00:00:10 <sipa> what OS?
00:00:18 <Eduard_Munteanu> Macs (and many other laptops) kinda have nasty keyboards.
00:00:32 <phao> me? Linux
00:00:34 <phao> archlinux
00:01:03 <sipa> you could define your own keymap then :)
00:01:20 <Eduard_Munteanu> I hate keyboards with no (or hard-to-access) keys like Home, PgUp, PgDn.
00:02:00 <Axman6> phao: you could always use (let lambda x = blah blah x in lambda) if you wanted
00:02:17 <phao> Axman6, what is that?
00:02:29 <applicative> do you need a language pragma to use unicode lambda? 
00:03:15 <Axman6> yeah
00:03:29 <Axman6> phao: that defines a function called lambda
00:03:50 <Axman6> > map (let lambda x = x*x+2*x in lambda) [1..10]
00:03:51 <lambdabot>   [3,8,15,24,35,48,63,80,99,120]
00:04:30 <Axman6> > map (\x = x*x+2*x) [1..10]
00:04:31 <lambdabot>   <no location info>: parse error on input `='
00:04:36 <Axman6> > map (\x -> x*x+2*x) [1..10]
00:04:36 <lambdabot>   [3,8,15,24,35,48,63,80,99,120]
00:05:20 <Eduard_Munteanu> #define lambda \\         -- might also do
00:05:46 <Eduard_Munteanu> (but you need to turn on CPP)
00:05:47 <applicative> >  let lambda n = n + 1 in lambda 3
00:05:48 <lambdabot>   4
00:07:06 <applicative> phao, this is an excellent motive to study pointfree programming!
00:07:15 <Eduard_Munteanu> Heh.
00:07:26 <phao> pointfree programming?
00:07:40 <Eduard_Munteanu> @pl \x -> x*x + 2*x
00:07:40 <lambdabot> ap ((+) . join (*)) (2 *)
00:07:50 <Eduard_Munteanu> Much more readable :P
00:07:57 <Axman6> applicative: no it is not, shoosh!
00:08:02 <Axman6> pointfree--
00:08:34 <rumbold1> how do i remove breakpoints in leksah?
00:08:46 <applicative> @pl \x -> \y -> x + y
00:08:46 <lambdabot> (+)
00:08:59 <applicative> @pl \x -> \y -> \z -> ( x + y ) * z
00:08:59 <lambdabot> ((*) .) . (+)
00:09:16 <applicative> look mom, no lambdas
00:09:26 <hamishmack> rumbold1: Right click in the breakpoints window.
00:09:27 <Eduard_Munteanu> That looks like disproportionated boobs.
00:10:12 <rumbold1> breakpoints window?
00:11:43 <rumbold1> ah i found it
00:28:11 <Eduard_Munteanu> Just checking... a zipper over a structure T is Z = (dT, T)?
00:28:57 <Eduard_Munteanu> Um, Z = ([dT], T).
00:29:44 <Eduard_Munteanu> And by intuition, "integrating" [dT] in the context of T gives the original structure?
00:30:32 <Eduard_Munteanu> ddarius gave me an example using that kind of Z for tree.
00:30:40 <Eduard_Munteanu> *tress
00:30:44 <Eduard_Munteanu> Argh, trees.
00:43:52 <Palmik> div 9 5
00:44:49 <Palmik> > (div 9 5)
00:44:49 <lambdabot>   1
00:44:54 <Palmik> > (div 9 (-5))
00:44:55 <lambdabot>   -2
00:45:03 <Palmik> heh :D
00:47:22 <Palmik> can someone explain why is that? first I thought that div does some rounding, but then I would expect (div 9 5) to be == with (-(div 9 (-5)))
00:47:34 <blueonyx> > -5 * 2
00:47:34 <lambdabot>   -10
00:48:17 <Palmik> > 5 * 2
00:48:17 <lambdabot>   10
00:48:22 <Palmik> so? :)
00:49:24 <blueonyx> > rem 9 (-5)
00:49:25 <lambdabot>   4
00:49:32 <blueonyx> > rem 9 (5)
00:49:33 <lambdabot>   4
00:50:28 <blueonyx> i dunno xD
00:51:09 <Eduard_Munteanu> Palmik: div x y = [x / y]  where '/' is proper division, and [] is the integral part.
00:51:44 <Palmik> yes... 9 / 5 is 1.8
00:52:02 <Palmik> and 9 / (-5) is (-1.8)
00:52:04 <Palmik> so?
00:52:26 <Eduard_Munteanu> [x] is further defined as the greatest integer lower than or equal to x.
00:52:28 <Palmik> oooh
00:52:30 <Palmik> I see
00:52:32 <Palmik> yes
00:52:46 <Palmik> you are right :)
01:04:45 <blueonyx> ah
01:04:54 <blueonyx> > mod 9 (-5)
01:04:55 <lambdabot>   -1
01:04:57 <blueonyx> > rem 9 (-5)
01:04:58 <lambdabot>   4
01:05:20 <blueonyx> > let (x,y) = (9,-5) in  (x `div` y)*y + (x `mod` y) == x
01:05:21 <lambdabot>   True
01:06:11 <blueonyx> > let (x,y) = (9,-5) in  (x `quot` y)*y + (x `rem` y) == x
01:06:12 <lambdabot>   True
01:06:15 <blueonyx> :)
01:35:57 <Palmik> blueonyx, nice find :)
01:51:43 <okui_> > [1..100]
01:51:44 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
01:53:51 <sipa> > [1,3..101]
01:53:52 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
02:07:13 <phao> Hi. In imperative programming languages, it's many times needed to do a bunch of statements in a row (like setting a bunch of values, executing a bunch of subroutines, start-up stuff for example). How do you guys do this kind of stuff here in haskell? In scheme there is the begin operator
02:07:20 <phao> what is it here?
02:08:33 <basti_> "let"
02:08:48 <Eduard_Munteanu> There's 'do' for monads. But you'll have to be a bit more specific. Could you give an example?
02:09:01 <sipa> first of all: execution is lazy, so not necessarily in any order you specify
02:09:28 <sipa> secondly: there are things where you build a chain of computations, which at least looks to be applied sequentially
02:09:40 <sipa> and there is syntactic sugar in the form of 'do' for this
02:10:19 <phao> Eduard_Munteanu, I don't know how to be more specific. I was talking about executing a bunch of statements in a row
02:10:27 <phao> like given a list of statements, execute each of them
02:10:33 <phao> like a list of statements in C
02:10:38 <sipa> there is no such thing as a statement
02:10:42 <Jafet> You want to do imperative programming in Haskell? Sure, you can do that.
02:10:42 <phao> int i = 1; i++; printf("%d\n", i);
02:11:06 <phao> Jafet, not quite...
02:11:10 <Jafet> But do you want to do imperative programming in Haskell?
02:11:11 <sipa> forM (putStrLn . show) [1..]
02:11:20 <phao> no
02:11:34 <sipa> phao: you're thinking in an imperative way
02:11:43 <sipa> that's not a problem, and it's possible in Haskell
02:11:44 <phao> I'm not thinking about anything in special actually
02:11:47 <Jafet> Then ask a different question -- your question was more or less, "how do I program imperatively in Haskell?"
02:12:09 <sipa> phao: you should think about what the result should be, not about in what order to do things to get there
02:12:12 <phao> no... I asked for a way to execute a list of statements (or whatever you call it) in here
02:12:17 <phao> like...
02:12:27 <phao> execute (s1, s2, s3, s4)
02:12:36 <okp> phao: executing a list of statements is imperative programming
02:12:49 <phao> not in all cases.
02:13:01 <raek> phao: in functional programming languages, the expression is the building block, rather than the statement
02:13:15 <phao> defining 5 functions in a row and then calling all of them connecting them with some operators
02:13:26 <sipa> s1 >> s2 >> s3 >> s4 >> s5
02:13:26 <phao> is having 6 statements being executed.
02:13:29 <sipa> that'll do
02:13:38 <sipa> or
02:13:47 <sipa> do { s1; s2; s3; s4; s5 }
02:13:55 <Jafet> Okay phao; what is a statement?
02:14:05 <sipa> but that's syntactic sugar for building an action from smaller actions
02:14:07 <Jafet> And what does it mean to execute statements?
02:14:10 <sipa> not exectuing them necessarily
02:14:31 <nCdy> Hello
02:14:33 <phao> Jafet, I don't know enough of haskell to know that actually... I was saying statement thinking of what it means in C or php, or any other language.
02:14:47 <nCdy> How can I select only one login ? :) http://hpaste.org/42461/login
02:14:52 <phao> Hoping that someone would understand and pick the "closest translation"
02:14:56 <nCdy> with seq.filter
02:15:05 <sipa> phao: i've given you a translation
02:15:14 <phao> sipa, =) yeah.. that's what I was thinking about
02:15:24 <phao> Jafet, but executing the statement is doing what is in it
02:15:39 <phao> foo bar = bar * 2 -- executing this would mean defining foo to be a function ....
02:15:59 <Jafet> Translating concepts like that is like translating a Polish novel word-for-word to Mongolian. It doesn't work.
02:16:18 <Jafet> If you want us to illustrate it, give an example of what you want to do.
02:16:32 <phao> I think this makes more sense in scheme because it has set! and can do imperative programming explicitly
02:16:48 <phao> well
02:16:55 <phao> imagining outputing something to a file.
02:17:02 <phao> I'd have to write the output and flush the file.
02:17:03 <okp> phao: in haskell you have functions, which are evaluated when their result is needed, and io actions (which seems to be what you mean by a statement), which can be chained together by do or >> and then run
02:17:06 <phao> to the output*
02:17:11 <phao> those are two steps.
02:17:34 <phao> okp, right
02:18:07 <Jafet> And you also have other things that aren't modelled on functions or actions
02:18:12 <phao> okp, I never thought about it before, but imperative programming seems to be MUCH related to I/O.
02:18:26 <phao> Jafet, yes... I don't know enough of IO to tell all the actions actually.
02:18:29 <Jafet> For files, there is the IO monad, which lets you chain IO actions together
02:26:08 <sipa> phao: if you want to do imperative programming in haskell, you can do everything inside the IO monad, and it's pretty powerful too
02:26:15 <sipa> but you'll miss out on the nicest features :)
02:27:54 <phao> heh
03:13:03 <pastorn> This was annoying... so i'm parsing binary data (animate sprites)
03:13:28 <pastorn> but in one animated sprite the same image can occur many times and is then only saved once
03:14:24 <pastorn> So i want to save the actual image data (ByteString) together with that frames metadata
03:14:38 <pastorn> but i'm using Attoparsec :/
03:15:06 <Eduard_Munteanu> How does Attoparsec make a difference there?
03:16:29 <pastorn> so basically a file looks something like this: [ meta0 { frames = [A,B,C], offsets = [P,Q,R] }, meta1 { frames = [C,D,E], offsets = [R,S,T] } ]
03:17:23 <pastorn> a "frame" here is just an identifying name, Offset is bytes from start of file (but i can keep track of where i am, so it's ok)
03:17:50 <pastorn> my problem is that when i want to parse the data for meta1 i have already consumed frame C at R
03:18:31 <pastorn> Eduard_Munteanu: only in the fact that it's a monadic parser and that i can't seek
03:18:48 <sipa> can't you store it somehow and reuse it?
03:18:54 <sipa> (i don't know attoparsec)
03:19:01 <pastorn> sipa: have you used parsec?
03:19:03 <sipa> yes
03:19:11 <pastorn> ok, well, it's the same
03:19:15 <sipa> there seems no point in wanting to parse something twice anyway
03:19:26 <pastorn> true...
03:19:35 <sipa> keep a map
03:19:38 <pastorn> oh, i'm feeling this will get messy
03:19:42 <sipa> as user state
03:20:17 <pastorn> StateT (Map Identifyer ByteString) Parser
03:20:28 <pastorn> *fier
03:20:41 <monadic_kid> pastorn: funny I'm actually doing almost the exact same thing as you but with xml
03:20:47 <monadic_kid> pastorn: right now
03:20:51 <sipa> parsec allows for a user state in the parsec itself as well
03:20:56 <sipa> *parser
03:21:01 <monadic_kid> pastorn: this for a sprite sheet?
03:21:18 <pastorn> monadic_kid: have you come up with anything good? i'm thinking of just parsing all the metadata in one pass, then just seek like crazy
03:21:28 <pastorn> then i'll optimize when i see the need for it
03:21:58 <pastorn> sipa: yeah, but this is attoparsec
03:23:19 <pastorn> it would be *really* annoying, since first i'll have to concatenate each sub-animation (one sprite for one specific thing contains all animations needed for that object) by offeset, then group them by their offset, do the loading, and then put them back in their original order
03:23:39 <pastorn> and i don't really know how to do that last
03:24:49 <pastorn> monadic_kid: have you come up with anything clever? i was thinking of intermediate structures holding everything but the payload
03:24:59 <monadic_kid> pastorn: i'm still typing
03:25:03 * pastorn wants records with inheritance
03:25:26 <pastorn> well, extendable records...
03:28:44 <pastorn> monadic_kid: what about if each record that i return from the parser is a function? parseFrame :: Parser ((ByteString -> Frame), Offset), and then once i'm done i could just do some seeking
03:28:48 <monadic_kid> pastorn: I used a tool to generate sprite sheet(s) from a number of images, it's a pluggable system, it comes with an xml exporter file iwith key value pairs, values being rects. This doesn't take into account animated sprites so until I can bothered to write a tweaked/custom exporter plugin I'm just encoding the frames with the name. Parsing I'm not doing much particularly fancy, each time I hit an element i read the key value into a Data.
03:28:48 <monadic_kid> Map of sring [Rect], I don't care so much how long it takes because it's just one time init when the game starts up. I'm not sure why you want to focus on making that optimal
03:29:45 <pastorn> monadic_kid: well, there's a *lot* of data
03:30:13 <monadic_kid> pastorn: how many elements roughly?
03:30:44 <pastorn> 2565 sprites... and the average 4~30kb
03:30:49 <pastorn> *they
03:31:12 <pastorn> so each will probably have to be loaded dynamically upon useage
03:32:01 <pastorn> all the graphics is 300 MB in its packed format
03:32:14 <pastorn> and then there's sounds on top of that
03:33:59 <pastorn> monadic_kid: how about if each contains an IORef to the data? Then, even if i load it twice i'll be ok
03:35:29 <pastorn> hmm... a Map will probably do... then i could just look in that first, if it's there i'll just point the data to it otherwise i'll do the loading
03:36:10 <Nibble> Anyone here interested in maintaining ghc for arch linux?
03:38:53 <sipa> pastorn: does attoparsec support resetting the data stream?
03:39:43 <sipa> otherwise you could store the (lazy?) data from the file in the user state, and for parsing seek to somewhere in there as input, and return afterwards
03:39:46 <sipa> seems like a hack though
03:40:43 <pastorn> sipa: hmm... i could perhaps cheat with try
03:41:59 <pastorn> do { meta <- try (parseMeta >> fail); parsePayloads (sortingMagic meta) }
03:45:23 <monadic_kid> pastorn: so you're dealing with about 10mb of sprite data (excluding the image data), that is such a tiny amount and the number is small really, you should not have any performance issues with those numbers. I don't understand why you're storing byte offset into the image file instead of using rects for which you can blit sub parts of the sprite imagine using those rects.
03:45:41 * hackagebot uu-parsinglib 2.5.6 - Online, error-correcting parser combinators; monadic and applicative interfaces  http://hackage.haskell.org/package/uu-parsinglib-2.5.6 (DoaitseSwierstra)
03:46:43 <pastorn> monadic_kid: so you suggest i load all 200 MB of data into memory on start-up?
03:47:25 <pastorn> monadic_kid: also, whit is "blit"?
03:47:37 <pastorn> i've seen that a bit lately but i don't understand what it is :/
03:48:44 <monadic_kid> pastorn: Well I'm talking about the metadata but yes even 300MB, if it's really an issue you can still virtualize the image data but the sprite meta-data is so insignificant.
03:49:32 <monadic_kid> pastorn: What graphics library are you using?
03:49:39 <pastorn> monadic_kid: none yet
03:49:43 <pastorn> this is all library stuff
03:49:53 <pastorn> monadic_kid: http://wiki.enleth.com/homm:homm3-def-animations
03:51:37 <monadic_kid> pastorn: you're not familiar with the term surfaces?
03:51:55 <pastorn> not all too familiar, no
03:52:05 <pastorn> i was thinking of doing a GTK viewer after this is done
03:54:09 <pastorn> monadic_kid: so my idea was that i should just load the data and unpack it from its RLE format with the library, then some other program (which focuses on the payloads) formats it to fit with whatever needs it has
03:56:02 <monadic_kid> pastorn: okay a surface is a pixel buffer that can be created in VRAM, system memory, etc. Blitting is term used to mean copying one surface onto another Surface, it's typically done in hardware and is very fast, when you have reference to a screen it is also just a surface so you can blit surfaces onto it. Blit routines usually support blit sub-areas (using offsets) and is still extremely fast operation. So with sprite sheets you typically
03:56:02 <monadic_kid>  do blitting sub-areas on the screen back buffer surface (and flip buffers) or blit sub-areas to other surfaces.
03:57:13 <pastorn> monadic_kid: ah, so as long as i do front-to-back i just blit with direct-bode graphics and it all works magically?
03:57:22 <pastorn> *BACK-to-FRONT*
03:57:28 <pastorn> obviously ;)
04:00:06 <monadic_kid> pastorn: they can also deal with transpacey using different techniques, simplest fastest being key coloring which bascially means you pick colour that represents a background colour you want treat as transparent and don't care about
04:00:47 <monadic_kid> pastorn: so that when you blit that one onto the dst surface the background on the srce doesn't exist
04:01:05 <silbo> yo
04:01:23 <Eduard_Munteanu> silbo: hi
04:01:28 <pastorn> monadic_kid: ok, but what happends on an animation? i don't have to do any clean-up fram last frame right?
04:01:31 <silbo> how do I match a string length
04:01:48 <pastorn> the front-to-back-drawing strategy will paint over old stuff?
04:02:00 <pastorn> or am i always painting on BGCOLOR?
04:02:25 <monadic_kid> pastorn: yep and you key use key-colouring (other transparency techniques) to do layering
04:02:41 <silbo> Eduard_Munteanu: any idea?
04:02:47 <Eduard_Munteanu> silbo: if you're referring to pattern matching, you can't. But you can use guards, or case / if-then-else constructs.
04:03:22 <Eduard_Munteanu> (you can using pattern-matching, but it's something like matching on a:b:c:[], not some arbitrary number)
04:03:44 <Eduard_Munteanu> :t length
04:03:45 <lambdabot> forall a. [a] -> Int
04:04:01 <Eduard_Munteanu> Can you be more specific?
04:04:20 <monadic_kid> pastorn: for animation you can store the image offsets into the sprite sheet, have an integer representing the current frame into the list of offsets and then blit that to the screen back buffer
04:05:38 <monadic_kid> pastorn: you don't need duplicate any image data, but for things like breakable that look different for each instance you can make seperate new sufaces for those
04:06:04 <monadic_kid> pastorn: like the breakable walls in Space invaders
04:07:05 <pastorn> hmmm... any libraries that support indexed colors?
04:08:07 <monadic_kid> pastorn: there is a single barrier sprite in an sprite sheet, in space invaders there are 4 barriers each one can break up individually so make 4 new surfaces the size of that one offset for the barrier then blit the barrier from the sprite sheet surface onto the 4 new surfaces, then you can do pixel collision dection and slowly destroy that wall
04:09:10 <pastorn> 4 surfaces in RAM?
04:09:17 <monadic_kid> pastorn: in vram
04:09:29 <monadic_kid> pastorn: the size of that sub-area in the sprite sheet
04:09:44 <monadic_kid> pastorn: or system ram
04:09:46 <pastorn> yeah, but how do i have individual "breakage" on the barriers?
04:10:18 <pastorn> do i have a "breakage" mask in RAM which i just blit over with alpha if broken?
04:10:41 <pastorn> (blit into the framebuffer)
04:11:37 <monadic_kid> pastorn: do a cheap bounding box test, find the barrier the bullet collides with then do pixel manipulation or yeah maybe you can use bit mask
04:11:49 <Eduard_Munteanu> The mask you're probably talking about is called a stencil buffer I think.
04:12:00 <Eduard_Munteanu> Why not use something like OpenGL for this?
04:12:28 <Eduard_Munteanu> (or rather some actual engine, like SDL)
04:12:48 <pastorn> Eduard_Munteanu: i'm thinking of GTK with OpenGL surface
04:13:01 <Eduard_Munteanu> That's okay I guess.
04:13:05 <monadic_kid> Eduard_Munteanu: OpenGL api and termonology isn't particularly great for doing 2D games if you don't know how 3D graphics pipelines work, i'd recommend something like SDL
04:13:40 <Eduard_Munteanu> I suppose you can get SDL to play nicely with GTK.
04:13:43 <monadic_kid> Eduard_Munteanu: with opengl you'd have use textures and othographic views, you'll end up writing an API over it
04:13:54 <Zao> monadic_kid: SFML is quite good, but I doubt it has Haskell bindings.
04:14:16 <Eduard_Munteanu> Yeah, I'd avoid using OpenGL directly
04:14:55 <pastorn> what's more portable? opengl or sdl?
04:15:04 <monadic_kid> pastorn: they are both portable
04:16:29 <monadic_kid> pastorn: OpenGL is for 3D graphics only, SDL is low-level simple cross-platform API over different things like input devices, graphics, sound, etc
04:16:37 <Eduard_Munteanu> SDL can use OpenGL or some other APIs though.
04:16:56 <Eduard_Munteanu> So it abstracts that part allowing even software rendering.
04:17:21 <pastorn> heh, nice
04:17:56 <Eduard_Munteanu> Also, look if Cairo can be used for such stuff, I don't know much about it. But Cairo can use OpenGL too IIRC.
04:18:13 <pastorn> oh, and cairo runs on *everything*, right?
04:18:19 <Eduard_Munteanu> (although Cairo makes more sense for vector graphics)
04:18:30 <Eduard_Munteanu> It's bundled with GTK I think.
04:18:30 <ManateeLazyCat> http://prezi.com/r2lbb3lfomg5/playing-to-learn-math/ Looks nice.
04:18:39 <Eduard_Munteanu> SDL works on many platforms too.
04:19:07 <ManateeLazyCat> pastorn: You can use Cairo draw everything (widget, picture...etc).
04:19:23 <monadic_kid> pastorn: I don't think Cairo would be useful for you, unless you're specifically doing 2D game with vector graphics
04:19:23 <ManateeLazyCat> pastorn: You can use Cairo do everything you want.
04:19:34 <ManateeLazyCat> pastorn: What's you need?
04:20:00 <monadic_kid> ManateeLazyCat: it seems like it would be overkill for a game
04:20:06 <ManateeLazyCat> If want running some OpenGL code, gtkglext is choose.
04:20:26 <pastorn> and cairo seems very floating point-oriented
04:20:50 <ManateeLazyCat> pastorn: Yes, you need write you own high-level code.
04:21:16 <pastorn> SDL has a lot of functions that takes Word8, which is what i need
04:21:18 <ManateeLazyCat> monadic_kid: What are you talking about? I just login in, but i'm interested everything about Graphics. :)
04:21:41 <monadic_kid> ManateeLazyCat: he's doing a 2D game
04:21:51 <ManateeLazyCat> monadic_kid: Which platform?
04:21:52 <Eduard_Munteanu> I'm not sure, but I think he wants to render animations made of sprites.
04:22:12 <monadic_kid> yes he wants to use a sprite sheets for sprite animation
04:22:39 <ManateeLazyCat> If for mobile, i suggestion use Java, there have complete API that how to handle sprites.
04:22:47 <Eduard_Munteanu> Boo!
04:22:49 <ManateeLazyCat> Include, translate, convert, 
04:23:33 <monadic_kid> personally i think SDL and SFML would be the best, keep it simple and direct
04:23:34 <Eduard_Munteanu> (I imagine people in #java don't return the favor of suggesting others to use Haskell :P)
04:23:47 <ManateeLazyCat> Of course, any language can work, but you need write you own high-level API to handle sprites, Collision detection...etc.
04:24:08 <monadic_kid> but apparently there are no bindings for SFML
04:24:13 <ManateeLazyCat> Eduard_Munteanu: I just suggestion use Java for mobile game develop. :)
04:24:41 <Eduard_Munteanu> Yeah, I was joking.
04:24:45 <monadic_kid> ManateeLazyCat: depends on the game, android are pushing the ndk a lot more nowadays for serious games
04:25:45 * ManateeLazyCat I develop many J2ME commercial game 3 years ago..
04:26:22 * ManateeLazyCat Something like this: http://goo.gl/lcJF
04:26:41 <monadic_kid> ManateeLazyCat: it really depends on the game anyway
04:26:46 <ManateeLazyCat> monadic_kid: Yeap, Android game is interesting
04:27:25 <ManateeLazyCat> If just for fun, cairo is enough
04:28:18 <monadic_kid> ManateeLazyCat: my co-worker has suffered because of the garbage collector, he did not use object-pools and using unboxed arrays (even though I mentioned it) in the end he had to do a lot of work to undo that
04:29:09 <ManateeLazyCat> monadic_kid: yes, i use object-pools a lots, because GC is costly, you just have 800k memory in mobile phone.
04:30:20 <monadic_kid> even with the new concurrent garbage collector in android 2.3 with sub 3ms pasues that can still be expsenive depending on the game, say something like the new resident evil game on the 3DS, probably best of using ndk for something like that
04:30:26 <ManateeLazyCat> monadic_kid: I test the max number sprites, then build object-pool and not release those sprites, after sprites disappear, re-initial sprites's attribute
04:31:09 <ManateeLazyCat> monadic_kid: Yeap, best don't do GC, it's expsenive.
04:32:00 <ManateeLazyCat> And we don't do multi-threads in mobile game, it's unnecessary...
04:32:06 <monadic_kid> i think haskell is alot more better for being controlled than Java, a lot more options when it comes to using unboxed arrays, non-gc'ed memory etc
04:33:19 <monadic_kid> the android ndk 2.3 is interesting because you can do pure native apps now, that should make it a bit more easier to get an unregistered post of ghc going
04:33:36 <monadic_kid> *unregistered port of ghc
04:33:57 <ManateeLazyCat> monadic_kid: I heard some guys has develop haskell game on iphone and Android. :)
04:34:00 <monadic_kid> well easier to write bindings to the stuff you need to get going with haskell app on android
04:35:07 <monadic_kid> ManateeLazyCat: yep someone told me they had it done on here
04:35:57 <lars9> ManateeLazyCat: hi, do you know why haskell.org/gtk2hs is down?
04:36:02 <ManateeLazyCat> monadic_kid: It's really cool that run haskell game on iphone/android, i wonder how many memory they use. :)
04:36:48 <ManateeLazyCat> lars9: No idea. :)
04:37:02 <ManateeLazyCat> lars9: maybe haskell.org down
04:37:20 <lars9> haskell.org is redirected to haskell wiki
04:37:31 <lars9> but the domain name is still ok
04:37:31 <monadic_kid> ManateeLazyCat: i think jhc might be choice but unfortunately I couldn't get any complicated apps using bindings working correctly when i was using it for Wii-homebrew with SDL
04:37:41 <ManateeLazyCat> lars9: I remember haskell.org and haskell wiki host on different site.
04:37:48 <monadic_kid> ManateeLazyCat: *might be a better choice
04:37:50 <lars9> ah see
04:38:35 <monadic_kid> jhc makes it so trivial to make a cross-compiler going with it
04:38:36 <ManateeLazyCat> monadic_kid: If don't care memory, haskell is always the best choose everywhere. :)
04:38:50 <ManateeLazyCat> monadic_kid: Most haskell graphics library is binding low-level C library.
04:39:26 <dcoutts> lars9: haskell.org moved physical server, the gtk2hs site has not yet been moved. It'll likely move to the community.haskell.org server and we'll set up a redirect from the old location
04:39:55 <ManateeLazyCat> dcoutts: How about new server? ;p
04:40:00 <monadic_kid> ManateeLazyCat: yep but jhc is whoe-optimizing cross-compiler and has a few options with regards to memory management, different garbage collectors i think it's even possible to not use one
04:40:04 <dcoutts> ManateeLazyCat: note that the haskell wiki is still hosted on haskell.org
04:40:26 <dcoutts> ManateeLazyCat: the new server is up and running
04:40:54 <ManateeLazyCat> monadic_kid: Hmm, interesting, never use jhc.. :)
04:41:39 <lars9> dcoutts: so how to access gtk2hs now?
04:42:44 <dcoutts> lars9: the downloads or the website? the website is not currently available, though you can get at the old site at http://haskell.cs.yale.edu/gtk2hs/
04:42:51 <msieradzki> quicksilver, yesterday I asked about cabal and different GHC versions but param you gave me doesn't work: cabal -w --with-compiler=path-to-ghc
04:43:12 <dcoutts> msieradzki: -w is an alias for --with-compiler
04:43:16 <msieradzki> I saw example showing runhaskell Setup.hs --wiith-compiler=ghc... but I don't want to do that
04:43:18 <msieradzki> ok
04:43:25 <msieradzki> but cabal doesn't like it
04:43:54 <dcoutts> msieradzki: cabal install -w ghc-6.12.3   will work
04:44:10 <dcoutts> assuming you have ghc-6.12.3 on the $PATH
04:44:15 <dcoutts> otherwise give the full path
04:45:10 <msieradzki> it uses separate GHC library storages, right?
04:45:13 <msieradzki> yes it worked
04:45:19 <dcoutts> right
04:46:19 <msieradzki> well something happened I'm not sure if it uses it correctly yet, anyway I expected other options to work with -w
04:47:42 <msieradzki> cabal list -w GHC-7.0.1 pat -> list of packages matching pat vs packages installed in 7.0.1 storage
04:48:32 <hvr> ...what's this ghc warnings I keep getting with ghc-7: SpecConstr / Function `$j_s1vVp{v} [lid]' / has two call patterns, but the limit is 1 / ... ?
04:49:00 <hvr> is this something wrong with my code (and many libraries on hackage), or just ghc being chatty?
04:49:01 <monadic_kid> ManateeLazyCat: yeah I did some working with it at one point using exploited Wii and SDL, I managed to get some rects drawn on to the screen but then i hit a brick wall with jhc generate incorrect code for foreign pointers or something, if i had multiple foreign pointers it would overrite the address of the last one
04:49:07 <dcoutts> msieradzki: ah yes, cabal list does not have that flag, though really it should.
04:50:43 <pastorn> I'm using *nix with .cabal in $HOME. Where should i put my personal library?
04:51:05 <ManateeLazyCat> monadic_kid: I just use ghc. :)
04:51:50 <monadic_kid> ManateeLazyCat: i tried to make an unregistered port of ghc first but the wii-homebrew sdk is not fully posix compliant so that was to painful to pursue
04:52:36 <ManateeLazyCat> monadic_kid: Maybe you can get help from #ghc?
04:53:16 <monadic_kid> ManateeLazyCat: nah, the only way is to implement the posix functions it depends on, can't be arsed with that
04:53:30 <ManateeLazyCat> :)
04:54:40 <ManateeLazyCat> BTW, do you guys like the idea "update user script by Cabal" ? I mean after user "cabal install config-package", it will udpate *running* process value dynamic. 
04:56:03 <ManateeLazyCat> So after a haskeller build an awesome configre package, other non-haskell user can use cabal install configure package, don't like Emacs need knock code yourself, easy to share....
04:56:06 <dcoutts> ManateeLazyCat: deployment is an interesting issue, but I think cabal is covering enough ground as it is and we should spend our time doing what it does do better
04:57:02 <Eduard_Munteanu> You could have your app handle SIGHUP or something.
04:57:18 <ManateeLazyCat> dcoutts: I'm working on "compile cache server", integrate with cabal. User can send DBus message to *running* process after cabal install configre package. 
04:57:21 <Eduard_Munteanu> Then a script could notify it to reload configuration.
04:57:42 <ManateeLazyCat> dcoutts: Then can use ghc dynamic linking those configure value in runtime, don't need restart application.
04:58:16 <ManateeLazyCat> dcoutts: I will bring "TVar middle layout" between dynamic-linking thread and running application.
04:58:32 <ManateeLazyCat> dcoutts: So we can update configure value in runtime, but code fast as compile version. :)
05:00:05 <ManateeLazyCat> Eduard_Munteanu: Dynamic-Linking thread update TVar value, application always read value from TVar, so application can update itself in runtime, but not slow like interpreter that need check depend every time.
05:00:09 <dcoutts> that's great, you can provide a script with your program to do that
05:00:37 <dcoutts> I'm just saying that extending the cabal spec to cover this kind of deployment issue is not something to be done lightly
05:00:43 <dcoutts> it's complicated
05:00:49 <ManateeLazyCat> dcoutts: I plan use "HValue -> IO ()" update TVar value in runtime. :)
05:02:16 <ManateeLazyCat> dcoutts: I have alternative solution that read fixed confige path, something like ~/.manatee/config/andy.hs . And biggest disadvantage of this solution is i need fix depend problem of config/andy.o myself, and it's really easy to break if user don't know how to play Haskell.
05:03:04 <ManateeLazyCat> dcoutts: Though Cabal is not lightweight solution, but it's haven't depend problem once cabal install success. So i just need focus on packageName/moduleName/symbolName from ghc/cabal database...
05:03:48 <ManateeLazyCat> dcoutts: My idea is, haskell expert write awesome configre package, then other people just need cabal can use those confgire file, don't need write any code...
05:04:23 <ManateeLazyCat> dcoutts: Of course, i perhaps write some tools build config.cabal automatically, haskeller just need fill it's configure value.
05:05:45 <ManateeLazyCat> config.o is lightweight way, but it's easy to break. Looks how painful that Emacs newbine knock code self, and most newbine give up last.
05:07:02 <ManateeLazyCat> Another advantage of cabal is you can hack code at any place, just do "cabal install" after you finish. :)
05:07:10 <ManateeLazyCat> Any suggestion are welcome! :)
05:07:36 <glow_> may i ask. what purpose of haskell?
05:07:49 <masak> glow_: it's a programming language.
05:08:36 <masak> as such, it has the same purpose as C, FORTRAN, and Smalltalk: to build programs.
05:09:31 <ManateeLazyCat> glow_: Haskell is generic programming language, and take you into a new *awesome* world. :)
05:10:00 <glow_> can i use haskell for expert system or knowledge engineering?
05:10:17 <sipa> @faq can you use haskell for expert system or knowledge engineering?
05:10:17 <lambdabot> The answer is: Yes! Haskell can do that.
05:10:49 <masak> glow_: the answer to "Can I use [programming language X] for [task Y]?" is: yes.
05:10:59 <sipa> @faq can haskell do the dishes for you?
05:11:00 <lambdabot> The answer is: Yes! Haskell can do that.
05:11:08 <ManateeLazyCat> glow_: Haskell can do everything.
05:11:08 <glow_> wow. that nice. I think I want study more about haskell.
05:11:10 <Zao> sipa: If I'd only known.
05:11:16 <Zao> My dishes have been stale for weeks.
05:11:48 <ManateeLazyCat> glow_: Haskell have awesome mechanism on concurrent and parallel. 
05:12:18 * ManateeLazyCat Hmm, i use too many *awesome*, haha ... :)
05:12:32 <glow_> I think haskell more advance than prolog. :)
05:12:42 <masak> ManateeLazyCat: no, that's just how awesome it is :)
05:13:10 <masak> glow_: yes, in the sense that Prolog imposes a specific model on your execution.
05:13:26 <masak> but in that sense, BASIC is also more advanced than Prolog.
05:14:19 <glow_> Oh man. why I didn't know this. I just discover haskell few minutes ago.
05:14:37 <ManateeLazyCat> glow_: Haskell is new language open your mind. :)
05:14:55 <sipa> glow_: be warned, it may be very different from what you know or expect
05:15:17 <osfameron> haskell's (like the spanish inquistition's) cheap weapon is surprise!
05:15:21 <osfameron> *chief
05:15:40 <osfameron> though I guess it may be cheaper (amortized) due to laziness too
05:18:16 <Botje> surprise and fear!
05:18:31 <hpc> osfameron: the surprise need not be evaluated until it surprises someone
05:19:16 <ManateeLazyCat> :)
05:19:16 <ManateeLazyCat> That's true. :)
05:19:36 <glow_> haskell really amuse me.
05:20:04 <osfameron> hmm, you'd imagine that surprise would need to be evaluated to be surprising
05:20:13 <osfameron> unlike horror, which is better unevaluated
05:20:27 <osfameron> does this suggest that haskell is better at horror than thrillers?
05:21:11 <sipa> > let f = 1 : 1 : zipWith (+) f $ head f in f
05:21:11 <lambdabot>   Couldn't match expected type `[t]'
05:21:11 <lambdabot>         against inferred type `[a] -> [a]'
05:21:29 <sipa> > let f = 1 : 1 : zipWith (+) f $ tail f in f
05:21:30 <lambdabot>   Couldn't match expected type `[t]'
05:21:30 <lambdabot>         against inferred type `[a] -> [a]'
05:21:37 <hpc> :t zipWith
05:21:38 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
05:21:44 <sipa> > let f = 1 : 1 : zipWith (+) f (tail f) in f
05:21:45 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
05:22:06 <ManateeLazyCat> glow_: I suggest http://learnyouahaskell.com/
05:22:34 <Bynbo7> glow_: why so?
05:23:26 <glow_> thanks for information. ManateeLazyCat.
05:26:58 <Jafet> > fix ((0 :) . scanl (+) 1)
05:26:59 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
05:31:09 * hackagebot timeplot 0.2.13 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-0.2.13 (EugeneKirpichov)
05:31:28 <glow_> haskell so awesome! :)
05:33:10 * hackagebot splot 0.1.8 - A tool for visualizing the lifecycle of many concurrent multi-staged processes.  http://hackage.haskell.org/package/splot-0.1.8 (EugeneKirpichov)
05:34:53 <ski> masak : "specific model on your execution" ?
05:36:22 <masak> ski: Prolog has an execution model which involves tree searching and backtracking.
05:40:18 <glow_> masak: yes that true. 
05:41:17 <ski> masak : how is that that different from how we often reason about thunks forcing other thunks, in Haskell ?
05:41:48 <masak> maybe not that different. and maybe it's misleading to speak of "more advanced" as if it meant something. :)
05:42:00 <masak> above the line of Turin completeness, all cats are gray.
05:42:14 <masak> s/Turin/Turing/
05:42:38 <ski> (yes, because of various reasons, the order of solutions in Prolog is fixed, barring (compiler- or user-) optimizations that would change that .. but how about systems like e.g. Mercury, then ?)
05:43:10 <masak> I don't know anything about Mercury.
05:43:58 <ski> Mercury is a pure, statically typed and moded, logic (and functional) programming language, related to Prolog
05:44:38 <ski> (Mercury uses a similar method as Clean, to do I/O in a declarative way)
05:45:27 <ski> so, because goals can't have side-effects, we can reorder conjunctions (and the implementation does that all the time), and also disjunctions
05:46:16 <ski> (and there's no cut either, to make us have to recall exactly which search tree we're traversing how, to ensure predictable pruning)
05:47:17 <masak> sounds enticing.
05:47:24 <ski> (actually, goals can have side-effects, but the system keeps track of that (in types, and in syntax (syntactic salt) .. this is mostly used for FFI things, before making a declarative wrapper)
05:47:33 <ski> )
05:49:55 <ski> glow_ : i'm not sure if there's any expert systems in Haskell, but i wouldn't be that surprised
05:50:47 <ski> glow_ : i suspect that for some such things, a logic programming language might be to prefer though (or you'll implement part of one, inside Haskell)
05:52:35 <glow_> ski: I think haskell can do all that. For information I am bachelor of Information technology in Knowledge Management.
05:53:42 <Jafet> @hackage facts
05:53:42 <lambdabot> http://hackage.haskell.org/package/facts
05:53:52 <ski> glow_ : you can implement e.g. logic variables in Haskell .. but it might be simpler (and not as ugly) to just use a logic programming language .. that's all i'm saying
05:53:58 <ski> similarly with search
05:54:19 <Jafet> @hackage Facts
05:54:19 <lambdabot> http://hackage.haskell.org/package/Facts
05:54:48 <ski> glow_ : btw, if you're interested in Prolog as well, you might consider joining ##prolog
05:54:56 <ski> (.. and for Mercury, there's #mercury)
05:55:17 <bartavelle> let's say i want to profile a little program, +RTS -p shows all time is spent in "main", without giving details. I suspect optimization, is there a way to get more precise data ?
05:55:32 <ski> glow_ : in any case, imo, you should learn both Haskell and Prolog
05:55:36 <glow_> ski: thank you. you really helpful. :)
05:55:45 <Jafet> bartavelle, insert your own cost centers
05:55:52 <bartavelle> i'll google that
05:56:11 <beanmachine> bartavelle: you can compile with -auto-all to insert them all over the place
05:56:16 <beanmachine> and -caf-all for even more
05:56:31 <beanmachine> or you can use SCC pragmas
05:56:39 <bartavelle> i did : ghc -O2 --make cointoss.hs  -prof -auto-all -caf-all -fforce-recomp
05:57:13 <beanmachine> oh, weird
05:57:27 <bartavelle> indeed :)
05:57:55 <bartavelle> http://hpaste.org/42468/myprof
05:58:22 <bartavelle> do i have to compile all modules with such options to get the details on what's happening in them ?
05:58:28 <McManiaC> is there something like floor for Double ?
05:58:42 <bartavelle> i suppose so ...
05:59:23 <beanmachine> bartavelle: yes
05:59:26 <bartavelle> i just cabal install -p
05:59:30 <bartavelle> the modules
06:00:14 <Jafet> What's so demanding about tossing coins?
06:00:57 <bartavelle> haha :)
06:01:40 <bartavelle> it's fiding the best coin tossing strategy in a brute force manner, so that's slow when there is a few tosses
06:01:40 <beanmachine> bartavelle: I use profiling: True in my .cabal/config
06:01:54 <bartavelle> oh i didn't knew you could have a general config
06:02:01 <bartavelle> i should read the doc
06:02:06 <beanmachine> it will tell you where it is if you go cabal --help
06:03:03 <bartavelle> yeah i found it, this will prove useful
06:12:48 <blueonyx> > floor (3.4::Double)
06:12:48 <lambdabot>   3
06:13:19 <Jafet> I had no idea coin tossing could be so strategic
06:13:44 <ClaudiusMaximus> McManiaC: http://hackage.haskell.org/packages/archive/cmath/0.3/doc/html/Foreign-C-Math-Double.html#v:floor
06:14:25 <ClaudiusMaximus> assuming you're fed up with all that   fromIntegral . floor  stuff
06:14:32 <Jafet> :t floor
06:14:32 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
06:15:16 <ClaudiusMaximus> @karma- decodeFloat
06:15:17 <lambdabot> decodeFloat's karma lowered to -1.
06:15:40 <weebl> :r
06:15:41 <weebl> ups
06:18:10 <ski> @type decodeFloat
06:18:11 <lambdabot> forall a. (RealFloat a) => a -> (Integer, Int)
06:18:16 <ski> @type properFraction
06:18:17 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> (b, a)
06:20:05 <ClaudiusMaximus> ski: i'm trying to write a decodeFloat implementation, it's painful
06:20:29 <ClaudiusMaximus> > ( decodeFloat (1 :: Float) , decodeFloat (1 :: Double) )
06:20:30 <lambdabot>   ((8388608,-23),(4503599627370496,-52))
06:20:49 <ski> @src RealFloat
06:20:49 <lambdabot> Source not found. I am sorry.
06:22:54 <ski> ClaudiusMaximus : slightly curious -- write an implementation of it, for what type ?
06:22:57 <ClaudiusMaximus> i had one "almost working" in that (uncurry encodeFloat . decodeFloat) f == f, but it didn't meet the postcondition as specified in the report
06:23:12 <ClaudiusMaximus> so things like 'significand' returned garbage
06:23:33 <ski> @type significand
06:23:34 <lambdabot> forall a. (RealFloat a) => a -> a
06:23:58 <ClaudiusMaximus> ski: data DoubleDouble = DoubleDouble Double Double  where DoubleDouble a b  represents a + b  (a cunning trick to get more bits of precision)
06:24:00 <ski> @type encodeFloat
06:24:01 <lambdabot> forall a. (RealFloat a) => Integer -> Int -> a
06:25:15 <ClaudiusMaximus> ski: it will be lossy in any case, because there might be a large gap between the exponents...
06:25:19 <ski> i assume by `a + b' you really mean something more like : concatenated mantissa, concatenated exponent ?
06:25:53 <ski> or, hm ..
06:26:05 <ClaudiusMaximus> ski: it's more subtle, because IEEE has an implicit leading 1 bit
06:26:10 <ClaudiusMaximus> or something
06:26:17 <ski> *nod*
06:26:27 <ClaudiusMaximus> but basically it's to get more bits of precision while still using fast machine instructions
06:27:11 <ClaudiusMaximus> this is for the bindings i'm writing to libqd - which also implements a QuadDouble type
06:27:41 <ClaudiusMaximus> i wouldn't have bothered with RealFloat, except that Data.Complex requires it and atan2 is useful too
06:27:50 * ski . o O ( it might be nice if hardware had support for this, similar to how to use add-with-carry for fixed precision .. but maybe that's already the case ? )
06:28:59 <ClaudiusMaximus> and i probably would be better off using something more flexible like MPFR, but the bindings are broken (very strange interactions with GMP/GHC/garbage collection/ etc)
06:32:46 <ClaudiusMaximus> i wrote this to check that the postcondition holds:
06:32:50 <ClaudiusMaximus> let checkFloat :: RealFloat f => f -> Bool ; checkFloat f = case decodeFloat f of { (0,0) -> True ; (m, e) -> b^(d-1) <= abs m && abs m < b^d } where { b = floatRadix f ; d = floatDigits f }
06:33:36 <ClaudiusMaximus> my current attempt fails for  1-0.5**54
06:39:08 <ClaudiusMaximus> int-e: thanks for the hints two weeks ago, only now finding time to try to get it working
06:41:44 <ClaudiusMaximus> ski: if you're curious, http://crd.lbl.gov/~dhbailey/dhbpapers/arith15.pdf
06:54:58 <Boxo> /J 
06:54:58 <Boxo> nm
07:01:43 * hackagebot strptime 0.1.7 - Efficient parsing of LocalTime using a binding to C's strptime  http://hackage.haskell.org/package/strptime-0.1.7 (EugeneKirpichov)
07:04:44 * hackagebot splot 0.1.9 - A tool for visualizing the lifecycle of many concurrent multi-staged processes.  http://hackage.haskell.org/package/splot-0.1.9 (EugeneKirpichov)
07:10:47 * hackagebot splot 0.1.10 - A tool for visualizing the lifecycle of many concurrent multi-staged processes.  http://hackage.haskell.org/package/splot-0.1.10 (EugeneKirpichov)
07:26:55 * hackagebot timeplot 0.2.14 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-0.2.14 (EugeneKirpichov)
07:33:43 <Gracenotes> happy winter solstice everybody
07:37:55 <HugoDaniel> im reverting to ghc 6 :)
07:38:43 <jmcarthur> aw
07:38:52 * jmcarthur has both installed
07:39:56 <HugoDaniel> i can't work with ghc 7 because all my stuff uses the encoding package... so ill just w8 and use 6 until everything is nice with 7
07:42:25 <HugoDaniel> im sticking with the haskell platform :)
07:52:13 <beanmachine> > case Just ((), []) of ~(Just (y, x:xs)) -> y
07:52:14 <lambdabot>   *Exception: <interactive>:1:133-176: Irrefutable pattern failed for pattern...
07:52:20 <beanmachine> > case Just ((), []) of ~(Just (y, ~(x:xs))) -> y
07:52:21 <lambdabot>   ()
07:57:48 <monadic_kid> beanmachine a reference to the megadrive game?
07:58:52 <benmachine> monadic_kid: uhm, sort of
07:58:57 <tromp> >1.44**21
07:59:04 <benmachine> monadic_kid: a reference to what google used to try to correct 'benmachine' to
07:59:10 <benmachine> monadic_kid: which I assume it did because of the game
07:59:13 <tromp> >1.44^21
07:59:23 <monadic_kid> benmachine: heh
07:59:36 <benmachine> > let ((:) x xs) = [] in x
07:59:37 <lambdabot>   *Exception: <interactive>:1:137-151: Irrefutable pattern failed for pattern...
07:59:44 <benmachine> hmm, don't get the whole message
07:59:58 <benmachine> ghci> let (:) x xs = [] in x
07:59:58 <benmachine> *** Exception: <interactive>:1:5-17: Irrefutable pattern failed for pattern : x xs
08:00:07 <benmachine> that error message is somewhat hmm
08:07:17 <ski> ClaudiusMaximus : sorry, was away
08:13:45 <revenantphx> Well, my issue from last night had a pretty simple resolution.
08:13:51 <revenantphx> Cabal wasn't expanding out "~"
08:13:53 <revenantphx> :|
08:14:10 <HugoDaniel> i did 3 cabal installs
08:14:17 <HugoDaniel> and haxml got installed 3 times
08:14:19 <HugoDaniel> ...wtf ?
08:16:15 * hackagebot nntp 0.0.4 - Library to connect to an NNTP Server  http://hackage.haskell.org/package/nntp-0.0.4 (MaciejPiechotka)
09:08:06 <Hilbert> Hey what does @ do in haskell?
09:08:37 <revenantphx> :t (@)
09:08:38 <lambdabot> parse error on input `@'
09:08:39 <revenantphx> :\
09:08:43 <revenantphx> oh
09:08:45 <revenantphx> you mena like
09:08:53 <revenantphx> a@(b, c)
09:09:24 <revenantphx> If thats a pattern match to a tuple,
09:09:30 <akamaus> here it allows you to match the whole tuple as well as it's parts
09:09:33 <revenantphx> then b and c are matched to the two elements each, and a to the entire tuple.
09:09:37 <Hilbert> I'm reading learn you a haskell and it uses xs@(x:y:ys)
09:09:48 <revenantphx> Yeah, so 'xs' is bound to the entire list.
09:09:53 <revenantphx> x to the first element
09:09:55 <revenantphx> y to the second
09:10:00 <revenantphx> ys to the remaining ones.
09:10:19 <Hilbert> Oh makes sense now
09:10:36 <Hilbert> Thnaks
09:10:43 <Hilbert> *Thanks
09:12:31 <Hilbert> Why doesn't ( xs ++ ys) make sense in pattern matching where xs and ys are lists
09:12:53 <Darkenor> Does anyone know why haskell functions can't have dashes in the name? 
09:13:19 <Darkenor> ex: "mod-function"
09:13:34 <Ke> I guess those are reserver for operators
09:13:58 <Darkenor> Ya, I guess that's the reason.
09:14:06 <monadic_kid> Hilbert: ++ is function not a data constructor, you need to use an extension to be able to use functions in pattern matching
09:15:12 <cde> Ke: right
09:15:14 <monadic_kid> Hilbert: there is also type operators extension so you can use operators in data & type constructors
09:15:19 <cde> Ke: http://sphinx.pocoo.org/
09:15:23 <kmc> Darkenor, that parses as mod minus function
09:15:24 <cde> it's not just for python though
09:15:52 <Hilbert> monadic_kid: Thanks I will have to read about them
09:16:09 <kmc> i think monadic_kid refers to the "view patterns" extension, but it doesn't really do what you want
09:16:09 <Darkenor> kmc: It's interesting to me that the compiler can't differentiate between a function name and body
09:16:17 <kmc> what do you mean?
09:17:17 <monadic_kid> Hilbert: so yeah the trict question is that data constructors are no different functions
09:17:29 <monadic_kid> Hilbert: *no different than functions
09:17:32 <revenantphx> Darkenor: ???
09:17:56 <kmc> data constructors can be applied like ordinary functions, but you can also pattern match against them, which you can't with ordinary functions
09:18:32 <kmc> Hilbert, if you say "data Foo = Bar Int | Baz String", then the "primitive" patterns for a value of type Foo are only (Bar x) and (Baz y)
09:19:07 <kmc> if you define some function that returns a Foo, you can't use it in place of "Baz"; the compiler can't always know how to invert your function, and the inverse might not be unique or defined
09:19:16 <kmc> if you *can* write the inverse yourself, then you can use ViewPatterns
09:19:36 <Darkenor> revenantphx: what I mean is that given a function like, eh say - mod-function:: (Integral a) => a
09:20:01 <kmc> that's not a legal name for a function
09:20:03 <Darkenor> revenantphx: I would think that the compiler would realize that mod-function is just a name and that - isn't an operator there
09:20:16 <kmc> this isn't an issue of what the compiler can do technically
09:20:17 <Darkenor> ya, I know- I'm just saying I'm surprised it has a problem with taht
09:20:20 <revenantphx> But - isn't in the characters it considers valid for function names.
09:20:22 <Darkenor> ya?
09:20:24 <kmc> Haskell is a standard language
09:20:33 <revenantphx> It could do it, but it's not standard to have - in function names.
09:20:37 <kmc> the standard says that function names are alphanumeric plus _ and '
09:21:02 <Darkenor> hmm, ok - so there's a standard for function names and it expects you to adhere to it
09:21:09 <kmc> there is a standard for the whole language
09:21:25 <Darkenor> So, dumb questIon: where is that standard? :)
09:21:26 <kmc> http://www.haskell.org/onlinereport/haskell2010/
09:21:27 <monadic_kid> Darkenor: are you coming from a scheme/lisp background?
09:21:36 <Darkenor> c++
09:21:46 <monadic_kid> Darkenor: well you can't do that in c/c++
09:21:47 <kmc> there's a standard for C++ too...
09:21:53 <kmc> and it says you can't use - in function names
09:22:04 <kmc> i wouldn't say "why can't g++ realize that i meant to use it as part of the name"
09:22:11 <kmc> it could, but then it wouldn't be a C++ compiler
09:22:28 <Darkenor> monadic_kid: are you sure? I'm fairly certain I've used dashes in visual studio (I know - I'm the evil enemy who devs on Windows) 
09:22:44 <ClaudiusMaximus> > let a=3;b'c=2 in a-b'c
09:22:45 <lambdabot>   1
09:22:54 <kmc> GHC implements many extensions to the Haskell standard, but (with very few exceptions) they must be enabled explicitly
09:23:00 <Darkenor> kmc: thanks for the link :)
09:23:39 <BONUS> quick question: (x,y) or (x, y)?
09:24:07 <kmc> if they're actually just variables i'd use the former
09:24:08 <c_wraith> I go with the latter.  But I like whitespace.  most of the time.
09:24:10 <monadic_kid> Darkenor: you can not use dashes as part of identifiers
09:24:10 <revenantphx> I prefer ( x , y )
09:24:17 * revenantphx troll
09:24:36 <revenantphx> I think I prefer the latter
09:24:37 <c_wraith> my company's ceo prefers randomly using spaces or not :)
09:24:53 <ClaudiusMaximus> revenantphx: i prefer ( x\n, y\n)
09:25:02 <monadic_kid> Darkenor: you can however do tricks with operator overloades to emulate that but someone would probably beat you if you did that in a real project
09:25:08 <Darkenor> monadic_kid: Ya, I just checked and you're right - even MS confirms it
09:25:09 <Darkenor> http://msdn.microsoft.com/en-us/library/565w213d.aspx
09:25:22 <Darkenor> I guess I just never did it before, lol
09:25:24 <kmc> {- opening parenthesis of the pair: -} ( {- first element of the pair -} x {- separator between the two elements of the pair -} , {- second element of the pair -} y {- closing parenthesis of the pair -} )
09:25:30 <kmc> jeez didn't you ever learn to comment your code?
09:26:17 <Darkenor> Thanks for setting me straight
09:26:44 <monadic_kid> Darkenor: Scheme/lisp allow dashes in identifiers
09:26:44 <kmc> genericPolymorphicHeterogeneousBinaryContainerFactory :: a -> b -> (a,b); genericPolymorphicHeterogeneousBinaryContainerFactory = (,)
09:26:47 <revenantphx> You forgot to comment the end of the line kmc.
09:27:19 <allbery_b> if the compiler and IDE are unicode-enabled you can probably use any of several hyphen-like characters in identifiers
09:27:33 <kmc> no, because they won't be in the alphanumeric unicode character classes
09:27:36 <kmc> or did you mean in C++?
09:28:52 <revenantphx> hngh.
09:29:00 * ManateeLazyCat In elisp, I remember i can use Chinese (unicode) as function/variable identifiers
09:29:01 <revenantphx> brew installed it's version of glib and gettext as x86_64
09:29:08 <revenantphx> figures that ghci is looking for a 32bit one.
09:29:19 <ManateeLazyCat> revenantphx: Your problem fix?
09:29:24 <kmc> figures if your ghci is 32-bit, yes
09:29:33 <kmc> what's brew?
09:29:39 <revenantphx> It's an OS X package manager.
09:29:53 <revenantphx> ManateeLazyCat: no, I didn't fix that one with X11
09:30:46 <ManateeLazyCat> revenantphx: Axel suggest you use $HOME/.cabal/bin instead ~/.cabal/bin on Mac, still can't work?
09:30:53 <revenantphx> Oh, that fixes the gtk issue.
09:31:12 <revenantphx> The gtk2hsC2hs works fine now.
09:31:13 <ManateeLazyCat> revenantphx: If gtk can install correctly, glib should be. 
09:31:20 <revenantphx> Yes the glib package is fine.
09:31:24 <ManateeLazyCat> revenantphx: Good to heard that. :)
09:31:31 <revenantphx> gettext is installed as 64bit only though
09:31:35 <ManateeLazyCat> revenantphx: So ~ is not HOME on Mac ?
09:31:40 <revenantphx> I need to install it again as 32bit/64bit
09:31:42 <revenantphx> ManateeLazyCat: it is.
09:31:48 <revenantphx> but cabal doesn't resolve it.
09:31:54 <ManateeLazyCat> revenantphx: Oh i see. :)
09:32:48 <luite> > let fakehyphen = "it works" in fakehyphen
09:32:49 <lambdabot>   "it works"
09:32:52 <luite> hmm
09:32:53 <revenantphx> kmc: https://github.com/mxcl/homebrew
09:32:57 <luite> does it really?
09:33:43 <kmc> > generalCategory ''
09:33:44 <lambdabot>   OtherLetter
09:33:47 <kmc> :O
09:33:50 <kmc> seems.... incorrect
09:34:06 <revenantphx> > generalCategory ''
09:34:06 <lambdabot>   MathSymbol
09:34:10 <ManateeLazyCat> @hoogle generalCategory
09:34:10 <lambdabot> Data.Char generalCategory :: Char -> GeneralCategory
09:34:10 <lambdabot> Data.Char data GeneralCategory
09:34:12 <Darkenor> Can someone explain why the "head" portion is necessary here? I believe it's because the [a] only supports a single variable when filter returns a list? But I was hoping for a more technical answer - (if someone has the time and patience.)?: modfunction = head (filter p [100000, 99999..])       where p x = x `mod` 3829 == 0
09:34:13 <revenantphx> generalCategory ' '
09:34:29 <kmc> Darkenor, head simply takes a list and gives you the first element of that list
09:34:32 <kmc> :t head
09:34:33 <lambdabot> forall a. [a] -> a
09:34:46 <revenantphx> Homebrew is just a nicer alternative to macports.
09:34:54 <kmc> Darkenor, and if the list is empty then head will crash and burn and kill your whole program with an unhelpful message, which is why we discourage its use
09:35:00 <revenantphx> It keeps everything inside /usr/local/Cellar (and keeps track of symlinks) so it's not as messy.
09:35:19 <kmc> Darkenor, the right way to get the first element of a list is pattern matching, which also forces you to consider (or at least consider considering) the empty case
09:35:34 <kmc> > case [1,2,3] of [] -> "empty"; (x:xs) -> ("value " ++ show x)
09:35:35 <lambdabot>   "value 1"
09:36:03 <Darkenor> ah - ok, so the best way is to setup cases for empty lists and then another case for "xs"
09:36:24 <kmc> "head" is only really appropriate if you know the list has to be non-empty
09:36:27 <ManateeLazyCat> > generalCategory ''
09:36:28 <lambdabot>   OtherLetter
09:36:31 <Darkenor> I did a :t test on filter and it looks like it returns (a -> Bool) -> [a] -> [a]
09:36:40 <kmc> but in those cases it's better to structure your code so that the non-emptiness is obvious to the compiler
09:36:40 <Nibble> head is only essential to C programmers
09:36:50 <kmc> Darkenor, that's the type of filter, yes
09:36:52 <kmc> :t filter
09:36:53 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
09:37:02 <Nibble> haskell programmers can concencate together their programs.
09:37:09 <ManateeLazyCat> Darkenor: filter return [a], head return a
09:37:12 <kmc> so "filter p :: [Int] -> [Int]" roughly
09:37:26 <kmc> so "filter p [100000, 99999..] :: [Int]"
09:37:43 <kmc> and then you use "head" to get a single int
09:37:48 <kmc> head :: [Int] -> Int
09:38:01 <ManateeLazyCat> > head []
09:38:02 <lambdabot>   *Exception: Prelude.head: empty list
09:38:08 <ManateeLazyCat> Darkenor: See ^^^ ?
09:38:25 <monochrom> head explosion :)
09:38:39 <ManateeLazyCat> > head $ filter (> 10) [1..5]
09:38:40 <lambdabot>   *Exception: Prelude.head: empty list
09:38:45 <ManateeLazyCat> Darkenor: See ?
09:38:45 <Darkenor> I'm "seeing" - I think. The return types in haskell are very difficult (at least for me) to figure out when compared to a c++ background
09:38:55 <kmc> what in particular is the difficulty?
09:39:08 <kmc> Darkenor, do you understand why we write "A -> B -> C" for a "two-argument" function?
09:39:30 <Darkenor> kmc, ya - that basically means (takes two arguments, a and b, and returns c"
09:39:36 <kmc> yes, except
09:39:37 <Darkenor> (a -> Bool) -> [a] -> [a]
09:39:41 <ManateeLazyCat> Darkenor: Use *recursive* think haskell function.
09:39:45 <kmc> there actually aren't any two-argument functions in Haskell
09:39:48 <kmc> every function has one argument
09:39:59 <kmc> and "A -> B -> C" is just shorthand for "A -> (B -> C)"
09:40:00 <luite> kmc: it does work as a haskell function name by the way
09:40:03 <Darkenor> this, as I understand it, means "takes a function with one argument and returns a bool, and then a number, then returns a number
09:40:22 <Darkenor> kmc: right, yes - I forgot that, it would be more
09:40:29 <kmc> that is, to implement a "two-argument function" you take one argument, and return a function which takes the second argument
09:40:36 <Darkenor> "takes an argument, then passes that to another function that takes an argument, then does that again"
09:40:46 <kmc> the type doesn't say anything about "passing"
09:40:48 <kmc> that's in the code
09:41:12 <kmc> so "A -> B -> C" is the same as "A -> (B -> C)", but "(A -> B) -> C" is something different
09:41:27 <Darkenor> heh - I guess that's what's confusing, I suppose. 
09:41:28 <kmc> "(A -> B) -> C" is the type of a function which takes a function as an argument and returns a C
09:41:34 <Darkenor> Let em read over what you just said and digest it for a second.
09:41:39 <kmc> furthermore the function it takes as an argument has to have type A -> B
09:42:27 <monochrom> types are hard because they're logical
09:42:31 <codeman> hey 
09:42:34 <kmc> it could be helpful to get comfortable with functional programming before assigning precise types to everything.  then again, the types can provide a lot of structure for learning
09:42:38 <scree> Darkenor: "takes a function with one argument and returns a bool, and then a number, then returns a number <-- if you mean (a -> Bool) -> [a] -> [a], it's quite important that [a] is a list, not a number
09:43:27 <Darkenor> scree: thanks for that
09:43:32 <codeman> I need help to uninstall...
09:43:39 <ManateeLazyCat> > filter (== 'a') "haskell"
09:43:40 <lambdabot>   "a"
09:43:48 <codeman> leksah
09:43:50 <ManateeLazyCat> Darkenor: ^^^ above is not just number.
09:43:53 <Darkenor> kmc: ok, you mentioned that (a -> b) -> c is different
09:43:55 <kmc> > filter (== 'a') "abracadabara"
09:43:56 <lambdabot>   "aaaaaa"
09:44:02 <kmc> Darkenor, yep
09:44:06 <Darkenor> that's where I think I'm having the gap, I believe.
09:44:07 <ManateeLazyCat> codeman: ghc-pkg unregister leksah
09:44:10 <kmc> you have to read type signatures outside-in
09:44:12 <Darkenor> a -> b - > c is pretty easy
09:44:23 <Darkenor> what does (a -> b) -> c mean exaclty
09:44:27 <Darkenor> *exactly
09:44:28 <kmc> well first recognize that (->) connects just two things
09:44:42 <kmc> "A -> B -> C" is merely shorthand for "A -> (B -> C)"
09:44:54 <kmc> "S -> T" means "function taking S, returning T"
09:45:13 <kmc> so "(A -> B) -> C" means "function taking (function taking A, returning B), returning C"
09:45:18 <Darkenor> oh, so "function A takes functions b returning c
09:45:43 <kmc> if "f :: (A -> B) -> C" and you're calling "f x" then "x :: A -> B"
09:45:53 <kmc> f is a function whose argument is a function
09:46:08 <codeman> hey any one know hotw to uninstall  Leksah from Mac and also remove all Cabal and its files ...need help to uninstall...
09:46:24 <Guest41469> @djinn (a -> b) -> c
09:46:24 <lambdabot> -- f cannot be realized.
09:46:27 <Guest41469> ;)
09:46:29 <ManateeLazyCat> codeman: You just can unregister it from ghc database
09:46:37 <revenantphx> hngh
09:46:41 <revenantphx> I'm having this exact issue.
09:46:41 <revenantphx> http://stackoverflow.com/questions/4317990/haskell-gtk2hs-no-suitable-image-found
09:47:03 <scree> @type (\f -> f 0)
09:47:03 <lambdabot> forall t t1. (Num t) => (t -> t1) -> t1
09:47:04 <revenantphx> But there's no indication on how to resolve it, since I can't figure out how to force homebrew to install it as i386 as well
09:47:31 <Darkenor> kmc: thanks! I just got it! :)
09:47:34 <kmc> nice :)
09:47:38 <Darkenor> kmc: haskell makes me feel retarded.
09:47:39 <Darkenor> lol
09:47:50 <codeman>  ManateeLazyCat:  i think all my config files are missing are currupted
09:48:05 <codeman> so i want to make a fresh install
09:48:15 <ManateeLazyCat> Darkenor: Not just you, me too when i first study Haskell.
09:48:44 <ManateeLazyCat> Darkenor: You will understand what's it when you confuse enough. :)
09:49:04 <Darkenor> haha :)
09:49:10 <ManateeLazyCat> codeman: cabal install leksah --install
09:49:13 <ManateeLazyCat> codeman: cabal install leksah --reinstall
09:49:26 <Darkenor> time to pick people up from the airport - christmas time. Thanks everybody, this channel rules.
09:49:39 <ManateeLazyCat> Darkenor: So just *feeling* it, you don't need understand all of them when you first time study it.
09:51:27 <codeman> anyone know of a uninstall pakage for leksah and all its sopportinglinks on a mac
09:52:28 <codeman> i know there are lots of hidden fills
09:53:40 <codeman> i
09:54:15 <codeman> [1..3]
09:54:27 <codeman> [1..]
09:58:05 <codeman> who
10:00:51 <haskell_father_o> hey
10:01:30 <haskell_father_o> i need  to remove Leksah
10:02:26 <iliketomato1234> if i define my own typeclass, how can i have an instance for List?
10:03:41 <scree> iliketomato1234: instance MyClass [a] where ...
10:04:13 <ManateeLazyCat> The faster of GFW's micro-blog is down
10:04:41 <haskell_father_o> ManateeLazyCat:are you on mac
10:04:47 <iliketomato1234> thanks, i should have thought of that scree
10:05:04 <scree> iliketomato1234: np
10:05:19 <ManateeLazyCat> Too many people comment, and administrator really really tired to delete comment, at last, shut down it's micro-blog.
10:05:22 <haskell_father_o> iliketomato1234 :are you on mac?
10:05:25 <ManateeLazyCat> haskell_father_o: I haven't Mac.
10:05:36 <ManateeLazyCat> s/faster/father
10:05:46 <ManateeLazyCat> The father of GFW
10:05:52 <iliketomato1234> although actually, now i'm getting a Kind mis-match
10:06:02 * ManateeLazyCat Damn slow English helper.
10:06:03 <haskell_father_o> ok .. my bloody Leksah installations is curupted
10:06:11 <kmc> iliketomato1234, does your type class take type constructors?
10:06:14 <kmc> like "Functor" does?
10:06:24 <iliketomato1234> kmc: i will paste the code, 1 sec
10:06:28 <kmc> in that case you'd write "instance MyClass []"
10:06:40 <kmc> if it's like "class MyClass f where foo :: f a -> Int"
10:06:50 <kmc> since you use "f" as "f a", "f" itself has to be a type constructor
10:07:56 <kmc> > [1,2,3] :: [] Int
10:07:57 <lambdabot>   [1,2,3]
10:08:06 <iliketomato1234> using [] works, thanks
10:11:59 * hackagebot applicative-quoters 0.1 - Quasiquoters for idiom brackets and an applicative do-notation  http://hackage.haskell.org/package/applicative-quoters-0.1 (BenMillwood)
10:22:55 <micahjohnston> I just discovered a really short quine: ((++)<*>show)"((++)<*>show)"
10:23:00 <micahjohnston> if anyone cares
10:23:01 <micahjohnston> :P
10:23:21 <jkff> Hey folks, is anyone apt with creating debian packages for haskell programs?
10:23:25 <jkff> (pun intended)
10:23:33 <kmc> i care micahjohnston, that's pretty cool
10:23:38 <micahjohnston> kmc: :D
10:23:39 <jkff> #debian-haskell is empty :(
10:23:43 <kmc> is there a "Quines" page on haskell wiki?
10:24:46 <monochrom> > ((++)<*>show)"((++)<*>show)"
10:24:47 <lambdabot>   "((++)<*>show)\"((++)<*>show)\""
10:24:51 <monochrom> nice
10:24:57 <micahjohnston> thanks :D
10:25:37 <kmc> > (text.((++)<*>show))"(text.((++)<*>show))"
10:25:38 <lambdabot>   (text.((++)<*>show))"(text.((++)<*>show))"
10:25:51 <micahjohnston> > putStrLn $ ((++)<*>show)"((++)<*>show)"
10:25:52 <lambdabot>   <IO ()>
10:25:58 <micahjohnston> :|
10:26:04 <monochrom> > putStrLn "<IO ()>"
10:26:05 <lambdabot>   <IO ()>
10:26:06 <monochrom> works
10:26:21 <kmc> > fix error
10:26:21 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
10:26:37 <micahjohnston> heh
10:26:51 <kmc> "that didn't fix anything!"
10:27:18 <monochrom> but oh boy does it err :)
10:27:40 <micahjohnston> > fix ("*Exception: "++)
10:27:41 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
10:28:13 <micahjohnston> > fix $ ((++)<*>show)"((++)<*>show)"
10:28:13 <lambdabot>   Couldn't match expected type `a -> a'
10:28:13 <lambdabot>         against inferred type `GHC.Ba...
10:28:26 <micahjohnston> > fix $ ((++)<*>show)
10:28:30 <lambdabot>   mueval-core: Time limit exceeded
10:28:55 <micahjohnston> > fix fix
10:28:56 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
10:30:24 <mauke> chturne: can I help you?
10:31:17 <jkff> > fix show
10:31:18 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
10:31:39 <micahjohnston> haha
10:38:52 <macrofix_> hi there?
10:39:10 <macrofix_> is it web programming language?
10:39:15 <Gracenotes> hello
10:39:39 <monochrom> no
10:39:59 <macrofix_> monochrom: where do u use this haskell programming lang?
10:40:02 <Gracenotes> haskell is a programming language which can be used to make web applications... er but not exclusively
10:40:16 <micahjohnston> mostly it's used for other stuff, I'd say
10:40:17 <monochrom> I use it on my computer.
10:40:44 <monochrom> I use it on my laptop. It's a mobile programming language.
10:40:57 <mauke> is it web scale?
10:41:05 <Gracenotes> to the cloud
10:41:27 <Gracenotes> well, you know, an mpi binding came out recently...
10:42:37 <macrofix_> i use ruby on rails for web development, And .NET for windows applications. simply can anyone guideme why should i use haskell and where do i use it?
10:42:39 <zaphar_ps> I use it in my editor :-)
10:42:42 <aristid> haskell is basically ruby, just completely different
10:42:44 <Gracenotes> haskell can be used for graphics, networks, scripting, cryptography, math (discrete and numeric), ...
10:43:06 <Gracenotes> implementing algorithms that are difficult to describe in languages like Java
10:43:11 <monochrom> you should see http://hackage.haskell.org/package/manatee especially the video and the screenshots
10:43:21 <mauke> you shouldn't use haskell
10:43:33 <Gracenotes> well stated mauke
10:43:58 <Gracenotes> @where lyah
10:43:58 <lambdabot> http://www.learnyouahaskell.com/
10:44:30 <minsa> haskell is real world is more windy ? 
10:44:37 <minsa> haskell in real world, I mean.
10:45:00 <monochrom> You should use whatever you like. You should find out what you like. What you like is probably not what you already know.
10:45:34 <mauke> learn the weaknesses of every programming language. what you don't know can kill you.
10:45:46 <aristid> monochrom: that does sound a bit wrong-ish, because people have a strong tendency to like what they know
10:45:47 <macrofix_> monochrom: i'm now using tryhaskell.org to explore. is tryhaskell.org is designed in haskell?
10:47:35 <monochrom> I have gone through several episode of meeting a new language and finding I like it better than my previous favourite languages. This tell me the wrong question is "why should I use this unknown language"; the right question is "why should I stick with my known languages".
10:47:52 <monochrom> And it's a rhetorical question too. The answer is "I shouldn't".
10:48:17 <BONUS> i think that one of haskell's attributes that people seem to underestimate the most is that it's just plain fun
10:48:30 <aristid> monochrom: no, the answer is "because learning new languages takes effort"
10:50:32 <zaphar_ps> BONUS: +1
10:53:12 <monochrom> Well then perhaps it's all just me.
10:54:09 <monochrom> I have a strong tendency to like what I don't know, as I've said. I used to like C++ and Perl too. I used to like Java too. I used to like OOP too.
10:54:37 <monochrom> Also I have found that learning takes me less and less effort.
10:54:51 <iliketomato1234> http://pastebin.com/MxL2U1HQ
10:54:59 <monochrom> Moreover all software works for me 100% of the time and this is also just me.
10:55:12 <iliketomato1234> i'm getting infinite type construction errors around line 15, no idea why
10:55:57 <benmachine> :t Data.Traversable.sequence
10:55:58 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Traversable.Traversable t, Monad m) => t (m a) -> m (t a)
10:56:14 * hackagebot lattices 1.2.1 - Fine-grained library for constructing and manipulating lattices  http://hackage.haskell.org/package/lattices-1.2.1 (MaxBolingbroke)
10:56:15 <c_wraith> iliketomato1234, do does not do anything even close to what you think it does.
10:57:22 <benmachine> c_wraith: huh? he looks like he's almost got it right to me
10:57:36 <c_wraith> but your problem is probably using x instead of result on line 19
10:57:37 <monochrom> "first <- x" is very disturbed
10:57:39 <benmachine> iliketomato1234: line 24 has a trivial error
10:57:52 <iliketomato1234> c_wraith: i could re-write that without do if i wanted, the purpose of that code is probably not what you think it is
10:58:04 <monochrom> err nevermind, "first <- x" is ok
10:58:08 <benmachine> heh
10:58:14 * hackagebot temporary 1.1.1 - Portable temporary file and directory support for Windows and Unix, based on code from Cabal  http://hackage.haskell.org/package/temporary-1.1.1 (MaxBolingbroke)
10:58:50 <c_wraith> :t Data.Traversable.sequence
10:58:51 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Traversable.Traversable t, Monad m) => t (m a) -> m (t a)
10:59:29 <c_wraith> That function looks a lot like your unwrap function :)
10:59:44 <iliketomato1234> c_wraith: i had no idea that existed, thanks :)
10:59:57 <c_wraith> iliketomato1234, it won't help you much, as you'd have to implement it anyway.
11:00:01 <benmachine> sure
11:00:02 <monochrom> unwrap $ map unwrap xs is not right
11:00:04 <benmachine> but it's nice to know anyway
11:00:08 <benmachine> monochrom: sure it is
11:00:12 <BMeph> :t Data.Traversable.sequenceA
11:00:13 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
11:00:27 <c_wraith> I'm pretty sure the problem is on line 19, where you use x instead of result
11:00:36 <benmachine> er, that's line 24
11:00:40 <c_wraith> giving you a = IO a
11:00:44 <c_wraith> which is an infinite type
11:00:50 <benmachine> oh wait
11:00:53 <benmachine> it's both
11:00:56 <c_wraith> oh, so it is
11:01:02 <iliketomato1234> ah yes, those errors on lines 24 and 19, trivial errors
11:01:07 <iliketomato1234> i clearly need more sleep
11:01:11 <benmachine> heh
11:01:15 * hackagebot graph-wrapper 0.1.1 - A wrapper around the standard Data.Graph with a less awkward interface  http://hackage.haskell.org/package/graph-wrapper-0.1.1 (MaxBolingbroke)
11:01:23 <iliketomato1234> it works now
11:01:30 <benmachine> if you'd used applicative style this particular mistake would be impossible ^_^
11:02:04 <c_wraith> iliketomato1234, just as a general diagnostic thing, an infinite type error generally means you used the wrong name somewhere
11:02:31 <iliketomato1234> c_wraith: thanks, i've also got those when using (:) instead of ++
11:02:40 <iliketomato1234> benmachine: what is applicative style?
11:02:52 <monochrom> the use of <$> and <*>
11:03:18 <benmachine> yeah
11:03:56 <benmachine> :t let unwrap (x:xs) = (:) <$> x <*> unwrap xs in unwrap
11:03:57 <lambdabot> forall (f :: * -> *) a. (Applicative f) => [f a] -> f [a]
11:05:46 <benmachine> iliketomato1234: there are a few ways to learn about applicatives
11:05:50 <benmachine> I believe they're mentioned in lyah
11:06:06 <benmachine> or you can try the typeclassopedia, which is a bit more involved
11:06:11 <benmachine> @where lyah
11:06:11 <lambdabot> http://www.learnyouahaskell.com/
11:06:14 <benmachine> @where typeclassopedia
11:06:15 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
11:11:30 <Hilbert> Hey I know what zip and zipWith do but what is the reason for their names?
11:12:09 <Chaze> Hilbert: the first argument to zipWith is the function you zip "with"
11:12:14 <kmc> takes two lists and pairs them up element-to-element
11:12:18 <kmc> like the two sides of a zipper
11:13:04 <Hilbert> Thanks
11:14:11 <kmc> not the most obvious name but it's better than "nub" and "intercalate" ;)
11:14:26 <kmc> btw ocaml calls zipWith "map2" and "zipWith3" "map3" and so forth, which i think is decent too
11:14:59 <kmc> i wouldn't be too sad if you had to write "zip" as "map2 (,)"
11:15:11 <kmc> i use zipWith a lot more than zip anyway
11:33:10 <tromp> :t zipWithout
11:33:11 <lambdabot> Not in scope: `zipWithout'
11:35:26 <aristid> :t let zipWithout = zipWith (\_ _ -> ()) in zipWithout
11:35:27 <lambdabot> forall a b. [a] -> [b] -> [()]
11:39:08 <ski> BONUS : `(x,y)'
11:39:53 <BONUS> ski: but when you have stuff like (Foo x y,Bar "fffffffff") it kinda looks ugly
11:40:11 <BONUS> because there are spaces between the individual arguments of constructors but not between the tuple components themselves
11:40:42 <ski> i don't think of it as ugly
11:41:02 <ski> not any more than there not being spaces on the insides of the brackets, there
11:41:04 <BONUS> not ugly but it seems less readable
11:41:14 <BONUS> hmmmmm
11:42:32 <ski> (fwiw, i often align the commas separating corresponding parts of tuple patterns, in multiple equations/branches)
11:44:21 <lambdor> How can I have two IO Monads (inputSDL, outputSDL) communicating with each other WITHOUT passing an IORef (or something) to them? (I want to hide the communication from the user)
11:44:36 <simon_> Hello. I was reading through "real world haskell" and the distinction between evaluating and performing for actions confused me. Before reading that section I would've said that actions are the same as normal (monadic) expressions except that they may produce side effects when evaluated (which for monadic expressions only happens when pattern matching against their value constructors? not sure about this). Can someone please explain this to 
11:45:05 <mauke> simon_: your message got cut off
11:45:15 <BMeph> I think that would be an interesting addition to the "Haskell Prime"/"Haskell 2" specification - removing the 'zip_' line of functions, and renaming the 'zipWith_' ones as 'map_' instead.
11:45:17 <BONUS> he probably meant to add: me
11:45:29 * hackagebot hamlet 0.6.1.2 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-0.6.1.2 (MichaelSnoyman)
11:45:39 <ski> lambdor : `frob :: IO (IO Foo,IO Bar)'
11:45:43 <simon_> where was it cut off?
11:45:44 <mauke> simon_: but "action" is just another name for "monadic value", and evaluating something doesn't produce side effects
11:45:53 <BONUS> simon_: you mean IO actions?
11:46:13 <BONUS> > putStr "hahah" `seq` 3
11:46:14 <lambdabot>   3
11:46:22 <smerz> he guys. I got lost on the following issues: http://nopaste.info/2284e35503.html
11:46:23 <simon_> mauke: oh, I thought the term action was exclusive to the io monad
11:46:27 <lambdor> ski, thx
11:46:30 <smerz> error is on line 4 and i don't get it :(
11:46:36 <ski> lambdor : each time you execute `frob', you create one more hidden channel, and two `IO Foo' and `IO Bar' actions that, whenever executed, will communicate using this hidden channel
11:46:39 <mauke> BONUS++  # pretty cool guy
11:46:46 <BONUS> :o)
11:47:13 <BONUS> I/O actions aren't performed when evaluated. they're performed once your program is run and if they're part of the I/O action called main
11:47:28 <BONUS> or if you punch them out in GHCi and press enter
11:47:38 <BMeph> simon_: Here's a hint: Since Haskell is a non-strict language, you can sometimes get answers from an expression without having to fully evaluate every sub-expression. This means that some effect-producing expressions may not be allowed to produce those effects.
11:47:39 <mauke> smerz: do you have tabs in that file?
11:47:52 <simon_> BONUS: isn't that the same? i mean nothing is evaluated until the program is executed anyway
11:48:06 <smerz> yeah
11:48:10 <smerz> both are tabs
11:48:21 <smerz> as in 1 tab after function. and 2 tabs after the 'let'
11:48:22 <ski> simon_ : i talk about `Foo'-action for any monad `Foo', not just `IO' (and often also for applicative functors `Foo')
11:49:13 <BONUS> simon_: correct. once you execute your program, it starts performing the main I/O action, which is probably comprised of many other I/O actions
11:49:33 <monadic_kid> composed actions
11:49:36 <BONUS> and then results that those actions need get evaluated
11:49:39 <BONUS> ya
11:50:29 <BONUS> for instance: main = do print (3 + 5); print (putStr "foo" `seq` 3 + 5)
11:50:47 <ski> simon_ : conceptually, a value of type `IO Foo' is just a datastructure describing a recipe of things to do. then run-time system will evaluate this recipe, and actually do the effects described in it, affecting the world
11:50:52 <lambdor> ski, so I don't refer to Foo and Bar directly but generate them with frob first, which in turn produces the channel (inputSDL :: IORef -> IO a, outputSDL :: IORef -> IO ())?
11:51:28 <lambdor> (Foo and Bar being inputSDL and outputSDL in this case)
11:51:37 <ski> lsthemes : close .. but you don't pass the `IORef's to those two functions (that's what you wanted to avoid)
11:51:38 <BONUS> putStr "foo" gets evaluated
11:51:42 <BONUS> but not performed
11:51:52 <lambdor> frob passes it
11:51:56 <simon_> BONUS: but I still don't understand why there's a distinction between performing and evaluating. To me it looks like there are just special rules for evaluating the insides of a monadic value
11:52:02 <lambdor> so the user doesn't see it anymore
11:52:18 <monadic_kid> simon_: think of composition versus application
11:52:36 <BMeph> smerz: We're pretty much "tabs are Tools of the Devil" here in Haskell-Land. ;)
11:52:37 <ski> lsthemes : `makeSDL_Input_Output :: IO (IO a,IO ())' .. something like that
11:52:56 <ski>   makeSDL_Input_Output = do
11:53:06 <lambdor> ok, got it. thx!
11:53:15 <ski>     hiddenReference <- newRef someInitialValue
11:53:20 <monadic_kid> simon_: you know function composition?
11:53:24 <simon_> BONUS: from your example with put
11:53:28 <ski>     let inputSDL = do
11:53:35 <smerz> BMeph, yeah
11:53:38 <smerz> i just went for spaces
11:53:40 <smerz> and bang
11:53:42 <smerz> meh
11:53:46 <ski>           ..use `hiddenReferece' here..
11:53:47 <smerz> i lost hours over this
11:53:55 <ski>         outputSDL = do
11:53:56 <ski>           ..use `hiddenReferece' here..
11:53:59 <smerz> :(. thanks guys
11:54:05 <ski>     return (inputSDL,outputSDL)
11:54:11 <lambdor> same for outputSDL and return (input, output)
11:54:14 <lambdor> right
11:54:19 <lambdor> cool ^^
11:54:47 <simon_> BONUS: from your example with putStr I would say that there's just a special rule for evaluating monadic values, so that its inside is only evaluated when one pattern matches against its value constructor
11:54:59 <ski> note that the `hiddenReference' here won't have "global" (i.e. process) extent
11:55:11 <BONUS> simon_: there's a distinction because they are different things. evaluating something is carrying out some sort of calculation that's been delayed, whereas performing an I/O action means carrying out their side-effects, such as writng and reading etc.
11:55:15 <ski> if you really want that (but you probably don't), there's a way of doing that
11:55:45 <mauke> smerz: if you have to use tabs in Haskell, make sure 1) they're at the beginning of a line and 2) it doesn't matter how many characters they're wide
11:56:01 <smerz> yeah i used them after functions
11:56:05 <smerz> and had no issues
11:56:11 <lambdor> yes, that was what I was trying first, but creating a channel makes more sense anyway => no concurrency when functions are used in multiple contexts
11:56:14 <smerz> but this "let" thing. totally confused the shit out of me :(
11:56:38 <BONUS> when you have a value that's not yet evaluate it and you evaluate it, you're taking some sort of recipe to perform a calculation and replacing it with the result of that calculation, in a sense
11:56:40 <mauke> smerz: if you use layout with tabs, you should probably start a new line after every layout introducer
11:56:51 <mauke> smerz: i.e. where/do/let
11:56:52 <monadic_kid> simon_: you can have a complex function that is made out of a composition of simplier functions that make up the whole but you haven't evaluted it yet until you apply that function, it's the same IO actions you're composing actions when you give all of their arguments you're not really fully applying them, only main fully applys the compound action and thus executes
11:56:54 <smerz> i'll just ditch tabs
11:56:55 <simon_> BONUS: but looking at this code: "Just $ 2 + 3" . This produces no side effects but as I understand it, just like your putStr, it would't get evaluated to "Just 5" by seq
11:56:56 <smerz> no problem
11:56:56 <smerz> x)
11:56:57 <BONUS> but doing so doesn't have anything to do with carrying out side-effects like writing or reading to the scsreen
11:56:58 <BMeph> smerz: Just keep in mind that many folks that work with Haskell like to chase tab-users with pitchforks and torches. ;)
11:57:02 <mauke> smerz: easy solution :-)
11:57:10 <smerz> haskell should refuse tabs then
11:57:11 <smerz> wtf
11:57:13 <smerz> ! :|
11:57:14 <BONUS> simon_: you're confusing monadic actions with I/O actions
11:57:31 <smerz> it should write: "Don't use tabs mofo" :D
11:57:50 <simon_> BONUS: but don't the same rules apply for both? just that other actions don't produce side effects when evaluated
11:57:57 <BONUS> I/O actions are, depends on how you look at it, special monadic actions. most monadic actions are pure
11:58:09 <ski> BONUS : the rule is, there are no side-effects
11:58:23 <ski> er
11:58:34 <ski> s/BONUS/simon_/
11:58:35 <ski> (sorry)
11:59:05 <mauke> smerz: that's kind of a bug in the language (it assumes tabs are 8 spaces wide)
11:59:08 <BONUS> when you evaluate Just $ 3 + 5, you get no side-effects
11:59:19 <sipa> BONUS: do you call "values of IO a" I/O actions?
11:59:19 <BONUS> when you evaluate putStr "foo", you also get no side-effects
11:59:25 <BONUS> sipa: yeah
11:59:29 <simon_> BONUS: but neither do you get "Just 5"
11:59:37 <ski> sipa : aye
11:59:42 <smerz> another quick questions. i got this function:      Int->Int->Coordinaat->(Coordinaat,Bool)
11:59:49 <smerz> how can i access the bool that's returned ? :|
11:59:50 <BONUS> simon_: yeah. but my point is that I/O actions are the only kind of monadic actions that can be performed
11:59:57 <sipa> smerz: snd
11:59:57 <ski> smerz : pattern-match
12:00:02 <sipa> or pattern match
12:00:07 <BMeph> smerz: But if tabs were entirely banned, those Haskell guys wouldn't get their cardio workouts, and would die of congested heart failure. This way, they can be "discouraged" but not outright banned, and everyone wins! ;)
12:00:15 <Nibble> I remember talking to someone about the famous fibonacci sequence example
12:00:19 <BONUS> and they get performed when you run your program and they're part of the main I/O action
12:00:21 <ski>   f ... = ...
12:00:22 <ski>     where
12:00:24 <Nibble> he said it was a good example of lazyness and dynamic programming
12:00:26 <Nibble> and something else...
12:00:31 <smerz> snd. i need another hint on that. sorry :|
12:00:34 <Nibble> I need to know what that something else might have been
12:00:38 <ski>     (newCoord,bool) = theFunction m n oldCoord
12:00:39 <smerz> BMeph, haha. i had a workout on it too :D
12:00:51 <mauke> @src snd
12:00:51 <lambdabot> snd (_,y) =  y
12:00:56 <simon_> BONUS: but performing seems to happen exactly at the same point when non IO actions are evaluated (like in the case of Just $ 1+3, which isn't evaluated by seq either) so still, why the distinction
12:00:56 <ski> > snd (4,"hello")
12:00:56 <lambdabot>   "hello"
12:00:58 <sipa> smerz: snd extracts the second element of a 2-tuple 
12:01:02 <smerz> oh
12:01:03 <smerz> thanks
12:01:04 <smerz> :)
12:01:11 <ski> > let aPAir = (4,"hello")  in  snd aPair
12:01:12 <lambdabot>   Not in scope: `aPair'
12:01:13 <smerz> i hope that'll be all for today :|
12:01:19 <ski> > let aPair = (4,"hello")  in  snd aPair
12:01:19 <lambdabot>   "hello"
12:01:21 <mauke> simon_: putStrLn "hi" doesn't output "hi"
12:01:22 <smerz> i really appreciate the help :)
12:01:54 <mauke> simon_: also, do you know why getChar isn't a function?
12:02:14 <sipa> simon_: both IO actions are still created by normal functions, there is nothing magical about it, and those are only evaluated when necessary
12:02:33 <BONUS> simon_: there's nothing really special about Just $ 1 + 3
12:02:52 <BONUS> and it does get evaluated by seq
12:02:58 <BONUS> it just doesn't produce Just $ 4
12:03:03 <sipa> however the big IO action that is returned by main, is executed, and this execution can (and will) cause evaluation of the functions (both normal and IO-action producing ones) used to write the IO action returned by main
12:03:43 <BONUS> x `seq` y means: before evaluating this whole expression, you gotta evaluate x first!
12:03:54 <sipa> so yes, if you are talking about actual execution, both normal function and IO actions are executed at the same time
12:04:09 <BONUS> > (Just $ 1 + 4) `seq` 3
12:04:10 <lambdabot>   3
12:04:16 <BONUS> the Just $ 1 + 4 does get evaluated here
12:04:25 <simon_> BONUS: but it doesn't change
12:04:31 <BONUS> in this case. because we forced the evaluation of 3 by giving it to lambdabot
12:04:37 <ski> nothing changes
12:04:55 <simon_> BONUS: using show on it would change it though, since one pattern matches against its value constructor though, i guess?
12:05:24 <BONUS> it wouldn't change it, but it would also force the evaluation of 1 + 4
12:05:25 <BMeph> simon_: Also, note this: Haskell folks are VERY pedantic, so they are very "picky"/"prickly" about there being a difference between execution and evaluation.
12:05:41 <simon_> BONUS: ye, that's what i meant
12:05:43 <BONUS> which (Just $ 1 + 4) `seq` 3
12:05:44 <BONUS> doesn't
12:05:54 <simon_> BONUS: isn't that the same with io actions?
12:05:56 <BONUS> it just evaluates the outer Just, if you will
12:06:27 <BONUS> simon_: what do you mean the same?
12:06:37 <simon_> BONUS: the same conditions
12:06:58 <BONUS> well if you do
12:07:04 <BONUS> > putStr "foo" `seq` 3
12:07:04 <lambdabot>   3
12:07:07 <BONUS> it goes to evaluate 3
12:07:12 <BONUS> and says ok i gotta evaluate that other thing first
12:07:24 <BONUS> and says: ok i evaluated this thing, it's an I/O action alright, well that's it
12:07:32 <BONUS> here's 3
12:07:33 <simon_> BONUS: so does "Just $ 3 + 1 `seq` 3"
12:07:51 <BONUS> yeah, in this respect they are the same. ah i see now what you meant
12:07:59 <simon_> BONUS: so does "Just ( 3 + 1) `seq` 3"
12:07:59 <BONUS> because they're expressions
12:08:08 <BONUS> the same happens with 5 `seq` 3
12:08:15 <BONUS> and 5 isn't monadic or anything
12:08:37 <BONUS> the point here is that evaluation doesn't imply performing of I/O actions
12:08:44 <BONUS> however, performing I/O actions often requires evaluation
12:09:13 <simon_> BONUS: so io actions are performed under the exact same conditions under which other actions like "Just $ 5 + 3" are fully evaluated ( as in Just 8)
12:09:23 <BONUS> nope
12:09:36 <mauke> simon_: putStrLn "hi" doesn't output "hi"
12:09:44 <BONUS> they're performed when they're part of main and when you're program is run. Just $ 5 + 3 can't be part of main
12:09:48 <BONUS> because it's not an I/O action
12:10:01 <mauke> "part of main" is kind of abstract"
12:10:01 <BONUS> and can't be performed
12:10:06 <BONUS> mauke: yeah it is
12:10:16 <mauke> I/O happens when the runtime system grabs an IO action and interprets it
12:10:35 <ion> Evaluating putStr "foo" returns a value of type IO () without any side effects. One can then pass the value to something that performs the action, for instance by binding it to main and running the program.
12:10:48 <BONUS> true, but i don't think that's so important to simon_'s confusion
12:10:52 <mauke> you can't call the runtime system
12:11:00 <simon_> BONUS: can't i write "main = Just $ 3 + 1"?
12:11:02 <mauke> there's no hook for you to execute IO actions
12:11:11 <BONUS> simon_: nope, try it
12:11:13 <mauke> simon_: you can, but it will probably fail with a linker error
12:11:21 <mauke> or a type error
12:11:26 <BONUS> type error i think
12:11:39 <ski> simon_ : `main' has to be an `IO'-action
12:11:46 <mauke> simon_: point is, there's other code that calls main, and it expects main to have an IO type
12:12:01 <mauke> and by "calls main" I mean "doesn't call main"
12:12:08 <simon_> i see
12:12:09 <mauke> because main is not a function :-/
12:12:47 <ski>   main = do
12:12:51 <ski>     let fred = putStrLn "fred"
12:12:54 <sipa> simon_: some primitive IO actions exist (like putStrLn), they describe interactions with the real world, and may be 'applied' to it at some point or not. Using monadic do-notation or >>=, you can combine many of those primitive IO actions (using normal functions), into bigger IO actions. Main eventually evaluates to a single big IO action that describes one interaction with the real world, and is executed
12:12:55 <ski>         joe  = putStrLn "joe"
12:12:59 <ski>     joe `seq` fred
12:13:00 <ski>     fred
12:13:10 <mauke> ski: ...
12:13:14 <ski> simon_ : consider this ^ small program
12:13:20 <mauke> that was terrible
12:13:47 <mauke> main = do { let { fred = putStrLn "fred"; joe = putStrLn "joe" }; joe `seq` fred; fred }  -- or use a pastebin
12:14:35 <BONUS> simon_: that something is a monadic action just means that its type is in the Monad type class. so it's sort of like any other type class, like Read or whatever. I/O actions just happen to be monadic actions. them being special doesn't have anything to do with the fact that they're monadic, but with the fact that they can be performed
12:14:36 <sipa> simon_: however, since functions are only evaluated lazily, it is not necessary (and in fact not possible) to evaluate main completely before execution, so the evaluation happens as necessary
12:14:38 * hackagebot iteratee 0.7.0.0 - Iteratee-based I/O  http://hackage.haskell.org/package/iteratee-0.7.0.0 (JohnLato)
12:15:16 <mauke> what do you mean by "functions are evaluated lazily"?
12:15:31 <mauke> do you mean that a function body doesn't actually run until you call the function?
12:15:48 <ski> simon_ : `main' is the `IO'-action that, if executed does : `fred' and `joe' are bound to some `IO'-actions, then `joe' is evaluated (nothing happens), and `fred' is evaluated (nothing happens) and executed. then `fred' is executed again
12:17:51 <simon_> BONUS: couldn't theoretically IO actions be performed in the same way as other actions (by pattern matching against their value constructors), if they were exported by the module that defines the IO monad?
12:18:18 <mauke> actions aren't performed by pattern matching
12:18:22 <simon_> BONUS: *as other actions can be fully evaluated i mean
12:18:40 <mauke> IO actions can be fully evaluated, it just doesn't do anything
12:18:48 <ski> simon_ : yes, but it couldn't be Haskell code which interpreted the `IO'-actions (unless you had another way of making things happen, like dialogue-based I/O, e.g.)
12:18:53 <BONUS> simon_: i guess they could, in some other strange version of haskell, but it would be a clusterfuck. 
12:19:05 <sipa> simon_: how would pattern matching against something, cause some output to be generated?
12:19:07 <simon_> mauke: doesn't pattern matching against "Just" fully evaluate "Just 1 + 3" to "Just 4"?
12:19:25 <mauke> simon_: I don't think so
12:19:35 <sipa> simon_: no, but using the value inside of it would
12:19:37 <BONUS> because of lazy evaluation, you wouldn't have any guarantee as to when (or if at all) the actions get performed
12:19:37 <simon_> sipa: by evaluating the thunk, the same way as "Just 3 + 1" becomes "Just 4"
12:19:39 * hackagebot mutable-iter 0.5 - iteratees based upon mutable buffers  http://hackage.haskell.org/package/mutable-iter-0.5 (JohnLato)
12:19:45 <mauke> > case Just (error "BAM!") of Just _ -> "all is well"
12:19:46 <lambdabot>   "all is well"
12:19:47 <c_wraith> sipa, depending on how you "use" the value
12:19:55 <sipa> c_wraith: true
12:20:12 <BONUS> simon_: nah. like mauke said. case Just (3 + 5) of Just x -> "woo"
12:20:13 <simon_> sipa: ye that's what i mean but you can only use it if you pattern match against the value constructor
12:20:24 <monochrom> > case Just (let x = x + 1 in x {- infinite loop -}) of Just n -> "not fully"
12:20:25 <lambdabot>   "not fully"
12:20:30 <BONUS> we pattern match against the Just, but its inner value isnt evaluated
12:20:36 <sipa> what BONUS said
12:21:05 <mauke> > case Just (error "BAM!") of Just x -> length [x, x, x]
12:21:06 <lambdabot>   3
12:21:21 <mauke> > case putStrLn "BAM!" of x -> length [x, x, x]
12:21:21 <lambdabot>   3
12:21:33 <monochrom> > case Just ("not fully evaluated" ++ repeat '!') of Just n -> take 10 n
12:21:34 <lambdabot>   "not fully "
12:21:40 <simon_> BONUS: I meant something like "case (Just $ 4 + 1) of Just x -> x seq 1"
12:21:41 <mauke> > case getChar of x -> length [x, x, x]
12:21:42 <lambdabot>   3
12:22:03 <monochrom> alright, x `seq` 1 evaluates more
12:22:04 <mauke> simon_: how would that work with getChar?
12:22:13 <ski> > case Just (4 + 1) of Just x -> x `seq` 1
12:22:14 <lambdabot>   1
12:22:21 <simon_> mauke: it wouldn't because the value constructors aren't exported
12:22:24 <BONUS> simon_: here you introduced two changes. the different formatting of (Just $ 4 + 1) doesn't change anything. however the seq does
12:22:28 <smerz> can i use an if statement inside "let" statement? :| 
12:22:30 <ski> > case Just (4 + error "help !") of Just x -> x `seq` 1
12:22:31 <lambdabot>   *Exception: help !
12:22:39 <ski> smerz : sure
12:22:39 <mauke> smerz: 'if' is an expression, not a statement
12:22:41 <BONUS> if that expression is evaluated, it says ok before i evaluate the 1 i need to evaluate x
12:22:50 <sipa> mauke: as is 'let'
12:22:57 <simon_> BONUS: i only meant to do the seq change
12:22:57 <sipa> (except inside do)
12:22:58 <mauke> sipa: 'let' can be a statement
12:23:00 <BONUS> but the x gets evaluated because of the seq, not because of the pattern matching. 
12:23:13 <BONUS> the outer Just gets evaluated because of the pattern matching
12:23:29 <BONUS> as it has to only determine if it is a Just or a Nothing to pattern match, it doesnt have to know what's inside the Just
12:23:54 <smerz> so i'm confused now. can i use it or not? :D
12:23:57 <monochrom> It is most productive to accept getChar etc. as runtime system magic. It isn't more magical than C, actually.
12:24:05 <smerz> gives me errors whichever way i try
12:24:09 <simon_> mauke: isn't "let x = 1; somestuffafter" just syntax for (\x -> somestuffafter) 1
12:24:23 <mauke> simon_: no, it's a syntax error
12:24:40 * hackagebot sndfile-enumerators 0.7.0 - Audio file reading/writing  http://hackage.haskell.org/package/sndfile-enumerators-0.7.0 (JohnLato)
12:24:41 <ski> > let x = 3 in if even x then "yes" else "no"  -- smerz
12:24:41 <lambdabot>   "no"
12:24:46 <simon_> BONUS: yes, but you can only use seq if you extract the inner value by pattern matching
12:24:53 <smerz> thanks ski
12:25:01 <mauke> simon_: do let {x = 1}; stuff is syntactic sugar for let x = 1 in stuff
12:25:17 <mauke> but 'let' isn't sugar for lambda; the typing rules are different
12:25:22 <BONUS> simon_: yes, but that's kind of logical
12:25:47 <simon_> mauke: my but in lisp it is, isn't it? my mistake
12:25:56 <sipa> smerz: show your code
12:25:57 <BONUS> mauke: is that because of monomorphic let or is that because of something else i'm missing because im sleepy
12:26:05 <smerz> sipa, sec will do
12:26:07 <sipa> smerz: if it's too long, use hpaste.org
12:26:12 <mauke> BONUS: more like monomorphic lambda, no?
12:26:26 <BONUS> mauke: yeah, of course. duh
12:26:46 <mauke> > let id x = x in (id "a", id 'a')
12:26:47 <lambdabot>   ("a",'a')
12:27:01 <mauke> > (\id -> (id "a", id 'a')) (\x -> x)
12:27:01 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
12:27:01 <lambdabot>         against inferred type...
12:27:21 <BONUS> of course
12:27:52 <sipa> > (\(id :: a -> a) -> (id "a", id 'a')) (\x -> x)
12:27:52 <lambdabot>   A pattern type signature cannot bind scoped type variables `a'
12:27:53 <lambdabot>    unless th...
12:28:25 <ski> > (\(id :: forall a. a -> a) -> (id "a", id 'a')) (\x -> x)
12:28:26 <lambdabot>   ("a",'a')
12:28:37 <mauke> you are now cheating manually
12:29:39 <smerz> http://hpaste.org/42479/524_parse_error_on_input
12:29:50 <smerz> i'm sure it doesn't work that way :D
12:30:04 <sm> why could I be getting "No instance for (Control.Monad.IO.Class.MonadIO (InputT IO))" while using http://hackage.haskell.org/packages/archive/haskeline/0.6.3.2/doc/html/System-Console-Haskeline.html which says InputT is an instance of MonadIO ?
12:30:13 <monochrom> push the if-then-else inside tweedeToestand
12:30:17 <BONUS> simon_: do you now sort of understand more between this distinction of performing and evaluating? i feel as though we've sort of gone off-track
12:30:21 * ski lazily ponders what it means to cheat manually
12:30:31 <simon_> BONUS: One last question; Assuming the io module would export its value constructors, could you then perform an io action by doing "case (ioaction) of constructor x -> seq x 1" ?
12:30:35 <Saizan_> sm: different MonadIO?
12:30:51 <monochrom> tweedeToestand = if ... then verplaats ... else beginToestand
12:30:52 <sipa> simon_: no
12:30:56 <BONUS> simon_: nope
12:31:00 <smerz> monochrom, thanks! :D
12:31:13 <sm> Saizan_: aha.. like maybe mtl 2 also provides it ?
12:31:23 <sipa> simon_: imagine it was a putStrLn action, represented by a PutStrLn String constructor
12:31:24 * sm hastens to spiffy new hoogle
12:31:28 <BONUS> like we said, evaluating (or deconstructing if that were possible) an I/O action doesn't mean it's performed
12:31:42 <mauke> simon_: imagine type IO a = String
12:31:44 <BONUS> yeah what sipa said
12:31:47 <sipa> simon_: pattern matching against it would allow you to retrieve the value that would be printed
12:31:48 * ski suspects simon_ wants to look at one or two of the sketches of `IO' as an algebraic (preferable GADT) datatype ..
12:31:52 <sipa> but it would not print it
12:31:58 <Saizan_> sm: i don't think so, but are you sure your haskeline is built against mtl-2?
12:32:03 <mauke> simon_: also imagine all the IO functions generated Perl code
12:32:07 <simon_> BONUS: k, i think i understand it now. Thanks for being so patient with me :)
12:32:15 <BONUS> hehe np
12:32:35 <mauke> simon_: then if you could look at the innards of IO, all you'd see was a String with weird text in it
12:32:42 <sm> Saizan_: not certain, though it's likely.. could you give an example of what might be happening ?
12:32:50 <mauke> now all you need is a runtime system that calls perl, and you're done
12:33:05 <HugoDaniel> BONUS: i love you
12:33:06 <djahandarie> "When you open IO, you see C code"
12:33:14 <sipa> mauke: why hasn't anyone done so!?
12:33:14 <Saizan_> sm: "ghc-pkg field haskeline depends" should tell
12:33:15 <BONUS> HugoDaniel: i love you too
12:33:16 <sipa> ;)
12:33:27 <monochrom> because perl is too hard
12:33:37 <mauke> maybe I will do that
12:33:41 <monochrom> actually too slow too
12:33:52 <simon_> mauke: so the information about how to perform an action is not hidden in the monad but built into haskell?
12:33:59 <djahandarie> Not when it is compiled with Pugs!
12:34:06 <djahandarie> Infinite loop!
12:34:10 <mauke> simon_: it's not even inside haskell
12:34:11 <sm> wow, that's a new one on me
12:34:12 <Saizan_> sm: if it lists mtl-1.x then InputT has an instance for the MonadIO class defined there, instead of the one defined in transformers
12:34:21 <simon_> mauke: well, the compiler
12:34:26 <mauke> simon_: it's in the runtime system that ends up using the 'main' in your program
12:34:30 <mauke> simon_: but yes
12:34:30 <sipa> mauke: what will you do with main = getChar >>= putStrLn . f
12:34:38 <simon_> mauke: k, thanks
12:34:40 <mauke> sipa: that's the tricky part
12:34:45 <sipa> callbacks!
12:34:47 <mauke> yep!
12:35:13 <sm> Saizan_: yes it's depending on mtl 1.x currently
12:35:34 <sm> so this should work, as it has until today >:/
12:36:13 <monochrom> a haskell implementation on top of a perl implementation on top of a haskell implementation on top of... we put the "funk" in self-hosting
12:36:32 <Saizan_> sm: maybe you weren't using transformers until today :)
12:36:49 <sipa> simon_: haskell allows you to use values and functions and combine them into a 'main', and the result is passed to the runtime system, which executes this main... of course, this evaluation will cause callbacks to haskell code
12:37:25 <BONUS> sipa: you mean: "of course, this execution"?
12:37:29 <sm> that's helpful.. if I hide transformers, the build indeed starts failing
12:37:41 <sm> I mean, failing sooner
12:38:10 <monochrom> fail early. fail often.
12:38:16 <Saizan_> maybe you should use a .cabal file for your builds
12:38:18 <BONUS> monochrom: my life motto
12:38:22 <sipa> BONUS: absolutely :)
12:38:36 <monochrom> fail early. fail often. fail the bazaar metaphor.
12:38:52 <Saizan_> it'd help keeping the packages you depend on under control.
12:40:21 <sm> Saizan_: I've got by ok till now doing my test builds without cabal, which I need for auto-recompile-on-file-change. I'll compare the cabal build, you've given me enough clues to get out of trouble I think
12:40:27 <sm> thanks!
12:41:42 <Saizan_> you could also recompile haskeline and others against mtl2
12:42:08 <BONUS> mtl2 caused some headaches for me, lyah-wise :)
12:42:43 <monochrom> I heard that you rewrite "Reader (\r -> haha)" to "reader (\r -> haha)"
12:42:58 <BONUS> yeah i will have to do that
12:43:11 <BONUS> but the tricky part is that i'll have to cheat a bit when explaining some monads
12:43:38 <monochrom> "to understand monads, you must first understand monad transformers"
12:43:47 <BONUS> cause you it's hard to explain what monad transformers first and then generalize that to monad transformers with Identity
12:43:51 <BONUS> yeah lol
12:44:05 <ski> monochrom : a motto to live by, in Prolog
12:44:25 <monochrom> I keep generating mottos to live by.
12:44:40 <ski> eh, you're using generate&test ?
12:44:59 <monochrom> I'm using generate&don't test
12:45:00 <djahandarie> ETA until we start using IOT Identity?
12:45:17 <BONUS> haha
12:45:58 * ski . o O ( `?- generate_motto(Motto),fail,test_motto(Motto). % Fail early. Fail often.' )
12:47:24 <ski> djahandarie : how about `IOT []' ?
12:48:06 <sm> Saizan_: good call, recompiling haskeline with mtl 2 made it just go away
12:48:26 <msieradzki> can I make class/data that allows writing "k * v" computing values (k*x,k*y)? I mean specific "*" operator and as far as I remember Num works with same types on both sides
12:48:40 <djahandarie> ski, perhaps it only works on communative monads.........
12:48:47 <sm> now to forget about all this and carry on until the next beating
12:49:26 <ski> djahandarie : ok, `IOT (Error EndOfWorld)', then
12:50:19 <djahandarie> Obviously that'll result in the end of the world
12:50:43 <ski> > '\EOW'
12:50:44 <lambdabot>   <no location info>:
12:50:44 <lambdabot>      lexical error in string/character literal at chara...
12:50:48 <ski> > '\EOT'
12:50:49 <lambdabot>   '\EOT'
12:50:54 <djahandarie> End of time...
12:51:02 <mauke> 
13:00:33 <jonathan_> can you declare local variables in else block of a if statement?
13:00:39 <jonathan_> if so how?
13:00:56 <lispy> > if True then let x = 1 in x else 2
13:00:57 <lambdabot>   1
13:00:59 <djahandarie> if ... then ... else let x in ...
13:01:04 <jonathan_> let in got it
13:01:05 <jonathan_> thanks
13:01:45 <mauke> 'if' is not a statement and it has no blocks :-(
13:02:21 <djahandarie> Hmm, what does the report call each part of a multi-part expression?
13:02:27 <djahandarie> Just 'expression'?
13:02:32 <lispy> mauke: and let doesn't create variables
13:02:43 <mauke> it doesn't?
13:02:51 <lispy> mauke: nah, it binds names
13:02:57 <mauke> oh, I call those "variables"
13:02:59 <BONUS> lispy: haha, well that's a bit pedantic isn't it
13:03:03 <BONUS> i call them variables too
13:03:16 <mauke> djahandarie: I don't know but I'd go with "subexpression"
13:03:24 <djahandarie> Seems like it just calls them expressions.
13:03:32 <lispy> BONUS: That was my point.  Saying that if/then/else doesn't have blocks and it's not a statement feels too pedantic to me :)
13:03:35 <djahandarie> But it calls an if expression a 'conditional'
13:04:31 * ski . o O ( `if <condition> then <consequent> else <alternate>' )
13:04:39 <djahandarie> Heh
13:04:44 <djahandarie> Probably going a bit too extreme there
13:04:56 <hoknamahn> it's functions
13:05:15 <djahandarie> Normally I just repeat people's questions back with the proper terminology when I answer it
13:05:25 <mauke> if <else> then <if> else <then>
13:05:37 <ski> > if False then "True" else "Maybe"  -- look, ma : no functions
13:05:38 <lambdabot>   "Maybe"
13:05:49 <lispy> if_then_else_ :: Bool -> a -> a -> a
13:06:09 * ski sometimes would like to use `if .. else .. then ..'
13:06:14 <lispy> I like that about agda, wish we had mixfix sometimes
13:06:25 <mauke> > if if False then x > y else 1 < 2 then "yes" else "what"
13:06:26 <lambdabot>   Ambiguous occurrence `x'
13:06:26 <lambdabot>  It could refer to either `L.x', defined at <local...
13:06:33 <mauke> @define
13:06:34 <mauke> > if if False then x > y else 1 < 2 then "yes" else "what"
13:06:35 <lambdabot>   "yes"
13:06:55 <ski> mauke : i like that `@define' :D
13:07:06 <mauke> lazy typing
13:07:11 <hoknamahn> hey guys anyone knows when next haskell platform with ghc 7 will be released?
13:07:30 <lispy> hoknamahn: it's time based right?  Every 6 months?
13:07:53 <hoknamahn> maybe i don't know
13:08:35 <BONUS> will 2011.2.0.0 have GHC7?
13:09:28 <lispy> http://trac.haskell.org/haskell-platform/wiki/ReleaseTimetable
13:09:45 <ski> (mauke : do you know if there is any expression where also having `if .. else .. then ..' would be ambiguous ?)
13:10:08 <BONUS> that timetable says that the freeze is supposed to be on dec 15 but it doesn't say if Data.Text is in or not
13:10:11 <jkff> Hi. Is there a secret primop for doing reinterpret_cast from an Int64 to Double, or an Int32 to Float?
13:10:12 <BONUS> it's a bit outdated hmm
13:10:26 <lispy> BONUS: did you check the ticket?
13:10:35 <mauke> ski: I don't think there is
13:10:36 <Cale> hmm, XChat seems to leak memory badly -- 240 MB for an IRC client?!
13:10:39 <benmachine> jkff: remind me which one reinterpret_cast is
13:10:41 <lispy> http://trac.haskell.org/haskell-platform/ticket/145  <-- not loading for me, but I tthink it's documented here
13:10:47 <BONUS> i did not, because i'm a stupid dummy
13:10:54 <benmachine> Cale: rewrite it in haskell obv
13:10:57 <jkff> benmachine: I mean, I want to get the bits of a Double as an Int64
13:11:01 <jkff> Or vice versa
13:11:13 <benmachine> jkff: ah. possible but dangerous, I think
13:11:15 <BONUS> hmmm the ticket isn't too informative imo
13:11:16 <mauke> unsafeCoerce#?
13:11:22 <Cale> and then I reload it, and it's down to 9MB again
13:11:24 <benmachine> unsafeCoerce from Unsafe.Coerce will do it
13:11:33 <benmachine> but will also kill all type safety forever :P
13:11:46 <jkff> benmachine: Oh thanks, for some reason I did not think about using unsafeCoerce here. Let's try..
13:11:51 <mauke> could also go via Foreign.Ptr and castPtr
13:11:52 <djahandarie> benmachine, won't rewriting it in Haskell make it use more memory? ;)
13:12:07 <BONUS> haskell package idea: a pizza package that enables you to order dominos pizza from within GHCi
13:12:07 <jkff> benmachine: I want it because I see no other way to store a double with specified endianness
13:12:19 <djahandarie> BONUS, brilliant.
13:12:28 <benmachine> jkff: hmmm.
13:12:31 <Cale> jkff: It's not 100% guaranteed that unsafeCoerce will actually always work, but in practice it will at least for now.
13:12:34 <lispy> BONUS: can I pay for it with bitcoin?  That would make it really attractive :)
13:12:43 <BONUS> haha
13:12:56 <benmachine> jkff: and why exactly do you want to do that? :P
13:12:57 * hackagebot web-routes 0.23.2 - Library for maintaining correctness and composability of URLs within an application.  http://hackage.haskell.org/package/web-routes-0.23.2 (JeremyShaw)
13:12:59 <zachk1> i think i made a few bitcoins then went wdf and stopped 
13:13:01 <acowley> Is there a way to refer to the current version of a package being compiled by cabal in the source code of that package?
13:13:42 <mauke> acowley: yes, there's a module called Paths_<package>
13:13:52 <jkff> benmachine: because I have to implement a network protocol with fixed endianness . Actually doubles are currently not used in this protocol, but I wanted to write something like an "endian-storable" package
13:13:54 <Cale> Theoretically, you should only use unsafeCoerce in cases where you know that the types are actually identical but don't want to go to the trouble of proving to the Haskell typechecker that they are (or where this will incur more work/memory for evidence)
13:14:08 <lispy> BONUS: "dons: dagit: yes, early Jan. GHC 7"
13:14:13 <jkff> benmachine: And I stumped on being unable to write an instance for Double
13:14:16 <BONUS> lispy: kewl
13:14:19 <acowley> mauke: Ah! I couldn't find docs describing where the version is kept even though I thought I'd heard/read of it. Can you point me to the right place to read up on it?
13:14:39 <benmachine> jkff: well, you could just decodeFloat first, and then store the bits separately
13:14:44 <benmachine> might be inefficient though
13:14:54 <jkff> benmachine: yes, inefficient :(
13:15:03 <mauke> acowley: sadly, no
13:15:06 <benmachine> hmm
13:15:16 <benmachine> have you looked at what the binary package does?
13:15:18 <benmachine> or cereal?
13:15:18 <acowley> mauke: I can't find it in the User's Guide
13:15:42 <jkff> benmachine: They don't seem to provide endian stuff for doubles, though let me doublecheck (pun intended)
13:16:04 <benmachine> oh it just encodes and decodes :x
13:16:24 <benmachine> yeah
13:16:29 <benmachine> are you sure that's too inefficient?
13:16:34 <benmachine> seems the simplest way
13:17:02 <jkff> benmachine: well, I'd like several hundred thousand decodes per second without too much cpu load in the ideal case.
13:17:23 <jkff> benmachine: Looks like unsafeCoerce works indeed
13:18:08 <benmachine> jkff: I'd normally suggest writing the program and then profiling it to see if it's actually a problem
13:18:18 <benmachine> but unsafeCoerce will probably be okay for your purposes
13:18:30 <benmachine> just be aware that that way madness lies
13:18:48 <jkff> benmachine: I am :)
13:19:43 <msieradzki> do class functions add bloat to types (class F a foo :: a -> a, instance F Float), is there any situations where some kind of dispatch (like vtable) table would be added?
13:20:13 <mauke> class dictionaries are independent of types
13:20:44 <djahandarie> There really needs to be some write-up about typeclass dictionaries somewhere
13:23:52 <msieradzki> so if I want to write <+> for my vector1, vector2 and vector3 do I lose performance by putting it in class?
13:24:30 <mauke> should be easy to test
13:25:06 <msieradzki> will do
13:26:21 <Cale> msieradzki: The implementation of typeclasses just adds function parameters.
13:27:21 <Cale> msieradzki: So, for example, sort :: (Ord a) => [a] -> [a] gets compiled into sort :: Ord a -> [a] -> [a], where Ord a is a record type whose values consist of a dictionary of operations for the Ord class.
13:29:03 <Cale> So there's a little bit of a performance hit, but it's not usually large enough to worry about.
13:29:08 <msieradzki> context where I want to use it is quite similar to Prelude.Num so, if I'm using it similarly I can assume similar performance (for instance it'll inline just fine like + gets), right?
13:29:18 <msieradzki> Num.+ works fine somehow
13:30:02 <Cale> yeah... if the extra polymorphism is a performance problem after all, then you can use the SPECIALIZE pragma to tell it to try to compile specialised versions.
13:31:29 <Cale> http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/pragmas.html#specialize-pragma
13:34:06 <acowley> Cale: The problem with SPECIALIZE is that it has to be in the same module as the definition iirc
13:34:40 <Cale> Well, yes. It can go anywhere that the type signature for the function can go.
13:36:34 <acowley> Cale: It's just that I've had that problem before and had to add a dummy module to my project that reimplemented some functions just so I could add SPECIALIZE pragmas
13:39:09 <Cale> I think the reason that it needs them to be in the same module as the original definition is that it needs the source code of the definitions to be able to compile specialised versions in the first place.
13:40:40 <acowley> Yep, which makes a lot of sense, but is also a big limitation.
13:44:39 <djahandarie> You can get around this if you manually write the specialization
13:45:20 <djahandarie> Then just use {-# RULES "genericFunc/Int" genericFunc = intFunc #-}
13:45:34 <djahandarie> Which only replaces when the types match
13:45:53 <djahandarie> And doesn't need to be in the original file
13:46:06 <acowley> djahandarie: That's a good tip, but it still requires manual specialization which feels awful to do.
13:46:15 <djahandarie> Right
13:46:26 <djahandarie> But also you can often specialize better than the compiler
13:46:52 <acowley> djahandarie: Sometimes, yes. But so often it's just an issue of Int vs Float vs Double
13:49:43 <Hilbert> What does currying work in this : addThree \x -> \y -> \z -> x+y+z, 
13:50:05 <acowley> Hilbert: can you rephrase that question?
13:50:43 <Hilbert> I'm not sure what the best way to pharse the question is
13:51:17 <mauke> may I suggest English
13:51:31 <mauke> and/or Haskell
13:52:10 <listofoptions> ok i cant find anything that will help me on on this for some reason so...what does value capture for this record look like?       data Tape t = Tape {curr::[t], pred::[t], prev::[t]}
13:52:42 <Hilbert> The example I gave is taken from LYAH, I am just struggling to understand how currying works when mixed with lambda expressions
13:52:45 <mauke> what's a value capture?
13:52:52 <Botje> listofoptions: you mean pattern matching?
13:52:56 <mauke> Hilbert: your example is a syntax error
13:53:09 <acowley> Hilbert: You could write addThree (x,y,z) = x + y + z
13:53:33 <Botje> listofoptions: foo (Tape{pred=x}) = ... x ...
13:53:35 <Hilbert> I know, but I want to understand what is going on in AddThree= \x -> \y -> \z -> x+y+z
13:53:37 <acowley> Hilbert: That function would require that you supply all three parameters at once
13:53:48 <listofoptions> thanks Botje
13:54:06 <acowley> Hilbert: Or you could write it so that it takes one parameter at a time, which we would normally write as addThree x y z = x + y + z
13:54:13 <djahandarie> addThree = \x -> \y -> \z -> x+y+z       addThree = \x -> \y z -> x+y+z        addThree = \x y z -> x+y+z      addThree x y z = x+y+z
13:54:44 <acowley> Hilbert: The latter function is another way of writing your lambda version.
13:54:46 <revenantphx> Is there any easy, without breaking everything, way to get a 64bit ghci?
13:55:17 <monochrom> on mac? that's an open problem
13:55:19 <acowley> Hilbert: Also, start with binary functions to play with currying to avoid accidental complexity
13:55:23 <revenantphx> monochrom: TT_TT
13:55:32 <revenantphx> Lets just say, trying to get 32 bit binaries for glib is proving a bitch.
13:55:37 <revenantphx> Since I *don't want to use macports*
13:55:42 <monochrom> I see.
13:55:45 <revenantphx> brew installs 64bit ones perfectly.
13:55:53 <revenantphx> But if I try to add in i386 manually, shit fails.
13:55:54 <listofoptions> Botje can i use the [x:y] list pattern match with that?
13:55:58 <acowley> addTwo (x,y) = x + y ==> addTwo x y = x + y ==> addTwo = \x -> \y -> x + y
13:56:30 <revenantphx> I managed to trick it into installing gettext 32/64 universal
13:56:32 <revenantphx> but no luck with glib.
13:56:33 <djahandarie> Well, curry addTwo, yeah
13:57:14 <Zenon1> has anyone here solved project euler problem 64? I'm at an impasse where I don't see anything wrong with my solution, but it can't be as it doesn't get accepted. I get 1410 so I'm wondering if I'm even close (i.e. an off by one error due to some bug) or if my solution is completely wrong...
13:57:18 <revenantphx> monochrom: what makes it such a big issue right now?
13:57:21 <mauke> listofoptions: do you mean (x:y)?
13:57:24 <monochrom> I don't know.
13:57:31 <listofoptions> yes 
13:57:34 <listofoptions> mybad
13:57:36 <monochrom> perhaps human resource is the only big issue
13:57:57 <Hilbert> Thanks, I still don't fully get currying
13:58:35 <monochrom> I would get it to work if I'm funded with enough money to buy two macbook pros, so I can buy one and pocket the rest.
13:58:44 <djahandarie> Hilbert, this is currying:     f1 (a,b,c) = a+b+c   =>   f2 a b c = a+b+c 
13:58:58 <djahandarie> Hilbert, the way you represent 'multiple arguments' in Haskell is with a tuple (like I just did).
13:59:00 <revenantphx> Zenon1: no clue.
13:59:21 <revenantphx> Did you account for any special or edge cases, maybe?
13:59:42 <djahandarie> Hilbert, f1 :: (Int,Int,Int) -> Int,    f2 :: Int -> Int -> Int -> Int
14:00:01 <djahandarie> Hilbert, ^^^^ those beings the types of the functions I wrote
14:00:18 <Botje> listofoptions: you can nest pattern matches, yes.
14:00:32 <dented42> When I use haddock to portray REPL-like examples with the '>>>' token, it requires that I supply the result of the computation in the next line. Why doesn't haddock just evaluate the expression itself and insert the correct value when the documentation is generated?
14:00:34 <Hilbert> Are f1 and f2 valid haskell syntax I know the latter is
14:00:54 <Renze> Can anybody tell me which symbols I can use to define an operator? My internet doesn't download the book in which it is standing, and I can't find it anywhere else on the internet...
14:00:54 <interferon> can i force a lazy bytestring into a standard bytestring?
14:01:04 <monochrom> haddock doesn't evaluate.
14:01:08 <maurer_> Hilbert: Both are valid, the former will not be curried though.
14:01:28 <monochrom> but perhaps I'm outdated.
14:01:32 <mauke> Renze: http://haskell.org/onlinereport/lexemes.html ?
14:01:42 <lispy> interferon: yes you can
14:01:46 <djahandarie> Hilbert, f1 uses pattern matching
14:01:59 <interferon> lispy: how? :)
14:02:03 <revenantphx> This is really irritating TT_TT
14:02:07 <lispy> interferon: in terms of implementation, you can think of it as type LazyByteString = [ByteString]
14:02:16 <lispy> ?hoogle chunk
14:02:16 <lambdabot> Data.ByteString.Lazy.Internal chunk :: ByteString -> ByteString -> ByteString
14:02:16 <lambdabot> Data.ByteString.Lazy.Internal Chunk :: ByteString -> ByteString -> ByteString
14:02:16 <lambdabot> Network.HTTP.Base chunkedTransfer :: BufferOp a -> IO (Result a) -> (Int -> IO (Result a)) -> IO (Result ([Header], a))
14:02:26 <lispy> interferon: ^^ start there
14:02:31 <djahandarie> Hilbert, another way to write it is   f1 x = let { (a,b,c) = x } in a+b+c
14:02:38 * djahandarie will brb, needs to go home
14:02:51 <lispy> interferon: IIRC, chunk actually goes strict -> lazy
14:03:05 <Saizan_> interferon: S.concat . L.toChunks
14:03:22 <Saizan_> interferon: it's not provided as a function in the library because it's a fairly costly operation
14:03:33 <Renze> Tnx mauke, I thaught , was also allowed, but it isn't :(
14:04:00 <interferon> Saizan_: thanks!
14:04:02 <Saizan_> it'll evaluate the whole lazy bytestring up front
14:04:08 <djahandarie> Hilbert, it is kind of hard to explain currying in Haskell, because functions technically can't have more than one argument. You can kind of fake it with a tuple like I did.
14:05:15 <dented42> monochrome: yes you are correct, it doesn't (as of 2.8.0) evaluate the expression. But I am wondering why the decision was made. Because it seems to me (admittedly with no knowlage of the problems involved) that it would be simpler to have haddock evaluate the expression and insert the correct result, because that would mean that the programmer won't forget to update the documentation if the behavior of the function being documente
14:05:15 <dented42> changes.
14:05:56 <tromp> saim4btd
14:06:04 <sipa> dented42: neither can they have anything less than one argument :)
14:06:44 <sipa> oh
14:06:44 <Zenon1> revenantphx: http://pastebin.com/EBAXgfHU this is the module I wrote for handling continued fractions, and http://pastebin.com/mwtt6zzr this would be the code (I've been using haskell for some 4 days, so there'll probably be tons of ugliness). I know the continuedFractions function works correctly, as I used it to solve another project euler problem, and it calculates the examples in problem 64 (numbers up to 13) just fine, so it can't be 
14:06:45 <Zenon1> completely wrong
14:06:53 <dented42> sipa: huh?
14:06:54 <sipa> that was for djahandarie/Hilbert
14:07:06 <dented42> sipa: oh, ok :-D
14:08:00 <Saizan_> dented42: it seems unlikely that there's been an explicit decision of not doing that, it's more likely that noone got around to request and/or implement it
14:08:25 <dented42> Saizan_: Ah, that makes sense.
14:08:40 <revenantphx> Well, I found a 13 line solution, with newlines and imports Zenon1 
14:08:44 <revenantphx> not to make you feel bad.
14:08:46 <revenantphx> (in haskell)
14:08:54 <dented42> Hilbert: when thinking about currying, and what a function actually does, I think it might help to consider the type of the function.
14:09:16 <dented42> Hilbert: f2 :: Int -> Int -> Int -> Int
14:09:59 <dented42> Hilbert: which can be rewritten as
14:09:59 <dented42> f2 :: Int -> (Int -> (Int -> Int))
14:10:12 <andyjgill> Can someone explain    "Warning: -XImpredicativeTypes is deprecated: impredicative polymorphism will be simplified or removed in GHC 6.14"? Is impredicative polymorphism being replaced, or removed?
14:11:31 <Zenon1> revenantphx: did you use http://tinyurl.com/2bwkgqs to calculate the continued fractions ?
14:12:36 <Saizan_> andyjgill: ghc-7 still has ImpredicativeTypes
14:13:08 <andyjgill> Saizan_: Good. In what way were they simplified?
14:13:37 <Hilbert> dented42: Thanks
14:13:51 <Saizan_> andyjgill: i don't know :)
14:14:25 <andyjgill> Saizan_: Okay. Good to know they are still there. I still use 6.12 right now, and did not want to back myself into a corner.
14:14:47 <dolio> Some impredicative stuff got kind of broken in 7.
14:14:56 <Zenon1> ah well, i could just use the sqrt function and check the cycle lengths of the remainder, but that's somewhat boring
14:15:00 <dolio> But they're probably fixable bugs.
14:17:03 <revenantphx> I didn't do it.
14:17:07 <revenantphx> I just googled it >_>
14:17:25 <revenantphx> The solution I found seems to do some shorthand, but only imports Data.List
14:18:50 <rfh> could anyone please advise: http://pastebin.com/FP7HtSGk  | dont know why line 15 and 16 wont compile
14:19:02 <arcatan> anyone know how to solve this problem with installing cryptocipher? http://hpaste.org/42480/cryptocipher_installation_prob
14:19:25 <mauke> rfh: because addLayer doesn't return Bool
14:20:16 <monochrom> Oh fun, overlapping instances from two sources.
14:21:52 <monochrom> But the (Either e) instance has been in mtl forever. I don't understand why RSA.hs bothers to both use mtl and define its own (Either Error) instance.
14:21:57 <arcatan> hmm, actually, looking at cryptocipher source, their instance of Either Error is enclosed in #if !MIN_VERSION_base(4,3,0)
14:22:35 <rfh> mauke: ghc said that yes, but i don't why...
14:22:57 <mauke> rfh: because you declared it as returning [Htree a]
14:23:05 * arcatan removes the #if .. #endif block
14:23:09 <arcatan> now it compiles
14:23:11 <monochrom> Oh I see. You have to force cabal-install to choose base-4 rather than base-3
14:23:20 <Zenon1> revenantphx, ah well, I'll figure it out eventually :) thanks anways
14:23:37 <ezyang> @tell lispy The Cryptol trial version download form doesn't work. 
14:23:37 <lambdabot> Consider it noted.
14:23:54 <monochrom> nevermind, not a base-3 problem
14:24:09 <lispy> ezyang: Oh, I noticed that earlier this week.
14:24:09 <lambdabot> lispy: You have 1 new message. '/msg lambdabot @messages' to read it.
14:24:25 <monochrom> "base >= 4 && < 7" is a bit too optimistic :)
14:24:30 <lispy> ezyang: It's better to request the commercial eval anyway, because you'll get a more recent version.
14:24:41 <lispy> ?messages
14:24:41 <lambdabot> ezyang said 1m 4s ago: The Cryptol trial version download form doesn't work.
14:25:07 <ezyang> That feels suboptimal. 
14:41:28 <orbital_fox> what would a transform strike you in programming as ?
14:41:41 <orbital_fox> im trying to name some classes and im wondering id that is a good name
14:41:51 <aristid> @tell ManateeLazyCat Please make a version of http://www.youtube.com/watch?v=weS6zys3U8k WITHOUT MUSIC, so it can be viewed in Germany.
14:41:51 <lambdabot> Consider it noted.
14:42:04 <aristid> fucking content nazis (sorry)
14:42:16 <tromp> :t getArgs
14:42:17 <lambdabot> Not in scope: `getArgs'
14:42:50 <orbital_fox> noone?
14:44:02 <Botje> aristid: the description links to a version without sound
14:44:10 <Botje> http://www.youtube.com/watch?v=A3DgKDVkyeM
14:44:25 * hackagebot test-framework-quickcheck2 0.2.9 - QuickCheck2 support for the test-framework package.  http://hackage.haskell.org/package/test-framework-quickcheck2-0.2.9 (MaxBolingbroke)
14:45:03 <aristid> Botje: the description is also hidden due to that restriction
14:45:12 <aristid> Botje: you cannot see title, description or anything
14:45:15 <aristid> it really really sucks
14:45:42 <Botje> aristid: content nazis indeed. :[
14:45:49 <Botje> fwiw, i'm in belgium and I can see it :P
14:45:59 <mauke> GEMA, fuck "yeah"
14:46:08 <hpc> you all need to get US proxies
14:46:17 <hpc> it has all sorts of other benefits too, like hulu
14:46:17 <mauke> "This video contains content from UMG. It is not available in your country. Sorry about that."
14:46:25 <mauke> this is literally all I see
14:46:55 <Botje> do you at least have spotify in germany?
14:47:49 <mauke> "Be one of the first to be updated when Spotify is available in your country!"
14:47:52 <mauke> of course not
14:48:20 <warrenharris> anyone up for a parsec question?
14:48:31 <Botje> boo :(
14:48:48 <Eelis> or how about a memoization question?
14:48:51 <aristid> warrenharris: shoot, somebody might
14:49:00 <copumpkin> Eelis: ?
14:49:07 <Eelis> copumpkin: i figured we could let people vote!
14:49:16 <Eelis> kidding, here it is: i have a function  f :: Int  Int  which is somewhat expensive to compute. normal memoization (using e.g. a trie on the bits) is great, but is a bit too aggressive for my needs, because it never "forgets" anything.
14:49:20 <Eelis> i'd like to give the garbage collector the freedom to reclaim seldom-used branches of the trie, which would have to be recomputed from f if i need them again.
14:49:20 <aristid> Eelis: This question is not available in your country. Sorry about that.
14:49:23 <Eelis> any suggestions on how to accomplish this?
14:49:34 <warrenharris> I'd like to write a parser with user state... but I'm wondering whether it is possible for the state to be an IO operation
14:49:44 <copumpkin> Eelis: hah, it's something I've wanted before, and I think we'd need a bit of support in GHC for it
14:49:48 <copumpkin> without some ugly hacks
14:49:52 <benmachine> warrenharris: IO operation? like what?
14:49:59 <Eelis> copumpkin: yeah, so i feared :)
14:49:59 <copumpkin> Eelis: it's also something edwardk wanted at some point I think
14:49:59 <tromp> :t divMod
14:50:00 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
14:50:05 <mauke> warrenharris: no problem. the tricky part starts when you want to actually execute the action
14:50:07 <warrenharris> I want to write identifiers to a file
14:50:11 <scree> don't weak references do that?
14:50:14 <copumpkin> Eelis: the issue is being able to provide heuristics for forgetfulness
14:50:16 <copumpkin> scree: not really
14:50:26 <Eelis> copumpkin: interesting. yeah, that'd be tricky
14:50:30 <benmachine> hmm
14:50:38 <Botje> warrenharris: ParsecT IO ?
14:50:41 <warrenharris> I tried lifting the IO op to the parser state monad... that seems to work
14:50:55 <Botje> warrenharris: although it kind of makes more sense to accumulate values and only write them to a file at the end
14:51:08 <Eelis> copumpkin: is there a conventional name for this as-of-yet non-existent "pattern" of forgetful memoization?
14:51:13 <warrenharris> I get a parser of type ParsecT s NodeStore IO Node
14:51:23 <warrenharris> where Node is my value type
14:51:51 <warrenharris> Botje: that's what I was wondering
14:52:05 <benmachine> warrenharris: see the Writer monad
14:52:11 <benmachine> but it depends what kind of work you want to do
14:52:14 <warrenharris> the problem I'm having is that my parser also uses a lexer, and the lexer seems to be bound to the Identity monad 
14:52:19 <warrenharris> can't be parameterized to IO
14:52:47 <warrenharris> type TokenParser st = GenTokenParser String st Identity
14:53:17 <revenantphx> Enterprise haskell is: wrapping all IO actions in IO actions to make sure the compiler *really* knows what you mean.
14:53:26 <HaudRex> Where's a working link for the Haskell Platform?
14:53:30 <copumpkin> scree: weak references don't allow you to recompute that which has been forgotten, sadly
14:53:39 <copumpkin> scree: you can ask if it's been forgotten, but once it's forgotten, it's gone forever!
14:53:44 <scree> copumpkin: ah, I see
14:53:45 <copumpkin> you could carry around a function to recompute it
14:53:53 <copumpkin> hmm
14:54:17 <benmachine> warrenharris: hmm, you should be able to convert ParsecT s u Identity a to ParsecT s u m a
14:54:19 <copumpkin> Eelis: I haven't heard of a name for it, but it is definitely something I've wanted, so let me know if you come up with a good name for it :P
14:54:24 <benmachine> I think
14:54:36 <Eelis> copumpkin, scree: these weak references sound intriguing! i'll definitely play around with those
14:55:11 <Eelis> copumpkin: well, i think "forgetful memoization" captures it pretty well :)
14:55:15 <warrenharris> benmachine: I think the problem is that Text.ParserCombinators.Parsec.Token is overly specialized
14:55:17 <copumpkin> Eelis: I think you might be able to hack something together with unsafePerformIO and weak references, with a function () -> a to recompute it as needed, but you'd need somewhere to store usage stats to decide
14:55:37 <copumpkin> I guess with weak references you don't get to choose who gets forgotten
14:55:39 <Botje> Eelis: so it's a student cache >:)
14:56:01 <Botje> why not a splay tree?
14:56:03 <mauke> CacheEvictionPolicyFactory
14:56:22 <Botje> the recently used items bubble up to the top, leaving lesser used items to sink towards the bottom
14:56:29 <BMeph> CAndCMusicFactory
14:56:36 <Botje> you could decide to make everything after a certain level use weak links
14:56:57 <Eelis> Botje: hm, that sounds very good. i'll have to study splay trees :)
14:57:52 <scree> I'm making stuff up here, but I wonder how far you can get with data Foo a = HardLink a | SoftLink (() -> a)
15:00:27 <scree> or rather data Foo a = { calculation :: () -> a, memoized :: Maybe a }
15:01:04 <scree> giving memoize :: Foo a -> Foo a and unmemoize :: Foo a -> Foo a
15:04:33 <bos> preflex: seen jdusek
15:04:33 <preflex>  Sorry, I haven't seen jdusek
15:04:39 <bos> preflex: seen solidsnack
15:04:39 <preflex>  solidsnack was last seen on #haskell 68 days, 3 hours, 59 minutes and 30 seconds ago, saying: zygoloid: However, once you have worked with Ruby modules that try to connect to a database when you load them into your interpreter to inspect some of their definitions, you will be glad for the absence of this functionality :)
15:06:23 <bos> preflex: seen wren
15:06:23 <preflex>  wren was last seen on ##javascript 154 days, 20 hours, 6 minutes and 34 seconds ago, saying: Enter text here...
15:07:12 <djahandarie> wren -> koninkje, iirc
15:13:42 <AmunRa> Hello! Is there a constant to represent infinity? (Hoogle not helping)
15:14:05 <shachaf> AmunRa: As a floating point?
15:14:17 <monochrom> for IEEE 754 infinity you may use 1/0 and (-1)/0
15:14:32 <AmunRa> I'm using an Integer
15:14:40 <monochrom> there is no infinity for Integer
15:14:40 <shachaf> AmunRa: There is no such thing.
15:14:56 <shachaf> AmunRa: For lazy naturals you can use (fix succ).
15:15:11 <djahandarie> For awful performance you can use lazy naturals
15:15:26 <AmunRa> Num a => infinity :: a   --I was being hopeful
15:15:30 <monochrom> For pastime you may use awful performance
15:15:45 <AmunRa> ehh well.. "Maybe Integer" it is then...
15:15:54 <shachaf> djahandarie: Lazy naturals have *far* better (fix succ) performance than Integers.
15:17:50 <monochrom> Num is not a suitable place to house an infinity
15:18:35 <monochrom> if anything it has to be infinity :: HasSingleInfinity a => a
15:19:09 <monochrom> to be distinguished from posinfinity, neginfinity :: HasTwoInfinities a => a
15:19:19 <AmunRa> module `Philosophy` might be an option
15:21:43 <djahandarie> infinities :: Compact a => [a]
15:22:51 <monochrom> I am not sure a list will do. The projective plane has uncountably many infinities.
15:26:59 <Draconx|Laptop> monochrom, note that under IEEE 754 arithmetic, 1/0 and (-1)/0 are not the same as a constant infinity, although it doesn't matter in Haskell.
15:27:35 <monochrom> they are two constants infinities
15:27:57 <Draconx|Laptop> no.  1/0 raises an exception, while a constant infinity would not.
15:29:03 <mauke> then no one uses IEEE 754 arithmetic
15:29:16 <Draconx|Laptop> mauke, hm?
15:29:29 <c_wraith> > 1 / (0.0)
15:29:29 <lambdabot>   Infinity
15:29:30 <mauke> I've yet to see 1/0 raise an exception
15:29:34 <mauke> > 1/0
15:29:35 <lambdabot>   Infinity
15:29:41 <djahandarie> > 0/0
15:29:41 <lambdabot>   NaN
15:29:42 <Draconx|Laptop> mauke, well, Haskell doesn't support floating point exceptions.
15:29:51 <mauke> Draconx|Laptop: does any language?
15:29:54 <Draconx|Laptop> mauke, C does.
15:29:57 <mauke> how?
15:30:03 <monochrom> the exception part is optional and user-customizable in IEEE 754
15:30:05 <Draconx|Laptop> mauke, fetestexcept and friends.
15:30:08 <djahandarie> I recall Infinity and NaN are actually some dirty hacks
15:30:12 <mauke> that's pretty obscure
15:30:25 <mauke> also, C99 only
15:30:47 <Draconx|Laptop> mauke, right.  Before C99 you had to use fortran if you wanted IEEE 754.
15:31:02 <Draconx|Laptop> monochrom, exceptions are a mandatory part of IEEE 754.
15:31:08 <dmhouse> djahandarie: in what sense?
15:31:27 <djahandarie> I don't remember, just that they weren't how I expected them to be
15:31:32 <dmhouse> djahandarie: they may behave in a matter which you might find contrary to mathematical sense, but they satisfy the IEEE semantics
15:31:33 <monochrom> by "optional" I mean user-customizable
15:31:53 <djahandarie> > read "Infinity" :: Double
15:31:54 <lambdabot>   Infinity
15:32:00 <djahandarie> > read "NaN" :: Double
15:32:01 <lambdabot>   NaN
15:32:04 <djahandarie> Hm...
15:32:05 <monochrom> yes, it is mandatory that it is an option. don't you love modal logics.
15:32:20 <djahandarie> I remember something weird here but I can't recall what it was
15:32:23 <dmhouse> djahandarie: this is important because (1) virtually every language implements floats as IEEE-compliant, and (2) CPUs have optimised circuitry for doing IEEE-float computations
15:32:31 <aristid> > read "djahandarie" :: Double
15:32:32 <lambdabot>   *Exception: Prelude.read: no parse
15:32:39 <dmhouse> (Oftentimes float-heavy code is maths number crunching and it's useful if it's fast.)
15:32:50 <aristid> djahandarie: i tried to type your nick correctly this time
15:33:02 <monochrom> well, (read "Infinity") does not raise an exception then.
15:33:02 <Draconx|Laptop> monochrom, well, it's an option in the sense that every implementation must provide them according to the detailed requirements of the standard...
15:33:04 <djahandarie> dmhouse, not talking about IEEE, I'm talking about Haskell's Show/Read Double instance
15:47:25 <silbo_> hey
15:48:20 <silbo_> if I have a function that reads in some user input and return a maybe data
15:48:38 <Martty> the suspense is killing me
15:48:45 <silbo_> ?
15:48:54 <mauke> schrdinger :: Maybe Cat
15:49:16 <aristid> :t let schrdinger = undefined in schrdinger
15:49:17 <lambdabot> Not in scope: `schr'
15:49:17 <lambdabot> Not in scope: `dinger'
15:49:21 <Martty> heisenberg :: Either Momentum Position
15:49:21 <aristid> :(
15:49:52 <aristid> ok, that's just a bug in lambdabot
15:50:08 <mauke> murphy :: Void
15:50:29 <silbo_> is it possible to convert mabe to a restricted data type?
15:50:33 <silbo_> maybe*
15:50:48 <mauke> what
15:51:08 <Bynbo7> silbo_: what do you mean?
15:51:44 <silbo_> i mean if I have a function that returns maybe something, then I can't pass it directly to function that does not declare maybe
15:52:19 <mauke> and if you have a function that returns a string, you can't pass it to a function that takes a number
15:52:21 <Bynbo7> you can use fromJust... but you probably don't want that if the function can return Nothing
15:52:58 <Bynbo7> and if it can't return Nothing, then there's no reason to be using Maybe
15:53:06 <monadic_kid> sibo_: well you could either, use applicative functor, use it as maybe monad, use maybe function
15:53:16 <mauke> :t fromMaybe
15:53:17 <lambdabot> forall a. a -> Maybe a -> a
15:53:41 <Bynbo7> > fmap f (Just x)
15:53:42 <lambdabot>   Ambiguous type variable `b' in the constraints:
15:53:42 <lambdabot>    `GHC.Show.Show b'
15:53:42 <lambdabot>      a...
15:53:58 <silbo_> can maybe somebody explain the whole idea of maybe xD
15:54:02 <Bynbo7> > fmap f (Just x) :: Maybe Expr
15:54:02 <lambdabot>   Just (f x)
15:54:04 <mauke> @src Maybe
15:54:04 <lambdabot> data Maybe a = Nothing | Just a
15:54:11 <mauke> silbo_: optional values
15:54:28 <monadic_kid> :t maybe
15:54:29 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
15:54:44 <mauke> @src maybe
15:54:44 <lambdabot> maybe n _ Nothing  = n
15:54:44 <lambdabot> maybe _ f (Just x) = f x
15:54:48 <Bynbo7> silbo_: the idea of Maybe is that it represents computations that may fail, it is basically use3d where null would be used in C or Java, but us much much much safer
15:56:34 <Bynbo7> >let safeDiv x 0 = Nothing; safeDiv x y = Just (x `div` y) in map (safeDiv 10) [1,2,4,6,0,6,8]
15:56:39 <Bynbo7> > let safeDiv x 0 = Nothing; safeDiv x y = Just (x `div` y) in map (safeDiv 10) [1,2,4,6,0,6,8]
15:56:40 <lambdabot>   [Just 10,Just 5,Just 2,Just 1,Nothing,Just 1,Just 1]
15:58:03 <silbo_> Bynbo7: so the idea is to use a function that returns maybe and check if it returned nothing or something?
15:58:15 <Bynbo7> yeah
15:58:48 <silbo_> and when it returned something then how the fuck I pass it to a fucntion that does not take in a maybe argument
15:59:17 <silbo_> i don't want to write my whole code with maybe this and maybe that
15:59:20 <Bynbo7> well, you can use the maybe function mauke showed you, you can pattern match on the Maybe constructors
15:59:31 <monadic_kid> Bynbo7: your definition of maybe "computation that may fail" is the definition of maybe monad, 
15:59:44 <Bynbo7> monadic_kid: shush
15:59:45 <Bynbo7> :P
15:59:48 <silbo_> xD
16:00:05 <Bynbo7> silbo_: where have you been learning haskell?
16:00:29 <silbo_> Bynbo7: learing it right know at home for my homework at school
16:00:52 <silbo_> Bynbo7: and it is 2 am here
16:00:53 <Bynbo7> well, i suggest you take a break from your homework for a little while and try this:
16:00:56 <Bynbo7> @where lyah
16:00:56 <lambdabot> http://www.learnyouahaskell.com/
16:01:08 <Bynbo7> go there, read it, become a haskell genius
16:01:21 <silbo_> lol
16:01:22 <Bynbo7> well, not really, but it'll get you on your way
16:02:01 <silbo_> ok thx guys, I will try it
16:08:11 <silbo_> this tutorial is actually funny
16:09:08 <Bynbo7> it's supposed to be :)
16:13:51 <aristid> silbo_: GMT+2? where is that?
16:16:16 <dmhouse> Eastern Europe or Western Europe in summertime
16:16:47 <aristid> dmhouse: given that it is not summer, it would be the former
16:26:22 <silbo_> aristid: I live in estonia
16:26:50 <silbo_> aristid: that is in europe, left from russia
16:27:12 <aristid> silbo_: i know that estonia exists :)
16:27:24 <silbo_> good xD
16:27:24 <aristid> i'm not sure, isn't it even in the eurozone?
16:27:45 <silbo_> what do you mean by eurozone?
16:27:53 <silbo_> it is a EU country
16:28:15 <p_l|backup> silbo_: probably the group of countries that adopted Euro as currency? It's the closest term to "Eurozone" I recall :D
16:28:34 <silbo_> we will have euros next year
16:28:42 <theorbtwo> p_l|backup: that's usually spelled as two words -- in English, anyway.
16:29:17 <silbo_> im thinking of buying 100g pure gold
16:29:44 <matt918> 02how much of the standard library is written in haskell?
16:29:57 <mpiechotka> Hello. When I tried to use capri it shows from time to time "extensible-exceptions-0.1.1.2: package has duplicate dependencies: base-4.3.0.0-d6f599ffb7445762058e21fe7a79b625 (use --force to override)". Any idea why it happens?
16:30:18 <p_l|backup> matt918: all of it?
16:30:19 <dmhouse> theorbtwo: "eurozone"? I've never seen that spelled as two words
16:30:27 <matt918> 02oh?
16:30:33 <dmhouse> theorbtwo: http://en.wikipedia.org/wiki/Eurozone
16:30:35 <p_l|backup> dmhouse: depends on the native language of the country, I think
16:30:46 <dmhouse> p_l|backup: yes, but he said Englissh
16:30:48 <dmhouse> *English
16:30:56 <theorbtwo> Hm.  My bad, you're right.
16:31:19 <p_l|backup> dmhouse: yes, but native language influences how certain terms might be spelled if original spelling isn't known
16:32:19 <djahandarie> matt918, the IO primatives like returnIO, bindIO, putChar, etc etc, are magic
16:32:44 <djahandarie> But whether you consider those a part of the standard lib or not...
16:33:35 <qwr> https://github.com/mth/hirc/blob/bcdfb1a348f6bb0f5d8ca1f8acd8712d67a21fd2/HircBot.hs#L144
16:33:51 <qwr> this function seems to leak memory... and i don't understand, why...
16:34:25 <raek> hrm, is the list comprehension syntax just using the list monad under the hood?
16:34:36 <djahandarie> raek, no.
16:34:45 <djahandarie> It used to, but not anymore.
16:35:31 <djahandarie> Well, I can't say for sure that no code is being shared for the list monad and list comprehensions, but list comprehensions don't desugar to the monad code or anything that direct.
16:36:00 <dmhouse> djahandarie: what doesn't desugar?
16:37:10 <djahandarie> [f a | a <- [1,2,3]] doesn't desugar to [1,2,3] >>= (\a -> return $ f a)
16:38:06 <dmhouse> > let f = (*2) in [1,2,3] >>= \a -> return (f a)
16:38:06 <lambdabot>   [2,4,6]
16:38:11 <silbo_> qwr: wtf are you writing a HTTP server with hasekell?
16:38:15 <silbo_> haskell
16:38:21 <qwr> silbo_: not http server
16:38:26 <qwr> silbo_: irc bot ;)
16:38:33 <aristid> djahandarie: well, in theory it could, albeit with a more restrictive type
16:38:42 <aristid> silbo_: why not though?
16:38:42 <dmhouse> djahandarie: do you mean under the hood that's not how the transformation is actually done, or that there's a semantic difference?
16:38:51 <djahandarie> dmhouse, under the hood that is not how it is done
16:39:08 <silbo_> qwr: lol just heard somebody wrote a server for one year know and still not finished
16:39:19 <silbo_> now*
16:39:27 <djahandarie> silbo_, there are plenty of Haskell servers/web frameworks out there
16:39:31 <djahandarie> Happstack, Yesod, Snap
16:39:47 <silbo_> hmm interesting
16:39:51 <qwr> silbo_: the bot actually works fairly well, but it grows about 40kB every time a external plugin is executed
16:39:54 <ddarius> Programming projects are rarely "finished."
16:39:54 <dmhouse> djahandarie: okay. But there's nothing in list comprehensions which couldn't desguar to the list monad, correct?
16:40:03 <djahandarie> dmhouse, right
16:40:20 <qwr> silbo_: which is a bit annoying
16:40:23 <ddarius> dmhouse: With extensions there are things that would need more than MonadPlus.
16:40:42 * qwr suspects runInteractiveProcess
16:40:54 <djahandarie> ddarius, hmm?
16:40:59 <silbo_> qwr: are there any web site examples that are written with haskell?
16:41:00 <ddarius> (And as indicated by that statement, standard list comprehensions already require MonadPlus (or really MonadZero) to be understood generically.)
16:41:19 <dmhouse> ddarius: right, because you need guard. 
16:41:30 <dmhouse> ddarius: what extensions are you referring to? Parallel list comprehensions?
16:42:28 <ddarius> Parallel list comprehension, "comprehensive" comprehensions
16:42:56 <qwr> silbo_: haven't really searched for haskell web examples. i've seen few frameworks.
16:43:33 <silbo_> are functional languages really the future?
16:43:49 <gienah> the haskellers website source code is available, its written in yesod
16:43:51 <silbo_> I really am fascinated of AI programming
16:43:54 <ddarius> No, and pretty much no one has suggested it.
16:44:20 <ddarius> (Unless "functional" just means "has higher order functions" in which case they are the present.)
16:45:46 <gienah> https://github.com/snoyberg/haskellers
16:48:05 <gienah> I think the source code to the snapframework web site is also available, haskellers seems like a more complex site
16:48:51 <qwr> well, looks like I have to rewrite that to use System.Posix. maybe it then stops leaking...
16:50:33 <gienah> the source code to the happstack site is also available, as noted at the bottom of its front page: http://happstack.com/
16:50:36 <mikeg> 40kB is only a leak if you do it a few thousand times
16:52:14 <matt918> 02when i try to tag the haskell libraries i get parse errors complaining that TemplateHaskell is not enabled
16:55:28 <monochrom> {-# LANGUAGE TemplateHaskell #-} ?
16:56:23 <elliott> What's the most "elegant" way to iterate a function until its output equals its input? Some filter on iterate?
16:56:59 <monochrom> write your own recursion
16:57:44 <elliott> monochrom: :/
16:57:54 <elliott> Not even a fold? :p
17:02:08 <matt918> 02monocrom, where should that go?
17:02:25 <shachaf> elliott: fix will always give you a fixed point. :-)
17:02:38 <monochrom> head of source code file
17:02:39 <elliott> shachaf: Indeed :-P
17:02:51 <matt918> 02but i don't want to edit all the standard library files
17:03:00 <elliott> matt918: can you stop that colour?
17:03:06 <matt918> 02?
17:03:06 <elliott> shachaf: Clearly a Sufficiently Smart Compiler will try and find a fixed-point in various, useful manners!
17:03:19 <elliott> matt918: it may just be my client, but you appear to be sending all your messages with blue colour codes.
17:03:28 <Hunner> It's not your client; he is
17:03:30 <matt918> 01is that better?
17:03:36 <elliott> yes, thanks :)
17:03:41 <BONUS> now it's black, lol
17:03:45 <elliott> oh, heh
17:03:56 <elliott> messages are normally black for me, so i didn't notice
17:04:03 <acowley> elliot: You mean the original input, or the input to the most recent recursive call?
17:04:09 <zakwilson> matt918: no, not better. My background is dark grey.
17:04:14 <matt918> 01lol
17:04:15 * Hunner can't read black on black
17:04:19 <ddarius> My background is black.
17:04:27 <j-invariant> How would you interpret a 3-ary function like R -> R -> R -> R in category theory?
17:04:40 <monochrom> black on black is a good way to /ignore
17:05:08 <ddarius> j-invariant: It depends.  You could directly translated to uses of exponentials, but the typical way is to have an arrow out of a 3-product.
17:05:20 <monochrom> you do want to /ignore childish colouring anyway
17:05:33 <ddarius> monochrom: Indeed.
17:05:37 <matt918> 01not sure how to use this client. sorry
17:05:44 <matt918> 01oops. damn it!
17:05:50 <matt918> 01i suck
17:06:21 <matt918> 01does anybody know how to tag the standard library?
17:06:40 <acowley> elliot: if the former, then f x = takeWhile (/= x) (iterate g x). If the latter, then f = unfoldr (\x -> let x' = g x in if x == x' then Nothing else Just x')
17:06:53 <matt918> 01hothasktags doesn't like the template stuff
17:06:55 <acowley> or something like that
17:07:02 <Hunner> matt918: you might want to get a different client that respects the default color. Anyone with a black background can't read anything you're saying
17:07:12 <j-invariant> so if you have + : RxR -> R and * : RxR -> R in a category, would you automatiaclly have \x y z -> x+y*z : RxRxR -> R?
17:07:24 <ddarius> j-invariant: No.
17:07:41 <Eelis> wow, vacuum is really awesome. i had no idea what i was missing
17:07:44 <j-invariant> I don't really get how you are supposed to do algebra inside category theory?
17:07:46 <elliott> Is there a takeWhileExceptForTheFirstOneThatSatisfiesItBecauseLeaveThatOne? :-)
17:07:54 <ddarius> Though typically you are working in a category with all (finite) products.
17:08:20 <monochrom> is that tail . takeWhile p ?
17:08:21 <elliott> thanks acowley btw, but i just ended up writing a recursive function :)
17:08:28 <elliott> (also adding the extra t helps me notice messages :P)
17:08:37 <elliott> monochrom: oh, hm, maybe
17:08:49 <elliott> monochrom: no, i don't think so
17:09:03 <elliott> I mean takeWhileExceptBlahBlah (> 0) [1,2,3,4,5,0,-1] -> [1,2,3,4,5,0]
17:09:07 <acowley> elliott: The Haskell way is to fight upstream until you've eliminated the recursion :P
17:09:07 <monochrom> then I'm not sure what your oh-so-meaningful identifier means.
17:09:37 <elliott> monochrom: er, I mean takeUntil
17:09:40 <monochrom> there is no amount of word mincing or essay writing that could clarify a specification. just formalize it.
17:10:13 <elliott> monochrom: ok: blah p [] = []; blah p (x:xs) | p x = [x] | otherwise = x : blah p xs
17:10:36 <noooooooob> i'm back. hopefully not in black
17:11:00 <noooooooob> everybody happy now. not blinding anyone?
17:12:04 <elliott> monochrom: just wondering whether it already exists or not :)
17:12:08 <noooooooob> does anybody know how to tag the standard library files? when i try to run hothasktags on the source files it complains about template not being enabled
17:12:18 <monochrom> it is not in the standard libs
17:12:45 <acowley> elliott: but I think you could bake that into an unfoldr
17:12:49 <noooooooob> so any idea what the problem is then?
17:13:05 <elliott> acowley: sorry to disappoint you, I wrote another recursive function :-D
17:13:20 <acowley> elliott: :(((((((
17:14:48 <noooooooob> nobody has tagged the standard library? weird 
17:14:58 <monochrom> what is "tag"?
17:15:09 <acowley> elliott: That's probably for the best. I hardly ever keep around a usage of unfoldr after figuring out how to make it work.
17:15:39 <noooooooob> generate a ctags style mapping definitions, so you can jump to definitions of standard library functions from inside vim
17:16:29 <hpc> :t unfoldr
17:16:30 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
17:16:53 <noooooooob> trying to do this using hothasktags, but it complains about TemplateHaskell not being enabled
17:17:36 <monochrom> most standard library functions are unlikely to need TemplateHaskell. I don't know what hothasktags is doing.
17:18:46 <monochrom> and it has not been done previously because probably it would be less useful than tagging certain poorly documented libraries out there.
17:20:27 <ddarius> Last I checked tools typically tag libraries on demand.  They don't (usually) have "tag files" that you download and use.
17:20:41 <monochrom> for example http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.0.0/Data-List.html#v:span "span p xs is equivalent to (takeWhile p xs, dropWhile p xs)" that is more useful than showing you the real code which is optimized beyond recognition.
17:21:35 <monochrom> so the more popular wish is "jump to haddock entry" rather than "jump to internal code"
17:22:05 <noooooooob> i see. thanks. i'll look into that
17:27:04 <elliott> is there any easy way to slurp all of stdin? i.e. non-lazy getContents
17:27:31 * hackagebot attoparsec 0.8.3.0 - Fast combinator parsing for bytestrings  http://hackage.haskell.org/package/attoparsec-0.8.3.0 (BryanOSullivan)
17:27:58 <monochrom> there is a "strict" package on hackage for that. http://hackage.haskell.org/package/strict
17:28:02 <Axman6> elliott: check the bytestring package, it might have hGetContents returning a strict bytestring
17:28:04 <ddarius> elliott: You can use a bytestring or (presumably) text function.  Or you could use the typical hack.
17:28:28 <elliott> ddarius: There's a typical hack?
17:29:11 <ddarius> The typical hack is ugly.
17:29:18 <ddarius> You should use one of the other options.
17:29:34 <elliott> ddarius: Absolutely. But ... theoretically, if this were, say, a one-off hack? :-)
17:29:46 <ddarius> (Incidentally, that strict package uses the typical hack for it's implementation.)
17:29:49 <elliott> I won't tell anyone. Or if I do I'll whisper. Quietly.
17:29:52 <monochrom> something like seq'ing the length of the string
17:29:59 <elliott> Oh, thank you kindly. I will read it now and then not integrate it into my program at all.
17:30:12 <elliott> hGetContents h  = IO.hGetContents h >>= \s -> length s `seq` return s
17:30:14 <elliott> Indeed. Such horror.
17:31:40 <monochrom> the name of the game. the length of the string. the crime of the time. the dog ate my moon.
17:33:04 <elliott> monochrom: Sage words.
17:33:46 <ddarius> My dreams of getting mass amounts of Chinese food are shattered.
17:34:30 <monochrom> I don't see why.
17:34:53 <monochrom> In fact wait 20 more years and you may find that Chinese food will be compulsory.
17:35:58 <ddarius> I would give it a bit more than 20 years, but perhaps you have some insight that I lack.
17:38:11 <a_jazz> I've had some issues with ghc complaining about certain sections of code that contain indentations: I used tabs instead of expanding the tabs into spaces. As soon as I replace tabs with spaces, ghc compiles code without problems. Anyone know why this is?
17:38:36 <Axman6> because DON'T USE TABS!
17:38:37 <Axman6> >_>
17:38:47 <monochrom> because your tab interpretation differs from haskell's tab interpretation
17:38:55 <Axman6> it's a bad idea. the haskell standard says that tabs are treated as 8 spaces
17:39:00 <elliott> *tabrepetation
17:39:02 <a_jazz> aaaahhh
17:39:05 <elliott> *tabretation
17:39:08 <a_jazz> that's the problem, then
17:39:26 <monochrom> not exactly 8 spaces. but you probably know the real meaning.
17:39:29 <a_jazz> I changed vim to expandtab from noexpandtab... :-)
17:39:41 <c_wraith> I'd argue it's the solution.  Well.  the second-best solution.  The best solution is to make tabs a syntax error. :)
17:39:43 <Axman6> stick it in your .vimrc ;)
17:39:54 <a_jazz> already done
17:40:34 <monochrom> you should carefully separate "what happens when I press the tab key" from "what does \t in the file mean"
17:40:48 <monochrom> But then again...
17:40:53 <monochrom> @quote ray 1970s
17:40:53 <lambdabot> ray says: when you're dealing with programmers you are often dealing with people who voluntarily use 1970s terminals. they cannot be reasoned with
17:41:03 <benmachine> c_wraith: -fwarn-tabs -Werror? >_>
17:41:12 <monochrom> that was when people got the two confused
17:41:16 <c_wraith> benmachine, I meant in the language spec
17:41:21 <benmachine> heh
17:41:27 <benmachine> nah
17:41:29 <benmachine> that's wasteful
17:41:36 <benmachine> make them a valid character in identifiers instead
17:41:45 <c_wraith> how about operator characters?
17:41:53 <benmachine> equally good!
17:41:55 <monochrom> you are geniuses
17:42:01 <ddarius> benmachine: More than equally good.
17:42:10 <elliott> no no no
17:42:13 <benmachine> some good are more equal than others
17:42:14 <ddarius> You could have overloaded "whitespace" then.
17:42:16 <elliott> tab characters should be allowed only for alignment
17:42:19 <elliott> and spaces only for indentation
17:42:24 <elliott> the blurst of both worlds!
17:42:34 <a_jazz> I just started learning haskell in earnest about 5 days ago: Learn You A Haskell and Real World Haskell have been my resources
17:42:44 <c_wraith> a_jazz, both good resources
17:42:51 <monochrom> tab should be a synonym for "do"
17:43:15 <elliott> monochrom: tab should be a synonym for <- -- in any context
17:43:21 <elliott> monochrom: -3<tab>2 == True
17:43:37 <benmachine> > -3<-2
17:43:37 <a_jazz> for clarification: ANY amount of space-indentation is an indication of a separate block, right?
17:43:37 <lambdabot>   not an expression: `-3<-2'
17:43:42 <benmachine> :x
17:44:01 <c_wraith> yes, any increased indentation is considered a new block
17:44:09 <monochrom> I am not sure "2" or "2 == True" is a monadic value to begin with.
17:44:19 <elliott> monochrom: no no no, you see,
17:44:26 <elliott> monochrom: it parses as -3 < -2
17:44:27 <c_wraith> :t do 2
17:44:27 <lambdabot> forall t. (Num t) => t
17:44:34 <monochrom> god, that's awful
17:44:37 <elliott> specifically, <tab> is either <- or < -, depending on which is syntactically valid
17:44:40 <elliott> monochrom: *beautiful
17:44:43 <monochrom> but I support it!
17:44:55 <elliott> now _nobody_ make something both an instance of Num and Monad
17:44:56 <ddarius> And if they are both syntactically valid?
17:45:01 <monochrom> > 3<-2
17:45:02 <lambdabot>   not an expression: `3<-2'
17:45:06 <elliott> ddarius: the compiler starts deleting your home directory in the background
17:45:12 <monochrom> but I'm afraid haskell disagrees
17:45:14 <elliott> (as defined in the spec)
17:45:25 <elliott> monochrom: duh, it's only <tab> that does that
17:45:33 <monochrom> oh ok
17:45:34 <elliott> but lambdabot is unfortunately not running on TabHaskell 2010.
17:45:37 <elliott> so i can't demonstrate.
17:46:09 <monochrom> compulsory reading for indentation: http://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-210002.7
17:46:26 <elliott> "Figure 2.2: Sample program with layout expanded"
17:46:31 <elliott> i'm going to write all my programs like this in future
17:46:51 <monochrom> hehehe
17:48:34 <jonathan_> what is syntax for telling runhaskell to include a package?
17:48:34 <mikeg> Does anyone have a copy of BinaryDeriv.hs, or something equivalent?
17:49:12 <monochrom> runhaskell -package globlin ?
17:50:25 <jonathan_> yeah, oddly it seems to ignore the file I pass after that
17:50:58 <jonathan_> runhaskell -package BiArrow Bivalidation.hs is just reporting Not in scope 'main'
17:51:14 <jonathan_> I want it to run Bivalidation.hs
17:51:24 <jonathan_> and use functions in BiArrow
17:52:31 <monochrom> interesting. runhaskell '-package goblin' Bivalidation.hs
17:52:47 <jonathan_> ah quotes
17:52:50 <monochrom> assuming most unix shells
17:52:53 <jonathan_> let me see...
17:52:55 <jonathan_> yeah
17:52:58 <monochrom> for windows use "
17:53:18 <benmachine> hmm
17:53:19 <jonathan_> sweet thanks monochrom
17:53:24 <benmachine> runhaskell Main.hs -package mtl works
17:53:30 <jonathan_> ah
17:53:30 <monochrom> that's also nice
17:53:34 <jonathan_> I'll try that too
17:53:38 <qwr> yeah, when using System.Posix.Process it won't leak anymore
17:53:48 <qwr> as it did with runInteractiveProcess
17:54:48 <jonathan_> fyi, benmachine putting the package second didn't work for me
17:54:59 <jonathan_> but thanks for anyway :)
17:55:01 <benmachine> no?
17:55:03 * benmachine shrug
17:55:06 <benmachine> k
17:55:12 <jonathan_> my thoughts exactly
17:55:14 <jonathan_> :)
17:55:46 <monochrom> it is considered arguments for your main program
17:55:50 <benmachine> ah
17:55:55 <benmachine> of course :P
17:55:58 * benmachine silly
17:56:42 <monochrom> I know it's tricky and the way I tested it I hid a crucial package first.
17:58:55 <monochrom> always watch out for placebo effects
17:59:43 <lars9> which functions other than data constructors and (:) can be used in pattern matching?
17:59:56 <monochrom> this is why education should include the scientific method (as opposed to making you memorize the spelling of "gravity")
18:00:11 <c_wraith> only data constructors, numeric literals, string literals, and list literals can be used in pattern matching
18:00:55 <lars9> the numberic literals?
18:01:10 <monochrom> such as "f 0 = True"
18:01:28 <c_wraith> here's a fun where clause I wrote today!  where { init' = fmap unsafeCoerce init ; clean' = clean . unsafeCoerce ; exec' = exec . unsafeCoerce }
18:01:37 <lars9> oh i see.
18:01:52 <Axman6> lars9: (:) isn't special, it's just another data constructor
18:02:19 <lars9> how to write `minus one` function? (-1) does not work :)
18:02:29 <Axman6> subtract 1
18:02:32 <lars9> :t (:)
18:02:33 <lambdabot> forall a. a -> [a] -> [a]
18:02:35 <Axman6> > subtract 1 6
18:02:36 <lambdabot>   5
18:02:52 <lars9> Axman6: i thought it's a normal function
18:03:00 <djahandarie> - is special in the Haskell grammar
18:03:01 <Axman6> @src []
18:03:02 <lambdabot> data [] a = [] | a : [a]
18:03:02 <shachaf> Or in some cases "pred".
18:03:03 <monochrom> the type doesn't tell you whether you can use it in patterns
18:03:07 <djahandarie> So sections don't work.
18:03:15 <c_wraith> No, : is like a capital letter, for data constructors.
18:03:19 <djahandarie> That's the whole reason the subtract functions exists
18:03:20 <Axman6> lars9: all constructors are normal functions
18:03:23 <Axman6> :t Just
18:03:23 <lambdabot> forall a. a -> Maybe a
18:03:32 <Axman6> :t (,)
18:03:33 <lambdabot> forall a b. a -> b -> (a, b)
18:04:29 <lars9> Axman6: thanks, im aware of that, i meant non-data-constructor functions
18:04:54 <monochrom> :t (\x -> Just x)
18:04:54 <lambdabot> forall a. a -> Maybe a
18:04:57 <Axman6> nope, (:) is just a data constructor
18:05:07 <monochrom> same type. tells you nothing.
18:05:40 <c3l> im new to haskell and was hoping to have some fun with wxHaskell, so I installed it via cabal, but I get error: "can't load .so/.DLL for: stdc++ (libstdc++.so: cannot open shared object file: No such file or directory)" and according to http://hackage.haskell.org/trac/ghc/ticket/3798 it will be fixed at ghc version 7.0.2, which has no date set, and the milestone has been pushed forward for some time. why? and how do I ...
18:05:47 <lars9> @src []
18:05:47 <lambdabot> data [] a = [] | a : [a]
18:05:49 <c3l> ... use wx with haskell? should add that im on gnu/linux - ubuntu.
18:06:17 <Axman6> c3l: why not use gtk like everyone else?
18:06:29 <lars9> @src ``
18:06:29 <lambdabot> Source not found. Do you think like you type?
18:06:30 <Axman6> it's the only really well maintained gui library for haskell
18:06:43 <Axman6> lars9: `x` is syntax
18:06:56 <Axman6> like <-
18:07:46 <djahandarie> lars9,    data List a = Nil | Cons a (List a)    =>    data List a = [] | (:) a (List a)     =>     data [a] = [] | a : [a]
18:08:03 <lars9> Axman6: is [] a normal infix function?
18:08:04 <djahandarie> That final version isn't legal to actually write in Haskell of course
18:08:17 <Axman6> [] is a constructor with no arguments
18:08:23 <monochrom> [] is not an infix function
18:08:27 <c3l> Axman6: hm, I thought wxWidgets was the way to go if you wanted a cross platform gui. but it turns out that was wrong, thanks.
18:08:28 <djahandarie> [] is not a function at all
18:08:40 <djahandarie> Unless we're talking on the type level, in which case it is a type function
18:08:41 <Axman6> :t []
18:08:42 <lambdabot> forall a. [a]
18:09:21 <lars9> i see, the data [] a = [] | a : [a] is not legal syntax?
18:09:39 <Axman6> no, only for lists
18:10:00 <Axman6> well,it is legal syntax, it's just syntax you can't user
18:10:02 <Axman6> -r
18:10:19 <lars9> i thought there is a way to define such surrounding infix functions
18:10:44 <Axman6> you can use data List a = Nil | a <:> (List a) if you like
18:11:03 <monochrom> not <:>. you must begin with :. like :<>
18:11:14 <Axman6> ah, right
18:11:42 <Axman6> i remember testing it and thought it worked, but i used let (<:>) = (:) in ...
18:11:59 <Axman6> which obviously makes it a function, not a constructor
18:12:23 <ddarius> I too think we should drop heavy objects on our students in the name of education.
18:12:41 * djahandarie wonders what conversation ddarius came from
18:14:04 <monochrom> haha
18:17:25 <elliott> an excellent one
19:00:13 <phao> Hi... A kinda offtopic question here. Some functions expect their arguments to be something. For example, factorials expect to receive positive integers.
19:00:30 <phao> What is a good thing to do if received argument isn't in the expected format?
19:01:02 <phao> Of course that the program design would be done so that doesn't happen, but what if it does?
19:01:12 <djahandarie> Normally you try to enforce the constraint on the argument in the type system.
19:01:22 <djahandarie> If you can't, then you error.
19:01:31 <phao> right..
19:01:45 <djahandarie> Error being a 'Maybe', an 'error', etc
19:01:56 <djahandarie> 'Either' works too
19:02:10 <phao> ?/
19:02:11 <lambdabot> Maybe you meant: . ? @ v
19:02:11 <phao> ?
19:02:39 <djahandarie> For Maybe: Nothing would be something bad happened, Just a being when you have a good result.
19:03:20 <djahandarie> For Either String a: Left holds error strings, Right holds good results
19:03:50 <djahandarie> For error: error "something", but it kind of sucks and isn't reflected in the type
19:04:15 <djahandarie> You can use 'fail' from a Monad if you're in one too
19:04:49 <djahandarie> You can ErrorT over IO if you want
19:05:00 <phao> So
19:05:15 <phao> thx =)
19:06:15 <djahandarie> I suppose just 'error' is fine in your case
19:06:27 <phao> yes...
19:06:29 <djahandarie> That's how division by zero, array bounds check, head of empty lists, etc. work
19:06:41 <djahandarie> > head []
19:06:42 <lambdabot>   *Exception: Prelude.head: empty list
19:09:41 <phao> > tail []
19:09:41 <lambdabot>   *Exception: Prelude.tail: empty list
19:09:45 <phao> nice.
19:09:46 <monochrom> Control.Exception.assert is very helpful
19:09:54 <phao> and I can handle exceptions, like in java?
19:10:03 * hackagebot formlets 0.8 - Formlets implemented in Haskell  http://hackage.haskell.org/package/formlets-0.8 (DougBeardsley)
19:10:12 <mm_freak_> :t catch
19:10:12 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
19:10:15 <phao> nice
19:10:27 <phao> I'm a beginner programmer. Never worried much about error handling before
19:10:40 <mm_freak_> Control.Exception is quite powerful
19:10:40 <phao> but I'm kinda starting to worry about it now.
19:10:52 <phao> thx...
19:10:57 <phao> is haskell standard library big?
19:10:59 <mm_freak_> one of my favorite functions is 'bracket'
19:11:20 <mm_freak_> haskell's 'base' library is big for a base library, which includes only the bare minimum
19:11:31 <phao> mm_freak_, right...
19:11:34 <monochrom> yes, kind of big
19:11:45 <lars9> ghc7's is smaller?
19:11:45 <phao> like... C++ big? or Java big?
19:12:11 <mm_freak_> rather C++-style "big"
19:12:22 <phao> right
19:12:24 <phao> thx
19:12:25 <mm_freak_> it has essentials, but lots of them
19:12:25 <lars9> phao: that's almost never a concern
19:13:01 <phao> lars9, most languages I don't care... I'm liking haskell, so I wanna see what is the idea in this programming language
19:13:18 <lars9> don't worry about it untill you get troubles with it
19:13:19 <phao> studying the standard library kindda gives an idea of what is the way people think about programming, in haskell
19:13:32 <phao> in other languages I just look up when I need.
19:13:46 <mm_freak_> btw, exceptions are great for IO stuff, but not so great for almost everything else
19:14:13 <mm_freak_> sqrt :: Float -> Maybe Float  -- this would be more idiomatic than what is currently defined
19:14:39 <lars9> read Prelude then, they'll give you an overview.
19:14:50 <lars9> then Data.List
19:15:07 <lars9> and use hoogle often
19:15:32 <phao> right
19:15:49 <phao> lars9, probably there are the "most used modules"
19:16:04 <mm_freak_> hmm, i almost never import Data.List
19:16:11 <djahandarie> I do fairly often
19:16:11 <phao> but little by little, I have the intention of checking the stadard library as a whole
19:16:18 <lispy> > sqrt (-1) :: Complex Double
19:16:19 <lambdabot>   (-0.0) :+ 1.0
19:17:00 <phao> thx for help
19:17:42 <mm_freak_> in fact i don't view haskell lists as a data structure, but rather as a control structure
19:18:01 <lars9> mm_freak_: that's because many functions for List are exported in Prelude. But it's good to read functions about list.
19:18:16 <mm_freak_> lars9: my point is that i don't use lists a lot
19:19:40 <mm_freak_> beginners step into the pitfall that lists are easier to use than any other data structure
19:19:59 <benmachine> well, they ARE pretty easy to use
19:20:23 <mm_freak_> yes, but they are limited in many ways, so i often find other data/control structures easier to use
19:20:36 <mm_freak_> i mostly use lists where i would use a loop in other languages
19:21:27 <lars9> what data structures do you often use?
19:21:55 <mm_freak_> maps, sets, arrays, bytestrings
19:22:27 <djahandarie> No sequences?
19:22:42 <mm_freak_> nope
19:25:17 <lars9> if m::Map has n elements, m2 = insert i m, after evaluating m2, how much space is required?
19:25:41 <mm_freak_> lars9: n+1
19:27:06 <lars9> mm_freak_: if map is stored in a tree, how can the tree tell i is in m2 but not in m?
19:28:43 <mm_freak_> actually it's only n+1, after m has been garbage-collected  until then my conjecture is that it uses up to n + logBase 2 n + 1 elements
19:28:44 <revenantphx> lars9: wait, can you repeat what you said before?
19:29:21 <lars9> revenantphx: if m::Map has n elements, m2 = insert i m, after evaluating m2, how much space is required?
19:29:33 <revenantphx> m2 is also a map?
19:29:42 <lars9> mm_freak_: i meant both m and m2 are not GCed
19:29:50 <lars9> revenantphx: yeah
19:30:13 <revenantphx> I'd think total space is n+1
19:30:15 <mm_freak_> lars9: then it should be around n + logBase 2 n + 1, because there is one path in m2, which is different from m
19:30:20 <lars9> m2 = Map.insert k v m
19:30:22 <revenantphx> mm_freak_: what?
19:30:48 <djahandarie> revenantphx, sharing
19:30:51 <revenantphx> djahandarie: I know.
19:31:03 <revenantphx> I'd see it as n + 2 then djahandarie :\
19:31:08 <revenantphx> if it was shared optimally, that is.
19:31:21 <benmachine> revenantphx: Maps work by a binary tree of sorts, right?
19:31:27 <benmachine> not binary
19:31:29 <revenantphx> No clue.
19:31:35 <benmachine> well they do
19:31:38 <mm_freak_> revenantphx: think in thunks
19:31:43 <revenantphx> oh this a map, why was I thinking tree :P
19:31:44 <revenantphx> anyways
19:31:50 <mm_freak_> the root thunk needs to reference the changed tree in one branch
19:31:54 <benmachine> because maps are treeish
19:31:57 <benmachine> yes
19:32:05 <mm_freak_> the root thunk of this branch needs to reference the changed tree in once branch
19:32:08 <mm_freak_> etc.
19:32:10 <lars9> n+logn makes more sense
19:32:11 <mm_freak_> until you reach the leaf
19:32:23 <mm_freak_> so i think it's n + logBase 2 n + 1
19:32:24 <revenantphx> why can't the leaf on which its being added be the only thing changing?
19:32:26 <benmachine> Map k a = Tip | Bin k a (Map k a) (Map k a)
19:32:34 <revenantphx> Why does it have to change all the way up to the root
19:32:47 <lars9> the new map is a new path with references to subtrees in original map.
19:32:51 <mm_freak_> revenantphx: because otherwise the root thunk references the old tree
19:33:00 <revenantphx> Oh... I see now.
19:33:14 <revenantphx> So it has to recreate whatever is necessary to access the "new" data.
19:33:27 <mm_freak_> yes
19:33:28 <benmachine> that's one way of looking at it
19:33:29 <lars9> that's neat.
19:33:35 <mm_freak_> but that's only until GC
19:33:44 <revenantphx> ?
19:34:00 <benmachine> it's obvious how much space is used after GC, surely
19:34:07 <mm_freak_> GC deletes the unused portion of the old tree deleteing the old path
19:34:16 <benmachine> oh right
19:34:17 <revenantphx> well yeah
19:34:23 <benmachine> erm
19:34:25 <mm_freak_> so logBase 2 n elements are deleted after GC leaving n + 1 thunks
19:34:29 <revenantphx> I was thinking in the case that the new old tree is still in use.
19:34:31 <benmachine> wait
19:34:38 <benmachine> after GC the old tree has no trace left
19:34:53 <benmachine> so surely you're just left with however much memory it takes to hold a tree
19:35:29 <benmachine> unless you keep both trees around
19:35:30 <mm_freak_> but anyway, GC may happen very early, possibly right inside of 'insert'
19:35:34 <benmachine> in which case they carry on sharing
19:35:52 <mm_freak_> so it's possible that the old and new paths never coexist at all
19:36:04 <mm_freak_> so the overall maximum memory usage may be n + 2
19:36:19 <benmachine> mm_freak_: do you mean that is theoretically possible, or that GHC actually does that?
19:36:30 <mm_freak_> benmachine: theoretically, but GHC is smart
19:36:34 <mm_freak_> so it /might/ do that
19:36:52 <benmachine> I know GHC is smart but I don't know it's that smart :P
19:37:15 <mm_freak_> the only thing i can say is that i've never had performance problems with StateT (Map k a) 
19:38:14 <mm_freak_> i know that GHC is capable of doing early GC to the point where O(n) space algorithms are optimized to O(1)
19:38:18 <mm_freak_> this may be true here as well
19:38:21 <benmachine> in theory the update could be destructive
19:38:24 <revenantphx> mm_freak_: how does that work?
19:38:34 <benmachine> but that rapidly approaches "magic supercompiler" territory which doesn't really count
19:38:36 <a_jazz> does anyone have any idea how I might restrict the precision of a number to two decimal digits to the right of the decimal point?
19:38:36 <mm_freak_> revenantphx: stream fusion is one example
19:38:41 <revenantphx> I don't know about fusion.
19:38:45 <revenantphx> I keep seeing it, but no clue what it is.
19:38:54 <revenantphx> So uh, are the guys who write ghc COMPLETELY INSANE?
19:38:57 <mm_freak_> a_jazz: by not using floating point
19:38:58 <Axman6> revenantphx: it removes intermediate datastructures
19:38:58 <revenantphx> (and magicians?)
19:39:01 <benmachine> revenantphx: aren't we all
19:39:05 <revenantphx> this is true.
19:39:23 <benmachine> a_jazz: do you mean when printing it or genuinely only having that many digits?
19:39:24 <a_jazz> I'm going to try solving this problem--- http://www.codechef.com/problems/HS08TEST/ ---using haskell
19:39:25 <mm_freak_> revenantphx: GHC is about the smartest compiler i know
19:39:42 <mm_freak_> revenantphx: just consider the semantics of the language it compiles, so the GHC developers must be insane to some point =)
19:39:50 <applicative> they seen so rational, at first sight....   the picture of Simon P J on the wikipedia is suggestive though....
19:39:57 <Axman6> revenantphx: the optimisation rule (map f . map g) xs = map (f . g) xs is an example of fusion, sort of
19:40:13 <a_jazz> the numbers are representative of bank acct balances
19:40:15 <ddarius> Haskell's semantics are quite a bit clearer than most languages.
19:40:17 <ddarius> +'
19:40:27 <mm_freak_> revenantphx: stream fusion effectively turns most list operations into loops, completely forgetting about lists
19:40:34 <benmachine> a_jazz: try Data.Fixed
19:40:35 <revenantphx> ???
19:40:40 <benmachine> a_jazz: use the type Fixed E2
19:40:46 <mm_freak_> > take 10 . dropWhile (< 100) . map even $ [1..]
19:40:46 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
19:40:46 <lambdabot>    arising from the literal `10...
19:40:54 <mm_freak_> > take 10 . dropWhile (< 100) . filter even $ [1..]
19:40:55 <lambdabot>   [100,102,104,106,108,110,112,114,116,118]
19:41:01 <a_jazz> benmachine: I suppose the two digits are only relevant when printing
19:41:14 <mm_freak_> revenantphx: this expression likely doesn't use lists at all internally, but just a tight loop
19:41:23 <a_jazz> benmachine, thank you
19:41:39 <benmachine> a_jazz: well, you could store a billion digits and only print 2, or you could really use actually only two digits
19:41:48 <benmachine> a_jazz: Data.Fixed does the latter
19:41:52 <revenantphx> I... seee.
19:41:54 <benmachine> and also doesn't have horribly nasty rounding errors
19:42:14 <benmachine> and also has phantom types, which are pretty clever
19:42:24 <mm_freak_> revenantphx: for math algorithms i often write an infinite list and look up some element from it
19:42:42 <mm_freak_> stream fusion turns this into a loop in about the same way you would write it in C
19:42:51 <minsa> I am confused between haskell and scheme.. I tried scheme for about two weeks and it was fun..
19:43:04 <revenantphx> What is this codechef a_jazz?
19:43:07 <minsa> and I tried haskell for a few days and it was fun. I didn't even miss scheme that much.
19:43:13 <Axman6> revenantphx: stream fusion does things like turning sum [1..100] into something like x where x = f 1 0; f x acc | x < 100 = f (x+1) (acc+x) | otherwise = x
19:43:23 <minsa> but it was so much fun doing scheme too.
19:43:31 <revenantphx> Axman6: I'm sorry you're just confusing me D:
19:43:38 <revenantphx> minsa: just do both >_>
19:43:41 <djahandarie> Short cut fusion goes a long way. Stream fusion goes even further.
19:43:47 <revenantphx> Axman6: mainly its hard to read in irc
19:43:48 <a_jazz> revenantphx, a place to practice coding. It's an online judge that accepts solutions to problems in about 35 programming languages
19:43:50 <ddarius> djahandarie: No it doesn't.
19:43:55 <ddarius> djahandarie: It goes in a different direction.
19:43:55 <revenantphx> I should use a monospaced font in irc....
19:44:07 <djahandarie> ddarius, I meant in the direction of 'fast'
19:44:09 <revenantphx> But Lucida Grande is just...
19:44:13 <revenantphx> so nice to look at TT_TT
19:44:15 <minsa> revenantphx: that's what I am thinking. but it scares me that with haskell, I was forgetting the joy with scheme.
19:44:23 <revenantphx> minsa: Oh don't worry.
19:44:24 <ddarius> That said, I think the main problem they were having was fixed in one of the later 6s or maybe in 7.
19:44:24 <minsa> and scheme and clojure are just basically the same.
19:44:32 <revenantphx> minsa... I know the perfect thing for you!
19:44:36 <a_jazz> revenantphx, I'm practicing my programming skills, since I don't get much opportunity while in school
19:44:42 <revenantphx> minsa: http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
19:44:43 <Axman6> revenantphx: http://donsbot.wordpress.com/2010/02/26/fusion-makes-functional-programming-fun/
19:44:43 <revenantphx> here :D
19:44:57 <minsa> dang... thnx.. I will check it out.
19:45:08 <mm_freak_> minsa: after programming for a while in haskell, almost every other language becomes an exercise in pain
19:45:08 <revenantphx> I found it fun, though it does tend to MAKE YOU REWRITE EVERYTHING
19:45:33 <revenantphx> When it adds error handling.
19:45:34 <revenantphx> Anyways.
19:45:43 <revenantphx> So uh
19:45:45 <mm_freak_> minsa: if you don't understand haskell well yet and you have to use other languages, flee as long as you can ;)
19:46:04 <revenantphx> can the compiler tell if a function is not safe to optimize (it has side effects) if you use unsafePerformIO or something like that?
19:46:14 <mm_freak_> revenantphx: no
19:46:21 <revenantphx> So... you could really fuck stuff up?
19:46:26 <mm_freak_> yeah
19:46:29 <Philippa> it's called unsafe for a reason
19:46:51 <mm_freak_> simple example:  unsafePerformIO randomIO
19:46:55 <revenantphx> yeah.
19:47:00 <ddarius> revenantphx: Modulo one thing the MLers ran into decades ago, unsafePerformIO isn't terribly unsafe in and of itself.
19:47:24 <revenantphx> So it isn't marked in some way so ghc can... you know, not do those optimizations?
19:47:31 <ddarius> It won't cause segmentation faults or stuff like that (unless what you are calling could)
19:47:46 <mm_freak_> revenantphx: it's more about semantics than about optimization
19:47:48 <djahandarie> revenantphx, there are legitimate uses of unsafe* though, and it'd prevent those.
19:47:51 <Axman6> let x = unsafePerformIO randomIO in (x,x), the compiler is free to either make x the same value, or turn it into (unsafePerformIO randomIO, unsafePerformIO randomIO)
19:48:11 <Axman6> because, x is pure, according to its type
19:48:14 <revenantphx> Axman6: wouldn't lazyness favor the latter?
19:48:18 <mm_freak_> revenantphx: in haskell referential transparency is not just an assumption for the optimizer, it's a semantic requirement
19:48:29 <Axman6> revenantphx: implementations favour one or the other
19:48:35 <revenantphx> Hm.
19:48:41 <mm_freak_> that's why unsafePerformIO is, well, "unsafe"
19:48:46 <Axman6> so, your results may be truly random
19:48:53 <mm_freak_> not because it can delete your files, but because it breaks semantics
19:49:11 <Axman6> it's also possible that let x = unsafePerformIO randomIO in x == x could return False
19:49:25 <Axman6> mm_freak_: but there's that too :P
19:49:36 <mm_freak_> Axman6: sharing would ensure that x == x = True
19:49:46 <zaphar_laptop> is there a way to get a complete dependency graph for a cabal build anywhere? or am I going to have to code that myself?
19:50:18 <mm_freak_> > let x = unsafePerformIO randomIO in (x::Int,x,x,x)
19:50:18 <mm_freak_> (-346110750,-346110750,-346110750,-346110750)
19:50:18 <lambdabot>   Not in scope: `unsafePerformIO'
19:50:44 <Axman6> hmm, sure, but that's not quaranteed right?
19:50:56 <minsa> revenantphx, mm_freak_: sadly, c++, the language I started out has become a stranger to me now. Granted, I haven't checked out the latest additions. I honed my discipline but finishing 6 chapters of "The C++ Programming Language" one summer. That was not easy.
19:50:58 <mm_freak_> (but of course, since it's "random", that might be a coincidence, too) =P
19:51:00 <Axman6> the compiler doesn't have to implement that optimisation
19:51:15 <revenantphx> C++ is to me, the antithesis to Haskell
19:51:20 <revenantphx> I can't exactly back that up...
19:51:25 <revenantphx> but it just *feels* like that.
19:52:29 <lispy> revenantphx: I think Java fills that role better than C++ does.
19:52:36 <listofoptions> revenantphx, i would have to agree the template system is very obfuscating
19:52:43 <lispy> revenantphx: Remember, you can do purely functional programming in C++ template system :)
19:52:49 <revenantphx> heh.
19:53:01 <listofoptions> compared to haskell's transparency
19:53:05 <revenantphx> "I don't write C++... I only write code in its templating language"
19:53:11 <listofoptions> lmao
19:53:16 <revenantphx> "I write enterprise servers in C++'s templating language"
19:53:21 * Axman6 would call Io the antethesis of haskell
19:53:25 <revenantphx> "You run them by invoking C++"
19:53:29 <revenantphx> Axman6: hah.
19:53:30 <revenantphx> How so?
19:53:47 <Axman6> it's completely dynamic and horrible :P
19:53:48 <revenantphx> Io's fun to play with imo, but yeah, totally different than haskell.
19:53:53 <revenantphx> It's fun to play with though :P
19:53:59 <mm_freak_> i think C is the antithesis of haskell
19:54:09 <mm_freak_> much like brainfuck is the antithesis of lazy k
19:54:36 <djahandarie> I think this conversation is an abuse of the word antithesis.
19:54:42 <revenantphx> Actually... I think brainfuck would be the antithesis.
19:54:48 <Axman6> revenantphx: did you read that article of dons' i pasted?
19:54:51 <revenantphx> *every* operation has side effects.
19:54:59 <revenantphx> I'm about too.
19:55:15 <mm_freak_> yeah, and in lazy k there are no side effects
19:55:39 <revenantphx> By the way guys D:...
19:55:42 <djahandarie> revenantphx, if you want to understand how stream fusion works you're going to need to spend a decent amount of time since there is no real guide to it
19:55:51 <revenantphx> every time I ever mention haskell anywhere...
19:55:52 <ddarius> lispy: Not just purely functional, lazy pure functional.
19:55:58 <djahandarie> But understanding 'what it does usually' is pretty easy
19:56:01 <revenantphx> people link the yegge post and it makes me saaaaad TT_TT
19:56:11 * revenantphx curls up in the corner.
19:56:14 <Axman6> yegge?
19:56:19 <djahandarie> revenantphx, I've noticed that also
19:56:27 <ddarius> There is actually quite a bit of similarity between C++ and Haskell.
19:57:11 <ddarius> djahandarie: There's a paper that explains everything.
19:58:19 <djahandarie> Right, dons'.
19:58:43 <mm_freak_> revenantphx: i usually convince people with actual code and don't care about stupid blog posts
19:58:56 <Axman6> what blog post? :\
19:59:07 <revenantphx> mm_freak_: The only code I have to show is my protocol implementation using Data.Binary
19:59:17 <revenantphx> It's just under 300 lines.
19:59:29 <revenantphx> The average one I've seen from other people is... 700-800
19:59:41 <mm_freak_> Axman6: no specific one, but there are enough haskell rants to pick from
19:59:44 <revenantphx> But that only works for people who know the pain of writing that in other language.
19:59:47 <ddarius> djahandarie: I would probably say it's Duncan's more than Don's.
20:00:42 <mm_freak_> Axman6: the only one of those rants i like is this one:  http://lukeplant.me.uk/blog/posts/why-learning-haskell-python-makes-you-a-worse-programmer/
20:01:03 <monochrom> the yegge post is probably sarcasm
20:02:11 <lispy> ddarius: what is the difference between purely functional and lazy pure functional?
20:02:12 <djahandarie> It is satire
20:02:33 <ddarius> lispy: You can quite readily have an eager purely functional language.
20:03:11 <ddarius> It is just childish whether it's sarcasm or not.
20:03:26 * djahandarie agrees
20:03:33 <lispy> ddarius: are you just adding that C++ templates are lazy?  Or was there more to it that I'm not understanding?
20:03:48 <revenantphx> lazy/eager is about evaluation, pure/impure is about semantics.
20:04:03 <ddarius> lispy: That's usually what the "not just" idiom means.
20:04:40 <lispy> ddarius: I was confused by the switch from "purely functional" to "lazy pure functional"
20:04:45 <ddarius> revenantphx: Lazy/eager is just about a different thing than pure/impure entirely.  Strict/non-strict is about semantics.
20:05:01 <lispy> ddarius: I thought maybe in your terminology "pure functional" != "purely functional"
20:05:07 <revenantphx> ddarius: er
20:05:08 <revenantphx> erp*
20:05:40 <adu> ddarius: whats the difference between nonstrict and lazy?
20:06:05 <djahandarie> ddarius, what should I study next semester?
20:06:15 <lispy> The way I learned it, lazy/eager -> graph reduction strategy, pure/impure -> are side-effects allowed/constrained
20:06:15 <ddarius> Laziness is a particular implementation of non-strictness.
20:06:55 <ddarius> djahandarie: Complex analysis (and the many and varied fields connected to it, which is almost all of mathematics, particularly applied mathematics.)
20:07:18 * djahandarie was joking
20:07:23 <monochrom> I sometimes use crazy evaluation to get non-strictness. crazy evaluation means spawn off threads to evaluate in the background, kill them when you don't need them later.
20:07:24 * ddarius wasn't.
20:07:36 <revenantphx> So guys, quick question
20:07:40 <revenantphx> what do you think of linked accounts?
20:07:44 <lispy> monochrom: That's McCarthy's amb, right?
20:07:56 <ddarius> lispy: No.
20:09:35 <monochrom> an example is http://conal.net/blog/posts/lazier-functional-programming-part-1/#comment-56929
20:09:56 <monochrom> I call it crazy evaluation because it's crazy. or frenzy.
20:10:16 <monochrom> but I like crazy and lazy sharing many letters
20:10:50 <monochrom> to get non-strictness you have to be bipolar, sometimes lazy and sometimes crazy :)
20:11:22 <lispy> ddarius: ah, I got idea from reading the PhD dissertation version of this: http://portal.acm.org/citation.cfm?id=667699
20:11:51 <zimbabwe> newbie question: how does one apply in haskell.  In Scheme (apply * '(2 3 4)) evalutes to 24.  In Haskell I thought the equivalent might be (*) ($) [2, 3, 4], but apparently not.  Help!
20:12:07 <monochrom> interesting
20:12:33 <Philippa> zimbabwe: you've got two issues there, because * in Scheme doesn't work like * in most languages (Haskell included)
20:12:53 <mm_freak_> > product [2, 3, 4]
20:12:54 <lambdabot>   24
20:12:55 <Axman6> zimbabwe: haskell doesn't have a way to apply a function to many arguments, their types determine how many things they can be applied to
20:13:08 <ddarius> Axman6: Namely one.
20:13:15 <Axman6> > foldl (*) 1 [2,3,4]
20:13:16 <lambdabot>   24
20:13:27 <Axman6> ddarius: ... yeah, but we'll get to that ;)
20:13:28 <monochrom> well, 1 or 0.
20:13:30 <ddarius> Blech foldl.
20:13:52 <ddarius> monochrom: If it's a function it can be applied at least once.
20:13:54 <benmachine> Axman6: the way to apply a function to many arguments is to use a list :P
20:14:40 <mm_freak_> benmachine: not in general
20:14:41 <Axman6> sure, but it's not part of the language
20:14:59 <mm_freak_> benmachine: lists are homogenous
20:15:06 <mm_freak_> and it's not good programming style either
20:15:16 <zimbabwe> Philippa, mm_freak, Axman6: thank you
20:15:58 <mm_freak_> anyway, zimbabwe, just note that (*) is a binary function in haskell, so you can only apply it to exactly two arguments to get a result
20:16:07 <mm_freak_> :t (*)
20:16:08 <lambdabot> forall a. (Num a) => a -> a -> a
20:16:48 <dibblego> use a Traversable
20:17:12 <mm_freak_> dibblego: Foldable
20:17:26 <benmachine> mm_freak_: yeah but most of the time when you want a variadic function the types of the arguments are the same or at least predictable
20:17:30 <dibblego> mm_freak_, Foldable givs you mapM_ but not mapM
20:17:47 <revenantphx> Oh, one question.
20:17:59 <mm_freak_> dibblego: and foldl/foldr
20:18:01 <revenantphx> How should I read a number from input in haskell? read a line then parse from it?
20:18:24 <mm_freak_> benmachine: they /have to/ be predictable
20:18:29 <Axman6> :hoogle Read a => IO a
20:18:33 <mm_freak_> static typing and stuff
20:18:35 <revenantphx> :|
20:18:37 <dibblego> mm_freak_, I was thinking t (x -> y) -> x -> t y
20:18:38 <Axman6> @hoogle Read a => IO a
20:18:38 <lambdabot> Prelude readLn :: Read a => IO a
20:18:38 <lambdabot> System.IO readLn :: Read a => IO a
20:18:38 <lambdabot> Prelude readIO :: Read a => String -> IO a
20:18:41 <revenantphx> right. read.
20:18:46 <Axman6> readLn
20:18:58 <mm_freak_> dibblego: if anything you want foldM, not mapM =)
20:19:13 <dibblego> @type Data.Traversable.sequence
20:19:13 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Traversable.Traversable t, Monad m) => t (m a) -> m (t a)
20:19:41 <mm_freak_> revenantphx: i fell in love with iteratees
20:19:53 <revenantphx> I'm planning on spending all of tomorrow on them :)
20:19:57 <revenantphx> If you have links ,give me them.
20:20:20 <mm_freak_> revenantphx: http://docs.yesodweb.com/blog/enumerators-tutorial-part-1/
20:20:29 <mm_freak_> tutorial for the 'enumerator' package
20:20:59 * ddarius doesn't believe Google Desktop's estimates for this first-time index.
20:21:01 <revenantphx> So, is there an analog to read other than show?
20:21:07 <revenantphx> that has some showLn type thing?
20:21:22 <Axman6> print?
20:21:22 <revenantphx> it's... something like println isnt ti
20:21:24 <Axman6> :t print
20:21:25 <lambdabot> forall a. (Show a) => a -> IO ()
20:21:26 <revenantphx> With a newline.
20:21:42 <Axman6> @src print
20:21:42 <lambdabot> print x = putStrLn (show x)
20:21:47 <revenantphx> :|
20:21:48 <revenantphx> fail
20:22:12 <ddarius> fail is a different function.
20:22:17 <Axman6> fail? what? it's exactly what you asked for...
20:22:21 <revenantphx> >_>
20:23:58 <revenantphx> hahaha. I tried the easiest of the problems with haskell...
20:23:59 <revenantphx> Correct Answer 
20:23:59 <revenantphx> Execution Time: 0.00
20:24:15 <revenantphx> Needs more precision mate.
20:27:18 <copumpkin> Eelis: did you figure out the weak references thing?
20:29:47 <ddarius> > 90 / 4
20:29:48 <lambdabot>   22.5
20:30:25 * hackagebot cabal-dev 0.7.2 - Manage sandboxed Haskell build environments  http://hackage.haskell.org/package/cabal-dev-0.7.2 (RoganCreswick)
20:30:38 <revenantphx> How does one, without getting into parsec and such, read in something like
20:30:45 <revenantphx> "90.0 120.0"
20:30:58 <revenantphx> ( a scanf equivalent'd be nice)
20:31:23 * ddarius has never used and never wanted to use scanf.
20:31:30 <ddarius> revenantphx: Just use reads.
20:31:39 <ddarius> Or words and read.
20:31:52 <revenantphx> oh, words would help
20:31:55 <revenantphx> "The read function reads input from a string, which must be completely consumed by the input process."
20:31:58 <ddarius> If you want to be very particular, you could use a regex.
20:32:09 <ddarius> reads /= read
20:32:29 <djahandarie> If you are using regex you should probably just switch to parser combinators
20:32:36 <djahandarie> At least I usually do because regex is a pita
20:32:46 <revenantphx> reads
20:32:47 <revenantphx> ?
20:32:50 <ddarius> :t reads
20:32:51 <lambdabot> forall a. (Read a) => String -> [(a, String)]
20:33:00 <revenantphx> @hoogle reads
20:33:00 <lambdabot> Prelude reads :: Read a => ReadS a
20:33:00 <lambdabot> Text.Read reads :: Read a => ReadS a
20:33:00 <lambdabot> Prelude type ReadS a = String -> [(a, String)]
20:33:09 <ddarius> > map read $ words "90.0 120.0" :: [Double]
20:33:10 <lambdabot>   [90.0,120.0]
20:33:48 <revenantphx> oic.
20:34:02 <revenantphx> is that just what reads does?
20:34:23 <ddarius> Obviously not.
20:34:33 <revenantphx> >_<
20:34:51 <revenantphx> ugh
20:35:38 <copumpkin> reads gives you all valid parses, supposedly, if the parser supports it
20:35:42 <copumpkin> which none of the built-in ones do
20:36:00 <ddarius> They all "support it."  None of them are ambiguous.
20:36:28 * hackagebot cabal-dev 0.7.2.1 - Manage sandboxed Haskell build environments  http://hackage.haskell.org/package/cabal-dev-0.7.2.1 (RoganCreswick)
20:36:43 <ddarius> I think one of the determining factors for reads' type is so it could be used in list comprehensions.
20:48:23 <revenantphx> ddarius: What if I'm not reading only one type?
20:50:12 <ddarius> The use reads.
20:50:15 <ddarius> +n=
20:50:48 <revenantphx> type ReadS a = http://hackage.haskell.org/packages/archive/base/4.3.0.0/doc/html/Prelude.html#t:String -> [(a, http://hackage.haskell.org/packages/archive/base/4.3.0.0/doc/html/Prelude.html#t:String)]
20:50:50 <revenantphx> er
20:50:55 <revenantphx> type ReadS a = String -> [(a, String)]
20:51:04 <revenantphx> :t reads
20:51:05 <lambdabot> forall a. (Read a) => String -> [(a, String)]
20:51:14 <revenantphx> :|
20:51:17 <copumpkin> revenantphx: presumably you already know the set of types you're reading?
20:51:22 <djahandarie> @hoogle reads
20:51:22 <lambdabot> Prelude reads :: Read a => ReadS a
20:51:22 <lambdabot> Text.Read reads :: Read a => ReadS a
20:51:22 <lambdabot> Prelude type ReadS a = String -> [(a, String)]
20:51:24 <revenantphx> One int, one double.
20:51:37 <copumpkin> then read them separately
20:51:44 <revenantphx> ugh, seems like the only option.
20:52:42 <revenantphx> And if they're on the same line copumpkin?
20:52:48 <Mathnerd314> is there a generics instance for HasLub?
20:53:08 <copumpkin> > fmap (fmap (listToMaybe . (reads :: String -> [(Double, String)]) . tail). listToMaybe $ reads "1 3.5" :: [(Int, String)]
20:53:09 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
20:53:21 <copumpkin> > fmap (fmap (listToMaybe . (reads :: String -> [(Double, String)]) . tail)) . listToMaybe $ reads "1 3.5" :: [(Int, String)]
20:53:22 <lambdabot>   Couldn't match expected type `[(GHC.Types.Int, GHC.Base.String)]'
20:53:22 <lambdabot>         a...
20:53:28 <copumpkin> meh
20:53:41 <ddarius> revenantphx: What do lines have to do with anything?
20:53:47 <revenantphx> nmd that
20:53:56 <revenantphx> Basically I want scanf("%d%f\n", &a, &b);
20:54:25 <revenantphx> without resorting to a fancy parser.
20:55:21 <jmcarthur> what's wrong with reads?
20:55:30 <ddarius> revenantphx: You've already been given two answers multiple times.
20:55:41 <copumpkin> > (liftM2 (,) . (\[x, y] -> (fmap fst . listToMaybe . reads $ x), (fmap fst . listToMaybe . reads y)) $ words "1 3.5") :: (Int, Double)
20:55:41 <lambdabot>   Couldn't match expected type `GHC.Base.String'
20:55:41 <lambdabot>         against inferred typ...
20:55:48 <revenantphx> reads gives you an array [a]
20:55:48 <copumpkin> fuck you lambdabot
20:55:56 <jmcarthur> that's not a problem
20:55:57 <revenantphx> The two values are not of the same type.
20:56:07 <revenantphx> Or should I just force them both as Double?
20:56:26 <ddarius> revenantphx: You don't understand reads and [a] is not an array.
20:56:35 <revenantphx> list... sorry.
20:56:44 <revenantphx> Then please explain TT_TT
20:56:46 <jmcarthur> > reads "5 \"foo\"" :: [(Int, String)]
20:56:46 <lambdabot>   [(5," \"foo\"")]
20:56:56 <jmcarthur> > reads "5 True" :: [(Int, String)]
20:56:57 <lambdabot>   [(5," True")]
20:57:10 <revenantphx> the string is just whats left...
20:57:14 <jmcarthur> right
20:57:16 <ddarius> revenantphx: You could also read the variety of documentation available.  reads is a completely standard function.
20:57:19 <jmcarthur> so use it with read
20:58:28 <jmcarthur> > (map.second) read $ reads "5 True" :: [(Int, Bool)]
20:58:29 <lambdabot>   [(5,True)]
20:58:50 <revenantphx> Yeah I got it now.
21:00:16 <lispy> :t map.second
21:00:17 <lambdabot> forall b c d. (b -> c) -> [(d, b)] -> [(d, c)]
21:00:33 <revenantphx> :t map . second
21:00:34 <lambdabot> forall b c d. (b -> c) -> [(d, b)] -> [(d, c)]
21:01:34 <revenantphx> @hoogle second
21:01:34 <lambdabot> Control.Arrow second :: Arrow a => a b c -> a (d, b) (d, c)
21:01:34 <lambdabot> Data.Time.Clock secondsToDiffTime :: Integer -> DiffTime
21:01:34 <lambdabot> Data.Time.Clock.TAI type LeapSecondTable = Day -> Integer
21:01:46 <revenantphx> snd
21:01:47 <revenantphx> ?
21:01:53 <revenantphx> :t map . snd
21:01:53 <lambdabot> forall a b a1. (a1, a -> b) -> [a] -> [b]
21:02:01 <revenantphx> apparently not...
21:02:23 <revenantphx> :t second
21:02:24 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
21:02:26 <revenantphx> what is this TT_TT
21:02:40 <kmc> (b -> c) -> ((d,b) -> (d,c))
21:02:48 <kmc> that is, read a as "->"
21:02:53 <kmc> except it generalizes to the Arrow type class
21:03:07 <revenantphx> hm
21:03:28 <kmc> (Arrow (~>)) => (b ~> c) -> ((d, b) ~> (d, c))
21:05:31 <revenantphx> oh that makes it a bit easier.
21:06:11 <revenantphx> do you have a quick trivial example?
21:06:17 <kmc> > second show (2,3)
21:06:18 <lambdabot>   (2,"3")
21:06:34 <revenantphx> > second (+1) (1,1)
21:06:34 <lambdabot>   (1,2)
21:06:56 <revenantphx> oh, so it just only applies the function (arrow?) to the second element?
21:07:03 <kmc> yeah
21:07:13 <kmc> i'm not sure what you call "a value whose type is a member of the Arrow type class"
21:07:38 <kmc> i'm sure it's sometimes called "an arrow"
21:07:46 <kmc> but that's kind of inconsistent
21:07:58 <kmc> anyway the Arrow class is not very widely used
21:08:04 <revenantphx> so if I'm in monadland
21:08:06 <kmc> 90% of the time you see Arrow functions, they'll be for (->) anyway
21:08:07 <revenantphx> let (w, b):_ = (map . second) read $ reads ln :: [(Int, Double)]
21:08:45 <kmc> monadland?
21:09:00 <revenantphx> In a monad >_>
21:09:06 <revenantphx> > 0.5 > 10
21:09:07 <lambdabot>   False
21:09:55 <revenantphx> > let w = 10; b = 150.0 in (w + 0.5 < b)
21:09:55 <lambdabot>   True
21:10:02 <revenantphx> Now why doesn't ghci like that for me.
21:11:25 <kmc> "in a monad"?
21:11:40 <kmc> it works for me revenantphx
21:11:57 <revenantphx> hm, must just be in context.
21:12:15 <revenantphx> https://gist.github.com/751121
21:12:34 <revenantphx> fails for me
21:12:37 <revenantphx>  Couldn't match expected type `Int' against inferred type `Double'
21:12:38 <revenantphx>     In the second argument of `(<)', namely `b`
21:13:50 <magicman> @type (map . second)
21:13:50 <lambdabot> forall b c d. (b -> c) -> [(d, b)] -> [(d, c)]
21:14:13 <magicman> Oh, right. I see.
21:15:35 <magicman> revenantphx: w is an Int, and b is a Double. (<) works only for two values of the same type.
21:15:42 <jmcarthur> @where sec
21:15:42 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
21:15:50 <revenantphx> so, fromIntegral on w?
21:15:58 <etpace> how would I test if its possible to connect to a port?
21:16:00 <magicman> Aye.
21:16:20 <Axman6> etpace: try (connectTo ...) and handle the Either case works for me
21:16:30 <Axman6> cases*
21:20:49 <lispy> Does Haskell provide a standard ESB?
21:20:55 <lispy> http://en.wikipedia.org/wiki/Enterprise_service_bus
21:21:11 <djahandarie> It has the word enterprise in it, so Java probably provides it.
21:21:28 <lispy> djahandarie: java implementations abound.  see for example, Kuali.
21:21:32 <Axman6> lispy: >___< buzzword overload
21:21:50 <lispy> But, Manatee is like an ESB just on your desktop.
21:22:55 <ddarius> @google "Nondeterminism in functional languages"
21:22:58 <lambdabot> http://comjnl.oxfordjournals.org/content/35/5/514.full.pdf
21:22:58 <lambdabot> Title: cache:http://comjnl.oxfordjournals.org/content/35/5/514.full.pdf - Google Search
21:23:26 <lispy> How do we solve the problems that an ESB solves in haskell?  (My answer: We don't try to solve the problems.  Not even a little bit, which is worse than at least trying to solve those problems.)
21:24:15 <kmc> lispy, i can't penetrate the thicket of buzzwords
21:24:23 <kmc> and i think you'll find that attitude prevails in the Haskell community
21:24:30 <kmc> anyway if i understand what an ESB actually is
21:24:31 <djahandarie> If you word 'problems that an ESB solves' in some way that doesn't involve parsing some crazy lingo then I'll try and solve it
21:24:40 <kmc> == djahandarie
21:24:42 <listofoptions> oh snap minecraft beta is out
21:24:52 * listofoptions wanders off topic
21:24:53 <kmc> lispy, anyway if my guess about wtf an ESB is is correct...
21:25:00 <kmc> we do have bindings to zeromq and rabbitmq
21:25:04 <kmc> several of them
21:25:27 <kmc> also soap and xml-rpc
21:25:41 <kmc> one of the bullet-listed properties of an ESB there is "must use XML"
21:25:43 <kmc> which seems... wrong
21:25:49 <kmc> as a way to define a technological concept
21:25:59 <ddarius> You can be a Middleware Analyst?
21:25:59 <ian_mi> yes, but do they implement an SOA-2.0 business enriched architecture?
21:26:30 <djahandarie> No doubt.
21:26:39 <etpace> @hoogle hclose
21:26:39 <lambdabot> System.IO hClose :: Handle -> IO ()
21:26:41 <kmc> also their idea of language-agnostic is "works in Java and .NET"
21:26:46 <kmc> except they spell Java as "JAVA"
21:27:23 <ddarius> One should perhaps not view Wikipedia as authoritative...
21:27:55 <revenantphx> night folks
21:28:09 <revenantphx> Actually, one side note.
21:28:10 <djahandarie> kmc, JAVA is a dialect of Java that exclusively uses buzzwords in its grammar
21:28:19 <revenantphx> I kind of sucks to be able to guess your mothers amazon password.
21:28:26 <revenantphx> Especially because it ruins what she got you for christmas.
21:28:30 <lispy> kmc: the problems that an ESB solve seems to be application-to-application communication across some sort of networked cyber infrastructure
21:28:54 <Axman6> classfactory Foo multiinherits Bar {...}
21:29:12 <lispy> kmc: and that (in their mind) includes transforming messages between sender/receiver so they can understand each other even if they weren't originally designed to speak the same language
21:29:18 <ddarius> The "Skills required of a Middleware Analyst" is entertaining.
21:29:29 <lispy> kmc: I totally agree that making XML a requirement is foolish.  It's too low level to capture the intent of the system.
21:29:46 <Axman6> "In JAVA, all classes and objects are factories and visitors"
21:29:58 <kmc> not just infrastructure but cyber infrastructure
21:29:59 <djahandarie> Haha
21:30:12 <lispy> kmc: and lots of other things like subscribing, queuing and lots of fun stuff like that
21:30:36 <kmc> yeah, i claim ZeroMQ and RabbitMQ probably solve these problems
21:30:44 <djahandarie> Well we should stop bitching about terminology in hindsight of all the terminology we have
21:30:47 <kmc> btw Haskell also has bindings to libxslt if you want to get crazy with transforms
21:30:59 <kmc> but we also have this great framework for writing transforms between different data types
21:31:02 <kmc> which is called "functions"
21:31:39 <lispy> kmc: right.  We could do it more simply and more natively, I'm sure.
21:31:40 <ddarius> But you can't run Haskell functions in a browser.
21:31:54 <lispy> moar*
21:32:01 <lispy> Haskell Beans
21:32:05 <Axman6> kmc: i think you mean...  ENTERPRISE FUNCTOTRANSFORMERS!
21:32:11 <lispy> Curry Pods?
21:32:13 <kmc> anyway i won't claim Haskell is the king of enterprise service architecture, but the basic pieces seem to be there.  do you have a credible scenario for a Haskell project falling through because of a lack of ESB support?
21:32:44 <lispy> No I don't, but that's not really what I'm trying to imply
21:33:07 <Philippa> more: how do I fit Haskell into the enterprise?
21:33:26 <Philippa> or even: how do I build one around it?
21:33:36 <Axman6> AT WARPSPEED!
21:33:41 <lispy> I like to point out areas where Haskell could grow to be more widely applicable.  I like to assume that the mainstream perception matters just as much as the library availability.
21:34:12 <ddarius> I don't think that that is a niche Haskell wants to fill or is particularly suited to fill.
21:34:12 <kmc> i think Haskell is helped tremendously by the perception that it's relatively free of enterprise stuff
21:34:36 <Philippa> being free of the requirement for it is good
21:34:37 <djahandarie> I'd like someone to go through every piece of stupid enterprise terminology and rewrite it to simple, concise words.
21:34:42 <Philippa> being free of the ability to interact with it? Not so much
21:34:51 <lispy> Or it could be full of lightweight apps/libraries that are beneficial to enterprises.
21:35:22 <lispy> djahandarie: It's not really the words that are broken, it's people using them sloppily, IMO
21:35:30 <kmc> Philippa, it's not just free from the requirement.  it's that you don't expect a typical haskell app to be architected the way an enterprise Java app is
21:35:31 <Philippa> the problem with Java is that you /have/ to make it "enterprise" to have that kind of configurability, and it's all done in heavyweight manner
21:35:59 <ddarius> Everything in Java is done in a heavyweight manner.  That's the Java way.
21:36:00 <kmc> i probably shouldn't talk about enterprise Java apps, since i've never worked on one
21:36:05 <kmc> i don't think i'd like to, either
21:36:11 <lispy> I liked the quote (paraphrasing) that I heard from reddit: Java is a DSL for converting XML into stack traces.
21:36:31 <kmc> haskell is a DSL for converting math into type errors
21:36:31 <Axman6> heh, a classic quote indeed
21:36:59 <ddarius> Scala is a DSL for converting programs into compiler bugs.
21:37:12 <lispy> ddarius: OMG.  Yes.  That was my experience with Scala.
21:37:27 <kmc> paging copumpkin, edwardk
21:37:37 <Philippa> kmc: enterprise java apps are architected the way they are because they're not naturally decomposable etc otherwise. Haskell has a few problems still on that front, but it's better at the native level than Java is
21:37:40 <lispy> Granted, I only learned it to satisfy the reqs of a class, so I'm a bit biased (I wanted to be using Haskell)
21:37:53 <Philippa> ("few problems" - where are my low-overhead functor-equivalents? Or my equivalents of signatures?...)
21:38:31 <ddarius> Philippa: Just write a source-to-source tool to add those.
21:38:51 <lispy> One thing Haskell could improve on in the "enterprise solutions" arena is using something more amenable to parsing and reading than XML is, but then you have to go through the process of inventing a new "thing" that people have to adopt if they're not using Haskell.
21:39:01 <ddarius> Or generate from XML files so that you need a GUI tool to use the thing at all.
21:39:26 <ddarius> lispy: What's wrong with just using XML?
21:39:47 <Axman6> lispy: anything wrong with things like yaml and such?
21:39:48 <lispy> ddarius: the fabulous support we have for it in haskell
21:39:54 <robinhoode> Hey all.. I'm a haskell newb.. A little experience but not much. I'm interested in implementing a stateful chat server (e.g. a chat server that holds some amount of history). What's the best way to approach this?
21:39:56 <Axman6> or even json?
21:40:16 <lispy> Axman6: I'm ignorant of yaml and json when it comes to actually using them so I won't comment there.
21:40:28 <Axman6> fair enough
21:40:34 <lispy> Axman6: json seems pretty reasonable as a way to serialize maps, though
21:40:42 <Axman6> yeah
21:40:47 <Philippa> ddarius: yeah, you know what I'm like at getting stuff done :-) I'd seriously look at how to make a better module system in terms of existing modules and type classes otherwise, though you'd probably need to break the 1 file : 1 module connection in GHC
21:41:25 * ddarius needs to implement local modules in GHC some time, or at least as a preprocessor.
21:41:42 <lispy> Philippa: Breaking the 1:1 connection would be pretty nice at times.  It may make it harder to find the file you want at other times.
21:42:26 <lispy> robinhoode: Well, do you know any languages besides Haskell?
21:42:35 <lispy> robinhoode: and how persistent do you want/need the history to be?
21:43:03 <lispy> robinhoode: threads in GHC are very lightweight so I could imagine having one thread per connection
21:43:34 <robinhoode> lispy, It will need to persist the chat history for a good while.. haven't thought about that angle much
21:44:12 <robinhoode> lispy, I'm pretty familiar with standard languages: C++, Java, etc.. Most of my paid work is with 'web' languages: Ruby, Javascript.. 
21:44:24 <lispy> robinhoode: there are a couple tutorials about writing an IRC client in Haskell.  You might start there?
21:44:25 <Axman6> well, i'd store the hostory as maybe a list of Text initially
21:44:40 <Axman6> history*
21:44:42 <lispy> text or sqlite db
21:44:54 <Axman6> moving to selite db eventually :P
21:44:59 <robinhoode> Would it be a bad idea to store it in memory?
21:45:00 <Axman6> q*
21:45:08 <robinhoode> I want this app to be pretty responsive
21:45:10 <Axman6> robinhoode: depends how many people will be using it
21:45:12 <lispy> robinhoode: well, it's fine if you don't need it between program runs
21:45:18 <Axman6> sqlite is damn fast
21:45:39 <adu> and everywhere
21:45:41 <lispy> and Haskell is no slouch
21:45:46 <Axman6> writing a server with the assumption "it won't crash" is a bad idea
21:45:46 <djahandarie> I think we really need a 'Haskell Database' of sorts
21:45:48 <robinhoode> Axman6, Yeah, but it's still an extra trip.. :/
21:46:02 <lispy> djahandarie: Well, I'm working towards that.
21:46:07 <robinhoode> Axman6, It's okay if it crashes.. 
21:46:09 <Axman6> robinhoode: a lot less overhead than the network connections connecting to your server ;)
21:46:10 <adu> how about MongoDB?
21:46:12 <ddarius> Axman6: Writing a server with the assumption "I don't care if it crashes" is fine.
21:46:18 <djahandarie> lispy, as long as it doesn't involve ESBs ;)
21:46:23 <Axman6> ddarius: indeed
21:46:45 <adu> EJB?
21:46:56 <ddarius> Actually the chat server would be a very primitive ESB.
21:46:56 * Axman6 is at the moment writing a server which "currently doesn't seem to crash, but when it does loses all state, and will fix that soon"
21:46:56 <lispy> djahandarie: heh.  No, my emphasis will actually be on correctness.  There are plenty of db implementations in the world.  My plans are to make one that has proofs about it's behaviors.
21:47:05 <copumpkin> kmc: wassup?
21:47:06 <djahandarie> Nice!
21:47:33 <Philippa> lispy: will that include time/space/etc behaviour?
21:48:08 <djahandarie> I've never figured out how to formally prove things about time/space/etc with a proof assistant
21:48:08 <lispy> djahandarie: I'm currently at the point making tools for that verification while trying to also write some corresponding documentation (fortunately I'm not alone in the endeavor)
21:48:23 <djahandarie> Galois work?
21:48:25 <lispy> Philippa: Well, I'll be using Isabelle to prove things.  Does that answer your question?
21:48:32 <Axman6> lispy: what are you working on?
21:48:44 <ddarius> lispy: That seems orthogonal to her question.
21:48:46 <robinhoode> So my main roadblock is figuring how how to persist the state, without using some kind of global variable..
21:49:08 <Axman6> what's wrong with a global MVar?
21:49:09 <robinhoode> *out how
21:49:10 <lispy> djahandarie: The project is new, we plan to make it open source from the beginning and we should be announcing it in the next 3 months or so.  We need to lay a certain amount of ground work before getting people's hopes up :)
21:49:21 <Axman6> well, a lot really, but it could be worse
21:49:41 <robinhoode> Axman6, Not sure, just wanted to avoid that.. Seemed like a throwback to my C days
21:49:43 <c_wraith> you don't need a global, though
21:49:58 <lispy> Philippa, ddarius: Using isabelle to prove things about space is hard.  You tend to have to prove something that implies the space behavior.  Like, "this tree structure is always balanced"
21:49:59 <Axman6> robinhoode: ah, but haskell has awesome global variables :)
21:50:22 <ddarius> lispy: No one said it was easy.
21:50:23 <djahandarie> lispy, cool. 
21:50:43 <ddarius> Axman6: What are you talking about?
21:50:53 * ddarius sees no reason why you would use a global variable for this.
21:50:55 <lispy> The last week of this year, I'm going to be working on it some and scheduling more time for it each week in 2011.
21:51:37 <ddarius> lispy: Give it one second of time on the first week of 2011, two seconds on the second, four on the third, usw.
21:51:47 <lispy> I'm currently trying to figure out how I'm going to write, "Learn you an Isabelle for Great Haskell" (something like that...)
21:51:56 <lispy> ddarius: hah!
21:52:03 <robinhoode> Axman6, See, my thinking was to somehow attach a Monad to some kind of server process.. But I'm a newb.. so I dunno.. 
21:52:13 <djahandarie> Give it BB(1) on the first, BB(2) on the second... etc...
21:52:22 <Saizan_> lispy: why Isabelle?
21:52:22 <robinhoode> ddarius, What do you recommend instead of global variables?
21:52:33 <djahandarie> Attach a monad to a server process??
21:52:33 <Axman6> robinhoode: well... the IO monad is a completely appropriate monad here :P
21:52:40 * djahandarie throws monads at robinhoode 
21:52:57 <lispy> Saizan_: a) local expertise is nice (but not a requirement), b) HOLCF lets you reason about bottom in programs
21:53:13 <ddarius> robinhoode: Pass the variable to the things that need it (or perhaps use a channel and a concurrent listening process) or perhaps use a state monad.
21:53:29 <ddarius> A state monad probably isn't suitable though.
21:54:19 <robinhoode> ddarius, Are there libraries suitable for this sort of thing? Not sure if I'm ready to go it alone just yet
21:54:39 <Axman6> robinhoode: it'll be easier than you expect, trust me :)
21:54:50 <ddarius> You don't need a library to pass a variable around (though, surprisingly, there are libraries for it.)
21:54:58 <lispy> Saizan_: Furthermore, agda is a moving target (has yet to mature/stablize).  If Coq had an equivalent of HOLCF and the decision was purely mine I would have went with it.
21:55:02 <Axman6> i've just been writing a fairly similar server, and it's maybe 300 lines of code?
21:55:25 <Axman6> haskell's fantastic concurrency primitives makes it great for this sort of thing
21:55:34 <djahandarie> @oeis 1,6,21,107
21:55:34 <lambdabot>  Sequence not found.
21:55:42 <robinhoode> ddarius, Yeah, I'm still not quite understanding how you would pass this data around. Where does it sit between requests?
21:55:49 <c_wraith> djahandarie, the oeis plugin is broken
21:55:59 <djahandarie> Ah, right
21:56:04 <c_wraith> @oeis 1,2,3,4
21:56:05 <lambdabot>  Sequence not found.
21:56:40 <Axman6> robinhoode: you have a thread that holds onto the history of all conversations, and a thread for each client. when a client sends a message to the server, it tells the central thread, which then tells all the other clients
21:56:47 <ddarius> robinhoode: I'm still recommending you use mutable state (or, in this case equivalently, a concurrent process), I'm just saying you can pass that variable/channel to the processes that need it rather than making a global one.
21:57:44 <ivanm> preflex: seen copumpkin 
21:57:45 <preflex>  copumpkin was last seen on #haskell 10 minutes and 40 seconds ago, saying: kmc: wassup?
21:57:45 <ivanm> is preflex alive?
21:57:49 <ivanm> ahhh
21:57:51 <Saizan_> lispy: makes sense, though i'm a bit surprised Coq doesn't have something like HOLCF, it has even Ynot for imperative programs (though i don't know how useful it is)
21:57:56 <djahandarie> ivanm, you're lagging ;)
21:58:14 <lispy> Saizan_: Well, I'm not a Coq expert, so perhaps it does have something similar.
21:58:23 <djahandarie> Do we have a local Coq expert?
21:58:39 <lispy> Saizan_: I'm pretty sure the code extraction it provides to Haskell assumes strictness
21:58:59 <lispy> Saizan_: which makes me think it also doesn't have a way to reason about bottoms (I could be wrong)
21:59:06 <ivanm> djahandarie: ... maybe...
21:59:23 <ddarius> Coq is pretty damn mature.  I'm sure there is a library for that.
22:01:51 <lispy> ddarius: HOLCF provides domain theory which is the key really.  Coq probably has domain theory too.
22:03:21 <lispy> http://research.microsoft.com/en-us/um/people/akenn/coq/Domains.pdf  <-- that might explain how to do it in Coq
22:10:29 <ivanm> does anyone know of any algorithms for finding all unique permutations of a list that may contain duplicates?
22:10:38 <ivanm> the combinat package has one, but it needs Ord, which I can't use :/
22:11:48 <ivanm> (so currently I'm stuck with either doing the permutations at an earlier step - which will probably be inefficient as the values I actualy want in them are expensive to compute) or do nub . doAllPermutations :s
22:11:58 <mtnviewmark> ivann: I can roughly come up with one
22:12:11 <Axman6> permutations . nub >_>
22:12:23 <mtnviewmark> first  compute   [a] -> [(a, Int)]   where each a appears only once and Int is the count
22:12:43 <mtnviewmark> well, nub'ing the permutations is going to be expensive, yes?
22:12:45 <dskippy> I'm having a hard time creating a function to do cyclic add or subtract on and bounded enum data type. The problem is this: cycleAdd x n = toEnum $ (fromEnum x + n) `mod` (maxBound+1)
22:12:53 <dskippy> maxBound has not type.
22:12:59 <ivanm> mtnviewmark: yeah
22:13:11 <ivanm> Axman6: ummm, that won't help much... :p
22:13:12 <dskippy> This should have the type: cycleAdd :: (Eq a, Bounded a, Enum a) => a -> Int -> a
22:13:24 <Axman6> ivanm: why not? it will remove all duplicates...
22:13:34 <ivanm> Axman6: I want to remove duplicate _permutations_
22:13:40 <ivanm> I need the duplicates in the initial list
22:13:47 <Axman6> :\
22:13:57 <ivanm> e.g. I want to get all permutations of a list like [Just tree 1, Just tree2, Nothing, Nothing, Nothing]
22:13:59 <Axman6> stop being so picky!
22:14:00 <Axman6> :P
22:14:07 <tehgeekmeister> i'd really appreciate it if a few people could take a look at these two (very simple) files and let me know what sorts of abstractions and patterns would be best suited to making this code more elegant.  it's bothering me to no end working with monster functions like these, but i don't know how else to do it... https://github.com/tehgeekmeister/connect/blob/master/src/User.hs 
22:14:08 <tehgeekmeister> https://github.com/tehgeekmeister/connect/blob/master/src/Main.hs
22:14:09 <ivanm> heh
22:14:19 <mtnviewmark> anyhoot, then perms can be generated from that along the lines of    [(a, an), rs] ->  a : perms ((a, an-1):rs)  :  
22:14:22 <mtnviewmark> or some such
22:15:15 <ivanm> mtnviewmark: hmmm.... interesting
22:15:29 <ivanm> lemme think about that
22:15:48 <Axman6> tehgeekmeister: using functions like either and maybe can help a lot
22:16:12 <tehgeekmeister> Axman6: oh, i knew about maybe and forgot about it.  either is the analog of it, i assume?
22:16:18 <Axman6> :t either
22:16:19 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
22:16:48 <tehgeekmeister> Axman6: and perhaps defining smaller functions to handle the behavior for each case of an either/maybe instead of having the code literally inlined?
22:16:55 <ivanm> I often wish there was a function: mapEither l r = either (Left . l) (Right . r)
22:17:15 <Saizan_> ivanm: (|||) from Control.Arrow
22:17:24 <Axman6> :t (|||)
22:17:25 <ivanm> Saizan_: oooohhh...
22:17:25 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
22:17:32 <Axman6> :o
22:17:35 <Axman6> i like that
22:17:40 <Saizan_> :t (+++)
22:17:41 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
22:17:45 <ivanm> @type succ ||| fromJust
22:17:45 <lambdabot> forall a. (Enum a) => Either a (Maybe a) -> a
22:17:48 <Saizan_> ivanm: (+++) actually
22:17:55 <ivanm> @type succ +++ fromJust
22:17:55 <lambdabot> forall b a. (Enum b) => Either b (Maybe a) -> Either b a
22:18:06 <ivanm> that _is_ cool
22:18:29 <Axman6> :O
22:18:47 * Axman6 needz moar arrows obviously!
22:18:55 <Saizan_> (|||) is just another name for either :)
22:19:15 <Axman6> tehgeekmeister: i like the unPust function, reminds me of my cat back home :P
22:19:22 <Axman6> when he jumps off you
22:19:30 <tehgeekmeister> Axman6: lololol i forgot that was in there.  =P
22:19:43 <Axman6> :P
22:19:50 <tehgeekmeister> i wish there was an easier way to handle all those parameters at once
22:25:01 <tehgeekmeister> also need to learn how to use the reader monad under another monad.  i know about monad transformers but gotta get comfortable with them; passing around database connections manually is lame.
22:25:40 <Axman6> tehgeekmeister: it's pretty easy, basically you just got to use ask and asks insize what looks like some other monad. works very well
22:26:20 <tehgeekmeister> i should try this soon
22:26:55 <Axman6> i'm using something like type SimRunner a = ReaderT SimConf IO a at the moment
22:27:03 <tehgeekmeister> cos then i could never have to specifically reference the database inside my frontend specific code
22:27:22 <Axman6> SimConf is a record, so i can use x <- asks recordelement
22:28:00 <dskippy> I am having trouble with enum, bounded and the type checker. I want to add some number of elements to an enum and get the resulting enum. But I want to modulo by the size of the enums so that it is cyclic. Problem is the type checker can't figure out the type of maxBound when it's in the modulo.
22:28:27 <ivanm> dskippy: example?
22:28:38 <ivanm> i.e. can you paste some code up?
22:28:55 <dskippy> ivanm: cycleAdd x n = toEnum $ (fromEnum x + n) `mod` (maxBound+1)
22:28:57 <ivanm> I would randomly guess that it's an MMR issue; explicit type sigs may help
22:29:12 <ivanm> dskippy: that's going to be maxBound of Int
22:29:15 <ivanm> @tyep mod
22:29:15 <lambdabot> forall a. (Integral a) => a -> a -> a
22:29:19 <dskippy> That's close. That should add n to my x. But the modulo I don't want to be maxBound of Int.
22:29:22 <ivanm> @type fromEnum
22:29:23 <lambdabot> forall a. (Enum a) => a -> Int
22:29:25 <dskippy> ivanm: Right, exactly.
22:29:33 <Saizan_> dskippy: cycleAdd x n = toEnum $ (fromEnum x + n) `mod` (fromEnum (maxBound `asTypeOf` x) + 1)
22:29:43 <dskippy> asTypeof!
22:29:45 <ivanm> dskippy: (fromEnum (asType x maxBound))
22:29:51 <dskippy> Sweet.
22:29:53 <Axman6> Saizan_: damn, beat me to it
22:29:54 <ivanm> or asTypeOf, whatever
22:30:07 <ivanm> I can never remember which way that one goes though...
22:30:17 <ivanm> > maxBound `asTypeOf` (1 :: Int)
22:30:18 <lambdabot>   9223372036854775807
22:30:24 <tehgeekmeister> Axman6: that's a restriction i currently dislike with haskell; a function you call can not bind something to the scope you're currently in; you have to do the binding yourself.  which means if you want to get five or six different parameters, you have to each one of them explicitly, one way or another.
22:30:26 <tehgeekmeister> is annoying.
22:30:28 <Axman6> x `asTypeOf` y, returns x as the type of y :P
22:30:29 <ivanm> OK, so my code is really wrong.... ;-)
22:30:49 <ivanm> Axman6: I'm used to doing it prefix; never realised how much sense the infix version was :p
22:30:58 <tehgeekmeister> !!!
22:31:10 <ivanm> tehgeekmeister: someone recently did a TH wrapper to solve that problem...
22:31:17 <ivanm> had some weird name starting with s I think
22:31:19 <tehgeekmeister> ivanm: oh?
22:31:39 <tehgeekmeister> ivanm: that's googlable...  was it on planethaskell or what?
22:31:47 <dibblego> @type \f -> second f . join (,)
22:31:48 <lambdabot> forall b c. (b -> c) -> b -> (b, c)
22:32:04 <ivanm> tehgeekmeister: think so, yes
22:32:09 <dibblego> @type \f -> first id . second f
22:32:10 <lambdabot> forall b d (a :: * -> * -> *) b1. (Arrow a, Functor (a (b, b1))) => a b1 d -> a (b, b1) (b, d)
22:32:50 <Saizan_> it's more a solution for the global IORef problem, but could work here too
22:32:52 <tehgeekmeister> instead i could have mini functions inside the snap monad that check for all the parameters i need/does validations needed/etc, and returns an either of a map of the values (where i know they all exist) or a map of the values to error messages.
22:34:09 <tehgeekmeister> ivanm: thanks
22:34:13 <ivanm> np
22:35:17 <Saizan_> http://hackage.haskell.org/package/seal-module
22:35:54 <ivanm> that's the one
22:36:19 <tehgeekmeister> oh slick
22:36:20 <tehgeekmeister> thanks
22:36:28 <tehgeekmeister> been meaning to learn some template haskell
22:36:28 <tehgeekmeister> r
22:36:33 <tehgeekmeister> ead a bit of the original paper
22:36:41 <tehgeekmeister> looks a lot simpler than i ever thought it could be
22:38:15 <copumpkin> ivanm?
22:38:27 <ivanm> copumpkin: you're working on new Qt bindings, arent' you?
22:38:51 <copumpkin> hell no
22:38:53 <copumpkin> I hate GUIs
22:39:25 <ivanm> gah, sorry, you were doing Obj-C, weren't you
22:39:39 <ivanm> somehow got it mixed up with Qt for some reason...
22:39:48 <ivanm> nvm then ;-)
22:39:58 <copumpkin> yeah, sort of :)
22:40:04 <ivanm> (I wanted to ask you about binding to C++ since I thought you were doing that, but you're obviously not)
22:40:11 <copumpkin> more about thinking how to static-ify a highly dynamic language
22:40:16 <copumpkin> than figuring out GUI aspects of it
22:40:55 <jkff> Hi. http://hpaste.org/42483/ghc_cpp_failure - why is ghc failing to properly preprocess the file here?
22:41:44 <ivanm> jkff: dare I ask what you're trying to do there?
22:42:17 <jkff> I'm generating a number of instances "instance Storable XXXX where ..." with endianness
22:42:26 <ivanm> jkff: use TH, not CPP for that
22:42:28 <tehgeekmeister> i just ran into exactly this error, and noticed it'd already been hpasted, anyone know more about it? http://hpaste.org/42356/bytestring0918_build_error
22:42:38 <ivanm> use CPP only for compilation-time configuration stuff if you must
22:42:53 <jkff> ivanm: Okay, but still is there a particular reason why CPP fails in this case?
22:42:59 <ivanm> tehgeekmeister: you really shouldn't be upgrading boot libraries like bytestring anyway...
22:43:06 <ivanm> jkff: *shrug* no idea; never used CPP :p
22:43:13 <tehgeekmeister> ivanm: crap.  that's what happened.  i knew htat.
22:43:24 <tehgeekmeister> ivanm: i think i need a new version of the platform.
22:43:30 <copumpkin> jkff: in unrelated talk, why not use newtypes around built-in types rather than constructing names like that?
22:43:51 <jkff> copumpkin: that's what I'm doing - it's just omitted from this part of source
22:44:02 <copumpkin> oh ok
22:44:41 <tehgeekmeister> ...  galois.com is down now too?
22:45:14 <copumpkin> man, maybe haskell is infectious for bad hosting
22:45:41 <tehgeekmeister> and here i'm using it as opposed to RoR for all my personal projects...
22:45:51 <ivanm> mtnviewmark: I'm looking at the source for Data.List.permutations to try and work out how to incorporate your suggestion, but there's nothing obvious that I can see that would ensure no duplicates :s
22:45:53 <tehgeekmeister> =P
22:46:47 <tehgeekmeister> i <3 bittorrent.
22:48:03 <mtnviewmark> ivann: I'm thinking something like --- 
22:49:01 <mtnviewmark> the perms are, the concatenation of, for each item in taht list, take one and prepend to the perms of the rest
22:49:06 <mtnviewmark> let me see if I can code it
22:49:18 <ivanm> ta
23:03:42 * ivanm heads off for a bit; back in about an hour
23:10:59 <mtnviewmark> got it
23:11:13 <mtnviewmark> d'oh - just missed him
23:27:37 <mtnviewmark> ivann: solution here: https://bitbucket.org/mtnviewmark/haskell-playground/src/66b3316ce13c/irc/UniquePerms.hs
23:27:55 <mtnviewmark> hmmm... isn't there a way to leave a message for someone?
23:28:25 <mtnviewmark> @msg ivann solution here: https://bitbucket.org/mtnviewmark/haskell-playground/src/66b3316ce13c/irc/UniquePerms.hs
23:28:25 <lambdabot> Not enough privileges
23:29:59 <mtnviewmark> @tell ivann solution here: https://bitbucket.org/mtnviewmark/haskell-playground/src/66b3316ce13c/irc/UniquePerms.hs
23:29:59 <lambdabot> Consider it noted.
23:31:43 <McManiaC> is there something like map which generalizes on any (list like) monad?
23:31:51 <McManiaC> mapM_ won't do it :)
23:32:06 <mtnviewmark> mapM
23:32:12 <mtnviewmark> :t mapM
23:32:12 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
23:32:20 <McManiaC> mtnviewmark: that still takes a list as argument
23:32:38 <mtnviewmark> :t fmap
23:32:39 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:32:40 <c_wraith> @hoogle sequenceA
23:32:40 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
23:32:40 <lambdabot> Data.Foldable sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
23:32:43 <McManiaC> I'm looking for something like (a -> m b) -> l a -> m (l b)
23:33:19 <c_wraith> @hoogle mapM
23:33:19 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
23:33:19 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
23:33:19 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
23:33:37 <McManiaC> > fmap (+2) [1..5]
23:33:38 <lambdabot>   [3,4,5,6,7]
23:33:52 <McManiaC> cool
23:34:07 <c_wraith> McManiaC, Data.Traversable's mapM appears to be what you want
23:34:51 <McManiaC> I'll note it down, thank c_wraith 
23:35:04 <c_wraith> @instances Traversable
23:35:04 <lambdabot> Couldn't find class `Traversable'. Try @instances-importing
23:35:16 <c_wraith> @instances-importing Data.Traversable Traversable
23:35:16 <lambdabot> Maybe, []
23:35:27 <c_wraith> Not much help, by itself :)
23:35:52 <McManiaC> basicly I'm looking for a replacement for "map" for monad comprehensions
23:36:19 <McManiaC> using Traversable however would increase the list of "monadic dependencies" for my comprehension... :)
23:37:06 <McManiaC> but then again it'll be only for group statements which makes kind of sense...
23:37:57 <Watermind> isn't there a, reverse ($), pre defined
23:38:03 <Watermind> ops
23:38:07 <Watermind> flip ($)
23:38:39 <McManiaC> why would you need that?
23:39:08 <Watermind> McManiaC: would just look prettier on some slides, because it's very close to >>=
23:39:31 <dibblego> just use >>= in Identity :)
23:39:51 <Watermind> dibblego: yes I know but the purpose is to explain (>>=) :P
23:40:02 <McManiaC> ^^
23:42:16 <Saizan_> explain (=<<), so it fits with ($) :)
23:45:57 <c_wraith> huh.  Is there any real difference between fmap unsafeCoerce and unsafeCoerce?
23:47:17 <Veinor> intuitively, it'd make sense for there not to be
23:48:03 <Veinor> Prelude Unsafe.Coerce> (unsafeCoerce id) :: String
23:48:04 <Veinor> ""
23:48:07 <Veinor> aw, I was hoping for something interesting
23:48:20 <c_wraith> do unsafeCoerce () ()
23:48:30 <c_wraith> that usually segfaults :)
23:48:49 <Veinor> well, by 'interesting', I meant 'memory dump'
23:49:04 <c_wraith> ah
23:49:14 <c_wraith> well...  try it as a bytestring!
23:49:16 <Saizan_> you're assuming the particular fmap respects the functor laws "intensionally", i can imagine situations where they are respected up to some more lax equivalence 
23:49:36 <Veinor> segfault!
23:49:59 <Veinor> istr some code that did actually unsafeCoerce a String into a function
23:50:27 <ivanm> @tell mtnviewmark thanks!
23:50:27 <lambdabot> Consider it noted.
23:50:35 <Veinor> anyway
23:50:36 <Veinor> sleep
23:50:45 <c_wraith> well, I'm just working with IO anyway.
23:57:57 <McManiaC> can anyone give me a quick introduction to type applications?
23:58:15 <McManiaC> in what order do I have to pass "m" and "a" to a function like return
23:58:19 <McManiaC> ?
23:58:59 <c_wraith> I must admit some....  confusion
23:59:33 <McManiaC> :D
23:59:38 <McManiaC> I'm hacking on GHC
