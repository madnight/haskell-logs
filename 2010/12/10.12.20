00:00:05 <blenderer> could someone provide me with an example?
00:00:39 <Axman6> blenderer: an example of what?
00:00:50 <Axman6> there's lots of things in that sentense therw could be examples of
00:01:22 <blenderer> Of something an ide might exploit
00:01:26 <blenderer> that is unique to haskell
00:01:39 <bartavelle> a module : http://hpaste.org/42442/the_gamesolver_module, and sample code : http://hpaste.org/42443/a_sample_using_gamesolver
00:01:52 <bartavelle> if somebody has a clue why the memoization doesn't seem to work, i'm all hears
00:03:40 <nCdy> hamishmack: how to open my project in Leskah ? )
00:04:36 <nCdy> hackagebot: I see ) it's open workspace
00:05:06 <hamishmack> hamishmack: Once you have a workspace
00:05:27 <hamishmack> Right click in the workspace and choose add package
00:05:47 <hamishmack> nCdy: Then select the .cabal file
00:06:15 <nCdy> hamishmack: it was opened in session
00:07:43 <hamishmack> blenderer: One advantage haskell has in IDE is that we can safely evaluate pure code and display the results
00:10:44 <Chaze> @pl any id
00:10:45 <lambdabot> or
00:15:57 <Chaze> @pl not . or
00:15:58 <lambdabot> not . or
00:42:50 <minsa> what's wrong with the following : [x | x <- [50..100], x 'mod' 7 ==3]  
00:43:25 <adu> mod
00:43:25 <minsa> I mean,  what's wrong with the following : [x | x <- [50..100], x 'mod' 7 == 3]  
00:43:30 <adu> mod
00:43:36 <minsa> I should use % instead ? 
00:43:41 <adu> no use `mod`
00:43:46 <minsa> oh, ic.
00:44:08 <adu> its all in the wrist :)
00:44:18 <minsa> the text is not really clear on that important point.
00:44:23 <minsa> I should blame the font. :)
00:44:26 <adu> yes
00:44:49 <adu> ' is for character literals
00:44:57 <adu> ` is for function infixing
00:45:12 <minsa> all the word infix functions are with `  ?
00:45:22 <adu> yes
00:45:36 <adu> although, using for functions of arity /= 2 is confusing, at best
00:46:00 <adu> :t const
00:46:01 <lambdabot> forall a b. a -> b -> a
00:46:20 <Boxo> > odd `id` 3
00:46:21 <lambdabot>   True
00:46:22 <adu> :t (1 `const`)
00:46:23 <lambdabot> forall t b. (Num t) => b -> t
00:47:36 <adu> minsa: what's actually happening is (mod x 7)
00:47:45 * minsa digesting
00:49:01 <Boxo> x `f` y = f x y
00:49:36 <minsa> adu and Boxo: thnx.
00:49:37 <Axman6> > x `f` y z
00:49:37 <lambdabot>   Ambiguous occurrence `x'
00:49:38 <lambdabot>  It could refer to either `L.x', defined at <local...
00:49:42 <Axman6> > x `f` y z :: Expr
00:49:43 <lambdabot>   Ambiguous occurrence `x'
00:49:43 <lambdabot>  It could refer to either `L.x', defined at <local...
00:49:48 <Axman6> > a `f` y z :: Expr
00:49:48 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr -> t'
00:49:48 <lambdabot>         against infe...
00:49:56 <Axman6> -_-
00:52:19 <minsa> adu: I don't understand ":t (1 `const`)"   yet, but I just started reading haskell 15 minutes, so I guess I will catch up later.
00:52:50 <Boxo> (x `f`) = f x
00:52:54 <adu> minsa: it is identical to (const 1)
00:53:04 <Boxo> (`f` y) = \x -> f x y
00:53:32 <lars9> what's the haskelly way to shuffle a list?
00:53:39 <Boxo> = flip f x
00:53:48 <Boxo> *** = flip f y
00:56:40 <adu> minsa: oh, and :t is how you ask the bot "what type is this?"
00:56:55 <Baughn> lars9: Grab one of the shuffling libraries off hackage, use that
00:57:23 <Baughn> lars9: Shuffling is hard enough if you /aren't/ trying to do it on an unchanging list
00:58:53 <lars9> Baughn: they use a different data structure?
00:59:35 <Baughn> lars9: No, pretty sure the one I saw just used a list.
00:59:52 <Baughn> lars9: The point is that shuffling is amazingly subtle. You don't want to try to do it yourself.
01:00:40 <lars9> Baughn: i see, thanks
01:01:45 <lars9> how about fisher yates shuffle using STArray?
01:08:42 <minsa> adu: could you please explain  the result of :t const ? 
01:08:54 <minsa> :t const
01:08:55 <lambdabot> forall a b. a -> b -> a
01:09:04 <minsa> are a and b types or variables ?
01:09:34 <companion_cube> type variables
01:09:50 <minsa> wow...
01:09:51 * hackagebot generic-deriving 0.4 - Generic programming library for generalized deriving.  http://hackage.haskell.org/package/generic-deriving-0.4 (JosePedroMagalhaes)
01:10:04 <minsa> so const is like a generic template function.
01:10:04 <companion_cube> for any types a and b, const takes an a and a b and returns the a
01:11:44 <lars9> const x _ = x
01:12:00 <minsa> ic..
01:12:04 <lars9> const x = \_ -> x
01:12:21 <minsa> \_ is ?
01:12:34 <lars9> any value
01:12:55 <minsa> x refers to type instead of value, right ? 
01:13:26 <minsa> :t head
01:13:27 <lambdabot> forall a. [a] -> a
01:13:29 <lars9> minsa: no... read some tutorials first.
01:13:49 <minsa> ok, I am reading but my interest got the better of me in previous answers.
01:14:11 <minsa> :t if
01:14:11 <lambdabot> parse error (possibly incorrect indentation)
01:14:20 <lars9> learn syntax first
01:14:49 <minsa> ":t const" gonna be gnawing at me though.
01:15:27 <adu> minsa: oops, just read
01:15:52 <adu> > 1
01:15:53 <lambdabot>   1
01:15:59 <Boxo> minsa, do :t for all the functions you know, spot the pattern...
01:16:00 <adu> > const 1 "hello"
01:16:01 <lambdabot>   1
01:16:07 <adu> const 1 542346
01:16:12 <adu> > const 1 542346
01:16:13 <lambdabot>   1
01:17:06 <adu> :t const :: Int -> String -> Int
01:17:07 <lambdabot> Int -> String -> Int
01:17:51 <minsa> adu: thnx a lot but there is something deeper there. Those types.
01:18:11 <adu> minsa: so what's so confusing?
01:18:36 <adu> minsa: what kind of background are you coming from? and how long have you been learning Haskell?
01:19:44 <minsa> adu: c, c++, I started scheme two weeks ago, still reading second chapters of a book. can't sleep, pick up a haskell tutotial that I printed out and started reading. 
01:19:49 <minsa> so this is my first night.
01:20:19 <adu> wow, you have a lot to learn then...
01:20:24 <adu> I'd start with currying
01:20:36 <minsa> yeah.. but I won't sleep before I got ":t const"
01:21:26 <adu> that's type inference in action
01:21:42 <adu> ":t" asks the bot to infer the type from some expression
01:21:57 <minsa> it looks like const will always honor the type of the first argument passed to it.
01:22:04 <minsa> that's all I got so far.
01:22:10 <adu> not honor, infer
01:22:28 <adu> o const
01:22:32 <adu> right
01:22:52 <adu> const just means turn the first argument into a function
01:23:03 <minsa> after inferring the first argument that is. const doesn't care about the rest in the argument list.
01:23:10 <adu> so (const 1) turns 1 from a number into a function which returns 1
01:23:16 <Boxo> :t (\a b c -> b)
01:23:16 <lambdabot> forall t t1 t2. t -> t1 -> t2 -> t1
01:23:17 <shachaf> adu: That seems like a confusing way of putting it.
01:23:18 <minsa> oh ic.
01:23:30 <shachaf> Ah, never mind.
01:24:49 <Boxo> :t id
01:24:50 <lambdabot> forall a. a -> a
01:24:51 <adu> minsa: const doesn't do any infering, it's Haskell that does the inferring
01:25:16 <minsa> notationally, t -> t1 -> t2 ? what doesn -> do ? 
01:25:27 <minsa> *does*
01:25:49 <Boxo> (a -> b) means a function from things of type a to things of type b
01:25:54 <adu> minsa: from a C background, that would be the type of a function like t2(*)(t name0,  t1 name1);
01:26:02 <Boxo> :t (&&)
01:26:03 <lambdabot> Bool -> Bool -> Bool
01:26:12 <Boxo> :t odd
01:26:13 <lambdabot> forall a. (Integral a) => a -> Bool
01:26:38 <adu> minsa: (->) constructs function types
01:27:05 <Boxo> -> is right-associative. Therefore (a -> b -> c -> d) really means (a -> (b -> (c -> d)))
01:27:26 <minsa> oh, that's why adu mentioned currying.
01:27:37 <adu> minsa: ya, i would learn currying first
01:28:02 <Boxo> What's there to learn besides the above :p
01:28:24 <minsa> paying my due. :)
01:28:31 <adu> minsa: but if you really want to avoid learning currying, then you can think of the above type as a C function d myFunc(a, b, c)
01:29:01 <minsa> but I will miss the subtlty and inside jokes, won't I ?
01:29:05 <adu> yes
01:29:37 <minsa> *subtlety*, I mean.
01:31:47 <adu> minsa: one way you can think about it is that there aren't any functions that take 2 arguments, they all take 1 argument... lots of times
01:32:31 <minsa> so currying is really at the center of haskell ? 
01:32:42 <adu> no, many things are the center of Haskell
01:32:44 <adu> for example:
01:33:01 <adu> Monads
01:33:03 <Philippa> functions are at the center of haskell, currying is an aspect of how that's the case
01:33:19 <Philippa> monads are a bit more peripheral, IO could've been done other ways (and initially was)
01:33:25 <adu> purity is also central
01:33:45 <Boxo> and laziness
01:33:56 <adu> i don't think laziness is central
01:34:12 <adu> unless you're dealing with infinite lists you may never notice laziness
01:34:51 <Jafet> Haskell, now in a prime central location!
01:35:44 <adu> I think closures are central, but that's part of functions
01:35:46 <shachaf> "Curry" is usually seen just to the right of "Haskell".
01:35:54 <Jafet> We guarantee a great view over the Blub landscape, and our property values will never hit bottom
01:36:05 <adu> shachaf: lol
01:36:32 <shepheb> preflex: seen snoyberg
01:36:32 <preflex>  snoyberg was last seen on #haskell 25 days, 20 hours, 57 minutes and 14 seconds ago, saying: a preliminary search implies this has to do with gcc, any thoughts on how to fix this?
01:36:44 <Zao> That's something that bothers me about SML. Everything seems quite confused whether functions take tuples or are partially applicable.
01:37:27 <cts> What happened to the tutorial "All About Monads"?  The link http://www.haskell.org/all_about_monads/html/index.html is dead.
01:37:47 <quicksilver> adu: laziness may not feel central to your use of haskell, but it's absolutely central to haskell's conceptin.
01:37:55 <adu> cts: i dunno, maybe you should write yet another monad tutorial
01:38:01 <quicksilver> adu: the goal of the haskell project was to implement a lazy functional language ;)
01:38:13 <adu> ok
01:38:14 <quicksilver> s/implement/design+define/
01:38:55 <Philippa> adu: closures are an implementation artefact, not part of the language
01:38:55 <waern> hi
01:38:55 <lambdabot> waern: You have 1 new message. '/msg lambdabot @messages' to read it.
01:38:58 <Jafet> Well, they'd done most of the designing by then, just in a dozen other languages
01:39:11 <imcmeans> I'm trying to define a little helper function to calculate an integer hypotenuse length, like this:
01:39:15 <imcmeans> hyp a b = floor $ sqrt $ a*a+b*b
01:39:27 <imcmeans> but when I use it, it's complaining about the types not working out:
01:39:33 <waern> I'm looking for a heredoc package with haskell code splicing support. Is there something like that on hackage?
01:39:42 <imcmeans> No instance for (Floating Int)       arising from a use of `sqrt' at euler.hs:100:18-21
01:39:47 <quicksilver> imcmeans: sqrt only works on fractional types; floor always produces an integer
01:39:55 <ezyang> incmeans: You'll need to cast the Int into a fractional type 
01:40:01 <quicksilver> imcmeans: which type did you hope to give 'hyp' ?
01:40:13 <adu> imcmeans: are a, b :: Int?
01:40:14 <imcmeans> I want a function that has integer inputs and outputs
01:40:15 <quicksilver> it can work fine as either fractional or integer
01:40:37 <imcmeans> a and b are defined inside a list comprehension, like this: a<-[1..1000], b<-[a..1000],
01:40:39 <Jafet> Hm, what if the hypotenuse isn't integer
01:40:40 <adu> :t fromIntegral
01:40:41 <quicksilver> floor $ sqrt $ fromIntegral (a*a) + fromIntegral (b*b)
01:40:41 <lambdabot> forall a b. (Integral a, Num b) => a -> b
01:41:20 <Jafet> Programming by guessing detected, all personnel to stations.
01:41:57 <adu> Jafet: there's a floor
01:42:02 <Boxo> I always program by guessing if I have to deal with numbers in haskell. It sucks.
01:42:27 <Jafet> adu: then it ain't no hypotenuse -- at least in greek
01:42:37 <imcmeans> yeah, I'm kind of confused why this the floor isn't sufficient to coerce things into ints, since I'd expect a and b to be ints. 
01:42:46 <quicksilver> imcmeans: it is. that's not your problem.
01:42:46 <adu> perhaps hypApprox
01:42:49 <imcmeans> Jafet: I only care about the exact integer case.
01:42:52 <quicksilver> imcmeans: your program is you can't run sqrt on ints
01:43:00 <quicksilver> imcmeans: which my solution fixes.
01:43:02 <imcmeans> oh! ok!
01:43:17 <imcmeans> I was assuming it was a problem with output.
01:43:19 <adu> imcmeans: you need to convert the Integers to Floats
01:44:31 <imcmeans> Thanks guys :) As a newb, the haskell error messages can be hard to work with.
01:44:50 <imcmeans> In this case though, it was explaining exactly what was wrong...
01:45:35 <Baughn> imcmeans: They require some getting used to, but they /are/ eventually readable. Ganbatte!
01:45:46 <Baughn> imcmeans: Not like C++ STL errors. :P
01:46:07 <Jafet> For sufficiently large eventuallies...
01:46:39 <Baughn> Eh, only took me a few months
01:46:57 * Baughn is now known as "haskeller of the typing pool"
01:50:32 <minsa> boomBangs xs = [ if x < 10 then "Boom!" else "Bang!" | x <- xs, odd x] 
01:50:35 <adu> Baughn: OMG you just used my favorite Japanese word
01:50:50 <Baughn> adu: I tried translating it. I couldn't figure out a decent english replacement.
01:50:53 <minsa> in the filter, do we evaluate odd first or x <- xs first ? 
01:51:06 * Baughn thinks in some absurd combination of japanese, english, german and norwegian, these days
01:51:12 <adu> Baughn: it literally means "fight" and idiomatically means "good luck"
01:51:53 <Baughn> adu: I know precisely what it /means/. But "Good luck" isn't quite right. I like 'ganbatte' because it implies that if there is a good result, it's what you create for yourself.
01:52:12 <Boxo> Godspeed!
01:52:14 <adu> yes :) that's why it's my favorite Japanese word
01:52:35 <adu> although i generally spell it Gambatte
01:53:04 * Baughn shrugs. Both spellings are the wrong alphabet.
01:53:40 <adu> がんばって
01:53:56 <Baughn> I mean.. there isn't a single canonical romanization of japanese
01:54:23 <medfly> maybe you should take your weeaboo crap to #haskell-blah
01:56:05 <Baughn> medfly: Be nice. Though you do have a point, it stretched on longer than expected.
01:59:24 <Scriptor> hi everyone
02:00:32 <lars9> Scriptor: hi
02:18:28 <kamatsu> adu: "fight" isn't really accurate either
02:18:48 <kamatsu> i'm an idiot, he's offline
02:20:09 <ezyang> Try @tell 
02:21:55 <Baughn> kamatsu: If you can come up with a short, accurate english phrase for that, you'll be my hero forever. :P
02:32:29 <kamatsu> Baughn: it literally means "spread the pain around"
02:32:38 <kamatsu> according to the kanji anyway
02:32:45 <kamatsu> i don't think Japanese people use it in that context
02:35:17 <Baughn> kamatsu: Yes.. no, I have to agree on that.
02:37:52 <cde> kikoo
02:47:09 <ziman> hm, I'm experiencing a weird (non-)typing issue
02:47:17 <ziman> ghci> :t ys      --  ys :: (Int -> Int) -> List Int
02:47:17 <ziman> ghci> :t ys (+1) -- <interactive>:1:4:Couldn't match expected type `Int' against inferred type `a -> c' In the first argument of `ys', namely `(+ 1)'
02:47:40 <ziman> is that even possible?
02:47:59 <Botje> :t (+1)
02:48:00 <lambdabot> forall a. (Num a) => a -> a
02:48:15 <ziman> ys ((+1) :: Int -> Int) gives the same error
02:48:23 <Botje> why does it infer a->c there :/
02:48:40 <monadic_kid> literals are polymorphic values
02:49:01 <ziman> the whole code is rather... convoluted but I might make a hpaste
02:49:14 <monadic_kid> :t 1
02:49:15 <lambdabot> forall t. (Num t) => t
02:49:16 <ziman> monadic_kid, even when I restrict (+1) to Int -> Int
02:49:42 <ziman> ...I get exactly the same error
02:51:48 <monadic_kid> ziman: that doesn't sound right, what is the actual definition of ys
02:53:39 <ziman> monadic_kid, let ys = flip map_list xs :: (Int -> Int) -> List Int, where map_list is a general anamorphism (in the category-extras style)
02:54:29 <ziman> map_list :: (a -> b) -> List a -> List b
02:54:53 <ziman> I'll make a hpaste
03:00:21 * hackagebot kqueue 0.1 - A binding to the kqueue event library.  http://hackage.haskell.org/package/kqueue-0.1 (ErikHesselink)
03:03:47 <ziman> I'm stupid. I had redefined (+) and forgot about that.
03:04:58 <monadic_kid> heh
03:05:53 <quicksilver> ziman++ ;)
03:06:31 <monadic_kid> ziman: so you're + was a -> b ?
03:06:59 <monadic_kid> ziman: i mean a -> b -> c, or a -> a -> a or something
03:10:03 <imcmeans> Can you have newlines in a string constant?
03:10:11 <imcmeans> Is there a multiline string like python's """?
03:11:29 <monadic_kid> imcmeans: yes i think you have to escape them with \
03:11:36 <hvr> is there some archive of the old wiki, where I can find wiki-attachments which now are broken links?
03:11:37 <ziman> monadic_kid, i had (+) :: (a -> c) -> (b -> d) -> (a :+: b) -> (c :+: d)
03:11:51 <monadic_kid> ziman: event better lol
03:12:35 <monadic_kid> imcmeans: http://www.haskell.org/pipermail/haskell-cafe/2006-January/013911.html
03:12:49 <ziman> monadic_kid, yes, it crashed only at the end when checking the Num constraint :)
03:13:23 <imcmeans> monadic_kid: coolbeans, thanks.
03:19:16 <quicksilver> imcmeans: monadic_kid was wrong; the \ is for when you *don't* want the newlines to appear in the string
03:19:32 <quicksilver> if you do want newlines in the string you can simply type them, although it looks ugly to me.
03:20:38 <imcmeans> It was for copy-pasting a chunk of text into an .hs file to test with.
03:21:20 <imcmeans> But since I'm on windows, this text editor's inserting \r characters which makes haskell's parser barf. so I'll not bother for now.
03:23:11 <quicksilver> imcmeans: haskell is happy with windows formatted text files. Just not a mixture, I guess.
03:23:41 <imcmeans> Even when those windows newlines are in string constants?
03:23:50 <imcmeans> I got this: lexical error in string/character literal at character '\r'
03:24:33 <quicksilver> I thought so. Maybe it depends how your GHC was compiled etc. I've never used windows.
03:37:49 * hackagebot language-javascript 0.0.1 - Parser for JavaScript  http://hackage.haskell.org/package/language-javascript-0.0.1 (AlanZimmerman)
03:49:00 * hackagebot hjsmin 0.0.5 - Haskell implementation of a javascript minifier  http://hackage.haskell.org/package/hjsmin-0.0.5 (AlanZimmerman)
03:49:35 <Jafet> Browsers should run Haskell already
03:49:50 <Jafet> *insight*
03:49:56 <Jafet> Hey manatee, I have a proposal
03:51:32 <pacak> Jafet: And we should declare javascript obsolete.
03:52:32 <pastorn> I saw something on reddit a while back
03:52:51 <pastorn> You can have a Monad with return/bind, but you could also have it with join and something else
03:53:01 <pastorn> which is this other function?
03:53:03 <pastorn> fmap?
03:53:06 <Boxo> join, fmap, return
03:53:22 <pastorn> oh right, you still need to be able to enter the monad
03:53:53 <pastorn> is that a more category-theory-oriented collection of functions?;
03:53:59 <Boxo> f >>= x = join $ fmap f x
03:54:04 <Jafet> And fail!
03:54:05 <pastorn> yeah
03:54:51 <Boxo> fmap f x = x >>= (return.f) ; join x = x >>= id
03:55:25 <pastorn> Boxo: nice
03:55:29 <pastorn> thanks
03:55:51 <blenderer> "Enter the Monad"
03:58:31 <Cale> pastorn: fmap/return/join is the traditional category theoretic way to define monads
03:59:00 <Cale> pastorn: At least, closer to it :)
03:59:48 <Martinix> Hi! Is there anyone I could ask about installing multiple versions of ghc on fedora 12?
04:00:14 <Cale> Martinix: ask away. I don't know anything specifically about Fedora 12, but maybe someone does.
04:02:16 <Cale> pastorn: If you have some category C consisting of a bunch of objects and arrows (e.g. types and functions), an endofunctor T: C -> C is a mapping sending objects to objects and arrows to arrows, and fmap (which category theorists will usually just call T) is the arrow part of that assignment. return :: a -> T a corresponds to the category theorists' natural transformation eta: 1 -> T, and join :: T (T a) -> T a corres
04:02:16 <Cale> ponds to a natural transformation mu: T^2 -> T
04:02:56 <Cale> (A monad is usually defined as an endofunctor together with a pair of natural transformations of those types satisfying some laws)
04:03:43 <quicksilver> Cale: (well, 'return' is only the object part of the natural transformation; it's an interesting fact of parametricity that the arrow-part is both uniquely determined and natural)
04:03:43 <Cale> Martinix: It's usually possible to install and use more than one version of GHC at a time, but it can be a little awkward.
04:04:09 <Cale> quicksilver: The object part of the natural transformation?
04:04:14 <quicksilver> hmm
04:04:20 <quicksilver> OK that wasn't right.
04:04:25 <Cale> The object part of the functor is the type constructor
04:04:26 <Boxo> huh. what's "1"?
04:04:41 <Cale> Boxo: The identity functor
04:04:50 <Cale> Which sends each object and each arrow to itself
04:05:09 <Cale> 1 X = X :)
04:05:13 * quicksilver thinks it's best if he is ignored :)
04:12:59 <blenderer>  /ignore quicksilver
04:29:19 <Martinix> <Cale> Thanks. The compiler, the grammatical framework and the line editor are needed. How would one add them next to the existing haskell-platform?
04:31:59 <cathper> I have a function, say `f', that is quite heavy to calculate. I have to consider `f 5' more than once. Adding -O2, will that make `f 5' to be calculated just once? It gets calculated twice (comparing the runtime) if not -O2 is added.
04:32:37 <Jafet> Memoizing it will use space.
04:32:46 <jkff> Hi. I'm trying to install haskell-platform on a fresh Ubuntu VM and I'm getting this http://hpaste.org/42448/cabal_update_failure . (but the actual 00-index.tar.gz ends up being only about 30kb instead of 2mb) How can this be fixed? cabal update goes fine on the Windows machine hosting this vm.
04:32:54 <Jafet> Since in Haskell you tend to worry more about space than time, that kind of optimization isn't done
04:33:09 <cathper> jkff: That's not a problem; the runtime is a way larger problem than mem usage.
04:33:19 <Jafet> You could memoize it manually, of course.
04:33:30 <jkff> cathper: I think you were addressing someone else
04:33:37 <cathper> Damn, for you Jafet. Right jkff.
04:33:48 * Jafet wonders why people tab from one letter
04:33:56 <cathper> Jafet: Right. But I'd prefer to let Haskell do that for me.
04:34:47 <jkff> Compare http://hpaste.org/42449/cabal_update_success - not too many differences
04:34:52 <Jafet> Haskell doesn't. GHC could, but it doesn't either.
04:35:02 <dcoutts> jkff: you could try the latest cabal-install version with a more recent HTTP lib
04:35:03 <lambdabot> dcoutts: You have 3 new messages. '/msg lambdabot @messages' to read them.
04:35:13 <cathper> Jafet: Because you were the last one writing ...
04:35:45 <Jafet> Memoizing isn't particularly hard, at least if you really aren't concerned with space
04:35:51 <jkff> dcoutts: well, I know I can do that, but it seems more than strange that haskell-platform can't cabal update out of the box
04:35:56 <cathper> Jafet: Well, GHC produces a binary that does. Yeah, but ...
04:36:21 <dcoutts> jkff: most people are not using proxies
04:36:32 <dcoutts> jkff: and it works with most proxies
04:36:40 <cathper> Jafet: Right. But if the code will do it automagically for me when compiling with -O2 I'd prefer that for now; and if it turns out to be a problem, then I'll fix it.
04:37:05 <Jafet> Uh, Haskell doesn't run on magic. I know, I feel sorry too.
04:37:27 <cathper> Sorry?
04:37:46 <jkff> dcoutts: Maybe, but exactly the same thing happened for a friend of mine who works at one of the largest programming companies in Russia (Yandex, Google's chief competitor) - that's quite a sad audience to lose :)
04:37:56 <Jafet> Look, GHC just doesn't do it. If you want them to do it, I guess you could ask them on the trac
04:38:20 <dcoutts> jkff: it's not that we don't care, but it's actually quite tricky to track down these problems
04:38:51 <jkff> dcoutts: Let's see if this can be fixed by using cabal 0.8.2 - maybe would it then make sense to simply bundle it with haskell-platform?
04:38:59 <dcoutts> jkff: so we'd want to concentrate on reproducing and working out the cause of the problem when using the latest versions
04:39:12 <cathper> Jafet: Okay. I was just wondering since `f 5; f 5' has the same execution time as `f 5' when -O2 is used.
04:40:01 <dcoutts> jkff: the current release of the haskell-platform does include cabal-install 0.8.2
04:40:09 <dcoutts> jkff: and an updated HTTP lib
04:40:21 <jkff> dcoutts: Hm. Then that seems a problem of the ubuntu distro. Thanks for pointing out, will complain to them :)
04:40:49 <cathper> Jafet: Even having `f 5; f 5; f 5; f 5' has the same execution time as `f 5' using -O2.
04:41:57 <Heffalump> I can't think of anything that has changed in HTTP that might fix such a problem, but I could be wrong (I'm the maintainer, but only as of recently, and I don't have much time for it - I'm only the maintainer because everyone else seems to have less time...)
04:42:26 <cathper> Also without -O2.
04:42:27 <Jafet> cathper: uh, what's f and how are you using it?
04:44:36 <cathper> Jafet: f x = heavy calculations (See http://zeros.spag.dk; it's the function `d'). I'm applying it on various values of x. For a concrete value of x, f is applied to x more than once.
04:45:18 <cathper> Jafet: Basically I ask if `f x' (for the concrete x) is calculated just once or the number of times f is applied to x?
04:45:43 <Jafet> I did check and did find that ghc does do cse in restricted cases like that.
04:46:46 <Jafet> cathper, I don't doubt your math, so please show your Haskell code instead
04:47:28 <Jafet> GHC does not do that in the general case, which is what I assumed you were referring to earlier (but you were referring to some contrived test)
04:48:00 <cathper> Jafet: Sorry, the link to the .hs file is kinda hidden. Here it is: http://people.math.aau.dk/~caspert/zeros/code.hs
04:48:23 <cathper> Jafet: I see.
04:51:42 <cathper> `f 5; f 5' make `f 5' calculated once. However, `[ f k | k <- [5,5] ]' will make `f 5' to be calculated twice, for instance.
04:57:42 <lars9> cathper: f 5; f 5 does not make sense by their own.
04:57:55 <lars9> cathper: if you want memoization, check out MemoTrie
04:58:30 <cathper> lars9: Right. main = do print $ f 5; print $ f 5. I was trying to be brief.
04:58:58 <cathper> lars9: Looking at MemoTrie.
04:59:10 <lars9> cathper: i think it will be calculated twice, if there is no optimization.
05:00:56 <cathper> lars9: You're right.
05:01:36 <lars9> cathper: f' = memo f, then call f' 5
05:01:53 <Baughn> lars9: IIRC, GHC does not normally do common subexpression elimination, due to laziness issues
05:02:09 <Baughn> (It can cause memory leaks)
05:02:27 * blenderer wishes cabal was smart enough to look in .cabal/bin on its own 
05:03:02 * Baughn does not so wish. Better to keep a single unique PATH.
05:03:22 <lars9> Baughn: not even with -O2?
05:03:59 <blenderer> Every time cabal spews back an error I get confused and spend 10 minutes wondering what happened.
05:04:30 <Baughn> lars9: Right. As I said, there are potential memory leaks. Let me think..
05:04:34 <dcoutts> blenderer: you can file tickets about poor error messages or behaviour
05:05:19 <Baughn> lars9: Let's say you have 'let a = f x; b = f x', and f x is an expensive operation that produces a large structure.
05:05:25 <Jafet> They're not potential memory leaks, they're usually real memory leaks
05:05:27 <cathper> http://www.haskell.org/haskellwiki/Performance/GHC#Common_subexpressions
05:05:32 <Baughn> ..or just read that
05:05:38 <Baughn> cathper++
05:06:00 * cathper feels incremented.
05:06:06 <Baughn> Yeah. In the few cases where they *aren't* real leaks, it's usually better to do CSE explicitly
05:06:38 <cathper> Baughn: Using MemoTrie, or?
05:07:02 <Baughn> cathper: Preferably an explicit let, if that's feasible. Otherwise MemoTrie, sure.
05:07:49 <cathper> Is there some neat way to inspect the number of times `f 5', say, is called?
05:09:06 <Baughn> I don't know if you'd call it 'neat', but unsafePerformIO would do that nicely
05:09:16 <Baughn> But if you mean 'is there a library to do it for me', I don't know
05:09:44 <cathper> Or some profiling option.
05:10:22 <laufbaum> There is Debug.Trace
05:10:29 <Baughn> It doesn't count
05:11:26 <lars9> you can just 'understand' it
05:12:30 <cathper> I'd add "'s around just ;-)
05:13:39 <Cale> The reason that GHC doesn't do CSE is indeed that it increases space usage -- this is true regardless of evaluation order (so it's not exactly to do with laziness).
05:13:41 <pro_momo> hey guys, is it possible to get hugs coloured like winhugs?
05:14:17 <Baughn> Cale: I can think of a few contrived scenarios where it won't, but point taken
05:14:49 <Cale> Baughn: Perhaps if you were evaluating things in parallel, then it wouldn't.
05:14:55 <Baughn> Right.
05:15:03 <Jafet> Is -fvia-c still necessary for the fastest numerical code?
05:15:11 <Baughn> Jafet: Try the LLVM codegen first
05:15:14 <Baughn> s/first/too/
05:17:32 <Cale> pro_momo: Hmm, I don't see anything in the documentation about it.
05:17:46 <Jafet> Hm. When did -fllvm get into the official distribution?
05:17:56 <Baughn> 7.0, I think?
05:18:16 * Jafet pouts
05:36:28 <blenderer> what does ghc use to parse haskell code?
05:37:38 <blenderer> nevermind. should google first
05:40:13 <pastorn> Cale: ugh... my head started to spin
05:51:39 <weebl> Hi guys, I'm messing about with happy parsers and I'm trying to generate lists, but not just any lists. Basically I have a list which needs a dataconstructor in front of it, i.e. data Selfmade = Selfmade [a]
05:52:02 <weebl> But since there are 4 cases to work with when parsing the syntax I have no idea to fix this. Let me post a little bit of code.
05:52:23 <Tiibiidii> hello, i have a problem... it seems that i wrote badly my pattern and this generates an infinite loop, since it's starting to get quite complicated i wanted to debug it, i followed the instructions here ( http://www.haskell.org/ghc/docs/7.0-latest/html/users_guide/ghci-debugger.html ), that is: set break on esception, trace the problematic instruction, terminate it with ^C and open the history, but it complains that it "Not stopped at a breakpo
05:52:23 <Tiibiidii> int", any idea?
05:53:48 <Tiibiidii> ghci is version  6.12.1 btw
05:54:01 <weebl> http://haskell.pastebin.com/kZH1NHEG <- this is what i mean
05:54:16 <Zeiris_> How fast is the HXT XML parsing suite? Can it compare with C libraries like RapidXML?
05:56:34 <weebl> anyone with knowledge of happy?
05:57:10 <pro_momo> Cale: Thanks, winhugs is really great with all the colour coding
06:00:20 <pro_momo> Cale: ghci can use colour
06:00:25 <pro_momo> i might use that instead
06:00:30 <pro_momo> http://www.haskell.org/haskellwiki/GHCi_in_colour
06:00:39 <Tiibiidii> weebl, i'm very new to haskell, but that seems a recursive data type to me... it's that what you're trying to do?
06:01:09 <Tiibiidii> btw, do you have (or anyone else here for that matter) any experience with debugging in ghci?
06:01:47 <weebl> Tiibiidii: yes it's supposed to be recursive, basically it generates a list of Alt ([Alt]) but this is my own datatype
06:01:53 <weebl> so it should put a constructor in front of it
06:01:56 <weebl> so Alts [Alt]
06:14:27 <Cin> http://hpaste.org/42450/systemio
06:15:01 <Cin> So, OS X's filesystem is case-insensitive.
06:15:27 <quicksilver> Cin: the disk that comes with a new mac is formatted case-insensitive, yes.
06:15:57 <quicksilver> the filesystem itself can be case-sensitive or not
06:16:24 <Cin> Ah, so the system will still work just fine if case-insensitive?
06:16:32 <Cin> Er, s/insensitive/sensitive
06:17:38 <quicksilver> its' a good question that :) It seems quite possible that some 3rd party software might accidentally assume case insensitivity.
06:17:43 <weebl> I fixed my problem, if anyone wants to know simply generate the normal list [Alts] first and call that like PreAlts then Alts : PreAlts { Alts $1 }
06:17:53 <quicksilver> I ran a Mac on a case-sensitive boot disk for a year or so without any identifiable issues though.
06:17:55 <Cin> quicksilver: Yeah, that's trouble brewing.
06:18:07 <Cin> Oh. Hum.
06:18:17 <quicksilver> then it blew up, and I didn't bother to reformat the replacement in the same way.
06:18:50 <Cin> Was anyone injured in the blast?
06:19:30 <quicksilver> every time a macintosh crashes, a fairy dies
06:19:33 <quicksilver> apart from that, no.
06:25:31 <Cin> quicksilver: That error... it's definitely due to the file system and not GHC? GHC sees 'System.Io' as an import, then presumably looks in the file path before the package registry. I'm having trouble imagining what step would cause this problem. Any ideas?
06:26:10 <Cin> Why would it expect 'System.IO' and not what was specified, 'System.Io'?
06:26:13 <quicksilver> Cin: the import of System.Io works fine, I imagine.
06:26:24 <quicksilver> Cin: it's the import of System.IO (by System.Io) which is the problem)
06:26:25 <Cin> Ah, woops. Good point
06:27:50 <Tiibiidii> anyone has any suggestion to detect loops in ghci? (i'm still googling a solution in the meanwhile)
06:28:49 <Cin> quicksilver: Hmm. Would a patch for GHC that checks the filename case-sensitively break everything, I wonder. Could be a good flag. Might be already!
06:29:19 <quicksilver> Cin: well I think this is the filesystem's fault, probably.
06:29:27 <quicksilver> GHC is asking for "System/IO.hs"
06:29:29 <Cin> Yeah, I mean as a workaround.
06:29:35 <quicksilver> and the filesystem is saying "yes, here it is"
06:29:46 <quicksilver> not easy for GHC to then check what case came back
06:29:50 <Cin> Right, it asks for it and gets it. But GHC can also say "what's the original file name?"
06:29:55 <Cin> Sure it is..
06:29:55 <quicksilver> I don't think so.
06:30:07 <romanandreg> guys I'm reading a declaration of a function from the mongoDB library 
06:30:08 <quicksilver> no way to go from file descriptor to original file name
06:30:15 <quicksilver> as far as I know
06:30:19 <romanandreg> and I don't understand some part of it
06:30:20 <romanandreg> find q@Query{selection, batchSize} 
06:30:33 <romanandreg> what does the {selection, batchSize} is
06:30:33 <romanandreg> ?
06:30:39 <quicksilver> romanandreg: record fields
06:30:46 <quicksilver> using one of the 'pun' extensions
06:31:01 <quicksilver> equivalent to Query{selection = selection, batchSize = batchSize}
06:31:10 <romanandreg> quicksilver
06:31:10 <Cin> quicksilver: Perhaps not but doing a stat before opening would work, no? It would be a bit slower, but that's partly why it could be a flag.
06:31:11 <romanandreg> aohhh
06:31:54 <Cin> (I.e. the openFile "aB" function would check and treat "AB" as a file not found.)
06:32:07 <quicksilver> Cin: stat doesn't give you the file name (does it?)
06:32:32 * Cin looks up unix stuff
06:32:45 <Cin> I've done this on Windows but never POSIXy
06:33:03 <bartavelle> for those who remember my problems with using memoization from last week, I believe I got it now, but it doesn't seem to work
06:33:04 <bartavelle> a module : http://hpaste.org/42442/the_gamesolver_module, and sample code : http://hpaste.org/42443/a_sample_using_gamesolver
06:33:15 <romanandreg> the second question regarding mongoDB code 
06:33:19 <romanandreg> given this function
06:33:22 <romanandreg> find
06:33:23 <romanandreg>   :: (Control.Monad.Context.Context Database m,
06:33:23 <romanandreg>       Control.Monad.Context.Context
06:33:23 <romanandreg>         Database.MongoDB.Internal.Protocol.Pipe m,
06:33:23 <romanandreg>       Control.Monad.Context.Context MasterOrSlaveOk m,
06:33:23 <bartavelle> the trace shows that memoization doesn't work
06:33:24 <romanandreg>       Control.Monad.Context.Context WriteMode m,
06:33:24 <romanandreg>       Control.Monad.Throw.Throw Failure m,
06:33:24 <romanandreg>       Control.Monad.IO.Class.MonadIO m,
06:33:25 <romanandreg>       Control.Applicative.Applicative m) =>
06:33:25 <romanandreg>      Query -> m Cursor
06:33:38 <Cin> Ah, yes.
06:33:48 <romanandreg> let me put it on a pastie better
06:33:49 <Cin> quicksilver: stat (at least OS X's) has N, the name of the file.
06:34:19 <Tiibiidii> does anyone knows why ^C doesn't throw an exception?
06:34:20 <bartavelle> if somebody has a clue on what i am doing wrong, that would be a great help
06:34:26 <quicksilver> Cin: I don't see it in my stat manual page
06:35:26 <romanandreg> nevermind
06:35:30 <romanandreg> I deduced myself
06:35:32 <romanandreg> i think
06:35:46 <quicksilver> Cin: if you m ean the %N specifier of the stat program, that's just giving you back the name you gave it, for convenient.
06:35:59 <quicksilver> Cin: I think you have to read the parent directory directly
06:36:18 <Cin> quicksilver: Ah, balls.
06:37:19 <Cin> Oh well, would certainly make it a bit slower.
06:37:38 <imc> if i have a (m [a]), how can I apply something to each a? i.e   m [a] -> (a -> m b) -> m b
06:38:05 <Cale> imc: A combination of mapM or forM and (>>=)
06:38:10 <Cin> Alright, gotta see if my flight's been cancelled again. BBL.
06:38:12 <imc> ok
06:38:31 <Cale> :t \x f -> mapM f =<< x
06:38:32 <lambdabot> forall a (m :: * -> *) b. (Monad m) => m [a] -> (a -> m b) -> m [b]
06:38:45 <Cale> oh, that gives a list of the results of course
06:38:51 <imc> :P
06:42:10 * hackagebot cpsa 2.2.1 - Symbolic cryptographic protocol analyzer  http://hackage.haskell.org/package/cpsa-2.2.1 (JohnRamsdell)
06:45:45 <Tiibiidii> i hate to bug in this way, but every reference i find googling says the same thing, and yet it's not what's happening to me...
06:45:55 <Tiibiidii> why ^C doesn't throw an exception?
06:46:12 <Tiibiidii> (in the meanwhile i tried to do :step repeatdly, but debugging like this is impossible)
06:52:25 <unkanon_> join #ror
06:52:30 <unkanon_> damin it :)
06:52:35 <Saizan> Tiibiidii: ^C does throw an exception, try e.g. Control.Exception.catch (getLine) (\(SomeException e) -> putStrLn "Thrown" >> print e >> return "")
06:53:59 <jan247> hi guys, been wanting to do haskell for the longest time, finally coming around reading the real world haskell book and it's one of the best computer books so far i have to say..
06:54:18 <jan247> i was wondering though, how good is haskell for server side programming?
06:55:17 <jan247> i've been doing erlang for the past year. i like haskell's laziness and it's type system.. but can i easily build something robust and scalable in haskell?
06:56:10 <jan247> in particular, does haskell come with a standard way of connecting to some shell of a running program, then hacking my way through there? or do i have to restart the app everytime i want to change something?
06:56:55 <unkanon_> it's a compiled language so you'll probably have to recompile every time
06:58:08 <xdanek7> hello, I have problems understanding this expression: any . notElem
06:58:10 <jan247> is there any way around that?
06:58:34 <xdanek7> looking at types, I know that (.) has the type (.) :: (b -> c) -> (a -> b) -> a -> c
06:58:58 <xdanek7> but for example notElem :: Eq a => a -> [a] -> Bool
06:59:08 <Tiibiidii> Saizan, i'm trying to run that snippet
06:59:18 <xdanek7> so how can be notElem used as the first parameter of (.)
06:59:19 <xdanek7> ?
06:59:19 <Tiibiidii> but i've never used Exceptions in haskell before
06:59:33 <lunaris> xdanek7: You can unfold the composition yourself to see how.
06:59:36 <unkanon_> xdanek7: notElem is the second parameters
06:59:40 <unkanon_> parameter*
06:59:40 <lunaris> So
06:59:45 <Tiibiidii> there's something particular i should do to use Control.Exception and Control.SomeException ?
06:59:56 <lunaris> (any . notElem) x = any (notElem x)
07:00:01 <lunaris> :t any
07:00:02 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
07:00:14 <unkanon_> jan247: maybe, but that's a question for the experts here, and I'm not one of them :)
07:00:32 <xdanek7> lunaris: how it this "unfoling" done?
07:00:38 <jan247> thanks though unkanon_ :)
07:00:44 <lunaris> xdanek7: Just apply the definition of composition
07:00:56 <lunaris> xdanek7: (f . g) x = f (g x)
07:01:07 <lunaris> xdanek7: So, (any . notElem) x = any (notElem x)
07:01:09 <unkanon_> jan247: things are a bit slow here now because it's too early. an hour from now or so, you'll stand a better chance at getting a good answer. good luck
07:01:19 <lunaris> xdanek7: any :: (a -> Bool) -> [a] -> Bool
07:01:24 <xdanek7> I have no problems applying . on a function that takes one argument and returns one value
07:01:33 <lunaris> xdanek7: notElem :: Eq a => a -> [a] -> Bool
07:01:34 <jan247> unkanon_: thanks for the tip :)
07:01:48 <Bynbo7> xdanek7: all functions take one argument, and return a nother
07:01:48 <xdanek7> but (.) :: (b -> c) -> (a -> b) -> a -> c so it works only for functions that take only one parameter b and return value of c
07:01:52 <Bynbo7> value8~
07:01:52 <lunaris> xdanek7: So (notElem x) must have type (a -> Bool) for some a.
07:01:54 <Bynbo7> **
07:02:18 <lunaris> xdanek7: The key thing to appreciate though is that notElem is a function that takes *one* argument
07:02:20 <okp> jan247: it's possible to recompile and restart the application to the same state with some trickery with hs-plugins
07:02:33 <lunaris> xdanek7: And that it returns a *function* of type ([a] -> Bool)
07:02:49 <Bynbo7> xdanek7: a -> b -> c -> d is really a -> (b -> (c ->d))
07:03:17 <jan247> okp: i've passed by hs-plugins and it seems interesting. would you know though if it's still actively maintained?
07:03:37 <xdanek7> really, I thought function application is left-associative, at least that is what our teacher said
07:03:54 <Jafet> You mean a -> b -> c -> d is theoretically a -> (b -> (c -> d))
07:04:01 <Jafet> In reality it's just a -> b -> c -> d
07:04:01 <xdanek7> yes
07:04:03 <Bynbo7> currying wouldn't work if it were
07:04:24 <Bynbo7> :t map
07:04:25 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
07:04:28 <unkanon_> xdanek7: wait, function application is left associative but TYPES are right associative ;)
07:04:35 <Bynbo7> :t map id
07:04:36 <lambdabot> forall a. [a] -> [a]
07:04:43 <Bynbo7> :t map id [1,2,3]
07:04:44 <lambdabot> forall a. (Num a) => [a]
07:04:46 <unkanon_> xdanek7: Bynbo7's example is correct
07:05:00 <xdanek7> ok, that makes sense
07:05:07 <okp> jan247: looks like the last update has been in 2010
07:05:21 <Bynbo7> >t \x -> any . notElem x
07:05:25 <Bynbo7> :t \x -> any . notElem x
07:05:26 <lambdabot>     Couldn't match expected type `a -> Bool'
07:05:26 <lambdabot>            against inferred type `Bool'
07:05:26 <lambdabot>     Probable cause: `notElem' is applied to too many arguments
07:05:39 <Bynbo7> eh?
07:06:09 <jan247> okp: oh, thanks for looking that up.
07:06:19 <danr> notElem x will be a Bool, but any expects a function as its first argument
07:06:40 <danr> :t any . notElem
07:06:41 <lambdabot> forall a. (Eq a) => a -> [[a]] -> Bool
07:06:44 <Bynbo7> :t notElem
07:06:45 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
07:06:48 <danr> :t \x -> any (notElem x)
07:06:48 <lambdabot> forall a. (Eq a) => a -> [[a]] -> Bool
07:06:56 <danr> those might be what you want :)
07:21:01 <hpc> :t notElem
07:21:02 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
07:21:38 <xdanek7> thanks, I think I finally understand that enough to work it out only with pen and paper ;-)
07:22:34 <Bynbo7> :t any . notElem
07:22:35 <lambdabot> forall a. (Eq a) => a -> [[a]] -> Bool
07:31:50 <j-invariant> I want to program the inverse limit in haskell (to help understand it) -- is this even remotely computable?
07:33:49 <hpc> j-invariant: perhaps try and see how far you can get?
07:33:53 <msieradzki> how do I install GHC 6.12 and 7.0.1 at the same time and have cabal use 6.12 (unless I manually switch to cabal from 7.0.1 or something like that)?
07:34:34 <dankna> very carefully.  sorry, that's my best answer :(
07:34:52 <quicksilver> you give cabal the appropriate commandline option
07:34:56 <quicksilver> to choose the ghc you want.
07:35:07 <msieradzki> which is?
07:35:19 <msieradzki> I can't find any
07:35:28 <quicksilver>  -w --with-compiler=PATH           give the path to a particular compiler
07:36:19 <Zao> I'd install it into a different directory and adjust $PATH just-in-time.
07:36:33 <Saizan> cabal -w ghc-6.12.1 vs. cabal -w ghc-7.0.1
07:36:47 <Zao> Similiar to the 'module load intel-cpp-11.1' of cluster environments.
07:36:51 <Saizan> (the niceness of versioned binaries)
07:39:00 <dcoutts> msieradzki: and if you want to make it persistent then you can use the config file
07:39:14 <rfh> could someone please help me with my implementation of partition: http://pastebin.com/6deSVKEw 
07:40:36 <Saizan> rfh: don't call both the predicate and the step function p
07:40:44 <tromp> rfh: first try adding some type declaration
07:40:49 <Saizan> rfh: since in the body of the step function p will be a recursive call
07:40:50 <orbital_fox> any comments about a haskell vs OCaml? do you think they "compete" why OCaml/Haskell?
07:46:55 <Bynbo7> orbital_fox: they only compete in JDH's mind
07:48:00 <orbital_fox> JDH ?
07:48:12 <Zao> Uncle Harrop.
07:48:22 <Zao> Grand Proponent of Madness.
07:49:09 <orbital_fox> ...
07:49:45 <tab> orbital_fox: there's plenty of comparaison "litterature" out there, why do you want another one ?
07:50:13 <orbital_fox> a reference to the best one in you opinion would be enough :)
07:50:30 <Bynbo7> obviouslt haskell...
07:50:32 <Bynbo7> y*
07:50:56 <Bynbo7> we win on the shootout, so it must be better in every way!
07:51:44 <rfh> Saizan: type signature: (a->Bool) -> [a] -> ([a],[a])
07:52:04 <Bynbo7> rfh: add it to your code
07:52:28 <Bynbo7> and notice that you're using the name p for two completely different things, this will never end well ;)
07:52:53 <Bynbo7> > let f x | f x = x in f True
07:52:54 <lambdabot>   *Exception: stack overflow
07:54:31 <Bynbo7> > let causeStackOverflow x | x = False | causeStackOverflow x = True in causeStackOverflow True
07:54:31 <lambdabot>   False
07:54:44 <Bynbo7> > let causeStackOverflow x | x = False | causeStackOverflow x = True in causeStackOverflowFalse
07:54:45 <lambdabot>   Not in scope: `causeStackOverflowFalse'
07:54:51 <Bynbo7> > let causeStackOverflow x | x = False | causeStackOverflow x = True in causeStackOverflow False
07:54:52 <lambdabot>   *Exception: stack overflow
07:55:52 * Bynbo7 should have called that avoidStackOverflow
07:57:11 <rfh> Bynbo7: dont get it. if my implementation unfolds it looks something like this: p x1(px2(...(p xn ([],[]) ))).
07:57:36 <sipa> > let avoidStackOverflow x = error "Throwing exception before any stack overflow can occur" in avoidStackOverflow 5
07:57:36 <lambdabot>   *Exception: Throwing exception before any stack overflow can occur
07:58:37 <Bynbo7> rfh: but your predicate and the function you give to foldr are both called p
08:01:00 <rfh> Bynbo7: changed function name, but getting still the same execption
08:03:32 <rfh> Bynbo7: ah. finally. what a relief.
08:03:39 <rfh> now i unterstand
08:03:44 * hackagebot jmacro 0.4.1 - QuasiQuotation library for programmatic generation of Javascript code.  http://hackage.haskell.org/package/jmacro-0.4.1 (GershomBazerman)
08:03:47 <orbital_fox> tab, no references?
08:05:29 <tab> orbital_fox: sorry, i don't have any good pointer
08:06:14 <tab> orbital_fox: i do both languages every day though ;)
08:09:46 <HugoDaniel> hey
08:09:54 <HugoDaniel> encoding does not work
08:10:10 <HugoDaniel> in ghc 7.0.1
08:10:47 <HugoDaniel> http://hackage.haskell.org/packages/archive/encoding/0.6.3/logs/failure/ghc-7.0 here is the log, any ideas how do i make this work ?
08:11:03 <pastorn> @hoogle (Monad m) => m a -> m b -> m a
08:11:03 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
08:11:03 <lambdabot> Control.Monad (>>) :: Monad m => m a -> m b -> m b
08:11:03 <lambdabot> Control.Monad.Instances (>>) :: Monad m => m a -> m b -> m b
08:11:15 <pastorn> @type liftM2 const
08:11:16 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m a1
08:11:27 <pastorn> what should i call it?
08:11:34 <orbital_fox> tab what is your personal preference, if you have one? if you were to briefly differentiate the two what would you say?
08:11:37 <pastorn> ignoring?
08:12:22 <danr> mconst ?
08:12:52 <Jafet> @pl liftM2 const
08:12:52 <lambdabot> liftM2 const
08:13:03 <danr> @unpl liftM2 const
08:13:03 <lambdabot> (\ d e -> d >>= \ b -> e >>= \ a -> return b)
08:13:17 <tab> HugoDaniel: it's mtl vs mtl2 issues, there's a wiki page somewhere about it
08:13:52 <tab> orbital_fox: i much prefer haskell despite having done years of ocaml first
08:16:05 <orbital_fox> tab, ok thanks :)
08:16:08 <pastorn> HugoDaniel: that's very weird... i'm looking at the source right now
08:16:24 <tab> orbital_fox: richer set of libraries, and a more alive community in general
08:16:27 <quicksilver> orbital_fox: ocaml is strict, impure, and has some annoying syntactical restrictions
08:16:37 <quicksilver> orbital_fox: haskell is lazy and pure
08:16:38 <pastorn> HugoDaniel: ghc-pkg hide *something*
08:16:49 <quicksilver> on the other hand, ocaml certainly has some interesting type extensions like the record stuff.
08:16:51 <pastorn> i think it's mtl you should hide, but i'm not suer
08:17:12 <pastorn> quicksilver: does ocaml have an IO type?
08:17:23 <orbital_fox> pastorn, are objects mutable in ocaml?
08:17:32 <orbital_fox> sorry pastorn that was for quicksilver 
08:17:37 <orbital_fox> quicksilver, , are objects mutable in ocaml?
08:17:40 <pastorn> i understood that :)
08:17:48 <tab> pastorn: there's no IO type
08:18:00 <pastorn> cool
08:18:21 <tab> pastorn: as such, everything is in IO :(
08:18:25 <pastorn> so basically it's haskell without being annoying ;)
08:18:34 <Jafet> There's no IO type in Haskell, either
08:18:42 <quicksilver> orbital_fox: I imagine so. I never tried to use the ocaml object stuff.
08:18:53 <orbital_fox> ok
08:18:56 <pastorn> quicksilver: i believe no one has
08:19:06 <tab> pastorn: I'm sure you'll change your mind as soon as you hit the terrible ocaml standard lib
08:19:13 <pastorn> i watched a video presentation by a guy at jane street, he said that it's there, but that noone uses it
08:19:14 <pgavin> pastorn: I just came in, but... how is haskell annoying?
08:19:22 <j-invariant> the only annoying thing about requiring an IO monad is all the trolls that complain about it
08:19:25 <quicksilver> pastorn: no need for anything like IO, if your language is impure anyway.
08:19:29 <pastorn> pgavin: ocaml has no IO type
08:19:38 <pgavin> it doesn't need it
08:19:40 <quicksilver> pastorn: putStrLn :: String -> ()
08:19:42 <quicksilver> e.g.
08:19:45 <pgavin> it's not purly functional
08:19:54 <Jafet> pastorn: neither does Haskell.
08:20:17 <Jafet> @quote IO
08:20:17 <lambdabot> LukePalmer says: ...when you use an advanced feature, you need a yet more advanced feature to abstract over it... But all you need to abstract over a function is another function.
08:20:19 <quicksilver> Jafet: don't be unnecessarily pedantic.
08:20:25 <pastorn> btw, i looked at BitC, it's probably going to have a 'pure' keyword to be placed in front of functions when applicable
08:20:27 <quicksilver> Jafet: IO is a type of kind :: * -> *
08:20:30 <Jafet> I'm not being pedantic, I'm giving him a hint
08:21:13 * djahandarie calls all things on the type level types, regardless of their kinds
08:21:31 <pastorn> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
08:21:41 * djahandarie does this for consistency with the value level
08:21:41 <pastorn> looks very much like a type to me...
08:22:11 <quicksilver> pastorn: it must be admitted, though, that that isn't haskell :)
08:22:34 <djahandarie> IO is abstractly defined in the report, so I think it's safe to say that Haskell has it... 
08:22:48 <Jafet> Okay. But if IO is a type, that still doesn't make Monad a type
08:22:57 <pgavin> Monad is a type class
08:23:12 <Jafet> Sorry, I mentioned Monad and IO. I should go hide somewhere now
08:23:14 <HugoDaniel> pastorn: ghc-hide mtl ? :P
08:23:47 <pastorn> HugoDaniel: ghc-pkg hide mtl *i think*
08:23:56 <pastorn> anyone: is it the right one to hide?
08:24:00 <pgavin> ghc -hide-package mtl
08:24:01 <tab> pastorn: probably not
08:24:07 <pastorn> monads-fd then?
08:24:31 <pgavin> transformers, monads-{fd,tf}, mtl, mtl-tf
08:25:23 <pastorn> pgavin: well, one of them needs to go
08:25:25 <tab> encoding is depending on mtl already
08:25:31 <tab> no need to hide any others monads libraries
08:25:53 <tab> the problems is more than likely that State constructor doesn't exist anymore in mtl2
08:26:03 <tab> whereas it's available in mtl1
08:26:18 <pastorn> HugoDaniel: ^^^^^
08:26:39 <tab> HugoDaniel: you could try putting a mtl < 2 in the encoding cabal file
08:27:05 <tab> or changing "State" to "StateT Identity" IIRC with mtl-2
08:27:16 <HugoDaniel> ah ok
08:27:36 <HugoDaniel> i should read up on mtl so i can understand these incompatibilities :/
08:28:03 <HugoDaniel> let me try chaging the cabal
08:28:08 <tab> HugoDaniel: http://trac.haskell.org/haskell-platform/wiki/Proposals/transformers
08:28:13 <roconnor> Or you could abandon the MTL like everyone should
08:28:20 <j-invariant> Does haskell have ACTUAL category theory in it?
08:28:21 <tab> HugoDaniel: section incompatibilities
08:28:38 <copumpkin> j-invariant: "in it"?
08:28:39 <tab> roconnor: huh ?
08:28:44 <HugoDaniel> roconnor:  what are the alternatives ?
08:29:15 <HugoDaniel> anyway this is for the encoding pkg that i tend o use quite often
08:29:17 <pgavin> j-invariant: type classes allow the abstractions necessary to represent category theoretical constructs
08:29:24 <copumpkin> j-invariant: category theory is a language used to describe structures, and haskell can (squinting a bit) be seen through many of the CT points of view
08:30:00 <roconnor> HugoDaniel: monadlib, mmtl, possibly others
08:30:08 <HugoDaniel> Downloading mtl-1.1.1.1...
08:30:36 <djahandarie> pgavin, not fully imo, I'd like the laws to be included for me to say something like that :)
08:30:41 <tswett> Gosh, fix$(<$>)<$>(:)<*>((<$>((:[{- thor's mother -}])<$>))(=<<)<$>(*)<$>(*2))$1 does what it does pretty inefficiently.
08:30:57 <djahandarie> :t fix$(<$>)<$>(:)<*>((<$>((:[{- thor's mother -}])<$>))(=<<)<$>(*)<$>(*2))$1
08:30:58 <lambdabot> forall a. (Num a) => [a]
08:31:04 <pastorn> tswett: have you done any profiling?
08:31:05 <djahandarie> > fix$(<$>)<$>(:)<*>((<$>((:[{- thor's mother -}])<$>))(=<<)<$>(*)<$>(*2))$1
08:31:05 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
08:31:06 <pgavin> djahandarie: you mean like monad laws etc.?
08:31:18 <djahandarie> pgavin, for example, yes
08:31:23 <tab> roconnor: to which benefit ?
08:31:28 <tswett> It does what it does pretty incomprehensibly, I should say.
08:31:35 * tswett tries to figure out how it works.
08:31:39 <djahandarie> Putting them as quickcheck props doesn't count :)
08:31:48 <Jafet> That would make a nice tattoo
08:31:49 <pastorn> tswett: i wouldn't if i were you :p
08:31:59 <roconnor> tab: correct implementations of StateT Cont
08:32:21 <pastorn> tswett: after that you only have the let-in thing to figure out
08:32:28 <Bynbo7> > fix error -- lostman__ 
08:32:29 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
08:32:39 <tab> roconnor: is that not solved by monads-fd already ?
08:32:50 <roconnor> tab: not as far as I know
08:33:01 <tswett> pastorn: you're looking at the same Uncyclopedia page as I am, eh?
08:33:08 <pgavin> djahandarie: how hard would it be to make the compiler do that though?
08:33:22 <pastorn> tswett: <3 <3 <3 box art <3 <3 <3
08:33:56 <djahandarie> pgavin, you'd be nearing on a proof assistant at that point
08:34:14 <HugoDaniel> still breaks after mtl < 2 is forced
08:34:15 <pastorn> tswett: haskell, also known as narwhalese
08:34:30 <roconnor> tab: oh, you might be right
08:34:38 <roconnor> ah no
08:34:50 <roconnor> The MonadCont instance for StateT is not compatible with the monad
08:34:51 <roconnor>    transformer.  The transformers package provides the correct lifting
08:34:52 <roconnor>    (in which callcc causes the state to rollback on entering the saved
08:34:54 <roconnor>    continuation), but also provides the MTL lifting for compatibility,
08:34:55 <roconnor>    and this is used by monads-fd.  It could be switched to the correct
08:34:56 <tab> i've no idea, i never used Cont
08:34:57 <roconnor>    lifting later.
08:35:21 <tab> see they got it correct in transformers at least
08:35:36 <tab> which is a dependencies of mtl-2 at least
08:35:54 <roconnor> but I expect mtl-2 to use the wrong version
08:35:57 <pastorn> roconnor: wait... did ContT break any monad laws?
08:36:16 <tswett> Is there a way to ask lambdabot what a particular typo command corrects to?
08:36:17 <roconnor> pastorn: not to my knowledge
08:36:23 <roconnor> pastorn: ListT does though
08:36:28 <tswett> Because as it is, figuring it out is a fun game.  Like, what the heck does @info do?
08:36:31 <tab> roconnor: well you could still use the one in transformers directly, isn't it ?
08:36:31 <pastorn> it does? how?
08:36:47 <tswett> @info does this--which is not very apparently useful
08:36:47 <lambdabot> does this
08:36:49 <roconnor> tab: not if you are abstract over MonadCont
08:36:55 <pastorn> it seems that the rollback on call-cc should be there, but i dunno
08:37:14 <Jafet> @inf
08:37:14 <lambdabot> Maybe you meant: bf id kind ping unpf wn
08:37:34 <Jafet> (Good thing spellcorrection is monotonic?)
08:37:41 <applicative> tswett, you can just type @ and it will list the commands.  It'd be a bit spammy here...
08:37:57 <roconnor> pastorn: ListT in the MTL only works on commutative monads
08:38:16 <pastorn> i don't know what that is
08:38:26 <pastorn> f >> g === g >> f ?
08:38:33 <tab> roconnor: ok
08:38:39 <quicksilver> pastorn: yes.
08:38:40 <applicative> @llist
08:38:40 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
08:38:54 <pastorn> but how does that even typecheck?
08:39:04 <pastorn> and what about order?
08:39:05 <roconnor> pastorn: liftM2 . flip = flip . liftM2 -- commutative monad
08:39:11 <quicksilver> or, "x <- f; y <- g; return (x,y)" == "y <- g; x <- f; return (x,y)"
08:39:31 <quicksilver> pastorn: well, your one only makes sense if they're both "m ()"
08:39:35 <tswett> I've figured it out.  @info is @pointful.
08:39:37 <quicksilver> my one is the more general version.
08:39:49 <roconnor> tswett: O_o
08:40:10 <monochrom> @info map f . map g
08:40:11 <lambdabot> map f . map g
08:40:24 <roconnor> @type (liftM2 . flip)
08:40:25 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a2 -> a1 -> r) -> m a1 -> m a2 -> m r
08:40:32 <roconnor> @type (flip . liftM2)
08:40:33 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a2 -> m a1 -> m r
08:40:59 <pastorn> ah, and how does this break against the monad laws?
08:41:02 <pastorn> which law?
08:41:06 <apple> Hi all, on OS X, what's the best way to get hold of the Haskell Platform Source code. Unless it's in the Haskell Platform and I can't find it...
08:41:12 <roconnor> how does ListT break the monad laws?
08:41:20 <apple> This is so that I use them in Leksah
08:42:05 <tswett> Which is to say, @info is @unpf.  :)
08:42:28 <applicative> apple, do you mean the source for the libraries?  there is also the ghc souce...
08:42:51 <NewWorld> Hi, is there a way to integrate a haskell interpreter into VIM? Like integrating HUGS
08:43:35 <monochrom> @info \x -> f (g x)
08:43:35 <lambdabot> \ x -> f (g x)
08:43:42 <apple> applicative: I guess I was thinking both the libraries and the ghc but I was thinking there was just a download somewhere called "Haskell Platform Source"
08:44:40 <apple> applicative: Alternatively, I can download the ghc source... but not sure how to get the rest other than one at a time.
08:45:25 <monochrom> I'm not convinced that Leksah requires library source rather than library installed. But here: http://hackage.haskell.org/platform/2010.2.0.0/haskell-platform-2010.2.0.0.tar.gz
08:45:50 <monochrom> how to find it in general: choose linux then look for source
08:46:10 <tswett> @info f . g
08:46:11 <lambdabot> f . g
08:46:19 <apple> monochrom: yeah, it could be an issue with how I have Lecksah set up as well
08:46:21 <applicative> apple http://hackage.haskell.org/platform/linux.html the tarball contains all the platform libs.  
08:46:24 <tswett> lambdabot: if f . g can't be made pointier, what can?
08:46:31 <applicative> oh, what monochrom said
08:46:46 <monochrom> well it seems choosing mac also has the "build from source" section
08:47:51 <applicative> apple, yes, i was thinking leksah will find all the platform library source 
08:48:03 <tswett> Anyway, can lambdabot tell me fixities?
08:48:10 <monochrom> no
08:51:15 * hackagebot polar 0.0.0 - Complex numbers in polar form  http://hackage.haskell.org/package/polar-0.0.0 (StefanKersten)
08:51:16 <monochrom> @unpl f . g
08:51:16 <lambdabot> (\ c -> f (g c))
08:51:42 <djahandarie> Wow, there are quite a few people in Japan who are interested in Haskell
08:51:51 * monochrom has a cunning plan!
08:51:58 <monochrom> @unpl g . h
08:51:58 <lambdabot> (\ c -> g (h c))
08:52:02 <monochrom> ghc :)
09:16:06 <apple> quit
09:21:46 <knobo> what is the obvious advantage of using continuation passing style?
09:22:13 <cde> knobo, it prevents global warming
09:22:53 <knobo> But the global warming is not man-made, is it?
09:23:13 <aristid> knobo: that does not matter. continuation passing style is man-made
09:23:14 <pgavin> knobo: it's not as useful in haskell as in strict languages
09:23:40 <aristid> you can write monad transformer stacks based on CPS :D
09:23:46 <aristid> mm_freak_ has done that
09:23:57 <cde> there's a direct corerlation between global warming and imperative programming. just look at the graphs
09:23:59 <pgavin> or just use ContT
09:24:06 <pgavin> and callcc
09:24:25 <knobo> cde: but cps is not imperative, is it?
09:24:44 <cde> I have no idea
09:24:52 <Jafet> CPS is functional spaghetti
09:24:55 <pgavin> lol
09:24:56 <pgavin> yes
09:25:50 <knobo> CPS sounds cool, but it's not, right?
09:26:18 <knobo> s/t, r/t. R/
09:26:19 <pgavin> eh
09:26:25 <pgavin> it's useful to know and understand
09:26:32 <pgavin> but not useful in practice :)
09:26:50 <Saizan> it's quite useful as an implementation
09:27:01 <Saizan> but you want to wrap it up in some nicer abstraction
09:27:01 <Cale> Actually, there is one great use for CPS
09:27:22 <Cale> Whenever you need to allocate some resource and ensure that it'll eventually be freed
09:27:22 <Jafet> I found CPS nicer than monad transformers
09:28:00 <Cale> Then what you can do is write a function taking the action to be performed with that resource as a parameter, and which handles the allocation and deallocation at the same time
09:28:24 <Cale> This idiom is usually accompanied by names prefixed with "with"
09:28:28 <Cale> "withFile" etc.
09:28:48 <pgavin> Cale: you still have the leaked handle problem
09:28:52 <Cale> Sure.
09:28:54 <unkanon_> Cale: oh I've seen that in haskell not long ago... oh, in that mainisnotafunction blog or something
09:29:00 <unkanon_> about running assembly in haskell
09:29:10 <unkanon_> so that's what those with... fiunctions are, hmm...
09:29:13 <Cale> It doesn't solve the problem entirely, but it can help avoid forgetting.
09:29:24 * hackagebot timeplot 0.2.12 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-0.2.12 (EugeneKirpichov)
09:30:08 <Cale> and a little bit of modification of it using some type system extensions can solve the leaked handle problem
09:30:17 <Cale> But may be a bit awkward.
09:30:27 <pgavin> ya
09:30:34 <Cale> a*
09:30:34 <pgavin> you could disallow the handle as a return type
09:30:38 <Cale> yeah
09:30:52 <pgavin> awkward is right, though
09:31:21 <pgavin> or wrap it in a state monad and only allow communication through the state
09:31:33 <Cale> It's basically the same trick as ST
09:31:37 <pgavin> ya
09:35:03 <BONUS> hey anyone know when the haskell platform release that will include mtl-2 is getting released?
09:35:07 <BONUS> i haven't been following the news
09:43:42 <hvr> BONUS: http://trac.haskell.org/haskell-platform/wiki/ReleaseTimetable
09:44:07 <BONUS> ah, that's what i was looking for. cheers
09:45:18 <BONUS> did Data.Text go through?
09:45:34 <hvr> BONUS: although I'm a bit confisued about when the 2011.1.x freeze was
09:45:46 <mm_freak_> pgavin: CPS is very useful, if you know how to make use of it
09:46:11 <mm_freak_> i found that i combine StateT and ContT so often that i decided to write a whole library of CPS-based monad transformers, as aristid mentioned
09:46:30 <pgavin> mm_freak_: I'll take a look at it
09:46:32 <mm_freak_> Cale: ensuring resource freeing by CPS is only useful with delimited CPS
09:46:58 <pgavin> mm_freak_: but as others have mentioned, it can lead to haskell spaghetti
09:46:58 <mm_freak_> but that's also about the only type of CPS you get in haskell, so it's fine =)
09:47:08 <mm_freak_> pgavin: it can, but not necessarily
09:47:14 <pgavin> mm_freak_: right :)
09:47:26 <mm_freak_> CPS is about as evil as goto =)
09:47:27 <Jafet> That's like saying goto can lead to fortran spaghetti
09:47:58 <pgavin> you don't need CPS to get spaghetti though, excessive tail calls can do that
09:48:08 <mm_freak_> used properly you get quite a lot of useful stuff (parsers, iteratees and even continuation-based webservers)
09:48:14 <Jafet> That's Greenspunned CPS.
09:48:15 <pgavin> yep
09:54:30 <j-invariant> How do you compute universal cones? Could I actually write a haskell function to do this or is it not possible?
09:58:57 <nostrand> j-invariant: do you have a formula for it?
09:59:13 <j-invariant> what do you mean by a formula?
09:59:24 <nostrand> f(x) = x²
09:59:43 <nostrand> i really don't know what you want to compute =)
09:59:54 <nostrand> but if it is computable Haskell can do it
10:00:35 <monadic_kid> i think it's from category theory
10:00:44 <monadic_kid> not gemoetric cones
10:00:48 <monadic_kid> right?
10:01:03 * djahandarie wonders what is being discussed
10:02:05 <monadic_kid> j-invariant: is that what you meant, not geometric cones but something to do wtih category theory?
10:03:00 <j-invariant> yes
10:04:11 <djahandarie> Ah, damn, my client was blending in the chat with the joins/quits
10:04:50 <monadic_kid> j-invariant: I've never studied category theory so i can't help you, there are some clever people in who can help but i think you've just picked a bad time
10:05:25 <djahandarie> j-invariant, you can represent limits and colimits in Haskell
10:06:43 * hackagebot snap-core 0.3.0 - Snap: A Haskell Web Framework (Core)  http://hackage.haskell.org/package/snap-core-0.3.0 (GregoryCollins)
10:06:45 * hackagebot snap-server 0.3.0 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.3.0 (GregoryCollins)
10:07:01 <djahandarie> Not sure about computing them, is there some mechanical way to do this?
10:07:13 <djahandarie> If it is universal I imagine you can't always do it
10:07:36 <djahandarie> edwardk probably knows
10:07:44 <monochrom> if it's semi-computable you can die trying
10:08:43 * hackagebot snap 0.3.0 - Snap: A Haskell Web Framework (Core)  http://hackage.haskell.org/package/snap-0.3.0 (GregoryCollins)
10:10:34 <aristid> bottest: snap
10:10:45 * hackagebot snap 0.3.0.1 - Snap: A Haskell Web Framework: project starter executable and glue code library  http://hackage.haskell.org/package/snap-0.3.0.1 (GregoryCollins)
10:11:02 <monochrom> eh?!
10:11:03 <arcatan> woot, snap 0.3?
10:11:20 <monochrom> and already an update within 2 minutes?!
10:11:34 <monochrom> bottest: snap
10:12:00 <djahandarie> Haha
10:12:03 <mjrosenb> @hoogle [a] -> a -> [a]
10:12:04 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
10:12:04 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
10:12:04 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
10:12:36 <mjrosenb> is there an equivalent for l \\ [x] that does not involve creating a list?
10:12:46 <mjrosenb> not that list fusion won't get rid of it
10:12:54 <mjrosenb> it just looks ugly.
10:13:48 <monochrom> what is \\ ?
10:13:59 <Makoryu> mjrosenb: delete ?
10:13:59 <aristid> so snap 0.3 is NOT a monad transformer. they decided against it *just learned*
10:14:07 <Makoryu> :t delete
10:14:07 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
10:14:14 <Makoryu> :t (\\)
10:14:15 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
10:14:50 <Makoryu> > delete 'z' "pizza"
10:14:51 <lambdabot>   "piza"
10:15:05 <Makoryu> > "pizza" \\ "z"
10:15:05 <lambdabot>   "piza"
10:15:25 <aristid> > (nub . not . (==)) 'z' "pizza"
10:15:25 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[a]'
10:15:34 <monochrom> not sure what you could do if you neither create new data nor mutable existing data.
10:15:37 <aristid> :t nub . not .: (==)
10:15:37 <lambdabot>     Couldn't match expected type `[Bool]'
10:15:37 <lambdabot>            against inferred type `a -> Bool'
10:15:37 <lambdabot>     Probable cause: `==' is applied to too few arguments
10:15:48 * hackagebot darcsden 0.4 - darcs project hosting and collaboration  http://hackage.haskell.org/package/darcsden-0.4 (AlexSuraci)
10:16:17 <monochrom> s/mutable/mutate/
10:16:19 <Makoryu> :t nubBy (/=)
10:16:20 <lambdabot> forall a. (Eq a) => [a] -> [a]
10:16:36 <Makoryu> aristid: ^
10:16:44 <aristid> Makoryu: ah, lol
10:16:47 <Makoryu> :p
10:17:01 <aristid> > nubBy (/=) 'z' "Pizza"
10:17:02 <lambdabot>   Couldn't match expected type `[a]'
10:17:02 <lambdabot>         against inferred type `GHC.Types...
10:17:14 <aristid> aah, lol
10:17:18 <mjrosenb> > nubBy (/=) "z" "pizza"
10:17:19 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> t'
10:17:19 <lambdabot>         against inferr...
10:17:20 <aristid> i was trying to use nub as filter all the time
10:17:29 <aristid> :t filter . not . (==)
10:17:30 <lambdabot>     Couldn't match expected type `a -> Bool'
10:17:30 <lambdabot>            against inferred type `Bool'
10:17:30 <lambdabot>     In the first argument of `(.)', namely `not'
10:17:37 <aristid> :t filter . not .: (==)
10:17:38 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
10:17:48 * hackagebot ssh 0.2.5 - A pure-Haskell SSH server library.  http://hackage.haskell.org/package/ssh-0.2.5 (AlexSuraci)
10:17:52 <aristid> > (filter . not .: (==)) 'z' "Pizza"
10:17:52 <lambdabot>   "Pia"
10:17:58 <Makoryu> Is .: a tighter-binding version of . ?
10:18:07 * mjrosenb fails as well :(
10:18:11 <aristid> same tightness, but different content
10:18:22 <aristid> :t filter .: (/=)
10:18:23 <lambdabot>     Couldn't match expected type `a -> Bool'
10:18:23 <lambdabot>            against inferred type `Bool'
10:18:23 <lambdabot>     Probable cause: `/=' is applied to too many arguments
10:18:25 <arcatan> (.:) = (.) . (.)
10:18:26 <aristid> :t filter . (/=)
10:18:27 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
10:18:29 <arcatan> :t (.).(.)
10:18:30 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
10:18:33 <Makoryu> :t filter (/= 'z')
10:18:34 <lambdabot> [Char] -> [Char]
10:18:39 <Makoryu> :V
10:20:14 <j-invariant> Do set theoretic things like Yoneda have "haskell friendly" versions?
10:20:21 <aristid> Makoryu: that's too easy
10:20:28 <Makoryu> aristid: （　°‿‿°）
10:20:46 <aristid> j-invariant: there's Yoneda stuff in some haskell modules, dunno if that's what you want
10:31:03 <ManateeLazyCat> @time
10:31:13 <lambdabot> Local time for ManateeLazyCat is Tue Dec 21 02:30:46 2010
10:31:22 <ManateeLazyCat> Need to sleep, bye all, G'night. :)
10:33:06 <roconnor> j-invariant: yes, Yoneda f a = forall b. (a -> b) -> f b
10:33:22 <roconnor> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor-Yoneda.html
10:35:25 <j-invariant> thanks
10:35:26 <applicative> here is an application of type Yo f a ... http://conal.net/blog/posts/memoizing-polymorphic-functions-via-unmemoization/
10:36:56 <roconnor> j-invariant: applying codensity to your monad can sometime increase perforamce.
10:37:18 <roconnor> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Monad-Codensity.html
10:39:10 <fryguybob> The link to download haskell platform for windows seems broken: http://hackage.haskell.org/platform/windows.html
10:39:13 <djahandarie> Does it ever reduce performance?
10:39:30 <roconnor> djahandarie: likely
10:40:08 <djahandarie> I guess the equiv. question would be "does a CPS transform of the code ever reduce performance?" which I imagine is true sometimes
10:40:42 <roconnor> CPS transforming CPS transformed code probably introduces a little overhead with no gains
10:41:04 <djahandarie> Though, asymptotically speaking?
10:41:05 <RichardBarrell> roconnor: wouldn't you hope that to be a no-op?
10:42:21 <monochrom> there is no hope
10:44:59 <applicative> fryguybob, i can get it.  
10:45:17 <fryguybob> applicative: ok
10:47:01 <fryguybob> strange,  the link that fails for me is: http://lambda.galois.com/hp-tmp/2010.2.0.0/HaskellPlatform-2010.2.0.0-setup.exe
10:48:55 <applicative> fryguybob, I see what you mean.  
10:49:15 * BMeph wonders why a link with "tmp" in its name should ever be expected to work all the time...
10:52:35 <applicative> BMeph, it's the link for the Windows Platform installer.  
10:53:15 <aristid> @hoogle forkIO
10:53:15 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
10:53:47 <aristid> @hoogle forkOnIO
10:53:47 <lambdabot> No results found
10:54:21 * monochrom posts on haskell-cafe to ask about the link http://lambda.galois.com/hp-tmp/2010.2.0.0/HaskellPlatform-2010.2.0.0-setup.exe
11:02:22 <mercury^> @pl \f g x -> f (g x) x
11:02:22 <lambdabot> flip flip id . liftM2
11:03:07 <mercury^> :t foo f g x = f (g x) x
11:03:08 <lambdabot> parse error on input `='
11:03:21 <mercury^> :t \f g x -> f (g x) x
11:03:23 <lambdabot> forall t t1 t2. (t1 -> t -> t2) -> (t -> t1) -> t -> t2
11:03:35 <mercury^> What do you call categories with that natural isomorphism?
11:07:31 <mercury^> @pl \f g x -> f x (g x)
11:07:31 <lambdabot> ap
11:07:31 <mercury^> :t \f g x -> f x (g x)
11:07:32 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t -> t1) -> t -> t2
11:07:35 <mercury^> Ah.
11:07:53 <mercury^> That's better. :)
11:11:16 <mercury^> So the key is that (t ->) is applicative. Still, what are categories with that property called?
11:11:42 <unkanon_> I never knew that, and I would never have found that out, because:
11:11:47 <unkanon_> @unpl ap
11:11:47 <lambdabot> (\ d e -> d >>= \ b -> e >>= \ a -> return (b a))
11:12:02 <unkanon_> that's very different from f x $ g x
11:12:04 <unkanon_> so thanks :)
11:12:28 <mercury^> Is it even a natural isomorphism?
11:12:32 <Saizan> code produced by @pl can be more general than the input, but @unpl doesn't guess that
11:12:52 <unkanon_> ic
11:13:10 * hackagebot hsndfile 0.5.0 - Haskell bindings for libsndfile  http://hackage.haskell.org/package/hsndfile-0.5.0 (StefanKersten)
11:15:04 <mercury^> Right, it isn't an isomorphism even in the case of (t ->) on Hask.
11:17:22 <mercury^> Still, this is what's responsible for hom(a, b \times c) ~ hom(a,b) \times hom(a,c)?
11:19:04 <applicative> @type \ f x -> runReader ((Reader f) `ap` (Reader x))
11:19:04 <lambdabot> forall r a a1. (r -> a -> a1) -> (r -> a) -> r -> a1
11:24:30 <elb0w> I am not very familiar with Haskell but I am curious about it. Would someone mind telling me its strengths and common uses?
11:24:54 <j-invariant> haskell  is quite simply  the best language around
11:25:02 <elb0w> lol
11:25:17 <benmachine> strengths are: being awesome
11:25:22 <benmachine> common uses: kicking ass
11:25:24 <benmachine> uhm
11:25:26 <benmachine> in seriousness
11:25:35 <pgavin> use it for everything
11:25:43 <benmachine> it is a general-purpose language
11:25:43 <pgavin> lol
11:25:45 <pumpkin> elb0w: strongly typed for reasonable correctness assurance, easy to reason about otherwise, lets you write very high-level code while still being performant, and is used a lot for compilers :)
11:25:55 <benmachine> so in principle it can be used for everything except possibly hard real-time
11:26:10 <byorgey> elb0w: it is functional (first-class functions), strongly typed, and pure (no mutation)
11:26:11 <benmachine> it has good abstraction capabilities I find
11:26:27 <applicative> elb0w  what sort of thing are you interested in, I mean, what sort of uses would attract you?  
11:26:47 <elb0w> I just see references to it here and there and didnt know enough about it
11:27:02 <elb0w> I am browsing the website, but I feel its always good to get users of the languages input
11:27:17 <applicative> its leading strength is incomparable beauty
11:28:00 <applicative> or rather, the inexplicable combination of that with the amazing compiler
11:28:42 <benmachine> heh
11:29:00 <elb0w> ok you guys sold me :P Think ill take out a book on it when I get done with python
11:29:10 <applicative> but that's just one addict's opinion...
11:29:15 <mauke> beware, the end boss is pretty hard
11:29:19 <pgavin> lol
11:29:22 <applicative> check out LYAH
11:29:29 <pgavin> his power level is over 9000
11:29:33 * pgavin ducks
11:29:38 <sm> here's my version: haskell lets you develop software with fewer runtime bugs and a flatter maintenance cost curve than most other languages
11:29:46 <applicative> elb0w, the tutorial
11:29:52 <applicative> @where lyah
11:29:52 <lambdabot> http://www.learnyouahaskell.com/
11:30:09 <pgavin> most of the bugs in haskell code show up at compile time
11:30:17 <j-invariant> Does anyone have examples of yoneda in action?
11:30:25 <pgavin> the rest after hours of hair pulling and various +RTS flags
11:30:26 <pumpkin> ezyang: around?
11:30:29 <mauke> @quote yoneda
11:30:29 <lambdabot> slava says: Because top enterprise industry analysts recommend that managers need to focus on Agile methodologies, SOA, B2B and Yoneda's lemma in today's rich Internet application-driven environment.
11:30:29 <lambdabot>  Don't get left behind by the AJAX craze by missing out on call center outsourcing and Yoneda's lemma!
11:30:44 <applicative> j-invariant, did you follow the link to conal's site?
11:31:11 <applicative> http://conal.net/blog/posts/memoizing-polymorphic-functions-via-unmemoization/
11:33:33 <alpounet> j-invariant, that would make a great book title
11:33:37 <alpounet> "Yoneda in action"
11:34:07 <applicative> IO (Yo a)
11:34:53 <mercury^> Does Yoneda have special Haskell meaning or are you asking for applications of the Yoneda lemma?
11:34:56 <applicative> IO (Yo f a) pardon
11:37:28 <mercury^> @djinn ((a -> b) -> (a -> c)) -> a -> (b -> c)
11:37:30 <lambdabot> f a b c = a (\ _ -> c) b
11:38:36 <mercury^> I'm too tired to think straight at the moment: is that an inverse for ap?
11:40:23 <lispy> ?src ap
11:40:23 <lambdabot> ap = liftM2 id
11:40:31 <lispy> ?src liftM2
11:40:31 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
11:40:41 <lispy> ?undo do { x1 <- m1; x2 <- m2; return (f x1 x2) }
11:40:41 <lambdabot> m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
11:58:12 <pumpkin> @tell ezyang just running darcs get on that URL gives a failure for me. Does it not for you? I get "Couldn't fetch `0000003609-361f0c2d7b7d50d0e898a35bd0928977210cc1045e7a0ef8851e176292e84cab'" and I think lispy did too. Not sure what's wrong, but --lazy seems to work
11:58:12 <lambdabot> Consider it noted.
11:59:29 <Zenon__> Could someone tell me if haskell (GHC) optimizes infinite list access? For instance if I have a recursive function that produces an infinite list, and I take 10 elements, and late on I take 11 elements from the same list/function, does it calculate the first 10 again or does it cache the results?
11:59:46 <mauke> Zenon__: same list or same function?
12:00:57 <Zenon__> same function, like f n = n : f (n+1), take 10 $ f 1 and take 11 $ f 1
12:01:03 <pumpkin> then no
12:01:29 <pumpkin> data is "memoized", functions are not
12:03:22 <Zenon__> hum is there an easy way to implement caching in this manner?
12:04:09 <mauke> there was a package called data-memocombinators or something like that
12:05:12 <edwardk> preflex: xseen Philippa
12:05:12 <preflex>  Philippa was last seen on freenode/#haskell-blah 9 hours, 34 minutes and 2 seconds ago, saying: (which, well, may happen by me changing host)
12:05:23 <Zenon__> ok thanks :)
12:05:36 <edwardk> @tell Philippa the VPL stuff turned out to be useful to provide me with asymptotic guarantees after all!
12:05:36 <lambdabot> Consider it noted.
12:07:09 <djahandarie> Zenon__, you can also check out MemoTrie
12:10:29 <Zenon__> well, that'll keep me occupied for some time... I hate it when I solve a project euler problem, but come to the conclusion that my solution could be reuseable for other problems if only I tweaked it a little. and that usually turns into a neverending story ...
12:12:15 <silbo__> how can I pattern match a number in string?
12:19:13 <mtnviewmark> like - given a String, you want to see if it contains a decimal number?
12:19:29 <pumpkin> a view pattern!
12:19:30 <pumpkin> :P
12:19:36 <mtnviewmark> or do you want to pattern match to see if the String is a particular number?
12:19:38 <pumpkin> on read :P
12:19:57 <Chewie[]> i am writing a file converter and it seems like System.IO.HVFS would be handy. it does not appear to be commonly used. is there a reason?
12:20:14 <Chewie[]> (particularly HVFS.Utils.recurseDirStat)
12:21:25 <steve__> Hi everyone, is it ok to ask very basic questions here? I'm a c++ programmer trying to learn haskell and am confused about some basics.
12:21:42 <danderson> sure
12:21:42 <mtnviewmark> welcome steve__
12:21:53 <steve__> Thanks. :) 
12:22:09 <steve__> One of the things I can't get around my head is function types and how they're handled. Specifically, take something like this:
12:22:20 <steve__> take' :: (Num i, Ord i) => i -> [a] -> [a]
12:22:40 <steve__> It's my understanding that the (  ) indicates that you're specifying a type name?
12:22:48 <pumpkin> nope
12:22:49 <steve__> Like you're saying "i" can be of type Num or ord
12:22:56 <danderson> the (...) => ... syntax means you're specifying type class constraints
12:23:11 <Zenon__> Num and Ord are type classes, a type can be a member of a type class
12:23:14 <steve__> Oh, so it's more saying "i can be a nu mor an ord)
12:23:20 <Zenon__> for instance Integer and Float are members of Num
12:23:22 <danderson> said in english, it reads "Given that 'i' implements both Num and Ord, take' is a function of 3 arguments..."
12:23:22 <steve__> *num or an ord
12:23:29 <Chewie[]> more like enforcing the constraint, "must be Num and Ord".
12:23:34 <pumpkin> you can think of typeclasses as being types of types, but a type can belong to multiple typeclasses, and they can be added retroactively
12:24:00 <steve__> Dang - talk about a lot of great responses. Let me digest those for a second...
12:24:23 <danderson> steve__: if you're following LYAH or RWH as tutorials, you'll get to type classes in a few chapters. Don't worry too much about them just yet.
12:24:29 <monochrom> a type class is really like a subset of types
12:24:35 <steve__> Danderson: this is perfect : you can think of typeclasses as being types of types, but a type can belong to multiple typeclasses, and they can be added retroactively
12:24:35 <steve__> * ttt-- (~abcd@78-23-117-246.access.telenet.be) has joined #haskell
12:24:35 <steve__> <steve__> Dang - talk about a lot of great responses. Let me digest those for a second...
12:24:35 <steve__> <danderson> steve__: if you're following LYAH or RWH as tutorials, you'll get to type classes in a few chapters. Don't worry too much about them just yet.
12:24:48 <danderson> at this stage a more concrete example may help
12:24:55 <steve__> eh sorry, copied a bit too much. But that explains it perfectly
12:25:11 <danderson> Int is one of Haskell's integer types
12:25:12 <monochrom> and then you also generalize to multiple parameter type class: an N-ary relation of types.
12:25:23 <danderson> it implements Num, meaning you can do various numeric operations with Int
12:25:33 <djahandarie> Another way to talk about it: Type classes give certain guarentees about your type (namely that certain functions will exist for your type)
12:25:33 <danderson> and it implements Ord, meaning that Int has an ordering
12:25:40 <danderson> so you can compare two Ints and get a total order
12:25:54 <Chewie[]> steve__: for example, think of Num and Ord as java interfaces (or loosely as base classes in C++) that take' "requires" some aspect of. this is not bulletproof but is sometimes the easiest to understand.
12:25:57 <danderson> the function type of take' is a generalization of that
12:26:21 <danderson> instead of saying that it only works with Int as the first argument, it says that it works for any ordered numeric type
12:26:48 <danderson> so you can give it an Int, but also a Word32 (32-bit unsigned integer), an Integer (arbitrary length integer) ...
12:27:09 <steve__> ok, very good - I think I understand. That seems very robust and easy going compared to what I'm used to 
12:27:28 <danderson> to fully get how this works under the hood, you need to wait until the chapter on type classes in whatever guide you're using
12:27:39 <steve__> I'm using the "Learn you a haskell" guide
12:27:45 <danderson> for now, let's just say that it's a vaguely related cousin of C++ classes and polymorphism
12:27:50 <danderson> only much more powerful :)
12:28:06 <steve__> ya, it seems a lot like polymorphism
12:28:07 <monochrom> not sure it's more powerful. but it's more organized.
12:28:08 <steve__> (only better)
12:28:12 <mauke> it is polymorphism
12:28:13 <steve__> http://learnyouahaskell.com/recursion
12:28:24 <mauke> it's less powerful than templates
12:28:27 <steve__> thats' the section I'm on
12:28:51 <danderson> yeah, so type classes will come quite a bit later.
12:28:56 <danderson> don't worry too much about them yet.
12:29:30 <steve__> Very cool. Thanks so much for the help, everyone. I'm sure I'll be back! What a cool language and community.
12:29:39 <danderson> when you see (...) => ... in a type signature, just remember that it's defining some constraints on the types the function accepts
12:29:48 <danderson> later on it'll all make much more sense :)
12:30:10 <mauke> :t show
12:30:11 <lambdabot> forall a. (Show a) => a -> String
12:31:00 <steve__> ok - thanks again, everyone. Unfortunately I have to run an unexpected errand. See you again soon.
12:31:20 * djahandarie suspects that we helped him too much
12:31:33 <mauke> @quote firehose
12:31:34 <lambdabot> No quotes match. stty: unknown mode: doofus
12:32:02 <McManiaC> is writing to a file lazy?
12:32:08 <monochrom> no
12:32:10 <McManiaC> stupid question
12:32:18 <mauke> actually, yes :-)
12:32:20 <McManiaC> will a lazy list be evaluated completly before written to a file?
12:32:26 <monochrom> yes
12:32:29 <pumpkin> McManiaC: who would request it?
12:32:31 <mauke> no
12:32:31 <pumpkin> if not
12:32:40 <Chewie[]> McManiaC: evaluated as it is written.
12:32:42 <McManiaC> yes no...
12:32:43 <McManiaC> :>
12:33:00 <mauke> McManiaC: file writing is lazy, lists are not completely evaluated before IO starts
12:33:13 <pumpkin> pff :P
12:33:13 <mauke> the first part is independent of Haskell, it's an OS feature
12:33:24 <mauke> see also: fsync
12:33:53 <Saizan> do writeFile "foo" str; putStrLn "str has been evaluated"
12:34:08 <Chewie[]> repeating... i am writing a file converter and it seems like System.IO.HVFS.Utils.recurseDir would be handy. it does not appear to be commonly used. is there a reason?
12:34:08 <Saizan> stdout is telling the truth there
12:34:39 <monochrom> thanks to a twist in OS buffering and journaling, there is a moment between the string evaluated and the file appears on the disk. if you time it right and power off your computer at that moment, the file is not written.
12:35:05 <c_wraith> some versions of some filesystems make that "moment" up to 5 minutes.
12:35:21 <c_wraith> Unless you explicitly sync the file
12:36:05 <monochrom> anyway I'm crossing abstraction boundaries here to troll :)
12:37:49 <monochrom> do { unsafeInterleaveIO (writeFile "foo" str); putStrLn "str has been evaluation"; putStrLn "the previous statement is false"; hPutStrLn stdout "stdout does not tell the truth" }
12:41:03 <tehgeekmeister> anyone heard of any work on an activerecord style persistence package for haskell?  not activerecord style in ease of use, but in conventions.
12:41:05 <Saizan> now i've lost my faith in programming.
12:41:31 <djahandarie> :-(
12:41:35 <mauke> that's me in the corner
12:41:45 <unkanon_> losing your religion?
12:42:22 <tehgeekmeister> Saizan: eh?
12:43:04 <Saizan> tehgeekmeister: nothing, just continuing the stdout joke from before
12:43:10 <tehgeekmeister> oh okay
12:43:34 <Saizan> what is activerecord style persistence?
12:43:49 <EvanCarroll> a plague.
12:44:06 <Saizan> (though i know only happstack-state as package for persistence in haskell)
12:44:37 <tehgeekmeister> Saizan: support for simple record style datatypes and simple relationships between them.  implement any other functionality you need in sql.
12:45:34 <Saizan> so it's a layer over rdbms ?
12:45:41 <tehgeekmeister> Saizan: yeah
12:46:23 <Saizan> there's haskelldb in that area
12:46:25 <tehgeekmeister> basically a package that provides a simple way to fetch rows into native datatypes and modify the rows, without having to use sql for that.
12:47:12 <tehgeekmeister> the package description seems like it describes something different than this
12:55:05 <Chewie[]> anyone know anything at all about System.IO.HVFS?
13:07:42 <Kaidelong> does differentiation behave something like a comonad, or are there derivatives that cannot be again derived?
13:08:45 <djahandarie> Only for a smooth function
13:08:59 <Kaidelong> djahandarie: can those be derived at all, though?
13:09:32 <pumpkin> comonad in what way?
13:09:38 <jst> Sup, peeps!
13:09:39 <pumpkin> you'd want a * -> * somewhere
13:09:47 <djahandarie> Unless you're talking about some other sort derivation...
13:09:47 <Kaidelong> if you have a derivative of some derivable thing
13:09:52 <Kaidelong> you can get the second derivative
13:10:00 <Kaidelong> if you have a derivative of some derivable thing
13:10:05 <Kaidelong> you can get the thing it was derived from
13:10:08 <jst> I have a simple question, bordering on the obscenely dumb.
13:10:25 <Kaidelong> there is no general way to go from a thing to its derivative, and that's fine
13:10:29 <Saizan> jst: go for it
13:10:42 <Kaidelong> comonad
13:10:47 <jst> Consider the following:
13:10:50 <pumpkin> http://hackage.haskell.org/package/ad
13:10:52 <jst> let a = []
13:11:08 <jst> all (==5) a
13:11:13 <jst> This returns True.
13:11:24 <Saizan> yeah
13:11:27 <Kaidelong> jst: all = foldr (&&) True
13:11:30 <jst> Why is that?
13:11:31 <pumpkin> it's the only thing that makes sense
13:11:38 <pumpkin> you want the unit of (&&)
13:11:39 <Kaidelong> there were no items in the list
13:11:40 <mauke> jst: same reason why sum [] == 0
13:11:49 <pumpkin> it's closer to product [] == 1
13:11:49 <mauke> and product [] == 1
13:11:58 <Kaidelong> thus none of them violated the condition, trivially
13:12:00 * edwardk hears one of his packages mentioned
13:12:22 <djahandarie> Kaidelong, that package pumpkin just linked can give you a tower of derivatives
13:12:28 <jst> Oh, alright.
13:12:33 <jst> I think I have it.
13:12:35 <benmachine> jst: what did you expect?
13:12:40 <Kaidelong> djahandarie: that and blog posts about it is what got me thinking about this to begin with
13:12:41 <jst> False
13:12:49 <djahandarie> And hey, edwardk is here, he can answer all of your questions!
13:12:50 <Kaidelong> the derivative tower looks a bit like a comonad
13:13:07 <jst> I thought it'd go like: "Well, I haven't found everything, ALL IS LOST!"
13:13:07 <edwardk> Kaidelong: yes, yes it does ;)
13:13:28 <benmachine> jst: a statement about all elements of an empty set is said to be 'vacuously true'
13:14:00 <edwardk> Kaidelong: there are plenty of derivatives that cannot be further derived. lots of functions are only C1 continuous
13:14:00 * jst just learned the word 'vacuosly'.
13:14:31 <Kaidelong> okay, so for many practical applications you cannot indefinitely continue to take derivatives?
13:14:35 <djahandarie> C^inf being 'smooth', i.e., what I said earlier
13:14:37 <edwardk> yes
13:14:42 <benmachine> you can think of the statement 'this property holds for all elements of the list' as the same as 'there aren't any elements of the list for which it does not hold'
13:14:57 <djahandarie> There are plenty of smooth functions
13:15:01 <benmachine> of course the latter is certainly true if there aren't any elements of the list at all :)
13:15:10 <djahandarie> I guess out of all functions, there are many more non-smooth functions though :)
13:15:12 <j-invariant> Kaidelong:all differntiable complex functions are infinitely differnetiable
13:15:13 <jst> Awesome.
13:15:29 <jst> benmachine: You are my hero.
13:15:34 <jst> Thanks, everybody!
13:15:39 <benmachine> woo
13:15:51 <edwardk> in fact, this is what keeps you from using things like higher order householder methods to converge arbitrarily quickly to the answer. e.g. Newton converges quadratically, but Halley's method converges cubically, and higher order householder methods (that rely on your function being C^n continuous), converge ^nthically ;)
13:16:36 <jst> Alright, have a nice day/night, everybody!
13:16:40 <benmachine> djahandarie: I heard that there is some sense in which 'almost all' continuous functions are nowhere differentiable
13:18:00 <Kaidelong> edwark: I was only really thinking of the single-variate case, I suppose with multi-variate things you can have things that are derivable in some ways but not in others...
13:18:03 <edwardk> benmachine: there is also a sense in which all computable functions are continuous, so it cuts both ways ;)
13:18:37 <Feuerbach> benmachine: OTOH if you consider monotonic functions, they are almost everywhere differentiable
13:18:38 <edwardk> http://math.andrej.com/2006/03/27/sometimes-all-functions-are-continuous/
13:19:06 <djahandarie> Man it gets really mathy in here sometimes
13:19:13 <benmachine> edwardk: yeah, I've read that, and it interested me a lot, but I sort of forget it for my real analysis courses :)
13:19:31 <edwardk> djahandarie: sorry, i've been trying to share some of the load between here and #scala lately ;)
13:19:39 <Saizan> yeah, what's a non-continuous function? you mean one whose domain is a disjoint union, right? ;)
13:19:40 <djahandarie> Hehe
13:19:57 <djahandarie> And that guy's latex is broken
13:20:07 <djahandarie> ...
13:20:18 <djahandarie> Who named it latex anyways?
13:20:42 <Saizan> it's all greeks' fault
13:20:57 <edwardk> benmachine: yeah real analysis and constructive logic don't play nice. kind of hard to get by without supremum property on sets of Reals, etc. 
13:21:07 <edwardk> djahandarie: blame Lamport
13:21:42 <sleepynate> djahandarie: don knuth made "tex", then lamport added the "la" from his name to it
13:22:00 * hackagebot maximal-cliques 0.1 - Enumerate all maximal cliques of a graph.  http://hackage.haskell.org/package/maximal-cliques-0.1 (GershomBazerman)
13:22:18 <edwardk> hey compumkin: check out gershom's latest toy, might help you ;)
13:22:41 <djahandarie> compumkin lol
13:23:17 <edwardk> he'll only become a compumpkin when i get him to write .net ;)
13:23:38 <edwardk> we move him to html and he can be a .compumpkin
13:25:34 <lispy> pumpkin: my hunch is that ezyang needs to set a sticky bit on the directory and change the existing permissions.
13:30:22 <Cale> djahandarie: The original TeX was by Donald Knuth, which was just a typesetting system for the most part, and then Leslie Lamport did LaTeX, which is a bunch of extensions to TeX which add lots of document preparation features.
13:31:16 <Ke> and to date there is no decent latex compiler
13:31:21 <Ke> !
13:31:26 <Cale> Oh?
13:31:44 <Cale> You mean to the standard of having as few bugs as TeX?
13:32:13 <lispy> djahandarie: and confusingly it's called la tex not latex
13:32:16 <Cale> I don't think I've ever run into an actual bug in LaTeX.
13:32:19 <lispy> djahandarie: but spell latex
13:32:30 <cde> reST >> latex (for simple stuff anyway)
13:32:57 <Ke> I mean ability to shut up, ability to provide single pdf document on single run and the ability to use eps and pdf graphics on same document
13:33:01 <Cale> Also, the X in TeX and LaTeX is pronounced like the ch in loch.
13:33:06 <Ke> and countless others
13:33:21 <cde> Ke: try sphinx :)
13:34:12 <pgavin> I always pronounced it like the tech in technology
13:34:25 <Ke> rubber was almost just bad when one did a bit shell script wrapping, but it doesn't work with texlive2010 anymore
13:34:45 <ion> I’ve used latexmk recently, but it has its faults.
13:35:02 <mjrosenb> i swear, one of these days i'm going to remember to save the url for this
13:35:03 <ion> No support for e.g. XeTeX without stabbing its source, for instance.
13:35:05 * hackagebot cabal-dev 0.7 - Manage sandboxed Haskell build environments  http://hackage.haskell.org/package/cabal-dev-0.7 (RoganCreswick)
13:35:26 <lispy> oh, woot! cabal-dev was finally released!
13:35:33 <djahandarie> That sounds needs
13:35:34 <djahandarie> neet
13:35:36 <djahandarie> neat
13:35:38 <djahandarie> -_-
13:36:00 <mjrosenb> does anyone know of a tutorial/.lhs file explaining how to do oop-ish things be making all of your data constructors take functions taht operate on the structures?
13:36:01 <ion> djahandarie: I see you’ve enjoyed similar amounts of alcohol as i have today. ;-)
13:36:32 <djahandarie> ion, hey, that'd be illegal! Unless you've had nothing to drink, in which case: yes.
13:37:03 <lispy> mjrosenb: There are a couple papers showing how to encode OOP in Haskell
13:37:08 <pgavin> djahandarie: where do you live that alcohol is illegal?
13:37:14 <lispy> mjrosenb: the most memorable for me is one by Oleg
13:37:25 <Saizan> mjrosenb: i remember something like that on Cale's wiki, but cale.yi.org shows the default page
13:37:27 <djahandarie> pgavin, US, I'm just young
13:37:33 <lispy> mjrosenb: http://homepages.cwi.nl/~ralf/OOHaskell/
13:37:33 <pgavin> djahandarie: oh, lol :)
13:37:35 <pgavin> djahandarie: ok
13:37:41 <Saizan> mjrosenb: the oleg paper is not intended for actual use
13:37:44 <djahandarie> Yeah, Oleg goes a far way doing OO stuff, even in Haskell 98
13:37:56 <mjrosenb> Saizan: yeah, i remembered it was dome by someone whose name started with a C.
13:37:59 <djahandarie> With a couple extensions he whips up a pretty powerufl OO language
13:38:06 <mjrosenb> Saizan: too many of them :-p
13:38:11 <Cale> Yeah, my wiki is on my other machine, and I'm uncertain about whether I'll be able to recover it, since the hard drive on that machine is failing.
13:38:22 <lispy> Saizan: the paper covers some tame approaches too
13:38:26 <monochrom> mjrosenb: http://www.haskell.org/haskellwiki/Existential_type has a section on OOP
13:38:34 <lispy> mjrosenb: if you want OOP in Haskell you probably want records
13:38:43 * mjrosenb believes it is the one that was on cale's wiki.
13:38:46 <Cale> Hopefully I will. I'm probably going to do something new with my webserver anyway though. I don't really care much for MediaWiki.
13:38:55 <lispy> mjrosenb: http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
13:39:09 <lispy> Cale: gitit has perks.
13:39:19 <mjrosenb> Cale: would it have been archived at archive.org?
13:40:16 <mjrosenb> iirc, this was implementing a (possibly asteroids-like) game
13:41:08 <Cale> mjrosenb: That's a decent idea
13:41:11 * hackagebot HDBC-postgresql 2.2.3.2 - PostgreSQL driver for HDBC  http://hackage.haskell.org/package/HDBC-postgresql-2.2.3.2 (JohnGoerzen)
13:41:37 <Cale> ah, my robots.txt kept it out :P
13:41:54 <pumpkin>     Couldn't match type `a' with `Var'
13:41:55 <pumpkin>       `a' is untouchable
13:41:55 <pumpkin>           inside the constraints (e ~ O, x ~ C)
13:41:58 <pumpkin> anyone know what give sthat?
13:42:18 <monochrom> untouchable. that's a new one. :)
13:42:20 <Cale> untouchable, eh?
13:42:29 <pumpkin> must be stuff from the new typechecker
13:42:33 <Saizan> mh, i remember something like that in the paper
13:42:41 <c_wraith> the type variable needs to be renamed eliottNess
13:42:49 <monochrom> is ghc now into dividing people into 4 classes? the lowest class being untouchable? :)
13:43:07 <Saizan> that the constraint solver wouldn't apply constraints under certain scopes.. though there wasn't the exact term "untouchable"
13:43:14 <Ke> cde: sphinx is quite ambiguous
13:43:15 <mjrosenb> type classes have now been replaced with type castes!
13:43:22 <pumpkin> lol
13:43:22 <djahandarie> pgavin, http://hackage.haskell.org/trac/ghc/ticket/4420#comment:2 related?
13:43:26 <djahandarie> Oops
13:43:28 <djahandarie> pumpkin, ^^
13:43:30 <c_wraith> isn't java full of type castes?
13:43:40 <mjrosenb> Cale: :(
13:44:26 <pgavin> djahandarie: sorry, I'm not sure what you mean
13:44:42 <djahandarie> pgavin, yeah, sent it to the wrong person lol, sorry
13:44:49 <djahandarie> Maybe I have had too much to drink...
13:45:03 <pgavin> oh that's what you meant by pumpkin ^^ lol
13:50:37 <monochrom> fewer type casts are now used in java source code thanks to generics. of course they are still type casts in intermediate form and bytecode.
13:50:56 * pumpkin shudders
13:51:33 <pumpkin> I'm surprised the word skolem made it into a user-facing error message
13:51:35 <c_wraith> yeah, java generics are still casts, they just are auto-generated by the compiler
13:52:06 <monochrom> statically checked type casts are fine. machine code is a big type-casting language.
13:52:18 <Cale> pumpkin: I'm not all that surprised, but where?
13:52:21 <c_wraith> the thing is, they're still checked at runtime.
13:52:25 * djahandarie casts a spell
13:52:32 <pumpkin> Cale: it's the polymorphic escape thing
13:52:37 <pumpkin>     Couldn't match type `e' with `e1'
13:52:37 <pumpkin>       because this skolem type variable would escape: `e1'
13:52:42 <djahandarie> c_wraith, I thought they were erased by runtime in Java?
13:52:53 <Cale> pumpkin: The type checker usually doesn't pull any punches when it comes to terminology regarding what it's doing.
13:52:54 <c_wraith> just because the jvm doesn't trust that the code it's executing came from a well-behaved compiler
13:52:59 <monochrom> oh, redundant runtime checks are fine unless you find it too slow
13:53:05 <Cale> pumpkin: It also mentions the occurs check :)
13:53:10 <pumpkin> true
13:53:13 <sipa> djahandarie: the bytecode doesn't know about generics
13:53:15 * hackagebot cabal-dev 0.7.1 - Manage sandboxed Haskell build environments  http://hackage.haskell.org/package/cabal-dev-0.7.1 (RoganCreswick)
13:53:20 <sipa> but the runtime does know about types
13:53:24 <djahandarie> Right
13:53:55 <sipa> so the generics information is erased, and replaced by runtime casts (which, by compiler verification, always succeed)
13:54:03 <monochrom> type erasure buys you speed only, and sometimes people regret it because it means less runtime debugging info
13:54:15 <sipa> speed?
13:54:28 <monochrom> speed.
13:54:37 <c_wraith> you know, amphetamines.
13:54:43 <sipa> Oh.
13:55:08 <pgavin> amphetamines are legal if you can convince a doctor you have ADD
13:55:24 <pumpkin> which doesn't seem very hard
13:55:26 <Saizan_> so is type erasure.
13:55:26 <monochrom> statically checked use of amphetamines?
13:55:40 <c_wraith> whoops, I dragged this channel way off-topic.  :(
13:55:44 <pgavin> lol
13:55:53 <monochrom> wait, type erasure is legal if you can convince a checker you have... ADD? :)
13:56:09 <sleepynate> correct.
13:56:14 <monochrom> @faq does haskell have ADD to warrant type erasure?
13:56:14 <lambdabot> The answer is: Yes! Haskell can do that.
13:56:22 <pgavin> lol
13:57:04 <c_wraith> @remember monochrom wait, type erasure is legal if you can convince a checker you have... ADD? :)
13:57:05 <lambdabot> Good to know.
13:57:08 <sipa> monochrom: i fail to see how type erasure gains you speed
13:57:11 <monochrom> heh
13:57:35 <sipa> or are you talking about compilation speed?
13:57:35 <monochrom> I actually just mean erasing runtime type checks.
13:57:53 <sipa> but type erasure (at least in java), still does runtime type checks
13:58:09 <sipa> s/does/causes/
13:58:25 <monochrom> s/type erasure/type check erasure/ OK?
13:58:43 <sipa> OK!
13:59:11 <Saizan_> type information uses memory, if you use too much memory you lose speed.
14:16:26 <pumpkin> man, hoopl is pretty opaque
14:23:59 <pumpkin> damn skolem variables escaping
14:24:06 * pumpkin gets a bigger leash
14:30:48 <c_wraith> Wouldn't a bigger leash let them slip out even more easily?
14:33:03 <McManiaC> where can I see the stats on garbage collection etc on the RTS?
14:38:16 <Cale> McManiaC: See  ./foo +RTS -h  for help
14:38:35 <Cale> There's -t, -s and -S
14:38:46 <Cale> depending on how much detail you want
14:39:39 <McManiaC> hmmhm
14:39:59 <McManiaC> my programm is running out of memory at 2gb ram usage and I dont get any rts information at all
14:40:29 <pumpkin> @tell ezyang I fixed all the hoopl tests/sample code if you're interested
14:40:29 <lambdabot> Consider it noted.
14:40:59 <ezyang> pumpkin: Ooh, did you get the Darcs pull to work? 
14:40:59 <lambdabot> ezyang: You have 2 new messages. '/msg lambdabot @messages' to read them.
14:41:03 <ezyang> @messages 
14:41:03 <lambdabot> pumpkin said 2h 42m 51s ago: just running darcs get on that URL gives a failure for me. Does it not for you? I get "Couldn't fetch `0000003609-361f0c2d7b7d50d0e898a35bd0928977210cc1045e7a0ef8851e17629
14:41:03 <lambdabot> 2e84cab'" and I think lispy did too. Not sure what's wrong, but --lazy seems to work
14:41:03 <lambdabot> pumpkin said 34s ago: I fixed all the hoopl tests/sample code if you're interested
14:41:17 <pumpkin> ezyang: nope, except for --lazy :)
14:41:19 <ezyang> Oh! 
14:41:26 <ezyang> That's because the original repo was lazy. Ups. 
14:41:36 <lispy> ezyang: ah!
14:41:45 <lispy> ezyang: 'darcs put' might be your friend in the future.
14:41:47 <ezyang> Ok, I guess I can un-lazify it and then rsync again. 
14:41:50 <ezyang> Or that :-) 
14:42:00 <lispy> ezyang: TBH, I've never tried to put a lazy repo somewhere.
14:43:32 <ezyang> Norman Ramsey said that he would merge in my Darcs patch for me; if he doesn't do it by the end of my vacation, I guess I'll do it myself. 
14:43:57 <pumpkin> is anyone still working on the original hoopl?
14:44:13 <pumpkin> there's still lots to be done
14:44:20 <pumpkin> maybe I'll write some documentation for it at some point
14:44:54 <ezyang> The webpage claims that hoopls is moving fast :-) 
14:45:07 <ezyang> Maybe they're taking a break and working on other projects. 
14:45:49 <pumpkin> ah :/
14:46:04 <pumpkin> ezyang: when are you coming back by the way?
14:46:56 <ezyang> Mid-January 
14:47:02 <pumpkin> ah cool
14:55:51 <McManiaC> is there something like "iterate" which doesn't build up a list?
14:56:16 <mauke> fix
14:57:08 <McManiaC> hm not sure how to use that
14:57:27 <pumpkin> McManiaC: the ffix function I defined the other day?
14:57:29 <pumpkin> :t ffix
14:57:30 <lambdabot> Not in scope: `ffix'
14:58:04 <pumpkin> @let ffix f x = let x' = f x in if x' == x then x' else ffix f x'
14:58:05 <lambdabot>  Defined.
14:58:07 <pumpkin> :t ffix
14:58:08 <lambdabot> forall a. (Eq a) => (a -> a) -> a -> a
14:58:21 <pumpkin> > ffix cos 5
14:58:22 <lambdabot>   0.7390851332151607
14:58:55 <pumpkin> should probably be strictified too
14:59:32 <McManiaC> well, I'm trying to run this function: http://npaste.de/t1/ and I'm trying to run this 10^8 times - but GHC currently takes up almost 1gb of ram
14:59:47 <McManiaC> with iterate x_n x0 !! (10^8)
15:01:34 <c_wraith> McManiaC, you really want a strict version of iterate
15:01:41 <McManiaC> yeah
15:01:48 <c_wraith> The list is fine.
15:01:51 <McManiaC> I already tried to make x_n strict with that bangpattern
15:01:57 <c_wraith> not relevant.
15:02:01 <McManiaC> ok
15:02:12 <c_wraith> you need to write your own version of iterate.
15:02:21 <c_wraith> Fortunately, that's actually pretty easy. :)
15:02:40 <McManiaC> would data.sequence be usefull for this?
15:02:43 <c_wraith> no
15:02:56 <c_wraith> Data.Sequence would need to fit in memory entirely
15:03:01 <McManiaC> ok
15:03:09 <c_wraith> a List just is a loop, in this case.
15:04:27 <c_wraith> :t let iterate' f x = x `seq` (x : iterate f (f x)) in iterate'
15:04:28 <lambdabot> forall a. (a -> a) -> a -> [a]
15:04:46 <c_wraith> That's the level of strictness you need, I believe.
15:05:45 <byorgey> McManiaC: what tyoe are you iterating over?
15:05:53 <c_wraith> byorgey, it's Int in his code
15:05:56 <byorgey> *type
15:06:11 <byorgey> oh, right
15:06:38 <McManiaC> it's still using up all my memory and overflows at 2gb ram
15:07:13 <byorgey> x `seq` (x: iterate f (f x))  doesn't help
15:07:40 <McManiaC> oh nevermind
15:07:52 <McManiaC> it's iterate' of course, not iterate again
15:07:53 <McManiaC> :)
15:07:53 <c_wraith> does it need to be let y = f x in y `seq` (x : iterate' f y)
15:07:54 <byorgey> or does it?  I find it hard to reason about seq
15:08:09 <byorgey> in practice, although I know how to reasona bout it in theory.
15:08:12 <McManiaC> stupid copy & paste
15:08:13 <byorgey> maybe I just need more practice.
15:08:14 <c_wraith> err, yes, making that iterate' would help
15:08:15 <McManiaC> now it works fine
15:08:16 <McManiaC> thanks
15:08:19 <byorgey> hehe =)
15:08:19 <c_wraith> that was my typo, sorry :)
15:08:33 <c_wraith> I think both work
15:08:42 <c_wraith> It's just a matter of when each value is forced
15:08:54 <byorgey> c_wraith: yes, I think you're right
15:11:09 <McManiaC> A38.exe: out of memory
15:11:12 <McManiaC> doesn't work yet :)
15:11:33 <medfly> .exe?
15:11:52 <McManiaC> some people use windows :P
15:14:30 <McManiaC> ok next - how can I save this into a file? http://npaste.de/t2/
15:14:44 <McManiaC> the u/x function is working - but the list still gets huuuuuuuuge
15:15:45 <McManiaC> the file itself should have a couple of kb of size
15:16:17 <McManiaC> do I want a lazy list here? :)
15:16:20 <monochrom> methinks pretty ((x,y):rest) = printf "%f %f\n" x y ++ pretty rest
15:17:06 <McManiaC> oh lol
15:17:07 <McManiaC> thanks :D
15:17:32 <McManiaC> oh wow
15:17:33 <McManiaC> :D
15:18:00 <McManiaC> now it runs smoooooooooooth
15:18:02 <McManiaC> :)
15:18:06 <McManiaC> feels almost like C ;)
15:19:36 <monochrom> well, sprintf("%f %f\n%s", x, y, pretty(rest)) in C would not be very successful either.
15:20:00 <McManiaC> yeah indeed
15:20:14 <McManiaC> no idea why I used recursion on that one
15:27:39 <McManiaC>   MUT   time  304.89s  (310.29s elapsed)
15:27:40 <McManiaC>   GC    time    3.20s  (  3.67s elapsed)
15:27:45 <McManiaC> pretty much okay I guess
15:27:46 <ddarius> monochrom's definition is still recursive.
15:27:56 <McManiaC> what exactly is MUT?
15:30:12 <Saizan_> time spent doing evaluation
15:30:23 <Heffalump> short for Mutator
15:30:27 <McManiaC> I see
15:30:35 <Heffalump> which is the garbage collection terminology for "thing doing the work"
15:30:57 <ddarius> I thought it was GC terminology for "the thing messing everything up"
15:30:58 <Heffalump> There's definitely a whiff of "if that pesky user code wasn't running this garbage collection would work much better" in the term :-)
15:32:00 <McManiaC> sweet
15:32:07 <McManiaC> pretty minor changes and everything runs smooth
15:32:15 <McManiaC> GC looks good, output looks even greater
15:37:20 <McManiaC> http://n-sch.de/m10000-1.png <- output
15:37:21 <McManiaC> :D
15:37:53 <lispy> http://corp.galois.com/blog/2010/12/20/cabal-dev-sandboxed-development-builds-for-haskell.html
15:37:59 <ddarius> That isn't nearly shiny enough.
15:39:07 <McManiaC> :D
15:44:08 <allbery_b> actually I think that makes 3 tools (pkg_env)
15:50:56 <argiopeweb> Okay, bit of weirdness here. I'm using hxt-xpath to parse a test html file and output it to a file. Quick, easy, 3 lines plus 2 imports.  When I load it up in GHCi and manually run main, no issues. If I compile it with "ghc Main.hs -o parser", I get a slew of undefined reference errors. Any ideas?
15:55:26 <argiopeweb> And the list is here: http://hpaste.org/42454/linker_reference_errors
15:56:10 <ddarius> Use --make
15:56:21 <ddarius> Just always use --make when you compile.
15:56:40 <lispy> allbery_b: pkg_env?
15:57:17 <argiopeweb> ddarius: Forces a library search I'm guessing? It worked beautifully.
16:02:41 <jmcarthur> argiopeweb: ghc 7 now defaults to --make, btw :)
16:04:29 <argiopeweb> jmcarthur: Ah, beautiful... More reasons for me to get around to upgrading. ;)
16:10:34 <allbery_b> @go haskell pkg_env
16:10:34 <lambdabot> Maybe you meant: google googleit do
16:10:40 <allbery_b> @goog haskell pkg_env
16:10:40 <lambdabot> Maybe you meant: google googleit
16:10:43 <allbery_b> bah
16:10:48 <allbery_b> @google haskell pkg_env
16:10:49 <lambdabot> No Result Found.
16:10:56 <allbery_b> hm, where'd it go, I had it bookmarked
16:11:22 <allbery_b> oh.  http://www.mail-archive.com/haskell-cafe@haskell.org/msg54520.html
16:20:02 <argiopeweb> Okay, new problem at http://hpaste.org/42455/memory_issues. Memory usage is out the roof. I'm parsing a ~316mb file and it's eating all available ram (~4gb) before the OS kills it.  It seems a bit contrary to lazy evaluation. Any idea why/how to fix it?
16:21:54 <beastaugh> readFile uses lazy IO
16:22:06 <Saizan_> are you sure xread is the right thing?
16:23:28 <argiopeweb> beastaugh: I've got lazy IO with readFile, I assume the XML parsing functions aren't strict, and the use of head should severely limit how much of the file is actually necessary to parse.
16:24:05 <beastaugh> my point was more that lazy I/O is not necessarily what you want
16:24:19 <argiopeweb> Saizan_: I believe so. Parses a string into a set of XML trees.
16:24:24 <c_wraith> the xml parsing functions could be strict, if the parser decides it wants to find a </xml> tag before it returns a result.  For the sake of error checking, for instance
16:24:48 <argiopeweb> c_wraith: Hmm, good point. I'll check the docs.
16:27:26 <argiopeweb> beastaugh: Could it benefit me to change it to non-lazy?  I wouldn't know whether the massive ram usage would caused by the xml library or the lazy reading, or whether the lazy IO would tend to complicate it.
16:28:36 <Saizan_> lazy I/O shouldn't cause more memory use
16:28:52 <Saizan_> String is not a memory efficient way to store text though
16:29:09 <argiopeweb> True true. I could drop to bytestring.
16:33:29 <conal> does anyone know how to access the #haskell logs with unicode chars intact? 
16:34:41 <mtnviewmark> sample date w/non-ascii chars
16:35:13 <mtnviewmark> ("unicode chars" -> they're ALL Unicode chars - even a, b and c!)
16:36:36 <mtnviewmark> (oh - it's VERY live so: ∀ ∃ ∞ ☮ €
16:36:57 <mtnviewmark> conal: http://tunes.org/~nef/logs/haskell/10.12.20 just works for me!
16:37:28 <conal> mtnviewmark: you don't see non-ascii chars replaced by pairs & triples?
16:37:34 <monochrom> It is already in UTF-8
16:37:38 <mtnviewmark> no - I see the characters
16:37:46 <mtnviewmark> but inspecting the headers returned by the web site
16:37:55 <conal> hm. in firefox, i lose the non-ascii chars
16:37:56 <unkanon> I see garbage:
16:37:56 <unkanon> 01:53:40 <adu> ãŒã‚“ã°ã£ã¦
16:37:59 <mtnviewmark> reveals:   Content-Type:text/plain
16:38:11 <c_wraith> ah.  so if your browser defaults to utf8, it works
16:38:13 <benmachine> I see the non-ascii characters in firefox fine
16:38:15 <mtnviewmark> so, the web site isn't returning the proper content type
16:38:25 <conal> mtnviewmark: right. it's not html
16:38:28 <c_wraith> technically, utf8 isn't correct for IRC logs
16:38:43 <c_wraith> irc has no defined encoding
16:38:56 <c_wraith> and some clients send different encodings than others
16:39:01 <mtnviewmark> corrent - it should be returning     Content-Type: text/plain;charset=UTF-8
16:39:12 <c_wraith> mtnviewmark, I disagree with that "should"
16:39:14 <mtnviewmark> IRC has no defined encoding, but we all seem to use UTF-8 here
16:39:30 <c_wraith> in any case, tell your browser it's utf8
16:39:34 <c_wraith> and it'll work
16:39:38 <mtnviewmark> c_wraith - remember that text/plain doesn't mean "encoding unknown", it defaults to "ISO-8859-1"
16:39:41 <c_wraith> most of the time
16:39:51 <monochrom> header is "Content-Type: text/plain". some default behaviours may apply
16:39:56 <c_wraith> really, it needs a "mixed encoding, you're on your own"
16:40:11 * ddarius will need to find Ogg and FLAC codecs for Windows Media Player.
16:40:31 <mtnviewmark> no such MIME Type parameter exists --- text/plain in MIME always has a charset
16:40:59 <mtnviewmark> anyhow - if you know you're mirroring logs of #haskell - I'd think charset=UTF-8 would be pretty safe, and work
16:41:22 <monochrom> slurp it into a bytestring and then do UTF-8 decoding :)
16:41:50 <unkanon> just change the encoding in firefox to utf8:  01:53:40 <adu> がんばって
16:41:58 <monochrom> yeah
16:42:06 <mtnviewmark> Or just use the browser menu:  View > Encoding > UTF-8
16:42:22 <monochrom> somehow my firefox chooses UTF-8 for this
16:42:23 <djahandarie> ada says 'Good luck'
16:42:26 <djahandarie> adu
16:42:35 * djahandarie lays off the booze
16:42:53 <monochrom> Ada says "good luck" to all programmer nerds! :)
16:44:12 <conal> mtnviewmark: thx. view/encoding/utf-8 works for me.  
16:44:24 <mtnviewmark> woot
16:50:34 <unkanon> is there a clever way I can transform elemIndices so that it's now [a] -> [a] -> Int instead of
16:50:37 <unkanon> :t elemIndices
16:50:38 <lambdabot> forall a. (Eq a) => a -> [a] -> [Int]
16:51:24 <roconnor> :elemIndex
16:51:27 <roconnor> :t elemIndex
16:51:28 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
16:51:48 <roconnor> unkanon: your type makes no sense
16:52:05 <unkanon> why?
16:52:12 <unkanon> I want to see if a substring exists
16:52:26 <djahandarie> If you actually want to transform elemIndices to elemIndex, use can use listToMaybe
16:52:34 <mm_freak_> :t (null .) . elemIndices
16:52:35 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
16:52:41 <djahandarie> But it seems you want to do something else
16:52:46 <mm_freak_> but of course there is also:
16:52:48 <unkanon> I don't want to transform elemIndices to elemIndex..
16:52:52 <mm_freak_> :t isInfixOf
16:52:53 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
16:53:05 <djahandarie> unkanon, go use Data.List.Split
16:53:16 <unkanon> I want to do: doesThisStringHave "fox" "the quick brown fox..." -> [Int]
16:53:27 <unkanon> I need the position
16:53:27 <mm_freak_> > "blah" `isInfixOf` "halablahahaha"
16:53:28 <lambdabot>   True
16:53:37 <unkanon> yes I'm aware of that :)
16:53:39 <mm_freak_> then better don't use lists at all
16:53:55 <mm_freak_> because lists are bad at random access
16:54:18 <unkanon> ok, then what do you recommend so I can make a function that finds the position of "fox" inside "the quick brown fox..."?
16:54:22 <mm_freak_> try Data.Text for text or Vector for other element types
16:54:46 <mm_freak_> the corresponding packages are 'text' and 'vector'
16:54:58 <benmachine> mm_freak_: that sounds a bit like overkill to me
16:55:00 <benmachine> I mean
16:55:21 <benmachine> in principle it makes sense but I'm inclined to think a small question should have a small answer :P
16:55:32 <benmachine> I think Data.List.Split was good advice
16:55:34 <unkanon> djahandarie: which function from Split do you think would help me? they all seem to do with splitting which I can't really do
16:55:34 <mm_freak_> that is a small answer, isn't it?
16:55:51 <roconnor> @type \a b -> findIndex (a `isPrefixOf`) (tails b)
16:55:51 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Maybe Int
16:55:58 <roconnor> ^^ not efficent
16:56:06 <mm_freak_> after all i've never written a single useful haskell program, which gets along without any other dependencies than "base" =)
16:56:24 <roconnor> > (\a b -> findIndex (a `isPrefixOf`) (tails b)) "fox" "the quick brown fox..."
16:56:25 <lambdabot>   Just 16
16:56:27 <mm_freak_> unkanon: anyway, you can also easily write this function yourself
16:57:14 <unkanon> @type \a b -> findIndices (a `isPrefixOf`) (tails b)
16:57:15 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [Int]
16:57:18 <revenantphx> So guys,what are your favorite languages to write in (e.g. most fun) other than Haskell?
16:57:31 <benmachine> revenantphx: is that a trick question :P
16:57:32 <roconnor> revenantphx: agda
16:57:35 <roconnor> revenantphx: coq
16:57:37 <revenantphx> no benmachine 
16:57:41 <unkanon> (\a b -> findIndices (a `isPrefixOf`) (tails b)) "the quick brown fox jumps over the lazy dog"
16:57:45 <dons> revenantphx: research extensions to haskell?
16:57:51 <benmachine> hee hee
16:57:52 <roconnor> unkanon: use > to eval
16:57:56 <unkanon> > (\a b -> findIndices (a `isPrefixOf`) (tails b)) "the" "the quick brown fox jumps over the lazy dog"
16:57:56 <lambdabot>   [0,31]
16:57:57 <benmachine> it begets trick answers though >_>
16:58:01 <unkanon> right, being silly here
16:58:05 <revenantphx> dons... I've seen your name before!
16:58:09 <revenantphx> I know who you are ^_^
16:58:15 <revenantphx> You're the guy who wrote the pony package.
16:58:20 <benmachine> haha
16:58:24 <mm_freak_> > let infixIndex is = length . takeWhile id . map (not . isPrefixOf is) . tails in infixIndex "blah" "halablahahahah"
16:58:25 <lambdabot>   4
16:58:26 <revenantphx> (or rather, didn't)
16:58:31 <benmachine> that is his greatest service to the haskell community, yes
16:58:39 <benmachine> but it gives you a unicorn :(
16:58:41 * benmachine felt betrayed
16:58:45 <mm_freak_> @ unkanon 
16:58:51 <unkanon> mm_freak_: yes
16:58:52 <revenantphx> Yeah I know, I felt like I'd been gypped.
16:59:13 <unkanon> mm_freak_: but see, even though I really need that function, I thought there should be a pretty way of "lifting" that findIndices function to work with strings
16:59:16 <unkanon> you know?
16:59:29 <revenantphx> Did he do anything else benmachine?
16:59:29 <mm_freak_> yes, but i don't think so
16:59:32 <roconnor> http://twan.home.fmf.nl/blog/haskell/Knuth-Morris-Pratt-in-Haskell.details -- read this if you want to find indices efficently
16:59:33 <revenantphx> I've only seen the pony package.
16:59:50 <benmachine> revenantphx: one or two things
16:59:57 <mm_freak_> unkanon: findIndices cannot be extended to strings easily, unless you want to iterate the list multiple times, which you hopefully don't want to do
17:00:05 <mm_freak_> to substrings, that is
17:00:08 <revenantphx> benmachine: Not anything well known I guess then.
17:00:15 <benmachine> revenantphx: nah
17:00:23 <mm_freak_> but…  one idea…
17:00:47 <unkanon> hmmm
17:01:01 <unkanon> okay before you share your idea
17:01:04 <mm_freak_> > let infixIndex is = length . takeWhile (not . isPrefixOf is) . tails in infixIndex "blah" "halablahahahah"
17:01:05 <lambdabot>   4
17:01:08 <unkanon> let me state the *real* problem then
17:01:09 <mm_freak_> too late =)
17:01:13 <unkanon> lol
17:01:15 <unkanon> anyway
17:01:34 <unkanon> I have one file that is 4 gigs + of pure text
17:01:37 <unkanon> it's a small corpus
17:01:43 <unkanon> I need to index ALL of its words
17:01:54 <unkanon> so I guess I can't really use "tails"  :P
17:02:03 <mm_freak_> not to interrupt you, but in that case you really don't want to use lists anyway
17:02:07 <mm_freak_> sure you can
17:02:18 <unkanon> you didn't interrupt me, I'm done describing the problem :)
17:02:20 <mm_freak_> that function should have linear time complexity and run in constant space i believe
17:02:32 <mm_freak_> but anyway, you still don't want to use lists
17:02:43 <mm_freak_> use Data.Text or Data.ByteString
17:02:44 <unkanon> it had better, yes, otherwise I'll just drop to C where I could do that the dirty way
17:03:03 <unkanon> okay so I'll use Data.ByteString but then do I use that same function?
17:03:04 <mm_freak_> or use iteratee/enumerator
17:03:12 <mm_freak_> almost, yes
17:03:28 <mm_freak_> using the lazy variant you can use that function as it is
17:03:49 <mm_freak_> but that's not really what you want to do, because it would require O(n) lookup for /each/ word
17:03:53 <unkanon> that's crazy powerful
17:04:01 <mm_freak_> instead of one single O(n) lookup for all words at once
17:04:12 <mm_freak_> i would use the enumerator package
17:04:14 <unkanon> yeah I really need O(n) for all
17:04:44 <Luke> anyone know what the the file is called that keeps track of what cabal packages are installed?
17:04:53 <unkanon> mm_freak_: this? http://hackage.haskell.org/package/enumerator-0.4.0.1
17:05:00 <mm_freak_> yes
17:05:02 <mm_freak_> http://docs.yesodweb.com/blog/enumerators-tutorial-part-1/
17:05:06 <benmachine> Luke: cabal doesn't keep track of packages itself
17:05:13 <mm_freak_> here is a good tutorial, which i found easy to understand
17:05:28 <benmachine> Luke: compilers keep track of installed libraries, but for executables you're on your own
17:05:29 <Luke> benmachine: when I type "cabal info <package>" it will tell me the latest installed version
17:05:40 <Luke> yeah where's it keep track of installed libs
17:05:47 <mm_freak_> Luke: if you use a recent GHC, then look into ~/.ghc/
17:05:50 <Luke> thanks
17:05:50 <benmachine> ghc-pkg list
17:05:55 <Luke> ah awesome
17:05:59 <unkanon> mm_freak_: ok I'll drink up that tute and will let you know. thanks for the help so far
17:06:08 <mm_freak_> unkanon: you're welcome
17:06:11 <benmachine> will not only list all installed libraries (whether by cabal or otherwise) but tell you where the pkgfiles are
17:09:07 <mm_freak_> unkanon: keep reading the tutorial, but just as a hint, when you're done…  your function should have a type signature like this:
17:09:30 <mm_freak_> wordIndices :: Monad m => Integer -> Iteratee Text m (Map Text Integer)
17:09:49 <mm_freak_> (or ByteString instead of Text, if you don't care about charset)
17:09:54 <unkanon> hmm that's pretty scary
17:10:02 <unkanon> oh I care abut charset
17:10:11 <mm_freak_> don't worry, it's much easier than it sounds
17:10:28 <mm_freak_> the tutorial will teach you what everything means
17:10:45 <mm_freak_> and the argument to the function is simply the starting index
17:10:55 <unkanon> I only believe you when you say it's easy because you said you never wrote a program that uses more than base as a dep :)
17:12:06 <djahandarie> You're trying too hard if you only use base ;)
17:12:10 <djahandarie> Or doing something magical
17:12:11 <mm_freak_> well, in haskell the 'base' package is more like a 'bare minimum' package ;)
17:12:34 <mm_freak_> even if you want only date handling or filepaths you already need additional packages
17:13:34 <largos> sm: lispy passed on your question about cabal-dev
17:13:55 <sm> hi largos 
17:14:31 <largos> sm: (which I passed on to Josh :) anyway, you can probably `cabal-dev install --sandbox=<sandbox>` darcs to skip the sdist step
17:15:05 <largos> (that is, run the `cabal-dev install --sandbox=sandbox` command within the darcs source tree)
17:15:05 <sm> largos: thanks, what's <sandbox> ? the cabal-dev dir or the source dir to add ?
17:15:15 <largos> sm: the cabal-dev dir
17:15:36 <largos> sm: you can call it whatever you want, as long as you're consistent :)
17:15:56 <largos> it's not quite the same as add-source though
17:16:08 <sm> great, thanks for the tips
17:16:11 <largos> the dependency resolution is slightly different
17:16:25 <sm> do you know what's missing from capri, that this does better ?
17:17:11 <largos> sm: I haven't used capri much -- the projects I've tried it on didn't compile after following the steps in the capri documentation
17:17:45 <largos> sm: we actually rolled out cabal-dev *right* before capri was announced -- there may have been a week between when we started using cabal-dev and the announcement
17:17:48 <sm> I see. I remember it had some documented limitations, but forget what
17:17:53 <sm> aha
17:18:36 <sm> largos: are you the main developer ?
17:18:58 <largos> sm: Josh did the bulk of the programming (I'm Rogan, btw.)
17:19:26 <sm> hi.. well, thanks!
17:19:27 <largos> I think he and I are probably going to be doing joint maintenance 
17:19:37 <sm> yay, maintenance too
17:19:42 <largos> sm: you're welcome!
17:21:42 <largos> sm: we'd love bug reports / patches if/when you find them :)
17:22:06 <danderson> whoa, cabal-dev, shiny!
17:22:12 <Saizan_>  /win 15
17:22:46 <sm> right o
17:22:47 <revenantphx> :t (^)
17:22:47 <revenantphx> :t (**)
17:22:48 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
17:22:48 <lambdabot> forall a. (Floating a) => a -> a -> a
17:23:02 <revenantphx> mmk.
17:24:35 <monochrom> (**) is an exp-log deal and so requires Floating
17:25:14 <Bynbo7> danderson: indeed :)
17:25:42 <monochrom> (^) is for x^(non-neg integer here) and enjoys the binary exponentiation algorithm and so requires Integral for the exponent
17:25:49 <monochrom> And don't forget:
17:25:53 <sm> largos: that worked nicely - I used --sandbox to install darcs into darcsden's sandbox
17:25:56 <monochrom> :t (^^)
17:25:57 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
17:26:02 <Bynbo7> omfg, it's shit like this Cabal! "cabal: dependencies conflict: ghc-7.0.1 requires containers ==0.3.0.0 however"
17:26:03 <sm> then I did it again with --constraint 'network ==2.3.*' , but I think cabal-dev ignores that
17:26:05 <Bynbo7> containers-0.3.0.0 was excluded because ghc-7.0.1 requires containers
17:26:07 <Bynbo7> ==0.4.0.0
17:26:18 <Bynbo7> what the fucking balls is that?
17:26:27 <sm> ghc-pkg list -f cabal-dev/packages-6.12.1.conf shows just network-2.x in the sandbox
17:26:27 <monochrom> x^^(integer here) may require computing "1/x" and so requires x to be Fractional
17:27:11 <Saizan_> Bynbo7: see the first Cabal FAQ
17:29:24 <adnap> something i often see in my code is multiple maps over lists in succession.  can this be optimized with a fold that does everything at once, or will the compiler already optimize my maps?
17:30:23 <allbery_b> I think there's already a rule that converts map a . map b to map (a . b)
17:30:26 <Saizan_> oftehn the latter
17:30:29 <lispy> adnap: It's called fusion
17:30:38 <allbery_b> yeh
17:30:46 <largos> sm: ah, glad the first bit worked.. just a sec. on the flags, you should be able to pass that contsraint on through
17:30:49 <c_wraith> Oh, right, it's multiple folds that don't fuse
17:30:54 <Bynbo7> thanks Saizan_ 
17:31:02 <c_wraith> see the fun avg ls = sum ls / length ls
17:31:05 * Bynbo7 still hates that this sort of thing is possible
17:31:08 <lispy> adnap: http://stackoverflow.com/questions/578063/what-is-haskells-stream-fusion
17:31:35 <adnap> wait, maybe that's not right.  i'm not able to use function composition in these cases.
17:31:37 <largos> sm: heh, our documentation is slightly lacking.  There is a --flags flag
17:32:08 <Saizan_> adnap: it works regardless of (.)
17:32:10 <adnap> no, here's an example, but it doesn
17:32:18 <adnap> it doesn't involve two maps
17:32:31 <sm> largos: cabal-dev install --sandbox ../darcsden/cabal-dev/ --flags constraint='network ==2.3.*' ?
17:33:07 <adnap> let's say i have a list of lists, where each inner list is a list of three elements (e.g. [[1,1,1],[2,2,2],[3,3,3]])
17:33:20 <sm> hm, that's still building network 2.2
17:33:34 <adnap> the goal is to have ([1,2,3],[1,2,3],[1,2,3])
17:33:34 <largos> sm: just a sec. I'm poking around... 
17:33:35 <sm> oh well, I can wait for these details to emerge
17:33:44 <adnap> i could do this:
17:34:03 <allbery_b> in any given case you can use ghc --dump-simpl (or see the ghc-core package on hackage) to see what ghc does with your code; it's uysually not too hard to figure out the basics of whats going on
17:34:06 <Saizan_> pastebin if it's long
17:34:32 <adnap> > unzip3 $ map (\[x,y,z] -> (x,y,z)) [[1,1,1],[2,2,2],[3,3,3]]
17:34:33 <lambdabot>   ([1,2,3],[1,2,3],[1,2,3])
17:34:40 <adnap> or i could do it all with one fold
17:34:41 <allbery_b> (core is a sort of "austere Haskell" with various things already translated and most code simplications performed (that's the "simpl")))
17:35:44 <Saizan_> adnap: list fusion applies to quite a lot of functions from Data.List, not just map, so it's likely that the intermediate list is never built, but see allbery_b's comment about chekcing what ghc is doing with your code
17:35:59 <adnap> okay
17:37:28 <largos> sm: well, the --flags flag was a red herring, sorry about that.
17:37:30 <lispy> adnap: and criterion + progression make a nice way to see if you're code is getting faster
17:37:39 <adnap> that normal ramsey is always answering haskell questions on stackoverflow :)
17:37:42 <adnap> *norman
17:37:56 <adnap> lispy: i don't know what that means
17:38:12 <adnap> allbery_b: thanks for the tip
17:38:14 <lispy> adnap: -Cafe is getting harder to follow.  I'm using stackoverflow more for that sort of thing too.
17:38:39 <adnap> lispy: can you explain what you mean by criterion + progression?
17:39:00 <largos> sm: this works:
17:39:07 <largos> sm: cabal-dev install network --constraint 'network ==2.2.*'
17:39:19 <largos> (or with 2.3, depending on which ver. you want)
17:39:28 <lispy> adnap: criterion is a statistically micro benchmarking library.  You use it to time micro benchmarks.  progression is a library that creates graphs from criterion times to help you see the "progression" of changes to performance.  Criterion can also make graphs natively on some systems (linux?)
17:39:31 <allbery_b> they're benchmarking packages oin hackage
17:39:42 <sm> largos: oh.. install the specific package that the constraint is on ?
17:40:11 <largos> sm: that's the closest I've been able to come to reproducing what you're doing.  
17:40:19 <adnap> lispy: oh, no wonder i didn't understand you.  i'm not familiar with those libraries.  i actually thought you were using buzzwords. XD
17:40:20 <largos> sm: what package are you working in?
17:40:32 <largos> sm: there may be something in the cabal file that would help
17:42:16 <lispy> adnap: you need an enterprise collaborative solution to leverage so that you can build solutions for your customers with synergistic cloud aspects.
17:42:29 <sm> largos: I'm currently in the darcs dir, where cabal-dev install --sandbox ../darcsden/cabal-dev --flags constraint='network ==2.3.*' --dry-run -v shows it selecting network 2.2
17:42:43 <largos> sm: thanks!
17:43:08 <lispy> adnap: cloud source your list operations! (okay now I'm using buzzwords)
17:43:13 <sm> but cabal-dev install --sandbox ../darcsden/cabal-dev network-2.3 --dry-run -v is doing the right thing
17:43:17 <lispy> adnap: er, I meant crowd sounce
17:43:19 <lispy> source*
17:43:50 <largos> sm: can you run with --verbose=3 and see what the cabal invocation looks like?
17:44:10 <largos> (and/or capture all the output and paste it)
17:45:13 <ddarius> Crowd sourcing an algorithm, i.e. the actual computation of an algorithm not the computational power for the algorithm, would be interesting.
17:45:20 <largos> sm: is that command line verbatim? (the constraint looks like it's missing some leading -'s)
17:45:32 * sm is looking for an easily installed, reliable gist paste script
17:45:35 <Saizan_> sm: sounds like a quoting bug, try with --constraint=network==2.3.*
17:46:08 <sm> largos: oh probably, that was just my guess at how --flags might work
17:46:20 <sm> I did it before without --flags, let's try that
17:46:24 <largos> sm: ah, ok.  you can take --flags out... that way my mistake.
17:46:59 <sm> I'm *reasonably* sure those quotes are fine, but will check
17:47:31 <ddarius> Bah, just make a proxy that spoofs hackage.haskell.org.
17:47:58 <sm> the situation is complicated by having just installed network-2.3
17:48:47 <Saizan_> make it more evident: use an impossible to satisfy constraint
17:49:15 * sm unregisters that.. cool
17:49:37 <largos> sm: hm... was it installed in the global package db?
17:49:57 <sm> largos: no, it's not
17:50:48 <largos> sm: ok, good.  the global db is much harder to control, so it's still shared across projects with cabal-dev
17:51:31 <sm> Saizan_: good tip
17:53:11 <largos> it does look like the constraint is passing through to cabal (network==12 caused it to fail..)
17:53:25 <sm> agreed - install --dry-run --constraint network==2.4 fails with "no such version", so that looks good
17:54:15 <sm> when I go with constraint network=2.3, it says In order, the following would be installed:
17:54:16 <sm> darcs-2.5.0.1 (reinstall) changes: HTTP-4000.0.10 removed, network-2.2.1.10 removed
17:54:19 <largos> sm: when I cabal-dev install darcs, it doesn't actually depend on network, is there a specific version that does?
17:54:34 <sm> but when I let it proceed, I end up with network 2.2. And now I really must get a gist paste script 
17:55:17 <sm> largos: I guess that depends on flag http, which looks true by default, in HEAD at least
17:55:33 <largos> ah, ok.  I'm not on head, which explains that
17:57:59 <largos> sm: how do you configure this with cabal-install?
17:59:32 <largos> sm: ah, n/m, just spaced out on cabal-install usage :)
17:59:41 <sm> ok
17:59:51 <sm> I'm surprised it's different in your darcs
18:00:18 <largos> sm: I'm just working in a 'cabal unpack darcs'
18:00:45 <largos> I can't actually cabal configure, although it *looks* successful, it's returning an error code
18:00:59 <largos> cabal configure -f http --constraint='network==2.3.*' --verbose=3
18:01:24 <largos> hrm.. I suppose I need to install network-2.3.* in my user db though...
18:01:39 <sm> an error code ? 
18:01:53 <largos> yeah, the command returns 127
18:02:12 <largos> but it's just printing "Resolving dependencies..."
18:02:17 <largos> (w/out the verbose flag)
18:02:41 <sm> pshhh.. maybe something like http://hackage.haskell.org/trac/hackage/ticket/777
18:03:12 <sm> anyway, I'm going to test a bit more here and paste results
18:11:45 <Watermind> I'm wondering if there's a specififc notation to denote this
18:12:29 <Watermind> I have an  x ::  forall a. A 
18:12:54 <Watermind> and I want to talk about the values  y :: A[B/a]
18:13:14 <largos> sm: I think you just have to relax the network dependency in the darcs cabal file to get this to work
18:13:27 <Watermind> obtained by substituting values in B for the variables of type a in y
18:13:44 <Watermind> "in x"
18:13:47 <Watermind> not in y
18:13:52 <sm> largos: oh boy.. I'm sorry, I've run out of time and steam here.. going to leave it for now
18:15:06 <largos> sm: keep us posted -- I'm not often in irc, but feel free to email as much as you want :) (our addresses are in the cabal file)
18:15:18 <Saizan_> Watermind: leaving those values unspecified?
18:16:03 <sm> thanks
18:16:13 <Watermind> Saizan_: well I want the set generated by all possible instantiations of those values
18:16:25 <Saizan_> i'm not aware of a notation for that, anyway
18:16:45 <Watermind> so for intance, for    x ::  (a,Int,b)     x=(z1,4,z2) and instanciation  (Int, Int, Char)  I'd want to talk about all the set  { (n,4 c) | n :: Int, c::Char}
18:17:20 <Watermind> well actually simpler than that since I only need one type variable
18:18:57 <Saizan_> you could restrict your x to be a closed term, and its type of the form forall a. a -> a -> .. -> B, and the set would just be the image
18:20:48 <Watermind> true... smart move, can't use it here though... this is related to haskell but not exactly haskell
18:21:34 <Watermind> was thinking of some sort of matemathical notation to denote all possible syntactic substitutions
18:23:09 <Watermind> brb
18:31:08 <benmachine> dang it
18:31:19 <benmachine> CPP ruins analysis tools
18:32:49 * benmachine is trying to run SourceGraph on stuff
18:41:05 * hackagebot yesod-paginate 0.0 - Pagination for Yesod sites.  http://hackage.haskell.org/package/yesod-paginate-0.0 (AlexanderDunlap)
18:41:56 <benmachine> :q
18:42:01 <benmachine> ...
18:42:03 <benmachine> you saw nothing
18:42:17 <c_wraith> So, just to double-check that I'm not about to do something dumb, Any and unsafeCoerce are precisely for the case where you know something is type safe, but can't convince ghc of that, right?
18:42:44 <benmachine> yeah, that sounds about right
18:42:48 <allbery_b> yes
18:43:10 <allbery_b> although usually the better solution there is cast instead of unsafeCoerce directly, IIRC
18:43:25 <c_wraith> with Data.Dynamic?
18:43:30 <c_wraith> That isn't what I need. :)
19:19:48 <roconnor> the only safe non-trivial use of unsafeCoerce that I know if casting a type with type variables to another type with type variables where it is known for other reasons that the two types will always be the same when instantiated
19:26:09 <c_wraith> roconnor, I'm going to be using unsafeCoerce as a -> Any and Any -> a
19:26:51 <roconnor> c_wraith: That, in general, isn't going to be safe.
19:26:57 <c_wraith> well, it's the same a
19:27:11 <roconnor> for exampel a -> () and () -> a definitely isn't safe (from experience)
19:27:11 <c_wraith> I'm pretty sure unsafeCoerce explicitly says that is safe
19:27:20 <c_wraith> No, Any.  not ()
19:27:52 <roconnor> sure, due to the special properties of Any it is plausible that it will be safe, but you didn't mention "Any" in your question.
19:28:27 <c_wraith> "So, just to double-check that I'm not about to do something dumb, Any and unsafeCoerce are precisely for the case where you know something is type safe, but can't convince ghc of that, right?"
19:28:45 <c_wraith> "I'm going to be using unsafeCoerce as a -> Any and Any -> a"
19:28:52 <revenantphx> hm
19:28:53 <c_wraith> I really was quite specific on that. :)
19:29:00 <revenantphx> I was going to use this while reading through HSoE (http://hackage.haskell.org/packages/archive/HGL/3.2.0.2/doc/html/Graphics-SOE.html)
19:29:09 <revenantphx> but it seems I can't because it's looking for an x11 dylib
19:29:14 <revenantphx> while X11 is in a framework.
19:29:18 <revenantphx> Is my only choice to symlink it?
19:31:09 <monochrom> is that on Mac?
19:31:28 <revenantphx> Yes.
19:32:31 <pastorn> c_wraith: yes... i once used it for OpenGL
19:33:07 <revenantphx> libx11.dylib actually lives in usr/bin/x11/lib/
19:33:09 <revenantphx> my bad.
19:33:12 <pastorn> c_wraith: there was a funcition getCurrentMatrix :: IO GlMatrix, but the constructor for that type wasn't exported, and i really needed that data
19:33:52 <pastorn> so i made my own 'newtype MyGlMatrix = MGM Vector4 (Vector4 Glfloat)' and then just unsafeCoerced into my own type
19:34:03 <revenantphx> monochrom: any ideas?
19:34:10 <monochrom> I don't know Mac.
19:34:26 <pastorn> roconnor: ^^^ 
19:34:54 <revenantphx> whats the thing... to specity a custom main metho
19:35:07 <pastorn> revenantphx: "custom"?
19:35:15 <revenantphx> I mean, something other than "main"
19:35:30 <pastorn> you declare a function and call it?
19:35:37 <revenantphx> no, when compiling.
19:36:02 <pastorn> oh, you want $ORIG or whatever you wanna call it to point to something else than main
19:36:09 <pastorn> "main"
19:36:13 <revenantphx> no.. that's not it.
19:36:19 <revenantphx> to ghc, there was a flag.
19:36:20 <roconnor> pastorn: sounds safe, but immoral
19:36:23 <revenantphx> as-main, something like that.
19:36:32 <ManateeLazyCat> Do you like the idea "User change haskell script by Cabal" ?
19:36:33 <pastorn> roconnor: it was immoral of the library builder to not give me the data
19:37:01 <roconnor> pastorn: no, it's call data abstraction, modularity, and/or information hiding.
19:37:24 <pastorn> roconnor: i needed that information for my shaders... had this been C i would have had no problem extracting that data
19:37:30 <ManateeLazyCat> Every time, user change configure file, then use "cabal install" update the running system.
19:37:44 <revenantphx> Even weirder monochrom, it compiles fine
19:37:48 <revenantphx> ghci just won't load the package.
19:37:50 <dibblego> does Alan Zimmerman hang around these parts?
19:37:55 <roconnor> pastorn: which library?
19:38:04 <pastorn> roconnor: OpenGl (not -Raw)
19:38:06 <monochrom> -main-is?
19:38:21 <revenantphx> monochrom: that's it.
19:38:22 <revenantphx> anyways.
19:38:42 <roconnor> pastorn: http://hackage.haskell.org/package/OpenGL  ?
19:39:07 <revenantphx> DYLD_LIBRARY_PATH=/usr/X11R6/lib ghci myfile.hs
19:39:08 <revenantphx> that works
19:39:17 <revenantphx> but having to screw with dyld is a bit unpleasant.
19:39:45 <revenantphx> It's the goddamn x11 package, they can;t fix that >_>
19:39:46 * roconnor didn't find getCurrentMatrix
19:39:55 <roconnor> Hayoo also doesn't find getCurrentMatrix
19:40:29 <pastorn> roconnor: http://hackage.haskell.org/packages/archive/OpenGL/latest/doc/html/Graphics-Rendering-OpenGL-GL-CoordTrans.html it was 'currentMatrix' iirc
19:40:51 <pastorn> and the only instance of Matrix is GLmatrix
19:42:52 <roconnor> pastorn: getMatrixComponents composed with get composed with currentMatrix seems like it would get the represeneation.
19:43:20 <pastorn> i don't remember the details
19:43:28 <pastorn> this was like 7 months ago...
19:43:37 <pastorn> anyway, unsafeCoerce rescued me
19:44:25 <revenantphx> Now where can i find this "Spencer Janssen"
19:44:31 <revenantphx> And tell him to _FIX IT_
19:44:52 <roconnor> pastorn: it makes your code fragile and defeats modularity and keeps you employed
19:45:15 <pastorn> revenantphx: download the source, fix it yourself and send him the patch
19:45:21 <revenantphx> Good plan.
19:45:30 <pastorn> roconnor: and the last part is bad *how* exactly?
19:45:49 <roconnor> pastorn: it is the silver lining
19:46:06 <pastorn> also: this was for a school hand-in
19:47:26 <revenantphx> I'm not sure what exactly is doing the dlopen >_>
19:47:42 <revenantphx> plain text search of the cabal package reveals its never called directly.
19:48:04 <dankna> who's dlopening what?
19:48:18 <revenantphx> the X11 package is dlopening libx11.dylib
19:48:21 <revenantphx> but it fails in ghci
19:48:21 <dankna> hrm
19:48:25 <revenantphx> it *compiles* fine.
19:48:25 <dankna> this is on a Mac of course?
19:48:27 <revenantphx> Yes.
19:48:27 <roconnor> pastorn: in that case it will prevent you from being employed :D
19:48:40 <pastorn> roconnor: haha
19:48:41 <revenantphx> its living in /usr/x11/lib/libx11.dylib
19:48:46 <dankna> yeah, hm
19:48:56 <revenantphx> gonna edit it and stuff
19:48:59 <dankna> never tried it
19:49:02 <pastorn> roconnor: doing shaders without GlRaw is pretty annoying
19:49:09 <revenantphx> any idea where it'd be done?
19:49:16 <dankna> I know that if you use OpenGL on the Mac, you get a library which is a stub that dynamically loads the real one
19:49:23 <pastorn> i.e. you can't push matrices with uniform
19:49:23 <dankna> X11 may work the same way
19:49:42 <revenantphx> The OpenGL.Framework is the real deal I believe.
19:49:44 <revenantphx> No stub there.
19:49:48 <revenantphx> Though it may be.
19:49:56 <revenantphx> X11 has no stub as far as I know
19:50:02 <dankna> yeah, I guess what I meant to say is that ldso or whatever component of the system it is, does the dynamic loading
19:50:08 <revenantphx> libx11.dylib is the dylib itself.
19:50:10 <revenantphx> dyld
19:50:11 <dankna> okay
19:50:14 <pastorn> so doing vertex shaders is a real hassle... had to use primitive mode and the matrix stack for all my rotations :/
19:50:16 <dankna> yes, that :)
19:50:26 <revenantphx> It works if I compile the package, of course >_>
19:50:28 <dankna> right
19:50:30 <dankna> it would
19:50:32 <dankna> hm
19:50:41 <pastorn> well, not primitive mode, i meant the "fixed function" pipeline
19:50:47 <dankna> well, if you get it working, write it up somewhere
19:50:52 <dankna> you can't be the first one to encounter this problem
19:51:05 <revenantphx> Im not.
19:51:20 <revenantphx> The only solution I've seen (which I can say works) is supplying a dyld directive as to where to find it.
19:51:29 <revenantphx> DYLD_LIBRARY_PATH=/usr/X11/lib ghci myfile.hs  
19:51:31 <revenantphx> will work perfectly
19:52:17 <revenantphx> (er... by directive I mean setting a env variable)
19:52:19 <revenantphx> (:P)
19:53:10 <dankna> right hm
19:53:14 <dankna> but shouldn't be necessary
19:53:35 <revenantphx> I agree.
19:55:20 <revenantphx> For some reason, it's not looking in the right places.
19:55:59 <revenantphx> Worst case I edit my DYLD_LIBRARY_PATH
19:56:07 <revenantphx> I don't like doing that though.
19:56:17 <dankna> yeah no kidding
19:57:47 <revenantphx> I don't know where to look or what to fix in the package though.
19:57:48 <revenantphx> :\
20:00:21 <dankna> one thing that occurs to me:  why does it work when compiled?  shouldn't it not find the library then too?
20:00:34 <dankna> maybe the .cabal file specifies the DYLD_LIBRARY_PATH thing
20:00:43 <revenantphx> I really wonder about that.
20:01:05 <revenantphx> only thing I see is extra-libraries:    "X11"
20:01:16 <dankna> hmm
20:01:17 <dankna> okay
20:01:28 <dankna> that just causes -lX11 to be passed
20:01:29 <revenantphx> hey dons is on the copyright list, lets tell him to fix it :)
20:01:38 <dankna> haha :)
20:01:39 <revenantphx> dankna: pretty much.
20:02:39 <revenantphx> The question is, where is ghci looking?
20:03:38 <revenantphx> relevant compile time flags : -lX11 -L/usr/X11/lib -R/usr/X11/lib
20:04:52 <etpace> @hoogle DiffTime -> Double
20:04:52 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
20:04:53 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
20:04:53 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
20:04:53 <dankna> hmm
20:05:18 <dankna> which seems as though it ought to be sufficient
20:05:28 <revenantphx> oh, during compile time that is sufficient
20:05:35 <revenantphx> the issue is that dlopen is looking where it should.
20:05:36 <dankna> oh, right, misread
20:05:51 <revenantphx> http://developer.apple.com/library/mac/#documentation/Darwin/Reference/ManPages/man3/dlopen.3.html
20:05:51 <dankna> what if you start ghci passing -lX11?
20:06:31 <revenantphx> <command line>: user specified .o/.so/.DLL could not be loaded (dlopen(libX11.dylib, 9): image not found)
20:06:32 <revenantphx> Whilst trying to load:  (dynamic) X11
20:06:32 <revenantphx> Additional directories searched: (none)
20:06:37 <revenantphx> adding -v
20:06:46 <revenantphx> no additional details there blah
20:07:09 <dankna> ah
20:07:15 <dankna> ghci -lX11 -L/usr/X11/lib
20:07:17 <dankna> starts okay for me
20:08:05 <revenantphx> well yeah, if you specify the path to look in
20:08:19 <revenantphx> the problem is obviously that its not looking in /usr/X11/lib >_>
20:09:10 <dankna> oh
20:09:14 <dankna> well why would it be though
20:09:18 <dankna> it's not a default place to look
20:09:34 <revenantphx> True >_>
20:09:45 <revenantphx> So is there any way in the cabal file to tell it, that it should look there?
20:09:50 <revenantphx> (however, only if it's on OS X)
20:09:58 <Axman6> /usr/X11 has never been a default place to look on OS X
20:10:17 <revenantphx> it's where it's installed :\
20:10:24 <dankna> cabal isn't used when you launch ghci
20:10:26 <revenantphx> I can symlink it to /usr/bin/lib I suppose
20:10:29 <dankna> cabal clearly knows where to look anyway
20:10:33 <revenantphx> mm.
20:12:29 <revenantphx> hm
20:13:18 <revenantphx> ugh yeah, I symlinked it, but now it cant fins libXext.dylib either
20:13:25 <revenantphx> so that's a bit of a cheap (and bad) solution.
20:13:38 <dankna> hrm yeah
20:14:39 <revenantphx> Rage.
20:14:47 <revenantphx> Graphics.SOE.Gtk fails to install (as an alternative)
20:15:01 <revenantphx> ... then again not having gtk installed could cause that
20:15:30 <revenantphx> oh, but cairo failed too, and glib...
20:15:31 <revenantphx> wonderful
20:16:32 <revenantphx> anyways, got any idea dankna 
20:16:48 <revenantphx> is there a ghci config file where I could add a line telling it to look there?
20:18:57 <revenantphx> Go brew/cabal... eat my CPU like rabid hyenas
20:19:04 <dankna> hmm, there might be?
20:19:09 <dankna> I don't really know, no
20:21:36 <ManateeLazyCat> revenantphx: ghc-pkg check
20:22:02 <revenantphx> theres one issue with binary I know about and need to fix
20:22:04 <ManateeLazyCat> revenantphx: Update from gtk2hs-buildtools then glib, cairo soe
20:22:05 <revenantphx> thats about it.
20:22:20 <revenantphx> ???
20:22:21 <revenantphx> gtk2hs-buildtools installs
20:22:24 <revenantphx> glib does not
20:22:39 <revenantphx> cairo does not either
20:22:43 <revenantphx> issue : Cannot find gtk2hsC2hs
20:22:43 <revenantphx> Please install `gtk2hs-buildtools` first and check that the install directory is in your PATH (e.g. HOME/.cabal/bin).
20:22:58 <ManateeLazyCat> revenantphx: yes,
20:23:28 <revenantphx> ...
20:23:30 <revenantphx> yes what
20:23:37 <ManateeLazyCat> revenantphx: When ~/.cabal/bin not in your PATH, gtk2hs will noticed you like above.
20:23:59 <revenantphx> It is in my PATH
20:24:14 <ManateeLazyCat> can you install glib again?
20:24:27 <revenantphx> thats the error I get.
20:24:31 <revenantphx> Exactly what I posted.
20:24:39 <revenantphx> (I just tried it again)
20:25:01 <ManateeLazyCat> revenantphx: Can you do "where gtk2hsC2hs" to test?
20:25:28 <revenantphx> OS X doesn't have a "where" command. :|
20:26:15 <ManateeLazyCat> revenantphx: You need configre out why OS X can't find gtk2hsC2hs even it has in your PATH
20:26:37 <revenantphx> it's there...
20:26:50 <revenantphx> gtk2hsC2hs is installed.
20:26:50 <ManateeLazyCat> s/configre/figure
20:27:57 <revenantphx> oh, how do I do a package unregister/delete again?
20:28:33 <ManateeLazyCat> revenantphx: ghc-pkg unregister packageName
20:28:34 <revenantphx> ghc-pkg unregister #id#, then delete it in ~/.cabal/packages?
20:28:53 <ManateeLazyCat> revenantphx: You just can unregister it
20:29:58 <ManateeLazyCat> revenantphx: You can try "caball install gtk2hs-buildtools --reinstall"
20:30:37 <ManateeLazyCat> revenantphx: Gtk2hs-base package need newest gtk2hs-buildtools to support
20:30:49 <revenantphx> one sec
20:31:03 <revenantphx> alright... I cleaned up ghc-pkg check
20:31:08 <revenantphx> no dependency issues anymore.
20:31:27 <revenantphx> I just installed it like 10 minutes ago.
20:31:29 <revenantphx> Reinstaling it...
20:31:37 <revenantphx> almost done...
20:31:47 <revenantphx> done
20:32:10 <revenantphx> I can see and use gtk2hsC2hs....
20:32:12 <ManateeLazyCat> revenantphx: Cabal won't check gtk2hs-buildtools before install any gtk2hs-base package, so you need update gtk2hs-buildtools manually
20:32:12 <revenantphx> but it can't find it?
20:32:27 <revenantphx> ManateeLazyCat... update?....
20:32:30 <revenantphx> it's all up to date?
20:32:30 <ManateeLazyCat> revenantphx: It's more like your system problem. :)
20:32:41 <revenantphx> You're confusing me, what do I need to do >_>
20:32:59 <revenantphx> it's not finding it, for some weird reason
20:33:01 <ManateeLazyCat> revenantphx: You have re-install gtk2hs-buildtools?
20:33:04 <revenantphx> yes.
20:33:13 <revenantphx> It installs perfectly, gtk2hsC2hs is in my path
20:33:20 <revenantphx> I can invoke it from the bash prompt normally.
20:33:38 <revenantphx> It's *definitely* in my PATH
20:33:48 <ManateeLazyCat> revenantphx: Can you do "cabal clean"? I'm afraid some cache in your glib package.
20:34:14 <revenantphx> ???
20:34:19 <TheSteve> Hi everyone. :) Is there anyone who'd be kind of to explain to me one thing: I'm wondering what exactly the ":" operator does. For instance, in this case:  | otherwise = x:replicate' (n-1) x  (This is from the LYAH tutorial and is demonstrating how to replicate a list
20:34:21 <ManateeLazyCat> revenantphx: And re-try "cabal install soegtk" after "cabal clean"
20:34:26 <revenantphx> It's automatically downloading the package from hackage
20:34:40 <revenantphx> cabal clean does nothing here
20:34:51 <TheSteve> *kind enough
20:34:57 <ManateeLazyCat> revenantphx: So it's your system problem. 
20:34:58 <revenantphx> should I delete the package in .cabal/packages?
20:35:37 <ManateeLazyCat> revenantphx: Please report this problem to gtk2hs list if you can't fix it, i'm haven't Mac, sorry. 
20:35:51 <ManateeLazyCat> I just test gtk2hs on Linux.
20:35:58 <revenantphx> mmk.
20:36:04 <revenantphx> The issue seems to be it's not... checking my bin?
20:36:06 <ManateeLazyCat> revenantphx: Author of gtk2hs have Mac.
20:36:23 <revenantphx> it's glib and cairo which are causing the issue it seems
20:37:29 <ManateeLazyCat> revenantphx: We use Cabal API 'programFindLocation' check gtk2hs-buildtools whether install in user's system
20:37:40 <revenantphx> hm
20:39:10 <TheSteve> (Please disregard my question - did some googling and managed to figure it out)
20:40:15 <ManateeLazyCat> revenantphx: Last question, once you successfully installed it? Or never succeeded?
20:40:31 <revenantphx> Never.
20:40:35 <Axman6> SteveJ: it's not so much an operator as a consteructor for lists. there are two constructors fpr lists, cons: (:) and nil: []
20:41:22 <ManateeLazyCat> revenantphx: If never succeeded, you can uncompress glib.tar.gz package and find Setup.hs to delete code "checkGtk2hsBuildtools ["gtk2hsC2hs"]", and do "cabal install" at glib directory.
20:41:31 <ManateeLazyCat> revenantphx: If that work, it's a bug of checkGtk2hsBuildtools
20:41:39 <Eduard_Munteanu> Gtk2Hs is causing problems? What platform?
20:41:46 <Eduard_Munteanu> (win/linux)
20:41:50 <ManateeLazyCat> Eduard_Munteanu: Mac
20:41:57 <Eduard_Munteanu> Ah.
20:42:10 <revenantphx> gtk2hsC2hs is not being found, despite *definitely* being in my path
20:42:29 <ManateeLazyCat> Eduard_Munteanu: From revenantphx's problem, i'm afraid Cabal API `programFindLocation' can't work in Mac.
20:43:24 <revenantphx> i'm trying that ManateeLazyCat 
20:44:31 <revenantphx> setup: gtk2hsC2hs is required but it could not be found.
20:44:35 <revenantphx> Even though I commented it out???
20:44:49 <ManateeLazyCat> revenantphx: Ok, it's your system problem.
20:45:01 <revenantphx> any idea?
20:45:06 <Eduard_Munteanu> revenantphx: run cabal install with -v
20:45:09 <ManateeLazyCat> revenantphx: Axel (author of gtk2hs) have test on Mac, can install.
20:45:18 <Eduard_Munteanu> And see if it finds it and actually runs it.
20:46:03 <revenantphx> it never runs it, it just says part way through 
20:46:05 <revenantphx> Cannot find gtk2hsC2hs
20:46:08 <revenantphx> Please install `gtk2hs-buildtools` first and check that the install directory is in your PATH (e.g. HOME/.cabal/bin).
20:46:10 <revenantphx> and then crashes
20:46:37 <Eduard_Munteanu> Ok, it sounded like the problem I had when trying to cabalize Gtk2Hs under Wine.
20:47:04 <Eduard_Munteanu> (i.e. it finds it, runs it but there's some breakage in there)
20:47:04 <revenantphx> do tell.
20:47:17 <revenantphx> I moved cabal's bin to the head of my $PATH
20:47:26 <revenantphx> I have it adding it in bash_profile btw
20:47:28 <revenantphx> should be fine.
20:47:37 <Eduard_Munteanu> Here, -v showed gtk2hsc2hs was actually ran, but failed to operate correctly. It was misleading.
20:47:59 <revenantphx> The thing is... WHERE IS IT LOOKING 0.o
20:48:02 <Eduard_Munteanu> The safe way to test path is echo $PATH :)
20:48:05 <revenantphx> It's right there where it should be!
20:48:13 <revenantphx> Eduard_Munteanu: I'm aware :|
20:48:18 <ManateeLazyCat> revenantphx: So fix it?
20:48:27 <revenantphx> ManateeLazyCat: I don't know what's wrong with it!
20:48:43 <Eduard_Munteanu> In my case, it failed with the same error.
20:48:45 <ManateeLazyCat> revenantphx: I haven't Mac on my box, sorry i can't test it for you. :)
20:48:55 <revenantphx> anyone have a mac in here who's willing to try it?
20:49:57 <Eduard_Munteanu> If you want a quick fix, see if there's a Mac binary for it. But it's probably going to be an older version like 0.10.1
20:50:21 <revenantphx> hgrmrrm
20:50:34 <revenantphx> I just wish it would say where it was looking
20:50:37 <revenantphx> It just says "cannot find"
20:50:40 <SteveJ> Would someone mind explaining the "xs" convention that's used in lyah? It just sort of appeared in the beginning and I'm finding it confusing. Here's an example: take' n (x:xs) = x : take' (n-1) xs  
20:50:57 <SteveJ> (I think it's first utilized in the length rewrite function)
20:51:07 <revenantphx> "ex and exes"
20:51:12 <revenantphx> "the other exes"
20:51:13 <ManateeLazyCat> We just use Cabal API in Gtk2HsSetup.hs, if it can't work, it's something wrong break Cabal
20:51:13 <SteveJ> ohhh
20:51:19 <SteveJ> geeze, that's obvious.
20:51:22 <revenantphx> ;)
20:51:27 <SteveJ> lol, thx :)
20:52:03 <ManateeLazyCat> revenantphx: BTW, gtk2hsC2hs is right name in your PATH? Or like gtk2hsC2hs.exe under Windows?
20:52:04 <revenantphx> ManateeLazyCat: this is really weird.
20:52:35 <revenantphx> ~/.cabal/bin/gtk2hsC2hs
20:52:38 <revenantphx> (exactly)
20:52:53 <ManateeLazyCat> Hmm, i'm no idea, sorry. :(
20:52:57 <Eduard_Munteanu> revenantphx: can you pastebin the output of cabal install -v? (like pipe it into wgetpaste)
20:52:59 <revenantphx> agggh
20:53:02 <revenantphx> yeah sure
20:53:40 <revenantphx> https://gist.github.com/749511
20:54:12 <SteveJ> So I guess the super-duper-stupid question I'm going to ask anyway is "Is haskell smart enough to understand that the letter s appended to the end of any variable is a reference that there might be multiple variables? Or is it just another variable name?"
20:55:21 <Eduard_Munteanu> SteveJ: no :)
20:55:26 <revenantphx> Just another name.
20:55:35 <Eduard_Munteanu> :t (:)
20:55:36 <lambdabot> forall a. a -> [a] -> [a]
20:55:41 <SteveJ> whew - that's good news :) thx
20:55:46 <revenantphx> But it is smart enough to understand that x and xs are both lists
20:56:06 <revenantphx> wait... how exactly does 9:blahblahblah work then?
20:56:13 <revenantphx> is 9 automatically promoted to [9] somehow D:?
20:56:21 <SteveJ> it's definitely a different way of doing things - that's unlike any language I've ever seen
20:56:25 <Eduard_Munteanu> Um?
20:56:28 <shachaf> revenantphx: ...No?
20:56:41 <revenantphx> Or are they somehow instances of the list monad..?
20:56:49 <Eduard_Munteanu> :t (:)
20:56:50 <revenantphx> or is it monoid stuff
20:56:50 <lambdabot> forall a. a -> [a] -> [a]
20:56:51 <revenantphx> WHY
20:56:57 <revenantphx> oh
20:56:59 <revenantphx> a -> [a]
20:57:03 <revenantphx> I need to read better.
20:57:12 <revenantphx> Anyways, back to my issue >_>
20:57:33 <ManateeLazyCat> revenantphx: From your error, it's weird
20:57:42 <revenantphx> No really TT_TT
20:58:08 <Eduard_Munteanu> You can take lists as   data [a] = [] | a:[a]
20:58:26 <Eduard_Munteanu> revenantphx: can you try -vv
20:58:27 <Eduard_Munteanu> ?
20:58:31 <revenantphx> -vv 0.o
20:58:35 <Eduard_Munteanu> It's not verbose enough :)
20:58:37 <revenantphx> is that like... verbosely verbose?
20:58:46 <ManateeLazyCat> Eduard_Munteanu: revenantphx almost crazy ... :)
20:58:50 <revenantphx> cabal: Can't parse verbosity v
20:58:58 <Eduard_Munteanu> Yeah. Like, lspci does the same, you can give it -vvv :)
20:59:12 <revenantphx> should be -v3 I think
20:59:27 <revenantphx> gaaah
20:59:36 <revenantphx> -v3 doesn't say anything about gtk2hsC2hs
21:00:14 <pastorn> is IntMap hardcoded to use Int32 keys?
21:00:42 <Eduard_Munteanu> I think it's whatever Int is, right?
21:01:04 <Eduard_Munteanu> It must work with any Int.
21:01:18 <revenantphx> IntMap uses Key, which is a type synonym for Int
21:02:17 <pastorn> ah
21:02:31 <pastorn> couldn't it be modified to work on Bits?
21:02:39 <revenantphx> Bits is a typeclass no?
21:02:59 <jmcarthur> i think it relies on certain properties about Int specifically to be fast
21:03:06 <revenantphx> EnumMap tries to do that but with enums.
21:03:09 <revenantphx> sadly its bitrotted
21:03:14 <pastorn> awww
21:03:19 <revenantphx> go fix it :)
21:03:22 <SteveJ> -Thanks for your help, everyone! Bedtime here.
21:03:27 <Eduard_Munteanu> Is Data.Map too slow for you?
21:03:28 <revenantphx> np
21:03:39 <revenantphx> Data.HashMap is one alternative.
21:03:48 <pastorn> IntMap will do... i'll have a lot of TVars with Unique:s to keep track of them
21:03:50 <revenantphx> (it just uses IntMap's underneath though ;) )
21:05:38 <slack1256> hello anybody up?
21:05:48 <danderson> most of us are sitting down
21:05:54 <danderson> at least, I hope.
21:05:56 <revenantphx> So yeah.... any ideas on my issue?
21:06:12 <revenantphx> Who should I talk too?
21:06:13 <pastorn> danderson: i'm sort of in between sitting and laying
21:06:21 <danderson> revenantphx: what was your issue?
21:06:21 <slack1256> ohh OK XD
21:06:30 <revenantphx> goddamn glib won't install
21:06:47 <revenantphx> Cannot find gtk2hsC2hs
21:06:47 <revenantphx> Please install `gtk2hs-buildtools` first and check that the install directory is in your PATH (e.g. HOME/.cabal/bin).
21:06:53 <revenantphx> except, gtk2hsC2hs is there.
21:07:01 <ManateeLazyCat> revenantphx: Send your "environment information" and "gtk2hs error" to gtk2hs list. 
21:07:04 <revenantphx> And ~/.cabal/bin is the FIRST thing in my path.
21:07:21 <revenantphx> the trac?
21:07:34 <ManateeLazyCat> gtk2hs-users@lists.sourceforge.net
21:07:36 <danderson> no, the mailing list, most likely
21:07:38 <danderson> yeah, that one
21:07:55 <danderson> revenantphx: random question, gtk2hsC2hs is on your PATH, right?
21:07:58 <revenantphx> Yes.
21:08:06 <revenantphx> I can invoke it from bash perfectly fine.
21:08:06 <danderson> not just installed, but also executable without specifying the full path?
21:08:07 <danderson> hmmkay.
21:08:19 <ManateeLazyCat> revenantphx: I doubt something wrong in your system that break Cabal.
21:08:22 <danderson> then yeah, goto usersList && cryForHelp
21:08:56 <ManateeLazyCat> revenantphx: Maybe send your box to China, i help you fix it. :)
21:09:22 <revenantphx> what should I send?
21:09:28 <revenantphx> the output, my path, and system info?
21:09:35 <ManateeLazyCat> revenantphx: Joking. :)
21:09:44 <revenantphx> no no, I mean to the mailing list ;)
21:09:59 <ManateeLazyCat> revenantphx: error, and detail information about your Mac. 
21:10:12 <slack1256> excuse my english please, but
21:10:14 <slack1256> does anybody know if there is a "haskell by example"?
21:10:20 <ManateeLazyCat> revenantphx: Something like Mac version, ghc version, cabal version. patch information
21:10:31 <slack1256> somewhere i could just look source code of little programs?
21:10:31 <danderson> slack1256: learnyouahaskell.com
21:10:40 <danderson> or book.realworldhaskell.org
21:10:42 <slack1256> yeah i tried that
21:10:48 <danderson> both are excellent intros, with examples
21:10:50 <Eduard_Munteanu> slack1256: maybe this? http://tryhaskell.org/
21:10:57 <Eduard_Munteanu> I'm not sure what you're looking for.
21:11:47 <revenantphx> hm there seems to be a cabal update
21:11:49 <revenantphx> I will install it
21:11:59 <slack1256> i looking for standalone programs for example, i saw a time ago one who was a little "ed-like" editor in haskell
21:12:33 <revenantphx> I find that that approach is not as nice with haskell.
21:12:43 <revenantphx> Theres a lot of idiomatic stuff that you'll miss or be puzzled by.
21:13:05 <Eduard_Munteanu> @where hackage
21:13:05 <lambdabot> http://hackage.haskell.org/package/
21:13:20 <slack1256> mm you are right :)
21:13:21 <Eduard_Munteanu> You could find small and big programs.
21:14:00 <slack1256> mm hackage seems to be what i am looking for :D
21:14:21 <slack1256> thanks a lot 
21:17:44 <Eduard_Munteanu> revenantphx: what approach?
21:17:48 <revenantphx> ?
21:17:53 <revenantphx> learning by example
21:17:56 <Eduard_Munteanu> Ah.
21:18:02 <revenantphx> I mean, purely by example.
21:19:19 <revenantphx> okay, sent out to the mailing list, hopefully they can help TT_TT
21:23:46 <revenantphx> ugh, hopefully tomorrow I can find a resolution.
21:30:36 <jonathan_> what are these symbols ~> and +>? 
21:31:51 <ManateeLazyCat> @hoogle (~>)
21:31:51 <lambdabot> No results found
21:32:00 <ManateeLazyCat> @hoogle "(+>)"
21:32:01 <lambdabot> Parse error:
21:32:01 <lambdabot>   --count=20 "(+>)"
21:32:01 <lambdabot>              ^
21:32:06 <ManateeLazyCat> @hoogle (+>)
21:32:06 <lambdabot> Control.Arrow (<+>) :: ArrowPlus a => a b c -> a b c -> a b c
21:32:06 <lambdabot> Text.PrettyPrint.HughesPJ (<+>) :: Doc -> Doc -> Doc
21:32:06 <lambdabot> Language.Haskell.TH.PprLib (<+>) :: Doc -> Doc -> Doc
21:32:33 <jonathan_> no results
21:32:44 <jonathan_> on hoogle
21:55:17 <Eduard_Munteanu> @hoogle Category
21:55:17 <lambdabot> module Control.Category
21:55:17 <lambdabot> Control.Category class Category cat
21:55:17 <lambdabot> Data.Char data GeneralCategory
21:55:38 <azaq23> @type sqrt $ (24 :: Num t => t) * (0.2 :: Float)
21:55:39 <lambdabot> Float
21:55:46 <azaq23> @type let f :: Num t => t -> Float -> Float; f i p = sqrt $ i * p in f 24 0.2
21:55:46 <lambdabot>     Couldn't match expected type `t' against inferred type `Float'
21:55:47 <lambdabot>       `t' is a rigid type variable bound by
21:55:47 <lambdabot>           the type signature for `f' at <interactive>:1:13
21:55:50 <azaq23> what's the difference here?
21:57:25 <dibblego> does there exist a way to read a UTF-8 encoded source file (with the first three bytes ef bb bf) into a String?
21:58:00 <Axman6> you could probably use something like attoparsec
21:58:35 <dibblego> I have a parser, it just accepts String
21:58:42 <dibblego> and it is barfing on my UTF-8 encoded String
21:59:36 <Axman6> that's why i suggested attoparsec, which works on bytestrings, you can parse the first three bytes, then turn the rest into a String if you like (or Text)
21:59:44 <Eduard_Munteanu> @type let foo :: a -> a; foo = id
21:59:45 <lambdabot> <no location info>:
21:59:45 <lambdabot>     not an expression: `let foo :: a -> a; foo = id'
22:00:13 <Eduard_Munteanu> @type let foo :: a -> a; foo = id in foo 1
22:00:14 <lambdabot> forall t. (Num t) => t
22:01:28 <Axman6> azaq23: you're trying to mix things of different types, haskell doesn't do automatic conversion between numeric types
22:02:36 <Eduard_Munteanu> Where? I can't see it.
22:03:35 <Eduard_Munteanu> Oh right, he's using that argument as if it where less polymorphic.
22:03:45 <Eduard_Munteanu> *were
22:03:51 <Axman6> the type of (*) is Num a => a -> a -> a, but azaq23 has given p the type Float, but i has the type Num t => t, which is not the sane as Float
22:06:42 <azaq23> Axman6: Shouldn't the other expression fail too, then? I'm specifically saying that 0.2 has the type Float and 24 type Num t => t, but there it works
22:06:43 <azaq23> > (sqrt $ (24 :: Num t => t) * (0.2 :: Float)) :: Float
22:06:44 <lambdabot>   2.1908903
22:09:15 <Axman6> azaq23: no, because i believe it then defaults to Float using the defaulting rules
22:09:19 <Eduard_Munteanu> azaq23: no, the problem is your definition of 'f' is expects 't' to be Float (because of (*)).
22:09:55 <Eduard_Munteanu> In function application making a type less polymorphic is okay.
22:10:54 <Eduard_Munteanu> Or to put it another way, what would happen if you supplied 'f' something that was a Num but couldn't be a Float?
22:12:44 <Ilum> If I want a function to take arguments of many different types (polymorphic) and have its behavior change based on the type of the argument, how do I specify this in the type signature?
22:13:00 <dibblego> Either a b -> c
22:13:10 <Rotaerk> with lots of hax and magic
22:13:22 <Rotaerk> or that
22:13:58 <Eduard_Munteanu> You can't explicitly dispatch by type in a function definition, if that's what you're asking.
22:14:31 <Eduard_Munteanu> (types exist only at compile time as far as Haskell is concerned)
22:15:23 <Eduard_Munteanu> But it's usually done by defining a typeclass, and having instances for each type you're interested in.
22:16:02 <Axman6> Ilum: using a class
22:16:56 <Axman6> Ilum: what exactly do you want to do?
22:17:13 <etpace> @hoogle getArgs
22:17:13 <lambdabot> System.Environment getArgs :: IO [String]
22:26:06 <azaq23> thanks, I see - so say that I want to define some simple probability functions using a type Prob = Float for a probability in the interval [0; 1] (since that's easy and sufficient), isn't there a simply way to use arbitrary numeric types with that? I can't do type Prob = Num t => t. Using ExistentialQuantification, data Prob = forall t. Num t => Prob t is possible, but then I can't mix this with some other type variable over Num
22:29:34 <Eduard_Munteanu> I don't think you want existentials there.
22:29:36 <c_wraith> Why do you need a type declaration at all?
22:31:25 <Eduard_Munteanu> Why not leave 'f' more polymorphic? Like f :: (Num a) => a -> a -> a
22:31:53 <Chaze> @pl (\x -> flip ((flip zipWith) x) (tail x))
22:31:53 <lambdabot> ap (flip . flip zipWith) tail
22:32:05 <Chaze> :t ap
22:32:06 <azaq23> I don't need a type declaration and I could of course do without, but "marking" (with type) probabilities seemed like a nice idea. Using a algebraic data type is something I just tested to see if that would work
22:32:06 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
22:32:16 <Chaze> i need to understand ap :)
22:32:52 <pastorn> Chaze: ap = do { f <- mf; x <- mx; y <- my; return (f x y) }
22:33:02 <pastorn> wait
22:33:05 <pastorn> scratch that
22:33:11 <blueonyx> :t litfM
22:33:12 <lambdabot> Not in scope: `litfM'
22:33:16 <Chaze> @src ap
22:33:16 <lambdabot> ap = liftM2 id
22:33:16 <ddarius> Little gung-ho on the arity.
22:33:19 <pastorn> Chaze: ap mf mx = do { f <- mf; x <- mx; return (f x) }
22:33:23 <blueonyx> :t Control.Monad.litfM
22:33:24 <lambdabot> Not in scope: `Control.Monad.litfM'
22:33:27 <ddarius> Indeed, ap = liftM2 ($) = liftM2 id
22:33:34 <pastorn> Chaze: my second attempt is correct
22:34:00 <augur> eclipse!
22:34:08 <Chaze> pastorn: and what would ap be in the function monad?
22:34:38 <pastorn> Chaze: (a -> r -> b) -> (r -> a) -> (r -> b)
22:34:50 <Chaze> in do-natation, basically each <- is a >>= right?
22:35:02 <Eduard_Munteanu> By the way is 'ap' related to TAPL's 'lam' and 'ap'?
22:35:04 <Chaze> with the following lines opening a new lambda function taking one argument
22:35:06 <pastorn> Chaze: each <- together with the ;
22:35:36 <Eduard_Munteanu> (the thing relating to the embedding of untyped lambda calculus)
22:35:37 <ddarius> Eduard_Munteanu: Yes and no.
22:35:52 <ddarius> (Or maybe just yes, I don't know what TAPL's definitions are.)
22:35:54 <azaq23> Chaze: ap is the S combinator in the function monad, \x y z -> x z (y z)
22:38:12 <Eduard_Munteanu> ddarius: 'ap' there is \f:D \d:D. f a, where D = \mu X. X -> X
22:38:30 <Eduard_Munteanu> (they do admit something to do with denotational semantics)
22:38:42 <ddarius> ap is "application with effects."  In particular, for the Reader/function monad, it's "application in an environment."  When you perform the (simpler) bracket abstraction algorithm(s), application gets transformed into the use of S which allows the lambda bound variables being removed to become simple parameters.
22:39:01 <Eduard_Munteanu> oops, s/d/a/
22:39:10 <ddarius> In the Identity monad, ap is ($), i.e. normal application.
22:39:47 <Chaze> how is the identity monad inferred?
22:39:49 <Eduard_Munteanu> Yeah, I was wondering if its name is somewhat inspired from a common source.
22:40:15 <Chaze> ddarius: can you write an example using ap that would infer the identity monad?
22:40:56 <Eduard_Munteanu> Why "infer"?
22:41:35 <Eduard_Munteanu> If you're using the identity monad explicitly, then that's what happens. I presume that's what he meant.
22:41:37 <iFire> http://www.ustream.tv/channel/coasterstorm's-weather-center lunder eclipse
22:41:41 <iFire> lunar*
22:42:23 <Chaze> Eduard_Munteanu: ok, so how would you use it explicitly?
22:42:40 <Chaze> Eduard_Munteanu: from my understanding, the instance of the monad gets infered by a type constructor
22:42:56 <Chaze> i have no idea what the type constructor of the identity monad would be
22:45:20 <danderson> has anyone seen an iteratee library that operates on a bitstream (not bit, not byte) by any chance?
22:46:04 <danderson> I'm thinking of playing with binary disassembly/translation, and an iteratee feels like a nice way of disassembling an instruction stream
22:46:19 <danderson> (especially for instruction sets with variable length opcodes)
22:46:42 <danderson> but that assumes having a bit-level iteratee. I can probably construct one, but if anyone has one lying around... :P
22:47:08 <Eduard_Munteanu> Chaze: Identity
22:47:17 <Chaze> :t Identity
22:47:18 <lambdabot> forall a. a -> Identity a
22:47:40 <Eduard_Munteanu> It's generally useful in the context of monad transformers.
22:47:42 <etpace> is there a difference between the cabal packages 'mtl' and 'ghc-mtl'?
22:48:42 <azaq23> Chaze: The identity type is a type which "boxes" other types and is defined to do nothing with them. The identity monad carries the semantics of a monad to that type. return is then just the type which "wraps" some value into the identity type, x >>= f would unwrap x (and do nothing with it) and applicate f to the "inner value" of x, then return it simply. So identity is a type data Identity t = Identity t, and for the monad the instance w
22:49:31 <Chaze> azaq23: ah, that is actually very nice for understanding monads
22:51:59 <Eduard_Munteanu> And transformers, since any monad Foo is obtained from FooT applied to Identity. (Well, except Identity itself.)
22:52:35 <exlevan> etpace: thre's quite a big difference, did you read package descriptions?
22:54:08 <dibblego> I am doing something very wrong, but I cannot find a library to also do it (tried utf8-string and text) http://paste.pocoo.org/show/307730/
22:57:54 <Eduard_Munteanu> dibblego: not sure what you want to do, but why not do binary I/O?
22:58:11 <dibblego> Eduard_Munteanu, I need to get a String ultimately, for a parsing library wich wants it
22:59:24 <dibblego> Eduard_Munteanu, if I use Data.ByteString.readFile then unpack it to [Word8] then decode it using Codec.Binary.UTF8.String I still get the same problem
23:02:37 <dibblego> here are some attempts: http://paste.pocoo.org/show/307735/
23:03:48 <exlevan> dibblego: so what's the problem you get?
23:04:03 <dibblego> the parser fails with my particular file: UnexpectedChar '\65279'
23:04:11 <dibblego> unless I use the s function, which works fine
23:04:50 <dibblego> but my s function feels wrong
23:07:22 <exlevan> dibblego: what's wrong with dropping Unicode BOM? Seems fine to me
23:07:36 <dibblego> you mean my s function looks fine to you? it just feels ick
23:07:42 <dibblego> surely there is a better way?
23:07:45 <ddarius> Somebody set us up the BOM
23:09:31 <dibblego> shall I assume this is OK?
23:10:04 <exlevan> well it could be written a bit prettier, but otherwise I see no problem here. Perhaps there should be a standard library function to do it, but I'm not aware of such
23:10:16 <dibblego> prettier?
23:10:40 <exlevan> like make it a separate function, e.g. dropBOM
23:10:51 <dibblego> right, I could break it out
23:12:51 <dibblego> http://paste.pocoo.org/show/307739/
23:12:54 <dibblego> still feels wrong
23:13:36 <jkff> Hi. Can anyone point me to sources on the *modern* ways of handling exceptions (particularly IO exceptions) in Haskell? Quick googling yields stuff that I know for sure has been outdated.
23:14:11 <dibblego> jkff, Control.Exception
23:14:28 <jkff> dibblego: is that the same as "extensible exceptions"?
23:14:51 <dibblego> I've no idea what that is
23:15:42 <exlevan> jkff: it is
23:16:13 <jkff> dibblego, exlevan: thanks - will look at it. I remember that it was somehow "outdated", but turns out it has been refactored with preserving the module name :)
23:16:48 <exlevan> dibblego: here's how I'd write it http://paste.pocoo.org/show/307741/
23:17:29 <exlevan> jkff: right, the old exception system now resides in Control.Exception.Old
23:17:40 <jkff> exlevan: Yep, thanks again
23:33:22 * hackagebot haxr 3000.8.1 - XML-RPC client and server library.  http://hackage.haskell.org/package/haxr-3000.8.1 (GracjanPolak)
23:37:21 <danderson> so, I'm pretty sure that there's a short and elegant way of getting all possible combinations of two lists (say, `permute (+) [1,2,3] [4,5]` output [5,6,6,7,7,8])
23:37:45 <Axman6> liftM2 (+)?
23:37:58 <Axman6> > liftM2 (+) [1,2,3] [4,5]
23:37:59 <lambdabot>   [5,6,6,7,7,8]
23:38:17 <danderson> aaaargh, I *knew* there was an elegant way with the list monad, but I forgot about liftM
23:38:21 <danderson> thanks :)
23:38:38 <danderson> (haskell rusts really, really fast when not used, it seems)
23:38:46 <Axman6> > (+) <$> [1,2,3] <*>? [4,5]
23:38:47 <lambdabot>   Not in scope: `<*>?'
23:38:57 <applicative> > [(+)] <*> [1,2,3] <*> [4,5]
23:38:57 <Axman6> > (+) <$> [1,2,3] <*> [4,5]
23:38:58 <lambdabot>   [5,6,6,7,7,8]
23:38:58 <lambdabot>   [5,6,6,7,7,8]
23:39:16 <applicative> Axman6 is to fast
23:39:19 <applicative> too
23:39:27 <ddarius> liftM = fmap
23:42:26 <pastorn> why is newtype restricted to one field?
23:42:29 <Axman6> > (length "(+) <$> xs <*> ys", length "liftM2 (+) xs ys")
23:42:30 <lambdabot>   (17,16)
23:42:55 <Axman6> pastorn: because newtypes disappear very quickly, they're there is a wrapper for existing types
23:43:32 <pastorn> but you can put (a,b,c) in a newtype, so why wouldn't a bigger record construct work?
23:43:49 <Axman6> because tuples are special
23:44:00 <Axman6> you're just wrapping (a,b,c) there
23:44:26 <pastorn> hhmmm...
23:44:33 <Axman6> when you go newtype Foo a b c = Bar (a,b,c), the Bar's disappear
23:46:10 <pastorn> but how does that prevent me from having records?
23:47:03 <pastorn> i mean... i could declare some newtype T = T (X,Y,Z,W) with get*/set* for each field inside the newtype
23:47:22 <pastorn> *inside the tuple*
23:54:34 <phao> is there any name for lambda beyond the \ character?
23:54:40 <phao> something like the name lambda
23:55:17 <c_wraith> You mean in the context of programming languages?
23:55:37 <c_wraith> lambda functions in programming languages are sometimes called anonymous functions.
23:56:05 <phao> no... I mean, in Haskell. Is there any other name I could used instead of the character \ to create a lambda expression, in Haskell
23:56:05 <sipa> pastorn: yes you  can, but it won't gain you anything compared to records
23:56:28 <phao> like, in scheme, we use the lambda (lambda (arguments list) (body))
23:56:51 <Axman6> you can use a unicode lambda symbol
23:56:53 <phao> Doing it like (lambda a1 a2 <rest of list> -> <body>) would be nice
23:57:00 <phao> Axman6, anything else?
23:57:10 <Axman6> f x = y?
23:57:17 <phao> ?
23:57:32 <Axman6> let f x = y in blah f?
23:57:39 <Axman6> i don't understand what you want
23:57:54 <phao> I want something I can use in the place of \
23:58:02 <sipa> why?
23:58:14 <Axman6> \ and the lambda symbol is all there is
23:58:17 <phao> typing \ is really annoying in my keyboard
23:58:23 <Eduard_Munteanu> You could hack something up with CPP, like a #define
23:58:33 <Eduard_Munteanu> Uh.
23:58:40 <etpace> @hoogle liftio
23:58:40 <lambdabot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
23:58:57 <etpace> @hoogle assert
23:58:57 <lambdabot> Control.Exception assert :: Bool -> a -> a
23:58:57 <lambdabot> Control.OldException assert :: Bool -> a -> a
23:58:57 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
23:59:18 <Eduard_Munteanu> Maybe you could remap keys? Like Compose + something to get '\' or even a unicode lambda.
23:59:33 <Eduard_Munteanu> What editor are you using?
23:59:36 <phao> medit
23:59:44 <phao> well, nevermind then.
23:59:46 <Eduard_Munteanu> I don't know then :)
