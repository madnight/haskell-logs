00:00:08 <shachaf> Oh, I was going to say that you also the "map " from words, but of course you put that in the fold.
00:00:30 <mtnviewmark> also, I really want a version of interact that does the "unixy" thing --- uses stdin in no file args, and use files mentinoed in args, concated if any
00:00:41 <mtnviewmark> exactly
00:01:12 <mtnviewmark> also - pairing up from a list with std. functions is hard...
00:01:24 <mtnviewmark> well... hard to make look more clear and concise than by hand
00:01:32 <shachaf> Unfortunately.
00:02:33 <mtnviewmark> if you are not doing code golf....      pairs (a:b:xs) = (a,b) : pairs xs; pairs _ = []     is fine
00:03:46 <mtnviewmark> but how could you do that with just Prelude functions?
00:06:02 <aefjt> So today's course is unique directed paths in 140 characters?
00:06:12 <aefjt> I probably won't play
00:08:12 <mtnviewmark> did you see the comment on the Ocaml version: "Basically an adaptation of the Haskell version, the length of which amazes me."
00:10:02 <shachaf> The Ruby version is shorter. :-)
00:10:41 <mtnviewmark> I know - and the algo is icky
00:10:48 <mtnviewmark> but - in this case they're shorter
00:11:02 <Veinor> @pl \x -> f x x
00:11:02 <lambdabot> join f
00:13:32 <aefjt> This reminds me of the following topological sort golf http://www.nntp.perl.org/group/perl.golf/2002/07/msg1289.html
00:13:44 <aefjt> "The principle behind this solution is that Perl already has a topological sorter for graphs built in: the garbage collector."
00:13:54 <Veinor> wat
00:13:58 <qfr> aefjt hahaha
00:14:41 <Veinor> oh my god it uses the eskimo kiss operator!
00:15:18 <Veinor> it doesn't compile, though
00:15:42 <augur> whats the eskimo kiss operator
00:15:57 <systemfault> I would like a kirby operator.
00:16:13 <Veinor> oh nevermind
00:16:18 <systemfault> <(^^<)
00:16:23 <Veinor> augur: }{
00:16:24 <tolkad> Could anyone with experience with Parsec please help me understand why my lambda calculus parsing code doesn't halt? http://pastebin.com/WrCRykNt
00:16:31 <augur> Veinor: lolwut
00:16:43 <augur> thats an operator in perl?
00:16:47 <Veinor> not really
00:16:53 <systemfault> Ah, Veinor, now I understand...
00:16:59 <augur> not really?
00:17:02 <augur> either it is or it isnt :P
00:17:16 <Veinor> augur: it isn't, but it's a syntactic hack that acts like an operator
00:17:25 <augur> how so?
00:17:28 <dolio> tolkad: Left-recursion.
00:17:31 <mtnviewmark> that is AMAZING
00:17:56 <Veinor> augur: well, perl -n 'do stuff' translates into 'while (<>) { do stuff } '
00:18:10 <Veinor> augur: well, perl -n 'do stuff}{ final stuff }' translates into 'while (<>) { do stuff } {final stuff}'
00:18:19 <Veinor> er, {do stuff}{final stuff}
00:18:27 <tolkad> dolio: thanks, was able to google that
00:18:36 <Veinor> ... wait
00:18:39 <augur> wtf Veinor
00:18:41 <dolio> lambdaParser = apParser <|> ... = (do x <- lambdaParser ; ...) <|> ... = (do x <- apParser <|> ... ; ...) <|> ..., etc.
00:18:43 <augur> what is WRONG with perl
00:18:45 <augur> god
00:18:51 <Veinor> perl -n 'do stuff}{final stuff' translates to 'while (<>) {do stuff}{final stuff}'
00:18:55 <Veinor> there we go!
00:19:32 <Veinor> augur: it's not the goatse operator
00:19:37 <mtnviewmark> yes - being able to count that the "wrapping" of -p is done that the textual level, and not AST level is just DEMENTED
00:20:00 <Veinor> mtnviewmark: it's the best stupid hack ever
00:20:47 <Veinor> the goatse operator is =()=, and it evaluates the thing on the right in array context
00:21:22 <augur> o_o;
00:21:28 <augur> =(
00:21:29 <augur> )=
00:21:35 <Veinor> and then assigns it to the thing on the left
00:21:36 <taotree> Is there a recommended library for accessing mysql from Haskell?
00:21:37 <Veinor> hahahs
00:22:12 <Veinor> oh, perl also has a variable called $^H
00:22:21 <Veinor> where by ^H I mean the backspace symbol
00:22:45 <qfr> taotree hmm just Google and pick the most popular one would be my guess :P
00:23:13 <taotree> Well, I see several on Hackage.... but not sure which is most mature/stable/...
00:23:56 <tomh1> cabal install readline is failing for me, ExitFailure 1, Mac OS X
00:27:32 <Saizan> tomh1: maybe you miss readline's C headers, there should be a more informative error message up in your log, also
00:28:44 <mtnviewmark> taotree: I've successfully used HDBC with the HDBC-mysql driver
00:31:45 <tomh1> Hmm, in build.log its telling me readline ConfigureFailed. Is that any more helpful?
00:39:19 <taotree> mtnviewmark: thanks. I'm considering trying out HaskellDB which would then use that same driver, I think.
00:56:10 <tolkad> haha, now I can write lambda calculus using the standard notation and have it automatically converted into SKI combinator calculus for me
01:35:10 <j-invariant> what's it called when you have written a program and it works but you don't like it
01:35:42 <Jafet> Success.
01:42:04 <mm_freak> j-invariant: C++
01:43:19 <earthy> j-invariant: just another day at the job
01:43:51 <mm_freak> forkOS = forkIO . runInBoundThread  -- right?
01:46:01 <silver> @src forkOS
01:46:01 <lambdabot> Source not found. Maybe if you used more than just two fingers...
01:46:07 <silver> @hoogle forkOS
01:46:07 <lambdabot> Control.Concurrent forkOS :: IO () -> IO ThreadId
01:46:23 <silver> @src Control.Concurrent.forkOS
01:46:23 <lambdabot> Source not found.
01:49:00 <c_wraith> That's going to be part of the RTS anyway
01:55:25 <mm_freak> is atomicModifyIORef safe even for complicated data structures?
01:57:58 <j-invariant> Any good books to own about category theory
02:00:24 <Veinor> @where awodey
02:00:24 <lambdabot> http://www.math.uchicago.edu/~may/VIGRE/VIGRE2009/Awodey.pdf
02:00:41 <Jafet> Categories for the unemployed programmer
02:01:01 <silver> 404
02:01:45 <Veinor> ftp://195.214.211.1/books/DVD-021/Awodey_S._Category_Theory(en)(305s).pdf
02:03:02 <silver> thank you
02:05:25 <Jafet> Ha
02:06:46 <Jafet> Who pays the bill for that ftp site?
02:07:56 <Veinor> reversedns says in.ua
02:08:01 <Veinor> so some ukranian :)
02:11:48 <rjo> I thought that I understand Monads for a second
02:12:31 <rjo> I've: getRandom :: State LCGState Integer
02:12:57 <rjo> now I would like to make a program, which prints that computation
02:13:01 <rjo> and I cannot
02:13:37 <Jafet> Why not?
02:14:13 <rjo> I've to convert it to IO ()
02:14:25 <mm_freak> LCGState, so you're reading my tutorial =)
02:14:30 <rjo> yes
02:14:49 <mm_freak> rjo: you don't convert State computations to IO computations, because they are pure
02:15:05 <mm_freak> later in the tutorial you will learn about monad transformers, which allow you to combine State and IO
02:15:43 <mm_freak> using runState/evalState you just evaluate the pure computation to a value, and that value can then be printed
02:16:27 <mm_freak> :t let result = evalState (modify (+3)) 5 in print result
02:16:27 <lambdabot> IO ()
02:17:05 <ddarius> Cumin is awesome.
02:17:32 <taotree> Is there a way to do something like: "data Round = Circle | Oval"  "data Polygon = Square | Rectangle and then "data Shape = Round | Polygon" ?
02:18:23 <Zao> data Shape = RoundShape Round | PolygonShape Polygon
02:18:43 <taotree> Zao: got it, thanks!
02:19:02 <Jafet> Implicit surfaces ftw
02:19:16 <ddarius> Implicit surfaces are pretty awesome.
02:19:43 <ddarius> @google f-rep
02:19:45 <lambdabot> http://www.hyperfun.org/F-rep.html
02:19:56 <Jafet> You can also make bsps with the same interface, requiring almost no extra code anywhere else
02:21:12 * hackagebot contstuff 1.1.0 - Fast, easy to use CPS-based monad transformers  http://hackage.haskell.org/package/contstuff-1.1.0 (ErtugrulSoeylemez)
02:21:35 <mm_freak> new version of contstuff, now all monad transformers support forkIO =)
02:21:59 <Jafet> Cool
02:22:07 <Jafet> Perhaps someday, I'll try using them again
02:22:19 <mm_freak> forkIO :: Forkable m => m a -> m ThreadId
02:22:59 <mm_freak> though perhaps i should rename that function
02:23:45 <Jafet> Hm, where's the IO
02:24:40 <Saizan> mm_freak: what semantics do you use for StateT or WriterT?
02:25:43 <ddarius> So Charles Babbage wrote a paper entitled "Table of Relative Frequency of the Causes of Breaking of Plate Glass Windows."
02:25:47 <taotree> hmm... but... in pattern matching, I would have to "descend the hierarchy" and match on RoundShape Square w, I couldn't just match on Square or Rectangle, right? So, if I changed that hierarchy for some reason, all code would have to be updated.
02:26:34 <mm_freak> Saizan: CPS, if that's what you're asking for
02:26:47 <ddarius> mm_freak: CPS isn't a semantics.
02:26:50 <Zao> taotree: Right.
02:27:07 <j-invariant> ddarius: that's to with opera singers?
02:27:07 <Zao> taotree: (barring (ab)use of dynamic and other unholy libraries)
02:27:09 <ddarius> Saizan is asking what does it -mean- to forkIO with StateT.  How is the state treated?
02:27:10 <Jafet> ddarius: I wonder what frequency was assigned to "impact"
02:27:25 <Zao> taotree: If you want them as constructors of a single type, make them constructors of a single type.
02:27:29 <mm_freak> Saizan, ddarius:  the state is forked
02:27:38 <Zao> taotree: Or use view patterns, I guess.
02:27:49 <Saizan> mm_freak: "do put 0; forkIO (put 1); ..." <- so a get at ... would see 0?
02:28:01 <mm_freak> Saizan: right
02:28:30 <mm_freak> i'm thinking about writing a package, which adds concurrent state
02:28:37 <mm_freak> but i'm not sure it would be very useful
02:29:40 <j-invariant> oh it means how often, not audio frequency
02:34:59 <mm_freak> but what i'm planning is to add inter-thread exception handling, so you can catch in one thread the exceptions of another one
02:37:16 <harlekin> I try to install parsec 3.1.0 (which cabal lists) and I'm having installed parsec 2.1.0.1. However, cabal install parsec tells me that the package is already installed. What am I doing wrong?
02:38:02 <rjo> harlekin, you can use explicit version numbers in cabal
02:38:24 <harlekin> rjo, that did it. Thanks.
02:38:45 <Saizan> harlekin: some packages have a "preferred-version" which isn't the latest one, parsec happens to be one of those
02:40:05 <aristid> harlekin: you can force versions (see docs)
02:42:28 <mm_freak> newtype X = forall a. Y a
02:42:32 <Jafet> Interfaces should have version numbers
02:42:36 <mm_freak> newtype X = Y (forall a. a)
02:42:39 <Jafet> And a cpo on the versions
02:42:40 <mm_freak> what's the difference?
02:43:12 <mm_freak> hmm
02:43:14 <mm_freak> s/newtype/data/
02:43:29 <Jafet> Is the former legal
02:44:14 <aristid> Jafet: cpo?
02:44:14 <mm_freak> i don't think so
02:45:34 <mm_freak> but anyway, given data, what's the difference?
02:46:05 <ski> with no hidden constraints, it probably could be allowed
02:46:12 <Jafet> At least, I *think* a complete partial order would work for interfaces
02:47:10 <ski> (and in any case `newtype X = forall a. Y a' and  `newtype X = Y (forall a. a)' would be very different, even if the first was allowed)
02:47:58 <gienah> kolmodin: did the re-recorded yesod-auth patch help?
02:47:59 <lambdabot> gienah: You have 2 new messages. '/msg lambdabot @messages' to read them.
02:47:59 <ddarius> The difference is the former has Y :: forall a. a -> X and the latter has Y :: (forall a. a) -> X
02:48:12 <gienah> sorry wrong channel
02:48:36 <mm_freak> ddarius: ok, that makes sense
02:48:37 <mm_freak> thank you
02:49:02 * ski missed the "s/newtype/data/" ..
02:57:33 <j-invariant> when my haskell program crashes it slows my computer down a lot...
02:57:42 <j-invariant> can you make it so that it doesn't do taht?
03:00:06 <ddarius> Stop writing programs that crash.  Furthermore when it crashes, it presumably is no longer executing so any performance problem at that point is due to your OS.
03:01:51 <Saizan> if it's trying to use all your memory you could limit that with RTS -M...
03:02:08 <gienah> j-invariant: if it is on unix, then maybe it is writing a huge core file, in which case it may be possible to stop it writing the core file
03:02:33 <Zao> (via ulimit or similiar tools)
03:02:42 <Zao> (or sysctls if on fbsd, methinks)
03:49:22 <qfr> Can any of you recommend a text on category theory? Ultimately I do want it digitally though
03:50:40 * hackagebot cryptohash 0.6.2 - collection of crypto hashes, fast, pure and practical  http://hackage.haskell.org/package/cryptohash-0.6.2 (VincentHanquez)
03:53:23 <qfr> Pure? In Haskell? Eeew
03:55:17 <rjo> "First quantization is a mystery, but second quantization is a functor!"
03:55:39 <Saizan> qfr: a popular one seems to be Awodey
03:55:41 * hackagebot contstuff 1.2.0 - Fast, easy to use CPS-based monad transformers  http://hackage.haskell.org/package/contstuff-1.2.0 (ErtugrulSoeylemez)
03:56:35 <tab> qfr: ?
03:56:41 <mm_freak> qfr: they are not pure in the sense of "pure haskell", but "without effectful computations"
03:56:47 <mm_freak> the algorithms are written in C
03:57:03 <qfr> Oh, it uses FFI? Hm
03:57:09 <tab> qfr: yes
03:57:39 <nswill> I have a question about this type signature readText :: FilePath -> ExceptionalT IOException IO String, it looks wrong to me. If everything in haskell is supposed to be referentially transparent it seems like the input to this function should have something that represents and input that could cause the computation to fail, like IO FilePath instead of FliePath. I must be mistaken so could someone point out how this can be considered 
03:57:40 <nswill> referentially transparent
03:58:34 <nswill> Or is FilePath just some alias for an IO type?
03:58:45 <Saizan> nswill: FilePath = String
03:58:46 <tab> nswill: FilePath is an alias for String
03:59:09 <Saizan> nswill: if you feed the same FilePath to readText you always get the same action back
03:59:30 <mm_freak> nswill: note that the result of this function is /not/ String
04:01:30 <nswill> The way i thought of this was that if I made two calls on the same filepath I could get different values of type ExceptionalT depending on the success or failure of the write. Am I not supposed to be able to reason about the contents of the ExceptionalT result?
04:01:45 <nswill> I mean read
04:02:19 <nswill> I assume you mean it's good enough that I get an ExceptionalT every time for purposes of referential transparency
04:05:57 <tab> nswill: the action is the same, but the result might not since you're probably in the IO monad.
04:06:02 <rodrigogribeiro> Hi! I'm with a problem that I don't know how to solve it. I'm implementing a haskell type synonym expansion algorithm for the haskell-src using SYB.
04:07:04 <rodrigogribeiro> the algorithm is something like this: everywhereM (mkM expand) ds
04:07:15 <rodrigogribeiro> where ds are values of type HsDecl
04:08:22 <rodrigogribeiro> I got stuck on how to expand synonyms like: type ReadS a = String -> [(a,String)] using SYB... Any clues?
04:10:54 <jonkri> how do i run a haskell project in eclipsefp?
04:11:40 <jonkri> i want to run the executable defined (automatically for me) in HaskellTest.cabal
04:19:02 <nswill> I think I understand now, readText just returns the same non-deterministic action every time, which is then passed to runExceptionalT resulting in a non-deterministic output in the specific exception when it is eventually computed
04:20:42 <nswill> Thanks
04:21:24 <ski> yeah (note that `runExceptionalT' is also deterministic, though, returning the same `IO'-action each time (it is given the same input))
04:23:24 <qfr> Hmm I might make a LaTeX version of Learn You A Haskell so I can read it on my crappy small ebook reader, the font size in the PDF is too small fo rit
04:23:30 <qfr> for it*, too
04:25:18 <osfameron> ebook reader doesn't resize fonts?
04:26:05 <qfr> osfameron the zoom breaks a lot of things
04:26:14 <osfameron> hmmm, lyah main page doesn't have a pdf version...
04:26:15 <qfr> the zoom is terrible for mathematical texts, too
04:26:19 <osfameron> ah
04:26:32 <qfr> Because vector graphics get cut up etc
04:26:54 <osfameron> doesn't lyah exist as a single HTML page anywhere?
04:26:56 <tab> osfameron: PDF doesn't reflow (on purpose), so increasing font size is terrible
04:27:17 <osfameron> I know pdf isn't intended to reflow... but I thought ebook readers made a best-endeavours attempt ;-)
04:27:19 <qfr> osfameron that would help
04:27:33 <osfameron> calibre might be able to convert the .pdf to .epub or something a bit more helpful 
04:27:53 <qfr> With the LaTeX I could totally remove all padding though and make it flow nicely
04:27:53 * osfameron is unimpressed by current state-of-art in ebook tech
04:28:37 <j-invariant> a single HTML?
04:31:44 <augur> :t (==)
04:31:45 <lambdabot> forall a. (Eq a) => a -> a -> Bool
04:41:14 <SeySayux> Is haskell suited as a scripting language inside a C++ application?
04:44:32 <lantti> SeySayux: You would have to run Haskell realtime system to run Haskell code.
04:44:43 <lantti> I mean it has been done.
04:45:48 <lantti> There was a demo on alternative party last time that had some impressive number of languages used and RTSs and VMs running...
04:46:02 <lantti> I thing Haskell was used as well.
04:46:27 <SeySayux> Hmm, I guess Haskell wasn't designed to be an embedded language.
04:47:05 <rjo> maybe some LISP-variant?
04:47:14 <mauke> it does work
04:47:28 <SeySayux> Yea, I was thinking of Common Lisp too, and if everything fails, Lua.
04:47:39 <mauke> http://haskell.org/ghc/docs/7.0-latest/html/users_guide/ffi-ghc.html#using-own-main
04:48:48 <SeySayux> On a similar topic, can I call C functions from Haskell and vice versa?
04:49:37 <mauke> yes
04:50:47 <SeySayux> okay, I'm going to check if Lisp can be run as a scripting language inside C++.
04:51:03 <lantti> Yes you can. Calling functions is rather straight-forward but you might have to write some extra to handle datatypes that don't exist readily on both.
04:52:50 <SeySayux> Is Haskell interpreted, compiled or a VM language?
04:52:55 <mux> yay, my NFA with epsilon and any moves works fine; now to fix the determinization algorithm :-)
04:52:57 <Saizan> lantti: s/realtime/runtime/ :)
04:53:23 <lantti> Ah. True. :)
04:53:24 <Saizan> SeySayux: different implementations do different things
04:53:27 <qfr> Strictly speaking interpretation involves compilation, too, no?
04:54:20 <SeySayux> I mean, what do you ship? The script code, bytecode for a VM or compiled code for an OS?
04:54:23 <Saizan> SeySayux: ghc compiles to native binaries, it links in a garbage collector and some other support though
04:54:35 <hi> ok
04:55:08 <Saizan> SeySayux: so you'd ship "compiled code"
04:55:13 <SeySayux> I guess GHC is the most used compiler for Haskell (I'm really new to this, so forgive me my ignorance)
04:55:20 <Saizan> yep
04:55:22 <qfr> SeySayux yes
04:56:00 <Saizan> ghc also comes with ghci which is a bytecode interpreter, but it's mostly intended for developemrnt
04:56:19 <SeySayux> it seems ghc has a rts environment built in, perhaps I could check that out.
04:56:28 <Saizan> yep
04:56:29 <qfr> Why does ghc default to static linkage btw?
04:56:42 <qfr> Seems contrary to good deployment practice
04:56:42 <qfr> s
04:57:04 <Saizan> does it still default to that?
04:57:06 <SeySayux> Does it take long (i.e. C/C++ long) to compile a haskell program? (It seems the interpreter on the website does this fairly fast)
04:57:09 <qfr> Oh, it changed?
04:57:16 <qfr> I haven't compiled anything with ghc in such a long time
04:57:35 <qfr> SeySayux: It's considerably shorter than C++ mostly afaik
04:57:36 <ivanm> Saizan: yeah, you have to specify dynamic linking
04:57:43 <mauke> SeySayux: I'd say yes, especially if you enable -O2
04:57:53 <mauke> ok, C++ may take even longer
04:57:56 <ivanm> qfr: the dynamic linker was only recently implemented
04:58:03 <qfr> ivanm: Oh, I see
04:58:15 <rjo> well, javac is quite slow also
04:58:27 <ivanm> until recently, binaries were usually small enough that the RTS took up most of the filesize anyway, so dynamic linking wouldn't have helped
04:58:47 <qfr> RTS = ?
04:58:57 <SeySayux> I know that I can compile 1500 Java classes in about 20-30 seconds. The same amount of C++ code takes 10 minutes.
04:58:59 <ivanm> Run Time System
04:59:07 <ivanm> SeySayux: does javac do any optimisation?
04:59:19 <ddarius> ivanm: Presumably not too much.
04:59:28 <ivanm> ddarius: my point exactly
04:59:38 <ivanm> go enthusiasts say how great it is that the compiler is so fast
04:59:47 <ivanm> but hummed and hawed when I asked how much optimisations it did :p
04:59:53 <SeySayux> not much I guess, as it has to stay platform independent and most optimisation is platform dependent.
05:00:17 <ivanm> ghc takes a while because it is rather agressive in its optimisations
05:00:35 <rjo> in large systems Unit tests and CI has becomed a bottleneck in projects I've been involved
05:00:38 <ivanm> then again, IIRC jhc has shorter compile times, and when it works produces quite good binaries
05:00:47 <ivanm> rjo: "CI"?
05:00:57 <rjo> continuous integration
05:01:05 <ddarius> ivanm: If JHC has shorter compile times, this is news to me.
05:01:29 <ivanm> ddarius: maybe I mis-remembered *shrug*
05:01:49 <SeySayux> Does anyone knows what kind of parameters are used on the website? (I mean http://tryhaskell.org/)
05:02:28 <Saizan> that essentially uses ghci
05:03:16 <rjo> in those situations my limited experience shows that haskell might shine, due to parallelization and "properties" instead of unit tests
05:03:17 <Bynbo7> no compilation is necessary Saizan 
05:03:20 <Bynbo7> uh, SeySayux 
05:03:23 <parcs> interpreting haskell files is very fast
05:03:59 <SeySayux> Okay, then I might need an interpreter
05:04:01 <Kaidelong> given the choice, should I use cabal or aptitude to get happy and alex?
05:04:43 <SeySayux> I need to use this both for one-line commands (think kind of "cheat console") and longer scripts.
05:04:49 <parcs> i use my distro's package manager to install executables, and cabal for libraries
05:04:50 <Saizan> Kaidelong: i'd go with aptituded, especially since they are binaries
05:04:58 <Saizan> *executables
05:06:37 <Kaidelong> ah that was the smart thing to do since they were already installed as dependencies and now that marks them as manually installed
05:06:47 <balor> Is there a nop expression in Haskell, i.e. a function that is an expression but does nothing?
05:07:07 <lantti> ()
05:07:17 <lantti> (is it, I'm not sure :)
05:07:25 <balor> thanks
05:07:38 <ski> expressions don't "do", they "are"
05:08:00 <Kaidelong> balor: any such an expression likely won't be evaluated
05:08:19 <Kaidelong> I'm not sure how a no-op would make sense in haskell
05:08:22 <luite> so your question reduces to a function that is nothing: Nothing :)
05:08:26 <Kaidelong> since haskell is not imperative
05:08:27 * ski is wondering what balor really wanted this for ..
05:08:44 <alpounet> the "op" in "no-op" doesn't make sense in haskell
05:09:08 <balor> ski: I've a do block in which "Last statement in a do-block must be an expression", but I thought I had an expression there.
05:09:08 <ski> (balor : and just to make clear : neither `()' nor `Nothing' are functions)
05:09:10 * balor is n00b
05:09:39 <Kaidelong> what do you want the no-op for? the one practical application I remember is to disguise malware but that's irrelevant to haskell
05:09:46 <ski> balor : you probably either had `x <- foo' as the last command, or had indentation trouble
05:10:06 <balor> The snippet is http://hpaste.org/42681/moo
05:10:21 <ski> balor : not sure it's really what you want, but `return ()' is the monadic "no-op"
05:10:47 <ddarius> So he, clearly, is having identation problems.
05:10:50 <ski> right, `ok <- ...' is indented too little
05:10:54 <balor> ah
05:11:11 <ski> re, `ok $ ...', i.e.
05:11:24 <balor> Should be 4 spaces instead of 2?
05:11:42 <Kaidelong> why not just rewrite the thing without using do notation?
05:11:47 <ski> right
05:12:03 <ski>   getEntries =
05:12:11 <ski>     do methodM GET
05:12:21 <ski>         conf  <- query ReadConference
05:12:32 <ski>        ok $ <div><% conf %></div>
05:12:40 <ski> (er, s/ conf/conf/)
05:12:51 <mauke> and that's why we use pastebins
05:13:06 <ski> anyway, if you use `do', you don't need `(>>)'
05:14:21 * ski wonders how that would parse, without the `$'
05:15:07 <parcs> is <div><% conf %></div> some kind of crazy composition of combinators
05:16:07 <ski> probably it's special syntax that HSP desugars into something else
05:16:08 <balor> parcs: It's using HSP magic.
05:16:58 <balor> Thanks, I've rewritten as http://hpaste.org/42682/moo_annotation
05:18:13 <ski> hm, does that relly work ?
05:18:22 <balor> ski: not sure yet.
05:18:50 <ski> `methodM GET ok ...' looks problematic, to me
05:19:25 <balor> yeah, I broke it
05:19:48 <ski> (and if you really can use a `where' like that, then i think you should be able to replace `conf' by `query ReadConference')
05:20:00 <ski> ok
05:20:53 <johnnowak> hello all. simple question about 'assert'... presumably i'm missing something obvious: http://paste.lisp.org/display/118174
05:22:11 <byorgey> johnnowak: assert has type  Bool -> a -> a
05:22:23 <johnnowak> blarg!
05:22:36 <byorgey> Hoogle is your friend
05:22:42 <johnnowak> so base n = assert (n >= 2 && n <= 16) $! Base n then
05:22:54 <j-invariant> why do have you $1 and seq?
05:23:01 <j-invariant> what about assert ... (Base n)
05:23:59 <johnnowak> no reason
05:24:48 <johnnowak> just had assumed seq was needed when i thought it was Bool -> ()
05:25:45 <Kaidelong> well the value of applying "Bool -> ()" to a Bool could be _|_
05:25:53 <Kaidelong> depending on the function
05:28:50 <johnnowak> Kaidelong: right, but is it realy were Bool -> (), you'd have to force evaluation otherwise the assert would never be triggered
05:35:45 <Kaidelong> what is do recursive do used for exactly?
05:36:19 <Kaidelong> creating monads that are infinitely nested and then infinitely joined?
05:36:48 <mauke> what's an infinitely nested monad?
05:37:33 <Kaidelong> anything that contains itself, I guess
05:37:44 <Kaidelong> a list that contains itself
05:37:49 <Kaidelong> as an element
05:38:00 <burp> is there any HTTP library that allows me to just load a specified amount of data?
05:38:18 <burp> I tried http://hackage.haskell.org/package/http-enumerator-0.2.1.5 because it says it's lazy
05:38:26 <burp> but the loading itself is not ;)
05:38:49 <mauke> Kaidelong: that sounds like a type error
05:39:25 <Kaidelong> so what does mdo vs do do then?
05:39:57 <benmachine> it's not a type error exactly
05:40:07 <mauke> > let xs = [xs] in xs
05:40:08 <benmachine> it depends in what manner the list contains itself
05:40:08 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
05:40:22 <benmachine> and how loosely you use the word 'contained'
05:40:31 <mauke> Kaidelong: lets me use the result of a computation before the computation happens
05:40:56 <burp> BSL.take 10000 =<< H.simpleHttp url, this loads the full url
05:41:02 <benmachine> you could imagine something (contrived) like x <- 0 : repeat x
05:41:24 <Kaidelong> @ty let x = join (return x) in x
05:41:25 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a
05:41:40 <benmachine> burp: first of all, how do you know, secondly, perhaps you need the non-simple interface?
05:41:40 <Kaidelong> huh
05:41:42 <Kaidelong> that works
05:41:58 <ddarius> Kaidelong: It's just like a recursive let in an imperative language (like Scheme.)
05:42:03 <mauke> > let x = join (return x) in length x
05:42:07 <lambdabot>   mueval-core: Time limit exceeded
05:42:12 <blubsala> somebody willing to review my code?
05:42:13 <blubsala> https://gist.github.com/761012
05:42:54 <parcs> blubsala: instead of fmap read $ findAttr (rssQName "fileSize") e you can do read <$> findAttr ...
05:43:26 <ivanm> blubsala: if you're going to derive Show, derive Read as well
05:43:35 <ivanm> and you might as well do Eq and Ord if possible
05:43:50 <sipa> :t fix
05:43:52 <lambdabot> forall a. (a -> a) -> a
05:43:57 <burp> benmachine: how do I know that I just need 10000 bytes? I just want to extract the title tag of html pages; and you're rightâ€¦ I should look at the non-simple interface
05:44:06 <ivanm> blubsala: also try running hlint on it
05:44:15 <blubsala> ok thx
05:44:18 <Kaidelong> so it lets you use the result of the computation before the computation happens, in the same computation?
05:44:52 <Kaidelong> or is it recursive in some other way?
05:45:05 <benmachine> burp: I meant how did you know it was getting the whole page :) but yeah I think the non-simple interface will work for you
05:45:33 <benmachine> Kaidelong: something like that, yeah
05:45:36 <ivanm> Kaidelong: what, fix?
05:45:41 <Kaidelong> mdo
05:45:44 <ivanm> ahhh
05:45:51 <sipa> :t rec
05:45:52 <lambdabot> <no location info>: not an expression: `rec'
05:45:58 <burp> benmachine: oh; I used a 100MB testfile url ;)
05:46:06 <burp> and watched the traffic grow
05:46:19 <mauke> :t fix
05:46:20 <benmachine> oh right
05:46:20 <lambdabot> forall a. (a -> a) -> a
05:46:22 <mauke> :t mfix
05:46:23 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
05:46:26 <burp> and the non-simple interface will do "Even though a Response contains a lazy bytestring, this function does not utilize lazy I/O, and therefore the entire response body will live in memory. If you want constant memory usage, you'll need to write your own iteratee and use http or httpRedirect directly."
05:46:41 <Kaidelong> @src mfix
05:46:41 <lambdabot> Source not found. Just what do you think you're doing Dave?
05:46:46 <mauke> @src MonadFix
05:46:47 <lambdabot> class (Monad m) => MonadFix m where
05:46:47 <lambdabot>     mfix :: (a -> m a) -> m a
05:46:47 <ski> Kaidelong : e.g. `mdo ref <- newIORef (...ref...); ..ref..'
05:46:55 <benmachine> burp: right, you need to use iteratees
05:47:07 <mauke> > mdo return ()
05:47:08 <lambdabot>   No instance for (GHC.Show.Show (t ()))
05:47:08 <lambdabot>    arising from a use of `M106384882...
05:47:17 <mauke> > mdo return () :: [()]
05:47:18 <lambdabot>   [()]
05:47:39 <Kaidelong> > do return () :: [()]
05:47:40 <lambdabot>   [()]
05:48:24 <benmachine> burp: I'm told that using iteratees is much easier than understanding them :P
05:48:46 <mauke> that's almost like programming! I don't want that!!
05:48:49 <burp> benmachine: ok, O hope so :D
05:49:33 <ski> > map (take 4) $ mdo xs <- [0:map succ xs,1:map (2 *) xs]; return xs  -- hm
05:49:34 <lambdabot>   [[0,1,2,3],[1,2,4,8]]
05:50:09 <ddarius> mdo xRef <- newIORef (1, yRef); yRef <- newIORef (2,xRef); return xRef
05:50:26 <mauke> needs more loeb
05:50:39 <ManateeLazyCat> Hi all. :)
05:51:04 <ski>   newtype ListCell ref a = Nil | Cons a (ref (ListCell ref a))
05:51:23 <ski>   mdo xRef <- newIORef (Cons 1 yRef); yRef <- newIORef (Cons 2 xRef); return xRef
05:51:41 <benmachine> neat!
05:51:41 <ManateeLazyCat> I like ThinkPad, but i hate TouchPad, always move cursor.
05:51:43 <ski>   type List ref a = ref (ListCell ref a)
05:51:48 <mauke> ski: unexpected '|', expected type name
05:52:17 <benmachine> *data
05:52:27 <ski> oh, right
05:52:41 <ski> (dunno why i wrote `data' at all)
06:03:01 <mreh> I have two installations of the same version of bytestring
06:03:17 <byorgey> let me guess, one global and the other local
06:03:49 <mreh> yes
06:03:58 <mreh> has I done bad?
06:04:05 <byorgey> no, it's a bug in cabal
06:04:26 <byorgey> try unregistering all the local versions of packages that are installed twice
06:04:31 <byorgey> but that doesn't always work
06:04:46 <byorgey> sometimes cabal just gets confused and insists on reinstalling lots of stuff, and I don't know how to fix it
06:04:58 <byorgey> occasionally I just nuke my package database and start over =(
06:05:17 <JuanDaugherty> it's a haskel community cultural quirk 
06:05:19 <mreh> is package management a complicated process?
06:05:47 <JuanDaugherty> .oO(supposed 2b 'schmal' I guess) 
06:06:14 <ivanm> mreh: it's bad in the sense that bytestring is a boot library and thus shouldn't be upgraded
06:06:16 * hackagebot bindings-audiofile 0.1.0.2 - Low level bindings to audiofile  http://hackage.haskell.org/package/bindings-audiofile-0.1.0.2 (MasatakeDaimon)
06:06:29 <ivanm> preflex: seen edwardk
06:06:30 <preflex>  edwardk was last seen on #haskell 4 days, 15 hours, 21 minutes and 22 seconds ago, saying: revenantphx: sorry, not familiar with the type signatures here in this lib, which is why i wanted to hack up something locally first ;)
06:06:57 <JuanDaugherty> extreme well foundedness at the core, half assed brokenness at the dealing with the real world level
06:08:40 <byorgey> mreh: actually, you might surprised how complicated it actually is.
06:08:58 <byorgey> aaaaaaand I just used 'actually' twice in the same sentence.
06:09:27 <mreh> I sentence you to death
06:09:32 <byorgey> I had this horrible science teacher in 8th grade whose favorite word was 'actually'
06:09:51 <byorgey> we used to count how many times she said it each class, I think the record was like 37 or something
06:10:07 <mreh> Cannot find gtk2hsC2hs
06:10:07 <mreh> Please install `gtk2hs-buildtools` first and check that the install directory is in your PATH (e.g. HOME/.cabal/bin).
06:10:36 <mreh> sry
06:11:09 <mreh> trying out leksah
06:11:26 <mreh> vim is too... complicated
06:11:40 <mreh> buffers tabs windows
06:11:52 <tomjnixon> s/complicated/awesome/
06:11:59 <tomjnixon> (sorry)
06:12:21 <HugoDaniel> happy new year haskellers!
06:12:25 <mreh> I don't have the real estate to have 7 windows open at once
06:12:39 <mauke> you can ignore buffers and tabs
06:12:49 <mreh> and the tab system is like a bunion on its face
06:13:23 <mux> @src Set mappend
06:13:23 <lambdabot> Source not found. :(
06:13:24 * ddarius is an idiot.
06:13:36 <ManateeLazyCat> mreh: Now gtk2hs install ?
06:13:50 <tomjnixon> mreh: what's wrong with it? use ':tabnew <file>' to open a file in a new tab, then gt and gT to switch backwards/forwards.
06:14:15 <ManateeLazyCat> brb, leave message to me, if you don't know how to fix.
06:14:33 <mreh> ManateeLazyCat: okay thanks
06:14:38 <j-invariant> I don't think im smart tenough to use haskell
06:15:04 <mauke> preflex: re "a+." smart
06:15:06 <preflex>  match: [ar]
06:15:49 <mreh> tomjnixon, well partially because gt/gT is one stroke too many, and I've been told to abandon hope of one buffer per tab
06:16:42 <tomjnixon> mreh: you could always rebind them to something more to your preference?
06:17:01 <mreh> tomjnixon: yes, that's only a petty gripe :)
06:18:13 <tomjnixon> mreh: ah, ok ;)  it's probably better than the alternative of having to use ctrl anyway.
06:18:31 <mreh> tomjnixon, but ctrl is modal
06:18:58 <ManateeLazyCat> j-invariant: Don't give up
06:19:02 <mreh> and I can hold it down with my pinky
06:19:32 <j-invariant> I did give up :(
06:19:43 <rjo> I've trying now actively about three weeks to learn
06:19:58 <mreh> it's taken me two years ;)
06:20:02 <rjo> I've estimated that I'll be effective after three years
06:20:26 <mreh> rjo: I'm still not there
06:21:07 <winxordie> j-invariant: I take it you're here for the #company then? :P
06:21:19 <j-invariant> :)
06:21:35 <winxordie> Haha fair enough.
06:21:59 <j-invariant> I cthink haskell is cool but I don't do it
06:22:20 <mreh> haskell is the language of posers
06:22:23 <winxordie> It's a reasonable position to take.
06:22:25 <tomjnixon> mreh: it's still in the wrong place to press easily, unless you're one of those poor people who still has caps lock rebound to ctrl from when they used to use emacs :D
06:22:28 * mauke strikes a pose
06:22:29 <rjo> j-invariant, have you read sicp
06:22:32 <j-invariant> yes
06:22:36 <j-invariant> SICP is great
06:23:05 <nostrand> j-invariant: if you are smart enough for sicp you are smart enough for Haskell =)
06:23:11 <mreh> tomjnixon, well no, but I like to quickly flip through tabs
06:23:20 <mreh> I have little screen realestate
06:23:34 <mreh> 1300x1080 approx
06:24:40 <tomjnixon> mreh: <n>gt will switch to the nth tab (3gt for third etc...). that fast enough?
06:26:32 <unkanon_> tomjnixon: you don't map your caps lock to ctrl? (I don't use emacs and I do)
06:26:55 <benmachine> I map it to escape
06:26:56 <tomjnixon> unkanon_: vim users map it to escape.
06:27:45 <unkanon_> not all of them. I map jj to escape. my caps lock is ctrl.
06:28:09 <mreh> any leksah users?
06:28:14 <mreh> I mean yi
06:29:14 <mreh> tomjnixon: too much counting :)
06:30:02 <Raynes> I've used Emacs for a couple of years. I never actually minded ctrl being ctrl. I switched it mostly for novelty and to see what the fuss was about.
06:30:51 <Kaidelong> computer shut off due to overheating while cabal was running
06:30:54 <Kaidelong> should I be worried?
06:31:09 <Kaidelong> cabal-install, specifically
06:31:12 <dschoepe> Kaidelong: depends on what else was running, I'd say
06:31:53 <mreh> time to upgrade possibly?
06:31:53 <rjo> I usually use screen or virtua screens instead of tabs
06:32:22 <monadic_kid> I'd be more concerned about your computer than a piece of software, it sounds like the fans are probably wearing out.
06:32:30 <mreh> disadvantage there is you have to start a new vim every time you open a new "tab"
06:33:57 * ddarius just uses buffers and knows nothing about tabs in vim.
06:35:14 <earthy> they're another layer on top of windows and buffers
06:36:24 <Kaidelong> it is a laptop monadic_kid
06:36:24 <allbery_b> (vim is to emacs what emacs' vi mode is to vi :)
06:36:28 <j-invariant> what's so good about Yoneda lemma anyway?
06:36:33 <Kaidelong> but I'll take some CO2 to the vents
06:37:04 <Kaidelong> well it is a couple of years old netbook, so maybe I should think of a new one
06:38:32 <monadic_kid> laptops can have fans, in any case no compoonent has an infinite life span, sounds like something is wearing out and making the laptop overheat or you're not giving enough space for ventilation
06:39:23 * mux hearts Foldable
06:39:32 <Kaidelong> probably the latter
06:40:48 <ddarius> j-invariant: Not starting all your questions with "what's the point" will be a useful skill for you to develop.
06:41:27 <mreh> I interpreted that as curiosity
06:41:45 <mreh> he's clearly taken an interest in it
06:42:17 <j-invariant> the monad is way cool
06:43:32 <Philippa_> what's cooler is how close Landin came to it in '65
06:43:35 <ddarius> mreh: My statement wasn't based solely on that one question.
06:45:04 <mreh> ddarius: okay ;)
06:45:37 <j-invariant> I don't know Hinze says to use Yoneda lemma
06:45:55 <ddarius> Philippa_: I'm pretty sure state passing either was known or was in the air at that time, and we don't say that all the other uses of state passing (or continuation passing or error propagation) in denotational semantics are semanticists discovering monads.
06:46:07 <j-invariant> Reason Isomorphically!
06:46:53 <banisterfiend> Philippa_: wow a female programmer
06:47:03 * ddarius goes to take a shower.
06:47:09 <banisterfiend> Philippa_: are you asian?
06:47:12 <Saizan> "as a corollary to the yoneda lemma you can prove that two objects are isomorphic by proving arrows from them are" seems to be an accurate summary of that talk :)
06:47:32 <j-invariant> but the proof doesn't give you a function
06:47:51 <j-invariant> when you prove isomorphism by actually constructing the function -  it's better
06:51:33 <Saizan> i think you probably can write the proof in a dep. typed language in a way that you get a function out of it too, but i'd have to try it out
06:56:08 <marel> Hey, could you guys http://overclock.lt/?kvietimas=sbl enter any nickname and email, confirmation is not needed.
07:03:31 * hackagebot mysnapsession 0.1.2 - Memory-backed sessions and continuations for Snap web apps  http://hackage.haskell.org/package/mysnapsession-0.1.2 (ChrisSmith)
07:03:44 <ddarius> The proof of the Yoneda lemma and that corollary readily gives you the isomorphism at either level.
07:08:33 <Saizan> ddarius: which levels? the source category and Set?
07:09:20 <ddarius> If you have a natural transformation between hom-functors you can get the arrow, and vice versa.
07:10:17 <ddarius> You'd have to go to some effort to make a non-constructive proof of Yoneda.
07:13:22 <lars9> 2011 in 48 minutes
07:13:50 <lars9> 1/12 of the world is in 2011 now
07:14:20 <medfly> I don't think that's... oh
07:14:36 <medfly> I keep such poor track of it I thought maybe it was the other day because so many people were talking about it.
07:15:33 <ddarius> Perhaps you're stuck in a time loop.
07:16:31 <lars9> ddarius: did we talk about regex in haskell?
07:16:45 <lars9> ddarius: im not sure if it was you or someone else
07:16:56 <ddarius> Probably someone else.
07:17:05 <lars9> aye see
07:17:49 <ManateeLazyCat> Hmm, uswsusp have bug that break my boot process.
07:18:44 <lars9> that sounds like oos-oos-oosp
07:21:33 <ManateeLazyCat> Good, my new laptop support Hardware accelerate, try KVM
07:23:56 <monadic_kid> "hardware acceletrate"? you mean you laptop's CPU has hardware-assisted virtualization support?
07:24:27 <ManateeLazyCat> monadic_kid: Yes.
07:24:43 <ManateeLazyCat> monadic_kid: I enable it from BIOS
07:25:02 <ManateeLazyCat> I believe KVM is much fast than VirtualBox.
07:25:05 <monadic_kid> ManateeLazyCat: sure, just the way you worded it came out a bit odd
07:25:18 <ManateeLazyCat> monadic_kid: :)
07:25:50 <ManateeLazyCat> monadic_kid: I try my new laptop, 4-core CPU/DDR-III 1066/320GB disk 7200.... :)
07:26:21 * ManateeLazyCat Ok, install ghc-6.12.3
07:27:23 <monadic_kid> KVM is much faster than virtualbox? I never I had performance issues with virtualbox. it supports utilizing vtx and graphics hardware acceleration
07:27:57 <ManateeLazyCat> monadic_kid: I haven't try KVM, but i hard many people talk KVM is fastest one. :)
07:28:03 <ManateeLazyCat> s/hard/heard
07:29:21 <hpc> KVM isn't virtualization, so it will inevitably be faster
07:29:55 <hpc> you only get one "instance" with KVM though
07:30:31 <ManateeLazyCat> hpc: Good to know that. :)
07:30:54 <MHD0> I'm messing around with some openGL, what's the haskell equivalent of "glMatrixMode(GL_PROJECTION)"?
07:31:15 <MHD0> No, sorry, GL_MODELVIEW
07:31:25 <tab> hpc: one instance of what ?
07:31:34 <MHD0> I see that Modelview takes an argument? Why is that?
07:31:44 <hpc> tab: you can copy a virtual hard drive and run both at the same time
07:31:50 <hpc> tab: or you can ssh into a computer multiple times
07:32:03 <hpc> tab: but double-KVM works like having two keyboards plugged in
07:32:25 <hpc> so you don't get to do twice as much
07:32:28 <hpc> you just fight for control
07:32:40 <tab> hpc: are you talking of kernel VM or keyboard video multiplexer ?
07:32:48 <hpc> oh, the latter
07:32:51 <sipa> lol
07:32:54 <hpc> didn't know about the first...
07:32:56 <sipa> i was about to ask the same thing
07:33:12 <tab> hpc: :)
07:33:18 <hpc> <.<
07:33:21 <hpc> >.>
07:33:23 <tab> it's a bit confusing they choose this name i guess
07:34:31 <monadic_kid> MHD0: matrixMode =: Modelview
07:34:49 <monadic_kid> MHD0: oh yeah i see the argument
07:35:17 <monadic_kid> MHD0: Modelview 0
07:35:25 <MHD0> monadic_kid: Ok, thanks.
07:35:49 <monadic_kid> MHD0: it's in the module Graphics.Rendering.OpenGL.GL.CoordTrans
07:36:12 <MHD0> monadic_kid: Yeah
07:36:17 <monadic_kid> MHD0: I don't understand what the extra argument is for either
07:36:37 <MHD0> monadic_kid: I think that you can have different modelview stacks?
07:36:55 <monadic_kid> MHD0: you can have a matrix stack for textures as well
07:37:26 <MHD0> monadic_kid: Yeah, the GL_TEXTURES or somthing
07:38:59 <monadic_kid> MHD0: at first i thought that maybe it was to specify the stack position but that doesn't make much sense since the other matrix modes don't have it
07:40:16 <monadic_kid> MHD0: docs says "of the specified vertex unit"
07:40:51 <MHD0> monadic_kid: Yeah, hell if I know.
07:53:38 <token22> hey
07:54:54 <token22> need help, i am trying to create class that aplies +,-,*,.. to bin. trees but i always get error Ambiguous variable occurrence "+"
07:56:44 <mauke> and it also tells you why it's ambiguous
07:57:15 <token22> well there is also this Could refer to: Main.+ Hugs.Prelude.+
07:57:20 <mauke> yes
07:57:35 <mauke> that's the two possibilities
07:57:51 <monadic_kid> why do you want all of those operators for binary trees?
07:58:12 <monadic_kid> is this for a DSL?
08:00:22 <xcthulhu> monadic_kid, Binary trees are monoids so + sort of makes sense... but he should really be using the monoid class if this is what he has in mind
08:00:27 <token22> acutally i need to practise in haskell (doesn't matter if it is not usefull or it already exist in some libraries because of school)
08:00:36 <xcthulhu> Or monadplus
08:00:48 <monadic_kid> xchtulhu: i know that but a monoid is just two operations
08:01:09 <monadic_kid> xchtulhu: why do you need *,-
08:01:11 <xcthulhu> Right.  I don't know what it means to subtract one binary tree from another
08:01:22 <xcthulhu> Multiplication = pairing?
08:02:23 * xcthulhu isn't sure if you can take products of binary trees like you can with posets and lattices and whatnot
08:02:36 <token22> e.g. i wrote this:tzipWith f (Node v1 l1 r1) (Node v2 l2 r2) = Node (v1 `f` v2) (tzipWith f l1 l2) (tzipWith f r1 r2)
08:03:12 <token22> and i want to this function was called when i typed tree1+tree2 (f = (+))
08:03:15 <ddarius> xcthulhu: What operation on binary trees are you considering (+) to be?
08:04:54 <Zao> Magic.
08:04:57 <token22> well conjuction i guess
08:06:19 <xcthulhu> ddarius, (+) (Node a b c) tree2 = Node a ((+) b tree2) ((+) c tree2) ; (+) (Leaf a) tree2 = Node a tree2 tree2
08:06:40 <xcthulhu> ddarius, And then I write that, and I realize that binary trees are a very awkward monoid...
08:06:51 <xcthulhu> And that I need more coffee
08:08:07 <mauke> coffeoid
08:09:21 <xcthulhu> coffee = the ffee category with all the arrows reversed
08:10:33 <xcthulhu> token22, How do you think that (*) works for binary trees?
08:11:06 <ManateeLazyCat> Happy new year all. :)
08:11:18 <Entroacceptor> :)
08:11:25 <Entroacceptor> you're in the wrong timezone
08:11:28 <xcthulhu> Happy new year ManateeLazyCat 
08:11:35 <Entroacceptor> but happy new year to you
08:11:44 <ManateeLazyCat> @time
08:11:45 <lambdabot> Local time for ManateeLazyCat is Sat Jan  1 00:10:51 2011
08:11:45 <Entroacceptor> I'm off, getting ready for the party
08:11:52 <Entroacceptor> @time
08:11:54 <token22> i mean i have BTree Int which contains only Integer
08:11:55 <lambdabot> Local time for Entroacceptor is Fri Dec 31 17:11:25 2010
08:11:58 <mauke> zomg, future
08:12:03 <Entroacceptor> see, yours is wrong
08:12:09 <mauke> @time xcthulhu 
08:12:10 <lambdabot> Local time for xcthulhu is Fri Dec 31 09:11:42
08:12:13 <ManateeLazyCat> Ah, Chinese has in new year. :)
08:12:18 <ManateeLazyCat> Haha.
08:12:30 <ManateeLazyCat> Entroacceptor: My time is faster. :)
08:12:30 <mauke> @time mauke
08:12:33 <lambdabot> Local time for mauke is 25:12:62 AM
08:13:06 <Entroacceptor> oh, wrong brane
08:13:34 <token22> but my problem is not with trees but with classes
08:15:12 <xcthulhu> token22, Well... I tend to like my type classes to obey mathematical axioms.  For instance, if you have both + and - instances for a type you should be able to prove the ring axioms for them
08:15:38 <xcthulhu> erm, + and - and *
08:16:39 <ddarius> xcthulhu: Don't look at Double then.
08:16:55 <xcthulhu> ddarius, Yes yes, it's all pretend
08:20:37 <xcthulhu> I know this is biggotted of me, but I don't think that floating point is actually numbers.  ...I sometimes think that maybe Haskell should follow OCaml, and have +. and -. and so on for floating points, just to remind you that they aren't really numbers.
08:20:59 <JuanDaugherty> floating point are not real numbers
08:21:09 <JuanDaugherty> i.e R
08:21:14 <xcthulhu> They aren't any kind of numbers
08:21:38 <JuanDaugherty> they certainly are
08:21:55 <xcthulhu> Are they a field?  Or a ring?  Or even a monoid?
08:22:17 <JuanDaugherty> irritatingly I had a paper on the gap functions mapping floats to reals about 30 years ago but haven't been able to find it since
08:22:45 <JuanDaugherty> the application area is analytic number theory 
08:22:55 <xcthulhu> google scholar?
08:22:59 <JuanDaugherty> and of course numerical methods and the like
08:23:32 <JuanDaugherty> Bellman's book on Analytic Number Theory is a gem
08:23:46 <ddarius> xcthulhu: Addition isn't a monoid nor multiplication.  Hell, equality isn't even an equivalence relation.
08:24:50 <xcthulhu> ddarius, Well, you can't actually enforce any axioms in Haskell
08:25:01 <xcthulhu> So Monads aren't really monads
08:26:31 <ddarius> xcthulhu: I was talking about on floating point numbers.
08:27:26 <xcthulhu> ddarius, Oh.  Wait, can you give an example where equality is no longer an equivalence relation?
08:27:44 <copumpkin> > (0 / 0) == (0 / 0)
08:27:45 <lambdabot>   False
08:28:00 <xcthulhu> > :t (0 / 0)
08:28:01 <lambdabot>   <no location info>: parse error on input `:'
08:28:07 <copumpkin> :t (0 / 0)
08:28:08 <lambdabot> forall t. (Fractional t) => t
08:28:16 <copumpkin> it's a double or float there
08:28:41 <dixie> > 0 / 0
08:28:42 <lambdabot>   NaN
08:28:46 <ddarius> xcthulhu: I'm pretty sure addition and multiplication are commutative though.
08:29:06 <sipa> xcthulhu: but not associative
08:29:27 <JuanDaugherty> Ramon E. Moore's 'Interval Analysis" is also good for this
08:29:31 <xcthulhu> sipa, That's right.  And you can shoot yourself in the foot
08:29:38 <JuanDaugherty> s/"/'/
08:29:41 <xcthulhu> JuanDaugherty, That's not a definition of a number...
08:29:56 <JuanDaugherty> what isn't?
08:30:03 <JuanDaugherty> a dedekind cut?
08:30:06 <xcthulhu> Your reference.
08:30:17 <xcthulhu> JuanDaugherty, I asked you for a definition a while back...
08:31:04 <JuanDaugherty> floats are just logarithms in and of themselves, ignoring for a moment thier use in mapping to reals
08:32:29 <xcthulhu> JuanDaugherty, would you consider the constructable ordinals to be numbers?
08:33:05 * xcthulhu supposes that maybe semi-rings are numbers
08:36:15 <JuanDaugherty> xcthulhu, I consider "number" to be an English word that can be applied with rigor to a host of specific application context about quantity
08:36:37 <JuanDaugherty> including transfinites, fuzzy numbers, etc.
08:36:57 <JuanDaugherty> fuzzy numbers = linguistic values, rigorously defined
08:37:30 <masonkramer> Newbie questions about Haskell, if anyone's got the time:  What's the best way to dump a variable to STDIN and see its type and contents?
08:37:56 <JuanDaugherty> *contexts
08:37:59 <sipa> :t print
08:38:01 <lambdabot> forall a. (Show a) => a -> IO ()
08:38:52 <masonkramer> wow, that's a pretty informative type system
08:39:20 <masonkramer> eh, hmm
08:39:25 <masonkramer> what's an m [Char] then?
08:40:33 <sipa> masonkramer: m typically stands for "any monad"
08:40:35 <JuanDaugherty> http://www.computer.org/portal/web/csdl/doi/10.1109/T-C.1970.223017 may be the one I was referring to.
08:40:43 <sipa> and [] means "list of"
08:40:49 <sipa> and String is an alias for [Char]
08:41:23 <masonkramer> I ask, because I can't print an m [Char], apparently
08:41:24 <masonkramer> http://hpaste.org/42684/yaht_exercise_help
08:41:47 <masonkramer> nor can I use the function I tried to create, putStrLns, to do it
08:42:21 <mauke> masonkramer: what's that 'return' doing in fact_info?
08:42:29 <mauke> masonkramer: also, (x) is the same as x
08:42:41 <masonkramer> ooh, good
08:42:49 <masonkramer> mauke's here!
08:42:59 <mauke> I AM HERE TO THE RESCUE
08:43:28 <Hilbert> Hey is is possible to efficent factorial function in haskell that used memorisation
08:43:58 <mauke> Hilbert: I'd just make a list of all factorials
08:44:29 <hpc> :t fix product
08:44:30 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
08:44:30 <lambdabot>       Expected type: [a]
08:44:30 <lambdabot>       Inferred type: a
08:45:22 <mauke> possibly related: http://mauke.ath.cx/stuff/haskell/how-to-io.html
08:45:28 <mauke> and I should really continue it some time
08:48:18 <masonkramer> mauke: so it was the return in fact_info that was causing my problem?
08:48:30 <mauke> yes
08:48:41 <mauke> one of them, at least
08:48:54 <masonkramer> after removing that, it worked
08:49:00 <masonkramer> so returns are for do expressions only?
08:49:15 <mauke> 'return' is a virtual constructor
08:49:23 <mauke> it's not a keyword or anything; it's a library function
08:49:46 <sipa> masonkramer: not only, return is just a function, like many others
08:49:58 <sipa> but typically it is used in do blocks
08:52:47 <masonkramer> Thanks guys.  
09:01:38 <Hilbert> Hey how do I modify this to work on an array instead of a list facs = scanl (*) 1 [1..]
09:03:37 <monochrom> facs = listArray (0, 1) (scanl (*) 1 [1..])
09:03:53 <sipa> :t listArray
09:03:54 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
09:06:03 <Hilbert> Thanks how do I access the ith element of an array
09:09:03 <tomjnixon> Hilbert: http://hackage.haskell.org/packages/archive/haskell98/latest/doc/html/Array.html
09:14:11 <sid3k> hi all. I've implemented curry in another language and couldn't write a simple description for api doc
09:14:16 <sid3k> any ideas? 
09:15:02 <ddarius> The type of curry pretty much says everything.
09:16:14 <sid3k> ddarius: like?
09:17:09 <Jesin> hmm
09:17:32 <Jesin> lambdabot should probably support the ":k" and ":t" abbreviations in privmsg
09:17:55 <Jesin> as it is it supports "@type" and "@kind" in privmsg, but not those abbreviations
09:19:53 <sid3k> my current explonation is: Transform 'fn' into a chain of functions each with a part of the arguments of 'fn'
09:28:52 <monochrom> let g be curry f. then g x y = f (x,y). a formula is worth a thousand pictures.
09:29:57 <ddarius> @djinn ((a,b) -> c) -> a -> b -> c
09:29:58 <lambdabot> f a b c = a (b, c)
09:32:25 <Eduard_Munteanu> This officially sucks... I just realized my mutable STRef trees can't share unless I use pointers to pointers, or some sort of mutable pointers.
09:33:05 <Kaidelong> @pl \a b c -> a (b, c)
09:33:06 <lambdabot> (. (,)) . (.)
09:33:11 <Kaidelong> oh my
09:34:36 <olsner> Eduard_Munteanu: FixF STRef :)
09:34:50 <Eduard_Munteanu> Heh.
09:34:54 <Eduard_Munteanu> Is FixF like Mu?
09:35:06 <lelf> ?pl \a (b,c) -> a b c
09:35:06 <lambdabot> (`ap` snd) . (. fst)
09:35:30 <ddarius> Eduard_Munteanu: Why would you be unable to share?
09:36:27 <olsner> Eduard_Munteanu: yeah, I think so: newtype FixF f = InF { outF :: f (FixF f) }
09:36:28 <Eduard_Munteanu> ddarius: consider a fork. The left STRef points to a subtree. That subtree has a parent pointer, but it essentially duplicates the parent.
09:36:59 <Eduard_Munteanu> ddarius: the underlying pointers of STRef aren't shared, they're actually different allocations.
09:37:20 <Jesin> @unpl (. (,)) . (.)
09:37:20 <lambdabot> (\ g j d -> g (((,)) j d))
09:37:34 <ddarius> Eduard_Munteanu: Why would it duplicate the parent?
09:37:37 <olsner> your nodes point to their parents? if you need parent pointers I think you can just keep that in whatever traverses the tree rather than in the nodes
09:38:09 <olsner> which I think is equivalent to using a zipper
09:39:40 <Eduard_Munteanu> ddarius: okay, another approach. X has a child Y, who has a child Z. X has a pointer to Y, and Z has a (parent) pointer to Y, but the pointers are different. So the storage is allocated three times for Y: once in itself if we hold a reference to it, then in X, then in Z.
09:39:50 <Kaidelong> aren't mutable trees a bad idea in general?
09:40:04 <Eduard_Munteanu> olsner: unfortunately I can't use zippers because I need to be able to access the leaves directly.
09:40:20 <Eduard_Munteanu> Kaidelong: I think so, but I see no way around it.
09:40:23 <ddarius> Eduard_Munteanu: Other than the pointer itself, they should all be using the same Y.
09:41:51 <Eduard_Munteanu> ddarius: doesn't each STRef use up space when you write into it, regardless if there's the same value everywhere? Like  do x <- newSTRef 0; y <- newSTRef 0; z <- newSTRef 0   will have separate allocations, right?
09:42:20 <ddarius> Yes, that would be the "pointer itself" that I was referring too.
09:42:25 <Eduard_Munteanu> Or does it work somewhat like COW?
09:42:32 <ddarius> You still aren't duplicating Y.
09:43:02 <ddarius> Unless you are explicitly recreating Y, in which case you are doing it wrong.
09:43:32 <Kaidelong> why is there is a need for a mutable tree as opposed to copying spines?
09:43:38 <Kaidelong> err, changing spines
09:43:41 <Eduard_Munteanu> http://paste.pocoo.org/show/312533/    -- replace ain't working yet, I'm working on it.
09:44:10 <Eduard_Munteanu> Kaidelong: I need to be able to hold a map of the leaves, and be able to mutate the tree without recreating the map.
09:45:17 <Eduard_Munteanu> ddarius: I'm not really sure if that's the case there ^ :/
09:45:25 <Kaidelong> hmm, that'd require pointers to parents unless you want to traverse the whole tree every time you change the leaves
09:45:46 <ddarius> Eduard_Munteanu: Unless you are calling newNode, you are not creating new trees.
09:46:37 <Eduard_Munteanu> ddarius: okay, so although the pointers are duplicated, they point at the same storage. Thanks.
09:46:58 <Eduard_Munteanu> I thought the semantics of newSTRef is a bit like malloc() :)
09:47:07 <Eduard_Munteanu> s/is/was/
09:47:08 <ddarius> Eduard_Munteanu: It is.
09:47:15 <ddarius> It mallocs one cell.
09:47:27 <ddarius> It behaves just like references in every other imperative language.
09:48:42 <ddarius> Also, use maybe more.
09:48:43 <ddarius> :t maybe
09:48:44 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
09:48:45 <Eduard_Munteanu> ddarius: but if we malloc one cell for 'left', then we malloc one cell for 'parent', how come they're shared when *left = *parent?
09:48:58 <Eduard_Munteanu> Ah, thanks.
09:48:58 <Argue> happy new year to all you folks in the channel i sometimes read but seldom write in
09:49:13 <Eduard_Munteanu> Happy new year Argue and everybody!
09:50:00 <Eduard_Munteanu> ddarius: note I'm not actually able to mutate the STRefs themselves, because it would require STRefs to STRefs :/
09:50:02 <ddarius> Eduard_Munteanu: They aren't, but the actual parent isn't the cell, it is a -tree- which is a data structure containing a bunch of stuff.
09:51:05 <Eduard_Munteanu> ddarius: hm. Should I make 'value' into a STRef as well?
09:51:30 <ddarius> Eduard_Munteanu: In fork, both of the parents of l and r point at p.  If you mutate p that change will be visible to l and r.
09:51:34 <Eduard_Munteanu> Technically that should do more sharing in case 'a' is something big.
09:52:33 <ddarius> a is shared along with everything else.
09:52:54 <ddarius> value should only be an STRef if you need to mutate it.
09:53:01 <Eduard_Munteanu> ddarius: how so? I have a newSTRef for 'l' and 'r', this is how my newNode works currently.
09:53:06 <taotree> I see this regarding Takusen: "Takusen can avoid loading the whole result set in memory, and so can handle queries returning millions of rows in constant space."   Does that mean HDBC and HSQL load entire result sets into memory? In my situation, I want to run through millions of rows so...
09:53:40 <Eduard_Munteanu> ddarius: it doesn't strike me why l->parent would share with r->parent.
09:53:54 <ddarius> Eduard_Munteanu: In fork, you are setting them to the -same thing-.
09:54:35 <c_wraith> taotree, HDBC has convenience functions that load the whole result set into memory, but provides low-level primitives to let you avoid doing so.  I haven't used HSQL, so I don't know about it.
09:55:04 <Eduard_Munteanu> Oh, yeah.
09:55:07 <ManateeLazyCat> Fix install docs, enjoy! :)
09:55:21 <ddarius> If you do the equivalent of l->parent = something else, r->parent will remain, but if you do l->parent->foo = 3, r->parent->foo will be 3.
09:56:06 <taotree> c_wraith, thanks!
09:56:07 <Eduard_Munteanu> ddarius: I suppose my 'replace' is really broken though.
09:56:18 * hackagebot manatee 0.1.7 - The Haskell/Gtk+ Integrated Live Environment  http://hackage.haskell.org/package/manatee-0.1.7 (AndyStewart)
09:56:49 <Eduard_Munteanu> ddarius: I kinda need to update the specific pointers instead of 'this', perhaps maintain a Ctx = L | R to know which parent left/right pointer to update.
09:56:55 <ddarius> Eduard_Munteanu: I don't know what it's supposed to do, and the this field seems nonsensical.
09:57:28 <ddarius> Eduard_Munteanu: I guess you want to copy the stuff it t' into t.
09:57:58 <Eduard_Munteanu> ddarius: it's supposed to replace a subtree with another subtree. I initially thought 'this' would make it unneccessary to know if the current subtree is a left or right child.
09:58:39 <Eduard_Munteanu> Because I kinda need to go up to the parent and write its left/right pointer with the new subtree.
09:59:43 <ddarius> Eduard_Munteanu: Well if the tree is actually a tree, you can just do pointer comparisons and find out which of the parent's children is t.
10:00:17 <ddarius> If the tree is actually a DAG or worse then the parent pointers don't seem like they make sense.
10:00:39 <ddarius> Incidentally, once you get rid of the this field your newNode function will be less silly.
10:01:25 <ddarius> Also, Applicative works well for this stuff.
10:04:54 <ddarius> For example, test = fork <$> newNode "Root" <*> (fork <$> newNode "Left" <*> newNode "LL" <*> newNode "LR") <*> (fork ...)
10:05:52 <ddarius> (Well, if you change fork to return the first argument.)
10:06:51 <ddarius> Actually, that's a bad idea, those calls to fork should instead be calling a newNode that takes initial arguments.)
10:15:37 <Eduard_Munteanu> ddarius: but pointer comparisons would only work with such a 'this'. (sorry for the delay)
10:16:17 <Eduard_Munteanu> (My use case for the tree is replicating something like data Tree a = Leaf a | Fork a (Tree a) (Tree a))
10:17:10 <Eduard_Munteanu> That's why I put 'this' there, but I have to make sure it's the same pointer as the parent's left/right.
10:20:47 <Eduard_Munteanu> Sorry, I have to go, New Year's eve party.
10:20:49 <ddarius> Eduard_Munteanu: What are the semantics of replace.
10:21:14 <Eduard_Munteanu> ddarius: it simply replaces the subtree indicated by the first arg with the subtree indicated by the second arg.
10:21:50 <ddarius> So it should replace the pointer in the parent of the first argument to point at the second argument, yes?
10:22:01 <Eduard_Munteanu> ddarius: yes.
10:22:21 <ddarius> Okay.
10:22:38 <Eduard_Munteanu> I suppose I could simply insert a data Ctx = L | R into each node and discriminate which parent's pointer to choose.
10:23:46 <Eduard_Munteanu> Ok, happy new year everybody, thanks ddarius. Have to go...
10:27:19 <ddarius> @tell Eduard_Munteau http://paste.pocoo.org/show/312549/  (completely untested, I just edited it in the textbox)
10:27:19 <lambdabot> Consider it noted.
10:34:36 <elliott> hmm, is there a function to count occurrences of element x in an array?
10:34:52 <mauke> @hoogle a -> [a] -> Int
10:34:53 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
10:34:53 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
10:34:53 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
10:35:13 <mauke> @hoogle count
10:35:13 <lambdabot> Data.ByteString count :: Word8 -> ByteString -> Int
10:35:14 <lambdabot> Data.ByteString.Char8 count :: Char -> ByteString -> Int
10:35:14 <lambdabot> Data.ByteString.Lazy count :: Word8 -> ByteString -> Int64
10:35:28 <ddarius> @tell Eduard_Munteau Actually the code for replace is somewhat wrong, it shouldn't overwrite Nothings, but then I suspect you could actually get rid of the Maybes.
10:35:28 <lambdabot> Consider it noted.
10:35:33 <token22> hm what does mean when i write e.g. class Eq a... instance (Eq a, Eq b) => Eq (a,b) (the part after =>) ?
10:35:58 <ddarius> @where report
10:35:58 <lambdabot> http://www.haskell.org/onlinereport/
10:36:01 <mauke> token22: the part after => is the instance you're defining
10:36:08 <mauke> in this case you're making (a,b) an instance of Eq
10:38:35 <kmc> you're making (a,b) an instance of Eq.  that instance requires that a and b are instances of Eq
10:38:40 <token22> and when i have (Eq a) => Eq (Tree a) means just only instance of Tree? wouldn't be better to write 'Eq Tree'?
10:38:46 <elliott> length.elemIndices I guess
10:38:52 <kmc> "Eq Tree" isn't well-formed
10:38:54 <mauke> token22: Tree is not a type
10:39:05 <kmc> Tree isn't a type; it's a one-argument type constructor
10:39:22 <kmc> also it is actually useful to refer to the variable
10:39:52 <kmc> you might want an instance like "Ord a => Eq (Tree a)" or "(Show a, Read a) => Eq (Tree a)" or even just "Eq (Tree a)" with no context
10:39:53 <token22> okay
10:40:06 <Jesin> hmm
10:40:27 <Jesin> actually, couldn't there be a decent definition for Ord (Tree a)?
10:40:45 <Jesin> err
10:40:51 <Jesin> Ord a => Ord (Tree a)
10:40:54 <Jesin> ^ that
10:41:10 <c_wraith> There could be many decent definitions.  Picking one is the fun part
10:41:29 <roconnor> whoa, there is an extra-hard hydra that even Kripke-Platek set theory cannot prove is always defeatable
10:41:30 <kmc> right, which is one disadvantage of type classes.  if there's not a single obvious correct definition
10:41:38 <Jesin> ...yeah.  =/
10:41:51 <j-invariant> roconnor: can you show me that?
10:42:02 <j-invariant> I haven't read about the basic hydra yet but I will bookmark this
10:45:00 <monochrom> w00t hydra. do you mean like http://math.andrej.com/2008/02/02/the-hydra-game/ ?
10:47:03 <roconnor> j-invariant: http://www.madore.org/~david/math/hydra.xhtml
10:47:49 <token22> when i have class Eq then instance Eq Int where max x y = if... i have to write in Hugs Main.max (1::Int) (2::Int) is there any way to avoid '::Int'?
10:48:10 <j-invariant> ahh I Like that
10:48:13 <kmc> "max" isn't a method in the type class "Eq"
10:48:14 <j-invariant> this hydra is great
10:48:27 <token22> okay then class Eg
10:48:41 <kmc> oh, you're defining your own class?
10:49:02 <mauke> make an instance for Integer
10:49:07 <kmc> right, there's an ad-hoc mechanism for defaulting numeric types with a few built-in classes, but it won't apply to your custom classes
10:49:18 <kmc> however if the signature on max is like (Eg a) => a -> a -> a
10:49:22 <kmc> then you could just say (max 1 2) :: Int
10:49:28 <token22> hm
10:49:31 <token22> try it
10:49:38 <kmc> since forcing the last 'a' to be Int will force the others to be the same
10:51:28 <token22> okay it works (thus i hope that without Main. i use my max function)
10:52:11 <monochrom> hydra is a very tiring clicking game. but I wish there is an iphone app for it. :)
10:53:25 <mjrosenb> monochrom: you should try the game i'm playing
10:53:38 <mjrosenb> monochrom: it's called "write an awesome haskell program"
10:53:49 <mjrosenb> i'm almost up to the final boss.
10:53:56 <monochrom> haha
10:54:14 <monochrom> is that oleg or spj?
10:54:25 <kmc> token22, also most people these days use ghci, not hugs
10:55:23 <roconnor> I'm not sure I understand how/why uncountable ordinals are needed to enumarate a fragment of the countable ordinals
10:55:41 <roconnor> regarding http://en.wikipedia.org/wiki/Bachmann%E2%80%93Howard_ordinal
10:56:28 <token22> kmc well, we use hugs in school (and i didn't even know about Hugs before - in fact when professor mentioned Haskell i heard Pascal)
10:56:32 <roconnor> oh maybe http://en.wikipedia.org/wiki/User:Gro-Tsen/An_ordinal_collapsing_function will explain
11:00:20 <kmc> fair enough
11:00:54 <kmc> a lot of Haskell courses in school have not been updated for the tremendous changes in Haskell tools which have happened recently
11:02:03 <mjrosenb> kmc: do you mean extensions that ghc has added to the language, the ghc debugger, or something completely different?
11:02:14 <kmc> Hugs hasn't had a release since 2006, while GHC is making major improvements every few months
11:02:21 <monochrom> "tools" means for example cabal
11:02:28 <kmc> mjrosenb, mostly the quality of ghc as a compiler, and of packaging tools
11:02:35 <kmc> cabal, hackage, etc.
11:02:53 <kmc> also some ghc language extensions, but most won't be relevant in an intro-level haskell course
11:03:53 <Cale> man, so much of set theory is almost absurdly technical :)
11:05:12 <token22> kmc well, i think so, but we have to know mainly: to determine a type of expression(without hugs), pointwise<->pointless, IO (>>=,>> <-> do), classes and binary trees..and everything on paper with pen (and this is killing me)
11:06:15 <monochrom> we have come to a point where set theorists laugh at intro discrete math courses "that is not set theory" like algebraists laugh at highschool algebra classes "that is not algebra"
11:06:34 <Cale> monochrom: Absolutely
11:06:44 <kmc> also most uni classes don't teach much about how to write real-world haskell code
11:06:51 <kmc> but that's okay, i heard someone wrote a book about that subject ;)
11:07:13 <Cale> It's not *really* set theory until you're using the axiom of replacement somewhere. :)
11:08:04 <kmc> i think fewer CS students would walk away with the reaction "ugh, this is useless" if they saw some of the concurrency and parallelism stuff that GHC Haskell supports
11:08:47 <xiackok> happy new years to everyone
11:09:08 <ManateeLazyCat> How to disable TouchPad?
11:09:19 <token22> and one more thing - there is no literature of haskell in my language (only something i have from school) (and i am not good in english to study it..)
11:09:26 <ManateeLazyCat> I use "synclient TouchpadOff=1" can't work. 
11:10:02 <Zao> kmc: During our "programming languages" course (which is a mix of ML and theory), several students have expressed a wish that we change it to something sane like Haskell next year :)
11:10:36 <monochrom> well I'm sure most intro discrete math students use { x*x+x | x in â„• } all the time.
11:10:48 <mjrosenb> ManateeLazyCat: this seems like the wrong place to ask.
11:11:10 <ManateeLazyCat> mjrosenb: I have ask Debian, i wonder someone know this tips here.
11:11:15 <kmc> token22, which language?
11:11:23 <mjrosenb> ManateeLazyCat: that being said, i'd try xinput.
11:13:34 <token22> you metioned some changes in Haskell...is now possible to write [ xn | x1 <– m1 , . . . , xn <– mn ] instead m1 >>= (\ x1 –> m2 >>= (. . . (\ xn –> return xn ) . . . ))
11:13:35 <token22>  ?
11:13:45 <kmc> Learn You A Haskell has been translated into Russian and Czech
11:13:49 <kmc> the author lives in Slovenia
11:13:52 <token22> well my native language is Slovak/Cyech
11:13:57 <token22> Czech
11:14:01 <kmc> http://naucte-se.haskell.cz/
11:14:23 <token22> yes and half of text is in english
11:14:27 <kmc> :/
11:14:59 <kmc> token22, well Haskell is a standardized language... there have been only minor changes to the standard between Haskell 98 (which is implemented by Hugs) and the current Haskell 2010
11:15:14 <kmc> however, GHC implements many features beyond standard Haskell
11:15:27 <Jesin> [14:10:09]	<monochrom>	well I'm sure most intro discrete math students use { x*x+x | x in â„• } all the time.
11:15:35 <kmc> that feature is called "monad comprehensions"; it existed in Haskell 1.4 but was removed for Haskell 98
11:15:42 <kmc> and someone's working on adding it to GHC as an extension
11:15:50 <kmc> but the current released versions of GHC don't support it, afaik
11:15:53 <Jesin> I'm pretty sure you can get that set without the axiom of replacement, actually
11:16:20 <kmc> the more conventional way to write that would be: do { x1 <- m1; x2 <- m2; ...; mn }
11:16:35 <Jesin> you just need separation, {x in N | exists y in N: x = y*y+y}
11:16:38 <Jesin> :p
11:17:22 <mjrosenb> kmc: in other words, | is syntatic sugar for the (invalid) `do` :-p
11:17:24 <kmc> if you have "do { x <- a; y <- b; return (f x y) }" where a and b don't depend on x and y, you can instead write simply "liftA2 f a b"
11:17:50 <Jesin> (so that doesn't count as using the axiom of replacement  :p )
11:18:11 <mjrosenb> kmc: liftA2 rather than liftM2?
11:18:50 <kmc> ideally yes
11:18:58 <Jesin> hmm, apparently there is a trivial Applicative instance for every Monad (assuming monad laws)
11:19:02 <kmc> yes
11:19:08 <kmc> liftMn should be deprecated in favor of liftAn
11:19:14 <Jesin> could there similarly be a trivial Category instance for every Functor?
11:19:23 <Cale> Jesin: mmm...
11:19:31 <Cale> Jesin: Well, in what sense?
11:19:38 <kmc> Jesin, the Control.Category.Category instance for every Prelude.Functor is (->)
11:19:42 <mjrosenb> kmc: what is the difference? i assume A stands for applicative, not arrow?
11:19:43 <Cale> There's a bit of a kind error there
11:19:46 <cdsmithus> Jesin: a functor isn't a category.  Functors are maps between categories
11:19:56 <Jesin> hmm
11:19:57 <Jesin> ok
11:20:00 <kmc> mjrosenb, right
11:20:00 <Jesin> aren't Arrows also that, though?
11:20:10 <Cale> A Functor in Haskell is just a functor Hask -> Hask
11:20:23 <Jesin> hm, k
11:20:37 <kmc> Prelude.Functor expresses a concept much narrower than "functor"
11:20:41 <Jesin> yeah
11:20:46 <Cale> Note that as a type constructor, an instance of Functor will have kind * -> *
11:20:59 <Cale> But an instance of Category needs to have kind * -> * -> *
11:21:06 <Jesin> umm
11:21:16 <Jesin> instance of Category a, then?
11:21:36 <Jesin> or Category MoreSpecificThing?
11:21:38 <Jesin> :p
11:21:39 <kmc> if F is an instance of Functor, then F maps types A to types F A, and "fmap" maps functions "f :: Hask a b" to functions "fmap f :: Hask (F a) (F b)"
11:21:51 <kmc> where we have "type Hask a b = a -> b"
11:21:58 <digitteknohippie> 36 pages into real world haskell, only 619 to go until i hit the index... n we'll see if i'm back here with questions.  ^_^  ace book.
11:22:04 <kmc> here the category is Hask
11:22:09 <kmc> and it's the same category on both sides
11:22:17 <Cale> digitteknohippie: I would recommend asking more questions as you go
11:22:21 <kmc> which is why Prelude.Functor =~ "endofunctor in Hask"
11:22:29 <digitteknohippie> good idea cale
11:23:02 <monochrom> I learn by asking questions.
11:23:10 <monochrom> But not to you. Just to myself.
11:23:18 <Cale> By the way, the class Category doesn't really correspond very well to the mathematical definition of category.
11:23:29 <monochrom> And usually the question is answered by some LL(k) parsing of the book.
11:24:00 <digitteknohippie> monochrom, heh, yeah, i often have questions under construction, that just through the act of refining the question, i find my answers.
11:24:10 <Cale> It's something more specific which is a bit hard to pin down.
11:24:26 <monochrom> onoes, another cargo cult math fuel
11:24:52 <Cale> Yeah, I don't know why that guy has such a strong reaction
11:25:05 <monochrom> because he is a blogger
11:25:05 <Cale> (Was it Quadrescence?)
11:25:15 <monochrom> no, Quadrescence has denied it
11:25:18 <token22> how can i use return with IO?
11:25:18 <Cale> ah, okay
11:25:20 <Cale> hmm
11:25:29 <kmc> token22, return :: a -> IO a
11:25:29 <Quadrescence> denied what
11:25:34 <monochrom> getLine >>= return
11:25:34 <kmc> it's a function, you call it
11:25:35 <hpc> token22: the same way you use (+) with numbers :P
11:25:42 <Cale> token22: Well, for any monad M, we have return :: a -> M a
11:25:48 <kmc> the name is kind of misleading
11:25:53 <Cale> token22: and IO is a monad, so  return :: a -> IO a
11:25:56 <kmc> it's not like the "return" keyword in Python or C
11:26:12 <kmc> it's just a function which takes a value, and returns an IO action that does nothing except produce that value
11:26:17 <Cale> token22: return v is the IO action which does nothing, and returns v all the time
11:26:48 <kmc> Haskell programs don't actually perform IO; they build descriptions ("IO actions") of how IO could be performed
11:27:00 <monochrom> if you haven't found an application of return, don't worry about it
11:27:00 <Cale> (so in particular, if you put  return v  in the middle of a do-block, it will do nothing, and continue on with the rest of the do-block as if it weren't there.)
11:27:07 <kmc> (except the runtime system is kind enough to actually perform the IO described by "main")
11:27:18 <monochrom> if you have found an application, you already know how to use it.
11:27:31 <monochrom> therefore, "if you have to ask, you are not ready to know"
11:27:46 <Cale> Quadrescence: That you were the blogger who was fretting about how the mathematics of Haskell is too cargo-cultish.
11:28:12 <token22> i mean i can't find the way to use return in hugs (interpreter) where i could see the using of return
11:28:23 <Quadrescence> I am the blogger, but I don't want the words misconstrued. The mathematics of haskell is perfectly legitimate.
11:28:28 <kmc> category theory is not about results; it's about common vocabulary
11:28:33 <Cale> token22: Consider something like  do x <- getLine; y <- getLine; return (x,y)
11:28:52 <kmc> and the vocabulary of category theory is kindof-sortof applicable to Haskell
11:29:02 <ddarius> kmc: I find the continuity properties of adjoint functors a rather useful result.
11:29:05 <kmc> but this is pretty much a sideshow to the language itself
11:29:15 <token22> Cale okay
11:29:40 <ddarius> And I use them in Haskell too, though it is a bit unrigorous for the usual reasons.
11:29:50 <Cale> token22: The result of a do-block is the result of the last item in it.
11:29:55 <kmc> what does that property give you in Haskell?
11:30:23 <Cale> token22: and so this IO action will get two lines, and produce as its result (when executed), the pair consisting of both Strings.
11:31:02 <token22> okay, i'll try to play with it
11:31:11 <ddarius> kmc: Modulo undefined, it immediately says things like: Either a b -> c ~ (a -> c, b -> c), forall a. a -> X ~ (exists a. a) -> X, a -> (b,c) ~ (a -> b, a -> c)
11:31:24 <Cale> token22: If we defined it as   getTwoLines = do x <- getLine; y <- getLine; return (x,y)
11:31:40 <token22> but it's quite confusing as I thought it return a value to e.g. function or...
11:31:45 <Cale> token22: Then we could write   do (x,y) <- getTwoLines; print x; print y
11:31:58 <zmbmartin> any arch users know when ghc 7 is going to be available?
11:32:00 <Cale> Note that getTwoLines isn't a function, because it doesn't have any parameter
11:32:09 <Cale> It's simply an IO action.
11:32:37 <Cale> That is, a description of some stuff which could be performed to cause I/O to occur, and produce a result of some type.
11:33:30 <portnov> :t liftM2 (,) getLine getLine
11:33:31 <lambdabot> IO (String, String)
11:33:58 <token22> Hm
11:34:28 <ddarius> There's a paper that can be viewed as: mu F a -> X ~ nu F (a -> X), giving, for example, Nat -> X ~ Stream X
11:37:21 <Jesin> hmm
11:37:25 <ddarius> (exists a. F a, y) ~ exists a. (F a, y) by cocontinuity of left adjoints.
11:37:26 <Jesin> is there a way to do this: http://haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal
11:37:32 <Jesin> without breaking existing code?
11:38:10 <Cale> No. There will be some code breakage when/if it happens.
11:38:18 <Jesin> hmm
11:38:20 <Cale> But not really serious code breakage.
11:38:26 <Jesin> http://haskell.org/haskellwiki/Class_system_extension_proposal <-- what about this?  :p
11:38:53 <Cale> and in fact, it might even be considered positive, as it will enforce the constraint that people write instances of Functor and Applicative when they could
11:39:06 <monochrom> mu F a -> X ~ nu F (a -> X) is interesting. I have wondered what's going on with Nat -> X ~ Stream X
11:41:06 <Hilbert> Hey is it possible to modify this to return to create an efficent alogorith that returns the values of n such that  n! mod p(n) ==0 where p(n) is the integer partion function
11:41:11 <Hilbert> http://syfran.com/2010/03/when-performance-matters/
11:41:32 <mauke> zomg it's Hilbert himself!
11:42:04 <ddarius> mauke: You're not going to help with Hilbert's program?
11:42:56 <monochrom> A friend asked me "I don't see coinduction in Stream, I only see induction". He refers to eg to prove that the stream "repeat True" always emits True, some proofs use Stream X ~ Nat->X and prove "forall n. (repeat True) !! n == True" instead, and from then on only induction is used.
11:43:50 <monochrom> hi Hilbert thanks for your brothel coupons last night
11:44:38 <Hilbert> monochrom: ?
11:44:39 * JuanDaugherty would like to hear more about that
11:44:57 <roconnor> @oesis 2 4 5
11:44:59 <lambdabot>  Number of fixed points in range [A014137(n-1)..A014138(n-1)] of permutation ...
11:44:59 <lambdabot>  [1,1,2,1,2,2,4,5,10,14,28,42,84,132,264,429,858,1430,2860,4862,9724,16796,33...
11:45:00 <roconnor> @oesis 2 4 6
11:45:01 <lambdabot>  d(n) (also called tau(n) or sigma_0(n)), the number of divisors of n.
11:45:01 <lambdabot>  [1,2,2,3,2,4,2,4,3,4,2,6,2,4,4,5,2,6,2,6,4,4,2,8,3,4,4,6,2,8,2,6,4,4,4,9,2,4...
11:45:25 <roconnor> @oesis 2 4 6 (3*2^402653211 - 2)
11:45:27 <lambdabot>  Sequence not found.
11:45:39 <ddarius> When did @oeis get fixed?
11:45:54 <mauke> recently, when lambdabot was recompiled
11:46:15 <ddarius> @google 2+2
11:46:15 <lambdabot> 4
11:46:27 <mauke> @eval lave@
11:46:59 <ddarius> @google 3 miles in micrometers
11:47:00 <lambdabot> 4 828 032 000 micrometers
11:47:00 <lambdabot> http://www.engineeringtoolbox.com/length-units-converter-d_1033.html
11:47:00 <lambdabot> Title: Length Units Converter
11:47:00 <Jesin> @help oesis
11:47:00 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:47:01 <monochrom> in Hilbert's brothel there are as many rooms as there are natural numbers. one day, the brothel is full, but there are as many new customers as the natural numbers arriving. what to do?
11:47:21 <Jesin> @help oesis
11:47:21 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:47:27 <hpc> monochrom: put them in your room, naturally
11:47:27 <Jesin> ??
11:47:31 <Jesin> eh.
11:47:59 <Hilbert> monochrom: Oh Hilbert's hotel
11:48:34 <monochrom> 1. ask customer in room n to move to room 2n. 2. or, announce a kind of "threesome night special"
11:49:09 <digitteknohippie> XD hehehehehe.  
11:49:13 * digitteknohippie picks 2
11:49:15 <Hilbert> monochrom: haha, anyway I have to work out my program
11:49:39 <monochrom> next chapter: well-rounded seduction
11:49:58 <ddarius> Ï‰ is the lonliest number 
11:50:21 <Jesin> hmm
11:50:41 <Jesin> http://haskell.org/haskellwiki/Functor_hierarchy_proposal looks like a less complete version of http://haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal
11:50:46 <Jesin> perhaps it should become a redirect?
11:51:58 <digitteknohippie> best feature of haskell i've discovered so far... it runs a check on if i'm well enough rested, hydrated, and [fed, high enough blood sugar], because if these conditions arent met, my brain (and thus anything attempted in haskell) just fails.
11:53:09 <monochrom> "inferred type [t] does not match expected type (t,t). perhaps drink some sugar water."
11:53:13 <hpc> digitteknohippie: i assume you mean "outputs Nothing", since everyone knows total functions are the only proper way to code :P
11:53:36 * digitteknohippie nods n grins
11:54:16 <token22> btw, why to use Haskell? 
11:54:26 <monochrom> because it is nice to use
11:54:33 <ddarius> token22: There is no reason.  You should go use PHP.
11:54:44 <hpc> lol
11:54:52 <token22> i would use python rather
11:54:59 <monochrom> why use PHP? I want to know that one too.
11:55:06 <digitteknohippie> it works like my brain works, rather than having to do strange contortions of my natural thought patterns, like is the case for me with C.
11:55:26 <token22> php is crap for me as Java, C#,...
11:55:55 <digitteknohippie> nrly everything > java.  imo
11:55:56 <monochrom> why use python, then?
11:56:13 <token22> :D
11:56:55 <Jesin> I also like Python better than PHP, Java, etc, and I'm still not sure what I think about Haskell  :p
11:57:28 <digitteknohippie> it's different, thats for sure.  hard to compare as if they were like for like.
11:57:34 <Cale> token22: python doesn't do enough typechecking, and its implementation of functions is a bit off
11:57:47 <hpc> Cale: "a bit"? :P
11:57:58 <token22> but for me is the best C (objective C - not stroustrup C++)
11:58:16 <mauke> python enrages me because of implicit scoping
11:58:42 <Jesin> oh, yeah
11:58:49 <Jesin> that's one thing I'd like to fix  :p
11:58:59 <hpc> what got me about python was that you have no way of knowing the specific type of a numeric value
11:59:16 <hpc> but you still couldn't perform arithmetic with one float and one integer
11:59:21 <Jesin> there should be a "local" keyword, perhaps
11:59:31 <mauke> "local" is too long
11:59:32 <Jesin> or "var"
11:59:34 <mauke> better
11:59:38 <mauke> or "my" :-)
11:59:55 <hpc> or just the type of the variable
11:59:59 <Jesin> no
12:00:02 <Jesin> not the type of the variable
12:00:05 <Jesin> variables don't have type
12:00:07 <Jesin> :p
12:00:08 <monochrom> oh, what's the point of loosening up on types if it can't float+int
12:00:22 <Jesin> ...
12:00:34 <Jesin> umm, yeah you can perform arithmetic with one float and one integer...
12:00:36 <mauke> 2 + 2.5 works just fine in python
12:00:51 <monochrom> alright good to hear
12:00:55 <Jesin> it results in a float, just like most other languages
12:00:56 <hpc> i forget what i was doing, but it was either multiplication or division
12:00:56 <Jesin> :p
12:01:03 <mauke> 2/3 is 0
12:01:10 <Jesin> mauke: not in Python 3
12:01:25 <mauke> python 3 doesn't exist
12:01:38 <Jesin> it isn't widely used yet
12:01:40 <Jesin> :p
12:01:41 <tomjnixon> (or with from __future__ import division at the top of your file!)
12:01:51 <hpc> python 3 is on the same plane of existence as perl 6
12:02:01 <parcs> python 3 is the default version of python in arch linux
12:02:12 <mauke> > 2/3 :: Rational
12:02:13 <lambdabot>   2 % 3
12:02:13 <monochrom> perl = python * 2
12:02:34 <hpc> monochrom: in every sense; it's twice as good, twice as bad, and has twice as much stuff
12:02:48 <monochrom> nice
12:02:55 <tomjnixon> monochrom: but with ten times as much line noise
12:02:57 <gio123> for any a>2 does there exist b,c>2 such that a^2+b^2=c^2?
12:03:27 <Jesin> I suppose you mean natural numbers?
12:03:43 <Hilbert>  Why doesn't this work facs = take 10^2 scanl (*) 1 [1..]
12:03:48 <Jesin> err, N\{0}
12:03:53 <gio123> yes
12:03:54 <mauke> Hilbert: because 2 is not a function
12:03:57 <gio123> natural numbers
12:04:20 <gio123> for any natural numbers a>2 does there exist natural numbers b,c>2 such that a^2+b^2=c^2?
12:04:32 <monochrom> take (10^2) (scanl (*) 1 [1..])
12:04:43 <Jesin> well
12:04:56 <Jesin> there's a=3, b=4, c=5
12:04:58 <Jesin> so yes
12:05:15 <gio123> for any :)
12:05:21 <Jesin> umm
12:05:23 <Jesin> no
12:05:33 <Jesin> you're using "any" wrong
12:05:43 <Jesin> you meant for all, I expect
12:05:43 <monochrom> pretend "for any" = "for all"
12:06:16 <monochrom> english is not his native language. expect lost in translation
12:06:22 <Jesin> ah, ok
12:06:38 <mauke> has gio123 ever talked about haskell?
12:06:43 <monochrom> especially not aware that english "any" is seriously broken
12:07:15 <monochrom> should completely remove that word from the whole language, or at least from all math books
12:07:19 <hpc> monochrom: file a bug report ;)
12:07:52 <gio123> mauke: never
12:08:22 --- mode: ChanServ set +o mauke
12:08:22 --- mode: mauke set +q $a:gio123
12:10:22 --- mode: mauke set -o mauke
12:12:32 <Hilbert> Is this valid sytax filter  (\x -> ( facs !! x `mod` p x == 0 ) [1..]     where facs and p have already been deined
12:13:21 <monochrom> not sure about operator precedence
12:13:21 <Hilbert> *defined
12:13:22 <mauke> :t filter  (\x -> ( ?facs !! x `mod` ?p x == 0 ) [1..]
12:13:23 <lambdabot> parse error (possibly incorrect indentation)
12:13:32 <mauke> no, you're missing a )
12:13:48 <monochrom> filter  (\x -> ((facs !! x) `mod` p x) == 0 ) [1..]
12:13:58 <mauke> :t filter  (\x -> ( ?facs !! x `mod` ?p x) == 0 ) [1..]
12:13:59 <lambdabot> forall a. (?facs::[a], ?p::Int -> a, Integral a) => [Int]
12:14:21 <mauke> :t filter  (\x -> ( ?facs !! x) `mod` ?p x == 0 ) [1..]
12:14:22 <lambdabot> forall a. (?facs::[a], ?p::Int -> a, Integral a) => [Int]
12:15:37 <monochrom> oh haskell weekly news!
12:15:59 <Hilbert> I want to enumerate the values of x for which the xth element of facs  divides x!
12:16:45 <Hilbert> Sorry I meant I want to eneumerate tha values of x for which p(x) divides the xth element of x!
12:18:48 <monochrom> yeah
12:20:08 <Hilbert> I keep getting synatx errors though
12:22:34 <monochrom> > filter  (\x -> (([1,2,6,12,72] !! x) `mod` id x) == 0 ) [1..4]
12:22:36 <lambdabot>   [1,2,3,4]
12:22:40 <monochrom> no syntax error
12:24:43 <Hilbert> Perhaps the error is else way in my .hs file
12:25:09 <monochrom> errors are never context-free
12:26:02 <token22> i got new error Haskell 98 does not support multiple parameter classes
12:26:16 <monochrom> that's expected
12:26:48 <monochrom> haskell 2010 doesn't support multiple parameter type classes either
12:27:23 <Hilbert> I don't understand
12:27:37 <token22> ups, i see what is wrong in my file
12:27:54 <monadic_kid> token22: it's extensions, you can specify to use it either in your module with pragma or as an option to the compiler
12:28:20 <token22> i wrote only class Strom where ...
12:28:55 <ddarius> Yeah, I mean come on they were only just added to Gofer in 1993.
12:28:57 <monochrom> heh
12:29:19 * ddarius wants nullary type classes.
12:29:45 * ddarius wonders if Gofer supported nullary type classes.
12:31:32 <Hilbert> Hey can anyobdy see the syntax error in this http://pastebin.com/SwSR2NJg
12:31:45 <mauke> what's the error message?
12:32:09 * ddarius bets GHC can see the error.
12:32:09 <Hilbert> part.hs:10:0: parse error (possibly incorrect indentation)
12:32:18 <monochrom> very bad idea to split lines 8 and 9
12:32:19 <monadic_kid> Hilbert: exactly what it says
12:32:48 <monochrom> and what the hell is with "(cycle" incompleted
12:32:49 <mauke> (cycle what
12:33:02 <Cale> Hilbert: If you want to continue a line on to the next line, the next line should start in a deeper column from where the expression on the previous line started.
12:34:03 <monadic_kid> yeah what the dilio is up with (cycle
12:36:51 <token22> damn i want to load .hs file which contains class and functions but has problem with context of class (+ and -) do i need to load it to hugs separately or?
12:37:56 <monochrom> not sure the true meaning of "context of class (+ and -)" but I have no problem
12:39:11 <token22> well the error is Ambiguous variable occurrence "+" *** Could refer to: Main.+ Hugs.Prelude.+
12:39:15 <Hilbert> mauke: The code is a modification of an algorithm somebody else  implemented in haskell
12:39:19 <token22> when i delete functions it works
12:40:04 <mauke> token22: so you have two different functions called + and hugs doesn't know which one you mean
12:40:07 <token22> monochrom i mean in class is (+),(-) :: a -> a -> a
12:40:56 <token22> yes but i thought that Main.+ should be the one from my class
12:40:59 <monochrom> 1. it is not very nice to reuse existing names. 2. if you insist, write "Main.+" and "Prelude.+" respectively at call sites to disambiguate.
12:41:28 <Hilbert> In  part.hs:10:5: parse error (possibly incorrect indentation)
12:41:28 <Hilbert>  what does the 10.5 refer to?
12:41:38 <monochrom> line 10 character 5
12:42:03 <mauke> token22: it is
12:43:10 <token22> it's strange
12:43:29 <monochrom> yeah it's strange if you presume do-what-I-mean
12:43:42 <mauke> token22: what
12:45:15 <monochrom> you import 10 modules, each exporting the same name "+". you further define your own too. and then you try to use one of them with "n = 4 + 5" and the computer completely fails to guess which of the 11 +'s you mean. it is so obvious to guess. so strange the computer can't do it.
12:46:58 <deech> Hi all, 
12:47:32 <monochrom> perhaps PHP can guess and that's why people like PHP so much
12:47:33 <deech> Is there some pure way to test that an list is finite? I guess I could call 'last' on it and catch the error.
12:47:51 <monochrom> sometimes that takes forever.
12:47:54 <token22> yes but in functions i do not use +, and i thought that after load file I can choose +
12:48:51 <monochrom> using + at the prompt is so much easier to guess than using + in the file, yeah, sounds obvious.
12:49:13 <azaq23> if you have to check for that I would guess you're using a suboptimal data model
12:49:46 <Hilbert> The error occurs at the in
12:49:54 <deech> monochrom: Good point. So no easy way?
12:50:06 <monochrom> no easy way. probably no way. pure or cheat.
12:50:20 <deech> interesting
12:51:25 <token22> okay
12:52:43 <token22> i just noticed what you wrote upper and it solved it
13:01:18 <Cale> deech: In a rather concrete sense, it's equivalent to the halting problem
13:01:36 <Cale> deech: If a list is finite, you can know that it's finite, but if it's not, there's no way to know for sure that it's not.
13:01:43 <Cale> (unless you prove it externally)
13:01:53 <Cale> (and even then, there will be undecidable ones)
13:02:43 <Cale> deech: One can imagine writing a function which given a Turing machine and an initial tape, gives a list of the states in which the Turing machine ends up before halting.
13:02:45 <kmc> in Haskell a "list" is an arbitrary procedure which may or may not ever yield another list element
13:03:16 <Cale> and then deciding if that list is finite is the same as deciding if the Turing machine halts
13:03:28 <ray> it can tell you if it definitely will not though
13:03:43 <kmc> now, if your list is guaranteed not to contain any thunks, then it's infinite iff it's circular
13:03:45 <Cale> Similarly, one could produce a list of reduction steps on a lambda term, attempting to normalise the lambda term
13:03:51 <kmc> and there are GHC-specific hacks that could detect circular lists
13:03:58 <kmc> but semantically, a circular list is like an infinite list
13:03:59 <Cale> and to say that the list is finite is to say that the lambda term is normalisable
13:04:14 <Cale> (which is another undecidable problem in general)
13:04:39 <pacak> 2011...
13:05:19 <ray> just make the type of only finite lists and use that type
13:05:47 <digitteknohippie> ace. http://blog.codeslower.com/static/CheatSheet.pdf i knew that'd b savvy to search for "Haskell cheatsheet" ;)
13:06:08 <monochrom> hrm code slower
13:06:12 <ray> (i don't think haskell can do that but i might be wrong)
13:06:38 <Cale> If you write these functions using a list type containing only finite lists, then they won't terminate at all when the Turing machine fails to halt or the lambda term has no normal form.
13:07:05 <Cale> Haskell can define a list type with only finite lists, but that type still contains a bottom element.
13:07:14 <Cale> (representing nonterminating computations)
13:07:47 <Cale> If you were to exclude that element from your type of finite lists, then it would simply be impossible to write these functions altogether.
13:07:51 <monochrom> pretty ok cheatsheet. just a bit long. and why does a cheatsheet need a conclusion?
13:08:26 <Cale> If you were to exclude bottom from your type of potentially infinite lists, then you could still write these functions, but you have the same problem about determining if the resulting list is finite or not.
13:09:43 <lelf> happy new year â‰¥ gmt+3 :)
13:10:53 <pacak> lelf: it was 9 minutes ago
13:11:55 <monochrom> well there are still 525588 minutes
13:12:25 <TTimo> are there some kind of haskell exercises / suggestions for learners out there? I'm going through learnyouahaskell but it's a bit dense with no practice
13:12:54 <monochrom> real world haskell has exercises
13:13:04 <monochrom> tryhaskell.org has exercises
13:13:15 <TTimo> k
13:19:03 <kmc> TTimo, i like http://www.cs.caltech.edu/courses/cs11/material/haskell/index.html
13:22:00 <taotree> I'm going through Real World Haskell book online, database section, my code http://pastebin.com/86ezUbTD ... It's giving me error on all the toSql calls with numbers. The String calls work, but not the numbers one
13:22:12 <elliott> Is the Haskell reddit's logo meant to be confusing? "45 :: IO"
13:23:21 <mikeg> don't you need nToSql?
13:23:54 <kmc> elliott, mouseover text: "45 years since Landin first described purely functional IO"
13:24:04 <elliott> kmc: THAT IS NOT HOW TYPES WORK :-)
13:24:09 * kmc grouses that Haskell's approach to IO is not very "functional"
13:24:15 <elliott> Can we get conal in here to -- yeah.
13:24:17 <elliott> Complain about that.
13:24:31 <elliott> "45 years since Landin first described how to embed imperative IO semantics in a purely functional language".
13:24:45 <kmc> the semantics aren't even embedded
13:24:46 <taotree> mikeg, Thanks, that fixed it. Apparently the API changed since the book.
13:24:50 <c3l> Ive been trying to get a grip of this by reading on the wiki and from the mailing list, but i cant really get a clear answer. is darcs the de facto scm system, or is the majority gravitating towards something else (git?)?
13:24:56 <kmc> you need a whole other semantics to describe execution
13:24:57 <elliott> kmc: well, yes.
13:25:05 <kmc> c3l, i see a lot of Haskell projects use git these days
13:25:08 <kmc> i use git with all my Haskell code
13:25:09 <elliott> kmc: 45 years since Landin first described how to embed imperative IO actions in a purely functional language.
13:25:28 <kmc> also what they mean is "the RealWorld-passing trick underlying the implementation of the IO monad"
13:25:35 <kmc> and by "the implementation" they mean "GHC's implementation"
13:25:37 <kmc> sigh
13:26:40 <elliott> kmc: to be fair, even the great Oleg misrepresented it in that way in his post
13:26:47 <elliott> and can we really expect people to be better than Oleg? :)
13:26:51 <kmc> hehe
13:30:21 <systemfault> Oleg isn't the end of the world....
13:30:33 <systemfault> There's always better... for anything
13:31:37 <parcs> > let x = succ x in x
13:31:38 <lambdabot>   *Exception: Prelude.Enum.().succ: bad argument
13:32:10 <parcs> > fix succ
13:32:11 <lambdabot>   *Exception: Prelude.Enum.().succ: bad argument
13:32:27 <parcs> oh, duh
13:36:38 <Hilbert> Hey, how do I add a timer to a haskell script
13:39:57 <cdsmithus> Hilbert: Perhaps: forkIO $ forever $ do { threadDelay interval ; myAction }
13:45:29 <token22> could you help me with this pls http://pastebin.com/EjahanAv
13:46:09 <token22> it still has problem with types 22. (+) Strom (BTree a) => BTree a -> BTree a -> BTree a
13:46:20 <token22> Inferred type : Strom (BTree Int) => BTree Int -> BTree Int -> BTree Int
13:47:16 <parcs> why is () an instance of Bounded and Enum?
13:47:29 <token22> i want to '+' to use as conjuction of two bin trees tree Main.+ tree1
13:47:37 <ray> because it's bounded and it's an enumeration
13:51:21 <monochrom> tzipWith works for BTree Int only. the Strom instance for (BTree a) requires code that works for arbitrary (BTree a). OK, not too arbitrary, but definitely not pinned down to Int.
13:52:13 <monochrom> if you change tzipWith to like (tzipWith :: Strom a => BTree a -> BTree a -> BTree a), then you have a better chance.
13:52:36 <monochrom> and of course then you won't be using Prelude.+ all that much
13:53:54 <parcs> > succ 5.1 :: Double
13:53:55 <lambdabot>   6.1
13:54:12 <pokoko222> can someone please help me with Kruskal minimum spanning tree algorithm? i have some questions
13:54:48 <monochrom> perhaps better luck in #haskell-blah
13:55:27 <monochrom> oh god deech is devious! "last = head. reverse" :)
13:55:42 <ray> enum float is almost completely ridiculous
13:57:58 <ray> > (,) (enumFromTo 0.3 3.0) (enumFromThenTo 0.3 0.6 3.0)
13:57:59 <lambdabot>   ([0.3,1.3,2.3,3.3],[0.3,0.6,0.8999999999999999,1.1999999999999997,1.4999999...
13:59:24 <Cale> I think of Enum as the class for defining [a,b..n] and related syntaxes. From that point of view, the instance for Float isn't all that bad, though it does have some issues.
14:00:03 <ray> yeah that's a fine way to look at it once you move succ and pred out
14:00:24 <monochrom> not really reliable for things like [n, n+0.1 ..] but there are reliable uses like [n, n+1 ..] and even [n, n+0.5 ..]
14:00:53 <monochrom> I guess I don't mind either way
14:00:56 <Cale> token22: Just a note: there are tab characters in your text. Make sure to configure your editor properly to convert tabs to spaces automatically.
14:01:27 <ray> it's not really a problem for me because i just go on guard when using floating point types
14:01:29 <monochrom> oh heh, the tabs in that file works so far
14:01:34 <Cale> It's certainly convenient to be able to write [0..10] :: [Float]
14:01:51 <monochrom> yeah, everyone should absolutely go on guard when using floating point
14:01:53 <token22> Cale hm is it matter?
14:02:05 <Cale> token22: It doesn't matter in your file right now, but it does in general.
14:02:14 <token22> okay then
14:02:26 <ray> well you could just map fromIntegral [0..10] in that case
14:02:27 <parcs> @type [0..10]
14:02:28 <lambdabot> forall t. (Num t, Enum t) => [t]
14:02:32 <Cale> token22: The compiler will treat tab characters as aligning to the column whose index is the next larger multiple of 8
14:02:44 <Cale> token22: But not all text editors do, which can get confusing.
14:02:52 <ray> :t 0
14:02:53 <lambdabot> forall t. (Num t) => t
14:03:06 <parcs> @instances Num
14:03:07 <lambdabot> Double, Float, Int, Integer
14:03:21 <token22> Cale okay okay, i ma just trying to make it work, but always get error
14:03:29 <ray> a little nuance there with integer literals to keep in minid
14:03:31 <ray> :t 0.0
14:03:31 <lambdabot> forall t. (Fractional t) => t
14:03:34 <Cale> token22: The actual problem with your code is that tzipWith has too specific a type to work with an arbitrary BTree a
14:03:47 <Cale> token22: It only works with BTree Int values, according to its type signature.
14:04:49 <Cale> tzipWith :: (Num a) => BTree a -> BTree a -> BTree a -- you could generalise it to this:
14:04:52 <Cale> but then:
14:04:57 <token22> Cale yes this was said already but i am still trying to fix it
14:05:03 <Cale> instance (Num a) => Strom (BTree a) where -- the instance has to change to this
14:05:40 <Cale> Actually, tzipWith, based on its name alone, should probably have another parameter
14:05:48 <Cale> (a combining function)
14:06:06 <monochrom> let's not second-guess about names
14:06:31 <token22> yes, it had, but i removed the function as it made problems
14:08:22 <Cale> Btw, you can use any sequence of symbol characters for infix operators. There's no need to reuse (+) from the Prelude.
14:08:53 <Cale> Having to qualify infix operators is really ugly.
14:11:44 <token22> i still get this "tree.hs":21 - Ambiguous class occurrence "Num"
14:12:30 <mauke> did you redefine Num?
14:15:17 <monochrom> god I hope not
14:15:26 <token22> :-) it now works
14:15:46 <token22> i need to write Prelude.Num
14:16:29 <token22> thanks
14:16:57 <monochrom> I wash my hands off this.
14:19:58 <token22> and now find out why it works
14:19:59 <Hilbert> If a haskell program is unable to allocate mermory, what can I do?
14:20:19 <mauke> Hilbert: go down in flames
14:21:19 <Hilbert> If works perfect for small numbers but fails for number above approx 50,000
14:23:34 <monochrom> improve the program
14:24:06 <TTimo> is there a shorthand way to say a function has the same signature than another, rather than copy pasting ?
14:24:50 <monochrom> "f , g :: Int -> Int -> Int -> Int -> Int"
14:26:35 <TTimo> k
15:05:02 <augur> > 1 == True
15:05:02 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
15:05:03 <lambdabot>    arising from the literal `1'...
15:07:26 <se> merry christmas!
15:09:57 <cole> What's the best web development framework in haskell?
15:11:57 <Hunner> There was a thread on reddit recently about that I think...
15:13:10 <Hunner> cole: http://www.reddit.com/r/haskell/comments/e7wiw/which_web_framework_should_i_use/
15:13:28 <Hunner> Summary: The "best" depends on your use case
15:13:37 <ion> augur: instance Num Bool where fromInteger = (0 /=) . fromInteger ;-)
15:13:59 <augur> sorry what
15:14:11 <ion> 1 == True
15:14:26 <augur> oh lol
15:14:41 <augur> ion: no, i was just verifying that i wasnt crazy when i said what the haskell == truth table looked like
15:15:45 <augur> http://www.reddit.com/r/programming/comments/etw3g/problem_boole_comparisons_in_php/c1awit4 <-- here and in the subthread http://www.reddit.com/r/programming/comments/etw3g/problem_boole_comparisons_in_php/c1ay64g
15:16:19 <vegai> cole: snap and yesod seem to be competing for that spot currently
15:16:34 <cole> vegai: Not happstack?
15:16:51 <vegai> not in my book, but ymmv
15:17:59 <systemfault> PHP is a joke that some people took seriously.
15:18:13 <augur> systemfault: x3
15:18:20 <augur> unfortunately true
15:20:39 <accel> is there anything like luabind or pythonbind but for haskell? i.e. a way to bind C++ code to Haskell
15:20:44 <accel> (besides wrapping all C++ code in C)
15:31:09 <cole> When I attempted to install hapstack via cabal install I received: Registering happstack-server-0.5.0.4... cabal: Error: some packages failed to install: happstack-0.5.0.3 depends on hsp-0.5.2 which failed to install. hsp-0.5.2 failed during the building phase. The exception was: ExitFailure 1
16:03:23 <cole> I keep getting the error: "Failed to laod interface for 'Happstack.Server'" What's wrong?
16:03:35 <mauke> happy new year
16:05:51 <gwern> hm. that's my new response to any new problems. 'Status: closed. Comment: Happy new year.'
16:06:17 <McManiaC> lol
16:06:19 <McManiaC> :D
16:16:23 <Codex_> hmm, how do I make a type conversion (both types are Word32... it gives error on converting GLenum to GLbitfield? :)
16:18:52 <siracusa> Codex_: Try toEnum . fromEnum
16:19:08 <mauke> fromIntegral
16:20:27 <Codex_> oh, that worked
16:20:37 <Codex_> the toEnum . fromEnum one at least
16:21:07 <ivanm> @slap people that still force using parsec-2 and not parsec-3
16:21:07 * lambdabot beats up people that still force using parsec-2 and not parsec-3
16:22:52 <polarina> What license do you recommend for projects? The modified BSD or the simplified BSD one?
16:23:11 <roconnor> me prefers MIT
16:23:19 * roconnor prefers MIT
16:23:38 <roconnor> which might be the same as the simplified BSD?
16:23:39 <ivanm> I think MIT is equiv to the simplified BSD one
16:24:31 <mauke> LGPL
16:24:49 <mafs> It depends.
16:26:14 <jmcarthur> MIT FTW
16:26:14 <lambdabot> jmcarthur: You have 1 new message. '/msg lambdabot @messages' to read it.
16:27:56 <mafs> I do have to agree, I'm fairly partial to the MIT License
16:28:05 <Veinor> ivanm: the only difference is the advertising clause, iirc
16:28:17 <ivanm> Veinor: between -2 and -3?
16:28:23 <ivanm> if so, yeah
16:28:25 <Veinor> between MIT and simplified-BSD
16:28:33 <ivanm> oh? I thought they _were_ the same
16:28:47 <Veinor> oh, by simplified you mean 2-clause
16:28:49 <Veinor> yeah
16:42:48 <cncl> haha, i didn't know () had a monoid instance
16:43:20 <mauke> > [minBound .. maxBound] :: [()]
16:43:21 <lambdabot>   [()]
16:43:49 <ray> > () `mplus` ()
16:43:50 <lambdabot>   Couldn't match expected type `m a' against inferred type `()'
16:43:57 <ray> i ALWAYS screw those up
16:44:05 <ray> > () `mappend` ()
16:44:06 <lambdabot>   ()
16:44:20 <mauke> > [minBound .. mempty] :: [()]
16:44:21 <lambdabot>   [()]
16:44:49 <cncl> comment on the implementation of the () monoid instance: -- Should it be strict?
16:45:05 <ray> no
16:45:16 <cncl> i mean, that is in the actual code
16:45:17 <cncl> haha
16:45:22 <cncl> that comment
16:45:23 <ray> yeah i'm just answering it
17:03:02 <megajosh2> :t (.:)
17:03:03 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
17:03:25 <megajosh2> @src (.:)
17:03:25 <lambdabot> Source not found. Just what do you think you're doing Dave?
17:03:33 <megajosh2> What in the world IS that?
17:03:39 <megajosh2> fmap?
17:03:42 <mauke> :t (.)(.)(.)
17:03:43 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
17:03:50 <megajosh2> ...oh my
17:04:26 <mauke> > (sqrt .: (+)) 2 2
17:04:28 <lambdabot>   2.0
17:04:39 <megajosh2> Hmmm
17:04:52 <megajosh2> So its like a . for two argument functions?
17:04:56 <mauke> yes
17:05:42 <ion> @unpl (.).(.)
17:05:42 <lambdabot> (\ i b c f -> i (b c f))
17:06:04 <megajosh2> @unpl (.)(.)
17:06:04 <lambdabot> (\ b c e f -> b c (e f))
17:08:15 <megajosh2> > (.)(.) (+) 2 (2+) 1
17:08:17 <lambdabot>   5
17:12:17 <ion> > (.)(.)(.)(.)(.) (1+) (1+) (1+) 1
17:12:19 <lambdabot>   4
17:15:20 <mux> yay, my NFA determinization algorithm works
17:15:36 <mux> and it supports epsilon moves
17:21:28 <lars9> :t RealWorld
17:21:29 <lambdabot> Not in scope: data constructor `RealWorld'
17:21:37 <lars9> @hoogle RealWorld
17:21:38 <lambdabot> No results found
17:21:59 <mauke> the RealWorld is a lie
17:22:44 <lars9> mauke: does it exist in ghc?
17:22:52 <mauke> depends on your definition of "exist"
17:23:31 <lars9> defined in language
17:25:38 <ray> that is of similar vagueness to "exist"
17:25:58 <ray> you'll find some State# RealWorld in the ghc source
17:26:03 <ray> or similar
17:26:28 <ray> (this is one of my areas of disexpertise)
17:27:32 <lars9> see
17:27:35 <shachaf> ray: We're counting unbirthdays now?
17:28:06 <ray> if so, happy unbirthday
17:28:27 <tswett> Hey, I think Agora's unbirthday was yesterday.
17:28:50 <ray> 2011's unbirthday was yesterday too
17:30:11 <tswett> Yes, Agora's unbirthday was yesterday, but since it occurs during a holiday, it's observed in the middle of January.
17:30:27 <spetrea> everybody here, have a happy new year !
17:30:40 <lars9> happy new year
17:31:00 <tswett> I refuse to have a happy new year until midnight local time.  But as for you, happy new year!
17:34:37 <tkuro11> happy new year too
17:36:03 <mreh> happy new year europe
17:36:46 <ivanm> eh, the "new year" looks exactly the same as the old one to me... >_>
17:37:05 <tswett> ivanm: I haven't seen it yet.  No spoilers!
17:37:11 <ivanm> heh
17:38:41 <tkuro11> representing string as list seems inefficient for me. are there any optimization?
17:39:08 <jmcarthur> tkuro11: there's bytestring, text, sequence, all kinds of stuff
17:39:26 <tkuro11> thanx i will try
17:39:31 <jmcarthur> tkuro11: which one to use depends on how you intend to use it
17:53:50 <sshc> Data.ByteString.take seems to be quite inefficient.  I'm making many thousands of comparisons between many substrings of two large strings, and I'm generating the substrings with Data.ByteString.take and Data.ByteString.drop.  Do those functions copy the bytestring?
18:00:28 <roconnor> Why all the hate with haskeller's use of lots of operator symbols?
18:02:01 <monochrom> cobol psychology
18:02:44 <roconnor> I guess these are the same people who say math is all greek to them.
18:03:13 <roconnor> I still find it bizzare that some people who like programming dislike mathematics, given that it is practically the same subject.
18:03:31 <systemfault> Well.. programming is applied maths..
18:03:44 <systemfault> Not "intellectual masturbation" to them
18:04:09 <monochrom> you look at python import lines and you understand. "from xxx import yyy". insisting on an imperialist natural language that has no future, rather than a neutral symbolic language that has true potential to be universal.
18:05:52 <monochrom> real applied maths doesn't read like "multiple x to y yielding z" either.
18:06:12 <monochrom> s/multiple/multiply/
18:06:29 <monochrom> the parallel with "from x import y" is horrifying
18:07:15 <monochrom> the cry of "so more people can program" is a case of those who have learned from history are bound to watch it repeat itself
18:08:00 <monochrom> I for one am pretty sure 1/2 of world's population would rather programming languages not be biased to English.
18:08:32 <tg_> The same half who wouldn't understand that sentence?
18:08:45 <systemfault> ...
18:08:45 <monochrom> well, they probably do.
18:09:05 <tg_> hehe ;)
18:09:05 <systemfault> Come on... Even if you don't like it, english is the real "esperanto"
18:09:09 <tg_> yeah
18:09:17 <tg_> well, whatever you'd like to call it
18:09:25 <tg_> it's global language attempt 1.0a
18:09:26 <monochrom> doesn't have to carry it over to programming languages
18:09:31 <systemfault> I telling you that and english isn't my first language.
18:09:41 <tg_> sure
18:09:42 <systemfault> monochrom: What would you prefer.. APL?
18:10:13 <tg_> It wasn't chosen with a great deal of intentionality, it was chosen in the way lots of things just accidentically get chosen when not thought about
18:10:22 <tg_> or when things are moving too fast
18:10:25 <monochrom> and even if you insist on English, "import x(y)" has much less baggage than "from x import y", you see?
18:10:38 <systemfault> Right
18:10:40 <ion> tee rivi â† lueRivi; tulosta rivi -- TÃ¤mÃ¤n voisi kirjoittaa paremminkin.
18:10:44 <ion> Now contribute my project!
18:10:46 <ion> to
18:11:22 <monochrom> the spurrious "from" is the same ghost behind "multiply x to y yielding z"
18:11:28 <tg_> for that matter, why are we limiting it to simple(er) typography. Why not allow any LaTeX?
18:11:40 <tg_> I guess I don't care enough because English is my 1st language
18:12:05 <ion> Why not allow images?
18:12:59 <tg_> haskell does do unicode source now, right?
18:13:09 <ion> Almost.
18:13:42 <ion> My pet peeve is that Î» is still not handled as \ :-)
18:14:02 <tg_> well, you have counterexample interactions
18:14:04 <tg_> that do things you're thinking of
18:14:09 <tg_> namely, Mathematica comes to mind :)
18:14:52 <ion> And exactly one person will be surprised to learn she *is* it.
18:15:51 <tg_> hm. lost me there.
18:16:14 <tg_> ssh: anyone respond to your question?
18:16:25 <ion> I guess your client ignores quit lines. RayNbow [kirika@scientia.demon.nl] has quit [Quit: When science finally locates the center of the universe, some people will be surprised to learn they're not it]
18:16:43 <tg_> oh, I just ferry them off to another window
18:18:10 <monochrom> that sentence must have been written before the big bang theory
18:19:14 <tg_> ion: It's interesting to realize that under the current standard model of cosmology (with accelerating expansion) show a future picture in which everyone will see themselves as the center of an island galaxy
18:20:19 <tg_> so, it's not true right now, but in the [far, far, far] future it will once again be appropriate to say they are at the center of the universe
18:21:29 <ion> That is, in the center of the observable universe, right?
18:21:58 <Jesin> aren't we already at the center of the observable universe?
18:21:58 <augustss> Happy New Year!
18:22:10 <tg_> Jesin: nope
18:22:19 <tg_> ion: the only universe we know
18:22:38 <Jesin> well, we're not too far off center, are we?
18:22:52 <ion> Until someone comes up with FTL travel. :-P
18:23:17 <monochrom> with new year comes new fear. bad pun.
18:23:22 <tg_> Jesin: Standard cosmologists would just answer that it's not appropriate to define a center
18:23:45 <Jesin> well, I agree with that
18:24:17 <Jesin> but if you *do* try to define a center it tends to end up near us, yes?
18:24:22 <Jesin> :p
18:24:24 <augustss> I bet we're close to the center of the Haskell part of the universe.
18:25:48 <monochrom> everything is close to everything by induction
18:26:17 <tg_> Jesin: Trying to come up with a thoughful answer.
18:28:11 <mikeg> Could someone point me to an example for using the -> monad?
18:28:59 <Jesin> oh wow
18:29:11 <Jesin> what would do notation come out as with that?
18:29:12 <Cale> mikeg: Well, the basic idea is that "running" a function means to apply it to the parameter to which the overall function has been applied
18:29:13 <Cale> So:
18:29:31 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "Hello"
18:29:32 <lambdabot>   ("Hello","olleH","HELLO")
18:29:48 <allbery_b> Jesin:  it's usually called ((->) e) and is the basic form of Control.Monad.Reader
18:29:55 <Cale> That's (->) String, in my case
18:30:17 <Cale> So you get nice things like  join f x = f x x
18:30:22 <mikeg> > map ($ "Hello") [id, reverse, map toUpper]
18:30:23 <lambdabot>   ["Hello","olleH","HELLO"]
18:30:25 <allbery_b> sorry, ((->) r) is more conventional
18:30:30 <Cale> and  liftM2 f g h x = f (g x) (h x)
18:30:42 <mikeg> Is that a totally different concept?
18:30:53 <Cale> allbery_b: Doesn't matter what the type variable is named of course ;)
18:30:56 <allbery_b> there are various sneaky ways it can be used, as Cale is showing; one usually doesn't bother with do notation, but uses ap or fmap
18:31:03 <Cale> mikeg: well, it's related
18:31:15 <allbery_b> true, but a consistent basis helps in recognizing it
18:31:15 <Cale> > sequence [id, reverse, map toUpper] "Hello"
18:31:16 <lambdabot>   ["Hello","olleH","HELLO"]
18:31:36 <mikeg> Ah neat, that's the syntax i forgot :)
18:31:59 <Cale> > liftM2 (||) even odd 5
18:32:00 <lambdabot>   True
18:32:14 <Azrael-> Is there any way to get GHCi to parse the stdin and pass it straight to stdout?
18:32:27 <Cale> :t interact
18:32:28 <lambdabot> (String -> String) -> IO ()
18:32:36 <Cale> Azrael-: er, hmm
18:32:55 <Cale> Azrael-: What are you trying to do?
18:33:43 <Azrael-> use ghci non-interactively
18:33:54 <Azrael-> (kind of a paradox i guess)
18:34:05 <Azrael-> but i want to do something like ghci --magic 1+1
18:34:14 <Cale> ghc -e '1 + 1' ?
18:34:15 <allbery_b> ghc -e 
18:34:21 <monochrom> echo "1 + 1" | ghci  works
18:34:41 <Azrael-> ah, awesome
18:34:48 <Azrael-> thanks, ghc -e is exactly what i was looking for
18:36:32 <allbery_b> it's also possible to use the GHC API (or wrappers around it such as hint) to do custom stuff along those lines
18:36:51 <monochrom> echo -e "let f x = x-x\nf 5" | ghci  also works
18:37:26 <Azrael-> it also spews out all the other stuff about starting up
18:37:39 <monochrom> that is a feature, not a bug
18:38:03 <ion> also, printf '%s\n' 'let f x = x-x' 'f 5'
18:38:10 <bsmntbombdood> oh cool
18:38:16 <bsmntbombdood> liftM2 id === S combinator
18:40:05 <parcs> :t liftM2 id
18:40:06 <lambdabot> forall a2 r (m :: * -> *). (Monad m) => m (a2 -> r) -> m a2 -> m r
18:40:23 <Cale> liftM2 id  can also be written  ap
18:40:28 <Cale> :t ap
18:40:29 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
18:45:53 <lars9> according to typeclassopedia,  there is some redundancy in haskell's type class design, functor, applicative, monad... etc
18:46:36 <lars9> so what's the perfectly orthogonal design?
18:49:58 <azaq231> > let f x | x <- [10] = 12 + x in f 4
18:49:59 <lambdabot>   No instance for (GHC.Num.Num [t])
18:49:59 <lambdabot>    arising from a use of `e_110124' at <i...
18:50:49 <azaq231> > let f x | x <- [10] = 12 + x !! 0 in f 4
18:50:50 <lambdabot>   22
18:50:56 <azaq231> this arrow, what is it?
18:51:03 <azaq231> that's not a do
18:52:04 <ion> http://www.haskell.org/haskellwiki/Pattern_guard
18:52:28 <azaq231> thanks
19:00:05 <parcs>  > let f x | (Just x) <- [10] = 12 + x in f 4
19:00:11 <parcs> > let f x | (Just x) <- [10] = 12 + x in f 4
19:00:12 <lambdabot>   Couldn't match expected type `[t]'
19:00:12 <lambdabot>         against inferred type `Data.Mayb...
19:00:50 <parcs> > let f x | (Just x) <- Nothing = 12 + x in f 4
19:00:51 <lambdabot>   *Exception: <interactive>:3:4-37: Non-exhaustive patterns in function f
19:03:56 <parcs> > let f x | otherwise = 12 + x in f 4
19:03:57 <lambdabot>   16
19:12:02 <ion> @tell BONUS It might be helpful for people who know imperative programming languages if LYAH showed a parallel to a list comprehension like [x*y | x â† [2,5,10], y â† [8,10,11], x*y > 50] as â€œfor each x in [2,5,10]: for each y in [8,10,11]: if x*y > 50: append x*yâ€
19:12:02 <lambdabot> Consider it noted.
19:17:17 <augur> whats the thing that lets you find a library function for some definition?
19:17:30 <parcs> hoogle, hayoo
19:17:36 <parcs> @hoogle a -> a
19:17:36 <lambdabot> Prelude id :: a -> a
19:17:36 <lambdabot> Data.Function id :: a -> a
19:17:36 <lambdabot> Control.Exception mapException :: (Exception e1, Exception e2) => (e1 -> e2) -> a -> a
19:17:39 <mauke> pl, sometimes
19:17:46 <augur> mm
19:17:54 <augur> @pl flip ($)
19:17:55 <lambdabot> flip id
19:18:01 <parcs> oh, not type definition
19:18:04 <augur> ya
19:18:04 <mauke> >>>
19:18:15 <augur> is that what it is?
19:18:19 <augur> i take it >>> is left assoc
19:18:27 <mauke> not sure, never used it
19:18:39 <augur> > odd 3
19:18:39 <lambdabot>   True
19:18:53 <augur> > [1,2,3] >>> filter odd >>> map (**2)
19:18:54 <lambdabot>   Couldn't match expected type `cat a b' against inferred type `[a1]'
19:19:05 <parcs> >>> is inverted function composition i think
19:19:07 <augur> i guess ** isnt exponentiation :p
19:19:11 <augur> > [1,2,3] >>> filter odd >>> map (*2)
19:19:11 <lambdabot>   Couldn't match expected type `cat a b' against inferred type `[a1]'
19:19:12 <mauke> whoops
19:19:20 <augur> definitely not that, mauke
19:19:20 <augur> :p
19:19:28 <augur> > [1,2,3] >> filter odd >> map (*2)
19:19:28 <lambdabot>   Couldn't match expected type `[a]'
19:19:29 <lambdabot>         against inferred type `[a1] -> [...
19:19:36 <mauke> :t filter odd >>> map (*2)
19:19:37 <lambdabot> forall a. (Integral a) => [a] -> [a]
19:19:47 <augur> oh ok
19:19:52 <mauke> parcs: right
19:19:54 <Jesin> @pl ($)
19:19:55 <lambdabot> id
19:20:04 <Jesin> @pl (>>>)
19:20:05 <lambdabot> (>>>)
19:20:14 <augur> so is there a built in left assoc version of flip ($)?
19:20:22 <mauke> @. hoogle type flip ($)
19:20:23 <lambdabot> Parse error:
19:20:23 <lambdabot>   --count=20 "forall a b. a -> (a -> b) -> b
19:20:23 <lambdabot> "
19:20:31 <Jesin> :t ($)
19:20:32 <lambdabot> forall a b. (a -> b) -> a -> b
19:20:36 <mauke> @hoogle a -> (a -> b) -> b
19:20:37 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
19:20:37 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
19:20:37 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
19:20:38 <Jesin> :t (>>>)
19:20:39 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
19:20:51 <mauke> augur: doesn't look like it
19:20:52 <Jesin> :t (Control.Category..)
19:20:53 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
19:21:00 <augur> mauke: k
19:21:10 <augur> :t ($$)
19:21:11 <lambdabot> Doc -> Doc -> Doc
19:21:12 <Jesin> :t (.) >>> (.)
19:21:13 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f1 (f a) -> f1 (f b)
19:21:16 <augur> wtf is that
19:21:20 <Jesin> :t (.) . (.)
19:21:21 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
19:21:32 <parcs> pretty-printing thing
19:22:09 <augur> well anyway, haskell is great for making it possible to code with a vaguely OO style if one choses
19:22:11 <augur> :T
19:22:18 <augur> :t (>>)
19:22:19 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
19:22:20 <mauke> that reminds me
19:22:22 <augur> right
19:22:39 <mauke> if you're going to define your own flip ($), please don't call it (.)
19:22:45 <augur> well duh
19:22:47 <augur> thats idiotic
19:22:55 <Jesin> umm
19:22:55 <parcs> augur: are you trying to do something like 5 $ (^2) . (+10) ?
19:22:57 <Jesin> guys
19:23:01 <mauke> I've seen people do that and write "foobar".sort.show.putStrLn
19:23:10 <augur> parcs: well you could do that but thats not the point
19:23:11 <mauke> it's totally like ruby guise
19:23:20 <Jesin> I think (>>>) is equivalent to  flip ($)
19:23:25 <Jesin> just more general
19:23:36 <augur> mauke: yeah but then you have to define all sorts of janky shit like what you said not to do
19:23:57 <augur> i mean, i like the aesthetic of method calls on lists, etc. just for chaining purposes
19:24:00 <mauke> Jesin: hello and welcome to 5 minutes ago, where I was proven wrong
19:24:06 <augur> but redefining (.) is stupid
19:24:07 <Jesin> umm
19:24:10 <mauke> Jesin: it's actually flip (.), not flip ($)
19:24:11 <Jesin> how were you proven wrong?
19:24:14 <Jesin> oh.
19:24:20 <mauke> augur tried some code
19:24:21 <Jesin> yeah, ok
19:24:26 <augur> mauke: ?
19:24:33 <augur> oh, you were referring to me, not addressing me
19:24:33 <augur> haha
19:24:34 <augur> :D
19:25:25 <augur> mauke: the aesthetics of, say, xs :> filter odd :> map (*2)
19:25:39 <augur> is nicer, i think, than map (*2) (filter odd xs)
19:25:46 <Jesin> :>
19:25:49 <Jesin> <:
19:25:51 <Jesin> .^.
19:25:54 <Jesin> 'v'
19:25:56 <mauke> (that's a constructor name)
19:26:03 <augur> whatever
19:26:05 <Jesin> what is?
19:26:11 <augur> im not trying to propose it as an actual operator :p
19:26:11 <Jesin> which one's a constructor name?
19:26:13 <mauke> I can see that
19:26:15 <augur> im just makin shit up for convenience
19:26:23 <mauke> Jesin: :whatever
19:26:30 <mauke> : is an uppercase symbol
19:26:37 <Jesin> ah.
19:26:41 <Jesin> I know
19:26:43 <augur> >>:
19:26:47 <Jesin> we should use >_>
19:26:49 <Jesin> and <_<
19:26:51 <mauke> :t ($>)
19:26:51 <Jesin> :D
19:26:52 <lambdabot> Not in scope: `$>'
19:26:53 <monochrom> data Smile = Int :> Bool
19:26:53 <augur> ^_^
19:26:56 <augur> v_v
19:27:10 <mauke> $> seems to be available
19:27:15 <augur> well then!
19:27:25 <sshc> What is a portable way to determine the endianness of the host machine?
19:27:30 <augur> xs $> filter odd $> map (*2)
19:27:51 <mauke> sshc: could go via Foreign.Ptr
19:28:35 <Jesin> umm
19:28:44 <Jesin> mauke, how do we know which punctuation counts as uppercase?
19:28:51 <augur> Jesin: look it up
19:28:57 <Jesin> where?
19:29:04 <monochrom> by reading http://www.haskell.org/onlinereport/haskell2010/
19:29:06 <augur> specs somewhere
19:29:10 <augur> like there
19:29:17 <augur> TAKE THAT, JESIN
19:29:20 <augur> UNF
19:29:20 <mauke> with (1 :: CInt) $ \p -> fmap (0 ==) (peekPtr (cast p :: Ptr CChar))
19:29:33 <mauke> or something along those lines
19:29:36 <Jesin> NFU
19:29:39 <Jesin> ...
19:29:48 <Jesin> except I don't particularly like urelements
19:29:50 <Jesin> :p
19:30:19 <monochrom> alternative you can ask me
19:30:32 <mauke> :t with (1 :: CInt) $ \p -> fmap (0 ==) (peekPtr (cast p :: Ptr CChar))
19:30:33 <lambdabot> Not in scope: `with'
19:30:33 <parcs> is : the only exception? (i presume it's to be consistent with pattern-matching with :)
19:30:33 <lambdabot> Not in scope: type constructor or class `CInt'
19:30:33 <lambdabot> Not in scope: `peekPtr'
19:30:41 <monochrom> yes
19:31:26 <mauke> :t aa ab ac ad ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az
19:31:27 <lambdabot> Not in scope: `aa'
19:31:27 <lambdabot> Not in scope: `ab'
19:31:27 <lambdabot> Not in scope: `ac'
19:31:45 <sshc> Is there a pragma or #define that's defined for the endianness?
19:32:38 <mauke> is my method not good enough? :-(
19:32:53 <sshc> Hmm, I wsas scrolled up
19:33:45 <sshc> That method is great, thanks
19:34:56 <mauke> there's a sneaky/obfuscated solution using PortNum
19:35:14 <monochrom> hahaha that's clever
19:35:29 <mauke> 1 == PortNum 1, basically
19:44:13 <hinkes> Hey haskell users.  New user here.  Is anyone familure with the simpleirc package?
19:53:36 <Cale> hinkes: Not familiar, but ask a question anyway :)
19:54:02 <Cale> (It's easy enough for me to look things up)
19:54:15 <hinkes> given the simpleirc API, how can I store messages in the program, to be recalled later?
19:55:07 <ManateeLazyCat> hinkes: fastirc is better package for IRC protocol
19:55:32 <hinkes> For instance, I want a haskell simpleirc bot to record all conversations, and the bot can "replay" upon request.
19:55:48 <Cale> Well, the same way you'd store anything else? You could use a function parameter, or an IORef.
19:56:26 <roconnor> hinkes: how persistent do you want it?  persistent between runs of the program?
19:57:22 <hinkes> I would think a State Monad would fit the bill ... but I don't know how to make it fit in an EventFunc.
19:57:39 <hinkes> Not persistent between runs
19:58:18 <hinkes> IORef?  I haven't made it too far in the Real World Haskell book yet.
19:58:30 <gwern> why not just pass a Map of conversations between functions?
19:58:42 <Cale> http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.0.0/Data-IORef.html
19:58:46 <gwern> you use state monad when you want monad features or have a lot of Maps and other data structures to pass around
19:59:14 <Cale> But yeah, if you have something like  messageLoop = do ... read and write messages over the network ...; messageLoop
19:59:36 <gwern> simple problem, simple solutions
19:59:39 <Cale> Then you can just add a parameter to that which is the current set of messages you're keeping track of
19:59:45 <hinkes> Yes, I map of conversations would be great.  How do I get the API to pas the map around from EventFuncc to EventFunc?
20:01:23 <ion> @tell BONUS Thereâ€™s an erroneous space in a type of addVectors in LYAH/syntax-in-functions. Btw, hopefully Walt Disney doesnâ€™t launch an army of lawyers at you for using the likeness of Kermit. :-)
20:01:23 <lambdabot> Consider it noted.
20:01:24 <hinkes> "[A] map of conversations" ... this hotel internet connections sucks ... lag lag lag
20:01:39 <Jesin> :t (:)
20:01:40 <lambdabot> forall a. a -> [a] -> [a]
20:01:46 <Cale> Ah, okay, an EventFunc is a handler for a given message. You should just use an IORef, I think.
20:02:03 <mauke> ion: also, nintendo
20:02:10 <hinkes> Thanks Cale! I'll look into that.
20:02:30 <hinkes> Cale++
20:02:43 <Cale> the API for IORefs is simple: you have newIORef :: a -> IO (IORef a), which makes a new IORef having a given initial value
20:03:09 <Cale> and then  readIORef :: IORef a -> IO a  and  writeIORef :: IORef a -> a -> IO ()
20:03:31 <Cale> which read and write the mutable reference with a new value
20:04:03 <Cale> You could then just use whatever immutable structure is appropriate to store your collection of messages, like a Data.Map, for instance.
20:04:54 <Cale> So, the idea will be that at some point before setting the handlers in your program, you create a new IORef, and then refer to that IORef from the various handlers.
20:09:04 <Random75> What does the error the type signature for myLength lacks an accompanying binging? The statement is: myLength :: [x] -> Integer
20:09:18 <Random75> binding*
20:09:59 <ion> > let foo :: Integer in foo
20:10:00 <lambdabot>   The type signature for `foo' lacks an accompanying bindingNot in scope: `foo'
20:10:06 <mauke> Random75: you didn't define myLength
20:10:56 <Random75> I put the myLength = ...... after?
20:11:04 <Random75> myLength [x] = ...
20:11:18 <mauke> no, you didn't
20:11:30 <mauke> show your real code
20:11:31 <Random75> mauke: thanks...
20:11:37 <Random75> case problem
20:11:55 <mauke> yeah, compilers are really good at spelling, unfortunately
20:12:17 <hinkes> Cale: so how would I get the IORef I created passed into the EventFunc?
20:12:22 <Random75> beena  while since I have coded anything and I keep messing these very simple things up.
20:12:56 <mauke> if you're using vim, :set hlsearch and * are your friend
20:12:59 <mauke> also, tab completion
20:13:25 <monochrom> ghc 7 detects spelling errors
20:13:40 <Random75> whats hlsearch?
20:14:01 <mauke> highlight all occurrences of the search pattern
20:14:14 <Random75> ah cool
20:14:23 <hinkes> Cale: FYI: http://hackage.haskell.org/packages/archive/simpleirc/0.2.0/doc/html/Network-SimpleIRC-Core.html 
20:16:45 <Random75> Is there a way to stop ghci from running an infinite recursion?
20:17:12 <Random75> stop it while it is running?
20:17:27 <monochrom> ctrl-c
20:17:56 <Random75> monochrom: that just put ^C in the console
20:18:09 <monochrom> windows? my condolence
20:18:20 <mauke> if it's not windows, try ctrl-z
20:18:36 <monochrom> actually in some cases need ctrl-c twice
20:19:09 <Random75> it worked
20:19:59 <monochrom> I also ran into a case of needing sigterm twice
20:21:19 <ManateeLazyCat> hinkes: If you want irc demo, you can read my source code : at package manatee-ircclient
20:21:23 <ManateeLazyCat> @package manatee-ircclient
20:21:24 <lambdabot> http://hackage.haskell.org/package/manatee-ircclient
20:21:40 <ManateeLazyCat> I use fastirc to parse IRC protocol
20:25:08 <j-invariant> what does this mean? "Since the inverse limit construction of recursive types is what Dana Scott did instead of proving the independence of the continuum hypothesis, it's one of the central mathematical ideas in programming languages."
20:26:03 <Veinor> wat
20:26:54 <monochrom> hahaha
20:27:20 <monochrom> firstly I think "inverse limit" there is more commonly called co-limit
20:28:03 <monochrom> secondly it's talking about nothingness. true statements of no value.
20:28:31 <Jafet> It wouldn't be valid in a substructural logic
20:28:42 <Jafet> I think
20:30:07 <Random75> I don't understand the errors ghci tells me.
20:30:43 <monochrom> I don't either.
20:31:17 <monochrom> anyway do not expect blogs to be meaningful.
20:31:38 <j-invariant> if D = C^op, then D --> .. and C^op --> .. are different..?
20:31:53 * monochrom finds that most blog ramblings are straw-man attacks.
20:32:41 <Veinor> Random75: expected-inferred type errors?
20:33:05 <Veinor> monochrom: that's why I only try to write about original thoughts I have, and not responses to other people. which is why i average one post/month :)
20:33:10 <Random75> Veinor: I think so... cannot construct the infinite type 
20:33:18 <Veinor> oh
20:33:19 <Random75> when generalizing the types
20:33:23 <Veinor> paste your code?
20:33:28 <monochrom> hahaha
20:33:31 <Veinor> that usually means you're doing something wrong
20:33:55 <monochrom> don't paste code. hang us in suspense.
20:33:55 <mauke> "infinite type" means you've confused yourself somewhere, like using a list as one of its elements or vice versa
20:34:17 <monochrom> use vivid poetic language to gradually leak out what's happening
20:34:22 <mauke> in newbie code it's usually a : vs ++ thing
20:34:36 <Random75> i know somethings wrong. is foo :: [x] -> [x]; foo (x:xs) = .... and I do have a ++
20:34:40 <monochrom> but always leave us room for imagination of what your real code is
20:35:08 <mauke> yeah, like that!
20:35:18 <Veinor> Random75: if you use ++, both things have to be lists
20:36:23 <Random75> so itd be xs ++ [x]? That the normal way to write it?
20:36:38 <mauke> to write what?
20:36:59 <Random75> foo (x:xs) = xs ++ [x]
20:37:08 <monochrom> the goal is to ensure different people imagine different code, so we always have something to argue over. like how some insightful people put both co-limit constructions and the continuum hypothesis in one sentence so readers have something to fight over.
20:37:20 <ManateeLazyCat> KVM running. :)
20:37:32 <Veinor> Random75: yeah, if you wanted a list with the first thing at the end
20:37:34 <djahandarie> ManateeLazyCat, people do that?
20:37:49 <mauke> monochrom: how sober are you on a scale from 1 to 27?
20:37:57 <djahandarie> Gah
20:38:05 <Random75> Veinor: is it clearer to do [xs] ++ [x]?
20:38:06 <djahandarie> Meant to highlight monochrom 
20:38:15 <Veinor> Random75: no, that won't typecheck
20:38:21 <mauke> Random75: irrelevant
20:38:32 <monochrom> someone wrote "Since the inverse limit construction of recursive types is what Dana Scott did instead of proving the independence of the continuum hypothesis, it's one of the central mathematical ideas in programming languages."
20:38:41 <Jafet> (++) xs ((:) x [])
20:38:42 <ManateeLazyCat> djahandarie: What what?
20:38:50 <Veinor> Random75: [xs] is a single-element list
20:38:53 <Veinor> whose element is the list xs
20:39:01 <Random75> I see, thanks for the help
20:39:02 <djahandarie> ManateeLazyCat, sorry, meant to send that message to monochrom, not you
20:39:03 <ManateeLazyCat> I'm running KVM, haven't follow this.
20:39:16 <ManateeLazyCat> djahandarie: What are you talking about ?
20:39:28 <djahandarie> I have no idea
20:39:34 * djahandarie just walked in himself
20:39:36 <ManateeLazyCat> typo. :)
20:42:10 <ManateeLazyCat> Ah, KVM still use Qmeu for I/O operation
20:42:16 <Jesin> *sigh*
20:42:26 <Jesin> the âŠ‚ vs âˆˆ problem again I see
20:42:27 <Jesin> :p
20:42:54 <Veinor> Jesin: ha, i never made that connection
20:43:05 <Veinor> also yessss i love the awodey pdf so much
20:43:35 <Jesin> well, asking if [xs] is "clearer" than xs
20:43:54 <Jesin> ...yeah, it's pretty much the âŠ‚ vs âˆˆ thing :p
20:44:05 <Jesin> hmm, awodey pdf?
20:44:09 * Jesin has not heard of this
20:44:14 <mauke> bonus question: which english word is immune against rot13?
20:44:32 <Jesin> vex
20:44:34 <Jesin> irk
20:44:42 <mauke> Jesin++
20:45:04 <ion> :-)
20:45:12 <cncl> take a list of integers, turn it into a period-separated string
20:45:16 <shachaf> @rot13 vex
20:45:17 <lambdabot> Unknown command, try @list
20:45:18 <cncl> clever way?
20:45:31 <mauke> intercalate "." . map show
20:45:57 <cncl> you win, good sir
20:46:01 <Jesin> ooh
20:46:28 <Veinor> Jesin: it's a pdf of a very nice intro to category theory
20:46:37 <Veinor> ftp://195.214.211.1/books/DVD-021/Awodey_S._Category_Theory(en)(305s).pdf
20:46:55 <Jesin> heh, I've been entertaining myself by thinking of ways to generalize functions as much as possible once http://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal is implemented
20:47:06 <banisterfiend> haskell programmers spend all their time reading about category theory and not actually writing applications
20:47:10 <banisterfiend> :P
20:47:26 <j-invariant> LOL
20:47:28 <Jesin> lol
20:47:30 <Jesin> anyway
20:47:42 <Veinor> Jesin: ugh, yes please
20:47:49 <Veinor> i would love that so much
20:47:50 <Jesin> "yes please" what?
20:47:57 <Jesin> ah, that proposal?
20:48:19 <Veinor> yeah
20:48:30 <Jesin> hmm
20:48:35 <Jesin> I also kind of like http://www.haskell.org/haskellwiki/Class_system_extension_proposal
20:49:14 <Jesin> which would enable the Functor hierarchy thing without having to add Functor and Applicative declarations to current Monads
20:49:41 <Jesin> though apparently there are some difficulties involved in implementing that?
20:50:47 <Jesin> anyway, yeah, that proposal would get allow map to work on functors, and would let us merge stuff like liftM2 and liftA2
20:51:07 <Jesin> which for the most part do exactly the same thing  :p
20:51:23 <Jesin> and then
20:51:30 <Jesin> intercalate should have a type signature more like...
20:51:34 <Jesin> hmm
20:51:37 <Jesin> :t intercalate
20:51:37 <lambdabot> forall a. [a] -> [[a]] -> [a]
20:52:06 <Jesin> (Applicative f) => f a -> f (f a) -> f a
20:52:08 <monochrom> (Functor f, Functor g) => f a -> f (g a) -> g a
20:52:15 <Jesin> or that
20:52:24 <Jesin> ...
20:52:29 <Jesin> yeah, that
20:52:33 <monochrom> I made it up.
20:52:51 <Jesin> you're sure it doesn't need one of them to be applicative?
20:52:57 <monochrom> no
20:53:01 <mauke> I don't see how any of that can work
20:53:19 <Jesin> mauke: any of which?
20:53:28 <monochrom> both of us :)
20:53:36 <Jesin> our frivolous intercalate proposal, or the more serious class extension thing?
20:53:41 <mauke> intercalate
20:53:45 <Jesin> k  :p
20:54:09 <Jesin> eh, I dunno
20:54:16 <cncl> intercalate only makes sense for something like a list
20:54:26 <Jesin> not necessarily
20:54:39 <cncl> how are you going to intercalate in Maybe
20:54:46 <Jesin> good point
20:54:50 <Jesin> hmm
20:54:51 <monochrom> > intercalate ":" ["hi", "you"]
20:54:52 <cncl> :)
20:54:53 <lambdabot>   "hi:you"
20:54:55 <mauke> how are you going to intercalate in (->) a?
20:54:56 <Jesin> what does join do with maybe, btw
20:55:06 <mauke> the obvious thing
20:55:14 <cncl> it returns nothing if any of them are nothing
20:55:19 <mauke> @djinn Maybe (Maybe a) -> Maybe a
20:55:20 <lambdabot> f a =
20:55:20 <lambdabot>     case a of
20:55:20 <lambdabot>     Nothing -> Nothing
20:55:20 <lambdabot>     Just b -> b
20:55:41 <Jesin> @src join
20:55:41 <lambdabot> join x =  x >>= id
20:55:54 <Veinor> join is usually 'obvious', i've found
20:56:01 <Jesin> k
20:56:23 <Jesin> :t join
20:56:24 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
20:56:32 <Jesin> riiight
20:56:40 <Jesin> ok
20:56:57 <Jesin> @src (>>=)
20:56:58 <lambdabot> Source not found. It can only be attributed to human error.
20:57:08 <Veinor> >>= is different for different monads.
20:57:13 <Jesin> yes
20:57:15 <Jesin> but
20:57:16 <shachaf> @check (\l -> (listToMaybe . join . maybeToList . fmap maybeToList) (l::Maybe (Maybe Int)) == join l)
20:57:17 <lambdabot>   "OK, passed 500 tests."
20:57:18 <monochrom> papa monad's secret sauce
20:57:19 <Jesin> I think the functor hierarchy proposal
20:57:24 <Jesin> hmm
20:57:48 <Jesin> "class Applicative m => Monad m where
20:57:49 <Jesin>     (>>=) :: m a -> (a -> m b) -> m b
20:57:51 <Jesin>     f >>= x = join $ map f x"
20:57:54 <shachaf> Veinor: Is fmap obvious? :-)
20:58:19 <Jesin> yeah, apparently you can define >>= in terms of join
20:58:47 <mauke> and map in terms of (>>=)
20:58:52 <Jesin> so it's not clear why it's not currently in the Monad typeclass with a default definition, like /= and == are in Eq
20:58:53 <mauke> @src liftM
20:58:54 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
20:58:57 <shachaf> Jesin: The standard definition of a monad is join/fmap/return.
20:59:00 <Veinor> shachaf: sometimes!
20:59:12 <shachaf> Jesin: What's even less clear is why fail is in there.
20:59:24 <monochrom> s/The standard/A standard/
20:59:27 <shachaf> Veinor: Are there situations where join and fmap are trivial but (>>=) is interesting? :-)
20:59:31 <Jesin> btw, I have a meta-proposal to make
20:59:51 <Jesin> I think http://www.haskell.org/haskellwiki/Functor_hierarchy_proposal looks like a less complete version of http://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal
21:00:01 <Jesin> so I propose the former be turned into a redirect to the latter
21:00:18 <Jesin> I don't have a wiki account though and I don't know how to go about doing that  :p
21:00:41 <shachaf> Jesin: About making an account?
21:00:57 <shachaf> Jesin: It says "create account" at the top of the page.
21:01:00 <Jesin> it is apparently a new year as of 32 seconds ago
21:01:14 <Jesin> brb
21:01:21 <krainboltgreene_> Heyo, #haskell. HNY.
21:03:34 <Jesin> I'm back now
21:04:07 <j-invariant> "what's it like in the future?"
21:04:41 <monochrom> it's like unpredictable in the future
21:04:50 <monochrom> hahaha I see now
21:05:14 <Adamant> monochrom: "predictions are difficult, especially about the future" - Yogi Berra
21:05:25 <j-invariant> I don't know why we give all the credit to Dec 31. Every day contributes towards one year
21:05:39 <Adamant> to the victor goes the spoils
21:05:48 <monochrom> no. we give all the credit to Jan 1.
21:05:58 <qfr> j-invariant I do no such thing
21:06:16 <Jesin> no, monochrom, the credit is obviously in the Dedekind cut
21:06:19 <Jesin> :P
21:06:20 <qfr> When the Christian calendar display on my screen started displaying I was on 2011 arguing about Arabic phonology
21:06:20 <monochrom> and every day contributes towards one lost year
21:06:28 <qfr> fail
21:06:37 <qfr> When the Christian calendar display on my screen started displaying 2011 I was on IRC* arguing about Arabic phonology
21:06:57 <tg_> the Arabic numberals on your Christian calendar saved you from any contridictions, though
21:06:58 <Adamant> I thought the Arabs used the same scheme with different year dates
21:07:14 <monochrom> I agree with the dedekind cut
21:07:14 <Adamant> at this point, anyway
21:07:29 <qfr> Adamant: Most of them do, but there's an Islamic calendar, too
21:08:01 <Jesin> I made an account
21:08:20 <Adamant> qfr: ah. I know they date according to a different year, I just thought they dumped their old calendar for Gregorian otherwise like we did
21:08:23 <Jesin> but I feel it would be impolite to replace a page with a redirect as my first action
21:08:47 <Jesin> should I go ahead and do it anyway, or should I put it in the discussion page and wait for somebody to pick it up or what?
21:08:48 <Jafet> Wikis are functional data structures (most of the time)
21:09:22 <Adamant> Jafet: not in the presence of rampant deletion
21:09:38 <Adamant> which you kinda accounted for, to be fair
21:09:40 <Jafet> It avoids space leaks
21:09:50 <Jesin> it would be stored in the history...
21:09:58 <Jesin> =/
21:10:30 <Jesin> why doesn't somebody else who's been here longer do it so I don't have to  :p
21:10:45 <Jesin> I just started coming to this channel a few days ago...
21:10:51 <Jesin> err
21:10:53 <qfr> Btw does anybody have any interest in the LaTeX source code of Learn You A Haskell?
21:11:06 <Jesin> more than a week by now I guess, but still not long
21:11:21 <qfr> Going to do some markup scrapery so I can read it on my crappy ebook reader with less drama
21:11:40 <qfr> The official PDF's font size is too small and the zoom features on this PRS-300 are a joke
21:11:55 <Random75> qfr: I would like it
21:12:14 <qfr> Ok, it'll probably take me a while to finish though
21:12:35 <Random75> qfr: Are you rewriting it?
21:12:55 <qfr> No, I'll just generate LaTeX from the HTML
21:13:10 <qfr> Or is the source already available and I just didn't see it?
21:13:22 <Random75> qfr: no idea.
21:14:02 <Random75> :t ==
21:14:03 <lambdabot> parse error on input `=='
21:14:12 <qfr> :t (==)
21:14:13 <lambdabot> forall a. (Eq a) => a -> a -> Bool
21:14:24 <qfr> I'm already a Haskell specialist, as you can see :(
21:14:39 <qfr> Just kidding, I'm still busy finishing some bigger project in Ruby
21:14:46 <qfr> Before I can dedicate more time to Haskell
21:15:06 <Random75> im finding haskell really hard for me to learn 
21:15:24 <qfr> Pretty much everybody sane does
21:15:41 <Jesin> what is a "sane"?
21:15:46 <Jesin> I don't think I've ever seen one...
21:15:50 <qfr> I doubt it will ever have great practical value for me honestly, I'm just doing it for educational purposes, to expand my horizons
21:15:52 <Jesin> :p
21:16:11 <Jafet> Most programmers are insane
21:16:19 <Jafet> @quote 1970s
21:16:19 <lambdabot> ray says: when you're dealing with programmers you are often dealing with people who voluntarily use 1970s terminals. they cannot be reasoned with
21:16:29 <Jesin> you're sure it's not just most *people*?
21:16:39 <roconnor> the trick to programing in Haskell is to make your code so obviously correct that even the computer can see it's correct.
21:17:09 <Jesin> roconnor: eh, maybe.
21:17:21 <Jesin> It's not necessarily "the trick"
21:17:35 <Jesin> and I don't feel like that would be very helpful advice...
21:17:54 <j-invariant> you want a silver bullet
21:18:05 <Jesin> no, I don't
21:18:08 <Jesin> I'm just saying that's not one
21:18:11 <Jesin> :p
21:18:28 <Jesin> but, let's see if I remember correctly, was it Random75 who had difficulty with the distinction between xs and [xs]?
21:18:32 <Jafet> Silver bullets are for making holes in your foot.
21:18:32 <roconnor> sometimes I think it would be helpful to learn something like Agda first.
21:18:38 <Random75> I have foo :: [x] -> Bool; foo x = x == bar x. It says cannot deduce Eq x from context ().
21:18:53 <j-invariant> [x] is weird
21:18:58 <j-invariant> it's actually List x
21:19:02 <j-invariant> but they use weird syntax to confuse people
21:19:21 <Jesin> also
21:19:32 <Jesin> I recommend against using [x] as the type variable
21:19:43 <Jafet> Dude, List x would kill golfing
21:19:46 <Jafet> We can't have that
21:19:53 <Random75> Jesin: I understand what they mean I just don't know to think like that when actually writing out. I am comfotable with basic set theory
21:19:57 <shachaf> Jafet: You rarely write out the types for that.
21:19:57 <Jesin> you'd probably be better off if you called it foo :: [a] -> Bool; foo x = x == bar x
21:20:05 <roconnor> Random75: you need foo :: (Eq x) => [x] -> Bool 
21:20:16 <Jesin> oh
21:20:19 <Jesin> thaat
21:20:20 <Jesin> yes
21:20:34 <roconnor> Random75: because your function won't work on say, lists of functions
21:20:36 <Jesin> (Eq a) => [a] -> Bool
21:20:38 <Jesin> that
21:20:48 <Random75> @ (=>)
21:20:55 <Jesin> umm
21:20:55 <roconnor> Random75: or other such types that don't have an equality comparision function.
21:20:56 <Random75> :t (=>)
21:20:57 <lambdabot> parse error on input `=>'
21:21:05 <Jesin> Random75: it's the constraint syntax
21:21:11 <Jafet> let (==) = id in
21:21:18 <Jesin> (Eq a) => [a] -> Bool
21:21:19 <bsmntbombdood> too bad we can't define equality over functions!
21:21:26 <roconnor> Random75: => is a deliminator between a list of constraints and the type.
21:21:47 <Random75> Found it LYAH. Thanks
21:21:53 <Jesin> means it's a function that takes [a] and gives Bool, such that a is an instance of Eq
21:22:07 <Jesin> and doesn't work when a is not an instance of Eq
21:22:09 <Jesin> :p
21:22:16 <Jafet> bsmntbombdood: sure you can. You can even compute it for total functions over finite domains!
21:22:42 <roconnor> Jafet: total functions over compact domains
21:22:51 <Jesin> wait
21:22:55 <Jesin> over compact domains?
21:22:56 <roconnor> bsmntbombdood: for some functions you can define Eq.
21:22:57 <Jesin> no...
21:23:12 <j-invariant> what's an example of an infinite compact domain?
21:23:18 <roconnor> Jesin: have you read seamingly impossible functions?
21:23:24 <bsmntbombdood> that was a joke ^_^
21:23:26 <Jesin> the Dirichlet function restricted to [0, 1]
21:23:44 <roconnor> j-invariant: Streams of bools
21:23:54 <bsmntbombdood> you can in the simply-typed lambda calculus 
21:24:12 <j-invariant> give f,g :: [Bool] -> [Bool] you can decide f == g?
21:24:15 <Jesin> roconnor: no I haven't
21:24:21 <j-invariant> assuming they are total
21:24:31 <roconnor> j-invariant: yes
21:24:39 <Random75> When you guys talk about compact domains, are you using the every open cover has a finite subcover?
21:24:48 <j-invariant> how O_O
21:24:55 <roconnor> er
21:25:03 <roconnor> j-invariant: sorry no
21:25:45 <roconnor> wait
21:26:12 <Jafet> A differentiable function over CReal is probably compact
21:26:15 <Jesin> roconnor: why is it total functions over compact domains?
21:26:23 <roconnor> j-invariant: if f and g return only finite lists then yes
21:26:33 <roconnor> j-invariant: if f or g can return infinite lists then no
21:26:52 <j-invariant> oh so it's like  f,g :: Stream Bool -> List Bool,  Stream always infinite and List always finite?
21:26:53 <Jesin> rconnor: actually
21:26:56 <Jesin> I think you mean
21:27:07 <Jesin> if f *or* g returns only finite lists then yes
21:27:20 <Jesin> if f and g can both return infinite lists then not necessarily
21:27:20 <roconnor> Jesin: loosely speaking, it is because a function over a compact domain can only consume a finite amount of it's input if it is to produce a finite output.
21:27:48 <j-invariant> even if it can only use finite amount... we don't know how much so how is it done
21:27:57 <Jesin> it doesn't have to be *bounded* output
21:28:04 <Jesin> and roconnor, what about the dirichlet function?
21:28:10 <roconnor> Jesin: I think I mean if f *and* g returns only finite lists.  Because I can't run f and g on every input, I need more help.
21:28:18 <Jesin> or those weird nonmeasurable things you get with the axiom of choice?
21:28:32 <roconnor> Jesin: what is the dirichlet function?
21:28:59 <Random75> j-invariant: an infinite compact co-domain could be the reals using the co-finite topology, correct?
21:29:00 <Jesin> indicator function of the rationals, sorry
21:29:03 <roconnor> Jesin: I think unbounded output is fine, so long as the codomain is decidable.
21:29:11 <Random75> compact domain*
21:29:16 <j-invariant> Random75: I don't know
21:29:37 <roconnor> Random75: in this case the topology is always the Scott topology.
21:30:00 <Jesin> roconnor, you didn't specify decidable codomain before  :p
21:30:10 <Jesin> you just specified compact domain
21:30:54 <roconnor> Jesin: ya, because Jafet didn't mention the decidable codomain either.  I figured everyone just knew that.
21:31:07 <Jesin> k
21:31:09 <Jesin> :p
21:31:15 <roconnor> :)
21:31:22 <Jesin> hmm
21:31:33 <Jafet> Beware the turing tarpit in which everything is possible but nothing of interest is obvious.
21:31:36 <Jesin> I dunno, how do you compute that, though
21:32:04 <Jesin> equality of two functions given a compact but infinite domain and decidable codomain
21:32:05 <roconnor> Jesin: it is so tricky that I don't even understand it.
21:32:19 <Jesin> ...oook then
21:32:22 <Jesin> moving on
21:32:23 <roconnor> Jesin: but you can read the blog post if you'd like
21:32:24 <Jesin> I suppose
21:32:26 <Jesin> :p
21:32:40 <roconnor> actually everyone should read the blog post
21:32:45 <j-invariant> Domain --> Codomain?
21:33:01 <roconnor> j-invariant: yes
21:33:14 <elliott> 05:31 roconnor: Jesin: it is so tricky that I don't even understand it.
21:33:14 <j-invariant> so what would som examples be?
21:33:21 <elliott> <roconnor> it is so tricky that even I don't understand it.
21:33:22 <elliott> FTFY
21:33:51 <Jesin> ftfy?
21:34:00 <Random75> fixed that for you
21:34:04 <Jesin> ah
21:34:37 <roconnor> j-invariant: examples of what?
21:34:55 <j-invariant> functions for which this equality test thing works
21:35:35 <roconnor> On of the simplest is (Nat -> Bool) -> Bool.
21:35:41 <Jesin> oops
21:35:49 <Jesin> accidentally /quit
21:35:56 <Jesin> ...I have to go in 5 minutes anyway  :p
21:36:00 <j-invariant> ah that's Rices theorem
21:36:04 <Jesin> hm?
21:36:12 <roconnor> er not
21:36:15 <roconnor> no
21:36:18 <Jesin> what are we talking about?
21:36:20 <Jesin> :p
21:36:23 <Jafet> You could also have an equality operator that tests the functions on the most sophisticated computer in the world, and returns a random answer if it failed
21:36:30 <Jafet> No one could tell otherwise
21:36:42 <roconnor> it is the type " (Nat -> Bool) -> Bool" that is decidable.
21:36:52 <j-invariant> any total predicate on turing machines is trivial
21:37:04 <j-invariant> so (Nat -> Bool) is const True or const False
21:37:16 <roconnor> in this case (==) :: ((Nat -> Bool) -> Bool) -> ((Nat -> Bool) -> Bool) -> Bool
21:37:49 <roconnor> @type: \f -> f 3 && f4 || f 7
21:37:50 <lambdabot> Not in scope: `f4'
21:37:52 <roconnor> @type: \f -> f 3 && f 4 || f 7
21:37:53 <lambdabot> forall t. (Num t) => (t -> Bool) -> Bool
21:38:08 <Jafet> j-invariant: your quantifier is wrong
21:38:21 <j-invariant> so how do you check equality of
21:38:42 <j-invariant> (\f -> f 899999) == (\g -> g 900000)
21:38:44 <Jesin> what's a Nat?
21:38:58 <Random75> roconnor: what does the symbol that looks like superset but is squar instead of rounded?
21:39:07 <Random75> mean
21:39:24 <Random75> âŠ’
21:39:28 <j-invariant> above
21:40:26 <roconnor> Jesin: lets say data Nat = Zero | Succ Nat, but using Integer instead of Nat would work as well
21:40:43 <roconnor> Random75: where did you see this symbol used?
21:40:52 <Jesin> oh, natural numbers
21:40:53 <Jesin> got it
21:41:00 <roconnor> Random75: it probably means "more defined"
21:41:21 <Jesin> the type [()] is isomorphic to that too  :p
21:41:34 <Random75> roconnor: I have never seen the scott topology before and I am looking it up. it is upper: if VâŠ’ UâˆˆU then VâˆˆU; and 
21:41:39 <Jesin> ...
21:41:41 <Jesin> hmm.
21:41:55 <roconnor> j-invariant: like I said, I don't understand exactly how the decision procedure works, but you can read it at http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/
21:43:51 <Random75> roconnor: reading this makes me sad my real analysis class didn't cover semicontinuous functions
21:43:58 <roconnor> Random75: it is the symbol that is commonly used in abstract partial orderings
21:44:30 <roconnor> Random75: you aren't missing much. Scott topologies are typically not T2, and I don't think they are even T1 typically.
21:44:35 <Jesin> exhaustive search over a cantor space, what
21:44:41 <Jesin> that's not even countable, I thought...
21:45:20 <roconnor> no, but it is compact
21:45:28 <roconnor> which is more important than being countable.
21:47:45 <j-invariant> > equal :: Eq y => (Cantor -> y) -> (Cantor -> y) -> Bool
21:47:45 <j-invariant> > equal f g = forevery(\a -> f a == g a)
21:47:46 <lambdabot>   Not in scope: type constructor or class `Cantor'Not in scope: type construc...
21:47:46 <lambdabot>   <no location info>: parse error on input `='
21:47:47 <j-invariant> what the hell!
21:47:50 <bsmntbombdood> haskell syntax is too hard ^_^
21:48:11 <bsmntbombdood> needs more sexps
21:48:25 <elliott> u be trollin
21:48:39 <bsmntbombdood> not
21:49:14 <Jesin> > type Natural = Integer
21:49:15 <lambdabot>   <no location info>: parse error on input `type'
21:49:16 <Jesin> > type Cantor = Natural -> Bit
21:49:17 <lambdabot>   <no location info>: parse error on input `type'
21:49:19 <Jafet> > ((*) 1 ((+) 2 3))
21:49:20 <lambdabot>   5
21:49:25 <cads> what are you trying to do there, j-invariant?
21:50:48 <j-invariant> it's from http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/
21:51:23 <roconnor> > let { find p = if forsome (p . (False:)) then False : find (p . (False:)) else True : find (p . (True:)); forsome p = p (find p); eq p q = not (forsome (\a -> p a /= q a)) } in eq (\f -> f!!1) (\f -> f!!2)
21:51:25 <lambdabot>   False
21:51:28 <roconnor> > let { find p = if forsome (p . (False:)) then False : find (p . (False:)) else True : find (p . (True:)); forsome p = p (find p); eq p q = not (forsome (\a -> p a /= q a)) } in eq (\f -> f!!1) (\f -> f!!1)
21:51:29 <cads> @type forevery
21:51:30 <lambdabot> Not in scope: `forevery'
21:51:30 <lambdabot>   True
21:51:41 <roconnor> > let { find p = if forsome (p . (False:)) then False : find (p . (False:)) else True : find (p . (True:)); forsome p = p (find p); eq p q = not (forsome (\a -> p a /= q a)) } in eq (\f -> f!!1 || not (f!!1)) (\f -> f!!1)
21:51:43 <lambdabot>   False
21:51:48 <roconnor> > let { find p = if forsome (p . (False:)) then False : find (p . (False:)) else True : find (p . (True:)); forsome p = p (find p); eq p q = not (forsome (\a -> p a /= q a)) } in eq (\f -> f!!1 || not (f!!1)) (\f -> True)
21:51:49 <lambdabot>   True
21:52:20 <roconnor> @define eq = let { find p = if forsome (p . (False:)) then False : find (p . (False:)) else True : find (p . (True:)); forsome p = p (find p); eq p q = not (forsome (\a -> p a /= q a)) } in eq
21:52:41 <roconnor> > eq (\f -> f!!1) (\f -> f!!2)
21:52:42 <lambdabot>   Not in scope: `eq'
21:52:52 <roconnor> @let eq = let { find p = if forsome (p . (False:)) then False : find (p . (False:)) else True : find (p . (True:)); forsome p = p (find p); eq p q = not (forsome (\a -> p a /= q a)) } in eq
21:52:54 <lambdabot>  Defined.
21:52:56 <roconnor> > eq (\f -> f!!1) (\f -> f!!2)
21:52:57 <lambdabot>   False
21:53:20 <roconnor> j-invariant: there you go
21:53:40 <cads> j-invariant, oh, I read about that exhaustive search a while back, but never understood it
21:54:06 <j-invariant> > eq (\f -> f!!2000) (\f -> f!!2000)
21:54:10 <lambdabot>   mueval-core: Time limit exceeded
21:54:14 <roconnor> as you can see the code isn't very big
21:54:19 <cads> there was some trick from the topology of the cantor space, as I remember it, that I wasn't able to understand
21:54:26 <roconnor> but this is one of the least efficent implementations
21:54:40 <elliott> what how is that even possible
21:54:43 <elliott> my blinds are mown
21:55:13 <j-invariant> I see it but I don't beleive it!
21:56:26 <roconnor> elliott: it's possible because every computable function is continuous in the Scott topology, and every continuous function on a compact domain is uniformly continuous, and hence for any given function on a compact domain there is only a finite amount of data you need to test to know it's entire behaviour.
21:56:58 <elliott> roconnor: WELL DUH :)
21:57:03 <j-invariant> it's finite but that doesn't mean you can compute the finite number
21:57:07 <elliott> "Thanks roconnor, it makes perfect sense now!"
21:57:11 <roconnor> elliott: I didn't say it was obvious. :D
21:57:35 <BMeph> No, you just said his MOM was... ;Ã¾
21:58:02 <j-invariant> roconnor: like proving two cubic polynomials are equal: You onyl have to check three cases
21:58:03 <cads> roconnor, can we paint an analogy with continuous functions on invervals of R, and calculus?
21:58:15 <j-invariant> roconnor: but if you are given two polynomials you never know how many points you need to check
21:58:21 <elliott> analogies, I love analogies -- they're the best way to confuse people!
21:58:31 <j-invariant> four points*
21:58:33 <roconnor> cads: it is best to think of continous functions to a discrete set
21:58:45 <roconnor> cads: which you will notice is piecewise constant.
21:58:55 <roconnor> more specifically 
21:59:07 <roconnor> constant on each connected part of the domain
21:59:42 <Random75> roconnor: f: [0,1]-->[1,1] would be a simple example right?
22:00:02 <j-invariant> what the hell!!
22:00:10 <cads> heh
22:00:10 <roconnor> Random75: the codomain there isn't discrete, so it isn't a good example.
22:00:13 <elliott> http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/comment-page-1/#comment-5868
22:00:14 <elliott> wow!
22:00:27 <elliott> I love it when a program gets smaller, more elegant, and much more efficient :)
22:03:07 <ddarius> roconnor: A singleton set isn't discrete?
22:03:22 <roconnor> Random75: f: [0,1] --> Bool would be a better example, though that one is too trivial.  Why?
22:03:41 <roconnor> ddarius: oh I didn't notice that
22:03:45 <roconnor> Random75: sorry
22:04:14 <roconnor> f : [0,1] -> {1} is indeed fine, but even more trivial than [0,1] -> Bool
22:05:10 <Random75> roconnor: well its an example for cads... going to Bool would be a continuous function for basic calculus
22:05:18 <Random75> wouldnt*
22:05:53 <j-invariant> Cantor -> Bool
22:05:59 <j-invariant> if we change it to
22:06:08 <j-invariant> Cantor\{const 1} -> Bool
22:06:23 <j-invariant> then I think you cannot compare equality anymore, even though the functions are still total
22:06:27 <roconnor> then we'd be screwed
22:06:41 <roconnor> the domain is no longer compact
22:06:48 <j-invariant> because you can have the time tend to infinity as Cantor tends toward 111111111111111... 
22:07:10 <Random75> what is const 1?
22:07:23 <Random75> err \{const 1}
22:07:37 <roconnor> \ is set minus
22:07:43 <j-invariant> Random75: I mean the domain does not allow const 1 to be passed in
22:08:07 <roconnor> {const 1} is the set of functions that return 1 or an infinite list of Trues depending on your representating of the cantor set
22:08:23 <cads> so can our function f have a really wierd domain like some uncountable set of unconnected points?
22:08:40 <roconnor> cads: the cantor set is an uncoutnable set of unconnected points
22:08:52 <cads> oh, nice
22:09:27 <j-invariant> is this something to do with
22:10:00 <Random75> j-invariant: all of this has to do with compactness.
22:10:24 <Random75> its the 1000 pound gorilla as my professor would say
22:10:24 <roconnor> remember compact means "finitely approximatable" and computers like finite things
22:10:40 <j-invariant> what is the definition of compact in this context?
22:10:48 <j-invariant> actually never mind that
22:10:56 <j-invariant> I will read these nots
22:11:01 <Random75> A set is compact if every open cover of a set has a finite cubcover.
22:11:10 <Random75> subcover*
22:11:15 <j-invariant> are there any other examples of this?
22:11:21 <Random75> of what?
22:11:36 <j-invariant> infinite compact domains
22:11:37 <roconnor> j-invariant: actually this only work for sets that are "computably compact"
22:11:40 <cads> roconnor, actually, at every finite level of its construction the cantor set is a uncountable set of connected points.. I don't know what this means for the fully constructed set
22:11:47 <j-invariant> in haskell
22:11:48 <roconnor> and I'm not sure what the definiton of computably compact is :(
22:12:07 <roconnor> but apparently most compact sets we are familiar with are computably compact
22:12:09 <Random75> j-invariant: What you are used to, compact = closed and bounded
22:12:13 <j-invariant> cads: define it as real numbers without 1 digits in trinary
22:12:24 <j-invariant> cads: that's obvious in bijection with binary real numbers
22:12:39 <j-invariant> the fractal definition is useful for measuing its dimension
22:13:09 <j-invariant> Random75: bounded?
22:13:12 <ddarius> People interested in this stuff should definitely look at Martin Escardo's synthetic topology.
22:13:34 <Random75> j-invariant: Yes... there is a maximum and a minimum over the set
22:13:40 <cads> so, then the points of type two are the irrational trinary numbers lacking 1s?
22:13:50 * ddarius is used to "every open cover has a finite subcover."
22:14:28 * roconnor is used to "complete and totally bounded"
22:14:53 <j-invariant> every0 sequence has a convergent subsequence?
22:15:03 <ddarius> I like the synthetic topology view though.
22:15:04 <Random75> j-invariant: only in hausdorff spaces
22:15:24 <Random75> actually it might be complete.. I don't quite remember
22:15:36 <Random75> roconnor?
22:15:44 <roconnor> ?
22:16:12 <cads> j-invariant, what does this say about functions f : Cantor-Set -> {0,1}?
22:16:19 <Random75> compact <=> sequentially compact in haurdorff or metric?
22:16:43 <Random75> hausdorff*
22:17:52 <roconnor> Random75: in metric, or more generally in any first-countable uniform space
22:17:53 * ddarius thinks the upward dimple on the bottom of many bottles is for agitation purposes.
22:17:57 <roconnor> according to wikipedia
22:18:58 <Random75> i love math 3>
22:19:58 <dankna> is 3> the inverse of the <3 operator?
22:20:19 <cads> j-invariant,  so, it seems like there are irrational numbers in the cantor set, and they are not connected to any other numbers by any net of sequences in the cantor set.
22:20:58 <djahandarie> @check \x -> (x<3) == (3>x)
22:20:59 <lambdabot>   "OK, passed 500 tests."
22:21:07 <dankna> haha awesome
22:21:14 <j-invariant> what is a net of sequences?
22:21:18 <roconnor> Random75: this is what separates Haskell programmers from other programmers.  Other programmers think you need the domain of a function to be finite to compare functions for equality, but we Haskellers know better.
22:21:39 <Random75> roconnor: I am no Haskeller haha
22:21:58 <bsmntbombdood> haha
22:22:02 <bsmntbombdood> lambdabot is awesome
22:22:05 <roconnor> j-invariant: an epsilon-net?
22:22:43 <elliott> psht, @check
22:22:47 <elliott> you can implement that as
22:22:56 <elliott> equal (\x -> foo) (\_ -> True)
22:22:58 <elliott> *trollface*
22:23:30 <djahandarie> Did /prog decide to come hang out in here or something?
22:23:30 <Random75> cads: the canto sets contains all the irrational between 0 and 1
22:24:05 <dankna> also all the rationals
22:24:15 <roconnor> Random75: that isn't the common definition.
22:24:31 <roconnor> Random75: though it is a homeomorphic definition
22:25:04 <Random75> roconnor: im not defining it. He just said there are irrationals in the set
22:25:23 <Random75> but it contains all of them between 0 and 1
22:25:40 <roconnor> the usual definition of the cantor set does not.
22:26:11 <Random75> how doesn't it?
22:26:18 <j-invariant> it would be interesting to see which real numbers are used in the checking of whethre f = g
22:26:44 <roconnor> the usual cantor set contain no number in the interval (1/3, 2/3).
22:27:13 <Random75> oh duh. yeah.
22:27:15 <roconnor> j-invariant: only parial real numbers are ever used.
22:28:24 <roconnor> > (\f -> f!!3 && f!!4) (False:False:False:True:True:undefined)
22:28:25 <lambdabot>   True
22:28:49 <roconnor> This is a key propery that allows this comparison to be computable.
22:29:06 <cads> j-invariant, when I said about a net existing between the points x and y, I meant that for every e > 0 we can choose a chain of points x, p1, p2, ... pn, y, such that for any two sequential points their distance is less than e.
22:29:17 <j-invariant> does the value 'undefined' depend on the output of (\f -> f!!3 && f!!4) (False:False:False:True:True:undefined)?
22:29:18 <roconnor> by this one test I've tested every extension of False:False:False:True:True:
22:29:31 <roconnor> which is an uncountable number of inputs!
22:29:37 <roconnor> (though compact)
22:29:40 <j-invariant> that's cool
22:29:48 <Random75> roconnor: can you explain that line of code in words?
22:30:02 <roconnor> Random75: I can rewrite it to make it more clear maybe
22:30:11 <roconnor> > (\f -> f!!3 && f!!4) [False:False:False:True:True
22:30:12 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
22:30:13 <roconnor> ooops
22:30:17 <roconnor> > (\f -> f!!3 && f!!4) [False:False:False:True:True]++undefined
22:30:17 <lambdabot>   Couldn't match expected type `[GHC.Bool.Bool]'
22:30:18 <lambdabot>         against inferred typ...
22:30:18 <j-invariant> cads: ah yes there is never an epsilon net between any two points
22:30:23 <roconnor> > (\f -> f!!3 && f!!4) ([False:False:False:True:True]++undefined)
22:30:24 <lambdabot>   Couldn't match expected type `[GHC.Bool.Bool]'
22:30:24 <lambdabot>         against inferred typ...
22:30:31 <roconnor> oops
22:30:38 <roconnor> > (\f -> f!!3 && f!!4) ([False,False,False,True,True]++undefined)
22:30:38 <Random75> roconnor: I don't follow haskell
22:30:40 <lambdabot>   True
22:30:46 <roconnor> Random75: are you familiar with undefined?
22:30:58 <Random75> probably not
22:31:02 <j-invariant> cads: to see that use the fractal construction, if our poinst are a----b then at some point chunks in the middle will be cut away
22:31:17 <cads> exactly why I said that :)
22:31:27 <j-invariant> said what?
22:31:59 <cads> any epsilon net would rely on points that would be removed at some finite step in the construction of the cantor set.
22:32:30 <roconnor> Random75: undefined is a value that throws an exception when it is evaluated
22:32:33 <roconnor> > undefined
22:32:33 <augur> my dear haskelliers!
22:32:34 <lambdabot>   *Exception: Prelude.undefined
22:33:00 <roconnor> Random75: however, because Haskell is a lazy language, parameters to functions are not always evaluted by the function
22:33:10 <roconnor> > (\x -> 3) undefined
22:33:10 <lambdabot>   3
22:33:23 <cads> j-invariant,  hehe, btw I think my definition of epsilon net is of something related but not quite an e-net
22:33:30 <Random75> ok
22:33:34 <roconnor> this expression evaluates to 3, even though it's parameter (undefined) will fail if it is evaluted.
22:33:50 <roconnor> this is because (\x -> 3) doesn't use it's argument, so undefine never gets evaluated
22:33:55 <j-invariant> but ther is no way to check if something is undefined
22:33:57 <roconnor> if it does use it's argument, then it iwll fail
22:34:01 <j-invariant> so the code can't use it
22:34:01 <roconnor> > (\x -> x+1) undefined
22:34:02 <lambdabot>   *Exception: Prelude.undefined
22:34:26 <roconnor> going back to "(\x -> 3) undefined"
22:34:26 <j-invariant> Does the program have something to do with diagonalization?
22:34:43 <Random75> like in java: (5==5) || 1/0 is valid 
22:34:54 <roconnor> > (\x -> 3) undefined
22:34:55 <lambdabot>   3
22:34:58 <roconnor> this result is 3
22:35:05 <roconnor> because it doesn't use it's argument
22:35:14 <augur> how praytell would you implement a coordinate type that has both 2d and 3d coordinates so that a) 3d coordinates are a kind of 2d coordinate, b) addition of coordinates is generic, except for the special case of 3d+3d?
22:35:34 <roconnor> but, from this we can concude that if we change the argument to a "more defined" value, the result must remain 3
22:35:38 <roconnor> > (\x -> 3) 7
22:35:39 <lambdabot>   3
22:35:40 <roconnor> > (\x -> 3) 10
22:35:41 <lambdabot>   3
22:35:44 <roconnor> > (\x -> 3) 26
22:35:44 <lambdabot>   3
22:36:18 <cads> augur, is that possible?
22:36:19 <roconnor> same thing works for the function head
22:36:27 <augur> cads: i dont know! thats part of the question
22:36:31 <roconnor> > head (7:undefined)
22:36:32 <lambdabot>   7
22:36:46 <bsmntbombdood> augur: 'Ass' typeclass?
22:36:48 <bsmntbombdood> err, Add
22:36:51 <Random75> roconnor: i get it.. haskells lazy as fuck
22:36:52 <roconnor> > head ([7]++undefined)
22:36:54 <lambdabot>   7
22:37:00 <cads> you could factor the third coordinate into the two numbers representing regular 2d coordinates
22:37:11 <roconnor> again the result is 7 on this input, it must be 7 on any more defined input
22:37:14 <roconnor> > head ([7]++[])
22:37:15 <lambdabot>   7
22:37:18 <roconnor> > head ([7]++[25])
22:37:20 <lambdabot>   7
22:37:22 <augur> bsmntbombdood: but would that let there be a single definition for addCoord that works for all coordinates, and then sub-definitions that work for more specific cases?
22:37:27 <roconnor> > head ([7]++[25,4535,333,23434])
22:37:29 <lambdabot>   7
22:37:29 <bsmntbombdood> augur: yes
22:37:33 <roconnor> > head ([7]++[0..])
22:37:35 <augur> bsmntbombdood: example?
22:37:35 <lambdabot>   7
22:37:50 <cads> augur, i.e., 3d numbers (x,y,z) could be written as (x, 2^y * 3^z).
22:37:52 <roconnor> so when we test
22:38:04 <roconnor> > (\f -> f!!3 && f!!4) ([False,False,False,True,True]++undefined)
22:38:05 <lambdabot>   True
22:38:15 <roconnor> we know the result must be true for any more defined input
22:38:21 <augur> cads: thats a cheat and is beside the point and doesnt work if coordinates are in R^3 :P
22:38:24 <roconnor> > (\f -> f!!3 && f!!4) ([False,False,False,True,True]++[True,False,True])
22:38:25 <lambdabot>   True
22:38:31 <roconnor> > (\f -> f!!3 && f!!4) ([False,False,False,True,True]++[False,True,False])
22:38:33 <lambdabot>   True
22:38:41 <roconnor> > (\f -> f!!3 && f!!4) ([False,False,False,True,True]++repeat False)
22:38:42 <lambdabot>   True
22:38:48 <j-invariant> but roconnor if it's not the program will crash
22:38:48 <cads> augur,  but this makes adding a 2d number to a 3d number create something many no longer be interpreted as a 3d number
22:38:53 <cads> may no longer be*
22:39:21 <bsmntbombdood> augur: class Add a where addPoint :: a -> a -> a; instance Add Point2D ...;  instance Add Point3D...
22:39:40 <augur> bsmntbombdood: yeah but the point is to have a single definition for points-in-general
22:39:54 <augur> like suppose this:
22:39:55 <roconnor> j-invariant: indeed the program doing the test doesn't use undefined, but it does use "short-circut" evaluation that allows it to return a result before recursing.
22:40:13 <j-invariant> so is it like
22:40:21 <alej> augur what do you want the behavior of (x,y) + (x', y', z) to be
22:40:28 <j-invariant> let result = f (True : use result)
22:40:41 <augur> alej: well, both would be instances of Point2
22:40:58 <bsmntbombdood> j-invariant: it is impossible to test for undefined, it's really just a more user-friendly version of nontermination
22:41:07 <augur> and youd have add for point2 be    add a b = Point2 (a.x + b.x) (a.y + b.y)
22:41:14 <roconnor> recall the definition: let { find p = if forsome (p . (False:)) then False : find (p . (False:)) else True : find (p . (True:)); forsome p = p (find p); eq p q = not (forsome (\a -> p a /= q a)) } in eq
22:41:32 <roconnor> the interesting bits are the mutual definition of find and forsome
22:41:32 <Random75> > (True || (/ 1 0) || undefined)
22:41:33 <lambdabot>   The section `GHC.Real./ 1 0' takes one argument,
22:41:33 <lambdabot>  but its type `GHC.Bool.Bo...
22:41:38 <augur> so add (Point2 x y) (Point3 x' y' z') = Point2 (x + x') (y + y')
22:41:52 <Random75> > (True || (1 / 0) || undefined)
22:41:53 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Bool.Bool)
22:41:53 <lambdabot>    arising from a use o...
22:41:57 <bsmntbombdood> augur: i don't think that's typeable
22:42:00 <augur> ok
22:42:07 <alej> ok i see what you want i think. this gets tricky if you think about n-d rather than just 2-d or 3-d
22:42:08 <Random75> > (True || (1 `/` 0) || undefined)
22:42:09 <lambdabot>   <no location info>: parse error on input `/'
22:42:18 <alej> since you could obviously make a data type Point = Point2D | Point3D
22:42:18 <j-invariant> roconnor:  let b = forsome (p . (False:)) : find (p . (head b:))
22:42:20 <augur> alej: yes well, thats why im asking ;)
22:42:24 <roconnor> forsome :: ([Bool] -> Bool) -> Bool -- this function takes a predicate p :: [Bool] -> Bool and decides if p holds for some input
22:42:26 <alej> hehe
22:42:27 <Random75> > (True || (1/0) || undefined)
22:42:28 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Bool.Bool)
22:42:28 <lambdabot>    arising from a use o...
22:42:33 <bsmntbombdood> augur: unless you have makePoint2d x y = Point3D x y 0 or something i guess
22:42:41 <Random75> > (True || undefined)
22:42:42 <lambdabot>   True
22:42:44 <augur> hmm
22:42:56 <Random75> Damnit, booleans aren't treated like integers
22:42:57 <roconnor> find :: ([Bool] -> Bool) -> [Bool] -- this function takes a predicate p :: [Bool] -> Bool and finds an input for which p returns True if there are any and returns (repeat False) otherwise
22:43:09 <augur> i suppose you wouldnt need it to be type-driven at all if you did it with lists
22:43:12 <augur> so points are a bad example
22:43:26 <roconnor> j-invariant: so look at the definition of forsome
22:43:38 <roconnor> forsome p = p (find p)
22:44:04 <cads> augur, I once represented my vectors as lists and used operations like  add = zipWith (+). This had the advantage that things like [1, 1] + [2,3,4] had useful meanings, and I could even do say [1,2,3] + [1..]
22:44:17 <augur> yeah
22:44:25 <j-invariant> :t find p = p (find (p . (False:))) : find (p . (head b:))
22:44:26 <lambdabot> parse error on input `='
22:44:29 <roconnor> here (find p) is going to manufacture an infinite list somehow, but the point is that forsome will test that infinte list on p and p will only consume a finite portion of that list before deciding True or False.
22:44:30 <j-invariant> :t let find p = p (find (p . (False:))) : find (p . (head b:))
22:44:31 <lambdabot> <no location info>:
22:44:31 <lambdabot>     not an expression: `let find p = p (find (p . (False:))) : find (p . (head b:))'
22:45:14 <roconnor> and because p is going to only test a finite portion of the input, the amount of recursion that find needs to unfold is finite (as it turns out).
22:45:16 <j-invariant> :t let find p = (let b = p (find (p . (False:))) : find (p . (head b:)) in b) in find
22:45:17 <lambdabot> ([Bool] -> Bool) -> [Bool]
22:46:07 <roconnor> but like I said, I don't really understand this code.
22:46:34 <cads> you can even have a couple operations. you can zip like above. Then the output size is the smallest of the two vectors. Or  you can pad the smallest vector with zeros, to pretend like you're projecting it into the dimension of the higher vector
22:46:37 <j-invariant> roconnor: I don't yet see why it terminates on all inputs
22:47:06 <j-invariant> actually I see it now
22:47:53 <augur> hmm. are there any investigations into subtypes in haskell?
22:48:00 <roconnor> j-invariant: ya.  You something like the fan theorem or open-induction to prove it I'd guess.
22:48:12 <j-invariant> I don't know those
22:49:12 <j-invariant> yeah I guess this find algorithm has a high complexity
22:49:18 <j-invariant> so you need a strong theory to prove it
22:49:56 <cads> j-invariant, you understand it?
22:50:00 <roconnor> does complexity theory extend to higher-order functions?
22:51:17 <cads> I wonder what you'd be measuring
22:51:40 <cads> how the higher order function transforms the complexity of its input functions?
22:52:25 <cads> roconnor, what would we say about the complexity of map, or fold?
22:53:04 <roconnor> I guess I'd say they are linear :)
22:54:15 <cads> maybe the complexity of a folded function scales linearly with the complexity of its input function?
22:54:45 <cads> as well as scaling linearly with the size of the input list that it now takes :)
22:55:14 <cads> as well as _being_  linear in the size of its input
22:57:28 <augur> anyone?
22:57:32 <augur> subtypes in haskell?
22:57:57 * roconnor doesn't like subtypes
22:58:06 <augur> roconnor: :P
22:58:11 <augur> why not ey
22:58:47 <roconnor> they seem to cause difficulties.  I guess I need to study them more to understand why.
22:59:38 <roconnor> I guess I dislike record subtyping more than say Integer being a subtype of Rationals
23:00:17 <roconnor> if coercions are not injective, then things get screwy
23:00:58 <roconnor> unforutately record subtyping tends to be a pretty commong subtyping relation, which perhaps what is colouring my view on subtyping
23:02:52 <augur> roconnor: the paradoxical thing about subtyping numbers, at least, is that you can plausible say that Real `subtype` Int and Int `subtype` Real
23:03:01 <augur> depending on what you care about
23:03:42 <augur> if subtype is subset, then obviously Int `subtype` Real
23:03:50 <augur> but if subtype is moreInformation
23:04:13 <augur> then plausibly Real `subtype` Int, because reals are Ints with a fractional part
23:05:04 <roconnor> indeed
23:05:17 <roconnor> though the second intpretation is rare
23:05:42 <roconnor> thoug it is similar to the record subtyping that is wrong.
23:05:44 <augur> not in OO land :)
23:05:53 <augur> i mean, not for numbers
23:06:12 <augur> but subclasses are obviously build on the idea of more information or behavior
23:06:13 <roconnor> yes record/object subtyping is very common in OO
23:06:29 <roconnor> and I'm pretty sure it is wrong
23:06:35 <augur> aww, why?
23:06:56 <roconnor> { a := 7; b := 5 } == { a := 7 } right?
23:07:03 <roconnor> by record subtying?
23:07:24 <Jafet> If you can define no tea in your object formalism, it is worthless for modelling the world
23:07:52 <shachaf> Jafet: Now, if you can define tea and no tea at the same time...
23:08:03 <roconnor> augur: right?
23:08:15 <Jafet> Why not use ML's subtyping formalism?
23:08:22 <augur> roconnor: surely not!
23:08:54 <augur> but with a least upper bounds definition of (==) it would
23:08:59 <j-invariant> does A subtyping B give you identity :: A -> B?
23:09:06 <roconnor> (==) :: {a ::Int} -> {a::Int} -> Bool
23:09:18 <augur> perhaps that means you would have a lub flag somehow
23:09:25 <augur> so you can say like
23:09:27 <roconnor> {a::Int; b::Int} is a subtype of {a::Int} so we can pass it to (==) right?
23:09:54 <augur> f :: (Lub a b) => a -> b -> c
23:10:01 <augur> or whatever
23:10:12 <augur> which would constraint a and b to be their type lub
23:10:27 <azaq23> Aren't OO classes mostly used like haskell typeclasses? Say, using Java Notation, to implement a common interface, hiding underlying attributes which are not relevant to the interface? If record subtyping means that subclasses actually have more public attributes which should be used, I've never seen that actually used, except in special toy problems
23:10:30 <roconnor> let's start simpler then
23:10:40 <augur> roconnor: no no i agree with you about (==)
23:10:53 <roconnor> augur: oh.  Why did you say surely not?
23:10:54 <augur> im just trying to think of a way that would make it possible to have subtyping when you want it
23:11:03 <Jafet> augur: well, glb seems equally reasonable to use
23:11:07 <augur> well surely not we dont want the equality to hole!
23:11:09 <augur> hold**
23:11:34 <Jafet> azaq23: Java isn't usually the language you go to for object oriented programming
23:11:47 <augur> Jafet: also plausible, assuming your types are atleast a meet semilattice
23:12:08 <augur> but subtyping usually entails join semilattice not a meet semilattice
23:12:29 <mrkotfw> Hello everyone
23:12:48 <mrkotfw> How can I suppress the beginning start up message for ghci?
23:13:41 <augur> roconnor: so suppose we had the possibility of a LUB constraint
23:13:46 <augur> do you think that would make it acceptable?
23:14:02 <roconnor> OTOH, in OO objects usually have identity, so {a := 7; b := 5} /= {a := 7} since the objects are not identical.  Still, I don't know if this really saves us.
23:14:03 <azaq23> Jafet: That's another matter I would say - Just said Java Notation so that it's clear what I mean by "interface", so I can say that haskell typeclasses == interfaces and classes in other OO languages are pretty much used the same way - you have one abstract baseclass and derive *one* layer of subtypes, with no change in public attributes or methods. That's the most common way I've seen OO classes used
23:14:05 <augur> so (==) would have no constraint, but maybe coord+ would?
23:14:15 <roconnor> augur: I haven't really thought about it.
23:14:32 <Jafet> azaq23: Java is OO only in syntax, not semantics
23:14:43 <Jafet> Here we are discussing the semantics
23:14:47 <dibblego> Java interfaces are more like data types, not type-classes
23:15:50 <roconnor> dibblego: what?
23:16:02 <dibblego> Java has nothing like type-classes
23:16:07 * roconnor thinks Java interfaces are roughly analogous to type-classes
23:16:11 <Jafet> Scheme has like three equality operators, I don't know how CLOS behaves
23:16:31 <augur> interfaces do seem to be like typeclasses
23:16:35 <augur> ~ mixins
23:16:45 <augur> i mean, interfaces are less mixins cause they dont include definitions
23:16:51 <dibblego> interface X { Y f(Z z); } is analogous to data X = X (Z -> Y)
23:16:54 * Xilon wonders why Universities use Java to teach OOP then
23:17:08 <augur> dibblego: surely not
23:17:11 * roconnor learend OOP with Modula-3
23:17:18 <dibblego> class X where k :: Z -> Y has nothing similar in Java
23:17:23 <augur> that yes
23:17:30 <augur> uh
23:17:36 <Jafet> Xilon: they don't. They use Java because the industry does.
23:17:48 <augur> dibblego: data X = X (Z -> Y) is an ADT
23:17:48 <j-invariant> java and haskell are totally different! You can't compare them
23:18:00 <dibblego> augur, yes
23:18:10 <augur> but interface X { Y f(Z z) } is not
23:18:24 <dibblego> when you pass a value of type X *implicitly* using Java, then you'll have something analogous to type-classes
23:18:27 <augur> thats just a constraint on the type that f can have if some class implements X
23:18:46 <dibblego> data X = X { f :: Z -> Y } -- correction
23:18:47 <mrkotfw> Haskell... seems really nice
23:18:50 <jmcarthur> roconnor: Java interfaces can't even do Num, can they?
23:19:01 <augur> dibblego: i think you're completely wrong about the analogy
23:19:07 <augur> obviously interfaces ~ typeclasses
23:19:10 * roconnor thinks  interface X { Y f(Z z); } is analogous to class X where f :: X -> Z -> Y
23:19:29 <augur> i agree with roconnor
23:19:49 <dibblego> ok, I think you're both wrong :)
23:20:06 <augur> yeah well you think that data types are abstract, so.. :P
23:20:11 * roconnor thinks dibblego is wrong about augur and I being wrong
23:20:17 <dibblego> no I don't
23:20:21 <dibblego> I already said what I think
23:20:26 <augur> yes
23:20:41 <dibblego> when you can achieve anything like type-classes with Java, please let me know
23:20:41 <augur> interface does not define something that can have instances
23:20:43 <augur> data does
23:20:51 <dibblego> yes it does
23:21:02 <augur> so i can do X x = new X(); in java?
23:21:06 <augur> having defined it as you did?
23:21:07 <dibblego> for every interface you give me, I can give you a data type and vice versa
23:21:33 <dibblego> yes, so long as you pass the function, with lots of syntax, as you would in Haskell
23:21:34 <Saizan> augur: a value of the X ADT is isomorphic to a class implementing the interface
23:21:38 <dibblego> X x = new X() { ...
23:21:39 <azaq23> My point was only that real record subtyping doesn't seem to be used that often (where subtyping is, in OO speak, subclassing with a extended public interface of methods and attributes) - I have most often seen the model <one abstract base class and one layer of subtypes> (in java one base interface, although I've never read much java), which is rougly analogous to haskell typeclasses
23:21:47 <augur> Saizan: yes but interfaces arent classes
23:21:55 <augur> which is the point
23:22:03 <dibblego> please show me anything remotely equivalent to the functionality of type-classes in Java
23:22:05 <Saizan> augur: and record types aren't values of those record types
23:22:10 <augur> you have to have a class that implements the class
23:22:19 <augur> er, implements the interface
23:22:26 <augur> not just an interface by itself
23:22:35 <roconnor> dibblego: for every type class you give me I can give you a data type.  This is even what GHC does.
23:22:36 <dibblego> interface Eq<A> { boolean eq(A a1, A a2); } is more like data Eq a = Eq { eq :: a -> a -> Bool } than it is Prelude.Eq
23:22:42 <jmcarthur> augur: how about implementing Num with Java interfaces? should be easu, right?
23:22:53 <jmcarthur> *easy
23:22:56 <Saizan> augur: record type : interface = value of that record type : class implementing that interface
23:22:58 <augur> jmcarthur: aint nothin about easy
23:23:00 <dibblego> roconnor, right, but which resembles the functionality of Java interfaces most? data types of course, you must pass them explicitly, just like Java
23:23:27 <augur> Saizan: i dont get your analogy
23:23:39 <roconnor> dibblego: you can implement multiple interfaces with one object in java, just like in haskell you can write data types that implement multiple type classes.
23:23:51 <roconnor> *with one class in java
23:23:52 <dibblego> in practice, I see all sorts of gymnastics as a result of Java having nothing like type-classes
23:24:09 <augur> dibblego: point is, you cant have just an instance of some interface, you need a class that implements it
23:24:14 <roconnor> that being said, the interfaces in java are no where near as flexible as the type classes of Haskell.
23:24:14 <cads> hey roconnor, check this out, and tell me if this seems like reasonable use of notation.. if f is a function of n bits with a run time complexity Q(n) = O(s(n)), then fold f is a function of n elements of no more than n* bits, with complexity FoldedQ(n*, m) = O(m*s(n*))
23:24:24 <dibblego> augur, so?
23:24:32 <augur> so thats what a typeclass is!
23:24:50 <cads> roconnor,  m elements of no more than n* bits, I meant :P
23:25:03 <roconnor> cads: sounds good. though I'm pretty sleepy
23:25:24 <dibblego> augur, I could say the same about the equivalent data type
23:25:44 <augur> no you couldnt, because i can INSTANTIATE a datatype without anything else, but you cant just instantiate an interface
23:25:45 <dibblego> augur, you don't get a value :: X without passing a value to the function X
23:25:51 <dibblego> no you can't
23:25:54 <augur> sure i can
23:25:57 <dibblego> data X = X (Z -> Y)
23:25:57 <augur> data X = X
23:25:58 <dibblego> go on
23:26:01 <Saizan> augur: you have to provide values for the fields
23:26:08 <augur> if there are fields, sure
23:26:09 <dibblego> interface X {}
23:26:15 <augur> instantiate it then
23:26:19 <dibblego> new X(){}
23:26:33 <augur> maybe i dont get java interfaces then
23:26:42 <dibblego> that's ok, they are like data types :)
23:26:46 <dibblego> oh, and nothing like type-classes
23:26:59 <roconnor> dibblego: Is that legal java?
23:27:02 <dibblego> yes
23:27:04 <augur> im pretty sure its not
23:27:12 <dibblego> I used to implement the Java specification
23:27:14 <dibblego> I promise you it is
23:27:31 <azaq23> dibblego: What you're doing they're is creating an anonymous subclass of an interface and instantiate it directly, special java syntax
23:27:33 <dibblego> JLS section 6 iirc
23:27:38 <azaq23> @google java anonymous subclass
23:27:39 <lambdabot> http://docstore.mik.ua/orelly/java-ent/jnut/ch03_12.htm
23:27:39 <lambdabot> Title: Anonymous Classes (Java in a Nutshell)
23:27:41 <dibblego> azaq23, it is not "special"
23:27:42 <augur> http://en.wikipedia.org/wiki/Interface_(Java)
23:27:44 <dibblego> azaq23, it is just java
23:27:45 <augur> "Interfaces cannot be instantiated."
23:27:56 <augur> so either dibblego you're wrong, or wikipedia is wrong
23:28:01 <dibblego> data type constructors cannot be mixed up with data types
23:28:09 <augur> im going to bet that wikipedia is wrong and you're just mistaken.
23:28:12 <dibblego> augur, that's not true
23:28:21 <dibblego> augur, I would like to put a wager on it before going further :)
23:28:48 <dibblego> wikipedia and I am both right
23:29:07 <alej> however new X()...
23:29:16 <augur> oh i see, you're creating an anonymous class that implements the interface right in the expression
23:29:23 <augur> yeah see thats not instantiating the interface
23:29:23 <dibblego> scala> trait X
23:29:24 <dibblego> defined trait X
23:29:24 <dibblego> scala> new X(){}
23:29:24 <dibblego> res0: java.lang.Object with X = $anon$1@3a0589
23:29:26 <dibblego> scala equivalent ^^
23:29:27 <azaq23> dibblego: Yes, but that's an anonymous subclass, which gets instantiated directly. There is actually a class instance compiled for this, and you can do stuff like class A { abstract Y f(X x); }; new A() { abstract Y f(X x) { /* body */ }}
23:29:41 <dibblego> azaq23, I'm not sure why you are telling me this
23:29:47 <augur> because it means you're wrong, dibblego
23:29:49 <augur> thats why
23:29:56 <dibblego> augur, no, it's creating an instance of X, just like the X constructor does
23:30:05 <dibblego> no it doesn't mean that
23:30:09 <augur> uh
23:30:12 <augur> yes it does
23:30:16 <augur> azaq23 just showed you why
23:30:35 <augur> and this conversation is concluded.
23:30:42 <dibblego> no, he told me something I already know, which doesn't negate the following: data types are analogous to Java interfaces. There is nothing like type-classes in Java.
23:30:58 <augur> anyway, roconnor
23:31:13 <augur> i think with a lub constraint you could have a good subtype system
23:31:28 <roconnor> I'll beleive it when I see it :)
23:31:36 <augur> well lets do it and see!
23:31:54 <dibblego> this mistake causes all sorts of problems when teaching :(
23:31:57 <roconnor> dibblego: type-classes are just dictionaries which are data types
23:32:03 <dibblego> that's the only reason I bothered to pursue it
23:32:08 <dibblego> roconnor, *precisely*
23:32:15 <dibblego> roconnor, now which resembles Java interfaces most?
23:32:18 <Saizan> augur: it's just that haskell doesn't have nullary functions, or better that nullary constructors aren't functions from ()
23:32:22 <roconnor> dibblego: type classes
23:32:27 <dibblego> roconnor, that's totally wrong
23:32:31 <augur> Saizan: what
23:32:31 <dibblego> roconnor, let's start here
23:32:45 <dibblego> class Eq a where eq :: a -> a -> Bool and data Eq a -> Eq { eq :: a -> a -> Bool }
23:33:16 <dibblego> roconnor, now suppose e.g. nub :: Eq a => [a] -> [a] and nub' :: Eq' a -> a -> a -> Bool
23:33:25 <dibblego> which is more like Java?
23:33:36 <Saizan> augur: if haskell were strict you'd see a lot more () -> .. types
23:33:38 <j-invariant> why are you comparing two completely different language
23:33:45 <augur> Saizan: ??
23:33:45 <roconnor> dibblego: the first one
23:34:07 <dibblego> roconnor, I've never seen an implicit argument in Java
23:34:14 <dibblego> roconnor, perhaps you are thinking of Scala
23:34:47 <dibblego> j-invariant, because this question comes up in teaching, it causes problems, and I wish to destroy it
23:34:57 <j-invariant> what question?
23:35:07 <dibblego> j-invariant, the mistake that augur and roconnor are making 
23:35:17 <j-invariant> the mistake is comparing haskell and java
23:35:22 <augur> lol
23:35:22 <roconnor> dibblego: do you teach this stuff?
23:35:24 <dibblego> j-invariant, beginners make the same analogy, which turns out, is not an analogy -> problems
23:35:31 <augur> roconnor: im guessing he teaches it incorrectly
23:35:31 <j-invariant> which analogy exactly
23:35:36 <dibblego> roconnor, not explicitly, but this question comes up occasionally
23:35:42 <roconnor> thank goodness
23:36:03 <j-invariant> precisely what is the analogy?
23:36:06 <j-invariant> (the false one)
23:36:17 <dibblego> roconnor, occasionally a beginner will say "so type-classes are like interfaces", which is totally wrong and if I don't pull it up, it leads to problems
23:36:20 <ion> Now, is $ more like BASICâ€™s GOTO or GOSUB?
23:36:25 <dibblego> j-invariant, Java interfaces are like type-classes (false)
23:36:33 <j-invariant> That's completely absurd
23:36:37 <roconnor> dibblego: but it is true
23:36:40 <j-invariant> why would anyone even come up with that
23:36:43 <dibblego> j-invariant, I would just say mistaken, not absurd
23:36:51 <roconnor> j-invariant: interface X { Y f(Z z); } is analogous to class X where f :: X -> Z -> Y
23:37:05 <dibblego> roconnor, that won't compile
23:37:08 <Saizan> another point in dibblego favour, is that OO noobs come here and start using typeclasses inevitably end up frustrated because inheritance doesn't work like they'd expect, but it'd work perfectly with record types
23:37:13 <j-invariant> There is no analogy
23:37:19 <roconnor> dibblego: what won't compile?
23:37:37 <j-invariant> java interfaces are something, haskell typeclasses are something else
23:37:43 <azaq23> An interface declares some methods as abstract. You define classes which implement these. You can instantiate classes. How is that not basically the same as the haskell "A typeclass declares some functions. A datatype can implement these functions. You "instantiate" a datatype (by using a data constructor)."
23:37:53 <dibblego> roconnor, your type-classs
23:38:16 <dibblego> j-invariant, because there is an analogy if you wish to save the idea that an analogy exists in the first place, but it is definitely not type-classes
23:38:19 <augur> dibblego: better question, where does it lead to problems, et
23:38:20 <j-invariant> azaq23: java has an object system, interfaces are one part of it. Haskell has typed functions, typeclasse are part of this.
23:38:25 <Saizan> there's more to typeclasses, interfaces and record types than "a specification of methods"
23:38:29 <dibblego> augur, in #haskell in this case :)
23:38:42 <augur> yes but where
23:38:49 <roconnor> j-invariant: interface X { Y f(Z z); } is analogous to class X x where f :: x -> Z -> Y
23:38:50 <ddarius> augur: drawAll(List<IDrawable> drawables)
23:38:51 <j-invariant> dibblego: I reject the possibility of any analogy
23:38:51 <augur> what is an example of this supposed problem
23:38:57 <Saizan> dibblego: i think augur means in code
23:38:58 <roconnor> dibblego: sorry
23:39:03 <dibblego> augur, there is a difference between data Eq a and class Eq a
23:39:11 <augur> ofcourse there is
23:39:15 <augur> but what is the PROBLEM
23:39:37 <dibblego> the problem is that you can write exactly what roconnor wrote as a type-class, but *failed to compile*, as a Java interface
23:39:48 <augur> uh
23:39:52 * BMeph rejects your analogy and replaces it with one of his choosing! ;Ã¾
23:39:53 <augur> YOU gave that Java interface, buddy
23:39:55 <roconnor> dibblego: I fixed it
23:40:01 <roconnor> dibblego: interface X { Y f(Z z); } is analogous to class X x where f :: x -> Z -> Y
23:40:05 <augur> that interface that he typed? Thats all yours.
23:40:07 <dibblego> roconnor, I know, but that's because you're not just learning
23:40:08 <azaq23> j-invariant: Right. I still don't see why they are not *basically* the same, if you ignore all the typeclass-superiority by using very fancy type stuff things
23:40:21 <dibblego> augur, I said type-class
23:40:38 <dibblego> in Java, nub has this signature:: Eq a -> [a] -> [a] -> Bool
23:40:44 <roconnor> dibblego: I'm not learning because I fixed my haskell code?
23:40:48 <augur> obviously you cant compile a haskell typeclass as a java interface because they're different languages so please be clearer
23:40:50 <dibblego> in Java, nub *cannot possibly have this signature* :: Eq a => [a] -> [a]
23:41:12 <dibblego> roconnor, because you are not learning, you were able to fix it, noobs cannot (you fixed it by creating something unlke Java interface)
23:41:12 <ddarius> roconnor: "not just learning" /= "not learning"
23:41:22 <augur> so? ok so the haskell type system can do more
23:41:29 <augur> in that it has type constraints
23:41:31 <dibblego> augur, that's what I said, remember?
23:41:32 <augur> whats your point
23:41:38 <roconnor> dibblego: no I just made a typo in my original post
23:41:40 <augur> thats about type constraints, not type classes
23:41:48 <dibblego> type-classes have no equivalent (even approximately) in Java <-- this is my point
23:41:50 <augur> oviously type constraints only matter if you have type classes
23:41:53 <dibblego> roconnor, ok
23:41:55 <augur> but you can have type classes without type constraints
23:42:10 <augur> how you USE a type class is not what makes a typeclass what it is
23:42:11 <dibblego> it is clear that my ultimate objective, which is to destroy this myth, will not succeed
23:42:13 <roconnor> dibblego: not every typeclass in Haskell can be written as a Java interface.  In this sense Haskell typeclasses are more expressive than java interfaces
23:42:16 <dibblego> I am happy to conclude
23:42:26 <dibblego> roconnor, not *any* type-class you mean
23:42:27 <augur> so i ask you again, what is the problem that arises
23:42:38 <j-invariant> dibblego: that's because you try to replace it with something else which is flawed. Rather than outright reject it
23:42:47 <ddarius> augur: I already gave you the beginning of an example.
23:42:58 <dibblego> ok, so we have at least moved to "Java interfaces are like type-classes, except not as expressive", which is an improvement
23:43:05 <dibblego> I am happy with that, thanks
23:43:06 <augur> ddarius: i wasnt paying attention to you :P
23:43:23 <ddarius> Java interfaces are not less expressive than Haskell type classes, they are differently expressive.
23:43:33 <dibblego> godspeed ddarius 
23:43:34 <augur> ddarius: i dont know what your example is supposed to do
23:44:08 <ddarius> augur: It something that works in Java and the "obvious" analog in Haskell has a completely different meaning.
23:44:14 <augur> how is that not just drawAll :: [IDrawable] -> ...
23:44:31 <ddarius> augur: It would be, but IDrawable there would not be a class now would it?
23:44:48 <augur> It'd be a type
23:44:55 <roconnor> drawall :: IDrawable x => [x] -> IO ()
23:44:58 <ddarius> augur: Which is exactly what dibblego was saying.
23:44:59 <augur> and since the analogy is Haskell type's ~ Java classes
23:45:16 <ddarius> IDrawable is an interface (presumably and now assertedly)
23:45:18 <roconnor> drawall = mapM_ draw
23:45:25 <azaq23> dibblego: Wasn't the not as expressive part what everyone assumed from the beginning? roughly analogous, etc.
23:45:29 <roconnor> no problem
23:45:31 <augur> ah well, if IDrawable is an interface thats different
23:45:31 <ddarius> roconnor: Yes, and that behaves differently than the Java equivalent.
23:45:36 <roconnor> how so?
23:45:56 <j-invariant> There is no java equivalent
23:46:16 <ddarius> Because I can drawAll a list of Circles and Squares, but in Haskell I would have to have a list of just Circles or just Squares.
23:46:38 <augur> roconnor: presumably because even while x can be drawable, it still has to be a mono-typed list
23:46:46 <augur> just where the type is an instance of IDrawable
23:47:06 <DevHC> who (which programming language or paradigm) was to first define what a class is (ie. which programming languages misuse the word "class")?
23:47:09 <augur> whereas List<IDrawable> can have arbitrarily many classes as long as they all implement IDrawable
23:47:15 <roconnor> ah right
23:47:24 <roconnor> drawall :: [IDrawable x => x] -> IO ()
23:47:25 <augur> obviously this is a point of departure between haskell and java's notion of type membership
23:47:27 <j-invariant> DevHC: it's a vague term, it can mean a whole load of different things
23:47:30 <roconnor> drawall = mapM_ draw
23:47:37 <roconnor> just need some existential types :D
23:47:41 <ddarius> DevHC: Usually Simula67 is considered the first "object-oriented" language.
23:47:42 <DevHC> orly
23:48:22 <azaq23> DevHC: Alan Key first defined the term object orientied and invented Smalltalk, if that's what you want to know
23:48:29 <dibblego> azaq23, "not as expressive" is not the same as "roughly analogous"
23:48:34 <augur> ddarius: Sketchpad! :|
23:48:42 <DevHC> who defined the term class?
23:49:03 <j-invariant> DevHC: it's been defined hundreds of times in different contexts to mean different things
23:49:03 <Xilon> Smalltalk doesn't use the term "class" (syntactically) does it?
23:49:06 <dibblego> azaq23, "roughly analogous" suggests there is some rough analogy (which doesn't exist, else I'd have seen an answer to my question)
23:49:19 <DevHC> uhm
23:49:19 <augur> which quesiton was tht, dibblego
23:49:27 <DevHC> who thefined the term class FIRST?
23:49:33 <dibblego> augur, I wish to discontinue, sorry
23:49:38 <ddarius> DevHC: Simula67
23:49:39 <roconnor> I think auger sketched a good rough analogy above
23:49:54 <augur> which analogy was that XD
23:50:01 <ddarius> At least as a specific programming language construct.
23:50:10 <j-invariant> it's not an analogy, it's a way to take code in one language and write code in another
23:50:13 <DevHC> and there a class is an interface or an object type?
23:50:29 <augur> DevHC: that sentence does not parse
23:50:40 <ddarius> A class is a class just like in C# or Java.
23:50:48 <roconnor> oh it was azaq23 who sketched the analgoy
23:50:57 <roconnor> [02:37] <azaq23> An interface declares some methods as abstract. You define classes which implement these. You can instantiate classes. How is that not basically the same as the haskell "A typeclass declares some functions. A datatype can implement these functions. You "instantiate" a datatype (by using a data constructor)."
23:51:28 <roconnor> though I now see that the analogy is even rougher than I had realized
23:51:33 <ddarius> Indeed.
23:51:44 <augur> indeed but that roughness comes from membership considerations nothing else
23:52:03 <augur> in haskell, the whole of a things type is relevant in all stages
23:52:28 <augur> hence why IDrawable x => [x] wont work the same
23:54:08 <augur> and its probbaly true that [IDrawable x => x] has the same behavior as that, so roconnor, your fix wouldnt work
23:54:09 <roconnor> in part of my defense, last time I used java "List<IDrawable>" wasn't legal
23:54:14 <roconnor> :)
23:54:26 <augur> but i dont think a slightly modification to the haskell type inference mechanism required to make this work would be an issue
23:54:37 <augur> and certainly would leave the nature of typeclasses unchanged
23:55:15 <roconnor>  [IDrawable x => x] has the same behavior as what?
23:55:31 <augur> would it not have the same behavior as IDrawable x => [x]?
23:55:34 <roconnor> no
23:55:39 <roconnor> well I should write it as
23:56:01 <roconnor> drawall :: [exists. IDrawable x *> x] -> IO ()
23:56:09 <roconnor> that might even be legal in UHC
23:56:11 * roconnor checks
23:56:12 <augur> well ok but thats not [IDrawable x => x] :P
23:56:31 <roconnor> it's what I mean though.  Plz read my mind
23:56:35 <augur> no u
23:57:07 <augur> > [1 :: Int, 2 :: Double] :: Num a => [a]
23:57:08 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
23:57:08 <lambdabot>         against inferred type ...
23:57:14 <augur> > [1 :: Int, 2 :: Int] :: Num a => [a]
23:57:14 <lambdabot>   Couldn't match expected type `a'
23:57:15 <lambdabot>         against inferred type `GHC.Types.I...
23:57:20 <augur> oh hm
23:57:30 <augur> erm
23:57:39 <augur> why doesnt that work, exactly?
23:57:59 <roconnor> because classes are contraints :)
23:58:13 <augur> ok?
23:58:15 <roconnor> well
23:58:21 <augur> but why doesnt it work :P
23:58:30 <roconnor> consider fold (+) 0 [1 :: Int, 2 :: Double]
23:58:41 <ddarius> Num a is not a type.  a is a type.  You have a list of a where a is constrained to be an instance of Num.
23:58:42 <augur> ok then lets!
23:58:45 <roconnor> that won't work because + doesn't operate on both Int and Double parameters
23:58:49 <augur> > fold (+) 0 [1 :: Int, 2 :: Double]
23:58:50 <Saizan> roconnor: now, if you start thinking about the difference between typeclass resolution and the (non-)equivalent in java, it gets even rougher
23:58:50 <lambdabot>   Not in scope: `fold'
23:58:54 <augur> > foldr (+) 0 [1 :: Int, 2 :: Double]
23:58:55 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
23:58:55 <lambdabot>         against inferred type ...
23:59:11 <Saizan> *typeclass instance resolution
23:59:15 <augur> roconnor: sure but does it have to?
23:59:18 <roconnor> because in Haskell type classes (+) :: a -> a -> a, the type variable can occur multiple times
23:59:29 <augur> oh yes it would
23:59:36 <augur> so thats not analogous to what i wanted to do
23:59:46 <augur> > map (+0) [1 :: Int, 2 :: Double]
23:59:47 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
23:59:48 <lambdabot>         against inferred type ...
23:59:50 <roconnor> augur: perhaps java gets away with this because in java the type variable occurs exactly once, in the hidden self parameter
23:59:58 <augur> now _that_ is certainly interesting
