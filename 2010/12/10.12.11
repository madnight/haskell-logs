00:11:59 <wagle> aieee  how do i find my old bookmarks in the new wiki for haskell.org?  like what happened to http://www.haskell.org/YaleHaskellGroupWiki/Projects
00:12:23 <wagle> search finds nothing
00:17:48 <dmwit> The answer is likely, "complain to the YaleHaskellGroup, they were supposed to speak up weeks ago about how to migrate their stuff".
01:01:11 <wagle> yeah
01:03:07 -OpenMike(~cokecig@66-168-255-112.static.mtgm.al.charter.com)- HI EVERYONE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE!
01:03:39 -OpenMike(~cokecig@66-168-255-112.static.mtgm.al.charter.com)- HI EVERYONE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE!
01:04:09 -OpenMike(~cokecig@66-168-255-112.static.mtgm.al.charter.com)- HI EVERYONE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE!
01:04:15 <dolio> @where ops
01:04:16 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
01:04:39 -OpenMike(~cokecig@66-168-255-112.static.mtgm.al.charter.com)- HI EVERYONE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE!
01:05:09 -OpenMike(~cokecig@66-168-255-112.static.mtgm.al.charter.com)- HI EVERYONE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE!
01:05:37 <ian_mi> hmm, I'm feeling a strange inclination to join #math
01:05:39 -OpenMike(~cokecig@66-168-255-112.static.mtgm.al.charter.com)- HI EVERYONE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE!
01:06:09 -OpenMike(~cokecig@66-168-255-112.static.mtgm.al.charter.com)- HI EVERYONE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE!
01:06:14 <augur> @where ops
01:06:14 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
01:06:31 <shachaf> > map @seen . @where $ ops
01:06:32 <lambdabot>   <no location info>: parse error on input `@'
01:06:32 <shachaf> :-(
01:06:38 <shachaf> I guess it would be mapM.
01:06:39 -OpenMike(~cokecig@66-168-255-112.static.mtgm.al.charter.com)- HI EVERYONE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE!
01:06:42 <augur> @where ops
01:06:42 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
01:07:07 <augur> i will continue to ping ops every time openmike does this shit.
01:07:09 -OpenMike(~cokecig@66-168-255-112.static.mtgm.al.charter.com)- HI EVERYONE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE!
01:07:11 <augur> @where ops
01:07:11 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
01:07:20 <augur> :|
01:07:26 <shachaf> augur: Come on, be nice to the ops.
01:07:26 <augur> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
01:07:26 <dolio> That isn't helping the spam problem.
01:07:34 <florianpilz> hello everyone, maybe someone wants to help me: I want to create random numbers with the generator which was created on start of the program ‚Äî however all random numbers created that way are IO a, but i want (g, a) without using mkStdGen
01:07:39 <augur> dolio: true, but its not adding much to it :P
01:07:39 -OpenMike(~cokecig@66-168-255-112.static.mtgm.al.charter.com)- HI EVERYONE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE!
01:08:09 -OpenMike(~cokecig@66-168-255-112.static.mtgm.al.charter.com)- HI EVERYONE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE!
01:08:11 <augur> dolio: on unrelated notes
01:08:14 <ziman> florianpilz, you still need to get the seed from somewhere
01:08:18 <medfly> lol
01:08:19 <augur> anything new in the haskell sphere?
01:08:29 <ziman> florianpilz, either from mkStdGen (or something related), or from the mighty unpure IO
01:08:37 <florianpilz> thought the global random generator is initialized with a seed?
01:08:39 <shachaf> florianpilz: Just get the seen from IO and then pass it into your functions.
01:08:39 -OpenMike(~cokecig@66-168-255-112.static.mtgm.al.charter.com)- HI EVERYONE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE!
01:08:43 <augur> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
01:09:02 <ziman> florianpilz, there are no global variables in Haskell. :)
01:09:09 -OpenMike(~cokecig@66-168-255-112.static.mtgm.al.charter.com)- HI EVERYONE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE!
01:09:14 <augur> wait, who's actually in here
01:09:15 <augur> :|
01:09:17 <florianpilz> hm, but how do I get "a" out of "IO a"? pattern matching did not work (or I was probably to dumb ;))
01:09:17 <augur> Cale: 
01:09:21 <shachaf> augur: Come on.
01:09:39 -OpenMike(~cokecig@66-168-255-112.static.mtgm.al.charter.com)- HI EVERYONE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE!
01:09:47 <sipa> florianpilz: you don't
01:09:52 <florianpilz> hackage tells me that getStdGen gets the global random number generator so ‚Ä¶ 
01:09:55 <florianpilz> damn
01:09:56 <shachaf> florianpilz: The "IO a" doesn't contain an "a".
01:10:09 -OpenMike(~cokecig@66-168-255-112.static.mtgm.al.charter.com)- HI EVERYONE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE!
01:10:30 <augur> Cale dons dcoutts Saizan dibblego Philippa kosmikus Igloo quicksilver monochrom Lemmih jmcarthur
01:10:32 <shachaf> florianpilz: It's lying. Haskell has no global variables. Big Brother is watching you.
01:10:36 <augur> you are all present in this channel
01:10:39 -OpenMike(~cokecig@66-168-255-112.static.mtgm.al.charter.com)- HI EVERYONE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE!
01:10:57 <sipa> kick that OpenMike 
01:10:57 <florianpilz> so whats the way to go to get a single random number from the global generator (which yields "IO a") and use it as a seed for mkStdGen?
01:11:09 -OpenMike(~cokecig@66-168-255-112.static.mtgm.al.charter.com)- HI EVERYONE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE!
01:11:09 <shachaf> florianpilz: Read about IO actions.
01:11:37 <augur> dolio: gimme links :D
01:11:39 -OpenMike(~cokecig@66-168-255-112.static.mtgm.al.charter.com)- HI EVERYONE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE!
01:11:54 <florianpilz> hm, havent thought about that *duck*
01:12:00 <shachaf> florianpilz: main = do { stdgen <- getStdGen; ... {- stdgen :: StdGen -} }
01:12:02 <florianpilz> thanks ;)
01:12:09 -OpenMike(~cokecig@66-168-255-112.static.mtgm.al.charter.com)- HI EVERYONE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE!
01:12:39 -OpenMike(~cokecig@66-168-255-112.static.mtgm.al.charter.com)- HI EVERYONE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE! JOIN #MATH NOW!! JOIN #MATH NOW!! EVERYTHING YOU WANT THE BADDEST ASS CHANNEL ON FREENODE!
01:12:49 --- mode: ChanServ set +o Cale
01:12:50 <ion> florianpilz: f >>= g where f :: IO a and g :: a ‚Üí ‚Ä¶, g will eventually be called with the value of type a that f returns.
01:13:02 <augur> thank you, cale.
01:13:03 --- mode: Cale set +b *!*@66-168-255-112.static.mtgm.al.charter.com
01:13:04 --- kick: OpenMike was kicked by Cale (OpenMike)
01:13:04 <shachaf> Cale++
01:13:16 <sipa> thx
01:13:55 <augur> we should have some sort of bot that can prevent this sort of thing.
01:14:02 <ion> florianpilz: do a <- f; ‚Ä¶ is syntactic sugar for f >>= \a -> ‚Ä¶ where the lambda expression would be equivalent to g in the example above.
01:14:06 <augur> we can write it in haskell, obviously.
01:14:48 <shachaf> We should have evenly-time-zone-distributed bots.
01:14:51 <shachaf> s/bots/ops/
01:15:35 <medfly> hehehe
01:15:48 <medfly> "I can't go honey, I have a shift guarding #haskell"
01:16:02 <florianpilz> thanks shachaf & ion :)
01:16:08 <augur> shachaf: that too.
01:16:24 <augur> i would volunteer but i dont live in a timezone.
01:17:05 <augur> someone point me to some interesting programming language theory work. something interesting and new or weird
01:17:50 <ion> augur: There‚Äôs this thing called ‚Äúlambda calculus‚Äù.
01:17:56 <augur> :P
01:17:57 <shachaf> augur: You're done with okmij.org? :-)
01:18:07 <augur> shachaf: oleg. warg.
01:18:16 <augur> i dont know if ill EVER be done with oleg
01:18:27 <shachaf> augur: Problem solved.
01:18:30 <augur> :P
01:28:25 <augur> shachaf: also, oleg is unfortunately very practical in a lot of his work
01:28:30 <augur> and the abstract stuff is meh
01:30:10 <shachaf> augur: Oleg is practical? Really?
01:30:20 <augur> shachaf: well, sort of
01:30:30 <lpsmith> actually the abstract stuff can be brilliant,  but unfortunately is usually not clearly explained.   But clear explanations are hard
01:30:35 <dolio> He just published something about remote execution.
01:30:37 <augur> i mean, whats all this stuff about XML trees and such
01:30:39 <augur> honestly now
01:31:02 <dolio> Which sounds pretty practical to me. Distributed computing.
01:31:05 <augur> i need to find a book on constraint logic
01:31:17 <augur> and also parallelism/concurrency
01:31:25 <augur> but theoretical issues and approaches
01:31:32 <augur> i hear linear logic is good for reasoning about concurrency
01:32:02 <lpsmith> I mean,  I don't know how good or bad my explanation of my corecursive queues are,  but the first section of my monad reader article was written over the course of two years.
01:32:38 <lpsmith> I mean,  it was basically write for a week,  let it sit for six months,  come back and reread it and try to improve it again,  rinse and repeat
01:33:25 <lpsmith> actually probably more like three years.
02:01:58 <Nibble> what does the =? function do?
02:02:11 <shachaf> Nibble: That depends on where you got it from.
02:02:25 <shachaf> @hoogle =?
02:02:25 <lambdabot> Test.HUnit.Base (
02:02:25 <lambdabot> Test.HUnit.Base (~=?) :: (Eq a, Show a) => a -> a -> Test
02:02:25 <Nibble> shachaf: I have no clu,e tpye is (=?) :: (Eq a) => Query a -> a -> Query Bool
02:02:37 <shachaf> @hoogle Query
02:02:37 <lambdabot> module Data.Graph.Inductive.Query
02:02:37 <lambdabot> Network.URI query :: URI -> String
02:02:37 <lambdabot> Network.CGI queryString :: MonadCGI m => m String
02:02:48 <shachaf> Nibble: Please specify your context a little bit.
02:03:06 <Nibble> my xmonad config file, classname =? "MPlayer" --> doFloat
02:03:33 <shachaf> Oh, xmonad. Probably #xmonad would be a better place to ask, then.
02:03:44 <Nibble> hmm, how do I check if an element exists in a list?
02:04:07 <Maxdamantus> > 42 `elem` [1..100]
02:04:08 <lambdabot>   True
02:04:11 <Nibble> ah, elem
02:05:57 <shachaf> Nibble: I'm pretty sure it's explained in XMonad's documentation.
02:06:15 <Nibble> most likely yes
02:06:46 <Nibble> hmm
02:06:50 <Nibble> this sounds strange
02:06:52 <Nibble> > find (\x -> 5**x > 10000) [2,4,6,8]
02:06:52 <lambdabot>   Just 6.0
02:06:58 <Nibble> Why the floating point?
02:07:19 <dolio> (**) is floating point exponentiation.
02:07:36 <Nibble> oh
02:07:42 <Nibble> > find (\x -> 5^x > 10000) [2,4,6,8]
02:07:43 <lambdabot>   Just 6
02:07:56 <Nibble> there we go, someone probably brainfarted when they wrote that example
02:07:57 <shachaf> > find (\x -> xor 5 x > 10000) [2,4,7,8] -- You want ^.
02:07:58 <lambdabot>   Nothing
02:08:17 <Nibble> shachaf: I am way ahead of you :P
02:08:42 <shachaf> Nibble: Really? I hope you're not using bitwise operators for this.
02:09:21 <Nibble> shachaf: hm? ^ is a bitwise operator in haskell? I was thinking of your comment "You want ^"
02:09:34 <shachaf> Nibble: I was thinking of my "xor 5 x". :-)
02:09:39 <Nibble> oh
02:10:08 <Nibble> why hasn't arch updated their ghc package
02:10:11 <Nibble> sounds stupid
02:10:13 <Nibble> I want llvm
02:12:52 <MrHOLO> How can I write a code to compute the length of a list in Haskell?
02:13:03 <Nibble> MrHOLO: hold on
02:13:27 <shachaf> MrHOLO: Define lists to be an instance of Num.
02:13:37 <shachaf> Then length = id.
02:14:04 <MrHOLO> shachaf: I didn't get you
02:14:31 <MrHOLO> Till now I was trying to arrive at a recursive if condition
02:14:39 <Nibble> @let xs = [1..10]
02:14:40 <lambdabot>  Defined.
02:14:53 <ziman> MrHOLO, you probably want to use pattern matching
02:15:07 <Nibble> @let length' xs = sum [x-x+1, x <- xs]
02:15:07 <lambdabot>   Parse error: LeftArrow
02:15:11 <shachaf> MrHOLO: My answer was unhelpful, of the form "Represent a number N as a list of N elements".
02:15:16 <Nibble> @let length' xs = sum [x-x+1 | x <-  xs]
02:15:17 <shachaf> MrHOLO: Is this a homework problem?
02:15:17 <lambdabot>  Defined.
02:15:23 <Nibble> > length' xs
02:15:24 <lambdabot>   10
02:15:29 <Nibble> MrHOLO: there you go
02:15:39 <Nibble> length' xs = sum [x-x+1 | x <- xs]
02:15:39 <MrHOLO> No it is 'my' problem
02:15:54 <MrHOLO> I was going through Real World Haskell
02:16:05 <MrHOLO> So I just took this up as an exercise
02:16:09 <Nibble> MrHOLO: the code I wrote
02:16:11 <Nibble> use it
02:16:21 <Nibble> you probably need some edge cases, like empty list
02:16:23 <ziman> MrHOLO, you can read about pattern matching here: http://learnyouahaskell.com/syntax-in-functions ‚Äî basically, you want to define the length of the empty list and the length of something consed to a smaller list
02:16:25 <MrHOLO> I am trying to understand it nibble
02:16:25 <Nibble> > length' []
02:16:26 <lambdabot>   0
02:16:39 <Nibble> ziman: my approach is far superior
02:16:52 <Nibble> nvm, you don't need edge cases
02:16:53 <ziman> Nibble, go ahead
02:16:56 <shachaf> Nibble: MrHOLO is trying to figure this out, so just giving a solution -- espcially an overly-complicated and overly-specific solution like that one -- is unhelpful.
02:17:17 <Nibble> shachaf: Overly complicated?
02:17:34 <Nibble> anyone in here uses arch? ghc package needs a maintainer
02:17:57 <shachaf> Nibble: Everyone in #haskell uses Arch, except for me, it seems.
02:18:07 <Nibble> shachaf: openbsd?
02:18:07 <ziman> @quote canons
02:18:08 <lambdabot> No quotes match. My pet ferret can type better than you!
02:18:17 * ziman uses debian
02:19:13 <ian_mi> Nibble: your length requires lists of class Num
02:19:14 <Nibble> MrHOLO: Do you understand the example?
02:19:25 <Nibble> ian_mi: yes
02:19:27 <MrHOLO> Nibble: No
02:19:31 <Nibble> that is why I am going to rewrite it
02:19:39 <MrHOLO> I am trying to 
02:19:50 <Nibble> @let length' xs = [1 | x <- xs]
02:19:50 <lambdabot>  <local>:2:0:
02:19:51 <lambdabot>      Warning: Pattern match(es) are overlapped
02:19:51 <lambdabot>               In...
02:20:01 <Nibble> @undefine length'
02:20:06 <shachaf> Nibble: You're just being unhelpful.
02:20:08 <Nibble> @unlet length'
02:20:08 <lambdabot>   Parse error: SemiColon
02:20:15 <Nibble> how do I unlet stuff?
02:20:20 <Nibble> @let length'' xs = [1 | x <- xs]
02:20:21 <lambdabot>  Defined.
02:20:24 <Nibble> there we go
02:20:27 <ziman> maybe forget?
02:20:28 <Nibble> ian_mi: now it doesn't
02:20:39 <ian_mi> Nibble: you forgot to sum the list
02:20:56 <Nibble> oh right
02:21:03 <Nibble> @let length''' xs = sum [1 | x <- xs]
02:21:03 <lambdabot>  Defined.
02:21:19 <MrHOLO> Nibble: What kind of a syntax is this?
02:21:22 <Nibble> > length''' [1..100] -- answer = 5050
02:21:23 <lambdabot>   Not in scope: `length''''
02:21:23 <shachaf> MrHOLO: Let's try to be a bit more helpful. You want to figure out how to write the function recursively, right?
02:21:39 <Nibble> MrHOLO: List comprehension
02:21:47 <MrHOLO> Yes shachaf
02:21:49 <Nibble> MrHOLO: here is another example of list comprehension
02:22:01 <MrHOLO> I am very new to Haskell
02:22:05 <ian_mi> how about foldr (\x -> (+1)) 0 xs
02:22:13 <MrHOLO> And am just reading the second chapter of RWH
02:22:14 <shachaf> Nibble: Come *on*. MrHOLO is should be learning to think recursively, not learning weird special-case corners of Haskell syntax.
02:22:29 <ziman> @undefine length''
02:22:36 <shachaf> MrHOLO: Consider http://learnyouahaskell.com/ if you're just starting out.
02:22:38 <ziman> @type length''
02:22:39 <lambdabot> Not in scope: `length'''
02:22:42 <ziman> there you go.
02:22:50 <Nibble> > [(a,b,c) | a <- [1..100], b <- [a+1..100], c <- [b+1..100], a^2+b^2 == c^2]
02:22:51 <lambdabot>   [(3,4,5),(5,12,13),(6,8,10),(7,24,25),(8,15,17),(9,12,15),(9,40,41),(10,24,...
02:23:00 <Nibble> pythagorean triples, yay!
02:24:41 <Maxdamantus> Project Euler..
02:26:10 <shachaf> MrHOLO: OK. So a recursive function definition is pretty simple: You have a base case and a recursive case.
02:26:18 <shachaf> MrHOLO: Do you know what the base (simplest) case would be?
02:26:43 <dolio> You could have multiple of each, too.
02:26:48 <MrHOLO> I know the simple recursive functions shachaf
02:27:15 <shachaf> MrHOLO: I think "length" usually qualifies as a simple recursive function. :-) What trouble are you having with it?
02:27:16 <MrHOLO> I make simple functions to generate fibonacci and all
02:27:31 <MrHOLO> Yeah true 
02:28:03 <shachaf> MrHOLO: Hopefully not "fib n = fib (n - 1) + fib (n - 2)". :-)
02:28:16 <MrHOLO> Yeah the same 
02:28:19 <Maxdamantus> > scanl1 1 $ (1:) . zipWith (+) [1..]
02:28:20 <lambdabot>   Couldn't match expected type `[[t]]'
02:28:20 <lambdabot>         against inferred type `[a] -> ...
02:28:24 <Maxdamantus> Meh.
02:28:32 <MrHOLO> After specifying the initial values ofcourse
02:28:35 <Maxdamantus> > scanl1 1 $ fix $ (1:) . zipWith (+) [1..]
02:28:36 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
02:28:40 <Maxdamantus> Forgot it.
02:29:17 <Maxdamantus> Oh, should've been something like ap (zipWith (+)) tail
02:29:19 <shachaf> > fix $ (1:) . scanl (+) 1
02:29:21 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
02:29:26 <Maxdamantus> Ah.
02:30:04 <Maxdamantus> > fix $ (1:) . (1:) . ap (zipWith (+)) tail
02:30:05 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
02:30:34 <shachaf> MrHOLO: That function won't work for values bigger than 50 or so.
02:31:01 <Nibble> > fix error
02:31:02 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
02:31:20 <Maxdamantus> > fix show
02:31:22 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
02:31:25 <shachaf> > fix nibble
02:31:26 <lambdabot>   Nibble is permanently broken
02:31:33 <Nibble> > fix your're face
02:31:34 <lambdabot>   Not in scope: `your're'Not in scope: `face'
02:31:43 <Nibble> hilarious
02:32:25 <c_wraith> > nibble 35
02:32:26 <Nibble> lol @ discussion in arch
02:32:26 <lambdabot>   Not in scope: `nibble'
02:52:49 <Cale> "your're" is a lovely monstrosity
02:53:32 <Nibble> oh, I meant youre'r
02:54:00 <shachaf> @localtime Cale
02:58:06 <luite> Nibble: mean't ;p
03:11:23 <Cin> @vixen your stupid
03:11:24 <lambdabot> you sir are no gentleman
03:13:47 <ion> ‚Äì Thank‚Äôs
03:13:51 <ion> ‚Äì Your welcome
03:16:46 <shachaf> @vixen YOUR STUPID IS GREATER THAN MY STUPID
03:16:46 <lambdabot> Most guys don't understand me, but we really seem to connect.
03:16:55 * shachaf should goto sleep;
03:19:31 <litb> hello folks
03:19:41 <litb> nice question popped up: http://stackoverflow.com/questions/4411279/haskell-typeclasses-and-c-template-classes
03:19:45 <litb> please enjoy
03:49:23 <Renze> Good afternoon!
03:53:00 <Renze> I'm stuck at a stupid function which is quite simple, but I can't find the solution to it... I want the 'length' of a Int; so 123=3, 123456=6, 1234567890123=13, ... All of my previous attempts lead to an function which returns the correct result for at least a result of <10 (so until 999.999.999), but with numbers bigger than that, every solution has a type conversion bug somewhere...
03:53:28 <Renze> Does anyone have a good idea of fixing it? I assume the answer is right in front of me, but I just didn't catch it yet.
03:53:32 <merijn> Renze: How about converting to a string then taking the length of it?
03:53:46 <Renze> But that is slow, right? :(
03:54:03 <merijn> Depends, how long are you expecting your numbers to be?
03:55:11 <Renze> Well, did not yet think of that, but ~20 should fit good enough.
03:55:17 <merijn> Pfft
03:55:34 <merijn> Unless your numbers are going to be longer then >100 numbers I wouldn't even consider speed
03:55:43 <merijn> And even then its probably fast enough
03:56:29 <Renze> Yes, that's right, but I use the function a lot (like REALLY a lot)
03:57:24 <merijn> Try this first, then see/profile if your code is too slow. IF its too slow and this function is the problem, THEN try to speed it up
03:58:27 <merijn> No point in trying to speed up bottlenecks you aren't sure are bottle necks
03:59:48 <Renze> That's right. Thanks :) 
04:20:45 <augur> hrmph.
04:42:49 <cncl> is it possible to declare an instance of functor for a functor within a functor
04:44:19 <cncl> (forgot to add a ? to the end of that sentence)
04:44:39 <merijn> cncl: How do you mean?
04:46:41 <cncl> like if i have a functor within a functor, then fmap would be lifted to the innermost functor
04:47:39 <merijn> I think so
04:48:03 <cncl> i couldn't puzzle it out myself
04:48:44 <parcs> define a monad instance of that functor, if possible
04:48:49 <parcs> then you get join
04:49:35 <parcs> (well, that wouldn't work if the functors are different)
04:49:43 <cncl> my functor has no pure/return anyway
04:52:54 <Cale> er
04:52:58 <Cale> You don't need join :)
04:53:34 <Cale> You just apply fmap twice
04:53:38 <Cale> :t fmap . fmap
04:53:39 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
04:54:09 <Cale> (and wrap it up in whatever newtype you're using to denote the composite of the functors, if you're writing an instance
04:54:10 <Cale> )
04:55:08 <cncl> ah, i meant for any two functors
04:55:30 <cncl> and without using a newtype to wrap them
04:55:44 <cncl> (so it would be an orphan instance)
04:58:53 <merijn> Cale: Way to obsolete the complicated attempt of doing that I was trying to work out with a trivial function composition >.>
04:59:22 <Cale> cncl: That would be ambiguous
05:00:55 <cncl> would it?
05:37:05 <mreh> is darcs clever enough to spot string replacements on its own?
05:37:44 <mreh> not strictly a haskell question
05:41:59 <mux> has -XGenerics been considered for Haskell2010?
05:42:42 <Igloo> No
05:43:40 <mux> Is it just not useful enough that noone thought about it, or are there other reasons?
05:45:10 <Igloo> All I know is no-one completed a proposal
05:52:18 <kosmikus> mux: I doubt that it would have any chance for inclusion in its current form. dreixel is working on a new implementation, though.
05:52:57 <mux> cool
05:53:40 <Aune> Cale: I have shown that a polynomial f(x) is irreducible in K. Now I need to  that the principal ideal it generates in K is maximal and or prime.
05:54:32 <Aune> Cale: If K is Q then it should be both since Q is a principal ideal domain, but I need to find a reference on that.
05:55:08 <Aune> And if K is Z then Im a bit lost
05:55:49 <Aune> Should be K[x], Q[x], Z[x] above
05:56:51 <Aune> @Cale, can you help me?
05:56:52 <lambdabot> Unknown command, try @list
05:57:18 <mux> btw, the documentation for generic classes says one need to use the 'lang' package, which doesn't seem to exist
07:04:07 <edon> what's a good tutorial on template haskell? most of the ones from the wiki page seem to be down.
07:06:12 <aavogt> edon: I guess some weren't moved when haskell.org switched servers
07:06:23 <aavogt> edon: you can find some ex. http://web.archive.org/web/20080822110753/http://haskell.org/bz/thdoc.htm
07:07:15 <aavogt> going through the prinf example (either there, or in some paper on TH) is probably a good idea
07:08:38 <edon> thanks aavogt
07:10:41 <Peaker> Hey, I'm trying to use Haskell as a matlab alternative for simple stuff, including graph plotting. Any simple plotting library that works? I tried HPlot and it wouldn't build on a standard Ubuntu. "plot" depends on the monstrous gtk2hs which took ages to install, and then I get runtime linkage errors :-(
07:11:09 <Peaker> And the examples aren't full, e.g: do not include import lists or the deps, which is highly frustrating
07:11:17 <sshc> Peaker: I would use cabal
07:11:26 <Peaker> sshc, I did use cabal, it took ages
07:11:26 <sshc> Peaker: But I'm not familiar with any plot libraries, sorry
07:11:47 <Peaker> sshc, I listed "plot" packages, it seemed not to have any other alternative, and these 2 are big and don't work for me
07:12:02 <aavogt> Peaker: there are a couple (?) bindings to gnuplot too
07:12:08 <aavogt> plot is prettier though
07:12:28 <megatron242> Hi, I'm trying to pattern match [(a,a)] as ((x,y):(xs,ys)) but it won't compile. What am I missing?
07:12:29 <sshc> Do the first bytes of Bitmaps as the package stb-image uses them hold the pixel of the bottom left corner or the top let corner of the bitmap?
07:12:36 <aavogt> Peaker: one interface to gnuplot being in HMatrix I think
07:12:58 <cncl> megatron242: ((x,y) : rest)
07:13:01 <Peaker> aavogt, plot itself was hard to find a working example to, and then when it finally builds, I get: 
07:13:06 <Peaker> GHCi runtime linker: fatal error: I found a duplicate definition for symbol  gtk2hs_closure_new
07:13:09 <sshc> megatron242: The end of a sequence of elements constructed by : needs to be a list
07:13:36 <sshc> megatron242: You probably want "((x, y):(x2, y2) : [])"
07:13:36 <cncl> Peaker: personally i use mathematica :[
07:13:51 <sshc> megatron242: You can also use the list monad if you wanted something else
07:14:07 <megatron242> cncl: But i need also rest to be mattched to xs and ys.
07:14:18 <sipa> megatron242: you'll need to do that afterwards
07:14:29 <cncl> megatron242: try thinking about it, that doesn't make sense :)
07:14:31 <megatron242> sshc: This compiles, but gives a run time error
07:14:47 <Peaker> I would figure Haskell, being used by some math types, would have great plotting packages :(
07:15:10 <sshc> megatron242: If you (x2, y2) to reer as a pair for each element, you can use the list monad
07:15:15 <Peaker> Plotting isn't even so hard to implement
07:15:18 <megatron242> cncl: Well, I'll need to have all the xs and ys.
07:15:26 <sipa> :t unzip
07:15:27 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
07:15:55 <aavogt> Peaker: I dunno what happened with your gtk2hs install. Perhaps it's only broken with ghci (and ok with ghc)?
07:15:58 <cncl> megatron242: pattern matching only works on data the way it is already constructed, not the way you want it transformed to
07:16:02 <megatron242> sipa: I'm familiar with unzip. I just thought it can be simpler.
07:16:07 <sipa> case list of ((x,y):rest) -> let (xs,ys) = unzip rest in ...
07:16:12 <sipa> that's what you want, i think
07:16:19 <sshc> megatron242: foo ((x, y) : vs) = do{ (futureX, futureY) <- vs; return $ expression_that_can_use_x_y_and_futureX_and_futureY }
07:16:24 <Peaker> aavogt, Ah, indeed with ghc --make it does work
07:16:29 <sipa> megatron242: a list of tuples is not a tuple of list
07:16:49 <megatron242> Ok, thanks all for your replies
07:17:26 <sshc> Do the first bytes of Bitmaps as the package stb-image uses them hold the pixel of the bottom left corner or the top let corner of the bitmap?
07:20:58 <sipa> top left
07:21:03 <sipa> oh
07:21:17 <sipa> not sure about any particular package, but top left is most common
07:22:31 <aavogt> Peaker: perhaps more annoying is that accessors in plot have such long names
07:22:55 <aavogt> since they decided not to group similarly named ones with classes
07:24:55 <Peaker> aavogt, I'm trying unsuccessfully to decipher a given example.. it's a bit ridiculous how difficult it seems to be.. plotting should be so much easier&simpler
07:25:43 <Peaker> aavogt, oh damn! I was reloading in emacs, emacs said it reloaded but it didn't so I got the same graph all the time
07:27:22 <rukav> Does Text.Regex.Posix support the backref in the regular expression? For example, "aa" =~ "(.*)\1$" :: Bool returns False.
07:27:48 <aavogt> the PCRE one supports more features
07:31:46 <Axman6> > "a\\1" ~= "(.*)\\1$"
07:31:46 <lambdabot>   Not in scope: `~='
07:31:49 <Axman6> :\
07:32:10 <mauke> > "a\\1" =~ "(.*)\\1$"
07:32:11 <lambdabot>   No instance for (Text.Regex.Base.RegexLike.RegexContext
07:32:11 <lambdabot>                    ...
07:32:16 <mauke> > "a\\1" =~ "(.*)\\1$" :: String
07:32:17 <lambdabot>   ""
07:32:20 <mauke> > "a\\1" =~ "(.*)\\1$" :: Bool
07:32:21 <lambdabot>   True
07:32:34 <mauke> > "aa" =~ "(.*)\\1$" :: String
07:32:35 <lambdabot>   "aa"
07:32:40 <Axman6> :t (=~)
07:32:41 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
07:32:52 <Axman6> o.O
07:32:56 <mauke> because perl was too simple
07:33:19 <Twey> Haha
07:33:31 <mauke> (in perl you either get a boolean result or a list of captured strings, depending on context)
07:34:44 <aristid> > "aaa" =~ "." :: [String]
07:34:45 <lambdabot>   No instance for (Text.Regex.Base.RegexLike.RegexContext
07:34:45 <lambdabot>                    ...
07:34:52 <aristid> :/
07:35:29 <aavogt> Peaker: it seems I was thinking of the library 'chart' rather than 'plot' which you use
07:35:40 <mauke>  > "aaa" =~ "." :: (String, String, String)
07:35:43 <mauke> > "aaa" =~ "." :: (String, String, String)
07:35:44 <lambdabot>   ("","a","aa")
07:35:58 <mauke> > "aaa" =~ ".b" :: (String, String, String)
07:35:59 <lambdabot>   ("aaa","","")
07:36:26 <aristid> ETOOMANYOVERLOADEDTYPES
07:36:54 <mauke> > "aaa" =~ ".b" :: Maybe String
07:36:55 <lambdabot>   No instance for (Text.Regex.Base.RegexLike.RegexContext
07:36:55 <lambdabot>                    ...
07:36:57 <mauke> aww
07:37:13 <Axman6> @instances-importing Text.Regex.Base.RegexLike.RegexContext
07:37:20 <Axman6> oi!
07:37:25 <aavogt> > "aaa" ==~ ".b" :: Maybe String
07:37:25 <lambdabot>   Not in scope: `==~'
07:37:31 <aavogt> > "aaa" =~~ ".b" :: Maybe String
07:37:32 <lambdabot>   Nothing
07:39:33 <Peaker> aavogt, is it simple?
07:39:44 <parcs> > "aaa" =~~ "." :: [String]
07:39:45 <lambdabot>   ["a"]
07:39:59 <Axman6> weak
07:40:25 <merijn> :t =~
07:40:26 <lambdabot> parse error on input `=~'
07:40:29 <merijn> :t (=~)
07:40:30 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
07:40:32 <mauke> > "aaa" =~~ ".(.)" :: [String]
07:40:34 <lambdabot>   ["aa"]
07:43:03 <aristid> :t (=~~)
07:43:03 <lambdabot> forall source1 source (m :: * -> *) target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target, Monad m) => source1 -> source -> m target
07:43:21 <mauke> > "aaa" =~~ ".(.)" :: [[String]]
07:43:22 <lambdabot>   No instance for (Text.Regex.Base.RegexLike.RegexContext
07:43:22 <lambdabot>                    ...
07:43:34 <aristid> woah, that's exceptionally ugly, using Monad for failure
07:44:23 <aristid> > "aaa" =~~ ".b" :: Either String String
07:44:24 <lambdabot>   Left "regex failed to match"
07:44:46 <rukav> "aa" =~ "(.*)\\1$" :: String returns "" using Text.Regex.Posix
07:45:20 <mauke> > ("aaa" =~~ ".b") (=~)
07:45:21 <lambdabot>   No instances for (Text.Regex.Base.RegexLike.RegexMaker
07:45:21 <lambdabot>                     ...
07:46:31 <aavogt> Peaker: plot looks simpler. I like Chart though, ex. used here http://code.haskell.org/~aavogt/darcsVersions/
07:47:22 <Nibble> how can I merge a string with a char?
07:47:39 <parcs> in what order?
07:47:46 <Nibble> string (merge) char
07:48:04 <aavogt> turn the Char into a string with [ char ]
07:48:10 <aavogt> then use ++ to combine the two
07:48:16 <rukav> "aa" =~ "(.*)\\1$" :: String
07:48:18 <Nibble> sounds simple enough
07:48:19 <mauke> why so simple? printf "%s%c"
07:48:38 <aavogt> that needs a type annotation sometimes mauke
07:49:21 <aavogt> also type-safety :)
07:49:40 <mauke> $(printf "%s%c")
07:49:44 <merijn> Is there a function like "[Chan a] -> IO a" which basically does readChan on all chan's in the list and returning the value of the first chan which has a message available?
07:50:02 <aavogt> a bit of overkill?
07:50:12 <mauke> can't have too much overkill
07:50:20 <aavogt> =)
07:50:33 <ddarius> merijn: No, but you could make one, though it would be much easier with TChans.
07:50:49 <Axman6> EXTRADEAD!
07:51:37 <merijn> Oh! I think I want TChans instead
07:52:04 <Twey> Woah
07:52:19 <Twey> Somebody gave haskell.org a speed boost
07:52:55 <Axman6> do { mv <- newEmptyMVar; mapM_ (\x -> forkIO $ readChan x >>= putMVar mv); takeMVar mv
07:53:07 <Axman6> uh, wiht xs
07:53:09 <Axman6> and }
07:53:37 <Twey> foldM orElse $ map read tchans?
07:53:37 <byorgey> hmm, the "recent package updates" on haskell.org are not very recent
07:53:37 <mauke> :t liftM (flip liftM (liftM return return)) (liftM (liftM join) (:))
07:53:38 <lambdabot> forall a. [a] -> a -> [a]
07:53:47 <merijn> ddarius: Would making one involve iterating over all of them doing "if not isEmptyChan then readChan else something"?
07:53:47 <aristid> :t orElse
07:53:48 <lambdabot> forall a. Maybe a -> Maybe a -> Maybe a
07:53:49 <ddarius> Axman6: That works if you want to actually read the channels, if you want to read the first one that's ready though...
07:53:56 <Twey> aristid: Not that one
07:54:05 <aristid> Twey: which, then?
07:54:24 <mauke> > liftM (flip liftM (liftM return return)) (liftM (liftM join) (:)) "aavog" 't'
07:54:25 <lambdabot>   "aavogt"
07:54:29 <mauke> yay, type safety
07:54:44 <Axman6> ddarius: assuming none of them are ready, that will read the first one that's ready
07:54:44 <aristid> mauke: that got to be the most complicated way two concatenate a string and a character
07:55:04 <ddarius> Axman6: That will read all of them regardless.
07:55:18 <mauke> @unpl liftM (flip liftM (liftM return return)) (liftM (liftM join) (:))
07:55:19 <lambdabot> liftM (\ c -> liftM c (liftM return return)) (liftM (liftM (\ e -> e >>= \ d -> d)) (:))
07:55:32 <mauke> :3
07:55:56 <ulfdoz> Aber die 848 w¸rde doch am besten zum Thinkpad passen. *grybl*
07:55:57 <Axman6> ddarius: well... yes? could add some more stuff to make it safer and not read from all of them, but it does do what was asked for ;)
07:55:59 <ulfdoz> ewin
07:56:22 <Nibble> uhm
07:56:25 <Nibble> parse cmd params =
07:56:26 <Nibble>     cmd ++ " " ++ (map (\x -> x ++ " ") params)
07:56:32 <aristid> ulfdoz: well, you should buy a Macbook Air
07:56:35 <Nibble> Couldn't match expected type `Char' against inferred type `[Char]'
07:56:36 <Axman6> Nibble: unwords?
07:56:36 <Nibble>     In the expression: x ++ "  "
07:56:44 <Twey> cmd ++ " " ++ map (++ " ") params
07:56:50 <Twey> unwords $ cmd : params
07:57:00 <ulfdoz> aristid: Not even as a gift, I prefer hardware, worth the price.
07:57:18 <Twey> parse = fmap unwords . (:)
07:57:30 <byorgey> Nibble: that ought to be  concat (map (...) params)
07:57:34 <merijn> Axman6: Hmm, with that solution I think I might as well scrap the separate channel and have every thread write directly into a single channel with a tag to indicate where its from. That might be easier anyway
07:57:35 <ulfdoz> On a macbook air, you cannot even put your coffee cup.
07:57:43 <byorgey> Nibble: but really you ought to use unwords like others have suggested
07:57:56 <Nibble> yeah, didn't know that function existed
07:58:01 <Axman6> merijn: yes, that's the w i'd go too, much nicer :0
07:58:03 <Axman6> :)*
07:58:40 <Axman6> > unwords ["this","is","a","test"]
07:58:41 <lambdabot>   "this is a test"
07:59:03 <Axman6> unwords . words can be quite useful
07:59:38 <aavogt> > lines "\n\n\nr\n\r\na\n\n"
07:59:39 <lambdabot>   ["","","","r","\r","a",""]
07:59:43 <merijn> Axman6: Oh! I think I can just as well replace "data GameEvent = forall a. (Event a) => GameEvent a" with "data GameEvent = forall a. (Event a) => In a | Out a" to solve my problem of communicating messages in and out :>
07:59:54 <aristid> > unwords . words " unwords . words can be quite useful,   says Axman6"
07:59:55 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
07:59:55 <lambdabot>         against inferred ty...
08:00:00 <aristid> > unwords . words $ " unwords . words can be quite useful, says Axman6"
08:00:01 <lambdabot>   "unwords . words can be quite useful, says Axman6"
08:00:29 <mauke> @check ap (==) (unwords . words)
08:00:30 <lambdabot>   "Falsifiable, after 339 tests:\n\"\\1070583\\222731\\495903\\1009547\\78164...
08:00:30 <Axman6> it's just a very simple way of stripping extra spaces
08:00:40 <mauke> @check ap (==) (unwords . words)
08:00:41 <lambdabot>   "OK, passed 500 tests."
08:00:43 <mauke> haha
08:00:57 <aristid> ulfdoz: well, be sure to get a SSD, then
08:01:08 <Twey> The perils of randomised testing ‚ò∫
08:01:18 <Axman6> > unwords . words $ "this     is type      by          a      mokey"
08:01:19 <lambdabot>   "this is type by a mokey"
08:01:27 <Axman6> there was a d there -_-
08:01:33 * Axman6 is drunk and should go to bed
08:01:35 <Nibble> What projects are you guys working on atm?
08:01:36 <aristid> Axman6 has just proven that he is a monkey (in Tokyo)
08:01:37 <ulfdoz> aristid: What for?
08:01:40 <Twey> Haha
08:01:44 <aristid> ulfdoz: speed?
08:01:53 <Twey> Axman6: What about the n?  ;)
08:01:57 <ulfdoz> aristid: I have 9h of battery life with a conventional harddisk, just saves 200EUR.
08:02:18 <ulfdoz> aristid: Speed? What for? 3GB RAM give quite good cache hits.
08:02:19 <mauke> "this is typen by a modkey"
08:02:21 * Axman6 directs Twey to his previous co0mment and goes to bed
08:02:44 <aristid> ulfdoz: you're such a typical SSD-and-Apple hater :P
08:03:03 <Axman6> 3GB? who doesn't have a power of 2 these days?
08:03:14 <aristid> Axman6: those with 32-bit operating systems perhaps?
08:03:17 <Maxdamantus> I have 3GB.
08:03:19 <ulfdoz> aristid: I had my apple time, I left MacOS disappointed after loosing my data twice.
08:03:26 <Maxdamantus> A pin on one of my slots is bent -_-
08:03:34 <Axman6> ... who has 32 bit operating systems these days?
08:03:43 <Axman6> merijn: weak :(
08:03:47 <aristid> ulfdoz: and yes, SSDs do give you a performance boost over 3 GB RAM, because even then not everything is always cached
08:03:53 <merijn> Axman6: What?
08:03:54 <Axman6> uh, Maxdamantus     
08:04:00 <merijn> Ah :p
08:04:04 <merijn> Tab fail :p
08:04:13 <Axman6> aye
08:04:21 <Axman6> ok, i'm going to sleep. night all
08:04:37 <ulfdoz> aristid: Its just not worth the money.
08:04:59 <ulfdoz> aristid: Give me 400GB SSD for 150EUR, and I buy one.
08:05:26 <ulfdoz> Until then, conventional HDDs are sufficient for my use cases.
08:05:28 <aristid> ulfdoz: the funny thing is, i have a 160 GB SSD and only use about 40 GB
08:05:41 <ulfdoz> aristid: I have 340GB HDD and use 300.
08:05:42 <unkanon> conventional hdd's are more reliable anyways
08:05:50 <aristid> ok, actually i use 48 GB now
08:05:50 <Nibble> no
08:05:51 <adrianlang> Does someone have experience with debian‚Äôs happstack packages? ghci doesn‚Äôt find the module Happstack.Server :/ 
08:05:53 <Nibble> unkanon: myth
08:05:59 <ulfdoz> unkanon: I started with backups this year. ;)
08:06:22 <unkanon> it's not a myth, it's just that ssd's haven't had enough time to prove themselves yet
08:06:27 <Nibble> unkanon: no
08:06:29 <ulfdoz> So basically I consider this a non-issue now.
08:06:30 <Nibble> myth
08:06:37 * sipa loves his 80GB SSD
08:06:39 <Nibble> unkanon: they are more reliable than regular hard drives
08:06:41 <jix> when you have a laptop and use it a lot on trains etc hdds fail one after the other
08:06:48 <Nibble> unkanon: since they have no moving parts
08:06:52 <unkanon> I don't believe that
08:06:56 <ulfdoz> jix: I never had a failing HDD.
08:07:01 <unkanon> that is the myth :)
08:07:08 <Nibble> right
08:07:16 <jix> ulfdoz: i had, several
08:07:19 <aristid> SSDs do exist for a while now
08:07:20 <sipa> i lost some 5 or 6 hard disks the past few years
08:07:26 <aristid> they just used to be EXTREMELY expensive
08:07:32 <sipa> two of them were my own fault though
08:07:32 <Nibble> SSDs have a longer lifespan
08:07:46 <ulfdoz> jix: Not even 1 in the last 10 years and I usually use them for at least 5 years.
08:07:46 <sipa> SSDs won't break by dropping them
08:07:47 <deech> Hi all, I am scheduled to give a talk on functional data structures to a bunch of imperative programmers. Are there any impressive examples you can point me to (not necessarily Haskell)?
08:07:49 <ddarius> Nibble: SSDs have different failure modes.
08:07:57 <sipa> but they will fail as well
08:07:57 <aristid> i think i lost a single hard disk, but that was an external hard disk that i put under quite intensive mechanical strain
08:07:59 <ulfdoz> sipa: I do not tend to drop my notebook.
08:08:01 <Nibble> ddarius: I know perfectly well what SSDs can fail from
08:08:11 <ulfdoz> That is not the intended use.
08:08:12 <Nibble> too many writes, for example
08:08:19 <Nibble> ulfdoz: it is
08:08:24 <sipa> advantage of SSDs: latency!
08:08:25 <Nibble> notebooks == they do get dropped
08:08:34 <Twey> deech: Maybe that lovely zipper filesystem?
08:08:37 <Nibble> advantage of SSDs: life expectancy!
08:08:38 <ulfdoz> Nibble: Never happened to me.
08:08:45 <Nibble> ulfdoz: good for you then
08:08:47 <Twey> http://lambda-the-ultimate.org/node/1036
08:09:02 <jix> also i want to be able to quickly grab my laptop... and i don't like the sounds hdds make when you do that...
08:09:08 <ulfdoz> But just assuming, HDD is broken than, how often can I do this, until I can buy one SSD with the same capacity?
08:09:19 <deech> Twey: Yeah, that one's pretty good. I've tried to understand that one many times.
08:09:46 <Taejo> :t fmap fmap fmap
08:09:47 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
08:10:27 <ddarius> deech: Why are you scheduled to give a talk on functional data structures?
08:10:35 <ulfdoz> jix: I do just that.
08:10:46 <deech> ddarius: Because I signed up for it. Why do you ask/
08:10:52 <Nibble> ddarius: He is just that awesome
08:10:59 <Nibble> You see him rollin
08:11:02 <Nibble> you hatin'
08:11:08 <aristid> ulfdoz: i once had a backup disk fail, which was a bit of a pain, because it was failing while trying to reinstall the computer that its backup data was from. fortunately my brother's data was not all that important
08:11:48 <ddarius> deech: Shouldn't you know what you are going to talk about before you agree to talk about it?
08:11:59 <Nibble> ddarius: I said
08:12:00 <merijn> Solution: Backup to Amazon S3 which probably has better redundancy then you :>
08:12:01 <aavogt> deech: you could look through chris okasaki's book/thesis
08:12:02 <Nibble> he is just that awesome
08:12:41 <deech> ddarius: I don't understand the Zipper file system, doesn't mean I don't get some of the simpler ones from Okasaki's book.
08:12:49 <aristid> merijn: yeah, when i reinstall, i want to have better backup now
08:13:12 <ddarius> deech: I wasn't talking about understanding.
08:13:43 <merijn> aristid: If you're working on *nix you might wanna take a look at Tarsnap
08:13:50 <Nibble> SNAP
08:14:16 <aristid> merijn: i currently use rdiff-backup
08:14:36 <merijn> It's a backup solution written by one of the FreeBSD security officers to do secure backups to Amazon S3, more expensive then direct S3 but at least you won't have to do all the complicated stuff yourself
08:15:09 <Nibble> what does amortized mean
08:15:22 <sipa> "averaged"
08:15:25 <ddarius> Make sure Amazon can't read all your porn.
08:15:33 <ddarius> @wn amortized
08:15:34 <lambdabot> No match for "amortized".
08:15:35 <ulfdoz> aristid: That is category of shit happens. But I have to think a long time back, when I was doing "re-install".
08:15:37 <aavogt> it's for bookkeeping
08:15:53 <aristid> ulfdoz: well, it was my brother's windows computer.
08:16:22 <deech> The goal is to take 40 mins to tell some imperative folks why functional data structures might be worth their time. 
08:16:34 <merijn> That's not going to work
08:16:39 <augur> wow
08:16:47 <merijn> You have to sucker them into doing functional programming without noticing it
08:16:53 <JuanDaugherty> give up
08:17:06 <deech> merijn: how?
08:17:06 <merijn> I'm working on a project like that atm :p
08:17:11 <dmwit> ?quote back.away
08:17:12 <lambdabot> No quotes match. The more you drive -- the dumber you get.
08:17:12 <augur> this channel gets quite active at about 10:30am est 0.0
08:17:17 <companion_cube> have them notice how boring can be copying structures
08:18:22 <deech> There's some pattern in Java where a function gives a new copy of the object passed in. Maybe I can use that as a springboard.
08:18:25 <dmwit> ?quote cjs moving away
08:18:25 <lambdabot> cjs says: I have to explain this shit to people. I mean, I start out right, "Hey, you know how you always have these bugs because what you thought was in the variable is not there?" And I get all of
08:18:25 <lambdabot> these nods of agreement. "Well, I've found a new language that solves that problem." Audience: "Ooooh! How?" Me: "There's no variables!" And then they all start moving away from me slowly....
08:18:45 <merijn> deech: I'm working on a project for data flow programming which is supposed to make parallelization easier. You just write "boxes" of code in any imperative language and then you hook the boxes together using stream combinators which lets the language handle the concurrency.
08:18:53 <dmwit> deech: Start that way. ;-)
08:18:55 <aristid> deech: maybe you should just give them a monad tutorial instead
08:19:13 <merijn> Of course these boxes really just behave like referentially transparent functions :p
08:19:34 <merijn> Which means our work of parallelizing them is fairly simple
08:19:38 <companion_cube> awesome quote, lambdabot 
08:20:22 <Aune> Hello, could someone explain to me what a monoid ring is?
08:20:40 <deech> merijn: nice.
08:20:52 <merijn> But as long as you call them boxes which get messages and send messages and the inside language is imperative no one notices you suckered them into functional programming ;)
08:20:54 <ddarius> merijn: And it's just up to the programmer to enforce referential transparency?
08:22:02 <merijn> ddarius: Yes, since we can't for example force a C function to be referentially transparent and you can code boxes in C. But that's not something which is easily solvable
08:22:17 <merijn> But baby steps are better then nothing
08:22:35 <medfly> Aune, #math or wikipedia
08:22:43 <deech> I try as much as possible to code that way.
08:22:47 <ddarius> Except that when they don't write referentially transparent functions, which is quite likely, things will go haywire.
08:22:57 <medfly> this channel thinks that mathematics should be explained through burritos...
08:23:09 <merijn> wikipedia is an awful source for math explanations
08:23:18 * ddarius wonders what the etymology of "haywire" is now.
08:23:26 <merijn> I recommend http://math.stackexchange.com/
08:23:40 <medfly> hay +‚Äé wire To go haywire  possibly originally referred to the tendency of wire spooled under tension and used in the baling of hay to spring into an unmanageable tangle once a piece had been removed from the factory spool, e.g., "he took off the back of his watch, removed a gear and the whole works went haywire" Or a tendency of slap-dash  repairs done with scraps of baling wire to fail catastrophically at times of mechanical stress. Perhaps the m
08:23:40 <medfly> eaning of haywire-- all in disarray or disrepair-- stems from this expression.
08:25:05 <Aune> medfly: thanks
08:25:12 <merijn> ddarius: I realize that, but I'm only a lowly master student so I don't get much say in the direction of an existing project and obviously forcing imperative people directly into a completely pure language has so far not worked out to great for functional programming :p
08:25:15 <duckinator> merijn: isn't the general format "<2-line explanation of something requiring a year to learn><TOC><overly-elaborate page explaining everything, including the color of <famous person related to article topic>'s underwear at the time of <awesome thing the person did>>"? :D
08:25:39 <duckinator> or something like that
08:26:10 <Twey> medfly: Burritos are the ultimate in explanatory abstractions.
08:26:26 <ddarius> merijn: Seems to have worked out overly well from my perspective.
08:26:59 <Nibble> hmm
08:27:00 <merijn> ddarius: Depends in which circles you hang out
08:27:02 <ddarius> As for the mainstream, I'd be happy with just a switch from mutable by default to immutable by default a la the MLs.
08:27:22 <merijn> Most of my fellow CS students seem to think Java is the end all, be all of programming languages
08:27:28 <ddarius> I think my perspective is mostly independent of the circles or other geometric figures I hang out in.
08:28:29 <merijn> Unfortunately I don't think learning to programming will ever be as popular as learning Java/C++/C#
08:29:36 <deech> merijn: At the masters level Java still holds sway? 
08:29:57 * ddarius wonders why convolution is so rarely written as a sum over x + y = t.
08:30:13 <merijn> For Software Engineering specialization (which seems the most popular one), yes
08:30:42 <deech> merijn: I see. I'm sorry.
08:31:52 <merijn> I'm doing High Performance Distributed Computing in which case its mostly C and (since I did a lot of theoretical stuff various formal verification languages)
08:31:55 <deech> Where I work we all appreciate functional programming languages, but accept that Java is paying the bills.
08:32:08 <companion_cube> you realize haskell has changed your way of programming when you end up writing combinators and monads in java...
08:32:10 <deech> Or more specifically, Java's tool support is paying the bills.
08:32:38 <deech> companion_cube: or just more interfaces.
08:33:00 <merijn> companion_cube: I barely do Java, but my functional C is quite pretty :)
08:33:07 <companion_cube> :)
08:33:26 <deech> merijn: Is there any reference for that? Or is that a style you've evolved?
08:33:34 <companion_cube> functional C seems easier than functional java
08:34:02 <merijn> It's a style I evolved. Recursive functions over data structures like lists/trees are quite easy in C
08:34:58 <companion_cube> did you define "immutable" structures ? 
08:35:19 <merijn> Didn't go that far
08:35:33 <merijn> Because then your code starts bloating again, C isn't really suited for that
08:35:56 <merijn> Although people in the research group here are work on true "functional C", the goal is to stick as close to C as possible but with immutable data (probably referential transparent too). It's aimed at high performance numeric work, vectors/matrices, etc
08:36:22 <merijn> It's called Single Assignment C, I think there's a demo available, but its not open source
08:36:23 <ddarius> See Single-Assignment C.
08:36:49 <ddarius> Single-Assignment C is more a successor to Sisal than a successor to C.
08:38:33 <Zao> By assignment, do they mean initialization?
08:38:51 <Zao> Oh wait, C. I expect that they're still hanging by the notion of declaring everything up-top?
08:39:03 <merijn> Zao: They mean no re-assignment of variables
08:39:15 <merijn> I.e. c =1; c = 2; would be an error
08:39:27 <Zao> I guess that the distinction between initialization and assignment is moot in C.
08:40:21 <deech> merijn: How much of a memory/performance hit do you take when you program this way?
08:40:26 <mauke> Zao: no and no
08:40:39 <mauke> Zao: C never had Pascal's "declare everything up-top"
08:41:08 <Zao> mauke: Last I looked at C89, you couldn't define any variables after statements.
08:41:15 <Zao> And as usual, no-one uses C99.
08:41:17 <mauke> not strictly true
08:41:34 <Zao> (you can open scopes and all, but you're still rather restricted)
08:41:35 <ddarius> Zao: You should read the tutorial.  As I said, this is a successor to Sisal not C.  It's not a C plus stuff.
08:41:38 <mauke> you can't define variables after statements *in the same block*
08:41:39 <merijn> deech: You mean recursive functions and lots of lists/trees? Not much, gcc supports tail call optimization and the code wasn't performance sensitive to notice anything for me
08:41:42 <ddarius> It's not even a C minus stuff.
08:41:55 <Zao> ddarius: Maybe they shouldn't have named it SA C then?
08:42:08 <deech> merijn: That's cool!
08:42:18 <Nibble> gcc is kinda cool
08:42:23 <Zao> mauke: You and I both know that's what I meant.
08:42:37 <Nibble> it automatically transforms some non tail recursive code into tail recursive code
08:42:44 <ddarius> Zao: It's basically a reskinning of Sisal (though they've definitely learned some stuff over the last two decades or so) purposely meant to be more appealing to imperative programmers.
08:43:04 <mauke> Zao: I don't!
08:43:07 <merijn> Nibble: clang and llvm are cooler, though
08:43:20 <mauke> also, I kind of hate Pascal since I had to code in Delphi
08:43:21 <Nibble> indeed
08:43:23 <Nibble> but not as fast yes
08:43:29 <ddarius> mauke: Sure you did.  Don't lie to us.  We know what you are thinking better than you know what you are thinking.
08:43:32 <Nibble> compiles a shitload faster tho
08:43:37 <merijn> Not as fast *yet*
08:43:46 <mauke> because Pascal *does* make you declare everything up top
08:43:58 <merijn> Considerable corporate backing is going into clang/llvm atm
08:45:40 <deech> And it's also awesome that GHC 7 generates LLVM code.
08:53:33 <LeCamarade> Failed to run the new GHC binary on FreeBSD.
08:53:35 <LeCamarade> :-(
08:53:48 <LeCamarade> Guess I"ll have to compile one meself.
08:55:02 <Zao> I wonder if I've tried that one yet.
08:55:22 <parcs> LeCamarade: what version?
08:55:37 <Zao> Did you read the notes on the download page?
08:55:48 * ddarius wonders if the old inliner bug has been fixed.
08:56:04 * ddarius assumes not or they probably would have mentioned it or at least removed mention of it from the docs.
08:57:26 <LeCamarade> 7.2-RELEASE.
08:57:53 <LeCamarade> I did read the install notes. I have an old GHC here.
08:58:19 <LeCamarade> I want to compile some SMPP library I've been using and release it, but it has to work with GHC 7 nicely.
08:59:05 <LeCamarade> I did it in the days before Unicode IO was incorporated.
09:00:27 <Zao> LeCamarade: So, what fails you?
09:01:37 * Zao installs math/gmp for great justice.
09:02:20 <LeCamarade> This:
09:02:24 <LeCamarade> ./configure
09:02:27 <Zao> (pastesites are nice)
09:02:40 <LeCamarade> checking for path to top of build tree... /libexec/ld-elf.so.1: Shared object "libutil.so.8" not found, required by "ghc-pwd"
09:02:41 <LeCamarade> configure: error: cannot determine current directory
09:02:58 <LeCamarade> Thought "it would be two lines, so why hpaste?"
09:03:09 <Zao> LeCamarade: We couldn't know that, now :D
09:03:10 <LeCamarade> Those three lines are the problem.
09:03:23 <LeCamarade> :-D
09:03:49 <LeCamarade> I have libutil installed from ports.
09:04:17 <Zao> Is /usr/local/lib in LD_LIBRARY_PATH?
09:04:37 <Zao> It's in base here on my 8.1, apparently
09:05:37 <LeCamarade> That ENV var is empty; I shall set it and try.
09:05:55 <Zao> I'm stuck on libgmp.so.10 which I just installed there.
09:07:03 <LeCamarade> Didn't work for me. :-(
09:09:23 <LeCamarade> Lemme go pick up corned beef from the shop and come back.
09:13:46 <merijn> LeCamarade: I recommend a visit to ##freebsd, they are quite helpful and there was a solution for these sort of linking/library problems but I forgot what
09:14:08 <Zao> I'm quite stumped why I can't get the linker to find the library..
09:14:24 <Zao> Motherlover...
09:14:28 <Zao> I grabbed the 32-bit package :D
09:15:39 <jmc_fr_> hello - very basic question. I'm doieng a module and want to import another one in it : haw can I do that ?
09:16:09 <merijn> jmc_fr_: Just do "import Module.Name"? 
09:16:09 <parcs> http://www.haskell.org/haskellwiki/Import
09:16:19 <Nibble> oh lol
09:16:31 <Nibble> oh loool
09:16:34 <Nibble> so
09:16:39 <Nibble> I am like trolling this guy
09:16:51 <Nibble> in one channel i am talking to him from this login
09:16:56 <Nibble> and in the other from a webchat
09:17:03 <Nibble> the other channel is his own
09:17:07 <mreh> > [] 3
09:17:08 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[a]'
09:17:09 <Nibble> he doesn't know that I am both
09:17:27 <Nibble> so I told him in the first channel that he should ask the person in the other channel if he like mudkipz
09:17:38 <Nibble> I, in the other channel
09:17:40 <ddarius> Congratulations, you've reached the humor level of a five year old.
09:17:45 <Nibble> answered yes. I love mudkipz
09:17:49 <jmc_fr_> merijn : already tried it, but I get an error message
09:17:51 <Nibble> then he wrote back in the first channel
09:17:51 <jmc_fr_> Book\Mark\GeorgiotImpair.hs:1:0:     File name does not match module name:     Saw: `Main'     Expected: `Book.Mark.GeorgiotImpair'
09:17:56 <Nibble> He said yes. 
09:18:02 <Nibble> He said I love mudkipz.
09:18:04 <jmc_fr_> and there is no "main" in my module ... ???
09:21:42 <mauke> jmc_fr_: what does your 'module' line say?
09:22:07 <jmc_fr_> mauke: import Book.DataStructure  module Book.Mark.GeorgiotImpair (analysedText) where  analysedText :: [ GroupOfWords ]
09:22:32 <mauke> wait, you can have 'module' after 'import'?
09:22:40 * roconnor doesn't quite see the point of Thirst
09:22:46 <jmc_fr_> mauke: and the Book.DataStructure module :
09:22:49 <jmc_fr_> mauke: module Book.DataStructure      (GroupOfWords     ) where
09:24:46 <mauke> you seriously have a 'module' after 'import'?
09:24:50 <mauke> what does that do?
09:25:09 <jmc_fr_> mauke: I think I got it : the right way is to do the import after the module
09:25:15 <augur> how does the haskell evaluator handle the global environment? presumably in some hiddenly mutable fashion, no?
09:25:29 <jmc_fr_> mauke: yes, seriously ... ;-) I'm a newbie
09:25:58 <jmc_fr_> mauke: tks, I think ts's ok now
09:26:18 <mauke> jmc_fr_: tk tks tkkkt sk
09:26:32 <jmc_fr_> mauke: ?????
09:26:32 <mauke> what language am I even speaking
09:26:38 <mauke> you started it!
09:26:49 <jmc_fr_> mauke: OK lol
09:27:01 <Paczesiowa> mauke: SKT calculus?
09:27:18 <mauke> I prefer HQ9+ calculus
09:28:56 <Mathnerd314> mauke: it's no good; you need a(n) FFI
09:33:24 <haikai> hi, someone knows an algorithm to detect if a string has contiguous  repeated substrings?
09:33:56 <merijn> haikai: Oh, that's fascinating problem
09:34:27 <haikai> merijn : how so?
09:34:40 <merijn> haikai: Because it sounds simple, but I think it isn't
09:34:52 <merijn> Especially since haskell can have infinite strings for example
09:35:19 <haikai> but how could I procede?
09:36:53 <merijn> I'm not entirely sure. How long are these strings, approximately?
09:37:06 <ddarius> haikai: You should write a specification.
09:37:50 <haikai> merijn: between 5 and 12 characteres
09:38:31 <mauke> (.+)\1
09:38:33 <merijn> In that case I'd probably try and implement some brute force which basically tries each possible prefix and sees if it's a match
09:38:39 <ddarius> Incidentally, any infinite string actually producable has contiguous repeated substrings.
09:39:08 <haikai> if I find a repeated substring I must reject, e.g., "telala"
09:39:22 <haikai> but not 123oi123
09:39:41 <mauke> > "telala" =~ "(.+)\\1" :: Bool
09:39:42 <lambdabot>   True
09:39:47 <mauke> > "123oi123" =~ "(.+)\\1" :: Bool
09:39:48 <lambdabot>   False
09:40:11 <remy_o> ddarius: why is it so ? 
09:40:34 <merijn> ddarius: Oh, I misread I though the entire string had to be contiguous repeated substrings
09:40:52 <haikai> is =~ a regular expression?
09:41:10 <mauke> no, it's an operator
09:42:17 <ddarius> I don't believe even the thing in the quotes isn't a regular expression.
09:42:21 <ddarius> s/isn't/is
09:43:14 <haikai> mauke: I meant if you used a regular expression
09:43:37 <mauke> no, but yes
09:44:00 <haikai> so, how does it work?
09:44:36 <mauke> it brute forces every combination and looks for a match
09:46:57 <haikai> what about =~ ? how does it work?
09:47:43 <sipa> :t (=~)
09:47:45 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
09:51:18 <haikai> ohh, now I understand
09:53:41 <jmc_fr_> hello. Is there a way to define a type  constructor in GHCi ? I mean, with a "data Tree a = Tip | Node a (Tree a) (Tree a)" I get a "<interactive>:1:0: parse error on input `data' "
09:54:27 <merijn> jmc_fr_: You can't, afaik. I usually just create a file which I edit then load the file into ghci
09:54:31 <sipa> i think you'll need to define it in a file, and load that
09:54:52 <jmc_fr_> merijn: OK tks
09:54:58 <jmc_fr_> sipa: OK tks too
10:07:18 <aavogt> is it possible to get path-dependent information using syb?
10:07:40 <aavogt> for example, you have     data Tree p a = Node p [Tree p a] | Tip a
10:08:08 <aavogt> then write a function using the data instance to give something that collects all the p from the root to the tip
10:08:25 <aavogt> so type:    Tree p a -> Tree p ([p],a)
10:08:54 <aavogt> I'm considering the use of an  everywhereM', defined much like the   everywhere'
10:09:55 <aavogt> but ideally the recursion is done with a modified environment like say  'local'
10:09:58 <aavogt> @type local
10:09:59 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
10:10:32 * aavogt guesses everywhereM' isn't the right shape
10:13:14 <aavogt> @src Mu
10:13:14 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
10:18:49 <roconnor> aavogt: I read something about that recently. In some paper with a title like up, down and sideways
10:18:59 <roconnor> but I don't remember the title well enough to find it
10:22:16 <ddarius> remy_o: To answer your question, all realizable machines are finite state machines so they must enter a cycle at some point.
10:23:00 <remy_o> ddarius: so you meant "infinite strings from Haskell"
10:23:03 <jmc_fr_> another newbie quastion : why does this lead to a type mismatch ? "1. data AB = A | B           2. data MaybeAorB = Maybe AB   3. a :: MaybeAorB               4. a = ( Just A )"
10:24:07 <sipa> your line 2 is invalid, i think
10:24:16 <sipa> you want a type declaration, not a data declaration there
10:24:23 <ddarius> remy_o: No, I meant infinite string producable by any physically realizable machine.
10:24:50 <ddarius> sipa: It's not invalid, it just doesn't mean what he thinks it means.
10:25:10 <sipa> true
10:25:23 <sipa> Maybe didn't exist as a data constructor before
10:25:49 <jmc_fr_> sipa: OK, tks
10:39:03 <sshc> Does Network.accept block until a connection is availlable?
10:39:18 <blackh> Yes, it does
10:44:30 * ddarius wonders what else it could do given its type.  Throw an exception?
10:44:33 * hackagebot xml-types 0.1.2 - Basic types for representing XML  http://hackage.haskell.org/package/xml-types-0.1.2 (JohnMillikin)
10:47:53 <monochrom> exception is the best thing since return value
10:53:17 <Shane__> let primeNum = listGen [2..] where {listGen (x:sx) = [n|n<-xs, (mod n x) /= 0, (x*x) < n]} in take 1001 primeNum
10:53:27 <Shane__> will that get calcuated a 1000 times?
10:54:03 <aavogt> xs isn't in scope
10:54:21 <Shane__> typo
10:54:32 <Shane__> let primeNum = listGen [2..] where {listGen (x:xs) = [n|n<-xs, (mod n x) /= 0, (x*x) < n]} in take 1001 primeNum
10:54:55 <Shane__> Im looking at the Haskell article and it saying that:
10:55:07 <Shane__> let primeNum = listGen [2..] where {listGen (x:xs) = [n|n<-xs, (mod n x) /= 0]} in take 1001 primeNum
10:55:19 <Shane__> gets calculated a 1000 times
10:55:31 <Shane__> *article on primes
10:57:36 <aavogt> is that actually productive as-is?
10:57:46 <aavogt> shouldn't you add x to the list being produced?
10:58:42 <Shane__> http://www.haskell.org/haskellwiki/Prime_numbers#Finding_Primes
11:00:19 <Shane__> yeah you are right
11:01:14 <Mathnerd314> aavogt: that problem (path-dependent info) is similar to my problem from yesterday. I have type Tree = Mu (p,Tree') and data Tree' a tree = Node [tree a] | Tip deriving Data; I think you can solve it from there
11:02:30 <Mathnerd314> s/Tree = Mu (p,Tree')/Tree a = Mu (p,Tree' a)
11:03:04 <aavogt> Mathnerd314: you did it with the Data instance?
11:03:25 <aavogt> I see how to do it for the specific type
11:03:59 <Mathnerd314> hmm, you probably just need a Functor instance
11:04:20 <aavogt> mostly I'm wondering if there's an appropriate combination of   gmapQ and gmapM  that gives a generally useful function for top-down path dependent info
11:05:07 <aavogt> Mathnerd314: p is forall'd?
11:05:51 <Mathnerd314> oh, it's another argument (latter one) to Tree
11:08:26 <aavogt> Mathnerd314: I'm going to need more explanation considering your typos
11:09:00 <Mathnerd314> aavogt: I'm too distracted by multirec to explain
11:23:22 <burp> how do I catch an Prelude.head empty list exception?
11:23:42 <sipa> you don't use head :)
11:23:48 <aavogt> @hackage spoon or don't use it
11:23:48 <lambdabot> http://hackage.haskell.org/package/spoon or don't use it
11:24:07 <burp> sipa: good answer, I think that's really the best :P
11:26:18 <Mathnerd314> sipa: how do you catch bottom?
11:26:41 <Mathnerd314> (e.g. running out of time)
11:28:34 <sipa> Mathnerd314: you are asking me how to solve the halting problem? ;)
11:29:16 <Mathnerd314> sipa: no, *a* halting problem (finite bound on time)
11:29:18 <aavogt> you can fork a thread and kill it when it doesn't give you the answer soon enough
11:29:43 <aavogt> > sum [1..] -- seems to have it implemented :)
11:29:49 <lambdabot>   mueval: ExitFailure 1
11:30:27 <dfrey> Is there a standard way to go from 1.23583957393 to "1.236".  In other words, I want to round a floating point number for display.
11:30:39 <unkanon> printf?
11:31:35 <aavogt> otherwise you can multiply by 10^n, round, then divide by 10^n
11:32:18 <dfrey> I will look at printf
11:32:35 <unkanon> dfrey: I wish I could show you right here with lambdabot how to use printf
11:32:41 <unkanon> but alas, I always forget how to use it
11:33:01 <adrianlang> > printf "%f.4" 0.12345
11:33:02 <lambdabot>   Ambiguous type variable `a' in the constraints:
11:33:02 <lambdabot>    `Text.Printf.PrintfType ...
11:33:11 <unkanon> all I know is your answer will have "%.3f" somewhere
11:33:41 <ben> > printf "%f.4" 0.12345 :: String
11:33:42 <lambdabot>   "0.12345.4"
11:33:44 <unkanon> > printf "%.2f" 1.23583957393 :: [Char]
11:33:44 <lambdabot>   "1.24"
11:33:54 <unkanon> > printf "%.3f" 1.23583957393 :: [Char]
11:33:54 <lambdabot>   "1.236"
11:33:58 <unkanon> that's it :)
11:34:08 <adrianlang> :)
11:34:14 <elliott> You can define foldl using foldr, right? (Ignoring efficiency, just theoretically.)
11:34:16 <elliott> I've forgotten how.
11:34:29 <unkanon> I thought it was the opposite?
11:34:48 <deadguys> I'm getting "Unsupported extension: PArr" trying to build ghc 7 from darcs.  any ideas how to get around it?
11:35:33 <unkanon> elliott: oh you're right
11:35:50 <unkanon> elliott: http://book.realworldhaskell.org/read/functional-programming.html
11:36:08 <unkanon> elliott: search for "write foldl using foldr" on that page
11:36:25 <elliott> unkanon: now that is not the kind of thing i would expect to see in RWH! :)
11:36:53 <dfrey> unkanon: thanks
11:37:02 <unkanon> dfrey: no problem
11:37:26 <unkanon> elliott: well yeah, that's the kind of thing I expect to see in Bird's Intro to Functional Programming
11:47:37 <Boxo> So have people thought of this way of doing typeclasses before? http://pastebin.com/6A1ZY9PW
11:47:56 <elliott> Boxo: Yes. At least I've written that MonadI structure at least once, I think.
11:48:14 <elliott> Yes, I definitely have.
11:49:42 <Boxo> Okay. I wanted to do typeclasses in Agda and that seems to be the way to go; works in haskell too...
11:50:14 <Saizan> Boxo: that's how typeclasses are implemented by GHC under the hood, and that's how it's usually done in Agda
11:50:59 <Saizan> the obvious drawback is that you lose the niceness of not having to manually specify which instance you want
11:51:54 <Saizan> (GHC also has a lot of optimizations to eliminate the indirection of accessing functions trough a record when possible)
11:54:22 <Boxo> and the gain is that you can have multiple instances
11:54:28 <Saizan> yep
11:55:04 <Saizan> in fact, the nearest thing are ML functors
11:55:19 <Boxo> There's all this crazy type hackery that embeds things like lists and numbers in the type system. It uses a lot of typeclasses. I wonder how it would be different with these special kinds of type classes.
11:56:31 <Saizan> those embeddings use the typeclass resolution machinery to perform computation at the type level, which is exactly the part that using records directly doesn't have
11:56:46 <Saizan> s/resolution/instance resolution/
11:57:33 <Saizan> though you can encode gadts that way
12:07:49 <Saizan> i sometimes use typeclasses only to build a gadt representation of the types involved, and then recurse over it to build various functions
12:07:51 <McManiaC> http://research.microsoft.com/en-us/um/people/simonpj/papers/list-comp/list-comp.pdf <- how do you read those semantics at page 6 ?
12:08:02 <Saizan> rather than trying to anticipate all the methods
12:09:34 <Saizan> McManiaC: figure 2?
12:09:37 <McManiaC> yeah
12:10:24 <McManiaC> oh, bottom to top?
12:10:55 <McManiaC> ah, nevermind, got it :)
12:11:24 <Saizan> good :)
12:11:57 <McManiaC> but I don't understand the forall in those group/order statements :>
12:12:04 <Mathnerd314> has anyone ever used multirec?
12:12:15 <Saizan> the boxes declare relations, the things with horizontal lines are rules that specify when they hold
12:13:11 <Saizan> McManiaC: that means that f has to be polymorphic in a
12:13:31 <McManiaC> yeah but I cant see why
12:17:13 <McManiaC> > [ x | x <- [1..10], then map (+1) ] -- why is that wrong?
12:17:14 <lambdabot>   Illegal transform or grouping list comprehension: use -XTransformListComp
12:17:33 <McManiaC> ok, besides that illegal transform error
12:18:13 <McManiaC> Could not deduce (Num a) from the context ()
12:18:14 <McManiaC> [..]
12:18:20 <McManiaC>  add (Num a) to the context of
12:18:21 <McManiaC>    the polymorphic type `forall a. [a] -> [a]'
12:18:48 <McManiaC> why isnt that typechecked as "[Int] -> [Int]" (if [1..10] :: [Int]) ?
12:19:20 <sipa> but [1..10] isn't [Int]
12:19:29 <sipa> it's forall a. Num a => [a]
12:19:41 <McManiaC> (if [1..10] :: [Int])
12:19:49 <McManiaC> pseudocode ;)
12:20:26 <Saizan> i guess because otherwise if you had two generators it'd have to take tuples
12:20:41 <McManiaC> even if it was forall a. Num a => [a], it should have a Num instance, but it's typechecked as "forall a2. [a2] -> [a2]", which is completly different
12:20:54 <elliott> Erm, what's the equivalent of right-fold on trees again? The inductive recursion scheme...
12:21:00 <elliott> (Trees as in Leaf X | Branch Tree Tree.)
12:21:20 <McManiaC> but whats the use of a plain "then" in a list comprehension then? everything I try fails
12:21:37 <Saizan> foldTree leaf branch (Leaf x) = leaf x; foldTree leaf branch (Branch x y) = branch x y
12:21:38 <McManiaC> (well, everything besides "const []")
12:21:51 <McManiaC> (and "id")
12:22:01 <unkanon> am I crazy or is the XOR example in the haskell neural network package wrong? : http://www.haskell.org/haskellwiki/HNN
12:22:05 <elliott> Saizan: erm are you *sure* about that? I notice a distinct lack of recursion
12:22:28 <Saizan> elliott: you're right
12:22:39 <elliott> :)
12:22:43 <Saizan> foldTree leaf branch (Leaf x) = leaf x; foldTree leaf branch (Branch x y) = branch (foldTree leaf branch x) (foldTree leaf branch y)
12:23:09 <elliott> Saizan: that's what I expected, thanks for making me sure :)
12:23:57 <Saizan> McManiaC: reverse ? :)
12:24:42 <McManiaC> Saizan: still, I cant see a reason why "map (+1)" shouldn't typecheck aswell
12:24:57 <McManiaC> just wondering if this could be generalized
12:25:02 <McManiaC> a bit more :)
12:26:09 <Saizan> then is not in the paper?
12:26:29 <McManiaC> nope
12:27:37 <McManiaC> TransformListComp uses "then f" "then f by e" "then group by e" "then group [by e] using f"
12:29:14 <Saizan> well, the type restriction might be there for readability, it ensures that f can only move or discard elements from the list in a parametric way
12:29:32 <McManiaC> the point is that I'm currently working on implementing these features for monad comprehensions, and there are very few functions which generalize to "forall a. Monad m => m a -> m a"
12:29:39 <Saizan> or it could be there to keep the types simpler
12:30:13 <McManiaC> (you couldn't even use reverse, take etc in that context)
12:30:37 <Saizan> you should allow m to be specified, and only enforce polymorphism on 'a'
12:30:42 <McManiaC> (maybe you could... hmm)
12:31:49 <McManiaC> Saizan: yeah, m is specified
12:32:08 <Saizan> in which case you can use reverse when m = []
12:32:26 <McManiaC> yeah
12:33:17 <Saizan> anyhow it seems possible in principle to allow f to be more specific
12:33:48 <Saizan> too bad the paper doesn't seem to explain that design decision
12:34:00 <McManiaC> yeah
12:34:11 <mreh> how do I derive MonadState s for all s?
12:34:22 <McManiaC> forall s. MonadState s =>
12:34:38 <mreh> I'm talking about generalized newtype deriving
12:34:41 <elliott> Saizan: hmm, is there a foldlTree then? I would guess no, but...
12:34:49 <McManiaC> (or just MonadState s => s a ...)
12:35:31 <Saizan> mreh: "MonadState s" gives an out of scope error?
12:36:44 <mreh> Saizan: a type mismatch error
12:37:11 <mreh> i'm deriving monadstate for a monad which has a fixed type, but MonadState s doesn't match that apparently
12:37:21 <mreh> fixed state type
12:37:47 <Saizan> then how should you be able to derive it for all s?
12:38:03 <mreh> because State is polymorphic
12:38:08 <mreh> *shrugs*
12:38:59 <Saizan> if you have newtype Foo a = Foo (State Bar a), how could you make a sane instance of MonadState s Foo ?
12:39:14 <Saizan> MonadState Bar Foo is fine
12:39:22 <ddarius> IKEA has a cute error picture: http://a4.g.akamai.net/f/4/25158/2m/ikeafailover.download.akamai.com/25158/holding/secure/ERROR_25.JPG
12:39:29 <Saizan> and "MonadState Bar" should work in a deriving clause
12:39:41 <McManiaC> ddarius: haha
12:40:35 <mreh> Saizan: fair point
12:42:35 <ddarius> Hmm, this barber shop might have won me over with a link to a 40 page PDF on "How to shave with a straight-edge" as the first thing on the site and a picture of acoustic guitars on the wall.
12:42:47 <mreh> my library for visualising DTDs is almost
12:43:39 <mreh> not a library
12:53:57 <ymasory> hi all. is there a good idiom/function for writing a list map when you also need the index and not just the element?
12:54:35 <ymasory> i would map over [1..(length lst - 1)] but then my map would be randomly accessing the list with !! and that's slow
12:55:06 <Liskni_si> you can map over zip list [1..] instead of list itself
12:55:28 <ymasory> oh excellent idea thank you Liskni_si
12:56:27 <aavogt> @ty zipWith 
12:56:28 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
12:59:21 <mreh> :t \f -> map (uncurry f) . zip
12:59:21 <lambdabot>     Couldn't match expected type `[(a, b)]'
12:59:21 <lambdabot>            against inferred type `[b1] -> [(a1, b1)]'
12:59:21 <lambdabot>     Probable cause: `zip' is applied to too few arguments
12:59:45 <mreh> :t \f -> (map (uncurry f) .) . zip
12:59:46 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
12:59:52 <mreh> woop
13:00:44 <Twey> Hmm
13:01:06 <Twey> :t \f -> (fmap . fmap) (uncurry f) . zip
13:01:06 <lambdabot> forall c a b. (a -> b -> c) -> [a] -> [b] -> [c]
13:02:09 <ddarius> :t zipWith [0..]
13:02:10 <lambdabot>     Couldn't match expected type `a -> b -> c'
13:02:11 <lambdabot>            against inferred type `[a1]'
13:02:11 <lambdabot>     In the first argument of `zipWith', namely `[0 .. ]'
13:02:20 <ddarius> :t flip zipWith [0..]
13:02:22 <lambdabot> forall a b c. (Num a, Enum a) => (a -> b -> c) -> [b] -> [c]
13:02:35 <mreh> :t (fmap . fmap)
13:02:36 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
13:02:47 <Twey> :t \f -> flip fmap zip $ (fmap . fmap) (uncurry f)
13:02:48 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
13:02:59 <Twey> :t \f -> flip fmap zip . fmap . fmap $ uncurry f
13:02:59 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
13:03:06 <Twey> :t flip fmap zip . fmap . fmap . uncurry
13:03:07 <lambdabot> forall b a b1. (a -> b1 -> b) -> [a] -> [b1] -> [b]
13:03:17 <mreh> this is like commuting patches
13:03:19 <aavogt> human @pl !
13:03:26 * Twey takes a bow.
13:03:56 <Twey> I enjoy deriving point-free versions of things
13:04:05 <Twey> At least when they come out nice
13:04:33 <ddarius> I enjoy writing in assembly code.
13:04:34 <mreh> don't you mean point-less?
13:04:39 <Twey> I think it's something every Haskeller should practise
13:04:58 <Twey> It imparts a good understanding of the language
13:05:46 <mreh> :t fmap fmap fmap
13:05:47 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
13:06:48 <mreh> can that be seen as a ternary function?
13:06:59 <mreh> f (f1 a)
13:07:43 <mreh> fmap fmap fmap (+1) (+) 1 2
13:07:48 <mreh> > fmap fmap fmap (+1) (+) 1 2
13:07:48 <lambdabot>   4
13:08:34 <Saizan> ternary requires 'a' to be a function type, or some newtype wrapping, i think
13:09:05 <applicative> @type liftM liftM liftM
13:09:06 <lambdabot> forall (m :: * -> *) a1 r (m1 :: * -> *). (Monad m, Monad m1) => (a1 -> r) -> m (m1 a1) -> m (m1 r)
13:09:36 <Saizan> (+) is binary though
13:09:51 <mreh> of course
13:12:23 <mreh> how could anyone find this confusing?!
13:12:56 <aristid> @type fmap fmap fmap
13:12:57 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
13:14:29 <mreh> am I learning abstract mathematics in no uncertain terms doing haskell?
13:15:07 <Renze> Good afternoon!
13:16:22 <Renze> Noob-question episode #2592 :(....: I'm trying to create a heap profile, but something goes wrong (and it went wrong a couple of weeks ago as well, but I don't know on which date so I can't look after it and I didn't documentate it..)
13:17:12 <Renze> I'm trying to run, after compiling it: Honderd +RTS -K100M -p -hc  (Honderd is the name of the file + module)
13:17:55 <ddarius> mreh: You're learning a little bit, but not too much.
13:18:41 <Renze> But GHC says I should built the program with -prof to use the flag -p, but I use -prof all the time... And it also says that -hc is a invalid heap profile, but that isn't correct, so I'm guessing I'm trying it in the wrong program or something like that...
13:26:55 <Renze> Found it myself :) thanks anyway
13:27:31 <unkanon> when I get an error saying I have a non-exhaustive pattern, can I have it tell me which pattern is missing?
13:28:57 <c_wraith> unkanon, it usually does tell you
13:29:05 <mreh> :t tell
13:29:05 <unkanon> I'm in ghci
13:29:05 <lambdabot> forall w (m :: * -> *). (MonadWriter w m) => w -> m ()
13:29:20 <c_wraith> oh.  I'm not sure if ghci will compile with extra warnings
13:29:53 <aavogt> you need to enable them with flags, which you can do like    :set -Wall
13:30:39 <aavogt> but something seems wrong if ghci says it's non-exhaustive but can't produce a failing input
13:31:59 <unkanon> hmm
13:37:23 * hackagebot http-enumerator 0.2.1.4 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.2.1.4 (MichaelSnoyman)
13:39:06 <deadguys> trapped in dependency hell.  anyone know how to tell why cabal insists on reinstalling a dependency?  presumably it needs to be built with a different version of shared dep, but I can't figure out which...
13:40:27 <lispy> deadguys: have you looked at the cabal FAQ?
13:40:52 <deadguys> lispy: nope.  checking now.
13:40:52 <lispy> deadguys: http://www.haskell.org/cabal/FAQ.html
13:45:14 <deadguys> lispy: doesn't seem to have my q
13:45:30 <ddarius> unkanon: You could also explore Catch.
13:46:09 <lispy> deadguys: hmm...I wish that page was a wiki, so we could add it
13:46:18 <unkanon> I'll take a look, right now I'm doing :set -Wall and undoing it with :set -w all the time
13:46:32 <lispy> ?tell dcoutts is it possible to turn http://www.haskell.org/cabal/FAQ.html into a wiki?  Seems like there are a lot of FAQs not answered there.
13:46:32 <lambdabot> Consider it noted.
13:46:42 <deadguys> lispy: it keeps wanting to install a dep from hackage, but I want it to use my local source.  I can't figure out how to build it the way it wants, or tell it to use my source tree
13:47:03 <lispy> deadguys: use --verbose=2 (or 3), and --dry-run
13:47:22 <lispy> deadguys: it should print more detailed info about install plans that way
13:48:25 <deadguys> lispy: it explains what it's going to do (install from hackage) and why it won't work.  but it doesn't say why the version I installed from source wasn't selected
13:49:59 <lispy> deadguys: okay, then add a --constraint="foo==..." to make your version be the one it should use
13:50:30 <lispy> deadguys: What package is this BTW?  a few packages have globally defined preferences on hackage that make them behave poorly
13:50:43 <lispy> deadguys: I forgot the URL but it's usually only 2-3 packages at any time
13:52:19 <lispy> deadguys: you might also want to ask in #cabal or #hackage
13:52:40 <lispy> deadguys: but, those channels are pretty quiet
13:54:39 <lispy> deadguys: I'm going to go read, good luck with it :)
13:54:54 <deadguys> lispy:  thanks
13:57:41 <aavogt> deadguys: is the dep also in global or per-user?
13:58:53 <aavogt> global packages can't depend on user-installed packages
13:59:56 <deadguys> aavogt: user i think
14:01:49 <aavogt> deadguys: everything using the  cabal  rather than the Setup.hs?
14:02:26 <deadguys> aavogt: yes
14:03:22 <aavogt> hmm, so that's not an issue. Follow lispy's suggestion then
14:11:32 <blehe> i'm playing around a bit with IO, but have gotten stuck on a problem: I read the contents from a directory using getDirectoryContents, and then try to filter out the files using filter. But get Couldn't match expected type `Bool' against inferred type `IO b'. Any ideas? :-) http://hpaste.org/42252/io_bool_problem
14:11:57 <mauke> :t isFile
14:11:58 <lambdabot> Not in scope: `isFile'
14:12:29 <mauke> what is isFile?
14:12:41 <aavogt> it produces an IO something
14:12:43 <blehe> woopsie, sorry. I made my own function that just calls doesFileExist 
14:12:57 <mauke> :t doesFileExist
14:12:58 <lambdabot> Not in scope: `doesFileExist'
14:13:07 <mauke> String -> IO Bool
14:13:12 <blehe> it's in System.Directory
14:13:13 <aavogt> I can suggest    files <- filterM isFile dirContents
14:13:13 <parcs> @type filterM
14:13:14 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
14:13:15 <mauke> :t filterM
14:13:16 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
14:13:22 <mauke> beat me to it
14:13:42 <blehe> monad? 
14:13:47 <blehe> what's that :-)
14:13:57 <mauke> ignore that part, just think 'IO' when you see 'm'
14:14:20 <mauke> filterM :: (a -> IO Bool) -> [a] -> IO [a]
14:14:28 <blehe> okay, thanks
14:14:29 <mauke> isFile :: String -> IO Bool
14:14:32 <shachaf> @quote a.monad.is
14:14:32 <lambdabot> thermoplyae says: <thermoplyae> someone finally pointed out to me that a monad is an monoid-object in an endofunctor category <thermoplyae> i have no idea how i've never seen that before
14:14:38 <mauke> filterM isFile :: [String] -> IO [String]
14:15:20 <mauke> blehe: sequence_ (map ...) is mapM_
14:16:06 <mauke> forM_ files (\x -> system $ unwords ["copy", show x, "backup"])
14:17:06 <Twey> Is roughly equivalent to system $ unwords ["copy", last files, "backup"]
14:17:11 <Twey> But slower ;)
14:17:12 <aavogt> what would be a good way to implement  Language.Haskell.TH.reify  for modules (since it doesn't handle those yet)? I'm considering    \modname -> runIO (readProcess "ghc" ["-e",":m + "++ modname, ":b "++modname]) -- are there better alternatives?
14:17:21 <shachaf> Also, watch out for files with spaces in their names and such.
14:17:42 <mauke> shachaf: show will put quotes around the names
14:17:59 <aavogt> uh, there should be some more -e flags
14:18:00 <Twey> Oh, right, show $ last files
14:18:31 <shachaf> mauke: They might have quotes in them also, and escaping isn't guaranteed to work the Haskell way.
14:18:36 <mauke> Twey: huh? why last?
14:18:52 <mauke> shachaf: that's true, but maybe windows disallows quotes in filenames?
14:18:59 <Twey> mauke: Because you're copying all the files over each other :√æ
14:19:00 <shachaf> mauke: Also, "copy" sounds like a DOS/Windows command, perhaps, and I'm not sure how that handles escaping in general.
14:19:06 <mauke> Twey: what if backup is a directory?
14:19:18 <mauke> shachaf: terrible
14:19:19 <Twey> mauke: I don't think ‚Äòcopy‚Äô does directories
14:19:21 <Twey> Could be wrong
14:19:29 <shachaf> mauke: Quite possible. But it's probably worth considering.
14:19:33 <Twey> It's been a while
14:20:05 <mauke> one of the help examples is: copy autoexec.bat c:\windows
14:20:28 <Twey> Guess it does, then
14:21:48 <shachaf> Ha, does Windows still check for autoexec.bat when booting these days?
14:22:30 <Twey> Yeah, think so
14:26:17 <Phantom_Hoover> @pl x >>= f = join (fmap f x)
14:26:18 <lambdabot> (line 1, column 9):
14:26:18 <lambdabot> unexpected "="
14:26:18 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<" or end of input
14:26:35 <Phantom_Hoover> @pl bind x f = join (fmap f x)
14:26:35 <lambdabot> bind = (join .) . flip fmap
14:26:55 <Twey> bind = fmap join . flip fmap
14:27:09 <Twey> :t fmap fmap fmap
14:27:10 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
14:29:28 * ddarius remembers the days of tweaking autoexec.bat and config.sys.
14:30:51 <c_wraith> buffers=20
14:31:03 <c_wraith> I never knew that that directive did
14:31:08 <c_wraith> Just that lots of games recommended it
14:34:38 <Twey> 22:28:11 < lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<" or end of input
14:34:54 <Twey> Does this mean that >>, >>=, =<<, >>>, ^>>, and ^<< are not operators?
14:36:59 <alpounet> jmcarthur, twitter account removed ?
14:50:33 <ddarius> Amount Owed: ($25.23), Yay.
14:51:31 <shachaf> @context ddarius
14:51:32 <lambdabot> Unknown command, try @list
14:56:37 <aristid> shachaf: context would just decrease the randomness
15:03:07 <ddarius> I don't think it needs context if you understand the notation.
15:03:18 <sshc> What is a good way to sleep (block / pause execution) for x milliseconds in Haskell?
15:04:15 <sshc> Is there a function that idles and blocks indefinitely that I can pair with System.Timeout.timeout?
15:04:27 <ddarius> threadDelay ?
15:05:04 <sshc> Ah, thanks
15:17:07 <darrint> Is there a function like bash dirname :: FilePath -> FilePath ?
15:17:45 <aavogt> @hackage filepath
15:17:46 <lambdabot> http://hackage.haskell.org/package/filepath
15:18:19 <aavogt> or did you look there already?
15:18:29 <mauke> my bash has no 'dirpath'
15:18:34 <mauke> what does it do?
15:18:41 <mauke> ergh
15:18:44 <mauke> I am teh stupid
15:19:10 <mauke> dropFileName
15:19:17 <darrint> Thanks.
15:19:42 <aavogt> slightly different
15:19:54 <mauke> takeDirectory?
15:20:00 <aavogt>  dropFileName "a/" == "a/"
15:20:19 <aavogt>  dirname "a/" == "."
15:21:44 <sipa> :t split
15:21:45 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
15:22:05 <ddarius> It's looking like I won't have to make a New Year's resolution to buy furniture.
15:23:00 <aavogt> so dirname  is closer to    init . splitPath
15:25:55 * hackagebot smallstring 0.2.0 - A Unicode text type, optimized for low memory overhead  http://hackage.haskell.org/package/smallstring-0.2.0 (AntoineLatter)
15:31:07 <sipa> is there a standard function like words, butwith a variable separator?
15:31:16 <mauke> intercalate
15:31:20 <mauke> OBVIOUS
15:31:51 <lispy> nub, intercalate, foldr, why can't people tell what these do just from the names? ;P
15:31:54 <unkanon> should be wordsBy, like nub -> nubBy
15:32:10 <mauke> I like those names
15:32:26 <lispy> actually, wordsBy and intercalate are totally different
15:32:31 <lispy> unwordsBy = intercalate
15:32:37 <mauke> whoops
15:32:48 <lispy> Yeah, maybe sipa wants something different
15:32:48 <mauke> words would be one of the split functions
15:32:58 <mauke> sipa: there's a Data.List.Split on hackage
15:34:33 <sipa> strange that it isn't included in Data.List in base
15:34:59 <unkanon> strange that words isn't implemented in terms of that
15:35:19 <sipa> indeed
15:36:00 <unkanon> one more thing to add to my mytools.hs :)
15:36:19 <ddarius> Data.List is essentially the List module from the Haskell 98 Report and so is at least twelve years old or so.  Data.List.Split is a package that was made a couple of years ago or less.
15:36:57 * hackagebot vty 4.6.0.2 - A simple terminal access library  http://hackage.haskell.org/package/vty-4.6.0.2 (CoreyOConnor)
15:38:49 <dons> where's the snap channel gone?
15:39:45 <Eduard_Munteanu> What's "snap"?
15:40:15 <ddarius> The fourth or fifth derivative of position with respect to time.
15:40:34 <Eduard_Munteanu> Heh, I knew only about 'jerk' and that stuff.
15:40:50 <Eduard_Munteanu> (that was the third, IIRC)
15:40:56 <ddarius> Yep
15:42:07 <parcs> apparently the fourth is jounce
15:43:15 <Eduard_Munteanu> It makes me wonder whether any of the next H' iterations will restructure Prelude to use more typeclasses. Or at least specify an alternate Prelude and deprecate this one.
15:44:08 <Eduard_Munteanu> Unfortunately Haskell got some popularity in the meanwhile :)
15:55:02 * hackagebot blaze-builder 0.2.1.0 - Efficient buffered output.  http://hackage.haskell.org/package/blaze-builder-0.2.1.0 (SimonMeier)
15:56:58 <applicative> dons, #snapframework ?
15:57:10 <hpc> Eduard_Munteanu: i hope so
15:57:10 <lambdabot> hpc: You have 1 new message. '/msg lambdabot @messages' to read it.
16:00:16 <Mathnerd314> @hoogle (a -> b, c -> d, e -> f) -> (a, c, e) -> (b, d, f)
16:00:16 <lambdabot> No results found
16:00:34 <Mathnerd314> @hoogle (a, c, e) -> (a -> b, c -> d, e -> f) -> (b, d, f)
16:00:35 <lambdabot> No results found
16:00:58 <aristid> :t \(f, g, h) (a, b, c) -> f a, g b, h c
16:00:58 <lambdabot> parse error on input `,'
16:01:05 <aristid> :t \(f, g, h) (a, b, c) -> (f a, g b, h c)
16:01:06 <lambdabot> forall t t1 t2 t3 t4 t5. (t -> t3, t1 -> t4, t2 -> t5) -> (t, t1, t2) -> (t3, t4, t5)
16:01:14 <aristid> @pl \(f, g, h) (a, b, c) -> (f a, g b, h c)
16:01:14 <lambdabot> (line 1, column 7):
16:01:14 <lambdabot> unexpected ","
16:01:14 <lambdabot> expecting letter or digit, operator or ")"
16:01:14 <lambdabot> ambiguous use of a non associative operator
16:01:34 <unkanon> @djinn (a -> b, c -> d, e -> f) -> (a, c, e) -> (b, d, f)
16:01:34 <lambdabot> f (a, b, c) (d, e, f) = (a d, b e, c f)
16:02:36 <Mathnerd314> but surely it's in a library *somewhere*...
16:03:04 * hackagebot blaze-builder-enumerator 0.2.0.0 - Enumeratees for the incremental conversion of builders to  bytestrings.  http://hackage.haskell.org/package/blaze-builder-enumerator-0.2.0.0 (SimonMeier)
16:03:23 <Cale> Mathnerd314: Tuples larger than pairs are a bit uncommon
16:04:11 <Mathnerd314> Cale: so why doesn't Haskell let ((a,b),c) = (a,(b,c)) = (a,b,c)?
16:04:38 <Cale> Those types aren't quite equivalent
16:04:42 <Cale> (they're close)
16:05:06 <sipa> Mathnerd314: (a,b,c) could be implemented as (a,(b,c)), comparable to lists, but that would be less expressive
16:05:39 <ezyang> New sigfpe! 
16:05:51 <Mathnerd314> Cale: right, I was just reading about that on Inside T5
16:06:14 <ezyang> boxes and diamonds remind me a lot of modal logic, and it looks like the relationship between the two is the same. 
16:06:51 <ezyang> Mathnerd314: I encourage you to draw the Hasse diagrams for those types :-) 
16:08:21 <ddarius> ezyang: Kripke multiple world semantics are the usual semantics for modal logics.
16:08:32 <ezyang> Ohhh 
16:08:38 <ezyang> Ok, so it is the same thing :-) 
16:08:53 <ezyang> or, I guess Kripke multiple worlds are more general. 
16:09:14 <ddarius> There is a short sweet paper about the accessibility relationship and how it relates to the corresponding modal logics somewhere.
16:09:48 <ezyang> ddarius: OOC, is the equivalence of Scott continuity and computability from Myhill and Sheperdson? 
16:09:59 <ezyang> ddarius: You keep citing papers and I keep failing to find them :-) 
16:10:14 <ezyang> I'm being bugged by your continuity computability comments from a few days ago too :-) 
16:10:21 <ddarius> I wouldn't be able to tell you with regards to the former.
16:10:34 <ddarius> Though you may want to look at synthetic topology and synthetic domain theory.
16:11:18 <ezyang> intriuiging. I assume that is one of the domain theories that achieves, erm, soundness, is it? 
16:11:46 * monochrom ‚ô• Kripke
16:12:33 <Mathnerd314> ezyang: better question, then: why doesn't Haskell let (a,b,c) = (!(a,b),c) = (a,!(b,c))
16:12:36 <ezyang> I feel like there is so little introductory material in this area. "No TAPL of denotational semantics" 
16:13:01 * applicative ? great Kripke too
16:13:10 <unkanon> is that the officer?  :P
16:13:13 * applicative but his unicode is messed up
16:13:33 * applicative thinks unkanon's joke was much employed in the 70's
16:13:43 <unkanon> aww... :)
16:14:30 <applicative> ddarius, you mean a short sweet paper by S K on accessibility relations?
16:14:40 <ezyang> Mathnerd314: Because that's not real syntax ;-) 
16:15:01 <applicative> http://sshieh.web.wesleyan.edu/wescourses/2007s/phil390/01/e-texts/Kripke/Kripke,%20Semantical%20Considerations%20on%20Modal%20Logic.pdf
16:15:06 <ezyang> gotta run. msg me if it is discovered 
16:15:11 <ezyang> oh, well, that works :-) 
16:15:33 <monochrom> haha great nickname shutdown_-h_now
16:15:35 * ezyang wishes he had a PDF copy of Kleene's intro to metamathematics 
16:17:18 <Mathnerd314> hmm, (!(a,b),c) ought to be real syntax
16:20:29 <applicative> here is Kripke's first possible worlds paper, http://tinyurl.com/28m49jb I think, looks like he was still a teenager.
16:22:34 <ddarius> I'll have to turn on my other laptop and see if Google Desktop can find it.
16:34:04 <jmcarthur> alpounet: no, it's just under a new name now. you should still be following me
16:34:24 <jmcarthur> alpounet: jacobmcarthur
16:34:41 <alpounet> oh ok
16:34:55 <alpounet> jmcarthur, any new for the project with conal and luke ?
16:38:06 <lars9> what's the best way to count number of distinct items of a list? using Data.Set ?
16:38:30 <parcs> @type length . nub
16:38:31 <lambdabot> forall a. (Eq a) => [a] -> Int
16:38:32 <unkanon> > length . nub
16:38:33 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> GHC.Types.Int)
16:38:33 <lambdabot>    arising f...
16:38:36 <adrianlang> Pity http://hackage.haskell.org/package/hs-twitter isn‚Äôt updated anymore :/
16:38:38 <unkanon> > length . nub $ [1,1,1,2,2,3,4]
16:38:39 <lambdabot>   4
16:38:59 <parcs> @type genericLength . nub
16:38:59 <lambdabot> forall b i. (Num i, Eq b) => [b] -> i
16:39:31 <Liskni_si> nub is O(n^2), isn't it?
16:39:34 <lars9> nub seems like O(N^2) to me
16:39:39 <parcs> @src nubBy
16:39:39 <lambdabot> nubBy eq []             =  []
16:39:39 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
16:39:43 <lars9> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/src/Data-List.html#nub
16:39:59 <Mathnerd314> @hoogle [(a,b)] -> ([a],[b])
16:40:00 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
16:40:00 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
16:40:09 <Mathnerd314> @hoogle [(a,b,c)] -> ([a],[b],[c])
16:40:09 <lambdabot> Prelude unzip3 :: [(a, b, c)] -> ([a], [b], [c])
16:40:09 <lambdabot> Data.List unzip3 :: [(a, b, c)] -> ([a], [b], [c])
16:40:50 <mreh> darcs revert doesn't delete files does it?
16:41:10 <Mathnerd314> try it and find out
16:41:22 <mreh> files that I'm currently working with, I don't care what it does to _darcs files
16:41:47 <mreh> I accidentally added all of my build
16:42:25 <dino-> mreh: Added but didn't record yet?
16:42:44 <dino-> revert discards unrecorded changes, so puts your "working copy" files back the way they are in the repo.
16:42:52 <dino-> Sounding like not what you want here
16:43:18 <mreh> dino- indeed, I just reverted, and unreverted
16:43:20 <mreh> phew
16:43:33 <aristid> preflex: seen merijn
16:43:33 <preflex>  merijn was last seen on #haskell 6 hours, 49 minutes and 6 seconds ago, saying: jmc_fr_: You can't, afaik. I usually just create a file which I edit then load the file into ghci
16:43:40 <dino-> So you have a pending add of things you don't want added?
16:43:50 <dino-> added but not yet recorded
16:43:50 <mreh> dino- yah
16:43:55 <mreh> yah
16:44:15 <dmwit> preflex: seen augustss
16:44:15 <preflex>  augustss was last seen on #haskell 41 days, 7 hours, 51 minutes and 19 seconds ago, saying: ddarius: and by induction, all finite numbers are nothing?
16:44:50 <mreh> darcs remove -r . did the trick
16:45:00 <dino-> I was just looking, forgot what to do about that.
16:46:25 <dino-> mreh: Aha, here it is, what you did, remove. Detailed with a pile of other things in this Best Practices page: http://darcs.net/manual/node5.html
16:48:02 <dino-> And actually `darcs remove -h` is very helpful about what it does, kind of opposite of add.
16:48:19 <dino-> I like that it has good docs built in.
16:49:45 <mreh> haskell tool command line is bliss
16:49:56 <mreh> cabal guesses what you might have meant to type
16:53:40 <mreh> and how does darcs know how to add files from a subdirectory into the right repo?
16:55:56 <unkanon> how do I lift a function f :: a -> a -> a into [a] -> [a] -> [a]?  fmap makes it [a] -> [a -> a]
16:56:15 <unkanon> I guess I have to use zipWith somehow
16:56:17 <mreh> :t zipWith
16:56:18 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
16:56:26 <mreh> just use zipWith
16:56:36 <unkanon> hmm why didnt it find that when I hoogled?
16:56:38 <mreh> the types check out
16:56:39 <unkanon> @hoogle (a -> a -> a) -> ([a] -> [a] -> [a])
16:56:39 <lambdabot> Prelude scanl :: (a -> b -> a) -> a -> [b] -> [a]
16:56:39 <lambdabot> Data.List scanl :: (a -> b -> a) -> a -> [b] -> [a]
16:56:39 <lambdabot> Prelude scanr :: (a -> b -> b) -> b -> [a] -> [b]
16:56:48 <unkanon> @hoogle (a -> a -> a) -> [a] -> [a] -> [a]
16:56:49 <lambdabot> Prelude scanl :: (a -> b -> a) -> a -> [b] -> [a]
16:56:49 <lambdabot> Data.List scanl :: (a -> b -> a) -> a -> [b] -> [a]
16:56:49 <lambdabot> Prelude scanr :: (a -> b -> b) -> b -> [a] -> [b]
16:56:53 <mreh> @more
16:57:02 <unkanon> I gotta be more generic I guess, and use different types
16:57:04 <unkanon> thanks :)
16:57:19 <mreh> anytime!
16:59:27 <mreh> apart from when I'm on vacation
17:00:16 <lispy> mreh: heh
17:00:22 <unkanon> that's unacceptable, please forward me your cellphone number when you're away
17:00:42 <mreh> I'm glad the job hasn't supplied me wth a cellphone
17:00:55 <mreh> that means they own my soul
17:01:19 <unkanon> you can always have your soul back momentarily by turning it off :)
17:02:59 <lispy> another brilliant blog post by sigfpe: http://blog.sigfpe.com/2010/12/generalising-godels-theorem-with.html
17:04:08 <mreh> the lock at work is a godel number
17:04:12 <mreh> on purpose...
17:06:28 <Saizan> so you just have to remember which sentence it encodes?
17:08:01 <mreh> yes, I've memorised the entire godel coding table
17:09:08 <mreh> that was rather extraverted thinking of you
17:10:05 <ddarius> +
17:11:46 <mreh> hmm, what could he mean?
17:12:17 <unkanon> I think it's the answer to a zen koan, it's up to us to find out which
17:14:51 <aristid> whoever got the idea of using an inefficient pseudo-quicksort to introduce people to the elegance of haskell should be punished :D
17:15:28 <mreh> it's effective
17:15:35 <unkanon> I just think of it as the elegance ofthe descriptiveness of functional thinking
17:16:35 <unkanon> one day computers will be fast enough that we'll only care about that emblematic quicksort
17:16:47 <unkanon> we'll only care about writing that version, I mean
17:18:22 <sshc> Is it possible to specify another package that conflicts with a cabal package?
17:23:13 <aristid> unkanon: i think there are more elegant sort algorithms
17:23:58 <sshc> It might be necessary to fix recursive dependencies.  For example, if there a bunch of packages that use distinct but similar types, and later another package that fixes the problem by generalizing with a type class, that package might depend on those packages.  Then, in the future, as that package becomes more standard and polished, it would be the base package (as it should) that doesn't depend
17:24:04 <sshc> on those existing packages that it did before, and now, instead, all the packages that are appropriate for the class, *including new ones*, now depend on that package.
17:28:08 <unkanon> aristid: that are easier to explain also?
17:28:46 <hpc> lispy: awesome post
17:30:36 <ddarius> unkanon: Computers will never be fast enough.
17:31:09 <unkanon> fast enough for what? for my puny self they've been fast enough for 10 years
17:32:58 <aristid> <unkanon> one day computers will be fast enough that we'll only care about that emblematic quicksort
17:33:34 <aristid> :t partitionEithers . zipWith ($) (cycle [Left, Right])
17:33:35 <lambdabot> forall b. [b] -> ([b], [b])
17:33:46 <aristid> @hoogle [a] -> ([a],  [a])
17:33:46 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
17:33:47 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
17:33:47 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
17:34:03 <unkanon> aristid: they'll never be fast enough for that, you think?
17:34:18 <aristid> unkanon: ddarius thinks so, and he's probably right
17:36:13 <aristid> now i'm wondering how to split a list into elements at odd and even positions most elegantly
17:36:20 <ddarius> The issue is that the amount of data we generate and need to process is rising significantly faster than our processing power.
17:36:36 <aristid> partitionEithers . zipWith ($) (cycle [Left, Right]) works, but i'm not sure if that's so nice
17:36:52 <aristid> plus, partitionEithers has that stupid bug
17:37:03 <hpc> @src partitionEithers
17:37:03 <lambdabot> Source not found. stty: unknown mode: doofus
17:37:37 <Saizan> which bug?
17:37:46 <aristid> Saizan: it can't deal with infinite lists
17:38:24 <aristid> at least in my version of GHC
17:39:15 <aristid> yeah, it has been fixed now
17:39:22 <aristid> but i still have GHC 6.12
17:40:28 <Saizan> :t foldr (either (first . (:)) (second . (:))) ([],[])
17:40:29 <lambdabot> forall a b. [Either a b] -> ([a], [b])
17:40:45 <hpc> :t partitionEIthers
17:40:46 <lambdabot> Not in scope: `partitionEIthers'
17:40:52 <Saizan> > foldr (either (first . (:)) (second . (:))) ([],[]) (repeat (Left ()))
17:40:53 <lambdabot>   ([(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(...
17:41:09 <aristid> > partitionEithers (repeat (Left ()))
17:41:10 <lambdabot>   *Exception: stack overflow
17:41:19 <aristid> lambdabot is not on GHC 7 it seems :)
17:41:31 <unkanon> ddarius: it'll probably reach a plateau one day
17:41:41 <unkanon> aristid: sorry I got confused for some reason
17:42:05 <aristid> unkanon: i'm constantly being confused by #haskell :)
17:42:34 <unkanon> heh
17:43:14 <ddarius> unkanon: Oh, it won't just reach a plateau, it will decline to nothingness.  However, it is likely that our processing power will do that at the same time if not earlier.  It certainly will do it at some point.
17:45:09 <aristid> now you're talking about points in time that are Pretty Far Away
17:45:10 <unkanon> but we're always throwing more cpus at the processing power problem
17:45:36 <aristid> unkanon: and we're always finding new uses for these new cpus!
17:47:06 <ddarius> Already much scientific data goes completely unanalyzed.
17:47:22 <unkanon> yes, and programming languages are slowly catching up to make use of all of the cpus
17:47:34 <hpc> ddarius: hell, much scientific effort goes into figuring out which data to discard
17:47:50 <parcs> note: don't run that code in ghci
17:47:55 <lars9> 
17:48:02 <unkanon> I think soon the increase of data will cease because we can only produce so much data. but we can always use more cpus
17:48:05 <hpc> parcs: couldn't ^C?
17:48:16 <ddarius> hpc: Indeed because we don't have the processing power to analyze it in a reasonable time frame (or at least we don't have enough processing power devoted to the task.)
17:48:24 <ddarius> hpc: However, that is somewhat unscientific.
17:48:50 <unkanon> ttyl guys, off to a date with the missus
17:48:55 <parcs> hpc: nope, the system was too busy swapping
17:49:13 <aristid> unkanon: but that doesn't mean we can afford to have terrible inefficiency. somewhat reduced raw processing efficiency in exchange for faster programming, OK, but not willfully throwing away multiple orders of magnitude
17:49:18 <hpc> i think at some point, we will bump up against the information limit
17:49:53 <ddarius> I think that point will come after we cease to exist.
17:49:56 <aristid> what's the complexity of that pseudo-quicksort, did anybody calculate that?
17:49:59 <hpc> as in, to make computers capable of processing more, we will concern ourselves with mass/entropy, instead of miniaturization or new techniques
17:50:29 <ddarius> aristid: The "real" quicksort is already worst-case O(n^2).
17:52:00 <aristid> ddarius: i'm not sure what you're trying to say. that quicksort is woefully inefficient?
17:52:40 <Draconx|Laptop> It's possible to achieve worst-case O(n lg n) quicksort by selecting your pivot carefully; although a random pivot is usually faster in practice.
17:52:41 <ddarius> aristid: That the pseudo-quicksort is not asymptotically worse than the real quicksort, at least as far as time is concerned.
17:53:04 <aristid> ddarius: i thought it might be due to the concatenations
17:53:34 <BarackOrrana> I need hackers?
17:53:47 <BarackOrrana> $$$$$$$$$$$$
17:54:27 <Axman6> %%%%%%%%%%%%!
17:54:36 <tg_zzz> > $$$
17:54:37 <lambdabot>   <no location info>: parse error on input `$$$'
17:55:32 <Axman6> :t ($) $ ($)
17:55:33 <lambdabot> forall a b. (a -> b) -> a -> b
17:55:58 <aristid> :t id id id
17:55:58 <lambdabot> forall a. a -> a
17:55:59 <parcs> @type fix ($)
17:56:00 <lambdabot> forall a b. a -> b
17:56:14 <aristid> > fix ($) (+1) 2
17:56:19 <lambdabot>   mueval: ExitFailure 1
17:56:26 <aristid> :t fix id
17:56:27 <lambdabot> forall a. a
17:56:59 <parcs> > (fix ($) `asTypeOf` id) 5
17:57:04 <lambdabot>   mueval: ExitFailure 1
17:57:09 <hpc> aristid: wtf is with the ExitFailure?
17:57:20 <hpc> is it a loop detection or something?
17:57:30 <aristid> hpc: i don't know, man
17:58:11 <hpc> i like how fix ($) :: a -> whoTheHellKnows
18:01:21 <Saizan> i think that's a killProcess from outside
18:02:36 <parcs> @type join . const
18:02:37 <lambdabot> forall a b. (b -> a) -> b -> a
18:02:42 <parcs> that's pretty neat
18:03:44 <aristid> :t join const
18:03:44 <lambdabot> forall a. a -> a
18:04:22 <hpc> oh i see, it's the same trick as fix id, only spookier
18:05:55 <Saizan> don't look too much into the bottom, or ..
18:06:50 <parcs> @type fix ($) `asTypeOf` const ()
18:06:51 <lambdabot> forall a. a -> ()
18:07:01 <parcs> > (fix ($) `asTypeOf` const ()) 5
18:07:05 <lambdabot>   mueval: ExitFailure 1
18:07:08 <parcs> :(
18:07:21 <hpc> Saizan: pandora opened the box and inflicted math upon the world; but in the _|_ of the box was unsafeCoerce :P
18:20:16 <zachk> > filterM (\x->[True,False]) [1..5] 
18:20:17 <lambdabot>   [[1,2,3,4,5],[1,2,3,4],[1,2,3,5],[1,2,3],[1,2,4,5],[1,2,4],[1,2,5],[1,2],[1...
18:21:01 <Axman6> :t filterM
18:21:02 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
18:21:03 <zachk> > filterM (\x->[True,False]) [1..3] 
18:21:04 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
18:21:36 <Axman6> @src filterM
18:21:36 <lambdabot> Source not found. Do you think like you type?
18:21:41 <Axman6> >_<
18:22:05 <aristid> ddarius: > filterM (const [False,True]) [1..3]
18:22:09 <aristid> > filterM (const [False,True]) [1..3]
18:22:10 <lambdabot>   [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
18:22:23 <aristid> sorry for the unintended highlight
18:23:20 <aristid> :t filterM
18:23:21 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
18:24:15 <aristid> > filterM (\x -> [x,not x]) [True,False]
18:24:15 <lambdabot>   [[True],[True,False],[],[False]]
18:26:00 <zachk> > filterM id [True,False] 
18:26:01 <lambdabot>   Couldn't match expected type `m GHC.Bool.Bool'
18:26:01 <lambdabot>         against inferred typ...
18:26:39 <dom96> @pl g(f(x))
18:26:39 <lambdabot> g (f x)
18:26:50 * hackagebot maude 0.1.0 - An interface to the Maude rewriting system.  http://hackage.haskell.org/package/maude-0.1.0 (DavidLazar)
18:27:17 <zachk> > filterM (\x->[x]) [True,False] 
18:27:18 <lambdabot>   [[True]]
18:27:53 <ddarius> > filterM return [True, False]
18:27:55 <lambdabot>   No instance for (GHC.Show.Show (m [GHC.Bool.Bool]))
18:27:55 <lambdabot>    arising from a use o...
18:30:16 <aristid> > filterM (\x -> [not x,x]) [True,False]
18:30:17 <lambdabot>   [[False],[],[True,False],[True]]
18:32:16 <aristid> > filterM (\x -> [x,x]) [True,False]
18:32:17 <lambdabot>   [[True],[True],[True],[True]]
18:32:28 <aristid> uh.
18:32:35 <aristid> > filterM (\x -> [x,x,x]) [True,False]
18:32:36 <lambdabot>   [[True],[True],[True],[True],[True],[True],[True],[True],[True]]
18:32:59 <aristid> > length $ filterM (\x -> [x,x,x]) [True,False]
18:33:00 <lambdabot>   9
18:33:03 <aristid> > length $ filterM (\x -> [x,x,x,x]) [True,False]
18:33:04 <lambdabot>   16
18:33:09 <aristid> > length $ filterM (\x -> [x,x,x,x,x]) [True,False]
18:33:10 <lambdabot>   25
18:33:32 <zachk> :t replicate 
18:33:33 <lambdabot> forall a. Int -> a -> [a]
18:33:38 <aristid> @oeis 1,4,9,16,25
18:33:38 <lambdabot>  Sequence not found.
18:33:54 <aristid> @oeis square
18:33:55 <lambdabot>  Sequence not found.
18:33:57 <zachk> length . replicate 8 oh my how would i do that :( 
18:34:26 <ddarius>  @oeis is (presumably) broken per the changes byorgey mentioned.
18:36:52 <aristid> :(
18:37:24 <aristid> > map (join (*)) [1..]
18:37:25 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
18:38:25 <aristid> > map (\n -> length $ filterM (\x -> replicate n x) [True,False])
18:38:26 <lambdabot>   Overlapping instances for GHC.Show.Show
18:38:26 <lambdabot>                              ([GHC....
18:38:40 <aristid> > map (\n -> length $ filterM (\x -> replicate n x) [True,False]) [1..]
18:38:41 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
18:38:49 <aristid> > map (\n -> length $ filterM (\x -> replicate n x) [True,False,False]) [1..]
18:38:53 <lambdabot>   mueval-core: Time limit exceeded
18:39:03 <aristid> > map (\n -> length $ filterM (\x -> replicate n x) [True,False,False]) [1]
18:39:03 <lambdabot>   [1]
18:39:08 <aristid> > map (\n -> length $ filterM (\x -> replicate n x) [True,False,False]) [1..5]
18:39:08 <lambdabot>   [1,8,27,64,125]
18:39:29 <aristid> > map (\n -> length $ filterM (\x -> replicate n x) [True]) [1..5]
18:39:30 <lambdabot>   [1,2,3,4,5]
18:39:40 <aristid> > map (\n -> length $ filterM (\x -> replicate n x) [True,True]) [1..5]
18:39:40 <lambdabot>   [1,4,9,16,25]
18:39:53 <aristid> > map (\n -> length $ filterM (\x -> replicate n x) [False]) [1..5]
18:39:54 <lambdabot>   [1,2,3,4,5]
18:41:55 <BarackOrrana> LEAKSPIN OPERATION, GO! http://www.youtube.com/watch?v=_AjZRYZwvFc
18:55:28 <jmcarthur> great, i didn't think about the leakspin stuff invading freenode
19:11:56 <Mathnerd314> what's the quick way to generate and print out a syntax tree with Template Haskell?
19:13:13 <ddarius> print
19:14:14 <Mathnerd314> in GHCi
19:18:13 <ddarius> Gtk2hs has a lot of modules.
19:19:18 <Mathnerd314> ddarius: print doesn't work; no instance for Show ExpQ
19:20:05 <ddarius> Mathnerd314: ExpQ is Q Exp.  Q is a monad.
19:20:25 <Mathnerd314> right...
19:20:42 <jmcarthur> check out runIO
19:21:11 <jmcarthur> err
19:21:26 <jmcarthur> runQ is what i think i meant
19:21:39 <c_wraith> probably
19:21:41 <Mathnerd314> ah, that works.
19:21:47 <c_wraith> runIO is IO a -> Q a
19:22:09 <jmcarthur> yeah runIO would be useful if you wanted to print the syntax tree during compilation
19:22:17 <jmcarthur> runQ for printing in a ghci session
19:22:53 * ddarius likes GHC 7.
19:23:20 * Mathnerd314 wishes the Haskell platform did rolling releases
19:23:49 <c_wraith> Prelude Language.Haskell.TH> runQ [| let x = 1 in x |]
19:23:49 <c_wraith> LetE [ValD (VarP x_1) (NormalB (LitE (IntegerL 1))) []] (VarE x_1)
19:23:58 <c_wraith> yeah, looks like runQ is what you want
19:24:28 <elliott> * Mathnerd314 wishes the Haskell platform did rolling releases
19:24:31 <elliott> that would achieve little, no?
19:24:40 <elliott> the whole point is to be a consistent platform that has been verified to work together nicely :)
19:24:41 <elliott> well, in theory
19:25:17 <Mathnerd314> elliott: the point is that they'd continuously make certain the "blessed" packages worked; i.e. that everything was compatible with GHC 7
19:25:36 <elliott> Mathnerd314: so much more work then :)
19:25:44 <Mathnerd314> elliott: right...
19:26:52 <Mathnerd314> elliott: but instead they do "every 6 months", and it doesn't sync up with GHC releases at all
19:27:13 <elliott> let's stop releasing software and just point people to git :)
19:27:15 <elliott> (i'm only half kidding)
19:27:45 <c_wraith> Mathnerd314, ghc7 isn't really stable yet.  They would have trouble making a platform release now if they wanted to.  Better to let things settle down
19:27:48 <Mathnerd314> git is slow compared to downloading binaries
19:27:57 <elliott> Mathnerd314: build bot!
19:28:02 <parcs> "This standalone GHC 7.0.1 release is aimed primarily at package maintainers and early adopters"
19:29:54 <mathstuf> hi, i was wondering the best way to have a function return data and a thunk to clean up the data later (temp files for example)
19:30:06 <mathstuf> my thought: do (dat, dtor) <- someFunc; doSomething dat; dtor
19:30:32 <Cale> mathstuf: another way is to have it take the continuation as a parameter
19:30:47 <Mathnerd314> c_wraith: the point is that the "blessed" libraries should be in-sync with GHC trunk, so that they could make platform releases
19:31:27 <c_wraith> Mathnerd314, I think it *is*, and you just don't understand.
19:31:42 <c_wraith> ghc 7 isn't for you.  (yet)
19:31:51 <c_wraith> It's the target for library maintainers to work with.
19:32:02 <c_wraith> When they get up to date, then the platform will be released.
19:32:04 <elliott> c_wraith: erm that seems silly to me
19:32:08 <c_wraith> Exactly as it should be
19:32:12 <elliott> "No, feeble user! The godly library maintainers and nobody else should use it!"
19:32:22 <c_wraith> elliott, that's what the release notes say :)
19:32:22 <elliott> Are there any known serious problems with GHC 7 at all, really?
19:32:29 <mathstuf> Cale: what would that look like?
19:32:37 <c_wraith> It changes the syntax for some stuff.  like QQ splices.
19:32:42 <elliott> c_wraith: I mean, anyone who *can* install GHC isn't going to find it hard to replicate the Haskell Platform, seeing as it's basically just a bunch of cabal installs away.
19:32:50 <c_wraith> So problems, no.  But it breaks packages.
19:32:51 <elliott> c_wraith: Sure, but every new release will do things like that.
19:33:15 <Cale> mathstuf: withResource f = do x <- acquireResource; v <- f x; releaseResource x; return v
19:33:26 <elliott> c_wraith: I just think that things like the Python 3 situation should be avoided, where it's completely neglected because of a catch-22 of "library maintainers need to support it first!" and "users don't use it so we're not migrating our library"
19:33:33 <c_wraith> elliot, if you think it's that easy, try even getting cabal-install to *build* on ghc 7 right now.
19:33:47 <mathstuf> Cale: ah
19:34:24 <c_wraith> elliott, that's what the platform is for.  To provide the effort to push a core of the libraries to update.
19:34:31 <Cale> mathstuf: There's Control.Exception.bracket which does this nicely and ensures that the resource is cleaned up even if there's an exception
19:34:46 <Cale> :t Control.Exception.bracket
19:34:47 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
19:34:50 <elliott> c_wraith: sure; i just don't think there's much reason not to use ghc 7 now really :)
19:34:59 <mathstuf> c_wraith: like this?
19:34:59 <elliott> having said that, i haven't used it at all.
19:35:00 <mathstuf> http://koji.fedoraproject.org/koji/buildinfo?buildID=207828
19:35:01 <elliott> so i may be totally wrong
19:35:41 <Cale> mathstuf: That's  "bracket acquire release thingToDo"
19:35:53 <ddarius> elliott: You can do whatever you want, just don't complain if it isn't all pretty.
19:36:16 <elliott> ddarius: But... but I want a well-typed pony.
19:36:23 <ddarius> @hackage pony
19:36:24 <lambdabot> http://hackage.haskell.org/package/pony
19:36:34 <elliott> Yaaaay
19:36:35 <ddarius> Builds on GHC 7.
19:36:41 <elliott> See, no reason not to use it!
19:37:27 <mathstuf> (<-- Fedora packager) ive hit a few things that dont compile on GHC7, but for the most part, things have been fine on rawhide builds
19:37:28 <ddarius> (Note that I cabal installed it between writing @hackage pony and saying it built.)
19:38:11 <elliott> mathstuf: ha ha enjoy your rpm :)
19:41:32 <hydo> Are there any tricks to providing an instance for a class for a given type aside from the newtype method?  I read the wiki article about orphaned instances, and the corresponding page about newtype, but I'm wondering if that's truly the extent of my choices.
19:42:24 <hydo> specifically, I want to send ObjectId in Data.Bson to a hstringtemplate template.. which involves deriving Data and Typeable and there's no Data instance for that type.
19:47:06 <applicative> hydo, i see ObjectId does have a derived Typeable instance.
19:49:22 <hydo> applicative: Right, but not a Data instance, which is my problem.
19:50:02 <applicative> what happens if you brazenly attempt to derive a Data instance with DeriveDataTypeable and StandaloneDeriving
19:50:22 <cch`> hi, how may I use Data.List.Stream? Just import it and hide relevant functions in Prelude ? I did so and get a much much worse performance
19:50:50 <hydo> StandaloneDeriving... i didn't know about that one.  I already use/have derivedatatypeable... let's see!  trying it now.
19:50:53 <ddarius> cch`: Are you compiling with optimizations?
19:51:33 <applicative> hydo, I don't have much experience with Data and Typeable, but here's Standalone... http://www.haskell.org/ghc/docs/latest/html/users_guide/deriving.html#stand-alone-deriving
19:51:44 <ddarius> Note that stand alone deriving is the same as making an orphan instance.
19:51:47 <cch`> I compile with -O2
19:51:59 <hydo> applicative: yep, reading the wiki article on it... I'll read that next.
19:52:28 <cch`> ddarius: actually: -prof  -auto-all -O2
19:52:37 <applicative> ddarius, the type in question might make it okay?  let me investigate
19:52:50 <hydo> Oh, well I tried making an orphan instance, but it's a major faux pas to write code here that doesn't compile cleanly.
19:53:06 <hydo> -Wall -werror, etc.
19:53:29 <applicative> ddarius, the type is introduced thus: data ObjectId = Oid Word32 Word64  deriving (Typeable, Eq, Ord)
19:53:40 <ddarius> applicative: That's irrelevant.
19:53:50 <applicative> how far wrong can hydo go?  I'm ignorant of Data.Data, it will be plain
19:54:42 <ddarius> applicative: The class and the type are irrelevant to my statement.  Stand-alone deriving just automatically makes an instance that he could write by hand.  It's an orphan instance no matter who writes it.
19:54:48 <applicative> ddarius, but if hydo writes a proper instance Data ObjectId where... there will be no chaos?
19:54:58 <applicative> right
19:55:38 <applicative> What should be done in such a case?  
19:55:58 <Saizan> cch`: tried timing without -prof? it adds a lot of overhead
19:55:58 <ddarius> applicative: He already stated the two options.
19:56:30 <Mathnerd314> the proper thing IMO is to rebuild the library with the Data instance
19:56:40 <applicative> if the author of data ObjectId = Oid Word32 Word64  deriving (Typeable, Eq, Ord) had added Data, there would be no problem.
19:56:41 <ddarius> For an application, orphan instances don't really matter much.  Worst-case scenario, one of your dependents adds the instance and you have to remove it from your code.
19:57:18 <ddarius> applicative: And if the author of data ObjectId had added instance MyAwesomeClass ObjectId there would be no problem.
19:57:19 <applicative> this is what I was thinking; it is a question how far hydo's module will go, so to speak.
19:57:41 <hydo> ddarius: Until that time, I guess I can ignore that warning.
19:58:09 <ddarius> If you are making a library, you really don't want to be defining instances for class and types you don't control.
19:58:55 <hydo> Naw, this is internal code... eventually I'll want to make and submit a patch to the bson package.
19:59:10 <hydo> In fact, that's probably a better approach come to think of it.
19:59:22 <cch`> Saizan: I tried without -prof, and still much much worse
19:59:33 <ddarius> Yes, for this it's best to ask the maintainer to update the package.
19:59:45 <ddarius> The general case gets sticky though.
19:59:53 <hydo> ddarius: Ok, i'll take the not-as-easy but better approach. :)
20:02:58 <applicative> cch` I don't know that Data.Stream.List is supposed necessarily to give better results than the usual ghc treatment of lists as it stands. It is a different approach.
20:04:33 <ddarius> It definitely doesn't.  There are some areas where it is notably worse.  And of course it doesn't change the list type.  You have to use the relevant functions to see any difference.
20:04:45 <applicative> cch` my experience hasn't been that it is slower, but that it hogs less memory;  but this is not the result of serious investigation. 
20:05:12 <Saizan> "much much worse" doesn't seem an expected outcome though
20:05:56 <applicative> yes, i was wondering if cch' was sticking something in the middle that would break the flow of the simplifications, or whatever one calls them, its escaping me
20:06:11 <ddarius> Saizan: Without code or even timings, there's not much basis for drawing any conclusions.
20:06:22 <cch`> I simply drop in Data.List.Stream
20:06:49 <applicative> cch` and you only use its own functions, not other list functions from around?
20:07:30 <cch`> applicative: yes, I hide every related list functions
20:07:37 <cch`> from Prelude
20:08:15 <cch`> the resulted executable use much more time and memory
20:08:37 * applicative thinks fusion rules, thats the word i was looking for....
20:09:51 <ddarius> Also note that the standard GHC list libraries also have (different) fusion rules which work pretty damn well.  If GHC was already doing a good job, you are not going to see any improvement in even the best case.
20:10:24 <applicative> cch`, Saizan and ddarius will know 100x more, but I think using Data.List.Stream is like another discipline of list programming with pitfalls like those facing the Prelude/Data.List one, but different
20:11:20 <applicative> cch` it's another brilliant scheme different from GHC's
20:12:40 <applicative> it is said that ghc 7 is better at using the fusion advice in statements of rules; maybe this would work to the advantage of Data.List.Stream
20:12:43 <applicative> ?
20:13:17 <cch`> I get a exponentially worse executation time 
20:14:23 <cch`> someday I may try GHC 7 to see
20:17:09 <applicative> cch` is the other path, using standard Data.List too slow too? 
20:19:51 <applicative> cch` it wouldn't surprise me that if there is much of a difference at all, it would turn out to be exponential in the end; clearly some of the Data.List.Stream rules arent 'firing' in your case, so you end up with unoptimized list programming somewhere...  -- something like that
20:19:53 <cch`> applicative: using standard Data.List get acceptable perforamance
20:20:36 <applicative> cch` I see.  
20:21:05 <cch`> applicative: the stream fusion docs say using stream fusion would not get worse result :)
20:21:35 <cch`> so I tried to use and get much worse one, so confused
20:23:56 <applicative> cch` this happened to me the first few times I used it.  it is easy unwittingly to do things that break the links theyre making for you. not that i'm expert at it now either :)
20:25:51 <ddarius> If none of the rules fired the difference wouldn't be "exponential" (which is a meaningless adjective without some variable)
20:26:08 <applicative> ddarius, of course. 
20:27:13 <applicative> ddarius, but the difference between unoptimized literal lambda reduction of list programs, and programs optimized by the ghc is likely to be extreme
20:27:59 <applicative> ddarius, similarly, the  difference between unoptimized literal lambda reduction of list programs, and those optimized with a smooth working of the stream fusion scheme will again be extreme. 
20:28:26 * applicative is working with a rather crude picture it is to be admitted
20:29:29 <ddarius> So use the word "extreme" rather than "exponential."
20:29:54 <applicative> cch` introduced the expression on the basis of actual timing
20:30:50 <ddarius> applicative: My words weren't directed at you alone, though, just because he used a term nonsensically is hardly reason to continue.
20:32:34 <applicative> ddarius, i take you point, i was just explaining why i used the word.  we should be dealing with cch` s disappointment, and how properly to think about a library like Data.List.Stream
20:33:43 <ddarius> applicative: If he would like us to actually help him in some way, he should post some code.  Heck, it would be nice if he even posted some timings so we'd have an idea of what "exponentially worse" actually meant.
20:34:10 <applicative> ddarius, indeed, i was approaching this a bit more indirectly
20:36:51 <applicative> cch` do you have a small test case that would show the disparity, that you could put on hpaste.org or whatever?
20:41:05 <applicative> cch` i have had had much better success with this simple semi-mechanical morphing of listy things by transmuting them to Data.Vector, especially Data.Vector.Unboxed, where possible. it is surprisingly simple if the case is right. 
20:42:47 <spacebar> I am trying to use c2hs and get an error saying:
20:43:04 <spacebar> c2hs: INTERNAL COMPILER ERROR:   CTrav.extractStruct: Illegal reference! Expected test_t at NodeInfo ("Test.chs.h",2,16) (Name {nameId = 4038}) to link to TagCD but refers to UndefCD
20:43:28 <jmcarthur> alpounet: we have been discussing it via email a bit. we haven't decided what to make yet
20:43:52 <jmcarthur> alpounet: sorry for the long waits between messages. things keep coming up
20:45:49 <cch`> applicative, ddarius: with exponentially I mean executing time is exponential to the list under manipulated
20:46:06 <jmcarthur> http://www.haskellers.com/jobs/ :(
20:46:34 <cch`> applicative, ddarius: a moment pls, let me try if I seperate out some test code
20:49:39 <zengr> hello 
20:49:51 <mdgeorge1> hello
20:49:59 <zengr> i am a java programmer from last 2yrs
20:50:11 <zengr> im planning to learn a functional programming
20:50:26 <djahandarie> jmcarthur, :(
20:50:30 <zengr> which one should i learn: scheme, lisp,, haskell or erlang
20:50:42 <mdgeorge1> I'm trying to install the numeric-prelude package from cabal on ubuntu.  I'm getting a lot of warnings about using base 3.x instead of 4.x
20:50:44 <mdgeorge1> is that a problem?
20:50:48 <zengr> can i get an unbiased answer? :P
20:50:50 <mdgeorge1> zengr: yes.
20:50:52 <mdgeorge1> :)
20:51:04 <spacebar> c->haskell is a PITA :-S
20:51:06 <aavogt> mdgeorge1: not yet
20:51:07 <gienah> spacebar: c2hs can be a little tricky at first, would probably need to see your code to have any chance of seeing how to tweak it to compile
20:51:23 <mdgeorge1> aavogt: can you elaborate please?
20:51:40 <aavogt> mdgeorge1: it means that code as-is won't compile with ghc-7
20:52:12 <spacebar> gienah: how do I marshal/unmarshal a struct timeval?
20:52:46 <mdgeorge1> I see.  If I'm just interested in solving my own problem for now and not interested in distributing it to a wider audience, I can just use what comes with ubuntu, using cabal to fill in the rest?
20:53:15 <mdgeorge1> I'm always wary about mixing package managers
20:53:47 <zengr> @mdgeorge1 i need to solve distributed computing problems
20:53:48 <lambdabot> Unknown command, try @list
20:54:21 <zengr> mdgeorge1: i need to solve distributed computing problems
20:54:23 <mdgeorge1> zengr: to be honest, I'm a bit of a novice with all of them
20:54:33 <mdgeorge1> but I think they're all really cool :)
20:55:00 <gienah> spacebar: I could try to do it if you like, but since I'm new to haskell it will take me at least 10 minutes :-)
20:55:11 <mdgeorge1> zengr: I'd be tempted to say erlang, since it's known to be well suited to that domani
20:55:28 <zengr> okay, thanks!
20:55:59 <spacebar> gienah: I was being lazy too. I was hoping there is an equivalent type in one of the libraries that I could use.
20:56:18 <spacebar> like I am using Network.Socket.HostAddress for in_addr_t
21:17:05 <gienah> spacebar: language-c required by c2hs fails to emerge on gentoo, I need to fix that first
21:26:07 <gienah> spacebar: I get the same INTERNAL COMPILER ERROR :-/
21:27:34 <gienah> spacebar: I wonder why. ghc has the CTime builtin type for time_t
22:04:09 <zeiris_> 
22:05:47 * hackagebot has 0.5.0.0 - Entity based records  http://hackage.haskell.org/package/has-0.5.0.0 (YusakuHashimoto)
22:21:20 <Chaze> argh, how do i write (\a -> map (* a) [1..]) point-free?
22:22:00 <ddarius> @pl \a -> map (* a) [1..]
22:22:00 <lambdabot> flip map [1..] . (*)
22:22:46 <Chaze> thx
22:28:06 <Chaze> @pl (\a -> map (* a) [1..]) point-free?
22:28:06 <lambdabot> (line 1, column 36):
22:28:06 <lambdabot> unexpected end of input
22:28:06 <lambdabot> expecting white space or simple term
22:28:12 <Chaze> @pl (\a -> map (* a) [1..])
22:28:13 <lambdabot> flip map [1..] . (*)
22:28:23 <Chaze> @pl (\a -> map (show . (* a)) [1..])
22:28:23 <lambdabot> flip map [1..] . (show .) . (*)
22:28:55 <Chaze> :t (show .)
22:28:56 <lambdabot> forall a (f :: * -> *). (Show a, Functor f) => f a -> f String
22:32:02 <Chaze> interesting: (show .) (+ 3) == (show) . (+ 3)
22:33:17 <danblick> I'm looking for documentation on Distribution.Simple.Test or how to run tests with Cabal 1.10.0 - does anyone know a place where I can find this?
22:38:20 <shachaf> Chaze: Interesting why? That's the definition of a section.
22:38:41 <Chaze> shachaf: a section?
22:39:47 <shachaf> Chaze: Yes. That's the (x .) or (. x) syntax.
22:40:55 <Chaze> in my head its more than a syntax difference, but i might be wrong
22:41:21 <shachaf> Chaze: (x .) y = (.) x y; (. y) x = (.) x y
22:41:24 <Jafet> > (1,,2,,3) 4 5
22:41:25 <lambdabot>   <no location info>: parse error on input `,'
22:43:19 <Chaze> still, the left hand side looks like a partial application of (.), and then an application of the resulting function
22:43:46 <aavogt> danblick: is that implemented, nevermind released, yet?
22:44:44 <danblick> aavogt: i'm not sure; looking into it.
23:04:36 <Chaze> why isn't this working:  liftM2 (==) id nub -- should be "contains no duplicates"
23:05:58 <aavogt> Chaze: have you an  import Control.Monad.Instances?
23:06:50 <Chaze> aavogt: now i did, didn't help
23:06:58 <Chaze> let test =  liftM2 (==) id nub
23:07:01 <aavogt> @ty liftM2 (==) id nub
23:07:01 <lambdabot> forall a. (Eq a) => [a] -> Bool
23:07:09 * Jafet hands aavogt the mind reading device
23:07:10 <Chaze> >  liftM2 (==) id nub
23:07:11 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> GHC.Bool.Bool)
23:07:11 <lambdabot>    arising f...
23:07:15 <aavogt> > liftM2 (==) id nub "aaa"
23:07:16 <lambdabot>   False
23:07:46 <Chaze>     Probable fix: give these definition(s) an explicit type signature
23:07:46 <Chaze>                   or use -XNoMonomorphismRestriction
23:07:56 <aavogt> > ap (==) nub "aaa"
23:07:56 <lambdabot>   False
23:08:31 <aavogt> Chaze: you could try the probable fix?
23:08:43 <Jafet> Use the second probable fix!
23:08:44 <Chaze> do i need that argument?
23:09:02 <aavogt> use ap instead since it's shorter
23:09:36 <Chaze> i don't really understand ap at this point :)
23:09:52 <aavogt> it's the same thing
23:09:54 <Jafet> ap == liftM2 const
23:10:17 <aavogt> not  liftM2 id?
23:10:25 <Jafet> Er, duh
23:10:26 <Chaze> :t const
23:10:27 <lambdabot> forall a b. a -> b -> a
23:10:39 <Jafet> @src ap
23:10:40 <lambdabot> ap = liftM2 id
23:10:45 <Chaze> what's the difference between const and id?
23:10:49 <Chaze> > const 42
23:10:50 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> t)
23:10:50 <lambdabot>    arising from a use of `...
23:11:05 <aavogt> $ for  id  makes more sense
23:11:16 <danblick> > const 42 "foo"
23:11:17 <lambdabot>   42
23:11:23 <Chaze> ah, i see
23:11:28 <aavogt> > id 42 "foo"
23:11:28 <lambdabot>   42
23:11:34 <aavogt> :)
23:12:18 <aavogt> but that's because   42  is allowed to stand for   const (42 :: Integer)
23:12:21 <danblick> huh? isn't that ($) 42 "foo" ?
23:12:26 <aavogt> since \bot is special
23:12:31 <Chaze> so does ap (==) nub exist as something named?
23:12:41 <aavogt> not likely
23:13:10 <Chaze> danblick: huh? that would be "apply foo to 42"
23:13:10 <aavogt> if you have Ord on the elements, you can have a faster implementation
23:13:31 <aavogt> apply 42 to "foo"
23:13:46 <Chaze> yes, that
23:13:55 <aavogt> > 42 "foo"
23:13:55 <danblick> aavogt: could you clarify when 42 stands for const (42 :: Integer)?
23:13:56 <lambdabot>   42
23:14:10 <aavogt> > (42 :: a -> Integer) "foo"
23:14:10 <lambdabot>   42
23:14:23 <danblick> > ($) 42 "foo"
23:14:24 <lambdabot>   42
23:14:36 <djahandarie> > (flip id) 42 "foo"
23:14:37 <lambdabot>   Couldn't match expected type `a -> b'
23:14:37 <lambdabot>         against inferred type `[GHC.T...
23:14:46 <aavogt> danblick: people are free to write additional Num instances
23:16:32 <aavogt> danblick: so ghc picks the     instance Num n => Num (a -> n), to make things work, according to the normal rules for instance selection
23:17:06 <danblick> ah, ok
23:17:12 <aavogt> which more or less involve matching up the (->)
23:18:11 <danblick> and lambdabot always uses instance Num n => Num (a -> n)?
23:18:12 <aavogt> then verifying that  a  and the  n  can actually be made to agree with whatever other constraints exist on the types there
23:18:29 <Jafet> @instances-importing Data.NumInstances Num
23:18:30 <lambdabot> (a -> b), (a, b), (a, b, c), (a, b, c, d), Double, Float, Int, Integer
23:18:43 <Jafet> Goddamn linear algebraists
23:19:48 <danblick> thanks, that makes sense
23:19:54 <aavogt> danblick: what do you mean by always here? Instance selection isn't random and tends not to be very complicated (at least without serious ghc extensions)
23:22:34 <danblick> sorry, what i'm trying to say by "lambdabot always uses this instance..." is something like "lambdabot evaluates expressions in an environment where this instance is declared"
23:23:25 <aavogt> yes
