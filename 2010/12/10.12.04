00:00:09 <sohum> yepyep. makes sense
00:06:40 <ddarius> preflex: seen copumpkin
00:06:40 <preflex>  copumpkin was last seen on #haskell 1 day, 3 hours, 50 minutes and 39 seconds ago, saying: only dumb ones
00:06:54 <Axman6> preflex: seen conal
00:06:55 <preflex>  conal was last seen on #haskell 10 hours, 2 minutes and 43 seconds ago, saying: function-level programming leads to lots of redundant computation w/o cse. since the sharable values cannot be named.
00:07:08 <ddarius> preflex: seen pumpkin
00:07:08 <preflex>  pumpkin was last seen on #haskell 4 days, 5 hours, 49 minutes and 37 seconds ago, saying: liyang: she isn't very general
00:10:02 <ajnsit> What's the simplest way of converting a Maybe (IO a) to IO (Maybe a) ?
00:10:39 <dolio> @type Data.Traversable.sequence :: Maybe (IO a) -> IO (Maybe a)
00:10:40 <lambdabot> forall a. Maybe (IO a) -> IO (Maybe a)
00:10:46 <mauke> :t maybe (return Nothing) (fmap Just)
00:10:47 <lambdabot> forall a (m :: * -> *). (Monad m, Functor m) => Maybe (m a) -> m (Maybe a)
00:11:13 <ajnsit> ah thanks!
00:11:24 <ajnsit> I was messing around with fmap!
00:13:40 <Evious> @faq Can Haskell do code hot-swapping on running processes like Erlang?
00:13:40 <lambdabot> The answer is: Yes! Haskell can do that.
00:14:06 <shachaf> @faq Can Haskell do code hot-swapping on processes running Erlang?
00:14:07 <lambdabot> The answer is: Yes! Haskell can do that.
00:14:41 <Xilon> @faq Can Haskell make pigs fly?
00:14:41 <lambdabot> The answer is: Yes! Haskell can do that.
00:15:12 <ajnsit> ha ha
00:15:29 <ManateeLazyCat> @faq Can haskell let lambdabot shut up?
00:15:29 <lambdabot> The answer is: Yes! Haskell can do that.
00:15:54 <ManateeLazyCat> Evious: Hi. :)
00:16:03 <Evious> :)
00:17:58 <ajnsit> how about the other way - from IO (Maybe a) to Maybe (IO a)?
00:18:24 <shachaf> ajnsit: Not really possible.
00:18:41 <ajnsit> shachaf, why?
00:18:58 <mauke> :t \y -> Just (do Just x <- y; return x)
00:18:59 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (Maybe b) -> Maybe (m b)
00:19:02 <Eduard_Munteanu> Because it's like an unsafePerformIO
00:19:08 <shachaf> ajnsit: How will you know whether it's a Just or a Nothing without running the IO action?
00:19:09 <mauke> no, it's an unsafePerformMaybe
00:19:17 <Eduard_Munteanu> :)
00:19:29 <mauke> hah, even better
00:19:30 <Cale> Just . fmap fromJust
00:19:34 <ajnsit> shachaf, okay makes sense
00:19:41 <shachaf> Fine, it's possible, but not in the sense that you want it.
00:19:44 * ddarius thinks he'll start working on another mote simulator.
00:19:49 <mauke> :t const Nothing :: IO (Maybe a) -> Maybe (IO a)
00:19:50 <lambdabot> forall a. IO (Maybe a) -> Maybe (IO a)
00:20:12 <Eduard_Munteanu> :t Just . fmap fromJust
00:20:13 <lambdabot> forall a (f :: * -> *). (Functor f) => f (Maybe a) -> Maybe (f a)
00:21:09 <Eduard_Munteanu> ddarius: what's that?
00:21:37 <ddarius> Semantics, shmantics.  Who needs those?
00:22:22 <ddarius> Eduard_Munteanu: Look up Butera's thesis.
00:23:34 <xpika> which version of readline do i need to install the hacakge package readline?
00:28:05 <mjrosenb> @unpl (\x -> (x, f x))
00:28:05 <lambdabot> (\ x -> (x, f x))
00:28:13 <mjrosenb> @pl (\x -> (x, f x))
00:28:13 <lambdabot> ap (,) f
00:28:27 <mjrosenb> @pl (\x -> (f x, x))
00:28:27 <lambdabot> (,) =<< f
00:31:33 * ddarius should just pay for an ACM subscription...
00:32:12 <ulfdoz> Apply at a university and get ACM for free. ;)
00:34:08 <Eduard_Munteanu> I had one, but unfortunately it didn't cover the library.
00:34:30 <Eduard_Munteanu> Which I think is pretty much the point of an ACM subscription.
00:34:45 <ddarius> ulfdoz: Well, since I'll probably be a member of multiple universities in the near future (and may actually currently be), that doesn't seem imprudent.
00:34:55 <moozilla> possibly a dumb question: is there an equivalent to short in haskell?
00:35:12 <ddarius> There is a library of fixed sized types, e.g. Word16.
00:35:15 <Eduard_Munteanu> moozilla: see Word16.
00:35:37 <moozilla> isn't that unsigned?
00:35:42 <Eduard_Munteanu> Yeah.
00:35:44 <ddarius> There is Int16 too.
00:35:51 <moozilla> oh okay
00:36:14 <moozilla> is Int the same as Int32?
00:36:22 <moozilla> or more arbitrary?
00:36:30 <ulfdoz> Eduard_Munteanu: When I was at university, the library had full access to ACM via static IP-addresses.
00:36:34 <ddarius> No, it isn't.
00:36:39 <mauke> moozilla: Int is the "native" int type
00:36:44 <ddarius> It's required by the Report to be at least 29 bits.
00:37:11 <Eduard_Munteanu> ulfdoz: ah no, they gave us a free 1y subscription during GSoC.
00:37:13 <ddarius> (or is it 30?)
00:37:50 <moozilla> how can I convert from Int to Int16?
00:37:55 <mauke> fromIntegral
00:37:56 <Eduard_Munteanu> ulfdoz: you had access to some free books, some materials and such, but not the full digital library.
00:38:38 <ulfdoz> Eduard_Munteanu: That sounds rather suboptimal.
00:38:54 <moozilla> is there a more general version of length I could use?
00:39:01 <ddarius> :t genericLength
00:39:02 <lambdabot> forall b i. (Num i) => [b] -> i
00:39:11 <moozilla> thanks
00:39:33 <Eduard_Munteanu> OTOH people could just publish their damned articles on some free archives, like arXiv.
00:40:06 <Eduard_Munteanu> Do they even get anything out of publishing to stuff like ACM?
00:40:07 <ulfdoz> Eduard_Munteanu: Full ack. Especially if already paid by taxes.
00:40:29 <Eduard_Munteanu> I think they just collect articles from various sources and charge for them.
00:40:59 <ddarius> You usually can find articles online for free, usually from the author's site.
00:41:07 <ddarius> (At least in CS.)
00:41:08 <ulfdoz> Eduard_Munteanu: They are not much more then a usual publisher.
00:41:20 <moozilla> @type genericLength "test" :: Int16
00:41:21 <lambdabot> Int16
00:41:32 <Eduard_Munteanu> Yeah, at least regarding Haskell articles, I was able to find almost all of them freely.
00:43:12 <moozilla> wait, is there an easy way I can turn an Int16 into a [Word8] ?
00:43:13 <Eduard_Munteanu> s/Haskell/functional programming/
00:43:17 <ulfdoz> moozilla: Except, when you are short on memory or interface with native code, there is usually no win in messing around with "non-common" types. An Int does equally well as an Int16 in 99% of the cases.
00:43:38 <moozilla> ulfdoz, the problem is I'm working on interpreting a protocol
00:43:43 <moozilla> and it requires specific sizes
00:43:57 <Eduard_Munteanu> moozilla: then you should use bit operations to do so.
00:44:00 <Axman6> moozilla: then you're using the wrong tools
00:44:02 <Eduard_Munteanu> You probably need them anyway.
00:44:17 <Eduard_Munteanu> Yeah, and signed integers are bad for that.
00:44:18 <Axman6> you should be using something like Data.Binary, or the cereal package
00:44:28 <Axman6> or attoparsec
00:44:46 <Axman6> haskell has some great binary parsing libraries, you should be using them
00:45:03 <moozilla> I'm worried they are a bit over my head :P
00:45:06 <mauke> moozilla: protocols require bytes, not Int16
00:45:15 <Axman6> they're extremely simple
00:45:20 <moozilla> I've been using ByteStrings
00:45:48 <Axman6> these binary parsing libraries are for parsing, among other thing, protocols in ByteStrings
00:46:25 <moozilla> Axman6, which do you recommend? I shouldn't need to do any bit operations
00:46:30 <ulfdoz> moozilla: There is no reason to extract a 16bit field different from a 32bit field. ;) For example a generic function could extract you signed or unsigned numbers e.g. get_uint :: Int -> BitStream -> IO Integer
00:47:00 <ulfdoz> Where the first arguemnt may be the length of the field in bits or bytes.
00:47:10 <moozilla> I'm trying to construct a specific packet to send
00:47:37 <moozilla> the string is a UTF8 string prefixed by the length as a short
00:47:55 <c_wraith> what byte order?
00:48:12 <moozilla> big endian
00:48:23 <c_wraith> well, at least it's specified properly :)
00:48:24 <Eduard_Munteanu> Data.Binary already reads that in BE.
00:50:31 <bl^ckh0le> my GHC complains that it cannot find module `System'
00:50:35 <bl^ckh0le> wtf?
00:51:00 <bl^ckh0le> can anybody shed some light on this?
00:54:43 <bl^ckh0le> err...guys?
00:55:59 <bl^ckh0le> http://pastie.org/1346654
00:56:35 <Veinor> bl^ckh0le: could you post the error message?
00:56:39 <Axman6> how did you install it? has it worked before? what did you to before it stopped working?
00:57:16 <bl^ckh0le> Axman6: I installed it using the precompiled GHC 7
00:58:05 <bl^ckh0le> um...standard ./configure --prefix=/usr && make && sudo <pkgmgr> -lp ghc-7.0.1 -- make install
00:58:12 <bl^ckh0le> then this...
00:58:26 <Axman6> prefix=/usr? :\ that's asking for trouble
00:58:35 <Axman6> though probably not this trouble
00:58:46 <bl^ckh0le> System/Directory.hs:87:8:
00:58:46 <bl^ckh0le>     Could not find module `System':
00:58:47 <bl^ckh0le>       Use -v to see a list of the files searched for.
00:59:14 <bl^ckh0le> Axman6: what? no, I removed the old precompiled GHC before installing the self-compiled one
00:59:28 <Axman6> why are you using /usr though?
00:59:39 <bl^ckh0le> Axman6: because it's my own system, compiled from scratch
00:59:41 <Axman6> why not /usr/ocal like you're supposed to?
00:59:44 <bl^ckh0le> so, why not?
00:59:44 <Axman6> local*
00:59:50 <bl^ckh0le> damnit, it's like Debian
00:59:52 <mjrosenb> > ((,) =<< (+1)) 1
00:59:53 <lambdabot>   (2,1)
01:00:10 <mjrosenb> hrmm,     No instance for (Monad ((->) a))
01:00:13 <bl^ckh0le> you compile packages into /usr
01:00:16 * Axman6 goes to get some dinner
01:00:17 <mjrosenb> what do i need to import?
01:00:20 <mauke> mjrosenb: import Control.Monad.Instances
01:03:02 <mjrosenb> @pl (\x -> liftM (\r -> (r,x)) (f x))
01:03:03 <lambdabot> ap (fmap . flip (,)) f
01:04:14 <Cale> bl^ckh0le: System is a haskell98 module
01:04:22 <Cale> bl^ckh0le: Try System.IO
01:04:28 <Cale> Or -package haskell98
01:05:10 <Cale> bl^ckh0le: actually, check to see if  gkc-pkg list haskell98  turns up anything, and if not, then you'll know why System is missing :)
01:05:50 <Cale> bl^ckh0le: If it shows up in parens, then it's hidden, and you can make it more easily accessible by doing  ghc-pkg expose haskell98  (I don't have GHC 7 installed to check)
01:06:02 <Eduard_Munteanu> Also you might not want to use GHC 7 yet.
01:06:26 <Eduard_Munteanu> Unless you're ok with fixing broken packages and such.
01:09:01 * Xilon likes the haskell.org facelift
01:11:37 <bl^ckh0le> Cale: haskell98-1.1.0.0
01:31:25 <co_dh> Hi, good evening. 
01:31:25 <lambdabot> co_dh: You have 1 new message. '/msg lambdabot @messages' to read it.
01:31:37 <co_dh> I have a problem with SDL on Mac OS X
01:32:10 <co_dh> in ghci , if I do   :m + Graphics.UI.SDL
01:32:15 <Gracenotes> linking problems?
01:32:29 <co_dh> and getTicks, I got an error  unknow symbol _SDL_FreeSurface.
01:32:33 <Gracenotes> did you do - ghci -lsdl?
01:32:40 <co_dh> Yes, I belive it's a linking problem. 
01:32:45 <co_dh> let me try
01:33:19 <co_dh> YESS, it's works, thanks gracenots :)
01:33:54 <hvr> is there something like `sequence` for the IO monad, which forkIO's each action in parallel and collects its results?
01:34:15 <co_dh> sequenceM
01:34:21 <co_dh> in Control.Monad
01:34:29 <co_dh> :t sequenceM
01:34:30 <lambdabot> Not in scope: `sequenceM'
01:34:33 <hvr> does it use forkIO?
01:34:35 <Gracenotes> wait.. I thought sequenceM *was* sequence
01:34:46 <Gracenotes> parallelism is a different beast entirely
01:34:59 <hvr> actually I just need concurrency :-)
01:35:01 <co_dh> yes, your are right. 
01:35:24 <co_dh> forkIO fork a thread, so it's concurrent.
01:35:27 <Gracenotes> there are functions which do just that.. in some concurrency framework or another..
01:36:19 <Gracenotes> although I think they're pure, not IO
01:36:40 <byorgey> @type forkIO
01:36:41 <lambdabot> Not in scope: `forkIO'
01:36:42 <hvr> if I have an action of result type "IO String", forkIO'ing it won't work, because forkIO needs a "IO ()" function
01:37:02 <mauke> solution: MVars
01:37:07 <Gracenotes> MVars and maybe Chans
01:37:31 <Gracenotes> hvr: if you expect it to yield a String, what's the point of forking it in the first place?
01:37:33 <hvr> mauke: ok, so I have to write my own 'future/promise' abstraction?
01:37:40 <mauke> dunno
01:37:48 <hvr> Gracenotes: I wan't it to fetch the string 'in the background'
01:37:56 <hvr> Gracenotes: in the style of `par`
01:38:06 <hvr> and lateron I'll collect it
01:38:44 <Gracenotes> you have n threads. have a makeshift countdown latch.
01:39:01 <hvr> Gracenotes: what's that? :-)
01:40:12 <Gracenotes> hm.. less complicated.. initialize an empty MVar for each computation. mapM readMVar. there you have it.
01:41:07 <hvr> Gracenotes: sounds like how I'd parMap a pure computation
01:42:09 <hvr> hrm... should have googled more before asking:
01:42:10 <hvr> http://stackoverflow.com/questions/2233452/how-can-i-use-parmap-with-a-monadic-function
01:42:45 <Gracenotes> there you have it
01:42:50 <Gracenotes> mapM takeMVar
01:42:52 <mauke> vs <- forM xs $ \x -> newEmptyMVar >>= \v -> forkIO (x >>= putMVar v) >> return v
01:42:58 <mauke> mapM takeMVar vs
01:43:00 <Gracenotes> readMVar being if you want them again
01:43:28 <hvr> I'm looking at Control.Monad.Parallel right now
01:43:40 <hvr> which seems to have it wrapped up nicely
01:44:09 <Gracenotes> as I said, "some concurrency framework or another." there are just so many of them.
01:44:36 <hvr> Gracenotes: ...just need to find the "right one" :-)
01:45:24 <Gracenotes> concurrency frameworks: the new xml parsers
01:48:12 <hvr> I'm eagerly waiting for the a hackage version which comes with voting/commenting facilities
01:49:13 <hvr> having to find out which package has which pro/cons amongst a dozen for the same task is quite time consuming
01:59:41 <Amit> is haskell a lot like ruby?
02:00:08 <tg_> Amit: in that they are both programming languages.
02:00:20 <edlinde> \whois
02:00:20 <tg_> And, both available on the internet.
02:00:21 <Amit> I mean the syntax and style
02:00:23 <edlinde> whoops
02:00:27 <tg_> no, not at all
02:00:47 <Amit> explain - I'm new to haskell
02:01:13 <danr> Major differences is that Ruby is mainly object orientated, dynamic typed, and haskell is lazily evaluated, strict typed and functional, and also pure (that is, functions have no side effects)
02:01:14 <tg_> one is a message passage, object oriented, duck typed language.
02:01:26 <tg_> the other is... what he said
02:01:45 <edlinde> is there a way to trace the calls in a function?
02:01:54 <edlinde> I mean to output all the recursive calls its making
02:02:06 <ddarius> Amit: Why don't you just learn about Haskell and not worry about how it is the same or different from Ruby.
02:02:53 <danr> edlinde: one way is to do the calculations it in a writer monad and tell it something everytime it enters a function
02:03:28 <edlinde> danr: is there nothing inbuilt into ghci?
02:03:31 <Amit> that'd be great but isn't it easy to compare languages to see how they're different?
02:03:59 <tg_> amit: it is, if you know both of them.
02:04:14 <tg_> It's pretty clear from easily available information (ie, wikipedia) that they are very different
02:04:27 <danr> from http://haskell.org/ghc/docs/6.12.2/html/users_guide/ghci-debugger.html : There is currently no support for obtaining a “stack trace”
02:04:31 <ddarius> Amit: Sure, it's easy and mostly useless.
02:04:44 <danr> but have a look at the ghci debugger from that page
02:05:01 <edlinde> k
02:06:10 <Amit> I'm finding Haskell pretty interesting! Anyone recommending good books?
02:06:23 <Twey> @where rwh
02:06:24 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
02:06:27 <tg_> @where lyah
02:06:27 <lambdabot> http://www.learnyouahaskell.com/
02:06:29 <Twey> Oh, you're a Ruby person
02:06:35 <Twey> Yeah, you'll probably prefer LYAH >.>
02:06:41 <tg_> Twey: Ruby-ist
02:06:45 <danr> start with lyah it's really nice :)
02:07:20 <hvr> there also neat video lectures with meijers
02:07:46 <tg_> Amit: you'll also usually find this channel really helpful when you have specific or advanced questions - but for questions which can be answered simply or which are matters of opinion, maybe not so helpful
02:08:11 <danr> tg_: well said :)
02:08:19 <Amit> I'm sorry I didn't know - I was just trying the tryhaskell.org and it suggested the IRC chat
02:09:03 <tg_> Amit: You can see some basic examples at http://en.wikipedia.org/wiki/Haskell_features
02:09:40 <tg_> Amit: but seriously - there is no more helpful channel than #haskell if you have a question with accompanying code, or you have detected some new or novel expression
02:09:56 <tg_> Amit: it puts #ruby and #rails to shame
02:10:13 <Amit> I'd keep that in mind! Really a very helpful (& passionate) community
02:10:34 <moozilla> hi, how do I run a parser in Data.Binary.Get over a socket?
02:10:45 <tg_> Amit: Install haskell platform. Read and follow LYAH. You'll be on your feet in no time.
02:10:59 <ddarius> Data.Binary.Get takes a ByteString.  It doesn't care how you get the ByteString.
02:11:27 <moozilla> ddarius is there a way to lazyily read from a socket?
02:11:32 <Amit> I'll surely install Haskell. And by the way, did you mean the MSDN lectures by Meijers on Haskell
02:11:42 <hvr> Amit: yes
02:12:12 <hvr> I found them fun to watch
02:12:41 <moozilla> I'm not sure hGetContents is appropriate?
02:12:44 <tg_> Amit: also, any videos by Simon Peyton Jones are delightful, funny, and interesting. He is the single most boyount presenter of programming material I've ever seen
02:13:23 <Amit> Wow! these are some really good lectures and will keep me busy for sometime!
02:13:41 <Amit> I can even make a Haskell project for my final year
02:13:46 <tg_> quick, someone pick a good SPJ video
02:13:58 <hvr> tg_: a taste of haskell?
02:14:57 <tg_> Amit: http://www.mefeedia.com/watch/26168585 and http://www.mefeedia.com/watch/26168580 would be great to watch
02:15:04 <tg_> to get a sense of things, from one of the language's inventors
02:15:13 <ddarius> tg_: I like the OSCON STM one.
02:15:27 <tg_> ddarius: yeah, but it's too short and specific to something that's not widely used yet :o
02:15:37 <tg_> ddarius: I was going to suggest the history of haskell/erlang one
02:15:56 <ddarius> tg_: That it is short is a benefit in this case, and it's a pretty interesting topic not that the topic really matters with SPJ.
02:16:17 <tg_> either way, Simon's quirky style is really engaging if you're a geek
02:16:30 <ddarius> I don't think being a geek matters.
02:16:40 <tg_> between him and Dr. Who - there's something in the water in Glasgow
02:17:10 <tg_> ddarius: I retract the guard for geekiness.
02:17:22 <edlinde> is there another way of grouping arguments for functions in haskell ... other than wrapping it in ( and ) ?
02:17:27 <Amit> it helps though :-)
02:17:48 <tg_> Amit: to be honest, when I first saw him on video, I thought he had some kind of savantism
02:18:20 <danr> edlinde: maybe put them in a record?
02:18:21 <tg_> edlinde: the things which change precedence?
02:18:23 <edlinde> just confused as to when and how to use the $ 
02:18:44 <Amit> was googling what is savantism ;-)
02:18:50 <edlinde> for ex I have a function called "nextRand n x = ...." takes two args
02:18:57 <byorgey> edlinde: $ is not for grouping per se.  It is just function application with a very low precedence.
02:18:58 <edlinde> I then call it in another fn as 
02:19:07 <edlinde> iterate (nextRand n) range
02:19:20 <edlinde> where I do a partial application with nextRand
02:19:22 <byorgey> yeah, you can't use $ for that
02:19:42 <edlinde> byorgey: ok
02:19:44 <tg_> hehe.. good very morning brent
02:19:48 <edlinde> byorgey: doing this ... take range $ iterate (nextRand n) range  works
02:20:16 <edlinde> is that not like saying ...   take range ( iterate.... range)
02:20:17 <edlinde> ?
02:20:21 <danr> yes
02:20:28 <byorgey> good morning tg_ =)
02:20:45 <edlinde> ok...
02:20:56 <danr> so a dollar can be seen as a start parenthesis, where the stop parenthesis is on the end of the entire exrpession
02:20:58 <edlinde> then i still haven't figured out when and when not to use $ :)
02:21:09 <edlinde> ah i see
02:21:09 <tg_> @hoogle takeRand
02:21:10 <lambdabot> No results found
02:21:33 <danr> so f x (g y) becomes f x $ g y
02:21:33 <byorgey> it's more that   ... $ ...   parses as  (...) (...)
02:21:57 <danr> but of course!
02:22:23 <edlinde> i see
02:22:25 <tg_> it's like a function quantizer?
02:22:34 <tg_> s/function/expression/
02:22:42 <edlinde> so in my case if I had to make a function call in the middle.. I just have to wrap it in a () 
02:22:48 <edlinde> there is no way else
02:22:57 <edlinde> coz I see a lot of times people doing a .
02:23:02 <edlinde> for function composition
02:23:07 <edlinde> f(g(x))
02:23:32 * ddarius really dislikes people saying "The $ is like an opening parenthesis."
02:23:45 <danr> ddarius: well sorry then :(
02:24:28 <byorgey> it's not that much harder to understand what is really going on
02:24:46 <byorgey> everyone knows that 3 * 4 + 5 * 6  parses as  (3*4) + (5*6)
02:24:52 <byorgey> why? because + has lower precedence than *
02:25:02 <byorgey> well, $ has lower precedence than EVERYTHING
02:25:09 <Gracenotes> parentheses are implicitly involved.. the same way they're involved for every other operator..
02:25:20 <tg_> ddarius: http://stackoverflow.com/questions/940382/haskell-difference-between-dot-and-dollar-sign
02:25:26 <byorgey> and it is defined by  f $ x = f x
02:25:38 <byorgey> QED.
02:25:48 <Gracenotes> byorgey: again, in Agda
02:26:06 <byorgey> Gracenotes: I don't have the proper Unicode input mode for irssi
02:26:47 <Twey> edlinde: Unfortunately our $ binds the wrong way, so there are some cases in which you have no choice but to bracket stuff
02:26:57 <danr> byorgey: ok well said, that is indeed more pedagogical
02:26:58 <edlinde> ok
02:27:05 <Twey> f (g x) y
02:27:14 <edlinde> can someone help me understand this
02:27:16 <edlinde> select [] = []
02:27:16 <edlinde> select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
02:27:30 <edlinde> the list comprehension has a recursive call to itself
02:27:37 <edlinde> its a bit confusing
02:27:44 <edlinde> I understand what the end result is
02:27:55 <Twey> edlinde: Why is it confusing?  It's just the function called on the rest of the items.
02:27:55 <edlinde> but how its doing it.. beats me a bit ;)
02:28:10 <Twey> Work it through with a small input
02:28:18 <edlinde> ok I did
02:28:22 <edlinde> with [1,2,3]
02:28:26 <Gracenotes> I kind of like $ being left-associative
02:28:34 <edlinde> so it starts of with a (x,xs) : ...
02:28:34 <Twey> edlinde: Sounds good
02:28:40 <Twey> Gracenotes: Why?  o.@
02:28:40 <Gracenotes> but we've discussed this here before..
02:29:06 <edlinde> Twey: so its saying I will have a pair of the form  say (1, [2,3])
02:29:08 <edlinde> yeah?
02:29:15 <edlinde> coz xs is the tail
02:29:56 <vitka> > let f (x:xs) = (x,xs) in [1,2,3]
02:29:57 <lambdabot>   [1,2,3]
02:30:05 <vitka> > let f (x:xs) = (x,xs) in f [1,2,3]
02:30:06 <lambdabot>   (1,[2,3])
02:30:17 <edlinde> yep
02:30:33 <mjrosenb> edlinde: morning.
02:30:45 <edlinde> mjrosenb: hi there... long time no see
02:30:47 <edlinde> :)
02:32:13 <edlinde> so yeah the list comprehension bit is still a bit confusing
02:32:29 <edlinde> why do this -->   [(y,x:ys) | (y,ys) <- select xs]
02:34:48 <ddarius> edlinde: That list comprehension is identical to a map.-
02:35:12 <Gracenotes> why do it? or what does it do?
02:35:37 <Twey> edlinde: Right
02:35:45 <edlinde> yeah what does it do 
02:35:50 <mjrosenb> edlinde: well you know what select does as a whole, right?
02:36:00 <edlinde> yeah
02:36:06 <Twey> Yeah, I'd've done a map (second (x :)) $ select xs
02:36:07 <edlinde> its building a list of selections
02:36:27 <kamatsu> hm
02:36:35 <kamatsu> best way to encode a value -> type relation?
02:36:42 <mjrosenb> and that call is no different.
02:37:03 <kamatsu> in Agda this is straightforward but I need to do something like this in Haskell
02:37:07 <edlinde> so in a list comprehension if I made a recursive call to "select .. tail" ... it will first evaluate that yeah?
02:37:23 * mjrosenb frequently wants a shortcut for [foo | bar <- [0..quux]]
02:37:24 <Gracenotes> kamatsu: .. Typeable? *shudder*
02:37:50 <ddarius> mjrosenb: It's called map as long as bar can't fail.
02:37:54 <mjrosenb> namely the [0..quux] bit; explicitly declaring a list inside of a list comprehension seems wrong.
02:38:14 <ddarius> Stop using list comprehensions: problem solved.
02:38:20 <kamatsu> Gracenotes: I have a map String String, and I want to declare that certain keys can be transformed to certain types.
02:39:18 <Gracenotes> I'm not sure how much type-level craziness you want to involve
02:39:23 <mjrosenb> ddarius: actually, i think i just want to be able to say bar <- 0..quux
02:39:36 <ddarius> That's ridiculous.
02:39:47 <Twey> edlinde: http://hpaste.org/42060/reduction_of_select
02:39:51 <Gracenotes> putting types in a uniform collection.. hhhmmmm
02:39:51 <mauke> mjrosenb: enumFromTo
02:39:51 <kamatsu> Gracenotes: alreaedy got crazy amounts of type stuff for other things.
02:40:03 <ddarius> mjrosenb: But if you really want, you can define (...) to be enumFromTo
02:40:12 <kamatsu> Gracenotes: my priority is for easy ability to declare key/types
02:40:16 <Gracenotes> then you'd know better than me
02:40:43 <moozilla> I'm having trouble with Data.Binary.Get
02:40:50 <moozilla> I keep getting errors like this: Couldn't match expected type `Word16' against inferred type `m a'
02:41:05 <Twey> moozilla: You're doing it wrong
02:41:16 <moozilla> I'm not sure what the issue is
02:41:29 <Twey> Neither are we, but we might if you showed us some code
02:41:43 <ddarius> moozilla: Learn more about type checking.
02:41:50 <sgtarr> A question: Why does not Haskell support a normal iterative loop approach, in which the compiler unrolls it into a tail recursive call so that under the hood,you aren't using any loop variable with a mutable state, but gives more convenience to the developer?
02:41:51 <edlinde> Twey: thanks am reading through it now
02:41:59 <Twey> And motes/do notation, by the looks of it
02:42:09 <kamatsu> sgtarr: you can easily implement one
02:42:16 <moozilla> if I do runGet getWord16 test, in ghci it returns a number like it should
02:42:18 <Twey> sgtarr: Because they tend to be *less* convenient
02:42:26 <sgtarr> kamatsu: yes, but why is it not in the language itself, a particular reason?
02:42:30 <moozilla> but if i do it in a do statement I get that error
02:42:32 <sgtarr> Twey: how so?
02:42:32 <tg_> sgtarr: loop unrolling is a compiler technique in most?
02:42:45 <mauke> sgtarr: that sounds just like 'map'
02:42:45 <Twey> sgtarr: Recursion is a more direct way to express most problems
02:42:45 <tg_> most languages... not a language technique, no?
02:42:45 <moozilla> I figure this is something about monads that I don't understand
02:42:46 <ddarius> sgtarr: No, they are less convenient even with built-in syntax in many cases.
02:43:01 <kamatsu> sgtarr: because keeping the amount of language constructs low allows more syntax for use in EDSLS etc.
02:43:06 <ddarius> Twey: I don't agree with that.
02:43:19 <ddarius> Twey: However, the higher order combinators we habitually use are.
02:43:30 <Axman6> sgtarr: sounds like you just described how we do looks in haskell, with (tail) recursion
02:43:32 <Twey> ddarius: More direct than an imperative loop, at any rate
02:43:48 <ddarius> Twey: I don't agree with that.
02:44:23 <Twey> ddarius: If you talk to someone from an imperative language, they'll generally consider recursion to be the ‘easy way out’, which of course must be avoided because it's inefficient and blows up the stack
02:44:27 <sgtarr> interesting answers...
02:44:37 <sipa> sgtarr: because a loop as primitive concept isn't necessary, you can easily express it using forM example
02:44:38 <dubhrosa> what's a better/more idomatically haskell way of unpacking wrapped data, through unpackSomeDataType functions or a typeclass with generic unpack function?
02:44:42 <Twey> Or at least that's my experience.
02:44:51 <sgtarr> !hoogle forM
02:44:54 <ddarius> Twey: I've never heard anyone say that.
02:44:58 <Twey> I certainly find it easier to write recursive algorithms for many problems than imperative iterative.
02:45:00 <sipa> :t forM
02:45:01 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
02:45:03 <sgtarr> oh
02:45:06 <mauke> sgtarr: I'd say it depends on what kind of results you want to collect
02:45:15 <ddarius> Twey: Perhaps you mean naive recursion for, e.g. factorial, versus iteration.
02:45:36 <Twey> ddarius: No, I meant what I said and said what I meant ☺
02:45:43 <ddarius> In which case I agree, but functional programmers say the same thing about naive recursion.
02:45:46 <sgtarr> mauke: you're right about map tough, it does sound like map
02:46:30 <ddarius> length [] = 0; length (_:xs) = 1 + length xs, is pretty and direct, but unacceptable to both imperative and functional programmers for the same reason.
02:46:47 <ddarius> The tail recursive form, though, looks pretty much just as ugly as the imperative form.
02:47:18 <mjrosenb> ddarius: i think that *most* operations on trees and lists look better when written recursively.
02:47:30 <ddarius> mjrosenb: Most operations on trees require recursion.
02:48:02 <Twey> I don't know… length acc [] = acc; length acc (_ : xs) = length (acc + 1) xs
02:48:07 <ddarius> On lists, we (at least) can exploit laziness in which case the "naive" "direct" version is indeed the right one.
02:48:20 <Twey> It might not be *as* nice, but I think it's still a far cry above a loop…
02:48:30 <ddarius> Twey: It's pretty much identical to a loop.
02:48:32 <ddarius> @paste
02:48:32 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
02:48:32 <mjrosenb> ddarius: looking up an node, and inserting a node can be done with a loop.
02:48:44 <Twey> hpaste.org now, no?
02:48:48 <mauke> Twey: length xs = { var i = 0; for _ in xs { i++ } return i }
02:49:29 <Twey> Quite a bit different to the accumulative version semantically, at least in my mind
02:49:39 <mauke> sub length { my $i = 0; $i++ for @_; $i }
02:49:53 <edlinde> Twey: is there a neater way of doing this?
02:50:19 <edlinde> Twey: I meant still with a list comprehension but maybe without the  (y, x:ys) bit :)
02:50:24 <edlinde> its a bit weird looking
02:51:41 <edlinde> Twey: would I be right in thinking that... as we go deeper into the recursion levels and we are coming back... we are adding the elements we left out to the tail in the pair (y, x:ys) ?
02:51:48 <mjrosenb> edlinde: second will do what you want, but ... ugh.
02:52:01 <edlinde> mjrosenb: I never used second
02:52:02 <ddarius> http://hpaste.org/42061/loop  I'm hard pressed to see how the imperative version is much uglier than the functional version.
02:52:37 <mauke> ddarius: needs more seq
02:52:40 <mjrosenb> > second (1:) (3,[4])
02:52:41 <lambdabot>   (3,[1,4])
02:52:52 <ddarius> mauke: I omitted that concern since the issue isn't particular to lazy languages.
02:53:01 <mauke> > fmap (1:) (3,[4])
02:53:02 <lambdabot>   (3,[1,4])
02:53:45 <mjrosenb> mauke: how on earth does that work?
02:53:48 <edlinde> yeah
02:53:56 <edlinde> how come it goes to the second?
02:53:59 <mauke> mjrosenb: it's done with Functors
02:54:06 <edlinde> coz its looking for the list in the pair?
02:54:14 <ddarius> mjrosenb: That's simply how fmap is defined.
02:54:17 <mauke> instance Functor ((,) a) where fmap = second
02:54:38 <mjrosenb> the functor for (,) operates on the second element?
02:54:47 <mauke> that's the only way to make it a functor
02:54:58 <edlinde> interesting
02:55:00 <edlinde> :)
02:55:01 <mauke> don't see why? try it yourself
02:55:09 <mjrosenb> oh.. right, since the types aren't actually symmetric
02:56:31 <edlinde> what do I need to import for second?
02:56:42 <edlinde> Control.Arrow?
02:57:17 <alpounet> @hoogle second
02:57:18 <lambdabot> Control.Arrow second :: Arrow a => a b c -> a (d, b) (d, c)
02:57:18 * hackagebot rclient 0.1.0.0 - Haskell client for Rserve  http://hackage.haskell.org/package/rclient-0.1.0.0 (TomDoris)
02:57:18 <lambdabot> Data.Time.Clock secondsToDiffTime :: Integer -> DiffTime
02:57:18 <lambdabot> Data.Time.Clock.TAI type LeapSecondTable = Day -> Integer
02:57:21 <alpounet> yes :)
02:58:15 <Xilon> Is there a cli utility to create the basic haskell project file structure?
02:59:18 <dubhrosa> Xilon: see here: http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
03:00:03 <mjrosenb> Xilon: touch usually works for me :)
03:00:08 <dubhrosa> there doesn't appear to be a script but you can start by copying Hnop
03:00:34 <nlogax> there's cabal init
03:01:11 <Xilon> Hmm, yeah. I guess it's too simple/infrequent to warrant a tool, but then again I'm lazy :P
03:02:18 <Cale> cabal init is probably what you're looking for
03:03:02 <Cale> It doesn't produce any source files of course, but does provide a quick way to get a simple .cabal and LICENSE file
03:03:23 <Cale> (and a Setup.hs, though you don't actually use that these days :)
03:06:01 <ddarius> > 8000^2
03:06:02 <lambdabot>   64000000
03:08:56 <Twey> edlinde: http://hpaste.org/paste/42060/simpler_version#p42062
03:09:11 <Twey> edlinde: No, you generally wouldn't use the comprehension at all.  It's just a map in disguise.
03:09:21 <edlinde> ok
03:09:22 <edlinde> cool
03:09:41 <Twey> ddarius: The data flow is much more complex
03:09:58 <Twey> (and of course this is a greatly simplified case, too)
03:14:47 <ddarius> Twey: The data flow is identical, so identical that the latter is usually converted into the former by compilers.
03:17:09 <ddarius> (Which, perhaps ironically, is then converted back into the latter by compilers of both brands of languages.)
03:18:12 <Twey> ddarius: It's not at all.  The *control* flow is essentially identical; the data flow is quite different.  In the recursive version, it's a straight progression into the next iteration until it gets to the base case, where it's returned up out of the function.  In the imperative version, the data flow involves jumping back and forth between the outer scope with the variable in it and the inner loop where the transformation is happening.
03:18:39 <Twey> ddarius: (and what compilers compile into isn't a particularly good indication of the semantics of a piece of code, or Haskell would be semantically equivalent to assembly language…)
03:19:22 <ddarius> Twey: Compilers must at least preserve the semantics, so if the compiler can compile the latter to the former and vice versa, they must be semantically the same.
03:20:16 <Twey> ddarius: Er, no?  They must encode the same information, but the way in which they do it can be quite different.
03:20:18 <ddarius> Also, since I used a curried definition, there is also an "uber-complex" data flow involving bouncing between scopes.
03:20:48 <Twey> (assembly language *with tags* could theoretically be compiled back into Haskell, for example, but it still wouldn't *be* Haskell)
03:22:10 <Twey> ddarius: Yes, but it's an implementation detail; it makes no difference in this particular case.  The flow of information in the imperative version *does* make a difference, and must be understood before the code makes sense.
03:22:24 <danr> Twey: what information would be stored in those tags?
03:22:56 <Twey> danr: No idea
03:23:19 <Twey> Types, function names, stuff like that, I guess
03:23:37 <sipa> how do you define 'data flow' ?
03:25:25 <Twey> sipa: The way that information moves through the program, similar to control flow but tracking data accesses and transformations instead of execution
03:30:40 <Cerise> hi there. how can i get glut to work on windows 7 (64bit)? i installed the haskell platform and i'm trying to compile the first example on http://www.haskell.org/haskellwiki/OpenGLTutorial2, but i get "user error (unknown GLUT entry glutInit)" when i run it
03:32:39 <ddarius> Twey: If your argument is that -mutation- complicates things in general, then certainly I agree, but that is somewhat orthogonal to (tail) recursion v. iteration.  The same issues can come up with tail recursion given mutation.  I do agree that tail recursion is usually much more explicit about the loop variables, but the same could be done with an iteration construct.
03:34:09 <ddarius> At any rate, being much more explicit isn't always a win.  I still doubt that you could honestly say that the imperative version I gave is much more ugly and difficult to understand than the tail recursive version.
03:35:38 <ddarius> Or less "direct."
03:35:47 <Twey> ddarius: For me it isn't, since I'm familiar with imperative programming and can gloss over the loop
03:36:06 <Twey> But for someone who doesn't know either, I think it would be.
03:36:24 <Twey> The effect is compounded with more complex code, too.
03:43:40 <ddarius> For more complex examples, the imperative code would be more structured with regards to control flow assuming the problem.  Tail calls are rather unstructured in this regard and would lead to the same sorts of problems you see with data flow, which really has to do with mutation not iteration, only for control flow.  Of course the solution is not to think at the level of (tail) recursion, but to use higher order functi
03:43:40 <ddarius> ons which capture structured control flow, which corresponds to the structured control flow constructs provided by imperative languages.
03:44:24 <Pille456> Hi, i've got a problem using "instance" + class: http://pastebin.com/zhjbBDxM Sure the error says, that it expects type 'a' there, but I'm not sure why. in my option ghci should expect 'Nat' here
03:45:34 <ddarius> So, typical imperative: good control structuring as long as the problem fits the control structures reasonably well, unstructured but powerful data flow.  Pure functional: good data flow structuring as long as it isn't too complicated, unstructured but powerful control flow.
03:46:35 <Axman6> Pille456: are the lines under the class line indented?
03:46:38 <sipa> good point
03:47:20 <sipa> both are able to do the same thing, but in imperative programming you explicitly state the control flow, and the data flow is a result; in functional programming you explicitly state the data flow, and the control flow is a result
03:47:25 <Pille456> Axman6: I'm using a *.lhs file with > at the beginng of each code line
03:47:32 <Twey> ddarius: Well, mutation is the key difference between the two things.  Functional has good data-flow structuring even when things get complicated: there's none of this dashing off to retrieve variables defined all over the place, just a linear data flow (or rather a series of such that can split and join as necessary).
03:47:42 <Twey> sipa: Sounds about right
03:47:58 <Axman6> Pille456: the elements of a class need to be indented after the class Foo a where line
03:48:07 <Axman6> class Foo a where
03:48:19 <Axman6>     bar :: String -> a
03:48:35 <Axman6>     baz :: a -> a -> a
03:49:30 <Pille456> Axman6: lol..i guess sometimes its better using ';' :D thank you!
03:49:48 <Axman6> no worries
04:00:55 <ddarius> Twey: 1) Mutation is orthogonal to recursion v. iteration, you can have either with or without mutation, 2) imperative languages tend to have nicely structured control flow, but if what I need is unstructured (or differently structured) control flow then this breaks down and my code is worse than it would be given an unstructured control flow construct.  If I need to "dash off and retrieve variables defined all over th
04:00:55 <ddarius> e place" then pure FP makes this extremely difficult and my code becomes much more complicated.
04:06:09 <Twey> ddarius: 1) We were talking about *imperative* iteration, where you iterate updating a variable until some condition is met; 2) Yes, but the idea is that you should never have to; if it looks like you've got that crazy unstructured data-flow, you should probably restructure your program somehow to make the data-flow nicer.
04:13:53 <merijn> If I have a a bunch of threads posting events to the main thread using a channel, what's the best way for the main thread to broadcast back to the individual threads? Adding a channel per thread to communicate back over?
04:17:48 <Axman6> merijn: you can duplicate channels, so you could make a chan, and duplicate it for each thread, and write to that
04:20:46 <ddarius> Twey: Okay, I'll modify your original statement to "Tail recursion has less potential complexity problems with regards to data than a mutative iterative loop in a mutation-oriented language."
04:20:51 <merijn> Axman6: Oh! If I duplicate a channel it won't remove the item from both channels when one thread reads. Didn't think of that. So I want to pass all threads the same channel for communicating with the mainthread and then pass them a duplicate of another channel for the main thread to write back in?
04:21:54 <Twey> ddarius: Of course, our functional code is iterative, too (naïve and accumulative implementations both).
04:34:22 <xarch> what are zygomorphisms used for ?
04:37:04 <mreh> :t fail
04:37:05 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
04:38:26 <merijn> xarch: Traditionally they're used for sounding pretentious :>
04:42:06 <co_dh> I got an Undefined symbols:
04:42:07 <co_dh>   "_SDL_main", referenced from:
04:42:07 <co_dh>       -[SDLMain applicationDidFinishLaunching:] in libSDLmain.a(SDLMain.o)
04:42:11 <co_dh> it's on MacOSx. 
04:42:22 <co_dh> ghc --make -lsdl example.hs
04:42:50 <co_dh> anybody knows how to fix this kind of bug?
04:43:20 <benmachine> co_dh: do you know if sdl works other than with haskell?
04:43:31 <benmachine> like, can you compile an example application with it or something
04:43:35 <co_dh> how can I test that?
04:43:40 <co_dh> wait . 
04:43:44 <co_dh> let me check
04:45:07 <co_dh> yes, it works. in the test fold, I make, and run a few examples. they work
04:45:21 <benmachine> I have no other ideas :P
04:45:23 <pokoko222> all you computer science guys here i have a general question :) when writing a paper, and you want to write about something that someone else has writen about, how do you do it? I mean you cant just quote one whole page
04:45:39 <benmachine> maybe you need a -framework or something/
04:45:49 <pokoko222> can you like comment it your way and then say, "according to the author bla bla"
04:46:10 <co_dh> like ghc --make -framework? 
04:46:45 <ezyang> pokoko222: What kind of paper are you writing? 
04:46:46 <benmachine> -framework something
04:46:48 <merijn> pokoko222: You'd normally write a one line summary of the other papers conclusion and include a reference. That way anyone who does not belief your summary can always look up the original paper
04:46:59 <benmachine> but I don't know what the something would be
04:47:03 * benmachine doesn't know enough about SDL
04:47:04 <merijn> (or more then one line, depends on the complexity of the subject)
04:47:06 <benmachine> or OSX
04:47:13 <pokoko222> ezyang actually it is seminar paper for a subject called software engineering
04:47:23 <pokoko222> i write about the v-model
04:48:03 <merijn> pokoko222: "According to Some-guy et al. [Som04] the v-model provides the following benefits", or whatever 
04:48:07 <co_dh> thanks benmachine.
04:48:16 <pokoko222> merijn i am allowed to do that? 
04:48:17 <ezyang> Ah, that's a somewhat different matter 
04:48:36 <benmachine> co_dh: it's only a guess :P just thought it might be worth exploring
04:48:53 <merijn> pokoko222: Well, so far in my bachelor thesis/class paper it hasn't gotten any complaints
04:48:55 <ezyang> Since the object of the paper is to resynthesize other people's work, not present novel work of your own. 
04:49:01 <moozilla> anyone know a good way to receive a large amount of data from a socket and just discard it?
04:49:13 <merijn> s/paper/papers
04:49:13 <pokoko222> ezyang, merijn, http://www.the-software-experts.de/e_dta-sw-process.htm that is the page and i want to talk about what he says
04:49:15 <co_dh> the graphics-combinators is elegant, just want to try it. but it's depends on SDL. 
04:49:15 <ezyang> Make sure you cite even when you paraphrase, etc. 
04:49:26 <pokoko222> so i guess i can say acording to the web page bla bla ... and so on
04:49:50 <merijn> pokoko222: The basic rule is "you can summarize/paraphrase all you want as long as you cite the original source"
04:50:08 <pokoko222> ok
04:50:29 <jro> I want to make readMaybeDouble
04:50:31 <jro> readMaybeDouble :: String -> Maybe Double
04:50:34 <jro> readMaybeDouble s = go (read s) where go (d::Double) = Just d; go _ = Nothing
04:50:54 <jro> bad try
04:51:00 <merijn> pokoko222: That way you don't claim credit for someone else's work and curious people can look it up themselves
04:52:36 <pokoko222> so he talks about an example in a whole paragraph. i can interpret that and talk about the example and then say the author of that
04:52:55 <pokoko222> i mean not just translate the whole paragraph and say author
04:54:18 <Axman6> moozilla: Data.ByteString.Lazy.hGetContents? it'll create a bytestring, that never actually gets u8sed, so gets gc'd
04:54:46 <Axman6> used*
04:55:01 <moozilla> I'm using hGet with the size specified and I get an exception
04:55:46 <moozilla> In the Data.ByteString.Lazy namespace
04:56:53 <co_dh> anybody know what does the following error message means?
04:56:54 <co_dh> hc[39574:1f03] *** _NSAutoreleaseNoPool(): Object 0x11278c0 of class NSCFNumber autoreleased with no pool in place - just leaking
04:57:24 <co_dh> I'm running the example.hs under http://github.com/luqui/graphics-drawingcombinators
04:57:35 <co_dh> with ghci -lsdl example.hs
04:59:23 <Axman6> namespace? :\
05:02:56 <Axman6> merijn: sorry i didn't reply sooner, that's exactly what i'd do :)
05:09:01 <jro> readMaybeDouble s | [d] <- maybeParse = Just d
05:09:15 <jro>                   | otherwise = Nothing 
05:09:20 <jro>   where
05:09:21 <jro>     maybeParse = [x | (x,_) <- reads s]
05:09:34 <jro> this requires PatternGuards extension
05:10:33 <jro> but works
05:11:23 <ddarius> maybeParse doesn't seem worthwhile.  You probably also want to look at listToMaybe.
05:16:13 <ddarius> :t fmap fst . listToMaybe
05:16:14 <lambdabot> forall a b. [(a, b)] -> Maybe a
05:16:25 <ddarius> :t fmap fst . listToMaybe . reads
05:16:26 <lambdabot> forall a. (Read a) => String -> Maybe a
05:17:40 <Axman6> why on earth reads isn't String -> Maybe i've never been able to figure out
05:19:32 <danr> for handling ambiguous parses?
05:19:33 <jro> ddarius, thanx
05:20:17 <ddarius> That and by using lists you can abuse list comprehension syntax
05:20:56 <ddarius> The issue isn't why does reads return a list, but why isn't readMaybe in the standard libraries.
05:21:33 <merijn> :t reads
05:21:34 <lambdabot> forall a. (Read a) => String -> [(a, String)]
05:22:03 <Axman6> win 20
05:26:00 * hpc always thought of "reads" as "read-safe", rather than "plural of read"
05:27:10 <ddarius> Amorphous computing produces the most interesting diagrams.
05:27:57 <masak> such as?
05:29:37 <co_dh> answer my own question about SDL and MacOS . 
05:29:52 <ddarius> The threat avoidance diagrams at the bottom of "Fast Self-Healing Gradients"
05:30:05 <co_dh> there is an readme in ~/.cabal/share/SDL_0.6.2, talk about the problem. 
05:30:18 <co_dh> you can't run SDL code in ghci , 
05:30:35 <hpc> more specifically, you can't run OpenGL code
05:30:39 <ddarius> masak: Or many of the simulation snapshots in Butera's thesis, "Paintable Computing."
05:31:31 <co_dh> I remember I can run OpenGL under ghci with another file.  
05:32:04 <Axman6> i believe the problem has been fixed in ghc-7
05:32:53 <masak> ddarius: yes; that does look fascinating.
05:32:55 <co_dh> which problem?
05:33:11 <co_dh> @where soe
05:33:11 <lambdabot> http://haskell.org/soe/
05:33:36 <Axman6> co_dh: the problem of not being able to run OpenGL apps in ghci on OS X
05:35:47 <co_dh> I remeber in the SOE website, there is a haskell file, you can run openGL within ghci with that file. 
05:35:56 <co_dh> but haskell.org seemed dead. 
05:45:34 <fryguybob> http://twitter.com/haskellorg/status/10846088751742976 perhaps?
05:47:44 <ezyang> Yeah, looks like the maintenance has started. 
05:53:50 <ddarius> copumpkin: You doing anything today?
05:53:50 <sshc> Does GHC still support compiling via C?
05:53:53 <ddarius> Yes.
05:53:53 <sshc> (Why wouldn't it?)
05:54:14 <sshc> I heard it might be dropping support in the future?
05:55:43 <copumpkin> ddarius: I have a friend from school staying over but I think he's leaving sometime this afternoon. Right now I'm gonna go back to sleep cause I went to bed at 5 and got woken up early by the cable guy coming to set up internet! You doing anything interesting later?
05:57:05 <ddarius> I was thinking about wandering aimlessly around the Fells and I wouldn't mind hunting down yuzu-shu in Boston in the evening.
06:01:20 <ddarius> Visual block mode, I love you so.
06:03:05 <co_dh> what's that Visual block for ? 
06:03:12 <co_dh> emacs?
06:03:42 <co_dh> oh, it's vi
06:04:08 <Twey> co_dh: It's how you make vi work a little bit like emacs ;)
06:04:16 <mauke> it's vim
06:04:31 <Twey> vim, yes… vi never had a visual mode, did it?
06:04:48 <mauke> vi is named after its visual mode
06:06:05 <co_dh> I think one of the reason that vi is more popular then emacs it : emacs has 5 character to type , while vi has just 2 . so I alias em=emacs :)
06:06:14 <Twey> mauke: Different kind of visual mode :þ
06:07:19 <co_dh> :t getArgs
06:07:19 <lambdabot> Not in scope: `getArgs'
06:07:24 <Twey> co_dh: I have alias ef='emacsclient -c -nw'
06:07:36 <Twey> co_dh: IO [String]
06:08:34 <co_dh> thanks. Twey
06:10:20 <moozilla> is hackage down?
06:10:35 <fryguybob> http://twitter.com/haskellorg/status/10846088751742976
06:11:19 <co_dh> not everbody has access to twitter or facebook. poor me :(
06:11:43 <co_dh> yes, hackage down
06:11:47 <geheimdienst> ... what is an "electrical bus riser"?
06:11:54 <fryguybob> it says: hackage.haskell.org / darcs.haskell.org will be down Saturday Dec 4th, due to building repairs - "a full torque of the electrical bus riser"
06:11:57 <moozilla> aw man
06:12:04 <moozilla> does that mean all of saturday?
06:13:19 * benmachine wonders why exactly haskellorg tags some things with #haskell
06:13:27 * benmachine wonders what this implies about the other things
06:13:53 <moozilla> is there a mirror i can download packages from?
06:14:48 <fryguybob> > length "hackage.haskell.org / darcs.haskell.org will be down Saturday Dec 4th, due to building repairs - 'a full torque of the electrical bus riser'"
06:14:49 <lambdabot>   140
06:14:58 <co_dh> which package you want ? maybe I can find it in my .cabal :)
06:15:21 <dixie> > reverse "hackage.haskell.org / darcs.haskell.org will be down Saturday Dec 4th, due to building repairs - 'a full torque of the  electrical bus riser'"
06:15:22 <lambdabot>   "'resir sub lacirtcele  eht fo euqrot lluf a' - sriaper gnidliub ot eud ,ht...
06:15:56 <co_dh> is haskell's OpenGL platform independent ? if yes, then there is no need for SDL if I only use OpenGL, right?
06:17:00 <Twey> co_dh: SDL provides a lot more than OpenGL
06:17:06 <moozilla> co_dh, I'm not sure you'll have this
06:17:14 <Twey> It gives you abstractions over sound, input, and drawing
06:17:17 <moozilla> Data.Binary.IEEE754
06:17:22 <moozilla> minus the dashes
06:17:23 <Twey> But if you just want to draw, you can just use OpenGL, sure.
06:17:30 <co_dh> Twey: for the opengl part , is haskell's one platform indepenent?
06:17:33 <Twey> It'll just be a bit more awkward.
06:17:36 <Twey> Yes, I believe so
06:17:47 <Twey> OpenGL is cross-platform; HOpenGL is just a binding
06:18:00 <co_dh> moozilla: I dont' have ieee754.
06:18:01 <ddarius> @hoogle fmap
06:18:01 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
06:18:02 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
06:18:02 <lambdabot> Control.Monad.Instances fmap :: Functor f => (a -> b) -> f a -> f b
06:19:10 <moozilla> I'll take this as I sign that I should stop coding and go to bed :)
06:19:38 <dixie> > sum $ map ord "hackage.haskell.org / darcs.haskell.org will be down Saturday Dec 4th, due to building repairs - 'a full torque of the  electrical bus riser'"
06:19:38 <lambdabot>   12749
06:23:24 <Twey> o.@
06:23:46 <Twey> What is an electrical bus riser, and why does one need to torque it?
06:24:09 <benmachine> can't let your bus risers go untorqued
06:24:12 <benmachine> electrical or otherwise
06:24:18 * Twey chuckles.
06:24:25 <benmachine> otherwise how would they rise the buses??
06:24:55 <Twey> http://wiki.answers.com/Q/What_is_bus_riser — okay… half a problem solved…
06:25:04 <copumpkin> ddarius: I'd be up for that if my friend leaves in time! I asked at the place downstairs from my office but they said they only have a yuzu syrup that they add to drinks
06:25:46 <sshc> Is Hackage working for anybody else?
06:26:06 <Twey> 14:19:11 < dixie> > sum $ map ord "hackage.haskell.org / darcs.haskell.org will be down Saturday Dec 4th, due to building repairs - 'a full  torque of the  electrical bus riser'"
06:26:17 <Twey> We have no idea what this means, but it sounds important.
06:27:06 <ddarius> copumpkin: Okay, text me or call me or poke me via IRC or whatever whenever.
06:27:34 <copumpkin> will do
06:27:39 <Twey> Wasn't there a Hackage mirror somewhere?
06:27:54 <geheimdienst> twey, you just gave a characterization of 50% of all human communication
06:28:26 <benmachine> there is at least one hackage mirror
06:28:48 <Twey> geheimdienst: Ha
06:28:54 <benmachine> http://bifunctor.homelinux.net/~roel/hackage/packages/hackage.html
06:29:01 <Twey> That's the one
06:29:07 <benmachine> "This site is just a demonstration of a reverse-dependency algorithm. It is not suited for use with cabal-install. You can use it as a sort of mirror when the real thing happens to be offline."
06:29:29 * benmachine wonders why it is not suited for use with cabal-install
06:29:31 <Twey> Eh, it'll do
06:29:46 <Twey> Probably not enough bandwidth?
06:29:57 <Fuco> @pl f x (g x)
06:29:57 <lambdabot> f x (g x)
06:30:03 <Fuco> @pl a x = f x (g x)
06:30:04 <lambdabot> a = ap f g
06:30:08 <Fuco> what is ap
06:30:28 <Twey> Fuco: ap = liftM2 id
06:30:31 <ddarius> @hoogle randomRIO
06:30:32 <lambdabot> System.Random randomRIO :: Random a => (a, a) -> IO a
06:30:44 <benmachine> cabal: Failed to download
06:30:45 <benmachine> http://bifunctor.homelinux.net/~roel/hackage/packages/archive/00-index.tar.gz
06:30:45 <benmachine> : ErrorMisc "Unsucessful HTTP code: 404"
06:30:47 <benmachine> I guess that's why
06:31:02 <Twey> For functions, ap f g = \x -> (f x) (g x)
06:31:10 <ddarius> :t random
06:31:11 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
06:31:14 <Twey> benmachine: Could be, could be
06:31:17 <ddarius> :t randomR
06:31:18 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
06:31:47 <ddarius> > randomR ((0,0), (10,10)) (mkStdGen 0) 
06:31:48 <lambdabot>   No instance for (System.Random.Random (t, t1))
06:31:48 <lambdabot>    arising from a use of `e_...
06:31:49 <Fuco> f (x (g x)) is the same as (f x) (g x)?
06:31:53 <ddarius> Curses.
06:31:55 <Twey> Fuco: No
06:32:05 <Twey> Fuco: f x (g x) = (f x) (g x)
06:32:08 <Fuco> ah
06:32:18 <Fuco> @pl a x = f (x (g x))
06:32:19 <lambdabot> a = f . ap id g
06:33:31 <ddarius> @hoogle replicateM_
06:33:31 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
06:34:08 <Fuco> ok, that makes sense
06:34:15 <Fuco> thanks Twey
06:34:49 <Twey> You're welcome
06:35:24 <Fuco> in APL (f g) x is f (x (g x)) and I wasn't sure if there isn't a buildin distribution like that in haskell
06:35:28 <geheimdienst> > (ap (+) (*2)) 3
06:35:29 <lambdabot>   9
06:36:20 <geheimdienst> > ((*3) &&& (*2) 3
06:36:21 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
06:36:29 <Twey> Fuco: Haskell is not APL.  Comparing other languages to APL will not generally get you very far.  :þ
06:36:36 <geheimdienst> > ((*3) &&& (*2)) 3
06:36:36 <lambdabot>   (9,6)
06:36:39 <Fuco> Twey: yea I figured :D
06:37:13 <merijn> Also, (f g) x == f (x (g x)) makes no logical sense whatsoever >.>
06:38:41 <Fuco> merijn: probably not, but it's a fairly common construct so I guess there's some buildin support for it
06:39:54 <Fuco> also (f g h) x is g (f x) (h x) and (f g h) x y is g (f x y) (h x y) :P
06:40:15 <Twey> Yeesh.
06:41:07 <merijn> I was planning on learning APL just for the hell of it, but I think I can strike it from my todo list now...
06:41:19 <Fuco> why :P
06:41:27 <Fuco> well yes, APL is obsolete, look into J
06:41:34 <Fuco> it's build on the same principles
06:41:45 <ddarius> J is fun.
06:41:47 <co_dh> f (x (g x))  is the S combinator, and haskell has it . 
06:41:55 <co_dh> I think it's in Applicative, wait
06:42:07 <benmachine> no
06:42:08 <Fuco> it's called hook in J/APL, the second one is fork
06:42:16 <copumpkin> :t \f g x -> f (x (g x))
06:42:16 <lambdabot> forall t t1 t2. (t1 -> t2) -> ((t -> t1) -> t) -> (t -> t1) -> t2
06:42:17 <benmachine> (f x) (g x) itym
06:42:45 <sshc> What should I use to find documentation of libraries like ByteString and zlib?
06:42:47 <benmachine> or wait I'm confused
06:42:58 <Fuco> and you can do like "+/ % # (list)" to get the average (+/ is fold (+) 0, % is division, # is length)
06:43:02 <copumpkin> :t \f g x -> f x (g x)
06:43:03 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t -> t1) -> t -> t2
06:43:09 <Twey> I wish J hadn't decided to limit itself to ASCII.  :-\  We have Unicode now.
06:43:11 <Fuco> so yea it's pretty sweet :P
06:43:24 <ddarius> Twey: There are APL implementations still.
06:43:37 <Twey> co_dh: Isn't S f x (g x) = ap?
06:43:51 <co_dh> yes, that's what I find. 
06:44:03 <co_dh> > ap sum length [1..3]
06:44:04 <lambdabot>   No instance for (GHC.Enum.Enum (GHC.Types.Int -> b))
06:44:05 <lambdabot>    arising from a use ...
06:44:07 <geheimdienst> fuco, so in your example, the (list) is an argument to +/ and to #, but not to % ...?
06:44:14 <ddarius> Also it would be no trouble for you to have the J ASCIIifications displayed to you as Unicode without affecting everyone else.
06:44:34 <Fuco> geheimdienst: yes, (f g h) x is g (f x) (h x)
06:44:37 <Twey> ddarius: Well, APL *is* obsolete.  I'm all for making a new APL; I just don't think that limiting oneself to an antiquated and rather limited character set is worth sacrificing brevity for.
06:44:38 <co_dh> :i ap
06:44:49 <co_dh> :t ap
06:44:50 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
06:45:41 <Twey> Fuco: Psst, ‘fold (+) 0’ is called ‘sum’
06:46:11 <Fuco> yea, I wanted to show what +/ does tho :P
06:46:23 <merijn> I thought "sum" was called "sum" :p
06:46:53 <Twey> Fuco: It does sum :þ
06:47:17 <Fuco> you're right. I can't argue with that :D
06:47:22 <Fuco> bullet proof logic :)
06:47:32 <Twey> Haha
06:49:46 <co_dh> > ap id length [1..3]
06:49:47 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
06:49:55 <geheimdienst> > uncurry (/) (sum &&& length) [10..20]
06:49:56 <lambdabot>   Couldn't match expected type `(a, c)'
06:49:56 <lambdabot>         against inferred type `[a1] -...
06:50:12 <geheimdienst> > uncurry (/) $ (sum &&& length) [10..20]
06:50:13 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
06:50:13 <lambdabot>    arising from a use o...
06:50:26 <benmachine> *genericLength
06:50:36 <geheimdienst> > uncurry div $ (sum &&& length) [10..20]
06:50:37 <lambdabot>   15
06:50:43 <co_dh> > (sum &&& length ) [10.20] >>> uncurry (/)
06:50:43 <geheimdienst> good enough :)
06:50:44 <lambdabot>   Couldn't match expected type `(GHC.Types.Int, c)'
06:50:44 <lambdabot>         against inferred ...
06:51:18 <co_dh> > (sum &&& length ) [10.20] >>> uncurry div
06:51:19 <lambdabot>   Couldn't match expected type `(GHC.Types.Int, c)'
06:51:19 <lambdabot>         against inferred ...
06:51:36 <co_dh> > ((sum &&& length ) [10.20]) >>> uncurry div
06:51:37 <lambdabot>   Couldn't match expected type `(GHC.Types.Int, c)'
06:51:37 <lambdabot>         against inferred ...
06:51:46 <co_dh> > (sum &&& length ) [10..20] >>> uncurry div
06:51:47 <lambdabot>   Couldn't match expected type `(GHC.Types.Int, c)'
06:51:48 <lambdabot>         against inferred ...
06:51:52 * geheimdienst hands co_dh a dot
06:55:00 <co_dh> > ((sum &&& length) >>> uncurry div ) [10..20]
06:55:01 <lambdabot>   15
06:55:23 <copumpkin> ugh forward composition
06:55:36 <geheimdienst> > (sum &&& length) >>> uncurry div $ [10..20]
06:55:37 <lambdabot>   15
06:55:50 <copumpkin> uncurry (/) . (sum &&& genericLength) $ [10..20]
06:55:56 <benmachine> > uncurry (/) (sum &&& genericLength $ [10 .. 20])
06:55:57 <lambdabot>   15.0
06:56:10 <benmachine> > uncurry (%) (sum &&& genericLength $ [10 .. 20])
06:56:11 <lambdabot>   15 % 1
06:56:46 <lars9> @instances Monad
06:56:47 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
06:57:04 * ddarius tries to figure out how to rate limit his motes.
06:57:30 <lars9> > interate reverse [1..3]
06:57:31 <lambdabot>   Not in scope: `interate'
06:57:38 <lars9> > iterate reverse [1..3]
06:57:39 <lambdabot>   [[1,2,3],[3,2,1],[1,2,3],[3,2,1],[1,2,3],[3,2,1],[1,2,3],[3,2,1],[1,2,3],[3...
06:59:22 <kolmodin> hackage is down?
06:59:22 <lambdabot> kolmodin: You have 3 new messages. '/msg lambdabot @messages' to read them.
07:01:48 <co_dh> yes, hackage is down
07:02:29 <co_dh> http://twitter.com/haskellorg/status/10846088751742976
07:03:00 <McManiaC> what is the most lightwight standalone http server available currently?
07:03:18 <mauke> netcat
07:05:32 <kolmodin> co_dh: ah, thanks
07:07:23 <co_dh> { echo -ne "HTTP/1.0 200 OK\r\n\r\n"; cat some.file; } | nc -l 8080
07:07:26 <co_dh> lol
07:08:42 * ddarius constructs a simple condition variable out MVars.
07:08:47 <McManiaC> mauke: haskell lib ofc :)
07:11:13 <co_dh> @hoogle \s f g x -> f x ( g x )
07:11:13 <lambdabot> Parse error:
07:11:13 <lambdabot>   --count=20 "\s f g x -> f x ( g x )"
07:11:13 <lambdabot>              ^
07:12:07 <ddarius> MVar [MVar ()]
07:14:01 <co_dh> do we have a S ( of SKI)  combinator in Haskell ? 
07:14:15 <ddarius> ap
07:14:19 <ddarius> or (<*>)
07:15:15 <Twey> 14:43:10 < Twey> co_dh: Isn't S f x (g x) = ap?
07:15:47 <co_dh> Yes, thanks.
07:16:23 <Twey> @hoogle (a -> b -> c) -> (a -> b) -> c
07:16:23 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
07:16:23 <lambdabot> Data.Data gmapQl :: Data a => (r -> r' -> r) -> r -> (d -> r') -> a -> r
07:16:23 <lambdabot> Data.Data gmapQr :: Data a => (r' -> r -> r) -> r -> (d -> r') -> a -> r
07:16:42 <Twey> Hm
07:16:57 <zygoloid> yeah, the pure and <*> of the Applicative ((->) r) instance are exactly K and S. i've often wondered if there's something deep going on there
07:16:57 <Twey> Oh, right
07:17:03 <co_dh> hehe, that's why I can't hoggle it. 
07:17:05 <Twey> @hoogle (a -> b -> c) -> (a -> b) -> a -> c
07:17:05 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
07:17:06 <lambdabot> Data.Data gmapQl :: Data a => (r -> r' -> r) -> r -> (d -> r') -> a -> r
07:17:06 <lambdabot> Control.Parallel.Strategies parZipWith :: Strategy c -> (a -> b -> c) -> [a] -> [b] -> [c]
07:17:12 <ddarius> zygoloid: Look up bracket abstraction.
07:17:56 <zygoloid> ddarius: thanks! :)
07:18:08 <co_dh> which bracket abstraction? google gives Efficient Bracket Abstraction.
07:18:15 <co_dh> a link zygoloid?
07:18:20 <Twey> @hoogle (c -> a -> b) -> (c -> a) -> (c -> b)
07:18:20 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
07:18:20 <lambdabot> Data.Data gmapQl :: Data a => (r -> r' -> r) -> r -> (d -> r') -> a -> r
07:18:21 <lambdabot> Control.Parallel.Strategies parZipWith :: Strategy c -> (a -> b -> c) -> [a] -> [b] -> [c]
07:18:25 <Twey> How strange
07:18:35 <Twey> Why doesn't it find ap?
07:18:49 <Twey> Also, why does on keep turning up?  They do seem quite similar…
07:28:46 <ddarius> When in doubt, abstract.
07:29:22 <geheimdienst> ... then end up with 4000 levels of abstraction
07:29:52 <ddarius> Invest in inlining.
07:30:04 <sipa> ... then end up with (let x = S x in x) levels of abstraction
07:30:06 <Twey> Heh
07:33:04 <wippler__> hackage.haskell.org seems to be down..
07:33:34 <Rutix> Apparently {darcs,hackage}.haskell.org is out for the day -- announced
07:33:34 <Rutix> on Reddit but not here.
07:33:37 <Saizan> sipa: using let explicitly is so low level: fix S
07:33:58 <sipa> Saizan: :)
07:34:06 <co_dh> what's wrong with abstraction? genheimdienst?
07:34:31 <wippler__> Ok.. didnt know that.. thanks Rutix
07:37:38 <Plevoscoba> hello there
07:37:58 <Plevoscoba> I've a little question: Do yoy know how can I use wxHaskell on a mac?
07:38:14 <Plevoscoba> I think the problem comes from wxCore.
07:46:30 <ddarius> @hoogle minimumBy
07:46:30 <lambdabot> Data.Foldable minimumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a
07:46:30 <lambdabot> Data.List minimumBy :: (a -> a -> Ordering) -> [a] -> a
07:47:13 <ddarius> @hoogle comparing
07:47:13 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
07:47:29 <Plevoscoba> ddarlus, do you use wxHaskell?
07:48:44 <ddarius> Pestering random people is not the most effective way to use IRC.
07:50:42 <Plevoscoba> My university teacher told me to ask on IRC cause he doesn't kon how to fix my problem.
07:50:47 <Plevoscoba> So I try.
07:51:42 <masak> Plevoscoba: I don't have a solution to your problem, but I can't help but notice that your question is vague.
07:51:52 <masak> Plevoscoba: maybe clarify a bit?
07:52:26 <Plevoscoba> Ok, I have a haskell code which use wxHaskell for the GUI
07:52:32 <Plevoscoba> It compiles
07:52:49 <Plevoscoba> but why y try to run it i got this error:
07:53:01 <Plevoscoba> Loading package wxcore-0.12.1.6 ... can't load .so/.DLL for: stdc++ (dlopen(libstdc++.dylib, 9): image not found)
07:54:38 <Saizan> Plevoscoba: does it work when you use ghc --make rather than ghci ?
07:56:23 <Plevoscoba> Hum, does it make a difference if I use a mac?
07:57:11 <sipa> .dylib is osx-specific, no?
07:57:52 <cheater99> Plevoscoba: see if you can find something like, oh, i dunno, libstdc++0.dylib or something
07:58:06 <cheater99> just search your file system for libstdc. then symlink.
07:59:25 <sbi> Plevoscoba: http://wewantarock.wordpress.com/2010/11/01/working-around-the-static-libstdc-restriction/
08:00:48 <Plevoscoba> cheater99 I've libstdc++.dylib not libstdc++0.dylib
08:01:24 <Plevoscoba> sbi thx, Ill read that.
08:01:36 <cheater99> well then i wonder why it can't open it
08:02:01 <Plevoscoba> yep... any clue about how to fix it?
08:02:14 <cheater99> well, i'm reading man dlopen right now
08:02:14 <Plevoscoba> cause I think it's a bad idea to rename it.
08:02:23 <cheater99> i said symlink, not rename
08:02:25 <cheater99> but yeah, don't touch it
08:02:33 <cheater99> see if the path it's at is inside your LD_LIBRARY_PATH
08:02:41 <Plevoscoba> sorry, I don't know symlike.
08:02:46 <cheater99> symlink.
08:03:17 <Plevoscoba> sorry yes.
08:07:35 <cheater99> so again
08:07:37 <cheater99> see if the path it's at is inside your LD_LIBRARY_PATH
08:09:00 <Plevoscoba> I'll try to understand what you say :)
08:09:14 <mpiechotka> Is there any mirror of hackage?
08:09:30 <jmcarthur> i don't like it when hackage is down :\
08:09:46 <Plevoscoba> Yep, down actually
08:09:59 <jmcarthur> Plevoscoba: it was planned at least
08:10:05 <Plevoscoba> ok
08:11:10 <mpiechotka> jmcarthur: When will it be back?
08:14:35 <Plevoscoba> Ok, so I realy don't understand the problem
08:16:04 <jmcarthur> mpiechotka: i don't think that was specified. yesterday on reddit there just a thing saying that hackage would be down today
08:16:19 <jmcarthur> mpiechotka: i would go check the thread, but reddit ironically seems down at the moment, too
08:16:31 <jmcarthur> mmm... *coincidentally
08:18:21 <jmcarthur> on the one hand, reddit being down means i could be more productive, but on the other hand, hackage being down hurts
08:18:33 <jmcarthur> checking hackage for existing work is a regular part of my workflow
08:18:44 <jmcarthur> kind of crazy that it's really that often
08:19:08 <jmcarthur> i've never quite coded this way in other languages, where libraries tend to be more for "bigger" things than the typical hackage package
08:19:41 <ndm> http://www.downforeveryoneorjustme.com/hackage.haskell.org
08:19:41 <dankna> I like this strategy better though
08:19:41 <lambdabot> ndm: You have 4 new messages. '/msg lambdabot @messages' to read them.
08:19:45 <dankna> small libraries are more reusable
08:19:48 <jmcarthur> i also think learning how to use a library in haskell tends to be easier than in other languages
08:19:56 <dankna> I tend to agree
08:20:06 <jmcarthur> type signatures help a lot. also lots of common interfaces
08:20:14 <ndm> hackage seems down, which is rather sad :-(
08:20:22 <ndm> does anyone in here know how to kick the server?
08:20:27 <jmcarthur> ndm: yeah, it was planned but only announced on reddit yesterday :\
08:20:47 <jmcarthur> ndm: it's due to some electrical work going on at galois i think
08:21:11 <ndm> announced on reddit, not the haskell announcements list...
08:21:16 <jmcarthur> yeah :(
08:21:27 <jmcarthur> it would be nice for somebody to at least make a torrent when hackage is about to go down, IMO
08:21:30 <dankna> I reiterate my offer to host a backup if we can figure out how to do the mirroring
08:21:37 <ndm> that sucks a lot, i was going to devote all of today to indexing all of Hackage with Hoogle
08:21:44 <jmcarthur> dankna: that would be awesome
08:21:50 <jmcarthur> ndm: oh suckage!
08:21:57 <dankna> yeah - I've got a lot of bandwidth eating a hole in my pocket
08:22:13 <dankna> the last time I mentioned it there wasn't that much interest I think
08:22:17 <ndm> and reddit is down right now as well, under heavy load...
08:22:27 <jmcarthur> ndm: yeah i know. funny
08:22:41 <jmcarthur> dankna: there's always more interest when hackage is down. now is the time to push it
08:22:54 <dankna> haha, point
08:23:00 <dankna> who would I even need to talk to?  dons?
08:23:07 <jmcarthur> dunno. start with the mailing list?
08:23:13 <dankna> good plan
08:24:04 <orlandu63> it'd be nice if there were an rsync mirror for hackage
08:24:16 <mpiechotka> jmcarthur: Thanks - I stopped reading regedit due to large amount of duplicates of Haskell planet + hard to get the original link. Also IIRC it is not an official channel (it is not even written in topic of this channel)
08:25:57 <Cin> I officially suck at programming in languages other than Haskell. It took me hours to come up with the first piece of code yesterday. I decided to rewrite it in Haskell just now and it took about 2 minutes to write and I tested it and it worked as expected: http://paste.lisp.org/display/117319
08:27:01 <ndm> (/=EQ).(cmp n) - looks like /= to me (although you may by spec have to pass a comparison operator)
08:28:08 <Cin> True, that can be reduced.
08:29:54 <Cin> not.(cmp n)
08:33:37 <medfly> yeah, writing in something besides Haskell is annoying. I find myself trying to write foldr and such.
08:33:55 <Cin> http://hpaste.org/raw/42065/parse :D
08:33:56 <haskeller> yeah, its a killer
08:36:18 <Cin> Woops, that should be: http://hpaste.org/raw/42067/fixfix
08:37:34 <haskeller> hey, i'm doing a little bit manipulation on 32-bit integers... should I use the Data.Word or is it's fine without it? Doing most bitwise operations in integers to compute sign, absolute val, if its a power of two... stuff like that
08:38:07 <haskeller> *on integers, damn keyboard
08:40:16 <benmachine> haskeller: if you want 32 bits guaranteed, you should probably work with Int32 rather than Int (or Word32 rather than Word)
08:40:19 <byorgey> haskeller: technically, the Haskell standard only mandates that Int must have a range of at least +/- 2^29
08:41:15 <byorgey> although I think most implementations actually give you a normal 32-bit (or 64-bit) signed integer
08:41:57 <jmcarthur> is there a torrent of the hackage packages hanging around anywhere
08:41:59 <jmcarthur> ?
08:42:03 <haskeller> Yes, that is a concern byorgey
08:42:20 <jmcarthur> there have been torrents a few of the past times that hackage was down
08:43:25 <haskeller> thank you both.
08:44:10 <sshc> What library should I use to run programs in a sandboxed environment, in which unsafe functions and IO aren't available (but a more restrictive IO monad is)?
08:45:00 <aavogt> you could do what codepad does
08:45:03 <Jafet> You want IO... without IO?
08:45:17 <aavogt> otherwise modify whatever mueval does
08:46:26 <dankna> and definitely look at the list of clever exploits on the lambdabot homepage
08:46:39 <dankna> there are things like DoS by supplying expressions that don't terminate
08:50:41 <aavogt> sshc: and there may be some IO available at http://tryhaskell.org/
08:51:35 <jmcarthur> just by the way everybody, if you need a package from hackage, you can browse <http://bifunctor.homelinux.net/~roel/hackage/packages/archive/pkg-list.html> and see if the package page there has a link to a homepage or repo. no downloads, unfortunately, but it does seem quite up to date
08:52:02 <byorgey> thanks jmcarthur 
08:52:16 <jmcarthur> aaaand it just occurred to me that this poor guy's home connection might crawl a little today :\
08:54:43 <dankna> eep no kidding haha
08:56:39 <aavogt> or this hackage that may not be as up-to-date http://sparky.haskell.org:8080/packages/
08:57:02 * ddarius can write code without being able to compile.
08:57:05 * ddarius just needs docs.
08:58:02 <jmcarthur> local cabal docs ftw!
08:58:03 <aavogt> ddarius: you don't ever make wrong assumptions about what is legal?
08:58:10 * byorgey is thankful he set .cabal/config to build local docs a long time ago
08:58:17 * jmcarthur is too
08:58:30 <dankna> likewise
08:58:48 <ddarius> That doesn't help when you don't have the package at all.
08:58:55 <ddarius> I don't need docs if I've got source.
08:59:10 <byorgey> true.
08:59:51 * ddarius thinks he has the SDL package installed on his old laptop.
09:02:53 <jmcarthur> ddarius: http://mirror.seize.it/hsSDL/hssdl/
09:03:36 <crutcher> I've started doing development with Data.Enumerator; and I've got a stack of Iteratee compositions that diverge.
09:03:57 <crutcher> I'm trying to find some sources on debugging Enumerators and Iteratees
09:04:52 <crutcher> I'm looking at writing an Iteratee wrapper that checks for divergence, and wrapping each piece of the stack, but if there's already a well know one, that would be preferable
09:04:57 <crutcher> anyone know of something?
09:05:10 <sshc> What does tryhaskell / lambdabot use to run code in a sandboxed environment?
09:05:24 <ddarius> > fix id
09:05:27 <lambdabot>   mueval-core: Time limit exceeded
09:05:38 <jmcarthur> sshc: mueval
09:05:43 <jmcarthur> sshc: that's lambdabot anyway
09:05:47 <jmcarthur> not sure about tryhaskell
09:06:49 <Twey> mueval as well, I believe
09:07:00 <mreh> type Option = Monad m => Options -> m Options
09:07:05 <mreh> what's wrong with that?
09:07:07 <crutcher> ddarius: is that meant for me?
09:07:23 <crutcher> oh, is haskell.org down again?
09:07:24 <dankna> I think there was something about them having forked from each other some time in the past and reunification being underway
09:07:37 <Saizan> mreh: that m is not in scope
09:08:08 <mreh> Saizan: can I make it universal/
09:08:12 <jmcarthur> sure
09:08:14 <Saizan> mreh: "type Option = forall m. Monad m => Options -> m Options" works with some extension
09:08:26 <jmcarthur> Rank2Types/RankNTypes
09:08:31 <mreh> Saizan: can I make it universal/
09:08:33 <mreh> upps
09:09:24 <Saizan> make sure you understand higher rank polymorphism if you use that, though :)
09:12:36 <crutcher> hmm, okay, it's only hackage that's down
09:13:11 <mreh> ImpredicativeTypes
09:13:18 <mreh> what's that
09:13:34 <ddarius> Something you probably neither need nor want.
09:14:02 <crutcher> wow, dev is really a pain without the hackage docs
09:14:19 <mreh> crutcher: local install!
09:14:30 <mreh> set you cabal to download them
09:14:47 <crutcher> mreh: that totally helps ... if I know what package I'm looking for
09:15:12 <crutcher> what I _really_ want is to be able to browse help through ghci
09:15:18 <mreh> crutcher: well you'll find it hard to download the packages too if hackage is down
09:15:28 <crutcher> yes, that is also true
09:15:55 <mreh> can haskell not afford better hosting?
09:16:00 <crutcher> it's sort of my point ... one website goes down, and developing in haskell becomes much more difficult
09:16:15 <mreh> better hosting is expensive
09:16:20 <jmcarthur> crutcher: look up package at <http://bifunctor.homelinux.net/~roel/hackage/packages/archive/pkg-list.html>, see if it has a link to a homepage or repo, download from there
09:16:24 <mreh> I presume this is being hosted as a favour
09:16:50 <aristid> hackage.haskell.org is down?
09:16:51 <jmcarthur> crutcher: dankna is trying to offer to mirror it in the future. i hope somebody takes him up on that
09:16:59 <mreh> Illegal polymorphic or qualified type
09:17:02 <jmcarthur> aristid: it was accounced yesterday, but only on reddit... :\
09:17:09 <mreh> type Option = forall m. Monad m => Options -> m Options
09:17:12 <jmcarthur> *announced
09:17:48 <jmcarthur> crutcher: use hackage locally to build docs :)
09:17:52 <jmcarthur> err
09:17:54 <geheimdienst> http://twitter.com/haskellorg/status/10846088751742976
09:17:55 <jmcarthur> crutcher: *haddock
09:18:25 <crutcher> jmcarthur: yes, but I want something more python like; I want to be able to get docs on modules and funcs in ghci
09:18:32 <jmcarthur> oh i see
09:18:39 <jmcarthur> i would like that too
09:18:42 <Saizan> crutcher: hoogle --info does that
09:18:53 <mreh> @hoogle blub
09:18:54 <lambdabot> No results found
09:19:04 <jmcarthur> assuming you have hoogle installed
09:19:08 <jmcarthur> i don't :\
09:19:10 <Saizan> assuming you have the hoogle cli and a sufficiently populated database
09:19:29 <ddarius> It seems I do not have SDL on my old laptop.
09:19:46 <mreh> did anyone see that type error I was getting?
09:19:52 <mreh> bizzare, non?
09:20:00 <crutcher> Saizan: a) what? I need that. b) that's not a replacement for docs in the repl; c) I'd do it myself ... if I understood enough yet
09:21:04 <ddarius> crutcher: There are ways to get hoogle in the GHCi.  In fact, GHCi's :def command is rather powerful.  It would be no problem to make a database of documentation that's accessible by such a command.
09:21:14 <ddarius> It will never be quite like python though.
09:21:25 <jmcarthur> ddarius: i linked you to the SDL repo above
09:21:25 <crutcher> ddarius: why not?
09:21:38 <ddarius> jmcarthur: A really old one.
09:21:42 <jmcarthur> oh?
09:21:48 <jmcarthur> that's the one linked to from hackage
09:21:53 <ddarius> crutcher: Because Haskell doesn't have doc strings or reflection.
09:22:14 <jmcarthur> ddarius: it was last modifed Nov. 1
09:22:21 <ddarius> Perhaps it's just the doc folder has old stuff in it.
09:23:08 <morricone> is there a mirror of hackage.haskell.org somewhere?
09:23:15 <jmcarthur> morricone: no
09:23:36 <Twey> Haha
09:23:42 <crutcher> ddarius: true; but we the haddock parser
09:23:46 <jmcarthur> morricone: but you can browse the packages at <http://bifunctor.homelinux.net/~roel/hackage/packages/archive/pkg-list.html>, look for links to project homepages/repos, then download from there
09:24:01 <crutcher> ddarius: and ghci has enough reflection to let things like :t and :k work
09:24:04 <jmcarthur> morricone: no docs or downloads at that link, but if you can get the package locally you can manage all that yourself
09:24:21 <ddarius> crutcher: Yes, but that requires source and won't know anything about what is actually in scope.
09:24:33 <Saizan> crutcher: http://community.haskell.org/~ndm/hoogle/
09:25:08 <crutcher> ddarius: yes. suppose we compile annotation information at make time for the libs; and drop them in a place in the package tree where ghci can find them
09:26:01 <crutcher> ddarius: it is a bit messy ... but so is ghci anyway
09:27:11 <crutcher> Saizan: yeah, that's hosted on hackage :)
09:28:04 <Saizan> crutcher: both http://www.haskell.org/hoogle/ and http://code.haskell.org/hoogle/ work currently
09:28:34 <Eduard_Munteanu> Is (>>) in IO strict?
09:28:42 <Saizan> http://holumbus.fh-wedel.de/hayoo/hayoo.html too
09:28:44 <crutcher> Is there a tip jar for hackage? I'd be willing to sign up to a recurring paypal subscription to foot part of the hosting costs
09:29:09 <Eduard_Munteanu> I'm getting a stack overflow when using a normal foldl' to chain IO actions.
09:29:24 <ddarius> crutcher: Hackage is hosted by Galois.  It's down for maintenance not because it couldn't be afforded.
09:29:29 <Eduard_Munteanu> It can be fixed by using seq, but IO doesn't seem to work alright.
09:29:33 <jmcarthur> yampa is at the top of the gamedev reddit today... here comes a storm of "that's ugly and confusing!" comments...
09:29:45 <Saizan> http://haskellorg.wordpress.com/2010/11/15/the-haskell-org-committee-has-formed/ <- relevant
09:29:50 <ddarius> Yampa is ugly and confusing.
09:29:51 <crutcher> ddarius: I don't understand 'down for maintenance' in 2010
09:29:57 <aristid> jmcarthur: well, FRP is not ready for primetime :)
09:30:05 <jmcarthur> aristid: i said as much
09:30:11 <ddarius> crutcher: I guess you're like me and don't read reddit.
09:30:13 <jmcarthur> aristid: http://www.reddit.com/r/gamedev/comments/eg5jy/the_yampa_arcade_implementing_space_invaders_with/
09:30:25 <Eduard_Munteanu> Maybe you could take a look at this: http://paste.pocoo.org/show/300292
09:30:25 <merijn> I can't wait for dependently typed FRP to "Just Work" :p
09:30:31 <Eduard_Munteanu> I'm using B.foldl' in doCompress
09:30:54 <Eduard_Munteanu> The reason I'm doing so is because ByteString isn't Foldable.
09:30:55 <aristid> jmcarthur: are you geezusfreak?
09:30:56 <jmcarthur> merijn: there is some dependently typed frp research, but is there a particular reason you are singling out dependently typed frp here?
09:31:00 <jmcarthur> aristid: yeah
09:31:29 <crutcher> Saizan: oh god. Who's brilliant idea was the "Get a big server" plan? Big servers are ALWAYS a pita
09:31:29 <Eduard_Munteanu> I'm not sure about this bit: B.foldl' (compress t p) (return ()) inp
09:31:38 <merijn> jmcarthur: Well, if I'm gonna wish why be modest and pick only dependent typing or FRP :p
09:31:45 <jmcarthur> heh
09:31:50 <Eduard_Munteanu> where... compress t p act w = act >> compress' t p (fromIntegral w)
09:31:59 <jmcarthur> the difference is that dependently typed programming languages *work*
09:32:01 <Eduard_Munteanu> Am I even supposed to do this?
09:32:04 <ddarius> When did Haskell.org get a larger social networking presence than me?
09:32:29 <merijn> jmcarthur: For academic values of work, yes
09:32:58 <merijn> I haven't seen a dependently typed language suitable for doing actual work in yet
09:33:20 <Saizan> they even have web framworks in agda, that's already too pratical :P
09:33:21 <ddarius> What about Coq?
09:33:47 <Eduard_Munteanu> I think actual work == programming, not proving stuff.
09:33:49 <megatron342> Hi, is there a way to use Data.Map with a custom < operator?
09:33:59 <mauke> megatron342: make a custom Ord instance
09:34:05 <ddarius> Ugh, wget -r went a little crazy.
09:34:21 <jmcarthur> merijn: i think agda would be perfectly practical with more libraries, for one
09:34:45 <jmcarthur> merijn: especially once it gets this new compiler than seems to be under development now
09:34:54 <megatron342> mauke: How do I do this? Can you please elaborate?
09:35:04 <Eduard_Munteanu> @src Ord
09:35:05 <lambdabot> class  (Eq a) => Ord a  where
09:35:05 <lambdabot>     compare      :: a -> a -> Ordering
09:35:05 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
09:35:05 <lambdabot>     max, min         :: a -> a -> a
09:35:10 <merijn> jmcarthur: "if it had more libraries" like I said, dependently typed languages only work for academic values of work :p
09:35:25 <jmcarthur> merijn: i'm making a distinction between language and library here
09:35:26 <Eduard_Munteanu> megatron342: your write your own "instance Ord YourType"
09:35:40 <jmcarthur> merijn: infrastructure is of course just as important, but the language isn't the problem here
09:35:59 <megatron342> OK, I'll do some googling. Thanks
09:36:08 * ddarius just realized that if he wants to make all these people go away, all he has to do is make sure hackage never comes back up.
09:36:20 <Eduard_Munteanu> Hah, it's down.
09:36:23 <jmcarthur> these people?
09:36:44 <merijn> jmcarthur: I agree that the *actual language* is not really a problem, but the language as in ecosystem is.
09:36:47 <jmcarthur> those focused on "practical" things?
09:37:03 <ddarius> All these people who weren't here in 2002.
09:37:04 <jmcarthur> merijn: yeah, i just don't tend to call that "the language"
09:37:12 <jmcarthur> ddarius: i wasn't here in 2002 :(
09:37:16 <Eduard_Munteanu> Heh.
09:37:18 <merijn> Although I haven't looked at Agda much yet, I hope its syntax is better then Coq
09:37:31 <ddarius> merijn: It is.
09:37:32 <jmcarthur> syntax schmyntax
09:37:39 <jmcarthur> but yes, it's a lot nicer, IMO
09:37:52 <Eduard_Munteanu> Ok guys, now please help a guy with a practical problem ^^
09:37:57 <Eduard_Munteanu> :P
09:38:03 <jmcarthur> Eduard_Munteanu: practical problems make ddarius hate you
09:38:06 <merijn> If I didn't care about syntax I'd probably have learned Lisp and never got to Haskell :p
09:38:35 <companion_cube> lisp has no syntax
09:38:36 <Saizan> > (undefined >> return () :: IO ()) `seq` ()
09:38:37 <lambdabot>   ()
09:38:41 <ddarius> companion_cube: It surely does.
09:38:52 <jmcarthur> lisp is nothing *but* syntax
09:38:55 <Saizan> it's not very strict.
09:39:08 <companion_cube> i mean, lisp syntax is as small as possible
09:39:09 <newsham> if i didnt care about semantics, i'd probably have used lisp.
09:39:15 <ddarius> companion_cube: That's completely false.
09:39:28 <merijn> companion_cube: Small syntax is not no syntax. In addition who says small syntax is better syntax?
09:39:35 <Eduard_Munteanu> Saizan: thanks. But I already tried... compress t p act w = act >> act `seq` compress' t p (fromIntegral w)
09:39:41 <ddarius> newsham: What have you been up to lately?
09:39:43 <companion_cube> well, what is in it apart from S-expr ?
09:39:45 <jmcarthur> lisp syntax is as complicated as you make it. it's designed to be that way
09:39:51 <companion_cube> merijn, i never said it was better
09:39:53 <Eduard_Munteanu> Saizan: it averts the stack overflow, but somehow I think it doesn't do the IO right.
09:40:10 <Eduard_Munteanu> I end up with far fewer characters in the output on bigger files.
09:40:16 <newsham> ddarius: some security consulting, some surfing, a little plan9 here and there, some reading... lotsa hanging w/ the kid, etc.
09:40:23 <Eduard_Munteanu> Is that foldl' misguided?
09:40:27 <haskeller> yes! 100/100 in my haskell class =)
09:40:27 <jmcarthur> every macro you define in lisp is new syntax, and macros tend to be used very often in lisp
09:40:28 <newsham> not too much haskell (well, a little a few months ago, writing a small web game)
09:40:58 <ddarius> companion_cube: Common Lisp's concrete syntax is probably more complicated than C's.  Furthermore, all the Lisps have quite a bit of syntax, i.e. special forms (not even counting macros.)
09:41:10 <Saizan> Eduard_Munteanu: it's not easy to see what you're trying to do from that code
09:41:22 <ddarius> companion_cube: In comparison, Joy or Forth have a much smaller and not just superficially simple syntax.
09:41:23 <companion_cube> ddarius, i do not count primitives in the syntax
09:41:46 <jmcarthur> i've not used common lisp, but "more complicated than C's" sounds shocking to me
09:41:50 <companion_cube> neither macros, since they are exactly the same as functions from syntactic point of view
09:41:53 <newsham> hmm.. more complicated than C?  i've never written a lisp (or even scheme) parser, but I woulda thought it would be much simpler than C's (even with the macros and stuff)
09:41:57 <ddarius> companion_cube: lambda is not a primitive.
09:42:00 <Eduard_Munteanu> Saizan: short story... the program is doing Shannon-Fano compression. It should map over each Word8 in the input, but I want to avoid unpacking the bytestring.
09:42:11 <ddarius> newsham: CL is not a simple language.
09:42:13 <companion_cube> ok, you have lambda, let and application
09:42:20 <newsham> *nod* that much I know :)
09:42:28 <companion_cube> lisp is nothing but untyped lambda calculus with macros
09:42:37 <companion_cube> which is quite simple
09:42:38 <ddarius> companion_cube: And progn and if and defun and ...
09:42:39 <Eduard_Munteanu> Saizan: so I'm using a fold to avoid unpacking, it's just too slow otherwise. But ByteString has no foldable instance, hence no general foldM I can use.
09:42:49 <mauke> companion_cube: what, no string literals?
09:43:02 <newsham> i'm pretty sure lisp also has integers. :)
09:43:10 <Eduard_Munteanu> Saizan: I want to avoid lists because they won't fuse away.
09:43:12 <ddarius> CL even let's you have infinite source.
09:43:13 <companion_cube> ah ok, i'm more used to scheme
09:43:31 <Eduard_Munteanu> So I'm interlacing compression with writing the result.
09:43:37 <companion_cube> yeah, lambda calculus with some extensions
09:43:40 <Eduard_Munteanu> Hence the IO stuff.
09:43:45 <companion_cube> like any language that claims to be usable
09:43:48 <Eduard_Munteanu> (I'm packing bits into bytes)
09:43:53 <mauke> so, lisp is basically C
09:43:53 <ddarius> companion_cube: Scheme is much better than CL, but it's still far from trivial.
09:44:00 <newsham> i should learn more forth.
09:44:06 <mreh> what's the best lib for record syntax updates
09:44:19 <mreh> foo { bar = qux } is ugly
09:44:30 <ddarius> newsham: I imagine within the last seven years or so you've fiddled with Joy at one time or another.  If not, it's fun.
09:45:03 <newsham> does Data.Derive (niel mitchell's package) generate record updaters?
09:45:07 <jmcarthur> mreh: data-accessor is mature and is all i have experience with, but i've heard good things about fclenses
09:45:14 <newsham> i havent even heard of Joy.  I'll take a look
09:45:19 <mreh> fclabels?
09:45:22 <jmcarthur> yeah that
09:45:25 <jmcarthur> lenses is another thing
09:45:36 <newsham> on the other hand, forth is directly helpful to me since I use some openfirmware boxes.
09:45:37 <Eduard_Munteanu> Bananas FTW
09:46:08 <kstt> hi ! Has anyone here even used the EventMachine library for ruby ? From http://rubyeventmachine.com/ : EventMachine: fast, simple event-processing library for Ruby programs ?  I decided to try to use it to implement a low level http reverse proxy, after a week of relative failure with haskell.
09:46:31 <Trollinator> Hi
09:46:33 <ddarius> newsham: Forth is fun too, but I much prefer the way Joy, Postscript, and Factor handle control.
09:46:36 <mauke> has anyone really been far even as decided to use even go want to do look more like?
09:46:40 <jmcarthur> an ominous nick...
09:46:46 <Eduard_Munteanu> :)
09:46:52 <newsham> i've played with postscript a little in the past.
09:46:54 <newsham> but not enough.
09:47:03 <kstt> Therefore, I'm looking for some ideas about how to use this kind of event-driven programming in haskell.
09:47:20 <ddarius> newsham: The main problems with "standard" postscript is the library functions are written with "being run in a printer" in mind.
09:47:24 <Saizan> Eduard_Munteanu: the foldl' seems a fine approximation of mapM
09:47:28 <ddarius> In particular, the string handling is painful.
09:47:39 <Saizan> Eduard_Munteanu: well, mapM_
09:47:40 <merijn> kstt: I was looking for something like event-driven programming in Haskell after using Python's Twisted. After a few weeks I've realized my attempts were flawed
09:47:54 <ddarius> Other than that, the language itself is reasonably nice.
09:48:17 * ddarius doesn't understand why one would -want- event-driven programming.
09:48:54 <jmcarthur> i wonder if something like chp would appeal to somebody who actually likes event-driven programming
09:48:58 <merijn> kstt: My current approach is to do the following: Have 1 master thread, spawn 1 thread per input source, have the input threads post events to a Chan, have the master thread take them out the Chan and handle them
09:49:25 <ddarius> jmcarthur: Why would it?  It's threaded programming.
09:49:50 <ddarius> It's easy enough to implement an event system in terms of threads, if event dispatch -really- fits the problem.
09:50:02 <Trollinator> there is an instance declaration like instance Show a => Show [a] where ... somewhere, right? On the other hand, Strings aren't formatted this way when you use show. For example, show "foo" ought to produce [
09:50:09 <ddarius> Usually event-based approaches are used because threads are expensive.
09:50:10 <Trollinator> ['f','o','o']
09:50:11 <merijn> ddarius: What's wrong with event-driven programming? I can't really think of any other way to tackle some issues (except maybe FRP, which as discussed earlier is not really realistic atm)
09:50:14 <jmcarthur> ddarius: because people who like to use libraries for event-driven programming would probably think chp is cool, that's all
09:50:22 <Trollinator> but it doesn't, how did they do that? 
09:50:24 <newsham> ddarius: *nod* but even so, if you just use a ps viewer its not so bad for small things... though i did really miss having some kinda interactiv econsole
09:50:25 <kstt> merijn: Hi. Twisted looks very similar to eventmachine indeed ! Why are your attempts flawed ?
09:50:32 <newsham> which i imagine "gs" could do if I looked hard enough
09:50:56 <ddarius> newsham: gs works for that somewhat.
09:50:58 <merijn> kstt: Because haskell's thread (and the new GHC7 IO manager) make it easier to do it using threads and channels
09:51:22 <Saizan> Trollinator: via the showList method
09:51:26 <merijn> ddarius: How is have a master thread with a Chan receiving input from multiple threads any different from event-driven programming for example?
09:51:38 <Eduard_Munteanu> Saizan: yeah a mapM_. However I'm not sure if it's something in my packer that's causing it (like misusing IO), or this chaining.
09:51:53 <Trollinator> Saizan: oh, OK, so there's some show-specific hack in there. 
09:51:59 <kstt> merijn: but that require threading. What I find very interesting in raw event-driven programming is that is can handle much in a single thread.
09:52:09 <jmcarthur> kstt: haskell threads are *cheap*
09:52:16 <merijn> kstt: Yes, but Haskell threads are lightweight, they are not OS threads
09:52:23 <jmcarthur> almost unbelievably cheap
09:52:36 <kstt> jmcarthur: I can't believe it :)
09:52:36 <merijn> Supposedly GHC7 can handle about 100k+ IO threads
09:52:51 <ddarius> merijn: It isn't.  It's an implementation of event-driven programming in terms of threads just like I said was easily done above.
09:52:52 <jmcarthur> kstt: and when a bunch of haskell threads are blocking they tend to share single calls to epoll/select/whatever
09:53:25 <jmcarthur> s/haskell/ghc
09:53:48 <kstt> but thread can be pre-empted, right ? That might be ok for my case, but is different from pure event based programming
09:53:49 <merijn> ddarius: You said you can't imagine why anyone would want to do event-driven programming. But for example writing a game server with multiple clients I can't really see any other way of doing it?
09:54:15 <merijn> Feel free to enlighten me if I'm wrong
09:54:31 <jmcarthur> kstt: ghc threads are pretty much ideal threads, IMO
09:54:58 <jmcarthur> kstt: m haskell threads to n OS threads, premptible, etc.
09:55:30 <Saizan> Eduard_Munteanu: i don't follow the logic in packBit, so i'd suspect that, you don't seem to be doing anything to weird with IO
09:56:14 <ddarius> merijn: Events and threads are "dual" in a sense, and a solution using events can be translated into a solution using threads and vice versa.
09:56:17 <kstt> jmcarthur: you can achieve to convince me if you point me to a simple and elegant implementation of a tcp proxy.
09:56:29 <kstt> That's really what I'm looking for.
09:57:06 <jmcarthur> seems to be a very specific request. not sure i can supply that
09:57:23 <kstt> I have been positively surprised by how short the ruby eventmachine code was short.
09:57:35 <merijn> ddarius: For a lot of things you will need a central place for input to go and output to be dispatched from. That is (to me) really what event-driven is about, whether its implemented using threads or what not
09:57:59 <kstt> (concurrent thoughts resulting in garbled grammar)
09:58:22 <newsham> whats that paper that shows the connection between event driven and thread programming in haskell?
09:58:36 <Eduard_Munteanu> Saizan: basically it makes room for a new bit shifting the accumulator to right, inserts the new bit on the MSB, then decreases the 'remaining bits' counter.
09:58:44 <ddarius> There are two I believe, plus a general one.  Li Peng's paper is pretty good.
09:58:46 <kstt> jmcarthur: well, it looks like a very standard use case for this kind of programming.
09:58:52 <Eduard_Munteanu> Saizan: when a complete byte has been produced, it's written and the counter is reset.
09:58:57 <newsham> http://lambda-the-ultimate.org/node/1435
09:59:14 <kstt> And so far, the eventmachine ruby tcp proxy performs much better than my best attempt with haskell threads.
09:59:15 <Saizan> Eduard_Munteanu: btw, with a Packer you've to go down a lot of indirections before you access the bits, using a record type with strict fields should be better
09:59:27 <kstt> which I find very disturbing :(
09:59:40 <Saizan> Eduard_Munteanu: also, you'd probably want larger chunks
09:59:41 <Eduard_Munteanu> I see.
09:59:43 <ddarius> merijn: I don't identify "having a central place for input to go and output to be dispatched" with event driven programming.  It doesn't really have anything to do with events.
09:59:48 <kstt> although most of the cycles happens in the c++ library
10:00:18 <newsham> kstt: make bindings to the same library using ffi?
10:00:21 <McManiaC> geee, how long will hackage be down?
10:00:23 <Eduard_Munteanu> I'll optimize that a bit later, I've seen using the input as a list is the major bottleneck so far.
10:00:39 <merijn> McManiaC: It's an announced maintenance outage
10:00:42 <jmcarthur> kstt: there's this, but i doubt it was ever tested for speed, etc. https://github.com/chrisdone/throttle
10:00:50 <McManiaC> merijn: I know
10:01:01 <McManiaC> that's why I ask, maybe someone knows :)
10:01:25 <jmcarthur> kstt: looks like it uses String instead of ByteString. that's going to be a performance hit right there
10:02:29 <kstt> jmcarthur: good catch, I'll have a look
10:02:44 <jmcarthur> kstt: oh, i'm wrong. seems to use ByteString after all
10:03:17 <jmcarthur> it is of course *intentionally* slow ;)
10:05:04 <kstt> jmcarthur: I see ... Nice strategy ! Next time my code performs badly, I'll add an option to control it, and advertise it as a feature ;)
10:05:30 <kstt> at least the code is really short. Looks good.
10:09:36 <lispy_> McManiaC: I expect it to be back by noon local time, so 2 more hours
10:09:43 <ddarius> Whenever I hear "Ruby/Tcl does X faster than <a language that isn't Ruby or Tcl>", I can only think "You're doing something wrong."
10:09:59 <lispy_> McManiaC: But, I can't recall if I heard the noon deadline for the last repair like this or this one.  So I may be wrong
10:10:10 <Rutix> TCL faster ? wut
10:10:40 <bremner> ddarius: unless that language is csh?
10:10:56 <McManiaC> lispy_: k, thanks
10:11:01 <geheimdienst> faster in programmer time, or what?
10:11:04 <newsham> ruby starts up faster than my bios! ;-)
10:11:22 <ddarius> What's wrong with your BIOS?
10:11:36 <mauke> ruby starts up faster than java
10:11:37 <ddarius> Does it use ruby?
10:11:49 <newsham> about 30yrs of legacy support and unreasonable hacks?
10:12:13 <ddarius> Well, as long as they were unreasonable hacks.
10:12:19 <lispy_> newsham: wow, that's wrong with my bios too!
10:12:24 <kstt> ddarius: I agree. But the whole thing is that ruby + eventmachine (c++ event lib with high performance network lib, with ruby bindings) leads to short and fast network systems.
10:12:34 <kstt> with little code
10:12:53 <lispy_> kstt: then write a binding for eventmachine for haskell and put it on hackage.
10:12:54 <kstt> that is my conclusion after 2 weeks working on a tcp/http proxy
10:13:47 <Jafet> bios doesn't matter unless you ever reboot
10:13:49 <kstt> most of this time was spent on an haskell attempt, the rest on the eventmachine thing.
10:14:08 <kstt> but I have not used chans, and was on ghc 6
10:14:22 <newsham> i think its hilarious that a quad core 2GHz cpu bsaed system would take 30-45 seconds to boot
10:14:24 <ddarius> kstt: What did you use if you didn't use Chans?
10:14:28 <jmcarthur> ghc 7 is nice :)  but warning: it's still new, and not everything supports it yet
10:14:58 <jmcarthur> newsham: cpu is probably the least important factor for boot times though
10:15:10 <ddarius> jmcarthur: Well everything else is faster too...
10:15:26 <kstt> ddarius: nothing at all, just network IO and forkIO
10:15:49 <newsham> jmc: awesome, then at least let the cpu run seti@home while booting ;-)
10:16:05 <jmcarthur> newsham: ha!
10:16:16 <jmcarthur> stick seti@home in the BIOS and go
10:16:26 <kstt> I'm a fairly bad haskell IO programmer to be honnest
10:16:28 <ddarius> seti@home is a silly project
10:16:39 <kstt> but I'm also a fairly bad ruby IO programmer :)
10:16:45 <newsham> ddarius: so is while(1) { idle(); }
10:16:50 <ddarius> Thank God for C++.
10:17:07 <ddarius> newsham: That's greener.
10:17:24 <newsham> true.
10:17:35 <newsham> but if we wante dot be green we wouldnt be using ia32
10:17:47 <dankna> what's less silly is the protein-folding one, I forget its name
10:17:51 <ddarius> newsham: True.
10:17:54 <newsham> (also whats with all the "other" cpus on my cpu and on my motherboard?)
10:17:59 <ddarius> Stack machines, the new wave!
10:18:00 <newsham> also prob way off topic now, sorry :(
10:19:03 <newsham> (did you know that my cpu has another cpu on it that is powered on when my cpu is powered off, that runs a web server even when my computer is turned off? with direct access to the NIC)
10:19:15 <lispy_> ddarius: how do you feel about einstein at home?
10:19:27 <ddarius> lispy_: I don't know what that is.
10:19:29 <ajnsit> is there a module in haskell to parse HTTP date formats?
10:19:40 <lispy_> ddarius: that one supports LIGO, the search for gravity radiation as predicted by general relativity
10:19:45 <newsham> better than einstein at the mall?
10:19:46 <ddarius> I do at least think the seti@home stuff is less silly than the MD5 cracking ones.
10:20:17 <ddarius> lispy_: That's fine, though I'm more partial to things like folding@home.
10:20:24 <revenantphx> I'm trying to figure out how the units for P = ρgh cancel out... at all.
10:20:35 <sshc> Does anybody know how much longer Hackage will be broken?
10:20:39 <sshc> I need documentation
10:21:03 <Jafet> I don't know why we'd want to look for aliens. I'd feel better about us cloaking our existing radio noise and stuff
10:21:04 <lispy_> ddarius: LIGO has similar problems to SETI.  What the search for should exist by our models, but with LIGO our sensors aren't precise enough and won't be for probably a decade, unless we get lucky and there is an event very close to use that produces a large wave while we're watching
10:21:05 <newsham> do docs get installed when you install a hackage?
10:21:19 <revenantphx> kg/m^3 * m/s^2 * m = kg/(m*s^2)
10:21:20 <revenantphx> what?
10:21:20 <kstt> newsham: I think so
10:21:21 <luite> do the distributed cryptographic cracking projects also collect data that can be used for further cryptanalysis of the algorithms, or do they just crack a single message?
10:21:53 <ajnsit> newsham, you need to enable it in cabal config
10:21:59 <lispy_> ddarius: LIGO is trying to pickup distortion of spacetime that is caused by things like blackholes orbiting each other
10:22:12 <ddarius> lispy_: I know what gravitational waves are.
10:22:16 <lispy_> ah cool
10:22:17 <benmachine> sshc: don't you get cabal to install docs?
10:22:21 <lispy_> most people don't
10:22:24 <mee> LIGO also is a very accurate train detector
10:22:32 <mee> ;)
10:22:37 <sshc> benmachine: What should I use for docs?
10:22:39 <lispy_> mee: heeh.  Yeah.  They also pickup noise from logging
10:22:42 <Jafet> luite: no, that isn't glamorous enough to get people to give you their cycles
10:22:51 <sshc> benmachine: I usually use Hackage's web interface?
10:23:04 <benmachine> sshc: do you have Documentation: True in .cabal/config?
10:23:17 <newsham> sshc: perhaps google cache has it?  what package?
10:23:23 <benmachine> sshc: if not I suggest turning it on although it's a bit late now :P
10:23:27 <dblhelix> question: what would be my data structure of choice if I want something like (Map k v, Map v k) such that for (vs, ks)  I always have that lookup k vs == Just v  ==>  lookup k vs == Just k ??
10:23:58 <sshc> newsham: zlib and mueval
10:24:05 <dblhelix> lookup k vs == Just v ==> lookup v ks == Just k , of course
10:24:12 <sshc> benmachine: I don't hav eit in my config
10:24:18 <sshc> benmachine: (Actually I do but it's commented out)
10:24:20 <byorgey> dblhelix: there is a package for this on hackage, which is unfortunately down today =(
10:24:27 <benmachine> sshc: oh, it might be default I'm not sure
10:24:39 <byorgey> dblhelix: the 'bimap' package IIRC
10:24:40 <sshc> benmachine: WHat's the best way to view documentation?
10:24:51 <benmachine> sshc: uhm, your web browser of choice?
10:24:53 <lispy_> dblhelix: You want a hierarchical map maybe?
10:25:05 <newsham> sshc: this http://webcache.googleusercontent.com/search?q=cache:http://hackage.haskell.org/packages/archive/zlib/0.5.2.0/doc/html/Codec-Compression-Zlib.html ?
10:25:05 <benmachine> sshc: normally I use hackage too but I have it locally installed in case of emergency
10:25:09 <sshc> benmachine: Can I use cabal to download documentation normally?
10:25:16 <dblhelix> byorgey: I'll have a look... thanks
10:25:25 <revenantphx> I think now that I understand haskell a bit better, I'll definitely rewrite my ant sim with it...
10:25:27 <sshc> newsham: The cache will work, thanks
10:25:30 <benmachine> sshc: you can build documentation using cabal from package sources
10:25:34 <revenantphx> There's just one issue :P.
10:25:35 <benmachine> sshc: 'cabal haddock'
10:25:45 <revenantphx> Sure, it can recycle old tree nodes in a tree and stuff like that but...
10:25:53 <benmachine> sshc: so any packages you already have installed, you probably still have the tarballs for, so you might be able to build/install docs for
10:25:59 <revenantphx> In this situation it'd have to recreate *every entry* in the list of ants
10:26:02 <revenantphx> since they always change 
10:26:08 <revenantphx> Oh well, I'll work it out.
10:26:10 <sshc> benmachine: If I set  documentation:true, will cabal automatically generate documentation?
10:26:22 <benmachine> sshc: it shoudl do yes
10:26:31 <benmachine> sshc: it doesn't hyperlink source which is annoying
10:26:31 <byorgey> dblhelix: http://bifunctor.homelinux.net/~roel/cgi-bin/hackage-scripts/package/bimap
10:26:39 <byorgey> dblhelix: http://code.haskell.org/bimap/
10:26:43 <benmachine> but it will run haddock on newly-installed packages and install them in docdir
10:27:09 <benmachine> sshc: there's no way to get cabal to generate docs for all your existing packages, except one-by-one
10:27:09 <revenantphx> I wish cabal would automatically doc every package I have >_>
10:27:11 <dom96> How can i use the HTTP package with https, is https even supported?
10:27:15 <revenantphx> benmachine: aww
10:27:24 <benmachine> not that I know of anyway
10:27:24 <sshc> benmachine: Where exactly *are* those docs? :)
10:27:29 <lispy_> dom96: IIRC, no it doesn't support it.
10:27:36 <lispy_> dom96: But, there are curl bindings that should
10:27:39 <benmachine> sshc: ~/.cabal/config has the default directories commented out in it
10:27:53 <byorgey> revenantphx: so set documentation : True in your .cabal/config
10:27:55 <benmachine> dom96: http-enumerator supports it
10:27:57 <lispy_> dom96: and http-enumerator supports https IIRC
10:28:00 <revenantphx> byorgey: where will it put it?
10:28:04 <benmachine> dom96: just plain HTTP tries to be lightweight
10:28:23 <dblhelix_> byorgey: thanks
10:28:25 <byorgey> revenantphx: in $prefix/share/doc  IIRC
10:28:26 <haskeller> !latest
10:28:28 <haskeller> ops, sorry
10:28:29 <sshc> benmachine: -- doc-index-file: $datadir/doc/index.html
10:28:37 <revenantphx> $datadir being?
10:28:38 <sshc> benmachine: Uh, where's $datadir?
10:28:43 <dom96> benmachine: lispy_: ahh, i will use that over curl then.
10:28:54 <benmachine> sshc: it's defined in there too
10:29:14 <benmachine> sshc: see the install-dirs sections
10:29:16 <lispy_> dom96: okay, you might check the .cabal file for http-enumerator, I think to get it to support https certain conditions have to be met at configure/compile time
10:29:16 <sshc> Ah,  so it'd be ~/.cabal/share/doc/
10:29:24 <benmachine> yes, that sounds likely
10:29:42 <benmachine> sshc: anything that came with GHC will probably have docs, too
10:29:53 <benmachine> in /usr/share/doc/ghc maybe
10:29:55 <dom96> lispy_: oh :\
10:30:25 <lispy_> dom96: the downside to using curl is that you have to bring in a C library dependency.  The upside is that curl supports everything and the curl devs are doing an adequate job at releasing security/bug fixes
10:30:56 <dom96> lispy_: Is there a way to do that automatically in my Apps .cabal file, so that users don't have to worry about changing anything?
10:31:35 <dom96> If not then i might as well go with curl.
10:31:39 <lispy_> dom96: Not that I know of.  Cabal doesn't provide you with enough sophistication to know how one of your dependencies was configured
10:31:47 <benmachine> I don't think http-enumerator's HTTPS support is optional
10:31:52 <benmachine> but how it gets it is optional
10:31:59 <lispy_> dom96: Well, look at the http-enumerator.cabal file before you take my word
10:32:00 <benmachine> i.e. it can either use the tls package or OpenSSL
10:32:11 <benmachine> http://bifunctor.homelinux.net/~roel/hackage/packages/archive/http-enumerator/0.2.1.2/http-enumerator.cabal
10:32:44 <lispy_> benmachine: ah!  See I based my conclusion off some #ifdefs I saw in the code.  Your explanation makes sense in light of that
10:33:52 <dom96> That's good. I suppose I will use http-enumerator. I wish hackage wasn't down...
10:34:11 <lispy_> Yeah, sorry hackage is down.   I thought they were going to use sparky during the outtage.
10:34:21 <benmachine> is sparky still up?
10:34:41 <benmachine> it is, can we use it?
10:34:43 <dom96> Is it a planned outage ?
10:34:55 <benmachine> yes
10:35:03 <dom96> I see.
10:35:09 <benmachine> http://twitter.com/haskellorg
10:35:30 <lispy_> benmachine: I don't know if sparky is up to date, does anyone have a recent hackage upload we can use to verify?
10:35:54 <aavogt> lispy_: you just have to find the most recent upload on sparky
10:36:10 <benmachine> it's not up to date, by the looks of things
10:36:12 <benmachine> http://sparky.haskell.org:8080/recent.rss
10:36:14 <dom96> benmachine: I need to look at my followers twitter feed more.
10:36:49 <kstt> I find the hackage is very often down anyway. With big companies getting into haskell, I wish they would offer some server space for more redundancy.
10:37:03 <benmachine> hackage isn't often down
10:37:13 <benmachine> code.haskell.org is, I think
10:37:18 <kstt> really ?
10:37:22 <benmachine> or community.haskell.org or whatever it is
10:37:22 <dons> yes, code.haskell.org does (due to its limited vpn skills).
10:37:28 <lispy_> community.haskell.org goes down all the time
10:37:30 <dons> its moving to the new-www.haskell.org machine (as a vpn)
10:37:37 <dons> grr. not vpn. :)
10:37:41 <dons> vm.
10:37:43 <lispy_> But, hackage is up pretty much all the time
10:38:00 <kstt> fair enough
10:38:04 <dons> transparent mirrors for hackage are on-going work. join #hackage for discussions
10:38:09 <lispy_> dons: Did we decide against having a backup hackage during the outage for some reason?
10:38:20 <revenantphx> How long is the outtage?
10:38:24 <dons> keep up to date on haskell.org stuff here: http://haskellorg.wordpress.com/ 
10:38:29 <dons> or on twitter.com/haskellorg
10:38:36 <dons> revenantphx: eta +7 hours 
10:38:43 <dons> ~5pm west coast.
10:38:59 <dom96> That's quite long :\
10:39:00 <kstt> I wanted some docs last month, on a combinator library for relational algebra, and the server has been down for 3 days IIRC.
10:39:02 <dons> lispy_: we just didn't get to it, with the www.haskell.org move 
10:39:18 <dons> dom96: the electricals in the building are being redone.
10:39:25 <lispy_> dons: ah, I see
10:39:33 <dons> kstt: hackage wasn't down for 3 days.
10:39:37 <dom96> oh. Well then that's understandable.
10:39:51 <dons> it was down for 6 hours when they first found the electrical issue; then today for the repair
10:40:00 <dons> that's the only downtime since the new machine last year, afaik
10:40:02 <lispy_> kstt: We had hackage.org (the wiki, lots of docs) go down 2 weekends in a row or something like that in the last month
10:40:14 <lispy_> kstt: I meant, haskell.org
10:40:15 <kstt> dons, ok, I trust that
10:40:16 <dons> the wiki? you mean www.haskell.org
10:40:28 <dons> which hosts the wiki and base docs.
10:40:45 <revenantphx> What's it down for?
10:40:48 <benmachine> the base docs are also on hackage aren't they?
10:40:51 <dons> anyway, follow twitter.com/haskellorg for latest news
10:41:04 <dons> http://twitter.com/haskellorg/status/10846088751742976 
10:41:29 * dom96 is already following.
10:41:45 <dom96> My twitter feed is way too big, i didn't notice haskellorg's tweet
10:42:02 * kstt hopes he won't see the lifted whale on twitter
10:42:13 <revenantphx> Lifted what...?
10:42:17 <revenantphx> liftM whale?
10:42:45 <lispy_> dons: anyway, thanks for providing up to date info and clarifications
10:43:11 <kstt> revenantphx: : this http://hongkietown.com/wp-content/uploads/2010/07/twitter-fail-whale.png
10:43:40 <revenantphx> 0.o
10:43:52 <revenantphx> what is it supposed to mean?
10:44:03 <kstt> twitter outage
10:44:14 <revenantphx> Well yes.
10:44:21 <revenantphx> But how is that represented by birds lifting a whale
10:44:38 <dom96> Whale is heavy, and it's very hard to lift for the birds.
10:44:39 <kstt> it might be because I'm in france but I see this page every week
10:44:40 <dom96> I guess.
10:44:46 <revenantphx> hm
10:51:49 <jmcarthur> dankna: dons said above to join #hackage for discussion about mirrors
10:51:55 <jmcarthur> in case you didn't see it
10:53:04 <dankna> thanks
10:58:20 <dons> so anyone played with the halvm yet? shapr?
10:59:10 <tromp_> what is the smallest positive double?
10:59:36 <tromp_> and the largest?
10:59:49 <sciolizer> > maxBound :: Double
10:59:50 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Double)
10:59:50 <lambdabot>    arising from a use o...
11:00:31 <Eduard_Munteanu> Why doesn't this work? B.foldl' (\acc w → acc >> acc `seq` putStrLn ".") (return ()) inp
11:00:33 <revenantphx> tromp_: depends on how it's stored. Double is usually 11 bits exponents, 1 bit sign and 52 mantissa
11:00:41 <Eduard_Munteanu> inp is a ByteString
11:00:51 <revenantphx> tromp_: so, 1*10^-11 would be by guess for smallest.
11:00:55 <Eduard_Munteanu> I'd expect a '.' for each word8 in the file, but instead I get only one.
11:00:59 <revenantphx> Then again, that's assuming haskell uses IEEE 754
11:01:04 <tromp_> thx. sorry; afk now
11:01:09 <Eduard_Munteanu> inp <- openBinaryFile fn ReadMode >>= B.hGetContents
11:01:16 <Eduard_Munteanu> This stuff is killing me.
11:01:17 <geheimdienst> @where halvm
11:01:17 <lambdabot> I know nothing about halvm.
11:01:36 <geheimdienst> hm ... is halvm.org the right place? because that seems to be down
11:01:36 <Eduard_Munteanu> The seq is in there because otherwise I get a stack overflow.
11:01:46 <Funktorsalat> Eduard_Munteanu: not sure but maybe seq-ing an IO action doesn't do anything
11:01:46 <jmcarthur> i have no idea what i would actually *do* with halvm aside from... try to make a haskell operating system or some other impossibly complicated thing like that
11:01:51 <dons> halvm's down since it is hosted at galois , which has no power today
11:02:05 <dons> jmcarthur: tiny fast, domain-specific cloud services?
11:02:06 <Eduard_Munteanu> Funktorsalat: if I don't I get a stack overflow, regardless of the (>>)
11:02:12 <geheimdienst> oh i see. thanks for the info
11:02:18 <dons> i'm really curious what people will come up with
11:02:18 <jmcarthur> ah, that would be neat
11:02:27 <Funktorsalat> Eduard_Munteanu: weird. my reasoning was that IO is a newtype for a function type
11:02:47 <Eduard_Munteanu> Yeah, and foldl' is already strict in the accumulator.
11:04:54 <Eduard_Munteanu> It's supposed to be a mapM_.
11:05:48 <Funktorsalat> Eduard_Munteanu: try ghc-core?
11:06:08 <Eduard_Munteanu> Funktorsalat: -ddump-simpl ?
11:06:41 <Funktorsalat> Eduard_Munteanu: hmm iirc that's very verbose... ghc-core does -ddump-simpl-stats and -fext-core or so
11:06:51 <Funktorsalat> and denoises it for you
11:07:24 <Eduard_Munteanu> Ah, I see.
11:07:26 <joe6> is hackage down?
11:07:30 <Eduard_Munteanu> Yes.
11:12:29 <portnov> does anyone know when hackage goes to be up? :)
11:12:36 <revenantphx> 7+ hours apparently.
11:12:52 <portnov> ok :/
11:13:36 <joe6> instead of having one website, is it hard to host a website on bittorrent?
11:13:48 <joe6> i mean centralised website.
11:14:06 <dankna> bittorrent isn't directly geared to that, and webbrowsers don't support it either
11:14:12 <Eduard_Munteanu> Bittorrent isn't great for syncing stuff.
11:14:14 <portnov> jo ah-oh. it's nice idea, and afaik it's discussed for a long time
11:14:25 <portnov> but without any effect ;/
11:14:29 <Eduard_Munteanu> Though some P2P-oriented rsync would be nice.
11:14:38 <Eduard_Munteanu> Or just have some damned mirrors :)
11:15:39 <tg_> Eduard_Munteanu: git?
11:16:12 <Eduard_Munteanu> That's still not P2P.
11:16:20 <portnov> tg_: are you suggest everyone to have full mirror of hackage with all history? :)
11:16:26 <portnov> *suggesting
11:16:38 <tg_> as much as they need
11:16:43 <Eduard_Munteanu> Yeah, you can manually go and add someone else's repo as remote, but it's not that transparent.
11:16:56 <tg_> Eduard_Munteanu: I actually just butted in this convo, I don't know what we're talking about
11:17:11 <Eduard_Munteanu> Making hackage more reliable :)
11:17:16 <tg_> oh
11:17:43 <tg_> yeah, git backend with p2p-style distribution of package info on a heirarchiacal (sp?) namespace
11:18:09 <mauke> hier-archi-cal
11:18:17 <tg_> thanks for the memonic
11:18:18 <conal> Axman6: ping
11:18:21 <revenantphx> git's gaining a lot of popularity it seems.
11:18:21 <chreekat>  /away not really here
11:18:24 <chreekat> damn it
11:18:27 <chreekat> haha
11:18:38 <conal> Axman6: you were looking for me earlier?
11:18:39 <tg_> revenantphx: i am not suggesting that it's superior than hg, though
11:18:49 <revenantphx> I prefer it to hg.
11:19:01 <revenantphx> However, that's only on the basis of having more experience with it... and github.
11:19:05 <revenantphx> Github > Bitbucket 
11:19:17 <portnov> ok, so, why not Darcs?
11:19:18 <portnov> ;)
11:19:25 <revenantphx> portnov: I don't know darcs :P.
11:19:36 * portnov does not too
11:19:45 <revenantphx> As I said, I don't really have a good reason git > hg, but I prefer using it. I've found it much quicker too.
11:19:58 <Funktorsalat> darcs is a lot easier to learn than git imo
11:20:17 <tg_> Funktorsalat: git is *extremely* powerful as an abstract toolkit
11:20:24 <Eduard_Munteanu> Yeah, I hear it's friendlier. I never used it though. Or perhaps just once.
11:20:40 <tg_> I once proposed using git as an LDAP backend
11:21:03 <mauke> so far I've found git easier to learn
11:21:21 <tg_> as a plain dvcs, it's comparable to it's competition
11:21:53 <revenantphx> git is very unixy.
11:22:02 <revenantphx> Lots of binaries, hg just has one.
11:22:02 <tg_> revenantphx: certainly by choice
11:22:04 <Eduard_Munteanu> I think we've got a bug.
11:22:07 <revenantphx> tg_: mm.
11:22:43 <revenantphx> brew for os x is nice.
11:22:44 <Eduard_Munteanu> On Wine, GHC 6.10.3, ByteString 0.9.1.4, it works.
11:22:58 <revenantphx> It's an apt-get type package manager written in ruby backended with git.
11:22:58 <Eduard_Munteanu> This thing: B.foldl' (\acc w → acc >> putStrLn ".") (return ()) inp
11:23:23 <Funktorsalat> revenantphx: many binaries vs. one binary with many command (darcs) doesn't seem like an essential difference
11:23:31 <Funktorsalat> not saying that you're claiming that, mind you
11:23:47 <Funktorsalat> git still has way more commands though, some of them confusing synonyms ;)
11:23:49 <tg_> Funktorsalat: I agree, twofold, and recall that git used to be accessed through a single executaable
11:24:26 <jmcarthur> speaking of binaries... if your repo must contain binaries then that's probably the biggest reason not to use darcs
11:24:32 <Eduard_Munteanu> And of course, no stack overflow.
11:24:56 <Eduard_Munteanu> Does anybody have any clue why?
11:25:00 <Funktorsalat> Eduard_Munteanu: what's the context containing the expression?
11:25:23 <Eduard_Munteanu> Funktorsalat: this is in main, and the only other statement is... inp <- openBinaryFile "tema2" ReadMode >>= B.hGetContents
11:25:40 <Rutix> What jmcarthur said
11:26:04 <jmcarthur> but on the flip side, i love darcs
11:26:21 <jmcarthur> so i really hope they work out a way to handle binaries decently
11:26:25 <Funktorsalat> jmcarthur: why no binaries? lack of diff or other problems?
11:26:37 <Funktorsalat> storing them worked for me so far
11:26:38 <jmcarthur> Funktorsalat: i don't know what darcs tries to do, but it's *slooooooooow*
11:26:45 <Funktorsalat> ah
11:26:53 <jmcarthur> even in small repos
11:27:13 <Funktorsalat> in a darcs 2 repo too? (no idea if that makes a difference)
11:27:14 <jmcarthur> since binaries often tend to be somewhat large, it doesn't help that darcs reads the entire thing in at a time
11:27:18 <jmcarthur> yeah
11:27:21 <Eduard_Munteanu> Can somebody try that on a 2MiB file and tell me if it works?
11:27:46 <Funktorsalat> Eduard_Munteanu: strict or lazy bs?
11:27:54 <Eduard_Munteanu> Funktorsalat: lazy
11:28:04 <Eduard_Munteanu> Strict didn't work on Linux either.
11:28:27 <alpounet> jmcarthur, still working with patchtag for all of your projects ?
11:28:43 <jmcarthur> alpounet: for a small subset of them
11:28:48 <jmcarthur> most of my projects are just local
11:29:03 <alpounet> ok
11:29:28 <jmcarthur> why?
11:29:41 <tg_> have you seen his code?
11:29:43 <saml> > i'm bored
11:29:44 <lambdabot>   Not in scope: `i'm'Not in scope: `bored'
11:29:45 <tg_> you wouldn't publish it either!
11:29:56 <jmcarthur> ouch
11:30:05 <tg_> jmcarthur: i was really talking about me :(
11:30:09 <jmcarthur> saml: #haskell-blah?
11:30:23 <Funktorsalat> Eduard_Munteanu: starts printing dots, but slowly (ghci)
11:30:34 <Funktorsalat> ghc 7, linux
11:30:35 <alpounet> jmcarthur, you to get an idea of patch-tag's current "popularity"
11:30:38 <Funktorsalat> *7.01
11:30:50 <Eduard_Munteanu> Funktorsalat: hm, it's slow here too on Windows, but at least it works. On Linux I only get a single dot :)
11:31:01 <Eduard_Munteanu> s/Windows/Wine/
11:31:18 <alpounet> s/you/just/
11:31:36 <jmcarthur> alpounet: it hasn't seemed to progress or regress in any way, to me
11:31:45 <Funktorsalat> Eduard_Munteanu: works compiledly too (--make -O2)
11:31:57 <Funktorsalat> though --make is redundant with 7.01
11:31:59 <Eduard_Munteanu> Funktorsalat: yeah, I use -O2 --make as well.
11:32:14 <Eduard_Munteanu> Funktorsalat: what bytestring version?
11:32:15 <Funktorsalat> I wonder why it's so slow
11:32:16 <martinhpedersen_> is hackage.haskell.org down? Can't reach it here:o
11:32:24 <alpounet> yes martinhpedersen_ 
11:32:26 <alpounet> maintainance
11:32:28 <jmcarthur> martinhpedersen_: should be back in 7 hours or so
11:32:36 <martinhpedersen_> ahh, ok:p
11:32:38 <tg_> martinhpedersen_: unlike google, if haskell.org is down, you can expect that it is
11:32:45 <Funktorsalat> Eduard_Munteanu: bytestring-0.9.1.8
11:33:04 <unkanon> what's a functor that's not a "container"?
11:33:07 <Eduard_Munteanu> Oh, I have .7 on Linux, and .4 in Wine.
11:33:12 <mikeg> How can I force evaluation of a Maybe? I'm trying to catch an exception that gets lazily wrapped in a Just
11:33:20 <jmcarthur> unkanon: arguably, all functors are
11:33:21 <martinhpedersen_> hehe;) Can I get the platform from another mirror? (for mac os)
11:33:21 <Watermind> unkanon: ((->) a)
11:33:24 <Funktorsalat> by 'so slow' I mean 'doesn't finish in a few seconds' as I think it should ;)
11:33:41 <jmcarthur> unkanon: but if you want something that's not a very traditional container, functions are a good example as Watermind points out
11:33:50 <Funktorsalat> Eduard_Munteanu: I used writeFile "tema2" (replicate (2^20) 'a') as input FWIW
11:34:03 <unkanon> hmm interesting...
11:34:10 <Funktorsalat> Eduard_Munteanu: terminated it after 143s now :o
11:34:14 <Eduard_Munteanu> Oh, 1MiB.
11:34:16 <Funktorsalat> something's fishy
11:34:21 <Funktorsalat> oh, right ;)
11:34:23 <Eduard_Munteanu> Yeah, mine is about 1.5MiB.
11:34:32 <Funktorsalat> I'll try 2^21
11:35:10 <Funktorsalat> Eduard_Munteanu: stack overflow indeed. sorry for the confusion
11:35:14 <Eduard_Munteanu> Oh.
11:35:29 <Watermind> unkanon: although jmcarthur also has a point because you can easily argue that is also a container, with it's elements indexed by the elements x of type a
11:35:52 <Eduard_Munteanu> Funktorsalat: what happens if you replace the folding function with \acc w -> acc >> acc `seq` ...
11:36:10 <Eduard_Munteanu> Funktorsalat: I'm curious if that makes it work there too.
11:36:36 <Funktorsalat> Eduard_Munteanu: yes, it does. and only prints a single dot too
11:36:48 <unkanon> Watermind: can you expand on that? I don't get the elements part
11:36:54 <Eduard_Munteanu> Hm, thanks. What the hell is going on? :)
11:36:56 <jmcarthur> Eduard_Munteanu: is this the same program as yesterday? are you still converting to some sort of a list and then folding that?
11:37:05 <Eduard_Munteanu> jmcarthur: not anymore.
11:37:09 <Funktorsalat> Eduard_Munteanu: rewrite rule faily corner case?
11:37:24 <alpounet> unkanon, a function f :: a -> b indexes elements of type b by elements of type a, somehow
11:37:29 <Eduard_Munteanu> jmcarthur: http://paste.pocoo.org/show/300343
11:37:29 <alpounet> so it's a lot like a container
11:37:36 <alpounet> and can be considered like one
11:37:46 <Watermind> unkanon: ((->) a) is the same as (a->)  so this is the type of functions with domain of type a
11:37:47 <Eduard_Munteanu> jmcarthur: I'm using B.foldl' as some sort of mapM_ and trying to pack stuff as I go.
11:37:50 <unkanon> Watermind: I can intuitively see (->) as a container because its fmap is (.) and I can think of f.g as f being a container for the result of g applied to something, but I can't really relate that to the symbol (->)
11:37:55 <Eduard_Munteanu> jmcarthur: in IO ().
11:38:01 <Eduard_Munteanu> Funktorsalat: I think so.
11:38:06 * ddarius gets in a horse stance for some hard fiddlin'.
11:38:07 <revenantphx> I fail at geometry... what would the height above the equilibrium position of a pendulum be at some degree theta?
11:38:13 <unkanon> alpounet: oh right, the definition of a function is that, of course :)
11:38:19 <alpounet> yup
11:38:24 <unkanon> alpounet: namely, to map elements from one domain to another
11:38:26 <Eduard_Munteanu> Funktorsalat: actually I looked at the source and foldl' = foldl, and they say foldl is subject to fusion.
11:38:35 <alpounet> exactly unkanon 
11:38:41 <ddarius> r(1-cos theta)
11:38:56 <Watermind> unkanon: so just like a list [b] is a contained that indexes it's elements with non negative integers
11:38:58 <revenantphx> ddarius: whats the logic behind that?
11:39:22 <ddarius> revenantphx: Draw a circle and draw a triangle and use sohcahtoa.
11:39:23 <unkanon> Watermind: so is (a->) a container that indexes its elements with the results of another domain?
11:39:29 <Watermind> unkanon: (a->b) is a container that indexes its elements with elements of a
11:39:29 <Funktorsalat> Eduard_Munteanu: sounds like it's worth a bug report, for the incorrect behaviour alone
11:39:35 <revenantphx> ddarius: >_>, thats not what I mean.
11:39:39 <unkanon> Watermind: oh ok
11:39:57 <Eduard_Munteanu> Funktorsalat: ah, thanks for confirming it. I'll do so.
11:40:11 <jmcarthur> Eduard_Munteanu: are you sure that foldl' isn't just making a huge IO action all in one go?
11:40:24 <jmcarthur> it would certainly explain the memory blowup you seem to be having
11:40:39 <Funktorsalat> Eduard_Munteanu: strict one only prints one dot too
11:41:03 <jmcarthur> are you sure a lazy foldr wouldn't be more appropriate?
11:41:05 <Eduard_Munteanu> jmcarthur: b-b-but why does this work, but print only one dot? B.foldl' (\acc w → acc >> acc `seq` putStrLn ".") (return ()) inp
11:41:07 <Funktorsalat> jmcarthur: it's in the main line of execution
11:41:41 <Funktorsalat> hmm though foldl(') isn't a streamy producer the way foldr is, is it
11:41:49 <jmcarthur> not at all
11:42:22 <Eduard_Munteanu> Well I want the actions to be executed strictly from left to right, isn't that what foldl' does?
11:42:41 <Funktorsalat> it doesn't execute anything I think
11:42:42 <jmcarthur> the direction of a fold says nothing about execution
11:42:56 <jmcarthur> what inputs are you guys using?
11:43:04 <Funktorsalat> the (>>=) of the main do block does the executing
11:43:08 <Eduard_Munteanu> jmcarthur: just some 1.5-2MiB files, data doesn't matter.
11:44:28 <Funktorsalat> Eduard_Munteanu: works with foldr (\w acc -> putStrLn "." >> acc)
11:44:34 <Funktorsalat> as expected
11:44:50 <Funktorsalat> takes 8s, still a bit more than I'd expect
11:45:05 <Funktorsalat> putStrLn overhead I guess
11:45:51 <jmcarthur> ./Main > /dev/null  1.06s user 0.01s system 99% cpu 1.076 total
11:46:00 <jmcarthur> that's the foldr version, piping to /dev/null
11:46:28 <Funktorsalat> jmcarthur: same here
11:46:40 <jmcarthur> that's an over 2.1 meg file input, too
11:46:48 <Eduard_Munteanu> Thanks, that works here too.
11:46:55 <Funktorsalat> (1.07s/0.03s, 2^21 bytes)
11:46:55 <jmcarthur> oh, it's exactly 2 meg, my bad
11:46:56 <Eduard_Munteanu> I guess it's some rewrite rules that's causing the bug?
11:47:04 <jmcarthur> what bug?
11:47:17 <Eduard_Munteanu> jmcarthur: well arguably it's still a bug with foldl', isn't it?
11:47:20 <jmcarthur> no
11:47:24 <unkanon> Watermind, alpounet: so if f :: a -> b indexes elements of type b by elements of type a, and we think of that as a container, then "fmap f g x" would first retrieve the element of g indexed by x and apply f to it. and indeed, fmap = (.) for (->) so it can be thought of as a container :)
11:47:28 <jmcarthur> i could have told you that would happen just by looking at it
11:47:29 <Eduard_Munteanu> Is there an explanation?
11:47:36 <Funktorsalat> jmcarthur: the 'only prints a single dot' part, not the overflow
11:47:38 <jmcarthur> Eduard_Munteanu: foldl' doesn't cause execution
11:47:47 <jmcarthur> Eduard_Munteanu: oh lemme look at that
11:48:29 <unkanon> so if all Functors are "containers" then what's a monad that's not? Cont?
11:48:36 <Eduard_Munteanu> jmcarthur: yeah if you add the `seq` it doesn't segfault yet it prints a single dot.
11:48:44 <Eduard_Munteanu> B.foldl' (\acc w → acc >> acc `seq` putStrLn ".")
11:49:03 <Eduard_Munteanu> B.foldl' (\acc w → acc >> acc `seq` putStrLn ".") (return ()) inp
11:49:19 <jmcarthur> weird. let's check core
11:50:27 <Eduard_Munteanu> It's weird because if I define a .>>. b = a >> a `seq` b, then write that as B.foldl' (\acc w → acc .>>. (putStrLn ".")) (return ()) inp    it still overflows!
11:50:43 <ddarius> Trying to view all monads, let alone all functors as "containers" is silly.
11:50:44 <jmcarthur> oh i have a suspicion
11:50:46 <ddarius> (And not helpful.)
11:50:49 <jmcarthur> h/o
11:51:12 <jmcarthur> Eduard_Munteanu: lol, i found the problem
11:51:25 <jmcarthur> Eduard_Munteanu: try this instead:  B.foldl' (\acc w → acc >> (acc `seq` putStrLn ".")) (return ()) inp
11:51:28 <jmcarthur> ;)
11:51:28 <Funktorsalat> Cont R A contains an A, but will only tell you what it is if you promise to use it for making an R
11:51:31 <Funktorsalat> ;)
11:52:01 <unkanon> hmm
11:52:07 <jmcarthur> Eduard_Munteanu: precedence was the problem there. it's no bug in GHC, seq, or B.foldl'  :)
11:52:37 <unkanon> ddarius: but what would you say is a functor that can't be thought of as a container? I'm not trying to shoehorn functors to be containers, just trying to find one that isn't
11:52:52 <Eduard_Munteanu> jmcarthur: you mean `seq` binds less tightly than (>>)? :O
11:53:10 <unkanon> jmcarthur: and that's why I as a beginner put unnecessary parentheses everywhere :)
11:53:11 <jmcarthur> i think all `foo` by default don't bind tightly
11:53:21 <tg_> is there a command to list the precedence
11:53:22 <tg_> of things?
11:53:24 <tg_> that isn't a manual?
11:53:28 <ddarius> unkanon: Cont isn't really, nor State, nor Const, nor IO.
11:53:32 <unkanon> tg_: :i function
11:53:34 <unkanon> in ghci
11:53:51 <tg_> :i seq
11:53:58 <jmcarthur> e.g.   :i `seq`
11:54:00 <Eduard_Munteanu> jmcarthur, Funktorsalat: well thanks for helping, it's certianly been interesting.
11:54:22 <merijn> Is there a function "until" similar to "forever"?
11:54:32 <ddarius> unkanon: I also don't see how a Parser is a "container."
11:54:42 <ddarius> Or a logic monad.
11:55:02 <jmcarthur> merijn: there is in the monad-loops package
11:55:07 <jmcarthur> which i just discovered today :D
11:55:23 <unkanon> ddarius: PArser == Parsec?
11:55:28 <aavogt> @ty until
11:55:29 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
11:55:37 <ddarius> unkanon: There are many monadic parser types.  Parsec is but one.
11:55:46 <merijn> :t forever
11:55:47 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
11:55:50 <jmcarthur> aavogt: he said similar to forever, which i assume means he wasn't a monadic one
11:55:55 <jmcarthur> *wants
11:55:57 <ddarius> (There are also non-monadic, parser types.)
11:56:11 <Funktorsalat> ddarius: if you understand 'container of a' to mean 'something that possibly outputs as' it seems fair enough
11:56:15 <unkanon> ddarius: then I agree it's tough to think of Parsec of being a container. Piping, maybe.
11:56:24 <jmcarthur> merijn: in monad-loops:   untilM :: Monad m => m a -> m Bool -> m [a]
11:56:28 <Funktorsalat> which may be a bit of a stretch
11:56:31 <merijn> Correct, for a server I basically want forever but with an optional "clean shutdown"
11:56:35 <jmcarthur> untilM' :: (Monad m, MonadPlus f) => m a -> m Bool -> m (f a)
11:56:39 <jmcarthur> untilM_ :: Monad m => m a -> m Bool -> m ()
11:56:45 <jmcarthur> iterateUntil :: Monad m => (a -> Bool) -> m a -> m a
11:56:59 <ddarius> Funktorsalat: If we define "container" to mean functor, then we'd be set.
11:57:06 <merijn> jmcarthur: Hmm, now that I think about it it might be just as easy to make the main loop a general recursive function
11:57:16 <jmcarthur> but that's lame :)
11:57:50 <jmcarthur> i found monad-loops while hunting for allM. totally worth it
11:57:54 <unkanon> ddarius: the thing is that a functor looks so much like a container
11:58:04 <jmcarthur> allM :: Monad m => (a -> m Bool) -> [a] -> m Bool
11:58:17 <Funktorsalat> Eduard_Munteanu: f x y = x + y
11:58:17 <Funktorsalat> infixr 1 `f`
11:58:19 <jmcarthur> ^^ short circuits
11:58:19 <unkanon> ddarius: it's even got an fmap to lift a function inside that container and apply it to its contents :)
11:58:26 <Funktorsalat> don't know if 'seq' has a fixity decl
11:58:29 <Philippa_> ddarius: the parser holds the input string, generally, but IKWYM
11:58:41 <jmcarthur> Funktorsalat: it must because it's lower than that
11:58:46 <jmcarthur> and i think is infixl
11:58:58 <unkanon> Funktorsalat: infixr 0 seq
11:58:59 <jmcarthur> oh, no, infixr
11:59:03 <jmcarthur> but still lower
11:59:07 <ddarius> unkanon: No, the thing is -type constructors- that are functors look so much like -type constructors- that are containers.
11:59:29 <ddarius> I'm pretty sure the main motivation of this "container" view is just to help someone with the types.
11:59:39 <Philippa_> except when it's the "forget everything" functor, to give an example...
11:59:45 <Philippa_> yeah, that sounds about right to me
11:59:52 <Funktorsalat> I took 'type constructor' for granted here
11:59:53 <unkanon> Philippa_: what functor is that?
12:00:04 <ddarius> unkanon: The Const one I mentioned above.
12:00:06 <Funktorsalat> rather than arbitrary categorical functors ;)
12:00:17 <unkanon> oh right
12:00:18 <Philippa_> especially const undefined, that's a fun variant
12:00:21 <ddarius> Funktorsalat: I'm not talking about arbitrary categorical functors.
12:00:34 <Funktorsalat> haskell functors that aren't type constructors?
12:00:36 <ddarius> Funktorsalat: If you talk about them, then the container view is just ridiculous.
12:01:12 <ddarius> Funktorsalat: Int is a type constructor and not a functor.  Similarly, (->) is a type constructor and not a functor.
12:01:40 <unkanon> but (->) is a functor
12:01:54 <Philonous> unkanon, The functor as container metaphor really doesn't work. You can't put anything "into" it, you can't get something out, all you can do is "lift" a function. 
12:01:55 <unkanon> @src (->) fmap
12:01:55 <lambdabot> fmap = (.)
12:01:58 <Twey> ((->) a) is a functor
12:02:00 <jmcarthur> yeah, the container point of view requires you to squint quite a bit for some functors
12:02:02 <Funktorsalat> ddarius: I interpreted you as saying 'type constructors that are functors' as opposed to other (haskell) functors
12:02:06 <Twey> (->) is @src sugar for it
12:02:13 <Twey> Functors only have one type variable
12:02:26 <Philippa_> Funktorsalat: that's weird, I'd take it as being as opposed to other type constructors
12:02:59 <mikeg> Am I trying to catch errors in readTime wrong? I still get a "Prelude.read: no parse" error with this code: http://hpaste.org/42070/catching_readtime_errors
12:03:12 <Funktorsalat> Philippa_: generally yes, but 'type constructors' was emphasized and the other interpretation didn't seem applicable to unkanon's issue
12:03:21 <mikeg> Note that parseTime just wraps that exception in a Just.
12:03:54 <unkanon> Philonous: yes you're right I guess
12:05:16 <aavogt> mikeg: what is parseTime in the context of that paste?
12:05:17 <ddarius> Funktorsalat: That's what I meant, and in fact, that is word for word what I said.
12:06:06 <mikeg> aavogt: parseTime is supposed to work like readTime, but return a Nothing if the string cannot be parsed.
12:06:35 <ezyang> :t uncurry const 
12:06:36 <lambdabot> forall a b. (a, b) -> a
12:06:47 <mikeg> However, parseTime is bugged and does not always do that. (parseTime "April 2000 "%e %B %Y" fails), so I have to catch the errors myself
12:07:29 <jmcarthur> i hate decomposing IO actions
12:07:36 <jmcarthur> it's so messy
12:07:39 <ddarius> jmcarthur: ?
12:07:51 <unkanon> @type uncurry
12:07:51 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
12:08:01 <aavogt> mikeg: what is the data that is supposed to be produced? evaluate probably isn't forcing the exception
12:08:02 <jmcarthur> ddarius: factoring out duplication in big IO functions
12:08:13 <ddarius> jmcarthur: Why do you have big IO functions?
12:08:22 <jmcarthur> it's trickier to get right than pure functions
12:08:34 <jmcarthur> ddarius: because it's OpenGL :P
12:08:53 <mikeg> Yes, evaluate isn't forcing the exception. Eventually I want to get a function parse :: String -> String -> MaybeT IO Day
12:09:18 <ddarius> "The other imperative programmers make fun of me because of my small functions."
12:09:37 <Twey> Hehehe
12:09:45 <Twey> OpenGL is heavily imperative.
12:10:18 <mikeg> aavogt: So, if parseTime returns either Nothing or an error inside a Just, I want Nothing
12:10:25 <aristid> @unmtl MaybeT IO Day
12:10:26 <lambdabot> IO (Maybe Day)
12:10:58 <jmcarthur> Twey: that's precisely what i'm hoping to clean up a little
12:11:29 <jmcarthur> not going for anything like a simple semantic model. just trying to remove some statefulness and general uglies
12:11:30 <Twey> jmcarthur: Are there no nice high-level wrappers for it?
12:11:37 <aavogt> mikeg: I'm confused because it isn't clear that you're trying to write this parseTime
12:11:40 <Twey> FieldTrip or something?
12:11:55 <DDave> Hey.. I have a very dumb question, how do I put " inside a string? I've tried using a backslash but couldnt get it to work..
12:12:03 <Cale> > "\""
12:12:04 <lambdabot>   "\""
12:12:05 <revenantphx> \"
12:12:08 <Cale> > length "\""
12:12:09 <lambdabot>   1
12:12:25 <revenantphx> > show "\""
12:12:26 <lambdabot>   "\"\\\"\""
12:12:30 <revenantphx> ...what
12:12:31 <Cale> :)
12:12:35 <jmcarthur> Twey: i'm trying to keep some of the power of low level opengl rather than specialize it as much as most high level wrappers do
12:12:36 <ddarius> Twey: I don't recall what it uses underneath, but gloss looks pretty pleasant for simple things.  It was too pure for the application I wanted though.
12:12:37 <revenantphx> what
12:12:38 <Cale> show ""
12:12:40 <revenantphx> Cale, I broke it
12:12:40 <Cale> > show ""
12:12:41 <lambdabot>   "\"\""
12:12:41 <DDave> Oh.. my bad, I thought "\"" was actually displaying \ and "
12:12:42 <DDave> thanks
12:12:46 <Cale> > show (show "")
12:12:47 <lambdabot>   "\"\\\"\\\"\""
12:12:48 <revenantphx> 0.o
12:12:49 <aavogt> mikeg: you should convert it to a  Day  before evaluate
12:12:53 <Cale> > show (show (show ""))
12:12:54 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\"\\\"\""
12:13:00 <mikeg> readTime returns a Day
12:13:00 <Twey> jmcarthur: Hm, alright… a worthy goal ☺
12:13:01 <Cale> > fix show
12:13:02 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
12:13:04 <Philonous> unkanon, I like to think of Funktors, Applicatives, Arrows and Monads as a framework for composable programs. The fmap from Functor allows you to append a predefined pure functions to the computation, Applicative gives you the power to apply functions that are themselves computed to the result, arrows allow you to compose predefined computations and with monads you can run programs that are the result of programs. 
12:13:14 <revenantphx> Cale: you beat me too it!
12:13:29 <revenantphx> One interesting note.
12:13:38 <DDave> Cale, thank you again :)
12:13:42 <revenantphx> If you print out fibonacci numbers (with Integer) for a bit, and then stretch out your terminal window...
12:13:44 <litb> hello all
12:13:49 <revenantphx> the comma's between each form wood grain patterns.
12:13:49 <Twey> @let leaningToothpickSyndrome = fix show
12:13:51 <lambdabot>  Defined.
12:13:51 <mikeg> And various combinations of $!, seq, evaluate, and return aren't helping :(
12:13:53 <revenantphx> Perfect ones.
12:13:59 <litb> why does this have so many ppl in here suddenly
12:14:02 <Twey> revenantphx: Hehe
12:14:04 <jmcarthur> wtf that's awesome revenantphx :P
12:14:08 <Twey> litb: ‘Suddenly’?
12:14:16 <jmcarthur> litb: seems normal to me
12:14:19 <Cale> revenantphx: Now, explain *why*
12:14:20 <nlogax> so fibonacci was made of wood?
12:14:20 <litb> hmm
12:14:26 <Twey> litb: We've been hovering around the 700 mark for as long as I remember.
12:14:35 <revenantphx> Cale: the length of the numbers must have some pattern to it.
12:14:39 <Twey> ± 25, maybe
12:14:39 <Cale> mhm
12:14:47 <dankna> some pattern.  how marvelously specific. :)
12:14:50 <aavogt> mikeg: oh, it fails because the exception isn't an  IOException
12:14:50 <ddarius> nlogax: He was made of carbon and wood is made of carbon.
12:15:05 <dankna> that means... he's a witch!
12:15:08 <Twey> Haha
12:15:09 <litb> afaik it was around 550 a year ago
12:15:14 <mikeg> Yeah, I get "Just *** Exception: Prelude.read: no parse"
12:15:16 <unkanon> Philonous: yes, thinking of them as a framework, an interface or simply a blueprint is better, I agree.
12:15:20 <Twey> litb: Still not exactly sudden :þ
12:15:24 <nlogax> ddarius: the plot thickens!
12:15:29 <aavogt> mikeg: change the type to    SomeException... maybe trace with    typeOf to know exactly a more specific one should be
12:15:56 <litb> where are the channel graphs again?
12:15:57 <Twey> mikeg: If you want to raise an exception where you call ‘read’ instead of when you use the value, try readIO
12:16:04 <mikeg> _exception :: e = SomeException (GHC.Exception.D:Exception (GHC.Show.D:Show ...) ....) (ErrorCall ['P',....]
12:16:05 <Twey> :t readIO
12:16:05 <lambdabot> forall a. (Read a) => String -> IO a
12:16:19 <Twey> That throws an IOException, and parses strictly
12:16:27 <orlandu63> > text "\""
12:16:28 <lambdabot>   "
12:16:28 <ddarius> The exponential rate of growth has significantly levelled off the last year or so.
12:16:46 <mikeg> Twey: I'm not calling read, it is Data.Time.Format.Parse
12:16:50 <litb> hmm
12:16:52 <Twey> Ah, okay
12:17:01 <revenantphx> jmcarthur: http://cl.ly/0x2Z0H2w351E2I1o1L3W
12:17:22 <mikeg> Which, is bugged on certain inputs, like (parseTime "April 2010 "%e %B %Y"), but the bugtracker is down i believe
12:17:22 <revenantphx> see the parabolas?
12:17:23 <jmcarthur> revenantphx: here's a fun one:  let fib = 0 : 1 : zipWith (+) fib (tail fib) :: [Integer] in map ((' ' <$) . show) fib
12:18:25 <revenantphx> Oh god, do that, then shrink the font and resize
12:18:56 <revenantphx> ohkay, back to work
12:20:06 <Funktorsalat> revenantphx: cute
12:22:34 <mikeg> Ok, that works aavogt :)
12:22:44 <aristid> > let fib = 0 : 1 : zipWith (+) fib (tail fib) :: [Integer] in map ((' ' <$) . show) fib
12:22:45 <lambdabot>   [" "," "," "," "," "," "," ","  ","  ","  ","  ","  ","   ","   ","   ","  ...
12:22:52 <ezyang> Hm. It's not clear to me how to draw diagrams of curried functions to show whether or not something preserves monotonicity. :-/ 
12:23:17 <aristid> jmcarthur: why is that a fun one?
12:24:27 <ddarius> ezyang: "Diagrams"?
12:24:33 <ezyang> uh 
12:24:58 <ezyang> you set up the range and the domain as poset diagrams 
12:25:03 <ezyang> and then you demonstrate a mapping from one to the other. 
12:25:12 <jmcarthur> aristid: run it in your terminal with a small font and full screen
12:25:37 <ezyang> > ((\() -> ()) undefined) 
12:25:38 <lambdabot>   *Exception: Prelude.undefined
12:25:39 <ddarius> Exponential domains get hairy.
12:25:46 <ezyang> yeah, it's true. 
12:25:58 <jmcarthur> aristid: revenantphx was talking about the curves that result from the commas in the fib sequence. i just turns all the numbers into spaces so the curves showed more easily
12:26:03 <jmcarthur> *turned
12:26:35 <ddarius> So (generalized) Hasse diagrams.
12:26:39 <aristid> jmcarthur: ah.
12:27:13 <ezyang> ddarius: Ah, is that the name? Excellent. 
12:27:32 <mikeg> aavogt: http://hpaste.org/42071/parseone thanks again :D
12:28:01 <Funktorsalat> jmcarthur: is that special to fibonacci somehow or will an exponential function do? *lazy*
12:28:38 <Eduard_Munteanu> Hm, I get better performance now... real    0m1.762s vs 0.3s-ish for C.
12:31:03 <Funktorsalat> :P let a = map (floor . (1.5 **)) $ [1.0 ..] :: [Integer] in map ((' ' <$) . show) a
12:31:23 <Funktorsalat> though that will overflow soon
12:32:42 <Funktorsalat> > floor (1.5 ** 10000000) :: Integer -- err or actually it won't
12:32:43 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
12:33:00 <Funktorsalat> that number is officially infinity? o_O
12:33:13 <Funktorsalat> > 1.5 ** 100000000
12:33:14 <lambdabot>   Infinity
12:33:26 <mauke> Funktorsalat: it doesn't stop!
12:33:59 <bragh> infinity is busy beaver (graham's function (ackermann's number, ackermann's number)). mwhahaha.
12:34:37 <Funktorsalat> wouldn't an exception be more appropriate for the floor here?
12:35:19 <Funktorsalat> or maybe that'd be more expensive since the current instance just applies the ordinary bit-twiddling to the rep of Infinity::Double. iirc that was our conclusion last time
12:36:13 <monochrom> haha bragh
12:36:39 <ezyang> > (\x -> if x then () else ()) undefined 
12:36:40 <lambdabot>   *Exception: Prelude.undefined
12:36:42 <Funktorsalat> > maxBound :: Double
12:36:43 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Double)
12:36:43 <lambdabot>    arising from a use o...
12:37:44 <ezyang> Is it appropriate to call a function that is not defined on any of it's arguments (i.e. undefined) partial? 
12:37:53 <ddarius> Yes.
12:38:08 <monochrom> eXtremely partial :)
12:38:25 <monochrom> Window XP - eXtremely partial function :)
12:39:00 <Funktorsalat> nevermind, apparently that Integer is the maximum non-Infinity Double
12:39:44 <Funktorsalat> > (length . show) (floor (1.5 ** 10000000) :: Integer)
12:39:45 <lambdabot>   309
12:39:54 <ezyang> also, I guess the difference between \() -> () and \_ -> () is that the left one is strict and the right one is lazy. 
12:39:56 <Funktorsalat> (or one more)
12:40:12 <Guest24546> hey, I'm new. I'd like to play with the REPA library. Can I install ghc-7 overtop of the haskell-2010.2.0.0 platform ?
12:40:38 <ezyang> Guest24546: Probably not. 
12:40:52 <dankna> you probably can actually, but the result will be that you aren't using the platform anyway
12:40:55 <lispy_> Guest24546: best to use ghc 6.10.3 if you're new or planning to use the platform
12:41:25 <lispy_> Guest24546: You'll be paying a lot of "first adopter" taxes if you use ghc7 right now
12:41:32 <Guest24546> REPA needs  GHC head branch > 6.13.20100309 or else it looses 10x performance...
12:41:38 <merijn> Is it possible to create something like "forall a. (MyTypeClass a) => Chan a"?
12:41:46 <Guest24546> (I'm reading)
12:42:01 <Guest24546> Is 6.13.20100309  a better choice than 7 then ?
12:42:08 <merijn> i.e. a heterogeneous Chan
12:42:27 <Eduard_Munteanu> Good, getting to 1.5-1.6s... 5x slower than C, I'm quite satisfied.
12:42:44 <ndrsndrs> merijn: no, but Chan Dynamic might work?
12:42:47 <Twey> merijn: No, but you can make a forall a. MyTypeClass a => MyDatum a and have a Chan MyDatum
12:42:49 <mauke> merijn: that's not heterogenous
12:42:50 <ndrsndrs> @hoogle Data.Dynamic
12:42:50 <lambdabot> module Data.Dynamic
12:42:50 <lambdabot> Data.Dynamic data Dynamic
12:42:50 <lambdabot> Data.Dynamic fromDynamic :: Typeable a => Dynamic -> Maybe a
12:43:11 <merijn> mauke: I realised, which is why I changed my description :p
12:43:31 <Cale> Guest24546: That's a good question. I would suspect that 7 includes all the stuff in the 6.13 branch, but I'm not sure.
12:43:45 <merijn> Basically I want to write events to a channel, now I could make a generic "Event" data type with a lot of constructors but that seems awful
12:43:56 <ndrsndrs> oh, i missed the class constraint. do what twey said instead
12:45:38 <merijn> Twey: Not sure I understand that one. So I define a typleclass MyTypeClass and then?
12:46:55 <monochrom> if you don't mind STM, you could wait on several channels simultaneously, atomically (readTChan chan0 >>= x `orElse` readTChan chan1 >>= y `orElse` ...) now they can be of different types. But there is still the problem of making x,y,... the same type
12:47:39 <ndrsndrs> merijn: http://www.haskell.org/haskellwiki/Existential_type
12:47:40 <merijn> monochrom: Several channels in this context would make no sense
12:48:16 <monochrom> my interim idea is atomically (readTChan chan0 >>= return action0 `orElse` ...) >>= \action -> action
12:48:43 <Guest24546> hmm... is it just me, or is http://hackage.haskell.org/   down?
12:48:55 <ndrsndrs> no, i think it is
12:48:59 <Guest24546> k
12:49:39 <merijn> monochrom: I want to have several input threads post things to a channel for the main thread to handle. Splitting that up into multiple threads seems counter-productive. Like I said, I could probably do it by make a single Event type and using a billion constructors/pattern matching but that seems awful.
12:49:52 <merijn> ndrsndrs: Ah yeah, that's what I was thinking of but forgot the name
12:50:20 <monochrom> Eh? atomically (readTChan chan0 >>= x `orElse` readTChan chan1 >>= y `orElse` ...)  is just one thread, no splitting.
12:51:13 <merijn> monochrom: I mean that I'd then have to have one channel per type per thread. Which seems a step further back then adding everything to the same type
12:52:41 <merijn> I think I want "data Event = forall a. (EventTypeClass a) => Event a" and then have "Chan Event"
12:53:07 <monochrom> that works.
12:53:14 <merijn> Which I see is what Twey wrote but without the data start >.>
12:53:18 <jmcarthur> Funktorsalat: it looks like that one stops making curves after a while
12:53:50 <monochrom> {-# LANGUAGE ExistentialTypes #-}
12:54:00 * monochrom checks whether it's spelt right
12:54:07 <jmcarthur> ah i guess it just stops growing instead of going to infinity or something
12:54:18 <jmcarthur> ExistentialQuantification?
12:54:54 <monochrom> {-# LANGUAGE ExistentialQuantification #-}
12:55:02 <ndrsndrs> Guest24546: http://twitter.com/#!/haskellorg/status/10846088751742976
12:56:36 <waterlaz> hi
12:56:53 <Guest24546> ndrsndrs: Thanks!
12:57:03 <waterlaz> is there a way to view the cpp output when doing compiling with ghc?
12:57:45 <monochrom> yes, somewhere in chapter 4 of the user guide: http://www.haskell.org/ghc/docs/latest/html/users_guide/index.html
12:57:51 <ndrsndrs> -E
12:57:58 <ddarius> 6.13 is a development branch.
12:58:20 <ddarius> Since there is no 6.14 if you need 6.13 or higher, you want 6.
12:58:23 <ddarius> 7
12:59:27 <inad922> Hello
13:00:24 <Eduard_Munteanu> Yahoooo!
13:00:35 <Eduard_Munteanu> down to 1s by adding strictness to the packer state.
13:00:46 <Eduard_Munteanu> And using -funbox-strict-fields.
13:00:46 <waterlaz> oh, thanks
13:00:51 <Eduard_Munteanu> Now I really like it.
13:01:21 <Eduard_Munteanu> Now it's only like 3 times slower or so than the C variant.
13:02:04 * Eduard_Munteanu learned a lot.
13:03:00 <Eduard_Munteanu> BTW, thanks guys.
13:03:03 <inad922> Anyone tried or know that someone tried to write optimization libraries in haskell(like linear programming solver)? I don't mean port of solver libraries written in C. Is it btw possible to write programs in haskell which is comparable in efficiency to their counterparts say in lang C?
13:04:00 <Eduard_Munteanu> inad922: we usually reuse code and call C programs through FFI for numerical stuff. Even stuff like Octave (that's not written in Haskell) uses already written routines, like BLAS, LAPACK etc.
13:04:03 <Cale> inad922: It is possible, but usually requires some subtlety
13:04:52 <Eduard_Munteanu> Cale: I'm pretty satisfied so far. 3x slower is good for me, although I still feel like pursuing this further :)
13:05:00 <inad922> Eduard_Munteanu: I see.
13:05:02 <Cale> There are some libraries that are in various stages of completion which help acheive that sort of performance more easily with naive code, such as the Vector library for arrays
13:05:04 * Eduard_Munteanu turns down his enthusiasm a bit :D
13:05:10 <inad922> Cale: What makes it hard?
13:05:27 <monochrom> whee, hackage seems down
13:05:32 * ddarius thinks wget downloaded everything except what he wanted.
13:05:38 <Eduard_Munteanu> monochrom: yep you're late
13:05:57 <merijn> inad922: My guess: Haskell code lets you easily pretends there is no machine which makes optimizing your code for a specific machine harder?
13:06:44 <merijn> C is closer to how the machine actually works then haskell, this means (manually) coopting the machine into better performance is easier, in my experience anyway
13:06:45 <Cale> inad922: Well, Haskell is quite high-level and abstract. Sometimes that's a good thing for potential optimisation, but it also means that you're very far away from the actual machine model of computation. (On normal computers at least)
13:07:27 <merijn> One of the most costly things for numeric code is stuff like cache misses and page faults. Its nearly impossible to control those in Haskell
13:08:01 <ddarius> Most people simply have no idea how Haskell executes since they've never bothered to learn and thus make poor coding decisions.
13:08:10 <Cale> That's also true.
13:08:27 <medfly> or maybe they don't code in Haskell, so their poor coding decisions do not matter
13:08:43 <medfly> making sense of how the computer works is much easier
13:08:45 <Cale> medfly: That's irrelevant?
13:08:47 <Cale> :)
13:08:54 <jmcarthur> merijn: not true! you can use the same cache optimization with haskell arrays as with C arrays
13:08:56 <Cale> We're talking about performance of Haskell programs here ;)
13:08:59 <medfly> it's your fault for making Haskell so complicated!
13:09:32 <merijn> jmcarthur: I didn't say it wasn't possible, I said its far easier to do optimizations based on controlling cache/pages is easier in C then in Haskell
13:09:40 <Cale> So, people who don't program in Haskell are excluded from the discussion :)
13:09:40 <jmcarthur> merijn: non-array code of course is tough to control in either language
13:09:48 <jmcarthur> regarding cache coherency
13:10:01 <medfly> as well as most people who do program in Haskell
13:10:02 <Eduard_Munteanu> ddarius: I think the abstract machine behind Haskell is harder to comprehend than C.
13:10:08 <ddarius> Eduard_Munteanu: It isn't.
13:10:10 <Cale> But yeah, a lot of beginner Haskell programmers write programs as if they're going to be evaluated by a strict evaluator.
13:10:13 <merijn> Cale: How about people like me who pretend to code in Haskell?
13:11:01 <mtnviewmark> if I had a nickel for every C/C++/Java programmer I met who didn't understand how local variables worked in the abstract machine....
13:11:17 <monochrom> Those who don't know how haskell could be executed also don't know how other code is executed. They just believe that they know.
13:11:19 <medfly> abstract machines are for losers
13:11:38 <merijn> Real men work on bare metal!
13:11:48 <Cale> All machines are abstract
13:11:53 <mtnviewmark> if I had a nickel for every C/C++/Java programmer I met who didn't understand how local variables worked on the actual hardware...
13:12:02 <merijn> On related note: The average bare metal documentation sucks >.>
13:12:10 <medfly> no they are not
13:12:22 <merijn> medfly: Name one which isn't?
13:12:26 <medfly> real men solder their circuits!
13:12:33 <revenantphx> mtnviewmark: I honestly don't know :\. I'd guess they're on the stack?
13:12:37 <monochrom> eh? hardware data sheets beat software docs.
13:13:01 <Cale> As soon as you think of a circuit as a machine in order to understand it, you have performed abstraction
13:13:03 <mtnviewmark> yes - only, how does the stack work? RAM doesn't actually have push-down FIFO queues!
13:13:03 <iago> I don't see why you need super-optimizations in Haskell
13:13:12 <Eduard_Munteanu> Heh, I agree with mono
13:13:12 <revenantphx> mtnviewmark: mm yeah, that I dont know.
13:13:15 <monochrom> hardware data sheet tells you even how much electricity it consumes. software docs can't even tell you the big-O cost of each operation.
13:13:18 <merijn> monochrom: I wasted a month trying to figure out how APIC works (well, technically I'm still trying to figure it out)
13:13:21 <mtnviewmark> there is hope: you can now visualize the bare metal in your browser: http://visual6502.org/JSSim/
13:13:47 <merijn> I think the only people who know are 10 year retired Linux hackers and Intel employees >.>
13:13:51 <Eduard_Munteanu> Though arguably these days you won't find much documentation for electronics, at least not the stuff in computers.
13:13:53 <Cale> Even if you're using a model which involves voltages, voltages are an abstraction :)
13:13:53 <monochrom> well on that aspect software docs are just as unclear.
13:13:59 <Eduard_Munteanu> Except stuff like the CPU and such.
13:14:06 <revenantphx> mtnviewmark: does that link actually check what CPU you're using?
13:14:10 <revenantphx> Or is it always the same image.
13:14:15 <merijn> Eduard_Munteanu: The CPU docs still suck :p
13:14:21 <revenantphx> Oh, its a 6502
13:14:21 <medfly> I think it's not an image, revenantphx 
13:14:22 <revenantphx> durr
13:14:36 <mtnviewmark> revenantphx: I suggest reading something like this: http://www1.idc.ac.il/tecs/
13:14:46 <merijn> And it's proving significantly difficult to find people who know how CPU level code actually works
13:14:46 <Eduard_Munteanu> Somewhat, yeah.
13:14:49 <mtnviewmark> It is actually good to understand how the actual stack works!
13:14:56 * revenantphx adds to book list
13:15:01 <medfly> idc.ac.il?
13:15:24 * Eduard_Munteanu is proud of his code now and goes watch a movie :P
13:15:47 <inad922> actual stack works with stack pointer not?
13:16:50 <mtnviewmark> sorry - here's the MIT press page for the book: http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=11453
13:17:29 <Cale> My stack actually consists of a bunch of case expressions ;)
13:17:57 <revenantphx> Cale: In what, some kind of VM?
13:17:57 <mtnviewmark> in most CPU hardware for the last, say, 50 years, a stack is implemented in hardware as a register that holds the address to a piece of memory.
13:18:01 <DDave> Uhm.. please dont kill me, but is there a function similar to PHP's "explode" function? as input I have a string "atest,b,c,dt" and I'd like to have a list ["atest","b","c","dt"] (Split it at each Comma)
13:18:14 <Cale> revenantphx: In my mental model of Haskell evaluation
13:18:18 <revenantphx> mtnviewmark: ah right, stack pointer and frame pointer.
13:18:36 <revenantphx> What's the register called on 86...
13:18:39 <jmcarthur> DDave: check out the split package once hackage is back up
13:18:54 <medfly> @hoogle splitAt
13:18:54 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
13:18:55 <lambdabot> Data.ByteString splitAt :: Int -> ByteString -> (ByteString, ByteString)
13:18:55 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
13:18:59 <Cale> DDave: The 'split' library on Hackage (which is unfortunately down for building maintenance right now) has lots of useful stuff
13:19:00 <medfly> oh, right... err
13:19:02 <revenantphx> mtnviewmark: I think it's ebp and esp (base and stack?)
13:19:05 <Cale> span and break are useful
13:19:07 <DDave> Thing is I cannot import more modules..
13:19:23 <Cale> > break (==',') "atest,b,c,dt"
13:19:24 <lambdabot>   ("atest",",b,c,dt")
13:19:29 <revenantphx> I know only the basics of assembly... :\
13:19:32 <jmcarthur> DDave: http://code.haskell.org/~byorgey/code/split/
13:19:37 <DDave> Thanks a lot!
13:19:42 <jmcarthur> DDave: you'll have to build the docs yourself if you want to see them
13:19:44 <merijn> revenantphx: Interesting stuff to learn
13:19:50 <revenantphx> merijn: yep.
13:19:52 <sinelaw> preflex, seen Peaker
13:19:53 <preflex>  Peaker was last seen on #haskell 7 days, 22 hours, 54 minutes and 3 seconds ago, saying: Cin, I discovered that if I work on that project, though, I cannot work on challenging projects at my workplace (if they're not the "top idea in my mind") so that's why I'm suspending it (I hope to finish the current project finally and leave :-)
13:19:54 <DDave> jmcarthur, Cale thanks
13:20:00 <medfly> hi sinelaw 
13:20:05 <merijn> I did a small bit of ASM for class, had the time of my live :)
13:20:10 <medfly> here's someone that should know how a stack works :p
13:20:11 <mtnviewmark> revenantphx: But it is good to read up on what those actually do - because you'll find that they implement fare less of the concept of a stack than you might think - the rest is just disciplined use of those registers!
13:20:15 <merijn> Instructors were less pleased with my code
13:20:29 <Cthulhon> esp defines the stack.  The use of ebp as frame divider is by convention.
13:20:31 <revenantphx> mtnviewmark: Well, the idea of a FIFO stack is a tad odd in any case ;)
13:20:31 <medfly> merijn, why?
13:20:40 <inad922> mtnviewmark: Is that book worth reading?
13:20:49 <sinelaw> hi
13:20:49 <revenantphx> I know how cdecl and such work. That's about my extent of understanding of the stack and such.
13:21:01 <merijn> medfly: Implemented minimalist exceptions by messing with the stack frame which caused the step-through debugger they used for grading to crash :D
13:21:14 <merijn> Program ran fine outside the debugger, though :p
13:21:20 <revenantphx> oh another note, this is very amusing
13:21:21 <revenantphx> http://cdecl.org/
13:21:31 <Cale> > let { split p xs = case break p xs of (ys,[]) -> [ys]; (ys,z:zs) -> ys : split p zs } in split (==',') "atest,b,c,dt"
13:21:32 <lambdabot>   ["atest","b","c","dt"]
13:21:41 <medfly> ugly
13:21:57 <Cale> Could probably be turned into an unfold
13:22:02 <revenantphx> CSV?
13:22:08 <inad922> mtnviewmark: I "read" Tannenbaum's book which was pretty bad on the topic. http://www.amazon.com/Structured-Computer-Organization-Andrew-Tanenbaum/dp/0131485210/ref=sr_1_5?ie=UTF8&qid=1291497677&sr=8-5
13:22:09 <merijn> medfly: Fun as hell, though :)
13:22:23 <merijn> inad922: Really? I found it rather good
13:22:36 <merijn> Then again, it was 5 years ago that I used that book for class
13:23:00 <Cthulhon> The stack is more complex than a pointer on architectures with register windowing, by the way.
13:23:11 <inad922> merijn: Too much talk for me.. I like it as short as possible. :)
13:23:15 <Cthulhon> E.g. SPARC, IA64.
13:23:15 <merijn> And in my more recent experience Tannenbaum's books are usually rather good
13:23:31 <merijn> inad922: I prefer a more conversational style like he uses :p
13:24:32 <Cin> Any standard library or Hackage package got one of these?
13:24:32 <Cin> whileM :: (a -> m Bool) -> a -> m [a]
13:24:32 <Cin> unfoldM :: (b -> Maybe (a, b)) -> m b -> m [a]
13:24:41 <Cin> @hoogle unfoldM
13:24:41 <lambdabot> No results found
13:25:19 <Cin> Ah, nice. monad-loops
13:28:16 <merijn> What's preferred style? Explicitly importing the functions you use or doing qualified imports?
13:28:46 <jmcarthur> merijn: personal preference / contextual
13:29:14 <monochrom> a mixture of both
13:29:50 <jmcarthur> i tend to say import Foo (foo, bar, baz) ; import qualified Foo as F
13:30:08 <jmcarthur> where foo, bar, and baz are frequently used
13:30:15 <Cin> Both are preferred over no explicity at all. If you have more than a line or so it's usually worth making it qualified, otherwise explicit is fine. Sometimes when you're importing, e.g. from the FFI, there are too many types and names to be qualifying or typing up, so you import that implicit but everything else is explicit, so people (i.e. you, in a week) reading your code can keep track easily.
13:30:27 <jmcarthur> types in particular i tend to import unqualified if i can
13:32:04 <Cin> Control.Monad.Loops is *packed* with useful monadic functions.
13:33:29 <FunctorSalad> the most economical solution is sometimes to import the offender unqualified and hide conflicting stuff in Prelude ;)
13:33:52 <FunctorSalad> possibly less forward-compatible, admittedly
13:34:36 <Cin> @hoogle (a -> Bool) -> a -> Maybe a
13:34:36 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
13:34:36 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
13:34:36 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
13:35:03 <sunjazz> hackage is down?
13:35:06 <Cin> Yes.
13:35:20 <Cin> Although downloading packages remains operational...
13:35:59 <ndrsndrs> is there a mirror or anything?
13:36:13 <sunjazz> negative. Cabal update doesnt work
13:37:37 <sunjazz> is there any news/status pages that can give details about outage and plans when it will be up?
13:38:35 <Cale> sunjazz: It's planned for today. The building is having its electrical system worked on.
13:38:36 <dons> yep. follow twitter.com/haskellorg for announcements and news
13:38:52 <dons> haskellorg.wordpress.com has more detailed news
13:39:31 <dons> you  can still obtain software via the hackage 2.0 test site: http://sparky.haskell.org:8080/ 
13:40:57 * Cale sends an abuse report email to some Moldovian ISP 
13:41:18 <Cale> Dictionary attacks :P
13:42:13 <Cale> Moldavian*
13:42:41 <sinelaw> where who
13:43:11 <Cale> 93.116.247.239
13:43:32 <sinelaw> what
13:43:44 <FunctorSalad> our base is under attack? :o
13:43:50 <Cale> (trying to login as root on my machine)
13:44:27 <orlandu63> you should change your ssh port
13:50:43 <sunjazz> Thanks dons, I have successfully updated from sparky
13:55:32 <Cin> Me too! :-)
13:57:54 <merijn> Network is sufficient for most normal networking? Or are other libraries in more common use?
14:00:54 <ddarius> > 50 `div` 3
14:00:55 <lambdabot>   16
14:02:59 <revenantphx> Does anyone in here know how to set a LaTeX document to composition notebook size? 
14:03:12 <revenantphx> I'm guessing there's some width/height options for the geometry package.
14:04:52 <merijn> Libraries like Network aren't part of GHC, right? So if I want to access them I need to install Haskell Platform and then cabal install haskell-platform again to get it working with GHC7?
14:05:29 <BONUS> nah, just install haskell platform
14:05:29 <lambdabot> BONUS: You have 3 new messages. '/msg lambdabot @messages' to read them.
14:05:47 <merijn> BONUS: Haskell Platform doesn't use GHC7
14:05:54 <BONUS> haha oh sorry
14:06:00 <BONUS> that's what i get for not reading up
14:06:08 <revenantphx> merijn: You have 4 new messages. '/part lambdabot @messages' to read them.
14:06:32 <merijn> revenantphx: Swing and a miss...
14:06:41 <revenantphx> baw.
14:07:27 <ddarius> @hoogle modifyMVar
14:07:27 <lambdabot> Control.Concurrent.MVar modifyMVar :: MVar a -> (a -> IO (a, b)) -> IO b
14:07:27 <lambdabot> Control.Concurrent.MVar modifyMVar_ :: MVar a -> (a -> IO a) -> IO ()
14:07:49 <unkanon> is there a way to use guards inside a function as opposed to using them to define the outcome of a function?
14:08:19 <merijn> unkanon: Wouldn't that be pretty much the same as a case?
14:08:20 <benmachine> unkanon: you can use them in case statements
14:08:30 <ddarius> @hoogle putMVar
14:08:31 <lambdabot> Control.Concurrent.MVar putMVar :: MVar a -> a -> IO ()
14:08:31 <lambdabot> Control.Concurrent.MVar tryPutMVar :: MVar a -> a -> IO Bool
14:08:39 <Philonous_> unkanon, case () of () | guard 1 -> foo; guard 2 -> bar
14:08:46 <unkanon> yes I'm using case .. of now instead, but case of really makes the text go to the right too much
14:09:05 <mauke> it only adds 4 spaces
14:09:46 <unkanon> http://hpaste.org/42072/indent_case_of
14:10:04 <unkanon> how do I make that code not go to the right so much ?
14:10:43 <mauke> indent it less
14:10:52 <benmachine> use guards?
14:11:11 <benmachine> or actually
14:11:16 <benmachine> you can do it all with && and ||
14:11:19 <unkanon> benmachine: but I can only put guards instead of the first case of, but not the second, right?
14:11:41 <adnap_> is hackage down for anyone else?
14:11:41 <unkanon> benmachine: well yes but that won't be as readable
14:11:52 <mauke> allEqual (x : y : xs) = x == y && allEqual (y : xs)
14:12:37 <benmachine> mauke has it right
14:13:04 <mauke> allEqual [] = True; allEqual (x : xs) = all (x ==) xs
14:13:06 <BONUS> way more readable
14:13:09 <ndrsndrs> apart from rewriting it, you only need to indent a case's arms to after the 'c'
14:13:21 <benmachine> you don't even need to do that actually
14:13:21 <mauke> ndrsndrs: no
14:13:37 <unkanon> oh only after the c, I didn't know that
14:13:41 <mauke> unkanon: NO
14:14:12 <benmachine> http://hpaste.org/paste/42072/case_indent#p42074 you can indent it like this it's fine
14:14:16 <unkanon> mauke: no I get it, I like your version better too, but that's how I had it before :)
14:14:47 <mauke> unkanon: which version?
14:14:56 <merijn> Network and related libraries aren't installed with GHC, are they?
14:14:59 <unkanon> benmachine: wow you can have it indented even before the case keyword, never knew that 
14:15:02 <revenantphx> So, if I have my entity map being passed recursively (simulating state), I have to create a new variable each time within the function when I add a potential transformation.
14:15:02 <preflex>  revenantphx: you have 1 new message. '/msg preflex messages' to read it.
14:15:16 <revenantphx> mauke: great thx
14:15:22 <unkanon> mauke: 17:11:25 < mauke> allEqual (x : y : xs) = x == y && allEqual (y : xs)
14:15:28 <revenantphx> Now the issue I see is if there's something conditional...
14:15:42 <dons> merijn: not with ghc, with the haskell platform.
14:15:45 <revenantphx> Like, if I only apply a transformation to the player map if I happen to receive that packet.
14:15:46 <adnap_> hey, can someone else please report the status of hackage.haskell.org?
14:16:14 <merijn> dons: So if I want to use GHC7 I need to install haskell platform and then immediately reinstall it using cabal?
14:16:21 <fryguybob> adnap_: http://twitter.com/haskellorg
14:16:21 <arcatan> adnap_: seems to be down.
14:16:38 <adnap_> thanks
14:16:47 <adnap_> also, i didn't know they had a twitter :P
14:16:51 <merijn> On hindsight maybe I shouldn't have chosen the day they take down hackage to break my haskell install >.>
14:17:04 <merijn> s/On/In
14:17:08 * revenantphx wants hackage back up, nao.
14:17:31 <dons> merijn: ghc7? no. ghc7 will be part of the next release of the haskell platform.
14:17:33 <adnap_> maybe i should read a book
14:17:34 * ezyang was going to hack on GHC, but can't get to the Darcs repo... instead, he's attempting (and failing) at doing laundry. 
14:17:43 <dons> if you want to use ghc7 now, you install from a snapshot and you're on your own with cabal
14:18:16 <revenantphx> So, here's my question I suppose.
14:18:28 <revenantphx> If I have a piece of state being passed recursively (a map in this case)
14:18:43 <revenantphx> And during each loop, I could perform a differing number of transformations to it...
14:18:43 <merijn> dons: Someone told me that was the solution a bit earlier but I guess they were either wrong or I misunderstood
14:18:45 <revenantphx> how do I manage this.
14:19:04 <benmachine> revenantphx: compose functions!
14:19:06 <revenantphx> Not exactly "perform transformations" as much as, "get a new map"
14:19:15 <revenantphx> benmachine: what if  they're in different clauses of a case statement ;)
14:19:21 <benmachine> that's fine
14:19:26 <revenantphx> benmachine: There are a few packets which could cause me to modify the map.
14:19:34 <revenantphx> And I may receive one, many or none of them.
14:19:35 <benmachine> :t id . case 0 of 0 -> id; _ -> const
14:19:35 <lambdabot>     Occurs check: cannot construct the infinite type: a = b -> a
14:19:36 <lambdabot>     Probable cause: `const' is applied to too few arguments
14:19:36 <lambdabot>     In the expression: const
14:19:39 <benmachine> wups
14:19:45 <benmachine> :t id . case 0 of 0 -> const id; _ -> const
14:19:46 <lambdabot> forall b. b -> b -> b
14:19:51 <merijn> So, what is the proper way of getting the libraries I need for GHC7? Download + compile by hand and dump them in some include folder I'm unaware of?
14:19:57 <revenantphx> ...?
14:20:09 <benmachine> you can have a case statement return a function
14:20:12 <benmachine> then compose some more!
14:20:25 <dons> merijn: use cabal-install. cabal remains the proper way to get libraries with any version of ghc, really.
14:20:26 <revenantphx> benmachine: right, but I also need to do transformations on other things.
14:20:35 <revenantphx> It seems like this will get very messy very quick ;)
14:20:55 <benmachine> if it's a messy problem it'll have a messy solution
14:21:05 <benmachine> if you paste some code there might be more specific things we can do
14:21:27 <ddarius> @hoogle withForeignPtr
14:21:27 <lambdabot> Foreign.ForeignPtr withForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b
14:21:44 <revenantphx> benmachine: I'm going to in a moment.
14:21:55 <revenantphx> I need to do something really quick
14:21:58 <benmachine> me too
14:22:46 <Cale> http://web.archive.org/web/20071020051936/http://iq.org/#Thehistoryofwarfare :)
14:23:05 <joe6> as hackage is down, I am looking for deepseq-1.1.0.2. is there any way I can find it.
14:23:19 <Cale> http://sparky.haskell.org:8080/
14:23:34 <Cale> joe6: ^^
14:23:47 <FunctorSalad> is there a library for center-aligning plain text ([String] -> [String])?
14:23:51 <dons> maybe add http://twitter.com/haskellorg to the title of #haskell
14:24:03 <benmachine> that sounds sensible
14:24:25 <joe6> Cale: thanks.
14:25:05 <FunctorSalad> @let center xs = let m = maximum (length<$>xs) in map (replicate (m `div` 2) ' ' ++) xs
14:25:07 <lambdabot>  Defined.
14:25:20 <FunctorSalad> > center (words "I can has coequalizer?")
14:25:21 <lambdabot>   ["      I","      can","      has","      coequalizer?"]
14:25:22 <benmachine> who updates the twitter? they're recommending the hackage 2 test but it's about four months behind now
14:25:27 <FunctorSalad> \o/
14:26:23 <merijn> Of course cabal appears to be missing from my system and the Haskell Platform is unreachable, curse you Finagle's Law
14:26:29 <FunctorSalad> > center []
14:26:30 <lambdabot>   []
14:26:34 <FunctorSalad> lazyness for the win
14:27:39 <benmachine> merijn: are you trying to install GHC 7?
14:28:23 <merijn> benmachine: I have that installed, but nuked everything earlier today before starting over. Not knowing hackage would be down :p
14:28:24 <FunctorSalad> @let correct_center xs = let m = maximum (length<$>xs) in map (\x -> replicate ((m-length x) `div` 2) ' ' ++ x) xs
14:28:26 <lambdabot>  Defined.
14:28:48 <benmachine> merijn: current releases of cabal-install won't compile with GHC 7, you need a darcs version or a pre-existing binary
14:28:54 <merijn> So I have GHC7 its just everything else that's missing :p
14:29:05 <benmachine> yes yes I meant, a GHC 7 environment I guess
14:29:21 <benmachine> I can make a tarball of the darcs repository if you want (since darcs.h.o is down too)
14:30:03 <merijn> benmachine: Meh, I'll wait for everything to be up. Less excuses to procrastinate on administration rather then write code :p
14:30:10 <benmachine> heh
14:30:10 <benmachine> k
14:30:15 <joe6> Cale: do you know where I can find http://darcs.haskell.org/packages/deepseq/
14:31:47 <joe6> i am trying to get http://hackage.haskell.org/packages/archive/deepseq/1.1.0.2/deepseq-1.1.0.2.tar.gz
14:32:43 <Cale> http://sparky.haskell.org:8080/package/deepseq -- ah it only has 1.1.0.2
14:32:49 <Cale> er, 1.1.0.0 rather
14:33:41 <joe6> yes, but the bindings-libusb-1.4.2 is dependent on that version
14:33:49 <joe6>  1.1.0.2, i mean
14:34:06 <Cale> You could always just wait until tomorrow :)
14:35:07 <Cale> Or just later tonight
14:35:20 <Cale> (Around 5PM PST, it's supposed to be back)
14:35:23 <ezyang> Oh hey, Math.OEIS is up for grabs 
14:35:44 <Veinor> up... for grabs?
14:35:48 <joe6> Cale: ok, thanks
14:35:55 <ezyang> As in, in need of an active maintainer. 
14:36:20 <Veinor> ah
14:39:59 <mreh> why is Monad (Either String) so hard for the type system>
14:41:01 <dons> how is it hard?
14:41:13 <Cale> mreh: It's just against the original very-restrictive rules about instances in Haskell 98
14:41:14 <mreh> it needs flexibleinstances
14:41:20 <Cale> mreh: It's not actually very hard
14:41:24 <mreh> :)
14:41:41 <dons> oh, well, flexibleinstances just lets you use String / [Char] and "it works"
14:42:43 <dons> http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/type-class-extensions.html#instance-rules 
14:43:01 <litb> hmm
14:45:11 <merijn> Is anyone aware of a Vim plugin for autoindenting haskell?
14:45:40 <mauke> :set ai
14:47:31 <merijn> That just maintains the current indent level, I was more looking for one that does smarter auto-indenting
14:48:39 <mauke> http://www.vim.org/scripts/script.php?script_id=1968
14:49:32 <mreh> sometimes I wonder if the transformers are worth it, I always end up littering the code with liftIO instead
14:50:05 <jmcarthur> you're doing it wrong then
14:50:28 <merijn> mauke: Awesome, that's much better :D
14:50:46 <mreh> <:(
14:51:00 <jmcarthur> you are usually better off hiding transformer stacks under newtypes and exposing only the operations you want to expose, effectively hiding all that lift stuff under those
14:51:07 <jmcarthur> liftIO specifically is more problematic I guess
14:51:23 <jmcarthur> since sometimes you want to expose a transformer as your abstraction rather than a full monad
14:51:44 <mreh> do I need to redefine all the classic IO functions then?
14:52:26 <jmcarthur> that's exactly why liftIO specifically is problematic. sometimes you want to expose a transformer than happens to be applied to IO, which is the case that you can't really hide that MonadIO instance
14:52:32 <jmcarthur> *that
14:52:48 <jmcarthur> it's when the IO is an implementation detail that you can get away with hiding liftIO
14:53:25 <jmcarthur> mreh: is the fact that IO is underneath this stack an implementation detail or something you intend to expose?
14:53:26 <kmc> not really a Haskell question but: has anyone built xmonad on ARM Linux?
14:53:42 <mreh> kmc: get it outside
14:53:46 <mreh> take it outside*
14:53:57 <jmcarthur> o_O
14:54:03 <mreh> jmcarthur: um, not sure
14:54:07 <mreh> let me think
14:54:16 <mreh> it's an implementation detail
14:54:26 <kmc> i'm contemplating using a Pandaboard or similar as a thin-ish client, but this is a potential sticking point
14:54:36 <jmcarthur> mreh: alright, then you should be able to hide it :)
14:55:00 <mreh> the program has an environment I want to pass around, but I also want to execute in an ordered fashion
14:55:03 <jmcarthur> under a newtype (and don't give it a MonadIO instance!)
14:55:38 <ddarius> Success.
14:55:52 <merijn> Typically I'd want foldl' rather then foldl, right?
14:55:59 <ddarius> merijn: 
14:56:01 <ddarius> Yes.
14:56:22 <mreh> jmcarthur: but I was to lift readFile :(
14:56:28 <mreh> want*
14:56:33 <mreh> so tired
14:57:02 <jmcarthur> mreh: if the IO is in fact an implementation detail then that seems to imply that any IO can be hidden under the newtype, right?
14:57:13 <jmcarthur> that is, client code doesn't need liftIO, right?
14:58:02 <mreh> jmcarthur: explain what you mean by client code
14:58:08 <mreh> please :)
14:58:20 <joe6> Could not find module `System.Console.CmdArgs' when I try to ghci pastepipe.hs
14:58:28 <jmcarthur> mreh: the user of the library/module you're making
14:58:51 <mreh> jmcarthur: yes, that's true, it's an executable though
14:58:57 <mreh> it was more of golfing question really
14:59:01 <jmcarthur> mreh: doesn't mean you don't want modularity
14:59:02 <joe6> is it just as simple as "cabal install System.Console.CmdArgs
14:59:14 <joe6> once hackage is back up. or is there more to it?
14:59:18 <jmcarthur> oh if you're golfing then yeah, you might not want transformers all the time
14:59:32 <jmcarthur> joe6: the name of the package, not the module
14:59:40 <jmcarthur> i think that package is called... cmdargs?
14:59:55 <jmcarthur> if i'm right, that would be:  cabal install cmdargs
15:00:08 <mreh> I think it's cmdargs, or CmdArgs
15:00:20 <mreh> was looking at it today
15:00:24 <joe6> in my .cabal/bin, I see cmdargs executable
15:00:32 <jmcarthur> joe6: if you're never used cabal-install before you may also need to run cabal update first
15:00:35 <mreh> odd, it's a library
15:00:41 <jmcarthur> *you've
15:01:01 <jmcarthur> ah you have a .cabal, so nevermind
15:01:35 <joe6> and pastepipe exe in the .cabal/bin dir. I am trying to see if I can fix the pastepipe.hs
15:01:45 <joe6> hence trying to load it onto ghci.
15:02:35 <mreh> I could just lift all the IO code in one large chunk, I'd quite like client code to use the reader
15:04:02 <mreh> no, that doesn't work
15:05:51 <jmcarthur> mreh: even if you end up having to use liftIO a lot, i'd still argue that that's often easier than the alternative of having to manage all that other context manually that a transformer stack would do for you
15:06:19 <mreh> jmcarthur: indeed
15:10:59 <merijn> How would I block a thread to wait for input on either a socket or a Chan?
15:14:00 <jmcarthur> merijn: the usual actions for getting input from sockets and chans are blocking already, aren't they?
15:14:26 <merijn> jmcarthur: Yes, but what I mean is: I have a thread with a socket and a Chan and I want to respond to new input on either
15:16:56 <merijn> I mean, blocking on just one of the two seems to rather defeat the purpose
15:18:00 <mauke> could use a Chan and two more threads
15:19:17 <jmcarthur> merijn: have one thread block on the socket, another block on the chan, and another blocking on yet another chan/mvar which the first two write to when they receive input
15:19:39 <Saizan> one of the nice things of STM is that you can block on multiple chans/vars with orElse, that doesn't cover sockets though
15:21:02 <merijn> My current approach: Have one Chan for input to my server loop, one Chan for output of my server loop (which is duplicated, one for each thread). Then spawn one thread per connection, any relevant events from the connection get posted to the input Chan any stuff that needs to go out to clients gets posted to the output Chan where threads pick it up, do whatever they need and write to the socket
15:21:47 <merijn> Having one thread with the Chan and one with the socket kinda defeats the purpose of using a Chan to communicate stuff from the socket to my main loop in the first place
15:21:55 <ddarius> merijn: What you want is a select.
15:22:03 <merijn> ddarius: Yes
15:22:28 <merijn> But I can't find one that'd let me mix Chan's and sockets
15:22:37 <ursthegizmo> if I want to write a c-class wrapper in c2hs do I need a normal C wrapper function for eacj class method?
15:22:53 <adnap_> does "golfing" refer to the effort to make code as short as possible?
15:22:55 <ddarius> The cml library and the CHP library have support for that.  You can also create one yourself, although that's fairly tricky depending on what all you want.  There isn't one in the standard libraries.
15:22:59 <merijn> adnap_: Yes
15:23:04 <ddarius> (for Chans that is)
15:23:07 <adnap_> lol, that's funny
15:23:28 <merijn> adnap_: Like in golf you try to code in as few (key) strokes as possible
15:23:29 <adnap_> i'm always golfing, but i suspect i'm not the best at it
15:23:48 <unkanon> adnap_: there's even a language called Golf (I think) that was made just to win "code golfing" contests
15:24:48 <adnap_> golfing often requires the use of esoteric concepts the may obfuscate the code to the layperson, yeah?
15:25:16 <adnap_> i guess that's too big of a generalization
15:25:36 <adnap_> i would like to see awesome exapmples of code golfing
15:25:45 <unkanon> google like this:
15:25:51 <unkanon> golfing site:stackoverflow.com
15:26:03 <ursthegizmo> is haskell one of the esoteric concepts too?
15:26:25 <ddarius> merijn: If you don't need to cancel one given the other, you could just fork a thread for each and funnel them into a single Chan using Either then wait on that Chan.
15:26:40 <adnap_> aw, people are just cramming their code onto one line
15:27:25 <merijn> ddarius: I suppose I could fork 2 threads per connection, but that seems a tad excessive?
15:27:58 <ddarius> merijn: Threads are cheap.  I made a GUI framework that forked several threads per control.
15:28:31 <ddarius> Also, you could probably reuse the existing channel at the cost of modularity.
15:28:35 <unkanon> what kind of threads does haskell use? green or red?
15:28:44 <merijn> unkanon: Both
15:28:54 <unkanon> at the programmer's choice?
15:28:56 <ezyang> The user should treat threads as green though 
15:29:24 <merijn> Just trying to think if I need any shared state for incoming/outgoing connections. I suppose if not I might as well use 2 per connection
15:29:54 <merijn> I don't think the feeling of this being like a deadly sin will go away, though :x
15:29:55 <ddarius> (Really, selecting on asynchronous channels is really much simpler than selecting on synchronous sends/receives...)
15:30:12 <sciolizer> New wiki page: http://haskell.org/haskellwiki/FFI_complete_examples
15:30:32 <sciolizer> It includes a swig example, which for all my searching I couldn't find one on the internet.
15:30:44 <jmcarthur> unkanon: it's m green threads on n OS threads
15:30:44 <ddarius> merijn: You should program in Pict or Occam or a similar language (or work with the underlying calculi) sometime.
15:31:07 <merijn> ddarius: Why, precisely?
15:31:07 <revenantphx> Okay.
15:31:20 <jmcarthur> unkanon: it's only 1 OS thread by default, but if you build with -threaded then it's n OS threads
15:31:22 <unkanon> jmcarthur: oh ok, so only if you go beyong m will you be using more than one red thread?
15:31:47 <jmcarthur> unkanon: is an OS thread a red thread? i've never heard it called that before
15:31:51 <ddarius> merijn: So you get experience with languages that are chock full of threads and where the design centers around using threads for decoupling.
15:32:20 <merijn> ddarius: Ah, so sorta like Erlang's approach to processes
15:32:23 <jmcarthur> unkanon: ghc will balance the green threads across multiple OS threads as needed
15:32:40 <jmcarthur> unkanon: the idea is to run one OS thread per core and have as many green threads on top of that as you want
15:33:07 <ddarius> merijn: Sort of only more extreme/prevalent.  In Pict, as it is based on the pi calculus, technically even function applications are reduced to threads and communication.
15:33:09 <jmcarthur> unkanon: you can specify at runtime how many OS threads to use
15:33:22 <jmcarthur> as a command line flag to your program
15:33:34 <unkanon> jmcarthur: yes afaik red thread = OS thread
15:33:38 <jmcarthur> okay
15:33:40 <merijn> My main annoyance with Haskell is that this is kinda design I'm trying to do is extremely basic and I can't find any clear Haskell examples on how to approach it :\
15:33:49 <unkanon> jmcarthur: I get it, that's cool
15:33:58 <jmcarthur> merijn: i don't think the many-threads approach sounds too complicated, personally
15:35:20 <ddarius> "Why can't I find examples that match the arbitrary restrictions I'm imposing on myself?"
15:35:42 <sinelaw> ddarius, because you can't
15:35:51 <merijn> ddarius: My problem isn't arbitrary restrictions, it is that using 2 threads per connections never occurred to me
15:35:55 <lispy_> otto_s: Where can I go to talk to Isabelle users?  They don't seem to have a channel on this irc server
15:35:56 <monochrom> Gödel may know the answer.
15:35:59 <lispy_> otto_s: Sorry
15:36:03 <sinelaw> monochrom, may have known
15:36:09 <merijn> jmcarthur: Its not complicated, but spawning 2 threads per connection to write a server program is none-obvious (for people coming from most popular languages) solution and no one appears to have bothered to have explained this sorta design anywhere...
15:36:11 <lispy_> otto_s: for some reason my client turns OT into your nick
15:36:16 <jmcarthur> merijn: it's not even a bad idea to use 100 threads per connection
15:36:16 <blackdog> hackage down, then... ?
15:36:25 <lispy_> Let me try that again, Where can I go to talk to Isabelle users?  They don't seem to have a channel on this irc server
15:36:37 * blackdog checks the subject to make sure he's not the nth guy to say it...
15:36:54 <jmcarthur> blackdog: yes it's down, yes you're the nth guy to say it, no i don't think it's in the topic...
15:37:03 <monochrom> apparently these days you have to check reddit and twitter too
15:37:06 <jmcarthur> blackdog: it was planned, should be back up... soonish
15:37:09 <otto_s> lispy_: No problem.
15:37:13 <jmcarthur> it was poorly announced
15:37:20 <bremner> screw twitter.
15:37:23 <lispy_> jmcarthur: it was on twitter and reddit
15:37:23 <ddarius> merijn: There are entire sub-branches of CS that cover "this idea."
15:37:29 <merijn> ddarius: Basically my point was that lacking a "this is how you design servers with multiple clients in Haskell" guide these sorts of design are not as obvious to me (and by logically flawed extension others as well) as a lot of people here seem to think
15:37:33 <jmcarthur> lispy_: but not the haskell mailing list(s)!
15:37:37 <ddarius> merijn: I recommend you read "A Concurrent Windowing System."
15:37:39 <jmcarthur> which is where most people expect it
15:37:48 <blackdog> jmcarthur: goodo. i've been in a world of java hurt for the last week, trying to immerse myself in some haskelly goodness for a few hours
15:37:52 <monochrom> I just whined about it on the mailing list
15:38:03 <ddarius> merijn: There's a paper on writing a web server in Haskell with full source.
15:38:16 <lispy_> jmcarthur: I agree that haskell-cafe/haskell are good ways to notify people, but I also discovered you can subscribe to these things on twitter and then make twitter behave like an IRC channel
15:38:19 <ddarius> At this point, it is a bit dated but, actually, it should all still be relevant.
15:38:44 <lispy_> Now I just check my twitter tab in pidgin and I'm current on the news
15:38:48 <blackdog> so, before i hose my install again - is ghc-mtl a core part of ghc? can i reinstall it, or will that break everytihng?
15:38:54 <merijn> ddarius: I saw some example code about a haskell webserver in SPJ's stuff about the Awkward Squad, but the main problem I had adapting that is that concurrent web server connections don't interact
15:39:04 <jmcarthur> monochrom: "This seems to me planned obsoletion of the mailing lists." <-- ouch
15:39:26 <merijn> Anyway, I guess step 2 after getting the basic design going will be to write the "Haskell server design I wish I had when starting this idea"-guide
15:39:33 <monochrom> ghc-mtl is ghc's private copy of mtl. don't modify it.
15:39:40 <jmcarthur> it would be cool if lambdabot would follow a twitter account or RSS feed for these things
15:39:50 <ddarius> http://research.microsoft.com/apps/pubs/default.aspx?id=67498
15:39:58 <blackdog> monochrom: crud. ok. if i need a version of it built with dyn libraries, i'd have to rebuild ghc, then.
15:40:10 <merijn> ddarius: Thanks, I'll check that one out too
15:40:32 <ddarius> merijn: Note that that is ten years old.
15:41:10 <lispy> We're starting #isabelle for you theorem proving folks!
15:42:10 <jmcarthur> monochrom: "The most important pragmatic reason for me is retarded or no attempt at mark-as-read and show-all-and-only-those-unread."    Every submission on Reddit has a "hide" button, and you can also configure your preferences so that it doesn't show you things that you've liked or disliked (each a separate option).
15:42:28 <jmcarthur> but i'm with you on not being able to switch between "all" and "only unread"
15:42:50 <jmcarthur> aside from never using "hide" and changing your preferences all the time and voting on everything
15:45:05 <revenantphx> Gr, 1:20 more till hackage comes back up?
15:45:19 <ddarius> Web 2.0: It steals your jobs.
15:45:20 <lispy> revenantphx: that's a tentative deadline
15:45:31 <sinelaw> ddarius, it seems to have given them to me
15:45:33 <lispy> revenantphx: it really depends on how the electrician's work goes
15:45:35 <sinelaw> not very fun though
15:45:58 <sinelaw> I didn't know computers still run on electricity nowadays
15:46:07 <sinelaw> i though it was eco-midgets
15:46:23 <ddarius> Eco-midgets produce too much methane.
15:46:27 * companion_cube thought it was dark mater energy
15:47:29 <revenantphx> Why does it say "hackage 2 test site"
15:49:52 <revenantphx>  Is it possible to manually download/install stuf from sparky?
15:49:56 <revenantphx> with cabal I mean
15:51:26 <Saizan> wget the tarball untar and run "cabal install" from the resulting dir is one way
15:51:36 <Saizan> or you could add it as another remote repo
15:52:15 <revenantphx> how does cabal handle multiple remotes?
15:53:44 <lispy> revenantphx: you can list multiple server lines in your config.  It will try them in order
15:53:51 <revenantphx> I see.
15:53:59 <revenantphx> I just did it manually... I just needed enum map
15:54:14 <revenantphx> aw crap, enum map depends on containers-0.2 and I installed 0.3
15:54:20 <revenantphx> can I safely *also* install 0.2?
15:54:22 <revenantphx> without a mess?
15:54:34 <revenantphx> http://sparky.haskell.org:8080/package/containers-0.2.0.1
15:54:36 <revenantphx> god dammit
15:54:39 <revenantphx> theres no tarball.
15:54:42 <lispy> revenantphx: I'd would try to first unpack it and bump the dependency
15:54:51 <lispy> revenantphx: 'cabal unpack foo'
15:55:17 <revenantphx> can't I just edit the dep in the .cabal file?
15:55:31 <revenantphx> er... it explicitly says containers >= 0.2.0.1 && < 0.3
15:55:47 <monochrom> do you mind just using haskell-platform altogether? I could upload a tarball of that...
15:55:55 <revenantphx> what?
15:56:00 <revenantphx> I'm just trying to get a few packages.
15:56:21 <revenantphx> I'm tentative about enum map now thouhg.
15:56:22 <monochrom> famous last words :)
15:56:32 <revenantphx> It's a year old and the dependency is out of date.
15:56:47 <kmc> yeah i had problems installing it for this reason
15:56:55 <kmc> you can just use IntMap through fromEnum/toEnum
15:57:03 <kmc> annoying but not difficult
15:57:04 <monochrom> I see, haskell-platform chooses containers-3 too.
15:57:25 <revenantphx> Well, I ay not need enum map too be hones.
15:57:33 <revenantphx> I was just told it was good since it gets O(1) access times
15:58:41 <kmc> asymptotic complexity is misleading
15:58:52 <revenantphx> I agree.
15:58:54 <kmc> EnumMap and Map API are very close
15:59:01 <kmc> so you can start with Map and switch if you have performance problems
15:59:08 <revenantphx> Yeah, thats what I was thinking.
15:59:13 <kmc> if your keys are already Int, there's no reason *not* to use IntMap
15:59:22 <revenantphx> They're not though.
15:59:24 <kmc> and EnumMap is an attempt to generalize this for-free improvement
15:59:24 <revenantphx> theyre tuples.
15:59:28 <kmc> but it has build problems
15:59:33 <revenantphx> IntMap would work for my player table though.
15:59:45 <revenantphx> Well, I have an interesting issue here.
15:59:46 <kmc> there's also hashmap
15:59:51 <revenantphx> I need a table of entities with information there.
15:59:53 <kmc> which is IntMap on a hash key + Map on collisions
15:59:57 <revenantphx> which is Int -> EntityData
16:00:04 <revenantphx> And I need a String -> Int table for players.
16:00:09 <revenantphx> To associate player names to entity ids
16:00:24 <revenantphx> So IntMap won't work for the String map, but oh well.
16:01:37 <revenantphx> um... shit
16:01:40 <revenantphx> I broke everything TT_TT
16:01:47 <monochrom> \∩/
16:02:01 <revenantphx> https://gist.github.com/728615
16:02:03 <revenantphx> what happened?
16:02:04 <adnap_> what is wrong with this: http://hpaste.org/42076/what
16:02:14 <revenantphx> containers is recursive now :\
16:02:25 <adnap_> (i think it's a pretty noob question)
16:03:01 <revenantphx> I think its the install of containers I did.
16:03:20 <mauke> adnap_: BT :: BT, which is too specific
16:03:36 <mauke> adnap_: foo's type says I can choose any instance of B I want
16:04:10 <revenantphx> monochrom: mauke: help I broke it all TT_TT
16:04:34 <adnap_> mauke: But how can I return anything but a specific instance of B?
16:04:36 <revenantphx> how can I remove a package with haddock...?
16:04:38 <revenantphx> er, cabal*
16:05:00 <mauke> adnap_: with that code? you can't
16:05:04 <mauke> adnap_: foo is impossible
16:05:07 <adnap_> noooo
16:05:14 <adnap_> that's crazy
16:05:14 <monochrom> did you f**k with your container-3?
16:05:42 <revenantphx> monochrom: yes...
16:05:50 <revenantphx> it's missing containers-0.3.0.0-ee442470d8dcc9e45f31677c400c5379
16:05:53 <adnap_> What I'm trying to do is write a function that projects a planar polygon in R^3 to a Polygon in R^2.
16:06:00 <adnap_> A polygon could be anything.
16:06:06 <revenantphx> how can I uninstall it?
16:06:09 <mauke> [Point]
16:06:13 <adnap_> yeah
16:06:19 <adnap_> Let me post code.
16:06:45 <sipa> what is TT_TT?
16:06:47 <killerswan> am I the only who can't connect (in any way) to hackage right now?
16:06:58 <monochrom> you now have to rebuilt all those other packages such as Cabal-1.8.0.6 and regex-base-0.93
16:07:05 <mauke> sipa: annoying
16:07:06 <killerswan> neither cabal nor the web page works...
16:07:30 <revenantphx> monochrom: ...what?
16:07:36 <FunctorSalad> adnap_: what's the encoding of your polygon?
16:08:17 <revenantphx> Is there any way I can just... remove the broken containers?
16:08:20 <monochrom> this web page won't solve your problem (not directly), but it explains why the problem happens to begin with: http://www.vex.net/~trebla/haskell/sicp.xhtml
16:08:30 <Cale> killerswan: It's scheduled downtime
16:08:38 <adnap_> FunctorSalad: I'm going to post code.
16:08:39 <mauke> misleading sicp!
16:08:52 <Cale> killerswan: http://twitter.com/haskellorg
16:08:54 <revenantphx> monochrom: is there an easy way to fix this TT_TT
16:08:56 <killerswan> Cale: aha :D
16:09:03 <monochrom> if you have not lost the previous containers-0.3 (unlikely), things could be restored.
16:09:11 <revenantphx> Ok, and where would it be
16:09:43 <monochrom> most likely the previous containers-0.3 was overwritten already.
16:10:06 <monochrom> do you happen to have a filesystem that supports a lot of undo-es?
16:10:15 <revenantphx> HFS+. not likely.
16:10:24 <revenantphx> .cabal/lib/containers-0.3.0.0
16:10:27 <revenantphx> only one of them TT_TT
16:10:41 <adnap_> http://hpaste.org/42077/polygon_projection
16:10:45 <revenantphx> Where would the original go?
16:10:47 <monochrom> hrm? you have no containers-0.3 in global?
16:10:54 <revenantphx> where would it be in global 0.0
16:11:15 <monochrom> "ghc-pkg list containers" lists all of them, global and user, all versions
16:11:31 <monochrom> hell, "ghc-pkg -v list containers" so you see the hash values too
16:11:33 <revenantphx>    containers-0.3.0.0
16:11:34 <revenantphx>    containers-0.3.0.0
16:11:54 <monochrom> oh good, maybe one of them is the old one you need.
16:12:05 <revenantphx>    containers-0.3.0.0 (containers-0.3.0.0-ee442470d8dcc9e45f31677c400c5379)
16:12:08 <revenantphx> this one is the one I want.
16:12:12 <revenantphx> It's in GHC.framework
16:12:24 <monochrom> ok, ghc-pkg unregister the other one
16:12:25 <revenantphx> this is the extra one /Users/dlukes/.ghc/i386-darwin-6.12.3/package.conf.d
16:12:42 <revenantphx> um, how do I type it in?
16:12:47 <revenantphx> ghc-pkg unregister containers-0.3.0.0-5e5316afb979d62081115c0576cc0513 doesn't work
16:13:04 <monochrom> ghc-pkg --user unregister containers-0.3.0.0
16:13:16 <adnap_> FunctorSalad: did you see my paste?
16:13:22 <monochrom> (I hope it's in user not global)
16:13:33 <revenantphx> :O
16:13:35 <revenantphx> it works now.
16:13:47 <revenantphx> How should I clean up the files?
16:14:04 <monochrom> "package containers-0.3.0.0-ee442470d8dcc9e45f31677c400c5379 is shadowed by package containers-0.3.0.0-5e5316afb979d62081115c0576cc0513" was the important error message
16:14:28 <revenantphx> so... I can't update containers ever?
16:14:37 <revenantphx> er rather, I can't install the same version.
16:14:43 <revenantphx> I could still install 4.00 
16:14:47 <monochrom> my url above has location of files, but for linux. you probably can adapt them to mac.
16:14:48 <FunctorSalad> adnap_: you need a type for generic polygons. or a typeclass 'Project' with 2 parameters
16:15:13 <revenantphx> .cabal/lib/containers-0.3.0.0
16:15:16 <revenantphx> can I delete this?
16:15:32 <monochrom> it or just one of its subdirectories
16:15:36 <adnap_> FunctorSalad: I don't think I can have a type for generic polygons because I've chosen to represent points as types in Data.Vec
16:15:37 <revenantphx> all of it.
16:15:44 <revenantphx> All the files were created today.
16:16:11 <FunctorSalad> adnap_: I mean 'data Poly2 = Poly2 [Vec2 Float]'
16:16:11 <monochrom> likely only one subdirectory called "blah blah 6.12.3 blah blah" anyway
16:16:20 <revenantphx> monochrom: there are no other subdirs
16:16:31 <monochrom> ok good, you can nuke it all then
16:16:34 <FunctorSalad> adnap_: since all you know about your input is that it has a list of vertices
16:16:34 <adnap_> FunctorSalad: But that will be a bitch if I want to write algorithms specific to Quads or Triangles or something.
16:16:37 <revenantphx> great.
16:16:46 <adnap_> FunctorSalad: I'll have to pattern match on the first 4 vertices or something.
16:16:46 <revenantphx> so, ghc-pkg manages what ghc sees.
16:16:52 <revenantphx> And cabal is an abstraction on top of that?
16:16:59 <monochrom> See my article.
16:17:06 <adnap_> FunctorSalad: Right?
16:17:17 <monochrom> And yes, I do have "the abstraction leaks" in my article.
16:17:28 <FunctorSalad> adnap_: then you need a 'class Project a b | a -> b where project :: a -> b'
16:17:37 <FunctorSalad> instance Project Quad3 Quad2
16:17:41 <sohum> grargh hackage is down
16:18:05 <adnap_> FunctorSalad: That's an okay solution.  Could I also use GADT to create a general Polygon type?
16:18:51 <unkanon> adnap_: are you re-writing the first chapters of The Haskell School of Expression?  :D
16:18:59 <adnap_> unkanon: I don't know what that is.
16:19:03 <FunctorSalad> adnap_: general in what sense?
16:19:04 <revenantphx> a cabal uninstall would be nice.
16:19:12 <unkanon> adnap_: it's a book. the first thing they implement is exactly a polygon data type
16:20:05 <adnap_> FunctorSalad: Something that encapsulates quads, triangles, and polygons with large numbers of points.
16:20:16 <adnap_> FunctorSalad: Would have multiple value constructors
16:20:31 <FunctorSalad> adnap_: so far that's only a plain ADT
16:20:35 <adnap_> unkanon: It's just a coincedence.  I'm writing a graphical program.
16:20:44 <unkanon> adnap_: as was the book :)
16:20:52 <FunctorSalad> with a GADT you could have the information whether it's a quad or triangle on the type level
16:21:06 <adnap_> FunctorSalad: But also I could handle Vec2 and Vec3 in one type, right?
16:21:32 <unkanon> adnap_: type Vertex = (Float,Float); data Shape = Polygon [Vertex]
16:21:37 <unkanon> that's from the book
16:21:43 <mreh> Ambiguous type variable `m' in the constraint: `Monad m'
16:21:44 <adnap_> unkanon: Okay, but I can't do that.
16:21:51 <mreh> I'm not even touching the Monad interface
16:21:52 <FunctorSalad> adnap_: that could be a type parameter
16:21:56 <adnap_> unkanon: I must use Data.Vec for convenience.
16:22:00 <unkanon> oh I see
16:22:06 <adnap_> FunctorSalad: right
16:22:06 <FunctorSalad> (which would be instantiated with either Vec2 or Vec3)
16:23:51 <adnap_> FunctorSalad: I honestly forgot why I didn't implement Polygon as a type.  I think it was 'cause I didn't want to handle special cases for algorithms which just work on lists of vertices.
16:24:16 <adnap_> FunctorSalad: But at the same time, I didn't want to pattern match on lists for specific types of polygons.
16:24:20 <revenantphx> monochrom: lesson learned, stick to ONE hackage 
16:25:14 <adnap_> FunctorSalad: I think that's why I have the type class.  So I can get lists of vertices when I need to, and write algorithms for specific types of polygons if they're not general.
16:25:20 <mreh> does haskell insist on giving a polymorhpic type a concrete instantiation when it remains entirely orthogonal to the implementation?
16:25:26 <mreh> haskell == GHC
16:25:50 <ray> =o byorgey is handing over oeis
16:25:59 <adnap_> FunctorSalad: I was thinking GADT might give me some extra flexibility, but unfortunately I'm not very familiar with GADT.  I've only seen a few examples.
16:26:06 <ray> i'd better collect all the ideas i had for that package
16:26:54 <aavogt> mreh: type variables have to turn into concrete types eventually
16:27:18 <copumpkin> ddarius: still up for doing something? sorry, my friend left then I took a long nap and just woke up
16:27:21 <mreh> e.g. let getLeft (Left a) = [a] ; getLeft r = [] in concatMap getLeft eithers
16:27:26 <aavogt> hmm, maybe not when they are  forall'd
16:27:27 <sohum> can I use GetOpt's ReqArg for -i foo -i bar -i baz being parsed into [foo,bar,baz] ?
16:27:47 <mreh> I don't care what the type of the Either is here, but it's still going to complain if I don't give eithers a concrete type
16:28:40 <mreh> the type of b in Either a b that is
16:29:55 <Eduard_Munteanu> :t ()
16:29:56 <lambdabot> ()
16:30:04 <hpc> mreh: i think what happens is it typechecks it, then removes values that can't be reached; any values that can need to be monomorphic
16:30:27 <hpc> so the first parameter to const can be polymorphic, ie
16:30:31 <hpc> (this is just a guess)
16:30:37 <aavogt> @type show . read
16:30:39 <lambdabot> String -> String
16:30:48 <aavogt> > show . read $ "()"
16:30:49 <lambdabot>   "()"
16:31:00 <hpc> @let id' = show . read
16:31:00 <lambdabot>  <local>:12:6:
16:31:00 <lambdabot>      Ambiguous type variable `a' in the constraints:
16:31:01 <lambdabot>        `S...
16:31:50 <Hilbert> h
16:32:11 <aavogt> ?ty runST
16:32:12 <lambdabot> forall a. (forall s. ST s a) -> a
16:32:17 <mreh> must not get distracted by minutiae
16:32:33 <Eduard_Munteanu> :t pure
16:32:34 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
16:32:46 <Hilbert> Is i possible to use prefix notation for addition in haskell, in lisp you can do (+ 3 4 5) 
16:32:57 <Eduard_Munteanu> Grr, Monad isn't Applicative.
16:33:09 <mreh> > fold (+) [3,4,5]
16:33:10 <lambdabot>   Not in scope: `fold'
16:33:11 <Eduard_Munteanu> I have to use the ugly return instead of pure, it seems.
16:33:15 <aavogt> > (+) 3 4 5 :: Int
16:33:15 <mreh> wut
16:33:16 <lambdabot>   7
16:33:29 <mreh> lol
16:33:41 <Eduard_Munteanu> > 3 5
16:33:41 <lambdabot>   Ambiguous type variable `t' in the constraint:
16:33:42 <lambdabot>    `GHC.Num.Num t' arising f...
16:33:42 <mreh> > 7 5 :: Int
16:33:43 <lambdabot>   7
16:33:43 <hpc> > foldr 5 [1..10]
16:33:44 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [t])
16:33:44 <lambdabot>    arising from a use ...
16:33:52 <Eduard_Munteanu> Ha.
16:33:55 <hpc> > foldr 5 6 [1..10]
16:33:56 <lambdabot>   5
16:34:11 <aavogt> Hilbert: practically you'd do       sum [3,4,5]
16:34:12 <mreh> Caleskell?
16:34:27 <mreh> > sum [1..10000]
16:34:28 <lambdabot>   50005000
16:34:30 <mreh> > sum [1..1000000]
16:34:32 <hpc> instance Num a => (a -> b) where fromIntegral = const
16:34:32 <lambdabot>   *Exception: stack overflow
16:34:34 <hpc> etc
16:34:37 <mreh> oh noes!
16:34:45 <hpc> sum isn't strict it seems
16:34:49 <Hilbert> aavogt: Thanks but I would like if you could do it like in list
16:34:51 <mreh> > sum' [1..1000000]
16:34:51 <Hilbert> *lisp
16:34:52 <lambdabot>   Not in scope: `sum''
16:34:53 <copumpkin> hpc: Num b ?
16:34:54 <Eduard_Munteanu> @src mapM_
16:34:54 <lambdabot> mapM_ f as = sequence_ (map f as)
16:34:55 <unkanon> > foldl' 0 [1..1000000]
16:34:55 <mreh> doh
16:34:56 <lambdabot>   Overlapping instances for GHC.Show.Show ([b] -> [t])
16:34:56 <lambdabot>    arising from a use ...
16:35:01 <Eduard_Munteanu> @src sequence_
16:35:01 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
16:35:04 <unkanon> > foldl' 0 (+) [1..1000000]
16:35:04 <killerswan> > :type sum
16:35:05 <aavogt> hpc: the result is in Num
16:35:05 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a -> a)
16:35:05 <lambdabot>    arising from a use...
16:35:05 <lambdabot>   <no location info>: parse error on input `:'
16:35:11 <Eduard_Munteanu> :t sequence_
16:35:12 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
16:35:17 <hpc> aavogt: oh, right
16:35:17 <mreh> > foldl' (+) 0 [1..1000000]
16:35:18 <hpc> derp
16:35:18 <lambdabot>   500000500000
16:35:21 <mreh> I win
16:35:23 <unkanon> yeah that's what I mean
16:35:26 <Eduard_Munteanu> :t mapM_
16:35:27 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
16:35:33 * mreh is triumphant
16:35:38 * unkanon lolz
16:35:58 <seckin> Are there career or research opportunities where people are using haskell for development?
16:36:09 <ezyang> Galois! 
16:36:13 <Hilbert> Why  doesn't min 3 4 5 6 work?
16:36:14 <mreh> seckin: Jane Street
16:36:21 <seckin> Jane Street?
16:36:29 <killerswan> :t min
16:36:30 <ezyang> Jane Street uses OCaml 
16:36:30 <lambdabot> forall a. (Ord a) => a -> a -> a
16:36:31 <mreh> Jane Street capital
16:36:36 <mreh> and haskell, I'm told
16:36:38 <blackdog> Jane Street is ocaml-based.
16:36:46 <ezyang> o rly 
16:36:53 <blackdog> although a bunch of the people working there have haskell backgrounds
16:36:54 <mreh> Hilbert: because we don't roll that way
16:37:01 <revenantphx> what's record update syntax again?
16:37:13 <ezyang> x { field = newval } 
16:37:16 <mreh> > minimum [9,8,7,6,5]
16:37:17 <lambdabot>   5
16:37:28 <mreh> @src minimum
16:37:28 <lambdabot> minimum [] = undefined
16:37:28 <lambdabot> minimum xs = foldl1 min xs
16:37:33 <seckin> What does jane street develop?
16:37:52 <kmc> seckin, http://haskell.org/haskellwiki/Haskell_in_industry
16:37:53 <ezyang> There a financial company, so they do trading systems. 
16:37:55 <mreh> they're an investment firm, they only invest their own cash
16:38:04 <revenantphx> Okay, so now I do need some help with this kmc
16:38:08 <revenantphx> https://gist.github.com/728636
16:38:37 <mreh> Ganesh is Jane Street?
16:38:37 <kmc> what about it revenantphx 
16:38:40 <revenantphx> so, here I have two different cases where i need to add an item to entityMap
16:38:58 <revenantphx> so insert returns another intmap...
16:39:10 <kmc> yeah, it's a pure-functional update
16:39:18 <revenantphx> so... should I have the case return the updated entityMap?
16:39:23 <kmc> yes
16:39:30 <kmc> insert doesn't change the map you pass to it
16:39:35 <revenantphx> I know that.
16:39:39 <killerswan> @src foldl1
16:39:40 <lambdabot> foldl1 f (x:xs) = foldl f x xs
16:39:40 <lambdabot> foldl1 _ []     = undefined
16:39:45 <kmc> if you want to "maybe insert", you'd have to return the map unchanged on the other path
16:39:46 <revenantphx> so somethinglike
16:39:52 <revenantphx> (newEntityMap, otherstate) <- case...
16:39:54 <ezyang> mreh: No, he's Credit Suisse 
16:39:56 <kmc> (of course, operationally it's not doing a fully copy)
16:40:02 <revenantphx> and then always recursively call with newEntityMap
16:40:05 <kmc> probably
16:40:14 <kmc> or you could keep your map in an IORef
16:40:19 <revenantphx> But then, I have to do that for all of the cases, even the ones i don't change.
16:40:24 <kmc> yeah
16:40:28 <revenantphx> right, that's what I was thinking would be easier.
16:40:42 <kmc> it may be easier; it may also produce code which is harder to reason about
16:40:43 <kmc> it depends
16:40:46 <revenantphx> hm.
16:40:58 <kmc> especially if you have multiple threads
16:41:08 <revenantphx> egh yeah
16:41:31 <revenantphx> oh, so since its a pure structure, its safe to access from any thread right?
16:42:27 <revenantphx> this is a conundrum TT_TT
16:42:30 <kmc> yes
16:42:34 <kmc> a value is a value, now and forever
16:42:35 <Eduard_Munteanu> ByteString really really needs this...
16:42:37 <Eduard_Munteanu> bsMapM_ :: (Monad m) => (Word8 → m a) → B.ByteString → m ()
16:42:37 <Eduard_Munteanu> bsMapM_ f xs = B.foldr (\x acc → f x >> acc) (return ()) xs >> return ()
16:42:43 <kmc> values don't change over time, that's a contradiction in terms.  in any language
16:43:07 <revenantphx> Er, thats not the conundrum bit.
16:43:10 <monochrom> you don't "change 5" by "adding 1 to it".
16:43:12 <kmc> sure
16:43:16 <seckin> Are functional programming languages chosen for work in finance for any particular reason?
16:43:19 <revenantphx> The conundrum bit is how to manage this.
16:43:27 <mreh> Mathematica lets you change values
16:43:36 <kmc> seckin, Haskell has significant strength in the area of domain-specific embedded languages
16:43:42 <kmc> which are useful for things like derivatives modeling
16:43:44 <kmc> there's some papers on this
16:43:44 <Eduard_Munteanu> #define 1 2     // ?
16:43:51 <ezyang> That's the traditional success story of FP in finance 
16:44:05 <revenantphx> monochrom: you have any idea?
16:44:09 <revenantphx> https://gist.github.com/728636
16:44:29 <ezyang> Jane Street uses OCaml for everything. I think they did this because a bunch of early employees thought it would be good and stuck with it because they were just more productive with it. 
16:44:30 <monochrom> no
16:44:31 <revenantphx> The issue is how to mange the entityMap (and more state such as an map of map data(
16:45:44 <monochrom> I just mean tl;dr
16:45:49 <revenantphx> oh, the issue is commented.
16:46:08 <revenantphx> I have multiple case statements, which may or may not produce a new entityMap.
16:46:13 <seckin> Are there other financial companies which use fp of which you're aware?
16:46:19 <revenantphx> So it seems like the pure choice would be to have *every case* return the amityState.
16:46:26 <revenantphx> Regardless of whether they modify it or not.
16:46:28 <mreh> cant we have special haddock warnings where a function is partial
16:46:45 <revenantphx> There's also that issue about dequeuing and keep alives jmcarthur 
16:46:51 <revenantphx> that you brought up.
16:47:28 <monochrom> I'll just tell you what I did to my pet project. I had a Data.Map shared by several threads; some threads would modify it. I put one in an MVar. (Today I would use a TVar.) Modifiers just took out old versions and put in new versions. End of story.
16:48:21 <revenantphx> hm. that might be the most prudent given possible future use across threads.
16:48:24 <blackdog> seckin: http://www.haskell.org/haskellwiki/Haskell_in_industry
16:48:56 <blackdog> but off the top of my head: standard chartered and barclay's
16:49:10 <blackdog> and curt sampson had a pretty sweet trading setup at tsuru
16:50:08 <revenantphx> monochrom: I'm noticing STM can be used to manage state? Just a side effect of its intended use?
16:50:25 <revenantphx> monochrom: as in, it can do similar things to STRef or IORef in terms of use.
16:51:30 <monochrom> STM is intended to be mutable state.
16:51:47 <hpc> i thought STM was software transactional memory
16:52:01 <hpc> oh, derp
16:52:06 * hpc misses the obvious
16:52:08 <revenantphx> ?
16:52:32 <revenantphx> what, the word "memory"?
16:52:46 <hpc> no, that software transactional memory /is/ mutable
16:52:51 <geheimdienst> software transactional molasses
16:52:56 <killerswan> hahaha
16:53:07 <monochrom> "memory" is hardware speak for mutable state
16:53:52 <monochrom> I be damned if your brain memory were not mutable. :)
16:55:57 <Eduard_Munteanu> Would it make sense for a ByteString to have a Foldable instance, given it always "contains" Word8s? If so, I suspect it should be for a forgetful functor, like data BS a = BS ByteString (never tried).
16:57:16 <Eduard_Munteanu> :t mapM
16:57:17 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
16:57:18 <kmc> how would you implement foldMap?
16:57:35 <kmc> foldMap :: (Monoid m) => (a -> m) -> ByteString -> m
16:58:03 <Eduard_Munteanu> Grr. I suppose it's not possible given m is universally quantified.
16:58:15 <kmc> i don't think that's why it's not possible
16:58:24 <kmc> the function (a -> m) is useless because the type a is useless
16:58:28 <kmc> you can't force a = Char
16:58:31 <kmc> for this to actually make sense, you'd need to make Foldable into a multi-param type class
16:58:42 <kmc> class Foldable container elem where { foldMap :: (Monoid m) => (elem -> m) -> container -> m }
16:58:47 <kmc> instance Foldable [a] a
16:58:49 <Eduard_Munteanu> Oh.
16:58:51 <kmc> instance Foldable ByteString Char
16:58:59 <kmc> you'd probably want a fundep container -> elem
16:59:08 <kmc> and you'd probably actually use an associated type instead of multiple parameters
16:59:38 <kmc> err "instance Foldable ByteString Word8"
16:59:53 <Eduard_Munteanu> Hm, so it's better to just make a separate bsMapM_ for it.
17:01:36 <revenantphx> whats record update syntax?
17:01:45 <revenantphx> Like, how does it go again?
17:01:56 <c_wraith> r { foo = bar }
17:02:04 <c_wraith> where r is a record
17:02:11 <Eduard_Munteanu> revenantphx: data Foo a = Baz { a :: Int, b :: Int -> Int }
17:02:13 <copumpkin> kmc: Reducer?
17:02:14 <copumpkin> :P
17:02:21 <revenantphx> No, update syntax.
17:02:27 <Eduard_Munteanu> Oh, the update syntax explicitly.
17:02:35 <Eduard_Munteanu> Yeah.
17:02:39 <revenantphx> I think its var{fieldtoChange = newValue}
17:02:45 <copumpkin> revenantphx: c_wraith just said that, yes
17:02:50 <Eduard_Munteanu> revenantphx: yes.
17:03:06 <revenantphx> oh, right.
17:03:09 <revenantphx> missed that, sorry XD
17:03:35 <c_wraith> record update syntax binds more tightly than function application, by the way
17:04:07 <c_wraith> "f rec { field = value }" is the same as "f (rec { field = value })" 
17:06:51 <revenantphx> um so... IntMap has Key typed to key... so if I have an int32, I need to make a key from that... how?
17:08:14 <copumpkin> revenantphx: fromIntegral, sadly
17:08:20 <copumpkin> I hate hate hate Int
17:08:43 <revenantphx> In this program, where I always use explicitly sized integers... Int is terribl
17:09:01 <revenantphx> makeKey k = fromIntegral k :: Key
17:09:18 <hpc> Integer++
17:09:29 <copumpkin> hpc: good luck squeezing that into a native int
17:10:28 <hpc> why does it need to be word-sized?
17:11:10 <kmc> you don't need to say :: Key
17:11:24 <kmc> Key is only a type synonym
17:11:32 <kmc> which means it's totally interchangeabe with the type Int
17:11:47 <revenantphx> mm.
17:11:48 <kmc> furthermore inference is probably enough to determine the polymorphic return type of fromIntegral
17:12:03 <revenantphx> I just made mkKey
17:12:08 <revenantphx> so it's a bit more... readable.
17:14:23 <copumpkin> kmc: it does, to have to squeeze into IntMap
17:14:35 <copumpkin> assuming that's definitely what you want
17:14:38 <copumpkin> but it probably isn't :)
17:17:46 <revenantphx> er... how can I convert an int to a double?
17:18:04 <revenantphx> the designer of the protocol thought it'd be a great idea to spawn entity positions with ints, but have their movement be doubles.
17:18:06 <revenantphx> (the fuck)
17:18:31 <Cale> revenantphx: fromIntegral
17:18:38 <revenantphx> Is that for *all of them*?
17:18:49 <revenantphx> It's been overloaded like hell XD
17:20:12 <c_wraith> @src fromIntegral
17:20:12 <lambdabot> fromIntegral = fromInteger . toInteger
17:20:28 <c_wraith> @src Num
17:20:28 <lambdabot> class  (Eq a, Show a) => Num a  where
17:20:29 <lambdabot>     (+), (-), (*)           :: a -> a -> a
17:20:29 <lambdabot>     negate, abs, signum     :: a -> a
17:20:29 <lambdabot>     fromInteger             :: Integer -> a
17:20:35 <revenantphx> I... see...
17:20:52 <c_wraith> where's toInteger? >_>
17:21:01 <c_wraith> :t fromIntegral
17:21:02 <lambdabot> forall a b. (Integral a, Num b) => a -> b
17:21:02 <sipa> :t toInteger
17:21:03 <lambdabot> forall a. (Integral a) => a -> Integer
17:21:09 <c_wraith> ah, it's in Integral
17:21:12 <c_wraith> @src Integral
17:21:13 <lambdabot> class  (Real a, Enum a) => Integral a  where
17:21:13 <lambdabot>     quot, rem, div, mod :: a -> a -> a
17:21:13 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
17:21:13 <lambdabot>     toInteger           :: a -> Integer
17:24:37 <fysx2> ghci vs hugs?
17:24:50 <lispy_> fysx2: ghci
17:24:56 <fysx2> pros and cons?
17:24:59 <c_wraith> ghci supports many more features, and is developed much more actively
17:25:14 <c_wraith> hugs is probably slightly smaller as a download and in-memory.
17:25:26 <lispy_> fysx2: hugs is old and not really what serious haskellers use.  ghci has better error messages, it's industrial strength, and is actively developed by a great team
17:25:53 <Eduard_Munteanu> Here's what I got in the end, it's pretty fast: http://paste.pocoo.org/show/300547/
17:26:01 <Eduard_Munteanu> 0.8s vs 0.3s the C variant.
17:26:10 <Eduard_Munteanu> I'd appreciate any comments.
17:30:02 <Eduard_Munteanu> This pastebin seems better at UTF8: http://codepad.org/hnM8qEGt
17:31:38 <sshc> hugs is written C, supports way too few extensions, and is dead.
17:31:50 <Eduard_Munteanu> It's been some ordeal writing this to be this fast.
17:32:20 <fysx2> yeah.. so i'm hearing that i shouldn't waste my time playing around with hugs
17:32:26 <c_wraith> Eduard_Munteanu, But now that you know what you do, think you could do it more easily in the future?
17:32:33 <fysx2> basically just use GHC for everything
17:32:40 <Eduard_Munteanu> I guess those synthetic, overly simple benchmarks I did were useful.
17:34:10 <Axman6> fysx2: no one really uses hugs these days. i believe hugs gives better error messages, but that's about it.
17:34:11 <Eduard_Munteanu> c_wraith: I guess so. I do have some rules of thumb now, like "don't use B.unpack" :)
17:34:41 <Eduard_Munteanu> And not to trust deforestation that much.
17:35:02 <Eduard_Munteanu> (At least for such apps, I wouldn't care for a GUI app.)
17:35:25 <c_wraith> right.  90% of code, performance doesn't matter much
17:35:41 <c_wraith> You only really need to power-optimize tiny bits, overall
17:36:00 <Axman6> Eduard_Munteanu: why not use the ST monad for what you're doing?
17:36:42 <Eduard_Munteanu> Axman6: I'd need to carry the resulting bytes around if I did. This way I avoid packing them back into a bytestring/handle.
17:36:54 <Axman6> i'd make getCounts do everything with ST to avoid copying those arrays all the time
17:37:14 <joe6> hackage is back.. good times...
17:37:43 <Eduard_Munteanu> I still can't compete with my "a couple of hours version", but I can compete with my colleages at the univ who did it in C (few) and certainly with Matlab.
17:38:12 <Eduard_Munteanu> Axman6: getCounts does use ST, it's a STUArray.
17:38:28 <Axman6> oh so it is, my bad :)
17:39:05 <Eduard_Munteanu> *couple of hours C version
17:39:40 <monochrom> competition leads to improvement
17:40:55 <Eduard_Munteanu> I asked my instructor if I could present future homework written in Haskell, and he was like "Wha'? What's that? Oh, I suppose you can."
17:41:00 <fysx2> ah good question... STArray vs IOArray ?
17:41:15 <Eduard_Munteanu> And I didn't want it to be too slow.
17:41:39 <Axman6> fysx2: what's the question? :P
17:42:00 <ion> axman6: Which one begins with an S?
17:42:02 <fysx2> i've seen the ST monad.. but what is it and why would i use it instead of IOArray ?
17:42:32 <hpc> i sort of want to introduce my linear algebra professor to haskell
17:42:48 <revenantphx> Okay, time for superfun string parsing TT_TT
17:42:50 <hpc> he decided to kick off a sophomore level class with a lecture on forall and exists, on the second day
17:42:51 <Axman6> ST allows you to write algorithms with real mutability, just like IO, but to everything outside the ST monad, it looks completely pure
17:42:52 <kmc> fysx2, the difference is that ST gives you runST :: ST a -> a
17:42:58 <kmc> except the actual type is more complicated
17:43:08 <kmc> but the idea is that you can safely turn an ST action into its resulting value
17:43:18 <kmc> while doing the same to an IO action is the notorious unsafePerformIO
17:43:22 <Eduard_Munteanu> fysx2: if you're already in the IO monad, I guess sometimes it's more convenient to use an IOArray, esp. if you want to keep some sort of global mutable state.
17:43:59 <kmc> it should also be noted that there's a perfectly safe stToIO
17:44:09 <Eduard_Munteanu> fysx2: while ST deals better in separating concerns (computing that array)
17:44:13 <kmc> you can run a whole ST action within the IO monad at no penalty
17:44:17 <hpc> stToIO = return . fromST?
17:44:20 <kmc> it's maybe a little faster than that, I'm not sure
17:44:22 <hpc> *runST
17:44:27 <fysx2> axman6: so then a method using an ST monad looks pure but has side effects?
17:44:36 <BMeph> I like the STFUArray. The answers come back so obviously, that you feel a little silly for even asking! ;)
17:44:47 <kmc> fysx2, the side effects are encapsulated within the runST call
17:44:49 <monochrom> haha
17:44:50 <Eduard_Munteanu> hpc: oh so he did have some background on that.
17:44:50 <kmc> that's the point
17:44:53 <revenantphx> BMeph: The API is a bit abrasive though.
17:44:56 <kmc> and there's a little type trickery to ensure that
17:45:07 <Axman6> well, no real IO side effects, they are actually pure actions, they will always return the same result, so it's ok to make them look pure
17:45:13 * monochrom introduces the RTFMArray
17:45:22 <kmc> fysx2, ST lets you use a local "closed world" of mutation and provide a pure functional interface
17:46:55 <Axman6> you can say implement a pure in place quicksort using STArrays, and because its results will always be the same, there's no reason to stick it in IO and have its results tainted by it
17:47:06 <BMeph> revenantphx: True, true... :)
17:47:40 * BMeph waits with baited breath to see if anyone EVAR uses monochrom's Array...
17:47:59 <Eduard_Munteanu> Yeah, it still doesn't compare to Matlab syntax if you want to write imperative-style algorithms like that.
17:48:03 <timemage> BMeph, bated we hope. =)
17:48:04 <Eduard_Munteanu> Or C.
17:48:18 <augur> kmc!
17:49:08 <Eduard_Munteanu> Which makes me wonder whether it isn't better to just FFI in those cases.
17:49:29 <BMeph> timemage: Eh? Did you mean "basted", or what?
17:49:43 <Eduard_Munteanu> I think "bathed".
17:50:00 <Eduard_Munteanu> IIRC.
17:50:01 <timemage> BMeph, no.  "bated breath"  as in "held breath".    not baited like fish bait.
17:50:02 <BMeph> Eduard_Munteanu: Ah, another good alternate. :)
17:50:07 <monochrom> "breathed breath" makes the most sense
17:50:32 <BMeph> timemage: Ah. I learned that word as "abated". ;)
17:50:38 <Eduard_Munteanu> Google says "bated", my bad.
17:50:49 <timemage> BMeph, you could bait your breath i suppose.  but that would be nonsensical and a little gross. =)
17:51:06 <Axman6> just eat some sardines!
17:51:17 <BMeph> timemage: With cheese, sure. With cinnamon and chocolate... ;)
17:51:18 <timemage> BMeph, a- (in a state of).  <shrugs>
17:51:24 <Axman6> you'll have tuna trying to kiss you all day long
17:51:54 <taktoa> has no one made the mastur*bate* joke?
17:52:09 <monochrom> no
17:52:17 <timemage> BMeph, funny you should mention cheese.  look up "Cruel Clever Cat"  =)
17:52:20 <Axman6> masturbated breath
17:52:28 <monochrom> god no
17:52:32 <Axman6> I'm not quite sure where to go with that
17:53:08 <geheimdienst> axman6, don't worry, monochrom might say you've gone too far already
17:53:10 <geheimdienst> ;)
17:53:23 <Axman6> Oh i think I have too :P
17:53:38 <Eduard_Munteanu> Do people blush in here? :P
17:54:04 <monochrom> I brush my teeth here
17:54:22 <monochrom> so I can eliminate baited breath
17:55:32 <Eduard_Munteanu> No CT guys trying to discuss braided breath categories yet?
17:55:37 <fasta> How can generic Haskell code be faster than C code? http://dannyturner.net/?x=entry:entry100618-103229 I thought GHC didn't evaluate programs completely at compile time?
17:55:41 <geheimdienst> > "berated breath" == "belated breath"
17:55:42 <lambdabot>   False
17:55:49 <geheimdienst> lambdabot: thanks for confirming
17:55:58 <hpc> fasta: it evaluates what it can
17:56:05 <hpc> if it turns out to be a whole lot, then...
17:56:21 <fasta> hpc: at compile time? 
17:56:35 <hpc> fasta: sure; it's one of the optimizations
17:57:06 <hpc> it only does the blindingly obvious by default, iirc
17:57:11 <Eduard_Munteanu> Well IDK, but did he run it multiple times?
17:57:29 <Eduard_Munteanu> That test might not have any statistical relevance.
17:57:36 <fasta> hpc: but this requires some kind of termination detection. 
17:57:39 <Eduard_Munteanu> Especially given the low running time.
17:57:52 <fasta> hpc: otherwise there will be programs that it cannot compile. 
17:57:58 <hpc> fasta: sure; it's not like it solves the halting problem
17:58:08 <hpc> it picks a subset that it knows will always terminate
17:58:08 <fasta> hpc: how long does it have this according to you? 
17:58:24 <hpc> dunno
17:58:27 <copumpkin> hpc: it doesn't do that
17:58:37 <Eduard_Munteanu> fasta: that's just loop unrolling there if I'm not mistaken and strength reduction.
17:58:39 <copumpkin> GHC doesn't, anyway
17:58:46 <copumpkin> GHC doesn't even unroll loops
17:59:06 <copumpkin> it will be getting one or two different supercompilation approaches eventually
17:59:14 <fasta> I also had the belief that GHC didn't do a lot of stuff. 
17:59:14 <BMeph> Looked it up; apparently, "bated" is short for "abated"...somehow. It's even the same root as "rebate". No answer if it's related to "masturbate" though. ;)
17:59:15 <copumpkin> as there seem to be two parallel efforts 
17:59:26 <hpc> ah, that's what i was thinking of, probably
17:59:27 <Eduard_Munteanu> copumpkin: maybe through -fvia-c ?
17:59:56 <copumpkin> Eduard_Munteanu: if you do via-C you can ask it to unroll loops but I'm not sure it'll always even be able to spot loops, since GHC doesn't emit very idiomatic C
17:59:57 <hpc> that or one of the -O flags
18:00:02 <kmc> the LLVM backend might unroll loops or strength-reduce
18:00:06 <Axman6> woah... hang on, it's faster when using Integer? interesting
18:00:09 <BMeph> GHC puts the "fun" in "-funroll"! ;)
18:00:24 <Axman6> i thought that was gentoo
18:00:24 <kmc> gentoo puts the fomit in -fomit-frame-pointer
18:00:34 <Eduard_Munteanu> I think it's not statistically relevant to infer anything from that.
18:00:49 <copumpkin> there's something iffy in that blog post
18:00:53 <bl^ckh0le> how do I install cabal-install?
18:00:57 <copumpkin> I'd want to see the core :P
18:01:00 <bl^ckh0le> I have no module named System...
18:01:05 <Eduard_Munteanu> kmc: x86-64 & DWARF do that ;)
18:01:09 <bl^ckh0le> and yet I have the haskell98 package
18:01:11 <geheimdienst> is loop unrolling the gold standard for optimization somehow ...? i thought it might do good, might do harm (due to inner loops not fitting in L1 cache lines anymore, and the like)
18:01:15 <Eduard_Munteanu> Automagically.
18:01:16 <kmc> bl^ckh0le, the eternal chicken-and-egg problem
18:01:25 <kmc> bl^ckh0le, did you install GHC through Haskell Platform?
18:01:29 <bl^ckh0le> no
18:01:34 <copumpkin> bl^ckh0le: there's a bootstrap.sh
18:01:37 <kmc> any particular reason you couldn't do so?
18:01:38 <copumpkin> it'll get you started
18:01:39 <Eduard_Munteanu> geheimdienst: it might enable other optimizations.
18:01:46 <kmc> see http://hackage.haskell.org/platform/
18:02:02 <kmc> in particular the "Build from Cabal" section under the Linux instructions
18:02:05 <kmc> if you don't want to start over
18:02:13 <kmc> oh that requires cabal-install :/
18:02:21 <bl^ckh0le> ohh...
18:02:33 <Eduard_Munteanu> bl^ckh0le: use an existing Platform.
18:02:43 <kmc> seems that Haskell Platform considers FreeBSD to be a Linux distro...
18:02:47 <Eduard_Munteanu> and build whatever you need.
18:03:00 <Axman6> kmc: u meen itz not?
18:03:33 <Eduard_Munteanu> kmc: hm, does FreeBSD run Linux binaries?
18:03:37 <geheimdienst> if it no has a linix kernl, it no is linux
18:03:38 <unkanon> Axman6: you're kidding, right? :)
18:03:52 <kmc> Eduard_Munteanu, i think it can, but i don't think that's how the FreeBSD Haskell project works
18:03:59 <aristid> unkanon: his spelling seems to indicate that
18:04:03 <fasta> It's pseudo POSIX, which covers all consumer operating systems. 
18:04:05 <kmc> i should run GHC on Debian GNU/FreeBSD for maximum confusion
18:04:09 <bl^ckh0le> I have ghc 7 though :(
18:04:15 <unkanon> aristid: right, I was just being rhetorical :>
18:04:22 <fasta> When was the last time you were trying to run GHC on a Lisp Machine? 
18:04:34 <kmc> bl^ckh0le, ghc 7 is not intended for ordinary developers yet -- wait for the next HP release early next year
18:04:38 <kmc> or do you need a specific GHC 7 feature?
18:04:42 <Eduard_Munteanu> fasta: heh, are there any?
18:05:06 <Eduard_Munteanu> Anything recent and consumer I mean.
18:05:25 <fasta> Eduard_Munteanu: you can still buy one from a company. 
18:05:37 * geheimdienst would like to install ghc on his weird-ass integrity-178b operating system
18:05:59 <fasta> Eduard_Munteanu: you can also download the software development environment from TPB. 
18:06:06 <Eduard_Munteanu> Heh.
18:06:13 <fasta> Eduard_Munteanu: but this is not legal in most countries. 
18:06:33 <bl^ckh0le> kmc: darnit, ok
18:07:17 <Eduard_Munteanu> Is there any preliminary Platform release for Linux/Windows that includes GHC 7?
18:07:32 <Eduard_Munteanu> I'd like to try the LLVM backend.
18:08:05 <Eduard_Munteanu> Or do I have to get a barebones GHC binary or build it myself?
18:08:59 <luite> as long as you have a working cabal-install executable, you don't really need the platform. just don't be surprised if you have to fix one or two things to make all packages work
18:09:57 <Eduard_Munteanu> Oh, just cabal-install ghc?
18:10:02 <Eduard_Munteanu> Sounds interesting.
18:10:11 <luite> no, download ghc
18:10:20 <luite> and then cabal install everything else you need :)
18:10:48 <Eduard_Munteanu> Ah, GHC binary, get cabal-install, use it.
18:11:19 * Eduard_Munteanu wonders why more projects don't supply universal Linux binaries.
18:11:34 <Eduard_Munteanu> (I'm not sure GHC does either)
18:11:52 <fasta> Ok, I checked what GHC is doing. Basically it is just loop unrolling without evaluation. 
18:12:09 <fasta> There is also a limit which says that it doesn't unroll forever. 
18:12:22 <fasta> So, it's just a very conservative optimization. 
18:12:25 <jkimball4> Eduard_Munteanu: i suppose part of supporting more than a single processor architecture is the reason
18:12:44 <fasta> What does surprise is that C doesn't do these things. 
18:12:52 <fasta> Or rather gcc. 
18:13:06 <fasta> It wouldn't seem that hard to recognize these cases.
18:13:08 <Eduard_Munteanu> fasta: well are you really sure those benchmarks reflect anything? You've seen those tiny timings.
18:13:24 <Eduard_Munteanu> BTW, gcc does that.
18:13:30 <Eduard_Munteanu> And probably better than ghc.
18:13:52 <fasta> Eduard_Munteanu: I will look at the asm produced by gcc then. 
18:14:05 <fasta> Eduard_Munteanu: it is doing something which is completely unnecessary in anyway. 
18:14:17 <Eduard_Munteanu> GCC is a quite fine compiler, IMHO.
18:14:30 <fasta> Eduard_Munteanu: I didn't say it wasn't. 
18:14:45 <Eduard_Munteanu> I didn't say you did say it wasn't. :)
18:14:55 <djahandarie> Eduard_Munteanu, still working on that one problem?
18:15:21 <Eduard_Munteanu> djahandarie: I kinda solved it, I'm very happy about that: http://codepad.org/hnM8qEGt
18:15:34 <Eduard_Munteanu> djahandarie: it now runs in 0.8s vs 0.3s the C version.
18:15:43 <djahandarie> Looks more complicated this time. :P
18:15:44 <Eduard_Munteanu> Which is good enough for me.
18:16:25 <Eduard_Munteanu> djahandarie: basically only the packing part is more complicated, but it's along the lines of equivalent C code.
18:16:40 <BMeph> Yo, that's how we (un)roll! :)
18:17:02 <Eduard_Munteanu> and I'm not unpacking the ByteString anymore, plus a nice inline pragma.
18:17:21 <djahandarie> Eduard_Munteanu, why'd you decide to use Sequences instead of Vectors? (Just curious.)
18:18:23 <fasta> Eduard_Munteanu: how can I convince gcc to compute the answer at compile time? As it doesn't do this by default it doesn't count imho (even with -O3). 
18:18:53 <Eduard_Munteanu> djahandarie: I'm basically unconsing from both ends there, but I think Vector would do too.
18:19:02 <fasta> -funroll-all-loops should have gotten rid of all the loops. 
18:20:52 <djahandarie> Eduard_Munteanu, looking at the code it's possible Vector.Unboxed would do better here. If you feel like wasting more time trying it out. :P
18:20:55 <Eduard_Munteanu> fasta: could you try -march=native? It might be reluctant to increase the cache footprint.
18:21:49 <Eduard_Munteanu> djahandarie: yeah, I could. :)   Though that's not the bottleneck at all I think.
18:22:02 <Eduard_Munteanu> I'll probably do it and see if it looks nicer.
18:22:06 <fasta> Does anyone have an informed opinion about the various web frameworks that exist for Haskell? 
18:22:15 <augur> hpc, Gracenotes: so the gist of ListT m a should be an m-like computation of listy things... so binding a ListT m through f should produce an m-like computation of lists as well...
18:22:15 <fasta> Eduard_Munteanu: tried and it doesn't matter.
18:22:16 <djahandarie> No it didn't look like it from your original program which is why I didn't bother suggesting to switch from Lists
18:22:39 <Gracenotes> augur: oh my, it is far too busy here! let us move to -blah
18:22:49 <augur> Gracenotes: :P
18:22:56 <djahandarie> Maybe we need a #haskell2
18:23:06 <geheimdienst> #haskell'
18:23:10 <geheimdienst> ;)
18:23:10 <djahandarie> True
18:29:27 <Eduard_Munteanu> $ gcc -O3 -march=native -funroll-all-loops --param max-unrolled-insns=500 --param max-unroll-times=50 --param max-average-unrolled-insns=500 euler.c -o euler
18:29:39 <Gracenotes> o,o
18:29:42 <Eduard_Munteanu> fasta: something like that does it, but it's probably stupid to unroll that much.
18:30:26 <Eduard_Munteanu> It's easy to wreck havoc in the L1 insn cache.
18:31:05 <Eduard_Munteanu> I don't think GHC does it either. Unless you can do part of that computation compile-time.
18:32:04 <moozilla> can someone explain the (Monad m) => m a type?
18:32:18 <moozilla> can I just use any monad?
18:32:26 <Eduard_Munteanu> moozilla: yes
18:32:39 <fasta> Eduard_Munteanu: the whole computation can be done at compile time. 
18:32:48 <Eduard_Munteanu> moozilla: that type fits IO a, Maybe a etc.
18:33:17 <Eduard_Munteanu> fasta: yeah, though the compiler doesn't really know that I suppose.
18:33:20 <moozilla> Eduard_Munteanu, my problem is I get a type like (Monad m) => Handle -> IO (m ByteString)
18:33:24 <moozilla> but I don't want the m
18:33:44 <kmc> then you probably wrote "return" somewhere it was unnecessary
18:34:05 <moozilla> oh
18:34:10 <moozilla> I guess that was it
18:34:22 <moozilla> I thought I needed to have a return at the end of each do statement
18:34:25 <Eduard_Munteanu> fasta: although I wouldn't mind if the compiler would occasionally be eager to evaluate computations that don't depend on runtime values at compile-time, even if it would run in an infinite loop and waste time recovering.
18:34:27 <kmc> the tip-off is that there's few functions that are polymorphic to all monads
18:34:47 <moozilla> I was thinking the return might be the issue, but I thought it was necessary too
18:34:59 <kmc> moozilla, "return" is just a function that turns a value into a "do nothing" action
18:35:16 <moozilla> right, I think I understand now, I only need to return if nothing is happening
18:35:17 <kmc> you need it sometimes within a "do"-expression, because the statements in "do" have to be actions
18:35:20 <kmc> yeah exactly
18:35:21 <Eduard_Munteanu> It usually just applies the functor.
18:35:22 <moozilla> right
18:35:29 <moozilla> I know it's a -> m a
18:35:41 <kmc> and you can eliminate most uses of "return" if you want
18:35:44 <Eduard_Munteanu> and thus the data constructor.
18:35:51 <moozilla> I'm not totally confused by monads, I'm just not sure how to connect them most of the time
18:35:59 <kmc> because «do { x <- m; return (f x) }» is the same as «fmap f m»
18:36:06 <fasta> Eduard_Munteanu: I think the model of JIT compilation is superior in principle, because for larger programs you are otherwise just waiting each time for the compilation to finish. 
18:37:59 <Eduard_Munteanu> fasta: I'm not a fan of JIT-ing, I tend to consider that we could learn more if we improved AOT compilers using principles of JIT. That is, to me, JIT is nicely integrated incremental compiling, profiling and optimization.
18:38:32 <fasta> Eduard_Munteanu: AOT?
18:38:36 <Eduard_Munteanu> Maybe that's because I usually work with open source software.
18:38:41 <Eduard_Munteanu> fasta: ahead of time, say GCC.
18:38:46 <Eduard_Munteanu> non-JIT.
18:38:55 <fasta> Eduard_Munteanu: yes, I know of ahead of time. 
18:39:00 <Eduard_Munteanu> So I don't really care that much about bytecode.
18:39:49 <fasta> Eduard_Munteanu: after it has been JIT'ed there is no bytecode anymore.
18:40:06 <Eduard_Munteanu> I certainly think JIT principles are interesting, but I don't think it's anything new. People have been doing such optimizations in the AOT age too.
18:40:23 <copumpkin> Eduard_Munteanu: it's fundamentally impossible to know what the program will do at runtime all the time
18:40:26 <hpc> it could be interesting to have a multi-part compilation process
18:40:27 <copumpkin> which is where JIT is useful
18:40:31 <fasta> It's not about the optimizations. 
18:40:33 <hpc> where you AOT to bytecode for distribution
18:40:38 <fasta> It's about faster compilation. 
18:40:42 <copumpkin> you can do regular compilation optimizations and do interesting things at runtime
18:40:43 <fasta> Or even no compilation. 
18:40:43 <Eduard_Munteanu> fasta: well I understand the main idea behind the "portability" of bytecode is because they don't have to distribute source code ;)
18:41:02 <hpc> and the person installing the package "JIT's" it into binary, except it is still AOT compilation
18:41:09 <fasta> Eduard_Munteanu: you can easily write an obfuscator for that.
18:41:18 <kmc> fasta, after it's JIT'ed you usually keep the bytecode, because your JIT is rarely complete.  it's probably a trace of hot paths only
18:41:29 <unkanon> for which you can easily write a de-obfuscator
18:41:33 <kmc> no you can't
18:41:38 <kmc> obfuscation is an information-losing process
18:41:41 <Eduard_Munteanu> copumpkin: and that's where AOT compilers could learn. We're not all developers to run profile-based optimizations. But if AOT compilers continuously improved the compilation results... you'd end up with JIT.
18:41:42 <fasta> kmc: sure, it's only partially. 
18:41:48 <kmc> you can do things that help but you won't recover the variable names ;P
18:42:02 <unkanon> yes you won't recover the variable names but still
18:42:17 <unkanon> they have a pretty good decompiler for C even, that will output idiomatic C
18:42:22 <kmc> which?
18:42:22 <unkanon> hex something is the name
18:42:23 <Eduard_Munteanu> I don't think there's a fundamental difference between JIT and AOT.
18:42:25 <unkanon> pretty impressive
18:42:28 <Eduard_Munteanu> It's only marketing there.
18:42:31 <fasta> There are fundamental results that show that obfuscation is "impossible". 
18:42:31 <kmc> hexrays?
18:42:49 <unkanon> yes!
18:42:50 <Eduard_Munteanu> (actually that's what I mean when I say "I don't like JIT", don't get me wrong.)
18:43:24 <kmc> Eduard_Munteanu, the difference is the difference between static and dynamic analysis
18:43:25 <fasta> That would be a fairly interesting product to build, I suppose.
18:43:27 <kmc> which is a big difference
18:43:31 <kmc> see: halting problem
18:43:47 <fasta> The halting problem is not even a real problem. 
18:43:52 <fasta> It exists only in theory. 
18:43:59 <unkanon> ??
18:44:02 <fasta> Just like Turing machines do. 
18:44:05 <kmc> because our computers are finite yes yes
18:44:13 <Eduard_Munteanu> kmc: so AOT can't do profile-based optimisation? Sure they can. *Only it's not automated*
18:44:22 <fasta> I wish I had a Turing machine. 
18:44:31 <BMeph> The halting problem is a problem looking for a premature solution? ;)
18:44:34 <fasta> It would exist forever, would not need maintenance. 
18:44:36 <unkanon> turing machine is too state-y
18:44:51 <Eduard_Munteanu> People have been doing such optimizations in AOT for a long time.
18:44:54 <kmc> fasta, a function which grows faster than any computable function is probably infeasibly large for "real inputs", even though it's also O(1) ;P
18:44:54 <fasta> Infinite memory. 
18:45:00 <Eduard_Munteanu> Claiming JIT invented it is really misleading.
18:45:44 <fasta> Eduard_Munteanu: a technique cannot invent anything. 
18:45:48 <Draconx|Laptop> fatsa, turing machines do not have infinite memory.  At any given step of the computation, only a finite amount of tape is used.
18:46:02 <kmc> it is more accurate to say that they have unbounded memory
18:46:11 <fasta> Draconx|Laptop: ok, unbounded. 
18:46:34 <Eduard_Munteanu> So don't get me wrong, I'd really like it if GCC did that behind the scenes, optimizing already compiled code. It doesn't, but it could.
18:46:44 <Eduard_Munteanu> I can do it manually with -fprofile-arcs or such.
18:47:04 <Draconx|Laptop> you can imagine a turing machine as follows: whenever an attempt is made to move past the end of the tape, it pauses and says "please insert more tape", at which point you need to go to the store, buy another roll of tape, and feed it into the machine.
18:47:09 <Eduard_Munteanu> Only that it might waste more time than JIT.
18:47:16 <fasta> Ok, I would want to have a Turing machine with an I/O port then ;)
18:47:21 <kmc> Draconx|Laptop, you give it a trust fund endowment and have it buy more storage on S3
18:47:34 <kmc> malloc() blocks until it has enough money for more swap
18:47:50 <kmc> or perhaps you set non-blocking mode and get EINSERTCOIN
18:47:52 <hpc> hehe
18:48:03 <Eduard_Munteanu> LOL, EINSERTCOIN
18:48:12 <fasta> A platform with that property would actually be useful. 
18:48:25 <kmc> 402 Payment Required
18:48:31 <hpc> kmc: named for historical reasons, due to early attempts at running dialup through pay phones?
18:48:36 <kmc> surely
18:48:49 <fasta> It should obviously not delete everything if you forgot to pay immediately. 
18:49:08 <fasta> It should just move the state of your program somewhere else until you pay. 
18:49:30 <lispy> This may be of interest to some here, I created a subreddit for Isabelle/HOL: http://www.reddit.com/r/isabelle/
18:49:37 <teratorn> hpc: anyone running dialup though a payphone is redboxing or otherwise getting the call for phree :)
18:49:51 <fasta> lispy: why would I want to use Isabelle over Coq?
18:50:32 <lispy> fasta: I'm not sure why YOU would want Isabelle over Coq.  I'm learning it because HOLCF lets you reason about laziness in programs eg. you can write proofs about things in Haskell and correctly factor in laziness/bottom in the proof.
18:51:10 <Eduard_Munteanu> lispy: that looks nice.
18:51:21 <fasta> lispy: did you specifically design your programs in a certain way or did you decide afterwards that you wanted to prove anything about them?
18:52:11 <lispy> fasta: We're working (soon to be announced publicly) haskell-verifier.  It will help you write theorem in Isabelle about your Haskell code.  The goal is that you'll replace your QC properties with Isabelle proofs
18:52:42 <fasta> lispy: "we"?
18:52:46 <lispy> fasta: we're just getting started so you won't be able to use haskell-verifier for a while, but we'll be looking for help soon
18:52:47 <copumpkin> of course, actually writing those proofs
18:52:52 <copumpkin> might really kick your ass :P
18:52:59 <lispy> fasta: some PSU folks, a few co-workers, and myself
18:53:03 <copumpkin> but at least it'll be attached to your haskell code
18:53:08 <Eduard_Munteanu> What's "QC"?
18:53:10 <fasta> lispy: Galois?
18:53:13 <lispy> Eduard_Munteanu: quickcheck
18:53:17 <Eduard_Munteanu> Ah.
18:53:17 <lispy> fasta: yes
18:53:42 <fasta> lispy: I watched all the presentations about formal stuff online @ Galois. 
18:53:53 <fasta> lispy: fairly interesting. 
18:53:53 <lispy> fasta: awesome.
18:54:19 <Eduard_Munteanu> See seL4 for a real application.
18:54:23 <Eduard_Munteanu> But that's a bit overkill.
18:54:32 <fasta> lispy: how did you get to work there? 
18:54:39 <lispy> copumpkin: yeah, that will be tricky as always, but I'm hoping we can make the formal methods into a "pay as you go" and "only pay for what you need" endeavor this way
18:54:56 <lispy> fasta: they were hiring and I applied :)
18:55:20 <lispy> fasta: it helped that my masters was on an open source Haskell project and I had a fair bit of Haskell open source experience beyond that
18:55:21 <Eduard_Munteanu> Especially since they set out to prove the underlying C semantics.
18:55:24 <sshc> YAY hackage is back \°/
18:55:28 <fasta> lispy: were you already a US citizen? 
18:55:35 <lispy> fasta: yes
18:55:43 <fasta> lispy: I think that helps more. 
18:56:18 <fasta> lispy: it's just a pain in the ass for a company like that (I think) to hire people that cannot get all the security clearances. 
18:56:41 <fasta> "The following meeting is for all US citizens. " 
18:56:49 <fasta> At least, I can imagine that it works like that. 
18:57:04 <lispy> fasta: actually, I think visas are a bigger issue
18:57:27 <fasta> lispy: why exactly?
18:57:39 <fasta> lispy: do they have to prove that to American can do the same job?
18:57:43 <fasta> no*
18:57:58 <lispy> fasta: Well, I'm on a DoE project right now and the whole thing is public save for the IP we keep confidential.  a non-US citizen could easily work on that project
18:58:43 <lispy> We're getting a bit off topic though :)
18:58:54 <fasta> lispy: nobody else is talking. 
18:58:55 <lispy> (and I don't work in legal...)
18:59:56 <fasta> lispy: I think it's great that some companies are really moving to create programs that really work as opposed that hopefully work. 
18:59:57 <unkanon> I'll talk then: I'm trying to print the reductions in ghci, should I go for hat? I can't get trace to work...
19:00:42 <fasta> unkanon: you don't have to get trace to "work". It always works. You just do not know what it does ;)
19:01:03 <unkanon> worse, I don't know how to use it :)
19:01:03 <lispy> unkanon: have you tried ghci's debugger?
19:01:19 <unkanon> I'm not sure what ghci's debugger is/does
19:01:22 <lispy> it has a built-in interactive debugger
19:01:31 <lispy> Sort of like gdb, but for Haskell
19:01:43 <fasta> And like, a piece of sh*t :)
19:01:44 <lispy> IIRC, you can step through evaluation
19:01:56 <fasta> lispy: how many times have you used it? 
19:02:01 <lispy> 0 :)
19:02:10 <fasta> lispy: please do not advice people to use it then.
19:02:19 <unkanon> how do I use it?
19:02:35 <unkanon> I just need to see the reductions
19:02:37 <fasta> unkanon: trace "OMG" 1
19:02:38 <moozilla> could someone give me a tip on how to make this point-free?
19:02:39 <moozilla> getMCString len bs = return $ runGet (getLazyByteString (fromIntegral len)) bs
19:02:47 <fasta> unkanon: that shows "OMG"
19:02:52 <unkanon> fasta: yeah I actually just got trace working and concluded it's not what I need
19:03:02 <unkanon> @type trace
19:03:03 <lambdabot> Not in scope: `trace'
19:03:07 <fasta> unkanon: I understand what you need, and I don't think it is there. 
19:03:28 <lispy> unkanon: if you're trying to use the debugger (I'm going to try it now), you type :? to see the list of commands
19:03:30 <unkanon> @pl getMCString len bs = return $ runGet (getLazyByteString (fromIntegral len)) bs
19:03:30 <lambdabot> getMCString = (return .) . runGet . getLazyByteString . fromIntegral
19:03:37 <unkanon> moozilla: ^
19:03:58 <moozilla> thanks
19:04:04 <unkanon> no proble
19:04:05 <unkanon> m
19:04:05 <moozilla> what is (return .) for?
19:04:17 <moozilla> @type (return .)
19:04:18 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (Monad m, Functor f) => f a -> f (m a)
19:04:37 <revenantphx> Hey you guys, how would I set up a quick little function to do "<name> message" into [name, message]
19:04:50 <unkanon> moozilla: usually f . g $ x  (for one parameter) turns into ((f .) . g) $ x y  (for two parameters)
19:05:31 <lispy> oh hm.  Debugger doesn't work on things I define in ghci or things defined in libraries.  That does seem limited...
19:05:43 <fasta> revenantphx: read the manual for any parsing library?
19:05:55 <unkanon> @let slice i k xs = let dropped = drop i xs in take (k-i+1) dropped
19:05:56 <lambdabot>  Defined.
19:05:57 <revenantphx> Well, It's such minimal use I was hoping to avoid that.
19:06:13 <fasta> revenantphx: then don't use a parsing library. 
19:06:20 <revenantphx> fasta, okay hence I asked.
19:06:22 <unkanon> > slice 1 5 "<name> message"
19:06:24 <lambdabot>   "name>"
19:06:29 <unkanon> > slice 1 4 "<name> message"
19:06:30 <lambdabot>   "name"
19:06:32 <revenantphx> name could be longer silly.
19:06:35 <unkanon> now replace 4 for a function that finds >
19:06:35 <moozilla> I'm not understanding what (f .) . g is doing
19:06:39 <revenantphx> true
19:06:42 <lispy> > words "<name> message"
19:06:43 <lambdabot>   ["<name>","message"]
19:06:51 <unkanon> revenantphx: I know, silly :P
19:06:53 <moozilla> (f . g) is the same as f (g x)
19:06:54 <moozilla> right?
19:06:57 <revenantphx> What I'm going to run into is "<name> $command param param param"
19:07:00 <lispy> ?src (.)
19:07:01 <lambdabot> (f . g) x = f (g x)
19:07:01 <lambdabot> NB: In lambdabot,  (.) = fmap
19:07:05 <lispy> moozilla: ^^
19:07:16 <revenantphx> I need some function that can take a message in the form "$command param param param" and break it up... this should be fun.
19:07:34 <lispy> revenantphx: looks like, words would do that unless you can have spaces in the params
19:07:45 <revenantphx> No, there shouldnt be, so yea.
19:08:04 <unkanon> @type lookup
19:08:05 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
19:08:08 <fasta> lispy: have you used Atom? 
19:08:37 <lispy> fasta: I think I maintained some code that used atom, but not really no
19:08:42 <unkanon> moozilla: do you understand it now?
19:08:55 <fasta> lispy: do you know for example whether it is formalized and whether there is a formalized CPU to go with it? 
19:09:08 <lispy> fasta: oh wait, you mean? http://hackage.haskell.org/package/atom/
19:09:13 <lispy> fasta: I have not used that atom at all
19:09:22 <unkanon> moozilla: that's how you make the composition of two functions point free when the rightmost function takes two parameters
19:09:25 <fasta> lispy: yes, I meant that Atom. 
19:09:33 <moozilla> so ((f .) . g) x y would be (f .)(g x y)?
19:09:36 <fasta> lispy: not the messaging Atom (which I never used). 
19:09:40 <moozilla> no I don't quite understand it yet
19:09:51 <revenantphx> > let getName = init . tail . (!! 1) . words in getName "<revenant> blah blah blah"
19:09:52 <lambdabot>   "la"
19:09:58 <revenantphx> okaaay....
19:10:05 <revenantphx> > words "<revenant> blah blah blah"
19:10:06 <lambdabot>   ["<revenant>","blah","blah","blah"]
19:10:11 <revenantphx> oh, right 
19:10:14 <revenantphx> TT_TT
19:10:30 <unkanon> oh that's a good idea!
19:11:03 <revenantphx> :t not
19:11:04 <lambdabot> Bool -> Bool
19:11:06 <adnap_> what happens when two functions depend on each other to compute their respective answers?
19:11:15 <adnap_> how does ghc deal with that?
19:11:23 <unkanon> secretly :P
19:11:25 <moozilla> so (f .) x is basically just f (x)
19:11:25 <lispy> fasta: I think you should ask here: http://groups.google.com/group/fp-embedded
19:11:28 <moozilla> is that right?
19:11:55 <revenantphx> adimit: Lazily.
19:12:06 <revenantphx> adimit: I'm guessing it will just call them back and forth as needed....
19:12:14 <unkanon> @type head
19:12:15 <lambdabot> forall a. [a] -> a
19:12:18 <unkanon> @type (head .)
19:12:19 <lambdabot> forall a (f :: * -> *). (Functor f) => f [a] -> f a
19:12:35 <unkanon> moozilla: I wouldn't think of it like that
19:12:48 <adnap_> Oh, I see.  It doesn't deal with that.
19:13:08 <moozilla> unkanon, as wrapping with paranthesis?
19:13:51 <unkanon> moozilla: do you understand that (f . g) x = f(g(x)) ?
19:13:55 <moozilla> yes
19:14:01 <moozilla> that I understand perfectly
19:14:09 <unkanon> ok. that only works because g takes one parameter
19:14:17 <unkanon> if it took two, you'd have to write this:
19:14:25 <unkanon> ((f .) . g) x y
19:14:46 <unkanon> ((f .) . g) $ x y
19:15:15 <moozilla> I think I understand why, I just can't wrap my head around how the compiler unravels it
19:15:21 <unkanon> > add 1 2
19:15:22 <lambdabot>   Not in scope: `add'
19:15:30 <unkanon> @let add x y = x + y
19:15:31 <lambdabot>  Defined.
19:15:33 <unkanon> > add 1 2
19:15:34 <lambdabot>   3
19:15:46 <parcs> moozilla: ghc is magic
19:15:53 <unkanon> > ((+1) . add) $ 1 2
19:15:53 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
19:15:54 <lambdabot>    arising from a use of `...
19:15:56 <unkanon> doesn't work, but:
19:16:03 <unkanon> > (((+1) .) . add) $ 1 2
19:16:04 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
19:16:04 <lambdabot>    arising from a use of `...
19:16:06 <unkanon> oops
19:16:26 <moozilla> >((+1) .) . add) $ 1 2
19:16:34 <moozilla> > ((+1) .) . add) $ 1 2
19:16:35 <lambdabot>   <no location info>: parse error on input `)'
19:16:40 <Eduard_Munteanu> What would be a good intro to denotational semantics?
19:16:45 <moozilla> > (((+1) .) . add) $ 1 2
19:16:46 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
19:16:47 <lambdabot>    arising from a use of `...
19:16:57 <moozilla> > (((+1) .) . add) $ 1 2 3
19:16:58 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
19:16:58 <lambdabot>    arising from a use of `...
19:17:08 <fasta> lispy: cool, I didn't know about that one. 
19:17:13 <unkanon> > (+1) (add 1 2)
19:17:14 <lambdabot>   4
19:17:24 <unkanon> > (+1) $ add 1 2
19:17:25 <lambdabot>   4
19:17:47 <moozilla> > ((+1) . add) $ 1 2
19:17:48 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
19:17:48 <lambdabot>    arising from a use of `...
19:17:55 <unkanon> > (((+1) .) . (\x y -> x + y)) $ 1 2
19:17:56 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
19:17:56 <lambdabot>    arising from a use of `...
19:18:23 <parcs> unkanon: $ 1 2 is wrong
19:18:27 <unkanon> > (((+1) .) . (\x y -> x + y)) 1 2
19:18:29 <lambdabot>   4
19:18:31 <unkanon> yay
19:18:32 <unkanon> parcs: thanks
19:18:42 <unkanon> > (((+1) .) . add) 1 2
19:18:43 <lambdabot>   4
19:18:48 <unkanon> moozilla: there we go :)
19:19:11 <moozilla> unkanon, I think I understand it :)
19:19:26 <unkanon> it kinda gets evaluated like this:
19:19:27 <Eduard_Munteanu> @pl \x y z -> x + y + z
19:19:28 <lambdabot> ((+) .) . (+)
19:19:34 <unkanon> > (((+1) .) . add) 1 2
19:19:35 <lambdabot>   4
19:19:38 <moozilla> for three functions would it be ((f .) . g) . h
19:19:51 <unkanon> > ((+1) . (add 1)) 2
19:19:52 <lambdabot>   4
19:19:52 <moozilla> wait
19:19:58 <haskeller> what's that @pl command?
19:19:59 <unkanon> > ((+1) (add 1 2))
19:20:00 <lambdabot>   4
19:20:05 <moozilla> (((f .) . g) .) . h
19:20:05 <unkanon> moozilla: do you see it now?
19:20:17 <Eduard_Munteanu> haskeller: it turns expressions into pointfree style.
19:20:31 <Eduard_Munteanu> That is, avoids function application.
19:20:35 <haskeller> swee-et
19:20:50 <moozilla> unkanon yeah
19:21:04 <Eduard_Munteanu> Like foo = f (g x) in pointfree is foo = f . g 
19:21:15 <moozilla> it just seems like there would be another operator to unravel that
19:21:32 <Eduard_Munteanu> erm foo x = f (g x)
19:22:22 <parcs> moozilla: you can define one
19:22:44 <moozilla> is that the prefered thing to do?
19:22:59 <moozilla> I'm just trying to make my code clean and easy to follow
19:23:35 <jmcarthur> Eduard_Munteanu: you mean it avoids lambda abstraction
19:24:13 <moozilla> from a beginners perspective, it avoids paranthesis :)
19:24:19 <jmcarthur> no it doesn't
19:24:22 <haskeller> another word for function composition then
19:24:50 <jmcarthur> @pl \x y -> f $ g x y
19:24:50 <lambdabot> (f .) . g
19:24:53 <Eduard_Munteanu> jmcarthur: hm yes, actually lambda abstraction covers that better.
19:24:59 <jmcarthur> it *added* parens there, moozilla ^^
19:25:00 <parcs> @let .: = (.) . (.)
19:25:00 <lambdabot>   Parse error: VarSym ".:"
19:25:23 <Eduard_Munteanu> :t (.) (.)
19:25:24 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
19:25:42 <jmcarthur> @pl f $ g x
19:25:42 <lambdabot> f (g x)
19:25:44 <Eduard_Munteanu> :t (.) (.) (.)
19:25:44 <jmcarthur> and there
19:25:45 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
19:25:47 <haskeller> does ghc have the same functionality?
19:26:00 <jmcarthur> haskeller: there is a pointfree program on hackage that you can install
19:26:07 <jmcarthur> for the command line
19:26:21 <Eduard_Munteanu> haskeller: you can actually cabal-install the whole lambdabot
19:26:59 <unkanon> ok I still need help with my question, what's the best way to see the reductions in ghci?
19:27:34 <haskeller> more sweetness
19:27:38 <haskeller> like i said, every night i get something new from here =)
19:27:56 <jmcarthur> unkanon: well, ghci has a debugger, but it's not really the most intuitive thing to use IMO
19:28:26 <unkanon> everybody was warning against it :P
19:29:15 <ekidd> Is there a nice way to get the high and low Word32 from a Word64?
19:29:18 <unkanon> that trace function from Debug.Trace didn't help me at all
19:29:25 <Eduard_Munteanu> Let's just say it's worse than stepping through a -O2 compiled program in gdb :)
19:29:46 <Eduard_Munteanu> Debug.Trace is really nice.
19:29:49 <Eduard_Munteanu> unkanon: why?
19:29:57 <jmcarthur> unkanon: what are you trying to figure out?
19:30:06 <revenantphx> I'm noticing that regex parsing can largely be replaced by clever composition.
19:30:11 <unkanon> because I'm tryign to see the steps of a recursive function
19:30:14 <revenantphx> let sender = init . tail . (!! 0) $ words msg
19:30:15 <revenantphx>                         message = tail $ dropWhile (/= ' ') msg
19:30:15 <unkanon> and trace only prints once
19:30:16 <jmcarthur> revenantphx: or by parsec :)
19:30:27 <revenantphx> jmcarthur: thats a bit much for something this simple ;)
19:30:39 <jmcarthur> unkanon: it's only printing once because it's only being evaluated once
19:30:42 <jmcarthur> so it makes sense
19:30:46 <jmcarthur> you are getting what you asked for
19:30:56 <jmcarthur> revenantphx: not necessarily :P
19:31:12 <parcs> revenantphx: why (!! 0) instead of head?
19:31:16 <unkanon> well... I still need to see the reductions so should I try hat?
19:31:20 <revenantphx> parcs: good point >_>
19:31:23 <revenantphx> @hoogle [[a]] -> [a]
19:31:24 <lambdabot> Prelude concat :: [[a]] -> [a]
19:31:24 <lambdabot> Data.List concat :: [[a]] -> [a]
19:31:24 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
19:31:37 <Eduard_Munteanu> I think trace can exhibit weird behavior, IIRC it's unsafePerformIO under the hood.
19:32:04 <unkanon> it's type is weird to begin with
19:32:04 <jmcarthur> unkanon: *why* do you need it?
19:32:13 <unkanon> because I need something to help me debug
19:32:25 <Eduard_Munteanu> What about someone? :)
19:32:35 <jmcarthur> unkanon: if you are more specific then we can try to help you learn how to debug effectively
19:32:45 <jmcarthur> by guidance
19:32:57 <ekidd> Ah, yes. fromIntegral.
19:32:59 <unkanon> Eduard_Munteanu: I know, #haskell is very helpful and friendly but I need to do things on my own :)
19:33:11 <unkanon> jmcarthur: I can show you the function
19:33:25 <unkanon> but I really want to learn how to find the problem, instead of being given the answer
19:33:34 <jmcarthur> unkanon: okay i promise not to spoil it
19:33:57 <jmcarthur> maybe privmsg instead of talking publicly so nobody else does?
19:33:58 <revenantphx> @hoohle [[a]] -> a -> [a]
19:33:58 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
19:33:58 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
19:33:59 <lambdabot> Data.Graph.Inductive.Internal.RootPath getPath :: Node -> RTree -> Path
19:34:17 <unkanon> > let rotate n xs = trace (show n ++ " " ++ show xs) (if n>=0 then drop n xs ++ take n xs else take (-n) xs ++ drop (-n) xs) in rotate 2 "abcdef"
19:34:17 <lambdabot>   Not in scope: `trace'
19:34:18 <jmcarthur> people like to blurt answers here sometimes :)
19:34:50 <unkanon> yeah I know, but I'll try to look away if they do :)
19:35:13 <jmcarthur> > let rotate n xs = (if n>=0 then drop n xs ++ take n xs else take (-n) xs ++ drop (-n) xs) in rotate 2 "abcdef"
19:35:14 <lambdabot>   "cdefab"
19:35:19 <unkanon> > let rotate n xs = if n>=0 then drop n xs ++ take n xs else take (-n) xs ++ drop (-n) xs in rotate 2 "abcdef"
19:35:20 <lambdabot>   "cdefab"
19:35:22 <unkanon> yes, that
19:35:30 <unkanon> but!:
19:35:36 <unkanon> > let rotate n xs = if n>=0 then drop n xs ++ take n xs else take (-n) xs ++ drop (-n) xs in rotate (-2) "abcdef"
19:35:37 <lambdabot>   "abcdef"
19:35:39 <unkanon> doesn't work
19:35:47 <jmcarthur> oh you want it to rotate in either direction. i see
19:36:09 <unkanon> yes, and I (apparently naively) thought by just reversing the take with the drop and negating the n I'd get the reverse
19:36:10 <Eduard_Munteanu> Look at who you're applying n to.
19:36:28 <jmcarthur> Eduard_Munteanu: we're trying to cover debugging techniques :P
19:36:29 <revenantphx> Haskell is a bit addicting...
19:36:42 <revenantphx> more than a bit :P
19:36:48 <Eduard_Munteanu> (yes, but there's nothing to debug here :D)
19:36:49 <unkanon> see, right now the way I'd solve this is I'd simply rewrite the whole thing
19:36:51 <unkanon> not very productive
19:37:00 <revenantphx> unkanon: what's the issue?
19:37:03 <jmcarthur> sounds productive to me
19:37:17 <unkanon> revenantphx: I'm trying to make it rotate both ways
19:37:20 <jmcarthur> rewriting entire functions in haskell is not uncommon. they tend to be short enough anyway
19:37:25 <unkanon> it works for positive numbers but not negative
19:37:32 <unkanon> jmcarthur: yes I see that
19:37:37 <ekidd> @hoogle Word32 -> Float
19:37:37 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
19:37:37 <lambdabot> Prelude realToFrac :: (Real a, Fractional b) => a -> b
19:37:38 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
19:37:38 <unkanon> but it feels strange
19:37:43 <unkanon> I'd like to debug things a bit
19:37:46 <sshc> How do I make a word bold in Haddock documentation?
19:37:52 * hackagebot yesod 0.6.6 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.6.6 (MichaelSnoyman)
19:38:29 <moozilla> @pl getMCInt bs = return (fromIntegral (runGet getWord32be bs))
19:38:29 <lambdabot> getMCInt = return . fromIntegral . runGet getWord32be
19:38:49 <Eduard_Munteanu> Suppose you used arithmetic modulo length.
19:38:56 <jmcarthur> unkanon: okay, i think the best thing you could do is try to evaluate it by hand. it's more instructive than trace and more clear than the ghci debugger
19:39:14 <Eduard_Munteanu> Ok, I'll shut up.
19:39:15 <jmcarthur> unkanon: to find your problem that's pretty much what i had to do in my head
19:39:41 <jmcarthur> unkanon: it gets easier with experience, but don't be afraid to pull out the pencil and paper if you need to :)
19:40:03 <unkanon> jmcarthur: I know I really have pen and paper handy that I use for that stuff
19:40:05 <Eduard_Munteanu> That's better than poking at it IMHO  ^
19:40:19 <unkanon> what I'm saying is it'd be faster if a computer could do it for me
19:40:29 <unkanon> which in fact it can, it just won't output the reductions :/
19:40:46 <jmcarthur> i agree that it would be nice to have something that just shows all the reduction steps as a series, but it's never quite that simple
19:40:54 <jmcarthur> the reason the ghci debugger sucks:
19:41:13 <jmcarthur> it's not clear when you want to see a step or not due to lazy evaluation
19:41:21 <jmcarthur> consider the composition of two standard library functions
19:41:34 <jmcarthur> do you want to jump between their definitions, back and forth, over and over?
19:41:39 <jmcarthur> because lazy evaluation kind of does that
19:42:19 <unkanon> well, yes, but... have you looked at what hat can do?
19:42:21 <jmcarthur> i am a fan of the in-place style of showing reduction, but ghci's debugger shows you your source code more like you typed it, iirc, so i has to jump around instead :\
19:42:49 <jmcarthur> yeah, a nicer way to visualize reductions would be awesome
19:42:59 <jmcarthur> i know it's possible. this is just how ghci's debugger works :\
19:43:18 <unkanon> oh but it doesn't need to be ghci, I wouldn't mind switching back and forth between apps
19:43:29 <unkanon> I just want to see the reductions :)
19:43:31 <Eduard_Munteanu> I wonder if selectively turning the evaluation eager could be done.
19:43:37 <jmcarthur> i just don't know of anything that supports ghc's extensions for sure
19:44:08 <jmcarthur> unkanon: you could always wrap every single application in trace :\
19:44:14 <jmcarthur> but have fun with that
19:44:27 <jmcarthur> by the time you write all that you you would understand every nuance of your function anyway
19:44:27 <unkanon> jmcarthur: well that first code I pasted here was using trace
19:44:34 <jmcarthur> hmm... maybe a preprocessor could do it
19:44:37 <unkanon> but trace was only printing once, like I said before
19:44:44 <jmcarthur> unkanon: you were not using it properly i think
19:44:56 <unkanon> jmcarthur: can you show me how to use it in this function?
19:45:01 <jmcarthur> unkanon: trace simply outputs the string you give it when the expression in its second argument is evaluated
19:45:15 <unkanon> right
19:45:18 <jmcarthur> unkanon: the idea is to wrap values in trace and it will spit out some text when that value is evaluated
19:45:26 <unkanon> but somehow it works differently when the fucntion is recursive?
19:45:29 <jmcarthur> unkanon: that expression you wrapped in trace was a *single* value
19:45:32 <Eduard_Munteanu> Well that function isn't recursive or anything.
19:45:39 <fasta> unkanon wants to show evaluations like Scheme shows them, probably. 
19:45:54 <fasta> You can write something like that on top of trace, but he obviously is lazy.
19:46:02 <unkanon> Eduard_Munteanu: you're right, I'm confusing that function with another one :P
19:46:06 <fasta> Hat is broken since 2008. 
19:46:14 <fasta> Maybe Buddha does it. 
19:46:53 <jmcarthur> unkanon: you will need to wrap every value with trace that you want to observe the reduction of
19:47:21 <dolio> Buddha doesn't build anymore, either.
19:47:24 <unkanon> wow, that's too much
19:47:30 <jmcarthur> unkanon: a common pattern is trace (show a) a
19:47:41 <jmcarthur> so that you can see the value of each reduction
19:47:47 <jmcarthur> when it makes sense at least
19:48:25 <unkanon> i'll try lacing my one-liners with trace
19:48:33 <unkanon> but i'll also check out if hat can be easily installed
19:48:38 <jmcarthur> man, some TH to scatter trace around a function for you would be neat
19:49:12 <jmcarthur> don't know what text it should show though...
19:49:21 <unkanon> unfortunately TH is way beyong my reach at
19:49:22 <unkanon> m
19:49:32 <jmcarthur> yeah that's not a suggestion by any means
19:50:03 <Eduard_Munteanu> TH is scary, or at least the documentation.
19:50:07 <jmcarthur> unkanon: honestly, you'd save a ton of time by just evaluating by hand ;)
19:50:16 <unkanon> can you show me a bit on how to use ghci's debugger?
19:50:20 <jmcarthur> Eduard_Munteanu: it's not that bad once you've done it once or twice
19:50:26 <unkanon> jmcarthur: I know I can solve it by hand :)
19:50:35 <unkanon> I just want to take this opportunity to learn to debug
19:50:46 <jmcarthur> unkanon: eep. i've used it maybe twice and that just out of curiosity. i wouldn't recommend it, and i couldn't help you with it if you decided to jump in anyway :\
19:51:11 <jmcarthur> trace is a far more clear debugging tool, IMO
19:51:21 <fasta> I wonder for how much money someone would want to maintain a tool like Hat. 
19:51:29 <Eduard_Munteanu> You basically :break on the function and then :print around (IIRC)
19:51:33 <jmcarthur> fasta: i would maintain it for money! :D
19:51:38 <moozilla> @unpl getMCString = (return .) . runGet . getLazyByteString . fromIntegral
19:51:39 <lambdabot> getMCString d m = return (runGet (getLazyByteString (fromIntegral d)) m)
19:51:40 <fasta> jmcarthur: how much? 
19:51:56 <jmcarthur> i have no idea. i'd have to see how crazy/boring it is
19:52:09 <unkanon> jmcarthur: no problem then, I appreciate the help :)
19:52:15 <fasta> Just to get rid of the whining would already have some value. 
19:52:36 <overscore> http://learnyouahaskell.com <--- loving this so far
19:52:47 <jmcarthur> i have no idea how much work it would be at this moment
19:52:55 <Eduard_Munteanu> unkanon: it shouldn't be that difficult to get started if you have experience with other debuggers, say GDB. Just see the help.
19:53:02 <fasta> jmcarthur: I think I could probably get it to work within less than a day. 
19:53:10 <Eduard_Munteanu> As for extracting meaningful information, that's tougher.
19:53:25 <fasta> jmcarthur: I think a system or micropayments would solve a lot of things.
19:53:31 <fasta> of*
19:54:30 <fasta> (such systems already exist and they work today, there are just not that much people aware of them)
19:54:40 <joe6> what is this operator " &= "
19:54:46 <jmcarthur> how well does it work considering the lack of awareness?
19:54:52 <FauxFaux> :t (&=)
19:54:53 <lambdabot> Not in scope: `&='
19:54:59 <fasta> jmcarthur: technically it works perfect. 
19:55:08 <Eduard_Munteanu> @hoogle (&=)
19:55:09 <lambdabot> No results found
19:55:25 <overscore> joe6, well, in C that's x = x & y
19:55:32 <lispy> fasta: darcs accepts donations, but other than funding hacking sprints (excellent productivity) the money doesn't increase productivity really
19:55:40 <BMeph> So, is anyone mildly interested in maintaining 'oeis'?
19:55:55 * Eduard_Munteanu wishes Google allowed searches by such stuff.
19:56:01 <lispy> BMeph: yeah, I know someone who told Brent they want to do it
19:56:03 <fasta> jmcarthur: visit bitcoinme.com for more information. 
19:56:36 <fasta> jmcarthur: they are like Linden dollars, except controlled by amount of computing power you have and in very limited supply. 
19:56:54 <BMeph> lispy: Ooh, nice! I'm still at the level of trying to figure out how to add new sequences to the new site. :\
19:57:26 <fasta> jmcarthur: people are willing to accept Bitcoins for US dollars and euros already. 
19:57:52 <fasta> jmcarthur: there is a store in a New York where you can buy a pizza with them. 
19:58:02 <fasta> -a
19:58:24 <fasta> jmcarthur: you can buy webhosting, some consultancy services, etc. 
19:58:28 <Eduard_Munteanu> fasta: what is it backed by?
19:58:50 <fasta> Eduard_Munteanu: it is backed by the initial costs to "mine" them. 
19:58:58 <unkanon> fasta: that's very cool, thanks for the link
19:59:13 <fasta> Eduard_Munteanu: it currently costs more to find them, then to just buy them. 
19:59:16 <moozilla> @pl hSendChat h str = write h $ runPut $ sendChat str
19:59:17 <lambdabot> hSendChat = (. (runPut . sendChat)) . write
19:59:26 <unkanon> I think I thought of that idea before (if I understand it correctly)
19:59:28 <fasta> Eduard_Munteanu: unless you use them to heat your house. 
19:59:34 <jmcarthur> fasta: i note that something *not* listed as a bullet point is value stability
19:59:35 <Eduard_Munteanu> fasta: how do I withdraw them?
19:59:50 <fasta> Eduard_Munteanu: you mean turn them back in dollars?
20:00:00 <fasta> Eduard_Munteanu: you find someone who wants bitcoins. 
20:00:01 <Eduard_Munteanu> fasta: no, possess the thing that's backing it.
20:00:13 <fasta> Eduard_Munteanu: ?
20:00:35 <joe6> language = "haskell" &= text "The language used for syntax highlighting" & typ "LANGUAGE"
20:00:35 <Eduard_Munteanu> I'm trying to determine whether it's fiat or not :)
20:00:39 <fasta> Eduard_Munteanu: US dollars are also worth nothing anymore. 
20:00:40 <joe6> > language = "haskell" &= text "The language used for syntax highlighting" & typ "LANGUAGE"
20:00:41 <lambdabot>   <no location info>: parse error on input `='
20:01:01 <fasta> Eduard_Munteanu: it is backed by nothing except for computational hardness. 
20:01:01 <Eduard_Munteanu> fasta: that I know.
20:01:04 <joe6> i am trying to understand this piece of haskell code. can you please help?
20:01:10 <joe6> > language = "haskell" &= text "The language used for syntax highlighting" & typ "LANGUAGE"
20:01:10 <lambdabot>   <no location info>: parse error on input `='
20:01:24 <fasta> Eduard_Munteanu: if you can crack sha256, then you can become a millionaire. 
20:01:26 <kmc> that's using the "cmdargs" library joe6
20:01:30 <kmc> you can look it up on hackage
20:01:33 * Eduard_Munteanu , on this note, recommends a look at http://pecunix.com/
20:01:36 <joe6> kmc: thanks.
20:01:44 <fasta> Eduard_Munteanu: those are not distributed.
20:01:59 <fasta> Bitcoin is unique in that without shutting down the Internet you cannot control it.
20:02:10 <kmc> joe6, that library has a lot of magical tricks.  it will be easy to understand its API but hard to understand the whole implementation
20:02:50 <Eduard_Munteanu> fasta: I'm not sure how it works. Is it fiat as in it can be "printed" in limitless quantities?
20:03:08 <fasta> Eduard_Munteanu: no, there is a maximum of 21 million coins. 
20:03:19 <fasta> Eduard_Munteanu: currently there are about 4 million, IIRC.
20:03:22 <Eduard_Munteanu> fasta: controlled / set by whom?
20:03:28 <fasta> Eduard_Munteanu: distributed.
20:03:41 <fasta> Eduard_Munteanu: i.e. nobody.
20:04:19 <fasta> Where normal money is controlled by bankers, this money is controlled by the users. 
20:04:25 <Eduard_Munteanu> Hm. How do I actually check the coins aren't fake?
20:04:34 <fasta> Eduard_Munteanu: the software does that. 
20:04:38 <fasta> Eduard_Munteanu: open-source, etc.
20:04:40 <Eduard_Munteanu> How? :)
20:04:50 <Eduard_Munteanu> I really need to look more in-depth.
20:05:01 <fasta> Eduard_Munteanu: you understand how the protocol works and then you could write your own client.
20:05:21 <fasta> Eduard_Munteanu: the protocol is not documented in a lot of detail, but in enough detail that an interested party can compare it to the source code.
20:05:31 <Eduard_Munteanu> My point is, if I invest in such stuff, I don't invest in fiat currencies.
20:05:45 <Eduard_Munteanu> There are enough of them already.
20:05:48 <jmcarthur> you do that every time you work for money
20:06:07 <jmcarthur> if you see your work as investing in a currency, that is
20:06:10 <fasta> Eduard_Munteanu: it costs more to find bitcoins than to buy them. 
20:06:27 <Eduard_Munteanu> jmcarthur: it matters what you put under your mattress, not what you get paid in. ;)
20:06:28 <fasta> Eduard_Munteanu: it's like gold in that sense.
20:06:50 <Eduard_Munteanu> fasta: oh, how do you "find" them?
20:06:52 <fasta> Eduard_Munteanu: so, you have gold under your mattress?
20:07:00 <fasta> Eduard_Munteanu: you solve a computationally hard problem. 
20:07:05 <Eduard_Munteanu> Well not literally a mattress.
20:07:23 <fasta> Eduard_Munteanu: finding certain sha256 hashes in the problem.
20:07:33 <fasta> Eduard_Munteanu: is*
20:07:40 <unkanon> why would there be a limit to how many coins there can be?
20:07:49 <jmcarthur> number of bits, i imagine?
20:07:51 <fasta> unkanon: because that's part of the protocol.
20:07:53 <Eduard_Munteanu> Hm, so the coins are determined by the SHA256 mappings?
20:08:41 <Eduard_Munteanu> That makes sense, but where's the scarcity once discovered?
20:08:45 <fasta> Eduard_Munteanu: no, you shout to the network "look, I found some gold", then the rest accepts that you found it. 
20:09:06 <fasta> Eduard_Munteanu: that's the idea. I am not going to describe in detail how it works. 
20:09:17 <fasta> But you can find out that yourself. 
20:09:26 * Eduard_Munteanu is a bit skeptical.
20:09:40 <kmc> it is fiat currency yes?
20:09:59 <kmc> in that there's no "intrinsic value"
20:10:08 <tg_> kmc: is there any other kind these days?
20:10:08 <fasta> kmc: creating the money is currently more expensive than buying them. 
20:10:10 <kmc> though one can say the same for gold -- why do we care that it's shiny, really?
20:10:19 <tg_> all currency is fiat or arbitrary
20:10:23 <Eduard_Munteanu> It probably isn't fiat in that sense, but I see no scarcity. It's only protected by other acknowledging it.
20:10:37 <fasta> kmc: you cannot just say "create 10000 bitcoins" and have them appear in your account. 
20:10:43 <kmc> right
20:10:43 <tg_> the only currency would be something like the summation of all stored elements or
20:10:46 <kmc> but i can't do that with USD either
20:10:49 <kmc> yet USD are fiat currency
20:10:56 <fasta> kmc: no, but the banks can. 
20:11:11 <tg_> with the USD, the Federal Reserve can, and any fractional reserve lender along the way can
20:11:13 <kmc> i think we're talking at cross purposes
20:11:13 <fasta> kmc: or at least the FED in combination with the government can. 
20:11:14 <Eduard_Munteanu> If you "mine" such coins, it'd be in the other's best interest not to acknowledge them.
20:11:29 <kmc> i do not mean to confuse the idea of "intrinsic value" with the idea of who controls printing, or the idea of scarcity
20:11:34 <kmc> i think these are all separate issues
20:11:37 <Eduard_Munteanu> Erm wait, no.
20:11:44 <tg_> fasta: it's questionable if the FED needs the USG to make money these days
20:11:45 <unkanon> one one to have this bitcoin thing work would be if you were selling your computer's processing time for money
20:11:50 <unkanon> much like SETI@home and such
20:11:52 <Eduard_Munteanu> It would actually be.
20:11:54 <unkanon> if they would pay you
20:11:55 <fasta> kmc: ok, they have no intrinsic value. 
20:12:01 <unkanon> then now you have a resource that is indeed scarce
20:12:05 <unkanon> so you have real value
20:12:15 <Eduard_Munteanu> They don't have to have intrinsic value.
20:12:18 <Eduard_Munteanu> There's no such thing.
20:12:22 <Eduard_Munteanu> They only need to be scarce.
20:12:43 <fasta> Gold has intrinsic value, because you can use it for electronics, for example.
20:12:47 <kmc> meh
20:12:48 <kmc> energy is intrinsic value
20:12:54 <kmc> gold is iffy
20:13:03 <unkanon> fasta: the real value of gold doesn't come from its usefulness
20:13:09 <kmc> if you really want to store wealth, pump a lot of water to the top of a hill.
20:13:16 <unkanon> it only comes from its scarcity
20:13:27 <kmc> unkanon, there are loads of scarce useless objects
20:13:35 <fasta> unkanon: I don't agree. 
20:13:39 <Eduard_Munteanu> Well that's a point to, but its market value isn't directly determined by that.
20:13:40 <unkanon> kmc: yes
20:13:52 <kmc> scarce and worthless too
20:14:09 <unkanon> Eduard_Munteanu: exactly what I said, but he doesn;t agree :)
20:14:18 <kmc> also is this conversation about Haskell somehow?
20:14:30 <fasta> kmc: it was about micropayments.
20:14:39 <Eduard_Munteanu> I hear the main channel is on #haskell-blah now :P
20:14:40 <unkanon> we can take it to -blah
20:15:37 <sauf> hi 
20:16:15 <Eduard_Munteanu> sauf: hi
20:16:33 <sauf> can you help me write an instance of Arbitrary
20:16:42 <sauf> for Rationals ?
20:16:59 <fasta> sauf: homework?
20:17:16 <sauf> personal work
20:17:41 <sauf> i need positive rationals
20:18:08 <sauf> for example numerators between 1 and 100
20:18:25 <sauf> and same for denoms
20:20:01 <Saizan> QuickCheck2?
20:20:45 <sauf> isn't Test.QuickCheck QuickCheck2 ?
20:21:10 <Saizan> arbitrary = do n <- choose (1,100); d <- choose (1,100); return (n % d)
20:22:07 <Saizan> both -2 and -1 have a Text.QuickCheck module, anyhow i think the code in my previous line works for both
20:23:02 <sauf> Saizan: thanks
20:24:15 <sauf> can you tell me if it could work for Ratio a instead of Rational ?
20:24:56 <Saizan> it'd work for Ration a when a is an instance of Random
20:25:33 <sauf> how could I instanciate Ratio a for Random ?
20:25:48 <Saizan> you could also substitute  choose (1,100) with elements [1..100] if a is only an instance of Enum
20:25:59 <Saizan> that's not what you'd need to do
20:26:31 <Saizan> e.g. if you want to use that code for "Ratio Foo" then you need an instance Random Foo where ..
20:27:53 <sauf> ok I'll try, thanks
20:30:45 <sauf> great it works ! bye !
20:46:39 <danblick> log handler
20:46:42 <danblick> oops, sorry
21:01:20 <sohum> @hoogle a -> (Int,Int) -> b
21:01:21 <lambdabot> Text.Regex.Base.RegexLike extract :: Extract source => (Int, Int) -> source -> source
21:01:21 <lambdabot> Data.Ix inRange :: Ix a => (a, a) -> a -> Bool
21:01:21 <lambdabot> Data.Ix index :: Ix a => (a, a) -> a -> Int
21:02:54 <sohum> (Ix a, Ix b) => Ix (a, b) interesting...
21:05:56 <sshc> If a function returns a tuple containing the main data and a Enum type that describes the format of that data, which should be first?
21:12:14 <mtnviewmark> (Enum, Data)
21:12:25 <mtnviewmark> since the Data's interpretation is dependent upon the Enum
21:13:10 <mtnviewmark> but makes me wonder why you don't just a data type then (the constructors play the part of the Enum)
21:13:31 <mtnviewmark> though I suppose you might have a domain where the Data will be treated mostly identically
21:18:41 <sohum> @hoogle [m a] -> m [a]
21:18:41 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
21:18:42 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
21:18:42 <lambdabot> Language.Haskell.TH.Syntax sequenceQ :: [Q a] -> Q [a]
21:18:54 <sohum> I love hoogle so much
21:20:59 <mtnviewmark> heh
21:21:09 <mtnviewmark> and, if you don't need the resulting array
21:21:13 <mtnviewmark> :t sequence_
21:21:14 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
21:21:18 <mtnviewmark> er, resulting list
21:21:29 <unkanon> me too, that's why I added it to my ghci
21:21:47 <unkanon> too bad I can't do | less from within ghci, sometimes hoogle's output is too much
21:24:14 <sohum> @pl \x y -> ptc b x y r n
21:24:15 <lambdabot> flip flip n . flip flip r . ptc b
21:24:32 * sohum blinks
21:25:51 <sohum> well, never mind. I can rewrite ptc to have x and y as its last arguments
21:27:07 <joe6> i am searching for a tutorial to use haskell to submit web forms. any suggestions, please?
21:29:17 <gienah> http://docs.yesodweb.com/book/forms/
21:29:17 <lambdabot> gienah: You have 2 new messages. '/msg lambdabot @messages' to read them.
21:30:30 <mtnviewmark> joe6 - submit them as a http client -- or process submitted forms as an http server?
21:30:46 <joe6> as a http client
21:31:21 <gienah> http://happstack.com/docs/crashcourse/RqData.html#rqdatapost
21:31:44 <mtnviewmark> @hackage HTTP
21:31:44 <lambdabot> http://hackage.haskell.org/package/HTTP
21:32:21 <joe6> thanks guys
21:55:17 <mtnviewmark> gosh, it's so quiet in here you'd think it was Saturday night or something....
21:55:20 <mtnviewmark> ... d'oh!
22:01:07 * edwardk waves hello.
22:01:21 <edwardk> preflex: xseen ddarius
22:01:36 <edwardk> hrmm no preflex?
22:01:41 <edwardk> lambdabot: seen ddarius
22:01:53 <mtnviewmark> @seen ddarius
22:01:54 <lambdabot> Unknown command, try @list
22:01:57 <mtnviewmark> @list
22:01:57 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
22:02:07 <mtnviewmark> @last ddarius
22:02:08 <lambdabot> No module "ddarius" loaded
22:02:21 <edwardk> iirc seen was dumped off of lambdabot because of state bugs
22:02:48 <mtnviewmark> funny, @seen is listed as a command
22:03:31 <edwardk> trying to encode some crazy category theory over in scala and wanted another set of eyes
22:04:16 <edwardk> i did get it to encode a bunch of things i can't say nicely in haskell like product categories, etc.
22:04:32 <Jafet> Let's highlight ddarius again so he gets the picture anyway
22:05:13 <edwardk> i wonder if he'll appear if we chant his name over and over, like kowey does over in darcs
22:08:02 <edwardk> otoh, i wind up faced with something i almost never encounter over here, compiler bugs all over the place
22:17:29 <copumpkin> :o
22:20:12 <pygmalion> so i'm trying to write my first full scale project (a command line todo list app) and i'm already in trouble with my datatype declerations. i have a type ToDo (which is compiling fine) and I want "data ToDoList = [ToDo]" but that's throwing any error. what gives?
22:20:51 <mtnviewmark> well... what is your definition of ToDo?
22:20:54 <danblick> pygmalion: in this case, your type "ToDoList" needs a constructor
22:21:11 <mtnviewmark> d'oh - "data", not "type" there...
22:21:26 <mtnviewmark> (funny how you read what you want to see)
22:21:44 <danblick> pygmalion, there are a few different ways to declare types, "data", "newtype", and "type" -- try     withForeignPtr z c_warray1
22:21:46 <danblick> oops
22:21:50 <danblick> try http://www.haskell.org/haskellwiki/Type
22:22:15 <pygmalion> thanks danblick. that was way more obvious than i expected. i didn't forget the constructor for my ToDo type... silly mistake
22:22:59 <danblick> np
22:30:19 <edwardk> heya copumpkin, i hope you aren't at the office =)
22:30:26 <copumpkin> I was actually thinking of going in
22:30:31 <edwardk> hah
22:30:31 <copumpkin> got rather hooked on implementing pattern matching
22:30:36 <copumpkin> friday night
22:30:37 <edwardk> sweet!
22:30:50 <copumpkin> but spent most of today doing less interesting things
22:31:19 <copumpkin> :)
22:31:21 <edwardk> i got stuck with magpie's generalized bifunctors, i think i need to do something bizarre like represent hom-sets in the form of dinaturals in order to get subtyping to work out right, and i just had to put it down
22:31:36 <copumpkin> aw
22:31:47 <edwardk> otoh, amusingly, equality now subtypes subtyping ;)
22:32:00 <copumpkin> :O
22:32:06 <copumpkin> oh
22:32:12 <edwardk> which means that the liskov and leibniz code now share refl, etc.
22:32:15 <copumpkin> nice
22:32:22 <copumpkin> I guess that makes sense
22:32:30 <edwardk> and you can let it degrade from one to the other, etc.
22:33:44 <copumpkin> yeah
22:34:12 <edwardk> i think i'm going to need to reimplement the functor side of things though, right now functors only know (at the type level) about the homsets of their categories and i think i need to instead let them know the full type of their categories, otherwise when i go to deal with  monoidal functors, etc i'll be swimming in subtypes of functors, when for the most part i only care about the subtyping on the categories
22:36:28 <edwardk> i also think i'm going to need to break up the dual-foo implementation machinery into one that provides the types and one that provides the plumbing, that will ease the amount of disambiguation in each point lower on the lattice than two or more parents
22:37:02 <edwardk> monoid subtyping unital semigroup and category for instance has to do a lot of disambiguation on how to resolve its dual and its product
22:37:15 <copumpkin> yeah
22:37:29 <edwardk> but you can take the product of a category and a group and get a category, etc.
22:37:34 <edwardk> so that much is working nicely
22:38:02 <copumpkin> cool
22:38:48 <edwardk> the biggest problem is this bifunctor mess =/
22:39:13 <edwardk> apprently the products don't provide enough variance information for subtyping to be happy when you actually go use them for something complicated
22:39:55 <edwardk> hence why i was thinking i may need to re-express them by claiming they are both positively and negatively variant in the same argument and doing some dinatural transformation stuff, so i only wind up talking about arguments that are on the diagonal anyways
22:40:35 <edwardk> otherwise i'm going to be spending a lot of time hacking the type system to do what i mean
22:40:49 <edwardk> er. sorry for all the non-haskelly talk
22:41:35 <edwardk> what i'm thinking about as a possible re-encoding of all the hom-set machinery is something like http://www.ioc.ee/~tarmo/tday-voore/vene-slides.pdf
22:42:00 <edwardk> particularly the bits about parametricity and strong duality
22:42:03 <edwardk> er
22:42:05 <edwardk> strong dinaturality
22:57:58 <Philippa_> edwardk: have you met Visibly Pushdown Languages, other than from my recent tweet?
23:00:55 <edwardk> Philippa_: i'll confess i haven't actually even read the tweet ;)
23:03:36 <dskippy> I am running code that I believe I have copied properly from Google Code search on using events in GTK. I am getting the error "No instance for (Control.Monad.IO.Class.MonadIO (mtl-1.1.0.2:Control.Monad.Reader.ReaderT (GHC.Ptr.Ptr Graphics.UI.Gtk.Gdk.EventM.EExpose) IO))" from my usage of liftIO that I copied from code search.
23:04:22 <dskippy> I have the code on paste bin of anyone would like to have a look and see if I'm doing anything obviously incorrect.: http://hpaste.org/42079/mainguihs  http://hpaste.org/42080/uiglade
23:05:29 <Saizan> dskippy: when ghc shows the package name in the type like that it means that's the reason you're getting the error
23:05:55 <Saizan> i.e. you might be using ReaderT from mtl-1.1.0.2 and the MonadIO class from some other package
23:05:59 <dskippy> It means what is the reason?
23:06:42 <Saizan> so there's probably a ReaderT from that other package that has an instance for the corresponding MonadIO class
23:06:57 <Saizan> but ReaderT from mtl-1.1.0.2 doesn't
23:08:05 <dskippy> Oh? There's not really even a value in my program that's supposed to have that value though. I want to ignore ReaderT and lift into the IO monad to do IO stuff.
23:08:39 <Saizan> that type you mean?
23:08:43 <dskippy> If you see the second to last line "putStrLn ...". If I comment that out, the program compiles just fine. 
23:09:30 <c_wraith> :t liftIO
23:09:31 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
23:09:40 <c_wraith> dskippy, is that what you want?
23:09:57 <Saizan> he has liftIO there
23:10:00 <c_wraith> oh.
23:10:20 <dskippy> Yeah. Just doesn't seem to be doing anything, sadly.
23:10:41 <c_wraith> what's the type of connectGUI?
23:10:42 <Saizan> dskippy: what's the type of "on (board gui) exposeEvent" ?
23:10:59 <c_wraith> just as a style thing, it's often worth annotating the type of top-level declarations
23:11:41 <c_wraith> oh, it must be IO something
23:11:49 <c_wraith> in which case, liftIO does nothing, yes
23:12:30 <Saizan> liftIO is used to build the "callback" to pass to on (board gui) exposeEvent
23:12:35 <c_wraith> ok, what's the type of "on" there?
23:12:40 <dskippy> Saizan: on :: object -> Signal object callback -> callback -> IO (ConnectedId object)
23:12:58 <Saizan> dskippy: and the type of exposeEvent ?
23:13:02 <dskippy> (board gui) :: DrawingArea
23:13:39 <c_wraith> yeah, the type of exposeEvent is what's critical here, then
23:13:49 <dskippy> exposeEvent :: (WidgetClass self) => Signal self (Graphics.UI.Gtk.Gdk.EventM.EventM Graphics.UI.Gtk.Gdk.EventM.EExpose Bool)
23:14:30 <Saizan> EventM might be a type synonym unfornately
23:15:29 <Saizan> here it is: type EventM t a = ReaderT (Ptr t) IO a
23:16:03 <Saizan> that's where the MonadIO (ReaderT ...) requirement comes from.
23:16:16 <dskippy> I see.
23:17:43 <dskippy> So why won't liftIO work to get out of the ReaderT?
23:17:58 <Saizan> because it's the liftIO from another package
23:18:49 <rupert88> can anyone here tell me why hugs behaves different to other programs in terms of console output?
23:19:06 <dskippy> Saizan: There's more than one liftIO?
23:19:46 <Saizan> dskippy: you probably have the "transformers" package installed, and ghc is picking Control.Monad.Trans from there rather than from mtl
23:19:52 <Saizan> dskippy: yes
23:20:08 <Saizan> dskippy: solution: -hide-package transformers
23:20:11 <newb1y> I'm new. I'm trying to figure out haskell with Emacs. Is there an emacs haskell-mode function to single step? i.e. Step through your code, passing each line in turn to ghci, or a similar method to acheive the same "single-step through" effect?
23:20:25 <dskippy> Saizan: It's definitely getting from Trans. I imported Trans specifically for that. That's the only liftIO I knew of.
23:20:32 <Saizan> dskippy: longer term: ghc-pkg hide transformers (you'll have to restart ghci for this to make effect)
23:20:53 <Saizan> dskippy: no, Control.Monad.Trans and "transformers" are two different things.
23:21:05 <dskippy> Oh gees. I'm confused. :)
23:21:13 <djahandarie> Both transformers and mtl provide Control.Monad.Trans
23:21:22 <djahandarie> You're getting the one from transformers while you want the one from mtl
23:21:26 <Saizan> dskippy: Control.Monad.Trans is a module, transformers and mtl are packages, which both expose a module with that name
23:21:30 <dskippy> Ooooh
23:21:44 <dskippy> That's really confusing.
23:22:11 <djahandarie> Don't know about confusing, but it is sort of dumb how modules are laid out. At least that's what some people think.
23:22:58 <dskippy> liftIO :: (transformers-0.2.2.0:Control.Monad.IO.Class.MonadIO m) => IO a -> m a
23:23:12 <dskippy> That's the type after I did ghc hide transformers.
23:23:19 <dskippy> Looks like it's still stuck on transformers.
23:23:26 <djahandarie> ghc-pkg hide transformers
23:23:33 <djahandarie> And if you are using cabal it might be using it explicitly
23:23:35 <dskippy> I did that.
23:23:46 <djahandarie> How are you compiling?
23:23:54 <dskippy> Just ran ghci, actually.
23:24:23 <djahandarie> Try doing ghci -hide-package transformers 
23:25:04 <dskippy> liftIO :: (MonadIO m) => IO a -> m a
23:25:04 <djahandarie> It's possible the code is using an extension that lets you specify the package explicitly... but it'd be pretty obvious if it was
23:25:06 <dskippy> Better.
23:25:20 <copumpkin> tail with foldr
23:25:28 <copumpkin> how would you write it?
23:25:32 <djahandarie> ghc-pkg hide should have done that
23:25:37 <dskippy> Yeah I posted my code to pastebin. I wrote it, so it's not explicitly asking for transformers.
23:26:17 <dskippy> So am I supposed to just compile this program with -hide transformers always?
23:26:37 <djahandarie> dskippy, what you're "supposed" to do is use cabal and explicitly state which packages your project uses
23:26:41 <dskippy> How would one have access to both liftIOs in the same program if they needed it?
23:27:11 <dskippy> djahandarie: I can do that. 
23:27:25 <copumpkin> is there a way to write tail using foldr and nothing outside of foldr?
23:27:50 <copumpkin> meaning not tail = f . foldr ? ?
23:27:54 <copumpkin> but tail = foldr ? ?
23:28:25 <djahandarie> copumpkin, should be able to...
23:28:39 <copumpkin> let's see it!
23:29:14 <Saizan> copumpkin: not even if f = fst ?
23:29:40 <copumpkin> it feels like cheating :P but I guess with that it's not that hard
23:31:08 <edwardk> clearly you just need to use one of the generalized catamorphisms instead to rid you of the burden of stripping off the extra structure ;)
23:31:52 <djahandarie> Yeah, nevermind, I thought I would do something funny with undefined but I couldn't
23:32:01 <copumpkin> init and tail are fairly easy
23:32:10 <copumpkin> I mean last
23:32:23 <copumpkin> well, safeInit and safeTail :P
23:32:30 <edwardk> hah
23:32:52 <copumpkin> so, safeHead, safeInit, and safeTail are all easy
23:33:06 <copumpkin> gah
23:33:08 <copumpkin> safeLast
23:33:08 <edwardk> sure, but tail needs to do something different at the last node
23:33:12 <copumpkin> it's safeTail that is tough
23:33:56 <Saizan> try the predecessor of a natural number first :)
23:34:10 <copumpkin> Saizan: I was being lazy cause it's basically the same question :P
23:34:17 <mauke> preflex: version
23:34:17 <preflex>  5.172
23:34:26 <copumpkin> and I already had a foldr on list in the prelude :p
23:34:37 <fasta> Saizan: what comes before zero?
23:34:43 <copumpkin> zero
23:34:43 <Saizan> fasta: zero
23:35:11 <fasta> That's what everyone does, but it's not actually an axiom.
23:35:19 <copumpkin> fasta: it is if you say it is
23:35:20 <copumpkin> :P
23:35:21 <Saizan> well, in the end it boils down to encoding the para from the cata and throwing away some of it
23:35:58 <fasta> copumpkin: right, I asked it as a rhetorical question. 
23:36:01 <Saizan> for church numerals it looks weird because you church encode the pairs involved in the construction
23:41:41 <wagle> nice..  gratuitous url changes on haskell.org..  all my bookmarks!  argh!  8/
23:43:12 <Saizan> all your bookmarks are belong to the haskell.org committee
