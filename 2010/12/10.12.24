00:00:40 <aindl> Hi. Have somebody experience with installation hmatrix on FreeBSD?
00:03:30 * hackagebot hjson-query 1.0.1 - library for querying from JSON  http://hackage.haskell.org/package/hjson-query-1.0.1 (YuriyIskra)
00:35:38 * hackagebot digestive-functors-snap 0.0.2.1 - Snap backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-snap-0.0.2.1 (JasperVanDerJeugt)
01:38:13 <Wooga> hello, if anyone interested, here is haskell layout plugin for gedit text editor:  ftp://neverb.net/soft/mine/gedit_haskell_mode/haskell_indentation.tar.gz
02:13:30 <Zvpun> Hi, I want a function digit :: a -> Int -> Int, where a can either be Int or Integer. What would you recommend? Is "digit :: Integral a => a->Int->Int" fine?
02:14:38 <Saizan> if you only needs things (derivable) from the Integral class it is
02:14:45 <shachaf> Zvpun: If that's the type that you mean, then yes.
02:16:58 <Zvpun> I found instance Integral Int and instance Integral Integer, is there a way to make sure that there is no other instance of Integral, or is that irrelevant? (digit should take x and n and return the n-th digit of x, so I thought, x should be an int or integer if it gets large)
02:17:49 <Jafet> Why don't you want it to be anything else?
02:18:22 <Zvpun> because I will only apply it to numbers of the form 2^n and dont need it for floats.
02:18:39 <Jafet> What if I want to use it with my own Integral type?
02:19:08 <Auxentiu97> where can I get started using haskell?
02:19:25 <Zvpun> Since I don't have experience and I gave this problem to me to learn some haskell I cannot answer these questions and asked you for best practice
02:19:33 <pacak> Auxentiu97: learnyouahaskell.com
02:19:57 <Auxentiu97> thanks
02:20:16 <Jafet> Note that in haskell, you must propagate all constraints. So if digit had a magical (IntOrInteger a) constraint, then all the users of digit would need to have a similar constraint, or be specialized to Int or Integer
02:24:18 <Zvpun> http://hpaste.org/42529/digit New question: What is a best practices to enforce my constraint of n >= 1?
02:24:55 <Jafet> if n < 1 then error "DIE PROGRAM DIE" else ...
02:25:44 <Jafet> There are special positive-integer types on hackage, but haskell isn't really that sort of language
02:26:38 <Jafet> By the way, you'd better check the type of (/), because that's probably not what you want.
02:26:49 <Zao> @type div
02:26:49 <lambdabot> forall a. (Integral a) => a -> a -> a
02:29:40 <Zvpun> ah nice, if only I have had learned earlier about div, would have saved me the hassle of error messages regarding /, ty very much Sir.
02:36:41 <Zvpun> http://hpaste.org/paste/42529/digit_annotation#p42530 Unfortunatly it seems x and n have to be of same type, but x could be large whereas n will always be small.
02:37:53 <Jafet> :t fromIntegral
02:37:53 <lambdabot> forall a b. (Integral a, Num b) => a -> b
02:38:12 <Jafet> And here's for you a crash course in type unification
02:38:26 <Jafet> :t fromIntegral :: (Integral a => a -> Int)
02:38:27 <lambdabot> forall a. (Integral a) => a -> Int
02:42:10 <Zvpun> http://hpaste.org/paste/42529/digit_annotation#p42531 Please judge.
02:44:06 <Zvpun> http://hpaste.org/paste/42529/digit_annotation#p42532 Actually I think this is better since x `div` 10^n' meight still be large but `mod` 10 is definitly small.
02:46:29 <Jafet> That looks fine, as long as you don't try to extract the ceiling (log_10 (fromIntegral maxBound) + 1)-th digit of an Int or anything
02:47:10 <phr_> http://hpaste.org/42533/digit_annotation
02:48:12 <Jafet> That looks like something completely different
02:48:20 <phr_> hm
02:49:23 <phr_> i couldn't figure out what the original one was doing
02:49:45 <Zvpun> get the n-th digit of a positiv integer.
02:49:52 <Zenon1> http://pastebin.com/5ik89D7a I'm currently writing some code dealing with poker cards and made this card class for it. But I'm having trouble making the card class an instance of ord. I tried http://pastebin.com/1H58kZk4 and http://pastebin.com/6xfH1RP6, both of which compile just fine, but if I use sortBy Poker.compare [cards], i get a stack overflow error, so obviously I'm doing it wrong. Also, why do I have to qualify the operators with M
02:49:53 <Zenon1> odule.operator? in the examples in lyah i've never seen them qualified and they worked just so. 
02:50:23 <Jafet> Get the n-th digit of an Integral t, assuming 10^n is a valid value in t, and dying horribly for non-positive inputs
02:51:28 <Zenon1> though there's no example of manually instantiating ord in lyah. (and i can't automatically derive it because I don't want to have Suit in Ord)
02:53:01 <Jafet> You shouldn't have to qualify the operator
02:58:39 <Zenon1> or could it be because i use record syntax?, so  instead of something like (Card x _) `compare` (Card y _) = x `compare` y i would have to do x `compare` y = (value x) `compare` (value y) ?
03:00:59 <Kaidelong> Zenon1: show us where the stack overflow occurs, hard to help with this context
03:04:13 <Kaidelong> also don't suites actually have an ordering as well in poker?
03:04:18 <Kaidelong> suits
03:04:37 <Zenon1> well, yes and no
03:04:44 <Zenon1> card suits have an ordering per se
03:04:56 <Zenon1> but depending on your poker variant, it doesn't count
03:05:24 <Zvpun> Jafet: http://hpaste.org/paste/42529/digit_annotation#p42535 I check that x is positiv. In case x is Int and 10^(n-1) is to large for and Int I added fromIntegral x to transform it into an Integer. Is there anything else wrong?
03:05:27 <Zenon1> i.e. if two opponents have a hand with Ace high, the second card would determine the winner instead of the suit of an ace
03:05:29 <Jafet> Good luck ordering Value in blackjack, too
03:06:12 <Zenon1> it used to occur when I did 'sortBy Poker.compare [(Card V2 C), (Card V3 C), (Card V4 C), (Card V5 C), (Card V6 C)]' but i just changed the pattern matching to record syntax pattern matching (didn't know this exists...) and now it seems to work
03:06:41 <Zenon1> but I still don't get why I have to qualify the operator if I make it an instance
03:07:05 <Kaidelong> you shouldn't have to, it should work even with importing ()
03:07:29 <Zenon1> i mean, shouldn't I be able to do 'sort [Card]' instead of 'sortBy Poker.Compare [Card]'
03:07:45 <Kaidelong> sort doesn't work?
03:07:47 <Kaidelong> what is the error?
03:08:28 <Jafet> Zvpun: well, I wouldn't have half as many sanity checks as you put in if I wrote something like that, but that's a matter of taste
03:08:33 <Zenon1> Stack space overflow: current size 8388608 bytes.
03:08:34 <Zenon1> Use `+RTS -Ksize -RTS' to increase it.
03:08:34 <Zenon1> ========== 2 =============
03:08:55 <Jafet> Zvpun: you might want to make sure that 10^(n-1) is an Integer then, because right now its type is indeterminate
03:09:20 <imcmeans> I wrote a little prime finder for project euler, and it's really slow. Any suggestions?
03:09:21 <imcmeans> http://hpaste.org/42536/primes
03:09:35 <Jafet> Zvpun: also, a common convention is to index digits, like everything else, from zero.
03:09:36 <Zenon1> oh an here's the full Poker module source, http://pastebin.com/Xb9dP0KS 
03:09:57 <imcmeans> I think my algorithm is good, so is my problem that I'm using Integer instead of Ints?
03:10:10 <Kaidelong> @src sort
03:10:10 <lambdabot> sort = sortBy compare
03:10:51 <Saizan> Zenon1: you have to indent the definition of compare
03:11:09 <Saizan> Zenon1: otherwise you're not defining the method of the instance, but rather a standalone function
03:11:42 <imcmeans> Is it recomputing primes inside of cand_divs each time?
03:11:45 <allbery_b> imcmeans: your algorithm sucks, actually :) it's not at all efficient, it's repeatedly doing the same things over and over
03:11:48 <Saizan> Zenon1: and the stack overflow is cause by the fact that Ord has default implementations that are circularly recursive, such that defining one of the methods defines them all
03:12:06 <Zenon1> ah 
03:12:21 <Zenon1> that makes sense
03:12:22 <Jafet> Isn't compare a minimal complete definition?
03:12:25 <Jafet> @src Ord
03:12:25 <lambdabot> class  (Eq a) => Ord a  where
03:12:25 <lambdabot>     compare      :: a -> a -> Ordering
03:12:25 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
03:12:25 <lambdabot>     max, min         :: a -> a -> a
03:12:37 <Saizan> Jafet: it is
03:12:45 <imcmeans> allbery_b: I'm kind of hazy on when a list is recomputed from the definition vs. stored and reused
03:12:47 <Zenon1> though one would expect the compiler to throw an error when there's an empty 'where' body
03:12:50 <allbery_b> Jafet: it is, but because the others are all defined in terms of it
03:13:03 <Kaidelong> Jafet: yes
03:13:16 <Jafet> Thank you all for agreeing!
03:13:20 <Kaidelong> he said belatedly
03:14:13 <allbery_b> imcmeans: sadly I'm kinda hazy on what happens inside list comprehensions
03:14:27 <imcmeans> But the problem is that "primes" is constantly getting recomputed from the start?
03:14:32 <allbery_b> but I'm pretty sure that expression is a little too complex for memozation to occur
03:14:43 <allbery_b> so yes
03:14:48 <Jafet> imcmeans: no, primes is a value, so its elements won't be recomputed.
03:14:49 <Zenon1> ok that works like a charm :) thanks a lot Jafet and Kaidelong
03:15:11 <Jafet> imcmeans: but your algorithm is really crap. You could look at those on the haskellwiki.
03:15:33 <Zenon1> oh an Saizan, of course :)
03:15:47 <Jafet> imcmeans: And if you want to know when evaluation happens, trace is your friend
03:16:04 <Zenon1> maybe I shouldn't code first thing in the morning...
03:16:15 <shachaf> Who runs lambdabot nowadays?
03:16:24 <shachaf> @let is broken
03:16:24 <lambdabot>   Parse error: SemiColon
03:16:49 <shachaf> @let is = broken
03:16:49 <lambdabot>  .L.hs:6:0:
03:16:49 <lambdabot>      Failed to load interface for `Control.Arrow.Operations':
03:16:49 <lambdabot>    ...
03:16:52 <Kaidelong> imcmeans: when doing the sieve of erastosthenes, I prefer counting with tuples over taking modulos, personally
03:17:39 <Kaidelong> I do not know if that is strictly neccessary but the result is fast enough for the euler problems
03:20:28 <Kaidelong> moddec (m,0) = (m,m-1)
03:20:30 <Saizan> imcmeans: are you compiling with -O2 ?
03:20:36 <Kaidelong> moddec (m,n) = (m,n-1)
03:21:46 <imcmeans> I'm running inside ghci
03:22:06 <imcmeans> is that much slower?
03:22:19 <Zao> imcmeans: Optimizations tend to help, a lot in some cases.
03:22:19 <Zenon1> cya guys, gonna get me some coffee and thanks again
03:22:43 <Zao> Kaidelong: I tend to go with arrays, and later on, precomputing and sucking them in.
03:23:02 <Zao> It helps having precomputed primes and phi up to N.
03:23:16 <imcmeans> ok. I might give that a try, but I think it's an algorithm probem like Jafet said - I might try a sieve implementation instead
03:23:16 <Zao> (phi as the totient function is trivial to compute while sieving for primes)
03:23:20 <Saizan> imcmeans: ghci can be very much slower
03:23:34 <Zao> Some day I'm going to implement Miller-Rabin for deterministic testing of moderately sized primes.
03:23:50 <Zao> Or some elliptic curves if I feel extremely insane :)
03:24:02 <Kaidelong> Zao: Miller-Rabin is overkill. Go with the fermat test, it is good enough.
03:24:36 <Kaidelong> if you're using the rabin cryptosystem pseudoprimes don't matter as much anyway since they cause the message to be lost forever, not to be sent insecurely
03:24:43 <Zao> I started doing my Eulers in Haskell, but have now moved to C++ with MPIR for bignums.
03:25:07 <imcmeans> Zao: THere's an implementation of it here http://www.polyomino.f2s.com/david/haskell/numbertheory.html
03:28:37 <Kaidelong> What's wrong with Haskell for the Euler's?
03:31:51 <Kaidelong> Eulers even
03:36:17 <Bram> hello, is the autor of http://learnyouahaskell.com/ idle here ? I've just created a .mobi (for kindle) version of his book and wanted to give it to him.
03:36:57 <ricky> I think that'd be BONUS ^
03:37:27 <Kaidelong> he is here and idle it seems
03:37:31 <Kaidelong> PM him
03:37:42 <Bram> ok
04:11:24 <pozic> | X{a=b} <- z -- which extension is this? 
04:12:07 <Saizan> PatternGuards iirc
04:19:15 <monadic_kid> Saizan: remember the problems i thought I was having with code never being evaluated? well it was a legitamgate because I was dealing with stateful computations I had identity/object problem so I was never using those lists that function was transforming. If I didn't pursue using deepseq I wouldn't been able to identity the problem so easily
04:19:50 <monadic_kid> *identify the problem so easily
04:22:18 <Saizan> monadic_kid: ah, great to see you solved it in the end, i'm always hesitant to suggest deepseq because it has to traverse the whole structure so it's often wasteful
04:25:38 <monadic_kid> Saizan: yeah well i gained some new knowledge/experience out of it, found about some awesome libraries like derive, template haskell can be so frickin useful sometimes
04:26:41 <Saizan> true, derive is quite nice :)
04:30:03 <monadic_kid> I hope something like Habit language with macro system like template haskell becomes popular, then there might be a chance to use it in an industry like the one i work in
04:39:54 * hackagebot storable-endian 0.2.2 - Storable instances with endianness  http://hackage.haskell.org/package/storable-endian-0.2.2 (EugeneKirpichov)
04:54:11 <Wooga> i've updated gedit haskell mode plugin to 0.2 version; now it smart also at deleting spaces after indenting keywords: 
04:54:14 <Wooga> ftp://neverb.net/soft/mine/gedit_haskell_mode/haskell_indentation_v0.2.tar.gz
04:55:15 <Wooga> but my python code is really nasty XD
04:55:24 <Saizan> maybe you should announce it to -cafe :)
04:55:33 <Wooga> thanks for direction
04:56:05 <monadic_kid> i was going try and put a link on the haskell wiki but couldn't find an appriopriate section
04:56:05 <Wooga> hm.. #haskell-cafe?
04:56:16 <monadic_kid> Wooga: mailling list
04:56:21 <Wooga> ah
04:57:26 <monadic_kid> the convention usually is to annouce on haskell main mailling list but you can annouce on -cafe as well
04:58:43 <monadic_kid> I could make a wiki page
05:12:53 <monadic_kid> min/maxBounds for floats?
05:13:25 <Jafet> > maxBound :: Double
05:13:26 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Double)
05:13:26 <lambdabot>    arising from a use o...
05:14:02 <sipa> > 1.0/0.0
05:14:03 <lambdabot>   Infinity
05:14:07 <Twey> No bound
05:14:26 <Twey> Floats lose precision when you get too big — there's no bound on the magnitude
05:14:46 <Twey> And then there's Infinity/-Infinity, yes ☺
05:15:15 <monadic_kid> just need a big enough number to create an infinite bounding volume
05:15:25 <monadic_kid> well i don't have to do it that way
05:15:33 <Zao> Maybe Maybe.
05:19:00 <ManateeLazyCat> I can dynamic linking new version in *running* program, but i need figure out how to *reload* current version if package's hash value change (mean user touch change code, but not change version number).
05:19:35 <ManateeLazyCat> Closer to target....
05:21:27 <monadic_kid> > infinity
05:21:28 <lambdabot>   Not in scope: `infinity'
05:21:35 <monadic_kid> > Rational.infinity
05:21:36 <lambdabot>   Not in scope: `Rational.infinity'
05:21:51 <dschoepe> > Infinity
05:21:51 <lambdabot>   Not in scope: data constructor `Infinity'
05:22:01 <sipa> > read "Infinity" :: Double
05:22:02 <lambdabot>   Infinity
05:22:15 <monadic_kid> > Numeric.IEEE.	infinity
05:22:16 <lambdabot>   Not in scope: data constructor `Numeric.IEEE'Not in scope: `infinity'
05:23:33 <monadic_kid> oh well i'll just use 1.0/0.0
05:24:10 <monadic_kid> ah
05:24:23 <monadic_kid> > GHC.Real.infinity
05:24:24 <lambdabot>   Not in scope: `GHC.Real.infinity'
05:25:34 <monadic_kid> interesting ghci says GHC.Real.infinity == 1.0 % 0.0
05:26:37 <Twey> Why's that interesting?
05:26:51 <Twey> That's kind of the definition around here
05:27:48 <monadic_kid> okay it's not particularly interesting
05:32:05 <ManateeLazyCat> @hoogle "[Int] -> Int"
05:32:06 <lambdabot> Parse error:
05:32:06 <lambdabot>   --count=20 ""[Int] -> Int""
05:32:06 <lambdabot>              ^
05:32:16 <ManateeLazyCat> @hoogle sum
05:32:16 <lambdabot> Prelude sum :: Num a => [a] -> a
05:32:16 <lambdabot> Data.Foldable sum :: (Foldable t, Num a) => t a -> a
05:32:17 <lambdabot> Data.List sum :: Num a => [a] -> a
05:33:10 <ManateeLazyCat> Which function do "[3,2,1] => 321" ?
05:33:44 <Twey> ManateeLazyCat: map intToDigit
05:33:58 <ManateeLazyCat> @hoogle intToDigit
05:33:58 <lambdabot> Data.Char intToDigit :: Int -> Char
05:34:25 <Eduard_Munteanu> Does the type-level fixed point combinator commute with the differentiation operator?
05:34:32 <ManateeLazyCat> Twey: I want 321 is Int
05:35:02 <Eduard_Munteanu> I'm reading this: http://en.wikibooks.org/wiki/Haskell/Zippers#Zippers_via_Differentiation    and I kinda wonder how to prove it, if I'm not mistaken
05:35:08 <Twey> read . map intToDigit
05:35:15 <ManateeLazyCat> Twey: I want compare [Int] in [[Int]] to get biggest version.
05:35:41 <ManateeLazyCat> Twey: Well, any function that don't need "Int -> String -> Int"?
05:35:51 <ManateeLazyCat> Twey: I want some function don't need convert.
05:36:06 <Twey> Or, sum . reverse . zipWith (*) (iterate (* 10) 1)
05:36:20 <Twey> But I suspect read . map intToDigit would be comparably fast
05:36:39 <Twey> > sum . reverse . zipWith (*) (iterate (* 10) 1) $ [3, 2, 1]
05:36:39 <Eduard_Munteanu> So the question is whether d(Mu f) = Mu df is true and how to prove it.
05:36:40 <lambdabot>   123
05:36:49 <Twey> Oh, right, you wanted it that order
05:36:51 <Twey> > sum . zipWith (*) (iterate (* 10) 1) $ [3, 2, 1]
05:36:53 <lambdabot>   123
05:36:58 <Twey> >.-
05:36:59 <ManateeLazyCat> Twey: Yes, thanks. :)
05:37:11 <ManateeLazyCat> ?
05:37:12 <Twey> Oh, I put the reverse in the wrong place
05:37:16 <Twey> > sum . zipWith (*) (iterate (* 10) 1) . reverse $ [3, 2, 1]
05:37:17 <lambdabot>   321
05:37:20 <Twey> There we are
05:37:30 <ManateeLazyCat> Ok, good function.
05:37:36 <Jafet> > read $ concat.show $ [3,2,1] :: Int
05:37:38 <lambdabot>   Couldn't match expected type `[a]'
05:37:38 <lambdabot>         against inferred type `GHC.Types...
05:37:51 <Jafet> > read $ concat.show. [3,2,1] :: Int
05:37:52 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
05:37:53 <lambdabot>         against inferred type...
05:38:00 <ManateeLazyCat> Twey: I'm real do is input packageName, then pick newest package by compare package version. :)
05:38:09 <Jafet> Blah, fixity
05:39:15 <demolithion> i totally don't get why  x = [0] ++ map (+1) x == [1..] someone can help me out i would expect it to be something like [0,1,1,2] after the second iteration. 
05:39:18 <ManateeLazyCat> But this way easy to break, if package version is like 0.0.1.
05:39:27 <ManateeLazyCat> s/is/is not
05:39:28 <Twey> ManateeLazyCat: Then 10 may not be a sufficient order of magnitude.  What do you do about package-0.24.19?
05:39:43 <Jafet> manatee: you'd better make a special version_compare for that.
05:40:02 <Jafet> Actually, you can probably just use the default Ord for [Int]
05:40:05 <ManateeLazyCat> Twey: Yeap, that's the problem if newest version is not Int bigger.
05:41:11 <monadic_kid> demolithion: the first form is infinite recurrsion
05:41:50 <monadic_kid> demolithion: because the definition x of is defined in terms of that expression using x
05:42:03 <Twey> monadic_kid: Yes; so is the other
05:42:10 <Twey> That's okay ☺  We're lazy
05:42:23 <Twey> demolithion: It's [0 ..], not [1 ..]
05:42:24 <monadic_kid> Twey: i never i said i wasn't
05:42:36 <monadic_kid> i never i said it wasn't
05:42:38 <ManateeLazyCat> Twey: Maybe i need figure out which package is newest for Cabal and don't care version number.
05:42:58 <Jafet> manatee, have you checked the cabal library?
05:43:07 <Jafet> It probably has some code for this.
05:43:08 <demolithion> monadic_kid: yes i get that it would produce an infinte list, but i somehow don't get how it produces [0..]
05:43:28 <Jafet> demolithion: simply insert the definition for x back into itself and reduce.
05:43:35 <monadic_kid> demolithion: what is it you don't understand
05:43:43 <ManateeLazyCat> Jafet: Yeap, i just want write some function for `versionBranch` in GHC-API, but i think maybe CAbal's code is better.
05:43:45 <Jafet> benmachine is supposed to have an evaluator that shows you the steps
05:44:07 <ManateeLazyCat> Saizan:  How doest Cabal know which package is newest? 
05:44:25 <Saizan> ManateeLazyCat: iirc it uses the Ord instance of Data.Version
05:44:33 <Twey> x = [0] ++ map (+ 1) ([0] ++ map (+ 1) ([0] ++ map (+ 1) …))
05:45:06 <Twey> x = [0] ++ map (+ 1) ([0] ++ map (+ 1) ([0] ++ …))
05:45:17 <Twey> x = [0] ++ map (+ 1) ([0] ++ [1] ++ …)
05:45:30 <ManateeLazyCat> Said
05:45:31 <Twey> x = [0] ++ [1] ++ [2] ++ …
05:45:44 <ManateeLazyCat> Saizan: Ah, Data.Version is versionBranch in GHC.
05:46:04 <Jafet> > fix ((0:).map succ)
05:46:05 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
05:46:16 <ManateeLazyCat> Saizan: Oh, Version is deriving from Ord, why i need compare mysef? Idiot...
05:46:33 <ManateeLazyCat> Saizan: I just need compare Version. :)
05:46:51 <ManateeLazyCat> @hoogle max
05:46:51 <lambdabot> Prelude max :: Ord a => a -> a -> a
05:46:51 <lambdabot> Data.Ord max :: Ord a => a -> a -> a
05:46:51 <lambdabot> Prelude maxBound :: Bounded a => a
05:47:07 <ManateeLazyCat> @hoogle maximum
05:47:07 <lambdabot> Prelude maximum :: Ord a => [a] -> a
05:47:07 <lambdabot> Data.ByteString maximum :: ByteString -> Word8
05:47:07 <lambdabot> Data.Foldable maximum :: (Foldable t, Ord a) => t a -> a
05:51:56 <Wooga> another gedit haskell mode update, improved space deleting feature: ftp://neverb.net/soft/mine/gedit_haskell_mode/haskell_indentation_v0.3.tar.gz
05:52:07 <Boxo> > fix ( (0:) . (1:) . ap (zipWith (+)) tail )
05:52:08 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
05:53:35 <Jafet> > text $ "[0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946..."
05:53:36 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
05:54:14 <medfly`> longer :)
05:57:45 <ManateeLazyCat> Haha, use Ord Version fix newest package problem. 
05:58:54 <ManateeLazyCat> Dynamic-linking newest package finish....
06:03:52 <PabloPerdomo> hi!
06:04:59 <Jafet> > ap (zipWith (flip (-))) tail $ unfoldr (uncurry $ (Just.) . ap (,) . (ap (,) . (+))) (0,1)
06:05:00 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
06:08:04 <Twey> >.-
06:11:15 <Twey> > zipWith subtract <*> tail $ unfoldr (uncurry $ fmap Just . ap (,) . ap (,) . (+)) (0, 1)
06:11:16 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
06:11:22 <Twey> Much neater.  ☺
06:12:07 <Jafet> > fix ((0 :) . map (succ . sum) . inits)
06:12:08 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
06:16:03 <Twey> > fix $ ([0, 1] ++) . (zipWith (+) <*> tail)
06:16:05 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
06:16:35 <Twey> Damn, three chars longer :þ
06:17:01 <Jafet> Oh, I thought we were going for length
06:17:17 <Jafet> > fix ((0:) . scanl (+) 1)
06:17:18 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
06:17:35 <Twey> Heh, nice
06:17:56 * Twey hadn't encountered that one before.
06:21:35 <Zeiris> Haskell is amazing. I am writing the dirtiest, hackiest, WORST code I've written since my first C++ programs years and years ago...
06:21:46 <Zeiris> Terrible naming, zero planning, nested functions, everything.
06:21:56 <Zeiris> And despite all that, the code somehow runs. No bugs.
06:21:59 <Jonno_FTW> Zeiris: what are you getting at?
06:22:15 <Zeiris> Just gotta spend a few minutes fixing type errors, and hey presto, it runs like magic :D
06:22:57 <Zeiris> Put down the torch and pitchfork, Jonno, this is a good thing :) 
06:23:22 <Zeiris> And it sort of explains/justifies some of the hackier code I've seen. It might not be human readable, but who cares - it was easily writeable.
06:26:23 * hackagebot redis 0.10 - A driver for Redis key-value database  http://hackage.haskell.org/package/redis-0.10 (AlexanderBogdanov)
06:28:11 <Saizan> so you're saying haskell could also steal market from perl?:)
06:29:22 <Eduard_Munteanu> What exactly is the relationship between Fix dF and d(Fix F)?
06:29:58 <Eduard_Munteanu> I reckon for zippers we want d(Fix F), but I can't tell how we get there from dF.
06:31:51 <Eduard_Munteanu> (where F is a functor whose fixed point gives the data structure over which we create a zipper)
06:33:23 <Zeiris> Saizan, exactly! Most of the potential unreadability, but with a compiler that finds really obvious screwups!
06:34:11 <Zeiris> There's some decent libraries for messing with files and traversing directories and whatnot. I bet if you selected the right bunch, and maybe wrote a few more, you could replace Perl's typical role.
06:34:57 <Jonno_FTW> Zeiris: there is already an implementation of perl 6 in haskell
06:35:21 <Zeiris> Hah. You're right, I guess that practically makes perl an EDSL!
06:40:00 <Eduard_Munteanu> Bah, you can't get any help on Christmas eve :P
06:40:29 <Eduard_Munteanu> BTW, happy xmas everyone.
06:40:32 <Twey> Eduard_Munteanu: I'd help… if I had any clue what you're talking about :þ
06:40:47 <Eduard_Munteanu> Well, zipper theory it is.
06:41:19 <ManateeLazyCat> Oh i remember: All, Merry Christmas! :)
06:41:33 <Twey> *grump*
06:42:10 <mescalinum> hi
06:42:14 <Twey> Hi
06:42:24 <mescalinum> are ParseLib and Interact two standard Haskell modules?
06:42:46 <mescalinum> I miss those for running a program (FOL theorem prover)
06:43:47 <Saizan> not currently
06:43:51 <Saizan> maybe in the past?
06:44:42 <mescalinum> yup, project dated 2001 (http://www.cs.yale.edu/homes/cc392/report.html)
06:45:09 <Twey> Hm
06:45:24 <Taejo> it says it was distributed with hugs
06:45:31 <Taejo> you can probably find a copy
06:45:35 <Twey> A message from June mentions ParseLib on Hackage
06:45:38 <Twey> Wonder what happened to it
06:46:01 <Twey> No idea about Interact, though
06:46:29 <Taejo> this might be it: http://www.fi.muni.cz/usr/skarvada/vyuka/IA014/ParseLib.hs
06:47:25 <mescalinum> yep, I found that too... but seems I can't find the proper Interact.hs
06:47:38 <Taejo> mescalinum: what functions are used from it
06:48:04 <Taejo> ah, found its export list
06:49:17 <Taejo> http://cvs.haskell.org/Hugs/pages/hugsman/libs.html
06:49:23 <mescalinum> here: http://haskell.pastebin.com/X6p4QUru  sorry, I'm stil new to haskell
06:50:09 <mescalinum> oh, thank you Taejo!
06:50:38 <Taejo> that's just the export list
06:51:04 <Taejo> it might not be very helpful to you
06:52:22 <mescalinum> so I need a different Haskell environment (HUGS)?
06:52:44 <mescalinum> what I just downloaded is HaskellPlatform-2010.2.0.0
06:53:00 <Taejo> mescalinum: I'm not sure if these'll be in Hugs any more
06:53:07 <Taejo> the platform includes GHC
06:53:22 <Taejo> but this code is quite old
06:53:30 <Taejo> a lot has changed in the Haskell world since then
06:54:38 <Taejo> I'm sure you can find the Interact module tho
06:54:46 <Eduard_Munteanu> @seen roconnor
06:54:46 <lambdabot> Unknown command, try @list
06:54:46 <preflex>  roconnor was last seen on #haskell 15 hours, 50 minutes and 26 seconds ago, saying: sm, Twey: Table 1 is wrong.  It should go KRC - Miranda - Haskell
06:55:00 <Eduard_Munteanu> preflex: seen roconnor
06:55:00 <preflex>  roconnor was last seen on #haskell 15 hours, 50 minutes and 40 seconds ago, saying: sm, Twey: Table 1 is wrong.  It should go KRC - Miranda - Haskell
06:55:38 <Taejo> mescalinum: http://google.com/codesearch/p?hl=en#SwdK0I69n_c/hugs98-Mar2005-patched/lib/hugs/Interact.hs&q=Interact%20hugs&d=3
06:55:45 <Twey> 05:22:43 *** roconnor ~roconnor@69-196-174-55.dsl.teksavvy.com has quit [Remote host closed the connection]
06:55:48 <Twey> (UTC)
06:58:24 <Eduard_Munteanu> Is he Conor McBride?
06:58:51 <Saizan> no, he's Russel O'Connor
06:59:23 <Saizan> McBride is pigworker on #agda/#epigram
07:00:56 <mescalinum> hmm... I get 'Invalid type signature' here:
07:00:58 <mescalinum> primitive ioeGetErrorString "primShowIOError" :: IOError -> String
07:00:59 <Eduard_Munteanu> I suppose I'll just stare at his paper really hard then :)
07:01:09 <Twey> Heh
07:05:23 <mescalinum> hmm... I tried the same code in Hugs98, get a similar error on the same line:
07:05:46 <mescalinum> "KnowledgeBase.hs":226 - Unknown primitive reference "primShowIOError"
07:08:32 <Taejo> mescalinum: Haskell's handing of IO errors is one of the things that's changed a lot recently... is it possible for me to download these files? I can see what I can do
07:11:38 <mescalinum> here's the program http://www.cs.yale.edu/homes/cc392/fol.tar.gz and here's the missing http://www.fi.muni.cz/usr/skarvada/vyuka/IA014/ParseLib.hs and (Interact.hs) http://google.com/codesearch/p?hl=en#SwdK0I69n_c/hugs98-Mar2005-patched/lib/hugs/Interact.hs&q=Interact%20hugs&d=3
07:11:45 <mescalinum> Taejo: ^
07:11:49 <Taejo> thanks
07:12:19 <Taejo> mescalinum: before I start on this, are you sure there isn't a newer version?
07:12:33 <Jafet> IOError is already an instance of Show, no magic there
07:13:21 <mescalinum> Taejo: I'm looking for it (or if anyone has already fixed this)
07:14:54 <Eduard_Munteanu> Hm, I kinda reached dT x dF = (dF T) x dT, where T = Fix F
07:15:40 <Eduard_Munteanu> Maybe I got it wrong, and the derivative is taken from the underlying ("unfixed") functor.
07:17:22 <Taejo> well at least KnowledgeBase.hs has {- This is very ugly -} above the very ugly part
07:17:26 <medfly`> wat, this looks like calculus
07:18:24 <Taejo> zomg, this program does case analysis on IO
07:18:30 <mescalinum> nope, the only I found at src.seereason.com/chiou-prover appears to be even earlier
07:18:45 <Jafet> medfly: even worse! It looks like ML.
07:18:46 <Taejo> do you have an email address for Chiou?
07:18:50 <Eduard_Munteanu> Yes, medfly`
07:19:03 <Eduard_Munteanu> (zippers as derivatives)
07:22:07 <Eduard_Munteanu> What would be the multiplicative inverse in a datatype, if it exists?
07:22:36 <Taejo> mescalinum: the problems aren't in the prover itself, just the way it does IO
07:24:01 <mescalinum> I see
07:24:10 <mescalinum> btw it uses many Hugs_* functions
07:24:18 <mescalinum> so I guess it won't work at all in GHC
07:24:31 <Taejo> only in the IO part
07:24:49 <Taejo> I should be able to hack it together in a few minutes
07:24:53 <mescalinum> yep, but the IO part is for loading a knoledge base (i.e. the thing you want to prove)
07:24:57 <Taejo> though it could sure use a rewrite
07:25:34 <mescalinum> unfortunately, I can't seem to find any easy to use theorem provers
07:25:40 <Taejo> @paste
07:25:40 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
07:25:51 <Eduard_Munteanu> T a b = a x b,   (T a b) / b = a  looks like some sort of forgetful functor
07:26:08 <Taejo> @paste2
07:26:08 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
07:30:15 <Taejo> mescalinum: I got it running: http://pastebin.com/Qgi8mCai
07:30:25 <Taejo> haven't tested it though
07:30:36 <mescalinum> really?^ in hugs or in ghc?
07:30:42 <Taejo> in ghc
07:30:54 <mescalinum> great!
07:35:15 <mescalinum> Taejo: getting this error: http://pastebin.com/HKyPeNgm am I missing something?
07:35:45 <Taejo> oh, sorry, I fixed that in my copy but didn't update the paste
07:36:05 <Taejo> change (const "") to (const $ return "")
07:36:28 <Taejo> mescalinum: ^
07:38:43 <mescalinum> according to "Did Curiosity Kill The Cat?" (http://www.cs.yale.edu/homes/cc392/node22.html) it's working
07:38:50 <mescalinum> thanks Taejo! you are a lifesaver
07:39:41 <Taejo> mescalinum: no problem
07:43:53 <Taejo> mescalinum: if the license allows, please put the fixed program somewhere googleable (possibly hackage, or at least a mail to haskell-cafe) so that the next person who needs it doesn't have to go through the same thing
07:44:00 <ManateeLazyCat> @hoogle lookupPackage
07:44:00 <lambdabot> No results found
07:45:45 <mescalinum> Taejo: heh, it doesn't say a word about license, and there isn't his email on the website... however the most of it comes from example of the AI book by Russel & Norvig
07:45:53 <ManateeLazyCat> @hoogle PackageConfigMap
07:45:54 <lambdabot> No results found
07:47:44 <mescalinum> Taejo: found it's email: charles.chiou at yale.edu
07:49:27 <mescalinum> *its
07:49:52 <Eduard_Munteanu> Hm, seems like Fix doesn't commute with function composition, right?
07:50:15 <tux_mark_5> hello
07:50:16 <Eduard_Munteanu> G o (Fix F) /= Fix (G o F)
07:50:18 <mescalinum> Taejo: how do you want to be credited? (i.e. name, email...)
07:50:38 <tux_mark_5> is there something like getCPUTime but without Integer?
07:51:02 <Taejo> mescalinum: my name is Max Rabkin, but what I did was trivial
07:51:37 <Eduard_Munteanu> s/function/functor/
07:51:41 <monadic_kid> tux_mark_5: clock package, posix bindings but it's only implemenated for linux at the moment
07:51:59 <tux_mark_5> monadic_kid: and what about cross-platform solution?
07:52:14 <arcatan> hmm, cabal-dev looks like something that could be handy the next time I'm going to dwell in the dependency hell
07:52:54 <tux_mark_5> nevermind, i guess i could use FFI; almost forgot that it was there ;D
07:53:20 <monadic_kid> tux_mark_5: it's suppose to be cross-platform, posix is a standization of OS/platform specific interfaces/tools, they just haven't written a mapping for windows because windows is not very posix compliant
07:53:38 <tux_mark_5> oh ;)
07:54:08 <tux_mark_5> because i need it to run both on linux and on windows; i use linux, but people who will run software use windows
07:54:13 <tux_mark_5> so FFI is the answer i guess
07:54:46 <Eduard_Munteanu> What's wrong with using getCPUTime and Integer?
07:55:09 <tux_mark_5> Eduard_Munteanu: i'm using MPFR, which doesn't play nice with GMP & Integer
07:55:12 <monadic_kid> tux_mark_5: maybe you can find another package on hackage
07:56:00 <tux_mark_5> Eduard_Munteanu: so i've replaced GMP allocator with my own, and now if anyone uses Integers within code, so program becomes unstable and eventually crashes
07:56:05 <ski> Eduard_Munteanu : `forall f g. fix (f . g) = f (fix (g . f))'
07:56:52 <monadic_kid> tux_mark_5: I'm using clock at the moment just because i need a high-res monotonic timer but later on i might try to get this working on windows, just that pre-windows 7 does not support monotonic timers i believe
07:57:49 <ManateeLazyCat> Saizan: Do you know which function can search packageName in Cabal database? I want input "foo" and get list ["foo-0.0.1", "foo-0.0.2", ... , "foo-0.0.n"], thanks! :)
07:57:57 <Eduard_Munteanu> ski: I'm more interested in Mu and zippers. Specifically, whether differentiation applies to the whole datatype or the unfixed functor.
07:58:25 <Eduard_Munteanu> And I suppose I can't prove d (Mu F) = Mu dF
07:58:51 <monadic_kid> tux_mark_5: wait looks like clock has been updated recently, maybe they've got a windows implementation now
07:59:04 <Eduard_Munteanu> I'm following the Wikibooks stuff... http://en.wikibooks.org/wiki/Haskell/Zippers#Zippers_via_Differentiation
07:59:19 <Eduard_Munteanu> They seem to differentiate the underlying functor.
07:59:34 <tux_mark_5> monadic_kid: never mind, i've already written small FFI & C & clock() function which is enough for me
07:59:45 <Eduard_Munteanu> So I guess it's not the derivative of the whole datatype as it sounds?
08:00:01 <mescalinum> Taejo: ouch, there are no means of contacting him (he's probably no longer at Yale) 550 550 5.1.1 <charles.chiou@yale.edu>... User unknown
08:00:30 <Taejo> ah
08:00:45 <ManateeLazyCat> @hoogle lookupPackageName
08:00:45 <lambdabot> No results found
08:01:06 <ski> Eduard_Munteanu : differentiation applies to the whole datatype, but zippers are not *exactly* differentiation
08:01:28 <silbo> hey
08:01:35 <Eduard_Munteanu> ski: could you expand on that?
08:02:12 <ski> Eduard_Munteanu : the differentiation of `F a' wrt `a' gives you the type of values of type `F a', except exactly one `a' element has been removed (replaced with a "hole", so to speak)
08:02:39 <Eduard_Munteanu> Yes.
08:03:20 <monadic_kid> tux_mark_5: yeah i know you're sorted now but i just looked at the source, they now have a windows impl
08:03:22 <ManateeLazyCat> lookupPackageName :: PackageIndex -> PackageName -> [(Version, [InstalledPackageInfo])]
08:03:30 <Eduard_Munteanu> But they seem to differentiate the underlying functor, i.e. the derivative of F' so that F = Mu F'. They have to be equivalent somehow.
08:03:46 <ski> Eduard_Munteanu : if you want instead to remove one *sub*-tree of `Tree a', then you don't want `d Tree a / Tree a', but rather decompose `Tree a' into `Mu (TreeF a)' (beware that this is not unique), and then you want `d TreeF a r / d r' (and then do something more with that ..)
08:03:49 * hackagebot greg-client 1.0.0 - A scalable distributed logger with a high-precision global time axis.  http://hackage.haskell.org/package/greg-client-1.0.0 (EugeneKirpichov)
08:06:50 <Eduard_Munteanu> ski: yeah, but given such a TreeF, you seem to imply 'd Tree' is at least isomorphic to 'Mu (d TreeF)'. Is this true or provable?
08:07:48 <ski> Eduard_Munteanu : as an example of the non-unicity : `forall a. List a = 1 + a * List a', `forall a r. ListF1 a r = 1 + a * r', `forall a r. ListF2 a r = 1 + a + a * a * r', note that `List a' is isomorphic to both `Mu (ListF1 a)' and `ListF2 a)' for every `a' (naturally), but `ListF1' and `ListF2' are different
08:08:01 <ManateeLazyCat> Looking for default PackageIndex
08:08:24 <ski> (yet another example is `forall a r. ListF0 a r = List a'
08:08:34 <Eduard_Munteanu> I only reached the point where dTree x dTreeF = (dTreeF . T) x dTree
08:08:52 <Eduard_Munteanu> s/T/Tree/
08:09:00 <ski> Eduard_Munteanu : i'm not sure what you mean by `d Tree' .. so you mean `D Tree' ?
08:09:08 <ski> s/so you/do you/
08:09:16 <Eduard_Munteanu> ski: 'd' is derivative
08:09:39 <Eduard_Munteanu> and Tree = Mu (TreeF)
08:09:46 <ski> i'm using `d ..a.. / d a' for taking the derivative of `..a..' wrt `a'
08:10:06 <ski> and using `D (...)' for taking the derivative of the function `...'
08:10:14 <Eduard_Munteanu> Oh.
08:10:16 <ski> those are different constructs
08:10:57 <ski> `D' is a ordinary higher-order function while `d ..a.. / a' is a variable-binding construct
08:11:25 <ski> more specifically `d ..a.. / d a' is the same as `D (\a -> ..a..) a'
08:12:18 <Eduard_Munteanu> I did my calculation kinda pointfree. Started with Mu F = F (Mu F), differentiated both sides, used chain rule and replaced T = Fix F. So I got...
08:12:51 * hackagebot strptime 1.0.0 - Efficient parsing of LocalTime using a binding to C's strptime,  with some extra features (i.e. fractional seconds)  http://hackage.haskell.org/package/strptime-1.0.0 (EugeneKirpichov)
08:12:51 <Eduard_Munteanu> dT/dx * dF/dx = ((dF/dx) T) * dT/dx
08:13:04 <Eduard_Munteanu> I'm at loss how to prove isomorphism there.
08:14:07 <Eduard_Munteanu> ski: note I'm differentiating functors, not functions.
08:14:07 <ski> i'm not sure what you did, there
08:14:22 <ski> yeah, type-functions
08:15:26 <ski> what did you do, after "Started with Mu F = F (Mu F)", more specifically ?
08:17:01 <Eduard_Munteanu> Mu F = F (Mu F)   <=>    (d Mu / dx) F   *   dF / dx  =   (dF / dx)(Mu F)    *     d(Mu F) / dx
08:17:15 <Eduard_Munteanu> I differentiated and applied chain rule in one step.
08:17:50 <Eduard_Munteanu> Does it look okay so far?
08:18:33 <silbo> MERRY XMAS!!!!!!!!!!!!
08:18:45 <Eduard_Munteanu> silbo: merry Christmas.
08:18:56 <ski> well, it doesn't look *syntactically* ok .. maybe the intension is correct, though .. let me think on that
08:20:00 <Eduard_Munteanu> Yeah, it's not Haskell syntax.
08:20:41 <ski> ok, you seem to be confusing `d (F T) / d a' with `d (F (G a)) / d a'
08:20:58 <ski> (i wasn't talking about whether it was correct as actual Haskell syntax)
08:21:40 <Eduard_Munteanu> ski: T is a T(a) there.
08:21:48 <ski> i suggest you should try to keep the `D (...) ' and `d (..a..) / d a' syntices apart, not confusing them
08:21:51 <ski> really ?
08:21:55 <ski> what is `a' then ?
08:22:18 <ski> you started from `Mu F = F (Mu F)'
08:22:23 <ski> there's no free `a' in that
08:22:23 <Eduard_Munteanu> ski: well for Mu F to be valid, F must be F :: * -> * -> *
08:22:33 <Eduard_Munteanu> ski: pointfree
08:23:01 <ski> oh, you're using `Mu :: (* -> * -> *) -> (* -> *)' ?
08:23:28 <Eduard_Munteanu> F is some F = \mu A. \mu X. A + A x X x X   for the tree type I'm specifically interested in.
08:23:43 * ski was thinking about `Mu :: (* -> *) -> *' (together with either `T :: * -> *' or `T :: * -> * -> *', though you seemed to use the former)
08:23:44 <Eduard_Munteanu> and my tree type is actually T = Mu F
08:24:01 <Eduard_Munteanu> or pointwise, T A = Mu (F A)
08:24:08 <ski> no
08:24:15 <ski> those are not equivalent
08:24:36 <ski> if `T = Mu F', then surely `T A = Mu F A'
08:24:56 <ski> with a different formulation of `T', you can get `T A = Mu (F A)', though
08:25:23 <Eduard_Munteanu> newtype Mu f = In (f (Mu f))     data ListF a f = Nil | Cons a f      type List a = Mu (ListF a)
08:25:28 <Eduard_Munteanu> This looks valid in Haskell.
08:25:47 <ski> yes
08:26:13 <ski> but then `List' is not `Mu ListF' (that's actually ill-kinded)
08:26:15 <Eduard_Munteanu> I'm using the Mu F notation simply so I don't write a every time.
08:26:22 <Eduard_Munteanu> Ah.
08:26:43 <Eduard_Munteanu> Any type-level composition operator then?
08:26:54 <ski> (however, `List' is `Mu . ListF' .. dunno whether that helps you or not)
08:27:39 <ski> anyway, in my mind, the `a' in `List a' is really irrelevant for what you're doing
08:27:59 <EvanR> does anyone know if randomR for Ints works correctly, that is, gets uniform distribution by 'rolling again' (to avoid range doesnt divide power of 2 problem)
08:27:59 <ski> you could just as well say `data IntListF r = Nil | Cons Int r'
08:28:10 <ski> and it wouldn't change what you're after, here
08:29:29 <Eduard_Munteanu> Well, whatever I wrote earlier I wrote on paper, so it could be like this... Mu . F = F . Mu . F   <=>    D Mu . F   *   DF  =   DF . Mu . F    *     D (Mu . F)
08:29:41 <ski> so, assuming `forall r. F r = 1 + A * r * r' (where `A' is a free variable, be it `Int' or whatever), then in `Mu F = F (Mu F)', both sides have kind `*'
08:30:06 <ski> so i'm not sure what you're differentiating alt. taking derivative wrt, there
08:30:24 <zachk1> how would i stop a character from echoing to the screen but still read it? 
08:30:27 <Eduard_Munteanu> ski: wrt the (only) free variable
08:30:36 <ski> wrt `A' ?
08:31:04 <Eduard_Munteanu> ski: F = \mu A. \mu X. A + A x X x X, so wrt X
08:31:06 * ski thought we had agreed we didn't want to take derivative wrt `A' .. so what then ?
08:31:27 <ski> `X' is not a free variable in `F'
08:31:30 <Eduard_Munteanu> (since A is bound by the application of F to the actual type we wish the tree over)
08:32:29 <ski> i'm sorry, but i'll be confused if we hop back and forth between the different variants, so let's consider your `forall a r. F a r = a + a * r * r', for the moment, ok ?
08:32:39 <Eduard_Munteanu> ski: ok, lemme ask it another way... How can I show building a zipper over T a = Mu (F a) is done by taking the derivative of F instead of T?
08:33:00 <Eduard_Munteanu> Ok.
08:34:15 <ski> using this, we have `forall a. Mu (F a) = F a (Mu (F a))'
08:34:27 <ski> .. which could also be written as `Mu . F = S F (Mu . F)', not sure whether that's really better
08:34:29 <Eduard_Munteanu> Yes.
08:35:11 <ski> so, here you *could* take the derivative of both sides, wrt `a' .. but i doubt you realyy *want* to do that
08:35:21 <Eduard_Munteanu> No, I don't.
08:35:47 <Eduard_Munteanu> I consider 'a' to be bound. So I have tress of Ints, of Chars, etc.
08:36:00 <Eduard_Munteanu> *trees
08:36:06 <ski> also, both sides have kind `*' (and there's no (sensible) other variable to abstract wrt, to get a higher kind)
08:36:29 <ski> heh, i would say that `a' is free :)
08:36:49 <ski> (but bound "further out" to something, yes)
08:36:56 <Eduard_Munteanu> ski: yeah, it is free, after all it's a polymorphic tree, but we're not interested in derivating wrt a.
08:37:16 <ski> so we can't seem to use `D' sensibly here, either
08:37:51 <Eduard_Munteanu> Why not? Let D = d/dX.
08:38:23 <ski> looking instead at `forall a r. F r a = a + a * r * r', we have `forall a. Mu F a = F (Mu F) a', or really `Mu F = F (Mu F)' (both sides having kind `* -> *', there)
08:38:23 <Eduard_Munteanu> (as a partial derivative, say)
08:38:42 <ski> to me, "D = d / d X' is nonsense
08:39:05 <ski> `D' is a constant, `d / d X' is (variable-binding) syntax
08:39:15 * ski blames bad math education
08:39:26 <Eduard_Munteanu> Hm, yeah.
08:39:49 <ski> another way of seeing that `d / d X' doesn't make sense here is to note that `X' is not a free variable
08:39:55 <ski> (or `r', as i named it ..)
08:40:09 <ski> you can only take the derivative wrt a free variable
08:40:57 <ski> `Mu (F a)' is the same as `Mu (\r -> F a r)', sure .. but that doesn't help
08:41:04 <zachk> how do i stop keys from echoing to console (on say windows ( though im interested in a cross platform solution)) 
08:41:14 <Eduard_Munteanu> ski: yeah.
08:41:33 <Jafet> zachk: hscurses or vty
08:41:56 <Jafet> Okay, ncurses might not be ported to windows
08:42:06 <roconnor> Finite Automata can add but not multiply?
08:42:10 <roconnor> really?
08:42:40 <zachk> im pretty sure finite automata cant parse s-expressions either
08:42:46 <aristid> if the size of the numbers is finite, they can
08:42:59 <ski> anyway, considering the alternative `forall a r. F r a = a + a * r * r' instead, we *could* form `D (Mu F) = D (F (Mu F))', .. but that's really the same as `forall a. d (Mu F a) / d a = d (F (Mu F) a) / d a'
08:43:00 <Eduard_Munteanu> ski: so how does one take the derivative of Mu F, or F then?
08:43:19 <roconnor> still, I thought there were "on-line" multiplication algorithms
08:43:23 * Eduard_Munteanu processing...
08:43:44 <roconnor> what if I make the number of digits equal (by prepending 0's to the shorter one) and then interleave the digits
08:43:45 <dolio> How many times do they read each number?
08:43:54 <ski> Eduard_Munteanu : i've currently only been trying to figure out any sense from your "taking derivative of `Mu F = F (Mu F)'
08:44:23 <Eduard_Munteanu> ski: I was trying to compare taking the derivative of Tree vs. TreeF
08:44:45 <ski> Eduard_Munteanu : yes. taking the derivative of `TreeF' makes sense
08:44:55 <ziman> hm, what's the complexity of multiplication? I know an O(n log n) algorithm while a DFA would do it in O(n)
08:45:06 <ski> Eduard_Munteanu:
08:45:07 <ski> er
08:45:21 <monochrom> An infinite lookup table could do it O(1)
08:45:26 <ski> Eduard_Munteanu : taking the derivative of `Tree' isn't useful, for zippers, though
08:46:20 <gio123> ski
08:46:37 <roconnor> ziman: O (n log n) is probably about the best complexity known
08:46:44 <Eduard_Munteanu> ski: so the only sane way to define zippers goes like: "zippers for a datatype 'T a', is taking the derivative of F such that T a = Mu (F a)"?
08:46:51 <ski> Eduard_Munteanu : assuming `forall r. TreeF r = a + a * r * r' (for a free `a'), then we want a zipper for `Tree' relative to its decomposition as `Mu TreeF' (which is not unique)
08:47:03 <Eduard_Munteanu> ski: ok, so it is indeed the underlying unfixed functor, not the whole datatype.
08:47:12 <Eduard_Munteanu> Ah, I see.
08:47:22 <ski> Eduard_Munteanu : i would skip the `a' in that formulation, since it's irrelevant to what you're after
08:47:28 <Eduard_Munteanu> Yeah.
08:48:19 <zachk> can i even get ncurses to compile on mingw? 
08:48:21 <ski> Eduard_Munteanu : so, `TreeF r' describes a collection of `r's .. these being the nodes of `Tree'
08:48:42 <Eduard_Munteanu> ski: initially I thought there was a sensible way to define the derivative of Foo = 1 + Foo x Foo wrt Foo, given its recursive nature.
08:49:15 <ski> Eduard_Munteanu : it can't be uniquely defined
08:49:17 <dolio> The derivative is 0.
08:49:40 <dolio> Since it's constant with respect to whatever you arbitrarily parameterize it by.
08:49:42 <Eduard_Munteanu> Oh, that's great. So it's infinitely recursive structure doesn't make any difference.
08:49:50 <Eduard_Munteanu> *its
08:50:05 <ski> Eduard_Munteanu : and then `d (TreeF r) / d r', or equivalently `D TreeF r', describes "nodes" of `Tree', with one `r'-element removed, corresponding to removing one subtree of `Tree'
08:50:44 <Eduard_Munteanu> Yeah.
08:51:24 <ski> Eduard_Munteanu : so then `Mu (\r -> 1 + D TreeF r)' will describe a `Tree' with one sub-`Tree' removed
08:51:29 <Eduard_Munteanu> Or to put it another way, zippers make sense for finite tree types (our unfixed functor), yielding an infinite tree type, right?
08:51:59 <ski> er .. i don't see where you get "finite" or "infinite" from
08:52:44 <ziman> roconnor, yes, that's why the existence of an on-line algorithm seems improbable to me (but this is just intuition)
08:52:46 <ski> hm
08:52:48 <Eduard_Munteanu> TreeF is finite, while Tree is (potentially) infinite.
08:53:00 <zachk> ziman: whats an "online algorithim" ? 
08:53:05 * hackagebot sphinx 0.3.3 - Haskell bindings to the Sphinx full-text searching deamon.  http://hackage.haskell.org/package/sphinx-0.3.3 (GregWeber)
08:53:10 <ski> i wouldn't think of `TreeF' as a tree type here, at all .. it *generates* `Tree'
08:53:48 <Eduard_Munteanu> Like if you had a list   data List a = Cons a (List a). On the other hand   data ListF a f = ConsF a f   is pretty much finite.
08:53:49 <ski> you can easily consider a tree type where every node has infinitely many direct sub-trees
08:54:01 <ziman> zachk, as I understand it, an algorithm that reads the input on a tape from left to right, never returning
08:54:02 <EvanR> can i use an ST array inside of a State action
08:54:04 <ski> i don't see that it would make any difference for the reasoning
08:54:13 <dolio> zachk: I believe it's an algorithm that produces the nth bit of output after reading only a factor of n input.
08:54:28 <zachk> mmm
08:54:29 <ski> EvanR : `StateT MyState (ST s)' ?
08:54:31 <Eduard_Munteanu> EvanR: with runSTarray yes, but not otherwise.
08:54:53 <Eduard_Munteanu> EvanR: ST is basically State with a store.
08:54:59 * zachk sometimes misses the ease of writing simple games in basic 
08:55:02 <dolio> It may be even a tighter bound than that.
08:55:06 * Bynbo7 thinks of ST as IO without the 
08:55:08 <EvanR> im in a State StdGen a
08:55:12 <Bynbo7> O*
08:55:15 <Bynbo7> IO*
08:55:21 <EvanR> can i from in here, run an ST array thing, while using the external state
08:55:26 <Bynbo7> urgh, bloody lag makes it impossible to correct mistakes -_-
08:55:27 <Eduard_Munteanu> ski: thanks for helping, things are clearer now.
08:55:50 <ski> Eduard_Munteanu : consider `data Tree a = Node a (Stream (Tree a))' and `data TreeF a r = Node a (Stream r)''
08:56:05 <dolio> zachk: If you want a random example, the paper More Haste, Less Speed describes how pure but lazy languages can solve a certain online algorithm asymptotically faster than a pure eager language.
08:56:22 <EvanR> would i have to extract that hidden state and pass it to the runSTUArray
08:56:44 <ski> Eduard_Munteanu : `TreeF a r' here is an "infinite tree" type, no ? .. still i don't see how this makes a difference
08:57:08 <dolio> Er, not solve an algorithm, but has an online algorithm that solves a certain problem....
08:57:10 <Eduard_Munteanu> ski: ah yes. But if you don't allow Mu (or similar constructs), you can only write TreeF-like datatypes.
08:57:14 <roconnor> ziman: there is an online algorithm for multiplying lazy streams of digits for real numbers between -1 and 1.
08:57:19 <monochrom> use StateT blah (ST s) a if you really want to mix them. no other way.
08:57:28 <zachk> dolio: do you have an authors name? google is returning a ton a of results some even in theology :-/ 
08:57:32 <roconnor> ziman: I mean, it has to be online since there is an infinite number of digits.
08:57:35 <EvanR> meh, the outside world needs to know i used ST
08:57:42 * zachk got it
08:57:44 <Eduard_Munteanu> EvanR: runSTArray doesn't require any changes to your types.
08:57:46 <ziman> roconnor, interesting...
08:57:47 <Eduard_Munteanu> :t runSTArray
08:57:47 <lambdabot> Not in scope: `runSTArray'
08:58:07 <roconnor> ftp://ftp.comlab.ox.ac.uk/pub/Documents/techpapers/Geraint.Jones/FP-1-96.ps.Z
08:58:12 <EvanR> yeah but i cant use the ambient RNG
08:58:19 <dolio> Search with the keyword "lazy".
08:58:28 <Eduard_Munteanu> anyway, it's like   s -> ST s (Array i e) -> e, IIRC
08:58:49 <EvanR> wheres the updated s
08:58:52 <roconnor> ziman: now we are comparing apples to pears here (multiplying integers and multiplying real numbers)
08:59:03 <Eduard_Munteanu> erm, no... runSTArray :: Ix i => (forall s. ST s (STArray s i e)) -> Array i e
08:59:11 <silbo> hey, if I have a type Point that has x and y and I want to take out the x from a variable of type point, how can this be accomplished?
08:59:22 <roconnor> so maybe there is wiggle room for there not to be an online algoirthm for multiplying integers and there to be one for multiplying real numbers.
08:59:32 <Bynbo7> Eduard_Munteanu: remmember the s completely disappears outside the runST* functions
08:59:58 <Bynbo7> silbo: what does Point look like? how is it defined?
09:00:02 <ski> Eduard_Munteanu : i'm not sure we're really closer to proving whatever you wanted to prove initially (i never understood exactly what) .. though i suppose it might be that the futility of it is more evident, or something
09:00:10 <Eduard_Munteanu> EvanR: so you get back a frozen Array, you don't need ST in your State type.
09:00:27 <roconnor> or maybe the online algorithom for multiplying real numbers gets arbitrarily ahead of itself.
09:00:34 <ziman> roconnor, I'd almost say they are the same thing (just reversed), but I need more thought
09:00:34 <EvanR> Eduard_Munteanu: that would be fine, but i need the updated state
09:00:35 <roconnor> though I don't recall anything like that
09:00:55 <silbo> Bynbo7: type Point = (Int,Int)
09:01:07 <Eduard_Munteanu> ski: well my initial understanding (you could blaim simplistic explanations of zippers) was that it involved taking the derivative of types like Tree, not like TreeF.
09:01:14 <roconnor> ziman: oh and the real numbers have a redudent digit
09:01:16 <Bynbo7> silbo: let getX (x,y) = x
09:01:17 <roconnor> ziman: I wonder if that helps
09:01:22 <Bynbo7> or, getX = fst
09:01:28 <roconnor> that's would be interesting
09:01:32 <dolio> Probably.
09:01:51 <roconnor> if we add a redudent digit, can we multiply integers in O(n) time?
09:02:01 <silbo> Bynbo7: ok
09:02:08 <silbo> Bynbo7: thx
09:02:19 <Bynbo7> o.O
09:02:28 <Eduard_Munteanu> ski: so a zipper over Tree actually involves a derivative of its decomposition in a TreeF.
09:02:32 <roconnor> (and the presumably removing the redudent digit would take Theta(n log n)
09:02:50 <roconnor> s/Theta/Omega/
09:02:55 <Zenon1> i wonder how long it'll take untill silbo asks about snd ;)
09:03:04 <Bynbo7> aye
09:03:34 * Bynbo7 -> sleep. being awake at 2AM on christmas morning isn't a good idea
09:03:57 <roconnor> Bynbo7: Santa won't come until you are alseep
09:04:01 <Eduard_Munteanu> Bynbo7: is it the 24th or 25th there?
09:04:05 <Bynbo7> i no rite?
09:04:07 <Bynbo7> 25th
09:04:38 <Bynbo7> so, Merry Christmas from Tokyo to you all!
09:04:44 <Bynbo7> and goodnight
09:04:47 <Eduard_Munteanu> Merry xmas to you too.
09:04:49 <EvanR> im doing a shuffle, i know that theres a functional perfect shuffle package, but i want to do it imperatively, and i dont want to use IO, and id like to keep the same external interface for the rng
09:04:58 <Jafet> roconnor: represent numbers as convolutions
09:05:12 <roconnor> EvanR: MonadRandom?
09:05:21 <c_wraith> EvanR, use ST
09:05:28 <Jafet> Of course, addition on convolutions is left as an exercise
09:05:29 <EvanR> yes ST sounds right
09:05:30 <roconnor> Jafet: sure.
09:05:42 <Eduard_Munteanu> Yeah, runST.
09:05:54 <EvanR> but doesnt seem to be compatible with State StdGen or MonadRandom
09:06:13 <roconnor> StateT StdGetn ST
09:06:33 <EvanR> ok, so run an inner StateT
09:06:35 <roconnor> c_wraith: why does EvanR want to use ST?
09:06:35 <Eduard_Munteanu> EvanR: if you embed your function in runST, you can present the computation as a State to the callers.
09:06:48 <c_wraith> https://patch-tag.com/r/c_wraith/yomid/snapshot/current/content/pretty/src/Util.hs  <-- There's an ST shuffle in here
09:06:53 <Eduard_Munteanu> roconnor: for mutable arrays.
09:07:01 <EvanR> so i will need to have raw access to the RNG state
09:07:12 <EvanR> to do the inner run
09:07:30 <Bynbo7> Eduard_Munteanu: can you get a list of values using the RNG?
09:07:30 <Jafet> Hm wait, addition on convolutions works. If you ignore carry propagation.
09:07:33 <c_wraith> eh?  No, the RNG is not something you need raw access to.  What you need for an efficient shuffle is O(1) updates.
09:07:34 <Bynbo7> uh, EvanR 
09:07:46 <roconnor> Jafet: ya, who needs to worry about carry
09:07:56 <roconnor> Grade 1 addition algorithms are lame
09:08:00 <EvanR> Bynbo7: yeah, i could do that ahead of time
09:08:18 <dolio> roconnor: Anyhow, I'm not sure an online algorithm helps with implementing it on a finite state machine, necessarily. I don't think there's a restriction on how much of the previous input you can remember in an online algorithm, while a FSM can remember at most O(1) bits of the input.
09:08:22 <ski> Eduard_Munteanu : yes, though s/its decomposition/a decomposition/
09:08:25 <Bynbo7> then do that, use ST, feed the ST block with a list of random values
09:08:35 <EvanR> seems roundable for imperative programming
09:08:36 <Eduard_Munteanu> ski: yes, I'm aware there could be plenty.
09:08:40 <Eduard_Munteanu> ski: again, thanks for the help :)
09:08:46 <dolio> Online is about restricting lookahead.
09:08:46 <EvanR> roundabout
09:09:00 <dolio> If I understand correctly, at least.
09:09:13 <lars9> how does state monad differ from ST monad? it seems we can simulate STVar with State Var
09:09:18 <Eduard_Munteanu> BTW, is there any particular name for decomposing a recursive functor into an "unfixed" functor?
09:09:25 <roconnor> dolio: I agree, but I don't recall a stack of any kind in the online multiplication algorithm
09:09:32 <roconnor> for real numbers
09:09:53 <Eduard_Munteanu> Or a recursive type into a non-recursive type and Mu.
09:09:58 <c_wraith> lars9: ST is different in internal representation.  In GHC, it's the same as IO underneath, meaning it uses true mutable state underneath.
09:09:59 <ski> lars9 : we can dynamically allocate `STRef s a's for any type `a', during the computation. there's no known way to do that with `State'
09:10:33 <ski> Eduard_Munteanu : i'm not aware of any
09:10:44 <Eduard_Munteanu> I see.
09:11:11 <lars9> c_wraith: means ST is faster?
09:11:22 <Eduard_Munteanu> Well isn't it rather trivial for State to be truly mutable through strictness analysis?
09:11:45 <Eduard_Munteanu> (at least for a strict state monad)
09:11:46 <c_wraith> lars9: If you're using it properly, it generally is fast.
09:12:28 <c_wraith> Eduard_Munteanu, I don't think GHC does that kind of analysis.
09:13:29 <EvanR> roconnor: what would the s in ST s (STArray s i e) be ?
09:13:49 <Eduard_Munteanu> Polymorphic.
09:14:01 <augustss> Eduard_Munteanu: it's not entirely trivial, but it possible
09:14:09 <roconnor> Eduard_Munteanu: the phantom type eated by runSt
09:14:15 <lars9> c_wraith: yeah, for Array it is. but it does not speedup when using ST with map, unless GHC provides us a STMap, right?
09:14:19 <roconnor> EvanR: the phantom type eated by RunST
09:14:29 <Eduard_Munteanu> I see.
09:14:32 <c_wraith> lars9: the big advantage to mutability are the few cases where it makes an algorithm faster to use mutable state.
09:14:37 <EvanR> roconnor: am i supposed to use it for something?
09:14:54 <c_wraith> EvanR: the point of ST is that you're never supposed to be able to tell what s is.
09:15:08 <EvanR> oh
09:15:18 <Eduard_Munteanu> Yeah, even if you provide typesigs, you leave it at 's'.
09:15:57 <xarch> if the s is polymorphic, then it means the side effects won't escape the expression
09:16:29 <c_wraith> lars9: yeah, the only things ST provides (at a base level) are STArray and STRef.  Any code that doesn't use them get no benefit from being wedged inside ST
09:16:39 <c_wraith> *gets
09:17:46 <Eduard_Munteanu> Basically IO without IO :)
09:18:21 * ski . o O ( `d IO / d IO')
09:19:01 <Eduard_Munteanu> Heh.
09:19:16 <roconnor> Eduard_Munteanu: you are supposed to use it to prevent sharing between different applications of runST (think of it as different "threads")
09:19:18 <roconnor> ga
09:19:26 <roconnor> Eduard_Munteanu: sorry I keep doing that
09:19:31 <Eduard_Munteanu> :)
09:19:32 <roconnor> EvanR: you are supposed to use it to prevent sharing between different applications of runST (think of it as different "threads")
09:19:58 <lars9> c_wraith: a ST map would be very nice:)
09:20:05 <EvanR> http://codepad.org/e9Kd32gE ignore the missing algorithm, just making sure i have the types straight
09:20:41 <EvanR> er e = outer a
09:21:18 <c_wraith> Why is there a StateT there?
09:21:31 <EvanR> gr i dont have a runSTArray anywhere
09:21:44 <c_wraith> you don't need runSTArray.  it's just a convenience method for some use cases
09:21:49 <EvanR> because a) people told me to use StateT and b) i need uniGen
09:22:44 <c_wraith> I clearly don't know enough about UniGen to know what you're doing.  But I suspect you don't need any of that in there.
09:23:01 <EvanR> i know i dont 'need' it
09:23:13 <Eduard_Munteanu> runSTArray is nice because it handles unsafe freezing.
09:23:17 <EvanR> but one of my requirements was to keep the same external interface
09:23:29 <EvanR> UniGen is just State StdGen, at the moment
09:23:41 <c_wraith> ok, here's what I'd do:
09:24:18 <c_wraith> 1.  get the permutation.  You can do this without ST.  Just generate the indexes that'll be permuted
09:24:37 <c_wraith> 2. Using ST, perform the permutation
09:24:59 <EvanR> getting the permutation is what 'requires' a mutable array
09:25:04 <c_wraith> No it's not.
09:25:10 <c_wraith> performing it is what requires mutability
09:25:23 <phao> I'm starting to see why functional programming, and no side effects is good =)
09:25:54 <EvanR> backtracking, i know there is a functional perfect shuffle package, but i want to do the imperative algorithm
09:26:07 <EvanR> i dont think you can do the latter efficiently without a mutable array
09:26:09 <c_wraith> backtracking, I provided a link
09:26:15 <c_wraith> That includes shuffle.
09:26:41 <EvanR> im going to find the link and read it
09:27:29 <EvanR> c_wraith: that doesnt do what you were just saying
09:27:41 <c_wraith> No, because I assumed a more general interface
09:27:56 <EvanR> ignore the actual shuffle of items, thats fine
09:28:07 <EvanR> lets talk about computing an random permutation
09:28:16 <c_wraith> I assumed "given a RandomGen, returning a RandomGen"
09:28:52 <EvanR> how do you compute a random permutation?
09:29:21 <c_wraith> Not quite the same way the perfect shuffle works.
09:29:23 <Eduard_Munteanu> You need a source of randomness.
09:29:32 <Eduard_Munteanu> That would be your state I reckon.
09:29:34 <EvanR> Int -> g -> ([Int], g) is fine
09:29:44 <EvanR> the first int is size of sequence
09:30:45 <c_wraith> Hmm.  I wouldn't generate a true permutation, because I can't obviously see how to do it.  Instead, I'd generate the swap indexes used by the shuffle algorithm.
09:30:45 <EvanR> the 'easiest' way i know is fischer yates on a mutable array
09:30:55 <EvanR> exactly
09:31:18 <c_wraith> But generating those indexes is not the same as actually doing the swaps.
09:31:24 <EvanR> ignore that
09:31:35 <EvanR> the real issue here is the permutation
09:32:03 <c_wraith> > \i -> randomR (0, i)
09:32:04 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> g -> (t, g))
09:32:04 <lambdabot>    arising from ...
09:32:09 <c_wraith> :t \i -> randomR (0, i)
09:32:10 <lambdabot> forall t g. (Num t, Random t, RandomGen g) => t -> g -> (t, g)
09:32:10 <EvanR> actually doing the permutation on an input list is just a map , i think
09:32:23 <EvanR> maybe not, but anyway
09:33:18 <c_wraith> :t unfoldR
09:33:19 <lambdabot> Not in scope: `unfoldR'
09:33:21 <c_wraith> :t unfoldr
09:33:22 <lambdabot> Not in scope: `unfoldr'
09:33:30 <EvanR> so the key here is to run an ST array internally to facilitate the swap algorithm, that gives you your permutation
09:33:34 <c_wraith> yes
09:33:49 <EvanR> and i might as well swap the items at the same time
09:34:03 <c_wraith> Well, your interface uglifies that.
09:34:21 <c_wraith> unless you assume you can extract g and then set it at the end
09:34:24 <EvanR> i didnt reintroduce the interface
09:34:48 <EvanR> so now separating them is silly isnt it
09:35:19 <EvanR> a random permutation is just a special case of the general shuffle
09:35:53 <EvanR> also, if i put my interface back, Int -> UniGen [Int], were back in the same situation with ST
09:36:45 <EvanR> so i think im on the right track
09:38:23 <EvanR> http://codepad.org/1Q2sB9w4
09:38:36 <EvanR> one problem i can identify here is the 'a' wont work
09:38:48 <EvanR> in the past i solved this by deleting type signatures
09:40:10 <roconnor> @kind StateT
09:40:10 <lambdabot> Not in scope: type constructor or class `StateT'
09:40:19 * hackagebot sphinx 0.3.4 - Haskell bindings to the Sphinx full-text searching deamon.  http://hackage.haskell.org/package/sphinx-0.3.4 (GregWeber)
09:40:24 <roconnor> shoudl be "StateT UniGen (ST s) (STArray s Int a)"
09:40:42 <EvanR> whats the third part?
09:40:53 <roconnor> the parameter of the monad
09:41:02 <roconnor> (ST s) is the monad being transformed
09:41:10 <roconnor> Unigen is the parameter of the state transformer
09:41:26 <roconnor> StateT takes three parameters
09:42:00 <EvanR> but runSTArray takes ST s (STArray s i e)
09:42:23 <roconnor> @hoogle runStateT
09:42:23 <lambdabot> Control.Monad.State.Lazy runStateT :: StateT s m a -> s -> m (a, s)
09:42:24 <lambdabot> Control.Monad.State.Strict runStateT :: StateT s m a -> s -> m (a, s)
09:42:29 <roconnor> @hoogle execStateT
09:42:29 <lambdabot> Control.Monad.State.Lazy execStateT :: Monad m => StateT s m a -> s -> m s
09:42:29 <lambdabot> Control.Monad.State.Strict execStateT :: Monad m => StateT s m a -> s -> m s
09:42:34 <roconnor> @hoogle evalStateT
09:42:34 <lambdabot> Control.Monad.State.Lazy evalStateT :: Monad m => StateT s m a -> s -> m a
09:42:34 <lambdabot> Control.Monad.State.Strict evalStateT :: Monad m => StateT s m a -> s -> m a
09:42:35 <c_wraith> UniGen has the wrong kind to be the state parameter
09:42:48 <roconnor> EvanR: replace runStateT with evalStateT
09:42:53 <c_wraith> Which is why this interface is silly
09:43:03 <EvanR> youre right, its in the wrong place
09:43:13 <roconnor> c_wraith: oh you are right
09:43:20 <roconnor> c_wraith: I thought UniGen was a type
09:43:45 <EvanR> its State StdGen
09:44:01 <roconnor> EvanR: do you have isomoprhisms exposing that?
09:44:10 <c_wraith> The right way to do this is to start with a get, and end with a put.
09:44:19 <c_wraith> And don't use Unigen internally
09:44:48 <EvanR> well MonadRandom doesnt let you do that
09:44:49 <c_wraith> Because it interferes with using ST
09:45:20 * hackagebot sphinx 0.3.5 - Haskell bindings to the Sphinx full-text searching deamon.  http://hackage.haskell.org/package/sphinx-0.3.5 (GregWeber)
09:45:24 <EvanR> roconnor: i dont understand
09:45:51 <EvanR> i only wanted one action for UniGen, basically the randomR
09:45:53 <c_wraith> yes.  I don't like MonadRandom very much because it prevents using ST.
09:46:22 <EvanR> ... or ST is preventing sane interfaces
09:46:53 <c_wraith> The only way you can make this work is to first generate the list of indices to update with inside UniGen, then use ST to do the shuffle.
09:47:17 <c_wraith> Two different steps, totally independent of each other.
09:47:21 <EvanR> ST stops you from combining with any generator-like monad?
09:47:42 <c_wraith> there's no ST transformer.
09:47:52 <c_wraith> So ST can only be used for pure code.
09:47:56 <EvanR> so youre saying im transformer the wrong direction?
09:47:58 <c_wraith> essentially
09:48:05 <EvanR> transforming
09:48:09 <c_wraith> I'm saying your transform doesn't make any sense.
09:48:27 <c_wraith> In theory, you could use UniGenT
09:48:33 <c_wraith> And maybe that's what you really want.
09:48:48 <c_wraith> But I kind of doubt that, too
09:48:58 <EvanR> generate the indexes first?
09:49:01 <EvanR> how does that help?
09:49:21 <c_wraith> Because then you pass a pure list of indices to an ST function that does the swapping.
09:49:22 <roconnor> @hoogle mapStateT
09:49:22 <lambdabot> Control.Monad.State.Lazy mapStateT :: (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
09:49:22 <lambdabot> Control.Monad.State.Strict mapStateT :: (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
09:49:41 <EvanR> c_wraith: the generating the of the permutation is what requires a mutable array xD
09:49:49 <c_wraith> No, it doesn't.
09:49:50 <ski> @type Data.Array.ST.runSTArray
09:49:50 <lambdabot> forall i e. (Ix i) => (forall s. GHC.ST.ST s (GHC.Arr.STArray s i e)) -> Array i e
09:50:07 <EvanR> yes, it does, the fisher yates algorithm, which is what im trying to do
09:50:31 <EvanR> also what your example does
09:50:40 <c_wraith> in your case, it'd be something like: sequence [randomR (0, i) | i <- [n,n-1..1] ]
09:50:51 <c_wraith> with whatever you renamed randomR to.
09:50:55 <c_wraith> it's not a true permutation
09:50:56 <roconnor> c_wraith: I think something can be done with mapStateT
09:51:00 <EvanR> so youre not saying to do it separately, youre saying to expose the generator directly
09:51:00 <c_wraith> instead, it's just the swap indices
09:51:04 <EvanR> thats something else
09:51:12 <c_wraith> I'm saying those are your two options
09:51:14 <EvanR> if i had the generator i could simply run ST
09:51:16 <c_wraith> expose the generator
09:51:28 <c_wraith> *or* generate the swap list independently
09:51:36 <EvanR> no. above you did BOTH
09:51:48 <c_wraith> Not at all.  That sequence is running in UniGen
09:51:50 <EvanR> randomR is a normal function
09:52:02 <EvanR> oh, sequence
09:52:06 <c_wraith> Right, I meant "your version of randomR that you haven't bothered to tell us the name of"
09:52:10 <EvanR> uniGen
09:52:14 <c_wraith> ah, ok
09:52:27 <c_wraith> sequence [uniGen (0, i) | i <- [n,n-1..1] ]
09:52:36 <EvanR> wait, that works an is efficient? o_O
09:52:48 <c_wraith> It just is generating the swap indices.
09:52:51 <c_wraith> Nothing special
09:52:54 <roconnor> @type mapStateT (Identity . runST)
09:52:55 <lambdabot> Not in scope: `mapStateT'
09:52:55 <lambdabot> Not in scope: data constructor `Identity'
09:52:55 <lambdabot> Not in scope: `runST'
09:53:01 <c_wraith> applying them properly is the tricky part
09:53:12 * EvanR brain explode
09:53:28 * ski . o O ( `forM [n,n-1 .. 1] $ \i -> uniGen (0,i)' )
09:53:31 <EvanR> thats been the key all a long
09:53:59 <c_wraith> crap, I have an appointment in an hour.  gotta run.  
09:54:07 <EvanR> thanks
09:54:35 <pacak> /quit
09:56:18 <EvanR> ski: sure thats right? uniGen may produce i
09:58:00 <ski> EvanR : i only reworded what c_wraith said, i don't know what it's supposed to do ..
09:58:16 <EvanR> ok
09:58:26 <EvanR> me neither, after looking at it, always ends in 0
09:58:43 <ski> EvanR> :t uniGen
09:59:01 <EvanR> Int -> Int -> UniGen Int
09:59:21 <ski> oh, not `(Int,Int) -> UniGen Int', then ?
09:59:28 <EvanR> no, maybe it should be a tuple
09:59:36 <EvanR> by default i never do that
10:00:04 <Eduard_Munteanu> Saizan suggested the second derivative could yield two-hole contexts. But following this reasoning, the 3rd derivative and so on could be zero.
10:00:28 <ski> if `UniGen' is some kind of random monad, then that would generate a list of indices, for permutating
10:00:34 <ski> i.e. a random permutation
10:00:42 <copumpkin> oh sweet, psykotic is on twitter now
10:00:48 <Eduard_Munteanu> Does anybody have any links/info to point me to for "higher-order" zippers?
10:00:55 <EvanR> ski: the last index seems a bit limitted
10:01:29 <copumpkin> > [n|(p,n+1)<-zip[2..](iterate(2*)4),iterate(\s->(s^2-2)`mod`n)4!!(p-2)==0]
10:01:33 <lambdabot>   mueval-core: Time limit exceeded
10:01:38 <copumpkin> > take 10 [n|(p,n+1)<-zip[2..](iterate(2*)4),iterate(\s->(s^2-2)`mod`n)4!!(p-2)==0]
10:01:39 <lambdabot>   [7,31,127,8191,131071,524287,2147483647,2305843009213693951,618970019642690...
10:01:41 <ski> EvanR : well, at that point, there's only one index left, so ..
10:02:14 <EvanR> ok, so its not to be interpreted as 'put thing at this index here'
10:02:51 <ski> it's to be interpreted as "now remove the element at this index, in the sequence of remaining elements"
10:02:53 <EvanR> ah, it needs to fed into fischer yates
10:03:11 <ski> possibly it can be reworked into a different presentation of the permutation
10:03:17 <Eduard_Munteanu> I'm mainly interested in a zipper over a tree that allows me to _swap_ two subtrees easily.
10:03:53 <kosmikus> Eduard_Munteanu: not multiple holes, but multiple datatypes (higher-order fixed points): http://www.cs.uu.nl/wiki/GenericProgramming/Multirec
10:04:19 <ski> Eduard_Munteanu : if `d (T a) / d a' is like `T a', but with one `a' removed, then `d (d (T a) / d a) / d a' is like `T a', but with two `a's removed (in order)
10:04:52 <Eduard_Munteanu> kosmikus: ah, I'm kinda writing my own zipper stuff.
10:05:14 <Eduard_Munteanu> ski: oh, so it's more like a zipper over a zipper.
10:05:17 <Eduard_Munteanu> Isn't it?
10:05:39 <ski> i don't see that
10:05:56 <ski> (the `T' here corresponds to your `F')
10:06:24 <Eduard_Munteanu> Uh, my bad, I misread your "in order".
10:07:20 <EvanR> ski: take thing at index, and collapse the sequence?
10:07:24 <ski> that was just to make clear that `[2,3,<missing 0>,7,11,<missing 1>,17]' will be considered different from  `[2,3,<missing 1>,7,11,<missing 0>,17]'
10:07:34 <ski> EvanR : yes
10:07:42 <Eduard_Munteanu> This complicates matters somewhat, I suppose I could replace subtree a with subtree b, by doing a <- b, backtracking to the top, following b's context and doing b <- a.
10:07:43 <EvanR> how does ST help with that
10:08:13 <Eduard_Munteanu> Unless there are better ways. (?)
10:08:35 <zachk> um can hackage package unix be built on mingw? 
10:08:49 <ski> this is related to the <http://en.wikipedia.org/wiki/Factoradic> number representation, btw
10:09:51 <ski> Eduard_Munteanu : interesting problem .. i'm not sure what's the best way to approach it
10:10:18 * ski didn't know EvanR was considering `ST' ..
10:11:03 <Eduard_Munteanu> ski: yeah, I'm implementing adaptive Huffman coding, and it's described in terms of such operation on trees. I think it's Vitter's algorithm.
10:11:21 <EvanR> ski: that was my original question, how to combine a generator monad with ST
10:11:27 <EvanR> answer is apparently you cant
10:11:31 <Eduard_Munteanu> And I kinda want to keep the implementation close to the description I've been given.
10:11:36 <EvanR> now im on a different track
10:11:41 <ski> what is a "generator monad" ?
10:11:58 <EvanR> a monad which has an action to take something from a stream
10:13:02 <ski> something like `[i] -> ST s (a,[i])', or what ?
10:13:22 <EvanR> [a] -> UniGen [a]
10:13:31 <EvanR> shuffle ::
10:13:36 <ski> @unmtl StateT [i] (ST s) a
10:13:36 <lambdabot> [i] -> ST s (a, [i])
10:13:55 <ski> and there's no transformer variant of `UniGen' ?
10:14:18 <EvanR> where are you suggesting i use such a thing
10:14:24 <EvanR> as the outter most signature?
10:14:37 <zachk> does anyone know how to get the hackage (haskell) package unix*.* to build on mingw/msys ? 
10:15:17 <EvanR> ski: UniGen is State StdGen, wouldnt UniGenT m just be StateT m StdGen
10:15:34 <ski> i was thinking maybe you wanted to use `StateT [i] (UniGenT (ST s)) a' .. but i'm not sure
10:15:50 <ski> quite possibly, yes
10:16:02 <silbo> hey, is it possible to make a case with 3 maybe variables?
10:16:09 <ski> hm
10:16:31 <ski> silbo : how do you mean ?
10:17:20 <silbo> ski: i have 3 maybe Ints and I want to case if everyone is a Just
10:17:31 <EvanR> im guessing delete from a list isnt the best way to carry out c_wraiths algorithm
10:17:44 <EvanR> silbo: all isJust ?
10:17:56 <ski> > sequence [Just 0,Just 1,Just 2]
10:17:57 <lambdabot>   Just [0,1,2]
10:18:01 <ski> > sequence [Just 0,Just 1,Nothing,Just 2]
10:18:03 <lambdabot>   Nothing
10:18:05 <Eduard_Munteanu> zachk: does it work on Wine/Windows?
10:18:07 <silbo> EvanR: means that they have a value and are not Nothing
10:18:10 <EvanR> :t all isJust
10:18:11 <lambdabot> forall a. [Maybe a] -> Bool
10:18:12 <ski> silbo : like that ^ ?
10:18:18 <Eduard_Munteanu> zachk: mingw/msys isn't like Cygwin.
10:18:48 <kosmikus> Eduard_Munteanu: actually, your's is an interesting idea. I'll try and see if I can implement second derivatives for multirec/zipper ...
10:19:07 <EvanR> case sequence [m1,m2,m3] of
10:19:16 <ski> EvanR : instead of deletion, you can adapt the indices, to make sure no index is mentioned more than once .. so you can use an aeeay, e.g.
10:19:21 <Eduard_Munteanu> kosmikus: actually Saizan hinted me to it.
10:19:21 <silbo> ski: ok ill try something like that
10:19:21 <EvanR> if all isJust [m1,m2,m3] then
10:19:28 * hackagebot quicktest 0.1 - A reflective batch tester for Haskell.  http://hackage.haskell.org/package/quicktest-0.1 (DavidSiegel)
10:20:18 <EvanR> ski: adapt? with a fold or something?
10:20:55 <ski> silbo : if you have a list of elements of type `Maybe a', then `sequence' will give you a `Maybe [a]', which will be `Nothing' if any of the original elements was `Nothing'. and `Just elements', if all where of the form `Just element'
10:22:05 <EvanR> seems like a non trivial algorithm
10:22:40 <zachk> i just wanna catch keys in console with no echo and bounce things around the console screen on windows using haskell :( 
10:22:45 <ski> EvanR : consider the case where the number of things to permute is three, then c_wraith's code (well, almost) will generate one of the following possibilities : `[0,0,0]',`[0,1,0]',`[1,0,0]',`[1,1,0]',`[2,0,0]',`[2,1,0]'
10:23:04 <EvanR> yeah
10:23:49 <ski> EvanR : and then you need to transform that into (or instead generate) : `[0,1,2]',`[0,2,1]',`[1,0,2]',`[1,2,0]',`[2,0,1]',`[2,1,0]'
10:24:04 <EvanR> instead generate is easier, with fischer yates
10:24:09 <EvanR> and ST
10:24:12 <silbo> ski: so ill write case (a,b,c) of Just (sequence[a,b,c]) -> ?
10:24:12 <Jafet> zachk: you probably need to use mingw in the msys environment, not cygwin
10:24:25 <zachk> im not touching cygwin 
10:24:30 * zachk has very bad memories of it 
10:24:31 <Jafet> zachk: or just use a goddamn real unix system
10:24:40 <EvanR> case sequence [a,b,c] of
10:24:40 <zachk> i got one 
10:25:30 <Jafet> Controlling a ANSI/VT-style terminal is bad enough business, trying to do it through a unix emulation layer just borders on the silly
10:26:29 <EvanR> zakwilson: use SDL
10:26:38 <EvanR> zachk*
10:27:11 <Jafet> I think DF2 implements its own terminal with SDL
10:28:00 <Eduard_Munteanu> AFAIK, Windows/DOS terminals aren't anything like VT/ANSI.
10:28:45 <Eduard_Munteanu> I think it's more like dumb terminals.
10:29:31 <EvanR> ski: ok. alternatively, these are indexes to swap with as you progress backward along a mutable array
10:29:41 <EvanR> viola
10:30:13 <ddarius> Back in the day there was ansi.sys
10:31:14 <ddarius> A second derivative will yield a two-hole context but one hole will be subordinate to the other.
10:31:31 * hackagebot quicktest 0.1.1 - A reflective batch tester for Haskell.  http://hackage.haskell.org/package/quicktest-0.1.1 (DavidSiegel)
10:32:19 <Eduard_Munteanu> ddarius: yeah I guess it's a PITA to use that.
10:33:12 <ddarius> Not really, it's just not quite the same thing.
10:33:24 <Eduard_Munteanu> So just do first half of the swapping, go to top, follow the context of the other, then do the other half of the swapping?
10:34:44 <ddarius> You'd move the first derivative to one location, create the second derivative at that location and navigate from there to the other location, plug in the value from the first location raising back up to just a first derivative and then plug-in the value from the other location.
10:35:08 <silbo> ski: thank you very much the sequence works fine
10:35:30 <ddarius> The biggest issue is that you can't just leave the second finger somewhere and move it about independently.
10:35:34 <Eduard_Munteanu> ddarius: hm, it doesn't seem to be a win over the first derivative variant. Looks similar.
10:37:08 <ddarius> Eduard_Munteanu: For this particular use-case it might not be very different.  However, some differences are you can make multiple changes to the history/future of the first derivative, and you don't need to move the first derivative, so you could start from this location multiple times.
10:37:40 <Eduard_Munteanu> Ah.
10:41:56 <EvanR> http://codepad.org/e7K4Q5NP
10:42:07 <EvanR> \o/?
10:42:24 <ddarius> The first derivative only version would require you to look up the root of the first subtree and then walk about willy-nilly to do the sway, in purely zipper terms it would be: go down to the first subtree, restart, go down to the second subtree, plug in, walk back up and then down to the first subtree, plug in.
10:42:34 * hackagebot quicktest 0.1.2 - A reflective batch tester for Haskell.  http://hackage.haskell.org/package/quicktest-0.1.2 (DavidSiegel)
10:42:39 <ddarius> With a second derivative approach you don't need that first step.
10:52:01 <c_wraith> EvanR, by the way, there *is* a way to "expose" g without actually exposing it
10:52:56 <c_wraith> rank2 types are pretty fun :)
10:55:48 <Ornedan_> Is anyone here familiar with Code-Image-DevIL? It's complaining about libpthread.so when I try to load the module
11:02:41 <Eduard_Munteanu> ddarius: yeah, I wonder if there's a better way to do this though. I kinda need zippers anyway though, as trees with backlinks.
11:03:30 <Eduard_Munteanu> Maybe some other sort of mutable trees? People have warned me trees with IORefs/STRefs are ugly :)
11:03:49 <Eduard_Munteanu> (well, structurally mutable)
11:04:42 <Eduard_Munteanu> Ornedan_: what error exactly?
11:06:17 <Ornedan_> Loading package Codec-Image-DevIL-0.2.3 ... can't load .so/.DLL for: pthread (/usr/lib/libpthread.so: invalid ELF header)
11:06:23 <jmcarthur> yeah every time i try to write a structurally mutable tree in haskell i end up making something fugly
11:07:11 <Ornedan_> And, yeah. Looks like /usr/lib/libpthread.so indeed is not ELF data, but some linker script(?)
11:10:07 <Ornedan_> Which means it's probably a compiler bug...
11:10:32 <ski> > map (foldr (\i k indices -> let (front,j:back) = splitAt i indices in j : k (front ++ back)) (\[] -> []) `flip` [0,1,2]) [[0,0,0],[0,1,0],[1,0,0],[1,1,0],[2,0,0],[2,1,0]]
11:10:33 <lambdabot>   [[0,1,2],[0,2,1],[1,0,2],[1,2,0],[2,0,1],[2,1,0]]
11:10:50 <roconnor> hi ski
11:10:58 <ski> EvanR : that's a `foldr', yes
11:11:09 <ski> lo roconnor
11:12:08 <Eduard_Munteanu> It probably is. Because of a very similar problem I can't get lambdabot to build on Gentoo.
11:12:45 <ski> EvanR : deletion of elements is there replaced by deletion of indices .. but as you say, possibly one can generate the indices more directly
11:18:21 <EvanR> ski: this is what i got http://codepad.org/1wfGrKvf
11:19:07 <ddarius> Perhaps -pgml will make a difference, but I doubt it.
11:24:34 <ski> EvanR : hm, you could probably get away with half the reads and writes .. if you use a recursive loop
11:27:32 <Ornedan_> Ignoring DevIL... What's the second easiest library for getting at the pixel data from a Targa image?
11:27:34 <ski>   let loop [] = do return (); loop ((i,j):ijs) = do x <- readArray arr i; loop ijs; writeArray arr j x in loop (zip [l-1,l-2 .. 0] ixs)
11:27:37 <ski> something like that
11:29:21 <ddarius> Looks like a bad idea to me.
11:30:33 <ski> m, i'm not sure whether it's any use
11:31:10 <ski> we're effectively putting a list on the stack
11:33:01 <ddarius> "Although one could program warehouse loads with a sequence of SQL insert statements, this tactic is never used in practice."
11:33:03 <ddarius> ski: Indeed.
11:35:24 <ddarius> "and queries that join multiple large tables have a tendency to run 'forever.'"
11:35:36 <ski> (what i'm not sure about is whether this stack has arbitrary limits .. if not, then i expect this to be comparable to reading elements into a list, and then writing off the list elements)
11:37:02 <ddarius> ski: It does.
11:38:33 <ddarius> Even if it didn't, doubling the memory requirements and increasing retention seem silly.
11:51:41 <EvanR> are you guys talking about my shuffle
11:53:37 * ddarius considers actually, conceivably -structuring- his collection of papers (or at least the new additions.)
11:54:10 <elliott> Has anyone written a PEG parser generator for Haskell?
11:54:17 <ddarius> Yes.
11:54:20 <ddarius> See Pappy.
11:54:53 <copumpkin> I bet it doesn't support edwardk's new packrat layout parsing
11:55:04 <ddarius> It is a packrat parser.
11:55:58 <elliott> I wonder how much of it I could reuse if I ported it to do that fancy derivative thing.
11:56:24 <newsham> "conal.net contains content from che.galeaskincare.com, a site known to distribute malware. Your computer might catch a virus if you visit this site."
11:56:27 <newsham> hrmmm
11:56:35 <copumpkin> I meant packrat layout parsing
11:56:38 <copumpkin> layout as in haskell layout
11:57:19 <elliott> newsham: now conal is in your computer! mwahahaha!
11:57:35 <elliott> newsham: soon it will be unable to perform any side-effects
11:57:45 <newsham> except i didnt go to his page after the warning
11:57:53 <elliott> it is already too late
11:58:06 <newsham> man, if only i had teh computer sekuritees
11:58:09 <franka> or ヲー
11:58:12 <elliott> tbh I find those warnings are usually pretty dubious :-P
11:58:18 <copumpkin> franka: you /parted the channel
11:58:37 <c_wraith> EvanR, you around?
11:58:40 <franka> or rather オー
11:58:57 <newsham> franka: wrong channel.
12:01:36 <EvanR> c_wraith: yes
12:02:00 <c_wraith> EvanR, I want to show you a trick involving rank 2 types.  Not that I think you should use it, but it should interest you.
12:04:20 <EvanR> alright
12:04:37 <c_wraith> http://hpaste.org/42541/unigen
12:04:40 <c_wraith> Now I have to go...
12:04:57 <c_wraith> But that's a way to allow functions to use the RandomGen without exposing the internals.
12:04:58 <c_wraith> anyway, bye
12:06:36 <elliott> why would anyone use rank 2 types when we have rank 3 types!
12:06:57 <Eduard_Munteanu> Inference? :)
12:06:58 <ddarius> Because 2 is the smallest prime.
12:08:12 <elliott> rank 7 types then
12:08:17 <elliott> 7 is also a nice number
12:08:28 <elliott> it has many advantages, such as making types look nice when prettyprinted
12:08:32 <elliott> from a few meters away
12:08:50 <dankna> lol
12:09:03 <lispy_> 2 is a magical prime.  How many primes are even afterall?
12:09:45 <c3l> 2 is cheating
12:09:45 <dankna> even is just a special case of "divisible by n", and EVERY prime is the unique prime divisible by some n :)
12:10:50 <lispy_> dankna: except 4
12:11:05 <dankna> 4 isn't a prime
12:11:19 <tonkman> any good tutorial about Reader monad?
12:12:55 <lispy_> dankna: yeah.  It's true of any composite, but I seem to be talking about special cases today :)
12:13:09 <dankna> oh haha
12:13:28 <lispy_> tonkman: Hm...the all about monads site is good
12:14:01 <lispy_> Unfortunately it's gone :(
12:14:09 <lispy_> http://www.nomaware.com/monads/html/  <-- no longer the right site
12:14:21 <tonkman> :(
12:15:11 <lispy_> and this hasn't been written yet: http://en.wikibooks.org/w/index.php?title=Haskell/Understanding_monads/Reader&action=edit&redlink=1
12:15:24 <elliott> tonkman: the reader monad is just the (->) monad wrapped in a newtype
12:15:26 <elliott> GLAD I COULD HELP
12:15:48 <Eduard_Munteanu> Heh.
12:16:10 <tonkman> Im quite new with haskell, so I would appreciate some tutorial :D
12:16:24 <Eduard_Munteanu> @where lyah
12:16:25 <lambdabot> http://www.learnyouahaskell.com/
12:16:28 <Eduard_Munteanu> @where rwh
12:16:28 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
12:16:38 <lispy_> tonkman: this looks decent, but I've not read it throughly: http://www.maztravel.com/haskell/readerMonad.html
12:16:51 <tonkman> ok, thanks
12:17:03 <lispy_> tonkman: the reader monad provides you with an "environment" in which you can lookup something
12:17:10 <lispy_> tonkman: it's like a read-only state monad
12:17:12 <elliott> someone should mix chapters of LYAH and RWH together and turn it into Learn You A Real-World Haskell :)
12:17:54 <lispy_> tonkman: It's great when you're writing a compiler and you need to implement scoped symbol tables
12:18:26 <lispy_> tonkman: as you enter a new scope, you extend the environment and when you leave the scope you can go back to the previous environment
12:18:35 <tonkman> ok
12:18:54 <lispy_> tonkman: one of the most confusing instances for Reader is the function instance
12:19:05 <lispy_> I'd save that instance for last
12:19:19 <lispy_> it looks like, instance Reader ((->) r) where ...
12:20:27 <lispy_> tonkman: this example should help, it follows the symbol table example: http://hackage.haskell.org/packages/archive/mtl/2.0.1.0/doc/html/Control-Monad-Reader.html#g:4
12:23:07 <lispy_> tonkman: the monad that is dual to Reader is Writer.  Writer is like a write only version of State.  Then of course State is a mix of Reader and Writer.  In this family, we have more important one.  RWST, and that's Reader + Write + State, all in one monad.  Uses of that are more advanced, but xmonad uses it to separate things that are implicit from things that are write only and to also separate out the state that you update.
12:23:36 <lispy_> Writer examples often talk about appending a string together, for example for logging or tracing
12:24:15 <tonkman> ok, that example helped a lot
12:26:04 <ddarius> Writer (as a functor) is the left adjoint to Reader and the induced monad is State.
12:28:20 <c3l> 0'
12:28:25 <c3l> 9~9^
12:35:02 <ddarius> Jim Gray's "Greetings! From a file system user" is interesting.
12:35:05 * hackagebot GoogleDirections 0.3.0.1 - Haskell Interface to Google Directions API  http://hackage.haskell.org/package/GoogleDirections-0.3.0.1 (KevinOberlies)
12:38:47 <gio123> ski
12:39:58 <dankna> ddarius: got a link to that?  sounds useful
12:41:29 <ddarius> research.microsoft.com/en-us/um/people/gray/talks/Fast_2005.ppt or www.usenix.org/events/fast05/tech/gray.pdf
12:41:46 <dankna> thanks!
12:49:45 <rovar> can someone point me to a simple function :  [Word8] -> CompactString?   so far I can't find any straightforward way in hoogle/hackage
12:51:51 * ddarius needs to install a tag-based virtual file system.
12:52:59 <dankna> we've had that conversation before, haven't we
12:55:17 <roconnor> @hoogle sequence
12:55:17 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
12:55:17 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
12:55:18 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
12:55:29 <roconnor> @hoogle sequenceA
12:55:29 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
12:55:29 <lambdabot> Data.Foldable sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
12:57:48 <roconnor> @hoogle traverseA
12:57:48 <lambdabot> No results found
12:57:52 <roconnor> @hoogle traverse
12:57:52 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
12:57:52 <lambdabot> Data.Foldable traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
13:00:32 <RayNbow> > (let (x@[]) = [1] in x)
13:00:33 <lambdabot>   *Exception: <interactive>:1:142-153: Irrefutable pattern failed for pattern...
13:01:20 <RayNbow> ^ how does Haskell's type system deal with this? Is it considered as just another _|_?
13:01:20 <rovar> dankna, I did map (fromEnum . toEnum) 
13:01:24 <rovar> but that just seems silly
13:01:32 <rovar> I hope it gets optimized out
13:02:28 <ezyang> @seen glguy 
13:02:28 <preflex>  glguy was last seen on #haskell 80 days, 13 hours, 40 minutes and 58 seconds ago, saying: Monoid is for things with kind * (mempty), MonadPlus is for things with kind * -> * (mzero)
13:02:28 <lambdabot> Unknown command, try @list
13:04:15 <ddarius> "But in practice, /throughput in a well-tuned transaction processing DBMS is typically not I/O-bound/." (emphasis original)
13:06:25 <Auxentiu> Man.I dont get this
13:06:32 <Auxentiu> its just gibborish
13:07:20 <monochrom> RayNbow: yes, it's bottom
13:08:15 <dolio> ezyang: By the way, if you want my support of your puns, you have to make them more like AC/DC song titles.
13:08:26 <dolio> Shoot to Thrill.
13:08:28 <dolio> That kind of thing.
13:09:18 <Blkt> merry christmas everyone
13:09:30 <Eduard_Munteanu> Merry xmas to you as well.
13:10:25 <ddarius> RayNbow: _|_ is orthogonal to typing.
13:10:42 <ddarius> x :: Num n => [n] as you would expect it to
13:11:22 <Eduard_Munteanu> What, Auxentiu?
13:11:44 <monochrom> fun, there is a haskell indentation plugin for gedit too
13:13:48 <ezyang> dolio: :-P 
13:13:48 <lambdabot> ezyang: You have 1 new message. '/msg lambdabot @messages' to read it.
13:16:04 <orbital_fox> is it worthwhile installing the latest python over the one that comes with Leopard stock?
13:17:24 <ddarius> orbital_fox: No, you should uninstall python entirely.
13:18:28 <revenantphx> orbital_fox: I have the built in one as well as 3.2 I believe.
13:18:38 <revenantphx> Unless you need 3.0+ stuff, there's no real need.
13:19:46 <orbital_fox> well
13:20:06 <orbital_fox> im trying to install numpy and matplotlib using the images they provide on their websites
13:20:26 <orbital_fox> wont do it thought cause it complains it cant find python on that drive
13:20:56 <ddarius> orbital_fox: Why are you asking here?
13:21:37 <orbital_fox> its the "most related" channel im currently in
13:22:25 <sheaf> how does fmap work, why doesn't it also take a functor as input? how does it know what functor I mean?
13:22:25 <monochrom> who did the assessmen of most-related?
13:22:39 <monochrom> s/assessmen/assessment/
13:22:47 <orbital_fox> revenantphx how do you go on about installing python libs? images from their websites? homebrew? other way?
13:23:02 <monochrom> type inference or type annotation specifies which functor
13:23:10 <ddarius> orbital_fox: Go to #python.
13:23:17 <monochrom> > fmap id [True,True]
13:23:18 <lambdabot>   [True,True]
13:23:28 <rovar> :t (,)
13:23:28 <lambdabot> forall a b. a -> b -> (a, b)
13:23:35 <monochrom> this chooses []'s functor instance because [] is involved
13:23:38 <revenantphx> orbital_fox: yeah, this isn't the channel
13:24:26 <sheaf> so I'm not allowed to talk about fmap id on its own then?
13:24:37 <ddarius> :t fmap id
13:24:38 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f a
13:25:00 <monochrom> fmap id alone is valid. it just still leaves open which functor is used. this leaving open is also valid.
13:25:22 <sheaf> fair enough, ok, thanks
13:25:33 <monochrom> hell, fmap alone has always been valid all along :)
13:26:57 <orbital_fox> ddarius, revenantphx im actually really sorry i was in the wrong tap, i  had machomebrew selected... i was beginning to get annoyed for a second, untill i saw someone asking for haskell types
13:27:08 <orbital_fox> s/tap/tab
13:29:18 * hackagebot pandoc-types 1.7 - Types for representing a structured document  http://hackage.haskell.org/package/pandoc-types-1.7 (JohnMacFarlane)
13:57:57 <revenantphx> merry christmas~
13:58:32 <latros> ko ji'a se pluka lo xisyjbenunsla doi la'oi revenantphx
14:00:23 <revenantphx> "We are not yet able to translate from Occitan into English."
14:00:24 <revenantphx> DARN IT.
14:00:43 <conal_> newsham: ping
14:01:34 <ddarius> "In practice, however, the simple story above is complicated by the need for extreme performance."
14:02:18 <newsham> hi
14:02:43 <newsham> conal: I got that in chrome when i went ot your page, but during several reloads it didnt happen again
14:03:44 <newsham> perhaps brought in by some 3rd party ad or stats tracker thing?
14:03:44 <conal_> newsham: thx. main page?
14:03:50 <newsham> conal.net/blog
14:04:00 <conal_> ah, thx!
14:04:39 <newsham> np
14:04:52 <conal_> newsham: could be. i'll install chrome and check it out when i'm in civilization next.
14:06:02 <elitheeli> I want to give a number of functions access to a certain variable, and I know that I only need external access to one function. One conceivable way to do it would be to define all of the functions in a where clause of the one I need external access to. But this kinda seems like something a module or something else nifty could handle for me. How do I do this right?
14:06:32 <rovar> what do you mean by access?
14:07:29 <remy_o> elitheeli: what is a variable ? 
14:07:51 <rovar> another good question.. i hadn't gotten that far yet :)
14:08:10 <elitheeli> oy, too much Ruby lately, not enough Haskell. Apologies for bad wording.
14:08:20 <newsham> elitheeli: your module can specify which symbols are exported, the rest being for internal use
14:08:21 <rovar> in general,   functions map   input values to output values
14:09:04 <rovar> but I think you want to define several functions within the scope of a variable.. so that it is "global" to them, yes? 
14:09:05 <remy_o> elitheeli: if various functions need a value, then set this value as a global constant in your file
14:09:15 <elitheeli> so let's say I have "foo x y z = x * y + z" and "bar x y z = x + y * z", and I know ahead of time that I want the same x for them. I could do something like "baz x = (foo 14 7) + (bar 99 0) where foo = ...\n bar = ..."
14:09:39 <elitheeli> rovar: correct
14:10:09 <remy_o> elitheeli: if x appears twice in an expression, Haskell will evaluate only once
14:10:49 <elitheeli> remy_o: I know that. But if I have a dozen functions which all take x as the first argument, I was just trying to find a way to eliminate the need to write it there and somehow have them get it through a closure or something
14:11:11 <remy_o> elitheeli: you are allowed to write "foo y z = x + y * z" in your example
14:11:25 <elitheeli> I want that.
14:12:00 <elitheeli> but there are a ton of functions, is the best way to do it to put them in a where clause?
14:12:14 <monadic_kid> elitheeli: define tons
14:12:20 <elitheeli> like 150,000
14:12:23 <elitheeli> I mean like 15
14:12:28 <listofoptions> do statements
14:13:03 <listofoptions> as in do x <-....
14:13:08 <monadic_kid> elitheeli: and they are all utility funcitons for one function? you don't need them anywhere else
14:13:15 <elitheeli> correct
14:13:47 <elitheeli> it's actually a couple dozen functions spanning a couple hundred lines of code
14:14:04 <rovar> you could do a big let ... where ...    and you define your "global x" in the where clause.. and the rest of your functions in your let block
14:14:17 <remy_o> elitheeli: so they are just intermediate steps of a computation, so yes that's the way to do it
14:14:19 <newsham> eli: put them all in one file as top-level functions.  then in the module header at the top of the file specify which ones you want to export
14:14:31 <rovar> e.g.    let  foo y z =  x + y * z  ;  bar y z = x * y + z  where x = 22
14:14:58 <elitheeli> newsham: that doesn't solve the magic "x" argument I want there
14:15:28 <newsham> ahh, I missed that part.
14:15:44 <newsham> where or let is prob what you want. *shrug*
14:15:57 <monadic_kid> elitheeli: You can hide x by using reader monad but you wont gain much out of doing that really
14:16:11 <elitheeli> rovar: that needs to be in the scope of some other function, though, right? So at the top of my file I write "doIt x = let" and then at the bottom I do "in somethingOrOther"?
14:16:13 <monadic_kid> elitheeli: there are also implicit parameters
14:16:22 <remy_o> elitheeli: having extra arguments in 15 global unctions only wastes 30 bytes of source code
14:16:32 <elitheeli> remy_o: that's true
14:16:47 <remy_o> it would make the code clearer
14:16:58 <elitheeli> remy_o: it also wastes bytes when I call the functions, too, though....
14:17:23 <remy_o> elitheeli: I think the optimizations make the situation a bit more subtle
14:17:38 <elitheeli> it also muddles the source code with passing around tons of stuff
14:17:48 <remy_o> that is true
14:17:48 <monadic_kid> elitheeli: you do understand closure isn't free either
14:18:32 <elitheeli> monadic_kid: I'm going for beauty over efficiency here.
14:18:57 <monadic_kid> elitheeli: so why mentioning "wastes bytes"
14:19:26 <elitheeli> remy_o brought it up
14:19:54 <remy_o> I was talking about bytes of source code
14:20:37 <elitheeli> me too
14:21:57 <elitheeli> anyway, it seems like there's something "wrong" if functions are passing around tons of data that they don't use but just pass to functions that they call
14:22:41 <latros> if they pass it to functions that they call, then they use it
14:22:47 <latros> (hi everyone, by the way)
14:22:50 <listofoptions> elitheeli: isn't that cps?
14:23:17 <monadic_kid> elitheeli: I don't see the big deal of a having a number of local functions in where clause that is the best you can do if you want capture bindings from an outer scope, you can mix up with some module level private functions. I think you're just making a big deal over nothing
14:24:06 <elitheeli> I tend to do that. Thanks for the advice, monadic_kid 
14:25:06 <monadic_kid> elitheeli: i think that is what most people tend to do naturally
14:26:08 <monadic_kid> listofoptions: he/she didn't saying functions taking functions that continue
14:26:24 <listofoptions> ohh 
14:27:21 <ddarius> elitheeli: If the x is a parameter that can vary, then a where clause approach like you originally described is probably your best bet or just passing the parameter to all of them.
14:28:22 <monadic_kid> ddarius: or a mix of both :)
14:29:39 <elitheeli> thanks, I guess it makes sense. On an unrelated note, I'm using "Debug.Trace" to debug stuff, but laziness is causing things to be printed out in a strange order. Any quick way to make it preserve order while debugging?
14:29:53 <ddarius> elitheeli: No.
14:30:08 <elitheeli> k, thanks ddarius 
14:30:22 <ddarius> (What "order" would it preserve anyway?)
14:30:25 <revenantphx> ...Enumerators... Enumeratees... and Iteratees...
14:30:30 <revenantphx> where are the Iterators?
14:30:50 <revenantphx> Whats the rational behind the naming anyways? I kind of get it, but not entirely.
14:31:10 <elliott> <elitheeli> anyway, it seems like there's something "wrong" if functions are passing around tons of data that they don't use but just pass to functions that they call
14:31:12 <elliott> electrogeek: reader monad
14:31:24 <elliott> revenantphx: your code is the iterator
14:31:26 <elliott> erm
14:31:29 <elliott> elitheeli: reader monad
14:31:52 <monadic_kid> elliott: it's not exactly what he/she wants
14:32:03 <elliott> close enough :P
14:33:31 <monadic_kid> elliott: using a reader monad you've made parameter disapear from a function argument but you'll you'll be using "ask" so for what he/she wants it doesn't gain you anything
14:33:52 <elliott> monadic_kid: well, true. you'd probably want foo' and bar' that get their first param from the monad
14:35:31 <ddarius> monadic_kid: But you'd only be using ask when you actually needed to deal with the parameter.
14:35:55 <ddarius> monadic_kid: However, the overhead of writing in monadic style would be very much not worth it unless the code is already in monadic style.
14:36:03 <monadic_kid> ddarius: from the sound of things he's using it almost in every function, he already started using where clause
14:36:20 <monadic_kid> ddarius: that captures a binding
14:37:31 <ddarius> monadic_kid: The where clause is the best bet for the situation he describes, but the Reader monad comment was in response to:<elitheeli> anyway, it seems like there's something "wrong" if functions are passing around tons of data that they don't use but just pass to functions that they call
14:37:46 <ddarius> Which the Reader monad effectively hides.
14:38:16 <elitheeli> makes sense to me.
14:38:21 <elitheeli> thanks, guys/gals
14:39:08 <monadic_kid> ddarius: after reading it fews times I got it
14:39:50 <elliott> WAIT!
14:40:00 <elliott> I know what to do!
14:40:09 <elliott> IMPLICIT PARAMETERS ^_____^
14:40:14 * elliott is mauled
14:40:51 <ddarius> elliott: One could also declare a global variable and mutate it upon entry and restore it upon exit.  'seems to work for the C programmers.
14:41:08 <elliott> ddarius: Use setenv.
14:41:28 <elliott> ddarius: (If you need to store a more complex value, serialise it. As JSON.)
14:41:31 <elliott> Or XML.
14:41:35 <elliott> And store it in the environment.
14:41:40 <elitheeli> oh god.
14:42:10 <elliott> elitheeli: You just can't appreciate ... my genius ...
14:43:03 <elitheeli> How about I use S-expressions and then write a lisp interpretter in Haskell to restore my data? That'd totally make sense, right?
14:43:20 <latros> why not just write a turing machine and code in that
14:43:26 <ddarius> Clearly the correct thing to do for the modern age is to make a SOAP based web service that will provide the parameter over the internet.
14:43:27 <latros> generalize all the way bitches
14:43:37 <latros> or hell, what's that combinator scheme, SKU or something
14:43:44 <elitheeli> SKIBC
14:43:49 <latros> no, it's only 3 combinators
14:43:53 <elitheeli> SKI are the 3 needed
14:44:01 <elitheeli> B and C make it much, much more compact
14:44:05 <latros> I think at some point I saw a weird composition of SKI
14:44:07 <latros> into one combinator U
14:44:18 <latros> though the parens in that scheme are so bizarre that they count as their own damn combinators
14:44:56 <ddarius> I is not needed.
14:45:17 <latros> I should clarify, this one combinator was sufficient
14:45:36 <latros> a one combinator language that's turing complete >.>
14:45:42 <elitheeli> oh yeah, I saw that a while ago
14:45:58 <ion> “I should clarify”
14:46:05 <latros> yes yes, puns
14:46:12 <ddarius> latros: The only one combinator bases I've seen don't actually use one -combinator-, they use pseudo-combinators.
14:46:26 <elitheeli> X
14:46:33 <latros> eh, semantics; with just one symbol, which has one meaning
14:46:36 <latros> and parentheses
14:46:40 <Eduard_Munteanu> Don't implicit params kinda suck?
14:46:43 <latros> they got turing completeness
14:47:04 <Eduard_Munteanu> I had that impression.
14:47:11 <ddarius> Jeroen Fokker's "The Systematic Construction of a One-combinator Basis for Lambda-Terms" is a pleasant and short read.
14:47:26 <ddarius> latros: There are a lot of ways to do that.
14:48:43 <elitheeli> wow, that is a short read
14:49:53 <revenantphx> Hey guys, I came up with an amazing solution to mutable variables!
14:50:11 <monadic_kid> what was the problem?
14:50:29 <revenantphx> What you do is you have a C program hold your variables in a map of sorts, and then when it receives strings over TCP, it returns said variable...
14:50:42 <revenantphx> And then on the haskell side, you just use unsafePerformIO.
14:50:49 <revenantphx> Isn't that such a great idea?
14:50:51 * revenantphx troll.
14:50:58 <latros> reminds me of unsafeCoerce
14:51:08 <ddarius> My bread only has an internal temperature of 200 degrees Fahrenheit.
14:53:13 <elitheeli> ddarius: thanks for the suggestion on that Fokker article, it's pretty neat
14:54:19 <ddarius> revenantphx: That's called a relational database.  You were scooped by about five decades.
14:54:30 <revenantphx> ddarius: :P
14:54:38 <revenantphx> STORE ALL VARIABLES IN SQLITE
14:54:45 <revenantphx> HASKELL IS NOW FIXED
14:56:12 <ddarius> Admittedly, neither C nor TCP are five decades old.
14:57:36 * Eduard_Munteanu waits for an unsafePerformOI
14:58:02 <Eduard_Munteanu> unsafePerformOI :: a -> OI a
14:58:58 <Eduard_Munteanu> (though OI is pretty unsafe by itself :P)
14:59:38 <aristid> Eduard_Munteanu: safePerformOI :)
14:59:55 <rovar> prefromOI
15:01:56 <Eduard_Munteanu> Heh, that's a point, aristid.
15:02:10 <elitheeli> ddarius: how is it relational if it's just a map?
15:04:46 <monadic_kid> arggh this the thing about jhc that is annoying, with hierarchical modules you can import defintiions just by importing some parent module name, it has to be fully qualified path to the module of which the definition came from
15:05:10 <monadic_kid> i mean you can't import definitions
15:05:35 <ddarius> elitheeli: It's a trivial case of relational.
15:07:16 <ddarius> monadic_kid: That's not JHC specific behavior.  The (not officially ratified) heirarchical module addendum only changes Haskell 98 by allowing . in module names.  Which is to say, there is no heirarchical structure.
15:09:58 <monadic_kid> ddarius: so being able to import definitions from grand-children is another extension in ghc?
15:11:58 <ddarius> GHC has no extensions for imports or the module system.
15:12:32 <ddarius> There are no "grand-children."  There is no heirarchical structure.  Data.Bar is completely unrelated to Data.Bar.Foo
15:14:22 <monadic_kid> ddarius: with ghc I can write import Graphics.UI.SDL which allows me to use definitions from sub modules like Graphics.UI.SDL.Video
15:14:38 <ddarius> monadic_kid: Look at the source to Graphics.UI.SDL.
15:14:49 <ddarius> And then look at the Haskell 98/2010 Report.
15:15:09 <ddarius> Again, there are no "submodules."
15:15:28 <ddarius> Graphics.UI.SDL could just as well reexport Data.Text.
15:15:44 <monadic_kid> ddarius: i can't find a source for Graphics.UI.SDL
15:15:53 <ddarius> @source Graphics.UI.SDL
15:15:53 <lambdabot> Graphics.UI.SDL not available
15:16:15 <ddarius> http://hackage.haskell.org/packages/archive/SDL/0.6.2/doc/html/src/Graphics-UI-SDL.html
15:16:38 <monadic_kid> ddarius: ok
15:16:58 <monadic_kid> ddarius: but this doesn't work jhc
15:17:06 <monadic_kid> ddarius: *work in jhc
15:18:47 <monadic_kid> ddarius: so i guess that means jhc doesn't support re-exporting modules in the export list
15:19:44 <ddarius> monadic_kid: I guess.  If so, then that is a bug in jhc.  Re-exporting modules is Haskell 98/2010.
15:20:15 <ddarius> See section 5.2 #5 here: http://haskell.org/onlinereport/modules.html
15:21:04 <monadic_kid> ddarius: yeah I do remember this sometime ago
15:22:11 <lispy_> Oh yeah, John said that JHC doesn't support it yet
15:22:17 <lispy_> He said so on Haskell-Cafe
15:23:45 <monadic_kid> there is something weird going on with multiple foreign pointers in the same scope (coming from binding functions) in jhc as well, I need to write a bug report about it.
15:23:46 <ddarius> lispy_: So now I have like two dozen more papers to read from that one paper (and I'm not quite finished with it yet.)
15:23:57 <lispy_> IIRC, he said so in this thread: http://osdir.com/ml/haskell-cafe@haskell.org/2010-07/msg00708.html
15:24:03 <lispy_> ddarius: hah
15:25:03 <ddarius> I mentioned this earlier, you may find it interesting: [15:41] <ddarius> research.microsoft.com/en-us/um/people/gray/talks/Fast_2005.ppt or www.usenix.org/events/fast05/tech/gray.pdf
15:28:26 <ddarius> lispy_: Google Maps says I can drive from Boston to Portland in 2 days and 1 hour (assuming I don't eat, sleep, or go to the bathroom, but that I go the speed that Google thinks I should go.)
15:29:08 <lispy_> ddarius: that sounds like a painful drive
15:30:38 <ddarius> lispy_: Well I have about 9 days for the whole round trip, so it wouldn't be that bad.  However, I've been thinking about going to the Grand Canyon and maybe Yosemite, then up to the redwood forests then back.
15:31:02 <lispy_> oh, I love the redwoods
15:31:25 <djahandarie> I've never really seen the appeal of sightseeing
15:31:27 <lispy_> ddarius: when is your trip?
15:31:38 <lispy_> djahandarie: double rainbow!
15:32:07 <lispy_> 1.3 days to read a 10TB drive??
15:32:09 <lispy_> Really??
15:32:36 <ddarius> lispy_: Sequentially no less.
15:32:49 <lispy_> Yeah, I kind of wonder about his calculation
15:32:57 <lispy_> I'd like to know what assumptions the author made
15:33:03 <ddarius> lispy_: If I do this, my trip would start as soon as possible, i.e. tomorrow, maybe tonight.
15:33:13 <ddarius> lispy_: You can easily calculate it from disk speeds.
15:33:41 <lispy_> ddarius: Would you be in portland for a mini-hack-a-thon :)  If dons is in town he would probably join us.
15:33:42 <ddarius> Note that that's the speed to read 10TB from a single drive, not 10TB of data.
15:34:08 <lispy_> He said something about leaving town and I forgot which days
15:34:31 <lispy_> (Portland is about 5-6 hours north of Redwoods)
15:35:29 <fmapE> I'm trying to build the darcs version of the haskell platform
15:35:38 <fmapE> but I'm slightly confused
15:35:50 <ezyang> ddarius: Ooh, nice! 
15:36:25 <fmapE> the configure script seems to require (working from memory here) a platform.packages file
15:36:29 <lispy_> ddarius: have you see the statistics on CMS and Atlas about how much raw data the detector generates before they apply compression (they have a lot of zeros they can compress)
15:36:35 <fmapE> in addition to the core.packages file
15:36:43 <fmapE> but only core.packages is in the repository
15:36:47 <lispy_> ddarius: 40 million collisions / second, at like 1kb each?  Something likje that
15:38:27 <lispy_> ddarius: They can only do a cursory scan of the data as it's collected.  That happens at Tier 0, then they ship it off to Tier 1 where they run high throughput computations to "reconstruct" the events.  Then at Tier 2-3 (universities and end-researchers) they actually go over the results of that.  It's crazy how much data they hav.
15:38:56 <ddarius> 1.6 Gbit/s is 0.2 GB/s which is 50,000 seconds for 10TB divide by 3600 seconds an hour and you get about 13 hours.
15:39:05 <aristid> lispy_: so they actually throw away most of the data at tier 0?
15:39:41 <ddarius> The 1.6 Gbit/s is from wikipedia for -burst- sequential media reads for enterprise grade hard disks.
15:39:55 <ddarius> The sustained, it says, is 1 Gbit/s.
15:40:44 <ddarius> So you are looking at on the order of a day to copy 10TB with high-end (not SSD) modern hardware.
15:40:47 <lispy_> aristid: they compress it
15:41:25 <ddarius> lispy_: Yeah, there are a lot of scientific/intelligence data sources that produce data -way- faster than we can process it, e.g. imaging satellites.
15:41:41 <ddarius> lispy_: Did you get to the "Guru Gap" slide.  I found that hilarious.
15:41:56 <aristid> lispy_: lossy compression?
15:42:14 <lispy_> ddarius: I saw it, but I didn't get what they are saying
15:42:36 <lispy_> aristid: I don't think so.  I'm pretty sure RLE would work
15:42:46 <aristid> lispy_: hmm
15:42:49 <lispy_> aristid: They just need to eliminate all the zeros
15:43:23 <ddarius> lispy_: Well the first take-away is that they could get 40 Gbit/s half-way across the country but not even 10MBps rack to rack (or perhaps less.)  Clearly due to poor configuration.
15:43:54 <aristid> ddarius: huh? that must be an extremely bad configuration
15:44:00 <aristid> where is that?
15:44:52 <ddarius> I'm pretty sure that wasn't raw copying disk to disk, but still, it had to have been bad.  They improved it by orders of magnitude fairly quickly.
15:44:56 <lispy_> ddarius: aah
16:00:06 <rovar> so there seems to be a  ghc -> jvm path now
16:00:56 <rovar> now that we can compile into llvm..   but I'm wondering how one might represent function calls into symbols which don't exist until the .classes get compile
16:01:41 <rovar> d
16:02:08 <Ilum> I'm inexplicably getting a "getAddrInfo: does not exist" error.
16:02:13 <monadic_kid> rovar: are you trying to get haskell on android?
16:02:21 <rovar> monadic_kid, yep
16:02:34 <rovar> via legitimate means, not via rooting :)
16:02:41 <lispy_> rovar: there is quite a bit of work in this area already.  See lambdavm and google for "Simon Peyton Jones jvm Haskell"
16:02:49 <monadic_kid> rovar: you know there is an easier route now with android 2.3
16:03:11 <aristid> monadic_kid: there is?
16:03:19 <monadic_kid> rovar: android 2.3 supports full native apps now, no need to go through jvm
16:03:43 <rovar> neato
16:04:17 <monadic_kid> rovar: but you sttill an unregistered port of ghc to use android's gcc port, and some ffi
16:05:00 <monadic_kid> rovar: but least no need to go through java
16:05:07 <rovar> that's a huge plus
16:05:08 <monadic_kid> rovar: and jni is horrid
16:05:54 <aristid> monadic_kid: so they expose their APIs to C now?
16:06:49 <ezyang> Hey guys, is there any reason why the MVar docs don't state that stuff like readMVar aren't atomic? 
16:07:59 <monadic_kid> aristid: they did a bit with before with older version of ndk but since android 2.3 they've been pushing ndk with better API support, support for writing native activities, native resource manager, etc. I think they are trying to entice more serious games for android, i mean they even said it was done on game develoiper requests
16:08:23 <monadic_kid> *developers
16:08:41 <monadic_kid> aristid: so yeah they got more native apis now
16:09:21 <copumpkin> ezyang: I was wondering where you found a darcs repo of hoopl since the only one I could find was git
16:09:27 <copumpkin> ezyang: or did you darcsify it yourself?
16:09:35 <ezyang> copumpkin: hoopl is... kind of special. 
16:09:40 <copumpkin> :O
16:09:58 <ezyang> So, in order to integrate it with darcs-all, since it's now in the base libraries set 
16:10:08 <ezyang> they mechanically darcs-ified the repo 
16:10:21 <ezyang> and so if you use darcs-all to grab stuff, that's where hoopl comes from 
16:11:11 <lispy_> what is hoopl again?
16:11:18 * lispy_ has a terrible memory
16:11:38 <monadic_kid> aristid: check this video to see what I mean: http://android-developers.blogspot.com/2010/12/android-23-platform-and-updated-sdk.html
16:11:39 <lispy_> oh, n/m
16:11:39 <ezyang> dataflow optimization library 
16:11:46 <lispy_> looks cool
16:11:49 <lispy_> Does it make GHC faster?
16:11:53 <lispy_> Like, noticably?
16:12:02 * ddarius wouldn't mind applying hoopl (or at least the ideas behind it) to query optimization.
16:12:36 <lispy_> I wouldn't mind applying some of it to code.haskell.org too :)
16:12:47 <aristid> monadic_kid: thanks for the link
16:12:50 * lispy_ has decided to move his projects away from those servers till they are more robust
16:13:17 <lispy_> I'm currently thinking about using some combination of github/patch-tag/darcsden
16:13:30 <aristid> monadic_kid: i wish android versions would propagate faster through devices
16:13:31 <lispy_> Not that I have any git repos....
16:13:52 <lispy_> aristid: yeah, my phone is still 2.1, and it makes me grumpy
16:13:53 <djahandarie> I wonder whatever happened to that grad student who presented his thing at boston haskell
16:14:02 <djahandarie> I don't really remember any details but I remember it was pretty cool
16:14:14 <djahandarie> Some way of optimizing queries but then making it more general
16:14:22 <aristid> lispy_: mine too :(
16:14:31 <aristid> damn you htc
16:14:33 <djahandarie> edwardk would remember but he isn't here
16:14:45 <monadic_kid> aristid: I heard this is going to get partially sorted in android 3, instead of updates going through network providers before going to handsets, updates will go out straight from google well i hope so
16:14:46 <copumpkin> ezyang: so is the git repo deprecated now?
16:14:47 <ddarius> djahandarie: It was about applying ideas from the theory of monads to query optimization, and presumably he is still toiling away at it.
16:14:48 * lispy_ runs to the store
16:15:06 <ezyang> copumpkin: No, I think it's still the real one. 
16:15:11 <djahandarie> ddarius, ah. You were there for that? I thought you walked in late
16:15:11 <copumpkin> ah
16:15:15 <ezyang> because spj and ramsey told me to move the patch over 
16:15:30 <copumpkin> so if I submit patches I should do it through git
16:15:34 <ezyang> and being on vacation, I haven't worked up the inclination to do it 
16:15:36 <ezyang> yep 
16:15:41 <copumpkin> I see
16:15:45 <aristid> monadic_kid: looking forward to it
16:16:03 <copumpkin> I was thinking of submitting some docs as a way to actually get familiar with the library
16:16:07 <copumpkin> as well as doing them a service
16:16:27 <ezyang> What do you know: I'm doing that right now for a different library :-) 
16:16:33 <copumpkin> oh, which one?
16:16:42 <ezyang> Orc. I've been planning on doing it for a while. 
16:16:47 <monadic_kid> rovar: so what have you been doing already so far?
16:16:48 <copumpkin> what's orc?
16:17:01 <ezyang> and it became relevant again, because I think Conal's unamb library wants the hierarchical thread abstraction 
16:17:11 <ezyang> A sort of concurrency DSL 
16:17:17 <ddarius> djahandarie: I did walk in late, but like five or ten minutes late, not an hour late.
16:17:36 <lispy_> ezyang: John L. did a talk or three about Orc before you got to Galois
16:17:44 <lispy_> ezyang: Sadly, I don't know where the slides are at the moment
16:17:48 <ezyang> Yeah. I think I was around for one of them 
16:17:52 <lispy_> ezyang: You might fire him an email
16:18:03 <ezyang> I dug up the draft PDF and am basically copy pasting relevant bits into Haddock comments. 
16:18:06 <ezyang> Yeah. 
16:18:09 <lispy_> cool
16:18:11 * lispy_ leaves for real
16:18:15 <ezyang> bye bye 
16:20:31 <rovar> monadic_kid, I was just conceptualizing using  llvjm to convert from llvm intermediate to jvm, then jvm to dalvek
16:20:45 <rovar> haven't actually built anything yet.. don't actually have anything to build
16:21:21 <ezyang> Anyway, anyone know about the MVar thing? 
16:21:28 <ezyang> Maybe I should write mail to haskell-cafe complaining 
16:22:06 <ddarius> ezyang: You shouldn't assume that they are atomic if they don't state that they are.
16:22:11 <ddarius> But it is mildly upsetting.
16:22:53 <ezyang> Well, the offputting part is that swapMVar states that it's racy, but none of the other ones say so. 
16:23:22 <benmachine> yeah that's annoying
16:23:30 <benmachine> but the docs do exlpicitly say it is a combination of take and put
16:23:46 <ezyang> And then, even further down, with modifyMVar 
16:23:56 <ezyang> it claims that it's "safe", but this safety guarantee is w.r.t. async exceptions, not racing 
16:24:07 <monadic_kid> rovar: there was one guy one here who said he/she already had an uregistered port of ghc on the android ndk going (this was before android 2.3 so you'd have native apis missing then), i think his/her name is kmc or something. It can be even easier with jhc which cuts out the need to build an unregistered port (which I found to be painful without a decent conforming posix platform) but jhc lacks a number of extensions compared to jhc and is 
16:24:08 <monadic_kid> less stable.
16:24:54 <monadic_kid> rovar: *but jhc lacks a number of extensions compared to ghc and is less stable.
16:26:35 <monadic_kid> nhc is an options as well, it's been updated recently and is quite portable apparently
16:26:49 <monadic_kid> but haskell98 only i believe
16:28:24 <ddarius> It has a few extensions.
16:29:05 <monadic_kid> even if it didn't can't really complain if you can get haskell on a smart phone or console :)
16:29:34 <monadic_kid> I did get jhc working on the wii (through homebrew)
16:30:17 <monadic_kid> the only problem is the majority of hackage packages use so many extensions
16:30:58 <monadic_kid> cause everyone uses ghc predominantly
16:31:14 <ezyang> We like our GHC extensions! ^_^ 
16:33:03 <Ornedan_> What library could I use to read a tga image and examine the pixel values?
16:33:31 <monadic_kid> Ornedan_: devil bindings probably support tga
16:34:13 <Ornedan_> Yes. It would be the best option if it worked
16:34:26 <Ornedan_> But it hits a compiler bug
16:34:32 <Ornedan_> So I can't use it
16:34:44 <ezyang> "so fix it!" :-) 
16:34:45 <monadic_kid> Ornedan_: compiler bug?
16:34:52 <monadic_kid> Ornedan_: compile error?
16:35:00 <Ornedan_> http://hackage.haskell.org/trac/ghc/ticket/2615 <- this thing
16:35:53 <monadic_kid> Ornedan_: that is for ghci
16:36:41 <sheaf> sorry I'm a bit confused at the moment, just starting out: I've got a function Int -> [Int] -> [Int], how do I write the corresponding function M Int -> M [Int] -> M [Int] out of it?
16:37:12 <copumpkin> what's M?
16:37:16 <Ornedan_> Possibly. But a test program that just tries loading an image segfaults
16:37:16 <monadic_kid> Ornedan_: I'm sure you can compile it to native and run it fine
16:37:27 <sheaf> some monad, in my case IO
16:37:33 <ezyang> Ornedan_: Fire it up in gdb. Do you get a semi-vaguely useful trace? 
16:37:41 <copumpkin> > let f :: Int -> [Int] -> [Int]; f = undefined in liftM2 f
16:37:42 <lambdabot>   Overlapping instances for GHC.Show.Show
16:37:42 <lambdabot>                              (m GHC...
16:37:45 <copumpkin> :t let f :: Int -> [Int] -> [Int]; f = undefined in liftM2 f
16:37:46 <sipa1024> mf a b = do { va <- a; vb <- b; return $ f va vb }
16:37:46 <lambdabot> forall (m :: * -> *). (Monad m) => m Int -> m [Int] -> m [Int]
16:38:38 <Ornedan_> ezyang: Not very. It did get into the devil side before crashing, tho
16:38:58 <ezyang> Ornedan_: Well, the question is, does it look like C or is it just s84f_info at the top 
16:39:23 <Ornedan_> #0  0x0000000000000000 in ?? ()
16:39:24 <Ornedan_> #1  0x00007ffff7aebaa7 in ilLoadTarga () from /usr/lib/libIL.so.1
16:39:24 <Ornedan_> #2  0x0000000000404248 in s2Wl_info ()
16:40:12 <Ornedan_> So I guess DevIL is out both because it's bugged itself and because I can't test it interactively :P
16:41:38 <Ornedan_> What's the next best choice? I've looked at the bitmap library, but the only way to get pixel data is IO actions with names of form unsafeX
16:43:05 <sheaf> ok, thanks, I'll play around a bit more now
16:43:09 <revenantphx> Ornedan_: what do you man?
16:43:24 * ddarius <3 Old Gray Cat.
16:43:39 <ezyang> That looks like it's in the library. 
16:43:41 <monadic_kid> Ornedan_: how about sdl-image but you'll have a dependancey on sdl package because that is what you will need to access the pixel data from a surface
16:43:44 <ezyang> You should probably install debugging symbols for it. 
16:44:04 <ezyang> It sounds like you may have gotten an API call subtly wrong. 
16:44:51 <monadic_kid> Ornedan_: or write a binding to another image loading library, or write your own tga loader
16:45:11 <ezyang> I suggest going ahead and writing a tga loader in Haskell :-) 
16:45:21 <ezyang> things just... work a lot more nicely when everything is pure Haskell. 
16:45:29 * ddarius suggests just using pnmtools and ignoring all of this.
16:46:14 <ezyang> "well, if you want to actually get something done :-)" 
16:46:34 <Ornedan_> Ah. Had to use ilInit first
16:47:14 <Ornedan_> Would be nice if that was mentioned in the documentation :P
16:48:04 <ezyang> That's not too surprising. 
16:48:50 <ezyang> I find this a very annoying behavior of C libraries :-/ 
16:51:38 <ddarius> Clearly the correct thing to do is bind all the C functions to a printf("error: not inited") function and then dynamically rebind them to the actual function after initialization.
16:53:30 <ezyang> "Unacceptable performance cost!" ;-) 
16:54:14 <ddarius> Since the library is being dynamically loaded anyway, it has no performance cost.
16:54:22 <ddarius> (If done at a low enough level.)
16:55:06 <ezyang> ddarius: The feeling I get is that we'd have to write a C stub that does this hack, and then starts up the RTS? 
16:56:25 <ddarius> It'd be part of the init routine.
17:00:02 <ddarius> Probably the simplest, near ideal thing that could be not too unreasonably done with the current operating environment is to have all those statically linked stub functions represented as jmps to the printf routine and then have those jmps rewritten to the appropriate routines on init.
17:00:36 <ddarius> The init routine will know those machine code locations and a known branch will be perfectly predicted leading to little I-cache stalling.
17:01:04 <ddarius> The end result will be something with essentially the overhead of a statically linked C call.
17:04:26 <Blkt> good night everyone
17:07:23 <ddarius> It would even be easy to support forward compatibility, i.e. if you statically link against an old stub and dynamically with a new DLL, it can safely and efficiently (not that it needs to be terribly efficient) detect when it has run out of stubs.  Or space can just be over-allocated.
17:29:24 <lars9> merry christmas to haskellers
17:29:42 <Eduard_Munteanu> Merry Christmas, lars9.
17:29:44 <dom96> merry christmas to you too
17:37:53 <ddarius> "One major Enterprise Resource Planning application, for example, has over 60,000 tables..."
17:38:05 <copumpkin> o.O
17:39:47 <Botje> one for every day-month-year combination since 1989!
17:40:16 <Botje> .. and then some :p
17:41:12 <dankna> no kidding
17:41:24 <dankna> I can barely conceive of how that's possible
17:41:29 <dankna> clearly they don't all have unique schemas
17:41:53 <luite> http://hirise.lpl.arizona.edu/images/2009/details/cut/PSP_007962_2635_cut.jpg
17:42:02 <luite> whoops, wrong channel
17:42:07 <luite> still a pretty image though :p
17:43:14 <ddarius> dankna: I presume (with no [other] evidence) that a significant number of them are generated via ORMs for example.
17:43:30 <dankna> that would make sense
17:43:43 <dankna> ooh, Marsy~
17:43:57 <c3l> x:xs is used a lot to match x to the head of some list. can I do something similar to let x match the last element of some list?
17:44:22 <benmachine> c3l: no
17:44:33 <benmachine> hmm
17:45:02 <benmachine> it's possible to get the last element with the 'last' function, but it goes wrong on empty lists
17:45:15 <benmachine> if you often want to get the last element, you might want a different structure
17:45:17 <benmachine> like Data.Seq
17:45:28 <benmachine> r
17:45:28 <benmachine> er
17:45:32 <benmachine> Data.Sequence
17:46:55 <c3l> hm, im new to all this. so it'll be an interesting experience. thanks
17:47:41 <benmachine> c3l: of course, you could pattern-match on (reverse list)
17:47:46 <benmachine> and use that to get the head
17:52:48 <Eduard_Munteanu> Bah, zippers on trees don't maintain consistency in my use-case... having a map of leaves, if I do an update I have to rebuild the map I suppose... *sigh*
17:53:22 <Eduard_Munteanu> I might give in to IORefs/STRefs.
17:54:01 <ezyang> What are you trying to do? 
17:55:40 <Eduard_Munteanu> ezyang: adaptive Huffman coding (I think it's Vitter's algorithm). I have a tree   Tree a = Leaf a | Fork a (Tree a) (Tree a), and a zipper on it. I figured I could have a map of the (zipped) leaves.
17:56:01 <Eduard_Munteanu> But if I update the tree in one place (lookup the map, update), then I have to rebuild it completely.
17:56:48 <ddarius> I.e. you want to have multiple zippers into the same tree but there's nothing connecting them (other than this map)
17:57:09 <Eduard_Munteanu> Yeah. Each one has its own copy of the context.
17:58:50 <Eduard_Munteanu> And the trouble is I also require structural mutability.
17:58:51 <ddarius> Eduard_Munteanu: Indeed.  That's why you need an explicit "multiple zipper" type and not just multiple zippers.
18:00:17 <Eduard_Munteanu> Suddenly it sounds really complicated... some sort of n-th order derivative-based zipper where n equals the number of nodes so I have as many fingers as I can? Uh...
18:00:29 <dolio> Oleg did it.
18:00:48 <Eduard_Munteanu> Yeah, I heard Oleg had some strange zippers.
18:01:26 <ezyang> I think at this point it's called a finger tree, not a zipper. 
18:02:06 <Eduard_Munteanu> Or I could have something like a zipper on ... data Tree a = Leaf (IORef a) | Fork (IORef a) (IORef (Tree a)) (IORef (Tree a)) ? :)
18:02:20 <Eduard_Munteanu> ezyang: hm, I might look that up.
18:07:33 <ddarius> Eduard_Munteanu: You wouldn't want higher derivatives as that's a different semantics.
18:08:04 <ddarius> Eduard_Munteanu: There would be little point in having a zipper on such a type.
18:21:26 <pumpkin> ezyang: still around?
18:24:36 <lispy_> hey
18:42:14 <pumpkin> ezyang: https://github.com/pumpkin/hoopl I gave you credit in the commit message, but it says I did it :P
18:42:34 <pumpkin> ezyang: you're welcome to do a separate one that I can clone though
18:43:31 <roconnor_> @src reverse
18:43:31 <lambdabot> reverse = foldl (flip (:)) []
18:44:45 <latros> what does @src drawo n
18:44:46 <latros> *draw on
18:44:48 <latros> ?
18:45:06 <latros> hmm
18:45:08 <latros> @src permutations
18:45:08 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
18:45:12 <parcs> an internal database of definitions
18:45:18 <latros> yeah, but presumably that is on some website?
18:45:25 <parcs> don't think so
18:46:24 <Eduard_Munteanu> ddarius: any suggestions? (sorry for the delay)
18:46:36 <latros> @src dropWhile
18:46:36 <lambdabot> Source not found. Wrong!  You cheating scum!
18:46:44 <latros> .....what
18:46:49 <latros> @src takeWhile
18:46:49 <lambdabot> takeWhile _ []                 =  []
18:46:49 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
18:46:49 <lambdabot>                    | otherwise =  []
18:46:53 <Eduard_Munteanu> Are you saying the zipper on the IORef thingy is also not that useful?
18:46:57 <latros> it has takeWhile but not dropWhile
18:47:00 <latros> wtf
18:47:12 <lispy_> ?version
18:47:13 <lambdabot> lambdabot 4.2.2.1
18:47:13 <lambdabot> darcs get http://code.haskell.org/lambdabot
18:47:20 <lispy_> latros: submit patches ^^ :)
18:47:38 <latros> also, is that definition right?
18:47:41 <latros> oh, yeah
18:47:42 <ddarius> Eduard_Munteanu: What would be the point of having a zipper on a mutable tree?
18:47:43 <latros> it is, k
18:47:58 <lispy_> latros: http://code.haskell.org/lambdabot/Plugin/Source.hs
18:48:07 <Eduard_Munteanu> ddarius: navigating it. It makes it a tree with backlinks.
18:48:29 <Eduard_Munteanu> So I can get from any leaf to any other node.
18:48:50 <Eduard_Munteanu> Or that's what I'm thinking.
18:48:55 <ddarius> Why not just add backlinks at that point?
18:49:30 <ddarius> It also wouldn't work correctly.
18:49:44 <Eduard_Munteanu> Hm, how? Would it work to use an IORef as a backlink?
18:50:13 <ddarius> Eduard_Munteanu: Of course it would.  That's what a backlink normally is (in other languages.)
18:51:00 <ddarius> It wouldn't work to have a "zipper" for your mutable tree to support backlinks because the functional path that the zipper held would not be correctly updated if the current subtree that the zipper pointed at was mutably relocated.
18:52:05 <Eduard_Munteanu> ddarius: I meant a zipper on   data Tree a = Leaf (IORef a) | Fork (IORef a) (IORef (Tree a)) (IORef (Tree a))
18:52:18 <Eduard_Munteanu> Why wouldn't it work if I updated those IORefs?
18:53:47 <Eduard_Munteanu> Oh, it wouldn't if I change it structurally, since the context must change.
18:54:26 <Eduard_Munteanu> Okay, so it's gonna be a tree with IORefs as backlinks.
18:54:52 <Eduard_Munteanu> Damn, I wish this was easier.
18:55:10 <Eduard_Munteanu> (it also means IO or ST will pollute my code)
18:55:47 <ddarius> The best way forward is probably to rethink the approach entirely.  Unfortunately, this can require quite a bit of creativity and insight.
18:56:45 <Eduard_Munteanu> ddarius: well I'm not really willing to change the algorithm too much. It's basically an assignment that I chose to do in Haskell, so not only the instructor isn't familiar at all with the language, but if I also rethink the algorithm..... :)
18:57:13 <Eduard_Munteanu> (we're supposed to do this in C, Matlab or something else :P)
18:57:37 <ddarius> Eduard_Munteanu: Yes, that's one of the problems with purely functional programming.  Almost all algorithms are specified in an imperative pseudo-language, and often apparently (or actually) rely on aspects of imperative languages.
18:57:42 <Eduard_Munteanu> Plus I'm not sure I can rethink Vitter's algorithm to be functional :)
18:57:51 <Eduard_Munteanu> Yeah.
18:58:52 <ddarius> Eduard_Munteanu: At any rate, you can make a mutable tree structure that completely mimicks the structure typically used in imperative algorithms and the result will be pretty much just as ugly.
19:00:26 <Eduard_Munteanu> I see, I'll try my luck with ST or IO and see what I get. Thanks.
19:01:45 <ddarius> That said, a lot of times algorithms don't deeply rely on imperative techniques and can be made purely functional and significantly simplified by just a slight change in perspective.
19:02:47 <Eduard_Munteanu> Yeah, I pretty much wrote the non-adaptive Huffman in a functional manner.
19:05:43 <lispy_> ddarius: so what kind of database do you want to make?  I assume you'll have a DSL for communicating with it, but what internal model do you want?
19:11:14 <ddarius> lispy_: I may try to directly implement Spivak's ideas for kicks, but otherwise (and even then) it would be more or less a relational database.
19:11:38 <lispy_> I see
19:11:49 <lispy_> I should probably watch his talk at some point, I missed it the day he gave it
19:11:59 <lispy_> Thankfully we have vimeo now
19:12:04 <djahandarie> Hmm... I know he gave a second talk, I haven't seen that one
19:12:06 <ddarius> That said, I intend to look at some of the column-store papers in the paper you provided.
19:12:19 <ddarius> I'd recommend the papers over the talk.
19:12:21 <shachaf> ddarius: You are making a database?
19:13:02 <ddarius> shachaf: Probably not, but I may hack on parts of one.  I've written a full-text database before, and I've been interested in the stuff that goes into making a database for a very long time.
19:13:37 <djahandarie> ddarius, if you make a solid core I'm sure someone else would be interested in picking it up and expanding to make it 'fully enterprise' or whatever databases need to be today (webscale?).
19:13:43 <ddarius> It would also be somewhat entertaining to make a database based on cache-oblivious data structures.
19:14:02 <lispy_> ddarius: full text database?
19:14:31 <lispy_> My goal for a DB would be to apply formal methods as much as I can
19:14:50 <ddarius> Also, I'd be interested in having some advanced features in the native query language e.g. implications, and I'm not sure quite how that would work out for the underlying model.  I imagine relational is more or less up to it.
19:15:11 <lispy_> For example, define a formal semantics for SQL (or something SQL-like) and verify all the rewrites that you do when query optimizing
19:15:13 <dankna> implications, hmm, I'm not familiar with those.  an Agda thing?
19:15:18 <ddarius> lispy_: There would be parts of any reasonably serious database that would greatly benefit from having formal methods applied to them for correctness.
19:15:33 <ddarius> dankna: Implication as in logic.
19:15:34 <Zeiris> Is anything known about Snap's security? Risky, completely safe, somewhere in between?
19:15:53 <djahandarie> "So unknown that no one has tried to crack it yet"
19:15:58 <lispy_> Zeiris: Well, what does security mean to you?
19:16:17 <dankna> ddarius: okay, but how do they fit into a programming language?
19:16:22 <lispy_> Zeiris: Integrity, availability, and what is the other one C-something is the standard definition I think
19:16:30 <Zeiris> Can I run it on a Windows box with a bunch of other stuff without worrying about getting ear-raped when things go terribly wrong.
19:16:58 <dankna> everyone knows people who hack Windows boxes go for the eye sockets, not the ears
19:17:10 <djahandarie> I'm sure it's fine though, I'd say if there are any serious security bugs, they'd lie in the RTS, not in the framework, as long as things are written in a type-safe fashion (i.e., you aren't mixing up strings with filenames and sql queries, etc.)
19:17:11 <ddarius> lispy_: The stuff covered in chapter 6 of the paper you provided would greatly benefit from formal proofs of correctness.  Unfortunately, they'd be -extremely- difficult to formalize.
19:17:39 <Zeiris> I mean, some of the experimental Erlang web servers had nasty stuff in 'em. Makes me feel a little wary about what's otherwise a very good-looking library.
19:17:39 <ddarius> dankna: Look at logic programming, particularly lambdaProlog (for practice) and abstract logic programming (for theory.)
19:17:52 <dankna> ah - okay
19:17:54 <dankna> will do sometime
19:17:56 <ddarius> dankna: Idealized SQL is a very simple logic language.
19:17:57 <lispy_> Zeiris: I'm supposed to read this: http://csrc.nist.gov/publications/nistpubs/800-12/handbook.pdf
19:18:03 <dankna> intriguing
19:18:06 * dankna is a big SQL fan
19:18:24 <lispy_> ddarius: what was chapter 6 again? /me goes searching for his kindle to check
19:18:34 <dankna> lispy: their jigsaw is missing some pieces, and other pieces don't fit.  I find this quite appropriate!
19:18:48 <ddarius> lispy_: "Transactions: Concurrency Control and Recovery"
19:18:54 <lispy_> ddarius: ah, right
19:19:05 <lispy_> ddarius: yes, that's a place where FM would shine
19:19:21 <lispy_> Not easy to verify, but verifying it would be worth it
19:19:29 <ddarius> Indeed.
19:19:59 <ddarius> dankna: Real SQL is rather non-logical in many respects (and this is part of what Spivak's ideas cover, he essentially provides an alternative grounding that actually fits SQL.)
19:20:18 <ddarius> dankna: However, Datalog is very much a logical language.
19:20:36 <dankna> yeah, I've written an SQL parser, so I know a bunch of its ins and outs, or at least know that they exist
19:20:45 <ddarius> (Admittedly, real Prolog is even less of a logical language that SQL is, so meh...)
19:20:45 <dankna> hmm
19:21:21 <ddarius> lambdaProlog, though, is a pretty pure logic language.
19:21:32 <elliott> is there a mirror of hackage? really slow
19:21:47 <elliott> prolog, i approve of this discussion, how long ago did it start
19:22:21 <revenantphx> I haven't ever done anything with prolog :
19:22:38 <dankna> elliott: no there is not, but people seem relatively okay with the idea of making one now.  I offered my server resources to that end, but nobody's quite sure what to do with them yet.
19:23:10 <ddarius> One of the benefits of making a database in this day and age is that a large amount of the complexity in current major DBMSes is due to the environment in which they were first made.
19:23:31 <dankna> indeed so
19:23:47 <latros> umm...where's the @src database?
19:24:01 <dankna> personally it's not something I would attempt; I would extend sqlite if I had to rather than start my own thing
19:24:22 <ddarius> latros: In lambdabot's source code, though the actual live one could be different from what is in the repositories.
19:24:26 <dankna> their test suite has 100% coverage - not just lines of code but every single asm instruction
19:24:32 <latros> I know it's in its source code
19:24:34 <latros> where in its source code?
19:24:48 <latros> Source.hs isn't especially clear on where it draws stuff from
19:25:03 <ddarius> latros: There's a file called sources I think, it should be pretty obvious when you see it, or you could just look at the code for the @src plugin.
19:25:08 <shachaf> latros: In state/, I think.
19:25:22 <shachaf> Yep, http://code.haskell.org/lambdabot/State/source
19:25:26 <revenantphx> @src lambdabot
19:25:27 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
19:25:29 <revenantphx> Damn.
19:25:34 <latros> there it is
19:25:40 <latros> State/source
19:25:46 <latros> oh
19:25:49 <latros> sorry, you already said that
19:25:58 <shachaf> revenantphx: That'd be @version
19:26:02 <ddarius> dankna: Hoping to make anything that will compete with the major players is silly.  At best you might be able to capture a niche.
19:28:06 <dankna> ddarius: yes I agree.  so that's obviously not your goal then.
19:28:11 <Zeiris> A completely transparent, well distributed database would be a nice niche to capture.
19:28:35 <dankna> transparent in what sense?  I don't think the existence of the database can be transparent.
19:28:37 <ddarius> I don't believe in completely transparent distribution.
19:28:43 <dankna> and I'm not sure the distrib--
19:28:45 <dankna> ya
19:29:06 <Zeiris> It's probably a pipe dream, but being able to access data without really caring where it is - like Erlang does with processes - would be nice.
19:29:13 <dankna> though you could do it somewhat like Oracle lets you put tables on different stores
19:29:19 <dankna> except the stores happen tob e located different places
19:29:56 <dankna> that way you CAN write queries that ignore the location - you just can't make guarantees about their efficiency
19:30:00 <ddarius> Zeiris: You -can- do that, as long as you really don't care about performance (and likely consistency)
19:30:56 <Zeiris> There's some applications where performance isn't a huge deal (configuration data, stuff that rarely changes)
19:38:10 <ddarius> Rarely changing doesn't mean performance doesn't matter.  Data warehouses rarely change and performance is a significant concern for them.  I don't see configuration data needing a DBMS or even a distributed one.
19:42:09 <roconnor_>                                                         1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq07777777777777777777777777
19:42:39 * shachaf agrees completely.
19:44:44 <elliott> roconnor_: btw, 98sdfuy9ddddddddddddddddd
19:44:58 <shachaf> elliott: That's going a bit far.
19:45:26 <elliott> shachaf: well okay, but what about ffff88888888889aaaaaaaaaaaaaaaaa0?
19:46:31 <shachaf> Eh. Sure, that's true, but it's almost a tautology.
19:51:49 <Bynbo7> roconnor_: kitteh?
19:53:14 <ddarius> Merry hour early Christmas to me.
19:57:25 <shachaf> ddarius: You should move east.
19:58:06 <ddarius> It's hard to get more east than I am and still stay in America.
19:58:15 <ddarius> I could live on a boat in the Atlantic though.  That'd be interesting.
19:58:27 <shachaf> ddarius: The US Virgin Islands would work.
19:58:41 <shachaf> Though I suppose that's not really America, just the US.
21:02:02 <roconnor_> Bynbo7: ya, sorry, cat.
21:04:57 <dskippy> May you all have a pure and functional Christmas.
21:05:34 <mm_freak> thanks, you too
21:06:09 <mm_freak> i just wrote a little test program using SDL to fill a 1280x1024 screen with random pixels…  it gives two interesting insights…
21:06:14 <ManateeLazyCat> Merry Christmas all. :)
21:06:31 <ManateeLazyCat> @time lambdabot
21:06:31 <lambdabot> I live on the internet, do you expect me to have a local time?
21:06:46 <mm_freak> 1. pokeElemOff is very fast, seems like it translates to a memory write instruction rather than a function call
21:06:55 <mm_freak> 2. mersenne-random is much faster than mwc-random
21:07:12 <mm_freak> at least for Word32
21:07:18 <mm_freak> ManateeLazyCat: thanks and back =)
21:08:17 <ManateeLazyCat> mm_freak: My Dynamic-Load library almost finish.... :)
21:08:23 <mm_freak> the second point directly contradicts the claims in mwc-random's package description
21:08:34 <mm_freak> which states: "Compared to the mersenne-random package, this package has a more convenient API, is faster, and supports more statistical distributions."
21:09:13 <Zeiris> Can I auto-derive Data and Typeable for a data type I didn't define, but have total access to?
21:09:16 <mm_freak> ManateeLazyCat: great…  i haven't found time to work on fastirc yet, but i will today =)
21:09:30 <mm_freak> Zeiris: i don't think so
21:09:41 * ManateeLazyCat pasted "dynload.hs" at http://paste2.org/get/1160707
21:09:41 <ManateeLazyCat> Code like above. 
21:10:07 <ManateeLazyCat> mm_freak: I hope i can finish this library in Christmas day. :)
21:10:38 <mm_freak> ManateeLazyCat: i'll have four hours in the train to work on fastirc and ismtp
21:10:46 <mm_freak> i'm planning to finish at least one of them
21:10:48 <ManateeLazyCat> mm_freak: :)
21:11:06 <ManateeLazyCat> mm_freak: What's the ismtp? ;p
21:11:13 <mm_freak> although i think ismtp will be much easier to finish considering that it's almost there =)
21:11:19 <mm_freak> it's my smtp library
21:11:24 <mm_freak> the 'i' stands for Iteratee
21:11:46 <mm_freak> it uses the 'enumerator' package for fast and predictable I/O
21:11:54 <ManateeLazyCat> mm_freak: Do you interesting create IMAP library?
21:11:55 <mm_freak> (or rather for the 'I' part of I/O)
21:12:14 <mm_freak> ManateeLazyCat: rather not, because i have little use for an IMAP library and almost no experience with it
21:12:19 <ManateeLazyCat> mm_freak: I perhaps will develop manatee-mailclient in near future, and you're good on protocol implement. :)
21:12:24 <duckinator> Merry Christmas you crazy people coding haskell at 12:10am on Christmas :)
21:12:25 <duckinator> 'night
21:12:34 <ManateeLazyCat> @time
21:12:35 <lambdabot> Local time for ManateeLazyCat is Sat Dec 25 13:12:07 2010
21:12:41 <mm_freak> @time
21:12:50 <duckinator> ManateeLazyCat: well that's even worse... :D
21:12:54 <mm_freak> ah, CTCP disabled
21:12:54 <Beltessazar> @time
21:12:55 <lambdabot> Local time for Beltessazar is 2010-12-25 03:12:28 -0200
21:13:01 <mm_freak> well, it's 6:12 am here
21:13:08 <mm_freak> i just came home =)
21:13:13 <ManateeLazyCat> mm_freak: After my dynload finish, we can use Haskell like script in runtime, but fast as compile code. :)
21:13:18 <mm_freak> and i'll go to bed in a few minutes
21:13:23 <duckinator> Beltessazar: oh jeeze :P
21:13:29 <mm_freak> ManateeLazyCat: great
21:13:40 <ManateeLazyCat> mm_freak: And perfect safe. :)
21:13:40 <Beltessazar> tell me about it
21:14:10 <duckinator> Beltessazar: are you coding haskell to control a device that captures santa? ;) if so, we can forgive you
21:14:16 <mm_freak> ManateeLazyCat: so you can just compile a project like normal, but some of its code will be placed in a shared object instead of in the executable?
21:14:46 <duckinator> ...ok, no more distractions. i'm going to bed before i end up being awake at 5am again :>
21:14:48 <duckinator> 'night crazies
21:15:10 <Beltessazar> something like that... except i'm just starting to learn haskell to control a device that captures santa...
21:15:15 <Beltessazar> maybe next christmass...
21:15:25 <ManateeLazyCat> mm_freak: User -> touch configre -> compile to cabal/ghc database -> use dynload dynamic linking newest library in running program -> update TVar cache layer -> running program read TVar at *same* time. :)
21:16:12 <Beltessazar> duckinator: 'night
21:17:00 <ManateeLazyCat> mm_freak: Because running program always read cache value from TVar, so it's fastest. And background thread update newest library to TVar cache, so it's scriptable. :)
21:17:41 <ManateeLazyCat> mm_freak: I call it "compile cache server"
21:18:23 <ManateeLazyCat> "compile cache server" is special framework, i will draw picture to explain my idea.
21:19:12 * ManateeLazyCat pasted "test code" at http://paste2.org/get/1160712
21:19:15 <ManateeLazyCat> mm_freak: Test code like above.
21:19:59 <ManateeLazyCat> mm_freak: Now i use block solution test code, i will use forkIO wrap `dynload` in my project to udpate cache asynchronous. :)
21:20:36 <ManateeLazyCat> mm_freak: See? :)
21:21:33 <mm_freak> interesting
21:23:26 <ManateeLazyCat> mm_freak: Now i can dynamic update new package install in cabal database, but i figure out how to dynamic code even package's fingerprint change.
21:36:53 <mm_freak> ManateeLazyCat: so far i haven't needed dynamic loading, but it would be a great feature to have
21:37:18 <ManateeLazyCat> mm_freak: I use dynamic loading as *developer mode"
21:37:26 <mm_freak> but doesn't GHC actually support dynamic linking?  can't you use this to also load modules dynamically?
21:37:37 <mm_freak> ah, i see
21:37:41 <ManateeLazyCat> mm_freak: I use GHC API.
21:37:49 <mm_freak> ah, ok
21:38:12 <ManateeLazyCat> mm_freak: Think about the develop speed of emacs developer. :) 
21:38:29 <ManateeLazyCat> mm_freak: Fix-And-Run in runtime, don't need restart and won't lose current state.
21:39:19 <ManateeLazyCat> mm_freak: So i also want bring this develop mode into Manatee project. :)
21:39:44 <ManateeLazyCat> mm_freak: Then manatee developer have extreme develop speed....
21:42:04 <mm_freak> ManateeLazyCat: sounds really great
21:42:09 <mm_freak> i could make use of that
21:42:27 <mm_freak> but for now i need some sleep =)
21:42:29 <mm_freak> good night
21:42:42 <ManateeLazyCat> mm_freak: Good Christmas dream. :)
21:42:59 <mm_freak> thanks =)
22:27:57 * zachk wants to beat the the console on windows to death with an aluminium baseball bat 
22:28:58 <leifw> zachk: I feel your pain.  If you're cool with emacs, just install it (probably under cygwin) and use eshell, otherwise, use cygwin's shell.
22:29:28 <leifw> zachk: I love how it's not resizable, and yet most windows cli programs' helptext is wider than the terminal
22:32:09 <zachk> im trying to to poll for chracters one at a time and not have them echo to the screen 
22:33:00 <zachk> i could do it in qbasic back in 1995 but not in haskell in 2010 wdf :( 
22:33:07 <zachk> MERRY CHRISTMAS YALL
22:34:20 <iamrohitbanga> zachk: why don't you use linux/
22:34:35 <zachk> trying to 
22:35:38 <zachk> i got unbuntu on my laptop with wifi working, but a small laptop for coding isnt the most comfortable thing, i just got a 40 gig solid state intel sata harddrive from bestbuy with christmas money and im putting gentoo on it, except i live in an apartment with my mom...
22:35:59 <zachk> and at night i cant run a cat5 cable to the router, and i dont quite have the hang of getting wifi to work on linux 
22:38:16 * zachk can see the c function he needs and its in conio.h 
22:39:06 <zachk> oh and hSetBufferingMode on windows console is totally broken, NoBuffering still does line buffering :( 
22:39:29 <Bynbo7> :\
23:12:22 <ddarius> @google The Limits of Network Transparency in a Distributed Programming Language
23:12:25 <lambdabot> http://www.info.ucl.ac.be/~pvr/raphthesis.pdf
23:12:25 <lambdabot> Title: The Limits of Network Transparency in a Distributed Programming Language
23:13:37 * ddarius read "Concurrency Control and Recovery in Databases" almost a decade ago.
23:16:42 * ddarius has some weird papers.
23:42:31 <adu> iH
23:42:43 <adu> I need some help with parsec
23:43:22 <adu> how do you tell how much input is left unconsumed after "parse"?
23:52:17 <edwardk> just append a parser that gets the input and runs length on it
23:52:18 * hackagebot byteorder 1.0.2 - Exposes the native endianess or byte ordering of the system.  http://hackage.haskell.org/package/byteorder-1.0.2 (AntoineLatter)
23:55:19 * hackagebot byteorder 1.0.3 - Exposes the native endianness or byte ordering of the system.  http://hackage.haskell.org/package/byteorder-1.0.3 (AntoineLatter)
23:56:53 * ddarius has stuff he didn't even know he had.
23:57:24 <edwardk> heya ddarius
23:57:34 <edwardk> merry xmas and all that
23:58:01 <ddarius> Moin
23:58:54 <edwardk> made more headway on the dinatural-hom thing, but then ran into another compiler bug, this one they are fixing ;)
23:59:52 <ddarius> edwardk: Maybe Scala will work by the time you're done.
