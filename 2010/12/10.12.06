00:02:30 * hackagebot Stream 0.4.2 - A library for manipulating infinite lists.  http://hackage.haskell.org/package/Stream-0.4.2 (WouterSwierstra)
00:09:21 <sohum> @pl \d f i -> map (a . c) $ cb d $ fmap f i 
00:09:22 <lambdabot> ((map (a . c) .) .) . (. fmap) . (.) . cb
00:11:01 <aoa> can anyone help with constructing ^ (power) from + (sum) in a point-free style?
00:11:51 <Taejo> aoa: for natural numbers? integers?
00:12:01 <aoa> @pl (\x -> take x $ repeat x)
00:12:02 <lambdabot> ap take repeat
00:12:51 <aoa> Taejo: Int or Integers
00:14:16 <sohum> @pl (a -> b) -> (a -> b) -> (b -> b) -> a -> b
00:14:16 <lambdabot> (line 1, column 4):
00:14:16 <lambdabot> unexpected ">"
00:14:16 <lambdabot> expecting variable, "(", operator or ")"
00:14:21 <sohum> @hoogle (a -> b) -> (a -> b) -> (b -> b) -> a -> b
00:14:21 <lambdabot> Control.Parallel.Strategies (-|) :: (a -> b) -> Strategy b -> (b -> c) -> a -> c
00:14:22 <lambdabot> Control.Parallel.Strategies (-||) :: (a -> b) -> Strategy b -> (b -> c) -> a -> c
00:14:22 <lambdabot> Control.Parallel.Strategies (.|) :: (b -> c) -> Strategy b -> (a -> b) -> a -> c
00:14:34 <sohum> :t (&&&)
00:14:35 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
00:14:57 <sohum> @hoogle (a -> b) -> (a -> b) -> (b -> b -> b) -> a -> b
00:14:57 <lambdabot> No results found
00:15:06 <sohum> :t on
00:15:08 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
00:15:43 <sohum> @hoogle (b -> b -> c) -> (a -> b) -> (a -> b) -> a -> c
00:15:43 <lambdabot> No results found
00:15:44 <blackdog> whee, finally got hubris working on mac os x
00:16:00 <blackdog> in a desperately only-on-my-machine sort of way, of course.
00:16:44 <aoa> Taejo: Int would be fine. Output from lambdabot is "ap take repeat", but it does not work on numbers
00:17:04 <aoa> quit
00:17:07 <Taejo> :t ap take repeat
00:17:08 <lambdabot> Int -> [Int]
00:17:17 <sohum> @pl \f g h a -> f (g a) (h a)
00:17:17 <lambdabot> liftM2
00:17:24 <sohum> :t liftM2
00:17:25 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
00:17:31 <Taejo> aoa: I think that's not what you want
00:17:51 <Taejo> aoa: btw, take n . repeat x = replicate n x
00:17:52 <c_wraith> :t ap genericTake repeat
00:17:53 <lambdabot> forall a. (Integral a) => a -> [a]
00:18:28 <aristid> > (genericTake <*> repeat) 5
00:18:29 <lambdabot>   [5,5,5,5,5]
00:18:33 <c_wraith> > ap genericTake repeat (3 :: Integer)
00:18:35 <lambdabot>   [3,3,3]
00:18:42 <aristid> > join replicate 5
00:18:43 <lambdabot>   [5,5,5,5,5]
00:18:51 <Taejo> > let a * b = foldr (+) 0 (replicate a b) in 5*3
00:18:52 <lambdabot>   15
00:19:08 <Taejo> @pl a * b = foldr (+) 0 (replicate a b)
00:19:08 <lambdabot> (line 1, column 7):
00:19:08 <lambdabot> unexpected "="
00:19:08 <lambdabot> expecting variable, "(", operator, "*", "/", "`quot`", "`rem`", "`div`", "`mod`", ":%", "%" or end of input
00:19:14 <aristid> :t genericReplicate
00:19:15 <lambdabot> forall i a. (Integral i) => i -> a -> [a]
00:19:22 <Taejo> @pl mul a b = foldr (+) 0 (replicate a b)
00:19:22 <lambdabot> mul = (foldr (+) 0 .) . replicate
00:19:24 <aristid> :t join genericReplicate
00:19:24 <lambdabot> forall i. (Integral i) => i -> [i]
00:22:37 * hackagebot haxr 3000.8 - XML-RPC client and server library.  http://hackage.haskell.org/package/haxr-3000.8 (GracjanPolak)
00:23:19 <jeanbern> hello, to pose a question do I just ask out loud here?
00:23:52 <aoa> all: thanks! 'product $ flip replicate 2 3' evaluates to 8. That is it, I think
00:23:54 <Axman6> you can pose it in lyrical prose if you prefer
00:25:08 <Axman6> jeanbern: ask away
00:25:43 <jeanbern> my poetry skills are not something to be proud of, so I think I will just go the straightforward route: I am trying to parse a string formatted as "x:y" where x and y could be Integers or there could be something wrong with the string where it is not formatted properly
00:26:08 <jeanbern> and I am running into problems with inferred and expected types, I will post what I have in a second
00:26:43 <aristid> :t break
00:26:44 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
00:27:18 <aristid> :t tail .: break (== ':')
00:27:19 <lambdabot> [Char] -> ([Char], [Char])
00:27:34 <aristid> > tail .: break (== ':') $ "ab:cd"
00:27:35 <lambdabot>   ("ab","cd")
00:28:00 <aristid> i feel dirty for using the Functor instance of (e,)
00:28:25 <c_wraith> :t fmap
00:28:26 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:28:28 <c_wraith> :t second
00:28:30 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
00:28:41 <c_wraith> eh, they're obviously the same :)
00:28:48 <c_wraith> :t fmap `asTypeOF` second
00:28:49 <lambdabot> Not in scope: `asTypeOF'
00:28:54 <c_wraith> :t fmap `asTypeOf` second
00:28:55 <lambdabot> forall a b d. (a -> b) -> (d, a) -> (d, b)
00:29:22 <aristid> c_wraith: yeah :) and it has to be second, not first, because of the type
00:29:52 <jeanbern> I will try to work with that, thank you
00:30:00 <aristid> but still, feels dirty
00:30:01 <c_wraith> Ah, I didn't expect that asTypeOf to work, but now I see why it did.  Enough information between the two to resolve both the typeclasses to specific types
00:30:23 <aristid> c_wraith: i would have put both in a list
00:30:56 <aristid> :t asTypeOf
00:30:57 <lambdabot> forall a. a -> a -> a
00:31:09 <aristid> asTypeOf is just id?
00:31:19 <aristid> um i mean const
00:32:09 <c_wraith> yes, it is
00:32:22 <c_wraith> many interesting functions are just const with a restrictive type signature
00:32:33 <aristid> many?
00:33:19 <c_wraith> in the sense that anything you can do with the ScopeTypeVariables extension can also be done with const and a funny type.
00:33:25 <c_wraith> err, ScopedTypeVariables
00:33:28 <aristid> ah
00:34:10 <aristid> i guess the appeal of ScopedTypeVariables is that people expect it to work that way anyways
00:34:49 <c_wraith> yep
00:35:29 <jeanbern> aristid, in the code you provided: tail .: break (== ':') $ "ab:cd" I get an error saying Not in scope `.: - I'm only starting to learn Haskell and I'm not sure of how you came up with the code so I don't know how to fix it myself
00:35:58 <aristid> jeanbern: it's better that you use a less evil solution :) sorry for bringing it up
00:36:54 <aristid> jeanbern: let (a, b') = break (== ':') "abcd"; b = tail b' in ... -- here you can use a and b
00:37:10 <twaffle> is there a parsec equivalent to Prelude's lex function?
00:37:23 <aristid> :t lex
00:37:23 <lambdabot> String -> [(String, String)]
00:37:33 <aristid> twaffle: what does lex even do? oO
00:37:43 <aristid> > lex "abc def.geh"
00:37:44 <lambdabot>   [("abc"," def.geh")]
00:38:03 <twaffle> :t Text.Read.Lex.lex
00:38:04 <lambdabot> Text.ParserCombinators.ReadP.ReadP Text.Read.Lex.Lexeme
01:03:45 <jeanbern> aristid: Thank you very much for the help, I ended up using the pattern (a:':':b) to match my query, the reason I couldn't get it to work before was a lack of parentheses 
02:01:34 <lewis1711> hello. I'm an undergraduate maths major that programs in my spare time. I wish to learn haskell to explore some mathematical ideas I have been having. are there any tutorials that come from "so you know a bit of maths" perspective, rather than a "so you know a bit of imperative programming" perspective?
02:03:03 <osfameron> lewis1711: I think some of the haskell tutorials will suit you better, even ;-)
02:03:14 <Kaidelong> lewis1711: I really doubt it. Also Haskell might not be what you looking for.
02:03:51 <osfameron> certainly Haskell school of Expression felt quite mathsy to me (as a mostly imperative programming background guy)
02:04:02 <danr> well it might also be exactly what you're looking for
02:04:09 <Kaidelong> depending on what mathematical ideas you might want to explore you might be better off using something more specialized
02:04:14 <danr> I can also recommend School of Expression. Maybe also this blog: http://www.polyomino.f2s.com/david/haskell/main.html
02:04:20 <Kaidelong> IE ACL2, R, Octave etc
02:04:38 <Kaidelong> or Coq
02:04:49 <Kaidelong> or a myriad of other things
02:04:52 <winxordie> lewis1711: You're probably looking around for SAGE or Coq
02:04:54 <lewis1711> Kaidelong: no, I am wanting to explore more fundamental ideas. like modelling certain maths with types and computer functions. not so much number crunching
02:05:10 <Kaidelong> Something like ACL2 or Coq then lewis1711?
02:05:15 <lewis1711> no idea:)
02:05:22 <lewis1711> danr: ty, having a look now
02:05:26 <danr> Also sigfpe's blog has nice haskell examples taken from math (and well type theory): http://blog.sigfpe.com/
02:05:31 <Kaidelong> Haskell does have a bit of that going for it
02:05:41 <Kaidelong> it might be good to learn haskell first
02:07:35 <Kaidelong> lewis1711: I think the biggest thing you could get out of haskell is seeing some existing approaches to modeling computer programs and have some idea how to build your own
02:08:12 <Kaidelong> the way in which side effects or random numbers work in haskell for example, pretty cool, might be worth learning
02:08:33 <lewis1711> well, I figure i wanted a functional static language that let me define new types. that's basically it at this stage.
02:08:40 <Kaidelong> @type getRandom
02:08:41 <lambdabot> forall (m :: * -> *) a. (MonadRandom m, Random a) => m a
02:09:03 <merijn> lewis1711: I think Learn You A Haskell is a good starting point regardless of background
02:09:15 <merijn> @where lyah
02:09:15 <lambdabot> http://www.learnyouahaskell.com/
02:09:22 <Kaidelong> lewis1711: how much do you want out of the type system? You might just end up wanting to go full circle and use something like ACL2
02:10:19 <merijn> And yeah, Coq or Agda might be worth looking into for more mathy things
02:10:28 <lewis1711> no, i more want something for a DIY computer algebra system
02:10:37 <merijn> Although I think learning Haskell couldn't hurt for that
02:10:52 <lewis1711> almost. er. I will try that learnyouhaskell.
02:11:56 <lewis1711> tbh I have tried to learn haskell with a few tutorials multiple times and gotten extremely bored because it's all about arbitrary programming stuff on the commandline for people who want to use haskell for applicaton programming or whatever. But I've had these ideas so i'll try again
02:12:29 <Kaidelong> lewis: programming is hard and starting out with the basics is a good idea
02:12:57 <Kaidelong> once you really get a feel for it you'll figure out what you want to do on your own without needing a tutorial
02:13:05 <winxordie> it's not exactly arbitrary stuff
02:13:20 <lewis1711> Kaidelong: I can already program somewhat. All the languages i've learnt I've learnt by diving in and getting lost
02:13:39 <lewis1711> haskell is sort of hard to do that with though, as it's thoroughly un-algol like
02:13:43 <lewis1711> but I may as well try again
02:14:12 <dolio> What makes that easy in Algol?
02:14:15 <Kaidelong> lewis: haskell's type system and interpreter are nice for learning by exploring. F# is perhaps a little better in that regard
02:14:39 <Kaidelong> lewis: it's often possible to tell what a function does from its type alone, so being able to ask for types is quite handy
02:15:07 <winxordie> lewis1711: you know any other functional languages?
02:16:13 <lewis1711> winxordie: not purely functional, no. but i am not exactly a stranger to HOF, lambdas, immutable values, closures, and all that
02:16:26 <merijn> @quote vending
02:16:26 <lambdabot> JohnMeacham says: I liken learning haskell to tipping over a vending machine. you can't just push it, you gotta rock it back and forth a few times building up momentum until bam! suddenly the flash
02:16:27 <lambdabot> of insight hits and it all makes sense.
02:16:34 <dolio> Perhaps you should read the Gentle Introduction, then.
02:17:40 <Kaidelong> I find the gentle introduction a bit confusing compared to LYAH or RWH
02:17:53 <merijn> "a bit" :D
02:17:56 <winxordie> lewis1711: If you're doing mathy stuff, I recommend going through project euler and http://haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems for practice
02:18:01 <Kaidelong> although I've taken to diving through source code lately
02:18:30 <Kaidelong> a lot of the stuff on hackage needs better documentation, I'd never have figured out hood if I didn't look at its source code
02:19:28 <lewis1711> TBH I'd rather just ask you all relatively basic questions until I get enough of a foot hold that I can google things myself. so how RTFM is this place, anyway?:P
02:19:36 <dolio> The Gentle Introduction is, if I recall, written for someone who already knows a little something about functional programming.
02:19:36 <Kaidelong> winxordie: I think what he basically wants to do is write a DSL in haskell to explore concepts from algebra
02:19:46 <dolio> Which I don't think is the case for LYAH and RWH.
02:20:42 <lewis1711> I want to define my own algebraic types
02:20:50 <winxordie> Kaidelong: it's still a good idea to run through a few exercises until one's acquainted with the mathish part of the language before writing DSLs left and right :D
02:20:53 <lewis1711> then define functions on them. but yeah
02:21:31 <Kaidelong> LYAH assumes imperative programming background but it doesn't really
02:21:35 <Kaidelong> lewis: I take it you want haskell for the typeclasses, right?
02:22:38 <lewis1711> Kaidelong: yes. I hear it's good, from my friend who's doing a phd in category theory
02:22:39 <Kaidelong> data F a b = G a | H b | J
02:22:40 <Kaidelong> etc
02:23:32 <Kaidelong> lewis: if you're looking for a proof assistant you're barking up the wrong tree. If you're looking to write a proof assistant yourself, perhaps haskell is a good choice
02:23:50 <Kaidelong> not that that would be an easy task
02:24:12 <winxordie> I don't think that's an easy task in any particular language
02:24:40 <Jafet> A basic proof assistant is ten lines of dwim
02:24:54 <Kaidelong> haskell's type system can encode arbitrary prolog programs though, so who knows
02:25:24 <winxordie> Kaidelong: I haven't heard of *that* particular result; what's the source of this claim?
02:25:31 <Kaidelong> hang on
02:25:39 <lewis1711> http://www.haskell.org/haskellwiki/Learn_Haskell_in_10_minutes, woo, this is me
02:25:41 <merijn> winxordie: I'm pretty sure Haskell's type system is Turing complete
02:25:55 <merijn> winxordie: Also, look at the terrifying stuff Oleg does in the type system
02:26:01 <sipa> a type class is a predicate over types
02:26:07 <lewis1711> Kaidelong: yeap, not looking for a proof assistant.
02:26:08 <winxordie> merijn: that would definitely be news to me then :)
02:26:21 <dolio> It isn't Turing complete without extensions.
02:26:28 <sipa> you'll need -XUndecidableInstances i think
02:26:31 <dolio> And type classes aren't exactly prolog.
02:26:42 <Kaidelong> lewis1711: GHC actually restricts the haskell type system to be decidable IIRC
02:26:47 <sipa> yes
02:26:48 <lewis1711> ok, finally compiled and ran a program (more tutorials should start with these instead of typing stuff into an interpreter)
02:26:48 <dolio> There's no backtracking.
02:26:53 <Kaidelong> the one defined in the report supposedly is turing complete
02:26:58 <merijn> dolio: Well, just plain Haskell types aren't, obviously
02:27:00 <Kaidelong> err not lewis
02:27:08 <Kaidelong> I meant winxordie
02:27:29 <winxordie> oh, gotcha
02:28:07 <winxordie> though I am curious as to how GHC decides decidability
02:28:08 <lewis1711> so haskell has type inference. I have seen code where one specifically defines what types the funciton takes is input, and returns as ouput. what is this called so i can look it up
02:28:22 <Kaidelong> it's called a type signature
02:28:38 <lewis1711> ty
02:28:41 <Kaidelong> if you want to see what type has been inferred for something you can use the ":t " command
02:28:51 <sipa> :t map
02:28:52 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
02:30:32 <merijn> lewis1711: Its considered good practice to manually write out the types for your main functions so you can verify your expectations with reality :p
02:31:02 <lewis1711> merijn: yeap, I'm a very paranoid programmer generally, so that makes sense to me
02:31:22 <Jafet> Unless they involve mt stacks
02:31:37 <sipa> mt?
02:32:00 <Kaidelong> merijn: it's also a good idea because there are lots of useful type system extensions which seriously mess up type inference. Not to mention the monomorphism restriction
02:32:27 <Jafet> @quote monad.transformer
02:32:28 <lambdabot> BMeph says: The Id monad is used to express subliminal desires to make Monad Transformers act like Monads... ;p
02:33:09 <merijn> It is always useful to supplicate Dread God Murphy to be forgiving when type checking your program :>
02:36:21 * hackagebot fuzzytime 0.1.1 - Print current time in a more casual way  http://hackage.haskell.org/package/fuzzytime-0.1.1 (KamilStachowski)
02:37:27 <lewis1711> ok I am not quite getting these type signatures... function::Int->Int->Int .... takes two Ints as input, and outputs one? so the last type is always the output, since a function has to return a unique result?
02:38:44 <ClaudiusMaximus> f :: Int -> Int -> Int  is  f :: Int -> (Int -> Int)  which means it is a function that takes one Int, and gives you a function that takes another Int, which gives you an Int
02:38:53 <Kaidelong> lewis1711: blame Schonfinkel
02:39:14 <Kaidelong> basically we do not believe in multiple parameters for functions
02:39:19 <Kaidelong> all functions take one parameter
02:39:37 <Kaidelong> Int -> Int -> Int is the same thing as Int -> (Int -> Int)
02:39:55 <Kaidelong> > :t ((+)(5))
02:39:56 <lambdabot>   <no location info>: parse error on input `:'
02:39:59 <Kaidelong> :t ((+)(5))
02:40:01 <lambdabot> forall t. (Num t) => t -> t
02:40:06 <Kaidelong> :t ((+)(5))(3)
02:40:07 <lambdabot> forall t. (Num t) => t
02:40:08 <lewis1711> so taking a simple function like addition... you believe that addition is infact two functions?
02:40:24 <Kaidelong> addition is a function from a number to a function from a number to a number!
02:40:32 <merijn> lewis1711: No, it is a function that takes a number and then returns a function which again takes a number to return a number
02:40:53 <merijn> :t (+) :: Int
02:40:54 <lambdabot>     Couldn't match expected type `Int'
02:40:54 <lambdabot>            against inferred type `a -> a -> a'
02:40:54 <lambdabot>     In the expression: (+) :: Int
02:40:58 <merijn> hmm
02:41:16 <merijn> ah, was already typed above anyway I see
02:41:28 <lewis1711> that. is seriously weird:)
02:41:34 <amishaa> :t 5
02:41:35 <lambdabot> forall t. (Num t) => t
02:41:49 <lewis1711> what is this theory called?
02:41:50 <merijn> lewis1711: It's fairly natural when you're coming from the lambda calculus
02:42:07 <lewis1711> that all functions take one argument
02:42:15 <ClaudiusMaximus> :t curry
02:42:16 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
02:42:20 <Kaidelong> http://en.wikipedia.org/wiki/Currying
02:42:21 <merijn> lewis1711: Schonfinkel/Currying
02:42:54 <scree> functions only take one argument in any formulation
02:43:03 <scree> it's just sometimes that argument is a tuple
02:43:45 <lewis1711> scree: that is more to my thinking
02:44:16 <Kaidelong> lewis1711: usually we don't use tupled arguments since currying can be very convenient at times
02:44:32 <merijn> lewis1711: Since your a mathematician anyway (and thus hopefully not scared by various calculi) I think it's enlightening to take a look at the untyped or simply typed lambda calculus
02:44:32 <lewis1711> though that currying article was very intriguing
02:45:05 <scree> lewis1711: you're a mathematician?
02:45:12 <amishaa> @pl \x->x
02:45:12 <lambdabot> id
02:45:14 <lewis1711> I have been meaning to. haskell is a sort of lambda calculus as a computer language?
02:45:23 <lewis1711> scree: no. undergrad maths major
02:45:30 <Kaidelong> > let errors = evalRand (mkStdGen 6) (replicateM 10 (getRandomR (0,0.6))) in sqrt . sum (map (^2) errors)
02:45:30 <amishaa> @pl \x->x*x
02:45:30 <lambdabot> join (*)
02:45:31 <lambdabot>   Couldn't match expected type `Control.Monad.Random.Rand g a'
02:45:31 <lambdabot>         agains...
02:45:38 <merijn> lewis1711: It is heavily inspired by various lambda calculi, yes
02:45:50 <scree> in that case curried funcions should still make sense to you in a mathematical context
02:45:58 <Kaidelong> :more
02:46:04 <Kaidelong> @more
02:46:24 <lewis1711> they do
02:46:33 <amishaa> :t join (*)
02:46:34 <lambdabot> forall a. (Num a) => a -> a
02:46:36 <Kaidelong> > let errors = flip evalRand (mkStdGen 6) (replicateM 10 (getRandomR (0,0.6))) in sqrt . sum (map (^2) errors)
02:46:38 <lambdabot>   No instances for (GHC.Real.Fractional (f a),
02:46:38 <lambdabot>                    System.Rand...
02:46:40 <lewis1711> but they are a new way to think of them
02:46:41 <scree> even for the set-theoretic definition of a function, the set of functions A -> (B -> C) and (A x B) -> C have a natural bijection
02:47:10 <amishaa> :t join(*)2
02:47:11 <lambdabot> forall a. (Num a) => a
02:47:13 <scree> equivalently, (A^B)^C === A^(BxC)
02:47:19 <lewis1711> scree: you are saying those two expressions are equivalanet?
02:47:29 <Chaze> is there some Bool -> Int function?
02:47:32 <lewis1711> (A x B) - > == A -> (B -> C)
02:47:47 <scree> lewis1711: no, but there's a very natural bijection
02:47:50 <ClaudiusMaximus> > map fromEnum [False ..]
02:47:52 <lambdabot>   [0,1]
02:48:04 <dolio> It's actually not true in Haskell that (A, B) -> C is isomorphic to A -> B -> C.
02:48:12 <dolio> So it works out better in set theory.
02:48:24 <Chaze> ClaudiusMaximus: thanks
02:48:51 <lewis1711> currying is not consistent with set theory?!
02:49:06 <Kaidelong> it isn't?!
02:49:11 <Kaidelong> oh
02:49:15 <scree> it is!!
02:49:30 <lewis1711> don't scare me like that scree
02:49:33 <lewis1711> :D
02:49:42 <Kaidelong> Oh wait thinking of haskell types in terms of sets didn't work for some reason did it?
02:49:55 <Kaidelong> I think it had to do with _|_ making life hard for everyone
02:50:06 <scree> that's what dolio is referring to, yes
02:50:10 <ddarius> @hoogle when
02:50:11 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
02:50:31 <lewis1711> why can't they be thought of in terms of sets?
02:50:42 <Kaidelong> it's somewhere in the haskell wikibook
02:50:45 <Kaidelong> let me see if I can find it
02:51:03 <scree> lewis1711: they can, you just have to add this extra element _|_ to every set
02:51:04 <dolio> There is no non-trivial set theoretic model of the polymorphic lambda calculus.
02:51:58 <lewis1711> what is _|_? (hard to google for, you understand)
02:52:21 <scree> lewis1711: _|_ is the "value" we give to computations that don't terminate, errors &c.
02:52:33 <dolio> Types in Haskell are more like lattices, and functions are order-preservine.
02:52:44 <engla> _|_ is called "bottom", right?
02:52:48 <dolio> Preserving, even.
02:52:48 <scree> BTW this is *not* a priority if you're just looking to understand currying ATM
02:52:48 <Kaidelong> http://en.wikibooks.org/wiki/Haskell/Denotational_semantics#Na.C3.AFve_Sets_are_unsuited_for_Recursive_Definitions
02:53:01 <lewis1711> *click*
02:53:23 <lewis1711> scree: nope
02:53:47 <Taejo> dolio: but if we have an order-preserving map between lattices we can surely forget the lattice structure and obtain a set-map?
02:53:48 <Kaidelong> lewis: seems to basically be saying you can define a type that has undefined cardinality if you look at it as a set
02:54:58 <lewis1711> doesn't haskell allow infinite lists and the like, due to lazy evaluation?
02:55:26 <Taejo> dolio: though I see that the lattice structure is valuable to see how to turn equational definitions into functions
02:55:26 <Kaidelong> yes
02:55:30 <Kaidelong> > [1..]
02:55:31 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
02:56:01 <Kaidelong> :t getRandoms
02:56:02 <lambdabot> forall (m :: * -> *) a. (MonadRandom m, Random a) => m [a]
02:56:27 <Kaidelong> hmm
02:56:29 <scree> Taejo: if you throw away the lattice structure, you might end up writing nonsense functions, right?
02:56:31 <Kaidelong> now I'm curious
02:56:43 <Kaidelong> :t evalRand
02:56:44 <lambdabot> forall g a. (RandomGen g) => Rand g a -> g -> a
02:57:10 <Kaidelong> > evalRand getRandoms (mkStdGen 6) :: [Bool]
02:57:11 <lambdabot>   [True,True,False,True,False,False,False,True,True,False,False,True,True,Fal...
02:57:17 <Kaidelong> wow that actually worked
02:57:24 <Kaidelong> I suspected it would hang
02:57:36 <Kaidelong> perhaps it does for evalRandIO?
02:57:58 <Jafet> @quote randomRIO
02:57:59 <lambdabot> <kmc> says: head [] = peek . intPtrToPtr . fromIntegral . unsafePerformIO . randomRIO $ (0, 2^32)
02:58:04 <lars9> how to describe "one or more" or "a non-emtpy list" in a data structure?
02:58:12 <lars9> * in a type
02:58:23 <dolio> (a, [a])?
02:59:11 <Taejo> scree: well the lattice theory stuff will tell you why f x = f x defines one function while f x = x defines another, even though both are true equations if f is the identity function
02:59:58 <scree> Taejo: oh, I see your point
03:00:32 <scree> Taejo: I was also thinking that if you "throw away" the lattice structure, you end up not knowing why (f () = True; f _|_ = False) isn't a valid function
03:01:06 <Taejo> oh I see -- though I would use "computable" instead of "valid"
03:01:14 <scree> right
03:01:49 <Jafet> _|_ isn't really a value, it's a denotation of no value
03:01:56 <Jafet> Strictly speaking, () has one value
03:02:30 <Taejo> Jafet: well if you want to view functions as set maps you need to have _|_ in your sets
03:03:13 <ddarius> What is or isn't a value is something you define when giving a (denotational) semantics.  In Haskell, _|_ is quite definitely a value.
03:03:15 <Jafet> If you care about computing them, yes
03:03:23 <Kaidelong> scree: isn't f () = true; f _|_ = false just restating the halting problem?
03:03:36 <Kaidelong> I dunno why it should be invalid, it's just not computable without a hypercomputer?
03:05:20 <scree> well (I guess) the lattice theory stuff Taejo was talking about distinguishes such halting-functions as exactly those which aren't order-preserving
03:05:32 <dolio> Yes.
03:05:38 <ddarius> Also, the polymorphism is not set-theoretic stuff isn't to say you can't model the polymorphic lambda calculus with sets, it's just that you can't simply use types = (plain) sets, and functions = (plain) set functions.
03:05:55 <dolio> _|_ <= (), so f _|_ <= f (), but false </= true
03:05:56 <ddarius> If you really couldn't model the polymorphic lambda calculus at all with set theory, that would be a foundations shaking result.
03:06:31 <Jafet> Kaidelong: then again, an nth-level hypercomputer cannot see bottom_n
03:06:50 <Kaidelong> yeah, sounds a lot like the incompleteness theorem
03:07:08 <Kaidelong> even if you have some model to deal with the liar's paradox that model gets its own liar's paradox
03:07:26 <Kaidelong> so long as you admit recursion at least
03:07:50 <dolio> And, right. The complete partial orders or coherence spaces or whatever you want to use as your model for the polymorphic lambda calculus can be constructed using sets.
03:07:50 <Taejo> scree: no, all non-order-preserving functions are uncomputable, but there are uncomputable order-preserving functions
03:08:03 <lewis1711> what is the relationship between _|_ and the Infinity type? from what I've read I would expect 1/0 to return _|_
03:08:16 <Kaidelong> > 1/0
03:08:17 <lambdabot>   Infinity
03:08:21 <Jafet> > 1/0 :: CReal
03:08:25 <lambdabot>   mueval-core: Time limit exceeded
03:08:47 <Kaidelong> > -1/0
03:08:48 <lambdabot>   -Infinity
03:08:54 <Kaidelong> > 0/0
03:08:55 <lambdabot>   NaN
03:09:27 <scree> Taejo: right, I made the fuzzier statement that non-order-preserving ones are those which "attempt to solve the halting problem"
03:09:43 <Jafet> lewis: be careful with the word "return". An expression which doesn't compute has a denotation of _|_, but clearly it won't ever "return" a normal value.
03:09:56 <scree> Taejo: there are still presumably uncountably many order-preserving functions
03:09:59 <Taejo> scree: I would roughly agree with that
03:10:02 <Jafet> (If "return" means "evaluates to")
03:10:30 <lewis1711> right, because 1/0 can't really evaluate at all
03:10:59 <Jafet> 1/0 evaluates fine with IEEE floating point, as shown above
03:11:01 <Kaidelong> well 1/0 in the sense haskell understands it by default is defined and computable
03:11:17 <Kaidelong> > (2/0) == (1/0)
03:11:18 <lambdabot>   True
03:11:21 <lewis1711> :|
03:11:54 <scree> That's a mystery of IEEE, not of haskell
03:12:03 <Jafet> > let bottom = (1 :: Int) + bottom in bottom -- this does not evaluate
03:12:07 <lambdabot>   mueval-core: Time limit exceeded
03:12:26 <Kaidelong> scree: it can be quite convenient at times
03:12:52 <Kaidelong> > 5 `div` 0 --on the other hand
03:12:53 <lambdabot>   *Exception: divide by zero
03:13:11 <Kaidelong> same with rationals
03:13:35 <Kaidelong> > 5 / 0 :: Rational
03:13:36 <lambdabot>   *Exception: Ratio.%: zero denominator
03:14:44 <ddarius> scree: It depends on what these order-preserving functions are functions between.
03:15:56 <ddarius> For, PCF, there are sound and fully abstract models which means you can write a program for every element in the relevant domains and there are only countably many programs.
03:22:27 <int-e> @type foldr flip return
03:22:28 <lambdabot> forall a (m :: * -> *). (Monad m) => [a -> (a -> m a) -> m a] -> a -> m a
03:42:31 <ddarius> > 1000000/24
03:42:32 <lambdabot>   41666.666666666664
03:43:51 <knobo> what is the "forall..." thing?
03:46:08 <jkff> Hi. Looks like haskell.org/gtk2hs is down . Anyone know where else can I get the installer bundle for Windows? Are there any mirrors?
03:46:15 <jkff> I need it rather urgently :(
03:46:28 <luite> jkff: you don't need an installer anymore, since you can install it using cabal-install now
03:46:51 <jkff> Oh, cool
03:46:52 <jkff> Let's try
03:46:54 <jkff> Thanks
03:46:55 <dcoutts_> jkff: installer bundle is on sourceforge site
03:47:17 <dcoutts_> jkff: aye, you probably only need the installer if you're on windows
03:47:52 <luite> jkff: you need a few things first, download the gtk complete bundle for windows (from the gtk site), extract it somewhere and add its bin directory to your %PATH%
03:48:01 <luite> jkff: then cabal install gtk2hs-buildtools
03:48:10 <luite> jkff: and then you should be able to install any gtk package you need
03:48:31 <jkff> Thanks again!
04:10:24 <m3ga> @hoogle sortBy
04:10:24 <lambdabot> Data.List sortBy :: (a -> a -> Ordering) -> [a] -> [a]
04:19:08 * hackagebot monad-stlike-io 0.2.2 - ST-like monad capturing variables to regions and supporting IO.  http://hackage.haskell.org/package/monad-stlike-io-0.2.2 (TaruKarttunen)
04:19:32 <Eduard_Munteanu> Wow what's that?
04:20:34 * Eduard_Munteanu thinks IRC really leads to procrastination.
04:21:42 <lewis1711> tommorow I think I may try and define a polynomial type in haskell. and if someone says it's already been done, i am going to cry
04:22:22 <sipa> it would be very surprised if no one did
04:22:34 <sipa> nonetheless, you may learn a lot from trying
04:22:58 <JuanDaugherty> *surprising 
04:23:22 <JuanDaugherty> *had
04:23:27 <sipa> JuanDaugherty: actually, i intended to say "i would"
04:23:53 <JuanDaugherty> sipa, Acknowledged.
04:53:01 <danr> lewis1711: http://www.haskell.org/haskellwiki/Blow_your_mind#Polynomials
05:09:25 <Kaidelong> Control.Concurrent.Spawn looks really nice and simple
05:24:48 <tromp_> wiku4hgr
05:25:56 <yiannis_t> does anybody know if ghc implements Tail Call Optimization (TCO) ?
05:26:12 <hpc> it does
05:27:24 <Botje> yiannis_t: it does, but not in the way you expect it to
05:27:41 <Kaidelong> yiannis_t: if you're asking you've probably run into a problem of excess laziness
05:28:05 <Saizan> @wiki Stack overflow
05:28:06 <lambdabot> http://www.haskell.org/haskellwiki/Stack_overflow
05:29:06 <yiannis_t> Kaidelong: you are probably right! i am examining a simple implementation of Pythagorian Triads with Simple Recursion and Taill Recursion
05:29:12 <Kaidelong> yiannis_t: foldl and foldl' are both tail recursive but in some situations one of them will build stack while the other won't, that's most likely why you're asking
05:29:14 <yiannis_t> and tail recursion is slower
05:29:26 <Kaidelong> it shouldn't be
05:29:29 <Kaidelong> could you post your code?
05:29:38 <Kaidelong> (unless there is something magical going on)
05:29:48 <Saizan> rules: 1) don't use tail calls if you can lazily produce your result instead 2) if you can't, make sure you're strict in the accumulator
05:30:05 <yiannis_t> Kaidelong: yeah sure. wait...
05:30:24 <Saizan> tail recursion can easily be slower as a corollary of 1)
05:31:31 <yiannis_t> Kaidelong: http://hpaste.org/42126/pythagorian_triads
05:32:59 <Kaidelong> yiannis_t: you're benefiting off of cons' laziness it seems
05:33:16 <Kaidelong> the version above is still tail recursive for all intents and purposes
05:34:07 <Kaidelong> yiannis_t: think of the version above as saying "return (a,b,c) then move onto the next computation"
05:34:22 <Kaidelong> like coroutines in C#/Icon/Python etc
05:34:32 <yiannis_t> Kaidelong: you think that's because of the lazyness?
05:34:57 <Kaidelong> > take 1 [1, 5, undefined]
05:34:58 <lambdabot>   [1]
05:35:24 <Kaidelong> > [1, 5, undefined]
05:35:25 <lambdabot>   [1,5,*Exception: Prelude.undefined
05:35:37 <yiannis_t> Kaidelong: yeah i know that! : ) the implementation should be faster if i force strict evaluation of the accumulator?
05:35:44 <yiannis_t> lets try it out! 
05:35:48 <Kaidelong> yiannis_t: No!
05:35:53 <yiannis_t> :S
05:35:58 <Kaidelong> your "naive" version is better, here
05:36:29 <Kaidelong> lists in haskell aren't really data structures so much as umm, computations, like java iterators
05:36:51 <Kaidelong> you aren't making building stack in your naive version
05:37:10 <Kaidelong> you're returning a computation that says "return (a,b,c) then run the computation in the tail"
05:37:32 <yiannis_t> Kaidelong: yes you are right. i 'see' it knoe!
05:38:06 <yiannis_t> but how could i compare tail and no-tail recursion! maybe force strictness in non-tail ?
05:38:16 <Kaidelong> I think that'd make it even worse!
05:38:18 <Kaidelong> but you could try
05:38:57 <yiannis_t> Kaidelong: the purpose of this code is to try to found out (by means of time performance) the optimizations that GHC implements
05:39:05 <yiannis_t> so i should try some versions! : )
05:39:16 <yiannis_t> thank you!
05:39:38 <Kaidelong> this has more to do with lists than GHC itself, I think
05:39:58 <hpc> apparently GHC doesn't optimize, by default
05:40:27 <yiannis_t> hpc: i use -O3 in compilation
05:41:32 <Saizan> redefining the thing with list comprehensions might trigger more optimizations
05:41:33 <Kaidelong> anyway the message to take home here is basically that laziness tends to blur data structures with control structures
05:42:38 <Kaidelong> Control.Iterator or something might be a good name for Data.List
05:43:52 <yiannis_t> Saizan: i have already done that! and it is much faster.. 
05:43:59 <Jafet> But List isn't about iterators, and not all iterators are lists!
05:44:14 <hpc> also, nouning verbs is a bad habit to get into
05:44:21 <hpc> it's how java came about, donchaknow
05:44:58 <Kaidelong> well the context was that lazy data structures often behave like control structures
05:45:06 <Kaidelong> so you can see them in both ways, sort of
05:45:24 <Jafet> Most fun languages do implement control structures that way
05:45:35 <hpc> i like to think of it as the typeclasses being the control structures
05:45:49 <hpc> and the data structures being a particular implementation of the control structure
05:46:28 <Kaidelong> hpc: I did something the opposite of that recently. The class allowed you to define computations for backtracking algorithms but the actual backtracking scheme used depended on the implementation of the class
05:46:51 <Jafet> Remember what Alan Perlis said... ten accessors on one State. Or something along those lines
05:47:02 <Kaidelong> an elaborate way to do N-Queens either breadth or depth first
05:47:14 <Kaidelong> with a single implementation of N-Queens
05:47:35 <Jafet> Kaidelong: that sounds like you did exactly what hpc said
05:47:48 <Kaidelong> oh
05:47:54 <Kaidelong> yes it does now that I read it again
05:48:24 <hpc> it separates control and data as much as possible
05:48:38 <hpc> and lends some weight to my assertion that Control.* should be almost entirely typeclasses
05:56:02 <ManateeLazyCat> Emacs/vi user sorry : http://www.flickr.com/photos/48809572@N02/5237505999/lightbox/
06:18:14 <ManateeLazyCat> @tell juhp_ You suggest me add vte terminal in Manatee, i was refuse that, because VTE widget is not MVC design. But i think you're right : "Not perfect better than Nothing", why not bring "not perfect" terminal in Manatee until we finish *perfect terminal". Looks manatee-terminal package. :)
06:18:14 <lambdabot> Consider it noted.
06:18:43 <ManateeLazyCat> @tell juhp_ Also see picture : http://www.flickr.com/photos/48809572@N02/5237505999/lightbox/
06:18:44 <lambdabot> Consider it noted.
06:18:45 * hackagebot manatee-terminal 0.0.6 - Terminal Emulator extension for Manatee.  http://hackage.haskell.org/package/manatee-terminal-0.0.6 (AndyStewart)
06:19:01 <ManateeLazyCat> Enjoy all! :)
06:19:47 * hackagebot manatee 0.1.3 - The Haskell/Gtk+ Integrated Live Environment  http://hackage.haskell.org/package/manatee-0.1.3 (AndyStewart)
06:20:07 <Kaidelong> ManateeLazyCat: Could you sell Manatee to me? I looked at it recently and didn't really get the point
06:20:45 <ManateeLazyCat> Kaidelong: http://haskell.org/haskellwiki/Manatee
06:20:47 <Kaidelong> looks to me like it's one of those tiling window managers but you say it isn't a window manager?
06:21:04 <ManateeLazyCat> Kaidelong: Also watch video :  http://www.youtube.com/watch?v=weS6zys3U8k
06:21:14 <Kaidelong> oh that's what I watched yes
06:21:21 <gds> Kaidelong: My impression of manatee is that it aims to do for haskell what emacs does for lisp.
06:21:23 <ManateeLazyCat> Kaidelong: It's not WM, not IDE, but include WM, and IDE
06:21:58 <Kaidelong> gds: so a swiss army chainsaw, basically?
06:21:59 <ManateeLazyCat> Kaidelong: It's new software, include everything, in aim. :)
06:22:17 <Kaidelong> okay
06:22:28 <Kaidelong> sounds frightening!
06:23:11 <jao> ManateeLazyCat: is Manatee scriptable in haskell in the same way as Emacs is scriptable in Elisp?
06:23:22 <ManateeLazyCat> jao: Still in developing
06:23:36 <ManateeLazyCat> jao: Will bring in manatee-0.1.4
06:23:48 <jao> ManateeLazyCat: excellent
06:24:09 <ManateeLazyCat> jao: I will use new way than Emacs's solution.
06:25:28 <jao> ManateeLazyCat: it'll be interesting to see how you manage that :)
06:25:46 <ManateeLazyCat> jao: Extension API still in coding
06:25:58 <ManateeLazyCat> jao: After that, i will create some site like "Firefox extension center"
06:26:19 <ManateeLazyCat> jao: Everyone can use extension API develop it's own extension and don't need my permission
06:26:47 <jao> ManateeLazyCat: good. are you using any plugin library?
06:27:10 <ManateeLazyCat> jao: I have create pdynload package, but not perfect, new code in testing
06:27:13 <ManateeLazyCat> @package pdynload
06:27:14 <lambdabot> http://hackage.haskell.org/package/pdynload
06:27:16 <ManateeLazyCat> jao: ^^^^^
06:28:43 <jao> ManateeLazyCat: ah, i see. thanks for the pointer.
06:29:13 <ManateeLazyCat>  jao: pdynload is not perfect, i perhaps will drop it in the future. :)
06:30:51 <jao> fair enough :)
06:40:49 <jro> There is no available version of ghc that satisfies -any
06:41:06 <jro> from where I should start to resolve this?
06:41:14 <jro> cabal install test-framework-quickcheck2
06:41:21 <jro> fromCommand
06:42:23 <Saizan> jro: what does "ghc-pkg list ghc" says?
06:43:02 <jro> $ ghc-pkg list ghc
06:43:02 <jro> /usr/lib/ghc-6.12.1/package.conf.d
06:43:03 <jro> /home/jro/.ghc/i386-linux-6.12.1/package.conf.d
06:43:40 <Saizan> ok, so you lack the "ghc" package, you only have ghc the compiler, not the library that exposes its API
06:43:55 <Saizan> i guess you installed your ghc via your distro package manager?
06:44:03 <Saizan> it should also have a package for this library
06:44:15 <jro> yes
06:44:20 <Saizan> e.g. libghc6-ghc-dev on debian, iirc
06:46:20 <paolino> I'd like to have comments on this snippet http://pastebin.com/Dka7HGzw
06:47:01 <paolino> last instance makes me wonder there is something wrong in the idea
06:47:15 <mux> paolino: identifiers written in italian is the very first thing that comes to my mind
06:47:18 <mux> I hate this with a passion
06:47:26 <paolino> ops
06:47:40 <paolino> I'll translate sorry
06:48:01 <mux> I fight with my colleagues pretty much eveyr day to have them stop using french similarly
06:48:25 <paolino> right
06:54:11 <paolino> http://pastebin.com/ahHExwax
07:00:37 <Axman6> [A
07:00:39 <Axman6> [A
07:00:55 <Axman6> [A
07:00:59 <Axman6> urgh
07:01:09 <copumpkin> argh
07:01:14 <copumpkin> [U
07:01:14 <copumpkin> [U
07:01:15 <copumpkin> [U
07:02:15 <sipa> i concur
07:02:36 <Zao> i ncur
07:08:43 <kniu> I want a implementation of Haskell in which I can know exactly what the machine is doing.
07:09:09 <bremner> so, no lazyness then?
07:09:20 <sipa> run it in a CPU emulator
07:09:28 <sipa> you'll know everything, exactly :)
07:14:25 <merijn> Sounds like a recipe for making everything hard
07:18:13 <Axman6> [A
07:48:17 <Alan> maybe you get this question a lot but... hugs vs. ghci? which should I be using?
07:49:00 <afilatun> see http://haskell.org/haskellwiki/Implementations
07:49:07 <Saizan> ghci,
07:49:08 <Kaidelong> well I imagine most of us use GHC, I don't know much about the limitations and advantages of Hugs...
07:52:26 <merijn> Alan: The amount of haskell programmers that don't use GHC is delta (if not epsilon)
07:54:05 <Alan> merijn: i see
07:58:16 * hackagebot stepwise 1.0.1 -   http://hackage.haskell.org/package/stepwise-1.0.1 (ArieMiddelkoop)
07:59:17 * hackagebot uuagc 0.9.34 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-0.9.34 (ArieMiddelkoop)
08:04:05 <lars9> @src when
08:04:06 <lambdabot> when p s = if p then s else return ()
08:05:36 <tromp_> isnt that the same as   guard p;s  ?
08:06:05 <tromp_> hmm, not quite
08:06:20 <magicman> No. "when p s; r" will always reach "r"
08:06:30 <magicman> (unless continuation magic, but meh)
08:06:46 <magicman> (or errors and such)
08:07:32 <paolino> @src guard
08:07:32 <lambdabot> guard True  =  return ()
08:07:32 <lambdabot> guard False =  mzero
08:07:47 <paolino> :t guard
08:07:48 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
08:08:12 <magicman> :t \p s -> (when p s, guard p >> s)
08:08:13 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m () -> (m (), m ())
08:08:21 <magicman> Heh.
08:10:28 <tromp_> guard False; print "yo!"
08:10:32 <tromp_> > guard False; print "yo!"
08:10:34 <lambdabot>   <no location info>: parse error on input `;'
08:10:46 <tromp_> > guard False >> print "yo!"
08:10:47 <lambdabot>   <IO ()>
08:12:10 <tromp_> > (guard False >> print "yo!") >> print "heh"
08:12:12 <lambdabot>   <IO ()>
08:12:35 <tromp_> > (when False (print "yo!")) >> print "heh"
08:12:37 <lambdabot>   <IO ()>
08:13:36 <testerdude> how can I overload TypeConstructors ? ex: data Expression = Expr Int | Expr String
08:13:42 <Kaidelong> tromp_: lambdabot will not perform IO actions
08:14:53 <Kaidelong> testerdude: you can't. Overloading in haskell isn't meant to allow things like that.
08:15:12 <testerdude> any work around ?
08:15:23 <tromp_> what would be the type of Expr?
08:15:44 <Kaidelong> testerdude: this is not something you'd want to work around. What are you trying to do?
08:16:00 <testerdude> I am trying to write a parser 
08:17:38 <testerdude> I want to define type expression combination of two EXISTING types
08:17:53 <tromp_> :t quickCheck
08:17:54 <lambdabot> forall prop. (Testable prop) => prop -> IO ()
08:17:57 <Kaidelong> "Either String Int"
08:19:35 <testerdude> ok there it is BNF :  expr ::= Number | Add expr expr | Mul expr expr
08:20:13 <testerdude> if I have types: Number, Add a b ,  Mul a b
08:21:49 <Kaidelong> testerdude: you might be looking for GADTs
08:21:55 <testerdude> yep
08:22:01 <Parmenides> I really like Haskell you guy
08:22:02 <Parmenides> s
08:22:14 <Kaidelong> presumably that is why you are here
08:22:16 <testerdude> but is there overloading in GADTs ?
08:22:23 <Parmenides> alot of immutable objects
08:22:32 <Parmenides> nothing changing
08:22:37 <Parmenides> <3
08:23:04 <testerdude> parmenides , in fact there is no object and everything is immutable ;)
08:23:13 <paolino> explicited time
08:23:27 <Kaidelong> testerdude: the whole point behind using the ADT is to put unique labels on things, overloading would thwart the point. But you could use some other ADT as the type or something like Either?
08:23:43 <Kaidelong> IE you could make something like
08:24:01 <Kaidelong> data Exp = Number Int | Error String
08:24:31 <Kaidelong> and then give "data Expr = Value Exp | Add Expr Expr" ... etc
08:28:20 <unkanon> does anyone here know anything about literate haskell with latex notation?
08:28:56 <Kaidelong> unkanon: I've written a couple of lhs2TeX things
08:29:05 <Kaidelong> so I might be able to help
08:29:37 <unkanon> well I'm just trying to understand the motivation
08:29:56 <unkanon> I don't know much about latex but doesn't a .tex file have to be compiled to be viewable?
08:30:14 <Kaidelong> yes
08:30:29 <Kaidelong> you preprocess the LHS into TeX and compile that
08:30:30 <unkanon> I guess I should just ask: if I write literate haskell with latex, can I have the very same file be both compilable and viewable?
08:30:55 <Kaidelong> the LHS can be compiled by haskell and turned into a TeX file by lhs2TeX
08:31:06 <testerdude> but overloaded typeconstructors would help much in some for of ad-hoc polymorphism !  ex: data Expression = Expr Int | Expr String | Nothing       display :: Expression -> String    display (Expr a) = show a      display Nothing =  "Error"
08:31:12 <Kaidelong> which can then be compiled with latex and exported using something like dvipdfm
08:31:26 <testerdude> *form
08:31:46 <Kaidelong> testerdude: but then how do you type "Expr"?
08:32:00 <unkanon> Kaidelong: right, that's what I thought. so I can never have a pretty viewable file that is also compileable?
08:32:38 <unkanon> in that sense it's very different from lhs miranda style, with the >
08:32:43 <Kaidelong> unkanon: Nope! There have been some efforts in that area though, like MS' asmL
08:32:59 <unkanon> because with > the very same file is intended to be viewable and compileable
08:33:05 <unkanon> oh I understand now.
08:33:15 <Kaidelong> unkanon: you can still view the LHS source code like any other LHS file
08:33:18 <kosmikus> unkanon: I don't understand your point.
08:33:23 <testerdude> data Expression where  Expr :: Int -> Expression    Expr:: String -> Expression  Nothing :: Expression
08:33:37 <Kaidelong> unkanon: but it's not like writing your code in MS word, if that's what you are after
08:33:41 <unkanon> right, but I'll be looking at the markup latex and not the pretty output
08:33:50 <unkanon> Kaidelong: yeah I was after that :)
08:34:05 <testerdude> anyway I believe Haskell doesn't support overloading 
08:34:14 <Kaidelong> unkanon: from experience, you won't miss the WSIWYG
08:34:32 <Kaidelong> testerdude: haskell supports a restricted form of ad-hoc overloading through typeclasses
08:34:49 <jmcarthur> unkanon: i use bird-style lhs with markdown. very readable
08:34:52 <Kaidelong> other than that haskell avoids ad-hoc polymorphism as much as possible by design
08:34:54 <unkanon> Kaidelong: well I was just thinking how pretty it would be to write code for a neural network and still being able to know what math formulas each function represents (in math notation)
08:35:10 <jmcarthur> unkanon: if you use pandoc markdown you even get access to latex math
08:35:22 <testerdude> kaidelong: why is that ? inference engine ?
08:35:26 <Kaidelong> unkanon: I'd say use lhs2TeX, it's easy enough to recompile the DVI while you are modifying the code
08:35:32 <Kaidelong> testerdude: that and soundness
08:35:57 <Kaidelong> typeclasses already break type inference in some situations
08:35:59 <unkanon> jmcarthur: what's markdown?
08:36:27 <jmcarthur> unkanon: http://jake.devio.us/starter/PlanetWars.lhs  generated  http://jake.devio.us/starter/PlanetWars.html
08:36:36 <testerdude> kaidelong: can you give me an example of overloading by typeclass
08:37:03 <unkanon> jmcarthur, Kaidelong: I'll take a look at those suggestions, thanks!
08:37:10 <jmcarthur> unkanon: you will see a few parts of the lhs file that start with "~~~". that is not actually markdown. the rest is, though
08:37:34 <jmcarthur> unkanon: make sure to look into pandoc. its flavor of markdown supports syntax highlighting for haskell and it has many nice export formats
08:37:41 <jmcarthur> unkanon: you can even get it to work with lhs2tex
08:37:50 <Kaidelong> testerdude: sure, PM me email addr and I can send you something I did recently where I use that kind of overloading
08:38:24 <Kaidelong> testerdude: the overloading is done in "instance" declarations, essentially
08:41:23 <unkanon> jmcarthur: that's cool
08:41:58 <unkanon> I'll look at pandoc definitely
08:45:09 <applicative> Alan, #haskell people tend to run down Hugs. If you use it a while you'll want to get ghc, that's all that should be said. 
08:47:49 <sleepynate> hugs will make you feel more warm and fuzzy than ghc, it's true.
08:48:00 <EvanCarroll> Why is that?
08:48:26 <sleepynate> um hello, who doesn't love hugs?!
08:48:32 * Zao hugs
08:48:32 <applicative> It's still nearly always easier to install, that's the decisive argument for it.  ghc is a torment unless you have deep knowledge of your os
08:48:37 * sleepynate hugs back
08:49:01 <kmc> i don't find 'apt-get install haskell-platform' to be a torment
08:49:05 <kmc> of course it's not always that easy
08:49:07 <kmc> but it often is
08:49:19 <sleepynate> kmc: but what if you want a new library, where does it go?
08:49:27 <sleepynate> especially not one in cabal?
08:49:29 <unkanon> jmcarthur: ok I just realized that your example is *exactly* what I need. so you used pandoc alone for that?
08:49:33 <applicative> kmc, it is possible to teach Haskell to jr high students
08:49:37 <applicative> they dont use apt get
08:49:43 <EvanCarroll> sleepynate: ~/.ghc/
08:50:04 <EvanCarroll> cabal installs to ~/.ghc/
08:50:08 <sleepynate> kmc: and how do you explain Ubuntu breaking Data.Map several months ago?
08:50:19 <sleepynate> EvanCarroll: not if you --global :P
08:50:40 <sleepynate> EvanCarroll: but even still, 'nix nubs don't know what dotfiles are
08:51:30 <applicative> apt get is used by a minute proportion of mankind.  Haskell is a cosmopolitan symbolism that should be available to everyone. 
08:52:11 <kmc> right then
08:52:22 <applicative> you shouldn't be permitted to use apt-get until you have learned Haskell :)
08:54:42 <applicative> E Meijer's lectures on Haskell for whatever that MS site is; they presupposed typical listeners were using Hugs.
08:54:48 <Alan> applicative: fair enough, i just started using ghci and the first thing i noticed is i can now do "import" and "let" in the interpreter... that's pretty significant :|
08:54:48 <Philonous> applicative, All of it? Because that would restrict apt-get to oleg. Maybe.
08:55:25 <applicative> Alan, yes ...
08:55:45 <jmcarthur> unkanon: pandoc with a special build flag (for the syntax highlighting)
08:55:51 <applicative> Alan, ghci has cooler features that way.  It is widely agreed that the hugs error messages are better
08:56:14 <Saizan> but we even have "Download Haskell" buttons that include ghc, and anyhow i've never had a problem with the generic binary tarballs
08:56:15 <applicative> Philonous, I take your point.
08:56:23 <Saizan> even on windows
08:56:50 <Saizan> i think hugs error messages are quite worse than ghci's current ones
08:56:56 <applicative> Saizan, you are an expert.
08:57:17 <Saizan> for a simple reason: hugs typechecks after desugaring
08:57:20 <applicative> I think the point about error messages is true to, when you get outside the prelude
08:57:22 <jmcarthur> i'm with Saizan 
08:57:35 <Saizan> so you get errors that refer to code you've never written.
08:57:36 <jmcarthur> i get really confused when i see the errors on codepad (which uses hugs)
08:57:45 <applicative> jmcarthur, you just don't attend when people come on here with windows problems
08:57:49 <jmcarthur> i'll grant that maybe it's just because i'm not used to it
08:57:57 <Saizan> also, ghc's error messages continue to improve
08:58:02 <jmcarthur> applicative: what does this have to do with windows?
08:58:05 <applicative> jmcarthur, theres a discipline of reading in both cases
08:58:34 <applicative> installing Hugs on windows was formerly childsplay, I'm not sure about the newer windowses.  You even had a gui library
08:58:50 <sleepynate> i think applicative EvanCarroll and kmc have just volunteered to write a wrapper around ghci that has better error messages and make an easy install package for all platforms. thanks guys!
08:59:01 * sleepynate claps
08:59:01 <EvanCarroll> sleepynate: don't get me wrong, I'm not pretending to be the "haskell" guy. I'm probably in the bottom 50% here. But, I still found GHC to be a total breeze to use on debian
08:59:04 <Alan> Saizan: you mean "parse :: GenParser a () b -> SourceName -> [a] -> Either ParseError b
08:59:11 <jmcarthur> i can't really help it that some people choose very crippling dev environments </troll>
08:59:13 <Saizan> installing ghc on windows is child's play too, you have an installed like everything else
08:59:17 <EvanCarroll> Oh, now for the error messages in GHC. I must say those suck.
08:59:33 <applicative> have you been on here when a windows guy was trying to try a little gui business. it's a total chamber of horrors.
08:59:34 <Alan> actually, never mind
08:59:37 <Saizan> the problem is installing other libraries that assume a C toolchain
08:59:41 <jmcarthur> *choose or are forced to use
08:59:49 <applicative> i've manages to build gtk2hs on osx once
08:59:52 <EvanCarroll> I've never worked with a compiler that produced more difficult to parse error messages than Haskell's GHC.
08:59:52 <applicative> managed
09:00:08 <Saizan> applicative: how's that better with hugs? is there even a GUI library that works with hugs?
09:00:14 <jmcarthur> EvanCarroll: g++?
09:00:18 <EvanCarroll> They honestly stupify me entirely 50% of the time, and I usually just end up rewriting code randomly to get tstuff to work.
09:00:18 <applicative> there was on windows yes
09:00:35 <Saizan> was or is?
09:00:38 <applicative> if it was still in development there still would be
09:00:42 <unkanon> jmcarthur: cool, thanks
09:00:47 <EvanCarroll> jmcarthur: used it, and it's not as bad.
09:00:50 <Saizan> yeah, but that's a big if :)
09:01:04 <Alan> how often are there differences between hugs and ghc for the same code?
09:01:12 <sleepynate> EvanCarroll: i'm not a "haskell" guy either... i come from a world of C and CL, and still try to wrap my head around it. ghc installs great on debian, but as soon as you start mucking about with adding cabal packages and whatnot, apt gets confused as to which libs it installs and which cabal has messed with, and then you have weird dependency issues all over. that is unless you install everything just for one user (i.e. ~/.ghc)
09:01:12 <jmcarthur> EvanCarroll: then you haven't used it much. once you start getting c++ template errors, you hate your life if you're stuck with g++
09:01:49 <sleepynate> EvanCarroll: but then you're really just not using apt except for the first install :)
09:01:50 <Alan> jmcarthur: is there a good C++ compiler though?
09:01:51 <zygoloid> jmcarthur: with g++, you can recognise patterns and learn 'this error means i messed up in that way'. the same is true for some -- but not all -- ghc errors in my experience
09:01:58 <zygoloid> Alan: clang is pretty decent
09:01:59 <Alan> I'd agree that C++ template errors are indecipherable...
09:02:06 <jmcarthur> zygoloid: what ghc errors don't work that way?
09:02:09 <Alan> zygoloid: is clang C++ working yet?
09:02:12 <jmcarthur> clang is alright, yeah
09:02:12 <kmc> oh boy flamewar time
09:02:14 <Alan> last time i looked, it's not done
09:02:15 <zygoloid> Alan: yup, since 2.8
09:02:33 <Alan> I have heard that clang is supposed to be much better for errors
09:02:34 <sleepynate> whoa whoa, who said C++ was good either? :D
09:02:34 <zygoloid> jmcarthur: expected 'this type', inferred 'that type'. often miles away from the actual problem.
09:02:36 <EvanCarroll> sleepynate: right. and, that's how it should always work with apt.
09:02:49 <jmcarthur> zygoloid: ah, but there is a discipline you can follow in order to find it
09:02:49 <EvanCarroll> sleepynate: If you think this is bad, don't dare use apt and cpan.
09:03:09 <sleepynate> EvanCarroll: with apt and haskell you mean? you let apt handle all your system C headers don't you?
09:03:15 <EvanCarroll> sleepynate: apt is for distribution of developed programs, it makes a horrible development platform
09:03:18 <Saizan> sleepynate: it's much easier if you make cabal only install as --user
09:03:25 <jmcarthur> all you have to do is add type annotations in a couple places and the ghc will point you in the right direction
09:03:27 <zygoloid> jmcarthur: yes, indeed there is. but the diagnostic alone isn't generally enough for me to understand the problem.
09:03:35 <jmcarthur> i'll grant that
09:03:43 <sleepynate> Saizan: right, but what if i want xmonad to be available to many users over ssh -X ?
09:04:07 <EvanCarroll> sleepynate: That's slightly different, in that scenario its because you installed something with apt that you don't want to compile.
09:04:24 <zygoloid> in fairness, i spend much more time looking at g++ errors than ghc errors, so i don't /expect/ to have as much familiarity with them
09:04:36 <Saizan> sleepynate: xmonad is in debian's repos, no?
09:04:41 <zygoloid> (with the latter, that is)
09:05:06 <sleepynate> Saizan: yep. but don't you dare try to use newer haskell libs with the one in there
09:05:17 <zygoloid> sleepynate: you could install haskell stuff with --global into /usr/local
09:05:36 <jmcarthur> wait, you can run a window manager over ssh -X?
09:05:40 <sleepynate> oh i'm aware, i've got it working just dandy.. but it's not exactly intuitive
09:05:46 <zygoloid> just so long as you never upgrade anything installed with --global ;(
09:05:54 <sleepynate> jmcarthur: you can run whole remote X sessions
09:06:23 <jmcarthur> hmm, actually, i recall doing that once now
09:06:32 <jmcarthur> or something like it at least
09:06:41 <zygoloid> a WM is just an X client which follows a certain protocol, like a compositing manager
09:06:45 <applicative> Saizan, you used to be able to use Hugs with the HasE
09:07:02 <applicative> Haskell School of Expression.  I've never been able to use it except on linux
09:07:19 <jmcarthur> zygoloid: sure. i just didn't realize you could run a window manager remotely. i typically just run specific applications remotely using my local window manager
09:07:40 <kmc> window managers are X clients basically
09:07:40 <jmcarthur> but like i said, i think i remember doing exactly this at some point in the past
09:07:43 <sleepynate> jmcarthur: this is probably quite dumb for you (most of it) and quite old... but here's the idea... http://www.vanemery.com/Linux/XoverSSH/X-over-SSH2.html
09:07:49 <applicative> Saizan good luck reading that book, which is aimed at artists and so forth, with any known operating system
09:08:01 <sleepynate> jmcarthur: (skip down to setup #3)
09:08:38 <applicative> Saizan, the cost of entry is way too high for Haskell now.  I think we can sense the decay coming.
09:08:51 <jmcarthur> sleepynate: okay yeah, i've done this indeed
09:08:53 <Saizan> applicative: i'm just claiming that currently there isn't any incentive to use hugs over ghc, i'm not making statement about the past nor saying that ghc on windows is as good as you can get
09:09:02 <jmcarthur> sleepynate: thanks
09:09:14 <Saizan> applicative: though, the cost of entry for ghc on windows is not as high as you seem to claim
09:09:41 <applicative> Saizan, I've only started using ghc on windows, having come into a windows machine again.  I used hugs last time I had one
09:10:02 <applicative> I would never have been able to learn haskell if I hadn't started before hugs started crashing
09:10:10 <jmcarthur> sleepynate: there's always the arch linux way of doing it. there's a tool to port cabal packages to pacman packages. i'm not sure if such a tool exists for debian
09:10:45 <jmcarthur> sleepynate: and then all you have to do is only use cabal-install for local packages
09:10:52 <applicative> Saizan, you are assuming that Haskell would only have any attraction for a programmer; this is a huge mistake. 
09:11:16 <sm> I don't think is HSOE is aimed at artists
09:11:19 <applicative> Saizan, ndmitchell is forever complaining he cant build 99% of hackage on windows
09:11:28 <haskeller> @src Data.Function
09:11:28 <applicative> sm, read the introduction.
09:11:29 <lambdabot> Source not found. Sorry.
09:11:39 <dcoutts_> jmcarthur: it does, but it's aimed at debian packaging people
09:11:40 <sm> I'm reading the book right now
09:11:46 <haskeller> oh, you lazy bot.
09:12:22 <applicative> sm, i could be wrong, i'm looking
09:12:30 <sleepynate> jmcarthur: indeed i use arch on my non-server machines .. luckily i've done enough to understand how the whole shebang works, i'm just making the point it's not exactly a walk in the park :)
09:13:35 <dskippy1> applicative: What does one need to consider when making a Hackage library when it comes to building on Windows?
09:14:01 <Saizan> applicative: no, the problem here is that this conversation started by talking about ghc itself, and i wasn't aware you were assuming that included a lot of gui or other such libraries
09:14:33 <sm> dskippy: first, check your dependencies for packages that don't support windows, like "unix"
09:15:08 <sm> second, try cabal install ing it on windows 
09:15:47 <applicative> SOE was written for Hugs, so was Fran.  Try getting to the point with GHC that you could get to 10 years ago...
09:16:10 <Saizan> there's gtksoe
09:16:19 <Saizan> and windows installers for gtk2hs
09:16:51 <EvanCarroll> It employs secure coding techniques to make buffer overflows a solved problem.
09:16:58 <EvanCarroll> hrm, I wonder what those techiqnues are...
09:17:05 <sm> dskippy: note to an extent you can test the latter in wine, I'm doing that right now
09:17:11 <applicative> Saizan, have you installed it. i'm not going to try.  
09:17:26 <Saizan> applicative: i don't care
09:17:38 <dcoutts_> applicative: on the other hand, the modern gui toolkits don't make people run away screaming with horror
09:17:39 <jmcarthur> sleepynate: i see. there are indeed many annoyances about the interactions between cabal packages and package managers :\
09:17:47 <applicative> rrrrrr
09:18:16 <dcoutts_> jmcarthur, sleepynate: can you characterise the problem precisely? what could cabal do better/differently?
09:18:31 <dcoutts_> is it just that the native package manager does not know about extra packages installed manually?
09:18:42 <applicative> dcoutts_, of course they do, you must be ignoring evidence from #haskell that is before your senses all the time.
09:19:17 <applicative> dcoutts_, i bought a netbook, because i was tired of alleged friends of our language ignoring the desperate pleas of windows users
09:19:43 <dcoutts_> applicative: well my evidence is that my customers are happy with the visual look and behaviour of the gui apps I've developed, but I'm sure they would not have been happy with the visual look of fran
09:19:58 <sleepynate> dcoutts_: give me a minute... work stuff
09:20:25 <dcoutts_> applicative: yep, I'm talking about windows
09:20:32 <jmcarthur> dcoutts_: it's not really cabal's fault, i think
09:20:43 <applicative> dcoutts, of course they look better
09:20:54 <jmcarthur> dcoutts_: my main issue is normally that cabal supports many different versions of the same package installed at the same time, but most linux package managers do not
09:21:41 <dcoutts_> jmcarthur: right, which is pretty important for developers, but yes when selecting packages for a distro it is usual to pick a single version of each package
09:21:45 <jmcarthur> dcoutts_: i suggested a couple times that cabal2arch could get around this by appending major version numbers to package names (assuming the packages in question follow the versioning policy)
09:21:52 <applicative> dcoutts_ the gui aspect came up indirectly.  my complaint was the incessant running down of hugs, and the failure to recognize the difficulty of installing ghc
09:22:28 <jmcarthur> dcoutts_: but still... it's not a cabal problem as far as i can tell
09:22:29 <applicative> dcoutts_ are there as many undergraduate courses taught with haskell as in the heyday of hugs? 
09:23:03 * sm is confused about why applicative is complaining to dcoutts about hugs
09:23:17 <dcoutts_> applicative: I think most courses switched to ghci, I switched the practicals when I was teaching it
09:23:45 <dcoutts_> applicative: I think the reason that hugs has not had releases since 2006 is a reflection of the fact that people were switching to ghci
09:23:53 <applicative> dcoutts_ i followed some german lectures at one of the big univs from last year; they presupposed hugs
09:24:09 <applicative> dcoutts_ yes, it was the people who are competent to install ghc
09:24:14 <dcoutts_> applicative: and the reason for the switch was that ghci had got up to par with hugs on error messages
09:24:15 <applicative> of course they use ghc
09:24:39 <dcoutts_> applicative: and the fact that hugs was considered by the students as a toy, which tended to put them off
09:24:54 <jmcarthur> ouch
09:24:54 <dcoutts_> using ghci we could use more interesting libraries which made practicals more fun
09:24:58 <dcoutts_> e.g. more graphics
09:25:01 <applicative> dcoutts_ I think the reasoning overlooked obvious points about the potential userbase
09:25:26 <dcoutts_> applicative: I do not regret the decision
09:25:51 <dcoutts_> it's a bigger download, but not a lot harder to install
09:26:30 <dcoutts_> I don't recall there being any more/less of a problem once we switched
09:26:34 <applicative> dcoutts_ I think i would agree if it were convincing that it isn't a lot harder to install.  
09:26:52 <applicative> dcoutts_ because you are overlooking the people who have tried haskell
09:27:10 <applicative> sorry, who haven't
09:27:17 <dcoutts_> applicative: OSX was not so popular at the time, so it was really just linux and windows, windows has a all in one installer, linux had packages
09:27:32 <dcoutts_> so that was really the same as hugs
09:27:41 <dcoutts_> though certainly a bigger download
09:28:00 <dcoutts_> we'd never used winhugs, nor encouraged students to do so, so that may be something
09:28:24 <dcoutts_> at the time we were using solaris workstations
09:29:27 <dcoutts_> applicative: so what is it that is harder to install?
09:29:55 <dcoutts_> are we comparing like with like, is it that it's now not just ghc, but also half a dozen extra things off hackage that makes things harder for first time users?
09:30:00 <applicative> dcoutts_ it is true that the principal difficulty with people I know was with os x
09:30:12 <applicative> dcoutts_ i first got a mac so I could install ghc
09:30:15 <dcoutts_> applicative: plus macports plus cabal?
09:30:26 <applicative> a couple of years ago
09:30:45 <dcoutts_> applicative: or the fact that OSX does not have gcc et by default (needs silly Xcode) ?
09:31:00 <applicative> there's one chamber of horrors for you
09:31:11 <dcoutts_> there's certainly a reasonable argument that we should ignore Xcode and just bundle gcc as we do on Windows
09:31:15 <applicative> think what a writer on os x need to do to install pandoc
09:31:37 <dcoutts_> they don't want ghc to use pandoc, they want a binary
09:31:44 <applicative> and add additional scripts from the list
09:32:55 <dcoutts_> so perhaps what we need is better tools for preparing portable binaries
09:32:56 <applicative> dcoutts_ yes, i have occasionally attempted to make a pandoc binary for os x.  
09:33:09 <dcoutts_> then the pandoc people could make one much more easily (similarly windows)
09:33:28 <applicative> dcoutts_ man is that true, but I assume it's a nightmare
09:33:43 <dcoutts_> it'll need some help from OSX people and cabal people
09:33:49 <tibbe> What's Antoine Latter's nick?
09:33:50 * dcoutts_ does not have any access to OSX
09:33:57 <dcoutts_> too expensive :-(
09:34:09 <applicative> dcoutts_ yes its a nightmare.  
09:34:18 <tibbe> dcoutts_, I intend to start a thread about bytearray soon, we have two possible candidates, one in the smallarray package and one in the primitive package
09:34:26 <dcoutts_> tibbe: ok
09:34:27 <applicative> dcoutts_ but in writerly milieus they spend the money, if they have it
09:34:30 <tibbe> dcoutts_, what's the OS X problem?
09:34:32 <kosmikus> applicative: I've been teaching Haskell at university level for several years, and installing GHC was never a stumbling block for anyone
09:34:36 <applicative> dcoutts_ similarly with teachers
09:34:42 <dcoutts_> tibbe: oh loads of packaging and system things
09:34:49 <applicative> kosmikus, you were teaching cs students
09:34:49 <kosmikus> applicative: some libraries may be hard to install occasionally, but then it's even harder with hugs ...
09:35:00 <tibbe> dcoutts_, if you want me to test some things, drop me an email and I can check on my OS X laptop
09:35:04 <dcoutts_> applicative: I've occasionally considered getting a mini, but they're soo expensive and inconvenient compared to a cheap windows VM
09:35:22 <dcoutts_> tibbe: the problem is no access for hacking, not no testers
09:35:23 <applicative> kosmikus, i'm speaking only on behalf of non-CS types
09:35:29 <tibbe> dcoutts_, what windows VM do you use? I need to get a new one to test network changes
09:35:34 <tibbe> dcoutts_, I see
09:35:41 <dcoutts_> tibbe: I use kvm
09:35:45 <tibbe> dcoutts_, ok
09:36:21 <applicative> i know someone who almost managed to install pandoc on OS X with the haskell platform 
09:36:28 <kosmikus> applicative: ok, I really can't judge, but my impression is that installing the Haskell Platform is relatively easy these days, so just let students bring their laptops or whatever, and they'll figure it out among themselves
09:36:53 <applicative> but then spent three days trying to understand what is obvious to a beginning CS student.  that he had to put ~/.cabal/bin in $PATH, and what that meant
09:37:01 <ezrakilty> I've had trouble recently with the fact that Platform requries OpenGL, and chasing that down on Ubuntu was not as easy as I'd have expected.
09:37:02 <dcoutts_> sigh
09:37:38 <dcoutts_> applicative: that one's quite easy to fix too, given a little developer time (ie so it'll just work, no user fiddling)
09:37:54 * dcoutts_ simply has not had the time
09:39:53 <applicative> dcoutts_ i apologize if i said something mean to you.  my irritation arose earlier.  
09:39:55 <kosmikus> applicative: these kinds of problems are quite valid, but they're also extremely easy to address as soon as you have a group of students
09:41:05 <applicative> kosmikus, what if they aren't students.  it is like the problems installing linux; they don't exist if you have linuxy friends
09:41:35 <dcoutts_> applicative: no no, it's all true, it's just a little frustrating :-)
09:42:15 <dcoutts_> applicative: btw, does OSX have a per-user dir that is on the $PATH by default? (like ~/bin on many linux systems)
09:42:18 <applicative> dcoutts_ I apologize for sounding sour about it, i'm not at all, it's just in connection with our friends here, who are completely pollyannaish about the present state of things
09:42:43 <dcoutts_> applicative: well if you can find anyone with time to fix things, I've got the list of tickets
09:42:44 <applicative> dcoutts, no ~/bin exists unless you make one
09:43:01 <sm> hrm, I thought process was windows-compatible. Actually it requires configure
09:43:15 <dcoutts_> applicative: and nothing more OSXish like ~/Applications ?
09:44:03 <applicative> dcoutts_ that I don't know.  it was trying to make a pandoc.app that could be called from the command lines that broke me last time
09:44:20 <applicative> otherwise the cabal-macox package and a couple of other examples were very helpful
09:44:25 <sm> dcoutts_: the nearest thing might be  ~/Library/Application Support/
09:45:00 <dcoutts_> applicative: I'm just wondering how it can be done at all, without root privileges, if we would somehow have to adjust the $PATH
09:45:44 <applicative> you mean with a standalone binary?
09:45:45 <Saizan> applicative: it would have been quite different if you stated initially what you meant as "easy to use", also that you were mostly talking about os x
09:46:13 <dcoutts_> applicative: any directory where we/cabal could stick a binary so that the user can run it without further configuration
09:46:32 <applicative> saizan, i used hugs on windows; and BOUGHT a million dollar mac, so i could install ghc
09:46:33 <dcoutts_> applicative: or failing that, anything else that is automatic, no user config required
09:46:45 <applicative> saizan, at that point i was competent to install linux :) 
09:46:48 <sleepynate> ok dcoutts_ ... i don't know what cabal can do better, but essentially the problem is if you have a 'nix noob using for example apt-get to install libghc6-data-accesor-dev, then they need an updated version from cabal for some other app, sometimes either apt no longer respects that that library is installed (as it's been overwritten by cabal) or cabal sees the version installed by apt and says you're not the right version.
09:47:01 <Saizan> applicative: that seems quite backwards to me, but ok
09:47:15 <applicative> Saizan you are a programmer
09:47:56 <Saizan> applicative: no, i'm just saying that ghc seems better maintained on windows rather than os x
09:48:14 <applicative> Saizan, i think this is true now.
09:48:17 <dcoutts_> sleepynate: apt should still think it's installed, if you use cabal to install the exact same version then ghc will only know about the one installed by cabal, not apt
09:48:21 <Saizan> (and Cabal etc..)
09:49:08 <dcoutts_> sleepynate: so presumably the only problem occurs when the same version is installed globally by both apt and cabal, and then cabal and ghc only see one of the two.
09:49:25 <dcoutts_> otherwise they will co-exist in the same global package db
09:53:43 <sleepynate> but let's say you've used cabal to update ghc -- now debian has 6.10 and you have another 6.12 on the system, the user then goes about trying to compile something from cabal (which i believe would try to use the newer ghc) but has missing dependencies that should be installed for 6.10 (and may not have actually changed)... i don't think cabal is doing anything "wrong", per se, just confusing. it might be duly dilligent to check and say "you 
09:54:07 <applicative> dcoutts_ I will take up the question how to make usable binaries for os x again.  I was disappointed when confronted with the subtleties of getting at the pandoc executable when buried inside their app directory structure.  If  i could make a little gui, it would be childs play to get access to the executable.  But to also use it from the command line seems to make trouble. 
09:54:10 <dcoutts_> sleepynate: cabal cannot update ghc
09:54:30 <applicative> dcoutts_ anyway, sorry for wearing down your brain!
09:54:38 <sleepynate> cabal install ghc doesn't work?
09:55:07 <Saizan> no
09:55:17 <dcoutts_> sleepynate: also, the set of libs installed for ghc 6.10 is entirely independent of those installed for 6.12 (or more generally all the versions have independent sets of libs)
09:55:27 <sleepynate> right
09:55:46 <dcoutts_> applicative: aye, I've never understood OSX app bundles and what makes them different from just a plain binary
09:56:13 <applicative> the binary is a couple of subdirectories in
09:56:41 <dcoutts_> sleepynate: so yes, cabal would in that situation install libs for the new ghc instance, you could say that these are the same version as those installed by apt, but they're for a different ghc version and will not interfere
09:56:59 <sm> I'm no expert, but they just bundle the binary and support files under one tree so you can drag install as a unit
09:57:07 <dcoutts_> sleepynate: as for which ghc it will pick, unless you specify then it picks the one on the $PATH
09:58:08 <dcoutts_> sleepynate: so perhaps it confuses people that they think they installed libghc6-foo-dev and no cabal is installing foo again, but for a different instance of ghc ?
09:58:14 <dcoutts_> no/now
09:58:48 <dcoutts_> perhaps the real source of their confusion is that they expect libs to be shared between multiple versions of ghc
09:58:51 <applicative> sm, yes, and whatever executable you have buried inside then becomes accessible with the point and click method due to the larger framing. 
09:58:59 <sleepynate> could be. i wish i could remember the issue specifically i had when converting someone over on an ubuntu system
09:59:31 <dcoutts_> sleepynate: if you work out what the specifics were/are then a bug report (/feature req) in the cabal track would not go amis
09:59:48 <sm> applicative: I've seen tools to turn a binary into a bundle, it seems you at least could make a clicky pandoc app easily
10:00:36 <sleepynate> right.. i had thought of it at the time (for ubuntu's bugtracker -- as its treatment is what i think was at fault) but didn't have a chance.
10:00:49 <sm> hmm. cabal install process on windows (wine) is now running forever
10:01:00 <applicative> sm, yes I've done this -- it carried its own version of iconv for example
10:01:12 <sleepynate> personally i'm lazy and just cabal --global as root ... so feel free to send me your rootkits :p
10:02:24 <applicative> sleepynate, just make sure cabal doesn't take it into its head to reinstall base-3 :)
10:03:33 <applicative> sm, I used the cabal-macosx library, which is surprisingly simple.   It fetches any libs you can't count on osx coming with
10:03:47 <dons> ?bug
10:03:54 <sm> ooh, thanks for that
10:03:56 * sleepynate can see the cabal team plotting to obliterate his non-working nvidia drivers and steal his FOSS code now...
10:03:59 <dons> oh, no lambdabot?
10:05:21 <sleepynate> dcoutts_: but yea, the way i dealt with that issue was basically user-education. "this is installed, don't touch it"
10:07:13 * sleepynate wants everything to be as friendly as darcs
10:08:53 <jro> better defintions to this functions? gotall = foldl (\x y -> liftM2 (+) x y) (Just 0)
10:09:34 <jro> case (gotall list) of Just _ -> do things with list
10:09:38 <applicative> sm, cabal-macosx is clever.  the ordinary result of 'cabal build' once you've got it right, is that inside dist/build/ is a 'draggable' sm.app
10:09:59 <sm> I will use for hledger. Now if only windows was as easy
10:10:50 <sm> applicative: cabal-macosx is not well documented, would you have an example ?
10:11:02 <applicative> sm, there are examples inside 
10:12:02 <applicative> sm it's pretty straightforward.  I will see if any of my goofy pandoc.app attempts build.
10:12:33 <sm> don't spend too much time, it's looking like something I'll have to try later
10:14:28 <dskippy1> jro: Maybe with foldM?
10:14:41 <benmachine> I don't think foldM is good for that
10:20:54 <jro> well, at least lambda is useless
10:21:37 <jro> I just thought that if I've list of Maybes maybe there would be something similar as msum, but giving Nothing if there
10:21:41 <jro> is Nothing
10:23:11 <ClaudiusMaximus> > sum <$> sequence [Just 4, Nothing, Just 5]
10:25:49 <jmcarthur> jro: what should the result be if there are no Nothings in the list?
10:26:02 <jmcarthur> Just <what>?
10:26:26 <dskippy1> jmcarthur: I'm going to guess nothing.
10:26:41 <jmcarthur> dskippy1: so the result should always be Nothing?
10:26:59 <jro> Just _
10:27:03 <dskippy1> jmcarthur: No what if there are all Just's in the list, then you sum them, right?
10:27:09 <jro> I do not need the sum
10:27:10 <dskippy1> I think that's what he wants. Not sure.
10:27:19 <jmcarthur> jro: why not just get a Bool then?
10:27:30 <jmcarthur> all isJust
10:27:47 <dskippy1> Oh, why did you original have a + in it?
10:28:47 <jro> (+) popped first out of my head
10:28:51 <jmcarthur> where's lambdabot? :(
10:29:08 <tromp_> on vacation
10:29:21 <dskippy1> jro: So you just want to know if they're all Just? I think jmcarthur nailed it then.
10:29:23 <tromp_> guy needed a break
10:29:43 <benmachine> sequence
10:29:57 <jmcarthur> all isJust [Just 5, Just 6, Just 7]  ==>  True  ;  all isJust [Just 5, Just 6, Nothing]  ==>  False
10:35:23 <jro> oh, thanks
10:35:53 <jro> \me reads List documentation
10:53:24 <jro> acsum [1..] = -1/12
10:53:27 <jro> does not work :-)
10:54:17 <medfly> heh
10:55:50 <jmcarthur> acsum?
10:55:57 <jro> analytically continued sum
10:56:06 <jro> using zeta function
10:58:21 <ExtremeTomato> Might I ask a question you've no doubt heard millions of times before (I'm just starting to learn Haskell)?
10:58:42 <kmc> is it "What are monads, really?"
10:58:49 <ExtremeTomato> not that bad, but close :-)
10:58:55 <kmc> go ahead :)
10:59:09 <ExtremeTomato> I'm attempting to get this working, and my knowledge of the type system is letting me down: "renderVal :: a -> String ; renderVal v = "Value: " ++ (show v)
10:59:16 <ExtremeTomato> "
10:59:33 <kmc> renderVal :: (Show a) => a -> String
10:59:40 <kmc> "show" isn't defined for all types
10:59:47 <kmc> it's only defined for some types
10:59:54 <ExtremeTomato> I knew that much, but my attempts to fix it died
11:00:00 <FauxFaux> Or renderVal v = "Value: " ++ (show v); :t renderVal..
11:00:03 <sproingie> if you're not sure what the type signature should be, leave it off and use :t
11:00:06 <kmc> you have to constrain 'a' to belong to the "Show" type class
11:00:12 <ExtremeTomato> too few lines on the arrow, I was using '-' rather than '='
11:00:22 <kmc> but yeah, it's good advice to define it and ask ghc the type
11:00:24 <monochrom> haha
11:00:29 <sproingie> :t \v -> "Value" ++ (show v)
11:00:37 <sproingie> @t \v -> "Value" ++ (show v)
11:00:39 <Saizan> ExtremeTomato: in this case you could have commented out the type signature and asked ghci with :type renderVal after loading it
11:00:54 <sproingie> oh fer crying out loud no \bot again?
11:00:58 * jmcarthur sighs because #haskell is repeating itself again
11:01:02 <jmcarthur> sproingie: yeah :(
11:01:23 <ExtremeTomato> Thanks, I'll look into all of those :-)
11:01:27 <monochrom> irc nature implies that all questions and answers recur infinitely often
11:01:39 <ExtremeTomato> I can imagine you get that one a lot
11:01:45 <monochrom> including "where is lambdabot?" :)
11:01:51 <sproingie> fix question
11:01:56 <jro> What are monads, really?
11:02:07 <sproingie> jro: tasty tasty burritos
11:02:08 <Saizan> hey, majestic stereo is a sign of tropical warm
11:02:20 <jmcarthur> unicorn burritos
11:02:23 <jmcarthur> in space
11:02:28 <ExtremeTomato> Out of morbid curiosity, do you give the mathematical or pragmatic answer to the monad question?
11:02:31 <sproingie> unicorn meat is the tastiest
11:02:41 <monochrom> I give a pragmatic answer
11:02:42 <sproingie> ExtremeTomato: pragmatic
11:02:47 <Zao> ExtremeTomato: Radioactive sea spacesuit.
11:02:48 <jmcarthur> ExtremeTomato: it depends who is around, but normally it's the pragmatic answer
11:02:55 <monochrom> it's like "what are arrays, really?"
11:02:56 <jmcarthur> or terrible metaphors
11:03:00 <Saizan> monads are really ways to embed some other small languages within haskell
11:03:01 <sproingie> "monoid over the category of endofunctors" is not all that useful an explanation
11:03:09 <ExtremeTomato> Are said metaphors car-related?
11:03:26 <jmcarthur> every type class in haskell is a way to embed some other small languages within haskell
11:03:32 <kadoban> all of the bad metaphors i've heard are toxic-waste related in some way
11:04:08 <jmcarthur> monads are nothing special really
11:04:27 <jmcarthur> besides having a lot of terrible metaphors :\
11:04:37 <Saizan> jmcarthur: that's clearly not true for any decent definition of language
11:04:38 <c_wraith> well.  They're special in that they get special syntax.  But nothing else.  Aside from the syntax, they're just another typeclass.
11:04:56 <ExtremeTomato> I've read a few things on them, and have worked with category theory, but they've not quite gone in yet
11:05:02 <iamjwc> hello all
11:05:02 <monochrom> arrays are like youtube
11:05:11 <sproingie> a well-behaved monad obeys monad laws, which can be summed up as "do-notation works like you'd expect"
11:05:18 <c_wraith> monochrom, you should avoid reading comments on arrays at all costs?
11:05:24 <ExtremeTomato> haha
11:05:33 <iamjwc> im working on implementing Vim in Haskell and I was curious if anyone could give some pointers to make my code more idiomatic
11:05:35 <iamjwc> its a lot to ask
11:05:39 <iamjwc> but if anyone is interested https://github.com/iamjwc/vim-in-haskell
11:05:41 <Saizan> and while there are some other typeclasses for which what i've said applies, they are not such a prominent example of this
11:05:58 <sproingie> iamjwc: you looked at yi?
11:06:06 <monochrom> http://www.haskell.org/haskellwiki/Monad_laws :)
11:06:23 <sproingie> the Monad Laws of Attraction.  like >>= like
11:06:35 <dskippy1> iamjwc: Would you allow for Haskell-based vimrc ?
11:06:44 <iamjwc> sproingie: ive seen it before.. im not writing this to be a great text editor. im writing this as an exercise to learn haskell
11:06:52 <c_wraith> sproingie, infinite type, cannot construct a = a -> m b
11:07:09 <Zao> iamjwc: Did you look at that Haskell-based editor that had vi and emacs frontends did things?
11:07:12 <iamjwc> dskippy1: i dont have plans for that... just want to get basic stuff working
11:07:17 <Zao> Can't remember the name of it, heh.
11:07:22 <mauke> yi
11:07:37 <Zao> Yi, it was.
11:07:47 <sproingie> you could call it "him"
11:07:56 <iamjwc> hahah
11:07:58 <iamjwc> yeah
11:08:01 <jmcarthur> Saizan: i think it's just a matter of where you draw the line, but there is no accepted black and white definition that i know of such that some type classes are obviously ways to embed languages and others aren't
11:08:10 <Zao> All I knew was that it had a dependency on that vt library, but Hackage wasn't awesome enough to give me the name from that :D
11:08:11 <iamjwc> i was hoping more for code suggestions, but ill take name suggestions :)
11:09:24 <Gmind> oh man ! 693 people in room !
11:09:35 <sproingie> who farted?
11:10:33 <jmcarthur> ^_^
11:11:02 <mauke> fortunately this is a channel
11:11:05 <sproingie> iamjwc: as for making your editor "idiomatic", it seems to me that there's a lot of idioms you can follow, and that idiomatic usually just means "looks like program XYZ"
11:11:33 <sproingie> iamjwc: i'd go for whatever's most maintainable for you and still performs well 
11:13:03 <iamjwc> sproingie: right. maybe in regards to managing state. there is a lot of stuff to keep track of (file, file name, position in file, directory in project, other buffers, and a million other things)
11:13:21 <sproingie> yeah pervasive state is sort of a bugaboo of mine too
11:13:36 <iamjwc> do i just keep all that in a big hash table and then pass that to every function?
11:13:40 <Saizan> jmcarthur: wherever you draw it, it has to be somewhere where you have something resembling function application
11:13:41 <iamjwc> or possibly use the state monad
11:13:44 <mauke> "our business model of building synergies between static types is the core of our forward thinking proactive agile approach to utilize cooperative association with our core values."
11:13:53 <sproingie> last couple things i did i just stuffed 'em into iorefs
11:14:19 <iamjwc> ah... ive never seen an ioref
11:16:20 <Saizan> jmcarthur: anyhow, more formally, i was getting at the fact that monads are a fundamental structure of denotational semantics for a large class of enriched lambda calculi
11:16:26 <sproingie> iorefs are about as close as it gets to having mutable variables.  gotta be in the IO monad of course
11:16:49 <sproingie> ST may be better if you want to isolate them
11:16:58 <iamjwc> ok
11:17:49 <jmcarthur> Saizan: i think function application is too tight. it rules out prolog, for example
11:20:20 <jmcarthur> of course one could argue that you can implement function *within* prolog
11:20:25 <jmcarthur> *functions
11:21:18 <Saizan> or that prolog's predicates are functions too, or that anyway the point is that you've some computation parametrized and you can push arguments into it
11:22:50 <jmcarthur> i can't think of many non-trivial type classes that aren't suitably expressive for that
11:23:23 <Saizan> Eq, Ord .. the numeric ones ..
11:23:35 <Saizan> Show, Read, ..
11:24:20 <Saizan> you've to be able to do that in the embedded language, not the host one
11:27:29 <monochrom> haha, the gentle introduction is not moved to the new server :)
11:27:45 <jmcarthur> Show and Read are certainly good examples so long as you use them idiomatically. Eq, Ord, and numeric classes I'm less certain about.
11:29:29 <jmcarthur> i don't mean to just be annoying and argue philosophy though, and i don't really want to try coming up with a great counterexample right now
11:29:38 <jmcarthur> so i'll just drop it
11:33:26 <revenantphx> hnggggh
11:33:38 <revenantphx> computer science teacher is claiming early binding does not constitute polymorphism.
11:34:00 <revenantphx> (I'd say it was a debatable point if he actually knew what polymorphism is)
11:34:11 <revenantphx> (he thinks "polymorphism is having interfaces that are bound late")
11:34:14 <revenantphx> TT_TT
11:34:17 <monochrom> he/she means early binding does not constitute ad-hoc polymorphism, which is quite right
11:34:28 <revenantphx> monochrom: That's what I'd like to think.
11:34:33 <revenantphx> But he doesn't know what ad-hoc polymorphism is.
11:34:51 <monochrom> well he hasn't heard of it called ad-hoc polymorphism, that's all.
11:35:04 <revenantphx> And overloading *is* ad hoc polymorphism no?
11:35:04 <monochrom> in any case, just bash TaPL on him
11:35:07 <monochrom> yes
11:35:33 <Saizan> it'd be quite fun to see how you could embed it into Eq, you'll probably make oleg's code look straightforward :)
11:36:12 <revenantphx> See, monochrom, I'd think early binding would be ad-hoc. :\
11:36:40 <revenantphx> oh well... in any case his lesson is a mess.
11:37:14 <revenantphx> I mentioned his recommendation to cast out of interface types earlier. Hurray, let's throw every principle of OO.
11:38:09 <Gracenotes> I didn't see casting in TaPL, that's for sure :|
11:38:25 <monochrom> it is better to separate semantics (what kind of polymorphism you get) from common implementations (when to bind). I know how to eliminate a lot of late bindings by heavy theorem proving.
11:38:34 <Gracenotes> ahm downcasting
11:39:50 <revenantphx> Please tell me that by college the teachers start knowing what they
11:39:54 <revenantphx> 're talking about?
11:40:06 <monochrom> does he have a phd?
11:40:15 <revenantphx> No, masters in mathematics...
11:40:21 <revenantphx> He knows physics much much better.
11:41:02 <mauke> ah, those physicians and their physical education
11:41:09 * mauke kicks english
11:41:10 <revenantphx> :3
11:41:24 <monochrom> In the old days, by college the students know that while the teachers may be wise and experienced, the teachers could also be wrong.
11:42:32 <monochrom> Old day students would challenge the teachers when necessary.
11:42:39 <revenantphx> I challenge the teacher *too much*.
11:42:55 <Gracenotes> read tapl
11:42:56 <monochrom> These days the students take the teaching as authoritative.
11:42:59 <Gracenotes> become type system god
11:43:12 <revenantphx> I need to read TaPL...
11:43:27 <Gracenotes> though if that's what tapl does, I wonder what attapl does
11:43:30 <revenantphx> def on my book list for christmas
11:43:40 <revenantphx> attapl 0.o?
11:43:48 <monochrom> and of course, similarly when you s/teacher/book/
11:43:58 <Saizan> Gracenotes: outer god
11:44:18 <Gracenotes> let's say, higher-order god
11:44:22 <revenantphx> The chapter dependency chart in TaPL is amusing.
11:44:41 <Gracenotes> that it is.
11:44:42 <twaffle> is it possible to include type class constraints in a type synonym?
11:45:17 <revenantphx> Oh, TaPL is already on my list.
11:45:29 <revenantphx> Seriously guys, I need like 3 or 4 more books.
11:45:29 <Gracenotes> speaking of higher-order polymorphism...
11:45:31 <monochrom> In the old days, Feynman's girlfriend was like "the book says DeCartes says he thinks therefore he exists, I think that's circular logic, I call it bluff".
11:45:36 <revenantphx> During the summer I need lots of reading.
11:45:42 <zygoloid> twaffle: as a GHC extension, yes
11:45:43 <Saizan> twaffle: i don't think it'd work well
11:45:59 <aristid> monochrom: hah, always stating the obvious that girl
11:46:02 <monochrom> These days, a cs student is like "the books says OOP is a must, therefore it must be true!"
11:46:04 <twaffle> zygoloid: what extension?
11:46:13 <revenantphx> If you guys don't recommend a book for me...
11:46:16 <revenantphx> I'll read http://covers.oreilly.com/images/9780596005689/lrg.jpg
11:46:23 <revenantphx> HARDCORE JAVA.
11:46:24 <revenantphx> HNGGHG
11:46:27 <aristid> revenantphx: is that a warning?
11:46:29 <Gracenotes> OH YES T$ROEAIJGRWEAQFNQEF
11:46:32 <aristid> a threat?
11:46:41 <zygoloid> twaffle: -XLiberalTypeSynonyms
11:46:54 <twaffle> zygoloid: thanks
11:47:16 <Saizan> revenantphx: attapl = advanced topics in ..
11:47:33 <zygoloid> twaffle: looks like you need -XRankNTypes too (not sure why...)
11:47:40 <revenantphx> the list right now is...
11:47:42 <revenantphx> Types and Programming Languages – Benjamin Pierce 
11:47:42 <revenantphx> The Elements of Computing Systems - Noah Nisan, Shimon Shocken
11:47:42 <twaffle> zygoloid: hmm. weird
11:47:45 <revenantphx> It's way too short.
11:48:02 <mee> revenantphx: have you read Bird & De Moor's /Algebra of Programming/ ? I'm not absorbing as much of it as I'd like, but it's definitely interesting
11:48:16 <revenantphx> No.
11:48:25 <revenantphx> I haven't.
11:48:34 <Gracenotes> revenantphx: I know it's Java, but if you're interested in concurrency primitives (how they do things in the non-STM-or-DPH world), Java Concurrency in Practice is a good read
11:48:51 <revenantphx> Gracenotes: I've done so much goddamn pthread/mutex shit...
11:48:56 <revenantphx> I'd prefer to *NEVER SEE THEM AGAIN*
11:49:01 <revenantphx> MVar and TVar are my new best friends :D
11:49:22 <younder> I agree
11:49:24 <Gracenotes> revenantphx: eh, this has some stuff about software engineering with them, and even a chapter on efficient imperative lockfree algorithms
11:49:36 <younder> That is why I am developing formula
11:50:05 <Gracenotes> dunno I liked it, Doug Lea is a smart guy. but, yes, hopelessly abstract is just as fun
11:50:20 <younder> concurrentcy mad easy throgh agents and hard throgh prooveabillity
11:50:49 <revenantphx> I wish the teacher wouldn't take the word of Cay Horstmann as inexorable fact.
11:51:01 <bremner> heh.
11:51:02 <Gracenotes> Horstmann? ooooohhhhhhhh.
11:51:07 <Gracenotes> I feel for you bro
11:51:08 <revenantphx> hnggh
11:51:18 <Gracenotes> brofeels
11:51:23 <revenantphx> No seriously.
11:51:35 <revenantphx> because the book says "new Coin(0.1, "dime")" is an "anonymous class" he insists it is.
11:51:44 <revenantphx> Even though you know, its obviously an instance, not a clas.
11:51:49 <younder> Look I know your hero is simon p. jones, but I am prety smart too..
11:52:12 <Gracenotes> revenantphx: learn how to talk about OOP languages using a variety of formalisms
11:52:22 <Gracenotes> so you can do an argument by obfuscation on any OOP advocate
11:52:33 <younder> rotfl
11:52:39 <Gracenotes> it's a good skill to have
11:52:40 <revenantphx> ....and he doesn't know the difference between an anonymous class and an abstract clas.
11:52:46 <revenantphx> Shoot me. Please just shoot me TT_TT.
11:53:24 <Gracenotes> waat
11:53:30 <revenantphx> Not really.
11:54:06 <revenantphx> The worst part is when your parents tell you "Stop questioning the teacher, he went to college and knows more than you".
11:54:16 <Gracenotes> you discuss OOP with your parents?
11:54:33 <revenantphx> Apparently spending eight hours a day (usually more) studying computer science as a hobby doesn't grant you any form of knowledge.
11:54:57 <younder> Look OO has it's points. IBM tried to find a alternative to OO with widows and failed. For things that actually ARE objects it rocks! it's just that Java et.al. is giving it a bad name.
11:55:12 <bremner> I think widows are underrated
11:55:33 <Saizan> widows?
11:55:42 <bremner> that's what the man said.
11:55:47 <revenantphx> While I agree there is a lot to learn from those who are wiser than yourself, its silly to assume that your teachers are always right...
11:55:48 <Gracenotes> hurm, how do I ship an object that's 24" long? :|
11:55:56 <Zao> In parts?
11:56:02 <Gracenotes> it's metal
11:56:04 <revenantphx> On a pallete.
11:56:11 <revenantphx> 24" is two feet.
11:56:13 <Saizan> Gracenotes: with the ship() method, duh
11:56:14 <revenantphx> Whats the issue there.
11:56:18 <Zao> Oh, 0.6m.
11:56:20 <younder> I was talking about windows systems not the windows operating system.
11:56:21 <Zao> That's no problem, really.
11:56:27 <revenantphx> Pick ip up
11:56:28 <revenantphx> and then move it.
11:56:29 <Zao> Your silly units confused me :D
11:56:36 <revenantphx> Zao: I know right :3
11:56:44 <Gracenotes> I cannot find a box large enough.. erg.
11:56:53 <zygoloid> Gracenotes: rotate it and put it in a 17"x17"x17" box
11:57:04 <younder> Personally I use Gnome and love it.
11:57:07 <Gracenotes> where's my 17x17x17 box -.-
11:57:11 <revenantphx> One moment, i'm seeing how badly he's going to screw up inheritance now.
11:58:12 <Saizan> revenantphx: it's also silly to continue to challenge who doesn't respond constructively to arguments, unless you want to get him fired by showing his incompetency, but that'd require whole different level of effort
11:59:11 <revenantphx> Saizan: He's a nice guy though, so Id rather that not happen.
11:59:24 <younder> Is there no ML group?
11:59:28 <revenantphx> I can do that though... if needed. There's a new history teacher who needs to go.
11:59:31 <Philippa> younder: I think there's a lot more to be said for Smalltalk-flavoured OO than Java-flavoured, FWIW
12:00:10 <revenantphx> I'm one of the few people in the world who likes Objective-C apparently.
12:00:13 <sproingie> i like self-flavored OO
12:00:19 <revenantphx> I like orange-flavored OO.
12:00:26 <Philippa> which isn't so much in your "for things that actually ARE objects" camp, though I sure as hell wish it supported algebras as data more effectively
12:00:35 <sproingie> actually i like CLOS-flavored, though i'm not entirely sure multimethods are so much OO as generic
12:00:55 <parcs> revenantphx: is this an ap computer science course?
12:01:06 <revenantphx> yes.
12:01:23 <revenantphx> I'm considering taking the AP exam over winter break and dropping the course to be honest.
12:01:32 <revenantphx> I just need to brush up on some of java's keywords and classes and I'd be good.
12:01:35 <Philippa> sproingie: yeah. Certainly I have use cases for something related to CLOS
12:01:37 <sproingie> part of coursework is suffering the course
12:02:31 * hackagebot parallel-io 0.2.2 - Combinators for executing IO actions in parallel on a thread pool.  http://hackage.haskell.org/package/parallel-io-0.2.2 (MaxBolingbroke)
12:02:39 <sproingie> academic assignments in general are about A) satisfying the professor first and B) maybe solving the actual problem if it happens to overlap with A
12:03:09 <revenantphx> yeah... seriously.
12:03:31 <younder> milton rocks and lacks a parallel in the Haskell universe. Global data-optimization  doesn't happen (and probably shouldn't)
12:03:33 <sproingie> satisfying vague, arbitrary, and capricious requirements is good preparation for the Real World :)
12:03:54 <revenantphx> I like how after I use the word "state" around him a lot.
12:03:59 <revenantphx> He starts saying "state" in power points...
12:04:04 <revenantphx> It amuses me
12:04:53 <revenantphx> So uh guys.
12:04:56 <revenantphx> book recommendations.
12:05:02 <sproingie> LYAH
12:05:03 <Gracenotes> you are in high school then
12:05:12 <revenantphx> Yes.
12:05:14 <revenantphx> I read LYAH
12:05:14 <Gracenotes> omg they're getting younger
12:05:15 <younder> I decided to write the formula core in ML.
12:05:21 <Gracenotes> :P
12:05:25 <jro> Stack space overflow when running quickcheck-tests?
12:05:41 <Gracenotes> who am I to say.. I started freshman year of college
12:05:48 <revenantphx> started what?
12:05:53 <Gracenotes> Haskell
12:05:55 <younder> mlton was a major part of it..
12:06:03 <revenantphx> oh, I just started this year.
12:06:06 <revenantphx> Enjoying it a lot.
12:06:35 <sproingie> revenantphx: okay, after LYAH, there's RWH
12:06:40 <Gracenotes> it is fun. Hm.... books
12:06:41 <revenantphx> Read it.
12:06:47 <Gracenotes> which papers have you read?
12:06:53 <revenantphx> I'm not looking for haskell books as much as papers and general stuff.
12:06:55 <revenantphx> even math books.
12:07:01 <sproingie> revenantphx: hm... how about Purely Functional Data Structures then?
12:07:02 <revenantphx> I'm sorely lacking in discrete math.
12:07:12 <parcs> revenantphx: SICP?
12:07:14 <younder> just look up GHC on wikipedia
12:07:19 <Gracenotes> have you read your SICP?
12:07:23 <revenantphx> parcs: I'm in the middle of it.
12:07:27 <revenantphx> I've been delayed by haskell :P.
12:07:28 <mreh> what library is it where all the monad are defined as transformers on Identity
12:07:29 <kmc> pick a school you respect and read their discrete math course notes and recommendations
12:07:32 <younder> yes
12:07:36 <kmc> MIT has tons of course materials online for free
12:07:38 <kmc> mreh, transformers
12:07:39 <sproingie> i never could get through SICP, it's just sooooo dry
12:07:42 <byorgey> mreh: transformers?
12:07:50 <Gracenotes> sproingie: you can watch the video lectures!
12:07:56 <Gracenotes> no promise on change of dryness
12:08:00 <mreh> mtl vs transformers
12:08:04 <medfly> lol
12:08:04 <revenantphx> SICP is really dry, yeah.
12:08:05 <Gracenotes> revenantphx: this one is good: http://www.soi.city.ac.uk/~ross/papers/Applicative.html
12:08:05 <sproingie> i've heard the lectures are much better
12:08:05 <mreh> answer quickly
12:08:08 <medfly> I guess I am not alone
12:08:18 <medfly> I intend to try to go through SICP on my own again later :)
12:08:27 <younder> I like S. P. Jones two texts on implementing functional languages as well.
12:08:57 <sproingie> CTM is pretty neat.  not at all haskell-related or even FP-related but it's still got some great stuff in it
12:09:02 <revenantphx> CTM?
12:09:20 <sproingie> http://www.info.ucl.ac.be/~pvr/book.html
12:09:30 <Gracenotes> to be honest, Implementing STG on Stock Hardware (1992 paper) helped me understand implementations better than Implementing Lazy Functional Languages did
12:09:47 <revenantphx> STG?
12:09:57 <sproingie> Spineless Tagless G-Machine
12:10:00 <Philippa> CTM is well worth reading, even though I dislike how its definition of 'paradigm' makes it hard to talk about... well, what you suddenly have to call meta-paradigms
12:10:03 <revenantphx> that sounds really menacing.
12:10:05 <sproingie> the abstract machine ghc uses
12:10:24 <revenantphx> I have to go, thanks a lot.
12:10:26 <Gracenotes> try to write your own implementation of STG in Haskell after eading it
12:10:29 <Gracenotes> reading
12:10:34 <revenantphx> Sadly, I think 3 or 4 books is my maximum.
12:10:36 * hackagebot containers-benchmark 1.0.0.1 - Extensive benchmark suite for containers package.  http://hackage.haskell.org/package/containers-benchmark-1.0.0.1 (MilanStraka)
12:10:43 <revenantphx> Computer books are *so* expensive (or free).
12:10:46 <Gracenotes> but papers are freeeeee
12:10:50 <revenantphx> :D
12:10:51 <revenantphx> YEP
12:10:59 <younder> I prefer 'Programming language pragmatics'  by Scott
12:11:00 <revenantphx> Thanks a lot.
12:12:00 <younder> SPJones books are available on the internet for free!
12:12:22 <Philippa> sproingie: I'd still like to know if there's more written on general ideas in constraint problems rather than "how I solved this problem", FWIW
12:13:10 <bremner> sproingie: CTM is kindof FP related, at least for people coming from Java
12:13:21 <Gracenotes> actually I'm writing a literature review on STG for a computer writing class
12:13:41 <Gracenotes> I'm mostly reading about graph machines prior to it (soo hard to find papers though), and some extensions to it, e.g. for parallelism
12:13:45 <younder> Well everyone neds to have read SICP. (Structured Introduction to Computer Programming by Sussman)
12:13:49 <sproingie> a bit, i suppose.  Oz has a distinct prolog-ish flavor to it tho
12:14:04 <Gracenotes> hm.. any papers that are must-haves for discussing STG?
12:14:07 <Philippa> eh, I'm not convinced SICP has so much to offer me from what I've got round to reading now
12:14:29 <Philippa> I'm happy to support the idea Oz is multiparadigm myself
12:15:04 <Philippa> it's just... well, PVR's not necessarily too polite about the idea of multiparadigm achieved by embedding, even if it's a by-omission, accidentally-ruled-you-out kind of impoliteness
12:15:38 <Philippa> Gracenotes: the problem with STG is it's not really stayed as one constant thing. The eval/apply paper's worth reading though
12:15:47 <augur> Philippa: sicp is beneath you at this point
12:15:58 <younder> otherwise  'The art of multiprocessor programming' by Herlithy and Shavit is excellent
12:16:02 <Gracenotes> Philippa: that's on the list
12:16:18 <Gracenotes> it's mostly just finding a bunch of associated papers.. I think I need 6-9 or something
12:16:24 <younder> a real eye opener
12:16:39 <theorbtwo> SICP is Structure and Intepretation of Computer Programs.
12:17:49 <younder> theorbtwo, I stand corrected
12:20:40 * hackagebot containers-benchmark 1.0.0.2 - Extensive benchmark suite for containers package.  http://hackage.haskell.org/package/containers-benchmark-1.0.0.2 (MilanStraka)
12:31:22 <jro> I have let [t, d, r, h] = map fromJust params in
12:32:13 <jro> Right fnct t d r h
12:33:14 <jro> when this map is evaluated?
12:33:56 <jro> if I do not need r and h in my function body, are those calculated at all?
12:34:13 <monochrom> no
12:36:46 * hackagebot haddock 2.9.0 - A documentation-generation tool for Haskell libraries  http://hackage.haskell.org/package/haddock-2.9.0 (DavidWaern)
12:36:49 <scree> jro: if params doesn't have length 4, you'll get an error immediately you try and force any of t, d, r, h
12:37:18 <scree> jro: but if any of the values is Nothing, you won't get an error until you force that exact element
12:38:46 <jro> I just thought that does forcing an one element force others to be computed, but now when I asked, that would not be very lazy
12:41:12 <jmcarthur> jro: taking this question the context of your previous question, i'm thinking you might be looking for catMaybes
12:41:18 <jmcarthur> *in the context
12:42:10 <jmcarthur> assuming that map fromJust is being applied to that same list
12:43:11 <jro> thanks for catMaybes, the problem that I was thinking is here http://bit.ly/fBA8Ah 
12:43:18 <jmcarthur> jro: anyway, to answer your question directly, the list spine will be evaluated (and you will get an error if the list doesn't contain exactly four elements), but the elements of that list will still only be evaluated as needed
12:44:41 <jmcarthur> ah i see
12:44:48 <jmcarthur> catMaybes may not be something you want after all then
12:46:37 * Cale adds a section to the Wikipedia article on Dirichlet series about combinatorics: http://en.wikipedia.org/wiki/Dirichlet_series#Combinatorial_importance  :)
12:49:59 <revenantphx> :t ⊕
12:50:17 <revenantphx> I'm wondering which unicode symbols can be used :\
12:50:24 <mauke> ALL OF THEM
12:50:25 <mauke> AT ONCE
12:50:50 <revenantphx> > let ∫ f x a b = {-- integral --}
12:50:51 <revenantphx> wheee
12:51:15 <revenantphx> > let ∫ x = x*x in ∫ 2
12:51:21 <ndrsndrs> revenantphx: I think anything in unicode symbol-ish categories can be used in ops, and same for lettery things and ids
12:51:22 <revenantphx> lambdabot is broken again?
12:51:35 <ndrsndrs> ∫ might be an op char, though
12:51:35 <revenantphx> I'm wondering which ones in the built in stuff are though.
12:51:56 <Cale> We're into heavy ping timeout land, so yeah.
12:52:04 <Cale> I'll bring it back up
12:52:44 <jmcarthur> @bot
12:52:51 <sproingie> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#unicode-syntax
12:52:52 <lambdabot> :)
12:52:55 <jmcarthur> :D
12:53:02 <revenantphx> ★... WHAT
12:53:05 <revenantphx> er, what*
12:53:09 <revenantphx> I mean what★
12:53:10 <sproingie> that's what's built-in using -XUnicodeSyntax.  otherwise it's whatever you define
12:53:25 <revenantphx> What's a good monospaced unicode font anyhow?
12:53:36 <mauke> DejaVu Sans Mono
12:53:37 <sproingie> dejavu sans mono 
12:53:42 <Cale> ★ would be used for kinds
12:53:44 <jmcarthur> dejavu sans mono and menlo both work
12:53:46 <revenantphx> I generally use Menlo... >_>
12:53:50 <revenantphx> Oh, that's cool.
12:53:56 <ndrsndrs> consolas :3
12:53:58 <revenantphx> menlo is easy to read.
12:54:03 <jmcarthur> > let ∫ x = x*x in ∫ 2
12:54:05 <revenantphx> idk how I feel about consolas. It's nice but, eh.
12:54:10 <lambdabot>   <no location info>: parse error on input `∫'
12:54:23 <sproingie> oddly U+2237 renders as two colons for me
12:54:30 <Cale> I use Dejavu Sans Mono, and let Freetype handle splicing in symbols from other fonts as necessary
12:54:34 <sproingie> separate chars and all
12:54:40 <revenantphx> Dejavu looks nice.
12:54:47 <jmcarthur> it should
12:54:53 <ndrsndrs> consolas doesn't have ∷ or ⇒ though, iirc
12:54:58 <jmcarthur> it's in the same family as menlo ;)
12:55:09 <revenantphx> Which family is that?
12:55:14 <sproingie> huh now i got a single ∷ char in irc
12:55:32 <jmcarthur> revenantphx: they both derive from bitstream vera
12:55:42 <revenantphx> http://static.arstechnica.net/apple/menlo_v_dejavu_sans_mono_300.png
12:55:43 <revenantphx> amusing.
12:55:48 <sproingie> dejavu sans mono 
12:55:51 <sproingie> doh
12:55:52 <revenantphx> The N and * are the only major differences.
12:55:52 <Cale> (On Linux, you don't need to worry about whether the specific font you're using has the appropriate symbol characters. So long as any font on your system has them, it will fill in the gaps.)
12:56:10 <sproingie> ah the web page isn't acually using the proportion codepoint
12:56:15 <revenantphx> Cale I'm familiar with freetype.
12:56:18 <jmcarthur> Cale: yeah but sometimes it does so fairly poorly unless you are sure to have some good fonts installed at all
12:56:27 <revenantphx> jmcarthur ^
12:56:45 <monochrom> yes, you are supposed to have some good fonts installed, or to be unpicky. :)
12:56:54 <sproingie> i've rarely seen freetype do the right thing as substitution goes
12:56:57 <Cale> jmcarthur: Yeah, if you're super-picky about it, you can tell it the order you'd like to layer things in. I do that for my Japanese fonts.
12:57:10 * monochrom chooses the unpicky route and just takes whatever ubuntu installs
12:57:13 * jmcarthur is a bit of a typophile sometimes
12:57:16 <sproingie> seems to be sensitive to the distribution
12:58:11 * monochrom actually has an exception concerning chinese fonts but not too badly. just apt-get installed two more packages, that's it.
12:59:14 <Cale> Yeah, it's annoying if some Chinese font takes over the job of handling hiragana and katakana, since they often don't have the best looking glyphs for those :)
12:59:31 <monochrom> And conversely Japanese fonts covering Chinese.
12:59:35 <Cale> yeah
13:00:10 <Cale> CJK unification can be a bit annoying in general, I suppose.
13:00:32 <tonkman> why any graphical, written is haskell, always opens a cmd to background
13:00:51 <Cale> tonkman: Who says it does?
13:00:57 <monochrom> does not happen to me
13:00:59 <sproingie> lemme guess, windows?
13:01:07 <Zao> sproingie: "cmd" implies that.
13:01:08 <tonkman> yeah, forgot to mention
13:01:27 <monochrom> what is your secret of success?
13:01:31 <Zao> gcc has flags like -mwindows to not create a console window.
13:01:40 <sproingie> hm i can never remember, there a runhaskellw or something?  
13:01:41 <Zao> I expect that GHC uses it accordingly.
13:01:52 <tonkman> Zao: thanks
13:01:57 <Zao> And of course, if you're running interactively, you're using the right launcher.
13:02:06 <sproingie> havent done haskell on windows in an age
13:03:18 <tonkman> ghc has a -optl-mwindows flag
13:04:32 <tonkman> cmd does not appear anymore, thanks
13:04:41 <monochrom> this is why sometimes I call windows "msdos". :)
13:06:35 <Zao> monochrom: On the other side of things, "you mean I have to start a command prompt, navigate to the directory of my program and launch it from there, typing in all the file arguments!?" would be the response to not showing a console window.
13:06:47 <Zao> With the rather common use case of "drag a bunch of files onto an executable".
13:07:35 <Zao> I'm personally more annoyed by the spam-happy programs that fl/oss developers love to write, as they normally don't use them from terminals.
13:07:43 <Zao> GTK+ and Qt, I'm looking at you!
13:07:51 <jmcarthur> spam-happy?
13:07:51 <Cale> ?
13:08:25 <Zao> jmcarthur: Just about any graphical application I use spams tons of "omg GTK widget couldn't do something, waaah" to stderr.
13:08:33 <byorgey> oh yeah, I hate that
13:08:35 <tonkman> actually, firefox is the only graphical program that I need
13:08:38 <jmcarthur> i use a launcher for those
13:08:40 <aristid> Zao: even emacs!
13:08:47 <tonkman> (and video player)
13:08:48 <Cale> The main thing I use nautilus for is browsing the photos that I've taken, particularly when extracting them from my camera, since it's a pain to tell which photos I want from the commandline.
13:08:50 <jmcarthur> but yeah, i hate that
13:09:10 <Zao> It's a pet peeve on the level of people who release code with warnings :D
13:09:20 <byorgey> they might as well just replace them all with  Gtk widget error: WOLF, HALP!!!
13:09:53 <monochrom> those are bugs of the graphical applications. here, my gtk2hs example spams you nothing because I use gtk correctly: http://www.vex.net/~trebla/haskell/gtk-interact.xhtml
13:10:55 <aristid> monochrom: looks like something that could be command-line
13:11:17 <jmcarthur> it's just an example
13:11:21 <Cale> Yeah, those messages are actually pretty helpful if you're writing the program. Maybe they're not even enough. GTK's API allows a lot of stupid things to go on which you don't find out about until runtime.
13:11:40 <Cale> (Like almost any C API)
13:11:57 <jmcarthur> does gtk2hs take any liberties with the API (e.g. tighter types)?
13:12:01 <monochrom> yes, you could argue why aren't programmer errors caught by the type system.
13:12:20 <jmcarthur> i've never actually used gtk2hs
13:12:46 <monochrom> I think gtk2hs adds a bit more type safety. But if you use glade you can still circumvent it.
13:12:49 <jmcarthur> or any of the haskell GUI libs for that matter
13:13:38 <jmcarthur> unless you count things like SDL... i wouldn't count that
13:14:01 <monochrom> I actually intend to use my example for real instead of the command line.
13:14:53 <joe6> tonkman: don't you need evince/xpdf?
13:15:04 <monochrom> There is something about the command line being single-line-oriented and hard-to-edit I dislike, and I only see salvation by GUI.
13:15:05 <Twey> You should make it eval Haskell, and feed it itself ;)
13:15:15 <cooolman> hey
13:15:17 <tonkman> joe6: those too
13:15:23 <monochrom> And yes, I mean even if the data I manipulate is "just text".
13:15:26 <tonkman> but actually the just show some text
13:15:42 <tonkman> *they
13:15:51 <adnap_> Can anyone familiar with hmatrix tell me if there is a way to get a specific column of a matrix without doing (!! x) . toColumns?
13:16:13 * Twey doesn't find the command-line particularly hard to edit.  Twey suggests that monochrom is using the wrong terminal.
13:16:37 <monochrom> then consider my example to be a right terminal
13:16:43 <sproingie> didn't someone whip up a SLIME-alike for haskell?
13:16:58 <monochrom> it doesn't do history yet but I will add that next time!
13:18:02 <Cale> adnap_: maybe subMatrix or trans . extractRows [n] . trans ?
13:18:27 <jmcarthur> it occurs to me that a terminal that works the way coqide does would be really awesome. the only problem is that rollback is tough
13:18:55 <lispy1> sproingie: scion, but I think it's dead now
13:19:05 <monochrom> a more important next step is adding this: on the left side, display a programmer-supplied description of what kind of text input is expected. For example if the f is a lambda evaluator, the description should say the expected syntax.
13:19:11 <lispy1> sproingie: at least, I the development moves at a glacial pace
13:19:53 <dixie> > Nothing >> Just "jozef"
13:19:54 <lambdabot>   Nothing
13:21:45 <Twey> monochrom: I'm not seeing what makes this difficult to do with a command-line…
13:22:04 <adnap_> Cale: I wonder what is fastest.  It's hard to tell.
13:22:15 <adnap_> Cale: I'm guessing subMatrix?
13:22:27 <Cale> adnap_: That would be my guess as well
13:22:46 <monochrom> Perhaps formalize your definition of command-line?
13:24:00 * hackagebot enumerator 0.4.3.1 - Implementation of Oleg Kiselyov's left-fold enumerators  http://hackage.haskell.org/package/enumerator-0.4.3.1 (JohnMillikin)
13:24:10 <jmcarthur> watching videos on the command line is annoying
13:24:17 <monochrom> haha
13:24:23 <jmcarthur> possible, but annoying
13:24:46 <Twey> monochrom: A purely textual interface in which interaction is accomplished by building complete commands to be sent, then sending them and awaiting a response
13:25:03 <Twey> jmcarthur: Not with svgalib ;)
13:25:06 <jmcarthur> why must it be purely textual?
13:25:29 <Twey> I suppose it needn't
13:25:42 <Twey> That's just the definition I was thinking of
13:25:44 <jmcarthur> Twey: doesn't svga remove that "textual" part of the definition anyway?
13:25:46 <monochrom> oh, let's say we want it textual for now. there are good use cases.
13:26:27 <Twey> jmcarthur: Not sure… the *interface* is still textual, no?  You just have an overlay atop it
13:26:41 <monochrom> now, I need help entering the input command correctly, e.g., order of parameters, special punctuations. what does your command line offer?
13:27:15 <Twey> monochrom: Tab-completion, an informative prompt, maybe a help message above the prompt
13:27:18 <dancor> a Clippy window segment
13:27:27 <jmcarthur> Twey: i suppose. my joke was relying on people thinking of things like AA-lib though
13:27:48 <Twey> jmcarthur: Aye, fair enough :þ
13:28:27 <monochrom> not "maybe", and not necessary "above". IMO the help message is compulsory, and it should be displayed concurrently on the side.
13:28:43 <jmcarthur> i don't see how that would not be possible in a CLI
13:28:48 <monochrom> and it does not disappear until you are done writing that command.
13:29:03 <jmcarthur> it's amazing what can be done with a customized shell
13:29:25 <nino> l
13:30:04 <Twey> monochrom: Well, the tab-completion might contain the context-sensitive help.  And why is the side (where you have less room) better than above?
13:30:24 <revenantphx> What does fl/oss stand for?
13:30:42 <Twey> revenantphx: Free-Libre/Open-Source Software
13:30:46 <revenantphx> jmcarthur: you could even have a gui inside your shell :)
13:30:56 <monochrom> perhaps the above contains past input and past output that I want to look at and copy for my current input. it's a crime to have the help message cover that up.
13:31:43 <Twey> monochrom: It doesn't have to cover it up… it's not going to be more than about four lines, and it can vanish when you've finished writing (so it doesn't take up an inordinate amount of history space)
13:31:43 <monochrom> and of course the help message must not cover up my current input either.
13:31:45 <jmcarthur> monochrom: you have to use screen real estate somewhere, GUI or not
13:32:05 <Twey> Just so
13:32:06 <monochrom> yes I have the screen real estate.
13:32:20 <jmcarthur> and there's also nothing stopping it from appearing *beside* your input anyway. no reason it has to take vertical space
13:32:39 <Twey> (though I still think that's a bad idea0
13:32:40 <Twey> )**
13:32:53 <revenantphx> What are you talking about monochrom?
13:34:17 <monochrom> well if it's the Eclipse Java IDE kind of contextual hovering help and suggestively named placeholder parameters, that may be livable.
13:34:36 <revenantphx> monochrom: ???
13:34:48 <jmcarthur> monochrom: in zsh i can hit alt-h while in the middle of typing a command and it pulls up the command's manpage, then i just hit q or escape and it takes me back to my in-progress command
13:34:54 <monochrom> please use the scroll buffer. it's too long to recount.
13:34:55 <adnap_> Cale: Here's what I came up with: getColumn i m = flatten $ subMatrix (0, i) (rows m, 1) m
13:35:03 <adnap_> Cale: Not sure if it's the best
13:36:11 <monochrom> does the alt-h display cover up current input, past input, past output?
13:36:37 <monochrom> I know you're yelling "needs screen real estate" but I really have the screen real estate.
13:37:02 <jmcarthur> monochrom: i can also make my own helpdir and set up my own command, which i could use to make it just show some help text and then remove it after i'm done with the command. shouldn't be too hard
13:37:26 <jmcarthur> the alt-h does by default cover everything up (just uses man)
13:37:28 <monochrom> And I would agree if you said I religiously take Raskin's "no modality, interrupting user's line of thought" seriously.
13:37:39 <monochrom> err
13:37:44 <monochrom> And I would agree if you said I religiously take Raskin's "no modality, no interrupting user's line of thought" seriously.
13:39:11 <revenantphx> monochrom: what is this >_<
13:39:19 <monochrom> UI debate
13:39:23 <revenantphx> Oh I see.
13:39:30 <revenantphx> I've... survived a few debates on modality.
13:39:35 <jmcarthur> monochrom: many shells also give you command-aware tab completion. i see no reason that mechanism couldn't also be used to just show you the command syntax on the side as well
13:40:06 <revenantphx> Is monochrom writing an awesome IDE
13:40:09 <revenantphx> because he should.
13:40:47 <livetester> :¬]
13:44:48 <unkanon> monochrom: what text editor do you use?
13:45:37 <monochrom> I think you answered my alt-h question. "just hit q or escape and it takes me back" well that's the crime I'm against. "just hit q or escape to make the manpage disappear" sure no problem. but "take me back"? your keyboard focus should be always staying with your in-progress command and it should be always displayed, there is no "going back" because there shouldn't be no "going elsewhere" to begin with.
13:46:30 <monochrom> I use emacs and gedit and vim.tiny and nano
13:47:20 <adnap_> Does anyone know why (.*) is deprecated in hmatrix?  Is there something else I'm supposed to use instead?
13:48:05 <Twey> monochrom: … which a contextual display above the prompt would do fine
13:48:08 <unkanon> monochrom: all of those are modal, no? you said you don't like modality.
13:48:18 <adnap_> Ah, I think there's a scale in Algorithms now.  nvm
13:48:23 <Twey> None of them are modal
13:48:30 <unkanon> ??
13:48:46 <unkanon> maybe we have different definitions of modal?
13:48:51 <Twey> monochrom: It would also hide less than a tooltip — it would take up only as many lines as it needed, and not obscure parts of lines.
13:49:10 <adnap_> Wait, that's old too.
13:49:20 <unkanon> gedit isn't modal but vim and emacs are
13:49:26 <Twey> unkanon: Modal editing: an editing paradigm in which editing a document involves switching between various modes to perform different functions (see: vim)
13:49:30 <Twey> unkanon: emacs is not modal.
13:49:43 <unkanon> emacs is less modal, but it still is modal
13:49:48 <monochrom> If it also doesn't cover up past input and past output, I'm fine with where the manpage appears.
13:49:55 <Twey> It has different modes, but they're just for editing different documents: switching modes is not part of the editing process.
13:50:14 <Twey> monochrom: A tooltip would hide history.
13:50:31 <monochrom> yeah
13:50:32 <unkanon> Twey: when I do C-x it puts me in a different mode that is not the insert mode
13:51:02 <Twey> unkanon: Mmm, alright.
13:51:04 <unkanon> it's now in a mode of waiting for the next input
13:51:18 <monochrom> emacs is non-modal most of the time. and I treat C-x C-c as an atomic ligature so it's not too modal.
13:51:34 <unkanon> right, it's not too modal, just modal-ish
13:51:40 <monochrom> hell, I even treat C-x C-f funny.hs as an atomic ligature!
13:52:10 <unkanon> I name all my haskell programs test.hs because I have no creativity
13:52:13 <Twey> Yeah, I'm with monochrom: it's really not a full-blown mode, per se
13:52:24 <Twey> But I can see how you might analyse it as one.
13:52:25 <unkanon> agreed.
13:52:29 <monochrom> oh, my funny.hs isn't all that better either!
13:52:49 <unkanon> at least you thought of something interesting. test.hs is pretty bland. and then comes test2.hs
13:52:58 <unkanon> which nullifies command-line tab completion right there
13:53:12 <monochrom> I tolerate vim.tiny because in case of no-GUI it is more featureful.
13:53:55 <monochrom> Also it's almost the first editor I learned so it kind of enjoys a fast device driver in my head.
13:55:03 <monochrom> I have a ring-0 device driver for vi. It no longer feels modal. :)
13:57:31 <jro> http://bit.ly/gJwjam
13:57:45 <monochrom> hahaha
13:58:10 <monochrom> My habit of avoiding the name "test" was trained by unix's "test".
13:59:34 <monochrom> I.e., you enter "ghc --make test.hs" and then you "test" and then, eh, nothing happens! Well at least it terminates. :)
13:59:57 <jro> . in path is evil
14:00:27 <blackdog> monochrom: "find ~ -iname test.hs" reveals a litany of shame
14:01:28 <unkanon> jro: lol
14:02:26 <sm> has anyone managed to build process on windows recently ?
14:03:22 <sm> I get a bunch of syntax errors in runProcess.c
14:04:34 <dixie> this repo is 404 :-( http://darcs.haskell.org/gtk2hs/demo/
14:04:51 <dixie> what is the current ? 
14:05:53 <monochrom> if you do "cabal unpack gtk" you will get the demo directory. this just requires talking to hackage.
14:07:26 <dixie> monochrom: thanks. I have some bookmarks on gtk2hs packges in haskell.org wiki but most of them are broken. seems you suggestion works.
14:07:55 <monochrom> haskell.org migration loses track of many things including the gtk2hs home.
14:10:17 <monochrom> although some demos use deprecated functions
14:11:23 <dolio> Do we seriously have people arguing, "we shouldn't fix various library bugs, because it would make some Haskell books obselete"?
14:11:37 <dolio> "They should be fixed in a Haskell successor."
14:12:05 <monochrom> I haven't heard of such a stance.
14:12:18 <dolio> Check the libraries list.
14:12:39 <monochrom> is there a notorious example of such a bug?
14:12:58 <dolio> People want to make Functor a superclass of Monad.
14:13:13 <dolio> That's the thread this discussion is happening in.
14:13:37 <monochrom> I see. That one is difficult.
14:14:48 <monochrom> I personally would not mind fixing it in Haskell 2011.
14:14:56 <dolio> Actually, Functor => Applicative => Monad
14:15:11 <monochrom> If necessary I offer free errata for various books.
14:15:28 <monochrom> And I don't mind even that in Haskell 2011.
14:15:46 <ArtyomKazak> Where can I get "All About Monads" tutorial? The link on HaskellWiki is broken, and Google finds only one PDF file, but I need HTML
14:15:56 <BMeph> monochrom: You are a purveyor of erratic ature, then? ;)
14:16:00 <dolio> Well, if we're going to fix Functor and Monad, might as well go all the way.
14:16:03 <BMeph> Drat!
14:16:19 <BMeph> "erratic *literature"
14:17:27 <revenantphx> I hate research papers.
14:17:35 <revenantphx> (on topics I don't care about)
14:17:47 <monochrom> I see the problem, the html version has just disappeared, the domain name has changed hands.
14:18:08 <ddarius> revenantphx: No where near as exciting a tech magazine articles on topics you don't care about.
14:18:24 <revenantphx> ddarius: try that again?
14:18:57 <revenantphx> I think just about anything is less dull than the kent state shootings.
14:19:12 <bremner> not for those involved
14:19:22 <revenantphx> To me it's jsut... Okay... yeah.... I guess I could tie in Du Contrat Social... ok, blah
14:19:27 <revenantphx> now I actually have to read it
14:19:33 <dqd> ArtyomKazak: http://web.archive.org/web/20080626073933/http://www.haskell.org/all_about_monads/html/
14:19:54 <revenantphx> write it*
14:22:26 * hackagebot idiii 0.1.2 - Reading and writing of ID3v2 tags  http://hackage.haskell.org/package/idiii-0.1.2 (ChrisWagner)
14:22:30 <ArtyomKazak> Oh, why haven't I thought about archive.com Thank you!
14:25:29 <monochrom> the name "idiii" is funny :)
14:26:03 <monochrom> hmm does hackage and cabal work fine with chinese package names?
14:34:03 <revenantphx> hey monochrom, one question.
14:34:22 <revenantphx> I'm not doing this now, but it just came up as a theoretical question...
14:34:28 <revenantphx> if you have something *very* stateful, like a server.
14:34:54 <revenantphx> Is it fine to just stick *everything* in a record of TVars or something like that?
14:35:08 <revenantphx> Perhaps even just have a single TVar Map and have that go to everything >_>
14:35:09 <copumpkin> why must a server be stateful?
14:35:36 <revenantphx> Well, specifically a minecraft server. A friend claims you couldn't write it in haskell, and I disagree. Thats irrelevant.
14:35:37 <hpc> why must large state preclude mutation?
14:35:45 <revenantphx> hpc: it doesnt...
14:35:53 <monochrom> I wrote a toy server and I used MVar for some states. Today I use TVar. They are shared states - multiple threads want to read/write them.
14:36:03 <revenantphx> Yep
14:36:12 <revenantphx> Out of curiosity, how fast is TVar?
14:36:25 <revenantphx> What's the overhead of an atomically transaction without any contention?
14:36:28 <monochrom> I probably don't have much of thread-local state to speak of.
14:36:29 <blackdog> presumably you want a persistence layer too? or is that just a checkpointing sort of thing?
14:36:32 <Twey> About three times slower than MVar, last I saw
14:36:34 <revenantphx> Since its lockless I'd guess pretty low.
14:36:40 <revenantphx> Twey: hm.
14:36:54 <revenantphx> No, I would not have *any* thread local state that I can think of.
14:36:56 <Twey> Significant, but not terrible.
14:37:10 <revenantphx> MVar's not too hard in any case.
14:37:15 <Twey> That was some time ago, though — might be nicer now.
14:37:22 <revenantphx> The basket analogy is pretty easy to work with.
14:38:04 <revenantphx> modifyMVar makes it possibly more convenient than STM some times I guess.
14:38:21 <Twey> revenantphx: STM lets you do things that you actually can't do with an MVar, though.
14:38:34 <Twey> If you take MVars, you have to do all the locking and stuff yourself, like in Java.
14:38:35 <revenantphx> like?
14:38:42 <Twey> Rollback
14:38:50 <danderson> revenantphx: STM isn't really lockless, the locking is just hidden in the machinery, with various semantic guarantees on how it happens
14:39:00 <Twey> Personally, I'd go for the TVar and maybe consider switching to MVars as an optimisation later if STM proved too slow
14:39:06 <monochrom> atomically ((takeTMVar x >>= ... ) `orElse` (takeTMVar y >>= ...))
14:39:12 <danderson> but even an uncontentioned transaction will involve locking, and probably more than a specifically designed MVar locking setup
14:39:16 <revenantphx> monochrom ?
14:39:26 * ddarius will need to reign in the communication somehow.
14:39:29 <monochrom> do you know "orElse"?
14:39:32 <revenantphx> Yeah...
14:39:37 <danderson> the argument is that STM lets you not break your brain coming up with the right locking semantics by hand
14:39:45 <revenantphx> mm
14:40:15 <c_wraith> In particular, TChan actually works properly in use cases where Chan doesn't.
14:40:30 <danderson> (and that it offers semantics that are much nicer than the typical explicit locking semantics, e.g. retry and composable transactions)
14:41:27 <revenantphx> I should try writing a server in haskell.
14:41:32 <c_wraith> But I'm still standing by my assertion that the STM implementation isn't appropriate in the case where you have a single mutable cell and many clients that use it in a read/modify/write cycle.
14:41:34 <revenantphx> That'd be a really interesting project.
14:41:40 <ddarius> danderson: There are lock-less implementations.  Also there is a term "lock-free" which has to do with certain guarantees rather than implementation mechanism.
14:41:40 <jmcarthur> revenantphx: if you're just going to have a single shared variable for your global state then there is no reason to use STM at all. STM is best for those cases when you have lots of shared variables with access patterns that you perhaps haven't anticipated up front
14:41:53 <revenantphx> jmcarthur: heh... heh... yeah, I'd have a *lot*
14:42:08 <revenantphx> Many many maps and so on.
14:42:25 <jmcarthur> revenantphx: so basically my recommendation is to avoid going for that TVar Map idea. it's pointless and would be much more complicated than just using STM as intended
14:42:31 <jmcarthur> and probably slower, to boot
14:42:43 <revenantphx> jmcarthur: Oh, well the TVar Map idea was just a thought (which I found silly)
14:42:51 <revenantphx> I'd prefer to do a TVar MyServerState
14:42:59 <revenantphx> where MyServerState is a record with all the relevant bits.
14:43:04 <jmcarthur> a single TVar will tend to be slower than a single MVar, but many TVars are often much much faster than many MVars, depending on access patterns
14:43:16 <ddarius> Putting all your state into one transactional variable is quite the pessimization.
14:43:17 <revenantphx> Oh, one thing I see often.
14:43:22 <revenantphx> nmd.
14:43:24 <revenantphx> ddarius: what?
14:43:30 <revenantphx> Er, sorry, I mystyped that.
14:43:38 <revenantphx> I meant a record of TVars.
14:43:48 <jmcarthur> ddarius means that you basically lose the benefits of optimistic concurrency, i think
14:43:51 <jmcarthur> ah
14:43:54 <jmcarthur> that's okay then
14:44:05 <revenantphx> data AmityState = AmityState { port :: Port, sessionId :: String, pktQueue :: TChan ClientToServerPacket, entityMap :: TVar (IntMap Entity), selfEID :: TVar Int32}
14:44:09 <revenantphx> thats what I use for my bot.
14:44:43 <c_wraith> Yeah, STM doesn't seem right there.
14:44:55 <revenantphx> c_wraith: how so?
14:45:11 <c_wraith> Is that the entirety of the server state?  A single copy of that?
14:45:17 <jmcarthur> is Entity using TVar internally as well? might be nice then
14:45:21 <revenantphx> c_wraith: yeah, pretty much.
14:45:31 <monochrom> In particular Chan is/was buggy: http://thread.gmane.org/gmane.comp.lang.haskell.glasgow.user/18667/focus=18687
14:45:35 <revenantphx> Entity does not use TVar internally at the moment.
14:45:44 <revenantphx> I didn't really see the point :\.
14:45:46 <monochrom> and TChan is recommended
14:45:57 <jmcarthur> or perhaps entityMap :: TVar (IntMap (TVar Entity)) would be alright
14:46:00 <jmcarthur> eh no point, yeah
14:46:06 <revenantphx> jmcarthur: why would that be better at all >_
14:46:09 <revenantphx> >_<*
14:46:19 <jmcarthur> revenantphx: the point is that if multiple threads update multiple entities then they can do some concurrently
14:46:36 <jmcarthur> but i don't know how you intend this to work
14:46:40 <revenantphx> Ah, i see.
14:47:01 <jmcarthur> most transactions will likely be very short and fast in the first place
14:47:34 <jmcarthur> redundant sentence is redundant
14:48:07 <c_wraith> the use case you want to avoid, at all costs, with STM, is "many threads read the same tvar.  each modifies the value, and tries to write it back"
14:48:20 <revenantphx> c_wraith: right, prevent retrys?
14:48:25 <c_wraith> yes.
14:48:32 <revenantphx> how can you generally avoid that?
14:48:41 <revenantphx> In a server I would have a lot of that.
14:48:45 <jmcarthur> basically the more fine grained you can make your transactions the better
14:48:46 <c_wraith> either have many TVars, or use an MVar
14:49:01 <revenantphx> Every single client sending position updates, modifying a map of entities
14:49:19 <monochrom> I would refine that to: either have many fairly independent TVars, or use an MVar
14:49:22 <jmcarthur> i assume the map can also have entities added or removed?
14:49:37 <Philippa> a chan can work for that
14:49:38 <c_wraith> I agree monochrom's refinement of my statement is an improvement
14:49:41 <revenantphx> mm
14:49:47 <revenantphx> Philippa: thats what I was thinking.
14:49:48 <c_wraith> err, agree *with*
14:49:57 <revenantphx> My trusty "serialize it all through a chan" strategy ;D
14:50:01 <revenantphx> works for *everything*
14:50:06 <jmcarthur> if the case is that entities aren't frequently added and removed, as long as each entity is in its own TVar then it's manageable
14:50:23 <revenantphx> okay, let me put it this way.
14:50:28 <jmcarthur> if they are added and removed from the map frequently then that map is going to be a major point of conflict
14:50:31 <revenantphx> if I have NPCs, I might have 1000 entities to manage.
14:50:38 <revenantphx> Each one of those is moving 30+ times per second.
14:50:52 <Philippa> that's not that much :p
14:50:52 <revenantphx> Doesn't sound too great for TVar, eh?
14:50:58 <jmcarthur> sounds perfect for it
14:51:02 <Philippa> doesn't sound great for /one/ TVar
14:51:06 <revenantphx> Philippa: right.
14:51:08 <Philippa> sounds wonderful for one per entity
14:51:12 <jmcarthur> yeah, sounds perfect for *many* tvars
14:51:45 <jmcarthur> revenantphx: have you ever written a game before?
14:51:49 <ezyang> I think common subexpression elimination is harmful. I should be allowed to state when I want the itme/cpu tradeoff 
14:52:06 <revenantphx> jmcarthur: No, but I've written a lot of bots and servers :\
14:52:12 <jmcarthur> ezyang: argue with roconnor about it please :)
14:52:26 <ezyang> jmcarthur: Heh :-) 
14:52:31 <revenantphx> Wait, I have one question
14:52:33 <jmcarthur> ezyang: i lean toward your sentiment in general
14:52:36 <Philippa> ezyang: it's (potentially) harmful by default in a lazy language, yes
14:52:38 <monochrom> you may have to benchmark different approaches
14:52:45 <c_wraith> Also, for that use case, I don't like TVar IntMap (TVar Entity) is good.  It will cause any update to the IntMap to make all in-flight entity updates retry.
14:52:45 <revenantphx> Philippa: So if I have one per entity, then would I have a TVar IntMap (TVar Entity)?
14:52:58 <jmcarthur> revenantphx: i ask because most games just iterate over all the entities to update in a single loop rather than running them concurrently
14:53:04 <ezyang> Though, it would be kind of cool if the compiler had knobs that you could specify how big the result of a thunk would have to be versus time to compute to discard it. 
14:53:06 <revenantphx> c_wraith: you got me before I could ask :P
14:53:11 <Philippa> depends: do you need serialisable or otherwise not-a-TVar references to your entities?
14:53:32 <revenantphx> jmcarthur: Mm, thats true, but wouldn't it be interesting to do it otherwise :P?
14:53:35 <Philippa> jmcarthur: that's the case now, yeah, but it can't stay the case
14:53:41 <revenantphx> jmcarthur: over 9000 virtual threads?
14:53:53 <ezyang> whooo 
14:53:57 <jmcarthur> ezyang: it would also be cool if the runtime could unevaluate thunks if they were too big, say at the will of the GC
14:54:10 <jmcarthur> based on some time/space tradeoff as measured at runtime
14:54:15 <revenantphx> c_wraith: so basically, what would I use then?
14:54:21 <Philippa> there are no virtual threads, just threads provided by the OS or otherwise :p
14:54:44 <jmcarthur> revenantphx: i'm not saying it's bad to use concurrency for this. i was just suggesting that this is not the only way, that's all
14:54:57 <revenantphx> jmcarthur: I dont think concurrency is the best way for mobs at all.
14:54:59 <revenantphx> :P
14:55:03 <revenantphx> Just thinking about it.
14:55:10 <jmcarthur> that's fine
14:55:16 <revenantphx> TVar IntMap (TVar Entity) has the issue you just pointer out, c_wraith, but what would be an alternative?
14:55:25 <jmcarthur> some systems really do become complicated enough that it's worth it to think about it this way, honestly
14:55:27 <c_wraith> Well, if you have the case that entities are added and removed infrequently, but modified often, I might consider IORef (IntMap (TVar Entity)), using atomicModifyIORef for updates to the IORef
14:55:51 <jmcarthur> c_wraith: i'd still set that as a TVar, personally
14:56:10 <Philippa> revenantphx: what's the IntMap /for/?
14:56:17 <revenantphx> The thing is, he is right, if the map itself is in a TVar, even non-colliding updates would force retries.
14:56:20 <jmcarthur> c_wraith: what if and entity should only be added or removed on the condition that some other transaction goes through?
14:56:24 <jmcarthur> *an
14:56:26 <revenantphx> Philippa: a map of entities to data about them.
14:56:32 <revenantphx> entityID -> Entity
14:56:37 <revenantphx> (where entityID is an Int32)
14:56:42 <jmcarthur> and then that would also affect other transactions, of course
14:56:46 <Philippa> c_wraith: unless you've got a really good excuse, just collect entities between frames while they're not interacting
14:56:49 <ddarius> revenantphx: I working on a program right now that spawns a thread for each entity (about 4000 is probably what I'll use typically.)  Each of those entities spawn threads off regularly for periodic work as well as quite often for communication.  I probably have like tens of thousands of threads going in the more active moments.
14:56:59 <mreh> @src mconcat
14:56:59 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
14:57:02 <Philippa> revenantphx: what makes TVar an insufficient entityID?
14:57:17 <revenantphx> Philippa: ???
14:57:20 <jmcarthur> Philippa: probably a minecraft-specific thing
14:57:27 <c_wraith> Philippa, it can't be serialized and sent over the wire
14:57:33 <revenantphx> c_wraith: ^
14:57:46 <Philippa> c_wraith: yes, I know of that one, I was just waiting to see if there are any others :-)
14:58:55 <revenantphx> On a totally separate note: https://gist.github.com/731161
14:58:56 <revenantphx> D:
14:59:02 <Philippa> so next question: why does it need to be particularly transactional?
14:59:10 <adnap_> if you put something in an IORef, is it necessarily evaluated?
14:59:15 <Philippa> adnap_: nope
14:59:16 <copumpkin> adnap_: no
14:59:18 <adnap_> cool
14:59:20 <revenantphx> Philippa: Well, I don't know which is why I'm asking :P
14:59:30 <adnap_> So, I can put an infinite list in an IORef, for example.
14:59:37 <jmcarthur> revenantphx: ah, enummap has not been very well maintained it seems. maybe try hacking its dependency versions
14:59:38 <monochrom> "Perhaps you need to add `base' to the build-depends in your .cabal file."
15:00:13 <ville> How's Haskell development targeting Android looking these days?
15:00:17 <Philippa> third question: is IntMap still the right type, or should we be rigging up something else that at least doesn't get into a mess about demands for the next fresh ID?
15:00:24 <ddarius> adnap_: You could do that even if IORefs forced their contents, which they do not.
15:00:31 <revenantphx> Philippa: ...what?
15:00:32 <monochrom> containers-0.2 is old.
15:00:35 <ddarius> adnap_: There are absolutely no restrictions on what you can put into an IORef.
15:00:39 <revenantphx> Each entity is stuck with a specific entityID.
15:00:49 <revenantphx> From the time it spawns to the moment it despawns.
15:00:57 <Philippa> sure. What happens when two newEntity calls collide, though?
15:01:04 <revenantphx> Ah, I see.
15:01:08 <jmcarthur> well, there are some corner case restrictions. i doubt you could put unboxed values into IORefs
15:01:12 <revenantphx> Actually.
15:01:17 <revenantphx> Given that I'm generating the entityIDs here.
15:01:25 <revenantphx> It might be more appropriate to use some array type.
15:01:35 <davidcsunshine> I have monad question. I have something of Type ServerPartT IO String, and I would like to reduce it to IO String is there a way to do this?
15:01:36 <ddarius> jmcarthur: That's because unboxed values are arguably not values.
15:01:45 <jmcarthur> as long as you can recycle IDs, revenantphx, otherwise you waste space
15:01:53 <revenantphx> jmcarthur: right.
15:01:58 <revenantphx> TArray looks suitable tbh.
15:02:01 <ezyang> davidcsunshine: Do you have a runserverPartT? 
15:02:03 <revenantphx> Array ix (TVar e)
15:02:07 <c_wraith> davidcsunshine, that's entirely a happstack question, having basically nothing to do with monads. :)
15:02:10 <ezyang> That will usually result in IO String. 
15:02:27 <twaffle> should "type MyParser a = (Stream s Identity Char) => Parsec s MyState a" perhaps be a newtype instead of a type synonym? also, why does that type synonym require Rank2Types?
15:03:21 <davidcsunshine> ezyang: I have runServerPartT, but that still wraps the IO monad, if I'm reading it's type correctly
15:03:28 <Philippa> revenantphx: anyway, I think my point is more that the only things that need to be atomic are entityID allocates (/not/ the process of slotting it into the map, just "you've got the ID") and deallocates. And deallocates shouldn't be a big problem either so long as you don't try to reuse the ID too quickly
15:03:47 <revenantphx> Philippa: as well as modifying existing entries.
15:04:02 <revenantphx> But if its in something like a TArray that should be fine, since each individual entry is a TVar.
15:04:06 * ddarius was tricked!
15:04:06 <c_wraith> davidcsunshine, What's your larger goal?  Why are you trying to execute the server action?
15:04:09 <Philippa> entries point straight to TVars, so that shouldn't be happening much
15:05:01 <davidcsunshine> c_wraith: My larger goal is to feed the ServerPartT IO String into a call to doesDirectoryExist
15:05:31 <revenantphx> Philippa: okay, TArray is of fixed size, so maybe not so good.
15:05:36 <monochrom> you should liftIO (doesDirectoryExist xxx) instead
15:05:43 <c_wraith> davidcsunshine, work the other direction.  work inside ServerPartT IO, using liftIO
15:06:05 <Philippa> yeah, I'm more saying "don't expose the 'basic' structure", not "don't use IntMap at all"
15:06:30 <revenantphx> I'm still stuck on the issue of how to keep all of the TVar entities.
15:07:13 <revenantphx> If I use a TVar IntMap, I have the issue c_wraith mentioned.
15:08:01 <davidcsunshine> c_wraith: Thanks; I'll look into that
15:08:01 <aavogt> twaffle: because you're suggesting that type works for any s, since you don't mention it on the left hand side
15:08:07 <c_wraith> revenantphx, as jmcarthur pointed out, sometimes you want that.  And Philippa pointed out that if you schedule adds and removes instead of doing them immediately, they shouldn't conflict with anything.
15:08:20 <revenantphx> Hm.
15:08:48 <revenantphx> The thing is, I need each modification of the entity table to occur before the next one.,,
15:08:54 <Philippa> to put it another way, you shouldn't be churning half your max entity size per frame anyway :-)
15:09:07 <revenantphx> i guess a TChan queueing modifications would work.
15:09:11 <Philippa> table is cheap, is-it-free structure less so
15:09:38 <Philippa> (IntMap is both simultaneously, sort-of, but how efficient is the "lowest free Int" call?)
15:09:49 <Philippa> to put this another way, you're writing a memory allocator
15:09:57 <Philippa> thankfully, you only have to allocate one block size
15:10:03 <roconnor> ezyang: what is the question?
15:10:04 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
15:10:04 <revenantphx> I didn't think of it like that...
15:10:10 <revenantphx> I've done a few really basic allocators >_>.
15:11:36 <twaffle> aavogt: I see that, but I don't see how that makes it rank-2
15:11:55 <jmcarthur> revenantphx: if you're queueing modifications... you might as well just use a loop instead of concurrency anyway, no?
15:12:39 <revenantphx> TVar IntMap (TVar Entity)
15:12:44 <revenantphx> is the most up front and simple approach.
15:12:47 <jmcarthur> time to eat
15:12:54 <revenantphx> I know it'll work, though not so sure performance wise and so on.
15:13:23 <roconnor> koninkje_away: *ping*
15:13:48 <revenantphx> Now to think about the entityID allocation...
15:14:17 <ezyang> roconnor: It was about CSE 
15:14:37 <revenantphx> Maybe I should start that by writing a fictional memory allocator in haskell.
15:14:46 <revenantphx> Just to work out how to do it
15:15:51 <Philippa> jmcarthur: I don't think it's a disaster to queue /only/ entity alloc/free, it's a big leap up still
15:16:55 <aavogt> twaffle: say you have     f :: Int -> MyParser a,  this is  actually:    f :: forall a. Int -> (forall s. Stream s Identity Char => Parsec s MyState a)
15:17:02 <sleepynate> @pl \(a,b) -> (f a, g b)
15:17:03 <lambdabot> f *** g
15:17:48 * ddarius contemplates going and eating a big, fat steak again.
15:18:10 <ddarius> Someone modified @pl?  Or did it "always" do that?
15:18:24 <sleepynate> ~_^ ?
15:18:25 <aavogt> twaffle: which makes it need -XRank2Polymorphism
15:18:32 <sleepynate> ddarius: do what?
15:18:45 <ddarius> Use (***)
15:18:47 <twaffle> aavogt: oh I see
15:18:56 <sleepynate> ddarius: mmm, no idea :P
15:19:53 <benmachine> ddarius: I don't remember it doing that before
15:22:14 <hpc> :t first
15:22:15 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
15:22:43 <revenantphx> So, I've wondered for a bit, what exactly are arrows?
15:22:52 <revenantphx> Do you guys have a paper I can read later on them?
15:25:33 <hpc> revenantphx: they are a generalization of functions, approximately
15:25:42 <ddarius> http://personal.cis.strath.ac.uk/~raa/msfp-slides-arrows.pdf
15:26:14 <revenantphx> ddarius: instantly I see category stuff I don't know.
15:26:23 <revenantphx> I need an intro to category theory type book >_>
15:26:42 <monochrom> Someone modified @pl. It used to try very hard with curry, uncurry, and liftM2
15:26:43 <ddarius> Very few introductions to category theory would cover Freyd categories.
15:26:50 <ddarius> Also, that was a bit of a joke.
15:27:11 <mreh> mappend x (mappend y z) = mappend (mappend x y) z
15:27:21 <mreh> isn't that also known as commutitivity
15:27:37 <benmachine> no
15:27:38 <ddarius> (Freyd categories aren't particularly complicated, they are just only interesting to a small subset of categorists.)
15:27:45 <benmachine> commutativity is op x y = op y x
15:27:51 <benmachine> that's associativity
15:27:56 <hpc> revenantphx: Arrow is a sub-class of Category
15:28:03 <mreh> right, okay, right concept, wrong name
15:28:03 <hpc> Category defines id and (.)
15:28:04 <revenantphx> I don't know about "Category" either...
15:28:16 <hpc> id :: Category cat -> cat a a
15:28:26 <hpc> er
15:28:38 <hpc> id :: Category (~>) => a ~> a
15:28:55 <hpc> (imagine ~> = -> for now)
15:28:59 <mreh> x `op` (y `op` z) == (x `op` y) `op` z
15:28:59 <roconnor> ezyang: I actually don't know much about what GHC does for CSE.
15:29:05 <hpc> similar for (.)
15:29:14 <sproingie> yampa arcade paper covers a practical application of arrows
15:29:18 <revenantphx> k....
15:29:21 <hpc> Category also provides (>>>) and (<<<)
15:29:22 <ddarius> GHC does rather little CSE and is pretty careful about it.
15:29:34 <mreh> hpc: post GHC 6.10?
15:29:36 <hpc> i forget which one is an alias for (.), and the other is a flipped version
15:29:44 <benmachine> (<<<) = (.)
15:29:45 <hpc> mreh: latest docs
15:30:11 <hpc> Category just gives us identity and composition
15:30:13 <mreh> hpc: yeah, I couldn't remember when they introduced category
15:30:18 <hpc> which is useful, but Arrow does much more
15:30:28 <revenantphx> mm
15:30:34 <hpc> Arrow first defines arr
15:30:40 <mreh> @arr
15:30:41 <lambdabot> Shiver me timbers!
15:30:48 <hpc> arr :: (b -> c) -> (b ~> c)
15:30:50 <ddarius> Where "much" means just adding a tensor product construction.
15:30:53 <hpc> so it lifts a function into an arrow
15:31:02 <hpc> for functions, arr = id
15:31:16 <ddarius> Oh yeah, and the injection.
15:31:20 <revenantphx> k
15:31:37 <hpc> it defines first :: (b ~> c) -> (b, d) ~> (c, d)
15:31:55 <hpc> which for functions, is \f (a, b) -> (f a, b)
15:32:10 <mreh> oh, infix arrow notation
15:32:20 <ddarius> (And technically by "tensor product" I mean premonoidal product.)
15:32:22 <hpc> it defines second in a very similar way
15:32:27 <revenantphx> hey hpc, can we take a raincheck? I have to go.
15:32:27 <monochrom> infix squiggy arrows!
15:32:31 <hpc> ah, k
15:32:34 <revenantphx> I need to finish this goddamn essay.
15:32:40 <revenantphx> I promised myself to get done a certain portion daily
15:32:48 <revenantphx> This is the worst essay of the year...
15:32:51 <sproingie> arrows appear to be for people who can't get enough tuples
15:32:52 <revenantphx> and I'm tryng something new...
15:33:02 <revenantphx> *not doing it the night before its due*
15:33:06 <revenantphx> I'm going to see if it works better.
15:33:10 <mreh> never
15:33:20 <hpc> sproingie: more like, arrows are what make tuples tolerable
15:33:31 <revenantphx> Procrastination for me is Haskell. :3
15:33:33 <sproingie> i guess you could see it that way too
15:33:45 <revenantphx> Thanks anyways, I'll be back later to try to write a server....
15:33:57 <revenantphx> I'd like to try something other than lazy IO with Binary.
15:34:06 <mreh> mconcat == foldl mappend mempty?
15:34:11 <ddarius> foldr
15:34:27 <mreh> doh, mappend is no commutative
15:34:37 <aavogt> it is associative
15:34:40 <sproingie> i had a kinda deeper understanding of arrows reading the yampa arcade paper but i dont get the overall abstraction
15:34:45 <ddarius> Actually, I think mconcat is a method of Monoid so it can be whatever you want.
15:35:00 <ddarius> @src mconcat
15:35:00 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
15:35:01 <mreh> ddarius: but as a general rule
15:35:05 <sproingie> probably my lack of category theory background
15:35:09 <aavogt>  a ++ (b ++ c)   == (a ++ b) ++ c   sort of as a rule, mreh
15:35:12 <mreh> it's not true for all Monoids
15:36:04 <ddarius> mreh: On finite, totally defined input lists, there is no semantic difference between foldl and foldr when given an associative operator.
15:36:16 <benmachine> it's a law of the Monoid class that mconcat = foldr mappend mempty
15:36:19 <mreh> sproingie: they allow you to do more static analysis at the cost of less expressivity
15:36:19 <blackh> revenantphx: Arrows are an abstraction where you have things that look like functions, so a b c looks like b -> c, except that it can have effects.  I did a tutorial which I think fills in a gap... I'll find the link
15:36:34 <aavogt> mreh: http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.0.0/Data-Monoid.html discusses mappend being associative
15:36:40 <sproingie> i thought the monoid operator always had to be associative
15:37:06 <thoughtpolice> isn't that kind of part of the definition of a monoid?
15:37:24 <blackh> revenantphx: http://en.wikibooks.org/wiki/Haskell/StephensArrowTutorial
15:37:27 <mreh> I'm still learning them it seems :)
15:37:33 <benmachine> sproingie: it does
15:37:34 <rainman_> How does a monad work?
15:37:45 <sproingie> monad fairies
15:37:51 <benmachine> rainman_: that's a weird question, what do you mean?
15:37:56 <blackh> revenantphx: I just realized my reply was really late. :)
15:37:59 <mreh> god did it
15:38:07 <sproingie> rainman_: by defining the functions in the Monad typeclass
15:38:27 <benmachine> I wonder what the motivation for mconcat being a class method is
15:38:38 <benmachine> none of the instances in Data.Monoid define it except the () instance
15:38:42 <benmachine> which defines it wrongly :P
15:38:54 <jmcarthur> @src () mconcat
15:38:54 <mreh> benmachine: to define things like Writer
15:38:55 <lambdabot> Source not found. It can only be attributed to human error.
15:38:57 <ddarius> benmachine: instance Monoid Sum
15:39:18 <sproingie> rainman_: look for 'instance Monad' in the ghc library sources (or just mtl) and you'll see how some monads work
15:39:26 <rainman_> Thx
15:39:31 <benmachine> ddarius: the instance for Monoid (Sum a) doesn't define mconcat
15:39:38 <ddarius> benmachine: It should though.
15:39:39 <benmachine> mreh: I don't follow
15:39:43 <revenantphx> no problem blackh
15:39:51 <benmachine> ddarius: to use foldl instead of foldr, you mean?
15:40:00 <ddarius> To use foldl' instead of foldr, yes.
15:40:08 <mreh> it doesn't need to define mconcat, it has a default implementation
15:40:12 <ddarius> Similarly for Product.
15:40:12 <benmachine> hmm
15:40:24 <benmachine> what about types with non-strict (+) implementations?
15:40:39 <mreh> i think it's just there for efficient implementation
15:40:47 <ddarius> benmachine: sum is already broken for them, why shouldn't mconcat?
15:40:58 <benmachine> ddarius: sum doesn't promise to be a foldr
15:41:04 <ddarius> sum is defined as a foldl
15:41:08 <benmachine> right
15:41:12 <benmachine> mconcat is defined as a foldr
15:41:18 <mreh> benmachine: Writer's content is a Monoid
15:41:35 <benmachine> mreh: yes I know
15:41:37 <ddarius> No, mconcat is given a default implementation as a foldr.
15:41:56 <benmachine> ddarius: and Monoid is given a law demanding that it should be equivalent to a foldr
15:42:00 <benmachine> http://hackage.haskell.org/packages/archive/base/4.3.0.0/doc/html/Data-Monoid.html
15:42:01 <ddarius> Which is bogus.
15:42:02 <mreh> we can make Writer more generalised with a class such as Monoid
15:42:32 <benmachine> ddarius: what do you think the rule should be?
15:42:52 <benmachine> mreh: I'm not sure what question you're asking, I'm pretty sure it's not mine :P
15:43:04 <benmachine> mreh: *answering
15:43:43 <mreh> yeah, probably not
15:43:45 <mreh> it's late
15:44:42 <ddarius> benmachine: I don't think there should be a strict rule.  I think the foldr default should be viewed as a guide and not a rigid specification.
15:44:49 <mreh> so mconcat == foldr mempty mappend == foldl mempty mappend?
15:44:54 <revenantphx> Hey, just jumping back to ask a quick question.
15:45:13 <mreh> I think I asked that question, I'm talking about equivalence, and not definition
15:45:16 <ddarius> As I mentioned above, on finite, totally defined lists foldl, foldl', and foldr will all give the same answer in the definition of mconcat.
15:45:18 <revenantphx> when it comes to binary protocols (where you cannot know the full length of a packet at any given time) what do you folks suggest for parsing?
15:45:28 <ddarius> Albeit with rather different performance characteristics.
15:45:34 <mreh> ddarius: good, I understood you
15:45:37 <revenantphx> Lazy IO was a pretty easy way to do it, but I'm wondering about what would be better, since people seem very adverse to lazy IO.
15:46:32 <sproingie> most binary protocols i work with have as a basic requirement that you do know the packet length
15:46:38 <mreh> ddarius: that's more of corallary of what you said
15:46:39 <revenantphx> Yeah, well this one is *shit*
15:46:41 <mreh> :D
15:46:51 <revenantphx> :P
15:46:53 <sproingie> at least a max length and the actual one from a header.  crummy protocol there.
15:47:04 <revenantphx> I know, I've bitched about it a lot.
15:48:00 <ddarius> benmachine: Seeing as the Monoid instances defined in that file fail to meet the laws also defined in the file, I'm less than inclined to blindly follow its strictures on mconcat.
15:49:24 <benmachine> ddarius: hmm, but don't you think it would be surprising to mconcat an infinite list of lazy natural numbers and get nontermination?
15:50:24 <ddarius> benmachine: No.  I'm not surprised when sum on an infinite list of lazy naturals gets non-termination, and, if I wasn't already jaded, I would be very surprised if mconcat on a finite list of Ints blew up.
15:50:48 <benmachine> ddarius: any more surprised than you would be to find that foldr blew up?
15:50:59 <hpc> ddarius: blows up as in stack overflow or non-termination?
15:51:50 <ddarius> benmachine: Yes, more surprised.
15:51:55 <benmachine> ddarius: it just seems easier to me to think "mconcat is a foldr" rather than "mconcat is whatever the library author thought was appropriate"
15:52:07 <ddarius> benmachine: Except that the latter is what is true.
15:52:30 <benmachine> ddarius: yes but I'm wondering what *should* be true, not what is :P
15:52:38 <benmachine> @botsnack
15:52:39 <lambdabot> :)
15:52:44 <benmachine> > mconcat undefined
15:52:45 <lambdabot>   ()
15:52:46 <benmachine> yaaaay
15:53:03 <hpc> :t mconcat
15:53:05 <lambdabot> forall a. (Monoid a) => [a] -> a
15:53:05 <benmachine> > foldr mappend mempty undefined
15:53:06 <lambdabot>   *Exception: Prelude.undefined
15:53:07 <ezyang> \ldots 
15:53:08 <benmachine> wups
15:53:22 <hpc> oh right, default instance
15:53:36 <benmachine> lambdabot's super-defaulting
15:53:56 <ddarius> > undefined `mappend` () -- wups
15:53:57 <lambdabot>   ()
15:54:12 <benmachine> ddarius: quite.
15:55:20 <ddarius> Of course, if we defined mempty to be undefined ...
15:56:09 <benmachine> that would be super-useful
15:56:18 <ddarius> It would satisfy the laws.
15:56:29 <unkanon> preflex: seen iamjwc
15:56:30 <preflex>  iamjwc was last seen on #haskell 4 hours, 39 minutes and 32 seconds ago, saying: ok
15:57:03 * ezyang is still uncertain if we should be asking programmers to think about what functions do when 'undefined' is passed to them. 
15:57:22 <ddarius> ezyang: There are -plenty- of strict languages out there for you.
15:57:49 <monochrom> some functions are meant to be strict. it's fine. just document it.
15:58:19 <monochrom> but something generic like mconcat is difficult. different people want it different.
15:58:27 <ddarius> monochrom: Indeed.
16:02:02 <Philippa> ezyang: I think it's fair enough to have some document convention for "I'm playing fast and loose: please stay morally correct"
16:02:33 <monochrom> I would write for such generic functions "this function is provided just to pay lip service to people in IRC who ask 'why not provide it in the stdlib'. it is not meant to be used. it has the most useless strictness property implementable so you have to roll your own - and you should because you need to take strictness back under your control"
16:04:11 <kmc> ezyang, perhaps you shouldn't think about what functions *do* on bottom, but think about what they *mean*
16:05:56 * ezyang likes syntactic manipulation! :o) 
16:10:12 <hpc> i like to think of functions as "how do i get this behavior to look like this main loop?"
16:10:34 <hpc> or similar
16:13:25 <revenantphx> hm, I'm curious about one thing.
16:13:34 <revenantphx> Is it possible to do dynamic loading in haskell?
16:13:40 <revenantphx> It would seem ghci does?...
16:13:41 <blackdog> yes.
16:13:43 <kmc> yes
16:13:48 <blackdog> ghci does it a slightly odd way, though.
16:14:07 <kmc> see packages: plugins hint direct-plugins metaplug
16:14:10 <kmc> and the GHC API itself
16:14:12 <revenantphx> cool.
16:14:19 <blackdog> the last guy to recommend an academic paper got made fun of, but i'll be brave and recommend don's thesis
16:14:35 <blackdog> there's a whole spectrum of different safety tradeoffs to make
16:14:42 <revenantphx> So it's possible to say, have a program load myplugin.hs and compile it at runtime?
16:14:43 <kmc> your egghead academic attitude is /not tolerated/ in the Haskell community
16:14:43 <kmc> ;)
16:14:49 <revenantphx> Or would it have to be precompiled...
16:14:50 <medfly> lol
16:14:52 <kmc> revenantphx, yes.  "hint" is probably the place to start looking
16:15:00 <blackdog> kmc: :) you know what i mean.
16:15:01 <revenantphx> @hackage hint
16:15:01 <lambdabot> http://hackage.haskell.org/package/hint
16:15:06 <blackdog> indeed, hint is lovely
16:15:10 <kmc> btw GHCi does this by including a whole custom ELF and PE dynamic linker
16:15:10 <blackdog> and now works on ghc 7
16:15:11 <adnap_> if you call length on a list, does it force evaluations of the entire list, or could it count up elements without fully evaluating them?
16:15:16 <blackdog> if you don't count a few failing tests :)
16:15:25 <revenantphx> kmc: what.
16:15:27 <revenantphx> 0.o
16:15:28 <blackdog> adnap_: it evaluates the spine, yes.
16:15:30 <magicman> > length [undefined,undefined,undefined]
16:15:31 <lambdabot>   3
16:15:36 <kmc> revenantphx, there are also bindings to dlopen() in the unix package, if you're trying to dynamically link C code
16:15:40 <kmc> or other languages
16:15:48 <revenantphx> Oh, gotcha.
16:15:52 <revenantphx> I'm not really.
16:15:57 <hpc> blackdog: "spine" is an excellent term for it :D
16:15:59 <revenantphx> Just wondering about the feasibility of hot-swapped plugins.
16:16:12 <kmc> revenantphx, also see "dyre" for a kind of "warm swapped" technique
16:16:15 <blackdog> ghci is full of evil :) dynamic linking is only relatively recently in
16:16:15 <kmc> also what's used by xmonad
16:16:19 <revenantphx> warm?....
16:16:24 <kmc> your program's config file is its Main module
16:16:24 <revenantphx> @hackage dyre
16:16:24 <lambdabot> http://hackage.haskell.org/package/dyre
16:16:29 <adnap_> blackdog: What's the spine?
16:16:29 <kmc> and it will recompile itself and restart
16:16:31 <kmc> saving state
16:16:43 <blackdog> revenantphx: i'm using a really low-tech way to do it in Hubris - just build dylibs and link them into ruby at runtime
16:16:50 <blackdog> seems to work fine
16:16:53 <kmc> blackdog, right, i meant the thing older than the .so support in GHC
16:16:58 <kmc> the ability for ghci to load .o files
16:17:17 <revenantphx> I'm not doing any of this now, just curious :).
16:17:45 <blackdog> adnap_: the spine is just an idiomatic term for the structure of lists. i guess there are equivalent concepts for trees
16:17:55 <blackdog> where you don't evaluate the nodes
16:18:06 <kmc> skeleton :)
16:18:16 <blackdog> ah, that'd be it:)
16:18:22 <blackdog> kmc: do you know the history of ghci's odd behaviour with dynamic linking?
16:18:23 <kmc> i made that up just now
16:18:31 <kmc> blackdog, i don't
16:18:47 <revenantphx> quick, I need clever puns/names involving cubes, blocks, and haskell/functional programming!
16:18:55 <revenantphx> (really I need a list of these)
16:19:00 <kmc> HLambdaBlockCube
16:19:04 <revenantphx> :O
16:19:19 <revenantphx> kmc: OMGSUPERKAWAIIDESUDESUDESU<3
16:19:22 <ezyang> lambda cube seems pretty canonical 
16:19:24 <revenantphx> In other words, no.
16:19:52 <blackdog> LegoMyLambda
16:19:52 <ezyang> I could probably make some visual puns 
16:19:58 <revenantphx> Preferably involving the word "craft" somewhere :3
16:20:05 <medfly> lube. it's lambda and cube.
16:20:10 <revenantphx> ....medfly 
16:20:12 <revenantphx> hahaha
16:20:14 <blackdog> medfly: and it goes down easy.
16:20:21 <revenantphx> XD
16:21:25 <revenantphx> no but really...
16:22:52 <dolio> I think we should all start saying, "free monoid," instead of, "list."
16:23:32 <Axman6> map applies an arrow to the free monoid
16:23:41 <medfly> free monoid comprehension.
16:24:09 <Axman6> do you has it?!?!?!
16:24:40 <aavogt> deforestation threatens the free monoid
16:25:24 <blackdog> it does sound grander
16:25:28 <revenantphx> Free Monoid 3: The Story of a Young Boy who ventures to a ghci sandbox where a free monoid came from the wild after he released it there after it was imprisoned in a hugs instance, all for it's wellbeing.
16:25:47 <blackdog> although "free monoid comprehension" sounds more like a political slogan
16:26:06 <dolio> We won't have to worry once they become monad comprehensions again.
16:26:11 <Axman6> bill posters is innocent!
16:27:31 <kmc> haha
16:27:58 <kmc> dolio, i second
16:28:07 <dolio> Awesome.
16:28:23 <dolio> My nefarious plot is going swimmingly.
16:28:31 <kmc> your support has increased 100% in the past minute
16:28:43 <aavogt> blackdog: as is the haskell school of expression
16:30:59 <revenantphx> So uh, name ideas :P?
16:31:15 <blackdog> i still like the lego theme
16:31:22 <blackdog> you'd probably get sued into a smoking hole in the ground though.
16:31:32 <adnap_> Is there an easy way to check when and why evaluation is forced during the execution of a program?  Is using some sort of debugger the best way?
16:31:49 <blackdog> there's vacuum, for small graphs
16:31:50 <revenantphx> blackdog: no...
16:31:54 <aavogt> Debug.Trace too
16:32:12 <blackdog> if it's about debugging space leaks, you probably want to look at the profiling tools
16:32:16 <kmc> yeah you might could use ghci debugger too
16:32:45 <revenantphx> I might call it MonadCraft... so that anyone using it is liek "hm, what's a monad"
16:32:54 <revenantphx> Bam. Potential Haskell converts.
16:33:01 <blackdog> oh god
16:33:07 <blackdog> could we talk less about monads please?
16:33:07 <adnap_> I have this graphics program that draws a frame using info from the head of an infinite list.  Every time the program is idle, I drop the head of the list.  When I make a simple program like this, it seems to work: http://hpaste.org/42136/update  (If it didn't, I wouldn't even get the first frame, 'cause it's an infinite list, right?)
16:33:10 <kmc> Haskell Is Not About Monads [tm]
16:33:11 <aavogt> with the ghci debugger you really need to name intermediate values more often
16:33:18 <blackdog> it's just an excuse for people to say "Haskell is hard, let's go hacking"
16:33:23 <revenantphx> My monads are itchy.
16:33:44 <bremner> what happened to the other one?
16:34:04 <adnap_> However, I have a program that has more complicated data in the infinite list, and for some reason it seems like the entire list is being forced to be evaluated.
16:34:11 <Saizan> blackdog: sure, let's talk more about free monoids!
16:34:32 <revenantphx> CurryCraft :D
16:34:37 <revenantphx> SPICY EXOTIC FUNCTIONAL FLAVOUR.
16:34:38 <kmc> om nom
16:34:51 <c_wraith> > (=<<) `asTypeOf` maybe Nothing
16:34:52 <lambdabot>   Overlapping instances for GHC.Show.Show
16:34:52 <lambdabot>                              ((a ->...
16:34:54 * revenantphx is not implying curry must be spicy.
16:34:56 <adnap_> Can someone take a look at the simple program (http://hpaste.org/42136/update) and see if it looks "sane"?
16:34:57 <c_wraith> err
16:35:01 <c_wraith> :t (=<<) `asTypeOf` maybe Nothing
16:35:02 <lambdabot> forall a a1. (a -> Maybe a1) -> Maybe a -> Maybe a1
16:35:26 <revenantphx> I have to say... $= still scares me.
16:35:38 <revenantphx> What horrible things is it doing behind the scenes D:
16:35:52 <ddarius> revenantphx: Won't they instead be like, "Ah, a game about the Leibnizian notion of reality."
16:36:02 <revenantphx> > let )( a b = a + b in )( 10 12
16:36:03 <lambdabot>   <no location info>: parse error on input `)'
16:36:12 <ddarius> MonadCraft even makes sense.
16:36:19 <revenantphx> ddarius: CandideCraft!
16:36:30 <ddarius> Although the first thing users will want is to sully the monadic nature.
16:37:58 <revenantphx> ddarius: How does the name "CurryCraft" at all relate to Leibnizian optimism tho.
16:38:00 <revenantphx> Seriously.
16:38:15 <jmcarthur> adnap_: just to be clear, the problem isn't that it's not doing anything after the first frame, but that you're not getting the first frame in the first place?
16:38:24 <revenantphx> Or is there something he did about monads I totally don't know about.
16:38:31 <dolio> Leibniz wrote about things called monads.
16:38:40 <jmcarthur> adnap_: because at first glance i don't think there will be any animation anyway since you aren't actually dropping the head of the list on each frame
16:38:42 <revenantphx> Oh I see.
16:39:10 <adnap_> jmcarthur: Yes I am
16:39:12 <jmcarthur> adnap_: but if you're not even getting the first frame then that's another thing
16:39:21 <adnap_> jmcarthur: look at idleCallback'
16:39:32 <adnap_> jmcarthur: modifyIORef state tail
16:39:35 <adnap_> jmcarthur: drops the head
16:39:47 <jmcarthur> adnap_: are you sure that it ever gets a chance to run?
16:39:56 <adnap_> jmcarthur: This simple program animates perfectly for me.  It fades a triangle from black to white.
16:40:07 <jmcarthur> i don't know if GPipe's main loop gives you time
16:40:08 <jmcarthur> oh okayu
16:40:09 <kmc> adnap_, it doesn't actually force "tail" until later though
16:40:09 <augur> can i just interrupt the haskelling for a moment and say
16:40:11 <jmcarthur> *okay
16:40:13 <augur> new planet! :OOOOO
16:40:18 <kmc> it just stores a thunk saying "tail foo" inside the ioref
16:40:19 <adnap_> huh?
16:40:27 <adnap_> kmc: Right, that's the good thing.
16:40:28 <kmc> where augur?
16:40:31 <augur> kmc: http://www.wired.com/wiredscience/2010/11/oort-cloud-companion/
16:40:40 <jmcarthur> adnap_: oh, so the program you pasted is the working version then?
16:40:44 <jmcarthur> i was confused about that
16:40:50 <adnap_> kmc: 'Cause it's an infinite list!  It's a damn good thing it doesn't evaluate tail.
16:40:54 <jmcarthur> no
16:41:17 <jmcarthur> adnap_: it doesn't actually drop the head until the renderFrame callback is called though
16:41:20 <adnap_> jmcarthur: This is the basic idea of my program.  The real program has different data in the inifinite list, and in that program, I'm not even getting the first frame for a long time.
16:41:23 <monochrom> forcing "tail infinite_list" takes O(1) time
16:41:36 <jmcarthur> adnap_: well i see nothing insane about the working version
16:41:37 <monochrom> well, for this particular infinite list anyway
16:41:43 <jmcarthur> adnap_: maybe you should paste the non-working version?
16:41:44 <monochrom> otoh it doesn't matter
16:41:51 <adnap_> jmcarthur: I can, but it's kinda huge.
16:42:02 <kmc> adnap_, no, forcing "tail xs" would still work on an infinite list.  forcing a list only forces the first (:)
16:42:13 <kmc> my "forcing" i mean "forcing to weak head-normal form"
16:42:13 <jmcarthur> adnap_: either way, kmc's point is just that you probably want to force the head of the list as you write it into the IORef
16:42:18 <adnap_> kmc: What I mean is, it doesn't evaluate the things in the tail.
16:42:22 <kmc> actually i don't claim that you should
16:42:27 <kmc> just pointing out this behavior if you weren't aware
16:42:32 <kmc> sometimes an ioref with a thunk inside is what you want
16:42:40 <adnap_> I'm kind of confused.  Let me explain a little more.
16:42:44 <jmcarthur> honestly it's not a huge deal though as long as the idle callback doesn't run way more often than the render callback
16:42:46 <adnap_> renderFrame forces evaluation of the head.
16:43:04 <adnap_> That's because renderFrame pulls the head out and the info is used to render the frame.
16:43:05 <jmcarthur> adnap_: just consider the case that the idle callback is called a million times between renders
16:43:22 <jmcarthur> adnap_: it would build up a huge chain of tail (tail (tail (tail (tail ...
16:43:26 <monochrom> head (tail (tail (tail (tail (tail ha)))))
16:44:00 <adnap_> So, you're saying that while it's trying to render the first thing, idleCallback' is forcing the evaluation of all the other data?
16:44:03 * monochrom should start a "boot camp for ghc evaluation order"
16:44:34 <kmc> it's great how laziness lets you ignore the order of evaluation except all the times when it doesn't
16:44:41 <monochrom> hahaha
16:44:48 <jmcarthur> adnap_: well, it can certainly take up lots of memory and make the actual render take a little longer. either way, i still don't think it's a huge deal here
16:45:05 <adnap_> jmcarthur: But it is a huge deal in my real program.
16:45:10 <jmcarthur> adnap_: you should paste your non-working code (or maybe try to simply it first)
16:45:12 <jmcarthur> adnap_: why?
16:45:18 <adnap_> jmcarthur: Okay, I'll post it.
16:45:36 <unkanon> @remember kmc it's great how laziness lets you ignore the order of evaluation except all the times when it doesn't
16:45:37 <lambdabot> Good to know.
16:45:39 <adnap_> jmcarthur: But before I do that, maybe I can explain my goal.
16:45:39 <monochrom> evaluation order is always a huge deal.
16:45:45 <jmcarthur> adnap_: in your simple version at least, the worst that happens is you have a little thunk chain building up between frames
16:45:56 <adnap_> jmcarthur: My goal is to have that not happen.
16:46:10 <jmcarthur> adnap_: then i would force the list as i write it to the IORef
16:46:12 <adnap_> jmcarthur: I don't want the rest of the list to be processed at all until the first frame is rendered.
16:46:16 <jmcarthur> adnap_: i still doubt that's your problem though
16:46:21 <jmcarthur> no
16:46:23 <adnap_> jmcarthur: Okay, let me post the code.
16:46:26 <jmcarthur> that's not what this is causing
16:46:40 <ddarius> kmc: Laziness is a different evaluation order not the absence of evaluation order.
16:47:06 <jmcarthur> non-strictness is the absense of a certain evaluation order though :)
16:47:16 <etpace> Is there a way to print out the dependencies of a package in cabal?
16:47:23 <dolio> So is strictness, then.
16:47:24 <revenantphx> cabal deps 
16:47:26 <revenantphx> I believe.
16:47:44 <revenantphx> uh waitn o, thats not it.
16:47:44 <monochrom> peace is not the absence of war
16:48:23 <adnap_> jmcarthur: Where should I upload it?
16:48:29 <kmc> ddarius, i know.  my point is it's a nice default semantically: going strict -> lazy will only make additional working programs
16:48:32 <adnap_> jmcarthur: It's about 4 files of around 100 lines each.
16:48:32 <monochrom> hpaste again
16:48:38 <monochrom> oh, oops.
16:48:40 <kmc> and it's more composeable etc
16:48:44 <kmc> so we champion laziness
16:48:44 <ddarius> kmc: Only in a pure language is that true.
16:48:57 <kmc> but then we spend half the time in this channel explaining subtle rules of graph reduction :D
16:49:01 <jmcarthur> adnap_: are you using version control? maybe you could github or patch-tag it or something
16:49:18 <ddarius> kmc: I never explain graph reduction.
16:49:31 <adnap_> jmcarthur: I'm not using version control yet.
16:49:56 <adnap_> jmcarthur: I'll just upload it to my server.
16:50:08 <monochrom> could you modify your program to produce just one frame and do nothing?
16:50:24 <adnap_> monochrom: One frame is easily produced.
16:50:34 <monochrom> Two frames?
16:50:56 <monochrom> "updates x = [x, update x]" something like that
16:51:00 <adnap_> monochrom: The behavior of the "real" program is like this:  nothing... frame frame frame
16:51:43 <jmcarthur> i never understood this whole "not using version control *yet*" thing. the first thing i do when i start a project is mkdir foo; cd foo; darcs init
16:51:59 <monochrom> naw, I cabal init first
16:52:15 <jmcarthur> monochrom: well, that too, but i'm talking about the general case, which might be non-haskell stuff
16:52:33 <monochrom> it depends on how professional the person is.
16:52:35 <ddarius> kmc: On the other hand, people fail to realize how much eager evaluation needed to be taught to them and often fail to recognize eager evaluation as the cause of similar problems that lazy evaluation is held accountable for.
16:52:58 <kmc> yep
16:53:00 <monochrom> A very professional programmer never starts a toy project. Whatever he/she starts needs version control since day 0.
16:53:02 <jmcarthur> lazy evaluation and strict evaluation are harmonious
16:53:03 <kmc> same for side effects
16:53:05 <kmc> same for OOP
16:53:11 <monochrom> I start toy projects all the time.
16:53:32 <jmcarthur> i use version control for all my toy projects...
16:53:36 <ddarius> jmcarthur: They are rather practical together, but really its the mixture that kills you in any language.
16:53:39 <adnap_> Okay, wait.  It is able to display a frame for the "real" program with an infinite list is the complexity of the problem is small.
16:53:53 <kadoban> ya...i use git for everything, even my crap projects.  1/2 the time they balloon into interesting projects eventually anyway
16:53:58 <adnap_> However, if I make the problem harder, it has trouble displaying the first frame for a long time.
16:54:06 <adnap_> But!
16:54:23 <jmcarthur> ddarius: it sounds like you are trying to say that haskell would be better off without ways to introduce strictness
16:54:28 <adnap_> It has no trouble displaying the first frame for a complex problem if I don't ask it to continue on with more solutions.
16:54:47 <medfly> monochrom, my professor is writing a book during his course, and he's using svn for it
16:54:53 <ddarius> jmcarthur: No, I'm not.  I'm saying it would be much simpler but much less practical.
16:55:00 <jmcarthur> okay
16:55:33 <jmcarthur> adnap_: do you have any idea how many times your idle callback is getting run between renders? i have a suspicion about this
16:56:29 <adnap_> jmcarthur: Well, if I put a print statement in the idle callback, I get no prints for a long time until it starts spitting out frames.
16:56:39 <adnap_> jmcarthur: Then I get many prints
16:56:56 <jmcarthur> many prints per frame?
16:57:34 <jmcarthur> brb
16:57:35 <sm> why does ghc not print some of the usual "compiling module" messages when I add -O2 ? it is compiling them
16:57:59 <parcs> does anyone recommend a specific xml-parsing library?
16:58:51 <blackh> parcs: hexpat, but I'm extremely biased
16:59:08 <ddarius> sm: If you are using ghc --make it doesn't recompile already compiled files unless there are changes in dependencies.
16:59:14 <adnap_> You know, it could just that the delay is a result of the "set up" time for the problem, which increases with complexity.
16:59:38 <sm> ddarius: I've made sure to clean out all .o  and .hi files.. they are being regenerated but not all of them are announced
16:59:41 <adnap_> No, that's not right, 'cause I remember getting the first frame right away for a complex problem.
16:59:50 <parcs> blackh: heh, i'll check it out regardless :)
16:59:53 <adnap_> (If I limit to 1 frame)
17:00:08 <kmc> sm, ghc -fforce-recomp
17:00:10 <kmc> to be sure
17:00:40 <kmc> using version control is liberating even on a tiny project
17:00:48 <kmc> you can delete stuff rather than uncommenting it
17:01:00 <kmc> the amount of code you can fit on your screen at once is a crucial parameter
17:01:07 <kmc> rather than commenting*
17:01:22 <kadoban> hmm, good point
17:01:48 * ddarius always codes in 2 point font.
17:01:52 <monochrom> version control should be built into the file system
17:01:58 <ddarius> monochrom: It is.
17:02:04 <adnap_> Okay: http://omanyte.ath.cx/radiosity
17:02:21 <monochrom> I used VMS and it was enjoyable.
17:02:27 <blackh> parcs: If you have any thoughts about how it could be improved, I'd appreciate them.
17:02:38 * ddarius was hoping for pictures.
17:04:57 <adnap_> I normally use version control, but I didn't see the point before I had pictures on the screen, 'cause I rarely had any clue whether I was right about something.
17:05:00 <sm> ha! I had an auto-builder running in another window
17:05:19 <monochrom> talk about side effects
17:05:24 <adnap_> I figured I would do the first commit as soon as I got a picture that looked right.
17:05:56 <ddarius> "I figured I'd do the first commit when I was done."
17:06:04 <adnap_> ddarius: lol
17:07:19 <adnap_> Also, functional programming is so modular.  Once I have a working function, I don't normally need to change it.
17:07:43 <adnap_> At least, for a tiny project
17:07:45 <parcs> blackh: no problem
17:07:59 <monochrom> I am not a bazaar kind of person. I am a cathedral kind of person, or more accurately a chapel kind of person because I build small things. I really do the first and last commit when I'm done.
17:08:07 <adnap_> I use version control right away for C or C++ though.
17:08:38 <kmc> adnap_, one thing i like about git is that you can use it willy-nilly, and then clean up history post-hoc if you want something nice for other contributors etc
17:09:06 <kmc> you can make a branch with 100 commits and then merge them as 4 logical units each constructed from bits of those 100
17:09:09 <adnap_> kmc: Yeah, I just haven't had the chance yet.  I started this like 3 days ago, and I have a deadline.
17:09:17 <kmc> but in the meantime you get the benefits of a vcs
17:09:40 <adnap_> Aw sheet
17:09:50 <adnap_> stack space overflow
17:10:04 <monochrom> The real reason I used version control was to have a kind of rsync between two computers before rsync existed.
17:10:08 <adnap_> wtf is going on with that infinite list?
17:10:53 <monochrom> but kmc is convincing me to use version control again
17:11:24 <monochrom> does svn enjoy the same property you mentioned of git?
17:11:26 <adnap_> I wish I could reason better about this.  I cannot "see" what is going on with the evaluation.  Are the debuggers that exist for this nice and easy to use?
17:11:29 <copumpkin> monochrom: nope
17:11:43 <monochrom> ah, maybe I should go git altogether
17:11:49 <copumpkin> only git really supports that kind of use pattern
17:12:20 <monochrom> willy-nilly then cleanup is nice
17:12:53 <aavogt> kmc: what if you've already shared it?
17:12:59 <sm> you cam do that with darcs surely
17:13:12 <monochrom> how does git represent file renames?
17:13:27 <lispy1> monochrom: it doesn't
17:13:42 <lispy1> monochrom: it notices when files share content but it doesn't track the renames themselves
17:14:02 <lispy1> monochrom: as a result, git will sometimes mistakenly tell you a file was renamed
17:14:06 <monochrom> that is inferior to svn, isn't it?
17:14:25 <lispy1> monochrom: that's a bit subjective IMO
17:14:49 <lispy1> Git perfectly represents the state of the world at each point and then later you can use it to infer what changed
17:15:03 <lispy1> (and by perfectly, I mean, no empty directories are allowed :)
17:15:05 <monochrom> ah, that's sufficient, I agree.
17:15:15 <mee> it's not fair to compare it to a VCS where you have to explitely tell it you renamed a file ;)
17:15:31 <stephenjudkins> monochrom: read http://www.wincent.com/a/about/wincent/weblog/archives/2007/07/a_look_back_bra.php 
17:15:56 <monochrom> I am a control freak in this regard, I want to explicitly say "this is a rename" and implicitly "nothing else are renames".
17:16:07 <stephenjudkins> in which linus torvalds explains his preference towards a "metadata-light" SCM
17:16:22 <adnap_> jmcarthur: Are you back yet?
17:16:45 <lispy1> monochrom: and correctly guessing what the difference implies is completely intractable
17:17:13 <lispy1> monochrom: I think in practice, you want what git does but you also want to be able to specify high level semantic information too
17:19:04 <revenantphx> hey, once again, do you guys have any programming book recommendations?
17:19:16 <revenantphx> well, not restricted to programming
17:19:24 <revenantphx> actually, a good book on category theory or something would be excellent.
17:19:26 <sm> revenantphx: coders at work
17:19:45 <lispy1> revenantphx: It would be nice if someone would write a book about advanced haskell that codifies a lot of the folklore
17:20:03 <revenantphx> mm, there aren't a lot of haskell books...
17:20:04 <revenantphx> at all.
17:20:14 <lispy1> revenantphx: wait, are you looking for reading or writing recommendations?
17:20:15 <jmcarthur> adnap_: what happens if instead of doing any rendering you just do "print solns"? do you get output quickly?
17:20:20 <revenantphx> reading.
17:20:21 <aavogt> papers, lispy1?
17:20:24 <sm> programming in haskell, haskell school of expression, real world haskell are all nice
17:20:49 <lispy1> There are few enough haskell books that they are all nice really.  Some are more dated than others though.
17:20:57 <jmcarthur> adnap_: like without even setting up callbacks or starting the mainLoop
17:21:03 <adnap_> jmcarthur: let me see
17:21:08 <aavogt> once you done one of those intro courses, there doesn't seem to be any order in which to study other topics
17:21:12 <dolio> There are few OCaml books, but they're not all nice.
17:21:39 <monochrom> revenantphx: these are some books I have. I don't recommend all of them, but perhaps they inspire you or search engines collaterally lead you: http://www.vex.net/~trebla/weblog/fpbooks.xhtml
17:21:41 <Raynes> The best OCaml books are probably F# books.
17:21:55 <lispy1> aavogt: papers are good, I want something to bridge the gap between "I can read and understand papers" and "I just learned Haskell last week".  And to also write down the boring stuff that papers don't document :)
17:22:07 <revenantphx> Which ones do you recommend most? I jhave Okasaki and Bird and de Moor on the list already.
17:22:35 <adnap_> jmcarthur: No, it looks like it chokes on the first solution
17:22:58 <mee> sm, revenantphx: I second /Coders at Work/; very fun read
17:23:11 <revenantphx> Seriously, do you guys have any recommendations for basic category theory books?
17:23:39 <adnap_> jmcarthur: It chokes at first, and then, if the solution is not too complex, after a while it starts spitting out infinite solutions.
17:24:32 <jmcarthur> adnap_: okay, i'll take a look at the rest of this code, but no promises that i'll run across the problem
17:24:34 <monochrom> free category books are better. awodey or fokkinga. ask Cale for awodey. fokkinga is http://wwwhome.cs.utwente.nl/~fokkinga/mmf92b.html
17:24:53 <monochrom> All paid category books are not worth their price.
17:25:40 <Cale> Awodey isn't actually meant to be free ;)
17:25:47 <jmcarthur> doh!
17:25:49 * jao likes Lawvere and Schanuel's "Conceptual Mathematics"
17:25:53 <Cale> (though I will happily give you a copy :)
17:26:01 <sm> I am *plagued* with these ExitFailure 11's from cabal configure. What could they be ??
17:26:04 <monochrom> oh, then it's an exception among paid category books :)
17:27:59 <jmcarthur> adnap_: yeah, sorry, i don't think have the time to go through all this :\. i suspect you just have a spot somewhere that's overly lazy, so it's building up a chain of thunks. see what your memory usage is like, do some profiling (both time and heap profiling), and i think you will be able to track it down
17:29:04 <adnap_> jmcarthur: Okay.  I have one other question.  Do you see any reason why, even with the simple program, the stack would continue to grow if I'm dropping elements off of the infinite list?
17:29:15 <revenantphx> anything else then?
17:29:26 <revenantphx> Anything good on compiler/language design?
17:29:33 <revenantphx> Since I might be doing stuff with that next year.
17:29:37 <jmcarthur> adnap_: are you getting stack overflows?
17:29:40 <lispy1> revenantphx: Do you use the haskell subreddit?  I'm pretty sure the question of what books to read about math/programming comes up their fairly often
17:29:58 * revenantphx doesn't use reddit.
17:30:36 <lispy1> revenantphx: A link to this is on the front page of the haskell subreddit: http://dekudekuplex.wordpress.com/2010/12/05/category-theory-for-the-mathematically-impaired-an-outline-of-a-short-reading-list-for-mathematically-impaired-computer-scientists-trying-to-learn-category-theory/
17:30:58 <lispy1> revenantphx: I think it's pretty much exactly what you're looking for
17:31:00 <adnap_> jmcarthur: yes
17:31:20 <jmcarthur> adnap_: okay, then that tells me it's definitely a laziness/strictness isue
17:31:22 <jmcarthur> *issue
17:31:25 <adnap_> jmcarthur: i suspect that even the simple program will overflow the stack after a long time based on what i've seen from my real program
17:31:55 <adnap_> jmcarthur: shouldn't it be much easier to debug the simple program to find out what's overflowing the stack?
17:32:08 <jmcarthur> adnap_: well, that issue kmc brought up earlier could cause it under certain circumstances (tons of calls to idle between renders)
17:32:30 <perimosocordiae> Is there a place to report bugs for specific Hackage packages?
17:32:42 <sm> all I can say is: maintaining a non-trivial cross-platform haskell app is seriously hard work. 
17:32:45 <jmcarthur> adnap_: stack overflows mean something will go slower than it should, so is likely to show up in a profile
17:32:56 <jmcarthur> adnap_: or it could appear in a heap profile
17:33:39 <copumpkin> perimosocordiae: the maintainer email address or some packages have links to bugtrackers on their page
17:34:17 <sm> six hours to build shippable binaries for one and a half platforms 
17:34:37 <jmcarthur> adnap_: really the only issue i can find in the simple version is that one thing. i can't think of anything else right now
17:34:38 <perimosocordiae> copumpkin: Ok cool, just wanted to check before emailing the maintainer.
17:35:21 <revenantphx> listhanks
17:35:24 <revenantphx> lispy1: thanks
17:35:46 <jmcarthur> adnap_: and i'm assuming that there is some bound on the number of times the idle callback is called, so i don't think it would cause a stack overflow in the simple version
17:36:02 <jmcarthur> adnap_: the problem could possibly be a bit magnified in the complex version of course
17:36:48 <adnap_> jmcarthur: argh
17:36:50 <jmcarthur> adnap_: but we've already verified that the problem in your complex version is *not* due to the idle callback anyway, since you can't even get output reliably without rendering
17:37:08 <jmcarthur> adnap_: so your main problem is unrelated to the problem in the simple version
17:38:25 <monochrom> revenantphx: Oh actually, here is a long list of compsci books: http://www.vex.net/~trebla/compsci/
17:39:02 <adnap_> jmcarthur: Are you sure?  YOu don't think the simple program has a stack overflow problem?
17:39:25 <xplat> is there a fast way to break a bytestring into a bunch of fixed-sized chunks?
17:39:54 <revenantphx> monochrom: any favorites on there?
17:40:28 <xplat> i can think of a lot of ways to do it, but none stand out as obviously fast
17:40:28 <unkanon> xplat: you want a splitAtEvery sort of function
17:40:29 <monochrom> all are favourites. you just have to narrow down which topic you want.
17:40:39 <unkanon> xplat: you can do that by using splitAt recursively
17:41:07 <xplat> splitAt on bytestrings won't copy the tail?
17:41:40 <revenantphx> monochrom: mmk.
17:41:44 <unkanon> xplat: I have never used bytestrings so I'm assuming it works as String does
17:41:57 <adnap_> jmcarthur: I ran profiling on the simple program.  %alloc gives the amount of heap allocation?
17:42:03 <monochrom> Doh! There is an online book I was trying to find, and it is listed on my own list!
17:42:06 <xplat> String is a linked list, bytestring is internally an array
17:42:38 <jmcarthur> adnap_: did something end up huge?
17:43:20 <xplat> it doesn't seem like it would work the same at all
17:43:24 <adnap_> jmcarthur: http://hpaste.org/42137/profile
17:43:30 <unkanon> xplat: I understand how they're different in their implementation, but I thought on the surface they were the same?
17:43:54 <adnap_> jmcarthur: Yes, the frameBuffer is berzerk.
17:43:58 <jmcarthur> adnap_: is this the simple one?
17:44:09 <adnap_> jmcarthur: yes
17:44:49 <unkanon> > splitAtEvery 2 "abcdefghijkl"
17:44:50 <lambdabot>   ["ab","cd","ef","gh","ij","kl"]
17:44:50 <unkanon> xplat: ^ 
17:46:20 <xplat> there's no Data.ByteString.splitAtEvery
17:47:09 <jmcarthur> adnap_: i think what might be happening is frameBuffer function is doing all the real work of the idleCallback function
17:47:42 <unkanon> xplat: I know, I just wrote that :)
17:48:29 <aWagner> Hello, can someone tell me what "\g" is?
17:48:32 <unkanon> @undefine splitAtEvery
17:48:35 <unkanon> @let splitAtEvery _ [] = []; splitAtEvery n xs = let (a,b) = splitAt n xs in a : splitAtEvery n b
17:48:36 <lambdabot>  Defined.
17:48:38 <unkanon> xplat: ^
17:48:42 <xplat> i know how to do this efficiently for a linked list, but as bytestrings are not linked lists ...
17:48:48 <jmcarthur> adnap_: i think i would try something like  do { x <- readIORef state; let x' = tail x in x' `seq` writeIORef state x'; postRedisplay $ Just win }
17:48:55 <jmcarthur> actually that's still not enough
17:49:10 <jmcarthur> adnap_: i think i would try something like  do { x <- readIORef state; let x' = tail x in head x' `seq` writeIORef state x'; postRedisplay $ Just win }
17:49:23 <unkanon> xplat: sorry then, I understand how they differ but I really thought they could be used the same way by the programmer
17:49:36 <jmcarthur> adnap_: that way it forces the head of the list as it writes the list into the IORef, so the work will actually be incremental instead of saved up
17:49:42 <adnap_> jmcarthur: do you think there is necessarily a problem?  %alloc just describes the amount allocated throughout the course of the program, but that doesn't mean that there is that much being allocated at any given time, right?
17:50:04 <jmcarthur> adnap_: it's taking 64.7% of your time as well
17:50:19 <adnap_> jmcarthur: Yeah, but it kicks off every other function.
17:50:21 <jmcarthur> adnap_: it may be due to rendering somehow though
17:50:38 <jmcarthur> adnap_: well, but those other functions don't seem to be contributing so much of that time
17:50:49 <adnap_> jmcarthur: frameBuffer returns the "picture"
17:50:52 <jmcarthur> adnap_: just try what i recommended and see what happens to your profile
17:50:56 <adnap_> okay
17:51:14 <Saizan> xplat: splitAt for a strict bytestring doesn't copy anything, it just changes the offset/length metadata
17:52:04 <fryguybob> aWagner: The beginning of a lambda expression? http://learnyouahaskell.com/higher-order-functions#lambdas
17:52:08 <jmcarthur> adnap_: i really think you should be focusing more on the complex one though unless you have actually observed a space leak (through either heap profiling or by seeing a stack overflow)
17:53:46 <adnap_> jmcarthur: profiling looks the same with your change.
17:54:01 <jmcarthur> okay, then i guess we can just attribute that time to GPipe
17:54:20 <pozic> Haskell: secure, reliable software (but it might give a stack overflow). 
17:54:34 <adnap_> jmcarthur: I'm scared to debug the complex one.  I haven't had to seriously debug anything before, so I don't even have a clue where to start.
17:54:58 <pozic> adnap_: like all problems by binary search.
17:55:02 <jmcarthur> adnap_: start by profiling :)
17:55:08 <adnap_> jmcarthur: alright
17:55:25 <__yhvh__> projecteuler Q: I am trying to generate the list of digits that sum to n, to feed another function. So when n is 12 the list is [[3,9],[4,8],[5,7],[6,6]], any pointers?
17:55:38 <jmcarthur> adnap_: make sure to rebuild the entire thing with -auto-all -caf-all
17:55:48 <jmcarthur> and -fforce-recomp
17:55:52 <unkanon> __yhvh__: list comprehensions
17:56:00 <pozic> __yhvh__: where is [0,12]?
17:56:17 <kadoban> pozic: i think he means single digits
17:56:21 <__yhvh__> yup
17:56:39 <aWagner> Thanks fryguybob
17:56:51 <__yhvh__> also, goes further than that, ie, [1,2,9]
17:56:54 <pozic> kadoban: brute-force would be all ways and then filtering on number of chars. 
17:57:12 <pozic> kadoban: that was meant for __yhvh__ 
17:57:26 <pozic> And I see the problem has already changed again.
17:57:46 <unkanon> > [ (x,y)  | x <- [0..9], y <- [0..9], x + y == 12]
17:57:47 <lambdabot>   [(3,9),(4,8),(5,7),(6,6),(7,5),(8,4),(9,3)]
17:57:52 <unkanon> __yhvh__: ^
17:58:46 <unkanon> > [ (x,y)  | x <- [0..9], y <- [0..9], x + y == 12, x <= y]
17:58:47 <lambdabot>   [(3,9),(4,8),(5,7),(6,6)]
17:58:50 <unkanon> :)
17:58:55 <kadoban> __yhvh__: so you want all possible ways to add single digits to get 12? that's gonna get big...
17:59:11 <pozic> 1+1+1 ...
17:59:13 <__yhvh__> are list comprehensions fast enough to deal with n = 150?
17:59:34 <__yhvh__> well the largest is replicate 1 12
17:59:44 <c_wraith> list comprehensions are neither fast nor slow.  They simply do what you say.  The question is, are you asking it to do tons of wasted work?
17:59:50 <__yhvh__> yes
17:59:57 <pozic> __yhvh__: URL to original problem?
17:59:59 <unkanon> __yhvh__: you want to also get (1,1,1,1,1,1,1,1,1,1,1,1) as a result?
18:00:07 <__yhvh__> as a last result
18:00:16 <__yhvh__> http://projecteuler.net/index.php?section=problems&id=254
18:00:16 <unkanon> hmm...
18:00:23 <adnap_> jmcarthur: Should I wait until the stack overflow to stop profiling?
18:00:25 <copumpkin> omg Henning's dream has come true
18:00:33 <jmcarthur> adnap_: how long does it normally take?
18:00:35 <copumpkin> Haddock 2.9.0:  * New flag --qual for qualification of names
18:00:52 <__yhvh__> I thought branching probably?
18:00:54 <adnap_> jmcarthur: A couple minutes with the complex solution to overflow the stack.  It doesn't overflow the stack for simpler problems.
18:01:26 <jmcarthur> adnap_: you can just let it go for a minute or so most likely
18:01:33 <jmcarthur> it would probably still show up
18:02:01 <jmcarthur> adnap_: i'm trying to install some profiling versions of dependencies so i can follow along
18:02:03 <adnap_> jmcarthur: Hm... the program is not responding to keyboard input, which would let me terminate early.
18:02:29 <adnap_> jmcarthur: In the past, I've noticed that if the program doesn't terminate in a nice way, I don't get the profiling info.
18:02:34 <pozic> __yhvh__: I don't see any reason for why you would need that.
18:02:41 <jmcarthur> adnap_: yeah i've seen that before too...
18:02:53 <jmcarthur> just let it overflow and see i guess
18:02:57 <adnap_> jmcarthur: guess so
18:03:04 <jmcarthur> or maybe C^c?
18:03:05 <pozic> __yhvh__: I also don't really see the reason to ask anything about it, really.
18:03:16 <pozic> __yhvh__: mathematically this is trivial.
18:03:23 <adnap_> jmcarthur: That's not "terminating nicely".  I could try it though.
18:03:25 <pozic> __yhvh__: programming wise it is trivial too.
18:03:33 <__yhvh__> pozic gimme a hint
18:03:36 <jmcarthur> the RTS might be able to handle that though
18:03:40 <pozic> __yhvh__: is there anything about Haskell that you don't understand?
18:03:54 <jmcarthur> beats kill -9
18:03:56 <__yhvh__> pozic: many things
18:04:01 <sm> nice: cabal: dependencies conflict: ghc-6.12.3 requires process ==1.0.1.3 however
18:04:01 <sm> process-1.0.1.3 was excluded because ghc-6.12.3 requires process ==1.0.1.4
18:04:09 <sm> take that, user!
18:04:16 <pozic> __yhvh__: projecteuler is about mathematical tricks. 
18:04:22 <adnap_> jmcarthur: Whoa, okay...
18:04:37 <jmcarthur> i guess you got something then
18:04:40 <xplat> Saizan: ah, thanks, then it'll work
18:04:51 <pozic> __yhvh__: mathematical tricks and no data structures (which most real world applications care about).
18:04:51 <__yhvh__> pozic : I know but I thought this would be solved with a branching search
18:05:05 <jmcarthur> adnap_: i'm still building dependencies. hpaste this sucker :)
18:05:09 <adnap_> jmcarthur: http://hpaste.org/42138/profile
18:05:37 <adnap_> jmcarthur: It looks like it's spending a bunch of time trying to set up the problem.  All of the functions that are at the top are things that only get called when I first set up.
18:06:01 <jmcarthur> projectionMatrix'              Polygon               72.8   71.9   7571 8363250562
18:06:12 <adnap_> jmcarthur: Yeah...
18:06:26 <adnap_> jmcarthur: I think I see the problem.
18:06:39 <adnap_> jmcarthur: Too many thunks before I'm able to build the initial matrix.
18:06:40 <__yhvh__> pozic: you saying this is trivial is painful to me, I'm not a retard
18:07:32 <kadoban> __yhvh__: it's not trivial, but it's...not a programming question really.  it's a, find a cool math trick to solve it question.  all of the project euler stuff that high is
18:08:13 <jmcarthur> adnap_: so you know what to do?
18:08:31 <jmcarthur> because i don't, not knowing your code :)
18:08:54 <adnap_> jmcarthur: I'm not sure yet.  It's spending a bunch of time intersecting rays with polygons, but somehow that's overflowing the stack.  Somehow I need to force evaluation of these computations.
18:09:09 <unkanon> __yhvh__: what kadoban is saying is that project euler' problems are supposed to be mathematically hard, not programmatically
18:09:16 <__yhvh__> I've scoured wikipedia for a clue, but I never know if I'm going in the right direction, I've even showed my maths teacher and she just shook her head
18:09:18 <jmcarthur> but you are sure that's what's doing it?
18:09:23 <unkanon> they are not programming problems, is what I think kadoban is saying
18:09:26 <adnap_> jmcarthur: I swear I'm already using foldl' in a few different places.
18:09:33 <adnap_> jmcarthur: I'm not totally sure, but it looks like it.
18:09:38 <kadoban> ya, exactly
18:09:39 <jmcarthur> sometimes that's precisely what you don't want, actually
18:09:49 <jmcarthur> just depends
18:09:51 <adnap_> jmcarthur: What do you mean?
18:10:20 <jmcarthur> adnap_: well, like when the operation is lazy (although i doubt that's the case this time since you're doing lots of number crunching)
18:10:43 <jmcarthur> adnap_: if you want to track it down further your could try heap profiling and see what's taking the most memory
18:10:51 <adnap_> jmcarthur: How do I do that?
18:10:53 <jmcarthur> like what constructors, types, etc.
18:10:59 <jmcarthur> adnap_: http://haskell.org/ghc/docs/6.12.2/html/users_guide/prof-heap.html
18:11:00 <adnap_> jmcarthur: I've been using +RTS -P
18:11:25 <jmcarthur> adnap_: http://book.realworldhaskell.org/read/profiling-and-optimization.html
18:12:27 <Philippa> __yhvh__: the central part of that question is g(i) for 1 <= i <= 150, yes? And you can optimise that by memoising sf(n), or otherwise only calculating it once for given n, until you've got that range of g(i) values
18:12:50 <revenantphx> Okay...
18:12:51 <Philippa> after that, it depends a bit on how much you need number theory to make it tractable...
18:13:02 <Philippa> (which I wouldn't know)
18:13:11 <__yhvh__> Philippa: yes but the search space is huge, I've analysed the problem
18:13:59 <pozic> __yhvh__: it is computing the answer now on my machine. 
18:14:35 <Philippa> right, so you're into number theory. This ain't the place for that
18:14:35 <__yhvh__> pozic: if correct I'd just like a hint please
18:14:35 <pozic> __yhvh__: it might be that I need to do something less stupid though. 
18:15:14 <__yhvh__> pozic: you may find it chokes around g(40)
18:17:50 <pozic> __yhvh__: this is what I wrote in 5 minutes or so. http://paste.debian.net/101699
18:17:56 <Philippa> throw it at a number theorist, really
18:18:05 <pozic> __yhvh__: but I now see that your problem was with the efficiency.
18:18:30 <Philippa> ...
18:18:31 <pozic> __yhvh__: you can compute the factorials much faster for example. 
18:18:43 <__yhvh__> pozic: well you only need the first 9
18:19:05 <Philippa> okay, that's not impressive. pozic, you do realise that a lot of Project Euler is problems that aren't even tractable without a /mathematical/ analysis rather than just a bunch of well-optimised code?
18:19:19 * hackagebot hledger-lib 0.13 - Core types and utilities for working with hledger (or c++ ledger) data.  http://hackage.haskell.org/package/hledger-lib-0.13 (SimonMichael)
18:19:24 <pozic> Philippa: he said he had issues with Haskell.
18:19:32 <Philippa> __yhvh__ is telling us that g(40) alone is a bitch to find
18:19:41 <pozic> Philippa: he said that after I was done.
18:20:00 <Philippa> so, __yhvh__: what've you got for your implementation of g (and everything it calls)?
18:20:21 * hackagebot hledger 0.13 - A command-line double-entry accounting tool.  http://hackage.haskell.org/package/hledger-0.13 (SimonMichael)
18:20:23 * hackagebot hledger-web 0.13 - A hledger add-on command providing a web interface.  http://hackage.haskell.org/package/hledger-web-0.13 (SimonMichael)
18:20:25 * hackagebot hledger-vty 0.13 - A hledger add-on command providing a full-window console interface.  http://hackage.haskell.org/package/hledger-vty-0.13 (SimonMichael)
18:20:26 <pozic> Philippa: I have no doubt that this is an easy problem.
18:20:27 * hackagebot hledger-chart 0.13 - A hledger add-on command to generate pie charts.  http://hackage.haskell.org/package/hledger-chart-0.13 (SimonMichael)
18:20:35 <pozic> Philippa: otherwise it wouldn't be on Project Euler.
18:20:52 <Philippa> eh, "easy" is likely to depend on perspective
18:21:07 <revenantphx> Okaaaay... My list at the moment is... The Haskell School of Expression, The Elements of Style (not comsci), Logical Approach to Discrete Math, Concrete Mathematics, Lambda-calculus, Combinators and Functional Programming, Category Theory (Awodey), Purely Functional Data Structures, and TaPL.
18:21:08 <pozic> Philippa: let's say below 40 points in Knuth terms.
18:21:09 <adnap_> jmcarthur: Well, one issue that bothers me is that the stack is overflowing, but how can I force allocation to go on the heap?
18:21:15 <revenantphx> (I love christmas :3)
18:21:22 <monochrom> "there exists a 2-line solution and it finishes in 2 seconds"
18:21:30 <kadoban> calling all project euler problems easy is kind of a stretch...
18:21:31 <Philippa> I wouldn't be surprised if simply memoising your sf calls isn't good enough, for example
18:21:54 <Philippa> nor doing that and filling in values for g(i) as you find 'em
18:22:35 <jmcarthur> adnap_: the stack in ghc is a little different from in C, you may be aware. it's just thunk chains that need to be forced, essentially. thunks show up in heap profiles
18:22:47 <__yhvh__> Philippa: I've narrowed what I think to be the problem down to the search space, which I came here to get help finding a solution to
18:22:54 <Philippa> so to have any confidence that's going to run in any tolerable length of time, you're going to want a few properties about sums-of-factorials and digit-summing
18:23:03 <jmcarthur> adnap_: try retainer profiling
18:23:18 <Philippa> well, unless you know more number theory than I do, the search space for g(i) is [1..]
18:23:20 <adnap_> jmcarthur: Will it tell me whether something has been fully evaluated or not?
18:23:39 <jmcarthur> http://haskell.org/ghc/docs/6.12.2/html/users_guide/prof-heap.html#retainer-prof
18:23:50 <monochrom> sum of factorial? like 4!+5!+6! = 4!(1 + 5 + 6) = happiness?
18:23:53 <jmcarthur> adnap_: "The definition of retainers is designed to reflect a common cause of space leaks: a large structure is retained by an unevaluated computation, and will be released once the computation is forced."
18:24:06 <unkanon> revenantphx: did somebody recommend against Bird's Intro to Functional Programming using Haskell?
18:24:12 <Philippa> monochrom: yeah, except now we're summing the resulting digits
18:24:33 <monochrom> summing digits has always been numerology to me
18:24:40 <revenantphx> unkanon: shall I add it?
18:24:52 <monochrom> this is why project euler is also numerology to me
18:25:03 <unkanon> revenantphx: I was going to ask that here :)
18:25:04 <__yhvh__> Philippa: well if you can find one, answer to sf(n) you can brach search on that
18:25:22 <jmcarthur> adnap_: really, if you're feeling too lazy to learn all the profiling methods, you can always just run all of them and then research the one(s) with the more prominant spikes ;)
18:25:38 <Philippa> __yhvh__: how would you be doing the branching from there?
18:25:41 <unkanon> I remember someone here profusely recommending Bird's Intro book but can't rememeber who
18:25:48 <__yhvh__> which is why I asked how I could branch search, like take [3,9] and get [4,8]
18:26:03 <revenantphx> hm, well I'm kind of out of funds.... from this grandparent 
18:26:05 <monochrom> and I erred. 4!+5!+6! = 4!*(1 + 5*(1 + 6))
18:26:08 <revenantphx> I still have 2 more I can hit up for more books.
18:26:19 <revenantphx> ... that sounded really insensitive.
18:26:20 <revenantphx> Ouch.
18:26:22 <monochrom> there is some horner rule going on
18:26:31 <unkanon> revenantphx: just buy 3 at a time
18:26:43 <monochrom> horner rule is scanl is happiness
18:26:44 <Philippa> g(150) is probably pretty big, anyway
18:27:09 <__yhvh__> replicate 9 16 : 6
18:27:14 <monochrom> @monochrom Bird
18:27:14 <lambdabot> Unknown command, try @list
18:27:25 <monochrom> @quote monochrom Bird
18:27:26 <lambdabot> monochrom says: krad!  I'm reading Bird's haskell book now.  It has fusion, parser monad, and monad transformers!  If I read this book instead of Paulson's ML book ten years ago, the history of the
18:27:26 <lambdabot> entire human race would have to be rewritten!
18:27:29 <monochrom> Like that? :)
18:27:38 <unkanon> wow
18:27:51 <unkanon> I guess I'll buy it right now then
18:27:54 * unkanon is not kidding
18:27:57 <monochrom> haha
18:28:11 <revenantphx> I'm trying to weasel another 70$ for it...
18:28:17 <revenantphx> weaseling succesful.
18:28:20 <monochrom> well it's a bit expensive and hard to find, I don't really want to push it. everyone has a limited budget.
18:28:21 <adnap_> jmcarthur: Do I need to do -P if I'm doing -hr -hcB?
18:28:28 <__yhvh__> I deleted my last branch search function in disgust, I'll rewrite and come back
18:28:29 <unkanon> well my wife has to give me something for xmas so  that book will be it
18:28:36 <monochrom> I got my copy for free because another grad student gave it away.
18:28:37 <jmcarthur> adnap_: no
18:29:01 <revenantphx> I'm doing these all as one huge amazon order, cheaper that way.
18:29:11 <revenantphx> I'm going to have a really big satisfying box arriving friday~
18:29:15 * jmcarthur makes a bitter reference to wikileaks
18:29:18 <unkanon> monochrom: also I remember somebody else saying that that was the only book that discussed in-depth the difference between all the different folds (left, right, strict)
18:29:18 <revenantphx> Or monday more likely.
18:29:38 <adnap_> jmcarthur: I'm pretty sure it is this Matrix that is full of thunks, but I'm not yet sure how to force evaluation of its entries.  I'm already doing some foldl''s.
18:29:40 <revenantphx> lol, at this rate by the time I get into college, I'll have bought most of the course material.
18:29:55 <monochrom> A problem is that Bird's book uses old notation, meaning you can't just enter its code into ghc. But you may ask me for translation.
18:29:57 <jmcarthur> adnap_: try it :)
18:30:16 <unkanon> monochrom: careful, I might take up onthe offer :)
18:30:21 <adnap_> jmcarthur: One thing I was told is that foldl' only force evaluation up to the first constructor, so it could be that things are still not fully evaluated.
18:30:21 <revenantphx> monochrom: what's different?
18:30:59 <jmcarthur> adnap_: sounds like you're hoping for something heavy handed like deepSeq
18:31:13 <adnap_> jmcarthur: Hoping?
18:31:32 <jmcarthur> deepSeq isn't inherently bad, but it's not the greatest thing
18:32:04 <adnap_> jmcarthur: Also, this heap profiling doesn't seem to be telling me anything usefull.  All I get are a bunch of lines like: Retainer Profiling: 13, at 1.380000 seconds Average number of visits per object = 4.703179
18:32:09 <jmcarthur> woot, got this thing built with profiling libs now
18:32:13 <Philippa> adnap_: sure, foldl' may be strict but that doesn't make it eager
18:32:14 <unkanon> jmcarthur: there's such a thing as deepSeq?
18:32:33 <jmcarthur> unkanon: yeah. i forget where. the parallel package maybe?
18:32:35 <adnap_> Philippa: I don't know what you mean.
18:32:49 <unkanon> aww, there's a difference between eager and strict? *just when I thought I understood all of that
18:32:55 <monochrom> firstly it writes like λx→ [ y | y←[1..]] so you have to translate it back to ascii.
18:33:06 <unkanon> jmcarthur: cool, good to keep on the back of my head
18:33:37 <unkanon> well haskell actually accepts that arrow there :)
18:33:43 <jmcarthur> adnap_: did you run the hp2ps thing?
18:33:44 <unkanon> if you pass it a flag I forgot now
18:33:48 <adnap_> jmcarthur: huh?
18:33:51 <jmcarthur> adnap_: you're supposed to get a graphic
18:33:53 <unkanon> it doesn't accept the lambda letter though
18:33:54 <adnap_> jmcarthur: I ran Retainer Profiling: 13, at 1.380000 seconds Average number of visits per object = 4.703179
18:33:58 <monochrom> secondly its "strict f x" is our f $! x
18:33:58 <adnap_> jmcarthur: oops
18:34:04 <adnap_> jmcarthur: Retainer Profiling: 13, at 1.380000 seconds Average number of visits per object = 4.703179
18:34:07 <adnap_> jmcarthur: agh wtf
18:34:10 <jmcarthur> adnap_: follow the instructions at those links i gave you
18:34:18 <adnap_> jmcarthur: Retainer Profiling: 13, at 1.380000 seconds Average number of visits per object = 4.703179
18:34:21 <adnap_> lol
18:34:25 <jmcarthur> it's okay
18:34:25 <adnap_> let me just type it
18:34:35 <Philippa> adnap_: strictness is the property that f _|_ = _|_, no more, no less
18:34:36 <adnap_> jmcarthur: -hr -hcB
18:34:50 <unkanon> hmm I see
18:34:53 <jmcarthur> adnap_: yeah, after you do that you run the output into a processor that creates a graphic for you
18:35:04 <Saizan> adnap_: it should have produced an .hp file
18:35:04 <jmcarthur> adnap_: just follow the instructions at either of those links
18:35:29 <adnap_> oh, okay
18:35:44 <adnap_> I'm using: http://haskell.org/ghc/docs/6.12.2/html/users_guide/prof-heap.html#retainer-prof
18:35:55 <jmcarthur> adnap_: if you scroll up it gives the big picture
18:36:14 <jmcarthur> hp2ps is what it recommends. i think hp2pdf exists as well
18:36:55 <unkanon> monochrom: just bought it, should have it by the end of the week :)
18:37:04 <adnap_> agh
18:37:18 <adnap_> jmcarthur: the problem is that when I cut the program off early, I don't get a valid hp file
18:37:28 <jmcarthur> ah suckage
18:37:36 <Saizan> that's not a problem
18:37:37 <adnap_> jmcarthur: maybe I can tweak it by hand
18:37:44 <Saizan> exactly
18:37:56 <Saizan> you just have to delete the last partial record
18:38:01 <younder> will you shut up!
18:38:09 <monochrom> I won't
18:38:09 * jmcarthur waits for his ^C to work...
18:38:13 <jmcarthur> younder: ?
18:38:26 <adnap_> Saizan: I did, and that's exactly what I meant.
18:38:57 <adnap_> jmcarthur: lol, my chart is empty
18:39:15 <adnap_> wtf
18:39:25 <jmcarthur> hey cool i got an empty .hp file. i'm gonna just blame it on this silly intel graphics card playing badly with gpipe and not even giving your code a chance to run
18:39:47 <adnap_> my hp file isn't empty, but hp2ps produces a graph with no data points
18:40:09 <younder> you are filling up my log with irrelevant drivle.
18:40:28 <monochrom> I heard the sun has crazy magnetic activity about now and may affect your computer.
18:40:44 <medfly> lol
18:40:45 <jmcarthur> younder: i'm sorry that somebody else's on-topic conversation is in your way. use /ignore
18:40:46 <younder> nop, solar minimum
18:41:39 <monochrom> use /leave #haskell
18:42:16 <adnap_> jmcarthur: I don't understand why my chart is empty.  Could it be my viewer?  I'm using evince to view the ps file.
18:42:29 <adnap_> jmcarthur: Would you like my to hpaste my hp file?
18:42:47 <younder> That's a bit hatche
18:43:38 <younder> s/hatche/harsh/
18:43:42 <jmcarthur> adnap_: nah, i'll figure out what i'm doing wrong here
18:44:56 <pozic> __yhvh__: I see what your original question was about now. 
18:45:58 <younder> Actually I deserve it far more on Lisp where I assosiated antifuchs with Klaus Fuchs.
18:46:01 <pozic> __yhvh__: that seems a logical and perfectly non-create step to optimize, yes. It should be the kind of optimization performed by a compiler. 
18:46:08 <pozic> non-creative*
18:46:47 <younder> clearly a relative
18:48:32 <younder> (the dude that gave the a-bomb to the russians..)
18:49:31 <ezyang> "Haskell data definitions define the *greatest* fixed points of equations." I don't think this statement is true. Someone enlighten me? 
18:49:46 * jmcarthur wonders when adnap_'s program is going to stack overflow on him...
18:51:09 <adnap_> jmcarthur: One thing I'm noticing is that rows of the matrix are not being evaluated right away.  If this were the case, when I print out the matrix, I should see each row come in one at a time, right?
18:51:14 <ezyang> greatest fixed point lets me do coinduction, which isn't really what Haskell data types look like. 
18:51:27 * hackagebot husk-scheme 1.2 - R5RS Scheme interpreter program and library.  http://hackage.haskell.org/package/husk-scheme-1.2 (JustinEthier)
18:52:11 <jmcarthur> adnap_: if they were all being evaluated up front then you wouldn't see their evaluation in the first place. it would just be all at once
18:52:19 <monochrom> you are supposed to do coinduction when you try to prove map id xs = xs.
18:52:20 <younder> Are you using a NVIDEA and in that case why not?
18:52:38 <__yhvh__> pozic: so I have this function, http://pastebin.com/3tmbntpV , it works for 2 digits, how could I make it work for arbitraryly many?
18:53:05 <younder> You wand vector processing , yes?
18:53:21 <ezyang> monochrom: Oh, that is true. 
18:53:25 <pozic> ezyang: what is the formal definition of greatest fixed point?
18:53:33 <ezyang> pozic: Uhh 
18:53:42 <younder> So get a Tesla, or better still get two.
18:53:47 <pozic> ezyang: Wikipedia doesn't define it. 
18:53:55 <jmcarthur> adnap_: on my machine i get bunch of output and then it hangs and burns the cpu for a while, but memory isn't going up
18:53:56 <pozic> ezyang: that means it is not popular.
18:54:04 <ezyang> TAPL had one formulation that I liked. 
18:54:11 <jmcarthur> adnap_: i'm at 5 minutes so far
18:54:16 <jmcarthur> still no overflow
18:54:21 <pozic> ezyang: I thought TAPL sucked ;)
18:54:25 <jmcarthur> adnap_: what build flags are you using?
18:54:46 <adnap_> jmcarthur: The bunch of output is just the elements.  Solution is of type [(Element, Double)], So, you're seeing the first part of the tuple.
18:54:47 <jmcarthur> adnap_: i built with -O2
18:54:55 <adnap_> jmcarthur: me too
18:55:08 <jmcarthur> adnap_: it didn't print a comma like it's trying to do a second part, but maybe that's just my buffermode
18:55:30 <pozic> ezyang: I found a definition now, but as such your statement is ill-typed.
18:55:47 <ezyang> aha! 
18:56:00 <pozic> ezyang: functions can have a greatest fixed point, but a data type is not a function. 
18:56:04 <jmcarthur> adnap_: well, i'm having to ^C^C it, which is causing it not to output any profiling info
18:56:39 <pozic> Unless you say it is a function from Type -> ASetOfDataConstructors. 
18:56:53 <ezyang> The greatest fixed point is the union of all F-consistent (X \subsetof F(X)) sets 
18:57:12 <pozic> ezyang: oh, cool, and what is F-consistent?
18:57:15 <ezyang> pozic: So it's simply a question of defining the set and the relation F appropriately 
18:57:39 <adnap_> jmcarthur: Oh, really?  I had to do that too, but somehow I still got profiling info.
18:57:52 <pozic> Every author thinks they can claim their own letter of the alphabet. 
18:58:12 <monochrom> F-consistent (X \subsetof F(X)) sets
18:58:26 <ezyang> Let F be a monotone function P(U) -> P(U) (where P is the powerset function), then F is F-consistent if for some subset of U is a subset of F of that subset. 
18:58:37 <monochrom> perhaps F-consistent (\\ \lambda \rightarrow X \subsetof F(X)) sets
18:59:08 <pozic> Normal people call that impredicative relations.
18:59:09 <ezyang> So, I think the universe is values of that type 
18:59:20 <ezyang> And F is our coinduction principle 
18:59:24 <Saizan> pozic: [1,1..] is not a function, and yet it's the least fixed point of (1:)
18:59:25 <pozic> If I understand it correctly. 
18:59:29 <ezyang> pozic: Ok. :-) 
19:00:03 <pozic> If I am right, then whoever wrote the F-consistent simply should never ever have written a paper/book.
19:00:17 <pozic> Making things complicated is easy.
19:00:20 <adnap_> jmcarthur: Can you check out a bit of the code really quickly?  I want you to see what I'm talking about with the rows of the matrix.
19:00:23 <Saizan> likewise [a] is not a function, but it's the fixed point of \l -> Either () (a,l)
19:00:28 <unkanon> I think "normal people" don't know the word impredicative exists even
19:00:48 <jmcarthur> adnap_: where is it?
19:00:59 <ezyang> Hmm, I think now would be a good time to revisit the recursive types chapter of TAPL 
19:01:04 <Saizan> given haskell semantics the greatest and the least fixed points of \l -> Either () (a,l) end up being the same thing
19:01:04 <adnap_> jmcarthur: In Radiosity.hs, there's formFactorMatrix and formFactors.
19:01:07 <ezyang> I think I'm in a much better place now mathematically. 
19:01:36 <adnap_> jmcarthur: formFactorMatrix is created from a bunch of vectors, returned by formFactors.
19:01:43 <adnap_> jmcarthur: What I
19:01:51 <jmcarthur> adnap_: where are Vector and Matrix from?
19:01:57 <adnap_> jmcarthur: hmatrix
19:01:57 <monochrom> "F-consistent" and its definition does not make things complicated.
19:02:01 <__yhvh__> I think I have a lot of reading to do
19:02:12 <jmcarthur> adnap_: ah, well... aren't those FFI types? implying that they are strict?
19:02:33 <adnap_> jmcarthur: Oh, I'm not sure.  Is hmatrix a binding to a C library or something?
19:02:33 <pozic> ezyang: ATAPL is even worse, btw. 
19:02:37 <jmcarthur> yes
19:02:47 <adnap_> jmcarthur: Oh, so I don't even have to worry about evaluation.
19:02:57 <jmcarthur> well, you do, but not about this
19:03:10 <jmcarthur> i'm beginning to think maybe you just have a logical bug
19:03:19 <jmcarthur> i never hit the stack overflow you were talking about
19:03:42 <jmcarthur> i'll try once without all the profiling stuff
19:03:51 <adnap_> jmcarthur: Have you tried computing smaller solutions?  The tweak variables are: raysPerElement and areaThreshold.
19:04:23 <jmcarthur> adnap_: what are reasonable small values?
19:04:29 <adnap_> jmcarthur: All of the profiling indicated that the issue was building up the matrix.  I suspect that the stack overflow was the result of trying to build up a giant matrix.
19:04:54 <adnap_> jmcarthur: Can you tell me what happened with you?  You said you didn't get a stack overflow?  Did you get a picture on the screen then?
19:05:25 <jmcarthur> adnap_: no, i went with the print-to-terminal method
19:05:31 <adnap_> jmcarthur: oh
19:05:39 <jmcarthur> adnap_: my graphics card sucks enough that i didn't want gpipe tainting the results
19:06:04 <jmcarthur> i've had even simple gpipe examples crash
19:06:07 <adnap_> jmcarthur: Making areaThreshold smaller and raysPerElement larger results in a more complex problem.
19:06:33 <Pseudonym> BTW, I consider this yet more evidence that radiosity is the wrong answer.
19:06:55 <Pseudonym> But I guess that's just me.
19:07:01 <jmcarthur> adnap_: how large is the [Ray] list going into formFactors typically going to be?
19:07:06 <pozic> Pseudonym: what is the question?
19:07:21 <Pseudonym> pozic: Solving the rendering equation.
19:07:26 <unkanon> __yhvh__: what's that function supposed to do?
19:07:32 <unkanon> it simply boxes a list for me
19:07:44 <adnap_> jmcarthur: for formFactors, the ray list is number of elements * raysPerElement.  The number of elements is related to the areaThreshold.
19:08:03 <__yhvh__> takes like [3,9] and gives [[3,9],[4,8],[5,7],[6,6],[7,5],[8,4]]
19:08:04 <adnap_> jmcarthur: Area threshold defines how finely geometry is chopped.
19:08:26 <pozic> Pseudonym: the solution to that problem always depends on the hardware available. 
19:08:35 <adnap_> jmcarthur: You can see how many elements there are by doing length $ scene areaThreshold
19:08:47 <jmcarthur> adnap_: the reason i ask is that that function will hold onto the whole list all the way until it's done. if the list is very large then i could see that taking some memory. still no stack overflow though
19:09:15 <jmcarthur> adnap_: since it's folding over the list and then taking the length of it
19:09:52 <adnap_> jmcarthur: Oh, shoot
19:10:00 <adnap_> jmcarthur: Maybe I should compute the length beforehand.
19:10:01 <jmcarthur> adnap_: but i still don't think that's your problem
19:10:07 <unkanon> __yhvh__: v
19:10:09 <unkanon> @let genAdds [a,b] = let n=a+b in  [(x,y) | x <- [0..9], y <- [0..9], x+y==n]
19:10:10 <lambdabot>  Defined.
19:10:14 <unkanon> genAdds [3,9]
19:10:17 <Pseudonym> Any computation problem depends on the hardware available, but radiosity has a well-known problem that it wastes effort no matter what you do, and doesn't solve the whole equation anyway.
19:10:20 <unkanon> > genAdds [3,9]
19:10:20 <lambdabot>   [(3,9),(4,8),(5,7),(6,6),(7,5),(8,4),(9,3)]
19:10:49 <monochrom> sometimes the problem is submitting a paper
19:11:22 <pozic> Pseudonym: but it does produce 'pretty pictures'.
19:11:26 <Pseudonym> Oh, and it doesn't scale to nontrivial geometry.
19:11:42 <adnap_> Pseudonym: I don't know what you're talking abuot.
19:11:45 <adnap_> Pseudonym: It does too.
19:11:59 <adnap_> Pseudonym: Are you making stuff up or something?
19:12:16 <Pseudonym> No.  I'm saying that if you have 2Gb of geometry, radiosity doesn't work.
19:12:26 <jmcarthur> adnap_: btw, that's a common pattern for (heap) space leaks:  f accumOfLargeStructure anotherAccumOfSameStructure
19:12:44 <__yhvh__> unkanon: it kinda misses the point, I need it to generate [1,2,9], [1,3,8] etc and on 
19:12:54 <adnap_> Pseudonym: I don't know what you mean by "doesn't work".
19:13:10 <jmcarthur> i think i'll drop this for now. i don't think i'm being very helpful
19:13:15 <unkanon> __yhvh__: that's a lot harder
19:13:30 <Pseudonym> adnap: Only that it's impractical on that scale.
19:13:42 <__yhvh__> unkanon: you can maybe see why I took the crooked approach
19:14:01 <pozic> Pseudonym: is there anything that does work on that scale?
19:14:03 <Pseudonym> Radiosity isn't useless, it just doesn't scale to a lot of modern workloads.
19:14:04 <__yhvh__> is this the subset sum problem?
19:14:05 <unkanon> __yhvh__: I can't because I know nothing about mathematics, I don't really care for project euler
19:14:08 <Pseudonym> Yes, Monte Carlo methods.
19:14:16 <Pseudonym> Importance sampling.
19:14:19 <pozic> Pseudonym: those are quite old too. 
19:14:21 <adnap_> Pseudonym: Radiosity can be an offline process.
19:14:35 <pozic> Pseudonym: I didn't hear about importance sampling, though.
19:14:36 <adnap_> Pseudonym: You can cache the radiosity values for static geometry and never compute them again.
19:14:52 <adnap_> Pseudonym: My radiosity solver is using Monte Carlo integration.
19:14:57 <pozic> adnap_: but in a game the idea is that it is not static. 
19:14:58 <adnap_> Pseudonym: With importance sampling.
19:15:10 <Pseudonym> pozic, I didn't complain that radiosity is old. I complained that it doesn't scale to 2Gb geometry.
19:15:13 <adnap_> pozic: Some things are, like the environment.
19:15:38 <adnap_> pozic: I'm sure plenty of games do some kind of global illumination and then cache the results into light maps.
19:15:39 <Pseudonym> adnap: You have a good point on static vs dynamic.  In practice, the GI problem is often effectively separable.
19:16:04 <Pseudonym> You can solve for a static term, and then solve for (or fake) any dynamic terms.
19:16:16 <Pseudonym> Oh, it's a _game_.  That makes a bit more sense.
19:16:28 <adnap_> Anyway, I have to turn this project in tomorrow.  I think I might bail and port to C for the sake of getting a good grade.  Maybe I'll try to fix the haskell program later. :/
19:16:50 <Pseudonym> The workloads in games are generally less complex than in, say, acoustic modelling or visual effects.
19:17:40 <adnap_> Pseudonym: Meh, I never said radiosity is the best choice.  I'm simply implementing it for a project as a learning experience.
19:17:47 <Pseudonym> That's perfectly fair.
19:18:01 <pozic> Pseudonym: do you work in the visual effects industry>
19:18:03 <adnap_> Unfortunately, most of the learning has been about how to debug haskell programs.
19:18:06 <Pseudonym> Used to.
19:18:13 <pozic> Pseudonym: what do you do now?
19:18:20 <Pseudonym> Bioinformatics.
19:18:32 <Pseudonym> Part text, part genomes.
19:18:47 <pozic> Pseudonym: do you do some biology too? 
19:18:52 <ville> How's Haskell development targeting Android looking these days?
19:18:55 <Pseudonym> Not really.  Wet lab is not for me.
19:19:10 <pozic> Pseudonym: ok, so still pushing bits around ;)
19:19:19 <Pseudonym> Yup.  Lots of bits, in fact.
19:19:36 <pozic> Pseudonym: the visual effects seem to be more sexy on a surface.
19:19:40 <Pseudonym> Some statistics, some basic algorithms/data structures etc.
19:20:09 <pozic> Pseudonym: in my experience most programs require the same kind of things. 
19:20:32 <pozic> Pseudonym: numerical computing is completely different, though. 
19:21:05 <Pseudonym> Every interesting area has its own challenges.
19:21:06 <pozic> That has traditionally been more of an area dominated by mathematicians, instead of computer scientists.
19:21:25 <Pseudonym> What I'm doing is a bit data structures, a bit statistics, a bit compression, a bit text processing...
19:21:29 <Pseudonym> A bit machine learning...
19:21:56 <pozic> Pseudonym: at a university or an industry lab?
19:22:26 <Pseudonym> Both, kind of, sort of.  I'm at NICTA, which is sort of like INRIA.
19:22:36 <Kaidelong> I've drastically changed my aesthetics class
19:22:44 <Pseudonym> So it's applied research, really.
19:23:23 <Kaidelong> and it now takes two parameters instead of four
19:23:56 <Kaidelong> it no longer supports forgetting virtues though or changing their weights, but I figure the implementation can handle that since I'll likely initialize the aesthetic once at the start of a simulation
19:24:52 <pozic> Pseudonym: I think that's what pushes society forward in the end. 
19:25:09 <pozic> Pseudonym: pieces of paper without implementation don't do anything.
19:25:38 <pozic> Pseudonym: especially when those pieces of paper are wrong :)
19:25:52 <pozic> I wonder whether peer-review has ever worked.
19:25:59 <Pseudonym> Yeah, I think that if you put "good theory" and "good practice" on a Venn diagram, the interesting stuff happens in the middle.
19:26:06 <Pseudonym> The interserction.
19:26:11 <Pseudonym> intersection
19:26:54 <monochrom> you don't even know what is right and what is wrong a priori. nevermind what is good.
19:27:36 <Pseudonym> BTW, the peer review things is worse in computer graphics than anywhere else.
19:27:36 <Pseudonym> Pixar gets a couple of SIGGRAPH papers a year, and none of them have reproducible results.
19:27:45 <pozic> If you have implemented and tried all the theory, it's the turn of the theory people again to do something. 
19:27:54 <pozic> Pseudonym: because of the commercial interests.
19:28:04 <pozic> Pseudonym: it's more like advertising. 
19:28:15 <Philippa> Pseudonym: wow, worse than image recognition? Ouch
19:28:49 <Pseudonym> Computer graphics, image processing... it's very similar stuff.
19:28:49 <pozic> There are some journals that only accept papers that come with source code now.
19:28:57 <Philippa> (Chowshe tells me in image recognition, nobody gives you all the fudge factors you need to get the algorithm to actually do something useful even on a pre-specified input, so you can't actually implement anything worth a damn without aaaaages experimenting)
19:28:57 <tg_> How is that an indictment against peer review?
19:29:04 <Pseudonym> tg: It's not.
19:29:08 <tg_> ok
19:29:09 <Pseudonym> IMO
19:29:26 <pozic> It isn't?
19:29:39 <pozic> It clearly shows that what is supposed to be science, isn't.
19:29:56 <pozic> Peer-review is a nice idea, but nobody does it.
19:30:08 <Pseudonym> All Pixar papers should be predicated with "first, assume you have the source code for PRMan".
19:30:10 <pozic> Reading other peoples stuff doesn't get you tenure. 
19:30:32 <pozic> Correcting it only wastes more time.
19:30:57 <pozic> The smartest thing to do is to keep your mouth shut and only say as much to give other people a good feeling about you.
19:31:06 <Pseudonym> Actually, it's not as bad as I make out.  You could implement their techniques in your system, but things like timings are meaningless.
19:33:03 <monochrom> How is that an indictment against peer review, if nobody does it and therefore you don't know what would happen if someone did it?
19:33:18 <monochrom> in fact, s/if/since/
19:33:21 <pozic> Ok, it's not. 
19:33:21 <tg_> monochrom: I thought it, but I thought surely that's obvious
19:33:23 <tg_> lol
19:33:46 <pozic> But they are all saying it's 'peer-reviewed'.
19:33:58 <revenantphx> :O
19:34:01 <revenantphx> well, there we go.
19:34:06 <revenantphx> Massive 450$ book order!
19:34:08 <pozic> It's more like that a guy looks at it for a few hours and tries to spot obvious mistakes.
19:34:11 <revenantphx> Hurray for consumer holidays!
19:34:20 <monochrom> are you sure you have that much money?
19:34:28 <pozic> While a good analysis would take weeks. 
19:34:29 <revenantphx> Yep. I save up aaaaall year.
19:34:42 <Pseudonym> monochrom: That sounds like Gandhi's comment on Western civilization.  "I think it would be a good idea."
19:34:44 <monochrom> I hope you will like the books.
19:34:48 <revenantphx> Last year I got 100$ of books and a new PS3, this year it's all books
19:34:52 <revenantphx> My final purchase list was...
19:34:57 <tg_> pozic: this all varies by field, but I think recent peer review efforts in physics have demonstrated that things are changing
19:35:02 <tg_> just nobody knows in what direction, yet
19:35:12 <pozic> tg_: in physics there is less of a commercial motive.
19:35:21 <pozic> tg_: and the best tools are controlled by non-profits.
19:35:34 <pozic> tg_: at least in some areas.
19:35:40 <tg_> but there is a much larger ego-motive (which was previously thought to be a worse influence)
19:35:44 <unkanon> Pseudonym: lol that's a funny quote
19:35:56 <revenantphx> Haskell School of Expression, A Logical Approach to Concrete Math, Purely Functional Data Structures, Introduction to Functional Programming w/ Haskell, Cateogory Theory (Awodey), Elements of Style (Strunk & White, not Comsci), Concrete Mathematics, Lambda-calculus, Combinators and Functional Programming, and TaPL
19:36:02 <revenantphx> I think I've got enough reading for the rest of next year tbh.
19:36:16 <revenantphx> probably much much more than tha.t
19:36:32 <pozic> revenantphx: Concrete Mathematics is enough for a long time. 
19:36:38 <revenantphx> I'm sure :).
19:36:40 <pozic> revenantphx: if you do all the exercises.
19:36:49 <revenantphx> What point is a textbook if you just skim it?
19:36:54 <monochrom> I think it's for 5 years. You've just got another communist 5-year plan!
19:37:02 <pozic> You can read it and think "yeah, that makes sense.".
19:37:02 <revenantphx> monochrom: awesome :D
19:37:08 <revenantphx> pozic: Well I don't agree with that.
19:37:17 <pozic> Then you do some exercises and then it's like "Hmm... that's kind of hard.".
19:37:18 <revenantphx> If you do that, you won't remember any of it a week later.
19:37:22 <pozic> revenantphx: no, we agree.
19:37:27 <revenantphx> You have to do exercises :)
19:37:28 <pozic> revenantphx: I just wasn't finished yet.
19:37:32 <revenantphx> oh, sorry 
19:38:06 <monochrom> more reason to press <enter> less often.
19:38:11 <nus> monochrom, communist 5-year plans are easily solved by experienced communist statisticians in a year
19:38:13 <pozic> One can question the use of these exercises, though. 
19:38:52 <revenantphx> monochrom: 1) ouch! 2) yeah, you're right.
19:38:56 <pozic> If you find a problem in real life, you might also think, ah, now I could apply that book and then study it in more detail.
19:40:26 <revenantphx> They should all come Friday in a really heavy box. I'm excited.
19:40:38 <revenantphx> Friday is the day I finish all my essays and such, so I'll have mroe free time.
19:41:06 <handonson> what would be the fastest way to convert a Word32 into four Word8s?
19:41:29 <blackh> handonson: Fastest for you or for the CPU?
19:41:53 <revenantphx> i did this earlier....
19:41:58 <handonson> well preferably the latter
19:42:01 * pozic thinks questions like that should be solved by a compiler.
19:42:02 <revenantphx> fromIntegral (x `shiftR` 24)
19:42:11 <revenantphx> fromIntegral (x `shiftR` 16)
19:42:11 <revenantphx> etc
19:42:18 <blackh> handonson: Use the code in Data.Bits.  You can also do it with the 'binary' package.
19:42:50 <revenantphx> this looks about what you're looking for.
19:42:50 <revenantphx> https://gist.github.com/731418
19:42:51 <handonson> yes i've been doing it with Data.Bits and felt maybe it was not the proper way
19:43:10 <pozic> How high-level a language is, is only determined by how fast it is if you write out the most obvious algorithm.
19:43:58 <pozic> You can read "language implementation" if you want.
19:44:48 <monochrom> the most obvious algorithm for me is the prologish Predicate(parameter, answer).
19:45:21 <Philippa> pozic doesn't like the Perlis definition, then?
19:46:04 <Philippa> 'cos I've written out plenty of code that, while 'obvious' for the language in question, still contained plenty of attention to the irrelevant
19:46:18 <handonson> how do you clamp?
19:46:40 <handonson> does fromIntegral do that?
19:46:47 <monochrom> yes
19:47:01 <handonson> thanks.
19:47:02 <monochrom> > fromIntegral (4983504 :: Word32) :: Word8
19:47:02 <lambdabot>   208
19:47:24 <monochrom> double-check that it is what you want
19:48:06 * monochrom verifies on his new-fangled ipod-touch calculator app! has bitwise calculator.
19:48:29 <pozic> Philippa: I like that which has utility. "Bending the mind" has no utility. 
19:48:40 <monochrom> ("his" means "he has downloaded", not "he has written" :) )
19:48:45 <Pseudonym> Actually, a lot of people could do with a thorough brainwashing.
19:49:20 <pozic> Taken as a whole the human race is idiotic. 
19:49:23 <tg_> pozic: relativity is a counterexample. It has (and continues to) bent the minds of many people, and is responsible for the trasistor.
19:49:27 <tg_> s/trasistor/transistor/
19:49:31 <monochrom> 208 is right :)
19:49:40 <Pseudonym> tg: I think you meant quantum mechanics.
19:49:47 <tg_> I didn't
19:49:54 <tg_> I'm a physicist, I meant what I said :o
19:50:05 <Pseudonym> I find relativity quite easy to understand.  I find it hard to believe.
19:50:18 <monochrom> the new-fangled calculator app is http://appshopper.com/utilities/calculatorbox
19:50:20 <tg_> Curious, I am the other away around re: QM and SR
19:50:32 <Pseudonym> If you shut up and calculate, it's all good.  It's the moment you try to apply common sense that everything goes wrong.
19:50:37 <Philippa> pozic: all you're saying is that speed is relevant - so what?
19:50:45 <pozic> If you add all the costs of all the paid programmers and system administrators and you would give that to one research institute, you would not need programmers anymore after some time. 
19:50:48 * monochrom fishes for more suddenly-free apps!
19:51:18 <Philippa> you'd also crash the entire industrial system, and thus your research institute's workers wouldn't even get fed
19:51:38 <Pseudonym> tg_: I'm curious where relativity comes in when understanding the transistor.  I mean, it certainly applies, because it needs the Dirac model of the electron etc.
19:52:02 <tg_> Pseudonym: that's just where.
19:52:02 <monochrom> relativity is responsible for the gps and quantum mechanics is responsible for the transistor. have you cake and eat it too.
19:52:14 <tg_> It's Dirac and nowhere else :o
19:52:19 <Pseudonym> Ah, right. :-)
19:52:24 <kmc> but if we want transistorized gps then we're screwed
19:52:26 <kmc> wait...
19:52:27 <tg_> Maybe Tokinanawa (sp?)
19:52:39 <pozic> Sometimes I think physics people are much smarter than those in other sciences. 
19:53:00 <pozic> It could also be that it's just my field. 
19:53:03 <Pseudonym> pozic: No, they're just better adapted, in an evolutionary sense.
19:53:05 <pozic> not*
19:53:06 <Philippa> tg_: anyway, pozic was saying that mind-bendingness isn't useful in and of itself. Which, y'know, is true except insofar as your mind gets bent into a more useful shape
19:53:07 <Kaidelong> I haven't really thought of any one of them being consistently smarter
19:53:12 <tg_> pozic: Sometimes I would agree, myself excluded. But sometimes it's just amazing mathemics that make them seem smarter than us.
19:53:39 <monochrom> Ah, I see, haven't thought of the dirac thing.
19:53:43 <Pseudonym> It takes many years of ignoring other interesting things to get that good at theoretical physics.
19:53:45 <pozic> I also don't like the fairly large steps that are made. 
19:53:46 <Kaidelong> chemists and biologists sometimes impress me with their capacity for remembering things so easily
19:53:47 <Philippa> explaining world-passing IO to physics undergrads tends to make them shut up about QM being mind-bending, so hey :-)
19:53:58 <pozic> I always needed to explain every step of a proof. 
19:54:03 <tg_> Philippa: I don't think the kind of 'mind bending' the iPad causes laypeople is useful, but the kind of mindbending that results from reading Newton, Hilbert, Riemann, Einstein, Dirac, Feynman, Winger, ...
19:54:35 <Philippa> tg_: "except insofar..."
19:54:36 <Pseudonym> tg: So read some Turing, von Neumann, Chaitin, Kolmogorov...
19:54:38 <pozic> In physics it's mostly like "then <complex formula> follows from <trivial application of theorem 22.1 from paper that cannot be found anymore>
19:54:54 <Pseudonym> Hell, read some Philip Wadler.
19:54:57 <tg_> Pseudonym: I totally agree for the first two :o
19:55:01 <Pseudonym> You're more likely to understand it!
19:55:01 <tg_> and Wadler, who I love
19:55:01 <Kaidelong> Philippa: I did not personally have much trouble grasping the copenhagen interpretation, although I suppose I'd struggle with the mathematical basis and application fo it
19:55:06 <tg_> There are too many to list.
19:55:21 <tg_> But I'm talking about people who provide theories which totally change the way something is interpreted.
19:55:29 <pozic> Pseudonym: The stuff they wrote comes easy for me. 
19:55:45 <Philippa> Kaidelong: I love winding people up when they try to use schroedinger's cat as an explanation of it instead of a query of it, myself
19:55:54 <pozic> I think it just is that it simply takes years to get into a field.
19:55:59 <Pseudonym> Dijkstra has the best of both worlds, since he was a theoretical physicist who became a theoretical programmer.
19:56:04 <tg_> pozic: there is the 10,000 hour theory
19:56:05 <pozic> But that in principle you could enter any field.
19:56:26 <tg_> which I like to accompany with the commonly-lived under 30 statistic that kids spend 10k hours in school, and 10k hours gaming
19:56:38 <Kaidelong> Philippa: I think the easiest way to understand it is just to say that "everything is a bit blurry and uncertain but less so when you look at it"
19:56:43 <Philippa> Pseudonym: and demonstrates neatly that theoretical physicists are shit at library building and management? :-)
19:56:45 <Pseudonym> I recently discovered Mihai Patrascu.  He's way, way too smart for me.
19:57:20 <Pseudonym> But it just goes to show that there are geniuses everywhere.  But Patrascu won't make the headlines like Feynman did.
19:57:22 <tg_> Mihai obtained a PhD (2008) and B.S. (2006) from MIT
19:57:23 <tg_> wow
19:57:25 <tg_> that's fast
19:57:32 <Pseudonym> Told you.
19:57:48 <Philippa> (the day mathematics does 'proof engineering' the way we at least hope we do 'software engineering', let alone the way it /should/ be done...)
19:57:56 <tg_> Feynman (self-admittedly) wasn't that smart.
19:57:58 <pozic> Pseudonym: his PhD shows that?
19:58:00 <tg_> He was a genius communicator.
19:58:11 <Kaidelong> well that's smarts in itself
19:58:21 <tg_> yes, it's a different kind of thing.
19:58:26 <tg_> It's not like, autistic savantism smart
19:58:29 <pozic> I heard two hours of Feynman today. I liked him. Too bad he is dead. 
19:58:30 <Philippa> pozic: how many cases of a 2-year PhD are you aware of in the last decade?
19:58:36 <unkanon> it's like street smart? :)
19:58:41 <Philippa> "autistic savantism smart"... *puke*
19:58:46 <tg_> unkanon: I dislike that term, but it's close to it :o
19:58:54 <unkanon> heh
19:59:09 <tg_> Philippa: the kind of ability which 99.99% of people aren't capable of because of their genetics.
19:59:30 <pozic> Philippa: PhDs take shorter in the US. So, technically he only did it 1.5 times as fast. 
19:59:31 <unkanon> 99.99 is a bit low really
19:59:38 <tg_> unkanon: probably
20:00:06 <Pseudonym> I dunno about that.  There are a lot of people smarter than Einstein who have died over the years in sweat shops and on cotton fields.
20:00:10 <Philippa> "only"... (and there're plenty of PhDs that took longer than that in practice even in the US, too - that, and I think they're nominally scheduled for 3 years where I am too)
20:00:32 <Pseudonym> 99.99% might be accurate, but most of the 0.01% don't get the opportunity.
20:00:32 <tg_> For reference, he got his BS when he was 24 and his PhD when he was 26
20:00:34 <Philippa> mmm. Someone's assessed me and concluded I'm 4 9s smart before, but...
20:00:37 <tg_> so it's not too far off normal for the PhD age
20:00:53 <Philippa> I don't think that's that big a deal in this chan, even
20:01:04 <Philippa> it's a question of what kind of smart you're 4 9s at /and what opportunity you have/
20:01:17 <tg_> Philippa: yes
20:01:19 <Pseudonym> You're certainly in a peer group here.
20:01:37 <tg_> Then, there are people like http://en.wikipedia.org/wiki/Srinivasa_Ramanujan
20:01:39 <Philippa> (and re the wording that I puked at: I have an ASD, but this ain't savant skills)
20:02:17 <Pseudonym> Actually, I should go check on a student.  BRB
20:02:26 <pozic> I got my BS when I was 19 if we are keeping score. 
20:02:27 <unkanon> Pseudonym: Pseudonym 99.99 is only an IQ of 156 which while high isn't like 180
20:02:29 <Cale> I tend to think of the Copenhagen interpretation of QM as being like a sort of garbage collection on top of the many worlds interpretation. If all the observers that we care about are entangled with the system in some way, there's no point in keeping around the other terms of the sum in each of those worlds. :)
20:02:32 <tg_> Quoting K. Srinivasa Rao,[91] "As for his place in the world of Mathematics, we quote Bruce C. Berndt: 'Paul Erdos has passed on to us Hardy's personal ratings of mathematicians. Suppose that we rate mathematicians on the basis of pure talent on a scale from 0 to 100, Hardy gave himself a score of 25, J.E. Littlewood 30, David Hilbert 80 and Ramanujan 100.'"
20:02:41 <guest2425> Do yuo guys have any idea how to solve the KenKen puzzle Haskell?
20:02:50 <Philippa> I honestly have no idea what I would've been capable of if I'd been introduced to suitably formal maths at 10, but I suspect a lot. OTOH, other things mattered, probably more
20:03:17 <tg_> unkanon: the 99.99 was totally made up on my part. You're right to point out the error, but don't belabor it.
20:03:19 <kadoban> Cale: haha, that's pretty cute.  i like it
20:03:30 <unkanon> Philippa: nothing matters, really
20:04:01 <Philippa> unkanon: eh, if we're going to get like that about it then I get to decide what does - at least to me, which is what I was commenting on
20:04:17 <tg_> Cale: depending on what you mean, many-worlds could have come before or after Copenhagen.
20:04:22 <unkanon> tg_: I didn't mean to, just that Pseudonym was saying he thinks that's right
20:04:49 <unkanon> Philippa: fair enough
20:04:50 <tg_> Cale: there's also the single-electron theory of QED (not intended to be taken seriously)
20:05:20 <tg_> http://en.wikipedia.org/wiki/One-electron_universe
20:05:23 <monochrom> single-electron theory sounds fun :)
20:05:28 <Cale> tg_: I think of Many Worlds as being in some sense the "right" way to think about things, but Copenhagen/waveform-collapse as being like the obvious simplification for the sake of computation.
20:05:46 <tg_> Cale: that's remarkably accurate for a non-physicist
20:05:54 * monochrom conjures "single-thread theory" for IO and Control.Concurrent :)
20:06:11 <tg_> Copenhagen admits that all simplifications are for the sake of computation (or experimentation)
20:06:53 <Cale> tg_: Well, I know a fair amount of the mathematics for QM, except for how to actually interpret that mathematics in physical experiments :)
20:07:10 <tg_> Cale: which mathematics?
20:07:15 <tg_> gauge fields?
20:07:34 <Cale> (My degree is in pure mathematics, and I've talked with my more applied-math friends about QM at length)
20:07:54 <Pseudonym> Back.
20:08:00 <guest2425> Cale: Why Haskell has a lot math on it??
20:08:20 <tg_> Cale: I understand pretty much everything except some of the consequences of String/M theories and some of the quantum loop gravity ideas
20:08:28 <Cale> Like, I know what L^2 spaces are, and how observables are linear maps, and how entanglement of systems is represented in tensor product spaces
20:08:34 <pozic> Does anyone have a good clue as to why large quantum computers cannot be built?
20:08:38 <tg_> guest2425: because it's foundational principles are hybrid mathematical-computational theories
20:08:54 <guest2425> ewwwww
20:08:59 <lispy> guest2425: math is good, mmmkay
20:09:00 <tg_> pozic: the difficulty of sustaining quantum entagled components together
20:09:05 <Philippa> what do you mean, hybrid? Computation /is/ maths
20:09:17 <pozic> tg_: but doesn't the universe do this all the time?
20:09:22 <guest2425> Math is good but not mixing with Haskell
20:09:23 <tg_> Philippa: I view Curry-Howard as a hybrid
20:09:26 <tg_> pozic: no
20:09:28 <Philippa> Haskell's actually a pretty low-level language. Just, low-level in terms of something like naive set theory
20:09:43 <guest2425> Philippa: I dont think so
20:09:49 <tg_> pozic: entangement, yes, but entanglement of dozens of particles, no
20:09:56 <monochrom> don't worry, you don't have to do integration by parts for haskell
20:09:57 <Philippa> (compared to, say, C being "low-level" in terms of stack-centric hardware)
20:10:00 <tg_> and certainly not in idealized states (all spin up, all spin down)
20:10:04 <pozic> tg_: how many are entangled usually? 
20:10:20 <Cale> guest2425: There's a lot of mathematics, because Haskell is designed by principled computer scientists who treat computer science like it should be as a branch of mathematics.
20:10:23 <tg_> pozic: that's sort of a meaningless question, but Cooper pairs are the commonest form of entanglement as far as I know
20:10:24 <tg_> so 2 
20:10:49 <tg_> though one can argue that the hadrons are entangled, so that would be 3 (quarks)
20:10:50 <Philippa> guest2425: computation is just "those bits of maths that can be automated". We don't even know if there /is/ any other kind that can be meaningfully carried out in this universe
20:10:54 <guest2425> Cale: I am dying because of that
20:11:01 <pozic> tg_: are those the same pairs as in chemistry?
20:11:02 <monochrom> the math used for haskell is not the math in most schools. you do not know a priori that you will dislike it.
20:11:08 <tg_> pozic: the very same
20:11:09 <Cale> guest2425: It's not really necessary to know much mathematics at all to program in Haskell.
20:11:18 <monochrom> math is broad. only a few bit is mentioned in schools.
20:11:26 <guest2425> Cale: I need to solve a kenken puzzle
20:11:27 <Cale> guest2425: It's necessary to understand how Haskell was designed in the first place, but not to use it.
20:11:34 <Cale> guest2425: Okay.
20:11:41 <Cale> guest2425: Backtracking solution?
20:11:43 <guest2425> Cale: so I need math and haskell functions for that ewwwwww
20:11:50 <guest2425> yeah Kinda
20:11:50 <Cale> guest2425: Why ew?
20:11:56 <pozic> tg_: so, you can see it as if there are long pieces of string that connect to one and the same point?
20:12:05 <Philippa> guest2425: homework, by any chance? It's about that time of year
20:12:08 <copumpkin> guest2425: you should pick a more memorable name
20:12:08 <tg_> pozic: I don't think you can picture it
20:12:12 <guest2425> huh
20:12:19 <tg_> pozic: if anything, it would be pictured as a mobius strip connecting two electrons
20:12:22 <copumpkin> Philippa: yeah, from the SF college I think
20:12:25 <Cale> guest2425: I guarantee it'll be no more troublesome mathematically than it would be in any other programming language.
20:12:25 <monochrom> kenken is a memorable name
20:12:26 <tg_> which doesn't make sense, obviously
20:12:27 <Philippa> I mean, why else would you be doing it in Haskell if it's all eww?
20:12:41 <guest2425> Cale: yeah
20:12:58 <Cale> guest2425: Moreover, Haskell gives you list comprehensions, which will be lovely here.
20:12:59 <Kaidelong> guest2425: the part of haskell that is mathematical is the same part of every other language that is mathematical
20:13:01 <pozic> tg_: well, this was just a wild guess, never mind. I will remember to talk to you once I actually know anything about physics (see you in a few years ;) )
20:13:02 <Philippa> hell, it'll be easier: you don't have to spend as long working out how to encode stuff
20:13:13 <tg_> pozic: I recommend the Susskind lecture series
20:13:17 <Philippa> Kaidelong: I wish, other languages don't half bury it when you need it :-(
20:13:22 <shachaf> Philippa: Sometimes people try new things that seem unappealing at first for the sake of variety.
20:13:22 <Cale> guest2425: and lazy evaluation makes things much simpler
20:13:22 <tg_> for rapid learning of physics
20:13:24 <monochrom> oh copumpkin is right :)
20:13:29 <pozic> tg_: Feynman not good enough?
20:13:45 <Cale> guest2425: You can make a tree consisting of all the ways to extend a partially-completed puzzle
20:13:47 <copumpkin> monochrom: needs moar magical recursion engines!
20:13:57 <tg_> pozic: ehh, Feynman is great but I am not aware of his lectures in video format (I have them in audio format and accompanying text)
20:13:57 <Cale> guest2425: and lazily search through that tree for complete solutions
20:14:06 <tg_> There are 100 or so Feynman lectures.
20:14:12 <monochrom> actually it's more like "needs moar different names for the same engine"
20:14:21 <tg_> Susskind's lectures are very recent, though, so will cover material that Feynman didn't (like Higgs, SUSY)
20:14:22 <guest2425> Cale: well I have something working already
20:14:27 <pozic> tg_: a Stanford. I love Stanford. 
20:14:30 <Cale> guest2425: (so you don't actually end up calculating the entire tree, unless you want to find *all* solutions)
20:14:31 <pozic> tg_: ah, *
20:14:44 <tg_> pozic: as I said, highly recommended. There are 6 or 7 series with ~ 10 lectures each, usually 1:45
20:14:49 <guest2425> Cale: But i need to make some changes!!! tears
20:14:59 <pozic> tg_: I saw some online courses on a different topic. They sounded like my teachers.
20:15:15 <pozic> tg_: confident, experienced, not a chance that you would outsmart them.
20:15:15 <Pseudonym> tg_: So how much do they assume?
20:15:21 <Kaidelong> data BackTrackerTree a = Empty | Leaf a | Subcomputations [BackTrackerTree a]
20:15:25 <Cale> guest2425: Come on, tighten up, it's not that bad :)
20:15:44 <Philippa> shachaf: most of the time they talk about it a little differently when they're doing it though :-)
20:15:45 <pozic> tg_: not all of my teachers were like that obviously.
20:15:51 <pozic> tg_: not all of my teachers were like that obviously.
20:15:52 <tg_> pozic: not so with Susskind, he is like Feynman in that he's a good communicator but not a sueprgenius
20:16:10 <tg_> Pseudonym: he assumes you can do calculus
20:16:10 <copumpkin> Kaidelong: what's the difference between Empty and Subcomputations [] ?
20:16:39 <pozic> I never experienced that idea of equal footing until I went to university. 
20:16:47 <Kaidelong> copumpkin: that will suffice
20:17:01 <Cale> Probably writing a Haskell program to do it is less tedious than solving most Kenken puzzles :)
20:17:55 <Kaidelong> evalBacktrackerTree (Leaf a) = return a; evalBacktrackerTree (Subcomputations as) = msum (map evalBacktrackerTree as)
20:18:18 <pozic> tg_: can I also get them without iTunes?
20:18:22 <Kaidelong> there you have a way to define a (depth-first) backtracking algorithm
20:19:48 <tg_> pozic: Yep. All of them except for the very last one are on youtube
20:20:49 <Cookies> Did you guys know that Obama is black?
20:20:57 <Kaidelong> is he?
20:20:58 <pozic> tg_: is there also a way to get them in order? ;)
20:21:10 <pozic> Cookies: everyone knows he is an alien. 
20:21:14 <Kaidelong> wrong channel for that I think
20:21:19 <Cookies> Did you guys know that Obama is black?
20:21:24 --- mode: ChanServ set +o Cale
20:21:28 <pozic> Ban in 3,2,1.
20:21:39 * kmc was unaware
20:21:44 --- mode: Cale set -o Cale
20:23:54 <Cookies> I hate my life :(
20:24:09 <guest2425> Cale: But I am tired of this puzzle
20:24:13 <guest2425> already
20:24:18 <Kaidelong> which puzzle is this?
20:24:18 <Cale> Cookies: This channel is for discussion of the functional programming language Haskell.
20:24:19 <pozic> tg_: got it already.
20:24:23 <Cookies> I hate my life :(
20:24:29 --- mode: ChanServ set +o Cale
20:24:38 <Genocide> What's haskell?
20:24:46 <tg_> pozic: sorry for the slow response, in PM
20:24:53 <Cookies> I hate my life :(
20:24:57 <Kaidelong> Cale: just make ChanServ ban automatically. FreeNode has that, right?
20:24:59 <Cale> okay, enough
20:25:04 <unkanon> guest2425: I for one thank you for mentioning it, I think I'll give them a try, I got tired of sudoku pretty fast
20:25:05 --- mode: Cale set +b *!*@c-66-177-245-64.hsd1.fl.comcast.net
20:25:06 --- kick: Cookies was kicked by Cale (Cookies)
20:25:15 --- mode: Cale set -o Cale
20:25:26 <guest2425> unkanon: I have some code
20:25:41 <guest2425> unkanon: I can share that with you
20:25:42 <unkanon> Kaidelong: the puzzle s kenken
20:25:47 <Cale> Genocide: It's a nice general purpose functional programming language (how did you get here if you don't know?) :)
20:25:52 <unkanon> guest2425: code that solves the puzzle?
20:25:57 <guest2425> yes
20:26:14 <guest2425> unkanon: Yes, but I need to implement something else
20:26:18 <unkanon> guest2425: why don't you pastie it on hpaste.org or something?
20:26:27 <guest2425> unkanon: ok 
20:26:30 <unkanon> does it solve by brute force?
20:26:37 <pozic> tg_: is there any point in taking classical mechanics before quantum mechanics? I have had high school physics and some calculus. 
20:26:38 <guest2425> unkanon: kinda
20:27:36 <Saizan> is there a difference between "entangled" and "quantum entangled" in quantum physiscs? because afaiu when you observe a system you end up entangled with it, but tg_ was saying it's hard to have even small numbers of particles entangled together
20:27:49 <tg_> pozic: I watched classical *after* quantum, and I found it interesting
20:28:25 <tg_> Saizan: entanglement and quantum entanglement are the same thing
20:28:38 <tg_> and it has to do with the wavefunction of a "particle" being in a bound state with another paticle
20:28:41 <tg_> particle
20:29:48 <pozic> If I understood anything from the lesson by Feynman, it was that what normal people think of as particles has nothing to do anymore with the physical concept. 
20:30:03 <pozic> They can just as well call them warm fuzzy thingies. 
20:30:17 <monochrom> we have warm fuzzy thingies too
20:30:30 <pozic> I know, that's why I picked those words. 
20:30:38 <monochrom> nice
20:30:45 <Saizan> yeah, basically particles don't exist, they are just spikes in the fields
20:31:05 <tg_> Saizan: the idea that our experiments in physics are achieving entanglement with the physics covered is a stretch
20:31:13 <Kaidelong> has anyone implemented a stream-bloom-filter like thing for haskell, and I'm just missing seeming it in hackage? and if not, (where) can I find hash functions in hackage?
20:31:14 <tg_> for most physical experiments that laypeople are exposed to
20:31:26 <Kaidelong> well I can in bloomfilter I suppose
20:31:32 <pozic> Kaidelong: a bloom filter is on Haskell.
20:31:42 <Kaidelong> pozic: but it's not a stream bloom filter
20:31:46 <tg_> brb
20:31:51 <pozic> Kaidelong: what's the difference?
20:32:09 <Kaidelong> pozic: less false positivies but you get false negatives
20:32:39 <pozic> Kaidelong: you mean Stable bloom filters?
20:33:03 <Kaidelong> pozic: you can implement a stable bloom filter using the technique I think, so yes
20:33:20 <pozic> Kaidelong: I never heard of them before, but I think you would have to implement that yourself.
20:33:27 <Kaidelong> stable is where the ratio of 0s to 1s doesn't ever go lower than a certain point, right?
20:33:28 <pozic> Kaidelong: or just find a C library.
20:33:43 <Kaidelong> stable would be fine
20:34:00 <pozic> Kaidelong: it might be on Hackage, but I don't know of it.
20:34:27 <Kaidelong> okay, well I can't find it, so I'm going to assume it isn't there then
20:34:27 <pozic> This shows btw, why a dependently typed language is nice.
20:34:44 <pozic> Questions like this could then be asked to a machine instead.
20:34:58 <pozic> With 100% correct answers in return.
20:35:45 <Kaidelong> pozic: I'm specifically interested in space efficiency here, unless you're thinking of me doing something like hoogle instead of asking here with a very specific dependent type
20:37:22 <pozic> Kaidelong: yes, I understand, but I don't have a quick answer for you.
20:37:45 <Kaidelong> pozic: you did! you gave me the answer I was expecting anyway
20:37:51 <Kaidelong> now to look for hash functions =)
20:38:06 <Kaidelong> could just use the ones already in bloomfilter I suppose
20:38:19 <pozic> Kaidelong: do you know of a way to download Youtube playlists? 
20:38:33 <pozic> Kaidelong: for all the videos in the playlist, download video. 
20:38:57 <Kaidelong> let me see if I still have it installed
20:39:21 <djahandarie> ezyang, you need to make sure your stuff gets on /r/haskell
20:39:44 <djahandarie> ezyang, I missed the last few posts because they weren't there :(
20:40:28 <pozic> Never mind, it seems the youtube-dl Gods already implemented it. 
20:40:58 <Kaidelong> pozic: I had a tool that did that as an add-on to firefox but it seems I got rid of it during a firefox performance related purge
20:41:39 <pozic> Except they didn't implement parallelism.
20:41:45 <pozic> ....Python....
20:41:55 <pozic> ><
20:42:05 <Kaidelong> python doesn't do concurrent IO?
20:42:16 <Kaidelong> well
20:42:19 <Kaidelong> asynchronous IO
20:42:23 <pozic> Kaidelong: python does, but the barrier to use it is apparently to high. 
20:42:23 <Kaidelong> more precisely
20:42:34 <pozic> Kaidelong: which in the end is all that matters.
20:42:46 <pozic> Kaidelong: I wrote a similar program, that doesn't have this limitation.
20:43:36 <guest2425> Cale: I need to write that it simply tries all permutations until it finds one that satisfies the cages. This is what I have http://pastebin.com/4t0ageB5
20:44:09 <ManateeLazyCat> I perhaps will failed on my interview, my spoke English is very bad, anyway, i will try ... if it doesn't work out at least i've tried....
20:46:49 <pozic> ManateeLazyCat: there are ways to improve your English that do not involve going to e.g. England. 
20:47:10 <Saizan> tg_: so how is Cale's description of the Copenhagen interpretation above accurate? "If all the observers of the system we care about are /entangled/ with the system in some way, .."
20:47:33 <Saizan> s/of the system//
20:47:43 <ManateeLazyCat> I will found my Chinese friend help me, i have phone interview at 5:15pm today
20:47:51 <ManateeLazyCat> 12:47 pm now. :)
20:47:54 <pozic> ManateeLazyCat: which company?
20:48:16 <ManateeLazyCat> pozic: Today is "Jane Street", next week is Google.
20:48:53 <pozic> ManateeLazyCat: did you complete your studies or something like that?
20:50:01 <Kaidelong> comprehension of a language is much easier than using it
20:50:21 <Cale> Saizan: I can try to elaborate on it, though I missed the intervening discussion.
20:50:34 <pozic> Kaidelong: using it correctly is, yes ;)
20:51:18 <pozic> Kaidelong: turning sounds into words can be quite hard, though. 
20:51:21 <Saizan> Cale: the intervening discussion stated that it's hard to keep more than an handful of particles entangled together, afaiu, and that's what puzzling me :)
20:51:27 <pozic> Kaidelong: reading is fairly easy.
20:51:46 <Kaidelong> pozic: there are languages where one is intelligible to the other but not vice versa
20:51:50 <pozic> Kaidelong: for most EU languages, at least.
20:52:21 <Cale> I don't think it's difficult at all to have quantum systems get entangled with each other. Maybe it's difficult for them to be entangled in the way that you want them to be.
20:52:22 <ManateeLazyCat> I will found some Chinese friend help me improve my Spoken English... 
20:53:02 <Kaidelong> ManateeLazyCat: the website I linked you in the PM will help you find people willing to tutor you for free or for pay
20:53:23 <pozic> ManateeLazyCat: ##english is also free.
20:53:41 <ManateeLazyCat> pozic: I mean spoken English, i haven't any problem with written English.
20:53:55 <pozic> ManateeLazyCat: you also have a problem with written English. 
20:54:01 <monochrom> hehe
20:54:02 <Kaidelong> ManateeLazyCat: it also will give you exercises and ask English speakers to rate and comment on your submissions
20:54:04 <ManateeLazyCat> pozic: But not too much. :)
20:54:05 <pozic> ManateeLazyCat: but not so large that people cannot understand you.
20:54:18 <Cale> Basically, if you have two quantum systems whose states separately are measured in spaces A and B, then the state of the composite system, allowing them to interact, is something in A (x) B (where (x) means tensor product)
20:54:19 <ManateeLazyCat> pozic: You got it. :)
23:04:59 --- topic: '["GHC 7 is out: http://is.gd/hb8vE", "Haskell Platform 2010.2: http://is.gd/dCGPn", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
23:04:59 --- topic: set by monochrom!trebla@toronto-hs-216-138-220-146.s-ip.magma.ca on [Wed Nov 24 17:56:54 2010]
23:04:59 --- names: list (clog Dawgmatix Chaze xinming crutcher PhilRod_ Snark cads Biggles qhe rothwell pozic int80_h freiksenet m3ga _nickel scm Enigmagic mmaruseacph2 ramkrsna lsthemes dreixel thou magicman faluf jethomas horms ablokzijl jsgf Philonous__ dankna kamatsu jrib ambroff applicative Jafet Axman6 kfish otto_s novas0x2a Genocide KristineB haskeller dimmy Hugglesworth khiroc smadge_ andyjgill Zeiris xittenn ceii ceii_ abiraja eb4890 hotaru2k3 ManateeLazyCat Pseudonym joe6)
23:04:59 --- names: list (perspectival Gracenotes fengshaun ousado antimatroid sidek papermachine_ Philippa danharaj Adamant flippo ormaaj trin_cz QinGW copumpkin hzh_ mm_freak cubi [df] siracusa devinus theorbtwo augur miclorb_ arnihermann Cobra_ ortmage Nereid djl damex ezyang AtnNn sohum njoubert ve Colours FauxFaux nominolo ExtremeTomato jcapper alexusraci SyntaxNinja Counter-Strike Yvemath yrlnry srobertson Eridius ksf tonkman lambdabot thetallguy1 drbean ChongLi bos31337 perlite)
23:04:59 --- names: list (sm sciolizer_ younder tensorpudding path[l] lyn prokos cheater99 ymasory mvid amiri MacMagnus Torrieri siplux tibbe ezrakilty mjrosenb birkenfeld shortcircuit Muad_Dibber svk_ hyko- hellige alexsdutton mercury^_ Vq Itkovian EvanCarroll krainboltgreene resistor etpace lostman__ zax xxpor dRbiG JaffaCake1 Amadiro jimmyjazz14 __nickm__1 tomaha_ Maxdamantus benc ddarius dcoutts_ s76__ mauke fpletz Utkarsh preflex SsvRrwQ zenzike gienah insomniaSalt hackagebot)
23:04:59 --- names: list (sShintah Nshag liyang min jedai ngochai winxordie MoALTz waern JuanDaugherty Sunhay Dashkal olsner itsjar mwc kermit hamishmack mun schroedinbug _janne saiam ion rndm Obfuscate ilab snorble clanehin hc Khisanth Draconx dons twaffle dino- pikhq thetallguy maurer_ hgolden borism evildalton em zomg majoh pix| davidL abbe hiredman Unforgivable bbee inimino cognominal ddilinger kolmodin _br_ Miciah tab hvr_ bblum int-e snr SecretAgent regalia_ brailsmt_ iFire`)
23:04:59 --- names: list (duairc_ steve_himself Jaak jvogel_ tridactyla andern jao ibt dual weebl helgikrs iveqy sipa earthy CindyLinz muep ski nchaimov cibs dcolish Cthulhon dfeuer wto anders^^ blackdog mgsloan danblick lispy palmje parcs andersk sgtarr geekounet remy_o ville arkx arcatan Fingerzam klugez akosch dmwit Fullma Draconx|Laptop xarch gereedy sonnym saccade henr_k jmv_ meanburrito920 eyck Baughn saurik adimit eregon cozmic sophacles nimred DJ_Ice wagle moozilla pastorn)
23:04:59 --- names: list (necroforest Martty electrogeek `0660 jbauman ricky xplat knobo Saizan kadoban brisbin Igloo Berengal tswett suiside helgim_ jomat rdd thorkilnaur Innominate Raku^ flori polarina edenc Twey felipe_ dMazz m4thrick onteria|i7 comex jkimball4 cYmen willb eno gbeshers BMeph sasha__ alip tg_ Ornedan ksandstr xmikedavis Zol cizra Cale yiannis_t ben Aestas shepheb sshc Sisu andrewsw tiz luite Paradox924X gju_ timchen1` The_third_man adnap_ bqf rizzen`` tobiw dibblego)
23:04:59 --- names: list (niko shutdown_-h_now srcerer entrosca MasseR frerich quicksilver cyanoacry Guest32383 cathper tmuki TML SimonRC Mitar harlekin Botje jrockway duckinator Razz idoru skaar slabanja kalven thoughtpolice dropdrive Gilly KaneTW tafryn quaestor muhtimin mietek untwisted encryptio milli Bleadof bezik opqdonut exDM69 deadguys pantsd kwuxalot ahihi Hunner sproingie McManiaC Gabbie kosmikus inr_ dumael Blub\0 norm2782 david` zygoloid aiko_ dax jml dorkitude Firegolfer)
23:04:59 --- names: list (nlogax aj| danderson byorgey burp emias tamiko pigoz CosmicRay taruti tomaw guybrush @ChanServ aempirei aavogt elliottcable davean shawn stroan _2x2l lantti Scala jmcarthur jyper ahf jvoorhis welterde arkonten yahooooo Belgarion0 jrk_ d-snp FDFlock alios wires Cerise Alan Jiten npouillard Guest35776 jamwt scree marienz ido solarus obraun jlouis DrSyzygy jql deavid newsham jdsc_ HalfWayM1n danr aristid sid3k sleepynate OnionKnight BrianHV Vulpyne_ drhodes)
23:04:59 --- names: list (noddy2000 pettter_ tessier_ samulihs_ canvon ray guerrill1 cynick dm120769 Deewiant solidsnack endpoint_david dqd fnordus zakwilson mornfall idnar DustyDingo johs jayne alpounet Reisen dilinger_ mlh Boney Nanar aleator_ defn boyscared rokoteko dimensia gds ibid koala_man jd10 cpa tromp_ orclev blackrain Lemmih StoneToad absentia robinsmidsrod dom96 ClaudiusMaximus koninkje_away bolmar_ osfameron BONUS ede ath bd_ ninegrid companion_cube allbery_b joni6128)
23:04:59 --- names: list (nornagon djahandarie semifor_ bremner edwtjo stepnem profmakx integral franksh_ ziman fabjan_ Sonicvan1Jr onteria Valodim erk_ cjay dionoea_ And[y] netcat jix noj Liskni_si jb55 finnomenon qebab ToRA danly fihi09``` Xorlev lalle freedrull Raynes __marius__ caligula pygmalion mee shachaf nothingmuch liesen nniro joeytwiddle kurganme Rooz mafs mortberg hirsch Starfire [swift] jon_of_arc slaye Ke trez mrshoe benmachine mrd mux Laney yurug ixzkn Spacejoker mattam)
23:04:59 --- names: list (bartavelle waterlaz rks monochrom chromakode levitation_ alexbobP mindwarp dixie nostrand mikeg proq Zao ps-auxw jonafan gdsx jpatota Veinor ernst waern_ ivan Janno path Vorpal endojelly Eelis djfm jkr flux epmf sbok AnAdorableNick kaol kniu chitragupt derekwright sajkr)
23:09:22 <cads> hey monochrom, may I ask you a question in private?
23:10:09 <shachaf> Chaze: Why? It describes exactly what you want to do.
23:10:49 <Chaze> shachaf: i always feel like lambda expressions are a last resort of haskell syntax
23:11:12 <shachaf> Chaze: Three-element tuples are a last resort.
23:14:53 <Chaze> something else: shouldn't there be an operator that makes an arrow work on both elements of a 2-tuple?
23:15:27 <Chaze> like (\f -> f *** f)
23:15:57 <Jafet> join (***)
23:16:35 <Chaze> Jafet: thanks. there's some command for lambdabot to tell me where 'join' is, right?
23:16:47 <Chaze> :t join
23:16:48 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
23:17:21 <shachaf> @index join
23:17:22 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
23:17:23 <Jafet> For general arrows you can write "both", or whatever you want to call it
23:17:31 <Jafet> @pl (\f -> f *** f)
23:17:32 <lambdabot> join (***)
23:18:04 <Chaze> what's @pl ?
23:18:33 <shachaf> @help pl
23:18:33 <lambdabot> pointless <expr>. Play with pointfree code.
23:26:23 <Jonno_FTW> what does this symbol represent: _|_ ?
23:26:49 <shachaf> @wiki Bottom
23:26:49 <lambdabot> http://www.haskell.org/haskellwiki/Bottom
23:26:56 <dblhelix> Jonno_FTW: undefined
23:27:02 <dblhelix> @type undefined
23:27:03 <lambdabot> forall a. a
23:27:27 <dblhelix> Jonno_FTW: it's considered equivalent to a failing or nonterminating computation
23:29:39 <Jonno_FTW> ok
23:30:00 <Philippa> the symbol chosen because it's at the bottom of an ordering by information context
23:30:28 <Philippa> _|_ < (_|_,_|_) < (1,_|_) or (_|_,1) < (1,1), for example
23:34:57 <augur> Philippa!
23:34:58 <augur> hey
23:37:51 <Philippa> hey
23:37:54 <Philippa> I shouldn't be up now :-(
23:38:08 <Philippa> you getting on okay with monad transformers now?
23:42:37 <Gracenotes> wikibooks has a good article about type lattices and denotational semantics
23:43:14 <Gracenotes> http://en.wikibooks.org/wiki/Haskell/Denotational_semantics
23:43:29 <Gracenotes> lots of bottom everywhar
23:45:37 <Gracenotes> er value lattices
23:46:28 <Jonno_FTW> @src zipWith
23:46:28 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
23:46:28 <lambdabot> zipWith _ _      _      = []
23:50:23 <adnap_> when you have a generic list of lists, is the generic name xss or xxs?
23:52:49 <Jafet> One xs, two xss
23:52:53 <Gracenotes> I would use xss
23:53:00 <Jafet> (xses?)
23:53:14 <Jafet> (That seems xsessive.)
23:53:31 <Gracenotes> if you look at http://code.haskell.org/lambdabot/State/source .. has two xxs and one xss
23:53:40 <Gracenotes> however xss is used as an @ name
23:53:53 <Gracenotes> I mean, er, switch xss and xxs in my previous two statements
23:54:25 <adnap_> so, I guess there is no consensus?
23:54:42 <Gracenotes> xss seems right to me
23:54:56 <adnap_> yeah, that's what I thought.  Like, xs's
23:55:42 <Gracenotes> well xs's is also a valid identifier :)
23:56:55 <Jafet> If names mattered, we'd be using listOfElements and listOfListsOfElements, anyway
