00:00:45 <j-invariant> all searchers for 'category theory' + programming etc.. link to haskell
00:00:58 <Axman6> of course
00:01:06 <Makoryu> ...Or do they?
00:01:35 <aefjt> Google doesn't search the future
00:03:11 <j-invariant> http://mathoverflow.net/questions/3721/programming-languages-based-on-category-theory haskell is #1 language tha tuses category theory
00:03:28 <Philippa_> shouldn't be all, but I'd expect it to be most because it's the #1 language in which category theory is used
00:03:40 <aefjt> #1 by what measure?
00:03:56 <boegel> aefjt: any measure ;)
00:04:24 <aefjt> Oh, stop being dense
00:04:31 * hackagebot digestive-functors 0.0.2.1 - A general way to consume input using applicative functors  http://hackage.haskell.org/package/digestive-functors-0.0.2.1 (JasperVanDerJeugt)
00:05:15 <Philippa_> j-invariant: it's fair to say that most languages that are better at it than Haskell for a long time will be "better Haskells", for a variety of values of better
00:05:26 <Philippa_> not that it isn't possible to build a language around a categorical design
00:05:54 <Philippa_> I think category theory's a natural thing to start playing with for approximately the same way set theory and things with v.simple embeddings in it were previously natural things
00:06:08 <Philippa_> the difference being that category theory's a lot better at talking about 'interface'
00:06:13 <Axman6> jaspervdj: *poke*
00:06:19 <huawei> /huawei waves
00:06:21 <j-invariant> Philippa_: I see that
00:06:26 <Philippa_> in that sense, it's the 'natural' maths of software engineering
00:06:28 <huawei> hei guys
00:06:50 <Philippa_> you get results that don't fall over the moment you realise you're not actually dealing with sets :-)
00:07:22 <Philippa_> not to mention some useful tools for trying to state in what way you're "close enough" to some structure without being it
00:07:45 <jaspervdj> Axman6: *poke back*
00:07:53 <jaspervdj> Axman6: thanks for the patch btw!
00:08:31 <Axman6> no worries :)
00:08:59 <Axman6> i got all excited when i saw you just released a new version, but then realised it didn't have my patch :P
00:09:14 <Axman6> i'm about to send you a new pull request for blaze-html
00:09:51 <jaspervdj> Axman6: it has your patch I think?
00:09:58 <jaspervdj> that's why I updated
00:10:19 <Axman6> oh, i'll check it out, i didn't see it in the log, but i didn't look to hard
00:10:45 <Axman6> urgh, would help if i were looking at the log for digestive-functors and not blaze-html ;)
00:10:54 <jaspervdj> haha :-P
00:12:28 <Axman6> pew! new pull request
00:18:35 * hackagebot blaze-html 0.3.2.1 - A blazingly fast HTML combinator library.  http://hackage.haskell.org/package/blaze-html-0.3.2.1 (JasperVanDerJeugt)
00:18:38 <jaspervdj> Axman6: ↑
00:19:08 <Axman6> thanks :D
00:35:38 <13WAAXQGV> hey
00:36:38 <13WAAXQGV> when I have a type X = (Int,String,Double) how do I get the String if I have a "huge" of type X
00:37:12 <13WAAXQGV> do I make a getter? (_,string,_) = string ?
00:38:36 <abbe> yes, pattern matching
00:39:57 <13WAAXQGV> ok pattern matching can be done in many ways, is a getter still the best way?
00:40:03 <13WAAXQGV> or do I use a where?
00:40:10 <13WAAXQGV> "where" operator
00:41:17 <Zao> let (_,foo,_,_,_) = anX
00:41:28 <Zao> Or define a function to extract a field.
00:41:59 <Zao> Or consider making it a type, like   data X = X { asdf :: Int, foo :: String, bar :: Double }
00:42:08 <Zao> And then you can simply   foo anX
00:43:23 <13WAAXQGV> hmm ok
00:44:01 <Zao> As for your getter, where you define it is up to you. If it's only meaningful locally, use a let or a where to define it.
00:44:09 <Zao> If it's useful elsewhere, make it a top-level fun.
00:48:16 <13WAAXQGV> top level fun  xD
00:56:05 <13WAAXQGV> Zao: http://hpaste.org/paste/42552/quarto_annotation#p42616 i am having some difficulties
00:56:25 <13WAAXQGV> its the second paste and line 136
00:58:12 <Zao> Line numbers do not match up to lines in this browser.
00:58:26 * Zao shakes a fist in the general direction of hpaste.
00:59:05 <tomh1> Is there a way to get a string from an IO String inside where bindings, something like where z <- y
01:00:58 <Kaidelong> tomh1: you could put the IO expression in a where binding but you will have to bind it somehow in the actual computation using >>= or do notation
01:01:25 <Zao> tomh1: Like   where  z <- y  directly?
01:01:44 <Zao> I'd say that it needs to be in a do block, which implies being bound to a function/var.
01:01:52 <Kaidelong> z <- y translates to y >>= \z ->
01:02:45 <tomh1> ok, I was trying to make a function which takes some stuff, including a IO action and wanted to save repetition with guards, but I'll do it the long way round for now
01:03:02 <Kaidelong> tomh1: make a PURE function that uses the guards
01:03:10 <Kaidelong> THEN use >>= to send the IO stuff into it
01:03:24 <Kaidelong> or you could actually put the pure function in the where
01:03:27 <Kaidelong> IE:
01:03:52 <tomh1> OK, I see I think. Minimise the pure co
01:03:53 <tomh1> 
01:03:59 <tomh1> minimise the IO code.
01:04:12 <tomh1> and separate it
01:04:45 <Kaidelong> isHello = getStrLn >>= isHello' where isHello' =  
01:05:08 <Kaidelong> isHello = getStrLn >>= isHello' where isHello' =  \x-> case x of { "Hello" -> True; _ -> False }
01:05:20 <Kaidelong> readLine
01:05:21 <Kaidelong> sorry
01:05:26 <Kaidelong> :t readLine
01:05:27 <lambdabot> Not in scope: `readLine'
01:05:32 <Kaidelong> err, I forget
01:05:36 <Kaidelong> is late
01:05:41 <Kaidelong> :t getLine
01:05:42 <lambdabot> IO String
01:05:44 <Kaidelong> there we go
01:05:52 <tomh1> Thanks
01:16:03 <nmkolev> :t map
01:16:04 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
01:16:55 <Kaidelong> :t fmap
01:16:56 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
01:18:29 <shapr> :t nmap
01:18:30 <lambdabot> Not in scope: `nmap'
01:20:33 <dibblego> what was the quip by SPJ regarding CPS?
01:21:18 <ddarius> SPJ made a quip regarding CPS?
01:21:38 <dibblego> maybe my memory is broken
01:25:15 <ddarius> @quote spj cps
01:25:16 <lambdabot> No quotes match. I've seen penguins that can type better than that.
01:30:17 <Jafet> @let fap :: Functor f => f (a -> b) -> f a -> f b; fap = (<*>)
01:30:18 <lambdabot>  <local>:4:52:
01:30:18 <lambdabot>      Could not deduce (Applicative f) from the context (Functo...
01:32:45 <ddarius> So my cache oblivious non-indexed nested loop join is twice as fast as the simple cache-unaware version (now that I switch to it for "small" cardinalities), but only if the elements are "large" (in this case ~4kb).  For elements like Ints, it's about half-again as long running.
01:33:27 <ddarius> It potentially gets faster for very large cardinalities in the latter case, but those would have insanely long running times (time is quadratic), so aren't particularly relevant.
01:34:04 <ddarius> Note that the benefits are had even though the large elements are boxed.
01:35:31 <Kaidelong> what'd be an example of a functor that is not an applicative functor?
01:36:05 <Kaidelong> Either?
01:36:19 <ddarius> Either e is a monad.
01:36:23 <Kaidelong> hmm
01:36:28 <Kaidelong> then it is also an applicative functor
01:37:09 <ddarius> (,) a is not an applicative functor except when a is a monoid.
01:38:08 <Jafet> @src Applicative
01:38:08 <lambdabot> class Functor f => Applicative f where
01:38:08 <lambdabot>     pure  :: a -> f a
01:38:08 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
01:38:42 <Jafet> Looks clear enough from here
01:41:28 <Jafet> ddarius: sql database in haskell?
02:05:08 <rajeshsr> hi all
02:05:28 <rajeshsr> I subscribe to Haskell-cafe. But I get a digest message every time!
02:05:45 <rajeshsr> I would like to know what it takes to get a threaded conversational view!
02:06:03 <Botje> have you logged in and looked around yet?
02:06:19 <Botje> normally digests are optional
02:06:35 <Zao> rajeshsr: Log into mailman and change your settings?
02:06:45 <Zao> http://haskell.org/mailman/listinfo/haskell-cafe
02:07:00 <rajeshsr> Zao, I checked yesterday. I don't think there was anything like "Send digest only"...
02:09:48 <Zao> rajeshsr: |Set Digest Mode|
02:10:06 <rajeshsr> Zao, ha!! So stupid of me!! 
02:10:08 <rajeshsr> thanks!!
02:25:41 <pozic> Is x `elem` [C1, C2] rewritten internally to something not using elem? 
02:26:55 <ion> @src elem
02:26:55 <lambdabot> elem x    =  any (== x)
02:30:52 <remy_o> @src any
02:30:52 <lambdabot> any p =  or . map p
02:31:01 <remy_o> @src or
02:31:01 <lambdabot> or    =  foldr (||) False
02:31:16 <silver> @src (.)
02:31:17 <lambdabot> (f . g) x = f (g x)
02:31:17 <lambdabot> NB: In lambdabot,  (.) = fmap
02:33:41 <remy_o> @pl \x l -> foldr (\y b -> b || (y == x)) False l
02:33:42 <lambdabot> flip foldr False . (flip (||) .) . (==)
02:41:03 <pozic> Did anyone implement some TH to get real multi-line strings? That is, when you paste a piece of text with newlines that it defines a \n?
02:41:36 <pozic> I know I can use unlines, but that means I need to do an operation to my data to get test data. 
02:41:52 <pozic> I can also read it from a file, but I still need to do more work than really needed.
02:42:23 <mm_freak> pozic: that would be interesting for ByteString or Text, but not so much for String, because 'unlines' likely doesn't impact performance at all
02:42:41 <mm_freak> i think it should be easy to write a corresponding quasiquoter
02:42:48 <mm_freak> 'hereString' or something
02:43:34 <pozic> mm_freak: I don't care about performance in this case, just programmer performance.
02:44:16 <pozic> mm_freak: use case: print a pretty printed version of some data structure, copy it in a source file, parse it to a data structure again. 
02:44:51 <pozic> mm_freak: the pretty printed version (as shown on the console) provides more information than just a one dimensional string.
02:45:22 <mm_freak> well, generally if you need to put large strings into source code, then your performance problem is somewhere else…  code should be dynamic
02:45:35 <pozic> mm_freak: I have no performance problem.
02:45:58 <pozic> mm_freak: I just asked the elem question, because I would like to know whether such obvious optimisations are done. 
02:46:01 <mm_freak> but to answer your question, it should be very easy to write a quasiquoter…  you can look into the 'hamlet' package for inspiration
02:46:09 <pozic> mm_freak: thanks
02:46:33 <mm_freak> another possibility is to put the string into an object file somehow and just link it
02:46:40 <mm_freak> if you really want to hardcode it, that is
02:47:27 <pozic> mm_freak: for large strings that's useful, I know.
02:48:07 <pozic> Still, it's a limitation of a Haskell implementation that large strings are not fast in source code files. 
02:50:05 <mm_freak> pozic: that's mainly a limitation of String, not of haskell
02:50:26 <mm_freak> you can use the OverloadedStrings extension to write literal ByteString constants
03:01:12 <lispy> "foo\nblah" and "foo  garbage\nblah" are my inputs.  Trying to use parsec here (but failing) to get both cases to parse "foo" and "blah" separately and ignore garbage and space.
03:01:36 <lispy> manyTill anyChar (try space) -- almost works
03:02:36 <lispy> basically, I want to parse foo upto the first space, then ignore all till the newline
03:02:45 <lispy> if newline is the first character after foo, I can just stop
03:04:54 <Igloo> Sounds like you want something like many (satisfy (not isSpace)); many (satisfy (/= '\n')); char '\n'
03:05:49 <Igloo> I guess manyTill is probably a nicer wayof doing the last 2, I'm not too familiar with the parsec API OTTOMH
03:07:01 <lispy> The first one should be the same as, manyTill anyChar (try space), I think
03:08:14 <lispy> I wonder if I should just parse "foo garbage" and then use takeWhile (not . isSpace) on it
03:08:47 <j-invariant> > map head . words . line $ "foo  garbage\nblah"
03:08:48 <lambdabot>   Not in scope: `line'
03:10:09 <lispy> the takeWhile trick works.  I'll leave it at that
03:11:41 <paolino> @seen copumpkin
03:11:41 <preflex>  copumpkin was last seen on #haskell 8 hours, 31 minutes and 6 seconds ago, saying: @src filterM
03:11:41 <lambdabot> Unknown command, try @list
03:11:55 <rjo> *Main> parse asdf "" "  fasdfasdf  \n  adsf"
03:11:55 <rjo> Right "fasdfasdf"
03:12:06 <rjo> asdf = do spaces; value <- many1 alphaNum; many (noneOf "\n"); return value
03:12:16 <rjo> well, maybe you got better solution already
03:12:23 <blackdog> @pl square = \x -> x*x
03:12:24 <lambdabot> square = join (*)
03:12:56 <blackdog> what's this join from? square = Control.Monad.join (*) doesn't seem to give me a squaring function...
03:13:10 <paolino> :t join
03:13:11 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
03:13:39 <paolino> from instance Monad (a ->)
03:13:51 <blackdog> @eval (join (*)) 2
03:14:28 <paolino> > :t join (*)
03:14:30 <lambdabot>   <no location info>: parse error on input `:'
03:14:38 <paolino> @type join (*)
03:14:39 <lambdabot> forall a. (Num a) => a -> a
03:14:40 <blackdog> > (join (*)) 2
03:14:41 <lambdabot>   4
03:14:42 <lispy> Now what I have is a program that takes input like /* @snippet-start example1.c */\nsome example code\n/* @snippet-end */, and extracts the snippet to the file example1.c.  It doesn't make any assumptions about comment syntax other than assuming the start/end lines are by themselves
03:14:54 <blackdog> hrm. what does lambdabot load that a standard ghci doesn't?
03:15:11 <lispy> blackdog: lots of stuff actually
03:15:28 <paolino> Control.Monad.Instances I guess
03:15:49 <paolino> ghc-7.0
03:15:55 <blackdog> ah, there we are
03:15:56 <blackdog> cheers
03:15:58 <lispy> my next plan is to use this extraction tool to split my code into snippets that I can load into latex files
03:16:07 <paolino> in 6.12 it should work
03:16:07 <lispy> inside of \verbatiminput
03:21:50 <clklein> Is there a way to capture the output of an IO action as a String?
03:22:19 <clklein> i.e., a function with type IO () -> IO String maybe?
03:22:38 <remy_o> what sort of output ? 
03:22:49 <sipa> you mean what it prints to standard ouput?
03:22:59 <clklein> yes, sorry
03:23:09 <remy_o> you can get standard input, the standard output of an external process...
03:23:11 <sipa> well, just use show instead of putStr
03:23:28 <sipa> IO objects are meant to be non-inspectable
03:23:28 <clklein> The function that's doing the printing isn't under my control.
03:23:54 <clklein> (It's quickCheck.)
03:24:05 <Botje> you could do weird things with pipes
03:24:36 <monadic_kid> does fclabels support record projections? i mean not just working with one (nested) field at a time
03:24:54 <remy_o> clklein: rewrite it to get its output
03:25:10 <clklein> remy_o: Rewrite the quickCheck function?
03:25:44 <ddarius> If things were more capability structured this would be trivial.
03:28:25 <clklein> Botje: Can you point me to the relevant docs?
03:28:27 <monadic_kid> okay it is possible to write projections but it looks like a lot of more work than just using de-constructing pattern but the former is immune to field re-ordering 
03:29:19 <Botje> clklein: err, you'd want to redirect stdout to a pipe and read from it afterwards
03:31:36 <Botje> clklein: System.Process does the nasty bits in C, apparently :(
03:32:14 <clklein> Botje: Ah, so create the pipe and use soemthing like dup
03:32:28 <Botje> yeah
03:32:59 <clklein> I'll try that. Thanks!
03:36:35 <rjo> I have "P.makeTokenParser haskellDef"
03:36:56 <rjo> I do want to find options and documentation for languageDefs
03:37:33 <rjo> am I blind or should this be in Hackage doc
03:37:52 <ivanm> hmmm?
03:38:26 <rjo> oh, sorry
03:38:28 <rjo> I found it
03:38:30 <adu> rjo: did you find it?
03:39:13 <adu> I don't like the languageDef thing... to restrictive
03:39:36 <Jafet> clklein: IO does not mean "print some text", IO means IO
03:40:04 <rjo> now I am trying to parse a float value
03:40:40 <Jafet> IO covers a wide variety of effects such as using an IORef, connecting to the internet, launching missiles
03:40:44 <clklein> Jafet: I know. 
03:41:00 <adu> lol
03:41:07 <rjo> it seems that I've to do coercion myself
03:41:21 <clklein> I want to ignore the IO that's not text printing.
03:41:23 <adu> you mean unsafeLaunchMissiles?
03:42:11 <rjo> parse P.float "" "2" == Left String
03:42:32 <adu> try 2.0
03:42:39 <Jafet> unsafeLaunchMissiles still has type IO(), the one with type () is unsafeUnsafeLaunchMissiles
03:42:40 <rjo> yes that works
03:42:56 <adu> is it Right String
03:43:08 <adu> lol
03:43:19 <Jafet> If you create a pipe and then read from it, won't you like deadlock
03:43:32 <rjo> but in the file format there is only floats, but sometimes in a form 2
03:44:33 <rjo> so is the only choice parse (P.naturalOrFloat lexer) "" "2" :: Either Integer Double, and then do the coercion
03:45:32 <Jafet> > show 2.0
03:45:33 <lambdabot>   "2.0"
03:45:38 <Jafet> Hrm
03:45:46 <Jafet> > read "2" :: Float
03:45:47 <lambdabot>   2.0
03:45:59 <silbo> heyp guys im trying to implement this function called mkPlacingMap http://hpaste.org/paste/42552/quarto_annotation#p42616 line 293, and I need to but the list of free positions back together
03:46:50 <silbo> when you go recursively trough a list and take items, how do you but it back together when your done?
03:47:58 <monadic_kid> @src map
03:47:58 <lambdabot> map _ []     = []
03:47:59 <lambdabot> map f (x:xs) = f x : map f xs
03:48:14 <rjo> Jafet, true, but float :: Parser Double fails when parsing 2
03:48:59 <rjo> and using read is tedious
03:49:04 <rjo> e.g.
03:49:09 <rjo> readMaybeConditionDouble cnd s = ((fmap fst . listToMaybe . reads) s)  
03:49:09 <rjo>                             >>= \x -> if cnd x then 
03:49:09 <rjo>                                         return x
03:49:09 <rjo>                                       else
03:49:09 <rjo>                                         Nothing
03:49:41 * hackagebot snippet-extractor 0.1 - Extracts labeled snippets of code to files.  http://hackage.haskell.org/package/snippet-extractor-0.1 (JasonDagit)
03:51:41 <Jafet> It does? Weird
03:52:19 <ddarius> @hoogle floatOrNatural
03:52:19 <lambdabot> No results found
03:52:41 <rjo> @hoogle naturalOrFloat
03:52:42 <lambdabot> Text.Parsec.Token naturalOrFloat :: GenTokenParser s u m -> ParsecT s u m (Either Integer Double)
03:52:42 <lambdabot> Text.ParserCombinators.Parsec.Token naturalOrFloat :: GenTokenParser s u m -> ParsecT s u m (Either Integer Double)
03:53:06 <Jafet> I hate import diamonds
03:54:02 <Jafet> Well, you could write your own parser that does do it properly
03:54:39 <rjo> true, maybe that is the best solution
03:55:18 <rjo> I just thought that using these floats I could gain easily more complicated cases like 123.123E-3 presentations
03:56:57 <lispy> Jafet: import diamonds?
03:57:09 <lispy> I'm using cabal-dev for everything these days and it's so nice
04:06:21 <rjo> > parse float "" "2"
04:06:22 <lambdabot>   Not in scope: `parse'
04:06:22 <rjo> Right 2.0
04:07:32 <rjo> oh, well, negative numbers
04:14:50 <hvr> Does anyone happen to know from experience with GHC (so I don't have to microbenchmark it) at which number of elements `Data.Set.member` starts outperforming `Data.List.elem`?
04:17:50 <adu> hvr: you should write a paper on it
04:22:06 <pozic> adu: you cannot write a paper on that.
04:22:31 <pozic> A tool which computes it for every possible data structure however might be worth telling people about.
04:22:46 <pozic> Not really news worthy from an academic point of view. 
04:23:03 <hvr> I was just wondering about real-world rule-of-thumb experience wrt to GHCs optimizer :)
04:24:20 <ddarius> hvr: The optimizer is hardly relevant.  On the other hand, the element type is relevant.
04:24:46 <hvr> ddarius: of course, the Eq vs Ord operation is important
04:25:16 <hvr> once Ord gets very expensive, every saved comparision favors Data.Set
04:25:37 <pozic> If the optimizer was really useful, one shouldn't have to care about which data structure one uses.
04:26:02 <pozic> There are data structures which support a superset of all the operations available in the libraries. 
04:26:25 <pozic> The compiler could recognize you only use a part of the operations and select a better data structure automatically in 99% of the cases.
04:26:44 <ddarius> pozic: Go ahead and write such a compiler then.
04:26:59 <pozic> ddarius: find me a source of funding and I will get right to it. 
04:27:31 <ddarius> Are you being funded to talk on IRC?
04:28:22 <pozic> ddarius: no
04:28:55 <hvr> maybe let me put the question a bit different: can I go wrong always using Data.Set were I need `elem` more than once?
04:30:04 * Toxaris is confused by Template Haskell.
04:30:19 <Toxaris> Why does (reify (mkName "Prelude.[]")) not work?
04:32:19 <lispy> > Prelude.[]
04:32:19 <lambdabot>   Not in scope: data constructor `Prelude'
04:32:51 <Toxaris> (reify (mkName "[]")) works fine, and so does (reify (mkName "Prelude.Maybe"))
04:33:05 <Toxaris> > P.[]
04:33:06 <lambdabot>   Not in scope: data constructor `P'
04:33:25 <Toxaris> lispy: But I want the type anyway
04:33:35 <Toxaris> (Maybe that's the problem?)
04:33:46 <mm_freak> pozic: i've just written a simple quasiquoter for here-docs
04:33:53 <lispy> :t Prelude.Maybe
04:33:54 <lambdabot> Not in scope: data constructor `Prelude.Maybe'
04:33:57 <lispy> :t Prelude.Maybe a
04:33:58 <lambdabot> Not in scope: data constructor `Prelude.Maybe'
04:34:03 <lispy> Toxaris: hmm
04:34:28 <mm_freak> pozic: i haven't implemented patterns though…  you can do that yourself
04:34:39 <mm_freak> hereDoc = QuasiQuoter { quoteExp = return . LitE . StringL . dropWhile (== '\n'), quotePat = undefined }
04:34:40 <ddarius> Toxaris: Why not use the '' syntax?
04:35:05 <Toxaris> ddarius: because I try to write glift :: Data a => Q Exp 
04:35:13 <mm_freak> pozic: then you can write:  [$heredoc| TEXT |]
04:35:21 <mm_freak> where TEXT can also contain line feeds
04:35:29 <Toxaris> ddarius: I mean of course: glift :: Data a => a -> Q Exp
04:35:37 <pozic> mm_freak: nice
04:35:56 <pozic> My program written in a real FP style also works sufficiently fast. 
04:36:19 <mm_freak> pozic: though if you want speed, you really want ByteString or Text, not String
04:36:40 <pozic> mm_freak: the output of the solutions is rather slow. 
04:36:48 <mreh> hmm, I've got to try and predict which way a signal is moving (is it decreasing or increasing) and annotate each point in the signal, so I figured using StateT (Value, Direction) [] (Value, Direction) and backtrack when I'm wrong
04:36:49 <pozic> mm_freak: Would ByteString also help with that?
04:37:05 <mm_freak> pozic: a lot…  consider that String is really a linked list of Char values
04:37:14 <mm_freak> while ByteString/Text are actual byte arrays in memory
04:37:18 <mreh> but I'm faced with the rather unsightly prospect of guessing what the initial state is
04:37:44 <mm_freak> pozic: for fast parsers, consider using attoparsec, possibly together with the 'enumerator' package
04:37:49 <Toxaris> @type Language.Haskell.TH.reify . Language.Haskell.TH.mkName . dataTypeName . dataTypeOf -- this does not work for lists because SYB and TH use different String representations for fully qualified types
04:37:50 <lambdabot> forall a. (Data a) => a -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Info
04:37:58 <mm_freak> pozic: for fast string output, i like the 'blaze-builder' package
04:45:39 <ddarius> > 128 * 80
04:45:41 <lambdabot>   10240
04:47:38 <ddarius> > 96 * 77
04:47:39 <lambdabot>   7392
04:47:55 * hackagebot language-javascript 0.0.3 - Parser for JavaScript  http://hackage.haskell.org/package/language-javascript-0.0.3 (AlanZimmerman)
04:52:43 <pozic> mm_freak: what's the fastest way to build a Builder from a Char (or anything equivalent)?
05:05:55 <mm_freak> pozic: writeChar, fromChar, fromString
05:06:44 <pozic> mm_freak: thanks, I missed it. I did see the writeWord8, etc.
05:07:34 <mm_freak> pozic: the best thing to do is not to have a Char in the first place, unless you're really dealing with individual characters
05:07:53 <mm_freak> fromChar/writeChar are fine for prefixing/suffixing/infixing some singleton character
05:08:06 <pozic> mm_freak: I have some object, and its representation is a letter. 
05:08:17 <mm_freak> ok
05:08:39 <pozic> mm_freak: I could also write that letter as a number, but that should be partially evaluated in a decent syste.
05:08:44 <pozic> mm_freak: m
05:09:01 <pozic> mm_freak: never mind.
05:10:30 <paolino> mh, I'm confused
05:11:11 <paolino>     Overlapping instances for Name (Confezione b, Bene Word b)
05:11:11 <paolino>       arising from a use of `singolare2'
05:11:11 <paolino>     Matching instances:
05:11:11 <paolino>       instance [overlap ok] (Polimorfo a, Name b) => Name (a, b)
05:11:11 <paolino>         -- Defined at Lib/NaturalLanguage.hs:33:10-44
05:11:11 <paolino>       instance Name (Scaffale Word Unità)
05:11:11 <paolino>         -- Defined at Lib/UIVoci.hs:32:10-35
05:11:31 <paolino> and this is correct
05:12:07 <paolino> but why adding "Name (Confezione b, Bene Word b)" to the constraints resolve ?
05:12:37 <sipa> the Name (a, b) instance matches every 2-tuple, the constraint is checked afterwards, i believe
05:13:17 <mm_freak> adding a context resolves overlapping instances?
05:13:22 <paolino> can you rephrase please ?
05:13:53 <mm_freak> now that would be great news
05:13:57 <paolino> mm_freak , it seemed, I retry
05:14:28 <paolino> yes
05:14:51 <mm_freak> anyway, if you have an instance for (a, b), then having a more specific instance seems not to be very useful in general
05:15:01 <paolino> the point is that I added what was inferred, the problem itself
05:16:08 <paolino> mm_freak: Confezione b is not instance of Polimorfo
05:16:42 <mm_freak> ah, i see it now
05:17:08 <sipa> paolino: unless you use OverlappingInstances, the "(Polimorfo a, Name b) => " part is irrelevant for finding matches
05:17:28 <mm_freak> sipa: really?
05:17:33 <sipa> i think so, yes
05:18:34 <sipa> When matching, GHC takes no account of the context of the instance declaration (context1 etc). GHC's default behaviour is that exactly one instance must match the constraint it is trying to resolve. 
05:18:40 <sipa> http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/type-class-extensions.html
05:18:53 <sipa> section 7.6.3.4
05:20:08 <paolino> sipa I use OverlappingInstances
05:20:49 <paolino> still I don't understand why adding the constraint to the function resolves the matching
05:23:00 <paolino> when you say "the constraint is checked afterwards" , it seems to me that adding it to the function makes it irrelevant
05:24:13 <mm_freak> sipa: i don't think it's irrelevant…  i rather think that overlapping instances only occur, when one instance is just a generalization of the other
05:24:36 <mm_freak> and in fact i can't reproduce that adding a context solves the overlapping
05:25:19 <paolino> mm_freak: It just did
05:25:35 <mm_freak> paolino: it might be that adding the constraint really makes it non-overlapping
05:25:45 <mm_freak> because if they still overlap, then you also still get an error
05:26:11 <paolino> but I added what ghc was inferring
05:26:32 <paolino> "Overlapping instances for Name (Confezione b, Bene Word b)"
05:26:50 <paolino> and I added that to the context, nothing more
05:27:11 <mm_freak> yes, and in haskell's type system you can't derive the special from the general (like in OOP)
05:27:32 <mm_freak> so adding the context might make it more general and thus the special instance doesn't apply anymore
05:29:33 <paolino> well, it seems that adding the context just convinced it that *one* of them was not right
05:30:23 <paolino> in fact there is no Polimorfo (Confezione b) around
05:33:06 * hackagebot bindings-DSL 1.0.8 - FFI domain specific language, on top of hsc2hs.  http://hackage.haskell.org/package/bindings-DSL-1.0.8 (MauricioAntunes)
05:33:34 <paolino> I cannot see why there is a more special instance there. It is just that the first one is not satisfiable with the present instances
05:34:25 <paolino> but really the type system is obscure to me 
05:47:00 <pozic> mm_freak: how do I turn a Write into a Builder and finally print it? I suppose I have to use some other bytestring I/O library for the last part?
05:47:46 <pozic> mm_freak: never mind, modulo the I/O.
05:52:27 <rrc7cz> does anyone have any idea why I might get a "Prelude.read: no parse" error when I try to run the basic Snap webapp per the quickstart?
05:53:16 <mm_freak> pozic: the blaze-builder package does everything…  in general there is also no need to go through a Write first
05:53:25 <rrc7cz> I should mention that when I run it w/out the command line args in the example "-p 8000" it does actually run fine
05:54:03 <mm_freak> instead of writeWhatever just use fromWhatever…  and to turn a Write to a Builder you can use fromWrite…  to output a Builder i usually use toByteStringIO
05:54:29 <mm_freak> rrc7cz: "no parse" is an error message from the 'read' function
05:54:39 <mm_freak> > read "abc" :: Integer
05:54:40 <lambdabot>   *Exception: Prelude.read: no parse
05:55:56 <rrc7cz> mm_freak: that makes sense then; when I run it with just "8001" it runs on the specified port. It looks like the latest version drops the "-p" but the site wasn't updated. Thanks
05:57:21 <mm_freak> you're welcome
05:57:44 <Kaidelong> oh my, active patterns are nice
05:57:49 <Kaidelong> does Haskell have anything like it?
05:57:57 <Kaidelong> views?
05:58:58 <pozic> mm_freak: I need a lazy output. With these strict bytestrings, everything is kept in memory, which is not what I want.
05:59:38 <Kaidelong> http://msdn.microsoft.com/en-us/library/dd233248.aspx <-- reference, want to know of haskell equivalent if there is one
06:01:08 <Kaidelong> it is the parameterized active patterns I want in particular
06:01:09 <Cale> Kaidelong: view patterns
06:01:26 <Cale> It's not *quite* the same thing
06:01:29 <Cale> But it's close
06:02:06 <Cale> http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns
06:02:13 * hackagebot wumpus-core 0.41.0 - Pure Haskell PostScript and SVG generation.  http://hackage.haskell.org/package/wumpus-core-0.41.0 (StephenTetley)
06:02:15 * hackagebot wumpus-basic 0.14.0 - Common drawing utilities built on wumpus-core.  http://hackage.haskell.org/package/wumpus-basic-0.14.0 (StephenTetley)
06:02:18 * hackagebot wumpus-microprint 0.13.0 - Microprints - "greek-text" pictures.  http://hackage.haskell.org/package/wumpus-microprint-0.13.0 (StephenTetley)
06:02:20 * hackagebot wumpus-tree 0.12.0 - Drawing trees  http://hackage.haskell.org/package/wumpus-tree-0.12.0 (StephenTetley)
06:02:20 <mm_freak> pozic: toByteStringIO does chunked IO
06:02:52 <Cale> http://www.haskell.org/ghc/docs/6.10.1/html/users_guide/syntax-extns.html#view-patterns
06:03:14 <mm_freak> pozic: lazy IO is a bad idea in general
06:04:32 <mm_freak> not so much for output, but at least for input
06:04:51 <pozic> mm_freak: it didn't seem to be chunked. 
06:04:56 <pozic> mm_freak: or at least very large. 
06:05:11 <pozic> mm_freak: converting to lazy bytestrings does work, though.
06:05:36 <mm_freak> pozic: the chunk size is chosen carefully
06:05:46 <mm_freak> lazy bytestrings likely have the same chunk size
06:06:05 <mm_freak> so you should observe the same thing, regardless of which one you use
06:06:23 <mm_freak> but the strict ByteString variant is at least faster, because you save the intermediate data structure
06:06:33 <Kaidelong> Cale: from what I could piece together from that documentation, they don't actually show the syntax for implementing "view"
06:09:03 <Kaidelong> I take it the whole "view ->" thing is similar to the HSB vs RGB example for F#?
06:09:16 <Kaidelong> you give the name of the view you want to use to generate the pattern?
06:09:22 <pozic> mm_freak: there is zero difference in my case. 
06:09:30 <Cale> Kaidelong: view is an arbitrary function
06:09:39 <Kaidelong> arbitrary?
06:09:47 <pozic> mm_freak: maybe it is only useful for MBs of data. 
06:09:52 <Kaidelong> truly arbitrary?
06:10:01 <Cale> yes
06:10:14 <Cale> (though choosing a data constructor would be silly)
06:10:41 <Kaidelong> okay, so essentially your "active pattern" is some data type you've defined
06:10:54 <Cale> > let f (reverse -> (x:xs)) = x in f [1,2,3]
06:10:55 <lambdabot>   3
06:10:56 <Kaidelong> and you use some function to build that type, and then decompose it with regular patterns?
06:11:30 <Cale> yeah
06:13:02 <Kaidelong> okay, looks like it accomplishes everything you can do with active patterns then, that's good!
06:14:42 <Kaidelong> so the goal here would be to avoid the need for nested case expressions and for guards?
06:16:24 <pozic> @src length
06:16:24 <lambdabot> Source not found. Are you on drugs?
06:16:35 <pozic> @src Data.List.length
06:16:35 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
06:16:46 <pozic> @src Prelude.length
06:16:46 <lambdabot> Source not found. Sorry.
06:17:27 <Kaidelong> > foldr (const (+1)) 0 [1..10]
06:17:29 <lambdabot>   10
06:17:45 <scree> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-List.html#length
06:17:50 <Kaidelong> > foldr (const (+1)) 0 [2..10]
06:17:52 <lambdabot>   9
06:18:05 <scree> pozic: ^^^
06:19:35 <pozic> If I have do let x = <long list>;print x; print (length x), I will have a space leak the size of the list, right?
06:19:50 <pozic> That is, the spine.
06:20:05 <Toxaris> looks like I just spend half a day to reinvent the appendix of http://www.eecs.harvard.edu/~mainland/publications/mainland07quasiquoting.pdf
06:20:39 <mm_freak> what exactly is a TVar?  what's the difference between TVar and TMVar?
06:20:45 <Twey> pozic: No, I don't believe so
06:20:57 <Twey> mm_freak: TMVars can be empty, IIRC
06:21:09 <mm_freak> i mostly use TMVar, because i'm a big fan of MVar outside of STM
06:21:31 <mm_freak> but i now have a use case, where STM can actually be very useful, so i'm wondering, is TVar just a transactional IORef?
06:21:40 <mm_freak> or can it actually block a thread?
06:22:21 <pozic> Twey: why not? It appears that this is exactly what I am seeing. 
06:23:26 <Twey> Oh, wait
06:23:36 <Twey> Yeah, the space of one copy of xs will probably be preserved
06:23:46 <Twey> Er, x
06:23:54 <Twey> Values and all
06:24:03 <Twey> But only one, not two
06:24:21 <Twey> When you ‘print x’ it's forced, but since it's still in scope afterwards, it's not going to be GC'd
06:24:42 <Twey> So ‘length’ doesn't have to force the spine again, but at the cost of having a list in memory
06:25:22 <pozic> A good compiler would also rewrite that. 
06:27:29 <mm_freak> oh, i see now the difference between TVar and IORef
06:28:49 <silver> silverbuddy, heybuddy!
06:29:29 <silverbuddy> hey, silver!
06:40:22 <Basti> good evening
06:42:21 <Basti> can someone help me with some shortest path problems?
06:42:38 <Zao> Find a Dijkstra implementation, implement :D
06:42:54 <Basti> ave to do Floyd Warshal
06:43:52 <Basti> have implemented a generic closure wich gives me the distnce
06:44:05 <Basti> but stuck at path output
06:44:38 <otzi> weird, I installed dbus with cabal install --global dbus and it worked. But if I download the source and do ``runhaskell Setup.hs configure; runhaskell Setup.hs build'' it doesn't even compile.
06:45:01 <otzi> does cabal do things differently?
06:49:08 <Zao> otzi: What fails?
06:52:37 <otzi> there was two failures. At first it didn't find a C header, which I was able to fix adding some include directories. I wonder how cabal found it by itself. The other error is http://pastebin.ca/2031463
06:54:56 <otzi> my ghc is 6.12.1. Hackage page for dbus reports that error for ghc 7, besides, it compiled just fine through cabal-install
06:55:05 <otzi> unless cabal-install just downloads the binaries
06:57:11 <pozic> Do you have any idea why this doesn't run in constant space? http://paste.debian.net/103340/
06:58:38 <Zao> If you have multiple GHC, it might be using the one cabal was built with?
06:58:50 <otzi> no, just the one
07:08:44 <otzi> and there' no way to see how cabal did the compiling :(
07:09:31 <pozic> Is there any way I can print a large list and its length while using a constant amount of memory?
07:09:49 <pozic> (without printing element by element)
07:10:22 <Jafet> How do you print a list without "printing element by element"?
07:10:40 <pozic> Jafet: if I do not print the length it runs in constant memory. 
07:11:01 <pozic> Jafet: it means, not using multiple putStrLn calls.
07:11:36 <Jafet> But what does that have to do with the space usage?
07:13:09 <pozic> Jafet: if you would do one putStrLn per element, you could simply increment some counter. 
07:13:37 <pozic> Jafet: I tried using a foldr to build the string a counter at the same time, but that didn't appear to work. 
07:13:43 <Toxaris> pozic: so what's the problem with that solution?
07:14:03 <pozic> Toxaris: multiple putStrLn's? 
07:14:08 <Toxaris> pozic: yes
07:14:50 <pozic> Toxaris: in principle not a lot, but you now have to mix I/O and computation.
07:15:06 <pozic> Toxaris: the very thing which FP is supposed to be about.
07:15:11 <Jafet> So abstract out the IO.
07:15:19 <Toxaris> pozic: oh, I guess you want    showAndLength x = (show x, length x)   but in constant memory?
07:15:32 <pozic> Toxaris: yes
07:15:40 <Toxaris> instead of    printAndLength x = do print x; return (length x)
07:16:07 <Toxaris> you need some extra strictness then
07:16:25 <Toxaris> so that the computation of the length is forced (!) while lazily computing the string
07:17:45 <pozic> Toxaris: http://paste.debian.net/103342/
07:18:04 <pozic> Toxaris: I already had this before you answered, but I don't see why it doesn't lazily compute the string.
07:20:02 <Toxaris> pozic: that's what I would have written
07:20:39 * frerich just tried to write his own version of concat; after a while he needed an idea how to tackle the problem, so he decided to see how the Prelude does it. Only to find out that it just uses foldr 8-{
07:20:52 <Twey> frerich: Hehe
07:21:00 <Jafet> What's wrong with foldr!?
07:21:20 <pozic> Jafet: I have no idea, but I can see that it is not lazy. 
07:21:34 <Twey> concat = foldr (++) []
07:21:43 <frerich> Jafet: It's painful to wrap the head around it if you're a newbie like me. As an exercise, I try to implement all the standard list functions myself.
07:21:45 <Toxaris> pozic: maybe you want a lazy match on the tuple in the lambda expression?
07:21:45 <Twey> Hm
07:21:57 <Twey> concat = foldr mplus mzero, more generally
07:22:02 <Toxaris> pozic: \solution ~(c, str) -> ...
07:22:07 <Toxaris> pozic: (just guesssing)
07:22:14 <frerich> Jafet: It's amazing how short the implementations in foldr are, but they are so concise that it's a bit hard to read for a beginner like me :-}
07:22:20 <frerich> s/in folder/in the prelude/
07:22:24 <pozic> Toxaris: nope
07:22:28 <Twey> Or mappend mempty, even
07:22:30 <kamatsu> frerich: it's not too hard to grok folds
07:22:44 <kamatsu> frerich: lists are just 1 : 2 : 3 : [], right?
07:22:53 <Jafet> pozic: does that code run in your constant space?
07:22:54 <kamatsu> frerich: so a fold replaces : with your function, and [] with the zero arg
07:23:09 <frerich> kamatsu: I understand them every time I go back to the 'folding' chapter of RWH, but I didn't grok them enough to think of them as possible solutions to whatever problem I'm thinking about.
07:23:43 <frerich> by now, I think you can express a helluva lot more stuff using foldl/foldr than one might think :-}
07:23:48 <kamatsu> yeah
07:24:10 <Twey> frerich: They're also nice for newbies because they relieve you of having to think about space leaks most of the time ;)
07:24:46 <tac-tics> @type fix id
07:24:46 <lambdabot> forall a. a
07:24:56 <tac-tics> @type fix fix
07:24:57 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
07:24:57 <lambdabot>     Probable cause: `fix' is applied to too many arguments
07:24:57 <lambdabot>     In the first argument of `fix', namely `fix'
07:25:13 <kamatsu> all list iterations can be expressed as a fold
07:25:37 <Jafet> All primitive recursive algorithms can be expressed as folds
07:25:42 <pozic> It might also be that my space-leak comes from somewhere else. When does the GC run?  
07:25:49 <pozic> Just when it is out of space?
07:25:56 <frerich> I think I need to adjust my point of view a bit because it feels like going through an 'artificial forest' (no idea what the english term is) where all the trees are aligned in a grid. If you stand wrongly, it looks like a mess, if you do a step into the right direction, it all looks simple :-}
07:26:08 <winxordie> Jafet: that's an interesting claim; could you tell me why?
07:26:35 <kamatsu> it's a catamorphism
07:27:19 <kamatsu> fold encapsulates structural recursion on a list
07:27:32 <kamatsu> there are also catamorphisms for other data structures
07:28:03 <Twey> Hence the Foldable typeclass
07:28:06 <winxordie> oh ok
07:28:24 <Jafet> pozic: eh, heap-profile your program.
07:28:54 <kamatsu> winxordie: so, essentially all programs that do structural recursion on  a list can usually be expressed as a fold.
07:29:52 <winxordie> never thought of it that way
07:30:24 <kamatsu> fold is to lists as maybe (the function) is to Maybe (the type)
07:30:28 <winxordie> kamatsu: I'll be sure to use a lot more folds then :)
07:30:45 <kamatsu> sometimes it's rather inelegant to use a fold, obviously
07:30:57 <kamatsu> but it's always possible
07:31:26 <Jafet> And then there's unfoldr, the anamorphism
07:31:28 <kamatsu> structural recursion means your call tree matches your data structure
07:31:36 <kamatsu> so you can't do quicksort as a fold.
07:31:42 <kamatsu> or, not  as a single fold anyway
07:32:19 <Jafet> @src sortBy
07:32:20 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
07:32:24 <Jafet> @src insertBy
07:32:25 <lambdabot> insertBy _   x [] = [x]
07:32:25 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
07:32:25 <lambdabot>                                  GT -> y : insertBy cmp x ys'
07:32:25 <lambdabot>                                  _  -> x : ys
07:32:35 <kamatsu> isn't that insertion sort?
07:32:58 <Jafet> It appears so
07:33:26 <kamatsu> you could probably express insertBy as a fold as well
07:34:25 <Jafet> Well, you have to be careful about what you allow in the fold body, to end up with only the primitive recursive stuff
07:34:36 <kamatsu> true
07:35:09 <pozic> Is there another tool to see .hp files than the hp2ps tool?
07:40:21 <Cale> sortBy isn't required to be an insertion sort though
07:40:27 <Cale> In GHC, it's a mergesort
07:42:40 <pozic> My profile says that MUT_ARR_PTRS_CLEAN uses the most memory.
07:43:10 <pozic> Followed by [], which is probably the memory leak. 
07:44:34 <Jafet> The last time someone mentioned that was to point out that the mergesort has different strictness from the one in the report
07:44:58 <Jafet> Which is mostly irrelevant for an algorithm that has to evaluate all its inputs, but well
07:45:27 <mm_freak> how fast does STM perform nowadays?  is it suitable for high scale server programs?
07:45:29 <Cale> It doesn't have to evaluate all the comparisons though
07:46:11 <mm_freak> i'm not using it heavily right now, but it does have its uses in a network program
07:46:51 <Cale> The strictness difference is in how much/what part of the comparison function gets evaluated :)
07:47:09 <mm_freak> also i might find uses for STM in games
07:49:51 <mm_freak> (i'd prefer to use FRP, but in my last benchmark all libraries were either too slow or simply not mature)
07:50:52 <pozic> Jafet: the leak went away when I rewrote it with multiple putStrLn calls. 
07:51:03 <pozic> So, the question still stands. 
07:51:32 <Jafet> I didn't see any "putStrLn calls" in the code you posted
07:51:33 <pozic> Is there any way in which you can do the computation of the string lazily, the computation of the number strictly such that it runs in constant space?
07:51:41 <Jafet> Perhaps you should post, like, the real code
07:51:52 <pozic> Jafet: it's an irrelevant part of the code. 
07:51:53 <Cale> http://hpaste.org/42621/displayandcount -- like this?
07:52:02 <mm_freak> pozic: you need to prevent sharing, but in that case you would need to iterate the list twice
07:52:15 <mm_freak> better use multiple put* calls
07:52:24 <pozic> Cale: right, that's what I have now.
07:52:38 <mm_freak> don't worry, the puts are buffered
07:52:48 <pozic> Cale: but the question is how to do it without using muliple putStrLns.
07:52:49 <mm_freak> and you can also enforce a certain buffer type/size using hSetBuffering
07:52:51 <Cale> pozic: Yeah, if you try to compute the string, you'll either end up holding on to the list of actual solutions, or the shown string
07:52:59 <Cale> while the number gets computed
07:53:11 <pozic> That seems to be a problem in compositionality. 
07:53:26 <pozic> or just composition ;)
07:53:28 <mm_freak> pozic: another possibility is to build a Builder while computing the length and then add the length to the Builder
07:53:33 <Jafet> mm_freak: iterate the list twice is a space leak
07:54:32 <pozic> mm_freak: are you sure you are not just moving the space leak then?
07:55:59 <mm_freak> Jafet: the builder method iterates only once
07:56:07 <mm_freak> pozic: i'm testing
07:56:14 <mm_freak> but i'm fairly sure it should work
07:56:32 <Jafet> Heh, build a Builder
07:57:07 <pozic> It works now with -M4m :)
07:57:16 <pozic> Still, using the 'hack'.
07:57:24 <Cale> Which hack?
07:57:34 <pozic> Cale: one equivalent to yours.
07:58:01 <Cale> It's just being careful about what's kept and thrown away as the items are printed.
07:58:17 <Cale> btw, my program runs a *lot* faster with block buffered stdout
07:58:30 <Cale> hSetBuffering stdout (BlockBuffering Nothing)
07:59:01 <mux> sounds like flushing buffers is more overhead than it should be, then
08:00:06 <pozic> Cale: is that GHC specific?
08:00:10 <Cale> no
08:01:02 <mm_freak> pozic: no, it really just moved the space leak
08:01:23 <mm_freak> pozic: but really, there is nothing wrong with calling put* multiple times
08:01:30 <mm_freak> it uses buffering as said
08:07:33 <Cale> I think pozic's problem is a legitimate one though... you wouldn't want to have to write direct recursion here. Perhaps we could use foldM
08:08:53 <Cale> Yeah, that works.
08:08:54 <pozic> I already use foldM
08:09:33 <Cale> http://hpaste.org/42622/with_foldm
08:10:14 <pozic> Cale: it's of course fundamentally still the same.
08:10:25 <pozic> Cale: your buffering did help a lot. 
08:10:41 <Jafet> What kind of semantics of haskell do space leaks come in?
08:10:48 <Cale> Well, sure, though recursion is bad to have to write
08:11:24 <Cale> The difference between the other one and this one is that this one isn't outwardly recursive.
08:11:39 <Cale> (foldM is recursive internally, of course)
08:12:10 <Cale> Jafet: um, hmm... you mean what kind of semantics can be used to explain space leaks?
08:12:38 <pozic> You could say that it is a problem of the implementation.
08:12:47 <Cale> Jafet: An operational semantics for the language can be used to measure space usage as the size of expression graphs.
08:12:55 <pozic> I can think of evaluation strategies that don't have the concept of space-leak.
08:13:27 <pozic> You can simply evaluate as lazy as possible and when you almost run out of memory you evaluate some stuff. 
08:13:27 <Cale> It's not really a space leak so much as it is just plain wastefulness with memory?
08:13:52 <Jafet> What's a space leak to you, then?
08:14:42 <Cale> Well, pozic seems to think that the space usage here is GHC's fault, but I don't think there's anything GHC could have reasonably done with that program to avoid the space usage.
08:15:32 <pozic> If I also cannot do anything to avoid it without using foldM or equivalent, it is a language problem. 
08:15:55 <Cale> Is it really?
08:16:36 <pozic> Let's say I want to compute something else.
08:16:44 <pozic> Then I have to rewrite the foldM loop again.
08:16:48 <Cale> If you want to keep a huge string in memory, it's going to use a lot of space.
08:16:59 <pozic> I do not want to keep the huge string in memory.
08:17:08 <pozic> I just want multiple consumers to read from it as needed.
08:17:13 <pozic> In parallel, preferably. 
08:17:26 <pozic> Just like real hardware.
08:17:55 <Cale> Well, we could certainly parallelise this.
08:17:56 <pozic> So, the readers should communicate with the producer saying whether they want more data.
08:17:58 <Jafet> ghc could turn (show s, length s) into a fold that computes that in little space, in principle
08:18:25 <pozic> When everybody is up to date, the producer creates the next element.
08:18:42 <pozic> No fundamental problem, but at the same time it's not working in 2010. 
08:21:08 <Cale> http://hpaste.org/42623/in_parallel
08:21:53 <Cale> Memory usage should stay relatively low, though there's not much in the way of guarantees
08:22:08 <Cale> It's just computing both in parallel and things become garbage as soon as possible
08:22:27 <Jafet> Hm, I never really thought about space usage with par
08:23:50 <Cale> It's possible that we could do something more subtle to ensure that things keep pace with each other
08:24:14 <Cale> (here, if one of the two evaluations gets ahead of the other, there will be some slack in space usage)
08:25:08 <pozic> Cale: that is a nice solution. 
08:25:53 <Jafet> I don't know any research on this sort of automatic synchronization
08:26:05 <Jafet> Or is it already included in what they call automatic parallelization research?
08:29:09 <Toxaris> pozic: http://hpaste.org/42624
08:29:15 <pozic> Jafet: I don't know, but AFAIK parallelism has been investigated to death. 
08:29:39 <pozic> It's just not nobody maintained some actual software.
08:29:46 <Jafet> If it really had been investigated to death, we wouldn't need Control.Parallel I would think
08:30:02 <Toxaris> pozic: I didn't check space behavior, but the trace output suggests that the execution order is what you want
08:30:04 <Jafet> Then again, I've never tried ghc-par
08:30:39 <Cale> Jafet: What?
08:31:44 <Cale> Jafet: Fully automatic parallelisation is one of those things that doesn't really work well because there are too many places to parallelise but determining how to balance the work is as hard as the halting problem.
08:32:25 <Jafet> Hm, how hard as the halting problem?
08:32:46 <Cale> Because you need to know how long it'll take to compute each of the branches ahead of time.
08:33:02 <Toxaris> Jafet: oh, just as hard as every other problem, according to Rice, so no big deal
08:33:35 <Cale> (in order to balance the work between processors)
08:33:47 <Ke> parallelization of pure branches would be still possible with preprofiling or special keywords
08:33:58 <Cale> yeah
08:34:00 <Ke> parallelization with IO is just too painful
08:34:10 <Jafet> You could just split still-running sparks to use the processors left over by the finished sparks, right
08:34:24 <Cale> Well, parallelisation with IO is pretty much what concurrency is all about.
08:34:43 <Cale> So par is sort of like the "special keywords" approach.
08:34:48 <Cale> (though par is not a keyword)
08:35:29 <Cale> If you spark absolutely everything, you'll find that while maybe you get lots of parallelism, the amount of wasted work kills you.
08:35:43 <Cale> Sparks are cheap, but they certainly are not free.
08:36:23 <thoughtp1lice> if you have a ton of expressions, '1+2' is meaningless to spark, but perhaps '1+x' is, because x is a longer computation - but what if x is just composed of a million different additions? do you parallelize each of them or none of them or what?
08:36:26 <Jafet> Sure, but even coarse-grained splitting should let you use the leftover processors quickly
08:37:09 <Jafet> I'm merely not sure why turing-completeness would make it more difficult than it already is
08:37:19 <Cale> But how does the compiler know what's coarse and what's not?
08:37:59 <Cale> Determining the running time of a program without running it is hard.
08:38:44 <thoughtp1lice> i think 'par' and things like strategies are a better approach. they preserve the meaning of your program and the fact you want parallelism (supposedly because it brings a runtime benefit) is more explicit but still very lightweight, rather than just relying on compiler possibilities
08:38:44 <Cale> Granted, for wide classes of programs, it's possible.
08:38:55 <Jafet> Especially if the program will thrash!
09:00:26 <davidsiegel> Hi, I'm trying to port a subset of JQuery to Haskell to let me easily write code to manipulate HTML representations. I want to be able to write code like: clean = remove "p" :: HQuery ();  So I declared HQuery as a newtype wrapper on a State monad, but I'm not sure how to declare HQuery so that it's decoupled from an underlying typeclass representing HTML that constitutes the state of the State monad: HTMLRep. I want to be able to t
09:00:53 <Jafet> I want to be able to t, too
09:02:39 <Taejo> yo
09:07:14 <monadic_kid> davidsiegel: what do you mean by decupled from underlying type-class?
09:09:42 <davidsiegel> monadic_kid: I mean that I want monadic code typed HQuery () to work with instance HTMLRep String and instance HTMLRep [TagSoup.Tag String], for example
09:10:23 <Jafet> You could see how Text.Regex does it.
09:10:28 <Jafet> It's... not pretty.
09:11:23 <davidsiegel> I would just rather that clients can type their code as HQuery () instead of HTMLRep a => HQuery a ()
09:11:49 <monadic_kid> davidsiegel: who wrote the type-class HTMLRep? you can always escape state monads: myPure = runState $ do ....
09:12:07 <path[l]> whoa whats jQuery in haskell? how does this work
09:12:10 <davidsiegel> I wrote the typeclass
09:12:32 <davidsiegel> monadic_kid: this is what I have tried so far, so you get the idea:
09:12:32 <davidsiegel> data HQuery a = forall s. HTMLRep s => HQuery { unHQuery :: State s a }
09:13:23 <monadic_kid> davidsiegel: why do you want to do that?
09:13:56 <davidsiegel> because I am going to be writing a lot of HQuery () code and I want each instance to be easier to type
09:14:06 <davidsiegel> and I may want to change the underlying HTMLRep
09:14:13 <path[l]> but is this meant to run on the browser?
09:14:19 <davidsiegel> I could make everything easier and just pick [TagSoup.Tag]
09:14:29 <davidsiegel> path[l]: no, not really
09:15:20 <davidsiegel> monadic_kid: ok you've convinced me, I am making this too complicated!
09:15:50 <davidsiegel> I thought I would use this approach if it were easy but it looks like it will be problematic
09:39:25 <copumpkin> golfing contest, [a] -> [(a, a)] containing all two-element permutations
09:39:44 <copumpkin> I guess I could just do it with a comprehension
09:40:11 <copumpkin> > let f xs = [(x, y) | x <- xs, y <- xs, x /= y] in f [1..4]
09:40:12 <lambdabot>   [(1,2),(1,3),(1,4),(2,1),(2,3),(2,4),(3,1),(3,2),(3,4),(4,1),(4,2),(4,3)]
09:40:32 <roconnor> copumpkin: that assume all the elements are distinct
09:40:41 <roconnor> copumpkin: you aren't allowed an eq constraint on a
09:41:04 <copumpkin> I'm quite fine with an Eq on it, but I'd be curious if you can find something nicer
09:42:36 <roconnor> > let select (x:xs) = (x,xs) :: map (\(a,b) -> a,x:b)) (select xs); select [] = [[]] in select [1..4]
09:42:37 <lambdabot>   <no location info>: parse error on input `\'
09:42:44 <roconnor> > let select (x:xs) = (x,xs) :: map (\(a,b) -> (a,x:b)) (select xs); select [] = [[]] in select [1..4]
09:42:45 <lambdabot>   <no location info>: parse error on input `\'
09:42:57 <roconnor> damn ocaml
09:43:01 <copumpkin> was going to say :)
09:43:02 <roconnor> > let select (x:xs) = (x,xs) : map (\(a,b) -> (a,x:b)) (select xs); select [] = [[]] in select [1..4]
09:43:03 <lambdabot>   Couldn't match expected type `(t, [t])' against inferred type `[a]'
09:43:13 <roconnor> > let select (x:xs) = (x,xs) : map (\(a,b) -> (a,x:b)) (select xs); select [] = [] in select [1..4]
09:43:13 <lambdabot>   [(1,[2,3,4]),(2,[1,3,4]),(3,[1,2,4]),(4,[1,2,3])]
09:43:45 <copumpkin> oh I've used that function many times before
09:43:49 <roconnor> > let select (x:xs) = (x,xs) : map (\(a,b) -> (a,x:b)) (select xs); select [] = [] in do (a,b) <- select [1..4]; (c,_) <- select b; return (a,b)
09:43:50 <lambdabot>   [(1,[2,3,4]),(1,[2,3,4]),(1,[2,3,4]),(2,[1,3,4]),(2,[1,3,4]),(2,[1,3,4]),(3...
09:43:59 <roconnor> > let select (x:xs) = (x,xs) : map (\(a,b) -> (a,x:b)) (select xs); select [] = [] in do (a,b) <- select [1..4]; (c,_) <- select b; return (a,c)
09:43:59 <lambdabot>   [(1,2),(1,3),(1,4),(2,1),(2,3),(2,4),(3,1),(3,2),(3,4),(4,1),(4,2),(4,3)]
09:44:08 <roconnor> I really think it should be in the prelude
09:44:12 <copumpkin> me too
09:44:16 <copumpkin> or Data.List at least
09:44:28 <roconnor> or the slightly better [a] -> [([a],a,[a])]
09:44:39 <copumpkin> splits?
09:44:59 <copumpkin> hmm, [a] -> [([a], [a])] seems more practical
09:45:12 <copumpkin> oh maybe not
09:45:16 <roconnor> that has no proof that the second list is nonempty
09:45:21 <copumpkin> yeah
09:45:28 <copumpkin> not a fan of triples though
09:45:36 <roconnor> there is a question of whether the first list should be reverse a la zipper or not (a la deriviative)
09:45:46 <djahandarie> Just nest touples then!
09:45:51 <djahandarie> tuples
09:45:57 <roconnor> djahandarie: :D
09:46:25 <roconnor> granted I almost always use [a] -> [(a,[a])]
09:46:41 <roconnor> even if it is less primitive
09:49:08 <roconnor> I'm tempted to post Eduard_Munteanu's challenge to impelement the Vitter Algorithm for adaptive huffman encoding/decoding to the Haskell reddit
09:49:45 <copumpkin> do it!
09:49:55 <roconnor> but it is his homework assignment
09:50:08 <copumpkin> oh
09:50:13 <copumpkin> when's it due?
09:50:16 <copumpkin> post it afterwards?
09:50:19 <roconnor> that's a good question
09:50:39 <copumpkin> cause I'm sure many (including me, possibly) would have lots of fun golfing and elegantizing solutions
09:50:42 <roconnor> @ask Eduard_Munteanu when is your Huffman assignment due?
09:50:42 <lambdabot> Consider it noted.
09:56:41 <c_wraith> Ah.  I implemented static huffman encoding once, but that's a lot more boring.
09:57:12 <roconnor> this adaptive huffman seems to be hard to implement purely and efficently.
09:57:57 <c_wraith> I haven't looked at the algorithm yet, but that seems likely.
09:59:17 * monochrom doesn't respect the moral code of "don't do other people's homework"
09:59:27 <copumpkin> I sort of agree
09:59:34 <copumpkin> I think it's their responsibility to not cheat
09:59:44 * monochrom is too lazy to do anyone's homework in detail, however :)
09:59:46 <copumpkin> but still, it can't hurt to facilitate that for them if the cost to you isn't too low
10:00:09 <c_wraith> I sometimes get interested in other people's assignments, if I think they're doing something interesting.  I may even try to do them.
10:00:10 <merijn> Depends on how interesting the homework is, imo
10:00:16 <c_wraith> But I rarely give them the result if I do :)
10:01:27 * monochrom is mostly interested in getting an explanation across in the simplest way, and sometimes it means showing the solution. some other times not, of course.
10:01:33 <c_wraith> But in general, homework assignments aren't interesting problem, so if I help someone I try more to get them to see how to solve it than do it for them.
10:01:38 <c_wraith> err, *problems
10:02:26 <monochrom> perhaps s/simplest way/minimum bandwith or time/
10:02:26 <djahandarie> My homework assignment is to write a dissertation, can anyone help?
10:02:37 <copumpkin> djahandarie: do I get to put my name on it?
10:02:38 <c_wraith> that doesn't sound interesting.
10:03:09 <djahandarie> c_wraith, it can be on whatever you want!
10:03:28 * c_wraith plans a dissertation on how pretty butterflies are
10:03:33 <copumpkin> djahandarie: can I get you to do all the boring work for me?
10:03:36 <c_wraith> 3 pages is good, right?
10:03:46 <copumpkin> and I just design it for you and write an outline of the paper?
10:03:59 * c_wraith gets out the thesaurus and starts writing down all the synonyms for pretty
10:04:06 <c_wraith> in 16 pt font
10:04:11 <copumpkin> lol
10:04:19 <djahandarie> This plan has backfired
10:04:22 <pozic> With Comic Sans captions!
10:04:45 <djahandarie> pozic, hey, respected members of the Haskell community use comic sans regularly!
10:05:03 <merijn> pozic: Challenge accepted! I will give my literature study slides captioned in Comic Sans!
10:05:24 * hackagebot HaskellNet 0.2.4 - network related libraries such as POP3, SMTP, IMAP  http://hackage.haskell.org/package/HaskellNet-0.2.4 (RobertWills)
10:05:40 <merijn> Now if only I could get myself to finish said study...speaking of doing peoples homework for them, I don't suppose someone cares to do the reading and explaining for me? :p
10:05:41 <monochrom> Thus for example "hi I can't get length xs / 5 to typecheck, this is homework", I'll just say "fromIntegral (length xs) / 5", as opposed to a 30-minute interactive guided tour on type-checking and the standard type classes. The idea is you can easily recognize the key being fromIntegral and explore further, you don't need my guide.
10:06:27 <djahandarie> Or you can just write down the answer and not care
10:07:43 <maskd> djahandarie: such a person wouldn't be interested in a 30-minute interactive guided tour, anyway
10:08:03 <saml> @import Prelude()
10:08:03 <lambdabot> Unknown command, try @list
10:08:20 <djahandarie> maskd, what if it has explosions?
10:08:55 <monochrom> OTOH if you ask "hi I need to write a PhD thesis, this is homework", I'll just say "need a better calculus for lazy timing analysis", as opposed to writing the thesis for you. The idea is: in under 140 characters, get you to make some progress.
10:09:22 <c_wraith> homework over twitter
10:09:26 <maskd> explosions have poor educational value, in my experience
10:09:42 * monochrom is most interested in efficient communication
10:09:43 <djahandarie> monochrom, I didn't realize IRC was twitter
10:10:38 <monochrom> Oh actually I will also throw in a few URLs of prior work on this subject (such as Catherine Hope's!), so it will likely exceed 140 characters :)
10:10:41 <c_wraith> maskd: sometimes, they make you wonder "why the hell did that explode?"
10:10:42 <saml> what's wrong with Num class? is there a better version?
10:11:05 <merijn> I usually trick people into explaining my homework by summarizing what I've learned so far and them pointing out all the ways my summary was flawed and misunderstood important key facts :p
10:12:25 <monochrom> since IRC has some 256 or 512 character limit per message, it is not too far from twitter in this sense :)
10:12:54 <monochrom> "#haskell has 658 followers!"
10:15:19 <c_wraith> That's confusing.  channel names are hash tags!
10:15:37 <shachaf> RT @monochrom since IRC has some 256 or 512 character limit per message, it is not too far from twitter in this sense :)
10:16:08 <monochrom> indeed. what do they say, real life tends to mimic IRC :)
10:16:18 <c_wraith> they don't say that
10:16:23 <monochrom> haha
10:16:34 <sproingie> decent irc clients split up lines.  i guess some twitter clients will post multiple tweets too
10:16:43 <monochrom> yes
10:17:00 <monochrom> or at least such a twitter client could be implemented
10:17:04 <otzi> I suppose some twitter clients let you follow everything that comes out with a certain hashtag
10:17:08 <sipa> my twitter client does
10:17:12 <otzi> and you can even talk to other people that way
10:17:12 <sipa> it's called irssi ;)
10:17:16 <monochrom> \∩/
10:17:44 <sproingie> i really did disdain twitter for a long time but i grudgingly admit it's a decent chat medium
10:18:12 <sproingie> i still don't use it or facebook, just dont see the need
10:18:17 <sproingie> <- old fuddy duddy
10:18:32 <otzi> the good thing about twitter is the ilimited log
10:19:16 <otzi> unlimited
10:19:18 <sproingie> i dont see myself as behind the times in technology, i'm just skipping a generation of it or two
10:19:41 <sproingie> when something comes along to replace twitter and facebook then maybe i'll jump on it.  or maybe also keep waiting :)
10:20:57 <sipa> diaspora!
10:21:23 <c_wraith> diaspora's an interesting concept, but a horrible implementation in just about every way
10:21:27 <otzi> I'm on twitter and facebook, but I use it much less than IRC and e-mail
10:21:43 <otzi> but, some day, the kids from facebook and twitter will grow
10:22:47 <monochrom> manatee crashes :)
10:22:48 <roconnor> I'm pretty sure twitter and facebook is just a fad
10:23:03 <roconnor> monochrom: that's impossible.  It is written in Haskell
10:23:20 <monochrom> unless it's compiled by ghc 7 :)
10:23:35 <copumpkin> roconnor: :O
10:23:47 * copumpkin fights roconnor 
10:24:43 <invarius1> What do you guys think of this book: 020102988X ?
10:25:52 <aristid> invarius1: http://www.amazon.de/Introduction-Automata-Theory-Languages-Computation/dp/020102988X ?
10:26:08 <invarius1> Yes
10:26:16 <invarius1> First Edition
10:26:19 <monochrom> interesting way to refer to a book. but thanks to google, it works :)
10:26:58 <copumpkin> roconnor: for a fad, I find that I get an awful lot of good (even haskell-related) information from twitter
10:27:09 <roconnor> that's impossible
10:27:17 <roconnor> it is limited to a few dozen characters
10:27:18 <copumpkin> oh sorry, I was mistaken
10:27:21 <sproingie> isbn is a good way to do it, gets you a nice localized link
10:27:22 <roconnor> point roconnor!
10:27:30 <copumpkin> :)
10:27:53 <roconnor> also I don't have a twitter account, ergo it must be useless!
10:27:58 <roconnor> set and match.
10:28:00 <invarius1> Actually, this probably isn't the right channel to have asked that question but, I don't know what channel people discuss complexity theory and formal language :(
10:28:06 <copumpkin> it would certainly be more useful to me if you had one ;)
10:28:15 <monochrom> someone sent all his type errors from emacs to twitter. this is why twitter has haskell-related information
10:28:22 <roconnor> my reasoning is infoulable
10:28:46 <sproingie> invarius1: eh, general CS isn't strictly on topic here but we're all fans of it :)
10:29:00 <otzi> so, I was able to compile dbus using cabal by passing  configure --extra-include-dirs=/usr/include/dbus-1.0/ --extra-include-dirs=/usr/lib/dbus-1.0/include/ and changing a import Control.Exception to import Control.OldException. But if I use cabal-install to install the same package it works without any of that
10:29:21 <copumpkin> invarius1: #haskell tends to be the best place to talk about anything CS-related, assuming there isn't any concurrent discussion on something more strictly related to haskell
10:29:39 <otzi> does anyone know what cabal-install is doing? I assume it doesn't change Exception to OldException
10:29:45 <invarius1> sproingie: Ah, do you know the book I inquire about?
10:29:52 <otzi> perhaps it passes some parameter to ghc?
10:29:53 <invarius1> Or at least a very good book on the subject?
10:29:54 <copumpkin> roconnor: for example, http://twitter.com/#!/donsbot/status/19541842164981760
10:30:13 <sproingie> invarius1: can't say i do.  it looks like a good book to learn formalism assuming you already have a bit of CS background
10:30:22 <monochrom> I think that book is ok. The authors are well-known for this subject. I just despise the use of Turing machines for this purpose, but this is more an object to almost all books on this subject rather than just this book.
10:30:30 <monochrom> s/object/objection/
10:30:40 <sproingie> monochrom: i'm not sure it's any worse than knuth and his wacktastic MIX architecture
10:30:55 <sproingie> MMIX might fix that but it ain't done yet
10:31:09 <Cale> otzi: What's the package name?
10:31:11 <monochrom> well I completely ignore MIX to begin with
10:31:15 <otzi> dbus
10:31:15 <invarius1> sproingie: I have a bit and am always learning more. Right now I'm studying under Knuth and Skienas texts
10:31:20 <otzi> DBus 0.4
10:31:35 <invarius1> Most of everything else I know is from that of studying group theory
10:31:48 <Cale> huh, that only depends on base and bytestring with unknown versions
10:32:09 <sproingie> i never could get into knuth.  i prefer abstraction over machine-level stuff, and MIX seems the worst of both worlds
10:33:04 <invarius1> sproingie: there's lots and lots of abstraction.... o_O
10:33:11 <sproingie> that and i prefer stuff like graph theory to numerical algorithms and sorting/searching
10:33:32 <invarius1> sproingie: not to put you on the spot but have you even read any of his books?
10:33:42 <invarius1> By read, I don't mean, glance at a few pages
10:34:09 <invarius1> It certainly has a lot of what you'd like to taste :p
10:34:25 <monochrom> when you depend on base without version bounds, and you use cabal-install or more precisely "cabal install dbus", base-3 is chosen, therefore "Control.Exception" refers to the old one.
10:34:31 <otzi> It has a configure script, but it seems to me that it doesn't even get called when I do setup configure; setup build;
10:34:33 <merijn> I have Knuth on my bookshelf, but I got it right after a heavy math semester and couldn't get myself to get through the start...I mean to read it eventually. For now I started with Intro to Algorithms by Cormen et al. which seemed slightly easier to read...
10:34:49 <sproingie> couple chapters of a couple books of aocp, and yes i'm probably grinding the axe about MIX a bit much
10:35:10 <monochrom> as for /usr/include/dbus-1.0 and /usr/lib/dbus-1.0 they may be automatically figured out anyway
10:35:35 <otzi> but why doesn't it get figured out when I don't use cabal-install?
10:35:48 <monochrom> I don't know.
10:35:51 <invarius1> merijn: It is pretty math heavy, but practice in reading the text over and over definitely gets you to understand much more clearly
10:35:57 <invarius1> It's very rewarding too
10:36:22 <sproingie> i think knuth's great actually, it's probably more my failing that i couldn't get into it as much
10:36:36 <roconnor> copumpkin: :o
10:36:55 <invarius1> sproingie: maybe you should check out, "Concrete Mathematics"
10:36:59 <invarius1> That should get you up to par
10:37:11 <invarius1> Gives you a little bit of intuition
10:37:26 <otzi> monochrom: is there a flag to pass to ghc in order for it to select base-3?
10:37:32 <sproingie> cool.  i really need to brush up.
10:37:43 <copumpkin> roconnor: there are lots of minor "announcements" like that, that I find interesting and can spark good discussion. Stuff that isn't mature enough for a mailing list post or a blog post, that nevertheless people consider worth tweeting because they feel less pressure, since people signed up to read what _they_ had to say, unlike a mailing list
10:37:58 <monochrom> no. you should look for a flag to pass to cabal or setup
10:38:22 <roconnor> :D
10:38:28 <roconnor> not mature enough for a blog post
10:38:35 <roconnor> kinda cool
10:38:39 <copumpkin> :P
10:38:41 <monochrom> there are --constraint and --preference and I keep forgetting which is which but do try each of them in turn
10:38:43 <roconnor> I didn't think there was a lower level
10:38:45 <Cale> I think that using an assembly language for any discussion other than one about compilation is a bit odd though.
10:38:56 <roconnor> copumpkin: no seriously.  That is neat
10:39:01 <copumpkin> I just feel that (if I had a blog), I'd feel more pressure to write up something fairly coherent
10:39:10 <roconnor> it's true
10:39:17 <copumpkin> whereas I can just say "yo, I'm tinkering with X" on twitter
10:39:19 <roconnor> twiter < blog post < reasearch paper
10:39:32 <sproingie> it's weird how i dislike machine-level stuff yet i have a soft spot for forth
10:39:40 <copumpkin> roconnor: yeah, that's a decent way to put it, I think
10:39:40 <sproingie> maybe it's because of how quickly you can abstract with it
10:40:08 <merijn> It's weird how I dislike machine-level stuff yet love it at the same time :p
10:40:09 <copumpkin> roconnor: now, under that formulation, I can see how many people might not want to bother with such incomplete thoughts
10:40:23 <copumpkin> so I'll stop bugging people about hating on twitter :P
10:40:39 <roconnor> yes, but they also might be missing out
10:40:52 <roconnor> how about
10:40:58 * Cale has enough trouble with the concept of a blog
10:41:01 <roconnor> IRC < twitter < blog post < reasearch paper
10:41:25 <copumpkin> roconnor: I'm not sure IRC fits in the same category
10:41:30 <medfly`> IRC < twitter?
10:41:42 <absentia> IRC > twitter.  don't be daft.
10:41:44 <copumpkin> the other three are all about an announcement of one's ideas to the world, in some sense 
10:41:49 <copumpkin> IRC is more for direct discussion
10:41:50 <absentia> twitter = joke
10:41:51 <copumpkin> as is a mailing list
10:42:11 <copumpkin> IRC < mailing list (in terms of well-formedness of ideas)
10:42:18 <roconnor> copumpkin: okay
10:42:19 <copumpkin> twitter < blog post < research paper (in terms of well-formedness of ideas)
10:42:21 <invarius1> okay, I will drop 9780201029888 and grab 9780201441246 instead, then grab 9780201029888 a bit later :)
10:42:28 <absentia> ug
10:42:32 <aristid> invarius1: wtf?
10:42:46 <copumpkin> I guess I can show up on #haskell and say "yo I've been working on X. discuss"
10:42:47 <roconnor> invarius1: you don't recoginize ISBN numbers?
10:43:03 <invarius1> huh?
10:43:04 <roconnor> aristid: : you don't recoginize ISBN numbers?
10:43:04 <copumpkin> but it feels more ephemeral and more like I'm boring people
10:43:12 <ray> you can only get a preordering on that shit at best
10:43:18 <Cale> invarius1: Do you have Sipser?
10:43:27 <invarius1> sipser?
10:43:33 <aristid> roconnor: uh, not in that format at least.
10:43:35 <invarius1> you're all confusing now
10:43:38 <Cale> http://www.amazon.com/Introduction-Theory-Computation-Michael-Sipser/dp/0534950973/ref=pd_sim_b_1
10:43:41 <aristid> invarius1: how about just using links to amazon?
10:43:46 <monochrom> 9780201029888 is a new kind of ISBN
10:43:48 <invarius1> Cale: oh, yes, I do :)
10:43:55 <Cale> I just refer to books by their authors' last names.
10:44:01 <ray> you mean an isbn for a stephen wolfram book?
10:44:06 <monochrom> also "ISBN numbers" is like "automatica ATM teller machines" :)
10:44:11 <invarius1> aristid: I don't use amazon...
10:44:13 <Cale> lol
10:44:27 <aristid> invarius1: well, or any other website. something that i can directly click on :)
10:44:28 <roconnor> fair
10:44:32 <sproingie> international standard ISBN book number
10:44:44 <monochrom> three-letter TLA acronyms
10:44:50 <djahandarie> ISBN: ISBN standard book number
10:44:56 <aristid> sproingie: clearly it is international standard book ISBN number
10:44:57 <sproingie> ooh
10:45:56 <monochrom> http://www.amazon.com/Specifying-Systems-Language-Hardware-Engineers/dp/032114306X/ :)
10:46:26 <invarius1> You're unable to query ISBNs?
10:46:45 <monochrom> I'm able to.
10:46:58 <Cale> It's just tedious
10:47:00 <invarius1> I suppose if I ask, I should make it easier to find out the information
10:47:05 <monochrom> But giving a URL is more convenient for the audience.
10:47:05 <invarius1> :p
10:47:08 <invarius1> Yes
10:47:31 <invarius1> Cale, do you know of a more advanced text on formal language?
10:47:39 <monochrom> What they say, an extra minute of work by the writter saves 60 minutes of work by the audience.
10:48:00 <invarius1> Most text I have found is usually introductory level or graduate papers :\
10:48:02 <Cale> invarius1: Not really. I've learned what I know about formal languages from a random bunch of places on the web.
10:48:13 <Cale> and papers, yeah
10:48:23 <sproingie> invarius1: hard to find that intermediate level stuff, isn't it?
10:48:38 <Cale> (but I don't really know all that much)
10:48:50 <invarius1> sproingie: just more advanced.. I find that intermediate level stuff is always skipped by learning the advanced stuff :p
10:49:18 <sproingie> invarius1: the notation tends to be a problem
10:49:22 <Cale> gio123 made me learn more than I really wanted to know about regular languages and automata
10:49:28 <invarius1> sproingie: what do you mean?
10:49:30 <merijn> invarius1: Teach me your trick for doing that
10:49:35 <invarius1> That's the point of the subject! xD
10:49:41 <invarius1> @ sproingie
10:49:44 <sproingie> invarius1: i find the advanced stuff often jumps into notation that isn't familiar
10:49:48 <invarius1> merijn: ?
10:50:00 <invarius1> sproingie: of course, that's why you learn it ;)
10:50:06 <merijn> invarius1: I'm trying to skip to learning the advanced stuff, but I get hopelessly stuck in trying to understand the advanced stuff's notation :p
10:51:07 <copumpkin> could the reverse state monad, or any of those recently discussed reverse-effect transformers, be encoded as an indexed monad?
10:51:10 <invarius1> merijn: ah, I can understand. Just take sure you take notes and translate it all into your native language. Relate the syntax to the way you'd formalize it and eventually, you should just understand what's notated written as is by intuition
10:51:20 <invarius1> s/take/make/
10:51:49 <sproingie> i can only think of one mathematical concept that really blew me away with elegance and practicality and that was learning about adjacency matrices
10:51:59 <sproingie> and how their nth power shows how many paths of length n exist
10:52:10 <manateeUser> Hmm, Memory is big problem when dynamic loading library, Manatee Irc Client use 8MB before link, use 46MB after linked.
10:52:21 <invarius1> sproingie: what about pascals triangle? :p
10:52:30 <sproingie> all of calculus just drowned me in tedium, for example
10:52:32 <Cale> You can do a not-so-bad job of getting started with formal languages by browsing around on wikipedia and then looking for papers to back up the things you read.
10:52:32 <manateeUser> But dynamic loading speed is very fast. :)
10:52:48 <copumpkin> sproingie: oh yeah, that's nice
10:52:55 <Cale> sproingie: That's too bad about Calculus
10:53:20 <merijn> My main gripe with advanced stuff is that the academic writing style of papers and good explanations appear to be mutually exclusive
10:53:20 <Cale> sproingie: I've probably recommended Spivak's text to you before?
10:53:24 <copumpkin> anyone know about indexed monads?
10:53:37 <invarius1> Cale: I find that wikipedia has a tendency to mislead you, a lot... But the bibliographies kind of back it up a little bit more formally
10:53:48 <djahandarie> Calculus on Manifolds?
10:53:53 <Cale> djahandarie: Just "Calculus"
10:54:07 <Cale> Calculus on Manifolds is also good
10:54:11 <Cale> But very different.
10:54:17 <djahandarie> Hm, I don't really like Calculus
10:54:25 <Cale> Oh?
10:54:34 <invarius1> Cale: Spivak's text on Calculus could be a little daunting in the beginning 
10:54:37 <sproingie> Cale: yah i recall that.  should put it on my wish list i suppose.
10:54:50 <invarius1> djahandarie: same :p
10:54:54 <Cale> http://cale.yi.org/share/Michael%20Spivak%20-%20Calculus.pdf
10:55:02 <djahandarie> I guess the elegence of Calculus on Manifolds is what made me like it
10:55:04 <merijn> I appear to have misplaced cabal...what the best approach on OSX? Install Haskell Platform, then GHC7 then update everything using cabal or install GHC7 then manually install cabal?
10:55:09 <monochrom> manateeUser: This is because dynamic loading essentially loads up another copy of all haskell libs (base, mtl, gtk...)
10:55:10 <djahandarie> I can learn all the other stuff by myself :)
10:55:19 <manateeUser> Maybe recompile new version is good idea after dynamic loading.
10:55:23 <invarius1> Cale: That is highly illegal
10:55:32 <djahandarie> Highly?
10:55:35 <medfly`> invarius1, no it's not
10:55:37 <copumpkin> as opposed to slightly illegal
10:55:44 <djahandarie> copumpkin, I see.
10:55:44 <invarius1> Piracy is a federal offense you know
10:55:50 <manateeUser> monochrom: Yep, if you dynamic loading many times, memory will increase.
10:55:52 <merijn> invarius1: Who says its piracy?
10:55:59 <medfly`> invarius1, too bad that only you live in the shitty US.
10:56:03 <Cale> It's just the usual sort of unenforceably illegal that piracy is.
10:56:18 <copumpkin> it's not just illegal! it's immoral!!!!
10:56:23 <invarius1> immoral?
10:56:25 <medfly`> GOD WILL PUNISH YOU
10:56:27 <invarius1> No, sharing is caring :p
10:56:28 <Cale> copumpkin: :)
10:56:37 <copumpkin> the law clearly corresponds to morality
10:56:38 <invarius1> But sharing is also socialism 
10:56:39 <djahandarie> copumpkin, would that be slightly or highly immoral?
10:56:49 <hvr> copumpkin: in which universe?
10:56:50 <merijn> Papers are very often also liberally licensed and piracy is only illegal in sucky countries...
10:56:56 <copumpkin> hvr: ours!
10:56:56 <sproingie> michael spivak to me is the guy who invented some silly gender-neutral pronouns :)
10:56:56 <invarius1> :p
10:57:00 <manateeUser> monochrom: I hope this problem will fix by GHC.
10:57:04 <monochrom> calculus (differentiation, integration) is not tedious. calculus homework is tedious, and even that is artificially so. I would give out non-tedious calculus homework.
10:57:05 <djahandarie> Man the conversation in this channel sure bounces all over the place sometimes
10:57:23 <manateeUser> monochrom: Release memory to OS if no pointer reference old address.
10:57:26 * djahandarie just took it to the meta level
10:57:28 <medfly`> differentiation and integration by hand is tedious
10:57:32 <Cale> The homework is a large part of what makes Spivak's book good :)
10:57:35 <invarius1> I've rarely studied calculus. I cannot even say I'm familiar with what a calculus really is
10:57:43 <invarius1> :(
10:57:44 <aristid> merijn: for the authors of papers, piracy is probably purely good. only journals may get damage from it
10:57:49 <medfly`> invarius1, should've pirated more
10:57:55 <Gracenotes> instead of 30 problems, 5 problems that make you think
10:57:56 <merijn> I know multiple calculi and I still don't know what calculus means :p
10:57:59 <Cale> It has lots of questions which have answers that you can actually care about.
10:58:03 <rjo> I once tried to do two weeks one single integration, and did not succeed
10:58:07 <rjo> that was tedious
10:58:10 <medfly`> Cale, if you're a mathematician
10:58:21 <invarius1> Reimann sums are as far as I got
10:58:23 <manateeUser> monochrom: Anyway, it's still a good model, that you can modify your program when it running and won't lose any state. :)
10:58:24 <monochrom> My idea of homework is getting some points across. Most teachers' idea of homework is assignment so much work to ensure a bell curve by guaranteed incompletion.
10:58:37 <monochrom> s/assignment/assigning/
10:58:42 <Gracenotes> rjo: next time you shouldn't try taking a limit to infinity :)
10:59:07 <Cale> Not like "Oh great, the integral of this random function on such and such interval is 54 pi + log(cos(1))"
10:59:22 <medfly`> Cale, that's more useful than some mathematics
10:59:36 <Cale> Problems whose answer is a number are usually pretty dull.
10:59:45 * monochrom is particularly not fond of the attitude "pretend that my course is the only course you're taking"
10:59:49 <medfly`> well, sometimes you need only the number to get shit done.
10:59:52 <rjo> it was gaussian integral over all paths and got up to the computing determinant of infinite matrix
10:59:57 <Gracenotes> oh god
10:59:58 <Cale> Sure, it has some of those, but it also has plenty which are not :)
11:00:05 <manateeUser> Off to test. :) 
11:00:05 <Gracenotes> rjo: ....well that would do it
11:00:07 <Cale> medfly`: If you only need the number, you could just numerically approximate
11:00:17 <rjo> I messed always to boundary conditions and did not got solution to recursion eqs
11:00:18 <medfly`> Cale, good
11:00:23 <medfly`> Cale, that's all I need
11:00:45 <Cale> medfly`: and the whole exercise would be pointless -- the answer would be to use a computer and the trapezoid rule :P
11:00:48 <medfly`> now stop teaching me stupid maths
11:00:59 <merijn> I appear to have misplaced cabal...what the best approach on OSX? Install Haskell Platform, then GHC7 then update everything using cabal or install GHC7 then manually install cabal?
11:01:24 <Cale> merijn: I'd do the latter, though I'm not sure I'd go with GHC 7 yet
11:01:53 <invarius1> Cale: Are there any relations from Haskell to Mathematical wikis or anything of the sort?
11:02:12 <Cale> invarius1: hmmm
11:02:12 <rjo> however, you I learned quite a lot, not succeeding rewards sometimes a lot in sense of learning things
11:02:40 <sproingie> thank goodness for my VPS host, couldn't grab that pdf from work
11:02:47 <sproingie> (we block dynamic dns sites)
11:02:49 <Cale> rjo: Sounds like quite an integral :)
11:03:05 <medfly`> Cale, maybe he just should've fed it into a computer
11:03:22 <merijn> Cale: I mostly want to play with the new IO manager and don't really care about my code compiling, so GHC7 should be good enough
11:03:23 <sproingie> i really should get on the unfiltered network so i can do investigations properly
11:03:39 <Cale> merijn: okay :)
11:04:19 <Cale> merijn: Then I recommend grabbing the generic binary from the GHC website and then getting cabal-install separately. I don't recall if the version on Hackage is supposed to be sufficient or not.
11:04:27 <Cale> You might need the darcs version.
11:04:53 <Cale> If you install the Haskell Platform and then GHC 7, the libraries will all be separate anyway.
11:05:04 <Cale> So you won't have accomplished much installing HP first.
11:06:03 <rjo> medfly': I think that computing these integrals is in most cases computationally intractable
11:07:56 <djahandarie> Cale, have you read Functional Analysis by Riesz?
11:08:01 <rjo> it reflects the thing that quantum computing is as efficient as it is
11:08:16 <Zao> Speaking of quantum computing - http://arxiv.org/abs/1009.3081
11:09:18 <djahandarie> Zao, what about that paper?
11:09:50 <Zao> Non-theoretical progress on a largely vapour-based field.
11:09:54 <Zao> That's kind of neat.
11:10:10 <Cale> djahandarie: No. I have Conway's book, but I don't really care much for it.
11:16:15 <dpratt71> so I came across "Programming Languages - Theory & Practice" the other day (http://goo.gl/q56gk)...
11:16:20 <dpratt71> ...I've been muddling through it, but now I'm at section 5.4 Renaming, and I feel that I don't truly understand it...
11:16:29 <dpratt71> ...is there another resource that might explain it more clearly and/or is someone willing to try to make me understand it?
11:17:04 <invarius1> Is there a method on how I can find Journals and Graduate Papers?
11:17:24 <invarius1> I'm not sure how to look them up
11:17:47 <merijn> Google Scholar?
11:18:08 <merijn> As good a starting point as any in my experience
11:18:35 <invarius1> that art of the qubit...
11:18:45 <invarius1> a tricky system :(
11:21:44 <dankna> invarius1: well, you want to look at the site of the journal's publisher
11:21:55 <dankna> invarius1: for example any journal published by the ACM is on their site
11:22:07 <dankna> access is usually not free
11:22:21 <dankna> for some things, citeseer is a good resource, as it saves PDFs of anything that it's legally allowed to
11:22:28 <invarius1> dankna: I've never published a journal or academic scholarly paper. What are some of the many known publishers?
11:22:40 <invarius1> citeseer
11:23:08 <dankna> neither have I, so I only know a little.  citeseer is a search engine.  well, there's the ACM (Association for Computing Machinery) and there's JStor which is a database that cuts across publishers -
11:23:09 <monochrom> ACM, IEEE, Springer.
11:23:15 <burp> arxiv.org
11:23:16 <dankna> most publishers are affiliated with universities
11:23:20 <monochrom> Elsevier
11:23:27 <sproingie> citeseer is a search engine and repository
11:23:36 <invarius1> monochrom: I thought Springer published Books
11:23:39 <monochrom> oh, forgot Cambridge University Press
11:23:43 <invarius1> and IEEE was very high up there
11:23:46 <dankna> if you have a citation, that includes the name of the journal and you can search that to find the site that goes with it
11:23:51 <sproingie> ACM and IEEE are nice but pricey
11:23:55 <monochrom> Springer publishes books and journals
11:23:58 <invarius1> Hmm, okay
11:24:07 <invarius1> This is good information. Thank you all :)
11:24:10 <dankna> np
11:24:11 <monochrom> Acta Informatica is a Springer thing IIRC
11:24:17 <merijn> If you're a student ACM is pretty cheap, and lots of universities have blanket subscriptions for all students
11:24:19 <sproingie> tho i can't swing a dead cat without hitting an ACM member around here so if i really need a paper i could probably just ask a co worker
11:24:48 <invarius1> xD
11:25:04 <invarius1> ACM has many papers?
11:25:04 <sproingie> tho they might not oblige after being smacked with a dead cat
11:25:10 <sproingie> they have oodles
11:25:15 <sproingie> all behind a paywall
11:25:28 <sproingie> citeseer also has many papers and they're all free
11:25:59 <rjo> that system is totally annoying
11:26:13 <monochrom> for free stuff you have to find on author's home page. usually through google and citeseer
11:26:38 <rjo> some publisher do not allow even indexing abstracts through scholar.google
11:26:39 <sproingie> i cant begrudge acm, they have to fund somehow
11:26:43 <monochrom> citeseer has free papers iff author has it on home page
11:26:45 <ray> stupid paywalls
11:26:57 <invarius1> publishers suck then
11:27:09 <sproingie> as professional associations go, ACM is super cheap
11:27:11 <monochrom> this is why Knuth calls for a revolution
11:27:18 <invarius1> I agree
11:27:41 <sproingie> i guess not so cheap if you're in sri lanka or something
11:28:05 <invarius1> I'm in africa
11:28:24 <ray> well if you get your professorship you have less incentive to care
11:28:36 <invarius1> :p
11:29:00 <sproingie> citeseer usually has more than enough for ambituous self-taught students
11:29:12 <mikeg> With TH, can I use ImportF/forImpD to import stuff from another Haskell module? If so, how?
11:29:39 <saml> learn me a hskell for greater good
11:29:53 <sproingie> yay
11:31:16 <ray> i just sleep in a university dumpster and steal their wifi when i want to read papers
11:31:18 <monochrom> http://www.google.ca/search?q=knuth+donald+torrent haha
11:31:49 <invarius1> I hate Barnes and Nobles 
11:32:03 <invarius1> I'm amazed how cheap taocp v4a is though 
11:32:33 <sproingie> isn't it still a draft?
11:32:44 <Mathnerd314> ray: how do you get food?
11:32:45 <invarius1> No
11:33:27 <ray> usually from the grocery store
11:33:41 <invarius1> 4a is the composition of all 5  fascials
11:34:46 <monochrom> http://www-cs-faculty.stanford.edu/~uno/joalet.pdf  Knuth saying what is going wrong with publishers
11:35:07 <invarius1> monochrom: thank you, I will read this
11:36:31 <sproingie> i wonder whether knuth inlined the source code for that letter :)
11:36:50 <ray> wow i hope so
11:37:00 <copumpkin> preflex: seen kmc
11:37:00 <preflex>  kmc was last seen on #haskell 1 day, 20 hours, 46 minutes and 34 seconds ago, saying: Rational is probably fast enough for most stuff (don't forget, orders of magnitude more people use CPython than will ever use GHC) but don't be surprised if Double is a lot faster
11:38:00 <invarius1> I think every day, I am becoming more research oriented
11:38:18 <invarius1> almost like some type of graduate student
11:38:49 <invarius1> I work all day, then stay up all night studying, barely eat anything, documenting almost everything, etc etc 
11:38:57 <invarius1> is this a good or bad thing?
11:39:41 <monochrom> you should eat. otherwise it's fine.
11:39:49 <dankna> it's a good thing, haha
11:39:56 <copumpkin> invarius1: haskell has that effect on people
11:39:58 <aristid> invarius1: make sure to sleep enough :)
11:40:10 <monochrom> steal some work time for eating.
11:40:16 <invarius1> aristid: I actually take power naps though out the day
11:40:34 <invarius1> that way everything is evenly spaced, not a huge sum of laying around 
11:40:41 <invarius1> helps with my memorization 
11:40:56 <invarius1> copumpkin: what'
11:41:10 <invarius1> copumpkin: what's funny is, I don't even know haskell yet :(
11:41:15 <copumpkin> hah!
11:41:16 <mafs> and then steal some eating tiem for sleeping
11:41:35 <mafs> s/tiem/time/
11:41:36 <invarius1> oh this friday, I'm going to have a feast! :D
11:41:46 <invarius1> maybe
11:41:52 <monochrom> you should spread out your eating too, you know
11:42:01 <invarius1> oh I do.. 
11:42:05 <invarius1> or don't eat at all lol
11:42:05 <ray> so
11:42:11 <invarius1> I have a pear in my pocket :D
11:42:19 <ray> hackage has no quaternion libraries
11:42:22 <mafs> Really, it sounds like the suggestion is to have dedicated eating time...why not eat while studying?
11:42:36 <invarius1> I eat fruit when my stomach feels empty
11:42:38 <monochrom> what they say, a pear in the stomach is better than two pears in the pocket
11:43:08 <invarius1> monochrom: well obviously.. lol
11:43:17 <invarius1> what good is a pear in your pocket? :\
11:43:18 <monochrom> no, don't eat while studying. eat while working for capitalistic boss.
11:43:25 <invarius1> no
11:43:26 <ray> i have a quaternion library
11:43:31 <ray> but it isn't fit for human consumption
11:43:37 <monochrom> steal from boss, not from yourself
11:43:44 <invarius1> hahaha
11:45:04 <invarius1> Knuth is complaining about prices because he
11:45:09 <invarius1> he's poor?***
11:45:11 <invarius1> lol
11:45:21 <ray> it also uses my custom typeclasses that allow for scalar products and hamilton products to both use *
11:45:22 <monochrom> no, because libraries are poor
11:45:29 <invarius1> I know :p
11:45:30 <rjo> thanks for the Knuth article
11:45:34 <ray> don't forget students, we're also poor
11:45:51 <invarius1> ray, as if a student could forget
11:45:55 <monochrom> and because publishing cost is decreasing not increasing.
11:45:57 <sproingie> knuth's students probably aren't poor either.  but many of his potential readers are.
11:46:17 <invarius1> I think knuths students are failures 
11:46:27 <invarius1> most of them
11:46:31 <monochrom> all university libraries (and all universities) are perpetually underfunded.
11:46:44 <invarius1> monochrom: that sounds insane
11:46:54 <Mathnerd314> I've seen people doing supercompilation on Haskell. Is there an introduction somewhere?
11:47:13 <merijn> What is "supercompilation"?
11:47:23 <ray> it's probably locked up in a blog post beyond a searchwall
11:47:27 <dmhouse> Like compilation but REALLY FUCKING AWESOME
11:47:39 <sproingie> public universities are underfunded.  i would not say the same of all universities
11:47:40 <invarius1> Please don't swear so hard
11:47:41 <Mathnerd314> merijn: exactly what I'm trying to figure out
11:48:00 <invarius1> sproingie: private universities don't sound fun at all
11:48:13 <merijn> Mathnerd314: Sounds like a made up term to me
11:48:33 <sproingie> invarius1: what do you think stanford is?  (that's where knuth teaches)
11:48:45 <monochrom> anyway, you look at what a publisher really pays for a journal and you see the price quote is insane. essentially a secretary or two, printing, mailing. that's it. not even paying for editors.
11:49:00 <dankna> the interesting point is that (most) universities don't release their financials
11:49:06 <invarius1> sproingie: he doesn't teach there
11:49:16 <invarius1> (right now)
11:49:18 <dankna> are they on the brink of collapse or do they have enough buffer to handle two recessions at once?  who knows?
11:49:25 <sproingie> oh right he's prof emeritus now
11:49:49 <monochrom> editors for academic journals are volunteer work and referees are volunteer work too. TeX implies that typesetting is volunteer work too.
11:50:31 <tonkman> is return and (>>=) compulsory function to define, when writing a monad class instance?
11:50:33 <arjanb> Mathnerd314: what worked for me, was reading neil mitchell's icfp'10 paper followed by "supercompilation by evaluation"
11:50:43 <monochrom> ok, public universities are perpetually underfunded. but that already hurts enough.
11:50:45 <invarius1> I should go back to school, but.. I don't have money :(
11:50:50 <tonkman> *only compulsory...
11:51:14 <dankna> tonkman: I believe you also need fail
11:51:29 <invarius1> Did any of you read, " http://www.amazon.com/Computability-Complexity-Languages-Second-Fundamentals/dp/0122063821 " ?
11:51:30 <Mathnerd314> arjanb: that's "rethinking supercompilation"?
11:51:39 <arjanb> yeah
11:51:49 <ray> nope it's default error something
11:52:03 <ray> bind and return is minimal complete definition
11:52:12 <dankna> oh okay
11:52:22 <tonkman> ray, thanks
11:54:25 <mm_freak> is it necessary to use the -threaded flag for a library?
11:54:46 <c_wraith> mm_freak: no
11:55:05 <monochrom> -threaded is for linking (producing an executable)
11:55:45 <mm_freak> ok, thanks
11:55:54 <monochrom> all it does is choosing one of two runtimes.
11:58:29 <mm_freak> btw, is there a minimalistic runtime system for embedded devices?
12:00:55 * hackagebot ismtp 1.0.0 - Incremental SMTP sessions  http://hackage.haskell.org/package/ismtp-1.0.0 (ErtugrulSoeylemez)
12:01:09 <invarius1> The discussions on amazon.com are dumb.... I guess all of the educated people just don't acknowledge anything there
12:02:24 <aristid> all generalisations are invalid
12:03:20 <dankna> ooh ooh.  "Every statement in _Goedel, Escher, Bach_ is false."
12:03:39 <maltem> invarius1, discussions as in product ratings? Those are just there to boost sales, not to be of any practical use
12:05:03 <invarius1> maltem: no, the forums
12:06:17 <maltem> Oh, so there are forums on amazon.com :)
12:06:58 <winxordie> maltem: yep, complete with intellectually-deep topics such as IS GLOBAL WARMING A FRAUD?
12:07:26 <maltem> heh
12:08:19 <invarius1> winxordie: lol
12:08:59 <invarius1> I would like to find a forum that contains "intellectually deep" discussion
12:08:59 <invarius1> that'd be pretty nifty
12:09:24 <sproingie> dankna: that comment on GEB is a joke when you think about it
12:09:50 <maltem> Is there some standard trick that people use to get functions like withForeignPtr, withCString etc. to work in any MonadIO?
12:10:02 <sproingie> oh nvm, now i see what you did there
12:10:50 <dankna> sproingie: yes, that was rather my point
12:11:08 <c_wraith> maltem: there really isn't.  You'll have to do the in/out trick for your particular monad
12:11:22 <sproingie> some of the reviews on amazon are comedy gold
12:11:22 <dankna> oh, yes, you realized it.  yes :)
12:11:37 <maltem> c_wraith, oh, that's unfortunate
12:12:21 <c_wraith> maltem: basically, those functions require the ability to convert m to and from IO.  MonadIO only goes one direction
12:14:13 <maltem> c_wraith, I could imagine hypothetical variants of those functions that work with MonadIO right away, but maybe that would mean that I had to rewrite base
12:14:24 <c_wraith> maltem, yeah.  that would work :)
12:14:34 <monochrom> http://hackage.haskell.org/package/monad-peel solves this problem
12:15:21 <invarius1> do any of you know an open alternative to Acrobat Distiller? 
12:15:54 <winxordie> invarius1: me too :(
12:16:14 <invarius1> ?
12:16:35 <winxordie> a forum with "intellectually deep" topics would be a lovely find
12:16:40 <invarius1> ah
12:16:53 <maltem> monochrom, what part of that package exactly would be of use to me? The MonadPeelIO class? 
12:17:13 <invarius1> Yeah, news.ycombinator is getting closer 
12:17:17 <13WAAXTXV> yoyo people
12:17:33 <monochrom> there is some way to call liftIOOp or liftIOOp_ 
12:18:53 <maltem> thanks monochrom, I'll have a closer look
12:19:54 <monochrom> Is it ok if I just contrive an example of withFile?
12:21:11 <mm_freak> somehow each time i upload a new package to hackage i always realize that i've forgotten something…  too late of course
12:21:49 <aristid> mm_freak: fortunately you can upload a dot-dot-dot release :)
12:22:44 <mm_freak> aristid: two minor uploaded revisions in my packages correspond to one real revision =)
12:23:01 <burp> dor-dot-dot-dor
12:23:11 <mm_freak> ok, next try
12:23:22 <aristid> mm_freak: it also maximises the free advertisement by hackagebot ;)
12:23:25 <maltem> monochrom, feel free to contrive as you see fit!
12:23:37 <mm_freak> aristid: true =)
12:23:47 <megatron242> Hi, small question: I'm using openFile to open a file and read its content to a string. The problem is that when I close the file hansle, the string is no longer there. What should I do?
12:24:01 * hackagebot ismtp 1.0.1 - Fast, incremental ESMTP sessions  http://hackage.haskell.org/package/ismtp-1.0.1 (ErtugrulSoeylemez)
12:24:04 <mm_freak> megatron242: the string is still there
12:24:18 <mm_freak> unless, of course, you don't use it, in which case it's garbage-collected
12:24:45 <megatron242> putStrLn before closing the handle prints the content, and after it's closed, nothing is printed.
12:25:03 <mm_freak> megatron242: paste to code to hpaste
12:25:05 <c_wraith> megatron242, you've just discovered lazy IO!
12:25:14 <mm_freak> yeah, probably
12:25:16 <maltem> megatron242, the Prelude I/O functions are quite enervating at times. I'd suggest to use the equivalents for strict bytestrings
12:25:52 <mm_freak> megatron242: as a side note, there is also the 'readFile' function
12:25:56 <mm_freak> :t readFile
12:25:57 <lambdabot> FilePath -> IO String
12:26:06 <mm_freak> :t readFile >>= putStr
12:26:07 <lambdabot>     Couldn't match expected type `IO String'
12:26:07 <lambdabot>            against inferred type `[Char]'
12:26:07 <lambdabot>       Expected type: IO String
12:26:14 <mm_freak> :t readFile >=> putStr
12:26:15 <lambdabot> FilePath -> IO ()
12:27:30 <megatron242> OK, I guess readFile is what I'm looking for. Thanks.
12:28:06 <mm_freak> you're welcome, but in general it's better to avoid lazy I/O (readFile is lazy)
12:30:20 <megatron242> Another question: I tried to implement a simple web server, like in the following URL: http://haskell.org/haskellwiki/Simple_Servers, the problem is that sometimes I get a connection reset error (like every few fast page referesh).
12:30:37 <megatron242> Any ideas?
12:31:48 <13WAAXTXV> links broken?
12:32:33 <megatron242> What links? the link I posted in my question?
12:33:01 <c_wraith> some irc clients will interpret the comma as part of the link, which breaks it.
12:33:06 <c_wraith> If it's broken for you, remove the comma
12:34:37 <rjo> ? "Receipt of a SYN message on a port where there is no process listening for connections."
12:35:03 <rjo> what example you used?
12:35:39 <parcs> which method is preferred for simple infinite loops: forever $ do {body} or tail recursion?
12:35:55 <mm_freak> parcs: if it's monadic, then 'forever'
12:36:28 <mm_freak> it's the same, but 'forever' looks nicer and makes the code more readable
12:36:59 <parcs> thought so
12:37:34 <monochrom> maltem: http://hpaste.org/42625/monadpeel_example
12:38:54 <EvanR-work> parcs: or, iterate, or, cycle, or repeat
12:39:30 <mm_freak> > let abort = Cont . const in runCont (forever (abort 15)) id
12:39:31 <lambdabot>   Not in scope: data constructor `Cont'
12:39:38 <mm_freak> ?!
12:39:38 <lambdabot> Maybe you meant: . ? @ v
12:39:59 <maltem> monochrom, marvelous, now I just need to get the MonadPeel(IO) instance for iteratees going. The Continue case looks a little tricky
12:40:27 <monochrom> haha, I didn't know you have that goal :)
12:40:29 <monadic_kid> anyone recognize this warning message from cabal: unrecognized options: --with-hc
12:41:00 <invarius1> lol, I can petition to use A High Level Computer Language as my second language for PhD
12:41:09 <dcoutts> monadic_kid: it'll be a package with an autoconf ./configure script
12:41:09 <lambdabot> dcoutts: You have 5 new messages. '/msg lambdabot @messages' to read them.
12:42:26 <maltem> monochrom, :) what actually makes it tricky is that I don't really grok the type signatures in monad-peel. I annotated the paste with some wild guesses
12:43:50 <monochrom> yeah, I only know how to use liftIOOp etc. I don't know what peel and peelIO should do.
12:44:39 <monochrom> especially peel since it involves 3 monads and 1 transformer. pretty scary.
12:46:24 <maltem> I understand so much that the t = Iteratee s …
12:48:15 <mm_freak> maltem: what are you trying to do?
12:49:59 <monochrom> oh, I see why it will be difficult. Iteratee/Enumerator is like ContT. No one has figured out MonadPeelTrans or MonadPeelIO for ContT yet.
12:51:25 <maltem> mm_freak, define instances for MonadPeel[IO] (Iteratee s), in the hope that it has elegant consequences. Originally I wanted an enumerator interface for zlib, which I figured out for (Iteratee ByteString IO ByteString), but I'd rather have it for an arbitrary MonadIO
12:51:46 <maltem> monochrom, oh, that isn't too good news
12:52:40 <mm_freak> i think it's easy to add individual IO features to ContT
12:57:22 <Evet> which graph database you suggest?
13:00:15 <copton> BONUS: thank you very much for learnyouahaskell.com! I really love reading it.
13:02:17 <aristid> preflex: seen BONUS
13:02:17 <preflex>  BONUS was last seen on #haskell 2 days, 6 hours, 57 minutes and 31 seconds ago, saying: too late i already did haha
13:04:43 <monochrom> @tell BONUS copton says thank you very much for learnyouahaskell.com! I really love reading it.
13:04:43 <lambdabot> Consider it noted.
13:07:38 <maltem> monochrom, the following typechecks, but I have no idea what it means:  case step of Continue k ->   peel >>= \f -> return (continue (help . f))
13:08:06 <maltem> wait, wrong file
13:08:29 <maltem> ok, false alarm
13:09:32 <maltem> this was all very wrong
13:11:54 <cncl> is there a go-to resource for someone interested in getting serious with optimizing haskell code?
13:12:07 <cncl> profiling, understanding evaluation, stuff like that
13:12:17 <c_wraith> cncl, the performance chapter of rwh is a good start
13:12:20 <c_wraith> @rwh
13:12:21 <lambdabot> Maybe you meant: rc run wn
13:12:22 <cncl> (beyond the sort of introductory stuff in real world haskell)
13:12:23 <c_wraith> err
13:12:27 <c_wraith> ah
13:12:29 <cncl> :)
13:12:41 <c_wraith> Beyond that?  Folklore, at this point.  Or asking the people involved directly.
13:12:54 <c_wraith> There is lots of information out there, but it's not indexed well
13:13:05 <cncl> yeah that is what i have encountered so far
13:13:15 <c_wraith> Answers on stack overflow, comments on blogs, bug reports for ghc, etc
13:15:03 <cncl> i'm still bad at spotting space leaks in code just by eye
13:16:01 <c_wraith> I learned most of what I know by tracking down problems in software written by myself (or my co-workers)
13:16:26 <roconnor> cncl: thankfully spack leaks typically blow up in your face at runtime :)
13:16:56 <cncl> roconnor: usually, but for the first time i'm working on long-running processes and i notice that they can creep up slowly over time
13:17:05 <roconnor> :O
13:17:45 <cncl> "long-running" in this case meaning a couple of days
13:17:49 <c_wraith> can you accelerate the problem?
13:17:59 <cncl> yes, that's what i've been doing so far
13:18:09 <cncl> hammering it and looking for parts that bloat up quickly
13:18:25 <cncl> seems kind of like a chaotic way to go about it, though
13:18:32 <c_wraith> Sounds like you're doing everything I did.
13:31:21 <cncl> i remember reading an article a few months back, talking about how most haskell job applicants do not understand optimization/evaluation well enough
13:31:25 <cncl> can't find it now, though
13:31:37 <invarius1> What IDE is nice to use for haskell?
13:32:18 <monochrom> emacs, yi, eclipse
13:34:06 <nostard> cncl: please link it if you find it again =)
13:38:49 <roconnor> cncl untill last year I didn't even know that GHC had a stack
13:39:07 <pozic> roconnor: stack overflow didn't ring a bell?
13:39:17 <roconnor> pozic: not really for some reason
13:39:34 <roconnor> pozic: I always imagined graph reduction operational semantics
13:39:36 <djahandarie> I think my new activity is going to be golfing programs to <= 140 characters and tweeting them
13:39:39 <pozic> It's kind of annoying that Haskell has no notion of a stack. 
13:39:48 <cncl> roconnor: i was just starting on haskell one yaer ago
13:39:54 <pozic> Yet implementations manage to figure out new reasons to fail.
13:40:15 <roconnor> pozic: how is it annoying?
13:40:17 <pozic> roconnor: the early implementations were like that.
13:40:43 <pozic> roconnor: it is an implementation detail.
13:40:53 <ksf_> djahandarie, you could lobby for that to be made a new category in some 1k contest
13:41:00 <pozic> roconnor: it's like manual shift on a car. 
13:41:12 <pozic> roconnor: technically completely redundant to have. 
13:41:12 <djahandarie> ksf_, heh
13:41:40 <djahandarie> pozic, what a useless metaphor
13:41:51 <pozic> djahandarie: yes, it's not the best. 
13:42:01 <pozic> djahandarie: there are some advantages to manual shift. 
13:42:19 <roconnor> djahandarie: ah, that is what twitter is for
13:42:40 <djahandarie> roconnor, I've been trying to figure out what to do with it
13:43:09 <thoughtp1lice> the explicit stack in GHC is something of a hold-over from the old days, from what I understand.
13:43:26 <thoughtp1lice> and now it's so deeply embedded in the compiler removing it would be a massive PITA
13:43:50 <ksf_> the stg hasn't only one stack
13:44:14 <roconnor> ksf_: the stack for primops is lame
13:44:21 <roconnor> mostly cause primops are lame :D
13:44:41 <ksf_> ...I once new how many and for what they are.
13:44:59 <ksf_> probably unimportant that's why it didn't stick long-term
13:45:03 <invarius1> Sorry, I may have asked this yesterday, but I completely forgot.. When you have a set of data and you want to do a comparison check against say, A and B, you're always required a max of 3 steps to return true. >, >=, <. If there a way to check for a condition faster?
13:45:34 <invarius1> Being such that there exists 3 steps for just a comparison, swapping their places requires another 3 steps
13:45:36 <ksf_> you could use ==
13:45:42 <invarius1> what?
13:45:43 <invarius1> no
13:46:05 <Zao> @type compare
13:46:06 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
13:46:34 <Zao> invarius1: I don't get what you're asking about.
13:46:37 <ksf_> ...then you have to describe your data better.
13:46:42 <roconnor> > compare 6 7
13:46:43 <lambdabot>   LT
13:46:56 <ksf_> and the equality you want to haev on it.
13:46:56 <Zao> > map (compare 9001) [9000..9002]
13:46:57 <lambdabot>   [GT,EQ,LT]
13:47:40 <Jesin> > [LT..]
13:47:41 <lambdabot>   <no location info>: parse error on input `]'
13:47:44 <invarius1> Zao: you want to swap a with A but you're not sure if a is greater than, less than or equal to A, regardless, each operation will perform a swap, excluding ==. This is a Maxima of 6 steps
13:47:46 <Jesin> hmm
13:47:55 <invarius1> Is there a shorter method?
13:48:10 <invarius1> I was told there was a type of shortcut in assembly
13:48:12 <invarius1> but I forgot
13:48:21 <Jesin> > [(LT)..]
13:48:22 <lambdabot>   [LT,EQ,GT]
13:48:36 <Jesin> > [LT ..]
13:48:36 <lambdabot>   [LT,EQ,GT]
13:48:40 <Jesin> ok then.  :p
13:49:02 <ksf_> ouch that's an ugly corner of the syntax.
13:49:16 <ksf_> LT.. being (.) in the module LT
13:49:20 <roconnor> invarius1: you mean the xor trick to swap two different values?
13:49:43 <invarius1> I think it's cmp, but maybe
13:52:47 <djahandarie> :t fix(\s z->concat[s[y|y<-tail z,y<x]++x:s[y|y<-tail z,y>=x]|x<-take 1 z])
13:52:48 <lambdabot> forall t. (Ord t) => [t] -> [t]
13:53:40 <djahandarie> 72 char quicksort
13:54:04 <invarius1> too many steps
13:54:13 <aristid> djahandarie: i bet you can do it more readably
13:54:39 <djahandarie> aristid, I hope I can
13:55:26 <Mathnerd314> djahandarie: is that *really* quicksort?
13:55:39 <djahandarie> fsvo quicksort
14:02:29 <Boxo> > fix(\s z->concat[s[y|y<-tail z,y<x]++x:s[y|y<-tail z,y>=x]|x<-take 1 z]) $ "54832103312798"
14:02:31 <lambdabot>   "01122333457889"
14:02:33 <tonkman> I have type Parser a b = a -> b -> (a, b)
14:02:40 <tonkman> and combParser :: Parser a b -> Parser a b -> Parser a b
14:03:20 <tonkman> is it possible to define Parser instance to monad typeclass
14:04:30 <copumpkin> djahandarie: a while back I tweeted a golfed RLE encoder/decoder :)
14:04:47 <ksf_> tonkman, your types look strange
14:04:53 <ksf_> have a look at http://www.cs.uu.nl/research/techreps/repo/CS-2008/2008-044.pdf
14:05:02 <djahandarie> copumpkin, heh. I'll get there eventually :P
14:05:12 <djahandarie> Gotta start somewhere
14:06:19 <copumpkin> @let encode = map (length &&& head) . group
14:06:20 <lambdabot>  Defined.
14:06:27 <copumpkin> @let decode = (uncurry replicate =<<)
14:06:28 <lambdabot>  Defined.
14:06:51 <tonkman> ksf_: I meant it to be: Where to parse -> What to parse -> (remainder, what was parsed)
14:07:05 <ksf_> "where to parse"?
14:07:11 <copumpkin> @check (\(xs : String) => decode (encode xs) == xs)
14:07:12 <lambdabot>   Parse error at "=>" (column 17)
14:07:17 <tonkman> like [String]
14:07:18 <copumpkin> @check (\(xs :: String) -> decode (encode xs) == xs)
14:07:18 <lambdabot>   Parse error in pattern at "->" (column 18)
14:07:31 <copumpkin> @check (\xs -> decode (encode xs) == (xs ++ ""))
14:07:32 <lambdabot>   Not in scope: `decode'Not in scope: `encode'
14:07:36 <copumpkin> ugh
14:07:37 <djahandarie> Foiled
14:07:59 <copumpkin> @check (\xs -> uncurry replicate =<< (map (length &&& head) . group $ xs) == (xs ++ ""))
14:08:00 <lambdabot>   Occurs check: cannot construct the infinite type:
14:08:00 <lambdabot>    a = (GHC.Types.Int, a)
14:08:03 <copumpkin> meh
14:08:10 <tonkman> ksf_: String, SomeDataType,.. what ever you want to parse
14:08:44 <djahandarie> > map (length &&& head) . group $ "What does this do?"
14:08:46 <lambdabot>   [(1,'W'),(1,'h'),(1,'a'),(1,'t'),(1,' '),(1,'d'),(1,'o'),(1,'e'),(1,'s'),(1...
14:08:50 <ksf_> but that's input to the parsing function, not a thing that interests your combinators
14:08:56 <djahandarie> > map (length &&& head) . group $ "Soooomething more useful"
14:08:58 <lambdabot>   [(1,'S'),(4,'o'),(1,'m'),(1,'e'),(1,'t'),(1,'h'),(1,'i'),(1,'n'),(1,'g'),(1...
14:09:07 <ksf_> anyway, you already have the what as second parameter.
14:09:17 <djahandarie> Neat
14:09:28 <djahandarie> That is pretty elegant
14:09:54 <tonkman> ksf_: so when I define parsing function it should look something like this: f :: String -> Parser a
14:10:03 <tonkman> not f :: Parser String a
14:10:39 <ksf_> ...you can probably do that, but it's not idiomatical.
14:11:19 <cncl> idiomatical is the word of the day
14:11:47 <ksf_> the main thing you're losing is to abstract the interface away from the implementation.
14:12:41 <tonkman> ok, but combParser combines two parsers, not parser and function, like >>=
14:13:52 <tonkman> so does it make any sense to even define monad instance?
14:14:13 <13WAAXTXV> http://hpaste.org/paste/42552/quarto_annotation#p42627 can anyone help me with the function mkTree ?
14:14:52 <mjrosenb> If I have a tree of ByteStrings, what is the fastest way to condense the whole thing into a ByteString?
14:14:53 <Zao> 13WAAXTXV: Well, what's wrong with it?
14:15:09 <ksf_> tonkman, if it did, you would know.
14:15:13 <mjrosenb> is it just turn the whole thing into a list, then use concat?
14:15:30 <ksf_> ...otherwise, I'd advice to stick to vanilla idioms
14:15:43 <13WAAXTXV> I am having troubles with butting the list back together
14:16:17 <13WAAXTXV> Zao: how to I put the list back together a normal way, so I go torugh each item in avail and free list
14:19:12 <applicative> It's tiresome to bring up the cargo cult nonsense but I have the writer (under the name `reikonomusha`) - and myself -- in a fairly rational frame of mind.
14:19:31 <cncl> 13WAAXTXV: what list?
14:19:38 <applicative> can someone tell me how to answer the question he puts at the end of this news.ycombinator thread? http://news.ycombinator.net/item?id=2044303
14:21:22 <applicative> I illustrate the ghci defaulting behavior that tripped him up in various ways.
14:21:23 <applicative> but I don't really know how to answer this question "What are your thoughts on this behavior overall? I mean, your opinion. When do we precisely know that '5' means '5::Integer'? At which point does GHC or really Haskell in general, I assume, make this decision?" 
14:21:36 <j-invariant> what's a cargo cult?
14:21:42 <applicative> my understanding of these things is from experience.
14:21:46 <cncl> applicative: he's just posting a reply so that you don't have the last word in the thread
14:22:04 <applicative> cncl, maybe. 
14:22:13 <cncl> people will come by and tend to vote up all of the replies in the thread that seem like they won
14:22:27 <j-invariant> 5 is fromInteger (5 :: Integer)
14:22:29 <cncl> so it's best, if you are gaming for karma, to never let someone else have the last word, especially if they just corrected you
14:22:34 <13WAAXTXV> cncl: the free and available lists
14:22:45 <applicative> the thread is past its moment, so it's genuine communication at this point. 
14:22:54 <c_wraith> applicative, defaulting rules kick in when something needs a monomorphic type for the type-checker to succeed.
14:23:18 <c_wraith> Also, for the monomorphism restriction
14:23:35 <aristid> applicative: you could quote from the Haskell 98 specification :D
14:23:54 <invarius1> so should I say if(a cmp b == true) {a xor b;} ?
14:23:58 <c_wraith> remember, for code to be evaluated, every expression needs to be assigned a monomorphic type.
14:24:06 <cncl> 13WAAXTXV: sorry, i don't understand your code. where are free, avail etc. bound from?
14:24:12 <Zao> @type cmp
14:24:12 <c_wraith> ...  There are some ways to loosen that restriction, but that's the basic idea
14:24:12 <lambdabot> Not in scope: `cmp'
14:24:27 <applicative> I think I will just affirm what is basically the case, that I'm used to it, it doesn't bother me, I don't have a theoretical grasp of all the options.  
14:24:27 <13WAAXTXV> cncl: from config type
14:24:42 <invarius1> Zao: pseudo-code 
14:25:03 <c_wraith> the extension GHCI uses is actually handy in live code sometimes...  But I seem to have forgotten what it's called.
14:25:17 <c_wraith> ExtendedDefaulting or something
14:25:33 <applicative> or does that seem too feeble.  It's long winded, but I think I got to the bottom of his problem, it really was that he was using Int not Integer
14:25:39 <aristid> c_wraith: or RankNTypes :)
14:25:41 <cncl> 13WAAXTXV: they aren't bound in that scope, also the code does not compile due to syntax errors (at least for me)
14:26:06 <c_wraith> aristid, that changes when things are required to be monomorphic, but not how defaulting works when something does need to be monomorphic
14:26:23 <aristid> c_wraith: yeah
14:26:29 <13WAAXTXV> cncl: wierd, what error are you getting?
14:27:22 <cncl> 13WAAXTXV: quarto.hs:447:43: parse error (possibly incorrect indentation)
14:28:56 <applicative> okay, I did it.  Sorry for bringing this nonsense up again.  I went into another rage when I realized he was intervening as a sockpuppet everywhere.
14:29:01 <13WAAXTXV> cncl: I use hugs, maybe it dose not work in ghc ?
14:29:04 <cncl> i don't know if perhaps you copied the file to hpaste incorectly, but you have to indent the 'then' and 'else' lines in an if-statement when used in a monadic do-block
14:29:16 <cncl> maybe hugs accepts that syntax when ghc doesn't
14:29:19 <mjrosenb> cncl: 13WAAXTXV where is this code?
14:29:43 <13WAAXTXV> http://hpaste.org/paste/42552/quarto_annotation#p42629
14:29:49 <mjrosenb> and whoever posted this code initially, are you using an if/then/else statement inside of a do block?
14:30:35 <cncl> mjrosenb: yes that is what he is doing, and he needs to indent the 'then' and 'else lines
14:31:08 <j-invariant> applicative: why does it even matter
14:31:08 <13WAAXTXV> mjrosenb: cncl: should I use case?
14:31:20 <mjrosenb> cncl: they actually changed that requirement somewhat recently
14:31:22 <j-invariant> I mean what's to be angry about
14:31:46 <mjrosenb> 13WAAXTXV: no, but for backwards compatibility, you should indent the then and else by a space
14:31:54 <cncl> mjrosenb: oh really? interesting
14:32:18 <mjrosenb> cncl: yeah, possibly with ghc-7?
14:32:28 <cncl> i'm still on 6.12
14:32:38 <ksf_> applicative, I don't think the haskell community needs to defend defaulting descisions against uninformed attacks by some random mathematician.
14:33:06 <ksf_> fight elitism with elitism
14:33:38 <monochrom> how do you fight elitism with elitism?
14:33:43 <Eduard_Munteanu> ksf_: context?
14:33:44 <lambdabot> Eduard_Munteanu: You have 1 new message. '/msg lambdabot @messages' to read it.
14:33:44 <j-invariant> by the way - what is his actual criticism
14:33:58 <j-invariant> I couldn't find any specific arguments
14:34:08 <ksf_> Eduard_Munteanu, http://www.reddit.com/r/programming/comments/es29o/the_air_on_which_haskell_programmers_seem_to/c1ajpf2
14:34:15 <cncl> i like fighting elitism with glibness
14:34:18 <monochrom> don't expect clear-headed clarity in blogs. :)
14:34:19 <Eduard_Munteanu> Ah, seen it.
14:34:29 <cncl> "put ur ints in teh box, ok"
14:34:39 <monochrom> maybe expect stream of consciousness
14:34:51 <ksf_> ...well, in the course of the thread I turn my attack approach by 180 degrees.
14:34:56 <ksf_> it ends with "I still don't get why you assume that mathematicians need beginner-level special catering, that is, why e.g. Learn You A Haskell would be incomprehensible to them."
14:34:58 <j-invariant> is 'barsoap' a legit person
14:35:06 <Eduard_Munteanu> roconnor: hi. I think my assignment is due 4th January.
14:35:15 <applicative> ksf_, indeed not.  He's not a mathematician anyway. It was the treatment of conal and mauke especially that put me over the edge, though conal wouldn't have approve of my frame of mind :)
14:35:37 <mjrosenb> Eduard_Munteanu: sounds like you should start working on it!
14:35:46 <Eduard_Munteanu> mjrosenb: heh, I am.
14:35:52 <13WAAXTXV> cncl: http://hpaste.org/paste/42552/quarto_annotation#p42630
14:36:03 <ksf_> well, conal wouldn't approve of my rhethorics, either.
14:36:23 <applicative> ksf_ , j-invariant, so it wasn't really Haskell I was defending, in my mildly lunatic way.
14:36:25 <ksf_> j-invariant, it's me.
14:36:36 <j-invariant> oh okay
14:36:38 <j-invariant> what is cargo-cult?
14:36:53 <j-invariant> right now it just seems like a meaningless insult
14:37:00 <applicative> a true cargo cult?  
14:37:01 <j-invariant> but maybe it means something
14:37:03 <ksf_> j-invariant, http://en.wikipedia.org/wiki/Cargo_cult
14:37:04 <c_wraith> there's a history to the term, but in general it means "doing stuff without understanding why"
14:37:06 <Eduard_Munteanu> @tell roconnor I think my assignment is due 4th January. I suppose I can deliver a not-so-smart-implementation, or prototype in Haskell, then translate in C if it's really a problem. But I still have time to think it more thoroughly.
14:37:06 <lambdabot> Consider it noted.
14:37:10 <j-invariant> in the context of this discussion
14:37:21 <applicative> they're kind of cool really, I mean, the real thing. 
14:37:46 <ksf_> "When the war ended, the military bases closed and the flow of goods and materials ceased. In an attempt to attract further deliveries of goods, followers of the cults engaged in ritualistic practices such as building crude imitation landing strips, aircraft and radio equipment, and mimicking the behaviour that they had observed of the military personnel operating them."
14:37:58 <monochrom> http://en.wikipedia.org/wiki/Cargo_cult  It refers to mimicking steps without knowing why
14:38:02 <Eduard_Munteanu> Actually, j-invariant, look at "cargo cult" applied to various "sciences".
14:38:18 <j-invariant> oh yeah but isn't everything in life cargo cult?
14:38:22 <Eduard_Munteanu> Like using maths in economics, psychology etc. hoping a miracle happens.
14:38:29 <c_wraith> No.  Sometimes you actually understand what you're doing. :)
14:38:35 <j-invariant> I mean nobody really has any reason to do anything, and any code you write you just write because that's what you do]
14:38:36 <monochrom> A little bit. Just don't overdo it. :)
14:38:57 <j-invariant> I mean especially in mathematics
14:39:12 <j-invariant> it's 99% do this do that do this here's an A for you!
14:39:21 <c_wraith> Well.  "knowing what you're doing" doesn't mean "knowing what result you'll get"
14:39:37 <c_wraith> It just means you understand the methods you're applying.
14:39:40 <j-invariant> it's the same in programming, you watch patterns arise and repeat them
14:39:51 <winxordie> j-invariant: I think cargo-cult learning is a necessary condition for non-cargo-cult actions
14:40:01 <winxordie> i.e. addition, multiplication tables, etc.
14:40:09 <mreh_> :i ($)
14:40:12 <j-invariant> nobody knows why we write a "complier for a new script language which has blah blah.." it's just an etude
14:40:14 <mreh_> @bots
14:40:15 <lambdabot> :)
14:40:17 <cncl> 13WAAXTXV: hm, what is the problem exactly? (your code is kind of long and it would take me a while to read and understand all of it)
14:40:35 <applicative> winxordie, very true. 
14:41:00 <13WAAXTXV> to tell the basics, this is a game called Quarto
14:41:06 <mreh_> what the hell is cargo-cult learning?
14:41:14 <13WAAXTXV> cncl: maybe you have heard of this game
14:41:26 <applicative> winxordie, the human is a mimetic machine.  "whatever does not wish to with must take upon itself the stigma of the inauthentic, for the human lives on the mimetic heritage"
14:41:27 <ksf_> mreh_, most of modern institutionalised education.
14:41:31 <13WAAXTXV> cncl: the idea is that the function mkTree builds up the gaming tree
14:41:44 <ksf_> in particular, anything that has any trace of rote learning.
14:42:04 <winxordie> applicative: interesting quote
14:42:09 <j-invariant> what /isn't/ rote?
14:42:22 <winxordie> j-invariant: is the conversation we're having now rote?
14:42:40 <ksf_> j-invariant, learning by doing.
14:42:47 <invarius1> j-invariant: I like your nick ;)
14:42:47 <winxordie> also I think it depends on how nihilistic one is :P
14:42:47 <13WAAXTXV> cncl: so the idea is to take a figure place it on a position on the board and so on so on if the whole gaming tree is calculated
14:42:49 <j-invariant> winxordie: I bet millions of people have had a discussion within epsilon of this one
14:42:51 <mreh> is the conversation we're not having now rote?!
14:43:03 <j-invariant> invarius1: :)
14:43:07 <13WAAXTXV> cncl: so the gaming tree contains all the possible moves in the game
14:43:18 <applicative> winxordie, I think its from Adorno, Minima Moralia which some time ago was my guide of life :)
14:43:42 <ksf_> the difference is hard to define in paedagogical terms, but bleeding easy to sense if you're used to learn by doing.
14:43:48 <13WAAXTXV> cncl: and while building up this configuration tree I need to remove available figures and free position from lists and but them back
14:44:03 <13WAAXTXV> cncl: are you following this far xD 
14:44:31 <j-invariant> ksf: "I still don't get why you assume that mathematicians need beginner-level special catering, that is, why e.g. Learn You A Haskell would be incomprehensible to them." <-- that's a good point, all this "X for Ys" stuff is just marketing crap
14:44:32 <ksf_> I figured out much of mechanics on my own with lego. rote learning of definitions of design patterns insults my intelligence.
14:44:36 <winxordie> j-invariant: basing it on epsilon distance eh? I don't think metrics are great models for this process but still I think there's semantic meaning to statements outside their statistical distribution
14:44:43 <cncl> 13WAAXTXV: yes sort of
14:45:10 <j-invariant> it's just an idiom for 'as close as you wisho
14:45:13 <cncl> 13WAAXTXV: so you want to know how to lazily remove things from lists and maybe put them back in as well?
14:45:15 <applicative> to copy, to replicate, to mirror -- everything human is founded on this -- even not to copy, not to mirror, not to replicate, are just  more advanced forms.
14:45:32 <monochrom> It's pretty easy to define. an exam of "write down the definition of monad. write an essay on it." vs an exam of "solve this problem. hint: you may find monads helpful."
14:45:39 <Eduard_Munteanu> ksf_: not really. It would be ideal if that knowledge could be transmitted rote.
14:45:49 <winxordie> applicative: nice! Adorno and Horkheimer are my favourite sociologists. ^^
14:45:50 <Eduard_Munteanu> But translating insight into words is really tough at times.
14:45:59 <ksf_> that would mean that every thought is effable.
14:46:09 <winxordie> j-invariant: yeah, I know. I have bad memories of analysis class though
14:46:19 <ksf_> that is, it just won't work with any communication medium short of telepathy.
14:46:20 <monochrom> clearly the former is so much easier to grade, therefore all of education tends to do it.
14:46:44 <Eduard_Munteanu> In fact, the "do this thing until it becomes clear" way of teaching requires the least effort on the pedagogue.
14:46:45 <13WAAXTXV> cncl: the requirement is that it is back in the list for the next call of the same function, the problem is that I can't figure out when the iteration should stop
14:46:48 <ksf_> and even then my encoding of stuff might be incomprehensible to your preconceptions, and the other way round.
14:47:10 <13WAAXTXV> cncl: as you see I but the list items back into the list end
14:47:13 <mreh> have any of your tought?
14:47:18 <mreh> taught*
14:47:23 <mreh> heh, the irony
14:47:39 <arcatan> monochrom: hmm, how the former is easier to grade?
14:47:45 <mreh> teaching isn't about getting people to understand on the whole
14:48:00 <13WAAXTXV> cncl: but if I but them all back, the recursive iteration will not end, I can't not pattern mach out the ending
14:48:03 <applicative> winxordie, if English is your native language the Minima Moralia has the advantage of being pretty well translated at least.  It was a gift to Horkheimer written in the US during the war, thus much analysis of America, in passing.
14:48:04 <mreh> most people are capable or interested in actually understanding the universe
14:48:47 <monochrom> "write down the definition" is merely string matching.
14:48:48 <ksf_> that's funny.
14:48:52 <monochrom> (to grade)
14:49:10 <ksf_> if you understand your relation to the universe, understanding the universe becomes boring.
14:49:26 <13WAAXTXV> cncl: so how could I solve this problem
14:49:31 <Eduard_Munteanu> Do you grade your students by the Hamming distance? :P
14:49:35 <invarius[w]> I have a question concerning algorithms. In what case would it be much more important to queue data for an operation opposed to preforming an operation on data being read?
14:49:43 <mreh> GET OUT!
14:49:52 <invarius[w]> :(
14:49:55 <mreh> oh, we're in haskell
14:49:58 <monochrom> "write an essay" seems harder if you're an honest grader. until you realize you can be a dishonest grader. just look for points in the essay that you have previously made students to memorize. don't give marks for other points.
14:49:59 <Eduard_Munteanu> What? :))
14:50:04 <ksf_> mreh, understanding the universe is like studying biology instead of doing your SO.
14:50:21 <mreh> ksf_ what's an SO?
14:50:26 <ksf_> significant other.
14:50:30 <applicative> Eduard_Munteanu is there evidence that using Hamming distance works well for grading?
14:50:40 <monochrom> whereas, grading "solve this problem" requires you to evaluate students' solutions, and there are many new ones.
14:50:43 <Eduard_Munteanu> No, I guess not :)
14:50:50 <ksf_> sex and sexual orientation-clean term for "girlfriend"
14:51:08 <monochrom> not to mention that you have to come up with a worthy problem in the first place.
14:51:27 <winxordie> invarius[w]: what do you mean by "preform an operation"?
14:51:27 <mreh> well, maybe we're none of us cabale of understanding, but that possibility drives me
14:51:46 <mreh> homosexuality is a myth
14:51:51 <mreh> lol
14:52:01 <winxordie> mreh: sexuality is a myth :P
14:52:06 <mreh> is this cynics night tonight?
14:52:15 <invarius[w]> winxordie:〈A, *〉
14:52:34 <monochrom> cargo-cult education is due to cargo-cult grading
14:52:54 <winxordie> sometimes I think this channel and -blah switch places without notifying me
14:52:55 <mreh> it's more to do with practical considerations
14:53:02 <monochrom> oops
14:53:11 <mreh> are they talking about haskell in blah again?
14:53:12 <Eduard_Munteanu> There is some cargo-cult teaching, like using slides, whatever...
14:53:24 <cncl> 13WAAXTXV: hard to tell from your code, but maybe turn the 'available figures that will be made into a configuration' into another argument
14:54:14 <winxordie> invarius[w]: I don't have an answer to that one sadly
14:54:20 <13WAAXTXV> cncl: ok this would work
14:54:22 <cncl> if you had a more simple version of what you were trying to do, it would be easier to see
14:54:24 <13WAAXTXV> cncl: thx
14:54:44 <winxordie> mreh: yeah they are.
14:55:20 <invarius[w]> winxordie: :(
14:55:31 <mreh> so if haskell is very good, what languages are excellent?
14:55:37 <invarius[w]> C
14:55:54 <copumpkin> mreh: lolcode
14:56:13 <mreh> you don't like the question do you? :)
14:56:19 <j-invariant> serious question: How come haskell is still the best  language?
14:56:27 <invarius[w]> Best as in?
14:56:29 <j-invariant> it's been around for ages... there should be something better now?
14:56:40 <invarius[w]> there is, assembly 
14:56:41 <invarius[w]> :O
14:57:05 <winxordie> haskell is my assembly
14:57:06 <Eduard_Munteanu> I figure the same conversation probably goes on in ##c or somewhere else at this moment.
14:57:14 <monochrom> j-invariant: some kind of anthropology principle.
14:57:48 <j-invariant> hm?
14:57:53 <copumpkin> I look forward to something better
14:57:55 <monochrom> haskell is good enough to attract you to this channel. it just happens to be called "haskell".
14:58:31 <mreh> someone on here said haskell programs weren't provable
14:58:33 <monochrom> in a parallel universe, you would be attracted to #erlang, wondering why erlang would be the best language so far there.
14:58:36 * Eduard_Munteanu also figures some distant aliens wondering if they're alone
14:59:28 <ksf_> I think Eduard_Munteanu is right.
14:59:41 <ksf_> ##c is quite likely asking themselves why haskell is still the best language
14:59:47 <winxordie> that was pretty bad monochrom
14:59:57 <copumpkin> > some (Just 5)
15:00:00 <monochrom> no, it's beautiful
15:00:01 <lambdabot>   mueval-core: Time limit exceeded
15:00:35 <mreh> some haskell programs are provable correct?
15:00:43 <j-invariant> what is there to prove?
15:00:49 <j-invariant> A haskell program is a haskell program
15:01:15 <Eduard_Munteanu> ksf_: heh, no, I meant the same thing about C.
15:01:27 <mreh> j-invariant: I'm thinking about proving certain hypothesis about the program
15:01:47 <monochrom> the haskell language definition doesn't say how to prove things. but you can still prove things according to your own rules.
15:02:25 <monochrom> most language definitions doesn't say how to prove things either. hasn't stopped formal verification a tiny bit.
15:02:54 <j-invariant> so what about a language that had proving built in?
15:02:55 <mreh> perhapse I should read david gries at long las
15:03:12 <monochrom> Hoare would love to see that.
15:03:58 <monochrom> Actually the SML definition gives you enough to start proving (that is, without needing you to invent your own rules)
15:03:59 <mreh> they look like the same person
15:04:12 <monochrom> heh
15:04:51 <mreh> making verifiable software was a dream of mine some time ago, I really wonder if it is practical
15:05:17 <mreh> or do I mean valid
15:06:04 <mreh> I think I need both
15:06:38 <j-invariant> I thought practical was just a silver bullet you use to kill peoples enthusiasm in anything nonstandard
15:06:48 <monochrom> word
15:07:23 <mreh> the real world still exists regardless of your idealisation
15:07:50 <ksf_> mreh, prove it.
15:08:02 <mreh> @slap ksf_
15:08:02 * lambdabot hits ksf_ with a hammer, so they breaks into a thousand pieces
15:08:04 <ksf_> even sokrates was smarter than that.
15:08:07 <mreh> did you feel that?
15:08:13 <ksf_> he knew that he didn't knew.
15:08:15 <ksf_> not at all.
15:08:24 <ksf_> you can't hit constructivists with reality nonsense.
15:08:55 <ksf_> "the real world exists" is based on as inconclusive evidence as the flying sphagetti monster.
15:09:44 <Boxo> @google yudkowsky simple truth
15:09:45 <lambdabot> http://yudkowsky.net/rational/the-simple-truth
15:09:45 <lambdabot> Title: Yudkowsky - The Simple Truth
15:09:54 <Jesin> lol
15:09:54 <monochrom> there was a time some opinion leaders thought haskell was impractical.
15:10:16 <monochrom> well, to be fair, haskell was impractical for a limited time.
15:10:34 <ksf_> c++ is still impractical.
15:11:07 <Jesin> heh
15:11:16 <monochrom> so, as for formal verification I hold the same opinion with a bit of faith. not practical now in its full glory. that will change.
15:11:39 <Jesin> I think the "impractical" predicate generally takes an "application" argument
15:11:42 <Jesin> :p
15:12:34 <Jesin> also Boxo that was a good response
15:12:46 <monochrom> and sure enough, many people claim "is practical" "is impractical" without ground, just as an excuse. ignore them.
15:12:58 <mreh> I still do informal proofs, that's good enough for now
15:13:22 <j-invariant> I have this feeling like there is more to a proof than just the justification of correctness of a program
15:13:44 <j-invariant> like maybe software gets complicated to a point where you can't actually continue programming without the proofs?
15:14:31 <j-invariant> maybe that is absurd
15:14:43 <Jesin> hmm
15:14:43 <mreh> like a proof junkie?
15:14:49 <j-invariant> hehe
15:14:55 <Jesin> proof of what, though
15:15:04 <mreh> we've already gone of this!
15:15:10 <mreh> over*
15:15:17 <mreh> validity
15:16:03 <mreh> often I use it as an excuse to actually make something that works
15:16:18 <monochrom> you have a program on one side and a specification on the other side. you use a proof to bridge them.
15:16:21 <mreh> not saying that's bad, just an observation
15:16:35 <ksf_> the spec is the program.
15:16:47 <Jesin> "validity" in what sense
15:18:02 <mreh> Jesin: it conforms to the specification
15:19:08 <mreh> gah, ksf_, that's so insightful it twists my brain
15:19:38 <Jesin> ah, that
15:19:40 <Jesin> ok
15:20:28 <Jesin> also, yeah if you look at it like that, programmers are basically just translating it from one language to another
15:20:33 <Jesin> provided the spec is detailed enough
15:20:44 <monochrom> haha
15:20:59 <ksf_> ...it's just that encoding specs happens to be AI-hard.
15:21:02 <Jesin> er, s/detailed/thorough/
15:21:16 <j-invariant> so a programmer is a compiler: that's just like old times
15:21:23 <Jesin> :P
15:21:53 <j-invariant> AI-hard a synonym for undeciable?
15:22:04 <mreh> this isn't my copy of reductionist bulletin, what's going on!
15:22:11 <monochrom> see Bird and de Moor "algebra of programming" for how to do this translation
15:22:24 <j-invariant> \i love that book
15:22:52 <aristid> j-invariant: you remind me of my hatred of people who do not clearly distinguish between slash and backslash
15:23:23 <j-invariant> I didn't even mean to type any slash
15:23:35 <aristid> heh
15:23:56 <Jesin> and what about |
15:24:03 <Jesin> that's not a forward OR back slash
15:24:03 <aristid> Jesin: that's a pipe
15:24:18 <Jesin> no, it's a midslash!  :p
15:24:24 <aristid> no, pipe! :p
15:24:27 <mreh> it's sitting on the fence
15:24:34 <Jesin> ooh
15:24:35 <aristid> but what is "!"? a dotted pipe?
15:24:51 <mreh> it's an exclamation mark, (not a point)
15:24:51 <Jesin> have you guys seen the INTERCAL manual's names for punctuation
15:24:58 <Jesin> it's kinda hilarious
15:25:05 <Jesin> ":" is a two-spot
15:25:22 <monochrom> oh, my http://www.vex.net/~trebla/haskell/scanl.xhtml has some example translations, too :)
15:27:03 <Jesin> ...
15:27:04 <Jesin> pow2s = fix (scanl (+) 1)
15:27:15 <Jesin> nice
15:27:22 <aristid> > fix $ scanl (+) 1
15:27:23 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
15:27:32 <aristid> > iterate (*2) 1
15:27:33 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
15:27:54 <aristid> > map length ["fix$scanl(+)1", "iterate(*2)1"]
15:27:55 <lambdabot>   [13,12]
15:28:00 <Jesin> hmm
15:28:00 <aristid> iterate wins!
15:28:33 <monochrom> yeah, using scanl for powers of 2 is just cute. you should use iterate.
15:28:43 <monochrom> s/just cute/just being cute/
15:28:48 <Jesin> > fix ((1:) . scanl1 (+))
15:28:50 <lambdabot>   [1,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,13107...
15:29:02 <Jesin> > fix (scanl1 (+) . (1:))
15:29:04 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
15:29:24 <aristid> Jesin: that was the fibonacci powers of 2 ;)
15:29:35 <Jesin> > fix (scanl (+) 1 . (0:))
15:29:36 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
15:32:17 <Jesin> fix ((1:) . scanl (\y z -> y*z+1))
15:32:20 <Jesin> > fix ((1:) . scanl (\y z -> y*z+1))
15:32:21 <lambdabot>   Couldn't match expected type `[t]'
15:32:21 <lambdabot>         against inferred type `[[t]] -> ...
15:32:31 <Jesin> waiit
15:32:38 <Jesin> > fix ((1:) . scanl (\y z -> y*z+1) 2)
15:32:40 <lambdabot>   [1,2,3,7,22,155,3411,528706,1803416167,953476947989903,17195157428668092229...
15:33:09 <aristid> ok i wish oeis would work
15:38:08 <Jesin> hmm
15:38:10 <Jesin> http://www.vex.net/~trebla/haskell/calculator/Calculator.hs
15:38:26 <Jesin> why do they use that implementation of fiblist, rather than the one involving scanl?
15:38:30 <monochrom> don't use the ackerman function! :)
15:38:53 <monochrom> because I like to
15:40:01 <Jesin> is one of them more space-efficient, or no?
15:40:41 <monochrom> I don't think there is much efficiency difference. The more direct one wins.
15:41:06 <Jesin> more direct?
15:41:22 <monochrom> closer to specification
15:45:21 <Jesin> hm, k
15:45:42 <Jesin> also
15:45:43 <Jesin> ack :: (Num a) => a -> a -> a
15:45:49 <Jesin> shouldn't that be Integral a?
15:46:45 <monochrom> all it does is + and -.
15:47:11 <Jesin> well
15:47:19 <Jesin> if you want the fully general type signature
15:47:25 <Jesin> then you also did it wrong for that
15:47:29 <Jesin> @type let ack 0 n = n+1; ack m 0 = ack (m-1) 1; ack m n = ack (m-1) (ack m (n-1)) in ack
15:47:30 <lambdabot> forall t a. (Num a, Num t) => t -> a -> a
15:55:44 <me8942> Hi, I'm trying to install Haskell on OSX (my first programming language so I'm a newb).  Once I open the installer, the "Install" button is disabled, even though I have Xcode on my computer.  
15:57:59 <Axman6> how odd
15:58:10 <lispy> Is there a way to preview my package's description before uploading to hackage?
15:58:31 <monochrom> haddock
15:58:58 <lispy> monochrom: I mean specifically, the "Description:" field in the .cabal file.  Will haddock show that to me?
15:59:05 <monochrom> yes.
15:59:10 <lispy> nice
15:59:33 <monochrom> use the "Contents" link
16:01:24 <lispy> thanks
16:02:08 <Jesin> hmm
16:02:27 <Jesin> lambdabot's @pl is not entirely reliable, is it?
16:02:31 <Jesin> @pl let ack 0 n = n+1; ack m 0 = ack (m-1) 1; ack m n = ack (m-1) (ack m (n-1)) in ack
16:02:31 <lambdabot> ap ((.) . ap id (subtract 1)) ((. subtract 1) . join id)
16:02:41 <Jesin> @type ap ((.) . ap id (subtract 1)) ((. subtract 1) . join id)
16:02:42 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a1 -> b
16:02:42 <lambdabot>     Probable cause: `subtract' is applied to too few arguments
16:02:42 <lambdabot>     In the second argument of `ap', namely `(subtract 1)'
16:02:44 <monochrom> not always optimal but pretty correct
16:02:58 <monochrom> haha
16:03:10 <ddarius> Jesin: It makes dubious assumptions, and by "dubious" I mean "incorrect."
16:03:14 <Jesin> :p
16:03:34 <Jesin> hmm
16:03:40 <Jesin> @unpl ap ((.) . ap id (subtract 1)) ((. subtract 1) . join id)
16:03:40 <lambdabot> ((\ o b c -> ((\ d -> d) >>= \ q -> (subtract 1) >>= \ p -> return (q p)) o (b c)) >>= \ h -> (\ x ac -> ((\ f -> f) >>= \ y -> y) x (subtract 1 ac)) >>= \ g -> return (h g))
16:03:46 <Jesin> ...
16:03:56 <Jesin> @unpl let ack 0 n = n+1; ack m 0 = ack (m-1) 1; ack m n = ack (m-1) (ack m (n-1)) in ack
16:03:56 <lambdabot> let { ack 0 n = n + 1; ack m 0 = ack (m - 1) 1; ack m n = ack (m - 1) (ack m (n - 1))} in ack
16:03:57 <mux> you write funny code when you deal with an IntMap (Map a IntSet) :D
16:04:12 <Jesin> ooh, curly brackets
16:04:29 <Jesin> @pl let { ack 0 n = n + 1; ack m 0 = ack (m - 1) 1; ack m n = ack (m - 1) (ack m (n - 1))} in ack
16:04:29 <lambdabot> (line 1, column 5):
16:04:29 <lambdabot> unexpected "{"
16:04:29 <lambdabot> expecting "()", natural, identifier or "in"
16:04:47 <monochrom>  @pl uses its own parser
16:05:13 <Jesin> hmm
16:05:33 <Jesin> I think all the incorrect @pl expansions I've seen
16:05:39 <Jesin> have involved weird uses of ap
16:06:08 <Jesin> why does it stick ap into things that don't originally involve monads?
16:06:32 <c_wraith> ap isn't necessarily wrong
16:06:33 <Axman6> because (->) is a monad
16:06:38 <me8942> so anyone have any idea why Haskell isn't installing on my Mac, even though I have Xcode? The install button is greyed out. I can't find any answers online.
16:06:45 <Jesin> hmm
16:06:47 <Jesin> k
16:06:48 <Axman6> me8942: the latest platform?
16:06:54 <Jesin> why does it get things wrong like that, though
16:06:59 <Jesin> it shouldn't be getting things wrong  :p
16:07:22 <Jesin> also...
16:07:23 <Jesin> [19:06:06]	<Axman6>	because (->) is a monad
16:07:34 <Jesin> it shouldn't be manipulating (->), though, should it?
16:07:39 <c_wraith> sure it should
16:07:43 <blackdog> Jesin: i noticed that if you don't import Control.Monad.Instances, a bunch of the @pl results don't work
16:07:51 <blackdog> (or rather, some kind soul here told me:)
16:08:19 <c_wraith> @pl s f g x = f x (g x)
16:08:20 <lambdabot> s = ap
16:08:26 <c_wraith> That conversion is correct
16:08:56 <Jesin> @pl let ack 0 n = n+1; ack m 0 = ack (m-1) 1; ack m n = ack (m-1) (ack m (n-1)) in ack
16:08:56 <lambdabot> ap ((.) . ap id (subtract 1)) ((. subtract 1) . join id)
16:09:20 <djahandarie> (->) isn't a monad
16:09:34 <djahandarie> It doesn't have the right kind, even.
16:09:45 <Jesin> Prelude Control.Monad.Instances Control.Monad> :t ap ((.) . ap id (subtract 1)) ((. subtract 1) . join id)
16:09:47 <Jesin> <interactive>:1:17:
16:09:48 <Jesin>     Occurs check: cannot construct the infinite type: a = a -> b -> c
16:09:50 <Jesin>     Probable cause: `subtract' is applied to too few arguments
16:09:51 <Jesin>     In the second argument of `ap', namely `(subtract 1)'
16:09:53 <Jesin>     In the second argument of `(.)', namely `ap id (subtract 1)'
16:10:05 <ddarius> :k (->)
16:10:06 <lambdabot> ?? -> ? -> *
16:10:08 <Jesin> Control.Monad.Instances doesn't fix it
16:10:21 <Boxo> :t substract
16:10:22 <lambdabot> Not in scope: `substract'
16:10:28 <Boxo> :t subtract
16:10:29 <lambdabot> forall a. (Num a) => a -> a -> a
16:10:45 <Jesin> > subtract 3 4
16:10:46 <lambdabot>   1
16:10:49 <Jesin> > subtract 4 3
16:10:50 <lambdabot>   -1
16:10:51 <djahandarie> Jesin, @pl is retarded and just rewrites stuff that sometimes changes semantics, so this could be one of those cases.
16:10:54 <Boxo> aha, maybe it's using lambdabot's funny Num
16:11:06 <Jesin> ?
16:11:07 <Boxo> > 1 $ 2 $ 3
16:11:08 <lambdabot>   1
16:11:10 <Jesin> what funny num
16:11:12 <Jesin> ...whaaat
16:11:16 <djahandarie> :t ap ((.) . ap id (subtract 1)) ((. subtract 1) . join id)
16:11:17 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a1 -> b
16:11:17 <lambdabot>     Probable cause: `subtract' is applied to too few arguments
16:11:17 <lambdabot>     In the second argument of `ap', namely `(subtract 1)'
16:11:24 <djahandarie> It's @pls fault
16:11:27 <Boxo> n = const n = const (const n) ...
16:11:30 <Boxo> so you can do
16:11:35 <Boxo> > sin^2 $ 0.5
16:11:36 <lambdabot>   0.22984884706593015
16:11:54 <Boxo> > sin^2 + 1 $ 0.5
16:11:55 <lambdabot>   1.2298488470659301
16:11:56 <Boxo> I mean
16:11:58 <Jesin> :t sin^2
16:11:59 <lambdabot> forall a. (Floating a) => a -> a
16:12:07 <Jesin> :t ^
16:12:08 <lambdabot> parse error on input `^'
16:12:11 <Jesin> :t (^)
16:12:12 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
16:12:20 <Jesin> umm
16:12:37 <Jesin> is there a nice "isinstance" thing
16:12:39 <c_wraith> :t let s f g x = f x (g x) in (s, ap)
16:12:40 <lambdabot> forall t t1 t2 (m :: * -> *) a b. (Monad m) => ((t -> t1 -> t2) -> (t -> t1) -> t -> t2, m (a -> b) -> m a -> m b)
16:13:07 <djahandarie> [s, ap]
16:13:16 <parcs> @instances Num
16:13:16 <lambdabot> Double, Float, Int, Integer
16:13:19 <Boxo> instance Num a => Num (b -> a) where ...
16:13:44 <Boxo> > sin + cos + 20 $ 1
16:13:45 <lambdabot>   21.381773290676037
16:13:53 <Eduard_Munteanu> @seen roconnor
16:13:53 <Jesin> @instances Floating
16:13:53 <preflex>  roconnor was last seen on #haskell 2 hours, 24 minutes and 33 seconds ago, saying: invarius1: you mean the xor trick to swap two different values?
16:13:53 <lambdabot> Double, Float
16:13:54 <lambdabot> Unknown command, try @list
16:14:01 <djahandarie> :t let s f g x = f x (g x) in [s, ap]
16:14:02 <lambdabot> forall t t1 t2. [(t -> t1 -> t2) -> (t -> t1) -> t -> t2]
16:14:20 <djahandarie> Damn saps.
16:14:26 <Jesin> ??
16:14:52 <Jesin> :t (3 $)
16:14:53 <lambdabot> forall a b. (Num b) => a -> b
16:14:56 <Jesin> what
16:14:58 <parcs> @check liftM (==1) (sin^2 + cos^2)
16:14:58 <lambdabot>   No instance for (GHC.Num.Num (a -> a))
16:14:58 <lambdabot>    arising from a use of `GHC.Real.^...
16:15:01 <Jesin> 3 $ 4
16:15:04 <Jesin> > 3 $ 4
16:15:05 <lambdabot>   3
16:15:12 <Jesin> > 3 $ 8
16:15:13 <lambdabot>   3
16:15:24 <djahandarie> Jesin, /msg lambdabot
16:15:43 <Jesin> yeah, I've done that some
16:15:45 <Jesin> umm
16:15:48 <djahandarie> Or cabal install vector-space; import VectorSpace.NumInstances ... or something
16:15:54 <Jesin> how can it do sin^2
16:16:02 <djahandarie> Because it has a Num instance for functions
16:16:06 <djahandarie> :t (^)
16:16:07 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
16:16:13 <Jesin> @instances (->)
16:16:14 <lambdabot> Couldn't find class `(->)'. Try @instances-importing
16:16:38 <c_wraith> You can't check on that one via lambdabot.  try GHCi
16:16:58 <Jesin> but GHCi doesn't have a Num instance for functions, does it?
16:17:12 <Jesin> waiit
16:17:13 <parcs> Jesin: read djahandarie's comment
16:17:14 <Jesin> maybe it does...
16:17:49 <Jesin> [19:10:27]	<Boxo>	aha, maybe it's using lambdabot's funny Num
16:17:57 <Jesin> I was under the impression it was just a lambabot thing
16:17:59 <Jesin> :p
16:18:14 <c_wraith> most of what's available in lambdabot is the result of a bunch of imports
16:18:20 <djahandarie> Jesin, only lambdabot-specific things are (.) = fmap, different flip, and I think one or two other small things
16:18:22 <c_wraith> There's very little custom in lambdabot
16:18:24 <c_wraith> > cake
16:18:26 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
16:18:31 <Jesin> ...
16:18:33 <djahandarie> Most big things are imports from other packages
16:18:34 <Jesin> different flip?
16:18:38 <Jesin> (.) = fmap?
16:18:40 <Jesin> what
16:18:45 <djahandarie> :t (.)
16:18:46 <Jesin> :t fmap
16:18:46 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:18:47 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:18:47 <parcs> @type (.:) -- also
16:18:48 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
16:19:05 <djahandarie> :t (Prelude..)
16:19:06 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
16:19:12 <djahandarie> :t flip
16:19:13 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
16:19:18 <djahandarie> :t (Prelude.flip)
16:19:18 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
16:19:37 <Jesin> umm
16:19:39 <Jesin> how's that different?
16:19:43 <Jesin> er
16:19:48 <Jesin> what exactly do those differences do...
16:19:49 <djahandarie> It is more general.
16:19:51 <Jesin> @src (.)
16:19:51 <lambdabot> (f . g) x = f (g x)
16:19:51 <lambdabot> NB: In lambdabot,  (.) = fmap
16:20:10 <djahandarie> For the (r ->) Functor, it is the same as the Prelude definition.
16:20:14 <Jesin> @src flip
16:20:15 <lambdabot> flip f x y = f y x
16:20:29 <Jesin> ...
16:20:31 <Jesin> sooo
16:20:44 <Jesin> hmm.
16:21:08 <Jesin> (^2) . [1..12]
16:21:13 <Jesin> > (^2) . [1..12]
16:21:15 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144]
16:21:23 <Jesin> ...
16:21:32 <Jesin> why isn't it implemented like that in Prelude
16:21:35 <Jesin> that's kinda nice  :p
16:21:39 <Jesin> hmm
16:21:43 <djahandarie> Because it's not easily understood
16:21:58 <Jesin> neither are monads
16:21:59 <Jesin> :p
16:22:05 <Jesin> and you need those to do freaking IO
16:22:11 <djahandarie> No you don't
16:22:14 <djahandarie> You need functions to do IO
16:22:33 <Jesin> what
16:22:35 <Jesin> ...
16:22:56 <Jesin> I guess the "do" syntax can be intuitively treated as magic imperativeness as regards IO
16:23:03 <c_wraith> well, you don't need to understand a thing about monads to do IO.
16:23:06 <c_wraith> exactly
16:23:09 <djahandarie> No magic required either.
16:23:17 <djahandarie> :t (>>=) :: IO a -> (a -> IO b) -> IO b
16:23:18 <lambdabot> forall a b. IO a -> (a -> IO b) -> IO b
16:23:31 <djahandarie> Let me know why you need Monads to use that.
16:24:02 <Jesin> now would probably be a good time to confess that I still don't understand monads
16:24:04 <Jesin> :p
16:24:07 <Jesin> or what >>= does
16:24:31 <djahandarie> If you're following LYAH just continue, no need to jump around
16:24:46 <Jesin> ok, I guess I'll continue that then.
16:24:53 <Jesin> but
16:24:56 <Jesin> (.) = fmap
16:25:00 <Jesin> is actually really nice
16:25:11 <Jesin> and makes a lot of things more elegant
16:25:22 <djahandarie> I don't consider golfed code elegant
16:25:29 <Axman6> good!
16:25:32 <Jesin> eh
16:25:34 <Jesin> fine
16:25:35 <Jesin> well
16:25:38 <Jesin> I meant...
16:25:38 <parcs> i use Data.Functor.(<$>) most of the time
16:25:38 <djahandarie> Man I am being terse and cold today
16:25:50 <djahandarie> Sorry Jesin!
16:25:54 <Jesin> eh, it makes understanding fmap easier, I think
16:26:07 <Jesin> er.
16:26:10 <Jesin> no wait.
16:26:13 <Jesin> ...
16:26:22 <djahandarie> It's another way to think of function composition.
16:26:36 <djahandarie> But function composition isn't hard to think of in the first place
16:26:39 <Jesin> yeah
16:26:41 <Jesin> :p
16:26:43 <Jesin> still
16:26:48 <Jesin> the type signature of (.)
16:26:57 <Jesin> ...
16:27:22 <Jesin> I dunno, I just liked noticing how the Functor thing acts for (a ->)
16:27:29 <Jesin> :p
16:27:32 <djahandarie> Yep, it's neat.
16:27:50 <Jesin> :t flip
16:27:51 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
16:27:54 <Jesin> what's that, though...
16:28:07 <djahandarie> Just plug in (r ->) for f
16:28:16 <djahandarie> :t (Prelude..)
16:28:17 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
16:28:25 <Jesin> hmm...
16:28:27 <djahandarie> Err
16:28:34 <djahandarie> Getting the type of the right thing would help
16:28:37 <djahandarie> :t (Prelude.flip)
16:28:38 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
16:28:44 <Jesin> flip [1..8]
16:28:47 <Jesin> > flip [1..8]
16:28:48 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> [b])
16:28:48 <lambdabot>    arising from a use of...
16:28:54 <Jesin> what
16:28:58 <djahandarie> lambdabot sucks at giving error messages
16:29:02 <djahandarie> Just means it can't show a function
16:29:12 <Jesin> :t flip [1..8]
16:29:13 <lambdabot> forall a b. (Num b, Enum (a -> b)) => a -> [b]
16:29:19 <djahandarie> (The danger of importing billions of packages)
16:29:27 <Jesin> umm
16:29:34 <Jesin> what's a good example of using flip
16:29:38 <Jesin> on something other than a function
16:29:40 <Jesin> :p
16:30:03 <Jesin> :t ($)
16:30:04 <lambdabot> forall a b. (a -> b) -> a -> b
16:30:09 <parcs> > flip [(+2), (^2)] 3
16:30:10 <lambdabot>   [5,9]
16:30:39 <Jesin> :t [(2+), (^2)]
16:30:41 <lambdabot> forall t. (Num t) => [t -> t]
16:30:43 <Jesin> :t flip [(2+), (^2)]
16:30:44 <lambdabot> forall t. (Num t) => t -> [t]
16:30:58 <aristid> flip is maybe the most ingenious Caleskell function
16:31:06 <Jesin> Caleskell=?
16:31:17 <djahandarie> I think sipa came up with it
16:31:41 <Eduard_Munteanu> Cale's variation on Haskell definitions, some of the stuff in lambdabot 
16:31:44 <Eduard_Munteanu> Like...
16:31:46 <Eduard_Munteanu> :t mappend
16:31:48 <lambdabot> forall a. (Monoid a) => a -> a -> a
16:31:52 <aristid> :t (++)
16:31:53 <lambdabot> forall m. (Monoid m) => m -> m -> m
16:32:01 <Eduard_Munteanu> Erm yeah.
16:32:01 <ksf_> :t (.)
16:32:01 <aristid> :t (Prelude.++)
16:32:02 <lambdabot> forall a. [a] -> [a] -> [a]
16:32:03 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:32:06 <djahandarie> Jesin, Cale maintains lambdabot so we jokingly call its version of Haskell 'Caleskell' or 'Hascale'
16:32:13 <ddarius> I don't even think sipa's been around longer than that flip definition.
16:32:24 <ddarius> Cale also likes a lot of this stuff.
16:32:39 <ksf_> :t flip
16:32:41 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
16:33:05 <djahandarie> ddarius, err, it was someone with an s I think
16:33:20 <ksf_> :t (<*)
16:33:22 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
16:33:25 <c_wraith> well that narrows it right down
16:33:25 <djahandarie> Who has been around for a long time
16:33:26 <ksf_> :t (<$)
16:33:27 <parcs> how is flip defined, by the way?
16:33:27 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
16:33:31 <ksf_> :t (<$>)
16:33:33 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:33:33 <c_wraith> @src flip
16:33:34 <lambdabot> flip f x y = f y x
16:33:37 <ksf_> :t (<*>)
16:33:38 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
16:33:45 <Eduard_Munteanu> One of the two Simons? :)
16:33:48 <parcs> lambdabot's flip
16:33:50 <djahandarie> Heh, no
16:34:20 <Boxo> > Just 1 ++ Just 2
16:34:21 <aristid> parcs: http://hackage.haskell.org/packages/archive/functors/0.1/doc/html/src/Data-Functor-Syntax.html#flip (this is not the version used by lambdabot, but equivalent)
16:34:21 <lambdabot>   Ambiguous type variable `t' in the constraints:
16:34:21 <lambdabot>    `Data.Monoid.Monoid t'
16:34:21 <lambdabot>  ...
16:34:41 <Boxo> > (Just 1) ++ (Just 2)
16:34:41 <lambdabot>   Ambiguous type variable `t' in the constraints:
16:34:42 <lambdabot>    `Data.Monoid.Monoid t'
16:34:42 <lambdabot>  ...
16:34:56 <parcs> ah, neat
16:34:58 <variable> :\
16:35:01 <Boxo> > 1 ++ 2
16:35:02 <lambdabot>   Ambiguous type variable `a' in the constraints:
16:35:02 <lambdabot>    `Data.Monoid.Monoid a'
16:35:02 <lambdabot>  ...
16:35:08 <Cale> > Just [1] ++ Just [2]
16:35:09 <copumpkin> > Just (Sum 1) ++ Just (Sum 2)
16:35:11 <lambdabot>   Just [1,2]
16:35:11 <lambdabot>   Just (Sum {getSum = 3})
16:35:20 * variable is NOT an Ambiguous type
16:35:35 <aristid> > Just [1] ++ Nothing
16:35:37 <lambdabot>   Just [1]
16:35:43 <aristid> zomg
16:35:44 <Boxo> oh, right
16:35:55 <aristid> > Just [1] `mplus` Nothing
16:35:56 <lambdabot>   Just [1]
16:36:28 <Boxo> > mconcat [Nothing, Nothing, Just [], Just "aa"]
16:36:29 <lambdabot>   Just "aa"
16:36:32 <applicative> The flip definition is pretty amazing. 
16:36:59 <aristid> :t catMaybes
16:37:00 <lambdabot> forall a. [Maybe a] -> [a]
16:37:04 <roconnor> Eduard_Munteanu: hi
16:37:04 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
16:37:20 <Eduard_Munteanu> Hey.
16:37:29 <Jesin> :t ($ 3)
16:37:30 <lambdabot> forall a b. (Num a) => (a -> b) -> b
16:37:34 <Jesin> :t (`id` 3)
16:37:35 <lambdabot> forall t t1. (Num t) => (t -> t1) -> t1
16:37:37 <Jesin> :p
16:37:47 <lispy> haddock: parsing haddock prologue failed
16:37:47 <Jesin> why the type restriction on ($)
16:37:49 <lispy> hmm
16:37:55 <roconnor> Vitter's algorithm is kinda complicated, even in Pascal.
16:37:56 <Jesin> :t ($)
16:37:57 <lambdabot> forall a b. (a -> b) -> a -> b
16:37:59 <Jesin> :t id
16:38:00 <lambdabot> forall a. a -> a
16:38:11 <Boxo> @pl \a b c d -> d
16:38:11 <lambdabot> const (const (const id))
16:38:20 <Jesin> @pl ($)
16:38:20 <lambdabot> id
16:38:22 <Jesin> :p
16:38:25 <Eduard_Munteanu> roconnor: yeah, it kinda is.
16:38:46 <roconnor> are you doing that one, or are you doing (Faller-Gallager-Knuth)
16:39:03 <djahandarie> roconnor, "even in Pascal"?
16:39:06 * djahandarie wouldn't normally say that
16:39:28 <Eduard_Munteanu> roconnor: my description relies on that "sibling property" thingy, I guess it's Vitter's.
16:39:34 <Eduard_Munteanu> FGK seems a bit different.
16:39:50 <djahandarie> Eduard_Munteanu, so when is your homework due?
16:39:53 <etpace> has anyone here used takusen with postgresql? im having trouble with overlapping instances
16:39:54 * djahandarie wants to try this challenge out
16:40:05 <roconnor> whoa, I think I blacked out for a second
16:40:11 <Eduard_Munteanu> djahandarie: mm, I think on 4th of January.
16:40:13 <djahandarie> roconnor, thankfully the channel has logs!
16:40:41 <djahandarie> roconnor, also, check that you don't have an alter-ego doing stuff behind your back
16:40:50 <roconnor> djahandarie: Vitter's published algorithm is in Pascal
16:41:10 <djahandarie> Ah
16:42:08 <roconnor> Eduard_Munteanu: you have blocks of weights that are either all leaves or all internal nodes?
16:43:45 <Eduard_Munteanu> roconnor: hm no. It's basically a tree with symbols on leaves and only counts on forks. The tree has to obey some properties.
16:44:44 <aristid> :t zipWith fmap
16:44:45 <lambdabot> forall a b (f :: * -> *). (Functor f) => [a -> b] -> [f a] -> [f b]
16:44:56 * ddarius grabbed the wrong tea!
16:45:29 <Eduard_Munteanu> roconnor: hm, actually I'm not sure it's not FGK.
16:45:34 <lispy> Is there a way to do code examples in the description field?
16:46:06 <lispy> Supposedly it's haddock syntax, but I put ">" at the start of each line in my example block and it renders it all on one line with the greater than characters in there
16:46:15 <lispy> I also tried @/@ at the start/end
16:46:23 <Eduard_Munteanu> I'm also working with a description of the algorithm where counts decrease from left to right.
16:46:32 <ddarius> roconnor: If you're blacking out for no reason, you may want to talk to your doctor about it.
16:46:42 <roconnor> ddarius: I am a doctor
16:46:59 <ddarius> roconnor: Doctors still have doctors.
16:47:17 <j-invariant> haha
16:47:22 <j-invariant> Doctor of philosophy?
16:47:30 * ksf_ blacks out every day at night and noon.
16:47:33 <j-invariant> That wont help with the blackouts
16:47:35 <Eduard_Munteanu> "The basic difference between FGK and Vitter is that FGK doesn't check the entire tree when updating weight class or use any type of numbered ordering scheme."
16:47:35 <roconnor> Eduard_Munteanu: maybe it is FGK. In Vitter's it seems important to block the leaves separately from the internal nodes
16:47:57 <ddarius> (Unless you're Werner Formann.)
16:47:59 <Eduard_Munteanu> I don't use a specific ordering number, so it looks like FGK.
16:48:06 <roconnor> j-invariant: yes 
16:48:57 <roconnor> Eduard_Munteanu: I must admit after reading Vitter's papers vs other internet resrouces I'm confused as to what FGK is. :)
16:48:59 <medfly`> roconnor, are you really a doctor?
16:49:04 <roconnor> medfly`: yeshttp://tunes.org/~nef/logs/haskell/"
16:49:08 <roconnor> oops
16:49:14 <roconnor> medfly`: yes
16:49:34 <medfly`> ... what kind of doctor?
16:49:41 <roconnor> not the kind that helps people
16:49:41 <Eduard_Munteanu> roconnor: Faller-Gallagher-Knuth. But I'm still not sure with all these variations on the algorithm.
16:49:43 <EvanR> love doctor
16:49:43 <medfly`> the kind that gets to look at my genitals?
16:50:18 <ddarius> medfly`: Who gets to look at your genitals is mostly up to you.
16:50:55 <ksf_> ddarius, that's a sure way to get arrested.
16:51:23 <j-invariant> 00:49 < roconnor> not the kind that helps people
16:51:27 <j-invariant> why not?
16:51:45 <medfly`> maybe he examines dead bodies.
16:51:46 <roconnor> j-invariant: I don't know how
16:51:56 <aristid> roconnor: a doctor of computers? :D
16:52:25 <lispy> What is wrong with this description field?  Haddock dies and the hackage upload form doesn't markup the code block: http://dpaste.com/291727/
16:52:26 <EvanR> medfly`: another rhetorical question, what kind of doctor is the doctor on doctor who?
16:52:40 <c_wraith> a time doctor?
16:52:58 <Eduard_Munteanu> roconnor: my paper seems to hint that whenever a node is updated, you update a subset of the nodes in the tree, then move up to the parent. Rinse and repeat.
16:53:18 <Eduard_Munteanu> (update by interchanging subtrees)
16:53:20 <djahandarie> What would be a neat paper to present to a bunch of CS grad students who don't know much about purely functional programming etc?
16:53:33 * djahandarie queries the Haskell hive-mind
16:53:36 <Eduard_Munteanu> Anyway, it doesn't look too complicated, so it might be FGK.
16:53:48 <medfly`> djahandarie, this is how I do all my work
16:53:49 <roconnor> Eduard_Munteanu: That will be true of both Vitter's and FGK
16:53:50 <c_wraith> djahandarie, from what perspective?  I mean, there's "Why Functional Programming Matters"
16:53:53 <roconnor> Eduard_Munteanu: :)
16:54:08 <djahandarie> c_wraith, right, thought about that one but it didn't feel academic enough ;)
16:54:09 <ddarius> @where whyfp
16:54:09 <lambdabot> http://www.math.chalmers.se/~rjmh/Papers/whyfp.html
16:54:53 <roconnor> djahandarie: Vitter's paper on dynamic huffman encoding.  There is no functional programming in it at all.
16:54:54 <BMeph> djahandarie: Corecursive queues! :)
16:55:03 <monochrom> lispy: "@snippet-start <filename>" looks really wrong. @ and " are special in haddock
16:55:50 <monochrom> also <
16:56:05 <ddarius> djahandarie: You could present Bart Jacobs' PhD thesis.
16:56:29 <lispy> monochrom: thanks, that was it.
16:56:39 <lispy> Haddock was just saying, "failed to parse prologue"
16:56:43 <djahandarie> ddarius, link?
16:56:58 * monochrom fails to parse prolog, too :)
16:57:03 <ddarius> 3http://www.cs.ru.nl/B.Jacobs/PAPERS/PhD.ps
16:57:10 <ddarius> -3
16:57:29 <djahandarie> Ah, screw .ps
16:59:51 <Eduard_Munteanu> Bah, I might also need to rescale frequency counters.
16:59:57 <djahandarie> ddarius, okay this is probably too hardcore
17:00:31 * hackagebot snippet-extractor 0.2.0 - Extracts labeled snippets of code to files.  http://hackage.haskell.org/package/snippet-extractor-0.2.0 (JasonDagit)
17:00:38 <djahandarie> No satisfying me I guess
17:00:43 <c_wraith> djahandarie, you remind me of goldilocks
17:01:50 <parcs> djahandarie: what about http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/mark.pdf?
17:02:10 <ddarius> c_wraith: In that he gets eaten by a bear?
17:02:15 <c_wraith> yes
17:02:27 <ddarius> c_wraith: I too noticed that similarity.
17:02:45 * djahandarie feel picked on
17:03:00 <c_wraith> We're trying to warn you about the bear standing behind you
17:03:06 <c_wraith> But pay no mind, if you'd rather ignore us
17:03:13 <j-invariant> goldilocs was happy with "just right"
17:03:19 <ddarius> Perhaps those picking feelings are bear teeth.
17:03:45 <djahandarie> parcs, hmmm... I think this could be good
17:03:58 <djahandarie> Would need to give some background but I could probably do that fairly quickly
17:06:36 <lispy> So, {} aren't marked as special in the haddock manual but it's erasing them from the output.  I even tried escaping them and it still deleted them.
17:06:39 <Jesin> > (sin^2 + cos^2 - 1) . [0..4]
17:06:41 <lambdabot>   [0.0,0.0,0.0,-1.1102230246251565e-16,0.0]
17:06:49 <Jesin> :t (+)
17:06:49 <lambdabot> forall a. (Num a) => a -> a -> a
17:07:05 <c_wraith> haha.  You discovered floating point error :)
17:07:08 <Jesin> :t (sin^2 + cos^2 - 1)
17:07:09 <lambdabot> forall a. (Floating a) => a -> a
17:07:29 <Jesin> :t sin
17:07:30 <lambdabot> forall a. (Floating a) => a -> a
17:07:38 <Jesin> @instances Num
17:07:39 <lambdabot> Double, Float, Int, Integer
17:07:46 <Jesin> wtf is this
17:07:57 <Jesin> ...
17:08:08 <c_wraith> the @instances command isn't live.  It has very limited results.
17:08:16 <Jesin> k
17:08:28 <Jesin> is there a live "isinstance"
17:09:01 <c_wraith> there's @instances-importing, but you have to know what module the instance is from for that to be useful
17:09:02 <j-invariant> I can't find bart jacobs phd
17:09:23 <Eduard_Munteanu> roconnor: looks like FGK is less strict in that it allows the sibling property to be maintained by just one swapping per level.
17:09:42 <Jesin> ok
17:09:47 <Eduard_Munteanu> roconnor: but anyway the difficulties you're mentioning really pertain to extensive optimization.
17:09:51 <Jesin> I wanna know how sin and cos are Num instances...
17:09:55 <Jesin> where's that implemented
17:09:59 <Jesin> because that's really pretty nice
17:10:01 <Jesin> :p
17:10:10 <Eduard_Munteanu> roconnor: but I'm more concerned with expressing it functionally. :)
17:10:20 <ddarius> j-invariant: Your inability is impressive considering I posted the link.
17:11:26 <Eduard_Munteanu> So I'd be happy if my Haskell implementation would be say, twice slower than a hypothetical, not really optimized C variant.
17:11:33 <j-invariant> got it now thanks :D
17:11:46 <Eduard_Munteanu> (I got similar results with Shannon-Fano, so it's a nice indicator :))
17:13:03 <Jesin> so, what
17:13:20 <Jesin> is (Num a => a -> a) an instance of Num?
17:13:24 <Jesin> in lambdabot, I mean
17:13:35 <Jesin> or is it more general than that?
17:14:38 <Jesin> > (sin / cos) (pi/4)
17:14:38 <lambdabot>   0.9999999999999998
17:14:40 <roconnor> Eduard_Munteanu: it won't be twice as slow, it will be of worse complexity.
17:14:44 <Jesin> hmm.
17:14:53 <roconnor> Eduard_Munteanu: not that I think that is a big deal
17:14:54 <Jesin> I wanna see the code for that
17:14:55 <Jesin> :p
17:15:00 <c_wraith> > (sin / cos) (pi / 4) :: CReal
17:15:01 <lambdabot>   1.0
17:15:13 <Jesin> what's CReal
17:15:27 <aristid> Jesin: infinite precision numbers
17:15:29 <c_wraith> a type for arbitrary-precision computable numbers
17:15:35 <mm_freak> Jesin: it's not more general, and it's also problematic with the current prelude
17:15:35 <Jesin> ...
17:15:37 <c_wraith> It's slow, but it's correct!
17:15:42 <aristid> c_wraith: sounds coolers if you say infinite
17:16:02 <Eduard_Munteanu> roconnor: mind I wouldn't have done much research to implement it in C, so 'worse complexity' must come from tradeoffs wrt expressivity vs performance, not actual algorithm considerations.
17:16:08 <c_wraith> it's more correct if I say arbitrary. :P
17:16:16 <mm_freak> > sin == sin
17:16:17 <lambdabot>   *Exception: (==): No overloading for function
17:16:35 <Jesin> hmm
17:16:47 <Jesin> and I suppose the current Prelude
17:16:56 <Jesin> requires Nums to be Eq?
17:16:59 <roconnor> Eduard_Munteanu: well I mean if you use immutable data stucutres it is not clear how to maintain the same complexity.  If you use STrefs or IOrefs then you can just implement the imperitive algorithm in Haskell, as you well know.
17:17:13 <mm_freak> Jesin: and Show
17:17:20 <mm_freak> > show sin
17:17:21 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
17:17:21 <lambdabot>    arising from a use of `...
17:17:30 <mm_freak> huh?
17:17:42 <Jesin> overlapping instances, what
17:18:00 <monochrom> lambdabot has a lot of extra baggages loaded
17:18:13 <monochrom> in fact for example:
17:18:15 <monochrom> > getLine
17:18:16 <lambdabot>   <IO [Char]>
17:18:23 <monochrom> should not happen
17:18:34 <Jesin> what
17:18:41 <monochrom> don't trust lambdabot
17:18:46 <mm_freak> monochrom: what's wrong with that?
17:18:50 <roconnor> Jesin: lambdabot has a bunch of crazy extra instances of things
17:19:10 <monochrom> raises artificial expectation of ghci
17:19:11 <lispy> monochrom: I have another haddock question :)  In my code block I used a { character.  In the haddock output, that character was missing, so I made it \{ and the output became \.  Any idea how to get the { character?
17:19:13 <mm_freak> it's probably just a Show instance for (Typeable a => IO a)
17:19:25 <monochrom> I don't know how.
17:19:40 <monochrom> oh, actually
17:19:46 <monochrom> > ord '{'
17:19:48 <lambdabot>   123
17:19:56 <monochrom> &#123;
17:19:59 <Jesin> > chr 123
17:20:00 <lambdabot>   '{'
17:20:45 <Eduard_Munteanu> roconnor: worst case, I think not holding "pointers" to tree leaves gives an additional O(log M) for looking it up every time. So far compression it's O(N * log M) where N is the stream length, and M is the number of symbols in the tree.
17:20:45 <lispy> hmm
17:20:48 <lispy> I will try that
17:20:52 <Eduard_Munteanu> An additional factor might come from zipper updates.
17:21:13 <lispy> > ord '}'
17:21:14 <lambdabot>   125
17:21:37 <roconnor> Eduard_Munteanu: how do you find the leaves so fast?
17:21:38 <Eduard_Munteanu> In case of swapping, considering you have to go back to the root and down to the other context, it looks like O(log M) again.
17:22:05 <lispy> monochrom: heh, I get for(i = 0; i < 100; i++)&#123;
17:22:11 <monochrom> yikes :)
17:22:27 <Eduard_Munteanu> roconnor: that's still something I'm pondering on. It could be fast if I have a symbol <-> frequency map, so I do linear search for symbols of equal frequency only.
17:22:37 <lispy> monochrom: I wonder if it's a cabal bug where cabal is stripping out {
17:22:43 <Axman6> surely there a C ??x conversion right?
17:22:53 <Axman6> what're they called? trigraphs?
17:23:03 <Eduard_Munteanu> roconnor: but yes, that was an underestimation a bit. Might be safer to say O(M)
17:23:07 <monochrom> "in the bird-track form, the text to the right of the ‘>’ is interpreted literally, whereas the @...@ form interprets markup as normal inside the code block."
17:23:11 <systemfault> lol @ digraphs/trigraphs
17:23:11 <Jesin> > chr 124
17:23:12 <lambdabot>   '|'
17:23:31 <lispy> monochrom: okay, I'll try @..@ form
17:23:32 <roconnor> Eduard_Munteanu: well you can have a symbol -> code map, and then using the code you can zip down the tree in O(tree-depth) time ... which could be linear in the size of the huffmann tree
17:23:48 <roconnor> Eduard_Munteanu: well, you are going to have to zip down the huffman tree anyways
17:23:54 <monochrom> @..@ form requires you to escape things left right and centre
17:23:54 <lambdabot> Maybe you meant: . @
17:23:56 <Eduard_Munteanu> Yes.
17:24:10 <lispy> monochrom: closer
17:24:15 <roconnor> which will take O(tree-size) anyways since the huffman tree can be completely unbalanced in the worst case for FGK
17:24:48 <roconnor> Again, this isn't bad for an assignment, but it won't win any converts to functional programming ;)
17:24:57 <Eduard_Munteanu> Heh, yeah.
17:25:22 <qfr> How would you go about running arbitrary Haskell programs which are all supposed to have their own stdin/stdout/stderr in such a way that you always have only one instance of ghci? (I am thinking of something along the lines of a Common Lisp SWANK server or whatever it's called, I think, where you run all the services within the same CL process with the same Lisp image) The purpose of all this is to reduce the amount of non-shared memory used. When I'm running
17:25:22 <qfr>  15 hello world processes which consume like 450 MiB of non shared memory whereas I would hope that it's possible to run them all in the same interpreter, reducing the memory usage to about 35-45 MiB.
17:25:58 <Eduard_Munteanu> Actually I hear my peers' Matlab implementations are really bad. (Those who actually did it without 'googling' for a solution.)
17:26:08 <mm_freak> qfr: what about concurrency?
17:26:08 <Eduard_Munteanu> *bad in terms of performance
17:26:15 <lispy> monochrom: not really worth the hassle I guess.  When I switched to the @..@ version it kills the space formatting
17:26:16 <qfr> the CL way to do that would be to run the server and connect to it using emacs, then launching/stopping stuff within that instance of SBCL, for example
17:26:24 <lispy> monochrom: I'll just leave out the {} characters
17:26:34 <Eduard_Munteanu> But that was for Shannon-Fano et al.
17:26:55 <roconnor> Eduard_Munteanu: actually maybe even with Vitter's algorithm the huffam tree could be unbalanced, since the frequences may make an unbalance tree the optimal coding strategy
17:27:12 <roconnor> Eduard_Munteanu: on the other hand, maybe it amortizes, so it isn't so bad
17:27:45 <mm_freak> qfr: haskell's way to deal with this is concurrency…  that also works in compiled code
17:27:50 <roconnor> Eduard_Munteanu: I mean if you have to zip down O(tree-size) to get to the leaf, you are also going to have to transmit a O(tree-size) code which will take O(tree-size) time anyways
17:27:55 <mm_freak> (and especially well there in fact)
17:28:12 <roconnor> Eduard_Munteanu: so maybe the complexity isn't worse after all.
17:28:25 <monochrom> 0. you don't have to use stdin,stdout,stderr.  1. dynamically linked executables eliminates a lot of lib code duplication in memory.
17:28:58 <qfr> mm_freak: So I'd have to write all of it on my own? Also, is it easy to load new code and unload loaded code in ghci at runtime? I wanted to manage this in a way similar to screen sessions or something like that really, where you can switch between the programs running in the interpreter, look at different screens, type something in one or two of them, launch a new one, kill another one, etc. All within the same instance of ghci.
17:29:11 <qfr> Although ghci simply launches ghc on Windows, it seems. Not sure about Linux.
17:29:31 <Eduard_Munteanu> roconnor: yeah, I guess I'm gonna go the zippers way, at least it's interesting. I hope I don't hit any major expressiveness hurdles.
17:29:48 <mm_freak> qfr: i think that you're asking for another development workflow
17:29:54 <ddarius> GHCi is a development tool that isn't really intended for nor appropriate for production use.
17:30:01 <mm_freak> the way it is done in CL is not possible to this extent in haskell
17:30:17 <Saizan> s/in haskell/in GHC/
17:30:25 <qfr> mm_freak is it because CL is dynamic whereas Haskell is static?
17:30:41 <mm_freak> Saizan: also not in haskell…  CL is very dynamic
17:30:49 <Eduard_Munteanu> roconnor: the STRef/IORef approach isn't great at all, except for demonstrating that "yes, you can do C in Haskell".
17:30:53 <Saizan> you can have eval in haskell too
17:31:00 <ddarius> mm_freak: There's no inherent problem with doing this in Haskell.
17:31:04 <roconnor> Eduard_Munteanu: yes
17:31:06 <Eduard_Munteanu> (in which case I could just as well FFI to C code :P)
17:31:10 <roconnor> yes
17:31:20 <lispy> monochrom: FWIW, this is a cabal bug.
17:31:21 <qfr> Hmm maybe I should do my webdev stuff in CL instead, Haskell might be too brutal for this
17:31:27 <monochrom> lispy: cabal doc section 3.1.5.1 "As an alternative to using layout you can also use explicit braces {}."
17:31:34 <Saizan> qfr: the main difference is that GHC is primarily a compiler
17:31:35 <qfr> But I thought it might be a nice way to force myself to learn some Haskell
17:31:39 <lispy> monochrom: (I just checked here by putting the working documentation in a haddock in my program
17:31:40 <Eduard_Munteanu> roconnor: thanks for looking it up though, I hope it works out well.
17:31:43 <ddarius> qfr: I agree that Haskell is a bad way to do CL development.
17:31:52 <mm_freak> qfr: haskell is really fine for web development (i love the yesod framework)
17:31:58 <roconnor> Eduard_Munteanu: it is a very intresting problem
17:32:01 <mm_freak> but it's just another workflow than in CL
17:32:08 <ddarius> Saizan: Most serious implementations of CL are primarily compilers too.
17:32:13 <monochrom> not sure how to tell cabal I want literal {
17:32:29 <monochrom> this is why plain text file is such a myopic idea
17:32:43 <Eduard_Munteanu> roconnor: maybe it's as difficult as doing the same thing for imperative linear algebra (matrix) algos.
17:33:01 <roconnor> Eduard_Munteanu: I'm not sure.  I think it is harder
17:33:04 <monochrom> "you could use any vanilla editor" my ass
17:33:07 <lispy> monochrom: I think I'll post a bug report (although, I doubt anyone will look at it or care)
17:33:12 <Eduard_Munteanu> Heh.
17:33:49 <Eduard_Munteanu> Still, so far I'm yet to see functional LU decompositions :)
17:34:01 <Eduard_Munteanu> Or that sort of stuff.
17:34:09 <mm_freak> qfr: haskell/GHC being so static is not worse than CL, it's just different and just as productive, once you understand it and are used to it
17:34:37 <roconnor> Eduard_Munteanu: I have Gothier's implementaiton in Coq.
17:34:46 <roconnor> *Gonthier
17:35:08 <roconnor> at least I think I do
17:35:10 * roconnor checks
17:35:28 <ddarius> Eduard_Munteanu: In many of those scenarios operating in-place and data layout are very significant, and also tuned, publically available implementations already exist, why recreate them?
17:36:43 <roconnor> Lemma cormen_lup_correct : forall n (A : 'M_n.+1),
17:36:44 <roconnor>   let: (P, L, U) := cormen_lup A in P * A  = L * U.
17:36:53 <Eduard_Munteanu> I'd say it would be something that could guide development of other algos.
17:37:04 <roconnor> that being said, Gonthier isn't really intrested in efficency
17:37:37 <Eduard_Munteanu> Meh, yeah.
17:37:54 <qfr> mm_freak me worrying about memory usage is unncessary anyways, it would be rather harmless, maybe 3-4 processes overall so the overhead is slightly annoying but no big deal
17:38:16 <c_wraith> I do wish the ghc could garbage-collect compiled code after it can no longer be used.
17:38:20 <Eduard_Munteanu> For LU itself it doesn't make sense, as even LAPACK is better than writing your own C code.
17:38:24 <mm_freak> qfr: why different processes in the first place?  haskell has a wonderful concurrency system
17:38:37 <Eduard_Munteanu> But it does make sense if you want to learn lessons and apply them to something else.
17:38:40 <qfr> mm_freak: How do I update them at runtime?
17:38:49 <qfr> mm_freak they are different sites, different codebases etc
17:38:59 <qfr> I don't want to shut down all services when I mess with one site
17:39:04 <mm_freak> i think nowadays GHC has a dynamic loader
17:39:13 <roconnor> Eduard_Munteanu: http://hpaste.org/42634/cormenlup_in_coq
17:39:16 <c_wraith> GHC has had a dynamic loader for the last several years :)
17:39:31 <lispy> monochrom: http://hackage.haskell.org/trac/hackage/ticket/784
17:39:39 <roconnor> Eduard_Munteanu: n is the dimension of the matrix
17:39:44 <lispy> monochrom: I just created that, feel free to add to it if you think I forgot something
17:39:50 <roconnor> well one less than the dimension of the matrix
17:42:17 <qfr> Web development usually consists of small modifications followed by tests. With my Ruby framework I would usually write like 30 lines, restart the thin server and refresh the browser. What would the workflow with Haskell be like? Is there even any point in creating standalone binaries with Haskell or do you simply interpret stuff?
17:43:07 <mm_freak> qfr: i use nginx and access the yesod application through fastcgi
17:43:11 <roconnor> qfr: in haskell you write the code and it works
17:43:14 <roconnor> :)
17:43:15 <Eduard_Munteanu> roconnor: not sure, but it looks efficient, except for in-place updating.
17:43:19 <qfr> Yeah I use nginx, too
17:43:30 <qfr> roconnor: ...
17:43:30 <mm_freak> this works great and you can replace a running process with a new one quite fast#
17:43:53 <Eduard_Munteanu> (the lemma doesn't need to be an efficient computation though, it's a proof)
17:43:56 <mm_freak> my Makefile handels restarting for me
17:44:20 <qfr> mm_freak you use the GNU automake? :o
17:44:29 <roconnor> Eduard_Munteanu: at least it doesn't look grossly inefficent.  I don't know how fast LU decomposition is supposed to be.
17:44:30 <mm_freak> qfr: no
17:44:34 <mm_freak> only GNU make
17:44:51 <mm_freak> it mainly just calls cabal and restarts the yesod app
17:45:01 <Saizan> qfr: interpreting in ghci is much less efficient in many cases, if that wasn't clear :)
17:45:03 <qfr> I have never seen that being used for anything other than C and C++ really
17:45:09 <qfr> For actual minimal rebuilds
17:45:15 <qfr> Saizan oh, ok
17:45:16 <mm_freak> also emacs can't handle cabal by itself, but it can handle Makefiles
17:45:30 <mm_freak> i use Makefiles a lot
17:45:34 * ddarius leaves.
17:45:39 <mm_freak> not only for development
17:45:53 <qfr> I thought cabal was Haskell's internal package management system, akin to something like Python eggs and Ruby gems
17:45:56 <Eduard_Munteanu> Mmm, yeah, I'm not sure how much of a good idea those permutations (as in actually generating and multiplying by them) are.
17:45:57 <qfr> Does it do more?
17:46:03 <mm_freak> i even use them for automatic image processing or making backups
17:46:32 <Eduard_Munteanu> And it's kinda using recursion in place of monadic code to do updates.
17:46:35 <mm_freak> qfr: cabal is not a package /management/ system, rather just a convenient installer for hackage
17:46:48 <mm_freak> no
17:46:52 <mm_freak> that's wrong
17:46:58 <roconnor> Eduard_Munteanu: ya. It is designed to be as simple and obviously correct as possible.  It isn't really meant to be executed :)
17:46:59 <mm_freak> cabal is a distribution library =)
17:47:12 <Eduard_Munteanu> Heh, yeah, rather compiled.
17:47:23 <mm_freak> and the 'cabal' command line tool is what i've just said =)
17:48:01 <roconnor> Eduard_Munteanu: the complexity still might be good though.
17:48:11 <Saizan> the Cabal lib also bundles a default build system
17:48:30 <qfr> mm_freak: In my Ruby framework I pretty much just run everything from Rack up, which is pretty much just a CGI wrapper so everything beyond that point is written by me. Does Haskell provide a convenient FastCGI wrapper or something like that for this? nginx does support FastCGI after all
17:48:47 <qfr> I guess most frameworks do much more than I want/need
17:48:57 <qfr> And I do the static content serving with nginx
17:49:00 <mm_freak> qfr: sure:  wai-handler-fastcgi is the one i use
17:49:07 <qfr> Nice, alright
17:49:14 <mm_freak> (and most, if not all, yesod projects use)
17:50:25 <mm_freak> and don't compare yesod to ZF or something like that…  it's really great for typesafe web dev
17:50:39 <qfr> Is there any reason to use ghc 7 over 6 at this point? Did a major change in the language occur? Is there a huge split akin to Python 2 vs. 3 or something currently going on?
17:50:46 <qfr> What's ZF?
17:50:55 <mm_freak> PHP Zend Framework
17:51:03 <qfr> Eew :(
17:51:05 <mm_freak> i'd rather call it a mess
17:51:11 <Eduard_Munteanu> They don't have a 'C'? :P
17:51:11 <mm_freak> but i have to use it at work
17:51:35 <qfr> I am not a friend of PHP, although I used it for several years when I was younger
17:52:04 <mm_freak> me neither
17:56:33 <qfr> mm_freak what do you use to generate markup? In Ruby I wrote a small silly DSL for that purpose, it reduced the number of markup errors greatly although it still permitted stuff like placing a title tag in the middle of the body.
17:56:48 <qfr> In PHP I just embedded markup all the time
17:56:53 <qfr> Written manually :(
17:58:29 <mm_freak> qfr: in yesod you mostly use hamlet, because it's well integrated, but you can use any package for that
17:58:39 <mm_freak> i liked pandoc's markdown a lot
17:59:15 <qfr> mm_freak: Can you modify those at runtime without messing with the process or how does it work?
17:59:44 <mm_freak> markdown yes, hamlet no, because the hamlet markup actually gets compiled
17:59:48 <mm_freak> this has a reason though
17:59:56 <qfr> Performance reasons?
18:00:07 <mm_freak> it gives you type-safe markup and access to some functionality at runtime
18:00:17 <mm_freak> i.e. statically typesafe
18:01:01 <mm_freak> you can combine both
18:01:13 <mm_freak> for example use markdown for dynamic content
18:01:19 <mm_freak> and hamlet for static
18:03:48 <mm_freak> that's actually really a great solution, because hamlet is really just a DSL for HTML, CSS and javascript
18:03:50 <qfr> mm_freak: I don't really get markdown, it appears to be a program which converts from one document format to another
18:04:12 <mm_freak> while markdown is really markup and not related to HTML
18:04:27 <qfr> Ah
18:04:30 <mm_freak> pandoc converts between markups
18:04:40 <mm_freak> it can, among others, convert markdown to HTML
18:04:56 <ivanm> rather poorly in most instances though (but that's what you get for having a one-size-fits-all converter)
18:05:53 <ivanm> e.g. pandoc's markdown -> latex converter usually writes weird-looking latex for section headers, etc.
18:06:32 <mm_freak> dunno, i've only used it for markdown → HTML
18:06:37 <mm_freak> and that works great
18:07:36 <ivanm> oh, it works, as long as you don't want to read the output yourself ;-)
18:07:54 * ivanm really should tweak the CSS he uses with his pandoc-generated homepage for graphviz
18:08:43 <mm_freak> generally i don't care about the product's readability
18:08:48 <mm_freak> the source code needs to be readable
18:09:19 <mm_freak> otherwise we would complain about GHC's generated C code to be unreadable by humans ;)
18:09:29 <qfr> Does ghc generate C?
18:09:43 <dankna> not anymore, as I understand it?
18:09:54 <dankna> but to be honest I'm uncertain
18:09:55 <Eduard_Munteanu> -fvia-C
18:09:59 <Eduard_Munteanu> But not by default.
18:10:06 <ivanm> dankna: still does have that option
18:10:11 <dankna> oh, okay
18:10:17 <ivanm> Eduard_Munteanu: well, it's the default on ppc, etc. IIRC
18:10:22 <qfr> Would using LLVM make any sense for Haskell btw?
18:10:24 <ivanm> since they don't have native code gens
18:10:33 <Eduard_Munteanu> Ah, that makes sense.
18:10:36 <ivanm> qfr: should do; it seems to have quite nice performance characteristics
18:10:38 <qfr> Just wondering, since it's the latest craze. Clang getting big, too, etc
18:10:49 <ivanm> GHC 7 has an LLVM backend
18:10:50 <Axman6> qfr: the latest GHC uses LLVM natively
18:10:57 <qfr> Wow I had no idea
18:11:05 <Axman6> it's not the defauly yet, but may become so eventually
18:11:12 <ivanm> Axman6: well, _can use_ ;-)
18:11:14 <Axman6> just compile with -fllvm
18:11:18 <mm_freak> qfr: it can still generate C code, but that's not default anymore
18:11:18 <ivanm> Axman6: btw, did you get that book?
18:11:33 <mm_freak> current GHC versions below 7.0 have a native code compiler
18:11:33 <Axman6> not yet, Sarah arives on the 31st
18:11:43 <ivanm> ahhh, I thought she flew out yesterday
18:11:52 <Axman6> nope, tomorrow
18:11:55 <ivanm> mm_freak: doesn't 7 have the NCG still?
18:12:00 <qfr> What is the reason for the major version change from 6 to 7 btw?
18:12:06 <ivanm> qfr: because they could
18:12:13 <etpace> good bye bachelor life in tokyo Axman6 
18:12:13 <mm_freak> ivanm: i thought it uses LLVM by default
18:12:15 <ivanm> qfr: new typechecker, new backend, etc.
18:12:20 <ivanm> mm_freak: not AFAIK
18:12:23 <ivanm> still too new, etc.
18:12:27 <mm_freak> ok
18:12:35 <mm_freak> dunno, never used 7.0
18:12:41 <qfr> Is the new language accepted by the compiler no longer backward compatible? That's usually when I see bigger version changes in compilers/interpreters
18:12:42 <mm_freak> i'm still using 6.12
18:12:45 <Axman6> etpace: i was never living the bachelor life here man, you know that
18:12:58 <etpace> its cool dude sarah wont find out
18:13:00 <etpace> postcode rule
18:13:14 <ivanm> qfr: oh, and ghc 7 has support for haskell2010
18:13:25 <ivanm> if you want to write haskell2010-compliant code, it isn't backwards compatible
18:13:27 <qfr> Is that standard radically different?
18:13:34 <djahandarie> Nearly exactly the same.
18:13:37 <ivanm> not really, just a few small changes
18:13:37 <qfr> Cheers
18:13:50 <mm_freak> less extensions to specify
18:14:00 <mm_freak> but only a few
18:14:00 * BMeph is glad to see Axman6, but misses the Bimbo...er, "Bynbo". ;)
18:14:01 <qfr> 2010 makes me think of C++0x so I expected something radical by the sound of it, haha
18:14:24 <BMeph> Axman6: Nice to see your regular name back. :)
18:14:59 <Axman6> heh, i use Bynbo7 when i'm logged in from home, Axman6 from work
18:15:09 <etpace> ircing at work.....
18:15:11 <etpace> terrible..
18:15:27 <Axman6> need to figure out how to SSH into here from home
18:15:38 <etpace> mm
18:16:08 <BMeph> Axman6: So, you're a laid-back bimbo? ;)
18:16:48 <Axman6> sure?
18:16:56 <aristid> qfr: c++0x is hardly radical. it's a complete disappointment for any c++ fan
18:17:19 <Axman6> aristid: thank god we don't like any of them, or we might feel sorry :P
18:17:42 <qfr> aristid: Well, even the most basic stuff will no longer be compatible because people will radically shift towards using auto for a lot of stuff, for example.
18:17:47 <otzi> I think the x stands for an hexadecimal digit
18:17:58 <qfr> I wasn't disappointed, byu the way. What were you disappointed by, aristid?
18:18:26 <aristid> Axman6: i'm pretty sure that some people in here do like c++ to some extent. i'm liking it less and less by the day, but for example ddarius expressed once that he does like it to some degree
18:18:37 <aristid> qfr: for example that they dropped concepts
18:18:40 <otzi> etpace: you don't irc at work?
18:18:46 <otzi> what do you do at work?
18:18:47 <aristid> qfr: and the way lambdas work is also disgusting
18:18:49 <Axman6> yeah, i have a feeling that i'd probably like it if i used it too
18:19:02 <aristid> qfr: i hate that lambdas have an unspecified class type
18:19:10 <monochrom> "what do you do at work" is a strange question :)
18:19:10 <Axman6> otzi: he's sitting right behind me
18:19:18 <megajosh2> Does anybody know a way you can dynamically load Haskell modules while your program is running without using hs-plugins?
18:19:26 <qfr> aristid: Yeah that's a bit messy. We had some laughs at the gcc internals output for that stuff in ##c++ one day
18:19:34 <raichoo> I've been a big fan of C++. Been using it since the late 90's. But I hate it today.
18:19:36 <qfr> sizeof was 1 or 0 or something strange like that
18:19:46 <dankna> megajosh2: use direct-plugins, of which I am the author.  but it's the same strategy as hs-plugins, just a different implementation.
18:19:59 <megajosh2> Alright thanks, I'll take a look
18:20:02 <dankna> sure
18:20:04 <Axman6> hmm, that's a nick i recognise, do i know you from somewhere else raichoo?
18:20:04 <qfr> aristid can you even make a vector of lambdas?
18:20:07 <megajosh2> When using hs-plugins I get weird errors
18:20:14 <megajosh2> amethyst-plugs: plugins/Test.o: unknown symbol `mtlzm1zi1zi1zi0_ControlziMonadziReader_zdfMonadReaderrReaderT_closure'
18:20:16 <aristid> qfr: no idea
18:20:27 <dankna> yeah, that happens in a number of situations.  I tried hard to give cleaner ones.
18:20:33 <dankna> but I don't always succeed.
18:20:45 <raichoo> Axman6: I think you saw me in the macosx channel some time ago. And maybe auroraux
18:20:52 <mm_freak> the idea for C++0x arose because C++ has a lot of problems
18:21:07 <aristid> megajosh2: that name mangling is not compatible with c++filt :)
18:21:13 <Axman6> ah yes, it was auroraux
18:21:13 <dankna> shouldn't that be 0xC++, if we want to be syntactically valid?
18:21:19 <aristid> mm_freak: and the proposed fixes were mostly dropped
18:21:20 <monochrom> haha
18:21:23 <dankna> :D
18:21:29 <mm_freak> now what they really did was to add additional features, which come with their own problems, without fixing any of those problems
18:21:51 <monochrom> 0xC is unlikely to be an lvalue, can't quite do 0xC++
18:21:51 <qfr> dankna: ++ requires an lvalue, no?
18:21:59 <qfr> monochrom: Programmer high five
18:22:12 <monochrom> but the tokeniser is probably fine with it
18:22:16 <qfr> Yeah
18:22:24 <dankna> I said syntactically :)
18:22:31 <mm_freak> dankna: how is 0xC++ syntactically valid?
18:22:32 <otzi> C++0x is syntatically valid
18:22:36 <monochrom> everything is syntax
18:22:37 <mm_freak> oh
18:22:40 <mm_freak> it is, indeed
18:22:44 <mm_freak> ok, forget it =)
18:22:47 <dankna> mm_freak: it's a hex constant, haha
18:22:48 <dankna> yeah
18:22:53 <aristid> dankna: c++ grammar is pretty context sensitive, so you might argue that l-valueness is part of the syntax
18:23:04 <dankna> that's a fair point which in no way detracts from the joke
18:23:50 <Jesin> umm
18:23:51 <dankna> I seem to have derailed the discussion, sorry :)
18:23:55 <mm_freak> well, so we would have 0xC++, even though invalid, it would actually be a great name
18:23:55 <Jesin> how's C++0x valid
18:24:03 <dankna> yeah
18:24:09 <mm_freak> because what comes after 0xC?  0xD…  i.e. 13
18:24:17 <Jesin> how about 0x++C
18:24:21 <monochrom> C is 12
18:24:22 <raichoo> Jesin: Preprocessor *scnr*
18:24:28 <dankna> hah!  so we could publish it three years later
18:25:17 <monochrom> Ocean's 0xC++
18:25:29 <aristid> lol
18:27:07 <mm_freak> monochrom: and (*(int *)malloc(sizeof(int)) = 0xC)++ is 0xD
18:27:16 <mm_freak> actually a great name for C++0x
18:27:29 <raichoo> The worst thing I ever saw in C++Land was a 8 lines functionname in a stacktrace. Template insanity…
18:27:33 <mm_freak> ugly syntax, unnecessarily complicated
18:28:37 <aristid> mm_freak: no no no, you would get lynched for that
18:28:42 <aristid> use reinterpret_cast
18:28:55 <EvanR> use haskell
18:29:15 <mm_freak> aristid: i agree with EvanR =)
18:29:40 <raichoo> I'm still not fully converted. Just tinkering with pleasure ^^
18:29:52 <EvanR> raichoo: youll get there. dont worry
18:30:09 * raichoo is pretty much into scala these days.
18:30:24 <raichoo> But the IO Monad in Haskell really is sweet.
18:30:35 <EvanR> what makes it so good?
18:30:45 <EvanR> i avoid it at all costs
18:31:05 <raichoo> I just love the way how you see side effects at first glance.
18:31:14 <Jesin> @instances Enum
18:31:15 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
18:31:21 <roconnor> EvanR: cause it doesn't interfere with the denotation of the rest of the langauge
18:32:12 <EvanR> you mean, because it uses the same denotation as the rest of the language
18:32:28 <EvanR> or because the 'rest of the language' is pure
18:33:55 <c_wraith> Both are actually really nice.
18:34:15 <c_wraith> I recently used IO (IO (IO (), Snap ())) in a type signature :)
18:34:24 <mm_freak> EvanR: IO is pure, too
18:34:40 <EvanR> the old technicality
18:34:44 <c_wraith> It's nice to be that explicit about what your IO actions do :)
18:35:20 <raichoo> Haskell sucks in the universe and returns a new one \o/
18:35:44 <megajosh2> It's just that powerful
18:36:11 <aristid> raichoo: lol, now i imagine there being a sucking sound whenever i run a haskell program
18:36:16 <mm_freak> EvanR: i don't think that's a technicality…  IO evaluation is pure, unless you use unsafePerformIO
18:36:24 <mm_freak> EvanR: only IO /execution/ is not pure
18:36:30 <raichoo> raichoo: mission accomplished :P
18:36:31 <mm_freak> but that's also something outside of haskell
18:36:34 <EvanR> we werent really talking about evaluation
18:36:42 <Mathnerd314> c_wraith: can't you use join to reduce that to IO (IO (), Snap ()) ?
18:36:51 <mm_freak> EvanR: we were talking about haskell
18:36:56 <raichoo> arg i meant aristid
18:36:59 <mm_freak> and execution is outside of haskell's scope
18:37:01 <aristid> raichoo: :)
18:37:01 <raichoo> Getting late here…
18:37:08 <aristid> raichoo: yeah here too
18:37:09 <c_wraith> Mathnerd314, Not and maintain the abstraction I want
18:37:18 <raichoo> 3:36 am -_-
18:37:52 <c_wraith> Mathnerd314, The outer IO is "run the interpreter to load an action."  the next IO is "initialize internal state, and return a cleanup action and a Snap handler action"
18:38:13 <EvanR> mm_freak: i wouldnt say that
18:38:22 <EvanR> ghc features are a good reason to recommend 'haskell'
18:38:49 <EvanR> if the goal is to avoid outside confusion about our conversation, ok
18:38:50 <ksf_> any hints on books on discrete maths?
18:38:56 <ksf_> I'm looking for the broad+approachable kind.
18:39:10 <dankna> Knuth's _Concrete Mathematics_ isn't exactly what you asked for but is good
18:39:15 <dankna> (it's not just by him)
18:39:19 <dankna> (but I forget the other authors)
18:39:42 <ksf_>   	 Concrete Mathematics: A Foundation for Computer Science?
18:39:48 <dankna> yes
18:39:52 <mm_freak> EvanR: well, there is nothing about execution in the spec or anywhere else…  putStrLn is an opaque DSL construct and could mean anything, as long as the types fit
18:39:56 <c_wraith> Mathnerd314, using join would combine the "run interpreter" portion with the "initialize internal state" portion.  I want them to remain discrete.
18:40:04 <mm_freak> IO could just as well be an HTML generator
18:40:23 <c_wraith> like in the UHC fork that targets javascript?
18:40:27 <mm_freak> which just outputs the individual IO "actions"
18:40:36 <EvanR> 'outputs' ?
18:40:49 <EvanR> sounds like a side effect
18:41:10 <Mathnerd314> mm_freak: but you have read actions, so you also need to print arbitrary functions
18:41:18 <mm_freak> type IO = IOAction -> HTML
18:41:33 <c_wraith> mm_freak, kind error. :P
18:41:35 <EvanR> yeah
18:41:39 <mm_freak> yes =)
18:42:06 <mm_freak> but you get the point
18:42:16 <mm_freak> "IO" is opaque and could mean anything
18:42:34 <mm_freak> inside of haskell it's really just a DSL
18:43:05 <raichoo> So is the STM monad.
18:43:18 <mm_freak> yes
18:43:34 <c_wraith> yeah.  I still think STM is totally awesome, and have yet to find an appropriate use for it (given its current implementation)
18:43:47 <EvanR> it isnt true that you can consider IO to be like any other monad when thinking about how to write code
18:43:53 <mm_freak> c_wraith: today i've found the first real use for STM
18:44:07 <mm_freak> c_wraith: timing out IO computations is really easy to do with STM
18:44:08 <EvanR> because IO is the only one that can cause robot arms to kill innocents
18:44:18 <c_wraith> mm_freak, ....  System.Timeout?
18:44:22 <EvanR> whether or not you call it 'haskell' does not wipe the blood from your hands
18:44:40 <mm_freak> c_wraith: timing out doesn't necessarily involve killing a thread
18:44:42 <dankna> unsafeKillInnocents :: RobotArm -> IO () ?
18:44:51 <c_wraith> mm_freak, ah, yes.  that's true.
18:45:59 <mm_freak> EvanR: it's the execution of the IO action, which kills people
18:46:15 <EvanR> 'pure' environments have a well defined domain of possible effects, IO has no definition, in practice you have to juggle time, hardware, concurrency processes, pointers, bullshit
18:46:31 <mm_freak> the point where you left haskell and purity and perform impure operations
18:46:38 <EvanR> thats fine
18:46:53 <megajosh2> "Haskell didn't kill your entire family, the outside world did!"
18:46:56 <mm_freak> IO itself is pure just fine
18:46:58 <EvanR> unfortunately the code looks exactly like haskell code
18:47:10 <mm_freak> l
18:47:18 <mm_freak> referential transparency is preserved by IO
18:47:34 <EvanR> but programmers sanity is not
18:47:40 <mm_freak> so?
18:47:49 <EvanR> we arent disagreeing on anything
18:48:06 <mm_freak> great =)
18:48:44 <ksf_> dankna, I asked for discrete maths because I was looking for a broader basis on CS topics, so concrete maths might actually be the exact thing I was looking, though not asking, for.
18:49:20 <mm_freak> after all referential transparency is the original motivation for monadic I/O
18:49:30 <ksf_> (I think asking for a broad theoretical basis for CS, directly, here on #haskell is foolhardy)
18:49:48 <mm_freak> or at least, doing I/O more nicely while still preserving RT
18:50:04 <EvanR> RT?
18:50:06 <aristid> mm_freak: compared to the old lists approach?
18:50:12 <aristid> EvanR: referential transparity
18:50:15 <mm_freak> aristid: yeah
18:50:27 <mm_freak> transparity?
18:50:32 <aristid> transparency
18:50:33 <aristid> typo :P
18:50:37 <dolio> Concrete Mathematics is awesome.
18:50:45 <dolio> It's fun just to read the margin notes.
18:50:46 <aristid> concrete is an awesome material
18:50:49 <mm_freak> =P
18:51:07 <aristid> steel-reinforced concrete is especially cool
18:51:20 <Axman6> aye
18:51:21 <dankna> ksf: awesome
18:51:51 <Axman6> the fact that steel and concrete have almost identicle expansion rates is very awesome
18:51:54 <mm_freak> are type families part of h2010?
18:52:04 <dankna> yes.  I still remember "Comp sci graffiti: N = 1 therefore P = NP".
18:52:13 <raichoo1> mm_freak:  Don't think so.
18:52:58 <mm_freak> too bad…  i hoped that h2010 would drastically shorten my LANGUAGE pragmas
18:53:29 <aristid> i found out today that hlint can warn me of unused pragmas
18:53:39 <raichoo1> That's actually a thing that scares me about haskell. The sheer amount of compiler extensions…
18:53:40 <Jesin> [21:51:38]	<dankna>	yes. I still remember "Comp sci graffiti: N = 1 therefore P = NP".
18:53:56 <aristid> raichoo1: why does it scare you? it's awesome
18:54:00 <Jesin> how do you know N=1
18:54:07 <dankna> you don't.  that's why it's graffiti.
18:54:17 <mm_freak> raichoo1: no, extensions are something very useful and accepted in haskell, unlike in other languages
18:54:21 <Jesin> though, I guess you could be using a language
18:54:27 <Jesin> where = means assignment
18:54:30 <Jesin> and 1 counts as true
18:54:31 <dankna> true, haha
18:54:32 <Jesin> :p
18:54:43 <Jesin> but that only works if you know ahead of time that P isn't 0
18:54:45 <mm_freak> Jesin: you're a math guy…  you just define N = 1
18:54:52 * Axman6 makes P = 0
18:54:53 <dankna> it's a short statement which appears to be profound on first glance but is actually meaningless
18:54:55 <dankna> hence it's graffiti
18:54:58 <mm_freak> Jesin: would still work
18:54:59 <aristid> how about this variant? "N=1 <=> P=NP"
18:55:06 <raichoo> mm_freak, aristid: Why so?
18:55:08 <EvanR> if P=0, P=NP for any N
18:55:10 <dankna> Twain wrote that "analyzing humor is like dissecting a frog; it's messy, and the frog tends to die in the process"
18:55:18 <aristid> raichoo: because they give you cool features
18:55:19 <mm_freak> N = 1, P = 0, therefore P = NP
18:55:20 <dankna> this is my blanket excuse for all jokes I make which are not well received!
18:55:24 <aristid> raichoo: like type families
18:55:29 <Jesin> lol
18:55:44 <Jesin> sometimes the analysis *is* the joke, though
18:55:45 <Jesin> :p
18:55:54 <dankna> there's that
18:55:57 <EvanR> youre the joke
18:56:02 <dankna> as in "All statements in G.E.B. are false."
18:56:04 <mm_freak> raichoo: haskell has always been very open for experiments and new ideas
18:56:06 <raichoo> aristid: It somehow locks you in on the compiler. You just can't switch to another implementation that does not support that extension.
18:56:13 <Jesin> ...
18:56:14 <dankna> which I already said earlier today, so nobody is obligated to laugh a second time
18:56:22 <Jesin> [21:55:35]	<dankna>	as in "All statements in G.E.B. are false."
18:56:23 <aristid> raichoo: yeah, but you don't need to use the extensions if you care about that
18:56:28 <Jesin> is that statement in the book?
18:56:30 <Jesin> it should be...
18:56:30 <mm_freak> raichoo: also extensions are fairly standard and consistently implemented among compilers
18:56:35 <dankna> I don't think so, but yes, it deserves to be
18:56:35 <EvanR> aristid: other implementations typically support all the important extensions in haskell
18:56:46 <aristid> raichoo: some extensions are supported my more than one compiler
18:57:01 <aristid> EvanR: i'm pretty sure my code only works on GHC tho :)
18:57:07 <EvanR> why youd use not GHC i dont know
18:57:10 <raichoo> Well, I guess I'm just having some prejudices here. Maybe I'll get used to them.
18:57:21 <mm_freak> raichoo: if you refer to FlexibleInstances, then it's the same extension in all compilers
18:57:34 <mm_freak> i make heavy use of extensions myself
18:57:49 <raichoo> …UndecidableInstences…
18:57:56 <raichoo> Instances even
18:58:11 <mm_freak> mostly FlexibleInstances, FlexibleContexts, OverloadedStrings and TypeFamilies
18:58:25 <mm_freak> sometimes also RankNTypes and UndecidableInstances
18:58:42 <raichoo> RankNTypes are nice.
18:58:44 <aristid> FunctionalDependencies :>
18:58:47 <dankna> I also like ScopedTypeVariables
18:59:02 <mm_freak> dankna: i found that mostly you can get along without them easily
18:59:24 <dankna> I don't use them (or any extension) by default, but I've gotten one or two cases that I felt were most naturally expressed with them
18:59:34 <dankna> though it would be interesting to try to reword them not to, if I could dig them up easily
19:00:03 <mm_freak> well, as an ugly fallback you can always use asTypeOf
19:00:07 <dankna> I recall defining a function as a large let block consisting of small functions
19:00:24 <dankna> and the compiler for some reason or other wanted type signatures on some of the small functions
19:00:32 <dankna> and the correct types could only be written with ScopedTypeVariables
19:00:37 <aristid> ok, so hlint finds SOME unused pragmas, but by no means all of them
19:00:38 <aristid> :(
19:01:00 <mm_freak> aristid: how should it anyway?  it would have to be a compiler
19:01:04 <dankna> I could dig up the actual code if I remembered what project it was in
19:01:28 <aristid> mm_freak: probably. GHC could do it
19:01:42 <c_wraith> asTypeOf and friends are fully interchangeable with ScopedTypeVariables, right?
19:01:58 <dankna> that is possible; I've never considered it
19:02:11 <mm_freak> c_wraith: i think so, unless you use quantified stuff
19:02:26 <c_wraith> well, yes, when you start to add Rank-n types, things get confusing
19:03:01 <dankna> hang on, waiting for output from $ find . -name "*.hs" | xargs grep ScopedTypeVariables
19:03:28 <c_wraith> I've never tried to sort out, mentally, how ScopedTypeVariables and RankNTypes interact.  It's probably not that interesting.
19:03:29 <mm_freak> ok, it's 4:02 am here
19:03:40 <mm_freak> g'night people =)
19:04:16 <mm_freak> c_wraith: for one thing, ScopedTypeVariables requires quantification, even though it's trivial quantification
19:04:36 <c_wraith> I thought you were going to bed. :P
19:04:46 <mm_freak> yes, but i love haskell =P
19:04:53 <c_wraith> :)
19:05:43 <dankna> http://hpaste.org/42635/uses_scopedtypevariables
19:05:45 <mm_freak> ok, gone
19:06:08 <dankna> this is just a snippet, but it should be comprehensible.  it does indeed use an existential.
19:06:16 <aristid> oh, oh, fun time: there is a follow up to the cargo cult blog: http://symbo1ics.com/blog/?p=827
19:06:58 <dankna> I missed the first one but feel that this post tells me all I need to know
19:07:01 <c_wraith> aristid, would I be happier not reading it?
19:07:14 <dankna> I find it profoundly ironic that Lisp people are telling Haskell people to avoid arrogance about the perfection of their language
19:07:15 <aristid> c_wraith: dunno, i only skimmed it
19:07:19 <dankna> speaking as a former Lisp person :)
19:07:39 <aristid> dankna: he talks about how Num a => a is "emulating" subtyping
19:07:46 <aristid> wtf :)
19:07:57 <Rabbit_> What Up
19:07:57 <c_wraith> sounds like I don't want to read it :)
19:07:59 <dankna> AHHHHHHH I could have taken that warlock had I not been doing productive things like reading that blog post instead :)
19:08:06 <j-invariant> lol
19:08:11 <EvanR> this is likely a 'one liner', how do generate n numbers and get the final generator state. something involving iterate?
19:08:25 <j-invariant> "soup of flaming"
19:08:34 <c_wraith> EvanR, that sounds like State
19:08:40 <aristid> EvanR: how about using random-fu? :)
19:08:44 <aristid> @hackage random-fu
19:08:44 <dankna> anyway c_wraith, I don't see a way to avoid ScopedTypeVariables in my example above
19:08:44 <lambdabot> http://hackage.haskell.org/package/random-fu
19:08:58 <Axman6> sequence (replicateM n random)?
19:09:13 <Saizan> EvanR: replicateM n in State StdGen or equivalent
19:09:20 <aristid> Axman6: System.Random is not monadic
19:09:34 <Axman6> sure, use MonadRandom
19:09:40 <c_wraith> dankna, I think you can.  Let me see if I can remember how it's done.
19:09:43 <dankna> hmmm okay
19:09:46 <EvanR> curiously i just dropped my monadic interface
19:09:46 <aristid> Axman6: no, use random-fu
19:09:57 <EvanR> aristid: this looks like a hardcore libraryr
19:10:10 <aristid> EvanR: and it is. but it's easy to use
19:10:23 <aristid> System.Random is simplistic and hard to use
19:10:38 <EvanR> yeah im not necessarily going to keep it
19:10:45 <EvanR> im making an interface
19:11:20 <aristid> EvanR: another thing i like about random-fu is that it supports many different generators. it supports System.Random, /dev/urandom, mwc, mersenne...
19:11:48 <EvanR> yeah im probably going to end up using my own mwc
19:11:49 <aristid> MonadRandom does not support mwc
19:11:56 <Saizan> mapAccumL could also be coerced into doing this without using the State monad explicitly :)
19:12:03 <mm_freak> > fix (\r g0 -> let (x, g1) = random g0 in x : r g1) (mkStdGen 0) :: [Int]
19:12:04 <aristid> EvanR: and why not just use random-fu?
19:12:04 <lambdabot>   [-117157315039303149,-8854136653200549331,-2598893763451025729,-21049421333...
19:12:11 <mm_freak> SCNR =P
19:12:29 <EvanR> and for now, i will figure out the answer to my question myself
19:12:37 <EvanR> unless mapAccumL will do it
19:12:56 <mm_freak> > iterate (random . snd) (mkStdGen 0) :: [Word8]
19:12:57 <lambdabot>   Couldn't match expected type `GHC.Word.Word8'
19:12:57 <lambdabot>         against inferred type...
19:13:14 <mm_freak> > iterate (random . snd) (0, mkStdGen 0) :: [Word8]
19:13:14 <lambdabot>   Couldn't match expected type `GHC.Word.Word8'
19:13:15 <lambdabot>         against inferred type...
19:13:49 <mm_freak> > iterate (random . snd) (0, mkStdGen 0) :: RandomGen g => [(Word8, g)]
19:13:50 <lambdabot>   Couldn't match expected type `g'
19:13:50 <lambdabot>         against inferred type `System.Rand...
19:13:58 <mm_freak> huh?
19:14:17 <mm_freak> > iterate (random . snd) (0, mkStdGen 0) :: [(Word8, StdGen)]
19:14:18 <lambdabot>   [(0,1 1),(173,40014 40692),(135,1601120196 1655838864),(49,1346387765 21034...
19:14:29 <mm_freak> there we go
19:14:53 <EvanR> so ignore the first one
19:15:00 <EvanR> drop 1
19:15:05 <mm_freak> btw, 'mersenne-random' is much faster than 'mwc-random', contrary to what the author claims
19:15:18 <mm_freak> EvanR: or tail =)
19:15:27 <Random75> Hey, I am following the learnyouhaskell.com tutorial, ans I was wondering, how to I get ghci to do syntax highlighting like the examples? Or are they not using ghci?
19:15:29 <EvanR> the author of what, mwc-random, or marsaglia
19:15:37 <mm_freak> EvanR: you can also split the generator
19:15:49 <Saizan> dankna: http://hpaste.org/paste/42635/uses_scopedtypevariables_anno#p42636 <- something like this by abusing the monomorphism restriction
19:15:54 <mm_freak> then you can just use 'randoms'
19:15:58 <mm_freak> EvanR: mwc-random
19:16:04 <EvanR> i highly doubt i can just use randoms
19:16:15 <EvanR> infinite lists are nice but doing work with IO
19:16:19 <EvanR> but dont work*
19:16:24 <dankna> hmmmm
19:16:32 <mm_freak> why not?
19:16:38 <flamingspinach> Random75: good question - I was wondering that myself :)
19:16:48 <EvanR> ok they work with O
19:16:53 <aristid> EvanR: you could split the generator
19:17:11 <EvanR> whatever is getting it cant treat it as a [a]
19:17:25 <dankna> Saizan: I don't get how that works.  (BTW this is an exercise, not a problem I need solved)
19:17:54 * ksf_ thinks the ghc authors should take the mersenne twister as a benchmark and have it compile as fast as the C source.
19:18:28 <ksf_> ...I know that it's a hard task because it's written in what's basically sse assembly. that's the point.
19:18:41 <EvanR> mwc would be faster if it had support for... multiply with carry
19:18:57 <c_wraith> dankna, http://hpaste.org/42637/not_scoped_type_variables
19:19:02 <ksf_> does any of the two use mersenne's array interface by now?
19:19:07 <c_wraith> I didn't actually check that, but the strategy is right.
19:19:16 <ksf_> that really matters if you need a lot of numbers.
19:19:27 <c_wraith> (I don't recognize the libraries you were using, so I couldn't import from them properly)
19:20:00 <qfr> I am having problems with whitespace management in Haskell. In Common Lisp I simply go indent-region or C-M-q  after I update the upper parts of a function but in Haskell this can hardly be done automatically so when I need to realign several lines below in a case statement it's pretty annoying :[
19:20:11 <Saizan> dankna: without MR result would have the type "forall a. Enum a => a" but the MR prevents it from being polymorphic, so given that it's used where a "content" is expected than it gets that type
19:20:13 <dankna> c_wraith: yeah don't worry about importing it, I'd have to give you the whole program it's a part of
19:20:24 <dankna> Saizan: hmm....
19:20:30 <dankna> c_wraith's is cleaner to me :)
19:20:45 <dankna> but I thank you, that makes sense now
19:20:51 <c_wraith> Yeah, that strategy works, even if it means inventing a fun new type signature for const :)
19:20:55 <dankna> haha
19:21:04 <ManateeLazyCat> From current situation, dynamic loading just good for *develop mode*, because GHC won't release memory after dynamic loading. So i want embedded user's configure file when install package to Cabal/GHC database. So have you guys know which package is good for embedded install? I found package 'file-embed'
19:21:54 <Saizan> dankna: well, mine is the same without the need for foo :)
19:22:00 <dankna> oh, haha
19:22:34 <c_wraith> Oh, yeah, it is.
19:22:36 <dankna> well, anyway, both are interesting.
19:22:42 <c_wraith> They're basically exactly the same.
19:22:55 <ManateeLazyCat> My idea is, once user use dynamic loading test finish, can re-compile all program with user's own configure file. 
19:23:07 <c_wraith> In both cases, you're using a type signature on const to explicitly unify two type variables
19:23:36 <dankna> which is an interesting thing to be able to do
19:23:36 <ManateeLazyCat> Then next time startup, don't need dynamic loading configure file for minimum memory usage.
19:24:08 <Saizan> and in both cases you're expecting the monomorphism restriction to prevent let generalization, for r/result
19:26:48 <c_wraith> And, as far as I can tell, that's why ScopedTypeVariables is never *necessary*.  But it is often the cleaner alternative.
19:30:41 <Saizan> i think it can be necessary with gadts and/or polymorphic recursion, unless you're ok with floating definitions to the toplevel of course
19:31:24 <Philippa_> not having it's plain silly, anyway. Is our type system an inference layer on top of a System F variant or not?
19:31:46 <c_wraith> I don't think it'd hurt the language if it was the default, at all. :)
19:31:53 <Philippa_> quite
19:32:42 <Saizan> if we answer yes then we need to solve the syntactical issues and allow explicit type instantiation too :)
19:38:42 <EvanR> randomR is a special case of a more general question, choose a random item in a subset of a full space of possibilities
19:38:56 <EvanR> does random-fu have nicer interface for that
19:47:27 <aristid> EvanR: yes.
19:47:33 <ddarius> http://web.mit.edu/holton/www/courses/freewill/modlog.pdf These are the notes on modal logic that I mentioned a few days ago.
19:48:10 <aristid> EvanR: http://hackage.haskell.org/packages/archive/random-fu/0.1.3/doc/html/Data-Random-Distribution-Uniform.html#v:uniform
19:48:29 <aristid> note that i'm NOT the author of random-fu, and not affiliated in any way ;)
19:50:23 <aristid> EvanR: oh, and http://hackage.haskell.org/packages/archive/random-fu/0.1.3/doc/html/Data-Random-Distribution-Categorical.html
19:52:54 <EvanR> aristid: ok
19:53:04 <EvanR> looks good
19:53:19 <EvanR> high performance would be nice
19:53:35 <EvanR> you can never generate random items too fast
20:05:11 <zingoba> Has anyone shifted  from using C++ to using Haskell?
20:05:20 <ddarius> Plenty of people have.
20:05:24 <raichoo> Me, kinda.
20:05:33 <raichoo> Well at least I'm away from C++ ^^
20:05:41 <zingoba> Is it fun?
20:05:46 <ddarius> Probably.
20:05:48 <raichoo> It enlightening.
20:06:04 <raichoo> And a lot of fun if you enjoy abstractions ;)
20:06:25 <raichoo> But I had a really down-to-earth-experience.
20:06:28 <zingoba> I know what you mean
20:06:40 <raichoo> You might feel pretty "stupid" when starting out
20:06:43 <zingoba> I'm totally new to this language
20:07:13 <zingoba> yeah this tryhaskell tut is kinda funny
20:07:43 <raichoo> I could not do the simplest things and a normally grasp new languages pretty quick. Haskell really reshaped my thinking.
20:08:09 <raichoo> Made me look at things from a different perspective.
20:08:17 <zingoba> yeah? How do we read input from console in haskell?
20:08:39 <zingoba> So everyone in here is for the haskell?
20:08:50 <raichoo> getLine
20:08:51 <c_wraith> Eh.  That's not so hard.  May not work within the context of tryhaskell, though.  being a web site, and all
20:09:22 <espringe> zingoba: http://haskell.org/haskellwiki/Introduction_to_Haskell_IO/Actions
20:09:43 <espringe> But you might be better off with just learning the basic language first
20:09:54 <espringe> I found the "learn you a haskell" to be really good
20:10:25 <zingoba> thanks
20:10:30 <raichoo> Monads might take a while to grasp, but once you did you will kind of recognize them in a lot of places you already used them without knowing ^^
20:10:55 <raichoo> And then you will think "What's the fuzz all about, that's simple" :)
20:11:52 <zingoba> Whats a Monad?
20:11:58 <zingoba> Nomad?
20:12:28 <espringe> just a fancy word
20:12:40 <espringe> You'll be best to start at the start of a haskell tutorial
20:12:40 <raichoo> zingoba: http://vimeo.com/8729673
20:12:42 <espringe> and build up :D
20:12:49 <zingoba> for what? what does it signify?
20:13:09 <espringe> input and output
20:13:10 <zingoba> yeah you're right
20:13:11 <raichoo> It's basically an abstraction for things you use everyday.
20:13:19 <zingoba> thanks for your time though :)
20:13:35 <raichoo> Lists, Side effects, chaining functions etc
20:13:56 <raichoo> IO, which is a sideeffect ^^
20:14:05 <zingoba> that sounds interesting enough to get me started
20:14:44 <raichoo> :)
20:14:51 <fmapE> that's me as of about a month ago
20:15:00 <fmapE> oops
20:15:05 <fmapE> stupid scrollbar
20:15:19 <JoeyA> Monad is a type class in Haskell: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:Monad
20:16:15 <JoeyA> Type classes are Haskell's function overloading mechanism.
20:17:01 <JoeyA> When you use >>= with IO, it takes one action and binds it to a function returning an action.
20:17:07 <JoeyA> e.g. getLine >>= putStrLn
20:17:29 <raichoo> The weirdest effect monads had on me that whenever I see sequential programs in an imperative language I think "Hey that's  a monad" ^^
20:17:50 <JoeyA> return is just a dummy action that doesn't do anything, but yields a result.
20:18:14 <JoeyA> >>= and return are overloaded to work on lists and such, which lets you do funky stuff like this:
20:18:22 <JoeyA> > sequence [[0,1],[0,1],[0,1]]
20:18:23 <lambdabot>   [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]
20:18:24 <zingoba> <raichoo> could you give an example of that ?
20:19:18 <raichoo> zingoba: putStrLn "foo" >> putStrLn "bar"
20:20:02 <raichoo> That's basically a sequential programm. just issuing 2 prints to stdout in a row.
20:20:04 <zingoba> what does this statement do? concatenate foo and bar?
20:20:21 <raichoo> nope it prints out foo and then bar
20:20:32 <zingoba> oh right thats not concatenation
20:20:33 <raichoo> Think of the >> a some kind of programmable semicolon.
20:21:17 <zingoba> >> is monad?
20:21:23 <JoeyA> >>= is monad.
20:21:34 <raichoo> It's a function defined in the monad typeclass
20:21:36 <raichoo> >>= is bind
20:21:37 <zingoba> whats >> called?
20:21:37 <JoeyA> >> is like >>=, but throws away the result of the left action.
20:22:03 <tswett> :t average
20:22:04 <lambdabot> Not in scope: `average'
20:22:08 <tswett> Hrm.
20:22:41 <JoeyA> (solvePVsNP) >> putStrLn "Muahahaha!  Nobody will ever know."
20:22:50 <zingoba> what if I did putStrLn  foo >> = x?
20:22:59 <tswett> > (\x -> sum x / length x) [4,3,4,3,4,4,3,2,4,3,3,5,3,2,4,3,4,4,3,3,4,3]
20:23:00 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
20:23:01 <lambdabot>    arising from a use o...
20:23:12 <Gracenotes> x would have to be a function taking a () argument
20:23:15 <JoeyA> >> = is parsed as 2 tokens, not 1
20:23:17 <tswett> > (\x -> sum x / length x) ([4,3,4,3,4,4,3,2,4,3,3,5,3,2,4,3,4,4,3,3,4,3] :: [Double])
20:23:18 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
20:23:18 <lambdabot>         against inferred type ...
20:23:23 <tswett> Oh, whatever.
20:23:30 <JoeyA> map
20:23:32 <tswett> I need genericLength or whatever it's called, don't I.
20:23:37 <raichoo> > putStrLn  foo >>= x
20:23:39 <lambdabot>   Not in scope: `foo'
20:23:39 <JoeyA> nvm
20:23:44 <Gracenotes> or fromIntegral
20:23:44 <raichoo> whoops
20:23:48 <raichoo> putStrLn  "foo" >> = x
20:23:59 <raichoo> > putStrLn  "foo" >>= x
20:24:00 <lambdabot>   Couldn't match expected type `() -> GHC.Types.IO b'
20:24:00 <lambdabot>         against inferre...
20:24:16 <Gracenotes> JoeyA: of course, solvePVsNP might have an effect that reveals its result
20:24:18 <raichoo> x must return something that is "inside the monad"
20:24:22 <zingoba> > 'a':[]
20:24:23 <parcs> are nullary definitions always memoized? i.e foo :: Int; foo = expensive_operation 42
20:24:23 <lambdabot>   "a"
20:24:53 <zingoba> Is this window an interpreter too?
20:24:53 <parcs> (i'm not sure nullary is the correct term, but i hope you understand my question)
20:25:16 <Gracenotes> parcs: in a strict language, it would be set to its value before continuing on
20:25:35 <raichoo> zingoba: Yes, you can play around a little. But afaik there is a haskell interpreter on the website.
20:25:38 <JoeyA> Gracenotes: Not if the computation is kept in-memory.  Well, unless ninjas dropped through your windows, stole your computer, and did a core dump, which is fairly likely given the circumstances.
20:25:44 <raichoo> zingoba: http://ertes.de/articles/monads.html
20:25:50 <Jesin> http://tryhaskell.org/
20:26:01 <Gracenotes> JoeyA: it's in IO.. so it modifies an MVar Bool :)
20:26:02 <raichoo> Jesin was faster ^^
20:26:04 <Gracenotes> let's say
20:26:06 <Jesin> is the only online interpreter I've found
20:26:10 <JoeyA> You can also /m lambdabot > 2+2
20:26:45 <JoeyA> Gracenotes: No, it just yields a Bool, I guess
20:26:54 <Jesin> hmm
20:26:56 <Jesin> "The ⊥ value is a theoretical construct."
20:26:58 <Gracenotes> parcs: in haskell it might be a bit of time before foo refers to a value. The code which calculates foo is replaced with the value of foo. This happens when the expression corresponds to a single value.
20:27:02 <Jesin> it's also available as "undefined"
20:27:27 <espringe> What's a nice way to write this? http://pastebin.com/RwBNPGnu
20:27:35 <espringe> i.e. insert a list of stuff into another list
20:27:36 <JoeyA> > solvePVsNP
20:27:37 <lambdabot>   No instance for (GHC.Show.Show (m GHC.Bool.Bool))
20:27:37 <lambdabot>    arising from a use of ...
20:27:41 <Gracenotes> so when you need the value of foo, one of two things can happen: 1. code is called which tells foo to evaluate itself to a value and return that value 2. code is called which returns the value of foo. 1 before 2.
20:28:10 <parcs> Gracenotes: thanks
20:28:13 <espringe> Is there any way to do that with function composition? Like applying the "insert" function for each element in the list?
20:29:19 <Gracenotes> parcs: memoized might not be the most straightforward way of putting it, since this is kind of par for course for strict languages. Haskell has a bit of indirection (laziness), which can nonetheless be helpful. But.. to answer your question, if it's a simple value like a data structure or a number, it'll be evaluated as far as you need it. If it's a polymorphic value (having more than one...
20:29:20 <Gracenotes> ...type), then it'll have more than one value, so it can't be "memoized"
20:29:56 <parcs> espringe: foldr insert, i think
20:30:01 <Gracenotes> not having more than one type at the same time, mind you, but say, the type Num a => a -- that type signature says you can get an Int if you want, you can get a Float if you want
20:30:42 <parcs> interesting
20:30:55 <Gracenotes> this is partly where the monomorphism restriction gets involved, which is of some importance in Haskell performance
20:31:00 <espringe> parcs: nice, thanks -- seems to work
20:32:35 <Gracenotes> http://www.haskell.org/haskellwiki/Monomorphism_restriction
20:33:03 <ddarius> Gracenotes: I would say the monomorphism restriction was added due to performance reasons, but hasn't actually served that purpose well and isn't that "important" for performance (though understanding the motivation can be.)
20:33:57 <Gracenotes> I think one of the original motivating examples was with Num, right
20:34:13 <Gracenotes> but most of the time I just want pretty pointfree top-level declarations
20:39:40 <ManateeLazyCat> Any library can scan *.hs file and give me a list of function/variable?
20:39:51 <ddarius> The thing is, if you're after performance you'll probably give monomorphic type signatures anyway.
20:40:07 <elliott_> ManateeLazyCat: there's probably a ctags plugin for that?
20:40:18 <elliott_> ManateeLazyCat: exuberant ctags
20:40:24 <ddarius> ManateeLazyCat: You could definitely do that with the Language.Haskell parser.
20:40:29 <elliott_> ddarius: aha
20:40:29 <elliott_> erm
20:40:30 <elliott_> ManateeLazyCat: aha
20:40:36 <elliott_> [edit] Hasktags
20:40:36 <elliott_> Hasktags creates ctags compatible tag files for Haskell source files.[2] It includes support for creating Emacs etags files.[3]
20:40:38 <elliott_> link is broken though :-)
20:40:56 <elliott_> ah it's in ghc documentation
20:41:03 <ManateeLazyCat> elliott_: I scan *.hs for generate new haskell file, not for IDE.
20:41:09 <zingoba_> you people are really fast with your replies
20:41:20 <elliott_> ManateeLazyCat: It would give you such a list though.
20:41:30 <elliott_> ManateeLazyCat: http://hackage.haskell.org/package/hasktags
20:41:34 <ManateeLazyCat> elliott_: I need scan user's configure file to mix with application's default option.
20:42:02 <ManateeLazyCat> elliott_: No, i'm don't need tags
20:42:09 <elliott_> ok :)
20:42:25 <ManateeLazyCat> ddarius: yep, I wonder have some library have do my need?
20:47:35 <zingoba_> Is haskell faster than python?
20:47:45 <ddarius> Significantly.
20:48:01 <zingoba_> they're both interpreted right?
20:48:13 <ddarius> No.
20:48:13 <raichoo> Haskell is compiled
20:48:16 <ManateeLazyCat> zingoba_: No
20:48:23 <raichoo> You can use it as a script though
20:48:26 <ManateeLazyCat> zingoba_: Haskell faster than java.
20:48:26 <j-invariant> zingoba_: there are python compilers as well as python interpreters
20:49:01 <zingoba_> faster than c++?
20:49:17 <espringe> nothing's faster than c++ ;D
20:49:43 <ivanm> ManateeLazyCat: I get errors with the Gtk2hsSetup.hs files when trying to build the latest versions of glib and cairo
20:49:58 <elliott_> j-invariant: python compilation is really hard though
20:50:02 <elliott_> j-invariant: since it's /really really/ dynamic
20:50:04 <ManateeLazyCat> ivanm: Paste error?
20:50:04 <ddarius> zingoba_: It depends on who's writing the code (and that's true for all of these.)  But typically well-written C++ will beat well-written Haskell code in performance (unless you start heading out into parallelism/concurrency.)
20:50:09 <allbery_b> C is faster than C++.  Assembly language is faster than C++.
20:50:33 <ddarius> allbery_b: Actually, there are things that make C++ able to be faster than C and even faster than sane assembly.
20:50:38 <ManateeLazyCat> zingoba_: Well, haskell is faster enough, most depend on your algorithm.
20:50:56 <roconnor> machine code is faster than assembly
20:51:12 <ivanm> ManateeLazyCat: http://hpaste.org/42638/error_building_glib012
20:51:15 <zingoba_> that's correct, but Why should I  learn haskell? Do I need to?
20:51:16 <allbery_b> and, more to the point, already with ghc there are cases where natural Haskell code compiles to a form faster than natural C++ code.  (where by natural I mean not specifically hacked to produce especially good output from the compiler)
20:51:16 <ddarius> roconnor: Indeed, those stupid assemblers not choosing the right representation for jmps.
20:51:17 <ivanm> @where shootout
20:51:17 <lambdabot> http://shootout.alioth.debian.org/
20:51:18 <ManateeLazyCat> REading.
20:51:20 <ivanm> zingoba_: ^^
20:51:26 <allbery_b> nit enough such cases as yet, but they do happen
20:51:36 <ddarius> zingoba_: No, you don't need to.  If you aren't interested in learning Haskell, feel free not to learn it.
20:51:38 <ivanm> language speed comparisons more depend on how much time you've wasted optimising that particular implementation though
20:51:40 <allbery_b> in particular, stream fusion can do some amazing things
20:51:56 <espringe> Yeah, c++ is faster than c. As you can just use the only the fastest features (c) and use C++ features where it's faster (like template to make specialised types)
20:51:59 <raichoo> zingoba_: I thought you came here because you were interested ;)
20:52:11 <espringe> But i think typical C++ style (high abstractions) is slower than typical C style
20:52:12 <zingoba_> I am interested
20:52:16 <raichoo> No one is going to tell you what you have to learn. It's up to you.
20:52:32 <qfr> espringe: lol.
20:52:51 <allbery_b> espringe: exactly.  I'm not talking about pre-optiomized codem I'm talking about *idiomatic* code
20:53:10 <parcs> what is the difference between import qualified ... as ... and import ... as ...?
20:53:20 <allbery_b> in the lattee case both forms are available
20:53:30 <qfr> espringe: Actually I don't get the abstractions one, what I do in C++ would usually be the same in C, just not as long
20:53:33 <parcs> ah, okay
20:53:34 <allbery_b> in the former you can only use the qualified name
20:53:35 <qfr> source code wise
20:53:46 <ManateeLazyCat> ivanm: Strange, i have patch with gtk2hs to support ghc-7 and cabal-1.10.0
20:53:57 <espringe> But it also depends on what you're doing. Take something like glib (written in c) where they emulate classes in an extremely slow manner and use strings for everything
20:54:04 <ivanm> ManateeLazyCat: this is with 6.12.3 and cabal-1.10
20:54:09 <ManateeLazyCat> ivanm: If your use cabal-1.10.0, Gtk2HsSetup.hs should select line at 199 and not 201
20:54:12 <espringe> compared to c++ where you can do it all a hundred times the speed
20:55:13 <raichoo> Speed isn't everything. C++ might be fast but it's hard to write real robust code in it. Especially when it comes to concurrency.
20:55:38 <qfr> raichoo: Yeah, it's easy to make mistakes and it can have terrible consequences
20:55:39 <raichoo> s/real/really/
20:55:42 <espringe> And then on the opposite end of the spectrum you have IO, where C++ libraries (including the standard one) are slow, giant and bloated compared to C :D
20:56:06 <zingoba_> We rarely are gonna  need concurrency 8 |
20:56:09 <raichoo> concurrency bug are extremely hard to debug.
20:56:36 <qfr> I've had some terrible bugs in C++ code I never managed to solve
20:56:41 <ManateeL`> ivanm: Can you try again?
20:56:43 <qfr> Especially with threads, yeah
20:56:54 <ivanm> ManateeL`: already tried a couple of times
20:57:00 <qfr> In C it would have been even worse, it's even easier to make mistakes there
20:57:04 <ivanm> I'm going to try doing it with cabal-install rather than the ebuild now though
20:57:11 <raichoo> zingoba_: You will at some point CPUs are not getting faster. But you will get more of them for the buck.
20:57:30 <qfr> As for IO, C++ standard library streams are pretty bad there, although ultimately all that stuff is bottlenecked by the medium used
20:57:40 <qfr> I love boost::asio for serious networking stuff though
20:57:53 <raichoo> At some point you will have to split up you program so you can harvest the power of the hardware.
20:58:01 <espringe> Agreed, boost.asio is great
20:58:03 <qfr> Good IOCP/epoll/kqueue wrapper
20:58:07 <ManateeL`> ivanm: Can you try "cabal install -DCABAL_VERSION_MINOR=1.10.0" ?
20:58:19 <raichoo> dang. My typing gets horrible. Think i might need some sleep.
20:58:45 <zingoba_> I need some sleep too
20:59:02 <zingoba_> thank you again everyone
20:59:49 <roconnor> my paste to expire in a hour didn't expire
21:01:01 <qfr> I'd use C for embedded systems and writing operating systems/drivers
21:01:01 <j-invariant> maybe cache?
21:01:23 <qfr> for userland stuff I don't see a point in using C over C++ since they're equally widely supported there really
21:01:40 <qfr> But most of my userland stuff doesn't require any low level interaction so I'd rather use Ruby, CL or Haskell
21:03:12 <espringe> If it's a library type thing (or could be in the future) it's often worth while to write it in c
21:03:28 <espringe> It's a lot easier to write bindings for c than c++
21:04:04 <ManateeL`> ivanm: I just wonder why your system can't detect those automatically, but if all solution can't work, you can remove 198~202 lines with 199 line, force Gtk2HsSetup.hs use Cabal-1.10.0 APIs, of course, this is hacking way. :)
21:04:18 <ManateeL`> s/remove/replace
21:04:56 <qfr> espringe oh yeah, libraries can be problematic in that regard, good point, since most people expect to be able to use it in C
21:05:15 <ManateeL`> ivanm: Please let me know if still have problem then. :)
21:05:16 <qfr> You can always write a C interface of course but it can be troublesome
21:06:09 <ManateeL`> C++ make simple thing become complicated.
21:07:22 <espringe> I guess it's what you're used to. I find simple things in haskell complicated and (reasonably) complex things in c++ simple
21:07:38 <espringe> (but i work as a c++ programmer)
21:08:18 <allbery_b> haskell pretty much requires you to think more as a mathematician.  once you figure out how to shift your POV that way, it becomes fairly obvious
21:08:35 <j-invariant> what does a mathematician think like?
21:09:20 <allbery_b> you don't think in terms of steps, but in terms of equations which transform one set (in the math sense, meaning oin our case data structures) into another
21:09:40 <j-invariant> oh like learning recursion
21:09:49 <j-invariant> but "more"
21:09:53 <allbery_b> so for example you don't generally use loops, but equations that operate over an entire collection
21:11:07 <ivanm> ManateeL`: OK, it works with cabal-install... weird :s
21:11:34 <ManateeL`> ivanm: Just cabal-install can work? ;p
21:11:56 <allbery_b> so a program is not a series of steps but a system of mutual equations that transform an input to an output
21:11:57 <ivanm> well, "cabal install glib" works
21:12:05 <ivanm> for some reason using the package manager doesn't
21:13:00 <ManateeL`> ivanm: Maybe package in gentoo too older?
21:13:12 <ivanm> it's 0.12
21:13:20 <ivanm> kolmodin says it works with ghc 7 :/
21:13:43 <ManateeL`> ivanm: yes, i patch it before release 0.12.0 release.
21:14:07 <ManateeL`> ivanm: Maybe gentoo administrator change package's content?
21:14:07 <ddarius> allbery_b: I don't think many mathematicians would describe equations as describing transformations at all.
21:14:34 <allbery_b> no, I'm being sloppy.  but if I'm stricter about it then I get myself into trouble fairly quickly
21:15:07 <ivanm> ManateeL`: I think I know why: it uses cabal-1.10 to build Setup.hs and run it, but you use CPP to set it to 1.8 with 6.12
21:15:29 <allbery_b> (seeing as how I'm not well grounded in any of the math, not even the basic ZF set theory)
21:17:44 <ManateeL`> ivanm: Your GHC is 7.0, right?
21:18:02 <ivanm> no, 6.12.3
21:18:02 <ManateeL`> ivanm: If ghc is 7.0 or above, it will use cabal-1.10
21:18:09 <ManateeL`> ivanm: Ah
21:18:22 <ManateeL`> ivanm: cabal-1.10.0 can work in ghc-6.12.x?
21:19:19 <ivanm> yes
21:19:37 <ivanm> Cabal-1.10 works back to GHC 6.4 IIRC
21:19:55 <ManateeL`> ivanm: We don't know how to get the cabal version like __GLASGOW_HASKELL__ to get ghc version.
21:20:30 <ManateeL`> ivanm: So Setup.hs is guessing the version of Cabal.
21:21:42 <ManateeL`> ivanm: I think "cabal install -DCABAL_VERSION_MINOR=10" force Gtk2HsSetup.hs use 1.10.0 
21:22:02 <ivanm> *nod*
21:23:04 <ManateeL`> ivanm: Ok, i need to works next version Manatee. :)
21:23:21 <ivanm> good-o
21:23:55 <ManateeL`> ivanm: My dynamic loading code works well, exception use too much memory once it linked in memory and ghc won't release.
21:24:07 <ManateeL`> ivanm: So i use it as *develop mode" like elisp for Emacs.
21:24:46 <ManateeL`> ivanm: Once developer finish test, can re-compile last configure file to build it's own version and minimum memory usage. 
21:24:47 * hackagebot yst 0.2.4 - Builds a static website from templates and data in YAML or  CSV files.  http://hackage.haskell.org/package/yst-0.2.4 (JohnMacFarlane)
21:25:01 <ivanm> cool
21:25:44 <ManateeL`> ivanm: In develop mode, i can modified software in runtime and won't lost state, most important, it's type safe. :)
21:27:39 <ManateeL`> ivanm: see you.  :)
21:39:37 <ddarius> @tell ezyang http://web.mit.edu/holton/www/courses/freewill/modlog.pdf
21:39:37 <lambdabot> Consider it noted.
21:42:40 <ManateeLazyCat> ivanm: Do you know any library scan *.hs file and output declaration list? I know i can use Language.Haskell.Parser, but i'm lazy.
21:43:49 * ddarius wonders how many times he'll slip and bust his ass running in the snow.
21:47:38 <ManateeLazyCat> juhp: Hi. :)
21:47:47 <juhp> ManateeLazyCat: hi!
21:48:13 * ManateeLazyCat pasted "Dynload.hs" at http://paste2.org/get/1167578
21:48:13 <ManateeLazyCat> juhp: Look above. 
21:48:24 <juhp> oh
21:48:27 <ManateeLazyCat> juhp: Scriptable manatee in developing
21:48:48 <ManateeLazyCat> juhp: I have test, we can modified Manatee in runtime like elisp for Emacs, but much faster and safer.
21:48:51 <juhp> cool
21:49:01 <ManateeLazyCat> juhp: Runtime modified software. :)
21:50:05 <ManateeLazyCat> juhp: Because GHC can't release dynamic linked memory, so we use this feature for Manatee developer, after developer test finish, we can re-compile application with user's configure file for minimum usage.
21:50:35 <ManateeLazyCat> juhp: Now, i'm working on re-compile user's configure in new version.
21:50:43 <ManateeLazyCat> juhp: After that, i will release new version Manatee. :)
21:50:53 <ManateeLazyCat> juhp: Of course, you can customize Manatee then. :)
21:50:56 <juhp> awesome
21:51:22 <ManateeLazyCat> Next step, i will focus all my time on IDE. :)
21:51:23 <ManateeLazyCat>  
21:51:59 <juhp> aha
21:52:24 <ManateeLazyCat> juhp: If you have time, we can discuss how to design IDE UI.
21:52:35 <ManateeLazyCat> juhp: Many works need finish on IDE.
21:52:41 <ManateeLazyCat> s/works/task
21:53:20 <juhp> ManateeLazyCat: have you tried eclipseFP?
21:53:34 <ManateeLazyCat> juhp: No.
21:53:43 <ManateeLazyCat> juhp: But i have many awesome idea.
21:54:02 <ManateeLazyCat> juhp: My plan is provide "Code completion" popup window like Eclipse, but UI like Emacs.
21:54:12 <ManateeLazyCat> juhp: Clean UI.
21:54:26 <ivanm> ManateeLazyCat: as in what it exports?
21:55:28 <ManateeLazyCat> ivanm: Oh, maybe i can expoert it, then i don't need scan all *.hs file, just need scan export list.
21:55:47 <ManateeLazyCat> ivanm: Thanks for notice, scan export is better idea, and much simple. :)
21:55:48 <ivanm> well, you can do something like that with haskell-src-exts
21:56:00 <ivanm> the trick is what to do when there's no explicit export list...
21:56:19 <ivanm> maybe see if you can hijack ghci's :browse functionality?
21:56:36 <ManateeLazyCat> ivanm: I need scan *.hs file then generate new module, that application can mix *default* configure and *user* configure.
21:57:16 <ManateeLazyCat> ivanm: If no explicit export list, then scan all code.
21:57:51 <ManateeLazyCat> ivanm: I just need search some declaration name the application care then hide default option that provide by application.
21:58:58 <juhp> completion is cool, but I would also like to do code browsing: like jumping to functions
21:59:22 <ManateeLazyCat> ivanm: Something like this, User.hs Default.hs have same function/variable name, if i scan duplicate name in User.hs, i will generate new module to hide Default.hs declaration, then i can mix *user* and *default* customize option when do "cabal install"
22:00:01 <ManateeLazyCat> juhp: Yes, that's need write backend to parse soure code.
22:01:11 <ManateeLazyCat> My idea about Manatee, developer use fix-and-continue features develop new feature in runtime, then user just need re-install application after configure file fixed.
22:01:22 <juhp> aha
22:01:26 <ManateeLazyCat> Then develop speed is fast and *stable*
22:01:39 <ManateeLazyCat> juhp: What do you think?
22:02:54 <ManateeLazyCat> juhp: My previous solution is always *dynamic loading* user's configure file, but i found GHC can't release memory to OS even you won't access old address, so *dynamic loading* at startup time waste user's memory
22:03:12 <juhp> yeah sounds good I guess
22:03:24 <juhp> ManateeLazyCat: though maybe one could just restart?
22:03:56 <ManateeLazyCat> juhp: yes, restart will lost state.
22:04:15 <juhp> true, sure
22:04:29 <ManateeLazyCat> juhp: My dynload.hs allowed you modified code in runtime and won't lost state, but you need pay for memory.
22:05:07 <juhp> ManateeLazyCat: I mean restarting would recover memory at least :)
22:05:31 <ManateeLazyCat> juhp: If GHC future version fixed memory problem, we can use dynload.hs everywhere. :)
22:05:36 <ManateeLazyCat> juhp: Yes, i know you mean. :)
22:06:05 <juhp> anyway just a comment :)
22:06:13 <ManateeLazyCat> juhp: After my test, memory increase is not always, it has a maximum value.
22:06:22 <juhp> aha
22:06:23 <ManateeLazyCat> juhp: Yes, i will add "reload tab" in the future.
22:07:01 <ManateeLazyCat> juhp: Example, irc client use 8MB, after one time dynamic loading, it's increase to 25MB, until 77MB, won't increase.
22:07:19 <juhp> hm I see
22:08:02 <ivanm> ManateeLazyCat: you can have a look to see how I do it in SourceGraph
22:08:06 <ManateeLazyCat> juhp: I don't know the detail of GHC, but i think there have a place we need fixed in GHC to let it release memory.
22:08:26 <ivanm> but it needs some work to be able to deal with CPP, TH, etc. (I keep meaning to split it out into its own package as well..)
22:08:59 <ManateeLazyCat> ivanm: Language.Haskell.Parser is not enough for scan declaration?
22:09:17 <ivanm> ManateeLazyCat: doesn't cover extensions if you mean just haskell-src
22:09:44 <ManateeLazyCat> ivanm: Ok, i will reading your SourceGraph, thanks! :)
22:11:10 <ManateeLazyCat> juhp: Maybe show *global finder" for user is not friendly when user first time startup Manatee? 
22:11:48 <ManateeLazyCat> juhp: Please let me know if you any idea about UI design, i will find time improve it.
22:15:22 <ManateeLazyCat> Ah, Language.Haskell.Parser define in haskell-src
22:16:24 <ivanm> ManateeLazyCat: that only covers Haskell98, so no extensions
22:16:35 <ivanm> even then, haskell-src-exts is stricter than GHC
22:16:51 <ManateeLazyCat> ivanm: So you recommend me use haskell-src-exts instead haskell-src?
22:16:57 <ivanm> yes
22:17:12 <ManateeLazyCat> ivanm: Ok, i will hacking haskell-src-exts, thanks for suggestion. :)
22:17:36 * ManateeLazyCat Maybe someday, we need install all hackage package to support Manatee. :)
22:18:37 <ManateeLazyCat> Ok, thanks all for help, off to coding. :)
22:27:09 <ddarius> @tell copumpkin So I was looking at Japan in Google Maps for latitudes and noticed the place my friend had lived.  It's Maibara in Shiga prefecture.
22:27:10 <lambdabot> Consider it noted.
22:43:42 * ManateeLazyCat pasted "IrcClient.hs" at http://paste2.org/get/1167599
22:43:43 <lambdabot> ManateeLazyCat: You have 1 new message. '/msg lambdabot @messages' to read it.
22:43:43 <ManateeLazyCat> ivanm: I try haskell-src-ext, but i don't know how to get function name from source code, example i want get ["selfMsgColor", "serverMsgColor"... ] from source code (source code link at above)
22:45:36 <ManateeLazyCat> juhp: So startup buffer show some help information, like "what's it", "where to get help" ?
22:46:56 <ManateeLazyCat> juhp: Maybe some design like Google Chrome, show application you can play...
22:50:06 <minsa> test
22:52:06 <ivanm> ManateeLazyCat: did you see how I did it in sourcegraph?
22:52:24 <ManateeLazyCat> ivanm: Too much module, which one i should look?
22:52:46 <ivanm> Parsing.ParseModule or something
22:52:56 <ManateeLazyCat> ivanm: Ok, look it.
22:53:50 <juhp> ManateeLazyCat: perhaps
22:54:38 <ManateeLazyCat> juhp: No chance to use "gloal finder" once user have some application running, so "gloal finder" is useless in most time.
22:55:03 <juhp> ManateeLazyCat: any difference between global finder and local finder? :)
22:55:26 <ManateeLazyCat> juhp: No, just global finder use bigger space. :)
22:55:47 <juhp> hm
22:56:41 <ManateeLazyCat> juhp: I build "global finder" to help user type something when they first time use Manatee.
22:56:59 <ManateeLazyCat> But looks it's too complicated for most user, and more confuse.
22:57:05 <ManateeLazyCat> Isn't?
22:57:06 <juhp> yeah, but to me it is not too intuitive
22:57:10 <juhp> right
22:57:36 <ManateeLazyCat> juhp: So which way is intuitive? Can you more detail?
22:58:14 <juhp> ManateeLazyCat: also would like to be able to open file/url from shell
22:58:30 <juhp> "manatee-browser http://google.com/" say
22:59:04 <juhp> ManateeLazyCat: I think I suggested before more separation of functions but I don't have a detailed plan yet :)
22:59:16 <ManateeLazyCat> juhp: So you need command interface for every application? Then you can call it from shell?
22:59:28 <juhp> also would like to have url finder for browser say
22:59:38 <ManateeLazyCat> juhp: Yea, i have record that suggestion in my TODO list.
22:59:49 <juhp> ManateeLazyCat: well that was a just a side comment suggesting more modularity
22:59:58 <juhp> ok
23:00:21 <ManateeLazyCat> juhp: In finder, have function search your browse history.
23:00:24 <juhp> currently I don't know how to edit current url
23:00:34 <juhp> or file path
23:00:44 <juhp> I would like something like C-x C-f
23:00:53 <juhp> hmm
23:01:07 <juhp> well I guess I just find the finder too "busy" :)
23:01:50 <ManateeLazyCat> juhp: After next version, you can customize how finder search, include remove something you don't want. :)
23:02:00 <juhp> ok cool
23:02:04 <juhp> it may help
23:02:33 <ManateeLazyCat> juhp: Hacking way, uncomment manatee-anything/Main.hs
23:02:40 <juhp> :)
23:02:50 <juhp> pulling now :)
23:03:09 <ManateeLazyCat> juhp: I haven't push customize code to repository.
23:03:16 <juhp> nod
23:03:28 <ManateeLazyCat> juhp: I just push patches when i make sure it can work.
23:03:31 <ManateeLazyCat> less confuse. :)
23:03:41 <juhp> but have to downgrade ghc I guess
23:04:39 <ManateeLazyCat> juhp: I remember your bug report has fixed by GHC team, haven't time try darcs ghc.
23:04:53 <juhp> :)
23:05:21 <juhp> you reported it first :)
23:05:31 <ManateeLazyCat> juhp: Well, you find it first. :)
23:05:40 <juhp> (:
23:06:01 <ManateeLazyCat> juhp: Now, just IDE and mail-client, Org-Mode need finish. :)
23:06:46 <ManateeLazyCat> juhp: In the future, i will find time write perfect temrinal emulator or patch to VTE library, now we just use manatee-terminal, not perfect than nothing! :)
23:06:49 <juhp> ok let's seen if i can send some patches before too long...
23:07:23 <juhp> I will focus more on polishing than new features
23:07:42 <ManateeLazyCat> juhp: That's cool, any patches are welcome! :)
23:08:21 <juhp> ManateeLazyCat: I was going to say maybe better not to allow splitting vte buffer
23:08:37 <juhp> (or new buffer?)
23:09:05 <ManateeLazyCat> juhp: VTE is dirty module that break Manatee framework, include Webkit-1
23:09:11 <juhp> I think we need more attention to detail if manatee is to become useful
23:09:29 <juhp> I know
23:09:48 <ManateeLazyCat> juhp: I really don't want add VTE in Manatee, but i haven't time write temrinal emulator, IDE is highest task now.
23:10:12 <juhp> writing terminal is not trivial
23:10:12 <ManateeLazyCat> juhp: I will remove vte once i build better one.
23:10:14 <juhp> sure
23:10:29 <juhp> but in mean time better to add such workaround IMHO
23:10:42 <juhp> or bugfix really
23:10:49 <ManateeLazyCat> juhp: Do you mean "session layout" ?
23:11:08 <juhp> I mean too easy to kill vte session irc
23:11:11 <juhp> iirc
23:11:32 <ManateeLazyCat> juhp: Well, i warning you at http://hackage.haskell.org/package/manatee-terminal-0.0.6 :)
23:11:55 <juhp> :) I before workaround to warning :)
23:12:01 <juhp> before = prefer
23:12:22 <ManateeLazyCat> juhp: Ok, i will write warning information when terminal startup. :)
23:12:31 <juhp> no!
23:12:42 <ManateeLazyCat> juhp: Joking. :)
23:12:45 <juhp> hehe
23:14:31 <ManateeLazyCat> juhp: Twitter is block by GFW, i need add proxy bridge before i finish manatee-twitter, but you can add it if you want. :)
23:19:18 <Taejo> ManateeLazyCat: I saw somebody say the GFW was down for a bit yesterday, is that true?
23:19:48 <ManateeLazyCat> Taejo: I remember all sites under google.com can't access.
23:19:51 <ManateeLazyCat> yesterday
23:20:15 <Taejo> ok
23:20:24 <ManateeLazyCat> Taejo: GFW just down when it need upgrade to become stronger, damn it everyday...
23:20:36 <Taejo> :(
23:24:55 <ManateeLazyCat> ivanm: I have better idea to get export list, compile *.hs to *.hi, then parse *.hi to get export list.
23:26:22 <ManateeLazyCat> Ok, talk enough. Hope can release new version tonight. :) 
23:28:32 <flipped> it is neccessary to use parsec for parsing string to basic regex, which involves only star, sequencing and switching (a*, abc, a|b|c, plus () is needed.) or just basic string manipulation is simplest?
23:29:07 <Philippa_> use a more appropriate parsing library
23:29:37 <Philippa_> (basic string manipulation'll do, but if you need to backtrack any then you're better off using a library and parsec'd actually be a bit of a pain)
23:30:10 <flipped> data Regex a = Atom a | Seq [Regex a] | Any (Regex a) | Switch [Regex a]
23:30:34 <Philippa_> yeah, if you're about to write your own regex library, you're better off using one of the existing ones
23:30:55 <Philippa_> someone else'd be better placed to tell you what's good though - now's a bit of a slow time because all the americans are asleep and most of europe isn't really up yet
23:30:57 <flipped> more complicated cases are to be added in future plan
23:31:24 <Philippa_> you realise that plain regular expressions can still require backtracking or non-deterministic parsing, right?
23:31:47 <flipped> this is our own course project
23:32:00 <j-invariant> wait
23:32:06 <Philippa_> have you been specifically told not to use libraries for parsing?
23:32:17 <flipped> so we can not use existing regex lib
23:32:23 <j-invariant> are you implementing regex or are you parsing strings like "a+|b"
23:32:26 <Philippa_> ah, in that case you're not expected to use parsec either
23:32:37 <flipped> Philippa_: no, we can use any lib we want except regex libs
23:33:02 <flipped> j-invariant: parsing string to regex is the 1st step
23:33:05 <Philippa_> heh, whoever set that wasn't very careful then :-) I suspect your lecturer/prof would be a bit pissed off if you used a more general parsing library though?
23:33:09 <j-invariant> ah, both?
23:33:36 <flipped> j-invariant: yeah
23:33:59 <tomh1> How best do you debug in Haskell if you can't just insert print statements to check outputs of functions, etc.?
23:34:08 <j-invariant> flipped: and you're working on step 1 now?
23:34:24 <Philippa_> tomh1: test bits and pieces in ghci - feed it input, decompose things. Oh, or use a writer monad, or the ghci debugger
23:34:26 <ddarius> tomh1: Simply make your types so strict that bugs cannot occur.
23:34:26 <flipped> Philippa_: we asked and things like parsec is said to be allowed
23:34:35 <flipped> j-invariant: exactly
23:34:47 <Philippa_> flipped: fair enough. Use Parsec but think about how to spot when you need backtracking, then
23:34:53 <j-invariant> flipped: http://en.wikibooks.org/wiki/Haskell/ParseExps this tutorial will help with step 1 - maybe you can adapt the ideas for step 2
23:35:12 <reltuk> what operators does your regex matcher need to support?
23:35:17 <Philippa_> or if that's giving you a headache, implement directly. Though I'd probably use parsec for the first stage
23:35:22 <j-invariant> it uses ReadP which is similar like Parsec
23:35:45 <ddarius> Philippa_: I personally agree with that design decision of Parsec.  I think being aware of when you need backtracking and recognizing when you failed to support it is easier than the dual problem.
23:36:45 <reltuk> n/m, you already said...
23:37:08 <Philippa_> ddarius: sure, OTOH not all use cases need to bother with the dual decision. Mileage varies, both should exist
23:37:12 <flipped> Philippa_: what kind of cases require backtracing? is backtracing like try-and-error, or say DFS?
23:37:21 <Philippa_> flipped: exactly that, yes
23:37:56 <j-invariant> flipped: check out that link it explains how to parse things liek "x+y*z" .. for your one you just need to use regex ops like | instead
23:38:22 <flipped> then it seems we dont need it for simple regex involving only () * + ? [] and | ?
23:38:28 <Philippa_> this|that requires backtracking if you handle it naively, for example. Obviously you can always build a DFA if you can be bothered to do it that way, but depending on possible step 3s that might not stay the case
23:39:48 <ddarius> Down with naive grammars!
23:40:27 <reltuk> flipped: what's Any (Regex a)?  'a*'?
23:40:35 <Philippa_> heh, I'm actually really tempted to build a library that aims to handle LL(1)&visibly pushdown as the default case
23:40:42 <flipped> reltuk: yeah
23:41:14 <reltuk> flipped: and Switch [Atom 'a', Atom 'b'] is 'a|b'?
23:41:22 <flipped> reltuk: yeah
23:41:28 <Philippa_> need to think about what cases for greater lookahead/backtracking I'm actually interested in: really I'm looking for something that behaves nicely on 'haskell-like' grammars if you do operator resolution in a separate phase
23:41:55 <Philippa_> where 'nicely' should mean "figures out as much of the performance concerns as possible without you having to write a non-naive version of the grammar"
23:42:14 <Philippa_> sort of a response to GvR's LL(1)-everywhere fetish
23:45:13 <Philippa_> (IIRC the main 'interesting' case in Haskell's grammar there is the qualification/no qualification ambiguity in types)
23:56:04 <flipped> Philippa_: no such parser lib exists?
23:57:01 <j-invariant> flipped: any luck with the wikibook?
23:59:09 <flipped> j-invariant: got the idea about how to do my own job:)
23:59:45 <j-invariant> huh?
