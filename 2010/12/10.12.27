00:00:04 <Gracenotes> ..I hope less
00:00:07 <Zao> The standard is rather special, as it's constructed almost a decade after the first implementation.
00:00:30 <Zao> Gracenotes: They've changed the concept of sequence points to something somewhat more clear.
00:00:41 <systemfault> Most of C++ UBs are from C.
00:00:42 <Zao> Or unclear, depending on who you ask :D
00:01:04 <systemfault> On the other side... nobody would be using C++ if it wasn't for its compatibility with C.
00:01:16 <Zao> Ooh, coffee break \o/
00:01:21 <systemfault> Win :P
00:01:31 <Zao> I wish that foreign import "cplusplus" worked :D
00:01:48 <systemfault> I wish I could use haskell at work :P
00:02:11 <ddarius> Zao: That'll never happen.
00:09:36 <turiya> when is it safe to use unsafePerformIO?
00:09:56 <ddarius> When the action you are performing is semantically pure.
00:10:18 <ddarius> Basically you don't care if, or how often, or when the action is actually performed.
00:10:49 <turiya> ddarius: is there a simple example?
00:11:37 <c_wraith> It's possible to give simple examples.  It's not possible to give especially simple explanations *why* those examples are cases it's ok
00:11:42 <ddarius> Sure, but that's not really helpful to you.
00:11:55 <vegai> could one use it to provide a pure function that stores the answer in an external cache
00:12:04 <vegai> and gets the answer from the cache if it exists there
00:12:18 <Axman6> turiya: if you make an FFI binding to the sqrt function, it is a pure function, but the haskell compiler doesn't know that, so you can use unsafePerformIO to tell it that it is safe
00:12:37 <c_wraith> vegai, you don't need unsafePerformIO for that though.  You can do that with laziness
00:12:42 <ddarius> In that particular case you can just import it without IO and the compiler will unsafePerformIO it itself.
00:13:08 <Gracenotes> vegai: and if it can't access the cache (e.g. over a network), it recalculates the value? sounds referentially transparent.. enough..
00:13:21 <ddarius> c_wraith: No you can't, and it isn't even necessarily pure depending on the details, though it is probably good enough.
00:13:23 <c_wraith> ah, I suppose if the cache is external, that's a different matter
00:13:34 <vegai> Gracenotes: yes... seems valid to me
00:14:28 <turiya> if I use the FFI binding for a function which uses malloc and free inside, can i use unsafePerformIO?
00:15:04 <Gracenotes> don't see why not. though.. stack might be preferred for not-totally-huge data
00:15:14 <ddarius> turiya: malloc and free don't immediately rule out being pure enough.
00:15:25 <turiya> i am trying to write some image processing code where speed is important so using FFI is the only choice
00:16:28 <c_wraith> turiya, that doesn't follow automatically, unless you're making heavy use of data-parallel ops
00:16:47 <c_wraith> Which image processing easily can do, I suppose.
00:17:46 <c_wraith> turiya, it sounds like your C/asm code is going to be operating on bitmaps in place then.  Those operations *should* be in IO.
00:17:58 <turiya> so, if a function the same value for the same argument, it is semantically pure and I can use malloc and free arbitrarily?
00:18:04 <ddarius> c_wraith: It depends on the granularity.
00:19:00 <c_wraith> If you allocate memory you don't free at the end of the function or hand off to haskell's GC, you also should not be in IO.
00:19:49 <c_wraith> err, *should* be in IO
00:20:19 <c_wraith> I mean, yes, you can allocate and free in a function that's not in IO, so long as the results of said mallocs and frees are not visible outside the function.
00:21:32 <turiya> c_wraith: oh, if I return a pointer from a malloc that function is no longer semantically pure?
00:22:15 <turiya> so I cant use unsafePerformIO?
00:22:25 <ddarius> turiya: Of course not unless you are caching it somehow, it won't be the same pointer each time.
00:22:26 <c_wraith> turiya, Actually, that one is usually semantically pure.  Though working with the pointer generally isn't.
00:22:37 <c_wraith> Oh, right.
00:22:41 <ddarius> If you completely hide that pointer though, you can get away with it.
00:22:41 <c_wraith> I was thinking the bytestring case
00:22:46 <c_wraith> which does completely hide the pointer
00:23:01 <turiya> it hides it in a ForeignPtr?
00:23:21 <c_wraith> yes
00:23:50 <Gracenotes> it is easy to get the GC involved thogh
00:23:51 <turiya> oh, but one could easily extract the pointer using the internal module..
00:24:05 <c_wraith> But even more than that, it hides the Pointer unless you use unsafe functions on the bytestring themselves
00:24:12 <Gracenotes> forget the function name, but has an allocate/deallocate pair
00:26:09 <c_wraith> anyway.  malloc doesn't automatically mean it's not semantically pure.  It depends on exactly what you return
00:26:10 <turiya> one can follow the bytestring example and hide the pointer in a ForeignPtr
00:26:32 <c_wraith> Well, hide it more than that.  Wrap it in some opaque type, only useful to your library
00:26:35 <ddarius> The ForeignPtr isn't the important thing.
00:26:47 <ddarius> (You don't need a ForeignPtr at all necessarily.)
00:26:57 <c_wraith> ForeignPtr is just for telling the garbage collector about it.
00:27:10 <turiya> c_wraith: what is meant by "hiding" here?
00:27:27 <Gracenotes> don't export
00:27:43 <ddarius> turiya: ByteString is a bunch of pointer manipulation underneath, but you can't see any of that at all with the public interface.
00:27:51 <Gracenotes> and make sure to provide *all* operations needed with pure Haskell functions
00:28:01 <ddarius> (In fact all data types are a bunch of pointer manipulation underneath.)
00:28:21 <Gracenotes> (assuming you can get away with unsafePerformIO)
00:30:22 <turiya> oh, as long as I dont export unsafe symbols, it is fine..
00:31:48 <ddarius> turiya: Here's one way of explaining when unsafePerformIO is acceptable.  If you -could- implement the interface in pure Haskell, then it is fine.
00:32:05 <j-invariant> if r :: T -> T -> Bool is a relation, what do you call the relation  forall x. r (f x) (g x)  ?
00:34:08 <ddarius> As a relation on functions?
00:34:38 <j-invariant> something about fibers/?
00:34:43 <ddarius> (Though I don't think there's a name regardless.)
00:34:43 <j-invariant> yse relating f,g
00:35:09 <ddarius> There might be something in the theory of logical relations, but I don't think so.
00:38:40 <ddarius> @google "Fibrations, Logical Predicates, and Indeterminates"
00:38:41 <lambdabot> http://www.lfcs.inf.ed.ac.uk/reports/93/ECS-LFCS-93-277/
00:38:41 <lambdabot> Title: Fibrations, Logical Predicates and Indeterminates
00:39:49 <turiya> ok now, the unsafePerformIO docs say that the IO computation should be free of side effects..does malloc have a side effect?
00:40:19 <ddarius> The question is whether it has side-effects from the user's perspective.
00:41:11 <c_wraith> And allocation itself isn't automatically a side effect...  It depends on how the results are represented.
00:41:47 <ddarius> Allocation side-effectful, it's just that we usually treat malloc and memory exhaustion as non-deterministic anyway.
00:42:35 <ddarius> turiya: The only question is whether the end result is a pure function.  It doesn't matter how you implement it as long as the result is pure.
00:43:22 <turiya> ddarius: hmm..i am even more confused abt purity and side effects now..
00:43:39 <c_wraith> turiya: is (:) pure?
00:43:44 <c_wraith> It allocates!
00:43:48 <Gracenotes> haskell will probably fail if malloc fails
00:43:52 <turiya> what are side-effects from a user's perspective?
00:44:19 <c_wraith> side effects are effects which are not part of the return value of the function.
00:44:42 <systemfault> Is (+) pure?
00:44:51 <systemfault> It changes the content of my CPU registers :'(
00:44:52 <turiya> yes
00:45:37 <qfr> There's nothing pure about physical execution on a register machine, obviously
00:45:39 <c_wraith> turiya, I think ddarius's alternate explanation is the best:
00:45:50 <c_wraith> <ddarius> turiya: Here's one way of explaining when unsafePerformIO is acceptable.  If you -could- implement the interface in pure Haskell, then it is fine.
00:46:42 <turiya> c_wraith: i did not quite understand what was meant by that 
00:47:07 <Gracenotes> the metric is very dependent on the interface itself...
00:47:31 <turiya> what is pure Haskell there?
00:48:00 <c_wraith> If you could implement the function you intend to do without unsafePerformIO, perhaps in a more roundabout or slower way, and the result type wouldn't be in IO, then you *can* do it safely with unsafePerformIO.
00:49:41 <ddarius> turiya: Whatever interface you are thinking to provide, could you implement it using only (safe) Haskell (possible much less efficiently.)
00:50:17 <c_wraith> here's an example of a FFI wrapper that uses unsafePerformIO safely around a function that does a lot of allocation:  https://github.com/chowells79/nano-cryptr/blob/master/System/Gnu/CryptR.hsc
00:52:19 <c_wraith> ugh. Looking at all those useAsCString calls..  Really makes me hate C's nul-terminated strings.  >_>
00:52:53 <ddarius> Pascal-style all the way.
00:53:17 <turiya>  ddarius: i want to be able to create an array in memory from an image and do some computation on the array
00:53:19 <c_wraith> oh, ddarius, I provided https://github.com/chowells79/nano-cryptr/blob/master/System/Gnu/CryptR.hsc as an example of unsafePerformIO use when you were absent for a couple seconds. :)
00:53:27 <Gracenotes> I might be too young for those
00:53:43 <c_wraith> Gracenotes, they're just length-annotated, instead of nul-terminated
00:53:45 <Gracenotes> oh.. prefixed with length
00:54:10 * ddarius is actually more interested in figuring out where he screwed up the pattern in his knitting.
00:54:16 <ddarius> right this second
00:54:27 <c_wraith> probably about 3 rows back.
00:55:27 <ddarius> There's not even three rows.
00:55:46 <turiya> data CDOpaque, and there are no constructors..
00:56:09 <ddarius> I think I just didn't move the right number of stitches from one needle to the another.  Everything might be fine.
00:56:23 <turiya> i have seen such things before.. what is the purpose?
00:56:26 <c_wraith> turiya, that's the EmptyDataDecls extension.  I never have a value of that type, only pointers to it.
00:57:27 <turiya> such as Ptr CDOpaque?
00:58:36 <c_wraith> Yes
00:59:01 <c_wraith> Since there's never a value of that type, it doesn't need any runtime representation.  It only exists to help keep the types straight.
00:59:17 <j-invariant> ddarius: I don't get knitting, isn't it kind of repetitive?
00:59:26 <j-invariant> maybe it's relaxing
01:00:44 <ddarius> j-invariant: It is actually relaxing (unles you've just dropped a stitch.)  It also allows you to make whatever you want however you want, but it is really not cost effective at all.
01:01:14 <ddarius> Of course, when society collapses it'll be a bit more cost effective.
01:02:34 <ddarius> So it looks like I should've purled one more stitch a bit back.
01:03:11 <ddarius> j-invariant: Crochet, though, let's you do some fun math related stuff.  Knitting and crochet have quite a bit to do with differential geometry.
01:03:37 <shapr> ddarius: Got pix? I recently finished a knitting project made as a present for my gf.
01:03:38 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
01:03:50 <j-invariant> I have seen some of the hyperbolic surfaces
01:04:26 <ddarius> shapr: I haven't knitted or crocheted anything since the Jayne's Hat I was working on when I visited you.
01:04:48 <ddarius> shapr: What did you make?
01:05:45 <shapr> Just a basic cowl, it looks like a short scarf. Still, not bad for my second started project, and my first completed project.
01:05:55 <ddarius> shapr: Also I was talking to J.J. Willette and he wondered if I was the reason you were interested in crochet when you were there.
01:07:14 <shapr> ddarius: I've wanted to learn for years. Your hat was definitely part of critical mass.
01:09:03 <ddarius> shapr: I'm intending on making beanie for copumpkin.  Right now I'm making a version with some acrylic yarn I have to get the size and design down.  The yarn I'll use for the actual thing is super expensive.
01:10:22 <ddarius> Here's a (very non-trivial) project for anyone who's bored.  Make a program that can take a reasonable class of surfaces and produce knit or crochet instructions from them.
01:11:12 <shapr> Personally, I'd like to see a KnitML screensaver that can turn instructions into the finished product on-screen.
01:11:33 <ddarius> Yeah, that's another one which would be comparably difficult.
01:12:37 <shapr> What's the name of the class of 3D notations that would hold KnitML? Other members would be juggling's siteswap notation, and choreography's labonotation.
01:14:12 <ddarius> shapr: The set of surfaces that could be crocheted doesn't fit nicely into typical categories, I don't think.  For example, it would be little trouble to crochet a Klein bottle.
01:14:41 <c_wraith> You know, you might actually be able to crochet a klein bottle.
01:15:00 <c_wraith> In such a way that the intersecting surfaces pass through each other.
01:15:15 <ddarius> Indeed.  As I said, it would be no problem.
01:15:25 <c_wraith> ah, right.  I misread that.
01:15:55 <ddarius> I'd be amazed to see someone knit one in one piece though.
01:16:29 <ddarius> (It's also very difficult and limiting to knit hyperbolic disks.)
01:16:52 <yitz>  would make an interesting mitten
01:48:14 <Gracenotes> er.... http://shootout.alioth.debian.org/u32q/program.php?test=pidigits&lang=java&id=4 .. and I thought that some of the Haskell shootout code was sacrificing clarity for performance...
01:49:42 <Gracenotes> that's unbelievable :|
01:50:43 <ddarius> pidigits: How quickly can you call GMP?
01:51:13 <eric_nl_> hi
01:51:27 <eric_nl_> would someone be able to help me with higher order types?
01:51:41 <Gracenotes> still, nbody for Java is just about as fast as g++ and is just about as clear. we're unclear, but hey, heavy mutation isn't our thing...
01:52:03 <ddarius> Only if they're exactly 6,495,457,524th order.
01:52:18 <eric_nl_> sorry, only second order
01:52:56 <ddarius> Gracenotes: I highly suspect a lot of the examples can be rewritten in a much clearer style with little to no loss of performance nowadays.
01:53:56 <ddarius> In fact, several can probably be made faster and clearer.
01:55:27 <ddarius> Bandwidth is nice.
02:00:26 * ddarius sees some optimizations that could be done to the pidigits code.
02:01:01 <Axman6> such as?
02:01:09 <Gracenotes> I think I barely sped it up when I worked on it a year ago... I mostly just ended up implementing the more interesting algorithms from the paper
02:02:59 <ddarius> Axman6: Well, a trivial one is that I'm pretty sure that quotRem can be used instead of divMod.
02:04:02 <ddarius> I'm also curious if as much allocation is being gotten rid of as could be.  But I don't think i'm curious enough to bother copying it and generating the core.
02:04:47 <Gracenotes> @quote core
02:04:48 <lambdabot> qwe1234 says: being garbage collected pretty much ensures that any and all multi-core implementation will get totally ruined and become unusable.
02:05:01 <Gracenotes> lol
02:06:03 * hackagebot greg-client 1.0.1 - A scalable distributed logger with a high-precision global time axis.  http://hackage.haskell.org/package/greg-client-1.0.1 (EugeneKirpichov)
02:06:39 <mux> am I correct in thinking that once I have constructed a DFA using this code (http://hpaste.org/42583/dfa), there is no way to detect cycles?
02:06:48 <ddarius> In (%) k and j are not forced necessarily, and thus are probably being allocated into thunks.
02:08:17 <ddarius> mux: No way within the language.
02:08:25 <azaq231> eric_nl_: just ask your question
02:08:27 <ddarius> Plenty of hacks you could do though.
02:08:50 <mux> ddarius: I would hate to have to move to an ugly Int-indexed data structure or something
02:09:00 <mux> can you elaborate on those hacks?
02:09:06 <ddarius> @hackage vacuum
02:09:07 <lambdabot> http://hackage.haskell.org/package/vacuum
02:09:20 <mux> oh yeah, that would be a hack.
02:09:58 <ddarius> Adding an Int identifier is, more or less, the right thing to do.
02:10:27 <ddarius> There are other possibilities, like explicitly representing cycles.
02:10:48 <Gracenotes> making it an IntMap ...
02:10:52 <eric_nl_> I have this code http://hpaste.org/42585
02:11:03 <eric_nl_> with ghc 6.8.2, foo compiles, but bar does not
02:11:11 <mux> this recursive definition for a DFA is so small and pretty.
02:11:35 <eric_nl_> giving the error message
02:11:36 <ddarius> mux: And completely fine if all you want to do is evaluate the DFA.
02:11:38 <eric_nl_>     Couldn't match expected type `forall a. a -> a'            against inferred type `a -> a'       Expected type: Maybe (forall a1. a1 -> a1)       Inferred type: Maybe (a -> a)     In the expression: Just $ id     In the definition of `bar': bar = Just $ id 
02:12:11 <ddarius> mux: Furthermore, the only change to the type (other than the fact that, as Gracenotes suggests, you should move to an IntMap) is adding an Int field.
02:12:12 <mux> ddarius: yeah, but my intent was to add code for NFAs, and transform those to DFAs, which would require me to be able to navigate in the DFA and seeing cycles
02:12:16 <ddarius> Construction will be uglier though.
02:12:32 <mux> yes, I'd have to generate Int's out of somewhere
02:12:53 <Gracenotes> mux: I've done NFA-DFA conversion, it gets messy when you have to take intersection/union of two NFAs
02:12:57 <mux> err, I meant, navigate in the NFA
02:13:10 <mux> but I'll have to be able to do likewise in the DFA anyway
02:13:11 <Gracenotes> it's doable if you're careful. really careful.
02:14:20 <ddarius> eric_nl_: That has to do with a thing called impredicativity.  GHC, more or less, doesn't support it though a really hacky, incorrect implementation was added, I think in 6.8.
02:14:40 <Gracenotes> er, union and concatenation, I mean. intersection is harder. 
02:14:46 <eric_nl_> ddarius: so I should try ghc 7?
02:14:54 <ddarius> No, you should just not worry about it.
02:15:10 <eric_nl_> oh, I'm getting the same error in real code
02:15:12 <Nibble> @src sum
02:15:12 <lambdabot> sum = foldl (+) 0
02:15:19 <Nibble> why doesn't  that work for me :/
02:15:20 <ddarius> Yes, and the solution is not to use ($).
02:15:29 <ddarius> Just like your example demonstrates.
02:15:32 <eric_nl_> bar is what I got when I simplified my code as much as possible
02:15:37 <Nibble> oh, I forgot the zero
02:15:52 <mux> I sometimes wish I had references in haskell
02:15:55 <eric_nl_> let me try some more variations...
02:16:16 <ddarius> mux: You -could- make a mutable (or single assignment) map, but that would be even less fun.
02:16:23 <mux> ddarius: yeah
02:17:06 <eric_nl_> ddarius:  huh, weird.  So why does ($) have that effect?
02:18:52 <ddarius> eric_nl_: Impredicativity is when you try to instantiate a polymorphic type to a polymorphic type.  There isn't anything special about ($) here, it's just the usual culprit.  ($) :: forall a b. (a -> b) -> a -> b.  In your example, you want to instantiate a to forall c. c -> c.  This is not allowed for good, but surmountable, reasons.
02:21:01 <Gracenotes> mux: would you be doing powerset construction btw?
02:21:39 <eric_nl_> ddarius:  ok, thanks, I see
02:23:45 <Gracenotes> my implementation ended up being 36 lines. however, I also used the state monad, parameterized over a map and reverse map from a DFA state to set of NFA states.
02:25:22 <eric_nl_> reading about impredicativity on -cafe now...
02:25:23 <eric_nl_> good night
02:25:37 <jkff> Hi, does anyone know how soon does hackage usually build a package after upload?
02:26:13 <ddarius> jkff: As in the documentation or as in the build testing?
02:26:35 <jkff> ddarius: Hm, I thought they were done together
02:30:17 <Gracenotes> twice a day
02:30:23 <Gracenotes> iirc
02:30:35 * ddarius considers making a meatloaf even though he has no binding ingredients.
02:30:55 <Gracenotes> they are done together... a bit of a necessity with the way haddock goes
02:30:56 <kafee> let me see if I get this straight: a monad is a way to describe a effect, the runtime does that effect?
02:31:13 <ddarius> kafee: No.
02:31:14 <jkff> Gracenotes: is it like "twice a day at fixed times" or just "no more than twice a day per package"? I mean, should I be hitting F5 or should I wait several hours? :)
02:31:16 <azaq231> Is using t :: FilePath -> (String -> a) -> IO a; t filename f = do { handle <- openFile filename ReadMode; contents <- hGetContents handle; r <- return $! f contents; hClose handle; return r } a correct way to load a small file completely on application startup? IO Exceptions aside?
02:31:18 <Gracenotes> the IO monad is a bit of an odd one out
02:31:19 <kafee> I know how to use them; just don't understand how they do that
02:31:34 <ddarius> jkff: I believe it's a cron job.
02:31:36 <Gracenotes> it's usually a poor example when you're talking about monads in general
02:31:43 <Gracenotes> jkff: all of them at once.
02:32:01 <Gracenotes> some jobs are run whenever a package is submitted, though, like reupdating the main index
02:32:08 <jkff> ddarius, Gracenotes: ok, thanks for the info
02:34:05 <Jafet> @quote monads.are
02:34:06 <lambdabot> copumpkin says: monads are like monad tutorials
02:34:21 <ddarius> @quote lax.functor
02:34:21 <lambdabot> copumpkin says: a monad is just a lax functor from a terminal bicategory, duh. fuck that monoid in category of endofunctors shit
02:35:39 * ddarius thinks he did 2x2 ribbing when he should have been purling on the previous needle...
02:36:10 <Gracenotes> it is fairly true that the IO value describes the effect which the runtime executes
02:36:23 <azaq231> kafee: A Monad itself is just the typeclass Monad, the IO type uses primitive (eg, implemented in the underlying implementation) functions to actually do the work, you're just using the monad interface to "sequence" things (this interface fits to that notion)
02:36:33 <Gracenotes> and manipulation of that value can be pure
02:37:24 <Gracenotes> turns out that the most useful kind of the manipulation of it, in haskell, is via monads
02:37:25 <ddarius> (Or maybe I am supposed to be doing 2x2?  Oh well, it doesn't matter too much.
02:37:27 <ddarius> )
02:38:29 <ddarius> Moggi has a recent paper about how we should generalize from "a monoid object in the category of endofunctors" to monoid objects in any monoidal category, and that this leads to nicer ways of combining monads.
02:38:52 <ddarius> (Which, at that point, are no longer just monads, but arbitrary monoid objects.)
02:39:21 <j-invariant> I'm going to try and read it
02:40:36 <Gracenotes> this one then http://www.disi.unige.it/person/MoggiE/ftp/tcs10.pdf
02:41:05 <Gracenotes> hm.. title implies a better way to combine monads than monad transformers
02:41:12 <mux> Gracenotes: yes, that's what I intended
02:41:12 <Gracenotes> I'm all for that.
02:45:12 * ddarius has a DDR song stuck in his head for no apparent reason.
02:49:32 <pozic> Is forall a. [a->a] -> a -> a implemented somewhere?
02:50:00 <pozic> Basically foldr (.) id
02:50:18 <ddarius> mconcat for Endo is that, though foldr (.) id is pretty short and clear as well.
02:50:53 <j-invariant> what is the category Endo?
02:51:03 <j-invariant> endofunctors.
02:51:18 <Gracenotes> @instance Monoid
02:51:18 <lambdabot> Maybe you meant: instances instances-importing
02:51:25 <Gracenotes> @instances Monoid
02:51:26 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
02:51:40 <Ke> is foldr really better in your opinion than foldr (id.)
02:51:46 <Ke> gah
02:52:01 <Ke> is "foldr (.) id" really better in your opinion than "foldr (id.)"
02:52:27 <Gracenotes> is that even possible?
02:52:29 <ddarius> (id .) = id
02:52:49 <ddarius> foldr ($) is fine.
02:52:59 <Ke> oh, indeed
02:53:22 <Gracenotes> hm... I suppose so... it's not like you get more flexible types with (.)
02:53:26 <Ke> missed evaluation orded again
02:53:40 <Gracenotes> since it's homogeneously constrained within a list
02:56:13 <ClaudiusMaximus> does gtk have a nice wordwrapping text display widget wherein i can add lines and highlight them in different colours?  so far I've tried packing labels into a scrollview, with mixed success (it looks really bad when the label text is long)
02:56:59 <ddarius> @google gtksourceview
02:57:01 <lambdabot> http://gtksourceview.sourceforge.net/
02:57:01 <lambdabot> Title: GtkSourceView - About
02:58:57 <ClaudiusMaximus> the "core features" list makes it seem more like a "gtksourceedit" than a mere view (which is all i want) - but i'll have a look
03:01:45 <ddarius> ClaudiusMaximus: The GTK folk couldn't bring themselves to display source without the ability to edit it.
03:01:59 <mreh> would backing tracking with state be accomplished with StateT []? The other case would be a non-deterministic computation with some global state correct?
03:02:08 <mreh> ListT State
03:02:19 <ddarius> mreh: You have that backwards.
03:02:45 <ClaudiusMaximus> ddarius: well, it's not really source as such - it's for a REPL history/status window
03:03:45 <mreh> I want [(s -> (s, a)], which is StateT [].
03:03:47 <Gracenotes> @unmtl StateT [] s a
03:03:48 <lambdabot> [] -> s (a, [])
03:03:48 <ClaudiusMaximus> ddarius: so far with labels i have nice colours for input/output/errors - but it explodes when i try to display really long texts
03:04:11 <Gracenotes> er
03:04:14 <Gracenotes> arg.
03:04:18 <Gracenotes> @unmtl StateT s [] a
03:04:18 <lambdabot> s -> [(a, s)]
03:04:29 <mreh> oh
03:04:39 <Evet> what can haskell do other programming languages cant?
03:04:52 <mreh> make you smarter
03:05:04 <Evet> make me "look" smarter?
03:05:10 <mreh> of course :)
03:05:11 <Evet> or its a new thinking approach?
03:05:20 <Gracenotes> well, if you used [s -> (a, s)], you'd use it the same way as s -> [(a, s)].
03:05:33 <mreh> Gracenotes: qute
03:05:39 <Gracenotes> :3
03:05:44 <mreh> :D
03:05:46 <ddarius> mreh: Actually, I think you did have it write.
03:05:50 <ddarius> s/write/right.
03:05:56 <ivanm> Evet: using Haskell teaches you how to casually state things like this:
03:05:58 <ivanm> @quote Zagen
03:05:58 <lambdabot> kmc says: Zagen, you'll need a zygohistomorphic prepromorphism from the bifunctorial Kleisli category of username-password pairs to a combinatory arrow calculus of php scripts
03:06:05 <Bynbo7> Evet: haskell can't do anything that other turing complete languages can
03:06:06 <ivanm> :p
03:06:21 <mreh> we just do it better
03:06:29 <ivanm> mreh: if it's worth doing, of course
03:06:34 <Gracenotes> what Bynbo7 means is that Haskell can compute uncomputable numbers :O
03:06:37 <ivanm> we typically don't do stupid better, for example
03:06:54 <ivanm> Gracenotes: but only if other turing-complete languages can!
03:06:59 <mreh> derp
03:07:08 <Evet> its just better at algebra?
03:07:13 <mreh> ._'
03:07:46 <ivanm> Evet: using Haskell typically involves a more disciplined approach, which helps you writing your code correctly the first tiime
03:07:47 <Bynbo7> Evet: not at all, it's better at a whole bun ch of things
03:08:13 <Gracenotes> it's refreshing to have code run correctly the first time you compile it
03:08:29 <mreh> and with far less boilerplate to write
03:09:37 <Bynbo7> Evet: with haskell you can write provably correct code (so you can use it in aircraft in theory), you can write extremely fast code, you can write extremely concurrent code, and you can write extremely beautiful code
03:09:58 <ddarius> You can't write provably correct code in Haskell.
03:10:02 <j-invariant> Bynbo7: what is it about haskell that lets you do that
03:10:19 <Ke> also haskell has things like hoogle, where you can search based on type signature
03:10:28 <ivanm> j-invariant: strong static typing + being a purely functional language helps a lot
03:10:35 <Bynbo7> what ivanm said
03:10:38 <Gracenotes> if a language is suitable for use in aircraft, that would make me more cautious of it
03:10:48 <ivanm> the concurrency is more due to the libraries, and the beautifulness is due to the chosen syntax and semantics
03:10:53 <ivanm> Gracenotes: why?
03:11:02 <Bynbo7> Gracenotes: I actually really like Ada too
03:11:04 <romildo> Hi.
03:11:12 <Ke> I wouldn't use haskell really on any high reliability purpose
03:11:14 * ivanm waves idly in romildo's general direction
03:11:16 <mux> laziness also helps in beautifulness
03:11:17 <ivanm> Ke: why not?
03:11:21 <ivanm> what would you use?
03:11:23 <Gracenotes> more dangerous :) less unsafe but useful amenities. now.. Ada is a nice balance.
03:11:27 <Ke> things like stack overflow are non-trivial
03:11:30 <ivanm> mux: Haskell isn't lazy; GHC-Haskell is lazy :p
03:11:39 <mux> ivanm: fine; s/lazy/non-strict/
03:11:51 <Ke> C eg. gives you alot more control over reliability
03:11:51 <mreh> what is Cont useful for?
03:11:57 <ivanm> Ke: hmmm... so you'd want more fine-level control and thus more chances to stuff up?
03:12:00 <Bynbo7> Ke: me either, but i would use it to write code for those systems
03:12:11 <Ke> =o)
03:12:22 <ivanm> Bynbo7: as in code gen?
03:12:24 <Bynbo7> well, to produce code for
03:12:25 <Bynbo7> yah
03:12:29 <romildo> How can I get a stack trace printed out when my program (compiled with GHC) finishes with an error?
03:12:41 * ivanm has to hack on C++ over his break :s
03:12:43 <Evet> im building a web application completely based on graph data structure, shortest path algorithms, speech recognition, computer vision, etc.
03:12:45 <Bynbo7> romildo: you can;t, and stack traces are evil
03:12:48 <ivanm> romildo: ... you can't
03:12:52 <ivanm> use ghci instead!
03:12:55 * ddarius may hack on C++ for fun over the break.
03:13:01 <Bynbo7> Evet: sounds like a good use for haskell
03:13:05 <ivanm> and Debug.Trace if necessary
03:13:16 <ivanm> Evet: ooohhhh, I like graphs...
03:13:19 <ivanm> tell me more
03:13:36 <Bynbo7> we've got some very fast web frameworks, lots of graphs stuff (see ivanm, he's doing his PhD working with graphs in haskell)
03:13:36 <ivanm> ddarius: are you masochistic or something? :o
03:13:54 * ivanm has never really used/learnt C++, but just looking at some code for it scares me
03:14:01 <ivanm> Bynbo7: correction: I'm just _using_ Haskell
03:14:04 <romildo> I need to locate the position in source code where the error appeared. Currently it just shows an error message. How can I do that in ghci then?
03:14:17 <ivanm> my PhD has nothing to do with Haskell (though I may try to get a paper into the Haskell Symposium about it)
03:14:31 <ivanm> romildo: oh, from using head or something?
03:14:38 <Evet> in c, libraries make my life easier. i heard good things about haskell, but i dont know how to use it for ai
03:14:46 <ivanm> don't use partial functions, and write custom error messages
03:14:49 <romildo> ivanm, exactly.
03:15:00 <romildo> $ ghc --make -O Gui && ./Gui mycollection.txt 
03:15:01 <romildo> Gui: Prelude.head: empty list
03:15:01 <ivanm> Evet: there are a few people hacking on AI stuff in Haskell
03:15:05 <Bynbo7> don't use head
03:15:07 <Gracenotes> I've heard that fgl is a good graph library. but I don't know if there's anyone here that can confirm this. ahem.
03:15:13 <ivanm> use listToMaybe or something instead
03:15:17 <ivanm> Gracenotes: it's OK
03:15:18 <ivanm> just dated
03:15:21 <Gracenotes> :P
03:15:30 * Bynbo7 tries to avoid using head, last, and anything else in the prelude that can throw an error
03:15:31 <Gracenotes> did you end up sticking with the inductive name?
03:15:36 <ivanm> tomberek and I are working on it on and off, though some people keep bitching about it :@
03:15:36 <ddarius> Going from Haskell to C++ would not be a fun transition.
03:15:43 <ivanm> Gracenotes: we're sticking with FGL
03:15:54 <mreh> Use Either, or a generalised interface for failure, Monad.
03:15:58 <ivanm> (currently)
03:16:02 <j-invariant> Bynbo7: what about division?
03:16:16 <ivanm> but we're going to be de-emphasising FGL to be _just_ inductive graphs, and use another library to define what a graph is
03:16:25 <Bynbo7> you can wrap division to make it safe
03:16:32 <Bynbo7> also...
03:16:35 <Bynbo7> > 1/0
03:16:36 <lambdabot>   Infinity
03:16:41 <ivanm> Bynbo7: bit harder taking into account overflows/underflows, etc. though
03:16:45 <Bynbo7> > 1 `div` 0
03:16:46 <lambdabot>   *Exception: divide by zero
03:16:56 <Gracenotes> solution: use IEEE for everything
03:17:16 <Bynbo7> aye :P
03:17:17 <ddarius> ivanm: The good news is you can compile your C++ with GHC.
03:17:25 <romildo> So it is not possible to easily locate the source of the error with head? Certainly I will make the program more robust, but now I would like to easily to locate the problem in the source code.
03:17:26 <ivanm> I once used head in something I _knew_ was safe... and then down the track edited something else that made my other assumption invalid (but I had forgotten about that assumption) :s
03:17:42 <ivanm> ddarius: nope, I'll be hacking on an existing C++ project
03:17:56 <ivanm> romildo: not really unfortunately
03:18:13 <ivanm> but find all usages of head
03:18:55 <ivanm> if necessary, as a transitioning point define something like: errHead f [] = error "Empty list in " ++ f; errHead _ (x:_) = x
03:19:26 <Bynbo7> if you use CPP you can add __FILE__ to that error
03:19:27 <ivanm> Evet: anyway, some of the AI stuff in Haskell: http://hackage.haskell.org/package/#cat:ai
03:19:50 <Evet> oh HOpenCV \o/
03:19:53 <Ke> would be awesome to have haskelllike imperative language that allows C-like use
03:19:56 <Gracenotes> I prefer explicit pattern matching to unsafe functions most of the time. .. what can I say, I like case statements.
03:20:30 <Gracenotes> ML?
03:20:40 <Bynbo7> Ke: they exist, see timbre
03:20:45 <Gracenotes> well, no, ML's still mostly functional.
03:20:54 <Bynbo7> and there's another i've forgotten.
03:21:05 <Evet> which library has dijkstra, A*, etc.?
03:21:09 <romildo> Bynbo7, how is that about using CPP?
03:21:39 <Ke> Bynbo7: any compilers that I would expect to find in a modern linux distribution?
03:21:50 <ivanm> Evet: FGL has some stuff; there's a dedicated A* library but it is independent of any data structure
03:21:53 <Bynbo7> Ke: they're written in haskell, so yes
03:22:16 <Bynbo7> romildo: if you add a language pragma (CPP), the C preprocessor is run over your code first, so you can use predefined macros like __FILE__, __LINE__ etc
03:22:22 <ivanm> Graphalyze has some algorithms for FGL graphs, but I wrote them more trying to work out how to do it from scratch rather than efficiently, so your mileage may vary
03:22:25 <Ke> that doesn't sound too reassuring
03:22:55 <ivanm> Evet: and graphviz will let you visualise FGL graphs (don't use Data.Graph.Inductive.Graphviz, it's horrible)
03:23:03 <Bynbo7> Ke: they're compilers written in haskell... what's wrong with that? o.OL
03:23:04 <Bynbo7> -L
03:23:21 <romildo> Bynbo7, nice. Then I will those information (__FILE__ and __LINE__) to the error message of errHead.
03:23:36 <Gracenotes> good compilers need lots of work. .. although, hopefully there'll be more functional compilers using the llvm package.
03:23:39 <Ke> Bynbo7: compilers written in haskell are awesome, just not too available
03:23:49 <Bynbo7> eh?
03:24:46 <Ke> you can expect to find gcc anywhere but even ghc is not too common
03:24:51 <romildo> Bynbo7, but adding file and line information to the error message would not be too easy, because it will refer to the file and line of the definition of errHead, and not of its use.
03:24:52 <Bynbo7> Ke: http://hackage.haskell.org/packages/archive/pkg-list.html#cat:compiler
03:30:34 <ivanm> preflex: seen dcoutts
03:30:34 <preflex>  dcoutts was last seen on #ghc 4 days, 18 hours, 47 minutes and 52 seconds ago, saying: dons: btw, re cabal-dev, I think it makes sense to do this stuff directly in cabal-install
03:31:23 <uli> Hi everybody. What is a very fast way to write a large array (~10^5) to disk? Data.Binary?
03:31:38 <Bynbo7> sure
03:31:43 <ivanm> if you write a good instance for it, sure
03:31:56 <Bynbo7> uli: we'd need a lot more information than that
03:33:07 <ntc2> romildo: maybe Bynbo7 meant that you could define errHead as macro, so that __FILE__ and __LINE__ would be expanded wherever errHead was used?
03:33:32 <ntc2> romildo: but it looks like you can get a trace in ghci: see http://haskell.org/ghc/docs/6.12.2/html/users_guide/ghci-debugger.html#ghci-debugger-exceptions
03:33:36 <uli> I want to make a game of life simulation by using arrays and I want to write every generation of it to a file (using the .pbm) format
03:33:36 <Bynbo7> not quite
03:34:25 <Bynbo7> then i can't see what you'd be using Data.Binary for
03:35:07 <Bynbo7> you could use Data.Binary.Put to create a bytestring quite efficiently, and then write that out to disk for some extra performance
03:35:36 <uli> yeah, I'm searching for efficient ways to do that - I'm already using bytestrings
03:36:25 <cargill> hi, how do I load the Ratio module into ghci? :l Ratio says "<no location info>: module `Ratio' is a package module
03:36:32 <Bynbo7> well, if you've already got bytestrings, just use the functions in Data.ByteString
03:36:41 * lispy_ has arbitrary latex -> html, custom haskell script to touch up the html, and using doc-review so you can comment on the document real-world haskell style
03:36:47 <Gracenotes> Data.Ratio
03:36:49 <Bynbo7> cargill: :m +Ratio
03:36:58 <Bynbo7> that's :module +Ratio
03:37:33 <norm2782> I'm trying to use TH to generate some code, however it gives me the error message pasted here: http://pastie.org/private/eknalwnexdfg3gurvrcgew
03:37:34 <cargill> oh, thanks Bynbo7
03:37:35 <lispy_> The next step is to get Isabelle to generate .tex files so I can wrangle the Isabelle output into a doc-review format
03:37:36 <norm2782> the strange thing is that when I paste the generated code  in the file with the TH call (TestHS.hs) and comment the TH line, the code compiles just fine. does anyone know what I might be doing wrong here?
03:39:02 <Bynbo7> lispy_: doc-review?
03:39:10 <lispy_> Bynbo7: it's on hackage
03:39:16 <Bynbo7> ah, i see
03:39:34 <uli> Bynbo7: Thx, I have already tried that - but I have to get it faster
03:39:39 <lispy_> my utility to auto label <p> tags is not released yet
03:39:57 <Bynbo7> uli: compress the bytestrings?
03:40:15 <lispy_> I run over the document and grab everything between <p> tags, compute the sha1, then use that as the id
03:40:20 <Bynbo7> i guess a compressed .pbm file isn't much use
03:40:25 <uli> yeah ;)
03:41:03 <lispy_> only problem I've had is that <script url="..."></script> gets converted to <script url="..."/> by the xml package which is wrong :(
03:41:07 <Bynbo7> uli: have you verified that they time i spent on writing the bytestrings?
03:41:38 * ddarius doesn't know what he'd do without mayonaisse.
03:41:50 <Bynbo7> uli: laos, you could for another thread to do the writing, use a Chan (FilePath, ByteString) to send it data to write, and keep the computation going
03:41:54 <Bynbo7> also*
03:42:03 <Bynbo7> bloody hell, my typing is horrible tonight
03:42:15 <ddarius> @hackage astar
03:42:16 <lambdabot> http://hackage.haskell.org/package/astar
03:42:19 <Bynbo7> lispy_: lame :(
03:42:37 <b0fh_ua> @pl \acc x -> acc + Char.digitToInt x
03:42:37 <lambdabot> (. Char.digitToInt) . (+)
03:42:44 <lispy_> Bynbo7: yeah, it's weird.  I just stick something that is valid JS between the tags, and then it stops happening
03:43:00 <uli> Bynbo7: Yeah, that is true, but I want to do it without threads (in particular, they are forbidden, because we do a little language shootout)
03:43:00 <Bynbo7> heh, how useful
03:43:41 <ddarius> <script url="..."><![CDATA[]]></script>
03:43:52 <Bynbo7> yeah, i was about to suggest that
03:44:13 <hvr> is there a well-known symbol for an operator applying a function to to both "sides", e.g. I'm searching some name for ??? in  '(???) f = f *** f'
03:44:15 <Bynbo7> uli: hmm, care to share the code?
03:44:40 * hackagebot stepwise 1.0.2 -   http://hackage.haskell.org/package/stepwise-1.0.2 (ArieMiddelkoop)
03:44:41 <Bynbo7> @hoogle (a -> b) -> (a,a) -> (b,b)
03:44:42 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
03:44:42 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
03:44:42 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
03:45:04 <Bynbo7> hvr: could just define (???) = join (***)
03:45:19 <Gracenotes> maybe hoogle could use common-instances tips... hm
03:45:25 <Bynbo7> @djinn (a -> b) -> (a,a) -> (b,b)
03:45:26 <lambdabot> f a (b, _) = (a b, a b)
03:45:30 <uli> Bynbo7: There's not much code until now - I'm not so used to arrays; but I can show you the java version so far
03:45:42 <Bynbo7> ok
03:45:49 <Bynbo7> uli: also, what sort of arrays are you using?
03:45:56 <hvr> Bynbo7: ...so there's no arrow syntax for such an operator? :)
03:46:19 <Bynbo7> not that i know of, but i don't use arrows much
03:46:28 <uli> Bynbo7: I tried it with IOArray
03:46:47 <Bynbo7> @hoogle a b c -> a (b,b) (c,c)
03:46:48 <lambdabot> Control.Arrow (***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
03:46:48 <lambdabot> Control.Arrow second :: Arrow a => a b c -> a (d, b) (d, c)
03:46:48 <lambdabot> Control.Arrow first :: Arrow a => a b c -> a (b, d) (c, d)
03:47:15 <Bynbo7> uli: i'd try IOUArrays
03:47:40 <Bynbo7> the interface is practically the same (possibly exactly the same), and you get much faster code
03:47:41 <uli> Bynbo7: java: http://pastebin.com/sUTAHZpK
03:47:55 <uli> Ok.
03:48:04 <Bynbo7> basically, an Array isn array of pointers to the elements, a UArray is an array of the elements
03:48:42 <Bynbo7> Arrays are useful when you need to define the elements in them lazily (say later elements definition depend on earlier elements' values)
03:49:46 <uli> Bynbo7: Ok. I think the main question is, how to iterate over the array and then write it (every iteration gives a new generation). If i iterate over the array and write it immediately (appendFile) this is too slow; so I thought maybe I iterate over the array and build up the bytestring but this string does get very fat then
03:50:09 <uli> Bynbo7: In the java-version I write to a buffer (StringBuilder)
03:53:21 <rjo> I'm trying to install package SDL-image using cabal install SDL-image
03:53:28 <rjo> <command line>: cannot satisfy -package Cabal-1.8.0.2: 
03:53:28 <rjo>     Cabal-1.8.0.2-72f6eafc7def741b28f6ec75d2686d14 is unusable due to missing or recursive dependencies:
03:53:31 <rjo>       directory-1.0.1.0-10fc46e61b67ff4a83f3e553454d003c process-1.0.1.2-8b5308cb23fbdc3c2df27e298550937f
03:53:35 <rjo>     (use -v for more information)
03:54:09 <rjo> it is probably due to this does not work: main = defaultMainWithHooks autoconfUserHooks
03:54:37 <rjo> /usr/bin/ghc --make ./Setup.lhs -o ./dist/setup/setup -odir ./dist/setup -hidir ./dist/setup -i -i. -package Cabal-1.8.0.2
03:54:48 <ivanm> rjo: methinks you screwed up your system
03:55:00 <rjo> me too
03:55:25 <ivanm> rjo: does "ghc-pkg check" complain about your global package db or your local/user one?
03:56:59 <rjo> it does not say anything
03:57:12 <ivanm> :o
03:57:24 <ivanm> who wrote that /usr/bin/ghc line? you or Cabal?
03:57:25 <rjo> I've used mainly only cabal to install packages
03:57:31 <ivanm> ghc-pkg list Cabal
03:57:33 <rjo> Cabal
03:58:28 <rjo> $ ghc-pkg list Cabal
03:58:28 <rjo> /usr/lib/ghc-6.12.1/package.conf.d Cabal-1.8.0.2
03:58:28 <rjo> /home/jro/.ghc/i386-linux-6.12.1/package.conf.d
03:59:12 <ivanm> ... interesting
03:59:22 <ivanm> are you using cabal-install or "runhaskell Setup.hs" ?
03:59:34 <rjo> cabal isntall
03:59:34 <ivanm> oh, right, you said cabal-install
03:59:49 <ivanm> ghc-pkg list directory
04:00:46 <rjo> $ ghc-pkg list process
04:00:46 <rjo> /usr/lib/ghc-6.12.1/package.conf.d process-1.0.1.2
04:00:46 <rjo> /home/jro/.ghc/i386-linux-6.12.1/package.conf.d process-1.0.1.2 process-1.0.1.4
04:01:24 <rjo> directory had one version 1.0.1.0 in /usr/lib... and /home.../
04:05:17 <ivanm> I said directory, not proces... :p
04:05:59 <rjo> $ ghc-pkg list directory
04:05:59 <rjo> /usr/lib/ghc-6.12.1/package.conf.d directory-1.0.1.0
04:05:59 <rjo> /home/jro/.ghc/i386-linux-6.12.1/package.conf.d directory-1.0.1.0
04:06:52 <ivanm> rjo: get rid of process-1.0.1.4
04:10:31 <rjo> error still persists
04:11:57 <Kaidelong> is there a compact, portable bytecode for GHC/GHCi?
04:12:08 <Kaidelong> or would I have to carry around source code with me?
04:12:44 <vegai> Kaidelong: why not just carry the binaries?
04:12:54 <Kaidelong> vegai: "portable"
04:13:07 <Kaidelong> I suppose I could compile several binaries
04:14:21 <vegai> ah, right
04:16:01 * Kaidelong wonders if Hugs would be an option, he uses a lot of mutable vectors in his code and doesn't know how well Hugs supports that
04:16:27 <rjo> this issues seems to identical: http://hpaste.org/41493/cabal_issues?pid=41493&lang_41493=d
04:17:33 <ntc2> @help
04:17:33 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:17:41 <ntc2> @help list
04:17:41 <lambdabot> list [module|command]
04:17:41 <lambdabot> show all commands or command for [module]. http://code.haskell.org/lambdabot/COMMANDS
04:18:14 <Bynbo7> @list help
04:18:15 <lambdabot> help provides: help
04:18:21 <Bynbo7> hehe
04:19:11 <ntc2> that COMMANDS url is broken for me :P how to tell lambdabot to give someone a message next time they log on?
04:19:24 <ivanm> @help tell
04:19:24 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
04:19:35 <ntc2> ivanm: thx
04:19:50 <shachaf> @help ask 
04:19:50 <lambdabot> ask <nick> <message>. When <nick> shows activity, ask them <message>.
04:19:59 <ivanm> ask is an alias for tell
04:20:06 <shachaf> tell is an alias for ask
04:20:14 <ntc2> @tell romildo here's an example of debugging head exceptions in ghci: http://hpaste.org/42589/romildo_ghci_debug_example
04:20:14 <lambdabot> Consider it noted.
04:20:16 <ivanm> heh
04:20:28 <shachaf> You gave in to the dark side. :-(
04:20:52 <pozic> Where is the instance Eq b=>Eq DiffArray (Int,Int) b?
04:21:14 <ivanm> pozic: possibly derived?
04:22:18 <pozic> ivanm: the problem is that deriving (Eq) for a type which uses one, doesn't work.
04:22:46 <rjo> I tried to update cabal 1.8.0.4: undefined reference to symbol 'sem_open@@GLIBC_2.1.1'
04:22:53 <ivanm> pozic: hmmm?
04:23:04 <ivanm> rjo: have you upgraded glibc?
04:23:16 <pozic> ivanm: because that instance doesn't exist
04:23:34 <rjo> I just run yum update frequently
04:24:08 <ivanm> pozic: oh, so what makes you think it _does_ exist?
04:24:49 <rjo> I try to --reinstall unix
04:25:49 <pozic> ivanm: I don't see why it is not implemented.
04:25:59 <ntc2> pozic: maybe you are looking for instance (Ix i, Eq i, Eq e) => Eq (DiffArray i e)?
04:26:18 <pozic> ntc2: and where is that one defined?
04:26:21 <ivanm> pozic: possibly because it will be difficult due to how it is implemented?
04:26:36 <ivanm> pozic: any particular reason for using DiffArray anyway? I thought it was deprecated or something...
04:26:37 <pozic> ivanm: compare all elements index by index?
04:26:39 <ntc2> it's defined here: http://hackage.haskell.org/packages/archive/ArrayRef/0.1/doc/html/src/Data-ArrayBZ-Diff.html
04:27:00 <ntc2> and eqIArray is here: http://hackage.haskell.org/packages/archive/ArrayRef/0.1.3.1/doc/html/src/Data-ArrayBZ-Internals-IArray.html#HasBounds
04:27:07 <pozic> ntc2: thanks
04:27:23 <ntc2> (ignore the #HasBounds)
04:27:40 <pozic> ntc2: except cabal install ArrayRef doesn't work
04:28:36 <ntc2> pozic: oh, i'm just googling for definitions :P
04:29:02 <ClaudiusMaximus> gnargh, gtk textview refuses to wrap text like ") ) ) ) ) ) ) )" even though i set WrapChar :-[
04:30:02 <rjo> this command is missing -lphtread excplicitly, when running cabal configure: /usr/bin/ghc --make ./Setup.hs -o ./dist/setup/setup -odir ./dist/setup -hidir ./dist/setup -i -i.
04:30:51 <rjo> no I shoud somehow get cabal realize this
04:31:45 <ntc2> pozic: hmmm, ArrayRef fails to cabal install for me to.
04:32:00 * hackagebot attoparsec-text 0.8.0.0 - Fast combinator parsing for texts  http://hackage.haskell.org/package/attoparsec-text-0.8.0.0 (FelipeLessa)
04:33:01 * hackagebot attoparsec-text-enumerator 0.2.0.0 - Convert an attoparsec-text parser into an iteratee  http://hackage.haskell.org/package/attoparsec-text-enumerator-0.2.0.0 (FelipeLessa)
04:33:53 <Zao> Ooh, attoparsec-text.
04:34:18 <Zao> Are there any decent introductory papers/texts on Iteratees? I seem to have missed the bandwagon.
04:35:32 <Zao> Ah, http://john-millikin.com/software/enumerator/
04:35:41 <Zao> Why the "iteratee/enumerator" schizo naming?
04:37:46 <rjo> oh well, Cabal was using unix-2.4.0 and process and directory packages 2.4.1 and cabal depended on process and directory, also Cabal.cabal was missing extra-libraries: pthread
04:39:23 <Bynbo7> Zao: http://docs.yesodweb.com/blog/enumerators-tutorial-part-1/
04:39:28 <Bynbo7> that helped me the most
04:39:28 <ClaudiusMaximus> and there's a gtk bug filed 7 years ago about it :/
04:40:35 <Bynbo7> Zao: also http://themonadreader.wordpress.com/2010/05/12/issue-16/ has a very good introduction about what they are. i'd start with that actually
04:41:23 <pozic> What's bad about FlexibleInstances? It seems a perfectly obvious feature.
04:42:00 <Zao> pozic: Footshooting possibilities?
04:42:03 <Jafet> Indeed, that's why GHC has it!
04:42:40 <pozic> I never had too many instances ;)
04:44:01 <Jafet> Most of my bullet holes are from fundeps
04:45:10 <pozic> How can you also tell GHC that it should look at the instance head?
04:46:51 <pozic> Never mind. GHC already suggests it. 
04:48:39 <Bynbo7> Zao: using those links, i went from not understanding what iteratees where at all a week ago, to being able to use them, at least somewhat effectively
04:48:58 <Zao> Bynbo7: Excellent.
04:49:06 <Zao> Next up, groking uu-parsinglib.
04:50:53 <Bynbo7> heh
04:59:45 <mreh> I love it when you rewrite something and it gets considerably shorter
05:02:36 <Bynbo7> mreh: it's a good feeling
05:09:52 <mreh> @instances MonadPlus
05:09:53 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
05:10:33 <Kaidelong> I actually found a use for functions as numbers!
05:10:43 <Bynbo7> yeah?
05:10:54 <Bynbo7> as in chruch encoding?
05:11:02 <Kaidelong> milesTravelled * const 2 + busesUsed * const 100 + studentsUnserved * const 5000
05:11:09 <Kaidelong> to get a fitness function
05:11:35 <Bynbo7> eh?
05:12:10 <Bynbo7> and do you just feed in numbers into that expression?
05:12:12 <Jafet> > let f n = n*n in f+5 $ 3
05:12:13 <lambdabot>   14
05:12:19 <Kaidelong> Bynbo: bus routes
05:12:53 <hpc> Kaidelong: and the whole thing is :: Num a => Bus -> a?
05:13:00 <Kaidelong> yes!
05:13:04 <Kaidelong> that's the idea anyway
05:13:11 <Kaidelong> I'm not done with the aesthetics yet
05:13:29 <hpc> that's actually rather clever
05:13:40 <Kaidelong> could make an infix operator like *|
05:13:45 <Kaidelong> to avoid repeatedly writing const
05:13:51 <aristid> Kaidelong: you can get rid of the const, because 2, 100 and 5000 are polymorphic already
05:14:01 <Kaidelong> oh right!
05:14:11 <Kaidelong> that's also clever
05:14:15 <aristid> :t fromInteger
05:14:16 <lambdabot> forall a. (Num a) => Integer -> a
05:14:30 <aristid> :t const . fromInteger
05:14:31 <lambdabot> forall a b. (Num a) => Integer -> b -> a
05:14:50 <aristid> something like that anyways
05:16:04 <Jafet> > let f n = n*n in (f+id)/2 $ 7
05:16:06 <lambdabot>   28.0
05:16:42 <Kaidelong> what would I import to get the number instance for functions?
05:16:48 <Kaidelong> or should I just define it myself?
05:16:58 <hpc> it's not hard
05:17:30 <hpc> instance Num a => Num (b -> a) where (+) = liftM2 (+)
05:17:32 <hpc> etc
05:17:35 <Kaidelong> it's more about wanting to do what is good style than not wanting to do it
05:18:25 <Jafet> lambdabot's instance comes from vector-space
05:18:35 <mreh> this is great, I'm slashing code away with Monad transformers
05:18:39 <Jafet> Do you know what else comes from vector-space? DRAGONS
05:26:49 <Kaidelong> Jafet: much thanks
05:27:34 <Kaidelong> Long live Conal
05:27:34 <Boxo> > 2 $ 3
05:27:35 <lambdabot>   2
05:28:18 <Boxo> > 1 2 3
05:28:19 <lambdabot>   1
05:29:04 <gio123> 3 2 1
05:29:25 <Boxo> >
05:30:12 <Boxo> > fmap 1 2
05:30:13 <lambdabot>   No instance for (GHC.Show.Show (f b))
05:30:13 <lambdabot>    arising from a use of `M8422751273...
05:30:17 <Boxo> > fmap 1 2 3
05:30:18 <lambdabot>   1
05:30:36 <Boxo> > (1.2.3) undefined
05:30:38 <lambdabot>   1.2
05:30:58 <Boxo> :t (1.2.3) undefined
05:31:00 <lambdabot> forall b. (Fractional b) => b
05:31:20 <Jafet> Don't play with the dragon, dear.
05:31:25 <Boxo> :t flip 3
05:31:25 <lambdabot> forall (f :: * -> *) a b. (Num (f (a -> b)), Functor f) => a -> f b
05:31:52 <Boxo> > join 1 2 3 4
05:31:53 <lambdabot>   1
05:32:40 <Boxo> > 1 undefined 2 undefined 3 undefined 4
05:32:41 <lambdabot>   1
05:34:46 <Boxo> > foldr (.) id [0..10] $ 1
05:34:47 <lambdabot>   No instance for (GHC.Enum.Enum (b -> b))
05:34:47 <lambdabot>    arising from a use of `e_10101'...
05:36:28 <Boxo> > foldr (.) id [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] $ 1
05:36:30 <lambdabot>   0
05:37:00 <Kaidelong> chrome is warning me that Conal's website may have been compromised
05:38:37 <Kaidelong> Boxo: 0 = const 0 = const (const 0) = const (const (const ...
05:39:14 <Boxo> yep
05:40:08 <lars9> why CPS is usually not mentioned in haskell world, but often mentioned in ocaml posts?
05:41:56 <osfameron> no idea.  but language communities often have preferred idioms, which are sometimes to do with the languages' support for them, sometimes to do with lack of support for alternatives, and sometimes just preference of the community
05:41:56 <Jafet> Because we ate all their quiche
05:42:09 <osfameron> hmmm, I think the quiche answer is better ;-)
05:42:14 <Kaidelong> lars9: wouldn't a lot of places where you'd use CPS just be done in haskell using (f .)
05:42:18 <azaq23> Can I pattern match against the content of a variable? So, for strings, something like \s -> let x = "string" in case s of { x -> ... }, working like \s -> case s of { "string" -> ... }, like scalas backquotes?
05:42:35 <osfameron> Kaidelong: but wouldn't that apply to ocaml too?
05:42:49 <Jafet> ocaml is eager.
05:42:53 <osfameron> ah
05:43:07 <Jafet> (Or strict, for the pedants at home)
05:43:09 <Kaidelong> you can still do it in OCaml yes
05:43:19 <Kaidelong> it'd come down to operative semantics
05:43:23 <Kaidelong> operational?
05:43:26 <Kaidelong> operational
05:44:04 <Bynbo7> azaq23: no
05:44:06 * Kaidelong wonders if (.) is least strict
05:44:23 <Kaidelong> > const 5 . undefined $ undefined
05:44:25 <lambdabot>   5
05:44:28 <Kaidelong> yes
05:44:45 <Bynbo7> :t undefined . undefined
05:44:47 <lambdabot> forall b (f :: * -> *). (Functor f) => f b
05:45:07 <Boxo> :t (.)
05:45:08 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:45:40 <Kaidelong> actually that means the strict vs non-strict distinction is important here
05:46:09 <Kaidelong> unless continuation passing style can be as non-strict as (.)
05:46:35 <Kaidelong> I suppose it could in some cases
05:46:40 <Kaidelong> or all cases
05:47:20 <lars9> to get depth of binary tree: depth Empty = 0; depth _ l r = 1 + max (depth l) (depth r); how to make it into tail call style?
05:47:57 <Kaidelong> lars9: why would you want to? there is more than one subtree
05:48:30 <Kaidelong> just put up with the "max" around the recursive calls
05:48:39 <lars9> second pattern match should be depth (Tree _ l r) = ...
05:48:48 <Bynbo7> depth t = go t 0 where go Empty x = x; go (Node _ l r) x = go l . go r $ x+1
05:49:07 <Bynbo7> uh, hmm, that's not wuite right
05:49:10 <Bynbo7> q*
05:49:22 <Bynbo7> that's the cumber of nodes :)
05:49:36 <lars9> that's just an ocaml question
05:49:39 <Bynbo7> i'm not sure you can make that tail recursive
05:50:01 <Kaidelong> Bynbo7: you could using CPS, but you'd still accumulate in the continuation, so you don't really gain anything
05:50:11 <Bynbo7> yeah
05:50:16 <ddarius> Bynbo7: Note that your counting function isn't tail recursive either.
05:50:16 <Kaidelong> or you shouldn't. Implementation details may matter
05:50:32 <Kaidelong> I have noticed some F# code that ran faster when I refactored it to use CPS and tail calls
05:50:36 <Bynbo7> ddarius: sure, but it should perform better no?
05:50:41 <Kaidelong> it had to do with binary trees
05:52:14 <lars9> wikipedia said all lambda can be converted to CPS automatically, if that's true, why do we need to convert it?
05:52:14 <ddarius> Bynbo7: Actually, it will perform worse, but that's from something else.  It will potentially use less stack, but still unbounded amounts of stack.
05:52:20 <lars9> http://en.wikipedia.org/wiki/Continuation-passing_style
05:53:03 <lars9> it's said CPS + TCO can eliminate the requirement of stack
05:53:07 <Bynbo7> ddarius: yeah, true. is there a way to avoid that?
05:53:33 <ddarius> Bynbo7: Yes and no.
05:53:37 <ddarius> In general, no.
05:53:44 <ddarius> In this particular case, yes, but not in Haskell.
05:53:52 <Jafet> lars9: why do you want to avoid stack?
05:53:54 <Bynbo7> yeah
05:54:00 <Jafet> Current hardware is optimized for stacks
05:54:13 <Bynbo7> ddarius: well, not with pure haskell anyway right? you could use ST couln't you?
05:54:18 <Bynbo7> couldn't*
05:54:38 <ddarius> (Admittedly, in this particular case a different approach would work, namely flattening and then summing the resulting list, but that's exploiting the associativity of addition.)
05:55:17 <ddarius> Bynbo7: You could if you made a mutable tree type.  The way I was referring to is to use pointer reversal to store the stack in the tree as you traverse it.
05:55:21 <Bynbo7> how would you flatten to get the maximum depths?
05:55:42 <ddarius> Bynbo7: I was referring to the counting version with that.
05:55:49 <Bynbo7> ah, ok
05:59:07 <Kaidelong> lars9: seems like it is mainly of interest for people trying to write "stackless" implementations
05:59:36 <Kaidelong> I do not think CPS can magically make a function that isn't tail recursive stop taking up extra memory, unless partial evaluation is involved somehow
06:00:24 <ddarius> CPS just moves where the stack is stored.  It won't even reduce the amount of (logical) stack frames used.
06:00:45 <ddarius> (Of course, that's kind of the point.  CPS is supposed to expose what is happening.)
06:01:58 <Kaidelong> lars9: basically, CPS allows you to do things that'd normally require a stack and a notion of returns in an environment that does not do either semantically, which is the case for some kinds of compilers
06:02:37 <Kaidelong> so it's not really applicable to haskell unless you want to make some kind of "stackless" compiler for it
06:03:09 <lars9> Kaidelong ddarius: i see, i saw that problem in an ocaml interview, asking to convert depth Tree into CPS, 
06:03:38 <lars9> i dunno why ppl bother to do that if compiler can do it in compile time
06:03:44 <Kaidelong> it is an exercise to test that you understand how CPS works
06:03:48 <Kaidelong> I bet
06:03:55 <Kaidelong> not something of practical interest, hopefully
06:04:00 <Jafet> If you really want to, there's ContT
06:04:25 * Jafet serves more quiche
06:04:28 <Kaidelong> (I have used CPS before, so presumably there are some cases where it is useful...)
06:04:55 <Kaidelong> (PS: Only in F#, never in Haskell)
06:04:59 <ddarius> lars9: Converting to CPS isn't an optimization.  It's not something you want "done."
06:05:29 <dpratt71> not very topical, but I had a quick question about something I'm reading in "Programming Languages - Theory and Practice" that I thought someone here might be able to answer.
06:05:35 <dpratt71> "The arity of an operator, , is the number of arguments, or sub-trees, required by  to form an ast. A signature is a mapping assigning to each   dom() its arity  ()."
06:05:57 <dpratt71> what does "" represent?
06:06:09 <ivanm> it would presumably be defined earlier
06:06:15 <ddarius> It's being defined there.
06:06:47 <ddarius> Or at least (o) is.
06:06:52 <Kaidelong> I have seen omega used before to be a placeholder for some algebra
06:06:57 <ddarius> A lot of times the notation is overloaded.
06:07:08 * ddarius usually sees .
06:07:37 <Kaidelong> well a name of an algebra rather than a term in it, to be specific
06:08:06 <lars9> math guys may prefer to write haskell code with those symbols
06:08:56 <dpratt71> is it possible as simple as: "" represents an imaginary function that returns the # of arguments of a given operator?
06:09:41 <ddarius> dpratt71: It is -defining-  there.  That is what it is defining  to be.
06:09:57 <underfire> OFFTOPIC note to self: update my irc client in order to properly see those symbols instead of big fancy boxes
06:10:07 <dpratt71> I still don't get the "  dom()" bit, though
06:10:18 <Kaidelong> o is an element of the domain of omega
06:10:58 <Jafet> For each o where (o) is defined, that sentence defines the definition of (o)
06:11:53 <lars9> could i ask some problems about english? how to say (1 - (14/56)^3)?, if not please tell me which channel can i go:)
06:11:54 <dpratt71> oh! right. sorry, much of this notation is...well, I was going to say 'Greek to me'
06:12:06 <dpratt71> but I guess it's Greek to everyone
06:12:34 <Jafet> lars9: "Hey, does anyone here have a napkin?"
06:12:38 <Kaidelong> lars9: one minus fourteen over fifty-six to the third power
06:12:51 <ddarius> Kaidelong: Incorrect (or rather ambiguous.)
06:12:57 <Kaidelong> ambiguous yes
06:13:15 <ddarius> "One minus the cube of the quotient of 14 and 56."
06:13:32 <lars9> Kaidelong: so the easy to say and easy to listen way is?
06:13:56 <Kaidelong> lars9: context and phrasing help a lot...
06:14:09 <Kaidelong> but you can do what ddarius did
06:14:14 <ddarius> Most English speakers would say the former and use pacing in the speech to indicate intent, but they'd something more like what I suggested if they didn't want to rely on verbal cues.
06:15:16 <HugoDaniel> hi
06:15:19 <lars9> thank you both
06:15:19 <phao> what is the value ()?
06:15:25 <phao> is it like c's void?
06:15:28 <Jafet> > ()
06:15:29 <lambdabot>   ()
06:15:33 <lars9> >:t ()
06:15:35 <lars9> :t ()
06:15:36 <lambdabot> ()
06:15:44 <lars9> @src ()
06:15:44 <lambdabot> data () = ()
06:15:53 <ddarius> phao: Yes, except that it's a first class value and it is better named than C's void.
06:15:55 <Kaidelong> phao: no, not really... () actually is a value as opposed to void which more isn't one...
06:15:55 <underfire> gotta love lambdabot
06:16:07 <Kaidelong> or void is any value
06:16:12 <Kaidelong> or the void value
06:16:14 <Kaidelong> or something
06:16:19 <Jafet> () is the syntax for the single value of the type whose name has the magical syntax ()
06:16:25 <Kaidelong> I guess () is of type ()
06:16:31 <Kaidelong> and void is of type "anything you like"
06:16:32 <ddarius> Jafet: It's the zero tuple.
06:16:49 <Jafet> Hm, where's the one-tuple then
06:16:58 <ddarius> > (1)
06:16:59 <lambdabot>   1
06:17:13 <jeltsch> Kaidelong: void isnt of any type, but void is a type, not a value.
06:17:19 <Jafet> That's a bit too flat
06:17:21 <Kaidelong> yes, that's true
06:17:21 <phao> Kaidelong, that'd be void*, and in terms of pointers
06:17:22 <ddarius> Arguably it's inconsistent in strictness.
06:17:35 <Jafet> With GHC extensions: data Void;
06:17:35 <Kaidelong> actually that makes the question a bit off
06:17:40 <Kaidelong> since () is a value
06:17:41 <phao> Kaidelong, void itself, in C, was created to mean "no type"
06:17:47 <ddarius> Kaidelong: () is also a type.
06:18:02 <lars9> () is also a data constructor right?
06:18:20 <lars9> :k ()
06:18:21 <lambdabot> *
06:18:25 <phao> I compared to void because I was wondering if the value () was created to mean "no value here"
06:18:31 <ddarius> If void meant what the name suggests and what "void" normally means in type theoretic jargon, no void C functions could ever return.
06:18:50 <jeltsch> phao: I wouldnt say no value, but dummy value.
06:19:00 <phao> jeltsch, dummy? what does that mean?
06:19:03 <Jafet> You can say that once you actually figure out the denotational semantics of C
06:19:09 <Kaidelong> anyway the haskell () is a real value of type ()
06:19:14 <p_l|backup> ddarius: unless it means "void type", not "void value"
06:19:32 <jeltsch> phao: A value that carries no information but is only present because there has to be some value present.
06:19:34 <ddarius> p_l|backup: There are no "void values."
06:19:41 <lars9> () is a value which you dont care, usually used in IO
06:19:48 <phao> right
06:19:48 <phao> thx
06:19:50 <Kaidelong> () is unit
06:20:09 <silbo> hey void guys, can anyone help me with my quarto game?
06:20:13 <silbo> mkPlaceingMap :: Config -> [Config]
06:20:14 <silbo> mkPlaceingMap (_,_,_,[],_,_,_) = []
06:20:14 <silbo> mkPlaceingMap (player,fig,board,(pos:free),avail,uscore,mscore) = [] ++ ( move (player,fig,board,(pos:free),avail,uscore,mscore) (pos,fig) )
06:20:24 <silbo> can't figure out what is the problem here
06:20:45 <Jafet> You can probably replace all IO () by IO Void
06:20:57 <jeltsch> Ja
06:20:59 <ddarius> Jafet: In Haskell you could.
06:21:19 <Eduard_Munteanu> Are there uninitialized STRefs/IORefs? I kinda want to avoid recursive do for something I'm doing.
06:21:25 <jeltsch> Jafet: No, you cant. An action of type IO Void could not return anything (apart from undefined).
06:21:39 <ddarius> In a total language, that would mean that the IO action threw an exception or invoked an abortive continuation or terminated the program, etc.
06:21:42 <Eduard_Munteanu> More specifically I'm making a tree with IORefs (forward and backlinks).
06:21:51 <Kaidelong> how would IO Void be inhabited if Void isn't?
06:22:09 <jeltsch> Void has no values, () has one value. Huge difference!
06:22:17 <ddarius> Eduard_Munteanu: Yes, there's newIORef_ and presumably the same for STRef.  It corresponds to initializing with undefined which you can do explicitly as well.
06:22:33 <Eduard_Munteanu> Oh, good idea, thanks ddarius.
06:22:36 <ddarius> Kaidelong: The same way Maybe Void is.
06:22:54 <Jafet> jeltsch: an action of type IO () could only return one value, so how is that more useful?
06:23:07 <Kaidelong> ddarius: Ah, so you use a conjunction to introduce a value to the type?
06:23:11 <Kaidelong> err, a disjunction
06:23:23 <Kaidelong> that makes sense
06:23:24 <allbery_b> in haskell it's the difference between bottom and ref bottom
06:23:26 <ddarius> Kaidelong: That's one possibility.
06:23:38 <ddarius> Void -> Void is also inhabited.
06:23:41 <jeltsch> Jafet: In a total language, an action of type IO () could terminate normally, returning (). An action of type IO Void couldnt terminate normally.
06:23:43 <allbery_b> (thanks to laziness)
06:23:45 <Jafet> IO () has loads of values.
06:23:56 <ddarius> Just because Void is in the type doesn't mean the -whole- type can take on no values.
06:24:04 <Jafet> So would IO Void. They return undefined, so just don't try to evaluate it
06:24:09 <ddarius> It is the case that any product containing Void is isomorphic to Void though.
06:24:22 <Kaidelong> ddarius: I get it now, I think.
06:24:33 <ddarius> (Basically, Void does indeed behave like 0, () like 1, Either like +, and (,) like *.)
06:24:39 <Kaidelong> forall a. (Void,a) -> Void
06:24:41 <Kaidelong> is inhabited
06:24:50 <jeltsch> Jafet: Well, returning undefined isnt very elegant. It seems like a hack that only works because Haskell isnt total.
06:24:55 <Kaidelong> but
06:25:09 <Kaidelong> forall a. Either Void a -> Void
06:25:11 <Kaidelong> is not inhabited
06:25:34 <ddarius> Kaidelong: No, it's still inhabited.
06:25:51 <ddarius> Er, I'm wrong.
06:26:00 <rjo> could someone try to guess what are get and set meant to do in this code? http://bit.ly/hcsY23
06:26:02 <ddarius> Either Void a -> Void is indeed uninhabited.
06:26:06 <jeltsch> It is inhabited, but only because Haskell isnt total. In Haskell, every type is inhabited with bottom
06:26:15 <rjo> src/AnnotatedGraph.hs:127:14: Not in scope: `set'
06:26:15 <Jafet> jeltsch: what would putStr "a" return? If there's nothing for it to return, it makes no real difference whether it returns () or undefined :: () or undefined :: Void.
06:26:25 <Boxo> @djinn Either () Char
06:26:25 <lambdabot> Error: Undefined type Char
06:26:30 <Boxo> @djinn Either () Bool
06:26:30 <lambdabot> f = Left ()
06:26:36 <Boxo> @djinn Either () Void
06:26:36 <lambdabot> f = Left ()
06:26:50 <Kaidelong> jeltsch: In this case being inhabited only by bottom would be being uninhabited, though, anyway
06:26:55 <Boxo> @djinn ((), Void)
06:26:55 <lambdabot> -- f cannot be realized.
06:27:11 <Kaidelong> @djinn IO Void
06:27:12 <lambdabot> Error: Undefined type IO
06:27:12 <ddarius> Kaidelong: No, being inhabited by bottom is being inhabited.
06:27:23 <ddarius> In the above, I was restricting to a total language.
06:27:41 <jeltsch> Jafet: You are too pragmatic for my taste. :-)  Id like a successful I/O action to exit with a non-bottom value.
06:27:42 <Kaidelong> is bottom a value then?
06:27:46 <allbery_b> I guess I don't understand "inhabited".  "forall a. Either Void a -> Void" strikes me as a specialization of fromJust.  not a *useful* inhabitant, but...
06:27:48 <ddarius> Kaidelong: Of course it is.
06:28:02 <jeltsch> At least, thats the usual terminology.
06:28:04 <ddarius> Kaidelong: You can pass it to functions, store it in lists and references.  In what way is it -not- a value?
06:28:28 <Kaidelong> ddarius: how can you get information out of bottom?
06:28:32 <ddarius> allbery_b: In a non-total language, Either Void a -> Void is inhabited along with every other type.
06:28:37 <mreh> > Just 3 == Just 3
06:28:38 <lambdabot>   True
06:28:42 <mreh> > Just 3 == Just 4
06:28:42 <lambdabot>   False
06:28:43 <jeltsch> allbery_b: fromJust isnt a total function. So it wouldnt exist in a total language.
06:28:52 <mreh> :q
06:28:58 <mreh> heh
06:29:03 <ddarius> Kaidelong: You don't need to be able to get information from something for it to be a value.
06:29:07 <mreh> still getting used to xmonad
06:29:08 <jeltsch> Kaidelong: You cannot get information out of bottom.
06:29:14 <Jafet> jeltsch: but in the value denotation sense, putStr "a" can't ever fail, it either returns or dies in a fire
06:29:35 <Eduard_Munteanu> By the way, I was going to ask this... the simply-typed lambda calculus and System F from TAPL are touted as fully normalizable. This, to me, kinda alludes to totality, but how can they be total _and_ have 'fix'?
06:29:35 <jeltsch> Jafet: What you you mean?
06:29:58 <Jafet> jeltsch: because its only return values are () and bottom.
06:30:19 <Eduard_Munteanu> Did I misread anything there?
06:30:22 <jeltsch> Jafet: Hmm, I dont understand this.
06:30:30 <Jafet> eduard: by fully normalizable, you mean confluent?
06:30:47 <ddarius> Eduard_Munteanu: I'm pretty sure they don't mean the languages with fix added.  Certainly, the term "System F" doesn't mean a language with fix in the general context.
06:30:52 <Eduard_Munteanu> Jafet: I don't know about confluence. I mean "normalizable" :)
06:31:39 <Eduard_Munteanu> ddarius: but anyone can define fix-like combinators in the simply typed lambda calculus, can't they? It doesn't seem to be a language construct.
06:31:47 <ddarius> Eduard_Munteanu: No.
06:32:00 <ddarius> Fix has to be asserted to exist in either of those systems.
06:32:07 <Jafet> Er well, STLC doesn't have fix
06:32:30 <Jafet> I read "untyped" at first
06:32:31 <ddarius> In fact, the STLC doesn't have -any- values until at least some base types are asserted to exist.
06:32:44 <pozic> Is [(0,0).. (1,1)] defined anywhere?
06:32:56 <ddarius> (At least, the Church style form.  One could argue that the Curry style does.)
06:32:57 <Jafet> pozic: Ix?
06:33:03 <Kaidelong> @instances Enum
06:33:03 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
06:33:13 <Botje> :t range
06:33:13 <Eduard_Munteanu> How about defining it like this: fix = \f. (\x. f (x x)) (\x. f (x x)) ?
06:33:14 <lambdabot> forall a. (Ix a) => (a, a) -> [a]
06:33:22 <Kaidelong> @instances Ix
06:33:22 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
06:33:23 * Eduard_Munteanu hopes didn't miswrite the Y combinator.
06:33:26 <ddarius> Eduard_Munteanu: That's not well typed.
06:33:32 <Kaidelong> @instances-importing Ix
06:33:33 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
06:33:36 <ddarius> Eduard_Munteanu: Haskell is far stronger than the STLC and it can't type that.
06:34:16 <ddarius> (Admittedly, type systems were more or less created to -keep- that from being typeable, so...)
06:34:17 <pozic> Unless you can pass a proof to fix that the argument terminates, you cannot express fix in a typed language. 
06:34:36 <ddarius> pozic: Sure you can.  Haskell is typed.  Perhaps you meant "total."
06:34:48 <Jafet> Well, that's pretty much the definition of total
06:34:54 <pozic> fix = undefined
06:34:59 <pozic> Look, it's defined, but pointless.
06:35:08 <ddarius> @src fix
06:35:08 <lambdabot> fix f = let x = f x in x
06:35:27 <Guest47630> hey
06:35:28 <pozic> Yes, but let is an axiom.
06:35:37 <Eduard_Munteanu> So I guess there must be a typing rule that allows fix, hm.
06:35:38 <ddarius> pozic: So?
06:35:40 * Eduard_Munteanu looks for it
06:35:47 <aristid> :t fix
06:35:47 <lambdabot> forall a. (a -> a) -> a
06:35:53 <ddarius> Eduard_Munteanu: It not a typing rule, fix is a value.
06:36:11 <Eduard_Munteanu> ddarius: but you said the Y combinator isn't typable in the STLC.
06:36:16 <aristid> :t fix (+)
06:36:17 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
06:36:17 <lambdabot>     Probable cause: `+' is applied to too few arguments
06:36:17 <lambdabot>     In the first argument of `fix', namely `(+)'
06:36:22 <aristid> :D
06:36:25 <aristid> :t fix ($)
06:36:26 <lambdabot> forall a b. a -> b
06:36:26 <ddarius> Eduard_Munteanu: If you added fix the the STLC, all you would be doing is asserting that there exists a value of type (Int -> Int) -> Int (say) that satisfies some equations.
06:36:32 <aristid> :t fix (.)
06:36:33 <lambdabot>     Occurs check: cannot construct the infinite type: a = f a
06:36:33 <lambdabot>       Expected type: a
06:36:33 <lambdabot>       Inferred type: f a
06:36:40 <Eduard_Munteanu> Oh, hm.
06:36:41 <ddarius> Eduard_Munteanu: fix is not the Y combinator.
06:37:06 <Guest47630> i have f = map (\x -> 3*x) how can i fill 'x' when call f function?
06:37:31 <Botje> Guest47630: what's the type of f ?
06:37:31 <Jafet> :t \x = x x
06:37:32 <lambdabot> parse error on input `='
06:37:37 <Jafet> :t \x -> x x
06:37:38 <Boxo> :t fix id
06:37:38 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
06:37:38 <lambdabot>     Probable cause: `x' is applied to too many arguments
06:37:38 <lambdabot>     In the expression: x x
06:37:38 <lambdabot> forall a. a
06:37:39 <Eduard_Munteanu> ddarius: I thought there were multiple 'fix'-es, depending on language semantics. That is, for a non-strict language, fix would be the Y combinator. Am I wrong?
06:37:47 <Boxo> > fix id ()
06:37:51 <lambdabot>   mueval-core: Time limit exceeded
06:37:53 <Eduard_Munteanu> TAPL seems to be using the Z combinator mostly.
06:37:55 <ddarius> Eduard_Munteanu: The Y combinator is an -implementation- of fix.
06:37:59 <Eduard_Munteanu> Yeah.
06:38:13 <pozic> Eduard_Munteanu: fix in Haskell is as shown above. 
06:38:21 <ddarius> I can't write the Y combinator in Haskell, but I can still implement fix.
06:38:59 <Eduard_Munteanu> @src fix
06:38:59 <lambdabot> fix f = let x = f x in x
06:39:26 <Eduard_Munteanu> fix f = f (fix f)
06:39:44 <Jafet> fix f = f (fix f); y f = f f
06:39:48 <Eduard_Munteanu> Okay, so what prevents me from defining any of these in the vanilla System F or STLC?
06:40:01 <ddarius> Eduard_Munteanu: They don't have recursive definitions.
06:40:15 <ddarius> In fact, they don't have definitions at all.
06:40:20 <Eduard_Munteanu> Oh, right, chicken and egg problem.
06:40:31 <Eduard_Munteanu> fix there depends on recursion itself.
06:41:02 <pozic> > iterate succ 0
06:41:02 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
06:41:10 <ddarius> The Haskell definitions indeed use a built-in notion of recursion at the value level.
06:41:15 <Eduard_Munteanu> And I guess 'let' there messes up totality too? Or it doesn't allow fix by itself.
06:41:23 <Guest47630> i mean instead of e.g. 'g x = 3*x' 'f y = map g y' i can write it with lamba (g), but then i do not know how to set x (it fills 1 when i call f with one parameter)
06:41:23 <ddarius> You could also define fix without value level recursion via a recursive type.
06:41:24 <Eduard_Munteanu> s/\./?
06:41:50 <Jafet> @src Mu
06:41:51 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
06:41:51 <ddarius> Eduard_Munteanu: It depends on the semantics you give to let.  Non-recursive let is fine.  Recursive let probably isn't, but you could constrain it so that it is.
06:41:58 <Kaidelong> Eduard_Munteanu: let doesn't need to put its own definition in scope like haskell's let does
06:42:07 <Eduard_Munteanu> Ah.
06:42:12 <ddarius> Total languages have restricted recursive definitions.
06:42:22 <ddarius> +Extant
06:43:47 <Eduard_Munteanu> I guess the Y combinator indeed requires recursive types, right?
06:43:56 <Eduard_Munteanu> (or why isn't it typeable?)
06:44:03 <ddarius> In theoretical presentations what is usually done is you simple assert that there is a constant called "fix" of type (a -> a) -> a that reduces via fix f -> f (fix f) (an example of a delta rule).
06:44:12 <Jafet> Guest47blahblah: what do you mean by "set x"? map takes the lambda and uses it to turn the list into a new list
06:44:26 <ddarius> Eduard_Munteanu: The Y combinator is given in terms of an untyped language.
06:44:49 <Eduard_Munteanu> Hm, yeah, my bad.
06:44:52 <ddarius> However, the "recursion" comes up in the domain equation for the semantic domain of (untyped) values.
06:44:55 <lars9> @src ($)
06:44:55 <lambdabot> f $ x = f x
06:46:03 <aristid> lambdabot: ($) = id, but with a less general type
06:46:32 <Eduard_Munteanu> @vixen Do you understand?
06:46:33 <lambdabot> let's don't talk about that
06:46:42 <Jafet> Silly detour: http://okmij.org/ftp/Haskell/Fix.hs
06:47:16 <Eduard_Munteanu> Jafet: nice, thanks.
06:47:21 <Boxo> :t ($)
06:47:22 <lambdabot> forall a b. (a -> b) -> a -> b
06:47:33 <ddarius> That "recursion", though, is traditionally explained via an iterative fixed point construction.  Math itself doesn't include recursion.
06:48:06 <ddarius> (But then again, math doesn't include definitions either.)
06:48:33 * Eduard_Munteanu finds out "open recursion style" stands for "unfixed" functions.
06:48:36 <duckinator> hi
06:49:39 <ddarius> Indeed.  "Open recursion" is a somewhat silly term.
06:54:31 <aristid> why didn't oleg write down the type signatures there? :/
06:55:48 <Eduard_Munteanu> write-type-sigs-by-need
06:59:12 <aristid> i guess he just sees them in his head, no need to write them down
07:00:31 <Eduard_Munteanu> Hm, if we had equirecursive types, we could've unified 'data' and 'type' declarations, right?
07:00:48 <aristid> what? :)
07:01:15 <Jafet> Maybe Haskell's type system is too trivial for him
07:01:29 <ddarius> Eduard_Munteanu: Not unless you wanted to write everything as Maybe (a, x) and such.
07:01:48 <Eduard_Munteanu> Hm, yeah, disregarding constructors for now.
07:01:52 <rjo> after three hours, I almost managed to compile a program...
07:01:54 <ddarius> If we had equirecursive types, we could also type the Y combinator.
07:01:59 <rjo> now it fails in linking phase
07:02:11 <rjo> <command line>: unknown package: base-3.0.3.2
07:02:21 <Eduard_Munteanu> I see.
07:03:13 <ddarius> (And, unless the compiler required the equirecursive types to be explicitly declared, as I believe O'Caml does, all those "could not construct infinite type errors" you get would become well-typed but incorrect code.)
07:03:59 <Eduard_Munteanu> Yeah, I hear some ML dialect allows you to switch on/off infinite types.
07:04:28 <ddarius> O'Caml does with the -rectypes flag.
07:04:53 <ddarius> C# also has equirecursive types in a special case.
07:05:00 <ddarius> You can type the Y combinator in C#.
07:05:17 <Eduard_Munteanu> I wonder if it allows true peano numbers to be expressed that way.
07:05:39 <Eduard_Munteanu> Like converting from/to them.
07:06:16 <HugoDaniel> my haskell code sucks
07:06:31 <ddarius> HugoDaniel: You should see your C++ code
07:07:06 <Eduard_Munteanu> My STRef-based trees look really sucky now. :)
07:07:26 <HugoDaniel> my haskell code is an ode to how bad coder i am
07:10:14 <Eduard_Munteanu> I wonder whether I should write it in C instead, but naaah.
07:10:52 <HugoDaniel> usually i write 80% haskell and 20% C
07:11:14 <ddarius> Luckily odes are relatively easy to (numerically) integrate.
07:11:21 <HugoDaniel> after a few runs of criterion and profiling i usually write 5 or 6 functions in C
07:11:28 <Jafet> rjo: did you use --make?
07:12:34 <rjo> Jafet, yes, the build uses make
07:13:31 <rjo> maybe I have some indirect dependency to base-3.0.0.2 somewhere
07:14:55 <Jafet> Dependency hell!
07:15:22 <rjo> it seems to be complicated
07:16:02 <rjo> that magic "get / set" above was some fclabels / template haskell stuff, and I did had to put explicit dependencies to fclabel
07:16:22 <rjo> also, I required some other dependencies to use base 4.2
07:18:27 <rjo> /usr/bin/ghc --make -o dist/build/graphui/graphui -hide-all-packages -fbuilding-cabal-package ...  -package-id graphics-drawingcombinators-1.2.1-3290b509a41284f667007deb20fbee93 -package-id graphviz-2999.9.0.0-c3f3ece440f7038ee3ebb8ef5b8bf164 -O -O2 -Wall -XArrows src/Main.hs
07:18:41 <rjo> Linking dist/build/graphui/graphui ...
07:18:43 <rjo> <command line>: unknown package: base-3.0.3.2
07:20:41 <rjo> now I'm quite out of ideas
07:21:39 <jmcarthur> wow, Quadrescence really ripped into us
07:21:51 <jmcarthur> or at least thinks he did
07:22:17 <jmcarthur> "The air on which Haskell programmers seem to thrive reeks of foul stench of cargo cult mathematics, something in which I dont want to be a part."
07:23:33 <rjo> jmcarthutr, from where this quote is?
07:23:51 * ddarius doesn't know what "cargo cult mathematics" is.
07:24:36 <rjo> http://en.wikipedia.org/wiki/Cargo_cult_programming
07:24:43 <jmcarthur> http://symbo1ics.com/blog/?p=788
07:24:46 <copumpkin> lol
07:24:49 <ddarius> programming is not mathematics
07:24:54 <copumpkin> he's always been a bit of a weirdo
07:25:16 <tac-tics> No proofs, no math
07:25:30 <jmcarthur> my favorite part is where the complaint is nothing to do with mathematics and then he accuses us of not being true mathematicians as a result
07:25:39 <rjo> ddarius, it might refer to using mathematical concepts in programs, so that you do not properly undestand those
07:25:54 <jmcarthur> his complaint is that he has to add a type annotation
07:27:00 * hackagebot yackage 0.0.0 - Personal Hackage replacement for testing new packages.  http://hackage.haskell.org/package/yackage-0.0.0 (MichaelSnoyman)
07:27:41 <underfire> there's a tendency nowadays to use large computations for finding flaws in conjectures. It's like a brute-force pseudo-mathematics.
07:28:36 <tac-tics> Deep Blue for math
07:29:11 <underfire> or Stephen Hawking's voice box ^_^
07:29:46 <ddarius> A witness that refutes a conjecture -is- a proof of its negation.
07:30:15 <jmcarthur> underfire: is it bad that sometimes the quickest way to find a contradiction is through brute force?
07:30:24 <jmcarthur> heck, this is how quickcheck works
07:30:31 <pozic> > pred 0
07:30:32 <lambdabot>   -1
07:31:03 <tac-tics> > iterate pred 0
07:31:04 <lambdabot>   [0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-...
07:31:07 <pozic> underfire: what makes you think that there are no problems for which this is the only way to solve the problem?
07:31:46 <ddarius> pozic: There provably -are- problems for which that is the only method.
07:32:03 <ddarius> (Probably not interesting problems though.)
07:33:11 <underfire> i just think you simply increase the arguments in favor of a certain hypothesis to be true
07:33:24 <underfire> but you don't prove it, unless you of course find a contradiction
07:33:38 <zachk> quad loves (operator arg1 arg2) 
07:34:14 <Jafet> I prefer "quad loves coq"
07:35:54 <zachk> i tried coq once i didnt like it. too many periods for me 
07:37:55 <applicative> It's too bad about Quadrescence.   Especially that he seems to have been put over the edge by such excellent tutors as conal and mauke.
07:38:17 <ddarius> applicative: How is it "too bad"?
07:38:28 <copumpkin> he wasn't exactly receptive to begin with
07:38:33 <copumpkin> he told me he hated haskell several months ago
07:38:50 <applicative> is that right, I just crossed past him a couple of times
07:39:11 <ddarius> underfire: You get somewhat more than that.  You get realms where you know the proposition -is- true.  It is, of course, useless as far as proving the actual theorem goes.  However, it does increase the plausibility of the theorem, which may be useful in non-mathematical contexts.
07:39:29 <roconnor> who is Quadrescence?
07:39:59 <copumpkin> Quintessence's little brother
07:40:49 <applicative> http://symbo1ics.com/blog/?page_id=2  -- the 'about' page
07:42:53 <applicative> his real objection seems to be to the working of type classes in general, not to the particular design of Num, which could be legitiimately complained of
07:43:38 <roconnor> why didn't defaulting kick in for him? 
07:43:47 <roconnor> because of the Monoid contraint?
07:43:48 <ddarius> He was using Monoid.
07:43:49 <ddarius> Yes.
07:43:53 <underfire> ddarius: Yeah, you are right. I just remember some HUGE computation about zeros of the Riemman zeta function, like 300 million zeros found. I'd say, it's a compelling argument of the plausibility of the hypothesis, thou it doesn't actually prove it (which if the hypothesis is true, it will never halt). =)
07:44:20 <roconnor> ddarius: because no Num type is a monoid, or because the contraint existed?
07:44:21 <ddarius> Also, as the clearly erudite, not cargo-culty at all mathematician that he is, I'm surprised he was using Int rather Integer.
07:44:30 <zachk> sounds like "proving" the goldbach conjecture 
07:44:40 <ddarius> roconnor: Because defaulting only kicks in if you are using standard classes.
07:44:48 <zachk> whats defaulting? 
07:44:58 <jmcarthur> :t 5
07:44:59 <lambdabot> forall t. (Num t) => t
07:45:01 <jmcarthur> bah
07:45:08 <roconnor> oh, he made Int a Monoid
07:45:20 <Jafet> Well, Int makes a perfectly fine Monoid
07:45:26 <copumpkin> more than one, even!
07:45:31 <roconnor> Jafet: too perfecly
07:45:41 <ddarius> > let f :: Show a => a -> String; f = show in f 5
07:45:42 <copumpkin> more than two, even
07:45:43 <Jafet> Ominous music here
07:45:43 <lambdabot>   "5"
07:45:48 <rjo> in (statistical) physics there are many results, which are "proven" by numerics
07:45:51 <ddarius> > let f :: (Bits a, Show a) => a -> String; f = show in f 5
07:45:52 <lambdabot>   Ambiguous type variable `t' in the constraint:
07:45:52 <lambdabot>    `Data.Bits.Bits t'
07:45:52 <lambdabot>      a...
07:46:03 <jmcarthur> zachk: for certain type classes, if you leave something with no annotation haskell will choose a default concrete type for you
07:46:15 <rjo> e.g. some value is 2/3 or sqrt(2)/5, even if those are known only by numerical experiments without rigorous proofs
07:46:17 <roconnor> underfire: I have some haskell code to search for a counter example to the Reimann Hypothesis
07:46:24 <jmcarthur> > 1 -- this defaults to Integer, iirc
07:46:25 <lambdabot>   1
07:46:53 <rjo> or, it is uncommon to even have such proofs
07:46:56 <underfire> roconnor: cool!
07:47:12 <roconnor> http://mathoverflow.net/questions/31846/is-the-riemann-hypothesis-equivalent-to-a-pi-1-sentence/31981#31981
07:47:36 * ddarius writes a program to generate all proofs of theorems in analysis.
07:48:05 <roconnor> ddarius: see the problem is that searching all proofs is not quite the same as deciding if a theorem is true or false
07:48:08 <ddarius> All we have to do now is wait until it gets around to the Riemann Hypothesis' proof (unless it's false.)
07:48:09 <underfire> ddarius: name it ErdosBot
07:48:13 <underfire> =)
07:48:37 <roconnor> ddarius: RH could be true but not provable in whatever system you have in mind
07:48:39 <ddarius> roconnor: It is the same as semideciding it.
07:48:45 <underfire> roconnor: that's a pretty nice code!
07:48:49 <Jafet> The Riemann Hypothesis is: *** Exception: stack overflow
07:48:55 <roconnor> or worse, whatever system you have in mind could be inconsistent rendering your entire search useless
07:49:08 * Beelsebob prods wyrmlink
07:49:12 <Beelsebob> wyrmling even
07:49:24 <roconnor> underfire: Davis-Matiyasevich-Putnam-Robinson deserve most of the credit
07:49:38 <ddarius> roconnor: I'd be using analysis' axioms.  If they are inconsistent, then it's hardly the tool's fault and people will eventually prove the Riemann Hypothesis true.
07:49:40 <Beelsebob> Wyrmling: right, so as I was saying, we define f :: a -> b
07:49:46 <Wyrmling> Right
07:49:55 <Beelsebob> in Haskell, we would apply this using the syntax f x
07:49:59 <Beelsebob> the space indicates application
07:50:05 <Beelsebob> function application is left associative
07:50:18 <Beelsebob> so if we now have g :: a -> b -> c
07:50:21 <roconnor> ddarius: they might very well prove that RH is true, but if the axioms are not sound then the proof won't imply that RH is true.
07:50:26 <Beelsebob> we apply that as g x y
07:50:26 <Jafet> http://www.amsta.leeds.ac.uk/~pmt6jrp/personal/riemann.html
07:50:33 <ddarius> roconnor: Sound with respect to what?
07:50:34 <Wyrmling> Right.
07:50:35 <Beelsebob> left associativity means that's (g x) y
07:50:49 <Beelsebob> so we pass g it's argument, and get back a function of type b -> c
07:50:49 <Wyrmling> *nods*
07:50:59 <Beelsebob> then we pass it y, it's second argument, and get back something of type c
07:51:04 <roconnor> ddarius: sound with respect to your meta logic
07:51:15 <mreh> StateT $ map return [1,2,3] -- doesn't strike me as idiomatic haskell
07:51:36 <mreh> doesn't even strike me a valid haskell
07:51:39 <Wyrmling> Beelsebob, does that prevent haskell from defining a function that takes more than one argument? (Yes, newbie question, I know)
07:51:43 <mreh> what am I looking for?
07:51:48 <ddarius> What is my metalogic and how do I check soundness with respect to it?
07:51:53 <Beelsebob> Wyrmling: indeed, Haskell has no such thing as 2 argument functions
07:51:57 <Wyrmling> Ah
07:52:01 <Beelsebob> Wyrmling: but currying allows us to have things that look very much like them
07:52:06 <Wyrmling> I see.
07:52:24 <ddarius> roconnor: And I could instead use the axioms of set theory if you like.
07:52:30 <Beelsebob> Wyrmling: we can also define a new type data Tuple a b = Tuple a b...
07:52:32 <roconnor> ddarius: your meta logic is whatever you are using to define what a a proof is.  Soundness is Tarski's definition of truth
07:52:37 <Beelsebob> we then give it special syntax
07:52:39 <Beelsebob> (a,b)
07:52:58 <Beelsebob> now we can define a function as h :: (a,b) -> c
07:53:05 <Wyrmling> .. interesting.
07:53:08 <Beelsebob> i.e. it takes a tuple containing an a and a b, and returns a c
07:53:14 <Beelsebob> so we can call h with h (x,y)
07:53:29 <Beelsebob> Wyrmling: then we'd of course want a nice quick way to switch between the two alternatives
07:53:33 <Wyrmling> Beelsebob, I'd stay a while and listen to more, but I gotta go =/.
07:53:47 <Beelsebob> so we define curry :: ((a,b) -> c) -> a -> b -> c
07:53:57 <Beelsebob> and uncurry :: (a -> b -> c) -> ((a,b) -> c)
07:54:21 <roconnor> ddarius: I don't like the axioms of set theory if that is what you are asking :P
07:54:41 <benmachine> roconnor: they are consistent though, right?
07:54:54 <Wyrmling> Beelsebob, thanks a lot! Sorry I can't make you talk more. =]
07:55:00 <Beelsebob> np
07:55:02 <Wyrmling> (Or, I suppose, stay longer myself)
07:55:08 <roconnor> benmachine: the axioms of set theory?
07:55:16 <benmachine> roconnor: yeah
07:55:28 <roconnor> benmachine: I have no compelling reason to believe it is.
07:55:32 <benmachine> oh
07:55:39 <benmachine> I thought that had been proven
07:55:52 <ddarius> benmachine: In what system would it have been proven?
07:56:09 * benmachine shrug
07:56:25 <roconnor> you can prove it is consistent by working in set theory + large cardinals, but I have no compelling reason to beleive that is consistent either.
07:57:21 <roconnor> OTOH, I find Gentzens argument for the consistency of PA (and similarly for Martin-Lof Type theory) to be compelling
07:57:26 <ddarius> It'd be just like a liar to tell you that they are honest.
07:57:45 <roconnor> benmachine: I similarly doubt the consitency of Coq.
07:58:07 * hackagebot uu-parsinglib 2.5.6.1 - Online, error-correcting parser combinators; monadic and applicative interfaces  http://hackage.haskell.org/package/uu-parsinglib-2.5.6.1 (DoaitseSwierstra)
07:58:16 <HugoDaniel> yeh
07:59:27 <cole> My intuition is that by writing a mainloop as a recursive function I'd surely get a stack overflow, but I've noticed that this is a common paradigm in Haskell. How does haskell avoid a stack overflow?
07:59:57 <ddarius> cole: Why would it stack overflow?
08:00:09 <roconnor> Jafet: I didn't get your riemann link
08:00:17 <lars9> @instances Functor
08:00:18 <lambdabot> ((,) a), ((->) r), ContT r m, Either a, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
08:00:22 <lars9> @instances Monoid
08:00:23 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
08:00:30 <benmachine> cole: function calls in haskell don't necessarily correspond to stack frames
08:00:38 <roconnor> cole: there is no stack push on function calls in Haskell
08:00:42 <benmachine> perhaps even don't usually
08:00:49 <Jafet> roconnor: it's humour (not to be confused with humor)
08:00:51 <roconnor> cole: in GHC the stack push happens on case statements
08:00:58 <roconnor> Jafet: I don't get the joke :(
08:01:14 <Jafet> Are you british?
08:01:22 <roconnor> I'm canadian
08:01:33 <Jafet> Ah well, nothing to worry about then
08:01:43 <roconnor> ok
08:28:51 <rjo> > head []
08:28:52 <lambdabot>   *Exception: Prelude.head: empty list
08:29:07 <rjo> > Just 5 > Nothing
08:29:08 <lambdabot>   True
08:29:13 <rjo> > Just 5 < Nothing
08:29:14 <lambdabot>   False
08:30:10 <Eduard_Munteanu> @src Ord Maybe
08:30:11 <lambdabot> Source not found. Sorry.
08:30:27 <Eduard_Munteanu> @src Maybe Ord
08:30:28 <lambdabot> Source not found. I've seen penguins that can type better than that.
08:34:05 <cole> There are methods of fixing a functions first and second arguments (by partially applying it) are there methods of fixing only its third, fourth or fifth?
08:34:38 <Eduard_Munteanu> "fixing"?
08:34:51 <Eduard_Munteanu> Oh.
08:35:30 <ddarius> cole: Sectioning just expands to lambdas.
08:35:32 <Eduard_Munteanu> You may define your own flip, then partially apply. Or using a lambda, like...
08:35:39 <Codex_>  \(x,y,z,a)->f(x,y,z,10,a)
08:35:40 <cole> Meaning you can curry the function and "fix" the first argument 
08:35:52 <Codex_> err
08:36:04 <applicative> this is why God gave us the lambda
08:36:12 <Codex_> I've been using c++ too much :(
08:36:36 <Eduard_Munteanu> f = \x y -> g x y 1 2 3
08:36:46 <ddarius> Codex_: That's completely legitimate Haskell.
08:36:58 <cole> Codex_: That offends my atheist sensibilities
08:39:11 <Eduard_Munteanu> I've been 'fix'-ing too much stuff today :).
08:39:57 <applicative> > let cole f fixed = \x y -> f x y fixed in cole foldr [1..10] (+) 0
08:39:58 <lambdabot>   55
08:47:25 <otzi> hello, I'm trying to follow this: http://uhsure.com/xmonad-log-applet.html but it seems like debian squeeze doesn't have a DBus module. Is it hidden within some package that's not named dbus, perhaps?
08:52:03 <benmachine> otzi: on hackage, only this package has a DBus module http://hackage.haskell.org/package/DBus
08:52:41 <copumpkin> ooh, Cale has some nice videos up on youtube
08:54:36 <applicative> otzi, is it the haskell bindings benmachine mentioned that you're missing, or dbus itself http://packages.debian.org/sid/dbus
08:56:09 <otzi> the bindings, import doesn't even work. I guess I need to install it through cabal
08:57:13 <applicative> otzi, I see, you're using packaged haskell things, but dbus hasn't been packaged.  That is a little irritating. 
08:57:28 <otzi> anyone from debian's haskell team around? Is there a reason for that library not to be packaged?
08:58:06 <sleepynate> otzi: i had the same problem on debian
08:58:13 <rjo> .cabal]$ find . -name \*  | while read file ; do grep base-3.0.3.2 $file; done
08:58:17 <rjo> Binary file ./lib/graphics-drawingcombinators-1.2.1/ghc-6.12.1/Graphics/DrawingCombinators.hi matches
08:58:27 <sleepynate> otzi: you need to get cabal and do a cabal install --global dbus
08:59:30 <rjo> I would like to know, why this specific library contains reference to base-3.*
09:00:23 <applicative> sleepynate, this won't mess things up if he tries to get haskell dbus from the package manager later?
09:01:10 <sleepynate> applicative: it's not in the package manager
09:01:22 <sleepynate> aptitude, anyways
09:02:39 <sleepynate> vlad:~% apt-cache search dbus | sort | grep ghc | wc -l 
09:02:39 <sleepynate> 0
09:04:29 <sleepynate> if you're phony-tough and crazy-brave, i guess you could just manually put them in /usr/local/lib/DBus-04/ghc-* ... but cabal is a much nicer option :P
09:05:01 <applicative> sleepynate, I know.  My impression was that otzi has been installing hackage libraries with packages prepared by http://wiki.debian.org/Haskell
09:05:56 <sleepynate> that is also my impression. if you use the version of cabal in the repo it should be OK
09:06:38 <sleepynate> just don't pull anything stupid like sleepynate and end up with 3 different versions of ghc :o
09:11:13 <applicative> sleepynate, okay.  but it seems like he should ask the debian haskell people to package dbus(-hs) for the sake of xmonad.   
09:11:53 <sleepynate> applicative: have you ever emailed the debian haskell team? :)
09:12:11 <applicative> no, I was worried about that too...
09:12:20 * sleepynate ducks the glare of debian haskell maintainers present
09:12:32 <sleepynate> applicative: i tried twice. both times i was told it was someone else's problem
09:12:37 <sleepynate> then i gave up :P
09:13:33 <sleepynate> josip rodin if you're listening plz fix things kthx
09:14:23 <sleepynate> basically debian is super picky about everything forever which is why i love and hate them at the same time. we have a horrible abusive relationship
09:15:41 <sleepynate> aptitude will punch me in the cabals and then go out drinking while i weep into my pillow, but then the next morning he'll come back with 360MB of presents and tell me how sorry he is.
09:16:30 <revenantphx> :|
09:16:44 <HugoDaniel> is there any readMaybe ?
09:16:58 <HugoDaniel> something that returns a Maybe a instead of an exception if there is no parse...
09:17:38 <copumpkin> :t fmap fst . listToMaybe . reads
09:17:38 <lambdabot> forall a. (Read a) => String -> Maybe a
09:18:15 <HugoDaniel> oh :(
09:21:00 <allbery_b> this is confusing, the dbus thing is both here and #xmonad...
09:21:23 <ddarius> @hackage safe
09:21:24 <lambdabot> http://hackage.haskell.org/package/safe
09:22:29 <dpratt71>   copumpkin: do you have a link for those vids by Cale you mentioned earlier?
09:22:41 <copumpkin> they're completely unrelated to haskell :)
09:22:46 <dpratt71> oh
09:22:52 <copumpkin> http://www.youtube.com/user/cgibbard 
09:22:54 <dpratt71> what are they?
09:23:03 <dpratt71> guess i'll find out :)
09:23:05 <copumpkin> craploads of magnets!
09:23:22 <applicative> allbery_b, I thought of sending otzi to #xmonad ...
09:23:26 <ddarius> I wonder if he's still receiving free magrnets at the same rate.
09:23:32 <revenantphx> Oh look, Cale's shiny balls.
09:23:44 <allbery_b> (bait: rejected)
09:23:54 <dpratt71> cool; I know someone who will definitely appreciate this
09:28:16 <revenantphx> Blergh.
09:28:31 <revenantphx> I got a repetition enumerator working, but I'm not happy with it. 
09:28:44 <revenantphx> It requires passing the iteratee through it *and* passing it as a parameter :\...
09:29:26 <aristid> revenantphx: can't you fix that? :)
09:29:39 <revenantphx> I'm trying to think of a way.
09:30:13 <revenantphx> If I remove the iteratee as a parameter, I need some way to "reconstruct" a Continue Step from a Yield step, which brings me right back to the same issue I had originally.
09:35:42 <aristid> somebody needs to find a way to better manage the complexity of iteratees :/
09:44:00 <Eduard_Munteanu> I wonder if sum types fare well with these mutable STRef-ish trees.
09:44:13 <Eduard_Munteanu> So far they add lots of complexity :/
09:47:01 <Eduard_Munteanu> > Just 5 >>= return >>= +1 :: [Int]
09:47:02 <lambdabot>   <no location info>: parse error on input `+'
09:47:11 <Eduard_Munteanu> > Just 5 >>= return >>= (+1) :: [Int]
09:47:12 <lambdabot>   Couldn't match expected type `[a]'
09:47:12 <lambdabot>         against inferred type `Data.Mayb...
09:48:57 <Eduard_Munteanu> > Just 5 >>= liftM (return >>= (+1)) :: [Int]
09:48:58 <lambdabot>   Couldn't match expected type `[a]'
09:48:58 <lambdabot>         against inferred type `Data.Mayb...
09:49:44 <benmachine> Eduard_Munteanu: you can't end up with [Int] if you start with Maybe Int
09:50:14 <Eduard_Munteanu> benmachine: I was wondering how to mix monads without using transformers.
09:50:30 <benmachine> >>= stays in the monad type
09:50:58 <benmachine> you'd have to have a function specficially for converting from Maybe to list
09:51:03 <benmachine> :t maybe [] (:[])
09:51:04 <lambdabot> forall a. Maybe a -> [a]
09:51:14 <Eduard_Munteanu> Say I'm have an f :: ... -> ST s (Maybe ...)
09:51:36 <Eduard_Munteanu> The idea was to use the inner maybe as a monad so I don't use case expressions.
09:51:56 <benmachine> hmm
09:52:01 <Eduard_Munteanu> But yeah, I guess it doesn't make sense because Maybe's fail can't deal with ST.
09:52:25 <benmachine> well you could construct a function a -> Maybe b and then use fmap and (=<<) to apply it
09:52:32 <Eduard_Munteanu> (rather ST can't deal with Nothing)
09:52:32 <benmachine> hmm
09:52:49 <benmachine> :t \f -> (fmap f =<<)
09:52:50 <lambdabot> forall a b (m :: * -> *). (Functor m, Monad m) => (a -> b) -> m (m a) -> m b
09:52:51 <Eduard_Munteanu> Yeah, but now I realize I still have to pattern-match Just/Nothing
09:53:11 * benmachine fiddles with things
09:53:46 <Eduard_Munteanu> @src ST fail
09:53:46 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
09:53:52 <benmachine> :t \f -> (liftM (f =<<) =<<)
09:53:53 <lambdabot> forall a (m :: * -> *) b (m1 :: * -> *). (Monad m, Monad m1) => (a -> m b) -> m1 (m1 (m a)) -> m1 (m b)
09:54:07 <benmachine> er
09:54:10 <benmachine> that's not quite right
09:54:14 <Eduard_Munteanu> @src Monad ST
09:54:15 <lambdabot> Source not found. Maybe you made a typo?
09:54:26 <Eduard_Munteanu> (I always forget if this worked.)
09:54:55 <benmachine> the @src is always a bit patchy
09:55:01 <benmachine> better off checking the real docs
09:56:48 <Eduard_Munteanu> Anyway, probably what I wanted can't be done.
09:57:11 <benmachine> what did you want?
09:57:15 <benmachine> have you tried something like
09:57:16 <benmachine> do
09:57:20 <benmachine>   Just x <- action
09:57:22 <benmachine> etc.
09:57:51 <benmachine> ST probably just errors in the fail case I guess
09:58:53 <Eduard_Munteanu> Yeah, what I wanted is a bit inconsistent. And I thought it was "safer", but that's actually like fromJust :)
10:01:14 <silbo_> jaja
10:04:49 * hackagebot xcb-types 0.6.0 - Parses XML files used by the XCB project  http://hackage.haskell.org/package/xcb-types-0.6.0 (AntoineLatter)
10:13:31 <sshc> Hey, I have an interesting problem.  There is a C structure which, for sake of simplicity, we'll say is defined as "typedef struct _Array {int size; unsigned long *data, void *objData; struct functions {unsigned long (*getVal)(Array *array, int elem)} f} Array;".  I'm working in an IO action, and "arrayPtr :: Ptr Array" is a pointer to one of those structures retured by another foreign function.
10:13:37 <sshc> (newtype Array = Ptr Array).  I can already access the size by means of the HSC macro: "(size :: CInt) <- #{peek Array, size} arrayPtr" (I think Array here is the type of the C struct).  Now, the tricky part: how can I call the getVal inside of the struct and get the returned CULong?
10:14:22 <c_wraith> sshc, I think FunPtr is relevant here.
10:14:34 <sshc> First I'd need to peek the FunPtr inside the inner struct, which I'm not sure how to do
10:14:52 <sshc> Then I'd need to call a FunPtr in Haskell, which I also don't know how to do
10:15:23 <c_wraith> But I'll also suggest looking at the bindings-DSL package
10:15:24 <c_wraith> http://hackage.haskell.org/package/bindings-DSL
10:15:31 <c_wraith> It automates a ton of this
10:22:25 <sshc> Ah, this is very helpful http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/hsc2hs.html
10:22:28 <sshc> #offset is relevant
10:22:50 <sshc> Once I have a FunPtr, how do I call it in haskell?
10:24:06 <copumpkin> sshc: it tells you here: http://haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Foreign-Ptr.html#t%3AFunPtr
10:24:20 <tac-tics> FunPtr.party()
10:25:26 <sshc> Ah, peek even accepts "field.subfield".  That's convenient
10:25:28 <sshc> copumpkin: Thanks
10:26:37 <wto> :t map
10:26:38 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
10:26:45 <wto> @src map
10:26:45 <lambdabot> map _ []     = []
10:26:46 <lambdabot> map f (x:xs) = f x : map f xs
10:49:46 <megajosh2> Hey, does anybody know what the operator precedence of (++) is?
10:50:10 <copumpkin> :i (++) in ghci
10:50:21 <megajosh2> Oh okay, thanks!
10:50:26 <megajosh2> That'll be handy for the future
11:10:03 <systemfault> Nice: http://www.codecommit.com/blog/ruby/monads-are-not-metaphors
11:12:11 <paolino> hello, is there a nice way to serialize gadts ?
11:12:50 <monochrom> probably you have to hand-code most of it
11:14:00 <paolino> terrible
11:14:08 <mux> how can I use a qualified infix operator already?
11:14:20 <monochrom> I think this is because gadt is too general
11:15:02 <monochrom> for example it includes existential type and I wouldn't know how to serialize that generally
11:15:05 <mauke> > 2 Prelude.+ 2
11:15:05 <lambdabot>   4
11:15:13 <paolino> mh, there should be a serializable subclass of them
11:15:25 <paolino> excluding existentials yes
11:15:40 <mux> mauke: ah, I thought I had to use parens-trickery; thanks
11:17:41 <paolino> monochrom: thanks, I put oil on the keyboard then :-(
11:18:15 <paolino> also because gadts tends to be big
11:20:18 <copumpkin> why do GADTs tend to be big?
11:20:22 <copumpkin> most of my datatypes are smallish
11:20:50 <copumpkin> monochrom: GADT kind of has to have existentials though
11:23:25 <revenantphx> So out of curiosity, could I use template code to generate parsec parsers from the contents of a file?
11:23:31 <revenantphx> Feasibly, I mean.
11:23:43 <revenantphx> I'd think so, I just don't know the capabilities of Template Haskell.
11:26:45 <wharzl> I don't understand why I can 'cast' from VariableExpression to Expression where 'data Expression = VariableExpression'
11:27:24 <Twey> wharzl: The concept doesn't even make sense
11:27:32 <paolino> they are different stuff
11:27:35 <Twey> wharzl: VariableExpression is already of type Expression
11:27:42 <Twey> You don't need to cast it
11:27:46 <Twey> VariableExpression isn't a type
11:27:47 <paolino> the "=" is not casting
11:27:50 <wharzl> right, but I can't pass it as Expression
11:27:53 <invarius> Is there a reference for Mathematical texts explained? For example, Monoids or abelian groups, etc
11:28:11 <Twey> wharzl: You can pass it as *an* Expression, if you need an Expression for the type of some function somewhere
11:28:19 <wharzl> I have an instance of VariableExpression and want to pass it as an Expression
11:28:19 <Twey> (because it is an Expression)
11:28:37 <invarius> I've seen an example of mappings before relative to a haskell wiki, however, I cannot remember where it was
11:28:43 <Twey> You don't have an instance of VariableExpression  you have VariableExpression itself.  VariableExpression is an instance if you like of Expression.
11:29:16 <Twey> (though what we usually refer to as an instance in Haskell is something quite different, so perhaps it's best not to use that term)
11:29:32 <wharzl> heh ya
11:29:42 <Twey> wharzl: If you have: data Colour = Red | Green | Blue
11:29:46 <wharzl> but you will probably have to talk down to me a bit for a couple days
11:29:50 <wharzl> it's ok
11:29:51 <Twey> You're defining three different values, Red, Green, and Blue
11:29:57 <Twey> And they are all of type Colour
11:30:57 <wharzl> k
11:33:44 <mux> what do you guys do when you have a where binding that you wish scoped over two equations for a function? use an additional case for the pattern matching inside the function?
11:34:40 <monochrom> most of the time I probably make it toplevel and not export it
11:35:07 <mux> you can't do that if the binding needs to have some of the function's parameter in scope
11:35:37 <Twey> mux: I take it out of the function
11:35:45 <Twey> Yeah what monochrom said
11:35:50 <monochrom> ah, I misread. yours is an option too
11:35:57 <Twey> mux: Yes you can: you simply make it a parameter to the new function
11:36:05 <mux> Twey: but the code isn't the same
11:36:12 <FireSnake> I have a deprecated base 3.x that doesn't work with pdf2line -- I tried updating and have ghc6.12 and don't understand why my base package doesn't seem to be updating with it.  Anyone know how to update base?
11:36:32 <FireSnake> The error message I keep getting is that Prelude is deprecated.
11:37:45 <EliasAmaral> @src ($=)
11:37:45 <lambdabot> Source not found. Maybe you made a typo?
11:38:16 <applicative> FireSnake, is it installing?  These are just warnings, I would think.
11:38:25 <monochrom> if there is pattern matching for two or more parameters, it gets yucky, I may move the local function to toplevel at the end
11:39:20 <monochrom> there is a refactoring menu for that in the Java plugin for Eclipse :)
11:39:40 <FireSnake> It is installing but I get that error message frequently also in other packages that don't install or work so I wanted to know how to fix it.
11:39:56 <mux> what if you want to have that binding precisely, because you're trying to hint GHC at CSE? :-)
11:42:29 <Cale> mux: Maybe push one of the pattern matches inward?
11:42:54 <mux> Cale: that's what I've been doing using let ... in ... case
11:42:57 <Cale> (and use case)
11:42:58 <Cale> yeah
11:43:02 <mux> I'm wondering if there's prettier
11:43:17 <monochrom> { f 0 x = k + k; f n x = k + k + n  where k = x*x } -> { f 0 x = k + k where k = local x; f n x = k + k + n where k = local x; local x = x*x } is an example of refactoring and preserving CSE
11:43:29 <Cale> If you're caring about how GHC optimises things, probably sticking with let/case/lambda is best as far as syntax goes
11:44:03 <Cale> Because those are closest to what the core will end up looking like.
11:44:07 <revenantphx> The Performance/GHC page on the haskellwiki is quite... pretentious :3
11:44:13 <mux> that makes sense
11:44:18 <mux> thank you guys
11:46:36 <FireSnake> applicative I also don't know how to use it
11:46:53 <FireSnake> I tried import Text.pdf2line and that isn't working
11:47:00 <FireSnake> also tried import Text.Pdf2line
11:47:03 <FireSnake> how do I use it?
11:47:24 <applicative> FireSnake, it is just an executable:    pdf2line foo.pdf > foo.txt
11:47:36 <FireSnake> so I cabal install pdf2line
11:47:52 <FireSnake> and then from the command line anywhere I can run pdf2line foopdf>foo.txt
11:47:58 <applicative> in theory yes
11:48:55 <scan1> how do I get the lambdabot ot pl me pattern matching functions?
11:50:47 <FireSnake> I tried pdf2line from command line and it's not finding the command
11:50:55 <FireSnake> doesn't cabal install do that?
11:51:12 <FireSnake> or is there some other command I must execute for it to be found?
11:51:49 <Cale> scan1: It's probably not worth it. If you're doing lots of pattern matching, there probably isn't a nice points-free form
11:52:31 <applicative> FireSnake, ~/.cabal/bin must be in path.  What operating system are you using
11:52:40 <FireSnake> Ubuntu
11:53:35 <scan1> Cale: I only have a simple Maybe-mathing over a monad, I feel there is a mapping function but I can't find it
11:53:47 <Cale> What function?
11:54:03 <scan1> 	draw p (Just x) = draw p x
11:54:03 <scan1> 	draw _ Nothing = return ()
11:54:49 <applicative> FireSnake, if you do     echo $PATH   does it show ...cabal/bin listed somewhere
11:55:27 <FireSnake> applicative, no it doesn't
11:57:33 <FireSnake> I tried find cabal and it didn't find anything
11:57:34 <applicative> you need to add your cabal/bin to the search path.  if you do say,"   cat .bashrc  " do you see anything.
11:58:02 <FireSnake> How do I know where cabal is
11:58:11 <FireSnake> If I do which cabal it returns usr/bin/cabal
11:58:37 <applicative> yes, that's the executable called 'cabal' that you already used
11:58:58 <FireSnake> cat .bashrc no such file or directory
11:59:25 <applicative> FireSnake, just a sec, must look up how its done in Ubuntu, 
11:59:45 <FireSnake> applicative, thanks
12:02:07 <applicative> FireSnake, it could be looking at hidden files called .bashrc .bash_profile or .profile    If you do ls -a it will list the hidden files
12:02:40 <applicative>  you should also see the directory .cabal in there too with ls -a
12:04:30 <FireSnake> got it I see the .bashrc file
12:05:41 <FireSnake> got it I found cabal/bin
12:05:45 <FireSnake> .cabal/bin
12:05:48 <FireSnake> hidden directory
12:05:56 <FireSnake> so now I just add that to my .bashrc file?
12:06:10 <FireSnake> and I have the pdf2line command running from my main directory
12:06:14 <FireSnake> didn't realize I had to back up
12:06:16 <applicative> FireSnake, I was going to say so, but now I'm reading about the Ubuntu curiosities.
12:06:36 <FireSnake> I was deeper in the directory tree
12:07:54 <applicative> FireSnake, this may be out of date, but it suggests that what I was going to say is not quite right http://sahasranaman.com/2008/02/05/path-variable-in-ubuntu/
12:08:41 <FireSnake> thanks applicative.  I will try to add .cabal/bin to my export in the .bashrc file and read that article.  
12:11:15 <applicative> it looks like the other file to look at is /etc/environment   I take it you would have do sudo ... to alter it.  
12:12:37 <EvanR-work> question about Text.JSON, there doesnt seem to be a ByteString version of the encode decode. is it that simply composing the utf8 bytestring encoder with the String version does what i want efficiently?
12:13:38 <applicative> FireSnake, this page speaks with authority, and not as the scribes do: https://help.ubuntu.com/community/EnvironmentVariables
12:30:03 <dave-1-2-3> Hi, a small question: I'm trying to write a really simple web server. I'm following this example: http://haskell.org/haskellwiki/Simple_Servers. The problem is that many time the browser gets a connection reset error. Any ideas?
12:44:59 <alkabetz> Can I define a type that represents, say, a Float between 0 and 1?
12:45:30 <sproingie> not easily
12:45:40 <monochrom> not unless you use an abstract data type or prove invariants yourself
12:48:58 <Cale> You could use a full range float together with a mapping to the interval [0,1]
12:49:11 <monochrom> oh god haha
12:49:22 <aristid> -Infinity would be 0 and Infinity would be 1?
12:49:35 <alkabetz> Ugh.  Sounds like an ADT is probably the way to go. :)
12:49:39 <Cale> Something like that, yeah :)
12:49:43 * monochrom recommends the sigmoid function :)
12:49:50 <aristid> monochrom: what is that?
12:50:34 <monochrom> a shifted and scaled version of hyperbolic tangent to (-oo, oo) -> (0,1)
12:50:34 <Gracenotes> or arctan
12:50:57 <monochrom> used in back-propagation neural networks
12:51:20 <Gracenotes> but sigmoid's distributed nicer
12:51:38 <monochrom> it has a really nice derivative
12:51:56 <aristid> > arctan 0
12:51:56 <lambdabot>   Not in scope: `arctan'
12:52:00 <aristid> > atan 0
12:52:01 <lambdabot>   0.0
12:52:08 <aristid> > atan (-1/0)
12:52:09 <lambdabot>   -1.5707963267948966
12:52:18 <aristid> > atan (1/0)
12:52:19 <lambdabot>   1.5707963267948966
12:52:38 <aristid> > atan (-1/0) + pi / 2
12:52:39 <lambdabot>   0.0
12:52:43 <aristid> > atan (1/0) + pi / 2
12:52:44 <lambdabot>   3.141592653589793
12:52:51 <aristid> > (atan (1/0) + pi / 2) / pi
12:52:52 <lambdabot>   1.0
12:52:59 <Gracenotes> gotta scale it
12:53:01 <aristid> > (atan + pi / 2) / pi $ 0
12:53:02 <lambdabot>   0.5
12:53:09 <aristid> > (atan + pi / 2) / pi $ -1 / 0
12:53:10 <lambdabot>   0.0
12:53:15 <aristid> > (atan + pi / 2) / pi $ 1 / 0
12:53:16 <lambdabot>   1.0
12:53:23 <aristid> scaled arctan is cool
12:53:50 <aristid> especially with lambdabot's funny Num instance
12:58:10 <roconnor>  > (atan + pi / 2) / pi $ 1 / 0 :: CReal
12:58:13 <roconnor> > (atan + pi / 2) / pi $ 1 / 0 :: CReal
12:58:17 <lambdabot>   mueval-core: Time limit exceeded
13:04:30 <aristid> roconnor: looks like CReal is not good at dealing with infinities :)
13:04:36 <aristid> > 1 / 0 :: CReal
13:04:40 <lambdabot>   mueval-core: Time limit exceeded
13:05:09 <roconnor> ah
13:05:47 <aristid> > (1 / 0) / (1 / 0) :: CReal
13:05:51 <lambdabot>   mueval-core: Time limit exceeded
13:07:26 <Boxo> > 2*pi :: CReal
13:07:27 <lambdabot>   6.2831853071795864769252867665590057683943
13:08:11 <aristid> roconnor: i wonder if it would be possible to build something like CReal but with support for infinities
13:09:19 <roconnor> aristid: you could build a circle without too much difficulty
13:10:08 <aristid> i'm not sure what you mean
13:10:21 <aristid> > 1 `div` 0
13:10:22 <lambdabot>   *Exception: divide by zero
13:10:39 <roconnor> aristid: the one point compactification of the reals is a circle
13:10:56 <aristid> roconnor: like in atan?
13:13:50 <roconnor> not exactly
13:13:58 <roconnor> > atan (-1/0)
13:13:59 <lambdabot>   -1.5707963267948966
13:14:02 <roconnor> > atan (1/0)
13:14:02 <lambdabot>   1.5707963267948966
13:14:15 <roconnor> the limits of atan at the two infinities are different
13:14:38 <roconnor> whereas the one point compactification only adds one infinity
13:14:39 <aristid> roconnor: which function, then?
13:14:58 <roconnor> well
13:15:11 <roconnor> if atan returned an angle instead of a number
13:15:38 <roconnor> then |-1.5707963267948966"="1.5707963267948966"
13:15:42 <roconnor> then "-1.5707963267948966"="1.5707963267948966"
13:16:11 <roconnor> so that function would work well on the one point compactification.
13:16:35 <aristid> sorry, i don't really understand
13:17:07 <roconnor> :)
13:21:34 <joe6> @pl flip (++) "\n" (head $ words "j k")
13:21:34 <lambdabot> head (words "j k") ++ "\n"
13:21:50 <joe6> @pl interact flip (++) "\n" (head $ words "j k")
13:21:50 <lambdabot> interact flip (++) "\n" (head (words "j k"))
13:22:13 <aristid> joe6: what's the point of sending something point-free through @pl?
13:22:13 <joe6> @pl interact flip (++) "\n" head $ words
13:22:14 <lambdabot> interact flip (++) "\n" head words
13:22:26 <aristid> a pretty pointless use of @pl indeed
13:23:12 <joe6> aristid: i am just trying to get the line to work so that it can take contents from stdin and print out the first column
13:23:23 <joe6> i am just using @pl to see if it helps.
13:23:32 <aristid> joe6: @pl does not check if it's valid
13:23:43 <aristid> :t interact flip (++) "\n" head $ words
13:23:44 <lambdabot>     Couldn't match expected type `Char' against inferred type `a -> b'
13:23:44 <lambdabot>       Expected type: String
13:23:44 <lambdabot>       Inferred type: [a -> b]
13:23:44 <joe6> oh, ok.
13:23:58 <joe6> :t interact flip (++) "\n" head words
13:24:00 <lambdabot>     Couldn't match expected type `Char' against inferred type `a -> b'
13:24:00 <lambdabot>       Expected type: String
13:24:00 <lambdabot>       Inferred type: [a -> b]
13:24:07 <joe6> :t interact flip (++) "\n" (head . words)
13:24:09 <lambdabot>     Couldn't match expected type `Char' against inferred type `a -> b'
13:24:09 <lambdabot>       Expected type: String
13:24:09 <lambdabot>       Inferred type: [a -> b]
13:24:20 <joe6> :t interact (flip (++) "\n" (head . words))
13:24:21 <lambdabot>     Couldn't match expected type `String -> String'
13:24:21 <lambdabot>            against inferred type `[Char]'
13:24:21 <lambdabot>     In the second argument of `flip', namely `"\n"'
13:25:05 <paolino> :t interact
13:25:06 <lambdabot> (String -> String) -> IO ()
13:25:27 <joe6> :t interact ( head . words)
13:25:28 <lambdabot> IO ()
13:25:32 <aristid> :t flip
13:25:33 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
13:25:39 <aristid> :t Prelude.flip
13:25:39 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
13:25:43 <aristid> :t Prelude.flip (++)
13:25:43 <lambdabot> forall a. (Monoid a) => a -> a -> a
13:25:49 <aristid> :t Prelude.flip (Prelude.++)
13:25:50 <lambdabot> forall a. [a] -> [a] -> [a]
13:26:03 <aristid> :t head . words
13:26:03 <lambdabot> String -> String
13:26:22 <aristid> joe6: head . words is not a list, so it cannot be an argument to (++) or flip (++)
13:26:53 <paolino> it is a list of char
13:27:07 <aristid> no, head . words is not a list of Char
13:27:23 <paolino> right
13:28:18 <joe6> isn't that the same thing? list of Char = String?
13:28:51 <paolino> String -> String is not String
13:29:07 <joe6> gotcha.. it is expecting a function
13:30:00 <joe6> no, isn't that the same as [Char] -> [Char]
13:30:26 <paolino> :t (++) "\n" . head . words
13:30:27 <lambdabot> String -> [Char]
13:30:57 <paolino> :t (++) "\n"
13:30:58 <lambdabot> [Char] -> [Char]
13:31:04 <aristid> :T (++ "\n") . head . words
13:31:10 <aristid> :t (++ "\n") . head . words
13:31:11 <lambdabot> String -> [Char]
13:31:20 <aristid> > (++ "\n") . head . words $ "j k"
13:31:22 <lambdabot>   "j\n"
13:31:29 <joe6> i am trying to do something like the cut here, in haskell: echo "j k t" | cut -f1 -d' '
13:31:36 <benmachine> > (++ "\n") . head . words $ "      "
13:31:38 <lambdabot>   "*Exception: Prelude.head: empty list
13:31:43 <benmachine> oh no :(
13:32:49 <aristid> :t interact $ (++ "\n") . head . words
13:32:50 <lambdabot> IO ()
13:33:09 <aristid> > (++ "\n") . head . words . (' ' :) $ ""
13:33:11 <lambdabot>   "*Exception: Prelude.head: empty list
13:33:42 <aristid> > (++ "\n") . head . (++ "") . words $ ""
13:33:43 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
13:33:43 <lambdabot>         against inferred ty...
13:33:48 <aristid> > (++ "\n") . head . (++ [""]) . words $ ""
13:33:50 <lambdabot>   "\n"
13:34:01 <joe6> :t interact ((++ "\n") . head . words)
13:34:02 <lambdabot> IO ()
13:37:51 <joe6> it appears that interact does not work on each line at a time. It works on all lines at once. is that the behaviour?
13:38:24 <wharzl> can someone tell me how this maybe function works - http://hpaste.org/42597/maybe
13:38:44 <Botje> :t maybe
13:38:45 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
13:39:18 <Botje> if the Maybe a value is Nothing, that first b is returned ( a default value)
13:39:38 <Botje> if Maybe a is Just x, x is fed to the (a->b) function and that's returned
13:40:17 <wharzl> um
13:40:23 <Botje> so in this case, the code throws an error if the lookup fails
13:40:39 <Botje> if the lookup succeeds you write to the IORef pointed to in the environment
13:40:46 <benmachine> joe6: interact works lazily
13:40:50 <wharzl> the last lookup?
13:40:53 <benmachine> it should output as much as it can as soon as possible
13:43:46 <joe6> benmachine: thanks.
13:44:01 <wharzl> thx Botje
13:44:10 <wharzl> I'll hve to think about it more
13:45:42 <wharzl> I'd like to replace this maybe with a conditional
13:47:28 <wharzl> do I use Just?
13:47:33 <aristid> :t maybe .: const
13:47:34 <lambdabot> forall a a1 b. a -> b -> (a1 -> a) -> Maybe a1 -> a
13:48:07 <aristid> :t flip maybe id
13:48:10 <lambdabot> forall a. a -> Maybe a -> a
13:48:12 <aristid> :t fromMaybe
13:48:13 <lambdabot> forall a. a -> Maybe a -> a
13:48:27 <wharzl> oh my head...
13:49:03 <remy_o> @src fromMaybe
13:49:04 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
13:50:04 <wharzl> ah, I think I ca understand that
13:51:16 <aristid> :t \a f -> fromMaybe a . fmap f
13:51:17 <lambdabot> forall a a1. a -> (a1 -> a) -> Maybe a1 -> a
13:51:28 <aristid> :t maybe
13:51:29 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
13:51:36 <aristid> @pl \a f -> fromMaybe a . fmap f
13:51:36 <lambdabot> (. fmap) . (.) . fromMaybe
13:51:47 <aristid> yay
13:55:39 <wharzl> error on '= case' - http://hpaste.org/42598/gdfgf
13:58:07 <remy_o> :t \y f k -> fromMaybe y (k >>= (Just . f))
13:58:09 <lambdabot> forall a a1. a -> (a1 -> a) -> Maybe a1 -> a
13:58:11 <remy_o> @pl \y f k -> fromMaybe y (k >>= (Just . f))
13:58:12 <lambdabot> (. ((=<<) . (Just .))) . (.) . fromMaybe
13:59:00 <aristid> HAHAHA
13:59:10 <aristid> @pl is almost always funny
13:59:11 <lambdabot> is almost always funny
13:59:32 <wharzl> can anyone explain that error?
14:00:24 <remy_o> wharzl: that does not make sense
14:00:58 <remy_o> wharzl: what are you trying to do with symbol ? 
14:01:04 <dskippy> wharzl: First of all your LET has no IN.
14:01:43 <benmachine> it doesn't need to, it's a part of the do-block
14:01:48 <wharzl> I thought IN was optional
14:02:00 <remy_o> it is not
14:02:07 <polarina> Is there something that can read signed integers (e.g. Int32) for the Binary package?
14:02:26 <wharzl> I want to throw the error if the symbol was not found
14:02:36 <wharzl> otherwise I want to write the value
14:03:00 <wharzl> like a scheme set!
14:03:19 <remy_o> well, the "in" is optional here, but what you want is "case symbol of ..."
14:03:29 <knobo`> yesod looks like a cool project. Is it production ready?
14:03:53 <wharzl> like - http://hpaste.org/42599/l
14:03:55 <wharzl> ?
14:05:32 <zeiris> Wasn't there a paper/library some time ago, about using ternary logic to optimize parallel code?
14:05:43 <zeiris> I can't tell whether I'm remembering or imagining it.
14:06:07 <remy_o> wharzl: you'll probably need the 'in' there 
14:06:49 <wharzl> ok I'll try it
14:07:26 <wharzl> no difference in error message
14:07:53 <remy_o> ?
14:08:04 <wharzl> the only error is now on line 7
14:08:24 <wharzl> on liftIO I think
14:08:56 <wharzl> no, on 'value'
14:09:13 <wharzl> Couldn't match expected type `IORef a'
14:09:13 <wharzl>        against inferred type `Expression'
14:12:03 <wharzl> what the hell am I doing?
14:12:32 <wharzl> i fail :(
14:12:38 <hpc> :t writeIORef
14:12:39 <lambdabot> Not in scope: `writeIORef'
14:13:11 <hpc> wharzl: readIORef envRef
14:13:22 <hpc> readIORef :: IORef a -> IO a, iirc
14:13:34 <mm_freak> i noticed that a killThread/throwTo is silently ignored, if the target thread doesn't exist  is this specified behaviour?
14:13:36 <hpc> envRef is your first parameter, which your type signature says is :: Expression
14:14:02 <wharzl> that's true
14:14:08 <hpc> also, oh god the throws pattern
14:15:05 <wharzl> huh?
14:15:40 <hpc> wharzl: in java, you can have "public void foo() throws BarException {..."
14:15:40 <wharzl> I'll paste the original working code
14:15:55 <mm_freak> or, as a related question, can i make an Iteratee in the 'enumerator' package time out without using concurrency?
14:15:58 <hpc> and you have to catch the exception, even if you can statically guarantee it doesn't get thrown
14:16:14 <wharzl> this worked - http://hpaste.org/42600/works
14:16:21 <hpc> adding layers of verbosity
14:16:22 <wharzl> but it's too hard to modify for me
14:16:37 <wharzl> so I'm trying to simplify it
14:16:52 <wharzl> that maybe function is making it too complicated to change
14:17:29 <aristid> wharzl: then just use a case
14:17:29 <wharzl> so I'm trying to get rid of it
14:17:29 <hpc> oh, i see another
14:17:35 <hpc> :t maybe
14:17:36 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
14:17:45 <wharzl> I'm trying but I can't get it to work
14:18:01 <wharzl> doesn't compile - http://hpaste.org/42599/l
14:18:19 <hpc> wharzl: "(liftIO . flip writeIORef value)" :: something -> Maybe somethingElse
14:18:29 <hpc> from where it is in your call to maybe
14:18:35 <hpc> however
14:18:42 <aristid> wharzl: case lookup name environment of Nothing -> throwError $ UnboundVar "Setting an unbound symbol" name; Just ref -> liftIO $ writeIORef ref value
14:18:57 <hpc> "Just v -> liftIO . flip writeIORef value" isn't the same type as your Nothing case
14:19:11 <aristid> and it does not even use the v
14:19:14 <hpc> you want Just v -> liftIO . flip writeIORef value $ v
14:19:17 <wharzl> I'll try that
14:19:39 <hpc> @src maybe
14:19:39 <lambdabot> maybe n _ Nothing  = n
14:19:39 <lambdabot> maybe _ f (Just x) = f x
14:20:28 <hpc> you basically expanded the second case to just "f" instead of "f x"
14:20:37 <wharzl> yay it works!
14:20:49 <hpc> is Expression a type alias?
14:21:00 <wharzl> that flip function really confused me
14:21:03 <hpc> oh, nvm
14:21:11 <hpc> :t flip
14:21:12 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
14:21:17 <hpc> bleh
14:21:31 <hpc> flip :: (a -> b -> c) -> (b -> a -> c)
14:21:42 <hpc> so you give it a function of two parameters, and it flips them
14:21:55 <wharzl> i know, but it was so confusing the way it was used
14:22:22 <hpc> yeah
14:22:32 <hpc> the trick is that you can read f x y as (f x) y
14:22:46 <aristid> haskell trains your brain :)
14:22:51 <hpc> so you can read "flip writeIORef value" as (flip writeIORef) value
14:23:00 <hpc> which makes it easier to see what's being messed with by flip
14:23:25 <hpc> from there, you just have to reach a zen state :P
14:24:01 <wharzl> ow my zen hurts
14:24:20 <wharzl> I've only been coding haskell for 3 days, so it's still very hard
14:24:52 <hpc> that is the worst code for a 3-day-old coder to play with, imo
14:25:43 <wharzl> don't worry, I'm slowly getting it :)
14:25:46 <hpc> heh
14:26:09 <wharzl> can I destructure in an if?
14:26:26 <hpc> i assume you mean "curry"
14:26:37 <hpc> as in (\x -> f x) = f
14:26:57 <wharzl> not at all :)
14:26:59 <hpc> and yes, but you have to write "if' c t f = if c then t else f"
14:27:02 <hpc> oh
14:27:16 <wharzl> ow
14:27:29 <wharzl> is there a more elegant way?
14:27:38 <hpc> nope; if is syntax :P
14:27:53 <hpc> (technically, it's sugar for case, but still...)
14:28:08 <dskippy> You can curry your IF by writing a function to wrap it.
14:28:23 <hpc> my personal favorite conditional wrapper is (t ?? f) c = if c then t else f
14:28:27 <ddarius> (\x -> f x) = f is not currying.  It isn't even related to currying.
14:28:55 <wharzl> I'm in the middle of a function and I need to destructure
14:28:56 <hpc> i couldn't think of a better example
14:29:00 <ddarius> (Well, actually the latter is too strong.)
14:29:06 <dskippy> ddarius: You're right. It's Eta-Equivalence. 
14:29:11 <hpc> oh wow, i see
14:29:18 <hpc> wharzl: pattern matching?
14:29:29 <hpc> case foo of ...
14:29:31 <Mathnerd314> wharzl: let [a,b]=c in ... ?
14:29:46 <wharzl> ah ya, that looks right
14:29:53 <wharzl> let can destructure then
14:30:22 <hpc> be careful with let patterns, because if c doesn't match [a, b] you get runtime errors
14:30:23 <Mathnerd314> > let [a,b] = [1,2] in (a,b)
14:30:24 <lambdabot>   (1,2)
14:30:31 <Mathnerd314> > let [a,b] = [1,2,3] in (a,b)
14:30:32 <hpc> > let [a, b] = undefined in a
14:30:32 <lambdabot>   *Exception: Prelude.undefined
14:30:33 <lambdabot>   (*Exception: <interactive>:3:4-18: Irrefutable pattern failed for pattern [...
14:30:46 <ddarius> (Eta and beta conversion are the triangle equalities in the adjunction induced by curry/uncurry.)
14:30:47 <wharzl> hmmm
14:30:57 <hpc> > let (a, b, c) = (1, a, b) in c
14:30:58 <lambdabot>   1
14:31:28 <wto> good one!
14:31:35 <Mathnerd314> > let (a, b, c) = (b, c, 1) in a
14:31:36 <lambdabot>   1
14:31:53 <hpc> > 1 2 3 4 5
14:31:54 <lambdabot>   1
14:31:55 <hpc> :D
14:32:54 <Mathnerd314> > (+1) + (+2) $ 2
14:32:55 <lambdabot>   7
14:33:33 <remy_o> :t (+1) + (+2)
14:33:35 <lambdabot> forall a. (Num a) => a -> a
14:34:16 <wharzl> oh lordy I am hating IO monads right now
14:34:30 <Mathnerd314> hpc: which package is that from again?
14:34:35 <hpc> > let o m g = w t f in 1 0 1
14:34:36 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr -> a -> t'
14:34:36 <lambdabot>         against...
14:34:45 <hpc> aw
14:37:06 <ion> Why does 1 2 return 1 in lambdabot?
14:37:13 <wharzl> what's the haskell symbol for true?
14:37:19 <ion> True
14:37:22 <MoALTz> > let [a b c] = [1 2 3] in a
14:37:23 <lambdabot>   <no location info>: Parse error in pattern
14:37:27 <wharzl> oh, True
14:37:28 <parcs> ion: there is an ((->) e) instance of Num
14:37:29 <MoALTz> > let a = 1 in a
14:37:30 <lambdabot>   1
14:38:00 <hpc> parcs: technically Num a => (e -> a)
14:38:07 <MoALTz> -- (i post these patterns as a slight note to myself and to others with a perverse sense like my own)
14:40:57 <ddarius> @hackage vector
14:40:57 <lambdabot> http://hackage.haskell.org/package/vector
14:42:08 <wharzl> how do I destructure Expression out of 'type Environment = IORef [(String, IORef Expression)]'?
14:42:20 <wharzl> er
14:42:45 <wharzl> out of - 'type EnvironmentEntry = (String, IORef Expression)'
14:43:21 <wharzl> I'm trying - 'let (a, b) = ref in'
14:43:22 <ddarius> > Data.Vector.singleton 3
14:43:24 <lambdabot>   Not in scope: `Data.Vector.singleton'
14:44:35 <remy_o> wharzl: just don't try to give it a name
14:45:03 <remy_o> > let x@(a,b) = (1,2) in a
14:45:04 <lambdabot>   1
14:45:16 <wharzl> ah hm
14:45:59 <remy_o> > let f (a,b) = a in f (1,2)
14:46:00 <lambdabot>   1
14:46:35 <ion> Could someone please tell me what to google for (a -> b) instances for types? My google-fu isnt good enough. :-)
14:48:43 <wharzl> how do I convert from Expression to VariableExpression with a let and without erroring on failure?
14:49:23 <Mathnerd314> ion: hoogle oughtto work
14:52:51 <azaq23> ion: message lambdabot, use @hoogle
14:53:02 <azaq23> @hoogle Monad m => m a -> (a -> m b) -> m b
14:53:03 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
14:53:03 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
14:53:03 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
14:54:31 <roconnor> wharzl: you cannot
14:55:53 <wharzl> I don't understand
14:56:00 <wharzl> it's just a down cast, no?
14:56:06 <ion> My hoogle-fu isnt good enough either. Id like to learn about the Num a => (e -> a) instance that makes 1 2 return 1.
14:56:13 <wharzl> well, a 'downcast'
14:58:34 <azaq23> ion: This instance is in the vector package that's linked by above. Allows you to do things like the following, just see the link
14:58:36 <roconnor> ion: pointwise functions
14:58:38 <azaq23> > sin^2 $ 1
14:58:39 <lambdabot>   0.7080734182735712
14:58:44 <azaq23> @type sin^2
14:58:45 <lambdabot> forall a. (Floating a) => a -> a
14:58:57 <roconnor> wharzl: what do you think should happen on error if not failure?
14:59:13 <ion> azaq23, roconnor: Thanks
14:59:56 <ddarius> azaq23: It's not in vector, it's in vector-space.
15:00:33 <wharzl> let me post some code -
15:00:55 <wharzl> http://hpaste.org/42601/sdf
15:01:31 <wharzl> if it is a VariableExpression, then write, otherwise throw the error
15:02:42 <wharzl> I don't know how to check that though (hence the True)
15:02:45 <mreh> > [(1,a),(2,b),(3,c)] >>= (\(n,_) -> [1..n])
15:02:46 <lambdabot>   [1,1,2,1,2,3]
15:03:03 <roconnor> wharzl: use a case statement
15:03:12 <mreh> > do { (n,_) <- [(1,a),(2,b),(3,c)] ; [1..n] }
15:03:13 <lambdabot>   [1,1,2,1,2,3]
15:03:39 <roconnor> wharzl: or better yet, reuse your existing case statement
15:03:48 <roconnor> just (VarExpression foo) -> ...
15:03:59 <roconnor> Just _ -> fail "error message"
15:04:44 <wharzl> just?
15:04:50 <wharzl> you mean Just, right?
15:05:16 <wharzl> :t just
15:05:17 <lambdabot> Not in scope: `just'
15:08:09 <wharzl> ok, one last issue
15:09:04 <roconnor> yes Just
15:09:33 <wharzl> line 6 of - http://hpaste.org/42602/lll - Couldn't match expected type `IORef Expression' against inferred type `Expression'
15:10:02 <aristid> wharzl: if you have an IORef, you need to use readIORef to get the value out
15:10:21 <roconnor> @type writeIORef
15:10:22 <lambdabot> Not in scope: `writeIORef'
15:10:28 <roconnor> @hoogle writeIORef
15:10:28 <lambdabot> Data.IORef writeIORef :: IORef a -> a -> IO ()
15:10:37 <wharzl> where do I use readIORef, though?
15:11:01 <monochrom> I wonder where Expression is declared
15:11:15 <aristid> @hoogle readIORef
15:11:15 <lambdabot> Data.IORef readIORef :: IORef a -> IO a
15:11:19 <aristid> wharzl: in IO
15:11:25 <roconnor> wharzl: s/ref/envref
15:11:30 <monochrom> and Environment too
15:11:31 <roconnor> wharzl: s/ref/envRef
15:11:42 <wharzl> Just readIORef (VariableExpression ref)?
15:11:44 <roconnor> replace ref with envRef in taht line
15:12:08 <HugoDaniel> hello there
15:12:15 <zachk> hullo 
15:12:27 <aristid> wharzl: you seem to be assembling symbols together with no method or logic at all oO
15:12:39 <wharzl> feels like it
15:13:58 <wharzl> I agree I should use readIORef
15:13:58 <megajosh2> Hey, I'm trying to get an object to load with hs-plugins, but when I load it, it tells me this:
15:14:04 <wharzl> but where do I use it in the function?
15:14:05 <megajosh2> amethyst-plugs: /usr/local/lib/MissingH-1.1.0.3/ghc-6.12.3/HSMissingH-1.1.0.3.o: unknown symbol `hsloggerzm1zi1zi0_SystemziLog_ERROR_closure'
15:14:52 <wharzl> there doesn't seem to be any place for it
15:15:38 <roconnor> wharzl: http://hpaste.org/paste/42602/lll_annotation#p42603
15:16:54 <wharzl> that's wrong
15:17:01 <wharzl> envRef is the envrionment
15:17:07 <wharzl> ref is an entry in the environment
15:17:11 <wharzl> right?
15:17:29 <wharzl> or maybe not
15:17:35 <wharzl> I'll just try it
15:18:06 <wharzl> ya, that's definitely wrong
15:18:19 <monochrom> ref's type is Expression? then it can't be written to.
15:18:49 <monochrom> type-oriented programming is almost logic-oriented programming
15:18:55 <invarius> Given that you have a list of words, you are told to find those words in a dictionary of immense size. My initial thought on how to the word with the least step possible was to read the character of each line, however, that requires checking each and every line to make sure you can check it's condition and move on
15:19:03 <invarius> what is a much more efficient way to do this?
15:19:34 <wharzl> well, the error isn't there, it's here -
15:19:56 <wharzl> 'Just ERROR(VariableExpression entryRef)'
15:20:19 <wharzl> though using envRef may be correct after all
15:20:42 <roconnor> I don't know if it is correct or not, but envRef is the only IORef that is in scope
15:21:10 <megajosh2> http://hpaste.org/42604/problems_loading_o_files Here's the code I Was using
15:21:20 <ddarius> Curse you generality.
15:21:24 <monochrom> as the dictionary size approches infinity, the probability that it contains the words tends to 1. so it is pretty safe to just declare that the words are found in the dictionary, without really looking. :)
15:22:23 <wharzl> I'll post again
15:22:34 <invarius> monochrom: Hmm, I should mention that there's more to it than acknowledging its existence >_>
15:22:49 <wharzl> this compiles - http://hpaste.org/42605/kkk
15:23:43 <wharzl> this doesn't - http://hpaste.org/42606/asdsd
15:24:17 <wharzl> there error is at the 'Just (VariableExpression entryRef)'
15:24:55 <roconnor> wharzl: what is the type of entryRef?
15:25:08 <wharzl> it expects 'IORef Expression' but infers 'Expression'
15:25:18 <roconnor> what is it suppoed to be?
15:25:31 <wharzl> here's what Environment is -
15:25:31 <wharzl> type Environment = IORef [(String, IORef Expression)]
15:25:32 <roconnor> what is Environment?
15:25:37 <monochrom> the dictionary-on-disk needs to be rewritten in a binary-search-tree format (or b-tree, or trie, or hash table, or judy-hash...) to facilitate fast search. or else load into memory but I suppose the point of "immense" is can't load into memory
15:26:21 <roconnor> wharzl: okay, so entryRef is an IORef Expression.
15:26:55 <roconnor> so you have to read from it before you can do case analysis. ... which happens to be what monochrom was saying
15:26:57 <roconnor> sorry monochrom
15:28:13 <wharzl> what do I do then?
15:28:29 <wharzl> I need two cases?
15:28:44 <roconnor> for example: Just entryRef -> do { entry <- readIORef entryRef; case entry of  { VariableExpression varexp -> liftIO $ writeIORef entryRef value ; _ -> failWith "error" } }
15:29:00 <roconnor> two cases would work
15:29:15 <invarius> I had a bad feeling about that. So when I read it, how am I able to depict where data is? Should I set a label for the beginning of each lexical group?
15:29:19 <mreh> > replicateM [1,2,3]
15:29:20 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
15:29:20 <lambdabot>         against inferred type ...
15:29:29 <mreh> > replicateM 2 [1,2,3]
15:29:30 <lambdabot>   [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
15:29:33 <wharzl> could you give the example with two cases? :)
15:30:06 <roconnor> > sequence [1,2,3] 2
15:30:07 <lambdabot>   [1,2,3]
15:30:35 <copumpkin> ugh
15:31:34 <roconnor> wharzl: http://hpaste.org/paste/42606/asdsd_annotation#p42607
15:33:40 <wharzl> can't I just do - 'Just entryRef -> case readIORef entryRef of'
15:34:04 <invarius> So by Reading the dictionary, I should in fact sort it somehow, making a map of it
15:34:08 <invarius> Right?
15:35:22 <aristid> wharzl: no, because case of only takes values. readIORef returns an action, not a value.
15:35:24 <roconnor> wharzl: because you need to explicitly sequence when the readIORef occurs.  If you could do that lazyness would cause that readIORef to be delayed to some random future point in time
15:35:40 <roconnor> wharzl: chaos would abound
15:35:50 <roconnor> wharzl: cats would lay down with dogs
15:35:50 <c_wraith> wharzl: when you use something in a pattern match, you have to match the constructors of it.  And you can't match the constructors of IO.  (and they wouldn't do what you wanted if you could)
15:36:00 <roconnor> wharzl: and hamburgers would eat people
15:36:03 <wharzl> lol
15:37:12 <wharzl> man I suck at haskell
15:37:17 <megajosh2> http://hpaste.org/paste/42604/problems_loading_o_files_ann#p42608 After getting rid of MissingH, I still have a problem when loading this object
15:37:46 <aristid> wharzl: you just have to unlearn all you learned from other languages :)
15:37:58 <mreh> > sequence . replicate 2 $ [1,2,3]
15:38:00 <lambdabot>   [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
15:39:58 <wharzl> that gives me a terrible error
15:40:34 <wharzl> http://hpaste.org/paste/42606/asdsd_annotation#p42609
15:40:41 <roconnor> sorry I wrote what I wrote off the top of my head
15:40:55 <tswett> Huh.  The Typeclassopedia seems to say that in any valid functor, it's impossible to come up with functions pure :: a -> f a and g such that fmap g . pure /= pure . g.
15:41:08 <roconnor> wharzl: liftIO the readIOref
15:41:13 <tswett> (No matter what the type signature of g is.)
15:41:23 <roconnor> wharzl: gotta go be back in 30 min or so
15:41:53 <wharzl> Just entryRef ->  do entry <- liftIO readIORef entryRef ???
15:42:06 <c_wraith> twsett, well, g has to type-check in that expression, but yes.  That's part of the rules Functor is supposed to follow
15:42:08 <benmachine> liftIO (readIORef entryRef)
15:42:27 <tswett> But this doesn't seem to be true.  Suppose that g x = x*2 and pure x = [x+1].  Then fmap g (pure 5) = fmap g [6] = [12], whereas pure (g 5) = pure 10 = [11].  So is the Typeclassopedia simply wrong here?
15:42:34 <wharzl> holy crap it compiled
15:42:35 <wharzl> well
15:42:45 <wharzl> i now have a clearer picture
15:42:54 <wharzl> of how much I really suck at this language still
15:42:57 <tswett> c_wraith: well, it says that this rule automatically works for all implementations of pure, assuming that it's a valid functor.
15:43:01 <c_wraith> twsett, that violates the rules for pointed functors.
15:44:07 <c_wraith> twsett: mostly because it has the wrong type.  pure must be a -> f a, not Int -> f Int
15:44:09 <applicative> twsett, the type of your pure would have to be much narrower than that of pure proper
15:44:33 <tswett> Ah!  You're right.  Thank you.
15:44:38 <wharzl> i don't understand why I need a 'do' instead of a 'let in'
15:44:48 <ddarius> tswett: You may want to look at free theorems.
15:45:16 <applicative> tswett, I was going to say, there are free theorems in the neighborhood
15:45:53 <wharzl> I suppose the do keeps the monad threaded
15:45:57 <copumpkin> tswett: your pure doesn't have that type signature
15:46:08 <tswett> Indeed, the Typeclassopedia mentions that this law is a free theorem.
15:46:13 <copumpkin> tswett: your pure is Num a => a -> f a
15:46:20 <copumpkin> or a -> [a] I guess
15:46:57 <tswett> wharzl: right.  Haskell has the curious property that even though order of evaluation is undefined, the program's behavior is well-defined.  Thus, there must be something specifying what order actions are performed in.
15:47:04 <tswett> do specifies that order.
15:47:31 <wharzl> so anything with readIORef or whatever needs to be done with do?
15:48:22 <wharzl> same I suppose for writeIORef
15:48:30 <tswett> Well, there are other operators that are equivalent to do, but the rule is that whenever you want to perform multiple actions, you must use something like do in order to put them together.
15:48:46 <aristid> wharzl: or with >>=, but yes
15:49:03 <wharzl> tswett, I was wanting to just use 'let in'
15:49:06 <zachk> or with >> if you only care about side effects and not the return value 
15:49:12 <wharzl> but that didn't work with the monda
15:49:14 <wharzl> monad
15:49:19 <zachk> you can use let in do blocks just drop the in 
15:49:29 <sproingie> the way >>= works creates data dependencies that force a particular order
15:49:40 <sproingie> at least IO's >>=
15:50:00 <ddarius> @hoogle listToMaybe
15:50:01 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
15:50:03 <applicative> tswett, it's more obvious than I was thinking, how many functions are there like so:  foo :: a -> [a] ? Maybe three?  foo x = [x] ; foo x = [] ; or foo x = undefined
15:50:04 <wharzl> let doesn't keep the monad threaded, right?
15:50:10 <zachk> a >> b = a >>= (\_->b) iirc 
15:50:41 <tswett> applicative: well, there's also [a,a,a] and the like.
15:50:45 <mauke> :t replicate ?n
15:50:46 <lambdabot> forall a. (?n::Int) => a -> [a]
15:50:56 <applicative> right, indeed. 
15:51:04 <ddarius> Wrong way
15:51:12 <tswett> wharzl: right.  If you say "let x = readLine in . . .", then the variable x will contain the action "readLine", not the line that you read.
15:52:01 <zachk> line <- getLine becomes getline >>= (\line->rest of your code here..) 
15:52:45 <wharzl> I have to think in terms of monad threading
15:52:54 <sproingie> let x = readline realWorld in ...
15:52:57 <zachk> enlighten that to me 
15:53:23 <wharzl> otherwise I don't have enough context to resolve the program semantics
15:53:42 <sproingie> (that realWorld thing was a joke BTW)
15:53:48 <mikeg> If I have a library file that works on strict ByteStrings, is there an easy way to make a .Lazy variant and keep the two in sync?
15:53:49 <wharzl> there, x is just an expression, right?
15:54:00 <applicative> tswett, right that was stupid; it makes it clear why the claim has to hold that fmap g (foo x) = foo (g x)
15:54:09 <tswett> Monads implement the principle of "Do not change the world so that it gives you what you want; instead, change yourself so that you no longer want it."
15:54:26 <tswett> applicative: aye.  It can't touch the x it receives; it has to pass it through undigested.
15:54:47 <monochrom> mikeg: I think so. import the lazy bytestring module instead.
15:55:58 <mikeg> Heh. so when I change one of the functions, copy-paste into "Lazy.hs" and change the import?
15:56:43 <monochrom> yeah
15:57:50 <monochrom> there are also overkill TH solutions
15:58:04 <mikeg> I think I could also put all of the logic in Lazy.hs, then just repack strict ByteString's into lazy ones...
15:58:25 <mikeg> f = Lazy.f . B.fromChunks . (:[])
15:58:46 * monochrom writes paper "TH as a higher-order module system"
15:58:58 <copumpkin> dons: ooh, an SMT solver! what back-end are you using?
15:59:07 <zachk> whats SMT
15:59:24 <copumpkin> satisfiability modulo theories
16:00:04 <ddarius> We should make SMS, satisfiabliity modulo sketchs.
16:00:06 <ddarius> +e
16:00:52 <monochrom> SMT solves the halting problem
16:01:06 <zachk> we should make SMEX satisfiability modulo EXtensions 
16:07:06 <Znudzon> Hi all. I have installed criterion by cabal but i still have not in scope "bench" ... and i don't know what to do 
16:07:58 * hackagebot hemkay-core 0.1.3 - A device independent module music mixer  http://hackage.haskell.org/package/hemkay-core-0.1.3 (GergelyPatai)
16:08:32 <Botje> Znudzon: did you load the module?
16:09:42 <megajosh2> http://hpaste.org/paste/42604/problems_loading_o_files_ann#p42608 I'm trying to use hs-plugins to load an object but I get an error I'm not sure how to solve
16:11:31 <Eduard_Munteanu> Isn't it possible to have an existential without constraints?
16:11:36 <dankna> does Test depend on mtl and amethyst-plugs doesn't?
16:11:44 <Eduard_Munteanu> like data Foo = forall a => Foo a
16:12:04 <Znudzon> Botje: yes i've imported criterion
16:12:08 <Eduard_Munteanu> Or okay, lemme state my real problem...
16:12:20 <Botje> Znudzon: can you be more specific?
16:12:20 <benmachine> Eduard_Munteanu: not sure what the point of that would be :P
16:12:34 <Botje> Znudzon: the documentation says the bench function is in Criterion.Main
16:12:37 <copumpkin> Eduard_Munteanu: sure it is
16:12:44 <copumpkin> data Foo = forall a. Foo a
16:12:57 <copumpkin> it's effectively ()
16:13:02 <Eduard_Munteanu> I'm making a datatype that contains STRefs. But STRefs have kind * -> * -> *, they take a state type.
16:13:11 <Eduard_Munteanu> I'd like that to be abstracted away.
16:13:31 <Eduard_Munteanu> Like data Foo a = forall s => STRef s a
16:13:34 <copumpkin> sure, but it might be tricky with ST
16:13:35 <Eduard_Munteanu> um sorry
16:13:40 <Eduard_Munteanu> Like data Foo a = forall s => Foo (STRef s a)
16:13:45 <copumpkin> you need a period there
16:13:48 <copumpkin> => introduces constraints
16:14:01 <ddarius> prop_Specification
16:14:09 <Eduard_Munteanu> copumpkin: 'forall s. =>' doesn't work
16:14:16 <copumpkin> Eduard_Munteanu: I wrote what it is :P
16:14:23 <copumpkin> forall a. Foo a
16:14:33 <copumpkin> => introduces constraints
16:14:35 * Eduard_Munteanu tries that, but remembers having no success..
16:14:45 <copumpkin> no, that is the syntax :P
16:14:50 <Eduard_Munteanu> Ah, thanks. It worked.
16:14:54 <copumpkin> but beware
16:14:57 <Eduard_Munteanu> I'm not sure what I did when it didn't.
16:15:10 <copumpkin> existential variables don't unify with anything else
16:15:29 <Eduard_Munteanu> But so long 's' is polymorphic there and I don't actually specify it, it should work with ST, right?
16:15:32 <copumpkin> so you might not be able to make ST work as you'd like
16:15:38 <Eduard_Munteanu> All my functions are like ... -> ST s ...
16:15:41 <mauke> prepare for explodey heads
16:16:02 <Eduard_Munteanu> I never understood why ST wanted that type parameter :/
16:16:10 <copumpkin> you might want Foo (forall s. ST s a)
16:16:10 <Znudzon> Botje: yes i know I've imported Criterion.Main ... i use a lot examples from web and i've always have the same problem
16:16:23 <copumpkin> Eduard_Munteanu: that's what stops you from doing bad things with it
16:16:36 <Eduard_Munteanu> copumpkin: I actually want STRefs, not ST.
16:16:52 <Botje> Znudzon: are you using ghc to compile or ghci to run your code interactively?
16:17:13 <Botje> Eduard_Munteanu: that type parameter is to prevent ST stuff from 'escaping'
16:17:18 <Eduard_Munteanu> copumpkin: basically I'm making a tree with STRefs.
16:17:18 <copumpkin> an existential won't really behave the way you want it there
16:17:20 <copumpkin> you probably want a forall
16:17:31 <roconnor> wharzl: back
16:17:40 <mauke> you probably don't want STRefs
16:17:46 <copumpkin> or what mauke said
16:18:00 <Znudzon> Botje: GHC to compile 
16:18:06 <Eduard_Munteanu> Why use IORefs if the caller might do well enough with ST?
16:18:10 <Botje> Znudzon: are you doing ghc --make ?
16:18:31 <mauke> Eduard_Munteanu: because you don't want the s parameter for some reason
16:18:37 <Znudzon> Botje: Yes. Is it wrong ?
16:18:38 <Eduard_Munteanu> Botje: yeah, but how does IO work then?
16:18:50 <Botje> Eduard_Munteanu: IO doesn't care :)
16:19:07 <Eduard_Munteanu> I don't really get the 's' there. 's' is RealWorld anyway.
16:19:16 <mauke> Eduard_Munteanu: no, s is unspecified
16:19:17 <Eduard_Munteanu> It's not like it changes.
16:19:20 <monochrom> Eduard_Munteanu: I recommend keeping s as a parameter of your type. data Foo s a = Foo (STRef s a)
16:19:21 <Eduard_Munteanu> Yeah, I know.
16:19:24 <roconnor> Eduard_Munteanu: phantom type
16:19:37 <Botje> Znudzon: no, it should be like that. so you are importing Criterion.Main and it can't find bench?
16:19:37 <Eduard_Munteanu> But isn't it always RealWorld in GHC?
16:19:41 <mauke> it's not like RealWorld exists
16:19:48 <roconnor> Eduard_Munteanu: not really
16:19:57 <Eduard_Munteanu> :t stToIO
16:19:58 <lambdabot> Not in scope: `stToIO'
16:20:03 <roconnor> Eduard_Munteanu: well maybe
16:20:22 <roconnor> Eduard_Munteanu: of course, RealWorld is a huge hack in GHC
16:20:22 <Znudzon> Botje: Yes... hmm and i don't know why. 
16:21:21 <Eduard_Munteanu> I think it's really ugly to show to the outside world (i.e. users of this API) that we use ST inside.
16:21:24 <Botje> Znudzon: that's weird
16:21:36 <aristid> :t runST
16:21:37 <lambdabot> forall a. (forall s. ST s a) -> a
16:21:53 <aristid> Eduard_Munteanu: you don't need to show ST to the outside, right?
16:21:57 <Bynbo7> > runST $ newArray (minBound, maxBound :: Int) (0 :: Int)
16:21:58 <lambdabot>   Not in scope: `newArray'
16:21:58 <roconnor> Eduard_Munteanu: is the alternative to show to the outside world that you use IO?
16:22:01 <Bynbo7> weak
16:22:12 <Znudzon> Botje: I know. This is the reason that i write here :D 
16:22:13 <Eduard_Munteanu> (I admit it wasn't the best point to make)
16:22:51 <Eduard_Munteanu> aristid: well this is mainly about the datatype, I know I'll need ST and 's' in functions.
16:23:01 <Botje> @seen bos
16:23:01 <preflex>  bos was last seen on #haskell 4 days, 31 minutes and 48 seconds ago, saying: @hoogle liftIO
16:23:01 <lambdabot> Unknown command, try @list
16:23:27 <Botje> Znudzon: make sure you have the latest version of criterion, if that fails you should @tell bos
16:23:27 <aristid> @hoogle liftIO
16:23:27 <lambdabot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
16:23:51 <Eduard_Munteanu> But why wouldn't an existential / rank-2 be able to hide that 's' in there? Doesn't ST get to choose 's' then?
16:25:21 <roconnor> Eduard_Munteanu: existential is no good. You want to make sure that when you bind two ST commands the phantom types align
16:25:30 <Znudzon> Botje: Ok. And after that i will reinstall GHC and Criterion . Maybe this will help :) Thanks for help
16:25:55 <Eduard_Munteanu> Oh.
16:26:40 <Botje> Znudzon: have you tested it with the simplest possible code?
16:26:59 <Botje> Znudzon: import Criterion.Main\n foo = bench \n main = return ()
16:28:34 <Znudzon> Botje: I've tested it with code from haskell.org
16:28:57 <Botje> Znudzon: do it with the simplest possible code, like i showed above
16:29:32 <ddarius> One relatively simple helper function and then a simple foldr and I should be done.
16:31:08 <roconnor> is polymorphic runST only neccessary for safety in the presence of existential types?
16:31:16 <Eduard_Munteanu> So isn't there a newtype or some other trick I can use to hide that 's'? I'm sure it can be done with CPP :)
16:31:39 <roconnor> Eduard_Munteanu: I don't understand your motivation :)
16:32:54 <Eduard_Munteanu> Well, are there any other libs that do that? I mean, besides ST, who says "leave this thing polymorphic"?
16:33:16 <ddarius> roconnor: Existential types weren't available in anything but HBC when ST was introduced.
16:33:18 <Eduard_Munteanu> Or maybe I could make myself a special monad for that tree?
16:33:33 <ddarius> Eduard_Munteanu: There are several libraries that do exactly the same thing as ST.
16:33:40 <aristid> Eduard_Munteanu: data STG a = forall s. ST s a ?
16:33:46 <roconnor> Eduard_Munteanu: I would imagine every other library leaves the s exposed
16:34:02 <Znudzon> Botje: I tryed your example and it crashed. I can't even close proces. Something strange goes with my system :/ 
16:34:02 <aristid> ddarius: what is HBC?
16:34:08 <Eduard_Munteanu> aristid: something like that.
16:34:30 <roconnor> ddarius: was runST rank-2 when ST was introduced?
16:34:54 <ion> I get how vector-space makes Num b  (ab) an instance of Num, so (sin^2) n becomes possible, but why does that result in 42 "foo" returning 42?
16:35:00 <Eduard_Munteanu> Though I'm mainly interested in STRefs, like have a data Foo a b = forall s. Baz a | Bar (STRef s b)
16:35:14 <Botje> Znudzon: crashed? did it at least compile?
16:35:18 <mauke> ion: what else would it do?
16:35:20 <roconnor> @type newSTRef
16:35:21 <lambdabot> forall a s. a -> ST s (STRef s a)
16:35:27 <Botje> if it compiles then so should your bigger piece of code
16:35:33 <roconnor> l
16:35:37 <roconnor> oh right
16:35:38 <ddarius> "what is HBC?" was not a question I was expecting.
16:35:59 <ddarius> roconnor: Yes.  It was one of the motivating reasons for supporting rank-2 types.
16:36:02 <roconnor> Eduard_Munteanu: http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types#Example:_runST illustrates why runST needs to be rank-2
16:36:13 <roconnor> Example: Bad ST code
16:36:15 <roconnor>  let v = runST (newSTRef True)
16:36:16 <roconnor>  in runST (readSTRef v)
16:36:27 <megajosh2> http://hpaste.org/paste/42604/problems_loading_o_files_ann#p42608 Hey does anybody know how to use hs-plugins?
16:36:34 <aristid> ddarius: so you did not expect the question, fine. is it somehow wrong to ask questions?
16:36:50 <Eduard_Munteanu> roconnor: yeah, I get the rank-2 stuff in runST.
16:36:56 <ddarius> aristid: I don't know how you read a value judgement into what I said.
16:37:23 <conal> ion: there is a systematic way of turning *any* applicative functor into a num instance. and it includes fromInteger = pure . fromInteger.
16:37:34 <aristid> ddarius: well, you did not actually answer the question from what i see, that's where i saw a value judgment
16:37:37 <conal> ion: pure = const for functions.
16:38:08 <conal> ion: so 42 = fromInteger 42 = pure 42 = const 42
16:38:20 <conal> ion: and const 42 "foo" == 42
16:38:21 <aristid> > atan == sin
16:38:21 <lambdabot>   *Exception: (==): No overloading for function
16:38:45 <conal> @hackage applicative-numbers -- ion
16:38:45 <lambdabot> http://hackage.haskell.org/package/applicative-numbers -- ion
16:39:39 <conal> ion: more explanation and examples in http://conal.net/papers/beautiful-differentiation/
16:39:42 <roconnor> conal: presumably any algebra can be lifted to any applicative functor?
16:40:26 <conal> roconnor: hm. maybe. i think ralf hinze has a recent relevant paper
16:40:55 <aristid> so HBC is a defunct haskell compiler
16:40:56 <Eduard_Munteanu> :t runST
16:40:57 <lambdabot> forall a. (forall s. ST s a) -> a
16:41:10 <aristid> from 2004
16:41:12 <conal> roconnor: there are some tricky issues. some methods don't have flexible enough types.
16:41:39 <mauke> wasn't HBC the first haskell compiler?
16:41:48 <roconnor> conal: hmm, maybe only traversable functors
16:42:10 <aristid> mauke: i did not read a haskell history book, sorry
16:42:11 <roconnor> *algebras for traversable functors
16:42:29 <Eduard_Munteanu> So the idea is that the 'state' in STRef must match ST's state type, I guess?
16:42:57 <Eduard_Munteanu> But if any given implementation gets to choose the state, why is it polymorphic?
16:43:01 <djahandarie> I don't read the Haskell history books, the Haskell history books will become me!
16:43:02 <roconnor> Eduard_Munteanu: I don't usually think of the phantom variable as the state, but I guess you can.
16:43:15 <conal> ion: did that explanation make sense to you?
16:43:23 <Eduard_Munteanu> roconnor: well, I guess it's the internal representation of ST's store of refs.
16:43:37 <mauke> aristid: me neither, so I'm asking
16:43:56 <mauke> but augustss may have been involved in writing it
16:44:09 <Eduard_Munteanu> GHC makes it some RealWorld, but can they ever mismatch?
16:44:19 <aristid> mauke: yes it was, and yes augustss was involved. http://wiki.portal.chalmers.se/cse/pmwiki.php/FP/Haskell20years
16:44:19 <roconnor> Eduard_Munteanu: I usually think of it as a trick to ensure bad ST code doesn't type check
16:44:25 <ddarius> HBC was the first compiler and was pretty much completely written by Lennart.
16:44:38 <ddarius> It's also not defunct.
16:44:54 <ddarius> (Though admittedly that's -really- hard to tell.)
16:45:01 <ion> conal: Ah, thanks. My stumbling point was not understanding how an instance for the type ab affects 42 which is of type a. I failed to connect the dots to the implicit fromInteger for integer literals.
16:45:13 <aristid> ddarius: the newest version i found is from 2004. i call that defunct
16:45:26 <Eduard_Munteanu> roconnor: could you give an example? The only obvious thing I can think of is using stuff like 'ST Foo Bar' (i.e. not leaving 's' polymorphic), but that's really obvious.
16:45:49 <roconnor> an example of what?
16:46:03 <Eduard_Munteanu> roconnor: of 'bad ST code'
16:46:11 <roconnor> Example: Bad ST code
16:46:13 <roconnor>  let v = runST (newSTRef True)
16:46:14 <roconnor>  in runST (readSTRef v)
16:46:26 <Eduard_Munteanu> Hrm... /me thinks...
16:46:30 <aristid> roconnor: ah, to prevent STRefs to leak out?
16:46:30 <conal> ion: cool. and btw the 42 :: b, not a.
16:46:33 <ddarius> aristid: Everyone thought HBC had been dead for years when suddenly a Haskell 98 version popped up out of the blue.
16:46:36 <roconnor> aristid: yes
16:47:05 <roconnor> there is probably a better way to make sense of this trick in terms of naturality, but I don't know it.
16:47:26 <ion> conal: I meant a completely different a, not the a from the previous type. :-)
16:47:49 <aristid> @index runST
16:47:50 <lambdabot> Control.Monad.ST.Lazy, Control.Monad.ST, Control.Monad.ST.Strict
16:47:51 <conal> ah
16:48:23 <Eduard_Munteanu> :t newSTRef
16:48:25 <lambdabot> forall a s. a -> ST s (STRef s a)
16:48:47 <aristid> @index STRef
16:48:48 <lambdabot> Data.STRef, Data.STRef.Lazy, Data.STRef.Strict
16:49:03 <ddarius> > case 1 `div` 0 of x -> x
16:49:04 <lambdabot>   *Exception: divide by zero
16:49:08 <ddarius> > case 1 `div` 0 of x -> ()
16:49:09 <lambdabot>   ()
16:49:16 <ddarius> > case 1 `div` 0 of !x -> ()
16:49:17 <lambdabot>   *Exception: divide by zero
16:49:41 <ddarius> > let !x = 1 `div` 0 in ()
16:49:42 <lambdabot>   *Exception: divide by zero
16:50:07 <aristid> roconnor: it's a very neat trick, actually
16:50:11 <ion> :t 42
16:50:11 <lambdabot> forall t. (Num t) => t
16:50:29 <monochrom> runST ensures that you can't just set s=RealWorld
16:50:34 <Eduard_Munteanu> So the badness is reusing the STRef in a context where it's no longer valid, I guess.
16:51:11 <revenantphx> One thing I always wonder...
16:51:12 <aristid> Eduard_Munteanu: yea, and that's completely prevented by the phantom type
16:51:20 <c_wraith> well.  really, the badness is having any ST mutable cell returned by the runST call.
16:51:20 <ion> :t fromInteger 42 :: Num (a->b)
16:51:21 <lambdabot>     Class `Num' used as a type
16:51:21 <lambdabot>     In an expression type signature: Num (a -> b)
16:51:21 <lambdabot>     In the expression: fromInteger 42 :: Num (a -> b)
16:51:23 <revenantphx> if say you have some kind of infinite sequence returning function
16:51:26 <revenantphx> like [1..]
16:51:28 <aristid> :t runST (newSTRef ())
16:51:29 <lambdabot>     Inferred type is less polymorphic than expected
16:51:29 <lambdabot>       Quantified type variable `s' escapes
16:51:29 <lambdabot>     In the first argument of `runST', namely `(newSTRef ())'
16:51:34 <ion> :t fromInteger 42 :: (a->b)
16:51:34 <lambdabot>     Could not deduce (Num b) from the context ()
16:51:35 <lambdabot>       arising from a use of `fromInteger' at <interactive>:1:0-13
16:51:35 <lambdabot>     Possible fix:
16:51:39 <revenantphx> Is it possible for it to calculate the values of indices 50 through 100, without 0-50?
16:51:50 <revenantphx> (for a more complex example, like prng)
16:51:53 <copumpkin> > [50..100]
16:51:54 <lambdabot>   [50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74...
16:51:59 <revenantphx> No no, that's not what I mean :|
16:52:02 <monochrom> kind of no, you have to at least go through lots of cons cells
16:52:10 <c_wraith> revenantphx, possibly.  It depends on if the values depend on previous values
16:52:14 <ion> Is it intentional that :t doesnt work in private? Id rather experiment without flooding the channel. :-)
16:52:16 <revenantphx> Yeah...
16:52:23 <revenantphx> I'm just wondering about rng stuff.
16:52:23 <aristid> ion: use @type in private
16:52:24 <mauke> ion: @ty
16:52:27 <ion> Thanks
16:52:30 <c_wraith> and as monochrom points out, you have to go through the cons cells, in any case.
16:52:43 <Eduard_Munteanu> < aristid> Eduard_Munteanu: data STG a = forall s. ST s a ?     -- /me thinks if this wouldn't prevent it...
16:52:46 <invarius> Okay, I need suggestions. In reading my dictionary(construction of one), should I  parse whatever the random text is for whitespaces; cut any word after a whitespace to a newline, compare F_{n-1} to F_{n}; move the greater value of F_{n} above or below..? Or should I cut it all first then go through and sort it all alphabetically?
16:52:50 <revenantphx> I'm kind of annoyed with this enumerator code...
16:53:00 <revenantphx> It works, but theres a redundant parameter I can't figure out how to remove.
16:53:19 <revenantphx> It's "needed" but there could (?) be a way to remove it.
16:53:34 <roconnor> Eduard_Munteanu: that wouldn't prevent it I don't think
16:53:56 <copumpkin> realWorld#
16:54:03 <revenantphx> https://gist.github.com/756748
16:54:10 <revenantphx> If anyone sees anything, do tell me.
16:54:27 <revenantphx> the issue is how repeatI requires the same param twice.
16:54:32 <revenantphx> (well not quite)
16:55:46 <Eduard_Munteanu> However, if I design my STRef-containing type as a monad and don't expose ST at all, then I guess I can hide that 's', right?
16:56:03 <revenantphx> That 's' will follow you forever.
16:56:09 <revenantphx> Forever... forever... forever...
16:56:10 <monochrom> word
16:56:20 <Eduard_Munteanu> "Haunt" is the proper term :)
16:56:31 <revenantphx> The ST 's' is the world's most clingy stalker.
16:56:39 <revenantphx> s is for stalker, in case you were wondering.
16:56:42 <Eduard_Munteanu> :))
16:56:58 <aristid> and you can't escape from the stalker
16:57:03 <monochrom> STicky STalker
16:57:10 <roconnor>  I doubt you can hide it, and I don't really see why you want to.
16:57:17 <aristid> there should be a movie about ST
16:57:18 <megajosh2> http://hpaste.org/paste/42604/problems_loading_o_files_ann#p42608 Does anybody know how to use hs-plugins? I'm trying to load some code dynamically and I get some weird errors
16:57:28 <revenantphx> Hrmbl.
16:57:32 <revenantphx> Peppermint Cheesecake.
16:57:33 <revenantphx> Yum
16:57:40 <Eduard_Munteanu> Well for my actual application it isn't much... but it would be really sucky if you couldn't abstract using ST behind the scenes.
16:57:58 <ddarius> That sounds like an abuse of cheesecake.
16:58:34 <monochrom> depends on what you mean by those natural language words
16:58:35 <aristid> Eduard_Munteanu: you can abstract it by using runST :P
16:59:09 <ddarius> Eduard_Munteanu: You can't hide the s.
16:59:12 <Eduard_Munteanu> Even if I do, those STRefs still carry an ugly 's' :)
16:59:52 <roconnor> Eduard_Munteanu: I don't know.  If you wrap up the polymorphic type with a forall (instead of an existential) that might work.
16:59:54 <aristid> Eduard_Munteanu: no, the STRefs cannot leak through runST at all
16:59:59 <Saizan> exactly, you can abstract over the use of ST if you also don't need to pass STRef through your API
17:00:14 <ddarius> prop_Specification p xs ys ~> True
17:00:15 * hackagebot xmonad 0.9.2 - A tiling window manager  http://hackage.haskell.org/package/xmonad-0.9.2 (AdamVogt)
17:00:17 * hackagebot xmonad-contrib 0.9.2 - Third party extensions for xmonad  http://hackage.haskell.org/package/xmonad-contrib-0.9.2 (AdamVogt)
17:00:19 <aristid> Saizan: and if you don't need to pass STRef, you can use runST
17:00:25 <Eduard_Munteanu> Yeah, I mean what Saizan said.
17:02:12 <Eduard_Munteanu> Anyway, thanks. I'll probably add an 's' to my mutable tree type.
17:02:51 <ddarius> Now to see if this code actually produces any benefit.
17:03:12 <roconnor> Eduard_Munteanu: test out using a forall type
17:03:34 <ddarius> @hackage criterion
17:03:35 <lambdabot> http://hackage.haskell.org/package/criterion
17:03:39 <Eduard_Munteanu> roconnor: I'm not sure what you mean by a 'forall instead of an existential'.
17:05:41 <Eduard_Munteanu> My datatype is 'data MutTree a b = <something in terms of 'MutRef a b'> where type MutRef a b = forall s. STRef s (MutTree a b)', or that's what I'm thinking of trying.
17:05:48 * Eduard_Munteanu lemme see...
17:06:15 * roconnor works on a paste
17:06:55 <gwern> @eval 1+1
17:07:04 * Bynbo7 licks some paste
17:08:18 <Eduard_Munteanu> http://paste.pocoo.org/show/310630/
17:08:40 <Eduard_Munteanu> This seems to be working so far, except it can't derive Show, but it's okay.
17:08:58 <revenantphx> You can implement Show yourself no?
17:09:02 <revenantphx> Might be better for a tree anyhow.
17:09:50 <Eduard_Munteanu> Yeah.
17:10:26 <Eduard_Munteanu> Illegal polymorphic or qualified type: MutRef a b    Perhaps you intended to use -XImpredicativeTypes   In the type signature for `getRef':  getRef :: MutTree a b -> ST s (MutRef a b)
17:10:28 <roconnor> Eduard_Munteanu: that doesn't look like it will be useful  You won't be able to build anything of this type I expect
17:10:35 <Eduard_Munteanu> Seems so ^
17:11:11 <aristid> Eduard_Munteanu: maybe you should just expose the s
17:11:17 <aristid> expose the stalker
17:11:24 <Eduard_Munteanu> Yeah, I guess so.
17:11:42 <deech> Hi all, I'm reading through "Purely Functional Datastructures" and a number of the structures say that "so-and-so-structure is great if persistence is not required". I thought all purely functional data structures were persistent, so what does this mean?
17:11:49 <Eduard_Munteanu> (It's still better than using IO there)
17:12:06 <sipa> deech: can you give an example?
17:12:26 <Bynbo7> deech: i think it means that things play well with the garbage collector... possibly
17:12:28 <mauke> deech: it means it's slow if you make use of persistence
17:12:32 <mauke> Bynbo7: no
17:12:37 <Bynbo7> or not
17:13:08 <deech> sipa : For example, chapter 5.2 on Queues. See the note to the practioner on pg.44.
17:13:47 <roconnor> Eduard_Munteanu: http://hpaste.org/42611/abstracting_st
17:14:58 <roconnor> Eduard_Munteanu: as long as you don't have STRefs as part of your interface, you should be good to go.
17:15:06 <ddarius> deech: The question is whether you'll use old versions or not.  You -can- use old versions for any structure but you may lose the performance guarantees then.
17:15:18 <deech> mauke: Is there some way to determine that by looking at the implementation? Later on in 6.5 he says that Lazy Pairing Heaps are better for persistence and I can't see why.
17:15:53 <mauke> I only have general comments
17:16:07 <mauke> lazy data structures rely on amortized bounds
17:16:18 <ddarius> deech: Consider a queue represented as a pair where you enqueue in one list and dequeue from the other until it's empty, at which point you move the enqueue list to the dequeue list reversing it.
17:16:35 <deech> ddarius: yes
17:16:35 <mauke> amortized costs mean you accumulate a bunch of O(1) operations and then do one O(n) operation
17:17:00 <mauke> persistence means you can repeat the expensive O(n) operation as often as you want
17:17:03 <ddarius> deech: In a singe-threaded usage, this is amortized constant time for enqueue and dequeue.  However, if you repeatedly use a version just before the dequeue list runs out, it will be O(length enqueue) each time.
17:17:08 <Eduard_Munteanu> roconnor: thanks.
17:17:15 <mauke> thus destroying your runtime cost analysis
17:17:16 <roconnor> Eduard_Munteanu: as long as you don't have STRefs *or any data holding STRefs* as part of your interface, you should be good to go.
17:18:05 <monochrom> At some point you have q = ("", "xyz") for example. Next time you tail, you spend 3 steps to get q' = ("zy", ""). If you go back to q and tail again, you spend 3 steps again to get a new copy of ("zy", ""), rather than reuse q'. Using old versions means repeating calculations.
17:18:11 <aristid> roconnor: but he seems to have that
17:18:22 <roconnor> aristid: I haven't seen his interface
17:18:37 <Eduard_Munteanu> roconnor: grr... I kinda need to hold STRefs in my datatype.
17:18:46 <deech> ddarius, mauke: I get it! That was pretty cool double-teaming. Are you the same person? :)
17:18:49 <Eduard_Munteanu> And callers do live in ST.
17:19:00 <roconnor> Eduard_Munteanu: well what is to prevent the Bad ST code from happening with your abstracted monad?
17:19:02 <mauke> deech: no, but I'm actually you!
17:19:02 <blackdog> how do you access constants in a C header using the FFI? am trying to get rid of C2HS
17:19:20 <aristid> Eduard_Munteanu: expose the s! expose the s! :)
17:19:21 * hackagebot Crypto 4.2.3 - Collects together existing Haskell cryptographic functions into a package  http://hackage.haskell.org/package/Crypto-4.2.3 (CreightonHogg)
17:19:41 <mauke> blackdog: use a tool like hsc2hs
17:20:14 <deech> mauke: So anytime you have a bottle-neck in your datastructure (like the reverse op) it's bad for persistence. Is that right?
17:20:31 <Eduard_Munteanu> roconnor: I guess that 's'. I'll just expose the 's' for now, like aristid says :)
17:20:32 <mauke> yeah, basically
17:20:38 <gwern> 'mauke> persistence means you can repeat the expensive O(n) operation as often as you want' <-- ouch
17:20:48 <roconnor> Eduard_Munteanu: your users will thank you
17:20:52 <mauke> the solution is laziness
17:21:22 <deech> mauke: so do Okasaki's warnings about persistence apply to Haskell?
17:21:23 <Eduard_Munteanu> Anyway, I'd dislike imposing the IO monad in that interface more.
17:21:25 <mauke> if you manage to push the expensive operation into a thunk, you win
17:21:35 <mauke> deech: yes
17:21:40 <ddarius> deech: They apply to any language.
17:21:53 <Eduard_Munteanu> (though with IO, all those 's'-es would be gone)
17:22:14 <roconnor> IO / s what's the difference
17:22:17 <deech> Right, because you still have to do the reverse operation sometime.
17:22:19 <monochrom> the 5.2 queue is written to not benefit from laziness
17:22:25 <Eduard_Munteanu> Just checking... IO is safe because there's no (safe) IO equivalent of runST, right?
17:22:36 <deech> Laziness just pushes it off.
17:22:43 <Eduard_Munteanu> s/is safe/needs such an 's'/
17:22:44 <blackdog> mauke: ah, that's right. so i still need hsc2hs installed on the client machine.
17:23:19 <monochrom> chapters 6 and 7 use laziness
17:23:45 <aristid> Eduard_Munteanu: the uniqueness of main is your s :)
17:23:45 <ddarius> deech: Part of the punch line of Okasaki's papers is that for pure implementations of data structures a careful -mixture- of eagerness and laziness is necessary.
17:24:15 <Eduard_Munteanu> Yeah.
17:24:30 <monochrom> laziness is your mutable cell
17:24:51 <deech> monochrom: Whow, can you elaborate?
17:25:02 <monochrom> chapters 6 and 7 will
17:25:14 <roconnor> Eduard_Munteanu: correct
17:25:16 <Eduard_Munteanu> monochrom: you go make me a structurally mutable and pure tree with backlinks :P
17:25:22 <Eduard_Munteanu> using only laziness.
17:25:26 <deech> monochrom: Cool. I think something just clicked when you said that, I just don't know what.
17:25:47 <Eduard_Munteanu> This stuff is killing me.
17:26:15 <Eduard_Munteanu> Don't worry, won't give in to "just write it in C".
17:26:16 <monochrom> also a glimpse of it in Bird et al.'s paper "more haste, less speed: lazy versus eager evaluation"
17:26:18 <deech> Eduard_Munteanu: Does this fit the bill? http://www.haskell.org/haskellwiki/Tying_the_Knot
17:26:23 <roconnor> Eduard_Munteanu: why would you want to make it mutable?
17:26:43 <Eduard_Munteanu> deech: there is NO way I'm doing that for those trees. It already made me go nuts with lists.
17:27:07 <deech> Eduard_Munteanu: I didn't say it was the friendliest implementation :)
17:27:14 <Eduard_Munteanu> roconnor: there's this assignment I have that entails implementing adaptive Huffman coding.
17:27:27 <deech> Eduard_Munteanu: I still don't get it. I re-try every few months or so.
17:27:32 <roconnor> Eduard_Munteanu: I see no reason to use mutable structures for that :D
17:27:52 * roconnor googles adaptive huffman coding
17:28:11 <Eduard_Munteanu> roconnor: well the main reasons are (1) I don't want to depart too much from the original algo description and (2) I don't know how to do it otherwise :)
17:28:24 <roconnor> (2) is where the fun is!
17:28:41 <roconnor> why are you writing it in Haskell?
17:29:00 <Eduard_Munteanu> roconnor: erm, because I thought it would be fun? :)
17:29:06 <roconnor> hence (2)
17:29:08 <roconnor> :)
17:29:14 <deech> Eduard_Munteanu: Ah the irony!
17:29:14 <Eduard_Munteanu> (It was kinda fun for Shannon-Fano and normal Huffman I already did)
17:29:28 <monochrom> translating imperative algorithms to haskell is not fun or educational
17:29:47 <roconnor> monochrom: well, not unless you make it purely functionall
17:29:49 <Eduard_Munteanu> monochrom: it's downright crazy at this moment, really.
17:29:56 <monochrom> it is still informative, in the sense "it informs you the pointlessness of such translations"
17:30:20 <monochrom> perhaps it's educational in that sense too
17:30:55 <monochrom> perhaps it's fun in that sense too, if you like discovering wastes of time as fun
17:31:07 <roconnor> Eduard_Munteanu: what is the point of backlinks in the tree?
17:31:12 <Eduard_Munteanu> roconnor: I'm really clueless how to move and swap those subtrees around without mutability. I'm also memoizing the leaves of the tree, which doesn't work well with zippers.
17:31:44 <Eduard_Munteanu> roconnor: I figure I should keep a map of the leaves so I don't look them up every time. I can't really use zippers there, hence backlinks for navigating.
17:32:19 <roconnor> what does it mean to memoize the leaves of a tree?
17:33:15 <Eduard_Munteanu> roconnor: keeping a map <symbol -> tree leaf>. That way I don't need to traverse the tree every time to look up a symbol's associated tree node.
17:33:34 <Eduard_Munteanu> (symbols always reside on leaves)
17:34:27 <c_wraith> Eduard_Munteanu, how are you keeping that map such that it's more efficient than traversing the tree?
17:35:06 <Eduard_Munteanu> c_wraith: Data.Map. I'm not sure there's a O(log n) way of searching the tree for a symbol, and this looked handy.
17:35:31 <roconnor> the huffman tree isn't balanced?
17:36:11 <Eduard_Munteanu> roconnor: it's shape / ordering relates to frequency, not symbol value, so that's the problem I suppose.
17:36:15 <Eduard_Munteanu> *its
17:37:00 <roconnor> interesting problem
17:37:24 <Eduard_Munteanu> Hm, as a matter of fact, I suppose I could keep a symbol <-> frequency map, and try to narrow it down by frequency first.
17:38:31 <Eduard_Munteanu> roconnor: other people said that the other day too :)
17:39:00 <roconnor> this Vitter algorithm is the one you are implementing?
17:39:23 <Eduard_Munteanu> roconnor: I think it's Vitter's, not FGK. But I'm not 100% sure.
17:39:59 <Eduard_Munteanu> There are variations in the exact procedure.
17:40:15 <roconnor> I don't quite get why you need this map from symbols to leaves.
17:41:28 <roconnor> oh wait
17:41:39 <Eduard_Munteanu> roconnor: you read a symbol from the stream. Then you have to lookup its associated tree node (actually a leaf, always) to update the tree.
17:42:16 <roconnor> but in order to read a symbol haven't you traversed the tree and you are at the leaf?
17:42:19 <Eduard_Munteanu> (And my instructor is really clueless about Haskell, which is why I don't want to depart too much from the original algo)
17:42:25 <roconnor> Ah
17:42:31 <roconnor> well, not much I can do about that
17:43:10 <blackdog> ah, fun. the ruby interpreter thinks that True and False are different types.
17:43:14 <Eduard_Munteanu> roconnor: you read the symbol from the stream you want to compress. You don't have the tree completely built beforehand.
17:43:14 <blackdog> *grumble*
17:43:27 <Eduard_Munteanu> You continuously update it as you read more.
17:43:42 <roconnor> oh
17:43:55 <Eduard_Munteanu> (unlike Shannon-Fano / normal Huffman, where you build the tree based on a frequency table)
17:45:24 <sipa> cabac!
17:46:45 <ddarius> blackdog: They should be different types but subtypes of the same supertype.
17:46:47 <roconnor> interesting problem
17:47:01 <Eduard_Munteanu> I think I could give up on this map thingy for now, and think about optimizing it later. Zippers are too luring not to use :)
17:47:23 <blackdog> ddarius: ... you're pulling my chain, right?
17:47:50 <Eduard_Munteanu> Although there are difficult problems there too... like how to swap two subtrees with zippers efficiently.
17:48:04 <blackdog> as it stands, they're just different primitive types. T_INT, T_STRING, T_FALSE, T_TRUE...
17:48:18 <blackdog> (whoops, T_FIXNUM, not T_INT)
17:50:36 <ddarius> abstract class Bool { public abstract A If<A>(A t, A e); }; class True : Bool { public True(){}; public override A If<A>(A t, A e) { return t; } }; class False : Bool { public False(){}; public override A If<A>(A t, A e) { return e; } }
17:53:36 <roconnor> Eduard_Munteanu: I understand your design now
17:54:19 <Eduard_Munteanu> roconnor: any insight/criticism?
17:54:44 <roconnor> Eduard_Munteanu: I can't immediately think of anything better that is as efficent
17:55:41 <roconnor> Eduard_Munteanu: though I think you can still abstract away the s variable from your interface
17:55:53 <Eduard_Munteanu> Ah, I think I'll screw efficiency for now, I'm mostly competing with really screwy Matlab implementations.
17:56:20 <Eduard_Munteanu> Yeah, though I think I'll backtrack a bit and use zippers atm.
17:56:21 <roconnor> Eduard_Munteanu: it will be simpler if you echew efficentcy
17:56:44 <Eduard_Munteanu> (at least they're more pleasant / interesting to work with)
17:57:29 * ddarius suspects he's getting fusion for the simpler loop (and by "suspects" he means "is pretty damn confident.)
17:57:39 <Eduard_Munteanu> Thanks for the advice though.
17:58:50 <Eduard_Munteanu> ddarius: btw, can you tell that from some sort of profiling?
17:58:52 <roconnor> ddarius: who is he?
17:59:02 <djahandarie> himself...
17:59:06 <roconnor> ah
17:59:12 <roconnor> makes sense
17:59:15 <Eduard_Munteanu> :)
18:00:19 <ddarius> Eduard_Munteanu: You probably could especially if all allocation is eliminated, but it'd be easier and more direct to see what rules fired and to look at the core.
18:01:10 <tswett> :t join id
18:01:11 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a)
18:01:12 <lambdabot>     Probable cause: `id' is applied to too few arguments
18:01:12 <lambdabot>     In the first argument of `join', namely `id'
18:01:16 <tswett> Alas.
18:01:36 <Eduard_Munteanu> Ah.
18:04:25 * ddarius sees if force will break the fusion.
18:07:33 <Eduard_Munteanu> Do impredicative types specifically refer to rank-2/N types used as arguments to type functions?
18:08:02 <ddarius> It refers to instantiating a polymorphic type to a polymorphic type.
18:08:29 <ddarius> (or rather instantiating a type variable to a polymorphic type)
18:09:11 <Eduard_Munteanu> ddarius: yeah, type variable makes sense. Because I'm seeing examples of (forall a. a -> a) -> ... vs Maybe (forall a. a -> a) -> ...
18:09:38 <Eduard_Munteanu> So I wondered where the difference between that and rank-N lies.
18:10:28 <Eduard_Munteanu> Could I assume -XImpredicativeTypes subsumes -XRankNTypes, at least logically?
18:10:51 <blackdog> ddarius: i understand that you could model true and false that way. i can't see a reasonable motivation.
18:11:40 <ddarius> blackdog: It's rather the natural "OO" way to represent it (or at least the OO way of encoding algebraic data types.)  Smalltalk does this (but then brutalizes it.)
18:11:50 <ddarius> (Self does this as well without the brutalization.)
18:12:16 <tswett> ddarius: the OO way to represent what?
18:25:52 <dolio> Eduard_Munteanu: GHC does some impredicative stuff even without the flag for it.
18:26:02 <dolio> When the variables are used only with (->)
18:26:45 <dolio> (forall a. a -> a) can be instantiated to (forall b. b) -> (forall b. b), for instance.
18:27:01 <dolio> That is impredicative instantiation, but it doesn't require the flag for impredicative types.
18:29:47 <aristid> dolio: (forall b. b) -> (forall b. b) looks totally incompatible with (forall a. a -> a)
18:29:57 <dolio> Set a = (forall b. b)
18:30:59 <aristid> :t undefined :: (forall b. b) -> (forall b. b)
18:31:00 <lambdabot> forall b. (forall b1. b1) -> b
18:31:17 <aristid> :t undefined :: (forall b. b) -> (forall c. c)
18:31:18 <lambdabot> forall c. (forall b. b) -> c
18:31:24 <copumpkin> (they're equivalent)
18:31:38 <aristid> :t undefined :: (forall b. b -> b)
18:31:39 <lambdabot> forall b. b -> b
18:31:58 <aristid> :t [undefined :: (forall b. b -> b), undefined :: (forall b. b) -> (forall b. b)]
18:31:58 <lambdabot>     Cannot match a monotype with `forall b. b'
18:31:59 <lambdabot>       Expected type: b
18:31:59 <lambdabot>       Inferred type: forall b1. b1
18:32:03 <dolio> Anyhow, I don't really understand why GHC allows that, but not other impredicativity. But it does.
18:32:17 <aristid> dolio: it does not seem to work with lambdabot
18:32:29 <copumpkin> I had just written it off as (->) being special-cased
18:32:31 <dolio> :t id
18:32:32 <lambdabot> forall a. a -> a
18:32:41 <dolio> :t (id :: (forall b. b) -> (forall b. b))
18:32:42 <lambdabot> forall b. (forall b1. b1) -> b
18:33:11 <aristid> dolio: ok, this does make sense in a twisted way
18:33:24 <Eduard_Munteanu> dolio: ah, thanks.
18:34:06 <ddarius> :t undefined :: Maybe (forall a. a)
18:34:07 <lambdabot>     Illegal polymorphic or qualified type: forall a. a
18:34:07 <lambdabot>     Perhaps you intended to use -XImpredicativeTypes
18:34:08 <lambdabot>     In an expression type signature: Maybe (forall a. a)
18:35:12 <ddarius> dolio: Either (->) is a normal type constructor, and thus -any- higher rank type would require impredicativity, or (->) is not a normal type constructor and thus the restrictions don't apply to it.
18:35:51 <aristid> i guess (->) is not a normal type constructor then
18:36:09 <dolio> Well, I suppose that's the answer.
18:36:52 <dolio> However, the oddity is that polymorphic types are always behave impredicatively for the purposes of instantiation.
18:37:13 <tswett> @index isSpace
18:37:13 <lambdabot> Data.Char
18:37:15 <dolio> It's only application of higher-kinded types that requires the flag.
18:37:55 <dolio> In 'forall (a :: *) ....', that * impredicatively includes types with quantifiers.
18:38:07 <dolio> But in 'Maybe :: * -> *', that first * does not.
18:38:07 <Eduard_Munteanu> What does "impredicative" mean, really?
18:38:49 <roconnor> Eduard_Munteanu: something defined in terms of itself
18:40:35 <copumpkin> @src filterM
18:40:36 <lambdabot> Source not found. I am sorry.
18:40:36 <Eduard_Munteanu> So I guess here it refers to quantification being imposed at the same level?
18:40:42 <dolio> (forall a. a -> a) is defining a type by referring to the entirety of types.
18:40:52 <dolio> It quantifies over *, and inhabits *.
18:40:59 <Eduard_Munteanu> Ah.
18:41:44 <dolio> In a predicative type theory, that 'a' would not range over the collection of types that the type as a whole inhabits.
18:42:15 <dolio> In Hindley-Milner, such a variable ranges over monotypes, like Int and Int -> Int, but not (forall a. a)
18:42:39 <aristid> dolio: except if the constructor is (->)?
18:42:56 <dolio> No, period.
18:42:57 <aristid> or is that a GHC extension over Hindley-Milner already?
18:43:01 <Eduard_Munteanu> Hm, yeah, but in HM here, predicativity seems to imply rank-1 exclusively.
18:43:12 <dolio> GHC is playing fast and loose.
18:44:49 <roconnor> now I want someone smart to implement this Vitter algorithm purely.  It is quite a puzzle.
18:45:38 <dolio> In something like Agda, you can quantify over Set, the universe of all types, but it ends up in the universe Set1.
18:45:49 <Eduard_Munteanu> Heh, this problem drags other people into it :)
18:45:52 <dolio> (forall (a : Set) -> a -> a) : Set1
18:46:32 <dolio> So again there, a does not range over types with quantifiers.
18:46:45 <dolio> Because they inhabit Set1.
18:47:08 <dolio> And if you instead do (forall (a : Set1) -> a -> a), that inhabits Set2.
18:47:30 <dolio> And so on.
18:47:58 <revenantphx> One question...
18:48:13 <revenantphx> is there any haskell abstraction for taking some stream of input (network) and producing another (also network)
18:48:22 <revenantphx> Stateless and fast as hell is best :)
18:49:31 <Philippa> revenantphx: I think we call that a function :p
18:49:40 <revenantphx> XD
18:49:47 <revenantphx> (or an arrow, from what I've seen)
18:49:51 <Eduard_Munteanu> I think he means like 'interact' for network.
18:49:56 <revenantphx> But I'm looking for something specifically for streams of data
18:50:01 <revenantphx> For a proxy of sorts in this case.
18:50:02 <Mathnerd314> preflex: seen ndm
18:50:02 <preflex>  ndm was last seen on #haskell 8 days, 7 hours, 33 minutes and 47 seconds ago, saying: if you don't, then there was a parse error
18:50:08 <revenantphx> I'm looking to take one protocol in, and produce another.
18:50:18 <revenantphx> with one-for-one packet production.
18:51:10 <Philippa> so something you could throw inside the equivalent of interact . map
18:51:39 <ManateeLazyCat> unsafeCoerce will throw any exception if type mismatch?
18:51:44 <revenantphx> not quite Philippa 
18:51:48 <revenantphx> not dealing with strings, for oen.
18:51:49 <lispy> ManateeLazyCat: no
18:51:53 <revenantphx> binary protocols
18:52:02 <ManateeLazyCat> lispy: Hmmm
18:52:19 <Eduard_Munteanu> roconnor: I think ddarius alluded to some crazy zippers (like second derivative, or multiple focuses) that could be useful, but it's way too complex.
18:52:46 <Eduard_Munteanu> Assuming you're not reinventing the algorithm completely.
18:52:52 <lispy> ManateeLazyCat: it converts between any two types, but only at the type level.  The value's representation is not changed.  This can lead to segfault.
18:53:16 <ManateeLazyCat> lispy: Yes, that's i want to avoid.
18:53:31 <roconnor> Eduard_Munteanu: really Adaptive Huffman is a protocol, so any implementation that can interopreate with, say a C implementation on the other side should be fine.
18:53:34 <lispy> ManateeLazyCat: pretty simple, just don't import it :)
18:53:41 <ddarius> ManateeLazyCat: unsafeCoerce is definitely the most unsafe function available
18:53:54 <ManateeLazyCat> lispy: I'm hacking GHC API to dynamic loading library in runtime.
18:53:55 <Philippa> revenantphx: "equivalent of". Pick a sensible equivalence class, FFS
18:53:56 <roconnor> Eduard_Munteanu: doing it purely isn't so hard, as you know.  Doing it purely and efficenctly is the trick.
18:54:02 <Eduard_Munteanu> Yeah.
18:54:16 <revenantphx> Philippa: sorry >_>
18:54:20 <Philippa> (how does it differ /aside/ from "packet for packet"?)
18:54:27 <lispy> ManateeLazyCat: in that case, look at some of Don Stewart's work on dynamic loading.  He shows how to do so in a type safe manner.
18:54:30 <revenantphx> how does what differ?
18:54:42 <Philippa> your situation
18:54:47 <ManateeLazyCat> lispy: I have finish almost work, and i know how to avoid that.
18:54:52 <revenantphx> differ from what :|?
18:54:56 <revenantphx> I'm confused.
18:54:58 <Eduard_Munteanu> I'm not sure whether efficiency can be added as an after-thought, like doing extra work to ensure memoization or if you need to rework stuff completely.
18:54:58 <ManateeLazyCat> lispy: BTW, dons' book i read many many times. :)
18:55:13 <roconnor> Eduard_Munteanu: it's unlikely
18:55:13 <ManateeLazyCat> lispy: Use "ghc -e" check type in runtime 
18:56:06 <ManateeLazyCat> lispy: I believe my solution is better solution that how to write scriptable program. :)
18:56:33 <ManateeLazyCat> lispy: Now just need refuse mismatch type if user's configure is older better. :)
18:57:02 <Philippa> revenantphx: assume a packet-by-packet version of interact. Does packetInteract . map ... suffice? If not, why not?
18:57:21 <ManateeLazyCat> lispy: http://hackage.haskell.org/packages/archive/pdynload/0.0.3/doc/html/src/System-Plugin.html look typeCheck
18:57:26 <Eduard_Munteanu> ManateeLazyCat: that's usually done by serializing and versioning those data structures.
18:57:26 <ManateeLazyCat> lispy: That's i use in pdynload
18:57:35 <revenantphx> I'm not talking about after the packets have been parsed.
18:57:47 <ManateeLazyCat> Eduard_Munteanu: Yep, if i focus convert, program can pass, but will crash later.
18:57:52 <revenantphx> I'm asking if theres a way to directly convert from one stream of binary to another, without intermediate types.
18:57:59 <ManateeLazyCat> s/focus/force
18:58:02 <revenantphx> (out of curiosity, may not be the mot feasible way)
18:58:15 <Philippa> why's "without intermediate types" a big deal?
18:58:25 <ddarius> revenantphx: You just read in one stream and write out the other.
18:58:31 <revenantphx> Yes, no duh.
18:58:34 <Philippa> and what ddarius said
18:58:44 <revenantphx> I just asked if there are any specific abstractions which might be helpful.
18:58:56 <revenantphx> I didn't expect this sort of Spanish Inquisition. 
18:59:15 <Eduard_Munteanu> Deforestation can effectively remove abstraction from final code.
18:59:16 <Philippa> ...has it occurred to you that we might be asking questions to narrow down your use case to try to pick some?
18:59:28 <revenantphx> Never Philippa, never.
18:59:28 <Philippa> Eduard_Munteanu: heh. Yeah, fusion is your bestest fiend
18:59:29 <ManateeLazyCat> lispy: I just don't like "ghc -e" solution, it's need user pass type information, it's tiresome
18:59:41 <revenantphx> Let me try to explain this in one simple paragraph.
18:59:51 <lispy> ManateeLazyCat: yeah...
19:00:34 <revenantphx> One side takes in shit wire protocol, the other spits out easy to parse, happy protocol. These conversions are one packet per packet, however... the shit protocol does not properly frame the size of packets, and so has to be parsed with iteratees or lazy io (preferably not).
19:00:58 <revenantphx> So yes, map works well enough, I'm just wondering if there's another cool way to look at it.
19:00:58 <Philippa> (what's wrong with packetConcat . packetInteract . map ...?)
19:01:06 * roconnor slowly starts imagining a pure data structure for this problem
19:01:07 <revenantphx> This is mostly a "for-fun" endeavor.
19:01:10 <Philippa> the short answer is "not really"
19:01:16 <revenantphx> long answer?
19:01:36 <Philippa> the long ones are all about whether you've got a stateful problem, what sort of rules the protocol has to follow etc etc
19:01:47 <Philippa> so they're more specific to the protocols involved
19:02:19 <Philippa> wrapping up the input stream in an arrow or something from the monad/applicative/... family can be good
19:02:35 <Philippa> (treat it as a reader+writer+... scenario and tail call for next packet, for example)
19:02:39 <revenantphx> I'm hoping this is a non-stateful problem.
19:02:46 <revenantphx> I know I can parse statelessly with iteratees.
19:03:05 <revenantphx> Let me put it this way.
19:03:14 <revenantphx> For the input protocol (the shit one), it's not going to have *any* useful properties
19:03:17 <Philippa> yeah. The reader+writer+... setup also gives you a foothold for semantics like "read x bytes when..."
19:03:20 <ddarius> Benchmarking non-indexed nested loop joins when you're interested in large scale cache effects is not fun.
19:03:30 <revenantphx> reader/writer?...
19:03:42 <Philippa> are you familiar with the reader and writer monads?
19:03:43 <revenantphx> got any links?
19:03:50 * ddarius needs bigger records.  That's the key.
19:03:52 <revenantphx> Not really.
19:04:01 <Philippa> someone else'd be better placed to point you at the currently-recommended tutorial info than I would
19:04:09 <Philippa> (but also consider the applicative instances)
19:04:14 <revenantphx> What's the gist of their purpose?
19:04:40 <Philippa> reader does "input-only" state with a stack discipline. Writer does "output-only" state - keeps a log or an output stream
19:05:18 <Philippa> (for perspective, Parsec keeps the input stream in its 'state')
19:05:42 <Eduard_Munteanu> If it's stateless, then something lazy-like, say like interact, suffices.
19:05:58 <Philippa> right, the rest's about convenience
19:06:21 <Philippa> and about embedding the semantics of the language the protocol's described in
19:06:24 <Eduard_Munteanu> And moreover the map goes away under composition.
19:06:36 <Eduard_Munteanu> @free map
19:06:38 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
19:06:57 <ddarius> V.map wasteMemory
19:07:01 <Eduard_Munteanu> (erm was hoping for something more like the rewrite rule)
19:07:05 <Philippa> revenantphx: Reader and Writer're both standard monads found in mtl etc, and in most monad tutorials that deal with specific monads other than IO, for what it's worth
19:07:27 <Eduard_Munteanu> map f . map g == map (f . g)
19:08:00 <revenantphx> Well, this is mostly about trying something neat.
19:08:08 <Eduard_Munteanu> Also all sorts of other abstractions might go away.
19:08:19 <ManateeLazyCat> lispy: I need think some light way force evaluate value from unsafeCoerce, then catch it, if exception throw, type is mismatch.
19:08:25 <aristid> @free join
19:08:26 <lambdabot> Expected variable or '.'
19:08:30 <aristid> :(
19:08:39 <aristid> @free fmap
19:08:41 <lambdabot> Expected variable or '.'
19:08:45 <aristid> wtf
19:08:53 <chessguy> hey guys, i'm curious, what would you say is the haskell equivalent to ruby's Enumerable module? it assumes that whatever class it's mixed into has an #each method, and gives you a bunch of other methods built in terms of it
19:09:29 <lispy> ManateeLazyCat: what if I gave you an IO action that was going to launch missiles.  Would your to check the unsafeCoerce launch the missiles?
19:09:30 <Philippa> revenantphx: spend a while understanding how monadic parsing works - not in terms of the level of parsing power achieved, just how the data flows. Take a look at using Writer to create a log or other output stream. Go from there
19:09:43 <aristid> chessguy: Foldable, maybe. or just Functor
19:09:44 <Eduard_Munteanu> chessguy: sounds a bit like Traversable
19:09:45 <ddarius> chessguy: I presume #each is supposed to be like a generator?
19:09:50 <revenantphx> Philippa: alright.
19:09:54 <ManateeLazyCat> lispy: Hmm.
19:09:55 <aristid> or Traversable, yeah
19:09:58 <Eduard_Munteanu> @src Traversable
19:09:58 <lambdabot> class (Functor t, Foldable t) => Traversable t where
19:09:58 <lambdabot>     traverse    :: Applicative f => (a -> f b) -> t a -> f (t b)
19:09:58 <lambdabot>     sequenceA   :: Applicative f => t (f a) -> f (t a)
19:09:58 <lambdabot>     mapM        :: Monad m => (a -> m b) -> t a -> m (t b)
19:09:58 <lambdabot>     sequence    :: Monad m => t (m a) -> m (t a)
19:10:05 <aristid> @src Foldable
19:10:05 <lambdabot> Source not found. Wrong!  You cheating scum!
19:10:08 <aristid> wtf
19:10:10 <Philippa> The original Hutton/Meijer paper probably isn't a bad place to start for parsing
19:10:10 <Eduard_Munteanu> LOL
19:10:14 <chessguy> ddarius, yes, it gives you a list, though you don't know of what type
19:10:25 <Eduard_Munteanu> @vixen Don't be rude to aristid!
19:10:25 <lambdabot> yup
19:10:45 <aristid> her selection of source code is a bit weird
19:10:51 <aristid> Traversable is there, Foldable not
19:10:58 <Eduard_Munteanu> @src Functor
19:10:59 <lambdabot> class  Functor f  where
19:10:59 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
19:11:09 <Eduard_Munteanu> She seems to be answering to me, in particular.
19:11:21 <aristid> Eduard_Munteanu: well, then try Foldable :P
19:11:24 <aristid> @src Functor
19:11:24 <lambdabot> class  Functor f  where
19:11:24 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
19:11:28 <Eduard_Munteanu> Dang!
19:11:32 * ManateeLazyCat Read the source code of "ghc -e"
19:12:50 <ManateeLazyCat> lispy: Correct, i need find way check type but not execute it, but lightweight
19:13:27 <aristid> ManateeLazyCat: i hope you don't find this question rude... how many years ago did you start learning english?
19:14:01 <ddarius> @hoogle rnf
19:14:01 <ManateeLazyCat> aristid: Maybe 4 years. :)
19:14:02 <lambdabot> Control.Parallel.Strategies rnf :: NFData a => Strategy a
19:14:47 <ddarius> chessguy: So how is the answer not just the list functions?
19:14:47 <Eduard_Munteanu> (I admit wanting to ask ManateeLazyCat the same thing, but couldn't get myself to)
19:14:50 <aristid> ManateeLazyCat: hmm, that's not much. didn't you start when you were 10 or so (that's when i started)?
19:15:09 <ManateeLazyCat> aristid: No.
19:15:43 <Eduard_Munteanu> You're Chinese, if I recall correctly, aren't you?
19:15:50 <ManateeLazyCat> I know my situation, i will find some time study English systematically.
19:15:58 <chessguy> ddarius, maybe it is, i'm not sure
19:16:08 <aristid> ManateeLazyCat: maybe you should just read a lot of books :)
19:16:22 <aristid> ManateeLazyCat: like harry potter or whatever suits you
19:16:29 <chessguy> ddarius, but in ruby, anything that can give you an array can be an enumerable, not just an array (list)
19:16:43 <chessguy> so i suspect it's more general. maybe functor
19:17:00 <ManateeLazyCat> aristid: Yep, i have read many papers, i can understand them.
19:17:08 <ddarius> chessguy: All you need then, is a "toList" function.
19:17:16 <ManateeLazyCat> aristid: Most of my time is coding coding and reading reading
19:17:42 <ddarius> And Foldable is equivalent to having a "toList" function.
19:18:09 <aristid> ManateeLazyCat: but nothing like harry potter or maybe newspapers?
19:18:16 <chessguy> err, actually, i take that back
19:18:24 <ManateeLazyCat> aristid: Sometimes I just can not express themselves well.
19:18:45 <ManateeLazyCat> aristid: Yep, i just read book about CS
19:18:55 <chessguy> i should have said anything that has a function, each, which can take another function, and somehow apply it to to all the "items" in it, is an enumerable
19:19:12 <Eduard_Munteanu> He probably means non-technical literature.
19:19:16 <aristid> ManateeLazyCat: you use the wrong class of words, sometimes, which is really confusing, for example
19:19:33 <chessguy> which does sound a lot like Functor
19:19:50 <aristid> ok that sentence of mine is way too nested :D
19:19:56 <revenantphx> so... quick check
19:19:58 <ManateeLazyCat> aristid: Yes, sometimes, i don't know which word is best choose.
19:20:11 <revenantphx> :t (<*>)
19:20:13 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
19:20:15 <revenantphx> :t ap
19:20:17 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
19:20:18 * ManateeLazyCat Damn i haven't time study English.
19:20:24 <revenantphx> same thing except for applicatives?
19:20:28 <aristid> ManateeLazyCat: i think reading non-technical books helps with that
19:20:33 <revenantphx> (and it's infix which is nice :|
19:20:50 <ManateeLazyCat> aristid: Unfortunately, i even haven't time read book now, too much task need finish.
19:21:20 <aristid> ManateeLazyCat: it's an investment. you get the benefit of better communication
19:21:30 <revenantphx> :t fmap
19:21:31 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:21:34 <revenantphx> :t (<$>)
19:21:35 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:21:42 <Philippa> aristid: prioties. They're up to ManateeLazyCat.
19:21:45 <aristid> revenantphx: (<$>) is just an alias of fmap
19:21:46 <Philippa> *priorities
19:21:47 <Eduard_Munteanu> I haven't read much non-technical literature so far.
19:21:50 <Philippa> ...me no brain good today
19:21:51 <revenantphx> aristid: yep.
19:21:55 <revenantphx> Noticed that.
19:22:02 <aristid> Philippa: yes, i'm just trying to convince him to change them. is that illegitimate?
19:22:06 <Eduard_Munteanu> Even in my native language.
19:22:17 <ManateeLazyCat> aristid: I think my situation will better if i have English environment, every friend speak English.
19:22:31 <Philippa> aristid: I think you've made your point already
19:22:44 <chessguy> @type foldr
19:22:45 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
19:22:56 <ManateeLazyCat> I found that my English has become the communication barriers and other friends.
19:23:01 <aristid> Philippa: you want me to stop?
19:23:10 <Philippa> aristid: yep
19:23:19 <Philippa> or at least move on beyond repeating the same point
19:23:31 <ManateeLazyCat> Ok, thanks all, i need coding now. Bye. :)
19:23:52 <Eduard_Munteanu> Look what you've done :P
19:23:59 <aristid> Philippa: sometimes things need to be repeated :P
19:24:00 <Eduard_Munteanu> Have fun, ManateeLazyCat 
19:24:12 <aristid> see you, ManateeLazyCat
19:24:37 <ManateeLazyCat> Eduard_Munteanu: Maybe today, or tomorrow, scriptable Manatee will release, then next step, i will focus all my time on improve Haskell IDE features.
19:24:59 <ManateeLazyCat> s/on/to
19:25:13 <Philippa> aristid: sometimes all it accomplishes is bullying, especially when you don't have a clear picture of what the higher priorities are
19:25:18 <Eduard_Munteanu> "on improving", even ;)
19:25:32 <chessguy> @src Monad
19:25:32 <lambdabot> class  Monad m  where
19:25:32 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
19:25:32 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
19:25:32 <lambdabot>     return      :: a -> m a
19:25:32 <lambdabot>     fail        :: String -> m a
19:25:39 <ManateeLazyCat> Eduard_Munteanu: Thanks. :)
19:26:11 * ManateeLazyCat Do not want you making fun of my English, bye guys. :)
19:26:34 <cheater99> can haskell generate a program that haskell cannot compile?
19:26:54 <Eduard_Munteanu> @faq ^
19:26:55 <lambdabot> The answer is: Yes! Haskell can do that.
19:27:03 <ddarius> > sqrt 10
19:27:04 <lambdabot>   3.1622776601683795
19:27:16 <cheater99> Eduard_Munteanu: but
19:27:23 <cheater99> can haskell compile all programs?
19:27:30 <cheater99> @faq
19:27:30 <lambdabot> The answer is: Yes! Haskell can do that.
19:27:35 <aristid> Philippa: and sometimes it accomplishes great things. so what to do?
19:27:47 <Eduard_Munteanu> cheater99: define "all programs"
19:28:08 <cheater99> programs.getAll()
19:28:09 <Eduard_Munteanu> It can compile all correct Haskell programs, yes.
19:28:14 <Philippa> aristid: apply a little sensitivity. I'd note ManateeLazyCat's last line before quitting
19:28:21 <ddarius> aristid: Default to letting people make their own decisions.
19:28:48 <Eduard_Munteanu> And a Haskell program can generate a C program, which obviously can't be compiled with a Haskell compiler.
19:29:02 <cheater99> no, but it can be compiled with haskell!
19:29:05 <cheater99> surely!
19:29:09 <Philippa> quite. If you don't understand someone's existing set of priorities, you should do no more than hand them the info - progressing beyond that into tactics that can be considered harassment is inappropriate
19:30:02 <aristid> Philippa: i'm sorry, i did not notice that he felt threatened by it
19:30:30 <ddarius> Eduard_Munteanu: Sure it can.
19:30:35 <lispy> His english is rough but I pretty much always know what he's saying.  IMO, that's good enough for IRC.
19:30:54 <aristid> lispy: i often have great trouble understanding it.
19:30:59 <ddarius> lispy: It wouldn't matter if it wasn't.
19:31:00 <Eduard_Munteanu> ddarius: well whatever you mean, that's not the point :)
19:31:14 <Philippa> aristid: you shouldn't expect to notice before it's too late. Look for clear signs that someone isn't
19:31:19 <lispy> aristid: maybe you should work on your broken english skills :P
19:31:35 <ddarius> lispy: Indeed that's starting to take the correct perspective.
19:32:18 <Eduard_Munteanu> Admittedly, his English is very bad, but that's not the point :/
19:32:25 <Axman6> has anyone used Text.Regex.Posix before? I can't get it to work, and bos' very nice post (http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/) doesn't seem to work any more for me
19:32:31 <Eduard_Munteanu> (as in barely functional)
19:32:52 <lispy> purely functional english
19:32:58 <Eduard_Munteanu> :)
19:33:12 <Eduard_Munteanu> More like lazy, but it isn't the case here.
19:33:21 <lispy> I told someone Haskell is a purely functional language and they thought I meant you can use it for fun stuff.
19:33:34 <lispy> can't*
19:33:43 <lispy> "Work stuff only, eh?"
19:33:45 <aristid> with can it would be correct
19:33:56 <lispy> aristid: yeah, freudian slip
19:34:00 <Philippa> lispy: sounds like a pun on their part to me?
19:34:06 <Axman6> lispy: i was going to say that i'm yet to prove them wrong, until you corrected it
19:34:14 <lispy> Philippa: this was a non-technical person, so I don't think so
19:34:16 <Eduard_Munteanu> lispy: heh, I tend to avoid mentioning "functional" without explaining it. Otherwise people think "well, C works too, it must be functional" :)
19:35:13 <ksf> is it feasible to do a numeric-prelude for the mathy types and a normal prelude for down-to-earth hackers that are compatable?
19:36:05 <Philippa> lispy: you don't have to be technical to consider that writing a game is still functionality!
19:36:14 <chessguy> > [1,2] >> [3,4]
19:36:15 <lambdabot>   [3,4,3,4]
19:36:17 <ksf> sometimes I loathe Num because it doesn't give me enough options, but then many times it's just the proper yagni default.
19:36:41 <Eduard_Munteanu> @wn yagni
19:36:43 <lambdabot> No match for "yagni".
19:36:54 <Axman6> so, no posix regex users here?
19:36:56 <ksf> you ain't gonna need it
19:36:56 <lispy> ksf: I'm not sure how you'd swing it.
19:37:07 <killerswan> So I'm trying to install leksah.  Is there any reason leksah requires gtksourceview2 <0.12?  Because there's an error on compiling 0.11...
19:37:10 <Eduard_Munteanu> Ah.
19:37:12 <ksf> lispy, if necessary with typeclass extensions.
19:37:16 <ksf> somewhere in h'.
19:37:22 <lispy> ksf: would you provide some slick way to go between Num and BetterNum?
19:37:52 <Eduard_Munteanu> Unfortunately Haskell didn't manage to avoid success, and it's probably too late to mess up existing code.
19:37:54 <lispy> (So, if you really make a BetterNum there won't be a bijection, so it seems to be lost already)
19:37:54 <ksf> well, yes, bijections between typeclasses might be one such extension
19:38:02 <monochrom> numeric-prelude could define a very rich class hierarchy. prelude could expose only a few of those classes, notably some of the leaf classes
19:38:20 <ksf> well, bijection up to isomorpmism.
19:38:34 <Eduard_Munteanu> I don't get the "numeric" in it though.
19:38:36 <lispy> ksf: Well, I'd remove signum from Num
19:38:45 <lispy> ksf: and BetterNum would be CommutativeRing
19:38:50 <ksf> split + and * into separate monoids
19:38:50 <Eduard_Munteanu> Rather "pedantic" or "mathy" or whatever.
19:38:56 <lispy> ksf: then I don't have me a bijection
19:39:02 <Eduard_Munteanu> Or abstract.
19:39:19 <ksf> typeclass synonyms might help, too.
19:40:06 <Eduard_Munteanu> Ring can easily be made from two Monoids that way.
19:40:16 <ddarius> "Bijection up to isomorphism" like an equivalence of categories?
19:40:49 <ksf> do I look like a category theroist?
19:40:53 <ksf> but sounds about right.
19:41:03 <Eduard_Munteanu> (actually a NumRing might be a better name, you clearly don't want an arbitrary ring to expose + and *)
19:41:20 <BMeph> Down with Show! >:(
19:41:37 <lispy> ksf: do you look like this? http://math.ucr.edu/home/baez/diary/shanghai/shanghai_john_harbor.jpg
19:41:39 <ksf> yep + and * should be limited to numbers, by default.
19:41:47 <lispy> (that was the result of a google image search for category theorist)
19:42:41 <ksf> ...you can always make some instances if you want to abuse them syntax-wise
19:42:43 <Eduard_Munteanu> I kinda like pics of Wadler :)
19:42:52 <Eduard_Munteanu> Heh.
19:43:33 <Eduard_Munteanu> http://en.wikipedia.org/wiki/File:Wadler2.JPG
19:43:55 <chessguy> what's the implementation for >> for list?
19:43:56 <ksf> hmmm. * will definitely have the wrong type to work for kleene algebras
19:44:05 <lispy> ksf: Speaking of syntax abuse, I want a mixfix extension.  I wonder how hard that would be in Haskell given the existing grammar.
19:44:47 <lispy> Probably nearly impossible...
19:44:48 <ksf> and using  would break the no-unicode rule
19:45:01 <lispy> No unicode _rule_?
19:45:04 <ksf> though a _very limited_ set of unicode characters might be sensible
19:45:08 <lispy> I thought no-unicode was just coincidence
19:45:22 <chessguy> @src (>>) []
19:45:22 <lambdabot> Source not found. Just what do you think you're doing Dave?
19:45:30 <chessguy> @src [] (>>)
19:45:30 <lambdabot> xs >> ys      = concatMap (const ys) xs
19:45:39 <ksf> where you know that it's only five things you have to learn. and have ascii alternatives.
19:46:08 <ksf> unicode for code is mostly just broken.
19:46:16 <lispy> unicode in Haskell wouldn't be so bad if all editors had sane ways to get the more mathy symbols.  See for example Proof General.
19:46:36 <ksf>  just doesn't fit well into a monospaced font.
19:47:30 <bsmntbombdood> ascii forever
19:47:31 <bsmntbombdood> down with unicode
19:47:34 <lispy> One thing that really bothers me in Haskell papers is when they type set haskell code using symbols that you can't use in real code.
19:47:38 <Eduard_Munteanu> And non-monospace fonts generally don't make sense for coding.
19:47:45 <ksf> I'd be all for allowing to write \to instead, though, which is the latex code for 
19:48:23 <ksf> ...make that an escape that does'nt clash wit lambdas.
19:48:29 <lispy> Actually, it's a bit weird that we never use non-monomspace fonts in code, isn't it?  Is it just a training issue?
19:48:36 <Eduard_Munteanu> #define and some editor fiddling might do that.
19:48:41 <monochrom> @quote ray 1970s
19:48:42 <lambdabot> ray says: when you're dealing with programmers you are often dealing with people who voluntarily use 1970s terminals. they cannot be reasoned with
19:48:44 <ksf> it's an alignment issue
19:48:44 <monochrom> is why
19:48:45 <bsmntbombdood> -> is less typing
19:49:12 <ksf> lispy, have a look at lhs2tex for how to deal with proportional fonts
19:49:21 <killerswan> I'd love a bigger keyboard with more symbols.
19:49:42 <killerswan> Let me use the second shift or second alt key for another set of symbols.
19:49:46 <bsmntbombdood> there is no reason whatsoever to complicate source with unicode
19:49:58 <killerswan> Unicode source would be fine if we had more buttons.
19:50:03 <bsmntbombdood> we dpm
19:50:05 <ksf> killerswan, man xmodmap
19:50:10 <bsmntbombdood> we don't need more buttons
19:50:23 <Eduard_Munteanu> Generally your editor can handle showing you the code using Unicode.
19:50:23 <ksf> if in doubt, use a second keyboard.
19:50:33 <Eduard_Munteanu> The on-disk representation doesn't have to be Unicode.
19:50:33 <killerswan> hmm
19:50:36 <chessguy> > [1,2,3] >> [2,3,4]
19:50:37 <lambdabot>   [2,3,4,2,3,4,2,3,4]
19:51:11 <monochrom> in fact, the on-disk representation doesn't have to be plain text
19:51:20 <bsmntbombdood> monochrom: yes it does
19:53:50 <killerswan> it has to be significantly improved from plain text.  i.e., not ClearCase.
19:53:59 <ksf> I'd actually like something like lhs2tex to become standardised
19:55:15 <aefjt> It's half a century since Algol and we're still doing all our programming in linear text!
19:55:18 <ksf> ...it's output is beautiful to _look_ at, it's just that I don't want to be forced to deal with all the issues involved all the time.
19:55:24 <aefjt> *breaks an egg down the middle*
19:56:17 <bsmntbombdood> aefjt: not quite linear, especially with layout in haskell
19:56:25 <killerswan> In that half century, has K-12 math education changed at all? (more important that text formats...)
19:56:32 <ksf> I once tried some agda, and spend half an hour wondering what's wrong with my setup until I realised that I had mistaken some unicode character for some other.
19:57:01 <ksf> math education is largely useless.
19:57:22 <Eduard_Munteanu> Education is largely useless.
19:57:37 * applicative is stunned how concessive our Haskellers are being, in their comments on this Quadrescence character's post accusing them of "cargo cult mathematics"
19:57:39 <aefjt> Well, haskell is still linear in everything other than definition blocks
19:57:44 <killerswan> i'd suggest replacing 90% of it with computer science, but Eduard has a point, too
19:57:50 <Eduard_Munteanu> Wrt usefulness/time spent in the whole of school.
19:58:33 <ksf> most of the time in math is spend learning to calculate
19:58:47 <roconnor> @wn concessive
19:58:47 <lambdabot> *** "concessive" wn "WordNet (r) 2.0"
19:58:48 <lambdabot> concessive
19:58:48 <lambdabot>      adj : or or pertaining to concession
19:58:48 <monochrom> in that half-century, K-12 math education has changed from not-new-math to new-math to not-new-math
19:59:14 <killerswan> what was "new math"?
19:59:22 <monochrom> set-theoretic
19:59:24 <aefjt> applicative: it's more polite and disaffected than being concussive?
19:59:25 <roconnor> killerswan: set theory for grade 2
19:59:30 <ksf> and those rules of standard algebra are something mysterious that's to be memorised instead of understood...
19:59:39 <monochrom> but I'm oversimplifying
19:59:52 <aefjt> Well, it was oversimplified set theory.
20:00:14 <monochrom> there were several noble goals and several things went wrong
20:00:15 <ksf> roconnor, about 12 years ago, I learned set theory in primary class.
20:00:27 <ksf> germany, schleswig-holstein, to be precise.
20:00:35 <Eduard_Munteanu> We did some abstract algebra (groups, rings, vector spaces) in the 12th grade here.
20:00:37 <ksf> that's very, very, sensible.
20:00:38 <roconnor> I'm sorry
20:00:49 <roconnor> er
20:00:51 <Eduard_Munteanu> But overall, math education was rather sucky.
20:00:52 <roconnor> how old were you?
20:00:52 <Philippa> applicative: where? Also, I think I know Quadrescence elsewhere...
20:00:54 <ksf> finite sets only, but it's a very good start.
20:00:56 <ksf> 6
20:01:02 <ksf> er.
20:01:03 <killerswan> (i learned the binary system in 5th grade in Nebraska)
20:01:06 <ksf> 22 years ago.
20:01:10 <aefjt> Most of the New Math jokes are, unsurprisingly, from america
20:01:13 <roconnor> ksf: surely hereditarily finite sets :)
20:01:20 <killerswan> (of the other kids in that class, none of the others remembered learning it)
20:01:29 <Eduard_Munteanu> Isn't it Nu Math?
20:01:37 <monochrom> Mu Math
20:01:54 <Eduard_Munteanu> You have a (fixed) point.
20:02:07 <monochrom> Fix Math = Math (Fix Math)
20:02:08 <ksf> roconnor, think {apple, pea, banana} `union` {apple, pea, tea}
20:02:15 <roconnor> ah
20:02:17 <roconnor> ur elements
20:02:21 <Eduard_Munteanu> Admittedly it needs fixing.
20:02:41 <Eduard_Munteanu> NO, UR AN ELEMENT!
20:02:45 <ksf> very intuitive and leads right up to addition.
20:03:07 <monochrom> such as 3+3=4?
20:03:08 <aefjt> Add no-tea and it leads your class naturally to non-monotonic logic
20:03:09 <ksf> ...I learned about different number system before learning the symbol '9'
20:03:31 <ksf> monochrom, toss in some types.
20:03:35 <Philippa> applicative: I don't think we generally do cargo cult maths, but we do do an awful lot of informal, bordering on pseudo-maths
20:03:54 <Philippa> and some of it looks a lot worse than it actually is because there's a lot of barely-spoken tradition about that which tends to save our arses
20:04:36 <applicative> Philippa,  http://symbo1ics.com/blog/?p=788 
20:05:03 <ksf> we should just let BONUS do the syllabus.
20:05:24 <aefjt> I am under a strong impression that this channel had already talked about quad yesterday
20:05:37 <ksf> Philippa, fast and loose reasoning is morally correct
20:05:45 <applicative> Philippa, Haskell is a language, no one can stop cargo cultists from learning to speak it. 
20:06:38 <c_wraith> > let (+) = const . const $ 4 in (2 + 2, 3 + 3)
20:06:40 <lambdabot>   (4,4)
20:07:22 <ksf> I think the problem's mostly formalists who don't get the incompleteness theorem. actually, the problem is lamers that don't get software design, but that sounds so harsh.
20:07:25 <c_wraith> 50% ain't too bad
20:07:52 <applicative> aefjt, Is that right? I see it is dated Dec 26. Still, it is incomparably evil.
20:07:52 <aefjt> random = const 4 &&& id
20:08:20 <ksf> ...those people that believe that mathematica actually does math.
20:08:31 <ksf> or does rigirous proofs
20:08:32 <aefjt> Attribute not to malice, applicative, not to malice.
20:08:59 <ksf> while it's actually just a guessing engine that tends to have luck.
20:08:59 <Eduard_Munteanu> ksf: a bit like Zeilberger?
20:09:20 <ksf> zeilberger?
20:09:26 <monochrom> "a guessing engine that tends to have luck" sounds like a brain
20:09:40 <ksf> yep.
20:09:43 <Eduard_Munteanu> Doron Zeilberger.
20:10:01 <aefjt> mathematica can do rigorous proofs, but it invariably tends to discard them and just echo the input back at the user
20:10:06 <ksf> only formalists can wallow in the illusion that the brain is actually a mathematical sound entity.
20:10:11 <roconnor> I read http://symbo1ics.com/blog/?p=788#comment-876 and I don't get where it is coming from
20:10:23 <Eduard_Munteanu> I've heard him touting Mathematica "proofs" consisting of checking the hypothesis. But then again, he's an ultrafinitist.
20:10:29 <blackdog> so, i don't suppose any brave hero's hacked on ghc x86_64 support for mac while i wasn't watching...?
20:10:52 <roconnor> why is it bad to use general categorical terms when writing generic libraries?
20:11:02 <ksf> well, I defitnitely know that mathematica can solve stuff wrong
20:11:20 <ksf> ...which means it's not as rigirous as a programmer would want something to be.
20:12:03 <roconnor> and I certainly don't understand what this complaint about abstract mathematics has to do with the poster's orginal problem
20:12:27 <Eduard_Munteanu> I don't even recall an original problem :/
20:12:41 <roconnor> oh, though chris smith claims to understand.  Is this cdsmith?
20:12:45 <dolio> The original problem appeared to be that type classes are open.
20:12:47 <Philippa> ksf: fast and loose reasoning is one part of what I have in mind, yeah. Certain conventions about 'up to' and 'modulo' use cases are another
20:13:17 <roconnor> Eduard_Munteanu: Haskell didn't infer his Int type from the Monoid + Num contraints.
20:13:38 <Eduard_Munteanu> Oh sorry, you're referring to that link.
20:13:51 <Eduard_Munteanu> I was talking about the off-topic here :)
20:13:57 <applicative> roconnor, the concession of 'Chris Smith' is especially infuriating.  
20:14:02 <hamishmack> killerswan: Dev version of leksah supports gtk2hs 0.12.  See bottom of http://leksah.org/download.html for details on how to build it.
20:14:44 <killerswan> thank you :)
20:14:45 <ksf> I think he should just be flamed to death for attempting to define Monoid Int in the first place.
20:14:57 <applicative> ksf, yes its so sick
20:15:08 <ksf> ...it's just a thing that's wrong in every imaginable way.
20:15:11 <applicative> He's so rigorous
20:15:16 <ksf> even if it's "just for this source file"
20:15:34 <Eduard_Munteanu> Monoid should be an MPTC, what do you say?
20:15:44 <roconnor> ksf: it's not that wrong, just really wrong ;)
20:15:45 <monochrom> what is the second parameter?
20:15:48 <Philippa> applicative: yeah, and there's a failure to acknowledge the way in which haskell is rigorous about its "ambiguities", too
20:15:51 <Eduard_Munteanu> The operation.
20:16:10 <roconnor> ksf: I mean, if the operation he instantiated wasn't even associative, now that would be wrong in eery imaginable way :D
20:16:22 <Eduard_Munteanu> Monoid Int Add makes sense, with Add as a phantom type.
20:16:32 <ksf> from a software engineering pov, it's wrong in every way.
20:16:38 <applicative> Philippa, yes, he's basically complaining about something that, however painful is for the sake of a genuine rigor.
20:16:54 <roconnor> Eduard_Munteanu: is that an MPTC?
20:16:59 <aristid> ksf: he also has an Eq constraint on the Monoid class
20:17:16 <applicative> ksf, note his complaint is that "HASKELL DOESNT KNOW THAT 5 IS AN INTEGER", when his expectation was that ghci would moronically infer Int
20:17:23 <Eduard_Munteanu> roconnor: Monoid a b is an MPTC
20:17:29 <roconnor> ok
20:17:39 <aristid> what is MPTC?
20:17:50 <Eduard_Munteanu> MultiParameter TypeClass
20:17:54 <dibblego> Multi-Parameter Type-Class
20:17:58 <aristid> aah
20:17:59 <MtnViewMark> Are we dissin a troll?
20:18:11 <applicative> ksf, he should say "but we need to add a signature because 'Haskell' might get the false impression that we're actually talking about integers"
20:18:22 <roconnor> MtnViewMark: I find it unlikely that symbo1ics was trolling
20:18:29 <bsmntbombdood> speaking of monoids
20:18:44 <aristid> MtnViewMark: troll or not, he got more than 50% upvotes on reddit, and a lot of upvotes on HN too
20:18:45 <bsmntbombdood> is it possible to declare that a type is a monoid over two different operations?
20:19:02 <aristid> bsmntbombdood: the usual solution seems to be creating newtypes
20:19:08 <MtnViewMark> I was cueing by the all caps
20:19:17 <Eduard_Munteanu> bsmntbombdood: not really because Haskell monoids already incorporate an operation.
20:19:21 <applicative> MtnViewMark, I guess. I am only irritated by the way conal and mauke are treated.
20:19:34 <dibblego> applicative, by whom?
20:19:51 <roconnor> aristid: yes, that is the usual solution.  See Sum and Product
20:19:53 <monochrom> conal is sacred.
20:19:53 <applicative> http://symbo1ics.com/blog/?p=788  
20:20:07 <MtnViewMark> This was in the Haskell reedit? I must've missed it
20:20:12 <Philippa> applicative: an edited comment at the bottom disavowing that interpretation would be appropriate, yeah
20:20:18 <aristid> conal is SECrad (ok, stupid joke :P)
20:20:31 <bsmntbombdood> aristid: what does that look like in use?
20:20:37 <applicative> monochrom, exactly.  The text quoted even shows why.
20:20:43 <aristid> MtnViewMark: programming reddit, but there was a repost on haskell reddit
20:20:56 <aristid> bsmntbombdood: look at Sum, from Data.Monoid
20:21:29 * applicative hasnt seen the reddit crap yet. aaargh.  I will stay away.
20:22:05 <bsmntbombdood> so you end up saying mappend (Sum x) (Sum y) ?
20:22:13 <dibblego> applicative, "the reddit crap" led to me cancelling my account, don't do it
20:22:14 <bsmntbombdood> or mappend (Product x)...?
20:22:30 <dibblego> bsmntbombdood, use on of course :)
20:22:46 <aristid> applicative: well, let's see if you can resist the temptation if i give you a link: http://www.reddit.com/r/programming/comments/es29o/the_air_on_which_haskell_programmers_seem_to/
20:23:03 <bsmntbombdood> dibblego: huh?
20:23:14 <dibblego> @type on -- bsmntbombdood 
20:23:15 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
20:23:28 <MtnViewMark> Oy - what a bad post, what bad writing
20:23:36 <aristid> dibblego: you cancelled the reddit account because of Quad's cargo cult reddit thread?
20:23:45 <dibblego> aristid, it was the straw
20:24:06 <monochrom> on mappend Sum x y
20:24:07 <aristid> dibblego: i mostly just read the haskell reddit, and that seems to be pretty OK
20:24:17 <dibblego> aristid, yeah I've heard that too
20:24:27 <Eduard_Munteanu> LOL
20:24:32 <dibblego> @let appendiing = on mappend 
20:24:33 <Eduard_Munteanu> (at aristid's link)
20:24:33 <lambdabot>  Defined.
20:24:34 <dolio> Progit was a lost cause a long time ago.
20:24:36 <aristid> monochrom: once you add a tag type, mappend becomes pretty meaningless, does it not?
20:24:42 <dibblego> dolio, I'm a slow learner :)
20:24:52 <dibblego> @let appending = on mappend 
20:24:53 <lambdabot>  Defined.
20:24:57 <aristid> :t appending
20:24:58 <monochrom> I haven't used Monoid a lot to know
20:24:58 <lambdabot> forall a b. (Monoid b) => (a -> b) -> a -> a -> b
20:25:29 <bsmntbombdood> hmm
20:26:06 <aristid> > appending ([0]:) [1,2] [3,4]
20:26:07 <lambdabot>   No instance for (GHC.Num.Num [t])
20:26:07 <lambdabot>    arising from a use of `e_101234' at <i...
20:26:12 <aristid> :t appending ([0]:) [1,2] [3,4]
20:26:12 <lambdabot> forall t. (Num t, Num [t]) => [[t]]
20:26:21 <aristid> :t appending ([0]:)
20:26:22 <lambdabot> forall t. (Num t) => [[t]] -> [[t]] -> [[t]]
20:26:33 <aristid> :t appending ([[0]]:)
20:26:34 <lambdabot> forall t. (Num t) => [[[t]]] -> [[[t]]] -> [[[t]]]
20:26:39 <aristid> :t appending (0:)
20:26:40 <lambdabot> forall t. (Num t) => [t] -> [t] -> [t]
20:26:48 <aristid> :t appending (0:) [1,2] [3,4]
20:26:49 <lambdabot> forall t. (Num t) => [t]
20:26:52 <aristid> > appending (0:) [1,2] [3,4]
20:26:54 <lambdabot>   [0,1,2,0,3,4]
20:27:07 <roconnor> ``Haskell community seems to nurture the idea of half-baked understanding of what inherently mathematical objects, such as monads, are.
20:27:22 <roconnor> in what way do people nurture a half-baked understanding of monads?
20:27:48 <monochrom> one could say LYAH presents half-baked monads
20:27:50 <roconnor> I know very few intermediate or advanced haskell programmer who misunderstand these categorical terms.
20:28:08 <roconnor> and beginners necessarily misunderstand them because they are learning.
20:28:13 <dolio> The blogging community seems to nurture making sweeping, controversial, statements without backing them up very well.
20:28:17 <MtnViewMark> Gosh - what does he say about C's approximation to Integers With only 32buts?!?!?
20:28:26 <MtnViewMark> er, bits
20:28:35 <aristid> roconnor: what counts as intermediate, and what counts as misunderstand? would not understanding them at all count as misunderstanding?
20:28:57 <blackdog> C's never really had any pretensions to being anything but an earthy systems language:)
20:29:10 <roconnor> dolio: oh, well I guess you might get a poor impression of the "comunity" if you think it consists of beginner's blogs posts
20:29:29 <Philippa> roconnor: I see some common misunderstandings about how "haskell monads aren't really monads" and to what extent amongst people who most would describe as at least intermediate if not advanced, and some really common misunderstandings where someone's not figured out the consequences of being a monad on that particular category
20:30:00 <monochrom> Consider "the human community nurtures the idea of half-baked understanding of what numbers are". True and who cares.
20:30:08 <Philippa> (some of the arguments I used to get into with people like Beelsebob were good examples)
20:30:20 <roconnor> Philippa: how are haskell monads not really monads?
20:30:37 <blackdog> roconnor: not functors, maybe?
20:30:49 <MtnViewMark> Ah see, I just understand Haskell as language that let's me get shit done better than others
20:30:50 <dibblego> roconnor, he argues in the comments that the laws are not enforced and the absence of Functor m =>
20:30:57 <roconnor> blackdog: all monads are functors.  See liftM
20:31:28 <blackdog> roconnor: sure, but it's not baked into the type system
20:31:36 <Philippa> roconnor: some common misunderstandings about fail and about _|_/fast and loose
20:31:37 <roconnor> @src liftM
20:31:37 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
20:31:52 <Gracenotes> not all Monads are Functors. all monads are functors.
20:31:54 <aristid> MtnViewMark: that's how i like to see it too, and as a language that inspires my brain to think a lot :)
20:31:56 <Gracenotes> >_>
20:31:57 <monochrom> I am all for imperfect understanding as long as you have a bounded life and your imperfect understanding hasn't shown failures in your work.
20:31:59 <roconnor> there is a difference between a structure being a functor and being an instance of Functor.
20:32:00 <MtnViewMark> Ah well, the realities of software evolution...
20:32:07 <dibblego> "(something is probably wrong when youre using Functor f => Algebra f b -> GAlgebra f (Cofree f) a -> (f :~> f) -> FixF f -> a as a type declaration)"
20:32:07 <Gracenotes> also all Monads are functors.
20:32:10 <Philippa> (occasionally complaints because you have to navigate cases like Identity via explicit isomorphism, too)
20:32:22 <blackdog> roconnor: yes, i should have capitalised it - got lazy, sorry.
20:32:43 <roconnor> Philippa: oh right fail.
20:32:47 <Philippa> the misunderstandings generally amount to "argh, I found this small hole-like thing, everything's broken!" though
20:32:49 <aristid> monochrom: which is good because probably all people have imperfect understanding of 99.999999999% of the things they encounter
20:32:51 <roconnor> that is a fair point I guess
20:33:00 <Philippa> which pisses me right off
20:33:50 <roconnor> dibblego: I totally don't get that comment
20:33:54 <Philippa> I get similarly annoyed when people make blanket statements like "monads don't have an architectural role", but that's partly my own fault for not blogging more instead of just saying stuff in here
20:33:55 <roconnor> what is wrong with such a signature?
20:34:07 <dibblego> roconnor, "I am an idiot or something, k?"
20:34:30 <Philippa> roconnor: "I'm being an arsehole and don't care to check edwardk et al's work through properly before accusing them of being cargo cultists"
20:34:34 <roconnor> dibblego: ... still don't get it
20:34:42 <Philippa> roconnor: probably also "I never heard of CPO or realised its relevance"
20:34:50 <dolio> I'd bet money you don't see that signature outside of category-extras.
20:34:52 <aristid> category-extras could use more documentation
20:34:55 <dibblego> roconnor, someone wishes to advertise that they are not the brightest bulb in the box, let it be that way
20:35:03 <dolio> And that's edwardk's playing-with-category-theory library.
20:35:11 <dolio> So, what do you expect?
20:35:12 <Eduard_Munteanu> It refers to the zygo thingy and that's mainly a joke.
20:35:17 <blackdog> Philippa: at the risk of branding myself an idiot: CPO?
20:35:29 <chessguy> @src Digit fmap
20:35:29 <lambdabot> Source not found. I am sorry.
20:35:35 <chessguy> @src Digit (fmap)
20:35:35 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
20:35:41 <dibblego> dolio, I think it's from the wiki page on zygohistomorphic prepromorphisms
20:35:42 <monochrom> C3PO
20:35:52 <roconnor> dibblego, Philippa, okay I now understand what you guys are saying, but I'm pretty sure that isn't the message he was meaing to convey (thought it might be the message he in fact conveyed)
20:35:54 <Philippa> blackdog: Complete Partial Orders. The category of turing complete functional programs
20:35:55 <dolio> Oh. In that case it's a joke.
20:36:17 <dibblego> dolio, but then he doesn't have a point to make :)
20:36:18 <Philippa> roconnor: oh, I agree entirely. I'm actually saying that lots of people blow this stuff way out of proportion because we don't make the details of these things explicit enough
20:36:19 <Eduard_Munteanu> Philippa: admittedly, there are probably more ways one could've structured such computations, in slightly different ways than monads
20:36:25 <Eduard_Munteanu> (at least Haskell monads)
20:36:29 <monochrom> more seriously, CPO is e.g. http://en.wikipedia.org/wiki/Complete_partial_order
20:36:38 <roconnor> Philippa: I see.
20:36:43 <roconnor> Granted it is really hard to convey
20:36:45 <Eduard_Munteanu> Heh, C3PO, now I saw it.
20:37:12 <chessguy> how the heck is anything with the name Digit an instance of Functor?
20:37:12 <roconnor> DCPO plz
20:37:25 <Philippa> yeah. I actually think Conal's attitude towards implicit details - or at least, how he talks about it - is actively unproductive there because it tends to come across as antagonistic towards having things be implicit in the first place
20:37:26 <chessguy> (http://www.haskell.org/ghc/docs/6.6/html/libraries/base/Control-Monad.html#1)
20:37:33 <roconnor> chessguy: almost every type constructor is a functor :D
20:37:41 <Eduard_Munteanu> chessguy: how is Maybe a functor?
20:37:47 <ksf> "I think the real problem is mathematicians employing cargo-cult programming practices, misinterpreting the purposes and design rationales of, and then glibly misappropriating, language features. Haskell wasn't designed to please mathematicians and their sense of rigour, it was designed to foster rigorous software design."
20:37:50 <Philippa> roconnor: "almost"? :p Also, every algebraic datatype is built around one...
20:37:53 <chessguy> how is Digit a type constructor?
20:37:56 * ksf thinks he wrapped it up quite well.
20:38:03 <aristid> roconnor: which message did he want to convey with "The air on which Haskell programmers seem to thrive reeks of foul stench of cargo cult mathematics, something in which I dont want to be a part."?
20:38:17 <chessguy> Eduard_Munteanu, i can totally see that
20:38:24 <Eduard_Munteanu> @src Digit
20:38:24 <lambdabot> Source not found. I feel much better now.
20:38:32 <roconnor> Philippa: well there are a few type variables that occur in a contrapositive position I guess.  Not that anyone uses them :D
20:38:32 <Philippa> ksf: I think pointing out that our sense of rigour is more rigourous than theirs might be appropriate :p
20:38:36 <chessguy> it applies the function to the value in it, if there is one
20:38:53 <ksf> oh, I did.
20:38:58 <chessguy> but how can there be a value "in" something called a Digit?
20:38:58 <dolio> newtype Endo a = Endo (a -> a)?
20:38:59 <roconnor> aristid: well he seems to be trying to point to a problem in the Haskell community
20:39:02 <ksf> http://www.reddit.com/r/programming/comments/es29o/the_air_on_which_haskell_programmers_seem_to/c1ajpf2
20:39:13 <roconnor> aristid: using categorical concepts without understanding it
20:39:14 <Eduard_Munteanu> chessguy: if it's a datatype it can certainly be
20:39:32 <roconnor> aristid: but I don't really know anyone who develops these categorical concepts without understanding them.
20:39:38 <Philippa> ksf: you only did it in the individual case. I'm thinking of our relationship to formal logic here
20:39:42 <Eduard_Munteanu> I'm not familiar with Digit though/
20:39:43 <ksf> I certainly understand monads better than he typeclasses.
20:39:46 <aristid> roconnor: i really do not want to learn category theory. am i disallowed from using haskell now? oO
20:39:47 <roconnor> *develops them in Haskell
20:39:55 <chessguy> is there not some way to look up where Digit is? do the haskell docs really suck this bad?
20:40:09 <dolio> hoogle or hayoo
20:40:09 <roconnor> aristid: not really.  Most of the categorical concepts are much similar in Haskell since they are restircted to a single category
20:40:10 <aristid> @hoogle Digit
20:40:10 <lambdabot> Text.Parsec.Char digit :: Stream s m Char => ParsecT s u m Char
20:40:10 <lambdabot> Text.ParserCombinators.Parsec.Char digit :: Stream s m Char => ParsecT s u m Char
20:40:10 <lambdabot> Data.Char digitToInt :: Char -> Int
20:40:17 <roconnor> *much simpler
20:40:32 <monochrom> The blogging community uses the Internet without understanding it. All the time.
20:40:47 <roconnor> aristid: that being said, I *think* you might become a better programmer if you learn category theory.
20:41:09 <Eduard_Munteanu> chessguy: you might also want to check docs pertaining to newer GHC versions.
20:41:11 <monochrom> For example how many of them even know a bit of fibre optics?
20:41:29 <aristid> roconnor: maybe, but there are also other things left to be done to become better
20:41:37 <monochrom> Or theories of social networks if you prefer the holistic side of the story.
20:41:39 <roconnor> aristid: dure
20:41:41 <roconnor> *sure
20:42:01 <ksf> starting out with a CT book isn't a good idea, better start out with e.g. some lenses stuff
20:42:10 <ksf> examples first
20:42:20 <aristid> monochrom: people live in cities without understanding their social dynamics. the list goes on and on :)
20:42:21 <chessguy> dolio, neither shed any light
20:42:22 <roconnor> ksf: lenses stuff?
20:42:42 <ksf> lotsa isomorpmisms used in fc-labels.
20:42:45 <aristid> @hackage lenses
20:42:45 <lambdabot> http://hackage.haskell.org/package/lenses
20:42:54 <dolio> chessguy: Do you have a file that's using it?
20:42:56 <aristid> yay the link actually works
20:43:11 <roconnor> ksf: tell me about this, since I'm trying to write a paper about the categorical properites of lenses
20:43:14 <chessguy> dolio, i'm looking at the Functor instances at http://www.haskell.org/ghc/docs/6.6/html/libraries/base/Control-Monad.html
20:43:24 <chessguy> dolio, it lists Digit, and i'm wondering what that is
20:43:27 <roconnor> ksf: I'd like to know if it has already been written
20:43:51 <ksf> "for :: (i -> o) -> (f :->  o) -> Point  f i oSource
20:43:51 <ksf> Combine a partial destructor with a lens into something easily used in the applicative instance for the hidden Point datatype. Internally uses the covariant in getter, contravariant in setter bi-functioral-map function. (Please refer to the example because this function is just not explainable on its own.) "
20:43:55 <ksf> http://hackage.haskell.org/packages/archive/fclabels/0.11.1.1/doc/html/Data-Record-Label.html
20:43:56 <Eduard_Munteanu> I'd start with bananas.
20:43:59 <ksf> does that fit your tastes?
20:43:59 <aristid> chessguy: these docs are really outdated
20:44:11 <aristid> chessguy: here, Digit is not listed: http://www.haskell.org/ghc/docs/7.0.1/html/libraries/base/Control-Monad.html
20:44:14 <dolio> chessguy: Oh, it's from the same package as finger trees.
20:44:20 <dolio> I'd wager.
20:44:21 <roconnor> ksf: well I know what it is.  I'm writing a paper on the topic after all :D
20:44:43 <chessguy> dolio, so...i'm just supposed to know that?
20:44:50 <roconnor> ksf: I'm just wondering if people have already noted that it is both a coalgebra of a comonad and/or a monoidal natural transformation.
20:44:57 <dolio> No. It should have a link to the definition.
20:45:00 <ksf> possibly.
20:45:02 <aristid> chessguy: you're supposed not to use outdtaed documentation :)
20:45:06 <ksf> but if I did, not in those term.
20:45:07 <ksf> s
20:45:14 <dolio> But it didn't get generated that way for some reason.
20:45:23 * roconnor needs to finish his paper :D
20:45:24 <chessguy> dolio, ah, gotcha
20:46:21 <ksf> you might not believe it, but I was capable of doing transformations based on fmap f . fmap g = fmap (f . g) way before I first heard the word functor.
20:46:37 <chessguy> aristid, http://www.haskell.org/ghc/docs/7.0.1/html/libraries/base/Control-Monad.html#t:Functor isn't much better. e.g., it says that IO is an instance of Functor, but neither in the source of Functor, nor in the source of IO (which is at least linked) is the implmentation shown
20:47:06 <ksf> IO is implementation-dependent.
20:47:14 <ksf> i.e. don't look at its implementation.
20:47:30 <aristid> chessguy: there's a non-exported Digit type in http://hackage.haskell.org/packages/archive/fingertree/0.0.1.0/doc/html/src/Data-FingerTree.html
20:47:36 <aristid> chessguy: but you can't use that :)
20:47:56 <roconnor> @free fmap
20:47:57 <lambdabot> Expected variable or '.'
20:48:07 <chessguy> aristid, that's not an instance of Functor
20:48:16 <aristid> chessguy: and you can't expect the blackbox implementation of IO to be shown anywhere besides the low-level GHC source code :)
20:48:32 <chessguy> ...
20:49:03 <aristid> chessguy: right, your GHC 6.6 documentation source maybe contained some type Digit somewhere
20:49:15 <chessguy> maybe...
20:49:15 <aristid> GHC 6.6 is really outdated :)
20:49:22 <roconnor> ksf: tell me more about your life before knowing what a functor was.
20:49:54 <roconnor> I'm not sure I understand your comment
20:50:16 <roconnor> you are saying you understood that fmap f . fmap g = fmap (f . g) before you knew it was a functor law?
20:50:25 <ksf> yes.
20:50:44 <roconnor> how did you know.  By generalizing from all the implementations of fmap that you knew?
20:51:05 <Eduard_Munteanu> (By similarity with 'map'?)
20:51:07 <ksf> by not writing stupid for-loops.
20:51:31 <roconnor> I don't see how that follows
20:51:36 <chessguy> ok, well, at least most of the types listed as instances of Functor in http://www.haskell.org/ghc/docs/7.0.1/html/libraries/base/Control-Monad.html#t:Functor actually show instance implementations
20:51:37 <ksf> why loop twice if you can loop once?
20:51:40 <chessguy> finally a plus
20:51:54 <roconnor> yes, but how did you know it would work for all isntances of Functor?
20:52:10 <roconnor> or did you just care about the instances you would use in your program?
20:52:29 <ksf> well, once I heard the word I identified "functor" as a proper term for the structure I knew.
20:53:00 <monochrom> I would say that means generalizing from examples like []
20:53:07 * Eduard_Munteanu retreats to his own ivory tower, in need of sleep
20:53:11 <ksf> I just don't go out and invent terms for every abstraction and law I've ever discovered while _doing productive work_
20:53:20 <roconnor> ksf: I don't quite understand how you were using fmap without coming across the word Functor.  It is part of the signature.
20:53:24 <Eduard_Munteanu> o/
20:53:31 <roconnor> Eduard_Munteanu: good night
20:53:32 <ksf> even before knowing haskell.
20:53:35 <aristid> roconnor: ignoring it?
20:53:40 <Eduard_Munteanu> Good night.
20:54:03 <roconnor> ksf: what language were you using?
20:54:07 <monochrom> ivory tower is for sleep? #haskell is for work and study? :)
20:54:19 <ksf> I think I knew it back in the pascal days
20:54:27 <ksf> (which was the first language we were taught)
20:54:51 <ksf> not in my unprofessional/uneducated days, I think.
20:54:59 <roconnor> you were using a generic fmap written in Pascal?
20:55:14 <roconnor> or a specific fmap for a specific structure?
20:55:15 <ksf> I don't have to use a computer to apply that axiom.
20:55:28 <killerswan> *searches furiously for XKCD P=NP toaster comic*
20:55:57 <ksf> ...I did that transformation in my head a gazillion times, proving it a bit further back in my head.
20:56:02 <roconnor> ksf: there is a big difference from knowing that you can apply that law to map, which you can derive from the code, to apply that law to fmap, which is inherently an abstract function.
20:56:21 <killerswan> http://www.xkcd.com/664/
20:56:32 <ksf> well I definietely was able to apply it to graphs, too.
20:56:54 <roconnor> ksf: sure, again a specific instance
20:57:08 <roconnor> your probably derived the same law for many instances
20:57:22 <roconnor> and then noted this common pattern
20:57:23 <ksf> nope.
20:57:43 <ksf> well, at some time, sure, yes.
20:57:45 <roconnor> and then later found out structures statifying that law had a name
20:58:01 <ksf> but that even before I wrote my first line of code.
20:58:25 <ksf> It's just one of those things one notices.
20:58:33 <ksf> like one notices that stuff tends to fall to the ground.
20:59:06 <ksf> thinking about programming made that understanding conscious, reading the word functor gave it a name.
20:59:09 <roconnor> but I bet you never made an abstract interface to that idea before
20:59:22 <roconnor> and then made generic functions operating on that abstract interface
20:59:33 <ksf> I *am* capable of thinking about my thoughts, so yes, sure I did.
20:59:35 <aristid> one notices that stuff falls to the ground according to s=a*t^2/2
20:59:46 <killerswan> hearing what the greeks thought about gravity is good entertainment
21:00:28 <roconnor> ksf, you mean to say that you were writing some code, over lists or something, and were like, hey might as well make this generic over all functors while I"m at it? (not using the word functor of course)
21:01:44 <ksf> I'm saying that the mental operations I now employ to think about what we call functors here were known and available to me long before I heard that word.
21:02:02 <roconnor> ksf: okay
21:02:03 <aefjt> aristid: only if one lives in a total vacuum on a uniform gravitational field
21:02:26 <aristid> aefjt: at least the latter is approximately true :)
21:03:01 <roconnor> ksf: that made it easy to understand Functors when you saw them.
21:03:52 <ksf> ...trivial.
21:04:12 <ksf> monads were a bit more of a stretch.
21:04:33 <roconnor> ksf: but that position is still far from being able to create and use the functor abstraction by yourself.  This is where knowing category theory might make you a better programmer, which I think was the original comment I made that motivated this thread.
21:04:34 <ksf> basically, I had to understand cps.
21:04:46 <aefjt> Compilers also do the opposite, splitting loops
21:04:59 <Philippa> you only really need to understand CPS for monad innards, and that's only one implementation strategy
21:05:01 <monochrom> I am not sold to "if you haven't done this at the code level, you haven't done this"
21:05:05 <ksf> well, I don't doubt that CT can teach you to spot those abstractions
21:05:08 <Philippa> these days I kinda like the explicit interpreter approach
21:05:11 <ksf> ...just by means of massive practice.
21:05:14 <robinhoode> I have to agree with ksf's sentiment. I had about 3-4 solid years of relaitvely abstract programming experience before taking my first proofs course in college. On one of the tests, my prof asked us to find a function that takes f : A -> B to a function from P(A) -> P(B) (P = powerset) and I managed to guess it was (what he called) the image.. I don't think anyone ever finished his tests before, but I finished that one.
21:05:16 <Philippa> you couldn't comfortably do it pre-GADTs though
21:05:28 <aefjt> So saying that the functor law "lets you loop once instead of twice" is hardly a complete description
21:05:41 <roconnor> ksf: I'm not sure the practice is important as being told by others that the abstractions exist.
21:06:01 <aristid> :t flip concatMap
21:06:01 <lambdabot> forall a b. [a] -> (a -> [b]) -> [b]
21:06:03 <robinhoode> Later on I found out that it was called the powerset functor
21:06:23 <robinhoode> But it was really just fmap on sets
21:06:52 <Philippa> it's /one/ fmap on sets
21:08:32 <killerswan> i think we can agree there are many ways to learn anything worth learning
21:08:32 <aefjt> Well, I think ontology is real. There is a qualitative difference between arriving at the functor laws by intuition, and deriving them by formal methods
21:09:07 <roconnor> oh yes
21:09:38 <roconnor> When I say that learning Category Theory probably makes you a better programmer is not to say that you should learn Category Theory.
21:09:52 <roconnor> There might be all sorts of other more effective ways to make you a better programmer
21:09:57 <roconnor> or a better person
21:10:00 <aristid> killerswan: and that all generalisations are wrong?
21:10:20 <aefjt> @quote generalisation
21:10:20 <lambdabot> benmachine says: unsafeCoerce is just a generalisation of id
21:10:35 <roconnor> I certainly find it easier to leave it to others to learn category theory and just implement libraries in Haskell.
21:10:55 <robinhoode> BTW my experience was mostly with Python/Ruby prior to the course, so I was probably slight worse off in terms of understanding the formallity of types necessary to understand what a funtor actually was
21:10:59 <roconnor> but presumably I'd be a better progammer if I learned category theory myself and wrote the libraries
21:12:27 <killerswan> aristid: indeed
21:12:51 <monochrom> I am not sure what "deriving the functor laws by formal methods" means in this context or whether it's relevant.
21:13:23 <monochrom> Consider also "deriving the ZF axioms by formal methods"
21:13:31 <aefjt> Sorry, try "applying"
21:14:41 <monochrom> "applying the functor laws by formal methods"? ok, I am not sure comparing "arriving at the functor laws by intuition" and "applying the functor laws by formal methods" is comparing like with like.
21:15:00 <Philippa> I think that's the point :p
21:15:31 <aefjt> Going from applications of the laws to laws won't get you to the applications you'd never thought of
21:15:56 <monochrom> I am not even sure of the meaning of them.
21:16:03 <Philippa> not without a pattern-matching phase as well, sure
21:16:31 <Philippa> but it sure makes the pattern-matching easier
21:16:31 <SailorReality> hey did you guys see this? http://www.reddit.com/r/programming/comments/es29o/the_air_on_which_haskell_programmers_seem_to/?sort=top
21:16:55 <roconnor> SailorReality: weve been talking about it for the last hour :D
21:17:30 <monochrom> "arriving at the functor laws by intuition" to me means: consider the first guy who defined functors. He/She saw a pattern coming, intuited about it, then finally wrote down: "Definition: A functor is ..."
21:18:02 <roconnor> monochrom: a very difficult step
21:18:33 <monochrom> That activity is a process of invention. It's orthogonal to "applying the functor laws by formal methods". "applying the functor laws by formal methods" isn't even invention.
21:18:39 <dolio> A functor is the obvious structure-preserving mapping between categories.
21:18:43 <CESSMASTER> hey i was gonna use haskell but then some guy told me it's cargo cult???
21:19:02 <Philippa> yeah, you listened to a cargo cultist :p
21:19:16 <killerswan> invention? I'm sure the USPTO would let you patent it... :P
21:19:20 <aefjt> monochrom: it was a response to ksf's "I saw the functor laws by writing loops in pascal"
21:19:48 <roconnor> monochrom: I'd like to add that there is a big difference between applying the map (f . g) = map f . map g law and applying the fmap (f . g) = fmap f . fmap g law
21:20:01 <aristid> killerswan: you need to say it works on a physical computer, then it might work
21:20:21 <monochrom> So I am not sure what "there is qualitative difference between being an inventor and being a user" means. Comparing apples with oranges?
21:20:22 <ksf> aefjt, it's the same thought as "gosh that thought about that thought was really telling".
21:20:29 <Philippa> aristid: for values of "physical computer" that can be met by a description of a turing machine, yeah :-)
21:20:37 <applicative> CESSMASTER, it's okay, it turns out that some undergraduate bloggers in St Paul are morons
21:20:37 <aefjt> aristid: if you read some of the patents there, you'll find that that step is sometimes optional
21:20:46 <ksf> ...as a thought about a thought is a function mapped over said thought.
21:21:04 <aristid> Philippa: i don't think any computer is really a turing machine :P
21:21:07 <Philippa> applicative: now now, how are we going to be superior about this if we're just as big a bunch of arseholes as everyone else? :-)
21:21:25 <aristid> aefjt: maybe it is just implicit? :D
21:21:29 <Philippa> aristid: it's enough to say "sufficient" tape :p Someone's built one somewhere
21:21:43 <roconnor> Philippa: is right.  I really want to understand the motivations of the author.
21:21:47 <applicative> Philippa, I agree of course.  For some reason the conal and mauke bit has me in an irrational rage.
21:21:50 <roconnor> s/://
21:21:57 <dolio> I don't understand why you'd need to 'intuit' the 'functor laws'.
21:21:59 <ksf> ...the thought about (a thought about a thought) thus is the very essential thought about the nature of functors.
21:22:16 <dolio> I don't need to observe lots of groups to intuit the 'group homomorphism laws'.
21:22:18 <ksf> ...in the general case, that is.
21:22:23 <ksf> usually it's more concrete.
21:22:30 <ddarius> dolio: They are completely intuitive.   A functor is a "category homomorphism."
21:23:09 * ksf thinks we should map the basic thought processes in category theory.
21:23:16 <killerswan> aristid: the USPTO and patent bar just sort of winks and nods.  yes, i see you have a "special purpose computer" there...
21:23:23 <invarius> Would anyone like to point out the performance difference between compiled haskell and interpreted haskell? While there's are some amazing features I like in haskell, I would certainly not want to manage enormous amounts of data with a loss of performance in comparison to speed (though, I'd probably lose a lot more time in C debugging)
21:23:31 <invarius> Thanks :)
21:23:44 <killerswan> where special purpose computer is x86, running java...
21:23:50 * applicative points out that this has been done, though he can't vouch for the merits
21:23:56 <dolio> The difference is right there.
21:23:58 <turiya> Can someone point me to an introductory material on how memory is managed by ghc?
21:24:01 <Philippa> invarius: substantial, because the interpreter also won't run the optimisation passes - it's not as simple as a constant factor
21:24:03 <aristid> invarius: GHC's compiled haskell has pretty good performance.
21:24:22 <aefjt> invarius: um, if your interpreted code is too slow or uses too much memory, you compile it
21:24:37 <ddarius> ksf: I think I've actually seen someone who was trying to do that.
21:24:43 <Philippa> GHC with the optimisations on can do some really impressive things, and there are definitely situations where it can match C or beat naive C
21:24:46 <invarius> aristid: That's pretty relative, could you be more specific
21:25:03 <invarius> I see, I see.. Thank you :)
21:25:08 <aefjt> The ghc interpreter can mix compiled and interpreted modules.
21:25:19 <invarius> Do you have any examples I could look at?
21:25:20 <ksf> CT would definitely make for a better basis for a language that predicate logic.
21:25:39 <ksf> I always considered lojban to be quite boring in that regard
21:26:31 <invarius> I would really like to make use of haskell for my upcoming projects, as this language seems extra special and unique to my project. If I can invest my time into it, I will. Especially being that there are so many apis available and even a desktop :D
21:26:32 <applicative> ksf, you dont want 'and' 'or' 'not' 'some' and 'all' in your language?  What else is there in 'predicate logic'?
21:26:52 <monochrom> for all, for some
21:27:04 <ksf> lojban is predicate logic in the sense that every sentence is a predicate logic term.
21:27:19 <monochrom> A suitable category subsumes predicate logic, so you don't lose operators, you gain more operators
21:27:20 <papermachine> I would say lojban is based in predicate logic
21:27:22 <invarius> Are there any recommended books? I don't care so much for the syntax, but more the language features, the use of categorial mathematics, etc etc
21:27:25 <papermachine> Not that lojban is predicate logic.
21:27:41 <aefjt> invarius: if you're just in here to see the marketing, look at the http://shootout.alioth.debian.org/
21:27:57 <ksf> one might for example be "house (owner-is pete) (inhabitant-is joe)" (that's named arguments, there)
21:28:16 <applicative> invarius, the standardly recommended starter tutorial is "Learn You a Haskell for Great Good", then the big book "Real World Haskell"
21:28:19 <ksf> lojban uses positional syntax, so that'd be just "house pete joe"
21:28:28 <papermachine> ksf: not really.
21:28:37 <invarius> aefjt: marketing? No, it's a language I want to put use but if it's a quest like c++ where that's all I'll ever see, I cannot put forth the time if the gain is at a minimal
21:29:03 <aefjt> invarius: no, I mean the shootout results are our marketing
21:29:06 <invarius> applicative: Okay, I've seen that book, "real world haskell", but, it wasn't very math heavy
21:29:08 <ksf> yeah, pete house joe.
21:29:11 <papermachine> ksf: for starters, zdani doesn't have that place syntax
21:29:17 <papermachine> http://en.wiktionary.org/wiki/zdani
21:29:24 <invarius> aefjt: I see
21:29:25 <Axman6> invarius: maybe ypou could be more specific about what you want
21:29:38 <papermachine> you'd have to extend it with selma'o BAI
21:29:51 <aefjt> invarius: what "math" are you doing?
21:29:51 <applicative> invarius no, I think you will need to be a bit further into it to get more specific advice
21:30:00 <ksf> I don't actually speak lojban, I just wanted to convey the gist.
21:30:14 <invarius> aefjt: category theory, formal language, etc
21:30:18 <papermachine> You're making it look like something it isn't to support a strained metaphor.
21:31:26 <ksf> ...that strained methaphor predicate logic is the base of most languages, actually.
21:31:40 <ksf> humanity still hasn't moved on from sokrates
21:31:52 <aefjt> invarius: if you want to learn category theory, you should probably read a category theory book, not a Haskell programming book
21:32:02 <ksf> heck most people can't tell a predicate from an implication.
21:32:10 <CESSMASTER> suckers
21:32:13 <applicative> invarius, you need to learn how the type system operates, then you'll see how e.g. category talk fits the case. -- and what aefjt said
21:32:14 <Philippa> implies(A,B) :p
21:32:16 <papermachine> imo there aren't any good self-contained ct books around
21:32:16 <j-invariant> If you want to learn Category Theory you should watch Youtube
21:32:34 <j-invariant> http://www.youtube.com/user/TheCatsters <-- this is a good way to learn some basics
21:32:37 <papermachine> mostly because all the good examples of things are in other fields
21:32:54 <ksf> what I'm arguing for is a language that, if one is able to speak it, ensures that one understands what rigirous logic is about, at least on an intuitive level.
21:33:00 <roconnor> hah, Smith writes in his comment "Thanks for this. I didnt know of default before."
21:33:19 <ksf> lojban, that is, from my pov isn't strong enough to fulfill its saphir-worf goal.
21:33:23 <applicative> roconnor, yes, the idiocy goes on and on.  
21:33:34 <roconnor> Now I kinda wish that Haskell had an empty default by default, so he would have encountered this "problem" from day 1, and not considered it a problem.
21:33:44 <aefjt> invarius: you don't really need more than a superficial understanding of category theory to use most of Haskell
21:33:53 <j-invariant> roconnor: are you talking about symbo1ics
21:33:59 <invarius> aefjt: I'm not "learning" category theory, I'm using what I've learned from it, and haskell seems to be all over it
21:34:03 <roconnor> j-invariant: yes
21:34:03 <aristid> aefjt: i think it works without any at all
21:34:15 <ksf> I think primitives that speak about different elements of logic, that is, an abstract logic, should be the base of the language.
21:34:33 <applicative> aefjt, on the other hand, Haskell contains surprisingly good illustrations.
21:34:33 <aefjt> It's supposed to, hence evocative class names like Monad and Functor
21:34:51 <roconnor> aefjt: arguably all of computer science is all over it, although they seems to be largely unaware of this fact.
21:34:54 <monochrom> most natural languages have modal logics. several of them too. "you must eventually quit" two orthogonal modal logics used, a normative logic and a temporal logic.
21:34:55 <ddarius> As entertaining as the Catsters lectures are, I think you'd already need to be reasonably mathematically sophisticated to get a lot out of them.
21:35:01 <roconnor> er
21:35:06 <roconnor> invarius: arguably all of computer science is all over it, although they seems to be largely unaware of this fact.
21:35:14 <j-invariant> ddarius: hah! that's the nicest compliment
21:35:26 <aefjt> I don't want to see the category theoretic model of java
21:35:27 <ddarius> You don't need any understanding of category theory at all to use any of Haskell.
21:35:28 --- mode: ChanServ set +o ddarius
21:35:43 <ddarius> shapr: ?
21:35:45 * shapr grins
21:35:47 <roconnor> aefjt: I saw a paper describing the monad stack that is java
21:36:00 <invarius> You're all missing the fact my project is heavily based on many of its assets
21:36:03 <aefjt> Thanks, I'll avoid it
21:36:10 <ksf> monochrom, see that's what I'm talking about.
21:36:22 <invarius> that's mainly why I want to use haskell, it's a lot easier
21:36:35 <Philippa> invarius: so describe your project in more detail?
21:36:35 <j-invariant> roconnor: I read it but I don't see the controversy
21:36:45 <monochrom> well then most natural languages already far exceed predicate logic.
21:36:52 <ksf> now do a language that allows me to say ""you must eventually quit" temporal-aspect mapped by "soon""
21:36:56 <ksf> or something like that.
21:37:12 <invarius> Philippa: there's no need, I didn't have a question about it.
21:37:27 <shapr> roconnor: That sounds nifty... what's the paper?
21:37:27 <aefjt> I thought the concept of "modal logic" was invented specifically to study natural languages
21:37:33 <ksf> ...I actually meant first-order logic.
21:37:38 <roconnor> j-invariant: I didn't really understand the post myself
21:37:42 <invarius> Anyways, I think i'll try and see what happens :p
21:37:47 <invarius> }part
21:37:48 <j-invariant> I just read it now
21:37:51 --- mode: ddarius set -o ddarius
21:38:04 <roconnor> shapr: I'm afraid I don't recall the name or authors
21:38:11 <c_wraith> :t liftA2 (<$>)
21:38:12 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Applicative f1) => f1 (a -> b) -> f1 (f a) -> f1 (f b)
21:38:13 <applicative> aefjt, Aristotle invented modal logic in the 4th c BC
21:38:16 <c_wraith> I think I'm going too far
21:38:43 <thermoplyae> is there such a thing
21:38:46 <ksf> a natural language with primitives for reflection might be another way to put it.
21:38:54 <j-invariant> http://symbo1ics.com/blog/?p=788#comment-883 -- this guy is SHOCKED
21:39:01 <ksf> real primitives, that is, not just elaborate self-referential descriptions.
21:39:12 <applicative> j-invariant, no he's evil
21:39:14 <ksf> primitives that you can't ignore as a speaker.
21:39:24 <aristid> j-invariant: he wrote the first haskell compiler
21:39:27 <j-invariant> "There was no category theory influence when Haskell was originally designed." <-- is that true?
21:39:32 <j-invariant> I thought haskell was based on ocaml
21:39:39 <applicative> j-invariant, you mean lennart a
21:39:43 <ddarius> If one is interested in category theory, I recommend Steve Awodey's book or, free, shorter, and more CS-oriented, Barr and Wells' ESSLLI lecture notes.
21:39:54 <applicative> j-invariant, he is a God among men. 
21:40:09 <dolio> OCaml? What?
21:40:10 <roconnor> j-invariant: augustss always looks like that
21:40:23 <Philippa> j-invariant: Lazy ML was an ancestor, ocaml postdates haskell
21:40:23 <applicative> the picture is great
21:40:29 <aefjt> j-invariant: http://research.microsoft.com/en-us/um/people/simonpj/papers/history-of-haskell/
21:40:31 <monochrom> well, then, god is shocked :)
21:40:31 <shapr> Lennart Augustsson is an amazing guy.
21:40:32 <j-invariant> oh thanks Philippa 
21:40:53 <shapr> roconnor: If you run across it again, I'd like to hear about it.
21:41:05 * ddarius also agrees that Lennart is pretty amazing.
21:41:22 <roconnor> shapr: did you google java and monad ... actually maybe that won't work
21:41:52 <roconnor> shapr: http://www.springerlink.com/content/fe62grwrv75mkbcf/
21:41:58 <applicative> augustss also devised Lazy ML
21:42:09 <roconnor> this seems likely the research I was thinking of, since it was conducted at the university I was attending
21:43:07 <monochrom> onoes, Bart Jacobs
21:44:30 <shapr> roconnor: thanks!
21:44:55 <j-invariant> has anyone succeed in using haskell for what this blog post tried to do?
21:45:20 <shapr> Which blog post is that?
21:45:36 <j-invariant> http://symbo1ics.com/blog/?p=788
21:45:36 <monochrom> "haskell for mathematicians" is doomed to be like "gnuplot for programmers".
21:45:39 <roconnor> j-invariant: what was the blog post trying to do?
21:46:14 <j-invariant> roconnor: it's like programming a typed computer algebra system
21:46:16 <aefjt> @hackage numeric-prelude
21:46:16 <lambdabot> http://hackage.haskell.org/package/numeric-prelude
21:46:49 <roconnor> j-invariant: oh. Heh that is the research project I work on
21:46:55 <ksf> a "computer algebra system"? like... a term rewrite library?
21:47:07 <roconnor> monochrom is right.  Haskell is doomed for such a task
21:47:11 <ksf> ...or a library of term rewritings for a particular algebra?
21:47:19 <monochrom> maple and mathematica are computer algebra systems
21:47:23 <roconnor> though it seems tantalizing.
21:47:59 <ksf> I can't say I'd know off the top of my hat how to write one, but I'm sure I wouldn't start with class Eq a => Monoid a ...
21:48:15 <monochrom> generally "<programming language> for mathematicians" is doomed to be like "VCR for programmers"
21:48:51 <ddarius> monochrom: What's wrong with Bart Jacobs?
21:48:53 <Philippa> the only good VCR for programmers is one that you can control easily from a computer with a sensible core command set
21:49:09 <monochrom> I adore Bart Jacobs. Nothing wrong.
21:49:13 <Philippa> I'm not sure the equivalent applies for "programming language for mathematicians"
21:49:59 <ksf> Philippa, http://www.linuxtv.org/vdrwiki/index.php/Main_Page
21:50:36 <ksf> I find it highly suspicious that he's writing that post without a firm grasp of haskell.
21:50:54 <ksf> sounds like me writing "category theory for haphazard haskell hackers"
21:50:58 <aefjt> /dev/betamax
21:51:04 <ksf> ...which is the thing he's complaining about.
21:51:04 <monochrom> "Coq for mathematicians" may work
21:51:08 <CESSMASTER> ksf: or you talking about lojban
21:51:14 <ksf> touche.
21:51:26 <thermoplyae> it's a blog post, idk if you can expect extreme competency
21:51:33 <roconnor> ksf: clearly only someone without a firm grasp of haskell could write such a post.
21:51:34 <thermoplyae> or just competency
21:51:37 <aefjt> Nah, coq is firmly for programmers.
21:51:42 <monochrom> heh heh heh
21:51:52 <Philippa> aefjt: it's programmersexual?
21:51:57 <ksf> though I must defend myself and say that I merely wanted to explain how "lojban is based on predicate logic" is to be interpreted.
21:52:09 <aefjt> Programmers don't have sex
21:52:20 <monochrom> they have gender
21:52:27 * Philippa will have to tell her girlfriend that, she'll be shocked
21:53:00 <j-invariant> is category theory in general useful for programming?
21:53:05 <j-invariant> or is it just monads
21:53:19 <monochrom> pushout solves the diamond problem
21:53:21 <ksf> is thinking useful for byclicle repairs?
21:53:34 <roconnor> j-invariant: it is useful for specific kinds of programming ... the generic kind .
21:53:50 <monochrom> co-limit backs recursive data types
21:54:01 <j-invariant> category theory doesn't seem to actually do anything - it's just like boxes you put your programs in
21:54:15 <Philippa> j-invariant: if you like abstraction, the field of "abstract nonsense" may be useful
21:54:21 <j-invariant> I had thought that category theory would just magically solve everythign for you.
21:54:33 <Philippa> sure, given infinite time and space and patience
21:54:45 <Philippa> the same can be said of set theory though, and you've still got to find the bits of 'everything' you care about
21:54:46 <thermoplyae> if you have those things, you don't need categories
21:55:03 <aefjt> That's like saying you don't want to bother learning calculus when all you want to do is solve differential equations
21:55:07 <roconnor> j-invariant: category theory at the very least has a bunch of predefined abstractions that occur regularly in programming
21:55:23 <roconnor> j-invariant: it turns out programming becomes easier when you follow these abstractions
21:55:29 <j-invariant> I read the paper, Moggi uses category theory to guide programming language design
21:55:33 <roconnor> j-invariant: and I find these abstractions very non obvious
21:55:34 <monochrom> I surely appreciate boxes holding my stuff in my bedroom even though they "don't seem to do anything".
21:55:45 <bsmntbombdood> roconnor: what sort of abstractions are you talking about?
21:56:13 <roconnor> bsmntbombdood: monads, comonads, monoidal functors, ...
21:56:27 <roconnor> algebras, coalgebras
21:56:29 <Philippa> j-invariant: right, so haskellers use them to guide /embedded/ language design
21:57:04 <Philippa> j-invariant: not only that, but to abstract across a class of embedded languages, so that we have things like control structures that can be written once
21:58:15 <roconnor> http://news.ycombinator.com/item?id=2043349 -- I wish someone would add Haskell to 	reikonomusha 's comment
21:59:25 <j-invariant> using category theory you can specify a program
21:59:31 <j-invariant> but implementing it is not category theory
21:59:41 <j-invariant> that is how it looks to me now, is that true
21:59:57 * ddarius doesn't understand people trying to find reasons to learn category theory.  If you aren't interested in it, ignore it.  If you are interested in it, learn it.
22:00:12 <Philippa> eh, that's all a matter of how you squint: define a categorical semantics for haskell and implementing in haskell is indeed category theory
22:00:19 <monochrom> I don't know. s/cateogry theory/editor/ and try again.
22:00:55 <monochrom> hell, some editors inspire my haskell programs too. or java programs.
22:01:10 <monochrom> (auto-completion)
22:01:16 <Philippa> If you specified the program in categorical terms in a way that you can extract computational content from, the implementation is likely to involve some kind of embedding of category theory
22:01:24 <j-invariant> I would like to know what are some of the uses of category theory for actual programming (not just the study of programming)
22:01:27 <Philippa> that is, you'll end up wanting to embed CT and write the spec down
22:01:39 <Philippa> j-invariant: I just gave you one above - embedding a class of languages into haskell
22:01:41 <dolio> Go look up Charity.
22:01:43 <dolio> The language.
22:01:47 <j-invariant> Philippa: is that posible in haskell though?
22:01:57 <killerswan> w00t, i am now running leksah
22:02:38 <ddarius> Philippa: I wouldn't say that.
22:02:44 <Philippa> j-invariant: not only possible but done regularly. In fact, there are libraries for specific classes of embedded languages, for building embedded languages of given classes in a lego-like fashion, for control structures that exist across a class of languages...
22:02:51 <monochrom> let me torture killerswan with "what does leksah really do to my programming" :)
22:04:04 <Philippa> ddarius: well, we use something at least pretty close to the CT constructs specialised on a specific category that happens to represent haskell
22:05:50 <ddarius> Compiling unification from arbitrary pattern matching to only equality constraints can be done by essentially taking a proof that equalizers, products, and a terminal object imply all finite limits, but you don't really need to "embed category theory" to realize the result in code.
22:06:44 <Philippa> ddarius: fair enough
22:07:51 <monochrom> there is no contradiction between the two examples.
22:07:53 <Philippa> and on that note, for j-invariant's benefit: languages for constraint gathering and solving are a traditional thing to embed as a monad or an applicative, especially if you might want backtracking
22:08:13 <killerswan> monochrom: I need all the help i can get since I'm a noob :D
22:11:06 <monochrom> there is a lot of "what will category theory do for me" because it is perceived to be costly to learn. but I think category theory is pretty cheap to learn.
22:11:08 <roconnor> Philippa: um, what time is it there?
22:12:02 <killerswan> regarding editors, i suspect a lot of category theory is easier to learn than emacs
22:12:27 <ddarius> monochrom: No one is telling these people to learn category theory.
22:12:29 <j-invariant> simple data types in haskell are initial algebra
22:12:38 <j-invariant> but nobody uses 'initial algebra' in haskell
22:12:39 <roconnor> j-invariant: we pretend they are
22:12:41 <monochrom> I even dare say less effort to learn than getting leksah (and more importantly its kind of aged dependencies) to install. But no one really asks "what will leksah do for me".
22:12:45 <ddarius> j-invariant: Yes they do.
22:13:37 <roconnor> j-invariant: and in fact they actually are, but the initial algebra we pretend they are isn't the same as the initial algebra that they actually are (different categories)
22:13:52 <Philippa_> can someone PM me what I missed while reconnecting?
22:13:53 <monochrom> Quite some of us mention "catamorphism" all the time. That's initial algebra.
22:14:04 <ddarius> Philippa: I don't think you missed anything.
22:14:09 <roconnor> Philippa: um, what time is it there?
22:14:44 <djahandarie> Catamorphism? Is that related to cats?
22:14:45 <Philippa_> roconnor: I'm a looong way out of sync with the local time zone anyway :-) I got killerswan's "I need all the help..." and your comment to j-invariant above
22:15:54 <ksf> catamorphisms are related to catastrophes.
22:16:00 <ksf> they tear structures down.
22:16:01 <ddarius> Philippa_: There's also the TUNES log.
22:16:07 <dolio> monochrom said that learning category theory isn't that hard. And j-invariant said that no one uses 'initial algebra' in Haskell.
22:16:12 <ksf> anamorphisms are related to anabolica
22:16:21 <dolio> That's all you missed.
22:16:31 <Philippa_> dolio: cool, that's the context I was missing
22:16:45 <Philippa_> and... well, if I were looking to generate surprisingly knowledgeable lulz...
22:16:45 <ksf> ...and combinations of them aren't called katanamorphisms but hylomorphisms, hylo is greek for wood, matter.
22:16:53 <ksf> ...which refers to the cycle of elements.
22:16:57 <j-invariant> Philippa_: the simple data types are initial algebras, but there is no "initial algebra" typeclass or anything in haskell
22:17:00 <Philippa_> and yeah, we all use initial algebra and final coalgebra
22:17:07 <Philippa_> why would there be one?
22:17:08 <ksf> phoenixmorphism might've been a better term.
22:17:13 <Philippa_> (well okay, I know a few good reasons...)
22:17:16 <roconnor> Philippa_: http://tunes.org/~nef/logs/haskell/10.12.27
22:17:35 <Philippa_> people do use the initial algebraness of ADTs though
22:17:38 <monochrom> I like ksf's analogies and new naming :)
22:17:43 <j-invariant> Philippa_: yes exactly what I mean
22:18:06 <ddarius> j-invariant: There are quite a few Algebra types.
22:18:20 <ddarius> j-invariant: You don't want a type class but rather simply: type Algebra f a = f a -> a
22:18:38 <j-invariant> you can just progrram to your hearts content - the fact that your stuff fits into category theoretic terms is just an observation, not part of the program
22:19:03 <roconnor> j-invariant: This is techinically true I think
22:19:24 <ksf> anamorphisms are functors from the category of geeks to that of quarterbacks?
22:20:01 <djahandarie> Algebras are boring. I prefer GDialgebras. GDialgebra f g w m a = f (w a) -> g (m a)
22:20:12 <ddarius> At any rate, I still don't see the point of this line of questioning.
22:20:16 <roconnor> j-invariant: however if you use category theory to create an abstraction in your program, then you've done something I suppose.
22:20:18 <Philippa_> j-invariant: technically that would be true /even if you programmed in a raw syntactic embedding of CT/ though
22:20:30 <Philippa_> welcome to the idea of embedding languages in each other
22:20:51 <monochrom> I know people who say "you can just crunch bits to your hearts content - the fact that your bits represent data structures is just an observation, not part of the program"
22:21:22 <Philippa_> monochrom: to which all I can say is - what are these "bits"?
22:21:22 <roconnor> :)
22:21:24 <monochrom> In fact I also know people who say "you can just pass electric currents..."
22:21:36 <Philippa_> and likewise electric currents...
22:21:44 <monochrom> high five!
22:21:49 <j-invariant> I don't find this analogy fitting: When we program high level there are lots of different possible implementations in terms of bits for what we wrote
22:22:18 <j-invariant> when we program haskell we literrally use Int or data Tree a = ..., thesea re one of many possible implementatitons of the category theoretic specification
22:22:42 <Philippa_> what's this /the/ specification, and who are you to identify it?
22:22:59 <BMeph> ...and How are you to identify it? :)\
22:25:25 <Philippa_> also, polymorphism: it is your friend
22:26:00 <Philippa_> (yeah, okay, so we have a particular category that we tend to start with when using the usual techniques, so what?)
22:28:46 <Philippa_> to put it another way: it's enough to indicate (which is, admittedly, done informally around here) which mapping we have in mind
22:28:56 <killerswan> regarding leksah: one concern is the opportunity cost of using it
22:29:28 <killerswan> if I can't get yi going within it, i'll have to find a reason sufficient to overcome the loss of all my vi[m] abilities...
22:29:32 <monochrom> is about a few megabytes of disk space, I believe
22:30:30 <ddarius> killerswan: Or you could just stick with yi/vi/vim/whatever you are currently using...
22:30:41 <killerswan> likewise, if you go to learn category theory, there's something else you're not learning in that time
22:31:00 <monochrom> such as java
22:31:05 <killerswan> ddarius: that may be what i do
22:32:11 <killerswan> monochrom: or .NET
22:33:11 <ddarius> Moral of the story: Get off IRC and go hiking in the Andes.
22:33:19 <djahandarie> ...
22:33:35 <monochrom> not too interested in the Andes.
22:33:42 <Gracenotes> Appalachian trail will suffice I hope
22:34:06 <ddarius> Gracenotes: I may be doing just that in a couple of days.
22:34:18 <c_wraith> no, no.  hiking in the appalachians is code for "in brazil with your illicit lover"
22:34:27 <j-invariant> Philippa_: so what about a two level programming language: One is haskell where you program and ontop of that (like sort of like types) we have the category theory which coordinates it all@
22:34:38 <Gracenotes> ddarius: bundle up..
22:34:51 <ddarius> Gracenotes: Well equipment is the reason I didn't go yesterday.
22:35:07 <djahandarie> What do you gain from hiking in the Andes?
22:35:25 <Gracenotes> water? compass? hiking pole? money? snacks? gloves? scarf? hat?
22:35:28 <Gracenotes> so many ways to accessorize
22:35:41 <killerswan> languages are just tools, just like ice axes, etc.
22:35:56 <ddarius> djahandarie: A hell of a lot more life experience, confidence, and exercise than you do on IRC.
22:36:13 <ddarius> Gracenotes: The main thing I'm lacking right now is waterproof clothing.
22:37:05 <killerswan> i need a good wetsuit, but that's another story
22:38:15 <killerswan> often we learn tangential things: half my goal in installing leksah is to become even barely competent with cabal
22:38:18 <monochrom> wait, money as an accessory in the Andes?
22:38:50 <ddarius> monochrom: That was for Appalachian Trail, but money is a useful thing to have around almost anywhere.
22:39:11 <ddarius> monochrom: In the absolute worst case you could use it for tinder.
22:39:29 <Gracenotes> don't forget a towel either
22:39:36 <Philippa_> j-invariant: CT in the widest sense isn't computable. We actually use haskell /as/ the layer two language a lot though (except more as layer zero)
22:42:55 <Gracenotes> hm. I'm getting better than 10 KB/s. good.
22:44:11 <BMeph> Ooh! "# B. Jacobs, Introduction to Coalgebra. Towards Mathematics of States and Observations. Two-thirds of a book in preparation; comments are welcome." looks interesting... :)
22:44:37 <monochrom> \/
22:45:17 <ddarius> chip intersected with chop
22:47:19 <CESSMASTER> = 
22:47:55 <BMeph> roconnor: Was this what you read? (http://www.cs.ru.nl/B.Jacobs/PAPERS/AMAST00.ps)
22:51:09 <ksf> you've still got three hours and fourty minutes to decide which 27c3 lecture to view next:   https://events.ccc.de/congress/2010/Fahrplan/day_2010-12-28.en.html
22:51:38 <ksf> ...streams on http://events.ccc.de/congress/2010/wiki/Documentation
22:57:16 <killerswan> night, everybody!
23:27:06 <j-invariant> in Computational Category Theory they use category theory to specify and derive algorithms but in the end the programs they produce are just the actual algorithms.. none of the category framework remains
23:28:29 <j-invariant> it's the same in haskell - all a haskell functor is, is map :: (a -> b) -> (f a -> f b)
23:29:20 <j-invariant> why doesn't this all collapse in the end, and is erasing all that stuff not a handicap?
23:30:27 <Philippa_> what do you mean by 'collapse' there?
23:30:40 <Philippa_> (it "works" because the CT is a good enough model of how the haskell behaves)
23:31:58 <j-invariant> Philippa_: I mean everything seems okay for a while but one day the whole thing falls apart and you just can't do anything because there are problem everywhere
23:32:11 <Philippa_> what kind of handicap do you have in mind? We certainly give the optimiser a workout, and sometimes we have to help it along...
23:32:25 <Philippa_> basically, so long as the CT is a good enough model of the haskell that works out
23:32:50 <Philippa_> and it is a good enough model - it's actually pretty easy to model "fast and loose" haskell reasoning in CT, for example
23:33:32 <Philippa_> "fast and loose" being a reference to a semi-famous paper here btw - basically, so long as you don't care what happens with infinite structures, you can reason as if everything's finite and it works fine
23:34:03 <Philippa_> to put it another way: so long as our haskell models of the CT structures follow the same laws, they /are/ instances of the CT structures
23:34:12 <Philippa_> the rest's just legwork working out how that's the case
23:34:22 <j-invariant> but nobody has written down the CT stuf
23:34:37 <j-invariant> it's just a vauge notion which may not even match up in different programmers minds
23:34:57 <Philippa_> to some extent, except it's a lot less vague than it looks at first glance
23:35:06 <Philippa_> usually the issues are about the extent to which _|_ has been fudged
23:35:33 <dolio> Does their model not have infinite structures?
23:36:00 <Philippa_> dolio: whose?
23:36:10 <dolio> The one in the 'fast and loose' paper.
23:36:46 <Philippa_> dolio: the whole point of it is showing that the 'obvious' embedding of finite-only works
23:37:26 <dolio> I thought it was more bottom-ignoring.
23:37:28 <Philippa_> j-invariant: GIGO is true, but there's surprisingly little G involved, basically. We're not perfectly formal on that front, but it's good enough for an incredibly large amount of work
23:37:42 <Philippa_> right, that's the embedding in question
23:38:02 <Philippa_> if you ignore bottoms everywhere and don't look to prove anything /about/ bottom, your results are valid
23:38:06 <j-invariant> Philippa_: i'm just worried about everything nose-diving someday soon
23:38:29 <Philippa_> j-invariant: "everything"?
23:38:41 <dolio> Ruling out [1..] and such along with that is a little inconvenient.
23:38:46 <j-invariant> Philippa_: programs become more and more essential to our live all the time
23:38:59 <Philippa_> j-invariant: then this is hardly the community to attack first
23:39:33 <j-invariant> I'm learning category theory
23:39:38 <Philippa_> haskell is one of the current sweet spots between being able to reason about stuff and being able to get stuff done. Over time, it'll be less sweet as more powerful options become available
23:40:07 <Philippa_> but if you need to verify your own stuff, /you know what laws to prove/ about the relevant instances
23:41:07 <aefjt> The world doesn't go dark when you turn blind.
23:41:16 <Philippa_> exactly
23:41:42 <j-invariant> aefjt: but it's very hard to find your way walking around with eyes shut...
23:41:57 <Philippa_> you know where coq, agda etc are if you want them
23:42:09 <Kaidelong> ACL2 is nice too
23:44:53 <Philippa_> Idris seems good - I haven't had enough of a play though
23:45:10 <j-invariant> I cannot compile Idris
23:46:14 <Axman6> haskell.orddownrage >___<
23:49:33 <lispy> haskell.org is down again??
23:49:37 <lispy> I thought we just moved it
23:51:08 <Axman6> well, it's not loading for me
23:51:52 <lispy> Actually, I just came here to complain.
23:52:08 <lispy> I didn't realize anyone else was having trouble with it
23:52:16 <lispy> I always use this to check: http://www.downforeveryoneorjustme.com/haskell.org
23:52:51 <lispy> It's pretty much down everytime I need it
23:57:12 <lispy> ?hoogle infixOf
23:57:12 <lambdabot> Data.ByteString isInfixOf :: ByteString -> ByteString -> Bool
23:57:12 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
23:57:12 <lambdabot> Data.ByteString.Char8 isInfixOf :: ByteString -> ByteString -> Bool
