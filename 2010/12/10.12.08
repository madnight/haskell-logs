00:00:47 <kfish> NewUser, you need to use backtracking, what textbook does your course use?
00:01:05 <NewUser> kfish: LYHN
00:01:36 <NewUser> kfish: I have a function array but it doesnt sort 1D array
00:02:50 <NewUser> kfish: I have this http://pastebin.com/DAuPbsDE
00:05:23 <BeginnerHere> NewUser what is the 1D function for again???
00:05:37 <BeginnerHere> NewUser: to print?
00:05:38 <Cale> (\cell -> value cell) cell is the same thing as value cell
00:05:52 <Axman6> value*
00:05:53 <NewUser> BeginnerHere: yes
00:07:10 <NewUser> yes
00:07:18 <NewUser> Cale: yes
00:08:12 <Cale> NewUser: How is this function different from Map.toList?
00:09:08 <Cale> That whole bunch of sortBy stuff just sorts them in the default order
00:09:14 <Cale> You could replace it with sort
00:09:51 <Cale> Or, if you really care about not comparing the elements when all else is equal, then sortBy fst
00:09:51 <NewUser> Cale: I need the cell value because I will use to solve a 1D kenken puzzle
00:10:00 <Cale> er, sorry  sortBy (comparing fst)
00:11:50 <NewUser> Cale: I am solving a 1D kenken puzzle, I have this so far but 1Darray fiunction is giving errors http://pastebin.com/nYwRx8Jh
00:13:18 <Cale> NewUser: cellsMapTo1DValuesArray = Map.elems
00:14:15 <Cale> You've written a bunch of stuff there which doesn't amount to doing anything, because Map.toList already produces the list of pairings in ascending order of their keys
00:14:25 <Cale> and the ordering you've specified is just the usual ordering on pairs
00:14:46 <Cale> and then the list comprehension does... nothing
00:14:58 <Cale> (except slow it down)
00:15:13 <NewUser> Cale: Why  cellsMapTo1DValuesArray = Map.elems? because 
00:15:24 <Cale> Oh wait...
00:15:27 <NewUser> yes
00:15:30 <Cale> That's a nested list comprehension
00:15:36 <NewUser> yes
00:15:44 <Cale> So, it's not even the right type for the type signature you gave
00:16:04 <Cale> Also, it doesn't produce an array. It's producing a list.
00:16:10 <NewUser> Cale: what you mean
00:16:55 <NewUser> Cale: that function is supposed to print the solutions for the KenKen puzzle
00:17:45 <BeginnerHere> Cale: actually it should produce a cellValue
00:17:58 <min> Couldn't you do `array [1..] (M.map M.elems)` or (whatever the array function is), if you wanted one, then?
00:18:09 <BeginnerHere> Because that what the signature is says...
00:18:32 <Cale> The type signature says that it produces a list of CellValue (not an array)
00:18:55 <BeginnerHere> Cale: yes
00:18:59 <Cale> I'm assuming that you actually want it to produce such a list, but the name isn't great.
00:20:33 <BeginnerHere> Cale: I think this function is just used for printed the cellValues in the correct place, I could be wrong???
00:22:08 <BeginnerHere> min: if NewUser did that could they get the [cellValue]
00:22:24 <Cale> BeginnerHere: Maybe?
00:22:40 <Cale> BeginnerHere: None of my comments about it had anything to do with what it was used for :)
00:22:57 <NewUser> Cale: So i had a bunch extra code in there?
00:23:03 <Cale> NewUser: yes
00:23:31 <NewUser> Cale: I was thinking that defining the type will be the best start 
00:23:37 <NewUser> *types
00:24:29 <NewUser> Cale: would you recommend start up with the operations before anything
00:24:32 <NewUser> ?
00:25:26 <Cale> Starting with the types is usually a good policy
00:25:58 <NewUser> oh ok
00:26:09 <NewUser> so that part is no extra code at all
00:27:36 <min> You have to1D :: Map Int Cell -> [CellValue] and CellValue's are Cell fields (`value`). So to1d = M.fold (\x y -> value x : y) [] is a function which takes a Map Int Cell and produces a list of CellValue. This is what you want right?
00:29:11 <NewUser> min: well I am solving the Kenken puzzle in 1D
00:30:08 <BeginnerHere> min: so for Map .. Int would a key and Cell would be the value right???
00:30:38 <NewUser> Cale: I am getting a bunch of error messages http://pastebin.com/JWN9yhJ1
00:30:40 <min> nevermind, I should pay more attention before giving suggestions which clearly have nothing to do with waht's being asked. Sorry :/
00:30:53 <NewUser> min: dont worry
00:31:04 <NewUser> your been nice
00:32:10 <min> That's what happens when you read a function signature and name, then make a function which does what you think the function should do.
00:32:37 <BeginnerHere> min and Cale: What I think NewUser's 1D kenken is suppose to do is that it is a 1D list or array which contains Cages.
00:32:58 <BeginnerHere> Cages have operations like + - % * 
00:34:02 <BeginnerHere> Cages also contains certain about of boxes in the values in the cells or boxes must match the total in the using the operation
00:34:20 <BeginnerHere> Some Cages may over lap
00:34:24 <NewUser> BeginnerHere: yeah and then do the operation without repeting the numbers in the cages
00:34:47 <BeginnerHere> NewUser: ya no repeats
00:35:15 <NewUser> so the cages needs to have a function check 
00:35:25 <BeginnerHere> So once the number is used in that rows with the multiple Cages it can't be used any more
00:35:43 <NewUser> yeah
00:36:22 <NewUser> min: any idea?
00:36:33 <BeginnerHere> I think that what NewUser is trying to do min and Cale if you follow me
00:36:50 <BeginnerHere> Is that right NewUser?
00:37:12 <NewUser> BeginnerHere: yes
00:39:31 <BeginnerHere> min and Cale, I am not sure but it looks like that cellsMapTo1DValuesArray is trying to sort the a list by Cage sizes
00:40:00 <BeginnerHere> for instance group all the Cages with 2 , then 3 , 4 , etc....
00:40:46 <NewUser> I am trying to get to this point all permutations until it finds one that satisfies the cages
00:41:00 <NewUser> that will be the operations
00:44:11 <ski> younder : #sml and #ocaml ? (and s/group/channel/)
00:44:23 <ski> Cale : why not `toAscList' instead of `toList' ?
00:45:59 <BeginnerHere> Cale: does toAscList sort by ascending order
00:46:36 <BeginnerHere> or ski sorry
00:47:10 <ski> `toList' currently also does, but afaik, you're not supposed to depend on the order you get from `toList'
00:47:48 <ski> (and `toAscList' ought to add an `Ord' constraint to the type signature, as well)
00:48:00 <NewUser> Cale: Can you please explain me what I have wrong in my code?
00:49:27 <BeginnerHere> :t toAscList
00:49:28 <lambdabot> Not in scope: `toAscList'
00:49:40 <BeginnerHere> import Data.Map
00:49:46 <BeginnerHere> :t toAscList
00:49:47 <lambdabot> Not in scope: `toAscList'
00:50:08 <BeginnerHere> Can't check imported types here?
00:50:53 <Kaidelong> out of curiousity
00:51:03 <Kaidelong> why is there no fromDescList and toDescList
00:51:05 <BeginnerHere> ski: so this what it does  toAscList :: Map k a -> [(k, a)] , where k is the key and a is the value ???
00:51:08 <Kaidelong> it is useful sometimes
00:51:13 <Kaidelong> you can't implement it from outside
00:51:16 <ski> @type M.toAscList
00:51:17 <lambdabot> forall k a. M.Map k a -> [(k, a)]
00:51:18 <ski> @type M.toList
00:51:19 <lambdabot> forall k a. M.Map k a -> [(k, a)]
00:51:20 <Kaidelong> and it's not any more computationally expensive
00:52:41 <Kaidelong> reverse . toAscList and fromAscList . reverse is, on the other hand
00:53:02 <ski> Kaidelong : imo, either there should be one, or `toAscList' should be scrapped, and `toList' get guarantees about ordering
00:53:16 <ski> ("one" refering to `toDescList', i.e.)
00:53:38 <ski> @type M.fromList
00:53:39 <lambdabot> forall k a. (Ord k) => [(k, a)] -> M.Map k a
00:53:40 <ski> @type M.fromAscList
00:53:41 <lambdabot> forall k a. (Eq k) => [(k, a)] -> M.Map k a
00:53:44 <ski> aha !
00:54:32 <ski> @type M.fromDistinctAscList
00:54:33 <lambdabot> forall k a. [(k, a)] -> M.Map k a
00:54:38 <ski> .. interesting
00:55:07 <ski> i assume those two latter come with preconditions / proof obligations
00:55:28 <BeginnerHere> ski: distinct means there is none of the same elements inside right?
00:55:38 <ski> i'd assume so, yes
00:56:01 <ski> (i.e., no key is repeated)
00:57:05 <BeginnerHere> so couldn't NewUser use M.fromDistinctAscList for their 1D function ?
00:57:25 <augur> ski: oi
00:57:51 <ski> io
00:57:52 <NewUser> ski: can i do that
00:58:00 <augur> ski: reader
00:58:33 <ski> output
00:58:33 <Kaidelong> ski: probably not enforced ones
00:58:50 <ski> Kaidelong : that's what i meant, yes
00:58:54 <Kaidelong> ski: also it'd be kind of useless because then you couldn't do membership tests anyway
00:59:03 <Kaidelong> unless you map over it first
00:59:06 <Kaidelong> or something like that
00:59:26 <augur> ski: WriterT
00:59:34 <augur> wait no thats not a monad by itself
00:59:58 <ski> just because `fromDistinctAscList' doesn't use `Eq k' or `Ord k' doesn't mean that there is no such instance 
01:00:07 <augur> WriterT String
01:00:17 <ski> heh, that's not a monad, either
01:00:32 <augur> damn paramterized monads
01:00:46 <augur> (Monad m) => WriterT String m
01:00:47 <augur> :|
01:00:51 <ski> Kaidelong : presumably the point of `fromDistinctAscList' is to avoid having a needless duplicates check
01:01:48 <Kaidelong> ski: right, just saying that even though you may not need Ord or Eq you would get a useless set if you actually did that
01:01:57 * ski feels that we possibly should distinguish between `C a => Foo a', and `Foo a', where `C a' is assumed to hold as a presupposition
01:02:49 <augur> ski: hmm.. presuppositions in computer program semantics?
01:02:54 <augur> an interesting idea!
01:03:15 <ski> (augur : .. though i assume you have your own ideas about definite descriptions and presuppositions)
01:03:43 <augur> ski: i have little opinion on presuppositions OR definition descriptions!
01:03:46 <Kaidelong> ACL2 probably does it right
01:03:49 <augur> im mostly a syntax guy
01:03:59 <Kaidelong> proof obligations
01:04:01 <Kaidelong> no types
01:04:05 <Kaidelong> you don't need them anymore
01:04:16 <augur> types are proofs.
01:04:20 <Kaidelong> basically yes
01:04:29 <Kaidelong> so you have types
01:04:31 <augur> so then why eliminate types!
01:04:37 <Kaidelong> you haven't!
01:04:46 <Kaidelong> you've just generalized them, I suppose
01:04:54 <augur> LAMBDA CUBE
01:05:05 <augur> omg guys, we should create a time-cube parody about the lambda cube
01:05:06 <augur> omg
01:05:37 <ski> Kaidelong : .. anyway, by "preconditions / proof obligations", i meant things that the programmer is supposed to check/prove, and which the compiler/library can just take on faith ("if you lie to the compiler/library, it will get its revenge")
01:05:48 <kadoban> oh time cube...so much amusement.  i wonder if anyone ever tracked that guy down and figured out if he's for real or not
01:06:02 <Kaidelong> he gave a lecture somewhere
01:06:10 <kadoban> really? nice
01:06:11 <Kaidelong> apparently he takes himself very seriously
01:06:19 <ski> Kaidelong : i Mercury, these are the `promise' declarations. in Haskell `unsafePerformIO' (which i think would be better renamed) is a similar thing
01:06:20 <augur> Kaidelong: most crazy people do
01:06:25 <Kaidelong> and is an incomprehensible in person as in writing
01:06:34 <augur> thats how we know they're crazy
01:06:47 <Kaidelong> ski: I'm learning mercury! or trying to. Or was, but school caught up to me, software engineering project...
01:06:48 <augur> if they didnt take themselves seriously they'd just be performance artists
01:07:03 <kadoban> i think that actually ruins it a tiny bit for me...i always assumed it was a gag
01:07:07 <Kaidelong> know good resources?
01:07:12 <ski> Kaidelong : of course there's a difference between nasal demons and "just" wrong answers (due to invalidated library invariants, &c.)
01:07:25 <augur> nasal demons? :|
01:07:39 <Kaidelong> augur: undefined behavior
01:07:59 <HugoDaniel2> hi
01:08:03 <Kaidelong> on good implementations like Windows NT it generally shows up as an error
01:08:27 <Kaidelong> but in some cases the undefined behavior might even be useful
01:08:30 <ski> Kaidelong : well, Mercury is cool !
01:08:36 <Kaidelong> think security vulnerability
01:08:40 <ski> (i assume you already know some Prolog, so you can compare)
01:08:47 <NewUser> ski: I have this code to solve the KenKen puzzle 1D but I am getting error message a lot http://pastebin.com/JWN9yhJ1
01:08:48 <augur> prologggg
01:08:50 <Kaidelong> ski: only the very basics!
01:09:05 <Kaidelong> I was never terribly interested in prolog for some reason, but mercury looks more appealing
01:09:06 <augur> ski: whats new and/or interesting in haskell land, conceptually speaking?
01:09:17 <augur> or really anywhere in programming theory land, i suppose
01:10:20 <ski> Mercury offers a static type system (with (parametric) algebraic data types, and type classes), and a static mode & inst & determinism system, plus functions in addition to the predicates
01:11:06 <ski> Mercury is pure/declarative. cut, var/1, and side-effecting I/O is removed, as is assert[az]/1,retract/1
01:11:48 <ski> Mercury predicates are more often multi-moded ("reversible") than Prolog ones, because of automatic (static) goal reordering, based on the mode & inst info
01:11:52 <augur> ski: which kind of cut? surely not gentzenian cut
01:12:46 <ski> also, Mercury is less flexible than Prolog, since you have to know statically how instantiated things are at any point (though there's constraint solver types and insts, that mitigate this, if you need the flexibility)
01:13:16 <ski> augur : not that. i refer to the evil, non-declarative !/0 "predicate" of Prolog
01:13:37 <min> cut in logic languages is choice elimination in a derivation tree
01:13:53 <augur> ski: what does ! do, anywa?
01:14:03 <Chaze> can i somehow turn a simple operation like (/) into a Maybe-version that catches division by 0?
01:14:19 <ski> augur : it is hard to explain. it is also very low-level
01:14:51 <augur> ski: TRY >|
01:15:00 <augur> ski: also, im teaching a friend SICP
01:15:14 <min> it would be interesting to see logic variables in Haskell as part of a standard monad (e.g., "Embedding Prolog in Haskell"). People already compute with Horn clauses at the type level, so the crossover wouldn't be hard.
01:15:21 <augur> we're going to modify the metacircular evaluator to include some haskell-like things. :D
01:15:42 <ski> Kaidelong : what's great in Prolog is backtracking (i.e. search) and logic variables and multi-modeness (i.e., "why define `stripPrefix' separatedly, when we already have `(++)' which we can run backwards ?")
01:16:40 <Kaidelong> ski: haskell does the first one great using MonadPlus, reversibility is nice I suppose, leave that to Oleg Kiselyov to do in the type-system?
01:17:00 <ski> augur : whenever `!' is called in a clause body of a predicate, all choice-points up-to and including the one (if any) created for the current predicate are removed. otherwise it behaves as true/0
01:17:08 <ski> augur : feel enlightened ?
01:17:28 <ski> Kaidelong : you forgot logic variables :)
01:17:29 <augur> ski: a little!
01:17:46 <augur> so it basically... prevents backtracking?
01:17:51 <augur> beyond a certain point, i mean
01:18:10 <Boxo> > let f a b = if b==0 then Nothing else Just (a/b) in f 1 0 -- What's the problem Chaze
01:18:11 <lambdabot>   Nothing
01:18:19 <Boxo> Nothing, that's right
01:19:05 <Chaze> i was thinking of some function that catches the "error" in general
01:19:07 <ski> augur : note that this means that if you have `p(...) :- q(...),...,r(...)', you can't lift out the middle `...' getting `p(...) :- q(...),aux(...),(...)' and `aux(...) :- ...', since in case that factored `...' contains `!', that's a semantics-changing transformation
01:19:12 <Chaze> > 1 / 0
01:19:13 <lambdabot>   Infinity
01:19:20 <ski> augur : in this regard, it is similar to `break' and `return' in C
01:19:22 <Chaze> > 1 % 0
01:19:23 <lambdabot>   *Exception: Ratio.%: zero denominator
01:19:25 <augur> hm.
01:19:29 <Chaze> like this exceptino
01:19:33 <ski> (so it's not compositional)
01:20:11 <Kaidelong> Chaze: you can only "catch" things in IO
01:20:19 <augur> ski: unrelatedly, do you know of any programming methods which involve programs that, rather than defining algorithms, define means of manipulating and combining atomic chunks of algorithm?
01:20:25 <Chaze> Kaidelong: i see
01:20:46 <Kaidelong> Chaze: in pure code you should use stuff like Maybe or [] instead to semantically deal with computations that can fail
01:21:19 <augur> that is to say, rather than writing code that you run to produce the algorithm, you instead write code that when run constructs the algorithm in question
01:21:20 <ski> augur : yeah, when the search tree is traversed (depth-first), if a `!' is encountered, any sibling and earlier child `OR'-branches (not yet traversed) are pruned from the tree
01:21:47 <Chaze> Kaidelong: let's say i want to map (1 %) [some numbers that might be 0]
01:21:51 <min> you can use Exception or Error also if you want to report error messages on failure, too; the latter is based on the Either type.
01:21:55 <ski> @type Control.Exception.mapException
01:21:57 <lambdabot> forall e1 e2 a. (GHC.Exception.Exception e1, GHC.Exception.Exception e2) => (e1 -> e2) -> a -> a
01:22:34 <Chaze> -- sorry, gotta go. i'll come back to my issue though
01:23:00 <ski> augur : i'm not sure
01:23:20 <augur> ski: i suppose points-free is one such style
01:23:43 <ski> augur : attribute grammars, in a sense, allow you to "combine in parallel" parts of algorithms .. but i'm not sure this is what you had in mind
01:23:51 <augur> after all, what is, say, composition or forking if not an instruction to build new procedures
01:24:23 <ski> (if you haven't seen it before, you might also want to loop up "aspect-oriented programming")
01:24:34 <augur> i suppose what im looking for could be called combinatorial programming. the primitives of the language should be combinatorial methods applied and atomic procedures
01:24:42 <augur> oh god, aspect oriented programming
01:24:46 <augur> ive never been able to understand that
01:24:48 <ski> yeah :/
01:24:53 <augur> attribute grammars are easy, but AOP? nuts.
01:24:58 <augur> ive heard monads described as AOP
01:25:02 <augur> or maybe it was monad transformers
01:25:21 <ski> there might be some nice things hiding inside AOP, but i haven't been able to extract them
01:25:26 <magicman> Monads have been described as burritos, nothing new there >_>
01:25:45 <augur> mmm burritos
01:27:39 <ski> augur : re presuppositions : `Monad m => WriterT String m a' to me means something that can accept any `Monad m' instance, and yields a `WriterT String m a' value .. otoh, `WriterT String m a' with a `Monad m' presupposition means just a value of type `WriterT String m a', where it is assumed that `Monad m' holds in this context
01:28:45 <augur> Monad m => ... seems to me something more like a conditional on types, not a presupposition
01:28:51 <ski> augur : in the former case, if you want a list of such values, the type would be `[Monad m => WriterT String m a]' (or maybe `[forall m. Monad m => WriterT String m a]' if you want to generalize over `m'); in the latter case, the type would instead be `[WriterT String m a]' (still assuming `Monad m' to hold in the context)
01:28:59 <ski> augur : exactly
01:29:09 <augur> but conditionals are not presuppositions at all
01:29:18 <augur> quote the contrary, in fact
01:29:28 <ski> (hence me complaining about your "<augur> (Monad m) => WriterT String m" :)
01:29:34 <ski> right
01:30:04 <ski> (also, `WriterT String m' isn't even the right kind .. which, if nothing else, should give you a hint that something is wrong, here)
01:30:26 <augur> what
01:30:29 <augur> how is it not the right kind
01:30:38 <ski>   WriterT String m :: * -> *
01:30:42 <ski>   WriterT String m a :: *
01:30:51 <ski> (assuming `a :: *' and `m :: * -> *', of course)
01:31:00 <augur> true, but Reader is * -> * -> *
01:31:21 <ski> yes .. i don't see your point
01:31:28 <augur> so how is it not the right kind?
01:32:03 <ski> which example involving `Reader' are you considering, now ?
01:32:30 <augur> when you accepted Reader as a rebuttal :|
01:32:45 <NewUser> ski: toAscList :: Map k a -> [(k, a)] this puts the smallest to biggest right
01:33:03 <ski> <augur> ski: reader
01:33:03 <ski> <ski> output
01:33:05 <ski> that ?
01:33:14 * ManateeLazyCat pasted "Ocaml" at http://paste2.org/get/1130890
01:33:15 <ManateeLazyCat> What's this Ocaml code mean?  
01:33:21 <augur> yes! :|
01:33:22 <ski> NewUser : yes
01:33:50 <ski> augur : `reader' and `output' referred to things with the same kind
01:34:04 <ski> augur : the kind complaint was only about "<augur> (Monad m) => WriterT String m"
01:34:04 <augur> prior to that you have IO
01:34:08 <NewUser> thank you
01:34:39 <augur> ski: but surely that has kind * -> * too
01:34:50 <augur> well, sort of
01:34:50 <ski> in `<cxt> => <type>', `<cxt>' should be a valid context, and `<type>' should be a valid type, of kind `*'
01:34:59 <companion_cube> ManateeLazyCat, the function foo seems to remove duplicates
01:35:03 <augur> ski: oic
01:35:08 <augur> well then!
01:35:27 <ManateeLazyCat> companion_cube: What's the mean of "let sorted = List.sort ~cmp:compare list in" ?
01:35:55 <companion_cube> sorted is the list list, but sorted according to compare
01:36:03 <companion_cube> which is the main comparing function
01:36:54 <ManateeLazyCat> companion_cube: I just got http://paste2.org/get/1130890
01:37:01 <ski> ManateeLazyCat : is that from your interview ?
01:37:07 <ManateeLazyCat> ski: Yes, 
01:37:16 <ManateeLazyCat> ski: But i don't understand Ocaml syntax. :)
01:37:29 <ManateeLazyCat> ski: I don't understand ~cmp:cmpare 
01:37:36 <companion_cube> oh
01:37:41 <ski> augur : re presuppositions, in Type theory, there's an alternative formulation of the usual conjunction forming rule
01:37:46 <companion_cube> it's an error, List.sort has no named parameter
01:37:55 <min> is there a reference listing the sizes of the primitive types in Haskell? I can't find one in the GHC docs.
01:37:57 <companion_cube> ~cmp:compare is a named argument
01:38:05 <companion_cube> but there you should just have compare
01:38:11 <companion_cube> List.sort compare list
01:38:59 <augur> ski: o?
01:39:05 <ski> augur : instead of "if `Gamma |- A well-formed' and `Gamma |- B well-formed' then `Gamma |- A /\ B well-formed' ..
01:39:09 <ManateeLazyCat> companion_cube: So correct should be "List.sort compare list" instead "List.sort ~cmp:compare list" ?
01:39:25 <augur> ski: who are you, martin-lof? :|
01:39:36 <companion_cube> ManateeLazyCat, i think
01:39:48 <ManateeLazyCat> companion_cube: How do about second function?
01:39:49 <ski> augur : .. they have "if `Gamma |- A well-formed' and `Gamma , A true |- B well-formed' then `Gamma |- A /\ B well-formed'"
01:39:58 <augur> ski: waa
01:40:20 <ski> augur : similarly, there's a "if `Gamma |- A well-formed' and `Gamma , A true |- B well-formed' then `Gamma |- A -> B well-formed'" rule
01:40:46 <ski> augur : so in a conjunction `A /\ B', and in an implication `A -> B', you may assume `A' is true, when forming `B'
01:41:01 <augur> ski: weird
01:41:06 <NewUser> ski: can you please guide how to solve this error messages http://pastebin.com/JWN9yhJ1
01:41:08 <companion_cube> ManateeLazyCat, i think it does the same
01:41:21 <companion_cube> but instead of sorting and then removing successive duplicates, it uses a set
01:41:29 <ski> augur : e.g. `A' might include a condition that a number `x' is not zero, and `B' can then use `1 / x' (which has as a presupposition that `x' is non-zero)
01:41:44 <blackdog> anyone know if there's a build of ghc 7 packaged for debian or ubuntu?
01:41:51 <blackdog> obviously not in the release...
01:42:10 <blackdog> (my poor little ec2 micro instance is compiling ghc slower than a wet week...)
01:42:40 <ski> augur : so i think here we can think of presuppositions as truth-conditions on the *well-formedness* of another formula
01:42:58 <augur> ski: perhaps perhaps
01:43:08 <augur> or conditional types, at the least
01:43:14 <ManateeLazyCat> companion_cube: What's mean :: in "hd::accum" ?
01:43:20 <mornfall> Is community.h.o hung up again?
01:43:26 <augur> obviously its something martin-lof-y
01:43:31 <NewUser> can someone  please guide how to solve this error messages http://pastebin.com/JWN9yhJ1
01:43:31 <companion_cube> it's the "cons" operator, similar to ":" in haskell
01:43:36 <ski> augur : maybe the theory of presuppositions are richer that this kind of thing in linguistics .. but i thought this could at least be interpreted in terms of (what little i know of) presuppositions
01:43:48 <mornfall> Ah. It replied.
01:43:50 <companion_cube> haskell and ocaml have opposite notations for typing and list atoms
01:44:00 <augur> ski: i know fuck all about linguistic presuppositions, honestly
01:44:03 <ski> augur : btw, note that this works as well for `A /\ B' as for `A -> B' .. so the conditional isn't needed for this
01:44:04 <augur> but they're usually not about well formedness
01:44:09 <ski> ok
01:44:38 <ManateeLazyCat> companion_cube: It's okay, never mind.
01:44:58 <companion_cube> you can use the ocaml repl to know what are functions ;)
01:45:05 <romildo> Hi.
01:45:08 <ManateeLazyCat> companion_cube: I don't want to 
01:45:21 <ManateeLazyCat> companion_cube: I love Haskell, but i don't want change to Ocaml
01:46:15 <romildo> I would like to be able to write a string with interspersed Haskell expressions, and then "evaluate" the string, which would replace the expressions by their values. Is there anything in that direction?
01:46:51 <quicksilver> romildo: there are two or three templating libraries on hackage. I don't know if any of them supports arbitrary expressions.
01:46:54 --- mode: quicksilver set -o quicksilver
01:47:07 <quicksilver> romildo: to do this at runtime would require an embedded haskell interpreter, obviously.
01:47:31 <Kaidelong> http://codepad.org/I44xhYQ3 this is what I sent the guy asking how to handle failure, does this sound just about right to everyone else?
01:47:40 <ski> augur : btw, note that those two rules above are the obvious(?) "proofs and types to truths and formulae" translation from "if `Gamma |- A type' and `Gamma , x : A |- B type' then `Gamma |- (x : A) /\ B type'" and similarly for `(x : A) -> B'
01:47:42 <quicksilver> if you want to do it at compile time, you can just write concat [ "My age is", show (50*2), ", nice to meet you" ]
01:48:49 <ski> augur : `(x : A) /\ B' and `(x : A) -> B' sometimes being written as `exists x : A. B' and `forall x : A. B' or `sigma_{x : A} B' and `pi_{x : A} B'
01:49:07 <augur> oh god ski stop D:
01:49:26 <ski> augur : so, if you take that, and remove the `x' (i.e. forget the actual proof, but not the fact that there was a proof), then you get the rules i showed above
01:49:28 <augur> also, yes, restricted quantification
01:49:30 <ski> augur : heh, ok
01:49:36 <augur> im well aware of restricted quantifiers
01:49:43 <ski> sorted/typed quantification
01:49:49 <augur> same thing
01:49:50 <dolio> (x : A) /\ B is never written that way, as far as I've seen.
01:50:00 <dolio> Maybe if you replace the /\ with an x.
01:50:02 <augur> i was actually going to suggest that earlier but then you mentioned quantified types
01:50:18 <ski> aka dependent product & sum (/ function & product)
01:50:34 <ski> dolio : well, s/\/\\/*/ or something :)
01:50:54 <ski> yeah
01:51:02 <augur> ski: well, restricted quantification isnt quite dependent anything
01:51:27 <ski> yeah, not if you keep the type vs. set distinction
01:51:51 <romildo> quicksilver, I was thinking about something like: let f xs = map toUpper xs in evalStr ("title: @title@\n")
01:51:51 <romildo> But I think your solution using concat with string literals intermixed with the expressions is good enough. Thanks for the idea.
01:51:52 <ski> (er, that should be the formula vs. type/set distinction)
01:52:32 <romildo> I meant, let f xs = map toUpper xs in evalStr ("title: @f title@\n")
01:53:09 <ski> ManateeLazyCat : i think both are more or less `nub' ..
01:53:44 <NewUser> nub means removing duplicates
01:53:47 <NewUser> :t nub
01:53:49 <lambdabot> forall a. (Eq a) => [a] -> [a]
01:53:54 <augur> ski: well, im not sure its the same even if you dissolve that distinction
01:54:24 <augur> i mean, if your only quantifiers are all and some, then sure, maybe you can collapse the notions
01:54:34 <ski> Kaidelong : i would either use `mzero' or `error'
01:54:42 * ski doesn't like `fail'
01:55:15 <Kaidelong> :t error
01:55:16 <lambdabot> forall a. [Char] -> a
01:55:36 <Kaidelong> > error "foo" `mplus` [4,5]
01:55:36 <lambdabot>   *Exception: foo
01:55:44 <ski> augur : hm, what other quantifiers are you thinking of ? .. "most" ? "finitely many" ? Henkin-quantifiers ?
01:55:46 <Kaidelong> > fail "foo" `mplus` [4,5]
01:55:47 <lambdabot>   [4,5]
01:56:09 <ski> yeah, `error' for precondition failure
01:56:09 <augur> ski: well, in the linguistic domain, "most" certainly counts
01:56:23 <augur> "same" could also be a quantifier, but it's not a restricted quantifier
01:56:27 <ski> granted :)
01:56:38 * ski doesn't know how "same" would work
01:56:45 <augur> type-wise?
01:56:53 <augur> same is just iff
01:56:54 <ski> type-wise, *and* semantics-wise
01:57:00 <augur> same == =
01:57:23 <augur> if quantifiers are relations between sets, its simple
01:57:27 <augur> same is equality
01:57:34 <ski> hm .. do you mean that `=' is (sortof) the left adjoint for the `\Delta' duplication morphism ?
01:57:40 * ski assumes no ..
01:57:41 <augur> no what
01:57:53 <ski> so, how is `=' a quantifier ?
01:58:14 <augur> its a set relation
01:58:16 <ski> hm, i assume you must mean that in a (syntactic, yes ?) linguistic sense ?
01:58:18 <augur> quantifiers are just set relations
01:58:34 <augur> some ~ non-empty intersection
01:58:37 <augur> all = subset
01:58:53 <ski> quantifiers, as i know them, bind variables
01:59:08 <augur> thats one way of thinking about them
01:59:11 <augur> but tell me
01:59:21 <ManateeLazyCat> ski: Thanks, but i don't want to go.
01:59:36 <augur> what is forall if not a function of type (a -> Bool) -> [a] -> Bool
01:59:36 <augur> ?
01:59:40 <ManateeLazyCat> ski: They need me change to Ocaml but i don't want to do.
01:59:45 <ManateeLazyCat> I love Haskell
01:59:48 <augur> forall a. P == forall (\a -> P)
01:59:49 <ski> in natural language, i'd assume one could say they introduce a "thing" to talk about (like "every dog has a flea that bit it")
01:59:53 <ManateeLazyCat> I just want use Haskell write program
02:00:30 <ski> ManateeLazyCat : write Haskell-to-Ocaml compiler, as part of Manatee ? problem solved !
02:00:36 * ski is jesting :)
02:00:38 <augur> ski: forall x : dog x. exists y : flea y & bit y x. x has y
02:01:05 <ManateeLazyCat> Also my Spoken English is quite horrible although i practiced a whole night for today interview.
02:01:06 <augur> but really, what is a predicate if not a set of satisfiers?
02:01:17 <augur> at least logically, you can think of it this way
02:01:28 <ski> augur : i think of it more like `forall_a :: (a -> Bool) -> Bool', then
02:01:50 <augur> sure, but thats just building in the domain
02:02:05 <augur> i mean, unrestricted quantifiers quantify over everything, right
02:02:12 <augur> at least everything in the domain of discourse
02:02:16 <ManateeLazyCat> ski: "Jane Street" is good company, but my English is not suitable. 
02:02:18 <ski> (augur : in Agda2, that's `Forall : {A : Set} -> (A -> Prop) -> Prop', generalized over any domain `A' of quantification)
02:02:28 <augur> exactly
02:02:45 <augur> but the thing is, these are restricted quantifiers
02:03:15 <augur> so while same is also basically a quantifier, in that it compares sets just like forall does
02:03:20 <augur> it has to be unrestricted
02:03:22 <ManateeLazyCat> I just want sleep now, bye all. 
02:03:48 <ski> augur : i want to be able to have many domains of discourse, and introduce new ones, on-the-fly :)
02:04:06 <ski> (also, i don't really believe in "quantify over everything")
02:04:08 <augur> sure, thats fine
02:04:24 <augur> but restricted quantifiers are more than merely having domains of discourse, see
02:04:48 <ski> i still don't see how "same" would be a quantifier
02:04:58 <ski> (except in the adjunction sense)
02:05:07 <augur> its a set comparison :|
02:05:18 <augur> forall is a set comparator
02:05:20 <augur> namely, subset
02:05:29 <ski> how is `same x y' a quantification ?
02:05:37 <ski> hm
02:05:42 <augur> same x y == subset x y && subset y x
02:06:02 <ski> i'd rather say `forall' checks whether a subset is the full subset, if you want to talk about subsets
02:06:11 <augur> "the full subset"?
02:06:23 <ski> the set, considered as a subset of itself
02:06:24 <blackdog> ManateeLazyCat: you interviewed with jane st today?
02:06:29 <augur> ski: what
02:06:37 <ski> with identity as the inclusion function
02:06:58 <augur> ski: what are you talking about :|
02:07:01 <ski> a subset of a set `A' is a set `S' together with an injective function `i : S --> A'
02:07:29 <ski> (that's the category theory version of what "subset" is about (slightly simplified))
02:07:48 <augur> i dont follow at all
02:07:50 <augur> but anyway
02:07:57 <augur> quantifiers are just set relations
02:08:30 <augur> but restricted quantifiers are a special kind of set relation
02:08:44 <ski> if you write `forall x : A. ..x..', then the mapping `x |-> ..x..' is the characterizing function for the subset of `A' of elements `x' that satisfy `..x..'
02:09:10 <augur> i have no idea what you just said
02:09:25 <ski> what `forall x : A. ..x..' is expressing is that this subset of `A' is actually the whole of `A', i.e. the property holds for every element in `A'
02:09:47 <ski> (s/characterizing function/characteristic function/, sorry)
02:10:01 <augur> ahh, i see
02:10:07 <ski> <augur> quantifiers are just set relations
02:10:13 <augur> you mean that the subset of A for which ..x.. holds is the whole of A itself
02:10:25 <augur> yes this is the essential property of restricted quantifiers
02:10:28 <ski> yes, in the above sense, `forall_A' is a predicate that is defined over subsets of `A'
02:11:09 <ski> hm
02:11:15 <augur> that is to say
02:11:31 <augur> a restricted quantifier can only tell you about the relationship of a subset of its restriction to the restriction itself
02:11:39 <augur> e.g. Most x : P. Q
02:12:03 <augur> tells you about the relative size of the Q subset of P compared to P as a whole
02:12:13 <augur> but same is not at all a restricted quantifier
02:12:23 <augur> because it compares two sets equally
02:12:46 <augur> Same P Q can only hold if we can say something about Q as a subset of P, and P as a subset of Q
02:12:50 <ski> so you're advocating expanding `same S0 S1' into `same {x : A | x \in S0} {x : A | x \in S1}', and then maybe changing the syntax to `same x : A. (x \in S0) ; (x \in S1)' (allowing in general `x \in S0' and `x \in S1' to be any formulae involving `x') ?
02:13:15 <augur> {X : A | x <- S0} == S0
02:13:33 <augur> what im NOT saying is we can change the syntax to same x : ...
02:13:43 <augur> because : is used for denoting restrictions
02:13:49 <ski> oh, you're comparing arbitrary sets `P' and `Q' (not just subsets of, say, `A') ?
02:13:59 <augur> right
02:14:01 <ski> ok
02:14:16 <ski> well, i don't belive in a universal set comparision
02:14:21 <augur> we can ofcourse add such constraints, but it doesnt change the facts of the matter
02:14:42 <augur> `same` is simple not a restricted quantifier
02:14:55 <augur> because restricted quantifiers inherently only tell you something about the restriction set
02:15:21 <ski> yeah, then i suppose i only believe in the "restricted" variety of quantifiers :)
02:15:29 <augur> well no, i dont think so
02:15:36 <augur> i mean, i dont think you're understand restricted in the same way i am
02:15:46 <augur> the version of same you gave is not restricted
02:15:56 <augur> even if we're only comparing A's
02:16:16 <dolio> S = T is not well-formed for two arbitrary sets S and T. :)
02:16:20 <dolio> In structural set theory.
02:16:31 <augur> dolio: i dont know anything about structural set theory
02:16:33 <dolio> (If I'm recalling correctly.)
02:16:54 <ski> imo, given any two arbitrary sets, it is meaningless to ask whether they are equal (apart from the weaker condition of they being isomorphic/equinumerous/equipotent / having the same cardinality / there existing a bijection between them)
02:17:32 <augur> ski: thats nonsense, of course its meaningful
02:17:47 <augur> if it were meaningless, then you surely cannot think that equality functions in haskell actually mean anything
02:18:12 <ski> each equality function in Haskell is attached to a single type
02:18:20 <augur> types are not what im talking about
02:18:40 <augur> have types, i dont care
02:18:45 <augur> thats not what restricted quantifiers do
02:19:24 <ski> <augur> the version of same you gave is not restricted
02:19:25 <augur> forall (x :: Int) : prime x. x == 2 || odd x
02:19:26 <ski> elaborate ?
02:19:44 <augur> ski: i said numerous times what restricted means :P
02:20:15 <ski> yes. you also stated "i dont think you're understand restricted in the same way i am", so presumably you think i'm missing some point
02:20:20 <augur> if a quantifier is restricted, e.g. forall x : R. S
02:20:27 <dolio> http://ncatlab.org/nlab/show/SEAR
02:20:34 <augur> what this tells you is about the S-subset of R in relation to R
02:20:56 <ski> yes
02:20:56 <dolio> That set theory, I'm pretty sure, adheres to ski's assertion about the meaninglessness of equality of arbitrary sets.
02:21:08 <augur> and therefore it tells you about the R-subset of S in relation to R
02:21:26 <ski> yes
02:21:33 <ski> since `S' describes an `R'-subset
02:21:37 <ski> that's only natural
02:21:38 <augur> well no
02:21:48 <augur> thats obviously false
02:22:05 <augur> forall x : prime x. x < 2
02:22:15 <ski> oh, maybe you have `R' and `S' both as common subsets of, e.g. `A' .. that works, too
02:22:19 <augur> the set of integers less than 2 is obviously not a subset of the set of primes
02:22:23 <ski> right
02:22:25 <ski> ok
02:22:42 <augur> consider the meaning of most
02:22:54 <augur> most x : P. Q
02:22:58 * ski is not sure of the meaning of "most", in natural language :)
02:23:05 <augur> more than half :P
02:23:17 <augur> if i say something like
02:23:20 <augur> "most dogs bark"
02:23:24 <ski> heh .. that semantics seems soo .. trite :)
02:23:43 <ski> (also, what does it mean, when the domain is infinite)
02:23:44 <augur> this tells me nothing about the barkers (except maybe that some of them are dogs but thats happenstantial)
02:24:04 <augur> what "most dogs bark" tells us really is something about the set of barkers
02:24:08 <ski> (most integers are not primes, because the schnirelman-density of the primes is zero ?)
02:24:09 <augur> er, about the set of dogs
02:24:10 <PhilRod_> language log did a bunch on that: http://languagelog.ldc.upenn.edu/nll/?p=2516
02:24:12 <augur> not about the set of barkers
02:24:39 <augur> PhilRod_: "This afternoon, Rachel directed our attention to Tim Hunter, Justin Halberda, Jeffrey Lidz, & Paul Pietroski, "Beyond Truth Conditions: The Semantics of most", SALT2008."
02:25:09 <augur> tim hunter is a friend and fellow grad student here at UMD (or he was until last semester)
02:25:19 <augur> justin was too until maybe a year ago
02:25:26 <augur> jeff and paul are two of my professors
02:25:27 <augur> ;)
02:25:50 <PhilRod_> oh, cool
02:26:09 * PhilRod_ would consider linguistics if he wasn't already a physicist
02:26:10 <augur> the Alexander mentioned there is probably also one of my profs
02:26:13 <augur> Alexander Williams
02:26:51 <augur> anyway, the point is, ski: most is the kind of thing that only tells you something definitive about it's first argument
02:27:03 <augur> another way of looking at this is that
02:27:09 <augur> if a quantifier Q is a restricted quantifier
02:27:31 <ski> PhilRod_ : ty
02:27:32 <augur> then Q xs ys == Q xs [y | y <- xs && y <- ys]
02:27:50 <augur> PhilRod_: i was a physics major before becoming a linguistics major :D
02:28:51 <augur> ski: that is to say, the truth of the quantified expression is unchanged if the property you ascribe to the restriction set includes being a member of that restriction set
02:29:02 <ski> (hm .. i suspect that will not hold for linear quantifiers, if it is possible to make sense out of such)
02:29:05 <augur> set relations on the whole _dont_ have this property
02:29:37 <augur> so while it's true that "most dogs are barkers that are dogs" is as true as "most dogs are barkers"
02:29:55 <augur> it's not the case that "the dogs are the barkers" is as true as "the dogs are the barkers that are dogs"
02:30:09 <augur> the former says there are no non-dog barkers
02:30:26 <augur> AS WELL AS that there are no non-barking dogs
02:30:33 <augur> whereas the latter only says there are no non-barking dogs
02:30:43 <augur> it says nothing about the non-dog barkers
02:31:03 <augur> so same, while its certainly a quantifier-qua-set-relation
02:31:09 <augur> is not a restricted quantifier
02:31:12 <PhilRod_> augur: well, I just started a postdoc in particle physics, so now isn't the time for a career change :)
02:31:14 <ski> would these two last be examples of "same" ?
02:31:28 <augur> ski: yes :P
02:31:34 <augur> surely thats what "the dogs are the barkers" means
02:32:18 <augur> PhilRod_: have you read that paper that shows some connections between logic, category theory, topology, and physics?
02:32:48 <augur> and computation
02:32:54 <augur> Physics, Topology, Logic and Computation - Baez and Stay
02:32:56 <augur> there it is
02:33:07 * ski was half-guessing Baez ..
02:33:17 <augur> :p
02:33:18 <PhilRod_> augur: no, do you have a link? (although I should say I'm an experimentalist, so theoretical physics maths tends to go over my head)
02:33:22 <PhilRod_> oh, thanks, will take a look
02:33:33 <augur> Baez: not only a great musician, but a great physicist too!
02:33:40 <augur> EXPERIMENTALIST?
02:33:42 <augur> GTFO
02:34:20 <PhilRod_> :-(
02:34:44 <ski> "Physics, Topology, Logic and Computation" at <http://math.ucr.edu/home/baez/rosetta.pdf> by John C. Baez,Mike Stay in 2009
02:35:00 <augur> dar yi gou
02:35:11 <augur> i dont think i finished that paper
02:35:18 <augur> i just ended up reading about CT
02:35:18 <dolio> It's quite long.
02:35:26 <augur> then i ended up reading about linear logic
02:35:28 <augur> then about ...
02:35:31 <augur> well you get the point
02:35:33 * ski grins
02:35:47 <augur> academic papers would be my TV Tropes
02:35:53 <augur> if TV Tropes werent my TV Tropes
02:36:06 <ski> augur : anyway, i think i need to ponder the examples you've given ..
02:36:12 <augur> also, its not THAT long, dolio
02:36:24 <dolio> 40-some pages is long for a paper.
02:36:35 <augur> dolio: i suppose it depends on the discipline
02:36:39 <augur> 40 pages is typical in linguistics
02:36:43 <augur> ski: just think of these things as set relations
02:37:07 <augur> forall (x :: Int) : prime x. x < 1
02:37:20 <augur> here we're comparing two subsets of the integers
02:37:30 <augur> namely the subset { x : prime x } and { x : x < 1 }
02:37:52 <augur> the fact that these are both subsets of the integers, well, thats an uninteresting fact
02:38:15 <augur> its just like an all function in haskell
02:38:21 <augur> only conflating functions and sets
02:38:32 <ski> would that be different from `forall (x :: Int) /\ prime x. x < 1' (or `(x :: Int) /\ prime x -> x < 1', in alternate syntax) ?
02:38:34 <augur> all :: [a] -> (a -> Bool) -> Bool
02:38:59 <augur> i have no idea.
02:39:24 <ski> (btw, why not `all_a :: (a -> Prop) -> (a -> Prop) -> Prop' ?)
02:39:26 <augur> i mean, the x :: Int thing is secondary to all of this
02:40:30 <ski> (i mean, if you convert one subset into a characteristic function of type `a -> Bool', why not do it for the other as well ?)
02:40:50 <ski> (except that doesn't work with `Bool', in Haskell .. but it'd work with `Prop' in Agda2, i think)
02:40:54 <augur> well thats fine, thats why i said we were conflating sets and functions
02:41:06 <augur> [a] ~ a -> Bool
02:41:10 * ski hates this kind of conflation :)
02:41:13 <augur> or {a} ~ a -> Bool
02:41:21 <augur> well, its a valid conflation if we're denotationalists
02:41:35 <augur> its a horrible conflation if we're algorithmists
02:41:50 <ski> sometimes, it can be, yes .. if there's a unique (or at least a canonical) isomorphism
02:41:53 <augur> well, extensionalists, lets say
02:41:59 <augur> well no, i mean
02:42:05 <augur> {a} ~ a -> Bool is perfectly valid
02:42:09 <ski> (but sometimes there's several isomorphisms, with no one to be preferred)
02:42:18 <augur> there doesnt need to be a unique anything
02:42:46 <ski> it's the same kind of thing as saying that `A /\ B' is the same as `B /\ A', no ?
02:43:03 <augur> well no thats different
02:43:14 <ski> why is it different ?
02:43:47 <augur> because its only a valid question whether or not they're the same if we treat that as mere syntax or not
02:44:24 <augur> i mean, if /\ is a unary function of two-sets, then the difference there is only one that exists in the written form
02:44:39 <augur> which is inherently ordered due to space having ordering
02:45:00 <augur> whereas there is, or at least can be, a substantive difference between sets and functions
02:45:27 <augur> the question is whether or not the conflation of some sets with some functions is a bad conflation
02:45:43 <ski> if we give an element of `A /\ B' (i.e. a pair) in a context where an element of `B /\ A' is expected, isn't is reasonable to use the same kind of conflation and say that we obviously mean to flip the parts of the pair ?
02:45:57 <augur> x <- X ~ X'(x) is perfectly valid
02:46:14 <ski> isn't this the same kind of thing as writing an element of `{a}' where an element of `a -> Prop' is expected (or vice versa) ?
02:46:16 <augur> why, well, maybe <- is just a function applicator, or maybe (-) is just notation for membership
02:46:52 <augur> ah but see, to say that A /\ B is a pair is one particular perspective on things
02:47:17 <augur> one which can only be valid if we assume space-as-such exists
02:47:27 <augur> ordering and so forth
02:47:32 <ski> (s/A \/\\ B/A * B/, if you prefer :)
02:47:46 <augur> yeah obviously its not a good conflation if /\ is pair-building
02:48:05 <augur> but in classical logic, /\ isnt a pair builder, its a two-set builder
02:48:05 <dolio> sed lets you use delimiters besides /
02:48:17 <dolio> s:A /\ B:A * B:
02:48:22 <ski> yeah .. the point i was building up to was : what if `A' and `B' is actually the same ?
02:48:22 <augur> or at least thats the essence of boolean algebra
02:48:39 <ski> dolio : ok. i've never used `sed' (manually, at least)
02:48:40 <augur> meh, who cares :P
02:49:10 <augur> my point, ski, is that its ok to conflate functions with predicates
02:49:24 <ski> augur : i meant `/\' as a builder of a set of pair. is that what you meant by "its a two-set builder" ?
02:49:37 <augur> er, functions with sets, sorry
02:49:50 <ski> augur : well, i'm not convinced that that's ok :)
02:49:55 <augur> ski: why not?
02:50:10 <augur> models with functions are isomorphic to models with sets
02:50:34 <augur> saying x <- X is no different than saying X(x)
02:50:43 <augur> on an extensional view
02:51:13 <ski> if that is so, then one shouldn't use `x <- X' at all, except possibly as an alternate form of `X(x)'
02:51:24 <augur> or maybe the reverse
02:51:31 <ski> so, in that case, there is no conflation, because `{A}' simply *is* `A -> Prop'
02:51:39 <augur> or vice versa
02:51:42 <ski> that's fine, of course
02:51:44 <augur> and mathematicians DO do this, you realize
02:51:47 <cads> how do I type synonym a function type?
02:51:50 <cads> I want to do
02:52:02 <cads> data Op = Int -> Int -> Int
02:52:06 <augur> mathematicians dont distinguish between functions and sets
02:52:10 <ski>   type Op = Int -> Int -> Int
02:52:14 <dolio> Some do.
02:52:15 <ski> if you want a type *synonym*
02:52:18 <dolio> The good ones.
02:52:24 <augur> dolio: well, it depends on their goals, i guess
02:52:34 <augur> constructivists probably do
02:52:50 <augur> and god only knows what hyperconstructivists think
02:52:58 <augur> probably not even god
02:52:59 <ski> cads : note that if you do that, then `Op' will just be another name for `Int -> Int -> Int' -- they will be the *same* type
02:53:27 <ski> cads : if you want to make a new type (e.g. to be able to catch errors with nicer messages), you can say
02:53:29 <dolio> A lot of your general statements are about ZF-style set theory.
02:53:31 <cads> augur, a function or relation :: A  -> B  has a 'trace' or a 'graph', which is a set that is a subset of the cartesian product AxB, which some mathematicians consider as distinct from the actual relation itself
02:53:35 <ski>   data Op = MkOp (Int -> Int -> Int)
02:53:37 <ski> or
02:53:39 <dolio> To a casual observer, at least.
02:53:40 <ski>   newtype Op = MkOp (Int -> Int -> Int)
02:53:54 <cads> augur,  even definding an operator graph(R) extracting the set representing r
02:54:00 <ski> cads : those are almost the same, but the `newtype' variant is probably preferable
02:54:17 <ski> cads : so `MkOp' converts from `Int -> Int -> Int' to `Op'
02:54:19 * hackagebot lhs2TeX-hl 0.1.3 - Literate highlighter preprocessor for lhs2tex  http://hackage.haskell.org/package/lhs2TeX-hl-0.1.3 (AlessandroVermeulen)
02:54:21 <cads> augur, this is often done only in more logical settings and in general what you say is true
02:54:34 <dolio> And you don't even have to be a constructivist to want to depart from ZF.
02:54:35 <augur> dolio: certainly. obviously we can get extremely foundational and question everything
02:55:00 <dolio> Like SEAR I linked earlier, or other set theories designed by category theorists.
02:55:24 <augur> but for the purposes of discussing quantifiers, i dont think theres any special distinction required between a predicate and a set
02:55:35 <cads> ski.. lightbulb :)
02:55:38 <ski> cads : there's also the `cograph' :)
02:55:59 <cads> I totally forgot about a constructor
02:56:09 <dolio> I'm a fan of those alternate set theories, too.
02:56:16 <dolio> Moreso than I'm a fan of ZF, at least.
02:56:30 <ski> @let graph :: Arrow ar => ar a b -> ar a (a,b); graph f = arr id &&& f
02:56:31 <ski> @let cograph :: ArrowChoice ar => ar a b -> ar (Either a b) b; cograph f = f ||| arr id
02:56:32 <lambdabot>  Defined.
02:56:33 <lambdabot>  Defined.
02:56:45 <augur> dolio: fine. but i dont think the distinction is a relevant one for this issue
02:57:32 <ski> cads : note that `ar a (a,b)' (read : `a -> (a,b)') can be considered an (`a'-shaped) subset of `(a,b)'
02:58:02 <ski> cads : while `ar (Either a b) b' (read : `Either a b -> b') can be considered an (`b'-shaped) quotient set of `Either a b'
02:58:07 <dolio> I wouldn't know whether it is. It probably isn't.
02:58:40 <dolio> Anything you can say about ZF can probably be interpreted as meaning something equivalent in the alternate style of set theory.
02:59:12 <dolio> Say in ZF, even.
02:59:33 * ski recalls Taylor talks about "Zermelo Type Theory"
02:59:54 <ski> (.. in "Practical Foundations of Mathematics")
03:00:58 <ski> (cads : do you see how those are "graphs" (and "cographs") in the sense you mentioned before ?)
03:02:31 <Kaidelong> why would a graph have a categorical dual?
03:02:39 <Kaidelong> or do we mean something else here?
03:02:43 <ManateeLazyCat> blackdog: Ok, i think i should give the result, i failed on my interview because my Spoken English, The English is only language in HK office, and my Spoken English is not good enough, that's all.
03:04:16 <NewUser> ManateeLazyCat: dont worry you will get another BIG job
03:04:26 <codolio> Crap, where did I leave off?
03:05:02 <ski> Kaidelong : a graph is a subobject. the dual a subobjects are quotient objects
03:05:24 <ski> s/dual a/dual of/
03:05:48 <ski> dolio : "<dolio> Say in ZF, even."
03:05:55 <dolio> Ah.
03:05:59 <dolio> Although if you think equality is a relation on sets, the structural theories would refute you.
03:06:05 <dolio> I think equality in that sense is only defined for two subsets of the same set.
03:06:10 <dolio> And otherwise, equality only applies to elements of sets, and no set is the element of a set. Sets and elements are distinct sorts.
03:06:15 <dolio> As I recall.
03:06:24 <ski> yeah
03:06:31 <quicksilver> ManateeLazyCat: shame. You'll do better next time.
03:06:51 <augur> ski: inverse species!
03:07:07 * ski sadly still knows very little of species
03:07:24 <augur> ski: byorgey's paper is excellent
03:07:30 <ski> (i'd like to get a hold of a few Joyal papers .. but they're in French, and afaict, not on-line)
03:07:53 <ski> which paper are you referring to ?
03:07:56 <ski> @where species
03:07:56 <lambdabot> I know nothing about species.
03:08:14 <augur> ski: just search for brent yorgey "oh my!"
03:08:31 <augur> http://www.cis.upenn.edu/~byorgey/papers/species-pearl.pdf
03:08:35 <augur> or click this link if you're lazy
03:09:36 <cads> ski, I was actually pretty amazed that you generated that notation so fast and wanted to ask you about it, but I'm not able to understand it now
03:09:45 <ski> @where+ species byorgey's paper : "Species and Functors and Types, Oh My!" at <http://www.cis.upenn.edu/~byorgey/papers/species-pearl.pdf> by Brent Yorgey in 2010-09  [feel free to add more interesting papers]
03:09:46 <lambdabot> Done.
03:10:07 <augur> @where species
03:10:08 <lambdabot> byorgey's paper : "Species and Functors and Types, Oh My!" at <http://www.cis.upenn.edu/~byorgey/papers/species-pearl.pdf> by Brent Yorgey in 2010-09 [feel free to add more interesting papers]
03:10:15 <augur> huh. interesting
03:10:34 <ski> @where sec
03:10:35 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
03:10:51 <ski> there's probably lots of goodies in there, that we forget about
03:10:55 <augur> ski: sicp!
03:11:02 <augur> conal is full of goodies
03:11:07 <augur> he's like a pinata
03:11:09 <ski> .. maybe we ought to have a `where-random' command
03:11:12 <ski> @where sicp
03:11:13 <lambdabot> http://mitpress.mit.edu/sicp/
03:11:22 <ski> bah, no videos there
03:11:26 <cads> ski, I want to see how those are graphs, and to learn what cographs are
03:11:40 <augur> @where sicpvideo
03:11:40 <lambdabot> I know nothing about sicpvideo.
03:11:41 <augur> @where sicpvideos
03:11:41 <lambdabot> I know nothing about sicpvideos.
03:11:42 <augur> :|
03:11:44 <cads> but tonight is busy with other studies already
03:12:25 <augur> @where+ sicpvideos http://groups.csail.mit.edu/mac/classes/6.001/abelson-sussman-lectures/
03:12:25 <lambdabot> It is forever etched in my memory.
03:12:29 <augur> @where sicpvideos
03:12:29 <lambdabot> http://groups.csail.mit.edu/mac/classes/6.001/abelson-sussman-lectures/
03:12:30 <augur> :D
03:13:04 <augur> ski: but yeah, im teaching sicp to a friend
03:13:55 <augur> we're going to modify the evaluator to at a minimum: laziness, case with patterns, curried functions, and monadic errors
03:14:00 <ManateeLazyCat> quicksilver: Thanks. :)
03:14:06 <augur> any other suggestions?
03:14:35 <dolio> Are you still going to use scheme syntax?
03:14:41 <augur> dolio: yep
03:14:52 <dolio> Because currying in lisp is, I think, a pain.
03:14:56 <ski> @where+ sicp The Wizard book : "Structure and Interpretation of Computer Programs" at <http://mitpress.mit.edu/sicp/> by Hal Abelson,Gerald Jay Sussman with Julie Sussman, videos at <http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/>
03:14:56 <lambdabot> Okay.
03:15:08 <dolio> ((((a b) c) d) e)
03:15:22 <augur> dolio: ahh see i was thinking of being more devious than that
03:15:30 <ski> iirc, Cale has some macros for auto-currying in Scheme
03:15:44 <dolio> Oh yeah, macros.
03:15:50 <ski> hm, no, maybe it was edwardk, actually
03:16:06 <augur> we'll say that if a proc has a list of params (we're ignoring the case of varargs), then we can do a comparison of # params with # args
03:16:21 <augur> and do some partial application magic
03:17:26 <augur> so that applying, say, + to 1 in (+ 1) will silently say, "aha, + has 2 params, ive got 1 arg, so construct some new proc with 1 param"
03:17:58 <augur> so itll be genuinely evaluator level, not bolted on top of the existing evaluator
03:18:01 <nostrand> augur: cool =)
03:18:16 <nostrand> augur: so all functions has one argument then?
03:18:17 <augur> nostrand: who are you 0_0
03:18:25 <ski> dolio : i case of arguments where there's no real preference for which to partially apply most commonly over, i think using multiple arguments is fine (and sometimes i use tuples for this, in Haskell)
03:18:34 <augur> nostrand: well, no, but they can be treated as such if you want to
03:18:59 <ski> (though, i usually only do that, when i want to group some arguments together, and possibly treat them as a unit, in some parts of the code)
03:19:23 <augur> ski, dolio: any other haskellisms you think would be interesting to try to add to a language?
03:19:27 <augur> maybe types
03:19:37 <ski> augur : how about `-' ? will you have a separate `negate' function ?
03:19:46 <nostrand> augur: i'm nobody =)
03:20:15 <augur> ski: yeah probably. im more concerned with just giving him a sense of curried languages more than anything
03:20:23 <ski> ah, ok
03:20:34 <ski> maybe you could try adding something list-comprehension-like
03:20:41 <dolio> Dunno. I think of handling pattern matching as a fair amount of work, but maybe that's because I've never bothered really figuring it out myself.
03:20:42 <augur> ahh list comps, thats an idea
03:20:50 <ski> (there's two or three things like that, in Scheme libraries)
03:20:56 <augur> not sure how i would add list comps without it being sugar for list bind tho
03:21:03 <augur> maybe thats an idea
03:21:28 <augur> dolio: well, pattern matching of the simple sort is actually quite easy
03:21:34 <augur> SICP goes over it, in fact
03:30:42 <Cin> Unification is easy, pattern matching trivial. A good use for the ST monad, IMHO.
03:31:24 <ski> augur : "SRFI 42 : Eager Comprehensions" at <http://srfi.schemers.org/srfi-42/srfi-42.html> by Sebastian Egner. (also `stream-of' in "SRFI 41 : Streams" at <http://srfi.schemers.org/srfi-41/srfi-41.html> by Philip L. Bewig)
03:32:12 <ski> augur : "Guide : Racket - 11 - Iterations and Comprehensions" at <http://docs.racket-lang.org/guide/for.html> (see e.g. `for/list')
03:32:26 <ski> (by the Racket / PLT Scheme devs, of course)
03:33:11 <ski> augur : "foof-loop: A Simple, Extensible Scheme Looping Facility" at <http://mumble.net/~campbell/darcs/foof-loop/foof-loop.txt> by Taylor Campbell (Riastradh on #scheme)
03:37:31 <ski> augur : those are the ones i can think of, though (do)/2 in "ECLiPSe User Manual - 5.2 Loop/Iterator Constructs" at <http://eclipseclp.org/doc/userman/umsroot023.html> in The ECLiPSe Constraint Programming System (roughly an extension of Prolog) is interesting to compare with
03:40:10 <ski> hm, i forgot to mention "The anatomy of a loop: a story of scope and control" at <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.128.5560> by Olin Shivers in 2005 (video at <http://video.google.com/videoplay?docid=-3704713569771882785>)
03:40:22 <ski> which is what "foof-loop" was inspired by
03:41:01 <ski> Cin : yeah, it becomes more fun, if you add implication into the mix
03:41:26 <ski> logic variables and skolems are (in a very rough sense) duals, yay !
03:41:50 * hackagebot splot 0.1.4 - A tool for visualizing the lifecycle of many concurrent multi-staged processes.  http://hackage.haskell.org/package/splot-0.1.4 (EugeneKirpichov)
03:43:54 <augur> i dont want loops :p
03:44:28 <augur> Cin: bottom up unification is interesting
03:44:43 <augur> bottom up unification with boolean patterns even more so
03:45:43 <Cin> Any twist beyond simple terms in unification is fascinating. :-)
03:46:01 <augur> Cin: do you know much about unification beyond basic kinds?
03:46:39 <ski> augur : (principled) loops are closely related to comprehensions
03:46:52 <augur> ski: perhaps!
03:47:15 <augur> i like the idea of doing list comps as desugaring a bind
03:47:28 <ski> (the links to loops i provided show comprehension examples, as well as more traditional loops)
03:47:41 <augur> itll introduce both complex sugaring and also give him a way to grasp bind
03:48:00 <ski> what is "bottom up" about it ?
03:48:40 <augur> ski: well, you can do (simple) unification in a sort of left-to-right substitutive fashion
03:49:05 <augur> wherein every time you bind a new variable, you substitute the value into the rest of both expressions to be unified
03:49:45 <ski> oh, right
03:49:52 <ski> now i remember you talking about this before
03:49:58 <augur> or perhaps more accurately, you substitute the whole set of bindings into the rest of the structures
03:50:07 <ski> so, this is "just" a twist on the implementation of the unification, yes ?
03:50:12 <augur> but another way would be to get sub-bindings and then merge them
03:50:24 <ski> (i.e. it would still implement the same sematics)
03:50:35 <augur> yeah, it would do the same thing
03:50:37 <augur> ideally
03:51:20 <augur> so like you'd unify '((x y) x) with '((1 2) 3) by sub-unifying '(x y) with '(1 2), yielding x = 1, y = 2
03:51:27 <augur> and sub-unifying x with 3 yielding x = 3
03:51:35 <augur> then you try to merge these bindings together
03:51:41 <augur> any inconsistencies yields failure
03:53:06 <bobzhangatthu> the ghc-user guide "7.9.5.  Template Haskell Quasi-quotation" example does not work, I build ghc --make -XQuasiQuotes Main.hs -o main, but it can not parse this line 
03:53:26 <bobzhangatthu>                [expr|'int:n|] -> print n
03:53:27 <ski> augur : *nod*
03:53:34 <bobzhangatthu> where am I wrong
03:53:45 <augur> ski: i found that this is a useful think to do when you have boolean patterns
03:53:54 <ski> why ?
03:54:14 <ski> why not propagate instantiations from one sibling child to the other ?
03:54:30 <benmachine> bobzhangatthu: are you using GHC 7?
03:54:33 <ski> (i.e. why not fail earlier ?)
03:54:46 <bobzhangatthu> 6.12.3
03:55:02 <benmachine> bobzhangatthu: ah, then you need [$expr|'int:n|]
03:55:07 <augur> ski: its more because you dont want to loose the variables in question
03:55:22 <benmachine> bobzhangatthu: GHC 7 allows you to omit the $ but earlier versions needed it
03:55:29 <Zvpun> Hey, I have "f lst elm = l ++ [e]". I tried "f = (++) . ([])" which seems wrong. How can I change the [] part (which seems wrong to me) to fit?
03:55:56 <augur> see, if you have boolean patterns, something might fail to unify, but not for any obvious reason dealing with simple substitution
03:56:31 <bobzhangatthu> thanks, but still does not work "ghc: internal error: PAP object entered!
03:56:31 <bobzhangatthu>     (GHC version 6.12.3 for i386_apple_darwin)
03:56:31 <bobzhangatthu>     Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
03:56:31 <bobzhangatthu> Abort trap"
03:56:32 <augur> rather, you end up trying wanting to substitute over something you already substituted into
03:56:35 <bobzhangatthu>  
03:56:49 <benmachine> Zvpun: f lst elm = lst ++ [elm], right?
03:57:01 <ski> Zvpun : `[e]' is `e : []' is `(:[]) e'
03:57:03 <augur> so its much easier if you just never bother with that, and instead worry about merging bindings
03:57:09 <augur> ill try to find you an example
03:58:07 <benmachine> @pl f lst elm = lst ++ [elm]
03:58:07 <lambdabot> f = (. return) . (++)
03:58:20 <Zvpun> benmachine: yes, sorry.
03:58:36 <ski> augur : hm, i'm not sure what you mean .. are you talking about things like a substitution mapping a variable `x' to a term `x && y' (e.g.), containing the same `x' (so that the substitution is not idempotent) ?
03:59:26 <ski> Zvpun : as benmachine showed, `(:[])' is also `return' in the list monad (and is also `pure', in the list applicative functor)
03:59:35 <ski> > return 3 :: [Integer]
03:59:36 <lambdabot>   [3]
03:59:38 <ski> > pure 3 :: [Integer]
03:59:39 <lambdabot>   [3]
03:59:47 <ski> > (:[]) 3
03:59:48 <lambdabot>   [3]
04:00:19 <augur> ski: ok so consider the simple boolean pattern ~1
04:00:24 <augur> which should unify with anything that isnt 1
04:00:33 <augur> that is, ~1 == 2, ~1 == 3, ...
04:00:39 <augur> but ~1 != 1
04:00:41 <ski> (Zvpun : don't worry about `return' or `pure' if you're not familar with monads or applicative functors yet. `(:[])' is just fine)
04:01:07 <augur> now suppose we have the following pattern: [x,~x] and we unify it with [1,1]
04:01:09 <ski> `!=' meaning "does not unify with" ?
04:01:12 <augur> yeah
04:01:28 <augur> if we do this left to right, we first unify x with 1, getting x=1
04:01:35 <ski> ah, right
04:01:38 <augur> substitute 1 for x into the rest
04:01:42 <Zvpun> ski: sorry when you said (:[]) is also return in the list monad, can I think of it as they are equal?
04:01:42 <augur> and unify that
04:01:43 <augur> namely
04:01:47 <augur> then we unify ~1 with 1
04:01:48 <augur> and fail
04:01:50 <augur> ok lovely
04:01:57 <augur> so that works
04:02:07 <augur> but now what about this: [~x,x] with [1,1]
04:02:16 <augur> well, what is the result if unifying ~x with 1??
04:02:21 <Zvpun> ski: thank you, I couldn't read as fast and think as you typed, so I will just not worry and later some later time.
04:02:21 <ski> the `?- X = 1,X \= 2.' vs. `?- X \= 2,X = 1.' illogicacy, in Prolog terms
04:02:47 <Zvpun> thank you for helping out and have a nice day
04:02:53 <ski> Zvpun : they are equal, when we're talking about lists .. however, `return
04:02:54 <augur> yeah, so you ultimately want constraint equations of some sort
04:03:03 <ski> ' is overloaded, so works for other things than lists
04:03:08 <ski> > return 3 :: Maybe Integer
04:03:09 <lambdabot>   Just 3
04:04:00 <augur> maybe the constraint equations go across and down, thats possible, and obviously you'd want to short circuit the unification process somehow to prevent unnecessary unification
04:04:28 <ski> augur : the result of unifying `~x' with `1' should be a disequality constraint, constraining `x' to not be `1'
04:04:34 <augur> certainly
04:04:43 <augur> but thats not a substitution algorithm anymore is it? :)
04:04:45 <ski> yeah, constraints yes
04:05:14 <ski> well, it arguably could be said to be *almost* that, if you restrict it to equality and disequality constraints :)
04:05:35 <ski> (and not introduce ordering, or arithmetic, or &c.)
04:05:56 <ski> but, yes. these `~(...)' things are strange
04:06:06 <augur> im not sure how to do full equation sets tho, honestly
04:06:21 <ski> (they have side-effects, since they do not denote a *single* value)
04:06:30 <augur> i understand, roughly, how the boolean patterns work, but i dont know how to do constraint equations
04:06:33 <Endiannes> #j lambdabot
04:06:35 <augur> which is odd, since they're equivalent, but
04:07:02 <ski> just equality and disequality between terms built out of (injective, non-overlapping) constructors, shouldn't be that bad, i think
04:07:05 <Endiannes> Oh, theres no lambdabot channel? o.o
04:07:17 <augur> > 1 + 1
04:07:18 <lambdabot>   2
04:07:24 <ski> (it's another thing, if you want to add laws, like associativity, or commutativity, &c. for the constructors)
04:07:27 <augur> ski: im not sure how that would work
04:07:35 <Jafet> Endiannes: hi, welcome to the lambdabot channel
04:07:59 <ski> Endiannes : try `/msg lambdabot > "hello"' (without the outer single quotes), if you want to query her in private
04:08:15 <Endiannes> Jafet, I thought theres a dedicated channel like #geordi
04:08:53 <ski> augur : hm, oh, your boolean patterns are wrt the boolean semantics of `&&' and `||' (as opposed to just treating them as constructors) ?
04:09:13 <augur> yeah
04:09:25 <ski> augur : now that i think of it, i think i recall that actually your `&&' and `||' was rather like `~', instead of being constructors .. mea culpa
04:09:44 <augur> basically a constraint equation like this: x = y&z
04:09:53 <augur> is the same as a set of equations x = y && x = z
04:11:03 <augur> i suppose i could just build up a single gigantic constraint equation to repeatedly evaluate every time i bind a variable
04:11:38 <augur> but i dont know how that would fail early
04:11:50 <augur> sure it would fail when a concrete value is given to it, but sometimes you never get a concrete value
04:12:39 <augur> sometimes you just get two partial values, so you'd need some decomposition rules to transform [x,1] = [2,y] into x = 2 && 1 = y
04:14:38 <Chaze> >let rotate = (uncurry take) . (length &&& iterate (uncurry (:) . (last &&& init))) in rotate "rot"
04:14:55 <Chaze> > let rotate = (uncurry take) . (length &&& iterate (uncurry (:) . (last &&& init))) in rotate "rot"
04:14:56 <lambdabot>   ["rot","tro","otr"]
04:15:06 <Chaze> can it get more nifty than that?
04:15:34 <Jafet> You could call it "rotations" instead
04:16:11 <Chaze> yeah
04:16:33 <ski> augur : ok, so since you're doing side-effects, i'm not sure how easy my "fail early" idea would be
04:16:42 <dreixel> what is the easiest way to get cabal-install under linux? I've installed ghc-6.12.3 already, but I cannot install the haskell platform because I don't have glut.
04:17:29 <ski> augur : i'd like some "nice, simple" declarative specification of what your terms/patterns mean, and what matching means. and then worry about making an efficient (or even feasible/computable) implementation
04:17:45 <orbital_fox> dreixel, get glut? :P
04:18:04 <augur> ski: who said side effects?
04:18:18 <augur> its all declarative.
04:18:25 <augur> or at least functional
04:18:58 <Jafet> > let rotations = liftM2 (zipWith (++) `on` init) tails inits in rotations "abc"
04:18:59 <lambdabot>   ["abc","bca","cab"]
04:19:11 <ski> @type (. (,)) . (.)
04:19:12 <lambdabot> forall a b b1. ((a, b) -> b1) -> a -> b -> b1
04:19:22 <Chaze> Jafet: wow
04:19:54 <dreixel> getting glut is not an option, as the machine is not mine and I'm not root
04:20:20 <ski> augur : does `x = ~(y & z)' mean `x != y /\ x != z' or `x != y \/ x != z' ?
04:21:17 <dschoepe> dreixel: you can install only cabal-install without the Platform. the archive linked on cabal's website has a script that fetches all its dependencies.
04:21:56 <augur> x = ~(y&z)  =>  x != y&z => x != y || x != z
04:22:06 <ski> s/=>/<=>/ ?
04:22:12 <augur> sure
04:22:30 <augur> the way i unify these things is basically
04:22:43 <augur> to unify x with ~(y&z)
04:22:53 <augur> unify it with y&z and if that yields some bindings, fail
04:23:02 <augur> if it fails, yield the empty binding
04:23:12 <dreixel> dschoepe: ah, ok, I'll try that script, then
04:23:26 * ski isn't really happy about that
04:23:37 <ski> negation-as-failure has known limitations
04:23:48 <augur> i know
04:23:52 <augur> im not doing logic programming
04:23:56 <augur> just advanced pattern matching
04:23:58 <ski> you are, sortof
04:24:05 <augur> that happens to involve unification
04:24:17 <augur> but its really just unification-based versions of case analysis
04:24:51 <augur> because all of these patterns exist only in the definitions of "functions"
04:24:53 <augur> like
04:25:08 <augur> foo [x,x] = true
04:25:17 <monstero> Hey guys! Is it possible to load a module with qualified name in ghci? My google-fu is failing me...
04:25:26 <augur> foo [x,~x] = false
04:25:37 <Twey> monstero: They're all loaded with qualified names automatically
04:25:46 <augur> sometimes its more complex tho, right
04:25:54 <Twey> monstero: You can access e.g. System.getArgs without importing System
04:26:18 <augur> so like, bar {1,...} = baz only applies to lists with 1's in them
04:26:21 <augur> er, sets
04:26:32 <ski> augur : unify `[x,2,3,2]' with `[~(y & z),x,y,z]'
04:26:34 <monstero> Twey: Ah. But is it possible to set a short name for a module, i.e., Data.ByteString -> B?
04:26:44 <Twey> monstero: Sadly not
04:26:53 <monstero> Twey: Okay, thanks.
04:26:54 <ski> augur : depending on which order you do the unification, won't you get success in one case, and failure in another ?
04:27:11 <augur> ski: order shouldnt matter
04:27:26 <augur> this is one reason why the approach i had been taking was a bad one
04:27:35 <augur> substitution lets you solve this right to left
04:27:38 <augur> but not left to right
04:28:01 <ski> augur : with negation-as-failure, order usually matters. you'll have to convince me it doesn't, in your use of it
04:28:31 <augur> ski: because ive gotten more devious in what ~x means ;)
04:28:55 <augur> since it's bottom up, i have a restricted subset of variable bindings
04:28:56 * ski still misses a formal declarative specification of the patterns, and the matching
04:29:02 <augur> namely, all of the _crucial_ variable bindings
04:29:15 <augur> so now the way you do x =? ~y is like this:
04:29:17 <augur> unify x with y
04:29:20 <Jafet> We don't even have amb matching yet and now what is this
04:29:43 <augur> if there are no results, succeed with the empty binding
04:30:03 <quicksilver> monstero: you can load a small haskell file which loads the modules with your personally preferred short names
04:30:24 <ski> Jafet : surely it is madness ;-P
04:30:29 <augur> if there are some results, derive a new set of bindings in which each variable is negated. e.g. if x =? y yields { foo = 1, bar = 2 }
04:30:47 <augur> then you yield the two sets { foo = ~1 }, { bar = ~2 }
04:31:13 <hpc> :t (~)
04:31:14 <lambdabot> parse error on input `)'
04:31:23 <ski> how about if `x =? y' yields two sets `{ foo = 1, bar = 2 }', `{ foo = 1, bar = 3 }' ?
04:31:26 <augur> because if x =? y succeeds with those bindings, then the only ways in which x =? ~y could succeed is if either foo ISNT 1, or bar ISNT 2
04:31:40 <ski> hpc : this is not-Haskell
04:31:55 <augur> thats fine, then you just get three possibly ways of failing
04:32:34 <ski> so you turn the disjunction-of-conjunctions into a conjunction-of-disjunctions (by negation), and then normalize to disjunction-of-conjunctions, again ?
04:32:34 <augur> tho i dont know how you'd get bar binding two distinct numbers
04:32:42 <augur> oh, no, its possible
04:32:54 <augur> man stop with the hyphenations :|
04:33:02 <ski> `[foo,bar] = [1,(2 | 3)]'
04:33:08 <augur> yeah there you go
04:33:17 <augur> the only way that could fail is if either foo is not 1
04:33:27 <augur> or if foo is neither 2 or 3
04:34:01 <ski> (hpc : or were you wondering about the Haskell `~ <pat>' pattern construct ?)
04:34:21 <hpc> ski: i was confused as to what you were discussing
04:34:25 <hpc> i understand ~pat
04:34:26 <augur> obviously theres going to be different interactions when it comes to disjunction than conjunction
04:34:36 <hpc> also i was wondering if (~) could be a function as well
04:34:49 <dreixel> dschoepe: thanks, that worked fine ;-)
04:35:44 <augur> but ski, that unification, with one side negated, should succeed also in the case where the other side is not a list at all
04:35:47 <augur> or is a list of a different length
04:36:17 <ski> hpc : augur is considering a pattern-language, with not only matching, but unification, but specifically, with negation-, disjunctive, and conjunctive patterns
04:36:34 <hpc> oh, nifty
04:36:49 <augur> ski: i'd point out that i've considered scrapping the boolean patterns out of simplicity ;)
04:36:52 <hpc> and you are determining how possible it is?
04:36:55 <ski> hpc : `<var> @ <pat>' in Haskell is basically a conjunctive pattern, except the left-hand-side `<var>' is restricted to be a variable, instead of any pattern
04:38:08 <monstero> Okay, one more question: I need to parse doubles, ideally a function String -> Maybe Double (actually, from ByteString would be even better). All I can find is read, which throws an exception, and an example on the wiki involving calling out to C and general scariness. Any ideas?
04:38:23 <Jafet> monstero: in general, you use reads instead of read
04:38:26 <Jafet> :t reads
04:38:26 <lambdabot> forall a. (Read a) => String -> [(a, String)]
04:38:37 <dolio> There's a package for bytestrings.
04:38:45 <dolio> bytestring-lexing or something.
04:38:47 <dschoepe> monstero: there's also the `safe' package on hackage, that provides more convenient variants
04:38:54 <dschoepe> :t readMay
04:38:55 <hpc> monstero: a successful read from reads will match the pattern [(val, "")]
04:38:55 <lambdabot> Not in scope: `readMay'
04:38:57 <monstero> ah, nice.
04:39:01 <dschoepe> :t Safe.readMay
04:39:02 <lambdabot> forall a. (Read a) => String -> Maybe a
04:39:33 <monstero> dschoepe: safe looks like the answer. Thanks!
04:39:42 <dolio> Kind of an amusing package. *All* it does is read doubles.
04:39:59 <monstero> Well, it *is* pretty important.
04:40:30 <dolio> Yeah, but I'm relatively certain that there are other things that aren't readable from bytestrings easily. And the name is general enough to have those too.
04:40:36 <Jafet> dolio: makes you wonder how much legacy, bug-ridden numerical code in the future will be in haskell
04:40:39 <dolio> But dons only has so much time, I guess.
04:41:11 <monstero> Jafet: I'm making bug-ridden, soon to be legacy numerical code right now.
04:41:43 <Jafet> Ai-ieee.
04:42:45 <ski> hpc : OCaml (and iirc, some SML implementations) has disjunctive patterns : <http://rosettacode.org/wiki/Pattern_matching> (scroll down to OCaml, cf. Haskell) , <http://caml.inria.fr/pub/docs/manual-ocaml/patterns.html> (see "“Or” patterns")
04:42:48 <hpc> hehe, legacy haskell
04:43:10 <monstero> I just need to finish the stupid IO layer, so I can work on the nice mathematical stuff.
04:46:49 <hpc> perhaps skip the IO layer and test in ghci?
04:47:34 <augur> hpc: im teaching sicp to a friend. what could i add to scheme to make it more interesting, from a programming-language-theory perspective?
04:48:00 <augur> ive got laziness, case-with-patterns, curried functions, maybe/error monads, and list comprehensions
04:48:12 <hpc> augur: not sure, actually; some of those are already in the book
04:48:20 <hpc> algebraic data types?
04:48:49 <hpc> it looks a lot like you are just reimplementing haskell in scheme though
04:48:56 <monstero> hpc: I know, I've done that. I have to get the IO done sooner or later, though. Testing only through ghci is painful in the long run.
04:48:57 <augur> to some extent
04:49:05 <augur> we're also going to be looking at haskell
04:49:22 <augur> the idea is to sort of de-mystify things
04:49:45 <hpc> i think having the extra language will just make it harder
04:49:55 <hpc> nothing beats good examples, etc etc
04:50:04 <augur> we're also eventually going to talk about prolog-esque logic programming and two kinds of non-deterministic computation (backtracking vs. list monads), as well as continuations
04:50:20 <augur> hpc: oh no, we're doing all of this stuff in scheme precisely to demystify
04:50:37 <augur> hes just also interested in haskell because haskell has a lot of cool fun stuff built in :p
04:50:42 <hpc> oh i see
04:50:50 <hpc> because scheme doesn't have it, he can see how it works
04:50:53 <augur> so scheme provides a nice easy way to take some otherwise magical things and pull back the curtains
04:51:02 <augur> by showing how we'd actually build it into a language
04:51:05 <hpc> nice!
04:51:49 <augur> i think we could also talk about parsing at some point
04:52:02 <augur> but for now, what would be cool to add to a language to explore as a programming concept/
04:52:04 <hpc> that reminds me, i still need to learn parsec
04:52:10 <augur> or what in general is interesting to teach?
04:52:19 <augur> ahh thats another one, species
04:52:25 <augur> also, combinatorial parsing
04:52:56 <hpc> augur: perhaps type checking?
04:53:06 * augur nods
04:53:11 <hpc> not sure how difficult it would be in scheme though
04:53:23 <augur> difficulty is no reason to not do it :P
04:53:47 <augur> i dont know the HM type inference algo but im sure i can figure it out
04:53:53 <augur> or provide some primitive version of it
04:54:02 <augur> thats something we could do, advanced type systems
04:54:29 <augur> remind me the distinction between ADTs and GADTs?
04:54:35 <hpc> i always thought of type inference as "type level pattern matching"
04:54:46 <augur> yeah basically
04:55:13 <hpc> it really helps, when you try to explain it to someone who already gets regular patterns
04:55:28 <Jafet> In GADTs, alternatives can have different types. Or something.
04:56:00 <augur> ah, parametric types
04:56:25 <dolio> ADTs are defining a type T by induction. GADTs are defining a type-indexed family of types F a by induction.
04:57:12 <augur> mm, type classes, thats something to discuss
04:57:46 <augur> we already discussed generic operators, so it'd be nice to tie that back in once we have types
05:03:18 <Endiannes> < let foo = (sin)/(2+3)
05:03:23 <Endiannes> > let foo = (sin)/(2+3)
05:03:24 <lambdabot>   not an expression: `let foo = (sin)/(2+3)'
05:03:29 <Endiannes> Why cant I curry that?
05:03:54 <hpc> Endiannes: follow the types
05:03:58 <mino> hi i want to draw with cairo + gtk2hs, but i have a problem, renderWithDrawable returns in IO monad but gtk2hs seems that wants to treat events in EventM monad, that is ReaderT (Ptr a) IO b, im not sure how to make the translation
05:04:02 <hpc> also, make it a complete expression
05:04:03 <Endiannes> Oh
05:04:10 <hpc> > let foo = (sin)/(2+3) in foo 4
05:04:11 <lambdabot>   -0.15136049906158566
05:04:23 <hpc> (it works in lambdabot because of crazy num instancing)
05:04:37 <hpc> :t (/)
05:04:38 <lambdabot> forall a. (Fractional a) => a -> a -> a
05:04:39 <hpc> :t sin
05:04:40 <lambdabot> forall a. (Floating a) => a -> a
05:05:14 <augur> does haskell have a regex library?
05:05:20 <hpc> augur: yes; it blows
05:05:21 <augur> i just realized i hadnt thought about this
05:05:24 <augur> hpc: lame :(
05:05:24 <hpc> :t (=~)
05:05:25 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
05:05:27 <Jafet> It has too many
05:05:41 <augur> haskell 2010 should have built in regex :|
05:05:43 <hpc> ^ is my favorite bad type ever
05:05:43 <ski> augur : "ADT" can expand to either "Algebraic Data Type" or to "Abstract Data Type"
05:05:45 <augur> why doesnt it
05:05:56 <augur> ski: algebraic in this case
05:06:04 <Endiannes> ski, Or argument dependant type :p
05:06:07 <mino> well my question is how to go from IO a to ReaderT (Ptr  a) IO b , i e EventM, is this possible?
05:06:12 <Jafet> There should just be one that's a thin wrapper for parsec. And world peace.
05:06:22 <ski> Endiannes : ooi, where's that from ?
05:06:30 <Jafet> augur: ...Text.Regex is part of base
05:06:44 <Endiannes> ski, From C++ :)
05:06:54 <augur> Jafet: eh. but can i use actual regex expressions like /blah/
05:06:56 <ski> mino : maybe `liftIO' is what you need ..
05:06:58 <augur> or is it all string based
05:07:07 <ski> Endiannes : and it means what ?
05:07:08 <hpc> augur: it's string based
05:07:16 <augur> hpc: yeah, thats sucky.
05:07:17 <hpc> foo =~ "/blah/"
05:07:30 <augur> regex should be native
05:07:35 <Endiannes> ski, A type dependant on ADL.
05:07:43 <augur> theres no excuse for it not being so
05:07:50 <ski> mino : `liftIO (renderWithDrawable blah bleh)', or something like that
05:07:57 <hpc> i was thinking regex should be more strongly typed
05:08:00 <Jafet> augur: I suspect it would interfere with your logical pattern matching syntax
05:08:09 <mino> ski: omg, thanks, yeah, yeah ive just noticed thats the way
05:08:11 <ski> mino : `liftIO' will go from `IO Whatever' to `ReaderT (Ptr a) IO Whatever'
05:08:13 <Jafet> hpc: that's very nice, and called parser combinators
05:08:14 <hpc> (=~) :: String -> Pattern -> Result
05:08:22 <hpc> Jafet: :P
05:08:31 <sipa> it should be possible to write pattern for any [a] type
05:08:43 <Jafet> (=~) is so generic, because of the instances people wanted to shove in it
05:08:58 <ski> mino : .. or `EventM Whatever' if that's what you want (provided there's an `MonadIO EventM' instance)
05:09:02 <augur> Jafet: what?
05:09:08 <hpc> Jafet: and yet the return values still suck
05:09:18 <sipa> (=~) :: Eq a => [a] -> Pattern a -> Result a
05:09:18 <ski> Endiannes : 2a type dependant on argument dependant type" ?
05:09:29 <hpc> seriously, (String, String, String, [String]) is not a nice type
05:09:39 <Endiannes> ski, Its a type which type depends on argument dependant lookup.
05:09:40 <Jafet> It can match a ByteString to a Sequence and return a who-knows-what, if you write all the proper instances for it
05:09:50 <ski> hpc : we need light-weight record types ?
05:10:10 <ski> Endiannes : i'm not sure what that means
05:10:28 <Endiannes> ski, Its C++ specific, doesnt exist in haskell :<
05:10:41 <ski> yeah, but what does it mean, *in* C++ ?
05:11:05 <Endiannes> ski, Sort of like pattern matching, when it can deduce a type at compile type, depending on the arguments you supply.
05:11:19 <Zao> ADL (or Koenig Lookup), lets you look up function names in the namespaces of the parameters.
05:12:14 <Zao> Say that you have namespace Foo { struct T {}; void f(T, std::string const&); }, then you can say   Foo::T t; f(t, "lol");
05:12:42 <Zao> (it searches in the scopes of the argument types, and their ancestor scopes, and such :D
05:13:50 <hpc> how does it resolve collisions?
05:14:27 <ski> Zao : ok, so a scope thing, then
05:14:28 <Endiannes> Zao, I guess a better example would be /*Don't need std::, because of ADL*/getline(std::cin, std::string)
05:15:15 <Zao> Endiannes: Sure, assuming that the reader knows about std::getline.
05:21:39 <zygoloid> ski: an (argument-)dependent type is a type which depends on a template parameter.
05:21:50 <zygoloid> this could be through ADL or through another mechanism
05:22:16 <zygoloid> for instance, in a template<typename T>, std::vector<T> is a dependent type but ADL is not involved
05:22:22 <ski> oh, i misread "ADL" as "ADT", above
05:22:28 <ski> so what does "ADL" expand to ?
05:22:33 <zygoloid> argument-dependent lookup
05:22:38 <ski> ah, ok
05:22:58 <quicksilver> but this is more a kind of 'type-directed name resolution'
05:23:05 <quicksilver> it's just a scoping/name lookup thing
05:23:16 <quicksilver> it's not any kind of polymorphism
05:23:18 <ski> so, why is `std::vector<T>' dependent ?
05:23:32 <ski> because `T' doesn't have an explicit namespace qualification ?
05:23:38 <zygoloid> because the type selected depends on the template parameter T (because C++'s templates aren't parametric)
05:23:49 <ski> oh
05:23:56 <ski> i see
05:30:15 <Endiannes> > let plot f y0 y1 x0 x1 dx = map (\a -> "_.,=-*'~`" !! round ((f a - y0)/(y1 - y0)*8)) [x0, x0 + dx .. x1] in plot sin (-1) 1 0 (5 * pi) 0.3
05:30:16 <lambdabot>   "-*'~```~~'*=,..___.,=-*'~```~~'-=,.____.,=-*'~```~~'-"
05:30:18 <Endiannes> Woo :)
05:31:00 <Endiannes> I wonder is it possible to remove that lambda function and sort of curry it into map?
05:31:07 <FauxFaux> Slightly less readable than the C++ version; geordi: typedef double D;void plot(D(*f)(D),D ymin,D ymax,D xstart,D xstep,D xend){char c[]="_.,=-*'~`"; for (D x=xstart;x<=xend;x+=xstep){size_t h=size_t((f(x)-ymin)/(ymax-ymin)*sizeof(c));cout<<(h<sizeof(c)?c[h]:' ');}} int main() { plot(sin, -1, 1, 0, 0.3, 5 * M_PI); }
05:31:39 <FauxFaux> Actually, that's really not bad for c++. :p
05:31:39 <Kaidelong> how do I put, in a type constraint, something like
05:31:48 <Kaidelong> "Vector v a" where a isn't a type variable
05:31:56 <Kaidelong> but says that v is a vector for ANY type
05:32:13 <Kaidelong> not just a
05:32:21 <Endiannes> FauxFaux, Slightly more readable, Eelis used the non canonic argument order xmin, xstep, xmax instead of xmin, xmax, xstep :P
05:32:31 <quicksilver> forall a . Vector v a
05:32:37 <quicksilver> but there are things you can't do
05:32:39 <sipa> Kaidelong: v ~ Vector a ?
05:32:46 <quicksilver> haskell doesn't have higher-order contexts.
05:32:49 <Kaidelong> quicksilver: GHC complains about a malformed class assertion
05:32:54 <Kaidelong> so it's not possible?
05:32:59 <quicksilver> yes.
05:33:18 <sipa> Kaidelong: how is Vector defined?
05:34:18 <Kaidelong> sipa: depends which one is being used? now that I think about it it wouldn't make sense neccessarily since unboxed vectors can't hold all types... but then again you could just exclude those vectors as a possibility
05:34:28 <Kaidelong> sipa: I don't know much about how Data.Vector is actually implemented
05:34:59 <Endiannes> FauxFaux, I didnt know you're a haskeller :o
05:35:15 <FauxFaux> Actually, I'm just a cross-language troll.
05:35:59 <haskeller> No, he's not me.
05:36:10 <haskeller> I'm one of a kind.
05:36:17 <haskeller> =)
05:36:21 <FauxFaux> /msg nickserv ghost haskeller
05:38:51 <Endiannes> So... back yo my question, is it possible to remove the lambda function and curry it into map? Like you do with (+) and such.
05:39:00 <Endiannes> s/yo/to/
05:39:09 <parcs> @pl (\a -> "_.,=-*'~`" !! round ((f a - y0)/(y1 - y0)*8))
05:39:09 <lambdabot> ("_.,=-*'~`" !!) . round . (8 *) . (/ (y1 - y0)) . subtract y0 . f
05:39:28 <parcs> that's not bad actually
05:39:38 <FauxFaux> Not in any readable way, as parcs beat me to demonstrating. :p
05:39:57 <parcs> it's quite readable imo
05:40:06 * Endiannes tries to understand that
05:41:02 <quicksilver> Endiannes: lambda function?
05:41:08 <Twey> Endiannes: Not *any*… you can't pattern-match with a function, so you need to have a helper function available that does the pattern you want
05:41:31 <Twey> Endiannes: Other than that, yes, I believe so, though the result may not always be desirable
05:41:37 <Endiannes> Twey, quicksilver I was just reffering to the one above ^, parcs did it already.
05:41:47 <Kaidelong> is there a way I can get GHCi to show me the size of a data structure?
05:41:49 * quicksilver nods
05:41:55 <quicksilver> Kaidelong: not as far as I know.
05:41:59 <Kaidelong> alright
05:42:37 <Twey> Yeah, the version λb gave is probably nicest
05:44:41 <Endiannes> I have a feeling that haskell is extremely similair to c++ template metaprogramming :|
05:44:52 <Twey> Endiannes: Except sane.
05:45:06 <Endiannes> Twey, True..
05:45:06 <revenantphx> Templating seems like it'd go better with strong typing.
05:45:20 <Jafet> It is, like C++, sufficiently capable of being insane.
05:45:55 <Kaidelong> {-# LANGUAGE GeneralizedNewtypeDeriving, FlexibleInstances, MultiParamTypeClasses, FlexibleContexts, UndecidableInstances, Rank2Types #-} <-- is it bad to have all these at once?
05:46:13 <Kaidelong> or do a lot of real things use so many extensions?
05:46:32 <revenantphx> Is there a more up to date equivalent to EnumMap?
05:46:33 <Twey> Many real things use a comparable number of extensions
05:46:33 <Jafet> Yes, just use {-# OPTIONS -fglasgow-exts #-}
05:46:44 <Twey> I'm not so sure about having UndecidableInstances in there
05:46:58 <Kaidelong> Twey: it won't compile if I take any of those out
05:47:08 <Kaidelong> that said the type checker has not timed out yet
05:47:09 <Twey> Obviously, because you've designed it to use them
05:47:48 <Kaidelong> Jafet: isn't that bad for portability? not that I expect this to be portable... but in theory
05:47:50 <Jafet> If you're looking at oleg's magical instance constraints for your Vector, you'll probably need them all
05:48:10 <Jafet> "It's portable to any platform ghc is!"
05:48:34 <Kaidelong> Jafet: to other Haskell compilers
05:49:14 <Kaidelong> anyway no time to redesign it
05:49:25 <Jafet> Is there a good reason you're worrying about that?
05:49:27 <Kaidelong> the band now plays sets of bus routes just fine
05:49:45 <Kaidelong> Jafet: no, but I thought that was the rationale behind avoiding the OPTIONS pragma
05:50:05 <Jafet> That was jocular
05:51:30 <Kaidelong> probably need a better function name than ensembleFromSizeBoundsAndPriorityList
05:53:18 <Kaidelong> type signature is also ugly
05:54:14 <Kaidelong> http://codepad.org/1b9YXu8R
05:57:31 <revenantphx> Why did IntMap have to make the type "Key"
05:57:36 <revenantphx> why can't it just use Int32 or something.
05:57:41 <revenantphx> (this is why I wish enummap worked)
05:59:15 <Jafet> Because it's not Int32Map?
05:59:48 <revenantphx> Well, it could use Int as a key
05:59:51 <Kaidelong> @instances Storable
05:59:51 <lambdabot> Couldn't find class `Storable'. Try @instances-importing
06:00:54 <Jafet> It does
06:00:56 <Jafet> type Key = Int
06:01:44 <revenantphx> Oh right.
06:01:52 <revenantphx> It's just a pain since my keys are all Int32...
06:01:59 <revenantphx> it'd be nice if EnumMap was updated.
06:02:46 * Endiannes wonders how an fsm in haskell would work
06:04:11 <quicksilver> Endiannes: one way to do it is with a simple ADT to represent the state
06:04:20 <quicksilver> Endiannes: and pattern matching to define evolution.
06:04:42 <Endiannes> quicksilver, ADT to represent the state?
06:05:17 <revenantphx> Kind of like how functions are often made with patterns [x:xs], [], and x:[]
06:05:18 <revenantphx> etc
06:05:33 <revenantphx> Those patterns match different "states" of the list.
06:05:34 <Endiannes> Hmm
06:05:37 <quicksilver> Endiannes: data FSMState = Blah | Bar | Baz | Bof
06:05:46 <krey> o/ I found this code to do a breadth first traversal on a tree, can somebody explain how it works? http://pastebin.com/6x51SDvf
06:06:07 * Kaidelong gets hashes working for his solutions...
06:06:23 <revenantphx> myFSMFunc = FSMState -> (FSMState, ResultState)
06:06:23 <revenantphx> myFSMFunc (Blah a) = ....
06:06:23 <revenantphx> myFSMFunc (Bar a) = ....
06:06:28 <ski> (revenantphx : itym s/[x:xs]/x:xs/)
06:06:33 * Kaidelong thinks he should either move on from buses or start documenting it before he stops being able to understand his own code....
06:06:37 <revenantphx> ski: right right
06:06:59 <Endiannes> revenantphx, But that wouldnt be very maintanable...
06:07:05 <quicksilver> Endiannes: why not?
06:07:08 <revenantphx> it was just off the top of my head >_>
06:07:22 <revenantphx> (the ResultState is so that you can *get* something out of the FSA)
06:07:42 <revenantphx> (you could have a function driving it which continues until the state is something)
06:07:56 <Endiannes> Hmm, now that I think about it, it seems ok..
06:08:04 <revenantphx> if say it was a vending machine that takes two coins, if the result state is "Needs more coins" it could call the function again on the resulting FSMState
06:08:18 <revenantphx> if the state is "Soda!" then it's done and can return the soda type or whatever it cares to do.
06:09:12 <revenantphx> There's probably a better way.
06:09:18 <Endiannes> revenantphx, Would I need all the myFSMFunc's in one file for it to work correctly?
06:09:26 <revenantphx> Endiannes: ?
06:09:36 <revenantphx> why wouldn't all of the patterns be with eachother?
06:09:40 <quicksilver> you need all the cases of one particular function in one file, yes
06:09:45 <Endiannes> Awe :(
06:09:48 <waterlaz|work> type STRep s a = State# s -> (# State# s, a #)
06:09:55 <quicksilver> you can have multiple different functions though.
06:09:55 <waterlaz|work> what do the "#" mean ?
06:10:01 <Endiannes> revenantphx, Because if several people work on the concrete fsm, using the same file isnt always a good idea.
06:10:05 <quicksilver> waterlaz|work: they mean "this is not as it appears"
06:10:22 <quicksilver> waterlaz|work: ... they mean the types/functions involved are internal GHC things, often primitives.
06:10:38 <waterlaz|work> ok, I see
06:13:05 <ski> waterlaz|work : `(# .. , .. #)' is an unboxed tuple type
06:13:10 <jon_of_arc> waterlaz: strictly speaking they're just symbols that can appear in identifiers, but yes, the convention is that GHC internals use them
06:13:29 <quicksilver> Endiannes: I'm not really sure I accept that reasoning in isolation (source code control is a fairly well solved problem with modern DVCS). But if it really upset you then you could use a preprocessing step to join your FSM definition into a single file.
06:13:35 <quicksilver> jon_of_arc: no, they're not.
06:13:44 <waterlaz|work> oh, thanks ski
06:13:46 <quicksilver> jon_of_arc: they're symbols that CANNOT appear in identifiers.
06:13:55 <jon_of_arc> quicksilver: really? They're at the least accepted as operators…
06:13:59 <quicksilver> jon_of_arc: (but GHC has an extension to permit them, -XMagicHash)
06:14:11 <quicksilver> correct. In standard haskell they are operator symbols not identifier symbols.
06:14:25 <jon_of_arc> quicksilver: huh. Missed that distinction, thanks
06:14:42 <quicksilver> with the extension on they are 'magic' symbols which can appear in both, which is posisbly confusing and I think it's whitespace sensitive.
06:14:43 * Endiannes makes an fsm
06:15:04 <quicksilver> that is, (a#b), (a # b) and (a# b) all parse potentially differently
06:15:07 <revenantphx> Endiannes: https://gist.github.com/733322
06:15:11 <quicksilver> whereas in standard haskell they all parse as (a # b)
06:15:35 <revenantphx> well, that's incomplete, and can't lop.
06:16:00 <applicative> @type 3#
06:16:01 <lambdabot> GHC.Prim.Int#
06:16:18 <applicative> @type 3.3#
06:16:18 <lambdabot> GHC.Prim.Float#
06:16:27 <hpc> :t (#)
06:16:28 <lambdabot> parse error on input `)'
06:16:32 <applicative> @type 'a'#
06:16:32 <lambdabot> GHC.Prim.Char#
06:16:35 <Endiannes> revenantphx, I think I'm going to over-engineer it a bit.
06:16:39 <applicative> @type "hahahah"#
06:16:40 <lambdabot> GHC.Prim.Addr#
06:16:43 <revenantphx> I'll make a better example... this is fun :3
06:17:09 <Endiannes> Hmm
06:17:23 <xplat> say, is there a builtin combinator in iteratees for running a pair of iteratees in parallel?
06:17:44 <Endiannes> If I make an haskell UML fsm, with the abillity to generate it from and to UML, would it be usefull for anyone else?
06:17:51 <xplat> i tried (&&&) from arrows but i just got a kind error
06:18:01 <quicksilver> applicative: good point, it's even more subversive than I suggested.
06:18:17 <quicksilver> applicative: they can appear in identifiers, operators *and* literals.
06:18:38 <quicksilver> MagicHash-- # subversive
06:19:31 <xplat> hashes, sharps, and octothorpes wild
06:19:51 <revenantphx> ack, one moment...
06:20:13 <Jafet> A sharp number is pounding hash
06:20:31 <revenantphx> some mistake hereand it wont compile
06:20:31 <revenantphx> https://gist.github.com/733329
06:20:35 <revenantphx> but this gets the idea across I think
06:21:04 <revenantphx> apparently the empty on line 12 is wrong
06:25:19 <applicative> xplat I take it you've seen, e.g. http://okmij.org/ftp/Haskell/Iteratee/IterateeN.hs  
06:26:27 <revenantphx_> So now that I think about it, monads can model FSA's to a certain degree...
06:26:33 <revenantphx_> that might be a better option for you Endianness.
06:26:48 <revenantphx_> But that sounds more complicated >_<
06:27:05 <Endiannes> revenantphx_, I don't quite understand monads yet, using haskell for pretty much 2 days so far.
06:27:32 <aleator> How do I get little endian from big endian?
06:27:48 <Endiannes> aleator, In haskell ? o.o
06:28:00 <revenantphx_> You reverse the bytes... but in haskell there's no need unless you're sending it or receiving it.
06:28:02 <aleator> Endiannes: Naturally in haskell :)
06:28:26 <Endiannes> I dunno how to get the loword or hiword of a byte in haskell :(
06:28:42 <aleator> Well, some guy just gave me few gigabytes of big-endian floats. Data binary parses it for half an hour
06:28:44 <Endiannes> of a word*
06:29:19 <Saizan> see Data.Bits
06:29:22 <revenantphx_> 0.o
06:29:53 <Saizan> though you might just want to use Data.ByteString.Lazy 
06:30:32 <aleator> Saizan: Well, runGet (replicate enough) getFloat32be just isn't fast enough.
06:30:40 <dpratt71> I want to divide a variable number of items evenly among a fixed number of 'buckets'. Is there a well-known algorithm for doing that?
06:31:16 <aleator> The data in question is (240*320*512) datacube.
06:31:20 <dpratt71> trivially, if I have 100 items and 20 buckets, I want 5 items in each bucket
06:31:33 <Endiannes> dpratt71, 100/20 = 5
06:31:51 <Jafet> aleator: there's always C FFI
06:31:53 <Saizan> aleator: if you want to keep them all in memory at once you shouldn't use a list
06:32:22 <dpratt71> less trivially, if I have 110 items, I would want something like [5,6,5,6,5,6...]
06:32:26 <Jafet> I would translate the file in a preprocessing pass
06:32:36 <aleator> Saizan: I put them in an Array with listArray, but that is quite a bottleneck
06:32:48 <aleator> since they go through the list
06:32:48 <dpratt71> in other words, I don't want to dump the remaining items in one bucket
06:32:53 <Saizan> aleator: you should use UArray
06:32:59 <Jafet> dpratt: you can write that with a fractional counter and unfold
06:33:12 <dpratt71> I want as even a distribution as possible
06:33:17 <unkanon_> Saizan: is U for unboxed?
06:33:22 <Saizan> unkanon_: yes
06:33:32 <unkanon_> ok.
06:33:49 <dpratt71> Endiannes: yes, that's why I said that example was 'trivial' :)
06:33:50 <Saizan> aleator: going through the list shouldn't be a big problem if you manage to produce/consume it lazily
06:34:19 <Jafet> I expect he wants to march through it or something
06:34:22 <aleator> Saizan: I think that depends on how listArray is implemented
06:34:29 <Jafet> I would do direct file seeking for that, though
06:34:54 <aleator> What I need to do is extract planes in the cube
06:34:58 <Endiannes> dpratt71, Well, if you have leftover items, just traverse your buckets and keep adding an item till you have none.
06:35:06 <aleator> So it pretty much cannot be consumed lazily
06:35:22 <Saizan> consume to put it in the array.
06:35:41 <Saizan> > 240*320*512 * 4
06:35:42 <lambdabot>   157286400
06:35:46 <dpratt71> Endiannes: I thought about that, but it would server to front-load or back-load the buckets depending on which way I went about it
06:35:49 <Jafet> aleator: "cube"? Is that voxel sample data?
06:35:59 <aleator> Jafet: spectral image
06:36:07 <Saizan> > 240*320*512 * 4 / (1024*1024)
06:36:08 <lambdabot>   150.0
06:36:12 <dpratt71> lacking a better idea, that's probably what I'll do
06:36:31 <Saizan> aleator: 150 mb shouldn't be too much of a problem
06:36:31 <aleator> Saizan: I currently have is  runGet (listArray ((0,0,0),(w-1,h-1,d-1)) <$> replicateM (w*h*d) getFloat32be)
06:36:32 <Jafet> aleator: http://alvyray.com/memos/6_pixel.pdf
06:36:34 <Endiannes> dpratt71, You could just skip every odd or even bucket, then it would be even.
06:37:06 <Saizan> aleator: compiling with -O2 ?
06:37:27 <dpratt71> Endiannes: unless I'm missing something, that would assume that the remainder is exactly half the divisor
06:37:32 <aleator> Saizan: Yes. Takes 1min 30sec for single cube
06:38:02 <jon_of_arc> Or you could take your initial number, divide it by the number of buckets (as a Rational), add the floor to each bucket after adding accumulated remainders and accumulate the remainder
06:38:09 <Saizan> aleator: ah, but which array type?
06:38:37 <jon_of_arc> (That may take some work to parse, my apologies; I haven't had coffee yet)
06:38:39 <aleator> Saizan: Currently I've got CArray to make things easier for me. (Currently modifying it to UArray as we speak)
06:39:06 <Endiannes> dpratt71, Well, if you want really really even distribution, you would have to divide the amount of buckets by the remainder.
06:39:06 <dpratt71> jon_of_arc: I think I get it; I'll give that a try, thanks
06:39:10 <Jafet> jon: usually done with unfoldr and splitAt
06:40:13 <applicative> @type splitAt
06:40:13 <lambdabot> forall a. Int -> [a] -> ([a], [a])
06:40:14 <Endiannes> dpratt71, E.g. your example with 110 20, would be, 110 / 20 = 5, (ceiled), mod 110 20 = 10, 20 / 10 = 2.0, so you skip every second bucket.
06:40:42 <dpratt71> Endiannes: yes, I think that could work as well. thanks much :)
06:40:45 <aleator> Ah. darn. UArray doesn't have slices
06:40:58 <quicksilver> aleator: does your whole data set fit in memory anyway?
06:41:39 <aleator> quicksilver: Easily. 32gb of memory and each cube is just 30mb something
06:41:53 <Jafet> Slice them yourself
06:42:04 <Saizan> ah, the Get monad is now a strict state monad, so it might build the whole list first, sigh.
06:42:25 <quicksilver> some of the new vector stuff has zero-copy slicing
06:42:40 <quicksilver> it's probably safest to chunk the IO reading by hand, I'm not sure.
06:42:42 <aleator> quicksilver: But sadly, it works only in 1D
06:42:52 <copumpkin> aleator: repa?
06:43:08 <revenantphx_> hm
06:43:10 <xplat> applicative: yeah, i've seen Oleg's articles on iteratees in parallel and enumerators in tandem, but his articles tend to be written with his own library rather than the ones that people standardized on afterward, and also i was looking for something built-in if it's there.  porting his examples was my fallback plan.
06:43:22 <aleator> copumpkin: Hey thanks. I totally forgot about that thing.
06:44:12 <aleator> But anyways, I think I'm back to square a, which is to mmap the file and somehow flip endiannes.
06:44:45 <unkanon_> Endiannes: you mean floored instead of ceiled? 5.5 ceiled is 6
06:46:10 <applicative> xplat, i figured, on reflection, that that was your meaning.
06:49:38 <applicative> xplat, if you figure out simple combinators to fit with one of the packages, you should Hackage them with extensive comments and simple examples :)
06:50:11 <Saizan> aleator: i'd use bytestring-mmap and then a loop with splitAt and reverse, wrapped in concat
06:50:48 <applicative> xplat, I suggest this for the benefit of the simple people, not people like myself who have to comprehension .... ha
06:51:04 <applicative> have total comprehension
06:51:42 <earthy> xplat: doesn't the 'iteratee' package have an enumPair function you could use?
06:52:48 <applicative> enumPair -- |Enumerate two iteratees over a single stream simultaneously.
06:53:19 <earthy> I may have misunderstood the question though ;)
07:01:01 <xplat> ah, ListLike seems to be where all the combinators were hiding that i was scratching my head over why they didn't seem to be concluded
07:01:11 <xplat> included, that is
07:01:28 <earthy> oh, right, yeah
07:02:10 <earthy> John Lato did great work, but the Iteratee package is not exactly easy to get to grips with
07:02:30 <aleator> Saizan: would you guess that to be faster than amap?
07:02:56 <aleator> (I think just using c would be easiest :)
07:04:08 <quicksilver> xplat: but but but but, ListLike is an abomination.
07:04:17 <quicksilver> xplat: the true list-like classes are Foldable and Traversable.
07:05:26 <unkanon_> @let bucketize items buckets = let floorQty = div items buckets ; preSize = mod items buckets ; preTimes = (buckets `div` preSize) in concat $ replicate preSize ((replicate (preTimes-1) floorQty) ++ [floorQty+1])
07:05:28 <lambdabot>  Defined.
07:05:32 <unkanon_> > bucketize 110 20
07:05:33 <lambdabot>   [5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6]
07:05:44 <unkanon_> too late, I know.
07:06:40 <Jafet> > bucketsize 20 11
07:06:41 <lambdabot>   Not in scope: `bucketsize'
07:06:45 <Jafet> > bucketize 20 11
07:06:46 <lambdabot>   [2,2,2,2,2,2,2,2,2]
07:07:00 <Jafet> @undef
07:07:08 <Jafet> Once more, with feeling.
07:08:41 <unkanon_> hmm
07:09:43 <unkanon_> wow it's severely flawed :)
07:15:00 <por> Does anyone know where a list of the primitive type sizes in GHC can be found? I can't find such a list in the documentation.
07:15:00 <lambdabot> por: You have 1 new message. '/msg lambdabot @messages' to read it.
07:16:05 <quicksilver> por: they are architecture dependent.
07:16:06 <Zvpun> "f x = 10 - x", earlier today someone used to bot to show f in another example. Is there something like "@pl f lst elm = lst ++ [elm]" in ghci?
07:16:15 <quicksilver> por: Int may be 32 bits or 64 bits, for example.
07:16:16 <benmachine> well, Char is always the same size
07:16:33 <quicksilver> por: the numeric types all have minBound and maxBound
07:16:41 <benmachine> Zvpun: no, but there is a 'pointfree' package on Hackage
07:16:43 <quicksilver> so you can tell how much room you have on a given setup.
07:16:52 <quicksilver> > maxBound :: Int
07:16:53 <lambdabot>   9223372036854775807
07:16:57 <Saizan> why would mmapping a ~70mb file require more than 1G of heap?
07:17:01 <benmachine> Zvpun: which gets you an executable that can do the same thing
07:17:19 <benmachine> $ pointfree 'f x = 10 - x'
07:17:19 <benmachine> f = (-) 10
07:17:26 <dschoepe> > Foreign.Storable.sizeOf (undefined :: Int)
07:17:27 <lambdabot>   Not in scope: `Foreign.Storable.sizeOf'
07:17:29 <por> Well, Integer is architecture dependent; I was thinking of the space requirements of types like Char, Bool, and so on. 
07:17:37 <quicksilver> por: "space" requirements?
07:17:55 <Zvpun> benmachine: alright, so I will have to figure out howto get pointfree running on my debian. Thank you, i am off reading.
07:17:56 <benmachine> > fromEnum (maxBound :: Char)
07:17:56 <lambdabot>   1114111
07:17:57 <quicksilver> por: things like Char and bool are 1 word for the value and 1 word for the indirection, in GHC, as far as I know.
07:18:07 <quicksilver> por: but this is very much up to the guts of the implementation.
07:18:13 <por> (size in bytes)
07:18:30 <benmachine> when things get inlined or folded or fused or whatever, it can get a bit tricky
07:18:53 <benmachine> you might be interested in Foreign.Storable
07:19:06 <por> Ah, okay. And the same is true of value constructors like True and False, then?
07:19:21 <benmachine> I'm not sure
07:19:23 <quicksilver> por: well, True is a value of type Bool.
07:19:38 <benmachine> I have this vague recollection that nullary constructors can sometimes be done as tag bits
07:19:54 <por> Ah, sorry - I didn't see the bool followig the "char" in your response.
07:20:00 <benmachine> question is why do you want to know :)
07:20:10 <benmachine> I mean
07:20:14 <benmachine> I usually don't like that question
07:20:26 <benmachine> but it's easier to give a good answer if you can tell us
07:21:28 <por> I absolutely hate the question. In fact, I have a rather trivial homework assignment "For your favorite language ... ". Well, hours of GHC documentation reading later, here I am. For some reason I could find a list of the sizes for all other langauges but Haskell :)
07:21:51 <quicksilver> por: for example, the bool in this statement " let x = True in 5 "
07:21:54 * hackagebot safeint 0.5 - overflow-checked Int type  http://hackage.haskell.org/package/safeint-0.5 (AndresLoeh)
07:21:58 <quicksilver> por: ...consumes zero bytes.
07:22:13 <quicksilver> lazyiness makes space consumption complication.
07:22:15 <quicksilver> so does fusion.
07:22:20 <quicksilver> and optimisations in general.
07:22:40 <por> Well, the bool is eliminated during optimization, correct?
07:22:50 <quicksilver> in a sense, yes, but that's not actually the point.
07:23:12 <quicksilver> consider further [True,False,True]
07:23:25 <quicksilver> the two 'Trues' there will, in GHC, be stored in the same place
07:23:32 <tibbe> por, what's the question?
07:23:38 <quicksilver> there is no need for GHC to allocate two True's
07:23:45 <quicksilver> because one True is identical to another.
07:23:49 <por> Ah, okay. It's like variable reference in a WAM .
07:24:01 <quicksilver> and, consider even further, let l = [3,4,5,6] in head l
07:24:18 <quicksilver> the "4,5,6" take up no space not because the optimiser removes them (although it might)
07:24:35 <quicksilver> but because even if the optimiser does not remove them, the lazy evaluation will never bother to allocate them.
07:25:43 <por> Well, that makes sense. That's how we think about function calls in Haskell intuitively also.
07:26:06 <quicksilver> so you understand why it was hard to answer your initial question? :)
07:26:14 <tibbe> por: I have some slides about memory layout in one of my talks
07:26:36 <tibbe> with diagrams :)
07:26:37 <quicksilver> some space can be shared, some can never be allocated, and some can be unboxed.
07:28:02 <por> Yes, understood. It would be interesting to read more about implementing lazy functional languages like Haskell. I can think of Jones' book, but (the beginning chapters) have more to do with reducing them to lc.
07:29:16 <quicksilver> SPJ's book remains the most complete reference I"m aware of
07:29:25 <quicksilver> althouhg it's quite out-of-date w.r.t. what GHC actually does
07:29:42 <quicksilver> more up-to-date GHC implementation notes are generally in papers published by SPJ and/or the wiki
07:29:46 <tibbe> quicksilver, the making fast curry paper adds some on top of that right?
07:29:58 <quicksilver> many of the papers add something :)
07:30:02 <tibbe> right
07:30:03 <quicksilver> I've not read all of them, either.
07:30:41 <por> Those sound like good references. I'd like to get a handle on SPJ's book first, though.
07:33:56 <thoughtpolice> SPJ's book is quite wonderful. all the papers after the fact are good for the more 'up to date' info on GHC, e.g. inliner papers, fast curry eval/apply, constructor specialisation, etc
07:34:28 <kmc> there's a nice article on the ghc trac too
07:34:37 <tibbe> there's also a paper about pointer tagging
07:34:40 <benmachine> por: also, the vector package can store an array of Bools at a cost of one bit each
07:34:41 <tibbe> or is that the curry one?
07:34:44 <benmachine> just to confuse things further :P
07:34:51 <thoughtpolice> tibbe: pointer tagging one is different
07:35:02 <kmc> tibbe, the eval/apply paper doesn't get into tagging pointers by ctor, i don't think
07:35:38 <Kaidelong> (Vector v Bus, Vector v (Int, Int), Vector v (Accessor (Buses v) Bus), Vector v Int) => Int -> (Int, Int) -> v Int -> BusBand v (Buses v)
07:36:08 <Zvpun> benmachine: I managed to install pointfree using cabal, now there is a tar.gz somewhere in ~/.cabal/..., would you mind telling me howto compile that?
07:36:16 <Kaidelong> I'm really uncomfortable looking at that, really
07:36:31 <benmachine> Zvpun: is there a binary at ~/.cabal/bin/pointfree
07:37:06 <Zvpun> benmachine: no, there is no ~/.cabal/bin (I used cabal update; cabal install pointfree; so far)
07:37:34 <benmachine> Zvpun: huh, weird, is there a /usr/local/bin/pointfree
07:38:25 <por> Really, I'll have to read more before you could confuse me with that. Sometimes you just don't know enough to /be/ confused.
07:38:58 <benmachine> heh ok
07:39:16 <Zvpun> benmachine: no, as far as I understand the docs cabal installs locally by default, and I dont have root priviliges. But dont worry/waste my time on me. I was hoping it had an easy/obvious fix.
07:39:47 <benmachine> Zvpun: it does install locally by default, but it should have given you ~/.cabal/bin therefore
07:39:58 <benmachine> Zvpun: are you sure the install was successful?
07:41:00 <Zvpun> benmachine: indeed, Plugin/Pl/Transform.hs:77:9: Not in scope: data constructor `State'
07:41:22 <Zvpun> benmachine: futhermore it says i use an old base version 3.x
07:41:28 <benmachine> aha
07:41:35 <benmachine> sounds like the package is broken
07:41:41 <benmachine> in which case it should be fixed!
07:41:44 * benmachine investigates
07:43:17 <benmachine> hmm it doesn't list a maintainer
07:43:23 <benmachine> maybe I should just take it
07:46:29 <Zvpun> The "problem" i try to understand is from "f x y z" I can create new function (f x y), yet how can i make a function g x = f x 1 1 or g y = f 1 y 1?
07:47:39 <benmachine> Zvpun: you can use 'flip' but usually just making a lambda is simpler
07:47:39 <kmc> because (f x y z) might itself return a function
07:47:52 <kmc> oh i see the question
07:48:10 <sipa> Zvpun: let g = (\x -> f x 1 1)
07:48:19 <sipa> or let g x = f x 1 1
07:48:28 <kmc> yeah, in Haskell it is important to anticipate how users will want to partially apply your function, and order arguments accordingly
07:48:41 <applicative> Zvpun, have you found the pointfree executable? Is ~/.cabal/bin in path?  
07:48:57 <Zvpun> applicative: no, as benmachine found out, it did not compile because of some error.
07:48:58 <kmc> not that the lambda syntax is terrible, but it's more syntax than no syntax at all
07:49:20 <unkanon_> kmc: well yes, but every misstep can be fixed with a lambda or some flips
07:49:44 <kmc> yeah
07:49:52 <applicative> hmm, I installed it a couple of weeks ago. If you figure it out add  this to your .ghci 
07:49:54 <applicative> :def pf \str -> return $ ":! pointfree \"" ++ str ++ "\""
07:50:33 <Zvpun> applicative: I found this in the README already. But I dont worry so much about pointfree, since I am very new to haskell and got lots of problems to solve and I can just /msg the bot
07:50:59 <Zvpun> Thank you guys again very much. sipa gave me the answers I was looking for.
07:51:00 <applicative> Zvpun, right
07:51:06 <unkanon_> Zvpun: just hope lambdabot's online when you need it :)
07:51:45 <applicative> Zvpun, what version of ghc are you using?
07:52:06 <Zvpun> applicative: 6.12.1
07:52:14 <applicative> oh good. 
07:53:04 <benmachine> Zvpun: if you're feeling adventurous, try cabal install pointfree --constraint='mtl < 2'
07:53:11 <benmachine> no guarantees but it might work
07:53:13 <Zvpun> I was using hugs but a friend told me that ghc is prefered (just at lunch today). I was learning alot from Prelude.hs with hugs but haven't fund them in ghc so I am kinda disappointed by ghc
07:53:31 <applicative> benmachine, I see the build depends for pointfree include ... hah I see you see ... parsec and mtl, unmarked for version
07:53:39 <Zvpun> benmachine: no thank you Sir. I value understanding some haskell concepts much more then solving a computer problem.
07:53:54 <quicksilver> Zvpun: do you mean that hugs comes with the source to the prelude but ghc does not come with the source?
07:54:18 <applicative> Zvpun, but we are here partly to resolve this sort of problem, so you can get on with learning. 
07:54:20 <kmc> Zvpun, for docs with ghc see http://www.haskell.org/ghc/docs/latest/html/libraries/ and http://hackage.haskell.org/packages/archive/pkg-list.html
07:54:24 <Zvpun> quicksilver: I was not able to find source in hugs yet and I assume its all compiled
07:54:34 <kmc> Zvpun, they should have source links
07:54:35 <benmachine> does anyone know who Thomas Jäger is and if he's been around recently
07:54:45 <quicksilver> Zvpun: OK, so I'm not sure what you meant.
07:54:46 <kmc> btw you can still read Hugs's Prelude.hs
07:54:50 <sipa> Zvpun: i don't quite understand what your problem is
07:54:51 <kmc> and probably use the same functions in ghci
07:54:58 <kmc> Zvpun, there's also
07:55:00 <kmc> http://ww2.cs.mu.oz.au/172/exercises/tourofprelude.html
07:55:05 <quicksilver> Zvpun: "I was learning alot from Prelude.hs with hugs but haven't fund them in ghc"
07:55:21 <benmachine> the pointfree package doesn't have a maintainer field *or* an email for the author
07:55:38 <Zvpun> quicksilver: I had a Prelude.hs on disk which I could access while offline and while using hugs, but could not find source files in /usr/lib/hugs
07:55:51 <Zvpun> *erm I mean /usr/lib/ghc
07:55:52 <sipa> Zvpun: then just keep using hugs' one
07:56:33 <applicative> benmachine, I see, Herr Jaeger last appears Haskell-land in 2005, it seems.
07:56:35 <Zvpun> In any case I am very thankful for the help I have already recieved.
07:56:45 <quicksilver> Zvpun: you're right, that GHC doesn't come with source if you only download a binary. You can of course download the source.
07:56:49 <benmachine> applicative: yeah, that's all I found on google
07:57:08 <quicksilver> Zvpun: GHC sources have a habit of using implementation dependent tricks, though (as is their prerogative)
07:57:22 <quicksilver> Zvpun: you can use :browse Prelude to just get a list of functions and types
07:58:33 <benmachine> :t outR
07:58:33 <lambdabot> forall a. Rec a -> Rec a -> a
08:00:44 <ski> benmachine : Thomas Jäger was known as `TheHunter' here -- but hasn't shown up in a long time
08:01:01 <benmachine> ski: right.
08:01:08 <ski> preflex: seen TheHunter
08:01:08 <preflex>  TheHunter was last seen on #haskell 197 days, 9 hours, 50 minutes and 16 seconds ago, saying: @join #functionaljava
08:01:22 <ski> (that is very probably not the real one)
08:01:23 <benmachine> I guess maintainership of pointfree should probably fall to lambdabot maintainers
08:02:36 <applicative> oh my god, don't tell me he's given up haskell for functional java...
08:03:02 <ski> @source Prelude
08:03:02 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
08:03:05 <applicative>   new channel #pointfreejava
08:03:05 <ski> Zvpun : ^
08:03:38 <ski> applicative : that's quite probably someone stealing lambdabot op powers, a short while
08:04:26 <Zvpun> thank you again
08:08:18 * ski idly wonders where the `42.4413     -84.2901' coordinates pointed to by `TheHunter' at <http://www.haskell.org/haskellwiki/HaskellUserLocations> resolves to
08:09:54 <quicksilver> ski: http://maps.google.co.uk/maps?f=q&source=s_q&hl=en&geocode=&q=42.4413+++++-84.2901&sll=53.800651,-4.064941&sspn=16.868876,43.813477&ie=UTF8&ll=42.440007,-84.290457&spn=0.010261,0.021393&z=16&iwloc=near
08:11:04 <ski> oh
08:13:06 <fryguybob> http://tunes.org/~nef/logs/haskell/10.05.24 -- it was copumpkin
08:13:13 <copumpkin> ?
08:13:44 <fryguybob> preflex: seen TheHunter
08:13:45 <preflex>  TheHunter was last seen on #haskell 197 days, 10 hours, 2 minutes and 52 seconds ago, saying: @join #functionaljava
08:14:15 <copumpkin> oh lol
08:14:30 <fryguybob> :D
08:15:06 <ski> (fryguybob : .. as i said "very probably not the real one" :)
08:29:52 <younder> The SML group seems a bit slow. I seek the Intellectual prowess of a Haskeller.
08:29:58 <younder> You..
08:36:07 <younder> Data-flow is the panacea of efficient functional programming. Isn't it?
08:37:06 <younder> I've studied this for some time.
08:37:25 <younder> And It always comes back to this
08:37:44 <younder> Cudos for MLTon
08:37:54 <sipa> QDos?
08:39:19 <younder> MLTon did a excellent job of creating a SUPPRESSOR functional compiler.
08:39:36 <younder> SUPERIOR
08:39:53 <ezyang> Mysteriously a build is stuck on 'ghc -o setup -package Cabal Setup*hs'. Curious. 
08:40:04 <younder> Damn automatic spell checks... ;)
08:40:11 <ezyang> I wonder why. 
08:40:19 <dcoutts_> ezyang: linking?
08:40:29 <benmachine> ezyang: using undecidable instances in your Setup.hs? >_>
08:40:35 <ezyang> It shouldn't take fifteen minutes, in my experience... 
08:40:45 <ezyang> This is HalVM 
08:40:57 <younder> well I didn't fuck up your system
08:40:57 <ezyang> I spun up a fresh Fedora 14 box just to see if I could get it to compile! 
08:41:03 <ezyang> So far no luck. 
08:42:13 <kmc> KOMPRESSOR
08:42:29 <kmc> ld can take 15 minutes
08:42:35 <kmc> ps axf
08:42:48 <ezyang> ok 
08:44:23 <kmc> ld burned my crotch
08:45:55 * benmachine always finds ps obscure
08:46:01 <benmachine> it has like three different kinds of options
08:46:49 <kmc> that's because it comes from a land before time
08:46:57 <ezyang> Yep, looks like it's ld 
08:47:00 <kmc> :D
08:47:04 <kmc> switch to gold?
08:47:09 <ezyang> sodding ld 
08:47:30 <kmc> are you using -ffunction-sections?
08:47:37 <kmc> i hear that makes ld unhappy
08:47:38 <ezyang> ooh, it looks like Fedora 13 grew support for gold 
08:47:51 <ezyang> kmc: I'm not sure, I'm trying to compile someone elses code. 
08:50:07 <ezyang> Trying gold. 
08:50:19 <ezyang> WHOO. Finished in less than a second. 
08:50:21 <ezyang> danke 
08:51:27 <kmc> hahaha
08:51:32 <kmc> it's really that much better?
08:53:04 <ezyang> Like night and day. 
08:53:47 <haskeller> younder, again, what do you seek? I might have it
08:53:57 <roconnor> @tell koninkje_away I seems more accurate to say that plates from a monoid since *any* two plates over any two functors F and G can be composed to produce a plate over (F o G).
08:53:58 <lambdabot> Consider it noted.
09:09:43 <Mitar> how can i cite an article in monad.reader?
09:09:59 <ezyang> What citation style? 
09:10:10 <Mitar> bibtex entry ;-)
09:10:30 <ski> roconnor : can i have a free monoid on a plate ?
09:10:59 <roconnor> ski: No, but you can have a constant applicative functor for a monoid on a plate.
09:11:31 <roconnor> oh, and you can also have a free monoid monad on a plate.
09:12:30 * ski wonders how these plates look like
09:12:59 <roconnor> ski: have you seen multiplate?
09:15:00 <ski> no, what's that ?
09:15:09 <roconnor> http://hackage.haskell.org/packages/archive/multiplate/0.0.1.1/doc/html/Data-Generics-Multiplate.html#t:Multiplate
09:15:11 <ski> a package ?
09:15:16 <ski> *nods*
09:15:24 <roconnor> a plate is an instance of Multiplate satifying the two multiplate laws
09:17:25 <aristid> roconnor: you totally need to make a multiplate tutorial for dummies, so i can understand it too
09:17:43 <roconnor> http://haskell.org/haskellwiki/Multiplate
09:17:58 <roconnor> aristid: have you tried reading the above?
09:18:07 <aristid> roconnor: yes, to no avail
09:18:10 <roconnor> ah
09:18:21 <roconnor> aristid: I what was the sticking point?
09:19:09 <aristid> roconnor: well, i guess i don't even know which problem it tries to solve, so i have no idea at all into what "frame" to put my mind before reading it
09:19:24 <roconnor> hmm
09:20:01 <roconnor> aristid: try reading http://www-ps.informatik.uni-kiel.de/~sebf/projects/traversal.html first and let me know if this helps
09:20:03 <roconnor> it isn't very long
09:20:06 <aristid> you should maybe start by explaining a problem, showing a solution without multiplate, and the introducing multiplate step by step
09:20:22 <roconnor> aristid: that's a good idea!
09:24:12 <Saizan> you just have to write getVariables directly :)
09:25:05 <tg_> aristid: and he suggests you embark on this immediately!
09:25:07 <sm> morning
09:25:52 <aristid> tg_: me? i have an excuse: i don't understand it, so i can't explain it. i mean, would you write a monad tutorial without understanding them? ;)
09:26:03 <tg_> aristid: hasn't stopped some others :O
09:26:08 <tg_> but no, I wouldn't :)
09:26:16 <sm> I couldn't find the reverse-dependencies-supporting hackage server I remembered, but http://bifunctor.homelinux.net/~roel/cgi-bin/hackage-scripts/revdeps works great. Except..
09:26:37 <sm> why does http://bifunctor.homelinux.net/~roel/cgi-bin/hackage-scripts/revdeps/process-1.0.1.4 say pango directly depends on process-1.0.1.4 ? pango doesn't seem to specify a version
09:28:10 <Saizan> sm: so it directly depends on any version?
09:28:33 <sm> Saizan: yes, see http://bifunctor.homelinux.net/~roel/cgi-bin/hackage-scripts/package/pango-0.12.0
09:29:48 <sm> I'm trying to trace my indirect dependency on process-1.0.1.4, which I've forgotten
09:30:01 <Saizan> sm: yeah, so i'd conclude that any version of process is a possible direct dependency of pango
09:30:33 <Saizan> but i can see that doesn't help with your use case
09:31:04 <sm> hmm ok, so it doesn't actuallly track version-specific reverse deps, a bit misleading
09:32:13 <younder> Two holes in my education 'Game theory'' (fixed) and Organic Chemistry (still fucked)
09:32:20 <Saizan> tried cabal install --dry-run -v to see why it picks process-1.0.1.4 ?
09:32:34 <sm> good idea
09:32:52 <Saizan> it might even simply do so because it's the latest
09:37:54 <sm>  cabal install --dry-run --constraint process==1.0.1.3  seems more informative
09:38:24 <sm> I'd better relax my own process dependency first
09:39:48 <sm> off topic: I find myself using for p in `ghc-pkg check 2>&1  | grep problems | awk '{print $6}' | sed -e 's/:$//'`; do echo unregistering $p; ghc-pkg unregister $p; done  quite a lot to clear out obsolete packages as they get broken.. quite useful
09:42:11 <sm> grr
09:42:24 <sm> I'll come back to this, thanks Saizan 
09:42:40 <Zvpun> why is "(. (:[])" not "((.) (:[]))" I thought that in order to convert an operator symbol "." to prefix notation one needs surrounding ()
09:43:19 <ziman> (`op` x) = flip op x
09:43:53 <ziman> because using that section, you partially apply the second argument of the op
09:44:37 <ziman> whereas (.) (:[]) applies passes (:[]) as the first argument to (.)
09:45:17 <Zvpun> well the question I am asking is why is (. (:[])) not invalid.
09:45:30 <ziman> because you want that often
09:45:46 <ziman> > filter (`elem` "abc") "blabrgc"
09:45:47 <lambdabot>   "babc"
09:45:49 <Zvpun> I tried (++ [...] [...]) that didn't work, but . is special?
09:46:07 <ziman> ((++) [...] [...]) would work
09:46:37 <Zvpun> Yes but why does . not need surrounding ()?
09:46:45 <ziman> such notation is called section
09:46:59 <ziman> which is partial application of a binary operator
09:47:15 <ziman> to exactly one argument
09:47:17 <fryguybob> > (++ ['d'..'f']) ['a'..'c']
09:47:18 <lambdabot>   "abcdef"
09:47:24 <Zvpun> ah, ty
09:47:32 * Zvpun off reading
09:47:46 <ziman> if you want to give the operator more arguments, you need to parenthesize it and use it as a regular (prefix) function
09:50:39 <jmcarthur> alright guys, we need more stuff here http://www.haskellers.com/jobs/
09:52:44 <aristid> jmcarthur: heh.
10:02:35 <ski> preflex: xseen koninkje_away
10:02:35 <preflex>  koninkje_away was last seen on freenode/#haskell-in-depth 4 days, 10 hours, 59 minutes and 10 seconds ago, saying: @tell roconnor assuming composePlate is associative and complete (i.e., closed, not total) and assuming purePlate is the identity for composePlate, then it is a category regardless; with multiplate an endofunctor
10:03:58 <sm> "I am not very technologically savvy" --SPJ  on ghc-users
10:04:08 <sm> love it :)
10:04:10 <ezyang> Classic :-) 
10:05:26 <Zvpun> damit, in order to understand the difference between (. f) ((.) f) I tried (- 10) 1 and ((-) 10) 1 unfortunately - is special and I should have tried (++ [1]) [2] and ((++) [1]) [2]. After reading haskell98-report 3.5 section I think I have some basic clue whats going on now.
10:06:58 <ziman> yes, (-) is special, bad luck. :)
10:07:42 <ski> hmm .. it might be nice if `f <pat-expr> (\<pat-expr> -> <expr>)' (or something similar) could have a shorthand syntax ..
10:08:02 <ski> examples of `f' being : `(,)' and `(=>>)'
10:08:23 <roconnor> > (^5) 2
10:08:24 <lambdabot>   32
10:08:29 <roconnor> > (5^) 2
10:08:30 <lambdabot>   25
10:08:36 <roconnor> > (^) 5 2
10:08:37 <lambdabot>   25
10:08:46 <roconnor> >  5^2
10:08:47 <lambdabot>   25
10:08:55 <roconnor> > (^) 2 5
10:08:56 <lambdabot>   32
10:09:00 <roconnor> >  2^5
10:09:01 <lambdabot>   32
10:09:08 <roconnor> Zvpun: ^^
10:09:25 <ski> e.g. `([e,e0], \ [e,e0] -> e :@: e0)', in the uniplate discussion at <http://www-ps.informatik.uni-kiel.de/~sebf/projects/traversal.html>
10:10:19 <ski> roconnor : ty for showing uniplate and multiplate .. this appears to be heavily cool stuff :)
10:10:26 <roconnor> ski: there is 
10:10:43 <roconnor> if you use a suitable applicative functor
10:10:58 <ski> in comonads, it's quite common to say `x =>> \x -> ..x..', i think
10:10:58 <roconnor> ski: there is loads more cool stuff I have to say on the topic of uniplate and multiplate.
10:11:50 <magicman> Not for pat-expr, there isn't.
10:12:20 <magicman> In one case it's a value, in the other it's a pattern :-/
10:12:49 <roconnor> ski: indeed, ([x],[x]->y) is a comonad.  twanvl calls it the FunList Comonad.  I'm currentlly calling it the cartesian store comonad in my paper I'm writing
10:13:00 <ski> magicman : yeah, that's the problem
10:13:02 <Boxo> (+) and (*) are commutative. (^) is not. What's up with that?
10:13:07 <ski> in the state-in-context comonad (`data StateInCxt s a = Stage s (s -> a)')
10:13:17 <roconnor> Boxo: I've often wondered about that
10:13:56 <roconnor> ski: yea, but in uniplate there is a restriction not captured by the type that the length of the input list is the same as the length of the list in the first component.
10:14:15 <ski> that expands to `let Stage s sa = x in Stage s (\s -> let x = Stage s sa in ..x..)', if i'm not mistaken .. hm
10:15:24 <roconnor> ski: I could send you a pre-preprint of my paper if you want to read about this.  The paper is still quite disorganized, but I think it has all the content that I want to write.
10:15:43 <ski> roconnor : yeah .. i pondered `newtype Foo a b = MkFoo (a -> exists f. Functor f *> (f b,f b -> a))', possibly replacing `Functor' with `Applicative'
10:16:01 <ski> (in response to some discussion of `([x],[x]->y)' i saw here, i mean)
10:16:30 <ski> roconnor : sure
10:16:41 <roconnor> ski: twanvl's type is isomorphic to exists n:Nat. (b^n, b^n -> a)
10:17:05 <roconnor> If you want to generalize this to noetherian containters, then you want to replace Nat with Shape I think.
10:17:10 <ski> @where FunList
10:17:10 <lambdabot> I know nothing about funlist.
10:17:11 <roconnor> I haven't really thought about this though.
10:17:41 <ski> "noetherian containers" being those with logarithms ?
10:17:49 <roconnor> http://twan.home.fmf.nl/blog/haskell/non-regular2.details and http://twan.home.fmf.nl/blog/haskell/non-regular1.details
10:18:05 <roconnor> ski: ya, maybe you can drop the noetherian restruction
10:18:16 <roconnor> but the shape seems to have something to do with logarithms
10:19:19 <Boxo> Well, http://www.reddit.com/r/math/comments/eievj/addition_and_multiplication_are_commutative/
10:20:19 <ski> @where+ FunList twanvl's "A non-regular data type challenge" at <http://twan.home.fmf.nl/blog/haskell/non-regular1.details> and "http://twan.home.fmf.nl/blog/haskell/non-regular2.details" at <http://twan.home.fmf.nl/blog/haskell/non-regular2.details>
10:20:19 <lambdabot> Good to know.
10:20:47 <roconnor> ski: pm me an address and I will send you an pre-preprint.
10:21:42 <ski> (roconnor : and iiuc, having logarithms here means that paths are "global", as opposed to local to specific values : so in lists, the third element might not exist, so it's not logarithmic)
10:21:58 <roconnor> ah
10:25:12 <ski> (hm, so that state-in-context comonad example is basically `let (s,sa) = x in (s,\s -> let x = (s,sa) in ..x..)', so the `x =>> \x -> ..x..' in the source has been translated into a `(s,\s -> ..s..)' in the target .. hm)
10:26:28 <dpratt71> earlier I had asked for some advice in creating a function that would distribute x tasks across y buckets...
10:26:55 <joeyh> having a utf8 problem with Text.Regexp: matchRegex (mkRegex "^.*$") "\232" = Nothing and I'd expect a match
10:26:56 <dpratt71> ...thanks to jon_of_arc and Endiannes, I have created such a function
10:27:13 <ski> hm, let's say we abbreviate `f <pat-expr> \ <pat-expr> -> <expr>' as `f @\ <pat-expr> -> <expr>', for the sake of argument
10:27:25 <dpratt71> now I'd like to verify its correctness (not formally) and improve it
10:27:37 <dpratt71> this is what I came up with: http://hpaste.org/42161/bucketize
10:27:38 <joeyh> do I need to do something with locales to make . match è ?
10:27:53 <ski> so `([e,e0], \ [e,e0] -> e :@: e0)' then becomes `(,) @\ [e,e0] -> e0 :@: e0' .. which seems less burdensome
10:28:09 <ski> and `x =>> \x -> ..x..' .. hm
10:28:37 <ski> `(=>>) @\ x -> ..x..' is somewhat clunky, i suppose
10:28:53 <dpratt71> in particular, I think I can probably reformulate it to take advantage of some built-in functions
10:29:47 <ski> maybe one could allow here `x \@ =>> ..x..', or something
10:30:18 <roconnor> ski: you can use ap to write this function.  This is how it is done in compos and multiplate (and effectively how the deriving mechinism in uniplate works).
10:30:37 <ski> so `x \@ =>> ..x..' then basically expands to `let (s,sa) = x in (,) @\ s -> let x = (s,sa) in ..x..)'
10:30:58 <ski> or `let Stage s sa = x in Stage @\ s -> let x = Stage s sa in ..x..', in the `newtype'
10:31:03 <ski> roconnor : which function ?
10:31:15 <roconnor> anyhow, I will send you the paper
10:31:20 <roconnor> that is probably best
10:31:29 <roconnor> one sec
10:33:20 <Zvpun> I have "map (\ x -> ([x', x'], [x', x']) [0..80] where x' = x `mod` 19". Now this is not correct since it should read "x' x" instead of "x'" but that makes it less readable. Is there another way? So far I have found "map (\ x -> let x' = x `mod` 19 in ([x', x'], [x', x'])) [0..80]" but I would like to move the let part "out of the way" 
10:34:25 <ski> roconnor : if you're talking about my `<expr-0> @\ <pat-expr> -> <expr>' and `<pat-expr> \@ <operator> <expr>' above, then those can't be done with `ap', since they rely on treating a sub-term as both a pattern and an expression
10:34:50 <revenantphx> So, how should I treat tree-like polymorphism?
10:35:04 <roconnor> revenantphx: more details
10:35:06 <revenantphx> I've been playing with existentials after last night...
10:35:13 <roconnor> about what you mean
10:35:16 <revenantphx> Uh, I have a tree of entity types.
10:35:29 <ski> Zvpun : i'm not quite sure what you're after ..
10:35:34 <roconnor> Tree Entity
10:35:44 <revenantphx> No no, let me more thoroughly explain.
10:35:46 <revenantphx> One moment.
10:36:28 <Zvpun> ski: syntactic suger to make it as easy and obvious to read and move the details (like x `mod` 19) as much out of the way as possible.
10:36:32 <ski> dpratt71 : style : i'd use `where' instead of `let', and pattern-matching instead of `== 0'
10:37:34 <revenantphx> basically, I want to have a map of Entities. However, entities can be of multiple types (projectiles, players, npcs)
10:37:43 <TheHunter> yo
10:37:50 <revenantphx> However they also share a lot of traits such as position.
10:38:03 <revenantphx> The issue is that for something as large as a PlayerEntity, I'd want to use record syntax.
10:38:12 <roconnor> revenantphx: the simplest solution is to make a sum type for all the possiblities.
10:38:19 <revenantphx> sum type?
10:38:44 <roconnor> data Object = Player Player | Projectile Projectile | NPC NPC | ...
10:38:46 <revenantphx> You mean multiple data constructors?
10:38:51 <revenantphx> wait... what?
10:39:04 <benmachine> roconnor: there's nothing confusing about that naming scheme at all
10:39:17 <roconnor> damn Haskell's crazy data syntax
10:39:27 <roconnor> data Object = OPlayer Player | OProjectile Projectile | ONPC NPC | ...
10:39:28 <TheHunter> it is I, the real hunter
10:39:38 <revenantphx> roconnor: ...okay
10:39:40 <roconnor> @seen TheHunter
10:39:41 <lambdabot> Unknown command, try @list
10:39:41 <preflex>  TheHunter was last seen on #haskell 13 seconds ago, saying: it is I, the real hunter
10:39:50 <revenantphx> I see I guess.
10:40:34 <revenantphx> The thing is, then, I'm going to have to manually do all the accesors.
10:40:46 <roconnor> revenantphx: you can build more elaborate hierarchies if you like.
10:40:51 <revenantphx> I see...
10:41:13 <benmachine> TheHunter: the real one?
10:41:17 <benmachine> the really real one?
10:41:26 <Twey> Zvpun: map (\ (flip mod 19 -> x) -> ([x, x], [x, x])) [0 .. 80]; map ((id &&& id) . replicate 2 . flip mod 19) [0 .. 80]
10:41:33 <jmcarthur> TheHunter: !!
10:41:59 <TheHunter> I own this account, you can check /whois
10:42:13 * jmcarthur there's no telling how many times i've hijacked your nick to get lambdabot to join a channel :P
10:42:19 <benmachine> <_<
10:42:26 <jmcarthur> dang that was supposed to be a /msg TheHunter 
10:42:29 <jmcarthur> not a /me
10:42:33 <benmachine> giggle
10:42:35 <roconnor> *lol*
10:42:35 <benmachine> TheHunter: so you wrote the pointfree command line tool?
10:42:42 <TheHunter> haha, no
10:42:47 <TheHunter> I just hijacked this nick better
10:42:53 <benmachine> aha
10:42:56 <benmachine> ic
10:43:09 <jmcarthur> oh great
10:46:09 <revenantphx> So...
10:46:17 <revenantphx> there's no easy way to do thsi really..
10:46:21 <revenantphx> well, no clean way.
10:46:29 <jmcarthur> revenantphx: i think you're thinking too hard about it
10:46:35 <revenantphx> Probably.
10:46:39 <roconnor> revenantphx: in my limited experience a hierarchy tends to work out quite well.
10:46:51 <revenantphx> If you have alternatives, please suggest them.
10:47:04 <revenantphx> The issue I have is record names overlapping.
10:47:32 <Twey> More modules.
10:47:46 <revenantphx> But they will all be used in the same code...
10:47:51 <revenantphx> That just means more qualified imports.
10:47:57 <Twey> That's fine
10:48:16 <revenantphx> Is it possible to have an Entity.hs that automatically imports all of the separate files qualfiied?
10:48:16 <Twey> They won't clash that way, and you can name them however you want
10:48:24 <Twey> Sadly, no :-\
10:48:34 <revenantphx> So imports don't bleed like C...
10:48:35 * benmachine want first class modules
10:49:05 <revenantphx> Twey: so if I have 20 entity types I'm going to have a massive import list in the source >_<
10:49:15 <revenantphx> I'm trying to decide whether that or wrapper types are worse.
10:49:24 <dpratt71> ski: got distracted and didn't notice your comment right away
10:49:28 <revenantphx> And even if I do that, I still need a way to store them all in an Intmap
10:49:32 <revenantphx> or Map, either way.
10:49:38 <dpratt71> ski: how about this? http://hpaste.org/42162/bucketize2
10:50:03 <UPPIN_JONES> Hey guys.  I'm new to Haskell and trying to figure out a good IDE for learning to code in Haskell.  Most important to me:  I'd like to be able to single step through code easily.  In R, I can do so easily with the Emacs-Speaks-Statistics R-mode.  But haskell-mode for emacs seems to only send *an entire buffer*, not just a single line.  Not what I want. If I may ask, how do you go about stepping through your Haskell code line-by-line, as if in a debugger?
10:50:28 <revenantphx> UPPIN_JONES: What OS?
10:50:30 <mauke> UPPIN_JONES: I don't know if such a thing exists
10:50:36 <revenantphx> UPPIN_JONES: also, you can step through in ghci
10:50:44 <UPPIN_JONES> I'm using Mac and Linux
10:50:50 <jmcarthur> revenantphx: well you can, but it kind of sucks
10:50:51 <mauke> it's not exactly line by line, though
10:50:53 <jmcarthur> for stepping
10:50:53 <ski> dpratt71 : that's more readable imo, yes
10:50:55 <revenantphx> jmcarthur: agreed.
10:50:55 <UPPIN_JONES> you can step in ghci? 
10:51:05 <revenantphx> I use TextMate for writing personally
10:51:10 <jmcarthur> UPPIN_JONES: it not very educational, but you can
10:51:13 <jmcarthur> *it's
10:51:13 <revenantphx> but its not feature-full as an IDE really.
10:51:15 <kmc> UPPIN_JONES, ghci has a debugger built in, but not many people use it
10:51:21 <dpratt71> ski: ok, thanks
10:51:24 <revenantphx> It's just clean and has syntax highlighting.
10:51:29 <UPPIN_JONES> ok
10:51:29 <kmc> the tactics for debugging a pure functional program are different than debugging an imperative program
10:51:36 <UPPIN_JONES> kmc: really?
10:51:55 <kmc> UPPIN_JONES, because functional programs aren't about "do this, then do that", but rather are about equations that hold
10:52:02 <UPPIN_JONES> kmc:  I like being able to do bottom up 
10:52:11 <kmc> sure, you can test your equations bottom up
10:52:16 <kmc> starting with the innermost function
10:52:23 <jon_of_arc> dpratt71: the toRational on the 0 is unnecessary
10:52:43 <jmcarthur> it really would be nice to get hat back up to speed
10:52:46 <kmc> i think Haskell needs better debugging tools but i also think a traditional stepping debugger is the wrong fit
10:52:47 <UPPIN_JONES> kmc: great!  is there something that automates the copy and paste 
10:53:06 <kmc> perhaps we need a revival of http://ww2.cs.mu.oz.au/~bjpop/buddha/
10:53:15 <kmc> UPPIN_JONES, uhm, you wouldn't copy paste
10:53:18 <kmc> just load your file into ghci
10:53:22 <kmc> and test its various functions
10:53:28 <UPPIN_JONES> ah
10:53:40 <kmc> like maybe you've defined h x = f (g x)
10:53:44 <kmc> you could test f and g independently
10:53:52 <jon_of_arc> dpratt71: other than that, I feel like this is a candidate for unfoldr but my attempts to just whip something up aren't coming out meaningfully more compact than your recursive solution
10:53:55 <UPPIN_JONES> budda looks very interesting, does revival mean it's not currently working?
10:54:04 <kmc> if you're convinced they're both okay, yet h isn't okay, it indicates where your conceptual error lies
10:54:09 <kmc> UPPIN_JONES, i'm not sure if it works now
10:54:12 <kmc> you could try it :)
10:54:15 <kmc> it hasn't been updated in years
10:54:16 <UPPIN_JONES> :-)
10:54:19 <UPPIN_JONES> oy
10:54:21 <kmc> and GHC has evolved a lot since then
10:54:27 <kmc> but i'm not sure how tightly hooked into ghc it is
10:54:53 <revenantphx> jmcarthur: this was what I had from last night.
10:54:54 <revenantphx> https://gist.github.com/733713
10:54:55 <UPPIN_JONES> kmc, but you say that ghci has a debugger, and presumably then the ability to single-step?
10:55:09 <revenantphx> It seems using a wrapper/sum type is unavoidable unless I use a lot of modules.
10:55:11 <UPPIN_JONES> I'll certainly give buddha a try!
10:55:12 <dpratt71> jon_of_arc: thanks again for the input
10:55:31 <sm> UPPIN_JONES: yes it does, see the ghci manual
10:55:35 <UPPIN_JONES> okay
10:55:36 <UPPIN_JONES> will do
10:55:40 <dpratt71> now I just need to figure out how to get my QuickCheck on
10:55:56 <UPPIN_JONES> all: thanks guys!
10:56:30 <jmcarthur> revenantphx: does the simulation care about types at all, or just distinct behaviors?
10:56:38 <revenantphx> It's not a simulation.
10:56:44 <jmcarthur> whatever
10:56:45 <revenantphx> This is for use in a persistent server.
10:57:03 <jmcarthur> let me just ask a different question
10:57:12 <revenantphx> Mainly they just have distinct variables, but they need to all be kept in one map.
10:57:19 <revenantphx> (unified list of ID's)
10:57:27 <jmcarthur> can you give me some examples of how entities will be used?
10:57:44 <jmcarthur> sounds to me like they don't need separate types at all
10:57:49 <jmcarthur> so far
10:57:53 <revenantphx> okay...
10:58:01 * hackagebot packdeps 0.0.0 - Check your cabal packages for lagging dependencies.  http://hackage.haskell.org/package/packdeps-0.0.0 (MichaelSnoyman)
10:58:14 <revenantphx> an Entity could be a player, keeping track of its position and inventory
10:58:39 <revenantphx> and other state
10:58:42 <sm> yay packdeps
10:58:52 <revenantphx> such as whether it's crouching or not... etc
10:59:03 <jmcarthur> revenantphx: have you seen this? http://cowboyprogramming.com/2007/01/05/evolve-your-heirachy/
10:59:08 <revenantphx> Or it could be a snowball, with a position and velocity only. (Or an arrow, which is identical except it has different trajectory)
10:59:32 <revenantphx> I'll take a read.
11:00:17 <jmcarthur> revenantphx: and if you like that then this is a good read as well: http://t-machine.org/index.php/2007/09/03/entity-systems-are-the-future-of-mmog-development-part-1/
11:00:27 <revenantphx> Oh dear.
11:00:32 <revenantphx> Rabbithole syndrome.
11:00:37 <revenantphx> Anyways, do you have a general idea?
11:00:42 <jmcarthur> revenantphx: i think after reading you will see what i'm suggesting
11:01:07 <jmcarthur> revenantphx: i get the idea. it's exactly what those articles talk about :)
11:01:23 <revenantphx> Could you give me the gist of what you're suggesting while I read?
11:01:43 <jmcarthur> revenantphx: the cowboyprogramming article says it better than i think i can on irc
11:01:58 <jmcarthur> revenantphx: the other link i gave goes into some detail on starting to implement something like it
11:02:02 <revenantphx> the component aggregation thing is interesting.
11:02:05 <jmcarthur> revenantphx: in an imperative language
11:02:11 <jmcarthur> java, iirc
11:02:16 <revenantphx> In haskell I'd accomplish it with type classes.
11:02:19 <revenantphx> I guess.
11:02:21 <jmcarthur> well no
11:02:33 <revenantphx> However I still need a way to get all types of entities into one map.
11:02:37 <jmcarthur> revenantphx: the point is that an entity is nothing but an id
11:02:45 <revenantphx> hrm?
11:02:50 <jmcarthur> revenantphx: and the aggregations are mappings from ids to data
11:03:07 <jmcarthur> revenantphx: and then the various systems in the program simply operate on the aggregations
11:03:20 <jmcarthur> revenantphx: the entities themselves don't intrinsically have any particular kind of data
11:03:31 <revenantphx> so... all entities could share a PositionComponent
11:03:38 <jmcarthur> no
11:03:46 <jmcarthur> entities don't *have* anything
11:03:46 * revenantphx is obviously missing the point.
11:03:50 <revenantphx> Er, yeah
11:04:08 <revenantphx> Could you give me a *really* basic haskell example? I work better with example code...
11:04:10 <jmcarthur> okay, just talking about positions...
11:04:10 <luqui> but there is about one PositionComponent per ID
11:04:17 <jmcarthur> luqui: at most
11:04:27 <jmcarthur> there could be none
11:04:49 <luqui> yeah but i meant, no multiple IDs don't share a single component
11:04:55 <luqui> emphasizing the "lower bound"
11:05:03 * hackagebot parallel-io 0.3.0 - Combinators for executing IO actions in parallel on a thread pool.  http://hackage.haskell.org/package/parallel-io-0.3.0 (MaxBolingbroke)
11:05:11 <sproingie> one hopes there are working examples other than Dungeon Siege
11:05:12 <jmcarthur> revenantphx: you have a mapping from entity ids to positions. the entities themselves are unaware of this mapping, as they are just IDs
11:05:19 <revenantphx> Right.
11:05:20 <sproingie> not exactly a game that people hold up as an example
11:05:23 <revenantphx> So I have a map table for each component?
11:05:25 <c_wraith> wait, that package was just featured on reddit yesterday.  updated already?
11:05:33 <revenantphx> That's a really interesting idea actually...
11:05:47 <luqui> Unity3D's object model is entirely component-based
11:06:20 <jmcarthur> revenantphx: if you read the second link i gave you (it's actually a series, so might take a while to read) he describes it as a kind of database
11:06:48 <jmcarthur> revenantphx: i'm not saying it's the *best* approach, but it gives you a lot of flexibility and sidesteps this whole typing issue you are asking about
11:07:19 <revenantphx> Yeah I could see that.
11:07:54 <revenantphx> game servers are very interesting and full of lots of little subprojects ~
11:07:55 <jmcarthur> revenantphx: it also means your idea to run all the game entities concurrently might not fit well though. it's not how this is meant to be used
11:08:09 <revenantphx> Oh, yeah, that wasn't going to happen.
11:08:16 <jmcarthur> ah okay
11:08:18 <revenantphx> Though, players have to be concurrnet.
11:08:21 <revenantphx> By definition.
11:08:46 <revenantphx> But all mobs or animals can be driven by a single loop thread.
11:08:56 <jmcarthur> potentially, yeah
11:09:04 * hackagebot mime-mail 0.1.0 - Compose MIME email messages.  http://hackage.haskell.org/package/mime-mail-0.1.0 (MichaelSnoyman)
11:09:06 <shapr> I've forgotten snoyman's irc nick
11:09:47 <sproingie> i'm not getting a lot out of that t-machine blog thing other than a lot of broad-brush OOP condemnations that don't strike me as accurate at all
11:10:14 <jmcarthur> sproingie: the technicals are not bad
11:10:27 <jmcarthur> sproingie: i agree that the OOP stuff is pretty much pointless
11:10:55 <kmc> what blog thing?
11:11:07 <jmcarthur> kmc: http://t-machine.org/index.php/2007/09/03/entity-systems-are-the-future-of-mmog-development-part-1/
11:12:05 * hackagebot improve 0.2.0 - An imperative, verifiable programming language for high assurance applications.  http://hackage.haskell.org/package/improve-0.2.0 (TomHawkins)
11:12:56 <jmcarthur> part 4 stupidly doesn't like to part 5...
11:13:04 <sproingie> "In tradtional OOP, if you have 100 units on a battlefield, and each is represented by an object, then you theoretically have 100 copies of each method that can be invoked on a unit."
11:13:05 <jmcarthur> part 5 is the meat
11:13:08 <sproingie> oh for crying out loud
11:13:31 <sm> shapr: snoyberg
11:14:23 <kmc> sproingie, is that "copies" in an operational memory sense, or some weird conceptual definition?
11:14:27 <ezyang> no, that's already in the tree :-/ 
11:14:55 <revenantphx> hm
11:15:04 <sproingie> vtables maybe.  likely not even then.
11:15:46 <sproingie> eh i'll just defer til i read the rest
11:16:24 <revenantphx> sproingie: Someone doesn't understand how classes work :P
11:16:29 <revenantphx> (not you)
11:16:34 <jmcarthur> revenantphx: there's also a few other ways to just model OOP in haskell, if this seems like it's not your cup of tea. or of course you can just go with a simple ADT, which is not a bad way to do it
11:16:45 <revenantphx> hm yeah.
11:16:52 <revenantphx> I'm always up for trying new stuff though :)
11:17:09 <jmcarthur> i don't think that statement was meant to be about how OOP works. on the other hand, i don't think it makes much sense from *any* angle
11:17:13 <revenantphx> I need to go write an essay... but I'll try this stuff out later.
11:17:16 <revenantphx> jmcarthur: agreed.
11:19:08 <sproingie> there is something to be said for games having to adopt different memory layouts than traditional OOP languages want to give you
11:20:12 <sproingie> especially with the PS3 which just loves to do linear access.  shades of tape drives, kinda
11:20:21 <kmc> why does it love that sproingie?
11:20:23 <kmc> lookahead caching?
11:20:36 <sproingie> cell architecture is ridiculously optimized for it
11:20:47 <sproingie> SPU's aren't so hot at random access
11:21:24 <monochrom> any heap-style malloc and free suffer from the same random-access problem
11:21:30 <jmcarthur> it would be cool for all these aggregates to be parallel arrays
11:22:20 <monochrom> may as well say any deviation from the Turing machine does not fit :)
11:23:14 <monochrom> Then again I'm all for destroying the "random access is O(1)" myth. :)
11:23:33 <monochrom> . o O ( hash tables die die die! )
11:23:39 <revenantphx> monochrom: :O
11:23:53 <jmcarthur> but in the real world hash tables *are* pretty fast most of the time
11:24:07 <monochrom> not if the real world all runs PS3
11:24:10 <jmcarthur> heh
11:24:22 <shapr> Bah, I don't have time to read the source for packdeps :-(
11:24:26 <kmc> pretty fast; also terrible for concurrency
11:24:30 * kmc is a fan of hash tries
11:24:40 <monochrom> not if the real world all runs Turing machines. not if the real world all runs Reducerons.
11:24:47 <revenantphx> monochrom: PS3?
11:24:48 <jmcarthur> hash tries? you mean like hat tries or something?
11:25:21 <kmc> not sure what a hat trie is
11:25:24 <dcoutts_> sproingie: by random access, you mean access to the main memory, presumably they have pretty decent random access to their local memory (which is only about the size of a L2/3 cache)
11:25:43 <kmc> hash trie: hash your key, then index a trie (like Data.IntMap) with the hash value
11:25:46 <shapr> revenantphx: The PlayStation 3 uses the Cell cpu. Efficient multiprocessing in the Cell requires 384-way interleaving.
11:25:49 <jmcarthur> ah
11:25:55 <monochrom> PS3's Cell is agressive about lookahead caching and so makes linear access faster than random access
11:26:16 <revenantphx> Right right.
11:26:19 <kmc> so it's "O(1)" but also persistent with lock-free snapshotting and pure functional updates
11:26:31 <revenantphx> I've always though the PS3 architecture would be interesting to look at.
11:26:32 <jmcarthur> right
11:26:34 <dcoutts_> monochrom: but only saving the difference between L1 and L2 lookup right?
11:26:37 <revenantphx> I'd heard it's *unique*
11:26:37 <kmc> or if you're trying to win over imperative programmers "optimistic update by atomic compare-and-swap"
11:26:48 <jmcarthur> i've thought about making a hash trie package if one doesn't exist, but i'm doing it lazily (haven't needed it yet)
11:26:49 <sproingie> revenantphx: PS2 architecture was pretty oddball for its time too
11:26:52 <kmc> it does exist
11:26:55 <jmcarthur> alright cool
11:27:01 <kmc> it's named "hashmap"
11:27:04 <shapr> revenantphx: It is, and I have eight dual-socket Cell blades with fully enabled and unlocked cores.
11:27:17 <monochrom> yes dcoutts_
11:27:20 <revenantphx> shapr: what?
11:27:23 <kmc> and as you'd expect, it's a layer on IntMap Int64 (Map k v)
11:27:27 <sproingie> shapr: what do you use those puppies for?
11:27:29 <revenantphx> isn't blade that IBM server?
11:27:35 <shapr> revenantphx: for that matter, Anand's Coconut project (written in Haskell) generates the fastest machine-produced Cell code I've seen.
11:27:37 <kmc> "blade" is a generic term
11:27:43 <sproingie> blades are machines on a card
11:27:43 <shapr> revenantphx: Yes, I bought an IBM BladeCenter.
11:27:51 <revenantphx> Just for fun? XD
11:28:00 <shapr> revenantphx: Yes, just for fun.
11:28:09 <sproingie> also known as "data center heaters"
11:28:12 <shapr> revenantphx: http://picasaweb.google.com/shae.erisson/UbuntuOnMyBladeCenter
11:28:26 <shapr> sproingie: truly, I had to leave the windows open in Boston wintertime.
11:28:36 <ray> =o no quaternion library on hackage
11:28:44 <revenantphx> ... and you have EIGHT of these.
11:28:49 <revenantphx> Is your computer fast enough yet?
11:28:52 <shapr> revenantphx: At $100 each, why not?
11:28:55 <revenantphx> only 100$?
11:28:56 <revenantphx> wut?
11:29:05 <shapr> revenantphx: They're down from the 2007 price of $18,000
11:29:10 <Cale> shapr: I take it the Coconut project is still going well then?
11:29:12 <revenantphx> the fffff?
11:29:17 <jmcarthur> it's ed!
11:29:20 <shapr> Cale: I haven't checked in recently.
11:29:49 <benmachine> hey Cale, the pointfree package on hackage has stopped compiling as of late, it doesn't have any maintainer or an author email
11:29:55 <revenantphx> shapr: how the hell does that work?
11:30:02 <shapr> revenantphx: Which part?
11:30:05 <mee> shapr: now you just need a filer to store some rainbow tables and you can do contract work for the nsa
11:30:08 <monochrom> dcoutts_ may be alluring to "so random access is still O(1), ignoring that it's really O(100)". By the same token, since your binary search tree is only 4GB, binary search tree access is merely O(64) but people don't think that way. Celebration for cognitive dissonance aka hypocrisy.
11:30:08 <benmachine> I thought it was probably best that lambdabot maintainers control its future, but I'm happy to take it on if you like
11:30:11 <revenantphx> the 100$ p art
11:30:19 <revenantphx> evne if it was cheap to make, I'd expect them to overcharge a bit more.
11:30:27 <shapr> mee: I thought about that, but I got distracted before I had iSCSI working.
11:30:35 <Cale> benmachine: Go for it. :)
11:30:44 <dcoutts_> monochrom: don't worry, I'm firmly in the same camp as you :-)
11:30:49 <monochrom> haha ok!
11:30:58 <jmcarthur> monochrom: you mean O(32) i think, but point taken :)
11:31:06 <jmcarthur> and of course it's the same :P
11:31:22 <kmc> monochrom, in Intro to Algorithms you learn just enough rope to hang yourself
11:31:42 <kmc> mmm rainbow tables
11:31:44 <shapr> revenantphx: It's a long crazy story, show up on #scannedinavian sometime and I'll tell it to you.
11:32:04 <ray> i spent $800 on my computer
11:32:13 * monochrom is among those who cannot count! :)
11:32:23 <Cale> Something that annoys me: using big O notation where you clearly don't want it.
11:32:27 <ray> i don't think it's quite as good as 8 servers
11:33:00 <ray> something that annoys me: using big O notation for a fixed n
11:33:04 <jmcarthur> Cale: i don't remember all the different notations, and sometimes i'm not sure whether i really want any of the common ones and instead want one that i never heard of
11:33:10 <Cale> ray: Yes, things like that :)
11:33:11 <revenantphx> shapr: so how does Cell differ from say, x86?
11:33:32 <jmcarthur> Cale: plus i can't type unicode efficiently on all machines :\
11:33:54 <monochrom> I particularly admire the numerical analysts or at least those who taught me. They reject "O(n^3)". They made me say "2*n^3/3 flops plus change". I think that's the right attitude.
11:33:55 <Cale> jmcarthur: Well, in particular, the main purpose of the big O notation is to be able to ignore constant multiples. O(1) and O(100) describe the same growth rate.
11:33:59 <jmcarthur> right
11:34:08 <kmc> monochrom, but do they account for cache?
11:34:13 <monochrom> no
11:34:27 <jmcarthur> cache hurts
11:34:30 <revenantphx> in big O world, we all deal with inifnite data sets.
11:34:31 <dpratt71> how might one constrain QuickCheck such that it produces only positive numbers for input?
11:34:33 <monochrom> well since they count flops, they ignore cache.
11:34:46 <Cale> dpratt71: There's a newtype for that.
11:34:54 <jmcarthur> dpratt71: quickcheck 2 has newtypes for things like that
11:35:00 <jmcarthur> quickcheck 1 doesn't, iirc
11:35:03 <Cale> dpratt71: I think it was just (\(Positive n) -> ...)
11:35:18 <jmcarthur> or Nonnegative, if that's what you really mean
11:35:22 <ray> maybe this weekend i will make my quaternion calculator presentable and release it
11:35:23 <dpratt71> Cale: I'll give that a go, thanks
11:35:30 <Cale> Yes, that's right.
11:35:49 <Cale> There's also NonNegative
11:36:06 <jmcarthur> positive vs. non-negative is a pet peeve of mine. bothers me more than using big O notation incorrectly because at least this is easier to be clear about
11:36:27 <jmcarthur> Cale: how would you word monochrom's statement above?
11:36:44 <dpratt71> Cale: worked! thanks
11:37:10 <shapr> revenantphx: 128 general purpose registers, each 128 bits in size. SIMD ops are awesome. Each SPU is on a ring bus that makes neighbor communicate fast. SPUs are roughly Altivec FPUs with attached DMA engines and 256k of ram.
11:37:22 <Cale> "so random access is still O(1), ignoring that it really takes 100 times longer"
11:37:22 <kmc> om nom nom
11:37:27 <shapr> aw man
11:37:40 * shapr shrugs
11:37:53 <jmcarthur> Cale: 100 times longer than what? linear access?
11:38:00 <shapr> @tell revenantphx Cell-specific questions can be directed to shapr on #scannedinavian
11:38:00 <lambdabot> Consider it noted.
11:38:01 <Cale> jmcarthur: Than what indeed
11:38:04 <Watermind> how do you pronounce Moggi?
11:38:07 <tg_> Cale: You can randomly access any data O(1)?
11:38:12 <Watermind> hard 'g'?
11:38:16 <tg_> Does that mean you randomly get what you don't want?
11:38:21 <Cale> It wasn't my statement, I simply translated it.
11:38:28 <tg_> yeah, I figured
11:38:32 <tg_> usually what you say makes sense
11:38:42 <shapr> Watermind: I've never heard anybody say it... but it's an Italian name, I'd check with someone from .it
11:38:42 <jmcarthur> lol
11:38:46 <dpratt71> so if my function goes off into the weeds with negative input, how best to handle that? test for negative values and return undefined?
11:38:54 <Watermind> shapr: good idea
11:39:09 <jmcarthur> dpratt71: if it's programmer error to give it negative input, sure
11:39:14 <Cale> dpratt71: Yeah, or better to use  error "foo: Negative input"
11:39:19 <tg_> dpratt71: use a positive-only type
11:40:00 <jmcarthur> positive-only types just move the problem into a smart constructor, honestly
11:40:14 <dpratt71> tg_: I'm not aware of what type that might be
11:40:21 <tg_> dpratt71: Integer, maybe?
11:40:27 <jmcarthur> err
11:40:27 <Watermind> shapr: ah found it, it's modji
11:40:29 <tg_> the equivalent of unsigned short?
11:40:31 <jmcarthur> you mean Word or something?
11:40:43 <jmcarthur> i wish we *had* such a type built in
11:40:48 <Cale> Yeah, it's Italian, so it's soft g
11:40:53 <jmcarthur> Int is to Integer as Word is to ??
11:40:54 <tg_> jmcarthur: I don't know what I mean :(
11:41:00 <tg_> DWord?
11:41:06 <monochrom> what does soft g sound like?
11:41:15 <dpratt71> tg_: Integer can be negative, can it not?
11:41:20 <tg_> dpratt71: yes :(
11:41:23 <Cale> (when followed by e or i)
11:41:33 <monochrom> I see.
11:41:34 <Cale> monochrom: Like "gem"
11:41:35 <tg_> which one is defined as 0 : succ?
11:41:37 <dpratt71> Cale: eh?
11:41:48 <dpratt71> Peano numbers ?!
11:41:52 <jmcarthur> tg_: naturals?
11:41:59 <monochrom> like g in Giovanni, no wonder.
11:41:59 <tg_> yeah those
11:42:01 <jmcarthur> data Nat = Z | S Nat
11:42:04 <Cale> dpratt71: what?
11:42:05 <jmcarthur> that's the lazy version
11:42:19 <tg_> dpratt71: definately not peano numbers
11:42:31 <tg_> though I do use them :O
11:42:33 * monochrom cues Mozart's Don Giovanni
11:42:42 <dpratt71> Cale: maybe I confused threads of conversation RE: your pronunciation guide
11:42:49 <Cale> dpratt71: :)
11:43:27 <monochrom> hehehe peano numbers are pronounced as geano numbers!
11:43:37 <tg_> monochrom: not by me :O
11:43:50 <monochrom> 0 is pronounced gero!
11:44:14 <tg_> is that what all those sandwhich shops are selling?
11:44:16 <tg_> gyros?
11:44:20 <monochrom> Geödel incompleteness georem
11:44:39 <jmcarthur> *sigh*
11:44:42 <tg_> monochrom: I don't see a reason why Italians should adopt a foricbly-incorrectly-translate-foreign-words rule?
11:44:52 <monochrom> no, it's me
11:44:55 <tg_> though they do have a strong counter-culture tinge to them
11:46:27 <monochrom> the italians have good culture
11:46:53 <tg_> in the same sense that bacteria can produce a good culture
11:47:01 <monochrom> no!
11:47:02 <tg_> I kid, I kid!
11:47:15 <tg_> it's the only place outside the United States I've ever been
11:47:18 <tg_> and I loved it :)
11:49:43 <benmachine> oh goodness me, a program that actually uses implicit parameters :O
11:49:52 <monochrom> goodness!
11:52:01 <byorgey> benmachine: !
11:52:03 <byorgey> where?
11:52:38 <ezyang> Cryptol uses implicit parameters. 
11:53:23 <benmachine> byorgey: pointfree
11:53:27 * hackagebot GoogleDirections 0.3.0.0 - Haskell Interface to Google Directions API  http://hackage.haskell.org/package/GoogleDirections-0.3.0.0 (KevinOberlies)
11:53:51 <byorgey> ooh, directions!
11:54:00 <benmachine> ooh shiny
11:54:05 <tg_> byorgey: unfortunately, the first direction is "go nowhere"
11:54:49 * byorgey does cabal update && cabal install GoogleDirections
11:56:25 <dcoutts_> sigh, more curl
11:58:01 * dcoutts_ notes we need a new sane high level HTTP lib
11:58:01 <benmachine> dcoutts_: to replace HTTP?
11:58:01 <mee> dcoutts_: I was just thinking that yesterday
11:58:01 <dcoutts_> benmachine: no, to use HTTP! :-)
11:58:01 <mee> or perhaps I'm just in the dark
11:58:01 <benmachine> oic
11:58:01 <dcoutts_> people clearly want to write doc <- openHTTP "http://foo...."
11:58:01 <benmachine> ah right
11:58:01 * byorgey definitely wants to write that
11:58:01 <dcoutts_> the tricky bit is making an API that starts out simple but can also let people do all the more detailed things they want
11:58:10 <dcoutts_> e.g. caching, ETags
11:58:16 <benmachine> dcoutts_: have you ever looked at http-enumerator? I've not used it but it seems nice
11:58:21 <benmachine> it's only a shame that its dependency list is so big
11:58:27 <monochrom> what is ETags?
11:58:32 <tg_> also https
11:58:49 <dcoutts_> benmachine: that's a much lower level
11:59:02 <dcoutts_> benmachine: we've got lots of solutions for that layer, including the current HTTP lib
11:59:05 <benmachine> really? they have an example that goes  main = simpleHttp "http://www.haskell.org/" >>= L.putStr
11:59:07 <mee> alternatively, I'd be fine with request <- HTTPRequest params ..., doc <- get request
11:59:16 <mee> like perl's LWP does
11:59:21 <benmachine> but I guess if you want more complex stuff that might be more difficult
11:59:23 <dcoutts_> benmachine: sure, but HTTP lib can do that too
11:59:44 <dcoutts_> benmachine: http enum is not doing proxies, redirects, etc etc etc
11:59:59 <benmachine> oh ok
12:00:05 <dcoutts_> which is what you typically want from a wget/curl style "just get me the content" api
12:01:00 <tg_> forkIO and use wget?
12:01:08 <dcoutts_> byorgey: thing is, at first you do want to just write that, but after using it for a bit you realise you need more
12:01:19 <dcoutts_> e.g. you want to reuse connections
12:01:24 <dcoutts_> so you need a context
12:01:27 <monochrom> eh, Ken Shan appears in comp.lang.functional!
12:01:32 <monochrom> err, comp.lang.haskell!
12:01:56 <ezyang> oh man! 
12:05:23 <byorgey> dcoutts_: oh, sure, I agree
12:06:06 * dcoutts_ was thinking of an API like, openHTTP :: Session -> URL -> IO Handle
12:07:36 <aristid> dcoutts_: http-enumerator does do redirects, although with a bug
12:07:38 <monochrom> HTTP.Browser has connection pool, can do "Connection: keepalive" etc
12:07:55 <byorgey> the verdict on the GoogleDirections package: needs moar documentation, but It Works! =)
12:07:57 <dcoutts_> monochrom: right, it's not bad as an implementation, but the API is unpleasent
12:08:12 <dcoutts_> aristid: oh ok
12:08:33 <aristid> dcoutts_: and, HTTP does not do SSL/TLS
12:08:38 <unkanon_>  is it possible to make [a] an instance of Num?
12:08:49 <aristid> the most complete API seems to be curl
12:08:57 <aristid> and also the worst imaginable interface
12:08:59 <kmc> yes unkanon_
12:09:13 <dcoutts_> aristid: right doing that is hard without relying on a C libs for the SSL, and then that makes the API and integration horrible
12:09:15 <kmc> unkanon_, there's at least a few different reasonable instances
12:09:18 <monochrom> the API may be more pleasant if we used a global mutable cell to record the connection pool so you could just doc <- openHTTP "http://haskell.org/" right inside IO and no alien monad! :)
12:09:25 <kmc> which makes it kind of a bad idea to write one
12:09:28 <dcoutts_> monochrom: exactly!
12:09:35 <kmc> because that becomes *the* instance for all libraries that use the standard type [a]
12:09:39 <kmc> better to use a wrapper type
12:09:40 <Cale> There's one true instance though ;)
12:09:41 <benmachine> are there any drawbacks to using -threaded these days?
12:09:44 <monochrom> hrm! you really want it?!
12:09:46 <kmc> newtype Polynomial a = MkPoly [a]
12:09:51 <aristid> dcoutts_: huh? the http-enumerator API isn't affected much by SSL (which it does support)
12:09:56 <kmc> benmachine, needing to be more careful about FFI with some libs
12:09:57 <dcoutts_> monochrom: I've been prototyping something like that
12:10:01 <unkanon_> kmc: so what are the libraries using now, before I define one that will be *the* one?
12:10:04 <Cale> (which is polynomials/power series of course :)
12:10:12 <kmc> unkanon_, there is no standard Num [a] instance
12:10:23 <kmc> unkanon_, it doesn't really matter, if you're not publishing your code
12:10:25 <dcoutts_> aristid: I've looked at the API of the SSL libs and none of them are nice
12:10:28 <kmc> but since instances are global
12:10:31 <benmachine> kmc: surely that's the exception rather than the rule?
12:10:32 * monochrom tips the Inquisition about dcoutts_ !
12:10:48 <dcoutts_> aristid: they all want to control the underlying socket/handle and hence do not integrate nicely
12:10:48 <aristid> dcoutts_: what about tls?
12:10:55 <kmc> if i were writing a program that used two libs A and B, and they had incompatible [a] instances, it would be a problem
12:11:06 <kmc> but if they each defined a different wrapper type for their specific use case, it's all right
12:11:25 <aristid> dcoutts_: well i don't really know how http-enumerator implements SSL other than that it supports both openssl and the tls package
12:11:31 <kmc> unkanon_, read about the "orphan instance" problem
12:11:31 <dcoutts_> aristid: I looked at openssl, gnutls and nsl
12:11:33 <unkanon_> kmc: well what I'm saying is, right now [1,2,3] + [4,5,6] doesn't do anything. so couldn't I get dibs on that without screwing up anything else?
12:11:46 <aristid> dcoutts_: tls is apparently not yet quite stable, but pure haskell
12:12:00 <kmc> unkanon_, then someone else publishes a library which uses a different instance
12:12:06 <kmc> and now i can't use their lib and yours at the same time
12:12:11 <dcoutts_> aristid: ok, well that's got a lot of potential, but it's a big thing to reimplement and be sure you've done it right
12:12:22 <monochrom> dcoutts_: don't forget to put cookies there too :)
12:12:32 <aristid> dcoutts_: yeah, that's why i want my http-enumerator to use the openssl module for now
12:12:43 <unkanon_> kmc: can't type synonyms solve that problem?
12:12:58 <kmc> unkanon_, those declared with "type"?  no, those are totally transparent synonyms
12:13:08 <kmc> the rule for avoiding orphan instances is that you shouldn't define an "instance C T" unless you defined either the class C or the type T
12:13:28 <kmc> an instance is orphan iff it's in a module which defines neither C nor T
12:13:58 <kmc> unkanon_, what you need for avoiding this problem is not a transparent type synonym but a new, "wrapper" type with its own data constructor
12:14:17 <kmc> you can declare that with "data" but it's more efficient (and slightly more semantically faithful) to use "newtype" in this case
12:15:13 <unkanon_> kmc: that makes complete sense. and indeed, I'm trying to define an instance C T where I haven't defined neither C nor T. I'll look into how to make newtype work so that I can have [1,2] + [3,4]
12:15:25 <kmc> well it won't quite work like that
12:15:30 * monochrom thinks it may be not so bad with an explicit "browser state grab bag" the user has to pass around at most calls of http functions. the grab bag has iorefs for keepalive connections, cookies, cache...
12:15:31 <kmc> MkPoly [1,2] + MkPoly [3,4]
12:15:43 <kmc> unkanon_, like i said, you can get away with orphan instances especially when you aren't releasing your code
12:15:48 <kmc> it's just a warning sign for bad design
12:16:07 <kmc> it's more acceptable when there's one clearly correct way to implement the class
12:16:14 * monochrom also thinks maybe provide both the global hidden state version and the explicit grab bag version and let users choose
12:16:14 <kmc> for (Num a) => Num [a] there's at least two
12:16:33 <dcoutts_> monochrom: just say no to cookies! (but yes, some people want that, and the HTTP browser module supports it)
12:16:44 <unkanon_> kmc: I want to avoid bad design and do things the proper way
12:16:45 <benmachine> kmc: what's the other?
12:16:56 <kmc> there's polynomials and vectors, i thought
12:16:58 <benmachine> ah
12:17:04 <kmc> though pointwise (*) on vectors is kinda useless
12:17:05 * dcoutts_ notes that cookies/sessions break REST and the new hackage server does not use them
12:17:09 <benmachine> yeah
12:17:19 <benmachine> and addition on list vectors is a bit od
12:17:20 <kmc> in the situation of one clearly correct implementation, the better thing is to contribute the instance upstream to the package which defined the class or the type
12:17:21 <benmachine> odd
12:17:46 <monochrom> cookies are important for automating logging in most websites like forums
12:18:18 <unkanon_> I'm only thinking of vectors here
12:18:45 <monochrom> Many years ago I used the HTTP lib to automate playing a stock game on a forum. It had automatic buying and selling.
12:19:03 <dcoutts_> monochrom: right, the web has totally messed up the way HTTP authentication is supposed to work
12:20:28 <ajnsit> was fieldtrip updated to work with opengl 2.4?
12:21:02 <ajnsit> I'm getting an error with missing ColorComponent instance for Float
12:22:25 <ezyang> Oh. Maybe what I want to do is pull all patches w/o conflicts 
12:22:28 <ezyang> mix 
12:24:17 <shapr> ow
12:24:43 <UPPIN_JONES> hey is anyone here using the  Leksah IDE for Haskell?
12:26:15 <shapr> Ok, what's the fix for all these crazy cabal dependency problems? I want to install gitit, but cabal: dependencies conflict: ghc-6.12.1 requires process ==1.0.1.2 however \n process-1.0.1.2 was excluded because ghc-6.12.1 requires process ==1.0.1.4
12:26:31 <shapr> UPPIN_JONES: I've never tried leksah, how do you like it?
12:27:36 <ajnsit> shapr, http://www.haskell.org/cabal/FAQ.html
12:27:41 <ajnsit> Dependencies conflict
12:28:11 <shapr> ajnsit: oooh, there's a FAQ! thanks!
12:29:31 <ajnsit> shapr, been there done that! I learnt the distinction between user and global packages the hard way!
12:30:08 <dcoutts_> shapr: how did you get it in that situation? using cabal upgrade?
12:30:13 <shapr> yes
12:30:27 <shapr> When in doubt, do something I haven't done before! 
12:30:50 <monochrom> still, I don't know why "ghc-6.12.1 requires process ==1.0.1.4"
12:31:05 <dcoutts_> monochrom: indirect dependencies
12:31:12 <dcoutts_> shapr: next version of cabal-install removes the upgrade command
12:31:17 <monochrom> I see.
12:31:45 <shapr> dcoutts_: Good to know.
12:32:01 <dcoutts_> monochrom: what people end up doing is rebuilding a dependency of the ghc package, and that one depends on a different version of another dep
12:32:10 <dcoutts_> hence ghc depends on two versions of a dep
12:32:48 * shapr unregisters twelve zillion packages.
12:33:02 <shapr> I should really stop trying to install all of hackage.
12:35:52 * hackagebot pointfree 1.0.4 - Tool for refactoring expressions into pointfree form  http://hackage.haskell.org/package/pointfree-1.0.4 (BenMillwood)
12:36:32 <benmachine> aw
12:36:43 <benmachine> the guy who was looking for pointfree earlier left
12:36:45 <shapr> for x in `ghc-pkg check`; do ghc-pkg unregister $x; done; # if only ghc-pkg used stdout instead of stderr!
12:37:02 <benmachine> shapr: 2>&1?
12:37:15 <benmachine> also, that's silly >_>
12:37:21 * djahandarie installs shapr
12:37:22 <shapr> eh?
12:37:37 <shapr> djahandarie: dependencies conflict
12:37:46 <shapr> shapr-1.0 requires ...
12:37:59 <jon_of_arc> cabal upgrade shapr
12:38:15 <monochrom> djahandarie probably wants to install all of hackage with minimal work by installing just shapr :)
12:38:24 <shapr> monochrom: That would make sense.
12:38:32 <djahandarie> jon_of_arc, you seem to have the latest version, shapr-1950s
12:38:43 <djahandarie> Soooo outdated
12:39:00 <jon_of_arc> I need to contact the maintainer and complain
12:39:08 <ezyang> "Compiling GHC" \o/ 
12:39:12 <djahandarie> \o/
12:39:50 <djahandarie> I should stop killing time here and get back to doing homework
12:40:39 <unkanon_> I think packages should be "pure" just like function, i.e. they shouldn't depend on other packages
12:40:47 <ajnsit> I see this message from Conal circa 2009 but with no replies - http://haskell.1045720.n5.nabble.com/ColorComponent-amp-VertexComponent-tt3197161.html
12:40:59 <ajnsit> does anyone know if he fixed the problems with fieldtrip?
12:41:56 <unkanon_> maybe I'll come up with a package system that has no dependencies, for haskell
12:42:00 <shapr> conal: o hai, how's code?
12:42:33 <shapr> unkanon_: alexj did that, before hackage. import urls were automatically rewritten to http urls, and the source was fetched and built.
12:42:45 <shapr> Was very cool, actually... but very scary too.
12:42:49 <conal> ajnsit: i've not revisited this issue since that email. i kept hoping that hopengl would be tweaked to allow new instances for those classes. and i sure don't want to cruft up the fieldtrip api with opengl types. probably other resolutions are possible.
12:42:57 <unkanon_> shapr: why aren't we all using that instead of cabal?
12:43:24 <shapr> unkanon_: Because hackage works better, as far as I can tell.
12:43:25 <quicksilver> unkanon_: because, in practice, packages *do* depend on specific versions of other packages.
12:43:39 <conal> shapr: hey there. code is a bit dormant atm. i'm just back from a 2-week trip to visit family in seattle.
12:43:39 <shapr> unkanon_: But you should try alex jacobson's approach, lemme find the url....
12:43:53 <dcoutts_> unkanon_: because it makes it very hard to reproduce a working environment
12:43:53 <quicksilver> http://searchpath.org/
12:44:01 <dcoutts_> tracking dependencies is actually important
12:44:10 <unkanon_> shapr: a new package system with no dependencies doesn't preclude hackage
12:44:29 <shapr> quicksilver: Aha, yes! That's it!
12:44:33 <unkanon_> quicksilver: yes but there's a way to separate that. they shouldn't all live in the same package namespace
12:44:41 <dcoutts_> unkanon_: well, hackage requires the .cabal metadata which includes deps, because packaging tools need that dep info
12:44:46 <unkanon_> shapr: yes plase
12:44:53 <unkanon_> oh ok
12:45:02 <shapr> unkanon_: Oh, I agree. How about writing up a blog post or -cafe message that compares and contrasts searchpath with cabal + hackage?
12:45:03 <dcoutts_> unkanon_: and you have to deal with deps on other things like C libs, tools etc
12:45:16 <shapr> unkanon_: If there's low-hanging fruit, it'd be nice if the community were aware of that!
12:45:20 <ajnsit> conal, oh, that is sad. If you can't figure it out, I'm sure certainly won't be solving this problem today. And I was hoping to play with fieldtrip :(
12:45:25 <conal> shapr: i'd most recently been working on common sub-expression elimination for my functional->gpu embedded language & compiler.
12:45:31 <dcoutts_> shapr: I think we've discussed it on haskell-cafe before
12:45:44 <djahandarie> conal, complete cse?
12:45:48 <unkanon_> shapr: I'll do some more thinking and I'll say something on haskell-cafe
12:45:57 <conal> ajnsit: it's probably not hard. 
12:46:06 <conal> djahandarie: "complete"?
12:46:25 <djahandarie> conal, more than what GHC does
12:46:32 <conal> djahandarie: i'm not going for higher-order cse or associative-commutative cse.
12:46:40 <ajnsit> conal, the easiest way being to switch to GLFloat instead of Float?
12:46:40 <shapr> conal: sounds awesome! is that at all related to work by Anand and/or Chakravarty?
12:46:43 <conal> djahandarie: definitely more than what ghc does, which is almost nothing.
12:46:50 <shapr> I should go read your references, most likely.
12:47:04 <conal> shapr: refs?
12:47:08 <shapr> unkanon_: I'd enjoy hearing what you discover in the meantime.
12:47:29 <shapr> conal: Chris Anand's work on coconut, chak's recent work on GPU stuff?
12:47:34 <shapr> I don't have citations handy.
12:48:02 <unkanon_> shapr: I was thinking of doing something akin to what pathogen does for vim plugins
12:48:12 <shapr> unkanon_: Never heard of it, I use emacs.
12:48:14 <monochrom> I am not sure searchpath and cabal are significantly different. I can only see difference in file sizes.
12:48:20 <conal> ajnsit: yeah. s/Float/GlFloat/ is the easiest way but would cruft my API beyond my tolerance.
12:48:25 <djahandarie> conal, annoyingly, GHC's cse manages to screw stuff up sometimes even though it does barely nothing. :P
12:48:35 <conal> djahandarie: oh?
12:48:48 <dcoutts_> monochrom: hmm?
12:48:51 <djahandarie> Though it's been awhile since that has happened to me. I think whatever heure
12:49:00 <djahandarie> heuristics they were using have improved
12:49:12 <monochrom> I.e., if you have a main program that needs linking both time-1.1.1.1 and and time-1.1.1.2 for some reason, it fails either way.
12:49:22 <quicksilver> shapr: unless, of course, we included in our import statements not only the full types of the names we wanted to import, but also their complete specification.
12:49:32 <unkanon_> well let me see if I get thise straight. one of the main problems is that when I "cabal install" say the hledger package, then the packages wai-extra and yesod will all be installed in the same namespace as all the other packages I have, right?
12:49:50 <quicksilver> shapr: in that case, in the spirit of unkanon_'s remark about purity, we could automatically fetch any package which satisfied them.
12:50:02 <unkanon_> and if I need the yesod version I have, then I will have conflicts because this cabal install will overwrite my version of yesod?
12:50:03 <quicksilver> shapr: there are a few gaping unsolved problems to resolve before we get there though :)
12:50:03 <conal> shapr: thx for the refs. i don't know coconut. i've been a bit in touch with manuel about cse. i've had cse, but it only captured representation sharing, using a typed variant of andy gill's observable sharing.
12:50:50 <monochrom> I am not sure that there are multiple namespaces at all.
12:50:53 <unkanon_> monochrom: that's one seriously flawed program if it needs to link to two versions of the same lib, no?
12:51:08 <conal> shapr: now i've added a 2nd method that's thorough (grabbing equal terms, not just pointer-equal ones) but too slow. next i'll combine them to get fast & thorough.
12:51:12 <unkanon_> monochrom: right, that's what we need to implement, one namespace for each *package*
12:51:20 <monochrom> No. Your main program wants packages X and Y. X wants time-1.1.1.1, Y wants time-1.1.1.2.
12:51:32 <dcoutts_> unkanon_: do you mean package/version namespaces, or module namespaces?
12:51:41 <unkanon_> monochrom: then that will be fine if X and Y have different namespaces
12:51:46 <unkanon_> dcoutts_: package
12:51:53 <dcoutts_> unkanon_: ghc and cabal support private/isolated package databases
12:52:06 <quicksilver> unkanon_: not if X takes some value of a type declared by time-1.1.1.1 and feeds it to Y
12:52:08 <monochrom> Have you looked into the time package yet? It contains its own C code.
12:52:23 <quicksilver> unkanon_: time-1.1.1.1:Foo is a different type from time-1.1.1.2:Foo
12:52:29 <quicksilver> (well, potentially different)
12:52:39 <monochrom> Both time-1.1.1.1 and time-1.1.1.2 exports the same C function names. Cannot be linked together.
12:52:51 <quicksilver> monochrom: that's trivial to solve. It's not the real problem here.
12:52:59 <monochrom> And then I can come up with another example involving type classes.
12:53:10 <unkanon_> quicksilver: how's that trivial to solve?
12:53:22 <quicksilver> unkanon_: linking can use either private namespaces or symbol renaming
12:53:33 <quicksilver> both solutions exist in certain real linkers
12:53:46 <unkanon_> quicksilver: oh then that's not a problem at all?
12:54:06 <quicksilver> the real problem is when the main program has an interaction which uses time-1.1.1.1 (via X) and time-1.1.1.2 (via Y) simultaneously
12:54:12 <dcoutts_> in principle it's not a problem, in practice it'll take a bit of work to sort out
12:54:16 <quicksilver> that part is a fundamental incompatibility.
12:54:29 <dcoutts_> yep, unification is the key issue
12:54:41 <unkanon_> quicksilver: and that can't be solved by having different namespaces for each package?
12:54:49 <dcoutts_> unkanon_: no
12:54:53 <dcoutts_> it's a source level problem
12:55:08 <dcoutts_> and that's why cabal tries to avoid using multiple versions of the same package
12:55:15 <unkanon_> so the problem is deeper than package-level but higher than linker-level?
12:55:22 <dcoutts_> not because they cannot be linked, but because compilation may fail
12:55:35 <dcoutts_> it does not have enough info to know types from the two versions will not be unified
12:55:45 <conal> ajnsit: i think fieldtrip can be fixed without uglifying the API by doing the Float -> GlFloat conversion internally.
12:56:01 <quicksilver> unkanon_: it's a semantic problem. It doesn't relate to the tools at all.
12:56:10 <quicksilver> unkanon_: it relates to the programmer and what he means.
12:56:26 <dcoutts_> and our lack of a proper module system :-)
12:56:35 <quicksilver> supposing time package defines the type UTCTime, and it changed in a substantial way between the two versions considered.
12:56:37 <unkanon_> is there any language that has that problem solved already?
12:56:45 <dcoutts_> unkanon_: ML with it's functors
12:56:46 <monochrom> I am glad to shoot down another attempt to abstract-hide dependencies! :)
12:56:48 <dobblego> is it possible to put multiple lines in a cabal file description?
12:56:53 <quicksilver> package X (which imports time) has a function which returns UTCime
12:56:54 <unkanon_> dcoutts_: then why don't we copy them? :)
12:57:04 <quicksilver> package Y (which imports time) has a function which accepts UTCTime
12:57:04 <dcoutts_> dobblego: yes
12:57:11 <dcoutts_> unkanon_: it's a change to the language
12:57:11 <quicksilver> the programmer expects to be able to pass the former to the latter
12:57:22 <quicksilver> so, the programmers needs X and Y to agree what UTCTime is.
12:57:47 <unkanon_> quicksilver: thanks, with your explanation I think I understand the problem now. I'll have to think about it
12:58:01 <unkanon_> dcoutts_: could you clarify?
12:58:12 <dcoutts_> monochrom: but what I'd like is a way to specify private dependencies
12:58:36 <monochrom> dobblego: http://hackage.haskell.org/packages/archive/bytestring/0.9.1.8/bytestring.cabal is an example of multi-line descriptions etc
12:58:51 <dobblego> monochrom, thanks
12:58:55 <monochrom> in particular two paragraphs too. note the "."
12:58:56 <dcoutts_> monochrom: it covers a common case where types from a dep are not re-exported. It's not as general as a full unification checker or functor system.
12:59:13 <monochrom> always look for dons's packages for examples :)
12:59:19 <dobblego> haha
12:59:30 <dcoutts_> except when dons does silly things like build-depends: base < 10
12:59:48 <monochrom> oh I was about to bring up that role-model example as well!
12:59:55 <dcoutts_> dons will get have the QA bot after him for things like that
13:00:00 <dcoutts_> it has no mercy
13:00:19 <aristid> but then his own bot will take revenge of some kind
13:01:06 <dcoutts_> aristid: that's indeed unfortunate, since the QA bot is impervious to threats
13:01:33 <quicksilver> unkanon_: there are of course cases where package X and package both use the same library in a way which is totally non-interfering
13:01:46 <quicksilver> unkanon_: however, it's not necessarily clear how you detect or describe that situation.
13:01:58 <aristid> dcoutts_: a spiral of violence
13:02:02 * hackagebot uuagc 0.9.36 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-0.9.36 (DoaitseSwierstra)
13:02:05 <unkanon_> quicksilver: that example you gave, does that happen all the time?
13:02:14 <dcoutts_> aristid: yep, it'll be terrible
13:02:33 <dcoutts_> unkanon_: functors are a language feature that ML has, but Haskell does not, we have other similar language features but they do not address the packaging issue
13:04:03 <conal> shapr: wow - that coconut work looks very cool.
13:05:53 <unkanon_> dcoutts_: ok i'll read some about those ML functor.s that's SML, right?
13:06:15 <dcoutts_> or ocaml
13:07:45 <unkanon_> so both have solved the deps problem?
13:08:20 <unkanon_> do you guys know any other languages that solved it? I'm asking my php co-worker and he says "php doesn't suffer from that problem"
13:08:47 <quicksilver> PHP doesn't check deps at all
13:08:47 <jedai_> dcoutts_: I don't really see how functors solve the versioned deps problem (though they're pretty cool and useful)
13:08:55 <quicksilver> it just calls the libraries
13:09:08 <quicksilver> if they're incompatible, undefined behaviour results.
13:09:17 <quicksilver> undefined behaviour is pretty much the norm for PHP scripts, so that's not frowned on.
13:09:21 <blackdog> ah, the hail mary pass
13:09:43 <blackdog> we do make a rod for our own backs with this whole "correctness" fetish, no?
13:09:52 <dcoutts_> jedai_: the point is it becomes possible for a tool to work out which compositions of modules are compatible
13:09:53 * quicksilver nods
13:10:13 <dcoutts_> jedai_: well, not sure about a search, but any specific test composition can be checked
13:10:39 <dcoutts_> I think it involves interface checking plus unification
13:10:49 <sleepynate> quicksilver: i was commenting earlier that php is so messed up that it's the only language I know whose code-formatter can actually make standard code stop functionting properly :/
13:11:04 <monochrom> haskell really lacks a module system :)
13:11:09 <jedai_> dcoutts_: only if it use functors explicitly though, ML code can also open modules without being a functor, no ?
13:11:42 <monochrom> yeah
13:11:56 <dcoutts_> jedai_: I'm not too sure, my understanding is that it's at least clear what the imports are, what is imported from what
13:12:19 <dcoutts_> so you can see what the import interface is, as well as the export interface
13:12:23 <unkanon_> wait where's the reply to jedai_ 's question? how do functors solve the deps problem?
13:12:50 <monochrom> there is a school of functorial programming. it insists you parameterize over everything you want to import.
13:13:18 <xplat> yeah, haskell's modules are pretty weak.  can't even rename a symbol on import, never mind parameterize on modules
13:13:51 <unkanon_> hmm
13:13:52 <dcoutts_> monochrom: and from the pov of packaging I think that'd be useful, to get that degree of info. Mind you it does not have to be explicitly done by the programmer, if it can be derived.
13:14:54 <dcoutts_> unkanon_: the point is, a packaging system is composing programs like sticking blocks together
13:15:08 <quicksilver> xplat: not being able to rename on import is not a true expressivity gap. It's just a convenience one. You can say "import Foo.Bar qualified as SecretModule1234; baz = SecretModule1234.bar" if you really want.
13:15:14 <dcoutts_> and it's obviously helpful to know how the blocks fit together
13:15:38 <dcoutts_> a system of package names, versions and version ranges is a rough approximation
13:15:53 <unkanon_> dcoutts_: I think of functions in terms of blocks too, but functions don't suffer the same problems that packages seem to
13:15:58 <dcoutts_> something like ML's functors might give you enough information to to a better job
13:16:05 <jedai_> unkanon_: I would say that ML has the potentiality, used properly, to rule out problems caused by the deps version with better flexibility than Haskell...
13:16:15 <dcoutts_> unkanon_: it's about interfaces/types
13:16:17 <monochrom> I say that ABI compatibility is the real issue.
13:17:29 <jedai_> unkanon_: In my experience though, ML implementation mostly avoid that problem by having less libraries and inferior automatic installation tools so those problem don't arise as much as in Haskell since the advent of Cabal and cabal
13:17:39 <monochrom> Then again ABI compatibility implies denying a lot of fusion optimizations.
13:17:43 <blackdog> monochrom: yeah, definitely. is a big deal for packaging.
13:17:48 <quicksilver> monochrom: ABI compatibility is the issue which can lead, possibly, to crashes.
13:17:59 <xplat> quicksilver: sure, but it's a pretty big convenience gap ... especially since different kinds of symbols need different kinds of declarations to rename them
13:18:32 <quicksilver> monochrom: but specification (in)compatibility is also an issue, which in general leads to code which runs but exhibits undefined behaviour.
13:19:12 <quicksilver> xplat: agreed. I would be totally in favour of a good import-renaming extension.
13:19:22 <quicksilver> xplat: and re-export-with-qualifications while we're at it.
13:20:28 <monochrom> http://thread.gmane.org/gmane.comp.lang.haskell.cafe/83264/focus=83298
13:21:15 <monochrom> too bad it renames @ to <at>!
13:21:16 <unkanon_> quicksilver: you know what my naive mind thinks is the solution to that example problem you gave?
13:21:59 <monochrom> http://www.mail-archive.com/haskell-cafe@haskell.org/msg84168.html
13:22:10 <xplat> i'd have expected this to be an instantly googleable, or even hoogleable, question, but what is the best way to convert a bytestring to a string?  (Data.ByteString.ByteString)
13:22:51 <unkanon_> if the package X depends on time-1.1, then when the programmer of package X submits it to the repo, package X would then no longer be dependent on anything, because it would have encapsulated time-1.1 and its functions under its own namespace
13:22:59 <monochrom> I particularly like this quote of mine: One name doesn't fit all.
13:23:09 <unkanon_> so that if package X wants to export a UTCTime it has to do that itself
13:23:20 <blackdog> xplat: unpack, i think. although that gives you [Word8]
13:23:25 <unkanon_> and not rely on time-1.1 (although now it's ok to rely on it since it's embedded)
13:23:34 <kmc> xplat, ByteString holds bytes, String holds characters
13:23:58 <kmc> xplat, so converting between the two involves character encoding/decoding, which means there's lots of ways to do it
13:23:58 <xplat> unkanon_: then how do you pass UTCTimes returned from another package's function into package X's functions?
13:24:01 <tromp_> :t when
13:24:03 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
13:24:09 <tromp_> @hoogle when
13:24:09 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
13:24:23 <quicksilver> unkanon_: you can certianly do that; that's the 'private namespace' approach
13:24:33 <unkanon_> xplat: you the programmer write a function that "translates" them
13:24:34 <monochrom> Data.ByteString.Char8.unpack gives String, if you don't mind the Char8 part.
13:24:40 <kmc> ByteString.Char8 is a hack and a lie
13:24:40 <unkanon_> since it's nobody's fault really
13:24:46 <quicksilver> unkanon_: but now my top-level program which is using both X and Y cannot use a UTCTime from one in the other.
13:24:53 <kmc> also, cultural imperialism
13:25:08 <quicksilver> unkanon_: how can you write that without knowing the internals of both, though?
13:25:17 <xplat> kmc: i know this, and i would be happy with, say, one.  my bytestrings on input happen to be guaranteed US-ASCII encoding, so ascii, latin1, or utf8 are fine.
13:25:35 <tromp_> :r
13:25:56 <monochrom> utf8-string will work, then
13:25:57 <jmc_fr> hello - I'm a kind of newbie, needing help for dealing with Strings including chars with accents - my code here produces strange results, both in files as in GHCi : http://hpaste.org/42165/tesths
13:26:27 <kmc> xplat, maybe you want Data.ByteString.UTF8 from the utf8-string package
13:26:34 <monochrom> jmc_fr: could you specify complete runtime info? such as OS
13:26:37 <unkanon_> quicksilver: I don't understand why you'd have to know the internals.
13:26:46 <monochrom> such as OS and locale settings
13:26:47 <unkanon_> it's a superficial problem
13:26:48 <kmc> xplat, or stuff from the "text" package
13:27:38 <unkanon_> jmc_fr: you need to specify both your terminal and your code editor to use unicode
13:27:47 <jmc_fr> monochrom: windows XP, Haskell Platform, GHCi, version 6.12.3
13:28:14 <quicksilver> unkanon_: well, maybe UTCTime is too simple an example.
13:28:31 <quicksilver> unkanon_: suppose we switch our example to some fictional http-lib-1.2 vs http-lib-1.3
13:28:36 <jmc_fr> code editor = NotePad++, my .hs is encoded in UTF-8
13:28:48 <unkanon_> maybe, yes, or maybe I'm just trivializing the problem for lack of better understanding
13:28:51 <quicksilver> unkanon_: and the common type is "HTTPRequest" which contains all kind of info about a request and a response, headers, encodings, body, etc.
13:29:13 <quicksilver> unkanon_: now, with your solution the "HTTPRequest" type exported by X is a different type from the one exported by "Y"
13:29:17 <xplat> unkanon_: say package X uses time, and so does package Y.  package X has a function prettyTime :: X.Foo.UTCTime -> String.  Y has modTime :: Handle -> IO Y.Something.UTCTime.  how do i plug those two together?
13:29:29 <quicksilver> but it's hard for me, as a user of X and Y, to write the translation function.
13:29:41 <jmc_fr> unkanon_: I've jsut answered to monochrom above
13:30:40 <unkanon_> jmc_fr: in notepad ++ on the right hand corner, one of those menu options will lead you to a window where you can pick unicode for both the terminal output from the embedded terminal in  notepad++ and its text editor. I remember when I used notepad++, that solve dit all
13:31:40 * unkanon_ is thinking 
13:32:53 <jmc_fr> unkanon_: not sure I understand : I'm only editing my source in NotePad++, not running. I run in GHCi, writing in an output file, where there are problems
13:33:52 <unkanon_> jmc_fr: then you need to do a codepage change in your cmd
13:34:01 <unkanon_> cp 66something, I forgot
13:34:25 <unkanon_> chcp 65001
13:34:31 <unkanon_> jmc_fr: try that and tunr your code again ^
13:34:42 <monochrom> jmc_fr: I'm not on Windows yet, but to show you it probably works as you expect on linux: http://hpaste.org/paste/42165/tesths_output_on_linux_with_a#p42167
13:34:43 <unkanon_> exit ghci, run that, go back into ghci
13:34:51 <xplat> chcp 65001?  and they call unix commands obscure ...
13:34:58 <unkanon_> chcp = change codepage
13:34:58 <chsigi>  /quit
13:35:09 <monochrom> This is why I refer to Windows as MSDOS.
13:35:40 <Zao> Note that you will not have much luck trying to use UTF-8 as console codepage.
13:35:45 <monochrom> The most ridiculous part is that the default code page is not already 65001.
13:35:48 <Zao> For hysterical raisins.
13:35:58 <xplat> no, it's now MRSDOS, because it's married to the gui
13:36:08 <monochrom> hahaha
13:36:10 <unkanon_> quicksilver: indeed now those HTTPRequest's are different types.
13:36:29 <jmc_fr> monochrom: well, no it doesn't work correctly : the String in TestRecord is not ok, same as under Windows
13:36:35 <handonson> (gtk) it seems { onDestroy window mainQuit } is deprecated... what is the new recommended code that does the same?
13:36:47 <monochrom> Anyway it's like their console assumes you still living in 1984.
13:37:09 <quicksilver> unkanon_: yes. and actually that is GHC's implementation too (GHC considers them different types, so it gives you a compile error)
13:37:31 <quicksilver> unkanon_: the alternative (to assume the types are the same) is to risk a crash, as data layout might have changed.
13:37:44 <aWagner> Hello, I am trying to search for a list of tuples(pairs) in another list of tuples(pairs) and return the indices of the matches. The hard part is: the first element of each tuple in the match must be greater than or equal to the first element of each of the pattern's tuples. The second element must only match. Is there a low complexity way to do this? I have been trying all sorts of things that are too ugly for me to have seen in other haskell code. Well, I
13:37:50 <unkanon_> quicksilver: GHC is doing the right thing here. the main thing to focus on is, the fact that the version of HTTPwhatever is different between X and Y is nobody's fault, don't you agree?
13:38:07 <monochrom> handonson: on window deleteEvent (liftIO mainQuit >> return False)
13:38:15 <xplat> it may be nobody's fault, but it's not nobody's problem
13:38:15 <quicksilver> unkanon_: yes.
13:38:28 <unkanon_> xplat: well it's the programmer's problem now
13:38:30 <unkanon_> right?
13:38:32 <quicksilver> unkanon_: and the solution is to recompile them both against the same HTTPwhatever. Which is a pain.
13:38:44 <quicksilver> but, so far as I am aware, a necessary pain.
13:38:47 <benmachine> it ain't not nobody's problem
13:38:56 <quicksilver> that is, I"m not aware of a solution which does away with that.
13:39:00 <handonson> monochrom: wow thanks
13:39:14 <unkanon_> quicksilver: that can't be the solution because if the code in Y relies on that particular HTTPRequest data structure layout, then it'll break under recompilation
13:39:26 <quicksilver> that's certainly true.
13:39:38 <quicksilver> there might be a new version of Y released now
13:39:45 <quicksilver> to support the new http request
13:39:50 <quicksilver> you have to check hackage :-/
13:39:51 <unkanon_> so just recompiling won't solve that
13:40:00 <quicksilver> it might. It's not guaranteed to.
13:40:13 <unkanon_> right, I want to think of a guaranteed solution
13:40:15 <quicksilver> If recompiling solves it, we say the versions were "source compatible"
13:40:31 <quicksilver> Hackage has a versioning policy which is supposed to indicate when you have source compatibility.
13:40:47 <jmc_fr> unkanon_: done. Problem still here. It's not only in GHCi, it's also in the output file - same underlinux as monochrom states
13:40:57 <xplat> one solution, if appropriate, is for the HTTP package author to supply 'migrations' with the package, which i think has been used in some academic projects and some homegrown package systems for erlang, besides its slightly differing use in webservers
13:41:04 <monochrom> jmc_fr: TestRecord {getString = "\269u\353paj\382 - \224\233\232\239\244\249\251^y\231&$\181\167"}  is correct behaviour for show TestRecort{...}.  Here:
13:41:06 <unkanon_> isn't that one of the strong reasons why OO has interfaces? so that stuff won't break on the next versions?
13:41:15 <monochrom> > show "Gödel"
13:41:16 <lambdabot>   "\"G\\246del\""
13:41:20 <unkanon_> jmc_fr: hmm
13:41:47 <quicksilver> xplat: or, it can export the "old" symbols as well as the "new" ones
13:41:56 <xplat> there can be no fully-automated solutions to all versioning problems short of AI
13:41:57 <red_> I'm pretty new to fucntional dependencies and mult-parameter type classes, but can someone tell me why `gett` fails to type here <http://pastebin.com/bk258e5g>. It seems to be unable to infer the type of the third parameter from the constraints I've given it.
13:41:59 <quicksilver> xplat: that's what the linux kernel does in some limited circumstances (symbol versioning)
13:42:05 <quicksilver> I think glibc too, perhaps?
13:42:14 <xplat> quicksilver: which is what COM does too, and glibc
13:42:32 <quicksilver> because they have a massive incentive to maintain binary compatibility
13:42:39 <quicksilver> because they're at the center of the dependency web.
13:43:42 <jmc_fr> monochrom: OK, is there any possibility to get "myRecord" written the right way ?
13:44:05 <monochrom> if you plan to use show, write your own Show instance.
13:44:44 <red_> I've given constraints a -> l, l -> b in my typeclass, so (as far as I know, and I may be wrong), I explicitly placed l and b in the intended relation. Shouldn't GHC infer from some t :: l the correct type b?
13:44:51 <quicksilver> monochrom: not particularly easy to do, unfortunately.
13:44:52 <unkanon_> quicksilver: ok for that HTTPRequest problem, package X should have functions like getBodyFromRequest, getHeaderFromRequest, etc, and then package Y's function that takes an HTTPRequest should take requests broken down, so it would have a function like takeRequest header body = ....
13:45:04 <xplat> short of fully-automated solutions, one thing that's been suggested is to have source repos publish refactorings in their semantic form
13:45:18 <quicksilver> monochrom: you have to get the rules for string escaping right..
13:45:28 <quicksilver> actually maybe it's not that hard in haskell.
13:45:30 <xplat> so that they can be applied automatically to client libraries
13:45:37 <monochrom> Not if you don't intend to have a Read instance at all.
13:45:49 <quicksilver> monochrom: ah, well, then it's not a show instance :)
13:45:50 <BestCode> Hello
13:46:02 <quicksilver> monochrom: it's something evil and polluted, just call it prettyPrint instead.
13:46:27 <monochrom> Fine. Not fine. pretty_print. camel_case die die die
13:46:29 <quicksilver> unkanon_: you can do that, definitely, but it's throwing away the baby with the bathwater - you're getting rid of all custom types.
13:46:34 <aristid> quicksilver: why? there's no hard law saying there must be a Read instance for every Show instance. otherwise, both would just be combined in a single class, right?
13:46:47 <quicksilver> aristid: the hard rule is that Show instances must produce haskell syntax
13:47:07 <quicksilver> aristid: what I assume monochrom was suggesting is not to bother to get string escaping right - then it wouldn't be haskell syntax any more.
13:47:11 <monochrom> pretty_print TestRecord{getString=s} = "TestRecord{getString=" ++ s ++ "}"
13:47:26 <BestCode> I am getting this error message, any idea http://pastebin.com/CaU3VPap
13:47:33 <xplat> ByteString's show instance doesn't read back correctly, but it is valid haskell syntax
13:47:39 <aristid> quicksilver: it can't be such a hard rule, given how many instances fail to obey it
13:47:44 <quicksilver> aristid: when I say 'hard rule', of course, I'm being slightly flippant :)
13:47:55 <quicksilver> aristid: but, all such Show instances are broken.
13:47:58 <monochrom> Look, there is no witness of violation if there is no Read instance.
13:48:06 <xplat> well, i should say it doesn't read back correctly as a literal.  it does with Read.
13:48:12 * monochrom burns down the Inquisition!
13:48:30 <jmc_fr> monochrom: ok, what if I nead to read it afterwards ?
13:48:32 <unkanon_> quicksilver: well but then now you the programmer can create a new HTTPRequest type and easily write a function that translates between the two HTTPRequest types
13:48:36 <xplat> or with that extension for overloaded string literals
13:48:48 <mauke> BestCode: import qualified Data.List as List
13:49:07 <unkanon_> quicksilver: but yes I see what you're saying , but what I'm saying is I think it's impossible to solve the problem while still keeping both old HTTPRequest data types and having them work with each other
13:49:07 <xplat> unkanon_: easily?
13:49:18 <BestCode> like this import Data.Lisr
13:49:26 <BestCode> mauke:  like this import Data.Lisr
13:49:31 <mauke> what
13:49:38 <BestCode> mauke:  like this import Data.List
13:49:45 <monochrom> If you want to read it afterwards, may as well stick with deriving (Show,Read) and not worry about why ö becomes \264 . In fact that's done precisely for reading back.
13:49:50 <mauke> wait, that's not actually what I meant to say
13:49:57 <monochrom> Pick one: readable by human, readable by machine.
13:49:58 <BestCode> oh ok
13:50:01 <mauke> BestCode: I meant: import qualified Data.Map as Map
13:50:58 <BestCode> mauke: still same error message
13:51:16 <mauke> you should have gotten a different error message
13:51:33 <jmc_fr> monochrom: ok, but preciselu for my project i need both !!! well, i need the 3 : the accents, the human readable, the machine readable ....
13:51:35 <unkanon_> xplat: yes because the translation function will be calling X's getHTTPRequest and feeding the header and body it returns into the Y's takeHTTPRequest
13:51:36 <BestCode> nope the same 
13:52:12 <xplat> import qualified Data.Map as Ṃ
13:52:39 <xplat> unkanon_: oh, you're talking about serializing.  what about when you have a type that doesn't have a standardized serialization?
13:52:41 <mauke> BestCode: are you actually using Map and Set?
13:52:47 <BestCode> this http://pastebin.com/PedJkiKm
13:52:53 <revenantphx> so uh
13:52:54 <lambdabot> revenantphx: You have 1 new message. '/msg lambdabot @messages' to read it.
13:53:06 <BestCode> mauke: I will later on http://pastebin.com/PedJkiKm
13:53:07 <xplat> you're really just shoving the problem off to the IETF as it is
13:53:15 <mauke> BestCode: uh, remove line 6
13:53:21 <monochrom> Then you should specify your project formally (using math formulas) and completely. There are always questions like: what if your string has ", what if your string has newlines... Well you could say they don't happen, well that's why you have to specify formally and fully.
13:53:24 <BestCode> oh ok
13:53:33 <benmachine> solving problems is the IETF's job
13:53:38 <benmachine> they can deal
13:53:41 <unkanon_> xplat: no not serializing
13:53:56 <unkanon_> xplat: just pluging in results into parameters
13:54:54 <xplat> unkanon_: okay, so what if the header type is different?  or what if the body type is different?
13:55:14 <unkanon_> what's IETF?
13:55:29 <monochrom> IETF is the people who do the RFCs
13:55:38 <BestCode> mauke: the error message is in this line  show (Grd grid)    = '\r' : (formatChars . unlines . (map show) $ grid)
13:55:41 <unkanon_> but I'm not talking about serialization
13:56:02 <Watermind> is there a pre defined monadic operator for kleisli 'functions'?
13:56:06 <revenantphx> Are there any up to date alternatives to EnumMap?
13:56:12 <revenantphx> That you guys would recommend?
13:56:20 <xplat> or what if the HTTPRequest in 4.x is divided into HTTPEntity and HTTPMessageHeader and HTTPHopHeader?
13:56:30 <revenantphx> Insertion/deletion speed is not nearly as important as access/modify speed.
13:56:47 <mauke> BestCode: did you get a different message?
13:57:01 <BestCode> no
13:57:03 <BestCode>   Ambiguous occurrence `map'
13:57:14 <BestCode>  It could refer to either `List.map', imported from Data.List at KenKen2.hs:5:0-23
13:57:24 <BestCode>  or `Set.map', imported from Data.Set at KenKen2.hs:6:0-21
13:57:31 <benmachine> Watermind: monadic operator?
13:57:35 <jmcarthur> revenantphx: i just learned of the existance of hashmap today. that could serve the purpose for you
13:57:35 <benmachine> Watermind: composition operator?
13:57:37 <xplat> Watermind: do you mean Control.Monad.(>=>) maybe?
13:57:39 <Watermind> i.e.  given f: a->m b  and g : b -> m c   an operator   g |o| f : a -> m c
13:57:40 <benmachine> :t (<=<)
13:57:41 <red_> If I have a 3-ary relation over types, I want to express an equivalence relation between them. Actually, the relation doesn't need to be stronger than a -> l b, l -> a b for types l b a. But I'm not sure if I read the syntax right. I though t -> t t' was shorthand for t -> t and t -> t'?
13:57:41 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
13:57:48 <ddilinger> i've been reading a blog recently about visualizing haskell data types, and it talks alot about partial ordering with resepect to bottom (upsidedown T), but i cant figure out whats the use of having that partial ordering?
13:57:50 <BestCode> this is the line with the error message show (Grd grid)    = '\r' : (formatChars . unlines . (map show) $ grid)
13:57:51 <mauke> BestCode: that is different
13:57:52 <Watermind> benmachine: exactly thank you
13:57:54 <pokoko222> hello dear haskellers, is image processing done in haskell?
13:57:59 <BestCode> yes
13:58:02 <benmachine> Watermind: the thing you asked for is actually (>=>)
13:58:03 <mauke> BestCode: import qualified Data.Set as Set
13:58:10 <pokoko222> i mean for image processing poeple use c++ but i am just curious if you do it in haskell too
13:58:11 <jmcarthur> it's pokoko222!
13:58:11 <jmc_fr> > :t toString
13:58:12 <lambdabot>   <no location info>: parse error on input `:'
13:58:12 <benmachine> but (<=<) more closely mirrors function composition
13:58:16 <pokoko222> for computer vision applications
13:58:20 <ddilinger> jmc_fr: you want show
13:58:27 <ddilinger> > :t show
13:58:27 <jmcarthur> pokoko222: there's a binding to opencv
13:58:28 <lambdabot>   <no location info>: parse error on input `:'
13:58:31 <Watermind> xplat: yes that one :)
13:58:33 <Watermind> benmachine: ye strue
13:58:34 <jmcarthur> i think that's what it's called
13:58:34 <jmc_fr> ddilinger: tks
13:59:01 <jmcarthur> pokoko222: sinelaw made a robot that follows you using it and some frp i think
13:59:18 <pokoko222> jmcarthur serious? i do opencv in c++
13:59:30 <BestCode> mauke: thank you what is the difference between qualified and the regular
13:59:38 <jmc_fr> monochrom: tks
13:59:41 <jmcarthur> pokoko222: http://hackage.haskell.org/package/HOpenCV
13:59:46 <jmc_fr> unkanon_: tks
14:00:09 <pokoko222> jmcarthur you have any experience? are the algorithms easier in functional paradigm?
14:00:29 <jmcarthur> pokoko222: you'll need to ask sinelaw about that
14:00:47 <xplat> pokoko222: also http://hackage.haskell.org/package/cv-combinators maybe
14:00:55 <jmcarthur> ah, sinelaw made that too
14:01:00 <ddilinger> how is bottom (undefined) used in practice/
14:01:03 <pokoko222> sinelaw dear friend share some experience with opencv please, compare it with doing image processing in OOP
14:01:19 <ezyang> ddilinger: It's used mostly for reasoning about the behavior of lazy programs. 
14:01:21 <jmcarthur> ddilinger: it's typically used to reason about the laziness/strictness of your functions
14:01:23 <pokoko222> ah he is not here
14:01:54 <unkanon_> xplat: the header types will always be different. oh, now I see why you thought I meant serialization
14:01:56 <mauke> BestCode: 'import Foo.Bar as Baz' is equivalent to 'import Foo.Bar; import qualified Foo.Bar as Baz'
14:02:04 <jmcarthur> bah, beaten by the guy with the cool blog articles ;)
14:02:20 <BestCode> oh ok
14:02:20 <monochrom> dilinger_: http://article.gmane.org/gmane.comp.lang.haskell.cafe/20686/ and http://article.gmane.org/gmane.comp.lang.haskell.cafe/23231/
14:02:22 <ezyang> haha 
14:02:22 <BestCode> thank you
14:02:31 <ddilinger> ezyang: oh, yea its your blog i'm reading that made me wonder :)
14:02:34 <Watermind> by the way is there a compositon that works in the oposite way of (.) ?
14:02:42 <jmcarthur> ezyang: i tried writing a blog post with handmade diagrams like yours but my handwriting sucks too much
14:02:43 <Watermind> the usual  f ; g 
14:02:45 <ezyang> I need to do zygoloid's fixes. 
14:03:02 <monochrom> ddilinger: http://article.gmane.org/gmane.comp.lang.haskell.cafe/20686/ and http://article.gmane.org/gmane.comp.lang.haskell.cafe/23231/
14:03:06 <ezyang> jmcarthur: I'm sure it's not that bad 
14:03:06 <xplat> unkanon_: if you're talking about recursively breaking down everything into primitive types that never change, that's pretty similar to serialization.  maybe call it 'arborization' ...
14:03:12 <jmcarthur> ezyang: it looks good in your blog, but my own equivalent looked pretty terrible
14:03:23 <ezyang> :-/ 
14:03:48 <jmcarthur> do you use a drawing tablet? that's what i tried with. i just suck that much
14:04:03 <unkanon_> xplat: yes you are right, there's some amount of serialization necessary there to make the header types work
14:04:08 <unkanon_> amongst differing versions
14:04:18 <ezyang> jmcarthur: Yeah, though it's a real screen underneath so it's easy to see what you're drawing. 
14:04:30 <jmcarthur> is it one of those nice cintiq ones?
14:04:33 <jmcarthur> or just a tablet pc?
14:04:39 <ezyang> latter 
14:04:46 <jmcarthur> ah, i was about to get jealous :)
14:04:54 <quicksilver> unkanon_, xplat : serialisation approaches prevent you having libraries which work (cooperatively) on efficient non-standard types like Bool Vectors
14:05:01 <eugenn> @pt filter (not . condicion)
14:05:01 <lambdabot> Maybe you meant: ft pl
14:05:17 <unkanon_> quicksilver: that observation is a bit above my head
14:05:28 <quicksilver> "serialisation is not free"
14:05:39 <eugenn> @help point free
14:05:39 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:05:49 <xplat> Watermind: you can use Control.Arrow.(>>>) or Control.Category.(>>>) 
14:05:51 <revenantphx> Is there any way to use an Int, but "cap" it at Int32's max positive size?
14:06:05 <jmcarthur> revenantphx: why not just use Int32?
14:06:07 <revenantphx> IntMap is perfectly convenient, except I'm working with Int32's not Int
14:06:11 <jmcarthur> ah
14:06:15 <revenantphx> Because then I have to use fromIntegral every single time
14:06:18 <Watermind> xplat: good point
14:06:22 <Watermind> xplat: thanks
14:06:42 <jmcarthur> revenantphx: hashmap supports Int32
14:07:08 <revenantphx> I suppose when it "hashes" an Int32... it's really just fromIntegral'ing it tho
14:07:10 <jmcarthur> revenantphx: it just uses fromIntegral under the hood
14:07:12 <eugenn> @pl filter(not. condicion)
14:07:12 <lambdabot> filter (not . condicion)
14:07:13 <jmcarthur> yeah
14:07:42 <eugenn> @pl reject condicion = filter(not . condicion)
14:07:43 <lambdabot> reject = filter . (not .)
14:07:46 <xplat> yes, serialization is cheaper in haskell since you don't have to serialize the parts you don't look at, but it's still a pretty expensive thing to do across every package boundary
14:09:08 <xplat> actually what i said is true more of arborization, serialization can create artificial strictness
14:11:14 <revenantphx> jmcarthur: alternatively I could have my read/write methods convert between Int and Int32, but I don't exactly like that.
14:11:28 <revenantphx> I mean, what happens is I use a value which Int can express, but Int32 cant
14:11:40 <revenantphx> (it'd take a while to get that high, but shit would break)
14:11:52 <benmachine> revenantphx: why not just use Map Int32 a?
14:12:46 <revenantphx> IntMap, because of the restrictions on keys, provides better run time.
14:13:01 <benmachine> sure but do you actually need that extra speed?
14:13:11 <tromp_> :t count
14:13:12 <lambdabot> Not in scope: `count'
14:13:17 <revenantphx> No, but it's easy enough, why not.
14:13:25 <benmachine> well except you're running into all this difficulty :P
14:13:26 <revenantphx> If EnumMap worked, this'd be even easier.
14:13:40 <revenantphx> enummap is totally out of date though >_>
14:13:45 <benmachine> I'd say just use the general Map
14:13:50 <benmachine> and worry about performance later
14:13:53 <jmcarthur> revenantphx: i don't see how you would accidentally get an Integer where you want an Int32 anyway
14:14:01 <revenantphx> Int, not Int32
14:14:09 <jmcarthur> or that
14:14:16 <jmcarthur> huh?
14:14:17 <revenantphx> i am assuming here that Int's size is implementation specific.
14:14:28 <revenantphx> So what if Int is a 64bit int under the hood.
14:14:29 <benmachine> revenantphx: according to the standard it can actually be less than 32 bits
14:14:31 <jmcarthur> well, it is, but i still don't see the point
14:14:35 <revenantphx> benmachine: there you go.
14:14:39 <benmachine> ...but that doesn't tend to ever happen
14:14:52 <jmcarthur> revenantphx: if you just use something like hashmap then that case can't hurt you anyway
14:14:54 <benmachine> revenantphx: in that case, IntMap might be straight up incapable of what you want :)
14:15:06 <jmcarthur> revenantphx: Map likewise
14:15:08 <benmachine> I think Map is awesome and everyone should hug it
14:15:14 <jmcarthur> Map is alright :)
14:15:15 <revenantphx> jmcarthur: except I have to send out those Ints to clients.
14:15:18 <revenantphx> And they expect Int32s.
14:15:25 <jmcarthur> revenantphx: then... use Int32?
14:15:28 <jmcarthur> i don't see the problem here
14:15:31 <jmc_fr> monochrom: would there be a walkaround with xml writing + reading - coping corectly with accents
14:15:33 <jmcarthur> revenantphx: hashmap supports Int32
14:15:44 <jmcarthur> so does Map
14:15:49 <revenantphx> I knw I know 
14:16:20 <jmcarthur> all your arguments are against IntMap. i don't think anybody is trying to convince you to use IntMap
14:16:27 <monochrom> I don't know of one.
14:16:39 <revenantphx> Not trying to argue against IntMap. I can use it if I want.
14:17:01 <revenantphx> I was just wondering if there was an equivalent which had the same performance and wouldn't require all the type conversion.
14:17:07 <monochrom> All xml libs I know of do utf-8 properly. I just don't know of tutorials.
14:17:08 <revenantphx> You mentioned Hashmap, great 
14:17:21 <jmcarthur> fromIntegral every once in a while won't hurt, i promise
14:17:46 <jmcarthur> or you could just use Map, which requires no conversion... but IntMap and HashMap would probably both be faster in this case if your that worried about it
14:17:50 <jmcarthur> *you're
14:18:06 <red_> Maps are a great, quick, array substitute
14:18:16 <revenantphx> I want to keep the data type consistent through the program first of all.
14:18:21 <jmcarthur> actually, they do more than arrays, red_ :)
14:18:25 <benmachine> revenantphx: abstract?
14:18:29 <revenantphx> I think HashMap will be fine.
14:18:41 <revenantphx> benmachine: it'd be nice, except I need to keep specific liits.
14:18:46 <red_> Well I know that :)
14:18:51 <jmc_fr> monochrom: OK, i'll try that - tks and good night
14:18:59 <revenantphx> All data types are of fixed sizes here.
14:19:02 <Eduard_Munteanu> Uh, this was mind-blowing to concoct.... I just made this doubly-linked list in Haskell, not really easy: http://codepad.org/5Onqw1Et
14:19:06 <Eduard_Munteanu> Any thoughts?
14:19:18 <jmcarthur> arrays are great for dense maps, but Map is also great for sparse ones :D
14:19:31 <revenantphx> One thing I am wondering
14:19:33 <ezyang> It almost looks like a zipper, but not quite. 
14:19:43 <Eduard_Munteanu> (yeah, before you say it, I might just use a zipper (I think it's still a zipper), but it was for experimental purposes)
14:19:44 <revenantphx> Do the haskell map types suffer much from clustering?
14:19:48 <jmcarthur> Eduard_Munteanu: the problem with that formulation of doubly linked lists is when you want to update it
14:19:48 <Eduard_Munteanu> Heh.
14:20:02 <jmcarthur> Eduard_Munteanu: updating it would require recreating the entire list. no sharing :\
14:20:14 <Eduard_Munteanu> Oh.
14:20:16 <jmcarthur> revenantphx: clustering?
14:20:48 <revenantphx> jmcarthur: some hashing algorithms have significantly worse performance from close-together keys in my experience.
14:20:55 <jmcarthur> Eduard_Munteanu: a good way to get around it is to use IntMaps to simulate pointers. then you can just reassign some pointers when you update it and all is well
14:20:58 <Eduard_Munteanu> So I guess there's no good algebrical way to define a doubly linked list.
14:21:03 <Eduard_Munteanu> (as in ADT)
14:21:21 <jmcarthur> revenantphx: Map isn't a hash table
14:21:26 <revenantphx> no, but Hash Map is.
14:21:31 <Eduard_Munteanu> jmcarthur: oh. I didn't actually look, but Seq might be something like that.
14:21:36 <jmcarthur> Eduard_Munteanu: nope
14:21:38 <revenantphx> My bad, I should have said hash map exclusively.
14:21:40 <jmcarthur> Eduard_Munteanu: Seq is a finger tree
14:21:56 <Eduard_Munteanu> My bad, not-a-list-at-all/
14:21:59 <jmcarthur> revenantphx: hashmap is actually an IntMap of Maps
14:22:12 <xplat> i've looked at Data.ByteString.Char8 and Data.ByteString.UTF8 and Codec.Binary.UTF8.String, i still see no nice function to turn a Data.ByteString.ByteString into a String in even one single encoding without stringing together like 4 functions
14:22:13 <revenantphx> Yeah, so I saw.
14:22:17 <jmcarthur> revenantphx: so instead of the O(n) worst case of a hash table, the worst case is still O(log n)
14:22:39 <jmcarthur> no matter how bad the hash function
14:22:56 <revenantphx> In any case, they all share a common interface.
14:23:01 <revenantphx> I can switch later if necessary.
14:23:04 <jmcarthur> revenantphx: also, if the has function is just converting Int32 to Int64, you won't get collisions
14:23:04 <Eduard_Munteanu> Now I suppose a binary tree with added backlinks (nodes to parents) is a killer to implement :)
14:23:08 <Eduard_Munteanu> Might as well use a zipper.
14:23:10 <jmcarthur> *hash
14:23:41 <jmcarthur> Eduard_Munteanu: incidentally i have spent quite some time recently trying to do exactly that with IORefs
14:23:44 <jmcarthur> god it sucks
14:23:52 <xplat> the assumption seems to be that you use a D.BS.Char8 for everything if you are dealing with latin1, a D.BS.UTF8 for everything if you are using UTF8, otherwise you have to pass through lists of Word8 or C strings or something
14:24:35 <jmcarthur> well, what sucks is that i'm also trying to do it with some purely functional constraints
14:24:47 <Eduard_Munteanu> I see.
14:24:52 <roconnor> Eduard_Munteanu: isn't it easy to make backlinks using data recursion?
14:25:00 <roconnor> for some definition of easy
14:25:23 <Eduard_Munteanu> roconnor: I suppose it's just like I did with lists, except you have two children instead of "one children".
14:25:44 <xplat> roconnor: you have to be careful if you want actual backlinks and not just things that evaluate equivalently
14:26:00 <Eduard_Munteanu> i.e. data Tree a = Nil | Cons (Tree a {- parent -}) a (Tree a) (Tree a)
14:26:02 <jmcarthur> roconnor: the problem is just that you can't really update a knot-tied data structure without breaking sharing
14:26:06 <ville> Seen today on a different channel: "16:02:31  #####> Haskell is the only language where strings are worse than in C++". - the author's identity is changed.
14:26:34 <Eduard_Munteanu> jmcarthur: actually the application that sparked this idea didn't require updating, so maybe I can actually use it.
14:26:55 <xplat> roconnor: and to avoid eagerly copying the tree every time you use them too
14:26:59 <jmcarthur> ville: i don't know about being the *only* language with that property, but the default string type in haskell *is* pretty bad, IMO
14:27:11 <jmcarthur> Eduard_Munteanu: ah, sounds ideal then :)
14:27:25 <xplat> also, the only use for backlinks vs zippers is that backlinks allow observable sharing
14:28:20 <Eduard_Munteanu> Does it? I mean in Haskell, I can't really tell if it shares just by looking at the code.
14:28:38 <jmcarthur> Eduard_Munteanu: what do you mean?
14:28:39 <Eduard_Munteanu> (with IORefs I suppose it does, but not the infinitely recursive stuff I used)
14:28:53 <jmcarthur> Eduard_Munteanu: if you use the same variable in more than one place, it's shared
14:28:58 <benmachine> ville: in fairness, alternatives aren't hard to come by
14:28:59 <jmcarthur> pretty simple rule, IMO
14:29:23 <tg_> jmcarthur: maybe he means mutable?
14:29:46 <jmcarthur> tg_: he just said he didn't need to be able to update it
14:29:52 <ville> Sure, just thought it was funny and apt for the current topic.
14:29:52 <Eduard_Munteanu> jmcarthur: ah, yeah, but I'm having troubles thinking that when you 'fix' something like that.
14:30:19 <Eduard_Munteanu> I guess it does.
14:30:57 <jmcarthur> Eduard_Munteanu: in fix (\f -> ...) you can be certain that f is not copied because that's just how it works :)
14:31:28 <xplat> my problem here is that what i'm doing is i hash some stuff, it produces a Data.ByteString.ByteString (semantically correct, Word8) and then i call a function to hex-encode it.
14:31:29 <mreh> how can I merge writers Writer w a and Writer w' b?
14:31:47 <mreh> like incorporate w' in w
14:31:49 <Eduard_Munteanu> jmcarthur: well is sharing part of, say, operational semantics, or is it "uhm, GHC tries its best"?
14:31:58 <xplat> the result of the hex function is semantically a character string but it is still returned as Data.ByteString.ByteString :(
14:32:24 <jmcarthur> Eduard_Munteanu: the former. it's not just an optimization
14:32:30 <benmachine> mreh: run one inside the other, I guess
14:32:35 <Eduard_Munteanu> Ah, I see.
14:32:46 <hpc> mreh: Writer (w, w') (a, b) perhaps?
14:33:02 <benmachine> yeah that's also a possibility
14:33:03 <Eduard_Munteanu> BTW, are Haskell's operational semantics written down somewhere? (Didn't look in the report yet)
14:33:09 <jmcarthur> Eduard_Munteanu: it's not something meant to be *observable* of course
14:33:21 <Eduard_Munteanu> Yeah.
14:33:25 <benmachine> what are non-operational semantics called?
14:33:30 <jmcarthur> Eduard_Munteanu: i don't think haskell has any particular operational semantics
14:33:44 <tg_> [17:29] <@tg_pc> namely the distributio
14:33:45 <tg_> [17:29] <@tg_pc> namely the distributio
14:33:51 <tg_> grr.
14:33:54 <jmcarthur> Eduard_Munteanu: but still, sharing is not just a ghc optimization, so you can be pretty sure about it
14:33:55 <mreh> :t mapWriter
14:33:55 <lambdabot> forall a w b w'. ((a, w) -> (b, w')) -> Writer w a -> Writer w' b
14:33:56 <xplat> and now i want to merge the hex printout into a string (actually, a Doc) without a voodoo incantation that converts to 5 different types on the way
14:33:58 <Eduard_Munteanu> benmachine: there isn't a non- there, there are denotational and axiomatic semantics as well
14:33:58 <tg_> benmachine: guessing, denoative?
14:34:05 <Eduard_Munteanu> jmcarthur: I see.
14:34:13 <benmachine> Eduard_Munteanu: k
14:34:29 <xplat> and preferably only requiring one extra module :I
14:34:49 <applicative> denotational? genuine?
14:35:20 <xplat> you would think you could convert a D.BS.BS to a D.BS.Char8.BS easily but it seems not ...
14:36:00 <Saizan> xplat: they are the same type.
14:36:03 <tromp_> what was the ghc flag for main in a non-Main module?
14:36:09 <Eduard_Munteanu> Interestingly this seems to say an eager Haskell wouldn't really work on some structures like this doubly-linked list.
14:36:19 <Saizan> tromp_: -main-is
14:36:23 <tromp_> thx
14:36:51 <tromp_> i had tried --main-is and failed:(
14:37:14 <benmachine> Eduard_Munteanu: wouldn't an eager haskell fail on infinite lists in general?
14:37:19 <xplat> Saizan: ah, that would explain the lack of a conversion function.
14:37:43 <Eduard_Munteanu> benmachine: yeah, but here the doubly-linked list equivalent of a finite list is infinite as well :)
14:38:00 <benmachine> sure
14:38:17 <Eduard_Munteanu> So unless they'd use some sort of lazy Z combinator, I can't tell how it would work.
14:39:28 <Cale> Eduard_Munteanu: Yeah. It's actually also been shown that there are problems for which the best possible solution in a pure eager language is asymptotically worse than the best possible solution in either a pure lazy language or an (eager) imperative language
14:39:48 <xplat> last time i got seriously into haskell bytestrings were not invented yet (!) so that's all kind of new to me
14:40:47 <Cale> tromp_: It's easier just to leave the module declarations off of all the files which contain main.
14:41:01 <Eduard_Munteanu> xplat: heh :)
14:41:14 <Cale> tromp_: (Making the module name Main by default)
14:41:39 <tromp_> doesn't that make it hard to import them?
14:41:51 <Cale> Well, yes, but they're the root of the import tree anyway.
14:42:13 <Cale> (you normally shouldn't have to import them)
14:42:44 <Eduard_Munteanu> Cale: hm interesting, but how does that work? I mean if that was true, I could embed Haskell code and a Haskell compiler in my imperative eager code and achieve the same asymptotic complexity.
14:42:52 <applicative> tromp_ call it arthur instead of main then make another module Main where main = arthur
14:42:52 <xplat> i guess another module could have a non-exported main ... or maybe Main could import its main from elsewhere?
14:43:10 <Eduard_Munteanu> Cale: unless there are some constraints on that.
14:43:19 <jmcarthur> Eduard_Munteanu: i'm not seeing anything controversial there...
14:43:29 <jmcarthur> or contradictory, rather
14:43:31 <Cale> Eduard_Munteanu: Um, imperative and pure lazy were the same for this example
14:43:44 <Cale> Eduard_Munteanu: It's pure strict which does worse
14:44:03 <Eduard_Munteanu> Oh, sorry, it probably makes sense then.
14:44:09 <Cale> The trick here is that lazy evaluation is like a kind of very restricted mutation.
14:44:14 <Eduard_Munteanu> I misread it, my bad.
14:44:22 <xplat> Eduard_Munteanu: and as it turns out a Haskell interpreter, or imperative language interpreter, will be slow if written in a pure eager language.
14:44:23 <jmcarthur> unobservable mutation :)
14:44:25 <sipa> thunks are once-mutable
14:44:29 <tromp_> i put a new version of my go code up at http://www.cwi.nl/~tromp/go/Go.hs
14:44:36 <sipa> in an unobservable way, indeed
14:45:08 <xplat> jmcarthur: it's one-sidedly unobservable.  you can observe that it happens, but you can't observe that it doesn't happen
14:45:20 <sipa> hmm?
14:45:34 <xplat> because you can only observe the difference by writing something that loops infinitely if it doesn't happen
14:45:43 <Cale> It is unclear whether or not it's always possible to acheive the same asymptotic complexity with a pure lazy evaluator as with an impure evaluator.
14:45:58 <jmcarthur> xplat: you can't tell the difference in haskell between a forced thunk and an unforced thunk
14:46:09 <dstcruz> is there a concatMap that works with monads?
14:46:14 <jmcarthur> xplat: and the act of forcing it is also unobservable because haskell is unaware of how long it takes
14:46:39 <dstcruz> something like :: (a -> m [b]) -> [a] -> m [b]
14:46:41 <xplat> jmcarthur: you can't tell the difference in the case of an individual thunk, but you can tell that there are unforced thunks somewhere by the fact that your program finishes
14:46:43 <Cale> In practical terms, there are cases where we don't seem to know how to do it, and it's often very hard to accomplish. However, it's easy to show that at worst, you take a logarithmic hit in complexity (you can always just use a Data.Map as a heap)
14:46:48 <Eduard_Munteanu> Hm, I just found other implementations of my lists online, but somehow I couldn't write it without fix :). I guess it's a useful abstraction at times.
14:46:50 <jmcarthur> xplat: *you* can. not haskell
14:46:50 <sipa> dstcruz: id ?
14:46:51 <Eduard_Munteanu> (they could)
14:47:15 <sipa> dstcruz: what you wrote is id
14:47:50 <Cale> sipa: note the [a]
14:47:57 <sipa> oh, sorry!
14:48:13 <dstcruz> Cale: thanks. I was trying to figure out how that was id.
14:48:14 * sipa shouldn't make code-related remarks after drinking
14:48:39 <xplat> jmcarthur: a haskell program (or parts of one) can observe that unforced thunks exist.  it can't observe that no unforced thunks exist, because in that case it doesn't observe anything at all.
14:48:46 <Cale> :t \f -> liftM concat . mapM f
14:48:46 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a1 -> m [a]) -> [a1] -> m [a]
14:49:30 <copumpkin> :t (fmap concat .) . Data.Traversable.traverseA
14:49:30 <lambdabot> Not in scope: `Data.Traversable.traverseA'
14:49:37 <copumpkin> :t (fmap concat .) . Data.Traversable.traverse
14:49:38 <lambdabot> forall a (f :: * -> *) a1. (Applicative f) => (a1 -> f [a]) -> [a1] -> f [a]
14:49:49 <dstcruz> w00t! thanks
14:50:10 <jmcarthur> xplat: how can haskell tell?
14:50:15 <copumpkin> :t (fmap join .) . mapM
14:50:16 <lambdabot> forall a (f :: * -> *) a1. (Functor f, Monad f) => (a1 -> f [a]) -> [a1] -> f [a]
14:50:56 <benmachine> isEvaluated x = x `seq` True
14:51:03 <jmcarthur> benmachine: lol
14:51:08 <cads> @hoogle Ix a => [a] -> [b] -> [b]
14:51:08 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
14:51:08 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
14:51:08 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
14:51:12 <benmachine> not my joke originally >_>
14:51:31 * dcoutts_ notes that there is an isBottom "function", but it cheats
14:51:36 <mikeg> Is there a builtin version of this function, or a similar monad1 -> monad2? f :: (Monad m) => [a] -> m a. f [] = fail "". f a:_ = return a
14:51:40 <xplat> oh, ha, isEvaluated is a different kind of one-sided observation
14:51:42 <jmcarthur> dcoutts_: yeah, that's not "haskell"
14:51:47 <dcoutts_> right
14:52:11 <cads> I'd like a function that extracts a list of indices from another list
14:52:12 <dcoutts_> it's meta haskell, useful for writing and testing strictness properties
14:53:06 <cads> I can do this:   extract indices list = map (list!!) indices
14:53:14 <benmachine> dcoutts_: it shouldn't be called isBottom though imo
14:53:19 <benmachine> should be called isError, or something
14:53:29 <xplat> > ((fix id :: String) >>= const "there was an unevaluated thunk somewhere") :: String
14:53:32 <lambdabot>   mueval-core: Time limit exceeded
14:53:42 <cads> > let extract indices list = map (list!!) indices in extract [1,3,5] [1..10]
14:53:43 <lambdabot>   [2,4,6]
14:53:45 <xplat> er
14:54:10 <magicman> Hrm. So I cabal install glade, and I get "gtk2hsC2Hs.exe: glade/glade.h: File does not exist".
14:54:10 <dcoutts_> benmachine: that doesn't express the intention however
14:54:14 <jmcarthur> that requires an argument, xplat 
14:54:20 <sipa> > isBottom (let x = x in x)
14:54:21 <UPPIN_JONES> shapr, Leksah is beautiful, but I am a bit bewildered by breakpoints. The seem to only work once.
14:54:21 <magicman> Now, my entire set-up on that windows machine is rather patchy <_<
14:54:22 <lambdabot>   Not in scope: `isBottom'
14:54:26 <xplat> const "there was an unevaluated thunk somewhere" (fix id :: String)
14:54:37 <xplat> > const "there was an unevaluated thunk somewhere" (fix id :: String)
14:54:38 <lambdabot>   "there was an unevaluated thunk somewhere"
14:54:40 <benmachine> dcoutts_: I thought the intention was to detect undefineds?
14:54:42 <magicman> So I'm wondering if it's something from the package I'm missing, or something in my setup?
14:55:06 <dcoutts_> benmachine: it's to specify properties about partial programs
14:55:08 <magicman> (patchy, as in: had to manually write pkg-config files and make some educated guesses at locations >_>)
14:55:11 <benmachine> but I guess undefined, though implemented in terms of error
14:55:13 <xplat> > const "there was an unevaluated thunk somewhere" $! (fix id :: String)
14:55:14 <copumpkin> what's a nice golfy way to get n-element combinations from a list? combs 2 ['a', 'b', 'c'] => [['a', 'b'], ['b', 'c'], ['c', 'a']]
14:55:16 <benmachine> is not an error necessarily
14:55:17 <lambdabot>   mueval-core: Time limit exceeded
14:55:42 <jmcarthur> > let foo = 5 in foo `seq` const "there was an unevaluated thunk somewhere" foo  -- xplat: counterexample! foo is actually evaluated, but it still reports that it was unevaluated
14:55:44 <lambdabot>   "there was an unevaluated thunk somewhere"
14:55:54 <dcoutts_> benmachine: obviously we can never do anything useful with non-termination
14:55:58 <magicman> > replicateM 2 "abc"
14:55:59 <lambdabot>   ["aa","ab","ac","ba","bb","bc","ca","cb","cc"]
14:56:07 <copumpkin> magicman: not the same
14:56:07 <magicman> Not quite, but getting there.
14:56:31 <copumpkin> > nubBy ((==) `on` sort) . replicateM 2 "abc"
14:56:32 <lambdabot>   Couldn't match expected type `[a]'
14:56:32 <lambdabot>         against inferred type `GHC.Types...
14:56:34 <benmachine> dcoutts_: I just feel like "isBottom" is conspicuously lying as a name
14:56:36 <dcoutts_> benmachine: but mathematically we can write strictness properties in terms of _|_ and many such properties can be tested using the approximation isBottom
14:56:38 <copumpkin> :t nubBy
14:56:39 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
14:56:48 <copumpkin> > nubBy ((==) `on` sort) . replicateM 2 $ "abc"
14:56:49 <lambdabot>   ["aa","ab","ac","bb","bc","cc"]
14:57:02 <jmcarthur> xplat: either way, just showing that something is evaluated doesn't mean you can tell that it ever *wasn't* evaluated
14:57:08 <magicman> I suppose if the input-list has non-unique elements, you want multiples to exist in the result as well?
14:57:09 <xplat> jmcarthur: that doesn't 'work' for the same reason that if 2 + 2 == 4 then "oh my god!  2 plus 2 is five!" else "everything is fine" doesn't work ... the condition doesn't match the English
14:57:20 <copumpkin> > filter (not null . drop 1 . group) . nubBy ((==) `on` sort) . replicateM 2 $ "abc"
14:57:21 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
14:57:21 <lambdabot>         against inferred type ...
14:57:23 <magicman> So if you had combs 2 "abca", "aa" *would* be a valid output-element?
14:57:40 <dcoutts_> benmachine: sure, but you have to be aware of that when you use it, so a more precise naming doesn't really help, it just makes the properties more ugly
14:57:50 <copumpkin> lambdabot's error output sure is fucking useless
14:58:05 <copumpkin> > filter (null . drop 1 . group) . nubBy ((==) `on` sort) . replicateM 2 $ "abc"
14:58:05 <lambdabot>   ["aa","bb","cc"]
14:58:11 <copumpkin> > filter (not . null . drop 1 . group) . nubBy ((==) `on` sort) . replicateM 2 $ "abc"
14:58:12 <lambdabot>   ["ab","ac","bc"]
14:58:36 <ddarius> copumpkin: Error messages are for the weak.
14:58:41 <copumpkin> damn right
14:59:15 <magicman> > filter (not . null . drop 1 . group) . nubBy ((==) `on` sort) . replicateM 2 $ "aba"
14:59:15 <lambdabot>   ["ab"]
14:59:25 <unkanon_> copumpkin: data.list has the subsequences function
14:59:33 <unkanon_> >subsequences ["abc"]
14:59:37 <unkanon_> > subsequences ["abc"]
14:59:37 <copumpkin> unkanon_: still not the right one
14:59:38 <lambdabot>   [[],["abc"]]
14:59:38 <jmcarthur> xplat: my claim is that in haskell you can't tell if a value is evaluated or not. forcing it still doesn't allow you to return a different result depending on whether it was originally evaluated or not
14:59:53 <unkanon_> > subsequences "abc"
14:59:54 <lambdabot>   ["","a","b","ab","c","ac","bc","abc"]
15:00:01 <unkanon_> now filter for length == 2
15:00:18 <magicman> Still won't have "ac".
15:00:23 <magicman> Wait, it will.
15:00:23 <jmcarthur> xplat: and _|_ doesn't count as a result for the same reason. you still have to observe it in order to act on it
15:00:24 <magicman> Woo!
15:00:24 <handonson> hmm... the original gtk has "expand" and "fill" arguments for box.pack_start, but haskell's boxPackStart lacks these arguments. i wonder what the equivalent is?
15:00:34 * magicman can't read, apparently :)
15:00:54 <ben> I knew this at one point.
15:00:56 <xplat> jmcarthur: when it comes to an individual value, i am not disputing that.  further, the observation that unevaluated thunks, in general, exist is epistemically weak because it is a distinction between true and bottom rather than true and false.
15:02:18 <ben> handonson: It gets rolled into the Packing argument with funny names
15:02:49 <jmcarthur> xplat: i'm not sure what you're disputing then
15:02:53 <ben> I think.
15:03:04 <unkanon_> > filter (\x -> length x == 2) $ subsequences "abc"
15:03:05 <lambdabot>   ["ab","ac","bc"]
15:03:11 <unkanon_> is that it?
15:03:13 <unkanon_> copumpkin: ?
15:03:18 <jmcarthur> xplat: if your point is just that the CPU gets hot when the runtime forces a thunk, sure
15:03:25 <copumpkin> unkanon_: looks like it might be
15:03:33 * hpc wishes for a subsequences that outputs as a tree
15:03:40 <copumpkin> it works if the elements are a set, I think
15:03:51 <copumpkin> but in my case they are
15:03:53 <copumpkin> so it's good :)
15:03:54 <handonson> ben: i supposed so too, but couldn't get Packing to do what i wanted
15:04:03 <unkanon_> copumpkin: cool, so I think that's the golfiest code
15:04:05 <unkanon_> where's my prize?
15:04:07 <unkanon_> :)
15:04:11 * copumpkin hands unkanon_ his package
15:04:22 <xplat> jmcarthur: my point is that haskell can 'tell' that it is lazy rather than eager because some expressions have values that wouldn't in an eager language
15:04:24 * djahandarie jumps in and steals it
15:04:25 <unkanon_> does that package have versioned dependencies? lol
15:04:29 <handonson> i've added two widgets with PackGrow and PackRepel to a VBox, but they still occupy the same space
15:05:03 <xplat> although if it were eager, it couldn't tell
15:05:08 <jmcarthur> xplat: conditional on the assumption that haskell can tell the difference between _|_ and not _|_
15:05:17 <ben> handonson: Did you look at how Packing translates into your bools? http://hackage.haskell.org/packages/archive/gtk/latest/doc/html/src/Graphics-UI-Gtk-General-Enums.html#fromPacking
15:05:20 <jmcarthur> (which it can't)
15:06:12 <handonson> ...
15:06:12 <xplat> jmcarthur: if you are lazy you can know you are lazy, but if you are eager you can know you are eager.  just like if you are dead you can't know that you're dead but if you're alive you can know you're alive.
15:06:14 <ben> err, with (expand, fill) = fromPacking packing
15:06:14 <Eduard_Munteanu> Seriously, could it be changed to tell that?
15:06:14 <mikeg> I think I'm looking for some form of the `lift` function, but I only see one in transformers, which doesn't work for, say: lift (return $ Just 4) :: Either String Int
15:06:18 <jmcarthur> xplat: the kind of observation you seem to be talking about relies on understanding the implementation of the value you're testing, which is also unobservable to haskell
15:06:39 <hpc> mikeg: what would be the type of the lift you want?
15:06:45 <jmcarthur> xplat: your argument seems to be philosophical, not semantic
15:06:48 <handonson> ben: wow, they're not named properly! PackNatrual does the repelling packing and PackRepel does the natural packing!
15:07:07 <Eduard_Munteanu> Some sort of lifting all Haskell values to Maybe, and doing undefined = some sort of Nothing. Then you could have a choice at doing total or non-total programming.
15:07:11 <handonson> this is awesome
15:07:13 <ben> I am kind of suspicious of language binding introducing concepts/names that are not used to map to language features
15:07:16 <unkanon_> PackNatrual indeed doesn't seem to be named properly  ;)
15:07:18 <xplat> jmcarthur: wow, that's the first time somebody tried to ding me for *not* arguing about semantics :)
15:07:28 <jmcarthur> ha
15:07:43 <handonson> ben: thanks a lot anyway. at least it tells me how i can fix this.
15:07:48 <mikeg> hpc: (Monad m, Monad m2) => m a -> m2 a, or just (Monad m) => [a] -> m a
15:08:05 <hpc> mikeg: not possible
15:08:13 <hpc> consider the case where m = IO
15:08:35 <copumpkin> isn't there a flatten :: Set (Set a) -> Set a ?
15:08:45 <copumpkin> if Set were a Monad instance, I could use join
15:08:46 <copumpkin> but :(
15:08:51 <xplat> jmcarthur: but this distinction, as weak as it is, does exist in both operational and denotational semantics
15:08:56 <jmcarthur> copumpkin: unions . toList?
15:08:58 <hpc> mikeg: a more useful answer would be "look at CoMonad"
15:09:00 <jmcarthur> or something like that
15:09:27 <mikeg> Hmm I saw Don's solution here http://stackoverflow.com/questions/3030767/haskell-maps-returning-a-monad, and thought `lift` was a builtin
15:09:56 <jmcarthur> xplat: yeah, it just can't be distinguished as a value. it requires observation "from the outside" in order to interpret what's going on
15:10:29 <Eduard_Munteanu> mikeg: that's for a very specific monad
15:10:45 <hpc> mikeg: lift :: MonadTrans t, Monad m => m a -> t m a
15:10:49 <Eduard_Munteanu> mikeg: but in general you can't / shouldn't pattern match on the constructor of a monad
15:11:02 <int80_h> ghc complains of not being able to find data,list,split. What environmental variable\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf could I give it to tell it where to find that?
15:11:10 <copumpkin> jmcarthur: that works, thanks
15:11:21 <Eduard_Munteanu> For Maybe, it's okay.
15:11:30 <Eduard_Munteanu> But not for IO like it has been said.
15:11:33 <mikeg> Yeah, I wrote a version for [a] -> m a, but I was hoping a more generic version was available.
15:12:04 <xplat> jmcarthur: it can be observed from the inside as well in a fashion, it's sort of like if quantum suicide works you can prove it to yourself but not to anybody else
15:12:21 <monochrom> > text "\x25cf"
15:12:22 <lambdabot>   ●
15:12:39 <mikeg> looks like MonadPlus may have a nicer solution, per claus's comment on that link
15:12:42 <xplat> (and if it doesn't work, you'll never know!)
15:13:07 <monochrom> int80_h: http://hackage.haskell.org/package/split
15:13:16 <ville> http://hpaste.org/42172/x -- "src/Main.hs:13:10: The last statement in a 'do' construct must be an expression", I can't seem to figure out what mistake I've made.
15:13:46 <Eduard_Munteanu> xplat: I suppose you could use a camera or something, and quantum kill that. But it would only constitute proof in a minority of universes :)
15:13:57 <int80_h> monochrom: bah. I thought it was in base. no wonder it couldn't be found
15:14:41 <Eduard_Munteanu> (although not indefinitely, next time you could kill it for good in your universe)
15:14:51 <monochrom> ville: merely alignment
15:15:06 <tromp_> @src subsequences
15:15:07 <lambdabot> Source not found. There are some things that I just don't know.
15:15:23 <aristid> ville: wrong indentation
15:15:42 <Eduard_Munteanu> @faq Can Haskell help you commit quantum suicide?
15:15:43 <lambdabot> The answer is: Yes! Haskell can do that.
15:15:53 <aristid> ville: the putStrLn must be in the same column as the xs <-, i think
15:15:56 <monochrom> git commit quantum suicide
15:16:05 <Eduard_Munteanu> Heh.
15:16:10 * monochrom just learned the git tutorial
15:16:28 <ville> monochrom, aristid: Ok, thanks.
15:16:31 <xplat> git can commit anything!  git slices bread AND waxes surfboards!
15:16:48 <int80_h> but does git come in cornflower blue?
15:16:54 <monochrom> sudo git make sandwich
15:16:58 <Eduard_Munteanu> Nice, it's not that difficult, monochrom. It used to be less friendlier though.
15:17:20 <int80_h> we can't adopt git unless the icons are cornflower blue
15:17:44 <xplat> git will let you branch your own cornflower blue icons
15:18:17 <xplat> and you can merge in the changes in the upstream icons
15:18:37 <xplat> (actually, that might really work, if they are svg)
15:18:43 <int80_h> git is all that, and a bag of chips!
15:19:18 <lispy1> xplat: how do I commit an empty directory in git?
15:19:37 <int80_h> that is sooo zen.
15:20:25 <Eduard_Munteanu> IIRC, you couldn't.
15:20:44 <lispy1> Yeah, I asked because: xplat: git can commit anything!  git slices bread AND waxes surfboards!
15:20:59 <Eduard_Munteanu> I suppose you can mkdir foo; touch foo/.keep_this; git add foo/.keep_this   and commit
15:21:00 <xplat> foolish mortals, an empty directory isn't 'anything', it's 'nothing'!
15:21:00 <lispy1> But, I'm pretty sure "empty directory" is not in the set of things git can commit
15:21:09 <ddarius> int80_h: Every icon in git is cornflower blue.
15:22:45 <xplat> actually i'm not sure why you wouldn't be able to commit an empty directory in git any less than you could commit an empty file ...
15:23:15 <c_wraith> xplat: because git doesn't track directories except as paths to files.
15:23:23 <c_wraith> not a very good reason, but it is why
15:24:13 <xplat> hm, i thought git aggregated files into trees and then committed a top tree, not just directly into commits
15:24:40 <Gracenotes> which abstract machine did Miranda use for evaluation?
15:24:53 <Gracenotes> ..was it SK? considering Turner wrote it
15:26:00 <Gracenotes> er yeah, history of haskell paper says so
15:27:03 <Gracenotes> so probably interpreter-speed performance
15:27:15 <JeroenDL> Anyone here use TextMate for haskell ?
15:29:57 <ddarius> Gracenotes: It compiles via combinators (not [just] SK).  I doubt that has changed.
15:30:18 <ddarius> Gracenotes: Compiling via combinators isn't slow.
15:30:50 <Gracenotes> ddarius: you mean C, B, etc.?
15:31:05 <Gracenotes> and a handful of other efficient shortcuts
15:31:25 <dolio> Could mean supercombinators.
15:31:48 <UPPIN_JONES> JeroenDL, not presently, but I'm looking for good IDE.  Do you like TextMate?
15:31:58 <Eduard_Munteanu> I wonder if such combinators are useful for a concrete machine instruction set.
15:32:00 <JeroenDL> I like it 'cause its pretty basic
15:32:15 <JeroenDL> But the haskell bundle seems to be offline ... Thats why I'm looking for someone who has it
15:32:17 <ddarius> Gracenotes: There's a bit more than a handful.  There are things like S' and B' usw.
15:32:52 <Eduard_Munteanu> TextMate sounds like an editor, rather than an IDE.
15:33:03 <JeroenDL> Sorry, yeah, its not an IDE
15:33:12 <UPPIN_JONES> JeroenDL, ah, I can't help there. I've been trying emacs and leksah.
15:33:46 <Eduard_Munteanu> maybe Vim?
15:34:00 <Gracenotes> ddarius: though... interpreted to some extent
15:34:02 <Eduard_Munteanu> (not sure how much of an IDE emacs is)
15:34:02 <hpc> vim is pretty great for haskell
15:34:05 <dschoepe> UPPIN_JONES: there's also a Haskell plugin for eclipse if you like your memory-hungry and unwieldy :)
15:34:10 <dschoepe> *your IDE
15:34:36 <UPPIN_JONES> dschoepe, hmm...that actually sounds quite appealing. I've seen good stuff done with Eclipse before.
15:34:42 <ddarius> Gracenotes: Why do you say that?
15:34:42 <Eduard_Munteanu> Yeah, I kinda don't fancy IDEs so I use Vim. :)
15:34:48 <UPPIN_JONES> :-)
15:35:13 <UPPIN_JONES> I appreciate vim, but I also like to be able to set breakpoints
15:35:36 <Gracenotes> ddarius: writing an essay, making a conceptual grouping of LML as a primary starting point of code generation for graph reduction. Things are always more black and white in essays..
15:35:53 <Eduard_Munteanu> UPPIN_JONES: when I write C code, I invoke gdb directly and break foo.c:1214
15:36:22 <Eduard_Munteanu> As for Haskell, I didn't debug much.
15:36:25 <dschoepe> UPPIN_JONES: using a debugger is somewhat less common in Haskell anyway, in my experience at least
15:36:34 <Gracenotes> i.e. compilation
15:37:04 <UPPIN_JONES> sdschoepe: very interesting. How does one develop a program then, if not by trying little pieces until they work?
15:37:14 <ddarius> Well, compilation via combinators isn't based on graph reduction.
15:37:21 <JeroenDL> You get it right the first time, or you don't and move on ... :D
15:37:28 <dschoepe> UPPIN_JONES: exactly like you said, you just don't try them with a debugger.
15:37:40 <UPPIN_JONES> with the interpreter then?
15:37:41 <dschoepe> instead you use a REPL, like ghci
15:37:45 <UPPIN_JONES> right
15:37:51 <UPPIN_JONES> I'm used to using an interpreter within emacs
15:37:55 <UPPIN_JONES> for example, with R
15:37:56 <Eduard_Munteanu> Yeah, using a debugger or stuff like that as first choice isn't a good idea.
15:38:04 <UPPIN_JONES> and then I can step through my script
15:38:05 <Gracenotes> ddarius: SASL was.. KRC was... it's really just the lazy stuff, no?
15:38:13 <UPPIN_JONES> by having each line in turn evaluated in the interpreter
15:38:19 <Eduard_Munteanu> Just review your code and try to spot the problems. Or avoid patterns that can introduce bugs.
15:38:31 <kmc> debugging is easy, just don't make any mistakes in the first place
15:38:31 <UPPIN_JONES> So far the emacs packages I've found, they only evaluate an entire buffer
15:38:32 <Gracenotes> or, I should say, stuff which has the potential to be lazy, or designed to be lazy
15:38:35 <UPPIN_JONES> :-)
15:38:39 <kadoban> UPPIN_JONES: i usually go with a pretty thorough test program built alongside whatever project i'm actually doing.  seems to save time overall
15:38:52 <Eduard_Munteanu> As for some easy debugging, you can use ghci to invoke your functions directly and see if they work.
15:39:03 <kadoban> so far i've mostly avoided haskell debugging...although at some point i should probably check how that's actually done
15:39:06 <UPPIN_JONES> and I'd like to be able to evaluate a single line
15:39:07 <monochrom> You could use ghci's debugger. Just generalize your idea of debug a little bit, i.e., expression-oriented not line-oriented.
15:39:22 <monochrom> and also expect lazy evaluation order
15:39:32 <UPPIN_JONES> right exactly my issue-- the ideal IDE would be able to pass a single expression to the interper, would it not?
15:39:41 <JeroenDL> If I have a function that prints out 1..   , how can I tell it to stop after 10 prints ?
15:39:55 <monochrom> take 10 [1..]
15:40:01 <kmc> print [1..10]
15:40:05 <hpc> > take 10 [1..]
15:40:06 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
15:40:10 <hpc> :t take
15:40:11 <lambdabot> forall a. Int -> [a] -> [a]
15:40:13 <JeroenDL> ok, bad example :p
15:40:25 <Eduard_Munteanu> Yeah :)
15:40:43 <UPPIN_JONES> let a = [1..]
15:40:44 <JeroenDL> I have a little program that starts with a number 'a', then does something with that number (fe *2) and then executes itself with the new number
15:40:45 <UPPIN_JONES> take 10 a
15:40:50 <JeroenDL> And it prints out the steps in between
15:40:55 <JeroenDL> but I want it to only print the first X steps
15:40:59 <Eduard_Munteanu> But then again, you can 'take' from 'show' output instead of printing.
15:41:14 <Eduard_Munteanu> *printing directly
15:41:34 <UPPIN_JONES> so my ideal editor would be able to parse the single next expression
15:41:46 <UPPIN_JONES> and pass it to ghci 
15:41:47 <magicman> > take 10 $ iterate (*2) 2
15:41:48 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024]
15:42:03 <parcs> @type mapM_ print
15:42:04 <lambdabot> forall a. (Show a) => [a] -> IO ()
15:42:08 <JeroenDL> I'm using print to display the output. No lists are involved
15:42:28 <Eduard_Munteanu> UPPIN_JONES: that's just like copy-pasting it, but usually you need to generate some input.
15:43:01 <UPPIN_JONES> the other odd thing seems to be that, at the interpreter, I have to put 'let' in front of expression, and that isn't necessary (for some reason?) in compiled code
15:43:08 <Gracenotes> in any case. all I'm going on is 20-year-old papers.. also SPJ's line from History of Haskell that "Although it is obvious in retrospect, we had become used to the idea that laziness meant graph reduction, and graph reduction meant interpretation."
15:43:10 <UPPIN_JONES> generate some input?
15:43:38 <Eduard_Munteanu> JeroenDL: let f x = ... in take 100 . show . f $ x
15:43:51 <UPPIN_JONES> like using, with gdb, set args < input_file
15:44:29 <UPPIN_JONES> does anyone know if you can talk to ghci over a socket?
15:44:30 <Eduard_Munteanu> JeroenDL: erm more like... let f x = ... in putStr . take 100 . show . f $ x
15:44:42 <JeroenDL> Eduard_Munteanu: example please ? http://pastebin.com/u88wTwGv
15:45:49 <Eduard_Munteanu> JeroenDL: that prints a single thing anyway.
15:46:10 <JeroenDL> Eduard_Munteanu: one item each time, but it goes on forever
15:46:30 <Eduard_Munteanu> Oh, supposing you use loop on inc
15:46:49 <JeroenDL> Eduard_Munteanu: yeah, should have made that more obvious: loop 0 inc
15:47:12 <cads> @hoogle [IO()] -> IO()
15:47:13 <lambdabot> System.Mem.Weak addFinalizer :: key -> IO () -> IO ()
15:47:13 <lambdabot> Control.Concurrent.MVar addMVarFinalizer :: MVar a -> IO () -> IO ()
15:47:13 <lambdabot> Foreign.Concurrent addForeignPtrFinalizer :: ForeignPtr a -> IO () -> IO ()
15:47:17 <Eduard_Munteanu> JeroenDL: you could redefine print to use an IORef for rate limiting.
15:47:34 <hpc> :t foldl2
15:47:35 <magicman> Or change "loop" to have a decreasing counter <_<
15:47:35 <lambdabot> Not in scope: `foldl2'
15:47:37 <cads> how do I compose a list of IO actions together into a concatenated output stream?
15:47:38 <Eduard_Munteanu> That should more or less just plug in
15:47:40 <hpc> :t foldr2
15:47:41 <lambdabot> Not in scope: `foldr2'
15:47:55 <JeroenDL> But theres no easy equivalent like take is for lists ?
15:47:56 <cads> > map print [1..5]
15:47:57 <lambdabot>   [<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>]
15:47:58 <Saizan> cads: sequence_
15:48:11 <hpc> :t sequence_
15:48:12 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
15:48:16 <Saizan> cads: sequence_ . map = mapM_
15:48:23 <Eduard_Munteanu> JeroenDL: if you redefine your functions to return a string, then yes, but otherwise I don't see how.
15:48:44 <cads> thanks saizan
15:49:37 <JeroenDL> ok, thx
15:49:50 <Eduard_Munteanu> Even with the IORef you still need to pass it around I guess.
15:50:12 <Eduard_Munteanu> Erm, not really, you can make it global.
15:50:21 <hpc> JeroenDL: once it gets to the output stream, it's gone
15:50:57 <bwq> hi
15:51:07 <bwq> i'm having a bit of problems getting a certain function to stop looping
15:51:32 <dschoepe> Eduard_Munteanu: but only with unsafePerformIO, right?
15:51:53 <bwq> i'm using a check function and if i get a check on the stuff i want, i run another function with the "found" argument set to 1
15:51:56 <hpc> :t coreturn
15:51:57 <lambdabot> Not in scope: `coreturn'
15:52:51 <bwq> thing is, i got an if/else in that second function
15:52:56 <Eduard_Munteanu> JeroenDL: you can do like printCount :: IORef Int; printCount = newIORef 10; print' :: String -> IO (); print' xs = do { c <- readIORef printCount; if (c > 0) then print xs else return (); writeIORef (c + 1) }
15:53:03 <bwq> and sure enough it enters the if for found == 1
15:53:07 <bwq> but it doesn't stop looping :/
15:53:21 <Eduard_Munteanu> dschoepe: ^   I'm assuming he only wants to do so in the IO monad.
15:53:52 <Eduard_Munteanu> um, writeIORef printCount (c + 1)
15:54:06 <dschoepe> Eduard_Munteanu: I meant your suggestion of making an IORef global. I've only seen that with unsafePerformIO. Your suggestion above would give printCount :: IO (IORef Int)
15:54:11 <Eduard_Munteanu> bah, s/+/-/
15:54:16 <JeroenDL> Eduard_Munteanu: wouldnt that continue printing empty strings ? Or doesnt haskell work that way ?
15:54:27 <JeroenDL> Or at least, continue running ?
15:54:28 <UPPIN_JONES> So somewhere perhaps there is a function one can call to tell if a piece of text can be parsed, does anyone know?
15:54:29 <Eduard_Munteanu> Oh right, that sucks.
15:54:40 <Eduard_Munteanu> You do need unsafePerformIO.
15:55:08 <dschoepe> and probably an NOINLINE-pragma
15:55:36 <Eduard_Munteanu> JeroenDL: no, why would it? It doesn't matter what print' returns, mind.
15:55:59 <JeroenDL> Eduard_Munteanu: since it doesnt matter what print' returns, it will continue looping, right ?
15:56:13 <Eduard_Munteanu> Yes.
15:56:17 <JeroenDL> Eduard_Munteanu: ok
15:57:07 <hpc> whoa, since when were global IORefs a serious suggestion?
15:57:15 <hpc> *since when did
15:57:17 <Eduard_Munteanu> Although you could use 'fail' to stop it instead of doing that return.
15:57:23 <ezyang> Unfortunately, they have been for a while :-/ 
15:57:38 <hpc> :/
15:57:52 <ezyang> Clearly the world needs more template haskell. 
15:57:58 <Eduard_Munteanu> Reader is much better, this was just a "here's how to do it if you still want it".
15:57:59 <hpc> haha
15:58:36 <hpc> "are you using too many global IORefs? Template Haskell is the solution! Twice the problems, with just one easy installation!"
15:58:38 <bwq> so any idea why a function continues looping even after it shouldn't? it's like haskell doesn't remember what you did in the else if structure
15:59:09 <Eduard_Munteanu> bwq: paste?
15:59:21 <c_wraith> That template haskell library for converting globals to arguments is an amusing idea.
15:59:25 <Saizan> bwq: can you paste the code?
15:59:35 <c_wraith> I wish I could remember the name of it
15:59:35 <bwq> well, it's my last bit of homework, so i don't really want to code it since everything is finished
15:59:42 <bwq> i just need to get it to properly exit upon success :/
16:00:12 <Eduard_Munteanu> bwq: maybe just that function (assuming you correctly determined which function does it)?
16:00:16 <Saizan> even just the incriminated loop could suffice
16:00:35 <bwq> yeah, i'll paste that
16:00:40 <bwq> do i really need to paste on hpaste?
16:00:47 <Saizan> or try to reproduce the problem in isolation, which is a good strategy for testing
16:00:54 <Saizan> any pastebin is fine
16:00:56 <Eduard_Munteanu> Not necessarily.
16:01:17 * Eduard_Munteanu usually uses wgetpaste, which doesn't seem to support hpaste by default :(
16:02:16 <bwq> https://pastee.org/3kezf
16:02:18 <bwq> pass is hsk
16:02:25 <bwq> yeah, sorry for the names
16:02:28 <bwq> i changed it just to be sure
16:02:38 <djahandarie> Oooh, passworded
16:02:39 <bwq> so, "lube" is my loop function
16:02:41 <JeroenDL> lol :D
16:02:55 * djahandarie feels like he is looking at a confidential document
16:02:56 <bwq> it's a really basic guessing game
16:02:58 * monochrom boycotts this
16:03:05 <JeroenDL> bwq: dutch ?
16:03:07 * Zao wikileaks it.
16:03:10 <bwq> but i can't get the lube function to quit, and i don't know why :<
16:03:13 <bwq> yes jeroen
16:03:29 <bwq> 	   else if found == 1 then do
16:03:29 <bwq> 	       putStrLn "ok"
16:03:31 * djahandarie arrests Zao
16:03:33 <bwq> shouldn't that just stop the loop?
16:03:41 <bwq> because right below it
16:03:41 <bwq> else do
16:03:42 <bwq> 	     putStr "correct nr: "
16:03:42 <bwq> 	     putStrLn (show rnd)
16:03:43 <bwq> this does it
16:03:48 <Zao> broodje maxkaas counter = ...
16:04:06 <bwq> and i've already verified that it enters the "else if found == 1" part
16:04:27 <krey> o/, in eager lambda calculus, do ifthenelse-s behave differently from any other language? ie. both cases get evaluated?
16:04:43 <magicman> Probably something layout-related :-/
16:04:54 <Zao> Your indentation seems a bit uneven.
16:04:57 <Eduard_Munteanu> The indentation looks fragile.
16:04:58 <Saizan> if it gets to that branch it should just stop
16:05:21 <hpc> krey: they don't in lispy languages, i don't think
16:05:31 <monochrom> perhaps someone calls lube again and again.
16:05:53 <Eduard_Munteanu> krey: at least in TAPL's, I don't think so.
16:06:24 <krey> Eduard_Munteanu: i'm reading TAPL atm!!!
16:06:31 <bwq> but if it's the identation, why does the else work?
16:06:41 <Saizan> it's not the indentation
16:06:41 <bwq> indented in the same way :/
16:07:02 <krey> Eduard_Munteanu: so if the evaluation is strict, the arguments should be evaluated before anything happens
16:07:10 <krey> Eduard_Munteanu: right?
16:07:10 <Saizan> and there's no way it'll continue to loop when found == 1
16:07:19 <Eduard_Munteanu> krey: aren't there a couple of E-IfThenElse rules that do just hat?
16:07:21 <Eduard_Munteanu> *that
16:07:22 <Saizan> the problem must be somewhere else, probably a caller of lube
16:07:31 <Eduard_Munteanu> krey: no
16:07:45 <bwq> hmm wait
16:07:47 <bwq> these 2 lines
16:07:47 <dibblego> the cabal manual mentions that some fields have a "freeform" format, but I can find no description of what this means
16:07:47 <bwq> ck x' rnd
16:07:48 <bwq> 	      lube x' f rnd maxkans tmpcounter found
16:07:57 <Eduard_Munteanu> krey: the condition *is* evaluated, but only one branch is, IIRC
16:07:57 <bwq> ck calls on lube
16:08:04 <bwq> and right after that, lube gets called again
16:08:08 <bwq> think that might be the prob?
16:08:38 <monochrom> of course
16:08:53 <krey> Eduard_Munteanu: but why? doesn't that break eager evaluation?
16:08:59 <bwq> is there a better way to solve this problem without having to resort to using an extra variable?
16:09:20 <bwq> i don't really want to call the "lube" function with that found variable to see if it should exit
16:09:30 <Eduard_Munteanu> krey: why would it? Most eager languages do that.
16:09:36 <dcoutts_> dibblego: so long as what you use is lexically still the same field, anything goes
16:10:02 <gaze__> how approachable is haskell's hindley-milner implementation?
16:10:06 <Saizan> bwq: quite probably, if only i could really grasp what the code is trying to actually do :)
16:10:12 <gaze__> in comparison to typing haskell in haskell
16:10:12 <dibblego> dcoutts, yeah I saw a short description of "freeform", but I'm wondering about things like <url> and multi-line code example
16:10:25 <krey> Eduard_Munteanu: but in most eager languages, the if-then-else is a special control mechanism. in lambda calc it's just a term
16:10:45 <ddarius> gaze__: Haskell has many implementations.  Perhaps you meant "GHC", in which case the answer is probably not very approachable at all.
16:10:55 <dcoutts_> dibblego: ah, for the description, hackage interprets the description field using haddock markup, this is not prescribed by the Cabal spec however
16:11:00 <Eduard_Munteanu> krey: TAPL, page 34, top. Look at E-IfTrue and E-IfFalse
16:11:01 <gaze__> sorry yes, I mean GHC
16:11:06 <Eduard_Munteanu> and E-If.
16:11:24 <gaze__> doesn't sound like there are really any components of GHC that are all that approachable
16:11:44 <Eduard_Munteanu> krey: E-If says the condition always evaluates, while the other two evaluate the branches depending on the condition.
16:12:13 <krey> Eduard_Munteau: I has no page numbers, could you give me the section number?
16:12:32 <Eduard_Munteanu> krey: it's on the page where 3.5 starts.
16:12:39 <int80_h> rickrolled!
16:12:44 <int80_h> he gets me every time
16:12:45 <Eduard_Munteanu> (3.5 Evaluation)
16:12:49 <bwq> Saizan: well, it reads numbers
16:12:57 <dibblego> dcoutts_, so then I can use >>> or @ @ for multi-line code blocks/examples?
16:12:58 <bwq> at the start of the program, a random number is chosen
16:13:08 <krey> Eduard_Munteanu: yeah, but that's a completely different section!
16:13:11 <bwq> if the user's entry is smaller than that number, it'll say "larger"
16:13:12 <dcoutts_> dibblego: probably
16:13:17 <bwq> if it's larger, it'll say "smaller"
16:13:21 <dibblego> dcoutts_, ok cheers
16:13:21 <krey> Eduard_Munteanu: that's about arithmetical expressions
16:13:24 <bwq> and if it's an exact match, it'll say "gg"
16:13:29 <Eduard_Munteanu> Ok.
16:13:36 * Eduard_Munteanu looks at the untyped lambda calculus...
16:13:43 <bwq> now, the "lube" function keeps asking the user for input (a number)
16:13:57 <bwq> and then it checks it with the ck function to see if it's a proper number (larger, smaller, equal)
16:14:12 <bwq> but the problem is that i'm not sure how to stop looping once the number is equal
16:14:28 <Endiannes> Rawr. I'm tired of inserting countless parenthesis in haskell, is there a way to write "someFunction 2 / 2" without using parenthesis?
16:14:56 <dibblego> dcoutts_, is there any way to find these things out without having to upload to hackage?
16:15:16 <dcoutts_> dibblego: sadly not, because it's not something cabal enforces/interprets
16:15:16 <krey> Endiannes: someFunction 1?
16:15:27 <dibblego> dcoutts_, ok I'll give it a crack :)
16:15:31 <dcoutts_> dibblego: it's a reinterpretation that hackage uses, not something cabal specifies
16:15:35 <dibblego> right
16:15:53 <Endiannes> krey, I mean, keeping the division.
16:16:38 <krey> Endiannes: someFunction $ 2 / 2 ?
16:17:00 <Endiannes> > round $ 2 / 2
16:17:01 <lambdabot>   1
16:17:18 <Endiannes> Huh, why doesnt it work in my case o.o
16:17:40 <Endiannes> Oh damn... I figured it out, thanks.
16:18:01 <Eduard_Munteanu> krey: are you talking about 'test'?
16:18:12 <Eduard_Munteanu> test = \l m n -> l m n
16:18:15 <bwq> what i originally wanted to do was
16:18:21 <bwq> checked <- ck x
16:18:34 <bwq> that should work to get the int it returns, right?
16:18:36 <krey> Eduard_Munteanu: yep
16:19:29 <bwq> but the strange thing is that somehow, it doesn't keep a variable updated if it passed an "else if" structure
16:19:31 <bwq> like this:
16:19:33 <bwq> else do
16:19:34 <bwq> 	  let ret = 0
16:19:34 <bwq> 	  print "gg"
16:19:36 <hpc> Eduard_Munteanu: test = id, doesn't it?
16:19:46 <Eduard_Munteanu> krey: hm, that indeed seems to evaluate its arguments.
16:19:56 <bwq> it prints "gg", but when it still returns the original value of ret, which is 1
16:19:58 <Saizan> bwq: https://pastee.org/tcbgt <- try this
16:20:13 <Saizan> bwq: variables are not mutable cells in haskell
16:20:20 <Saizan> bwq: they don't get updated, ever.
16:20:38 <Saizan> bwq: you're merely shadowing there
16:20:51 <bwq> but if i do
16:20:53 <bwq> let ret = 1
16:20:56 <bwq> return ret
16:20:57 <bwq> that works fine :/
16:21:05 <Saizan> that defines ret
16:21:20 <krey> Eduard_Munteanu: thanks, that's the confirmation I was looking for
16:21:23 <c_wraith> bwq: that uses the shadowed version of the name
16:21:24 <Eduard_Munteanu> krey: but I think they then inherit the if-then-else from the booleans part in the following chapters/sections.
16:21:32 <dibblego> dcoutts_, didn't work :( the idea that you need to "train for scala" is as fallacious as hav
16:21:33 <dibblego> oops
16:21:36 <c_wraith> bwq: these are standard scoping rules, the same as most languages
16:21:41 <dibblego> dcoutts_, didn't work http://hackage.haskell.org/package/Javav
16:21:43 <Eduard_Munteanu> hpc: hm, I don't think so.
16:21:56 <Saizan> bwq: redefining let in a branch of the if, doesn't touch the ret defined in the outer scope
16:22:09 <Saizan> bwq: i meant ret, not let
16:22:27 * hackagebot Javav 0.0.2 - A utility to print the target version of Java class files.  http://hackage.haskell.org/package/Javav-0.0.2 (TonyMorris)
16:22:30 <bwq> yup
16:22:40 <hpc> Eduard_Munteanu: test = \l m n -> l m n = \l m -> l m = \l -> l = id
16:22:59 <krey> hpc:eta-reduction!
16:23:05 <bwq> thanks for your solution, although we haven't seen some of that stuff :p
16:23:17 <bwq> so hmm
16:23:23 <Saizan> bwq: if you want to return a different value in different branches of an if/then/else you just have to do so from there
16:23:26 <bwq> there is really no way to return, say, 0 if it's been found?
16:23:28 <ddarius> Eta-reduction is a lie.
16:23:32 <bwq> yeah, but that didn't work :/
16:23:35 <Saizan> s/there/within them/
16:23:51 <c_wraith> bwq: don't try to mutate anything, just return the value for that case.
16:23:58 <Saizan> bwq: yeah, just return 0 from the branch where it's found
16:24:07 <Saizan> bwq: and remove the return at the end
16:24:23 <Saizan> bwq: return doesn't shortcut like in imperative languages
16:24:30 <dcoutts_> dibblego: mm, not obvious to me why not
16:24:46 <bwq> hmm k
16:24:48 <bwq> No instance for (Num ())
16:24:48 <bwq>   arising from the literal `0'
16:24:51 <bwq> i'm getting this now
16:24:59 <Eduard_Munteanu> hpc: hm it might work untyped. Like 'test tru a b' would be 'id tru a b' = 'id (tru a b)' = 'id a' = 'a'. Oh, yeah.
16:25:11 <bwq> else do
16:25:12 <bwq> 	  return 0
16:25:12 <bwq> 	  print "gg"
16:25:16 <bwq> wasn't this what you guys meant?
16:25:21 <Saizan> you've to change the type
16:25:22 <bwq> other way around btw
16:25:35 <Saizan> and also nom return 0 must go last
16:25:44 <dcoutts_> dibblego: it's clearly not sensible that hackage interprets it this way but that it's not enforced by anything else
16:25:59 <c_wraith> That error message means "0 a Num, and there's no way to unify () and the Num constraint!", by the way
16:26:18 <dibblego> dcoutts_, ok, not sure if it's worth pursuing
16:26:22 <dcoutts_> dibblego: oh, actually I think we do the same thing for hadock docs, so you could test it that way
16:26:39 <hpc> c_wraith: "but they look the same!"
16:26:40 <dcoutts_> dibblego: we use it for the prelude or whatever haddock calls it
16:26:45 <hpc> :P
16:27:02 <dcoutts_> dibblego: so perhaps cabal really should enforce it :-)
16:27:03 * c_wraith writes a Num instance for ().
16:27:08 <c_wraith> everythign is solved now!
16:27:26 <dcoutts_> dibblego: we didn't think about the markup when we originally started using it, we were only thinking of plain text
16:27:29 * hackagebot Ranged-sets 0.3.0 - Ranged sets for Haskell  http://hackage.haskell.org/package/Ranged-sets-0.3.0 (PaulJohnson)
16:27:29 <dibblego> dcoutts_, are you saying it's a bug or that I can work around it?
16:27:31 <Eduard_Munteanu> What's a good intro to denotational (or even axiomatic) semantics?
16:27:39 <dibblego> dcoutts_, fair enough, I'll just carry on without it
16:27:39 <bwq> return (0 :: Num)
16:27:44 <bwq> what's wrong with this?
16:27:46 <dcoutts_> dibblego: no, I'm saying you can test it locally by using cabal haddock
16:27:51 <dibblego> bwq, Num is a type-class not a data type
16:27:53 <hpc> bwq: v
16:27:55 <hpc> :t 0
16:27:55 <lambdabot> forall t. (Num t) => t
16:28:00 <dibblego> dcoutts_, I can't, since it is an executable
16:28:14 <dcoutts_> dibblego: you can, there's a flag for it
16:28:32 <hpc> bwq: "return 0" is enough, as you don't gain specificity from your intended type signature
16:28:38 <Eduard_Munteanu> :t 0 :: Int
16:28:39 <lambdabot> Int
16:28:56 <hpc> any specificity you would gain is already gotten from the signature of the function calling "return 0" anyway
16:28:58 <dibblego> dcoutts_, oh that gave me a parse error before, so I figured it was not possible, but it was the cabal file
16:29:10 <bwq> return 0 doesn't work :/
16:29:30 <Eduard_Munteanu> Return doesn't alter flow.
16:29:32 <dcoutts_> dibblego: ok so you can check the haddock manual about the markup and play around with it until it works
16:29:40 <bwq> maybe because :: Int -> Int -> IO Int is my signature?
16:29:45 <dibblego> dcoutts_, yep thanks!
16:29:47 <bwq> and IO Int doesn't match with it?
16:29:50 <c_wraith> :t fmap `asTypeOf` second -- I like this.  It unifies two signatures with different typeclasses into one without them.
16:29:51 <lambdabot> forall a b d. (a -> b) -> (d, a) -> (d, b)
16:30:01 <Saizan> bwq: return 0 matches IO Int
16:30:01 <dibblego> dcoutts_, wait, dos haddock display the cabal description field?
16:30:22 <hpc> bwq: http://faidio.visuallycreated.com:8000//blog/view.cgi?id=4 <- learn how types are inferenced
16:30:52 <hpc> er, without that extra '/' in there
16:30:53 <Saizan> bwq: i think the problem is that in the other branches of the if you're not returning a number
16:30:55 <dcoutts_> dibblego: cabal passes the description to haddock as the "prologue"
16:31:00 <bwq> ok
16:31:10 <bwq> ah yeah Saizan, i'm not
16:31:18 <bwq> is that necessary then?
16:31:38 <Saizan> yes
16:31:43 <bwq> weird, it works now :/
16:31:59 <Saizan> ?type \b t f -> if b then t else f
16:31:59 <lambdabot> forall t. Bool -> t -> t -> t
16:32:02 <bwq> i figured because i had "return ret" after the ifs, it would work
16:32:04 <Saizan> the types must match
16:32:09 <bwq> ah i see
16:32:12 <bwq> ty
16:32:30 <Saizan> in haskell if/then/else is an expression
16:32:50 <Saizan> like the ternary operator .. ? .. : .. from C-like languages
16:32:53 <c_wraith> well.  the types of the then and else clauses must match
16:33:00 <dibblego> dcoutts_, I have no idea how that is rendered in the final documentation
16:33:03 <c_wraith> The part in the if clause always must be a boolean :)
16:33:33 <dibblego> dcoutts_, sorry mate, ignore me, doing too many things at once, sorry
16:33:36 <dcoutts_> dibblego: it goes in the contents page iirc
16:33:42 <dibblego> dcoutts_, yeah
16:34:23 <shachaf> > if if if True then True else False then True else False then True else False
16:34:24 <lambdabot>   True
16:34:25 <dibblego> dcoutts_, the problem is the > in @\n> abc\ndef@
16:34:27 <c_wraith> @hoogle concatMapM
16:34:27 <lambdabot> No results found
16:34:31 <dcoutts_> dibblego: if you get a moment, filing a cabal ticket about the fact that really we should properly specify, interpret and enforce that the description is in haddock markup format
16:34:56 <dcoutts_> dibblego: erm, filing a ticket about that would be a good idea
16:34:57 <dibblego> dcoutts_, ok, I will when I get a chance'
16:35:00 <dcoutts_> ta
16:35:10 * dcoutts_ goes back to writing about hylomorphisms
16:35:33 <hpc> shachaf: awesome
16:35:34 <Eduard_Munteanu> Hylos are now the best thing to blog about? :)
16:35:48 <Eduard_Munteanu> Monads were at some point.
16:36:13 <aWagner> Hello, is there a function like isInfixOf that returns indices and accepts a predicate?
16:36:37 <pumpkin> an O(n^2) version?
16:36:48 <Saizan> who's blogging about hylos?
16:37:05 * dcoutts_ is actually trying to quickly polish off the related work chapter of his thesis
16:37:07 <Twey> Hmm
16:37:10 <pumpkin> dcoutts_
16:37:15 <Eduard_Munteanu> Not specifically blogging, but dcoutts_ is "writing" about them.
16:37:27 <bwq> great, works awesome now
16:37:35 <bwq> ty guys, appreciate the insight
16:37:37 <pumpkin> dcoutts_: thesis blog!
16:37:39 <Eduard_Munteanu> I think edwardk had something on hylos on his blog.
16:38:04 <pumpkin> I'm sitting across from edwardk on the train :o
16:38:05 <dcoutts_> pumpkin: perhaps when I've submitted :-) I've also got a technical report on bytestring to publish
16:38:19 <Eduard_Munteanu> pumpkin: was that planned or randomly?
16:38:22 <bwq> ah, 1 final thing, didn't really find something that quick, but why can't you concatenate strings and ints?
16:38:24 <pumpkin> planned :P
16:38:31 <bwq> like "putStr "hfezfzef" ++ int
16:38:39 <sipa> use show
16:38:39 <pumpkin> bwq: because they are of different types?
16:38:48 <bwq> yeah, i used show
16:38:55 <bwq> but it only worked when i used it in front of the string :p
16:39:05 <sipa> "blabla" ++ show int
16:39:17 <shachaf> > findIndex isUpper "ab1Ce4" -- aWagner
16:39:17 <lambdabot>   Just 3
16:39:22 <sipa> > let int=5 in "blabla" ++ show int
16:39:23 <lambdabot>   "blabla5"
16:39:26 <shachaf> Er, I may have misread.
16:40:07 <bwq>  Couldn't match expected type `[a]' against inferred type `IO ()'
16:40:11 <bwq> i get this when i do that :<
16:40:11 <shachaf> You want a general substring search?
16:40:14 <sipa> bwq: show you code
16:40:18 <aWagner> yes
16:40:22 <sipa> your
16:40:28 <Saizan> bwq: you need parentheses around "hfezfzef" ++ show int
16:40:55 <Saizan> bwq: otherwise it parses as (putStr "hfezfzef") ++ show int
16:41:01 <bwq> ah yes indeed :)
16:41:02 <bwq> ty
16:41:14 <Eduard_Munteanu> or '$'
16:41:25 <Saizan> function application always binds tighter than operators
16:41:32 <Eduard_Munteanu> (I don't like Lispy code :) )
16:42:11 <dibblego> dcoutts_, http://hackage.haskell.org/package/Javav :)
16:42:20 <Twey> aWagner: \p -> findIndices id . map (or . map p . inits) . filter (not . null) . tails
16:42:33 * hackagebot Javav 0.0.3 - A utility to print the target version of Java class files.  http://hackage.haskell.org/package/Javav-0.0.3 (TonyMorris)
16:42:37 <sipa> Eduard_Munteanu: you mean like ((++) ((putStr) ("hfezfzef")) ((show) (int))) ? :)
16:42:42 <dcoutts_> dibblego: :-)
16:43:01 <Eduard_Munteanu> That's horrible :)
16:43:11 <Eduard_Munteanu> :unpl findIndices id . map (or . map p . inits) . filter (not . null) . tails
16:43:17 <Eduard_Munteanu> @unpl findIndices id . map (or . map p . inits) . filter (not . null) . tails
16:43:18 <lambdabot> (\ d -> findIndices (\ a -> a) (map (\ j -> or (map p (inits j))) (filter (\ t -> not (null t)) (tails d))))
16:43:29 <Eduard_Munteanu> @unpl \p -> findIndices id . map (or . map p . inits) . filter (not . null) . tails
16:43:29 <lambdabot> \ p d -> findIndices (\ a -> a) (map (\ j -> or (map p (inits j))) (filter (\ t -> not (null t)) (tails d)))
16:43:33 <monochrom> in lisp/scheme you write (++ (putStr "hfz") (show int))
16:43:38 <Eduard_Munteanu> Uh not any better.
16:44:05 <hpc> Eduard_Munteanu: @unpl isn't nearly as effective as @pl :P
16:44:13 <xplat> nono, he means ((++) putStr ((:) 'h' ((:) 'f' ((:) ...))))
16:44:23 <monochrom> haha
16:44:26 <Eduard_Munteanu> :))
16:44:57 <sipa> xplat: loi
16:49:07 <aWagner> Twey: I'm trying it out. Thanks so much.
16:49:35 <Twey> aWagner: The filter (not . null) is actually unnecessary, since or returns false for that anyway
16:49:51 <Twey> \p -> findIndices id . map (or . map p . inits) . tails
16:50:50 <Twey> (\p -> findIndices id . map (or . map p . inits) . tails) (== "cde") "abcdefg"
16:50:54 <Twey> > (\p -> findIndices id . map (or . map p . inits) . tails) (== "cde") "abcdefg"
16:50:54 <lambdabot>   [2]
16:51:00 <Twey> > (\p -> findIndices id . map (or . map p . inits) . tails) (== "cde") "abcdefgdefabc"
16:51:01 <lambdabot>   [2]
16:51:09 <Twey> > (\p -> findIndices id . map (or . map p . inits) . tails) (== "cde") "abcdefgcdefabc"
16:51:10 <lambdabot>   [2,7]
16:51:29 <Twey> A (start, end) pair might be more useful than just returning the start index, though
16:51:51 <aWagner> yes
16:55:04 <Twey> > let ranges p lst = [ (ix, ix + len) | (ix, (True, len)) <- filter (fst . snd) . map (zip [0 ..] . (or &&& length) . map p . inits) $ tails lst ] in ranges (== "cde") "abcdefgcdefabc"
16:55:05 <lambdabot>   Couldn't match expected type `(a, (GHC.Bool.Bool, b))'
16:55:05 <lambdabot>         against infe...
16:59:31 <Twey> \p lst -> [ (ix, ix + len) | (ix, [(True, len)]) <- zip [0 ..] . map (filter fst . map (p &&& length) . inits) $ tails lst ]
16:59:50 <Twey> > let ranges p lst = [ (ix, ix + len) | (ix, [(True, len)]) <- zip [0 ..] . map (filter fst . map (p &&& length) . inits) $ tails lst ] in ranges (== "cde") "abcdefgcdefabc"
16:59:51 <lambdabot>   [(2,5),(7,10)]
17:00:41 <Twey> aWagner: ^
17:02:05 <revenantphx> This just in, Haskell is only about monads, and OO is better than functional programming.
17:02:27 <revenantphx> Also, nano is better than vim and emacs.
17:02:32 <ddarius> OO has monads now.
17:02:37 <revenantphx> C#, I know :)
17:02:44 <revenantphx> (among others I guesS)
17:02:53 <revenantphx> I'm excited to use them in my internship work. I can see some applicable places.
17:03:01 <ddarius> Also Ed's recent work with Scala will have it soon having a better category-extras than Haskell.
17:03:02 <revenantphx> LINQ is just sugared monads no?
17:03:15 <ddarius> It's no more or less sugared than do-notation.
17:03:28 <revenantphx> Figured.
17:04:22 <monochrom> "We expect to ship ghc-7 in Fedora 15 which is scheduled for release in May 2011" hehehe
17:04:39 <aWagner> Twey: The == can be substituted with a matching function, p is the pattern and lst the text?
17:05:09 <Twey> p is a predicate, lst is a list
17:05:10 * ddarius needs to get nail growing stuff again.
17:05:28 <Twey> p can do pattern-matching, so long as it's of type [a] -> Bool
17:06:26 <Twey> @let ranges p lst = [ (ix, ix + len) | (ix, [(True, len)]) <- zip [0 ..] . map (filter fst . map (p &&& length) . inits) $ tails lst ]
17:06:27 <lambdabot>  Defined.
17:07:27 <Twey> > let f [a, b] = a > b; f _ = False in ranges f [1, 2, 3, 2, 1, 2]
17:07:28 <lambdabot>   [(2,4),(3,5)]
17:07:34 <monochrom> The proper sentence is "OOP is better than functional programming"
17:07:58 <Twey> > let f [a, b] = a < b; f _ = False in ranges f [1, 2, 3, 2, 1, 2]
17:07:59 <lambdabot>   [(0,2),(1,3),(4,6)]
17:08:28 <Twey> Bed-time for me.  'night.
17:08:52 <Eduard_Munteanu> o/ Twey
17:09:11 <aWagner> Twey: Goodnight
17:11:34 <cads> monochrom, it seems like oop is easier to diagram than fp
17:11:41 <handonson> Can't I set some RTS options' default values at compile time?
17:12:03 <cads> of course when we diagram fp we get commutative diagrams :)
17:12:05 <handonson> For example +RTS -N4 -RTS?
17:12:28 <kadoban> handonson: yes.  you have to create a very small C file
17:12:33 <handonson> ...
17:13:02 <jmcarthur> isn't there a way to do it as a compiler argument with ghc 7 now?
17:13:12 <jmcarthur> or is that only for certain RTS flags?
17:13:28 <kadoban> i dunno, that does seem like a cleaner solution though
17:13:43 <Veinor> man, the RTS argument-passing stuff is osme of my least favorite parts of haskell
17:13:47 <monochrom> you could diagram type classes
17:13:50 <kadoban> handonson: http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/runtime-control.html  4.15.8, for the old way. i dunno the new way if there is one
17:14:14 <monochrom> also those use case diagrams and state transition diagrams are universal.
17:14:27 <Eduard_Munteanu> handonson: simply link in a C file with a char ghc_rts_ops[]
17:14:34 <Eduard_Munteanu> on the GHC cmdline.
17:14:54 <Eduard_Munteanu> like char ghc_rts_opts[] = "-H64m"
17:15:12 * jmcarthur attempts computer suicide by running make -j50 in a ghc source checkout
17:15:55 * jmcarthur is now convinced that the BF scheduler for linux is capital-A Awesome
17:16:13 <Eduard_Munteanu> jmcarthur: that might actually be less hard on the CPU.
17:16:29 <jmcarthur> Eduard_Munteanu: either way, it's really hard on the scheduler
17:16:43 <Eduard_Munteanu> O(1) scheduling FTW :)
17:16:43 <jmcarthur> I/O can be more rough than raw CPU
17:17:01 <mee> BF?
17:17:22 <jmcarthur> mee: BrainFuck (unrelated to the brainfuck language though)
17:17:38 <mee> ah, ok
17:18:12 <Eduard_Munteanu> jmcarthur: yeah, and there's I/O scheduling as well.
17:19:23 <jmcarthur> it looks like the ghc build is maxing out at around 12 ghcs running at a time. yay for amdahl's law
17:19:43 <jmcarthur> oh, and i had to stop it due to memory constraints, but at least it wasn't the scheduler's fault :)
17:20:06 <Eduard_Munteanu> Heh.
17:20:20 <jmcarthur> probably something like the linux kernel would be a better test since gcc doesn't need so much memory
17:20:48 <jmcarthur> i'm very off topic, sorry
17:21:41 <Eduard_Munteanu> jmcarthur: it depends what you're after, CPU time or IO. If it's the former, you could spawn lotsa cpuburn (say burnP4) processes
17:22:12 <Eduard_Munteanu> (Nobody's saying anything else ATM anyway.)
17:22:37 <jmcarthur> well, i'm not after a CPU stress test. just a scheduler stress test (testing for latency)
17:22:54 <jmcarthur> user observable latency, that is
17:23:15 <Eduard_Munteanu> What about measurable? ;)
17:23:19 <Eduard_Munteanu> There was some tool for that.
17:23:41 <jmcarthur> burn processes seem to have particular characteristics unlike things i might normally have going in the background
17:23:46 <Eduard_Munteanu> schedtop IIRC.
17:24:03 <jmcarthur> eh whatever. i'm satisfied
17:25:09 <Eduard_Munteanu> These days I no longer have issues with building in the background and doing something remotely soft RT (like playing music, browsing etc.)
17:26:26 <jmcarthur> oh me either, really, but with the default scheduler there's still the occasional UI stutter (never things like music though)
17:27:15 <Eduard_Munteanu> Hm, that might be application-related. Like Firefox having a big stutter a few seconds after startup.
17:27:51 <jmcarthur> it often manifests when you have things like smoothscrolling :)
17:28:50 <Eduard_Munteanu> Ah, no, that's disabled. I guess it's the way they "solved" the startup times thingy :)
17:39:40 <darrint> With hamlet I'm using $(hamletFile "myfile.txt") and I get 'Exception when trying to run compile-time code: "%h2 Attractions' Anyone know the right way to do that?
17:41:31 <handonson> how do I Integer -> [Word8]?
17:44:40 <Eduard_Munteanu> handonson: maybe this helps if you want to serialize it, look at encode here: http://hackage.haskell.org/packages/archive/binary/0.4.1/doc/html/Data-Binary.html
17:46:38 <handonson> uhm... actually, i don't want to serialize it. I want to make a fixed length (Word8) key from an arbitrary length Integer
17:47:11 <Eduard_Munteanu> Oh.
17:47:28 <Eduard_Munteanu> > fromIntegral (1238129391273612973612835 :: Integer) :: Word8
17:47:29 <lambdabot>   35
17:47:52 <Eduard_Munteanu> > fromIntegral (1238129391273612973 :: Integer) :: Word8
17:47:53 <lambdabot>   173
17:47:54 <handonson> yeah that would work but i wanted to OR the Word8s I can get from an Integer
17:48:02 <handonson> i mean XOR
17:48:50 <handonson> err... no.
17:48:52 <Eduard_Munteanu> Ah. I'm not sure if it's already implemented.
17:50:04 <c_wraith> :t (.^.)
17:50:05 <lambdabot> Not in scope: `.^.'
17:50:56 <Eduard_Munteanu> Maybe look for a premade hash function or just do something like foldl' (yourXor) 0 . map (`mod 256`) . takeWhile (/= 0) . iterate (`div` 256)
17:50:58 <handonson> okay, what I wanted to do was to make a 32-byte-long ByteString out of a very large Integer
17:52:38 <handonson> i guess serialising and slicing the first 32 bytes would just work...? but i want to do the XOR so the result will be more random yet deterministic
17:52:56 <Eduard_Munteanu> handonson: you could use 'encode' and cut the resulting ByteString to 32 bytes, but I'm not sure whether you want some mixing in there with the rest of the ByteString.
17:53:29 <Eduard_Munteanu> handonson: I'd look on Hackage for some cheap hash function.
17:53:31 <handonson> afaik Integer is like a linked list of Int
17:53:47 <Eduard_Munteanu> @src Integer
17:53:47 <lambdabot> data Integer = S# Int#
17:53:47 <lambdabot>              | J# Int# ByteArray#
17:54:06 <handonson> so that it would contain arbitrarily large numbers
17:54:54 <handonson> what I want are the members of it, and I thought there should be a built-in function for that
17:58:08 <handonson> Can I have the new cool hackage haddock skin on my local cabal docs?
17:58:23 <dcoutts_> upgrade your haddock
17:58:55 <handonson> i did that immediately after the new skin came out... let me try again
17:59:27 <handonson> ...how do I upgrade it? cabal update && cabal install haddock?
17:59:37 <dcoutts_> @arr!
17:59:37 <lambdabot> Smartly me lass
18:03:38 <xplat> argh, my hashing iteratees are not strict enough
18:08:45 <darrint> Figured it out by the way. Hamlet does not like blank lines.
18:14:02 <ManateeLazyCat> @hoogle Language.Hi.Parser
18:14:03 <lambdabot> No results found
18:14:40 <ManateeLazyCat> @hoogle Language.Hi
18:14:40 <lambdabot> Language.Haskell.Syntax HsEThingAll :: HsQName -> HsExportSpec
18:14:41 <lambdabot> Language.Haskell.Syntax HsEThingWith :: HsQName -> [HsCName] -> HsExportSpec
18:14:41 <lambdabot> Language.Haskell.Syntax HsIThingAll :: HsName -> HsImportSpec
18:17:42 <ManateeLazyCat> Ah in plugins-1.0...
18:35:03 <xplat> hm, after i 'fixed' it it blew 8 megs of stack
18:35:48 <xplat> this does not count as progress
18:37:50 <Cale> xplat: What's going on?
18:37:55 <Cale> (What are you writing?)
18:38:09 <c_wraith> Today I learned what the T in STG machine means :)
18:39:01 <c_wraith> I also have thought back to videos of SimonM presentations I've seen, and have decided that ghc is no longer precisely an STG machine.
18:39:12 <c_wraith> There have been further optimizations made
18:39:15 <Cale> It's no longer tagless
18:39:30 <c_wraith> well, the closure representation is different
18:39:47 <dolio> It's tagless in the sort of tags that STG is tagless in, I think.
18:39:59 <dolio> But there are tags for other things.
18:40:06 <c_wraith> There are tags for data constructors.
18:40:12 <dolio> Right.
18:40:13 <Cale> Sort of... there's pointer tagging which does more than just tell you if the thing is evaluated or not.
18:40:25 <Philippa> they're hint-tags rather than 'required' tags, though
18:40:29 <Cale> yeah
18:40:41 <dolio> They're not tags telling you 'integer vs. pointer'.
18:40:46 <dolio> And suchlike.
18:40:49 <ddarius> The STG has grown back both an S and the Ts.
18:40:56 <c_wraith> Also, the implementation of GHC's closures changed in GHC 7
18:41:17 <c_wraith> Something to do with garbage collection and tibbe's bug reports :)
18:41:44 <dolio> I've never really understood what 'spine' refers to.
18:43:24 <Philippa> spine of the 'call tree'?
18:43:33 <Philippa> (or stack)
18:44:36 <Saizan> so the true spineless machine didn't have stack oveflows?
18:45:04 <ddarius> Spineful ones wouldn't.
18:45:38 <ddarius> Except that where memory is allocated from is somewhat orthogonal.
18:46:50 <Cale> I think one way to look at it is that you're searching for the outermost reducible subexpression, and normally unless the very top of the expression being evaluated is already reducible, you'd have to build up a "spine" of outer stuff that's not reducible yet.
18:47:50 <Cale> (as an actual graph structure)
18:49:09 <Saizan> ah, so spineless in the sense that the object language stack is implicit in the evaluation of the machine rather than represented as a data structure?
18:50:00 * Saizan should have read the papers in these years
18:50:17 <ddarius> Saizan: Yeah, I read these papers almost a decade ago.
18:50:20 <dolio> I'm pretty sure I've read the papers and I still don't know. So don't beat yourself up.
18:58:36 <xplat> Cale: right now i'm writing an iteratee to evaluate several hash functions (and maybe other things) at once
18:59:32 <xplat> it's for a database of metadata for files
18:59:37 <Cale> xplat: If it's not too huge, and you want to put it up on hpaste, I'll see if I can spot any obvious stack problems
19:02:27 <xplat> yay, just fixed one
19:02:58 <xplat> only two more custom hash functions to test, i'll let you know if i have problems with any of them
19:13:01 <NiggKilla> sup assholes
19:13:13 <YouMamma> NiggKilla: ? 
19:13:43 <NiggKilla> YouMamma: who asked you anything?
19:13:44 <adu> 폭발 means explosion
19:14:28 <YouMamma> NiggKilla: Go to hell, if you would not mind.
19:14:31 --- mode: ChanServ set +o jmcarthur
19:14:44 <NiggKilla> YouMamma: sure you mothefuckar
19:15:00 --- mode: jmcarthur set +q *!*@gateway/web/freenode/ip.190.244.124.219
19:15:03 --- mode: jmcarthur set -o jmcarthur
19:19:14 <xplat> duelling sockpuppets, how droll ...
19:30:11 <revenantphx> Out of curiosity... would there be any way for a C program to initiate a haskell instance, passing it one end of a pipe, or a few file handles?
19:30:29 <revenantphx> (If I have bootstrapping code in C, and want the main guts to be Haskell)
19:31:36 <monochrom> yes
19:31:57 <xplat> yay, all hash functions done, now just need the filetype detector
19:37:27 <ville> http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14 what does the term 'fresh identifier' mean?
19:38:07 <xplat> it means an identifier chosen to be different from all other identifiers visible at that scope
19:38:27 <xplat> so it doesn't shadow or capture anything
19:39:11 <ville> alright.
19:42:31 <xplat> it is generally also chosen not to equal any free variable of the enclosed scope, but that only comes up either in the case of errors or if the language infers declarations
19:42:35 * hackagebot http-enumerator 0.2.1.3 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.2.1.3 (MichaelSnoyman)
20:03:09 <tg_> holy christ
20:03:13 <tg_> that's quite a dependancy list
20:03:15 <copumpkin> ?
20:03:27 <tg_> http-enumerator
20:03:28 <RadicalED_> probin haskell
20:03:32 <RadicalED_> looks like Python
20:03:58 <Saizan> tg_: lots of or, actually
20:04:14 <tg_> Saizan: yeah yeah. the list is long nevertheless
20:05:00 <Saizan> ~12
20:05:22 * tg_ goes and hides in the corner
20:05:59 * Saizan wonders what the average is
20:06:11 <tg_> Saizan: perhaps I would be wiser to suggest that the format for that list needs revision
20:06:15 <tg_> because it's very daunting initially
20:06:47 <djahandarie> Oh nice, that's even longer than Agda's
20:07:03 * ddarius doesn't find it especially long.
20:07:46 * tg_ commits haskell seppuku
20:09:50 <Saizan> yeah, i don't like the formatting either
20:10:00 <jon_of_arc> tg_: so you don't die until you eat breakfast and force your stomach?
20:10:27 <tg_> jon_of_arc: do I not know what seppuku is?
20:10:31 <xplat> hahaha
20:10:44 <djahandarie> I have a version with a slightly better dependency list
20:10:55 <jon_of_arc> tg_: bad lazy evaluation joke.
20:11:16 <xplat> not a bad one!  best laugh i had all day ...
20:11:19 <djahandarie> tg_, http://althack.org/hackage/hackage4.png
20:11:25 <djahandarie> Though it's going to be flipped from that
20:11:41 <tg_> djahandarie: that's much, much, much sweller
20:11:59 <Saizan> djahandarie: would you get 4 colums in this case?
20:12:08 <djahandarie> Saizan, that's why it's going to be flipped
20:12:08 <tg_> Saizan: hopefully not
20:12:28 <djahandarie> The packages on one line, the under them the version numbers
20:12:32 <djahandarie> The lines would alternate
20:12:42 <tg_> djahandarie: it also seems to me that sorting alphabetically is (as usually) very arbitrary in this case
20:12:59 <djahandarie> Not quite as pretty-looking as that but it scales much better and is still nicer than what is currently there
20:13:00 <tg_> but I can't think of an easier way
20:13:12 <tg_> maybe by the density of version numbers supported?
20:13:25 <tg_> ie, ==4.1 is the smallest
20:13:31 <djahandarie> tg_, I can't think of any heuristic that wouldn't look random yet still be useful
20:13:49 <tg_> closed ranges next
20:13:52 <tg_> open ranges last
20:13:59 <ozataman> anybody know how to hide a specific package version while installing with cabal?
20:14:00 <ddarius> Not looking random would be a requirement for it to be useful.
20:14:05 <jmcarthur> http-enumerator only has 13 dependencies. i think i've started projects with more than that before
20:14:28 <djahandarie> ddarius, s/useful/include information/
20:14:30 <tg_> jmcarthur: :( I already withdrew my objection of having too many deps
20:14:44 <jmcarthur> ah i missed it
20:14:52 <ddarius> As at the language level, so at the package level.
20:15:03 <dcoutts_> ozataman: hiding does not apply when building things with cabal, what is the actual problem?
20:15:19 <ozataman> dcoutts_: I'm having trouble installing the formlets library
20:15:26 <ozataman> dcoutts_: My guess was that it is because of mtl-2
20:15:50 <tg_> djahandarie: what additional information (say, contextual information in cabal packages) could you imagine using to enhance that list)?
20:15:55 <tg_> a reason why you are using a dep?
20:16:00 <tg_> grouping deps by reason why?
20:16:00 <dcoutts_> ozataman: you can get cabal to pick different versions of dependencies using the --constraint='foo <= x.y' flag
20:16:14 <ozataman> dcoutts_: Thank you; let me try that
20:16:40 <ozataman> dcoutts_: that did it! thank you!!
20:16:41 <jon_of_arc> I think the main issue for the dependency lists for me is that specific dependencies required by all options are duplicated in every option-list
20:17:07 <djahandarie> tg_, it could be possible to group them by category
20:17:21 <dcoutts_> djahandarie: the 'or' approach is a failed experiment, we should do it the more normal way
20:17:22 <jon_of_arc> I found myself advancing one dependency, scanning down all four option lists, then repeating just to find where they differed
20:17:26 <djahandarie> tg_, except cabal uses tags, not categories... so things wouldn't be able to seperate like that anyways
20:17:35 <Saizan> jon_of_arc: yeah, the flatness impairs readability
20:17:45 <dcoutts_> djahandarie: it's something Ross originally tried to simplify the way deps were presented, but it's actually had the reverse effect
20:17:48 <tg_> djahandarie: well I'm proposing if you had ultimate control of cabal and could add anything you wanted
20:18:07 <djahandarie> tg_, that'd open a lot of avenues. ;)
20:18:13 <djahandarie> dcoutts_, what is the other/older version?
20:18:26 <dcoutts_> djahandarie: presenting them how there's done in a .cabal file
20:18:39 <dcoutts_> there's/they're
20:19:05 <tg_> djahandarie: i'm thinking of something similar to 'blame' in git
20:19:16 <tg_> where you could 'blame' the dep by saying why you used it (in plain english) :o
20:19:51 <djahandarie> dcoutts_, aren't there often if statements and such in the .cabal?
20:19:51 <dcoutts_> e.g. listing unconditional deps first, and conditional ones along with their condition
20:19:54 <tg_> on second thought, that's a stupid idea
20:20:07 <tg_> dcoutts: I think I suggested that
20:20:12 <tg_> though in not so few words
20:20:30 <dcoutts_> djahandarie: e.g. on gentoo they're presented like "foo (if flag_bar)"
20:20:48 <Saizan> maybe we could flatten nested ifs, by showing them with the conjunction of the conditions
20:21:05 <dcoutts_> if the condition turns out to be really complicated then there's no need to show all of it
20:21:33 <ddarius> Clearly we should be applying Boolean minimization.
20:21:34 <tg_> Saizan: that's a clear description
20:22:07 <dcoutts_> Saizan: it's more tricky if it appears in multiple branches
20:22:10 <dcoutts_> but yes
20:22:13 <tg_> for example, for agda, if there only exists one version of pretty
20:22:21 <dcoutts_> and like I said, you don't need to show all the conditionals
20:22:27 <dcoutts_> or rather not all the details
20:22:30 <tg_> you certainly don't want to specify it 4 times for each OR
20:23:22 <copumpkin> anyone have the Richard Bird pearl on finding celebrities?
20:23:29 <dcoutts_> djahandarie, Saizan: it's also relatively straightforward to simplify with partial info, like a particular OS/Arch combo or ghc/base version
20:23:29 <djahandarie> The logic in displaying this stuff seems to be getting complicated
20:23:46 <tg_> djahandarie: maybe display none of the versions until you ask for more?
20:25:14 <dcoutts_> and it'd probably be a good idea to separate out the "standard" from "non-standard" deps, e.g. haskell-platform deps
20:25:26 <dcoutts_> djahandarie: yep, it's something that'll need some coding
20:25:30 <tg_> dcoutts: that sounds arbitrary
20:25:48 <dcoutts_> tg_: not especially, it corresponds to what people want to know at first glance
20:25:51 <djahandarie> tg_, maybe in terms of packages, but it's useful
20:26:02 <djahandarie> "What else do I need to get once I already have HP?"
20:26:20 <djahandarie> Would be even more useful if it just told you what else you need on your system, but I don't think that's possible ;)
20:26:23 <tg_> djahandarie: it seems like the answer to that question requires local information?
20:26:35 <tg_> otherwise darcs will have to record the evolution of packages in HP
20:26:39 <dcoutts_> djahandarie: nope, not without you telling it what you've got already :-)
20:26:59 <tg_> djahandarie: I don't see why that's not possible, though
20:27:03 <tg_> and sounds damn useful
20:27:06 <djahandarie> dcoutts_, or a web browser plugin that interfaces with Cabal
20:27:08 <djahandarie> :P
20:27:12 <dcoutts_> tg_: hackage will know this because the haskell-platform will be on hackage :-)
20:27:26 <tg_> view webpage -> it lights up green where you have the deps installed
20:27:36 <tg_> yellow where they can be, red where there is dephell
20:31:27 <ManateeLazyCat> Have any option can make darcs skip scan ./dist directory when i do "darcs record -l"? I know i can change the rule of 'boring' file, but the patch change 'boring' can't push to server, i will do it again once i re-dwonload from server. So i want add some option in "darcs record -l" command. Thanks!
20:32:44 <tg_> dcoutts: how official is haskell-platform anyway?
20:32:47 * hackagebot manatee 0.1.4 - The Haskell/Gtk+ Integrated Live Environment  http://hackage.haskell.org/package/manatee-0.1.4 (AndyStewart)
20:32:50 <ManateeLazyCat> Sorry, forgot add the depend library (libvte-dev libvte-common) for manatee-terminal. Fix it now. :)
20:32:51 <Saizan> hackage 2.0: now with NP-complete color schemes!
20:33:07 <dcoutts_> tg_: how "official" do you want it? :-)
20:33:14 <tg_> Saizan: provably 4-color-ed
20:33:36 <tg_> dcoutts: did SPJ give a lecture on how awesome it is and how it's the next big thing?
20:34:10 <dcoutts_> tg_: no, dons and I gave SPJ and the rest of the Haskell Symposium that lecture :-)
20:36:18 <djahandarie> Well if all goes well I'll finish my finals next week and then finish this Hackage stuff asap.
20:36:38 <djahandarie> It's been sitting on my backburner for too long
20:36:43 <Veinor> that reminds me
20:36:47 <Veinor> i need to upload askitter
20:37:03 <djahandarie> Why isn't it called htwitter?
20:37:09 <Veinor> I dunno.
20:37:09 <djahandarie> Or hwitter
20:37:27 <Veinor> :P
20:37:27 <djahandarie> @free
20:37:27 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-23
20:37:30 <djahandarie> Damn
20:37:34 <djahandarie> Forget the command...
20:37:36 <djahandarie> @freename
20:37:36 <lambdabot> Hads
20:37:46 <Veinor> in any case, i e-mailed the maintainer of hs-twitter, which uses the Web.Twitter module
20:37:50 <Veinor> and didn't get a reply
20:37:59 <Veinor> so I feel fine taking over Web.Twitter as a module name
20:38:53 <Veinor> (since hs-twitter doesn't work anymore!)
20:52:43 <dibblego> I regularly find myself chance class C c where f :: a -> b to class C m s where f :: a -> m b
20:52:48 <dibblego> s/chance/changing
20:55:57 <dibblego> so I help run the Brisbane Functional Programming Group
20:56:29 <dibblego> recently we had in a speaker who made all sorts of claims, but standing out was "Pure Functional Programming is Unpractical"
20:56:36 <dibblego> my employer has recently approved a new project
20:56:44 <dibblego> to have our graphic designer create a t-shirt design
20:56:58 <dibblego> on one side will be a lower-case greek lambda with a red circle/cross through it
20:57:08 <dibblego> on the other will be "Pure Functional Programming is Unpractical"
20:57:15 <dibblego> I am taking t-shirt sizes, selling at cost
20:57:38 <NewUser> hello
20:57:47 <NewUser> I have a question 
20:57:59 <NewUser> is someone here?
20:58:06 <Veinor> yeah.
20:58:39 <NewUser> I have a question about a program that  i didi
20:58:43 <NewUser> veinor
20:59:04 <Veinor> what's the question?
21:00:48 <NewUser> Veinor: here you go http://pastebin.com/cN6GVa3b
21:01:44 <Veinor> hm
21:02:04 <djahandarie> NewUser, and what happens currently?
21:03:04 <NewUser> it runs it solve the 1dimension but I will like to print the the positions of the permutations
21:03:32 <djahandarie> Could you paste me the current output (on pastebin)?
21:04:24 <NewUser> here you go http://pastebin.com/5GuxdmGW
21:05:06 <djahandarie> So you want... pos 1 = [3,2,1]; pos 2 = [2,3,1]; pos 3 = [2,1,3,4,5]... etc?
21:05:13 <djahandarie> But with new lines instead of semi colons
21:05:32 <NewUser> no
21:06:26 <djahandarie> I'm not sure what you currently have gets transformed to what you want then
21:06:56 <NewUser> i need this http://pastebin.com/ctxTgqMb
21:07:48 <NewUser> djahandarie: I need this http://pastebin.com/ctxTgqMb
21:08:09 <djahandarie> Hold your horses, I'm reading
21:08:21 <NewUser> oh ok i am sorry
21:09:48 <ManateeLazyCat> tg_: Nice to talk with you, i need coding now, see you. :)
21:13:58 <ManateeLazyCat> tg_: Here have framework illustration, it will help you understand the framework of Manatee: http://www.flickr.com/photos/48809572@N02/5031811365/lightbox/
21:14:06 <ManateeLazyCat> tg_: I really need to go, bye.
21:15:58 <djahandarie> NewUser, well, I understand how your current code works now, but I still don't understand this concept of 'position'.
21:18:20 <djahandarie> Maybe I'm just too tired :P
21:18:23 <NewUser> djahandarie: I trying to do this Instead of trying all permuations, this version tries cell positions one-by-one.
21:23:04 <djahandarie> NewUser, I don't know. This seems to require some knowledge about the game which I don't have
21:23:28 <mtnviewmark> this is a reduced version of ken-ken, yes?
21:24:43 <NewUser> mtnviewmark: yes this is a 1D kenken
21:27:16 <crutcher> does anyone know if there's an upper size bound on the scatter/gather IO in sendMany?
21:27:29 <crutcher> like, total number of elments in the vector?
21:28:14 <kmc> what library?
21:29:46 <NewUser> djahandarie: basically I am trying to do  is given the permutations and the the positions, how can I write a function where positions have values of the permutations 
21:30:22 <NewUser> so if one position use a value, the ones after that can't use that value
21:30:39 <djahandarie> You may not find a solution like that though.
21:30:46 <mtnviewmark> NewUser: break the problem down - what is a "step" in your algorithm?
21:31:56 <mtnviewmark> this is a problem in constraint solving
21:32:11 <mtnviewmark> how are you going to find a solution (if one exists) to the constraints?
21:32:44 <NewUser> djahandarie and mtnviewmark: well basically the values must all distinct 
21:33:14 <djahandarie> I understand what you're trying to find now, but it's fairly complicated if you want to do it any other way than a naive brute force
21:33:21 <djahandarie> Did your teacher not cover this?
21:34:01 <NewUser> djahandarie: brute force  is ok, no he didn't
21:34:35 <mtnviewmark> so, brute force means: generate all the possible arrangements and check if the constraints hold
21:34:59 <djahandarie> mtnviewmark, actually rereading this it doesn't seem like he needs to solve the problem at all
21:35:00 <NewUser> mtnviewmark: yes 
21:35:41 <djahandarie> Just solve the problem for each position
21:36:00 <NewUser> well I am trying to modify what I have http://pastebin.com/ctxTgqMb to meet these extra positions
21:36:14 <NewUser> conditions *
21:36:26 <djahandarie> So position 1 is only limited by Cage 3 in that example
21:36:36 <djahandarie> While position 2 is limited by Cage 3 and Cage 4
21:37:02 <djahandarie> So basically go through each position, gather your constraints (like I just did) by filtering down your cages
21:37:03 <NewUser> djahandarie: yes
21:37:06 <mtnviewmark> I'm assuming here that the assignment is to write a general solver, yes? not just this one
21:37:36 <djahandarie> "Each position" meaning [1..gameSize ken]
21:37:59 <mtnviewmark> so - that is a different approach
21:38:47 <djahandarie> And then once you have all your constraints for that position, you just need to find a value that satisfies all those constraints (by whatever means, apparently)
21:39:08 <NewUser> yes
21:39:20 <djahandarie> So I outlined what you need to do. Where are you having a problem?
21:39:59 <NewUser> getting the positions permutations?
21:40:10 <iammisc> I have a parametized type Vec3 a (where a is the type of the elements of the vector). Eventually I want Vec4 and Vec2 as well. Now I want a class Vector which can group together operations on these types. However, since these types are parametized, some operations like dot product (which is defined in vector) need to know the parameter of this type, how would I supply this? If my class is Vector a, then I only have access to the typ
21:40:12 <iammisc> e of the vector but I need access to its type parameter
21:40:15 <mtnviewmark> approach 1) generate all premuatations, and check each to see if which satisfy the constraints
21:40:47 <mtnviewmark> appraoch 2) generate all possible allowed values for position 1 by the constraints, then for each of those generate all possibel values for position 2 allowed by the constaints.... etc....
21:41:02 <djahandarie> Right. He already has approach 1 done
21:41:05 <djahandarie> And is doing 2 now
21:41:23 <djahandarie> You just want the intersection of the different constraints on a single position
21:41:27 <mtnviewmark> approach 3) represent all possible values at all posisionts, iterate through the constraints narrowing it down repeatedly until no further changes are possible
21:42:04 <NewUser> djahandarie: yes thats what i need 
21:42:41 <tg_> hmm
21:42:45 <tg_> so 3 is 1 + 2?
21:43:06 <djahandarie> NewUser, so for position 2, you have cage 3 and cage 4. Cage 3 allows [1,2] in the second spot (spot 2). Cage 4 allows [1,4] in the first spot (spot 2).
21:43:10 <Axman6> > 1 + 2
21:43:11 <lambdabot>   3
21:43:18 <tg_> Axman6: QED!
21:43:24 <djahandarie> NewUser, the intersection of [1,2] and [1,4] is [1], which is indeed what you are suppose to have for position 2.
21:43:35 <NewUser> yes
21:43:48 <mtnviewmark> iammisc: something like:    class Vector a where { dotProduct :: Vector a -> Vector a -> a }
21:44:28 <djahandarie> NewUser, I'm trying probe your brain to see why you can't get to the answer, so replying "yes" doesn't always help. ;) It just makes me feel like I'm telling you stuff you already know.
21:44:28 <iammisc> How does that make sense? a is the type of the *vector* class, like Vec3, not the type parameter to Vec3 (which could be float, int, double, etc.)
21:44:50 <mtnviewmark> ah, so you've got a plan for how to do it, NewUser, excellent --- now -- what are your types? The types will tell the story
21:44:50 <iammisc> I want to have an instance (Num a) => Vector (Vec3 a) where 
21:45:06 <iammisc> but I don't know how to declare a class Vector (a b) where 
21:45:19 <iammisc> (In that declaration b would be the parameter I need)
21:45:21 <mtnviewmark> oh oh, sill me
21:45:56 <mtnviewmark> ianmisc:  class Vector v  where { dotProduct :: v a -> v a -> a }
21:46:00 <NewUser> djahandarie: sorry, my main issue is that if i need to write an extra function or i can use one that i already have
21:46:10 <iammisc> Ah ok, that makes more sense
21:46:14 <iammisc> Let me try that
21:46:28 <mtnviewmark> yes (I should really get some sleep)
21:46:30 <djahandarie> NewUser, it's just a single new function, but it will be using a lot of other functions you already have.
21:46:46 <mtnviewmark> (instead of trying to answer haskell questions while avoiding cleaning up a messy Makefile...)
21:46:58 <NewUser> djahandarie: oh ok
21:47:17 <djahandarie> NewUser, I don't see how that helps at all, really. :P
21:47:24 <NewUser> djahandarie: can i use the built-in intersect for that function
21:47:42 <djahandarie> NewUser, sure, for that part of it
21:48:08 <djahandarie> But you need to gather your cages first, and then for each cage gather the possible values for that position
21:48:36 <NewUser> djahandarie: how can i gather the cages?
21:49:20 <djahandarie> NewUser, the [Int] list in the Cage data type is a list of positions
21:49:56 <djahandarie> (The list of positions the Cage holds.)
21:50:16 <Mathnerd314> is there an Eq instance for Data.Dynamic somewhere?
21:50:16 <NewUser> this one rite data Cage   = Cage Int Op [Int]
21:50:25 <djahandarie> NewUser, I don't see any other. :)
21:50:30 <NewUser> oh ok
21:50:41 <NewUser> so it will be Cage Int correct
21:50:44 <djahandarie> NewUser, of course that is just the data decleration. The actual values are defined lower down
21:50:51 <djahandarie> No?
21:50:54 <NewUser> ok
21:51:10 <djahandarie> If I give you   Cafe 2 Add [1,2,3]   how do you get [1,2,3] out of it?
21:51:16 <djahandarie> Oops
21:51:20 <djahandarie> Cage 2 Add [1,2,3]
21:52:19 <djahandarie> Well NewUser I need to go to bed for class tomorrow. Sorry.
21:52:37 <djahandarie> But hopefully what I outlined above can help you, since now you have a couple of smaller problems to solve rather than one big one
21:52:40 <djahandarie> gl
21:52:48 <kmc> "Now you have two problems"
21:52:51 <djahandarie> ;)
21:52:58 <djahandarie> *smaller* problems :P
21:53:04 <NewUser> thank you
21:53:06 <NewUser> so much
21:58:37 <Zao> > let (Just foo) = Just 9001 in foo
21:58:38 <lambdabot>   9001
21:58:53 <Zao> > let x@Nothing = Just 9001 in x
21:58:54 <lambdabot>   *Exception: <interactive>:1:153-173: Irrefutable pattern failed for pattern...
21:58:58 <Zao> \o/
22:00:20 <Mathnerd314> can one write an Eq instance for Data.Dynamic? I just need something for "simple" types, e.g. toDyn (1 :: Integer) == toDyn (1 :: Integer)
22:00:59 <kmc> why are you using Dynamic?
22:02:39 <kmc> you can compare the TypeReps of two Dynamics.  you can't compare the values inside unless you have Eq for that type
22:02:40 <Mathnerd314> I'm writing an interpreter, and want an extensible way to embed Haskell types in directly
22:03:10 <kmc> i can imagine a compiler extension which lets you do typeclass lookup at runtime by TypeRep, but i don't know a clever way to emulate it
22:03:24 <kmc> ordinarily i'd first suggest using a plain algebraic variant type
22:03:26 <kmc> but you said "extensible"
22:03:58 <Mathnerd314> yeah; I'm tired of writing Char Char | Bool Bool | ...
22:04:00 <kmc> so i think maybe you should use an existential which includes Eq and whatever else
22:04:39 <kmc> data Val = forall a. (Eq a, Typeable a) => Val a
22:05:25 <kmc> without the Typeable constraint you can't compare two Vals as you've no way to interrelate their closed-over types 'a'
22:07:28 <Mathnerd314> so the Eq instance is something like (a == b) = Just a == (fromDynamic . toDyn) b ?
22:07:45 <kmc> for Val?
22:07:58 <kmc> yeah, something like that
22:08:42 <kmc> i might define:  unwrap2 :: (forall a. (Typeable a, Eq a) => (a -> a -> t)) -> Val -> Val -> Maybe t
22:08:46 <kmc> not really so useful if the context is just Eq
22:08:57 <kmc> because that function pretty much has to be (==) or (/=) or worse
22:09:10 <kmc> but maybe you end up with other classes in your existential
22:13:40 <iammisc> So I'm trying to create a new storable instance from my Vec3 data type. I have class Storable a => Storable (Vec3 a) where
22:14:16 <iammisc> However in my sizeOf definition, I've defined it as sizeOf _ = 3 * (sizeOf (undefined :: a)), but haskell complains of an "ambiguous type variable"
22:14:31 <iammisc> But how is it ambiguous, when I declared it storable in the instance declaration
22:14:40 <iammisc> Sorry that should be instance Storable a => Storable (Vec3 a)
22:14:52 <kmc> iammisc, because that 'a' isn't the same 'a' as the instance head
22:14:56 <kmc> type variables aren't scoped by default
22:15:03 <iammisc> :/
22:15:06 <Mathnerd314> kmc: probably not; I'll just keep the types around in some usable form (String/TypeRep) and use some more dynamic casting
22:15:15 <iammisc> How do I get haskell to do that?
22:15:22 <kmc> you don't in Haskell
22:15:23 <iammisc> I can't change the declaration of sizeOf
22:15:24 <kmc> but you can in GHC
22:15:32 <kmc> but i'm not sure how in an instance declaration
22:15:33 <iammisc> well that's what I'm using
22:15:45 <Eduard_Munteanu> Does this have any meaning, or is it just a placeholder? unsafeCoerce# = let x = x in x
22:15:59 <kmc> ?
22:16:00 <Eduard_Munteanu> Also, lazy, inline, seq are the same thing.
22:16:04 <iammisc> -XScopedTypeVariables
22:16:08 <iammisc> thanks kmc
22:16:11 <Cale> iammisc: {-# LANGUAGE ScopedTypeVariables #-}
22:16:14 <kmc> iammisc, sure, but you have to activate that by using the keyword "forall"
22:16:21 <kmc> does it automatically come into scope in instances?
22:16:25 <kmc> Eduard_Munteanu, where?
22:16:34 <Cale> Eduard_Munteanu: That would just be a placeholder
22:16:36 <kmc> Eduard_Munteanu, i think that's a placeholder of some sort
22:16:36 <Eduard_Munteanu> http://www.haskell.org/ghc//docs/latest/html/libraries/ghc-prim-0.2.0.0/src/GHC-Prim.html#unsafeCoerce%23
22:16:36 <iammisc> Ok I know how to use that, thank
22:16:41 <kmc> GHC.Prim has no Haskell source
22:16:52 <kmc> look at the top of the file Eduard_Munteanu :)
22:16:59 <Eduard_Munteanu> Oh, all of them are the same :)
22:17:09 <Eduard_Munteanu> Ah, I see.
22:18:05 <Cale> It is however possible to define unsafeCoerce in terms of unsafePerformIO
22:18:12 <Cale> (and IORef)
22:18:24 <Eduard_Munteanu> Yeah, I suppose passing something through FFI.
22:18:29 <kmc> not even
22:18:30 <Cale> Nope, not even :)
22:18:40 <Cale> Well, unless you consider unsafePerformIO to be FFI
22:18:40 <kmc> unsafePerformIO lets you make a polymorphic IORef
22:18:41 <Eduard_Munteanu> Or using pointers.
22:19:02 <Eduard_Munteanu> :t unsafePerformIO
22:19:02 <lambdabot> Not in scope: `unsafePerformIO'
22:19:05 <kmc> ref :: IORef a; ref = unsafePerformIO $ newIORef undefined
22:19:10 <Eduard_Munteanu> anyway... IO a -> a
22:19:10 <kmc> now you can put any type you like into "ref"
22:19:14 <kmc> and get out any other type you like
22:19:28 <kmc> it's a very subtle interaction between side effects and polymorphic type generalization
22:19:38 <Eduard_Munteanu> Oh, nice.
22:19:40 <kmc> which ML avoids by the "value restriction"
22:19:47 <Cale> unsafeCoerce x = unsafePerformIO (do writeIORef r x; readIORef r) where r = unsafePerformIO (newIORef undefined)
22:20:28 <Eduard_Munteanu> Yeah, since ref looks polymorphic to any caller even if a "value".
22:23:55 <Eduard_Munteanu> Are kinds # -> * permitted, like can you make some sort of data Boxed a = Box a and use it for some unboxed type? If not I suppose boxing must be monomorphic, right?
22:24:17 <Eduard_Munteanu> (and if not, I'm not sure why)
22:24:31 <bblum> is there a more concise version of 'List.replicate 1'?
22:24:35 <bblum> List.singleton doesn't exist
22:24:47 <Botje> return 1
22:24:54 <Eduard_Munteanu> or pure :)
22:24:55 <Cale> (:[])
22:24:55 <Botje> or whatever you wanted
22:25:02 <Cale> Robot monkey
22:25:10 <bblum> hm i guess
22:25:14 <Eduard_Munteanu> Yeah, that looks weird :)
22:25:22 <Cale> > map (:[]) [1..10]
22:25:22 <lambdabot>   [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10]]
22:26:15 <Cale> Or of course, if you know which element you're applying it to, you can just write [1] :P
22:26:39 <bblum> Cale: my specific use case is "singlething <- singleton <$> blah"
22:26:43 <bblum> with blah in the State monad
22:27:01 <bblum> i guess i could sequence [blah]
22:27:02 <Eduard_Munteanu> So far I've only seen boxed types defined like data Int = I# Int#, so I wonder why.
22:27:28 <Cale> Eduard_Munteanu: The thing which makes parametric polymorphism work is the boxing
22:27:39 <Cale> Eduard_Munteanu: which gives a uniform representation to the data
22:28:15 <Eduard_Munteanu> Cale: so # -> * functors would somehow interfere with that?
22:28:19 <kmc> seems like you should be able to take an type arg which is an unboxed type
22:28:22 <kmc> but not use it in data
22:28:27 <kmc> i.e. it would have to be phantom
22:28:43 <Cale> Yeah, that might work
22:28:49 <Eduard_Munteanu> kmc: I'm rather arguing for 'type Int = Box Int#'
22:28:51 <Cale> Though it would perhaps be of limited use
22:29:02 <kmc> Eduard_Munteanu, i don't think that would work
22:29:11 <kmc> because (Box a) doesn't have a uniform representation
22:29:20 <Cale> Eduard_Munteanu: The problem is that different unboxed types have different sizes in memory
22:29:23 <kmc> Cale, yeah.  if the type param is phantom then why do you care if it's boxed
22:29:31 <kmc> different sizes, different CPU registers, etc
22:29:34 <kmc> some have size zero :)
22:29:41 <Cale> Eduard_Munteanu: and so it's not possible to make code that works on all unboxed types at once
22:29:53 <Eduard_Munteanu> So somehow I# is magic and takes care of boxing?
22:30:02 <kmc> it's not exactly magic
22:30:07 <kmc> i don't know what you consider magic
22:30:08 <Cale> Eduard_Munteanu: You'd end up doing something cheesy like compiling a version of every function with every conceivable unboxed type
22:30:11 <kmc> but Int isn't a polymorphic type
22:30:12 <Eduard_Munteanu> kmc: magic as in defined by the compiler.
22:30:18 <kmc> no
22:30:33 <Cale> I# is just an ordinary data constructor there
22:30:37 <Cale> (with a weird name)
22:30:48 <kmc> it's not defined by the compiler except in as much as it's in the compiler's standard library
22:30:53 <kmc> data Int = I# Int#
22:31:09 <kmc> we can't complain that "Int doesn't have a uniform representation", because, uniform over what?  it's not polymorphic
22:31:16 <Eduard_Munteanu> But how does that accomodate the size differences?
22:31:19 <Cale> You're allowed to have data constructors with unboxed fields
22:31:20 <kmc> there's no size differente
22:31:24 <kmc> we know how big Int# is
22:31:36 <kmc> but we don't know how big 't' is if t is allowed to be instantiated to any of Int#, Double#, or State# T
22:31:49 <Eduard_Munteanu> Oh.
22:31:54 <Cale> Is State# even unboxed?
22:31:58 <Cale> It's just void
22:32:31 <kmc> Cale, i'm not sure how you'd define "unboxed" exactly
22:32:38 <kmc> State# uses a STG calling convention that isn't 'p'
22:32:40 <Eduard_Munteanu> Thanks, I thought some specialization would occur, and the compiler would figure out different representations regardless of polymorphism.
22:32:46 <kmc> (specifically 'v' as you said)
22:32:54 <Cale> Well, does State# t have kind #? I don't think it does...
22:33:05 <Eduard_Munteanu> @src State#
22:33:05 <lambdabot> Source not found. Sorry.
22:33:14 <Cale> oh, it does
22:33:18 <Cale> ghci> :k State#
22:33:18 <Cale> State# :: * -> #
22:33:21 <Cale> interesting
22:33:24 <kmc> yeah
22:33:27 <Eduard_Munteanu> Wow.
22:33:40 <kmc> i think it has to, otherwise you could write stuff like [State ()]
22:33:46 <Eduard_Munteanu> How is that expressed, I wonder?
22:33:47 <kmc> which would be confusing what with it being void
22:33:51 <Cale> Well, it's not really impressive as such. The boxed type parameter is a phantom
22:34:09 <Cale> (There are no values of type  State# t  for any t)
22:34:25 <kmc> these are two different statements
22:34:32 <kmc> but i guess the'yre both correct
22:34:45 <Cale> kmc: Presumably they could have just let it be the one-element type  data Void
22:34:49 <kmc> let me think
22:34:54 <Eduard_Munteanu> So it's just some sort of 'data State# a'? I wonder how it knows its kind.
22:35:01 <Cale> Eduard_Munteanu: It's primitive
22:35:03 <kmc> Eduard_Munteanu, State# is a compiler primitive
22:35:13 <Eduard_Munteanu> Oh, so this one is magic.
22:35:13 <Cale> Eduard_Munteanu: It's part of the hacky implementation of IO and ST
22:35:14 <kmc> Cale, true, but then it would be boxed and would have 'p' STG-type
22:35:42 <kmc> Eduard_Munteanu, correct.  Int# is an unboxed machine int, Double# is an unboxed machine double, (State# T) is an unboxed machine *nothing*
22:35:44 <kmc> it takes zero bytes
22:35:51 <Eduard_Munteanu> :)
22:35:51 <kmc> it's used only to introduce an artificial data dependency
22:36:01 <Cale> Eduard_Munteanu: Basically, it's used to define the RealWorld type, which is just an empty datatype used to hijack the data dependency analysis in order to keep effects in IO in the right order
22:36:04 <kmc> because GHC implements IO in terms of some side-effecting functions
22:36:12 <Eduard_Munteanu> Yeah, it makes sense as a phantom type.
22:36:23 <Eduard_Munteanu> I see.
22:36:30 <kmc> i'm not sure what you mean by "phantom type"
22:36:37 <kmc> to me "phantom type parameter" is a thing
22:36:40 <kmc> which means the parameter is unused
22:36:48 <kmc> (at value level)
22:36:50 <Eduard_Munteanu> kmc: erm, rather type representations.
22:36:52 <kmc> which is true of the parameter to State#
22:37:02 <kmc> but that's not the most special property it has :)
22:37:23 <kmc> the parameter to State# provides a little static checking on the implementation of ST
22:37:27 <kmc> i'm not sure how much value it has, really
22:37:32 <Eduard_Munteanu> I don't recall the actual name, maybe it was type witness.
22:37:52 <Eduard_Munteanu> I remember reading something on the wiki regarding that.
22:38:39 <kmc> are there other things with 'void' STG type?
22:38:41 <kmc> Cale, do you know?
22:39:21 <Cale> I don't know
22:40:25 <dolio> State# isn't used to define RealWorld.
22:40:59 <dolio> Rather, IO a is internally State# RealWorld -> (# a, State# RealWorld #)
22:41:03 <kmc> yeah; RealWorld serves as a phantom parameter to State#
22:41:03 <dolio> Or something like that.
22:41:32 <kmc> i'm not sure why State# needs a parameter at all
22:41:34 <Eduard_Munteanu> Isn't RealWorld something concrete after all? Maybe something that tracks the RTS state (IORefs, file handles etc.)?
22:41:48 <kmc> no
22:41:52 <Cale> However, I think the original paper by Simon about unboxed types actually defined algebraic unboxed types with type parameters and all (but no recursion)...
22:42:27 <kmc> Eduard_Munteanu, it doesn't matter what structure the RealWorld type's values have, because the State# type doesn't use its parameter
22:42:29 <Cale> (recursion would be nuts)
22:43:03 <Cale> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.50.231
22:43:17 <Eduard_Munteanu> Cale: hm, thanks.
22:43:29 <dolio> I could see custom unboxed types being useful.
22:43:52 <kmc> Habit has a thing for specifying bit-level representation
22:43:59 <dolio> Although, maybe they're not really necessary with all of GHC's optimizations.
22:44:28 <Cale> data unboxed UPair# a b = UPair# a b
22:44:50 <Cale> and even  data unboxed Maybe# a = Just# a | Nothing#
22:44:55 <kmc> is equivalent to (# a, b #) ?
22:45:05 <kmc> hmm, how would Maybe# be represented?
22:45:52 <Cale> "It can be represented by a bit to distinguish one constructor from the other, together with enough words to contain the components of any of the constructors (one, in this case)."
22:45:59 <kmc> makes sense
22:46:17 <kmc> and this would live on the stack or in another closure's field but never as its own heap closure with info ptr etc
22:46:39 <Eduard_Munteanu> Is 'data unboxed' actual Haskell (non-standard) syntax?
22:46:43 <Cale> no
22:46:50 <Cale> It was never implemented like that
22:47:09 <Eduard_Munteanu> Makes sense, I only know about those unboxed types and tuples.
22:47:12 <Cale> I'm not sure what the intention was regarding the implementation of type parameters in unboxed types
22:47:47 <Cale> Maybe they would allow the types to occur in function signatures only fully instantiated.
22:49:26 <Eduard_Munteanu> Uh, and ddarius said the underlying Haskell "machine" wasn't more difficult to understand than C's assumptions. But maybe I'm equating Haskell with "GHC-like" :)
22:50:00 <Cale> The Haskell "machine" is nothing this low-level
22:50:04 <Eduard_Munteanu> Haskell really has few assumptions regarding the underlying machine.
22:50:13 <kmc> yep
22:50:18 <kmc> in fact Haskell doesn't even require lazy evaluation
22:50:26 <Eduard_Munteanu> Yeah, but STG and all that, *sigh* :)
22:50:33 <kmc> but you can assume lazy eval and describe a fairly simple, fairly abstract Haskell machine
22:50:41 <kmc> a graph reduction machine
22:50:54 <Cale> Normally when I think about how Haskell evaluates, I think of one of a handful of things which has almost no connection whatsoever to how it's actually represented in real hardware.
22:51:08 <kmc> the S and T part of STG are GHC-level implementation details, though probably shared with every other Haskell implementation
22:51:19 <Cale> Always expressions in some form being turned into other expressions
22:51:20 <kmc> does anyone actually use the two tag bits allowed for Int?
22:51:28 <Cale> Either graphs, or just textual expressions
22:51:54 <Cale> I'm not sure any implementation ever actually used them.
22:52:11 <kmc> perhaps LML, as some ML implementations have tags
22:52:20 <kmc> yeah, expressions with "let" stand for graphs... i wonder if this is a useful way to write graphs generally
22:52:50 <Eduard_Munteanu> BTW, has JHC got region inference yet? Or is it still "allocate but never free memory"? I'm thinking of giving it a try.
22:53:03 <kmc> i think it got a real GC in the latest version
22:53:11 <Eduard_Munteanu> Grrr...
22:53:18 <Eduard_Munteanu> The fancy thing was region inference.
22:53:27 <kmc> i think it still does that too
22:53:48 <Cale> I like the way that the space usage of a program is almost proportional to the amount of space on a piece of paper that it would take to draw the graph :)
22:53:58 <Eduard_Munteanu> Heh.
22:54:14 <Cale> (It's proportional to the number of vertices and edges)
22:54:41 <Cale> http://www.cas.mcmaster.ca/~kahl/HOPS/ANIM/index.html
22:54:45 <Chaze> how would you call "(== 1) . length . nub", and is there something more elegant?
22:55:08 <kmc> ((==1) . length) is less lazy than it could be
22:55:18 <kmc> perhaps (isJust . listToMaybe)
22:55:23 <kmc> :t isJust . listToMaybe
22:55:23 <lambdabot> forall a. [a] -> Bool
22:55:24 <Cale> Chaze: null . drop 1 . nub
22:55:26 <Eduard_Munteanu> Nice stuff.
22:55:49 <Eduard_Munteanu> Chaze: you could use a custom 'nub', one that takes an Ord instance.
22:55:49 <Cale> er, I suppose that's not 100% equivalent :)
22:55:50 <Eduard_Munteanu> :t nub
22:55:51 <lambdabot> forall a. (Eq a) => [a] -> [a]
22:55:58 <Chaze> Cale: yeah, that's better i guess. is there a way to get rid of nub?
22:55:58 <Cale> (differs on the empty list)
22:56:03 <Eduard_Munteanu> For performance reasons, not elegance.
22:56:13 <Cale> Chaze: why?
22:56:20 <Cale> nub is good for performance here
22:56:29 <Chaze> alright
22:56:34 <Cale> You don't want the sorting one
22:56:46 <Eduard_Munteanu> Yeah, but admittedly (Ord a) => [a] -> [a] could do better.
22:56:55 <Cale> Because nub only becomes inefficient as you get to later elements of the list
22:57:00 <Cale> No, it couldn't.
22:57:40 <Eduard_Munteanu> It should be O(n log n) vs O(n^2).
22:57:40 <Cale> Well, it could do better if you're using length, granted :)
22:57:58 <Cale> But this use of nub with null and drop 1 will be O(n)
22:58:07 <Eduard_Munteanu> (from O(n log n) sorting + O(n) eliminating duplicates)
22:58:26 <Cale> because if it finds a second element of the nub, it stops right there
22:58:30 <Chaze> Cale: your version behaves different for empty lists though
22:58:35 <Cale> So there's no way for it to become quadratic
22:58:37 <Cale> Chaze: right
22:58:39 <Eduard_Munteanu> Oh.
22:58:43 <kmc> > listToMaybe "abc"
22:58:43 <lambdabot>   Just 'a'
22:58:48 <kmc> ok so what i suggested doesn't work at all :D
22:59:18 <Eduard_Munteanu> Yeah, his original version can only return True/False, there either is a '1' there or not.
23:00:10 <Cale> Chaze: So, maybe something like  existsUnique = liftM2 (&&) (not . null) (null . drop 1 . nub)
23:00:38 <Cale> (okay, okay, maybe that's a bit too points-free ;)
23:01:30 <Cale> @let existsUnique = liftM2 (&&) (not . null) (null . drop 1 . nub)
23:01:31 <lambdabot>  Defined.
23:01:36 <Cale> > existsUnique [1..]
23:01:36 <lambdabot>   False
23:01:47 <Cale> ^^ try that with your sorting :)
23:01:54 <Veinor> what's existsUnique do?
23:01:59 <Veinor> don't feel like running it in my head
23:02:19 <Cale> Veinor: determines if the list, treated as a set, has exactly one element
23:02:29 <Cale> > existsUnique [1,1,1]
23:02:30 <lambdabot>   True
23:02:31 <Veinor> ah
23:02:33 <Cale> > existsUnique [1,1,2]
23:02:34 <lambdabot>   False
23:03:19 <Cale> Though to be fair, there's a version of nub which doesn't sort, but does take advantage of Ord, and would work lazily like the usual nub does
23:03:45 <Cale> (It does something like collecting the elements seen so far into a Data.Set)
23:04:28 <Chaze> unfortunately, whenever i see 'liftM2', i give up understanding it :)
23:04:52 <Cale> Oh, it's just liftM2 f g h = \x -> f (g x) (h x)
23:05:21 <Chaze> :t liftM2
23:05:22 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
23:05:40 <Chaze> i like your version more
23:06:17 <Cale> Well, I gave a specialised version of it, to the monad we're actually using here :)
23:06:30 <Chaze> which is?
23:06:36 <Cale> (the function monad, which simply distributes the common function parameter to all the computations)
23:07:00 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
23:07:00 <lambdabot>   ("hello","olleh","HELLO")
23:07:37 <Cale> > sequence [id, (+2), (*2), (^2), (2^)] 5
23:07:37 <lambdabot>   [5,7,10,25,32]
23:08:16 <jabenev> heya
23:08:21 <Cale> heya
23:08:28 <Chaze> oh, i used to do that like > map ($ 5) [id, (+2), (*2), (^2), (2^)]
23:08:31 <jabenev> hiyo
23:08:44 <Cale> Chaze: That's a good way too :)
23:09:05 <Cale> Chaze: I'm assuming here that you're familiar with sequence in general, though
23:09:27 <Chaze> my view of monads is, that everything has to be 'wrapped' in some type, such as State, Maybe, or []
23:09:43 <Cale> Well, monads are type constructors, sure
23:09:44 <Chaze> in your upper example in do notation
23:09:52 <Chaze> i don't really get what type constructor is being used
23:09:53 <Cale> They're type constructors with some extra functionality
23:09:58 <Cale> Oh, it's (->) e
23:10:09 <kmc> ((->) e t) is the same as (e -> t)
23:10:10 <Cale> for a fixed type e (I used String and Integer above)
23:10:20 <kmc> so ((->) e) is a 1-arg type constructor
23:10:20 <Cale> Right, good to explain that :)
23:10:32 <kmc> would be nice if we could write it as (e ->) but alas
23:10:48 <Cale> So, for example...
23:10:52 <Cale> :t liftM2
23:10:53 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
23:11:01 <Cale> If we plug in m = (->) e here
23:11:05 <Cale> we get:
23:11:11 <JoeyA> http://hpaste.org/42174/on_log_n_alternative_to_nub
23:11:19 <Cale> (a1 -> a2 -> r) -> (e -> a1) -> (e -> a2) -> (e -> r)
23:11:57 <Cale> Or with sequence
23:12:00 <Cale> :t sequence
23:12:01 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
23:12:07 <Cale> [e -> a] -> e -> [a]
23:12:20 <Chaze> so (->) is just like a type constructor?
23:12:26 <Cale> It is a type constructor
23:12:31 <Cale> with 2 parameters
23:12:50 <Cale> and so if you supply one of the parameters, it becomes a type constructor with just one parameter left
23:12:59 <Cale> and that's the right kind of type constructor to possibly be a monad
23:13:04 <Chaze> :t (->)
23:13:05 <lambdabot> parse error on input `->'
23:13:08 <Cale> :k (->)
23:13:09 <lambdabot> ?? -> ? -> *
23:13:23 <Cale> Ignore the ??, it's some nonsense about unboxed types
23:13:24 <kmc> type constructors don't have types, they have kinds
23:13:27 <Cale> * -> * -> *
23:13:27 <kmc> yep
23:13:57 <Cale> Where * is the kind of all well-formed types
23:14:10 <Cale> :k []
23:14:11 <lambdabot> * -> *
23:14:12 <Cale> :k Maybe
23:14:13 <lambdabot> * -> *
23:14:15 <Cale> :k IO
23:14:16 <lambdabot> * -> *
23:14:21 <Cale> :k State
23:14:21 <lambdabot> * -> * -> *
23:14:23 <Cale> :k State s
23:14:23 <lambdabot> Not in scope: type variable `s'
23:14:25 <kmc> :k ContT
23:14:26 <lambdabot> * -> (* -> *) -> * -> *
23:14:26 <Cale> :k State Integer
23:14:27 <lambdabot> * -> *
23:14:33 <JoeyA> :k forall s. State s
23:14:34 <lambdabot>     `State s' is not applied to enough type arguments
23:14:34 <lambdabot>     Expected kind `*', but `State s' has kind `* -> *'
23:14:38 <JoeyA> darn
23:14:39 <Cale> Monads all have kind * -> *
23:14:45 <Cale> So...
23:14:53 <Cale> :k (->) Integer
23:14:53 <lambdabot> ? -> *
23:15:09 <Cale> (and again, ignore the distinction between ? and *, because it's not important here)
23:15:27 <Chaze> can you actually use (->) syntactically?
23:15:31 <Cale> yep
23:15:43 <JoeyA> > read "123" :: ((->) String Int)
23:15:44 <lambdabot>   No instance for (GHC.Read.Read (GHC.Base.String -> GHC.Types.Int))
23:15:44 <lambdabot>    arisi...
23:15:56 <Cale> :t reverse :: (->) ([] a) ([] a)
23:15:56 <lambdabot> forall a. [a] -> [a]
23:16:10 <JoeyA> oops
23:16:21 <JoeyA> > (read :: ((->) String Int)) "123"
23:16:21 <lambdabot>   123
23:16:33 <JoeyA> > (read :: String -> Int) "123"
23:16:34 <lambdabot>   123
23:17:00 <Cale> It's important to have a prefix form so that we can define instances
23:17:22 <Cale> So, in order to be a monad, (->) e had better be a functor
23:17:31 <Cale> fmap :: (a -> b) -> f a -> f b
23:17:33 <Cale> so in this case
23:17:40 <Cale> fmap :: (a -> b) -> (e -> a) -> (e -> b)
23:17:49 <Cale> and fmap is nothing other than function composition
23:18:14 <Cale> and then return :: a -> m a, which specialises to a -> (e -> a)
23:18:18 <Cale> and that's the type of const
23:18:23 <Cale> :t const
23:18:24 <lambdabot> forall a b. a -> b -> a
23:18:34 * hackagebot persistent 0.3.1.3 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-0.3.1.3 (MichaelSnoyman)
23:18:47 <Cale> and then  join :: m (m a) -> m a, which is  (e -> e -> a) -> (e -> a)
23:18:54 <Cale> join f x = f x x
23:19:09 <JoeyA> > join zip [1..10]
23:19:10 <lambdabot>   [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10)]
23:19:21 <Cale> and that already tells us how to define >>=, but let's just do it from the type :)
23:19:34 <Cale> (>>=) :: m a -> (a -> m b) -> m b
23:19:40 <Cale> so, specialising,
23:19:50 <Cale> (>>=) :: (e -> a) -> (a -> e -> b) -> e -> b
23:20:14 <Cale> (f >>= g) x = g (f x) x
23:21:42 <Cale> So what >>= is doing is "running" f by applying it to x, and then taking the result of that and applying g to it to get another function which it "runs" by applying it to x
23:22:21 <Cale> So "running" a function in this monad just means to apply it to the parameter to which the whole function has been applied
23:22:32 <Chaze> you lost be somewhere at 'functors', but i feel like i understand a little more each time :)
23:22:45 <Cale> Yeah, I raced through that sort of quickly
23:22:58 <JoeyA> > (do {a <- (!! 0); b <- (!! 1); c <- (!! 2); return (a,b,c)}) "abc"
23:22:59 <lambdabot>   ('a','b','c')
23:23:27 <Cale> (I'm going to need to help a friend with something in a minute, so trying to get through a bit quickly, sorry)
23:24:02 <Chaze> i'm good, this is a little information overload anyways
23:24:25 <kmc> information overload is our specialty
23:24:31 <shachaf> Chaze: If you want to have more fun, implement the monad where "m a" means "(a -> r) -> r". :-)
23:24:32 <JoeyA> The function monad is like doing things "lifted" above the argument.
23:25:26 <kmc> @djinn ((a -> r) -> r) -> (a -> ((b -> r) -> r)) -> ((b -> r) -> r)
23:25:26 <lambdabot> f a b c = a (\ d -> b d c)
23:25:48 <shachaf> kmc: Spoilsport.
23:25:49 <JoeyA> cool
23:26:26 <kmc> blame djinn for being so clever
23:26:30 <JoeyA> So instead of actions which interact with the world or state or something, you use a function as the "action" which gets a value from the "state" present in the argument.
23:26:58 <JoeyA> > (do {a <- id; return (a+1)}) 2
23:26:59 <lambdabot>   3
23:27:03 <kmc> JoeyA, for ((->) e)?  yeah, it's the same as the (Reader e) monad modulo wrapping
23:27:14 <shachaf> @djinn ((((a -> r) -> r) -> r) -> r) -> (a -> r) -> r
23:27:14 <lambdabot> f a b = a (\ c -> c b)
23:27:18 <JoeyA> yeah
23:27:19 <kmc> > (fmap (+1) id) 2
23:27:20 <lambdabot>   3
23:27:32 <JoeyA> > (id >>= \a -> return (a+1)) 2
23:27:33 <lambdabot>   3
23:27:41 <shachaf> JoeyA: It's generally called an "environment" when you don't modify it.
23:27:44 <JoeyA> Really, though, the most important application of all this is:
23:27:47 <JoeyA> @quote zip`ap`tail
23:27:47 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
23:27:57 <kmc> :D
23:28:05 <JoeyA> > (zip`ap`tail) [1..10]
23:28:07 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
23:28:36 * shachaf likes zipWith max.
23:28:37 <kmc> that particular "ap" is the S combinator
23:28:44 <kmc> :t zipWith max
23:28:45 <JoeyA> Yup
23:28:45 <lambdabot> forall a. (Ord a) => [a] -> [a] -> [a]
23:29:16 <shachaf> Or, rather, zipWith max `ap` tail.
23:51:43 * hackagebot histogram-fill 0.3.1 - Library for histograms creation.  http://hackage.haskell.org/package/histogram-fill-0.3.1 (AlexeyKhudyakov)
