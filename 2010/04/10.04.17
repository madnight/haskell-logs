00:00:13 <edlinde> fax: and would it integrate with say c++?
00:00:19 <fax> yes
00:00:30 <edlinde> ah cool did not know that
00:00:39 <tensorpudding> It's a Turing-complete language, it is not limited in that capacity.
00:00:46 <edlinde> ok
00:01:04 <fax> -_-
00:01:09 <edlinde> but I mean you cannot setup a website in haskell now can you?
00:01:10 <tensorpudding> It has a foreign function interface for interfacing with C
00:01:17 <fax> edlinde: Yes you can
00:01:21 <edlinde> I mean I wouldn't use C to write a page
00:01:33 <fax> um
00:01:38 <fax> a lot of webservers ARE written in C
00:02:05 <DigitalKiwi> lmao
00:02:09 <edlinde> yeah the actual web server itself in C makes sense
00:02:09 <tensorpudding> Webpages are different, they need to be in an approved format that browsers understand.
00:02:11 <DigitalKiwi> it can do anything, it is turing complete!
00:02:30 <fax> URgh
00:02:33 <edlinde> DigitalKiwi: and you don't agree with that statement about haskell?
00:02:35 <fax> stop talking about turing machines ffs
00:02:49 <copumpkin> church-complete?
00:02:51 <fax> sure is computer science in here
00:03:14 <copumpkin> fucking computer scientists
00:03:16 <fax> "Can I use haskell for practical program?" ---> "turing machines!"
00:03:17 <copumpkin> always talking about computer science
00:03:19 <DigitalKiwi> while i will agree it is turing complete, i do not think that means it is the best tool to do anything and everything
00:03:22 <kmc> edlinde, you can in fact write a CGI script in C
00:03:24 <edlinde> I been told that the learning curve with haskell is steeper than with say ML
00:03:26 <kmc> it's not very common, but not unheard of
00:03:31 <copumpkin> DigitalKiwi: no, it is
00:03:31 <kmc> the learning curve is pretty steep
00:03:37 <fax> edlinde: definitely
00:03:44 <copumpkin> edlinde: I'd agree
00:03:45 <tensorpudding> Haskell is different from most languages, it requires getting used to.
00:03:52 <kmc> edlinde, Haskell avoids taking the "easy way out" in language design
00:03:52 <DigitalKiwi> itc copumpkin is elitist fanboy
00:03:54 <edlinde> but once I get the hang of haskell would it kick ass over ML? :)
00:03:59 <kmc> this makes for a better language overall, but it is harder to learn
00:04:06 <kmc> edlinde, for some things
00:04:06 <ivanm> the co-gourd is back! \o/
00:04:13 <kmc> learn them both, and see for yourself :)
00:04:17 <copumpkin> DigitalKiwi: hey, don't hate cause haskell is awesome
00:04:19 <copumpkin> just ask @faq
00:04:20 <edlinde> well actually I have to
00:04:27 <DigitalKiwi> hey i didn't say it wasn't awesome
00:04:30 <ivanm> copumpkin: where've you been all this time?
00:04:41 <DigitalKiwi> but don't make the whole world a nail just cause your hammer is haskell
00:04:48 <tensorpudding> @faq Can Haskell do everything?
00:04:49 <lambdabot> The answer is: Yes! Haskell can do that.
00:04:49 <copumpkin> ivanm: having lots of fun
00:05:02 <DigitalKiwi> can it? maybe, should it? probably not
00:05:08 <Cale> edlinde: If you can ignore the fact that you already know how to write computer programs in an imperative language and treat it like your first programming language, it won't be much different from that, difficulty-wise :)
00:05:10 <copumpkin> @faq can haskell be the perfect language for every application?
00:05:11 <lambdabot> The answer is: Yes! Haskell can do that.
00:05:26 <brooksbp> The term \f.\y.(f (f y)) has type (t->t)->t->t  ... How can the term also have the type (t->t)->(t->t)?  Or can it not have that type?
00:05:27 <kmc> edlinde, a lot of the effort in learning Haskell is applicable to ML too
00:05:34 <fax> we should make faq say "The answer is: Yes! Haskell can do that because it's a turing machine" XD
00:05:43 <edlinde> Cale: yeah thats what I hear all the time.. if you have an imperative background you will keep thinking in those terms and mess up
00:05:51 <fax> brooksbp: those are exactly the same type
00:05:51 <Cale> yeah
00:05:54 <DigitalKiwi> embed haskell in a game that makes it easy for a nonprogrammer to edit the files without spending weeks on developing your own api
00:05:56 <fax> brooksbp: the parens are optional
00:06:05 <DigitalKiwi> oh wait, lua already does that
00:06:10 <Jafet> @faq Can Haskell have or-patterns?
00:06:10 <lambdabot> The answer is: Yes! Haskell can do that.
00:06:16 <edlinde> oh yeah can I embedd haskell into say an application written in C++?
00:06:17 <tensorpudding> brooksbp: the parens are right associative
00:06:22 <DigitalKiwi> could you? sure, would it be wise to? no
00:06:23 <copumpkin> @faq can haskell have xnor patterns?
00:06:23 <lambdabot> The answer is: Yes! Haskell can do that.
00:06:25 <fax> edlinde I already answered that
00:06:27 <kmc> edlinde, but Haskell is actually a good imperative language.  it's just that we don't treat imperative programming as the only or primary tool
00:06:37 <tensorpudding> in actuality, A -> B -> C is the same as A -> (B -> C)
00:06:47 <Gracenotes> brooksbp: there are two interpretations, though. In the first, you take a function and a value and apply the function twice to the value. In the second, you take a function and return a function which has the behavior of doing the first one twice
00:06:55 <ski> copumpkin : hm, how would those work ?
00:06:57 <edlinde> fax: I thought you said haskell can call C code via foreign functions... wonder how it works the other way round :)
00:07:12 <copumpkin> ski: xor would be /=, xnor might be ==, but who knows
00:07:16 <Cale> So unlearning your imperative intuitions about how programs should be structured, and just resigning yourself to learning a different way to break things down is most of the work. The fortunate aspect of it is that typically the way that programs break down often ends up being closer to something natural for non-programmers.
00:07:21 <tensorpudding> Calling Haskell in C is possible.
00:07:23 <edlinde> kmc: so you saying haskell allows me to code imperatively too?
00:07:23 <kmc> edlinde, both ways work
00:07:26 <LegendaryPenguin> you must unlearn what you have learned
00:07:27 <kmc> edlinde, yes
00:07:29 <Cale> (In a funny way)
00:07:33 <kmc> edlinde, when you need to
00:07:38 <edlinde> ok thats nice
00:07:48 <kmc> edlinde, in a very elegant and principled way, in fact
00:07:50 <tensorpudding> Though it's harder to marshall the types that way than the other.
00:08:09 <kmc> edlinde, some Haskell values represent "sequence of imperative steps" and these are just as much values as anything else in the language
00:08:28 <kmc> however it's probably a bit far along the learning curve before you learn to use those effectively
00:08:45 <kmc> don't expect to write whole programs immediately; start by evaluating individual expressions in GHCi
00:08:51 <edlinde> actually I been working on some c++ template metaprogramming in the past and i hear that learning haskell actually improves your c++ template skills too
00:08:53 <edlinde> :)
00:08:55 <DigitalKiwi> but that's boring kmc
00:09:01 <kmc> ;P
00:09:05 <tensorpudding> You must spend a few hours and contemplate the zen of foldr
00:09:15 <kmc> learning haskell is not an instant-gratification task
00:09:17 <edlinde> http://tryhaskell.org/
00:09:19 <DigitalKiwi> i dunno a good program to write in  haskell if i ever get around to learn it :(
00:09:22 <Jafet> It was for me!
00:09:24 <Cale> For example, if you think about how to accomplish some task like "get the dishes washed". It's very unnatural to introduce some sort of counter, and give each dish an index and increment that counter as you loop over the dishes washing them. Only imperative programmers think like that. :)
00:09:31 <edlinde> I was playing around with that and that seemed real straight forward to me
00:09:34 <Gracenotes> to get values in functional languages, you take other values and combine them. I think it's more intuitive than taking procedures in imperative languages and combining them to get /behaviors/... and who knows how something will behave when you have things mutating all over the place.
00:09:49 <Jafet> @quote fibonacci
00:09:49 <lambdabot> _pizza_ says: i think Haskell is undoubtedly the world's best programming language for discovering the first few dozen numbers in the Fibonacci sequence over IRC
00:10:07 <tensorpudding> Hmm, where is that haskell factorial thing
00:10:21 <edlinde> Cale: how does a functional programmer wash his dishes? :)
00:10:23 <kmc> http://www.willamette.edu/~fruehr/haskell/evolution.html ?
00:10:25 <DigitalKiwi> things i find i want, ncmpcpp without the mpd, wicd without the python, EAC without the windows, pacman clone withou the C, aur helper without the <anything but haskell>, pastebin client, umm...
00:10:29 <kmc> edlinde, "for each dish, wash it"
00:10:30 <edlinde> Cale: recursively?
00:10:30 <tensorpudding> Yeah, that one.
00:10:32 <DigitalKiwi> i should really write these down
00:10:32 <kmc> map wash dishes
00:10:33 <Cale> Recursion also is a bit unnatural, even though "wash the first dish, then wash the rest" isn't quite as unnatural (I'd argue). But normal humans think in terms of collective operations (wash all the dishes)
00:10:41 <DigitalKiwi> oh, torrent client like rtorrent but with more control
00:10:52 <Jafet> Except you need mapM*.
00:10:54 <Cale> Which is a heck of a lot closer to something like map wash dishes than it is to a for-loop
00:10:56 <kmc> interestingly they don't have a true imperative Haskell solution
00:10:58 <tensorpudding> jlouis is working on a Haskell torrent client
00:11:01 <kmc> using IO or ST
00:11:01 <edlinde> Cale: lets break the dishes down to smaller dishes and clean them up :)
00:11:01 <Jafet> But you shouldn't know about that yet.
00:11:03 <DigitalKiwi> what would be a good one to pick? :D
00:11:04 <ski> edlinde : `mapM_ wash dishes', possibly
00:11:18 <edlinde> Cale: thats prolly what a functional dude would do :)
00:11:30 <Gracenotes> unless you want a series of receipts that you in fact washed each dish, then you want mapM
00:11:45 <Jafet> Imperative languages do have map, like lisp.
00:11:47 <brooksbp> But... How can \f.\y.(f (f y)) have the type (t->t)->(t->t).  That type seems like it would model a term like (\x.x \x.x).  When you typecheck \f.\y.(f (f y)) you say f must be a function type so \f.(...) is (t->t)->... and y must be some type t \y.(...) t-> ... then the application reduces to type t... so the final type is (t->t)->t->t.  I dont see how this is equal to (t->t)->(t->t)
00:11:48 <Cale> Yeah, since washing has an effect, you might want mapM_ instead. But it depends on how we're interpreting the analogy
00:11:52 <Jafet> Dysfunctional languages don't.
00:11:59 <kmc> Jafet, yes, imperative languages such as Haskell have map
00:12:00 <kmc> ;)
00:12:04 <tensorpudding> Python and Ruby have map
00:12:15 <kmc> brooksbp, (->) is a binary type constructor
00:12:18 <Jafet> Python's map is second-class, disowned by guido
00:12:19 <DigitalKiwi> so...which of what i listed would be good to dive into haskell with? :D
00:12:19 <kmc> so what does A -> B -> C mean?
00:12:23 <kmc> it means A -> (B -> C)
00:12:24 <Cale> In any case, we normally think in terms of neither iteration nor recursion, but in terms of higher-order ways of composing ideas.
00:12:42 <kmc> brooksbp, because every (->) is connecting only two types
00:12:51 <kmc> so it must be equivalent to either (A -> B) -> C or A -> (B -> C)
00:12:51 <edlinde> Cale: is that "higher order functions" you are talking about?
00:12:54 <kmc> and the latter is the useful one
00:12:59 <DigitalKiwi> i think i could do the pastebin client moderatly easily...
00:13:00 <Cale> yeah
00:13:03 <edlinde> ok
00:13:27 <Cale> Functional programming isn't really about getting everything you can out of recursion, as much as it's about getting everything you can out of higher order functions.
00:13:45 <kmc> edlinde, have you done any functional programming?
00:13:47 <edlinde> Cale: I really got time over summer to get to learn haskell.. hope I see some progress, coz it would suck to not move forward at all
00:13:49 <DigitalKiwi> what is 'higher order function'
00:14:00 <kmc> DigitalKiwi,  a function that takes another function as an arg, or returns a function
00:14:03 <Gracenotes> brooksbp: lemme try.. \f. (\y.(f (f y))). f has type (t  -> t), both y and (f (f y)) have type t and so the lambda abstraction has type (t -> t), so why can't it be (t -> t) -> (t -> t)?
00:14:10 <edlinde> kmc: nah none at all... well closest I did was Scheme I think... but I suppose it doesn't count
00:14:13 <ski> > map (2 *) [1,2,3,4]
00:14:14 <lambdabot>   [2,4,6,8]
00:14:14 <DigitalKiwi> kmc: oh
00:14:15 <kmc> edlinde, why not?
00:14:28 <kmc> edlinde, Scheme is a beautifully simple functional language
00:14:28 <DigitalKiwi> so a higher order function could be an iterator?
00:14:32 <ski> > filter (5 <) [2,8,5,7,1,4]
00:14:33 <edlinde> kmc: why not for what sorry?
00:14:33 <lambdabot>   [8,7]
00:14:33 <ivanm> copumpkin: what, you're saying that haskell isn't fun? :o
00:14:34 <kmc> DigitalKiwi, what's an iterator?
00:14:35 <DigitalKiwi> slash closure
00:14:38 <kmc> edlinde, why doesn't scheme count?
00:14:49 <Associat0r> DigitalKiwi: function taking a function
00:14:54 <edlinde> kmc: I wasn't sure if its purely functional like haskell?
00:14:55 <Jafet> ivanm, he's coserious today
00:15:00 <copumpkin> ivanm: haskell is fun, but I needed a break, and I found other fun things
00:15:01 <ivanm> ahhhh
00:15:02 <kmc> edlinde, i said "functional" not "purely functional"
00:15:12 <ivanm> copumpkin: liar! there is no other fun things!
00:15:12 <kmc> edlinde, and the "purely functional" aspect of Haskell is a pretty technical thing
00:15:15 <DigitalKiwi> in lua iterator for i, v in ipairs(sometbl) do <stuff with i and v> end
00:15:20 <kmc> we have ways to do all the stuff they do in "impure functional languages"
00:15:21 <ski> DigitalKiwi : some higher-order functions perform "internal iteration", yes ..
00:15:22 <Cale> edlinde: It's less pure, but scheme is one of the easier lisps in which to program in a functional style.
00:15:36 <kmc> edlinde, basically Haskell is careful about where effects go, whereas other languages are sloppy
00:15:42 <kmc> but Haskell still supports effectful programming
00:15:49 <edlinde> Cale: yeah I was tossing up between learning Common Lisp or something more modern like Haskell.. and I think I choose Haskell
00:15:52 <copumpkin> ivanm: I've been doing things you'd disapprove of
00:16:11 <edlinde> kmc: ok
00:16:11 <ivanm> copumpkin: you went on a bender to get over getting dumped?
00:16:16 <kmc> edlinde, in most languages, evaluation of function application and execution of side effects happen as the same  process
00:16:17 <ivanm> and whilst doing so found a new girlfriend?
00:16:20 <kmc> in Haskell, they are totally distinct
00:16:21 <ski> edlinde : Scheme isn't purely functional, but it emphasizes pure solutions to problems, when reasonable
00:16:27 <Gracenotes> choose DDC for control of effectful computations!
00:16:32 <Cale> edlinde: Common Lisp actually makes a terrible language for functional programming compared with Scheme, I think.
00:16:35 <copumpkin> ivanm: on a bender?
00:16:55 <kmc> Haskell *also* emphasizes pure solutions to problems, and lets you use mutation when you need to
00:16:58 <Cale> edlinde: (That doesn't mean it doesn't have its good points, just that it's hard to program in a functional style using it, in my experience.)
00:16:59 <DigitalKiwi> and a closure just returns a function in lua like uh.... http://www.lua.org/pil/6.1.html
00:17:08 <DigitalKiwi> often used in iterators
00:17:15 <edlinde> yeah its just that at uni we have a lot of Common Lisp people or ML people... no one recommends using Haskell .. which I think sucks
00:17:33 <tensorpudding> Scheme is the fun little Lisp
00:17:35 <fax> edlinde: what sucks about haskell
00:17:43 <DigitalKiwi> you think haskell sucks or you think they don't recommend it sucks?
00:17:43 <Cale> fax: That's not what he meant :)
00:17:49 <edlinde> fax: thats not what I said
00:17:52 <edlinde> :)
00:17:56 <DigitalKiwi> oh, the latter
00:17:58 <Jafet> tensorpudding, "little" is right!
00:18:00 <pippijn> edlinde: ML is often much faster than either haskell or CL
00:18:09 <Jafet> "fun" is debatable
00:18:22 <tensorpudding> It's fun to implement.
00:18:30 <edlinde> pippijn: even with GHC ?
00:18:30 <DigitalKiwi> we should all speak lojban
00:18:48 <pippijn> edlinde: and CL is dynamically typed
00:18:59 * ski . o O ( `-rectypes' : `(fun x -> x x) (fun x -> x x)' )
00:19:00 <pippijn> edlinde: two reasons to use either ML or CL
00:19:06 <kmc> languages don't have speed... implementations do
00:19:16 <DigitalKiwi> sometimes i love dynamic typing and sometimes i absolutely hate it ;_;
00:19:18 <Gracenotes> type inference beats dynamic typing any day
00:19:23 <copumpkin> yo mama has speed
00:19:24 <Gracenotes> most days at least
00:19:27 <Cale> edlinde: I would say one of the first things you should do to get comfortable is to get really good at manipulating lists using collective operations and higher order functions. map, filter, takeWhile, group, foldr, and such.
00:19:27 <copumpkin> she gave me some last night, anyway
00:19:28 <pippijn> kmc: which is why I said "often"
00:19:38 <kmc> Gracenotes, and you can always implement dynamic typing in a statically typed language
00:19:40 <kmc> but not the other way around
00:19:46 <kmc> dynamic typing is a trivial special case of static typing
00:19:49 <tensorpudding> Is that referring to SML or OCaml or both, when you say ML
00:19:59 <Cale> edlinde: Lists are sort of like our loops
00:20:05 <pippijn> both
00:20:05 <edlinde> Cale: yeah true I see a lot of list manipulation
00:20:06 <ski> Cale : .. and list comprehensions, to start with
00:20:12 <DigitalKiwi> kmc: do you know how to do it in fortran? I would love to know for my linked lists ;_;
00:20:23 <Gracenotes> kmc: or, implement your own type system out of tag-manipulating hacks!
00:20:29 <pippijn> the mlton sml compiler produces amazingly fast machine code
00:20:32 <Cale> edlinde: Just as a loop either doesn't happen, or consists of a single iteration followed by a loop, a list is either empty, or consists of a single element followed by another list.
00:20:37 <pippijn> ocaml also does a pretty good job
00:20:40 <ski> mlton is a whole-program compiler
00:20:43 <brooksbp> Gracenotes: I guess... when I see (t->t)->(t->t) I think of an abstraction term where the function is of type g->g and the argument is a function of type t->t so like (\g.g \x:t.x).  Whereas the type (t->t)->t->t I think of a term that has 2 applications
00:20:44 <pippijn> yes
00:20:45 <kmc> much of the supposed flexibility of dynamic types comes from using the type system itself as a single, ad-hoc variant type
00:20:46 <edlinde> I am slowly going through the "try yourself a haskell" tutorial online
00:21:07 <kmc> brooksbp, did you see what i said above?
00:21:22 <edlinde> Cale: is the ":" symbol just concatenation?
00:21:25 <fax> brooksbp: They're identical
00:21:34 <kmc> brooksbp, there is a very simple argument that type (A -> B -> C) must be either ((A -> B) -> C) or (A -> (B -> C))
00:21:38 <edlinde> 'a': 'b' : [] == "ab"
00:21:39 <kmc> brooksbp, do you follow so far?
00:21:41 <Cale> edlinde: It means adding a single element to the beginning of a list
00:21:50 <brooksbp> kmc: yep.  I understand they're identical.  The notion of associativity for function type just isn't natural for me.
00:22:01 <kmc> brooksbp, because you think of A and B as "argument" types and C as "result" type?
00:22:09 <ski> brooksbp : when you see `(t -> t) -> (t -> t)' you should think of an abstraction term where the argument is of type `t -> t' (the part before the main `->'), and where the result is of type `t -> t' (the part after the main `->')
00:22:11 <Cale> And it associates to the right, so that  'a' : 'b' : []  means  'a' : ('b' : [])
00:22:14 <edlinde> Cale: so that example I got from the interactive tutorial just means adding elements a and b to an empty list yeah?
00:22:17 <copumpkin> brooksbp: they aren't identical
00:22:18 <kmc> brooksbp, think of it this way -- the function takes only A, and to take B, it *returns* a function which then gets the B
00:22:18 <Cale> yeah
00:22:19 <DigitalKiwi> things i find i want, ncmpcpp without the mpd, wicd without the python, EAC without the windows, pacman clone without the C, aur helper without the <anything but haskell>, pastebin client, rtorrent without the lack of control...what should i start with? :D
00:22:21 <Gracenotes> brooksbp: although the number of arguments can be misleading. if t itself is (a -> a), then you get ((a -> a) -> a -> a) -> (a -> a) -> a -> a
00:22:21 <kmc> that's how currying works
00:22:34 <kmc> brooksbp, ((A -> B) -> C) is very much not the same type as (A -> (B -> C))
00:22:37 <ski> brooksbp : so if you have `\f. ...', that means `f' has type `t -> t', and `...' has type `t -> t'
00:22:48 <Cale> edlinde: You'll also see (:) a lot in pattern matching to break lists down again
00:22:59 <kmc> but the latter is the same as (A -> B -> C).  it's what we *mean* by that, because any time we use an operator like that, we must say which way it associates, if it's not associative
00:23:06 <Cale> > let mySum [] = 0; mySum (x:xs) = x + mySum xs in mySum [1,2,3,4,5]
00:23:07 <lambdabot>   15
00:23:11 <kmc> and (->) is *not* associative
00:23:24 <edlinde> Cale: I have actually done quite some work with regular expressions in Perl and BASH scripts etc... so maybe that will come handy?
00:23:30 <tensorpudding> @djinn (a -> b -> c) -> a -> (b -> c)
00:23:30 <lambdabot> f a = a
00:23:47 <pippijn> edlinde: not much
00:23:51 <Gracenotes> pattern matching reveals the structure of the things you're matching against
00:23:52 <edlinde> ok
00:24:02 <Cale> edlinde: So here, we define the function mySum for both the empty list case, and the nonempty list case, where the list consists of a single element x, followed by another (possibly empty) list xs
00:24:04 <brooksbp> I meant that (t->t)->(t->t) = (t->t)->t->t
00:24:13 <Jafet> @. pl djinn (a -> b -> c) -> a -> (b -> c)
00:24:13 <lambdabot> f = id
00:24:19 <Gracenotes> so I see how you see the link with regex, but... eh.
00:24:22 <tensorpudding> There are a few regular expressions libraries in Haskell, but they work in different and unfamiliar ways from Perl.
00:24:32 <kmc> brooksbp, the first (t -> t) part is irrelevent
00:24:38 <DigitalKiwi> :(
00:24:45 <kmc> brooksbp, so do you understand why (A -> B -> C) is (A -> (B -> C)) and not ((A -> B) -> C)
00:24:54 <kmc> sorry to keep asking, but i didn't get a clear answer, or maybe i missed it
00:25:01 * DigitalKiwi will ask later when you all stop talking theory and turing machines
00:25:01 <edlinde> Cale: why do we break the list into x and xs - empty and non-empty?
00:25:02 <pippijn> tensorpudding: edlinde asked whether regex knowledge would help understanding haskell pattern matching
00:25:04 <ski> edlinde : regular expressions aren't that related to pattern matching (of algebreaic datatypes (/ variants and product types))
00:25:07 <brooksbp> kmc: because the function type is right associative?
00:25:13 <kmc> brooksbp, right, but why does it make sense
00:25:20 <edlinde> is this done to deal with the last element or say the boundary cases separately?
00:25:20 <kmc> given that (A -> B -> C) is a "two argument function"
00:25:25 <Cale> edlinde: Well, any list is either empty [], or it consists of a single element followed by another list
00:25:29 <kmc> edlinde, because every list is either empty, or it's an element and another list
00:25:32 <Cale> edlinde: That's just how we define lists
00:25:34 <kmc> it's a recursive definition
00:25:47 <kmc> in fact lists are not very special or built-in.  you can define them yourself as:  data List a = Nil | Cons a (List a)
00:25:53 <kmc> (but then you don't get special syntax)
00:26:01 <edlinde> ah I get the recursive definition
00:26:08 <fax> well they are a tiny bit special
00:26:10 <Cale> So when we write the most basic functions on lists, we use recursion, and break down the structure, usually handling those two cases separately.
00:26:15 <fax> because of [_]
00:26:16 <edlinde> so its basically saying that the one element is like the base case in recursion yeah?
00:26:16 <kmc> that says that for each type T, there's a type (List T), and that any value of that type is either Nil, or it's (Cons x xs) where x has type T and xs has type (List T)
00:26:20 <tensorpudding> Haskell makes recursive data structures very easy to define.
00:26:24 <kmc> edlinde, the *empty* list is the base case
00:26:26 <fax> we're not allowed to define brackets ourself in haskell (I think I could be trusted tohugh...)
00:26:41 <edlinde> kmc: alright
00:26:42 <Cale> edlinde: The empty list case is your base case, and the (x:xs) case is the recursive case
00:27:05 <kmc> edlinde, although any particular function on lists might have a different base case
00:27:06 <edlinde> is it always defined as x:xs? sorry to ask... but are those variables?
00:27:07 <ski> edlinde : `[]' is the base case .. `x:xs' is the recursive case (where you may name `x' and `xs' however you like)
00:27:12 <kmc> for example if you want to treat the single-element list specially
00:27:13 <edlinde> could I call it c:cs?
00:27:15 <Gracenotes> edlinde: ignore the right side of the diagram... here's a list, laid out: http://en.wikipedia.org/wiki/File:Right-fold-transformation.png (yay Cale)
00:27:15 <kmc> yes
00:27:16 <ski> yes
00:27:21 <dobblego> edlinde, http://blog.tmorris.net/haskell-exercises-for-beginners/
00:27:22 <kmc> edlinde, there is a grammar of patterns
00:27:23 <tensorpudding> it's pattern matching
00:27:24 <Cale> edlinde: x and xs are variables, and you can name them whatever you like
00:27:26 <edlinde> ok got it
00:27:36 <brooksbp> kmc: (A->B->C) = (A->(B->C)) So a term like \a:A.\b:B.c where c:C or a term like \a:A.z where z:B->C
00:27:40 <edlinde> Cale: coz I seen it like x:xs in many places
00:27:47 <tensorpudding> it sees the (:), which is the constructor for lists, and defines x to be the first argument and xs to be the second
00:27:48 <kmc> brooksbp, right, one such z is \b:B.c
00:27:52 <Cale> edlinde: yeah, it's sort of a convention
00:27:55 <edlinde> I think I saw quicksort implemented like that
00:28:00 <Cale> edlinde: xs is the plural of x :)
00:28:06 <edlinde> hahah yeah
00:28:11 <kmc> this isn't Rails, our language doesn't know about pluralizations
00:28:13 <kmc> ;)
00:28:14 <ski> brooksbp : yes, since `\b:B.c' is one such `z' of type `B -> C'
00:28:15 <edlinde> its simpler to form a memory aid I suppose
00:28:28 <tensorpudding> it's traditional to match lists on (x:xs), or (c:cs), or (y:ys), or something like that
00:28:30 <Cale> Sometimes people will write things like xss for a list of lists as well
00:28:38 <edlinde> "single x followed by x's"
00:28:43 <kmc> yeah
00:28:51 <ski> brooksbp : `\a : A. \b : B. c' means `\a : A. (\b : B. c)', if that helps
00:28:56 <Cale> > let (x:xs) = [1,2,3,4] in x
00:28:57 <lambdabot>   1
00:28:59 <Cale> > let (x:xs) = [1,2,3,4] in xs
00:29:00 <lambdabot>   [2,3,4]
00:29:10 <Jafet> x's is legal, actually
00:29:21 <edlinde> and when you do a let.. in?
00:29:26 <edlinde> what does that do really?
00:29:31 <edlinde> is this a declaration?
00:29:38 <Cale> It makes some definitions local to an expression
00:29:44 <c_wraith> > let 3 = 5 in 3
00:29:45 <lambdabot>   3
00:29:50 <Cale> The whole (let ... in ...) expression evaluates to a value
00:29:51 <ski> edlinde : it declares (and gives values for) a bunch of variables that are local to an expression
00:29:54 <edlinde> Cale: is this similar to scoping?
00:29:57 <Cale> yeah
00:30:05 <edlinde> ok
00:30:13 <tensorpudding> the variables bound in a let are scoped to the statement after in
00:30:16 <Cale> The stuff you define in the 'let' portion scopes over the expression in the 'in' portion
00:30:19 <ski> > let x = 2 in (let x = 3 in x + x) * x
00:30:20 <lambdabot>   12
00:30:26 <Jafet> > let 2+2=3 in 2+2
00:30:27 <lambdabot>   3
00:30:29 <tensorpudding> they can shadow variables defined elsewhere
00:30:37 <kmc> edlinde, "let" gives a name to an expression locally
00:30:42 <c_wraith> Cale: and the other bindings in the same let block
00:30:44 <ski> edlinde : ^ see how the "outer" `x' there is not the same variable as the "inner" `x'
00:30:48 <Gracenotes> > case [1, 2, 3, 4] of (x:xs) -> "Top element is "++show x; [] -> "No top element, empty"  --case construct, too... more pattern matching
00:30:49 <Cale> Of course, everyone has to show the weird and confusing corner cases first ;)
00:30:49 <lambdabot>   "Top element is 1"
00:30:49 <kmc> edlinde, in particular, it *doesn't* execute side effects, or "assign" in any destructive sense
00:31:00 <ski> edlinde : that expression above simplifies to `(3 + 3) * 2', btw
00:31:20 <edlinde> ski: yep I got that one :)
00:31:37 <edlinde> the syntax is actually quite simple ... I mean atleast when you put it this way
00:31:59 <edlinde> I suppose its way too basic at the moment and gets more complex later on
00:32:05 <ski> edlinde : using `where' is similar to `let', except it's in "the other order", and `where' only attaches to defining equations .. you can't just add it inside an expression
00:32:38 <ski> > let x = y + y where y = 4 in x  -- here the `where y = 4' attaches to `x = y + y'
00:32:39 <lambdabot>   8
00:32:44 <kmc> edlinde, Haskell syntax is not too complicated.  a lot of it is just "syntactic sugar" which translates into simpler forms in a well-defined way
00:32:56 <Cale> The syntax has a certain 'natural' feel to it. It's complicated compared to something like scheme, but it's well-designed so it doesn't feel too complicated when you're using it.
00:33:11 <ivanm> copumpkin: "on a bender" == "went out and got smashed", usually implying doing some kind of property, etc. damage along the way
00:33:21 <edlinde> Cale: to be honest it doesn't look so complicated to me
00:33:22 <copumpkin> ivanm: nope, didn't drink much
00:33:34 <ski> edlinde : if you were writing this in a source file, you could just write `x = y + y where y = 4', and that would define `x' (`y' is a local variable, that is not visible outsie the body of the definition of `x')
00:33:52 <brooksbp> So... \f.\y.(f (f y)) can be typechecked by "f takes a type (t->t) and returns \y.(f (f y)) which is of type (t->t) so the resulting type is (t->t)->(t->t)" ORRRRRR typechecked by "f takes type (t->t), y must be type t, and (f (f y)) is type t, so the resulting type is (t->t)->t->t"
00:33:53 <edlinde> ok cool
00:34:16 <Cale> edlinde: There are some tricky bits. One is that there are arbitrarily many infix operators, and you're allowed to define the associativity and precedence level of them in the same module where you're defining and using them :)
00:34:26 <edlinde> I seem to understand the part now about how haskell or fp in general is about defining the problem
00:34:31 <ski> brooksbp : yes, those two explanations are the same thing
00:34:34 <edlinde> and not talking about HOW to solve it
00:35:04 <Cale> edlinde: Not as much, anyway. You're defining the problem in a way that constitutes a solution somehow :)
00:35:15 <edlinde> Cale: oh I am sure there are caveats but I mean the syntax isn't as convoluted... its pretty clean if you think about it
00:35:33 <Cale> yeah
00:35:44 <edlinde> Cale: but it seems more mathematical in some sense... which is nice
00:35:47 <copumpkin> ivanm: lots of sin though
00:36:00 <ivanm> copumpkin: new gf, or lots of one night stands?
00:36:16 <copumpkin> something closer to the former
00:36:32 <ivanm> *nod*
00:36:36 * DigitalKiwi wishes he had a new gf :(
00:36:47 <edlinde> ok gtg now... but thanks for the quick tutorial guys :) will come back with more concrete problems when I try coding
00:36:55 <ivanm> DigitalKiwi: hey, I've never even had an _old_ one...
00:36:56 <Cale> edlinde: sure :)
00:36:58 <copumpkin> new gf implies losing old gf, which isn't always pleasant
00:36:59 <edlinde> thanks!
00:37:01 <tactics> DigitalKiwi: The new ones _are_ better than the old ones :)
00:37:03 * ski gently points in the direction of #haskell-blah
00:37:12 * DigitalKiwi tells some sob story, you feel pity, and hook him up with a hot chick who likes nice guys
00:37:15 <ivanm> ski: fine then
00:37:48 <DigitalKiwi> 02:36 < copumpkin> new gf implies losing old gf, which isn't always pleasant
00:37:51 <tactics> Can someone explain to me why \x y -> x + y is a supercombinator, but \x -> x + y isn't? Isn't the (+) operator free in both?
00:37:53 <DigitalKiwi> not necessarily...;D
00:37:58 <kmc> copumpkin, not always
00:38:05 <copumpkin> we should move it to blah
00:38:14 <kmc> "so i said, supercombinator? i hardly know her!"
00:38:16 * kmc rimshot
00:38:21 <DigitalKiwi> i'm already in like 22 channels ;_;
00:38:55 * DigitalKiwi has 93 buffers open :(
00:39:15 <Cale> http://i.imgur.com/G07TI.jpg MOAR OFFTOPIC
00:39:16 <ivanm> DigitalKiwi: heh
00:39:36 <DigitalKiwi> Cale: i lawled
00:39:37 <Cale> With the picture, that headline is perfect
00:39:43 <ivanm> Cale: here you are: http://i.imgur.com/EkfZP.png
00:39:54 <ski> tactics : maybe i'm recalling wrong, but i'm imagining that the difference is that `(+)' has one global definition (so it itself is a supercombinator), while `y' in `\x -> x + y' would probably be assumed to not be such, instead being a parameter to a function "further out"
00:40:25 <Cale> ivanm: heh
00:40:32 <ski> (tactics : of course, if you define `y = 42' in your program, then `\x -> x + y' would be a supercombinator by that analysis)
00:41:07 <tactics> but in a pure language like haskell, isn't an unbounded variable like y constant anyway?
00:41:36 <ivanm> Cale: and http://28.media.tumblr.com/tumblr_l0yj0pdFlP1qzqtumo1_500.jpg
00:41:54 <Cale> ivanm: yeah, saw that one :)
00:42:15 <tactics> There isn't a sharp distinction between top-level and unbounded in lambda calculus anyway, thus the confusion :)
00:42:16 <DigitalKiwi> ivanm: i don't get why there is a box
00:42:24 <DigitalKiwi> ofc i don't have an iphone or ipad and never will
00:42:27 <ivanm> DigitalKiwi: no flash on iPad
00:42:30 <ivanm> or iPhone
00:42:34 <DigitalKiwi> oh
00:42:47 <DigitalKiwi> OH
00:42:49 <DigitalKiwi> lmao
00:43:00 <ski> tactics : `y' in `\x y -> x + y' is not a "constant", in the sense that when that expression is used, `y' might have different values in different circumstances
00:43:32 <ski> (tactics : of course, *within* a specific application of that function, `y' will always have the same value, though)
00:44:32 <ski> tactics : also, your program won't run if you have variables in it which are not bound anywhere (including not bound in imported libraries)
00:45:27 <tactics> ah, I think I get it
00:46:06 <tactics> ski: So in your program text, if you see the expression " \x -> y + x" in two different places, you can't guarantee they are equalivalent functions, yes?
00:46:33 <ski> (on the topic of off-topic pictures : <http://imagebin.ca/img/dBlVY8r.jpg>)
00:46:55 <ski> tactics : right, because the free `y's in them might refer to different binding locations of `y'
00:47:51 <tactics> I think I get it. Thanks :)
00:51:23 <edlinde> ah guys just one last question, are there any good haskell books you guys recommend?
00:51:30 <edlinde> "real world haskell"?
00:51:58 <edlinde> is there so to say a definitive guide for haskell?
00:52:02 <erikc> that's the only good one imo
00:52:31 <edlinde> ok
00:53:08 <LeNsTR> http://learnyouahaskell.com/
00:56:03 <ski> @where rwh
00:56:03 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
00:57:14 <ivanm> edlinde: as in tutorial book?
00:57:22 <ivanm> I recommend "craft of functional programming"
00:57:45 <edlinde> ok
00:58:49 <kulin> are there any good haskell libraries for string matching? I do not need a full on regex unless that is the best option, a lexer might be better for my purposes
00:59:49 <Jafet> There is parsec, if you want to parse things
01:00:18 <Jafet> And then there is simply reads
01:00:22 <tactics> If kulin thinks regexes are heavy weight, parsec is even heavier
01:00:41 <Jafet> Well, regex isn't heavy for parsing, it's simply incorrect
01:00:49 <Jafet> At least, if they're regular.
01:00:58 <ski> (Alex is a lexer)
01:01:48 <kulin> great thanks, ill look at alex and parsec
01:02:38 <ski> there's also Happy, which is a more traditional sort of yacc-like grammar tool
01:02:45 <DigitalKiwi> things i find i want, ncmpcpp without the mpd, wicd without the python, EAC without the windows, pacman clone without the C, aur helper without the <anything but haskell>, pastebin client, rtorrent without the lack of control...what should i start with? :D
01:03:08 <ski> but you should look at parser combinator libraries like Parsec too, imo
01:04:08 * ski wonders what a pastebin client is, in this case
01:04:51 <Jafet> hpaste, perhaps
01:04:59 <ski> (.. maybe like a command-line tool or emacs command for sending a file/buffer to a paste site ?)
01:06:11 <ski> @where hpaste.el
01:06:11 <lambdabot> http://haskell.org/haskellwiki/Hpaste.el
01:10:03 <DigitalKiwi> http://kiwi.github.com/curlpaste/ ski
01:10:08 <DigitalKiwi> one i wrote in lua
01:10:27 <DigitalKiwi> http://github.com/Kiwi/curlpaste
01:11:51 <DigitalKiwi> curlpaste file, or curlpaste -x (to post from clipboard, or somecommand | curlpaste, or somecommand --stdin + other options, or curlpaste file -s service -l language, etc...
01:11:55 <DigitalKiwi> it's pretty cool
01:12:11 <ski> i see
01:12:19 <DigitalKiwi> posts to codepad by default, supports the run flag for codepad with -r
01:12:51 <DigitalKiwi> http://kiwi.github.com/curlpaste/help.txt
01:28:46 <dobblego> what additional laws does a pointed functor have
01:28:56 <fax> none
01:29:12 <dobblego> thanks
01:29:42 <kmc> fmap f (pure x) = pure (f x) ?
01:31:11 <kmc> yeah, that's in typeclassopedia
01:31:16 <kmc> fmap g . pure = pure . g
01:31:27 <dobblego> ah righto cheers
01:31:46 <kmc> "However, you need not worry about it: this law is actually a so-called "free theorem" guaranteed by parametricity; it's impossible to write an instance of Pointed which does not satisfy it."
01:32:10 <kmc> but of course you can cheat ;P
01:32:26 <dobblego> that's interesting
01:32:34 <fax> @free point :: a -> Maybe a
01:32:34 <lambdabot> $map_Maybe f . point = point . f
01:32:39 <fax> @free point :: a -> Fe a
01:32:39 <lambdabot> $map_Fe f . point = point . f
01:32:44 <kmc> :t \g -> fmap g . pure
01:32:45 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> a -> f b
01:33:07 <kmc> fax, cool
01:33:10 <kmc> is Fe some particular functor?
01:33:15 <fax> I meant F
01:33:19 <kmc> oh heh
01:33:21 <fax> I was trying to get it to say $fmap
01:33:30 <fax> $map_F is the best I can do
01:33:35 <kmc> so @free will invent $map_Foo for any tycon?
01:33:42 <kmc> @free point :: a -> Foo a
01:33:42 <lambdabot> $map_Foo f . point = point . f
01:33:44 <kmc> @free point :: a -> F a
01:33:44 <lambdabot> $map_F f . point = point . f
01:34:07 <fax> @free l :: F a -> G a
01:34:07 <lambdabot> $map_G f . l = l . $map_F f
01:34:34 <ski> @free e :: Endo a
01:34:34 <lambdabot> $map_Endo f e = e
01:37:30 <fax> ski that's wiked because it's true even though it doesn't know what Endo is
01:37:53 <fax> it's saying that the only function forall a. a -> a is identity
01:37:58 <ski> well, i suppose there's only one (total) element of `forall a. Endo a'
01:37:59 <fax> at least that's how I read it
01:38:01 <ski> *nod*
01:38:11 <ski> so, it's a too simple example, i suppose
01:38:31 <ski> (but i'm not sure one can do "better" (i.e. worse))
01:39:54 <fax> im going art
01:39:57 <fax> bye
01:40:03 <ski>   (: (\ l (\ a `(,l a))) (-> (-> f g) (all (: a set) (-> (f a) (g a)))))
01:41:19 * ski ponders
01:43:00 <ski>   forall a. f a -> forall b. g a b -> h a b
01:43:12 <ski>   forall a. f a -> (g a -> h a)
01:45:07 * ski is wondering what currying means for natural transformations ..
01:48:24 <Cale> ski: Work out what exponential objects are in the category of functors, I guess.
01:58:46 <Kaidelong> what could cause "minimumBy" to leak memory?
01:59:27 <Kaidelong> or does haskell just keep using up memory until it has to release it?
01:59:40 <Kaidelong> rather than releasing it the moment something will not longer be used
01:59:50 <kmc> it releases it when the garbage collector runs
01:59:54 <kmc> though not necessarily back to the OS
01:59:58 <kmc> but back to the internal allocation pool
02:00:04 <kmc> i assume that by "Haskell" you mean GHC's implementation
02:00:19 <Kaidelong> yeah, I take it that's a good assumption to make?
02:00:23 <Kaidelong> sorry I wasn't clearer about that
02:00:24 <kmc> which?
02:00:28 <kmc> yeah, most people use GHC
02:00:44 <kmc> but it's worth separating what would have to be the case from what GHC does but might have done differently
02:00:45 <kmc> anyway
02:01:01 <kmc> i see that minimumBy uses foldl1
02:01:12 <Kaidelong> I've noticed that laziness has been a bit of a pain, in parts of my application where I think I should be fine or even see an advantage I often find stack or heap overflows due to accumulation of a thunk or something
02:01:15 <kmc> and not foldl1'
02:01:20 <kmc> yes
02:01:45 <kmc> you could take the defn of minimumBy from http://www.haskell.org/ghc/docs/6.10-latest/html/libraries/base/src/Data-List.html#minimumBy
02:01:49 <kmc> and change it to use foldl1'
02:01:58 <kmc> which will strictly evaluate the applications of minBy
02:02:10 <kmc> instead of building a chain of thunks
02:02:30 <kmc> laziness is tricky
02:03:09 <kmc> i think this sort of issue is one of the biggest obstacles to Haskell becoming more widely used
02:05:06 <Kaidelong> why would foldl1 build a chain of thunks anyway if the lists themselves is lazy?
02:05:14 <Kaidelong> are
02:05:20 <kmc> i don't follow
02:05:32 <Kaidelong> I mean, you could just store "fold this list"
02:05:45 <Kaidelong> rather than generate some huge expression
02:05:49 <kmc> right
02:06:50 <kmc> nothing in Haskell is forced at application in an absolute sense
02:07:04 <kmc> every strictness annotation is a way of saying "when you force that, force this first"
02:07:24 <kmc> foldl has a well-known problem with excessive laziness
02:08:08 <kmc> and i think it happens once you force the foldl expression
02:09:24 <kmc> the specific change in foldl' is to force the accumulator before forcing the result of the fold over the tail
02:09:42 <Kaidelong> foldl's implementation baffles me a little
02:09:49 <kmc> the primed one or the regular one?
02:09:51 <kmc> @src foldl
02:09:51 <lambdabot> foldl f z []     = z
02:09:51 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
02:09:55 <Kaidelong> regular one
02:10:00 <kmc> what about it
02:10:09 <Kaidelong> well I jsut read up about it
02:10:15 <kmc> it's "tail recursive", but that's less important in a lazy setting
02:10:17 <Kaidelong> apparently it constructs a huge thunk when it is called
02:10:23 <kmc> when it's forced, yes
02:10:26 <Kaidelong> rather than yeah, continuing
02:10:31 <kmc> that's why we have foldl'
02:10:35 <kmc> @src foldl'
02:10:35 <lambdabot> foldl' f a []     = a
02:10:35 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
02:11:14 <Kaidelong> right, given what I've been working on so far I've been assuming "if it's tail recursive, it uses constant memory so long as the parameters themselves do not grow"
02:11:30 <Kaidelong> learning that in haskell this is not the case has been a big surprise for me
02:11:32 <Jafet> Does ghc -O2 normally fix this?
02:11:37 <kmc> correct, it's not the case
02:11:39 <Kaidelong> because parameters will grow when you aren't expecting it
02:11:42 <kmc> Jafet, i don't know why it would
02:12:04 <Jafet> I use foldl often and this has never come up
02:12:07 <kmc> in particular, if the accumulator function itself produces results lazily
02:12:12 <kmc> then you don't want the strictness of foldl'
02:12:31 <kmc> there's a reason foldr is nicer than either foldl or foldl'
02:12:35 <Kaidelong> Jafet: I'm using lists in the same context of F# seqs to generate huge amounts of values
02:12:59 <kmc> in fact i'm not sure why maximum uses foldl1 instead of foldr1
02:13:06 <Kaidelong> minimumBy was causing overflows and this flabbergasted me
02:14:14 <mercury^> kmc: yeah, foldl' would make some sense over foldr, foldl has no advantages as far as I can see.
02:14:44 <mercury^> kmc: but then, it's not worse either.
02:14:52 <kmc> worse than what?
02:14:56 <kmc> foldl does a lot more work than foldr
02:15:00 <mercury^> Worse than foldr for maximum.
02:15:06 <kmc> oh
02:15:16 <Kaidelong> from what I see in this wiki entry
02:15:21 <kmc> because you have to force the whole computation before you get any of the accumulator, yeah
02:15:26 <Kaidelong> foldl does do more work than foldr
02:15:27 <kmc> but that's not true of every accumulating function
02:15:32 <Kaidelong> not asymptotically more, but more
02:15:42 <kmc> Kaidelong, «foldr f z» just replaces each (:) with f and [] with z
02:15:48 <kmc> it preserves the list structure
02:15:49 <mercury^> I don't see why it would do more work for maximum.
02:15:51 <Kaidelong> http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl%27
02:16:00 <ski> Kaidelong : the problem above is that the parameters themselves *do* grow
02:16:22 <Kaidelong> ski: yeah, that was the epiphany, the parameters are thunks, not values
02:16:30 <ski> Kaidelong : `f z x' is a larger parameter than `z'
02:16:30 <Gracenotes> foldl can work with functions that don't return thunks.. namely constructors..
02:16:46 <kmc> ah, that explains why they use foldl
02:16:49 <kmc> instead of foldr
02:18:08 <ski> Kaidelong : maybe you you say "foldl does do more work than foldr" you really mean that `foldl' is a bulk operation, while `foldr' is not (necessarily)
02:18:27 <ski> (more clear : `foldr' can be incremental)
02:18:29 <Kaidelong> ski: I don't understand your terminology, sorry
02:19:41 <ski> Kaidelong : `foldr (\n ns -> (n*n):ns) ns2 ns' does its work in small incremental steps .. each step is done when you force one cell of the resulting list
02:21:20 <kmc> map f = foldr ((:) . f) []
02:21:23 <ski> Kaidelong : otoh `foldr (\ns s -> (n*n):ns) ns2 ns' does all its (traversal) work in one big lumb .. you either don't force it; or you force it all in one bulk operation, after which forcing the individual resulting list cells doesn't do much work
02:22:26 <kmc> :t ((:).)
02:22:27 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f ([a] -> [a])
02:22:38 <ski> @type ((:) Prelude..)
02:22:39 <lambdabot> forall b a. (a -> b) -> a -> [b] -> [b]
02:23:35 <Kaidelong> Thank you ski, I can't really claim to understand it fully yet but I have a vague idea and maybe I'll get it after a few weeks
02:23:44 <ski> (hrm, sorry, `foldr' in that latter `foldr (\ns s -> (n*n):ns) ns2 ns' example should have been `foldl')
02:24:17 <Kaidelong> What I think is going on is that foldr can be partially evaluated for some intermediate value while foldl can't?
02:24:51 <kmc> right
02:25:24 <ski> yes, `foldr' can be "incremental"
02:25:27 <kmc> foldr builds expressions like (a # (b # (c # ... not computed yet)))
02:25:40 <Kaidelong> why would you use that instead of a scan?
02:25:42 <kmc> and maybe (#) is defined such that it can produce some result before forcing its right hand argument
02:25:52 <kmc> as is the case with ((:) . f)
02:25:56 <ski> `foldr' always have to traverse the whole list, before any output can be observed (this is a direct consequence of it being tail-recursive)
02:26:00 <kmc> which is why foldr ((:).f) [] is as lazy as map
02:26:16 <kmc> foldl builds expressions like (((a # b) # c) # ... not computed yet ...)
02:26:34 <ski> Kaidelong : "scan" as in ?
02:26:44 <Kaidelong> scanl, scanr
02:26:45 <xcthulhu> Sourceforge appears to be down.  Does anyone know of a mirror where I can get gtk2hs?
02:26:49 <kmc> Kaidelong, the issue of fold vs scan is orthogonal to all this
02:27:02 <kmc> a scan is just a fold that remembers intermediate values of the accumulator in a list
02:27:22 <ski> Kaidelong : note that `(#)' above was meant to be an arbitrary function
02:27:27 <kmc> it could still be strict or lazy in the accumulator
02:27:41 <Jafet> > trace "lalala" 1
02:27:42 <lambdabot>   Not in scope: `trace'
02:27:48 <Jafet> > Debug.Trace.trace "lalala" 1
02:27:49 <lambdabot>   Not in scope: `Debug.Trace.trace'
02:27:54 <kmc> no unsafePerformIO in lambdabot ;P
02:28:03 <Jafet> It could be a WriterT!
02:28:10 <kmc> lambdabot will however safely evaluate IO actions for you
02:28:10 <kmc> ;P
02:28:31 <Jafet> Is there a command for execution?
02:28:33 <kmc> no
02:28:50 <Jafet> Outrageous
02:29:10 <Jafet> lambdabot is clearly not the world's finest imperative sandbox
02:29:22 <kmc> that'd be geordi
02:29:28 <ski> @let traceJ :: (Monoid w,MonadWriter w m) => w -> a -> m a; traceJ w a = liftM (const a) (tell w)
02:29:29 <lambdabot>   MultiParamTypeClasses is not enabled
02:29:35 <ski> bah!
02:29:37 <kmc> outrageous!
02:30:33 <ski> (strange that `@type' accepts it, though ..)
02:37:22 <Kaidelong> hmm, so foldl' is lazy until it is forced?
02:37:33 <kmc> not sure what that means
02:37:33 <Kaidelong> so using it basically stores a "fold this list"
02:37:40 <kmc> everything is lazy until forced
02:37:40 <Kaidelong> until you need the actual folded list
02:37:43 <Kaidelong> okay
02:37:54 <Kaidelong> I just wanted to make sure I understood, still very new to haskell
02:37:54 <kmc> so, yes :)
02:38:23 <Kaidelong> that's actually nice, or so it seems to me now
02:38:32 <kmc> yeah it works out all right
02:38:55 <kmc> there's no such thing as an absolutely strict function
02:39:12 <ski> `id' is strict
02:39:26 <Kaidelong> what about things in IO or ST monads?
02:39:39 <Kaidelong> also not evaluated until forced?
02:39:43 <benmachine> I think what we mean here is that there's no function that forces evaluation just by existing
02:39:48 <benmachine> which is true
02:39:51 <Kaidelong> or does the left arrow for an evaluation?
02:39:55 <Kaidelong> force even
02:40:01 <kmc> what i mean is, if you write "let x = f y in ...", and never mention x, there's no "f" that already applies to y
02:40:07 <kmc> Kaidelong, the <- arrow in "do" is just sugar
02:40:18 <ski> Kaidelong : no, it forces execution in the monad (which might not necessarily do much, depending on the monad)
02:40:20 <kmc> do { x <- a; b }  ==>   a >>= (\x -> b)
02:40:34 <ski> (note the difference between "execution" and "evaluation")
02:40:37 <chrisdone> hi
02:40:45 <ski> lo
02:40:49 <kmc> Kaidelong, and when (>>=) forces its arguments depends on the monad, since it's a type class method
02:40:59 <Kaidelong> that makes sense
02:41:08 <Kaidelong> I was thinking of the IO and ST monads, specifically
02:41:13 <kmc> Kaidelong, but the idea behind ST and IO is emphatically not "force evaluation so side effects order correctly"
02:41:26 <kmc> it's "disentangle execution from evaluation entirely"
02:42:24 <kmc> if you want to observe evaluation order, you can use Debug.Trace.trace
02:42:25 <benmachine> well fundamentally evaluation only ever starts forcing because of something that is done by main
02:43:04 <kmc> evaluation can be forced by execution or by other evaluation
02:43:16 <kmc> by execution because you have to know what an action is before you execute it
02:43:39 <kmc> by evaluation because forcing a pattern match requires forcing the scrutinee far enough to compare against the patterns
02:43:53 <kmc> and because of things like seq that set up an explicit artificial relationship
02:45:15 <Kaidelong> so that's why you can use a dummy pattern match that doesn't do anything to force parameters to get evaluated?
02:45:27 <kmc> how so?
02:45:37 <kmc> that works in some intermediate languages like Core but not in Haskell
02:45:44 <kmc> > case undefined of _ -> ()
02:45:45 <lambdabot>   ()
02:45:49 <kmc> > case undefined of !_ -> ()
02:45:50 <lambdabot>   <no location info>: Illegal bang-pattern (use -XBangPatterns)
02:46:00 <kmc> hmm, lambdabot got -XViewPatterns and lost all the rest?
02:46:24 <ski> > id $ undefined
02:46:25 <lambdabot>   *Exception: Prelude.undefined
02:46:25 <ski> > id $! undefined
02:46:26 <lambdabot>   *Exception: Prelude.undefined
02:46:32 <ski> er, .. right :)
02:46:33 <benmachine> > let seq () y = y in undefined `seq` 0
02:46:34 <lambdabot>   *Exception: Prelude.undefined
02:46:36 <ski> > const () $ undefined
02:46:37 <lambdabot>   ()
02:46:39 <ski> > const () $! undefined
02:46:40 <lambdabot>   *Exception: Prelude.undefined
02:46:41 <chrisdone> @info Identity
02:46:41 <lambdabot> Identity
02:46:46 <chrisdone> thanks lb
02:46:46 <benmachine> > let seq () y = y in () `seq` 0
02:46:47 <lambdabot>   0
02:46:56 <Kaidelong> > (\x -> case (id x) of ()) undefined
02:46:57 <lambdabot>   <no location info>: parse error on input `)'
02:46:59 <chrisdone> :t runIdentity
02:46:59 <lambdabot> forall a. Identity a -> a
02:47:09 <chrisdone> @hoogle runIdentityT
02:47:10 <lambdabot> No results found
02:47:18 <ski> Kaidelong : missing `->' in the branch
02:47:26 <chrisdone> wops
02:47:28 <Kaidelong> > (\x -> case (id x) of _ -> ()) undefined
02:47:29 <lambdabot>   ()
02:47:46 <chrisdone> yeah if you write all your code in the Identity monad
02:47:57 <ski> > (\x -> case x of _ -> ()) undefined
02:47:58 <lambdabot>   ()
02:48:03 <chrisdone> can you quickly swap it or transform it to Writer(T)?
02:48:05 <ski> > (\_ -> ()) undefined  -- really the same thing
02:48:06 <lambdabot>   ()
02:48:12 <Kaidelong> > (\x -> case (id x) of 0 -> ()) undefined
02:48:12 <chrisdone> then output some "logs" to see the evaluation order
02:48:13 <lambdabot>   *Exception: Prelude.undefined
02:48:38 <kmc> Kaidelong, "case" will force evaluation if one of the arms has a pattern that's not trivially matched
02:48:45 <Kaidelong> what about if you put in a guard of "False"
02:48:48 <kmc> i.e., if it needs to see what the value is to see if it matches
02:48:51 <Kaidelong> after a pattern
02:49:01 <benmachine> Kaidelong: the pattern is matched before the guards execute
02:49:02 <kmc> Kaidelong, then all the forcing required by that pattern will still occur
02:49:12 <kmc> > case undefined of Nothing -> ()
02:49:13 <lambdabot>   *Exception: Prelude.undefined
02:49:19 <kmc> > case undefined of Nothing | False -> ()
02:49:20 <lambdabot>   *Exception: Prelude.undefined
02:49:29 <ski> chrisdone : maybe my <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10060> would be sortof what you're thinking of ?
02:49:36 <kmc> > case undefined of _ | False -> 0; | otherwise -> 1
02:49:37 <lambdabot>   <no location info>: parse error on input `|'
02:49:40 <kmc> > case undefined of _ | False -> 0 | otherwise -> 1
02:49:41 <lambdabot>   1
02:49:48 <kmc> > case undefined of () | False -> 0 | otherwise -> 1
02:49:49 <lambdabot>   *Exception: Prelude.undefined
02:50:16 <chrisdone> ski: exactly!
02:50:21 * chrisdone bookmarks
02:50:40 <ski> chrisdone : that only handles the (monomorphic) self-recursion case, though
02:50:52 <kmc> chrisdone, probably not; only the execution order, not the evaluation order
02:51:25 <ski> chrisdone : note how i used `Rank2Types' for information hiding in `trivialFix' and `traceFix' :)
02:51:27 <chrisdone> kmc: yeh true
02:53:40 <chrisdone> ski: no I don't see why you did that. can you explain?
02:53:43 <ski> (.. also, that use of `Rank2Types' ensures that the code that is being traced is essentially pure, since it doesn't know which monad it will run it)
02:54:11 <ski> well, i didn't want to expose the exact monad i used for implementing `traceFix', in the type of it
02:54:11 <chrisdone> ohhh
02:54:24 <chrisdone> i missed the closing paren on l34
02:55:18 <ski> also, doing that ensures that the argument function can't do any effects in the monad (like inserting bogus tracings) .. the only way it can do effects is by calling itself "recursively" (i.e. calling the argument), which is a version of itself wrapped in code that emits a trace point
02:56:17 <chrisdone> clever!
02:57:30 <ski> hm, i realize i forgot to include the definition of `Traced' there .. it's just a shorhand `type Traced a b = a -> Trace a b', though
03:01:55 <ski> (hm, or maybe it actually was `type Traced a b = a -> (Trace a b,b)', now that i think of it)
03:02:52 <chrisdone> yeah i think it was
03:03:17 <chrisdone> tracefix :: .. ->  (a -> (Trace a b,b))
03:03:38 <ski> m
03:04:19 <chrisdone> :t runST
03:04:20 <lambdabot> forall a. (forall s. ST s a) -> a
03:04:45 <ski> one could probably make variants of this that allowed the user function to use specific effects in some monad
03:05:26 * ski is not sure how to parameterize that nicely, though
03:05:26 <chrisdone> with a class?
03:05:56 <ski> well, instead of having `Monad' in there, you could have `MonadIO', and then an `IO' in the result
03:06:14 <chrisdone> yeah
03:06:53 <ski> so the argument should use "any monad that supports `Foo'", and the result would be a standard monad supporting `Foo'
03:06:58 <chrisdone> could have Effectable a
03:07:05 <chrisdone> yeah
03:07:09 <ski> .. hm, or i suppose the result could be "any monad that supports `Foo'", as well
03:07:41 <ski> (though that's strictly not necessary .. you can always inject yourself)
03:08:12 <chrisdone> you could separate FileIO from SocketIO and ThreadIO, I guess
03:08:48 <ski> m. the thing i'm not sure to do is how to abstract this over all these possible specific kinds of effects
03:09:06 <chrisdone> yeah
03:09:28 <ski> for each specific kind of effect, we want a class constraint that is satisfied by any monad having at least that specific kind of effect
03:09:37 <ski> something like `MonadBase', perhaps
03:10:18 <ski> but i suppose it's not clear how `StateT Foo IO' would work as a "specific kind of effect", then
03:10:41 <chrisdone> how do they implement the class though? arbitrary IO ? wouldn't you have to provide them with the IO functions so they couldn't just do launchMissiles
03:11:14 <ski> i'm not sure what you're asking about
03:11:33 <ski> in the `IO' case, this'd be something like
03:11:56 <chrisdone> n/m
03:12:36 <chrisdone> MonadIO you can run any IO action. i was thinking you could have MonadThreads or MonadSockets, for example
03:12:55 <ski>   traceIOFix :: (forall m. MonadIO m => (a -> m  b) -> (a -> m  b))
03:12:56 <ski>              ->                         (a -> IO b)
03:13:03 <chrisdone> yeh
03:13:21 <ski> er, s/b/(Trace a b,b)' in the latter line
03:13:56 <ski> yes, compartmenalizing `IO' into smaller blocks might be useful, as a separate thing
03:14:02 <chrisdone> right
03:14:55 <ski> Clean has something like that, where you can split the `World' into smaller subsystems of file-system, graphics, ..
03:15:03 <chrisdone> that's cool
03:15:15 <chrisdone> would be good for plugins and stuff
03:15:20 <ski> (and then you can piece together things again, iirc)
03:15:43 <Twey> But there's sure to be a lot of leakageâ¦
03:15:51 <ski> that's related to one of the critisisms in Clean of the `IO' monad : it oversequentialized thigs, often
03:16:43 <ski> aiui, they can decompose their state into several independent ones, and then those don't have to be sequentialized wrt each other .. just use lazy evaluation to compute in the order that things are demanded
03:16:59 <ski> with `IO', you can use threads, of course
03:17:20 <ski> (i'm not very familiar with the details of how the aboce works in Clean, though)
03:18:02 <mm_freak> arcatan: ircSendCmd, ircSendMsg, ircSendString
03:18:34 <mm_freak> arcatan: the next release will contain Bot functions like botJoin, but in the current one you have to do something like that
03:21:38 <Twey> mm_freak: A new IRC IO library?
03:22:56 <mm_freak> Twey: http://hackage.haskell.org/package/fastirc
03:23:02 <Twey> Oh, that one
03:23:12 <Twey> Yeahâ¦ why doesn't it use Network.IRC?
03:23:34 <mm_freak> because then i wouldn't call it 'fastirc' ;)
03:23:48 <Twey> You think it's slow?
03:23:55 <mm_freak> yes
03:24:02 <Twey> Why?
03:24:07 <mm_freak> the 'irc' library is a simple IRC parser using String/Parsec
03:24:15 <pippijn> what kind of demands do you have that require a fast irc parser?
03:24:26 <mm_freak> fastirc uses ByteString/attoparsec and does much more than parsing
03:24:35 <Twey> mm_freak: Oh, fair enough âº
03:24:47 <Twey> Yeah, but it doesn't do as much parsingâ¦ you don't have the awesome message lookup table âº
03:24:54 <mm_freak> pippijn: IRC servers or multi-user bouncers
03:25:07 <pippijn> that's interesting
03:25:19 <pippijn> are you making such things?
03:25:44 <mm_freak> pippijn: i'm planning to, as soon as i get time to finish fastirc
03:25:50 <mm_freak> to finish = to reach 0.4.0
03:25:56 <pippijn> nice
03:26:13 <mm_freak> Twey: i'm not sure how to make it yet
03:26:54 <mm_freak> Twey: i'll probably just include some functions like numWelcome
03:27:07 <Twey> Also, why ByteString and not Text?
03:27:07 <mm_freak> numWelcome :: Integer; numWelcome = 1
03:27:48 <Twey> mm_freak: A Map might be better
03:27:54 <ivanm> Twey: because attoparsec doesn't support Text... >_>
03:28:09 <Twey> ivanm: Oh, really?  Huh.  :-\
03:28:10 <mm_freak> ivanm: that's one reason, but not even the main one
03:28:30 <mm_freak> the IRC protocol is octet-based and doesn't know anything about character sets and encodings
03:29:06 <Twey> Oh, yeah â duh
03:30:14 <mm_freak> although unfortunately most IRC servers don't follow the standard anyway
03:30:30 <mm_freak> for example according to the standard [ and { are the same character in nicknames =)
03:31:04 <mm_freak> a lot of daemons don't follow this, which makes writing a nickCompare function quite difficult =)
03:31:19 <mm_freak> (or an Ord instance for UserSpec)
03:31:53 <ivanm> mm_freak: :o (the "[ and { are the same")
03:32:01 <ivanm> mm_freak: presumably to make it "case insensitive"?
03:32:02 <Twey> That's weird
03:32:09 <mm_freak> Twey: in this case i'd probably use something like Array, not because O(log n) is slow, but because it's unnecessary
03:32:18 <mm_freak> ivanm: yeah
03:32:30 <mm_freak> "[]\" = "{}|"
03:32:50 <mm_freak> that's because of the origin of IRCâ¦  i don't remember where it comes from
03:32:57 <Twey> mm_freak: Yeah, that's fair
03:33:27 <mm_freak> ah yes: "Because of IRC's scandanavian origin, the characters {}| are considered to be the lower case equivalents of the characters []\,
03:33:40 <mm_freak> respectively. This is a critical issue when determining the equivalence of two nicknames."
03:33:46 <mm_freak> RFC 1459
03:34:18 <mm_freak> /whois |net
03:34:19 <mm_freak> =)
03:36:02 <Twey> Haha, I like that âbecause of IRC's Scandinavian originâ
03:36:21 <chrisdone> i read freenode's source ages ago and it just implements what "the other" irc servers did. funny how that goes
03:36:51 <voker57> can i somehow trace exception's origin?
03:36:51 <chrisdone> writing an ircd in c, though. what a pain in the ass
03:37:12 <Twey> Freenode considers them the same nowadays
03:38:14 <mm_freak> yes, writing anything IRC is a PITA in C
03:38:32 <Twey> s/IRC //
03:38:41 <mm_freak> hehe
03:38:56 <chrisdone> i dunno writing memset is pretty easy
03:38:57 <mm_freak> writing inline assembly is easier in C than in haskell =P
03:39:05 <kbp> could anyone please help me? http://codepad.org/OFuJtkCT I don't know why the 2nd line is wrong
03:39:17 <pippijn> chrisdone: writing a *fast* memset is pretty hard
03:39:28 <mm_freak> chrisdone: mapM_ + writeArray is easy, tooâ¦  just not as fast =P
03:39:31 <ivanm> kbp: your definition is wrong for data
03:39:35 <kmc> kbp, your "data" isn't declaring any constructors
03:39:36 <ivanm> s/data/Var/
03:39:50 <kmc> kbp, and you're trying to test equality between a vaiable and a type
03:39:57 <kmc> i think you misunderstand how "data" works conceptually
03:40:02 <ivanm> kbp: the error says it's the second line because its still trying to find wtf the first line means ;-)
03:40:05 <chrisdone> i meant literally writing "memset(..,..)" not implementing it
03:40:06 <chrisdone> haha
03:40:12 <ivanm> kbp: see the Either type
03:40:14 <ivanm> @src Either
03:40:14 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
03:40:17 <Twey> chrisdone: Haha
03:40:18 <ivanm> grrr....
03:40:22 <kbp> ...
03:40:25 <ivanm> data Either a b = Left a | Right b
03:40:31 <ivanm> it's in the prelude
03:40:44 <ivanm> kbp: so you want: type Var = Either Int [Char]
03:40:56 <chrisdone> hmm
03:41:00 <kmc> ivanm, i disagree, important to learn how to declare these things
03:41:00 <chrisdone> lambdabot's using mueval these days right?
03:41:05 <chrisdone> > fix id
03:41:09 <lambdabot>   mueval-core: Time limit exceeded
03:41:12 <ivanm> test :: Var -> IO (); test Left{} = putStrLn "This is an Int"; etc.
03:41:12 <chrisdone> sweet
03:41:17 <kmc> kbp, i think you want something like this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24900#a24900
03:41:21 <ivanm> kmc: OK, fine, define something _like_ Either
03:41:28 <ivanm> my point was that you want something like that
03:41:34 <mm_freak> chrisdone: sure, but there is no 'memset' equivalent for Array/UArray
03:41:48 <ivanm> kbp: you appear to be trying to use dynamic typing in Haskell, which isn't possible (unless you go all hacky)
03:42:00 <mm_freak> i think there are equivalents for vector/uvector, but i don't know how fast they are
03:42:04 <chrisdone> you could have per-nick and per-chan files
03:42:22 <ivanm> kbp: or else you want some class where Int and [Char] are instances of that class and test is a class method
03:42:22 <kbp> oh I see.. I think I've got the idea how to declare using data now, thank you guys :D
03:42:33 <kmc> kbp, every function takes only one type.  and "Int or String" is not a type.  but "Ints tagged with A, plus Strings tagged with B" is a type
03:42:38 <chrisdone> so i could write
03:42:38 <chrisdone> @data T = T deriving Show
03:42:38 <chrisdone> > T
03:42:38 <lambdabot> Unknown command, try @list
03:42:39 <lambdabot>   Not in scope: data constructor `T'
03:44:56 <pastorn> kbp: fixed it! http://codepad.org/6672OFtQ
03:45:58 <kbp> Let say I have this: data prog_output    = Num Int | List [Int] | Nil | Text [Char] , is there a way to check whether these words "Num, List, Text" are not some special built-in words inside Haskell (such as Int, Double etc.)
03:46:31 <Twey> Â« Line 1: error: expected '=', ',', ';', 'asm' or '__attribute__' before 'Var' Â» â what's CodePad up to?
03:46:37 <pastorn> kbp: none of those are, but in ghci, type ":i Lol"
03:47:00 <pastorn> Twey: well, haskelling in C isn't always successfull :/
03:47:02 <Twey> kbp: Those aren't special built-ins â just the names of some common types
03:47:05 <chrisdone> Twey: cunning source filtering?
03:47:25 <Twey> pastorn: Oh, right.  :Ã¾
03:47:27 <kbp> :i does the trick :)
03:47:35 <Jafet> You can override builtin names, I thought
03:47:37 <miguel000> can i split lines somehow for better reading
03:47:40 <Twey> I was fooled by the fact that it still highlighted âdoâ :Ã¾
03:47:43 <miguel000> like with \ for strings
03:47:44 <pastorn> kbp: when checking ":i Num" you will see that it's taken, but that's not a datatype, that's a typeclass
03:47:53 <Twey> miguel000: Of course, wherever you like so long as you indent
03:48:03 <pastorn> kbp: so it's fine to declare "data Var = Num Int | ..."
03:48:33 <miguel000> indent means: TAB ?
03:48:38 <Twey> kbp: http://codepad.org/AfwcTdmJ
03:49:01 <Twey> miguel000: We generally frown upon using soft-tabs
03:49:02 <pastorn> Twey: thanks :)
03:49:07 <miguel000> ok seems to work fine with tab , thankk you
03:49:10 <Twey> They can be confusing
03:49:11 <pastorn> hpaste seems to work again :)
03:49:19 <miguel000> hmm so just one single space?
03:49:28 <Twey> Or many spaces
03:49:42 <Twey> If you have a decent editor, it should be able to convert for you
03:50:06 <miguel000> allright, thx
03:50:52 <Twey> pastorn: Even if it were a datatype, it would be fine
03:51:34 <Twey> pastorn: Types and typeclasses share one namespace, and values, including data constructors, share another
03:51:43 <pastorn> Twey: he was asking about name conflicts
03:52:19 <Twey> Right
03:52:26 <pastorn> Twey: like how you shouldn't have a constructor called 'GT'
03:52:46 <Twey> But it's fine to have a type called âGTâ (in principle)
03:53:00 <pastorn> dude, i know...
03:53:00 <Twey> 11:47:20 < pastorn> kbp: when checking ":i Num" you will see that it's taken, but that's not a datatype, that's a typeclass
03:53:03 <Twey> 11:47:39 < pastorn> kbp: so it's fine to declare "data Var = Num Int | ..."
03:53:33 <Twey> It's just that this made it seem that it was okay *because* it is a typeclass (and it wouldn't be okay if it were a datatype)
03:53:40 <Twey> Which isn't the case
03:53:46 <Twey> Sorry if I misinterpreted you somehow âº
03:53:59 <pastorn> Twey: just because i don't precisely specify all the ins and outs of how namespace conflicts in haskell works doesn't mean i don't know
03:55:52 <kbp> im still working on how to compare the type instead of the value... because I cannot do pattern matching
03:56:11 <pastorn> kbp: why can't you?
03:56:24 <pastorn> http://codepad.org/AfwcTdmJ <-- this is pattern matching
03:56:46 <kbp> http://codepad.org/o2iujUtu <---- the complexity of the function.... cannot do pattern matching
03:57:15 <ivanm> kbp: sure you can, but I think you're doing it wrong
03:57:44 <ivanm> kbp: also, you want /= , not !=
03:58:24 <kbp> oh that's right...  :)
03:58:43 <ivanm> eval (Var Nil) _ = undefined; eval (Var Cons{}) _ = undefined, eval (Var x) (Vars a _ _ _) | x == a = a; | otherwise = undefined
04:02:12 <pastorn> kbp: are you sure eval should end in IO ()?
04:02:22 <pastorn> don't you want it to have a result of type Val?
04:02:34 <kbp> nah I just wrote it quickly to describe why i couldnt do pattern matching
04:02:49 <pastorn> kbp: i'm doing pattern matching on it
04:02:50 <kbp> so IO() shouldnt be there
04:02:51 <pastorn> it's simple
04:03:28 <kbp> ivanm: thanks for your code but prob you misunderstood my code somehow :)
04:04:46 <kbp> ok nvm I've fixed it... thanks guys :)
04:05:13 <kbp> I just removed all the confusing codes and rewrote it
04:05:40 <pastorn> kbp: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24901 <-- here you have it with pattern matching
04:06:22 <pastorn> it typechecks, so it must be correct
04:07:01 <aavogt> for pastorn's first paste (http://codepad.org/AfwcTdmJ), you can write    test (VInt {}) = ...
04:07:04 <kbp> pastorn: oh I see, using case to fix the pattern matching problem :) cool
04:07:12 <aavogt> which means you don't have to count underscores
04:07:34 <aavogt> I think the parentheses are unnecessary there too
04:08:08 <aavogt> > let f = \Endo{} -> 5 in f mempty
04:08:09 <lambdabot>   5
04:08:23 <aavogt> > let f Endo{} = 5 in f mempty
04:08:24 <lambdabot>   5
04:09:02 <pastorn> kbp: check this out; pattern matching bonanza: http://darcs.mutantlemon.com/omegagb/src/Cpu.hs
04:09:21 <pastorn> (it's a gameboy emulator)
04:09:23 <Twey> kbp: âIO()â isn't some sort of C-like function
04:09:32 <Twey> () is the type returned by the IO action
04:09:40 <Twey> IO Int, IO String, IO ()
04:09:43 <kbp> @@
04:10:46 <kbp> lol i'm just new to Haskell so ... lol @ Cpu.hs
04:11:41 <kbp> Twey: the question says I should put putStrLn if the output is IO()... anyway the IO() in the code I wrote before wasnt supposed to be there :)
04:11:46 <pastorn> kbp: well, it's code from an emulator, os it isn't exactly trivial...
04:17:00 <EvanR> IO(void*, const char*, unsigned long)
04:22:43 <Blkt> could anyone explain me why in Haskell 2010 will be banned "n-plus-k-patterns"?
04:22:53 <Blkt> what's wrong with them?
04:23:40 <Jafet> (+) is a function, not a constructor.
04:23:55 <Jafet> Although I personally would rather they take it the other way and allow string ++ patterns too
04:24:21 <Taejo> Jafet: sounds like you want a logic programming language
04:24:33 <Jafet> What? I thought Haskell was one!
04:24:34 <Twey> You'd have to make an arbitrary decision about what got matched by âfoo ++ _â
04:24:51 <Twey> Blkt: It behaves oddly for non-positive ints
04:24:53 <Taejo> Twey: or choose all of them
04:25:09 <Twey> > let f (n + 3) = n in n 2
04:25:10 <lambdabot>   Couldn't match expected type `t1 -> t'
04:25:10 <lambdabot>         against inferred type `Simpl...
04:25:12 <Twey> Er
04:25:13 <Twey> > let f (n + 3) = n in f 2
04:25:14 <lambdabot>   *Exception: <interactive>:1:145-157: Non-exhaustive patterns in function f
04:25:29 <Jafet> Huh, weird
04:25:31 <Twey> You can achieve the same goals in a more consistent manner using view patterns
04:25:45 <Twey> > let f (subtract 3 -> n) = n in f 2
04:25:46 <lambdabot>   -1
04:26:07 <Twey> Likewise for strings
04:26:19 <arcatan> what is that? o_O
04:26:31 <Twey> > let f (splitAt 3 -> ("foo", rest)) = rest in f "foobar"
04:26:32 <lambdabot>   "bar"
04:26:42 <Twey> arcatan: A view pattern
04:26:58 <Twey> It allows you to apply an arbitrary function to a parameter and match on the result
04:27:00 <Taejo> arcatan: it runs the function before the -> and then matches the result to the pattern after the ->
04:27:24 <Blkt> mmm
04:27:40 <Jafet> > case "asdf" of (splitAt 2 -> ("as", rest)) -> rest
04:27:40 <Twey> Taejo: Elaborate on âor choose all of themâ?
04:27:41 <lambdabot>   "df"
04:28:01 <Taejo> Twey: like prolog
04:28:06 <arcatan> looks handy
04:28:12 <Jafet> So this is the fuss with view patterns
04:28:17 <Twey> Taejo: Ohâ¦ but that would require the result to be in the list monad
04:28:33 <Taejo> something like that
04:28:41 <Taejo> you could do it in any monoid
04:28:43 <Twey> Aye
04:28:59 <Twey> But it changes the type
04:29:02 <arcatan> in which version of GHC are those?
04:29:09 <Taejo> Twey: sure
04:29:24 <Taejo> this is why you want an actual logic programming language
04:29:27 <mercury^> View Patterns have been around for some time.
04:29:45 <mercury^> But they are not a standard part of any language revision, are they?
04:30:15 <Taejo> mercury^: no, they aren't
04:30:31 <mercury^> http://hackage.haskell.org/trac/haskell-prime/query?status=new&status=assigned&status=reopened&state=accepted&milestone=Haskell+2010&order=priority
04:30:36 <mercury^> That list is so frustrating.
04:30:50 <EvanR> how do i get every other element of the list
04:30:52 <Blkt> Twey: I got it now, thanks!
04:30:53 <Taejo> mercury^: why?
04:31:25 <mercury^> Taejo: There were many good proposals, and only a few trivial ones were agreed upon.
04:32:12 <Taejo> mercury^: that was sort of the point. It was an "intermediate" standard, because a more controversial one would take much longer
04:33:00 <EvanR> > let other (x:xs) = x : other' xs; other' (x:xs) = other xs; other [] = []; other' [] = [] in other [1,2,3,4,5,6]
04:33:01 <lambdabot>   Conflicting definitions for `other'
04:33:01 <lambdabot>  In the binding group for: other, other...
04:35:23 <Jonno_FTW> what's the difference between abstract and algebraic datatypes?
04:36:20 <kmc> Jonno_FTW, they are separate concepts
04:36:27 <kmc> "abstract" means that the constructors are hidden
04:36:32 <kmc> so you can't directly build or pattern-match on them
04:36:40 <kmc> you can only manipulate them through the functions given
04:36:42 <EvanR> > let other [] = []; other (x:xs) = x : other' xs; other' (x:xs) = other xs; other' [] = [] in other [1,2,3,4,5,6]
04:36:43 <lambdabot>   [1,3,5]
04:36:54 <kmc> this is "abstract" in that it hides implementation and provides only an interface
04:37:21 <kmc> "algebraic datatypes" are the ones you declare with "data"
04:37:47 <Jonno_FTW> ok
04:37:52 <kmc> each algebraic datatype has zero or more constructors, each of which has zero or more data fields
04:38:00 <Jonno_FTW> are there other non-algebraic datatypes?
04:38:11 <kmc> there are non-algebraic types
04:38:15 <kmc> for example (a -> b)
04:38:19 <EvanR> zero constructors?
04:38:21 <kmc> has no constructors; you can't pattern-match it
04:38:35 <kmc> some people would take the "data" in "datatype" to mean "algebraic"
04:38:50 <kmc> EvanR, allowed with -XEmptyDataDecls
04:38:54 <kmc> also, do you consider Char to be algebraic
04:39:00 <Jonno_FTW> yes
04:39:03 <kmc> semantically, it's like data Char = 'a' | 'b' | 'c' | ...
04:39:09 <EvanR> yes
04:39:11 <kmc> in GHC it's actually like data Char = C# Char#
04:39:18 <kmc> both are algebraic but in vastly different ways
04:39:23 <kmc> and Char# would be non-algebraic
04:39:33 <kmc> but is also a discriminated union of sorts
04:39:49 <EvanR> data Int = ... -2 | -1 | 0 | 1 | 2 ... ;)
04:39:56 <Jonno_FTW> heh
04:40:21 <EvanR> minBound ... maxBound
04:40:24 <kmc> right
04:40:25 <Jonno_FTW> ..2^32
04:40:38 <EvanR> > maxBound :: Int
04:40:39 <lambdabot>   9223372036854775807
04:40:53 <Jonno_FTW> :|
04:40:57 <EvanR> 2^63 - 1
04:43:09 <Jonno_FTW> i get : Prelude> maxBound :: Int
04:43:11 <Jonno_FTW> 2147483647
04:44:18 <EvanR> Int is implementation dependent
04:44:34 <EvanR> you have 2^31 - 1
04:44:47 <Twey> I think that means that lambdabot is on a 64-bit machine, while you're on a 32-bit machine.
04:45:18 <Twey> In Data.Int there are explicit Int32, Int64, &c. types.
04:47:18 <EvanR> > maxBound :: Integer
04:47:19 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Internals.Integer)
04:47:19 <lambdabot>    arising...
04:47:37 <kmc> hehe
04:47:46 <EvanR> i want fancy messages ;)
04:48:06 <EvanR> "Integer is not bounded"
04:48:19 <Twey> That's what it says.  Can't you read?  ;)
04:48:36 <kmc> Helium does that stuff doesn't it?
04:49:17 <kmc> i believe the largest Integer in GHC's implementation is like 256^(2^64)
04:49:32 <kmc> it's doubtful your computer can store an integer larger than that
04:49:39 <EvanR> doesnt it use gmp
04:49:43 <kmc> yeah
04:49:50 <EvanR> that is bounded?
04:50:02 <kmc> it uses a Word64 to store the number of bytes, iirc
04:50:09 <EvanR> lame
04:50:13 <kmc> yeah i know right
04:50:16 <kmc> it should be a recursive data type
04:50:47 <EvanR> data Integer = Integer Sign [Digit]
04:50:48 <EvanR> ;)
04:50:53 <Twey> @src Integer
04:50:53 <lambdabot> data Integer = S# Int#
04:50:54 <lambdabot>              | J# Int# ByteArray#
04:51:02 <Twey> Int#
04:56:35 <EvanR> :t randomIO
04:56:35 <lambdabot> forall a. (Random a) => IO a
05:02:53 <EvanR> randomIO uses what as the seed?
05:03:03 <kmc> system something or other
05:03:08 <ivanm> yeah
05:03:12 <ivanm> I think it's OS-dependent
05:03:14 <kmc> i expect the spec is fairly quiet on the issue
05:03:32 <ivanm> but you're better off not using that because it doesn't update the seed too well or something IIRC
05:03:41 <ivanm> kmc: well, it's an implementation issue...
05:03:46 <EvanR> i mean, if i restart the program is it different or the same
05:03:48 <kmc> also System.Random is slow as balls
05:03:50 <EvanR> undefined?
05:03:51 <ivanm> there's no reason why you shouldn't use random.org to get a seed... >_>
05:03:59 <ivanm> EvanR: I think it's time-based
05:04:01 <kmc> EvanR, probably different
05:04:06 <EvanR> ok
05:04:07 <ivanm> and uses /dev/urandom or something on linux
05:04:14 <theorbtwo> (/dev/u?random)++
05:04:17 <kmc> http://www.haskell.org/ghc/docs/6.10-latest/html/libraries/random/src/System-Random.html
05:04:19 <kmc> look at mkStdRNG
05:04:29 <ivanm> EvanR: it's also computationally expensive to keep setting the system seed all the time, so doing it purely is better
05:04:41 <ivanm> but using mwc-random is probably a better choice
05:05:02 <EvanR> i the RandomGen interface to my generator, but im making ways to make the generator. one is seed from randomIO
05:05:51 <EvanR> im using mwc method, i wish i knew how to make it faster though
05:05:57 <EvanR> maybe i should profile
05:16:40 <EvanR> how do i write a program to evaluate N list elements, but dont do anything with them. to test performance
05:16:50 <EvanR> i seem to be optimizing them away
05:17:27 <twink> seq, evaluate, etc.
05:17:37 <EvanR> im doing seq
05:18:03 <kmc> :t rnf
05:18:04 <lambdabot> forall a. (NFData a) => a -> Done
05:18:11 <EvanR> main = take (10^20) src `seq` return ()
05:18:26 <kmc> seq only forces the argument to WHNF
05:18:32 <kmc> meaning for a list, it will only force the first cons cell
05:18:33 <EvanR> :\
05:18:40 <kmc> look at Control.Parallel.Strategies
05:19:16 <EvanR> how do i 'do something' with the list that wont degrade performance, like printing out
05:19:18 <aavogt> > [1..] `seq` ()
05:19:19 <lambdabot>   ()
05:19:20 <twink> There is a better answer.
05:19:41 <kmc> main = evaluate (take (10^20) src `using` rnf)
05:20:01 <kmc> evaluate is from Control.Exception and forces its arg to WHNF as an IO action
05:20:17 <kmc> "using" ensures that the whole expression is not at WHNF until the list is in NF
05:21:34 <EvanR> rnf
05:21:50 <EvanR> bah now i have to install Parallel.Strategies
05:22:02 <EvanR> why is this not built in ;)
05:22:03 <kmc> i think it's in platform
05:22:07 <kmc> if not "cabal install parallel"
05:22:24 <aavogt> evaluate is strange
05:22:39 <kmc> EvanR, btw if you are benchmarking, you should look at "criterion"
05:22:40 <kmc> it's great
05:22:44 <aavogt> @docs Control.Exception
05:22:44 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
05:22:47 <ivanm> anyone here have a project with a website at projects.haskell.org ?
05:22:51 <kmc> aavogt, how so?
05:22:54 <EvanR> ok
05:23:32 <m3ga> ivanm: not my project but i hack on ddc
05:23:45 <ivanm> m3ga: any idea what we're allowed to have on the websites there?
05:23:47 <aavogt> kmc: in the docs it says: Note: the first equation implies that (evaluate x) is not  the same as (return $! x). A correct definition is
05:23:52 <aavogt> evaluate x = (return $! x) >>= return
05:23:52 <ivanm> e.g. are we able to have gitit running or something?
05:23:58 * ivanm is just considering his options atm
05:24:04 <kmc> aavogt, that made sense to me after thinking about it a bit
05:24:04 <aavogt> f >>= return == f
05:24:08 <aavogt> this is a monad law
05:24:17 <m3ga> benl23 uses darcs for ddc
05:24:41 <m3ga> and trac
05:24:56 <ivanm> right, but I'm talking about using gitit for a wiki
05:24:57 <kmc> aavogt, are monad laws considered to hold even with respect to strictness?
05:25:01 <aavogt> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html#t%3AMonad
05:25:03 <aavogt> yes
05:25:08 <Twey> aavogt: That's strange
05:25:14 <ivanm> since kowey seems to think that would be a good idea for graphviz to have one
05:25:27 <aavogt> law #2 is being broken
05:25:40 <EvanR> rnf doesnt seem to work with using
05:25:44 <aavogt> or the 'correct' definition isn't the one that's actually being used
05:25:50 <m3ga> ivanm: not sure.
05:26:16 <aavogt> kmc: seq makes more sense
05:26:37 <EvanR> couldnt match expected type Eval [Int] against inferred type () in second argument of using namely rnf
05:26:38 <ivanm> m3ga: hmmm...
05:26:48 <ivanm> who manages the haskell community stuff?
05:27:18 <aavogt> or you can explain otherwise evaluate can be written without some stuff being done on part of the compiler
05:27:34 <aavogt> ie. writing it with just  seq, return, >>=
05:27:56 <EvanR> aavogt: sounds good to me ;)
05:28:14 <EvanR> but that wont evaluate completely would it
05:29:37 <EvanR> :t (`using` rnf)
05:29:38 <lambdabot> forall a. (NFData a) => a -> a
05:29:46 <EvanR> that fails for me in ghci
05:31:03 <Twey> Did you forget to import the module?  ;)
05:31:19 <kmc> works for me, latest Haskell Platform
05:32:22 <EvanR> it gives a type error
05:32:26 <EvanR> gah
05:32:58 <Twey> Oh, doesn't seem to work on .12
05:33:13 <EvanR> nevermind, i just wont produce the damn list without printing it D:
05:33:13 <Twey> using :: a -> Strategy a -> a
05:33:17 <Twey> :t using
05:33:22 <lambdabot> forall a. a -> Strategy a -> a
05:33:27 <Twey> :t using
05:33:28 <lambdabot> forall a. a -> Strategy a -> a
05:33:30 <Twey> Er
05:33:31 <Twey> :t rnf
05:33:32 <lambdabot> forall a. (NFData a) => a -> Done
05:33:41 <Twey> Hmm
05:33:43 <Twey> rnf :: (NFData a) => a -> ()
05:33:45 <Twey> In .12
05:34:18 <Twey> I'm confused
05:36:51 <aavogt> is .12 supposed to be 0.12?
05:37:10 <Zao> 6.12, assumedly.
05:46:07 <aavogt> @type flip using r0
05:46:08 <lambdabot> forall b. b -> b
05:49:27 <aavogt> `The main change is to the 'Strategy a' type synonym, which was previously a -> Done  and is now a -> Eval a. This change helps to fix the space leak described in "Runtime Support for Multicore Haskell".'
06:10:37 <Kaidelong> I am impressed by how well written the sources for Haskell's libraries are
06:10:46 <Kaidelong> I am not used to this kind of readability
06:17:40 <ivanm> Kaidelong: yay! :D
06:17:57 <ivanm> @remember Kaidelong I am impressed by how well written the sources for Haskell's libraries are; I am not used to this kind of readability
06:17:57 <lambdabot> Done.
06:19:44 <Peaker> I dislike the term "Readability"  --  it implies that code has an inherent level of readability that is objective, whereas different people will find completely different kinds of things more/less readable
06:20:24 <Kaidelong> well the fact that it is concise helps a lot
06:20:32 <ivanm> Peaker: OK, how should we refer to it?
06:20:41 <ivanm> "Haskell code typically has a high level of grokability"? :p
06:20:47 <Kaidelong> also there are a lot of comments to describe what is going on
06:22:06 <Peaker> ivanm, Depends on what you want to refer to.. Readability of the layman? Of the expert?
06:22:32 <applicative> Kaidelong, the libraries are definitions of terms in the ordinary sense --  subject to a discipline that makes them executable.   So it isn't surprising.
06:22:38 <Peaker> ivanm, I disagree, I think Haskell gives up Readability-to-laymen or to casual reader, in favor of making it more concise, more reliable and more composable (and possibly more readable to the expert)
06:22:46 <Jafet> All laymen are equal -- not all experts are
06:22:48 <Peaker> Python is more readable-to-layman than Haskell
06:22:54 <Jafet> Laymen shouldn't be programming at all
06:22:58 <applicative> On the other hand, try
06:23:02 <Jafet> Python is not readable, no
06:23:03 <Peaker> Assumes less knowledge at the reader
06:23:06 <Kaidelong> I have never liked looking at python
06:23:08 <Jafet> Have you actually read Python?
06:23:16 <Peaker> Jafet, I work with Python all the time
06:23:26 <Kaidelong> it's not that big an improvement over Java for me
06:23:26 <Jafet> A few thousand lines of it?
06:23:32 <Peaker> Jafet, Yeah
06:23:39 <Peaker> Jafet, tens of thousands of lines
06:23:43 <Jafet> You have my sympathies.
06:23:48 <dv-> Basic haskell code is quite readable
06:23:53 <Kaidelong> particularly since it also has loops and I find those to be quite difficult to figure out sometimes
06:24:01 <applicative> On the other hand, Array.Vector.Prim.BUArr or something like that
06:24:01 <Twey> Peaker: I disagreeâ¦ imperative algorithms take a lot of effort, and often a mental dry-run, to grok, even for someone well-versed in the paradigm and the language
06:24:06 <ivanm> Peaker: heh, that reminds me: I came across a discussion on thedailywtf the other day (from 2008) where they were stating that the Haskell quicksort definition (and the claim that it was more readable to the layman) a "wtf" (despite not including the bit afterwards that explained the code)
06:24:15 <Peaker> Kaidelong, But the unknowledgable layman will find those easier than recursions
06:24:27 <Kaidelong> I never found recursion hard personally
06:24:31 <ivanm> most people ended up agreeing that it was readable (barring the choice of variable names) to non-Haskell programmers, especially if they had a good enough maths background
06:24:34 <ivanm> Kaidelong: agreed
06:24:40 <Kaidelong> but I had a good introductory teacher for mathematics
06:24:50 <Peaker> Kaidelong, I don't remember if I did (it was long ago) but the fact is a lot of people find it difficult
06:24:55 <Kaidelong> Dr. Andy Wildenberg, if anyone knows the name
06:24:56 <Jafet> Peaker, by "layman" do you mean "an imperative programmer"?
06:24:57 <ivanm> basically, if you try it with an open mind, most people shouldn't have too many problems with the basics of Haskell
06:25:08 <Peaker> ivanm, btw: Bad names are pretty common in Haskell code :(
06:25:14 <ivanm> however, too many people have preconceived problem ("It doesn't look like C!")
06:25:23 <Peaker> Jafet, Hehe, no, an unknowledgable person
06:25:24 <ivanm> Peaker: they were using the_lower_vals or something like that
06:25:28 <applicative> when I first tried Haskell, with Hugs, I felt I had always known it.
06:25:44 <Jafet> Peaker, those people live in the jungles, I don't see why they are relevant.
06:25:54 <Jafet> Well, even jungle people probably know some things.
06:26:02 <Jafet> Newborns?
06:26:09 <Kaidelong> I first learned to program on a pencil and paper, imperatively, with line numbers and gotos, when I was little, my dad got me a book detailing that
06:26:10 <applicative> They know the jungle!
06:26:16 <Peaker> Jafet, Well, you could argue that a lot of school systems and other educational sources teach limited forms of imperative programming, so that's the basic exposure people do have
06:26:25 <Kaidelong> I was writing "recursive" algorithms that way before I knew what recursion meant
06:26:36 <Jafet> A fair point.
06:26:47 <Jafet> "You could have invented recursion!"
06:27:03 * ivanm tries to find that discussion
06:27:05 <Peaker> Non-programmers are often exposed to "pseudo-code" which is almost always a Python-like imperative language
06:27:14 <Kaidelong> I don't think it's a big jump from imperative programming, recursion is just like a goto in a sense
06:27:32 <Kaidelong> Peaker: I find in the books I read it is usually something that looks like Pascal or C
06:28:13 <Kaidelong> Python looks a bit like that
06:28:31 <Kaidelong> but I don't think the aim was to look like python so much as python tried to look like pseudocode
06:28:34 <Jafet> Kaidelong, then you don't fully understand what recursion can express.
06:28:50 <ivanm> here we are: http://thedailywtf.com/Comments/Friday_Smorgasbord.aspx
06:28:56 <applicative> There is a theory advanced lately by Chomsky et al that the capacity for recursion is the decisive step in the evolution of modern humans.    So it's a jungle capacity.
06:29:01 <Jafet> For example, there is no goto analogue of first-class continuations.
06:29:19 <ivanm> it used elts_lt_x and elts_greq_x
06:29:26 <Kaidelong> hmm, don't think you could really use tree recursion either
06:29:34 <Kaidelong> not with the "machine" I was using anyway
06:30:06 <Kaidelong> but it did illustrate the concept of going back into a "function" and having it read its previous "output"
06:30:39 <Kaidelong> I think for imperative programmers who worked with things like DOS scripts that particular part of recursion shouldn't be hard to grasp, and it's a common one
06:30:48 <Kaidelong> pattern of
06:30:52 * Jafet hears blubbering sounds
06:31:22 <Kaidelong> just talking from what I remember doing when I was first learning
06:31:57 <applicative> indeed, the elts_greq_x is pretty ugly....
06:33:36 <applicative> I see the wiki has a new version of the paragraph without it.
06:34:39 <Peaker> I am trying to compile the "derive" package on ghc 6.10.4... Anyone got that working?  Or is 6.12 good enough now?  The download page for ghc 6.12 still warns that it's for "early adopters"..
06:34:56 <applicative> http://www.haskell.org/haskellwiki/Introduction#Ease_of_understanding
06:35:29 <ivanm> applicative: yeah
06:35:37 <ivanm> Peaker: 6.12 should be OK now
06:35:42 <applicative> ivanm, it really is much nicer
06:35:44 <ivanm> Peaker: unless you need gtk2hs
06:35:49 <ivanm> applicative: definitely
06:35:59 <ivanm> who needs useless temporary variables that are only used once anyway!
06:36:39 <applicative> yes, it can make sense, but in that case none at all.
06:36:47 <Peaker> ivanm, it sounds like 6.10.4 is a bit "abandoned" (stuff from Hackage don't install smoothly)
06:37:09 <ivanm> Peaker: most stuff should still work with 6.10.4
06:37:17 <Zao> The 6.10-6.12 threshold is a bit rough.
06:37:19 <kamatsu> hey, has anyone given thought to the possibilty of making Haskell distributed so that threads can be run on many machines?
06:37:20 <ivanm> there are a few libs that needs base >= 4.2 (i.e. 6.12) but not many
06:37:28 <kamatsu> how easy would that be to achieve in GHC?
06:37:30 <Peaker> ivanm, "derive" doesn't compile :-(
06:37:39 <jaspervdj> kamatsu: iirc there's a compiler extension
06:37:45 <ivanm> kamatsu: well, I thought that was what you and TacticalGrace were doing... ;-)
06:37:52 <ivanm> Peaker: get an older version then... >_>
06:37:56 <kamatsu> ivanm: no?
06:38:01 <applicative> the where clause for elts_greq_x at least had the advantage of depending on x   I think that it's not ideal practice to have where clauses that could stand as separate definitions.
06:38:06 <ivanm> Peaker: actually, IIRC I couldn't get it to compile on 6.12 either
06:38:12 <ivanm> unless there's a new version out since then
06:38:14 <kamatsu> ivanm: I'm doing the JS compiler stuff with TacticalGrace, no distributed stuff
06:38:21 <kamatsu> ivanm: afaik, TG just does DPH stuff
06:38:28 <Peaker> ivanm, it has preprocessor IF's about ghc version being <6.12 or not, but it still fails to build, I think maybe the err is in deps..
06:38:44 <kamatsu> jaspervdj: link?
06:38:52 <ivanm> Peaker: could be
06:38:54 <Jafet> kamatsu, concurrent haskell?
06:38:55 <ivanm> kamatsu: JS?
06:39:07 <kamatsu> ivanm: haskell->js
06:39:21 <ivanm> oh, like what yhc used to have?
06:39:27 <Peaker> I think that Cabal packages need to have their versions specified independently of the .cabal file
06:39:33 <ivanm> kamatsu: do you mean something like erlang (for the distributed stuff)?
06:39:39 <ivanm> or like using MPI vs OpenMP?
06:39:42 <Peaker> module signatures to replace version deps could be awesome
06:39:43 <kamatsu> Jafet: yes, but can concurrent haskell only runs on one machine
06:39:47 <kamatsu> Jafet: afaik
06:39:50 <kamatsu> ivanm: i mean like Erlang
06:39:52 <Jafet> So far, yes.
06:39:59 <ivanm> Peaker: dcoutts has been considering how to make the cabal file _external_ to the tarball
06:40:09 <Jafet> I'm pretty sure marlow is working on that though
06:40:14 <Jafet> Or whoever it is
06:40:15 <kamatsu> ivanm: yes, like yhc used to have, but I'm taking a more methodical approach.
06:40:19 <Peaker> ivanm, I guess some things are inherent to the tarball (list of exports)
06:40:36 <ivanm> something a bit more akin to Gentoo's ebuilds, in that you get the cabal file, it has the deps, etc. (and can be edited to reflect changes) and then cabal-install, etc. then download the tarball with the sources
06:40:36 <Jafet> Does erlang automatically manage clustering?
06:40:44 <Peaker> ivanm, I think "Cabal" should mandate use of export lists and import lists (or qualified imports -- using a tool to auto-generate the import lists from that)
06:41:07 <Jafet> I mean, you probably would need new primitives to get any real performance.
06:41:15 <ivanm> Peaker: IIRC (from discussions with dcoutts) part of the problem is that GHC doesnt' distinguish between deps that are exported and those that aren't visible (e.g. parsec)
06:41:27 <ivanm> so it's not really something cabal can solve atm
06:41:52 <Peaker> ivanm, Deps that are exported? You mean re-exported imports?
06:42:01 <ivanm> right
06:42:04 <kamatsu> Jafet: clustering is built into erlang, but i'm not sure how automated it is
06:42:09 <ivanm> or maybe not re-exported but _visible_
06:42:12 <Peaker> If import/export lists had to be complete -- it wouldn't be a problem anymore..
06:42:23 <Peaker> (Unqualified open imports make everyone's life difficult)
06:43:15 <ivanm> Peaker: e.g. if you had an exported function that even mentioned a type from parsec, then parsec can be considered in part and "exported dependency" since it's visible to other libraries which specific version of parsec is being used
06:44:04 <ivanm> Peaker: well, I use them only for internal modules or for special cases (e.g. I import all of a PolyParse module when I'm doing parsing)
06:44:29 <Peaker> ivanm, I prefer to use "import ... as B" and then "B." everywhere
06:44:48 <ivanm> Peaker: *shudder* even for types?
06:44:58 <ivanm> I presume you mean qualified in there as well
06:45:09 * Twey prefers to do so, too
06:45:19 <ivanm> and since more than one module can be labelled as B, that doesn't always make it simpler
06:45:34 <Twey> ivanm: Yes, but you just don't do that :Ã¾
06:45:38 <Twey> Problem solved :Ã¾
06:46:01 <ivanm> heh
06:46:09 <ivanm> well, some people like to do that for ByteString...
06:46:14 <Kaidelong> I keep hearing that you should use fully qualified names unless the functionality is meant to create a "language"
06:46:18 <ivanm> (only case I know of of it being used)
06:46:31 <ivanm> Kaidelong: never heard anything like that before
06:46:41 <ivanm> I only use qualified imports for things that clash (e.g. Data.Map)
06:47:02 <Kaidelong> F# books say to do it, probably different from Haskell style
06:47:10 <Peaker> ivanm, Finding a new letter for more such modules is *far* better, IMO, to having more than one unqualified open import
06:47:12 <Kaidelong> also probably to make it look more like C#
06:47:13 <Twey> Qualified imports are good because they allow the *user* of the libraries to choose their own names that they know won't clash, so the library authors don't have to worry about it
06:47:23 <Peaker> ivanm, unqualified open imports make it impossible to read code, imo
06:47:37 <Twey> Kaidelong: Fully qualified names are never used.  âº
06:47:50 <Peaker> I don't mind if the name is qualified or explicitly imported
06:47:57 <ivanm> Peaker: so do you even do qualified imports for Data.List?
06:48:01 <Peaker> Just that I can search it in the module and find where it comes from
06:48:09 <ivanm> Twey: except for emergency debugging in ghci :p
06:48:10 <Peaker> ivanm, I do:  import Data.List(intercalate)
06:48:13 <hpc> Data.List is almost entirely subsumed by Prelude anyway
06:48:21 <ivanm> Peaker: right, as do I; but I don't import it qualified
06:48:26 <Twey> ivanm: Only because GHCi doesn't allow qualified imports â¹
06:48:34 <ivanm> Twey: yeah :s
06:48:47 <Peaker> ivanm, oh, I don't mind either one -- I only mind: "import Data.List" and think it is horrible that it is the "default" import syntax (simplest) and thus encouraged when it should be banned
06:49:07 <ivanm> but I've done that in cases where I have a module that only exports one function anyway, and I want to just quickly use it without bothering to import the module
06:49:34 <hpc> i use unqualified imports a lot, but only for stuff like Maybe and Applicative
06:49:41 <ivanm> Peaker: as I said; I only do so when it's either 1) an internal module (even then I sometimes have an explicit import list) or 2) I use pretty much the entire module; I find this system works quite well
06:50:35 <kamatsu> quite often I only use one or two functions from the module, or pretty much the whole thing
06:50:38 <Peaker> hpc, might as well copy them directly into Prelude if people assume everyone already knows the list of names in them
06:50:44 <kamatsu> so, following your rule, ivanm, gives me the best results
06:50:57 <hpc> Peaker: indeed
06:50:59 <ivanm> kamatsu: \o/
06:52:10 <kamatsu> ivanm: what does \o/ mean?
06:52:28 <hpc> it's the hand gesture people make at rock concerts
06:52:34 <Peaker> Which "base" version goes with ghc-6.10.4 and 6.12.1?
06:52:38 <ivanm> hpc: nope
06:52:42 <kamatsu> oh, those things
06:52:42 <hpc> no?
06:52:50 <hpc> oh, that's \m/
06:52:53 <ivanm> \o/
06:52:54 <ivanm>  |
06:52:59 <ivanm> /-\
06:53:04 <hpc> heh
06:53:05 <ivanm> ^^ that give you a clue? :p
06:53:08 <kamatsu> hehe
06:54:02 <Peaker> I have base-3.0.3.1 and base-4.1.0.0 both installed.. I suspect my package problems are because seeing ghc-6.10.4, packages try to use base-3, but get compiled against base-4.. is that possible?
06:55:13 <ivanm> Peaker: uhhhh, don't think so
06:55:31 <ivanm> Peaker: with cabal-install-0.6, it defaults to base-3 if there's no explicit upper bound that lets you use base-4
06:55:52 <ivanm> but having different libraries using different versions of base isn't a problem
06:56:27 <ivanm> actually, I have once managed to artificially cause that to happen (something depending on both versions and thus dying); that was something I knew didn't build on base-4 but its deps said it could
06:56:39 <Peaker> Well, lots of code in "derive" that's sitting under "#if __GLASGOW_HASKELL__ >= 612" works here, even though I'm on 6.10.4, whereas the code that's in the "#else" is broken
06:57:06 <ivanm> Peaker: :o
06:57:49 <ivanm> Peaker: I think it needs something special for 6.12 because of library changes; AFAIK anything that uses just base from 6.10 should build on 6.12
06:58:05 <aavogt> TH had some additions with ghc612
06:58:11 <aavogt> the AST that is
06:59:17 <Peaker> ivanm, Well, I need to reverse all of the "#if"s and then it builds! :-P
06:59:28 <ivanm> interesting...
06:59:30 <ivanm> aavogt: oh, right
06:59:48 <ivanm> aavogt: if its only additions, then it isn't a problem (unless you defined something with the same name and there's a clash)
07:00:00 <aavogt> ivanm: as in more constructors got added
07:00:12 <aavogt> to existing data types
07:00:22 <aavogt> this horribly breaks haskell-src-meta
07:00:39 <ivanm> I thought mmorrow had already abandoned haskell-src-meta...
07:00:51 <aavogt> since when?
07:01:21 <Peaker> Anyway, the "#if" is about GHC version when it should be about template-haskell's version, it seems
07:01:21 <ivanm> since he didn't need it
07:01:38 <ivanm> Peaker: because 6.12 had a new TH version that isn't backwards compatible IIRC
07:01:51 <Peaker> ivanm, And I manually fixed it to work with 6.10 :)
07:02:07 <aavogt> Peaker: template-haskell's version is stuck to gh
07:02:09 <aavogt> ghc
07:02:35 <aavogt> at least I don't think you can upgrade it
07:03:53 <aavogt> currently, if you don't want your package to be broken with cabal install like data-accessor-template, it's probably best to guess the TH versions from the GHC version
07:07:09 <Peaker> aavogt, I manually installed the newest TH onto 6.10.4 and now manually getting everything to install on top of that :)
07:08:01 <Peaker> ok, now getting SIGSEGV when trying to compile data-accessor-template heh
07:08:05 <Peaker> I guess I'll avoid doing that
07:08:19 <ivanm> heh
07:08:35 <jaspervdj> sioraiocht: ping
07:08:36 <Peaker> what TH version is for 6.10.4?
07:08:44 <sioraiocht> jaspervdj: pong
07:08:59 <jaspervdj> sioraiocht: see query
07:12:25 <Peaker> does "yi" install on 6.10.4? It seems to require template-haskell-2.4 which is for 6.12?
07:12:39 <Peaker> "Dependency hell" due to version deps rather than signature deps
07:13:35 <ivanm> Peaker: you need to use the version of data-acessor-tempaltes lower than what's the latest
07:13:40 <ivanm> to avoid a duplicate instance problem
07:14:17 <Peaker> wasn't that fixed? "yi" supposedly had a major release recently?
07:14:24 <ivanm> it did? *shrug*
07:14:27 * ivanm doesn't use it
07:14:52 <ivanm> Peaker: well, if it only works with 6.12, that's strange because it uses gtk2hs and that doesn't work on 6.12 yet (there's no release that does so anyway)
07:15:17 <Peaker> it works with vty too
07:15:27 <ivanm> oh, right
07:15:27 <Peaker> I never used gtk2hs with anything
07:15:36 <Peaker> I hate Gtk :P
07:15:46 <ivanm> Peaker: chart produces some nice plots...
07:16:17 <aavogt> gtk2hs works for 6.12 though...
07:16:22 <Peaker> I think I'll just install ghc-6.12 from scratch and fight problems there.. fighting problems with 6.10.4 is just a waste of time
07:16:23 <aavogt> maybe not the released version though
07:16:42 <ivanm> aavogt: exactly
07:16:51 <Peaker> 40K/sec download :(
07:20:14 <Peaker> I wonder why ghc-6.12.1 binaries are 100MB compressed.. What's in so much code?
07:20:25 <ivanm> MOAR AWESOME
07:20:32 <ivanm> (since copumpkin isn't here to say it)
07:20:34 <Peaker> SPJ intro videos? :)
07:20:57 <aavogt> hmm? Mine are only 55M
07:21:09 <Peaker> aavogt, the download package
07:21:31 <aavogt> well I mean my distro package
07:21:34 <Zao> Peaker: Base libraries? Lots of variants (profiling etc)?
07:21:45 <ivanm> Peaker: which distro?
07:21:45 <aavogt> those should be compressed though
07:25:12 <Peaker> ivanm, the official download page
07:26:04 <ivanm> oh, that was aavogt saying it was his distro package
07:26:38 <ivanm> 79MB here for a tarball that includes the binary (+profiling versions of libs) and haddock docs
07:26:49 <ivanm> 22MB for the source
07:27:04 <aavogt> ivanm: arch, but the included docs don't include source
07:27:42 <ivanm> neither are the gentoo ones
07:27:44 <jaspervdj> is there a backdoor to import a non-exposed module somehow?
07:27:51 <ivanm> wait, I lie; we build them but they aren't coloured :(
07:28:02 <ivanm> jaspervdj: manually expose it via ghc-pkg
07:28:05 <ivanm> but that's not portable
07:28:14 <ivanm> jaspervdj: why do you want to do such a thing?
07:28:30 <ivanm> you can of course do what the leksah devs did and fork the package just to expose some internals... >_>
07:28:31 <ivanm> @time
07:28:32 <lambdabot> Local time for ivanm is Sun Apr 18 00:28:09
07:28:33 <ivanm> :o
07:28:50 <jaspervdj> Yeah, I suppose :-/
07:30:46 * ivanm should be sleeping...
07:37:10 <Peaker> it should be called GGHC "The Glorious Glasgow Haskell Compilation System, version 6.12.1"
07:37:29 <Mathnerd314> reading TMR issue 13... it defines `class Functor f => Applicative f`. Could/should this be `class Applicative f` and `instance (Applicative f) => Functor f`?
07:37:31 <Kaidelong> make it recursive for a third G?
07:38:43 <Peaker> Mathnerd314, That would create overlapping instances.... It is a big problem with Haskell's type-class system as it is today...
07:39:50 <Mathnerd314> Peaker: what would overlap?
07:40:25 <Peaker> Mathnerd314, Haskell98/10 instances are all (potentially parametrized) types, not type variables
07:40:37 <Peaker> Mathnerd314, every Functor instance would overlap with that big instance you wrote
07:41:12 <Mathnerd314> only if it was applicative...?
07:41:53 <Peaker> Mathnerd314, (Instances only look at the "head" or type, not at the class context/restrictions)
07:41:54 <applicative> Peaker, how does it work with Monad.  I guess there's no general applicative instance
07:42:12 <applicative> or functor instance
07:42:40 <Peaker> applicative, why not?  pure=return; (<*>)=ap
07:42:42 <Peaker> fmap=liftM
07:42:55 <Peaker> @src ap
07:42:56 <lambdabot> ap = liftM2 id
07:43:00 <Peaker> @src liftM
07:43:00 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
07:43:21 <applicative> of course, i know rthat, but i mean, you don't get <$> and fmap just by declaring a Monad
07:43:29 <Twey> You would with class aliases!
07:44:10 <applicative> Peaker, I was trying to speak to Mathnerd314's difficulty, I thought he was asking about syntax basically
07:45:52 <Peaker> why doesn't anyone implement class aliases?
07:45:54 <applicative> Mathner314, what is the difficulty, exactly?  The idea is that you don't call it an Applicative until you've first called it a functor, so you just need to add pure and <*>
07:46:27 <Mathnerd314> but fmap == (<*>) . pure, so every applicative must be a functor
07:46:46 <applicative> no fmap =<$>
07:46:53 <applicative> right
07:46:54 <applicative> sorry
07:47:21 <applicative> but of course every applicative must be a functor, thats whats said by    class Functor f => Applicative f
07:47:55 <Mathnerd314> every applicative *is* a functor by definition, so I'd think you'd get it for free
07:48:14 <Mathnerd314> (just by defining an applicative instance)
07:48:54 <aavogt> no you don't
07:48:58 <aavogt> you have to define it first
07:49:12 <Peaker> Mathnerd314, Ideally, yes, but then what if someone already defined a manual Functor instance?
07:49:36 <Mathnerd314> then... tell them to go home and shut up?
07:49:47 <Peaker> GHC will find both
07:49:52 <Peaker> And then what should it do?
07:49:55 <applicative> Mathnerd314, every Monad is a functor but it works differently from applicative
07:50:02 <aavogt> pick the most specific instance, Peaker
07:50:17 <aavogt> that's how overlapping instances work
07:50:30 <Peaker> aavogt, They create some problems...
07:50:55 <Peaker> You might get different semantics from different instances, and your code might break by merely importing some other module
07:51:03 <applicative> I don't think this was Mathnerd314s difficulty, but maybe I don't understand
07:52:32 <Peaker> He was wondering why "Every A is a B" means "class B f => A f where ..." rather than the an auto-instance...
07:53:18 <fax> shouldn't it be  class A f => B f ?
07:53:49 <Peaker> That allows for A's which are not B's
07:53:57 <Peaker> class Eq a => Ord a where ...
07:54:23 <applicative> fax also meant it should have been "Every B is an A"
07:54:53 <fax> doesn't that means if you have an Eq instance on a, then there is an Ord instance induced on a?
07:55:27 <fax> i.e. every Eq is an Ord
07:55:43 <applicative> no, no all Eqs are ords
07:55:44 <mauke> class, not instance
07:56:44 <Peaker> Mathnerd314, do you also want "class Ord" to not extend Eq, and a big "instance Ord a => Eq a where ..." ?
07:57:05 <fax> mauke doh!! I understand now
07:57:16 * applicative wonders how this rather elementary discussion should be putting his mind into such confusion
07:57:38 <Peaker> Is there a good example in the stdlib, of a subclass that cannot be used to auto-derive the super-class?
07:58:04 <Draconx|Laptop> Peaker, RealFloat?
07:58:16 <Peaker> @src RealFloat
07:58:16 <lambdabot> Source not found. Do you think like you type?
07:59:25 <mauke> Peaker: Integral?
07:59:39 <Peaker> @src Integral
07:59:39 <lambdabot> class  (Real a, Enum a) => Integral a  where
07:59:39 <lambdabot>     quot, rem, div, mod :: a -> a -> a
07:59:39 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
07:59:39 <lambdabot>     toInteger           :: a -> Integer
07:59:57 <mauke> @src Real
07:59:58 <lambdabot> class  (Num a, Ord a) => Real a  where
07:59:58 <lambdabot>     toRational      ::  a -> Rational
08:00:02 <mauke> actually
08:00:15 <mauke> Peaker: Num itself
08:00:22 <Peaker> Num is a bad example, though
08:00:32 <Peaker> because "Eq" is a pretty crappy super-class for Num..
08:00:48 <mauke> or Show
08:01:37 <Peaker> Yeah, both are over-restrictive
08:03:54 <applicative> Mathnerd314, I wonder if the case of Applicative is ideal.  You clearly have to define pure, that goes beyond Functor, but <*> sort of already includes fmap, given pure; its stronger, and you can't use your fmap definition to help define it.
08:04:01 <applicative> @src Traversable
08:04:01 <lambdabot> class (Functor t, Foldable t) => Traversable t where
08:04:01 <lambdabot>     traverse    :: Applicative f => (a -> f b) -> t a -> f (t b)
08:04:02 <lambdabot>     sequenceA   :: Applicative f => t (f a) -> f (t a)
08:04:02 <lambdabot>     mapM        :: Monad m => (a -> m b) -> t a -> m (t b)
08:04:02 <lambdabot>     sequence    :: Monad m => t (m a) -> m (t a)
08:05:35 <applicative> Mathnerd314 here you add stuff that's definitely new and optional for an applicative functor, and can use the applicative instance as it was.
08:06:38 <aavogt> does the naming there strike anybody as inconsistent?
08:07:12 <applicative> you wouldn't want to do    instance Functor Foldable => Traversable  since you would have had to define all the Traversable operations in terms other than those for Applicative
08:07:34 <applicative> sorry, i meant, other than those for functor
08:07:43 <applicative> yes, this example is bad too.
08:09:44 <applicative> @src Alternative
08:09:44 <lambdabot> class Applicative f => Alternative f where
08:09:44 <lambdabot>     empty :: f a
08:09:44 <lambdabot>     (<|>) :: f a -> f a -> f a
08:11:00 <applicative> Okay, now I have an example.  I don't want to say "instance Alternative f => Applicative f"  , would I?
08:11:42 <Peaker> haskell-src-exts depends on happy but cabal-install doesn't seem to know it
08:13:45 <kamatsu> hey all, what would be a simple use case for Applicative? I understand them, i just fail to see a use for them
08:14:19 <harlekin> kamatsu, applicate parsec is nice in case you don't need parsec's monadic interface.
08:14:20 <applicative> Mathnerd314,sorry, I'm probably making things worse, but does it seem clear that "instance Alternative f => Applicative f" would be an inferior approach.  I would have to have separate terms for these things, <*> pure etc., then identify them, in order to get the applicative instance.
08:14:38 <harlekin> kamatsu, http://book.realworldhaskell.org/read/using-parsec.html
08:15:33 <applicative> kamatsu, wherever you use Monad, you might as well also use Applicative, for when there needn't be 'sequencing'
08:16:28 <applicative> (++) <$> (readFile "a.txt") (readFile "b.txt")
08:16:33 <Mathnerd314> applicative: I'
08:16:50 <Mathnerd314> d think that I could define an instance for Monoid instead of making alternative
08:17:03 <applicative> is the concatenation of two files, what's not to like.
08:17:46 <Peaker> kamatsu, The static-ness of Applicative allows the instance to do things a Monad instance couldn't
08:18:28 <Peaker> kamatsu, (Knowing all of the "effects" before-hand lets you build an optimized automaton for context-free parsing, whereas a Monadic parser cannot be converted to an optimized automaton)
08:19:41 <kamatsu> applicative: Ah, that's nice
08:19:45 <kamatsu> applicative: I see the use now
08:20:09 <kamatsu> applicative: don't you need a <*> in there?
08:20:10 <applicative> Mathnerd314, I see.  Of course that route is also possible.  I don't think it's an objection to the def. of Alternative (which thinks ahead to parsers mostly)
08:20:29 <Peaker> That's not exactly a "use of Applicative" if you could achieve the same with a Monad (liftM2 (++) (readFile ..) (readFile ..) or using liftM and ap
08:20:35 <applicative> kamatsu, of course, you could do with with monad (
08:20:37 <applicative> haha
08:20:45 <kamatsu> right
08:20:52 <Peaker> A "use of Applicative" would be making use of the extra information an instance has
08:21:09 <applicative> but the use of Applicative goes with a certain intuition of whats up.
08:21:15 <Mathnerd314> well, I'll start with {-# LANGUAGE NoImplicitPrelude #-} and see where I get to
08:21:28 <applicative> Peaker has a more exalted conception of Use
08:21:42 <Twey> 16:16:05 < applicative> (++) <$> (readFile "a.txt") (readFile "b.txt")
08:21:54 <Peaker> applicative, I guess what I thought "use" meant here was what's the benefit
08:22:02 <Peaker> That example is missing a <*>
08:22:03 <Twey> applicative: Isn't that meant to be a (++) <$> readFile "a.txt" <*> readFile "b.txt"?
08:22:06 <Peaker> ya
08:22:09 <applicative> yes, sorry
08:22:10 <Peaker> or liftA2/liftM2
08:22:13 <Twey> Oh, I see kamatsu mentioned it
08:22:16 <applicative> too early
08:22:21 <Twey> Haha
08:22:24 <applicative> it's clear you can do it with monads
08:22:34 <Twey> My first thought was, âwoah, cool, how does he lift the second bit automagically?â
08:22:40 <kamatsu> lol
08:22:46 <applicative> Twey sorry
08:23:35 <applicative> i am waiting for idiom brackets of course [| readFile "a.txt" ++ readFile "b.txt" |]
08:23:45 <Twey> Hehe
08:23:52 <applicative> i was grasping for this Utopia too quickly
08:24:31 <fax> idiom brackets are already there
08:24:36 <fax> it's (| |) though
08:24:48 <applicative> in the she preprocessor
08:24:50 <applicative> ?
08:24:51 <aavogt> only with a preprocessor
08:26:02 <aavogt> http://hackage.haskell.org/packages/archive/haskell-src-meta/0.0.6/doc/html/src/Language-Haskell-Meta-QQ-Idiom.html
08:27:34 <kamatsu> oh, I have to get this preprocessor
08:27:34 <applicative> yes, somehow importing TH and quasiquotes seem less than utopian to  me
08:28:01 <kamatsu> applicative: it works?
08:28:08 <kamatsu> applicative: seems pretty okay to me
08:28:20 <applicative> kamatsu, the she preprocessor?
08:29:10 <kamatsu> applicative: yes
08:29:12 <applicative> kamatsu, of course, it's aimed at much more....  but the idiom brackets bit seems to work fine.  I was using for goofy scripting -- just for the idiom brackets, I mean, and didn't run into trouble.
08:29:44 <harlekin> > init []
08:29:44 <kamatsu> oh, no
08:29:45 <lambdabot>   *Exception: Prelude.init: empty list
08:29:47 <kamatsu> i wasn't asking a question
08:29:48 <harlekin> init [1..10]
08:29:56 <kamatsu> i was more questioning your "less than utopian" comment
08:30:20 <applicative> kamatsu, she is Utopian
08:31:00 <applicative> I should look into the /Language-Haskell-Meta-QQ-Idiom.html way
08:34:28 <EvanR> :t zip `ap` tail
08:34:29 <lambdabot> forall b. [b] -> [(b, b)]
08:34:45 <aavogt> applicative: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24248
08:34:54 <EvanR> :t zip `ap` tail [1,2,3,4,5,6,7,8]
08:34:55 <lambdabot>     Couldn't match expected type `[a] -> [b]'
08:34:55 <lambdabot>            against inferred type `[t]'
08:34:55 <lambdabot>     In the second argument of `ap', namely `tail [1, 2, 3, 4, ....]'
08:35:04 <EvanR> :t (zip `ap` tail) [1,2,3,4,5,6,7,8]
08:35:05 <lambdabot> forall b. (Num b) => [(b, b)]
08:35:11 <EvanR> > (zip `ap` tail) [1,2,3,4,5,6,7,8]
08:35:12 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8)]
08:35:33 <EvanR> @src ap
08:35:33 <lambdabot> ap = liftM2 id
08:35:53 <EvanR> :t leftM2
08:35:54 <lambdabot> Not in scope: `leftM2'
08:36:08 <Peaker> applicative, What I meant earlier was that I wanted to explain the benefit of Applicative over Monad, not just some things it can do
08:36:21 <applicative> aavogt, very cool
08:36:40 <Peaker> I guess the main benefit noone mentioned is extra compsability (liftA2 . liftA2   makes two applicatives into one, whereas  join . join  doesn't make two monads into one)
08:36:51 <Peaker> @src liftM2
08:36:51 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
08:37:22 <applicative> Peaker, yes, I saw what you meant;  I was thinking about the benefit for comprehensibility, which is distinct from that.
08:37:22 <harlekin> What could I use instead of maybe (return ()) (\ch -> monadicAction ch) foo?
08:37:48 <aavogt> harlekin: traverse monadicAction
08:38:13 <aavogt> though that gives you a    m (Maybe ())
08:38:15 <applicative> aavogt, it hadn't occurred to me that the quasi-quote way will work in the ghci.  Don't think you could do that with she....
08:38:23 <Peaker> @type maybe (return ())
08:38:24 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> m ()) -> Maybe a -> m ()
08:38:34 <Peaker> I had a name for that somewhere
08:38:36 <aavogt> @hoogle traverse
08:38:37 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
08:38:37 <lambdabot> Data.Foldable traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
08:38:45 <aavogt> oh, traverse_ will fix that
08:39:05 <aavogt> Peaker: it's in Data.Foldable already
08:39:20 <harlekin> Thanks.
08:39:45 <EvanR> so whats the use of liftM2 andap
08:40:59 <Peaker> EvanR, liftM2 is useful when you want to apply a pure function to the results of 2 actions
08:41:02 <applicative> EvanR, exactly  ... to get the applicative instance out of the monad
08:43:32 * Baughn wonders if he's the only one to use pattern guards in place of where, without the least bit of pattern-matching going on
08:43:42 <EvanR> hmm
08:43:46 <Baughn> Or.. in place of let, I guess. The layout looks better.
08:43:57 <Mathnerd314> but if monads were auto-instances of applicative.... then liftA2 == liftM2 and ap == <*>, right?
08:44:22 <Peaker> EvanR, Converting (a -> b -> c) to (m a -> m b -> m c)
08:44:23 <Baughn> Mathnerd314: Yep, that's the general idea
08:44:35 <EvanR> Peaker: got it
08:44:48 <EvanR> i probably could have used that in my travels so far
08:45:27 <EvanR> and ap is a simpler version
08:46:05 <Peaker> @type \f x y -> f `liftM` x `ap` y -- you mean?
08:46:07 <lambdabot> forall a1 a b (m :: * -> *). (Monad m) => (a1 -> a -> b) -> m a1 -> m a -> m b
08:46:35 <EvanR> i mean, just ap by itself
08:46:35 <aavogt> heh, Baughn. let is quite rare in guards
08:46:55 <EvanR> is for (b -> c) to (m b -> m c) ?
08:47:12 <applicative> > (+) `liftM` [1,2,3] `ap` [4,5,6]
08:47:13 <lambdabot>   [5,6,7,6,7,8,7,8,9]
08:47:31 <Baughn> aavogt: What I mean is, I'm using "foo a | x <- mungle a = bangle x" in place of "foo a = let x = mungle a in bangle x"
08:47:36 <Peaker> EvanR, that's liftM
08:47:39 <Peaker> @type ap
08:47:40 <aavogt> I only use it when I use a value on the RHS and in a following one
08:47:40 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
08:47:52 <applicative> > (+) <$> [1,2,3] <*> [4,5,6]
08:47:53 <lambdabot>   [5,6,7,6,7,8,7,8,9]
08:47:59 <aavogt> Baughn: foo a | let x = mungle a = bangle x
08:48:21 <Mathnerd314> @type (<*>)
08:48:22 <Baughn> aavogt: ..that can't be valid syntax
08:48:22 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
08:48:30 <aavogt> it is
08:48:32 <EvanR> gah, back to the drawing board
08:48:44 <Baughn> @let foo a | let x = mungle a = bangle x
08:48:44 <lambdabot>   PatternGuards is not enabled
08:48:46 <Peaker> EvanR, "ap" is useful as a building block for liftMn: liftM2 f x y = return f `ap` x `ap` y ; liftM3 f x y z = return f `ap` x `ap` y `ap` z ; and so on
08:48:47 <aavogt> > case () of _ | let x = x -> x
08:48:51 <lambdabot>   mueval-core: Time limit exceeded
08:49:03 <aavogt> > case () of _ | let x = 1 + 1 -> x
08:49:04 <lambdabot>   2
08:49:39 <kamatsu> oh, haskell-src-meta doesn't build on 6.12
08:49:45 <Baughn> aavogt: Hm. Is there any reason to use that instad of "x <-"
08:49:47 <Peaker> EvanR, the idea is that if you try to use liftM to apply a function of 2 args on an action, you get a result that's partially applied only to the first arg, but that partially applied result is in "m", so it looks like "m (a -> b)". Then you use "ap" on that to apply it to the next arg
08:49:47 <Baughn> ?
08:49:48 <aavogt> > let x = 0 in case () of _ | x <- x + 1 -> x
08:49:49 <lambdabot>   1
08:49:57 <Baughn> It seems superfluous
08:49:57 <aavogt> > let x = 0 in case () of _ | let x = x + 1 -> x
08:50:01 <EvanR> Peaker: so liftMx and ap lets you get away with fewer 'return's
08:50:01 <lambdabot>   mueval-core: Time limit exceeded
08:50:09 <BONUS> someone should turn off kind displaying for higher-kinded type variables when showing types in lambdabot >_>
08:50:12 <aavogt> Baughn: there's a difference if you like to shadow names
08:50:16 <BONUS> :t lift
08:50:17 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
08:50:28 <aavogt> actually in favor of the <-
08:50:29 <edwardk> Baughn: there is a whole class of computations that aren't strong enough to support <- but can support `ap`: We call them Applicatives.
08:50:47 <aavogt> though I dunno if people actually make recursive let bindings in pattern guards...
08:50:47 <edwardk> Baughn: also you don't have to name dozens of temporary variables
08:50:53 <Peaker> EvanR, I used "return f `ap` x" instead of "f `liftM` x" so the first arg doesn't look special.  But yeah, liftMx lets you have fewer liftM's and ap's
08:51:14 <Peaker> EvanR, (or fewer returns if you use that form, or fewer do blocks if you use that form :)
08:51:16 <Baughn> aavogt: I see. Interesting, though it seems like it could get confusing.
08:51:31 <Peaker> liftMx is shorter than using liftM/ap, which is shorter than using return/ap, which is shorter than using do blocks
08:51:36 <aavogt> the amazingness of -XPatternGuards?
08:51:37 <Baughn> > msum (Just 2) (Just 3)
08:51:37 <lambdabot>   Couldn't match expected type `[m a]'
08:51:38 <lambdabot>         against inferred type `Data.Ma...
08:51:47 <Baughn> > mplus (Just 2) (Just 3)
08:51:48 <lambdabot>   Just 2
08:51:49 <EvanR> :t liftIO
08:51:49 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
08:52:06 <patch-tag> I'm trying to grok the programming with effects article on hareddit
08:52:06 <applicative> Peaker, but why not use <$> and a bunch of <*>s
08:52:33 <edwardk> applicative: coz peaker is retro like that ;)
08:52:34 <patch-tag> can someone give me an example of a common thing that's a functor but not a monad?
08:52:37 <Peaker> applicative, You don't want another context beyond "Monad m => "
08:53:05 <edwardk> patch-tag: IntMap
08:53:15 <applicative> yes, it's the wages of not introducing Monad by way of Applicative,
08:53:22 <patch-tag> What about Data.Map?
08:53:26 <edwardk> that works too
08:53:34 <patch-tag> Data.Set also?
08:53:36 <Peaker> though that *should* have been a Monad
08:53:39 <edwardk> nope.
08:53:44 <Peaker> (Data.Map)
08:53:45 <edwardk> Data.Set cares about the type of a.
08:53:52 <edwardk> because it has to have an Ord instance
08:54:00 <edwardk> and so can't just be arbitrarily replaced
08:54:02 <Peaker> edwardk, Well, mathematically, even that case is considered a Monad
08:54:04 <patch-tag> Peaker: Data.Map should have been a monad, or Data.Set?
08:54:10 <Peaker> I think both
08:54:15 <applicative> patch-tag, I sympathze, the post was way too compressed.
08:54:23 <Peaker> But maybe I'm wrong about Data.Map
08:54:25 <edwardk> Peaker: not the Maps, there is no readily defined mechanism for combining the keys
08:54:28 <patch-tag> Yeah, but I really hope to make use of it
08:54:33 <Peaker> Oh, ok, not Data.Map then
08:54:34 <aavogt> @instances-importing Data.Map Monad
08:54:35 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
08:54:40 <Peaker> There's RMonad that lets you use Data.Set as a Monad
08:54:47 <edwardk> peaker: you CAN make a monad out of a trie though which combines keys by concatenation
08:55:05 <applicative> patch-tag, we should convince him to write more.
08:55:11 <patch-tag> Edwardk: what about Map Integer?
08:55:15 <edwardk> in general if you need to turn to rmonad you're using the wrong abstraction =)
08:55:28 <edwardk> Map Integer works fine as a functor, but isn't a monad.
08:55:31 <patch-tag> Functor, yes? But not monad?
08:55:33 <patch-tag> gotit
08:55:49 <patch-tag> And Set Integer could be a monad if it got tweaked a bit
08:55:56 <edwardk> not quite
08:55:59 <patch-tag> though it isn't as currently implemented
08:56:04 <patch-tag> is that the story?
08:56:10 <aavogt> set integer has the wrong kind
08:56:13 <edwardk> 'Set' could be a monad, remember it needs an argument
08:56:21 <patch-tag> oh right
08:56:25 <edwardk> but the problem is confluence and the monad laws
08:56:39 <edwardk> because you can't make a set of functions that collapses identical functions
08:56:54 <edwardk> hence the need for RMonad and the attendant hinkiness involved there ;)
08:58:26 <edwardk> patch-tag:  you can add a little bit of structure and get a Pointed functor, or a bit more and get Applicative, and still not be a monad.
08:58:29 <patch-tag> So... Map Int could be a nice example of functor but not a monad
08:58:33 <edwardk> yeah
08:58:36 <applicative> patch-tag, arent ziplists not a monad?
08:58:44 <patch-tag> no idea, that's why I'm here :)
08:58:53 <edwardk> applicative: that was going to be my example of an applicative but not monad =)
08:59:16 <edwardk> i like map k, because there is no canonical choice of key for pointed
08:59:21 <patch-tag> Edwardk: Pointed functor was missing from that lovely diagram in the article
08:59:28 <patch-tag> Do you see a place where it would fit in?
08:59:31 <edwardk> patch-tag: which article?
08:59:44 <patch-tag> programming with effects, the story so far
08:59:56 <patch-tag> http://just-bottom.blogspot.com/2010/04/programming-with-effects-story-so-far.html
09:00:02 <edwardk> its between functor and applicative
09:00:03 <applicative> patch tag, between functor and applicative.  he just doesnt
09:00:05 <applicative> make use of it
09:00:36 <patch-tag> So is there an easy example of Pointed functor but not a functor or Applicative?
09:00:56 <patch-tag> I mean not an applicative?
09:01:02 <patch-tag> (I guess it would be a functor)
09:01:25 <edwardk> newtype Endo a = Endo (a ->a); instance Pointed Endo where point = Endo . const
09:01:33 <edwardk> er
09:01:34 <edwardk> no
09:01:37 <edwardk> thats not a Functor
09:01:38 <edwardk> hrmm
09:02:09 <patch-tag> I mean something like Data.Map Int that I'd encounter in day-to-day
09:04:57 <edwardk> what you need is something you can construct with just an 'a', and map over, but which you can't glue together.
09:05:46 <patch-tag> I don't understand the gluing together bit
09:06:03 <patch-tag> Map 1 'a'
09:06:11 <edwardk> @type (<*>)
09:06:12 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
09:06:16 <patch-tag> fmap
09:06:40 <Mathnerd314> @type (>>=)
09:06:41 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
09:06:58 <patch-tag> mathnerd314: we're talking about weaker than monads I think
09:07:06 <edwardk> for instance with some constraints on the key for your map you could define a 'pointed' map. i.e. if there was a canonical 'zero'
09:07:13 <Mathnerd314> yeah... just thinking about do-notation for applicatives
09:07:32 <edwardk> Mathnerd314: you can do it, you just don't let any of the variable names bind until the last clause.
09:07:40 <aavogt> stuff would be confusingly out of scope
09:07:43 <patch-tag> edwardk, bringing in monoid structure like things?
09:07:58 <edwardk> patch-tag: yeah. though you don't need a full monoid, just a 'zero' =)
09:08:12 <patch-tag> what's a thing that has a zero but isn't a monoid?
09:08:15 <edwardk> class Zero a where zero :: a
09:08:20 <edwardk> its kinda boring =)
09:08:46 <edwardk> since you have no laws all it is a type with a known inhabitant that you've selected.
09:08:59 <patch-tag> so is there an interesting example of a pointed functor?
09:09:14 <edwardk> there are a bunch of them but i'm trying to find one that is more mainstream.
09:09:24 <patch-tag> i'm googling around too
09:09:49 <Mathnerd314> class MZero m where mzero :: m a; much more interesting, since you can't use a
09:10:19 <edwardk> patch-tag: i usually use it for things that are just a temporary newtype wrapper
09:10:22 <edwardk> i.e. http://hackage.haskell.org/packages/archive/monoids/0.1.36/doc/html/Data-Ring-Semi-Ord.html
09:10:28 <applicative> patch-tag, i was wondering about that.  Typeclassopedia's example of a non-pointed functor is (,) e    instance Monoid e => Pointed (,) e   works
09:10:45 <edwardk> allowing point and extract to add and remove the wrapper
09:10:59 <edwardk> the problem is that is also a monad =)
09:11:30 <applicative> I know, i was trying to think of something weaker than monoid that wouldnt give us a monad
09:12:21 * hackagebot vector-space 0.6.2 - Vector & affine spaces, linear maps, and derivatives (requires ghc 6.9 or better)  http://hackage.haskell.org/package/vector-space-0.6.2 (ConalElliott)
09:13:17 <applicative> edwardk, i was thinking, whats the least I can do to make something pointed.   That path wasn't working, clearly
09:13:41 <conal> Peaker: that vector-space release has your Boolean version fix
09:14:15 <edwardk> applicative: well, the least thing would be to just take a type that doesn't have a monoid associated with it, select one element from it, and call that a point.
09:14:22 * hackagebot Combinatorrent 0.2.2 - A concurrent bittorrent client  http://hackage.haskell.org/package/Combinatorrent-0.2.2 (JesperLouisAndersen)
09:14:45 <edwardk> http://hackage.haskell.org/packages/archive/monoids/0.1.36/doc/html/Data-Monoid-Lexical-SourcePosition.html is pointed, but not applicative
09:15:22 <edwardk> i remember now. if you have branches that may or may not contain your value, but can't combine them if they don't then you can't be applicative
09:15:29 <Mathnerd314> are pointed's necessarily functors? (besides by definition)
09:15:42 <edwardk> Either gets away with effectively choosing the 'Last' monoid
09:16:09 <edwardk> Mathnerd314: not necessarily you can define a type that you can inject values into which you can't fmap over all possible inhabitants of the type.
09:16:16 <edwardk> newtype Endo a = Endo (a -> a)
09:16:18 <edwardk> is not a functor
09:16:26 <edwardk> but you could define a 'point' for it
09:16:30 <edwardk> which just ignored its argument
09:16:41 <Mathnerd314> ah.
09:17:16 <Mathnerd314> @type fmap
09:17:17 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:17:23 <patch-tag> thanks for the example edwardk
09:17:52 <applicative> edwardk, but in the category extras library, Pointed is defined by Functor  as in typeclassopedia
09:18:00 <edwardk> applicative: yes
09:18:05 <Peaker> conal, cool, thanks :)
09:18:07 <edwardk> applicative: he said 'other than by definition'
09:18:24 <Peaker> conal, It's a little problematic to have to release a new version for such trivial changes
09:18:30 <edwardk> as in if you didn't have the constraint could you make it a Functor given just the point operation
09:18:57 <conal> Peaker: easy for me.  i use cabal-make, so i just say "make release".
09:19:15 <conal> Peaker: which churns through 12 steps or so automatically.
09:19:19 <patch-tag> What about Applicative but not arrow?
09:20:28 <edwardk> my knee jerk reaction here would probably be ziplist.
09:20:37 <conal> i wonder if cabal could provide some mechanism that would catch the insufficiently specified dependencies.  i've made this mistake several times.
09:20:48 <edwardk> though be careful, because arrow has a different kind
09:21:02 <Peaker> conal, ah, cool.. still, imagine all the other packages that specify upper bounds on vector-space :)
09:21:32 <Peaker> conal, yairchu suggested having a type-check mode for ghc, and then running it on every uploaded package against various versions
09:21:36 <applicative> edwardk, I was going to say, how do you recover the other type you need for arrow from the applicative; its hard to pose the question
09:22:06 <edwardk> applicative: if you change your definition of arrow a bit you can do it. you need wadler-style arrows though
09:22:33 <edwardk> http://homepages.inf.ed.ac.uk/wadler/papers/arrows-and-idioms/arrows-and-idioms.pdf
09:23:59 <Mathnerd314> @let newtype Endo a = Endo (a -> a)
09:23:59 * Baughn is having a bit of a problem deriving serializers for both happstack and cereal in the same module. So much for per-file namespaces. :/
09:23:59 <lambdabot>  Invalid declaration
09:24:13 <edwardk> > Data.Monoid.Endo id
09:24:14 <lambdabot>   No instance for (GHC.Show.Show (Data.Monoid.Endo a))
09:24:14 <lambdabot>    arising from a use ...
09:24:18 <edwardk> its already here
09:24:33 <Mathnerd314> oh
09:24:55 <Mathnerd314> @type Data.Monoid.Endo . id
09:24:56 <lambdabot> forall a. (a -> a) -> Endo a
09:25:32 <edwardk> . id -- is kind of a boring appelation to add ;)
09:25:43 <applicative> edwardk, the Wadler et al paper will reward study?
09:25:49 <Mathnerd314> yeah, just thinking a bit more
09:26:20 <Mathnerd314> @type Data.Monoid.Endo id
09:26:21 <lambdabot> forall a. Endo a
09:26:25 <edwardk> applicative: somewhat. it has some pretty deep flaws
09:26:25 <Mathnerd314> there
09:26:50 <Mathnerd314> @pl f x y = Data.Monoid.Endo id
09:26:50 <lambdabot> f = const (const (Data.Monoid.Endo id))
09:26:53 <edwardk> applicative: the model of arrows they propose is nice, but the mechanism they use to prove its equivalence to traditional arrows is flawed.
09:27:01 <Mathnerd314> @type const (const (Data.Monoid.Endo id))
09:27:02 <lambdabot> forall a b b1. b1 -> b -> Endo a
09:27:08 <edwardk> but if you take THAT with a grain of salt, the ideas they generate are fine.
09:27:38 <applicative> edwardk, its another thing, which might also have been called arrows?
09:27:56 <edwardk> applicative: yeah. this was done more recently to try to give arrows a more monadic/applicative feel
09:28:01 <Mathnerd314> @type const (const (Data.Monoid.Endo id)) -- edwardk, suitable instance of functor for Endo?
09:28:02 <lambdabot> forall a b b1. b1 -> b -> Endo a
09:28:14 <patch-tag> What is that squiggly right pointing arrow?
09:28:15 <edwardk> applicative: they just used a flawed mechanism to prove the equivalence of it to the traditional formulation
09:28:56 <edwardk> patch-tag: in short that is the name they gave their arrow type, which has kind * -> * -> *
09:29:11 <edwardk> Mathnerd314: check the laws ;)
09:29:24 <edwardk> and note the type is wrong
09:29:54 <edwardk> fmap id = id -- doesn;t seem to hold ;)
09:30:38 <Guest39558> what is wrong whit this code: dzenSwitchWs s = "^ca(1,switch-workspace.pl " ++ (show s) ++ ")" ++ s ++ "^ca()"
09:30:51 <Guest39558> Im afraid the ^ are wrong
09:31:03 <Guest39558> its part of a script i found on the internet
09:31:06 <edwardk> did you miss a show s?
09:31:08 <Guest39558> i have absolutely no idea about haskell
09:31:18 <patch-tag> Guest: what's the error? (maybe use a pastebin)
09:31:31 <Guest39558> there is no error, it just doesnt do what it shold
09:31:34 <edwardk> dzenSwitchWs s = "^ca(1,switch-workspace.pl " ++ show s ++ ")" ++ show s ++ "^ca()"
09:31:39 <edwardk> ?
09:31:42 <patch-tag> Guest: I think I agree with edward
09:31:45 <Guest39558> it shall call switch-workspaces.pl and put the otput in this place
09:31:57 <patch-tag> if you needed to do show s in one place you probably need it in the other
09:32:17 <patch-tag> I guess you're not getting a compile error... just not the behavior you want.
09:32:18 <Guest39558> is ^ca proper haskell syntax??
09:32:25 <Guest39558> exactly
09:32:29 <patch-tag> Guest: nothing in quotes gets evaluated by haskell
09:32:32 <jmcarthur> that's just in a string
09:32:36 <patch-tag> guest: are you coming from perl?
09:32:41 <patch-tag> different world :)
09:32:58 <patch-tag> " is like ' in perl
09:33:01 <Guest39558> ahh so its passed to pearl and NOT evaluated therer it seems
09:33:07 <edwardk> yeah
09:33:14 <patch-tag> " is just syntactic sugar for lists of characters
09:33:15 <Guest39558> i have also no idea abotu perl :)
09:33:20 <applicative> guest, yes, it's haskell writing a bit of perl
09:33:22 <patch-tag> oh false assumption
09:33:25 <jmcarthur> "<stuff>" ++ show s ++ "<stuff>" ++ show s ++ "<stuff>", where <stuff> is not haskell syntax
09:33:43 <patch-tag> guest: what's your main language?
09:33:49 <Guest39558> polish
09:33:53 <Guest39558> :)
09:33:54 <patch-tag> I mean computer language
09:33:57 <applicative> "GOTO " ++ show s
09:34:00 <Guest39558> yeah just joking
09:34:06 <Guest39558> c, c++, java,
09:34:41 <applicative> > let goto n = "GOTO " ++ show n in goto 17
09:34:43 <lambdabot>   "GOTO 17"
09:34:48 <Guest39558> eehehehe
09:34:49 <tensorpudding> Haskell isn't really like any of those languages.
09:34:49 <patch-tag> anyway there's n magic to quotes in haskell
09:34:54 <patch-tag> no magic
09:35:08 <Guest39558> yeah, im fascinated by haskell since about 2 hours
09:35:10 <patch-tag> I guess there is in c?
09:35:17 <Guest39558> never saw it before
09:35:27 <patch-tag> certainly in bash. anyway, not here.
09:36:09 <Guest39558> nah I think this string should be processed in perl by some other application but it just doesnt happen for some reason
09:36:16 <patch-tag> Guest: program.pl is almost polish. so I was almost right.
09:36:40 <applicative> Guest, "blahblah" in the usual haskell representation is a list of characters in the standard sense of list   'b' : 'l' : 'a' ...
09:37:04 <Guest39558> ok
09:37:06 <patch-tag> it's called interpolation in perl/bash, but we don't have it.
09:37:59 <applicative> Guest, a ++ b  just concatenates the lists.
09:38:22 <Guest39558> yah i assumed that
09:38:31 <Guest39558> It just builds a long list / string in my sense
09:38:45 <tensorpudding> (++) works on arbitrary lists due to polymorphism
09:38:55 <applicative> and show x gives the canonical representation of a value if it has one
09:39:20 <applicative> Guest, but it sounds like the problem is coming from somewhere else, can you paste the module
09:39:32 <Guest39558> the problem however is not in the haskell part of the mechanism
09:39:41 <tensorpudding> the representation the programmer chose to code (or not code, if Show was derived)
09:39:59 <patch-tag> Guest: haskell motto is "if it compiles it works"
09:40:00 <Guest39558> thats a config file only but i can paste it
09:40:12 <applicative> tensorpudding, the representation he chose to make canonical?
09:40:13 <Guest39558> Im afraid you wont be able to help but wait a second
09:41:24 <Guest39558> http://pastebin.com/iXD96thf
09:42:07 <Guest39558> but that is just a small part of some bigger mechanism i do not even have the sources here now
09:43:16 <Guest39558> all I know some parameter is set to some string and processed by something , and the output is not satisfying :)
09:43:24 <Guest39558> thats all we can see in this snipplet
09:43:57 <Guest39558> and the haskell part works fine
09:44:02 <applicative> Guest, have you tried #xmonad?
09:44:25 <Mathnerd314> @type Data.Monoid.Endo . mappend -- edwardk, better definition of pure for Endo?
09:44:26 <lambdabot> forall a. (Monoid a) => a -> Endo a
09:44:33 <applicative> it isn't as populous, unfortunately
09:44:50 <edwardk> Mathnerd314: possibly, yes.
09:44:50 <Guest39558> no, but thats an idea
09:45:00 <edwardk> but note
09:45:07 <edwardk> you have a constraint on a
09:45:14 <edwardk> so it fails, its 'RPointed' at best ;)
09:45:24 <Mathnerd314> yeah, so it's a restricted monad/functor/etc.
09:45:31 <patch-tag> does R mean right in Rpointed?
09:45:34 <patch-tag> restricted?
09:45:39 <edwardk> restricted
09:45:51 <applicative> Guest, I just joined and wrote, a
09:45:54 <edwardk> Endo is functor, just not over Hask
09:46:09 <applicative> nyone awake here, and nothing happened.
09:46:13 <edwardk> class ExpFunctor f where xmap :: (a -> b) -> (b -> a) -> f a -> f b
09:46:25 <edwardk> you can make an instance of ExpFunctor over Endo
09:46:44 <patch-tag> What is Exp an abbreviation for?
09:46:49 <edwardk> exponential
09:47:07 <Guest39558> I hope you do not expect me to understand what you say :)
09:47:10 <fax> -> is exponential
09:47:12 <edwardk> the justification for the name is somewhat circuitous.
09:47:15 <fax> it's from category theory
09:47:22 <Mathnerd314> is instance Functor Endo an EndoFunctor, or am I just confusing myself? :p
09:47:24 <Guest39558> I will study haskell and come back one day however ;)
09:47:35 <patch-tag> Guest: we'll be here :)
09:47:39 <fax> if you count the functions {0,1,2} -> {0,1,2,3,4} for example you can see why its called exponential
09:47:45 <applicative> Guest, I joined #xmonad, to see if anyone was there to help.  SOrry, it was a little opaque...
09:48:04 <fax> (also consider the same for products and sums)
09:48:19 <Guest39558> im joining now too
09:48:34 <edwardk> but in short you can look at X | Y as +, data (,) as *, etc. and so functors that are built out of 'sums and products, 0s, 1s, and x's' are 'polynomial' functors
09:49:07 <edwardk> and if you need (->) they become 'exponential functors' in category theory, an object in the category that you can apply is an exponential. (->) plays that role in hask
09:49:11 <applicative> Guest, I haven't been using xmonad lately -- you can get help on #xmonad but you might have to check in a few times.
09:49:46 <applicative> Guest, but on #haskell, you can always get help with Haskell....
09:49:51 <edwardk> patch-tag: http://comonad.com/reader/2008/rotten-bananas/
09:51:14 <Saizan> edwardk: so the category would be the one of isomorphisms over Hask? and the two functions you give to xmap should be inverses then?
09:51:29 <edwardk> Saizan: yeah, either isomorphisms over hask or embedding projection pairs.
09:52:52 <edwardk> you don't need a full isomorphism, just enough to extract from the subset of b in the image. the isomorphism definition is more satisfying though, because then you can flip the args to xmap to get the opposite answer.
09:53:48 <Saizan> uh, lenses
09:53:58 <edwardk> yeah
09:55:26 <patch-tag> edwardk: very intereesting...
09:55:49 <Guest39558> problem solved, thank you too guys
09:56:41 <sadache> hello everyone
09:57:13 <sadache> I have a question about happsStack but there seems noone to answer on #haspps
09:57:21 <sadache>  type UnWebT m a = m (Maybe (Either Response a, FilterFun Response))
09:57:50 <patch-tag> sadache: I think there is also a webdevel channel that might be more active
09:58:11 <patch-tag> that's a nasty type I know, what are you trying to do?
09:58:31 <sadache> why in this type we have Either Response a, a needs to have a class instance
09:58:59 <sadache> but Response can do so too, for response it seems to me the id function
10:00:35 <Haeng_Un> !seen me
10:00:42 <Haeng_Un> .seen regalia
10:01:26 <tensorpudding> preflex: seen regali
10:01:26 <preflex>  Sorry, I haven't seen regali
10:01:29 <tensorpudding> preflex: seen regalia
10:01:29 <preflex>  regalia was last seen on #haskell 15 days, 22 hours, 20 minutes and 45 seconds ago, saying: :t forever
10:02:30 <sadache> why not  type UnWebT m a = m (a, FilterFun Response) and in case of Response you can anyway have an instance of ToMessage on Response
10:03:28 <patch-tag> sadache: I asked jeremy shaw... hunting around for his answer
10:03:47 <sadache> patch-tag: thank you
10:06:13 <patch-tag> sadache, not sure if this helps but http://docs.google.com/View?id=dgvmg8h_80d9dkr9dr
10:06:21 <patch-tag> this should be incorporated into the wiki somewhere
10:07:45 <patch-tag> I have to go, and not sure if I could deliver a satisfactory answer even if I didn't :)
10:23:25 <patch-tag> I put a breadcrumb to hareddit re the discussion of functor -> pointed functor -> applicative: http://www.reddit.com/r/haskell/comments/bp4a8/programming_with_effects_the_story_so_far/c0obgq7
10:24:33 <Saizan> sadache: the Left is used to ignore the filters
10:34:23 <jmcarthur> overloaded whitespace! http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24906
10:34:50 <ezyang> wat
10:35:29 <jmcarthur> woops, i used ($) instead of whitespace in the kleisli example
10:35:30 <dolio> Take that, Arc!
10:35:36 <jmcarthur> well, take that to mean that both work ;)
10:36:28 <siracusa> Where can I find information about all the result types that are possible for `a =~ b' ?
10:36:53 <jmcarthur> i haven't worked on the Mapping class much. this was just some test code. i will probably put the preprocessor and the Mapping class in separate packages on hackage. i want to see some cool uses for both ;)
10:37:25 <jbapple> siracusa: where did you find "=~"?
10:37:29 <jmcarthur> dolio: does arc have overloaded whitespace or something?
10:37:55 <siracusa> jbapple: I'ts in the Text.Regex modules
10:37:55 <dolio> I think it lets you use arrays and maps as if they were functions.
10:37:58 <dolio> Or something like that.
10:37:59 <jmcarthur> ah
10:38:14 <dolio> That was one of the big selling points, as I recall.
10:38:23 <Twey> @let zipMap = flip fmap fmap (fmap (flip fmap fmap) (fmap join)) (flip zip)
10:38:24 <lambdabot>  Defined.
10:38:47 <pippijn> flip flap
10:38:47 <jmcarthur> the related Mapping class and some instances: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24906#a24908
10:39:09 <jmcarthur> on the downside, the error message you get if you mess up are extremely opaque :(
10:39:14 <jmcarthur> *messages
10:39:45 <jmcarthur> and many function combinators need to be reimplemented to take advantage of the full generality
10:40:17 <siracusa> A lot of them are described here http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/, but at least [[String]] is not, so maybe there are even more.
10:40:50 <jmcarthur> all the preprocessor does is replace function application with ($)
10:48:54 <jmcarthur> i'm debating whether to change Mapping to take * -> * instead of just *
10:49:05 <jmcarthur> or something
10:49:36 <jmcarthur> it just seems too general, like it would be tempting to define many instances for the same type
10:50:14 <jmcarthur> or something
10:50:36 * jmcarthur just realizes he said "or something" twice
10:51:12 <fax> lol
11:04:05 <Gwern-away> @quote
11:04:05 <lambdabot> xDie says: <xDie> > 1.1.1.1.1.1.1.1.1.1.1.1 + 2.3
11:04:22 <Gwern-away> > 1.1.1.1.1.1.1.1.1.1.1.1 + 2.3
11:04:23 <lambdabot>   No instance for (GHC.Real.Fractional (a1 -> a))
11:04:23 <lambdabot>    arising from the literal...
11:05:19 <benmachine> @quote gwern
11:05:19 <lambdabot> gwern says: all good languages are but corruptions or extensions of haskell
11:26:19 <BMeph> Does anyone here use Maude on a regular basis?
11:26:51 <BMeph> Heck, does anyone here use Maude on an irregular basis? :)
11:27:07 <fax> I never used it but I read a little about it seems really cool
11:32:19 <BMeph> BRB - networking reset...
11:33:53 <siracusa> Does Gtk2Hs provide changing the look and feel?
11:34:19 <JuanDaugherty> looks to me like something I would look at and then look for rewriting and equational logic pkgs in haskell
11:35:16 <pippijn> maude is pretty neat
11:35:21 <pippijn> I've played around with it
11:40:26 <BMeph> JuanDaugherty: I think there's a different "fee" between a package that lets you do rewriting and equational logic, and a language based on it.
11:40:43 <BMeph> Er, s/"fee"/"feel"/
12:00:46 <benmachine> @pl \s -> hPutStrLn h s >> putStrLn h s
12:00:46 <lambdabot> ap ((>>) . hPutStrLn h) (putStrLn h)
12:26:07 <doofer> I'm having some troubles with existentially quantified types and sets, where the difference operation falls into an endless loop if its second argument has an element not in the first argument. Anyone know what might be causing this? Code here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24910#a24910
12:33:31 <siracusa> doofer: Does it work if you give all values in both lists an explicit type signature?
12:35:14 <doofer> siracusa: No, doesn't seem to be working if I make it say "f n = Any (Box n :: Box Char)" for instance
12:45:03 <siracusa> doofer: Ah, it's quite simple to fix, you only define the < operator for comparison. If S.\\ uses e.g. >, it falls back to the standard definition which causes a loop
12:45:13 <siracusa> doofer: Better use `compare (Any (Box i)) (Any (Box j)) = compare i j'
12:45:46 <monochrom> Yeah, try f 1 > f 2
12:46:55 <monochrom> If you define <= then all is well.
12:47:13 <monochrom> everyone calls compare, compare calls just == and <=
12:47:14 <doofer> siracusa: Ooh, thank you! I just assumed that > would be automagically defined for me. Guess that wasn't the case. :)
12:47:36 <jmcarthur> well it was. it just wan't what you wanted
12:48:02 <doofer> monochrom: ah, minimal complete definition: (<=) or compare. I guess I should have read the docs more carefully!
12:48:04 <monochrom> See http://haskell.org/onlinereport/basic.html#sect6.3.2
12:48:55 <doofer> ah
12:49:25 * hackagebot mkcabal 1.0.0 - Generate cabal files for a Haskell project  http://hackage.haskell.org/package/mkcabal-1.0.0 (DonaldStewart)
12:49:38 <jmcarthur> woah mkcabal hit 1.0?
12:49:55 <idnar> hit it in the face?
12:50:07 <jmcarthur> does it have any advantages over cabal init? i haven't used it since i found cabal init
12:50:48 <dons> read the page ...
12:50:59 * jmcarthur is doing that now
12:51:05 <DigitalKiwi> things i find i want, ncmpcpp without the mpd, wicd without the python, EAC without the windows, pacman clone without the C, aur helper without the <anything but haskell>, pastebin  client, rtorrent without the lack of control...what should i start with? :D
12:51:08 <jmcarthur> oh haha
12:51:42 <jmcarthur> DigitalKiwi: why would you want ncmpcpp without the mpd?
12:52:17 <BMeph> dons: So, that's just a fancy way for you to say, "Uncle!" eh? ;)
12:52:32 <DigitalKiwi> because mpd is a bigger hassle to configure and more dependencies i don't need as I use none of its features, but ncmpcpp is the best on console music player i have found
12:53:14 <jmcarthur> you could make your own backend for ncmpcpp that follows the mpd protocol perhaps
12:53:15 * BMeph wonders why there hasn't been a reddit announcement of mkcabal being superceded by 'cabal init' yet... ;þ
12:53:19 <monochrom> Great, a new version to say "I am deprecated" :)
12:53:20 <jmcarthur> but i really don't see what the advantage would be
12:53:56 <jmcarthur> even if ncmpcpp was standalone you would still have to configure it and bring in a lot of dependencies
12:54:51 * jmcarthur hates typing "ncmpcpp"
12:55:06 <dons> BMeph: do you think mkcabal is significant enough to warrant an announce?
12:55:15 <dons> i wonder how many downloads
12:55:23 <DigitalKiwi> jmcarthur: yeah a new name too!
12:55:32 * BMeph suggests DigitalKiwi do the pastebin client
12:55:34 <dons> 200 downloads in Q1, not worth an announce.
12:56:03 <dons> monochrom: right. to say 'this is done- don't use it'  that's accepted practice
12:56:06 <dons> esp. since we can't delete projects
12:56:10 <jmcarthur> DigitalKiwi: grab the hmp3 source and extend it :)
12:56:41 <DigitalKiwi> what is hmp3?
12:56:43 <BMeph> dons: <snarks deadpannily> I wasn't aware "significance" was a factor in your reddit announcements...
12:56:46 <jmcarthur> i wouldn't want projects to be deleted anyway
12:57:03 <jmcarthur> DigitalKiwi: an ncurses mp3 player in haskell
12:57:09 <DigitalKiwi> oh
12:57:11 <DigitalKiwi> cool
12:57:13 <jmcarthur> not sure if it does other formats
12:57:13 <DigitalKiwi> hmm
12:57:24 <jmcarthur> i think dons made it?
12:57:25 <monochrom> This is an artifect of a hackage webpage generated from a package upload solely and nothing else. Therefore to announce anything you must upload a full package.
12:57:27 <jmcarthur> i haven't used it
12:58:02 <FunctorSalad>  dons: new version?
12:58:12 <FunctorSalad> I did use the old one
12:58:20 <dons> why are people talking about this?
12:58:57 <FunctorSalad> you were asking about doing an announce
12:59:00 <BMeph> dons: Duh - we're talking about it, because it has ->Your<- name on it! :)
12:59:39 <monochrom> I am talking about this because I see a limitation of the hackage infrastructure.
12:59:52 <dons> monochrom: yeah, you can't edit the metadata
12:59:58 <dons> without uploading
13:00:14 <jmcarthur> can you upload without bumping the version?
13:00:31 <FunctorSalad> you could bump it just a little bit
13:00:43 <FunctorSalad> does it allow a fifth part?
13:00:50 <jmcarthur> i'm sure it does
13:01:05 <sinelaw> hi all
13:01:06 <jmcarthur> but i was just thinking that if you could do it without a version bump then that would be equivalent to just changing metadata
13:01:18 <jmcarthur> like, if it replaced the old version
13:01:20 <dons> no, you can't
13:01:28 <dons> you can't clobber existing versions
13:01:41 <jmcarthur> that makes sense, of course. don't want to lose things
13:01:48 <jmcarthur> which is why i'm happy with being unable to delete packages, too
13:02:55 <monochrom> The correct way is to have meta-meta-data. meta-meta-data is versioned separately like wiki.
13:05:39 <bluetaslem> Hi.
13:06:01 <fax> hi]
13:09:16 <bluetaslem> WHat exactly is the purpose of "Maybe"
13:09:36 <bluetaslem> That is to say, I'm just learning it, and don't quite understand its purpose.
13:09:40 <fax> it's a monad
13:09:53 <bluetaslem> hm?
13:10:07 <sepp2k> bluetaslem: The purpose is to e.g. define a function that maybe returns something or maybe not.
13:10:10 <writer> and nice where you want to indicate something equivalent of C/C++/Java's NULL/null
13:10:12 <fax> you can think fo it like a baby version of the list monad
13:10:35 <fax> with Maybe you'll either have no value (Nothing) or some value (Just x)
13:10:39 <bluetaslem> So, sort of the ability to return different types of results?
13:10:44 <silver> no
13:10:48 <fax> not different types
13:10:58 <bluetaslem> I see.
13:11:36 <bluetaslem> Now, would I be right in saying that "Just" essentially   is (almost) like a function, that returns the "Maybe ..."  where ... is the type of the thing after it?
13:12:20 <fax> yes
13:12:26 <fax> that is exactly right
13:12:39 <bluetaslem> Now is it a function?
13:12:45 <fax> yes
13:12:56 <bluetaslem> Is Maybe a function?
13:13:09 <sepp2k> No, it's a type.
13:13:11 <fax> well you know that there are values and types in haskell
13:13:15 <fax> and they never mix
13:13:18 <bluetaslem> I see.
13:13:25 <fax> Just takes one value to another (it's a function)
13:13:31 <fax> and Maybe takes one type to another (it is also a function)
13:13:35 <bluetaslem> Trying to figure out if its like a function, or a predeccesor to a type that generates a new type.
13:13:58 <fax> but Just :: a -> Maybe a, where as Maybe :: * -> *
13:14:09 <fax> the stuff with *'s is a kind (that's the type of types types)
13:15:18 <Saizan> bluetaslem: you can think of Maybe as a function at the type level, what that means is that it takes a type and gives you another type
13:15:39 <bluetaslem> Thats what I was thinking.
13:15:48 <bluetaslem> Then, is it literally stored as a function?
13:15:56 <bluetaslem> If so, what Typeclass does it belong to?
13:16:17 <Saizan> specifically, it's a type constructor, because an application of Maybe to some type doesn't reduce to anything else
13:16:39 <fax> my advise is not to think about 'stored as' because how things are implemented can be completely different than the simplest or most flexible sort of conceptualization you can have
13:16:54 <Saizan> it's not literally stored as a function, it's irrelevant at runtime
13:16:57 <fax> but you can be sure that all types are erased during compliation
13:17:04 <bluetaslem> Hm.
13:17:06 <bluetaslem> ow, just curious..
13:17:15 <bluetaslem> How would you make something like a game in Haskell?
13:17:30 <bluetaslem> Because, you'd have to loop, wouldn't you?
13:17:38 <Berengal> You start out with an idea, then you program it
13:17:46 <bluetaslem> Not what I meant.
13:17:52 <fax> you can implement loops using recursion
13:18:01 <bluetaslem> MKay, thats what I thought.
13:18:07 <bluetaslem> Now, just curious..
13:18:11 <Berengal> Recursion, or since your game probably lives in a monad, forever is a nice function
13:18:17 <bluetaslem> Couldn't that eventually cause a problem with memory
13:18:30 <fax> only if you did it wrong
13:18:37 <bluetaslem> Because, the Stack would eventually become too high.
13:18:40 <Berengal> Just because you're using recursion doesn't mean you have to use extra stack
13:18:45 <fax> if you get memory problems you can fix them
13:18:52 <bluetaslem> True.
13:18:55 <bluetaslem> Hm..
13:19:03 <bluetaslem> Is it possible to tell Haksell to "Forget" something?
13:19:09 <Berengal> Anything that can be written as a simple loop can be written as a tail-recursive function, and tail-recursive functions don't need extra stack
13:19:42 <bluetaslem> Thanks.
13:20:00 <Berengal> Forget how? Delete?
13:20:21 <fax> bluetaslem: you mean like malloc/free type stuff?
13:20:36 <bluetaslem> Um, hard to describe...
13:20:45 <bluetaslem> Its a problem I can't figure out exactly how to portray..
13:21:02 <bluetaslem> Essentially, running a loop that you externally calculate is infinite, and then need to terminate.
13:21:11 <bluetaslem> Is it posible to order haskell to ignore it, and just not care?
13:21:18 <bluetaslem> Stop evaluation?
13:21:20 <Berengal> Not really. There are ways to manually allocate memory, but those live outside the built-in allocation/garbage collection scheme
13:21:35 <Saizan> bluetaslem: oh, you can make that evaluate in a different thread and kill it
13:21:45 <bluetaslem> Okay, that makes sense.
13:21:56 <bluetaslem> Now, how does one ceate thread sin Haskell?
13:21:57 <roconnor> > forever (left "exit")
13:21:58 <lambdabot>   Couldn't match expected type `a b c'
13:21:58 <lambdabot>         against inferred type `[GHC.Ty...
13:21:59 <Saizan> bluetaslem: though there are some problems with preemption in GHC's concurrency
13:22:06 <roconnor> > forever (Left "exit")
13:22:07 <lambdabot>   Left "exit"
13:22:40 <Saizan> bluetaslem: you simply use "forkIO what_to_do_in_the_new_thread"
13:22:51 <Saizan> ?type forkIO
13:22:52 <lambdabot> Not in scope: `forkIO'
13:23:02 <Saizan> ?hoogle forkIO
13:23:03 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
13:24:33 <fax> luetaslem: uh I dunno I think you are looking for problems that don't exist
13:24:49 <fax> bluetaslem: main thing to remember is if stuff is broken you're gonna know and be able to fix it
13:29:03 <bluetaslem> I'm having trouble understanding this...
13:29:09 <bluetaslem> Could I post a 2 line code here?
13:29:32 <bluetaslem> infixrÂ 5Â :-:Â Â 
13:29:36 <bluetaslem> dataÂ ListÂ aÂ =Â EmptyÂ |Â aÂ :-:Â (ListÂ a)Â derivingÂ (Show,Â Read,Â Eq,Â Ord)Â Â 
13:30:03 <bluetaslem> I understand what it does. But I don't understand how.
13:30:23 <Saizan> what are you referring to in particular?
13:30:35 <tensorpudding> hmm, NO-BREAK SPACE
13:30:54 <bluetaslem> I got it from a tutorial.
13:31:20 <bluetaslem> It makes a system where you can create a sort of pseudo-list   using:     5 :-: 6 :-: Empty
13:31:25 <Saizan> that's defining the List type constructor, giving its two value constructors Empty and (:-:)
13:31:41 <Berengal> Not a pseudo-list, a real list
13:32:04 <bluetaslem> Its not Typed like a real list I've ye tto see.
13:32:07 <bluetaslem> *yet to
13:32:10 <Berengal> That's exactly how lists are defined in Haskell, except the syntax is different
13:32:23 <brooksbp> What's the difference between let-polymorphism and parametric polymorphism?
13:32:31 <sepp2k> bluetaslem: It's exactly the definition of the built-in list except with different names
13:32:42 <bluetaslem> I see.
13:33:02 <bluetaslem> So, sicne you're using "List" it basically assumes what the operator does?
13:33:07 <sepp2k> @src []
13:33:08 <lambdabot> data [] a = [] | a : [a]
13:33:35 <Berengal> Operators in Haskell are just functions. This one's also a constructor
13:33:40 <Saizan> brooksbp: let-polymorphism is a specific way to allow definitions that are parametrically polymorphic in your language
13:34:14 <bluetaslem> But, I mean...
13:34:21 <Saizan> brooksbp: it refers to how in HM type inference only let bound variables are given a polymorphic type
13:34:42 <bluetaslem> Where is the function defined?  That code never states exactly what ":-:" should do, as far as I can see.
13:34:57 <sepp2k> bluetaslem: It's defined right there.
13:35:14 <Saizan> brooksbp: this ends up restricting you to only rank-1 types
13:35:25 <sepp2k> data Foo = Bar | Baz  defines the type Foo and the constructors Bar and Baz
13:35:44 <brooksbp> Saizan: So... it's like universal types only for let constructs instead of everywhere like in System F?
13:35:53 <Berengal> bluetaslem: As a data constructor it doesn't need any more definitions than that. Data constructors are functions that return values you can deconstruct by "unapplying" the same constructor in a pattern match... ish
13:35:58 <FauxFaux> brooksbp: CRYYYYYYYYYYYYYYYYYYYYYYYY.
13:36:04 <Saizan> bluetaslem: "aÂ :-:Â (ListÂ a)" in "dataÂ ListÂ aÂ =Â EmptyÂ |Â aÂ :-:Â (ListÂ a)" is what defines (:-:)
13:36:14 <brooksbp> FauxFaux: ?
13:36:20 <bluetaslem> So it assumes that it acts that way, becaus eof the type its being applied to?
13:36:57 <Berengal> bluetaslem: No, it assumes it acts that way because it's defined in a data declaration. Also, all constructors start with capital letters, or if they're operators, the symbol ':'
13:37:21 <BMeph> BBL...
13:37:22 <bluetaslem> Okay, thanks.
13:37:49 <Saizan> brooksbp: yeah, and type abstractions/applications are hidden behind the scenes
13:48:51 <chipmonkpyro> hiya; Im trying to load this file (http://www.cis.syr.edu/courses/cis252/code/Turing.hs) by placing the line import Turing, as it is in this file (http://www.cis.syr.edu/courses/cis252/code/hw09-sample.hs) but from some reason even though I'm being told both modules are loaded ok [Ok, modules loaded: Turing, Main.] but none of the functions from Turing are evaluating properly in the buffer...
13:48:53 <chipmonkpyro> ...and giving me "not in scope". Both files evaluate individually and when I load Turing by itself all the functions in Turing evaluate just fine but for some reason when I try to use "import" it doesnt work. Any ideas anyone??
13:58:30 <chrisdone> sup homes
14:01:25 <hpaste>  hpaste feed bot should be ok now (chrisdone)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24913
14:02:19 <fax> sup
14:04:06 <scree> chipmonkpyro: import doesn't work in ghci.  You need to do :m +Turing
14:04:48 <chipmonkpyro> in the buffer?
14:05:37 <scree> chipmonkpyro: in the ghci prompt, yes
14:06:00 <chipmonkpyro> is there anything i can put in the file itself or is that the only option?
14:07:22 <scree> chipmonkpyro: you could write the modules in a different order on the command line -- iirc the first one is in scope -- but to get both you need a :m + I think
14:13:37 <scree> chipmonkpyro: correction: you can also (1) force ghci to dynamically compile, or (2) explicitly re-export Module1 in Module2's signature
14:25:55 <HugoDaniel> hello
14:27:36 <Stalker> COME ON #E3B and say the WORDS: ALLAH OUAKBAR! You could win instantly! Come on #E3B and say the words ALLAH OUAKBAR! /join #E3B say the WORDS: ALLAH OUAKBAR! and YOU COULD WIN ! COME NOW ON #e3b AND SAY THE WORD: ALLAH OUAKBAR! #E3B ALLAH OUAKBAR ! RIGHT NOW! YOU COULD WIN A PRIZE INSTANTLY!
14:29:11 <alpounet> hmm
14:29:18 <alpounet> can we visualize finger trees with vacuum-cairo ?
14:31:49 <kmc> yes
14:32:00 <Gwern-away> > 478 / 14.5
14:32:01 <lambdabot>   32.96551724137931
14:34:45 <alpounet> neat
14:44:45 <aep> uuuh
14:44:47 <aep> <stdin>: hGetContents: invalid argument (Invalid or incomplete multibyte or wide character)
14:45:28 <aavogt> String IO is now interpreted as UTF8 now
14:46:03 <aep> great. what if i dont have utf8 input?
14:46:41 <aavogt> then set whichever mode you use for the handle stdin
14:46:52 <aavogt> @docs System.IO
14:46:52 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
14:46:59 <aep> yeah well, i dont use it directly. this is some parsec parser
14:47:23 <aep> i'm parsing mail, so its invalid crap in spam anyway. can i just tell it to ignore invalid chars?
14:47:39 <aavogt> you can catch the exception
14:47:46 <aep> hm good idea
14:48:10 <libero> hi
14:48:23 <aep> hm no i can't. parse just returns :(
14:49:01 <aavogt> aep: you're using Prelude.catch?
14:49:24 <aep> no. i'm not using anything. i have to read up on howe exceptions work first
14:49:56 <mauke> parsec reads from strings, not filehandles
14:50:17 <aep> well the example does: parse message "<stdin>" (fixEol input)
14:50:53 <hpaste>  simple html ls generator (zk)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24914
14:52:04 <zachk> oh no it broadcasts to the channel again
14:54:32 <aep> aah input <- getContent
14:54:42 <aep> but that doesnt throw at all
14:54:47 <mauke> lazy IO
14:54:53 <aep> yeah, i see
14:55:10 <aep> can i force evaluation?
14:55:59 <aep> maybe this shouldnt be getContents in the first place. i remember that was evil
14:56:16 <dancor> aep: do you want to catch the error (ignoring that whole getContents) or just ignore single bad characters
14:56:33 <aep> the later
14:56:46 <int-e> aep: hSetBinaryMode stdin True  may be worth a try
14:56:59 <dancor> aep: and you need to process well-formed unicode?  or just ascii?
14:57:10 <mauke> unicode has no form
14:57:19 <dancor> thought-police
14:57:20 <int-e> (which will give you characters as byte as before, but you'll have to convert CR/LF to LF on your own)
14:58:00 <aep> i think thats what i want. since its mail, i dont know which encoding it has before parsing it
14:58:39 <mauke> mail should be 7-bit ascii
14:58:44 <aep> hehe yeah... should
14:59:22 <aep> damn, the parser fails anyway at everything else :(
14:59:35 <aep> real life mail is not compliant in any sane way.
15:00:56 <dancor> is there a processUtf8AsBestYouCan :: [Word8] -> String
15:01:04 <mauke> http://video.google.com/videoplay?docid=7054401183589794595#
15:01:05 <dancor> @hoogle [Word8] -> String
15:01:05 <lambdabot> Prelude show :: Show a => a -> String
15:01:06 <lambdabot> Text.Show show :: Show a => a -> String
15:01:06 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
15:03:21 <dancor> there are a lot of times when you just want to make the best of rouge input
15:03:24 <Gwern-away> dancor: utf8-string is no good?
15:04:43 <dancor> Gwern-away: ah that looks good
15:04:45 <dancor> Errors are replaced by character '\0xFFFD'.
15:05:22 <aep> cool thanks
15:05:49 <dancor> probably makes sense to use that with bytestring
15:06:03 <sadache> can anyone provide me with a reference to what one needs to port yhc on .net?
15:06:41 <aep> oof. even after stripping the chars, it still whines.  any idea if there is a real life tolerant mail parser?
15:07:55 <HugoDaniel> how do i define a vector for my own data type ?
15:09:43 <ozataman> Anyone know why one would get the "hGetContents: invalid argument (Illegal byte sequence)" error when reading a file with readFile?
15:10:10 <alpounet> @src mod
15:10:10 <lambdabot> Source not found.
15:10:18 <alpounet> @hoogle mod
15:10:18 <lambdabot> Prelude mod :: Integral a => a -> a -> a
15:10:18 <lambdabot> Data.Fixed mod' :: Real a => a -> a -> a
15:10:18 <lambdabot> Text.PrettyPrint.HughesPJ data Mode
15:10:20 <alpounet> hm
15:12:54 <mauke> ozataman: because the file is not in the encoding you think it is
15:13:05 <ozataman> mauke: ah I see.. OK, thanks.
15:13:19 <ozataman> mauke: is there a good way to determine the encoding of a file?
15:14:00 <mauke> well, you can open it in a text editor and guess based on what you see
15:15:24 <chipmonkpyro> scree: even with the :m + doesnt seem to be working, the functions defined in Turing still arent being defined...
15:15:51 <ozataman> mauke: right.. I'm trying to set up an automated way to do it though...
15:16:02 <mauke> impossible in general
15:16:03 <hpaste>  integral (roconnor)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24915
15:16:19 <ozataman> mauke: ok thanks
15:17:34 <ezyang> O.o. Suddenly . (.) makes a lot more sense
15:17:49 <hpaste>  . (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24916
15:18:04 <chipmonkpyro> scree: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24916#a24916
15:19:39 <chipmonkpyro> for anyone else who wants to help the function startState is defined in the module Turing but is still not being defined when I reference Turing using :m +Turing
15:20:05 <chipmonkpyro> no idea why...
15:21:40 <chipmonkpyro> you can see Turing @ (http://www.cis.syr.edu/courses/cis252/code/Turing.hs) and hw09-sample.hs @ (http://www.cis.syr.edu/courses/cis252/code/hw09-sample.hs)
15:23:15 <brooksbp> The STLC rule for application is (e1 : t1->t2) (e2: t1) ==> (e1 e2) : t2 ... Would it be okay to create a type system where the rule for application is (e1 : t1->t2) t1 != t2  (e2: t1) ==> (e1 e2) : t2 ??
15:23:34 <sykopomp> are there any good examples of Haskell with subtype inheritance? I've found a page on O'Haskell. I'm not sure if there's already an extension that provides this.
15:23:58 <fax> brooksbp - that would be a disastiar
15:24:39 <fax> brooksbp do you know the key properties of a type system?
15:25:01 <brooksbp> fax: what do you mean key properties
15:25:15 <fax> ill write them out
15:28:09 <ddarius> fax: That rule wouldn't make the system unsound.  You'd probably get a violation of subject reduction.
15:28:21 <fax> um struggling to remember the last one
15:28:24 <fax> subject reduction - if t : T and t --> t' then t' : T (modify this for subtyping)
15:28:27 <fax> soundness - if t : T then t does not go wrong*
15:29:27 <brooksbp> fax: In my type system I have another form of application that can handle applications not typable by the judgement I gave above... So is this still okay?
15:30:44 <Cale> brooksbp: Your rule is insisting that the function's domain and codomain are distinct?
15:30:58 <brooksbp> Cale: which rule?
15:31:17 <Cale> "(e1 : t1->t2) t1 != t2  (e2: t1) ==> (e1 e2) : t2"
15:31:23 <Cale> I'm not sure how I'm supposed to parse that
15:31:56 <brooksbp> Basically, I want to create an application rule that specifies that the function type cannot be int->int, bool->bool or any \forall basetype. basetype->basetype .... So what would that function type look like?
15:32:24 <fax> PRESERVATION AND PROGRESS
15:32:33 <Cale> Well, that also excludes things like (Int -> Int) -> (Int -> Int) and so on.
15:32:37 <fax> now I need to lie down
15:32:50 <brooksbp> Cale: Yes I want to make them distinct but I don't know how to express
15:33:28 <Cale> Well, I'm not sure why you'd want to do that, but sure, that rule makes some amount of sense, anyway :)
15:33:49 <brooksbp> Cale: Well no because Int->Int isn't a basetype... so (Int->Int)->(Int->Int) isn't typeable by \forall basetype.basetype->basetype
15:34:26 <Cale> Do t1 and t2 only range over base types?
15:35:04 <brooksbp> I want t1 and t2 to range over everything except for when t1 == t2 and t1, t2 \in basetype
15:35:11 <brooksbp> So what would that function type look like?
15:35:55 <Cale> Just write that condition out. The typing rules are arbitrary logical implications.
15:36:31 <brooksbp> Could you explain how to do that?
15:38:27 <Cale> e1 : t1 -> t2 and e2 : t1 and not (t1,t2 \in basetype and t1 = t2) => (e1 e2) : t2
15:39:32 <brooksbp> Oh.  Yeah... I see what you mean
15:40:13 <mauke> t1 â basetype, t2 â basetype\{t1}
15:41:09 <Cale> mauke: Apparently he wants the rule to cover cases where t1 and t2 are equal non-base types
15:42:05 <Cale> (but that would be a nice way to write it otherwise :)
15:43:09 <brooksbp> Cale: I want to cover the case where: not (t1 and t2 are the same basetype)
15:47:42 <brooksbp> Which would be a more appropriate way of writing: t1, t2 \in BaseType \wedge t1 = t2  ...OR... t1, t2 \in BaseType . t1 = t2   ... are they the same thing?
15:51:39 <ddarius> brooksbp: The former.
15:56:33 <hpaste>  . (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24917
15:57:50 * kmc writes "I will not use Char to do binary I/O" on the blackboard 500 times
15:58:24 <ivanm> kmc: :o this sounds like a good story...
15:58:41 <aavogt> looking at ghci's sources surprises me considering how well it works
15:58:52 <Cale> At one point, there was no other way to do it
15:58:58 <ivanm> @remember aavogt looking at ghci's sources surprises me considering how well it works
15:58:58 <lambdabot> Nice!
15:59:05 <kmc> the story is just that i was writing binary pgm using '\x00' for black and '\xff' for white
15:59:19 <ivanm> thank you for that ringing endorsement of my ability to pick quotes to remember, lambdabot
15:59:24 <kmc> but of course '\xff' utf-8 encodes to something else
15:59:37 <ivanm> heh
16:00:14 <kmc> last time i had this problem, it was more obvious because i tried the program on GHC 6.10.x and it worked
16:00:19 <kmc> but it appears i do not learn...
16:00:38 <Cale> The cheesy solution would be to open the handle in binary mode, but it's a lot simpler just to use ByteString probably
16:00:49 <aavogt> I'm trying to make the import qualified with renaming work correctly
16:00:57 <ivanm> if anyone here has a reddit account, they might want to point out gwern's change-monger app here: http://www.reddit.com/r/haskell/comments/bsett/are_there_tools_that_would_be_suitable_for/
16:02:48 <kmc> Cale, does binary mode turn off utf encoding?
16:02:56 <kmc> i thought it was more a system level thing, newline conversion and such
16:03:02 <kmc> and yeah i used bytestring eventually
16:03:15 <hpc> text mode converts \n and \r
16:03:21 <hpc> binary mode does nothing
16:03:28 <ivanm> kmc: I think it does turn of encoding
16:04:08 <kmc> oh
16:04:52 <kmc> hmm yeah it does
16:05:05 <kmc> i'm used to not caring about "binary mode" since i never use windows
16:06:34 <Cale> As I understand it, binary mode is mostly for the sake of easily converting old Haskell programs which assumed things about how characters would be encoded in order to write binary files (pre-ByteString,etc.)
16:07:17 <ivanm> Cale: and I presume it's better for binary data... >_>
16:07:25 * hackagebot Agata 0.2.0 - Generator-generator for QuickCheck  http://hackage.haskell.org/package/Agata-0.2.0 (JonasDuregard)
16:07:46 <Cale> ivanm: Well, if you're writing binary data, you probably don't really want to use String IO at all.
16:07:58 * ivanm does
16:08:08 <ivanm> since I need String output at times as well ;-)
16:09:13 <Cale> I would say better to keep things all binary then, and use one of the UTF-8 ByteString encoders on Hackage.
16:09:24 <ivanm> huh?
16:09:37 <Cale> If you're interspersing text and binary data
16:09:45 <ivanm> Cale: this is what I'm doing it in: http://hackage.haskell.org/packages/archive/graphviz/2999.8.0.0/doc/html/src/Data-GraphViz-Commands.html#graphvizWithHandle%27
16:10:05 <ivanm> (note: I will probably switch to using Text rather than String in a future release, in which case I _won't_ be using String IO)
16:11:17 <kmc> suppose i'm using an IOVector Bool in several threads in a totally unsynchronized way
16:11:33 <kmc> but the vector starts out all False, and all they do is read it and set various cells to True
16:11:37 <kmc> is anything likely to go wrong?
16:11:59 <ivanm> Cale: I at times get the String output and parse it internally rather than writing it to file, so atm I need it to return a String
16:12:28 <Cale> kmc: Does what they read affect how they set the cells?
16:13:01 <kmc> yes.  it's a nondeterministic simulation, and i'm aware that by doing things this way, i introduce the scheduler's nondeterminism into it
16:13:09 <kmc> but i think that's fine
16:13:36 <Cale> I suppose you can always just try it and introduce synchronisation later if there's a problem
16:13:41 <kmc> yeah
16:14:05 <kmc> basically i'm okay with the semantics, as long as there's no observable "garbage" state between False and True
16:14:07 <Cale> kmc: The worst thing that might happen is that the progress might not be monotone
16:14:12 <kmc> how so?
16:15:09 <Cale> kmc: Suppose we have the vector 00 to start with, and thread A and thread B both read the vector, and then thread A tries to set the first element, so sets 10, and thread B tries to set the second, so it sets it to 01
16:15:36 <Cale> and the 1 in the first position is lost
16:15:37 <aavogt> but isn't this like  [IORef Bool]?
16:15:55 <aavogt> where writes to one cell don't affect any others
16:15:55 <Cale> I don't know
16:16:04 <Cale> If that's the case, you'll be fine
16:16:16 <djahandarie> Is it possible to convert an arbitrary quiver to a quantum group?
16:16:36 <Twey> djahandarie: Wrong channel still?  :Ã¾
16:16:41 <djahandarie> Not this time
16:16:41 <Twey> Ah
16:16:46 <Cale> djahandarie: hmm, I don't really know enough about quantum groups to answer that.
16:17:19 <kmc> Cale, hmm. i think writes to different cells of an unboxed vector should commute
16:17:21 <kmc> but i'm not sure
16:17:35 <djahandarie> Because I went to a seminar awhile ago and the guy mentioned that you can do that... but that'd be pretty interesting considering there is no other way to do so in a rigerous process
16:17:47 <erikc> kmc: powerpc hardware commutes them :)
16:17:47 <aavogt> you can quickcheck that
16:18:20 <Cale> Is IOVector from the new Vector library?
16:19:08 <djahandarie> I think I should e-mail this guy
16:19:21 <kmc> yeah
16:19:25 <ivanm> @tell Paczesiowa wow, that 1 < x < 100 code you wrote is an absolute abomination! btw, readLn = read `fmap` getLine
16:19:25 <lambdabot> Consider it noted.
16:19:47 <Cale> djahandarie: So we start with a quiver -- maybe a representation of a quiver? And we're trying to build some sort of Hopf algebra on it?
16:19:49 <Twey> ivanm: Is it?  I thought it was getLine >>= readIO
16:20:14 <ivanm> oh? what's the difference?
16:20:18 <ivanm> @src readLn
16:20:18 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
16:20:28 <ivanm> wow, hlint wouldn't like that definition :p
16:20:39 <Twey> There you go
16:20:46 <Twey> readIO throws an IO exception when parsing fails
16:20:51 <ivanm> *nod*
16:20:52 <djahandarie> Cale, the guy gave an example from a Dynkin diagram, I think A_5
16:21:00 <Twey> Also, it's strict as IO
16:21:26 <ivanm> @tell Paczesiowa my mistake, readLn = getLine >>= readIO (though for the purposes of your code there it doesn't make a difference AFAICT)
16:21:26 <lambdabot> Consider it noted.
16:22:19 <djahandarie> Actually I have like a number of questions for that guy so I think I'm going to email him
16:23:27 <Cale> djahandarie: Probably a good idea. I have a vague sense that it's maybe something like the Coxeter group construction, but I really have no idea what I'm talking about in this area ;)
16:23:41 <djahandarie> Because he also mentioned converting a group algebra into a quiver... I asked him to do a symmetric group like S_3 and his representation only had one node and two paths even though the symmetric group has at at least like 3 eigenvalues
16:23:53 <djahandarie> Cale, well, neither do I, but it got me interested enough. :D
16:56:47 <Resbaloso> It is time to put those Haitian jigaboos in their place!  No matter how many times the civilized world donates money, opens schools, rebuilds their nation, and holds their little monkey paws, the damn niggers can never get it right.  Mexicali had a worse earthquake than Haiti, and only about 4 people died!  Even the housing of the poor generally held up!  If you are sick of the fecal beast Join Chimpout Forum!
16:57:05 <Resbaloso> Why did Mexicali fare well with an earthquake worse than Haiti's?
16:57:06 <tensorpudding> @ops
16:57:06 <lambdabot> Maybe you meant: docs oeis pl
16:57:11 <Resbaloso> It is a city of near a million people
16:57:13 <djahandarie> @where ops
16:57:13 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
16:57:16 <Resbaloso> the haitian niggers
16:57:24 <Resbaloso> even their elites didn't know how to build
16:57:25 <Resbaloso> lol
16:57:25 --- mode: ChanServ set +o glguy
16:57:28 --- mode: ChanServ set +o mauke
16:57:28 --- kick: Resbaloso was kicked by mauke (Resbaloso)
16:57:29 <brooksbp> If we have an application (e1 e2) where e1 has a universal function type \forall t.t->t ... does this mean we can infer (e1 e2) ==> e2?
16:58:02 --- mode: glguy set +b *!*@64.134.232.41
16:58:06 --- mode: glguy set -o glguy
16:58:35 <mauke> @free e1 :: t -> t
16:58:35 <lambdabot> f . e1 = e1 . f
16:58:54 <fax> @freee eeee :: eee -> ee -> (ee,eee)
16:58:54 <lambdabot> $map_Pair g f . eeee x = eeee (f x) . g
16:59:28 --- mode: mauke set -o mauke
17:00:44 <LegendaryPenguin> was Resbaloso a bot? lol
17:00:58 <glguy> This isn't the right channel to discuss trolls
17:00:58 <mauke> probably not
17:01:08 <sykopomp> LegendaryPenguin: no
17:04:02 <mauke> he's been k-lined
17:04:59 <tensorpudding> What does the K in K-lined mean?
17:05:14 <sykopomp> tensorpudding: continuation, obviously.
17:06:30 <mauke> kill
17:06:42 <tensorpudding> kill-lined?
17:06:53 <mauke> yep
17:07:00 <FunctorSalad> like emacs kill where you've only gone to the kill-ring? or REAL kill? :O
17:07:11 <benmachine> what about the G in G-lined
17:07:15 <mauke> global
17:07:19 <benmachine> oh
17:07:25 <benmachine> that is not at all logical
17:07:32 <benmachine> well it kind of is
17:07:38 <tensorpudding> kill only sends signals, it doesn't do any slaughtering
17:07:58 <FunctorSalad> eh? what about number 9?
17:08:08 <FunctorSalad> the process doesn't get any say afaik
17:08:24 <tensorpudding> It writes the process in its Death Note, so to speak.
17:08:43 <djahandarie> ... lol tensorpudding
17:10:29 <benmachine> isn't the only function of type t -> t id?
17:10:48 <mauke> :t [id, undefined, const undefined]
17:10:49 <lambdabot> forall a. [a -> a]
17:10:58 <benmachine> mmph.
17:11:11 <benmachine> :t fmap fix return
17:11:12 <lambdabot> forall a. a -> a
17:11:35 <benmachine> is there actually any different between undefined :: a -> a and const undefined :: a -> a?
17:11:43 <FunctorSalad> hehe good question
17:11:44 <benmachine> keeping in mind that as we all know, seq doesn't exist
17:11:56 <FunctorSalad> in domain theory as I saw it, there should be none
17:12:05 <benmachine> *difference
17:12:10 <FunctorSalad> but in haskell you can't have it because there's no eval under lambdas, I think
17:12:34 <FunctorSalad> > (\x -> undefined) `seq` "ok"
17:12:34 <lambdabot>   "ok"
17:12:36 <sbahra> So, who was the go-to guy again for Haskell mailing lists? I need to add a moderator to one of the lists, and I forget my credentials.
17:12:40 <brooksbp> If we have an application (e1 e2) where e1 has a universal function type \forall t.t->t ... does this mean we can infer (e1 e2) ==> e2?
17:12:43 <FunctorSalad> > (undefined :: Int -> Int) `seq` "ok"
17:12:44 <lambdabot>   "*Exception: Prelude.undefined
17:13:32 <benmachine> seq should just not work on functions
17:13:42 <kmc> benmachine, why not?
17:13:44 <benmachine> then it'd be much less magic
17:13:56 <benmachine> and rule-breaking
17:14:12 <benmachine> ...so I believe anyway, maybe I'm misinformed
17:14:19 <FunctorSalad> the *easy* definition of less-defined-than for functions is pointwise
17:14:26 <FunctorSalad> then undefined and const undefined are indeed the same
17:14:45 <aavogt> @type ?f >=> return . return
17:14:46 <lambdabot> forall a (m :: * -> *) b (m1 :: * -> *). (?f::a -> m b, Monad m, Monad m1) => a -> m (m1 b)
17:14:46 <kmc> it's true that there is no way to write seq for a function type yourself without a similar magic primitive
17:14:50 <FunctorSalad> I read it all gets messier if you don't have the pointwise less-than, but I don't know the details
17:14:52 <kmc> whereas you can write it for an algebraic type
17:15:13 <benmachine> kmc: how often do you actually want to seq a function anyways
17:15:33 <kmc> benmachine, seems reasonable to me
17:15:46 <FunctorSalad> benmachine: I think the argument in the early days was about sneaking in seqs in polymorphic functions
17:15:53 <kmc> you have some large calculation that's lifted out of the lambda body
17:16:01 <FunctorSalad> you'd suddenly need a NFData constraint everywhere
17:16:15 <kmc> and you want to force this calculation to happen now rather than later
17:16:22 <FunctorSalad> (was that the exact argument? something along these lines I think)
17:16:40 <FunctorSalad> I think someone here linked to the thread I mean ;)
17:17:18 <benmachine> FunctorSalad: I was told that back when seq needed a typeclass, refactoring took a lot of effort
17:17:22 <benmachine> or, something
17:18:38 <FunctorSalad> benmachine: there is this "moral equivalence", you probably read it I guess... it restores most of the lost sanity to equations in haskell
17:18:57 <FunctorSalad> but I have no idea to how much of the language it can be extended
17:19:25 <FunctorSalad> ("sanity" like fst . ( f &&& g ) === f )
17:19:32 <benmachine> heh
17:21:03 <aavogt> isn't that specific case covered by one of the many arrow laws, FunctorSalad?
17:22:51 <FunctorSalad> aavogt: AIUI, most of the laws are actually broken if you distinguish seq-distinguishable laws... (is this one an arrow law?)
17:23:03 <FunctorSalad> the second "laws" should be "values"
17:24:10 <dolio> FunctorSalad: I'm pretty sure that was the argument. Adding the equivalent of a bang pattern could modify type signatures all over your program.
17:24:33 <FunctorSalad> mhm
17:24:54 <dolio> Although, even when seq was in a class, it was still magic, and worked on functions.
17:24:55 <aavogt> as a typeclass without user-defined instances?
17:25:00 <dolio> Which is weird.
17:27:50 <FunctorSalad> does it ever do anything for functions?
17:28:00 <FunctorSalad> except tell apart undef vs. anything else
17:28:08 <dolio> It evaluates them somehow.
17:28:20 <dolio> To whnf.
17:29:12 <aavogt> aww, the ghc-api doesn't let you set qualified imports without going through a file
17:29:28 <kmc> e.g. i might write «let x = big calculation in x `seq` (\y -> ...)»
17:29:42 <kmc> and then seq on that value would force the big calculation
17:29:52 <kmc> and give you back a function which is closed over the already-computed value of x
17:30:01 <dolio> If it were lambda terms, that'd mean it'd reduce things until it saw a \x -> ..., or some under-applied primitive function.
17:30:15 <dolio> But what it actually does probably has to do with how GHC actually represents functions.
17:30:41 <kmc> operationally, seq will just enter the closure with a catch-all continuation, i think
17:30:53 * hackagebot lscabal 0.1.1 - List exported modules from a set of .cabal files  http://hackage.haskell.org/package/lscabal-0.1.1 (DonaldStewart)
17:30:53 <kmc> seq x y = case x of _ -> y,  using Core's case
17:30:58 <kmc> which always forces
17:31:11 <kmc> (i think)
17:31:17 <dolio> Yeah.
17:31:19 <FunctorSalad> dolio: oh... so not every non-bottom function is whnf?
17:31:29 <FunctorSalad> hmm ok, HOFs need to be applied
17:31:40 <kmc> FunctorSalad, there are expressions of function type which are not bottom and not whnf
17:31:47 <FunctorSalad> yeah
17:31:49 <kmc> a "function" might be defined to be "a value of function type"
17:31:52 <dolio> I mean, if you consider (+) built-in, then (+) 1 is whnf.
17:31:54 <FunctorSalad> I was thinking about function values
17:32:00 <FunctorSalad> I think there it'd be kinda true ;)
17:32:10 <FunctorSalad> if only lambdas are ground values
17:32:11 <dolio> And so is (\x -> (\y -> y) x)
17:32:42 <dolio> I think (+) ((\x -> x) 1) is also whnf.
17:33:01 <kmc> ((\x y -> x + y) 3) is an expression of function type which is not in whnf
17:33:11 <FunctorSalad> whnf for functions = lambda on toplevel, I understand
17:33:30 <FunctorSalad> unless as you say, (+) is primitive
17:34:08 <FunctorSalad> kmc: sure or map blah and so on
17:34:12 <FunctorSalad> (map blah)
17:38:07 <orlandu63> is there any way to get the value of a system call?
17:38:14 <orlandu63> System.Cmd seems to return the exitcode
17:38:39 <mauke> why do you need it?
17:38:39 <orlandu63> rawSystem*
17:38:40 <FunctorSalad> that just does shell calls
17:38:55 <FunctorSalad> err or execsomething
17:39:08 <FunctorSalad> but don't you need the ffi to do system calls directly?
17:39:16 <kmc> orlandu63, look at the System.Process module
17:39:49 <FunctorSalad> if you just mean the stdout and stderr of the process, look at readProcessWithExitCode
17:39:53 <kmc> but i am also confused
17:39:58 <kmc> what you mean by "system call"
17:40:44 <orlandu63> i think i meant shell calls.
17:40:51 <orlandu63> i'm not too familiar with the proper terminilogy
17:41:02 <mauke> what do you mean by "value"?
17:41:23 <kmc> orlandu63, you want to execute an external command?
17:41:24 <orlandu63> well, `ls` prints the directory listing
17:41:29 <orlandu63> the directory listing is the value
17:41:32 <kmc> so you want to read the command's standard output
17:41:33 <mauke> no, it isn't
17:41:41 <mauke> it's what ls wrote to its stdout
17:41:42 <kmc> "the value" is not a term that would be commonly used here
17:41:44 <copumpkin> the value is typically 0
17:41:54 <copumpkin> unless something went wrong
17:41:57 <benmachine> copumpkin: is that a general philosophical statement
17:42:01 <copumpkin> yep
17:42:12 <orlandu63> ah yes stdout
17:42:14 <orlandu63> that's what i meant
17:42:19 <kmc> orlandu63, the simple interface to what you want is System.Process.readProcess
17:42:32 <FunctorSalad> orlandu63: readProcess then
17:42:44 <FunctorSalad> or readProcessWithExitCode if you want the 'err too
17:43:07 <kmc> the flexible interface is to build a record of type CreateProcess and pass it to createProcess
17:43:32 <FunctorSalad> benmachine: it's bash's bizarro co-world ;)
17:43:39 <orlandu63> thank you
17:43:43 <FunctorSalad> (I know you know already that 0 is true in bash)
17:44:11 <benmachine> you know a lot about what I know it seems
17:44:29 <benmachine> have you been going through my mail :O
17:45:10 <FunctorSalad> nvm then... that statement didn't have any deep meaning ;)
17:45:26 <kbp> hi I need some helps. I have two variables x,y both type Int. If I do x/y, what type is its result? (I'm expecting Int)
17:45:32 <FunctorSalad> just guarding myself against accusation of taking things to literally
17:45:33 <kmc> kbp, you can't
17:45:33 <FunctorSalad> or so
17:45:40 <kmc> because (/) is only defined on fractional types
17:45:41 <kmc> :t (/)
17:45:42 <lambdabot> forall a. (Fractional a) => a -> a -> a
17:45:43 <benmachine> heh ok
17:45:50 <kmc> kbp, Haskell has no implicit numerical conversion e.g. from Int to Double
17:45:58 <mauke> kbp: it is Int, but it will only typecheck if you add an instance Fractional Int
17:46:00 <kmc> kbp, you can find out types of things for yourself
17:46:11 <kmc> in ghc
17:46:13 <kmc> ghci*
17:46:15 <kbp> so is there away to convert its result to Int ?
17:46:17 <kmc> kbp, what do you *want* it to do?
17:46:32 <kmc> kbp, there *is* no result, it's a type error.  unless you did what mauke said which is probably not correct for your situation
17:46:34 <benmachine> kbp: what sould (1 :: Int) / 2 be?
17:46:46 <kmc> kbp, if you want it to truncate to an Int, use quot or div
17:46:49 <kmc> > 5 `div` 2
17:46:50 <lambdabot>   2
17:46:51 <kmc> > 5 `quot` 2
17:46:52 <lambdabot>   2
17:47:09 <kmc> :t div
17:47:10 <lambdabot> forall a. (Integral a) => a -> a -> a
17:47:13 <kbp> oh I see. `div` is what I'm looking for. thank you guys :D
17:47:18 <kmc> Int is a member of the type class Integral but not of Fractional
17:47:19 <kmc> :)
17:47:36 <benmachine> keep in mind you can't use `div` on doubles!
17:47:38 <kbp> `div` is built in right? i dont need to import Math or something..
17:47:39 <kbp> ?
17:47:46 <kmc> it's in the Prelude
17:47:52 <FunctorSalad> kbp: fromIntegral and real2frac are the allround ones
17:48:00 <FunctorSalad> @type realToFrac
17:48:01 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
17:48:02 <FunctorSalad> or that
17:48:04 * benmachine just inadvertantly whipped himself with his power cord :(
17:48:07 <orlandu63> :t quot
17:48:08 <lambdabot> forall a. (Integral a) => a -> a -> a
17:48:14 <orlandu63> what's the difference?
17:48:15 <benmachine> realToFrac
17:48:15 <kmc> > (-5) `div` 2
17:48:16 <lambdabot>   -3
17:48:17 <kmc> > (-5) `quot` 2
17:48:18 <lambdabot>   -2
17:48:21 <benmachine> orlandu63: they are extremely similar
17:48:45 <Cale> div and mod are the ones you usually want
17:48:55 <orlandu63> so it seems that div rounds down when working with a negative quotient?
17:49:16 <Cale> Yeah
17:49:17 <Saizan> yeah, div rounds to -infinity while quot rounds to 0
17:49:49 <orlandu63> interesting
17:50:25 <FunctorSalad> div and mod are the Mathematically Correct ones ;o
17:50:26 <benmachine> (-5) `rem` 2
17:50:31 <benmachine> > (-5) `rem` 2
17:50:32 <lambdabot>   -1
17:50:42 <benmachine> > 5 `rem` (-2)
17:50:43 <lambdabot>   1
17:50:48 <benmachine> > (-5) `mod` 2
17:50:49 <FunctorSalad> (normalizing to coherent representatives)
17:50:50 <lambdabot>   1
17:50:54 <FunctorSalad> or however you want to say it
17:50:59 <benmachine> > 5 `mod` (-2)
17:51:00 <lambdabot>   -1
17:51:11 <FunctorSalad> though consistently choosing negative reps is fine too
17:51:15 <copumpkin> :o
17:51:52 <benmachine> @check (==) <*> uncurry (+) . divMod
17:51:53 <lambdabot>   Couldn't match expected type `(a, a)'
17:51:59 * benmachine hmms
17:52:09 <Mathnerd314> > 3.14 `mod` 2
17:52:10 <lambdabot>   Ambiguous type variable `t' in the constraints:
17:52:10 <lambdabot>    `GHC.Real.Fractional t'
17:52:10 <lambdabot> ...
17:52:21 <Cale> @check \n m -> (n `div` m) * m + (n `mod` m) == n
17:52:22 <lambdabot>   "*Exception: divide by zero
17:52:30 <Cale> @check \n m -> m == 0 || (n `div` m) * m + (n `mod` m) == n
17:52:31 <lambdabot>   "OK, passed 500 tests."
17:52:36 <benmachine> oh yeah, I keep forgeting the * m
17:52:39 <Cale> @check \n m -> m == 0 || (n `quot` m) * m + (n `rem` m) == n
17:52:40 <lambdabot>   "OK, passed 500 tests."
17:52:51 <FunctorSalad> Cale: I'd hope quotRem gets that law right at least :)
17:52:59 <h-cell> Does lambdabot support System.Random?
17:53:17 <benmachine> > mkStdGen 1
17:53:18 <Cale> Both pairs of functions satisfy that same law
17:53:18 <lambdabot>   2 1
17:53:22 <benmachine> seems so
17:53:25 <FunctorSalad> I meant the choosing a system of reps for the modulo relation yadda yadda
17:53:31 <benmachine> but obviously not getStdGen or newStdGen
17:54:07 <FunctorSalad> so x and y are equivalent iff x `mod` n == y `mod` n, but not with rem
17:54:43 <aavogt> you can also use @check to get (small) random values
17:54:57 <benmachine> what like
17:55:06 <benmachine> @check length (xs :: [Int]) < 5
17:55:07 <lambdabot>   Not in scope: `xs'
17:55:09 <aavogt> @check \(x::Double) -> error (show x)
17:55:09 <lambdabot>   Parse error in pattern at "->" (column 14)
17:55:13 <benmachine> @check \xs -> length (xs :: [Int]) < 5
17:55:14 <FunctorSalad> benmachine: the quickCheck invoker does the IO
17:55:14 <lambdabot>   "Falsifiable, after 17 tests:\n[-7,8,-1,7,4,1,-7]\n"
17:55:19 <FunctorSalad> not the checkee
17:55:26 <benmachine> those numbers look pretty random to me!
17:55:27 <aavogt> @check \x -> error (show x) `const` (x :: Double)
17:55:27 <lambdabot>   Add a type signature
17:55:39 <aavogt> @check \x -> error (show x) `const` (x `asTypeOf` (undefined :: Double))
17:55:40 <lambdabot>   Add a type signature
17:55:45 <aavogt> @check \x -> error (show x) `const` (x `asTypeOf` (undefined :: Double)) :: ()
17:55:46 <lambdabot>   "Arguments exhausted after 0 tests."
17:56:01 <benmachine> that's off
17:56:03 <benmachine> odd
17:56:09 <benmachine> @check error :: Int -> Bool
17:56:09 <aavogt> oh, it doesn't print that counterexample
17:56:10 <lambdabot>   Couldn't match expected type `GHC.Types.Int -> GHC.Bool.Bool'
17:56:19 <benmachine> @check error :: String -> Bool
17:56:20 <lambdabot>   Couldn't match expected type `GHC.Base.String -> GHC.Bool.Bool'
17:56:21 <aavogt> @check \x -> error (show x) `const` (x `asTypeOf` (undefined :: Double)) :: Bool
17:56:22 <lambdabot>   "*Exception: 0.0
17:56:25 * benmachine confuses self
17:56:35 <aavogt> @check \x -> error (show x) `const` (x `asTypeOf` (undefined :: Double)) :: Bool
17:56:35 <lambdabot>   "*Exception: -1.5
17:56:48 <benmachine> @check ()
17:56:48 <lambdabot>   "Arguments exhausted after 0 tests."
17:56:57 <FunctorSalad> hmm? it should do Int -> Bool
17:57:12 <benmachine> @check error "flirb" :: Bool
17:57:12 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
17:57:17 <benmachine> @check error "flirb" :: Int -> Bool
17:57:18 <lambdabot>   Couldn't match expected type `GHC.Types.Int -> GHC.Bool.Bool'
17:57:20 <aavogt> @check (error :: Int -> Bool)
17:57:20 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
17:57:23 * benmachine shrugs
17:57:26 <FunctorSalad> @check (\x -> collect (x ::Int) True)
17:57:26 <lambdabot>   No instance for (Test.QuickCheck.Testable
17:57:27 <lambdabot>                     (Test.QuickCh...
17:57:33 <FunctorSalad> @type collect
17:57:33 <benmachine> remember error :: String -> a
17:57:34 <lambdabot> forall a prop. (Show a, Testable prop) => a -> prop -> Property
17:57:40 <Saizan> @check (error "flirb" :: Bool)
17:57:41 <lambdabot>   "*Exception: flirb
17:57:45 <Gracenotes> @check \a b c d -> True || a || b || c || d
17:57:45 <FunctorSalad> @type label
17:57:46 <lambdabot>   "OK, passed 500 tests."
17:57:47 <lambdabot> forall prop. (Testable prop) => String -> prop -> Property
17:57:53 <Saizan> @check (error . show :: Int -> Bool)
17:57:54 <lambdabot>   "*Exception: 0
17:58:01 <FunctorSalad> @check (\x -> label "oh hai" True)
17:58:01 <lambdabot>   No instance for (Test.QuickCheck.Testable
17:58:01 <lambdabot>                     (Test.QuickCh...
17:58:05 <FunctorSalad> :(
17:58:10 <Gracenotes> why would it pass 500 tests when there are only 16 combinations of arguments?
17:58:15 <FunctorSalad> is this mueval being paranoid?
17:58:19 <FunctorSalad> the types look ok
17:58:19 <benmachine> Gracenotes: just a standard number
17:58:21 <benmachine> notice:
17:58:26 <benmachine> @check \x -> x < 1000
17:58:27 <lambdabot>   "OK, passed 500 tests."
17:58:27 <h-cell> Wierd Rounding Problems With randomRIO: randomRIO (0,9) >>= return . (*(0.1)) should give a number like 0.0, 0.1,...,0.9 but I get numbers like 0.3671343... and 0.659644... how is this possible?
17:58:27 <FunctorSalad> @check (\x -> label "oh hai" (property True))
17:58:28 <lambdabot>   No instance for (Test.QuickCheck.Testable
17:58:28 <lambdabot>                     (Test.QuickCh...
17:58:33 <FunctorSalad> @ty property
17:58:34 <lambdabot> forall prop. (Testable prop) => prop -> Property
17:58:37 <Gracenotes> benmachine: so that's not what the "arguments exhausted" message means above?
17:58:41 <FunctorSalad> uh but Bool is Yestable
17:58:44 <FunctorSalad> uh but Bool is Testable
17:58:45 <benmachine> Gracenotes: I don't know what that means
17:59:00 <Saizan> FunctorSalad: you're ignoring the 'x'
17:59:14 <benmachine> h-cell: okay there are a few things to explain there
17:59:18 <FunctorSalad> @check (\x -> label "oh hai" (x==x))
17:59:18 <lambdabot>   No instance for (Test.QuickCheck.Testable
17:59:19 <lambdabot>                     (Test.QuickCh...
17:59:27 <Gracenotes> benmachine: I guess it makes no attempt to prevent duplicates. speaking in term of pigeonholes, 16 possible argument combinations and 500 tests...
17:59:27 <FunctorSalad> @check (\x -> label "oh hai" (x=='c'))
17:59:28 <lambdabot>   No instance for (Test.QuickCheck.Testable
17:59:28 <lambdabot>                     (Test.QuickCh...
17:59:40 <FunctorSalad> Saizan: right that would have ununiqued it, but still no luck
17:59:55 <benmachine> h-cell: first of all, you're trying to get Ints and multiply them by Doubles, that doesn't work without converting between the two
18:00:01 <benmachine> h-cell: look:
18:00:03 <benmachine> :t (*)
18:00:04 <lambdabot> forall a. (Num a) => a -> a -> a
18:00:17 <benmachine> h-cell: both arguments and the result have to be the same type
18:00:44 <benmachine> h-cell: however, the reason why your thing doesn't give a type error is that randomRIO isn't actually producing integral values like you expect
18:00:58 <benmachine> :t randomRIO
18:00:59 <lambdabot> forall a. (Random a) => (a, a) -> IO a
18:01:15 <aavogt> @type label
18:01:16 <lambdabot> forall prop. (Testable prop) => String -> prop -> Property
18:01:48 <benmachine> randomRIO is quite capable of producing floating-point values, which is what you're seeing there
18:01:56 <FunctorSalad> aavogt: with the premium version ;) that should give you statistics about the labels in the end
18:04:03 <FunctorSalad> works just fine in my ghci
18:06:45 <h-cell> benmachine: thanks for your explaination. haskell is such an interesting language!
18:08:11 <benmachine> h-cell: by the way, a neat way of writing (x >>= return . f) is (liftM f x) or (fmap f x)
18:08:17 <benmachine> liftM is in Control.Monad
18:08:21 <benmachine> that's not important, it's just nice to know
18:08:41 <FunctorSalad> or (f<$>x)
18:09:14 <h-cell> benmachine: randomRIO (0,9) >>= return . (*0.1) . fromIntegral
18:09:48 <benmachine> h-cell: that's pretty good yeah
18:10:05 <benmachine> h-cell: well, actually I would use fromInteger in that case
18:10:55 <benmachine> hmm no I don't think I would
18:10:57 <benmachine> I'd use
18:11:12 <benmachine> oh never mind me
18:11:19 <benmachine> I could really use some sleep
18:11:31 <FunctorSalad> but sadly there's no foo g f x = (return . g) <=< f
18:11:32 <FunctorSalad> ;)
18:11:45 <FunctorSalad> drop the x
18:12:09 <benmachine> :t \g f -> return . g <=< f
18:12:10 <lambdabot> forall a (m :: * -> *) b a1. (Monad m) => (b -> a) -> (a1 -> m b) -> a1 -> m a
18:12:29 <FunctorSalad> I run into it rather often
18:12:29 <benmachine> hmm
18:12:49 <benmachine> :t ((fmap .) Prelude..)
18:12:50 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *) a1. (Functor f, Functor f1) => (a1 -> f1 (a -> b)) -> a1 -> f1 (f a -> f b)
18:12:59 <benmachine> ok I got that wrong
18:13:07 <Mathnerd314> @pl \g f -> return . g <=< f
18:13:07 <lambdabot> (line 1, column 20):
18:13:08 <lambdabot> unexpected "=" or "<"
18:13:08 <lambdabot> expecting variable, "(", ".", space, operator or end of input
18:13:08 <lambdabot> ambiguous use of a left associative operator
18:13:22 <benmachine> weird
18:13:40 <Mathnerd314> @pl \g f -> (return . g) <=< f
18:13:40 <lambdabot> (<=<) . (return .)
18:13:55 <Mathnerd314> @type (<=<) . (return .)
18:13:56 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> c) -> (a -> m b) -> a -> m c
18:14:00 <benmachine> it looks like a nested fmap to me
18:14:25 <FunctorSalad> @type \x -> liftM ?g (?f x)
18:14:26 <lambdabot> forall a1 r t (m :: * -> *). (?g::a1 -> r, ?f::t -> m a1, Monad m) => t -> m r
18:14:33 <FunctorSalad> if you prefer
18:14:47 <Mathnerd314> fmap fmap fmap `asTypeOf` \g f -> return . g <=< f
18:14:51 <Mathnerd314> > fmap fmap fmap `asTypeOf` \g f -> return . g <=< f
18:14:52 <lambdabot>   No instances for (Test.SmallCheck.Serial (f a),
18:14:52 <lambdabot>                    GHC.Show...
18:14:54 <FunctorSalad> hehehe
18:15:13 <benmachine> :t fmap fmap fmap `asTypeOf` \g f -> return . g <=< f
18:15:14 <lambdabot> forall a b (f :: * -> *) a1. (Functor f, Monad f) => (a -> b) -> (a1 -> f a) -> a1 -> f b
18:16:01 <Mathnerd314> so it *is* fmap fmap fmap?
18:16:07 <benmachine> seems so
18:16:14 <dabblego> instance Functor (Kleisli m)
18:16:19 <Mathnerd314> yay for intuition :-)
18:16:20 <benmachine> or if you're being pedantic, liftM liftM liftM
18:16:38 <kmc> doesn't (Kleisli m) have the wrong kind?
18:16:51 <dabblego> instance Functor (Kleisli m a)
18:16:53 <benmachine> newtype Kleisli m a b
18:17:22 <FunctorSalad> not bad Mathnerd314 :)
18:17:37 <ido> :t (<*>)
18:17:38 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
18:17:45 <ido> :i (<*>)
18:17:48 <FunctorSalad> and an excuse for writing fmap fmap fmap in serious code
18:18:15 <Mathnerd314> hmm...
18:18:20 <Mathnerd314> :t fmap . fmap
18:18:21 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
18:18:36 <Mathnerd314> :t fmap . (.)
18:18:37 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
18:18:45 <Mathnerd314> :t (.).(.)
18:18:46 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
18:18:46 <monochrom> whee view pattern
18:19:01 <aavogt> :t let (.) = (Prelude..) in ((fmap .) .)
18:19:02 <lambdabot> forall a b (f :: * -> *) a1 a2. (Functor f) => (a2 -> a1 -> a -> b) -> a2 -> a1 -> f a -> f b
18:19:09 <benmachine> put a lambda in the lhs
18:19:20 <aavogt> :t let (.) = (Prelude..) in ((. fmap) .)
18:19:21 <lambdabot> forall c a b (f :: * -> *) a1. (Functor f) => (a1 -> (f a -> f b) -> c) -> a1 -> (a -> b) -> c
18:19:37 <aavogt> :t let (.) = (Prelude..) in ((. `fmap`) .)
18:19:38 <lambdabot> parse error on input ``'
18:19:38 <benmachine> :t let (\x -> case x of x -> x -> x) = 0 in x
18:19:39 <lambdabot>     Illegal view pattern:  (\ x -> case x of { x -> x } -> x)
18:19:40 <lambdabot>     Use -XViewPatterns to enable view patterns
18:19:42 <benmachine> :(
18:19:53 <FunctorSalad> dabblego: CoFunctor in the left arg, akshully
18:19:53 <benmachine> ooh
18:19:57 <benmachine> :t let (\x -> case x of x -> x-> x -> x) = 0 in x
18:19:58 <lambdabot> parse error on input `->'
18:20:04 <benmachine> :t let (\x -> case x of (x -> x) -> x -> x) = 0 in x
18:20:04 <lambdabot>     Illegal view pattern:  (\ x -> case x of { ((x -> x)) -> x } -> x)
18:20:05 <lambdabot>     Use -XViewPatterns to enable view patterns
18:20:05 <lambdabot>     Illegal view pattern:  (x -> x)
18:20:06 <aavogt> benmachine: they are allowed with @run
18:20:13 <benmachine> > let (\x -> case x of (x -> x) -> x -> x) = 0 in x
18:20:14 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
18:20:18 <djahandarie> -_-
18:20:19 <benmachine> hmmm
18:20:32 <FunctorSalad> (sorry, beginning to turn into a lolcat)
18:20:35 <dabblego> FunctorSalad, instance Cofunctor (flip (Kleisli m b))
18:20:37 <benmachine> > let (\x -> case x of (\x -> x -> x) -> x -> x) = 0 in x
18:20:38 <lambdabot>   0
18:20:42 <benmachine> best view pattern evar
18:20:49 <monochrom> haha
18:21:00 <FunctorSalad> omg
18:21:42 <Mathnerd314> what are view patterns, exactly?
18:21:56 <benmachine> they allow you to apply a function to a value before pattern matching on it
18:21:57 <FunctorSalad> preprocess an arg without giving a name to the unprocessed arg
18:22:07 <monochrom> @remember benmachine let (\x -> case x of (\x -> x -> x) -> x -> x) = 0 in x / best view pattern evar
18:22:07 <lambdabot> I will remember.
18:22:25 <benmachine> > case [1,2,3] of (drop 3 -> []) -> True
18:22:26 <lambdabot>   True
18:22:37 <benmachine> > case [1,2,3] of (drop 2 -> xs) -> xs
18:22:38 <lambdabot>   [3]
18:23:00 <monochrom> view patterns: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#view-patterns
18:23:28 <Mathnerd314> ah.
18:23:40 <FunctorSalad> @let f x = case x of { \(length -> 0) -> "empty"; otherwise -> False; }
18:23:40 <lambdabot>   ViewPatterns is not enabled
18:23:47 <FunctorSalad> worst 'null' impl ever
18:24:09 <aavogt> > let f p (stripPrefix p -> Just x) ((\\ x) -> y) = y in f "lol" "lol cat" "category"
18:24:10 <lambdabot>   "egory"
18:24:55 <FunctorSalad> what's that double backslash?
18:24:59 <aavogt> delete
18:25:15 <FunctorSalad> :o
18:25:25 <aavogt> or I suppose you could look at it as subtracting lists
18:25:33 <aavogt> > "hello" \\ "le"
18:25:34 <lambdabot>   "hlo"
18:25:44 <hpaste>  Helo World in Hack Webapp Framework (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24918
18:25:45 <FunctorSalad> didn't even consider it could be an identifier
18:26:04 <FunctorSalad> (but yeah, I've seen it in Set)
18:27:07 <aavogt> @src (\\)
18:27:07 <lambdabot> (\\) = foldl (flip delete)
18:27:15 <ido> @src (<*>)
18:27:16 <lambdabot> Source not found. You untyped fool!
18:27:31 <aavogt> FunctorSalad: for lists it's horribly inefficient
18:27:48 <FunctorSalad> yeah. why do we even give ppl ideas? ;)
18:28:13 <aavogt> almost to the point that it shouldn't be included, like how there isn't an updateAtIndex
18:28:17 <FunctorSalad> it puzzles me why emacs uses alists so liberally, too
18:28:25 <FunctorSalad> when it has perfectly fine hashtables...
18:28:29 <aavogt> or insert if you want to call it
18:28:37 <aavogt> that
18:28:40 <FunctorSalad> (do they get autooptimized to hashes or sth?)
18:29:12 <bremner> FunctorSalad: alists are older than hashtables, I suppose
18:30:17 <aavogt> > let (\) = flip (/) in 2 \ 1
18:30:18 <lambdabot>   <no location info>: parse error on input `)'
18:30:35 <aavogt> > let ( \ ) = flip (/) in 2 \ 1
18:30:36 <lambdabot>   <no location info>: parse error on input `)'
18:31:22 <hpc> \ is lambda
18:31:50 <aavogt> but if there isn't a matching ->...
18:32:08 <hpc> apparently that's a syntax error
18:32:38 <FunctorSalad> it's a special token only when not followed by an operator character
18:32:47 <FunctorSalad> that makes the word just an operator token
18:33:45 <ddarius> aavogt: That would require quite a bit of look ahead.
18:34:18 <FunctorSalad> @let (\/) = (||)
18:34:19 <lambdabot>  Defined.
18:34:43 <mail> @let
18:34:44 <lambdabot>  Defined.
18:35:05 <mail> @
18:35:21 <aavogt> @let import Data.List
18:35:21 <lambdabot>  Invalid declaration
18:37:32 <LegendaryPenguin> is there an elegant way of doing takes and drops on an int? like i might want the first x digits of a number, or the last x digits.  Currently converting it to string and doing takes/drops and converting back
18:38:05 <LegendaryPenguin> or maybe i should be using divs and mods..
18:38:17 <ddarius> What is the type of your "take/drop"?
18:38:37 <ddarius> (and, mostly likely, yes, you should be using div and mod.)
18:38:51 <aavogt> ddarius: yeah, and it's probably not a good idea considering the type errors you might end up with from some misplaced ->
18:41:17 <dons> LegendaryPenguin: well, there's the Bit class, Data.Bit
18:41:33 <dons> which has everything you'd need to define a take/drop (treat words as sequences of Bool)
18:42:50 <FunctorSalad> LegendaryPenguin: "last x" is (`mod` (10^x))
18:43:12 <FunctorSalad> "first x" is some div
18:44:00 <Mathnerd314> is http://code.haskell.org/lambdabot/State/ the actual state of lambdabot?
18:44:13 <dons> its a snapshot
18:44:23 <LegendaryPenguin> x div 10^(n-x) or something
18:44:39 <Mathnerd314> dons: so where's the actual stuff?
18:44:54 <FunctorSalad> yeah and n the somehow-rounded (off by one errors lurking) log_10 ;)
18:44:57 <LegendaryPenguin> er length o x
18:46:04 <FunctorSalad> sure if you want binary digits, use shifts and masks
18:46:25 <FunctorSalad> no idea if bit manipulation is worth it for decimal
18:46:33 <LegendaryPenguin> is there a log 10 there
18:46:56 <Saizan> > log 100 / log 10
18:46:57 <lambdabot>   2.0
18:47:06 <FunctorSalad> you could just do repeated divs instead of using doubles
18:47:47 <dons> Mathnerd314: http://hackage.haskell.org/packages/archive/base/4.2.0.0/doc/html/Data-Bits.html
18:48:04 <ddarius> :t logBase
18:48:05 <lambdabot> forall a. (Floating a) => a -> a -> a
18:48:19 <Mathnerd314> dons: I mean the actual current state of lambdabot
18:48:22 <ddarius> Anyway, for that operation, just use logBase 10 and then check the result, fixing it if necessaryi.
18:48:38 <ddarius> Mathnerd314: It's on the actual machine holding the actual running lambdabot.
18:48:56 <Mathnerd314> is that on the net somewhere?
18:49:40 <Saizan> i don't think so
18:49:41 <FunctorSalad> @let l = snd . head . filter ((==0).fst) . iterate (\(y,i) -> (y `div` 10, i + 1))
18:49:41 <lambdabot>  Defined.
18:49:45 <FunctorSalad> > l 12345
18:49:45 <lambdabot>   Ambiguous occurrence `l'
18:49:46 <lambdabot>  It could refer to either `L.l', defined at <local...
18:49:56 <FunctorSalad> @let l__ = snd . head . filter ((==0).fst) . iterate (\(y,i) -> (y `div` 10, i + 1))
18:49:57 <lambdabot>  Defined.
18:50:01 <FunctorSalad> > l__ 12345
18:50:01 <lambdabot>   No instance for (GHC.Num.Num (a, b))
18:50:02 <lambdabot>    arising from the literal `12345' at...
18:50:15 <FunctorSalad> @let l__ x = snd . head . filter ((==0).fst) . iterate (\(y,i) -> (y `div` 10, i + 1)) $ (x,0)
18:50:15 <lambdabot>  <local>:14:0:
18:50:16 <lambdabot>      Multiple declarations of `L.l__'
18:50:16 <lambdabot>      Declared at: <local...
18:50:27 <FunctorSalad> @let leng x = snd . head . filter ((==0).fst) . iterate (\(y,i) -> (y `div` 10, i + 1)) $ (x,0)
18:50:28 <lambdabot>  Defined.
18:50:33 <FunctorSalad> > leng 12345
18:50:34 <lambdabot>   5
18:50:38 <FunctorSalad> yay....
18:50:56 <FunctorSalad> avoiding off-by-one was pure luck there
18:51:05 <FunctorSalad> :)
18:53:43 <FunctorSalad> @unlet leng
18:53:43 <lambdabot>   Parse error: SemiColon
18:53:46 <FunctorSalad> @unlet
18:53:47 <lambdabot>  Defined.
18:54:05 <FunctorSalad> @let leng x = snd . head . filter ((==0).fst) . iterate ((`div` 10) *** succ) $ (x,0)
18:54:05 <Mathnerd314> @undefine
18:54:06 <lambdabot>  <local>:14:0:
18:54:06 <lambdabot>      Warning: Pattern match(es) are overlapped
18:54:06 <lambdabot>               I...
18:54:07 <LegendaryPenguin> firstNDig n x = (x `div` 10^(length (show x) - n)) , does that look funny
18:54:18 <FunctorSalad> nooo
18:54:23 <FunctorSalad> @let lengt x = snd . head . filter ((==0).fst) . iterate ((`div` 10) *** succ) $ (x,0)
18:54:24 <lambdabot>  Defined.
18:54:30 <FunctorSalad> ah. unlet was ineffective
18:54:42 <Mathnerd314> yeah - @undefine
18:55:02 <LegendaryPenguin> when i call the function, it says 0, but when i substitute in the values, it gives the right answer
18:55:08 <LegendaryPenguin> weird
18:55:28 <LegendaryPenguin> when i use 1 and 5000
18:56:03 <benmachine> @help unlet
18:56:04 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:56:12 <benmachine> @unlet
18:56:13 <lambdabot>  Defined.
18:56:18 <FunctorSalad> benmachine: unlet = let :(
18:56:22 <FunctorSalad> like 'inflammable'
18:56:26 <benmachine> haha
18:56:26 <FunctorSalad> edit distance 2
18:56:40 <benmachine> that's... terrible
18:56:47 <benmachine> but also kind of neat but mostly terrible
18:56:57 <aavogt> there should probably be a special case for that
18:57:03 <kmc> i like the correction in lambdabot
18:57:05 <kmc> @ball-dicks foo
18:57:07 <lambdabot> *** "foo" jargon "Jargon File (4.3.1, 29 Jun 2001)"
18:57:09 <lambdabot> foo /foo/ 1. interj. Term of disgust. 2. [very common] Used very
18:57:11 <lambdabot>    generally as a sample name for absolutely anything, esp. programs and
18:57:13 <lambdabot>    files (esp. scratch files). 3. First on the standard list of
18:57:15 <lambdabot>    {metasyntactic variable}s used in syntax examples. See also {bar},
18:57:17 <lambdabot> [171 @more lines]
18:57:19 <FunctorSalad> I like it too ;)
18:57:31 <benmachine> kmc: there is no way I should be laughing this much at that
18:57:32 <Mathnerd314> ball-dicks? o_O
18:57:36 <FunctorSalad> @botcrack
18:57:36 <lambdabot> :)
18:58:01 <aavogt> @botslack
18:58:02 <lambdabot> :)
18:58:04 <benmachine> Mathnerd314: all-dicts I assume
18:58:04 <Mathnerd314> oh, all-dicts
18:58:24 <benmachine> kmc: sometimes it's nice but the @info thing really annoys me
18:58:27 <Mathnerd314> and botsnack
18:58:43 <copumpkin> @butsmack
18:58:43 <lambdabot> :)
18:58:54 <kmc> what about @info?
18:59:03 <benmachine> it's actually @undo
18:59:05 <kmc> ahaha
18:59:12 <kmc> i remember once @vixen got removed and was autocorrected to @nixon
18:59:19 <benmachine> @nixon
18:59:19 <lambdabot> When the President does it, that means that it is not illegal.
18:59:21 <aavogt> @info I really need to know
18:59:21 <lambdabot> I really need to know
18:59:25 <kmc> so instead of airhead flirting you get rants about how the jews and the gays are ruining the country
18:59:32 <kmc> @. vixen nixon
18:59:33 <lambdabot> i think i can...
18:59:34 <benmachine> haha
18:59:35 <aavogt> @info >I really need to know
18:59:35 <lambdabot> (> I really need to know)
18:59:38 <kmc> @. elite nixon
18:59:39 <lambdabot> D0n'+ TRY +O takE 0n 4 New p3RzOnalitY; IT d0ESn'7 WORx.
18:59:45 <Mathnerd314> @if 1+2=3
18:59:45 <lambdabot> Maybe you meant: bf id
18:59:48 <kmc> @. elite nixon
18:59:48 <lambdabot> zolu+i0NS aR3 No7 ThE 4ns\/\/eR.
19:00:56 <Mathnerd314> @help get-shapr
19:00:57 <lambdabot> get-shapr. Summon shapr instantly
19:00:59 <benmachine> @flunch
19:00:59 <lambdabot> Not enough privileges
19:01:32 <FunctorSalad> <kmc> what about @info?
19:01:32 <FunctorSalad> <benmachine> it's actually @undo
19:01:32 <FunctorSalad> <kmc> ahaha
19:01:37 <FunctorSalad> awesome
19:01:51 <kmc> instantly!
19:03:09 <Mathnerd314> benmachine: what's flunch?
19:03:17 <benmachine> flush
19:03:47 <benmachine> i.e. save state to disk
19:03:51 <Mathnerd314> not in command list...
19:04:01 <benmachine> well, it's operator-only
19:04:03 <benmachine> @help flush
19:04:03 <lambdabot> flush. flush state to disk
19:04:14 <benmachine> hence, not enough privileges
19:04:37 <Mathnerd314> oh.
19:04:48 <Mathnerd314> @flunk
19:04:48 <lambdabot> Not enough privileges
19:04:49 <benmachine> besides I don't think the list is entirely up to date
19:05:08 <Mathnerd314> @flunk school
19:05:09 <lambdabot> Not enough privileges
19:05:55 <Mathnerd314> so what's the shortest way to write fmap fmap fmap?
19:06:00 <Gracenotes> social commentary? .-.
19:06:06 <benmachine> fmap.fmap
19:06:09 <benmachine> probably
19:06:17 <Mathnerd314> :t (.).(.)
19:06:18 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
19:06:28 <benmachine> that only works if you previously redefined (.)
19:06:47 <dabblego> there is a library on hackage that has it, but I've forgotten its name (Scala uses ââ)
19:06:57 <Gracenotes> 'a a a' is shorter if you define a = fmap somewhere else
19:07:11 <Gracenotes> ... rhhm, useful stuff.
19:07:23 <FunctorSalad> (\x -> x.x.x)fmap
19:07:25 <FunctorSalad> :p
19:07:31 <Mathnerd314> @hoogle (a -> b) -> f (f1 a) -> f (f1 b)
19:07:32 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
19:07:32 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
19:07:32 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
19:07:40 <dolio> a.a would be shorter than that.
19:07:43 <benmachine> :t join(.)fmap
19:07:44 <lambdabot>     Occurs check: cannot construct the infinite type: a = f a
19:07:44 <lambdabot>       Expected type: (a -> b) -> f a -> f b
19:07:44 <lambdabot>       Inferred type: (a -> b) -> a -> b
19:07:48 <FunctorSalad> @ty (\x->x.x.x)
19:07:49 <lambdabot> forall b. (b -> b) -> b -> b
19:07:51 <benmachine> hmm
19:07:55 <FunctorSalad> nice, spaces are optional
19:08:08 <benmachine> :t join (.)
19:08:09 <lambdabot> forall a. (a -> a) -> a -> a
19:08:38 <Gracenotes> there must be three distinct symbols, though. in the case of shoving a single fmap through a lambda, it all gets combined into one functor
19:08:38 <benmachine> I guess the fmaps aren't the same
19:08:56 <benmachine> :t let a = fmap in a . a
19:08:56 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
19:09:00 <FunctorSalad> and not composed...
19:09:17 <FunctorSalad> my fault
19:09:37 <dons> dabblego: srsly? ââ == fmap fmap fmap ?
19:09:47 <FunctorSalad> fmap fmap fmap = fmap . fmap
19:10:01 <FunctorSalad> (just repeating)
19:10:02 <dons> mapping a mapping function over a structure. its nice, but how common is it?
19:10:09 <dabblego> dons, yes (in a third party library)
19:10:13 <dons> cute.
19:10:16 <dabblego> dons, it's extremely common
19:10:38 <FunctorSalad> whenever you have two functors composed?
19:10:38 <dons> i suppose we see it a lot in applicative code these days. lots of lifting and mapping
19:10:42 <FunctorSalad> fmap.fmap, at least
19:11:19 <benmachine> :t fmap toUpper <$> getLine
19:11:20 <lambdabot> IO [Char]
19:11:24 <FunctorSalad> @ty (fmap fmap fmap, fmap.fmap)
19:11:25 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *) (f2 :: * -> *) a1 b1 (f3 :: * -> *). (Functor f, Functor f1, Functor f2, Functor f3) => ((a -> b) -> f (f1 a) -> f (f1 b), (a1 -> b1) -> f2 (f3 a1) -> f2 (f3
19:11:25 <lambdabot> b1))
19:11:38 <dons> btw, elliottt and glguy have coined <$> -- "money" and <*> as "splat".
19:11:42 <dons> i strongly suggest you use these names :)
19:11:56 <ezyang> +1
19:11:57 <glguy> ha
19:11:58 <FunctorSalad> not money in a box?
19:12:02 <FunctorSalad> thought it was a box
19:12:21 <dons> glguy: heya
19:12:32 <FunctorSalad> (in perspective...)
19:12:38 <aavogt> that's not too many 't's?
19:12:47 <dons> nope.
19:13:04 <Mathnerd314> :t <*>
19:13:05 <lambdabot> parse error on input `<*>'
19:13:09 <Mathnerd314> :t (<*>)
19:13:09 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
19:13:17 <Mathnerd314> :t (<$>)
19:13:18 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:13:33 <Mathnerd314> so many names for fmap...
19:13:35 <FunctorSalad> @ty fmap fmap fmap ?g ?f ?x
19:13:36 <lambdabot> forall t a b (f :: * -> *). (Functor ((->) t), Functor f, ?g::a -> b, ?f::t -> f a, ?x::t) => f b
19:14:11 <Saizan> "fmap is money!"
19:14:26 <uorygl> Is there some sort of directive that says "make this thread start using as much of the share of computing time as possible"?
19:15:08 <dons> uorygl: there's no priority control of haskell lightweight threads (forkIO'd ones)
19:15:27 <dons> the scheduler will try to balance running threads over cores so they get a fair share of time
19:15:30 <FunctorSalad> stop the other threads?
19:15:38 <Mathnerd314> > map `asTypeOf` fmap `asTypeOf` (.) `asTypeOf` (<$>) `asTypeOf` liftM `asTypeOf` liftA
19:15:39 <lambdabot>   {{()->()}->{[]->[];[()]->[()];[(),()]->[(),()];[(),(),()]->[(),(),()]}}
19:15:42 <dons> you can play some tricks, with pinning things, and controlling which threads are on which core
19:15:46 <FunctorSalad> maybe make a new process with other prio....
19:15:46 <dons> but that's a bit advanced.
19:15:51 * uorygl nods.
19:16:20 <benmachine> what is the point of liftA I wonder
19:16:35 <c_wraith> it's like fmap, but...  identical! :)
19:16:58 <dabblego> every module must define a fmap alias; it's in the report
19:16:59 <FunctorSalad> hmm
19:16:59 <Mathnerd314> :t liftA
19:17:00 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
19:17:12 <FunctorSalad> consistency with liftA2 etc
19:17:21 <Mathnerd314> :t liftA2
19:17:22 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
19:17:32 <Saizan> should be liftA1 then
19:17:40 <FunctorSalad> :)
19:17:45 <Saizan> but we've liftM i guess
19:17:47 <dabblego> pure = liftA0
19:17:47 <benmachine> pure = liftA0
19:17:50 <benmachine> hah
19:17:50 <dabblego> zing!
19:17:51 <FunctorSalad> :D
19:17:51 <kmc> haha
19:18:04 <Mathnerd314> yes!
19:18:17 <benmachine> Saizan: yeah but liftM at least can be used to circumvent the problem of Functor not being implied by Monad
19:18:23 <benmachine> Applicative doesn't have that problem
19:18:27 <FunctorSalad> is that really the natural choice?
19:18:56 <FunctorSalad> oh nvm
19:18:59 <FunctorSalad> seems like it
19:18:59 <Mathnerd314> liftAX f x = liftA(X-1) f <*> x
19:19:19 <dabblego> Applicative has the problem of not having Pointed
19:19:30 <Mathnerd314> > liftA2 `asTypeOf` \f x -> liftA <*> x
19:19:31 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> b
19:19:50 <benmachine> dabblego: what methods would Pointed even have anyway
19:19:51 <FunctorSalad> dabblego: until we have superclass defaults, that's a tradeoff
19:19:57 <dabblego> benmachine, pure
19:19:57 <benmachine> err, not methods
19:19:58 <FunctorSalad> moar classes, moar boilerplate
19:19:58 <benmachine> but
19:20:03 * dubblego coughs
19:20:11 <benmachine> Monad has mapM and sequence and all those
19:20:15 <Mathnerd314> > liftA2 `asTypeOf` \f x -> liftA f <*> x
19:20:16 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
19:20:16 <FunctorSalad> (finer hierarchy, to be exact)
19:20:22 <benmachine> well strictly speaking Applicative should have both of those but anyways
19:20:32 <benmachine> Monad has... when and unless
19:20:41 <benmachine> but Pointed can't really do anything interesting
19:20:45 <dabblego> yes it can
19:20:55 <dabblego> you've surely used pure without (<*>_
19:21:04 <FunctorSalad> instance Pointed ... pure = unsafeLaunch....
19:21:06 <benmachine> hmm I guess so
19:21:14 <aavogt> @src fmap2
19:21:15 <lambdabot> Source not found.
19:21:25 * benmachine blinks
19:21:53 <dolio> @type \f x -> (liftA f x <*>)
19:21:53 <lambdabot> forall a a1 b (f :: * -> *). (Applicative f) => (a -> a1 -> b) -> f a -> f a1 -> f b
19:22:03 <Saizan> @type liftA2 `asTypeOf` \f x y -> liftA f x <*> y
19:22:04 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
19:22:12 <benmachine> what types would be pointed that aren't applicative?
19:23:02 <Mathnerd314> Data.Monoid.Endo!
19:23:15 <dabblego> Endo is not a functor
19:23:20 <dabblego> (covariant functor)
19:23:34 <Mathnerd314> :'-(
19:23:41 <benmachine> :t Endo const
19:23:41 <lambdabot>     Occurs check: cannot construct the infinite type: a = b -> a
19:23:42 <lambdabot>     Probable cause: `const' is applied to too few arguments
19:23:42 <lambdabot>     In the first argument of `Endo', namely `const'
19:23:43 <benmachine> er
19:23:45 <benmachine> :t Endo . const
19:23:46 <lambdabot> forall a. a -> Endo a
19:23:58 <benmachine> that's not actually useful though is it? :P
19:24:09 <Mathnerd314> nope :-/
19:24:43 <Mathnerd314> but IIRC (,) e is only a functor
19:25:07 <benmachine> it's not pointed either
19:25:12 <Nereid> so I'm trying to get haskell stuff working in Windows
19:25:18 <benmachine> unless you Monoid the e, in which case it's Applicative too
19:25:19 <Nereid> so I try to cabal install SDL
19:25:22 <Nereid> and I get this message:
19:25:26 <FunctorSalad> Monad even :o
19:25:29 <FunctorSalad> writer
19:25:30 <Nereid> setup.exe: The package has a './configure' script. This requires a Unix compatibility toolchain such as MinGW+MSYS or Cygwin.
19:25:47 <benmachine> true
19:25:47 <Nereid> I've got mingw and msys installed, so is there a way to tell cabal to use that?
19:25:52 <Nereid> or how do I build this?
19:26:13 <Mathnerd314> Nereid: add the directories of gcc/sh/... to your %PATH%
19:26:26 <Nereid> ok, let's try that
19:27:13 <Nereid> ok, thanks
19:27:15 <Nereid> :)
19:28:38 <orlandu63> is there a functional implementation of if/else?
19:28:56 <c_wraith> :t if'
19:28:57 <lambdabot> Not in scope: `if''
19:28:58 <dabblego> type if'
19:29:02 <c_wraith> @type if'
19:29:03 <lambdabot> Not in scope: `if''
19:29:09 <Mathnerd314> @hoogle if'
19:29:09 <lambdabot> No results found
19:29:11 <orlandu63> i tried that :P
19:29:15 <orlandu63> which is why i asked
19:29:18 <dabblego> Data.Bool :)
19:29:51 <Nereid> that doesn't have it
19:29:54 <benmachine> @pl \p x y -> if p then x else y -- pl cheats
19:29:54 <lambdabot> if'
19:30:00 <Nereid> lol
19:30:03 <benmachine> just write it yourself :P
19:30:30 <Mathnerd314> @let if' a b c = if a then b else c
19:30:30 <lambdabot>  Defined.
19:30:33 <Mathnerd314> :t if'
19:30:34 <lambdabot> forall t. Bool -> t -> t -> t
19:30:39 <Mathnerd314> :-)
19:31:16 <benmachine> I actually quite like t -> t -> Bool -> t
19:31:36 <Mathnerd314> ah, the fold
19:32:07 <Mathnerd314> @pl \a b c -> if c then a else b
19:32:07 <lambdabot> flip . flip if'
19:32:46 <nus> @src if'
19:32:46 <lambdabot> Source not found. My pet ferret can type better than you!
19:33:01 <nus> @spank lambdabot
19:33:01 * lambdabot jabs lambdabot with a C pointer
19:33:38 <Mathnerd314> hm, wonder how you add source definitions...
19:33:49 <Mathnerd314> @help src+
19:33:49 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:34:05 <benmachine> it'd be pretty hard to fit them in one line
19:35:20 <Mathnerd314> @src+ if' if' a b c = if a then b else c
19:35:20 <lambdabot> Source not found.
19:35:29 <Mathnerd314> ^ one line
19:35:35 <benmachine> well sure
19:35:44 <benmachine> @src zipWith
19:35:44 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
19:35:45 <lambdabot> zipWith _ _      _      = []
19:35:49 <benmachine> ^ two lines
19:36:13 <copumpkin> omnom
19:36:13 <copumpkin> ^ one line
19:36:16 <nus> naively, one may also want @src (<-)
19:36:22 <Mathnerd314> @src+ zipWith zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
19:36:22 <lambdabot> Source not found. Sorry.
19:36:37 <Mathnerd314> @src++ zipWith zipWith _ _ _ = [] :-)
19:36:37 <lambdabot> Source not found. Maybe if you used more than just two fingers...
19:36:57 <Saizan> @karma src
19:36:57 <lambdabot> src has a karma of 0
19:37:11 <Mathnerd314> @karma @src
19:37:11 <lambdabot>  @src has a karma of 0
19:38:19 <jediforce666> hi
19:38:23 <nus> @unpl flip $ flip if'
19:38:23 <lambdabot> (\ b c -> if' b c)
19:38:34 <jediforce666> lo que?
19:39:53 <sohum> @oeis 144,24
19:39:53 <lambdabot>  a(n) = smallest k>n such that n^2+k^2 is a perfect square, or 0 if no such k...
19:39:54 <lambdabot>  [1,0,0,4,0,12,8,24,15,12,24,60,16,84,48,20,30,144,24,180,21,28,120,264,32,60...
19:40:12 <sohum> @oeis 144,24,1
19:40:12 <lambdabot>  Symmetric triangle of certain normalized products of decreasing factorials.
19:40:12 <lambdabot>  [1,1,1,1,1,1,1,2,2,1,1,6,12,6,1,1,24,144,144,24,1,1,120,2880,8640,2880,120,1...
19:40:28 <sohum> @oeis 144,24,,1
19:40:29 <lambdabot>  Symmetric triangle of certain normalized products of decreasing factorials.
19:40:29 <lambdabot>  [1,1,1,1,1,1,1,2,2,1,1,6,12,6,1,1,24,144,144,24,1,1,120,2880,8640,2880,120,1...
19:40:37 <sohum> hm.
19:41:26 <orlandu63> @oeis
19:41:27 <lambdabot> Plugin `oeis' failed with: Math/OEIS.hs:316:10-40: Irrefutable pattern failed for pattern ('%' : c : _, rest)
19:41:36 <orlandu63> @oeis 5,10
19:41:37 <lambdabot>  Pascal's triangle read by rows: C(n,k) = binomial(n,k) = n!/(k!*(n-k)!), 0<=...
19:41:37 <lambdabot>  [1,1,1,1,2,1,1,3,3,1,1,4,6,4,1,1,5,10,10,5,1,1,6,15,20,15,6,1,1,7,21,35,35,2...
19:42:18 <orlandu63> heh, that's useful
19:42:30 <mle> @oeis 4,8,15,16,23,42
19:42:30 <lambdabot>  The Lost Numbers.
19:42:30 <lambdabot>  [4,8,15,16,23,42,108]
19:43:07 <dankna> hahaha
19:43:09 <dankna> I see
19:43:34 <dankna> @oeis 1,11,21,1211,111221
19:43:35 <lambdabot>  Look and Say sequence: describe the previous term! (method A - initial term ...
19:43:35 <lambdabot>  [1,11,21,1211,111221,312211,13112221,1113213211,31131211131221,1321131112311...
19:43:38 <dankna> hey, it had it
19:43:51 <orlandu63> say i have type Value = String and a type definition f :: Value -> a
19:44:00 <orlandu63> would passing a String into f work?
19:44:01 <mail> > [2,4..]
19:44:01 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
19:44:08 <aavogt> yes
19:44:16 <mail> [1,1..]
19:44:22 <mail> > [1,1..]
19:44:22 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
19:44:35 <aavogt> > [1..1]
19:44:36 <lambdabot>   [1]
19:45:04 <Mathnerd314> since it works for [Char] and String
19:46:22 <orlandu63> Mathnerd314: good point
19:47:50 <FunctorSalad> orlandu63: (@if/then/else): the primitive concept are ADTs and that you can `case' over them
19:48:00 <FunctorSalad> i/t/e is the fold for Bool
19:50:19 <orlandu63> i see
19:51:38 <dabblego> @type \p -> if p then True else False -- identity
19:51:39 <lambdabot> Bool -> Bool
19:59:16 <copumpkin> where does the loeb function come from?
20:00:11 <Cale> Transplanted from modal logic
20:00:53 <Cale> http://en.wikipedia.org/wiki/L%C3%B6b%27s_theorem
20:01:34 <Cale> Seems it goes back even further to a statement about provability of statements in Peano arithmetic
20:01:37 <copumpkin> aha
20:09:53 <uorygl> > foldl1' gcd [8,10,14]
20:09:54 <lambdabot>   2
20:10:45 <uorygl> > foldl1' gcd [1200000*7,720000*7,1440000*7,14400000,864000*7,288000*7,720000*7,2400000*7]
20:10:45 <lambdabot>   48000
20:11:04 <uorygl> > map (/48000) [1200000*7,720000*7,1440000*7,14400000,864000*7,288000*7,720000*7,2400000*7]
20:11:05 <lambdabot>   [175.0,105.0,210.0,300.0,126.0,42.0,105.0,350.0]
20:12:20 <uorygl> Thank you, lambdabot!
20:12:55 <uorygl> > (126+105,42+350)
20:12:56 <lambdabot>   (231,392)
20:30:27 <Mathnerd314> @pl \f x y -> (liftA f x) <*> y
20:30:27 <lambdabot> ((<*>) .) . liftA
20:30:44 <Mathnerd314> lambdabot is just... so useful...
20:41:36 <tensorpudding> @djinn (((a -> b) -> a) -> a)
20:41:36 <lambdabot> -- f cannot be realized.
20:43:00 <tensorpudding> your intuition is too weak, djinn
20:43:52 <dancor> it's supposed to be f x a = a?
20:44:09 <dolio> That has too many arguments.
20:44:35 <c_wraith> yeah, the only way I can see to realize that is trivially via bottom
20:44:53 <dancor> f g = g undefined?
20:45:03 <ddarius> It would be a proof of Pierce's law which is equivalent to excluded middle.
20:46:09 <Veinor> how can you realize ((a -> b) -> a)
20:46:14 <Veinor> ?
20:46:24 <tensorpudding> Yes, it is exactly Peirce's law.
20:46:54 <tensorpudding> It's not valid intuitionistically, but it's easy enough to see classically.
20:47:51 <dolio> Let's see your classical lambda calculus.
20:48:12 <tensorpudding> classical lambda calculus?
20:48:21 <Nereid> :t \x y -> x :: (((a -> b) -> a) -> a)
20:48:22 <dancor> so there is no haskell expression not containing undefined with that type?
20:48:22 <lambdabot>     Inferred type is less polymorphic than expected
20:48:23 <lambdabot>       Quantified type variable `b' is mentioned in the environment:
20:48:23 <lambdabot>         x :: ((a -> b) -> a) -> a (bound at <interactive>:1:1)
20:48:26 <Nereid> hm
20:48:36 <Nereid> :t \x y ->yx :: (((a -> b) -> a) -> a)
20:48:37 <Nereid> er
20:48:37 <lambdabot> Not in scope: `yx'
20:48:38 <dancor> so haskell is intuitionistic in that way?
20:48:43 <Nereid> :t \x y -> y :: (((a -> b) -> a) -> a)
20:48:43 <lambdabot>     Inferred type is less polymorphic than expected
20:48:44 <lambdabot>       Quantified type variable `b' is mentioned in the environment:
20:48:44 <lambdabot>         y :: ((a -> b) -> a) -> a (bound at <interactive>:1:3)
20:48:46 <Nereid> so
20:48:54 <Nereid> :t \x y -> y
20:48:55 <lambdabot> forall t t1. t -> t1 -> t1
20:49:09 <tensorpudding> @type callCC
20:49:10 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
20:49:26 <ddarius> @djinn (EM a) => ((a -> b) -> a) -> a
20:49:26 <lambdabot> f a =
20:49:27 <lambdabot>     case em of
20:49:27 <lambdabot>     Left b -> b
20:49:27 <lambdabot>     Right c -> a (\ d -> void (c d))
20:50:00 <Nereid> EM?
20:50:06 <ddarius> @djinn-env
20:50:07 <lambdabot> data () = ()
20:50:07 <lambdabot> data Either a b = Left a | Right b
20:50:07 <lambdabot> data Maybe a = Nothing | Just a
20:50:07 <lambdabot> data Bool = False | True
20:50:07 <lambdabot> data Void
20:50:09 <lambdabot> type Not x = x -> Void
20:50:11 <lambdabot> class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b
20:50:11 <dolio> tensorpudding: djinn produces terms in a typed lambda calculus that corresponds (roughly) to the intuitionistic propositional calculus. So if you want Peirce's law, you'll need a lambda calculus (or something else) that corresponds to classical logic.
20:50:13 <lambdabot> class Eq a where (==) :: a -> a -> Bool
20:50:15 <lambdabot> class EM a where em :: Either a (Not a)
20:50:26 <dancor> ha
20:50:29 <Nereid> mm
20:51:59 <Nereid> so then what's void
20:52:01 <Nereid> :t void
20:52:02 <lambdabot> Not in scope: `void'
20:52:23 <ddarius> An empty case statement.
20:52:50 <Nereid> what do you mean?
20:52:51 <hpaste>  . (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24919
20:53:07 <ddarius> Let x :: Void, case x of {}
20:53:11 <ddarius> :: a
20:53:26 <Nereid> oh
20:53:27 <Nereid> I see.
20:54:41 <Nereid> so void :: Void -> a
20:54:41 <Nereid> ?
20:54:58 <ddarius> Quodlibet ex falso
20:55:40 <solrize> let accum !(!s1,!sx,!k0) !(a,k,n,xs) = (s1+n,sx+k*n,max k0 k)
20:55:52 <solrize> print (foldl' accum (0,0,0) hs
20:56:00 <solrize> any idea why that could be leaking space?
20:56:14 <nus> case x of {} :: a -- fiat currency?-)
20:56:59 <dolio> tensorpudding: For the record, I have seen classical lambda calculi. The one I recall is a bit different than your typical functional language, though.
20:57:17 <Nereid> anyway
20:57:23 <dolio> tensorpudding: That is, calculi that don't simply add lem/callcc as an extra primitive function.
20:57:27 <ddarius> I believe Parigot's lambda-mu calculus is the most well-behaved one.
20:57:30 <Nereid> can anyone help me get the SDL package built on windows?
20:57:31 <nus> doesn't classical LC imply AoC?
20:57:38 <ddarius> nus: No.
20:57:53 <nus> id?
20:57:55 <ddarius> The (full) axiom of choice has nothing to do with programming.
20:58:04 <Nereid> whenever I try to build, I get
20:58:05 <Nereid> well
20:58:21 <tensorpudding> dolio: Yeah, I knew that about djinn, I was just poking it for fun.
20:58:22 <Cale> solrize: Is it leaking space?
20:58:28 <solrize> yes
20:58:35 <solrize> after 15 sec it's using 100+ MB
20:58:40 <Nereid> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=24920#a24920
20:58:42 <tensorpudding> I've not heard of classical Î»-calculi though
20:58:43 <hpaste>  . (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24920
20:59:00 <Cale> solrize: hmm...
20:59:17 <c_wraith> solrize: what Num instance?
20:59:22 <solrize> Integer
20:59:24 <Cale> solrize: What is hs?
21:00:02 <solrize> hs = large list, i'm trying to figure out its type
21:00:07 <nus> ddarius, programming is only collateral to LC?
21:00:16 <Cale> I'm not really seeing so much space usage even just inside ghci with no optimisations, taking hs to be (zip4 [1..5000000] [1..] [1..] [1..])
21:00:21 <tensorpudding> This inspired me to install Coq again
21:00:42 <dolio> tensorpudding: http://hal.archives-ouvertes.fr/docs/00/15/02/83/PDF/Main.pdf
21:01:05 <nus> ddarius, besides, the choice function of AoC is sorta id, no?
21:01:32 <ddarius> nus: I don't know what you mean by "sorta id"
21:02:08 <solrize> hs :: Integral a => (a, a, a, [String])  or so
21:02:42 <c_wraith> ah.  ! on a String doesn't strictify it.
21:02:49 <scotty> What does <?> do?  I'm having a hard time using Google to search for those characters.
21:02:49 <gerryxiao> hello
21:02:51 <c_wraith> it only forces the first constructor
21:02:55 <Cale> gerryxiao: hello
21:02:57 <c_wraith> @hoogle <?>
21:02:57 <lambdabot> Text.Parsec.Prim (<?>) :: Monad m => ParsecT s u m a -> String -> ParsecT s u m a
21:02:57 <lambdabot> Text.ParserCombinators.Parsec.Prim (<?>) :: Monad m => ParsecT s u m a -> String -> ParsecT s u m a
21:02:58 <tensorpudding> That's not likely to mean anything to me.
21:03:12 <solrize> yeah, but i'm not even using the string in the fold
21:03:13 <scotty> Okay, so this is something specific to Parsec.
21:03:16 <solrize> it should just discard it
21:03:32 <Cale> scotty: In Parsec, it annotates a parser with a friendly name to be used in error messages to indicate when that parser fails.
21:03:43 * ddarius suspects that hs is what is taking up the memory, not the foldl'.
21:03:45 <gerryxiao> why ap= liftM2 ($)
21:03:52 <solrize> hmm
21:04:03 <Cale> solrize: try: print (foldl' accum (0,0,0) (zip4 [1..10000000] [1..] [1..] (map show [1..])))
21:04:19 <Cale> solrize: That works in apparent constant (or log) space for me.
21:04:37 <gerryxiao> liftM2 :: (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
21:04:49 <gerryxiao> (liftM2 ($)) :: (Monad m) => m (a2 -> b) -> m a2 -> m b
21:04:59 <solrize> trying
21:05:16 <gerryxiao> ($) :: (a -> b) -> a -> b
21:05:22 <Cale> gerryxiao: liftM2 f x y = do u <- x; v <- y; return (f u v)
21:05:32 <gerryxiao> and?
21:06:00 <gerryxiao> liftM2 ($)
21:06:02 <Cale> So if f = ($), then  ap x y = liftM2 ($) x y = do u <- x; v <- y; return (u v)
21:06:39 <Cale> So, run both actions, apply the function result of the first to the value result of the second, returning that.
21:06:48 <ddarius> The standard definition of ap is liftM2 ($), so what answer are you expecting besides "by definition?"
21:07:07 <pastorn> @type ap
21:07:08 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
21:07:09 <gerryxiao> type to type
21:07:33 <solrize> that doesn't seem to leak space
21:07:50 <Cale> solrize: So whatever it is, it can't be explainable just from that fragment
21:07:55 <solrize> right
21:08:12 <nus> ddarius, \x.x how do you choose x?
21:08:50 <gerryxiao> type inference from ap to liftM2 ($)
21:09:14 <c_wraith> :type liftM2 ($)
21:09:28 <c_wraith> @type liftM2 ($)
21:09:29 <lambdabot> forall a2 b (m :: * -> *). (Monad m) => m (a2 -> b) -> m a2 -> m b
21:09:38 <c_wraith> looks right to me
21:09:38 <ddarius> nus: That doesn't make sense.
21:10:02 <solrize> but, how can hs leak space, if accum forces every element of hs to be evaluated?
21:10:34 <ddarius> If hs is bound, then it will just grow and the early nodes won't be able to be reclaimed.
21:10:54 <scotty> Cale: Will the error message passed to <?> show up when running the program in ghci?
21:11:22 <scotty> The function I'm looking at looks like this:
21:11:25 <scotty> word :: Parser String
21:11:25 <scotty> word = many1 letter <?> "word"
21:11:34 <nus> ddarius, well, Church-LC doesn't specify the domain, for that to make sence in set theory.
21:11:42 <solrize> hmm.  yes, hs is bound, but nothing uses it except that fold
21:12:06 <ddarius> solrize: Is it bound in GHCi?
21:12:15 <solrize> no
21:12:18 <scotty> So, if I do "run word 4," I would expect to see "word," right?
21:14:04 <solrize> should i pastebin the whole program?  it's about 30 lines but very ugly
21:16:59 <nus> ddarius, let me rephrase, for \x.x to have any applicative sense, a choice function is required.
21:17:51 <Cale> scotty: If the parse fails inside that parser, it'll say something like "Expected: word"
21:17:59 <Cale> solrize: go for it
21:18:42 <solrize> ok
21:18:54 <hpaste>  . (solrize)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24921
21:19:09 <solrize> i added a comment explaining what it does
21:20:10 <solrize> the parsec import and some other weird artifacts are b/c this code is from cannibalizing another file :P
21:21:09 * hackagebot hoopl 3.7.12.1 - A library to support dataflow analysis and optimization  http://hackage.haskell.org/package/hoopl-3.7.12.1 (NormanRamsey)
21:22:02 <Cale> solrize: Just to check, have you tried compiling with -O2?
21:22:07 <solrize> yes
21:22:09 <Cale> okay
21:22:23 <Cale> hmm
21:22:36 <solrize> wait, let me compile again
21:22:45 <solrize> it looks like i left out -O2 in my later tests
21:23:09 <solrize> and now i broke something
21:23:48 <solrize> still burning space with -O2
21:25:03 <Cale> Will there be a lot of lines with the same hash?
21:25:05 <solrize> let me clean up the code a little, it's gotten too messy
21:25:37 <solrize> you mean runs of millions?  hmm i doubt it but it's possible
21:25:39 <solrize> 1000's maybe
21:25:44 <Cale> okay
21:25:46 <siracusa> Hhm, hoopl has a strange version history ...
21:25:57 <Cale> I'm not even sure it would matter.
21:27:52 <Cale> solrize: You might try heap profiling
21:28:57 <Cale> I don't see anything where it would obviously have to hang on to early parts of the input for a long time.
21:29:26 <solrize> ok, i'll look in RWH to see how to use the heap profiler... i used it a long time ago but have forgotten   thanks
21:29:39 <solrize> anyway it helps to know i didn't do anything obviously broken or insane
21:29:47 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/prof-heap.html
21:30:20 <Cale> Basically, start by compiling with -prof -auto-all and then run with +RTS -hc
21:30:29 <Cale> and then run hp2ps on the resulting .hp file
21:30:37 <solrize> it says i've got to install more libraries to use -prof, sigh
21:30:58 <Cale> oh, but you're not really using all those libraries are you?
21:31:15 <solrize> well the first one it complains about is Data.Function
21:31:25 <Cale> Oh, weird.
21:31:25 <solrize> which i'm using
21:31:30 <Cale> Isn't that in base?
21:31:48 <Cale> it is
21:31:48 <solrize>     Could not find module `Data.Function':
21:31:49 <solrize>       Perhaps you haven't installed the profiling libraries for package `base'?
21:31:55 <solrize> well it's suggesting i haven't installed base
21:32:01 <ddarius> Does the functor U : Rng -> Grp (forgetting the multiplication) have a left adjoint and is U monadic (tripleable)?
21:32:04 <Cale> blah, that's supposed to come with GHC
21:32:25 <Cale> Do you have Ubuntu or Debian's version of GHC installed?
21:32:35 <solrize> i don't remember how i installed ghc... just downloaded some big tarball from haskell.org and unpacked it
21:33:09 <Cale> ddarius: Maybe the group ring Z[G]?
21:33:46 <Cale> solrize: hmm, okay
21:33:52 <solrize> maybe this is a good time to upgrade my haskell installation
21:35:01 <solrize> 6.12.1 is ok to use these days?  i'm still on 6.10.4
21:35:33 <Cale> solrize: I'm also still on 6.10.4
21:37:36 <ddarius> Cale: Thanks.  That may be it.  It's at least something.
21:38:37 <solrize> trying yum install ghc
21:38:57 <solrize> says it's already installed
21:39:34 <Cale> solrize: ah, so perhaps you are using your distribution's GHC. Check for a ghc-prof package or something.
21:39:34 <pastorn> solrize: get the 6.12 binary blob and install it manually
21:40:09 <solrize> trying install ghc-prof first
21:40:20 <ddarius> Well it isn't quite what I'm looking for.
21:40:24 <solrize> yum is searching mirrors and not finding it
21:41:27 <solrize> oh now it found it
21:41:48 <Cale> ddarius: hmm... F.U would go Rng -> Rng, and would send a ring to the ring of integer-linear combinations of ring elements. That has an obvious eta and mu
21:41:56 <solrize> will be done downloading in a minute or two
21:42:11 <solrize> haskell platform download instructions are messed up
21:42:18 <Cale> Er, is that the wrong adjoint?
21:42:52 <Cale> Hard to keep things the right way around sometimes :)
21:42:53 <ddarius> Cale: Yes.  The group of units functor is not the "forgetful" functor that I'm considering.
21:43:16 <Cale> You're considering the additive group functor
21:43:25 <ddarius> Yes.
21:43:40 <ddarius> Cale: There is an adjunction using the group of units functor, though.
21:43:44 <Cale> That's still okay, isn't it though?
21:44:20 <Cale> You can still form Z[G] where G is the additive group of your ring, and it just amounts to taking formal integer linear combinations of your ring's elements
21:44:46 <Cale> and there's an easy monad there
21:44:54 <solrize> ok, compiled with -prof, running with ./md5dup +RTS -P -RTS   is that right?
21:45:36 <Cale> Because every element of your ring naturally goes to its image in Z[G] (x goes to the trivial linear combination 1*x)
21:45:42 <Cale> and that's your eta
21:45:55 <Cale> and mu will expand a Z-linear combination of Z-linear combinations out
21:46:41 <Cale> solrize: +RTS -hc
21:47:03 <solrize> ah, ok.  profile report with -P was useless
21:47:08 <ddarius> Cale: I want U(Z) = Z for example, not U(Z) = {1,-1}
21:47:22 <Cale> ddarius: I know.
21:47:34 <Cale> ddarius: I never assumed otherwise
21:49:32 <Cale> But I think maybe I have the wrong adjoint... F . U is a monad, which means that U is left adjoint to F.
21:49:44 <solrize> i see the allocation for MAIN goes up and down in size but then eventually starts climbing
21:50:16 <solrize> maybe there's a large run of identical md5's in that file and that's using heap
21:50:20 <Cale> solrize: okay, so maybe you'll need to add some cost-centres to get some more detail
21:50:34 <solrize> hmm
21:50:37 <Cale> solrize: since everything is defined locally in main, and auto-all only tags top-level things
21:50:54 <solrize> i can split out those functions to the top level i guess ?
21:51:04 <Cale> that might help
21:51:16 <Cale> But also, maybe have a look at the file and see if there's anything obvious like that
21:51:20 <solrize> or is it better to tell ghc to profile the internal nodes
21:51:20 <Cale> it would be a useful hint anyway
21:51:33 <solrize> hmm, how to find that in the file... i guess i can run a python script
21:51:36 <solrize> the file is about 300MB
21:51:52 <Cale> Ah, I suppose that's a little large to pop open in a text editor and have a look :)
21:52:08 <Cale> It should be visually obvious though
21:52:17 <solrize> i don't think i can scroll through that much ;)
21:52:53 <Cale> Hey, what happens if you just print hs
21:53:21 <solrize> that's millions of nodes
21:53:35 <Cale> But does it leak memory?
21:53:47 <solrize> you mean just writing to stdout ?
21:53:50 <Cale> yeah
21:54:10 <solrize> trying
21:54:37 <solrize> yes, leaking mem
21:55:33 <Cale> You're not using the 4th part of each tuple in the foldl', are you expected to need it later?
21:55:49 <solrize> no, the whole program is in the hpaste
21:55:54 <solrize> there's nothing after the print
21:56:08 <Cale> okay, so what if you change collapse to just produce triples
21:56:37 <Cale> Kill off 'rest'
21:56:43 <solrize> trying
21:56:56 <Cale> at least it'll make things simpler, if nothing else :)
21:57:26 <solrize> still leaking
21:57:39 <Cale> hmmm....
21:57:43 <solrize> that was the print hs version
21:57:46 <solrize> now trying the fold
21:57:56 <solrize> which also leaks
21:58:02 <Cale> Well, if printing them leaks, then so should the fold
21:58:22 <ddarius> I've found my answer.
21:59:04 <solrize> should i put !'s in the type sig of accum?
21:59:36 <Cale> solrize: That'd be a syntax error
21:59:45 <solrize> k
21:59:47 <Cale> solrize: Making things too strict doesn't necessarily help anyway
22:00:22 <Cale> The outer ! on the triple for the first parameter of accum isn't doing anything
22:00:37 <solrize> yeah i wasn't sure, figured it couldn't hurt
22:00:43 <solrize> didn't want a thunked tuple constructor around
22:00:47 <Cale> (also on the second)
22:00:56 <Cale> Triple constructors aren't thunks
22:01:01 <Cale> well...
22:01:11 <c_wraith> the pattern match forces the constructor to be evaluated, anyway
22:01:14 <Cale> Once it matches the pattern it really will be a triple constructor
22:01:23 <solrize> right
22:01:26 <Cale> so it can't be an unevaluated expression
22:06:02 <ivanm> is it just me, or have other people been getting Postmaster Delivery Status Notification(Failure) messages about trying to send an email to -cafe and it not being able to be sent to someone's blackberry?
22:06:31 <solrize> wow, there's some hashes that occur 165000 times
22:10:12 <solrize> so i have head xs and length xs... i guess that's trying to retain 165000*32 chars at 24(?) bytes per list node... 1.2gb
22:10:22 <solrize> no wait 126m
22:10:41 <solrize> and then 2x that for gc ?
22:10:59 <solrize> but i think i let it run for a while and it got over 1gb consumed
22:11:26 <Cale> solrize: I'm just refactoring your program into something a little easier for me to understand :)
22:11:35 <solrize> :)
22:18:38 <Cale> http://paste.lisp.org/display/97948
22:18:50 <Cale> (hpaste just got stuck somehow)
22:19:08 <Cale> hmm...
22:19:15 <solrize> sec
22:21:25 <solrize> trying your version... last "hs" should be "ms", fixed
22:21:32 <Cale> ah, yes :)
22:21:57 <solrize> leaks at about the same rate as my version
22:22:16 <Cale> one thing which is mostly superstitious but I'd like to try it anyway is to switch the let in collapse out for a case
22:22:39 <Cale> That is,  case head xs of (lineno, (hash, len, filename)) -> (lineno, fI (length xs), fI len)
22:23:00 <solrize> ok, sec
22:24:01 <solrize> no change
22:24:04 <Cale> okay
22:24:12 <ddarius> Cale: Incidentally, the left adjoint to the functor that takes a ring to its additive group is the tensor ring construction which treats the underlying (Abelian) group as a Z-Z bimodule.
22:24:40 <solrize> but, maybe some more strictness is possible there
22:24:49 <Cale> ddarius: Okay, I'm mostly unfamiliar with that :)
22:25:18 <Cale> solrize: What does the heap profile look like now?
22:25:38 <Cale> At least with things split apart a little more, maybe we'll see something more interesting?
22:25:42 <solrize> sec
22:26:27 <ddarius> Cale: I think if you consider the problem, you'd arrive at the same thing (albeit in a much more messy, concrete fashion).  I'm pretty sure that's where my construction was heading, I was just too lazy to check to see if the addition made sense.
22:26:57 <scotty> If I have a data constructor such as "data Person = Person String Integer", how do I extract the first piece of data (String in this case)?
22:27:14 <copumpkin> pattern match
22:27:19 <scotty> Is that the only way?
22:27:21 <wavewave> pattern match?
22:27:24 <solrize> not too much different than before
22:27:24 <copumpkin> yeah
22:27:26 <Cale> scotty: Pattern match:  f (Person name age) = name
22:27:26 <copumpkin> unless you make a record
22:27:32 <scotty> How about if I have a list of the type?
22:27:44 <solrize> i don't see any of those internal functions in the profile
22:27:45 <Cale> map (\(Person name age) -> name)
22:27:47 <scotty> What if I'm already pattern matching like so: (x:xs)
22:27:50 <solrize> just MAIN getting large
22:28:03 <jmcarthur> (Person name age):xs
22:28:03 <scotty> Ah, I think I see how I could do it.
22:28:13 <wavewave> pattern match can be nested
22:28:13 <scotty> Oh, awesome!
22:28:33 <scotty> I guess it's also handy to define helper functions, yeah?
22:28:36 <jmcarthur> you can always use record syntax or define accessor functions
22:28:52 <scotty> Like, name (Person n a) = n
22:28:54 <Cale> scotty: Yeah, and learn to avoid explicit recursion as much as possible by using higher order functions
22:28:56 <wavewave> x@(Person name age):xs is also possible.
22:29:10 <solrize> i see MAIN oscillates in size for a while, before starting to grow monotonically
22:29:11 <Cale> scotty: Yeah, you can get those functions for free if you use the "record syntax"
22:29:16 <jmcarthur> data Person = Person { name :: String, age :: Integer }
22:29:21 <scotty> Whoa
22:29:21 <Cale> ^^ like that :)
22:29:22 <solrize> suggesting that it's burning space when it hits a big run of similar md5's
22:29:26 <scotty> That's nice sugar.
22:29:37 <jmcarthur> gives you (name :: Person -> String) and (age :: Person -> Integer) for free
22:29:49 <scotty> Cale: Can you elaborate on the recursion bit?
22:29:59 <solrize> i will try writing collapse as a strict fold
22:30:23 <Cale> scotty: Well, you generally want to get really good at using map/filter/foldr/group/takeWhile/etc. to your advantage
22:30:57 <Cale> scotty: Most recursions on lists can be turned into compositions of the various higher order functions in one way or another.
22:31:04 <tensorpudding> you can use those functions to generalize other operations which are conceptually similar
22:31:22 <scotty> Cale: I see.
22:31:39 <jmcarthur> yeah, it leads to clearer, more decomposable code
22:31:55 <jmcarthur> explicit recursion usually means all those separate concepts have to be all interleaved together
22:32:19 <tensorpudding> for example, taking the product of a list of numbers
22:32:37 <tensorpudding> you could recurse on the list, but it turns out that using a fold makes the answer very concise
22:32:41 <Cale> solrize: You might also try turning off optimisations while profiling
22:32:48 <tensorpudding> @src product
22:32:48 <lambdabot> product = foldl (*) 1
22:32:55 <jmcarthur> of course for that example you can just use the product function
22:32:57 <Cale> solrize: If everything gets inlined into main, it makes things awkward
22:32:57 <solrize> ok
22:33:01 <solrize> ic
22:33:49 <Cale> solrize: Though perhaps it's counting the memory for parseLines as being part of main regardless. I'm not exactly sure how it counts things.
22:34:09 <Cale> solrize: I'm thinking that it's got to have something to do with groupBy
22:34:12 <solrize> i rewrote collapse as a fold and it didn't help
22:36:57 <solrize> basically same output
22:37:06 <solrize> i mean same .hp output
22:37:48 <Cale> everything still being accounted for as main?
22:37:56 <solrize> yeah
22:41:22 <Cale> solrize: I'm just constructing memory-wise similar demos in ghci trying to get similar memory usage... I can't seem to get a space leak from the most obvious things.
22:41:23 <ivanm> anyone here actually made a full website using markdown + pandoc?
22:42:48 <Cale> solrize: In particular, the space usage of  map (\xs -> (head xs, length xs)) . groupBy ((==) `on` \(i,(a,b,c)) -> a) . zip [1..] $ [1..] >>= \n -> replicate (n^2) (n,n,n)  seems roughly constant
22:44:34 <Cale> (despite the fact that the lists of equivalent elements are growing, the elements are immediately getting GC'd once counted by length)
22:45:22 <ivanm> preflex: seen chrisdone
22:45:22 <preflex>  chrisdone was last seen on #haskell-blah 6 hours, 32 minutes and 13 seconds ago, saying: uh right
22:45:54 <Cale> (actually, I am seeing a bit of memory usage, but I think it's just the list of elements being computed)
22:46:38 <solrize> sorry was away for a sec
22:48:52 <wavewave> Can anyone help? I cannot compile gtk2hs program .
22:49:01 <kmc_> what's your error?
22:49:04 <wavewave> error message is here : http://pastebin.org/156200
22:49:33 <ivanm> wavewave: using ghc 6.12.1?
22:49:36 <kmc_> strange
22:49:40 <kmc_> i see that you are using ghc --make
22:49:42 <dmwit> --disable-split-objs ?
22:49:58 <kmc_> can you paste Hello.hs?
22:50:05 <solrize> cale, what if you have \xs->(head xs, length xs, show (length xs))
22:50:08 <solrize> so you get a lot of strings
22:50:28 <solrize> wait maybe that's in the wrong place
22:51:02 <wavewave> my hello.hs : http://pastebin.org/156202
22:51:13 <Cale> solrize: There are lots of strings to begin with, but they should all become garbage pretty quickly...
22:51:37 <wavewave> dmwit: what is --disable-split-objs?
22:52:10 <solrize> yeah, thing is that the very large md5 runs in that file will have 10's of MB of strings, how many heap bytes does that become?
22:52:12 <ivanm> wavewave: which version of ghc are you using?
22:52:15 <wavewave> ivanm: I am using ghc 6.12.1
22:52:29 <ivanm> wavewave: which version of gtk2hs are you using? from darcs?
22:52:41 <Cale> solrize: Assuming that it's all in memory at the same time...
22:52:49 <wavewave> I get it from darcs, I think..
22:53:05 <wavewave> In fact, I don't remember when...
22:53:13 <solrize> lemme try just letting that run and see if the memory goes about 2 or 3 GB.  this is an 8gb machine so it will survive even though a bunch of other stuff is running on it.  i never let it get above 1gb or so before
22:55:06 <Cale> solrize: Char values are 4 bytes. List cells are 12 bytes (on a 32-bit machine)
22:55:20 <solrize> this is an x86-64
22:55:21 <Cale> At least, if I'm remembering correctly.
22:55:27 <Cale> Ah, then even larger.
22:55:37 <solrize> program has maybe stabilized at 1.3gb, still running
22:56:02 <solrize> i wish there was an easy to log how much of the file has been processed
22:56:15 <Cale> We could always switch to using ByteString and see if that cures the problem
22:56:23 <solrize> yeah true
22:56:36 <solrize> still running at 1.3gb
22:56:38 <Cale> Though parsing will get just a little more complicated than 'read' :)
22:56:41 <wavewave> 'darcs change' shows that my gtk2hs is version of  Mar 30, 2010.
22:57:01 <solrize> read -> pack
22:57:24 <Cale> solrize: ah, I suppose you could do that too
22:57:32 <Cale> wavewave: does it show up in your ghc-pkg list?
22:57:47 <Cale> Though, you'd get an error if it didn't.
22:57:47 <solrize> program finished
22:58:02 <solrize> 3 minutes runtime to process 200M of text, seems pretty pathetic
22:58:14 <solrize> i will try again with heap profiling, which is about 3x slower
22:58:20 <Cale> Yeah, well, String IO is not so fast
22:58:24 <wavewave> Cale: no.. ghc-pkg list | grep gtk2hs    does not give any..
22:58:49 <wavewave> Cale: so should I register gtk2hs by hand?
22:59:04 <Cale> wavewave: any results for just 'gtk'?
22:59:20 <kmc_> wavewave, it builds for me on GHC 6.12.1 with Haskell Platform + Gtk2hs and friends from Debian
22:59:20 <wavewave> gtk-0.10.1
22:59:27 <solrize> yeah, bytestring should speed it up.  but 3 minutes for 200mb of just i/o?  i mean that's awful.  i will check the time profile for "read"
22:59:29 <Cale> yeah, that's it
23:00:20 <solrize> i also found that hexpat with bytestring did about 3MB/sec which was also disappointing... i was thinking of using attoparsec as an alternative, for munching large xml files
23:00:28 <Cale> solrize: You have to realise that as you read that 200mb of data, you're allocating list cells which consist of an integer tag and two pointers, each of which is going to be 8 bytes on your machine.
23:00:47 <Cale> solrize: Not to mention the Char values which are themselves huge :)
23:00:50 <wavewave> kmc_: hmm.. I have installed ghc separately.
23:00:53 <_nickel> new to xmonad here, anyone know why the focus border wouldn't be working properly?
23:01:01 <_nickel> ugh
23:01:06 <_nickel> thought I joined xmonad
23:01:10 * _nickel is sorry
23:01:15 <Cale> _nickel: no problem :)
23:01:19 <solrize> yeah, string is slow
23:01:40 <solrize> and i guess using read+pack will be almost as slow
23:01:53 <Cale> solrize: For fun, you might do a normal profile and see how much allocation your program does :)
23:02:05 <solrize> 100's of gb's i'm sure
23:02:19 <solrize> currently running with heap profile, a few minutes to go
23:03:04 <wavewave> now I am recompiling gtk2hs with --disable-split-objs
23:03:30 <solrize> crap, my net connection crashed
23:03:34 <solrize> and i had a huge download running
23:06:04 <solrize> hah, wget somehow restarted itself?
23:08:19 <Nereid> there's also wget -c to resume of course
23:09:05 <solrize> 2010-04-17 23:00:29 (299 KB/s) - Read error at byte 8209082704/17008818540 (Connection reset by peer). Retrying.
23:09:14 <solrize> it just went and connected up again in the middle.  neat.
23:09:22 <Nereid> indeed
23:09:30 <dmwit> This is why people tell you not to reinvent stuff.
23:09:38 <dmwit> Those wget folks already thought of everything. =)
23:09:44 <solrize> ;)
23:09:59 <solrize> i'm glad the remote server knows about byte ranges
23:10:15 <solrize> i actually thought of upgrading my dsl just for this download
23:11:18 <solrize> the heap profiling version of that program is using 1.8gb (stabilized i think) while the non-hc version used 1.3gb
23:11:27 <solrize> and it's run 12.5 minutes
23:14:21 <LegendaryPenguin> how do I say this: valuesInRow b 2 = nub $ concatMap (take 3 (drop 3)) $ take 3 b
23:14:27 <LegendaryPenguin> it doesnt like the take 3 drop 3 part
23:14:59 <Nereid> do you mean valuesInRow b 2 = nub $ concatMap (take 3 (drop 3 (take 3 b)))
23:15:31 <I_LIVE> I'm looking at using haskell at acm-style contests. Though, I/O is a pain.
23:15:33 <LegendaryPenguin> or that, yeah
23:15:42 <Nereid> because drop 3 :: [a] -> [a], which will not be accepted as a second argument to take
23:15:43 <dmwit> drop 3 . take 3 === const []
23:15:57 <Nereid> indeed
23:16:04 <LegendaryPenguin> so if I compose it, its ok?
23:16:18 <Nereid> drop 3 (take 3 x)) is [] for any list x
23:16:24 <Nereid> so it's probably not what you want
23:16:35 <LegendaryPenguin> i have the drop 3 second
23:16:46 <Nereid> and a take 3 third
23:16:47 <c_wraith> I_LIVE: given that there's printf for output, I assume you just mean input?  but even for input, words and read should do most of what you need.
23:17:13 <LegendaryPenguin> its in a concatMap though
23:17:23 <Nereid> oh
23:17:25 <Nereid> hmm
23:17:43 <Nereid> nub $ concatMap (\x -> take 3 (drop 3 x)) $ take 3 b
23:17:43 <ddarius> LegendaryPenguin: take 3 . drop 3
23:17:53 <Nereid> is that what you were trying to say?
23:18:10 <Nereid> in that case yes, concatMap (take 3 . drop 3) does the same there
23:19:19 <kmc_> I_LIVE, what's so hard about IO in Haskell
23:19:24 <kmc_> i think it's hard to *learn* not hard to *do*
23:19:33 <kmc_> and not all that hard to learn if you take the right approach
23:20:01 <solrize> program finished, 20 minutes(!) with heap profiling, MAIN heap consumption relatively small at the end.  ok, bytestring is next
23:20:25 <c_wraith> kmc_: well, programming-contest style IO is not real IO.  Almost every problem specification is set up assuming scanf and printf, for instance.  They format input and expected output such that it's easy with those primitives.
23:20:40 <solrize> cale, thanks much for the help, i still don't understand why the groupby sub-lists are using so much space, but it at least doesn't seem crazy
23:21:09 <c_wraith> kmc_: some languages (java) had primitives different enough that writing programming contest programs involved large amounts of IO boilerplate
23:21:19 <solrize> and thanks to everyone else who responded too
23:22:16 <c_wraith> kmc_: So I'm assuming I_LIVE's complaint is more about fitting the IO primitives available to the input/output forms expected by the problems with a minimum of boilerplate
23:22:18 <I_LIVE> java has many boilerplate code for nearly anything
23:22:24 <kmc_> that's true
23:22:33 <kmc_> most prog contest input formats i've seen are very simple
23:22:39 <kmc_> and would just be a matter of lines, words, and read
23:22:48 <I_LIVE> um
23:22:52 <kmc_> in fact i think that's significantly easier than getting the scanf qualifiers right
23:22:54 <c_wraith> Whatever version of java introduced java.util.Scanner massively simplified programming contest IO in java.
23:23:07 <I_LIVE> contestant needs to be able to handle any case
23:23:18 <I_LIVE> c_wraith, Scanner is turtle
23:23:24 <I_LIVE> slow as snail
23:23:31 <dabblego> 1.5
23:23:44 <c_wraith> doesn't matter. 99% of the time, the data sets are small.
23:23:44 <I_LIVE> inside, it uses regular expressions
23:24:02 <c_wraith> Speed of writing code is far more important than speed of execution
23:24:23 <c_wraith> There *are* counter-examples, but they're not the common cases.
23:24:40 <Nereid> and even so, most of the execution time will be spent on non-IO stuff
23:24:50 <I_LIVE> you can look at java solutions used in NEERC
23:25:15 <I_LIVE> here
23:25:15 <I_LIVE> http://neerc.ifmo.ru/past/2007/runs-neerc-2007.rar
23:25:24 <I_LIVE> Scanner is unsufficient
23:25:47 <ivanm> dabblego: what's 1.5?
23:25:59 <c_wraith> I_LIVE: my experience is based on making the worlds in the ACM competition. :P
23:26:00 <dabblego> "Whatever version of java introduced java.util.Scanner"
23:26:18 <I_LIVE> dabblego, 1.5
23:26:27 <ivanm> ahhhh
23:26:28 <Axman6> -_-
23:26:29 <I_LIVE> c_wraith, huh? where did you compete? which place?
23:26:35 <ivanm> hey Axman6
23:26:50 <Axman6> o/
23:27:01 <c_wraith> Western US region.  Out of the University of Oregon.
23:27:08 <LegendaryPenguin> is this a good way of accessing multiple sublists? map ($ x) [(!! 1), (!! 4), (!! 7)]
23:27:22 <dabblego>  map ($ x) = mapM
23:27:34 <Zao> <cue mandatory rant about how !! is evil>
23:27:46 <I_LIVE> c_wraith, what about semifinals?
23:27:48 <Cale> dabblego: what?
23:27:56 <c_wraith> LegendaryPenguin: do note Zao's mandatory rant. !! is O(k)
23:28:03 * Zao competed in NWERC.
23:28:24 <Axman6> LegendaryPenguin: map (x !!) [1,4,7]
23:28:44 <I_LIVE> many of java solutions contain code like: 	public int nextInt() throws Exception {	return Integer.parseInt(next());}
23:28:56 <LegendaryPenguin> oh, lol, that one is better
23:29:03 <dabblego> Cale, I was thinking ((->) t) monad
23:29:12 <I_LIVE> it's not 99% cases as you say, more like to 60%
23:29:53 * BMeph thinks it looks more like Cont t than ((->) t)...
23:30:03 <c_wraith> in any case, lines, words, and read should handle all the common parsing cases, and haskell does have printf...  So..  Where's the issue with IO in haskell?
23:30:19 <Cale> dabblego: Perhaps you were thinking of sequence
23:30:20 <copumpkin> omnom
23:30:40 <dabblego> Cale, yeah prolly
23:31:25 <c_wraith> :t liftM ($ x)
23:31:26 <lambdabot> forall b (m :: * -> *). (Monad m) => m (Expr -> b) -> m b
23:31:33 <c_wraith> err, right
23:31:39 <I_LIVE> how, for example, to read a line (with integer N in it), then N lines, and a number following it
23:31:43 <c_wraith> :t \x -> liftM ($ x)
23:31:44 <lambdabot> forall a b (m :: * -> *). (Monad m) => a -> m (a -> b) -> m b
23:31:53 <copumpkin> omg it's flip flip
23:32:01 <copumpkin> :t flip flip
23:32:02 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
23:32:16 <c_wraith> caleflip :)
23:32:37 <Axman6> wrongflip1
23:32:38 <Axman6> !*
23:33:24 <Cale> I_LIVE: do n <- readLn; xs <- replicateM n getLine; k <- readLn; doStuffWith n xs k
23:33:50 <BMeph> ...and Caleskell WINS again! :)
23:34:28 <Niccus> > flip flip 2 div 8
23:34:29 <lambdabot>   4
23:43:21 <lars9> hey, what is the simplest way to use muttable list?
23:43:33 <dmwit> The simplest way is "don't".
23:43:49 <Lemmih> lars9: MVar [List].
23:44:29 <lars9> I need to shuffle a list using knuth shuffle alg. it's not efficient if we copy the whole list everytime
23:44:40 <kmc_> that's not a mutable list
23:44:43 <dmwit> ?go provably correct shuffle oleg
23:44:43 <lambdabot> Maybe you meant: google googleit do
23:44:47 <dmwit> ?google provably correct shuffle oleg
23:44:48 <lambdabot> http://okmij.org/ftp/Haskell/perfect-shuffle.txt
23:44:51 <kmc_> that's a mutable cell which will over its lifetime hold different immutable lists
23:44:55 <dmwit> lars9: done
23:45:00 <kmc_> lars9, wouldn't "shuffle" imply some kind of random access?
23:45:16 <kmc_> lars9, you're aware that lists aren't arrays?
23:45:50 <LegendaryPenguin> are there any rotate list functions
23:46:04 <dmwit> Not built in.
23:46:10 <dmwit> There's transpose, but I doubt that's what you mean.
23:46:21 <kmc_> LegendaryPenguin, look in Data.List
23:46:38 <kmc_> splitAt might be a useful building block
23:46:53 <lars9> kmc_, Lemmih, dmwit: my problem is, shuffle :: [a] -> IO [a],
23:46:56 <kmc_> :t \n -> uncurry (flip (++)) . splitAt n
23:46:57 <lambdabot> forall a. Int -> [a] -> [a]
23:47:02 <LegendaryPenguin> i will just use cycle
23:47:04 <LegendaryPenguin> that will work
23:47:07 <kmc_> lars9, are you aware that lists aren't arrays and what that means?
23:47:33 <kmc> lists have bad performance for accessing or modifying an element by index
23:47:37 <lars9> kmc, i didn't get what you meant
23:47:43 <dmwit> lars9: I'm aware of your problem. I've even given you a solution, made out of whole cloth, with more comments around the code than you can shake a stick at, accompanied by a proof of correctness...
23:47:54 <kmc> lars9, haskell lists are immutable singly-linked lists
23:47:59 <kmc> reaching the nth element takes O(n) time
23:48:15 <kmc> i'm not exactly sure what you're trying to do but "shuffle" makes me think you want an array: a data structure with constant-time indexing
23:48:26 <kmc> lars9, the simplest mutable array to use would be IOArray
23:48:32 <kmc> see: http://www.haskell.org/ghc/docs/6.10-latest/html/libraries/array/Data-Array-MArray.html
23:48:34 <ivanm> there's a shuffle package on hackage that implements oleg's perfect shuffle function...
23:48:48 <dmwit> even better
23:48:56 <ivanm> @google haskell shuffle
23:48:56 <lambdabot> http://okmij.org/ftp/Haskell/perfect-shuffle.txt
23:49:03 <ivanm> lars9: ^^ have a read of that
23:49:13 <dmwit> I already tried linking him to that. =P
23:49:17 <c_wraith> lars9: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16865
23:49:24 <lars9> thanks everyone, a ton of links to read
23:49:29 <dmwit> ?hackage random-shuffle
23:49:29 <ivanm> oh...
23:49:30 <lambdabot> http://hackage.haskell.org/package/random-shuffle
23:49:34 <ivanm> lars9: Haskell /= C
23:49:40 <ivanm> stop trying to treat it as if it is
23:50:29 <kmc> though, programming with mutable arrays in the IO monad is closer to C
23:50:51 <ivanm> greetings Fallen_Demon
23:50:54 <kmc> if you really want to program C in Haskell you should use Foreign and Storable and such to get totally unsafe untyped memory buffers and do unsafe untyped pointer arithmetic to use them
23:51:44 <c_wraith> shuffle is an algorithm that seems to have no implementation using immutable data structures that's the same complexity as the obvious version with mutable data structures.
23:52:03 <I_LIVE> Cale, I forgot to mention that I need file i/o, not console
23:52:57 <solrize> c_wraith, it's usual to accept a factor of log(n) for functional data structures, e.g. Map vs. hash tables
23:53:18 <dmwit> I_LIVE: stick an 'h' in front of all the function names, then
23:53:24 <dmwit> hGetLine, hReadLn
23:53:40 <c_wraith> solrize: that seems to actually be true for only a very small set of algorithms.  Shuffle is one of them.
23:53:55 <Cale> Strangely hReadLn is an omission
23:54:03 <dmwit> ah
23:54:08 <solrize> hm?  shuffle in O(n log n) should be straightforward
23:54:10 <Cale> You can use fmap read hGetLine though
23:54:11 <dmwit> Well, it's easy enough to define, though.
23:54:47 <c_wraith> solrize: I mean that often times you can get the same complexity with immutable structures.  shuffle is one the small set of cases where you get a factor of log n worse
23:55:38 <solrize> hmm, i thought it was common
23:57:15 <lars9> which tutorial explains runST IOArray etc well?
23:57:37 <Fallen_Demon> ivanm, hey
23:57:53 <kmc> runST is used to make an ST monad action into a "pure" value
23:57:53 <kmc> if you don't need that ability to escape the monad, IO will be simpler
23:57:58 <kmc> i would just read the API docs, and ask here
23:58:12 <ivanm> Fallen_Demon: so you can't make it to AusHack for the Friday?
23:58:41 <kmc> i don't think RWH covers the mutable array interface
23:58:42 <kmc> it covers immutable arrays in Ch 12
23:59:03 <Fallen_Demon> ivanm, likely not
23:59:10 <ivanm> Fallen_Demon: :(
23:59:20 <lars9> kmc: thanks
23:59:30 <ivanm> Fallen_Demon: so, there goes the idea of asking you if you want to organise mass transport with myself, Axman6 and Axman6's girlfriend...
23:59:39 <ivanm> Fallen_Demon: OK, how about accommodation?
23:59:48 <ivanm> (since you didn't reply to my email to everyone...)
23:59:59 <Fallen_Demon> Ah, sorry ^^;
