00:00:12 <Fallen_Demon> Must've got swept up with mailing lists and stuff
00:00:22 <Fallen_Demon> I was just going to check into a youth hostel
00:00:31 <ivanm> Fallen_Demon: it isn't in the mailing list; I emailed everyone using the email address they had for registration
00:00:52 <ivanm> Fallen_Demon: right, I was asking to see who was planning on doing so in the hopes of getting a discount
00:01:04 <Fallen_Demon> Yeah, but I get a lot of stuff from other mailing lists
00:01:08 <ivanm> @ask chrisdone are there any examples of blogination usage lying around?
00:01:08 <lambdabot> Consider it noted.
00:01:13 <ivanm> Fallen_Demon: fair enough
00:01:24 <Fallen_Demon> So a ton of legitimate emails get swept into places they shouldn't
00:01:28 <ivanm> heh
00:01:34 <ivanm> that's why I use filters!
00:02:52 <ivanm> hamishmack: where were you planning on staying during AusHack?
00:03:34 <hamishmack> ivanm: Yes.
00:03:51 <ivanm> let me try that again
00:03:56 <ivanm> hamishmack: WHERE were you planning on staying during AusHack?
00:04:08 <ivanm> is that enough emphasis? want more? :p
00:05:51 <hamishmack> ivanm: I am not sure yet.  I may have my family in tow.
00:05:52 <dmead> @seen byorgey
00:05:52 <lambdabot> Unknown command, try @list
00:05:55 <dmead> @list
00:05:56 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
00:06:08 <ivanm> hamishmack: ahhh, fair enough
00:06:11 <ivanm> preflex: seen byorgey
00:06:11 <preflex>  byorgey was last seen on #haskell 2 days, 3 hours, 30 minutes and 31 seconds ago, saying: yeah, I've heard of DoCon but never tried it
00:06:14 <ivanm> dmead: @seen is no more!
00:06:20 <hamishmack> It is the second week of school holidays
00:06:24 <dmead> ah
00:06:36 <hamishmack> (the week before AusHac that is)
00:07:06 <ivanm> hamishmack: *nod*
00:07:30 <hamishmack> We are thinking of flying into Brisbane then making our way down to Sydney during the week
00:08:19 <I_LIVE> what linking error means: 1.o:fake:(.text+0x10e): undefined reference to `containerszm0zi2zi0zi0_DataziSet_fromList_closure'
00:09:03 <c_wraith> it means you should compile with --make
00:09:23 <c_wraith> it'd be nice if those errors suggested that.
00:09:29 <ivanm> hamishmack: cool
00:09:53 <ivanm> hamishmack: if you're driving, then plan on spending the night somewhere between brisbane and sydney
00:10:00 <ivanm> otherwise you have to start early and get there late
00:10:27 <ivanm> c_wraith: helpful error messages? are you _crazy_? :o
00:10:38 <c_wraith> yes, but how's that relevant? :)
00:10:46 <ivanm> heh
00:10:56 * ivanm goes off to use his new BBQ for the first time :D
00:11:09 <I_LIVE> thanks c_wraith
00:11:11 <ivanm> (I would have used the term "barbie" but I don't know how international that is)
00:11:17 <Veinor> c_wraith: why do you need to use --make anyway?
00:11:21 <hamishmack> ivanm: we will spend the weekend before with my relatives in Brisbane, then spend all week making our way down.
00:11:34 <hamishmack> assuming I can get time of work
00:11:35 <ivanm> hamishmack: all week driving? cool
00:11:40 <ivanm> inland or coast road?
00:11:42 <c_wraith> Veinor: I don't actually know.  I've just learned to do it. :)
00:11:52 <Veinor> darn.
00:12:23 <hamishmack> We'll take the kids to the beach etc. on the way.
00:12:41 <hamishmack> May go North first if we have time
00:13:14 <ivanm> hamishmack: noosa is nice, but takes 4 hrs at least to drive there from Brisbane
00:13:25 <ivanm> otherwise surfers, etc. is about an hours drive from brisbane
00:13:27 <dobblego> bollocks
00:13:47 <dobblego> noosa is 2 hours max
00:14:13 <ivanm> dobblego: you're on the north side though, aren't you?
00:14:23 <dobblego> 20 minutes north of Brisbane
00:14:40 <dobblego> BNE to Noosa is no more than 2 hours drive
00:14:41 <ivanm> (my family went there a few years back, and took us just under 4 hours to get to the hotel near the broadwalk or whatever they call it)
00:14:55 <dobblego> they obviously removed the spark plug leads first
00:15:00 <ivanm> dobblego: well, I lived on the southside, so I had to go through the city
00:15:16 <dobblego> I can do it in 85 minutes on my bike
00:15:22 <ivanm> and it depends on if there's another truck that's broken down on the bruce highway :p
00:15:36 <dobblego> if you're in a car
00:15:55 <hamishmack> Its got to be warmer than Wellington in the winter anyway.
00:15:59 <ivanm> exactly
00:16:16 <ivanm> hamishmack: still, I wouldn't swim in the ocean in July; it'll be cold
00:16:21 <ivanm> a heated pool maybe
00:17:40 <lars9> what happens if we make a method to espace from IO: IO a -> a?
00:18:16 <tensorpudding> unsafePerformIO
00:18:16 <ivanm> lars9: you get arrested
00:18:25 <ivanm> tensorpudding: shhhh!!! don't tell newbies about it!
00:18:32 <ivanm> then they'll start using it when they shouldn't!
00:18:32 <c_wraith> lars9: it doesn't necessarily do what you think it does.  But it exists.
00:18:36 * ivanm -> dinner
00:19:22 <lars9> cool to know it exists
00:19:23 <c_wraith> lars9: And you really should go out of your way to avoid using it when possible.
00:19:33 <c_wraith> But if you really need it, it's there
00:20:29 <lars9> c_wraith: i see, thanks. i just want to know if purity can be broken in haskell
00:20:38 <pastorn> lars9: i've been using haskell for ~3 1/2 years and i've never had any reason to use it yet
00:20:45 <kmc> lars9, Haskell normally has a strict separation between execution and evaluation
00:20:52 <c_wraith> there's also unsafeCoerce, for additional ways to shoot yourself in the foot. :)
00:20:54 <kmc> unsafePerformIO will break that
00:21:15 <pastorn> my favourite is unsafeInterleaveIO :: IO a -> IO a
00:21:15 <kmc> you have to be careful to avoid things like compiler optimizations that become incorrect with side-effecting evaluation
00:22:03 <c_wraith> at least unsafeInterleaveIO is easy to use correctly.  It can have horrible side effects, but it *does* do what you wanted. (You just may not realize how perverse what you want is)
00:22:05 <kmc> lars9, unsafePerformIO is used to implement some core libraries that have specialized requirements.  it's best seen as an alternative to extending the compiler
00:22:33 <Jafet> @hoogle trace
00:22:34 <lambdabot> Debug.Trace trace :: String -> a -> a
00:22:34 <lambdabot> Network.HTTP.Base TRACE :: RequestMethod
00:22:34 <lambdabot> module Debug.Trace
00:22:48 <lars9> kmc: i see, that means it's not for newbie
00:22:53 <lars9> kmc: isn't it?
00:22:55 <kmc> right
00:23:15 <kmc> you have to understand the operational details of how GHC (for example) happens to implement Haskell very precisely
00:23:19 <kmc> in order to use it correctly
00:23:24 <Jafet> @quote pikhq simon
00:23:24 <lambdabot> pikhq says: <kmc> you use simonSaysPerformIO to make it so <pikhq> Yes, but you should think long and hard before using it if you're not named Simon.
00:23:26 <pastorn> lars9: the only real reason i've heard to use it is to get performance boosts under certain conditions
00:23:40 <c_wraith> originally, unsafePerformIO came from the Foreign Function Interface, as a way to provide a foreign function that's actually pure with a pure interface
00:24:00 <kmc> yeah, what c_wraith said
00:24:12 <kmc> if you are C importing a function that needs some alloc or poke or whatever
00:24:20 <kmc> but you know that the overall result is a pure function
00:24:40 <pastorn> c_wraith: cool, didn't know that... was it always called unsafePerformIO?
00:25:25 <kulin> why is parsec monadic?
00:25:30 <kulin> why would they do this to me
00:25:36 <tensorpudding> unsafePerformIO . return
00:25:39 <ivanm> kulin: what's wrong with it being monadic?
00:25:55 <kulin> it parses a string, i dont see what side effects it could have
00:25:57 <pastorn> kulin: is it really that bad?
00:25:57 <ivanm> kulin: that's kind of the whole point of using a parsing combinator library, rather than traditional lexing + parsing
00:25:58 <kmc> kulin, because monads are a way of overloading what sequential operations mean
00:26:05 <ivanm> kulin: monadic /= has side effects
00:26:05 <kmc> kulin, monads are not about side effects
00:26:08 <kmc> kulin, only certain monads are
00:26:11 <pastorn> kulin: parsec is side effect free
00:26:14 <ivanm> kulin: monads just mean you can sequence them
00:26:19 <kmc> kulin, a monad is any type that has "do" notation
00:26:21 <ivanm> which you kind of want to do when parsing
00:26:21 <pastorn> wow, that's a lot of the same answer :)
00:26:23 <kmc> "do" notation is a useful way to write parsers
00:26:36 <ivanm> kulin: for it to have side effects, it needs to be in IO, ST, STM, etc.
00:26:43 <kmc> kulin, Maybe and lists are also monads, and they've got nothing to do with side effects
00:27:01 <kulin> still, ruins my life
00:27:09 <kmc> in fact it's best to forget that IO is a monad when you're learning what a monad in general is
00:27:09 <pastorn> no, it shouldn't
00:27:13 <kmc> kulin, what interface would you prefer
00:27:17 <pastorn> kulin: what are you working on?
00:27:25 <tensorpudding> Maybe is the boringest non-trivial monad
00:27:25 <kulin> now i need to learn how to quickcheck monads
00:27:36 <kmc> kulin, no, because you can run the parser
00:27:37 <ivanm> kulin: you need to have some way of saying "parse the string using this parser, and then parse the rest using the next parser"
00:27:43 <ivanm> that's exactly what monads give you
00:27:45 <kmc> you can turn a parsec monad action into a function of type String -> Either ParseError YourType
00:27:47 <kmc> just check that
00:27:52 <lars9> in C, we can make a pure function with some local variables inside, sometimes the local vars are important to make the function efficient. I found those local vars can only be implemented using mutable vars in haskell, which is an advanced concept and hard for newbie, right?
00:28:00 <ivanm> tensorpudding: where "trivial" == the Identity monad?
00:28:13 <kmc> lars9, as a newbie you should probably avoid mutation, yes
00:28:18 <pastorn> lars9: use where-clauses
00:28:22 <ivanm> kulin: you quickcheck parsec values, not monads
00:28:26 <pastorn> and  'let'
00:28:33 <kmc> lars9, that said, if you have an algorithm that absolutely needs mutation internally, but presents an immutable interface, you can use the ST monad for that
00:28:38 <kmc> (ST monad not to be confused with State monad)
00:28:43 <ivanm> and by "values", I mean individual combinators (or conglomerates of them)
00:29:05 <kmc> ivanm, the constant monad is more trivial
00:29:08 <Jafet> Hm, how do you get haddock docs with cabal-install?
00:29:22 <ivanm> kmc: oh? what's that?
00:29:22 <kmc> data K a = K; return _ = K; _ >>= _ = K
00:29:31 <kmc> satisfies all the laws!
00:29:33 <pastorn> kulin: have you written any parser code yet?
00:29:33 <ivanm> Jafet: check ~/.cabal/config ; one of the options is for documentation
00:29:39 <kulin> no pastorn
00:29:39 <ivanm> Jafet: or else: cabal haddock <foo>
00:29:47 <Jafet> Okay
00:29:52 <kulin> i start with checks, then work backwards
00:29:53 <lars9> kmc: im not familiar with ST yet, let me read more
00:29:54 <ivanm> kulin: have a read through the RWH chapter on parsec
00:29:58 <kmc> kulin, you may prefer the Applicative interface to Parsec over the monadic interface
00:30:11 <ivanm> kulin: in Haskell, we treat our type signatures as our initial checks most of the time :p
00:30:19 <ivanm> lars9: I wouldn't bother until you need it
00:30:30 <pastorn> kulin: if you want to understand wtf is going on with parsec, read this: http://eprints.nottingham.ac.uk/archive/00000223/01/pearl.pdf
00:30:36 <kmc> kulin, then write your checks in terms of the overall String -> Either ParseError YourType
00:30:41 <Jafet> I wonder why it's False by default
00:31:22 <pastorn> lars9: ST can be used of O(1) writing to arrays
00:31:26 <ivanm> Jafet: to minimise build time and disk space is my guess
00:31:39 <ivanm> Jafet: the defaults are aimed at people that just want to install and use pandoc, etc.
00:32:01 <lars9> pastorn: to what array? IOArray?
00:32:08 <pastorn> STArray
00:32:09 <kulin> alright, ill read the rwh chapter and the pdf and use either, i had not thought to use that to test monadic code before
00:32:18 <Jafet> ...and are connected to internet all the time, I guess
00:32:22 <kulin> thanks
00:32:39 <ivanm> pastorn: do you teach kids how to swim by throwing them in the deep end and seeing how they go? :p
00:32:39 <pastorn> kulin: use parsec
00:32:45 <lars9> what's the difference between STArray and IOArray?
00:32:49 <ivanm> kulin: you're not testing monadic code
00:32:49 <pastorn> the paper is for understanding
00:32:54 <ivanm> kulin: you're testing a parsec parser
00:32:58 <ivanm> to do so, just run the parser
00:33:00 <Jafet> Er nevermind, the source contains the haddock comments
00:33:06 <ivanm> oh, and use polyparse instead, it's simpler! :p
00:33:06 <pastorn> lars9: STArray is 'safer'
00:33:15 <pastorn> lars9: or something... i don't really know
00:34:50 <dmead> is anyone else going to hac phi?
00:34:50 <kmc> lars9, you can't (safely) turn an IO action into a "pure" value
00:34:59 <pastorn> ivanm: also, that paper isn't hard until you reach page 8
00:35:00 <kmc> lars9, but you can turn an ST action into a "pure" value using:
00:35:02 <kmc> :t runST
00:35:03 <lambdabot> forall a. (forall s. ST s a) -> a
00:35:18 <kmc> lars9, which uses the type system to ensure that your references don't "leak out"
00:35:39 <pastorn> ivanm: sorry, page 6 (chain)
00:35:42 <kmc> lars9, so it's good for using mutation to efficiently implement something that's semantically a pure function
00:36:00 <kmc> and unlike unsafePerformIO, you have no extra obligation to understand implementation details when using runST
00:36:08 <lars9> kmc: cool, i see. and both are instance of MArray?
00:36:08 <kmc> if it type checks, your use is guaranteed safe
00:36:10 <kmc> (unless you use other unsafe stuff, of course)
00:36:19 <kmc> lars9, yes
00:36:33 <ivanm> pastorn: I was referring to you telling lars9 to use STArray!
00:36:34 <kmc> ST also has STRefs which are mutable reference cells like IO's IORefs
00:37:01 <pastorn> ivanm: hehe... he seems to know his C, he can handle it ;)
00:37:05 <lars9> kmc: cool, your explanation clarifies a lot for me
00:37:16 <pastorn> ivanm: ^^^^
00:37:30 <ivanm> *shrug* I'm talking about throwing too many new Haskell concepts at him
00:37:49 <pastorn> lars9: for most of your code you'll be using normal lists and Data.Map
00:37:59 <kmc> :)
00:38:14 <ski> kmc :   return _|_ >>= (`seq` K)  =  K  =/=  _|_  =  (`seq` K) _|_
00:38:16 <pastorn> lars9: if you're using arrays in haskell it's premature optimization
00:38:20 <ski> kmc : so it fails that monad law
00:38:36 <ski> (however, you might say that doesn't "count", because that uses `seq')
00:39:10 <ski>   return _|_ >>= (\() -> K)  =  K  =/=  _|_  =  (\() -> K) _|_
00:39:18 <ski> is however an example not using `seq'
00:41:57 <ski> lars9 : the difference is really that `STArray s' is "bound" to a specific `ST'-state-thread (by the `s' type variable), while all `IOArray's are "bound" to the single `IO'-state-thread (ignoring concurrency, for the moment)
00:42:44 <pastorn> ivanm: now THAT'S what i call going too far for the newbz ^^^
00:43:02 <ivanm> heh
00:43:23 <ski> lars9 : so, to a first approximation, accesses to different `IOArray's must be totally ordered wrt each other, while for `STArray's in different `ST'-threads, there is no inherent ordering (while there is one *within* each `ST'-thread)
00:44:05 <ski> lars9 : now, with `unsafeInterleaveIO' and `unsafeInterleaveST', you can still remove bits of ordering .. and with `IO' you can use concurrency, too
00:44:40 <lars9> ski: i see, so ST is more strict than IO?
00:45:01 <c_wraith> ST certainly permits less
00:45:21 <ski> what do you mean by "strict" here ? (it has a technical meaning that i'm not sure if you are referring to ..)
00:45:39 <kmc> it should be noted that "ST-threads" are not concurrent execution threads
00:45:53 <ski> yes, good point
00:45:54 <kmc> they are more like closed "universes" of state
00:46:28 <ski> "thread" here should be thought of as passing a series of state versions/values through an argument of a recursive function
00:47:15 <I_LIVE> I'm trying to modify this: http://www.haskell.org/haskellwiki/Tutorials/Programming_Haskell/String_IO (example 6) to write in file
00:47:22 <ski> (also, passing it in and out (e.g. using `State' or `StateT', but also `ST') of not necessarily recursive functions, thereby "threading" the state through (parts of) your program)
00:47:30 <I_LIVE> this doesn't compile: writeFile "moo" $ Data.Set.map (spell dict) (words g)
00:48:01 <c_wraith> :t writeFile
00:48:02 <lambdabot> FilePath -> String -> IO ()
00:48:04 <Axman6> :t writeFile
00:48:05 <lambdabot> FilePath -> String -> IO ()
00:48:06 <Axman6> bah
00:48:20 <Axman6> :t Set.map
00:48:21 <lambdabot> Couldn't find qualified module.
00:48:23 <c_wraith> The second argument needs to be a String, and that's not what you're providing
00:48:25 <Axman6> :t Data.Set.map
00:48:26 <lambdabot> forall a b. (Ord a, Ord b) => (a -> b) -> S.Set a -> S.Set b
00:48:35 <ski> for `unsafeInterleaveST' you should make sure that the action you are passing to it really doesn't interact state-wise with the "rest of the `ST'-computation" .. i.e. that the parts of the state read or modified by the action and the rest are disjoint
00:48:37 <dv-> :t show
00:48:38 <lambdabot> forall a. (Show a) => a -> String
00:49:09 <ski> i'd like to say that that's how `unsafeInterleaveIO' should be used, too .. but i'm not sure how much this conforms with common practice
00:49:42 <c_wraith> sadly, unsafeInterleaveIO is mostly used with lazy IO, where it does conflict with things like file handle state
00:49:43 <ski> .. maybe this is a possible source of the common complaints about `unsafeInterleaveIO' ?
00:50:26 <c_wraith> hGetContents followed by hClose probably doesn't do what you think it should, for instance
00:50:36 <ski> maybe `unsafeInterleaveIO' should be split into two functions, one which should only be used with the same caveats as `unsafeInterleaveST'
00:51:05 <ski> while the other would allow such use, which would thereby invoke the usual (demonic) nondeterminism
00:51:08 <ski> ?
00:51:33 <c_wraith> seems difficult to enforce at the type level...
00:52:17 <c_wraith> Or by giving actual different semantics to the two theoretical functions
00:52:27 <ski> c_wraith : well, re `hGetContents', one should never pass a handle that's been passed to `hGetContents' also to `hClose'; simple as that
00:52:45 <c_wraith> ski: that's true.  But also sometimes false :)
00:53:06 <c_wraith> really, you shouldn't use hGetContents in anything real ;)
00:53:31 <ski> c_wraith : of course, the constraint above is difficult to enforce at the type level .. which is what warrants the "unsafe" prefix (though i'd like to rename it to "promiseSafe" or something like that)
00:54:09 <ski> c_wraith : i'm not sure i would go that far :)
00:54:12 <c_wraith> basically, hGetContents can be a handle leak if the operations you perform on the result string never force the [] at the end.
00:54:21 <ski> certainly, it is often over-used / mis-used
00:55:28 <ski> ("giving actual different semantics to the two theoretical functions" ?)
00:57:23 <ski> c_wraith : ^
00:57:35 <I_LIVE> irc is crap
00:57:45 <Veinor> whee, netsplit
00:58:04 <ski> I_LIVE : maybe use a better client ?
00:58:16 <I_LIVE> why
00:58:20 <ski> (but yes, the IRC protocol has bugs)
00:58:23 <c_wraith> ski: oh, if you split unsafeInterleaveIO into two different functions, would they actually have different functionality?
00:58:29 <I_LIVE> it's not bug
00:58:31 <I_LIVE> it's a feature
00:58:55 <ski> c_wraith : on the intersection of the cases where both could be used, they would have same semantics
00:59:27 <ski> maybe the more restrictive one could be implemented more efficiently (since the compiler can assume you don't do as much strange things), i don't know
01:00:37 <ski> c_wraith : hm, could you elaborate on what you meant by "lazy IO, where it does conflict with things like file handle state" ?
01:01:11 <c_wraith> ski: I did give an example.  hGetContents and hClose share state.
01:01:45 <c_wraith> though any of the h* functions would apply
01:01:48 <ski> (is that "conflict" as in my previous "state accessed by action is disjoint from state accessed by rest" or other ?)
01:07:36 <ski> c_wraith : i'm still not sure why you say `hGetContents' and `hClose' share state
01:07:41 <ski> which state is shared ?
01:08:27 <kmc> the handle?
01:08:41 <ski> (if you cann `hClose', then you pass the handle to it, so it can't be the handle you're talking about .. and the state the handle refers to should be unaffected if `hClose' is called on another handle, so it can't be that state either)
01:08:56 <ski> (s/cann/call/)
01:14:38 <augur> ski!
01:14:51 <ski> hi there
01:14:55 <augur> hey
01:15:00 <augur> you know of Iota
01:15:00 <augur> ?
01:15:09 <ski> not sure
01:15:14 <augur> the esolan
01:15:16 <augur> g
01:15:29 <ski> is it a variant of Unlambda and Lazy-K ?
01:15:43 <augur> ehhhh
01:15:55 <augur> its a two-command tarpit
01:16:03 <augur> really, on command one nesting operator
01:16:16 <augur> * which is like lazy-k's `
01:16:23 <augur> and i which is, apparently, \x.xSK
01:16:46 <ski> ok, a variant of Unlambda and Lazy-K, then ;)
01:16:57 <augur> anyway, the guy who invented it is a linguist -- a semanticist -- who works at NYU
01:17:05 <augur> we're trying to get him to come talk at UMD next semester
01:17:13 <augur> if we get him, any questions you want asked?
01:17:28 <ski> (iirc, `\x.SK' is one popular choice of an "`X'-combinator", one which can express every combinator (together with application))
01:17:46 <ski> where is UMD ?
01:18:10 <Adamant> in Maryland
01:18:11 <ski> (er, `\x. x S K', rather .. as you said)
01:18:22 <Adamant> I presume the College Park branch
01:18:38 <ski> i'm not sure .. ia haven't really thought very much about combinator "calculi" in a long time
01:18:52 <ski> augur : why do you ask ?
01:19:21 <augur> Adamant: correct
01:19:44 <Adamant> augur: do I get a cookie and some NSA decrypts?
01:19:45 <augur> i ask just cause we might have him here, and i'd enjoy surprising him with some esolangosity
01:19:51 <augur> Adamant: no, NSA is in Laurel.
01:20:15 <augur> you can have CASL decrypts tho!
01:20:18 <Adamant> augur: yeah, but I was under the impression they had a lot of spooky people being educated at UMD-College Park
01:20:29 <augur> yeah but they all work at CASL
01:20:32 <augur> at least if theyre linguists
01:20:32 * ski is not sure what interesting questions one might ask ..
01:20:46 <augur> ski: god only knows! it doesnt have to be iota-related, it could be anything
01:20:49 <ski> it depends of course on what he's interested in
01:21:04 <augur> well hes interested in continuations in natural language, and minimalist programming languages
01:21:05 <augur> obviously
01:21:06 <augur> god
01:21:07 <ski> e.g. can one make a combinatory *logic* programming language ?
01:21:07 <augur> :|
01:21:38 <ski> (sortof like Curry (or was it Church) was originally thinking ?)
01:22:08 <ski> hm, maybe i should ask what this person is named ..
01:24:18 <augur> fuck, im so drunk x.x
01:24:37 <augur> oh, he's also researched the import that monads have in natural language
01:24:43 <augur> just, you know, to keep it on topic
01:24:45 <ski> augur : go read about sober spaces ?
01:24:59 <augur> i'd sober your space
01:25:03 <augur> if you know what i mean ;o
01:25:11 <ski> <http://en.wikipedia.org/wiki/Sober_space>
01:25:31 <augur> D:
01:25:41 <ski> (augur : and i'd still like to know what name this person has ..)
01:25:50 <augur> oh, sorry
01:25:53 <augur> Chris Barker
01:25:57 <augur> http://homepages.nyu.edu/~cb125/
01:26:17 <augur> or maybe it was shan who's done the monads in natlang stuff
01:26:19 <augur> whatever
01:26:34 <Jafet> ski, unlambda?
01:26:36 <ski> (augur : and btw, i think continuations in NatLangs is enough topic-ness for #haskell .. though monads in NatLang works too, of course)
01:26:46 <ski> Jafet : what about it ?
01:26:54 <Jafet> Combinatory logic
01:26:55 <augur> yeah but monads are super haskellian
01:27:23 <ski> Jafet : i was thinking of something (whose implementation) would use logic variables, backtracking, &c. ..
01:27:41 <Jafet> Hrm, nondeterministic combinators
01:27:51 <Jafet> Don't know any
01:28:45 <ski> (well, you could do bottom-up / forward-reasoning instead of top-down / backward-reasoning .. i'm not picky .. and you don't really have to use logic variables, either, you could "try all substitutions", or maybe use "nondeterministic terms")
01:29:49 <ski> augur : ok, Chris Barker :)
01:30:18 <augur> yes, chris barker
01:30:22 <augur> anyway, im off to bed
01:30:25 <augur> im wayyyy to drun
01:30:26 <augur> k
01:30:31 <augur> ill see you in a few hours
01:30:33 <augur> maybe 12
01:30:34 <augur> XO
01:30:35 <augur> XP
01:30:36 <ski> (just noting that i recognize that name)
01:30:36 <augur> even
01:30:40 <augur> x.x night
01:30:42 <Gracenotes> XOXOXO
01:30:43 <ski> night
01:30:47 <augur> <3
01:30:54 <Gracenotes> night augur :x
01:32:19 <ski> c_wraith : anyway, ty for making me realize that one could apply the same restriction to `unsafeInterleaveIO' that one ought to use with `unsafeInterleaveST', and the succedent idea of separating this restricted use of `unsafeInterleaveIO' with more general (nondeterministic) uses of it
01:32:28 <ski> ("you learn something new everyday")
01:51:03 <ski> hm .. regarding partial (recursive/computable) functions and expressions
01:52:07 <ski> it seems like there's an interesting distinction between
01:52:08 <ski> (a) a function/expression that is partial because there (for some inputs / values of variables) there is no possible output
01:52:37 <ski> (b) a function/expression that is partial because there (for some inputs / values of variables) is too *many* possible outputs (i.e. not unique output)
01:53:30 <ski> e.g. in haskell `x = x' and `div 0 0' would be an example of the latter, while `div 1 0' would be an example of the former
01:53:58 <ski> what i'm wondering is : what is the appropriate terminology to distinguish between these two cases ?
01:54:46 <ski> (obviously, some functions could fall under both (a) and (b))
01:58:37 <ski> (and "possible output" should usually be interpreted wrt some specific semantics for the function .. just outputting any value in the result type is usually not that useful .. and is sometimes not even possible)
02:04:36 <kamatsu> why do we seem to view fundeps as out of vogue?
02:04:50 <ivanm> kamatsu: because we have associated types instead!
02:05:00 <ivanm> and IMHO fundeps are ugly :s
02:05:02 <kmc> asstypes
02:05:32 <kmc> asstypes are clearer and more direct
02:05:41 <BMeph> Get some! ;þ
02:05:47 <kmc> there might still be some remaining use cases for fundeps
02:05:52 <kmc> but i don't know of a specific one
02:06:06 <Axman6> mmmhmmm, gotta get me some asstypes
02:06:08 <kmc> fundeps lead to a proliferation of parameters and type variables
02:06:12 <kmc> i'd hit that asstype
02:06:50 <lars9> what's the diff between Int and Integer?
02:07:01 <opqdonut> Integer is unbounded
02:07:03 <kmc> Int is machine size
02:07:11 <opqdonut> > 2^^1000 :: Integer
02:07:11 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Integer.Internals.Integer)
02:07:12 <lambdabot>    aris...
02:07:13 <ivanm> opqdonut: well, it is, by the size of your RAM...
02:07:18 <opqdonut> > 2^1000 :: Integer
02:07:19 <lambdabot>   107150860718626732094842504906000181056140481170553360744375038837035105112...
02:07:22 <opqdonut> > 2^1000 :: Int
02:07:23 <Axman6> > 2^65 :: Int
02:07:23 <lambdabot>   0
02:07:24 <lambdabot>   0
02:07:26 <lars9> cool...
02:07:27 <kmc> there's actually a harder bound than that
02:07:28 <Axman6> > 2^65 :: Integer
02:07:29 <lambdabot>   36893488147419103232
02:07:29 <kmc> but yes
02:07:34 <opqdonut> ivanm: unbounded by design
02:07:36 <ivanm> > 10^(10^100)
02:07:37 <Axman6> > 2^65536 :: Integer
02:07:38 <lambdabot>   200352993040684646497907235156025575044782547556975141926501697371089405955...
02:07:41 <lambdabot>   mueval: ExitFailure 1
02:07:44 <kmc> in particular it's unBounded
02:07:53 <ivanm> awwwww.... lambdabot couldn't express a googleplex
02:07:58 <ivanm> *googelplex
02:08:01 <kmc> lars9, using Int over Integer is usually premature optimization; however it's done a lot in the std lib :/
02:08:03 <ivanm> however it's spelt
02:08:12 <pippijn> googolplex
02:08:18 <opqdonut> kmc: the length of the Integer is expressed as a machine word or something, right?
02:08:18 <ivanm> thta's the one
02:08:22 <kmc> yeah opqdonut
02:08:29 <lars9> thanks
02:08:33 * BMeph yaps that asstype
02:08:35 <Axman6> @src Integer
02:08:35 <ivanm> kmc: well, IIRC it's only an implementation specific to ghc that Integer uses Int for Int-sized values
02:08:35 <lambdabot> data Integer = S# Int#
02:08:36 <lambdabot>              | J# Int# ByteArray#
02:08:37 <opqdonut> I was kinda disappointed when I found that out :)
02:08:46 * BMeph taps it, too
02:08:50 <kmc> yeah, it should be recursive
02:08:54 <opqdonut> yappity yap
02:08:59 <kmc> data Integer = S# Int | J# Integer ByteArray#
02:09:00 <ivanm> Axman6: yes, but is that in the report or only GHC?
02:09:07 <opqdonut> type Integer = Nat
02:09:10 <opqdonut> ;)
02:09:15 <ivanm> also, if you need Storable, etc. then you can't use Integer
02:09:23 <ivanm> opqdonut: Nat doesn't allow negatives; Integer does
02:09:23 <kmc> you could write your own instance
02:09:29 <kmc> but Storable assumes fixed size
02:09:34 <ivanm> exactly
02:09:41 <opqdonut> ivanm: ah, yeah
02:09:54 <opqdonut> well whatever the canonical name for signed Nat is then
02:14:04 <lars9> what is Ix short for, Index?
02:14:13 <kmc> yeah
02:14:20 <kmc> type class of types that can be used as Array indices
02:14:55 <lars9> cool
02:15:45 <lars9> kmc: hey do you know how to filter those join/quit channel message?
02:15:53 * BMeph thought IX was short for nine... ;þ
02:15:56 <kmc> that'd be a client option
02:16:21 <lars9> kmc: o i thought that's some irc command
02:18:16 <arcatan> lars9: if you're running irssi, see /help ignore
02:18:56 <ivanm> opqdonut: that would be integers
02:19:33 <lars9> arcatan: thanks
02:19:56 <opqdonut> ivanm: yeah, but I said Nat (meaning data Nat = Z | S Nat) and not naturals
02:20:20 <ivanm> opqdonut: oh, you mean church numerals?
02:20:32 <ivanm> IIRC oleg has an implementation of church numerals that allow for negatives
02:20:37 <opqdonut> yeah
02:21:02 <opqdonut> I was replying to kmc saying that Integer should be recursive
02:21:30 <ivanm> ahhh
02:21:38 <ivanm> there is a Natural type that is defined like that
02:21:44 <ivanm> copumpkin loves it
02:23:50 <kmc> it's fun because (genericLength [1..] > (5 :: Natural)) == True
02:25:46 <BMeph> True, and decidable in ginite time... ;)
02:25:53 <BMeph> *finite
02:29:09 <opqdonut> [1..] `isLongerThan` repeat 5 ()
02:32:06 <FunctorSalad_> signed ints should just be pairs... proving stuff with Integer = N Nat | Z | P Nat is awful
02:32:48 <FunctorSalad_> (pairs like it's done traditionally)
02:34:57 <harlekin> @pl (\s -> f =<< g s)
02:34:57 <lambdabot> (f =<<) . g
02:35:33 <harlekin> @pl (f . g . h =<<) . k
02:35:33 <lambdabot> (f . g . h =<<) . k
02:38:46 <hpaste>  cgopeusoyx (cgopeusoyx)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24926
02:39:14 * FunctorSalad_ wonders how expensive Integer is as long as you stay in that S# ctor...
02:43:12 <FunctorSalad_> I should finally read up on how ghc does ADTs
02:43:51 <FunctorSalad_> just learned by diffusion here that it does a variant of church encoding ;)
02:44:20 <FunctorSalad_> with no manifest tags for the disjunction
02:44:47 <lars9> how to convert STArray to a list?
02:46:11 <kmc> FunctorSalad_, don't think that's accurate
02:46:25 <kmc> FunctorSalad_, did you read the STG machine paper?
02:46:43 <kmc> it discusses a couple conventions
02:47:03 <FunctorSalad_> kmc: no :( it's the one I thought I should read
02:47:09 <kmc> yeah, it's a great paper
02:47:10 <olsner_> I think it's kind of special in this case since S# is unboxed (right?)
02:47:59 <FunctorSalad_> kmc: it doesn't do such encoding at all? or just like olsner_ said?
02:48:22 <kmc> i suppose it is a little like church encoding
02:48:32 <kmc> with an abnormal calling convention
02:48:44 <kmc> everything in the heap is a closure, with a code entry point
02:49:40 <olsner_> what I've read is that boxed types usually reuse bits of the pointer-to-contained-thunk to say which type constructor is containing that thunk (and if that pointer points to a function that does evaluation rather than a value)
02:49:51 <kmc> yeah
02:49:58 <kmc> but that's an optimization introduced after the STG machine paper
02:50:06 <kmc> and in fact makes it not tagless
02:50:30 <kmc> the idea is that you can case on an ADT with only a few constructors without having to enter its closure at all
02:51:29 <olsner_> ... and it's only applicable when the number of constructors is lower than the heap alignment in bytes (minus at least one for unevaluated-thunk)
02:51:49 <kmc> yeah
02:52:50 <kmc> FunctorSalad_, the basic convention is that an ADT already in whnf is a piece of code which simply: a) assigns a tag value into a global register, b) pushes its fields onto the stack, c) pops and jumps the top continuation off of a "continuation stack"
02:53:04 <olsner_> I think I should also read the STG paper! I know I did once before, but then I didn't know haskell half as well so I didn't understand a lot...
02:53:19 <kmc> there is an optimization called "vectored returns" where that continuation has one code ptr per tag, and instead of setting the global tag register it just jumps to the appropriate one
02:53:25 <kmc> iirc, that was implemented in ghc and later removed
02:53:58 <kmc> anyway, one of the original insights of the STG paper was this "data is code" representation
02:54:00 <olsner_> hmm, kind of like run-time constructor specialization or something?
02:54:19 <FunctorSalad_> kmc: ok, for some reason I had the picture in mind that the ADTs are represented as their folds...
02:54:31 <kmc> meaning the user doesn't need to know whether something is a thunk. you ask it to evaluate itself, and if it's already in whnf then it will just return immediately
02:55:00 <kmc> and if it's not, and it's marked as an "updatable closure", then before returning it will overwrite itself with the result of evaluation
02:55:09 <olsner_> FunctorSalad_: it is, the issue is how the fold is implemented? :)
02:55:15 <kmc> hehe
02:55:40 <FunctorSalad_> olsner_: hmm, you use the value by passing it n pointers, where n = number of constructors?
02:55:52 <FunctorSalad_> and it picks one and calls it
02:56:09 <kmc> this is like the vectored returns convention
02:56:28 <kmc> i know i read the STG paper at least twice while i was learning haskell and did not understand much of it
02:56:32 <kmc> and had to come back years later to really get it
02:56:57 <olsner_> FunctorSalad_: I mean - that may not be what actually happens, but whatever happens can be seen as a simulation of that
02:57:41 <arcatan> what's RWS monad?
02:57:51 <FunctorSalad_> ReaderWriterState
02:57:58 <kmc> once you do really get it, you can write a compiler from a very austere Haskell-like language (something like Core) to real C or LLVM code
02:58:09 <kmc> it is nicely self-contained like that
02:58:14 <arcatan> ah.
02:58:31 <olsner_> I don't like how that implies that looking at a value is always a function call, I expected the magic to be more efficient
02:58:56 <kmc> that's what strictness analysis and unboxed values are for
02:59:32 <kmc> the STG paper also explains GHC's treatment of primitive unboxed values
02:59:37 <kmc> which i think is still substantially accurate
03:00:40 <kmc> it has the nice property that all lazy values are algebraic
03:00:44 <kmc> and evaluation is only forced by "case"
03:01:16 <kmc> actually the STG paper clarified my thinking about Haskell too -- seeing "let" as the fundamental source of laziness, and "case" as the fundamental source of strictness
03:01:18 <kmc> deep, man
03:01:24 <kmc> sleep, ttyl all
03:01:54 <shay> cya
03:02:25 <olsner_> btw, the STG paper == peyton-jones' "Implementing lazy functional languages on stock hardware" paper from 1992?
03:03:44 <FunctorSalad_> cya
03:11:09 <int-e> olsner_: I think so. At least that's what I call the STG paper.
03:14:07 <hpaste>  . (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24927
03:16:18 <olsner_> heh, the paper speaks of exploring the design space to *locate* the STG machine... evokes a nice image: it has always been out there in the design space but not located until SPJ ventured out and found it
03:24:42 <arcatan> Can I have binary literals in Haskell?
03:27:55 <Jafet> arcatan, sure.
03:28:08 <Jafet> Well, they're not strictly literals...
03:29:53 <Jafet> > let binary 0 = 0; binary n = if n < 0 then negate (binary n) else binary (div n 10) * 2 + mod n 10; in binary 101010
03:29:54 <lambdabot>   42
03:30:06 <kulin> parsec isnt so bad after all, got it working!
03:30:45 <c_wraith> kulin: being monadic just means it works the way you think it should. :)
03:30:57 <olsner_> I would like a coparsec that has commit instead of try
03:45:49 <I_LIVE> How cow. I made it.
03:46:02 <I_LIVE> s/How/Holy/
03:53:54 <I_LIVE> in pascal or c/c++, it is possible to redirect stdio streams to use file io. thus it is possible to convert program using console io to one which uses file io just adding 2 lines
03:53:59 <I_LIVE> is this possible in haskell?
03:55:50 <ivanm> I_LIVE: possibly, but it's not something you should do
03:56:08 <ivanm> let the end users redirect the stdout and stderr if they want to at the command line
03:56:39 <Jafet> Write code parametrized on file handles
03:56:51 <zygoloid> I_LIVE: you can call dup2 via FFI if you want
03:57:05 <I_LIVE> ops
03:58:10 <I_LIVE> Jafet, just like using FILE *in = condition ? fopen("file","r") : stdin;  in C?
03:58:41 <Jafet> It's a strange imperative concept in any case, changing a value here causes a change in behaviour there
03:58:54 <zygoloid> basically what you're asking for is global variables in disguise
03:59:13 <Ke> o_O
03:59:18 <I_LIVE> why
03:59:34 <I_LIVE> I'm not going to change i/o handle AFTER my program started
03:59:36 <litb> hello folks
03:59:38 <Ke> I don't think there is any sense being manufactured here
03:59:52 <litb> how was that haskell emacs clone called?
04:00:00 <zygoloid> litb: yi?
04:00:07 <litb> ah thanks mate
04:00:26 <litb> is it true that learnng ocaml before haskell is easier to get into haskell from an imperative background?
04:01:16 <Ke> declarative/functional is trivial lazy is painful
04:01:23 <Ke> +,
04:01:31 <monadic_kid> o_0
04:01:49 <litb> so you mean ocaml since it'snot lazy is easier to start with?
04:02:16 <olsner_> I think laziness makes functional more declarative since you get rid of a bunch of operational considerations
04:02:17 <Ke> no idea about that
04:02:36 <Ke> olsner_: perhaps a bit
04:02:42 <olsner_> and humans (arguably) think in a more declarative manner than either of functional or imperative
04:03:00 <Ke> yes
04:04:04 <monadic_kid> litb: I would just start with Haskell, if you feel it's to much then start with SML I think it's a better choice (ocaml and SML are part of the same family of ML languages)
04:04:57 <litb> oh
04:08:42 <litb> dons, i spotted you acting on SO.
04:11:55 <mercury^> olsner_: one might argue that laziness adds operational considerations.
04:12:21 <Jafet> But you can be lazy and not consider them
04:13:02 <mercury^> If you don't care about your program needing reasonable resources, yes.
04:13:24 <olsner_> yeah, when I said that you get rid of a bunch, I neglected to mention that you get a bunch of new ones :)
04:14:23 <olsner_> it feels like the new ones are less significant and are mostly useful for optimization, but I'm biased since I like haskell
04:15:13 <Jafet> If you program lazily in a lazy language, by the time you get around to releasing the code computers will be powerful enough to run it
04:15:19 <c_wraith> is there any way to have a lexically scoped type variable?
04:15:26 <mercury^> In a strict language, you can write less, but what you write will always behave as you expect it to. In a non-strict language you can write more, but you have to be careful about performance all the time.
04:17:06 <c_wraith> that is, I want "a" in a type signature on one line to be the same type as the explicitly named "a" in a parent scope.
04:17:22 <c_wraith> I don't want a rigid type variable, I want to say "whatever that is, the same thing"
04:17:40 <jlouis> c_wraith: shot in the dark: Type families, GADTs
04:18:34 <c_wraith> No, less than that.  I think the ScopedTypeVariables extension does what I want somehow, I just don't know how.
04:19:15 <olsner_> nah, the usual approach to performance applies just as well to haskell I think - don't optimize until you need to and when you do, make sure that you optimize the right thing
04:19:44 <olsner_> constantly being "careful about performance" seems like it really means to constantly apply superstition to do premature optimization
04:19:47 <Jafet> Is there a library function equivalent to \f -> reverse.f.reverse?
04:19:52 <jlouis> olsner_: that was indeed the approach I took with combinatorrent. And it is seems to work quite well
04:20:22 <Jafet> Basically, do something to a list from behind.
04:20:37 <jlouis> since the heap profiler can do retainer-profiling and is wickedly powerful, you can easily narrow down the culprit of a space leak
04:21:05 <Oejet> I've just installed SDL with "cabal install SDL". Now, when I try to configure a program "runhaskell Setup.hs configure", I get: "Setup.hs: At least the following dependencies are missing: SDL -any". What is going on?
04:21:37 <Jafet> Oejet, do you run cabal as root?
04:21:58 <jlouis> runhaskell Setup.hs configure --user perhaps
04:21:58 <Oejet> Jafet: No, as local user.
04:22:00 <c_wraith> I just want to say "array <- newListArray (0, upper) ls :: ST s (STArray s Int a)" in a function that has accepts ls as an argument, and explicitly says the type of ls is [a].  That is, I want that a to refer to the outer scope a, not to be a rigid type variable
04:22:06 <Jafet> Then what jlouis said
04:22:40 <c_wraith> sadly, because of how I'm using the STArray, its type can't be inferred, so it can't figure out which newListArray I mean
04:22:50 <jlouis> Oejet: if you install as a user, then the package is only visible in the scope of the user. Adding --user to the configure command unhides the user scope for you
04:23:03 <c_wraith> So I need to provide a type signature explicitly
04:23:04 <Oejet> jlouis, Jafet: Argh, I knew that, but had forgotten. Too long ago.
04:23:11 <c_wraith> But it also needs to be polymorphic
04:24:01 <olsner_> I think that ScopedTypeVariables means that when you mention 'a' in the type signature for your function, you can use 'a' in the type signature for array to mean the same type
04:24:01 <Oejet> jlouis, Jafet: Thank you!
04:24:25 <hpaste>  . (xanxys_)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24928
04:25:02 <c_wraith> olsner_: it doesn't appear to be working for me..  I think I'm doing it wrong :)
04:26:08 <olsner_> c_wraith: as a workaround, maybe you can use a dummy function of some kind to restrain the type to what you want
04:26:28 <c_wraith> olsner_: yeah, I'm trying to get rid of doing that.  It just looked clunky
04:27:40 <olsner_> btw, which part of the array type is it that you can't get sufficiently constrained?
04:28:49 <c_wraith> newListArray is a typeclass method
04:29:03 <c_wraith> it can't even figure out which instance I mean
04:29:25 <c_wraith> err, it's not a typeclass method, but it's defined in terms of the MArray typeclass
04:29:35 <c_wraith> :t newListArray
04:29:36 <lambdabot> Not in scope: `newListArray'
04:29:48 <c_wraith> :t Data.Array.MArray.newListArray
04:29:49 <lambdabot> forall i e (m :: * -> *) (a :: * -> * -> *). (Data.Array.Base.MArray a e m, Ix i) => (i, i) -> [e] -> m (a i e)
04:30:27 <olsner_> but your function's type would constrain 'm' to ST s, right?
04:30:32 <c_wraith> yes
04:30:40 <c_wraith> But that doesn't help it resolve a
04:31:42 <olsner_> and all your accesses to the array are also through the MArray interface?
04:31:45 <c_wraith> yes
04:32:34 <c_wraith> a happens to be STArray, but I can't really specify that by itself
04:32:46 <c_wraith> You can't give it a partial type signature :)
04:33:54 <c_wraith> oh, do I need to add an explicit forall?
04:34:25 <c_wraith> that did the job.
04:34:34 <c_wraith> I was just using the extension wrong
04:35:59 <olsner_> ah, nice... maybe there should be a warning that you have scopedtypevariables and might want to add that forall to actually make use of it
04:37:42 <harlekin> Let K be a field, x in K and x + x = 0. Can you conclude x = 0 or is this valid in a field?
04:38:06 <Jafet> Consider Z/2Z.
04:38:15 <Jafet> But you should consider that in #math I think
04:38:25 <harlekin> Thanks.
04:38:57 <olsner_> jlouis: a question about those performance graphs for combinatorrent - is the x axis time/build# or testcase?
04:39:26 <zygoloid> harlekin: if 2*x = 0, you can conclude that either 2 = 0 or x = 0
04:40:29 <harlekin> zygoloid, yeah. But that's too specific. As Jafet pointed out I cannot conclude what I was trying to.
04:41:46 <Jafet> Hrm, so if x /= 0, the field cannot contain 2
04:42:38 <jlouis> olsner_: basically it is just a run of what is currently on the master branch. Things to the right are more recent, but there is no specific time interval
04:42:49 <jlouis> olsner_: I guess build# is the most accurate description
04:42:51 <harlekin> Jafet, 2 is not very general. :) At least we associate the property 2x = x + x which isn't obvious from the field acioms to me.
04:43:05 <harlekin> *axioms
04:44:03 <zygoloid> harlekin: x + x = (1*x) + (1*x) = (1 + 1) * x
04:44:45 <olsner_> ah, ok, so the best/worst-case of each graph just shows that things were at one point that bad/good
04:44:58 <harlekin> zygoloid, okay. Then it is obvious. ^^
04:45:47 <jlouis> olsner_: yes. I also define a cutoff for the graphs, so the failed run with 450 megabytes of live heap doesn't skew the graph too much. It is about looking for a general trend, not about getting the raw data
04:46:43 <jlouis> That said, the recent builds are definitely more worthy than the older builds :)
04:46:48 <olsner_> each graph could show how good the latest result is compared to the best ever, with the goal of always being 100%
04:47:31 <jlouis> olsner_: yup, my R-fu is not up to that yet though :)
04:49:12 <olsner_> "should be trivial" :)
04:53:59 <BONUS> i just found out about F7 and F8 in GHCi :o
04:54:01 <BONUS> mind = blown
04:54:56 <Taejo> BONUS: a quick way to type 18~ and 19~?
04:55:25 <olsner_> it's 8~ and 9~ for me
04:55:49 <dv-> 18~ and 19~ here too
04:56:41 <zygoloid> probably technically a quick way to type <escape>18~ and <escape>19~
04:56:56 <Taejo> BONUS: what do they do for you?
05:06:36 <monadic_kid> is it not possible to say in a module export list "export everything except for these"?
05:07:07 <Twey> monadic_kid: module Foo (..) hiding (Something (..), somethingElse) whereâ€¦
05:07:24 <monadic_kid> Twey: nice
05:07:28 <benmachine> I've never seen that ever
05:08:30 <I_LIVE> how to convert string to integer?
05:08:30 <ivanm> you can do that for exports as well? :o
05:09:00 <monadic_kid> Twey: is that an extension, can't get it to compile?
05:09:19 * benmachine suspects it just isn't a thing that exists
05:09:38 <ivanm> I_LIVE: read
05:09:42 <ivanm> > read "2.0" :: Double
05:09:43 <lambdabot>   2.0
05:09:47 <benmachine> I_LIVE: depends, are you definitely sure the string contains an integer and isn't "blip" or something
05:09:48 <ivanm> > read "2" :: Integer
05:09:49 <lambdabot>   2
05:09:51 <ivanm> > read "2" :: Double
05:09:52 <lambdabot>   2.0
05:10:07 <I_LIVE> benmachine: suppose I'm sure
05:10:19 <benmachine> I_LIVE: then like ivanm said you want read
05:10:28 <benmachine> read is nice and simple but it's not good for error handling
05:10:29 <ivanm> I_LIVE: unless you're trying to deal with some big huge thing, in which case you want to use a proper parsing library
05:10:36 <Twey> monadic_kid: Oh, I could just be wrongâ€¦ I thought it was validâ€¦ o.@
05:15:04 <dantheman_> Hey all, can anyone explain to me the difference, especially wrt scoping, between a where clause and a let clause?
05:15:22 <benmachine> dantheman_: essentially they are just used in different situations
05:15:36 <benmachine> where clauses attach to function equations or case branches only
05:15:46 <benmachine> let can appear in any expression
05:16:37 <benmachine> the advantage of where over let is pretty much purely aesthetic
05:17:42 <dantheman_> So can you have multiple where clauses in the same function equation?
05:17:58 <benmachine> sooort of
05:18:09 <benmachine> well, where starts a block
05:18:21 <benmachine> so you can have f x = x where y = blah; z = flib
05:18:34 <benmachine> hmm I wonder if you can
05:18:48 <benmachine> > let x = y where y = z where z = 7 in x
05:18:48 <lambdabot>   7
05:18:56 <benmachine> where can also attach to pattern bindings
05:19:00 <dantheman_> sorry what does the semicolon signify there?
05:19:13 <benmachine> it signifies a semicolon :P
05:19:14 <benmachine> well
05:19:25 <benmachine> if you're using layout as all sensible people do then it'd be a newline
05:19:37 <benmachine> with appropriate indentation
05:19:52 <dantheman_> ahh ok. right. so both y and z are defined in the where clause.
05:20:02 <benmachine> yes
05:21:31 <hpaste>  . (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24929
05:21:46 <dantheman_> Can you have something like this: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=24929#a24929
05:22:07 <benmachine> yes
05:22:21 <dantheman_> the two z's won't conflict?
05:22:25 <benmachine> no
05:22:45 <Twey> > case 1 of 1 -> y where y = 5; 2 -> y where y = 6
05:22:46 <lambdabot>   <no location info>: parse error on input `->'
05:23:28 <benmachine> > case 1 of { 1 -> y where y = 5; 2 -> y where y = 6; }
05:23:29 <lambdabot>   <no location info>: parse error on input `->'
05:23:31 <benmachine> bah
05:23:35 <dantheman_> haha
05:23:57 <benmachine> > case 1 of { 1 -> y where { y = 5 } 2 -> y where { y = 6 } } -- last try
05:23:58 <lambdabot>   <no location info>: parse error on input `2'
05:24:02 <benmachine> oops
05:24:08 <benmachine> > case 1 of { 1 -> y where { y = 5 }; 2 -> y where { y = 6 } } -- really last try
05:24:09 <lambdabot>   5
05:24:12 <benmachine> \o/
05:24:22 <dantheman_> rightt ok.
05:24:28 <benmachine> obv if it wasn't all on one line it'd be less horribly ugly
05:25:04 <Twey> Hehe, ooh
05:25:11 <Twey> I didn't know they attached to case branches
05:25:19 <dantheman_> so where is scoped as you'd expect wrt the layout rules, i.e. the first earlier line that is less indented?
05:25:53 <dantheman_> thanks
05:26:25 <benmachine> Twey: I spent ages thinking they attached to whole case expressions but they actually don't at all
05:27:31 <dantheman_> Can you give me an example of a situation where you might expect to be able to replace a let expression with a where clause but can't?
05:28:47 <dantheman_> e.g. f  x = 10 + (let z = 5 in z) + 7
05:29:44 <zygoloid> > let f x | x < 10 = let xs = x:xs in xs | otherwise = [] in f 4
05:29:45 <lambdabot>   [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,...
05:30:21 <benmachine> zygoloid: I could put a where xs = x:xs there
05:30:31 <benmachine> it'd go after the otherwise though
05:31:10 <zygoloid> > let f x xs | Just z <- lookup x xs = z | otherwise = 0 in f "a" [("a", 1), ("b", 3)]
05:31:11 <lambdabot>   1
05:31:28 <zygoloid> ^^ something like that, with a let inside the first guard
05:32:06 <zygoloid> > let f x xs | Just z <- lookup x xs = let zs = z:zs in zs | otherwise = [] in f "a" [("a", 1), ("b", 3)]
05:32:07 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
05:32:16 <benmachine> zygoloid: interesting
05:32:38 <benmachine> not h98 though! :P
05:33:08 <zygoloid> it is haskell2010 though.
05:33:17 <benmachine> mm fair enough
05:35:15 <dantheman_> hmm, not sure I quite get that zygoloid. So if you were to attempt to use a where clause instead, where might you try and put it (even though it would fail).
05:35:38 <zygoloid> dantheman_: you might try to put it before the "| otherwise"
05:36:43 <dantheman_> so ... lookup x xs = zs where zs = z:zs | otherwise ...
05:36:46 <dantheman_> ?
05:37:56 <Twey> Oooh, pattern guards in \b?
05:39:05 <dantheman_> is that list comprehension syntax?
05:39:31 <dantheman_> (i.e. the Just z <- lookup x xs )
05:39:45 <Twey> Of course, f = (fromMaybe 0 .) . lookup
05:39:57 <Twey> dantheman_: No, it's just a pattern match
05:40:12 <Jafet> View patterns!
05:40:40 <Twey> Jafet: No, pattern guards â˜º
05:40:48 <Twey> They overlap a bit
05:40:55 <dantheman_> Oh. Don't think I've seen those before.
05:41:19 <Jafet> Uh, can't tell where the arrows are going today
05:55:07 <ski> hm .. is there any guarantee that in `foo x | Left y <- bar x = baz x y | Right z <- bar x = quux x z', `bar x' will be shared ?
05:57:24 <ivanm> no
05:57:34 <ivanm> use a where clause if you want sharing
05:57:43 <ivanm> ski: alternatively, use the either function
05:57:55 <ski> *nod*, i was suspecting that
05:58:08 <ivanm> foo x = either (flip baz y) (flip quux z) $ bar x
05:58:14 <ski> (obviously this was just a silly example, in this specific case, i'd use `either' instead, yes :)
05:58:21 <ivanm> awwwwww :(
05:58:31 <ivanm> you mean I did all that work for you for _nothing_?!?!?!? :@
05:58:31 <ivanm> :p
05:58:50 <ski> well, i'd remove the `x's and use `.' instead of `$'
05:59:11 <ivanm> ski: wait, I stuffed that definition up anyway
05:59:23 <ivanm> foo x = either (baz x) (quux x) $ bar x
05:59:28 <ivanm> @pl foo x = either (baz x) (quux x) $ bar x
05:59:28 <lambdabot> foo = ap (liftM2 either baz quux) bar
05:59:33 <ski> oh, right
05:59:57 <ivanm> ski: that was why I had it explicit, but then stuffed up the function calls :s
06:00:04 <ivanm> but yay for @pl! \o/
06:00:44 <ski>   return either `ap` baz `ap` quux `ap` bar
06:01:21 <ivanm> what do you have against liftM2? :p
06:01:46 <ski> nothing in particular .. it's just that i would probably have derived that version, first
06:02:22 <ski> (and possibly then spotted that one could use `liftM3', instead)
06:03:45 <ski> (ivanm : .. or maybe you didn't spot that !?)
06:03:51 <ivanm> you can use liftM3?
06:03:53 <ivanm> @type liftM3
06:03:54 <lambdabot> forall a1 a2 a3 r (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
06:04:09 <ivanm> ski: sureley @pl would have used liftM3 if you can use liftM3
06:04:40 <ski>   liftM3 f ma mb mc  =  liftM2 f ma mb `ap` mc  =  liftM f ma `ap` mb `ap` mc  =  return f `ap` ma `ap` mb `ap` mc
06:04:54 <Twey> :t liftM3 either baz quux bar
06:04:55 <lambdabot> Not in scope: `baz'
06:04:55 <lambdabot> Not in scope: `quux'
06:04:55 <lambdabot> Not in scope: `bar'
06:04:56 <ski> ivanm : apparently it didn't
06:05:00 <Twey> :t liftM3 either ?baz ?quux ?bar
06:05:01 <lambdabot> forall a c b (m :: * -> *). (?baz::m (a -> c), ?quux::m (b -> c), ?bar::m (Either a b), Monad m) => m c
06:05:13 <zygoloid> @pl foo x = either (baz x) (quux x) (bar x)
06:05:13 <lambdabot> foo = ap (liftM2 either baz quux) bar
06:05:25 <ivanm> how does that work?
06:05:25 <ski> (i suspect it has cases hardcoded for `return',`liftM',`liftM2')
06:05:29 <Twey> Apparently it doesn't know about liftM3
06:05:35 <ivanm> ahhhh
06:05:40 <zygoloid> also why liftM2 not liftA2?
06:05:49 <Twey> Point
06:05:55 <ski> Idiom
06:05:55 <ivanm> zygoloid: becuase it's from before Applicative was defined and used
06:05:57 <Twey> :t liftA3 either ?baz ?quux ?bar
06:05:57 <lambdabot> forall a c b (f :: * -> *). (?baz::f (a -> c), ?quux::f (b -> c), ?bar::f (Either a b), Applicative f) => f c
06:06:09 <zygoloid> @type foo = either <$> ?baz <*> ?quux <*> ?bar
06:06:10 <lambdabot> parse error on input `='
06:06:15 * ivanm still uses liftM rather than fmap when using monadic code...
06:06:17 <zygoloid> @type either <$> ?baz <*> ?quux <*> ?bar
06:06:18 <lambdabot> forall a c b (f :: * -> *). (?baz::f (a -> c), Applicative f, ?quux::f (b -> c), ?bar::f (Either a b)) => f c
06:06:35 <ski> ivanm : i do that as well .. at least when i'm polymorphic in the monad
06:07:42 <ivanm> ski: no, this is when I know what monad I'm using as well
06:07:47 <ski> ok
06:07:49 <ski> @type \a -> do a
06:07:50 <lambdabot> forall t. t -> t
06:07:57 <ivanm> I think it just fits in better with usage of do, etc.
06:08:02 <ski> ivanm : any particular reason why ?
06:08:14 <ski> how does it fit better ?
06:08:20 <ivanm> *shrug* I prefer it
06:08:32 <ivanm> this is for my parser stuff; everything else is monadic
06:08:46 <ivanm> and that way I can distinguish between the parser stuff and any fmapping I might be doing to its internals, etc.
06:09:06 <ski> ok, that might be useful in particular code, yes
06:09:25 <ski> (don't you mean that your parser stuff is monadic, too ?)
06:09:42 <ivanm> ummmm, I meant the parser stuff is monadic
06:09:54 <ski> ic
06:10:00 <ivanm> so all the other parser combinators are monadic, so why suddenly use fmap in a few cases rather than liftM
06:11:22 <ski> well, if `Monad' was a subclass of `Functor', `fmap' would *be* monadic (even though it is more general)
06:11:25 <ski> see what i mean ?
06:11:32 <ski> (but i take your point)
06:12:42 <ivanm> yes
06:13:16 <ivanm> I don't really know why I do it, but I prefer using liftM for explicitly monadic values *shrug*
06:13:47 <ski> well, i usually prefer using `map' rather than `fmap' on lists, even though it's the same
06:13:58 <Jafet> Use (.)!
06:14:25 <ski> the reason being that it more explicitly tells you what type it is working with
06:14:59 <ivanm> ski: agreed
06:15:01 <ivanm> @slap Jafet
06:15:02 * lambdabot will count to five...
06:15:04 <ski> (which often makes the code easier to read .. even though it makes it (slightly) harder to generalize)
06:15:25 <ivanm> yet for some reason if I'm using a list I'm highly unlikely to want to generalise it down the track...
06:15:58 <ski> yes, often generalization is not very likely
06:16:34 <ski> (after one has considered generalizing it, and either not been able to find one, or deciding it is (currently) not worth it)
06:17:25 <ivanm> or you need to change that much code to generalise it, you might as well add one extra character to replace map with fmap
06:18:05 <harlekin> @type liftM2 (>>=)
06:18:06 <lambdabot> forall (m :: * -> *) a b (m1 :: * -> *). (Monad m, Monad m1) => m1 (m a) -> m1 (a -> m b) -> m1 (m b)
06:18:21 <harlekin> Can I somehow force Monad m1 to be the (->) Monad to simplify output?
06:19:08 <olsner_> it *shouldn't* be that much code to change - replacing a list with another representation of a sequence *should* only require changing the type signatures (if any)
06:19:19 <ivanm> harlekin: you mean when doing @type ?
06:19:25 <harlekin> ivanm, yeah.
06:19:39 <ivanm> @type liftM2 (>>=) succ
06:19:40 <lambdabot> forall (m :: * -> *) a b. (Monad m, Enum (m a)) => (m a -> a -> m b) -> m a -> m b
06:19:48 <ivanm> harlekin: ^^ like that?
06:19:54 <ivanm> note that it's missing the first argument though...
06:20:09 <harlekin> ivanm, yes.
06:20:22 <harlekin> @info (->)
06:20:22 <lambdabot>  Parse error at "->)" (column 2)
06:20:29 <harlekin> @src Monad (->)
06:20:29 <lambdabot> Source not found. Wrong!  You cheating scum!
06:20:35 <Jafet> @let S = ap; K = const; I = id; Î¹ = flip ($S) K
06:20:35 <lambdabot>  <local>:4:0: Not in scope: data constructor `S'
06:20:36 <lambdabot>  
06:20:36 <lambdabot>  <local>:4:8: Not in scope...
06:20:45 <Jafet> @let s = ap; k = const; i = id; Î¹ = flip ($s) k
06:20:45 <lambdabot>  <local>:4:38:
06:20:45 <lambdabot>      Ambiguous occurrence `s'
06:20:46 <lambdabot>      It could refer to either `L...
06:20:48 <ivanm> @src ((->) a) return
06:20:48 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
06:20:53 <harlekin> ivanm, I don't want to do the (c -> ) replacements (or was it (-> c)?) by myself.
06:21:05 <ivanm> harlekin: you don't want to do that for what?
06:21:23 <Jafet> @let Î¹ = flip ($ap) const
06:21:24 <lambdabot>  Defined.
06:21:25 <ski> (ivanm : yes, that's more or less what i was thinking about)
06:21:33 <harlekin> ivanm, replacing the m for which I want to restrict (Monad m) to the (->) monad.
06:21:47 <ivanm> harlekin: what are you trying to do?
06:21:59 <ivanm> harlekin: write your type signature that you want, then try writing the function
06:22:15 <harlekin> Sorry, I have to go. I'll come back later.
06:59:44 <deteego> Hello, in regards to GADT I was wondering if something like this is possible http://haskell.pastebin.com/vujK9zRm
07:01:24 <mauke> huh?
07:02:30 <deteego> kinda hard to explain, I basically want to create different constructors out of an enumerator
07:02:45 <deteego> for a data type
07:03:14 <mauke> data T = Ca Double Int Float | Cb String Double Int | Cc String String String
07:04:06 <deteego> yes but thats the thing, I wouldn't be able to do whats shown here
07:04:23 <deteego> case test1 of (a,_,_,_) -- do stuf here
07:04:32 <deteego> where a is the enum type
07:04:53 <deteego> which is the whole point of it all
07:05:03 <mauke> why do you think you need to do that?
07:05:17 <mauke> your case test1 code makes no sense, btw
07:05:27 <mauke> well, the definition of test1 makes no sense in the first place
07:05:29 <deteego> no it was just a generic example
07:05:50 <mauke> no, it makes no sense
07:05:55 <mauke> it's not an example of anything
07:07:15 <deteego> I was just demonstrating how I would like to use the constructors of the data type
07:07:18 <deteego> and destructors
07:07:46 <mauke> MyDataType is not a data constructor
07:08:00 <mauke> a is overloaded with two conflicting definitions
07:08:04 <deteego> oh my bad
07:08:10 <mauke> both of which are invalid because constructors must start with an uppercase letter
07:08:23 <deteego> that was an accident
07:08:32 <mauke> your use of a is invalid; it takes no arguments
07:08:49 <mauke> you can't pattern match on test1 and extract values, much less a tuple
07:09:10 <deteego> http://haskell.pastebin.com/keDsMJbu
07:09:24 <deteego> my brains a bit fuzzy, that should have better clarity
07:09:34 <mauke> where x, y, z is invalid
07:09:38 <mauke> a is still lowercase
07:09:48 <mauke> A takes no arguments
07:09:54 <mauke> Data should be data
07:10:49 <deteego> http://haskell.pastebin.com/8LfVgfz3
07:11:00 <deteego> there, sorry about that
07:11:06 <mauke> <mauke> where x, y, z is invalid
07:11:14 <mauke> <mauke> a is overloaded with two conflicting definitions
07:11:21 <mauke> <mauke> A takes no arguments
07:11:27 <mauke> <mauke> you can't pattern match on test1 and extract values, much less a tuple
07:13:25 <pvdbrand> hi, I want to fork off one or more servers in the main thread and then block the main thread indefinitely. I know the servers will never stop. How can I block the main thread indefinitely? Simply creating an empty MVar and trying to take it doesn't work, because the MVar will detect that it can never take any value out of it
07:13:25 <orlandu63> how do you import only the ! operator in Data.Map?
07:13:30 <orlandu63> i get a syntax error
07:13:40 <pvdbrand> import Data.Map ((!))
07:13:41 <mauke> import Data.Map ((!))
07:13:47 <orlandu63> duh!
07:14:11 <mauke> :t forever (threadDelay maxBound)
07:14:12 <lambdabot> Not in scope: `threadDelay'
07:14:16 <mauke> oh well
07:14:30 <pvdbrand> ok
07:16:06 <pvdbrand> mauke: works fine, thanks!
07:26:24 <Oejet> pvdbrand: What is the error message from the MVar?
07:26:58 * Jafet today joins the people who have written a crappy forking http server club
07:27:52 <Oejet> Jafet: What's so crappy about yours?
07:28:24 <pvdbrand> Oejet: it gives a runtime error: thread blocked indefinitely in an MVar operation
07:28:35 <pvdbrand> and that's exactly what's happening :)
07:28:57 <Jafet> Error handling.
07:29:34 <Jafet> MVar is required to schedule internally, pvdbrand
07:29:46 <Jafet> Although my favourite is the nonterminating code exception
07:29:56 <mauke> maybe you can trick it with x <- readMVar foo; putMVar foo x
07:30:05 <mauke> er, takeMVar
07:30:33 <pvdbrand> well, the forever threadDelay works fine and actually expresses my intent more clearly I think
07:31:53 <pvdbrand> I'm thinking about changing my code to something like "start servers 1 to (n-1) in a thread, and start the n'th server from the main thread"
07:31:55 <Jafet> It seems like a strange intention to me
07:32:07 <Jafet> The main thread normally has some sort of supervisory function
07:32:48 <Jafet> mauke, that might raise a NonTermination exception!
07:33:10 <pvdbrand> I want to listen on a TCP port, on a UDP port, and get input from stdin (but only when I run in debug mode), so I want to start three servers. If I start them all with forkIO, then the main thread will exit immediately after forking the servers and then make the whole program exit
07:34:16 <pvdbrand> and, btw, whether not the TCP and/or UDP servers should be run depends on a config file
07:35:17 <Jafet> I guess threadDelay is most correct then
07:35:39 <pvdbrand> is there a lowerCase on Strings? I can only find the Data.Char one
07:35:52 <Jafet> map
07:36:00 <pvdbrand> right, but no predefined fn?
07:36:15 <Jafet> Sort of unnecessary
07:36:21 <pvdbrand> true...
07:36:57 <Jafet> I just found a neat idiom today, fromEnd = (reverse.).(.reverse)
07:37:18 <Jafet> Then fromEnd f applies f to lists from behind
07:44:35 <mercury^> Jafet: that only seems useful for scans on finite lists, but they already come with both options.
07:45:51 <Jafet> "both options"?
07:46:01 <byorgey> deteego: if you now just remove 'MyEnum' and change the case at the end to   case test1 of (A _ _ _) -> ...  (B _ _ _) -> ...  and so on it works fine.
07:46:11 <mercury^> Jafet: scanl and scanr.
07:46:25 <byorgey> deteego: I'm not sure I understand the point of having MyEnum.
07:46:33 <Jafet> Hm, I see
07:46:59 <deteego> byorgey: thanks, the reason MyEnum is there is because its used in other areas
07:47:07 <deteego> and I wanted the enum to be used generally
07:47:13 <Jafet> (reverse.).(.reverse) looks so nice though
07:53:43 <roconnor> @ type (reverse.).(.reverse)
07:53:46 <roconnor> @type (reverse.).(.reverse)
07:53:47 <lambdabot> forall a a1. ([a1] -> [a]) -> [a1] -> [a]
07:54:48 <dantheman_> hey all. Say I have two fns that each return a result of type Maybe Bool, and I want to combine their results to return a Maybe Bool, so that if both are Just bool the final result is the logical and (&&) of each, and otherwise Nothing. What would be a nice way to do this that takes advantage of the monadic nature of Maybe?
07:55:13 <deteego> byorgey: http://haskell.pastebin.com/mYBzQMbv
07:55:18 <mauke> liftM2 (&&)
07:55:19 <deteego> that is the kind of stuff I wanna do
07:55:43 <dantheman_> ahha. thanks mauke.
07:56:57 <deteego> byorgey: that enum is used in other areas, there is a reason I am using it
07:57:06 <deteego> byorgey: otherwise yes, this is pointless
07:57:26 <mauke> that code still makes no sense
07:58:29 <deteego> and what exactly is confusing
07:58:35 <mauke> http://codepad.org/yiu5TpVR - here's something that actually compiles
07:58:54 <mauke> deteego: see above
07:58:56 <deteego> its not SUPPOSED to compile
07:59:40 <deteego> im just asking if what I am trying to do
07:59:45 <deteego> is possible in any way
07:59:48 <mauke> how about I code a solution in perl, that won't compile either
07:59:55 <mauke> I HAVE NO IDEA WHAT YOU'RE TRYING TO DO
08:00:02 <mauke> BECAUSE YOUR CODE MAKES NO SENSE
08:00:10 <mauke> AND YOU DON'T EXPLAIN ANYTHING
08:00:23 <deteego> I am trying to use an enumerators as overloaded constructors
08:00:49 <mauke> you can't overload constructors
08:01:00 <mauke> that's problem #1
08:01:12 <deteego> overloaded was the wrong wrd, moreso
08:01:37 <deteego> I want to fill the constructors for a datatype using an enumerator
08:01:49 <mauke> what do you mean by "using"?
08:01:58 <mauke> also, is this supposed to happen at runtime?
08:02:06 <mauke> if at compile time, why does the enum exist at all?
08:02:27 <deteego> mauke: I would believe it would happen at runtime
08:02:37 <deteego> unless Haskell has some meta programming feature
08:02:59 <mauke> you can't define constructors at runtime
08:03:17 <mauke> that might be problem #2
08:03:26 <deteego> hmmm ok
08:03:42 <deteego> is there any module for reflection that could help do it at compile time?
08:03:57 <mauke> do what?
08:04:23 <deteego> map the values in the Enumerator
08:04:33 <deteego> to what you have written
08:04:34 <deteego> data MyEnum = A | B | C deriving (Eq,Show)
08:04:42 <deteego> which is essentially what I am trying to do
08:04:47 <mauke> why?
08:04:55 <mauke> <mauke> if at compile time, why does the enum exist at all?
08:05:09 <deteego> because the enum is used in other areas
08:05:14 <deteego> im asking if its possible?
08:05:55 <mauke> bah
08:06:18 <deteego> ?
08:06:47 <aavogt> what's the difference from using MyEnum than having A B C constructors take the 3 arguments each?
08:07:30 <mauke> you're not telling me what you're trying to do
08:07:32 <deteego> ... thats besides the point, I would have to upload all my code to show why
08:07:37 <mauke> preflex: ? xy
08:07:38 <preflex>  factoid not found
08:07:40 <mauke> preflex: ? xy-problem
08:07:41 <preflex>  factoid not found
08:07:43 <mauke> aww
08:08:00 <deteego> im already telling you what I am trying to do, you are replying with why
08:08:07 <deteego> im asking if its possible
08:08:21 <litb> hmm
08:08:25 <deteego> and if so how to do it
08:08:46 <mauke> preflex: + xy They ask how to do X, but that's because they really want to do Y but think X will get them there and most of the time they are wrong
08:08:46 <soiamso> deteego: template haskell ?
08:08:55 * hackagebot vcd 0.1.0 - Tools for writing VCD files.  http://hackage.haskell.org/package/vcd-0.1.0 (TomHawkins)
08:09:30 <deteego> soiamso: ah thank you
08:09:35 <deteego> just what I needed
08:09:41 <deteego> didnt realise haskell had templates
08:10:29 <deteego> im assuming template haskell doesn't really have the issues that templates have in other languages
08:10:36 <deteego> such as C++
08:10:49 <mauke> is there another language with templates?
08:10:54 <mauke> also, template haskell is macros
08:10:57 <Mathnerd314> scheme ;-)
08:11:30 <soiamso> deteego: C++ 's template is just for generic ?
08:11:43 <Mathnerd314> I'm not certain Template Haskell has *hygienic* macros though
08:11:49 <aavogt> so how are you supposed to get a string out of the A anyways
08:12:04 <deteego> yeah....
08:12:21 <aavogt> no, they are clean if you want them to be
08:12:28 <Associat0r> Mathnerd314: mauke deteego http://www.cs.rice.edu/~taha/publications/journal/dspg04b.pdf
08:13:51 <soiamso> deteego: i think template haskell is not for generic
08:14:06 <deteego> aavogt: I believe the enum instance does have a function for converting enums->string
08:14:11 <deteego> soiamso: hmmm
08:14:29 <deteego> im looking through it trying to understand it
08:14:40 <soiamso> deteego: deriving (Show) ?
08:15:30 <deteego> soiamso: yup or that
08:15:32 <deteego> =D
08:17:01 <soiamso> deteego: it's that fullfill ?
08:18:02 <deteego> huh?
08:18:30 <aavogt> wwso for addStrings, the output should be either "A", "B", or "C"?
08:19:38 <deteego> yeah
08:19:42 <deteego> anyways im gonna go to bed
08:19:56 <deteego> thanks for your help, will look at it tommorow
08:25:20 <hpaste>  0Ld (4LLH)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24930
08:26:35 <chrisdone> woops, I guess hpaste doesn't handle utf-8 well
08:29:40 <siracusa> chrisdone: Looks fine for me
08:30:22 <chrisdone> the title and author are messed up, i put chrisdone as the author
08:34:02 <burp> nice
08:34:41 <burp> aren't there more grey-shades?
08:35:23 <chrisdone> i just saw those three on some forum
08:35:49 <burp> and I think with a monospace font you don't have to use 2 fields
08:36:19 <burp> hm, I mean some font where height = width
08:48:30 <dantheman_> hey, is there any chance someone could fix the link to hpaste above (the closing " is in the linked text when it shouldn't be)
08:48:33 <gio123> Cale: hi
08:49:12 <dantheman_> Actually it's the same for all the links
08:49:23 <mauke> dantheman_: irc doesn't have links
08:49:43 <dantheman_> hmm, maybe it's just on the webchat.freenode client?
08:49:55 <mauke> yes, it's your client misdetecting urls
08:50:00 <BONUS> what are the advantages of Logic a compared to [a] when it comes to backtracking computations? I'm just figuring out the logic monad but it seems like they do their computation quite similarly
08:50:41 <dantheman_> i.e. http://webchat.freenode.net
08:51:01 <dantheman_> who should I ask to get it fixed I wonder, its kind of annoying!
08:52:06 <gio123> is here anybody familier about simple type lambda calculus?
08:53:19 <Philippa> gio123: just about everyone here is either directly or indirectly, as Haskell subsumes the STLC :-)
08:53:39 <Philippa> bbiab
09:15:17 <rfh> a uncurried function f (a,b): (a,b)->c , a curried function f a b : a->b->c, thus i would conclude the function curry takes an uncurried function f(a,b) and gives f a b. but why is the opposite true: curry f a b = f (a,b) ?
09:15:29 <aavogt> @type uncurry
09:15:30 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
09:16:11 <aavogt> remember what they do based on what the result is
09:16:14 <mercury^> rfh: curry f produces a curried function.
09:16:32 <aavogt> sort of like knowing what 'words' and 'unwords' do
09:17:08 <mercury^> "uncurry" should better be "bland" though
09:17:10 <rfh> hmm
09:17:52 <rfh> @type words
09:17:53 <lambdabot> String -> [String]
09:18:45 <rfh> thanks for the responses
09:19:25 <rfh> still, curry makes no sense to me from an functional perspective
09:19:55 <rfh> not the inventor of haskell of course :)
09:20:17 <mercury^> rfh: it makes perfect sense, you are a bit confused.
09:20:45 <mercury^> And Haskell Curry did not invent Haskell btw.
09:21:15 <rfh> sorry, the eponym
09:21:48 <Jafet> > drop 10 $ map integerToBreakfast [1..]
09:21:49 <lambdabot>   Not in scope: `integerToBreakfast'
09:22:04 <Jafet> Herr ober!
09:22:25 <Mathnerd314> > [| x |]
09:22:26 <lambdabot>   <no location info>: parse error on input `|'
09:23:31 <Mathnerd314> no template haskell? :-(
09:24:35 <Jafet> Maybe codepad runs it
09:29:10 <Mathnerd314> http://codepad.org/H1gSRnXZ
09:29:13 <Mathnerd314> no :-)
09:29:19 <Mathnerd314> * :-(
09:29:57 <Jafet> Don't be emotionally confused! You can still use ghc
09:30:38 <Spaceghost> hi
09:31:48 <Spaceghost> I have defined the functions and polynomial equation, we need to do one to classify as incompatible systems of equations, compatible determinate or indeterminate
09:32:11 <Spaceghost> what algoritm is the most easy for do in Haskell in yours opinion?
09:32:59 <exDM69> I have a problem installing Haskell platform on my ubuntu bozx
09:33:10 <exDM69> I have problems with the OpenGL package
09:33:11 <Mathnerd314> @type ((<*>) .)
09:33:12 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Applicative f, Functor f1) => f1 (f (a -> b)) -> f1 (f a -> f b)
09:33:46 <Mathnerd314> @type fmap (<*>)
09:33:47 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Applicative f, Functor f1) => f1 (f (a -> b)) -> f1 (f a -> f b)
09:34:08 <Mathnerd314> @type fmap fmap (<*>)
09:34:09 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b. (Functor f, Applicative f1) => f1 (a -> b) -> f (f1 a) -> f (f1 b)
09:34:16 <exDM69> first, I got errors about not being able to find glEnd in libGL, I hacked configure.ac to not check for it. now I get Missing (or bad) header file: HsOpenGL.h
09:34:24 <exDM69> I have all opengl libraries installed properly
09:34:30 <Mathnerd314> @type fmap fmap fmap (<*>) liftA
09:34:31 <lambdabot> forall a b a1 (f :: * -> *). (Applicative f) => (a1 -> a -> b) -> f a1 -> f a -> f b
09:35:05 <Mathnerd314> @type (.).(.) (<*>) liftA
09:35:06 <lambdabot> forall (f :: * -> *) a b a1. (Functor f) => (a1 -> b) -> f ((a -> a1) -> a) -> f ((a -> a1) -> b)
09:35:18 <Mathnerd314> @type ((.).(.)) (<*>) liftA
09:35:19 <lambdabot> forall a b a1 (f :: * -> *). (Applicative f) => (a1 -> a -> b) -> f a1 -> f a -> f b
09:35:50 <Mathnerd314> @type ((.).(.)) (<*>) liftA2
09:35:51 <lambdabot> forall a a1 b c. (a1 -> b -> c) -> (a -> a1) -> ((a -> b) -> a) -> (a -> b) -> c
09:36:25 <mreh> do we have a wikipage concerning deploying haskell software on windows?
09:36:46 <hpc> don't think so
09:37:12 <mreh> I can make precompiled executables for windoze though can't I?
09:37:49 <hpc> i assume just compile on windows and you have your executable
09:38:10 <hpc> i mainly work on linux though, so i could be wrong
09:38:23 <aavogt> I've compiled windows executables with a ghc installed in wine
09:38:24 <mreh> windows isn't an architecture
09:38:44 <aavogt> actually, just one :)
09:39:04 <mreh> aavogt: did you make a cross compiler for a specific architecture?
09:40:56 <aavogt> mreh: no. Though I was running x86_64, but everything in wine is i386
09:41:23 <Zao> aavogt: Unless you're insane and run wine64.
09:41:26 <aavogt> I just installed the ghc for windows into wine
09:41:38 * mreh doesn't know *that* much about machine architectures
09:41:40 <Zao> Not that there's any win64 ghc builds though.
09:41:49 <aavogt> right, I'm not aware that that would work
09:43:11 <FliPPeh> How do I use Data.Bits to append a bit in front of something?
09:43:45 <tromp_> what does that mean?
09:43:47 <Zao> Find next power of two, .|. it in.
09:43:54 <Zao> It all depends on what you mean.
09:44:19 <Zao> 14:30, it seems.
09:44:23 <tromp_> Data.Bits just provides operations on fixed length bit sequences
09:44:31 <Zao> Bah, wrong channel.
09:45:11 <Mathnerd314> hm, is (.) associative?
09:45:45 <Jafet> The sane definition is
09:45:56 <mreh> what's the insane definition?
09:45:58 <aavogt> mreh: this was a year ago, however
09:46:02 <Jafet> Maybe that assumes partiality, though
09:46:10 <Jafet> mreh, fmap
09:46:30 <Mathnerd314> @type \f g h -> (f . g) . h
09:46:31 <lambdabot> forall a b a1 (f :: * -> *). (Functor f) => (a -> b) -> (a1 -> a) -> f a1 -> f b
09:46:33 <Mathnerd314> @type \f g h -> f . (g . h)
09:46:34 <lambdabot> forall a b a1 (f :: * -> *). (Functor f) => (a -> b) -> (a1 -> a) -> f a1 -> f b
09:46:57 <Jafet> @type let f . g x = f (g x) in \f g h -> (f . g) . h
09:46:58 <lambdabot> Parse error in pattern
09:47:09 <Jafet> @type let (f . g) x = f (g x) in \f g h -> (f . g) . h
09:47:10 <lambdabot> forall t t1 t2 t3. (t -> t1) -> (t2 -> t) -> (t3 -> t2) -> t3 -> t1
09:47:17 <Jafet> @type let (f . g) x = f (g x) in \f g h -> f . (g . h)
09:47:18 <lambdabot> forall t t1 t2 t3. (t -> t1) -> (t2 -> t) -> (t3 -> t2) -> t3 -> t1
09:47:21 <Gwern-away> @wn spiv
09:47:23 <lambdabot> *** "spiv" wn "WordNet (r) 2.0"
09:47:23 <lambdabot> spiv
09:47:23 <lambdabot>      n : a person without employment who makes money by various
09:47:23 <lambdabot>          dubious schemes; goes about smartly dressed and having a
09:47:23 <lambdabot>          good time
09:47:27 <Gwern-away> I like how 'spiv' sounds like an ethnic slur
09:47:47 * Gwern-away puts it in the toolbox next to 'niggardly'
09:48:20 <Jafet> The internet seems to have effected some triviality in your affected vocabulary.
09:48:36 <Gwern-away> Jafet: if you think it's affected, you don't know me very well
09:49:19 <Jafet> Alas, but you are not Yorick.
09:49:46 <Twey> Hehe
09:49:50 <Gwern-away> on the internet, no one knows you're an abhorred skull
09:50:21 <sm> @wn hustler
09:50:22 <lambdabot> *** "hustler" wn "WordNet (r) 2.0"
09:50:22 <lambdabot> hustler
09:50:22 <lambdabot>      n 1: a prostitute who attracts customers by walking the streets
09:50:22 <lambdabot>           [syn: {streetwalker}, {street girl}, {hooker}, {floozy},
09:50:22 <lambdabot>            {floozie}, {slattern}]
09:50:24 <lambdabot>      2: a shrewd or unscrupulous person who knows how to circumvent
09:50:26 <lambdabot>         difficulties [syn: {wheeler dealer}, {operator}]
09:50:55 <aavogt> what does :def! do in ghci?
09:51:16 <aavogt> is it just a more enthusiastic :def?
09:51:42 <Gwern-away> aavogt: I believe that's what the postfix ! does
09:51:45 <Gwern-away> cf. :browse!
09:51:57 <aavogt> and what is that?
09:52:12 <Gwern-away> it's like :browse, but more so
09:52:28 <Gwern-away> it has more vim, more vigor, more brio, more je ne sais quoi
09:52:29 <aavogt> this isn't clarifying things at all
09:52:41 <Gwern-away> if you want clarifying, go to a creamery
09:53:57 <Twey> Heheheh
09:54:58 <FliPPeh> Man
09:55:14 <FliPPeh> I wanted to implement the Sha-2 algorithm in Haskell
09:55:17 <Gwern-away> (persiflage and badinage is a lost art)
09:55:24 <FliPPeh> But I already fail at the "append the bit '1' to the message" part
09:55:31 <chrisdone> haha
09:56:16 <litb> lulz
09:56:25 <FliPPeh> Oh wait.
09:56:30 <FliPPeh> Append, not add to the front
09:56:39 <Gwern-away> let's all program assembler in accordance with the socialist lifestyle!
09:56:52 <Jafet> Wait till you get to endianness!
09:57:08 <chrisdone> FliPPeh: prepend/append mm
09:57:10 <aavogt> sounds like nettoyage
09:57:42 <litb> i heard human can only do 2 things the same time. from that point on i figured that all those haskell guys playing with tens of type variables aren't anymore the average human. :)
09:58:19 <Gwern-away> litb: the research is 2 separate tasks; it didn't put any limits on how complex each task may be
09:58:22 <dmwit> :browse! does, indeed, hame much more vim (than emacs)
09:58:23 <dmwit> ;-)
09:58:25 <FliPPeh> chrisdone: All done with "msg ++ [0x01]" :/
09:58:57 <litb> 2 separate task, and each task contain 2 other separate tasks :)
10:00:58 <Jafet> Lazy multitasking
10:01:29 <Jafet> The stg only needs four registers, or something
10:04:07 <hpaste>  . (Mathnerd314)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24931
10:04:18 <Mathnerd314> I'm thinking that I'm missing some pattern in this
10:05:11 <Mathnerd314> like, there's some easy to write liftAN in terms ofliftA(N-1)
10:06:23 <Jafet> pure f $ foldr1 (<*>)
10:06:55 <Jafet> Or something
10:06:58 <Mathnerd314> @type pure f $ foldr1 (<*>)
10:06:59 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
10:06:59 <lambdabot>       Expected type: f (a -> b)
10:06:59 <lambdabot>       Inferred type: f a
10:07:28 <Jafet> @type ($ foldr1 <*>) . pure
10:07:29 <lambdabot> parse error on input `)'
10:07:35 <Jafet> @type ($ foldr1 (<*>)) . pure
10:07:36 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
10:07:36 <lambdabot>       Expected type: f (a -> b)
10:07:37 <lambdabot>       Inferred type: f a
10:07:46 <Jafet> Something, then
10:08:10 <Mathnerd314> @pl liftA4 f a b c d = (liftA3 f a b c) <*> d
10:08:11 <lambdabot> liftA4 = ((((<*>) .) .) .) . liftA3
10:08:15 <BONUS> what would the type of something like pure f $ foldr1 (<*>) be?
10:08:20 <FliPPeh> Quick, converting a Char to a Word8!
10:08:26 <Jafet> ord!
10:08:32 <FliPPeh> What!
10:08:32 <BONUS> the type checker is spot on when it says it would need to unify a and a -> a for that
10:08:39 <Jafet> Sorry, I had to be quick.
10:08:39 <FliPPeh> I thought that does convert it to an int
10:08:39 <dolio> liftAN = (<*>) `compN` liftA(N-1)
10:08:40 <zygoloid> fromIntegral . fromEnum!
10:08:51 <dolio> Or maybe comp(N-1)
10:08:53 <Jafet> A Char doesn't convert to a Word8, anyway
10:09:01 <FliPPeh> I know :(
10:09:04 <zygoloid> FliPPeh: const 42!
10:09:11 <FliPPeh> zygoloid wins.
10:09:33 <zygoloid> fromIntegral . digitToInt?
10:09:36 * Jafet whips Flippeh with a ByteString
10:09:44 <FliPPeh> I was just about to do that
10:09:46 <Mathnerd314> @type ((((<*>) .) .) .)
10:09:46 <FliPPeh> :)
10:09:47 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *) (f2 :: * -> *) (f3 :: * -> *). (Applicative f, Functor f1, Functor f2, Functor f3) => f3 (f2 (f1 (f (a -> b)))) -> f3 (f2 (f1 (f a -> f b)))
10:09:49 <FliPPeh> Thanks
10:10:21 <Mathnerd314> @type (.) (.) (.) (<*>)
10:10:22 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) a b. (Functor f, Functor f1, Applicative f2) => f (f1 (f2 (a -> b))) -> f (f1 (f2 a -> f2 b))
10:10:51 <Mathnerd314> @type (.) (.) (.) (.) (<*>)
10:10:52 <lambdabot> forall a (f :: * -> *) a1 b. (Functor f) => (a -> a1 -> b) -> (a -> a1) -> f a -> f b
10:11:23 <Mathnerd314> @type (.) ((.) ((.) (<*>)))
10:11:24 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *) (f2 :: * -> *) (f3 :: * -> *). (Applicative f, Functor f1, Functor f2, Functor f3) => f3 (f2 (f1 (f (a -> b)))) -> f3 (f2 (f1 (f a -> f b)))
10:11:26 <Twey> :t fmap .fmap $ fmap (<*>)
10:11:27 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) a b (f3 :: * -> *). (Functor f, Functor f1, Applicative f2, Functor f3) => f (f1 (f3 (f2 (a -> b)))) -> f (f1 (f3 (f2 a -> f2 b)))
10:11:49 <Twey> :t (Prelude..)
10:11:50 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
10:11:59 <Jafet> Martian boobs
10:12:12 <Twey> :t ((((<*>) Prelude..) Prelude..) Prelude..)
10:12:13 <lambdabot> forall (f :: * -> *) a b a1 a2 a3. (Applicative f) => (a3 -> a2 -> a1 -> f (a -> b)) -> a3 -> a2 -> a1 -> f a -> f b
10:12:47 <Mathnerd314> not much help :-/
10:12:52 <dolio> comp1 = (.) compN = comp(N-1) . (.)
10:13:36 <Mathnerd314> @let comp1 = (.)
10:13:37 <lambdabot>  Defined.
10:13:48 <Mathnerd314> @let comp2 = comp1 . (.)
10:13:49 <lambdabot>  Defined.
10:13:53 <benmachine> :t comp2
10:13:54 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
10:14:17 <Mathnerd314> :t comp2 (<*>)
10:14:18 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *) (f11 :: * -> *). (Applicative f, Functor f1, Functor f11) => f1 (f11 (f (a -> b))) -> f1 (f11 (f a -> f b))
10:14:25 <Twey> @let comp 1 = (.); comp (pred -> n) = comp n
10:14:25 <lambdabot>   ViewPatterns is not enabled
10:14:29 <Twey> Aw
10:14:38 <zygoloid> it was the other day :(
10:14:44 <Twey> @let comp 1 = (.); comp n = comp $ pred n
10:14:44 <dolio> That wouldn't work anyway. It'd be ill-typed.
10:14:45 <lambdabot>  Defined.
10:14:48 <benmachine> > let (id -> x) = 7 in x
10:14:49 <lambdabot>   7
10:14:53 <Twey> :t comp
10:14:54 <lambdabot> forall t a b (f :: * -> *). (Num t, Functor f, Enum t) => t -> (a -> b) -> f a -> f b
10:14:59 <Twey> dolio: Looks okay to me
10:15:10 <dolio> Hmm...
10:15:11 <Mathnerd314> :t comp 1
10:15:12 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:15:13 <benmachine> Twey: okay but it's const (.)
10:15:16 <Mathnerd314> :t comp 2
10:15:17 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:15:25 <Mathnerd314> ^ wrong
10:15:26 <dolio> Ah, yes.
10:15:37 <Twey> Don't ask me.  I was just Haskelling dolio's thing.  :Ã¾
10:15:46 <dolio> You can't Haskellize my thing.
10:15:46 <Twey> > let f (pred -> n) = n in f 5
10:15:47 <lambdabot>   4
10:15:55 <benmachine> maybe you could TH it?
10:15:56 <Twey> I guess they're enabled in mueval but not in \b proper
10:16:02 <dolio> At least, not without type-level naturals.
10:16:06 <benmachine> > ord '\b'
10:16:07 <lambdabot>   8
10:16:25 <Mathnerd314> ah, type-level naturals + some typeclasses to make it work
10:16:45 <Mathnerd314> can you @let classes with lambdabot?
10:16:51 <dolio> No.
10:16:51 <benmachine> I'd be surprised
10:17:14 <benmachine> @let infixl 0 `id`
10:17:15 <lambdabot>  <local>:8:9:
10:17:15 <lambdabot>      The fixity signature for `id' lacks an accompanying bindin...
10:17:18 <benmachine> :(
10:17:32 <Mathnerd314> @let infixl 0 <****>
10:17:33 <lambdabot>  <local>:8:9:
10:17:33 <lambdabot>      The fixity signature for `<****>' lacks an accompanying bi...
10:17:38 <benmachine> wat
10:17:40 <Twey> @let infixl 0 `id`; id = Prelude.id
10:17:41 <lambdabot>  Defined.
10:17:45 <benmachine> > id 0
10:17:46 <lambdabot>   Ambiguous occurrence `id'
10:17:46 <lambdabot>  It could refer to either `L.id', defined at <loc...
10:17:49 <Twey> Damn
10:17:56 <Mathnerd314> @undefine
10:18:04 <benmachine> > id ()
10:18:04 <lambdabot>   ()
10:18:23 <Mathnerd314> @let infixl 0 <****>; <****> = id
10:18:23 <lambdabot>   Parse error: VarSym "<****>"
10:18:35 <Mathnerd314> @let infixl 0 <****>; (<****>) = id
10:18:36 <lambdabot>  Defined.
10:18:40 <benmachine> wooo
10:18:46 <Mathnerd314> :t (<****>)
10:18:47 <lambdabot> forall a. a -> a
10:19:04 <Mathnerd314> @undefine
10:19:30 <Mathnerd314> @let data One
10:19:30 <lambdabot>   EmptyDataDecls is not enabled
10:19:55 <benmachine> @let data Identity a = Identity { runIdentity :: a }
10:19:55 <lambdabot>  Invalid declaration
10:20:08 <benmachine> what
10:20:21 <Mathnerd314> yeah...
10:20:35 <dolio> Actually, even with type-level naturals, it'd be a tall order.
10:20:45 <dolio> I think you'd need type-lists.
10:20:48 <Mathnerd314> @let data Identity a = Identity a
10:20:48 <lambdabot>  Invalid declaration
10:20:59 <Jafet> It's an easy job in TH
10:21:00 <Mathnerd314> @let data Foo a = Foo a
10:21:01 <lambdabot>  Invalid declaration
10:21:21 <Mathnerd314> so close, yet so far far away...
10:21:36 <Jafet> These lift* are pretty close to sugar, anyway
10:21:41 <benmachine> @let type Not x = x -> Void
10:21:41 <lambdabot>  Invalid declaration
10:21:53 <benmachine> I guess it whitelists declaration types
10:22:00 <benmachine> only typesigs etc.
10:22:12 <benmachine> typesigs, funbinds, patbinds
10:22:15 <benmachine> etc.
10:22:26 <dolio> liftA :: forall ts b (f :: * -> *). VecWitness ts -> (Fun ts b) -> Fun (Map f ts) b
10:22:52 <Mathnerd314> @hoogle VecWitness
10:22:52 <lambdabot> No results found
10:23:04 <dolio> For instance: Map f (t ::: u ::: Nil) ~ f t ::: f u ::: Nil
10:23:19 <dolio> And Fun (t ::: u ::: Nil) b ~ t -> u -> b
10:23:30 <Mathnerd314> I'm not familiar with ::: and ~
10:23:37 <dolio> ~ is type equality
10:23:42 <benmachine> ::: is a constructor
10:23:43 <Jafet> Is it, should it, and/or will it be possible to have internal modules in a source file?
10:23:49 <Mathnerd314> oh.
10:23:49 <dolio> ::: is some hypothetical type cons I made up.
10:24:01 <Mathnerd314> like (->) or (,)
10:24:12 <benmachine> Jafet: it'd complicate GHC's system for finding files
10:24:12 <Mathnerd314> ?
10:24:20 * dolio goes to lunch.
10:24:26 <benmachine> Mathnerd314: yes, except those are both special
10:24:27 <Jafet> Well, "internal" so it's not counted for export
10:24:36 <Mathnerd314> ok
10:24:42 <benmachine> (you can't declare nonspecial ones without -XTypeOperators)
10:25:14 <Jafet> Sometimes it feels silly to create a new file just to namespace some things away
10:27:03 <Mathnerd314> > let comp 1 = (.); comp n = comp (n-1) . (.) in comp 1
10:27:04 <lambdabot>   Occurs check: cannot construct the infinite type: a = f a
10:27:18 <Jafet> That being said, should I make record field names really long instead?
10:27:23 <Mathnerd314> stupid occurs check :p
10:28:41 <Mathnerd314> :t (.)
10:28:42 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:28:45 <Twey> Jafet: No, keep with the file
10:28:48 <Mathnerd314> :t (.) . (.)
10:28:49 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
10:29:02 <Twey> And carry on praying to the devs for same-file submodules â˜º
10:29:06 <Jafet> New files for new records?
10:29:21 <Jafet> Maybe I just need a better filebrowser
10:29:42 <Mathnerd314> yeah; language sucks -> get a good IDE
10:29:53 <Jafet> emacs should have zsh style path completion
10:30:07 <Jafet> And smooth scrolling, but I long gave up on that
10:30:41 <Jafet> Maybe it could be implemented in TH...
10:30:48 * Jafet thinks perverse evil thoughts
10:31:01 <Mathnerd314> what could? record system?
10:31:21 <Jafet> Internal namespacing
10:31:29 <Mathnerd314> ok
10:33:55 <aavogt> is it possible within ghci to get a list of all locally `let' bindings?
10:35:13 <aavogt> oh, :show bindings
10:37:28 <aavogt> now how to run all of them in turn...
10:40:33 <Mathnerd314> :k [Maybe]
10:40:34 <lambdabot>     `Maybe' is not applied to enough type arguments
10:40:34 <lambdabot>     Expected kind `*', but `Maybe' has kind `* -> *'
10:40:53 <Mathnerd314> :k [Maybe a]
10:40:54 <lambdabot> Not in scope: type variable `a'
10:42:00 <Mathnerd314> there *must* be a way to write '(a -> b) -> f (f1 a) -> f (f1 b)' as an instance of '(a -> b) -> f a -> f b'
10:44:04 <Mathnerd314> anyways, on to Template Haskell...
10:44:29 <aavogt> how is this related?
10:44:48 <aavogt> are both f and f1 instances of Functor?
10:45:39 <Mathnerd314> yeah
10:45:52 <aavogt> just define   newtype F2 f1 f2 a = F2 (f1 (f2 a));  instance Functor F2 where fmap f (F2 x) = F2 (fmap fmap fmap f x)
10:46:55 <aavogt> without the newtype I suspect that your instance (if ghc can be convinced to accept it), will result in fmap going as deep as possible
10:47:21 <Mathnerd314> that's what I want...
10:48:34 <aavogt> you're probably best off writing a new class  DeepFmap or something
10:48:47 <Mathnerd314> yeah; I'm calling it Comp
10:48:51 <aavogt> which has instances defined in terms of other Functor instances
10:48:56 <byorgey> Mathnerd314: see the TypeCompose package
10:50:39 <byorgey> aavogt: is the 'fmap fmap fmap' REALLY necessary? =P
10:50:55 <zygoloid> (fmap . fmap) is nicer imo
10:51:33 <byorgey> for that newtype I think you can even just say 'deriving Functor
10:51:51 <aavogt> deriving Program
10:52:13 <zygoloid> module DoWhatIMean deriving Program
10:52:47 <aavogt> on a more serious note, do any of you know how to get the output of :show bindings  in a different :def?
10:53:21 <Jafet> It's less obscene than (.) (.) (.)
10:53:38 <Mathnerd314> :t (.) (.) (.)
10:53:39 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
10:53:52 <Mathnerd314> heh, I like that :-)
10:53:55 <chrisdone> danderson: ping
10:53:57 <zygoloid> i'd take (.).(.) over (.)(.)(.)
10:54:04 <zygoloid> total recall scares me
10:54:18 <Jafet> > (.)(.) id const succ 5$ 0xb00b135
10:54:19 <lambdabot>   6
10:55:14 <jmcarthur> (.).(.)
10:55:35 <aavogt> @remember Jafet > (.)(.) id const succ 5$ 0xb00b135
10:55:35 <lambdabot> Done.
10:55:59 <aavogt> incidentally, i'd is a valid identifier
10:55:59 <Jafet> Now write a black porn poem
10:56:19 <zygoloid> a well typed one, obv.
10:58:48 <Mathnerd314> what's a good type for nonnegative integers?
10:59:13 <dmwit> How big?
10:59:15 <Jafet> Doing such a thing does not sound positive.
10:59:29 <dmwit> The Word types are fast.
10:59:29 <Mathnerd314> dmwit: any size
10:59:48 <Mathnerd314> I just want to do some recursion
11:00:11 <Mathnerd314>  /induction
11:00:15 <dmwit> Does "any size" mean "the type has to support values of any size" or "any size is big enough"?
11:00:35 <Mathnerd314> "support values of any size", I think
11:00:47 <zygoloid> data Nat = Zero | Succ Nat
11:00:49 <dmwit> Integer if you like speed; Nat if efficiency doesn't matter.
11:00:59 <Mathnerd314> :t Zero
11:01:00 <lambdabot> Not in scope: data constructor `Zero'
11:01:05 <zygoloid> Nat isn't necessarily inefficient
11:01:41 <dmwit> ?hackage nat
11:01:41 <lambdabot> http://hackage.haskell.org/package/nat
11:01:59 <jmcarthur> it depends how it will be used
11:02:27 <Mathnerd314> I just want some type for the first argument of comp!
11:02:36 <cads> Are there any materials available talking specifically about what it takes to work with cabal and the haskell platform on windows?
11:02:59 <jmcarthur> for example, lazy naturals would probably be a lot faster than integers for comparing the lengths of lists
11:03:23 <jmcarthur> that's probably the most common example for lazy naturals, actually
11:03:45 <dmwit> ?hackage numbers
11:03:46 <lambdabot> http://hackage.haskell.org/package/numbers
11:03:49 <dmwit> That one is also good.
11:03:51 <zygoloid> they're fast for comparing small natural numbers to infinity :)
11:04:01 <jmcarthur> this is because they don't require a full traversal of both lists
11:04:10 <jmcarthur> *don't necessarily
11:05:02 <hpaste>  . (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24932
11:06:26 <Mathnerd314> :t id . fmap
11:06:27 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:07:39 <dmwit> id . x === x
11:08:07 <Mathnerd314> yeah yeah
11:08:43 <monochrom> Who is "."?
11:09:24 <zygoloid> "." is fmap in disguise. posting on hpaste under an alias.
11:09:34 <Mathnerd314> heh
11:09:34 <monochrom> haha
11:10:19 <Mathnerd314> hmmm... how do you do $() in ghci?
11:10:38 <zygoloid> just like that. but you need to :set -XTemplateHaskell
11:10:40 <monochrom> What is $()?
11:11:14 <aavogt> apply to a 0-tuple
11:11:19 <Mathnerd314> zygoloid: thanks
11:11:47 <Mathnerd314> yay; comp is 3 lines!
11:11:52 <zygoloid> Mathnerd314: you can also put -XTemplateHaskell on the ghci command line
11:12:31 <Mathnerd314> zygoloid: any reason it's not turned on by default?
11:12:41 <aavogt> it steals syntax
11:12:51 <aavogt> > const $("hello")
11:12:52 <lambdabot>   {()->"hello"}
11:13:21 <zygoloid> comp 0 = [| ($) |]; comp (n+1) = [| $(comp n) . fmap |]
11:13:42 <Mathnerd314> yeah, except I wrote id instead of ($)
11:13:55 <zygoloid> @type (id, ($))
11:13:56 <lambdabot> forall a a1 b. (a -> a, (a1 -> b) -> a1 -> b)
11:14:04 <kmc> @type [id, ($)]
11:14:05 <lambdabot> forall a b. [(a -> b) -> a -> b]
11:14:10 <zygoloid> ($) seems to have the more appropriate type
11:14:35 <dmwit> ($) = id -- a valid implementation
11:14:49 <kmc> @pl \x y -> x $ y
11:14:49 <lambdabot> id
11:15:05 <dmwit> ?pl ($)
11:15:05 <lambdabot> id
11:15:06 <dmwit> ;-)
11:17:33 * aavogt would have written:       [| \x -> $(foldr appE [| x |] (replicate 10 [| fmap |])) |]
11:17:46 <aavogt> where 10 is actually your 'n'
11:18:28 <aavogt> hmm, though that \x actually binds the function being used
11:18:32 <zygoloid> doesn't the Q monad get in the way there?
11:18:40 <zygoloid> @hoogle appE
11:18:40 <lambdabot> Language.Haskell.TH appE :: ExpQ -> ExpQ -> ExpQ
11:18:40 <lambdabot> Language.Haskell.TH.Lib appE :: ExpQ -> ExpQ -> ExpQ
11:18:40 <lambdabot> Language.Haskell.TH AppE :: Exp -> Exp -> Exp
11:19:24 <aavogt> zygoloid: not at all
11:19:42 <zygoloid> i didn't realise appE is already liftM2'd
11:20:57 <aavogt> not to hide any points: fmapN n = [| \f x -> $(foldr appE [| f |] (replicate n [| fmap |])) x |]
11:22:14 <aavogt> amazing when accidentally pointfree code works
11:23:28 <zygoloid> fmapN n = iterate (\e -> [| fmap . e |]) [| ($) |] !! n
11:24:53 <zygoloid> fmap . $e, rather
11:25:09 <Mathnerd314> that's more complicated, not less
11:25:23 <aavogt> it's shorter
11:25:35 <Mathnerd314> no, yours is the shortest
11:25:50 <Mathnerd314> token count, not character count
11:26:19 <zygoloid> mine is 16, aavogts is 21
11:26:49 * Mathnerd314 is confused
11:27:16 <zygoloid> (for the expression, excluding the "fmapN n =")
11:27:45 <Mathnerd314> oh.
11:28:14 <Mathnerd314> I count yours as 19, then
11:28:14 <aavogt>  doing some @pl:     fmapN n = iterate (varE 'fmap `appE`) [| ($) |] !! n
11:28:38 <aavogt> no, that's wrong :(
11:28:41 <hpc> what on earth is [|($)|]?
11:28:59 <Mathnerd314> hpc: [| id |]
11:29:03 <dankna> that is a Template Haskell expression
11:29:08 <hpc> ah
11:29:09 <zygoloid> Mathnerd314: if you count ($) as 3, then it's 18, but if you're counting that, replace it with id :)
11:29:16 <Mathnerd314> ok
11:29:46 <zygoloid> but that gives the wrong type for fmapN 0, but so does aavogt's so never mind :)
11:31:12 <Mathnerd314> no, type is fine
11:31:19 <aavogt> fmapN n = [| \f -> $(iterate (varE 'fmap `appE`) [| f |] !! n) |]
11:31:44 <zygoloid> Mathnerd314: fmapN 0 should be (a -> b) -> (a -> b), surely. a -> a is too general.
11:31:59 <aavogt> oh, fmapN 0  should be  ($), not id?
11:32:11 <Mathnerd314> no, should be id
11:32:30 <Mathnerd314> overly-general types aren't a problem for me
11:32:54 <vermin_slam> hey, I'm a newbie with a cabal install failure. I'm on windows XP with the Haskell Platform 2010.1.0.0, trying to do a "cabal install yi" so I can see some actual production haskell. The install failed with Exit Failure 1, and the cabal FAQ tells me to find the real error message, but all I can find is "Warning: cannot determine version of C:\Program Files\Haskell Platform\2010.1.0.0\bin\ghc.exe: """
11:33:39 <dv-> just Exit Failure 1?
11:34:15 <vermin_slam> it says that several times
11:34:30 <vermin_slam> i wish i could copy the log out of cmd.exe for you, but that doesn't seem to be possible
11:34:30 <dmwit> Can you paste the entire output to hpaste.org or similar, please?
11:34:46 <dv-> I think you right click, mark, then paste
11:34:54 <vermin_slam> ah, got it
11:34:58 <vermin_slam> never knew that was doable
11:35:13 <dv-> you could also redirect the output to a file
11:37:12 <hpaste>  cabal install yi log (vermin_slam)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24933
11:37:35 <vermin_slam> neat
11:37:41 <vermin_slam> i was about to paste the url
11:38:22 <vermin_slam> cmd doesn't store enough output to have the whole thing, but the end is there
11:38:34 <FliPPeh> Uhm
11:38:44 <FliPPeh> How'd I convert from Int to Word32?
11:38:51 <dankna> fromIntegral, isn't it?
11:38:54 <dv-> vermin_slam: Looks like you're running out of memory
11:39:00 <zygoloid> const 42, same as Char to Word8 :)
11:39:10 <FliPPeh> Thanks dankna!
11:39:15 <dankna> sure thing
11:39:16 <FliPPeh> zygoloid: Nah, that was Char to Word8!
11:39:20 <dv-> vermin_slam: increase page file size maybe
11:39:30 <zygoloid> oh, ok.
11:39:33 <zygoloid> > product [1..8]
11:39:34 <lambdabot>   40320
11:39:37 <FliPPeh> Also, a const 42 is not desirable for security applications
11:39:38 <zygoloid> that's a big word.
11:39:39 <FliPPeh> :)
11:39:50 <fax> ??
11:40:10 <vermin_slam> xp warned me that it needed to increase the page file's size part way through, i was afraid that might have caused problems
11:40:32 <vermin_slam> i'll try again, with less memory used up
11:41:04 <vermin_slam> thanks
11:41:07 <exDM69> http://www.pasteall.org/12524
11:41:18 <exDM69> I have trouble installing lambdabot
11:42:55 <poincare201> Hi. I've just begun with haskell (I know quite a few other languages), and so far, its not making much sense. Firstly, what the heck is nomad and what does it do? (I'm familiar with the basics of set theory but not much more abstract math aside from that)
11:43:16 <fax> lol
11:43:30 <poincare201> fax:?
11:43:50 <fax> poincare201: haskell nomad is someone who travels around the world telling using haskell to build a makeshift house and trap animals for food
11:43:50 <zygoloid> a nomad is a traveller, one who chooses to roam the land rather than having a fixed home
11:44:10 <hpc> haha
11:44:51 <fax> poincare201 - you should not bother to study monads until you have a basic understanding of the type system and the data declaration method
11:45:05 <goomba> i prefer nomnomnomads
11:45:29 <poincare101> I meant monad :)
11:45:30 <zygoloid> poincare101: start by trying to understand type constructors and functors.
11:45:42 <monadic_kid> poincare101: you mean monad, you should not be trying to understand them now as you're a beginner. Wait until you understand what type constructors and you recognize higher-kinded polymorphism and understand functors
11:45:54 <dmwit> poincare101: Check out sigfpe's blog posts, either "The IO Monad for People Who Just Don't Care" or "You Could Have Invented Monads -- and Maybe YOu Already Have", depending on whether you just want to get up and going or want to really grok monads.
11:46:00 <poincare101> This is what I'm following: http://jonathan.tang.name/files/scheme_in_48/tutorial/firststeps.html
11:46:09 <kmc> poincare101, "Monad" is just the name of an API.  this API is defined by a type class and contains higher order functions.  so you need to understand what those are first
11:46:12 <poincare101> what would be better for me (I know C, Python, Perl etc.)
11:46:24 <kmc> poincare101, i like that document
11:46:25 <hpc> @where lyah
11:46:25 <lambdabot> http://www.learnyouahaskell.com/
11:46:30 <kmc> poincare101, but you might want to check out LYAH and RWH
11:46:32 <kmc> @where rwh
11:46:32 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
11:46:40 <monochrom> a brain format is better for you
11:46:42 <dmwit> poincare101: In that case, I recommend browsing "Who Just Don't Care" and then getting back to following the Scheme in 24 tutorial.
11:46:42 <poincare101> kmc: which first?
11:46:44 <djahandarie> Cale, apparently (regarding quiver stuff), if G is a finite group, it can be rewritten via Artin-Wedderburn to a direct sum of matrix algebras... and you'd get one Artin-Wedderburn block for each irreducible representation. And then you'd be able to find a rich family of a family of orthogonal idempotents... so my question still lies as to what the theorem is, because I thought that these symmetric algebras have multiple orthogonal minimal id
11:46:50 <kmc> poincare101, hard to say, check them both out
11:47:00 <kmc> poincare101, note that it's not useful to know "what a monad is" if all you want is to do IO
11:47:06 <kmc> in fact IO is an atypical example of a monad
11:47:23 <kmc> if you just want to do IO, read http://haskell.org/haskellwiki/Introduction_to_IO
11:47:28 <poincare101> ah.
11:47:35 <poincare101> @where lyah
11:47:35 <lambdabot> http://www.learnyouahaskell.com/
11:48:01 <monadic_kid> poincare101: those two online books are good, wikibook too: http://en.wikibooks.org/wiki/Haskell
11:48:21 <monadic_kid> poincare101: check haskell wiki, links to many resources
11:49:50 <Mazza> does anyone knows how do I make a command run before quit XMonad?
11:50:06 <poincare101> thank you all very much! (I used to think that haskell was weird, unpopular language, not anymore :D)
11:50:26 <dmwit> Mazza: Join us in #xmonad.
11:50:37 <monochrom> Eh? channel size is over 700
11:50:43 <kmc> poincare101, it's still pretty niche, but catching on big
11:51:05 <monochrom> just a few days ago was still hovering over 666
11:51:15 <djahandarie> Haha
11:51:15 <kmc> poincare101, and i think it's weird by the standards of other languages.  but that's a good thing
11:51:17 <ddarius> monochrom: Several months ago it got up to 699.
11:51:36 <monochrom> Does it coincide with school terms ending?
11:51:49 <kmc> the ratio of #haskell members to ##c members is a bit different from the ratio of Haskell users to C users
11:51:54 <djahandarie> monochrom, hehe, I'd think that the channel count would actually go down. ;)
11:52:05 <poincare101> monochrom: they don't end quite yet
11:52:15 <poincare101> monochrom: are there other school kids here? (not college)
11:52:50 <aavogt> haskell is for 'mature' people?
11:52:51 <Twey> monochrom: No, the school term is just beginning again, I think
11:52:58 <poincare101> Twey: nope.
11:53:01 <poincare101> Twey: not in uSA
11:53:03 <poincare101> AFK
11:53:05 <Twey> In England
11:53:26 <fax> Twey you are right
11:53:41 <vermin_slam> i have a different error this time, bit it made some progress, just one more package left before yi is done! the error is with the installation of dyre-0.8.2. I think this means there's a problem with dyre's source, or maybe with the cominbation of it's source and my ghc version?
11:53:47 <hpaste>  cabal install yi 2 error isolated (vermin_slam)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24934
11:53:57 <vermin_slam> s/bit/but/
11:54:07 <monochrom> I guess "the term is dead. long live the term".
11:54:26 <fax> why does hpaste put a leading space?
11:54:34 <fax> if the bot doesn't take any input it can't be part of a loop
11:54:50 <Jafet> Try pasting as ">"
11:55:00 <LegendaryPenguin> are there any replaceAt functions for lists
11:55:04 <Twey> fax: The space is about output, not input
11:55:08 <Jafet> A DAG traversal can be almost as annoying as a loop.
11:55:11 <monochrom> it doesn't want to be part of a culprit either
11:56:44 * monochrom imagines dons announcing "under the invisible hands of shapr, #haskell has hit 700"
11:57:26 <monochrom> "#haskell is now the O(1)th largest channel on freenode"
11:57:40 <Jafet> Applying some analogy with cricket, no doubt.
11:58:32 <medfly> I can't wait until this channel goes in reverse
11:58:47 <medfly> when it starts hitting 500, 400, etc. again :)
11:59:06 <c_wraith> err.  700?  that's new.  hiya medfly! :)
11:59:11 <monochrom> I can help. I can ban you, that will decrease by 1. <duck>
11:59:13 <medfly> hi
11:59:20 <medfly> sure, go ahead.
11:59:48 <Jafet> Now we're an airplane.
11:59:59 <Jafet> I should write a monadic IO tutorial involving airplanes
12:01:00 <shapr> monochrom: ?
12:01:02 <djahandarie> I think there should be a new internet rule.... "if it exists, there is a monad tutorial using it as an analogy"
12:01:19 <c_wraith> there's a monad tutorial using porn as an analogy?
12:01:32 <ddarius> c_wraith: Actually...
12:01:33 <medfly> there should be?
12:01:40 <medfly> go ahead and make one
12:01:40 <Jafet> I can apply the rule that causes it to be created.
12:01:49 <monochrom> there is a monad tutorial using monad tutorials as an analogy
12:01:51 <arcatan> arrow tutorials, please
12:02:12 <monochrom> "monads are like monad tutorials, they are so polymorphic"
12:02:17 <djahandarie> haha
12:02:23 <Jafet> arcatan, "So, uh -- imagine a pointed functor"
12:02:32 <benmachine> @remember djahandarie <djahandarie> I think there should be a new internet rule.... "if it exists, there is a monad tutorial using it as an analogy"
12:02:32 <lambdabot> It is stored.
12:02:42 <monochrom> arrow plain tutorial
12:03:10 <monochrom> <djahandarie> is redundant
12:03:45 <benmachine> @quote djahandarie
12:03:45 <lambdabot> djahandarie says: <djahandarie> I think there should be a new internet rule.... "if it exists, there is a monad tutorial using it as an analogy"
12:04:01 <benmachine> @quote benmachine
12:04:02 <lambdabot> benmachine says: unsafeCoerce is just a generalisation of id
12:04:04 <benmachine> hmm
12:04:05 <medfly> @forget djahandarie <djahandarie> I think there should be a new internet rule.... "if it exists, there is a monad tutorial using it as an analogy"
12:04:05 <lambdabot> Done.
12:04:07 <benmachine> okay
12:04:09 <medfly> @forget djahandarie I think there should be a new internet rule.... "if it exists, there is a monad tutorial using it as an analogy"
12:04:09 <lambdabot> No match.
12:04:10 <benmachine> I thought it was convention
12:04:11 <medfly> er
12:04:13 <benmachine> but whatever
12:04:14 <medfly> @remember djahandarie I think there should be a new internet rule.... "if it exists, there is a monad tutorial using it as an analogy"
12:04:15 <lambdabot> Done.
12:04:18 <medfly> @quote djahandarie
12:04:19 <lambdabot> djahandarie says: I think there should be a new internet rule.... "if it exists, there is a monad tutorial using it as an analogy"
12:04:28 <benmachine> @quote <.*>
12:04:29 <lambdabot> br1 says: [13:52] <br1> viajas distinto pero viajas
12:04:38 <benmachine> eerm, okay
12:04:42 <djahandarie> haha
12:05:10 <monochrom> "viagara leads to more viagara"
12:05:24 <benmachine> I feel enlightened
12:05:57 <yitz> @quote analogy
12:05:57 <lambdabot> mmorrow says: a functor is like an analogy between two analogies
12:06:13 <c_wraith> @seen mmorrow
12:06:13 <lpsmith> is there a Word128 implemented somewhere?
12:06:13 <lambdabot> Unknown command, try @list
12:06:18 <c_wraith> preflex: seen mmorrow
12:06:18 <preflex>  mmorrow was last seen on #ghc 90 days, 16 hours, 8 minutes and 33 seconds ago, saying: * mmorrow is rtfm'ing
12:06:24 <LegendaryPenguin> @quote LegendaryPenguin
12:06:24 <lambdabot> No quotes match.
12:06:26 <c_wraith> damn that manual
12:06:36 <yitz> preflex: seen mmorrow
12:06:36 <preflex>  mmorrow was last seen on #ghc 90 days, 16 hours, 8 minutes and 51 seconds ago, saying: * mmorrow is rtfm'ing
12:06:41 <hpaste>  . (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24935
12:06:59 <benmachine> a lot of people seem to be looking for mmorrow
12:07:04 <yitz> hey! hpaste is announcing again. yay!
12:07:27 <yitz> we may not see him, but mmorrow is here
12:08:16 <fax> I don't hink mmorrow implemented that
12:08:39 <yitz> fax: didn't he write hpaste2?
12:09:23 <BONUS> i just hope hes ok
12:09:23 <fax> yes
12:09:44 <c_wraith> BONUS, wasn't he editing your next version of LYAH?
12:09:44 <yitz> i've also been worried about him
12:09:49 <fax> same
12:10:00 <BONUS> c_wraith: yeah, the current one actually, just for book release and such
12:10:09 <BONUS> he disappeared so we had to get a new technical editor
12:10:22 <c_wraith> that's a bad sign :(
12:10:31 <fax> BONUS you don't have his phone or anything
12:10:32 <fax> ?
12:10:42 <fax> because nobody seems to have got through via email
12:10:42 <BONUS> fax: nah, just had his mail :\
12:10:43 <lpsmith> LYAH is going to come out in book form? :)
12:10:48 <BONUS> lpsmith: yup yup!
12:11:01 <lpsmith> Self published or do you have a publisher?
12:11:12 <BONUS> lpsmith: no starch press
12:11:31 <BONUS> that's why new chapters haven't been coming out as much cause we've been busy editing the old ones
12:11:39 <BONUS> but it'll still stay free on the net, even the new stuff
12:11:50 <c_wraith> sounds good
12:12:14 <benmachine> http://twitter.com/mmorrowÂ I am going to hazard that this is not him
12:12:25 <BONUS> benmachine: that ain't him
12:12:52 <yitz> BONUS: if anyway it's staying free, why not use the comments blog app that they used for rwh?
12:13:01 <lpsmith> sweet!   I have a self-publishing project in the works that's unfortunately stalled out at this point.    But it's also something that is... unusual...  (and not a book) so I'm not sure who would take it on anyway.
12:13:12 <yitz> you'll get some good input and free editing
12:13:21 <fax> lpsmith, what is it?
12:13:23 <benmachine> daaang there are more mmorrows than you might think
12:13:31 <BONUS> yitz: yeah i thought about that, but i'd have to rearrange everything to integrate it
12:13:37 <yitz> yeah, hundreds of them
12:13:46 <yitz> but only one haskeller
12:14:05 * yitz nods
12:14:50 <yitz> BONUS: what doc format are you using?
12:15:01 <lpsmith> fax,  it's a manipulative for teaching plane geometry and the dihedral group of the square that's difficult to describe without seeing a sample
12:15:21 <fax> lpsmith oh cool - but why mass produce it?
12:15:31 <fax> rather than just putting up instructions
12:15:58 <lpsmith> Umm... the only printing press I know that's capable of doing what I want costs about a million dollars :)
12:16:00 <BONUS> yitz: i'm just straight up manually writing html :D
12:16:22 <fax> wow what is it tat needs done/
12:16:23 <fax> ?
12:16:35 <yitz> BONUS: your publisher can get by with css?
12:16:49 <lpsmith> fax:  4 colors front and back in perfect registration
12:16:55 <scotty> If I have two data constructors for a type, how do I specifiy that a function only operates on instances of the type constructed with one of the two data constructors?
12:17:00 <fax> hm
12:17:06 <yitz> or are you using XSLFormatting
12:17:09 <kmc> scotty, you can't
12:17:15 <kmc> scotty, make more types
12:17:21 <scotty> So, I just let it error if they pass in the wrong thing?
12:17:46 <kmc> scotty, or return in Maybe
12:17:49 <kmc> or make more types
12:17:57 <scotty> okay
12:17:57 <BONUS> yitz: oh nah, when i submit it to the publisher for editing, i rewrite it in latex
12:18:10 <BONUS> not the most efficient thing for me but oh well
12:18:15 <kmc> e.g. data AOnly = AOnly ....stuff....;  data BOnly = BOnly ....stuff....; data AOrB = IsA AOnly | IsB BOnly
12:20:59 <orlandu63> you can use Either AOnly BOnly for the last one
12:21:05 <hpaste>  liftAN in Agda (dolio)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24936
12:21:25 <hpaste>  . (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24937
12:21:31 <dolio> Mathnerd314: ^^
12:21:36 <cads> hmm.. I'm getting "type constructor not in scope" error in this file I'm trying to compile. The constructor is SomeException from Control.Exception, but the package is imported at the top of the file so I don't know what's up.
12:21:53 <cads> that last Hpaste was me
12:22:10 <scotty> Is there a way to do the following with an as pattern?:
12:22:10 <scotty> data MyType = MyType { mtvalue :: Integer, mta :: String, mtb :: String}
12:22:11 <scotty> foo :: MyType -> Integer
12:22:12 <scotty> foo m@(MyType) = mtvalue m
12:22:24 <cads> the line using SomeException is the second to last line, any ideas what's the matter with it?
12:22:25 <scotty> I want to avoid pattern matching every element of MyType.
12:22:29 <scree> cads: you've imported qualified, no?
12:22:39 <scree> cads: so you need E.SomeException
12:22:41 <scotty> So, I thought I could use an as-pattern to save text.
12:22:57 <mauke> scotty: what's wrong with foo = mtvalue?
12:23:18 <scree> cads: or, add "import Control.Exception (SomeException)"
12:23:27 <scotty> Oh, okay.  So, foo becomes a function then?
12:23:35 <scotty> That's awesome.
12:23:37 <mauke> yes, since mtvalue is
12:23:39 <cads> scree: that's the darndest thing because I've already tried E.SomeException and no dice
12:23:51 <cads> I'll try importing it like you say
12:24:33 <dolio> Mathnerd314: That's a lot more painful in Haskell, because you need witness types for lots of stuff to help GHC's inference algorithm (instead of passing types explicitly in Agda).
12:24:36 <cads> oh..
12:24:55 <cads> Control.Exception doesn't seem export someException
12:24:59 <cads> seem to*
12:25:13 <Mathnerd314> dolio: yeah... Template Haskell is definitely much less painful than either of those
12:25:51 <scree> cads: and what I said earlier was total rubbish ... no "qualified"
12:26:00 <Mathnerd314> dolio: I can see sort of how it works though
12:26:07 <mauke> cads: what version of ghc?
12:26:14 <benmachine> cads: which version of base?
12:26:47 <cads> base 3.0.3.1, ghc 6.10.4
12:27:11 <cads> this is 2009.2.0.2
12:27:36 <benmachine> why aren't you using base 4?
12:27:59 <benmachine> I believe the exception mechanism changed
12:28:02 <scotty> Actually, here's what I'm trying to do: http://pastebin.com/2ERWSpzV
12:28:20 <scotty> I don't know how I can do it without pattern matching in this case.
12:29:01 <cads> benmachine: this is a plain install from the windows installer
12:29:09 <kmc> scotty, what are you trying to change?
12:29:13 <benmachine> cads: how are you compiling?
12:29:20 <benmachine> scotty: there are a few things you can do
12:29:27 <benmachine> e@(Entry {}) should work
12:29:34 <scotty> kmc: What I posted doesn't work, since Entry has multiple parameters.
12:29:35 <monochrom> pattern matching is fine for this. in advanced programming, you can write a general "fold" function to hide pattern matching, by the "fold" function itself uses pattern matching.
12:29:39 <kmc> scotty, this is essentially equivalent to Prelude's lookup on [(String, Integer)], except that will return in Maybe
12:29:54 <monochrom> s/by/but/
12:29:58 <kmc> scotty, what benmachine said.  or you can get at the stuff explicitly by
12:30:01 <mauke> scotty: why are you using an @-pattern there?
12:30:09 <benmachine> you could also match with the pattern Entry { ename = en } and then use en instead of (ename e)
12:30:11 <kmc> dlookup name (Entry { ename = n, evalue = v, erest = r })
12:30:17 <benmachine> yeah, like that
12:30:30 <mauke> dlookup name e | ...
12:30:33 <kmc> scotty, or, look at GHC's RecordWildCards and NamedFieldPuns extensions
12:30:33 <scotty> mauke: So that I don't have to type (Entry n v r)
12:30:35 <cads> benmachine: I'm trying to run the cabal install on hmatrix 0.9.2.0 and it halts on the error.
12:30:35 <kmc> for nicer syntax
12:30:39 <mauke> scotty: uh, just type e
12:30:49 <kmc> e.g. you can just say dlookup name (Entry{..})
12:31:02 <cads> benmachine: do I need to upgrade to base 4 somehow?
12:31:06 <scotty> mauke: I want it to be clear that it's not an Empty
12:31:12 <kmc> and the field selectors ename,evalue,erest will be shadowed locally by the values for those fields in this particular struct
12:31:12 <benmachine> cads: probably you just need to tell cabal install to use base4
12:31:18 <mauke> scotty: stop that
12:31:25 <kmc> scotty, but maybe what you should do is factor the list structure out of the pair structure
12:31:52 <benmachine> cads: try editing the .cabal file to put an upper bound on the base dependency
12:31:56 <benmachine> actually
12:32:04 <benmachine> you should use base >= 4 && < 5
12:32:53 <cads> hmm, maybe the developer has base 4 installed and no base 3, whereas in my environment it's defaulting to 3.
12:33:40 <benmachine> maybe, but I'm pretty sure you get base 3 free with any GHC
12:33:40 <cads> benmachine:  ah. Right now it's base >= 3 && < 5
12:33:43 <scotty> kmc: What do you mean?
12:33:43 <benmachine> ah
12:33:56 <benmachine> that's odd, I wonder why it's picking base 3 for you then
12:34:04 <benmachine> try base >= 4 anyway
12:34:12 <dv-> There's a base > 4?
12:34:14 <kmc> scotty, your Dictionary type is like a list
12:34:21 <cads> benmachine: I did, and it's working!
12:34:28 <kmc> scotty, specifically it's very much like the type [(String,Integer)]
12:34:43 <benmachine> dv-: base-4.2.0.0 is the latest as far as I know
12:35:15 <kmc> scotty, do you see?
12:35:30 <cads> benmachine: Thanks for the help!
12:35:47 <scotty> Yeah, I'm thinking about it. So, does Prelude have a built-in function to look-up things in that format?
12:36:13 <monochrom> @type lookup
12:36:14 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
12:36:19 <kmc> scotty, yes
12:36:27 <kmc> scotty, also, this is a very inefficient way to store an associative data structure
12:36:36 <monochrom> > lookup "hi" [("hello", 4), ("hi", -3)]
12:36:37 <lambdabot>   Just (-3)
12:36:43 <kmc> scotty, you know about Data.Map?
12:36:44 <monochrom> > lookup "hl" [("hello", 4), ("hi", -3)]
12:36:45 <lambdabot>   Nothing
12:36:58 <monochrom> @type M.lookup
12:36:58 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> Maybe a
12:37:05 <kmc> there's probably some valid use case for assoc lists, but i think generally Data.Map is the best first choice
12:37:50 <monochrom> > M.lookup "hi" (M.fromList  [("hello", 4), ("hi", -3)])
12:37:51 <lambdabot>   Just (-3)
12:38:30 <benmachine> assoc lists can be lazier
12:38:34 <benmachine> can have non-orderable keys
12:38:41 <benmachine> and are simpler to handle, arguably
12:38:59 <kmc> the simplest (K, V) associative data type is simply K -> Maybe V
12:39:15 <kmc> same efficiency as assoc list (at least a naive one)
12:39:44 <kmc> this is the easiest type for proving theorems
12:39:48 <monochrom> more efficient in the infinite case
12:40:23 <Jafet> http://hackage.haskell.org/packages/archive/procrastinating-structure/1.0.1/doc/html/Data-PVar-Queue.html
12:40:35 <Jafet> "I think it fits the definition of referentially transparent"
12:40:39 <monochrom> hahaha "procrastinating structure"
12:41:14 <monadic_kid> 2010.1.0.0 Haskell Platform released
12:41:16 <benmachine> a pretty good description of my laptop
12:41:36 <Jafet> These packages are marvellous
12:42:20 <yitz> kmc: i disagree, Data.Map is premature optimization in more cases than you think.
12:42:30 <benmachine> ooh I like :$
12:42:50 <Jafet> yitz, huh? I use Map when I mean Map.
12:42:51 <yitz> assoc lists are the simplest, stay with them unless you have reason to believe that your assoc list will grow quite large.
12:42:56 <benmachine> (infixr 9 :$
12:42:56 <benmachine> type a :$ b = a b
12:42:56 <poincare101> Hmmm... I'm reading LYAH and I can't figure out what the heck a lazy language means and what the point of it is. Can someone explain?
12:43:09 <kmc> poincare101, it means expressions are not evaluated until needed
12:43:09 <Jafet> I use assoc lists when I mean assoc lists.
12:43:10 <kmc> for example
12:43:13 <Jafet> They are not the same thing.
12:43:15 <kmc> > let a = 2 + 3 in 'x'
12:43:16 <lambdabot>   'x'
12:43:20 <kmc> poincare101, ^^^^ did not add 2 and 3
12:43:23 <kmc> because we never used 'a'
12:43:32 <fax> > let a = 2 + 3 in 'a'
12:43:33 <lambdabot>   'a'
12:43:33 <benmachine> > let a = sum [1 .. 1000000] in "banana"
12:43:34 <lambdabot>   "banana"
12:43:38 <Mathnerd314> :t Prelude.return
12:43:38 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
12:43:41 <monochrom> Data.Map has a richer API than Data.List for assoc purposes.
12:43:49 <kmc> poincare101, technically "lazy evaluation" is one particular strategy for implementing "non-strict semantics"
12:43:56 <kmc> poincare101, but often the terms are used interchangeably
12:44:16 <kmc> poincare101, the point of it is a) avoid unnecessary work b) allow some programs to work when they'd break with strict eval
12:44:22 <kmc> poincare101, for example, we can make infinite lists
12:44:23 <Mathnerd314> hm, how do I refer to the Prelude's definition of Monad?
12:44:27 <dmwit> > let a = error "this error would definitely happen in an eager language" in 32
12:44:28 <lambdabot>   32
12:44:29 <kmc> Mathnerd314, Prelude.Monad /
12:44:33 <kmc> Prelude.Monad?
12:44:34 <yitz> monochrom: not really, they are just different styles. like Jafet said.
12:44:49 <kmc> > let n = 1 : map succ n in n
12:44:49 <Jafet> I said quite the opposite.
12:44:50 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
12:44:52 <kmc> poincare101, ^^^^ an infinite list
12:45:02 <kmc> poincare101, but we can take arbitrarily many elements off it in finite time
12:45:04 <yitz> Jafet: you said they are two different things, right?
12:45:11 <Jafet> [("a", 1), ("a", 2)] -- valid assoc list
12:45:12 <kmc> because it will not actually do the work to compute the nth element until we ask for it
12:45:29 <yitz> ah, that's what you meant.
12:45:41 <kmc> and in a strict language it would be stuck forever computing the "full" value of n, before generating any output
12:45:47 <monadic_kid> poincare101: I'm sure you've written that had value that was lazily evaluated, maybe never knew the term before
12:46:00 <yitz> true, Data.Map enforces uniqueness at runtime. that can be good or bad.
12:46:04 <monochrom> Then let's argue Data.MultiMap vs Data.List
12:46:13 <kmc> multimap?
12:46:24 <monadic_kid> poincare101: *I'm sure you've written a program that had a value that was lazily evaluated, maybe you never knew the term before
12:46:54 <scotty> Hey, sorry. Someone called. So what I'm using right now is considered an associative list?
12:46:59 <kmc> yeah
12:47:10 <kmc> except that you've sort of unfolded the pair into the list cells
12:47:22 <poincare101> kmc: thanks a lot (still reading)
12:47:26 <poincare101> BONUS: you're awesome!
12:47:27 <yitz> poincare101: are you already comfortable with some other programming language?
12:47:34 <scotty> It looks like Data.Map involves monads. I'm still reading Gentle Intro to Haskell and I don't know much about them yet.
12:47:35 <kmc> poincare101, one fundamental Haskell concept is this: In many languages, functions play three roles: argument dependence, delayed evaluation, and side effects.  In Haskell these three things are handled by three different language features.
12:47:35 <poincare101> yitz: C, Python, Perl
12:47:43 <BONUS> poincare101: no, YOU are!
12:47:58 <yitz> poincare101: oh. ever use generators in python?
12:47:59 <scotty> What is "Just (-3)?"
12:48:07 <poincare101> yitz: sort of. yeah.
12:48:12 <benmachine> scotty: it's a value of type Maybe Integer
12:48:19 <benmachine> well
12:48:19 <kmc> @src Maybe
12:48:19 <lambdabot> data Maybe a = Nothing | Just a
12:48:25 <benmachine> pedantically, Num n => Maybe n
12:48:35 <Jafet> scotty, you don't need to know anything about monads to use Map...
12:48:37 <yitz> poincare101: so that's the idea for lists. in haskell, laziness applies for every funcion (by default)
12:48:42 <Jafet> Well, unless you want to use the typeclasses.
12:49:04 <benmachine> I think purity is more important to understanding Haskell than laziness
12:49:09 <dmwit> scotty: "Maybe a" is Haskell's answer to having a null pointer. It takes a type, and makes a new type that can either be null or have a value of the given type. "Nothing" is the null; "Just foo" is the value.
12:49:10 <poincare101> kmc: that's pretty cool. Lemme try something...
12:49:12 <benmachine> once you understand purity, laziness is easier
12:49:30 <poincare101> let a = 2+3
12:49:35 <kmc> laziness applies not just for every function
12:49:39 <kmc> in applies for every value
12:49:47 <kmc> (except for a few fringe cases)
12:49:50 <poincare101> > let a = 2+3
12:49:51 <lambdabot>   not an expression: `let a = 2+3'
12:49:55 <poincare101> ?
12:49:58 <dmwit> poincare101: prepend "> " to ask \bot to run your code; also, "let" blocks need an "in" clause
12:50:01 <kmc> poincare101, the syntax is "let ... in ..."
12:50:04 <fax> > let a = 2 + 3 in 'a'
12:50:05 <lambdabot>   'a'
12:50:10 <burp> hrhr
12:50:13 <burp> @let a = 2+3
12:50:13 <kmc> poincare101, unless you're in a "do" block (which GHCi implicitly is, but lambdabot isn't)
12:50:14 <lambdabot>  Defined.
12:50:15 <poincare101> > let a = 2+3 in 'a'
12:50:15 <burp> > a
12:50:15 <lambdabot>   'a'
12:50:16 <lambdabot>   Ambiguous occurrence `a'
12:50:16 <lambdabot>  It could refer to either `L.a', defined at <local...
12:50:17 <scotty> dmwit: Okay, cool. I get it.
12:50:19 <burp> > La
12:50:20 <lambdabot>   Not in scope: data constructor `La'
12:50:20 <burp> > L.a
12:50:21 <lambdabot>   5
12:50:21 <fax> XD
12:50:41 <poincare101> kmc: what does the in do?
12:50:41 <benmachine> @undefined
12:50:51 <yitz> @undef
12:51:02 <kmc> poincare101, well, "let" introduces some names for expressions
12:51:09 <dons> the installer and torrent for the Windows Haskell 2010.1.0.0 platform is now live.
12:51:12 <kmc> the scope of those names is the stuff after "in"
12:51:14 <yitz> @botsnack
12:51:14 <lambdabot> :)
12:51:18 <dons> thanks to refold for all the hard work on the installer!
12:51:18 <scotty> So, if I want to pull the data out of "Just", I just pattern match?
12:51:25 <dmwit> scotty: right
12:51:26 <benmachine> @notsnack
12:51:26 <kmc> scotty, yes
12:51:26 <lambdabot> :)
12:51:29 <kmc> using "case" e.g.
12:51:30 <cybercobra> @type Set
12:51:31 <lambdabot> Not in scope: data constructor `Set'
12:51:33 <dons> Get yr' windows installers here: http://haskell.org/platform/
12:51:33 <kmc> or you can use some functions
12:51:34 <kmc> :t maybe
12:51:35 <poincare101> >let a = 2+3 in 'x'
12:51:35 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
12:51:35 <scotty> Alright, I'll give that a shot.
12:51:36 <kmc> :t fromMaybe
12:51:36 <scotty> Thanks
12:51:36 <yitz> @hotsnack
12:51:37 <lambdabot> :)
12:51:37 <lambdabot> forall a. a -> Maybe a -> a
12:51:40 <cybercobra> @type Data.Set.Set
12:51:41 <lambdabot> Not in scope: data constructor `Data.Set.Set'
12:51:47 <dmwit> ?quote sprynge
12:51:47 <lambdabot> Cale says: Beware of the function [a] -> a. For it may contain trappes and sprynges of great variety and harm.
12:51:49 <poincare101> >let a = 2+3 in 'a'
12:51:58 <kmc> poincare101, if a and b are expressions and x is a variable, then "let x = a in b" is another expression
12:52:25 <kulin> you are also messing up types, there is a lot you are getting wrong in that statement
12:53:07 <Jafet> Hrm, which of the five sqlite bindings on hackage should I use?
12:53:08 <kmc> ?
12:53:40 <benmachine> Jafet: write two packages to convert between them, then interleave the use of all of them randomly
12:53:43 <kulin> http://www.haskell.org/tutorial/index.html this is a really good read, that combined with ghci is a perfect way to learn the basics of haskell
12:53:47 <yitz> @type S.Set
12:53:48 <lambdabot> Couldn't find qualified module.
12:53:54 <Jafet> Good idea
12:53:58 <monochrom> benmachine++
12:54:29 <cybercobra> yitz: i'm trying to figure out if it has an instance for Ord
12:54:50 <yitz> @hoogle Set
12:54:50 <lambdabot> module Data.Set
12:54:50 <lambdabot> Data.Set data Set a
12:54:51 <lambdabot> Network.Browser setAllowBasicAuth :: Bool -> BrowserAction t ()
12:55:06 <Jafet> I'll go with Takusen, since it has a nice blurb
12:55:10 <yitz> hmm there is a lambdabot command for that
12:55:22 <yitz> @help instance
12:55:22 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:55:26 <Jafet> @instances Ord
12:55:26 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
12:55:31 <poincare101> > let a = 2+3 in 'a'
12:55:32 <lambdabot>   'a'
12:55:39 <yitz> @help instances
12:55:39 <lambdabot> instances <typeclass>. Fetch the instances of a typeclass.
12:55:41 <benmachine> @instances-importing Data.Data Data
12:55:42 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, [a]
12:55:45 <benmachine> oh is that all
12:55:49 <poincare101> > let a = 2+3 in 'a'\n a
12:55:50 <lambdabot>   <no location info>: parse error on input `\'
12:55:54 <poincare101> > let a = 2+3 in 'a' a
12:55:55 <lambdabot>   Couldn't match expected type `t1 -> t'
12:55:55 <lambdabot>         against inferred type `GHC.T...
12:55:55 <cybercobra> @instances-importing Data.Set
12:55:56 <lambdabot> Couldn't find class `Data.Set'. Try @instances-importing
12:56:01 <poincare101> > let a = 2+3 in 'a'
12:56:02 <lambdabot>   'a'
12:56:02 <poincare101> a
12:56:05 <poincare101> > a
12:56:06 <lambdabot>   a
12:56:07 <benmachine> :info Data is fun after you've imported something like haskell-src-exts
12:56:14 <benmachine> or something else ADT-heavy
12:56:44 <monochrom> "my God, it's full of Data"?
12:57:06 <kulin> poincare101: 'a' is a character, you probably want let a = 2 + 3 in a but that is a really round about way of typing (2+3) or 5
12:57:18 <yitz> > S.fromList [(0,1),(2,3)]
12:57:19 <lambdabot>   fromList [(0,1),(2,3)]
12:57:35 <yitz> > S.fromList [(0,1),(2,3)] > S.fromList[(4,5)]
12:57:36 <lambdabot>   False
12:57:47 <monochrom> I always use roundabout ways to learn things
12:57:47 <yitz> cybercobra: so it looks like yes
12:58:44 <yitz> > S.fromList [(0,sum)] > S.fromList[(0,product)]
12:58:45 <lambdabot>   No instance for (GHC.Classes.Ord ([a] -> a))
12:58:45 <lambdabot>    arising from a use of `Data...
12:59:09 <Jafet> How derivative.
12:59:14 <yitz> cybercobra: so it only works if the value type has an Ord instance
13:00:07 <scotty> How do I get around having to say Map.lookup?
13:00:14 <cybercobra> yitz: okey-dokey
13:00:34 <scotty> (lookup is ambiguous)
13:00:40 <Twey> scotty: import Prelude hiding (lookup)
13:01:00 <yitz> import qualified Data.Map as M -- then you can use M.lookup
13:01:15 <benmachine> scotty: but there's also map and filter and whatever else, so you are probably better off with the qualified import in the end
13:02:20 <scotty> Qualified import?  I just did "import Data.Map as Map."  Is that what that is?
13:02:23 <yitz> right. except often you'll also say import Data.Map ((!)) -- because that doesn't conflict with the Prelude and it's *much* nicer to use ! unqualified
13:02:34 <scotty> What does the "qualified" keyword specify?
13:02:36 <kmc> scotty, qualified import uses the "qualified" keyword
13:02:43 <kulin> scotty, you want import qualified Data.Map as Map, if you dont use 'qualified' you are just aliasing the import
13:02:45 <yitz> as I wrote above
13:02:48 <kmc> scotty, it specifies that you *need* the module name to use it
13:02:50 <kulin> qualified says you must always use the alias
13:02:58 <scotty> Oh
13:03:00 <Twey> It would be nice to be able to specify a default for modules in case of ambiguous lookups
13:03:18 <kmc> with "import Data.Map as M" you can say "lookup" or "M.lookup", but the former will be ambiguous.  with "qualified" there you can only say "M.lookup" and so Prelude's lookup isn't ambiguous
13:03:27 <scotty> Okay
13:03:31 <Twey> E.G. import Data.Map overriding (Prelude) â€” specifies that in the case of a conflict between Prelude and Data.Map, Data.Map wins
13:03:32 <scotty> Sounds like something to use all the time then.
13:04:07 <yitz> Twey: that sounds potentially flaky to me. i like it the way it is.
13:04:13 <Jafet> Just qualify all imports, including prelude.
13:04:15 <Twey> *shrug*
13:04:20 <kulin> it depends, sometimes you will import a library with no conflicts and then you can just use 'import Whatever.Library' and your code will be pretty
13:04:49 <benmachine> I just wish someone would invent a new punctuation character so we could use it for qualified names without killing composition
13:04:54 <Jafet> import Data.Map following (Haddock)
13:04:57 <kulin> i dont like all the periods that you get from qualified names, ya ben
13:05:00 <scotty> kulin: Yeah, I want the pretty code! :-(  But I don't want to get myself or someone else confused.
13:05:06 <yitz> Jafet: do they make keyboards with a reinforced "." key?
13:05:10 <fax> what about typeclasses
13:05:28 <poincare101> BONUS: I like your drawings, they liven the text up quite a bit :)
13:05:34 <Jafet> I hope not! It's expensive enough to get reinforced C- M- S-.
13:05:50 <BONUS> poincare101: thanks :) big blocks of text get boring quickly
13:06:01 <BONUS> preview: here's the newest drawing that's going up soon: http://learnyouahaskell.com/pirateship.png
13:06:06 <yitz> Jafet: I guess you could bind "." to one of those
13:06:22 <Jafet> That sounds like a plan.
13:06:25 <scotty> Ha-ha!  Nice drawing!
13:06:41 <benmachine> BONUS: 1 0 ()?
13:06:51 <benmachine> ohh IO ()?
13:06:53 <systemfault> BONUS: What do you use to draw? :P
13:06:59 <benmachine> or not
13:07:04 <BONUS> benmachine: monoids!
13:07:08 <yitz> BONUS: Cool! Does that mean you're going to use a p2p client as an example?
13:07:14 <benmachine> BONUS: ohh ok
13:07:20 <BONUS> systemfault: Flash 8 :(
13:07:29 <systemfault> Haha :)
13:07:32 <dmwit> By default, importing a module defines two names for each function exported by that module: "name" and "Module.name". The "qualified" keyword says not to define the former. The "as Foo" clause say to define an additional name, "Foo.name".
13:07:39 <BONUS> yitz: actually i just felt like drawing a gay pirate ship but that would be a cool example!
13:07:42 <benmachine> BONUS: mappend bones bones = skull?
13:07:50 <BONUS> haha
13:08:14 <dons> BONUS: does that mean more chapters soon?
13:08:42 <yitz> BONUS: ever try inkscape?
13:08:42 <BONUS> dons: yeah. new chapters have been kind of lacking cause we've been busy with editing the old ones :\
13:08:57 <dons> ah for the paper book?
13:09:00 <BONUS> yup
13:09:02 <dons> yay!!
13:09:24 <BONUS> yitz: nope, but i've heard good things about it
13:09:53 <BONUS> yeah, most of my work now is on the real paper book, but it's going down!
13:10:38 <BONUS> don't tell anyone i'm showing y'all this, but this is what i've imagined for the cover: http://dl.dropbox.com/u/665999/cover1.png
13:10:49 <BONUS> we're gonna see what the designer at the publishing house thinks about this
13:11:07 <kmc> BONUS, i'm sure your secret is safe with all 704 of us and the public log bot
13:11:15 * Twey snrk
13:11:18 <poincare101> :)
13:11:23 <BONUS> yes, i am counting on that
13:11:25 <Twey> I thought you were Finnish, BONUS
13:11:26 <dmwit> this... this is AWESOME
13:11:26 <dons> we gotta get the buzz out about the LYAH book :)
13:11:29 <Twey> Oh no, wait
13:11:35 <BONUS> dons: not just yet!
13:11:35 <dons> wow
13:11:36 <Twey> You're the Slovenian
13:11:45 <BONUS> but soon ... *rubs hands*
13:11:50 <fax> I thought it was gonna be a  narwhale
13:11:55 <dons> can't hurt to build expectations :)
13:11:57 <Twey> Nice cover :Ã¾
13:11:58 <dons> is there a pre-order yet?
13:12:13 <systemfault> Is there a pre-order yet? :)
13:12:14 <BONUS> dons: nah. that's what i'm waiting for before spamming the hell out of everything
13:12:16 <Twey> â€˜No, but there's a pre-pre-orderâ€™
13:12:17 <systemfault> :/
13:12:39 <dons> BONUS: we did good on RWH with pre-order about 6 months prior
13:12:44 <Twey> You pay a little extra and they put you on the pre-order list automatically when it opens
13:12:47 <dons> huge shipments on release day
13:13:00 <dons> which helped o'reilly feel more comfortable, i think
13:13:00 <systemfault> I pre-ordered it :P
13:13:23 <BONUS> awesome. yeah i gotta see about the preorder ASAP. i just gotta get this cover confirmed and then i think it's good for preorder
13:13:41 <dons> the cover confuses me
13:13:48 <dons> is the programmer the knight?
13:13:51 <dons> and haskell the tiny horse?
13:13:56 <BONUS> nah, it's just a funny picture
13:13:58 <dons> that seems unsuited for real tasks...
13:14:06 <dons> well, says me, with the GIANT BUG on the cover
13:14:10 <BONUS> :D
13:14:11 <BONUS> haha
13:14:16 <BONUS> although i like this one too http://dl.dropbox.com/u/665999/cover5.png
13:14:23 <Jafet> At least there's only one!
13:14:29 <poincare101> http://dl.dropbox.com/u/665999/cover1.png
13:14:30 <dons> i have to say i really like the pirate ship!
13:14:34 <poincare101> whoops!
13:14:40 <BONUS> or we could do the pirate ship as well yeah hmm
13:14:41 <benmachine> is that a subtle allusion to rwh?
13:14:47 <dmwit> "hello, world!"
13:14:54 <BONUS> this one is the world saying hello back to you
13:14:57 <benmachine> heh
13:15:00 <benmachine> nice
13:15:04 <dons> the elephant with glasses is also somewhat iconic for LYAH
13:15:04 <poincare101> BONUS: I like other one better (the one with the night)..
13:15:08 * dmwit is now looking at covers1-5
13:15:14 <benmachine> I quite like the globe
13:15:27 <poincare101> The monkey's cool..
13:15:41 <dons> yes, monkey++
13:15:49 <BONUS> hmmm!
13:15:51 <benmachine> agreed
13:15:52 <dons> we clearly need a condorcet anonymous internet voting system to solve this
13:16:25 <dons> the monkey definitely has the fun of LYAH captured nicely
13:16:54 <dons> and it hints at unicycles
13:16:54 <BONUS> yeah, it seems to be having fun, although i'm worried that the monkey has a bit *too much* goin on
13:17:00 <dons> which are an important theme in haskell land
13:17:04 <BONUS> true
13:17:10 <dons> shapr: not enough unicycles, right??!
13:17:14 <scotty> Why is this not working?: http://pastebin.com/ieLiwsU1
13:17:18 <dmwit> Yeah, my reaction to that one was that it was too busy, too.
13:17:28 <dons> monkey on a unicycle. 'nuff said :)
13:17:39 <dmwit> scotty: See my description of the "qualified" keyword above.
13:18:04 <indigopenguin> You'll have to say Map.Map and Map.fromList
13:18:07 <dmwit> scotty: If you import Data.Map qualified, it doesn't define the "fromList" name -- only Data.Map.fromList (and Map.fromList because you have an "as Map" clause).
13:18:09 <yitz> I have this feeling that the publisher is going to decide in the end. they'll probably just use a bug.
13:18:24 <monochrom> scotty: Map.Map, Map.fromList
13:18:28 <Twey> Heh
13:18:34 <monochrom> or just delete "qualified"
13:18:48 <scotty> Oh, I have to say Map.Map!
13:18:50 <Jafet> Who is the publisher?
13:18:51 <yitz> hey, it sells.
13:19:06 <dons> apress?
13:19:08 <Nebasuke> scotty: or like this: http://pastebin.com/0fLFNHXn
13:20:12 <kmc> dons, "Haskell makes your bugs really big so you can find them and squash them!"
13:20:18 <scotty> I see.  So you're using a qualified import and then just making an alias specifically for the type "Map?"
13:20:20 <kmc> it's an analogy for type checking, of course
13:20:21 <dons> also, it is an enormously strong bug.
13:21:06 <yitz> it's an enormously strong creature of any kind
13:21:38 <Nebasuke> indeed
13:23:06 <monadic_kid> dons: where can find a changelog for the platform release?
13:23:09 <scotty> Alright, is this too verbose?: http://pastebin.com/3av1WYz9
13:23:38 <dons> monadic_kid: there's no change log, but you can find the contents specified here: http://hackage.haskell.org/platform/contents.html
13:23:40 <poincare101> something that really helps me understand haskell is scheme/lisp. It seems sorta similar...
13:23:46 <dons> monadic_kid: what kind of change log were you looking for?
13:23:49 <yitz> dons it's no starch press
13:23:51 <dv-> dons: do you know if anyone is working on getting a newer port of ghc in openbsd?
13:23:51 <dmwit> scotty: There's fromJust.
13:23:53 <dons> no starch!
13:23:57 <dmwit> scotty: But BOO on partial functions!
13:24:03 <dmwit> scotty: Don't use 'em!
13:24:04 <dons> dv-: kili is (mattias killian)
13:24:10 <BONUS> ya
13:24:15 <Botje> scotty: look at the "maybe" function
13:24:16 <dmwit> And don't write 'em, either!
13:24:18 <scotty> dmwit: Ahhh, what? :-O
13:24:22 <Botje> it can replace your looky'
13:24:27 <dmwit> scotty: looky' = fromJust
13:24:30 <monadic_kid> dons: more than which newer version of ghc has been updated too
13:24:33 <dv-> dons: thanks
13:24:33 <BONUS> i think o'reilly is distributing or something and no starch publishing
13:24:37 <kmc> poincare101, there are similarities definitely
13:24:39 <poincare101> dv-: why does ghc not work on openbsd by default?
13:24:41 <dmwit> scotty: But you shouldn't use fromJust, or write it yourself; you should actually say what to do with a Nothing instead.
13:25:01 <kmc> right.  not having to specify what to do on "null" every time something might be null is Java's "billion dollar mistake"
13:25:04 <dons> monadic_kid: so currently we just list all version numbers of packages
13:25:11 <scotty> dmwit: I want Nothing to throw an error
13:25:13 <dons> and you can refer to the individual package project pages for details
13:25:21 <monadic_kid> dons: k
13:25:23 <dv-> poincare101: I don't think the source just compiles, no. And the port/package is still 6.6.1
13:25:23 <dons> it will be hard to get more detailed info, since the projects are distributed
13:25:36 <dons> e.g. like GNOME, the HP just integrates stable things together
13:25:39 <kmc> poincare101, Haskell is a lot more comprehensible if you're familiar with basic functional programming.  scheme and lisp are classic functional programming languages, but also you can do FP in any decent language
13:25:43 <kmc> people do FP a lot in Python and C#
13:25:45 <dons> and doesn't actually manage the components directly
13:26:09 <Gwern-away> bleh. how do I find the members of the xmonad-p group on c.h.o?
13:26:30 <dv-> poincare101: it would be nice if big apps like ghc (and firefox, ...) were compatible with all unices, not just linux
13:26:33 <kmc> poincare101, but Haskell has a lot of stuff not found in those languages
13:26:40 <twink> Python has higher-order functions?
13:26:45 <kmc> twink, yeah
13:26:50 <kmc> map and filter are even in the std lib
13:26:51 <yitz> Gwern-away: one sec I'll get it for you
13:26:55 <kmc> though guido has some stupid vendetta against them
13:27:09 <sepp2k1> foldl too
13:27:14 <Gwern-away> xmonad-extras-p:!:1533:dmwit,aavogt,dschoepe
13:27:18 <kmc> yeah "reduce"
13:27:19 <Gwern-away> that's not right...
13:27:23 <kmc> twink, Python's lambda is syntactically limited, but you can get closure without those limits by using a nested named def
13:27:26 <poincare101> dv-: what errors is it having? I mean, aside from networking stuff, there shouldn't be much problems. And, networking shouldn't be that hard to fix..
13:27:28 <kmc> and Python's scoping rules are a bit odd
13:27:33 <scotty> dmwit: I'm writing a lisp interpreter, and if the result of a lookup result in a Nothing, it means that the code I was given is incorrect.  What else could I do but throw an error?
13:27:33 <kmc> but i think their closures are reasonable wrt those rules
13:27:43 <dmwit> scotty: That's fine, just don't come crying to us later when the headaches start. ;-)
13:27:44 <yitz> yitz@nun:~$ grep xmonad-p /etc/group
13:27:44 <yitz> xmonad-p:!:1032:sjanssen,dons
13:27:47 <Gwern-away> ah, there we go
13:27:48 <Gwern-away> xmonad-p:!:1032:sjanssen,dons
13:27:53 <dmwit> scotty: We're just going to say "we told you so". =)
13:27:54 <Gwern-away> I was logged into community, not code
13:28:08 <yitz> ha
13:28:15 <twink> kmc: I'll have to look it up. I touch Python seldom enough to miss significant details.
13:28:18 <dv-> poincare101: I haven't tried, but from the ghc page on porting, it seems to be quite tricky
13:28:21 <Igloo> community and code are the same machine
13:28:22 <scotty> dmwit: I asked "what else could I do?"  I honestly want to know.  I'm trying to heed your warning.
13:28:26 <yitz> Gwern-away: same machine
13:28:28 <Gwern-away> funny. I thought there were more than 2 committers for xmonad
13:28:32 <poincare101> wow. Haskell seems like the perfect language. It combines my love for mathematics and my liking for clean syntax and lisp.
13:28:46 <Gwern-away> Igloo: are they the same OS?
13:28:47 <dmwit> scotty: Just go ahead and propogate the Maybe-ness everywhere.
13:28:50 <kmc> poincare101, i think the connection between Haskell and maths is actually a bit overblown in the popular programming media / blogs
13:28:59 <kmc> poincare101, but it's stronger than most languages
13:29:04 <dmwit> scotty: i.e. don't bother with looky at all, and just use Map.lookup with the type it has
13:29:19 <Igloo> Gwern-away: Yes
13:29:22 <poincare101> kmc: its completely based off lambda calculus, what more could you ask for?
13:29:24 <Gwern-away> hm
13:29:32 <kmc> poincare101, it's definitely the case that Haskell makes a lot of sense to someone used to thinking about maths
13:29:32 <poincare101> :)
13:29:34 <dmwit> scotty: We've got lots of great ways of combining Maybe values available, including feeding Maybe values to functions that don't take them, or to functions that return them.
13:29:40 <kmc> poincare101, most languages are
13:29:52 * poincare101 is happy and feeling quite nice. Kudos (once again) to BONUS
13:29:54 <lowasser> kmc: idk, I've just been some combinatorics and translating to/from haskell is gloriously easy
13:29:57 <BONUS> :)
13:30:01 <yitz> $ host code.haskell.org
13:30:01 <yitz> code.haskell.org is an alias for community.haskell.org.
13:30:01 <scotty> dmwit: Huh?
13:30:02 <dmwit> scotty: For example, (=<<) :: (a -> Maybe b) -> (Maybe a -> Maybe b), and fmap :: (a -> b) -> (Maybe a -> Maybe b).
13:30:08 <lowasser> *been doing
13:30:09 <yitz> Gwern-away: ^^
13:30:15 <kmc> the down side of emphasizing this connection is that everyone thinks you need three Ph.D in maths to do anything in Haskell
13:30:31 <kmc> a lot of programmers are distrustful of theory, almost anti-intellectual
13:30:39 <kmc> it's unfortunate
13:30:50 <benmachine> yes but that is because they are bad people and we don't want them anyway
13:30:54 <lowasser> hah
13:30:57 <kmc> i often wish Haskell were marketed under a few different names
13:31:09 <Gwern-away> I'd say it;s because most theory is too heavy-weight and doesn't deliver much benefit
13:31:09 <kmc> one being "the pragmatic alternative to Haskell"
13:31:23 <kmc> people are definitely distrustful of static types and "type theory" because of Java and C++
13:31:29 <kmc> where the types are a lot of effort and little gain
13:31:37 <benmachine> Gwern-away: sturgeon's law?
13:31:52 <Gwern-away> benmachine: I'm not sure even 10% of academic cs theory is worthwhile
13:31:58 <yitz> kmc: so you meant "the pragmatic approach to types"?
13:32:00 <lowasser> *ouch
13:32:00 <lowasser> *
13:32:02 <kmc> heh
13:32:06 <lowasser> Gwern, that *hurts*
13:32:16 <frivol> Maybe algebraic types should be renamed Extreme Types.
13:32:25 <lowasser> or even better, Extreeeeeeeeme types
13:32:31 <Gwern-away> lowasser: you want the truth? you want the truth?
13:32:33 <benmachine> fusion power stealth types
13:32:40 <frivol> lowasser, funny, I almost wrote it that way.
13:32:43 <sepp2k1> kmc: Did you make the experience that people usually associate the term "type theory" with C++/Java? Cause I wouldn't expect that.
13:32:44 <yitz> Xtreme types
13:32:45 <kmc> i would wager that a lot of people who've vaguely heard of Haskell as "that crazy theory language" don't know about first-class imperative programming in Haskell, or C FFI, or lightweight threads
13:32:45 * Gwern-away thinks lowasser can't handle the truth! no truth-handler, he
13:32:50 <Jafet> BONUS: I slapped this up just now http://imagebin.org/93537
13:32:51 <lowasser> Gwern: bring it
13:32:54 <kmc> sepp2k1, maybe not "type theory"
13:32:58 <twink> Don't forget "iTypes"
13:32:59 <Gwern-away> bah! I deride your truth-handling abilities
13:33:01 <lowasser> we might have different conceptions of "academic cs theory," mind
13:33:07 <lowasser> that's really what I'm curious about
13:33:12 <scotty> dmwit: I'm not sure how I can pass the Maybe around.  I immediately need to use the value from the dictionary.  I'm sure I'm just not seeing how 'cause I'm a newbie Haskell programmer, but I'm reluctant to post my full code since it's so long.
13:33:16 <BONUS> Jafet: hahaha :D oh my god what is that
13:33:30 <BONUS> looks like a (:) but also like an alien
13:33:35 <lowasser> also, I'm not sure our definitions of "worthwhile" are compatible
13:33:38 <kmc> scotty, you want to throw an error if it's Nothing?
13:33:48 <Mathnerd314> :t id
13:33:49 <lambdabot> forall a. a -> a
13:33:50 <scotty> kmc: I don't know anymore! XD
13:33:52 <lowasser> that is, part of any field is scratching around in the dark until you find something interesting
13:33:52 <Mathnerd314> :t (.)
13:33:53 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:34:01 <scotty> kmc: I got the impression that it's bad.
13:34:01 <kmc> scotty, unless you want to refactor your code to pass around Maybe values
13:34:04 <kmc> or something else like Either
13:34:09 <lpsmith> hmm... does HDBC have efficient support for binary objects?
13:34:13 <kmc> scotty, it depends.  if you are fine with the interpreter exiting immediately, that's ok
13:34:14 <Gwern-away> lowasser: let's put it this way, you ever read through the annual ICFP fp workshop journal collection? how many of those tools and libraries and results ever get into widespread use?
13:34:20 <scotty> Hm, let me try to explain why I think I can't.
13:34:21 <benmachine> kmc: yes but we were telling him off for using error because it's hard to recover from
13:34:22 <kmc> and if you really want you can catch "error" exceptions from within IO
13:34:25 <Gwern-away> lowasser: cabal, sure. haddock made it. but most of the others...
13:34:29 <kmc> scotty, if you're a beginner this is the easy route
13:34:32 <cybercobra> what's the way to send a pragma to ghc from inside the source code?
13:34:35 <yitz> scotty: when you're just passing it around, use Maybe t instead of t. when you actually need to use the value for something, the type system will force you to specify what to do if an error occurred.
13:34:38 <Botje> BONUS: tilt your head sideways :)
13:34:46 <Gwern-away> (quickcheck, sweet. but there are many more misses than hits)
13:34:57 <lowasser> gwern: that's true of any field
13:34:58 <yitz> scotty: using the maybe function, or fromMaybe, or pattern matching
13:35:02 <twink> Gwern-away: There usually isn't much of an investment in these things.
13:35:29 <Gwern-away> lowasser: sure. but you're supposed to be arguing that CS has a 10% or greater hit rate, remember?
13:35:32 <yitz> scotty: of course, it could be just to pass the error condition through to the caller.
13:35:36 <Gwern-away> not that the hit-rate is >0%
13:35:49 <lowasser> no, we were arguing about the definition of "worthwhile"
13:35:59 <yitz> @wn worthwhile
13:36:00 <lambdabot> *** "worthwhile" wn "WordNet (r) 2.0"
13:36:00 <lambdabot> worthwhile
13:36:00 <lambdabot>      adj : sufficiently valuable to justify the investment of time or
13:36:00 <lambdabot>            interest; "a worthwhile book"
13:36:01 <benmachine> Gwern-away: do you think that CS is particularly poor in this respect?
13:36:06 <BONUS> Botje: aaaah!
13:36:18 <yitz> @vixen what is worthwhile?
13:36:18 <lambdabot> i don't know, what?
13:36:20 <lowasser> and the question is whether or not it's worthwhile to try something if it'll miss
13:36:49 <lowasser> granted, I'm planning to become a CS academic, so I'm sort of biased here
13:36:51 <Gwern-away> benmachine: dunno. I don't read that heavily is that many fields. I gather that biology and medicine are even lower signal to noise ratio though
13:36:54 <Gwern-away> *in
13:36:58 <twink> Gwern-away: There aren't many grants going around for going around and making use of new tools/infrastructure/etc. when they make things better.
13:37:09 <lowasser> Gwern: definitely true of bio =P
13:37:34 <lowasser> but of course any "hit" in bio is worth lots of money
13:37:43 <twink> So probably most of science in general just falls on deaf ears.
13:37:47 <lowasser> and therefore it's accepted that you'll have a lot of noise for any given signal
13:38:00 <Mathnerd314> :k (~>)
13:38:00 <lambdabot> Not in scope: type variable `~>'
13:38:05 <lowasser> because that's a necessary part of science, and even so we occasionally get something really awesome
13:38:06 <CalJohn> Gwern-away: the other question is whether this current "noise" helps result in future "signal"
13:38:38 <Gwern-away> CalJohn: sounds like a semantically null question. if the noise makes future signal, then it wasn't noise
13:38:57 <fax> guys
13:39:02 <fax> http://www.cs.uiowa.edu/~pfu/document/Reducibility%20for%20STL.pdf
13:39:15 <Gwern-away> lowasser: well, with med/bio, there are a lot of vested interests and tremendous corruption, and the statistics are dismal
13:39:16 <cads> I read someone who said science is dying
13:39:17 <fax> this proves that simple lambda calculus is SN using reductibility
13:39:17 <CalJohn> i thought you were defining "noise" as "not being used"
13:39:26 <fax> (CBV)
13:39:41 <fax> This proof is so simple and clear
13:39:44 <Gwern-away> CalJohn: that's null too. if it leads to future signal, then obviously it got used by the creators of that future signal at some point
13:39:46 <lowasser> meh
13:39:46 <fax> (I mean the way it is written)
13:39:47 <twink> If you had some particularly enlightened funding source or some such, they'd go around reviewing different things that go around in science (including computer science), decide to "roll things out," and then spend the effort putting things into practice.
13:39:50 <lowasser> let's take it another direction
13:40:04 <Twey> Gwern-away: Zero?
13:40:13 <Twey> Gwern-away: Haddock isn't in â€˜widespread useâ€™ â˜º
13:40:24 <lowasser> I claim that no kind of research can guarantee a great signal to noise ratio
13:40:30 <lowasser> and that research is worthwhile nevertheless.
13:40:34 <Gwern-away> Twey: compared to literate haskell or latex haskell it sure is :)
13:40:50 <Twey> I like LaTeX Haskell
13:41:07 <Twey> Would be nice to fuse it with Haddock, so I don't have to repeat myself
13:41:08 <CalJohn> Gwern-away: ok, but then don't java generics (as missed an opportunity as they were) retrospectively turn a lot of cs theory noise into signal (at least in part)?
13:41:11 * Twey makes a note
13:41:36 <Gwern-away> CalJohn: was ad hoc polymorphism all *that* enormous a part of cs theory?
13:41:42 <cads> Twey: what's the name of the latex haskell package?
13:41:58 <Twey> cads: No package â€” it's included with GHC
13:42:22 <lowasser> Gwern, type systems theory isn't trivial
13:42:24 <Twey> GHC can compile .lhs files that are LaTeX, with code delimited by \begin{code} â€¦ \end{code}
13:42:47 <lowasser> let's look at extensions currently in GHC
13:42:49 <cads> twey, ah
13:42:52 <Mathnerd314> what fixity is ~> ?
13:42:54 <lowasser> functional dependencies, type families
13:42:57 <CalJohn> Gwern-away: it's only an example I'm using to demonstrate a principle
13:43:12 <lowasser> there's a lot of different ways to an idea, and it's not necessarily clear which is most useful
13:43:15 <Axman6> Mathnerd314: :i (~>) in ghci should tell you
13:43:23 <yitz> @haddok (~>)
13:43:23 <lambdabot> Unknown command, try @list
13:43:27 <Gwern-away> CalJohn: anecdotes don't provide much support for arguments for or against statistical propositions
13:43:29 <yitz> @haddock (~>)
13:43:30 <lambdabot> Unknown command, try @list
13:43:32 <lowasser> research is happening all the time, and trying to come up with good ways to do things
13:43:44 <yitz> @hoogle (~>)
13:43:44 <lambdabot> No results found
13:43:51 <lowasser> there's always going to be hit and miss, but the hits are worthwhile and useful
13:44:19 <Mathnerd314> yitz: it's just used as an identifier in http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/src/Control-Category.html
13:44:20 <CalJohn> Gwern-away: they do when they illustrate cognitive bias
13:44:48 <yitz> hmm, have to let ndm know that that module is missing
13:45:27 <cads> Gwern-away: There was an article where a scientist argues that 50% of scientific findings in research journals are false http://www.boingboing.net/2005/08/30/journal_article_50_o.html
13:45:36 <Mathnerd314> yitz: I think it's like searching for 'a'
13:45:39 <CalJohn> my opinion is that there is actually quite a lot that eventually results from academics, so even if you think academics are justified only by results, there is still quite a lot of justification
13:45:39 <Gwern-away> cads: would not surprise me
13:45:52 <yitz> why?
13:46:10 <Gwern-away> even under perfect circumstances, p<.05 means a lot of wrong results...
13:46:11 <CalJohn> cads: if that's the article i think it is, it's wrong in it's conclusion
13:46:15 <cads> I wondered if the article was part of the hypothesized 50% of journal articles that are false :)
13:46:36 <Mathnerd314> yitz: it's used as a weird-looking name for the type argument to the class declaration
13:47:19 <lowasser> Gwern: p < .05 does mean a lot of wrong results, but that's *not the same* as not having been worthwhile
13:47:20 <yitz> Mathnerd314: oh. but isn't there a famous function by that name?
13:47:32 <twink> How would you set up a pipeline from theory to practice if you were, say, something huge like DARPA, and wanted to make sure that the results of research get used, implemented, rolled out, etc.?
13:48:27 <Nebasuke> force it as a standard :P
13:48:43 <Gwern-away> twink: multi-stage grants; one grant for the R&D, another grant for hiring someone to go around and make everything that could use it, use it
13:49:12 <cads> I wonder how effective research is inside corporations
13:49:17 <twink> Gwern-away: This isn't very often done? (Nor are other plausible strategies for all that.)
13:49:30 <yitz> Research is only worthwhile if it used in practice, yes. For example, Fermat's work is essential for RSA, so it's worthwhile. That was kind of hard to know then, though.
13:49:31 <Gwern-away> there're a lot of techniques you could use for the latter; contests, for example. '1k for prettiest Haddock'd module!'
13:49:39 <twink> cads: Not very. A lot of it is cribbing university research anyway.
13:50:02 <Gwern-away> cads: if xerox and bell labs are any guide, it's very effective; just not for the corp :)
13:50:16 <scree> twink: usually university work done ten years ago
13:50:20 <frivol> Gwern-away, too bad those don't exist anymore
13:50:29 <BONUS> yo. what are the advantages of the logic monad when doing backtracking computations? i'm getting to know it now but it seems it just ends up what the list monad does at the end
13:50:43 <Jafet> The worst software company has a department producing the best software research
13:50:54 <Gwern-away> twink: I'm not sure I've ever seen an academic grant focused on diffusion of existing CS research libs/progs; at least, nothing comes to mind in haskell
13:51:28 <twink> Gwern-away: I've never heard of anything like it in science anywhere.
13:51:30 <Gwern-away> BONUS: I thought it avoided recomputing lists and thus saved time?
13:51:32 <yitz> BONUS: StateT is the basic backtracking monad. LogicT is a lot noisier.
13:51:36 <poincare101> @where source
13:51:36 <lambdabot> I know nothing about source.
13:51:40 <CalJohn> cads: i think that article is subject to it's own data.  if it hadn't been such a high impact article, it's conclusion would not have been disproved so fast
13:51:50 <poincare101> where is lambdabot's source code? What's he written in?
13:51:55 <Gwern-away> @version
13:51:55 <lambdabot> lambdabot 4.2.2.1
13:51:55 <lambdabot> darcs get http://code.haskell.org/lambdabot
13:51:56 <BONUS> Gwern-away: ah, could be.
13:52:15 <yitz> @hackage lambdabot
13:52:15 <lambdabot> http://hackage.haskell.org/package/lambdabot
13:52:24 <Gwern-away> twink: I've long complained that haskell has a real problem with neat research not translating into results, and research bitrotting; look at how neat oleg's stuff is, and how little it's used
13:52:35 <BONUS> right now i'm just writing the monad and alternative instances for Logic a and seeing how they work
13:52:57 <Twey> Gwern-away: s/Haskell/computer science/, I thinkâ€¦
13:53:01 <twink> Gwern-away: But how is it unique to Haskell at all?
13:53:05 <BONUS> but it seems that return 1 <|> return 2 <|> return 3 just ends up being \sk fk -> sk 1 (sk 2 (sk 3 fk)))
13:53:08 <cads> CalJohn: I never got around to reading it myself
13:53:13 <twink> Gwern-away: Or even computer science?
13:53:15 <BONUS> which is well, a list at the end of the day
13:53:16 <CalJohn> Gwern-away: i think this problem is general to every field, and it's because the incentives to create value aren't good
13:53:26 <Gwern-away> actually, for corporate research, haskell is a good example. look at ghc. would ghc be as good if microsoft research hasn't consistently subsidized it for the last 2 decades?
13:53:43 <Gwern-away> where is YHC these days? (York Haskell, where york = university)
13:53:51 <poincare101> >a=1
13:53:56 <poincare101> > a=1
13:53:56 <lambdabot>   <no location info>: parse error on input `='
13:53:57 <CalJohn> cads: basically, Ioannidis is famous for showing that articles published in more pretigious journals are more likely to be disproved
13:54:05 <poincare101> oookay...
13:54:12 <poincare101> can you define functions in ghci?
13:54:13 <Gwern-away> @let a = 1
13:54:13 <lambdabot>  Defined.
13:54:15 <Gwern-away> > a
13:54:16 <lambdabot>   Ambiguous occurrence `a'
13:54:16 <lambdabot>  It could refer to either `L.a', defined at <local...
13:54:19 <poincare101> > a
13:54:20 <lambdabot>   Ambiguous occurrence `a'
13:54:20 <lambdabot>  It could refer to either `L.a', defined at <local...
13:54:21 <Cale> Gwern-away: Though, it's not like the Simons would have any problem finding a place that they could do research and work on GHC.
13:54:21 <Gwern-away> @let a = 1
13:54:22 <lambdabot>  <local>:2:0:
13:54:22 <lambdabot>      Multiple declarations of `L.a'
13:54:22 <lambdabot>      Declared at: <local>:1...
13:54:23 <Gwern-away> @let z = 1
13:54:24 <lambdabot>  Defined.
13:54:25 <CalJohn> cads: and that is a sensible result, because more people read them.  it's also helpful, because negative results are of value
13:54:25 <Gwern-away> > z
13:54:26 <lambdabot>   Ambiguous occurrence `z'
13:54:26 <lambdabot>  It could refer to either `L.z', defined at <local...
13:54:37 <Jafet> Gwern, fail
13:54:38 <poincare101> @let func x = x*x
13:54:39 <lambdabot>  Defined.
13:54:41 <scree> Gwern-away: so by the previous arguments, the problem is that microsoft invested in researching haskell, just not putting it into practice
13:54:45 <poincare101> > func 2
13:54:46 <lambdabot>   4
13:54:49 <Cale> All the one-letter names are taken by simplereflect
13:54:51 * poincare101 claps
13:54:53 <scree> could explain a lot
13:54:56 <Cale> @undefine
13:54:58 <poincare101> > func 123123123123
13:54:59 <lambdabot>   Not in scope: `func'
13:55:00 <Gwern-away> Cale: oh, is that it? hm.
13:55:19 <poincare101> @let func x = x*x
13:55:20 <lambdabot>  Defined.
13:55:23 <poincare101> func 123123123123123
13:55:26 <Gwern-away> Cale: where would the Simons go that would give them tenure to work on ghc?
13:55:30 <poincare101> > func 123123123123123
13:55:31 <lambdabot>   15159303447591705561417273129
13:55:39 * poincare101 claps again and is back to the book
13:55:44 <fax> > (func . funct) 7
13:55:45 <lambdabot>   Not in scope: `funct'
13:55:45 <yitz> Cale:  getting the kind of funding they get from MR is not so easy
13:55:48 <fax> > (func . func) 7
13:55:49 <lambdabot>   2401
13:55:49 <CalJohn> cads: that whole school of thought seems from a shoddy understanding of Philosophy of Science
13:55:50 <cads> CalJohn: as long as we're not scrutinizing useful results to death
13:55:53 <burp> poincare101: you don't need to define it with @let as a permanent definition
13:55:55 <Cale> Gwern-away: Glasgow?
13:56:05 <cads> CalJohn: so was his paper disproven?
13:56:06 <burp> use "> let func = x*x in func 10"
13:56:06 <Gwern-away> Cale: what, the whole city?
13:56:19 <poincare101> > let func x*x in func 10
13:56:20 <lambdabot>   <no location info>: parse error on input `in'
13:56:22 <cads> hm, disproven? disproved?
13:56:23 <poincare101> ooh. I get it!
13:56:27 <CalJohn> cads: AFAIK, yes
13:56:28 <Cale> Gwern-away: The G in GHC stands for something ;)
13:56:32 <poincare101> > let func = x*x in func 10
13:56:33 <lambdabot>   Couldn't match expected type `t1 -> t'
13:56:33 <lambdabot>         against inferred type `Simpl...
13:56:35 <Gwern-away> cads: 'disproven'
13:56:43 <burp> um sorry
13:56:47 <poincare101> burp: ^what does that mean/
13:56:48 <burp> func x of course ;)
13:56:48 <cads> CalJohn: ah, hehe, that's ironic
13:56:52 <Twey> Gwern-away: Yhc isn't actually developed by York Uni
13:56:53 <indigopenguin> G for Glorious
13:56:54 <burp> > let func x = x*x in func 10
13:56:55 <poincare101> > let func x = x*x in func
13:56:55 <lambdabot>   100
13:56:56 <lambdabot>   {-3->9;-2->4;-1->1;0->0;1->1;2->4;3->9}
13:56:58 <Gwern-away> Twey: lies!
13:56:59 <poincare101> > let func x = x*x in func 10
13:57:00 <lambdabot>   100
13:57:05 <poincare101> > let func x = x*x in func 100
13:57:06 <lambdabot>   10000
13:57:09 <CalJohn> cads: it's pretty much linus' law
13:57:22 <Twey> http://haskell.org/haskellwiki/Yhc
13:57:30 <Twey> Â« Warning, this compiler is not finished, and is not useable as a standard Haskell Compiler. It is also not an official York project. Â»
13:57:40 <Twey> It does have a really cool logo, though.
13:57:41 <yitz> > let func = join (*) in func 100
13:57:42 <lambdabot>   10000
13:57:49 <CalJohn> if your paper gets published in newspapers all over the world, you're picking a fight with millions of eyeballs
13:57:57 <fax> @@ @run @run let func x = "let func = "++x++"*"++x++" in func" in var $ func "10"
13:57:59 <lambdabot>   100
13:58:18 <burp> lol
13:58:43 <scree> if your paper gets published in newspapers you should work on making it less comprehensible
13:59:08 <cads> CalJohn: I wonder how it was disproved.. can we simply not infer the percentage of false papers from the data presented, or is the bound less drastic than he proposes?
13:59:11 <indigopenguin> Less comprehensible is a good thing?
13:59:15 <Jafet> Or worse, science magazines
13:59:17 <BONUS> scree: lol
13:59:33 <cads> fox news
13:59:51 <indigopenguin> It'd be terrible if the uneducated plebs understood anything!
13:59:53 <Mathnerd314> :t join
13:59:54 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
14:00:01 <fax> does anyone know quantum computing?
14:00:02 <Gwern-away> one way I think of it is, do you agree that google summer of code is a major success and has done good far out of proportion to the actual payments? if you accept both of those propositions, then doesn't this show a major gap in academic CS/software engineering funding priorities?
14:00:05 <fax> I have a question :(
14:00:13 <scree> indigopenguin: or worse, thy might realize how little we actually understand
14:00:19 <Gwern-away> fax: there are several quantum computing libraries/modules in haskell
14:00:23 <CalJohn> cads: his data is completely correct, he's just wrong that it matters.  his theory was "prestigious journals are bad for science" and that theory has been largely debunked
14:00:41 <CalJohn> (at least, for the reasons he proposes, i think they're bad for other reasons)
14:00:50 <Twey> Heh, he actually theorised that?
14:00:50 <fax> this article says: "Many scientists believe that quantum entanglement is required in order for effective quantum computing" but I don't get it.. isn't the computationg classical if you don't use entanglement?
14:00:54 <indigopenguin> The technical priesthood is like a Vatican of its own.
14:00:59 <Twey> Non-satirically?
14:01:11 <indigopenguin> Except they don't molest grad students (I hope)
14:01:19 <hpaste>  parametricity -> induction (dolio)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24938
14:01:49 <cads> indigopenguin: what's wrong with molesting grad students?!
14:02:06 <CalJohn> Twey: he's famous for it, yeah.  there are good criticisms of "peer review" and the way the scientific establishment operates, but his aren't
14:02:12 <scree> it's only undergrads who are off limits
14:02:52 <twink> cads: The thing is, when sex with grad students happens, they're willing and able to give informed consent (barring alcohol).
14:02:53 <Mathnerd314> why does google keep ranking mirrorservice.org over haskell.org?
14:03:23 <Twey> twink: Whereas priests aren't?  ;)
14:03:24 <CalJohn> twink: surely with undergrads also, dependant on country?
14:03:36 <cads> twink: why molest when you can ply with booze, neh?
14:03:49 <scree> no, undergrads are mentally underdeveloped creatures incapable of making their own decisions
14:03:49 <Cale> I don't really think that journals are a problem for science. It's publishing companies which are a problem now. They used to provide a useful service, but now they're just leeches.
14:03:58 <Jafet> Undergrads cannot own guns yet
14:04:16 <aBrickOntheWall> fax..what article are  you looking at? Yes, for quantum computation algorithms to work it is essential to keep coherence/entanglement.
14:04:17 <cads> Hey I've got this line in a package I'm trying to compile (hmatrix still):
14:04:20 <CalJohn> Cale: the RIAA of academia
14:04:25 <cads> foreign import ccall "auxi.h gsl_strerror" gsl_strerror :: CInt -> IO (Ptr CChar)
14:04:34 <scree> Jafet: do you have to present your degree at the gun shop?
14:04:39 <Twey> Haha
14:04:47 <indigopenguin> It's bad to have a relationship like that with someone who has a great deal of power over you.
14:05:16 <Twey> indigopenguin: Depends on the moral responsibility of the other party.
14:05:27 <cads> then when I compile and try to run the tests I get "unknown symbol '_gsl_strerror' Unable to load package"
14:05:57 <fax> aBrickOntheWall - http://www.physorg.com/news176364815.html
14:06:10 <Gwern-away> @quote Olin
14:06:10 <lambdabot> astrolabe says: Below a certain level of competence, coding is a destructive act.  Like playing the violin.
14:06:15 <Gwern-away> @quote Shiver
14:06:15 <lambdabot> No quotes match.
14:06:34 <Gwern-away> @quote OlinShivers
14:06:34 <lambdabot> OlinShivers says: As my advisor said, the tragedy of Galois is that he could have contributed so much more to mathematics if he'd only spent more time on his markmanship.
14:06:36 <cads> I'm in windows and the install file gives some wierd instructions on fetching some gsl headers and dlls and putting them in the ghc/include and bin directories respectively.
14:07:02 <poincare101> fax: slightly scary...
14:07:06 <Gwern-away> @quote OlinShivers
14:07:06 <lambdabot> OlinShivers says: "I am not a Church numeral; I am a free variable!"
14:07:19 <Gwern-away> @quote OlinShivers
14:07:19 <lambdabot> OlinShivers says: My God, no one could blame me -- no one! -- if I went off the edge and just lost it completely one day.
14:07:28 <Jafet> So, young undergrad, monads are like guns. They help you keep pure and free from molestation, but to make sure everyone can only use them properly, they must follow certain "gun laws"
14:07:28 <Twey> Hahaha
14:07:31 <cads> and I've noticed that there is in fact no auxi.h in the headers included, but that the gsl_strerror function is included in the gsl_errno.h header
14:07:44 <Gwern-away> @quote acknowl
14:07:44 <lambdabot> OlinShivers says: Oh, yes, the *acknowledgements*. I think not. I did it. I did it all, by myself.
14:07:51 <poincare101> Jafet: hee hee :)
14:08:08 <Gwern-away> @quote Amerika
14:08:08 <medfly> did someone explain monads through porn yet
14:08:08 <lambdabot> OlinShivers says: They look at me funny; they think I twitch a lot. I'm not twitching. I'm controlling my impulse to snag my 9mm Sig-Sauer out from my day-pack and make a few strong points about the
14:08:08 <lambdabot> quality of undergraduate education in Amerika.
14:08:50 <poincare101> > [3, 6,..100]
14:08:51 <lambdabot>   <no location info>: parse error on input `..'
14:08:58 <twink> Gwern-away: Let's say there's a grand discovery about how to do integrated register allocation and instruction scheduling. How do you "roll this out" into all the compilers out there?
14:08:59 <poincare101> > [3, 6..100]
14:09:00 <lambdabot>   [3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78...
14:09:33 <cads> I keep running into how monads are burritos
14:09:40 <Jafet> twink, write an assembly-assembly compiler
14:09:57 <poincare101> Jafet: oh my god. no. please.
14:10:15 <sepp2k1> Is there a pragma I can use to say "all types defined in this file should derive Show", so I don't have to put deriving Show everywhere?
14:10:16 <yitz> > let func = join (m 2); m 0 _ k = k+1; m 1 j 0 = j; m 2 _ 0 = 0; m _ _ 0 = 1; m i j k = m (i-1) j $ m i j (k-1) in func 10
14:10:17 <lambdabot>   100
14:10:19 <Gwern-away> twink: take the easiest compiler to update - probably LLVM - and perfect it in it; with convincing realworld benchmarks, you can then hire specialists in each compiler.
14:10:28 <cads> and while most people understand the tounge in cheek way byorgey said "monads are like burritos", I just ran across this guy's explanation of how monads are really like burritors
14:10:45 <cads> "bind is clearly a tortilla"
14:10:56 * Jafet spits a coburrito at cads
14:11:15 <medfly> it's a joke no a joke
14:11:40 <Jafet> Monads are like jokes
14:11:43 <Gwern-away> twink: once it's in a few high profile compilers and is universally acknowledged as a major win, market forces will do the rest
14:12:26 <Gwern-away> much like how once a decent fraction of haskell packages were in cabal, it ceased to be an issue and became the default
14:12:28 <Philippa> market forces operate a little weirdly when it comes to something like gcc
14:12:34 <twink> Gwern-away: Well, there's a big trick there. Those compilers are all private enterprise, yes?
14:12:47 <scree> Jafet: you mean, there are only about 10 good ones which get used over and over?
14:12:53 <Gwern-away> twink: gcc and llvm aren't really, if I take you to mean proprietary
14:13:16 <poincare101> > let func x = [1, 1+x..] in func 10
14:13:16 <lambdabot>   [1,11,21,31,41,51,61,71,81,91,101,111,121,131,141,151,161,171,181,191,201,2...
14:13:29 <poincare101> whoa. infinite lists. that's cool!
14:13:38 <Jafet> scree, I will think about your question tomorrow on the invisible jello train.
14:13:49 <Jafet> And tell you the answer yesterday.
14:13:55 <Gwern-away> Philippa: sure, which is why you have to hire someone for it. a change in pcc isn't going to motivate the gcc devs; a change in gcc might motivate the pcc devs. (where if pcc doesnt exist, = some obscure c compiler)
14:14:21 <indigopenguin> pcc does exist, OpenBSD is trying to adapt it
14:14:31 <Jafet> Bellard still won't bother, unless it involves hypergeometric sums
14:14:55 <Philippa> Gwern-away: takes more than that, unfortunately. GCC is a political force and forking it would get interesting
14:15:08 <Gwern-away> Philippa: but doable! as history proves
14:15:14 <scotty> Man, I love deleting lines in my Haskell code.
14:15:21 <twink> egcs?
14:15:30 <Gwern-away> it would be interesting to try to calculate how much one would have to invest to successfully fork a given project
14:15:33 <scree> it's writing them I hate
14:15:43 <aBrickOntheWall> fax...not a very well written article, but the point is that if you want to do more complex calculations you need to use more qubits and also qubits with more degrees of freedom. But as you add more qubits you lose entanglement/coherence. Keeping coherence is a big challenge for quantum computers.
14:15:54 <yitz> > let fibbo = 1 : 1 : zipWith (1) fibbo (tail fibbo) -- poincare101
14:15:55 <lambdabot>   not an expression: `let fibbo = 1 : 1 : zipWith (1) fibbo (tail fibbo) -- p...
14:16:01 <fax> aBrickOntheWall okay thank you
14:16:03 <yitz> > let fibbo = 1 : 1 : zipWith (+) fibbo (tail fibbo) -- poincare101
14:16:04 <Philippa> weren't most of the succesful GCC forks (measured in terms of use and/or code used upstream) ones intentionally created by the GNU crowd?
14:16:04 <lambdabot>   not an expression: `let fibbo = 1 : 1 : zipWith (+) fibbo (tail fibbo) -- p...
14:16:04 <poincare101> is there some way i like execute two statements on lambda bot, so it won't forget the variable that I just created?
14:16:13 <yitz> > let fibbo = 1 : 1 : zipWith (+) fibbo (tail fibbo) in fibbo-- poincare101
14:16:14 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
14:16:22 <yitz> whew
14:16:32 <twink> Gwern-away: I daresay that integrated register allocation and instruction scheduling would be rather challenging to merge into gcc in any meaningful way beyond replacing the whole back end.
14:16:36 <Gwern-away> poincare101: nested lets?
14:16:36 <poincare101> > cycle [1,2,3]
14:16:37 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
14:16:46 <Gwern-away> twink: well, look at what's happening right now :)
14:16:55 <medfly> @let whatever = 3
14:16:56 <lambdabot>  Defined.
14:17:04 <Jafet> fax don't lose hope, we can factor 15 now.
14:17:05 <medfly> > whatever + whatever
14:17:06 <lambdabot>   6
14:17:07 <poincare101> ah.
14:17:12 <twink> Gwern-away: I've been out of the loop. What's happening right now?
14:17:12 <medfly> better
14:17:14 <poincare101> > factor 15
14:17:15 <medfly> > whatever * 7
14:17:15 <lambdabot>   Not in scope: `factor'
14:17:16 <lambdabot>   21
14:17:19 <medfly> wait, no
14:17:21 <medfly> > whatever * 14
14:17:22 <lambdabot>   42
14:17:25 <medfly> there we go
14:17:27 <Gwern-away> twink: llvm is being integrated as a backend
14:17:50 <Gwern-away> twink: everyone is all atwitter because apparently llvm does low-level optimization better than ghc and emits faster code
14:18:11 <twink> Gwern-away: I meant gcc not ghc
14:18:19 * poincare101 is know reading about list comprehensions. 
14:18:21 <Gwern-away> oh. oops
14:18:35 <indigopenguin> Clang can replace GCC
14:18:40 <Jafet> gcc already has several somewhat pluggable allocators and tree transforms
14:18:52 <yitz> > let 14 = whatever in 7 * 14
14:18:53 <lambdabot>   98
14:19:14 <twink> Gwern-away: But you can probably just push the stuff down to llvm's or gcc's obstacles to integrated instruction scheduling and register allocation.
14:19:25 <poincare101> gcc is never going to be replaced for market share as long as i live, its just so stable (cept C99, which may or may not cause its death)
14:19:34 <yitz> > let 14 = whatever in 3 * whatever
14:19:35 <lambdabot>   9
14:20:00 <Jafet> Everyone uses gcc for really no other reason than gcc is used by everyone.
14:20:09 <poincare101> Jafet: its stable.
14:20:15 <Mathnerd314> well, one could try llvm-gcc
14:20:16 <Jafet> That is not the real reason.
14:20:25 <BMeph> It's UNstable. ;þ
14:20:25 <poincare101> Jafet: and there
14:20:35 <medfly> it came with ghc
14:20:36 <poincare101> Jafet: and there's a lot of tutorials for it and using it...
14:20:44 <indigopenguin> I'm sure plenty of people would like to switch to LLVM/Clang.
14:20:48 <Gwern-away> it would be pretty easy to fork xmonad, for example. I'd bet hiring 1 or 2 fulltime developers would be enough
14:20:54 <Jafet> Still no. People use it simply because people use it.
14:21:00 <medfly> whatever
14:21:01 <medfly> it works
14:21:08 <medfly> it's better than everyone using something different
14:21:20 <medfly> better have a shitty standard than no standard at all
14:21:25 <indigopenguin> GCC is a monoculture.
14:21:32 <Jafet> I don't use tcc, because tcc only generates code for x86.
14:21:35 <BMeph> medfly: FSVO "better", anyway. ;)
14:22:11 <Gwern-away> (heck, a part-time developer might be enough for xmonad. dons and sjanssen seem to have abdicated their roles)
14:22:33 <poincare101> Jafet: what *do* you use?
14:22:41 <Jafet> gcc, of course.
14:22:46 <Mathnerd314> medfly: no. because then it's too hard to change to the *good* standard
14:22:56 <poincare101> Jafet: :D
14:23:21 <Jafet> tcc does let you do silly things like compile strings at runtime
14:23:26 <Axman6> gcc--
14:23:27 <medfly> I hate accommodating for a gazillion different possibilities.
14:23:50 <indigopenguin> I'm sure Apple will switch to Clang at some point.
14:24:02 <Jafet> I thought the shitty standard was autoconf.
14:24:09 <Axman6> 10.7 i'd bet indigopenguin
14:24:13 <medfly> like having to find another charger for a mobile phone. who cares what the standard is? just pick one, dammit! it's just a charger!
14:24:28 <Philippa> they have done - microUSB
14:24:34 <medfly> in the end you end up with a drawer full of mobile phone chargers
14:24:36 <Jafet> Well, the nokia design is objectively better than the sony ericsson.
14:24:54 <twink> Gwern-away: You basically get the idea that it requires tremendous amounts of violence to core data structures, modularity/layering assumptions, etc.?
14:26:05 <poincare101> is there a random number function in haskell?
14:26:06 <Axman6> indigopenguin: i can't wait for that day
14:26:14 <Axman6> @hoogle random
14:26:15 <lambdabot> package random
14:26:15 <lambdabot> System.Random random :: (Random a, RandomGen g) => g -> (a, g)
14:26:15 <lambdabot> module System.Random
14:26:29 <Axman6> @hoogle randoms
14:26:29 <lambdabot> System.Random randoms :: (Random a, RandomGen g) => g -> [a]
14:26:37 <Axman6> @hoogle randomR
14:26:37 <lambdabot> System.Random randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)
14:26:38 <lambdabot> System.Random randomRIO :: Random a => (a, a) -> IO a
14:26:38 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
14:27:03 <poincare101> wait, are monads like functions, but they return functions?
14:27:12 <hpc> no
14:27:13 <dv-> no
14:27:20 <indigopenguin> I don't have any particular personal grievance against gcc, or gnu in general.
14:27:24 <mreh> why is haskell software infinity times easier to start developing?
14:27:37 <poincare101> well, never mind...
14:27:38 <mreh> I don't seem to have half the hassle when trying to make someone elses software
14:27:46 <indigopenguin> in fact, i rather enjoy the majority of gnu software that i use
14:27:57 <hpc> monads are things with other things inside them
14:28:01 <Jafet> genRandom = peek . intPtrToPtr . fromIntegral
14:29:14 <hpc> the easiest way to learn monads is with Maybe, imo
14:29:27 <benmachine> indigopenguin: have you seen their indentation style? :P
14:29:28 <Jafet> Definitely Maybe.
14:29:33 <hpc> haha
14:30:02 <mreh> I'd start with specific examples for things like Monads and Arrows
14:30:18 <mreh> a monad is a container and two functions, that is all
14:31:12 <Jafet> A monad is a functor with two transformations
14:31:33 <Gwern-away> twink: can't say I really get that idea
14:31:45 * mreh feeds Jafet a biscuit
14:31:59 * Jafet binds and returns ()
14:32:10 <twink> Gwern-away: It presents a new/interesting quandary with respect to rolling out "new technology" or "research results."
14:32:27 <Gwern-away> twink: sounds like it only increases the expense
14:32:49 <edwardk> jafet: with three laws, and four...
14:34:19 <poincare101> Jafet: so, like a mapping functor?
14:35:06 <Jafet> Mommy and daddy will tell you next time
14:35:28 <Gwern-away> @wn certes
14:35:30 <lambdabot> No match for "certes".
14:35:37 <Jafet> I think I've just found out how to make a monad analogy to porn
14:35:55 <poincare101> um.
14:36:13 <Jafet> I'll write it up, just for medfly.
14:36:14 <poincare101> @let a = [1..]
14:36:14 <lambdabot>  Defined.
14:36:18 <benmachine> have you ever wondered what it's like to think of something and then never tell anyone ever?
14:36:21 <poincare101> @let b = [4..]
14:36:22 <lambdabot>  Defined.
14:36:27 <poincare101> zip a b
14:36:27 <benmachine> could be an interesting experience!!
14:36:33 <poincare101> > zip a b
14:36:34 <lambdabot>   Ambiguous occurrence `a'
14:36:34 <lambdabot>  It could refer to either `L.a', defined at <local...
14:36:35 <Twey> benmachine: I do it all the time
14:36:40 <Twey> Sometimes I don't even tell myself
14:36:42 <poincare101> > zip L.a b
14:36:43 <lambdabot>   Ambiguous occurrence `b'
14:36:43 <lambdabot>  It could refer to either `L.b', defined at <local...
14:36:47 <poincare101> > zip L.a L.b
14:36:48 <lambdabot>   [(1,4),(2,5),(3,6),(4,7),(5,8),(6,9),(7,10),(8,11),(9,12),(10,13),(11,14),(...
14:36:53 <mauke> @undefine
14:37:01 <Mathnerd314> > zip [1..] [4..]
14:37:01 <lambdabot>   [(1,4),(2,5),(3,6),(4,7),(5,8),(6,9),(7,10),(8,11),(9,12),(10,13),(11,14),(...
14:37:17 <poincare101> oh my god. Its mapping between infinite lists. *This* is cool.
14:37:28 <Mathnerd314> > zipWith (+) [1..] [4..]
14:37:28 <lambdabot>   [5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,55...
14:37:48 <FliPPeh_> Of course it does
14:38:25 <Jafet> Procrastinating lists are cooler
14:38:26 * poincare101 is never going to program in Python again.
14:38:37 <Gwern-away> procrastinating lists?
14:38:43 <FliPPeh> :)
14:38:43 <FliPPeh> > zip [1..] ["One", "Two", "Three", "Four"]
14:38:44 <lambdabot>   [(1,"One"),(2,"Two"),(3,"Three"),(4,"Four")]
14:38:51 <poincare101> Jafet: are those like lazy lists?
14:39:14 <Jafet> http://hackage.haskell.org/packages/archive/procrastinating-structure/1.0.1/doc/html/Data-PVar-Queue.html
14:39:51 <poincare101> how can I make sure that something is an integer and not a float?
14:40:00 <fax> :: Integer
14:40:07 <Gwern-away> 'You can populate the back of the queue in IO and read the front of the queue in pure code.'
14:40:09 <benmachine> > (2 :: Integer) / 3
14:40:10 <Gwern-away> wait what?
14:40:10 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Integer.Internals.Integer)
14:40:10 <lambdabot>    aris...
14:40:15 <benmachine> *gasp* it doesn't work
14:40:25 <dmwit> Gwern-away: Reading the front blocks if you haven't pushed enough stuffs.
14:40:28 <Gwern-away> doesn't that mean you'll eventually be pulling impure stuff out into pure code?
14:40:38 <dmwit> Gwern-away: Amazingly enough, no, I don't think so.
14:40:44 <Jafet> "I think it fits the definition of referentially transparent"
14:40:44 <benmachine> Gwern-away: I had a look and it doesn't import any System.Unsafes :P
14:40:51 <Gwern-away> but how wha
14:40:53 <benmachine> oh wait it might
14:41:11 * benmachine cabal unpack to have a look
14:41:20 <dmwit> Gwern-away: Peaking at the front doesn't modify the queue at all.
14:41:42 <Gwern-away> dmwit: but pop doesn't seem to involve IO
14:41:44 <Gwern-away> 'pop  :: Queue  a -> Maybe  (Queue  a, a)
14:41:56 <dmwit> Gwern-away: Right. It doesn't modify the tail of the queue, either.
14:42:10 <dmwit> It's returning you a *new* queue that represents the rest of the queue.
14:42:27 <dmwit> You wouldn't be at all surprised by that interface if I told you the push operation wasn't in IO; why does putting the push in IO suddenly make it surprising?
14:42:41 <mreh> poincare101: haskell will ruin your life, don't do it
14:42:47 <benmachine> ohh here we go, Data.PVar uses unsafe
14:42:49 <Jafet> It isn't referentially transparent, but the front end is pure.
14:43:05 <dmwit> Isn't referentially transparent?
14:43:07 <dmwit> Are you sure?
14:43:10 <Jafet> It's fun to think about what this library really does.
14:43:20 <Gwern-away> benmachine: phew! I thought I was going crazy for a moment
14:43:33 <Jafet> dmwit, head returns a different value each time
14:43:41 <c_wraith> Hmm.  I'm told that hdbc-postgresql is broken.  *sigh*
14:43:57 <c_wraith> well.  kinda broken.  it uses the blocking libpq calls
14:44:18 <dmwit> Jafet: I don't see a "head".
14:44:33 <Jafet> peek, then.
14:44:35 <dmwit> Jafet: And "peek" doesn't have the behavior you say, nor does "pop".
14:44:58 <Jafet> Oh, what's the type of peek?
14:45:10 <dmwit> peek :: Queue a -> Maybe a
14:45:11 <benmachine> Gwern-away: it uses unsafePerformIO but if I understand correctly it could equally get away with unsafeInterleaveIO
14:45:13 <Jafet> No IO in it, as far as I can see
14:45:15 <benmachine> not sure about that though
14:45:31 <Jafet> If you put a different value in the queue, peek returns a different value
14:45:47 <hpaste>  unsafeness in Data.PVar (benmachine)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24939
14:45:49 <Gwern-away> unsafeInterleaveIO doesn't launder dirty values though, iirc
14:45:53 <benmachine> thx hpaste
14:45:58 <dmwit> Jafet: If you call peek many times on the same Queue, you always get the same result.
14:45:59 <poincare101> > [(a,b,c) | a <- [1..100], b <- [1..100], c <- [1..100], a^2+b^2==c^2]
14:46:02 <lambdabot>   mueval-core: Time limit exceeded
14:46:07 <dmwit> Jafet: That's the definition of referential transparency right there.
14:46:10 <benmachine> Gwern-away: that ^ there contains the only use of System.IO.Unsafe
14:46:14 <poincare101> dang it.
14:46:16 <poincare101> > [(a,b,c) | a <- [1..100], b <- [1..100], c <- [1..100], a^2+b^2==c^2]
14:46:19 <lambdabot>   mueval-core: Time limit exceeded
14:46:29 <poincare101> > [(a,b,c) | a <- [1..10], b <- [1..10], c <- [1..10], a^2+b^2==c^2]
14:46:30 <lambdabot>   [(3,4,5),(4,3,5),(6,8,10),(8,6,10)]
14:46:32 <poincare101> yay!
14:46:32 <Jafet> dmwit, what is "the same queue"?
14:46:36 <Gwern-away> poincare101: try using lazy lists and demanding only a few values
14:46:55 <Gwern-away> poincare101: mueval doesn't give you very much time; may not have enough time to do 100 computations
14:46:57 <dmwit> Jafet: eh?
14:47:21 <Jafet> dmwit, each time the code is executed, a different queue gets built.
14:47:25 <Gwern-away> benmachine: well, unsafePerformIO explains it all I guess
14:47:28 <Jafet> Or may get built.
14:47:41 <benmachine> Gwern-away: yeah but the use there looks like it could be unsafeInterleaveIO
14:47:41 <dmwit> Jafet: Each time "newQueue" is executed, a different queue gets built, yes. I'd be upset if anything else happened.
14:47:44 <Jafet> dmwit, so, what is the semantics of peek?
14:47:47 <benmachine> but that probably still explains it
14:48:00 <burp> @check [(a,b,c,n) | a <- [1..], b <- [1..], c <- [1..], n <- [3..] a^n+b^n==c^n] == [] -- ;)
14:48:01 <lambdabot>   Couldn't match expected type `t -> a' against inferred type `[a1]'
14:48:10 <Gwern-away> > take 10 $ [(a,b,c) | a <- [1..], b <- [1..], c <- [1..], a^2+b^2==c^2]
14:48:14 <lambdabot>   mueval-core: Time limit exceeded
14:48:20 <poincare101> Gwern-away: lazy lists? how do I use those?
14:48:22 <Jafet> dmwit, if you draw semantics for peek, somewhere in it you'll reach IO
14:48:31 <Gwern-away> benmachine: but it does./ readIORef returns IO a, while the sig says newPVarWithCustomMessage :: String -> IO (PVar a, a)
14:48:35 <dmwit> Jafet: so?
14:48:35 <fax> burp if you try that one in mathematica it works
14:48:46 <Gwern-away> benmachine: and not '-> IO (PVar a, IO a)'
14:48:51 <dmwit> Jafet: Referential transparency doesn't care about whether you reach a particular type in your call graph.
14:49:08 <burp> fax: oh it knows fermat's last theorem? :>
14:49:10 <Gwern-away> poincare101: see my example. I guess performance wise it doesn't work...
14:49:11 <Jafet> dmwit, would you say it's transparent but impure
14:49:16 <dmwit> Jafet: If you trace the FFI call to sin back, you'll reach IO, too, but that doesn't mean it's not referentially transparent.
14:49:41 <Gwern-away> poincare101: it's generally a good idea to let the caller decide how many answers it wants
14:49:44 <dmwit> Jafet: I think that's fair. The side effect is that it blocks if you read too much before fulling (or closing) the queue.
14:49:44 <benmachine> Gwern-away: but you can write a function IO (PVar a, IO a) -> IO (PVar a, a) -- it'd normally change how the effects were executed but in this case unsafeInterleaveIO takes care of that I think
14:50:06 <benmachine> (you can write such a function safely, I mean)
14:50:12 <HugoDaniel> HI
14:50:15 <benmachine> hi
14:50:17 <Gwern-away> benmachine: hum. you can join IO (IO a) to IO a, 'tis true
14:50:34 <HugoDaniel> has anyone tried out reactive ?
14:51:26 <HugoDaniel> im looking at reactive again...
14:52:09 <poincare101> hi!
14:52:12 <gio123> s : alpha1-->alpha2-->alpha3-->beta  what is domain here and what is image?
14:52:43 <amontez> Hai...
14:52:44 <dmwit> domain alpha1, range (alpha2 -> alpha3 -> beta)
14:53:06 <benmachine> image you can't tell from information given
14:53:22 <gio123> in simple typed lambda calculus
14:54:03 <Philippa> gio123: by convention that's equivalent to alpha1 -> (alpha2 -> (alpha3 -> beta))
14:54:43 <gio123> -> associates to the right
14:54:44 <amontez> What is the point of Applicative?
14:55:12 <HugoDaniel> amontez: applicative is teh most beautiful thing!
14:55:14 <Philippa> amontez: it's like the point of Monad, only first-order
14:55:29 <Philippa> alternatively: what point? It's point-free
14:56:46 <Philippa> amontez: it's a bunch of general combinators with specific instances that do all kinds of interesting things
14:57:39 * hackagebot iteratee 0.3.5 - Iteratee-based I/O  http://hackage.haskell.org/package/iteratee-0.3.5 (JohnLato)
14:57:41 <amontez> I have not seen a usage of it where a Monad would not have been enough.
14:58:13 <dmwit> Yes, all Monads are Applicative, too.
14:58:20 <hpaste>  . (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24940
14:58:21 <Philippa> you've probably seen many where Monads are more than enough
14:58:23 <dmwit> But there are some Applicative instances that cannot be made Monadic.
14:58:33 <Mathnerd314> ZipList...
14:58:34 <amontez> dmwit: Such as?
14:58:39 <dmwit> ZipList =)
14:58:39 <fax> :t prime
14:58:40 <lambdabot> Not in scope: `prime'
14:58:43 <fax> ffffffffff
14:58:48 <fax> when is 5^n a prime
14:58:54 <balor> Could someone tell me why directory won't build for me? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24940#a24940  I don't understand why Base might be hidden
14:58:56 <Twey> When n = 1 ;)
14:59:18 <Mathnerd314> though an alternate structure, having the same <*> and pure operations as ZipList, will in fact work
14:59:20 <fax> only??
14:59:28 <Twey> Yes, only
14:59:30 <dmwit> The Arrow paper by Ross Paterson has a few more examples. I can't remember them off the top of my head, but I think they were for automata and time-varying functions.
14:59:36 <Mathnerd314> fax: it's divisible by 5...
14:59:45 <fax> ack
14:59:46 <Philippa> Applicatives admit a degree of self-analysis that monads don't, too
14:59:49 <Twey> :Ã¾
14:59:50 <fax> I mean to write 5^n+1
15:00:03 <amontez> Philippa: What do you mean?
15:00:06 <Twey> Hm
15:00:08 <Philippa> because the structure of an applicative computation is statically fixed
15:00:17 <dmwit> 5^n + 1 is always even (i.e. not prime)
15:00:19 <benmachine> 5^n + 1 is always even
15:00:21 <Twey> Yeah
15:00:25 <Mathnerd314> fax: when n=0
15:00:28 <dmwit> n=0, right
15:00:33 <Philippa> amontez: self-optimising combinators is the classic example
15:00:34 <Twey> Mathnerd314: ^ parses before + :Ã¾
15:00:39 <fax> ill have to use 2*5^n + 1 then
15:00:45 <Twey> Oh, but 2 is prime.
15:00:47 <Twey> Hehe.
15:01:00 <Philippa> you get parsing combinators that analyse the grammar they're based on to some extent and use that information for a more efficient implementation
15:01:49 <benmachine> there's the Monoid m => Applicative (Either m) too
15:01:56 <benmachine> that can't be Monadised
15:02:11 <benmachine> (where Left values are mappended)
15:03:55 <Mathnerd314> :t isPrime
15:03:56 <lambdabot> Not in scope: `isPrime'
15:08:55 <Mathnerd314> hmmm... nothing useful on Hackage either
15:08:58 <edwardk> benmachine: that can be monadized, but it just works over the Right hand side, that is the Either monad we have in Control.Monad.Error with a slightly different name
15:09:06 <Mathnerd314> *from
15:09:12 <benmachine> edwardk: the mappending can't be monadised
15:09:13 <edwardk> benmachine: they just implicitly use the 'Last' monoid
15:09:53 <edwardk> benmachine: sure it can. that is the action of the MonadPlus on that monad.
15:10:21 <benmachine> edwardk: that's monadplusising :P
15:10:33 <Philippa> MonadPlus != Monad, and I'd take "monadised" to mean preserving pure/return and ap
15:10:38 <benmachine> yes
15:10:51 <benmachine> there is no monad that has an ap that mappends Lefts
15:11:02 <Philippa> anyway, I'm heading off
15:11:15 <shapr> dons: Truly, more unicycles!
15:11:32 <edwardk> sure
15:11:41 <edwardk> heya shapr
15:11:48 <shapr> y0 edwardk
15:12:31 <HugoDaniel> i like the way haskell blends with C code
15:12:39 <HugoDaniel> makes me feel "balanced" with the code
15:12:48 <HugoDaniel> yin yang of programming
15:13:02 <chrisdone> :D
15:13:36 <chrisdone> are you writing actual c code inside your .hsc file or importing functions?
15:13:51 <indigopenguin> Would be nice if Haskell could interface with other languages as easily.
15:14:01 <HugoDaniel> im just importing functions :)
15:14:48 <sbahra> edwardk, ping?
15:15:13 <edwardk> sbahra: pong
15:15:15 <sbahra> edwardk, who was the go-to guy again for Haskell mailing lists? I need to add a moderator to one of the lists, and I forgot my credentials.
15:15:34 <edwardk> honestly, i have no idea =)
15:15:55 <sbahra> Ok.
15:16:09 <edwardk> from http://www.haskell.org/haskellwiki/Mailing_Lists : Any problems with haskell or haskell-cafe should be reported toÂ haskell-admin@haskell.org, and any problems with haskell-beginners should be reported toÂ DekuDekuplex@Yahoo.com.
15:17:29 <sbahra> mailman@haskell.org
15:18:26 <edwardk> ooh neat paper: http://matt.might.net/papers/might2010mcfa.pdf
15:19:17 <shapr> No torrent for the Linux version of HP?
15:19:30 <danderson> it's too small to matter
15:19:36 <danderson> since it doesn't include all of GHC
15:19:44 <danderson> we used to have one, nobody used it
15:20:05 <poincare101> who wrote haskell?
15:20:09 <edwardk> oh looks like it hit LtU a couple of months back
15:20:16 <shapr> poincare101: Simon Peyton-Jones?
15:20:18 <edwardk> poincare101: lots of people - it was designed by committee
15:20:30 <shapr> danderson: That makes sense.
15:20:38 <Mathnerd314> shapr: why is there @get-shapr?
15:20:48 <shapr> Mathnerd314: Because someone wanted me, I assume.
15:21:05 <sbahra> @get-shapr
15:21:05 <lambdabot> shapr!!
15:21:08 <sbahra> heh
15:21:14 <edwardk> poincare101: http://research.microsoft.com/en-us/um/people/simonpj/papers/history-of-haskell/history.pdf describes the history of haskell in some depth
15:21:22 <shapr> Mathnerd314: Actually, I started #haskell many years ago, and I used to run many of the community services on my own server, so it was a useful command then.
15:21:32 <shapr> Er, many of the #haskell community services specifically.
15:21:42 <edwardk> if you had to pick out a 'who's who' of haskell's early design the authors of that paper would be a good place to start.
15:22:16 <shapr> edwardk: Someone offered me a possible internship where I get my name on a paper as one of authors...
15:22:21 <danderson> shapr: specifically, the torrents appeared after the last release of HP, when it got onto reddit and HN simultaneously, and DoS'd hackage.haskell.org :)
15:22:28 <edwardk> shapr: nice
15:22:29 <shapr> danderson: Oh wow!
15:22:42 <balor> What package contains c_opendir?
15:22:49 <shapr> @hoogle c_opendir
15:22:49 <lambdabot> No results found
15:22:52 <shapr> bah
15:23:01 <balor> Ah, it's unix
15:23:05 <balor> makes sense
15:23:17 <danderson> so I put seeded torrents with my server (100mbps, yay) and dons posted the links to ease the pain a bit
15:23:45 <shapr> I'm torrenting!
15:24:36 <danderson> oh, that reminds me, I need to start seeding the rest of the downloads again
15:24:56 <shapr> Are there more Haskell torrents?
15:25:21 <danderson> just the platform for win32 and OS X afaik
15:25:29 <shapr> So, only two then...
15:25:41 <danderson> up
15:25:43 <danderson> yup
15:26:13 <danderson> if there's anything else that makes sense to serve as torrents (large files), I'm happy to provide a fast seed, but there doesn't seem to be much need
15:26:32 <indigopenguin> How does cabal work on a Windows machine?
15:27:33 <BMeph> Sporadically. ;0¦
15:27:33 <FliPPeh> indigopenguin: It puts files wherever it wants
15:27:41 <FliPPeh> At least that's what it did for me.
15:27:44 <BMeph> ;þ
15:27:51 <dons> Gwern-away: sjanssen and i are both still here, and your patch just isn't the highest priority thing at the moment.
15:29:26 <yitz> indigopenguin: it sends an SMS to ndm, and he instructs it what to do each time
15:29:33 <balor> @hoogle Control.Exception.Base
15:29:34 <lambdabot> module Control.Exception.Base
15:29:34 <lambdabot> package base
15:29:34 <lambdabot> package regex-base
15:31:46 <yitz> danderson: i just downloaded hp for the mac. it's not just that it's a big download; it's that hackage.haskell.org is sllooowww.
15:32:34 <dons> yitz: did you try the torrent?
15:32:46 <dons> hackage shouldn't be too slow (i can get 500 kbps here)
15:32:55 <yitz> dons: no. i'm not set up for it - opening ports, etc.
15:32:57 <danderson> yitz: that's the problem. hackage.haskell.org is a very sollicited server, and doesn't have infinite bandwidth
15:33:03 <dons> yep
15:33:10 <danderson> so you can download it from there, when there is little enough traffic
15:33:13 <dons> sparky'll be the new mirror in europe in coming months
15:33:18 <yitz> torrent definitely makes sense.
15:33:20 <dons> which should help.
15:33:24 <dons> and torrents are the more general solution
15:33:25 <danderson> but if traffic goes up, you're going to crawl to 3-4kbps
15:33:26 <yitz> oh good
15:33:27 <balor> @hoolge CDirent
15:33:27 <lambdabot> No results found
15:33:33 <danderson> (which is what happened during the last release)
15:33:51 <yitz> dons: we're thinking of moving c.h.o there.
15:34:01 <dons> there's actually already a noticeable spike in traffic today
15:34:14 <dons> http://abbot.galois.com/mrtg/external-bandwidth-week.png
15:34:18 <dons> prob up about 50%
15:34:40 <yitz> good news
15:34:54 <dons> bandwidth is around 6Mbps though, so there's plenty of capacity to go, and i notice a few seeders on the windows torrent, so presumably that's getting some use.
15:35:00 <yitz> (unless it's spambot noise, which has also been going up a lot lately)
15:36:15 <yitz> besides torrents, we really need to spread out our mirrors
15:37:18 <Igloo> dons: Why's traffic going up?
15:43:13 <dons> Igloo: windows final installer up.
15:43:19 <dons> not longer an RC.
15:44:44 <Mathnerd314> really?
15:44:46 * Mathnerd314 downloads
15:45:37 <Mathnerd314> dons: how long has it been there?
15:45:41 <dons> please use the torrent if you can.
15:45:43 <dons> about 2 hrs
15:46:01 <dons> i should add a little blurb encouraging people to use the torrent, i think.
15:46:03 <danderson> dons: is the windows installer spiking now?
15:47:01 <danderson> dons: seems to be zero traffic on the windows torrent atm.
15:47:15 <danderson> and on that note, 5min of downtime for my seed, need to reboot to tweak network performance
15:47:39 <dons> looks to be as many in the last two hours as all of yesterday, on the windows and torrent downloads
15:47:50 <dons> note that sunday's are pretty quiet, and i've not announced this widely
15:47:55 <dons> so hopefully it'll state pretty quiet.
15:47:55 <danderson> true
15:48:11 <danderson> well, hold back on announcing for another 5min or so, so that I can get my seed back online :)
15:48:15 <danderson> back in a moment.
15:48:18 <dons> hehe
15:50:11 <Mathnerd314> hmm... I need a bittorrent client. dons: recommendations? maybe put a link to a client underneath the torrent?
15:50:32 <danderson> ... and we're back.
15:51:09 <jmcarthur> Mathnerd314: for long term or basically just one torrent?
15:51:25 <jmcarthur> i'd go with rtorrent if it's worth taking the time to learn
15:51:31 <Mathnerd314> jmcarthur: I just want to get the haskell platform :p
15:51:32 <Cale> I like deluge
15:51:35 <jmcarthur> otherwise something easy like deluge
15:51:42 <jmcarthur> i like deluge too
15:51:43 <danderson> Transmission is a good one
15:51:53 <jmcarthur> transmission is my favorite on os x
15:51:55 <danderson> (both for one-off and long term serving)
15:52:05 <jmcarthur> good for one offs too, yes
15:52:19 <danderson> speaking of which, folks grabbing the platform, if you can stand to leave it seeding for a week or so, it may help a little during the release
15:52:48 <aavogt> didn't some people offer to mirror it?
15:53:48 <Cale> Transmission is good for people who aren't obsessive about monitoring things ;)
15:53:48 <danderson> I'm seeding the platform from a fast server.
15:53:48 <danderson> but the point of bittorrent is that swarms help collectively ;)
15:54:10 <danderson> dons: that said, if you also fancy an HTTP mirror, I can also oblige
15:54:52 <yitz> benmachine: are you still around?
15:55:26 <yitz> Igloo: is benmachine == benl of ddc?
15:55:35 <benmachine> :\/
15:55:40 <benmachine> never heard of either benl or ddc
15:55:47 <yitz> oh ok
15:55:57 <benmachine> should I be flattered or insulted? :P
15:56:01 <dons> i think we're good for now.
15:57:32 <benmachine> ben lippmeier? he appears to be significantly better-qualified than me
15:57:47 <benmachine> that is to say, he has qualification
15:57:47 <benmachine> s
15:58:45 <MarcWeber> Liskni_si: ping (scion vim patch)
15:59:26 <Liskni_si> MarcWeber: pong
15:59:42 <MarcWeber> Liskni_si: You know about my github repository?
16:00:06 <yitz> benmachine: yes i wanted to ask ben l. a quick administrative question. nothing to do with qualifications. :)
16:00:23 <benmachine> oic
16:00:24 <Liskni_si> MarcWeber: nope :-)
16:01:00 <MarcWeber> http://github.com/MarcWeber/scion-backend-vim @ Liskni_si
16:01:06 <natesbrain> hi, does anyone here have experience with the Network.HTTP/Browser package?
16:01:23 <chrisdone> danderson: who's that guy at zurich google who's working on youtube and a python html templating lib, he was at zurihac?
16:01:37 <benmachine> natesbrain: a tiny little bit
16:01:59 <Liskni_si> MarcWeber: wow, thanks, I'll check that out
16:02:05 <natesbrain> I'm wondering how I might go about posting a form to a url
16:02:16 <danderson> chrisdone: I was at zurihac, but I was messing with tunskell
16:02:23 <natesbrain> Request objects seem a little, well, generic :)
16:02:25 <MarcWeber> Liskni_si: I did'nt work on it for quite while. Checkout vim-addon-manager, the haskell stuff. If you have any trouble ping me
16:02:26 <danderson> you're probably thinking of tibbe, the fearless organizer
16:02:28 <natesbrain> just wondering what I put in the body
16:02:50 <benmachine> natesbrain: you want a POST request? in my experience the easiest way to do it is with formToRequest in Network.Browser
16:02:53 <chrisdone> danderson: it was a coworker of tibbe's. he came in shortly. hang on i'll get a pic
16:03:10 <MarcWeber> Liskni_si: "I wasn't able to get a meaningful trace" That's on my TODO..
16:03:14 <MarcWeber> I didn't have time to work on it.
16:03:22 <MarcWeber> There is the monad error package which can help here.
16:03:53 <Liskni_si> MarcWeber: did you also get that crash?
16:04:00 <natesbrain> benmachine: well now that's slick.  i hadn't seen that, thanks
16:04:02 <Liskni_si> or is that unrelated?
16:04:15 <MarcWeber> Liskni_si: All I remember is that Vim dies after 15min or so. I just restart it and continue..
16:04:31 <chrisdone> danderson: http://lh5.ggpht.com/_wlGLHRg69T4/S6YqnT51ZmI/AAAAAAAAAZ8/b9TEivyc2wE/s800/IMG_1394.JPG
16:04:39 <chrisdone> who's the guy on the left?
16:04:46 <chrisdone> wearing a hoodie
16:05:05 <Liskni_si> MarcWeber: ok :-). thanks for the link; afk to bed :-)
16:05:07 <danderson> ah, yes, thingies
16:05:08 <danderson> -s
16:05:13 <danderson> darn, what's his name
16:05:16 <MarcWeber> Liskni_si: g8
16:07:13 <MarcWeber> Liskni_si: I think I've missed some updates. I'm new to background-typecheck-file.
16:08:13 <dons> chrisdone: python unicode guy.
16:08:26 <eikke_> is there any reason most basic list functions like take, length are using Int arguments instead of Integral ?
16:08:58 <dons> better performancee in 1992 :)
16:08:59 <chrisdone> dons: yeah what's that guy's name?
16:09:01 <dmwit> The thinking at the time was that if you have lists long enough to explode Int, you're probably going to be exploding your RAM, too.
16:09:16 <eikke_> oh, right
16:09:19 <dons> right. and the implementations weren't good at specializing
16:09:24 <dmwit> Data.List has genericLength and friends, though
16:09:29 <benmachine> eikke_: this doesn't answer your question, but Data.List has some functions like genericTake and genericLength
16:09:34 <aavogt> isn't this still the case?
16:09:36 <benmachine> which work on any Num
16:09:40 <benmachine> hmm
16:09:53 <benmachine> > genericTake (1 :+ 1) [1,2,3,4,5]
16:09:53 <lambdabot>   No instance for (GHC.Real.Integral (Data.Complex.Complex t))
16:09:54 <lambdabot>    arising fro...
16:09:54 <eikke_> will check the Data.List counterparts, thanks!
16:10:03 <yitz> @type genericTake
16:10:04 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
16:10:04 <benmachine> oh, I am denied my silliness :P
16:10:09 <dmwit> aavogt: With 64-bit machines, it's possible (though expensive) to have enough memory to store a list longer than Int can index. =)
16:10:16 <benmachine> although
16:10:24 <benmachine> > genericLength [1,2,3] :: Complex Double
16:10:25 <lambdabot>   3.0 :+ 0.0
16:10:28 <benmachine> whee
16:10:28 <dmwit> aavogt: (Int only guarantees 29 bits, and one of them is for negative numbers.)
16:10:29 <Veinor> dmwit: and when you say expensive, you mean expensive :D
16:10:32 <benmachine> silliness restored
16:10:35 <aavogt> dmwit: but the Int is proportionally longer...
16:10:44 <dmwit> aavogt: That's not guaranteed, no.
16:10:51 <aavogt> > maxBound :: Int
16:10:52 <lambdabot>   9223372036854775807
16:11:07 <benmachine> dmwit: you could have a list for which calculating the length didn't ever require having it all in memory at once, couldn't you?
16:11:10 <dmwit> aavogt: GHC happens to implement Int as a machine-word sized thing, but it might not in the future. =)
16:11:14 <eikke_> > take ((fromIntegral (maxBound :: Int) + 1)) [1,2..]
16:11:14 <lambdabot>   []
16:11:19 <eikke_> that surprised me :D
16:11:26 <benmachine> hah
16:11:29 <dmwit> benmachine: Well, sure, and that's why we have genericLength these days. =)
16:12:04 <aavogt> @src length
16:12:04 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
16:12:11 <benmachine> and genericIndex which is approximately one billion times less convenient than !!
16:12:35 <benmachine> but then listToMaybe . drop n is better than either anyway
16:12:39 <benmachine> *genericDrop
16:12:56 * dmwit suggests import Prelude hiding (!!); (!!) = genericIndex
16:13:05 <benmachine> ((!!))
16:13:09 <benmachine> due to silly
16:13:11 <dmwit> Anyway, (!!) is a code smell.
16:13:13 <aavogt> monomorphism!
16:13:15 * ddarius suggests import Prelude hiding ((!!))
16:13:41 <benmachine> import Prelude hiding ((!!)); (!!) = error "one partial function is as good as another, right?"
16:13:46 <mreh> should I try and implement a haskell runtime for flash?
16:13:57 <benmachine> mreh: sounds scary
16:14:14 <benmachine> which is my way of saying, I have absolutely no information of relevance or interest to your question
16:15:11 <zygoloid> error's not so much partial as nonetial
16:15:12 <mreh> i can type check the code using a mature compiler, then I could just interpret it using an arbitary runtime system
16:15:32 <mreh> maybe compiling to byte code for efficiency
16:15:58 <mreh> then using some API for the flash environment, we have interactiv haskell running in browser
16:16:11 <mreh> more games in haskell!
16:16:30 <mreh> this is just a crazy idea I had, please feel free to sanity check it
16:16:36 <MarcWeber> mreh: HaXe may be of help
16:17:23 <QtPlatypus> Isn't flash SVG + emca script?
16:17:45 <MarcWeber> QtPlatypus: There are some extensions. Eg you can give vars a type.
16:18:16 <QtPlatypus> MarcWeber: But we would be able to do it as a verant of javascript.
16:19:11 <eikke_> slightly related: I understood YHC would have a JS backend, but I couldnt get YHC to compile on my system -> is it maintained?
16:21:05 <mreh> the whole question of language translation is an interesting one, has anyone formally studied it?
16:21:47 <aavogt> look for stuff on compilers
16:21:53 <mreh> where does the majority of effort in programming the GHC go? is it all debugging for specific architectures?
16:25:47 <mreh> my compiler knowledge was all tainted with *spits* java
16:29:22 <ddarius> "Lieutenant Wellordering means well, but can still accomplish by laziness and gullibility what General Recursion does by sheer incompetence."
16:29:55 <fax> yeah lol
16:30:05 <fax> im way jelous of his writing skills
16:30:53 <Twey> Nice
16:32:58 <mreh> is this LYAH?
16:33:24 <zygoloid> this is epilogue
16:33:55 <zygoloid> http://www.e-pig.org/epilogue/?p=469
16:34:29 * mreh reads the first sentence and is confused
16:34:31 <mreh> never mind
16:34:43 * FauxFaux opened the paper. /o\
16:36:18 <edwardk> mreh: conor is like that ;)
16:36:20 <benmachine> does anyone actually use yi
16:36:28 <Gwern-away> I do
16:36:35 <benmachine> oh
16:36:44 <edwardk> Gwern-away: man, now i can no longer say nobody uses it. ;)
16:36:57 <benmachine> what configuration thing do you use
16:37:13 <mreh> some people are incapable of putting things simply
16:37:14 <Gwern-away> dons: it isn't my patch; it hasn't been highest priority now for half a year?
16:37:22 <Gwern-away> benmachine: look in Users/
16:37:26 <mreh> but maybe that's not what he wants
16:38:09 <dons> Gwern-away: right.
16:38:13 <dons> thanks for poking.
16:38:26 <benmachine> Gwern-away: I don't seem to have Yi.Users.anything
16:38:37 <Gwern-away> dons: if you guys really are that insanely busy, then maybe you should add some maintainers
16:38:55 <Gwern-away> benmachine: I don't think they're installed as part of the lib, but as extra-source-files
16:39:01 <dons> Gwern-away: well, its an interesting question.
16:39:03 <benmachine> ah, okay
16:39:07 <dons> i don't think the core is that active.
16:39:14 <dons> but we should certainly not let patches site.
16:39:16 <dons> sit.
16:39:28 <Gwern-away> benmachine: or maybe not. I don't see my config listed in the cabal, so guess you need darcs
16:39:34 <benmachine> darcsing now
16:39:42 <ddarius> Damn the (now renamed) BCAM.
16:39:56 <Gwern-away> dons: >8 patches right now active for core: http://darcswatch.nomeata.de/repo_http:__code.haskell.org_xmonad.html
16:40:11 <Gwern-away> ddarius: and damn the Hussars too!
16:40:26 <dons> great, thanks!
16:40:57 <BMeph> Are there any useful record tutorials out there?
16:41:28 <Gwern-away> BMeph: are records really hard enough to merit full tutorials?
16:41:52 <Gwern-away> dons: if core isn't that active, it's not to the contributors we should look, I think
16:42:16 <mreh> BMeph: the syntax isn't too bad, you need to get used to it
16:42:17 <ezyang> BMeph: WAYRTTD?
16:42:56 <ezyang> mreh: I dunno, fclabels/data-accessor is kind of nice :-)
16:43:14 <BMeph> mreh: No, you don't understand; I get the syntax, but my use-case is crying out for another solution. :)
16:43:38 <mreh> BMeph, what is it?
16:43:44 <benmachine> so you really want non-record tutorials :P
16:44:47 <dons> Gwern-away: the intent is that it shouldn't be very active.
16:44:50 <BMeph> I have a five-component type that I sometimes want to internally edit, and other times, pattern match on parts.... Now that I think on it, fclabels may be just what I want.
16:44:59 <djahandarie> Ahhhh papers are so much nicer to read when they have colouring in their notation
16:45:16 <Gwern-away> benmachine: no, I think he wants record non-tutorials
16:45:46 <mreh> what's wrong with the current syntax for updating records?
16:45:58 <Gwern-away> "I've frequently not been on boats." "No no... what you've been is not on boats."
16:46:34 * djahandarie pushs Gwern-away off the boat
16:46:37 <mreh> ship { sheilds = shields ship - 1 } -- what  could be less confusing than that?
16:46:51 <mreh> minus the spelling errors
16:46:53 <Cale> The same line without the spelling error
16:46:58 <mreh> haha, noticed it first
16:47:09 * BMeph has frequently been on not-boats...
16:47:20 <djahandarie> Cale, see my message?
16:47:33 <Cale> Which one?
16:48:00 <edwardk> mreh: use data-accessor or fclabels and they suck less.
16:48:10 <djahandarie> Cale, apparently (regarding quiver stuff), if G is a finite group, it can be rewritten via Artin-Wedderburn to a direct sum of matrix algebras... and you'd get one Artin-Wedderburn block for each irreducible representation. And then you'd be able to find a rich family of a family of orthogonal idempotents... so my question still lies as to what the theorem is, because I thought that these symmetric algebras have multiple orthogonal minimal id
16:48:12 <Gwern-away> mreh: I think part of the problem is that people might want to use 'shields' as a different function
16:48:22 <ezyang> I guess I should blog about fclabels for tomorrow
16:48:43 <mreh> edwardk: I tried, but inertia made me stick with them when I was unable to grok them quickly enough
16:49:17 <mreh> Gwern-away: this happens in my Yampa loads, so I just put a suffix on everything
16:49:24 <Gwern-away> mreh: zacl;y
16:49:50 <mreh> Gwern-away: it is a primitive solution
16:49:59 <mreh> like many solutions we see in the world today
16:50:01 <djahandarie> By that I mean a family of elements $c_i$ so that $c_i^2 = c_i$ and $c_i c_j = 0$ when $i \neq j$.
16:50:44 <fax> woah
16:50:48 <fax> do you have latex working on IRC
16:50:52 <fax> (I don't)
16:51:09 <djahandarie> No, but I might as well just use it. :P
16:51:49 <Mathnerd314> dons: if BitTorrent is the preferred method, should it come first on the download page?
16:52:08 <aavogt> @arr
16:52:08 <lambdabot> Avast!
16:52:12 <Gwern-away> we need clients autorunning turing complete languages like latex like we need ActiveX in IRC...
16:52:25 <Cale> djahandarie: hmm, you mean passing to some group-ring on that group which somehow turns out to be a semisimple ring so you can apply Artin-Wedderburn to that?
16:52:30 <dmwit> It doesn't take long working with LaTeX before you have a working preprocessor between your eyes and your brain.
16:52:44 <dons> Mathnerd314: its an interesting idea, yes
16:56:52 <djahandarie> Cale, the group algebra C[G] over the complex numbers is essentially a semisimple ring, no?
16:57:31 <djahandarie> Any finite group G and field K whose characteristics does not divide the order of G is a semisimple algebra
16:58:01 <djahandarie> Forget the name of the theorem
16:58:02 <djahandarie> :P
16:58:39 <Cale> djahandarie: I seem to recall something like that. It's been a while since noncomm :)
16:59:27 <Cale> Is that Maschke's theorem?
16:59:43 <Cale> seems so :)
16:59:51 <djahandarie> Ah yeah thats it
17:01:00 <djahandarie> But after getting the orthogonal minimal idempotents... I thought that each should represent a vertex in the quiver, but it seems that they don't... or something
17:01:25 <danderson> is there any way to ask ghc whether a binary (built with --make) needs recompiling or not, without doing anything?
17:03:49 <Cale> danderson: Maybe -n?
17:24:50 <poincare101> danderson: that doesn't make any sense.
17:25:14 <danderson> poincare101: hmm?
17:30:27 <mail> how can i check the type of a parametre passed to the function?
17:30:42 <Cale> mail: It's known statically.
17:30:54 <Cale> mail: (At compile time)
17:31:01 <fax> I thought that said "statistically"!
17:31:27 <Cale> mail: You can go into ghci and ask for the type of the function using :t
17:33:02 <Cale> mail: Or is that not what you're asking?
17:38:36 <mail> functiondef  :: a -> b -> c
17:38:44 <fax> a is the type
17:39:11 <mail> a and b can only be say fictional datatypes Number or Expression
17:39:19 <mail> possible?
17:39:40 <fax> by the way you can make a class like  class Name a where name :: a -> String  with   instance Name String where name _ = "String"  instance Name Bool where name _  = "Bool" ...
17:40:01 <fax> then  functiondef :: Name a => a -> b -> c would let you use name on the 'a' thing to see which one it is
17:40:33 <fax> you have to write.. Number -> Expression -> c
17:40:55 <mail> both a and b can be Number or Expression
17:41:07 <mail> but only number or espression
17:41:13 <fax> oh
17:41:27 <mail> then i want to different things depending on if it's a number or expression
17:41:30 <fax> well you can form a new type,  Either Number Expression -> Either Number Expression -> c
17:41:43 <fax> @src Either
17:41:43 <lambdabot> Source not found. :(
17:41:46 <fax> hm
17:41:54 <fax> data Either a b = Left a | Right b
17:58:58 <zong_sharo> can anyone help me to understand how to use http://hackage.haskell.org/package/records
17:58:58 <lambdabot> zong_sharo: You have 1 new message. '/msg lambdabot @messages' to read it.
18:03:02 <byorgey> zong_sharo: haha, you and me both
18:04:29 <byorgey> zong_sharo: from what I can figure out you make a data type  data Field = Field deriving (Show) for each field you want to have
18:04:34 <byorgey> and make it an instance of Name
18:05:01 <byorgey> then you can write records like   X :& Field1 := value1 :& Field2 := value 2 &: ...
18:05:28 <byorgey> which will have type  X :& Field1 ::: Type1 :& Field2 ::: Type2 &: ...
18:05:33 <byorgey> where value1 :: Type1 and so on
18:05:59 <fax> wow that sounds crazy
18:06:15 <byorgey> but I am not exactly clear on how to USE a record once you have it
18:06:22 <dmwit> > let average x y = (x .&. y) + (xor x y `div` 2) in average 45 706 -- wicked
18:06:23 <lambdabot>   375
18:06:26 <byorgey> I guess you have to use the 'fold' method from the Record class, but it has a crazy type
18:07:23 <byorgey> and I am really not sure what you can give to fold as an argument
18:07:29 <byorgey> some examples in the documentation would help a lot.
18:07:31 <dmwit> > ((maxBound - 1) + (maxBound - 1)) `div` 2 :: Int
18:07:32 <lambdabot>   -2
18:07:48 <dmwit> > let average x y = (x .&. y) + (xor x y `div` 2) in average (maxBound - 1) (maxBound - 1) :: Int
18:07:48 <lambdabot>   9223372036854775806
18:08:21 <byorgey> dmwit: crazy, how does that work?
18:08:28 <djahandarie> ... was one of thsoe suppose to be minBound?
18:08:45 <dmwit> http://aggregate.org/MAGIC/#Average%20of%20Integers
18:08:48 <dmwit> djahandarie: nope
18:09:02 <dmwit> djahandarie: That was to show that the naive definition overflows, but this clever one doesn't.
18:09:12 <djahandarie> Ah, I see
18:10:58 <mauke> > let average x y = x + (y - x) `div` 2 in (maxBound - 1) (maxBound - 1) :: Int
18:10:59 <lambdabot>   No instance for (GHC.Num.Num (a -> GHC.Types.Int))
18:10:59 <lambdabot>    arising from the lite...
18:11:08 <mauke> > let average x y = x + (y - x) `div` 2 in average (maxBound - 1) (maxBound - 1) :: Int
18:11:09 <lambdabot>   9223372036854775806
18:11:43 <byorgey> > let average x y = x + (y - x) `div` 2 in average (maxBound - 1) (minBound + 1) :: Int
18:11:44 <lambdabot>   9223372036854775807
18:11:56 <djahandarie> haha
18:12:08 <dmwit> > let average x y = (x .&. y) + (xor x y `div` 2) in average (maxBound - 1) (minBound + 1) :: Int
18:12:09 <lambdabot>   -1
18:12:39 <djahandarie> I have to say that is pretty damn cool
18:12:48 <dmwit> I totally agree.
18:12:56 <djahandarie> How is it in terms of efficiency?
18:14:03 <dmwit> It's on a page dedicated to doing "relatively obscure low-level things very efficiently"...
18:14:45 <byorgey> well, it involves one bitwise and, one bitwise xor, one shift, and one addition,  as opposed to just an addition and a shift -- but that's not a bad price to pay for never getting an overflow.
18:15:05 <fax> I don't undersatnd it
18:15:12 <fax> what does .&. mean
18:15:19 <fax> :t xor
18:15:20 <lambdabot> forall a. (Bits a) => a -> a -> a
18:15:20 <dmwit> fax: .&. is bitwise and
18:15:23 <byorgey> bitwise and
18:15:44 <byorgey> (x .&. y) computes the places where carries happen when computing x + y
18:15:49 <fax> ah!
18:15:55 <dmwit> > showHex (0xff88 .&. 0x4280) ""
18:15:56 <lambdabot>   "4280"
18:16:14 <mauke> see also http://mauke.ath.cx/stuff/perl/add.pl
18:16:27 <byorgey> x .|. y (bitwise or) computes where there is a nonzero result when computing x + y
18:16:37 <byorgey> so (x + y) = (x .&. y) + (x .|. y)
18:16:52 <byorgey> but then note that (x .|. y) = (x .&. y) + (xor x y)
18:17:16 <byorgey> i.e. if you get a 1 bit, it's because either both bits in x and y were one, or only one of them was
18:17:29 <byorgey> so (x + y) = 2 * (x .&. y) + (xor x y)
18:17:34 <byorgey> then divide both sides by 2
18:17:55 <zong_sharo> byorgey: how do i select something from record?
18:17:59 <dmwit> I actually find going straight from (x+y) to (2*(x .&. y) + xor x y) is easier than putting in the extra step as they did in their explanation.
18:18:35 <zong_sharo> it's in separation class, but it gives me overlapping instances error
18:18:42 <byorgey> zong_sharo: I have no idea!
18:18:46 <zong_sharo> k
18:19:34 <byorgey> zong_sharo: I think we should all send mail to Wolfgang saying "add some examples to the documentation pleeeeeeze"
18:20:03 <byorgey> dmwit: oh really?  how do you think about it?
18:20:33 <dmwit> xor x y gives ones in all the non-carry places
18:20:53 <dmwit> (and x .&. y is the carries, as you explained)
18:21:05 <zong_sharo> byorgey: well, probably i should
18:21:09 <byorgey> oh! I see, and the 2* puts them in the right place =)
18:21:18 <byorgey> nice
18:21:45 <poincare101> ls
18:22:04 <poincare101> BONUS: how far are you from being done with the Monads chapter?
18:22:33 <poincare101> @where RWS
18:22:33 <lambdabot> I know nothing about rws.
18:22:36 <poincare101> @were LYAH
18:22:37 <lambdabot> http://www.learnyouahaskell.com/
18:22:43 <dmwit> ?where rwh
18:22:43 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
18:22:50 <poincare101> dmwit: thank you :)
18:23:15 <dmwit> ?where sigfpe
18:23:16 <lambdabot> http://sigfpe.blogspot.com/
18:23:39 <dibblego> @type \k f g a c -> k <$> f a <*> g c -- is this recognised as a known pattern?
18:23:40 <lambdabot> forall t t1 a a1 b (f :: * -> *). (Applicative f) => (a -> a1 -> b) -> (t -> f a) -> (t1 -> f a1) -> t -> t1 -> f b
18:24:00 <poincare101> > [1..]
18:24:01 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
18:24:29 <byorgey> dibblego: not that I know of
18:24:40 <fax> dibblego: what do you mean
18:24:56 <fax> that's what <$> and <*> is for isn't it ?
18:25:23 <byorgey> dibblego: yeah, seems like it's not much harder to write  k <$> f a <*> g c  than to write   someCombinator k f g a c
18:25:24 <dibblego> @type \k f g a c -> liftA2 k (f a) (g c)
18:25:25 <lambdabot> forall t t1 a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> (t -> f a) -> (t1 -> f b) -> t -> t1 -> f c
18:25:39 <byorgey> and probably clearer
18:26:29 <fax> :t liftAt (liftA2 .) .)
18:26:30 <lambdabot> parse error on input `)'
18:26:31 <fax> :t liftA2 (liftA2 .) .)
18:26:32 <lambdabot> parse error on input `)'
18:26:41 <fax> @pl \k f g a c -> liftA2 k (f a) (g c)
18:26:41 <lambdabot> ((flip . ((.) .)) .) . (.) . liftA2
18:26:46 <fax> rubbish ...
18:26:58 <dmwit> ?pl \k f a g c -> liftA2 k (f a) (g c)
18:26:58 <lambdabot> (((.) .) .) . (.) . liftA2
18:27:05 <fax> @pl \k f g -> liftA2 (liftA2 k) f g
18:27:05 <lambdabot> liftA2 . liftA2
18:27:21 <fax> :t liftA2 . liftA2 :: (Applicative f) => (a -> b -> c) -> (t -> f a) -> (t1 -> f b) -> t -> t1 -> f c
18:27:22 <lambdabot>     Occurs check: cannot construct the infinite type: c = f c
18:27:22 <lambdabot>     In the expression:
18:27:22 <lambdabot>             liftA2 . liftA2 ::
18:27:27 <fax> so that's not worked
18:27:36 <dmwit> fax: That would apply f and g to the same argument, no?
18:27:48 <dmwit> :t on -- a better spelling of liftA2 in that case
18:27:48 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
18:27:57 <dmwit> err
18:28:05 <dmwit> on /= liftA2 -- whoops
18:33:35 <Cale> hmm, GHC 6.10.4 seems confused about the kind of some of the things in Data.Record
18:34:36 <Cale> Perhaps I should take this opportunity to upgrade to 6.12
18:36:28 <Cale> It seems to think that the kind of X is * -> * which is obviously wrong, because it's supposed to take a type function parameter.
18:40:13 <Cale> byorgey, zong_sharo: Out of interest, which version of GHC are you guys using?
18:40:45 <zong_sharo> 6.10.4
18:41:23 <Cale> zong_sharo: Then perhaps you're having the same problem I am.
18:42:02 <Cale> (maybe it's a bug in the library, but I'm going to see if perhaps it's just that 6.10.4 doesn't handle type functions quite as nicely as it ought to)
18:50:47 <mail> anyone know how an inverting op amp works?
18:51:34 <dmwit> This isn't really the right forum for that question.
18:51:43 <drhodes> mail: the ##electronics people are a good bunch
18:51:44 <dmwit> It's pretty quiet, though, I guess.
18:51:54 <Cale> mail: *sort of*
18:53:28 <fax> what is an op amp ?
18:54:54 <Cale> fax: Stands for operational amplifier. It amplifies the difference in voltage between two of its inputs.
18:55:07 <EvanR> by a very large amount ;)
18:57:19 <aavogt> denotational amplifiers
18:59:06 * hackagebot WashNGo 2.12 - WASH is a family of embedded domain specific languages (EDSL) for programming Web applications in Haskell.  http://hackage.haskell.org/package/WashNGo-2.12 (MarcWeber)
19:00:19 <aavogt> MarcWeber: that works for newer ghcs?
19:02:16 <MarcWeber> aavogt: You can be the first one trying it :) I compiled it with current ghc 6.12.1. I fixed some cabal issues and replaced 2 import lines.
19:02:24 <DeathC200> hello my fellow developers :)
19:02:33 <MarcWeber> aavogt: WASH itself only uses basic well known haskell98 extensions. There is no reason why it should break.
19:03:30 <cscheid_> Hi - I'm thinking of doing playing around with haskell gui programming, and was hoping to use either wxHaskell or Gtk2Hs. Do you guys have any opinions either way?
19:03:49 <dmwit> You should use the one you already know from another language.
19:03:53 <aavogt> I mean that base and containers have changed somewhat
19:04:50 <cscheid_> I don't mind learning either API actually. I was just hoping not to start using something that is not at least a little popular
19:04:59 <MarcWeber> aavogt: Well I didn't test it. I made it compile. If it doesn't work someone will tell me :)
19:05:09 <cscheid_> There seems to be a few pretty 'experimental projects
19:05:17 <MarcWeber> cscheid_: I think both are fine
19:05:32 <cscheid_> ... here http://haskell.org/haskellwiki/Applications_and_libraries/GUI_libraries
19:07:53 <cscheid_> MarcWeber: thanks! Do you know if there's anything like wxFruit, Grapefruit etc that is actually being used?
19:09:09 <MarcWeber> cscheid_: No. Try haskell-cafe. This is the universe of knowledge.
19:09:22 <cscheid_> ah, sorry!
19:09:33 <Cale> cscheid_: Feel free to ask questions here of course :)
19:09:54 <Cale> cscheid_: But for a question like that you may very well get a better response from the mailing list :)
19:10:37 <Cale> cscheid_: wxHaskell and Gtk2Hs are the main two GUI libraries -- they're reasonably comparable in terms of quality.
19:11:13 <Cale> cscheid_: However, the amount of abstraction they provide over the imperative libraries that they wrap is not that big.
19:11:30 <MarcWeber> cscheid_: Those who who do are very likely to miss your message here. That's what I was trying to say.
19:11:55 <Cale> cscheid_: So lots of people have tried various things to build up a nice functional abstraction for GUI programming, but there's no clear winner there.
19:12:20 <EvanR> i cant seem to get my head around how a GUI can be functional
19:12:38 <tumult> http://news.ycombinator.com/item?id=1275860 roughly the cont monad in javascript without runCont, i think? i just wasted a few awesome minutes
19:12:49 <EvanR> the concept is very i/o bound, graphical, user interface
19:12:57 <Cale> EvanR: Well, the basic idea is this:
19:13:00 <sbpaul> EvanR: functional reactive programming
19:13:01 <cscheid_> Cale: I just finished reading skimming Peterson's wxFRoot, and that seems fairly exciting
19:13:11 <sbpaul> a recursive function that polls for input
19:13:13 <cscheid_> but no one seems to have picked it up and actually implemented the whole thing
19:13:17 <MarcWeber> EvanR: What's your problem?  doSomething: UserInput -> OldInterface -> NewInterface
19:13:29 <sbpaul> np: Nest - Cad Goddeu (Revised)
19:13:32 <sbpaul> ^ beautiful
19:13:52 <Cale> You have two sorts of things: you have things which are functions of time -- they always have a value whenever you look at them: like the position of the mouse, the current time, the current picture being displayed on the screen, and so on
19:13:56 <MarcWeber> If you could translate this reactive stuff to js, actionscript and such it would be nice
19:14:05 <Cale> and you have things which are discrete sequences of events
19:14:05 <EvanR> Cale: yes
19:14:09 <sbpaul> MarcWeber: i think you can...
19:14:12 <Cale> (keypresses, mouse clicks)
19:14:17 <sbpaul> though i'm not a JS expert
19:14:20 <sbpaul> by any means
19:14:26 <EvanR> k
19:14:59 <Cale> The idea is that a GUI model is a declarative specification of how input behaviours and events correspond to output behaviours and events
19:15:19 <Cale> That is, the same 'model' as in 'model view controller'
19:16:22 <Cale> The question is just how can we represent these behaviours and event streams such that we can write functions on them and recover reasonable performance from our programs.
19:16:25 <david_> hey, kind of a newbie question but does anyone know why in this paste ghc says I'm giving showTree too many params? http://codepad.org/huPAOJqJ
19:16:45 <sbpaul> cause you're giving it too many params ;)
19:16:53 <david_> heh figured that
19:17:01 <sbpaul> let's see...
19:17:04 <Cale> That is, we don't want to leak memory horribly by retaining the entire sequence of keystrokes from the very beginning of the program's operation forever.
19:17:08 <david_> I have showTree surrounded by ()
19:17:09 <cscheid_> david_ is that simply an extra x there?
19:17:22 <david_> oops
19:17:27 <sbpaul> ah yeah see
19:17:30 <sbpaul> the error explains it
19:17:34 <david_> forgot that when I copied some stuff from before
19:17:35 <david_> thanx
19:17:52 <sbpaul> we <3 you too david_
19:18:17 <cscheid_> it'd be nice if ghc let you know about unused params - there's probably a flag?
19:18:57 <david_> sbpaul, aww thanks
19:19:14 <david_> most of the programming channels on freenode can be a bit frustrating
19:19:16 <david_> lots of love here
19:19:37 <sbpaul> actually i'm just kidding
19:19:41 <sbpaul> piss off kid ;)
19:19:41 <aavogt> cscheid_: yeah, it's included with -Wall, though there's definitely a specific -fwarn-unused-binds or something
19:19:44 <EvanR> Cale: a gui reacts to events using its old state, producing a new state, and perhaps i/o commands (separate from the graphical stuff)
19:19:49 <sbpaul> everybody here hates everyone else
19:19:56 <sbpaul> i really hate EvanR
19:20:02 <sbpaul> >:::OOOOOOO
19:20:44 <EvanR> Cale: seems like its more natural to just write imperative event handlers which can mutate state at will
19:20:46 <Cale> EvanR: There needn't really be anything which you necessarily call a state.
19:21:12 <monochrom> I hate all those who are hated by all those who hate whom I hate.
19:21:17 <Cale> EvanR: It's really just sending some time functions and event streams to other time functions and event streams :)
19:21:20 <cscheid_> EvanR: and state has a knack for not composing very well
19:21:27 <EvanR> sure does!
19:22:25 <dmwit> monochrom: Proof. tauto. Qed.
19:22:55 <EvanR> Cale: so the time functions would be used to model an animating widget
19:23:12 <Cale> EvanR: yes, for instance :)
19:23:39 <Cale> EvanR: At least, semantically, we ought to be able to write programs which appear this way.
19:24:07 <Cale> EvanR: Of course, the way in which things are implemented might involve internal state and so on, but the programmer need not be exposed to that
19:24:15 <EvanR> a lot of times the animation depends on something besides time
19:24:21 <Cale> EvanR: Of course
19:24:33 <aavogt> <3 ListT
19:24:42 <Cale> EvanR: Which means that the output behaviour will be a function of more than just time, but also a bunch of input behaviours.
19:24:48 <Cale> (or event streams)
19:26:21 <EvanR> event could be user input, but also an event produced by some other reaction?
19:26:22 <Cale> EvanR: So, the position of my spaceship, say, will be the integral of the spaceship's velocity, which in turn will be the integral of its acceleration, which will be the sum of the acceleration due to gravity, and an acceleration which depends on the last keypress event.
19:26:45 <Cale> We want to be able to express things like that :)
19:27:21 <MarcWeber> Cale: Shouldn't you write a wiki article and quote that ? :)
19:27:47 <Cale> Why?
19:28:08 <Cale> I'm not even really an expert on this, and Conal's got tons of stuff written already :)
19:28:22 <EvanR> ive been thinking of a similar setup for a game, ive been wondering if there are any hard limitations or situations that are awkward there
19:28:42 <dmwit> MarcWeber: Have you seen flapjax?
19:29:16 <EvanR> though, i suppose a (to some) surprising number of common tasks in imperative programming are awkward
19:30:54 <Cale> Weird that the Haskell platform seems to require cabal-install==0.8.0 when 0.8.2 is out.
19:31:20 * Cale downgrades
19:32:06 <Mathnerd314> good/bad idea to post the new platform to reddit?
19:32:34 <Cale> If dons somehow hasn't beaten you to it
19:32:39 <EvanR> Cale: let Behavior be a 'function of time' from above, to specify a reaction, would we say that its a function Behavior -> Event -> (Behavior, [Event]), the new behavior having possibly new facilities to interpret events?
19:33:15 <EvanR> that is, reaction changes behavior by producing a new behavior
19:33:42 <Mathnerd314> well, it's just on the haskell reddit... proggit, for example...
19:33:45 <Cale> EvanR: Yeah, there would typically be lots of facilities for constructing behaviours which switch between a number of options according to a stream of events, or which somehow integrate or summarize an event stream.
19:35:34 <Cale> huh, installing GHC 6.12.1 hasn't helped the situation with the records package.
19:35:57 <Cale> It still gives the wrong kind to the record type constructors
19:36:15 <kmc> is there a new HP, or only for windows?
19:36:22 <Mathnerd314> just windows
19:36:37 <Mathnerd314> the rc turned into a real release
19:36:38 <monochrom> dmwit knows my tautology :)
19:36:41 <Sgeo> "Multiplication can cause side-effects"
19:36:42 <Cale> I wonder if I can fix things with some manual kind annotations
19:37:18 <MarcWeber> dmwit: Sure.
19:37:34 <EvanR> Cale: if entities can react to events by sending new events to other entities or by doing non graphical output commands, then we have a situation analogous to message passing object oriented
19:38:09 <Cale> EvanR: It's sort of like that placed on its side, yes :)
19:39:52 <kmc> Sgeo, "the time needed to figure out what a+b actually means is an exponential function of the number of types, implicit conversions, template specializations and overloaded operator versions involved"
19:40:28 <Sgeo> kmc, is that from someplace?
19:40:44 <Sgeo> o.O, sounds like C++
19:40:51 * Sgeo was referring to a spec of an esolang
19:41:41 <kmc> C++ FQA
19:41:50 * Sgeo nightmares
19:41:54 <kmc> hehe
19:42:03 <fax> frequently questioned answers?
19:42:07 <Sgeo> For what it's worth, I was quoting from http://catseye.tc/projects/n-dcnc/doc/readme.txt
19:42:18 <EvanR> Cale: so the only question left is what is the most convenient way to specify the total system out of which primitive parts
19:42:30 <Sgeo> Which is not intended to be sane. C++.. is
19:42:39 <EvanR> i meant to say something less general and meaningless than that
19:42:41 <kmc> Sgeo, i've seen little evidence for that
19:42:44 <Sgeo> It's like the difference between parody and reality, when reality turns out to be worse
19:42:48 <kmc> i think C++ is best thought of as an esolang
19:42:49 <kmc> yes
19:42:52 <fax> haha
19:43:05 <kmc> it's fun to learn, fun to figure out how to do some trivial things in only 300 lines of code
19:43:07 <EvanR> i was thinking of writing an esolang 'manual' for php
19:43:08 <kmc> not fun to use for practical stuff
19:43:12 <kmc> haha EvanR
19:43:31 <kmc> the line about multiplication causing side effects would not be out of place in a description of C++, C#, Python, Ruby, etc.
19:43:48 <kmc> plenty of languages where (*) is overloadable and can have side effects
19:44:06 <Sgeo> Multiplication is used for loops in 'N-DCNC
19:44:09 <kmc> the best thing is, in C++ you can make a "const" *and* a non-"const" version, and have them do totally unrelated things
19:45:01 <EvanR> in many languages you can do ridiculous and obviously braindamaged things. in practice we usually avoid that and try to do things the best we can given the circumstances, but the norm in php is to do braindamaged and ridiculous things
19:45:18 <kmc> yeah
19:45:23 <kmc> like include source over http
19:45:27 <kmc> what can go wrong
19:45:31 <EvanR> haha
19:45:37 * Sgeo posts kmc's statement as his Facebook status
19:45:42 <ddarius> Should I read about combinatorics, algebraic geometry, applications of wavelets to graphics, or just read a novel?
19:45:43 <kmc> which?
19:45:50 <Sgeo> "<kmc> I think C++ is best thought of as an esolang. It's fun to learn, fun to figure out how to do some trivial things in only 300 lines of code. Not fun to use for practical stuff."
19:46:14 <frivol> ddarius, read a book on decision making.
19:46:23 <nus> ddarius, better write a novell about at least two of first three (-:
19:46:25 <monochrom> read a novel on haskell
19:46:42 <Mathnerd314> @remember kmc I think C++ is best thought of as an esolang. It's fun to learn, fun to figure out how to do some trivial things in only 300 lines of code. Not fun to use for practical stuff.
19:46:45 <lambdabot> Okay.
19:46:50 <cscheid_> Hm. I can get a simple, no-frills wxHaskell program to run fine on ghc, but "ghci -package wx" fails on wxcore, not finding libstdc++.so. Is this known/should I stick to ghc only?
19:47:25 <fax> ddarius - djvu uses wavelets
19:48:13 <kmc> ddarius, get high and read all three books interleaved on a per-sentence level
19:48:48 <monochrom> all four
19:49:56 <cscheid_> (this is on ghc 6.12.1, cabal 0.8.0, x86_64 linux)
19:50:55 <nus> cscheid_, ubuntu?
19:51:04 <cscheid_> nus: yeah, 10.04 beta 2
19:55:09 <nus> cscheid_, http://wiki.wxpython.org/InstallingOnUbuntuOrDebian
19:55:49 <nus> i.e. apt.wxwidgets.org packages perhaps are better
19:56:08 <nus> short of rolling your own
19:59:20 <cscheid_> nus, does wxHaskell require wx2.9? I am running 2.8.10.1, which http://www.wxwindows.org/downloads/ claims is the stable release
19:59:51 <cscheid_> and compiling the code works fine - it's just running via ghci that is trouble
20:01:06 <nus> cscheid_, check if there's libstdc++.so link at all
20:03:21 <cscheid_> yeah, libstdc++.so is where it's supposed to be: /usr/lib, symlinked from /usr/lib/gcc/x86_64(...)/libstdc++.so :) specifically, "ghc -package wx main.hs -o main" works, and ./main runs ok. but "ghci -package wx" fails
20:09:30 * hackagebot meldable-heap 1.1.1 - Asymptotically optimal, Coq-verified meldable heaps, AKA priority queues  http://hackage.haskell.org/package/meldable-heap-1.1.1 (JimApple)
20:09:34 <_martin_> What's the best way to store a large list to disk so I don't have to recompute it every time?
20:09:55 <_martin_> I just came over from Python.
20:10:01 <nus> cscheid_, http://hackage.haskell.org/trac/ghc/ticket/3798
20:10:13 <kmc> _martin_, how large?
20:10:39 <blackh> _martin_: 'show' and 'read' are the most convenient way, but they are a little slow.  If speed is important, you can use the binary package, which requires a bit of extra work.
20:11:41 <_martin_> When I pickled them in Python and put them in a sqlite db, it was 688 MB
20:11:44 <cscheid_> nus, thanks, I had seen that. It
20:11:59 <CalJohn> _martin_: use binary
20:12:16 <cscheid_> ... seems that the ghc issue was fixed, but not the ghci. Oh well, ghc it is. Thanks a bunch, I appreciate it!
20:13:03 <kmc> _martin_, that's pretty big for a list in memory even
20:14:07 <kmc> _martin_, each element of the list is at least five machine words: a (:)-cell (3 words) pointing to a data element (>= 2 words)
20:14:18 <Cale> It doesn't necessarily have to be in memory all at once
20:14:22 <blackh> _martin_: If the data structure is complex, this is an opportunity to plug my hexpat-pickle package.  That's for fast pickling to XML.
20:14:31 <kmc> _martin_, if you want to work with large amounts of data in-memory in Haskell, you might want an unboxed array
20:15:00 * Cale contradicts kmc: A lazy list might be perfect depending on the access pattern.
20:15:04 <kmc> it's true
20:15:26 <_martin_> I'm feeding it to a simulated annealing algorithm
20:15:31 <_martin_> so the access pattern is random selection
20:15:42 <Cale> Okay, then a list is the wrong datatype.
20:16:33 <Cale> You should think of lists as being like loops which are waiting to happen.
20:17:15 <Cale> Linear access on a list is very efficient, but anything else is not.
20:17:53 <_martin_> Why couldn't you sort the list randomly and then take its head?
20:18:15 <_martin_> Would that be like a random choice without replacement?
20:18:51 <_martin_> recursively take the head, i mean
20:19:13 <Cale> Well... you could, except that the random sorting is going to take at least O(n log n) time, and will require the whole list to be in memory at once.
20:19:17 <jbapple> Well, the sort will take \Omega(n lg n) time
20:19:32 <kmc> _martin_, a Haskell list is a singly-linked list
20:19:50 <kmc> @remember Cale You should think of lists as being like loops which are waiting to happen.
20:19:50 <lambdabot> It is forever etched in my memory.
20:19:52 <Cale> which, given that lists have a lot of overhead, is no small order for lists of hundreds of millions of elements
20:20:14 <blackh> _martin_: You'd have to shuffle in the right way with a list that big.  The ST monad would be best - then you can do the shuffle in-place.
20:20:24 <kmc> @where shuffle
20:20:24 <lambdabot> http://okmij.org/ftp/Haskell/perfect-shuffle.txt
20:20:36 <jbapple> @where external sort
20:20:37 <lambdabot> I know nothing about external.
20:21:10 <Cale> You probably want an unboxed array for that much data, along with a random permutation of the indices.
20:21:42 <_martin_> OK.  I think I'm getting some direction.
20:21:56 <jbapple> Though if you want replacement, there is no need to store the permutation in its entirety
20:22:02 <Cale> yeah
20:22:23 <Cale> Well, there's no need for a permutation at all. Just generate random or pseudorandom indices as you go :)
20:22:47 <_martin_> right
20:22:49 <jbapple> (Unless you want seelction without replacement)
20:23:45 <_martin_> Thanks for your help, everyone.  I am very impressed with Haskell and its community.
20:24:01 <blackh> _martin_: An immutable array and some way of generating the indices in a random order would work fine.  Another alternative is a mutable array (using ST) and use a standard shuffle algorithm.  Like Cale said, boxing adds a lot of overhead in arrays, so an unboxed array would make a big difference.
20:24:26 <blackh> The array package is more established, but there's a new package called vector that would also do the trick.  I am not sure if vector can be used with ST.
20:24:58 <kmc> it can
20:25:01 <kmc> there are also immutable vectors
20:25:21 <blackh> Great - a mutable vector would do nicely, then!
20:25:58 <blackh> _martin_: If you want to use ST and you get stuck understanding any of it - come back and ask here.
20:26:11 <_martin_> I will, blackh
20:26:23 <blackh> It's broken up into several modules, so it can be difficult to figure out how it all fits together.
20:26:39 <Cale> I usually try to avoid mutable structures as far as is reasonable
20:26:59 <blackh> Cale - I agree, but in this case, it would be really easy to implement a shuffle using a mutable array.
20:27:06 <Cale> But yeah, if you're updating this huge structure repeatedly, mutability might be necessary.
20:30:14 <_martin_> Thanks again, everyone.  Have a good night.
20:31:37 <siracusa> Is there a list of all version numbers of the packages included in the latest platform?
20:32:32 <sykopomp> are there situations where Haskell can't compile type tags out of runtime objects?
20:32:57 <aavogt> existential types?
20:33:27 <sykopomp> probably :)
20:33:52 <kmc> existential types are erased too, i think
20:33:53 <kmc> in GHC
20:34:00 <kmc> there is no way to typecase on what's inside
20:34:13 <aavogt> sure you can
20:34:20 <kmc> all you get is what you bundled together, which is safe relative to itself
20:35:06 <aavogt> I see a   data T = forall a. Typeable a => T a    as carrying type information along
20:35:13 <kmc> i am guessing that operationally,  data X = forall a. X a (a -> Bool)  is no different from data Y = Y Any (Any -> Bool)
20:35:27 <kmc> aavogt, but GHC is oblivious to the fact that Typeable has anything to do with types
20:35:33 <kmc> (except when deriving instances ofc)
20:35:47 <aavogt> why do you make this distinction?
20:35:53 <kmc> the type tags of Typeable are orthogonal to the compiler's own type repr, which in the case of GHC is erased
20:36:32 <kmc> aavogt, because i think that if you take a type-erasing implementation and add something like Typeable as purely a library, it'd be weird if the implementation were no longer considered type-erasing
20:36:55 <kmc> indeed there is no guarantee that Typeable instances are faithful to GHC's type system
20:37:15 <monochrom> The Typeable dictionary is carried. The data constructor tag is carried.
20:37:24 <kmc> and in fact they're restricted to a tiny subset of that system
20:37:30 <kmc> monomorphic types only
20:37:39 <ddarius> There are no "type tags."  There are witnesses to types at run-time in some instances, but they are not types themselves.
20:38:18 <kmc> i would like to see a future version of Typeable which handles a) polymorphism, b) efficient type-compare by direct info ptr inspection
20:38:29 <ddarius> kmc: Look at Cleaon.
20:38:35 <kmc> and that would require specific compiler support, beyond just emitting boilerplate instances
20:39:01 <kmc> ddarius, it has type introspection baked in?
20:39:29 <byorgey> AIUI Epigram 2 will support something like this
20:39:31 <ddarius> kmc: It has some compiler support for a Dynamic type that supports polymorphism.
20:39:48 <kmc> cool
20:40:32 <jon_of_arc> Is it possible to express via types that two variables should be tuples, and that they should be the same type of tuple, but that they need not be a particular type of tuple?
20:40:44 <kmc> jon_of_arc, yes, with polymorphism
20:40:48 <kmc> if by "variables" you mean e.g. function args
20:40:55 <kmc> f :: (a, b) -> (a, b) -> c
20:41:08 <jon_of_arc> But that doesn't take (a,b,c)
20:41:16 <kmc> jon_of_arc, oh, you want polymorphism over tuple size?
20:41:19 <jon_of_arc> Right
20:41:24 <Cale> jon_of_arc: Differently sized tuples are completely unrelated types
20:41:27 <kmc> jon_of_arc, that's not really possible.  the different-sized tuples are totally unrelated types
20:41:42 <kmc> you can't even make a function that takes an arbitrary tuple and gives you the first element
20:41:53 <jon_of_arc> Mm. As I feared, thanks.
20:41:55 <kmc> (you can make a family of functions and give them the same name, using typeclasses)
20:41:57 <Cale> There's no common operations which act on all sizes of tuples which don't also act on every sort of value.
20:42:03 <kmc> (and you can make a function to generate those functions, using Template Haskell)
20:42:18 <kmc> there is on Hackage somewhere a library of typeclass-overloaded tuple operators
20:42:34 <Cale> jon_of_arc: What are you trying to do?
20:42:58 <kmc> jon_of_arc, if you like, you can tell us more about the problem you're solving and we can suggest alternative ways to do it?
20:43:21 <monochrom> @quote monochrom
20:43:22 <lambdabot> monochrom says: I really like insults.
20:43:30 <monochrom> @quote monochrom fugue
20:43:30 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
20:43:36 <jon_of_arc> Calse, kmc: give me a minute, now I have to remember it. (Clearly spent too much time looking for this answer)
20:43:53 <jon_of_arc> Er, Cale. I can spell tonight.
20:45:07 <monochrom> @quote monochrom common
20:45:07 <lambdabot> monochrom says: Monad theory is abstract common sense.
20:45:35 <monochrom> I have long forgotten that one. I should revive it next time someone asks about monads. :)
20:46:51 <nus> @where hlist
20:46:51 <lambdabot> http://homepages.cwi.nl/~ralf/HList
20:48:56 <monochrom> @quote monochrom Laws
20:48:56 <lambdabot> monochrom says: The Three Laws of Types. (1) Must protect programmer. (2) Must obey programmer, when not in conflict with (1). (3) Must protect computer, when not in conflict with (1) or (2).
20:49:36 <jon_of_arc> Cale, kmc: right, that was it. I'm working on providing an attribute grammar library and was looking for the type that the (semantic, not the type) set of attributes on a node should have so I could make certain functions on all attributes be required for the typeclass; other approaches are obvious, but I felt (incorrectly) that there must be some way to make this one work. Thanks for your help, though.
20:51:39 <byorgey> jon_of_arc: maybe try something like HList?  although I'm not sure I quite understand the problem.
20:52:03 <kniu> http://hackage.haskell.org/packages/archive/parsec/3.1.0/doc/html/Text-Parsec-Expr.html#v%3AbuildExpressionParser
20:52:08 <kniu> The example here doesn't work right.
20:52:49 <kniu> a simple "(1+1)" doesn't parse; one has to put parentheses around the second operand: "(1+(1)" --> 2
20:53:49 <kniu> I've been trying to figure out why, since moving (parens) after (natural) doesn't fix it either, and neither does putting either in (try).
20:54:27 <jon_of_arc> byorgey: the real issue is that I got fixated on something I "knew had to be able to be made to work", and was wrong :)
20:55:52 <monochrom> @quote monochrom DesCarte
20:55:52 <lambdabot> monochrom says: data DesCarte = forall a. Think a => Exist a
20:56:43 <monochrom> Good joke when someone brings up existential types. :)
20:59:32 <Sgeo> @quote Sgeo Goldilocks
20:59:32 <lambdabot> No quotes for this person. Sorry.
20:59:34 <Sgeo> Aww
20:59:52 * hackagebot ltl 0.0.0 - Using linear temporal logic (LTL) to verify embedded software and hardware.  http://hackage.haskell.org/package/ltl-0.0.0 (TomHawkins)
21:00:05 <monochrom> wow LTL!
21:00:16 <tensorpudding> What is it?
21:01:10 <Adamant> a logic that's more common in EE stuff
21:01:25 <monochrom> You can express "infinitely often foo", "always foo", "eventually foo", etc.
21:01:40 <tensorpudding> Huh, interesting.
21:01:52 <monochrom> where foo is a propositional sentence or yet another LTL sentence
21:02:16 <monochrom> Then you can check the sentence against a finite-state omega automaton.
21:02:17 <ddarius> Always Eventually Crashes
21:04:20 <kmc> on a long enough timeline, the survival rate for everyone drops to zero
21:05:23 <byorgey> jon_of_arc: hehe, fair enough =)
21:05:44 <Mathnerd314> is there a compilable prelude somewhere, for making alternate preludes of?
21:06:05 <nus> eh, protoprelude?
21:06:47 <Mathnerd314> yeah, that's a good name for it
21:07:05 <nus> Mathnerd314, that would be your favorite haskell compiler, then
21:08:08 <Mathnerd314> how so? I don't think it includes source.
21:16:40 <kmc> Mathnerd314, the Report has prelude source doesn't it?
21:17:14 <Mathnerd314> yeah, but it has all this garbage like data Int = ... | -1 | 0 | 1 | ... and such
21:27:10 <kniu> whoops.
21:27:14 <kniu> now I just feel stupid.
21:27:54 <kniu> so in Parsec.Token, the set of reserved op names is supposed to be a subset of the set of possible ops?
21:28:02 <aavogt> protontorprelude
21:28:12 <aavogt> @protontorprelude
21:28:12 <lambdabot> Unknown command, try @list
21:28:41 <kmc> @protontorpedo
21:28:41 <lambdabot> hey guys can haskeel be used to produce fast webapps?
21:28:49 <kmc> @protontorpedo
21:28:50 <lambdabot> and haskell is general purpose?
21:29:16 <Mathnerd314> @help protontorpedo
21:29:16 <lambdabot> protontorpedo is silly
21:29:31 <aavogt> and banned
21:31:16 <Mathnerd314> wait, code.haskell.org is down?
21:31:43 <aavogt> this is a weekly ritual?
21:31:51 <applicative> Mathner314 it was down a bit ago
21:31:55 <aavogt> preflex: seen dcoutts
21:31:55 <preflex>  dcoutts was last seen on #haskell 3 days, 6 hours, 11 minutes and 1 second ago, saying: kmc: btw, I applied your patch about the foreign libs/headers check
21:32:22 <aavogt> preflex: seen Igloo
21:32:22 <preflex>  Igloo was last seen on #haskell 8 hours, 3 minutes and 3 seconds ago, saying: Gwern-away: Yes
21:32:33 <applicative> Mathner314, still searching for the perfect personal Prelude?
21:33:10 <Mathnerd314> yeah. prelude-plus seems pretty good
21:33:41 <applicative> oh wheres that, on hackage?
21:33:57 <Mathnerd314> yeah
21:34:55 <applicative> oh i see, integrates quickcheck things
21:36:08 <applicative> no, i take that back.
21:36:27 <Mathnerd314> yeah; it just imports lots of stuff from other modules
21:36:35 <Mathnerd314> @type (.)
21:36:36 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:37:27 <Mathnerd314> @type Control.Category.(.)
21:37:28 <lambdabot> Couldn't find qualified module.
21:38:55 <applicative> @instances Category
21:38:55 <lambdabot> Couldn't find class `Category'. Try @instances-importing
21:39:21 <nus> @hoogle (.)
21:39:21 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
21:39:21 <lambdabot> Control.Category (.) :: Category cat => cat b c -> cat a b -> cat a c
21:39:21 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
21:40:18 <Mathnerd314> actually, I have no idea where that Functor (.) came from
21:40:46 <applicative> mueval is clearly getting its (.) not from prelude either.
21:40:46 <nus> lambdabot
21:41:01 <siracusa> Mathnerd314: I think it was Cale who defined (.) = fmap
21:41:56 <applicative> the thought is that fa here can be a -> c, and fb b -> c ?
21:42:39 <nus> f :: * -> *
21:43:28 <Mathnerd314> yeah; one could probably do instance Category from that
21:44:17 <applicative> i was thinking of the (.) as fmap.
21:44:52 <Mathnerd314> yeah; how does one unify (.) :: Category cat => cat b c -> cat a b -> cat a c and (Functor f) => (a -> b) -> f a -> f b ?
21:45:16 <nus> @type fmap
21:45:17 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:45:18 <siracusa> f is (a ->)
21:45:34 <Mathnerd314> siracusa: for one instance of Functor, yes
21:45:46 <Mathnerd314> and in the Category, cat is (->)
21:46:32 <applicative> I'm thinking the functor (with c as index or whatever) maps types a, b, etc. to   a -> c  , b-> c, etc
21:47:04 <applicative> then it's a functor, since we can define an fmap for things a -> b
21:48:01 <applicative> but it's contravariant, i'm confused    as usual
21:48:32 <siracusa> applicative: No, it maps a, b to c -> a, c -> b
21:48:34 <applicative> confusion changing...
21:48:35 <Mathnerd314> @instances-importing Control.Category Category
21:48:35 <lambdabot> (->), Kleisli m
21:48:52 <Mathnerd314> @instances Functor
21:48:52 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
21:49:00 <Mathnerd314> clearly a large difference
21:50:26 <applicative> siracusa, i'm still in a muddle.  it has to take an  a-> b thing and make it a   ...a... -> ...b.... thing.
21:51:37 <Mathnerd314> :k (->)
21:51:37 <lambdabot> ?? -> ? -> *
21:52:01 <Mathnerd314> :k (->) Integer
21:52:01 <lambdabot> ? -> *
21:52:16 <Mathnerd314> applicative: make any sense?
21:53:24 <applicative> I dont have trouble seeing a functor there, it's just seeing composition as fmap, i'm getting the order reversed somehow.
21:53:37 <timofonic> Hi
21:53:48 <applicative> @type Prelude.(.)
21:53:49 <lambdabot> Not in scope: data constructor `Prelude'
21:54:00 <Mathnerd314> @hoogle Prelude.(.)
21:54:00 <lambdabot> Parse error:
21:54:00 <lambdabot>   --count=20 Prelude.(.)
21:54:00 <lambdabot>                     ^
21:54:05 <Mathnerd314> @hoogle (.)
21:54:05 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
21:54:05 <lambdabot> Control.Category (.) :: Category cat => cat b c -> cat a b -> cat a c
21:54:06 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
21:54:11 <nus> applicative, fmap is composition is fmap
21:54:42 <timofonic> Do you all think Haskell could be suitable as a start programming language? For someone that even if being novice in maths, liking them and such...
21:55:02 <applicative> So taking Prelude (.) :: (b -> c) -> (a -> b) -> a -> c  we do well to see an fmap lettered so
21:55:21 <applicative> fmap: (b -> c) -> f b -> f c
21:55:34 <applicative> which is what we say.
21:55:49 <applicative> okay
21:56:02 <applicative> the arrows were going backward somewher in my head.
21:56:15 <applicative> timofonic, the answer is Yes
21:56:30 <timofonic> Could Haskell help reduce the typical attention deficit disorder when learning computer programming or make it worser? :P
21:56:48 <timofonic> applicative: Oh, but do you have some argumentation?
21:57:00 <applicative> there is the ancient statement about Lisp, that you can learn it in a day, unless you've learned other programming languages....
21:57:11 <kmc> timofonic, it has a pretty steep learning curve
21:57:16 <kmc> it is not an instant gratification language
21:57:26 <timofonic> applicative: I don't mentioned Lisp...
21:57:29 <kmc> some things that are hard in other languages are very easy
21:57:43 <kmc> many things that are trivial in other languages (e.g. IO) take more learning
21:57:52 <nus> timofonic, attention deficit disorder is PBKAC
21:57:57 <timofonic> kmc: Well, some people get bored when things get too easy :P
21:58:07 <kmc> timofonic, i think you should just dive in
21:58:10 <kmc> and see if it sticks
21:58:14 <kmc> you can come here if you get stuck
21:58:24 <applicative> kmc, many things that are 'programming' in other languages, are just defining your terms in Haskell
21:58:24 <kmc> which is great, because getting stuck is otherwise a way to get bored and wander off
21:58:33 <kmc> what applicative said :)
21:58:54 <kmc> timofonic, basically, in Haskell, expect to think a lot and write little code
21:59:06 <kmc> this is good because you can increase your rate of thinking more easily than you can increase your rate of typing :)
21:59:18 <timofonic> Also, from my very little external experience... isn't Haskell a math nerdy language? It could a nice excuse for improving my maths, I was quite good at maths years ago :)
21:59:35 <applicative> timofonic, there's certainly nothing to be said against trying.  have you tried to install the GHC compiler or the Hugs interpreter?
21:59:40 <kmc> timofonic, i think the connections between Haskell and maths are a bit overblown.  certainly all this you hear "you need two PhD to do IO in Haskell" is total bullshit
21:59:57 <kmc> timofonic, it's more like, the people who find maths an enjoyable way of thinking will also find Haskell an enjoyable and similar way of thinking
22:00:00 <kmc> not that they're directly the same way
22:00:07 <tensorpudding> it's hard not to conflate the two if you sit in #haskell a lot
22:00:09 <timofonic> kmc: Uh, but it's a language more inherent to math logic?
22:00:11 <jmcarthur> you do end up learning a little math though...
22:00:16 <tensorpudding> people in here talk about math a significant amount
22:00:17 <kmc> timofonic, i'm not sure what that would mean
22:00:43 <kmc> timofonic, there is a precise technical connection between statically typed languages and systems of logic
22:00:45 <jmcarthur> haskell being easier to reason about naturally lends itself to mathematical styles of thinking, but that doesn't mean it requires math to learn or anything
22:00:53 <kmc> timofonic, called the Curry-Howard isomorphism.  very cool stuff
22:01:03 <applicative> these reponses are needlessly technical
22:01:09 <kmc> timofonic, but it's not necessarily relevant to writing practical Haskell code
22:01:13 <timofonic> kmc: Logic in philosophy is a shit and there a lot, logic in maths is another, logic in computers is less like in maths...
22:01:14 <applicative> the similarity to logic class is more obvious
22:01:26 <kmc> it's more relevant as a philosophy of what types should do for you
22:01:33 <blackh> timofonic: I'm a programmer who spends all day every day trying to get stuff done.  Haskell lets me get much more stuff done quicker.
22:01:33 <applicative> square x = x * x
22:01:37 <kmc> that types exist to specify and prove properties of programs
22:01:43 <jmcarthur> or, rather, it doesn't necessarily require any maths that are not generally applicable to other languages as well
22:01:46 <kmc> not just (or primarily) to specify representation to the computer
22:01:49 <timofonic> blackh: I see
22:02:17 <applicative> timofonic,  see you've caused a tempest among them....
22:02:28 <jmcarthur> it's mostly stuff you already know but might not have a name for already
22:02:42 <applicative> what jmcarthur said
22:03:14 <applicative> i felt that i had always known haskell, the first few days i was studying it.   of course with numerous curiousities...
22:04:27 <applicative> you just keep defining things, square x = x * x and so on, and then the interpreter or compile unpacks them for you, just the way you would if you were reading through someone else's definitions
22:05:05 <timofonic> Also... I used emacs some time ago... I like it in certain way, having an integrated environment is something it doesn't exist actually (Apple is a lie of layers). Emacs is slow, lisp is slow... why an environment shouldn't be able to even run on a relatively slow computer? Emacs for example also lacks of a proper way to make apps responsive, they don't use multithreading or another equivalent method
22:05:07 <timofonic> for making multitasking something that works somehow :P
22:05:22 <timofonic> applicative: Uh, I have the weird ability to do that at the start :/
22:05:25 <jmcarthur> if you've ever noticed, consiously or subconsiously, that a lot of things have associative operations and also have identity elements, you already know what a monoid is
22:05:33 <jmcarthur> ^^ e.g.
22:06:16 <applicative> yes, what jmcarthur said.  so you might give it a try.  there is frequently difficulty getting it installed the first time...
22:06:40 <timofonic> PEBKAC, nice error message :)
22:06:45 <jmcarthur> i never understood that. i never once had an issue installing ghc and other environment niceties as a beginner
22:07:08 <timofonic> jmcarthur: Oh, so people can't look bad at me when I write loads of pages about weird stories and conspiracy theories? :D
22:07:10 <applicative> jmcarthur, you were better brought up...
22:07:26 <jmcarthur> it was only after i felt confident enough to screw around with things that i messed up an installation
22:07:32 <LegendaryPenguin> whats wrong w/ the map in this? http://pastebin.com/5d3GQYDv
22:07:34 <jmcarthur> like messing with ghc-pkg and stuff
22:07:43 <timofonic> jmcarthur: Oh yes, they'll do it. I mean... writing Haskell stuff instead :D
22:08:21 <applicative> i got Hugs on, became an addict, then it was torture getting the ghc... but i'm an idiot of course
22:08:40 <jmcarthur> maybe i was just using ideal environments
22:08:49 <jmcarthur> i hear it's harder to set up on windows than mac or linux
22:08:52 <timofonic> applicative: I use Archlinux... I really love FOSS, like Linux... but HATE most distros. But this seems less crap
22:09:02 <jmcarthur> timofonic: if you use arch then you will have no issue
22:09:04 <jmcarthur> i use arch
22:09:10 <siracusa> LegendaryPenguin: What's the error message?
22:09:12 <kwallmark> LegendaryPenguin: looks like your indentation for the let/in is messed up, not the map
22:09:14 <timofonic> jmcarthur: Nice
22:09:25 <jmcarthur> timofonic: in fact, quite a few of us do. i haven't figured that one out
22:09:37 <timofonic> jmcarthur: Are you still annoyed by pacman not evolving? For example, so people add crap on top of it :P
22:09:42 <LegendaryPenguin> updated http://pastebin.com/dcMBrDW5
22:10:37 <timofonic> jmcarthur: I don't want another Gentoo or Debian, also I would like a simpler environment structure but that doesn't exist yet...
22:10:37 <Mathnerd314> isn't pacman written in Haskell? :p
22:10:56 <jmcarthur> timofonic: i don't mind so much. if it wasn't for that then we wouldn't have bauerbill (among other things it has support for hackage!)
22:10:57 <kwallmark> "eng" is a character, so [eng] is a string.  String ++ [String] won't work
22:11:26 <jmcarthur> Mathnerd314: no :P
22:11:38 <timofonic> Mathnerd314: Oh, was that a perverse joke? :D
22:11:42 <LegendaryPenguin> oh
22:11:46 <LegendaryPenguin> haha
22:12:01 <LegendaryPenguin> but the second one isnt [String] is it
22:12:14 <LegendaryPenguin> just a String
22:12:16 <applicative> Legendary it would typecheck if it was "A" "B" "C"  not 'A' 'B'
22:12:35 <applicative> ...I think
22:12:48 <LegendaryPenguin> i can do ['a'] ++ "ASD"
22:12:49 <timofonic> jmcarthur: I liked the concept behind Stali (sta.li, funny name) but the suckless guys are so insane they are unable to make it usable (still)
22:13:06 <kwallmark> LegendaryPenguin: good point.  Hmm.
22:13:10 <jmcarthur> timofonic: i haven't tried that one
22:13:15 <timofonic> jmcarthur: Statically linked linux...
22:13:40 <jmcarthur> oh it's a distro
22:14:00 <timofonic> jmcarthur: Tests shown avoiding bloated crap (glibc?), proper app selection and optimizing binaries... can make the envinronment quite faster and such
22:14:16 <timofonic> jmcarthur: And you remove complexity of the tree structure at same time...
22:14:27 <jmcarthur> sounds interesting
22:14:30 <jmcarthur> web site is down though
22:15:26 <applicative> LegendaryPenguin, i'm just making more trouble.   It would help to get rid of the nested lets, so we could survey the types.
22:15:36 <timofonic> jmcarthur: I'd say, I see an environment bloated by things that do the same. Linux distros suffer that, I'd say go to the past and make a very solid environment tightly integrated :P
22:15:41 <LegendaryPenguin> how do I do that
22:15:55 <timofonic> jmcarthur: Haskell OS based on Linux kernel? :P
22:16:20 <jmcarthur> timofonic: why linux kernel? we've got a haskell kernel! ;)
22:16:30 <timofonic> jmcarthur: Well, really?
22:16:35 <jmcarthur> @where house
22:16:35 <lambdabot> http://programatica.cs.pdx.edu/House/
22:16:37 <timofonic> jmcarthur: But hardware support..
22:16:50 <jmcarthur> well yeah, i'm not suggesting anything practical here
22:16:58 <timofonic> "programatica", oh, Haskell isn't a nerdy thing :D
22:17:09 <jmcarthur> but if we're redesigning the OS anyway...
22:18:10 <timofonic> jmcarthur: What demotivates me of actual computing in an extreme and personally destructive way is... everything is a set of unterminated, badly mounted puzzles :p
22:18:13 <jmcarthur> timofonic: house is basically the ghc runtime ported to run on hradware
22:18:25 <jmcarthur> yeah that basically sums things up
22:18:32 <timofonic> jmcarthur: Does he insults you in creative ways too? :D
22:18:41 <jmcarthur> heh
22:18:58 <jmcarthur> the OS should be called lupus
22:19:28 <timofonic> jmcarthur: Invent the name, find an acronym later :)
22:19:32 <timofonic> jmcarthur: (as excuse)
22:19:49 <Mathnerd314> yay, code.haskell.org is back up
22:19:55 <jmcarthur> right
22:20:09 <Mathnerd314> or no, that was just my cache :-(
22:20:21 <timofonic> jmcarthur: This reinventing syndrome is that made me hate actual computer and back into retro stuff...
22:20:28 <jmcarthur> timofonic: we've even got hardware just for haskell. our job should be easy (haha, right)
22:20:50 <jmcarthur> yeah reinventing is one of my big problems with productivity as well
22:21:02 <jmcarthur> @where reduceron
22:21:02 <lambdabot> http://www-users.cs.york.ac.uk/~mfn/reduceron/index.html
22:21:08 <timofonic> jmcarthur: Few ram, few processors, few storage, a language that sucks (BASIC) but you can use assembler... :P
22:21:19 <jmcarthur> that's an outdated link
22:21:37 <jmcarthur> i think this is the correct one now? http://www.cs.york.ac.uk/fp/reduceron/
22:22:38 <timofonic> jmcarthur: Also, I'm starting to hate Google and their products. Well, the searcher works, but I would prefer a proper distributed one without government censoring :P
22:22:57 <timofonic> jmcarthur: I can't conspirate peacefully with the big brother there...
22:23:51 <timofonic> jmcarthur: Uh L4... avoid all signs of contamination from that never ending OS project...
22:25:42 <LegendaryPenguin> got rid of lets http://pastebin.com/sdLtdcR1
22:25:44 <timofonic> jmcarthur: Hurd is the product of some mental disorder, avoid it. It's also a bad copy of Plan9, another insane crap but with a few interesting shit (Unicode?)
22:26:40 <kwallmark> LegendaryPenguin: your outermost map is the problem.  It's giving you twenty-six answers, not one: the answer if the string started with 'A', the answer if the string started with 'B', and so on.  This messes up the type of translateMorseCode, which then confuses your inner map.
22:26:47 <Adamant> Plan 9 had a fair amount of interesting ideas.
22:27:01 <Adamant> I'm not sure what it's justification is at this point, though.
22:27:19 <timofonic> jmcarthur: What if I want... shell interface, modern standards compatible web browser (WebKit based is OK), IM/IRC client, text editor... under Haskell? :P
22:27:29 <Mathnerd314> #haskell == #kernelwarz
22:27:57 <lament> windows sucks!
22:27:59 <nus> timofonic, you write 'em?
22:28:05 <timofonic> Adamant: Plan9 is another mad world domination project, both Plan9 and Hurd were fails but resulted in certain interesting stuff :)
22:28:20 <Adamant> it's not like kernels are that important at this point anyway.
22:28:25 <Mathnerd314> timofonic: Hurd is still under active development!
22:28:33 <timofonic> nus: I just can kick someone to make it write it :P
22:28:38 <Adamant> Mathnerd314: so is Plan 9
22:28:40 <Adamant> IIRC
22:28:40 <timofonic> Mathnerd314: Always in construction :D
22:29:03 <timofonic> "Plan9 is the OS where drivers are easier to write"
22:29:08 <nus> timofonic, what if he kicks back harder, with a badly written code?-) :-P
22:29:09 * ddarius isn't aware of anything interesting coming out of Hurd.
22:29:51 <timofonic> Well, where is it? Even Linux has problems with graphics adapters, those are worser to undertand than vaginas :P
22:30:00 <Adamant> ddarius: Plan 9 had Unicode, /proc filesystem, and attempts to unify everything as a file, at least
22:30:01 <timofonic> (modern ones, ATI/AMD and Nvidia...)
22:30:16 <ddarius> Adamant: Hurd /= Plan 9
22:30:18 <timofonic> nus: Uh, you are right. Kick harder? :)
22:30:27 <Adamant> ddarius: yeah, I know
22:30:32 <timofonic> Adamant: Hurd had... people back to Linux?
22:30:34 <Adamant> hence the 'at least'
22:30:41 <ddarius> Adamant: I'm quite aware of interesting things coming out of Plan 9.
22:30:43 <Mathnerd314> Adamant: http://groups.google.com/group/plan9changes 's last post is 2008
22:31:31 <Adamant> ddarius: just making conversation and agreeing with your basic point.
22:31:37 <timofonic> Think of GNU Hurd like a psychiatrist, it keeps dangerous people in calm :)
22:32:00 <timofonic> I knew a Hurd nerd...
22:32:27 <Adamant> I thought those were only on TV shows.
22:33:23 <nus> timofonic, there's also #haskell-blah
22:33:27 <timofonic> Mathnerd314: The plan9 community consists actually of weird people from universities hacking it and such, I don't see serious plans of making something practical beyond experimenting with it :P
22:33:34 <timofonic> nus: oh, ok
22:36:20 <timofonic> jmcarthur: Back to topic, fast way to Haskell on Arch? http://wiki.archlinux.org/index.php/Haskell_package_guidelines
22:36:25 <timofonic> jmcarthur: There IS no CABAL?
22:36:53 <applicative> 	LegendaryPenguin, you are trying to translate an English string into a list of "--." morse code strings, right?
22:39:16 <applicative> if so the definition should have the form,  translate user_text = map charToMorse user_text or whatever.
22:40:46 <timofonic> jmcarthur: Not in #arch-haskell ? :)
22:41:24 <timofonic> jmcarthur: Why using AUR? Does it improves speed "by resolving C dependendies" and such?
22:41:33 <Katiebug> Can anyone tell me what is going on here? How exactly do these patterns overlap?
22:41:35 <Katiebug> Warning: Pattern match(es) are overlapped
22:41:35 <Katiebug>          In the definition of `delta3':
22:41:35 <Katiebug>              delta3 (0, ' ') = ...
22:41:35 <Katiebug>              delta3 (0, '.') = ...
22:41:35 <Katiebug>              delta3 (0, '(') = ...
22:41:36 <Katiebug>              delta3 (0, ')') = ...
22:42:00 <dmwit> Please use hpaste instead of pasting in-channel.
22:42:12 <Cale> Katiebug: Are those the only patterns?
22:42:13 <Katiebug> sorry >_>
22:42:14 <dmwit> Those patterns don't overlap, so I suspect you're not pasting the whole function (or the whole error).
22:42:30 <Katiebug> Cale: No, there are a few others but they don't seem to overlap either
22:42:35 <Cale> Katiebug: hmm...
22:42:43 <Katiebug> that is the whole error
22:42:51 <Katiebug> I'll paste the rest of the function
22:42:54 <Katiebug> where is hpaste?
22:43:03 <Cale> http://hpaste.org/new
22:43:24 <Katiebug> thanks
22:43:57 <Katiebug> ah crap nevermind, I see the problem >_>
22:44:03 <Cale> ah, okay
22:44:03 <dmwit> Well, I know it's not the whole error, because it doesn't include a line number and column number... =)
22:44:18 <Katiebug> :P
22:44:49 <timofonic> Why Haskell as a own package manager? Why some distros try to avoid or hide it? :P
22:45:29 <Cale> timofonic: You mean cabal-install?
22:46:23 <timofonic> Cale: yep, right?
22:46:28 <timofonic> Cale: And own repo
22:46:50 <timofonic> Like Ruby, Perl... :D
22:47:03 <Cale> It's just a convenient cross-platform way to build and distribute libraries independent of what gets included in, say, a specific Linux distribution.
22:47:42 <timofonic> Cale: So in essence, it's a platform hates the host platform :)
22:47:51 <timofonic> that hates
22:47:58 <Cale> You could choose to only install things which the Debian people happen to package, but not everything on Hackage is of sufficient general interest to be included in Debian.
22:48:14 <Cale> (and Debian does package a bunch of Haskell libraries too)
22:48:26 <timofonic> Cale: I see
22:49:59 <Cale> It's also a heck of a lot more convenient to build things using cabal than autoconf/make, for instance.
22:50:39 <timofonic> I see, Arch guys overcomplicate things. I'm waiting for someone to explain me that cabal2arch shit :D
22:51:32 <sykopomp> timofonic: archers tend to prefer installing packages through their own package manager
22:52:07 <timofonic> sykopomp: I hate mostly all package managers, but if that improves things. But cabal2arch is not so elegant :P
22:52:16 <timofonic> sykopomp: And AUR... :P
22:52:30 <sykopomp> timofonic: AUR is quite nice. I can't speak for cabal2arch.
22:53:08 <timofonic> sykopomp: Well yes, but I'm currently under a slow compy that would make you laugh and an expensive monitor :D
22:53:27 <sykopomp> timofonic: this is not a problem with the AUR.
22:53:34 <timofonic> sykopomp: PIII 733mhz, 256mhz ram and i810 IDP. HP l2475w
22:53:43 <timofonic> sykopomp: Yes, but Gentoo made me to hate compiling
22:54:09 <timofonic> Uh, IGP. lp2475w :P
22:54:10 <sykopomp> then don't compile, that's what the main repos, including community, are for. The AUR is so that packages are still available even when they're not official.
22:54:27 <timofonic> sykopomp: But, haskell is in bytecode?
22:55:00 <sykopomp> I don't understand what you're talking about now. :\
22:55:50 <timofonic> this compy is slower than me trying to understand Haskell, I see there's GHC and it's the popular compiler but also there's bytecode out there :)
22:56:23 <timofonic> Compiling here means making the system slow, it seems multithreading on Xorg isn't something not so well done....
22:56:43 <jps_77> "isn't something not so well done...." means it is well done, am i right?
22:56:46 <jps_77> double negative
22:57:22 <timofonic> jps_77: Lost in translation then, Sorry, English is not my main language. I tried to use irony
22:57:50 <timofonic> Anyway, I'm contamianting the channel with nonsense offtopic, sorry...
22:58:28 <jps_77> timofonic: when people try to say something like "I haven't done anything", they sometimes say "I haven't done nothing", which is a double negative and means the person actually _has_ done something
22:58:37 <applicative> LegendaryPenguin, would something like http://pastebin.com/ac2vMGQM be missing t he point?
22:58:40 <jps_77> i was just pointing out that your statement is possibly a double negative
22:58:52 <timofonic> jps_77: Yes, right
22:59:20 <timofonic> jps_77: I tried to say ironically... after years of development, it's something that still not managed to do?
22:59:24 <jps_77> I can't see compilation being too slow on your machine
22:59:44 <tensorpudding> compilation is kinda resource intensive, by comparison
22:59:45 <applicative> LegendaryPenguin, sorry, forgot to import Data.Maybe for fromJust
22:59:53 <tensorpudding> linking especially
22:59:56 <timofonic> jps_77: So I see the environment becoming slow as hell
23:00:17 <jps_77> tensorpudding: but a P3 should handle a compilation of a medium size project fairly well, would it not?
23:00:27 <timofonic> tensorpudding: I need to learn more computing, maybe it has to do with available threads?
23:00:47 <jps_77> timofonic: I am not doubting your statement, I am just curious as to how it could be true
23:00:57 <timofonic> jps_77: But this poor guy gets slower on other stuff, also the GPU eats ram for 1920x1200
23:01:21 <jps_77> ahh, you are already utilising a lot of your system resources. that could explain it
23:01:25 <timofonic> jps_77: This is a bit exotic and insane computer configuration :P
23:01:38 <timofonic> jps_77: Intel GPU from... 97?
23:02:03 <timofonic> jps_77: Also, only 256mb ram
23:02:19 <timofonic> jps_77: This is somehow a self applied... torture? :D
23:02:33 <jps_77> I believe it is time you invested some money in a new computer
23:03:18 <timofonic> jps_77: Well, I dived into what I'd call "obsolescence". Get used to use computer resources efficiently
23:03:47 <timofonic> jps_77: Also, it's the worser time to get money here. I'll try to find some pieces and mount some computer probably
23:04:02 <jps_77> ahh, I see. that should be good for learning useful resource management techniques
23:04:32 <timofonic> jps_77: Now I avoid youtube too :D
23:04:52 <timofonic> jps_77: Well, I use minitube sometimes in search of a cli replacement :P
23:05:11 <jps_77> you may want to tweak your settings, for example changing your video mode from 1920x1200 to 1024x768, or something like that
23:05:18 <jps_77> it may help with the speed problems
23:05:28 <timofonic> jps_77: Screen resolution is sacred! :D
23:05:35 <aavogt> make sure you're compiling with -O0
23:05:47 <timofonic> aavogt: uhm
23:06:14 <aavogt> it's quite a bit faster to compile that way
23:06:30 <LegendaryPenguin> applicative, its going the other way
23:07:07 <LegendaryPenguin> plus there could be multiple translations
23:07:31 <timofonic> aavogt: Yes, thanks
23:07:46 <timofonic> Also, are Haskell apps resource efficient?
23:08:12 <aavogt> that's only likely if you enable optimizations :)
23:08:39 <timofonic> aavogt: Uh?
23:08:55 <LegendaryPenguin> timofonic, in mathematics there are no resources
23:09:01 <applicative> LegendaryPenguin, are the other translations implicit in your definition?
23:09:41 <jps_77> timofonic: you may be interested in learning C (if you have not done so already)
23:09:52 <jps_77> it is as resource efficient as you make it
23:09:53 <timofonic> LegendaryPenguin: I mean... my computer is slow like shit, will I get bored until dying if using Haskell apps as main tools? :)
23:10:14 <timofonic> jps_77: It is, I tried to learn C a bit yep
23:10:23 <LegendaryPenguin> applicative, http://rubyquiz.com/quiz121.html
23:11:38 <Katiebug> hmm, is it not possible to do something like cs++c as opposed to c:cs in a recursive function?
23:12:20 <LegendaryPenguin> it sucks that i took those lets out of my program
23:12:24 <LegendaryPenguin> now its unreadable mess
23:12:42 <applicative> LegendaryPenguin, http://pastebin.com/rwwm9DNC
23:13:53 <nus> @src (++)
23:13:53 <lambdabot> []     ++ ys = ys
23:13:53 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
23:13:53 <lambdabot> -- OR
23:13:53 <lambdabot> xs ++ ys = foldr (:) ys xs
23:14:10 <LegendaryPenguin> are you sure that will work applicative
23:14:22 <LegendaryPenguin> it has to take something like fromMorse "...---..-....-"  and generate all the possible words
23:14:45 <nus> Katiebug, (:) is the basic constructor
23:16:00 <Katiebug> so if I'm writing a recursive function and want to take the last element from the list instead of the first at each recursion
23:16:05 <dmwit> Katiebug: Correct, you can pattern match only on constructors (not arbitrary functions).
23:16:06 <Katiebug> how would i do that?
23:16:16 <dmwit> Katiebug: Pattern match on the reversed list. =)
23:16:25 <Katiebug> ok
23:16:32 <Katiebug> that's the most efficient way?
23:16:36 <kmc> yes
23:16:38 <kmc> reverse it once only
23:16:48 <kmc> going to the end of a list takes time proportional to the length of the list
23:16:53 <kmc> so you don't want to do it over and over
23:17:55 <Katiebug> ah, I just realized I can't do it that way. I'm trying to implement foldl and foldr but one of the constraints is that I can't use one function in the other
23:18:02 <applicative> LegendaryPenguin, I see now what the problem is, I'm still puzzled how a map over the association list was going to do it.
23:18:05 <Katiebug> so I can't just have foldl reverse the list and call foldr
23:18:19 <LegendaryPenguin> if i concat the list applicative
23:18:30 <LegendaryPenguin> and put in proper return values for when the code is empty
23:18:36 <LegendaryPenguin> then it would actually work
23:20:38 <nus> Katiebug, fac n = foldr (\x g n -> g (x*n)) id [1..n] 1 -- using foldr to simulate foldl
23:21:12 <Katiebug> nus: I specifically *can't* use foldr to implement foldl
23:21:30 <applicative> LegendaryPenguin, yes, but you need to go through all the ways of breaking up the "...---..-....-" into units of 1 2 3 or 4 pieces, which is unpleasant.   This suggests though, eliminating fromJust, and letting the fromMorse return a Maybe String.  Then if one of the ways of breaking up the list doesn't work, it returns nothing.  Then you use a [Just a] -> [a] to return the valid 'parses'.
23:21:37 <ddarius> Katiebug: I think you are misunderstanding the specification of foldl if you are trying to get elements from the end of the list.
23:21:44 <kmc> :t catMaybes
23:21:45 <lambdabot> forall a. [Maybe a] -> [a]
23:21:58 <LegendaryPenguin> applicative, that is what my first map is doing
23:22:35 <Katiebug> ah, I can use init and last anyway
23:22:38 <LegendaryPenguin> the second one is trying to map all the return values onto the current letter
23:23:58 <timofonic> Oh nice, something weird happened. I have a package database corruption! :D
23:24:39 <manjunaths> BONUS, thanks for LYAH new chapters
23:25:03 <LegendaryPenguin> that book has a nice elephant
23:29:49 <kmc> Katiebug, "last" will also walk to the end of the list one by one
23:30:11 <kmc> and "init" will do the same *and* copy all but the last list element (though the data in each element will remain shared)
23:30:23 <kmc> basically, this is the easy way, but there's a heavy performance penalty, if you care
23:31:11 <kmc> a sequence type with less laziness and more efficient operations is implemented in Data.Sequence
23:31:22 <Katiebug> Well, I'm supposed to give "as concise an implementation as possible" so I'm guessing that the complexity of the code is more important than the performance
23:31:26 <kmc> yeah, okay
23:34:41 <Cale> Katiebug: It's not necessary to use reverse, last, or init to implement foldl
23:35:00 <Katiebug> oh?
23:35:13 <Cale> Just plain recursion
23:35:16 <Katiebug> ...
23:35:20 <Katiebug> that's for foldr
23:35:22 <Katiebug> not foldl
23:35:35 <Cale> foldr is indeed more straightforward and natural
23:35:46 <Cale> but foldl can be implemented using just recursion as well
23:36:01 <Katiebug> how so?
23:36:22 <nus> Katiebug, they're the same fold in left in right disguieses
23:36:32 <Cale> In particular, foldl f z (x:xs) is equal to foldl f (...something...) xs
23:38:24 <Katiebug> ah, I see :3
23:40:07 <Katiebug> awesome, thanks
23:41:48 <Cale> foldl has the unfortunate task of having to call itself until it reaches the end of the list, while foldr gets to pass control off to f in the recursive case. For this reason, foldl will never work on an infinite list, while foldr with an appropriate f (one which doesn't always need to look at its second parameter to produce a result) will.
23:44:19 <Cale> On the other hand, with a little additional strictness (which can be inferred by the optimisations in the compiler or added by hand), foldl has the nice property that since it only calls itself with different parameters, it can be compiled into a simple loop.
23:47:06 <nus> iterated destruction vs destruction-while-constructing
23:47:09 <kmc> yeah.  in real code you most commonly see foldr or foldl' (the strict version of foldl)
23:49:38 <applicative> LegendaryPenguin, sorry, lost power.  This is very much a job for a standard parser returning a 'list of successes'
23:57:54 <ddarius> "A new interleaved sampling approach based on the Sudoku puzzle is used to minimize the number of rays per pixel."
23:59:16 <lars9> hey i'm learning haskell's array: http://haskell.org/tutorial/arrays.html; in the tutorial the fibs and wavefront examples in section 13.2, when creating an array, when is its elements evaluated? lazy eval on every array element?
23:59:29 <dmwit> correct
23:59:39 <dmwit> Except for unboxed arrays, which may come later in the tutorial.
