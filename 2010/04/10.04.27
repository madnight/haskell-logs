00:26:57 <whald> haskell wiki sez: "You can even implement unboxed arrays yourself for other simple types, ..." -- anyone can give me a hint how to do that?
00:50:14 <m3ga> is code.haskell.org down?
00:52:55 <ehamberg> http://downforeveryoneorjustme.com/code.haskell.org
00:57:03 <m3ga> thanks ehamberg, its not just me :-(
00:57:41 <tomberek> hey everyone
00:57:54 <tibbe> dcoutts: Did you ever try to manually unpack the buffer parameter to the continuation in the builder monoid to see what speed improvements could be had?
00:58:01 <tibbe> tomberek: hi
00:59:15 <tomberek> tibbe: what's going on?
00:59:33 <tibbe> tomberek: not much, at work :)
01:00:22 <kamatsu> hey, any agda experts here?
01:00:44 <dolio> I know Agda reasonably well.
01:01:14 <kamatsu> i'm trying to do a homework task in agda and i'm getting errors i don't understand
01:02:32 <kamatsu> i'm implementing a fast-reverse function (i.e with an accumulator) for sized vectors
01:03:25 <kamatsu> i got the base case to check, but can't seem to get the recursive case working.
01:04:05 <kamatsu> suc (b + n) != b + suc n of type ℕ
01:04:26 <dolio> Yeah.
01:04:31 <glguy> kamatsu, did you figure it out?
01:04:51 <kamatsu> i assume i have to use the rewrite construct.
01:05:06 <kamatsu> but i tried that and it didn't seem to change anything
01:05:24 <kamatsu> i can give you my code so far in a pastebin
01:05:35 <dolio> Probably a good start.
01:06:43 <glguy> If you have  a lemma  ∀ b n → suc (b + n) ≡ b + suc n
01:06:46 <glguy> you can rewrite with it
01:06:51 <glguy> (I suppose like you just said)
01:06:53 <dolio> Oh, wait, you're trying to use rewrite to change the result type you have to provide?
01:06:54 <kamatsu> glguy: i tried that
01:06:58 <kamatsu> glguy: it didn't seem to do anything
01:07:01 <dolio> I'm not sure if that will work.
01:07:06 <kamatsu> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25089#a25089
01:08:59 <glguy> I think that you have too many parameters as implicity
01:09:01 <glguy> -y
01:09:09 <glguy> but otherwise what you would use is the "subst" function
01:09:20 <glguy> you can use subst to rewrite the type of a value given an equivalence
01:09:24 <kamatsu> right
01:10:20 <kamatsu> so, you're saying i should make n and m explicit parameters/
01:10:28 <kamatsu> sorry, b and c
01:10:41 <kamatsu> and use subst for the rewrite?
01:11:06 <dolio> Man, Data.Vec takes forever to load the first time, too...
01:11:08 <glguy> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25089#a25090
01:11:17 <glguy> that's the answer, so don't look if you want ot work it out
01:11:29 <glguy> subst for the type-level rewrite, yeah
01:11:56 <kamatsu> i see
01:12:01 <kamatsu> ah, i get it now
01:12:13 <kamatsu> but, why wouldn't using the rewrite construct work?
01:12:24 <Maxdamantus> http://codepad.org/NH4D4xkS <-- why might I be getting that error on line 4? O_o
01:12:36 <glguy> it will
01:12:47 <glguy> but you have to use the symmetric equivalence to the one you tried
01:13:18 <glguy> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25089#a25091
01:13:20 <glguy> rewrite version
01:13:42 <Maxdamantus> Neither ghci's nor whatever codepad uses' errors seem to be helpful.
01:13:49 <kamatsu> OH!
01:13:52 <kamatsu> right!
01:13:56 <olsner> Maxdamantus: the function name is after the "where ", so when you put the case to the left of that column it's read as outside the where clause
01:13:57 <kamatsu> aargh
01:14:00 <kamatsu> i see now
01:14:02 <kamatsu> thank you
01:14:10 <olsner> something like that anyway, I don't know the exact layout rules
01:14:11 <glguy> Maxdamantus, is the ) lined up with the 'h'?
01:14:14 <glguy> if so, that is your bug
01:14:46 <glguy> Maxdamantus, also line 4 needs more indent
01:14:55 <glguy> it needs to be more indented than its name
01:14:57 <Maxdamantus> olsner, ah.
01:15:03 <Maxdamantus> Mmm.. I see.
01:16:01 <olsner> I usually put a newline after the where
01:16:07 <glguy> ditto
01:16:25 <glguy> OK, bed time
01:16:27 <glguy> good night
01:17:15 <kamatsu> glguy: dolio thanks alot, i understand now
01:17:55 <dolio> Glad I could help by sitting around waiting for Agda to load all the dependencies of Data.Vec while glguy answered your question.
01:18:51 <Maxdamantus> Hmm.. So what was that about the (? :\
01:22:28 <quicksilver> the ( is fine
01:22:36 <quicksilver> the ) needs to be at least 1 char further in
01:22:49 <quicksilver> so it forms part of the expression which starts on line 7, not a new case.
01:24:57 <Maxdamantus> Hmm.. :\
01:24:58 <Maxdamantus> http://codepad.org/E4vkjlRb
01:25:19 <quicksilver> your h is one space too the right
01:25:33 <quicksilver> that h needs to be aligned with the '
01:26:33 <Maxdamantus> The one on line 8? O_o
01:26:48 * Maxdamantus doesn't like this content-based aligning stuff :S
01:28:01 <ivanm> where is lambdabot? :o
01:28:28 <Botje> Maxdamantus: it takes some getting used to, but it's fine after a while
01:28:39 <Botje> Maxdamantus: you can also revert to braces and semicolons, if you /really/ don't like it
01:28:43 <quicksilver> Maxdamantus: the one with the error in ;)
01:28:56 <quicksilver> Maxdamantus: don't use if it you don't want to; otherwise get an editor which understands it
01:29:02 <Maxdamantus> Mmm.. I'd rather not use braces, I'll just try and get used to the indenting.
01:29:19 <Botje> the important thing is to not mix spaces and tabs
01:29:29 <Maxdamantus> quicksilver, which ' is it meant to be aligned to?
01:29:44 <Botje> and to remember that more indentation is a {, less is a }
01:29:47 <Maxdamantus> The 2nd one on line 7? (']')
01:30:21 <Maxdamantus> Mmm.. I should probably figure out how to get vim to stop doing the autotab crap.
01:30:42 <quicksilver> Maxdamantus: no, the first one on line 7
01:30:47 <quicksilver> Maxdamantus: it's not a difficult rule :)
01:30:54 <Maxdamantus> Where if I hit enter on a line with lots of spaces, it indents to where I am, but then swaps all tabs on the new line with 8 spaces.
01:31:01 <quicksilver> Maxdamantus: each case alternative must begin at the same column.
01:31:04 <ivanm> preflex: seen lambdabot
01:31:04 <preflex>  lambdabot was last seen on #xmonad 2 hours, 20 minutes and 6 seconds ago, saying: filter not available
01:31:16 <ivanm> :o that long and still not back up? :o
01:31:30 <quicksilver> Maxdamantus: if it begins further to the right it's a continuation of the last expression, not a case alternative.
01:31:30 <Maxdamantus> Er, swaps all the 8-spaces with tabs*
01:32:15 <Maxdamantus> quicksilver, appears to already be aligned to that
01:32:36 <quicksilver> set expandtab, by the way
01:32:40 <quicksilver> to stop vim being stupid
01:32:48 <Maxdamantus> Thanks.
01:32:56 <quicksilver> Maxdamantus: in the paste you made, the h is aligned with the [
01:33:03 <quicksilver> one character to the right of the '
01:33:36 <Maxdamantus> Oh, didn't notice that O_o
01:33:46 <Maxdamantus> Ahah.
01:35:42 * Maxdamantus wonders if he can, rather than use expandtab, make it so it copies whatever ^[ \t]* was on the previous line.
01:36:48 <quicksilver> best not to
01:36:57 <quicksilver> using tabs in haskell generally leads to madness.
01:37:01 <Maxdamantus> Mmm.. Not for Haskell - I just won't tab there
01:37:07 <Maxdamantus> But I use tabs in C etc
01:43:04 <Maxdamantus> Got it (copyindent)
01:46:04 * hackagebot hs-bibutils 0.2 - Haskell bindings to bibutils, the bibliography  conversion utilities.  http://hackage.haskell.org/package/hs-bibutils-0.2 (AndreaRossato)
01:49:40 <whald> how would i create an unboxed array of a pair of Float?
01:51:30 <Agnostos> quick question: how long should the haskell installer take to assign the target to the path on windows 7?
01:52:06 * hackagebot vcd 0.1.3 - Tools for reading and writing VCD files.  http://hackage.haskell.org/package/vcd-0.1.3 (TomHawkins)
01:52:26 <Botje> Maxdamantus: :set et
01:52:30 <Botje> Maxdamantus: :%retab!
01:52:34 <Botje> then you have all spaces
01:52:57 <quicksilver> whald: you can't directly.
01:53:20 <quicksilver> whald: you can either use a pair of arrays, or just use an array twice as long and handle the index transformations yourself
01:53:20 <Maxdamantus> Yeah, but in most imperative languages I'll use tab, and would prefer to treat them as tab from then on
01:53:44 <Maxdamantus> So far I just use spaces in HTML and haskell afaicto.
01:54:10 <Botje> myeah, well.
01:54:14 <Botje> i'm usually a tabs guy as well
01:54:20 <Botje> buth askell is just a tad too picky :(
01:54:40 <whald> quicksilver: my arrays are rather large, so i think the twice-as-big array and interleaved storage would be preferable in terms of cache efficiency
01:56:00 <whald> but what is the boilerplate i need to express what i want in haskell? :-)
01:56:03 <Agnostos> guess I'll assume it's crashed and attempt a re-install then.
01:59:53 <Entroacceptor> I guess it's known already, but code.haskell.org is down?
02:00:39 <quicksilver> Maxdamantus: I would favour tabs if my editor supported a sane mixed style (a.k.a. "tabs for indentation, spaces for alignment")
02:00:54 <quicksilver> Maxdamantus: but for some reason whilst that idea is obviously sensible, it doesn't have editor support :)
02:01:14 <quicksilver> (it still wouldn't mix well with haskell; requires you to add extra newlines to make sure all layout starts on a clean tab stop)
02:01:30 <quicksilver> (some people are happy with that but I guard my vertical space jealously)
02:04:03 <tibbe> code.haskell.org is down :(
02:18:32 <shay> if we import modules where do we have to put the modules to run a script in GHCI so that they can be found by GHCI
02:18:56 <shay> hope that made some sense
02:20:35 <quicksilver> either in the current directory, or preferably installed properly as a pacakge
02:20:52 <shay> how do you install it as a package?
02:21:15 <deteego> aaaaaaaaa
02:21:17 <shay> i had to download the files in a .tar
02:21:17 <deteego> woops
02:21:22 <deteego> sorry
02:21:39 <deteego> you have to use the :m command in ghci to load modules
02:21:44 <shay> ohhhhh ok
02:22:01 <quicksilver> that's not true
02:22:05 <quicksilver> :m does not load modules.
02:22:08 <shay> :/
02:22:19 <quicksilver> :m brings an already loaded module into scope
02:22:30 <quicksilver> all :m does is affect your current scope.
02:22:41 <shay> Ah I see.... so if it isn't already loaded then ...
02:22:42 <quicksilver> if you downloaded some files as a .tar you should install them properly
02:22:50 <quicksilver> there should surely be a readme
02:22:55 <shay> hmm ok
02:22:58 <quicksilver> but normally it's runhaskell Setup.hs configure
02:23:03 <quicksilver> runhaskell Setup.hs build
02:23:07 <quicksilver> sudo runhaskell Setup.hs install
02:23:33 <quicksilver> or just cabal configure; cabal build; sudo cabal install
02:23:38 <quicksilver> if you have cabal-install installed.
02:24:26 <Entroacceptor> is there a drawback to just saying 'cabal install'? It configures and builds, too
02:25:15 <wto> @pl \(a,b) -> hasMine a b
02:25:24 <wto> oh, no lambdabot :(
02:25:56 <ivanm> and no lunabot, assuming I could work out how to use it...
02:25:58 <shay> there is a Setup.hs file... so what do I need to do with that? Just run in it GHCI?
02:26:12 <shay> there was no readme file
02:26:21 <ivanm> shay: runhaskell Setup.hs configure
02:26:29 <ivanm> runhaskell Setup.hs build
02:26:35 <ivanm> runhaskell Setup.hs install
02:26:44 <ivanm> ^^ cabal-install basically just does those three steps for you
02:27:12 <shay> it says dependencies missing
02:27:25 <shay> GLUT and OpenGL
02:27:32 <ivanm> then install them
02:27:35 <shay> ok
02:27:39 <ivanm> cabal-install also automates that for you
02:27:47 <ivanm> shay: any particular reason you aren't using cabal-install?
02:27:58 <shay> i dont know what that is :|
02:28:26 <shay> ivan im from COMP110 and am trying to get the Gloss package on my computer
02:28:28 <dancor> is it possible to use openal without the destroy warnings
02:28:29 <ivanm> oh, I thought quicksilver told you what it was...
02:28:34 <ivanm> shay: ahhhhhh
02:28:39 <dancor> OpenAL+ALUT
02:28:41 <ivanm> shay: which OS/distro are you using?
02:28:56 <shay> What is tha
02:28:58 <shay> that*
02:29:13 <ivanm> which operating system are you using?
02:29:15 <ivanm> windows?
02:29:19 <shay> Vista
02:29:26 <shay> yeah
02:29:43 <ivanm> shay: you installed the haskell platform, dind't you?
02:29:49 <ivanm> if so, it has cabal install
02:29:54 <shay> I installed GHCI and Notepad ++
02:30:02 <shay> which I'm guessing is part of one of them
02:30:28 <ivanm> shay: from the COMP1100 website?
02:30:32 <shay> yes
02:30:35 <ivanm> OK
02:30:47 <ivanm> open up a command prompt and do this:
02:30:51 <ivanm> cabal update
02:30:57 <ivanm> cabal install gloss
02:31:04 <ivanm> ^^ those two commands should do it
02:32:30 <shay> and that will allow me to run scripts that require the Graphics.Gloss module?
02:33:58 <ivanm> should do, yes
02:34:00 <shay> It came up with failed during final install step - permission denied....
02:34:48 <ivanm> shay: paste the entire build process up here:
02:34:50 <ivanm> @where hpaste
02:35:00 <Entroacceptor> I ate lambdabot
02:35:08 <systemfault> O RLY?
02:35:44 <shay> its huge
02:36:09 <shay> ill retry it
02:37:10 * ivanm force Entroacceptor to spew lambdabot up
02:37:32 <Entroacceptor> whuaaaaaaaargggggggggg
02:37:50 <shay> so the update will get the GLUT and OpenGL dependencies?
02:37:54 <ivanm> shay: yes
02:38:35 <shay> ok well when I tried to update it it came up with permission denied for creating a directory
02:38:52 <ivanm> which directory?
02:39:03 <shay> Microsoft Windows [Version 6.0.6001]
02:39:03 <shay> Copyright (c) 2006 Microsoft Corporation.  All rights reserved.
02:39:03 <shay> C:\Users\Mark>cabal update
02:39:03 <shay> Downloading the latest package list from hackage.haskell.org
02:39:03 <shay> Note: there is a new version of cabal-install available.
02:39:03 <shay> To upgrade, run: cabal install cabal-install
02:39:07 <ivanm> anyone else here use cabal-install on windows?
02:39:34 <shay> whoops :/
02:39:48 <shay> did you read that
02:39:52 <shay> at the end
02:40:15 <ivanm> yes
02:40:19 <ivanm> you can ignore that for now
02:41:10 <shay> ok well im trying to install gloss again
02:41:44 <ivanm> preflex: seen Axman6
02:41:44 <preflex>  Axman6 was last seen on #haskell 5 hours, 5 minutes and 37 seconds ago, saying: it's like from the docs...
02:42:33 <shay> ok the end part failed again like last time
02:42:43 <shay> while trying to compile Data.Tensor
02:43:01 <shay> same issue with unable to create directories
02:43:50 <Entroacceptor> do you have admin rights?
02:44:23 <shay> Well I only have one account on this computer but I always get stupid messages asking for permission even though I'm on the admin logon
02:45:22 <shay> I do have admin rights but I have to always press 'Allow' none the less
02:45:49 <Entroacceptor> maybe you can try running the terminal as admin (aditionally?)
02:45:54 <shay> I just turned off User Account Control
02:45:54 <Entroacceptor> with super user rights
02:46:09 <ivanm> UAC doesn't apply in this case
02:46:12 <shay> i will try restarting... might make a difference
02:46:17 <Maxdamantus> What's a usual way of converting between char and an integral?
02:46:17 <ivanm> but I thought cabal-install defaulted to user installs...
02:46:17 <shay> well i didnt think it would
02:46:23 <ivanm> shay: try cabal install gloss --user
02:46:25 <Maxdamantus> ['\0'..] !! c seems odd.
02:46:30 <Entroacceptor> shay: in the context menu I got a 'run as administrator' switch
02:46:36 <Maxdamantus> And the other way will be odder.
02:46:39 <Entroacceptor> even though I'm admin on this computer
02:46:43 <ivanm> Maxdamantus: convert to Int first
02:46:47 <ivanm> @hoogle Char -> Int
02:46:51 <Entroacceptor> (win7, though)
02:46:57 <shay> oh
02:47:00 <ivanm> Entroacceptor: don't think that makes a difference...
02:47:07 <Entroacceptor> ivanm: why not?
02:47:15 <ivanm> vista vs win7
02:47:19 <Entroacceptor> ah, that
02:47:22 <Entroacceptor> I don't know either
02:48:07 <Maxdamantus> Hm. Char.ord
02:48:37 <ivanm> oh, right lambdabot isn't here so @hoogle didn't work
02:48:51 <ivanm> Maxdamantus: Data.Char.org or else just use fromEnum
02:49:47 <Maxdamantus> Ah.
02:51:33 <shay> ivanm: it seemed to have worked that time round, what does the --user do?
02:51:51 <ivanm> installs stuff in the users home directory
02:53:01 <qebab> this is so totally the wrong channel for this but I'm doing my head in trying to figure this out... given I have some integer n, I want to find all x such that x * n `rem` (x - n) = 0, x > n and I have no idea how I can work out that x is now "too large" or how many values for x there should be :(
02:53:16 <qebab> would really appreciate it if anyone could hint me towards something
02:53:19 <ivanm> I thought cabal-install defaulted to that...
02:53:33 <dmhouse> qebab: there is a #math, you might find more bites in there
02:53:36 <ivanm> do you mean mod? or rem?
02:53:56 <qebab> ivanm: what is the semantic difference?
02:54:00 <qebab> dmhouse: thanks, I'll check that out :)
02:54:24 <ivanm> qebab: different for negative values
02:54:29 <qebab> wait, that's in how they treat negatives ?
02:54:30 <ivanm> > -5 `mod` 3
02:54:33 <qebab> ah right
02:54:34 <ivanm> > (-5) `mod` 3
02:54:37 <ivanm> oh, right, no bot
02:54:40 <Entroacceptor> lol
02:54:46 <qebab> n is always positive and x > n so it shouldn't matter in this case
02:54:46 <Entroacceptor> poor ivanm
02:56:26 <shay> I am trying to run the fractal exercise and its coming up with can't load .so/.DLL for: glut32 (addDLL: could not load DLL)
02:56:38 <ivanm> shay: try compiling it
02:56:51 <shay> my fractal script?
02:56:55 <ivanm> yeah
02:57:04 <ivanm> some of those kinds of libraries that link to those C DLLs don't work too well in ghci
02:57:17 <shay> oh ok
02:57:27 <shay> what was the command for compiling
02:57:39 <ivanm> ghc --make
02:59:43 <shay> Unknown GLUT error when I try and run it
02:59:48 <Maxdamantus> Hum. Can't use fromEnum on getChar apparently :(
03:00:02 <ivanm> shay: sorry, I don't use windows so I"m not sure how to sort this out :s
03:00:21 <shay> thats ok
03:00:25 <shay> ill just ask clem
03:00:30 <shay> thanks for your help anyhow
03:01:00 <quicksilver> probably your version of glut is fail
03:01:14 <quicksilver> but I can't help much, not having used windows
03:02:20 <shay> what exactly is GLUT
03:02:32 <pastorn> shay: an easy way to create a window etc.
03:02:37 <shay> oh ok
03:02:40 <pastorn> shay: to draw your openGL stuff in
03:02:41 <quicksilver> maybe you just don't have glut32.dll at all.
03:02:57 <shay> where could i get it from
03:02:59 <shay> ?
03:03:03 <pastorn> shay: but you won't want it for making games... keyboard support "works" but ain't that grand
03:03:14 <pastorn> shay: google "freeglut"
03:03:18 <shay> ok
03:05:09 <quicksilver> perhaps the haskell platform includes glut32.dll?
03:05:15 <quicksilver> in the old days, GHC came with the dll
03:05:47 <shay> um how do i install freeglut... i am assuming the instructions are for linux
03:05:48 * ivanm was about to suggest shay use locate or find to see if he has it, then remembers that it's the wrong OS...
03:06:00 <pastorn> shay: no, they're not
03:06:06 <pastorn> or maybe that was normal glut
03:07:43 <shay> well it says to type in ./autogen, ./conigure and make
03:07:54 <shay> but the files are unknown type
03:08:07 <shay> configure*
03:08:34 <pastorn> shay: that's *nix stuff
03:09:11 <pastorn> shay: http://www.cs.rpi.edu/~girdhy/komputer_grafix/installing_glut.html
03:09:17 <pastorn> can't be *THAT* hard :p
03:10:59 <dancor> oh duh deleteObjectNames
03:11:31 <pastorn> dancor: wut?
03:11:40 <pastorn> why is everyone doing 3D all of the sudden...?
03:11:44 <dancor> answer to my earlier question
03:12:00 <dancor> i'm just using OpenAL bc Haskore is so terrible
03:12:17 <dancor> i just need to generate tones
03:12:25 * zygoloid looks sadly at the GSoC projects. still no haskell debugger. :(
03:12:53 <kamatsu> zygoloid: ghci?
03:13:54 <ivanm> pastorn: in what?
03:14:20 <zygoloid> kamatsu: ghci can't attach to a running process. it can't debug compiled code. and the functionality it provides is very lacking compared to, say, gdb
03:14:52 <shay> pastorn: I put the glut.dll file in the Windows system folder but I dont have the folders for Microsoft Visual Studio
03:14:59 <shay> is this necessary
03:15:00 <dancor> ghci also doesn't do partial compilation
03:15:03 <dancor> which is annoying
03:15:08 <pastorn> shay: dude, i dunno
03:15:11 <pastorn> i use *nix
03:15:13 <shay> lol
03:15:17 <shay> :|
03:15:17 <pastorn> 'cause i'm cool like that
03:15:46 <pastorn> shay: suxx 2 b u :p
03:16:13 <shay> pastorn: it works now
03:16:13 <shay> pastorn: :D
03:16:48 <shay> tyvm everyone for your help
03:16:48 <shay> i know i have been a pain xD
03:18:19 <TheColonial> hi guys. can someone please give me a hint on how to read N lines of input from stin? Yup, I'm a real noob :)
03:18:25 <ivanm> shay: what did you have to do? just install freeglut?
03:18:31 <ivanm> if so, I'll tell Clem that tomorrow
03:18:36 <ivanm> hey TheColonial
03:18:42 <TheColonial> ivanm! how goes it mate?
03:18:44 <ivanm> TheColonial: replicateM readLine
03:18:46 <TheColonial> long time no see :)
03:18:59 <ivanm> yeah, not bad; how's the newborn going?
03:19:00 <TheColonial> ivanm, thanks dude.
03:19:16 <ivanm> you able to come to AusHack in July?
03:19:20 <TheColonial> ivanm, he's fine mate thanks :) he's huge now! they grow up quick
03:19:35 <quicksilver> TheColonial: replicateM n getLine
03:19:41 <TheColonial> i really wish i could, but it's not going to happen :( though I have booked in for next year's with the wife, so i hope to be there for that one!
03:19:48 <ivanm> duh, yeah, getLine not readLine
03:19:52 <ivanm> and I forgot the n :s
03:19:56 <TheColonial> lol
03:20:01 <ivanm> TheColonial: fair enough
03:20:02 <TheColonial> thanks quicksilver and ivanm, much appreciated
03:20:05 <quicksilver> that's why I'm here, ivanm ;)
03:20:07 <TheColonial> ivanm, how are things down south?
03:20:11 <zygoloid> kamatsu: i think my favourite ghci feature, though, is when i :trace some expression, then type :history, and it says "Perhaps you forgot to use :trace?"
03:20:13 <ivanm> TheColonial: cold :s
03:20:18 <ivanm> quicksilver: to fix my mistakes? :p
03:20:33 <TheColonial> ivanm, ha! welcome to canberra ;)
03:20:48 <TheColonial> is replicateM in Control.Monad?
03:20:56 <ivanm> I think so
03:20:56 <quicksilver> yes.
03:20:59 <TheColonial> thanks :)
03:22:10 <dancor> zygolol
03:22:10 * quicksilver was tempted to lmgtfy but is in a good mood :)
03:22:35 <ivanm> quicksilver: lmhtfy (let me hoogle that for you)? :p
03:22:48 <dancor> @hoogle replicateM
03:23:08 <dancor> @bot
03:23:19 <TheColonial> man I'm such a Haskell noob.. i hate it!
03:23:20 <TheColonial> :)
03:23:55 <ivanm> dancor: Entroacceptor ate her :@
03:24:27 <dancor> i see
03:26:18 <ivanm> every now and then, I want to call this channel #haskell-cafe ... >_>
03:27:07 <quicksilver> Cale: ALARM! ALERT! FIRE! FOES! LAMBDABOT DOWN!
03:27:19 <ivanm> preflex: seen Cale
03:27:19 <preflex>  Cale was last seen on #haskell 7 hours, 39 minutes and 19 seconds ago, saying: One of De Morgan's laws works, the other doesn't, as I recall.
03:27:20 <Cale> tsk
03:27:47 <quicksilver> :)
03:28:23 <Cale> I wish that lambdabot would notice that it had been disconnected. It clearly thinks that it is still connected to the network.
03:28:27 <ivanm> Cale: did you have any comments on my proposed changes to FGL on -cafe?
03:28:38 <ivanm> @bot
03:28:43 <lambdabot> :)
03:28:48 <ivanm> \o/
03:28:55 <Cale> ivanm: I haven't been keeping up with -cafe for the last couple of years
03:28:58 <quicksilver> Cale: is it ignoring SIGPIPE instead of handling it?
03:29:01 <Maxdamantus> Hmm.. I'm looking at: http://www.haskell.org/tutorial/io.html and they appear to be comparing a Char with an IO Char or something.. This doesn't seem to work for me.
03:29:02 <ivanm> Cale: :o
03:29:07 <Maxdamantus> 'a' == getChar
03:29:15 <Cale> I have 9166 unread threads in -cafe in my mailbox
03:29:27 <Cale> quicksilver: no idea
03:30:02 <Cale> Maxdamantus: Where?
03:30:20 <quicksilver> Maxdamantus: I don't believe you will find "== getChar" anywhere in that document.
03:30:26 <quicksilver> (I did just do a quick search)
03:30:26 <Maxdamantus> do c <- getChar; if c == '\n' ...
03:30:32 <ivanm> Cale: http://article.gmane.org/gmane.comp.lang.haskell.cafe/73868
03:30:37 <quicksilver> yes, but that's totally different Maxdamantus
03:30:43 <quicksilver> in fact, it's the whole point :)
03:30:43 <Maxdamantus> Oh.
03:30:47 <quicksilver> <- is how you run actions
03:30:48 <Saizan> i've found that the only reliable way to make a bot aware of disconnections is to make it ping itself if it doesn't see any traffic
03:30:50 <Maxdamantus> Hm.
03:30:50 <Cale> Maxdamantus: That binds c to the *result* of executing getChar, and then compares that result with '\n'
03:31:02 <ivanm> quicksilver: well, extract values from actions...
03:31:02 <quicksilver> if getChar :: IO Char, and c <- getChar, then c :: Char
03:31:28 <Maxdamantus> Is it to do with the fact that Haskell's purely functional otherwise and might not call getChar or something?
03:31:39 <quicksilver> there is no otherwise.
03:31:44 <quicksilver> haskell is purely functional.
03:31:45 <Cale> Maxdamantus: It has to do with the fact that getChar is not the same thing as the result of getChar
03:31:46 <ivanm> Maxdamantus: not really
03:32:03 <ivanm> Maxdamantus: it's because Haskell is strongly statically typed
03:32:04 <Cale> Maxdamantus: We want the ability to treat getChar as a proper thing in itself -- pass it to functions and so on
03:33:00 <Cale> Maxdamantus: If it automatically executed whenever it was the parameter to another function, not only would it be confusing because of Haskell's undefined evaluation order, it would also prevent us from passing the action itself as the parameter.
03:34:11 <Maxdamantus> Oh, I see.
03:34:15 <Maxdamantus> So <- is an IO thing.
03:34:19 <Maxdamantus> >_<
03:34:27 <ivanm> a monadic thing
03:34:31 <Maxdamantus> Yeah, that.
03:34:48 <ivanm> it's part of the do-block syntax
03:34:54 <ivanm> which desugars down to >>= and >>
03:35:07 <ivanm> (where >> itself is based on >>=)
03:35:19 <ivanm> Cale: http://article.gmane.org/gmane.comp.lang.haskell.cafe/73868
03:35:43 * Maxdamantus has been doing random stuff instead of reading this tutorias.
03:35:52 <Cale> Maxdamantus: Yeah, it's a monadic thing like ivanm says, but you don't have to care about that for now
03:36:30 <ivanm> Axman6 has a good non-monadic (as in you don't have to know/care about monads) IO tutorial...
03:36:32 <Cale> Maxdamantus: the important thing is that using do-notation, you can glue together simpler IO actions into more complex ones.
03:37:25 <Cale> Maxdamantus: v <- x means "run x and name its result v", an IO action on its own on a line means to run that IO action (ignoring the result), and the result of the overall action (the whole do-block) is the result of the last action in it
03:37:31 <ivanm> Cale: short version: martin is giving up FGL, Louis Wasserman and I are taking over
03:37:38 <Cale> ivanm: okay
03:37:47 <Maxdamantus> I see.
03:37:59 <ivanm> I plan on merging some of the stuff that you and I were talking about for the generic graph class into FGL, use ATs for the Node type, etc.
03:38:02 <zygoloid> is there a better name for a commutative monoid?
03:38:07 <ivanm> but some people believe that we shouldn't change the FGL API :s
03:38:17 <Cale> zygoloid: that's the one everyone uses
03:38:18 <ivanm> zygoloid: better than... ?
03:38:31 <zygoloid> ivanm: better than "commutative monoid" :)
03:38:40 <ivanm> ahhhh
03:38:42 <pookleblinky> Ah, damn. I just did a pacman -Syu and broke xmonad.
03:38:44 <dibblego> aka abelian monoid
03:39:08 <pookleblinky> Arch is a bit sadistic about haskell
03:39:27 <Cale> ivanm: How many users does FGL have? It may be worthwhile to those people to maintain a compatible version of FGL, and fork the future.
03:40:03 <Cale> ivanm: I know that there's someone from #haskell (forget who) that wrote a faster backend in terms of Vector, I think.
03:40:26 <pielgrzym> hi :) what does a dot do? in xmonad I have defultPP with a bunch of stuff like this:  ppCurrent :: WorkspaceId -> String - it should basically take some WorkspaceId and return a String. Instead it can take a string separated by dot then wsId. what does this magicall dot do?
03:40:46 <Cale> But I personally dislike FGL's interface and it's most of the reason that I basically never use it.
03:40:56 <dibblego> pielgrzym, it composes two functions together to return a new function
03:41:53 <Cale> pielgrzym: If f :: A -> B, and g :: B -> C, then g . f :: A -> C, and (g . f) x = g (f x)
03:42:24 <Cale> pielgrzym: At least, if this is the same (.) that we're talking about
03:42:43 <pielgrzym> dibblego: ok, so if I want a dzenColor function that is defined here: http://xmonad.org/xmonad-docs/xmonad-contrib/src/XMonad-Hooks-DynamicLog.html#dzenColor I use: ppCurrent = dzenColor col1 col2 . \wsId -> dropIx wsId but how can I append dzenColor an extra string?
03:42:55 <pookleblinky> This is rather annoying. I tried reinstalling xmonad and such through AUR, but no luck.
03:42:57 <pielgrzym> Cale: like in math functions?
03:43:02 <Cale> pielgrzym: exactly
03:43:23 <pielgrzym> Cale: woow :) some really serious logic has to be undertaken in background :|
03:43:38 <pielgrzym> I'm beggining to love this language :D
03:44:07 <ivanm> Cale: well, someone did suggest we call it FGL'
03:44:12 <pielgrzym> plus I don't get why there is "\" in the beggining of wsId :)
03:44:19 <Cale> pielgrzym: (.) is just a simple function which is defined in the prelude, but of course, one of our favourites
03:44:20 <ivanm> but I think that will lead to the mtl problem
03:44:54 <Cale> \ is ascii art for greek lambda (λ) and introduces a function
03:45:05 <Cale> The syntax is \ <parameters>  ->  <result>
03:45:14 <pielgrzym> aaaaah. a lambda function :]
03:45:36 <pielgrzym> I bet they are totally different then python lambdas :)
03:45:52 <Cale> pielgrzym: Not *so* different, but possibly less broken
03:45:57 <pielgrzym> hehe :)
03:45:57 <ivanm> yes: Haskell's can be more than one line!
03:46:03 * Maxdamantus needs to figure out how to use putChar now. :(
03:46:03 <ivanm> but we don't use them that often
03:46:18 <ivanm> partially applied functions typically get used more
03:46:22 <ivanm> @hoogle putChar
03:46:22 <lambdabot> Prelude putChar :: Char -> IO ()
03:46:22 <lambdabot> System.IO putChar :: Char -> IO ()
03:46:22 <lambdabot> System.IO hPutChar :: Handle -> Char -> IO ()
03:46:27 <ivanm> Maxdamantus: putChar 'c'
03:46:32 <ivanm> will print that character to stdout
03:46:41 <Maxdamantus> Mmm.. But in a do or something.
03:46:47 <Maxdamantus> do putChar 'a'; 42
03:46:56 <Cale> Maxdamantus: The 42 is the problem with that
03:47:16 <Cale> Maxdamantus: Each line of an IO do-block should consist of an IO action.
03:47:21 <Maxdamantus> Ah.
03:47:34 <quicksilver> "do putChar 'a'; return 42" would have been OK
03:47:41 <Cale> Maxdamantus: So if you want to return 42 as the result of the IO action, you use the return function
03:47:44 <Maxdamantus> So I want some sort of sequence operator somehow
03:47:55 <Cale> Which takes a value, and produces the action which does nothing but to return that value
03:48:08 <Cale> Oh, did you want to print 42?
03:48:17 <pielgrzym> ok, so what we've got here: , ppUrgent = dzenColor myUrgentFGColor myUrgentBGColor . \wsId -> dropIx wsId      actually is a dzenColor function in conjunction with the tiny lambda that takes a workspace id and returns another function (oh, my) that takes wsId and does something with it, right? so to pass it a dzenColor ++ "^i(myniceicon.xbm)" I will need to create a function that 'eats' dzenColor and does the magic inside?
03:48:25 <Cale> (print 42  will indeed work)
03:48:32 <Maxdamantus> Ah, return does it.
03:48:41 <Maxdamantus> (return is what I want there)
03:49:33 <Cale> pielgrzym: actually, that's equivalent to  ppUrgent = dzenColor myUrgentFGColor myUrgentBGColor . dropIx
03:49:39 <Cale> If it's any help :)
03:49:44 <pielgrzym> this obviously won't worki since we can't concatenate stuff? ppCurrent = dzenColor myUrgentFGColor myFocusedBGColor ++ wrap "^i(" ++ myIconDir ++ "/full.xbm)" . \wsId -> dropIx wsId
03:50:11 <pielgrzym> Cale: dropIx - gotta check what it actually is :)
03:50:21 <Maxdamantus> *Main> bfint (bf2op "++++++++++[>+++++++>++++++++++>+++++++++++>+++>++++++++++++<<<<<-]>++.>+.>--..+++.>++.>-.<<.+++.------.<-.>>+.")
03:50:24 <Maxdamantus> "Hello world"
03:50:27 <Maxdamantus> \o/
03:50:30 <quicksilver> :)
03:50:32 <Maxdamantus> IO seems tricky so meh.. Return a string.
03:50:39 <quicksilver> definitely
03:50:44 <quicksilver> no need for IO in an interpreter
03:50:47 <Maxdamantus> But then it'll be awkward to do stuff without the interpreter.
03:50:49 <Cale> Maxdamantus: Maybe also read: http://www.haskell.org/haskellwiki/Introduction_to_IO
03:51:35 <lhames> Any thoughts on the best haskell matrix library if I just need really basic linear algebra functionality? (I just need to be able to add, subtract, multiply and invert matrices)
03:53:02 <lhames> I see a few names on haskellwiki, but I don't know which to go for, or whether one is considered a defacto standard these days?
03:55:50 <Cale> lhames: Maybe hmatrix?
03:56:04 <Cale> What kind of linear algebra?
03:56:12 <fasta> lhames, and which license?
03:56:20 <fasta> lhames, and which purpose?
03:56:50 * fasta notes that one package to rule them all would be nice.
03:56:50 <Cale> If it's floating point approximate linear algebra, then hmatrix gives a decent interface to stuff from GSL, BLAS, and LAPACK
03:56:54 <lhames> Linear algebra: Dead easy. Like I said - I need to add, subtract, multiply and invert matrices. I want to try to knock up a basic raytracer.
03:57:01 <lhames> Doesn't matter if it's fast.
03:57:08 <fasta> lhames, I like the Vec library.
03:57:14 <Cale> If you needed something like rational linear algebra, I wouldn't know what to tell you :)
03:57:16 <fasta> lhames, which also does matrices.
03:57:18 <lhames> License: Anything I don't have to pay for, free is better. :)
03:57:38 <Cale> Or linear algebra over a finite field, again, I'm not sure we have a good story there
03:57:55 <lhames> Ahh ok. No - linear algebra over floats will be just fine. :)
04:00:23 <lhames> Sounds like Vec and hMatrix are the ones to look into.
04:00:38 * Maxdamantus has a better idea -_- make the bfint function take an arg for input.
04:01:20 <lhames> Neither ship as ubuntu packages. I might finally have to get off my ass and install something more up-to-date.
04:03:38 * alpounet dreams of a generic and comprehensive mathematical framework for haskell
04:03:52 <eevar2> lhames: don't have cabal?
04:04:47 * hackagebot vcd 0.1.4 - Tools for reading and writing VCD files.  http://hackage.haskell.org/package/vcd-0.1.4 (TomHawkins)
04:04:55 <lhames> eevar2: Not yet. I've been very lazy. I've just been pulling down ubuntu packages for the libs I want.
04:05:28 <lhames> eevar2: Also still on GHC 6.10.4.
04:06:47 <lhames> I feel the appropriate level of shame (I think), but I've been really busy, and I'm still kinda new to Haskell.
04:06:53 <eevar2> okies. just running ghc from debian testing here (on debian)
04:08:07 <lhames> Yep. New ubuntu release in two or three days. Hopefully that'll have a more up
04:08:14 <lhames> *up-to-date version.
04:08:19 <fasta> lhames, there is no problem running older versions of GHC when there are good reasons (like lazy maintainers of packages on which you depend).
04:08:31 <alpounet> we'll have the new platform release soon anyway
04:08:50 <fasta> This whole concept of "releases" is kind of silly imho, especially when the releases always suck ;)
04:08:50 <lhames> new platform release?
04:08:55 <fasta> (see Ubuntu)
04:09:08 <lhames> Ahh. You mean 10.4?
04:09:12 <lhames> Can't wait for that.
04:09:24 <fasta> For example, their ntfs-3g drivers are very old.
04:09:36 <alpounet> http://hackage.haskell.org/platform/
04:09:39 <lhames> Still - I can compile from source, so I should give that a try. One day I'd like to actually hack on GHC itself a bit.
04:12:04 <lhames> alpounet: Sounds interesting. Setting up a copy now.
04:13:41 <ManateeLazyCat> dcoutts: Are you seen Axel recently?
04:13:45 <alpounet> it comes with the (almost) latest GHC
04:13:54 <alpounet> cabal
04:13:58 <alpounet> key libraries
04:14:00 <alpounet> etc
04:14:38 <dcoutts_> ManateeLazyCat: I've not been checking email that carefully
04:15:16 <ManateeLazyCat> dcoutts_: I have so much local repositories: gtk2hs darcs, gtk2hs cabal, gtk2hs 2.18.3, gtk2hs 2.20, gio 2.24.0
04:15:40 <ManateeLazyCat> dcoutts_: And Axel like *small* patches, so i need a repository to record.
04:15:59 <pookleblinky> Ok, I'm rebuilding haskell-x11 and xmonad etc from ABS
04:16:01 <dcoutts_> ManateeLazyCat: aye, I get the sense that you've been flooding Axel with patches :-)
04:16:02 <ManateeLazyCat> dcoutts_: But current main repository still need adjust, i can't record in that repository.
04:16:04 <pookleblinky> Hopefully that works.
04:16:10 <dcoutts_> ManateeLazyCat: he's got limited review bandwidth
04:16:51 <fasta> dcoutts_, it seems that Hackage is becoming a bottleneck for cooperation. It might be more useful to figure out a policy to solve the "lag that package maintainers have".
04:17:22 <ManateeLazyCat> dcoutts_: I want push patche directly, but i'm afraid some functions has bug, so i want Axel review my patches before push to avoid break user's code.
04:17:28 <dcoutts_> fasta: you mean for the case of "I've got this vital bugfix but the maintainer has not applied it yet!!!"
04:17:30 <alpounet> fasta, don't hesitate to write down some advices / ideas for that hackage 2.0 project :)
04:17:52 <fasta> dcoutts_, yes. There are lots of people asking about that.
04:17:53 <dcoutts_> ManateeLazyCat: yes, it should all go through review
04:18:47 <ManateeLazyCat> dcoutts_: Maybe you can review my code? I think answer is : "Sorry, i haven't spare time, too busy."
04:18:54 <ManateeLazyCat> :)
04:19:05 <dcoutts_> fasta: well one option is for people to post tarballs in their own webspace and for us to extend cabal so you can cabal install http://code.haskell.org/~user/foo-1.1-with-critical-patch.tar.gz
04:19:16 <dcoutts_> ManateeLazyCat: hey, even I send my patches for Axel to review :-)
04:19:45 <dcoutts_> fasta: do you have any other suggestions?
04:19:59 <fasta> dcoutts_, that could work, but I think that having everything centralized has some advantages, but also a lot of disadvantages.
04:20:09 <ManateeLazyCat> dcoutts_: I did bad thing for Gtk+ 2.18.3, some functions is buggy, so i won't push any patches directly now.
04:20:27 <fasta> dcoutts_, one thing is that as Haskell grows, it will need more infrastructure support and thus actual organizations and there is no technical need for those.
04:20:37 <dcoutts_> fasta: it's might be ok to list such forks from the main hackage page, but it's not ok to go around overriding decisions of maintainers
04:21:31 <dcoutts_> fasta: there's nothing stopping people from doing things in a decenteralised way, it just makes a lot of sense for actual releases to have a central distribution point
04:21:35 <ManateeLazyCat> dcoutts_: I'm now binding GIO, because Axel want GnomeVFS departed, and gio binding is un-complete, so haven't same functions to replace GnomeVFS.
04:22:01 <dcoutts_> fasta: for intermediate dev releases that people need to share, other solutions are probably preferable
04:22:42 <ManateeLazyCat> dcoutts_: Maybe Axel is too busy like you, perhaps he will reply my mail at this weekend.
04:22:43 <fasta> dcoutts_, I think the searchpath solution by the same guy who funded HAppstack was a nice solution.
04:23:11 <fasta> dcoutts_, it did one thing, and it did that right.
04:23:14 <dcoutts_> ManateeLazyCat: the key thing is to make sure you've got patches that cleanly apply to the main repo
04:24:19 <fasta> dcoutts_, anyway, maybe I should just shut up, since I have no time to develop a decent system myself ;)
04:24:23 <dcoutts_> fasta: so one thing I'd like to do is to make tools to make it easier to manage a package archive
04:25:00 <dcoutts_> fasta: so that people could do things like project-specific archives, eg containing daily snapshots or betas or whatever
04:25:00 <fasta> dcoutts_, yes, I would like to be able to convert an archive.tar file into something from which you can cabal install stuff.
04:25:02 <ManateeLazyCat> dcoutts_: Yes, i will, and keep every patches is clean and small.
04:25:24 <fasta> dcoutts_, currently there is some check for some index file, which is not included in the archive.
04:25:43 <fasta> dcoutts_, but I suppose you are already aware of that issue.
04:25:44 <dcoutts_> fasta: indeed in principle a package index could refer to tarballs from many different servers, rather like the searchpath concept
04:26:12 <fasta> dcoutts_, I suppose that would be a nice incremental step.
04:27:41 <ManateeLazyCat> dcoutts_: I think Axel is hate me, why that guy send some many patches and take up my weekend.
04:30:21 <dcoutts_> ManateeLazyCat: no, he does appreciate that you're making big improvements. He just struggles under the workload :-)
04:30:31 <dcoutts_> ManateeLazyCat: you just need to be patient
04:32:05 <dayz> hi
04:33:28 <Raynes> mun: day toosday windsay therrsday fryday saterday soonday
04:33:29 <Raynes> :p
04:33:59 <pookleblinky> Gah. I'm now somewhat annoyed. Even building haskell-x11 through ABS didn't work.
04:34:16 <pookleblinky> This happens on every update of ghc, for me.
04:34:33 <mun> given \forall x,y. f(x) = f(y) <=> \forall x,y. f(x) = g(y) /\ X, is there any way to find what X could be? e.g., X could be \forall x. f(x) = g(x)
04:35:14 <mun> this is like unification, right?
04:36:02 <ManateeLazyCat> dcoutts_: BTW, we need so much time to review code even code generate by ApiGen, we hope gtk2hs don't need middle code someday (at least for simple function) .
04:37:00 <siracusa> dcoutts_: Are new demos appreciated, too?
04:38:04 <ManateeLazyCat> siracusa: New demo for gtk2hs?
04:38:13 <siracusa> Yes
04:38:45 <ManateeLazyCat> siracusa: Yes!
04:39:04 <ManateeLazyCat> siracusa: Any contribution are welcome.
04:39:47 <ManateeLazyCat> siracusa: Demo for what?
04:40:00 <ManateeLazyCat> siracusa: I mean which part of gtk2hs?
04:40:31 <siracusa> ManateeLazyCat: My idea was a demo program for how to handle several events
04:40:51 <dcoutts_> siracusa: yes, always appreciate demos, they're also easier to get in since they don't touch the rest of the codebase.
04:41:39 <ManateeLazyCat> siracusa: Can you paste your code? Maybe i can help you push it.
04:43:00 <siracusa> ManateeLazyCat: Well, atm there actually is no code to push :-)
04:43:38 <siracusa> ManateeLazyCat: I'm just playing around with Gtk2Hs a bit and I find some things are not that easy to handle
04:43:41 <ManateeLazyCat> siracusa: If you demo is useful and simple, i can push it to "gtk2hs/demo "
04:43:54 <ManateeLazyCat> siracusa: Detail?
04:44:02 <ManateeLazyCat> siracusa: Maybe i can help you. :)
04:44:41 <siracusa> ManateeLazyCat: e.g. how to handle a double-click on arbitrary widgets?
04:46:43 <ManateeLazyCat> siracusa: `LeftButton` in EventM ?
04:47:24 <siracusa> ManateeLazyCat: On which signal?
04:48:23 <ManateeLazyCat> siracusa: widget `on` eventButton $ tryEvent $ do ....
04:48:46 <simona_> siracusa: w `on` buttonPressEvent $ tryEvent $ do { DoubleClick <- eventClick; putStrLn "Double Click" }
04:49:28 <simona_> siracusa: If the pattern match fails with an exception, the 'tryEvent' will simply return 'False' indicating that the event has not been dealt with. Other handlers will then be invoked.
04:49:46 <dcoutts_> fasta: feel free to comment on: http://hackage.haskell.org/trac/hackage/ticket/667
04:50:30 <siracusa> simona_: But eventClick is deprecated, isn't it?
04:51:11 <ManateeLazyCat> simona_: buttonPressEvent ?
04:51:32 <ManateeLazyCat> siracusa: Graphics.UI.Gtk.Gdk.Events is deprecated.
04:51:44 <simona_> siarcusa: No, everything in Gdk.EventM is good, everything in Gdk.Event is deprecated.
04:51:59 <fasta> dcoutts_, well, I pretty much agree with that write-up as a step in the right direction.
04:52:11 * ManateeLazyCat Dinner time, brb.
04:52:12 <simona_> siracusa: yes, sorry Events not Event
04:52:32 <dcoutts_> fasta: ok, thanks
04:52:35 <ManateeLazyCat> siracusa: Leave message to me, dinner. :)
04:53:25 <siracusa> simona_: Maybe we use different versions, in EventM there is no eventClick
04:53:57 <simona_> Oh, yes. That was an oversight. But I think it is in the latest release of Gtk2Hs.
04:55:11 <fasta> dcoutts_, as for the end-goal: a single command which allows one to fork Hackage completely from scratch on a random machine (Linux/Windows does not matter).
04:55:55 <dcoutts_> fasta: you mean like a writable proxy?
04:57:07 <fasta> dcoutts_, I mean that after that command and possibly changing some server field setting in the configuration file, this new server is for all purposes equal to the "official" one.
04:57:35 <dcoutts_> fasta: oh, running a private hackage-server instance, that should be easy
04:57:39 <dcoutts_> with the new server impl
04:58:15 <fasta> dcoutts_, then there can be inter-server protocols to share packages, I suppose.
04:58:32 <dcoutts_> yep, http :-)
04:58:58 <fasta> dcoutts_, ah, right ;)
04:59:53 <siracusa> simona_: Do you know how to handle a mouse (release) event on a label?
05:01:43 <simona_> siracusa: I guess it should be l `on` buttonRelease $ tryEvent $ do ...
05:02:22 <siracusa> simona_: Yeah, I tried that but nothing happens
05:02:43 <Botje> congrats to all SoC students!
05:10:11 <ManateeLazyCat> For all gtk2hs user: If you use ghc-6.10, just use gtk2hs-0.10.1, if you use ghc-6.12, you can use Cabal install below packages: glib, cairo, pango, gtk.
05:10:21 <ManateeLazyCat> from darcs repository.
05:10:52 <benmachine> when do we get them on hackage :P
05:11:29 <ManateeLazyCat> benmachine: I have convert all non-core packages to Cabal, but it's need Axel adjust gtk package before i push those Cabla packages.
05:11:40 <benmachine> awesome
05:11:40 <simona_> siracusa: I think a Label does not create it's own GdkWindow (DrawWindow in Gtk2Hs) and only these can receive events. I think...
05:11:41 <quicksilver> ManateeLazyCat++
05:12:04 <ManateeLazyCat> benmachine: Time is limit by Axel's spare time.
05:13:12 <ManateeLazyCat> benmachine: And one thing is, we plan to departed GnomeVFS, so i'm binding GIO to newest, make sure user will use same GIO functions to replace GnomeVFS one.
05:14:35 <siracusa> ManateeLazyCat: Is the cabalized version buildable with GHC 6.10?
05:15:37 <ManateeLazyCat> siracusa: I think cabalized version (glib, cairo, pango, gtk) should be works one 6.10,  Axel has them with 6.10 , i have test them with 6.12.
05:16:17 <alpounet> ManateeLazyCat, so glib, cairo, pango and gtk2hs from the darcs repo can be built and installed just by cabal installing them ? that's awesome indeed!
05:16:21 <ManateeLazyCat> siracusa: As i said, cabalized version just have core-packages
05:16:23 <alpounet> eventually we got that
05:16:49 <siracusa> ManateeLazyCat: So glade is not yet cabalized?
05:16:55 <ManateeLazyCat> alpounet: Infact, all package in gtk2hs can install by Cabal, just i haven't push non-core packages.
05:17:08 <ManateeLazyCat> siracusa: All packages, just haven't push.
05:17:15 <ManateeLazyCat> siracusa: Including Glade.
05:18:34 <ManateeLazyCat> Calized package has finish: glib, cairo, pango, gtk, gconf, gio, glade, gtkglext, gtksourceview2, soegtk, svgcairo, vte, webkit.
05:19:08 <ManateeLazyCat> After i finish GIO APIs update and Axel finish gstreammer, we can release gtk2hs-0.10.5
05:20:33 <alpounet> via hackage ? =)
05:21:23 <ManateeLazyCat> alpounet: Well, before i push those Cabal packages, i need Axel adjust `gtk` package, otherwise can't compile pass those non-core packages.
05:21:31 <alpounet> ok
05:21:59 <ManateeLazyCat> alpounet: Axel looks too busy recently, so we need wait he some time.
05:22:11 <alpounet> no hurries anyway
05:22:37 <ManateeLazyCat> alpounet: BTW, cabal install gtk2hs is *damn* fast. In 5 mintues.
05:23:00 <alpounet> if none of gtk2hs' dependencies are installed, you mean ?
05:23:06 * dcoutts finds that speed surprising
05:23:22 * hackagebot iteratee-parsec 0.0.3 - Package allowing parsec parser initeratee  http://hackage.haskell.org/package/iteratee-parsec-0.0.3 (MaciejPiechotka)
05:23:33 <ManateeLazyCat> alpounet: Just gtk.
05:23:38 <alpounet> ok
05:23:41 <ManateeLazyCat> alpounet: Otherwise packages very fast.
05:25:03 <ManateeLazyCat> After release gtk2hs-0.10.5, we will review/push Gtk+ 2.18.3 patches from other repository, then i can push my patches for Gtk+ 2.20, after that, i can rest half year. :)
05:28:10 <ManateeLazyCat> dcoutts: ApiGen can't work, i binding GIO by hand, and luck, i have gtk2hs.el :)
05:28:31 <jkramer> Hi
05:29:00 <ManateeLazyCat> dcoutts: I'm write test code for new functions, then Axel will apply my patches quickly. :)
05:29:10 <siracusa> ManateeLazyCat: Can you post your patches to haskell-cafe or so, for the impatient ;-)
05:30:34 <ManateeLazyCat> siracusa: Simple answer is : no, because `gtk.cabal` or Setup.hs need adjust, we don't want delete code after we released it, we don't want *break* user code.
05:31:13 <ManateeLazyCat> siracusa: "Never break user's code". :)
05:31:26 <ManateeLazyCat> siracusa: BTW, i'm impatient too.
05:31:47 <ManateeLazyCat> siracusa: Because i have so much local repositories that make me crazy. :)
05:31:53 <siracusa> ManateeLazyCat: Hhm, ok
05:33:58 <simona_> siracusa: The repo at code.haskell.org/gtk2hs contains a fully working cabalized Gtk2Hs (it's not quite working for Windows). You can use this is you only need gtk/cairo/pango.
05:35:17 <siracusa> simona_: Unfortunately, I'm on Windows and need the glade extension.
05:36:14 <ManateeLazyCat> siracusa: Windows perhaps need longer, because most gtk2hs developer haven't Windows.
05:36:26 <simona_> siracusa:  Right :-( . I'll give it a whirl this we, see if I can get Andy's (ManteeLazyCat) patches to work.
05:36:42 * dcoutts highly recommends KVM for windows testing
05:36:56 <dcoutts> only downside is I actually had to buy a copy of Win XP
05:36:57 <simona_> ManateeLazyCat: Malcom Wallace has done some testing for Windows and it seems that it's nearly there.
05:37:20 <fasta> dcoutts_, so you can run Windows within Linux?
05:37:32 <ManateeLazyCat> simona_: Yes, i read his's post.
05:38:43 <fasta> dcoutts_, never mind.
05:38:45 <ManateeLazyCat> dcoutts: Infact, i have a "Windows 7" for my GF, but i don't want waste time on Windows.
05:39:08 * quicksilver is sure that ManateeLazyCat didn't mean to imply his girlfriend runs on windows 7 ;)
05:39:09 <ManateeLazyCat> fasta: You can use VirtualBox to run Windows in Linux, but it's slower than KVM.
05:39:14 <dcoutts> fasta: yeah, it works really well
05:39:18 <dcoutts> KVM is easy and free
05:39:30 <ManateeLazyCat> quicksilver: My GF hate Linux. :)
05:39:34 <fasta> Can you also use the GPU?
05:39:48 <fasta> (when running Windows in KVM)
05:39:59 <dcoutts> check the KVM website
05:40:11 <jkramer> I'm looking for a module that allows me to traverse directories recursively and find files/directories matching given criteria, similar to File::Find in Perl
05:40:12 <ManateeLazyCat> dcoutts: KVM need special CPU?
05:40:17 <jkramer> is there something like that for Haskell?
05:40:34 <ManateeLazyCat> quicksilver: And i hate Windows, i feeling Windows is wate my time.
05:41:01 <dcoutts> ManateeLazyCat: needs the hardware virtualisation support, it's in most CPUs made in the last 2-3 years
05:41:21 <ManateeLazyCat> dcoutts: Unfortunately, my CPU haven't that feature.
05:42:09 <ManateeLazyCat> dcoutts: I use VirtualBox, just works fine, but slow.
05:42:23 <pookleblinky> http://osdir.com/ml/xmonad@haskell.org/2010-01/msg00055.html ah
05:42:34 <Cale> jkramer: http://hackage.haskell.org/package/FileManip looks good
05:42:46 <Cale> http://hackage.haskell.org/packages/archive/FileManip/0.3.2/doc/html/System-FilePath-Find.html#v%3Afind
05:43:15 * ManateeLazyCat Unfortunately, i found bug (perhaps) in Gtk+ 2.20 that break my code 
05:44:00 <ManateeLazyCat> GtkPlug can't works when reparent GtkSocket.
05:44:52 <mun> given \forall x,y. f(x) = f(y) <=> \forall x,y. f(x) = g(y) /\ X, is there any way to find what X could be? e.g., X could be \forall x. f(x) = g(x). is this like unification?
05:45:40 <dolio> I still think it's undecidable, except for unsatisfying answers.
05:46:09 <augur> mun: theres an infinity of possibilities
05:46:26 <ManateeLazyCat> Talk enough, i need binding GIO now, another *huge* API except Gtk+. Oh, god .....
05:46:28 <dolio> And, really, even the unsatisfying answers might be tough.
05:46:33 <augur> if you know what f anf g are, then maybe
05:46:47 <jkramer> Cale: Cool, thanks
05:47:01 <mun> dolio, why do you think it's undecidable?
05:47:40 <mun> augur, assume I do know what f and g are, how would one go about finding X?
05:47:41 <dolio> Because first-order logic is undecidable in general.
05:48:31 <mun> generate all possible models for the left hand term in the consequent and find an expression that includes those models satisfying the antecedent?
05:48:34 <augur> mun: logical manipulation of f
05:48:42 <augur> no that would be silly
05:49:20 <mun> dolio, true, but there are some pretty good FOL theorem provers out there that can do pretty well, e.g., Vampire etc.
05:49:25 <augur> imagine if, for instance, f(x) = h(x) & j(x) & \exists y[k(x,y)], and g(x) = h(x) & j(x)
05:49:52 <augur> obviously you can see that you can subtract out g(x) from f(x) to get \exists y[k(x,y)] = X
05:49:55 <augur> but if you had, say
05:50:41 <mun> augur, so it's a syntactic manipulation?
05:51:00 <quicksilver> I'm quite sure it's undecidable in all sorts of boring ways
05:51:06 <quicksilver> you could hope for syntactically minimal examples
05:51:21 <augur> f(x) = ~ \forall y[~k(x,y) | ~h(x) | ~g(x)]
05:51:24 <quicksilver> in some appropriate diagonal or breadth first enumeration of your syntax
05:51:39 <augur> if this were f, then you could still manipulate it to get g out
05:51:52 <augur> g necessarily depends only on x, right
05:52:01 <dolio> For instance, if you ask P <=> Q /\ X as above, and it decides P => Q (which may already be non-trivial), then P <=> Q /\ P is a solution.
05:52:10 <augur> so if you can find the parts of f which are separable, then you can find X
05:52:13 <dolio> But it's not the one you want.
05:52:16 <augur> this should be possible
05:52:36 <augur> fax!
05:53:00 <augur> ok im out. <3
05:53:43 <mun> thanks
05:54:31 <fax> hi
05:54:45 <gio123> fax: hi
06:12:50 <blart> i think i need functional dependancies but i don't know what they are
06:13:11 <blart> i'm getting No instance for blah blah errors because my types are ambiguous
06:13:27 <blart> but i reckon they could be inferred if i could tell the compiler they are dependant
06:13:32 <blart> is this what a functional dependancy is for?
06:13:45 <dolio> It's entirely possible.
06:13:57 <blart> i'm trying to overload "$"
06:14:04 <blart> so I have: class A a where ($$) :: a
06:14:06 <blart> instance A ((a -> b) -> a -> b) where a $$ b = a b
06:14:18 <dolio> Then, no.
06:14:28 <dolio> Functional dependencies are for multi-parameter type classes.
06:14:49 <blart> hmm
06:15:51 <blart> the problem is how to overload ($) such that i can maintain its normal imlpementation for (a -> b) -> a -> b, but i'd also like an a -> b -> c implementation
06:15:58 <blart> i'm not sure if this is possible
06:15:58 <fax> wow blart thats mad
06:16:25 <fax> class Dollar arrow a b where ($$) :: arrow a b -> a -> b
06:16:27 <fax> what aboult that?
06:16:38 <fax> infact
06:16:38 <blart> i did exactly that
06:16:40 <blart> which is ok
06:16:43 <fax> class Dollar arrow where ($$) :: arrow a b -> a -> b
06:16:46 <fax> no need for a and b
06:16:53 <fax> well you write something a bit different
06:16:55 <blart> but then another implementation has to be an arrow
06:17:08 <fax> then you can instance with (->)
06:17:11 <zygoloid> blart: what do you want to happen for the a -> b -> c case?
06:17:17 <Cale> blart: How the heck is it supposed to know which instance you mean? It'll be inherently ambiguous
06:17:21 <fax> but you could also instance with some other types or arrow
06:17:39 <blart> fax: yeah i did an instance for (->)
06:18:08 <blart> fax: so i have the (a -> b) -> a -> b instance, but how to do a -> b -> b instance such that a and b are the same type. is this ludicrous?
06:18:28 <Cale> That's kind of silly. What would the instance look like anyway?
06:18:34 <zygoloid> blart: you want an instance with ($$) :: a -> b -> b? flip const?
06:19:08 <blart> i did one with `data Foo' a b' and type Foo = Foo () () but blargh
06:19:14 <jmcarthur> blart: i have done this. lemme dig up the hpaste for it
06:19:16 <blart> zygoloid: well sort of
06:19:19 <blart> jmcarthur: yay!
06:19:21 <Cale> blart: What are you trying to express?
06:19:26 <jmcarthur> i used associated types
06:19:41 <zygoloid> blart: what other types do you want for ($$) other than (a -> b) -> (a -> b) ?
06:19:41 <Cale> jmcarthur: Do you actually understand what blart is trying to do?
06:19:59 <fax> blart no I said get rid of a and b
06:20:09 <blart> Cale: ok. i want to insert html tags into other ones with ($), rather than having to define my own combinator "<<" or w/e, and i obv. want to maintain the old one
06:20:16 <jmcarthur> Cale: i think so
06:20:22 <blart> fax: oh wait
06:20:25 <Cale> blart: whaaaaat
06:20:26 <jmcarthur> blart: huh?
06:20:30 <blart> fax: lemmie try
06:20:43 <jmcarthur> blart: that would not be a faithful overloading of ($) as far as i can tell
06:21:03 <blart> :{
06:21:09 <jmcarthur> blart: anyway, here's how i overloaded ($) with associated types: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24906#a24908
06:21:20 <Cale> blart: ($) is function application. However you choose to generalise it should be a generalisation of function application somehow.
06:21:56 <jmcarthur> blart: i decided later that my overloading is probably a bit too general to be very useful, though. i need to come up with some restrictions on it
06:22:03 <zygoloid> blart: can you give an example of another type you want ($$) to exhibit?
06:22:07 <opqdonut> you _could_ have a html generation library where tags are functions that take inner tags as arguments
06:22:14 <opqdonut> in which case $ would be applicable
06:22:20 <Cale> (The sensible generalisation which jmcarthur's code embodies is the one where you treat other datatypes as functions in various natural ways
06:22:23 <Cale> )
06:23:00 <Cale> opqdonut: That's true... but $ already works there.
06:23:14 <Cale> (to the extent that it's ever going to work)
06:23:29 <jmcarthur> Cale: ($) works there unless they are not *actually* haskell functions
06:24:59 <Cale> Okay, but you could always contrive that they are.
06:25:09 <jmcarthur> sure
06:25:13 <Cale> Or else define a new operation which turns them into functions first
06:25:46 <blart> well that can be done right? Html -> (Html -> Html)? make a parent tag into a consumer of child tags?
06:26:00 <Cale> hmmm
06:26:18 <Cale> But the Html value that you give as the first parameter might not have a well-defined insertion point.
06:26:29 <augur> mun: yes, in a very real sense it's syntactic manipulation, but manipulation according to some logic
06:26:34 <jmcarthur> i don't think it's a particularly great idea
06:26:48 <Cale> What if it's some complicated random HTML document?
06:26:53 <augur> if, for instance, you were using intuitionistic logic, you might not be able to do some of the things necessary to solve for X
06:26:55 <Cale> Where does the new stuff go?
06:27:14 <augur> but to the extent that you can do manipulation of that sort, yes, you can solve for X
06:27:22 <blart> Cale: insertion always replaces whatever's inside
06:27:26 <jmcarthur> algebraic combinators would be much cooler
06:27:38 <Cale> hmm, I suppose that works
06:27:45 <jmcarthur> blart: then how do you insert more than one child into a parent?
06:28:00 <jmcarthur> or do you mean you combine children before insertion?
06:28:01 <blart> jmcarthur: by appending two tags together into e.g. HtmlTags [Html]
06:28:04 <blart> yeh
06:28:05 <jmcarthur> ah
06:28:19 <jmcarthur> that seems somewhat reasonable
06:28:26 <blart> the reason i really want parents to not be functions is so that i can use record syntax
06:28:27 <jmcarthur> but not very new
06:28:31 <Cale> But overall this seems like it's just going to be more awkward than much more obvious ways of handling this problem.
06:28:51 <jmcarthur> blart: how would that help you use record syntax?
06:29:07 <blart> form {frm_action="foo",frm_method="bar"} $ fieldset $ input{inp_type="text"}
06:29:11 <blart> for example
06:29:20 <quicksilver> record syntax is a non-composable aberration
06:29:28 <quicksilver> do not use it as part of a nice design.
06:29:38 <blart> this ensures the attributes for tags are correct
06:30:04 <Cale> blart: btw, nesting ($)'s is ordinarily considered bad style too
06:30:38 <Cale> (it's better to use function composition wherever you can -- compose functions and then apply them to a parameter with a single $)
06:30:51 <quicksilver> form [ frm_action := "foo", frm_method := "bar" ] /> fieldset /> input [ inp_type := "text" ]
06:30:54 <quicksilver> could still be type-safe
06:31:03 <jmcarthur> blart: if you're going to abuse record syntax and function application you might as well just write a quasiquoter or something so you can use whatever syntax you want
06:31:06 <fax> what are those green versions of blackboards called?
06:31:06 <quicksilver> (given appropriate definitions of := and /> )
06:31:07 <blart> Cale: well it's because i'm using do syntax, so i don't have to do this horrible custom syntax
06:31:35 <Cale> eh?
06:31:43 <blart> :=, />, +++, etc.
06:31:45 <blart> ugh!!
06:31:47 <jmcarthur> do is overrated
06:31:54 <Cale> What monad is this?
06:31:56 <quicksilver> blart: why ugh?
06:32:07 <blart> main = renderHtml stdoutRenderer $ do
06:32:07 <blart>     h1 "BlazeHtml" ! [("id", "header")]
06:32:07 <blart>     img "logo.png" "BlazeHtml logo"
06:32:07 <blart>     setAttributes [("class", "intro")]
06:32:10 <blart>     p $ do text "BlazeHtml is a blazing fast HTML combinator library."
06:32:13 <blart>            em $ text "BlazeHtml uses a monadic interface."
06:32:16 <blart>            text "This gives us very readable code."
06:32:18 <jmcarthur> blart: nooo!
06:32:20 <blart> blaze html ^
06:32:21 <jmcarthur> hpaste
06:32:29 <quicksilver> blart: why is a new operator name more ugh then reusing an existing operator to do something completely different?
06:32:44 <Cale> blart: What are the results of those computations?
06:33:04 <Cale> Like, what if I write x <- h1 "BlazeHtml" ! [("id", "header")]
06:33:09 <Cale> What will x be?
06:33:11 <Cale> () ?
06:33:16 <Cale> Will it always be ()?
06:33:25 <quicksilver> it looks like a Monoid using monad notation, yes
06:33:27 <Cale> If so, then you might as well use the monoid interface.
06:33:54 <quicksilver> but you could imagine some cases where <- returns some information about the current nesting.
06:33:55 <blart> they wrote a custom monad (no idea why)
06:33:58 <Cale> (maybe with a better choice of operator symbol than `mappend`)
06:33:59 <fax> what is monoid notaon?
06:34:01 <fax> notation
06:34:04 <jmcarthur> like i said, algebraic combinators are much nicer for things like this
06:34:13 <fax> what is algebraic combinators?
06:34:13 <benmachine> do you ever get the feeling that one of your sneaky corner case hacks has just crashed into one of your other sneaky corner case hacks and suddenly everything is going to explode
06:34:19 <fax> ⊕ <-- that's a monoid plus
06:34:23 <jmcarthur> fax: fold [a, b, c, d]
06:34:29 <fax> ⊗ <-- but then this a monoid times..
06:34:30 <jmcarthur> that's monoid notation ;)
06:34:33 <blart> Cale: i would personally use a writer monad. so x <- h1 .. is ()
06:35:06 <Cale> fax: Those symbols are used for a number of things, but most commonly in mathematics as operations on set-like structures of various sorts (vector spaces for example)
06:35:22 <fax> oh I've not really got that far
06:35:31 <fax> direct product
06:35:50 <jmcarthur> the setAttributes function in the code blart pasted throws me off though. looks less like a monoid
06:35:51 <blart> quicksilver: how is it completely different? it's just a writer monad. it's a monad for outputting html..
06:36:11 <blart> jmcarthur: well that's stupid i wouldn't have that, i just didn't have another example of using do notation to write html
06:36:11 <Cale> fax: ⊕ is direct sum (or direct product, it's the same for vector spaces), and ⊗ is tensor product
06:36:38 <blart> jmcarthur: anyway it beats the pants of defining your own combinators to write horrible line noise
06:36:46 <Cale> jmcarthur: hmm
06:36:52 <Entroacceptor> Haskell, the only language where you spend more time argueing over mathematics than writing code ;)
06:37:14 <jmcarthur> blart: i'd prefer to use general algebraic combinators, not new ad hoc combinators
06:37:42 <quicksilver> jmcarthur: setAttributes is perfectly monoidic still
06:37:56 <blart> jmcarthur: which algebraic combinators?
06:37:57 <Cale> What does setAttributes influence?
06:37:59 <quicksilver> blart: the 'completely different' part was a comment on your plan to use ($) for something other than function application.
06:38:09 <quicksilver> Cale: the attributes of successive tag(s)
06:38:18 <Cale> The last tag? Ah, the following tag?
06:38:19 <blart> Cale: that's just for that particular implementation, they had it so the monad was a reader monad with the attributes in the r
06:38:55 <Cale> See, this wouldn't be so confusing with the special combinators ;)
06:39:00 <Saizan> jmcarthur: as a side note, what makes a combinator an algebraic one?
06:39:19 <blart> quicksilver: well i could just write << or $$ but ($) seemed less noisy
06:39:35 <quicksilver> blart: I don't understand why you think it's "line noise" to define new combinators and "horrible", but it's nicer to give an existing symbol a new and completely unrelated meaning.
06:40:09 <Saizan> s/nicer/nicer than/ ?
06:40:17 <blart> quicksilver: it's horrible line noise because it looks like a mess
06:40:31 <quicksilver> whilst I accept that these things are subjective, myself I'm fairly clear that it's abhorrent to take an existing symbol and give it an unrelated new meaning, but quite reasonable to define new combinators with precisely the meaning you choose.
06:40:33 <Cale> blart: It's not so nice to take function names which already have well established meanings and redefine or overload them to have completely unrelated meanings.
06:40:34 <blart> quicksilver: redefining ($) is probably a bad idea i get it
06:40:45 <quicksilver> I don't think it looks like a mess.
06:40:50 <blart> good for you ?
06:40:52 <Cale> This applies equally to infix and prefix functions.
06:41:22 <quicksilver> what it looks like is new notation - so you have to learn what it means
06:41:27 <blart> quicksilver: out of interest have you written a nontrivial web application with those combinators?
06:41:31 <quicksilver> but once you learn what it means, it's efficient.
06:41:40 <Cale> It would generally be pretty confusing to do something like define a function called map which had no relationship at all with the Prelude map
06:41:43 <quicksilver> all new notation has a start-up cost
06:42:01 <quicksilver> but on the other hand most people find infix operators have a lower syntactic overhead one they're used to them
06:42:03 <blart>  handling all these messy operators all over the place .. not efficient imo but oh well
06:42:14 <quicksilver> that's why most of the combinator librarys out there use at least some infix operators
06:42:23 <jmcarthur> Saizan: it's algebraic if i say it is, for lack of a more concrete definition ;)  ... but if i was to try more seriously i'd say it must be a operation in an algebraic structure
06:42:47 <blart> i'll just use (<<)
06:42:52 <quicksilver> blart: blazehtml, no, I haven't. Infix combinator libraries, sure. Almost every piece of haskell I've ever written has used at least some infix combinators.
06:43:49 <blart> quicksilver: ok. in my experience dealing with infix combinators at least for html is a massive pain in the arse to edit and read
06:44:11 <jmcarthur> not in my experience
06:44:13 <Cale> blart: Note that as long as your lines remain indented properly, you can continue expressions onto following lines even if they involve things like <<
06:44:20 <blart> i know
06:44:45 <Cale> So you could put a line break before each << for example
06:44:53 <quicksilver> for example, this is gtk2hs syntax: "set window [ containerBorderWidth := 10, containerChild := button ]". If they decided they didn't like infix operators, they could have chosen the syntax "set window [ Attr containerBorderWidth 10, Attr containerChild button ]".
06:45:08 <Cale> and it would quite closely approximate the effect of the do-notation, without all the conceptual noise.
06:45:16 <blart> http://github.com/glguy/hpaste/blob/master/src/Pages.hs
06:45:18 <quicksilver> it's purely subjective, but I agree with the gtk2hs designers that the infix := is more readable than a prefix Attr would be.
06:45:19 <blart> look at that mess
06:46:08 <jmcarthur> blart: that code doesn't follow some of my preferred conventions, but i don't think the combinators are a source of frustration to me there
06:46:09 <blart> parentheses should never span more than one line  ugh
06:46:15 <Saizan> blart: you should use some HOFs
06:46:19 <jmcarthur> blart: i definitely disagree with that
06:46:26 <blart> Saizan: what's a HOF?
06:46:38 <Saizan> blart: higher order function, like e.g. map
06:46:41 <Reo> dunno.
06:46:48 <blart> Saizan: to do what?
06:46:48 <Saizan> blart: that would reduce a lot of the repetitions
06:46:50 <quicksilver> I agree that that code is not particularly attractive
06:47:02 <quicksilver> I don't think that's *because* the HTML library there has infix operators
06:47:10 <quicksilver> I think rather it's the other implementation choices
06:47:11 <blart> quicksilver: i think it's because he didn't have time to prettify it
06:47:14 <benmachine> I think that code's fine, except for indenting depending on name lengths
06:47:20 <blart> quicksilver: and that if he did it with do notation he wouldn't have had to
06:47:26 <quicksilver> the relative apparent weight of +++, << and !
06:47:32 <Cale> There are other things wrong with that code too -- particularly the nested if/then/else usage
06:47:37 <Saizan> blart: and you could also abstract some patterns like "a row in a table" into a function that takes a list of the elements in that row
06:47:59 <blart> Saizan: yeah you can go so far with that
06:48:09 <blart> it seems like writing html is always a barrage of special cases, however
06:48:11 <benmachine> Cale: why is that a problem particularly?
06:48:24 <Cale> benmachine: Would be nicer to use guards
06:48:39 <Cale> (Maybe 'wrong' is a bit of a strong word)
06:48:48 <benmachine> Cale: maaaaybe... don't know there'd actually be a big difference
06:49:19 <quicksilver> blart: I don't think that using do notation is going to be the magic bullet you think it is :)
06:49:31 <Saizan> those if/then/else are definitely not idiomatic :)
06:50:39 <jmcarthur> hpaste died :(
06:51:32 <jmcarthur> blart: the code you pasted earlier without do notation: http://codepad.org/f4WwRlOt
06:52:01 <jmcarthur> and without that setAttributes junk
06:52:10 <IceDane> 15:47 <+IceDane> for fun and profit
06:52:13 <IceDane> oops.
06:52:33 <Cale> If you're going to go to a lot of trouble to hack things so that you have nice syntax for HTML, probably your best bet is to write a quasiquoter...
06:52:45 <Cale> Maybe someone has already done this
06:52:46 <jmcarthur> agreed
06:53:07 <Cale> Just, if you do it, don't copy the HTML syntax itself, since it's even uglier than using infix operators and lists.
06:53:21 <quicksilver> all do notation does in this case - at best - is let you take *one* monoidal operator at *one* level, and implement that with ; or new line
06:53:38 <quicksilver> it doesn't do anything helpful about nesting, and HTML construction is all about the nesting.
06:53:58 <portnov> @hoogle allM
06:53:58 <lambdabot> Text.Regex.Base.RegexLike newtype AllMatches f b
06:53:59 <lambdabot> Text.Regex.Base.RegexLike AllMatches :: f b -> AllMatches f b
06:53:59 <lambdabot> Text.Regex.Base.RegexLike getAllMatches :: AllMatches f b -> f b
06:54:09 <quicksilver> even that use of do notation is an abuse, really, is it that much better than mconcat [... , \n ..., \n ...] ?
06:54:16 <jmcarthur> :t all
06:54:17 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
06:55:04 <jmcarthur> allM :: (a -> m Bool) -> [a] -> m Bool?  allM :: (a -> Bool) -> [m a] -> m Bool?  allM :: (a -> m Bool) -> [m a] -> m Bool?
06:56:08 <fax> what does M mean
06:56:28 <jmcarthur> i'm assuming it's like replicateM, mapM, etc.
06:56:38 <jmcarthur> :t mapM
06:56:39 <fax> any more?
06:56:39 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
06:56:49 <jmcarthur> :t filterM
06:56:50 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
06:57:13 <fax> :t ((map,mapM),(replicate,replicateM),(zipWith,zipWithM))
06:57:13 <lambdabot> forall a b a1 (m :: * -> *) b1 a2 (m1 :: * -> *) a3 a4 b2 c a5 b3 (m2 :: * -> *) c1. (Monad m, Monad m1, Monad m2) => (((a -> b) -> [a] -> [b], (a1 -> m b1) -> [a1] -> m [b1]), (Int -> a2 -> [a2],
06:57:14 <lambdabot> Int -> m1 a3 -> m1 [a3]), ((a4 -> b2 -> c) -> [a4] -> [b2] -> [c], (a5 -> b3 -> m2 c1) -> [a5] -> [b3] -> m2 [c1]))
06:57:17 <Cale> Presumably unlike 'all' itself, you'd want allM to not be written in terms of mapM, since you want the early termination
06:57:17 <jmcarthur> :o
06:57:18 <lazni> @src takeWhile
06:57:18 <lambdabot> takeWhile _ []                 =  []
06:57:18 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
06:57:18 <lambdabot>                    | otherwise =  []
06:57:44 <fax> does M only work on functions that work on lists?
06:57:57 <Toxaris> fax: the M is part of the name
06:57:58 <jmcarthur> :t Data.Traversable.mapM
06:57:58 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
06:58:01 <Cale> fax: The M isn't anything in particular
06:58:16 <Toxaris> fax: and it just means that the function is somehow related to monads
06:58:19 <fax> travesable just means list-like so we can ignore that
06:58:21 <Cale> fax: It's just a convention which means "some monadic generalisation of this thing"
06:58:34 <Toxaris> fax: so if foo is some function, and there is a version of foo wich does something similar, but with monadic actions, it is often called fooM
06:58:37 <Cale> fax: In general, functions will generalise in more than one way, and we pick one.
06:58:44 <fax> Cale: which one?
06:58:55 <Cale> Usually whichever is easiest to write.
06:58:59 <jmcarthur> @src filterM
06:59:00 <lambdabot> Source not found. Where did you learn to type?
06:59:05 <Cale> (and thus probably the most obvious)
06:59:23 <fax> is fooM with identity monad = foo?
06:59:35 <Cale> fax: That's a good quality to have
06:59:45 <sclv> preflex: seen decoutts
06:59:45 <preflex>  Sorry, I haven't seen decoutts
06:59:48 <jmcarthur> hmm
06:59:54 <Cale> (and is, I think satisfied at least up to strictness by the stuff in Control.Monad)
06:59:57 <sclv> preflex: seen dcoutts
06:59:57 <preflex>  dcoutts was last seen on #haskell 1 hour, 18 minutes and 56 seconds ago, saying: ManateeLazyCat: needs the hardware virtualisation support, it's in most CPUs made in the last 2-3 years
07:00:03 <quicksilver> well, there is a methodical way.
07:00:24 <lazni> @src dropWhile
07:00:24 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
07:00:28 <quicksilver> you put an "m" on the return values of all functions taken as parameters.
07:00:33 <Cale> There's more than one methodical way, even ;)
07:00:48 <sclv> preflex: seen dons
07:00:48 <preflex>  dons was last seen on #haskell 14 hours, 6 minutes and 25 seconds ago, saying: sproingie: so the point is whether haskell encourages naive code, and perhaps it does.
07:00:50 <EvanR-work> im trying to make a polymorphic function and failing. roll :: RandomGen g => Rand g Bool; roll = getRandom :: Rand g Bool
07:00:54 <fax> :t null
07:00:54 <lambdabot> forall a. [a] -> Bool
07:01:00 <jmcarthur> > head . runIdentity . mapM id $ [1..]
07:01:01 <lambdabot>   No instance for (GHC.Num.Num (Control.Monad.Identity.Identity b))
07:01:01 <lambdabot>    arisin...
07:01:05 <jmcarthur> oops
07:01:14 <jmcarthur> > head . runIdentity . mapM Identity $ [1..]
07:01:15 <lambdabot>   1
07:01:16 <fax> :t findM
07:01:17 <lambdabot> Not in scope: `findM'
07:01:19 <fax> :t find
07:01:19 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
07:01:30 <fax> why not findM :: (a -> m Bool) -> [a] -> m (Maybe a)?
07:01:31 <quicksilver> Cale: yes, indeed
07:01:34 <Cale> EvanR-work: drop the explicit type signature in the code
07:01:46 <Cale> roll :: RandomGen g => Rand g Bool; roll = getRandom
07:01:50 <fax> what other methodical ways are there?
07:01:56 <EvanR-work> Cale: i want it to return a Bool
07:02:09 <jmcarthur> EvanR-work: the top-level signature already guarantees that
07:02:16 <EvanR-work> oh
07:02:47 <fax> Cale; what about writing M functions and then defining -M functions in terms of runIdentity?
07:03:00 <fax> :t foldM
07:03:01 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
07:03:03 <Cale> EvanR-work: The problem is that the 'g' in the two type signatures is not the same g
07:03:09 <EvanR-work> ah
07:03:41 <Cale> fax: You could do that, but it would at best make the simplifier work hard, and at worst make things perform more poorly
07:04:03 <EvanR-work> so if i were to put getRandom in the middle of a do block, how would i make it a bool. getRandom :: Rand specificGen Bool ?
07:04:04 <Cale> (and usually not add much clarity to the definition)
07:04:13 <fax> (.M) :: (m b <- a) -> (m c <- b) -> (m c <- a)
07:04:18 <fax> composeM
07:04:19 <Cale> fax: Essentially the M versions are overspecified versions of the non-M versions
07:04:45 <gio123> Cale: hi
07:04:51 <fax> what does overspecified mean?
07:04:53 <Cale> You'd expect the non-M versions of the functions to be easier to read
07:05:14 <Cale> Means that there's information in them that's discarded by the identity monad
07:05:27 <fax> ah!
07:05:32 <quicksilver> Cale: and in a few cases catastrophically break the space behaviour, I fear? does runIdentity mapM have the right space behaviour on infinite lists?
07:05:36 <fax> that's like in scheme too
07:05:41 <Cale> mapM puts an explicit order on the execution of the actions it gets from applying the function to the list values
07:05:42 <quicksilver> (or, rather, on very long lists)
07:05:50 <fax> when we write (a b c) it doesn't say which order you should evaluate a b or c
07:06:06 <Cale> quicksilver: hmmm
07:06:12 <dolio> > runIdentity (mapM (Identity . succ) [1..])
07:06:13 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
07:06:14 <Cale> quicksilver: I sort of think that it ought to
07:06:27 <jmcarthur> > head . tail . runIdentity . mapM Identity $ undefined : [1..]
07:06:28 <lambdabot>   1
07:06:38 <fax> map f = runIdentity (mapM (Identity . f))
07:06:53 <Cale> quicksilver: But wouldn't be *too* surprised if I turned out to be wrong.
07:08:01 <jmcarthur> @src mapM
07:08:02 <quicksilver> dolio's and jmcarthur's proofs seem to make it look ok :P
07:08:02 <lambdabot> mapM f as = sequence (map f as)
07:08:17 <jmcarthur> proofs, eh?
07:08:18 <Cale> We could try to simplify it all out and see
07:08:26 <jmcarthur> @src sequence
07:08:26 <lambdabot> sequence []     = return []
07:08:26 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
07:08:26 <lambdabot> --OR
07:08:26 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
07:08:53 <EvanR-work> why is that sequence so much more complicated
07:08:57 <Cale> hm?
07:09:01 <Cale> Which one?
07:09:02 <jmcarthur> EvanR-work: there are two definitions there
07:09:03 <EvanR-work> oh
07:09:22 <siracusa> When you use getContents to read a Happy file line by line from the keyboard, will the `file' be processed lazily i.e. fail only after the first syntactically incorrect line?
07:09:22 <EvanR-work> i was getting mapM and sequence confused
07:09:42 <Cale> sequence is simpler than mapM, but usually mapM is defined in terms of sequence
07:09:57 <fax> Cale -- it would be cool if you could run haskell on functions!
07:10:13 <jmcarthur> if what could?
07:10:13 <Cale> fax: not sure what you mean by that...
07:10:30 <fax> like if you put in  (\f -> (\x -> f x) 7)  in ghci
07:10:35 <fax> and it would give \f -> f 7
07:10:43 <fax> or if you put in runIdentity (mapM (Identity . f)) it would print out map f
07:10:46 <Cale> ah, a partial evaluator
07:10:47 <jmcarthur> evaluation under lambda?
07:10:51 <EvanR-work> all you need is a Show for functions ;)
07:11:09 <maurer_> Just use yhc, and dump the bytecode live :P
07:11:14 <jmcarthur> partial evaluation would be pretty awesome if it is ever tamed
07:11:34 <Cale> That would be a nice feature to add (with a flag) to benmachine's evaluator
07:11:42 <fax> tamed?
07:11:46 <jmcarthur> benmachine's evaluator?
07:12:08 <dolio> mapM (return . f) (x:xs) = return (f x) >>= \y -> mapM f xs >>= \ys >>= return (y:ys) = mapM f xs >>= \ys -> return (f x : ys)
07:12:15 <Cale> benmachine wrote a syntax-level step-by-step Haskell evaluator
07:12:25 <dolio> Given mapM f xs = return (map f xs) for the inductive hypothesis, you get...
07:12:29 <Cale> (it's unfinished as of yet, but already pretty cool)
07:12:37 <dolio> = return (f x : map f xs)
07:12:38 <jmcarthur> fax: runtime partial evaluators tend to cause explosions in partial languages from what i've read since they don't always know when would be best to stop
07:12:47 <fax> runIdentity . return = id!
07:12:58 <fax> that's great
07:13:32 <fax> jmcarthur, oh okay maybe it would have to ask you where to reduce and what to unfold, and especially when to use recursion
07:14:12 <Cale> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi
07:14:36 <Cale> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=foldr+%28%2B%29+0+[1%2C2%2C3]
07:14:42 <jmcarthur> ah cool
07:15:09 <Cale> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=let+double+x+%3D+x+%2B+x+in+double+%28double+5%29 -- clearly not lazy evaluation ;)
07:15:15 <Botje> .oO(now I want to make a graph reducer in javascript.)
07:15:48 <jmcarthur> fax: lazy partial evaluation is pretty awesome though. there's a thesis running around somewhere that discusses the design and implementation of a lazy partial evaluator that passes the tower of interpreters test
07:16:04 <opqdonut> tower of interpreters?
07:16:05 <fax> what is the tower of interpreters test?
07:16:26 * Botje pushes on his todo stack
07:16:35 <Botje> would be nice to learn some <canvas> and refresh JS
07:16:48 <jmcarthur> a stack of interpreters where each interpreter only adds a constant cost, if my memory serves correctly
07:17:12 <jmcarthur> one interprets another which interprets another with interprets another, etc.
07:17:13 <fax> Botje: an animated graph that can collapse due to reduction rules?? that would be really ureful
07:17:22 <Botje> yeah
07:17:45 <Botje> it's probably a better activity than dwarf fortress
07:17:51 <Botje> although dwarf fortress is more fun :)
07:18:00 * jmcarthur still hasn't played DF
07:18:01 <Jafet> jmcarthur, so, purely metacircular runtime?
07:18:41 <jmcarthur> Jafet: well, it's not necessarily a self-interpreter
07:18:54 <Jafet> Good point
07:19:30 <Jafet> I don't think it's possible in general. I think there's a theorem by Blum which would apply to this
07:19:40 <jmcarthur> Jafet: the point is that you can create DSLs without too much overhead
07:19:54 <jmcarthur> or at least that's the upside for me
07:20:07 <quicksilver> Botje: write a very simple declarative diagram drawer in JS and then do the hard work in haskell
07:20:15 <quicksilver> Botje: I have used that technique effectively
07:20:25 <Eelis> would it not be better if toList was a specializable member of the Foldable class? for nonempty lists represented by (a,[a]), conversion to list should really be O(1), but Data.Foldable.toList is O(n)
07:20:52 <Jafet> jmc: we already know how to do efficient DSLs very well, though
07:21:00 <jmcarthur> Jafet: certain kinds
07:21:21 <jmcarthur> Jafet: what sucks is when you have to resort to defunctionalization
07:21:45 <Jafet> Oh dear, resorting to long words I don't understand
07:21:54 <Jafet> I'll look up this paper then
07:22:13 <benmachine> someone was talking about me :P
07:22:16 <benmachine> *:O
07:22:27 <Botje> quicksilver: did you animate it?
07:26:01 <quicksilver> Botje: yes
07:26:09 <Botje> ooh, cool
07:26:18 <quicksilver> Botje: it was a kind of simplistic war game simulator
07:26:22 <blart> quicksilver: well do notation helps with (1) nesting and (2) appending. (1) you can rely just on the indentation to show nesting, you don't need dangling/ending parens/brackets. and for (2) a; b or newline is appending. you're inserting spaces and indenting anyway. extra stuff is just line noise that you have to read and edit
07:26:44 <quicksilver> blart: yes, that is tue
07:26:45 <quicksilver> true.
07:27:09 <quicksilver> It has been suggested more than one that it would be nice ot have a more general way to 'use' layout as a combinator tool
07:27:16 <quicksilver> without having to define spurious monad instances for it :)
07:27:18 <blart> quicksilver: i guess i'll do: p << bar and do notation
07:27:28 <blart> yeah
07:31:20 <quicksilver> Botje: http://roobarb.crazydogs.org/~jules/battlefield/canvastest.html
07:32:35 <Toxaris> Cale: how should a lazy reduction sequence look like? something like this? http://www.copypaste.at/1113
07:32:47 <Botje> quicksilver: coool!
07:33:27 <quicksilver> Botje: if you select from the two popups at the bottom it sends the description to a (haskell) CGI script which emits a javascript declarative description of the animation
07:33:42 <quicksilver> Botje: I can paste the source if you want
07:33:47 <quicksilver> it's not very elegant :)
07:33:58 <Botje> quicksilver: i can see how it works
07:34:02 <Botje> it's still pretty cool :)
07:34:55 <Cale> Toxaris: yeah
07:46:29 <benmachine> I want pattern synonyms
07:47:03 <benmachine> pattern VUI n = Var (UnQual (Ident n))
07:47:04 <benmachine> or something
07:47:13 <dolio> SHE has them.
07:47:25 <Saizan> with that syntax.
07:47:31 <quicksilver> pattern MOaS = Moon (On (A (Stick)))
07:47:33 <shapr> That would be nice.
07:47:42 <quicksilver> benmachine: there is always QQ
07:47:48 <quicksilver> it's not quite as nice to look at.
07:47:59 <dolio> SHE has them.
07:48:12 <quicksilver> yes, I gathered that :)
07:51:20 <Cale> I wonder what's so hard about full-blown views that they never got implemented.
07:51:58 <quicksilver> perhaps some boring detail abotu GHC phases rather than anything subtantial?
07:52:03 <quicksilver> I am only guessing.
07:52:22 <fax> what's missing from the views we have now?
07:53:11 <Cale> Well, okay, there's a sort of equivalence of power there... I think.
07:54:14 <Cale> But it's somewhat nicer perhaps to be able to define new constructors with backward and forward translations than it is to have separate functions for taking things apart and putting them back together.
07:54:53 <bitstream0101> Has anyone seen an error like 'h2ps: x.hp, line 485, samples out of sequence' from hp2ps and have an idea how to fix it?
07:55:01 <quicksilver> there is a summary of quite a lot of  the alternatives at http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns
07:55:34 <dolio> View patterns are missing the => for Maybe patterns, unless things have changed.
07:55:53 <dolio> But I don't think that was part of the original views idea.
07:56:50 <Cale> The original views idea is rather different-looking from the view-pattern syntax
07:57:21 <Cale> But view patterns have the nice property that every function is usable in a view pattern
07:57:52 <Cale> bitstream0101: weird
07:58:06 <bitstream0101> Cale: Yeah. What's even more strange is that the samples are actually out of sequence in the file ;P
07:58:17 <bitstream0101> Cale: and if i remove a few offending samples, I get a parse error instead :(
07:59:59 <Cale> bitstream0101: and it keeps happening if you remove the .hp and try again?
08:00:28 <bitstream0101> it's happened twice, i think, but i'm trying again now.
08:01:05 <quicksilver> I haven't used view patterns yet but http://neilmitchell.blogspot.com/2009/11/reviewing-view-patterns.html is quite interesting.
08:10:06 <bitstream0101> Cale: Okay, ran the test a 3rd time.  This time, no sequence ordering error, but instead I'm getting something like 'hp2ps: x.hp, line 1282656: integer must follow identifier' :(
08:10:47 <Cale> bitstream0101: That is really very strange. Maybe some bug(s) in the heap profiler? Which GHC are you using?
08:10:49 <bitstream0101> Cale: Nevermind, it cut off because the program crashed :P
08:10:52 <Cale> oh
08:11:23 <bitstream0101> Cale: Yeah, makes more sense now ;P
08:15:09 <Cale> bitstream0101: In what way did the program crash? If it crashed with a proper Haskell exception, I would expect the heap profile to be intact.
08:15:27 <Cale> If it was killed by the OOM killer, then all bets are off ;)
08:16:41 <bitstream0101> Cale: Probably, it's blowing the stack on a particular problem size, which is why I'd turned to profiling :P
08:18:00 <Cale> bitstream0101: Ah, the stack is another thing entirely. If you have *no* idea where it's happening then a normal profile might help (watch the entries column for large numbers)...
08:18:15 <Cale> However, first thing to check: are you compiling with -O or -O2?
08:18:24 <bitstream0101> Cale: -O2 in this case
08:19:25 <bitstream0101> and i've done normal profiling, but haven't noticed anything odd.  at least not in terms of #entries, although i do have some very large numbers in there, the test case itself is quite large so I expect it
08:19:41 <bitstream0101> (it's writing 128MB in 4k blocks, very slowly :P)
08:19:49 <Cale> Okay, next is to look for points in the program where you're taking "large" amounts of data (in the sense that there are lots of separately-evaluatable parts) and collapsing it down into a summary which is "small" (in the sense of having not many separately-evaluatable parts, which depend on all the input data)
08:20:37 <Cale> This is the sort of pattern where strictness is actually useful, and tends to be where you get stack overflows
08:20:57 <bitstream0101> Cale: Yeah, I have a guess -- the crash seems to occur (by my reading of my own log files) during a "free resource" like invocation, so I'm probably attempting to gather up too much stuff at once or something.
08:20:59 <Cale> accumulators count as well
08:21:02 <bitstream0101> *nod*
08:22:14 <Cale> If you want, you can pastebin the program, and I'll look for anything suspicious
08:22:44 <Cale> The stack that the GHC evaluator uses is not used for what a stack is normally used for in program execution.
08:22:47 <bitstream0101> Cale: I appreciate the offer, but I can't open source the code just yet and I'm operating under NDA atm.
08:23:21 <bitstream0101> Cale: Cool, I'll see if I can play around with it some more -- thanks!
08:23:30 <Cale> Essentially, the entries on the stack represent case expressions (or other pattern matches) which are waiting for their scrutinee to be evaluated enough to be able to pattern match
08:23:51 <bitstream0101> ahh, interesting
08:23:57 <Cale> (of course, it's all really a lot lower-level than that, but that's a reasonably good high-level approximation)
08:24:03 <bitstream0101> *nod*
08:27:52 <gio123> Cale: hi
08:27:57 <Cale> hello
08:28:56 <gio123> Cale: can you see pm
08:35:32 <wferi> Hi! I get cabal: Couldn't read cabal file "./HDBC/2.2.5/HDBC.cabal"
08:35:51 <wferi> with cabal-install version 0.6.4 using version 1.6.0.3 of the Cabal library.
08:36:10 <wferi> Is this normal and expected, or is something amiss here?
08:38:54 <Cale> wferi: something is amiss...
08:39:07 <bitstream0101> Cale: http://haskell.pastebin.com/AEVbWiDp if you're so inclined -- this _may_ be the culprit
08:39:33 <bitstream0101> in particular, i think i'm building up thunks around the accumulator
08:40:39 <Cale> bitstream0101: Yeah, maybe try freeCont !acc c = ...
08:40:49 <bitstream0101> is that the bang patterns extension?
08:40:51 <Cale> yeah
08:40:56 <bitstream0101> cool, i'll give it a shot. thanks.
08:40:57 <Cale> or equivalently...
08:40:59 <bitstream0101> seq
08:41:00 <bitstream0101> ?
08:41:08 <Cale> freeCont acc c = acc `seq` ...
08:41:13 <bitstream0101> seq acc $ ...
08:41:14 <bitstream0101> nod
08:41:14 <quicksilver> I don't see the recursion, I assume there is mutual recursion via freeBlocks?
08:41:34 <Cale> freeCont is a parameter to contFoldM
08:41:36 <quicksilver> oh, the recursion is in contFoldM
08:41:41 <bitstream0101> yeah, in contFoldM
08:42:07 <quicksilver> yes, force the acc and see if that fixes it
08:42:16 <quicksilver> you almost always want accumulators to be strict.
08:42:17 <bitstream0101> cool -- trying it now. the test takes a while to run :P
08:42:20 <bitstream0101> *nod*
08:43:10 <waterson> what does it mean when a program i'm trying to run outputs "<<loop>>"?
08:43:21 <xerox> infinite loop detected
08:43:54 <Cale> More specifically, it means that your program tried to evaluate an expression which was already in the midst of evaluating.
08:44:15 <waterson> that's very helpful -- thanks!
08:44:32 * quicksilver prefers the form "<<yo dawg>>"
08:44:41 <quicksilver> so I patched my own GHC to do that.
08:44:52 <Cale> haha, awesome
08:46:56 <Cale> waterson: Yeah, it's a bit unfortunate that more information isn't available about *where* the infinite loop is -- sometimes it can be tricky to figure out exactly where it's happening. If you compile with -prof -auto-all and run the program with +RTS -xc, then sometimes you can get a bit more information about where in the program the thing happened.
08:47:22 * waterson gives that a whirl
08:48:24 <carlito> :type [3, []]
08:48:31 <Cale> :t [3,[]]
08:48:33 <lambdabot> forall a. (Num [a]) => [[a]]
08:49:00 <Cale> Num [a] is normally unsatisfied, but you could write an instance
08:49:24 <carlito> It feels not consistent that this fails:
08:49:29 <carlito> let h = [3, []]
08:49:40 <quicksilver> carlito: dreaded monomorphism restriction
08:49:51 <fax> [] + 3 = ?
08:49:57 <fax> [3] obviously :D
08:50:09 <Cale> I wonder if it would be sensible to have a compiler option to use a different black hole for every expression in the program (or maybe just for the expressions in each function), so that <<loop>> errors could be made more informative
08:50:40 <quicksilver> in order to have a useful name you have to have SCCs, surely
08:50:57 <quicksilver> but for the black hole to take the name of the nearest SCC would seem eminently sensible
08:51:03 <Cale> yeah
08:51:42 <Cale> If it were giving every expression its own black hole, then it could just use the source location
08:51:57 <carlito> Thanks for the help !
08:52:15 <Kaidelong> got wxHaskell working on my 32-bit netbook
08:52:19 <siracusa> Cale: when exactly does GHC detect a loop? If I try let f 1 = f 1 in f 1 it doesn't.
08:52:19 <Kaidelong> still broken here
08:52:47 <Cale> siracusa: because that's a different f 1 ;)
08:53:06 <siracusa> Cale: Huh?
08:53:11 <bitstream0101> Cale/quicksilver: well, that wasn't it, still seeing a crash around the same place (still don't know where it's happening though)
08:53:24 <Cale> siracusa: try  let x = x + 1 in x
08:54:15 <Cale> bitstream0101: What is contFoldM?
08:54:30 <bitstream0101> one sec i'll pastebin it
08:54:42 <siracusa> Cale: Hhm, it doesn't print <<loop>> but stops execution
08:54:50 <AxleLonghorn> is it possible to make an Arbitrary instance for a recursive data type (for use in quickcheck)?
08:55:07 <Cale> siracusa: ah, you're using the threaded runtime
08:55:09 <quicksilver> AxleLonghorn: of course
08:55:30 <bitstream0101> Cale: http://haskell.pastebin.com/6h5nvhC1
08:55:36 <quicksilver> AxleLonghorn: it's not generally any different from a non-recursive type in shape, although it will contain a recursive call to 'arbitrary'
08:55:44 <quicksilver> (which makes sense really!)
08:56:04 <AxleLonghorn> quicksilver: do you have a link to any examples? I'm having trouble writing the instance for an AST
08:56:07 <bitstream0101> (drefCont reads data from disk and decodes it)
08:56:11 <Cale> siracusa: The threaded runtime can't know that the value isn't just being evaluated by some other thread and will later become available, and so will instead block, waiting for some other thread to (maybe) finish evaluating the values
08:56:14 <Cale> value*
08:56:44 <bitstream0101> Cale: I'll see if I can narrow down where the problem might be via trace scattering ;)
08:56:58 <Cale> bitstream0101: Well, that looks strict enough
08:57:08 <bitstream0101> Cale: Yeah, I thought so too. =/
08:57:19 <bitstream0101> the accumulator was the only thing that seemed like it might be a problem
08:57:25 <Cale> bitstream0101: Note that if you print the parameters when you add the traces, the problem might go away (in which case you'll know that you've found it)
08:57:36 <bitstream0101> but some back of the envelop math shows like 500ish thunks or so for this problem size
08:57:42 <bitstream0101> Cale: right, exactly
08:59:41 <Cale> Hmm, ghc 6.12.1 seems more resistant to stack overflows than previous GHC versions
09:00:15 <Cale> I was about to say that it's on the order of 1000000 elements or so where you get a stack overflow, but I can't seem to elicit one from ghci now.
09:00:25 <Cale> (just using plain foldl)
09:01:14 <bitstream0101> interesting. yeah, i suspect it'd have to be pretty large -- much larger than it seems like i'd be collecting anywhere
09:01:19 <bitstream0101> (but obviously, i am ;P)
09:01:56 <Cale> It might be that it's doing more strictness analysis than it used to
09:02:01 <Cale> I'm not sure
09:02:09 <quicksilver> I didn't think the bytecode compiler did any strictness analysis
09:02:20 <Cale> I didn't think so either
09:02:31 <Cale> okay, no that's not it
09:03:14 <Cale> heh, it seems to just allocate lots of memory
09:03:29 <Cale> MOAR STACKS OMNOMNOM
09:04:51 <Cale> That's more like what it ought to do. Behave in an idealistic fashion and let the OOM killer sort things out ;)
09:08:23 <EvanR-work> Cale: think more about functional reactive, it seems that for a game, the event handler must be also a function of time. consider a spinning asteroid ship, how it reacts to a keypress depends on when in time you press thrust
09:08:30 <EvanR-work> s/think/thinking/
09:08:39 * hackagebot Raincat 1.1.1.1 - A puzzle game written in Haskell with a cat in lead role  http://hackage.haskell.org/package/Raincat-1.1.1.1 (MikhailPobolovets)
09:09:01 <EvanR-work> im guessing a function from time to event handler wouldnt be inefficient, since it never gets evaluated until an event occurs
09:09:16 <Cale> EvanR-work: read conal's blog :)
09:09:19 <EvanR-work> ah
09:09:28 <EvanR-work> that guy
09:10:22 <jmcarthur> heh
09:10:50 * ManateeLazyCat Stop update gtk2hs now, i make Axel crazy.
09:10:57 <ManateeLazyCat> :)
09:12:22 <waterson> Cale: so, my <<loop>> came from the fact that I had created something that was "instance Num" but was missing a def'n for (-).
09:12:46 <opqdonut> (-) was implemented in terms of negate, and negate in terms of -
09:12:47 <opqdonut> right?
09:12:52 <Cale> waterson: ah, that's an interesting way to get it -- you have to define either (-) or negate
09:12:56 <Cale> yeah
09:12:58 <waterson> right
09:13:15 <EvanR-work> or both
09:13:19 <EvanR-work> non recursively ;)
09:13:41 <waterson> anyway, rookie move. ;
09:13:43 <waterson> ;)
09:13:50 <opqdonut> EvanR-work: well, recursion might work ;)
09:14:26 <opqdonut> a - 0 = a; a - b = succ (a + negate (pred b)); negate b = 0 - b
09:14:32 <opqdonut> or something like that
09:14:53 <Cale> Oh neat, UCBerkeley has their own version of the SICP course on YouTube :)
09:20:36 <ManateeLazyCat> I have udpate Ubuntu 10.04, nice.
09:20:44 <ManateeLazyCat> Which your OS?
09:20:57 <fax> I should try Ubuntu 10.04
09:21:34 <ManateeLazyCat> fax: Just one remember, if you want mount some device when boot, don't use UUID, use device name instead.
09:21:42 <ManateeLazyCat> fax: Otherwise boot failed.
09:22:04 <ManateeLazyCat> fax: It's a bug of mountall, perhaps has fix in today.
09:22:08 <EvanR-work> how to execute shell command in haskell
09:22:19 <ManateeLazyCat> EvanR-work: runProcess.
09:22:22 <ManateeLazyCat> EvanR-work: runCommand
09:22:27 <fax> ManateeLazyCat okay it sounds difficult for me :S
09:22:29 <EvanR-work> thanks
09:23:43 <ManateeLazyCat> fax: I can't login in Ubuntu 10.04 until i use Puppy Linux fix it. :)
09:23:46 <sproingie> i never got the logic of mounting by uuid on simple setups like home pcs or appliance servers
09:24:12 <fax> ManateeLazyCat lol
09:24:24 <fax> ManateeLazyCat if I was in the situation though I would just go "huh!!" and gives up
09:24:33 <ManateeLazyCat> fax: Another tips, Ubuntu 10.04 use Grub2, you need type "Shift" to show Grub2 menu, it's make me crazy yesterday, lucky i have another box.
09:24:56 <quicksilver> sproingie: potentially saves you a nasty surprised if you plug in a new disk.
09:25:11 <quicksilver> sproingie: can even save you a nasty surprise if a kernel upgrade brings up your controllers in a different order
09:25:21 <sproingie> yeah because it reorders them.  which is itself freakin stupid.
09:25:24 <quicksilver> the latter has happened to me
09:25:27 <ManateeLazyCat> fax: I won't give up, because i modified /etc/fstab after i finish all configuration. So i search error
09:25:46 <quicksilver> ManateeLazyCat: you need to change the configuration inside your initrd as well
09:25:54 <EvanR-work> bah
09:25:59 <ManateeLazyCat> quicksilver: What?
09:26:09 <EvanR-work> Ord instance requires Eq, so i cant define the Eq in terms of the Ord comparison
09:26:23 <quicksilver> your initrd also needs correct disk information (assuming ubuntu uses initrds, debian does)
09:26:38 <quicksilver> EvanR-work: I think you can actually
09:26:40 <ManateeLazyCat> EvanR-work: no
09:26:53 <ManateeLazyCat> EvanR-work: instance Eq and instance Ord is separate.
09:27:02 <EvanR-work> class  (Eq a) => Ord a  where ?
09:27:12 * ManateeLazyCat pasted "ord code" at http://paste2.org/get/796939
09:27:14 <quicksilver> EvanR-work: I don't think it matters
09:27:15 <ManateeLazyCat> EvanR-work: Like above
09:27:22 <EvanR-work> oh
09:27:22 <fax> Cale - I think it is impossible to define lazy lambda calculus using evaluation contexts!
09:27:25 <quicksilver> you can still have dependencies betwee the two as far as I know.
09:27:26 <ManateeLazyCat> EvanR-work: Look http://paste2.org/get/796939
09:28:07 <Cale> fax: ?
09:28:24 <ManateeLazyCat> quicksilver: I never change initrd after i install.
09:28:26 <fax> oh I was still thinking about that evaluation
09:28:29 <fax> single step evaluator
09:28:49 <Cale> I think it ought to be possible by using let to represent sharing.
09:29:02 <Cale> But I don't know what you mean by "evaluation contexts"
09:29:49 <EvanR-work> quicksilver: so it just 'figures it out'
09:29:54 <ManateeLazyCat> quicksilver: IMO, if some device name or UUID is wrong, just skip that device and continue, not loop in boot, it make me can't login in.
09:30:07 <fax> Cale, sometimes I saw evaluation order (such as strict) defined by evaluation contexts
09:30:15 <quicksilver> EvanR-work: it doesn't really figure anything out.
09:30:24 <fax> it's like in type systems
09:30:26 <quicksilver> EvanR-work: all haskell definitions are potentially recursive
09:30:37 <EvanR-work> thats what i mean
09:30:56 <EvanR-work> some of the recursive definitions i wrote, i cant image how it works internally ;)
09:31:10 <jmcarthur> @where stg
09:31:10 <lambdabot> http://citeseer.ist.psu.edu/peytonjones92implementing.html
09:31:18 <EvanR-work> some times it seems circular
09:31:19 <jmcarthur> like that
09:31:19 <jmcarthur> roughly
09:31:20 <quicksilver> if you're designing a non-strict evaluator, recursion is basically free
09:31:22 <ManateeLazyCat> EvanR-work: Just write, write, write, you can understand when you write enough. :)
09:31:27 <quicksilver> admittedly compilers are a bit more than evaluators
09:31:40 <quicksilver> but in a non-strict language disallowing recursion would be the more surprising choice
09:31:46 <Cale> fax: Lazy evaluation is outermost-first evaluation, plus an additional optimisation that if a parameter to a function occurs more than once in the body of the function, then the evaluation of that argument is shared between the copies.
09:32:13 <Cale> (which can be syntactically represented using a let expression)
09:32:24 <Cale> I have no idea what an evaluation context is.
09:32:54 * ManateeLazyCat Haskell is my blood now. :)
09:33:00 <fax> what if you have (A and B are complex expressions)  let x = (A,B) in (x,fst x)
09:33:15 <jmcarthur> evaluation context = bound variables?
09:33:16 <fax> does it reduces to ((A,B),A) or let a = A in ((a,B),a)?
09:34:25 <Cale> Has to be something like the latter
09:34:30 <jmcarthur> the former looks like call-by-name, the latter like call-by-need
09:35:01 <Cale> I dislike the call-by-X names for evaluation strategies, because I can never remember what they mean.
09:35:24 <Cale> They seem highly unintuitive to me, anyway.
09:35:34 <jmcarthur> Cale: what do you call call-by-name when constrasting with lazy, then?
09:35:45 <Cale> outermost-first evaluation?
09:35:52 <Cale> (Is that right?)
09:36:08 <jmcarthur> hmm
09:36:14 <Cale> Or normal order evaluation.
09:36:22 <Cale> (which is the same thing)
09:36:30 <jmcarthur> normal order evaluation has two meanings, it seems
09:36:45 <jmcarthur> sometimes people use that to refer to evaluation orders which include evaluation under lambda
09:36:52 <jmcarthur> because it results in normal form
09:37:57 <jmcarthur> but sometimes people don't intend eval under lambda
09:38:07 <Cale> I suppose I tend to separate the idea of whether we're going to evaluate under lambdas from the evaluation order
09:38:19 <jmcarthur> hmm
09:38:40 <quicksilver> I would assume normal order doesn't go under lambdas
09:38:55 <quicksilver> it just 'stops' and 'returns' <lambda>
09:39:03 <quicksilver> but maybe that's not standard.
09:39:33 <jacobian> It's not standard if you need a normal form
09:39:33 <Cale> Well, the name *does* come from the normalisation property that it has when you *do* allow it to evaluate under lambdas
09:40:02 <jacobian> Normalisation by Evaluation requires you descend under lambda.
09:40:24 <jacobian> A bit moot in the context of a non-normalising language like haskell though
09:40:39 <fax> jacobian: wait I don't get what you mean
09:40:43 <fax> why do you have to descend
09:40:50 <fax> is that in the quote step?
09:40:56 <jacobian> normal forms mean that you have canonical terms.
09:40:57 <quicksilver> Cale: I don't understand that.
09:41:08 <quicksilver> Cale: the whole point of normalisation is that it doesn't matter what order you use.
09:41:09 <jacobian> you can't decide of terms are canonical unless you complete evaluation entirely
09:41:25 <quicksilver> so, therefore, why would the normalisation property grant its name to one particular order?
09:41:27 <jacobian> That way you can decide if two terms are equal by comparison (modulo alpha)
09:41:46 <jacobian> Because you get head normal form!
09:41:47 <jmcarthur> quicksilver: normal order guarantees that you reach a normal form. other evaluation orders do not
09:41:52 <Cale> Well, if you don't look inside unapplied lambdas, you can have silly things like (\x -> (\y -> y) x) which is clearly equivalent to (\x -> x), but not the same
09:42:04 <jmcarthur> quicksilver: guarantees that you reach a normal form *if there is one*, i mean
09:42:49 <jmcarthur> although i don't know whether normal order is the only order that has that property
09:42:53 <jmcarthur> that's just how it gets the name
09:42:53 <Cale> Well, that's a little harsh. Normal order isn't the only order which guarantees normalisation.
09:43:14 <jmcarthur> it just gets its name in contrast to other common evaluation orders
09:43:20 <jacobian> if you have a strongly normalising language, call by value should work fine
09:43:26 <Cale> Many others do as well, and innermost-first is even a little uncommon in not having that property.
09:43:47 <jmcarthur> jacobian: really? i thought cbv didn't have that property
09:44:10 <Cale> call-by-value is strict evaluation is innermost first, isn't it?
09:44:11 <jacobian> It might depend on the language, not sure, but I know at least some strongly normalising languages where that is true.
09:44:17 <jmcarthur> Cale: yes
09:44:34 <Cale> Then no, in any Turing complete variant of the lambda calculus, it won't do.
09:44:58 <jmcarthur> jacobian: on you're talking about strongly normalizing languages
09:45:02 <jmcarthur> s/on/oh/
09:45:03 <Cale> strict evaluation is sufficient only if you do something severe to guarantee termination
09:45:08 <jacobian> If the language is strongly normalising, it wont be be turing complete :)
09:45:18 <Cale> yeah
09:45:38 <jmcarthur> jacobian: we're talking about there being *some* normal form, not a normal form for every evaluation order
09:45:44 <fax> jacobian; how did you learn this stuff about NbE/
09:45:45 <fax> ?
09:45:52 <fax> because I didnt' quite get it
09:45:54 <jacobian> I think we have to ask what a normal form is
09:46:05 <fax> can define normal form using evaluation contexts
09:46:06 <jacobian> It's my thesis
09:46:15 <fax> jacobian: is it online ?
09:46:21 <jacobian> Not yet
09:46:23 <fax> aw
09:46:28 <fax> I want to read it ;P
09:46:32 <jacobian> Abel has good stuff on NbE for System-F
09:46:40 <fax> so what exactly are you working on?
09:47:21 <jacobian> NbE style approaches to languages which are not strongly normalising
09:47:27 <fax> oh cool
09:47:29 <jacobian> And looking at NbE for languages with infinite types
09:47:35 <fax> wow infinite types that sounds crazy
09:47:45 <fax> I implemented a haskell style language using nbe
09:47:50 <jacobian> I just mean types which are recursive
09:47:56 <fax> it wasn't that interesting though
09:48:07 <fax> oh
09:48:18 <fax> I thought you mean like coinductive lambda calculus, except types instead of terms
09:48:31 <jacobian> coinductive types
09:48:38 <jacobian> and inductive types
09:48:55 <alexbobp> the haskell wiki page on haskell games has a link to a mario clone in ruby!  http://www.haskell.org/haskellwiki/Applications_and_libraries/Games
09:49:01 <alexbobp> lol
09:49:22 <Cale> alexbobp: huh?
09:49:48 <Cale> oh, weird
09:49:49 <jmcarthur> looks like nario is in ruby
09:50:01 <Cale> It wasn't before.
09:50:05 <Cale> There is a Haskell nario.
09:50:11 <alexbobp> Cale: I want that one then!
09:50:20 <Cale> I wonder where it went.
09:50:23 * alexbobp downloaded nario only to be confronted with scary .rb files
09:50:24 <jmcarthur> http://svn.coderepos.org/share/lang/haskell/nario/
09:50:31 <jacobian> "Mixed Inductive/Coinductive Types and Strong Normalization", "Typed Applicative Structures and Normalization by Evaluation for System $^\omega$" - Andreas Abel
09:50:39 <jacobian> Those should keep you busy fax :)
09:51:16 <alexbobp> thanks jmcarthur
09:51:28 <Cale> I wonder if this Abel is related to *the* Abel (Neils Henrik)
09:51:44 <Cale> Niels, sorry
09:52:05 <jmcarthur> dangit, more papers to read
09:52:25 <jacobian> hehe
09:52:37 <jmcarthur> everytime i say "added to my queue" i feel guilty that i don't actually have a queue that tracking these for me
09:52:59 <jacobian> I use a bibtex file.
09:53:06 <jacobian> With a NOT READ comment
09:53:14 <bremner> org-mode would work
09:53:22 <fax> lol just grep haskell logs
09:53:29 <jmcarthur> haha
09:53:38 <[swift]1> i use Papers for that task
09:53:43 <jmcarthur> grep 'jmcarthur.*added to my queue'
09:54:10 <jacobian> What's "Papers"?
09:54:24 <[swift]1> jacobian: http://mekentosj.com/papers/
09:54:45 <[swift]1> jacobian: great piece of software (if you use os x)
09:57:30 <jacobian> cool
09:58:52 <quicksilver> org-mode suffices though, and if you are using OSX you can drive spotlight from the commandline / elisp / haskell easily enough to search your papers.
09:59:00 <Berengal_> Does ghc 6.12.2 contain the llvm backend?
10:05:11 <jmcarthur> Berengal_: i kind of doubt it
10:09:46 <ddarius> jmcarthur: All I do is put files in a ToRead directory.
10:10:59 * fax tends to read things as I hear about them - doesn't have a big pile of to-read papers
10:11:26 * mux has more papers in his "to-understand" queue rather than in the "to-read" one
10:11:32 <jmcarthur> ddarius: i'd do that except (1) i don't want to have to hunt down a pdf when i'm not even ready to read it yet, and (2) i don't always use the same computer so i'd also have to put the pdfs somewhere shared
10:11:34 <quicksilver> Berengal_: no, but there is a blog post on how to get it working.
10:12:37 <[swift]1> jmcarthur: personally, i find that having the pdf drastically increases the chances that i'll actually read the paper; ymmv
10:13:40 <[swift]1> jmcarthur: for your second problem, mercurial takes care of that pretty well for me =)
10:13:43 <jmcarthur> [swift]1: for me that's only if the pdf has a very descriptive file name
10:14:34 <FunctorSalad> an automatic unlikely-phrase extractor might be handy ;)
10:14:59 <FunctorSalad> disclaimer: missed the context except the last three msg'es excluding mine
10:15:04 <[swift]1> jmcarthur: well Papers gets that metadata for you semiautomatically, but before i used Papers i just renamed the pdf to the full name of the paper
10:15:28 <cjay> Lemmih: I sent you a darcs patch to make the SDL OS X example work
10:16:39 <Lemmih> cjay: Excellent.
10:16:40 <ddarius> jmcarthur: Just keep the directory sorted by date.
10:16:57 <ddarius> (or just give the pdf a descriptive name)
10:16:58 <FunctorSalad> that helps too
10:17:02 <FunctorSalad> (the date)
10:17:16 <wferi> I don't get why cabal install -v --dry-run HDBC-mysql concludes with:
10:17:17 <wferi> HDBC-2.1.0 (reinstall) changes: HUnit-1.2.0.3 removed, QuickCheck-1.2.0.0 removed, testpack-1.0.2 removed, utf8-string-0.3.5 -> 0.3.6
10:17:44 <wferi> even though I hid utf8-string-0.3.6 and the mentioned packages weren't removed.
10:17:55 <jmcarthur> i think the root of my problem is that i'm too lazy
10:18:00 <[swift]1> as an aside, i hate how some research databases call every paper you download "fulltext.pdf" or something similar; it's just unnecessary
10:18:02 <cjay> Lemmih: I'm not sure I did the Makefile the best way, but compiling the C file with ghc saved me from having to specify extra include paths
10:18:09 <jmcarthur> i'll work up the discipline sometime
10:18:23 <wferi> HDBC-2.1.0 is already installed system-wide, it wants to shadow it.
10:18:32 * EvanR-work does a seq on jmcarthur 
10:18:47 <FunctorSalad> [swift]1: down-them-all for firefox lets you put the (defused) url into the filename
10:18:47 <jmcarthur> _|_
10:18:50 <EvanR-work> lol
10:18:50 <FunctorSalad> :)
10:19:09 <[swift]1> FunctorSalad: neat!
10:19:13 <EvanR-work> you have that one planned, didnt you
10:19:29 <jmcarthur> nope
10:19:45 <jmcarthur> i'm just nonterminating
10:19:46 <alexbobp> [swift]1: unnecessary?  It's lazy...
10:19:59 <alexbobp> [swift]1: it just means they didn't bother to send the filename in php or whatever
10:20:10 <[swift]1> alexbobp: yeah, that's what i was getting at =)
10:20:13 <FunctorSalad> so is it a middle finger or a bottom? analogy confusion
10:20:25 <jmcarthur> FunctorSalad: yes
10:20:36 <mux> mmm, I feel very bad for asking, but does someone have a PDF version of ATTAPL?
10:20:56 <FunctorSalad> jmcarthur: I see what you did there ;)
10:21:23 <jmcarthur> mux: can't get a dead tree version?
10:21:49 <Amagineer> Hey, I'm trying to set up a portable Haskell Package for windows
10:21:54 <jmcarthur> mux: the dead tree version is a nice hardback and looks good on a bookshelf with other techie books
10:21:59 <Amagineer> Is there any way to ease this for me?
10:21:59 <mux> jmcarthur: I'm considering buying it soon, but I like to have a PDF first (I have a paper version of TAPL that I bought after making sure it was for me)
10:22:14 <jmcarthur> mux: if you like tapl you'd like attapl
10:22:19 <jmcarthur> i have both
10:22:26 <Amagineer> I can't seem to find a way to convince cabal to use a different config
10:22:29 <mux> I actually know I'd like it, I had a pdf version of it but lost it :-)
10:22:43 <jmcarthur> then why another pdf?
10:22:44 <mux> I wanted to take a quick look again, because the last time it was slighty too hardcore for me
10:23:02 <jmcarthur> it's not really any more hardcore than tapl. it just covers additional topics, is all
10:23:26 <[swift]1> wish i had a PDF version of TAPL, and the rest of my CS books
10:23:27 <Philonous1> mux: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.65.1947&rep=rep1&type=pdf
10:23:30 <mux> well I found it much harder, I went through TAPL very easily, but dependent typing etc still hurts me
10:23:31 <[swift]1> my bookshelves are getting full
10:23:51 <mux> Philonous1: oh thanks!
10:23:55 <fax> mux if you've done tapl you'll have no trouble with dependent types
10:24:03 <mux> well I had :D
10:24:27 <mux> it's time to give it another shot and I'll buy it then
10:24:40 <jmcarthur> ah that's just a sample. i was wondering why a whole book like that would be on citeseer
10:24:50 <mux> it is? damn.
10:24:57 <mux> indeed.
10:25:02 <jmcarthur> yeah i'd like pdfs of them as well even though i have dead tree versions
10:25:27 <jmcarthur> really though, a sample should be enough to determine whether you want to buy it anyway
10:25:35 <sbahra> Unfortunately, gigapedia.org is down. You might want to check there once it's back up, mux.
10:26:14 <sbahra> Though, the book might be in DJVU or chm format.
10:26:18 <luite> Philonous1: ooh tnx
10:26:33 <Philonous1> luite: It appears to be just a sample
10:26:57 <luite> hmm, I see, 84 pages
10:27:03 <[swift]1> i would freely rebuy all of my dead tree books in pdf form if they would just sell them to me that way
10:28:21 <mux> sbahra: ok thanks.
10:30:45 <EvanR-work> gah.
10:30:53 <EvanR-work> shuffle doesnt work with Monad.Random
10:30:57 <jmcarthur> i would not rebuy them. i just want them to be free since i already bought the books
10:31:02 <fax> EvanR why do you need shuffle
10:31:14 <fax> are you still working on drop n random
10:31:20 <EvanR-work> i just started
10:31:28 <fax> what about the suggestion I gave?
10:31:37 <EvanR-work> i have it in front of me from the history, but i dont understand it
10:31:44 <EvanR-work> and im on the clock ;)
10:32:03 <jmcarthur> haskell at work?
10:32:04 <EvanR-work> let me reexplain
10:32:07 <EvanR-work> yeah
10:32:11 <jmcarthur> where?
10:32:13 <[swift]1> jmcarthur: i would certainly _prefer_ not to rebuy them, but even having the option of rebuying them would be an improvement over the current situation
10:32:13 <jmcarthur> doing what?
10:32:25 <jmcarthur> [swift]1: agreed, but that alone wouldn'
10:32:27 <jmcarthur> grr
10:32:31 <EvanR-work> pick ls n :: [a] -> Int -> [a]
10:32:36 <EvanR-work> pick random n things from ls
10:32:39 <jmcarthur> [swift]1: wouldn't convince me to rebuy them
10:32:40 <fax> yeah I already wrote that function man
10:33:03 <[swift]1> jmcarthur: it would for me, because my bookshelves are basically full and i need to free up space for more books =)
10:33:49 <EvanR-work> fax: probably, though backwards
10:33:59 <fax> no
10:34:12 <EvanR-work> it drops n random
10:34:21 <EvanR-work> so picks length - n
10:34:33 <EvanR-work> ill paste it
10:34:42 <EvanR-work> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25068
10:34:57 <EvanR-work> are you sure this works?
10:35:01 <EvanR-work> and the patterns are right
10:35:12 <jmcarthur> [swift]1: get more bookshelves ;) bookshelves are relaxing to be around
10:35:15 <fax> EvanR, there's no reason to ask me if it works: I told you a correctness proof
10:36:18 <EvanR-work> ok, so yuo cant explain it easily ;)
10:38:49 <alexbobp> man, the guy who made monadius is real cool
10:38:57 <alexbobp> he made a fully automatic book scanner with lego mindstorms XD
10:41:13 <EvanR-work> fax: im confused about the bit where it decrements length, or not
10:41:40 <fax> EvanR-work: I don't know what you mean
10:41:41 <EvanR-work> erm, it always decrements length.
10:41:46 <EvanR-work> but it decrements n or not
10:41:58 <fax> EvanR-work: Do you know what n means
10:42:07 <EvanR-work> number dropped so far
10:42:09 <EvanR-work> er
10:42:14 <EvanR-work> n_0 - dropped so far
10:42:21 <fax> no
10:43:11 <zygoloid> fax: "i have only proved it correct, not tested it" ;)
10:43:30 <EvanR-work> "i have claimed a proof exists"
10:43:43 <EvanR-work> but its too big to put in the small margin ;)
10:43:43 <fax> I'm a bit less experienced, so I think proofs actually imply the thing works :p
10:44:00 <fax> EvanR-work: I wrote out the proof when I showed you this algorithm -- I didn't just claim to have one
10:44:27 <EvanR-work> i dont recall that
10:45:14 <EvanR-work> n is number left to drop, length is elements left before the end
10:47:41 <EvanR-work> is it uniformly distributed?
10:47:50 <EvanR-work> are all results equally likely
10:48:09 <EvanR-work> because i distinctly remember forgetting to restrict the algorithm to that ;)
10:49:04 <zygoloid> EvanR-work: well, do i have a bridge for YOU!
10:49:21 <EvanR-work> ?
10:49:33 <zygoloid> dropRandomly = drop :)
10:49:43 <zygoloid> it's not uniform, but...
10:50:01 <EvanR-work> haha
10:50:11 <EvanR-work> it produces one result 100% the others zero ;)
10:50:27 <zygoloid> so, with one exception, it's uniform!
10:50:35 <fax> 17:47 < EvanR-work> because i distinctly remember forgetting to restrict the algorithm to that ;)
10:50:38 <fax> what?
10:50:59 <EvanR-work> scroll up to the question, not my subsequent remarks
10:51:15 <fax> I think you are misremembering something
10:51:18 <Berengal_> "If you're feeling really paranoid, the -dcore-lint option is a good choice. It turns on heavyweight intra-pass sanity-checking within GHC. (It checks GHC's sanity, not yours.)"
10:51:47 <EvanR-work> does it produce all possible results with equal chance
10:58:27 <fax> EvanR-work have you ever seen these before http://media.texample.net/tikz/examples/PNG/probability-tree.png ?
10:58:55 <EvanR-work> i vaguely remember this from math class
10:59:10 <fax> just aply this idea to the case branch of this code
10:59:35 <EvanR-work> ok
11:00:09 <EvanR-work> the probability of p1 AND p2 is p1 * p2
11:00:11 <tab> ../
11:03:42 <dons> jlouis: great post, again, btw. rereading it a 3rd time and still find good stuff.
11:07:53 <alpounet> which one ?
11:09:10 <jlouis> dons: thanks! I took some hours to write so it is appreciated
11:09:38 * jmcarthur wonders what jlouis wrote
11:09:45 <[swift]1> it's not "haskell vs. erlang for bittorrent clients", is it?
11:09:55 <[swift]1> just saw that on HN
11:09:59 <jmcarthur> ah!
11:10:01 <jlouis> that one, yes
11:10:15 <[swift]1> jlouis: cool! reading now
11:10:42 <alpounet> same here
11:16:51 <fax> > sin (1/55555555555555) :: CReal
11:16:52 <lambdabot>   0.00000000000001800000000000018
11:17:06 <fax> I was lied to :(
11:17:32 <fax> > sin (1/55555555555555 * (180/pi)) :: CReal
11:17:33 <lambdabot>   0.0000000000010313240312354920890226789587
11:17:47 <fax> > sin (1/55555555555555 * (pi/180)) :: CReal
11:17:48 <lambdabot>   0.0000000000000003141592653589824654389179
11:17:56 <fax> > sin (1/55555555555555555555555555555555555555555555555555 * (pi/180)) :: CReal
11:17:56 <lambdabot>   0.0
11:18:03 <fax> roconnor?
11:20:36 <Itkovian> dons: Have you pondered my proposal yet?
11:26:31 <jmcarthur> dang. i'm getting all wrapped up in making a game in haskell and all this webgl stuff is catching my eye now
11:26:56 <fax> IGNORE IT...
11:27:17 <jmcarthur> but webgl would be an awesomely convenient way for people to play my games
11:27:23 <fax> URgh
11:27:33 <fax> the last thing i want is something like flash except 3D
11:27:47 <jmcarthur> it's not really like flash
11:28:41 <jmcarthur> or at least it doesn't *feel* like flash to me
11:30:07 <fax> @oies 2,12,120,252
11:30:07 <lambdabot>  Sequence not found.
11:30:10 <fax> D:
11:30:16 <fax> I tohught oies knew everything
11:30:28 <fax> hrm that's disappointing
11:30:32 <Niccus> I thought it was oeis
11:30:42 <fax> @oies 12,120,252
11:30:42 <lambdabot>  Denominator of Bernoulli(2n)/2n.
11:30:42 <lambdabot>  [12,120,252,240,132,32760,12,8160,14364,6600,276,65520,12,3480,85932,16320,1...
11:30:50 <fax> ah it was my fault. as usual
11:41:07 <koeien37> why is the ghc package hidden by default?
11:43:16 <Berengal_> koeien37: Probably because using it is non-portable and maybe not such a good idea.
11:43:56 <c_wraith> Is there an API in ghc for talking to the garbage collector?
11:43:58 <koeien37> why wouldn't it be a good idea? (well, obviously not if you want to write portable Haskell 2010)
11:44:21 <Berengal> I don't know. I said maybe :P
11:44:27 <Makoryu> Since when is Haskell 2010 a standard? D:
11:44:36 <c_wraith> I really want to extend vacuum with the ability to show references in the closures being held by unevaluated thunks.
11:45:45 <c_wraith> Or in lambdas, for that matter.  Though the ones being held in unevaluated thunks are more interesting from a space leak perspective.
11:46:03 <jmcarthur> c_wraith: yeah that would be nice
11:47:27 <Berengal> c_wraith: Going by the track record of vacuum, there's no library for that and you have to poke the bytes yourself.
11:51:00 <fax> @let f a b c x = sum . map (\n -> (a n * b n * x ^ n) / (c n * let factorial n = product [1..n] in factorial n)) $ [1..500]
11:51:01 <lambdabot>  Defined.
11:51:32 <c_wraith> @ty f
11:51:33 <lambdabot>     Ambiguous occurrence `f'
11:51:33 <lambdabot>     It could refer to either `L.f', defined at <local>:14:0
11:51:33 <lambdabot>                           or `SimpleReflect.f', imported from SimpleReflect at State/L.hs:74:0-32
11:51:54 <fax> @let hypergeometric a b c x = sum . map (\n -> (a n * b n * x ^ n) / (c n * let factorial n = product [1..n] in factorial n)) $ [1..500]
11:51:55 <lambdabot>  Defined.
11:52:47 <fax> > let alpha a 0 = 1 ; alpha a n = (a+n-1)*alpha a (n-1) in (hypergeometric (alpha (1/12)) (alpha (5/12)) (alpha (1/2)) (1323/1331), 3/4 * 11**(1/4))
11:52:48 <lambdabot>   Ambiguous type variable `t' in the constraints:
11:52:48 <lambdabot>    `GHC.Real.Integral t'
11:52:48 <lambdabot>   ...
11:54:10 * hackagebot X11-xshape 0.1.1 - A binding to the Xshape X11 extension library  http://hackage.haskell.org/package/X11-xshape-0.1.1 (EwanHiggs)
11:54:20 <rovar> hey all,  I've got a dependencies issue I haven't figured out how to solve..
11:54:51 <aavogt> just ask
11:55:16 <rovar> 6.10.4  -> template_haskell 2.3.0.1    however  syb-with-class 0.6.1 -> template_haskell 2.4*
11:56:04 <rovar> if I try to unregister syb, it will break a whole lot of stuff..
11:56:05 <MadHatterDude> Is there a "link with these libraries" pragma for haskell?
11:56:13 * hackagebot X11-xdamage 0.1.1 - A binding to the Xdamage X11 extension library  http://hackage.haskell.org/package/X11-xdamage-0.1.1 (EwanHiggs)
11:56:22 <rovar> hiding it doesn't seem to work... btw.. i"m attempting to install yesod
11:56:51 <c_wraith> rovar: explicitly tell cabal to use syb-with-class 0.6
11:57:07 <c_wraith> (at least, I think that's the version that works with ghc 6.10.*)
11:57:52 <rovar> errm.. does syb-with-class normally require 6.12.*?
11:58:19 <rovar> syb-with-class-0.6.1 requires template-haskell ==2.4.*
11:58:27 <c_wraith> syb-with-class depends on template haskell
11:58:30 <rovar> which seems to be beyond 6.10.
11:58:33 <c_wraith> and template haskell can't be upgraded
11:58:46 <MadHatterDude> Is there a link pragma for ghc?
11:58:48 <c_wraith> so you need the one that depends on the version of template haskell in ghc 6.10
11:58:50 <rovar> so I need to tell it to use an older syb than 0.6.1
11:59:14 <c_wraith> yes.  You can check dependencies on hackage, but I think 0.6 works
11:59:29 <rovar> that appears to be 0.6.0, yes
12:00:14 <fax> tensorpudding?
12:00:16 <c_wraith> yeah, this is an unfortunate situation that's come about because cabal-install's solver doesn't know that it can't upgrade template haskell
12:02:05 <zygoloid> huh, good math bad math had another go at fingertrees, and nearly got it right this time :)
12:02:51 <rovar> wow.. my repos are seriously hosed
12:03:25 <rovar> apparently upgrading from 6.10.3 to 6.12 then back down to 6.10.4 is not a smooth transition :)
12:04:04 <c_wraith> err.  yeah.  you need to delete ~/.ghc and ~/.cabal for those to go cleanly :)
12:05:04 <ickabob> I'm extreamly confused about the use of functional data structures, because they are persistant and not ephermeral (got those terms from okazaki).  When calling insert on say a heap structure, i'm returned the heap with the new element properly placed, however the issue I apparnently am unable to resolve is the course of action to take if i want to make multiple inserts to the heap structure.  Is this solved by using the strcture as say a functor
12:05:06 <ickabob> or another higher order function?
12:05:16 * hackagebot th-kinds 0.1.0 - Automated kind inference in Template Haskell.  http://hackage.haskell.org/package/th-kinds-0.1.0 (LouisWasserman)
12:05:54 <opqdonut> ickabob: you just perform the insert on the just-returned structure
12:06:10 <ickabob> implying sometype of state tracking mechanism.
12:06:19 <c_wraith> you don't need state tracking.
12:06:31 <c_wraith> or at least, not in a mutable sense.
12:06:36 <opqdonut> > let ins=Data.Set.insert in ins 1 $ ins 2 $ ins 3 $ Data.Set.empty
12:06:37 <lambdabot>   Not in scope: `Data.Set.insert'Not in scope: `Data.Set.empty'
12:06:38 <aavogt> @type foldr (uncurry M.insert)
12:06:39 <lambdabot> forall a b. (Ord a) => M.Map a b -> [(a, b)] -> M.Map a b
12:06:40 <opqdonut> gah
12:06:44 <ickabob> hmmm
12:06:50 <c_wraith> wouldn't you want foldl?
12:07:07 <aavogt> maybe, that involves more flipping
12:07:17 * hackagebot th-kinds 0.1.1 - Automated kind inference in Template Haskell.  http://hackage.haskell.org/package/th-kinds-0.1.1 (LouisWasserman)
12:07:24 <c_wraith> but it fits the pattern better: multiple operations on an accumulator
12:07:30 <ickabob> i've been trying to wrap my head around folding up a structure for the last week and a half
12:07:51 <c_wraith> actually, we're just talking about folding a list
12:07:58 <Berengal> > S.insert 1 . S.insert 2 . S.insert 3 $ S.empty
12:07:59 <lambdabot>   fromList [1,2,3]
12:08:10 <opqdonut> there
12:08:18 <c_wraith> fold the list of things to insert, with the insert operation, from the starting state.
12:08:43 <Berengal> > foldr S.insert S.empty [1,2,3,4,3,2,1]
12:08:44 <lambdabot>   fromList [1,2,3,4]
12:09:09 <Berengal> > S.insert 1 (S.insert 2 (S.insert 3 S.empty))
12:09:10 <lambdabot>   fromList [1,2,3]
12:09:29 <Berengal> There are all, in a sense, equivalent ways of saying the same thing
12:10:13 <ickabob> hmm i guess lemme try to throw together a testcase, the idea makes sense to me but i've been unable to ever get anything to work.
12:10:35 <aavogt> lowasser: so th-kinds needs such a narrow range of template-haskell because of "Note: There has been a bug observed in Template Haskell relating to the parsing of types. This assumes that bug is still present, and fixes it."
12:10:54 <lowasser> aavogt: The thing is, that bug was just fixed in GHC 6.12.2
12:11:11 <lowasser> (mostly because I submitted a bug report =P)
12:11:49 <Berengal> public Set<Integer> immutableSetInsert(){Set<Integer> e = Set.empty(), set0, set1, set2; set0 = Set.insert(1, e); set1 = Set.insert(2, set0); set2 = Set.insert(3, set1); return set2;}
12:12:02 <lowasser> but yes, essentially
12:12:18 * hackagebot iso3166-country-codes 0.20090527.1 - A datatype for ISO 3166 country codes  http://hackage.haskell.org/package/iso3166-country-codes-0.20090527.1 (JonFairbairn)
12:12:44 <aavogt> hmm, it might be better to accept some kind of range though ex. template-haskell >= 2.4.0.1
12:13:15 <lowasser> yah, probably
12:13:26 <MadHatterDude> god damnit...
12:15:12 <zygoloid> > let s = S.empty; s1 = S.insert 1 s; s2 = S.insert 2 s; s12 = S.insert 2 s1  in  (s, s1, s2, s12)
12:15:14 <lambdabot>   (fromList [],fromList [1],fromList [2],fromList [1,2])
12:15:34 <aavogt> that's looks easy to mess up
12:15:34 * ologNation is still thinking about DrIFT and XmlContent
12:18:12 <zygoloid> > let runSet = flip runState S.empty; ins = modify . S.insert; has = gets . S.member  in  runSet $ do ins 1; ins 2; b1 <- has 2; b2 <- has 5; return (b1, b2)
12:18:13 <lambdabot>   ((True,False),fromList [1,2])
12:20:19 <EvanR-work> annoying
12:20:27 <EvanR-work> you cant use the letter l as a variable because it looks like 1 ;)
12:20:37 <aavogt> depends on the font
12:20:50 <EvanR-work> in C i used L
12:20:57 <EvanR-work> but nooooo
12:21:03 <aavogt> > case 2 of l -> 1
12:21:04 <lambdabot>   1
12:21:14 <zygoloid> > let (^) = (map chr .) . zipWith (xor `on` ord) in  "win" ^ "die"
12:21:16 <lambdabot>   "\DC3\NUL\v"
12:21:39 <MadHatterDude> What is that new GHC ": panic! (the 'impossible' happened)" thing?
12:22:38 <aavogt> it means you have a bug or you're doing something wrong for which there is no nice error message
12:22:46 <aavogt> a bug in ghc
12:22:52 <MadHatterDude> ... Huh?
12:23:18 <aavogt> ex. if you mess up writing LANGUAGE pragmas, I think ghc tended to mess up like that
12:23:38 <aavogt> I'm not sure if that has since been given a better error message
12:23:57 <MadHatterDude> aavogt: It was a LANGUAGE...
12:28:30 <MadHatterDude> Goddamn "noooo, I can't use polymorphism the way you want it" bullshit that GHC pulls on me sometimes.
12:28:52 <MadHatterDude> I wish you could dope slap computer programs...
12:29:22 <thaostra> i'm sure they are writing code to achieve that <_<
12:29:24 <fax> MadHatterDude: what's wrong?
12:29:37 <MadHatterDude> fax: A sec, I'll bin it
12:29:46 <pastorn> MadHatterDude:
12:29:48 <pastorn> @hpaste
12:29:49 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
12:29:58 <pastorn> cause in #haskell, we're cool like that
12:30:26 <thaostra> i'm sure
12:30:43 <EvanR-work> @hoogle <$>
12:30:43 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
12:32:34 <MadHatterDude> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25145#a25145
12:32:53 <MadHatterDude> fax: I've included the error messages
12:33:43 <pastorn> MadHatterDude: why do you have typeclass restrictions in you newtype
12:33:47 <pastorn> seems silly :p
12:34:37 <MadHatterDude> Pastorn: To get the generality I want.
12:35:09 <pastorn> MadHatterDude: that generality should probably be in the function types, not in the datatype
12:35:09 <MadHatterDude> pastorn: The whole point is that you will be able to not only parse strings, but that I will generalize it to a category/arrow
12:35:35 <pastorn> and on line 19 and 20 you use >>= in the definition of >>= (by using do)
12:35:39 <pastorn> you should write that as
12:35:53 <pastorn> let (x,r) = runParser p s in runParser (f x) r
12:36:12 <pastorn> see, what you have there is a use of >>= before even declaring it :p
12:36:16 <MadHatterDude> pastorn: its a Just (a, b), not (a, b)
12:36:28 <MadHatterDude> pastorn: A monad in a monad, mind you
12:36:35 <pastorn> oh, heh
12:37:12 <MadHatterDude> pastorn: And about my restrictions on the function type, it is so that you can have your monadic cake and eat it with an arrow.
12:37:37 <fax> why
12:37:38 <fax> (<|>) :: Parser a b -> Parser a b -> Parser a b
12:37:39 <fax> rather than
12:37:47 <MadHatterDude> pastorn: eg. apply TokenConstructor (many "Hello") >>> parseSomeGrammar
12:37:53 <fax> (<|>) :: (Parseable a, Parseable b) => Parser a b -> Parser a b -> Parser a b
12:37:53 <fax> ?
12:38:07 <MadHatterDude> fax: You're ringht, maybe...
12:38:51 <fax> Parser $ \s -> runParser p s `mplus` runParser q s
12:38:55 <fax> this is a 'pattern'
12:39:15 <fax> if we have an isomorphism between types - it seems silly to have to keep writing out these patterns
12:39:26 <MadHatterDude> fax: ?
12:39:42 <fax> this isn't specific to your code
12:39:43 <MadHatterDude> fax: Can you elaborate?
12:39:50 <MadHatterDude> fax: How?
12:39:59 <MadHatterDude> It works?
12:40:01 <fax> everyone has written this pattern
12:40:09 <MadHatterDude> So? :P
12:40:18 <MadHatterDude> I write what I want to...
12:40:49 <fax> but nobody, to my knowledge, has solved the general problem
12:41:24 <MadHatterDude> Which is?
12:41:31 <fax> isomorphism between types
12:41:38 <MadHatterDude> ...
12:41:51 <MadHatterDude> Can you link me to some articles on this?
12:42:06 <fax> no there aren't any
12:42:19 <MadHatterDude> I have trouble just understanding "isomorphism = bad" or what it is you postulate.
12:42:24 <jamwt> ~
12:42:34 <fax> no that's not what I meant
12:42:40 <aavogt> then why aren't your isomorphic types the same type?
12:43:40 <MadHatterDude> aavogt, fax: I have no fricking idea what you guys are saying, I am really trying hard to understand.
12:43:43 <ickabob> would somone help me in understanding why this test case wont work?
12:43:45 <ickabob> http://codepad.org/cnkFsJhb
12:44:02 <gwern> @remember jlouis Autotools is the Maven of C programming.
12:44:02 <lambdabot> It is forever etched in my memory.
12:44:28 <gwern> @flish
12:44:38 <aavogt> I don't know what your problem is
12:44:53 <gwern> I can't spell :(
12:44:54 * aavogt reads the scrollback
12:45:22 <Botje> ickabob: uh, your splayheap type only has an E and a T constructor ..
12:45:23 <sbasuita> would it be inefficient to do something like: length (nub list)?
12:45:40 <gwern> @src nub
12:45:40 <lambdabot> nub = nubBy (==)
12:45:41 <MadHatterDude> ickabob: Isn't it a Splay tree, rather than a heap?
12:45:42 <mauke> sbasuita: yes
12:45:43 <gwern> @src nubBy
12:45:43 <lambdabot> nubBy eq []             =  []
12:45:44 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
12:45:56 <sbasuita> thought so
12:46:04 <sbasuita> odd that there isn't a library function to just count the duplicates
12:46:05 <EvanR-work> hey splay, what you do today
12:46:07 <Botje> ickabob: did you mean makeLeaf k = T E k E ?
12:46:12 <aavogt> MadHatterDude: do you know -XExistentialQuantification?
12:46:19 <gwern> sbasuita: how often does one really need that?
12:46:25 <MadHatterDude> aavogt: A little...
12:46:44 <MadHatterDude> aavogt: Something to do with forall, right?
12:46:56 <aavogt> yes
12:46:58 <EvanR-work> sbasuita: countDups ls = (length ls) - (length . nub $ ls)
12:47:06 <ickabob> Botje: yes i did, i did without even realizing it.  Time to ttake a step away from the code and pull it together. Thanks
12:47:23 <MadHatterDude> aavogt: How does it help me?
12:47:31 <benmachine> :t ((-) `on` length) `ap` nub
12:47:32 <lambdabot> forall a. (Eq a) => [a] -> Int
12:47:38 <benmachine> >_>
12:47:43 <sbasuita> EvanR-work: oops, i meant to say i wanted to count the number of unique elements
12:47:48 <sbasuita> rather than count the duplicates
12:47:55 <sbasuita> but cheers
12:47:59 <benmachine> sbasuita: Data.Set is probably the fastest way, if they're orderable
12:48:02 <gwern> > nub [1,2,2,1]
12:48:04 <lambdabot>   [1,2]
12:48:30 <gwern> benmachine: what would that be, Set.size . Set.fromList?
12:48:35 <benmachine> gwern: yep
12:48:44 <benmachine> wouldn't it?
12:48:53 <gwern> hm. fromList is... O(n)?
12:49:02 <gwern> guess one can't do better than that
12:49:03 <ologNation> I wrote
12:49:05 <ologNation> data NodeIndex = NI Int deriving(Show,Eq,Ord)
12:49:05 <ologNation>       {-! derive : XmlContent !-}	-- this line is for DrIFT
12:49:07 <ologNation> But got an error
12:49:14 <ologNation> from DrIFT because
12:49:25 <ologNation> Int itself does not derive XmlContent.
12:49:42 <gwern> oh, it's n*log n http://hackage.haskell.org/packages/archive/containers/0.3.0.0/doc/html/Data-Set.html#v%3AfromList
12:49:49 <ologNation> Can anyone guess how to tell DrIft to tell Int to derive XmlContent?
12:49:53 <gwern> that makes sense. it's probably storing in a tree
12:49:58 <MadHatterDude> gwern: fromListAsc is O(n)
12:50:09 <benmachine> fromAscList is O(n) but it's probably not an asc list :P
12:50:23 <benmachine> you could sort it first but the set API basically just does that for you but simpler
12:50:38 <gwern> MadHatterDude: if he has an ascending/sorted list, then he can just hand-write an consecutive-nub and keep an accumulator for o(n)
12:51:19 <ologNation> error: No instance for (XmlContent Int)
12:51:41 <benmachine> or sum . map head . group
12:51:46 <benmachine> er not sum
12:51:47 <benmachine> length
12:52:00 <aavogt> @type (>>)
12:52:02 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
12:52:26 <gwern> @src group
12:52:27 <lambdabot> group = groupBy (==)
12:52:28 <aavogt> MadHatterDude: you're writing an implementation for (>>) whose type is   m a -> m a -> m a
12:52:30 <gwern> @src groupBy
12:52:31 <lambdabot> groupBy _  []       =  []
12:52:31 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
12:52:31 <lambdabot>     where (ys,zs) = span (eq x) xs
12:52:44 <gwern> benmachine: I'd wonder about the complexity of groupBy
12:52:54 <benmachine> would you indeed?
12:52:59 * gwern would
12:53:02 <benmachine> looks pretty n to me
12:53:34 <aavogt> MadHatterDude: I suspect that you might be breaking laws by writing a  >>  that runs the second argument with different input than >>=
12:53:35 <gwern> I wonder specifically about span; might that not traverse the whole list?
12:53:48 <benmachine> no
12:53:50 <opqdonut> but it only continues traversing where span left off
12:54:01 <benmachine> span only needs to go until the predicate is false
12:54:02 <benmachine> @src span
12:54:03 <lambdabot> Source not found. The more you drive -- the dumber you get.
12:54:05 <opqdonut> > group [1,2,1,2,1,1,1,2,2,2,1,2,1]
12:54:06 <lambdabot>   [[1],[2],[1],[2],[1,1,1],[2,2,2],[1],[2],[1]]
12:54:07 <benmachine> hmph
12:54:13 <opqdonut> it only groups consecutive entries
12:54:22 <benmachine> fst $ span (== 4) [4,4,4,7,undefined]
12:54:26 <benmachine> > fst $ span (== 4) [4,4,4,7,undefined]
12:54:28 <lambdabot>   [4,4,4]
12:55:22 <EvanR-work> fax: having a hell of a time getting your function to work, either it has non exhaustive pattern match or i dont understand the inputs. evalRand (dropr 2 [1,2,3,4,5] 5) (mkStdGen 0)
12:55:56 <fax> EvanR-work: why doesn't that work ?
12:56:09 <EvanR-work> Non-exhaustive patterns in function dropr
12:56:15 <sbasuita> so er
12:56:26 <fax> EvanR, what's you implementation of roll?
12:56:28 <fax> or whatever it is
12:56:30 <sbasuita> consensus on most efficient way to count unique elements?
12:56:59 <EvanR-work> roll p = do x <- getRandom; if x < p then return False else return True
12:57:20 <EvanR-work> is that backwards
12:57:23 <fax> I think that's the problem
12:57:42 <fax> roll p should be True with probability p, False with probability 1-p
12:57:57 <mauke> sbasuita: does it matter?
12:58:03 <opqdonut> sbasuita: roll the elements into a Set, get size
12:58:12 <sbasuita> ok
12:58:13 <opqdonut> you have to go nlogn anyway in the general case
12:58:20 <EvanR-work> fax: seems to work now
12:58:29 <sbasuita> thanks guys
12:58:33 <opqdonut> length . group . sort is not bad either
12:58:38 <mauke> for Int, IntSet might be faster
12:58:53 <sbasuita> they'll be integers < 10
12:58:58 <EvanR-work> fax: what book is this algorithm from, btw?
12:59:05 <opqdonut> IntSet'll do the trick
12:59:07 <mauke> sbasuita: how many of them?
12:59:13 <fax> EvanR-work: I just made it up
12:59:19 <tensorpudding> @type getRandom
12:59:21 <lambdabot> forall (m :: * -> *) a. (MonadRandom m, Random a) => m a
12:59:22 <EvanR-work> oh ._.
12:59:37 <sbasuita> mauke: 6
12:59:45 <sbasuita> mauke: (this is a maths problem, not an engineering one)
12:59:56 <opqdonut> if there
12:59:57 <mauke> sbasuita: who the hell cares which is more efficient
13:00:06 <opqdonut> 's six of them, efficiency hardly matters :)
13:00:12 <tensorpudding> roll p = liftM (>= p) getRandom is a bit nicer looking
13:00:15 <mauke> it's less than a thousand elements
13:00:19 <mauke> you won't even notice the difference
13:00:28 <sbasuita> right, but 6 six an arbtrary value
13:00:30 <sbasuita> it could be 6,000
13:00:33 <aavogt> it will _feel_ faster
13:00:49 <mauke> sbasuita: call me when it becomes the bottleneck of your program
13:01:26 <EvanR-work> tensorpudding: :o
13:01:43 <EvanR-work> tensorpudding: btw, >= ?
13:02:03 <EvanR-work> wont that sometimes give roll 0 => True
13:02:20 <tensorpudding> you have it so that you want x < p returns False right?
13:02:21 <fax> does getRandom return a value in [0,1]
13:02:36 <tensorpudding> i don't actually know what getRandom does
13:02:44 <EvanR-work> checking
13:02:47 <EvanR-work> random instance of Double
13:02:51 <sbasuita> mauke: it is the bottleneck
13:02:56 <Athas> What are the requirements/recommendations for when a chunk of code should go on Hackage?
13:03:08 <mauke> sbasuita: how are you doing it currently?
13:03:08 <tensorpudding> x >= p returns false when x is strictly less than p, true otherwise, like what you wrote
13:03:09 <Athas> I've written a completely non-library end-user-program.  Does that go on Hackage?
13:03:13 <EvanR-work> For fractional types, the range is normally the semi-closed interval [0,1).
13:03:40 <sbasuita> mauke: i haven't written it yet
13:03:40 <fax> that shoudl be fine
13:03:41 <aavogt> everything may go on hackage, provided it is packaged with cabal
13:03:50 <mauke> sbasuita: then it's not a performance bottleneck
13:04:42 <EvanR-work> ah
13:04:44 <EvanR-work> mm
13:05:00 <tensorpudding> alternatively, roll p = getRandom >>= not . (< p)
13:05:12 <ologNation> I pasted some code here:
13:05:13 <tensorpudding> more idiomatic to what you wrote
13:05:13 <ologNation> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25079#a25079
13:05:25 <EvanR-work> so liftM (>= is right?
13:05:38 <ologNation> The idea is that those comments (saying "derive XmlContent")
13:05:46 <ologNation> are messages to the DrIFT preprocessor.
13:05:50 <ologNation> I've got a very basic hang up though.
13:05:51 <EvanR-work> 0 >= 0, true, => False
13:05:52 <EvanR-work> ok
13:05:55 <ologNation> I don't know how to derive basic types.
13:05:59 <ologNation> Like Int, for example.
13:06:58 <EvanR-work> tensorpudding: getRandom >>= return . not . (< p) ?
13:07:50 <fax> maybe we could have some probability monad
13:08:08 <fax> roll p = [ True `with` p, False `with` 1-p ]
13:08:11 <EvanR-work> true false all over the place ;)
13:08:27 <fax> so it's like list monad but it collects up the probabilities
13:08:37 <fax> then you can just compute one random number at the very end
13:08:57 <absentia> orbitz invasion
13:09:02 <jmcarthur> there is a package for that
13:09:15 <jmcarthur> coincidentally i was just looking at it before i peeked at irc
13:09:28 <jmcarthur> http://hackage.haskell.org/package/ProbabilityMonads
13:09:33 <jmcarthur> it looks very borked though
13:11:25 <ibt> hah, borked
13:12:53 <zygoloid> > let countBits n = foldl' (\n (p,s) -> (n .&. p) + ((n `shiftR` s) .&. p)) n [(0x5555,1),(0x3333,2),(0x0f0f::Word32,4),(0x00ff,8)];  numUniques = countBits . foldr (\n c -> (1 `shiftL` n) .|. c) 0 in numUniques [1,2,5,4,1,5,2,5,1]
13:12:54 <lambdabot>   4
13:13:06 <zygoloid> sbasuita: ^^ that's one way of doing it ;)
13:13:48 <zygoloid> hmm, second foldr should be a foldl' too
13:14:15 <sbasuita> zygoloid: your solution scare me :S
13:14:29 <zygoloid> hehe :D
13:15:33 <zygoloid> what are you doing where you think this operation is going to be the bottleneck?
13:16:42 <sbasuita> zygoloid: counting the numbers from min to max which use only x unique digits
13:17:15 <zygoloid> sbasuita: well, you could probably do with a bailout when you've already seen >x digits
13:17:31 <sbasuita> hmm
13:17:37 <zygoloid> but i'd think you could work that out directly with a little thought
13:17:59 <sbasuita> i'm very new to functional programming
13:18:08 <sbasuita> so its all a bit tough atm ;)
13:18:38 <zygoloid> i think there's a better algorithm than searching all the numbers between min and max
13:18:43 <pikhq> zygoloid's solution would not be out-of-place in C.
13:18:53 <sbasuita> zygoloid: yeah
13:18:53 <pikhq> Well, with some manual loops instead of the folds. Still. :P
13:19:12 <sbasuita> zygoloid: but i was looking for a brute force method ;)
13:19:13 <EvanR-work> Break monad, end computation early ;)
13:20:49 <zygoloid> sbasuita: if you want the more elegant method, start by thinking how you'd do it for 2 unique digits, and generalize
13:21:00 * zygoloid thinks he sees how the direct computation would work
13:22:38 <EvanR-work> can i get a ratio of two Integers as a double, which works ;)
13:22:50 <EvanR-work> @hoogle Integer -> Integer -> Double
13:22:51 <lambdabot> Data.Fixed div' :: (Real a, Integral b) => a -> a -> b
13:22:51 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
13:22:51 <lambdabot> Prelude curry :: ((a, b) -> c) -> a -> b -> c
13:22:59 <mauke> :t join (liftM2 (/)) fromInteger
13:23:00 <lambdabot> forall a1. (Fractional a1) => Integer -> a1
13:23:01 <jmcarthur> Athas: if you feel like you want to release something, you put it on hackage. we dont' really have very strict requirements on it
13:23:07 <mauke> oh, right
13:23:16 <EvanR-work> two large integers will be Infinity before the division
13:23:17 <Athas> jmcarthur: nice.  Thanks.
13:23:36 <jmcarthur> sbasuita: what is it you are doing again?
13:23:42 <mauke> :t (fromRational .) . %
13:23:42 <lambdabot> parse error on input `%'
13:23:46 <mauke> :t (fromRational .) . (%)
13:23:47 <lambdabot> forall a. (Fractional a) => Integer -> Integer -> a
13:23:49 <EvanR-work> ah
13:23:56 <sbasuita> jmcarthur: 21:16:18 <sbasuita> zygoloid: counting the numbers from min to max which use only x unique digits
13:24:01 <EvanR-work> > 234 % 67
13:24:03 <lambdabot>   234 % 67
13:24:12 <EvanR-work> > fromRational $ 234 % 67 :: Double
13:24:13 <lambdabot>   3.4925373134328357
13:24:17 <EvanR-work> genius
13:24:58 <jmcarthur> sbasuita: so if you have three unique digits you want the number of expressible numbers using those digits?
13:25:11 <jmcarthur> sbasuita: within certain bounds, that is?
13:25:55 <sbasuita> jmcarthur: yeah, i guess you could put it like that
13:26:33 <ketil> I have a problem compiling bloomfilter again.  It has some cbits sources, but they don't seem to get compiled in?  nm shows the functions as U(ndefined).
13:26:50 * ketil don't remember having this problem before.  Any ideas?
13:27:29 <xerox> > fromRational . uncurry (flip (%)) . join (***) read . splitAt 3 $ "113355"
13:27:30 <lambdabot>   3.1415929203539825
13:27:36 <fax> :D
13:27:41 <EvanR-work> o_O
13:27:49 <hiato> wha!?
13:27:49 <fax> > 113/355
13:27:50 <mauke> > 355/113
13:27:50 <lambdabot>   0.3183098591549296
13:27:51 <lambdabot>   3.1415929203539825
13:28:02 <xerox> very handy approx to remember.
13:28:08 <hiato> oh, i see
13:28:11 <fax> why not just remember the digits :P
13:28:13 <ketil> Hm..  the functions are prefixed with "static inline", does that cause trouble?
13:28:23 <burp> > 22/7
13:28:24 <lambdabot>   3.142857142857143
13:28:29 <EvanR-work> > 3
13:28:31 <lambdabot>   3
13:28:33 <EvanR-work> almost
13:28:34 <burp> lol
13:28:34 <xerox> burp: that's the previous continued fraction cut
13:28:44 <EvanR-work> 3 and some change
13:29:16 <mauke> ketil: yes, 'static' means "I'm a private function, not visible from other modules"
13:29:20 <ketil> Yep - that was it.
13:31:29 <ologNation> I tried to say
13:31:31 <ologNation> data FakeInt = Int
13:31:31 <ologNation>       {-! derive : XmlContent !-}	-- this line is for DrIFT
13:31:34 <ologNation> But that didn't work either.
13:32:06 <EvanR-work> i need to learn these monad tricks
13:32:26 <EvanR-work> like i know theres a way to do concat mapM, without doing mapM ... >>= return . concat
13:33:13 <EvanR-work> :t fmap
13:33:15 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:34:13 <Eelis> the library submission guidelines mention setting a "a timescale for consideration" in the Trac ticket. what time scale should i set?
13:34:18 <EvanR-work> fmap concat (mapM ...
13:34:47 <xerox> ?pl \f -> (>>= return . f)
13:34:48 <lambdabot> fmap
13:37:04 <pikhq> pl seems to make the assumption that all monads are functors...
13:37:38 <pikhq> Of course, cases where this *isn't* true are probably a bug.
13:37:56 <xerox> :t (.)
13:37:57 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:38:00 <xerox> ;)
13:39:14 <gwern> Eelis: a month is usually enough
13:39:37 <gwern> Eelis: unless you're proposing, I dunno, 'let's make Int a synonym for Integer to further programm correctness!'
13:40:11 <Mathnerd314> pikhq: every monad must be a functor, via fmap = liftM
13:40:22 <Mathnerd314> @type liftM
13:40:23 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
13:40:38 <ologNation> I'm reading the api here:
13:40:39 <ologNation> http://hackage.haskell.org/packages/archive/HaXml/1.20.2/doc/html/Text-XML-HaXml-XmlContent-Haskell.html
13:40:42 <ologNation> for HaXml,
13:41:03 <ologNation> Can someone tell me where I can learn how to declare an instance of the typeclass XmlContent?
13:41:19 <ologNation> drift does it automatically for me, but I can't get drift to
13:41:33 <ologNation> a) declare Int to be an instance of XmlContent or
13:41:44 <ologNation> b) declare Set Node to be such an instance where Node is.
13:41:56 <fax> gwern, I do that
13:42:17 <jmcarthur> sbasuita: which is likely to be larger, digits! or max-min?
13:42:19 <fax> gwern, e.g.  type Natural = Integer  -- but all functions defined on Natural do not dare touch negative numbers
13:42:34 <sbasuita> jmcarthur: max-min
13:44:07 <pikhq> Mathnerd314: Yes, but this is not actually *true*.
13:44:32 <Eelis> gwern: it feels weird specifying deadlines for other volunteers.. naively i'd just expect "as long as it takes" to be a reasonable "timescale for consideration" :)
13:44:48 <jaj> has anybody used System.BSD.Sysctl from bsd-sysctl on hackage?
13:45:02 <jaj> I try this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25162#a25162
13:45:28 <jaj> and I get "No instance for (SysctlKey [Char])" even though the library defines an instance for SysctlKey String
13:46:33 <jaj> moreover the compiler tells me that sysctlNameToOid is not defined even though it is documented and gets defined in the library code
13:50:20 <EvanR-work> gah, Ord restricts you to one ordering ;)
13:50:28 <EvanR-work> i want to sort two ways
13:50:34 <mauke> sortBy
13:50:34 <jmcarthur> sortBy
13:50:51 <jmcarthur> i wish we had a standard sortOn, though
13:51:02 <EvanR-work> my new sortBy function is
13:51:02 <mauke> :t sortBy . comparing
13:51:03 <lambdabot> forall a a1. (Ord a1) => (a -> a1) -> [a] -> [a]
13:51:07 <EvanR-work> compareSurvey (Email s1 _ _) (Email s2 _ _) = compare s1 s2
13:51:22 <gwern> Eelis: if you don't put a deadline and start bugging people about it, nothing will get done
13:51:24 <lispy> Use an Ord Factory Factory to produce the Ord Factory you need, then use that with the Strategy pattern to construct an appropriate Comparer object
13:51:32 <EvanR-work> rofl
13:51:33 <xerox> if you have an Email record you can do sortBy (comparing firstfield)
13:51:48 <Botje> jaj: that looks strange. have you tried enabling the TypeSynonymInstances option?
13:51:54 <jmcarthur> mauke: sure, but sortOn could be faster by caching the result of the conversion until the sort is over
13:51:56 <lispy> EvanR-work: look at the on function
13:51:58 <lispy> :t on
13:51:58 <gwern> Eelis: fear and threats. that's how one deals with the rebels
13:51:59 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
13:52:03 <mauke> sortBy (comparing firstfield `mappend` comparing secondfield)
13:52:06 <jaj> Botje: nope
13:52:17 <Botje> jaj: i think you need that for the instance to work
13:52:18 <lispy> :t compare `on` fst
13:52:18 <EvanR-work> :S
13:52:19 <lambdabot> forall a b. (Ord a) => (a, b) -> (a, b) -> Ordering
13:52:25 <gwern> Eelis: look at how many times I had to bug people about Control.Monad.void
13:52:26 <mauke> :t comparing fst
13:52:27 <lambdabot> forall a b. (Ord a) => (a, b) -> (a, b) -> Ordering
13:52:34 <Botje> {-# LANGUAGE TypeSynonymInstances #-} at the top of your file, fwiw
13:52:37 <EvanR-work> ill use comparing with record syntax
13:52:42 <gwern> Eelis: I suggest a monthly calendar item: 'bug people about addition X'
13:52:42 <Eelis> gwern: hm, i see. ok, i will keep that in mind, thanks
13:53:04 <mauke> :t sortBy (comparing snd `mappend` comparing fst)
13:53:05 <lambdabot> forall a b. (Ord b, Ord a) => [(a, b)] -> [(a, b)]
13:53:26 <EvanR-work> :t comparing
13:53:27 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
13:53:35 <jmcarthur> (sortBy . comparing) applies the function nlogn times :(
13:53:55 <EvanR-work> uh oh, does that mean its bad
13:54:00 <jmcarthur> nah
13:54:07 <jmcarthur> for most things it's still going to be plenty fast
13:54:18 <jmcarthur> just for certain kinds of things it won't be
13:54:27 <EvanR-work> btw im using groupBy not sortBy ;)
13:54:47 <jmcarthur> ah, a little different then
13:56:00 <EvanR-work> groupBy (comparing surveyId) :(
13:56:41 <mauke> why so sad?
13:57:08 <xerox> just incomplete paste, it's cons(...
13:57:08 <jmcarthur> comparing won't even work with groupBy
13:57:19 <mauke> :t groupBy
13:57:20 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
13:57:21 <EvanR-work> right
13:57:31 <EvanR-work> whats the equivalent of comparing for groupBy
13:57:33 <mauke> groupBy ((==) `on` surveyId)
13:58:04 <EvanR-work> @hoogle comparing
13:58:04 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
13:58:24 <mauke> @src comparing
13:58:25 <lambdabot> Source not found. That's something I cannot allow to happen.
13:58:30 <mauke> why you
13:58:44 <EvanR-work> on is gnarly
14:00:58 <EvanR-work> @hoogle on
14:00:58 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
14:00:58 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
14:00:58 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
14:03:33 <Eelis> @hoogle [a] → (a → Maybe b) → [b]
14:03:33 <lambdabot> Parse error:
14:03:34 <lambdabot>   --count=20 "[a] → (a → Maybe b) → [b]"
14:03:34 <lambdabot>                   ^
14:03:41 <Eelis> hm
14:03:49 <Eelis> oh
14:04:00 <Eelis> @hoogle [a] -> (a -> Maybe b) -> [b]
14:04:01 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
14:04:01 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
14:04:01 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
14:04:13 <Eelis> poor hoogle isn't UnicodeSyntax-enabled
14:05:12 <Wanderratte> can someone help a beginner?: getting error: "Ambiuous occurence '==' It could refer to either 'Main./='  or Prelude./=" seems like a beginners error
14:05:25 <xerox> have you redefined /=
14:05:48 <Wanderratte> introduced a new class eq' and instanciated it
14:06:10 <xerox> you gotta choose different names for your Eq' class functions
14:06:17 <xerox> than those already used in Eq
14:06:27 <xerox> or hide Eq somehow
14:07:45 <Wanderratte> so i cannot redefine the eq function  like in the wikibook ( http://en.wikibooks.org/wiki/Haskell/Class_declarations )
14:08:11 <Wanderratte> like calling it eq' or smth
14:08:28 <xerox> those are already defined in the Prelude
14:08:37 <xerox> ?src Eq
14:08:37 <lambdabot> class  Eq a  where
14:08:38 <lambdabot>     (==), (/=)   :: a -> a -> Bool
14:08:52 <xerox> exactly in the wikibook fashion
14:09:19 <lpsmith> Wanderratte, you could use === and =/=  maybe;   but I'm not sure why you'd want to redefine Eq :)
14:09:19 <Wanderratte> of course, but in case i want to define a new eq-class, shouldnt i be able to do it the same way?
14:09:29 <Wanderratte> just for educational purposes ;)
14:09:35 <xerox> a new eq class or a new instance
14:09:50 <Wanderratte> class i think ;)
14:10:08 <xerox> as I said, a new eq class either has to have a different name, or needs the Prelude one to be hidden
14:10:16 <lpsmith> class MyEq a where  (===) , (=/=) :: a -> a -> Bool
14:11:08 <Wanderratte> ah okay, somehow the eq' didn't work out (maybe I forgot to save :) ). Okay thanks alot guys!
14:17:07 <bitstream0101> Cale: Found my space leak and fixed it =). Thanks for your help earlier.
14:18:09 <bitstream0101> Cale: It wasn't freeCont/Blocks but it was related: I was cramming free block groups back into a fingertree and accumulating thunks there that weren't being evaluated until much later (the next allocation from the tree, as a matter of fact).
14:28:13 <EvanR-work> how do i use an MVar to spawn n threads, and block until they all signal that they are complete
14:28:25 <EvanR-work> MVar Chan, something
14:28:44 <mauke> use one MVar per thread, take from all of them
14:28:52 <mauke> each thread puts when done
14:28:57 <EvanR-work> ah
14:29:23 <EvanR-work> mapM newEmptyMVar [1..n]
14:30:42 <monadic_kid> EvanR: http://www.haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/Control-Concurrent.html#11
14:31:03 <monadic_kid> EvanR: look at waitForChildren
14:31:42 <mamalujo_> hi, how much of haskell extensions are currently supported by TH, say in GHC HEAD? I think I read it supports families, but not view patterns?
14:31:59 <EvanR-work> forM_ mvars (\m -> takeMVar m)
14:32:02 <EvanR-work> erm
14:32:07 <EvanR-work> forM_ mvars takeMVar
14:32:18 <EvanR-work> why is that example so verbose
14:32:52 <EvanR-work> and its using unsafePerformIO
14:37:39 <aavogt> mamalujo_: it supports all extensions for the type system, extensions purely for syntax not so much
14:38:20 <aavogt> mamalujo_: there's a bug for view pattern support (or some way to have guards in the Pat data)
14:40:26 <mamalujo_> aavogt, thx, but i didn't quite understand your 2. sentence, a bug as in there's an open ticket to add the support, or there is some problem in adding them?
14:40:42 <aavogt> I mean open ticket
14:40:50 <mamalujo_> ah, k, thx
14:41:06 <aavogt> nobody claims there is a technical reason for not supporting view patterns
14:41:15 <EvanR-work> how to shorten this (\x -> foo >> bar x)
14:41:25 <mauke> (foo >>) . bar
14:42:18 <EvanR-work> what about (\x -> bar x >> foo)
14:42:23 <mamalujo_> but, actually I read that ticket, and I think simonPJ there commented that he's not sure about pouring so much concrete over the idea of view patterns yet. well at least at the time he posted that..
14:42:37 <mauke> (>> foo) . bar
14:42:38 <Gracenotes> (. (>>foo)) . bar
14:42:42 <EvanR-work> :o
14:42:55 <mauke> @unpl  (. (>>foo)) . bar
14:42:55 <lambdabot> (\ e h -> bar e (h >> foo))
14:43:34 <Gracenotes> sections, confuzzling me
14:44:36 * hackagebot NonEmptyList 0.0.3 - A list with a length of at least one.  http://hackage.haskell.org/package/NonEmptyList-0.0.3 (TonyMorris)
14:45:08 <EvanR-work> thanks Tony
14:45:38 <aavogt> but the quickcheck?!?!
14:46:21 <aavogt> dibblego: you're aware of the awkward situation with using libraries that require varying versions of quickcheck?
14:49:17 <copumpkin> optional dependencies on quickcheck are where it's at
14:49:44 <aavogt> fixing cabal install is where it's at
14:49:58 <aavogt> err, should be
14:50:00 <copumpkin> for specific test support?
14:50:09 <copumpkin> because having a flag to enable tests seems to be decent for now
14:50:54 <dcoutts> aavogt: what aspect of fixing?
14:53:28 <aavogt> dcoutts: either considering that module interfaces can depend on flags, or otherwise letting you build something that depends indirectly on different versions of the same package
14:54:31 <aavogt> but that's all pretty vague: maybe it's just better to fix the packages that always expose their tests
14:57:15 <djahandarie> Interesting, it's the same conversation as when I went to bed!
14:58:39 <SubStack> still talking about haskell? cripes
14:59:44 <jbapple> There's a discussion on libraries@haskell.org right now about whether or not to move a function into a class. One of the arguments against it is that one might then be tempted to move many functions into the class. Why would that be bad? Does it actually make dictionary passing slower?
15:07:08 <[swift]> i'd like to write this: f (_ x y) = doSomething x y, but haskell doesn't like a wildcard for the constructor. is there some way to get a similar effect? (i just want it to work for different data constructors of a single type, all of which have the same parameters)
15:08:23 <EvanR-work> runghc is awesome
15:10:19 <copumpkin> did the 6.12.2 release miss the most recent platform update?
15:11:00 <Cale> [swift]: If you're not too far ahead in writing your program, you might consider changing the design of the datatype a bit, given that all the cases are shaped the same.
15:11:52 <Cale> [swift]: Otherwise, I suppose the sensible thing to do would be to write a function which discards the information about which data constructor it is and gives a plain pair.
15:12:07 <[swift]> Cale: haha well i have already changed it once. =) this setup is convenient because i _usually_ want to do different things for each case, and this lets me use pattern matching to do that
15:12:10 <Cale> [swift]: You could then use the view patterns extension:
15:12:25 <Cale> f (toPair -> (x,y)) = ...
15:12:36 <copumpkin> [swift]: factoring out the bit that changes still lets you pattern match
15:13:09 <copumpkin> data Animal = Baa Int Int | Oink Int Int | Woof Int Int | Moo Int Int
15:13:10 <[swift]> copumpkin: hmm.. maybe i should throw the type definition up on hpaste, because i'd love to see how you'd recommend changing it
15:13:18 <copumpkin> data Noise = Baa | Oink | Woof | Moo
15:13:24 <copumpkin> data Animal = Animal Noise Int Int
15:13:33 <fax> what are the Ints fr?
15:13:36 <copumpkin> beats me
15:13:50 <fax> four legs good, two legs bad!
15:13:51 * hackagebot Twofish 0.1 - An implementation of the Twofish Symmetric-key cipher.  http://hackage.haskell.org/package/Twofish-0.1 (RonLeisti)
15:13:58 <copumpkin> :P
15:14:00 <[swift]> copumpkin: ok, i think i get the idea actually
15:14:10 <copumpkin> then you do
15:14:16 <copumpkin> f (Animal _ x y) = ...
15:14:23 <copumpkin> or f (Animal Baa _ _) = ...
15:14:27 <copumpkin> depending on what part you care about
15:14:33 <[swift]> copumpkin: so then one can write f (Animal Baa i j)
15:14:48 <EvanR-work> more interesting would be a prime number of legs. oh wait, 2 is prime
15:15:00 <[swift]> copumpkin: damn, i wish i had thought of that earlier! i'll make the change
15:15:23 <fax> 2 is the oddest prime
15:15:42 * EvanR-work refines primes so 1 is prime and 2 isnt
15:15:54 <EvanR-work> take that
15:18:11 <copumpkin> EvanR-work: that might break a few things, unless you make the 1 symbol take on the common value of the 2 symbol and vice versa
15:18:53 <EvanR-work> nah
15:19:39 <EvanR-work> a prime is a number with factors 1 and itself, except 1, and except 2
15:20:14 <EvanR-work> all primes are odd
15:20:17 <EvanR-work> new theorem ;)
15:20:17 <fax> is -1 prime
15:20:22 <fax> is -3 prime
15:20:31 <EvanR-work> yes -1 is prime ;)
15:20:50 * EvanR-work knows all
15:20:51 <fax> is 4 prime? :P
15:20:51 <Eridius> http://primes.utm.edu/notes/faq/negative_primes.html
15:20:55 <EvanR-work> no, 2*2
15:21:01 <fax> but 2 isn't a prime
15:21:05 <EvanR-work> doesnt matter
15:21:05 <Rotaerk> EvanR-work, uh no... In mathematics, a prime number (or a prime) is a natural number that has exactly two distinct natural number divisors: 1 and itself.
15:21:13 <Cale> A prime p is a nonzero nonunit such that whenever p | ab, then p | a or p | b
15:21:16 <kynky> 2 is prime, 1 isnt prime
15:21:23 <EvanR-work> Rotaerk: that doesnt work for 1
15:21:24 <fax> EvanR of course it matters
15:21:34 <EvanR-work> fax: my def didnt use prime in itself
15:21:35 <Rotaerk> EvanR-work, correct, 1 isn't prime, but 2 is
15:21:40 <Rotaerk> and negatives aren't
15:21:46 <EvanR-work> ah, two distinct
15:22:27 <EvanR-work> is i prime ;)
15:22:33 <Cale> The 'nonunit' excludes 1 and -1 from being prime integers. You don't want 1 or -1 to be prime, since it destroys the uniqueness of factorisations into primes.
15:22:39 <fax> I think i is just as prime as 1 and -1
15:22:40 <fax> so yes
15:22:49 <copumpkin> i^i is prime
15:22:51 <kynky> EvanR, defn of natural numbers is.... ?
15:22:52 <Cale> i is similarly excluded
15:22:53 <fax> but if you include complex numbers, some things which used to be prime are not any more
15:23:01 <Cale> (in the Gaussian integers)
15:23:23 <EvanR-work> kynky: 1 2 skip a few 99 omega
15:23:23 <Cale> Because it has -i as a multiplicative inverse, and things with multiplicative inverses are not prime
15:23:28 <kynky> :)
15:23:31 <copumpkin> > (0 :+ 1) ** (0 :+ 1)
15:23:32 <lambdabot>   0.20787957635076193 :+ 0.0
15:23:38 <copumpkin> omg
15:23:42 <fax> lol
15:23:43 <copumpkin> :P
15:23:44 <Cale> If you're talking about the whole field of complex numbers, then there are no primes anymore.
15:23:49 <Cale> Everything is 0 or a unit
15:23:53 <fax> can you give an intuitive explanation why it's real?
15:24:05 <copumpkin> not sure it'd be intuitive
15:24:35 <EvanR-work> > (0 :+ 1) ** (0 :+ (-1))
15:24:36 <lambdabot>   4.810477380965351 :+ 0.0
15:24:50 <copumpkin> it's not that bad though
15:25:05 <Cale> i^i = exp(i log i), and log i = i pi/2
15:25:29 <Cale> So i^i = exp(i^2 pi/2) = exp(-pi/2)
15:25:44 <fax> > sqrt(-1) ^ (sqrt(sqrt(-1))/2) :: Complex Double
15:25:45 <lambdabot>   Ambiguous type variable `a' in the constraints:
15:25:45 <lambdabot>    `GHC.Float.Floating a'
15:25:45 <lambdabot>  ...
15:25:53 <fax> > sqrt(-1) ** (sqrt(sqrt(-1))/2) :: Complex Double
15:25:54 <lambdabot>   0.4876194697242326 :+ 0.302570280877804
15:29:40 <fax> > (-1) ** (-eye/2)  :: Complex Double
15:29:41 <lambdabot>   0.20787957635076193 :+ 0.0
15:30:35 <fax> so why is -1^i real?
15:31:15 <c_wraith> > eye
15:31:16 <lambdabot>   (-0.0) :+ 1.0
15:31:20 <c_wraith> hah
15:31:41 <c_wraith> negative zero!
15:31:51 <ddarius> > 0.0 == -0.0
15:31:52 <lambdabot>   True
15:31:59 <ddarius> > -0.0
15:32:00 <fax> you can't multiply by yourself "i" times
15:32:00 <lambdabot>   -0.0
15:32:03 <fax> that doesn't make sense
15:32:04 <djahandarie> > -Inf / Inf
15:32:05 <lambdabot>   Not in scope: data constructor `Inf'Not in scope: data constructor `Inf'
15:32:10 <djahandarie> grr
15:32:15 <djahandarie> > -(1/0)
15:32:16 <lambdabot>   -Infinity
15:32:21 <ddarius> fax: Cale already told you the definition of exponentiation in this situation.
15:32:42 <fax> I know the definitions
15:32:50 <djahandarie> > -(1/0) / (1/0)
15:32:50 <fax> I mean you just run it and it hsows the result is real
15:32:51 <lambdabot>   NaN
15:32:57 <fax> I'm wondering about an intuitive explanation
15:33:01 <fax> maybe it's impossible
15:34:59 <ddarius> fax: -1 = e^(pi i), -1^i = e^(pi i)^i = e^(pi i^2) = e^(-pi)
15:35:03 <ddarius> > exp (-pi)
15:35:04 <lambdabot>   4.321391826377226e-2
15:36:11 <ddarius> > (-1)**(0:+1)
15:36:12 <lambdabot>   23.140692632779267 :+ 0.0
15:36:28 <fax> hey
15:36:34 <fax> I've seen that number somewhere
15:36:46 <fax> heheh if you google it there is #haskell
15:36:46 <ddarius> > exp pi
15:36:47 <lambdabot>   23.140692632779267
15:36:53 <ddarius> Different branch cuts.
15:36:57 <EvanR-work> maybe look at the graph of i^z
15:36:58 <Cale> Exponentiation with a complex exponent is a bit of a strange operation
15:37:43 <ddarius> The logarithm of a complex number is a bit of a strange operation.
15:38:10 <fax> what about multivalued functions
15:38:21 <mle> > exp $ 0 :+ pi
15:38:21 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
15:38:26 <Cale> A bit less strange to me somehow :)
15:38:35 <fax> hi mle!
15:38:39 <mle> heya fax
15:39:49 <fax> Cale - it is weird because going from x^n = x*x*x*...*x to x^(n/m) is fine, and extending to reals is fine -- but how can you extend a function from a line into a plane, it seems like thre could be any definition for it outside the real line
15:40:10 <fax> maybe because you can multiply them to get a real again.. that forces it to be unique
15:40:26 <Cale> Well, actually I think it's less weird for those reasons than it is for the reason that it just doesn't show up that often.
15:40:36 <mle> fax: consider A + Bi as cartesian coordinates, then convert to polar, and it makes more sense.
15:41:24 <mle> e^(i pi) is -1 because that's how far pi radians spins it around.
15:41:30 <mle> other things... eh.
15:41:43 <fax> that makes senes
15:41:45 <fax> sense
15:42:02 <kynky> there are quite a few different proofs of that though, that is just one of them
15:42:04 <Cale> exp, and by extension, log, have perfectly sensible geometric interpretations, but exp(a log b) is a bit of a funny thing to do.
15:42:34 <mle> kynky: sure.  That one's handy with kids though.
15:44:22 <kynky> i also like that the tower of powers of the square root of 2 == 2
15:44:36 <fax> what's that?
15:44:53 <fax> > iterate (**sqrt(2)) 1
15:44:53 <lambdabot>   [1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1....
15:45:03 <fax> > iterate (**sqrt(2)) sqrt(2) !! 100
15:45:03 <lambdabot>   Couldn't match expected type `t -> [a]'
15:45:03 <lambdabot>         against inferred type `[a1 ...
15:45:09 <fax> > iterate (**sqrt(2)) (sqrt 2) !! 100
15:45:10 <lambdabot>   Infinity
15:45:31 <fax> > iterate (sqrt(2)**) (sqrt 2) !! 100
15:45:32 <lambdabot>   2.0000000000000004
15:45:54 <kynky> (...(sqrt 2 ** (sqrt2 ** (sqrt2)))) = 2
15:46:06 <fax> hm
15:46:13 <fax> do you need lambert W to prove it
15:46:53 <kynky> :)
15:46:58 <idnar> > iterate (sqrt(2)**) (sqrt 2)
15:47:00 <lambdabot>   [1.4142135623730951,1.632526919438153,1.7608395558800285,1.8409108692910108...
15:47:11 <dibblego> aavogt, no, what should I use instead?
15:48:32 <Cale> Speaking of which, have you guys seen the proof that an irrational number to an irrational power may be rational?
15:48:53 <copumpkin> is it constructive
15:49:01 <ddarius> copumpkin: No.
15:49:05 <copumpkin> :(
15:49:38 <FunctorSalad> the traditional narrative goes on to mention that there is a constructive proof, but that it's far harder
15:49:38 <ddarius> Well, I guess in this case all it needs to do is provide a specific pair of irrationals.
15:49:40 <FunctorSalad> ;)
15:49:42 <fax> it can be made consrtuctive
15:49:44 <Cale> We know that sqrt 2 is irrational. (sqrt 2)^(sqrt 2) is either rational, in which case we are done, or it's irrational, in which case raising it to the power of sqrt 2 gives 2, which is rational.
15:49:48 <copumpkin> ddarius: yep
15:49:49 <gio123> Cale: can it be proved at all:)?
15:50:29 <copumpkin> > join (^) $ sqrt 2
15:50:31 <lambdabot>   Ambiguous type variable `a' in the constraints:
15:50:31 <lambdabot>    `GHC.Real.Integral a'
15:50:31 <lambdabot>   ...
15:50:33 <copumpkin> > join (**) $ sqrt 2
15:50:34 <lambdabot>   1.632526919438153
15:50:50 <copumpkin> > (join (**) $ sqrt 2) ** sqrt 2
15:50:51 <lambdabot>   2.0000000000000004
15:50:55 <AmunRa> Hello! I'm learning haskell and I'm really struggling to get my head around how to use "cabal-install" properly without messing things up
15:51:08 <copumpkin> > (join (**) $ sqrt 2, sqrt 2) -- there, a constructive proof, yay
15:51:09 <lambdabot>   (1.632526919438153,1.4142135623730951)
15:51:15 <copumpkin> me rules
15:51:21 <copumpkin> whoops
15:51:53 <ddarius> copumpkin: First show that sqrt 2 ^ sqrt 2 is not rational.
15:51:56 <AmunRa> I somehow ended up with two installations of "process" a global and a user.. what's the best way to resolve this without creating more damage?
15:51:58 <FunctorSalad> AmunRa: messing things up = jollily putting files to /usr/local?
15:52:07 <FunctorSalad> for that I recommend "paco"...
15:52:30 <FunctorSalad> or checkinstall (but that asks more questions)
15:52:41 <copumpkin> ddarius: no rational number raised to an irrational power would give another rational number!
15:52:41 <zachk> amunaRa: ps -aux | more ; get the pid; kill -9 pid
15:52:55 <FunctorSalad> zachk: he means the library ;)
15:53:04 <zachk> oh i have no idea then :-/
15:53:26 <FunctorSalad> AmunRa: hmm I stopped bothering and just nuked the user-wide package file
15:53:44 <FunctorSalad> then you just have to make an empty one with ghc-pkg init and it will work again ;)
15:53:49 <ddarius> copumpkin: Proof?
15:53:51 <FunctorSalad> minus the packages there, obviously
15:54:13 <aavogt> dibblego: use a cabal flag to conditionally enable the quickcheck tests and dependency
15:54:14 <copumpkin> ddarius: I choose to prove by calling a friend, or maybe asking the audience
15:54:16 <FunctorSalad> AmunRa: but to only delete 'process', use ghc-pkg unregister
15:54:28 <fax> > 1**sqrt(2)
15:54:29 <lambdabot>   1.0
15:54:51 <FunctorSalad> AmunRa: it takes --used and --global to tell it on which one to operate
15:54:54 <FunctorSalad> *user
15:54:59 <FunctorSalad> and "global" might be "system"
15:55:00 <FunctorSalad> ;)
15:55:07 <zachk> > 0**sqrt(2)
15:55:08 <lambdabot>   0.0
15:55:25 <ddarius> > (-1) ** sqrt 2
15:55:26 <lambdabot>   NaN
15:55:27 <copumpkin> > 1**(2 :+ 4)
15:55:27 <FunctorSalad> copumpkin: is it a fact or am I missing something?
15:55:28 <lambdabot>   1.0 :+ 0.0
15:55:44 <FunctorSalad> (that is, a facetious thread)
15:56:22 <mamalujo_> um, hypothetically, could nix or some version thereof become a replacement for cabal? I mean, are these package systems in the same category, and as I understand it, cabal is criticized as being fairly primitive?
15:56:35 <AmunRa> yeah.. I think that's how I installed everything so far.. but for some reason: `cabal install --global cabal` gives me "missing process-1.0.1.2" even though I have both a global and user install
15:56:50 <copumpkin> mamalujo_: I haven't actually heard much informed criticism of cabal
15:57:10 <FunctorSalad> mamalujo_: cabal seems fairly complex and featureful except for lack of installed file tracking :) but maybe not compared to even larger package systems, dunno
15:57:19 <ddarius> copumpkin: dcoutts said it was somewhat primitive, but he probably doesn't know what he's talking about
15:57:25 <FunctorSalad> (cabal is a build system primarily anyway, isn't it)
15:57:28 <copumpkin> lol
15:57:33 <dcoutts> mamalujo_: for aspects of the package management, yes.
15:57:35 <dcoutts> ddarius: ;-)
15:57:52 <copumpkin> it does what it claims to do quite well, I think
15:58:03 <FunctorSalad> copumpkin: I'd like a "import whatever you want" flag for development
15:58:08 <FunctorSalad> (early development)
15:58:11 <copumpkin> ah
15:58:28 <kynky> cabal not very good for uninstalling stuff and then resolving reverse dependencies
15:58:36 <FunctorSalad> adding the deps into the .cabal seems like a bit of a needless speedbump with a fresh project
15:58:36 <copumpkin> pff who needs uninstall
15:58:38 <AmunRa> dunno.. together with the lack of mature libraries.. the usability of cabal is what I find most annoying in the haskell programming workflow (language itself is great)
15:59:23 <mamalujo_> there was some lecture slides around, http://blog.well-typed.com/wp-content/uploads/2008/10/future-of-cabal.pdf but regardless of that, the purity and a lambda calculus based model of nix surely sits better with haskell?
15:59:41 <FunctorSalad> AmunRa: for messing with installed packages you need ghc-pkg, not cabal
15:59:48 <FunctorSalad> (you already have it)
15:59:50 * ddarius doesn't recall nix having anything to do with the lambda calculus.
15:59:59 <dcoutts> mamalujo_: yes, I'm trying to steal ideas from nix as quickly as possible. It manages installed packages the "Right Way"TM
16:00:13 <FunctorSalad> AmunRa: but it can only forget about an installed package, not physically delete it
16:00:13 <ddarius> dcoutts: Yay!
16:00:37 <dcoutts> ddarius: it's a functional package description language, and it uses a persistent package store. In that sense it is functional.
16:00:48 <mamalujo_> ah, right that are your slides, didn't notice :) you mention maak there, and thats a direct predecessor of nix as I understand it
16:01:07 <ddarius> dcoutts: I understand purity, but not lambda calculus-y.
16:01:09 <dcoutts> right, which focused on package building, rather than package management
16:01:28 <dcoutts> ddarius: yeah, it's not lambda calculus
16:02:02 <gwern> isn't it a fully lazy functional languagen ix uses?
16:02:06 * hackagebot NonEmptyList 0.0.4 - A list with a length of at least one.  http://hackage.haskell.org/package/NonEmptyList-0.0.4 (TonyMorris)
16:02:36 <dcoutts> gwern: lazy and dynamically typed
16:03:17 <AmunRa> b.t.w. for future reference.. is there something I can tweak so cabal *never* does --user ?
16:03:19 <FunctorSalad> btw I want colors too
16:03:21 <FunctorSalad> in cabal
16:03:22 <FunctorSalad> :D
16:03:35 <dcoutts> AmunRa: ~/.cabal/config
16:03:44 <dcoutts> FunctorSalad: me too
16:04:16 <FunctorSalad> dcoutts: why not just pipe it through an existing highlighter? at least the haskell fragments
16:05:20 <dcoutts> FunctorSalad: perhaps we're thinking of different things. I was thinking about nice colours and formatting of the command line messages that cabal produces. You're talking about Haskell code.
16:05:51 <FunctorSalad> dcoutts: about the haskell fragments output by cabal :) since that's the hardest part
16:06:09 <dcoutts> FunctorSalad: oh that's easy, since cabal never outputs any Haskell fragments :-)
16:06:14 <FunctorSalad> for the other messages one could start with 'red' for error and so on
16:06:22 <dcoutts> FunctorSalad: you're probably talking about ghc error messages
16:06:26 <FunctorSalad> dcoutts: hmm, ok, it's ghc :)
16:06:36 <[swift]> argh, i HATE the asymmetry between TH and custom quasiquotes
16:07:07 <FunctorSalad> asymmetry? is there any similarity at all? ;)
16:07:10 <FunctorSalad> except the brackets
16:07:30 <FunctorSalad> ok, you need to produce the same output type
16:07:36 <[swift]> ignoring that this isn't real code, this expresses the difference: [d| x |] = $([$d| x |])
16:07:44 <[swift]> is that clear?
16:07:56 <[swift]> custom quasiquotes are a composed splice and quote
16:08:00 <[swift]> in TH you can separate the two
16:08:10 <FunctorSalad> hmm... as long as you know that the $ is followed by an arbitrary name?
16:08:15 <FunctorSalad> (in the qq)
16:08:26 <FunctorSalad> and the first 'd' is 'decl'...
16:08:54 <[swift]> FunctorSalad: what i meant by the above is, imagine we have a custom quasiquoter which does the same thing as the template haskell d quoter
16:08:58 <aavogt> quasiquotes are run earlier
16:09:15 <[swift]> FunctorSalad: then the behavior of the quasiquoter is the same as if we had _spliced_ the output of the template haskell d quoter
16:09:23 <FunctorSalad> [swift]: aah, you're talking about something deeper than the similar looks :)
16:09:37 <FunctorSalad> (but different behaviour)
16:09:41 <FunctorSalad> sorry I missed the point
16:09:42 <aavogt> so you can't exactly emulate [| |], [t| |], [d| |] with quasi quotes
16:09:45 <[swift]> aavogt: that may the origin of the problem, but i think it was a design mistake
16:09:49 <[swift]> aavogt: exactly
16:10:11 <FunctorSalad> quasiquotes can't be decls in either case (unless that changed)
16:10:13 <aavogt> I mean in terms of capturing the correct varibles
16:10:35 <[swift]> aavogt: i've come up with a tolerable hack for the expression case (basically have the quasiquoter return the _AST_ of what you really want it to return)
16:10:59 <[swift]> aavogt: this doesn't work right for the pattern case, tho
16:11:19 <aavogt> FunctorSalad: Q [Dec] is supported for the next release
16:11:23 <[swift]> FunctorSalad: yeah, i believe that's still right, tho one can return the AST of a decl and splice it in
16:11:32 <FunctorSalad> aavogt: nice
16:12:12 <aavogt> also  Q Type.. though usually type inference is enough...
16:12:54 <[swift]> aavogt: those are good improvements, but i really wish the TH quoters and the quasiquoters just worked the same way
16:13:03 <FunctorSalad> I'm still a bit confused what the intended and what the actual behaviour of your first snippet is :) the quasi produces a Q Expr, which you can splice, so far ok
16:13:20 <[swift]> FunctorSalad: that's not a snippet to be read literally; that's what i meant by "this isn't real code"
16:13:30 <[swift]> FunctorSalad: i was just trying to summarize what i said afterwards
16:13:47 <FunctorSalad> I understood that the "d" quasiquoter was hypothetical
16:13:52 <FunctorSalad> but that's not the only problem?
16:14:14 <FunctorSalad> oh wait... you're assigning something to a value on the LHS
16:14:23 <FunctorSalad> :)
16:14:32 <FunctorSalad> (Q [Dec])
16:14:35 <[swift]> FunctorSalad: haha, looking at it again, i wrote it backwards. this is what i meant: $([d| x |]) = [$d| x |]
16:14:50 <[swift]> FunctorSalad: the point is that the quasiquote automatically does a splice
16:15:05 <[swift]> FunctorSalad: which is not always what you want; sometimes you want an AST to manipulate further
16:15:05 <FunctorSalad> yes
16:15:34 <aavogt> [swift]: then stick another 'lift' in your definition of d
16:15:53 <FunctorSalad> [swift]: I see, so QQs should return arbitrary types?
16:16:03 <FunctorSalad> assuming you don't just want the vanilla haskell AST
16:16:18 <aavogt> they do...
16:16:20 <FunctorSalad> but isn't that just... "read"? ;)
16:16:29 <FunctorSalad> (string to arbitrary)
16:16:30 <[swift]> aavogt: yeah, i've gotten it working, but its not as elegant as the TH ones and i can't, say, for the QQ to be evaluated in a pattern context unless its actually _in_ a pattern
16:16:39 <FunctorSalad> thought the whole point of qq was that they become haskell directly
16:16:44 <[swift]> *force
16:17:07 <[swift]> FunctorSalad: in this case i do want the vanilla haskell AST, tho it'd be nice to be able to return whatever kind of AST you want
16:17:21 <aavogt> FunctorSalad: yes, they become haskell (patterns or expressions)
16:17:32 <FunctorSalad> but that latter case would be just "read"
16:17:35 <aavogt> [swift]: I don't understand what you mean by that
16:17:46 <FunctorSalad> (eval'ed at compile-time, as core TH can do already)
16:17:56 <[swift]> FunctorSalad: if read was enough then who needs any of the quoters? just write $(read "blah")
16:18:04 <aavogt>   [$something|     |]  --- is supposed to be a haskell expression
16:18:20 <[swift]> aavogt: ... or a pattern
16:18:26 <aavogt> sure
16:19:06 <[swift]> aavogt: i can't call the QQ's pattern implementation unless i've actually _placed it in a pattern_. however, if my goal is to get out an AST to manipulate further, that won't work
16:19:12 <aavogt> which means it must be a Pat or a Exp
16:19:49 <[swift]> aavogt: with TH you could theoretically (if it was implemented) do [p| blah |] and get an AST for the pattern out. you can't do something similar with QQ's.
16:20:05 <FunctorSalad> [swift]: that was my point too (don't need any quotes if you want a generic String -> AST parsing)
16:20:34 <FunctorSalad> couldn't you just *call* the quasiquoter instead of using quasiquotation, to obtain your Q Expr?
16:20:38 <FunctorSalad> Q Exp
16:20:47 <[swift]> FunctorSalad: right but then you have an "unhygienic" macro
16:21:11 <[swift]> FunctorSalad: yeah, sure, i can. but that doesn't mean that i think that's how it should be.
16:21:22 <aavogt> what is the post-processing?
16:21:23 <JacquesC_> I have heard generic programming described tongue-in-cheek as "the kind of polymorphism that a language does not (yet) have".  I find this description rather apt, and it matches fairly what I see called 'generic' in various communities.  But who said this, where and when?
16:22:08 <[swift]> aavogt: various munging, i've got several combinators by now. things like replacing all instances of a certain variable with an expression, manipulating names of variables, etc
16:23:01 <aavogt> can you pass implicit parameters to quasiquoters?
16:23:15 <FunctorSalad> [swift]: hmm I see... that renaming stuff should be avoided to do manually if at all possible
16:23:23 <FunctorSalad> I had it with plain quote-free TH anyway, though
16:23:46 <FunctorSalad> like if you want to specialize a polymorphic type...
16:24:00 <[swift]> aavogt: i'm not sure how other than by including it in the text they parse...
16:24:17 * aavogt tries it out
16:24:32 <FunctorSalad> (I mean, if you want to actually expand a specialization :))
16:24:45 <FunctorSalad> and get the specialized constructors
16:24:53 <FunctorSalad> just a random case I remember
16:25:15 <[swift]> sadly i have to go to a meeting but i'll be happy to talk about this more later
16:25:52 <[swift]> one other complaint about TH: for TH AST types, (read . show) x /= x
16:26:10 <[swift]> this because the implementation of show for Name is wrong (in the sense that it doesn't produce executable Haskell code)
16:26:21 <FunctorSalad> I don't quite remember what TH does if you reify types containing type variables... but it's not what meets the eye
16:26:42 <[swift]> but anyhow we can pick this up later
16:26:44 <FunctorSalad> (the vars have uniquifying tags, but I don't remember the exact scheme)
16:27:13 <FunctorSalad> ah, seems like you mean a different prob
16:27:31 <FunctorSalad> I meant "a" vs "a102040"
16:28:11 <aavogt> appparently not, since implicit params aren't in scope for the quasiquoter, and you can't bind them in Exp yet (probably ever)
16:28:51 <aavogt> as in: ?b is never in scope: q = QuasiQuoter { quoteExp = \_ -> if ?b then stringE "yes" else stringE "no" }
16:29:48 <aavogt> which is to be expected given how early the qq is expanded
16:31:19 <orclev> is there a structure like a list but that can hold differently typed data?... I want something like [Char]:Foo:Bar:[]
16:31:58 <aavogt> a tuple
16:32:09 <orclev> aavogt: I also want variable length
16:32:16 <zachk> HList
16:32:30 <orclev> ok, I'll go take a look at HList
16:32:32 <aavogt> or tag the members such that they have the same length
16:33:03 * aavogt should prod somebody to get another release of hlist out
16:33:23 <aavogt> since docs are important
16:33:27 <Axman6> oyou don't want HList, and you don't want what you're asking for
16:33:39 <Axman6> orclev*
16:33:49 <FunctorSalad> hehehe
16:33:54 <FunctorSalad> bad experiences?
16:33:55 <FunctorSalad> ;)
16:34:06 <dcoutts_> edwardk, Gracenotes: btw, what timezone are you two in?
16:34:24 <Axman6> FunctorSalad: badly typed ;)
16:34:56 <Gracenotes> I'm in EST, though my sleep schedule doesn't always reflect that
16:35:23 <FunctorSalad> Axman6: with hlist
16:35:37 <Gracenotes> dcoutts_: I've been meaning to poke edwardk on IRC, though he's just idled for a day or two
16:35:40 <Axman6> yes
16:35:49 <aavogt> what happened?
16:36:23 <dcoutts_> Gracenotes: we should probably pick a channel for general discussion, eg -overflow or -soc
16:36:24 <Axman6> me?
16:36:31 <aavogt> yes you
16:36:46 <Gracenotes> -overflow works great if no one else is using it
16:37:00 <FunctorSalad> you would like -in-depth
16:37:04 <Gracenotes> and others in the channel could comment, as well
16:37:05 <Axman6> i've never used it, but the general advice is you don't need HList
16:37:25 <aavogt> you don't need most things
16:37:31 <FunctorSalad> hehehe
16:37:56 <Axman6> aavogt: and that you probably don't want it either
16:37:57 <orclev> I'm trying to pass arbitrary data into a template loading function... I tried a list at first, but of course not everything is the same type
16:37:58 <dcoutts_> Gracenotes: or perhaps #hackage is most appropriate! :-)
16:38:05 <ddarius> dcoutts: edwardk is also EST, though he stays up rather late.
16:38:07 <Gracenotes> quizas, quizas
16:38:12 <dcoutts_> ddarius: ta
16:38:18 <Axman6> orclev: do you have specific types?
16:38:37 <Gracenotes> ah, really. There have been multiple times in the past when I've ended up sleeping between 12PM-8PM
16:38:56 * dcoutts_ just got up at 10pm
16:39:01 <orclev> Axman6: yes and no... for now, it's all strings and one project specific data type, but in the future other types might be called for
16:39:02 <Gracenotes> hopefully can keep it more under-control, but there is a nightwards tendency
16:39:16 <dcoutts_> I'm working nights on my thesis at the moment
16:39:21 <Axman6> orclev: well make an ADT which hold the types you need
16:39:28 <orclev> Axman6: using HStringTemplate, so they all need to be instances of ToSElem
16:39:39 <orclev> Axman6: ADT?
16:39:44 <orclev> oh
16:39:47 <orclev> algebraic data type
16:39:48 <Axman6> algebraic data type
16:40:15 <Axman6> and add new constructors when you need to add new types
16:40:37 <aavogt> hlist provides a proper record system which you are trying to emulate here quite likely
16:41:13 <orclev> Axman6: hmm... that would make the template loading function messy with a bunch of guards for all the different constructors
16:41:17 <aavogt> but there is lots of sugar in favor of using haskell's weak records
16:41:50 <orclev> aavogt: weak records?
16:41:58 <Axman6> orclev: guards? why not pattern matching?
16:42:16 <aavogt> orclev: stuff like   data T = T { x,y,z :: String }
16:42:26 <aavogt> I'm using weak as an insult
16:43:16 <orclev> Axman6: eh, meant pattern matching... anyway, point is I'd have to keep the function in line with the data type, and every time I changed a template I'd need to update the data type and the function
16:43:53 * Axman6 isn't sure what orclev is actually trying to do, but it doesn't sound well thought out
16:45:34 <orclev> I've got a function called loadTemplate :: String -> [(String, a)] -> ServerPartT IO Response.... it takes a template name, an array of name value pairs to feed to HStringTemplate, and returns the loaded template as a Happstack response
16:45:47 <orclev> only the array doesn't work
16:45:56 <orclev> s/array/list/
16:46:47 <aavogt> do you only do one thing to the 'a' in the list?
16:47:40 <orclev> aavogt: yes, it's passed pretty much directly to another function
16:48:07 <orclev> @hayoo renderTemplateGroup
16:48:07 <lambdabot> Unknown command, try @list
16:48:10 <orclev> hmm
16:48:16 <orclev> @hoogle renderTemplateGroup
16:48:16 <lambdabot> No results found
16:49:14 <SubStack> > map (id &&& ("meowing " ++)) $ words "cats dogs owls"
16:49:15 <lambdabot>   [("cats","meowing cats"),("dogs","meowing dogs"),("owls","meowing owls")]
16:49:23 <aavogt> omg
16:52:30 <orclev> aavogt: ?
16:53:08 <b4taylor> Anyone use arch here?
16:53:22 <Axman6> dons does, as do quite a few others
16:53:37 <orclev> b4taylor: I am, but I'm not that familiar with it yet, mostly just use yaourt for everything
16:53:54 <b4taylor> Indeed as dons is the one that started up cabal2arch and whatnot I believe.
16:54:09 <b4taylor> orclev: You really shouldn't use yaourt if you're also installing Haskell packages.
16:54:22 <b4taylor> yaourt doesn't handle the provides field properly.
16:54:32 <b4taylor> orclev: I've had alot of success with packer.
16:54:35 <orclev> b4taylor: I don't install haskell stuff with yaourt, I just use cabal
16:54:42 <b4taylor> Ah good show.
16:55:01 <b4taylor> Anyways, I was just wondering how I should, when I install haskell packages, compile them with profiling support.
16:55:07 <b4taylor> Should I just edit the package builds?
16:56:30 * orclev wonders if he's doing something so dumb it killed aavogt from apoplexy...
16:57:05 <aavogt> orclev: http://codepad.org/KTSpfnQp
16:57:48 <aavogt> you can do that for collecting up lists of things which all support the same class, but are different types
16:58:25 <SubStack> I like to define an operator ==> for that
16:58:31 <SubStack> reminds me of perl hashes
16:58:54 <aavogt> the alternative is:   data Showable = forall a. Show a => Showable a -- which is less pretty if you do much manipulation since it forces explicit pattern matches
16:59:43 <aavogt> b4taylor: there's just another flag for cabal install, which you can put in the config file
17:00:39 <aavogt> though there's no simple way to say, rebuild everything necessary to allow profiling xyz library
17:00:49 <aavogt> other than removing everything first
17:01:49 <b4taylor> hmmm
17:03:36 * hackagebot NonEmptyList 0.0.5 - A list with a length of at least one.  http://hackage.haskell.org/package/NonEmptyList-0.0.5 (TonyMorris)
17:05:02 <halberd> what is the usefulness of a non-empty list?
17:05:24 <aavogt> orclev: but in any case, that interface for hstringtemplate isn't typed at all, so you can't see the benefits of hlist without somehow being able to read your template file at compile time...
17:05:39 <aavogt> halberd: head is safe
17:06:10 <blackdog> hm. thinking of stealing his thunder and coming out with a list of length at least 2...
17:06:17 <blackdog> it's one better!
17:06:38 <halberd> but once you take head what do you get
17:06:41 <halberd> just a regular list?
17:06:47 <halberd> er i mean tail
17:06:52 <andyjgill> Does anyone know what/where the Haskell *constructor*  '*' is? I see it on my profile.
17:07:29 <aavogt> where it that identifier valid as a constructor?
17:07:56 <dibblego> Maybe is a list with a length of at most 1
17:08:15 <orclev> doesn't the profiler use * for things that don't belong to a cost center?
17:08:33 <andyjgill> aavogt: yes, where *is* it valid?
17:08:44 <andyjgill> orclev: good question.
17:08:47 <pickles> greetings fellow haskellians
17:09:39 <pickles> pickles: geeze, way to kill a room
17:09:48 <pickles> pickles: shut up, they'll hear you!
17:12:18 <blackdog> hm. haskellians?
17:13:19 <pickles> blackdog: you no like?
17:13:41 <blackdog> i've always liked "haskellites"
17:13:48 <blackdog> although haskellers is more common
17:13:56 <blackdog> haskellites has that whole monkish devotion thing
17:14:08 <pickles> mm tru, it does
17:14:29 <pickles> yeah, haskellian sounds more like some sort of hell raizer doesn't it
17:14:56 <pickles> maybe if we ever got a programming biker gang going or something
17:15:06 <Mathnerd314> "haskelops"?
17:15:29 <Mathnerd314> though that sounds too much like IRC
17:15:29 <blackdog> Mathnerd314: for one-eyed haskell fans?
17:15:46 <pickles> haskel + develop = haskelop?
17:16:01 <Mathnerd314> oh, I meant haskellot
17:16:21 <pickles> ah, like zealot
17:17:35 <aavogt> haskelloid
17:17:57 <blackdog> a haskelloid's just an endofunctor in the category of programmers?
17:18:10 * blackdog knows _no_ category theory. barely enough jargon to bluff.
17:18:12 <Mathnerd314> haskellites
17:18:27 <Mathnerd314> wait, that's what blackdog said
17:18:51 <aavogt> haskones
17:18:54 <Mathnerd314> haskellati
17:18:56 <idnar> is haskelop a pure functional antelope?
17:19:06 <aavogt> lop rabbit
17:19:39 <Mathnerd314> of the genus /haskelli/
17:20:09 <ddarius> blackdog: The use of -oid in mathematics seems completely unsystematic.
17:20:49 <blackdog> ddarius: good, i can feel comfortable in my sloppiness then.
17:21:41 <Mathnerd314> monoid, groupoid, ... can't think of any others off the top of my head
17:21:43 * pickles thinks it must have a been slow conversation when he came in since this topic has lasted so long
17:22:02 <pickles> Mathnerd314: try the bottom of your head then?
17:22:16 <idnar> blackdog: zygoloid!
17:22:29 <pickles> *been a
17:22:37 * pickles is slow too apparently
17:23:12 <Mathnerd314> bottom of my head is wikipedia: quantaloid, setoid, and R-algebroid
17:23:33 <pickles> algebroid? now they're just making things up... more so than usual
17:23:45 <ddarius> Mathnerd314: Matroids as well.
17:23:56 <ddarius> Also groupoid has two distinct meanings.
17:24:02 <pickles> Metroid?
17:24:07 <ddarius> And there are allegedly ringoids as well.
17:24:21 <idnar> *Super* Metroid
17:24:40 <idnar> pickles: isn't mathematics all about making things up?
17:24:47 <Mathnerd314> apparently there's a game called "Oids"
17:24:52 <systemfault> Metroid Fusion sounds like a math term :P
17:25:29 <idnar> more like a compiler optimisation
17:25:42 <systemfault> stream fusion++
17:25:47 <blackdog> more like a video game
17:26:10 <blackdog> the 17th version, when they get tired of calling it Metroid $number
17:26:19 <idnar> blackdog: that's what it /is/, not what it /sounds like/
17:27:12 <FunctorSalad> 'matroids' are math
17:27:24 <pickles> idnar: i would think mathematics is about discovering the innate relationships of the universe and other abstract concepts then putting silly, vaguely greek- or latin-sounding names to them
17:27:34 <FunctorSalad> (and have like 3000 equivalent definitions which I mix up)
17:27:39 <ddarius> blackdog: The metroids are mostly unnumberred.
17:28:06 <FunctorSalad> 'independence system where all maximal sets have equal size' is one I think
17:28:26 <pickles> Metroid ~N(0,inf)
17:28:34 <pickles> (pick  a number)
17:29:02 <FunctorSalad> pick another number
17:29:04 <idnar> pickles: "discovering" is just another word for "making stuff up" :)
17:29:10 <pickles> aha, tru tru
17:30:15 <ddarius> idnar: Like when Columbus (re)discovered America.
17:31:49 <blackdog> idnar: facts are stupid things:)
17:32:10 <FunctorSalad> pickles: better a greek letter than "meaningful identifiers" that get so large that any algebraic laws become unrecognizable ;o
17:32:22 <FunctorSalad> *reflex counterrant*
17:32:30 <idnar> ddarius: exactly
17:33:13 <FunctorSalad> "Appendoid". nuff said? ;)
17:34:24 <pickles> Adenoid
17:35:01 <pickles> FunctorSalad: yeah, mathematical naming with versioning numbers?
17:35:11 <pickles> yipe
17:35:28 <Cale> pickles: When you're talking about "relationships of the universe", it makes me think that you've confused mathematics with physics
17:36:08 <idnar> Cale: I was thinking sociology
17:36:20 <pickles> Cale: i think math and physics are intertwined somewhat
17:36:28 <systemfault> Haskell seems to have a bad reputation of being for mathematicians only... I love it but sucks at math, am I normal? :/
17:36:47 <idnar> systemfault: that's just a vicious rumour spread by maths haters ;)
17:36:55 <systemfault> :)
17:37:16 <Mathnerd314> programming == math (secretly)
17:37:21 <idnar> systemfault: actually, I suspect Haskell annoys some programmers because it's too mathy, and annoys mathematicians because it's not mathy enough
17:37:26 <Cale> pickles: Only in that physicists use mathematics.
17:38:00 <jacobian> maths = bad
17:38:11 <pickles> Cale: i suppose you're right, the physics just behaves according to math models, but the math doesn't necessarily depend on physics
17:38:19 <pickles> (forgive me, i spoke in haste earlier)
17:38:36 <jacobian> well, maths has been created by physicists in some instances
17:38:40 <pickles> *math doesn't depend on physics
17:38:41 <jacobian> And some maths is empirical
17:38:55 <FunctorSalad> systemfault: surely you can't totally suck at the more symbolical branches if you love haskell
17:39:02 <pickles> i think that's what i was trying to get at -- the discovery of math relationships through physics research
17:39:09 <FunctorSalad> at geometry, maybe
17:39:18 <pickles> even tho those relationships can be used elsewhere
17:39:24 <FunctorSalad> (or at speed calculating)
17:39:47 <idnar> maths is a very useful tool for all sorts of things
17:39:57 <idnar> so it's not surprising that those other things, in some cases, have driven the development of maths
17:40:40 <FunctorSalad> Mathnerd314: I questioned that here the other day
17:40:55 <Cale> The main difference as I see it is that physics uses the scientific method, while mathematics is not a science.
17:40:56 <Mathnerd314> which other day?
17:41:06 <Mathnerd314> ^ FunctorSalad
17:41:25 <FunctorSalad> on grounds that programming is more like math with only definitions, with the properties optional and just done in quick thoughts if at all
17:41:37 <FunctorSalad> Mathnerd314: dunno, it's an idiom :(
17:42:32 <FunctorSalad> "properties" like equalities, that is
17:43:07 <FunctorSalad> (equality sign for assignment, boolean-producing or definition doesn't count ;))
17:43:19 <Mathnerd314> hah - wait until dependent types
17:43:45 <FunctorSalad> (propositions that are just "true", not necessary to make explicit for the prog to operate)
17:43:49 <FunctorSalad> Mathnerd314: yes
17:43:52 <FunctorSalad> that's different
17:44:35 <FunctorSalad> maybe I'm comparing apples and oranges here, but isn't it a qualitative difference?
17:44:44 <FunctorSalad> even taking into account the somewhat different domains
17:45:37 <pickles> cale: much of math started out with people recognizing shared relationships in the physical world, didn't it?
17:46:53 <FunctorSalad> pickles: and inner world (the reasoning part of that, anyway ;))
17:47:07 <pickles> right
17:47:27 <FunctorSalad> collective unconscious, non-supernatural style ;)
17:47:45 <FunctorSalad> just commonalities due to common build
17:48:44 <pickles> i bet --make was used to build it
17:48:52 <ddarius> See Lakoff's and Nunez's "Where Does Mathematics Come From"
17:49:17 <FunctorSalad> haven't read it but I heard it argues from that perspective
17:49:32 <FunctorSalad> here, probably (we are so predictible ;))
17:51:13 <mamalujo_> dcoutts_: have you created any code for such a cabal replacement tool idea? or, is cabal itself to mutate in that direction?
17:51:58 <dcoutts_> mamalujo_: my intention is to develop cabal in the direction of nix-style package management
17:52:23 * gwern wonders what is going on behind the scenes here: 'return posts written in [last 5123 years]'
17:52:28 <dcoutts_> mamalujo_: nix is not a replacement, there are plenty of other things that cabal does, for example automatic dependency resolution
17:53:11 <ddarius> FunctorSalad: I've mentioned it before.
17:53:15 <mamalujo_> I see, well, interesting work, thx
17:55:12 <taybin> I've been doing the exercises in RWH.  that said:
17:55:21 <taybin> say I have data Tree a = Node a (Maybe (Tree a)) (Maybe (Tree a))
17:55:50 <taybin> why can I do
17:55:50 <taybin> let myTree = Node 1
17:55:54 <taybin> but I can't do
17:56:18 <taybin> let myTree = Node 1 (Just (Node 2)) (Just (Node 3)) ?
17:56:37 <FunctorSalad> the former isn't of tree type
17:56:41 <c_wraith> taybin: the type of myTree isn't right
17:56:42 <taybin> or rather, why does the first case work?
17:56:43 <FunctorSalad> it's a partial application
17:56:55 <FunctorSalad> try :type in ghci :)
17:57:12 <FunctorSalad> (lambdabot doesn't have this type so can't do it here)
17:57:26 <QtPlatypus> let myTree = Node 1 Nothing Nothing -- Is a tree
17:57:39 <taybin> QtPlatypus: yes, that worked too
17:57:47 <c_wraith> that has a different type
17:57:51 <FunctorSalad> :type Node 1
17:58:16 <c_wraith> follow FunctorSalad's advice, and ask ghci what the type of Node 1 is
17:58:18 <aavogt> @type Branch 1
17:58:18 <QtPlatypus> taybin: It compiled, thats diffrent to it working.
17:58:19 <lambdabot> Not in scope: data constructor `Branch'
17:58:33 <taybin> oh, so what the partial application returns is a function that I can then pass the child nodes to?
17:58:43 <c_wraith> yes
17:58:58 <c_wraith> conceptually, that's how all functions with multiple arguments work in haskell
17:59:06 <taybin> yeah, I can see that
17:59:09 <FunctorSalad> but since it's not a tree you can't  put it inside another node
17:59:12 <FunctorSalad> until it's applied
17:59:16 <c_wraith> And constructors are functions, too
17:59:32 <taybin> but to this beginner, it looked like maybe haskell was trying to be "helpful"
17:59:55 <FunctorSalad> it never lets you omit "Nothing" :)
18:00:03 <FunctorSalad> Maybe is not magic, you can define it yourself
18:00:27 <taybin> yeah, I saw the definition in the RWH book.  it was pretty simple
18:01:07 <taybin> thanks for the help
18:02:46 <FunctorSalad> *waits for someone to correct him that Maybe is the extended default for MonadPlus or whatever*
18:02:50 <FunctorSalad> ;)
18:02:55 <FunctorSalad> (that is freely made up)
18:03:09 <c_wraith> eh.  everyone ignores defaulting rules most of the time :)
18:05:23 <pickles> so, what kind of dressing would you put on a functor salad?
18:06:18 <FunctorSalad> uh... crushed pills?
18:06:32 <FunctorSalad> never tried a nonsensical answer to that
18:06:37 <FunctorSalad> (comes up often :))
18:07:00 <aavogt> > mzero
18:07:01 <lambdabot>   No instance for (GHC.Show.Show (m a))
18:07:01 <lambdabot>    arising from a use of `M7578205450...
18:07:02 <pickles> darn, and i thot i was being original
18:07:16 <pickles> now for the important question: would it have bacon bits?
18:07:31 <aavogt> FunctorSalad: what that extended default rule?
18:07:46 <FunctorSalad> aavogt: I have no idea whether there even is one for MonadPlus
18:07:52 * Eridius would put pickles on a functor salad
18:07:57 <FunctorSalad> I just wanted to confabulate a reason why Maybe could be special
18:08:04 <aavogt> @check \x -> x == reverse x
18:08:05 <lambdabot>   "OK, passed 500 tests."
18:08:14 <aavogt> that's extended defaulting
18:08:38 <FunctorSalad> pickles: but... isn't that unhealthy? :o
18:09:18 <pickles> FunctorSalad: depends on how often you eat it :-P
18:09:28 <FunctorSalad> the same instance? o_O
18:09:40 <FunctorSalad> sorry I'm having a run of randomness somehow
18:09:54 <pickles> heheh, that just show's that im catching
18:09:59 <pickles> Eridius: i've never had pickles on a salad... can't think of a salad i might try it on
18:10:09 <FunctorSalad> aavogt: "extended" isn't about types but about functions? is that what you're saying?
18:10:36 <aavogt> no, it's about sending type variables to ()
18:10:40 <FunctorSalad> *about lifting to function types
18:10:46 <FunctorSalad> ahhh
18:11:01 <aavogt> > show undefined
18:11:02 <lambdabot>   "*Exception: Prelude.undefined
18:11:11 <FunctorSalad> I never used defaulting intentionally, as you pointed out :)
18:11:14 <FunctorSalad> except for integers
18:11:49 <FunctorSalad> my nomono-snippet sees very fast use usually ;)
18:12:17 <aavogt> hmm?
18:12:20 <FunctorSalad> (hmm maybe that's not enough to disable defaulting)
18:12:32 <twink> You can make the defaulting list empty.
18:12:45 <twink> default () or something like that at the top level.
18:12:49 <c_wraith> my favorite example of poor defaulting:
18:12:59 <c_wraith> @check \x -> x == reverse x
18:13:00 <lambdabot>   "OK, passed 500 tests."
18:13:05 <FunctorSalad> nevermind, the point was choosing a type due to ambiguous typeclass instance
18:13:13 <FunctorSalad> full polymorphism doesn't save me there
18:13:50 <c_wraith> [()] is not the most useful default type for a list. :)
18:14:24 <aavogt> twink: default applies to Num though
18:14:37 <FunctorSalad> I was just confusing the DMR with the fact that with a class like, say, Arbitrary, you need to commit to a monotype with or without DMR
18:14:50 <twink> I presumed defaulting was involved.
18:14:59 <aavogt> is that da monomorphism restriction?
18:15:12 <FunctorSalad> no, I was confused as I said :)
18:15:20 <c_wraith> @check \x -> x == reverse (x :: [[()]])
18:15:21 <lambdabot>   "Falsifiable, after 2 tests:\n[[(),(),()],[()],[(),(),(),()]]\n"
18:16:19 <Eridius> @check \x -> x == reverse (x :: [Char])
18:16:20 <lambdabot>   "Falsifiable, after 2 tests:\n\"\\557394\\768199\"\n"
18:16:23 <FunctorSalad> the DMR doesn't rely on typeclasses I think, it's just about "non-function values" not being automatically polymorphic
18:16:45 <FunctorSalad> so you don't get caught by surprise when your "constant" is implemented by a function (dict-passing)
18:17:17 <FunctorSalad> hmm but that's typeclasses again
18:17:42 <FunctorSalad> non-typeclass example other than bottom?
18:17:51 <aavogt> @let __ = __
18:17:53 <lambdabot>  Defined.
18:17:56 <aavogt> @type __
18:17:57 <lambdabot> forall t. t
18:18:05 <FunctorSalad> that's bottom :)
18:19:00 <FunctorSalad> "<aavogt> is that da monomorphism restriction?" <-- oops, you mean the 'd'
18:19:05 <FunctorSalad> DREADED
18:19:48 <aavogt>  -XNo substitutes all values with  (error "no")
18:20:34 <FunctorSalad> if DMR applies to tuples too, you could have a polymorphic "constant"  other than bottom, without typeclasses, I guess
18:20:47 <FunctorSalad> which would get forced to mono by the MR
18:22:27 <FunctorSalad> *gives it up, decides he would have to read what exactly the constant types to which MR can apply are*
18:23:43 <FunctorSalad> "constant type" in contrast to "function type" not to "varying type"
18:25:09 <FunctorSalad> function types *are* immune to MR, right? before I embarass myself further
18:29:25 <aavogt> FunctorSalad: function types that look like values are restricted
18:29:56 <FunctorSalad> ahhh, like "f = g &&& h"?
18:30:22 <FunctorSalad> I do remember something about eta changing meaning int he presence of MR o_o
18:31:19 <Cale> Just in that it affects how types are inferred though. If you give explicit type signatures, it makes no difference
18:32:14 <FunctorSalad> yes
18:45:09 <dolio> Wow, c.h.o is still down.
18:47:26 <ologNation> How many different lists of numbers from [1..5] add up to five?
18:47:31 <ologNation> [1,1,1,1,1]
18:47:33 <ologNation> [5]
18:47:36 <ologNation> Those are obvious.
18:47:50 <ologNation> [4,1]
18:47:53 <ologNation> I don't care about ordering.
18:48:05 <ologNation> so [4,1] and [1,4] are the same.
18:48:13 <ologNation> but [3,2] and [3,1,1] are different.
18:48:36 <ologNation> It's fun.
18:48:44 <ologNation> It's a problem which is easy to state,
18:48:48 <ologNation> but it's not what you think.
18:48:56 <ologNation> I don't think you could do it using recursion.
18:49:16 <djahandarie> "I don't think you could do it using recursion"
18:49:17 <djahandarie> lol
18:49:25 <aavogt> if ordering doesn't matter, change your representation
18:49:25 <dolio> You can definitely do it using recursion.
18:49:56 <bd_> it's quite simple. Go from n..1; tack it onto the start of the list, then recurse, searching only for elements equal to or smaller than the inpu
18:51:09 <djahandarie> Well, if you can argue it isn't computable...
18:51:30 <ologNation> djahandarie, You could.
18:51:42 <ologNation> But it's not what you'd think.
18:51:50 <drhodes> 11111,1112,113,14,2111,212,23,311,32,41,5 ?
18:51:58 <ologNation> not bad.
18:52:06 <dolio> That has a duplicate.
18:52:12 <djahandarie> ologNation, that was a joke, its pretty clearly computable.
18:52:29 <ologNation> It's computable, but it's runtime complexity is exponential, which I think is unexpected.
18:52:46 <drhodes> dolio: yeah, wanted to keep the pattern there
18:53:18 <djahandarie> ologNation, even taking a dynamic programming approach?
18:53:21 <byorgey> ologNation: these are known as "integer partitions".
18:54:03 <ologNation> What I meant to say is that there is no very simple relationship between the partitions of 4 and the partitions of 5.
18:54:13 <bd_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25180#a25180
18:54:26 <bd_> simple enough to compute recursively
18:55:04 <byorgey> djahandarie: no, the number of partitions grows exponentially in the number being partitioned
18:55:12 <bd_> also, all sumsets of 4 exist as a subset of one of the sumsets of 5
18:55:17 <byorgey> so you need exponential time just to print out all the partitions.
18:55:17 <bd_> for obvious reasons
18:55:52 <djahandarie> byorgey, well, what if the printing of all the partitions is a black box?
18:56:19 <bd_> djahandarie: you still need to pass it an exponential number of partitions, which takes exponential time
18:56:59 <ologNation> If someone handed me the partitions of 4, I cannot easily put them together to get partitions of 5.
18:57:03 <byorgey> I suppose you could hope to compute the list of all possible partitions using lots of sharing in subexponential time.
18:57:08 <ologNation> Okay, guys.  I take it back.
18:57:12 <ologNation> Gimme a break.
18:57:44 <byorgey> ologNation: take what back?  It's definitely an interesting problem.
18:57:49 <ologNation> byorgey, That sounds interesting.
18:57:54 <bd_> ologNation: also, I suspect that the relation is as follows: sumsets n = nub $ cocatMap (\n' -> map (\l -> (n-n'):l) sumsets n')
18:58:07 <ologNation> Hmm..
18:58:34 <djahandarie> cocat
18:58:36 <byorgey> ologNation: it does satisfy some nice recurrences, but you can't compute the partitions of 5 from JUST the partitions of 4.
18:58:38 <djahandarie> Is that like a comonad?
18:58:49 <ologNation> bd_, Can you paste that as working code?
18:59:04 <ologNation> byorgey, I think that's a good way of saying what I meant.
18:59:08 <bd_> ologNation: stick a sumsets 0 = [[]] above and there you go. Horrible running time from the nub though.
18:59:20 <bd_> and the recursive calling of an exponential-time function :)
18:59:25 <byorgey> what you want is a dynamic programming-like solution as djahandarie suggested, where you keep track of the ways to partition n into pieces of size at most k for each pair (n,k)
18:59:59 <bd_> also s/cocat/concat/ :)
19:00:32 <bd_> wait hm.
19:00:39 <Cale> > let partitions' k n | n <= 0 = [[]]; partitions' k n | k <= 0 = []; partitions' k n = [x:xs | x <- [k,k-1..1], xs <- partitions' x (n-x)] in partitions' 5 5
19:00:39 <byorgey> and if you only want to count the *number* of partitions, as opposed to actually computing the partitions themselves, there are some very elegant recurrences discovered by Euler and others
19:00:40 <lambdabot>   [[5],[4,4],[4,3],[4,2],[4,1],[3,3],[3,2],[3,1,1],[2,2,2],[2,2,1],[2,1,1,1],...
19:00:45 <Cale> errr
19:00:52 <byorgey> hmmmm
19:01:09 <Cale> > let partitions' k n | n == 0 = [[]]; partitions' k n | k <= 0 || n < 0 = []; partitions' k n = [x:xs | x <- [k,k-1..1], xs <- partitions' x (n-x)] in partitions' 5 5
19:01:10 <lambdabot>   [[5],[4,1],[3,2],[3,1,1],[2,2,1],[2,1,1,1],[1,1,1,1,1]]
19:01:15 <Cale> yeah, there we are
19:01:20 <byorgey> that's better =)
19:02:04 <bd_> nevermind, my recurrence does appear to be incomplete
19:02:35 <Cale> You actually probably could define partitions n in terms of partitions (n-1) alone, if you were careful.
19:02:55 <bd_> Cale: trivially so, since you can determine the value of n-1 and compute it directly :)
19:03:06 <Cale> You just need to determine the valid points at which to add 1.
19:03:18 <bd_> ologNation: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25180#a25181
19:03:41 <Cale> Which is at the start of each block of equal elements, or at the end.
19:03:45 <byorgey> Prelude Math.Combinatorics.Species> map (fmap (length . getSet) . unComp) (enumerateU partitions 5 :: [Comp Set Set ()])
19:03:48 <byorgey> [{5},{2,3},{1,4},{1,2,2},{1,1,3},{1,1,1,2},{1,1,1,1,1}]
19:04:05 <tommd> preflex: seen dons
19:04:05 <preflex>  dons was last seen on #haskell 8 hours and 23 seconds ago, saying: jlouis: great post, again, btw. rereading it a 3rd time and still find good stuff.
19:05:13 <Cale> of course, that leaves you with annoying repetition that needs to be eliminated
19:07:06 <fryguybob> > let partitions' k n | n == 0 = [[]]; partitions' k n | k <= 0 || n < 0 = []; partitions' k n = [x:xs | x <- [k,k-1..1], xs <- partitions' x (n-x)] in map length $ map (\x -> partitions' x x) [1..]
19:07:10 <lambdabot>   mueval-core: Time limit exceeded
19:08:01 <fryguybob> > let partitions' k n | n == 0 = [[]]; partitions' k n | k <= 0 || n < 0 = []; partitions' k n = [x:xs | x <- [k,k-1..1], xs <- partitions' x (n-x)] in take 20 $ map length $ map (\x -> partitions' x x) [1..]
19:08:02 <lambdabot>   [1,2,3,5,7,11,15,22,30,42,56,77,101,135,176,231,297,385,490,627]
19:11:13 <benl23> Is there a code.haskell.org admin around? I can login to the machine but there is no web or trac. The apache process is running though...
19:12:27 <dcoutts_> benl23: sigh
19:13:18 <fryguybob> ?oeis 1,2,3,5,7,11,15,22,30,42,56,77,101,135,176,231,297,385,490,627
19:13:19 <lambdabot>  a(n) = number of partitions of n (the partition numbers).
19:13:19 <lambdabot>  [1,1,2,3,5,7,11,15,22,30,42,56,77,101,135,176,231,297,385,490,627,792,1002,1...
19:13:25 <dcoutts_> benl23: try now
19:13:45 <dcoutts_> benl23: it often goes awol like that, we're planning to move the community server onto sparky which is much less memory constrained
19:14:13 <dcoutts_> the current puny virtual server has ~500Mb ram
19:14:14 <benl23> dcoutts_: ok thanks, it's back but v.slow
19:14:17 <benl23> erk
19:14:23 <benl23> where is community hosted atm?
19:14:28 <benl23> on a commercial server?
19:14:41 <dcoutts_> cheapo commercial virtual server host
19:14:48 <benl23> nasty
19:15:02 <dcoutts_> haskell.org isn't that rich :-)
19:15:37 <Cale> > [exp (pi * sqrt (2/3 * n)) / (4 * sqrt 3 * n) | n <- [1..]]
19:15:38 <lambdabot>   [1.8766704226053694,2.7151604315612023,4.090511993628218,6.100095666405725,...
19:15:47 <benl23> dcoutts_: Yitzchak Gale was trying to contact you wrt moving community -> sparky
19:15:57 <benl23> said you were buried under thesis though...
19:16:02 <dcoutts_> benl23: oh thanks, I didn't know
19:16:16 * dcoutts_ notes the financial issues are more to do with organisation
19:16:23 <benl23> There's been some email back and forth regarding the move
19:16:38 <dcoutts_> oh, hmm, I clearly missed it
19:16:50 <benl23> will fwd you
19:16:53 <dcoutts_> ta
19:18:00 <dcoutts_> benl23: perhaps if you've time, you might like to help organise haskell.org joining the SFC, it's something several of us have disused a fair bit but never really got going on
19:18:13 <dcoutts_> people are so busy
19:18:14 <benl23> what's SFC?
19:18:22 <dcoutts_> Software Freedom Conservancy
19:18:26 <dcoutts_> darcs joined recently
19:18:37 <benl23> hrm, don't know anything about it.. will have to read.
19:18:44 <dcoutts_> gives a legal umbrella, lets you hold accounts
19:18:53 <byorgey> > [round $ exp (pi * sqrt (2/3 * n)) / (4 * sqrt 3 * n) | n <- [1..]]
19:18:54 <lambdabot>   [2,3,4,6,9,13,18,26,35,48,65,87,115,152,199,258,333,427,545,692,875,1102,13...
19:18:57 <dcoutts_> benl23: provides a little legal status and protection
19:19:06 <benl23> ok, I'll look into it
19:19:50 <dcoutts_> benl23: Ian, Malcolm, me and the Simons discussed it a while ago, all generally positive. Needs someone to push it. I can forward old emails if you're interested.
19:20:28 <benl23> dcoutts_: ok. fwd me them
19:20:40 <Cale> > partitionsOdd k 0 = [[]]; partitionsOdd k n | k <= 0 || n < 0 = []; partitionsOdd k n = [x:xs | x <- [m,m-2..1], xs <- partitionsOdd x (n-x)] where m = if odd k then k else k-1 in [length (partitionsOdd k k) | k <- [0..]]
19:20:41 <lambdabot>   <no location info>: parse error on input `='
19:20:44 <Cale> > let partitionsOdd k 0 = [[]]; partitionsOdd k n | k <= 0 || n < 0 = []; partitionsOdd k n = [x:xs | x <- [m,m-2..1], xs <- partitionsOdd x (n-x)] where m = if odd k then k else k-1 in [length (partitionsOdd k k) | k <- [0..]]
19:20:45 * dcoutts_ will try to remember to do so when he gets home
19:20:48 <lambdabot>   mueval-core: Time limit exceeded
19:20:54 <Cale> > let partitionsOdd k 0 = [[]]; partitionsOdd k n | k <= 0 || n < 0 = []; partitionsOdd k n = [x:xs | x <- [m,m-2..1], xs <- partitionsOdd x (n-x)] where m = if odd k then k else k-1 in [length (partitionsOdd k k) | k <- [0..20]]
19:20:55 <lambdabot>   [1,1,1,2,2,3,4,5,6,8,10,12,15,18,22,27,32,38,46,54,64]
19:21:43 <fryguybob> ?oeis 1,1,1,2,2,3,4,5,6,8,10,12,15,18,22,27,32,38,46,54,64
19:21:44 <lambdabot>  Expansion of Product_{m=1..infinity} (1 + x^m); number of partitions of n in...
19:21:44 <lambdabot>  [1,1,1,2,2,3,4,5,6,8,10,12,15,18,22,27,32,38,46,54,64,76,89,104,122,142,165,...
19:21:46 <Cale> > let partitionsDistinct k 0 = [[]]; partitionsDistinct k n | k <= 0 || n < 0 = []; partitionsDistinct k n = [x:xs | x <- [k,k-1..1], xs <- partitionsDistinct (x-1) (n-x)] in [length (partitionsDistinct k k) | k <- [0..20]]
19:21:47 <lambdabot>   [1,1,1,2,2,3,4,5,6,8,10,12,15,18,22,27,32,38,46,54,64]
19:21:55 <byorgey> =)
19:22:37 <systemfault> > putStr "Stop abusing me!!!!!"
19:22:38 <lambdabot>   <IO ()>
19:22:39 <fryguybob> Just learned about oeis today, nice work :D
19:22:44 <systemfault> :(
19:23:40 <pickles> > ['a','b','c','d']
19:23:40 <Cale> The number of partitions of n into distinct parts is equal to the number of partitions of n into odd parts :)
19:23:41 <lambdabot>   "abcd"
19:23:46 <byorgey> Cale: have you seen the generalization of that bijection to partitions avoiding certain subpartitions?
19:23:49 <pickles> HAHAHAHAHA PRINT!
19:24:17 <pickles> can't believe it took me this long to think that
19:24:27 <byorgey> it's a really astounding and beautiful result
19:24:30 <fryguybob> > "string"
19:24:31 <lambdabot>   "string"
19:24:36 <Cale> byorgey: I've seen a number of variations of things like that, but I'm not sure if I know what you mean
19:24:57 <byorgey> Cale: I don't quite remember what I mean either, I could look up the details if you're interested =)
19:25:09 <byorgey> learned about it in my combinatorics class last semester
19:26:13 <Cale> The number of partitions of n where any part occurs not at all, 2, 3, or 5 times, is equal to the number of partitions of n with parts congruent to 2,3,6,9, or 10 modulo 12
19:26:16 <Cale> Things like that?
19:27:09 <byorgey> Cale: the result I'm thinking of is more general, like "the number of partitions of n which avoid subpartitions in set X is equal to the number of partitions which (something)"
19:27:19 <byorgey> freely parameterized by X
19:27:25 <Cale> hmm
19:27:42 <byorgey> which subsumes particular results like the one you said
19:28:48 <Cale> @let partitions' k n | n == 0 = [[]]; partitions' k n | k <= 0 || n < 0 = []; partitions' k n = [x:xs | x <- [k,k-1..1], xs <- partitions' x (n-x)]
19:28:50 <lambdabot>  Defined.
19:29:01 <Cale> @let partitions n = partitions' n n
19:29:02 <lambdabot>  Defined.
19:29:56 <byorgey> Cale: my notes are at school, I'll see if I can find you a link tomorrow
19:30:34 <Cale> @check (\n -> n < 0 || (length . filter (== 1) . concat . partitions $ n) == (length . group . partitions $ n)
19:30:34 <lambdabot>  Unbalanced parentheses
19:30:40 <BMeph> jlouis: Cheers! Enjoyed your blogage yesterday. :)
19:30:40 <Cale> @check \n -> n < 0 || (length . filter (== 1) . concat . partitions $ n) == (length . group . partitions $ n)
19:30:41 <lambdabot>   Not in scope: `partitions'Not in scope: `partitions'
19:30:45 <Cale> oh, right
19:30:50 <djahandarie> Haha
19:31:02 <Cale> > [(length . filter (== 1) . concat . partitions $ n) == (length . group . partitions $ n) | n <- [1..10]]
19:31:04 <lambdabot>   [True,True,False,False,False,False,False,False,False,False]
19:31:06 <Cale> hmm
19:31:36 <Cale> > partitions 5
19:31:37 <lambdabot>   [[5],[4,1],[3,2],[3,1,1],[2,2,1],[2,1,1,1],[1,1,1,1,1]]
19:31:43 <Cale> oh, right :P
19:31:59 <Gracenotes> http://www.scannedinavian.com/~shae/lift-concat.jpg
19:32:00 <Cale> > [(length . filter (== 1) . concat . partitions $ n) == (sum . map (length . group) . partitions $ n) | n <- [1..10]]
19:32:02 <lambdabot>   [True,True,True,True,True,True,True,True,True,True]
19:32:06 <Cale> there we go :)
19:32:16 <Cale> > and [(length . filter (== 1) . concat . partitions $ n) == (sum . map (length . group) . partitions $ n) | n <- [1..50]]
19:32:20 <lambdabot>   mueval-core: Time limit exceeded
19:33:34 <pickles> > "\b> \"hello\""
19:33:34 <lambdabot>   "\b> \"hello\""
19:34:09 <pickles> nite all
19:35:09 <cads> hey I'm looking at the hmatrix cabal code and I note that it's set to a custom build-type. The configure script, however, simply runs a haskell file which determines where some libraries are located on the system, and write this info to a buildinfo file. In the interest of getting the package to install without modification on windows, I was wondering if there is a way to move this code to the setup.hs file.
19:36:17 <cads> I'm not quite familiar with how a simple build-type would work - would the isntall.hs file be able to write the buildinfo file before the library was built and linked?
19:36:47 <dcoutts_> cads: yes, it should be moved into the Setup.hs file
19:37:02 <cads> thanks dcoutts_
19:37:17 <dcoutts_> cads: there is no need for buildinfo files, those are just for the benefit of ./configure shell scripts
19:37:37 <dcoutts_> cads: Haskell code in the Setup.hs can pass the information directly, without needing to go via text files
19:40:23 * hackagebot repa 1.0.0.0 - High performance, regular, shape polymorphic parallel arrays.  http://hackage.haskell.org/package/repa-1.0.0.0 (BenLippmeier)
19:42:33 <cads> dcoutts_ thanks for your help with --extra-lib-dir options earlier - I was able to make the install process much smoother in windows
19:42:47 <dcoutts_> cads: excellent
19:43:35 <dcoutts_> cads: I take it you help maintain the hmatrix package?
19:44:26 <cads> I just recently got into contact with the author of the package and we've been working a little on making windows support seamless
19:44:44 <dcoutts_> I see, good
19:45:14 <cads> this is the first projected I've actually worked with cabal in, but it feels like a good start
19:45:21 <dcoutts_> cads: of course the major problem is there being no sensible automatic way to find the C libs on windows, since they all live in non-standard places
19:46:14 <dcoutts_> cads: we may eventually need to make some kind of binary packaging thing for Windows C libs
19:46:22 <dcoutts_> huge pita however
19:46:29 <ddarius> Yay repa!
19:47:04 <cads> for that I'm considering ways of arranging that instruction messages get printed telling windows users to fetch the proper library package, which is provided on hackage
19:47:21 <dcoutts_> cads: or try and use windows assemblies
19:47:47 <cads> then it would involve the user installing the library files as you say to a stable location
19:47:55 <cads> what are those?
19:48:15 <dcoutts_> cads: it's windows newer method of installing bunches of related DLLs
19:48:42 <dcoutts_> cads: rather than simply looking for DLLs in the current directory on on the $PATH
19:48:49 <dcoutts_> on on/or on
19:49:11 <cads> and it does seem like a pain, but I think it's worth it it to support windows even if it'll choose to be hard to support
19:49:18 * ddarius is kind of annoyed that L-species are not instances of Fiore and co.'s generalized species.
19:49:25 * hackagebot repa-examples 1.0.0.0 - Examples using the Repa array library.  http://hackage.haskell.org/package/repa-examples-1.0.0.0 (BenLippmeier)
19:49:39 <dcoutts_> cads: the main issue is finding windows developers to work on it
19:51:03 <dobie_gillis> i'm having some syntax issues with fields... ghc output here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25183#a25183
19:51:15 <cads> The situation is better when haskell code is solely used
19:51:45 <dcoutts_> cads: for really simple C code it's ok, eg the zlib binding just bundles all the C code and cabal compiles it.
19:51:49 <cads> and indeed, one wonders how simple java libraries would be to support on multiple operating systems if the code didn't tend to be all in java
19:52:08 <dcoutts_> cads: but it's harder for bigger C packages that need special ways of building them
19:52:56 <dcoutts_> cads: there's an MS chap who's trying to build a packaging system for open-source packages on Windows
19:53:06 <dcoutts_> I think he's using assemblies and MSI
19:53:58 <cads> I'd like to find out more about that
19:54:39 <cads> it feels like windows is wrongly left out of the open source development action out of pure spite
19:54:59 <byorgey> dobie_gillis: you shadowed the record selector play_button with your (Just play_button) binding
19:55:08 <ddarius> cads: That's ridiculous.
19:55:14 <cads> not that I have any love for windows..
19:56:24 <dcoutts_> cads: it's not spite, it's just that much harder to do
19:57:00 <dcoutts_> cads: I've found it a bit easier recently since getting virtualisation working, so no need to dual boot just to test
19:57:35 <gwern> cads: it's left out because no one really wants to dive down the windows rabbit hole
19:57:43 <dcoutts_> windows makes it really easy to make whole applications and distribute them as binary installers
19:58:03 <gwern> cads: oh and with macs, you get to maintain an entire third package/distribution/installation system.
19:58:04 <dcoutts_> but it has more or less zero support for distributing libraries
19:58:08 <byorgey> dobie_gillis: and what is thisButton?
19:58:32 <gwern> cads: if programmers really had the spare effort for all that, documentation would be better :)
19:59:42 <dcoutts_> cads: don't get me wrong, I want cabal/hackage to support windows well because half our users are there. I've tried to keep stuff portable to windows. It's just the C libs that's the major problem.
19:59:47 <dobie_gillis> byorgey: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25184#a25184   I'm working on my first large haskell program so my programming style may be a little strange
20:00:18 <dobie_gillis> thisButton is intended to be the button under the mouse position 'mp'
20:02:59 <cads> It would be nice to see some pure haskell libraries for things like GUI
20:04:19 <cads> ddarius: I still feel like there should be something like a package distribution system for windows which throws together a standardized build environment to kind of factor out windows' unruliness
20:04:34 <cads> an apt-get for windows
20:05:20 <cads> but this is unrealistic
20:06:36 <dcoutts_> cads: so something somewhat lightweight might be a separate archive of windows lib binaries indexed by the names of the libs they provide. cabal install knows what libs each package needs so it could be mapped to the binaries.
20:07:14 <dcoutts_> cads: though it also needs something to deal with the dll search path problem
20:07:32 <dcoutts_> there is the "side by side" assembly thing, but it only works for the root user
20:07:43 <dcoutts_> there's no equivalent for per-user installs sadly
20:08:21 <dcoutts_> perhaps it'd be possible to hack something up on recent windows versions using symlinks
20:08:25 <BMeph> dcoutts_, cads: Not to mention, do you use .NET in your package system, or not? :)
20:08:50 <dcoutts_> BMeph: assemblies were basically invented for .net but they can be used for native code dll too
20:10:10 <cads> I'm going to look into these assemblies for perhaps making hmatrix more automatic to install
20:10:36 <idnar> cads: apt-get was ported to win32 already ;)
20:10:41 <cads> dcoutts_ can you remember any more info about the ms guy working on the package system?
20:10:42 <BMeph> dcoutts_: Okay, but do you use .NET for more than the assembly format?
20:11:01 <cads> idnar: hah!
20:11:10 <dcoutts_> BMeph: the assembly format does not use .net, it's native tools and xml manifests
20:11:10 <cads> fantastic
20:11:21 <dcoutts_> BMeph: so no, really no use of .net at all
20:11:35 <BMeph> dcoutts_: ...exactly. ;)
20:11:39 <idnar> cads: oh god, apparently there's even a Debian port to Interix
20:12:00 * dcoutts_ has clearly missed the point BMeph was making
20:13:55 <BMeph> Maybe we should get a win32 port of Nix...any takers? ;)
20:14:25 <ManateeLazyCat> dcoutts_: Are you use GtkSocket/GtkPlug in separate processes? My code break in Gtk+ 2.20, but works fine in Gtk+ 2.18.3
20:14:28 <dcoutts_> BMeph: it'd face the same dll search path problem
20:14:35 <dcoutts_> ManateeLazyCat: no, never used it
20:14:51 <dcoutts_> ManateeLazyCat: check the gtk bug tracker
20:22:42 <cads> idnar: that actually sounds rather useful
20:23:05 <cads> as the original interix distribution apparently didn't even have bash
20:24:29 <idnar> cads: who needs bash when you have ksh!
20:25:13 <cads> idnar, gaze upon this handsome monstrosity: http://grozeille.files.wordpress.com/2006/06/CyGnome.png
20:25:15 <tensorpudding> who needs ksh when you have sh
20:25:17 * gwern wonders if I am the only one who pronounces ksh as kiss and wants to stick my tongue out and shake my head wildly
20:25:44 <gwern> oh noes - french! my mortal enemy!
20:26:19 <dancor> quiche
20:26:39 <gwern> oh french why ya gotta get gender all up in your grammar?
20:26:57 <tensorpudding> english is weird for being unisex
20:27:04 <gwern> weird - or sane?
20:27:13 <gwern> tensorpudding: quick, what is the gender of a table and why?
20:27:16 <tensorpudding> english is *hardly* sane
20:27:20 <systemfault> Une table
20:27:24 <systemfault> Feminine
20:27:32 <tensorpudding> mesa?
20:27:37 <tensorpudding> I don't remember.
20:27:46 <gwern> systemfault: that's only half the answer...
20:27:51 <tensorpudding> I don't know French.
20:27:56 <idnar> cads: *shudder*
20:28:04 <tensorpudding> Latin mensa.
20:28:10 <idnar> cads: except, it should be running in merged mode ;)
20:28:32 <gwern> tensorpudding: I was makign a general point. french makes you systematically memorize pseudorandom bits; english does so unsystematically and so is less to blame
20:28:36 <cads> I actually would prefer this over the windows interface
20:29:21 <systemfault> gwern: I don't know... really :/
20:29:23 <tensorpudding> It's better to have ad-hoc not-conforming-to-patterns stupidity than regularized follows-rules stupidity?
20:29:34 <idnar> cads: I only use Windows for gaming, so the UI isn't terribly important to me either way
20:29:34 <dancor> i think you could compare gender in romance languages and nonregular spelling in english
20:29:35 <systemfault> gwern: It just sounds weird with "un"
20:29:40 <gwern> tensorpudding: yeah, because there's less of it
20:29:45 <dancor> it terms of added unnecessary load
20:29:57 <gwern> dancor: wait, and romance languages are totally regular spelling?
20:30:15 <dancor> gwern: well spanish is way moreso
20:30:28 <tensorpudding> Spanish is a very regular language compared to English.
20:30:31 <dancor> i'm not sure about french but i think it's much better than english too
20:30:44 <cads> idnar: visualize a an ancient monk ritual for making life much harder in some unreasonable way in order to achieve purity and zen.. that is what windows use is for me :)
20:30:59 <gwern> tensorpudding: I don't know any spanish, so I won't criticize it. I'm dubious that somewhat more regular spelling makes up for a bit of randomness per noun
20:31:13 <idnar> cads: using Windows... to achieve purity and zen?!?! :P
20:31:20 <idnar> cads: that's certainly novel
20:31:32 <dancor> i guess it's hard to quantify
20:31:35 <tensorpudding> The only things English has almost no subjunctive mood remaining, and has no gender.
20:31:38 <cads> perhaps like the monk who mediates in the brothel :)
20:32:23 <gwern> tensorpudding: it were well people used the subjunctive mood more?
20:32:42 <tensorpudding> err, the only things going for English in terms of simplicity
20:33:01 <tensorpudding> Though it makes up for it by having horribly inconsistent spelling and pronunciation.
20:33:28 <dancor> at least neither uses chinese characters..
20:33:44 <tensorpudding> Chinese does have an enviable information density.
20:33:54 <gwern> tensorpudding: pity about the writing system though
20:34:21 <gwern> tensorpudding: wait, how does english nearly not have subjunctive mood left? http://en.wikipedia.org/wiki/Subjunctive_mood#The_subjunctive_in_English shows plenty of normal stuff - 'I own it'.
20:34:45 <BMeph> PWNED!
20:35:04 <cads> gwern, but it's not complete randomness now is it? the table is female, while the chairs are male, while the forks and spoons and plates are again female.
20:35:08 <dancor> 'He own it' tho?
20:35:09 <gwern> BMeph: no no, that should be 'I pwn tensorpudding'; pwned is the past tense
20:35:14 <tensorpudding> Hmm.
20:35:44 <gwern> cads: wait, how is that logical at all? why would the tableware be female? they're 'using' the table even more than the chairs
20:36:25 <dancor> why don't you just make all the nouns masculine
20:36:28 <dancor> and be like "deal with it"
20:36:54 <dancor> (was that "be" subjunctive?)
20:36:54 <cads> because then the words would sound all goofy
20:36:58 <gwern> dancor: if they're all masculine, why bother in the first place?
20:37:01 <ManateeLazyCat> dcoutts_: I'm ready to release my project, but i got this error in Gtk+ 2.20, unfortunately.
20:37:08 <dancor> gwern: i mean you could be the change
20:37:12 <dancor> activism
20:37:22 <gwern> dancor: activism in what, a language I don't speak?
20:37:24 <tensorpudding> No one uses the "were" though.
20:37:25 <gwern> that'll work well
20:37:34 <dancor> ya passivism
20:37:43 <ManateeLazyCat> dcoutts_: I have check bug tracker and source code, haven't found any hint.
20:38:00 <cads> hmm, the words have a different character if you make them male
20:38:18 <dcoutts_> ManateeLazyCat: you could file a ticket
20:38:31 <dcoutts_> ManateeLazyCat: does gtk2hs do anything non-standard for reparenting widgets?
20:38:38 <cads> gwern, are you suggesting that words are made feminine to indicate objects that are used like the dirty sluts they are?
20:38:57 <dancor> ha
20:39:12 <gwern> cads: gendering language is sexist, let's just be honest about it
20:39:30 <tensorpudding> That present subjunctive of to be looks really artificial.
20:39:41 <ManateeLazyCat> dcoutts_: I think gtk2hs is fine. It's problem of Gtk+, current Gtk+ haven't support any mechanism to reparent GtkPlug, need hacking "deleteEvent" signal on GtkPlug.
20:40:08 <tensorpudding> I can't think of a sentence which would use that.
20:41:24 <idnar> o/` if I were a rich man o/`
20:41:38 <cads> gwern, I don't know if english speakers seem to be inherently less sexist for speaking english
20:42:00 <gwern> cads: just go ask some french philosophes :)
20:42:15 <gwern> (they can bend your ear about it - it seems to be a central preoccupation of theirs)
20:42:27 <ManateeLazyCat> dcoutts_: Details is this: I'm running GtkSocket and GtkPlug in different processes. GtkSocket running in server process for manager Tab in Notebook, and running GtkPlug in plug-in process, then i can use function `socketAddId` embedded plug-in process to server process to render.
20:42:38 <cads> hehe, I can't only imagine what they conjecture
20:42:47 <ManateeLazyCat> dcoutts_: But sometimes, i need move GtkPlug from one GtkSocket to another GtkSocket.
20:43:02 <ManateeLazyCat> And GtkPlug will destroy if GtkSocket is remove from it's container.
20:43:17 <tensorpudding> the use of subjunctive "were" in the case of that line from Fiddler on the Roof is still correct but not ubiquitous.
20:43:20 <ManateeLazyCat> So i return True with "deleteEvent" signal on GtkPlug.
20:43:38 <dcoutts_> ManateeLazyCat: sounds like it's not supported behaviour
20:43:48 <ManateeLazyCat> Then GtkPlug will hide instead destroy when GtkSocket remove.
20:44:10 <ManateeLazyCat> dcoutts_: After i create new GtkSocket, i can use socketAddId re-use GtkPlug.
20:44:21 <dcoutts_> ManateeLazyCat: you should be able to use the normal gtk reparenting, and if that's not supported for those widgets then it's not supported and you should take a different approach, not try to hack it
20:45:34 <ManateeLazyCat> dcoutts_: But problem is, my solution is works fine in Gtk+ 2.18.3, i have test it many many times, but looks Gtk+ 2.20 change something to break my code.
20:45:58 <dcoutts_> ManateeLazyCat: as I said, don't try to hack it
20:46:26 <dcoutts_> because you're relying on internals that change between versions
20:47:00 <cads> gwern, I'm not sure if acknowledging the existence of something like a female and male essence and attributing these to various words must necessarily have overall detriment to one of the sexes
20:47:38 <tensorpudding> There isn't a strictly feminine or masculine nature.
20:47:48 <tensorpudding> Though we can forgive the ancients for not knowing that.
20:48:05 <BMeph> tensorpudding: My wife disagrees. ;)
20:48:41 <gwern> cads: one of many viewpoints goes that associating anything biases society in general - makes women doing male-linked words something exceptional, requiring defense
20:48:53 <gwern> cads: raising the cost; as economics tells us, raise the price, lower the demand
20:49:06 <gwern> cads: see the critiques of barbie's stereotyped roles
20:49:35 <ManateeLazyCat> dcoutts_: Yes, i have another idea, but much complicated than this hack.
20:49:38 <tensorpudding> Early society had capitalized on stastistically-valid physical differences between men and women, which led to seeing them as having essentially different natures.
20:49:38 <gwern> cads: but feminist philosophy doesn't really interest me, so if you want more consult wikipedia or stanford internet encyclopedia
20:50:11 <syntaxglitch> gwern, ehh, a huge collection of often arbitrary and conflicting biases is pretty much what culture *is*
20:50:12 <dcoutts_> ManateeLazyCat: I see you've already asked on the gtk-list mailing list
20:50:19 <tensorpudding> (animals are pretty sexist too)
20:50:21 <syntaxglitch> the human mind is a finely-tuned engine for jumping to conclusions
20:50:28 <ManateeLazyCat> dcoutts_: Another solution is, when i need reparent GtkPlug, don't reparent it, create new pair GtkSocket/GtkPlug, and reparent *old* GtkPlug children to *new* GtkPlug.
20:50:34 <ManateeLazyCat> dcoutts_: Yes.
20:50:48 <tensorpudding> conversation about feminism should migrate to -blah...
20:51:30 <rsaarelm> Books with automatically generated interactive code sections are fun: http://book.realworldhaskell.org/read/efficient-file-processing-regular-expressions-and-file-name-matching.html#id617251 . The Regex return type [String] apparently isn't supported with the new version of the library, so the generated example session now shows an error message, while the text still tells you to use [String].
20:51:50 <ManateeLazyCat> dcoutts_: In Gtk+ 2.18.3 i can use that hack tips reparent GtkPlug directly, for new solution, i need emit/receive DBus signal when reparent GtkSocket.
20:54:57 <dcoutts_> ManateeLazyCat: so why doesn't gtk_widget_reparent work?
20:55:27 <ManateeLazyCat> dcoutts_: GtkPlug can't simple use gtk_widget_reparent.
20:58:18 <ManateeLazyCat> dcoutts_: If you want add GtkPlug to GtkSocket, the only is socketAddId or pass SocketId when create GtkPlug.
20:58:36 <ManateeLazyCat> dcoutts_: You can't use widgetReparent with GtkSocket/GtkPlug.
20:59:07 <ManateeLazyCat> dcoutts_: And current problem, GtkPlug will destroy when GtkSocket remove from toplevel window even GtkSocket still live.
20:59:53 <cads> rsaarelm: can you find the previous version of the library?
21:04:59 <dcoutts_> ManateeLazyCat: ok so you can't move a GtkPlug from one GtkSocket to another but can't you change the parent of the socket, so you can e.g. move if from one notebook tab to another?
21:08:56 <ManateeLazyCat> dcoutts_: GtkPlug will destroy even you reparent GtkSocket's parent.
21:14:18 <ManateeLazyCat> dcoutts_: I think reparent action is this, "remove from old parent ==> add to new parent".
21:15:24 <ManateeLazyCat> dcoutts_: But GtkPlug and GtkSocket don't care what's parent, them just care *TopLevelWindow*, once you remove GtkSocket or it's parent from TopLevel Window, even just use "widgetReparent", GtkPlug will destroy.
21:15:51 <dcoutts_> ManateeLazyCat: ok, so it's not supported.
21:16:10 <ManateeLazyCat> dcoutts_: Yes, i have new idea around this, not hack tip.
21:16:12 <ManateeLazyCat> :)
21:18:04 <ManateeLazyCat> dcoutts_: We can't reparent GtkPlug or GtkSocket, why not reparent GtkPlug's children to new GtkPlug?
21:19:32 <EvanR> @google haskell data.list
21:19:33 <lambdabot> http://www.haskell.org/ghc/staging/docs/latest/html/libraries/base-4.2.0.0/Data-List.html
21:19:45 <EvanR> 404
21:41:35 <rsaarelm> cads: No, and I don't need to. The comments on the page already tell that the fix is just to use [[String]] instead of [String]. Just finding it funny that the book hasn't either been updated or kept being generated by the old library version.
21:43:49 <EvanR> :t foldl
21:43:50 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
21:43:52 <EvanR> :t foldr
21:43:53 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
21:44:14 <EvanR> is there any significance to the different letters here
21:44:43 <pikhq> Yes.
21:44:53 <pikhq> Note the type of the functions passed.
21:45:12 <pikhq> :P
21:45:12 <EvanR> one returns the same type as the contents of the list
21:45:14 <EvanR> one doesnt
21:45:35 <EvanR> no
21:45:36 <pikhq> Yes. There's the type-level significance.
21:45:49 <EvanR> they both return oppose the list, same as result of fold
21:45:50 <pikhq> Erm.
21:45:50 <pikhq> No.
21:46:04 <EvanR> and same as initial value
21:46:07 <pikhq> The type-level significance is the order of the arguments.
21:46:15 <EvanR> yes they have different order of arguments
21:46:16 <idnar> those types are a bit confusing
21:46:19 <pikhq> Which is to say, not much.
21:46:24 <idnar> it might be easier if you swap one of the definitions around
21:46:34 <idnar> foldl :: (b -> a -> a) -> b -> [a] -> a
21:46:41 <idnar> foldr:: (a -> b -> b) -> b -> [a] -> b
21:46:45 <idnar> err, oops
21:46:51 <idnar> foldl :: (b -> a -> a) -> b -> [a] -> b of course
21:47:02 <pikhq> The relevant differences are in the semantics, not the type, anyways.
21:47:12 <EvanR> idnar: that cant be right
21:47:31 <idnar> foldl :: (b -> a -> b) -> b -> [a] -> b
21:47:34 <EvanR> in both cases the function has to return the same type as the fold
21:47:35 <idnar> third time lucky?
21:48:05 <idnar> now that I've finally finished getting it wrong, you can see what you guys already figured out :P
21:48:09 <EvanR> well the thing is i cant remember which argument is which for the callback ;)
21:48:30 <EvanR> why they are swapped i dont know
21:48:37 <pikhq> @src foldl
21:48:38 <lambdabot> foldl f z []     = z
21:48:38 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
21:48:40 <pikhq> @src foldr
21:48:40 <lambdabot> foldr f z []     = z
21:48:40 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
21:49:14 <pikhq> I'm going with a solid "'cause".
21:49:23 <EvanR> lol
21:49:51 <EvanR> ok, foldl calls the function on the left ones first, foldr on the right ones
21:50:03 <EvanR> wait no
21:50:06 <idnar> well, it kind of follows naturally from the definition
21:50:21 <EvanR> foldr does something weird
21:50:35 <idnar> foldr replaces each (:) constructor with f, and each [] constructor with z
21:50:45 <idnar> at least, I find that the easiest way to think of it
21:51:45 <EvanR> :t scanr
21:51:46 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> [b]
21:51:49 <EvanR> :t scanl
21:51:50 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
21:52:02 <EvanR> im thinking, after all that, i need one of these instead ;)
21:52:11 <idnar> heh
21:52:31 <idnar> which have exactly the same types, even though they do something completely different
21:52:49 <EvanR> i have a infinite list, and i want to make another infinite list using 'past values', im thinking foldl scanl is the only one that makes sense for that?
21:53:30 <EvanR> where are the data.list docs :(
21:54:20 <monochrom> bookmark this: http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
21:54:36 <EvanR> ah
21:54:36 <monochrom> Google is outdated, that's all.
21:54:41 <EvanR> google is broke
21:57:57 <dcoutts_> monochrom: which URLs broke? we should not be randomly invalidating google's index
21:58:20 <EvanR> @google data.list
21:58:21 <lambdabot> http://haskell.cs.yale.edu/ghc/docs/6.12-latest/html/libraries/base-4.2.0.0/Data-List.html
21:58:54 <monochrom> Eh it changed. Last time it was http://www.haskell.org/ghc/staging/docs/latest/html/libraries/base-4.2.0.0/Data-List.html
21:59:32 <lpsmith> huh, didn't ghc-core have a format option?
22:00:46 <dcoutts_> monochrom: hmm, so the problem there is that we're using latest and then making things underneath that versioned.
22:01:09 <lpsmith> There used to be an option for ghc-core to dump HTML output
22:01:34 <dcoutts_> probably what we want is two separate sets of docs, one fully versioned and one "latest" that is not versioned so that the URLs are stable
22:02:34 <monochrom> In any case "staging" is an omen.
22:03:14 <monochrom> I don't invalidate google's index ever. Not randomly, not systematically. I just can't.
22:05:49 <BMeph> conal: Have you been following what david barbour has been doing? :)
22:06:04 <conal> BMeph: nope.
22:06:35 <BMeph> conal: Been busy concentrating on what you're doing? ;)
22:06:49 <conal> BMeph: yep.
22:07:09 <conal> BMeph: where have you been seeing david barbour's work?
22:09:57 <BMeph> conal: From his references on LtU.
22:11:16 <conal> BMeph: ah
22:12:33 <lpsmith> BMeph, have you seen anything outside of LtU?
22:12:37 <EvanR> when i import a module, i dont seem to get types?
22:12:46 <Athas> How do people deal with including manpages with their Haskell packages?
22:12:59 <Athas> I'm mostly thinking about how to get cabal to install them.
22:13:09 <lpsmith> EvanR, you should be getting types.   What do you mean?
22:14:00 <lpsmith> EvanR,  are you referring to a module in a package that's shadowed by a module in another package,   so you aren't actually importing the module you think you are?
22:14:11 <EvanR> module Types where ... type Point = Complex Double, other module, import Types error Not in scope type constructor or class Point
22:14:11 <dcoutts_> Athas: at the moment they mostly despair
22:15:04 <dcoutts_> Athas: see the lhs2tex Setup.hs for an example. It's on our (very long) TODO list to improve this. Of course it'll improve quicker with more volunteers ;-)
22:15:10 <lpsmith> EvanR,  hmm, well, that *should* work from the information you are giving
22:15:26 <EvanR> ghc -c OtherModule.hs
22:15:33 <EvanR> i havent compiled Types.hs yes
22:15:34 <EvanR> yet
22:16:27 <monochrom> Yes you need to compile Types.hs first.
22:16:41 <EvanR> ah
22:16:45 <Athas> dcoutts_: this sounds like a good thing to help out with.  I'll see if I can come up with something clever (but I'm not really experienced with installers).
22:17:09 <monochrom> Develop the habit of giving a complete procedure for reproducing your error.
22:17:30 <monochrom> Reproducible or it didn't happen.
22:18:36 <dcoutts_> Athas: it's more about working out a sensible design for describing documentation in .cabal files and then installing it.
22:18:50 <OceanSpray> So I tried installing leksah in windows.
22:19:18 <dcoutts_> Athas: eg to indicate which docs are man pages vs tutorials, handling different formats, html, pdf, man, plain text. Not installing man pages on windows etc.
22:19:25 <OceanSpray> Not that I expect thing to "just work", but I've been messing with it for quite a while, and it's just not starting.
22:21:02 <dcoutts_> Athas: see http://hackage.haskell.org/trac/hackage/ticket/330
22:21:55 <dcoutts_> Athas: the main issue is working out a sensible coherent design, the coding is easy by comparison :-)
22:22:15 <Athas> dcoutts_: thanks, I will take a look at this eventually, because I will definitely care more about it int he future.
22:22:28 <Athas> For the moment, however, I'll just grab manpage code from lhs2tex.
22:23:02 <dcoutts_> Athas: great, supporting more general documentation is an important long term issue. It'll help to encourage more and better package docs.
22:23:29 <lpsmith> EvanR:   ghc --make -c OtherModule.hs   will (re-)compile the Types module as necessary
22:23:52 <lpsmith> --make is a very handy option
22:23:59 <EvanR> ah yeah, i wasnt using --make because i didnt want to build everything
22:24:10 <EvanR> but if i specify that module it will only build deps
22:26:08 <monochrom> Yeah.
22:27:18 <Athas> Actually, under which circumstances are Setup.hs run?
22:28:11 <EvanR> dsolve v as = let vs = scanl (+) v as in scanl (+) 0 vs
22:28:22 <EvanR> ^ asteroids ;)
22:33:10 <BMeph> conal: Sorry, surfing. Anyhow, the c2Wiki and LtU are all that I've seen of Mr. Barbour.
22:34:20 <conal> BMeph: any impressions?
22:37:24 <BMeph> conal: He has a lot of ideas, not sure if they're going to go anywhere, since there are a lot of directions for him to go. I kinda know that feeling... ;)
22:37:38 <conal> :)
22:37:52 <ezyang> Hey, does anyone know why type Modifier f i o = (o -> i) -> f -> f in fclabels is f i o and not f i = (i -> i) -> f -> f?
22:40:30 <o-_-o> Any place Duncan Coutts slides, for the "Strong Types and Pure Functions" talk, are available ?
22:41:02 <o-_-o> when I go to vimeo it says you don't have permission to access this video.
22:41:13 <dcoutts_> o-_-o: yes, on the blog post
22:41:31 <dcoutts_> and on the conference website
22:41:43 <o-_-o> dcoutts, oh hi, the man himself in flesh and blood!
22:41:49 <dcoutts_> :-)
22:41:55 <o-_-o> dcoutts, do you have a link ?
22:42:22 <dcoutts_> o-_-o: apparently the video is only accessible through the conference page, not directly at vimeo, I tried that too :-(
22:42:35 <o-_-o> dcoutts, ok
22:42:42 <o-_-o> dcoutts, no problem I downloaded it
22:43:06 <dcoutts_> http://blog.well-typed.com/2009/12/talk-at-the-functional-programming-exchange/
22:43:08 <o-_-o> dcoutts, ah sound the flides
22:43:12 <o-_-o> argh!
22:43:24 <o-_-o> dcoutts, ah found the slides
22:43:31 <dcoutts_> ok great
22:43:40 <o-_-o> I don't even understand how I typed that
22:43:58 <dcoutts_> one of life's little mysteries :-)
22:44:09 <o-_-o> heh...
22:44:42 <monochrom> . o O ( I don't see any flesh or blood here. I only see flash and blog. )
22:45:48 <dcoutts_> monochrom: heh, very good
22:46:36 <o-_-o> wow...haskell syntax is really simple compared to F#
22:48:00 <monochrom> type inference helps save a lot of typing
22:48:34 <tensorpudding> I like adding explict types to top-level functions
22:49:36 <o-_-o> now the video is not even accessible on the conference web-page, same you don't have permission to embed the video
22:49:37 <BMeph> conal: This is what caught my eye to ask you about dmbarbour: https://c2.com/cgi/wiki?ConstraintReactiveCapabilityProgramming
22:50:38 <conal> BMeph: thx
22:51:01 * BMeph brings out his black-and-white warning sticker - "Haskell Advisory: Contains Explicit Annotations"
22:51:27 <Veinor> unsafePerformSex
22:51:40 <BMeph> conal: I thought you'd find it interesting. (You're welcome.) :)
22:51:49 <EvanR> im using complex. is it better to do map (v*) [0..] or scanl (+) 0 (repeat v)
22:51:56 <EvanR> seems like the +
22:52:03 <BMeph> Veinor: usafePerformExplicitIO? ;
22:52:22 <o-_-o> conal, do you have a basic tutorial for FRP ?
22:52:36 <conal> o-_-o: a very old one, yes.
22:52:55 <o-_-o> conal, are you writing a book on FRP ?
22:52:58 <BMeph> EvanR: Why not "iterate (+v) 0" ? ;)
22:53:05 <conal> http://conal.net/fran/tutorial.htm
22:53:24 <EvanR> nice
22:53:34 <conal> o-_-o: not yet.  still noodling over the foundations.  not yet satisfied.
22:53:52 <monochrom> > map (0.999 *) [0..] !! 10000
22:53:52 <lambdabot>   9990.0
22:54:09 <monochrom> > scanl (+) 0 (repeat 0.999) !! 10000
22:54:09 <lambdabot>   9989.999999998423
22:54:17 <EvanR> hrm
22:54:19 <monochrom> Guess which one is closer to the correct answer.
22:54:25 <monochrom> Guess why.
22:54:30 <EvanR> accumulation error
22:54:55 <EvanR> monochrom: this is a lucky case where the result has a closed form ;)
22:55:04 <BMeph> > iterate (+ 0.999) 0 !! 10000
22:55:06 <lambdabot>   9989.999999998423
22:55:27 <o-_-o> conal, ok...you really meant old, when you said old :-)
22:55:28 <EvanR> this is accelerate v 0
22:55:37 <EvanR> accelerate v as = dsolve .. ;)
22:55:46 <conal> o-_-o: yeah.  my kids are grown now (20-27).
22:55:47 <EvanR> which i used two scanls
22:56:05 <EvanR> to integrate
22:56:18 <conal> o-_-o: (pictured in the tutorial)
22:56:36 <o-_-o> conal, ah...haha
22:56:39 <monochrom> Google for "What Every Computer Scientist Should Know about Floating-Point Arithmetic"
22:58:53 <o-_-o> conal, I saw a haskell opengl program with FRP, but I can't seem to find it anymore, is there anywhere that is available ?
22:59:20 <o-_-o> conal, I want to know if glut callback like flow can be replaced with FRP.
22:59:23 <conal> o-_-o: library?  app?
22:59:34 <rsaarelm> Did Frag use FRP?
22:59:35 <o-_-o> conal, it was just a small sample program
22:59:42 <o-_-o> conal, I think
22:59:53 <rsaarelm> http://www.haskell.org/haskellwiki/Frag
23:00:01 <rsaarelm> Not really a small sample program though.
23:00:12 <o-_-o> ook
23:00:35 <conal> o-_-o: there are some demos with reactive-glut.  may give you a taste, though broken at the moment.
23:00:47 <conal> @wiki reactive-glut
23:00:47 <lambdabot> http://www.haskell.org/haskellwiki/reactive-glut
23:01:41 <conal> o-_-o: sorry the implementations are in bad shape.
23:02:10 <o-_-o> conal, no problem, thanks
23:04:31 <BMeph> monochrom: Still campaigning for Borneo? ;)
23:08:54 * BMeph imagines Scala with Borneo doing the numerical stuff...
23:16:15 <monochrom> What is Borneo?
23:16:31 <Athas> Why can I do 'cabal install process' over and over again without being told that it's already installed?
23:17:22 <dcoutts_> interesting
23:17:57 <BMeph> monochrom: It's like Java, only more locally compact... ;)
23:18:14 <monochrom> haha
23:18:19 <dcoutts_> Athas: does it succeed? is it installed (and not broken) according to ghc-pkg?
23:19:04 <Athas> dcoutts_: yeah.
23:19:09 <monochrom> Because you can re-install Windows over and over again without being told it's already installed. "principle of least surprise"
23:19:49 <dcoutts_> Athas: yeah to both? what does cabal install process --dry-run -v say about it?
23:19:55 <Athas> But other packages will complain.  And more to the point, whenever I do 'cabal install' on a program I've written that depends on process, cabal will recompile and reinstall process again.
23:20:19 <monochrom> I see. Fun.
23:20:21 <Athas> It can see that it's a reinstall.
23:20:28 <dcoutts_> certainly sounds like cabal thinks its not installed
23:20:44 <dcoutts_> or that it's installed but broken, which amounts to the same thing from Cabal's pov
23:21:06 <dcoutts_> Athas: ghc-pkg check doesn't report anything suspicious?
23:21:53 <Athas> No, nothing except that it's in both the system-wide and local package.conf.d's (same version both places).
23:22:15 <o-_-o> conal, have you given any talks on FRP and are there any videos of your talks available ?
23:22:56 <conal> o-_-o: i've given several FRP talks.  only one video that i know of.  looking ...
23:23:09 <Saizan> Athas: that's the problem, that situation utterly confuses cabal (and i think ghc-pkg too?)
23:23:16 <conal> o-_-o: see http://conal.net/papers/push-pull-frp/
23:23:58 <o-_-o> conal, thanks
23:24:22 <EvanR> if i have repeat x, and x is a complex expression, does that mean the complex expression will be reevaluated each time i use each value of the resulting list
23:24:28 <conal> o-_-o: sure.  and do you know about my blog?  also other frp resources on haskell.org
23:24:31 <conal> @wiki FRP
23:24:31 <lambdabot> http://www.haskell.org/haskellwiki/FRP
23:24:33 <Athas> Saizan: alright, I deleted my local package.conf.d.  Let's see if I can avoid the problem...
23:24:56 <dcoutts_> Saizan: even so, it's not obvious to me exactly why cabal would consider the user package broken
23:25:01 <Saizan> Athas: ah, you could've just "ghc-pkg unregister process"
23:26:42 <Athas> Saizan: there were many like it.
23:27:50 <cads> are ghc-pkg and cabal install related in a similar way to debian's dpkg and apt-get?
23:27:58 <ologNation> I have a very redundant list.
23:28:08 <ologNation> Does anyone know a quick way to remove duplicates?
23:28:23 <EvanR> nub [1,2,3,5,3,3,4,1,1,2,3]
23:28:27 <EvanR> > nub [1,2,3,5,3,3,4,1,1,2,3]
23:28:29 <lambdabot>   [1,2,3,5,4]
23:28:31 <dcoutts_> cads: sort-of, ghc-pkg is ghc's registry of installed libraries.
23:28:32 <ologNation> I think I just thought of one, but I'm curious to here if there is an idiomatic ..
23:28:33 <ologNation> nub?
23:28:40 <ologNation> Huh.
23:28:44 <dcoutts_> cads: neither track installed files
23:29:34 <EvanR> ologNation: its as idiomatic as it gets ;)
23:29:55 <Athas> Hm, a perhaps related problem... I have a standard Setup.hs ('main = defaultMainWithHooks simpleUserHooks'), yet when I do 'runhaskell Setup.hs configure' it complains about missing packages.  But plain 'cabal install' works, and the packages are in my ghc-pkg list as well.
23:30:46 <Saizan> runghc Setup configure defaults to global installations
23:30:47 <dcoutts_> Athas: http://haskell.org/cabal/FAQ.html#runghc-setup-complains-of-missing-packages
23:31:56 <Athas> Oh, thanks.  I should have read the FAQ first.
23:32:33 <dcoutts_> Athas: basically, stick to 'cabal' rather than 'runghc Setup.hs'
23:33:07 <Athas> Yeah, but I need some custom code in Setup.hs to install manpages...
23:33:34 <ologNation> EvanR, Indeed!
23:33:39 <ologNation> That's just what I was looking for.
23:33:40 <ologNation> Thank you.
23:33:42 <idnar> EvanR: repeat only creates one cons cell
23:33:53 <idnar> EvanR: does that answer your question?
23:34:10 <EvanR> idnar: i think so, that means theres only one expression to evaluate. once its evaluated, its evaluated
23:34:12 <idnar> @src repeat
23:34:13 <lambdabot> repeat x = xs where xs = x : xs
23:34:58 <idnar> EvanR: actually, I guess for your purposes, it doesn't matter
23:35:07 <Saizan> Athas: cabal will run the Setup.hs script for you with the appropriate flags, but you need to put build-type: Custom in the .cabal file
23:35:22 <idnar> EvanR: actually, I guess for your purposes, it doesn't matter
23:35:28 <idnar> EvanR: you only pass one value to repeat, it has no way to copy the value
23:35:42 <Athas> Saizan: ah, that was the missing piece of the puzzle.  Thanks!
23:35:46 <dcoutts_> Athas: indeed you must use build-type: Custom if you use a custom Setup.hs
23:35:49 <idnar> EvanR: but it's nice that an infinite list spine won't be produced either
23:36:22 <EvanR> idnar: im combining many operations onto infinite lists and their derived lists, i was worried about it slowing down at some point
23:38:45 <idnar> anyone know if there's a rewrite rule for map / repeat?
23:39:19 <idnar> if not, then doing something like map f (repeat x) will unfortunately produce a list with an infinite spine and evaluate f x (but not x) multiple times
23:39:34 <idnar> (well, when the list values are evaluated, anyhow)
23:40:36 <dcoutts_> idnar: try it, you should find it fuses via foldr/build fusion
23:40:53 <idnar> dcoutts_: I'm not really sure how to test it
23:41:10 <dcoutts_> -ddump-simpl-stats iirc
23:41:39 <dcoutts_> look for the "repeat" and "foldr/build" rules firing
23:41:53 <dcoutts_> and you can check the resulting core code too
23:42:53 <idnar> 3 RuleFired
23:42:53 <idnar>     1 fold/build
23:42:53 <idnar>     1 map
23:42:53 <idnar>     1 repeat
23:43:01 <idnar> I... guess that means it does
23:43:32 * idnar attempts to read Core
23:43:34 <dcoutts_> yes, though it'd be interesting to see if the sharing is preserved
23:43:43 <idnar> er, wait, how do I dump Core?
23:43:44 <dcoutts_> I suspect it is with foldr/build
23:43:55 <idnar> (no pun intended)
23:44:05 <dcoutts_> -ddump-core? :-)
23:44:27 <dcoutts_> actually I typically use -ddump-simpl
23:44:48 <idnar> where is that documented?
23:45:09 <idnar> oh, apparently it doesn't exist
23:45:15 * idnar tries -ddump-simpl
23:45:52 <idnar> bleh, I think the optimiser flattened my entire program into a loop
23:45:57 <idnar> which is nice, but not very helpful
23:47:01 <Athas> How do I check whether I'm running on Windows?
23:47:24 <arcatan> maybe some kind of build-time check?
23:47:25 <idnar> oh, no, hang on
23:47:29 <Athas> I know about System.Info.os, but what can I expect to find there?
23:47:31 <idnar> Main.main_xs = GHC.Types.: @ GHC.Integer.Type.Integer a_rUR Main.main_xs
23:47:36 <idnar> that looks like a recursive list cell
23:48:08 <idnar> a_rUR is the value that results from pushing my f into the repeat
23:50:39 <BMeph> Does anyone on that uses Vector regularly, miss not having splitAt?
23:54:37 <cads> thanks  dcoutts
23:58:01 * ologNation just computed that 
23:58:02 <ologNation> there are 5 distinct words made of 1 letters
23:58:02 <ologNation> there are 13 distinct words made of 2 letters
23:58:02 <ologNation> there are 29 distinct words made of 3 letters
23:58:02 <ologNation> there are 53 distinct words made of 4 letters
23:58:02 <ologNation> there are 59 distinct words made of 5 letters
23:58:04 <ologNation> there are 60 distinct words made of 6 letters
23:58:06 <ologNation> where the letters are a = [1,2,3], b = [3,4,5], generating A_5
23:58:22 <ologNation> (note: A_5 is the group of even permutations of 5 things).
23:58:32 <ologNation> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25187#a25187
23:58:43 <ologNation> and http://www.polyomino.f2s.com/david/haskell/permgrp.html
23:59:54 <ologNation> Hey Conal.
23:59:58 <ologNation> You missed it.
