00:02:27 <jaspervdj> fffej: With some custom fold it should be possible
00:02:27 <lambdabot> jaspervdj: You have 1 new message. '/msg lambdabot @messages' to read it.
00:04:08 <fffej> jaspervdj:  thanks - I'll go down that root and see what happens
00:05:10 <jaspervdj> fffej: also, the new Vector libraries might be more effiecient
00:06:10 <jaspervdj> fffej: you probably want mutable unboxed vectors/arrays
00:06:17 <fffej> jaspervdj: you mean http://hackage.haskell.org/package/vector-0.5?
00:06:23 <jaspervdj> fffej: yes
00:06:57 <Axman6> i'm not sure of vector is what you want
00:07:14 <Axman6> I believe vectors in the vector package are one dimentional
00:07:24 <fffej> axman6: I can always map the 2d co-ords into 1d
00:07:30 <jaspervdj> Axman6: ah, yes
00:07:31 <Axman6> sure
00:07:35 <kmc> inded, the Ix class does that for you
00:07:55 <kmc> > index ((0,0), (100,100)) (30,20)
00:07:56 <lambdabot>   3050
01:17:20 <fps> anyone here using a tracer?
01:19:29 <fps> reason I ask: I implemented different functions for root finding and I would like to compare these by how many times each function gets called
01:20:40 <koeien37> you could use the profiler in this case
01:21:27 <koeien37> you will get output which includes the number of times the functions got called
01:22:35 <fps> Ah, in the doc I just found profiling output for time
01:23:12 <koeien37> it contains a column "entries", I think that should indicate it
01:23:22 <koeien37> I don't know how this interacts with optimizations switched on though
01:23:57 <fps> are optimizations switched on by default?
01:24:18 <fps> ah, lets just try it
01:24:24 <fps> thanks for now
01:24:53 <koeien37> you can use Debug.Trace as well. The problem is that the Haskell compiler is free to rearrange your computation.\
01:25:15 <koeien37> since they are supposed to be side-effect free
01:25:22 <fps> I see
01:26:09 <koeien37> -O
01:26:16 <koeien37> by default optimizations are off
01:26:39 <koeien37> -O2 switches on most useful optimizations
01:34:59 <ketil> I can't seem to find 'cairo' on Hackage?
01:35:22 <quicksilver> ketil: it's not cabalized
01:35:29 <tobbra> cairo is in gtk2hs
01:35:44 <quicksilver> ketil: http://www.haskell.org/gtk2hs/overview/
01:37:00 <ketil> Ah.  Ok.
01:37:08 <ketil> Shame - lots of packages depend on it.
01:37:24 <quicksilver> yes, undoubtedly they *want* to cabalize it
01:37:39 <quicksilver> it's just that it has a rather sick and twisted^W^W^W complex build procedure.
01:38:48 <ketil> The good news is that it's probably..yes, there it is...my distribution has them.
01:39:46 <tobbra> something debian based?
01:53:04 <HugoDaniel> hello
01:56:59 <BONUS> hi
02:03:31 <mxc> hi
02:04:27 <mxc> what are the safety of unsafeFreeze?
02:04:50 <mxc> if i ensure that there are no concurrent reads/writes with an MVar, it should be safe right?
02:05:14 <mxc> (in the MArray package)
02:05:37 <mxc> s/package/module
02:05:56 <lars9> can we make a type MyType Int Int which gaurantees first Int must be larger than 2nd Int?
02:06:19 <koeien37> lars9: No.
02:07:11 <koeien37> lars9: you can hide the internals though in another module, and prove that it's correct; then export a "smart constructor" mkMyType :: Int -> Int ->  Maybe MyType
02:08:24 <lars9> koeien37: now mkMyType is just a method, not a type constructor right?
02:09:40 <koeien37> a function
02:10:37 <koeien37> in a dependently typed language you ought to be able to define your type though
02:11:13 <ketil> No debian-haskell channel?  Apparently, libghc6-cairo-{prof,doc} are missing, although -dev is there.
02:11:28 <lars9> can we make a type class "IntN Int" with which IntN 100 means all int <= 100?
02:13:06 <pastorn> lars9: no, you can't make restrictions like that and enforce them with types
02:13:14 <pastorn> (unless you do massive type hacks)
02:14:04 <pastorn> lars9: and that doesn't really sound like a typeclass
02:14:04 <mle> >400 milli-Olegs
02:15:16 <pastorn> lars9: haskell /= ADA
02:15:41 <lars9> pastorn: is this a type?: data Int10 = 0 | 1 | 2 ... | 10
02:16:04 <koeien37> no, but data Int10 = I0 | I1 | ... | I10 is
02:16:08 <Jafet> Yes, but it's not valid Haskell
02:16:39 <edwardk> lars9: note in ada the attempted assignment of a value out of range to a subtype is caught at runtime via an exception. you CAN do the same thing in haskell
02:16:44 <lars9> so what should be convered by type system what should not?
02:17:08 <edwardk> newtype IntBelow100 = IntBelow100 Int -- and then in your Num instance you can carefully check the invariant
02:17:54 <edwardk> what of course would be better would be checking the invariant holds over all executions and obviating the need for the exception ;)
02:18:04 <pastorn> lars9: if you try really hard you can get an invalid matrix multiplication (dimension error) to be caught at compile time
02:28:17 <lars9> pastorn: why matrix?
02:30:31 <ketil> tobbra, yes - I use Ubuntu (apolgies for the long delay)
02:31:32 <Botje> lars9: multiplying a matrix of size AxB with one of size CxD is only defined if B == C
02:31:48 <exDM69> ketil: I had trouble getting the haskell platform to run on my ubuntu 9.10 box
02:32:16 <exDM69> ketil: ubuntu 10.04 lucid will solve some of the issues as it will ship with a GHC version compatible with Haskell 2010
02:33:00 <exDM69> I solved the problem by installing GHC to my home dir and installing packages required to get cabal up and running
02:33:02 <ketil> 10.4 here. I'm generally very happy with Haskell support now.
02:33:32 <exDM69> debian's got a haskell-platform package
02:34:19 <ketil> I guess I should contribute by debianizing some packages (my own plus some dependencies).  It's on my list, but the instructions seem a bit complicated, so it tends to get postponed.  Sigh.
02:35:01 <ketil> haskell-platform is missing in Ubuntu, but I think the dependencies are available.
02:35:15 * eevar2 just went for arch for his laptop
02:35:59 <exDM69> ketil: I also stumbled into difficulties building the OpenGL package bundled with haskell platform 2010
02:36:31 <exDM69> complaints about missing gl.h and glEnd in libGL.so, although I have (nvidia-glx) opengl dev libs installed and working
02:37:37 <Jafet> Well, do you have gl.h and glEnd?
02:37:40 <Cale> lars9: It's a bit unfortunate, but type-level arithmetic, while possible, is significantly more awkward than one would hope in Haskell at present. Other systems (especially dependent types) make it easier to do such things, but we don't have them in GHC yet.
02:37:45 <Zao> Headers may be provided by some silly mesa package.
02:39:56 <Cale> lars9: So while it's possible to define a type of integers less than k, for instance, it's usually on the wrong side of the tradeoff between obtaining compile-time guarantees and retaining some amount of sanity in your code :)
02:43:19 <lars9> Cale: oh i see, it's really hard to check bounded integer in compile time
02:43:35 <Cale> lars9: yeah
02:43:55 <Cale> lars9: At least, not without making your code really awkward. :)
02:44:21 <Jafet> A bounded integral ring doesn't sound hard, as long as you don't need values at compile time
03:03:27 <dancor> if f is top-level and you want a single f n to be memoized should you do y = f n and pass that around or will using the same (f n) in a bunch of different places be automemoized
03:03:43 <quicksilver> the former.
03:03:46 <dancor> ok
03:04:01 <quicksilver> "automemoization" is a serious memory leak
03:04:09 <quicksilver> althoug GHC will occasionally common up subexpressions
03:04:19 <dancor> mm
03:05:42 <exDM69> Jafet: I do have the gl.h header and the library containing glEnd, but for some reason the autoconf script trying to detect them fails
03:06:13 <exDM69> using opengl libs & headers from another vendor (like mesa) might work, but I don't want to break my system (even temporarily) just to get a flaky library instaled
03:07:02 <exDM69> after I finally got Cabal working, I could install the HOpenGL library but the version bundled with haskell-platform didn't work
03:07:49 <exDM69> I also noticed that the new OGL module also suffers from the same problem as the HOpenGL bundled with platform2010
03:08:51 <exDM69> it failed from the same error as HOpenGL initially did when I tried to install it from the platform tarball
04:05:38 <dantheman_> Hey all, does anyone know if there's a standard way to asynchronously clear a channel?
04:05:41 <roconnor> http://www.reddit.com/r/haskell/comments/bmzai/regular_shapepolymorphic_parallel_arrays_in/c0ohc0f
04:07:12 <dantheman_> i.e. an equivalent to tryTakeMvar for channels?
04:13:40 <Cale> dantheman_: You mean like reading all the elements off of it?
04:13:53 <Cale> dantheman_: (but atomically?)
04:14:52 <Cale> dantheman_: You could always have something like an MVar (Chan a) or IORef (Chan a), to allow you to replace the Chan with an empty one immediately.
04:15:40 <dv-> Since we're on the topic of concurrency, has anyone tried eprocess on hackage and figured out how to use it?
04:15:55 <quicksilver> dantheman_: there isn't, and I had to roll my own Chan to make one without a race condition.
04:16:15 <quicksilver> there may be an easier way but I couldn't see it at the time.
04:16:55 <dantheman_> Ah ok thanks.
04:17:07 <dantheman_> Just wanted to make sure I wasn't missing anything.
04:18:01 <dantheman_> Did the one you made yourself basically involve forking off a helper thread and then timing that out?
04:18:25 <Cale> dv-: It looks like an extremely thin wrapper around just making use of a Chan
04:18:39 <Cale> dantheman_: Did you see my suggestion?
04:18:56 <dantheman_> ah, yes, just noticed it there!
04:18:58 <dantheman_> thanks.
04:19:06 <quicksilver> dantheman_: no, no forking involved.
04:19:11 * hackagebot network-bytestring 0.1.3 - Fast, memory-efficient, low-level networking  http://hackage.haskell.org/package/network-bytestring-0.1.3 (JohanTibell)
04:19:16 <quicksilver> dantheman_: just direct access to the MVars that a Chan is built out of
04:19:29 <quicksilver> dantheman_: mind you I probably didn't complete the API, just the bits I needed.
04:19:44 <dantheman_> ah ok. so you just built your own chans from scratch
04:20:10 <dantheman_> wonder why they don't have such a fn in the api
04:20:26 <Cale> Of course if you do it my way, you'll probably just want to do something like getChanContents when you swap the channel out.
04:20:58 <dantheman_> why's that?
04:21:19 <Cale> So you don't miss the items which were in the channel when you swapped it out.
04:21:49 <dantheman_> ah ok sure. I'm not too worried about those.
04:21:52 <Cale> I suppose it's possible you just want to give up on all the elements which were put in there.
04:22:41 <dantheman_> basically the channel has the same sender but a different receiver, and I want to make sure that the latter doesn't receive anything that was destined for the former
04:22:57 <dantheman_> although now that I think about it I should probably just create a whole new channel
04:23:20 <Cale> Yeah, it's also quite possible to do fancy things like Chan (Chan a), and such :)
04:23:47 <dantheman_> haha. Ya I use that quite a lot for req/reply, It's quite nice I think.
04:26:32 <quicksilver> dantheman_: you can also, very possibly, solve your problems using TChan instead.
04:26:47 <quicksilver> but that may force you to reexamine various other design decisions on the way.
04:27:58 <quicksilver> TChan is a good way of resolving race conditions
04:28:48 <quicksilver> ...but you can't do arbitrary IO actions inside your STM transactions without cheating.
04:31:25 <dantheman_> ah ok, thanks, I'll have a look.
04:31:46 <Cale> You really shouldn't have to do arbitrary IO inside your transactions though.
04:32:27 <Cale> Usually you can either do the necessary I/O beforehand, or produce it as a result of the transaction and do it afterward.
04:48:07 <proppy> Hi, is there a way to tell cabal install it can use more than one processor/job when building ? (like make -j)
04:49:16 <orlandu63> whereis cabal
04:49:19 <orlandu63> oops
04:49:23 <orlandu63> wrong terminal
04:49:25 <orlandu63> :P
04:49:39 <chrisdone> proppy: i'm pretty sure ghc doesn't support multijob compiling, but i've also thought about building separate libs/executable in parallel. i wonder..
04:49:41 <Jafet> There is no cabal
04:49:51 <blackdog> Jafet: jeez, it's a while since i heard that line
04:50:06 <blackdog> anyway, looking for naming suggestions
04:50:25 <blackdog> i'm doing a quick reimplementation of treetop, the ruby parser in haskell and hubris
04:50:27 <proppy> chrisdone: thanks for the information
04:50:35 <blackdog> bit experimental, but it'd be nice to have a name
04:50:44 <blackdog> currently leaning towards "leafy", but open to suggestions...
04:51:37 <Schalken> Is there such a thing as "data MaybeOK a = OK a | Error String" already anywhere? I need a monad version.
04:52:14 <osaunders> Schalken: Either?
04:52:34 <osaunders> @type Either
04:52:35 <lambdabot> Not in scope: data constructor `Either'
04:52:41 <osaunders> @type Left
04:52:42 <lambdabot> forall a b. a -> Either a b
04:52:46 <osaunders> @type Right
04:52:48 <lambdabot> forall b a. b -> Either a b
04:53:17 <Schalken> Is Either a monad?
04:53:21 <hpc> no
04:53:23 <hpc> er, yes
04:53:29 <hpc> thought you said just Either
04:54:16 <osaunders> I don't think Either is a monad but there's a monad for it. I'm sort of guessing though.
04:54:29 <koeien37> "Either a" is a monad
04:54:31 <hpc> Either a is a monad
04:54:50 <hpc> i think Either is an arrow
04:55:08 <koeien37> that seems unlikely? maybe my intuition is off
04:55:15 <osaunders> I have a philosophical question.
04:55:30 <osaunders> I've been using a tree of: data Tree = Empty | Node String Tree Tree
04:55:31 <blackh> What are the advantages of using transformers over mtl?
04:55:52 <osaunders> But now I see a different design: data Tree = Node String [Tree]
04:56:01 <hpc> blackh: robots in disguise :P
04:56:31 <osaunders> The second is superior but why?
04:56:32 <hpc> osaunders: the first is a binary tree, the second is just a regular tree
04:56:33 <blackdog> blackh: mtl's been deprecated, hasn't it?
04:56:58 <osaunders> hpc: I don't think the first is a binary tree.
04:57:00 <hpc> and neither one is superior; it depends on what you need it for
04:57:03 <blackh> blackdog: Well, that would be a good reason - is that written somewhere?
04:57:03 <proppy> updated http://hackage.haskell.org/trac/ghc/ticket/3353#comment:3
04:57:44 <osaunders> hpc: I phrased that a little softly. I'm actually quite confident the first isn't a binary tree.
04:57:49 <osaunders> I've used it.
04:57:55 <blackdog> blackh http://old.nabble.com/MTL-vs-Transformers.-Any-status-update--td26534986.html
04:58:13 <blackdog> not official, per se
04:58:22 <hpc> how isn't it a binary tree?
04:58:30 <osaunders> How is it?
04:58:34 <hpc> each leaf can have at most two leaves
04:58:45 <blackh> blackdog: If the platform is deprecating it, then that's good enough for me - thanks for that. That's been bugging me for a while.
04:58:59 <hpc> that's all it has to do to be a binary tree
04:59:08 <Botje> s/each leaf/each node/
04:59:15 <koeien37> hpc: well, you might define it as having either 2 or 0 children
04:59:23 <blackh> blackdog: I nearly have my plane tickets.
04:59:42 <osaunders> Hm.
04:59:44 <hpc> im using the wikipedia definition
04:59:47 <blackdog> blackh: excellent:) i've just got back from railscamp, i'm pretty jazzed about doing the same sort of thing with haskell hackers.
04:59:51 <hpc> http://upload.wikimedia.org/wikipedia/commons/f/f7/Binary_tree.svg
05:00:10 <blackh> blackdog: There will be much great good!
05:00:40 <hpc> what it isn't is a sorted binary tree, but that depends on more than just the signature of the constructor
05:01:07 <osaunders> Now I'm really confused.
05:01:31 * hackagebot xhaskell-library 0.0.6 - Replaces/Enhances Text.Regex  http://hackage.haskell.org/package/xhaskell-library-0.0.6 (KennyLu)
05:01:43 <osaunders> Are you allowed to have nodes with only one other connecting node on a binary tree?
05:01:57 <hpc> yes, according to the wiki page
05:02:04 <blackdog> osaunders: i think you're thinking of a complete binary tree
05:02:15 <blackdog> they're nice because you can represent them as arrays
05:02:18 <osaunders> Because I thought it was 2 or 0.
05:02:41 <blackdog> osaunders: oh. yes, that definition allows 2 or none
05:02:53 <blackdog> it's just that the nil tree is a legit tree
05:03:03 <osaunders> blackdog: nil tree?
05:03:07 <hpc> empty tree
05:03:16 <osaunders> Oh right, sure.
05:03:31 <blackdog> look at the picture on wiki - the 9 has a left child but no right child
05:03:55 <osaunders> Yeah.
05:04:04 <osaunders> Damn.
05:04:21 <hpc> you have to be able to allow for nodes with one leaf, otherwise not all tree sizes are possible
05:04:31 <osaunders> OK well hpc it seems I owe you an apology.
05:04:53 <hpc> nah, i would have made the same mistake
05:05:35 <osaunders> So normal trees don't have nil nodes.
05:06:03 <blackdog> osaunders: yeah they do
05:06:12 <blackdog> how else would you indicate that you've stopped going down?
05:06:48 <blackdog> if you were in lisp, you could store an immediate value in the car/cdr rather than a pointer, but we're typesafe in this here chatroom
05:06:57 <osaunders> With `data Tree = Node String [Tree]` you have Node "foo" []. But now actual nil node. Right?
05:06:57 <hpc> well, for my symbolic differentiator: data Function = Constant Double | Variable | Function Function String Function
05:07:04 <hpc> that's another way to do it
05:07:10 <osaunders> s/now/no
05:07:31 <blackdog> osaunders: exactly. it's implicit.
05:08:26 <cebewee> Or you could use data Tree = Leaf String | Node Tree Tree.
05:08:55 <osaunders> Isn't that a binary tree again?
05:08:58 <proppy> Igloo: thanks for correcting me on #3353 :)
05:09:20 <proppy> I think it was still usefull to link the patch here, in case people wants to compile c2hs with 6.12.1 :)
05:09:20 <cebewee> A binary tree without Nil nodes (but also without values on the inner nodes)
05:09:44 <blackdog> proppy: patch to c2hs?
05:09:54 <blackdog> that bloody CLDouble thing?
05:10:04 <osaunders> cebewee: Interesting.
05:10:11 <Schalken> is there an easy way to implement getters and setters on top of a data constructor from another module, without writing out a get and set function for each field?
05:10:22 <hpc> record syntax
05:10:30 <hpc> oh, another module
05:11:07 <proppy> blackdog: y
05:11:16 <Schalken> hpc: can I redefine the constructor with record syntax for my own purposes and have it compatible with the existing constructor?
05:11:16 <hpc> well, setters would use something like
05:11:34 <hpc> f {something=thing_to_set_to}
05:11:44 <hpc> no
05:11:51 <hpc> you would be making a new structure
05:12:50 <proppy> is anymore able to install Hieroglyph with cabal ?
05:12:56 <Schalken> hpc: so can i implement the "f { field = value }" interface on top of this constructor at all?
05:13:01 <proppy> I get cabal: cannot configure Hieroglyph-3.89. It requires base ==4.1.0.0
05:13:17 <proppy> and it seems I got base ==4.2 installed
05:13:35 <proppy> does hiroglyph package dependencies needs to be updated ?
05:13:39 <quicksilver> that means it doesn't work with your GHC version
05:13:39 <exDM69> that is a problem
05:13:42 <quicksilver> (or it claims not to)
05:13:49 <quicksilver> base versions are tied to GHC versoins
05:14:01 <hpc> no, if it doesn't use record syntax
05:14:06 <exDM69> I've had similar issues with packages requiring a specific version of base
05:14:22 <hpc> you will need to modify the actual module
05:14:55 <Schalken> hpc: right, and since i cant i have to write out getters and setters manually...right?
05:15:02 <hpc> yeah
05:15:11 <Schalken> hpc: cool, thanks for your help. :)
05:15:56 <quicksilver> Schalken: there is code to write accessors like that for you.
05:16:23 <Schalken> quicksilver: as in a haskell code generator, or something within haskell itself?
05:18:03 <quicksilver> Schalken: Template Haskell
05:18:22 <quicksilver> see http://community.haskell.org/~ndm/darcs/derive/derive.htm and possibly fclabels (on hackage) and probably other things too.
05:19:51 <Schalken> quicksilver: oooh. i was just trying to save a dozen or so lines of code, so maybe thats a bit much. thanks anyway. :)
05:20:22 <dv-> I was just looking at fclabels. Seems nice
05:21:43 <blackh> I've just been comparing fclabels, lenses and data-accessor.  fclabels looks best with the small amount of time I spent on it.
05:24:38 <Cale> The 'records' package looks really cool, but I couldn't get it to actually work.
05:25:38 <quicksilver> blackh: this annoying TH-version dependency seems an annoying problem in practice.
05:25:52 <quicksilver> blackh: if you were inclined to write a mailing list post giving a comparison that would be very interesting.
05:26:04 <quicksilver> or even a "weblog post" if you want to get all 2.0 about it.
05:26:18 <Cale> I should probably take a closer look at what's going wrong with it.
05:26:29 <Cale> Because if it only worked, it would be really cool :)
05:26:45 <fax> does anyone have a one liner for picking variables out lists fairly?
05:27:07 <fax> like a <- [1..], b <- [1..] ... but better
05:27:34 <quicksilver> fax: not a oneliner, but Control.Monad.Omega
05:27:46 <Cale> > [1..] >>- \a -> [1..] >>- \b -> return (a,b)
05:27:47 <lambdabot>   [(1,1),(2,1),(1,2),(3,1),(1,3),(2,2),(1,4),(4,1),(1,5),(2,3),(1,6),(3,2),(1...
05:27:56 <Cale> logict
05:28:12 <Cale> Control.Monad.Omega defines a monad instance that it shouldn't
05:28:16 <fax> @let i f = [2..] >>- f
05:28:17 <lambdabot>  Defined.
05:28:33 <blackh> quicksilver: I am too busy! Even too busy to spend any time deciding properly between them. I don't use TH so the version dependency doesn't seem too bad.  I did have to hack fclabels to accept the newer monads-fd though, or it refused to build.
05:29:01 <fax> @let j f = i (\x -> i (\y -> return (x :+ y)))
05:29:01 <lambdabot>  <local>:5:6:
05:29:01 <lambdabot>      Ambiguous occurrence `i'
05:29:02 <lambdabot>      It could refer to either `L....
05:29:04 <fax> :((((
05:29:19 <fax> @let gauss f = [2..] >>- (\x -> [2..] >>- (\y -> return (x :+ y)))
05:29:20 <lambdabot>  Defined.
05:29:42 <quicksilver> blackh: :)
05:30:05 <fax> > gauss $ \x -> gauss $ \y -> gauss $ \z -> [3..] >>- $ \n -> guard (x^n + y^n == z^n) >> return (x,y,z,n)
05:30:06 <lambdabot>   <no location info>: parse error on input `$'
05:30:23 <fax> > head (gauss $ \x -> gauss $ \y -> gauss $ \z -> [3..] >>- \n -> guard (x^n + y^n == z^n) >> return (x,y,z,n))
05:30:24 <lambdabot>   2.0 :+ 2.0
05:30:33 <fax> what has gone wrong here??
05:30:39 <fax> I was after a (x,y,z,n)
05:30:59 <fax> how odd
05:31:06 <fax> @undef
05:31:07 <xerox> ?type >>-
05:31:08 <lambdabot> parse error on input `>>-'
05:31:12 <xerox> ?type (>>-)
05:31:13 <lambdabot> forall (m :: * -> *) a b. (MonadLogic m) => m a -> (a -> m b) -> m b
05:31:16 <xerox> whoa.
05:31:20 <fax> @let gauss f = [2..] >>- (\x -> [2..] >>- (\y -> f (x :+ y)))
05:31:20 <lambdabot>  Defined.
05:31:23 <fax> > head (gauss $ \x -> gauss $ \y -> gauss $ \z -> [3..] >>- \n -> guard (x^n + y^n == z^n) >> return (x,y,z,n))
05:31:24 <lambdabot>   (2.0 :+ 2.0,2.0 :+ 2.0,2.0 :+ 2.0,683)
05:31:28 <fax> there we go!
05:31:51 <fax> > (2.0 :+ 2.0)^683 + (,2.0 :+ 2.0)^683 == (2.0 :+ 2.0)^683
05:31:52 <lambdabot>   <no location info>: parse error on input `2.0'
05:31:54 <fax> > (2.0 :+ 2.0)^683 + (2.0 :+ 2.0)^683 == (2.0 :+ 2.0)^683
05:31:55 <lambdabot>   True
05:31:59 <fax> so that disproves fermats last theorem
05:32:03 <xerox> no
05:32:07 <fax> imo
05:32:14 <xerox> reread the statement
05:32:36 <fax> > take 4 (gauss $ \x -> gauss $ \y -> gauss $ \z -> [3..] >>- \n -> guard (x^n + y^n == z^n) >> return (x,y,z,n))
05:32:39 <idnar> fax: I have an explanation of why you're wrong, but unfortunately this IRC window is too small to contain it
05:32:40 <lambdabot>   mueval-core: Time limit exceeded
05:33:19 <xerox> idnar: it takes 8 characters
05:33:22 <Cale> So what are the positive integers a,b,c and integer exponent n > 2 for which a^n + b^n = c^n?
05:33:25 <fax> wait im confused
05:33:29 <fax> http://www.wolframalpha.com/input/?i=%282%2B2i%29^683+%2B+%282%2B2i%29^683+%3D+%282%2B2i%29^683
05:33:33 <fax> wolfram alpha says it's not true
05:33:35 <xerox> > length "integers"
05:33:35 <fax> but haskell said its true
05:33:36 <lambdabot>   8
05:34:07 <Cale> > (2:+2)^683
05:34:08 <lambdabot>   (-Infinity) :+ Infinity
05:34:12 <Cale> lol
05:34:14 <fax> hahaha
05:34:21 <fax> oh well
05:34:26 <quicksilver> fax: your wolfram is wrong as well
05:34:28 <fax> ill have to take a differen approach
05:34:29 <quicksilver> (but it's not true)
05:34:33 <quicksilver> you need + not times
05:34:41 <quicksilver> http://www.wolframalpha.com/input/?i=(2+%2B+2i)^683+%2B++(2+%2B+2i)^683+%3D+(2+%2B+2i)^683
05:34:55 <xerox> they should do something about those urls
05:35:22 <idnar> quicksilver: that looks the same to me
05:35:24 <fax> so are there any gaussian integers which x^n+y^n=z^n
05:35:32 <quicksilver> idnar: oh, the URL must be broken. Sorry
05:35:44 <xerox> fax: (0,0,0)
05:35:50 <fax> not zero :/
05:35:58 <idnar> (2 + 2i)^683 +  (2 + 2i)^683 = (2 + 2i)^683
05:36:07 <Cale> @let cm (a,b) (c,d) = (a*c - b*d, a*d + b*c)
05:36:08 <lambdabot>  Defined.
05:36:25 <xerox> fax: I guess there are, many
05:36:32 <fax> how can we find some?
05:36:36 <xerox> maybe depending on n
05:36:49 <fax> > take 4 (gauss $ \x -> gauss $ \y -> gauss $ \z -> [3..] >>- \n -> guard (x^n + y^n == z^n) >> return (x,y,z,n::Integer))
05:36:53 <lambdabot>   mueval-core: Time limit exceeded
05:36:57 <fax> > head (gauss $ \x -> gauss $ \y -> gauss $ \z -> [3..] >>- \n -> guard (x^n + y^n == z^n) >> return (x,y,z,n::Integer))
05:36:59 <lambdabot>   (2.0 :+ 2.0,2.0 :+ 2.0,2.0 :+ 2.0,683)
05:37:02 <fax> urgh
05:37:06 <xerox> why don't you fix n before
05:37:15 <fax> > head (gauss $ \x -> gauss $ \y -> gauss $ \z -> [3..] >>- \n -> guard (x^n + y^n == z^n) >> return (x,y,z::Complex Integer,n))
05:37:15 <lambdabot>   No instance for (GHC.Float.RealFloat GHC.Integer.Internals.Integer)
05:37:16 <lambdabot>    aris...
05:37:24 <fax> oh THAT! I hate that bug
05:37:24 <quicksilver> I don't think there will be any.
05:37:26 <fax> you can't have complex integers
05:38:20 <exDM69> fax: is it because of the Integral vs. Fractional / vs. div-issue?
05:38:37 <fax> I don't think there's any good reason
05:38:52 <Cale> There is a reason
05:39:10 <xerox> Cale: what was cm about?
05:39:19 <xerox> ah complex multiplication..
05:39:43 <Cale> The reason is signum and abs
05:39:56 <Cale> (which oughtn't be in Num anyway)
05:40:30 <fax> @let cp x 0 = (1,0) ; cp x n = cm x (cp x (n-1))
05:40:31 <lambdabot>  Defined.
05:40:47 <fax> @let ca (x,y) (u,v) = (x+u,y+v)
05:40:48 <lambdabot>  Defined.
05:41:24 <xerox> now you can state gauss-flt
05:41:27 <fax> @let gauss' f = [2..] >>- (\x -> [2..] >>- (\y -> f (x, y)))
05:41:28 <lambdabot>  Defined.
05:41:58 <fax> > head (gauss' $ \x -> gauss' $ \y -> gauss' $ \z -> [3..] >>- \n -> guard (ca (cp x n) (cp y n) == cp z n) >> return (x,y,z::(Integer,Integer),n))
05:42:01 <lambdabot>   mueval-core: Time limit exceeded
05:42:08 <fax> so there aren't any
05:42:11 <fax> QED
05:42:21 <Cale> heh
05:42:22 <xerox> does that kind of search diagonalize?
05:42:29 <fax> xerox, yes
05:44:43 <Cale> Though it does so in a way which is a bit suboptimal here.
05:45:08 <fax> "In 1847, Gabriel Lam√© outlined a proof of Fermat's Last Theorem based on factoring the equation xp + yp  = zp in complex numbers, specifically the cyclotomic field based on the roots of the number 1. His proof failed, however, because it assumed incorrectly that such complex numbers can be factored uniquely into primes, similar to integers"
05:45:15 <fax> but gauss integers are a UFD :S
05:45:20 <Cale> Half of the things you're testing have real part equal to 2
05:46:50 <Cale> Yeah, that's not talking about the Gaussian integers.
05:46:52 <xerox> Cale: how does it do that?
05:46:55 <fax> oh I see
05:47:11 <Cale> It's talking about the cyclotomic field Q(zeta_n)
05:47:21 <xerox> for a primitive zeta_n
05:47:24 <Cale> yeah
05:47:43 <fax> (1 + 5sqrt(d))^3  +  (5 + 3sqrt(d))^3  =  (3 + 4sqrt(d))^3
05:47:49 <fax> oops
05:48:08 <fax> > (1 + 5*sqrt(-3/2))^3  +  (5 + 3*sqrt(-3/2))^3  ==  (3 + 4*sqrt(-3/2))^3
05:48:09 <lambdabot>   False
05:48:13 <fax> hrfm
05:48:21 <fax> > (1 + 5*sqrt(-3/2))^3  +  (5 + 3*sqrt(-3/2))^3  -  (3 + 4*sqrt(-3/2))^3
05:48:21 <lambdabot>   NaN
05:48:31 <fax> why is haskell always giving me rubbish answers today
05:48:36 <fax> i don't want NaN
05:48:40 <fax> or "Infinity"
05:48:46 <fax> > (1 + 5*sqrt(-3/2))^3  +  (5 + 3*sqrt(-3/2))^3  -  (3 + 4*sqrt(-3/2))^3 :: Complex Double
05:48:47 <lambdabot>   (-2.842170943040401e-14) :+ 0.0
05:48:51 <fax> thats zero ^
05:50:18 <fax> What would be a good internal representation for numbers that have well coefficents in Q(i) but also square roots and maybe more roots
05:50:21 <fax> ?
05:50:22 <gerryxiao> hello
05:50:24 <fax> if you wanted to exact computation with algebraic numbers
05:50:33 <fax> hi
05:50:40 <fax> maybe not quite algebraic, but irrational
05:50:42 <xerox> fax: each root you add changes the field
05:50:44 <gerryxiao> why runMaybeT (return 3)  = Just 3 ?
05:51:02 <yitz> preflex seen dons
05:51:02 <preflex>  dons was last seen on #haskell 6 hours, 50 minutes and 49 seconds ago, saying: if its simple, maybe write the app in both, and tell us which was easier!
05:51:09 <xerox> gerryxiao: because it's Maybe over some other monad
05:51:24 <yitz> anyone know where to report bugs for the haskell platform?
05:51:27 <fax> so if I was to implement this in haskell what should I use?
05:51:31 <gerryxiao> xerox: i shold get a monad value
05:51:35 <fax> or do I have to invent it myself
05:51:46 <gerryxiao> s/shold/should
05:51:56 <xerox> gerryxiao: where did you get MaybeT from
05:52:20 <xerox> aha, are you doing that in ghci?
05:52:29 <Dodek> hey, is there a function which replaces an element of a list at a given index?
05:52:31 <xerox> I guess it's picking IO and printing it, like it does with IO actions
05:52:35 <Dodek> i mean, in standard library
05:52:51 <gerryxiao> xerox: where?
05:53:01 <fax> Q(sqrt(-1),sqrt(2),sqrt(3),sqrt(5),...)
05:53:05 <dankna> Dodek: In Haskell that would mean re-creating the entire list, don't forget
05:53:05 <yitz> fax: hmm. unfortunately, Data.Complex requires RealFloat.
05:53:09 <fax> infinite dimensional
05:53:25 <gerryxiao> Control.Monad.Trans.Maybe?
05:53:26 <xerox> fax: the algebraic numbers?
05:53:36 <xerox> that would be fun, except I don't know how to encode it
05:53:36 <dankna> Dodek: I don't think that's really what you want, as it's O(n).  I think you want a different data structure, maybe a custom finger-tree.
05:53:37 <Dodek> dankna: it depends on the position, but yes, i know that
05:53:39 <fax> well that's not algebraic
05:53:45 <dankna> Dodek: fair, yes.
05:53:49 <yitz> fax: so you would have to re-implement that with a more lenient class restriction. bummer. it's just cut and paste though.
05:53:49 <Dodek> dankna: i have up to 10 elements on a list.
05:53:51 <fax> but it's the first step
05:53:57 <xerox> fax: yes it is
05:54:07 <fax> yitz, yeah I have reimplemented numbers myself
05:54:09 <dankna> Dodek: well, with that caution given, I don't know the answer but I suspect there is no such function for the reason I gave.  You can easily write it though.
05:54:17 <yitz> fax:  that get's you your Q[i]. Then you
05:54:23 <Dodek> okay, i just did not want to reinvent the wheel
05:54:26 <dankna> yeah
05:54:27 <fax> xerox, what about sqrt(sqrt(2)) ?
05:54:32 <yitz> 're on your own for the square roots :)
05:54:35 <xerox> yitz: nope it gets something more
05:54:42 <fax> I don't think I can represent that in my Q
05:54:43 <Cale> Dodek: replace n a xs = [if k == n then a else x | (k,x) <- zip [0..] xs]
05:54:43 <fax> extended
05:55:13 <Dodek> Cale: woudln't that recreate the whole list?
05:55:14 <xerox> yitz: i.e. the degree of that thing (whatever comes after "...") isn't 2
05:55:29 <Cale> Dodek: It's not a very efficient operation in general. You could use splitAt as well, which is a little better, but it will still recreate everything up to the changed element.
05:55:33 <fax> > 781769**12 + 852723**12 - 874456**12
05:55:34 <lambdabot>   0.0
05:55:36 <xerox> e.g. sqrt(i) is in that field
05:55:44 <fax> there, now I have disproved fermats last theorem!
05:55:45 <Dodek> Cale: ah, splitAt.
05:55:49 <xerox> (but it isn't in Q(i))
05:55:52 <Cale> Dodek: If you need random access and updates, lists are just the wrong structure in general.
05:56:18 <Dodek> Cale: i know, i just don't have enough elements to care
05:56:19 <Cale> Dodek: But I suppose for small enough cases, it doesn't matter so much, since you know it'll take at most 10 steps or something.
05:56:32 <Dodek> i could even hardcode that, but that would have been ugly
05:56:50 <yitz> > 781769^12 + 852723^12 - 874456^12 -- sorry to spoil your fun, fax
05:56:51 <lambdabot>   -347556962514758894125372771210040333239190747849657454
05:57:40 <fax> I wonder how I could make a data type that is a field extention of Q, and is closed under square roots
05:57:48 <Cale> You guys could represent extension fields the same way they're defined in mathematics basically.
05:57:51 <fax> it seems a shame to stop there though, because what about cube roots and such
05:58:08 <Cale> Yeah, you could also just represent the whole field of algebraic numbers
05:58:21 <xerox> fax http://en.wikipedia.org/wiki/Algebraic_number#The_field_of_algebraic_numbers
05:58:26 <fax> I dont' know how to do algebraic numbers, but I can see what you mean about the math thing
05:58:32 <xerox> Cale: that would be fun but ~how~
05:58:46 <fax> that would work -- that's a really nice way to do it, oh but I would have to write a thing that tests if a polynomial is irreducible?
05:58:52 <koeien37> represent a number by a (minimal) polynomial?
05:58:57 <Cale> The whole field of algebraic numbers would be a good deal more complicated to do well than finite extensions over Q
05:59:17 <Cale> Yeah, you'd represent numbers by minimal polynomials together with a root index of some type
05:59:19 <fax> what would be the difference?
05:59:53 <Cale> The tricky part is discerning between the various roots of a single minimal polynomial.
06:00:13 <fax> "This can be rephrased by saying that the field of algebraic numbers is algebraically closed." Wow!! I thought only |C was
06:00:23 <fax> I guess that's why they call it "algebraically closed" XD
06:00:25 <Cale> Nope, A is as well.
06:00:31 <koeien37> fax: every field has an algebraic closure
06:00:36 <fax> and write it with a closure symbol
06:00:38 <Cale> Also, various extensions of Z_p
06:00:43 <fax> I never realised this before!
06:01:04 <fax> so |C = |R^bar
06:01:10 <koeien37> fax: correct, yes
06:01:11 <xerox> it's easy to show
06:01:16 <koeien37> but C != Q^bar
06:01:40 <gerryxiao> runMaybeT (return 3)   here what's inner monad?
06:01:42 <fax> okay so what is the difference between Q --> Q(sqrt(-1)) --> Q(sqrt(-1),sqrt(2)) --> ..., and |Q^bar?
06:01:58 <Cale> gerryxiao: any monad.
06:02:00 <fax> the first one would grow to accomidate whatever operations you do
06:02:38 <fax> by the way, these algebraic numbers would probably have to be used in a monad
06:02:50 <fax> rather than the normal x + y type stuff we write
06:02:57 <Cale> fax: There are polynomials whose roots are not expressible in terms of nth roots, algebraic operations, and integers
06:03:12 <fax> oh right
06:03:15 <Cale> (the smallest degree of such a polynomial is 5)
06:03:17 <xerox> take a root  a  of a polynomial  a_i x^i  over the algebraic numbers, each a_i is algebraic so Q(a_0,a_1,...a_n) is finite, say of degree m, thus [Q(a_0,...,a_n,a):Q]=[Q(a_0,...,a_n,a):Q(a_0,...,a_n)][Q(a_0,...,a_n):Q]<=n*m is finite, hence algebraic
06:03:26 <fax> so what should I call the first one? since it's not quite algebraic numbers
06:03:34 <fax> it's sort of like radical numbers
06:04:32 <xerox> yours is usually the counterexample used to show  algebraic extension =/=> finite extension  while the other direction holds
06:04:55 <Drone022> hey
06:04:59 <Drone022> anyone here?
06:05:08 <koeien37> sure! lots of people. how can we help?
06:05:09 <Cale> yep
06:05:10 * dankna hides behind the couch
06:05:19 <Cale> There are apparently 671 of us.
06:05:21 <Drone022> ah cool, quick question
06:05:36 <Cale> (most idling though)
06:06:00 <Drone022> [1..floor(sqrt x)] gives me an error
06:06:15 <Drone022> but shouldnt the floor function convert the sqrt float to an int?
06:06:20 <xerox> ?type floor
06:06:21 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
06:06:45 <Cale> yes, it should
06:06:52 <xerox> the problem may be x has a fixed type, like an integer? floor (sqrt (fromIntegral x))
06:06:58 <Cale> That code on its own is fine
06:06:58 <koeien37> > [1.. floor (sqrt 37)]
06:06:59 <lambdabot>   [1,2,3,4,5,6]
06:07:00 <fax> um
06:07:00 <Schalken> is "a :: b -> IO (Maybe b)" bad style? putting a monad in a monad?
06:07:07 <fax> If I define my base field type Base = Complex (Rational Integer)
06:07:15 <Cale> Schalken: no, that's fine
06:07:27 <fax> then I can\t define sqrt :: (x :: F) -> extend F (sqrt(x))
06:07:32 <Cale> Schalken: Sometimes the fact that something is a monad is pretty irrelevant.
06:07:33 <fax> that kind of sucks ?
06:08:06 <Schalken> Cale: Thanks. :)
06:08:17 <fax> If I only use square roots that would be constructible numbers
06:08:42 <Cale> Schalken: The only thing that distinguishes a monad from any other type constructor is that a particular interface of functions is supported.
06:09:02 <Drone022> so fromIntegral returns a Num from an Integral?
06:09:05 <roconnor> > exp (0.0025)
06:09:05 <lambdabot>   1.0025031276057952
06:09:32 <theorbtwo> Drone022:
06:09:36 <theorbtwo> :t fromIntegral
06:09:37 <lambdabot> forall a b. (Integral a, Num b) => a -> b
06:09:44 <Cale> Drone022: Yeah, it takes anything of an Integral type, and produces something of any Num type.
06:09:48 <theorbtwo> Yes.
06:10:10 <Drone022> ok, thanks, problem solved
06:10:11 <Cale> Num and Integral aren't themselves types, but classes to which types may belong
06:10:26 <Drone022> ah I see
06:10:33 <Cale> For example, Integer and Int are instances of both. Float is an instance of Num, but not Integral
06:10:43 <Schalken> Cale: right, but i was just thinking i could replace the Nothing of the Maybe with an error in the IO monad. but my reasoning is only IO errors (which this isn't) should go in the IO monad - right?
06:11:05 <Cale> Schalken: That's usually pretty good reasoning.
06:11:15 <Schalken> Cale: cool.
06:11:28 <fax> how is algebraic numbers harder than radicals?
06:11:34 <Cale> Schalken: You can invent your own exceptions now that there's an extensible exception library, but it's often still more convenient just to use Maybe when that seems like it'll do.
06:11:39 <Drone022> haskell is awesome
06:12:09 <Cale> fax: Because you have to disambiguate the various roots of a degree 5 polynomial, say.
06:12:33 <fax> why do you have to disambiguate if they are automorphic?
06:13:36 <koeien37> for radicals you also have to disambiguate right?
06:13:59 <fax>  I don't know
06:14:06 <Cale> right, though there's an easier system of canonical choice for radicals
06:14:14 <ivanm> I need an image for students to use when demoing their image manipulation assignment; any suggestions?
06:14:18 <xerox> are you talking only about irreducible polys?
06:14:49 <Cale> xerox: I'm talking about how just knowing the minimal polynomial of some algebraic number isn't really enough to pin down which number it is.
06:14:57 <koeien37> ivanm: take a high-resolution picture of the planet?
06:15:02 <Cale> ivanm: Lena, of course.
06:15:07 <ivanm> Cale: heh
06:15:23 <fax> but any algebraic equation you can swap the roots around so does it really matter which one we take?
06:15:36 <ivanm> koeien37: they're doing PPM manipulation where type Image = [[(Int, Int, Int)]] ; do you really think a high res shot is appropriate?
06:15:40 <fax> hmmm
06:15:47 <fax> well suppose you did a long calculation which had two results
06:15:49 <ivanm> Cale: isn't Lena only for testing compression algorithms though?
06:16:00 <fax> then we would really define a set of pairs of numbers?
06:16:01 <xerox> depends what you want, Cale wants the number, and a fixed polynomial gives you a set of numbers
06:16:04 <Botje> at least it's something interesting to look at :P
06:16:14 <dankna> list of list of values?!  wow, people are laaaaazy
06:16:17 <Cale> ivanm: I think I've seen that picture used in some other settings.
06:16:21 <roconnor> Cale: but saying cuberoot(2) also doesn't pin down a number
06:16:23 <Cale> dankna: huh?
06:16:35 <ivanm> hmmm...
06:16:46 <Cale> ivanm: Edge detection stuff
06:16:47 <fax> yeah that cuberoot(2) is a bit spooky
06:16:50 <ivanm> ahhh
06:16:52 <ivanm> dankna: if that was for me, this was a first year assignment
06:16:52 <xerox> it's like, we are used to i being what it is, but all would work the same if we used -i in place
06:17:04 <ivanm> and the image parser/writer was written for them
06:17:10 <ivanm> they had to just do stuff _with_ the image
06:17:13 <roconnor> though I guess there is a unique positive real root when given a positive real input.
06:17:35 <fax> as far as Q is concerned, there is no difference between the complex cube roots and the real one
06:17:39 <dankna> ivanm: fair enough.
06:17:39 <Cale> Though I guess edge detection is also an important part of the compression breakfast :)
06:17:49 <koeien37> ivanm: then it's a little bit too big maybe :)
06:18:25 <ivanm> I was trying to thin of a more Haskell-related image, but unless I use the textbook cover or something then either 1) they won't get it or 2) it's not interesting enough :s
06:18:59 <Botje> use spongebob squarepants! kids love it! :P
06:19:19 <ivanm> Botje: 1st year uni, not 1st year of school....
06:19:55 <fax> I think this radical numbers thing is gonna be a bit like ST monad
06:19:55 <mxc> hi
06:20:07 <mxc> what are the safe use conditions for MArray.unsafeFreeze
06:20:15 <fax> except without the rigid type variable
06:20:30 <mxc> as in, if its only ever accessd by a single thread, guarded by an mvar, what could make it cause Seg Faults?
06:24:52 <fax> mxc, well I don't know the saftey preconditions but you know what I would say about it...
06:26:09 <abberaman> hi!
06:26:14 <fax> hi
06:26:15 <roconnor> fax: to be fair Q knows the different roots are different
06:26:25 <dino-> Does anyone have experience with hscurses or nanocurses and colors?
06:26:29 <roconnor> I think
06:26:31 <fax> roconnor but we just proved they are automorphic the other day, ? what do you mean
06:26:44 <fax> it's only when you break out the trancendental functions that you can distinguish them, I think
06:26:47 <roconnor> fax: Q knows that there are 3 roots and they are unequal
06:26:56 <fax> oh right
06:26:56 <dino-> Specifically, I'm unsure how to get a Pair to be an attribute in the absense of being able to use the C macro that's used for this normally.
06:27:17 <fax> yes they are not equal but you can swap them in any algebraic equation
06:27:30 <roconnor> fax: ya
06:27:41 <roconnor> It's like having 3 idential marbles
06:27:46 <roconnor> identical
06:28:03 <roconnor> you know there are 3 of them and they are each at different locations
06:28:04 <fax> what I was thinking is, because they _are_ 3 different values.. is that any computation you do with these numbers, at the end you might be able to 'freeze' it (maybe get an approximation, or a Complex CReal) -- but in that case you'd get 3 different answers
06:28:17 <roconnor> but if someone wizard swaped the marbles around, you'd never catch it
06:28:42 <roconnor> fax: well, if you bring Complex CReal into the picture then you've painted the marbles
06:28:48 <roconnor> different colours
06:30:19 <domor> let's say I have a list of functions [(+),(*)], which I'd like to print somehow. I'm pretty sure I'll have no choice but to put them in a datatype, but just in case, is there an easier way?
06:30:37 <ivanm> domor: nope
06:30:43 <fax> domor: it it a specific instance of Num or not?
06:30:54 <domor> fax: it is
06:30:54 <ivanm> domor: unless you define an instance for functions, but you can't distinguish what function it is
06:30:58 <ivanm> (when printing)
06:31:05 <fax> yeah there's no way to do it
06:31:21 <fasta> Is there in any language anyone who has ever built a system in which files and source code is generally stored in memory with only backups to disk in which "rebuilds" are near instantaneous?
06:31:21 <domor> fax, ivanm: thanks
06:31:32 <ivanm> domor: no worries
06:31:59 <EvanR-work> fasta: reading files is the bottleneck?
06:32:11 <EvanR-work> i would think its the compilation process
06:32:39 <fasta> EvanR-work, it is more that a one line change should take not more than 0.3 seconds to work again.
06:33:03 <EvanR-work> a one line change requires rebuilding the entire file
06:33:04 <Botje> fasta: smalltalk and self, and image-based systems in general can do that
06:33:21 <fasta> Botje, yes, but smalltalk and self don't care for efficiency.
06:33:36 <Botje> fasta: beg pardon?
06:33:43 <Botje> the self people are _obsessed_ with speed
06:33:54 <Botje> and modern smalltalk implementations are pretty speedy, too
06:34:01 <fasta> Botje, if that is the case, where are all the fast programs?
06:34:14 <fasta> Botje, they already convinced me of their superior tools.
06:34:23 <fasta> Botje, it is just that it is sluggish.
06:34:31 <abberaman> How do you use hpaste? I'm getting "internal server error, database is locked" when I try to load http://hpaste.org/
06:34:38 <EvanR-work> hpaste is broke
06:34:41 <Botje> they can't hold a candle to fortran et al, true
06:34:50 <Botje> but smalltalk with a jit is okay :)
06:35:00 <fasta> Botje, if they would introduce a static sublanguage, it would be great.
06:35:08 <Botje> :)
06:35:16 <abberaman> ok.. I'm having some trouble with classes in haskell
06:36:14 <abberaman> I import Data.Complex, then I have "class Adjointable a where adjoint :: a -> a" and then I try (and fail) this "instance Adjointable (Complex Double) where adjoint = conjugate"
06:36:17 <fasta> Botje, do you know anything about Self other than watching e.g. their video?
06:36:29 <fax> :t conjugate
06:36:30 <lambdabot> forall a. (RealFloat a) => Complex a -> Complex a
06:36:39 <fax> abberaman: that should work.. I am confused
06:36:48 <fasta> Botje, as in: have you actually written a program of at least a hundred lines in it?
06:37:03 <abberaman> ghc 6.10.2
06:37:28 <fax> abberaman: that *does* work I just tried it
06:37:31 <Botje> no, but i've been reading the papers where they show their optimizations
06:37:41 <Botje> playing with self is for when i have a bit more time :)
06:37:56 <abberaman> fax: I get Illegal instance declaration for `Adjointable (Complex Double)'
06:37:57 <fax> @remember < Botje> playing with self is for when i have a bit more time :)
06:37:58 <lambdabot> I will remember.
06:38:15 <fax> import Data.Complex
06:38:15 <fax> class Adjointable a where adjoint :: a -> a
06:38:15 <fax> instance Adjointable (Complex Double) where adjoint = conjugate
06:38:18 <fax> that works for me ^
06:38:20 <Botje> fasta: grr :)
06:38:30 <fasta> Botje, a language in which you can add invariants later (when you require speed) would be nice.
06:38:47 <Botje> .oO(now you're entering lisp territory *runs*)
06:38:53 <fasta> Botje, and it is not really the language that is important, which many reseachers seem to thing, it is the whole package.
06:39:00 <fasta> researchers*
06:39:14 <zygoloid> abberaman: you need -XFlexibleInstances for that instance
06:39:33 <zygoloid> abberaman: haskell'98 requires instances to be for (T a b c) where a, b, c are variables
06:40:25 <abberaman> zygoloid: Thanks. So in 98 there is no way to do this?
06:41:07 <Botje> fasta: agreed.
06:41:10 <fax> doh
06:41:15 <zygoloid> you can use a newtype, or define an instance for RealFloat a => Complex a, or define a class IsDouble a, and then an instance for IsDouble a => Complex a
06:41:27 <Botje> we only recently published an IDE for the language we created
06:41:34 <fax> abberman, yeah sorry -- I didn't think.. This is what's in my .ghci
06:41:35 <zygoloid> abberaman: but FlexibleInstances is pretty safe
06:41:37 <fax> :set -XNoMonomorphismRestriction -XFlexibleInstances -XTypeOperators
06:41:38 <fax> :set -XMultiParamTypeClasses -XGADTs -XEmptyDataDecls -XRankNTypes
06:41:38 <fax> :set -XScopedTypeVariables -XFlexibleContexts -XTypeSynonymInstances
06:41:59 <Botje> wow. that's pretty hardcore.
06:42:22 <zygoloid> abberaman: did ghc not give you an error message explaining all this?
06:42:39 <zygoloid> 6.8.3 seems to give pretty good errors for this particular case
06:42:47 <abberaman> ok, how do I do the general case, like "instance Adjointable (RealFloat a => Complex a) where adjoint = conjugate" except that it should work
06:43:10 <zygoloid> that's written as: instance RealFloat a => Adjointable (Complex a) where adjoint = conjugate
06:44:23 <abberaman> zygoloid: yes, but I thought I shouldn't be turning on all the extensions until I understand a little more
06:46:23 <abberaman> ok, and now I have the other errors fixed as well, wonderful!
06:46:40 <zygoloid> ok. well, the haskell'98 rule is pretty strict. i think FlexibleInstances rules out some implementation strategies for typeclasses, but not ones which are actually used...
06:48:26 <abberaman> gotta go..
06:55:19 <EvanR-work> i asked yesterday about formatting tips on do blocks and general stuff to keep my code not so wide
06:55:31 <EvanR-work> but i didnt ask about if then else
06:55:42 <EvanR-work> how to format nicely if then else in a do block
06:55:44 <fax> I never use if/then/else
06:55:57 <fax> I define bool as a fold on Bool and use that instead
06:57:27 <EvanR-work> hm thats not too bad
06:57:46 <Schalken> what monad transformer would I use to combine "IO (Maybe a)" ?
06:58:21 <dv-> Combine how?
06:59:46 <yitz> preflex seen dons
06:59:47 <preflex>  dons was last seen on #haskell 7 hours, 59 minutes and 33 seconds ago, saying: if its simple, maybe write the app in both, and tell us which was easier!
07:04:21 <Schalken> dv-: I have "f :: a -> IO (Maybe a)", "g :: a -> Maybe a", "h :: a -> IO (Maybe a)", "f x = case (g x) of Nothing -> return Nothing; Just a -> h a"
07:04:44 <Schalken> dv-: I want to use Maybe's monad interface to get rid of the case expression.
07:05:29 <Schalken> dv-: But I dont know how, because the end result I want is IO (Maybe a). :/
07:06:08 <EvanR-work> :t return Nothing
07:06:09 <lambdabot> forall a (m :: * -> *). (Monad m) => m (Maybe a)
07:06:09 <gerryxiao> can i delete stuff located under /home/.ghc ?
07:07:55 <hpc> :t fromMaybe
07:07:56 <lambdabot> forall a. a -> Maybe a -> a
07:09:17 <Schalken> hpc: what does "fromMaybe Nothing" reduce to?
07:09:29 <Schalken> bagh.
07:09:37 <EvanR-work> :t fromMaybe Nothing
07:09:38 <lambdabot> forall a. Maybe (Maybe a) -> Maybe a
07:10:08 <fax> wow
07:10:09 <IceDane> Schalken: You pass it the value you want it to return on Nothing
07:10:14 <fax> > fromMaybe Nothing
07:10:15 <lambdabot>   {Nothing->Nothing;Just Nothing->Nothing;Just (Just ())->Just ()}
07:10:21 <Schalken> IceDane: OH!
07:10:24 <EvanR-work> lol
07:10:28 <IceDane> > fromMaybe 0 Nothing
07:10:28 <lambdabot>   0
07:10:32 <IceDane> > fromMaybe 'c' Nothing
07:10:33 <lambdabot>   'c'
07:10:41 <hpc> >fromMaybe 'c' Just 7
07:10:45 <IceDane> > fromMaybe 'c' (Just 'b')
07:10:46 <lambdabot>   'b'
07:10:48 <hpc> er
07:11:12 <EvanR-work> i thought you legitimately wanted fromMaybe Nothing foo ;)
07:11:53 <EvanR-work> Nothing, Just Nothing, Just $ Just x ;)
07:12:49 <hpc> i would hate to see the code that spawned the Maybe Maybe
07:13:16 <IceDane> heh
07:13:21 <hpc> that would possibly be the first Haskell dailywtf
07:14:47 <Schalken> I dont think fromMaybe helps me.
07:15:11 <Schalken> Basically I want to know how to do this without pattern matching: http://pastebin.com/4U8gFEkm
07:15:19 <dino-> How about liftM g $ x >>= h  ?
07:16:37 <dino-> hmm, I get (Just (Just blah))
07:16:48 <Botje> maybe (return Nothing) h . g
07:19:15 <Schalken> Botje: "h . g" is not type correct. Or do I have the precedence wrong?
07:19:27 <Botje> it's (maybe ...) . g
07:19:30 <philo> hi i am using unafePerformIO (print $$DEBUG_MESSAGE) for debugging perposes
07:19:34 <philo> but i doesnt work
07:19:37 <philo> any help ?
07:19:37 <Botje> philo: use Debug.Trace instead
07:19:47 <Botje> philo: and it will only print something if your value is used
07:20:08 <Botje> so let _ = trace "here" undefined in ... won't work
07:20:11 <Jafet> Debug.Trace, for Blur fans
07:20:34 <philo> Botje: any pointer on why the the unsafeIO dont work ? something to do with lazyness ?
07:20:44 <Botje> philo: yep. if it's not evaluated, it won't print.
07:20:51 <Botje> philo: can you show how you're trying to use it?
07:20:56 <koeien37> if the value is not evaluated, it will not be print.
07:20:57 <Botje> (on a pastebin)
07:21:05 <philo> a sec
07:22:36 <philo> is hpase down ?
07:22:40 <philo> hpaste
07:22:51 <EvanR-work> yes
07:22:57 <EvanR-work> for at least a week
07:23:00 <koeien37> yes, try pastebin?
07:23:27 <Jafet> codepad.
07:24:18 <philo> http://pastebin.com/yaxqNgnW
07:24:56 <Botje> philo: ah yes. Debug.Trace can help you there.
07:25:14 <Botje> replace the unsafePerformIO line with () <- trace "here" ()
07:25:24 <philo> ok
07:25:28 <Botje> (the "() <-" part is really important here)
07:25:41 <philo> but i am still curious on the why...
07:26:01 <Botje> philo: do you know how do blocks are desugared?
07:26:12 <philo> yes a bit
07:26:19 <philo> know about the concept
07:26:38 <Botje> your code is roughly equivalent to return () >> convertIrExp .. >>= ...
07:26:52 <philo> ok
07:26:55 <philo> following you
07:27:02 <Botje> and >> simply ignores what its left hand side produces, so the () isn't evaluated
07:27:34 <Botje> but if you had done () <- return $ unsafePerformIO ..., it would have been forced to patternmatch
07:27:49 <EvanR-work> i have let (a,b,c) = expr in a do block, a is of type IO a (different a), to run the action i just type... a ?
07:27:50 <Botje> (nevertheless, use Debug.Trace instead, it's nicer :) )
07:28:17 <philo> Botje:  thanks
07:28:40 <Botje> EvanR-work: i think so, yes
07:34:41 <philo> Botje: should it be : () <- return $ trace "here" ()
07:37:13 <Botje> philo: uh, yeah.
07:40:11 <quicksilver> > (do () <- undefined; return 1) :: Maybe Int
07:40:12 <lambdabot>   *Exception: Prelude.undefined
07:40:24 <quicksilver> interesting. For some reason I wasn't sure that woudl work.
07:40:28 <quicksilver> Botje++
07:40:43 <sioraiocht> dcoutts: ping for super quick question
07:41:15 <fasta> philo: or you just do let !_ = trace "Foo" "bar"
07:43:32 <philo> fasta: hummm
07:43:57 <philo> now what does the "!_" means ?
07:44:02 <philo> strict evaluation ?
07:44:05 <fasta> philo: it's a trick I figured out a few years ago.
07:44:15 <fasta> philo: ! is a bang pattern.
07:44:27 <fasta> philo: you can combine it with a macro.
07:44:43 <fasta> philo: then you can just say SHOW(<some haskell expression>)
07:44:50 <fasta> philo: and it all works out.
07:45:31 <fasta> For complicated algorithms I suppose using a Writer monad is better theoretically, but that doesn't get compiled away if you don't use it.
07:46:20 <EvanR-work> for just debugging trace makes more sense
07:46:43 <EvanR-work> no point in having a logging framework set up if there are no bugs :)
07:46:52 <EvanR-work> debug log
08:01:00 <fizruk> hi all! any ideas why i get this ( http://pastebin.com/AbiPz7a7 ) when linking this ( http://www.haskell.org/haskellwiki/Simple_STM_Example ) ?
08:02:39 <koeien37> did you add --make ?
08:04:38 <fizruk> m...
08:04:39 <fizruk> no
08:05:34 <fizruk> koeien37: all's fine, lots of happyness for you
08:05:47 <gio123> does somebody knows proof irrelevance?
08:06:40 <jmcarthur> not much, but what about it?
08:06:58 <jmcarthur> and i really mean "not much"
08:07:17 <jmcarthur> maybe ask in #coq or something?
08:08:09 <gio123> i will try
08:08:10 <jmcarthur> or perhaps #agda
08:08:10 <gio123> thanks
08:08:20 <jmcarthur> coq is probably a bit more likely to be helpful
08:09:28 <jmcarthur> just because proof irrelevance probably plays a little bit more role in how coq works, at least as far as i know
08:09:43 <jmcarthur> i really need to learn coq and agda both better
08:10:01 <EvanR-work> what are they?
08:10:10 <jmcarthur> EvanR-work: coq and agda?
08:10:14 <EvanR-work> yes
08:10:56 <jmcarthur> EvanR-work: coq is a theorem prover, but you can use it for general programming too, and agda is a dependently typed programming language
08:11:05 <jmcarthur> EvanR-work: both are pretty cool
08:11:27 <EvanR-work> coq is like, logic programming?
08:11:41 <jmcarthur> EvanR-work: nah, it's more like functional programming
08:11:48 <jmcarthur> it just has a very powerful type system
08:11:51 <EvanR-work> pure and lazy like haskell?
08:11:55 <jmcarthur> and is total
08:12:02 <EvanR-work> total?
08:12:05 <jmcarthur> laziness doesn't even matter because it's strongly normalizing
08:12:22 <jmcarthur> EvanR-work: no matter what evaluation order you use it eventually arrives at the same answer
08:12:46 <EvanR-work> so it navigates around _|_ or something
08:12:57 <jmcarthur> it doesn't have _|_
08:13:00 <jmcarthur> _|_ is impossible
08:13:02 <EvanR-work> :o
08:13:31 <EvanR-work> sounds very different
08:14:39 <jmcarthur> EvanR-work: this is a very good read. i've been meaning to give it another chance, and it's highly recommended around here a lot http://adam.chlipala.net/cpdt/
08:14:52 <jmcarthur> EvanR-work: official coq page http://coq.inria.fr/
08:18:22 <jmcarthur> EvanR-work: it's critical not to have _|_. coq works by expressing proofs as values which prove their types. if it has _|_ then you would be able to prove anything
08:19:07 <EvanR-work> i take it that this leads to a program that is known to be certainly reliable?
08:19:31 <jmcarthur> EvanR-work: you can use coq to write certified programs, yes
08:19:46 <jmcarthur> EvanR-work: the first thing i liked you to explain all this very well
08:19:50 <jmcarthur> *linked you to
08:20:16 <EvanR-work> yes im reading
08:20:24 <jmcarthur> EvanR-work: you can also export haskell code from it once you've proven it correct
08:20:32 <EvanR-work> interesting
08:21:02 <EvanR-work> what does certified correct mean for a program that does i/o ?
08:21:32 <jmcarthur> EvanR-work: well, coq by itself won't do IO
08:21:43 <koeien37> yes i've seen that. probably the coq will not output IO a for some a
08:21:55 <jmcarthur> EvanR-work: but you could make an IO DSL and verify that it will do the correct things when executed
08:22:03 <EvanR-work> ok
08:25:33 <wvd> So I'm trying to do some basic things with Haskell. I was trying to fix project-euler problem 5: "What is the smallest number that is evenly divisible by all of the numbers from 1 to 20?" - It gave me the correct answer with 1 to 10, but it never seems to finish this calculating for 1-20, anyone has ideas what's wrong, and what could be improved? (i.e. - the length(..) == 20 isn't that decent, and a sidenote: i'm feeding an infinite list to problem4, was ju
08:26:03 <EvanR-work> message too long
08:26:11 <wvd> WHere it cuts?
08:26:16 <EvanR-work> ist to problem4, was ju
08:26:39 <wvd> "was just practice): http://gist.github.com/372619"
08:29:18 <wvd> It's still going
08:29:56 <Schalken> where can i find the instance decleration for "instance Monad (Either a) where..." ?
08:30:09 <jmcarthur> wvd: i would just use a different algorithm
08:30:47 <Jafet> :t lcm
08:30:48 <lambdabot> forall a. (Integral a) => a -> a -> a
08:32:22 <otto_s_> :t foldl1
08:32:22 <aavogt> Schalken: Control.Monad.Error
08:32:23 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
08:33:14 <aavogt> though that instance requires that the a meet additional requirements
08:34:14 <Schalken> aavogt: Namely that the a be an instance of Error?
08:34:52 <aavogt> yeah, something like that
08:34:58 <koeien37> maybe Control.Monad.Instances ?
08:35:05 <mreh> conal: yes please, where does this language come from? I've never really come across it before in FP
08:36:01 <conal> for context, mreh is asking about "Roughly, ¬ìfull abstraction¬î means we must not distinguish between what is (operationally) indistinguishable, while ¬ìjunk-freeness¬î means that every semantic value must be denotable."  from http://conal.net/blog/posts/garbage-collecting-the-semantics-of-frp/
08:36:10 <mreh> having used AFRP and having quite enjoyed it, i'd quite like to get up to speed
08:36:14 <Twey> Eep, crazy encoding
08:36:42 <conal> mreh: are you asking about the terms "full abstraction" and "junk-free"?
08:36:57 <mreh> conal: I wish to understand the way you have defined them
08:37:30 <conal> mreh: those terms come from denotational semantics.  we can break that sentence into its two halves, and look at each.
08:38:29 <conal> mreh: first, denotational semantics is about mapping from a data type (usually syntax, but not in my use) to a mathematical type of "meanings".
08:39:04 <conal> "full abstraction" and "junk-freeness" are two desirable properties when designing & evaluating such a mapping (a semantics).
08:39:42 <mreh> so the syntax is the denotation
08:39:54 <conal> mreh: no, the opposite.
08:40:03 <conal> mreh: meaning == denotation
08:40:12 <conal> for instance, the meaning of "3" is the number 3
08:40:21 <conal> and the meaning of "3 + 4" is the number 7
08:40:41 <conal> where i'm using quotation marks to signify syntax
08:40:46 <mreh> still with you
08:42:46 <wvd> jmcarthur, like?
08:42:53 <conal> so to say that "every semantic value must be denotable" means that every value in the semantic domain (type of meanings) has at least one "expression" that maps to it.
08:43:04 <conal> (expression or whatever is being given meaning to)
08:43:46 <conal> conversely, if there are non-denotable meanings, those meanings are called "junk".
08:44:17 <mreh> conal: do I have to map onto every meaning?
08:44:33 <conal> mreh:  the meanings you don't map onto are "junk".
08:44:47 <conal> mreh: so if you want junk-freeness, then yes.
08:45:05 <Janni> Hello.
08:45:13 <iaefai> Salut
08:45:15 <jmcarthur> wvd: Jafet gave a hint above
08:45:16 <conal> mreh:  a semantics with junk is still a semantics.  but one that might be improved on.
08:45:25 <jmcarthur> wvd: the solution is very short. i could just spoil it for you if you want
08:45:40 <iaefai> Is there anything that can automatically format haskell code? (to produce a form of pretty code)
08:46:13 <aavogt> you can run it through a parser / pretty printer
08:46:15 <mreh> isn't there a pretty printer?
08:46:41 <jmcarthur> something like haskell-src-exts would help
08:46:44 <wvd> jmcarthur, lcm?
08:46:48 <aavogt> iaefai: there's one in haskell-src-exts, but I don't like it's pretty printing
08:46:51 <jmcarthur> wvd: yup
08:47:06 <jmcarthur> wvd: lcm plays a critical role in the solution i am thinking of
08:47:24 <wvd> jmcarthur, how?
08:47:32 <jmcarthur> wvd: do you want me to just spoil it?
08:47:40 <iaefai> I would like something for my editor to indent source code properly
08:47:42 <jmcarthur> you understand what lcm does, right?
08:47:43 <wvd> jmcarthur, i Could make a partial function from 1-20
08:47:49 <wvd> gives the lowest multiplier
08:47:54 <iaefai> But I don't know all the rules that would be followed
08:47:55 <aavogt> in particular, you can't configure the pretty printer to not make so much whitespace on the left side of the page
08:48:20 <aavogt> such that following some keywords, you can put a newline and unindent quite a bit
08:48:24 <jmcarthur> wvd: alright, the solution you are looking for is essentially the lcm of all the numbers from 1-20
08:48:26 <wvd> jmcarthur, ah I'll see. gotta eat now, thanks though.
08:48:40 <conal> are any of the google folks here now?
08:48:40 <jmcarthur> wvd: the lcm function only works on two, so you have to find a way to make it work for more
08:49:14 <aavogt> but I suppose that pretty printing like that requires taking more context into consideration than the current pretty printer does
08:50:18 <iaefai> I take it that itis this: http://code.haskell.org/haskell-src-exts/src/Language/Haskell/Exts/Pretty.hs
08:50:55 <iaefai> I am definitely looking for something much simpler
08:53:58 <Janni> AFAIK there are still no extensible records in Haskell, but I need them. Then again, I'd like to avoid libraries using template Haskell or nasty language extensions. So there is still the possibility of using a naive tuple-of-tuple solution, which I find still reasonably elegant. Although it's simple to implement by myself, isn't there already a small library for that?
08:54:30 <Janni> Hmm. I'm not even completely sure, whether it is really extensible records I'm talking about, so I'll give a small example... (takes a moment)
08:55:51 <Janni> data Pair a b = Pair {cur :: a, prev :: b}       type View pair a = (get :: pair -> a, put :: a -> cont -> cont)
08:56:08 <Janni> s/cont/pair/
08:56:27 <Janni> pack :: a -> b -> (View pair a, View pair b)
08:57:15 <Janni> pack x y = ((cur, \x pair -> pair {cur = x}), (prev, \y pair -> pair {prev = y}))
08:58:13 <Janni> So, suppose you have a function f that operates on type A. f would have a signature like "f :: ... A ...", something with some As in it.
08:58:37 <Janni> But we can generalise f to operate on any values that carry an A.
08:59:16 <Janni> f :: ... View pair a ...
09:00:16 <Janni> I'm not sure whether all this is understandable, but I'd like to know what kind of pattern I am describing.
09:00:43 <zxww> When I ask what the type of a number is ':t 10', this is returned '10 :: (Num t) => t', what does '(Num t) => t' mean?
09:01:00 <Janni> Someone suggested "extensible records" (here, the pack function extends the record by a type) and saw some kind of bidirectionality.
09:01:07 <Janni> But I'm a bit lost...
09:01:15 <koeien37> "10 is of any numeric type"
09:01:47 <zxww> what does t signify?
09:01:50 <Saizan> Janni: look up "lenses", "functional references"
09:01:58 <Janni> Thanks.
09:01:59 <EvanR-work> zxww: 10 can be used anywhere a Num is needed, that is, where you use + and *
09:01:59 <koeien37> zxww: it is a type variable
09:02:14 <zxww> ok thanks
09:04:17 <EvanR-work> is there a lambdabot command to show the inteface for a class
09:04:23 <EvanR-work> :info Num
09:05:15 <hpc> @src Num
09:05:15 <lambdabot> class  (Eq a, Show a) => Num a  where
09:05:15 <lambdabot>     (+), (-), (*)           :: a -> a -> a
09:05:15 <lambdabot>     negate, abs, signum     :: a -> a
09:05:15 <lambdabot>     fromInteger             :: Integer -> a
09:05:22 <EvanR-work> nice
09:05:27 <EvanR-work> @src Bounded
09:05:28 <lambdabot> class  Bounded a  where
09:05:28 <lambdabot>     minBound, maxBound :: a
09:05:35 <EvanR-work> @src Monad
09:05:35 <lambdabot> class  Monad m  where
09:05:35 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
09:05:36 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
09:05:36 <lambdabot>     return      :: a -> m a
09:05:36 <lambdabot>     fail        :: String -> m a
09:05:40 <hpc> i think :b works too (aka :browse in GHCi)
09:05:42 <hpc> :b Num
09:05:55 <hpc> hmm
09:06:56 <EvanR-work> @src Eq
09:06:57 <lambdabot> class  Eq a  where
09:06:57 <lambdabot>     (==), (/=)   :: a -> a -> Bool
09:10:15 * hackagebot bindings-librrd 0.1 - Low level bindings to RRDtool  http://hackage.haskell.org/package/bindings-librrd-0.1 (MasatakeDaimon)
09:16:00 <wvd> jmcarthur, back - so basically I want to use "lcm 1 to 20" + the increasing number and check if the is the same as what I gave as 2nd parameter? (i.e. lcm x n == n)
09:17:16 <zxww> what does '=>' signify?
09:17:36 <hpc> it sets conditions for the type signature
09:17:48 <hpc> so "class (Eq a, Show a) => Num a where"
09:17:57 <aavogt> > 1 <= 2
09:17:58 <lambdabot>   True
09:18:29 <hpc> a is an instance of Eq and Show
09:18:35 <hpc> if it is an instance of Num
09:18:36 <aavogt> > let (=>) = flip (<=) in 2 => 1
09:18:37 <lambdabot>   <no location info>: parse error on input `=>'
09:18:46 <aavogt> so it is reserved...
09:18:47 <zxww> ok thanks
09:19:12 <quicksilver> yes. It doesn't need to be reserved as far as I can see, but it is.
09:19:20 <IceDane> @src permutations
09:19:21 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
09:19:27 <quicksilver> Makes it consistent with -> which does definitely need to be reserved.
09:19:30 <IceDane> @src Data.List.permutations
09:19:30 <lambdabot> Source not found. That's something I cannot allow to happen.
09:19:34 <IceDane> o.o
09:19:53 <aavogt> quicksilver: what's ambiguous if you allow -> as a function name?
09:19:54 <quicksilver> IceDane: @src is a small, manually maintained database for a hand picked list of functions.
09:20:10 <aavogt> @docs Data.List
09:20:11 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
09:20:11 <quicksilver> aavogt: case x of 5 -> blah ?
09:20:13 <IceDane> quicksilver: I see
09:20:37 <quicksilver> if @src could get the source of any old function it would be very spammy...
09:20:56 <aavogt> quicksilver: I don't see it there
09:21:19 <quicksilver> aavogt: well, that's technical not ambiguous but it would break the current grammer
09:21:24 <IceDane> My imperative mind is failing blatantly at coming up with an algorithm for a lexicographic permutation function in haskell
09:21:36 <aavogt> there will be a semicolon after blah, so you wouldn't confuse ->  the operator with -> the syntax
09:21:36 <IceDane> with immutable state and such
09:21:38 <quicksilver> aavogt: which deliberately treats patterns and functions uniformly
09:22:19 <EvanR-work> IceDane: listing permutations sounds very functional
09:22:21 <aavogt> @quote evar
09:22:22 <lambdabot> DRMacIver says: I dread to think what category theory would look like after the software engineering world had got their grubby paws on it. Enterprisevariant functors. Commutative UML diagrams.
09:22:26 <IceDane> EvanR-work: Yeah, I think it is
09:22:34 <IceDane> but it's still, hmm
09:22:36 <aavogt> @quote view
09:22:36 <lambdabot> augustss says: hbc still has some unique features, like views.  that i've never used..
09:22:52 <jmcarthur> wvd: i believe lcm is an associative operation *hint hint*
09:23:03 <EvanR-work> :t perms
09:23:04 <lambdabot> Not in scope: `perms'
09:23:21 <IceDane> EvanR-work: permutations
09:23:25 <IceDane> it's not lexicographic
09:23:27 <jmcarthur> @check \x y z -> lcm (lcm x y) z == lcm x (lcm y z)
09:23:27 <lambdabot>   "OK, passed 500 tests."
09:23:34 <aavogt> IceDane: you can use Control.Monad.ST...
09:23:58 <aavogt> it isn't that painful
09:24:01 <IceDane> aavogt: Yeah, that's what I thought about initially but I still haven't conquered the state monad
09:24:02 <EvanR-work> IceDane: off the top of my head, the algorithm goes... list of x:(perms xs) where x is everything in xs
09:24:17 <wvd> jmcarthur, "Associative operation?"
09:24:17 <EvanR-work> what lexiconographic mean?
09:24:23 <aavogt> that one is different from Control.Monad.State, IceDane
09:24:26 <IceDane> EvanR-work: In order, so to speak, sorter
09:24:36 <EvanR-work> so sort the list of permuatations, two steps
09:24:43 <aavogt> in that you get to make real mutable references
09:25:17 <EvanR-work> :t permutations
09:25:18 <lambdabot> forall a. [a] -> [[a]]
09:25:23 <jmcarthur> wvd: i mean that you can get the lcm of a couple numbers, then get the lcm of the result with another number, then the lcm of that result with yet another number, etc. and it's the same as getting the lcm for all those numbers
09:25:35 <aavogt> but treat the result of that computation as pure, since it only deals with it's own variables
09:25:36 <EvanR-work> > sort . permutations $ "hello world"
09:25:41 <lambdabot>   mueval-core: Time limit exceeded
09:25:41 <lambdabot>  mueval: ExitFailure 1
09:25:45 <EvanR-work> ;)
09:25:47 <jmcarthur> > lcm 1 4
09:25:49 <lambdabot>   4
09:25:52 <jmcarthur> > lcm 5 1
09:25:53 <lambdabot>   5
09:25:59 <jmcarthur> cool, lcm forms a monoid
09:26:04 <fax> > lcm 7 9
09:26:05 <lambdabot>   63
09:26:28 <fax> > lcm (2^3*5^7) (2^2*5^3)
09:26:29 <lambdabot>   625000
09:26:31 <EvanR-work> lcm means least common factor other than 1 ?
09:26:59 <EvanR-work> ah no
09:27:10 <fax> > 5^4
09:27:12 <lambdabot>   625
09:27:13 <wvd> jmcarthur, why would that be effective?
09:27:17 <BMeph> "least common multiple", maybe? ;)
09:27:20 <EvanR-work> right
09:27:29 <fax> > 5^4*5^3*2^31000
09:27:30 <lambdabot>   664745817936459921024712478971908127387986764083022620702776908035921354640...
09:27:35 <philo> how to do strick file reading : !a <- (hGetContents out) ?
09:27:37 <fax> > 5^4*5^3*2^3
09:27:38 <lambdabot>   625000
09:27:45 <jmcarthur> wvd: i could just spoil it
09:27:50 <fax> > lcm 3 3
09:27:51 <lambdabot>   3
09:27:52 <fax> I don't get lcm
09:27:52 <gwern> philo: just use bytestring and save yourself a world of trouble
09:27:55 <fax> what's the point
09:27:59 <wvd> jmcarthur, you better do. I think I don't get lcm
09:28:05 <Saizan> philo: strict bytestrings
09:28:09 <jmcarthur> > foldl1' lcm [1..20]
09:28:10 <lambdabot>   232792560
09:28:14 <wvd> jmcarthur, still new to Haskell and advanced maths (if you call this advanced)
09:28:17 <jmcarthur> wvd: that's the answer
09:28:18 <fax> > product [1..20]
09:28:20 <lambdabot>   2432902008176640000
09:28:27 <fax> it's not factorial
09:28:37 <jmcarthur> fax: and?
09:28:44 <gwern> lcm is useful for reducing fractions isn't it?
09:28:55 <philo> no way to "stricking" hGetContents ?
09:28:56 <fax> I thought we used gcd in fractions
09:29:01 <EvanR-work> gcd is for reducing fractions
09:29:04 <EvanR-work> lcm is for adding fractions
09:29:12 <fax> > gcd (2^3*5^7) (2^2*5^3)
09:29:13 <lambdabot>   500
09:29:16 <fax> > lcm (2^3*5^7) (2^2*5^3)
09:29:17 <wvd> jmcarthur, ah thanks. I think I'm going to skip this one as I don't really know how lcm works, never had it with math and I'd better don't attempt to.
09:29:17 <lambdabot>   625000
09:29:31 <fax> oh the denominator will be 625000
09:29:42 <Saizan> philo: yes, "do str <- hGetContents handle; length str `seq` return str"
09:29:59 <jmcarthur> > sum $ map (1%) [1..20]
09:30:00 <lambdabot>   55835135 % 15519504
09:30:12 <BMeph> x * y = gcd x y * lcm x y
09:30:15 <philo> wow
09:30:19 <philo> readFile is strick ?
09:30:27 <aavogt> philo: with view patterns      a @ (length -> !n) <- hGetContents out
09:30:29 <Saizan> philo: "strict"
09:30:37 <Saizan> philo: but no, it isn't
09:30:50 <jmcarthur> it is strict in Data.ByteString
09:30:53 <aavogt>    !_  should work too
09:31:01 <jmcarthur> but not in Prelude, System.IO, or Data.ByteString.Lazy
09:31:02 <EvanR-work> ! is awesome
09:31:10 <EvanR-work> strict for the win!
09:31:18 <philo> so wich func should i use to strictly read a file ?
09:31:32 <jmcarthur> philo: how about Data.ByteString.readFile?
09:31:35 <EvanR-work> they should make a language where everything is strict
09:31:36 <Schalken> how can i find out where ghc finds a module when i do "import" ?
09:31:41 <jmcarthur> EvanR-work: ...
09:31:51 * BMeph stricks it to the Man!
09:31:57 <hpc> Schalken: -v
09:31:59 <aavogt> Schalken: ghc-pkg find-module ...
09:32:03 <hpc> or that
09:32:04 <EvanR-work> fully strict ;)
09:32:11 <jmcarthur> EvanR-work: you joking?
09:32:11 <philo> jmcarthur: Saizan  said it is not strick
09:32:13 <wvd> Other question, is Data.ByteString usefull for TCP clients, and shouldn't module names be lowercase (ByteString)?
09:32:14 <aavogt> even the function results
09:32:16 <EvanR-work> yes
09:32:20 <jmcarthur> philo: the one in Prelude isn't
09:32:27 <jmcarthur> philo: the one in Data.ByteString is
09:32:36 <aavogt> EvanR-work: if then else must be strict!
09:32:39 <philo> ok that was the one i was talking about
09:32:40 <jmcarthur> philo: it also returns a ByteString instead of a String, btw
09:32:41 <BMeph> EvanR-work: Fully strict, with interactive "Intelligent" input, even! :D
09:32:45 <quicksilver> I think the best way to handle case in package names is to use it for minor API variations.
09:32:46 <jmcarthur> ah
09:33:04 <quicksilver> So if you have 3 or 4 different API ideas, upload them as packages with the same modules, whose names differ only by case.
09:33:40 <jmcarthur> @slap quicksilver
09:33:41 * lambdabot pushes quicksilver from his chair
09:34:07 <Saizan> quicksilver: that's not so far from what ByteString already does, tbh :)
09:34:51 <aavogt> there are modules for ByteString Bytestring, ByTestRing ?
09:34:55 <shapr> What's a good name for a Haskell TCP/IP stack? HackStack?
09:35:10 <shapr> SYN/HASK ?
09:35:10 <jmcarthur> shapr: i like that
09:35:13 <jmcarthur> the first one
09:35:17 <fax> lololol
09:35:21 <quicksilver> shapr: I'd call it GetShapr
09:35:21 <fax> SYN/HASK
09:35:30 <shapr> quicksilver: Er, really?
09:35:39 <quicksilver> (what else would you use haskell TCP/IP for except summoning shapr?)
09:35:40 <philo> any  convenient way to translate bytestring in string ?
09:35:41 <quicksilver> @get-shapr
09:35:41 <lambdabot> shapr!!
09:35:46 <quicksilver> philo: unpack
09:35:46 <shapr> um :-)
09:35:56 <quicksilver> if it is a Char8 bytestring
09:36:03 <quicksilver> but that's just for ASCII encoding, of course
09:36:11 <quicksilver> for real encodings, use a real decoding function
09:36:32 <aavogt> from the utf8-string package
09:36:57 <EvanR-work> !a <- hGetContents foo sounds simpler if you have utf8
09:37:02 <shapr> Is there a good way to fork a darcs repo from a git repo?
09:37:17 <quicksilver> EvanR-work: that won't work.
09:37:23 <aavogt> it isn't strict enough
09:37:29 <EvanR-work> :(
09:37:37 <aavogt> > ('a':undefined) `seq` "ok"
09:37:38 <lambdabot>   "ok"
09:37:58 <jmcarthur> shapr: i've tried things like tailor for that. it was a pain in the butt and also screwed up
09:38:03 <aavogt> so you force the first character to be read
09:38:37 <EvanR-work> i was trying to force an entire list a few days ago, that was a hassle, and i never succeeded because parallel strategies was broken
09:38:56 <aavogt> which version of the parallel library?
09:39:05 <EvanR-work> im not at home right now
09:39:26 <Saizan> it's pretty easy, however
09:39:34 <EvanR-work> i hope so
09:39:48 <shapr> jmcarthur: So it probably makes more sense to keep a copy of the git repo around so others can read the history before the fork.
09:39:54 <philo> quicksilver: unpack give word8...
09:40:09 <Saizan> philo: Data.ByteString.Char8.unpack
09:40:42 <jmcarthur> shapr: at minimum... unless you want to try tailor or try writing something to do it yourself
09:40:42 <quicksilver> the real enemy here is so-called "lazy" IO
09:40:45 <quicksilver> which isn't lazy, it's broken.
09:40:47 <Saizan> damn you, overloading!
09:40:56 <quicksilver> interleaving execution of IO actions with evaluation of pure values.
09:41:05 <lpsmith> Ok,  there was a paper (80-ish) that argued that pure functional languages were inherently less efficient in some circumstances,  requiring an extra factor of O(log n)
09:41:05 <shapr> jmcarthur: I really just want to write code, not poke at the repo.
09:41:10 <shapr> I suspect most people feel that way.
09:41:29 <philo> ok i think !a <- hGetContents foo  is far simpler
09:41:39 <philo> what is the deal with -XBangPattern ?
09:41:45 <Saizan> philo: but that doesn't work!
09:41:49 <EvanR-work> we just covered that
09:41:51 <lpsmith> Then there was a later paper that discovered the argument only applied to *strict* pure languages,   but lazy languages were just as efficient as imperative programming (asymptotically speaking, that is)
09:41:53 <philo> ho ewal ?
09:42:20 <lpsmith> anybody recall what those two papers were?
09:42:23 <EvanR-work> !a <- hGetContents is effective the same as a <- hGetContents for the purposes of avoiding lazy io snafus
09:42:45 <Saizan> lpsmith: the second should be something like "More speed, less haste"
09:43:13 <lpsmith> ok, thanks,  it probably contains a reference to the first in the bibliography too :)
09:43:22 <cypher> is there some place where one can dl all the language shootouts programs with appropriate makefiles to play with?
09:43:36 <Saizan> philo: use this: "hGetContentsStrict foo = do a <- hGetContents foo; length a `seq` return a"
09:43:40 <aavogt> lpsmith: It came up in Osaki's book on data structures, so maybe it's referenced there?
09:44:11 <lpsmith> aavogt, I'll check that out too
09:44:58 <EvanR-work> Saizan: cool trick, does THAT work? :)
09:45:08 <philo> Saizan:  thanks
09:45:14 <lpsmith> thanks guys!
09:46:45 <quicksilver> EvanR-work: actually it is more effective in practice.
09:47:01 <EvanR-work> what do you mean
09:47:03 <quicksilver> EvanR-work: it forces the first char, which will probably force the first "minimum IO buffer"
09:47:10 <quicksilver> EvanR-work: which is probably quite large (at least 8K).
09:47:23 <quicksilver> EvanR-work: so, it will probably appear to work for small tests :)
09:47:38 <shapr> jmcarthur: With TweakLabs meeting once a week on Tuesdays, I don't have much time to organize a Huntsville Haskell meeting...
09:47:55 <EvanR-work> quicksilver: read errors manifest themselves as undefined chars in the list?
09:48:17 <Kaidelong> wxFruit is dead?
09:48:19 <hpc> wouldn't a read error be an exception?
09:48:25 <Kaidelong> should I just use wxhaskell?
09:48:27 <Saizan> quicksilver: now i'm suddenly worried about all the "!a <- hGetContents foo"s on hackage which will break for large inputs..
09:48:31 <EvanR-work> hGetContents
09:48:45 <shapr> jmcarthur: If I don't end up taking a summer internship out of state, would you be up for doing the on-site part of organizing a BAH HUMBUG meeting?
09:48:57 <quicksilver> EvanR-work: according to the docs, read errors manifest themselves just as lists which end early.
09:49:16 <quicksilver> although I don't know if that's actually true, dcoutts seemed to think the docs were lying, at least in the case that the error was a decoding error.
09:49:42 <EvanR-work> :(
09:50:13 <Cale> Long story short - don't hClose a handle which has had hGetContents applied to it
09:50:31 <Saizan> i think they just considered the report couldn't talk about unicode decoding errors, because the report doesn't talk about decoding, so they were free to use exceptions for them
09:50:35 <EvanR-work> for small files, is it ok to just hGetContents, use it, and just not hClose
09:50:39 <Cale> The type system doesn't prevent you from doing it, but in this case that doesn't mean you should ;)
09:51:02 <Cale> It's always okay not to hClose something that has been hGetContents'd
09:51:09 <c_wraith> EvanR-work: you should never hClose if you used hGetContents...  which has its own set of problems.
09:51:11 <EvanR-work> great
09:51:23 <Cale> The handle will be closed when the resulting string is GC'd.
09:51:30 <Cale> Or when you reach the end
09:51:42 <EvanR-work> but read errors? decoding errors?
09:51:59 <Cale> I have no idea what happens if there's an error in decoding.
09:52:06 <c_wraith> I can see easy use cases where the string is not GC'd nor do you reach the end of it.  In those cases, you have a handle leak.
09:52:17 <Cale> Read errors will usually result in truncation.
09:52:56 <Cale> c_wraith: Absolutely, and if you care about that, you should not be using hGetContents at all.
09:53:10 <EvanR-work> what use case
09:53:19 <quicksilver> EvanR-work: basically, you should only use hGetContents if you know there will never be an error
09:53:29 <quicksilver> EvanR-work: (or if you don't care if your program behaves stupidly in the case of an error)
09:53:30 <c_wraith> Anything where you're building up a list of strings that match a predicate, for instance.
09:53:35 <monochrom> for a million files: hGetContents, read just two bytes
09:53:36 <Cale> For example, it is really not advisable to call hGetContents on sockets.
09:53:48 <Cale> Or yes, when you have lots of files
09:54:11 <quicksilver> so it's fine for toy programs/examples but not really suitable for programming in the large
09:54:24 <Cale> It's a really bad idea because you have no control over how many handles you have open, and operating systems have ridiculously stupid limits on how many filehandles you can open.
09:54:41 <EvanR-work> i just want to read a config file
09:54:52 <Cale> If it's just one file, then you're fine :)
09:55:21 <c_wraith> heck.  the current IO manager also limits you to no more than 1024 open handles
09:55:27 <c_wraith> (on linux, I guess)
09:55:28 <EvanR-work> in another case i want to read the file, parse it, then append to it
09:55:29 <Saizan> the only problem is if you're on windows and you might want to delete the file :)
09:55:29 <Cale> It's fine for a lot of non-toy programs.
09:55:44 <Cale> It's just not fine for programs that need to open a lot of files.
09:56:03 <Cale> There are plenty of interesting things you can do without opening so many files ;)
09:56:06 <EvanR-work> what happens if you write to a readwrite handle that had hGetContents called on it
09:56:10 <Saizan> EvanR-work: append is going to be problematic, you've to force the thing
09:56:12 <EvanR-work> i suppose its half closed, so its not possible
09:56:20 <Cale> EvanR-work: Right.
09:56:25 <Cale> You should get an exception.
09:57:01 <quicksilver> Cale: well I don't think it's fine for a program which wants to respond gracefully to an error.
09:57:19 <quicksilver> Cale: admittedly I'm being hyperbolic by saying that any program which doesn't do that is a 'toy'
09:57:24 <quicksilver> but this is #hyperbole, right?
09:57:53 <quicksilver> it's a bit sad to have a default IO API which makes sane error handling impossible. But you know my opinion.
09:58:46 <EvanR-work> is it straightforward to write an IO action that reads the contents of the file and returns it all as a list, such that after executing it you may hClose it?
09:58:57 <EvanR-work> without hGetContents
09:59:16 <EvanR-work> or will *that* be lazy
09:59:29 <Cale> That's easy enough
09:59:34 <EvanR-work> great
09:59:46 <Cale> In fact, the strict ByteString hGetContents already does that.
09:59:58 <Cale> So you can use that, and then just unpack the strict ByteString
10:00:10 <Cale> (or decode it as text, if you need an encoding)
10:01:50 <EvanR-work> i suppose that is easier than looping hGetChar
10:05:48 <EvanR-work> another formatting question, is it common for functions to have no blank lines within their definition?
10:06:37 <aavogt> if your function has logical sections that need to be indicated by blank lines, shouldn't you have separate functions?
10:06:47 <Botje> EvanR-work: generally, yes
10:07:09 <Botje> EvanR-work: because once your functions start to clutter up, you can often extract stuff to top level
10:07:17 <EvanR-work> i have 10 actions in a do block, they are logically separated
10:07:30 <Botje> EvanR-work: that was the counterexample i was about to bring up :)
10:07:41 <pao> hi all, does anyone know when ghc-6.12.2 will be released?
10:08:12 <EvanR-work> if i make separate functions they wont have access to previous variables unless i pass them in, and i usually put type signatures at the top level, could be more hairy than necessary
10:08:27 <Jonno_FTW> why does the compiler return a warning on this in a do block: setCurrentDirectory <$>  getAppUserDataDirectory "uTorrent"
10:08:52 <aavogt> @type setCurrentDirectory
10:08:53 <lambdabot> Not in scope: `setCurrentDirectory'
10:08:59 <aavogt> @type System.Directory.setCurrentDirectory
10:09:01 <lambdabot> FilePath -> IO ()
10:09:14 <aavogt> that's not a type error, Jonno_FTW?
10:09:24 <aavogt> you probably want =<< instead of <$>
10:09:37 <Jonno_FTW>  Warning: A do-notation statement discarded a result of type IO ().
10:09:49 <aavogt> heh
10:10:06 <aavogt> then that annoying warning is actually catching a bug
10:10:13 <Jonno_FTW> i don't really get what =<< does
10:10:38 <aavogt> as-is, your code won't actually set the current directory
10:10:38 <Lemmih> Jonno_FTW: It's like >>=. Just the other way around.
10:10:40 <Jonno_FTW> does it take Filepath out of the IO?
10:11:00 <jmcarthur> @hoogle setCurrentDirectory
10:11:01 <lambdabot> System.Directory setCurrentDirectory :: FilePath -> IO ()
10:11:20 <aavogt> so you are creating an action with type:   IO (IO ())
10:11:50 <aavogt> this is like:
10:12:15 <aavogt>  do dir <- getBlah; return (setCurrentDirectory dir)
10:13:36 <aavogt> anyways, that warning is annoying if you like to write functions   (IO OptionalInformation)
10:14:50 <Jonno_FTW> would it still work if i used: do {dir <- getAppUserDataDirectory "utorrent"; setCurrentDirectory dir}
10:14:52 <Jonno_FTW> ?
10:15:26 <aavogt> yeah, or just replace <$> with =<<
10:15:34 <Jonno_FTW> ok
10:15:50 <Jonno_FTW> just testing this in ghci doesn't seem to work
10:15:53 <Twey> Isn't there some function like ‚Äòintersperse‚Äô that takes a list instead of a single item?
10:16:07 <philo> any way to force print to correctly interpret "\n" ?
10:16:10 <Jonno_FTW> @hoogle intersperse
10:16:11 <lambdabot> Data.ByteString intersperse :: Word8 -> ByteString -> ByteString
10:16:11 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
10:16:11 <lambdabot> Data.ByteString.Char8 intersperse :: Char -> ByteString -> ByteString
10:16:40 <aavogt> > "intercal" `isPrefixOf` "intercalate"
10:16:41 <lambdabot>   True
10:16:57 <philo> any way to force print to correctly interpret "\n" ??
10:17:02 <Twey> Not quite the same
10:17:03 <aavogt> philo: use putStr
10:17:13 <Twey> func "foo" "bar" -> "bfooafoor"
10:17:53 <aavogt> > concatMap (:"foo") "bar"
10:17:54 <lambdabot>   "bfooafoorfoo"
10:17:54 <philo> thanks
10:18:29 <aavogt> (sections involving `:' are great :)
10:19:10 <lispy> > concatMap (:" pizza! ") "hamburger"
10:19:11 <lambdabot>   "h pizza! a pizza! m pizza! b pizza! u pizza! r pizza! g pizza! e pizza! r ...
10:20:04 <aavogt> > (:"foo") =<< "bar"
10:20:05 <lambdabot>   "bfooafoorfoo"
10:20:27 <aavogt> anyways, there's a trailing foo there that's ugly to remove
10:21:03 <aavogt> > drop 3 $ concatMap  (("foo"++) . (:[])) "bar"
10:21:05 <lambdabot>   "bfooafoor"
10:21:58 <Twey> aavogt: Ah, that'd do it.  Thanks ‚ò∫
10:23:20 <Twey> Could've sworn there was something in Data.List or so, though.
10:23:42 <Twey> I suppose I should just concat . intersperse . map return
10:24:02 <Twey> > concat . intersperse "foo" . map return $ "bar"
10:24:03 <lambdabot>   "bfooafoor"
10:24:21 <jmcarthur> :t intersperse
10:24:22 <lambdabot> forall a. a -> [a] -> [a]
10:25:35 <jmcarthur> :t intercalate
10:25:36 <lambdabot> forall a. [a] -> [[a]] -> [a]
10:26:08 <aavogt> that can probably be generalized
10:26:18 <jmcarthur> > intercalate "foo" . map pure $ "bar"
10:26:19 <lambdabot>   "bfooafoor"
10:27:02 <Kaidelong> when the configure step complains about a missing C library, is there any way to find out just which library is missing?
10:27:43 <Jonno_FTW> :t pure
10:27:44 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
10:27:50 <Twey> @let intersperseMany = fmap concat . flip fmap (fmap return) . intersperse
10:27:51 <lambdabot>  Defined.
10:27:57 <Twey> > intersperseMany "foo" "bar"
10:27:58 <lambdabot>   "bfooafoor"
10:28:23 <Twey> jmcarthur: Oooh, that'd do it too
10:30:44 <aavogt> eliding multiple points is confusing sometimes
10:30:56 <aavogt> which fmap is in which Functor instance?
10:31:23 <Twey> aavogt: ‚Äòfmap return‚Äô is in []
10:31:31 <Twey> aavogt: The others are all in (->)
10:31:41 <jmcarthur> yucky
10:32:33 <Twey> ‚Äò(concat .) . flip (.) (map return) . intersperse‚Äô is uglier :√æ
10:33:02 <Twey> Oh, I guess ‚Äò(concat .) . (. map return) . intersperse‚Äô isn't so bad
10:33:09 <xerox> one to go
10:33:10 <jmcarthur> @pl \x -> intercalate x . map pure
10:33:10 <lambdabot> (. map pure) . intercalate
10:33:20 <Twey> I always feel that the point goes where thre three dots are, though, which isn't the case :√æ
10:33:32 <xerox> but it doesn't type
10:33:51 <Twey> :t (. map pure) . intercalate
10:33:52 <lambdabot> forall a. [a] -> [a] -> [a]
10:33:55 <Twey> ?
10:34:23 <Twey> :t (concat .) . (. map return) . intersperse
10:34:24 <lambdabot> forall a. [a] -> [a] -> [a]
10:34:26 <jmcarthur> > ((. map pure) . intercalate) "foo" "bar"
10:34:27 <lambdabot>   "bfooafoor"
10:34:28 <Twey> What doesn't type?
10:34:43 <xerox> > ((concat .) . (. (return .)) . intersperse) "foo" "BAR"
10:34:44 <lambdabot>   "BfooAfooR"
10:34:49 <xerox> ok
10:35:04 <xerox> (i had an error)
10:35:08 <Twey> Ah ‚ò∫
10:35:33 <Twey> I'm getting better at reading and writing more complex point-free forms lately
10:35:36 <Twey> I've been practising
10:35:46 <xerox> > (concat .) . (. (return .)) . intersperse $ "foo" "BAR"
10:35:47 <lambdabot>   Couldn't match expected type `t -> [a]'
10:35:48 <lambdabot>         against inferred type `[GHC...
10:35:49 <xerox> this is what I was doing
10:35:51 <chrisdone> (why?)
10:36:15 <xerox> (same code)
10:36:34 <chrisdone> :t intersperse
10:36:35 <lambdabot> forall a. a -> [a] -> [a]
10:36:54 <chrisdone> :t (concat .) . (. (return .)) . intersperse
10:36:55 <lambdabot> forall a. [a] -> [a] -> [a]
10:36:56 <hpc> @pl fromMaybe
10:36:56 <lambdabot> fromMaybe
10:37:01 <chrisdone> :t ((concat .) . (. (return .)) . intersperse $)
10:37:02 <lambdabot> forall a. [a] -> [a] -> [a]
10:37:05 <hpc> oh, duh
10:37:10 <chrisdone> hpc: hahaha
10:37:23 <chrisdone> fromMaybe = flip maybe id
10:37:24 <xerox> write it with points!!!
10:37:27 <xerox> eheh
10:37:36 <EvanR-work> @hoogle Seq a -> [a]
10:37:36 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
10:37:36 <lambdabot> Prelude repeat :: a -> [a]
10:37:36 <lambdabot> Data.List repeat :: a -> [a]
10:37:48 <jmcarthur> things of the form (. f) tend to be the hardest for me to follow
10:38:12 <aavogt> @type (. ?g) . ?f
10:38:13 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (?g::f a, Functor f, ?f::f1 (a -> b), Functor f1) => f1 (f b)
10:38:16 <Kaidelong> Saw in a mailing list that wxhaskell does not work with wxwidgets 2.8, is this still true?
10:38:29 <Kaidelong> because that would explain a lot of my problems
10:38:39 <jmcarthur> :t (Prelude.. ?g) Prelude.. ?f
10:38:40 <lambdabot> forall b c a a1. (?f::a1 -> b -> c, ?g::a -> b) => a1 -> a -> c
10:39:12 <xerox> ((. g) . f) x y = (. g) (f x) y = (f x . g) y = f x (g y)
10:39:14 <Twey> jmcarthur: I find ‚Äòflip (.) f‚Äô or ‚Äòflip fmap f‚Äô easier
10:39:19 <Twey> Visual thing, I guess
10:39:36 <jmcarthur> i find (. g) easier for precisely the same explanation
10:39:36 <aavogt> isn't that ap?
10:39:43 <Kaidelong> no it isn't still true
10:39:56 <jmcarthur> aavogt: i don't think so
10:40:07 <aavogt> oh right, x /= y
10:40:15 <xerox> aavogt: so..
10:41:18 <xerox> > join ((. (g::Expr->Expr)) . (f::Expr->Expr->Expr)) x :: Expr
10:41:19 <lambdabot>   f x (g x)
10:41:27 <xerox> > ap (f :: Expr->Expr->Expr) (g::Expr->Expr) x
10:41:28 <lambdabot>   f x (g x)
10:41:33 <xerox> but..
10:41:34 <IceDane> is there a built in function like find that will search a sorted list and exit prematurely if, say, the element searched for is smaller than the current element being looked at?
10:41:38 <xerox> ?pl \f g x -> join ((. g) . f) x
10:41:38 <lambdabot> (join .) . flip ((.) . flip (.))
10:41:39 <xerox> :-(
10:41:44 <xerox> it doesn't spot it.
10:41:46 <hpc> :t Expr
10:41:47 <lambdabot> Not in scope: data constructor `Expr'
10:41:54 <EvanR-work> is there a --make clean ;)
10:41:55 <hpc> @src Expr
10:41:56 <lambdabot> Source not found. You speak an infinite deal of nothing
10:42:27 <jmcarthur> :t \f g x -> join ((. g) . f) x
10:42:28 <lambdabot> forall t a a1. (Functor ((->) t), Monad ((->) t)) => (t -> a -> a1) -> (t -> a) -> t -> a1
10:42:35 <jmcarthur> ugh caleskell
10:42:37 <byorgey> IceDane: no, but you can make it yourself by doing a 'takeWhile' before calling 'find'
10:42:43 <jmcarthur> :t \f g x -> join ((Prelude.. g) Prelude.. f) x
10:42:44 <lambdabot> forall b a a1. (a1 -> b -> a) -> (a1 -> b) -> a1 -> a
10:42:48 <IceDane> byorgey: aah
10:42:49 <IceDane> thanks
10:42:52 <xerox> boo ooh
10:42:59 <aavogt> IceDane: how is find wrong?
10:43:16 <jmcarthur> @. pl . djinn type \f g x -> join ((Prelude.. g) Prelude.. f) x
10:43:18 <lambdabot> f = ap
10:43:21 <jmcarthur> :D
10:43:22 <aavogt> > break (=='l') "hello"
10:43:23 <lambdabot>   ("he","llo")
10:43:29 <byorgey> aavogt: find doesn't know that the list is sorted, and will happily keep searching until it gets to the end of the list
10:43:34 <byorgey> even if it has no hope
10:43:38 <IceDane> ^
10:44:04 <aavogt> use Set instead of manually sorted lists?
10:44:22 <byorgey> if it really is a set, sure
10:44:25 <aavogt> or  Map a Int, if you want lots
11:10:26 <flux> does anyone know if an ML-like language for low-end platforms with a few dozen kilos of ram exists?
11:10:42 <fax> ocaml
11:10:53 <aavogt> is haskell ML-like?
11:11:00 <flux> it is, sort of
11:11:05 <aavogt> I mean in your definition
11:11:15 <flux> well, I don't think ocaml's been ported to 8-bit platforms
11:11:59 <aavogt> there is some haskell compiler intended for embedded?
11:12:06 <jmcarthur> nhc?
11:12:07 <tavelram> flux, perhaps timber might be interresting?
11:12:10 <jmcarthur> jhc?
11:12:30 <jmcarthur> nhc is explicitly intended for low footprint, iirc
11:12:40 <flux> tavelram, ah, I'll take a look. actually I had seen the name earlier but didn't make the proper connection :)
11:12:55 <tavelram> hf :)
11:26:14 <fax> > exp (sqrt (-1)) * exp pi :: Complex DOuble
11:26:15 <lambdabot>   Not in scope: type constructor or class `DOuble'
11:26:16 <fax> > exp (sqrt (-1)) * exp pi :: Complex Double
11:26:17 <lambdabot>   12.502969588876512 :+ 19.472221418841606
11:26:26 <fax> > exp (sqrt (-1) * pi) :: Complex DOuble
11:26:27 <lambdabot>   Not in scope: type constructor or class `DOuble'
11:26:57 <jmcarthur> > > exp (sqrt (-1) * pi) :: Complex Double
11:26:58 <lambdabot>   <no location info>: parse error on input `>'
11:27:01 <jmcarthur> > exp (sqrt (-1) * pi) :: Complex Double
11:27:02 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
11:27:08 <jmcarthur> > exp (sqrt (-1) * pi) :: Complex CReal
11:27:09 <lambdabot>   (-1.0) :+ 0.0
11:27:35 <fax> > exp pi -- what's so special about e^pi
11:27:36 <lambdabot>   23.140692632779267
11:28:01 <jmcarthur> > exp (sqrt (-1))
11:28:02 <lambdabot>   NaN
11:28:10 <jmcarthur> > exp (sqrt (-1)) :: Complex Double
11:28:11 <lambdabot>   0.5403023058681398 :+ 0.8414709848078965
11:28:20 * jmcarthur shrugs
11:28:47 <shepheb> > exp (- sqrt (-1) * pi) :: Complex Double
11:28:48 <lambdabot>   (-1.0) :+ (-1.2246467991473532e-16)
11:28:53 <shepheb> haha roundoff error
11:29:02 <jmcarthur> > exp (- sqrt (-1) * pi) :: Complex CReal
11:29:03 <lambdabot>   (-1.0) :+ 0.0
11:29:10 <shepheb> ...
11:29:30 <fax> > (exp pi)^(sqrt(-1))::Complex Double
11:29:31 <lambdabot>   Ambiguous type variable `a' in the constraints:
11:29:31 <lambdabot>    `GHC.Float.Floating a'
11:29:31 <lambdabot>  ...
11:29:32 <jmcarthur> > sqrt 2 ^ 2
11:29:33 <lambdabot>   2.0000000000000004
11:29:36 <fax> > (exp pi)**(sqrt(-1))::Complex Double
11:29:37 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
11:29:37 <jmcarthur> > sqrt 2 ^ 2 :: CReal
11:29:38 <lambdabot>   2.0
11:29:48 <fax> > (exp pi)**(-1)**(1/2)::Complex Double
11:29:49 <lambdabot>   (-1.0000000000000002) :+ (-1.2246467991473535e-16)
11:29:55 <ologNation> Does anyone use happy for parsing?
11:30:34 <edwardk> ologNation: i used to
11:31:05 <ologNation> edwardk, What do you use now?
11:31:11 <edwardk> ologNation: sadly nothing i parse these days is nicely behaved as lalr ;)
11:33:06 <ologNation> You make it sound kind of depressing.
11:33:09 <edwardk> ologNation: i use a fairly horrible homegrown system involving multiple parallel passes that determine where i can start parsers, and i thin parsers that yield token streams that i then extract layout and pairing info using a bitonic sequence monoid, then i run little parsers over the lexemes in those fragments in parallel. -- its a bit of a mess ;)
11:33:43 <EvanR-work> bitonic sequence
11:33:45 <edwardk> er s/thin/run thin/
11:34:34 <edwardk> EvanR-work: i have a monoid that consists of 'unparsed closing contexts', followed by parsed stuff, followed by 'unparsed opening contexts' -- i can merge those 'bitonic sequences' together to obtain a new bitonic sequence.
11:34:59 <EvanR-work> bi-tonic
11:35:08 * ologNation senses a bit of affection in edwardk's description of his homegrown parsers...
11:35:17 <EvanR-work> or bit-onic ;)
11:35:21 <edwardk> bi-tonic
11:35:25 <EvanR-work> hehe
11:35:30 <edwardk> as opposed to monotonic =)
11:35:45 <fax> I am monotonic
11:35:54 <edwardk> ologNation: it has its moments ;)
11:36:04 <EvanR-work> got it now, i was reading bit-onic, sounded medieval ;)
11:36:20 <scree> fax: monotonic increasing or decreasing?
11:36:21 <edwardk> ologNation: it does let me do almost all of my parsing in parallel
11:36:43 <EvanR-work> scree: or remaining constant ;)
11:37:02 <scree> french convention
11:37:08 <ologNation> That's pretty cool.  What are you running it on.
11:37:14 * ologNation is reading the wikipedia article on lalr parsers. 
11:37:17 <scree> "decreasing" is "non-increasing" in your language
11:37:32 <scree> though that gives overlapping alternatives
11:37:35 <EvanR-work> right
11:37:44 <edwardk> ologNation: mostly for fiddling with source code for which it is serious overkill. ;)
11:38:03 <edwardk> ologNation: but it is nice being able to run a c preprocessor in parallel.
11:38:11 <EvanR-work> scree: 'strictly decreasing' doesnt let you have 5 4 3 3 3 3 2 1
11:38:47 <monochrom> I like the french convention. I don't mind overlapping. I think some people are too freaked out about overlapping.
11:39:03 <scree> right, so I wouldn't talk about monotonic (strictly increasing) sequences
11:39:11 <edwardk> it finds all the # directives in parallel by skimming for them at the beginning of a line not preceded by a backslash, then starts little directive parsers on each of those lines, yielding directives and ropes of bytestrings between them, so once that is done, i can extract the defines, and quikly handle includes, etc.
11:39:29 <edwardk> without touching the intervening ropes of text
11:39:49 <scree> i'm not 100% sure it is the french convention, but they do the same thing with "positive" and "negative" so it should be
11:40:31 <siracusa> Hey! Can you make a GtK2Hs GUI look like a typical windows GUI on WinXP?
11:40:45 <dcoutts_> siracusa: yes, that's the default
11:40:48 <EvanR-work> french pah, what do they know about stuff
11:40:49 <edwardk> that lets me go through and apply the macros to the individual source fragments in parallel after i've figured out all the includes
11:41:03 <edwardk> mostly just trying to see how well this can work
11:41:25 <scree> EvanR-work: i don't know.  you'd have to ask them
11:41:27 <siracusa> dcoutts_ : Well, actually it does not :-(
11:41:43 <scree> EvanR-work: but maybe not understand the reply
11:41:55 <dcoutts_> siracusa: you mean some little detail, or the whole thing is using completely the wrong theme?
11:41:58 <EvanR-work> almost certainly not
11:42:25 <edwardk> ologNation: http://comonad.com/reader/2009/iteratees-parsec-and-monoid/ talks a bit about part of my approach
11:42:31 <scree> they may know unimaginable secrets that that can't communicate to the rest of mankind
11:42:43 <siracusa> dcoutts_: The text boxes, the labels, the menues, that all I have for now.
11:42:51 <EvanR-work> its like elvish
11:43:50 <dcoutts_> siracusa: are you using the installer from the gtk2hs site?
11:45:15 <siracusa> dcoutts_: No, it was a minimal package provided somewhere for GHC 6.10.4 IIRC
11:45:33 <dcoutts_> siracusa: oh, that might have been my installer :-)
11:46:30 <dcoutts_> siracusa: was it this one? http://haskell.org/~duncan/gtk2hs/gtk2hs-0.10.1-win32-installer.exe
11:47:13 <siracusa> dcoutts_: Yes, I think so
11:47:30 <dcoutts_> siracusa: hmm, I was pretty sure I set the theme to be the windows native one
11:48:55 <edwardk> ologNation: i'm actually ripping a fair chunk of the aforementioned complexity out and replacing it with a boring parsec parser at the moment ;)
11:49:43 <edwardk> the only piece that is remaining parallel will probably be the preprocessor
11:51:23 <dcoutts_> siracusa: you can check, there's a file in the installation, etc/gtk-2.0/gtkrc
11:51:33 <dcoutts_> siracusa: should be set to gtk-theme-name = "MS-Windows"
11:52:27 <dcoutts_> siracusa: and I'm assuming the installer did not report any problems with DLLs, otherwise you could be picking up the gtk+ dlls from some other app
11:52:59 <siracusa> dcoutts_: It is "MS-Windows"
11:54:07 <dcoutts_> siracusa: as a quick check, does it make any difference if you copy your test .exe to the gtk2hs bin dir and run it from there? I'm wondering if you're accidentally getting the wrong gtk dlls
11:54:21 <EvanR-work> > show 'a'
11:54:21 <lambdabot>   "'a'"
11:54:28 <EvanR-work> > show ['a','b']
11:54:29 <lambdabot>   "\"ab\""
11:54:35 <EvanR-work> > show [['a','b']]
11:54:36 <lambdabot>   "[\"ab\"]"
11:54:50 <EvanR-work> > show [[1,2]]
11:54:51 <lambdabot>   "[[1,2]]"
11:54:59 <EvanR-work> i can show any list?
11:55:10 <fax> Show a => Show [a]
11:55:24 <fax> > show [show]
11:55:25 <lambdabot>   "[{()->\"()\"}]"
11:55:38 <EvanR-work> eh
11:56:06 <siracusa> dcoutts_: Let me try this ...
11:57:43 <edwardk_> EvanR-work: if the contents of the list are showable, then you can show the list
11:57:55 <sepp2k> How can [Char] have its own show function? Doesn't that overlap with Show a => Show [a]?
11:58:05 <edwardk_> @type showList
11:58:06 <lambdabot> forall a. (Show a) => [a] -> String -> String
11:58:08 <mauke> sepp2k: it doesn't
11:58:14 <edwardk_> 'show for [a] calls showList
11:58:19 <mauke> I mean, [Char] doesn't have its own Show instance
11:59:01 <sepp2k> Ah, ok. Thanks.
11:59:02 <edwardk_> @src Show
11:59:02 <lambdabot> class  Show a  where
11:59:02 <lambdabot>     showsPrec :: Int -> a -> ShowS
11:59:02 <lambdabot>     show      :: a   -> String
11:59:02 <lambdabot>     showList  :: [a] -> ShowS
11:59:41 <edwardk_> its a dirty trick, and there is a default body for showList that just wraps it in []'s with ,'s
11:59:47 <EvanR-work> what is ShowS, is it related to ReadS
11:59:51 <edwardk_> but its the only way to make that work in Haskell 98
11:59:58 <edwardk_> ShowS = String -> String
12:00:09 <edwardk_> it is a 'difference list' based string
12:00:24 <EvanR-work> @instance Show
12:00:24 <lambdabot> Maybe you meant: instances instances-importing
12:00:25 <edwardk_> strings suck for appending, because you traverse over and over
12:00:30 <siracusa> dcoutts_: No, it makes no difference
12:00:37 <EvanR-work> @instances Show
12:00:38 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, ST s a, Sum a, [a]
12:00:42 <edwardk_> so show, which basically concatenates a ton of string uses difference lists instead
12:01:00 <dcoutts_> siracusa: can you post a screenshot?
12:01:10 <siracusa> dcoutts_: Maybe it's a missing dll?
12:01:36 <edwardk_> showPrec 3 (Either 12 "Bob") "lalala"
12:01:47 <dcoutts_> siracusa: in the share dir, there should be a couple gtk theme dlls, one is raleigh the other is mswindows or something like that
12:01:50 <edwardk_> > showPrec 3 (Either 12 "Bob") "lalala"
12:01:51 <lambdabot>   Not in scope: `showPrec'Not in scope: data constructor `Either'
12:01:56 <edwardk_> showsPrec 3 (Either 12 "Bob") "lalala"
12:02:04 <dcoutts_> siracusa: or wimp or something
12:02:10 <edwardk_> > showsPrec 3 (Either 12 "Bob") "lalala"
12:02:11 <lambdabot>   Not in scope: data constructor `Either'
12:02:14 <edwardk_> hah
12:02:19 <EvanR-work> Either? Left?
12:02:21 <edwardk_> > showPrec 3 (Right "Bob") "lalala"
12:02:22 <lambdabot>   Not in scope: `showPrec'
12:02:32 <EvanR-work> showsPrec?
12:02:33 <edwardk_> one of these days i'll paste every correction at once ;)
12:02:46 <edwardk_> > showsPrec 3 (Right "Bob") "lalala"
12:02:47 <lambdabot>   "Right \"Bob\"lalala"
12:02:49 <edwardk_> yay
12:03:24 <edwardk_> the difference list takes a list of 'what to put at the end', then ++ is just .
12:03:46 <siracusa> dcoutts_: In share/themes there are 4 folders but no dlls inside them
12:04:31 <dcoutts_> siracusa: oh hmm, perhaps I messed something up, perhaps try the official installer from the gtk2hs site
12:05:10 <siracusa> dcoutts_: Is it for GHC 6.10.4?
12:05:24 <dcoutts_> siracusa: no 6.10.1
12:05:34 <dcoutts_> that's why I made the other installer
12:05:49 <dcoutts_> since I needed to use 6.10.4 for a client project
12:06:11 <siracusa> But the dlls are compatible to 6.10.4?
12:06:24 <dcoutts_> siracusa: yep, they're the same
12:06:32 <siracusa> Okay
12:06:35 <EvanR-work> that being said, i sure wish SqlVal were showable, since hdbc returns [[SqlVal]]
12:07:06 <aavogt> EvanR-work: in your SELECT it can be helpful to ask for formatting
12:07:46 <aavogt> if you write:    "SELECT (a,b,c,d) ...", you can have a bytestring for each row that matches
12:08:13 <EvanR-work> hrm, it says its an instance of Show, and i do remember printing it out in the interpreter, but ...
12:08:25 <aavogt> right, except all the constructors are labeled
12:08:32 <aavogt> it's not intended for pretty printing
12:08:53 <EvanR-work> it was for testing anyway
12:09:27 <EvanR-work> is it common for show to return a string readable by read
12:10:38 <edwardk_> EvanR-work: if you instantiate both show and read then your code should round trip where possible. if you implement one or the other, some people take that as a license to take some liberties in the interest of expedience
12:11:12 <EvanR-work> is it common for show to produce something that does not completely reveal the data
12:11:23 <aavogt> > show (+1)
12:11:24 <lambdabot>   "{-3->-2;-2->-1;-1->0;0->1;1->2;2->3;3->4}"
12:11:47 <aavogt> sometimes you can't reasonably show it
12:12:16 <edwardk_> EvanR-work: if you have functions (or infinite/circular structures) involved some times you can't show everything
12:12:37 <EvanR-work> > read "{-3->-2;-2->-1;-1->0;0->1;1->2;2->3;3->4}" :: a -> a
12:12:38 <lambdabot>   Could not deduce (GHC.Read.Read (a -> a)) from the context ()
12:12:38 <lambdabot>    arising fr...
12:12:48 <EvanR-work> > read "{-3->-2;-2->-1;-1->0;0->1;1->2;2->3;3->4}" :: Int -> Int
12:12:49 <lambdabot>   No instance for (GHC.Read.Read (GHC.Types.Int -> GHC.Types.Int))
12:12:49 <lambdabot>    arising...
12:12:56 <EvanR-work> lame
12:12:57 <EvanR-work> ;)
12:13:20 <aavogt> > \x -> case x of {-3->-2;-2->-1;-1->0;0->1;1->2;2->3;3->4}
12:13:21 <lambdabot>   <no location info>: unterminated `{-'
12:13:41 <pikhq> A read instance is significantly harder than a show instance.
12:13:45 <aavogt> > \x -> case x of { -3->-2;-2->-1;-1->0;0->1;1->2;2->3;3->4}
12:13:46 <lambdabot>   <no location info>: Parse error in pattern
12:13:53 <pikhq> Though you could possibly define one by using GHC. :P
12:13:53 <edwardk_> oddly i'd expect it to be more readily possible to define read :: a -> b much easier than to define show ;) (given of course instances for Read for a and b
12:14:26 <pikhq> edwardk_: That's called "eval". ;)
12:16:21 <edwardk_> pikhq: exactly ;)
12:16:50 <edwardk_> i suppose i'm omitting all the useful functions that should be dragged into scope, etc.
12:17:08 <edwardk_> so its a bit harder ;)
12:17:23 <aavogt> the compiler already has some representation of the function
12:29:44 <siracusa> dcoutts_: I fear in the old installer there are no dlls in share/themes either :-S
12:30:18 <siracusa> dcoutts_: But bin has some more
12:30:57 <dcoutts_> siracusa: oh then that's not the directory then
12:34:14 * hackagebot executable-path 0.0.2 - Finding out the full path of the executable.  http://hackage.haskell.org/package/executable-path-0.0.2 (BalazsKomuves)
12:35:39 <siracusa> dcoutts_: Can I change the layout to see if it takes effect?
12:36:48 <dcoutts_> siracusa: the layout of the directories? no, the ones in the gtk2hs installer are correct.
12:37:25 <dcoutts_> siracusa: I can't remember the exact dir name where the gtk theme dlls live, look about under lib or share
12:37:31 <siracusa> No I meant the GUI layout, change it to "Raleigh" e.g.
12:37:39 <dcoutts_> siracusa: oh yes, you can do that
12:37:48 <dcoutts_> the theme
12:39:18 <siracusa> So simply change the value in etc/gtk-2.0/gtkrc?
12:39:23 <dcoutts_> yep
12:41:23 * hackagebot txt2rtf 1.0.0 - Filter to convert plain text files to RTF  http://hackage.haskell.org/package/txt2rtf-1.0.0 (JohnGoerzen)
12:42:53 <CosmicRay> is there a recommended location to list the location of my git repo for a project in the .cabal file?
12:43:20 <dcoutts_> CosmicRay: yes! the source-repository section, see the cabal user guide for details
12:44:02 <CosmicRay> dcoutts_: ahh sweet.  I even had the right doc page open, just didn't look at the right place
12:44:45 <siracusa> dcoutts_: Still the same theme ... weird :-)
12:46:33 <CosmicRay> dcoutts_: I would like to suggest an improvement to that.
12:47:13 <CosmicRay> dcoutts_: Debian packages have headers like vcs-git and vcs-browser.  vcs-git is the raw git:// url that people can clone from.  vcs-browser is the web repo viewer, if available.
12:48:18 <CosmicRay> dcoutts_: it would be nice to specify a location-browser or something
12:50:55 <aavogt> CosmicRay: you are allowed to specify multiple repos in the cabal file
12:51:05 <CosmicRay> dcoutts_: Where exactly does this source-repository section go?  I'm getting errors for everything after it
12:51:27 <CosmicRay> aavogt: I'm not talking multiple repos; I'm talking multiple ways to access a single repo (via the VCS tool directly, or online viewing via a web front-end)
12:53:07 <CosmicRay> see http://gist.github.com/372972 for the error
12:59:34 * hackagebot txt2rtf 1.0.1 - Filter to convert plain text files to RTF  http://hackage.haskell.org/package/txt2rtf-1.0.1 (JohnGoerzen)
13:01:03 <aavogt> CosmicRay: version is inconsistent: http://github.com/jgoerzen/txt2rtf/blob/master/txt2rtf.hs
13:01:36 <aavogt> there is a Paths_programName you can import which has the version in the cabal file
13:02:40 <CosmicRay> aavogt: heh.  I upload this thing to github a few seconds ago and already a bug report.  thanks ;-)
13:02:45 <CosmicRay> that code was written before that existed
13:03:05 <CosmicRay> http://github.com/jgoerzen/txt2rtf/commits/master and laugh at the 5-year gap ;-)
13:03:26 <CosmicRay> really all that changed is a few lines to .cabal to make it hackage uploadable.
13:03:45 <aavogt> CosmicRay: maybe it sort of misleading, but you can have two source-repository sections that refer to different views of the same repository
13:04:13 <CosmicRay> but there is no way to say "you can clone from this one" and "you can just view this one on the web", right?
13:04:38 <CosmicRay> I mean, if I say type: git, I ought to be giving a URL that a person can clone from
13:05:36 <gwern> believe so.
13:06:04 <CosmicRay> gwern: incidentally thanks for your comments on my blog
13:06:15 <gwern> since I think the intended use was to allow automated operations; a git section should just need a 'git clone git://' ++ field to work
13:06:18 <CosmicRay> gwern: I think I will migrate to github and shut down software.complete.org.
13:06:32 <CosmicRay> my reading was that git:// should be in the field
13:06:36 * hackagebot hamlet 0.0.0 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-0.0.0 (MichaelSnoyman)
13:06:42 <gwern> hm, maybe
13:06:50 <CosmicRay> since it says it wants a URL
13:07:01 <CosmicRay> I still think something like debian's vcs-browser would be useful.
13:07:06 <gwern> vcs-browser?
13:08:47 <CosmicRay> gwern: a debian/control file supports headers for VCS info.  for instance, in one, I have:
13:08:51 <CosmicRay> Vcs-Git: git://git.debian.org/git/pkg-haskell/missingh.git
13:08:51 <CosmicRay> Vcs-Browser: http://git.debian.org/?p=pkg-haskell/missingh.git;a=summary
13:08:57 <CosmicRay> the vcs-git line is what you use with git clone
13:09:10 <CosmicRay> the vcs-browser is a clickable link to take you to a web-based repo viewer
13:09:15 <gwern> interesting. is that very common?
13:09:22 <CosmicRay> in debian? yes, quite.
13:09:40 <gwern> that many people run web browser repos?
13:09:48 <CosmicRay> see the upper left corner at http://packages.qa.debian.org/m/missingh.html
13:09:49 <gwern> not very common in haskell world
13:09:54 <CosmicRay> yes, it is almost universal.
13:10:24 <CosmicRay> is that because darcs' web front end isn't quite as good?
13:10:32 <CosmicRay> git has a particularly excellent one
13:10:42 <CosmicRay> (and perhaps its repo format lends itself to that more readily as well)
13:11:58 <CosmicRay> heck, even Debian runs http://darcs.debian.org with... darcsweb
13:12:10 <mornfall> CosmicRay: Well, that's rather subjective. Gitweb (and a very similar-looking darcsweb) are the exact opposite of excellent... as far as I am concerned.
13:12:14 <CosmicRay> heh
13:12:37 <CosmicRay> there are also github.com, gitorious, sourceforge, google code, trac, redmine, etc...
13:12:43 <CosmicRay> all of which have a web-based repo viewer of some sort.
13:13:14 <CosmicRay> I find it very helpful.  I can just click a link to see recent commits without having to leave the browser.
13:13:21 <CosmicRay> if I need to, I can alsways clone the repo too
13:18:50 <angelicvenus> hi all. Is HaskellDB under active dev these days?
13:21:12 <bluetaslem> Hi, I'm doing a report on Haskell.
13:21:26 <bluetaslem> I need some kind of source to site, excluding the official Haskell site.
13:22:26 <angelicvenus> http://www.haskell.org/haskellwiki/Research_papers might be of use to you
13:22:52 <tensorpudding> The Haskell 98 Report covers the basics of the design of Haskell.
13:23:10 <tensorpudding> @where report
13:23:10 <lambdabot> http://www.haskell.org/onlinereport/
13:25:47 * hackagebot web-routes 0.22.0 - Library for maintaining correctness and composability of URLs within an application.  http://hackage.haskell.org/package/web-routes-0.22.0 (JeremyShaw)
13:28:48 * hackagebot web-routes-th 0.20 - Support for deriving PathInfo using Template Haskell  http://hackage.haskell.org/package/web-routes-th-0.20 (JeremyShaw)
13:30:49 * hackagebot web-routes-regular 0.18 - Library for maintaining correctness of URLs within an application.  http://hackage.haskell.org/package/web-routes-regular-0.18 (JeremyShaw)
13:32:49 * hackagebot web-routes-mtl 0.19 - Extends web-routes with mtl-based MonadIO / MonadTrans RouteT instances  http://hackage.haskell.org/package/web-routes-mtl-0.19 (JeremyShaw)
13:32:51 * hackagebot web-routes-transformers 0.18 - Extends web-routes with some transformers instances for RouteT  http://hackage.haskell.org/package/web-routes-transformers-0.18 (JeremyShaw)
13:32:53 * hackagebot web-routes-hsp 0.19 - Adds XMLGenerator instance for RouteT monad  http://hackage.haskell.org/package/web-routes-hsp-0.19 (JeremyShaw)
13:33:50 * hackagebot web-routes-happstack 0.19 - Adds support for using web-routes with Happstack  http://hackage.haskell.org/package/web-routes-happstack-0.19 (JeremyShaw)
13:34:44 <jmcarthur> that's a lot of web-routes packages
13:34:51 * hackagebot web-routes-wai 0.19 - Library for maintaining correctness of URLs within an application.  http://hackage.haskell.org/package/web-routes-wai-0.19 (JeremyShaw)
13:34:51 <stepcut> :)
13:34:54 <stepcut> all done :)
13:35:02 <jmcarthur> rock
13:35:19 <stepcut> it was either that or have it depends on lots of libraries that you probably don't need
13:35:30 <chrisdone> Twey: what you doin with a selma'o frequency analizer[1]
13:35:30 <chrisdone> [1]: teehee
13:36:22 <chrisdone> stepcut == jeremy shaw?
13:36:24 <stepcut> yeah
13:36:28 <chrisdone> can i call you jez?
13:37:03 <chrisdone> web routes interests me, i'll need seomthing like this soon
13:37:03 <stepcut> for a small fee..
13:37:10 <stepcut> chrisdone: sweet!
13:37:33 <chrisdone> where do i start though *long sigh*
13:37:54 <angelicvenus> stepcut: out of interest, what exactly does your web-routes package provide?
13:37:55 <stepcut> chrisdone: you should start where you already are
13:37:57 <angelicvenus> (and hi)
13:38:45 <chrisdone> downloading so i can build the docs
13:39:04 <stepcut> angelicvenus: hopefully there was be some descriptions, docs, and tutorials soon..
13:39:51 <Cale> http://www.marriedtothesea.com/042010/logo-version-1.gif
13:39:54 <EvanR-work> possible fix: add an instance declaration for (Foo bar), how often do you think a user will actually do this, and how often do you think new users think this is the solution ;)
13:39:54 <stepcut> angelicvenus: but, the basic concept is that in your application you don't deal directly with url strings (aka, "http://www.example.org/foo/bar"), instead you deal with a haskell type that represents your urls
13:40:22 <angelicvenus> interesting, what added data does the URL type contain?
13:40:34 <angelicvenus> (over the string)
13:40:52 <chrisdone> stepcut: that's exactly what i was after
13:41:05 <stepcut> angelicvenus: as a result (1) if you mistype the url, like, showURL Foobra, instead of Foorbar, you get a compile time error, instead of just an invalid link
13:41:13 <chrisdone> i was thinking of using regular to derive urlable instances from data types. does this do it?
13:41:24 <stepcut> chrisdone: yes, web-routes-regular
13:41:27 <chrisdone> indeed, that's important
13:41:29 <chrisdone> cool!!
13:42:05 <stepcut> angelicvenus: or, if you simply change the URL in your app, you get compile time errors if places in your code still try to use the old URL
13:42:18 <angelicvenus> stepcut: I am building a web framework in Haskell for my dissertation; this sounds like it could be a nifty tool
13:42:27 <stepcut> angelicvenus: it also provides composability -- which is important if you are trying to combine serveral 3rd party libraries together
13:43:02 <chrisdone> angelicvenus: what's your web framework made out of?
13:43:20 <stepcut> angelicvenus: for example, if two libraries tried to use the url "/submit", that is going to cause trouble if you use them both in your app, because how do you know with "/submit" a request refers to
13:44:03 <chrisdone> stepcut: one problem with url generate i have is how to handle, generically, things like pagination (for multiple data sets)
13:44:38 <stepcut> angelicvenus: with web-routes, the different submits will be forced into separate subdirectories such as, "/lib1/submit"  and "/lib2/submit".
13:44:44 <angelicvenus> chrisdone: HaskellDB and my own 'GUI' data type (to represent all presentational aspects, CSS, HTML); it's not very complex, more a proof of concept for type safe web applications
13:44:47 <chrisdone> so x library can have a function DataSet -> URL -> URL which adds pagination to the url for a given data set
13:45:29 <chrisdone> angelicvenus: reeto. will you be posting it anywhere that i can keep track of/
13:45:30 <stepcut> angelicvenus: you should use happstack-state instead of HaskellDB ;)
13:46:06 <angelicvenus> stepcut: I am yet to be convinced of the benefits of happstack-state
13:46:38 <angelicvenus> chrisdone: Once my dissertation is done, it will go online with a self-descriptive wiki tutorial
13:46:44 <chrisdone> is happstack-state a type-safe mungodb-like?
13:46:55 <chrisdone> angelicvenus: nice one
13:47:02 <stepcut> chrisdone: I am not really clear that pagnation is a 'generic' problem.
13:47:55 <stepcut> chrisdone: yes. In happstack-state you just use normal Haskell data types, and your 'queries' are normal Haskell functions. Except the queries are magically ACID
13:49:50 <chrisdone> stepcut: well, you have some dataset you get to the database. you need to RESTfully paginate it, so you have a ?page=x parameter in the URL. if you're on ebay, and you hit Next on your bidded on items, the page becomes foo.dll?biddeditems=5&foo=bar. for any given dataset added to your page you need to be able to take the URL of the page and properly update/insert the page number into it. i'd like a standard way to handle that
13:49:55 <stepcut> chrisdone: so you don't have to worry about marshalling your Haskell datatypes into something that can go in a SQL database, etc. You just have Haskell types, and that is it.
13:50:07 <chrisdone> yeah i just read about the ACID monad, nice
13:50:10 * chrisdone wonders if it's written in STM
13:50:19 <chrisdone> yeah, it is
13:50:35 <chrisdone> stepcut: i like that. sql is a hassle
13:50:50 <stepcut> yes, storing trees in sql is no fun
13:50:59 <chrisdone> no fun whatsoever, Timmy
13:51:06 <stepcut> and, half the internet is 'forums' aka, 'trees of posts' ;)
13:51:27 <gwern> (and the other half is porn)
13:51:46 <c_wraith> so...  bittorrent must all be porn then?
13:51:47 <tennin> wait, does happstack-state persist to disk?
13:51:51 <chrisdone> the venn diagram i'm thinking of is kind of intersected
13:51:55 <Saizan> tennin: yes
13:51:55 <angelicvenus> tennin: no
13:52:01 <angelicvenus> I didn't think it did?
13:52:08 <Saizan> it does
13:52:10 <chrisdone> angelicvenus: yeah it does, that's why it's good
13:52:17 <gwern> isn't that where it checkpoints to? where else would it?
13:52:25 <tennin> I love relational databases but I hate all the cruft surrounding them + the SQL language
13:52:47 <stepcut> tennin: by default, yes. There also used to be a S3 backend. There is a memory backend as well.. but that is not very persintant ;)
13:53:29 <tennin> there was a research paper awhile back (2006?) on encoding a relational database into Haskell types
13:53:30 <stepcut> angelicvenus: the working dataset is in-memory, but it persists to disk or other sources.
13:53:33 <tennin> "Coddfish"
13:53:40 <stepcut> tennin: yeah, I read that
13:53:43 <tennin> is happstack-state related to that at all?
13:53:48 <stepcut> nope
13:53:59 <chrisdone> happstack isn't relational, going off what stepcut says
13:54:27 <stepcut> happstack-state is not a relational data store, though you could a relation data type in your happstack-state
13:54:28 <dcoutts_> CosmicRay: you still here?
13:54:30 <chrisdone> it's more like whatever haskell values you want
13:54:44 <CosmicRay> dcoutts_: yessir
13:55:05 <chrisdone> stepcut: i bet it doesn't serialize memoization :p
13:55:19 <stepcut> chrisdone: ?
13:55:20 <nostrand> is there a haskell forum somwhere?
13:55:24 <dcoutts_> CosmicRay: so you're using the old style section syntax, to use the source-repository section you need to use the new style
13:55:34 <gwern> nostrand: we call it the haskell-cafe mailing list
13:55:40 <dcoutts_> CosmicRay: take a look at the examples at the beginning of the user guide
13:55:47 <nostrand> gwern: ok, thanks =)
13:55:53 <chrisdone> stepcut: let x = [1..10^6] in (x,x) -- would have to serialize two lists here
13:56:18 <dcoutts_> CosmicRay: and about the browser url, seems like a good idea, can you file a ticket with that feature request?
13:56:33 <dcoutts_> CosmicRay: http://hackage.haskell.org/trac/hackage/
13:56:43 <CosmicRay> ah ok.
13:56:45 <stepcut> chrisdone: right
13:56:57 <chrisdone> stepcut: 'tis a shame
13:56:58 <CosmicRay> how recent an innovation is this new style?
13:57:03 <CosmicRay> don't want to break compatibility needlessly
13:57:18 <angelicvenus> stepcut: When you say happstack keeps a working dataset in memory, my impression was that it keeps the entire dataset in memory, and that was it's draw back (you run out of memory with a large dataset)
13:57:23 <dcoutts_> CosmicRay: 1.2
13:57:37 <CosmicRay> ah.  that was ahilw back, right?
13:57:57 <dcoutts_> CosmicRay: which apparently you require already. Yes, that was ghc-6.8 I think
13:58:22 <gwern> I saw throw it in anyway. evolve or die!
13:58:28 <stepcut> angelicvenus: yes. It keeps the entire dataset in memory. But, disk is too slow to be a substitute for RAM.. just buy more RAM :)
13:58:56 <lispy> if disk is too slow use APDB
13:58:56 <chrisdone> stepcut: that's kind of a crappy solution
13:58:58 <angelicvenus> Tell Google that
13:59:03 <chrisdone> ram is expensive
13:59:17 <lispy> http://thedailywtf.com/articles/announcing-apdb-the-worlds-fastest-database.aspx
13:59:24 <CosmicRay> dcoutts_: thank you
13:59:48 <Twey> chrisdone: It's for donri's tag cloud
13:59:58 <Twey> chrisdone: http://vlasisku.lojban.org/
14:00:03 <stepcut> chrisdone: not compared to engineering time. People seem to spend a lot of time and money dorking around with memcached to get there data in RAM. You can buy a lot of RAM for what it cost to pay 1 engineer per year
14:00:53 <chrisdone> Twey: hmm that is vastly superior to jbovlaste
14:00:55 <HeMan> Hi! When I try to compile a short haskell program with parsec I get some link problems, http://pastebin.com/y45rDwm3
14:01:10 <stepcut> chrisdone: http://glinden.blogspot.com/2009/11/put-that-database-in-memory.html
14:01:27 <bluetaslem> ...
14:01:32 <bluetaslem> I need help.
14:01:34 <chrisdone> stepcut: but i've never needed that
14:01:39 <dcoutts_> CosmicRay: np
14:01:51 <bluetaslem> I need to find documented research on Haskell that is NOT on the Haskell.org site, or a subdomain or subfolde rof it.
14:01:57 <stepcut> chrisdone: what is the largest database you have had ?
14:02:00 <chrisdone> stepcut: maybe your sites are immensely popular and need something like memcached :p
14:02:03 <Twey> chrisdone: It's just an interface for now
14:02:52 <chrisdone> stepcut: 'bout 100mb i guess
14:03:24 <chrisdone> stepcut: nah you've convinced me. i guess my db's are never even that big to care
14:03:25 <stepcut> chrisdone: so, like $8/month for a VPS ? http://prgmr.com/xen/
14:04:19 <siracusa> dcoutts_: Finally I figured it out, the gtkrc file in the Gtk2Hs installation is completely ignored, but there's a .gtkrc-2.0 file in my home directory that determines the current theme.
14:04:22 <chrisdone> Twey: i can see that. it's a good interface. well done donri
14:04:47 <siracusa> dcoutts_: Anyway, thanks for your help :-)
14:04:50 <dcoutts_> siracusa: ahh, so presumably if you remove that then it'll use the one from the gtk2hs dir
14:05:27 <chrisdone> Twey: (i can tell it's written in ruby. slow :p)
14:05:56 <chrisdone> stepcut: yeah i have gigs of memory with linode. i am converted
14:06:05 * chrisdone collapses into bed
14:07:25 <siracusa> dcoutts_: Indeed, I renamed it an everything works well.
14:07:31 <dcoutts_> siracusa: ok, great
14:08:24 <Twey> chrisdone: Hehe
14:11:43 <fax> I would like to see a graph of the zeros of some irreducible polynomials
14:13:17 <dantheman_> Hey all, I have a question about the IO monad. Would I be right in saying that IO values are NOT themselves referentially transparent, and that the usefulness of monads for IO is that it allows you to 'tag' things as not being referentially transparent?
14:13:39 <fax> dantheman_: I don't think of it that way myself but that seems fine
14:13:58 <Twey> dantheman_: Not really
14:14:42 <Twey> The usefulness of monads for IO is merely that they provide a convenient interface for the ‚Äòdo this, then do that‚Äô sequencing paradigm
14:15:04 <idnar> the IO values are referentially transparent, though
14:15:08 <Twey> You don't have to use monads for IO at all.
14:15:19 <Twey> And yes, the values thus produced are as pure as any other value
14:15:33 <idnar> the "IO" tag just changes the meaning, in that sense
14:15:50 <fax> I think that you can consider IO as a tag which expresses this, that is perfectly consistent
14:15:50 <dantheman_> Ok, so what I wrote was basically completely wrong?
14:15:52 <idnar> String is a sequence of characters, IO String is a recipe for obtaining a sequence of characters
14:15:59 <c_wraith> remember that IO is *not* just a simple tag.  I recently helped someone write a function with a type something like "Process a b -> IO (a -> IO b)"  That really wouldn't make any sense at all if IO wasn't a real, first-class type constructor.
14:16:16 <Twey> dantheman_: It's one way of looking at the abstraction, but it's nothing like what's really happening.
14:16:17 <idnar> for example, getLine :: IO String
14:16:22 <dantheman_> Well yes, I mean the term tag very loosely.
14:16:27 <fax> dantheman_ - re read what I wrote, it's not wrong but it's not how I (or other people) view it
14:16:35 <Twey> No, it's wrong :√æ
14:16:40 <idnar> the recipe doesn't change; however, when the recipe is executed at runtime, the resulting String will not be the same each time it is executed
14:16:54 <idnar> which is why you'll have different String values obtained from sequencing the same IO String action
14:17:00 <Twey> It could potentially be a useful lie, but it's still a lie.
14:17:07 <dcoutts_> dantheman_: so there's a subtle distinction between values that are IO actions, and the fact that actions when executed do impure things
14:17:18 <conal> what does "unregistered" mean, as in "we do have an unregisterised ARM port of GHC in Debian"?
14:17:44 <Twey> dantheman_: ‚ÄòIO String‚Äô does not mean ‚Äòthis function returns a string, and oh by the way it does some IO‚Äô
14:17:56 <mle> conal: there are stages of ghc porting/bootstrapping
14:17:56 <dcoutts_> dantheman_: the point is, it's quite possible to purely construct and compose actions, though the running of those actions of course has side effects
14:18:09 <Twey> dantheman_: ‚ÄòIO String‚Äô means ‚Äòthis function returns a (pure) value that specifies how to do some IO and what to do with the result of it‚Äô
14:18:10 <dcoutts_> conal: it's "registerised" as in CPU register
14:18:12 <EvanR-work> :t hGetChar
14:18:12 <lambdabot> Not in scope: `hGetChar'
14:18:24 <fizruk> is there standard function doing same as (length . filter)?
14:18:34 <EvanR-work> :t getChar
14:18:35 <lambdabot> IO Char
14:18:55 <Twey> fizruk: I don't think so
14:19:00 <dcoutts_> conal: and it refers to whether or not ghc is generating code that uses a bunch of low-level optimisations including assigning STG virtual registers to real CPU registers
14:19:00 <orlandu63> @pl (length . filter)
14:19:01 <lambdabot> length . filter
14:19:01 <conal> dcoutts_: "unregistered" means it doesn't mess with cpu registers?
14:19:07 <dantheman_> Maybe I'm misunderstanding the referential transparency concept.
14:19:28 <EvanR-work> dantheman_: getChar is an IO action (IO Char) which when executed results in a Char
14:19:29 <fizruk> Twey: :(
14:19:40 <conal> dcoutts_: thx.
14:20:15 <Twey> fizruk: What's wrong with ‚Äòfmap length . filter‚Äô?  It's not exactly long :√æ
14:20:23 <fax> fizruk doesn't seem hard to just write  count = length . flter  or whatever
14:20:26 <Twey> > (fmap length . filter) (> 3) [1 .. 5]
14:20:27 <lambdabot>   2
14:20:43 <dcoutts_> conal: the "unregisterised" ports use fairly portable C code and are slow, the registerised ports are faster (2x) and either use a native code gen or speical C code using various GNU extensions and a perl script to post-process the assembly from gcc.
14:21:16 <EvanR-work> dantheman_: putChar is a function which evaluates to an IO action (Char -> IO ()) which when executed results in nothing ;)
14:21:31 <dcoutts_> conal: as far as I know, there's no native code gen for arm yet, and no registerised C backend either
14:22:07 <conal> dcoutts_: so the unregistered port is easier to get working, and is an intermediate step toward a (faster) registered port?
14:22:11 <dcoutts_> conal: for long term support on android and other arm platforms we really want to have a native code gen backend for ghc
14:22:16 <dcoutts_> conal: yes
14:22:25 <dcoutts_> conal: exactly, it's mainly for portability
14:22:34 <dantheman_> I take it to mean that a variable is the same no matter where it is referenced... this would imply to me some way to test for equality. However, if you have an IO action, then it encapsulates the state of the world at some point in time no?
14:22:54 <dantheman_> (By it I mean referential transparency)
14:23:13 <EvanR-work> a value is the same
14:23:14 <orlandu63> @pl (\a b -> b + a ^ 2)
14:23:14 <lambdabot> (+) . (^ 2)
14:23:23 <EvanR-work> variables just have values
14:23:27 <aavogt> how much slower are unregisterized builds?
14:23:50 <dcoutts_> aavogt: about 2x I've heard
14:23:51 <dantheman_> So, is the value of an IO action only defined when you execute it?
14:23:58 <EvanR-work> no
14:24:07 <dantheman_> otherwise it would seem to have different values as the state of the world changes?
14:24:20 <dantheman_> Oh. Ok. aargh.
14:24:25 <dcoutts_> dantheman_: the value of an IO action is it's abstract description, not the result when you e execute it
14:24:26 <EvanR-work> you are confusing the action value and the value that is returned by the IO system when execute
14:25:10 <dantheman_> So what is this 'abstract description'. What does it mean to say it is referentially transparent?
14:25:19 <aavogt> well you can't do much with the IO action other than execute it
14:25:31 <dantheman_> If anything?
14:25:33 <idnar> dantheman_: it's like the difference between the source code for a haskell program, and the output produced when you compile and run the program
14:25:37 <Twey> dantheman_: It means that the description you get from a specific function, given particular arguments, will always be the same.
14:25:47 <EvanR-work> dantheman_: you can reorder them, make a infinite loop of them...
14:26:15 <idnar> an IO action is an opaque description of something the runtime system should perform
14:26:16 <dcoutts_> dantheman_: I could implement IO as a data type, eg data IO a = PutChar Char | GetChar  | ...
14:26:19 <EvanR-work> make new actions from an old action and a list of something
14:26:45 <dcoutts_> dantheman_: and then we have main :: IO (), and the rts "interprets" the IO
14:27:16 <dcoutts_> dantheman_: then you can see that functions that construct IO values are completely pure
14:27:38 <EvanR-work> like this one >>=
14:27:39 <EvanR-work> ;)
14:27:47 <dantheman_> twey... ah ha! So this description is what is referentially transparent. So you can then repeatedly pass it to the runtime system... but what does all this give you?
14:28:03 <Twey> dantheman_: A pure language capable of doing IO.  By proxy.
14:28:34 <Twey> It also has the rather neat side-effect that these IO ‚Äòrecipes‚Äô are pure values, and you can combine them and play with them in different ways before executing them
14:28:44 <dantheman_> dcoutts.. that sounds interesting, but I'm not sure I understand you...
14:29:09 <Twey> s/pure/first-class/
14:30:10 <dantheman_> So I'll take another angle. From what  I've read, the alternatives to monads considered were streams and continuations... what is the advantage of monads over these for IO?
14:30:11 <orlandu63> @hoogle Monoid
14:30:11 <lambdabot> module Data.Monoid
14:30:11 <lambdabot> Data.Monoid class Monoid a
14:31:14 <conal> dcoutts_: thanks!  much clearer now.  (delayed)
14:32:13 <Twey> dantheman_: They support a more direct translation of sequencing, and arbitrary combination
14:32:29 <Twey> Though, in a sense, they still are continuations
14:32:41 <Twey> Or at least contain continuations
14:32:43 <EvanR-work> :t >>=
14:32:44 <lambdabot> parse error on input `>>='
14:32:45 <dantheman_> Twey, is this because of the >>= operator?
14:32:49 <Twey> Yes
14:32:51 <Twey> :t (>>=)
14:32:52 <EvanR-work> :t (>>=)
14:32:52 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
14:32:53 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
14:33:01 <Twey> The second parameter is a continuation
14:33:16 <dantheman_> The b you mean?
14:33:23 <Twey> No, the (a -> m b)
14:33:33 <Twey> You should probably learn more Haskell before tackling weighty topics like these
14:33:57 <dantheman_> Well although it might not seem like it I kind of have!
14:34:00 <EvanR-work> getChar >>= putChar
14:34:36 <Twey> dantheman_: The classic signature of the CPS function is a -> (b -> r) -> r
14:35:01 <Twey> For a function taking an a and producing a b
14:35:07 <dantheman_> Hmmm.
14:35:13 <dantheman_> edit ah right ya
14:35:22 <dantheman_> I was wondering how you got from the a to the b
14:36:04 <dantheman_> Is there a good paper out there comparing the continuation/stream approach to the monadic approach to IO? Tackling the awkward squad?
14:36:05 <EvanR-work> it doesnt actually produce the b though
14:36:07 <EvanR-work> ?
14:36:08 <Twey> The a is passed in by the calling function, and the function uses it to construct a b, which is passed to the continuation
14:36:15 <EvanR-work> it goes to the continuation
14:36:17 <Twey> EvanR-work: It does produce it
14:36:19 <Twey> It doesn't return it
14:36:26 * hackagebot forkable-monad 0.1 - An implementation of forkIO for monad stacks.  http://hackage.haskell.org/package/forkable-monad-0.1 (DavidAnderson)
14:36:27 <Twey> (for the usual value of ‚Äòreturn‚Äô)
14:38:33 <danderson> yay, first hackage upload.
14:38:58 <danderson> So, is the protocol now to announce this on haskell@ as well?
14:39:13 <ivanm> danderson: and -cafe
14:39:20 <ivanm> since the discussions go on -cafe
14:39:57 <danderson> so, to haskell-cafe bcc: haskell, essentially
14:40:31 <tromp_> > showIntAtBase 8 intToDigit  19178274  ""
14:40:32 <lambdabot>   "111121442"
14:40:43 <danderson> ivanm: cheers.
14:40:51 <ivanm> danderson: usual approach is to haskell, cc haskell-cafe
14:41:10 <ivanm> and then people _should_ go and remove haskell@ when replying
14:41:15 <danderson> doesn't that rely on people correctly editing headers when replying to avoid roping in haskell@
14:41:26 <danderson> if it's the convention though, why not
14:41:57 <ivanm> yes, it does
14:42:00 <ivanm> and that usually happens
14:42:19 <danderson> okay, then I will trust -cafe subscribers and do what is usual
14:42:57 <ivanm> to quote The Big Bang Theory, "It _is_ the social convention" :p
14:43:19 <danderson> heh
14:43:41 <danderson> oh, it's a non-optional social convention, well why didn't you say so in the first place!
14:44:45 <stepcut> you could set the Reply-to: header?
14:51:24 <Janni> Hello. Is there some language extension that allows me to test constructors for equalities? I'm refering to _unsatisfied_ constructors!
14:52:16 <dino-> I'm trying to use the UI.HSCurses.Curses.mvAddCh which takes a ChType for the thing to output. This thing is: type ChType = Word32 ..
14:52:28 <dino-> Does anyone know, can I make one of those from a Char or something?
14:53:02 <dino-> Poking around Data.Word and yada, not seeing anything though.
14:53:22 <fax> Janni I don't know how to do it but I am really interested in how you'd use it/what for
14:53:46 <Janni> dino-: Probably first to int by Data.Char.ord, then to Word32...
14:54:48 <ivanm> Janni: use Foo{}
14:54:54 <dino-> Janni: I'll try that, see what the underlying curses thinks of it.
14:55:13 <ivanm> i.e. bothMaybe Nothing Nothing = True; bothMaybe Just{} Just{} = True; bothMaybe _ _ = False
14:55:28 <ivanm> @type let bothMaybe Nothing Nothing = True; bothMaybe Just{} Just{} = True; bothMaybe _ _ = False in bothMaybe
14:55:29 <lambdabot> forall t t1. Maybe t -> Maybe t1 -> Bool
14:55:32 <Janni> fax: Assume we're in the Maybe-Monad. Then I'd like to use "MyConst {field1 = f1, ...} <- request MyConst"
14:56:01 <Janni> ivanm: ... instead of "request $ MyConst {}" which I'm doing at the moment.
14:56:05 <ivanm> oh, wait, "unsatisfied constructors" == haven't applied all values to it?
14:56:11 <Janni> Yes.
14:56:21 <ivanm> well, I have no idea what request is... :p
14:56:43 <Janni> At the moment I'm doing exactly what you suggested, but that requires ugly instancing of Eq of the kind "MyConst {} = MyConst {}"
14:57:00 <Janni> Ehr, "MyConst {} == MyConst {} = True"
14:58:00 <Janni> fax: The request function would return a value, but only if "start with a" constructor that is equal to MyConst.
14:59:28 <dino-> mm. fromIntegral . ord
14:59:29 <fax> okay
14:59:37 <dino-> Seems to work
14:59:38 <fax> why not have myConst instead of MyConst?
14:59:38 <dino-> Thanks!
15:00:19 <EvanR-work> mm not defined
15:00:21 <Janni> fax: Yes, I could also define isMyConst for each of the constructors... Which I find annoying....
15:00:29 <fax> no not isMyConst
15:00:41 <dino-> :D mm. was a hmm-like vocal expression
15:00:58 <Janni> But in case of "myConst = MyConst {}" I'd still be stuck with the "MyConst {} =
15:00:58 <EvanR-work> (:D) not defined
15:01:06 <EvanR-work> sucks you cant use letters in an operator
15:01:08 <gwern> mmm... boilerplate
15:01:10 <Janni> +MyConst {}" Eq instance thing.
15:01:46 <fax> no I was thinking myConst = 354
15:01:49 <fax> or some other random number
15:02:26 <Janni> Hmm. I guess Data.Typeable has been made for that kind of task....
15:13:19 <EvanR-work> is there a function like interact but lets you do more than just print stuff to stdout
15:13:52 <aavogt> Janni: more like Data.Data
15:14:06 <aavogt> EvanR-work: look for FRP
15:14:18 <Janni> Thanks. I'm reading the module description already.
15:14:44 <aavogt> there's no guarantee that typeable and data instances are not strict though
15:15:00 * aavogt ran into some strict ones in HList
15:15:19 <aavogt> but you should be safe if the compiler writes the instances for you
15:15:31 <Saizan> a strict typeOf? that sounds quite broken
15:17:07 <aavogt> well it's fixed now
15:17:56 <aavogt> there could be a language that was more lazy than haskell
15:18:58 <fax> yes
15:19:24 <EvanR-work> super lazy
15:19:24 <Janni> There could be lazier evaluation than (weak) head order reduction
15:19:46 <EvanR-work> full laziness
15:20:33 <aavogt> I mean that patterns could be lazy, but that you would jump to the next case once you tried to look at a failing irrefutable match
15:20:57 <aavogt> but that wouldn't work nicely for     String -> IO ()
15:21:08 <aavogt> since you can't exactly unevaluate IO
15:25:37 <tromp_> > showIntAtBase 8 intToDigit  1153  ""
15:25:38 <lambdabot>   "2201"
15:25:50 <Veinor> :t showIntAtBase
15:25:51 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
15:25:55 <Veinor> why is it called at?
15:26:19 <Cale> Well, it's not the evaluation of the IO that's such a concern, it's the execution which is going on along the way,
15:26:28 <edwardk> hrmm, how reusable is the macid machinery from happstack?
15:26:55 <EvanR-work> Veinor: what preposition is better/ :)
15:27:03 <Veinor> in?
15:27:49 <EvanR-work> prove it!
15:28:48 <Veinor> "in base 2" gets a million google hits
15:29:11 <Veinor> "at base 2" gets half a million, and only a few are math related
15:29:33 <mauke> showAllYourBase
15:29:39 <EvanR-work> @define let showIntInBase = showIntAtBase
15:29:49 <mauke> EvanR-work: that's not how it works
15:29:53 <EvanR-work> i figured
15:30:24 <jmcarthur> edwardk: it's fairly independent of happstack proper
15:31:25 <gwern> 'how do you write 10 in base 2'?
15:31:28 <gwern> 'how do you write 10 at base 2'?
15:31:33 <Veinor> yeah
15:31:37 <aavogt> Cale: how do you mean? Whether the match fails may be due to the result of getLine or somethin
15:31:41 <gwern> which one sounds natural? which one sounds like a demented foreigner?
15:31:47 <edwardk> jmcarthur: haven't really looked at it since happstack split off of happs, digging through it now
15:31:51 <gwern> the answer may surprise you!
15:31:54 <aavogt> gwern: you!
15:32:10 <pkrumins> gwern: bin(perl -wle 'print unpack "B8", pack "c", shift' 113
15:32:11 <jmcarthur> edwardk: i like happstack-state (and happstack in general) quite a bit
15:32:12 <edwardk> jmcarthur: thinking about trying to store a bunch of my internal compiler state (i.e. after 'configure') in macid form in the build dir
15:32:15 <pkrumins> disregard that
15:32:17 <pkrumins> gwern: perl -wle 'print unpack "B8", pack "c", shift' 113
15:32:26 <jmcarthur> edwardk: yeah, that sounds like a cool use for it
15:32:27 <edwardk> jmcarthur: but its just a straw man idea at this point
15:32:43 <jmcarthur> edwardk: but do you really need full ACID for that?
15:32:48 <pkrumins> crap
15:32:49 * gwern thinks pkrumins could use a lesson about the use/mention distinction
15:32:49 <pkrumins> wrong channel
15:32:51 <pkrumins> sorry about that.
15:33:06 <edwardk> much of the compiler runs in parallel
15:33:32 <jmcarthur> edwardk: obviously you should just use all of happstack and make your compiler a web service
15:33:47 * hackagebot ui-command 0.5.0 - A framework for friendly commandline programs  http://hackage.haskell.org/package/ui-command-0.5.0 (ConradParker)
15:33:52 <edwardk> currently i do this by careful staging, etc. but it'd be nice to step a bit back and let stm help out here and there where it obviously doesn't matter.
15:34:09 <timmaxw> what's the difference between "data A = A !Int" and "newtype A = A Int"?
15:34:12 <timmaxw> note the "!"
15:34:18 <edwardk> jmcarthur: =) i want the 'compiler as a service' but to me, that means that i want it around during runtime ;)
15:34:40 <edwardk> hard to muck around with in-process details when you're out on your lonesome on the web
15:34:40 <gwern> timmaxw: well, with newtype the 'A' tag gets erased at runtime
15:34:43 <aavogt> timmaxw: there is a difference
15:34:56 <timmaxw> is there any difference other than runtime performance?
15:35:02 <mauke> yes
15:35:04 <gwern> strictness comes to mind
15:35:15 <aavogt> > case undefined of Endo x -> "ok!"
15:35:16 <timmaxw> doesn't the "!" make "A" strict?
15:35:16 <lambdabot>   "ok!"
15:35:19 <mauke> timmaxw: case undefined of A _ -> ()
15:35:20 <jmcarthur> timmaxw: there's a good wiki page for this somewheer
15:35:21 <edwardk> I like the IxSet stuff in happstack
15:35:25 <jmcarthur> *somewhere
15:35:31 <aavogt> Endo is a newtype
15:35:35 <edwardk> you could do a cool datalog off of that
15:35:41 <aavogt> that will fail if you have a data there
15:35:51 <jmcarthur> edwardk: that would be cool, yes
15:36:22 <jmcarthur> > case undefined of Just x -> "ok?"
15:36:23 <lambdabot>   "*Exception: Prelude.undefined
15:36:32 <edwardk> performance probably suffers though. i presume it does a lot of work through data and typeable
15:36:43 <timmaxw> oh, i see. that's really subtle. i ran across banged fields and i thought "doesn't this make newtype useless?" but i guess i was wrong
15:36:44 <jmcarthur> wait, why did a double quote appear in that output?
15:36:57 <aavogt> > show undefined
15:36:58 <lambdabot>   "*Exception: Prelude.undefined
15:37:15 <aavogt> because show is that lazy
15:37:16 <Kaidelong> has anyone actually gotten wxHaskell working on windows? I've gotten to the point of being able to build wxHaskell applications that segfault at runtime
15:37:30 <jmcarthur> why is it showing it though?
15:37:33 <edwardk> or rather the syb-with-class machinery though
15:37:40 <mauke> > ""
15:37:41 <lambdabot>   ""
15:37:49 * hackagebot ght 0.2.0 - Trivial routines for inspecting git repositories  http://hackage.haskell.org/package/ght-0.2.0 (ConradParker)
15:37:54 <timmaxw> jmcarthur: show prints the quote first, then tries to evaluate its argument, then prints the end quote
15:38:06 <jmcarthur> i get that, but where is the implicit use of show?
15:38:07 <mauke> > undefined :: String
15:38:08 <lambdabot>   "*Exception: Prelude.undefined
15:38:12 <mauke> in lambdabot
15:38:15 <edwardk> string
15:38:35 <jmcarthur> but... it doesn't do this:
15:38:39 <aavogt> > text (undefined :: String)
15:38:40 <lambdabot>   *Exception: Prelude.undefined
15:38:40 <jmcarthur> > show "ok?"
15:38:41 <lambdabot>   "\"ok?\""
15:38:51 <jmcarthur> > "ok"
15:38:52 <lambdabot>   "ok"
15:38:53 <edwardk> the type of the undefined value there is what causes the show, lambdabot calls show on the datatype
15:39:15 <edwardk> > "\"ok?\""
15:39:15 <aavogt> jmcarthur: because the result of your show is being showed again
15:39:16 <lambdabot>   "\"ok?\""
15:39:19 <jmcarthur> > ("ok" :: String, undefined :: String)
15:39:20 <lambdabot>   ("ok","*Exception: Prelude.undefined
15:39:35 <aavogt> > text (show (undefined ::String))
15:39:36 <lambdabot>   *Exception: Prelude.undefined
15:40:18 <edwardk> aavogt: the exception blew up before text finished parsing the string, so nothing was built and returned
15:40:55 <aavogt> > text ("hello there"++undefined)
15:40:56 <lambdabot>   *Exception: Prelude.undefined
15:41:18 <aavogt> hmm, I suppose text has to get the string length for alignment purposes
15:41:52 <jmcarthur> > undefined
15:41:53 <lambdabot>   *Exception: Prelude.undefined
15:42:05 <jmcarthur> or dur i get it
15:42:18 <aavogt> > undefined :: ()
15:42:19 <lambdabot>   *Exception: Prelude.undefined
15:42:27 <jmcarthur> > undefined :: String
15:42:27 <aavogt> > undefined :: (String,())
15:42:28 <lambdabot>   "*Exception: Prelude.undefined
15:42:28 <lambdabot>   *Exception: Prelude.undefined
15:42:44 <jmcarthur> huh, so show for tuples is not that lazy
15:42:59 <aavogt> this is a serious defficiency
15:43:12 <jmcarthur> we must call the president
15:43:19 <mauke> probably because of show (x, y) = ... instead of show ~(x, y) = ...
15:43:57 <Mathnerd314> how hard is it to hack GHC?
15:45:24 <lispy> > fmap show (undefined, 'a')
15:45:24 <lambdabot>   (*Exception: Prelude.undefined
15:46:07 <lispy> > fst $ fmap show (undefined, 'a')
15:46:08 <lambdabot>   *Exception: Prelude.undefined
15:46:15 <lispy> heh, meant snd
15:46:19 <lispy> oh well, I'll stop :)
15:46:33 <gwern> @quote
15:46:33 <lambdabot> kolmodin says: I'd be interesting to compare
15:46:42 <edwardk> Mathnerd314: you can usually figure it out by the time you finish your phd over at cambridge ;)
15:46:44 <gwern> @forget kolmodin I'd be interesting to compare
15:46:44 <lambdabot> Done.
15:46:46 <lispy> What a profound quote
15:46:48 <gwern> @quote
15:46:48 <lambdabot> newsham says: C programmers know the cost of everything and the value of nothing.
15:46:50 <lispy> gwern: thanks
15:46:57 <gwern> @flush
15:48:22 <tensorpudding> @quote
15:48:22 <lambdabot> IsoPallo says: "Error: This program isn't worth compiling"
15:49:04 * Kaidelong thinks he might have found the problem
15:50:47 <edwardk> jmcarthur: if nothing else mining through happstack is a nice syb-with-class tutorial
15:51:21 <jmcarthur> heh
15:52:41 <newsham> lambdabot's always talking behind my back
15:54:44 <Mathnerd314> edwardk: so... pretty hard?
15:56:25 <Mathnerd314> (to hack on GHC)
16:01:48 <edwardk> Mathnerd314: sadly
16:02:02 <edwardk> Mathnerd314: you can find your way around with some effort though
16:02:07 <edwardk> Mathnerd314: what do you want to do?
16:02:26 <Mathnerd314> constraint families
16:02:51 <edwardk> so 'not easy stuff' ;)
16:03:19 <[swift]_> i'm about to write some haskell code that generates haskell code. before i get in too deep, is there a better approach then simply building up a string containing the desired code?
16:03:39 <Mathnerd314> [swift]_: Template Haskell!
16:03:56 <edwardk> swift: template haskell works well
16:04:33 <[swift]_> i may be assuming too much based on C++ experience, but that won't work if what I want is to write the generated code to a file, will it? (the context: i'm writing a parser generator)
16:04:34 <edwardk> swift: you can make expressions that have holes where you need to plug things in using quasiquotation
16:04:56 <hpc> it's haskell's awesome version of #define
16:06:01 <[swift]_> trying to figure out if i can grab template haskell's output as a string now
16:06:12 <edwardk> you can actually mix and match when you call the TH code. using code fragments defined at compile time that evaluate out into TH expressions and data bindings, which you move to runtime to use
16:06:17 <Mathnerd314> [swift]_: pprint will print it out as Haskell source
16:06:35 <edwardk> a good reference, ironically isn't on how to use TH for haskell at all, but instead javascript. look at jmacro
16:06:44 <[swift]_> edwardk: that sounds very convenient!
16:06:49 <edwardk> internally it does a lot of deep magic to make a nice javascript quasiquoter
16:06:54 <[swift]_> Mathnerd314: perfect; i'll try it out then!
16:07:26 <[swift]_> edwardk: thanks for the reference; i'll check that out before reading the TH docs
16:07:32 <IceDane> How do I thread Control.Monad.State using the >>= operator? I'm *just* beginning to grok this stuff, but I'm confused about all the various functions and which ones to use in this case
16:07:41 <edwardk> including translating the javascript expression from compile time quasiquotation with 'hygienic antiquotation' into a runtime datastructure
16:08:43 <edwardk> icedane: >>= for state wires up a function of the form s -> (a,s) -- and a function of the form a -> s -> (b,s)  into a result of the form s -> (b,s) -- by connecting the appropriate s's and a's
16:08:57 <edwardk> IceDane: the rest of it is just noise to make the typechecker happy ;)
16:09:13 <byorgey> IceDane: you mean you're trying to implement State, or just use it?
16:09:21 <edwardk> what are you trying to do with state?
16:09:27 <IceDane> I'm just trying to get my head around it in general, heh
16:09:36 <IceDane> It's this "view it as a computation"
16:09:58 <edwardk> a 'State s a ~ s -> (a,s)' -- plus a newtype wrapper
16:10:23 <IceDane> I just need to stare at it persistently until something snaps and I either go insane and write something in an imperative language or understand it
16:10:32 <edwardk> so a 'state monadic value' is a computation that takes a state, yields a value, and gives you back your new state
16:10:50 <tennin> IceDane: that's pretty much what eventually worked for me
16:10:53 <edwardk> 'return' just chooses to ignore the state
16:10:56 <tensorpudding> @type runState
16:10:57 <lambdabot> forall s a. State s a -> s -> (a, s)
16:11:06 <edwardk> return a = State (\s -> (a,s)) -- just passes s through
16:11:18 <AnAdorableNick> IceDane: I wrote a tutorial on the State monad: http://strabismicgobbledygook.wordpress.com/
16:11:20 <tensorpudding> @type runStateT
16:11:21 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
16:11:25 <edwardk> get = State (\s -> (s,s)) -- takes the state and gives it to you as your 'value of type 'a'
16:11:28 <edwardk> get :: State s s
16:11:35 <AnAdorableNick> IceDane: Will you let me know how well it helps you? :)
16:11:51 <edwardk> put s' = State (\_ -> ((),s')) -- forces the state to a new value.
16:12:09 <tennin> IceDane: and people make fun of them, but I think it does help to read a bunch of the bizillion monad tutorials out there
16:12:42 <edwardk> then m >>= k just returns a new function that wires up the output state of m, and the answer into the computation k, which returns the final answer and final state.
16:12:56 <tennin> IceDane: after you've looked at it from enough slightly different angles, it'll eventually get traction
16:13:04 <tennin> to mix vague metaphors
16:13:24 <tensorpudding> The monad metaphors kinda suck
16:13:26 <edwardk> the state monad is just 'plumbing' to wind around an extra state argument through each function
16:13:42 <IceDane> AnAdorableNick: I will, thanks
16:13:51 <IceDane> tennin: Yeah, it's worked for me on the rest of the stuff that was hard to grok
16:13:58 <AnAdorableNick> np :)
16:14:15 <IceDane> edwardk: Yeah, I know how the >>= works, and it's hard to explain 'what I don't get', but there's just some stuff that isn't going through
16:14:22 <IceDane> It's not computing
16:14:30 <IceDane> It's the kind I just need to look at until I go "ah"
16:14:45 <edwardk> IceDane: what is interesting is that there are 'two ways you can wire up the state'
16:15:15 <edwardk> you can wire up the state from the first computation to the inputs of the function, but you can also rely on laziness and 'miswire' the state backwards
16:15:40 <byorgey> hehe
16:15:46 <IceDane> I understand you're trying to help, but hat makes absolutely no sense to me, heh
16:15:55 <edwardk> hah, np
16:15:56 * byorgey <3 the backwards-chaining time-travel state monad =)
16:16:02 <edwardk> lets look at how >>= works
16:16:22 <byorgey> if only I could find a situation where I actually need it
16:16:48 <IceDane> What i'm just not grokking is, if I have a function defined as: "fn x = State (\s -> (x + 1, s))", and I do soemthing like: runState (fn 3) 1
16:17:01 <IceDane> what is actually happening?
16:17:26 <hpc> byorgey: all you need now is TardisT, which would transform a monad over your timetravelling state monad
16:17:30 <IceDane> It's running my fn on 3, putting it in the 'left' value of the tuple and the other in the right tuple
16:17:38 <edwardk> ok, ignoring your runState call for a second, fn returns a computation that ignores the state and just gives you back your value + 1.
16:17:39 <mauke> IceDane: fn x s = (x + 1, s); fn 3 1
16:18:09 <edwardk> the state gets added as an extra -- ah mauke beat me to it ;)
16:18:26 <tromp_> > showIntAtBase 8 intToDigit  80  ""
16:18:27 <lambdabot>   "120"
16:18:37 <IceDane> That's just it @ "returns a computation"
16:18:47 <edwardk> > let fn x s = (x + 1, s) in fn 3 1
16:18:48 <lambdabot>   (4,1)
16:19:13 <IceDane> The word "computation" is so abstract it has no intrinsic meaning to me
16:19:16 <JuanDaugherty> wait is there a line by mauke in the 20 above this one?
16:19:24 <edwardk> > let fn x = \s -> (x + 1, s) in fn 3 1 -- nothing has changed yet
16:19:25 <lambdabot>   (4,1)
16:19:47 <mauke> IceDane: "computation" means a function of type s -> (a, s), basically
16:19:52 <edwardk> > let fn x = State (\s -> (x + 1, s)) in runState (fn 3) 1
16:19:53 <lambdabot>   (4,1)
16:20:03 <edwardk> all that was changed was the introduction and removal of a newtype wrapper
16:20:35 <edwardk> @src State
16:20:36 <lambdabot> Source not found. My mind is going. I can feel it.
16:20:42 <edwardk> @src Control.Monad.State.Lazy.State
16:20:42 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
16:20:45 <edwardk> bah
16:21:16 <edwardk> state is just a newtype wrapper around a function
16:21:45 <byorgey> IceDane: the word "computation" is not *supposed* to have much intrinsic meaning.  It just means "something which will produce a value (while possibly having some monad-specific effects)".
16:21:47 <edwardk> newtype State s a = State (s -> (a,s)) -- yes it uses record syntax, but that is just extra noise
16:22:00 <IceDane> But \s -> (x + 1, s) is a lambda - can the fn function not be written in a standard form? if not, why not?
16:22:10 <byorgey> in the case of State, a "computation" is something which produces a value, while (possibly) updating the state
16:22:32 <mauke> IceDane: huh? lambda is the standard form
16:22:39 <edwardk> IceDane: i went through two steps there, i took it from the 'standard form' and encapsulated it into a lambda, so that in the next step i could wrap the newtype constructor around it
16:23:12 <edwardk> a 'State' constructor takes one argument, which is a function, that expects one argument and returns two
16:23:22 <edwardk> (as a tuple)
16:23:26 <IceDane> mauke: I mean, I can write, "square x = x * x" as "square = \x -> x * x"
16:23:34 <IceDane> edwardk: Ah
16:24:00 <edwardk> fn = State (\x -> ("Hello", "Nurse")) -- would be a value 'State' monadic value in the State String monad
16:24:04 <byorgey> note that the only thing 'runState' really does is remove the 'State' constructor
16:24:11 <edwardk> runState (State f) = f
16:24:26 <edwardk> so in the above
16:24:40 <edwardk> > let fn x = State (\s -> (x + 1) , s)) in runState (fn 3) 1
16:24:41 <lambdabot>   <no location info>: parse error on input `)'
16:24:54 <edwardk>  > let fn x = State (\s -> (x + 1, s)) in runState (fn 3) 1
16:25:06 <edwardk> > let fn x = State (\s -> (x + 1, s)) in runState (fn 3) 1
16:25:07 <lambdabot>   (4,1)
16:25:11 <edwardk> i can rewrite that
16:25:29 <edwardk> > runState (State (\s -> (x + 1, s)) 1
16:25:29 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
16:25:38 <edwardk> > runState (State (\s -> (x + 1, s))) 1
16:25:39 <lambdabot>   (x + 1,1)
16:25:43 <edwardk> hah
16:25:46 <IceDane> Ah
16:25:46 <byorgey> hehehe
16:25:47 <IceDane> Hmm
16:25:57 <edwardk> > runState (State (\s -> (3 + 1, s))) 1
16:25:58 <lambdabot>   (4,1)
16:26:11 <edwardk> > (\s -> (x + 1, s)) 1
16:26:12 <lambdabot>   (x + 1,1)
16:26:26 <edwardk> > (\s -> (3 + 1, s)) 1
16:26:26 <lambdabot>   (4,1)
16:26:30 <IceDane> So the result above, (x + 1, 1) is of the type (\x -> x + 1, Int) ?
16:26:40 <edwardk> the (x + 1) was a typo ;)
16:26:43 <IceDane> Oh
16:27:06 <edwardk> which only worked because of some lambdabot magic
16:27:10 <Saizan> (\x -> x + 1, Int) isn't a type
16:27:11 <IceDane> Ah
16:27:20 <edwardk> > a + b
16:27:20 <lambdabot>   a + b
16:27:28 <mauke> > (a + b)^2
16:27:29 <lambdabot>   (a + b) * (a + b)
16:27:39 <edwardk> > (a + b)^1000
16:27:40 <lambdabot>   (a + b) * (a + b) * ((a + b) * (a + b)) * ((a + b) * (a + b) * ((a + b) * (...
16:27:44 <Saizan> @type a + b -- anyhow
16:27:45 <lambdabot> Expr
16:27:54 <IceDane> I see.
16:27:56 <edwardk> so
16:28:18 <edwardk> to my point, you can mechanically add and remove the newtype wrapper for State to see the action of runState (fn 3) =)
16:28:24 <IceDane> so runState literally takes comptuation returned by (fn 3) and applies it to 1?
16:28:28 <edwardk> yeah
16:28:38 <edwardk> runState just strips off the 'State' tag
16:28:40 <mauke> > \x -> [x,y]
16:28:41 <lambdabot>   No instance for (Test.SmallCheck.Serial SimpleReflect.Expr)
16:28:41 <lambdabot>    arising from...
16:29:12 <edwardk> the tag exists solely so the compiler can spot that it is a 'state monad' and that do should do something special with it, and you should be able to define isntances for it, and not just some other boring old function
16:29:49 <edwardk> its just probably the first data type you saw that carried around a function
16:29:52 <dantheman_> Hey all. Say I have a list of functions that do different things, but are all of type (a -> b), and I want to apply each function to the element at the corresponding position in a list of type [a]... what's the best way to do this?
16:30:08 <IceDane> edwardk: I think that's precisely it
16:30:16 <Saizan> dantheman_: zipWith ($)
16:30:17 <dantheman_> It's kind of like a zip, except the function gets applied to the corresponding element, instead of forming a tuple
16:30:25 <edwardk> > zipWith id [(+1),(+2)] [1,2,3]
16:30:25 <lambdabot>   [2,4]
16:30:40 <IceDane> What I needed, I think, was exactly what you did - breaking it down, thanks. I think may just need to play around with it for a while, do some practical exercises, and it'll come to me
16:30:49 <dantheman_> Thanks!
16:31:13 <edwardk> dantheman_: you can of course zipWith ($) if it makes you feel better about the types but ($) is just a special case of id =)
16:31:25 <edwardk> @type zipWith id
16:31:26 <lambdabot> forall b c. [b -> c] -> [b] -> [c]
16:31:47 <mauke> > zipWith f [a,b] [x,y]
16:31:48 <lambdabot>   Ambiguous type variable `c' in the constraints:
16:31:48 <lambdabot>    `GHC.Show.Show c'
16:31:48 <lambdabot>      a...
16:31:54 <mauke> > zipWith f [a,b] [x,y] :: [Expr]
16:31:54 <Saizan> and, btw, zipWith f xs ys = map f $ zip xs ys
16:31:55 <lambdabot>   [f a x,f b y]
16:31:59 <c_wraith> IceDane: the key thing to remember, when I finally figured it out, is that the type State Foo Bar actually encapsulates a function, even though it kind of acts like a value of type Bar.  In some ways.  :)
16:32:05 <mauke> Saizan: needs more uncurry
16:32:08 <edwardk> map (uncurry f)
16:34:12 <dantheman_> Hmm, zipWith takes (a->b->c) as its first argument, but id is of type (a->a) no?
16:34:59 <mauke> dantheman_: same thing
16:35:04 <edwardk> yes, so a = b -> c
16:35:15 <pastorn> is there any way to show a an expression during runtime (the actual definition)
16:35:20 <mauke> (b -> c) -> b -> c
16:35:28 <pastorn> i was thinking if it's possible to implement 'assert' in some way
16:35:38 <dantheman_> ahhhh.. right. thanks.
16:35:41 <pastorn> so that when it fails it'll show the actual expression that failed
16:35:57 <c_wraith> dantheman_: it's more common to see zipWith ($) than zipWith id, but they're equivalent
16:36:39 <tromp_> > showIntAtBase 8 intToDigit  -432  ""
16:36:40 <lambdabot>   No instance for (GHC.Num.Num
16:36:40 <lambdabot>                     (t -> GHC.Base.String -> G...
16:36:48 <tromp_> > showIntAtBase 8 intToDigit  (-432)  ""
16:36:49 <lambdabot>   "*Exception: Numeric.showIntAtBase: applied to negative number -432
16:37:03 <tromp_> > showIntAtBase 8 intToDigit  (65536-432)  ""
16:37:04 <lambdabot>   "177120"
16:37:20 <darkscythe> hey! Do haskell programs remember the output of a function with certain inputs so that if it's called repeatedly it does not actually compute the function again?
16:37:27 <mauke> darkscythe: no
16:37:33 <stepcut> darkscythe: no
16:38:03 <Saizan> darkscythe: there are libraries for that, but you've to ask for it explicitly
16:38:08 <darkscythe> oh ok
16:38:24 <c_wraith> I'm just as happy ghc doesn't auto-memoize my functions that produce gigabytes of output
16:39:02 <darkscythe> well how about functions in guards, like:
16:39:03 <darkscythe>   | divi x 20 = x
16:39:03 <darkscythe>   | divi x 20 == False = find (x + 1)
16:39:03 <darkscythe>   | otherwise = 0
16:39:10 <darkscythe> it's calls divi twice?
16:39:27 <darkscythe> it*
16:39:36 <Saizan> those guards don't make much sense
16:40:03 <stepcut> darkscythe: it might do common subexpression elimination (CSE), http://en.wikipedia.org/wiki/Common_subexpression_elimination
16:40:10 <Saizan> IOW it's the same as writing | divi x 20 = x | otherwise = find (x + 1)
16:40:34 <stepcut> Saizan: true, it will probably just eliminate that case entirely
16:40:39 <darkscythe> oh you're right saizen
16:41:43 <stepcut> in the case of
16:41:44 <stepcut> foo n
16:41:44 <stepcut>         | n `mod` 5 == 0 && n `mod` 3 == 0 -> ..
16:41:44 <stepcut>         | n `mod` 5 == 0  -> ..
16:41:44 <stepcut>         | n `mod` 3 == 0  -> ..
16:42:06 <stepcut> I have seen the compiler rewrite it so that each mod will be done at most once.
16:42:35 <darkscythe> Alright, thanks!
16:42:50 <stepcut> also, if you write, bar (f x) (f x), it will sometimes rewrite that to, let a = f x in bar a a, so that 'f x' is only evaluated once
16:43:05 <stepcut> but CSE and auto-memoization are not the same
16:43:34 <tromp_> > showIntAtBase 8 intToDigit  80  ""
16:43:35 <lambdabot>   "120"
16:45:04 <stepcut> the rewritting is fun, because most people assume that it is better to make the first case, n `mod` 15, but it turns out that you will be doing more 'mod' calculations that way, not less
16:45:20 <IceDane> edwardk: If have a function "initState x = State (\s -> (x, s))" that just puts a value into a state(Is there standard one for this?), and then I wanted to thread this initial state through to another function using the >>= operator a few times, what would that look like? For the sake of example, making it just decrement the first value and increment the second should be simple enough for me to understand, heh
16:45:45 <edwardk> 'return'
16:45:55 <edwardk> but note that doesn't put a state in, that puts a value in
16:46:00 <edwardk> 'put' puts a state in
16:46:15 <edwardk> put s = State (\_ -> ((), s))
16:47:00 <edwardk> incrState = State (\s -> ((), s + 1)) -- might be one way to write a function that adds one to its state
16:47:04 <edwardk> another way to write it would be
16:47:14 * RayNbow smiles at sjoerd_visscher's latest Tweet...
16:47:17 <edwardk> incrState = do x <- get; put (x + 1)
16:47:22 <edwardk> or equivalently
16:47:39 <edwardk> incrState = get >>= \s -> put (s + 1)
16:48:12 <edwardk> when the 'bind' gets done with it and the compiler gets done inlining the result will look a lot like the incrState i hand crafted first above.
16:49:31 <IceDane> edwardk: I see
16:50:40 <edwardk> using those definitions you can start to play with: foo = do put 12; incrState; incrState --
16:51:10 <edwardk> and expect that the result of runState foo undefined -- to be 14.
16:51:26 <edwardk> -- i passed it undefined to show that the state wasn't used until after i changed it using put
16:51:37 <edwardk> er to be ((), 14)
16:51:40 <RayNbow> @check \s -> runState (get >>= \s -> put (s+1)) s == runState (modify (+1)) s
16:51:41 <lambdabot>   "OK, passed 500 tests."
16:51:42 <IceDane> hmm
16:51:47 <IceDane> I'll play around :P
16:51:48 <IceDane> thanks
16:53:57 <edwardk> hrmm it looks like the only part of the IxSet machinery that cares about HappStack at all is the noise about supporting Serialize
16:54:26 <edwardk> seems like kind of a heavy dependency for one class that is only tangentially useful
16:56:41 <pastorn> @type callCC
16:56:42 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
16:58:14 <pastorn> @type runCont
16:58:15 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
16:58:58 <Saizan> edwardk: more tangentially than IxSet itself?
16:59:17 <edwardk> Saizan: hah, well, i wanted ixset, but didn't need happstack ;)
16:59:53 <pastorn> @type runContT
16:59:54 <lambdabot> forall r (m :: * -> *) a. ContT r m a -> (a -> m r) -> m r
17:00:06 <monochrom> callCC v.fun
17:00:10 <darkscythe> Wow, I just randomly hit numbers into an app that checks if a number is prime or not and the first time I tried it the number turned out prime. Turns out 6878686 is a prime guys. What're those crazy chances?
17:00:24 <edwardk> Saizan: i'd reinvented it or rather just built something very similar a couple of years back as part of a random olap-in-haskell project, but they had a better idea ;)
17:00:24 <hpc> lol
17:00:34 <edwardk> darkscythe: zero ;)
17:00:36 <c_wraith> darkscythe: wow.  nearly 0%, in my estimation!
17:01:02 <twink> 2 * 3439343 ?
17:01:22 <darkscythe> oh wait no, it wasn't that number
17:01:26 <darkscythe> it was  687868667
17:01:31 <EvanR> haha
17:01:33 <darkscythe> which is even crazier
17:01:37 <monochrom> I be damned. GHCi 6.10.4 understands "import Data.Set" at the prompt.
17:01:59 <c_wraith> yeah, at least all of 6.10 supports that
17:01:59 <darkscythe> Now if only I could fix those odds on the lottery
17:02:12 <c_wraith> but it's just syntactic sugar for :m +
17:02:25 <c_wraith> It doesn't let you do qualified or explicit imports
17:02:25 <EvanR> ive been importing A.B.C for a while now
17:03:16 <gwern> c_wraith: the qualified import bug is still outstanding if you want to cc yourself to it...
17:07:38 <edwardk> hrmm are class associated types supported by TH? i forgot
17:09:08 <Saizan> i think they aren't supported at all
17:09:24 <edwardk> =/ thats what i was afraid of, ok
17:19:18 <byorgey> edwardk: I think template-haskell-2.4 supports them
17:19:55 <byorgey> maybe it depends what you're trying to do with them but it's worked for me
17:20:34 <byorgey> I've use TH to generate class instances with associated types
17:23:54 <edwardk> byorgey: 6.12.x?
17:24:02 <byorgey> yep
17:24:04 <Saizan> oh, true, there's the whole FamilyD etc.
17:24:37 <edwardk> k. i can live with a type family for my current purposes, but i'll remember that
17:24:45 <edwardk> er s/type family/fundep/
17:25:06 <edwardk> just lobotomizing IxSet at the moment
17:25:20 <edwardk> was looking at replacing 'Indexable' with a class associated type
17:25:52 <edwardk> it is sort of the poster child for class associated types, a simple fundep, one arg, one result, etc.
17:25:59 <edwardk> and rarely used
17:26:28 * hackagebot lrucache 0.3 - a simple, pure LRU cache  http://hackage.haskell.org/package/lrucache-0.3 (CarlHowells)
17:27:34 <Saizan> one could get rid of Typeable/Data and the untypedness with a 2-parameter typeclass
17:28:15 <Saizan> (or any other way of storing the projections)
17:30:07 <edwardk> yeah
17:30:52 <edwardk> hrmm, use fclabels-like lenses?
17:31:21 <edwardk> the problem there is that it becomes hard to match up indices
17:31:33 <edwardk> i need to be able to do 'joins' which was my reason for selecting this abstraction
17:31:42 <wavewave> how can we make haskell program have some plugin option?
17:31:48 <edwardk> and i can't join if i don't agree on the index type, so that can become tricky fast
17:31:52 <edwardk> wavewave: hsplugins
17:32:23 <wavewave> edwardk: oh thanks.
17:33:58 <wavewave> edwardk: can hsplugins also be used for plugin in other language?
17:34:16 <edwardk> wavewave: nah, its basically a wrapper around compiling and linking in haskell code
17:34:28 <edwardk> wavewave: for anything more exotic you have to go farther afield ;)
17:35:34 <wavewave> edwardk: I want to make a kind of partial evaluator.
17:36:04 <wavewave> edwardk: especially polynomial.
17:36:13 <edwardk> wavewave: what do you want to partially evaluate? at compile time? runtime?
17:36:45 <kmc> wavewave, hsplugins is obsolete i think, look at hint
17:36:47 <kmc> or the GHC API directly
17:37:06 <wavewave> edwardk: in fact, for such multi-phase program, compile or runtime is rather obscure..
17:37:29 <wavewave> kmc: is hint a library name?
17:37:29 <edwardk> the hs-plugins approach would be to generate a small haskell module that has a function in it with the right signature. lennart would probably steer you towards using the llvm bindings directly, which might not be a bad idea if your problem has a simple structure
17:37:31 <kmc> wavewave, look at "dyre" for automatic reconfiguration through recompilation
17:37:33 <kmc> wavewave, yes
17:37:37 <edwardk> hint is 'haskell interpreter'
17:37:55 <edwardk> dyre -- i was googling trying to find that one =)
17:39:49 <wavewave> is hint the same as GHC API basically?
17:40:00 <kmc> wavewave, hint is a very much simplified wrapper on GHC API
17:40:01 * syntaxglitch falls off the wagon and starts answering Haskell questions on stack overflow again
17:40:17 <edwardk> syntaxglitch: hahaha, welcome to the club
17:40:21 <kmc> wavewave, you can use the llvm library to generate portable assembly-like code then link and call it
17:41:08 <kmc> i thought there was also some wrapper to the C libdl
17:41:09 <edwardk> wavewave for an example of that http://augustss.blogspot.com/
17:41:14 <kmc> but you can do that directly with FFI at any rate
17:41:17 <syntaxglitch> edwardk, I was at the top of the "last 30 days top answerers" for a couple weeks, that felt almost like "winning"
17:41:23 <syntaxglitch> Thought I'd kicked the habit
17:41:30 <syntaxglitch> But it didn't last...
17:41:41 <wavewave> kmc: thanks. anyway I will deal with foreign function interface.
17:41:50 <edwardk> syntaxglitch: ouch i'm not that hardcore about stack overflow, but it does wax and wane
17:42:22 <syntaxglitch> edwardk, you're still beating me on the "all time" list
17:42:31 <syntaxglitch> ...by, uh, one point
17:42:32 <syntaxglitch> crap
17:42:37 <edwardk> muhahahah
17:43:03 <wavewave> edwardk: the blog looks quite interesting, thanks :)
17:44:29 <edwardk> "Steve K"?
17:44:52 <ivanm> great, I need to upload something to my code.haskell.org account space... but I can't remember the password (since at home I use an RSA key to unlock it) :s
17:45:04 <byorgey> hehe, doh
17:45:09 <byorgey> I've done that before
17:46:18 <ivanm> whilst I can walk home, turn my laptop on, ssh in and then change the password, I don't particularly want to do that, since I'm meant to be reading papers, etc. atm
17:46:39 <syntaxglitch> ivanm, ssh into your home box, then ssh from there
17:46:44 <syntaxglitch> it's what I've done
17:46:44 <ivanm> syntaxglitch: it isn't on...
17:46:47 <syntaxglitch> :(
17:46:54 * ivanm wonders if he has any uni webspace he can upload this to just so that students can access it this afternoon...
17:47:16 <syntaxglitch> I also idle on IRC so that when my dyndns isn't working I can connect, /whois myself to find the IP address, and ssh to that
17:47:20 <byorgey> ivanm: if you email it to me, I can put it on my code.haskell.org space so people can download it
17:47:42 <ezyang> syntaxglitch: Classy :-)
17:47:51 <ivanm> byorgey: heh, it's not that big a deal; I can get students to google it for themselves
17:47:57 <byorgey> ivanm: ok =)
17:47:59 <ivanm> I just wanted a link I knew that I could write up
17:48:03 <ivanm> but thanks anyway
17:48:06 <byorgey> oh, I see
17:48:11 <syntaxglitch> ezyang, yeah, it's not a very good system but it works!
17:48:58 <ivanm> and I know I can ssh in to my uni machine... I wonder if it's possible to just make a directory available on the local network...
17:50:07 * syntaxglitch stops wasting time on Stack Overflow for now and goes back to wasting time doing overcomplicated type-level metaprogramming
17:50:30 <HugoDaniel> :)
17:50:46 <hpc> it is a miracle that i don't have a stack overflow account
17:51:29 <HugoDaniel> whats the thing with stack overflow ?
17:51:36 <syntaxglitch> I keep tinkering with stuff and wanting a bit of type programming here or there, and it's so ugly to always reimplement it
17:51:49 <syntaxglitch> so I'm writing myself a type programming library that I can just install and use
17:52:17 <hpc> HugoDaniel: it is a timesink, similar to tvtropes but productive
17:52:18 <edwardk> hrmm, is anyone actually using dyre?
17:52:29 <HugoDaniel> edwardk: i am
17:52:38 <HugoDaniel> nice app :)
17:52:39 <edwardk> HugoDaniel: what are you thoughts of the experience so far?
17:52:45 <HugoDaniel> it works
17:52:49 <edwardk> caveats?
17:53:03 <HugoDaniel> i cant think very well right now
17:53:07 <HugoDaniel> are you planing on using it ?
17:53:12 <edwardk> i'm trying to see if i could shoehorn it into my current design
17:53:17 <HugoDaniel> hmm
17:53:22 <edwardk> and avoid needing to define a big application-specific config file
17:53:43 <HugoDaniel> i started using it after reading the xmonad code and thinking to myself "hey, i want this!"
17:54:03 <syntaxglitch> HugoDaniel, the stack overflow thing is this: http://stackoverflow.com/questions/tagged?tagnames=haskell
17:54:20 <edwardk> *nods*. i have a small cabal-like api based compiler, thinking it might be a nice way to allow 'user hooks' to add new commands to the compiler
17:54:53 <syntaxglitch> HugoDaniel, and basically "answer questions for high score"
17:55:23 <HugoDaniel> hmm
17:55:37 <syntaxglitch> or ask questions, I suppose, but I've actually never bothered, heh
18:05:20 <cads> where can I find out about the constants and functions that are available in a cabal file?
18:05:42 <cads> I'd like to write   if os(WinXP) .....
18:06:57 <byorgey> cads: see http://www.haskell.org/cabal/release/cabal-latest/doc/users-guide/authors.html#configurations
18:06:59 <cads> I should ask, where in the cabal docs
18:07:05 <byorgey> scroll down to "Conditions"
18:08:12 <cads> oh nice
18:08:21 <cads> thanks byorgey
18:10:37 <ivanm> cads: is os(WinXP) then error "Upgrade" ?
18:10:39 <ivanm> :p
18:11:03 <cads> hehe
18:12:04 <cads> it seems like if(windows) does the trick :)
18:12:37 <cads> I forget everyone's moved on to windows seven and ubuntu, here I am with windows xp and plain old debian
18:13:08 * syntaxglitch and his macbook feel left out 
18:13:25 <cads> die hipster.
18:13:32 <danderson> cads: wow, that is so 20th century!
18:13:33 <cads> j/k :)
18:13:34 <danderson> :-)
18:13:42 <ivanm> cads: linux /= ubuntu
18:13:44 <edwardk> oh well, it looks like out of the box dyre won't do what i need. http://github.com/willdonnelly/dyre/issues#issue/1 is exactly my issue
18:13:53 <ivanm> danderson: which is why he wants it to die! :p
18:14:08 <syntaxglitch> cads, nah, I mostly use Ubuntu, and WinXP at work
18:14:15 <syntaxglitch> but macbooks are oh so shiny
18:14:20 <syntaxglitch> so very shiny
18:14:27 <danderson> meh shiny
18:14:58 <ivanm> edwardk: not sure I get that bug: doesn't it do ghc --make properly or something?
18:15:36 * syntaxglitch remarks as an aside that getting a Haskell SDL program to build and run on all of WinXP, OS X, and Ubuntu is a bit of a pain
18:15:51 <cads> syntaxglitch: I thought the cool macbooks had that neat titanium satin finish
18:15:57 <ivanm> isn't SDL mainly a Linux thing?
18:16:08 <jmcarthur> no
18:16:08 <edwardk> ivanm: it runs ghc --make, but if your application-cum-library requires something that is hidden by default due to multiple package versions then it'll fail to make
18:16:10 <syntaxglitch> SDL is a cross-platform thing, which is largely the point
18:16:14 <jmcarthur> SDL is *very* cross platform
18:16:22 <ivanm> edwardk: :o
18:16:32 <edwardk> ivanm: consider if your library used parsec 3, which is usually hidden by default
18:16:40 <ivanm> edwardk: so the same problem that anyone using ghc --make rather than cabal will have...
18:16:46 <edwardk> yeah
18:16:51 <jmcarthur> "SDL supports Linux, Windows, Windows CE, BeOS, MacOS, Mac OS X, FreeBSD, NetBSD, OpenBSD, BSD/OS, Solaris, IRIX, and QNX. The code contains support for AmigaOS, Dreamcast, Atari, AIX, OSF/Tru64, RISC OS, SymbianOS, and OS/2, but these are not officially supported."
18:16:51 <ivanm> parsec-3 is hidden by default? really?
18:16:58 <edwardk> well, it is by cabal
18:17:14 <edwardk> i suppose that isn't a problem with you use --make
18:17:14 <jmcarthur> i thought SDL worked on more than even that though
18:17:15 <ivanm> oh, if the version is unspecified you mean?
18:17:19 <edwardk> yeah
18:17:29 <ivanm> and that's by cabal-install, not cabal itself ;-)
18:17:33 <edwardk> yeah
18:17:35 <mightybyte> Does Cabal have a way to make certain ghc options conditional depending on the ghc version?
18:17:35 <syntaxglitch> the problem with SDL is that it uses some disgusting preprocessor hack that replaces main() with its own entry point
18:17:44 <syntaxglitch> oddly, that doesn't work so well on Haskell code
18:17:47 <ivanm> edwardk: so I supose the solution is that dyre needs to automagically make an in-place .cabal file and use that :p
18:17:54 <edwardk> ivanm: exactly =)
18:18:03 <ivanm> syntaxglitch: as in it isn't a problem, or it needs a bigger hack?
18:18:05 <edwardk> ivanm: i can probably work around it
18:18:10 <jmcarthur> works okay if you write a C main that calls into your haskell (and that issue only seems to come up for me on os x)
18:18:23 <edwardk> ivanm: just by keeping my configuration dependencies internalized
18:18:29 <ivanm> *nod8
18:18:29 <syntaxglitch> ivanm, as in I have no idea how it could ever work sanely
18:18:32 <ivanm> s/8/*
18:18:37 <edwardk> but i need to figure out how to reflow the application to support dynamic recompilation anyways
18:18:39 <edwardk> that
18:18:46 <syntaxglitch> I do basically what jmcarthur said
18:19:12 <jmcarthur> on other platforms it's a non-issue afaik. certainly not an issue on linux
18:19:27 <edwardk> and i should probably go out of my way to make the dyre configuration feel like the rest of the build files for the app. (i.e. have dyre compile to a folder near where all the other compiler folders are built, have it load a config from the right place, etc.
18:19:27 <syntaxglitch> Write a C wrapper, export the Haskell "main" via the FFI, and munge the building in a makefile
18:19:28 <jmcarthur> i think it has something to do with not being cocoa native on os x
18:19:36 <edwardk> it may wind up having to be merged in though =/
18:19:41 <syntaxglitch> jmcarthur, it's an issue on WinXP too
18:19:46 <jmcarthur> oh :(
18:20:04 <ivanm> edwardk: hang on, you're doing internal library forks? :o
18:20:07 <wavewave> how is the status of llvm backend of ghc ?
18:20:15 <syntaxglitch> Smooth sailing on linux, of course
18:20:15 <edwardk> ivanm: i already had to fork cmdargs ;)
18:20:18 <wavewave> any news?
18:20:22 <ivanm> edwardk: how come?
18:20:29 <ivanm> wavewave: in what sense?
18:20:32 <cads> hmm, does graphics-drawing-combinator or anything else wrap sdl in haskelly goodness?
18:20:38 <edwardk> ivanm: localization support, and the need to expose a lot of the internals
18:20:44 <ivanm> the patch into LLVM has been accepted; haven't heard anything from the GHC front
18:20:57 <edwardk> ivanm: the approach i'm taking is highly non-portable but needed to keep the app consistent
18:20:57 * syntaxglitch has the code set up so that he can build it with cabal in a sane manner on his Ubuntu box, or run the kludgy makefile on the macbook or a Windows machine
18:21:02 <ivanm> edwardk: pushing patches back to ndm (I would think others would want localisation support)?
18:21:14 <wavewave> ivanm: just curious whether llvm backend will be included in newer version of ghc.
18:21:29 <ivanm> wavewave: it will, but I think they're still cleaning it up
18:21:29 <edwardk> ivanm: thought about it, but i'm not terribly happy with my localization model and its terribly abusive ;)
18:21:40 <ivanm> note that it's unlikely to be available until 6.14
18:21:47 <ivanm> edwardk: heh, fair enough
18:21:49 <edwardk> ivanm: i.e. i use getopt to parse just the localization flags so they are known before the rest of the configuration gets parsed
18:21:52 <syntaxglitch> cads: not that I'm aware of
18:21:55 <ivanm> *nod*
18:22:18 <ivanm> edwardk: actually, there was a new library to do something like cmdargs that just came out
18:22:20 <edwardk> ivanm: and i need to rely on a bunch of heavyweight changes to my cabal setup.lhs file so i can locate the po files
18:22:37 <wavewave> ivanm: if it has that backend, then LLVM module may be absorbed in GHC API?... curious.
18:22:43 <edwardk> all of which are hard to encapsulate
18:22:44 <syntaxglitch> cads: graphics-drawingcombinators is a wrapper for 2D OpenGL stuff
18:22:58 <ivanm> edwardk: http://blog.kfish.org/2010/04/uicommand.html <-- I wonder if this would work better for you
18:23:06 <ivanm> wavewave: huh?
18:23:06 <cads> oh well that's probably better
18:23:07 <edwardk> finally, i need to be able to generate a man page, that latter part is about all that really could be backported
18:23:39 <ivanm> wavewave: note: I just know about the LLVM stuff in a "that sounds cool" sense rather than "I wonder why they didn't do it this way" sense (i.e. I have nfi what they're actually doing) :p
18:23:43 <wavewave> ivanm: just random thought..
18:23:55 <syntaxglitch> cads: in some respects... OpenGL itself is kinda horrible though
18:24:01 <ivanm> edwardk: that UI.Command library can generate man pages apparently...
18:24:04 <ivanm> or else you can use pandoc
18:24:22 <edwardk> ivanm: the other piece that i'm trying to bolt on is support for bash autocomplete
18:24:25 <jmcarthur> oh god yes opengl is horrible
18:24:30 <edwardk> ivanm: just for sake of completeness ;)
18:24:35 <syntaxglitch> SDL provides a bunch of other stuff, like input and timing as well
18:24:36 <jmcarthur> like... great for C and all, but not haskelly at all
18:24:44 <ivanm> edwardk: don't you just ship an external bash-completion file or something for that?
18:25:07 <edwardk> ivanm: i plan to, but it'll invoke the command line because there is a ton of context sensitivity in the args
18:25:09 <syntaxglitch> jmcarthur, OpenGL is mutable state built on top of mutable state
18:25:14 <wavewave> ivanm: this LLVM is really cool~~
18:25:16 <syntaxglitch> it's mutable state all the way down
18:25:26 <ivanm> edwardk: *nod*
18:25:27 <edwardk> ivanm: and it obviates me maintaining it in multiple locations
18:25:37 <syntaxglitch> trying to use opengl in Haskell makes me die a little inside
18:25:51 <jmcarthur> syntaxglitch: and yet it's an interface to something which makes the most sense as purely functional! >_<
18:26:18 <syntaxglitch> I've seen assembly code that's more functional than doing anything with opengl
18:26:33 <jmcarthur> i just mean in concept, not in implementation
18:26:36 <edwardk> ivanm: the other problem i've been running into with cmdargs is scalability, its a pain in the butt to deal with a bunch of similar commands using that machinery, i wound up using the c preprocessor to do most of my glue =/
18:26:36 <jmcarthur> or in API, obviously
18:26:46 <syntaxglitch> jmcarthur, yeah, I know :(
18:26:52 <jmcarthur> opengl is an interface to highly parallel hardware
18:26:53 <ivanm> edwardk: :/
18:27:08 <ivanm> edwardk: cmdargs looks cool, but I was thinking something similar
18:27:09 <edwardk> and that still doesn't adequately handle my desire to be able to fetch defaults from various config files.
18:27:11 <syntaxglitch> unfortunately I'm nowhere near competent enough with opengl to try to build a sane, functional interface around it
18:27:34 <jmcarthur> syntaxglitch: i've been trying, but even competence with opengl is not enough to write a wrapper so effectively
18:27:36 * ivanm is wanting to add command line functionality to SourceGraph but has no real idea how to combine all the various options with sub-modes, etc.
18:27:46 <jmcarthur> syntaxglitch: it's like trying to write a compiler for a dsl
18:28:09 <jmcarthur> even if you are writing shaders in GLSL, the rest of opengl still feels like compilation in the implementation of a functional wrapper
18:28:13 <syntaxglitch> jmcarthur, no, writing a compiler sounds like fun
18:28:18 <syntaxglitch> wrapping openGL doesn't
18:28:19 <edwardk> i.e. ideally i'd grab options from some kind of installed .../etc/kata/config, ~/.kata/config <build-dir>/<kit>/config -- for post 'configure' options, and then from your commandline
18:28:42 <jmcarthur> syntaxglitch: well, a purely functional wrapper essentially requires compilation in order to use opengl efficiently
18:28:53 <jmcarthur> or at least some crazy rewrite rules
18:29:00 <jmcarthur> but compilation would be better
18:29:37 <syntaxglitch> on the other hand SDL is at least stupidly simple, and for the most part only as stateful as you want it to be
18:29:51 <jmcarthur> eh
18:30:00 <syntaxglitch> the haskell SDL bindings are stuffed full of IO of course
18:30:02 <jmcarthur> i got with SDL because i don't like the alternatives
18:30:06 <jmcarthur> *i go with
18:30:11 <kmc> SDL sucks for actual rendering
18:30:17 <jmcarthur> well, yeah
18:30:24 <syntaxglitch> but there's so little there it's easy to work around it and write mostly functional code
18:30:26 <kmc> it's all right for getting a window, input, and an OpenGL context
18:30:45 <jmcarthur> oh i didn't realize rendering was what syntaxglitch meant about sdl
18:30:52 <jmcarthur> yeah i'm not a fan of that part of sdl
18:30:54 <kmc> i don't know either
18:30:59 <kmc> just wanted to mention this
18:31:05 <syntaxglitch> well, I meant SDL in general
18:31:09 <jmcarthur> ah
18:31:21 <jmcarthur> i pretty much only use it for what kmc said, and also inputs
18:31:27 <jmcarthur> oh kmc said that
18:31:41 <edwardk> i'm currently fiddling with what is the right set of options there. i can forego a good chunk of that and have the cabal installer install the .po files for localization and set the app dir - thats what i do now. with that i could perhaps modify dyre to just grab the config from your app dir and compile it. otherwise i can deal with writing a cheesy parser for a config format
18:31:41 <kmc> maybe it's good for sound? haven't used that
18:31:45 <edwardk> and apply it to those locations
18:31:45 <syntaxglitch> I'm not averse to using SDL to shove pixels onto the screen
18:31:54 <syntaxglitch> kmc, it works well enough for that
18:32:03 <jmcarthur> yeah i haven't used sdl for audio either
18:32:10 <kmc> maybe if your graphics are totally sprite-based
18:32:27 <kmc> even then, OpenGL textures are easy enough, and you can scale them etc.
18:32:53 <syntaxglitch> kmc, but the downside is that then you have to use OpenGL :(
18:32:58 <edwardk> ivanm: the 'top level mode' notion works well in cmdargs, but it doesn't really have nested modes
18:33:17 <kmc> i think OpenGL is all right
18:33:19 <jmcarthur> or a wrapper like graphics-drawingcombinators, which is actually quite good
18:33:37 <jmcarthur> not the fastest graphics library in the verse, but good
18:33:45 <syntaxglitch> kmc, it's painfully un-Haskell-ish is all
18:33:48 <kmc> true
18:33:56 <jmcarthur> *very* painfully :(
18:34:03 <kmc> i think Haskell is a fine imperative language
18:34:09 <kmc> and i like writing imperative programs in Haskell
18:34:12 <edwardk> it'd also be nice to be able to factor the 'Data' based configuration out so that it can have common fragments. data Mode1 { groupAOptions :: CommonFlags1, groupBOptions :: CommonFlags2 } | Mode2 { ... }
18:34:14 <syntaxglitch> it's rather telling that the author of the haskell openGL bindings made a package just to provide a nice syntax for setting global state variables
18:34:18 <kmc> but yes a truly functional graphics library would be / is nice
18:34:24 <jmcarthur> yes, but haskell also makes you wish you weren't programming imperatively because you have seen nicer alternatives
18:34:42 <kmc> jmcarthur, but the nicer alternatives for interactive graphics are still an active research area
18:34:56 <ivanm> edwardk: right, which is what I want
18:35:00 <jmcarthur> kmc: the interactivity is more researchy than the graphics
18:35:05 <kmc> true
18:35:10 <edwardk> kmc: they would have been less of a 'research area' had khronos actually delivered on 3.0 as proposed ;)
18:35:14 <kmc> so maybe you can make it partway functional
18:35:22 <kmc> without handling state and interactivity in an FRPish way
18:35:40 <kmc> just by describing scenes declaratively
18:36:17 <edwardk> ivanm: my thought on the config file format is to just take name: value pairs, where 'name' is the option sans -- and merge them incrementally
18:36:21 <jmcarthur> all you need to make a generic functional graphics api work well with animation is find a good way to use sharing to avoid recreating gpu resources for each frame
18:36:39 <edwardk> starting from the etc to the user app dir to the current config, to the command line overriding as i go
18:36:41 <kmc> observable sharing eh
18:36:47 <ivanm> edwardk: hmmmm....
18:36:48 * syntaxglitch ends up using SDL for tinkering just because he finds Haskell + OpenGL so unpleasant :\
18:36:51 <jmcarthur> i didn't say observable
18:36:56 <kmc> but it'd have to be
18:36:57 <kmc> yes?
18:36:59 <jmcarthur> nah
18:37:03 <kmc> i haven't thought it through enough
18:37:04 <edwardk> ivanm: that fits reasonably closely with the behavior of cabal
18:37:43 <syntaxglitch> jmcarthur, I wonder if it would be easier to make a functional wrapper around a higher-level library that itself uses opengl
18:37:45 <edwardk> ivanm: with only the command line yelling if you use an option that isn't applicable to the current mode, but all yelling if you use one that isn't applicable in any mode.
18:37:46 <jmcarthur> just treat the buffers like normal memory with finalizers and such
18:37:57 <kmc> hmm, yeah
18:37:58 <jmcarthur> syntaxglitch: yeah i thought about something like ogre
18:38:00 <syntaxglitch> either write one for that purpose, or an existing one, dunno
18:38:01 <kmc> well finalizers are a little magical still
18:38:07 <kmc> and nondeterministic and all
18:38:10 <jmcarthur> but... c++... not fun to bind to
18:38:23 <syntaxglitch> :(
18:38:37 <edwardk> jmcarthur: binding to ogre was one of the reasons i started writing my own language. haskell's ffi to c++ leaves something to be desired ;)
18:38:48 <jmcarthur> edwardk: yeah :(
18:39:24 <wavewave> edwardk, kmc: LLVM library is exactly what I want.. thx.
18:39:27 <syntaxglitch> is C to C++ any better? Or is "via C wrappers" what haskell's c++ ffi already is
18:39:33 * syntaxglitch hasn't tried
18:39:34 <edwardk> wavewave: happy to help =)
18:39:35 <jmcarthur> kmc: you could just force a gc between frames if you hit problems
18:39:40 <Kaidelong> OpenGL with C++ is a mess
18:39:44 <Kaidelong> GLUT isn't much better
18:39:51 <jmcarthur> kmc: or wherever you need to reclaim gpu resources anyway
18:40:02 <Kaidelong> speaking from experience
18:40:06 <jmcarthur> syntaxglitch: via C wrappers
18:40:13 <syntaxglitch> GLUT steals the event loop, doesn't it? That bugs me, too
18:40:21 <jmcarthur> syntaxglitch: yeah. i hate glut with a passion
18:40:40 <syntaxglitch> Having to give up the event loop seriously screws up a lot of attempts to make things less imperative
18:40:42 <jmcarthur> glfw is alright
18:40:45 <Kaidelong> I tried Irrlicht, had a bit more luck with that, but adapting it to work well with F# was a pain
18:41:07 <Kaidelong> (figured since it had .NET bindings might as well hack at it from familiar territory)
18:41:18 <edwardk> glut isn't anything you can really build on past a small toy example
18:41:25 <fax> guess how many lines of haskell I wrote today
18:41:32 <fax> ...ONE.
18:41:55 <jmcarthur> ABOUT NINE THOUSAND EXACTLY NOT OVER OR UNDER
18:41:56 <syntaxglitch> blah, F# makes my head hurt, it's sufficiently similar to Haskell that I trip over everything expecting them to act the same way
18:41:57 * Kaidelong has been spending most of today, and the last 3 days, trying to get wxHaskell working
18:41:59 <edwardk> Kaidelong: when working in c# i usually go with something like slimdx
18:42:07 <fax> at this rate I will be finished very soon
18:42:10 <fax> :P
18:42:31 <Kaidelong> I like F#, it's comfortably imperative, and making parallel algorithms in it is really easy
18:42:43 <syntaxglitch> I think I'd like F# if I got used to it
18:42:50 <Kaidelong> array of lazy closures then force map in parallel
18:42:54 <edwardk> Kaidelong: i'd like f# if don syme ever figured out how to shoehorn a decent module system into the CLR ;)
18:42:59 <interferon> is there a builtin function takes a list xs and returns xs except without its final element?
18:43:27 <Kaidelong> edwardk: I'd really like the projects system to work better and not be order dependent but it is workable
18:43:33 <syntaxglitch> interferon, init?
18:43:41 <Kaidelong> Don Syme did manage to get IL to be extended to ILX
18:43:48 <interferon> syntaxglitch: nope
18:43:57 <interferon> mystery [1, 2, 3] => [1, 2]
18:44:00 <Kaidelong> and he was a force behind the introduction of LINQ, I think
18:44:03 <ivanm> jdh was advertising a new F# book he'd written, so I went to have a look to see what he wanted for it... it was about USD$120, whereas I bought RWH for about USD$70
18:44:31 <Kaidelong> both prices are rather astronomical
18:44:31 <aavogt> 70 is still quite a bit
18:44:34 <jmcarthur> yeah
18:44:40 <syntaxglitch> interferon, isn't that what init does...?
18:44:45 <edwardk> Kaidelong: sadly none of my libraries can really be written in f# (most of category-extras needs some kind of real parametric polymorphism or polymorphic recursion.)
18:44:47 <interferon> syntaxglitch: no
18:45:02 <interferon> yep
18:45:03 <blackdog> > init [1,2,3]
18:45:03 <edwardk> Kaidelong: a lot of that was actually erik meijer
18:45:03 <lambdabot>   [1,2]
18:45:09 <interferon> :D
18:45:12 <interferon> you're right
18:45:13 <edwardk> another functional programmer in microsoft
18:46:05 <ivanm> > inits [1..5]
18:46:06 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]]
18:46:48 <Kaidelong> edwardk: I'm not very clear on why there would be something you can do in C# that you can't do in F# in terms of the type system, although if you'd explain it to me I'd love to hear
18:46:53 <interferon> syntaxglitch: i was thinking of inits
18:46:59 <syntaxglitch> I've dabbled with F# a bit, but using the .NET libraries feels so ugly and awkward
18:47:00 <edwardk> Kaidelong: i can do it in haskell, not f# ;)
18:47:02 <syntaxglitch> Not functional at all
18:47:04 <Kaidelong> oh
18:47:13 <Kaidelong> I like Haskell's type system a lot
18:47:50 <syntaxglitch> And the whole OOP + functional thing just feels like a horrible jumble to me
18:47:52 <edwardk> f# pretty much beats c# in terms of functionality in lots of little ways, though the syntax gets pretty clunky by the time you bolt on all the inherited quirks of the CLR and an ml heritage ;)
18:47:53 <cads> after google's done beating the fuck out of microsoft, don't you guys rather feel like it'll become as mild mannered and generous as IBM has after having its ass handed to it by MSFT? I think the beating's only just begun.
18:47:53 <Kaidelong> OCaml also can do a few type things F# can't
18:48:08 <Kaidelong> F# has the disadvantage of having to be compatible with the .NET type system
18:48:34 <ivanm> well, I know that one of my programs won't work on F# because it uses Cabal to get the output of ghc-pkg... :p
18:48:35 <Kaidelong> so you don't have as much implicit structural typing and structural equality and you can't infer all the types
18:48:45 <edwardk> Kaidelong: i understand why the language evolved the way it has. it just means i can't use it for the things i want to do ;)
18:48:51 <Veinor> I kind of want to play with F#
18:49:01 <Veinor> but I don't have easy access to a windows machine
18:49:03 <Veinor> so
18:49:27 <oblomov> Mono supports F#
18:49:28 * ivanm suddenly wonders if someone is paying jdh to troll just to keep people away from OCaml and F# ...
18:49:32 <edwardk> Kaidelong: and sadly, scala makes a better f# than f# for the few cases where it seems appropriate to me ;)
18:49:39 <syntaxglitch> my main problem with F# was having to stop every few lines and remind myself that it actually evaluates terms that I clearly don't need the value of
18:49:39 <Kaidelong> edwardk: there are some advantages to runtime types, or at least I thought it counted as an advantage when I was marshalling data coming in from R over COM
18:49:47 <syntaxglitch> such a weird behavior
18:49:54 <syntaxglitch> dunno who came up with that
18:50:15 <ivanm> edwardk: well, scala is also used as a research language, whereas I doubt F# could (since it isn't open)
18:50:24 <Kaidelong> syntaxglitch: I started my functional programming with scheme, so I find that to be the intuitive behavior and write around it, and often screw up writing haskell because it's so counterintuitive to me that things will be lazy unless I saw otherwise
18:50:25 <edwardk> Kaidelong: i keep scheme in my toolchest for that reason. ;) heck my toy language is largely untyped. =)
18:50:41 <Kaidelong> ivanm: it isn't?
18:50:42 <ivanm> syntaxglitch: you mean it's eager rather than lazy?
18:50:54 <ivanm> Kaidelong: can anyone who wants to download the F# compiler and tweak it?
18:51:02 <edwardk> though, i have to admit that 'ubiquitous laziness' makes a prettier language.
18:51:28 <syntaxglitch> scheme is rather charming, I admit
18:51:40 <Kaidelong> I am not sure
18:51:41 <edwardk> no 'fun/val' noise, no need to use let, since you can use where, since you don't have any let binding ordering just for effect purposes, etc.
18:51:46 <Kaidelong> I guess I'll look it up and see
18:51:48 <syntaxglitch> I never did enough scheme programming for that perspective to stick, though
18:51:59 * ivanm looks at the F# page on Wikipedia
18:52:19 <edwardk> you can use let rec as the default, rather than have to have two forms, because you don't need to worry about the loss of effects or changes in termination behavior
18:52:24 <Kaidelong> doesn't look like it's open
18:52:29 <ivanm> OK, so people bitch that Haskell isn't like C, but at least we use C-like comments... I mean, (* what's with this comment syntax? *)
18:52:35 <ivanm> Kaidelong: exactly
18:52:47 <ivanm> and I doubt Mono's is as good as the official .Net one
18:52:50 <Kaidelong> ivanm: wasn't quite sure if it was since it was originally a MSR product
18:53:06 <aavogt> neither is GHC
18:53:06 <Kaidelong> yes, I do not consider .NET cross platform in a practical sense
18:53:17 <Kaidelong> however Microsoft's tooling is second to none
18:53:19 <syntaxglitch> I think the strongest statement that can be made about Mono is that things often compile and run under it
18:53:26 <edwardk> mono does work rather disturbingly well though
18:53:31 <Veinor> I remember reading about a language that used: *> this is a comment <*
18:53:33 <Veinor> or something
18:53:37 <ivanm> it's "Microsoft Research Shared Source license agreement ", so who knows *shrug*
18:53:43 <ivanm> aavogt: neither is GHC what?
18:53:52 <aavogt> an MSR product
18:53:52 <ivanm> Veinor: :o
18:53:53 <Kaidelong> Veinor: there is mumps where comments can only be of a certain length and slow down the program
18:54:03 <edwardk> i was shipping a number of apps under 3.5 early on and they caught up to the point where i could compile and distribute my apps using mono in fairly short order, despite using a LOT of 3.5, WCF, etc.
18:54:04 <ivanm> Kaidelong: heh
18:54:06 <syntaxglitch> Mono is an impressive bit of work, but it really can't keep up with MS's platform
18:54:14 <Veinor> I don't remember what language it was, though
18:54:19 <ivanm> aavogt: well, that's because it predates MSR hiring SPJ
18:54:27 <ivanm> it was already in the wild by then ;-)
18:54:29 <Kaidelong> ivanm: shared source is not open, you can look at it but you can't redistribute it
18:54:42 <ivanm> Kaidelong: yeah, I figured it'd be something like that
18:54:42 <Schalken> I have a function which returns a writer. How do I get the log and the value out?
18:54:58 <edwardk> @type runWriter
18:54:59 <lambdabot> forall w a. Writer w a -> (a, w)
18:55:04 <ivanm> like the old definition of "open source": "you give us more money and we'll let you tweak your own installation of the product you're licensing"
18:55:06 <edwardk> the value is 'a'
18:55:08 <edwardk> the log is 'w'
18:55:11 <Kaidelong> ivanm: nonetheless a lot of MSR stuff really is open, IE the common compiler interface
18:55:22 <ivanm> Internet Explorer is open? :o
18:55:23 <ivanm> :p
18:55:31 <edwardk> IE /= MSR stuff ;)
18:55:32 <Veinor> in general, for a Foo monad, runFoo will 'unwrap' the monad in some sense
18:55:35 <Kaidelong> IE never has been part of MSR I don't think
18:55:55 <syntaxglitch> MS does actually have some open source stuff--I think the ASP.NET MVC framework is?
18:56:01 <Kaidelong> F# was for most of its lifetime and just recently got mainstreamed
18:56:08 <Kaidelong> and their data mining suite
18:56:13 <Kaidelong> CRM analytics
18:56:17 <syntaxglitch> as well as some of the dynamic runtime stuff
18:56:26 <Kaidelong> and then the singularity research operating system
18:56:53 <Schalken> edwardk: So "let runWriter (a, w) = somethingThatReturnsAWriter... in ..." ?
18:56:53 <edwardk> ooh http://www.comlab.ox.ac.uk/ralf.hinze/SSGIP10/AdjointFolds.pdf
18:56:56 <Kaidelong> and an old game of theirs called alliegance, kind of pointless just to sit here listing examples
18:57:04 <Kaidelong> allegiance even
18:57:06 <aavogt> this is -blah content
18:57:16 <edwardk> schalken let (a,w) = runWriter (somethingThatReturnsaWriter) in ...
18:57:46 <Schalken> edwardk: Aha! That's where I was going wrong. Thanks!
18:58:09 <aavogt> Schalken: there are also evalWriter and execWriter if you don't care about one of 'a' or 'w'
18:58:20 <Veinor> @src evalWriter
18:58:20 <lambdabot> Source not found. I am sorry.
18:58:23 <Veinor> >:(
18:58:31 <aavogt> @type evalWriter
18:58:32 <lambdabot> Not in scope: `evalWriter'
18:58:37 <aavogt> @type evalState
18:58:38 <lambdabot> forall s a. State s a -> s -> a
18:58:43 <aavogt> @type execState
18:58:44 <lambdabot> forall s a. State s a -> s -> s
18:58:57 <aavogt> or there is for State at least
18:59:02 <aavogt> @type execWriter
18:59:03 <lambdabot> forall w a. Writer w a -> w
18:59:11 <aavogt> right, evalWriter would be sort of useless
18:59:25 <aavogt> since why would you log something only to throw it away?
18:59:41 <syntaxglitch> sounds very zen
18:59:51 <Schalken> aavogt: Nah, I'm just printing the log and then doing something else with the value.
19:00:34 <orlandu63> how would one define fmap to make Data.Map an instance of Functor?
19:00:54 <syntaxglitch> ...isn't it an instance already?
19:01:06 <orlandu63> for practical purposes, let's assume it's not
19:01:08 <orlandu63> :P
19:01:12 <syntaxglitch> ah
19:01:21 <octavious> sounds like homework :-D
19:01:30 <ivanm> orlandu63: fmap over the values, not the keys
19:01:41 <orlandu63> sounds like a tutorial question that i'm trying to confirm my answer to
19:02:00 <ivanm> since Functor doesn't allow restrictions on the type, whereas Map requires the keys to be Ord instances
19:02:20 <orlandu63> (that sounded rude; don't take it that way)
19:02:21 <aavogt> you don't fmap over the keys
19:02:31 <orlandu63> anyway i got fmap = Map.map
19:02:35 <orlandu63> is that ok?
19:02:38 <aavogt> you fmap over the elements, which don't have to be ordered
19:03:06 <syntaxglitch> orlandu63, those are pretty much synonymous, yes
19:03:13 <ivanm> aavogt: didn't I just say that?
19:03:25 <ivanm> @type Map.map
19:03:26 <lambdabot> Couldn't find qualified module.
19:03:27 <syntaxglitch> that's not really a very interesting definition though...
19:03:27 <dolio> edwardk: What's with the Fraktur?
19:03:31 <ivanm> @type M.map
19:03:32 <lambdabot> forall a b k. (a -> b) -> M.Map k a -> M.Map k b
19:03:49 <edwardk> dolio: he seems to have chosen that as his syntax for the base functor. i'm not fond of it
19:03:50 <mun_> in logic, how to express that a term 'Foo' is in a FOL formula 'form'? is there a notation?
19:03:53 <ivanm> orlandu63: get all the values, map them, put them back in
19:04:10 <ivanm> hint: you can't get the values on their own (well, not if you want to be able to re-create the Map anyway)
19:04:19 <edwardk> dolio: but its nice seeing something other than my ramblings and uustalu's talking about mendler-style folds and unfolds =)
19:05:05 <edwardk> the fraktur would work better if he quickly got away from the base functor so it was used less
19:05:44 <aavogt> ivanm: yeah, I'm not sure how you would involve the keys anyways, sinc you'd have to flip the type parameters around
19:06:00 <ivanm> fromList . map (second f) . toList
19:06:18 <ivanm> wait, why did I just type that here...
19:06:20 <ivanm> aavogt: yeah
19:07:02 * syntaxglitch looks at the paper
19:07:09 <syntaxglitch> wow, that is an... interesting choice of font face
19:07:19 <edwardk> i do love the derivation of adjoint folds on pp16-17 though.
19:07:49 * syntaxglitch sets the paper aside to read later, though :(
19:08:52 <edwardk> syntaxglitch: well, there is a common problem when you have a base functor, the fixed point of the base functor, some kind of wrapped version of that folded functor, a mendler-style fixed point equation and a function all to name using similar terminology ;)
19:08:57 <gio1234> Cale: hi
19:09:14 <ivanm> gio1234: :o how do you know Cale is actually online?
19:09:17 <ivanm> preflex: seen Cale
19:09:17 <preflex>  Cale was last seen on #haskell 3 hours, 42 minutes and 58 seconds ago, saying: Well, it's not the evaluation of the IO that's such a concern, it's the execution which is going on along the way,
19:09:21 <ivanm> ;-)
19:09:26 <edwardk> ivanm: cale is always online
19:09:40 <ivanm> nick being here /= actually online
19:10:02 <syntaxglitch> edwardk, I sometimes wish I could do something similar in actual code, just upper/lower case for the initial letter doesn't really go very far
19:10:20 <gio1234> bet
19:10:25 <edwardk> no, i mean he is wired up to feeding tubes, and we administer shocks to him whenever his name is called on channel. ;)
19:10:37 <syntaxglitch> edwardk, on the other hand, look on the bright side: at least it didn't use Comic Sans MS
19:10:57 <Kaidelong> using the haskell debugger won't help me find a segmentation fault right?
19:10:57 <gio1234> he is 24 h online, no eat, no sleep...
19:11:04 <Kaidelong> that'll always be part of a foreign library?
19:11:29 * syntaxglitch has never seen a segfault from Haskell
19:11:41 <gio1234> ivanm: ok?
19:12:38 <tensorpudding> Maybe you could make a segfault by doing something unsafe
19:12:53 <syntaxglitch> probably
19:13:06 <syntaxglitch> but the worst thing I've ever done is crash GHC
19:13:18 <Kaidelong> this is quite annoying, if I compile a program that uses wxHaskell, it complains that it wxColour::set couldn't set the color to some predefined color string and then segfaults
19:13:27 <Kaidelong> not during compile time
19:13:29 <tensorpudding> And of course you could get a segfault running code pulled through the FFI right?
19:13:33 <Kaidelong> I mean, when the program is run
19:13:34 <syntaxglitch> or make GHC eat 3GB of memory before I had to kill it, that was fun
19:13:58 <tensorpudding> GHC loves using memory :(
19:14:16 <edwardk1> you can crash Haskell with some of the various System.* calls, unsafeCoerce, or even playing with some fringe cases with newtypes and type families
19:14:22 <syntaxglitch> tensorpudding, I was just trying to compile a six-line program with no weird extensions! :(
19:14:34 <Kaidelong> well the amount of memory you need grows exponentially the more types you define doesn't it? or was this some other language I was thinking of
19:15:00 <Kaidelong> to compile it
19:15:18 <edwardk1> Kaidelong: actually a lot of hindley-milner-esque sml-like languages and processes are exponential in theory and all but linear in practice
19:15:30 <Kaidelong> ah I see
19:15:48 <Kaidelong> so a bit like how prolog in theory should become exponentially more slower the more rules you have in a program but it doesn't in practice?
19:16:03 <Kaidelong> slower
19:16:13 <syntaxglitch> except the program I wrote, apparently
19:16:15 <edwardk1> yeah big-Oh can sometimes be a pretty loose bound ;)
19:16:34 <syntaxglitch> which seemed to hit some sort of near-worst-case scenario :(
19:16:35 <ezyang> "Use Big-Theta instead!"
19:17:03 <edwardk1> ezyang: well, in this case most of these are actually the big-theta bounds, but most problem instances don't go anywhere near the bounds
19:17:37 <ezyang> Yeah; the fat constant gives you a lot of leeway
19:18:44 <Kaidelong> I suppose the other thing is that you don't need to define truly new types that often anyway since most things can be expressed as functions over relatively simple things like trees or lists
19:19:23 <Kaidelong> it's not like OO programming where you make a new class whenever you need some slightly different notion of mutable state
19:19:42 <edwardk> Kaidelong: of course not, you just define a new monad ;)
19:20:10 <syntaxglitch> Kaidelong, I dunno, my program that made GHC fell over didn't define any new types at all! :D
19:20:17 <syntaxglitch> ...which was actually part of the problem
19:20:23 <edwardk> syntaxglitch: hah
19:21:56 <syntaxglitch> ahh, here we go
19:22:05 <syntaxglitch> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24153
19:22:17 <z1y> Hello. I've compiled `test.hs` from http://code.haskell.org/http/test/ and got error "http://code.haskell.org/http/test/". What's wrong?
19:22:34 <syntaxglitch> anyone want to guess why that code makes GHC cry? :D
19:23:24 <edwardk> @type \ x y z f = f x y z
19:23:25 <lambdabot> parse error on input `='
19:23:33 <edwardk> @type \ x y z f -> f y x z
19:23:34 <lambdabot> forall t t1 t2 t3. t -> t1 -> t2 -> (t1 -> t -> t2 -> t3) -> t3
19:23:44 <greedo> which would be more correct
19:23:49 <z1y> Hello. I've compiled `test.hs` from http://code.haskell.org/http/test/ and got error "Not in scope: type constructor or class `ConnError'". What's wrong?
19:24:21 <greedo> Int -> Int -> Int -> Int or Int -> ( Int -> (Int -> Int))
19:24:42 <edwardk> greedo: use the former or you'll slowly go insane working in haskell ;)
19:25:01 <edwardk> greedo: with the interpretation that they say the same thing
19:25:10 * syntaxglitch notes that loading the hpaste'd code into GHCi and doing ":t uh.oh" won't hurt too bad and will demonstrate the problem with the code :(
19:25:58 <Kaidelong> that's a lovely type signature
19:26:05 <Kaidelong> at least it terminates
19:26:05 <syntaxglitch> yes indeed
19:26:20 <syntaxglitch> technically
19:27:05 <syntaxglitch> add a few more ". up" and ". down" in there and it won't terminate in any practical sense though
19:27:36 <syntaxglitch> in the program I was trying to write it all collapsed back down to a few types in the end
19:28:03 <syntaxglitch> but due to how I wrote it, and a lack of type signatures, nothing unified until the last minute
19:28:18 <syntaxglitch> and the intermediate types looked like the result of the hpaste'd code :(
19:29:01 <jmcarthur> @pl \ x y z f -> f y x z
19:29:01 <lambdabot> (flip .) . flip (flip . flip id)
19:29:38 <syntaxglitch> I'd like to say that I learned something from the experience, but I can't really say I did, heh
19:30:46 <cads> I'm working with hmatrix here in windows and finally got it to compile... managed to simplify the installation process a bit bit it still involves the user in modifying a cabal file and fetching a compressed file with some libraries.
19:31:08 <edwardk> dolio: woot. left and right kan extensions on p 28 ;)
19:31:43 <cads> aside from including the library files in the hackage version of hmatrix, what could be done to make this process automatic so that you could say cabal install hmatrix even in windows
19:31:56 <syntaxglitch> hmm, I think it was something involving church-encoded right folds
19:32:02 <syntaxglitch> not really the most practical bit of code
19:32:58 <syntaxglitch> oh well
19:33:42 <Kaidelong> the "@pl" command really makes me dread having to TA someone who knows about it
19:34:21 <edwardk> kaidelong, enough round trips between pl, do, undo, and unpl and you can get some seriously obfuscated code
19:34:48 <Kaidelong> oh wow
19:34:58 <edwardk> Kaidelong: there is of course, always http://comonad.com/haskell/remorse-1.0/remorse.hs
19:35:29 <Makoryu> edwardk: Auuuugghhhhh
19:35:33 <syntaxglitch> edwardk, oh good lord what is that
19:35:33 <cads> hmm, hmatrix is actually published under the same gpl license as the as the library files it needs to compile in windows
19:35:36 <edwardk> Makoryu: blame malcolmw
19:35:44 <dolio> edwardk: This really gives a lot of background.
19:35:45 <edwardk> syntaxglitch: it morse codes and uncodes haskell
19:36:11 <cads> but including the extra files in the hackage distribution would just about double its size
19:36:27 <edwardk> dolio: this is by far my favorite paper this year. it had a coherent use for mendler style folds and unfolds, the adjoint style clearly subsumes the general form, and it uses a lot of nice adjunctions
19:37:35 <aavogt> Kaidelong: there's an @unpl though!
19:37:48 <Kaidelong> aavogt: yes, it's pretty bad
19:38:13 <dolio> edwardk: It is quite good.
19:38:32 <syntaxglitch> the problem with @pl is that it doesn't help you make your code more general purpose, we need something that replaces as many functions as possible with their most generic equivalents
19:38:36 <edwardk> dolio: i can even forgive him the fraktur ;)
19:38:50 <aavogt> something like hlint
19:38:51 <syntaxglitch> monoids and functors can take you pretty far
19:38:52 <jmcarthur> edwardk: why bother using do notation in remorse?
19:38:55 <Makoryu> syntaxglitch: Hmmm
19:38:56 <tensorpudding> What's wrong with fraktur?
19:39:05 <Kaidelong> @pl \predictors -> sqrt . sum .  map (\n-> n*n) . map (\y x -> y-x) . zip predictors
19:39:05 <lambdabot> ((sqrt . sum . map (join (*))) .) . zipWith (curry (-))
19:39:15 <Kaidelong> @unpl ((sqrt . sum . map (join (*))) .) . zipWith (curry (-))
19:39:15 <lambdabot> (\ d o -> sqrt (sum (map ((*) >>= \ k -> k) (zipWith (curry (-)) d o))))
19:39:16 <edwardk> jmcarthur: not my code, ask malcolmw ;)
19:39:19 <dolio> This is the first paper I've seen that gives a quick overview of how to do nested types via initial algebras.
19:39:37 <edwardk> dolio: oh, there are a number of papers by ghani and johann
19:39:41 <Makoryu> @type curry (-)
19:39:42 <lambdabot> forall a b. (Num (a, b)) => a -> b -> (a, b) -> (a, b)
19:39:47 <Kaidelong> err that's wrong
19:39:48 <dolio> Although, I don't think it's exactly the same way as in Initial Algebras are Enough!
19:39:52 <Makoryu> O_o
19:39:55 <dolio> If I'm recalling that paper correctly.
19:39:56 <Kaidelong> @pl \predictors -> sqrt . sum .  map (\n-> n*n) . map (\(y,x) -> y-x) . zip predictors
19:39:56 <lambdabot> ((sqrt . sum . map (join (*))) .) . zipWith (-)
19:39:58 <syntaxglitch> yeah, see... map? (.)? those are both fmap
19:40:06 <Kaidelong> @unpl ((sqrt . sum . map (join (*))) .) . zipWith (-)
19:40:07 <lambdabot> (\ d o -> sqrt (sum (map ((*) >>= \ k -> k) (zipWith (-) d o))))
19:40:08 <edwardk> thats one of the ones they did that in
19:40:12 <Kaidelong> still bad
19:40:15 <jmcarthur> :t uncurry (-)
19:40:16 <lambdabot> forall a. (Num a) => (a, a) -> a
19:40:30 <edwardk> his presentation here is about taking them apart and putting them together through the adjoint though, so its a bit different
19:40:59 <dolio> edwardk: I don't think I'd call Initial Algebras are Enough a 'quick overview'. :)
19:41:29 <edwardk> seemed perfectly clear at the time ;)
19:42:27 <Kaidelong> I suppose zipWith (-) is nicer than using a zip and a map actually
19:42:49 <edwardk> http://personal.cis.strath.ac.uk/~patricia/popl08.pdf is the one i think i'm thinking of
19:43:07 <edwardk> "Foundations for Structured Programming with GADTs"
19:43:25 <dolio> Does that cover nested types?
19:43:59 <edwardk> though, they abuse kan extensions even worse there. it covers gadts in pretty good generality, non-unary data constructors, multiple type parameters, etc.
19:44:14 <edwardk> maybe they don't hit nested data types
19:44:15 <edwardk> hrmm
19:44:35 <dolio> I'm not sure if I ever got around to reading the GADTs one.
19:44:57 <edwardk> its a good read. it actually post-hoc justified a lot of the machinery i'd put into category-extras for me ;)
19:45:22 <edwardk> i added control.category.discrete to better model some of this stuff
19:45:47 * syntaxglitch wishes he could make sense of more of category-extras :(
19:45:54 <dolio> I guess that lends credence to Agda's 'inductive families'.
19:46:22 <edwardk> syntaxglitch: which is why i need to split it apart
19:46:49 <dolio> Since you can index types by other types, and Conor McBride mentioned a few days back that no one's ever proved that it's actually okay to do that.
19:46:53 <edwardk> so it can be clearer what parts are readily accessible
19:47:01 <edwardk> dolio: hah
19:47:25 <dolio> Or, index them by Set, that is.
19:47:36 <edwardk> well, prove it, and get a paper out of it ;)
19:48:00 <syntaxglitch> edwardk, it's the sheer number of moving parts that gets to me... most of it makes sense, but I have to go look up what everything means to figure out what does what :(
19:48:28 <timofonic> Are there "foundations to have a nice life full of sex, health and geekyness" document?
19:48:34 <edwardk> syntaxglitch: yeah. when i get a chance to revisit it and a week to binge i want to go through and carve it up into 6-7 pieces
19:48:44 <timofonic> @faq Will Haskell reduce my sex life?
19:48:44 <lambdabot> The answer is: Yes! Haskell can do that.
19:49:13 <dancor> > 0 / n
19:49:14 <lambdabot>   0 / n
19:49:29 <timofonic> Sorry, internet connection stoped by some minutes and had to troll a bit :P
19:49:41 <edwardk> syntaxglitch: there are a number of fairly disjoint ideas captured in category-extras, and i'll admit the size of the package dependency keeps it from being used in a lot of places where only one or two of them apply
19:49:54 <greedo> second xs = head (tail xs)
19:50:17 <greedo> is [a] -> [a] -> [a] -> [a]
19:50:23 <greedo> correct?
19:50:37 <edwardk> @type head . tail
19:50:38 <lambdabot> forall a. [a] -> a
19:50:41 <edwardk> fraid not
19:50:42 <edwardk> =)
19:51:00 <greedo> hmm
19:51:06 <syntaxglitch> edwardk, what kind of stuff do you think you'd be splitting out?
19:51:40 <edwardk> syntaxglitch: 'categories' 'functors' 'comonads' 'monads' 'recursion-schemes', and '-extras' versions of most of those to deal with the esoteric cases
19:51:55 <greedo> so them [a] -> [a] -> a
19:52:05 <dancor> do ppl really care about deps in haskell
19:52:09 <edwardk> @type \xs -> head (tail xs)
19:52:09 <lambdabot> forall a. [a] -> a
19:52:12 <dancor> and in category theory of all things
19:52:14 <edwardk> no, just [a] -> a =)
19:52:38 <edwardk> dancor: well, there are a lot of simple comonads in there that can be used without all the theoretical nonsense
19:52:43 <edwardk> i.e. control.comonad.supplyu
19:52:48 <edwardk> or control.comonad.product
19:52:49 <greedo> oh, lamba would be a good way to test it
19:53:08 <dancor> right, i could see that it's hard for the leity to know what they could actually find useful
19:53:12 <edwardk> and the codensity monad comes up a lot when talking to me
19:53:26 <edwardk> =)
19:53:39 <edwardk> dancor: exactly
19:53:44 <dancor> i think there should be a "killer application" example for each one
19:53:57 <dancor> or for the ones where an app has been found yet :)
19:53:59 <edwardk> yeah, i just got bored by the end ;)
19:54:08 <dancor> mm
19:54:08 <syntaxglitch> edwardk, yeah, the comonads and some of the neat functor stuff is what I've sometimes wanted to use
19:54:20 <edwardk> if you look at the commit time category-extras was more or less a couple month binge on my part ;)
19:55:23 <syntaxglitch> also I think you have parameterized monad sorta things in there... somewhere? those are useful, too.
19:55:48 <edwardk> syntaxglitch: what puts people off is some of the machinery needed for full generality. i.e. the free monad machinery is built off of a bunch of general purpose bifunctor combinators, because that lets it work better with a couple of bifunctor recursion schemes
19:55:51 <edwardk> yeah
19:56:04 <edwardk> control.(co)monad.parameterized and control.(co)monad.indexed
19:56:15 <wavewave> edwardk: some time could you write Monad.Reader article on the usage of Comonad?
19:56:17 <edwardk> depending on if you want one parameter or two ;)
19:57:19 <edwardk> wavewave: not a bad idea. i committed to giving a talk on fingertrees and ropes next week some time for the boston haskell user group. i'm not sure if i'm going to cover the comonadic annotated rope stuff i've been writing
19:57:53 <syntaxglitch> edwardk, I was thinking of the two-parameter kind, where bind matches them up, looks like a cross between function composition and regular >>=
19:58:14 <syntaxglitch> lots of useful things that can be expressed that way
19:58:18 <edwardk> syntaxglitch: yeah that is the indexed kind http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Monad-Indexed.html
19:58:38 <edwardk> i never did add indexed writer, parameterized
19:58:39 <syntaxglitch> especially with a bit of cheating, i.e. GHC rebindable syntax
19:58:43 <edwardk> on a category
19:59:00 <edwardk> you can do nice stack machine stuff with that =)
19:59:50 <edwardk> dan piponi wrote up something, now that i think about it: http://blog.sigfpe.com/2009/02/beyond-monads.html
20:00:10 <edwardk> the problem with indexed monads is you can't compose them =(
20:00:15 <edwardk> they don't have pretty transformers
20:00:56 <dancor> maybe you can work with pairs and triples of them in some other way
20:00:57 <aavogt> normal monad transformers are pretty?
20:00:57 <syntaxglitch> edwardk, my favorite was something like an indexed version of State, where the extra parameters are the state type, with an HList stashed in there
20:01:06 <edwardk> yeah
20:01:16 <syntaxglitch> nice ad-hoc state stashing
20:01:33 <edwardk> aavogt: compared to trying to compose indexed monads, yes. ;)
20:01:34 <syntaxglitch> without having to pre-define everything you want to store
20:02:00 <aavogt> so like ST?
20:02:03 <edwardk> syntaxglitch: check out the stack operations in dan's write up =) but yeah state was the first time i tripped over the indexed monad idea
20:02:06 <aavogt> or is there a difference?
20:02:16 <edwardk> aavogt: no, you have two more parameters.
20:02:33 <edwardk> think newtype State s r a = State (s -> (a,r))
20:02:34 <syntaxglitch> edwardk, yeah, I think his post was where I first saw the idea actually
20:02:36 <aavogt> I mean in terms of how user code looks
20:02:42 <edwardk> its like the State monad when s = r
20:02:58 <edwardk> but you can change the type of the state if you want in a 'monadic' action that changes the index.
20:03:03 <edwardk> return leaves the index alone
20:03:07 <edwardk> but bind composes the changes
20:03:11 <syntaxglitch> aavogt, you mean the ad-hoc state thing I mentioned?
20:03:16 <aavogt> yes
20:03:30 <dolio> edwardk: Mightn't a T-indexed transformer of an S-indexed monad be T * S-indexed?
20:03:32 <edwardk> aavogt: ST just has one extra parameter
20:03:44 <syntaxglitch> then yeah, I guess so, except that it's in something much closer to State
20:03:47 <syntaxglitch> for whatever that's worth
20:03:50 <edwardk> dolio: i wasn't able to encode that you might have better luck than i
20:03:58 <aavogt> I suppose the difference between ST and syntaxglitch's stuff is that your state parameters can go out of scope in the same block
20:04:08 <dolio> edwardk: It's not something I'd expect to be able to do in Haskell.
20:04:26 <edwardk> syntaxglitch: you can take that and push tuples with the old state and your new layer, and get the 'hlist-effect' you want
20:04:51 <dolio> Since it doesn't have product kinds.
20:05:16 <edwardk> dolio: yeah, i tried GADT'ing my way through it and things blew up on me. it was a long time ago, i forget the details
20:05:22 <syntaxglitch> edwardk, hm? not sure what you mean
20:05:26 <aavogt> though with name shadowing you can make the STRef go away
20:06:26 <aavogt> reading things into hlists is interesting
20:06:35 <edwardk> syntaxglitch: push = do x <- get; put (x,x); --  pop = modify snd; top = gets fst
20:06:55 <edwardk> er push y = do x <- put (y,x)
20:07:28 <aavogt> ooh, never pop an empty stack
20:07:30 <edwardk> replace () and (,) with HNIL and HCons
20:07:31 <syntaxglitch> edwardk, that doesn't give me type-indexed lookup for the stashed values
20:07:49 <edwardk> and then you can look up the stashed miscellanea
20:08:00 <edwardk> its just a choice if index
20:08:25 <aavogt> syntaxglitch: that's just a question of the appropriate instances being written for (,) instead of HCons
20:08:38 <syntaxglitch> ah
20:08:46 <syntaxglitch> I actually wrote my own hlist-style stuff anyhow
20:09:07 <syntaxglitch> more minimalist
20:09:17 <aavogt> when you do it at the value-level it's so much more simple :(
20:09:29 <edwardk> i've been meaning to adapt a type level version of data.sequence i wrote to  do some hlist/oohaskell stuff, to see if its worth doing
20:09:34 <syntaxglitch> dunno, the core of hlist is pretty simple
20:10:01 <aavogt> syntaxglitch: what I mean is that the code to do the 'same' thing is 3x as long
20:10:05 <edwardk> main advantage is that record field access becomes o (log (min(n,l-n)) rather than o(n)
20:10:16 <aavogt> since functions -> classes, declarations -> instances
20:10:27 <syntaxglitch> I had some code I was working on with a tree-shaped equivalent of hlist
20:10:37 <edwardk> main downside is the 6 pages of code to just deal with append ;)
20:10:38 <syntaxglitch> aavogt, ah yeah, type programming is verbose :(
20:10:54 <syntaxglitch> which is why I'm working on a library for myself to make it easier
20:11:05 <syntaxglitch> nice prebuilt type-level maps, folds, etc.
20:11:17 <aavogt> conceptually it's simple, but the code shows otherwise
20:11:48 <edwardk> syntaxglitch: i have an old library of type level 16s complement arbitrary precision arithmetic, you're welcome to incorporate/update ;)
20:12:14 <syntaxglitch> edwardk, thanks, but that doesn't help with my current headache
20:12:35 <syntaxglitch> namely trying to shove some bare minimum of "type"-checking down GHC's throat
20:12:38 <edwardk> lots of type level naturals, but there are a general shortage of actual integers
20:12:53 <syntaxglitch> all this un"type"d type-level programming is annoying
20:13:03 <edwardk> i find that is a lot easier with fundeps than type families
20:13:12 <syntaxglitch> type families aren't really viable
20:13:12 <aavogt> at least you figure out the errors at compile-time though
20:13:36 <edwardk> with a MPTC i can say things like class (Boolean a, Boolean b, Boolean c) => And a b c
20:13:38 <syntaxglitch> there's a few places where you just can't get rid of overlapping instances :(
20:13:41 <edwardk> with a type family i can't =(
20:13:46 <syntaxglitch> mostly oleg's TypeEq
20:13:49 <syntaxglitch> can't live without that
20:13:51 <edwardk> yeah
20:14:10 <edwardk> you can't built hlist in type families
20:14:15 <aavogt> what's holding back overlapping instances with type families?
20:14:32 <edwardk> aavogt: you really need "closed type families"
20:14:51 <syntaxglitch> also, with my meta-type checking it helps to have lots of generic instances with unsatisfiable contexts that provide "friendly" errors
20:15:53 <syntaxglitch> aavogt, actually that's the annoying part, only for certain definitions of "compile-time"
20:15:55 <aavogt> yeah, that's a nice trick
20:16:08 <syntaxglitch> a lot of broken type-level code will be accepted at first
20:16:17 <syntaxglitch> and only cause errors when you try and use the result
20:16:24 <edwardk> i found that defining a type family (:<) a b :: * which answered if a value of type a had type b and TypeOf a  'type inference' family, that asked the type of a i could do everything i needed
20:16:46 <edwardk> so you have the two primitives of 'type inference' and 'type checking' as needed
20:17:08 <edwardk> which you can skillfully interlace and get the type machinery you need without too much boilerplate
20:17:29 <aavogt> syntaxglitch: hmm? Type level programs are simpler though
20:17:44 <Makoryu> Say...
20:17:50 <syntaxglitch> aavogt, not the ones I'm writing :(
20:17:55 <edwardk> but the correctness of the 'type of type' stuff is just convention, not anything very strong
20:18:02 <aavogt> I mean, there's no IO :)
20:18:20 <Makoryu> I was talking to someone the other day who very stubbornly refused to see the difference between type inference and dynamic typing
20:18:30 <edwardk> aavogt: i have type level programs with 100,000+ instances ;)
20:18:34 <Makoryu> Eventually gave up on explaining it to him
20:18:39 <edwardk> aavogt: and you can do IO, you just need to use TH ;)
20:18:42 <Makoryu> How would you guys demonstrate it clearly?
20:18:49 <syntaxglitch> edwardk, I'm trying to be a little pickier about it--checking things like the meta-type for a type-level fold
20:19:28 <edwardk> syntaxglitch: ultimately application like that breaks down without kind polymorphism as things become too complicated though
20:19:45 <edwardk> Makoryu: with a 2x4? =)
20:19:58 <Makoryu> Ôºà„ÄÄ‚âñ‚Äø‚âñÔºâ
20:20:02 <aavogt> Makoryu: change the type of a function (number or type of arguments) that is occasionally used in a project... see when you find out about calls to the changed function you forgot to update
20:20:28 <edwardk> Makoryu: type inference catches errors at _compile time_, dynamic typing catches it at runtime
20:20:31 <syntaxglitch> edwardk, it's actually working out okay for me so far, just slow going
20:20:38 <edwardk> after you've shipped it ;)
20:20:53 <edwardk> syntaxglitch: yeah i feel your pain =)
20:21:45 <aavogt> edwardk: what exactly do you have to calculate that takes 100,000+ instances?
20:22:17 <aavogt> this means at least 10,000 regular functions if it was a value-level program...
20:23:02 <Makoryu> aavogt, edwardk: I should mention that this was compounded by a very C++-centric understanding of operator overloading, and that I didn't have a whole lot of time to explain it, or anything to write down example code on
20:23:04 <aavogt> though each instance is more like a pattern match
20:23:11 <edwardk> aavogt: i have some machinery for generating unboxed versions of data types off of some pretty flexible instances that shuffles the instances around and packs them into a bounded number of unboxed ints, etc.
20:23:31 <Makoryu> Actually, hmmm
20:23:34 <edwardk> Makoryu: thats fine, just write out some code that won't typecheck, and ask if you want that crap to make it into production before it throws an error ;)
20:23:39 <syntaxglitch> edwardk, also, currying and partial application are kind of a headache
20:23:44 * Kaidelong is starting to think the problem might be with wxWidgets itself
20:24:04 <aavogt> so part of the verbosity is supporting tuples up to n length?
20:25:13 <edwardk> aavogt: another case is dealing with generating the bodies for things like big hex adders, exponentiators, etc which can have  a couple of thousand cases, in the case of the earlier 16s complement library i mentioned
20:25:29 <edwardk> aavogt: so each case in a case statement there corresponds to an instance
20:25:48 <edwardk> aavogt: i generated it all with TH, but its still a massive amount of generated code for the compiler to chew on
20:25:51 <aavogt> aha, hopefully some of that code is generated?
20:25:59 <edwardk> aavogt: yeah
20:26:31 <aavogt> TH makes it so easy to write code that makes for slow compiles
20:26:44 * syntaxglitch so far has type-level versions of [], Maybe, and Either, partial application of type functions, somewhat tedious meta-type checking, some simple functions like map, foldr, zipWith, etc., and a sort of "pattern matching" thing
20:26:50 <aavogt> well maybe not that easy, but the code is short
20:27:09 <edwardk> http://comonad.com/haskell/type-int/src/Data/Type/Binary/Internals.hs is the version i did by hand for binary arithmetic http://comonad.com/haskell/type-int/src/Data/Type/Hex/ is the staged 3 tier build for hexadecimal that i cobbled together to learn TH a few years back
20:27:37 <edwardk> the binary version you can get your head around ;)
20:28:31 <edwardk> the hex version is an exercise in the kind of annoying 'deep pidgin' that can develop when you only have a single author on a functional programming project and they are in a hurry ;)
20:29:17 <edwardk> nowadays i'd probably use a lot more quasiquotation and splicing
20:29:57 <syntaxglitch> edwardk, for comparison, here's an "increment" function from an old version of my library: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24980
20:30:18 <syntaxglitch> I've cut the verbosity down a lot since then
20:30:28 <edwardk> pretty at least
20:30:37 <edwardk> your naturals peano or base n?
20:30:55 <syntaxglitch> binary, it's a type-level list of bits
20:30:56 <aavogt> hmm, there's no hackage library for a Num class that does 'implicit' conversions
20:31:02 <edwardk> ok, you pass ;)
20:32:00 <edwardk> the lib there was basically the same thing with two 'zeros' T and F which I used to indicate an infinite tail of 1s or 0s
20:32:02 <syntaxglitch> most of the verbiage in that hpaste is actually just trying to implement a fold
20:32:09 <edwardk> that way pred can be total
20:32:23 <edwardk> and you get rid of a lot of the other warts with type level nats
20:32:36 <edwardk> easy trichotomy, total 3 way reversible addition, etc.
20:32:49 <syntaxglitch> but I ended up scrapping that version of the library anyway, since it had other problems :(
20:32:55 <edwardk> *nods*
20:33:24 <edwardk> i had a student last year who wanted to work with me on a type level programming library for the summer of code, but it didn't pass muster =/
20:33:38 <syntaxglitch> also, I was mostly intending nats to be used for recursion, not math
20:33:46 <edwardk> *nods*
20:34:11 <edwardk> i was just very happy when things like the full adder dropped out with perfect symmetry
20:34:33 <edwardk> infinite precision integers are actually quite pleasant to work with
20:34:45 * syntaxglitch nods
20:35:10 <edwardk> even if practical considerations limited the base 2 version to ~20 or so bits, and the base 16 version to ~70
20:35:17 <edwardk> (which is why i implemented the latter)
20:35:23 <edwardk> so i could use them for array bounds, etc)
20:35:49 <syntaxglitch> oh, and here's a snippet from the next version (also since scrapped) of the library: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24981
20:36:03 <syntaxglitch> the verbiage is a bit better, as you can see
20:36:14 <edwardk> yeah
20:36:28 <edwardk> thats starting to look like the toy type level programming lib sketched out last year
20:37:22 <syntaxglitch> to clarify, :@> is kind parameter application, :$> is type function application, and :<= evaluates a type function
20:37:35 <syntaxglitch> if that wasn't obvious
20:37:51 <edwardk> pretty much what i'd guessed
20:38:15 <edwardk> looks almost monadic, i like the style
20:38:26 <syntaxglitch> yeah, that was deliberate
20:38:43 <edwardk> how fare your efforts to work with higher order functions?
20:39:03 <edwardk> we ran into issues with higher order functions using higher order functions and REALLY wanted kind polymorphism ;)
20:39:36 <edwardk> but you can flatten a lot of that down by using an explicit application operator
20:39:45 <syntaxglitch> letting type variables into anything is no end of pain for me
20:40:13 <syntaxglitch> I use explicit kind parameters in many places, roughly inspired by what raw polymorphic lambda calculus looks like
20:40:23 <edwardk> yep
20:40:33 <edwardk> your Map, can you curry that?
20:40:40 <edwardk> or must you fully apply your functions?
20:41:10 <syntaxglitch> almost everything I use is either empty data nametags or binary data types, so there's little in the way of actual Haskell kinds to worry about; polymorphism has to be explicit
20:41:21 <syntaxglitch> they're curried, sort of
20:41:32 <syntaxglitch> they have to be fully applied before evaluation
20:41:43 <dibblego> @djinn (s -> a) -> (s -> b) -> s -> a -> b
20:41:43 <lambdabot> f _ a b _ = a b
20:42:12 <syntaxglitch> but I can tack arguments on with :$> bit by bit, and pass around the result just like a nametag for a type function
20:42:22 <edwardk> nice
20:42:28 <edwardk> so you went the flat route
20:42:39 <edwardk> so no higher kinds to muck around with
20:43:16 <syntaxglitch> if I ask it what the kind is of (Map :$> Not) it'll tell me (List :@> Boolean :-> List :@> Boolean), for instance
20:43:16 <edwardk> just the fake 'kind/type-type' typeclasses
20:43:21 <edwardk> yeah
20:43:55 <syntaxglitch> not being apply to evaluate partially applied type functions doesn't really lose much anyway
20:44:13 <syntaxglitch> since the result would have no meaning at term level
20:44:23 <edwardk> no, the worry was if partially applied type functions had higher kinded types, then the combinator set explodes
20:44:35 <edwardk> i.e. if you didn't use an explicit :$>
20:44:38 <syntaxglitch> ah, no
20:45:14 <syntaxglitch> I figured out very quickly that I needed to make everything the same kind and arity wherever possible
20:45:16 <edwardk> so when you use (:$>) does it always cons the argument into a tuple somehow?
20:45:22 <edwardk> or do you manually case each arg?
20:45:41 <syntaxglitch> uh, I don't recall how it worked in that snippet
20:45:48 <syntaxglitch> that part's kinda in flux in the new versions
20:46:21 <edwardk> ultimately i decided it wasn't that bad with a little bit of template haskell help ;)
20:46:58 <edwardk> you seem to have steered clear of that direction though
20:47:04 <syntaxglitch> though, at various points I was converting left-nested (:$>) into right-nested tuples
20:47:24 <syntaxglitch> and the other way around
20:47:31 <syntaxglitch> trying to juggle syntactic sugar
20:47:32 <edwardk> your tupled args for Map were reminiscent of that style
20:47:40 <edwardk> but without the base case
20:48:35 <cypher> does anyone know some open source app that could be a showcase for vector library?
20:48:45 <syntaxglitch> yeah, at that point I think was tuplifying the arguments somewhere between :<= and Apply
20:48:54 <Pseudonym> cypher, I don't understand the question.
20:48:57 <edwardk> sounds about right.
20:49:08 <edwardk> cypher: as in the vector library roman is hacking on?
20:49:43 <cypher> Pseudonym: as in something that shows that vector is good and allows you to write programs in a nice and abstract way and under the hood fusion makes them "smoking fast", as dons called it on his blog
20:49:48 <edwardk> cypher don't the statistics libs/criterion/etc use it?
20:50:06 <edwardk> cypher: i'm starting to bolt on vector into my rope lib as well
20:50:16 <edwardk> but its hardly a showcase and isn't an end-user application yet ;)
20:50:50 <edwardk> cypher: some of us folks on #hnn have had good success with vector. tomberek used it to speed up a bunch of fgl code by 6-10x
20:50:52 <syntaxglitch> edwardk, here's another example: http://pastebin.com/iFQxj5m4
20:50:57 <cypher> edwardk: yeah, they do, but they're not very good for my purpose ;)
20:51:30 <edwardk> syntaxglitch: nice
20:51:34 <syntaxglitch> along with a subtle illustration of why I decided that the tuplifying was a bad idea
20:51:49 <edwardk> syntaxglitch: heh
20:52:05 <edwardk> its not THAT bad
20:52:39 <syntaxglitch> except that it's impossible to untuplify the arguments to RunChoice
20:53:00 <syntaxglitch> because the representation of Choice uses a tuple itself
20:53:26 <edwardk> you need to use a distinguished type or mark the contents, more boilerplate, but not insurmountable
20:53:40 <syntaxglitch> I am, in the new version
20:53:42 <edwardk> (Elem f, (Elem g (Elem (This, x)))
20:53:51 <edwardk> or  what have you
20:54:11 <syntaxglitch> I decided that tuples were too important to the concrete representation to steal for syntax
20:54:16 <edwardk> yeah
20:54:25 <edwardk> :*: or something it is ;)
20:55:01 <edwardk> i like the choice of :$> :@> and :<= they grow on me =)
20:55:12 <syntaxglitch> Right now I'm working on a concise way to define a "GADK" along with its constructor signatures and concrete representations
20:55:33 <edwardk> you're not going to like the answer -- it involves category theory ;)
20:56:06 <syntaxglitch> currently undecided whether I want to insist that concrete representations be globally unique, or only unique given some kind specification
20:56:21 <edwardk> neil ghani and patricia johann did the construction of gadts using initial algebra semantics, the same machinery can be applied at the type level
20:56:48 <edwardk> but Mu and Nu don't unify up there in the kind of setting you're using, so you have to be careful
20:57:35 <syntaxglitch> the main difficulty is extracting as much information as possible from as little code as possible, in a form that I can use for faux-kind-checking, etc.
20:57:44 <edwardk> *nods*
20:58:00 <syntaxglitch> the limiting factor being what I can get away with in terms of overlapping instances and such, I think :\
20:58:05 <edwardk> i think if you stick to regular "ADT"s you'll be fine
20:58:29 <edwardk> and limiting your dependency on overlapping instances to the occasional judicious use of TypeEq
20:59:18 <syntaxglitch> as long as client code can define a data kinds, type functions, and use them without needing overlapping or undecidable instances, I'm happy
20:59:41 <edwardk> SPJ is going to be out here at northeastern tomorrow. playing hooky from work to go to the seminar
20:59:49 <syntaxglitch> fun
20:59:55 <edwardk> yeah
21:00:52 <syntaxglitch> by the way, got a reference for that gadt construction? might actually give me some inspiration...
21:01:58 <edwardk> initial algebra semantics is enough
21:02:14 <edwardk> and there is a followup paper or 3 on patricia johann's website
21:02:21 <edwardk> all the links from neil ghani's site are broken
21:02:53 <edwardk> feel free to ask questions about the papers, i slept with them under my pillow for a while ;)
21:03:05 <cypher> edwardk: playing hooky by using a volcano?
21:03:50 <cypher> it's not that he can get to work in this mess
21:03:50 <dolio> edwardk: http://code.haskell.org/~dolio/agda-share/html/IndexedMonad.html
21:03:55 <edwardk> cypher: if you follow Lost: http://cleolinda.livejournal.com/876719.html?thread=52508079#t52508079
21:04:10 * cypher wonders if this qualifies as paid holiday
21:04:15 <edwardk> dolio: cute =)
21:04:17 <cypher> what's Lost?
21:04:22 <syntaxglitch> haha, I forgot about that--SPJ is trapped in north america, eh
21:04:34 <edwardk> cypher: tv show
21:05:05 <cypher> ah, yeah, I've heard of it.. it used to be popular a year ago IIRC
21:05:06 * syntaxglitch has already been reading about some adventures of stranded academics courtesy of Language Log
21:05:11 <edwardk> dolio: they/you need more indexed monads ;)
21:05:42 <dolio> Well, it's a proof of concept.
21:05:53 <cypher> syntaxglitch: the holiday at my uni is just about finished and lots of people (students and academics alike) can't get here
21:06:03 <dolio> I only know of a couple others.
21:06:09 <cypher> so they shuffle the exams and so on ;)
21:06:59 <syntaxglitch> edwardk, anyway thanks for the references, I'll give it a read tomorrow hopefully
21:07:26 <syntaxglitch> I'm in the middle of moving to a new apartment, so time for recreational type hackery and reading is limited :(
21:07:39 <edwardk> syntaxglitch: be warned you may need to backtrack a bit. also i have a bunch of blog articles on kan extensions that may be useful when they come up in the papers
21:07:57 * cypher learns about a cambridge software company that gives ipads to people who come for interviews
21:08:02 <cypher> O_o
21:08:21 <syntaxglitch> edwardk, I've read your blog articles actually, but they didn't really stick :(
21:10:08 * syntaxglitch has no formal background in anything remotely like category theory, but is slowly picking up enough of it to get by
21:10:17 <edwardk> syntaxglitch: i'm generally done in by my lack of examples =/
21:10:39 <ray> only in #haskell is category theory mainstream enough that people would think you can have a formal background in it
21:10:54 <syntaxglitch> edwardk, not everyone can be sigfpe I'm afraid
21:10:54 <lpsmith> yeah,  examples help me a lot
21:11:31 <lpsmith> I'm definitely better talking about concrete things than abstract,  though with time i can work my way up the abstraction heirarchy
21:12:03 <mail> concrete is so boring
21:12:11 <mail> grey and stuff
21:12:29 <syntaxglitch> the problem is that with abstract concepts it's easy for examples to actually make things worse
21:13:08 <syntaxglitch> one of my pet peeves is "explaining" abstract ideas in a way that conflates the idea itself with concrete examples of it
21:13:33 <ray> monads are kfc double down sandwiches
21:13:48 <cypher> mhhm
21:13:49 <cypher> food
21:13:52 <lpsmith> syntaxglitch, there is that risk, yes
21:13:53 <tensorpudding> sounds disgusting
21:14:03 <lpsmith> But say you want to explain what a monad is, or what a group is
21:14:10 <cypher> not if you're really hungry
21:14:10 <syntaxglitch> which usually leads into a rant about functors not being containers, monads not being about sequencing, and monoids not being about appending no matter what the stupid Prelude says
21:14:27 <mail> kfc double down?
21:14:31 <lpsmith> It helps a lot to have a good understanding of at least three monads and at least three groups to help motivate things
21:14:35 <lpsmith> (at least for myself)
21:14:44 <cypher> syntaxglitch: I like to ask what monads are, because it's amusing what kind of answers you get
21:15:15 <cypher> syntaxglitch: most of them are really irrelevant to what you use monads for in Haskell
21:15:18 <mail> screw monads just watch fresh prince of bel air
21:15:18 <syntaxglitch> lpsmith, there's a fine line between showing concrete examples and generalizing from them, vs. conflating the examples with the abstraction itself
21:15:33 <dankna> "A monad is like a bad metaphor for what monads are.  >>= combines one metaphor with another and return adds another layer of abstraction."
21:15:36 <dankna> -- someone in here
21:15:45 <cypher> ;-) good one
21:15:48 <dankna> yeah :)
21:15:48 <mail> tis what i did instead of learning about PDA's
21:15:53 <cypher> I had this interview once
21:15:57 <cypher> and I'm aske what is a monad
21:16:03 <dankna> yeah?
21:16:05 <aavogt> lpsmith: exactly, if your typeclass only has one instance ever, it shouldn't be generalized
21:16:12 <cypher> so I use the long-established def "monads are just monoids.."
21:16:24 <dankna> right
21:16:24 <cypher> and the interviewer says "huh?"
21:16:32 <dankna> haha
21:16:33 <syntaxglitch> cypher, I usually just quote that "brief, incomplete, and mostly wrong history of programming languages" as my preferred nonexplanation of monads
21:16:39 <cypher> so I'm saying, that's just about as useful as any other definition ;-)
21:16:47 <tensorpudding> if you don't know what monoids are, how can you expect to know what monads are?
21:17:02 <lpsmith> syntaxglitch, well,  a well chosen monoid examples would dispel common misconceptions,  such as being about appending
21:17:18 <syntaxglitch> lpsmith, yeah
21:17:30 <cypher> the funny thing is that having done enough CT that def. makes perfect sense and knowing that monad is a monoid make monadic laws obvious (even if broken by the assymetry), but in the end, for a working programmer, none of this matters ;)
21:17:31 <aavogt> which ones aren't appending? First?
21:17:58 <dolio> +, *, min, max...
21:18:01 <syntaxglitch> cypher, the other good answer is "a burrito"
21:18:12 <lpsmith> well,   the set of integers and * are a monoid
21:18:14 <tensorpudding> A Haskell programmer doesn't need to know monads, just needs to know Monad
21:18:18 <cypher> the only good that may come from asking such question is perhaps that you can distinguish between mathsy-inclined programmers and working programmers (I guess)
21:18:19 <tensorpudding> and there is a difference
21:18:21 <syntaxglitch> which monoids ARE appending in any reasonable sense, besides []?
21:18:23 <lpsmith> yeah,  +, min, max too :)
21:18:29 <edwardk> cypher: actually they are only asymmetric in haskell's notation, they are perfectly symmetric when you use the kleisli composition operator
21:18:37 <aavogt> syntaxglitch: endofunctions
21:18:41 <cypher> edwardk: true
21:18:44 <edwardk> (f >=> g) >=> h = f >=> (g >=> h)
21:18:48 <aavogt> or whatever Endo abbreviates
21:19:07 <syntaxglitch> aavogt, okay, I'll buy that one
21:19:07 <cypher> yeah, or if you define monadic composition, then you can re-state them
21:19:10 <edwardk> and return >=> a = a >=> return = a
21:19:16 <lpsmith> edwardk, agreed:  kleisli composition makes the monad laws much easier to remember
21:19:20 <cypher> but for most part.. who cares?
21:19:36 <cypher> only people who care about maths
21:19:45 <cypher> and perhaps like maths enough to investigate
21:19:59 <lpsmith> Once I saw that I pretty much forgot about the monad laws in terms of return and bind,  and re-derive them from kliesi composition and eta-reduction if I need to
21:20:34 <cypher> IMO that's a good differential between certain very different kinds of people
21:20:43 <cypher> lpsmith: yeah, just make the types match ;-)
21:20:47 <mail> so eh what are monads?
21:20:51 <cypher> mangle a bit and it's done
21:21:00 <lpsmith> mail:  a monad is a burrito
21:21:04 <lpsmith> ;-)
21:21:11 <edwardk> AND a space suit
21:21:18 <cypher> an abstract concept, like sleep
21:21:20 <aavogt> you should curry your monads a bit.. call them triads
21:21:23 <syntaxglitch> it's an endospacesuit on a burrito category
21:21:48 <edwardk> preferably you choose to use it as a space suit before your friend treats it like a burrito or those can be some of the worst space walk hours you'll ever log.
21:21:56 <lpsmith> @remember syntaxglitch a monad is an endospacesuit on a burrito category
21:21:56 <lambdabot> I will never forget.
21:22:51 <syntaxglitch> actually that should probably be burrito on an endospacesuit category but oh well :(
21:22:59 <edwardk> aavogt: that sounds like a gastronomic disaster waiting to happen
21:23:17 <syntaxglitch> sounds better the other way even if it makes less sense
21:23:25 <lpsmith> what about a endoburrito on a spacesuit category?
21:24:35 <aavogt> endoburritos sound awkward... consume and produce the same thing?
21:25:22 <lpsmith> cypher, I am curious where you were interviewing to get asked about monads :)
21:25:35 * aavogt too
21:25:42 <syntaxglitch> lpsmith, well, assuming it's supposed to be mangling an actual definition, the endofoo needs to describe the category, not the object in it
21:25:52 <edwardk> aavogt: so endoburrito = burrito ;)
21:26:00 <cypher> lpsmith: more than one place actually
21:26:12 <syntaxglitch> but I'm not going to get too picky, under the circumstances
21:26:27 <aavogt> edwardk: not the burritos I eat :)
21:29:13 <edwardk> must ... resist ... the ... lure ... of ... git-hub.
21:30:01 <tensorpudding> the git kool-aid is tasty.
21:30:34 <cypher> what is this thing about "drinking the same kool-aid"?
21:30:50 <Gracenotes> I've signed up for a free git provider (500MB space). Seems to be working out.
21:30:50 <cypher> I've heard this expression few times in some strange contexts, what's its origin?
21:30:57 <lpsmith> cypher:  it's a reference to the jonestown cult
21:31:11 <Gracenotes> well, the first one didn't work out. paypal swallowed my money and, meh.
21:31:13 * cypher still doesn't get it.. some American thing?
21:31:21 <lpsmith> Which committed mass suicide by poisoning the kool-aid
21:31:21 <syntaxglitch> specifically, to the cult committing mass-suicide by drinking poisoned kool-aid
21:31:22 <tensorpudding> Yeah, in Jonestown they committed suicide by drinking cyanide-laced Kool-Aid or somesuch
21:31:35 <cypher> cool
21:31:38 <cypher> ;-)
21:31:47 <lpsmith> After killing a congressman who flew in to investigate the cult, among other things
21:31:48 * Gracenotes puts a "notable" sticker on the phrase. http://en.wikipedia.org/wiki/Drinking_the_Kool-Aid
21:31:57 <tensorpudding> Usually the reference to kool-aid has a negative connotation.
21:32:12 <lpsmith> Unless it's kool-aid man
21:32:15 <syntaxglitch> OH YEAH!
21:32:18 <cypher> I see
21:32:18 <syntaxglitch> ...sorry
21:32:21 <lpsmith> :)
21:32:24 <tensorpudding> Lots of references to Steve Jobs and drinking the Apple Kool-Aid.
21:32:26 <cypher> yeah, family guy kind of joke
21:32:42 <lpsmith> robot chicken too
21:32:45 <cypher> ok, I'd better catch some sleep
21:32:45 <cypher> nite
21:32:51 <Gracenotes> well, kool-aid bursting through walls is from kool-aid itself
21:32:53 <lpsmith> g'night!
21:33:09 <Gracenotes> *waves*
21:33:34 <lpsmith> well, yes, but robot chicken and family likes draws on pop culture things like that from 15-30 years ago
21:33:41 <Gracenotes> it also means the kool-aid man has a contingency escape plan from any room
21:33:43 <lpsmith> err, family guy
21:34:18 <syntaxglitch> Gracenotes, it also means you can never escape him
21:34:25 <syntaxglitch> no wall can stop him if he comes for you
21:35:23 <syntaxglitch> ugh, I need to get some sleep
21:35:47 <tensorpudding> anyway, what's the issue with github?
21:36:49 <edwardk> tensorpudding: mostly that i have to give up darcs to use it ;)
21:37:10 <tensorpudding> That's the point of github, that you use git.
21:37:12 <syntaxglitch> could just write a darcs->git bridge of some sort
21:37:18 <syntaxglitch> that sounds like a reasonable solution
21:37:31 <edwardk> syntaxglitch: i'll wait and see how iolaus pans out
21:37:48 <tensorpudding> iolaus?
21:38:02 <lpsmith> David Roundy's porcelain for git
21:38:14 <edwardk> http://github.com/droundy/iolaus
21:38:30 <edwardk> well, at least git chooses a suitable name for its front ends ;)
21:38:37 <syntaxglitch> at any rate, yeah, sleep time I think
21:38:52 <syntaxglitch> edwardk, want me to drop you a line when my type programming library is in better shape?
21:39:53 <edwardk> syntaxglitch: sounds good to me. if you throw it up on a public repo i might even toss a patch or three your way ;)
21:39:54 <syntaxglitch> hadn't really decided if I was going to try and tidy it up for release or just use it myself, but getting input on how it looks would be appreciated
21:40:10 <syntaxglitch> it's not really in any sort of workable form right now, though
21:40:17 <aavogt> syntaxglitch: I'd be interested too
21:40:21 <greedo> http://pastebin.com/sx3anqK2
21:40:23 <edwardk> if you don't i'll just write one and take all the credit, so its now in your rational self-interest to see it to completion ;)
21:40:28 <greedo> why is this wrong?
21:40:44 <syntaxglitch> since I keep scrapping it and rewriting the faux-kind-checking code, sigh
21:41:19 <aavogt> greedo: you aren't allowed -> in patterns
21:41:21 <tensorpudding> I have tons of repos in a variety of different scm's, though the code I write is all in git.
21:41:29 <edwardk> syntaxglitch: i do the same with every version of a type level meta programming library that i put together that involves class associated types in any depth, which is one reason why i backed off and started using fundeps more again ;)
21:41:34 <greedo> dang
21:41:57 <aavogt> at least if you don't enable view patterns
21:42:00 <syntaxglitch> okay, well, hopefully in a couple of weeks once I'm done moving into the new apartment I'll find a public repo for it
21:42:39 <syntaxglitch> since my free time is kinda limited right now :(
21:42:43 <aavogt> in which case you can write:   safeTail x@ (length -> l) | l > 0 = tail x | otherwise = []
21:43:11 * Axman6 prefers drop 1
21:43:12 <aavogt> but in your case, it's probably best just to pattern match on actual constructors, greedo
21:43:32 <aavogt> Axman6: that's non-obvious though
21:43:40 * aavogt does it too
21:43:48 <greedo> this is just practice
21:44:37 <greedo> so @ allows ->
21:44:42 <aavogt> no
21:45:16 * syntaxglitch heads to sleep now
21:45:20 <aavogt>   name @ patter   allows binding name to whatever patter matches with
21:45:36 <greedo> >:t @
21:45:39 <aavogt> -XViewPatterns allows putting functions in patterns
21:45:47 <aavogt> it's syntax, not a function
21:47:57 <aavogt> > case "hello" of everything @ (x:xs) -> (everything,x,xs)
21:47:58 <lambdabot>   ("hello",'h',"ello")
21:47:58 <greedo> so can i still do that lamba expression?
21:48:24 <greedo> ah i see
21:48:31 <greedo> cool
21:50:04 <aavogt> and with -XViewPatterns, you can put (f -> pattern) to pattern match on the results of function applied to whatever the value would have been, if you named a variable for what's in the surrounding parens
21:50:35 <pickles1> quick question
21:50:42 <aavogt> quick answer
21:50:46 <pickles1> hoorya
21:50:47 * Axman6 thought that was a statement
21:50:53 <pickles1> ok, i have a list of lists
21:51:00 <pickles1> and want to take the inner lists out of their list wrappers
21:51:04 <pickles1> and just end up w/ a final list
21:51:08 <pickles1> i kno there's a function for that
21:51:12 <pickles1> but foret what it's called
21:51:15 <Axman6> so... something of type [[a]] -> [a]?
21:51:15 <pickles1> *forget
21:51:18 <pickles1> yeah
21:51:21 <aavogt> @hoogle [[a]] -> [a]
21:51:21 <lambdabot> Prelude concat :: [[a]] -> [a]
21:51:21 <lambdabot> Data.List concat :: [[a]] -> [a]
21:51:22 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
21:51:31 <pickles1> ah, concat
21:51:34 <pickles1> htat'll do it
21:51:44 <pickles1> (i really need to learn lambdabot one of these days)
21:51:50 <pickles1> thx guys!
21:52:00 <aavogt> hoogle has a nice web interface
21:52:20 <pickles1> url?
21:52:34 <aavogt> it's linked from http://haskell.org
21:52:41 <pickles1> cool, thx
21:52:54 <pickles1> (i suppose i could have just googled it... im sleepy :) )
21:53:21 <pickles1> thx again guys
21:53:24 <pickles1> nite
22:27:03 <pastorn> @pl (\x y k -> square' x (\sqx -> square' y (\sqy -> add' sqx sqy k)))
22:27:03 <lambdabot> (. ((. flip (flip . add')) . (.) . square')) . (.) . square'
23:20:23 <Resbaloso> It is time to put those Haitian jigaboos in their place!  No matter how many times the civilized world donates money, opens schools, rebuilds their nation, and holds their little monkey paws, the damn niggers can never get it right.  Mexicali had a worse earthquake than Haiti, and only about 4 people died!  Even the housing of the poor generally held up! Meanwhile even the Haitian elites couldn't buil
23:20:24 <Resbaloso> d decent buildings.  Look at what happened to the house of their monkey president!  If you are sick of the fecal beast Join Chimpout Forum!
23:20:43 <pikhq> Thou art a failure of a human being, m'thinkst.
23:21:00 <Resbaloso> vete a la verge puto
23:22:02 <jbapple> Any mods around?
23:22:46 <tensorpudding> @where ops
23:22:46 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
23:23:49 <DigitalKiwi> freenode staff will k-line it if you tell them
23:24:04 <Resbaloso> so what
23:24:13 <Resbaloso> ya difundÌ mi mensaje
23:24:17 <Resbaloso> jajaja
23:24:21 --- mode: ChanServ set +o allbery_b
23:24:38 <jbapple> What is k-line?
23:24:51 <DigitalKiwi> kicks them off the whole network
23:24:57 --- mode: allbery_b set +b *!*@189.220.21.241.cable.dyn.cableonline.com.mx
23:24:57 --- kick: Resbaloso was kicked by allbery_b (Resbaloso)
23:25:00 <DigitalKiwi> on freenode a k-line is like a g-line on other networks
23:25:13 <DigitalKiwi> global ban essentially
23:25:16 * allbery_b is slow (and half asleep), sorry
23:25:24 --- mode: allbery_b set -o allbery_b
23:25:58 <DigitalKiwi> (on other networks a k-line is not usually for all servers in the network but only the one it is joined on)
23:28:29 <DigitalKiwi> anyway k-line actually stands for kill not kick but whatever
23:29:14 <DigitalKiwi> http://en.wikipedia.org/wiki/K-line#K-line
23:29:50 * hackagebot gloss-examples 1.0.1.0 - Examples using the gloss library  http://hackage.haskell.org/package/gloss-examples-1.0.1.0 (BenLippmeier)
23:51:47 <jarick> Hi. Anyone used Network.Pcap? The implementation has a callback of type PktHdr -> ByteString -> IO (), which gets one packet at a time. I wish to coalesce multiple packets together, perhaps in a Sequence, and process that.
23:52:10 <bitstream0101> Is there a built-in way to filter -prof output to exclude certain modules from showing up?  I'm trying to profile my own code but the .prof file is cluttered by other modules and they're also showing up in the "top cost centres" portion as well.
23:59:29 <jarick> Never mind. Got it. I shall pass a Data.IORef from main
