00:00:32 <kmc> lars9, you can't really
00:00:42 <tensorpudding> you don't have to ['w','r','i','t','e',' ','l','i','k','e',' ','t','h','i','s']
00:00:48 <lars9> i see
00:00:51 <kmc> lars9, the definition of IO that lambdabot just gave you is serious internal GHC magic
00:00:58 <kmc> you're supposed to treat IO as an opaque type
00:01:14 <kmc> no visible constructor; you only get values with the IO primitives like putChar and the action combining functions like (>>=)
00:01:34 <kmc> tensorpudding, yeah, String has sugar
00:01:36 <kmc> as does []
00:01:40 <kmc> String is more sugary
00:01:44 <tensorpudding> Very few things have sugar
00:02:30 <tensorpudding> very few types*
00:02:37 <tensorpudding> The numeric types, String, Char
00:03:01 <kmc> "(Num a) => a" has sugar
00:03:10 <kmc> not individual numeric types
00:03:12 <kmc> to be super-pedantic ;P
00:03:32 <kmc> Char has syntax, yeah.  it's not shorthand for something else
00:03:46 <tensorpudding> Hmm.
00:04:07 <edwardk> off to get some sleep before climbing on a plane. see you guys next week
00:04:07 <kmc> or maybe it is shorthand for (toEnum 12345)
00:04:16 <tensorpudding> Is Data.Word some sort of veneer over machine integers implemented in C?
00:04:22 <kmc> edwardk, enjoy and safe travels
00:04:36 <kmc> tensorpudding, in GHC, yes
00:04:43 <kmc> well i don't know about "implemented in C"
00:04:46 <edwardk> kmc: thx
00:04:51 <kmc> but the thing inside a Data.Word box is an unboxed machine int
00:04:55 <kmc> interpreted in an unsigned way
00:05:03 <kmc> unlike Int which is signed (but isomorphic repr)
00:05:38 <dolio> Word is a wrapper around Word#
00:05:40 <tensorpudding> Is Int32 guaranteed to have 32-bit range?
00:05:54 <dolio> Which is an unsigned machine integer.
00:05:55 <c_wraith> yes.  that's the reason it exists
00:05:58 <pastorn> tensorpudding: isn't the first bit the sign?
00:06:13 <c_wraith> Int32 is signed, Word32 is unsigned
00:06:16 <tensorpudding> I should have said, guaranteed to have 32-bit size
00:06:58 <tensorpudding> I was under the impression that Int, on a 32-bit system, might have a size bigger than 32-bits, but never less.
00:07:32 <dolio> Int always has at least 30 bits. That's the only thing the report guarantees.
00:07:58 <pastorn> dolio: hm... that seems weird
00:08:11 <pastorn> i'd guess is that 30 number bits?
00:08:22 <dolio> It allows implementations to have 2 tag bits.
00:08:28 <dolio> Assuming a 32-bit system.
00:08:30 <pastorn> or 29 number bits + 1 sign bit
00:08:51 <pastorn> dolio: when would you want tag bits on an Int?
00:08:53 <tensorpudding> But on 64-bit systems, Int might have a larger range.
00:09:02 <dolio> It guarantees a range of -2^29 to 2^29-1.
00:09:18 <dolio> On 64 bit systems, GHC will use 64 bits for Int.
00:09:23 <blackdog> pastorn: you might want to tag pointers, for instance
00:09:32 <pastorn> blackdog: true
00:10:07 <blackdog> ghc uses unlifted types for that sort of thing, i think, rather than relying on runtime tags
00:10:09 <dolio> pastorn: It allows you to distinguish whether something is an Int versus a pointer by looking only at the value (say, if you're doing garbage collection).
00:10:16 <blackdog> but it's pretty common in dynamic languages
00:10:39 <pastorn> blackdog: what is? tag bits?
00:10:46 <dolio> GHC doesn't need to do that because it knows statically which things are Ints and boxed and such, but it's not an uncommon technique.
00:11:02 <kmc> it's used by ocamlc iirc
00:11:14 <kmc> the "tagless" in STG machine means not using these things
00:11:25 <kmc> it means a lot of care when building e.g. closures and stacks
00:11:31 <kmc> to make sure it's structurally know which values are pointers
00:11:34 <c_wraith> I thought GHC did use tags
00:11:44 <dolio> It uses tags for different things now.
00:11:49 <c_wraith> I thought STG was spineless tagged g-machine.  >_>
00:12:05 <c_wraith> clearly if I'm remembering it backwards, there's an issue :)
00:12:08 <kmc> heh, that's like MIPS
00:12:16 <kmc> "Microprocessor without Interlocking Pipeline Stages"
00:12:21 <dolio> The T in STG is tagless.
00:12:24 <blackdog> c_wraith: i think they're both -less :)
00:12:33 <kmc> what does GHC use tags for?
00:12:37 <tensorpudding> I thought MIPS was a reference to "millions of instructions per second"
00:13:24 <dolio> kmc: As I recall, they somewhat recently added tracking for whether things are evaluated, and possibly what constructor it evaluated to using extra bits in the pointer.
00:13:27 <solrize> i thought ghc switched to using tags not that long ago and got a performance boost.  it uses tags because of polymorphism, to avoid having to totally specialize
00:13:49 <lars9> is 'let' just a sugar?
00:14:10 <lars9> only a text substitution?
00:14:27 <c_wraith> lars9: for the most part.  if it pattern matches in the binding, there's an implicit case
00:14:42 <kmc> lars9, no.  in particular, in «let x = e in .... x .... x ....», the work of evaluating x is done at most once
00:14:49 <kmc> let establishes sharing
00:15:15 <kmc> and is usually treated as the fundamental way that computation is deferred until needed (the way that lazy "thunks" are created)
00:15:26 <kmc> and "case" is treated as the fundamental way that computation is forced to occur
00:15:28 <lars9> in the x ... x ... x case, if no using let, x is evaluated 3 times?
00:15:39 <kmc> lars9, well, what's x?
00:15:43 <kmc> if it's a complicated expression, yes
00:15:48 <kmc> > (2+3, 2+3, 2+3)
00:15:48 <lambdabot>   (5,5,5)
00:15:50 <c_wraith> let doesn't *have* to introduce sharing.
00:15:52 <kmc> ^^^^ does the addition three times
00:15:56 <kmc> > let x = 2+3 in (x, x, x)
00:15:57 <lambdabot>   (5,5,5)
00:15:59 <kmc> ^^^^ does the addition once
00:16:00 <c_wraith> It just happens to be simpler to implement it so it does
00:16:19 <kmc> yeah, i think the standard is oddly silent on these operational details
00:18:10 <lars9> i see
00:18:43 <dolio> Well, it's that way so that it doesn't mandate lazy evaluation.
00:19:21 <solrize> CSE in lazy evaluation can cause space leaks iirc
00:19:33 <dolio> Yes.
00:21:24 <dolio> Powerset (list) is an easy example.
01:01:55 <hiredman> , (read-string (binding [*print-dup* true] (pr-str (struct (create-struct :a :b) 1 2))))
01:02:00 <hiredman> er
01:02:05 <hiredman> pardon me
01:05:15 <Dari[work]> Hi
01:05:27 <Dari[work]> I'm trying to install ghc
01:05:34 <Dari[work]> I mean build and install
01:05:39 <Dari[work]> On Fedora/x86
01:05:42 <Dari[work]> Without root
01:06:01 <Dari[work]> And it epicly fails with "Can't work out build platform"
01:06:16 <kmc> Dari[work], do you have some version of GHC already?
01:06:20 <Dari[work]> Nope
01:06:23 <Dari[work]> That's the problem
01:06:25 <kmc> you need GHC to build GHC (i don't think another Haskell compiler will do)
01:06:28 <kmc> you can get GHC binaries
01:06:37 <Dari[work]> How can i get a binary?
01:06:44 <kmc> the easiest would be to get a binary of the whole Haskell Platform
01:06:49 <Dari[work]> Indeed
01:06:52 <kmc> http://hackage.haskell.org/platform/linux.html
01:07:30 <kmc> not sure where to download the actual RPM
01:07:38 <kmc> but there's a link for GHC binaries on that page
01:08:27 <Dari[work]> Okay
01:08:32 <Dari[work]> I'm gonna give it a try
01:08:40 <Dari[work]> Thanks :)
01:14:41 <Keal> Anyone know the maths involved for calculating the angle subterranian termites build tubes at relative to a heat source?
01:15:18 <pastorn> Keal: yes, i know it all
01:15:27 <pastorn> but i also know it's your homework, so i won't help
01:15:43 <sinelaw> howdy
01:15:58 <Keal> It isn't homework, I just have termites in my house and wish to predict future tunneling.
01:16:57 <pastorn> check your local university librarys catalogues
01:17:09 <Keal> I have no idea what that means.
01:17:18 <pastorn> there's probably some biologist somewhere who's gotten a phd studying this
01:28:21 <lars9> how do you use haskell in your big or small tasks?
01:28:37 <quicksilver> skillfully?
01:29:10 <lars9> hmm... i mean what kind of task do you use haskell for?
01:31:22 <roconnor> I use it for portfolio optimization
01:31:27 <Itkovian> lars9: scripting, processing results, ... anything for which I will need to know what the heck it did in a few years time, and thus like to have types to help me regrok it later.
01:31:33 <lars9> i'm using python for small tasks, such as shell scripting, text processing, web crawling, Is haskell as good as python in such tasks?
01:31:33 <kmc> it really shines for implementing languages, e.g. domain-specific stuff
01:32:02 <Itkovian> kmc: yeah, for example, for generating Objective-C :-)
01:32:06 <kmc> haha
01:32:18 <roconnor> lars9: haskell is better at that than python of course!
01:32:42 <arcatan> @faq can Haskell replace Python for small tasks?
01:32:43 <lambdabot> The answer is: Yes! Haskell can do that.
01:33:00 <arcatan> I use Haskell for solving Project Euler problems
01:33:18 <Itkovian> As most general purpose languages, you can use it for anything
01:33:28 <hpaste>  Clusters (falbani)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24847
01:33:47 <lars9> is there any everyday-task-oriented haskell tutorial?
01:33:56 <roconnor> @where lyah
01:33:56 <lambdabot> http://www.learnyouahaskell.com/
01:34:01 <roconnor> lars9: ^^
01:34:05 <kmc> @where RWH
01:34:05 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
01:34:11 <kmc> those are the two tutorials people recommend
01:34:17 <quicksilver> OMG, we can has hpaste bot?
01:34:36 <roconnor> quicksilver: this seems like a bad idea
01:35:02 <quicksilver> works OK in other channels I frequent; and provides a useful service.
01:35:17 <lars9> i know RWH, let me check LYH
01:35:19 <kmc> i've used Haskell for implementing compilers, interpreters, debuggers, swarm agent simulation, bioinformatics analysis, computer graphics
01:35:43 <lars9> kmc cool!
01:36:38 <lars9> kmc: compiler, bioinfo, graph, these are so different areas
01:36:45 <tensorpudding> haskell doesn't have much marketshare in desktop apps though
01:36:46 <lars9> and you work on them all?
01:36:52 <roconnor> quicksilver: we've had an hpaste bot in the past here.  I thought people complained it was too noisy
01:37:09 <hpaste>  . (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24848
01:37:15 <quicksilver> I don't remember any complaints back then
01:37:17 <roconnor> tensorpudding: is the haskell desktop apps share proportional to the number of haskell developers?
01:37:31 <tensorpudding> Not sure.
01:37:32 <fatalerrorx> can someone help me with http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24848#a24848
01:37:36 <quicksilver> unless we suffer from spam, it just saves the paster the work for pasting the link.
01:37:40 <roconnor> quicksilver: ok.  Let's give it a go again
01:37:44 <Cale> I don't remember any complaints either. It just tended to get disconnected, and wouldn't reconnect until the web application was restarted.
01:37:58 <fatalerrorx> no idea what error it is
01:38:06 <quicksilver> fatalerrorx: nothing in that paste tells me what you need help with
01:38:16 <kmc> industrially it's used for things like hardware design, cryptography, generating embedded systems code, bioinformatics, AI, financial analysis, web applications, automatic code refactoring
01:38:21 <quicksilver> fatalerrorx: if there is an error message perhaps you should paste that too?
01:38:22 <tensorpudding> I suppose if you count XMonad, I can only think of one desktop app written in Haskell
01:38:27 <fatalerrorx> quicksilver: won't compile
01:38:36 <kmc> tensorpudding, yes, it's a bit of a visibility problem for us
01:38:38 <Cale> fatalerrorx: tabs
01:38:41 <roconnor> tensorpudding: have you checked out hackage?
01:38:52 <fatalerrorx> Cale: :)
01:38:55 <tensorpudding> I'm sure that hackage has some that I've never heard of.
01:38:56 <Cale> fatalerrorx: ensure that your text editor is set to convert tabs to spaces
01:39:04 <tensorpudding> But I doubt that people outside of Haskell have heard of them.
01:41:10 <kmc> people are adding to the Haskell in Industry page all the time
01:42:05 <tensorpudding> People in Industry use Haskell too
01:42:08 <kmc> 5 more companies added so far this year
01:42:52 <lars9> hey, what editor do you use for haskell? I want the auto-completion like in GHCi...
01:43:03 <tensorpudding> Haskell has a couple web frameworks but are any of them worth using?
01:43:19 <roconnor> I use kate, but it has not editing features for haskell
01:43:35 <kmc> tensorpudding, i think happs is the only one used for "real" stuff
01:43:47 <kmc> err happstack
01:43:53 <tensorpudding> Is it feasible to move haskell.org and everything over to happstack?
01:44:26 <hpaste>  . (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24849
01:45:06 <hpaste>  . (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24850
01:45:18 <ivanm> the hpaste bot is back? :o
01:45:48 <tensorpudding> It'll get obnoxious if hpaste.org gets spammed again.
01:45:57 <fatalerrorx> any help with http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24850#a24851
01:46:12 <fatalerrorx> please i included the error
01:46:22 <Cale> fatalerrorx: Sure, get isn't a Word16
01:46:34 <Cale> fatalerrorx: Rather, it's probably a Get Word16
01:46:36 <fatalerrorx> but it supports it
01:46:36 <quicksilver> fatalerrorx: in fact, those annotations are unnecessary anyway
01:46:44 <quicksilver> as GHC will infer the types.
01:46:53 <quicksilver> but if you want to use them, it's "get :: Get Word16"
01:46:56 <quicksilver> (as Cale said)
01:47:01 <fatalerrorx> ah
01:47:12 <Cale> You're giving the type of the computation, not the type of its result
01:47:27 <fatalerrorx> how would GHC know that its Word16 and not Word32?
01:47:45 <fatalerrorx> I see
01:47:48 <Cale> because you're using the result in the e_magic field of a DosHeader
01:47:50 <quicksilver> by the way you use it in DosHeader
01:48:04 <Cale> Which must itself be a Word16
01:48:04 <fatalerrorx> ah
01:48:15 <lars9> hey can anyone should me an example, which can retrieve the first google search result?
01:48:18 <fatalerrorx> Why Get Word16?
01:48:33 <lars9> it can be done in several lines with python
01:48:34 <fatalerrorx> is it like IO String
01:48:45 <Cale> fatalerrorx: Similar, Get is another monad.
01:49:00 <fatalerrorx> thanks for the help
01:49:05 <ivanm> I've just gotten some spam from someone that wants me test drive some presentation software... >_>
01:49:06 <Cale> lars9: hmm, I could certainly do it with tagsoup
01:49:17 <ivanm> it looks legit as well :s
01:49:31 <Cale> lars9: I'm not sure if there's a library already available for grabbing google search results or not, but it's a decent idea.
01:50:06 * ivanm has no idea how he was chosen...
01:50:26 <fatalerrorx> is it possible to make show display word16 in hex?
01:50:38 <Cale> http://hackage.haskell.org/package/NGrams apparently is a program which uses google search results... I wonder how it does it...
01:50:43 <quicksilver> fatalerrorx: that would be a mistake, that's not what "show" is for.
01:50:43 <fatalerrorx> do i have to make my own instance?
01:50:58 <fatalerrorx> what is it for?
01:51:01 <Cale> fatalerrorx: Use showHex
01:51:09 <fatalerrorx> data serialization?
01:51:14 <fatalerrorx> Cale: thanks
01:51:14 <lars9> Cale: let me check it:)
01:51:15 <quicksilver> it is for a canonical, haskell-formatted, machine-readable view of the data
01:51:24 <Cale> > showHex (798432 :: Word16) ""
01:51:25 <lambdabot>   "2ee0"
01:51:31 <quicksilver> Show instances should be (a) readable with 'read' and (b) valid haskell code.
01:51:35 <fatalerrorx> nice
01:52:00 <quicksilver> Cale: @google in lambdabot too ;) although that's very old code it probably doesn't use modern libraries
01:52:15 <fatalerrorx> is it possible to make my own deriving show?
01:52:27 <kmc> err, the point of "deriving" is that the compiler writes it for you
01:52:32 <kmc> you can write your own Show instance
01:52:35 <kmc> not using deriving
01:52:41 <quicksilver> you can write your own Show instances, but you normally should not.
01:52:41 <fatalerrorx> its still show
01:52:49 <fatalerrorx> ok
01:52:54 <quicksilver> the compiler-derived Show instance does the right thing in most cases.
01:53:01 <fatalerrorx> i used show as dbug output sort of thing
01:53:07 <quicksilver> one reason to write your own is to preserve abstraction, if your data structures aren't exported.
01:53:12 <Cale> Ah, it just uses the HTTP library and scrapes the result with a regex (it apparently is only concerned with how many results there are)
01:53:33 <quicksilver> it is definitely handy for debug output but that's not it's main purpose
01:53:52 <quicksilver> some people think that haskell should have a 'DebugRepr' class or something to make the separation clear
01:56:06 <kmc> Show is defined in terms of String (slow concat) and ShowS (hacky, opaque)
01:56:17 <kmc> usually for "real" printing rather than debug i want something like Doc
01:57:17 <kmc> not sure that should be in a typeclass
01:58:04 <kmc> i'm usually fine with ppExpr, ppStmt, etc.
01:58:21 <kmc> not convinced that overloading the names is a good / necessary idea
02:00:26 <kmc> one annoyance i have with «deriving Show» is that i'll have a big type with lots of constructors, one of which has something unShowable like a function in it
02:00:27 <fatalerrorx> what is ppExpr?
02:00:59 <Cale> Presumably it stands for "pretty print expression"
02:01:06 <PeakerWork> dobblego: hey, are you there?
02:01:07 <kmc> fatalerrorx, i'm talking about a hypothetical program which has to print a syntax tree of some kind... i'm saying it's okay to have a couple different names for the different parts
02:01:15 <fatalerrorx> ah i thought it wask in haskell lib
02:01:27 <fatalerrorx> ok
02:01:39 <kmc> anyway i would like to be able to derive Show in those cases
02:01:47 <kmc> with the un-printable fields replaced with "???" or whatever
02:02:30 <PeakerWork> dobblego: When you are, would like to know if Lastik can "scan" the dependencies of auto-generated code -- and then rebuild that before building the auto-generated code.. (Basically if it's a Build Monad, and not a Build Applicative :-) )
02:02:36 <kmc> TH can't look for instances as part of reification can it?
02:03:56 <kmc> it's probably good enough for my purposes to blacklist (->) plus a user-specified list of tycons
02:11:00 <o^_^o> In the you could've invented monads tutorial
02:11:32 <o^_^o> for exercise seven, implement bind :: (a â StdGen â (b,StdGen)) â (StdGen â (a,StdGen)) â (StdGen â (b,StdGen))
02:11:50 <o^_^o> solution is: bind f x seed = let (x',seed') = x seed in f x' seed'
02:12:06 <o^_^o> there seems to be something in there that I am not getting
02:12:30 <kmc> how so?
02:13:19 <o^_^o> x is not a function which takes StdGen and returns (s, StdGen)
02:13:35 <o^_^o> s/(s, StdGen)/(a, StdGen)
02:13:42 <kmc> isn't it?
02:13:47 <kmc> bind :: (a â StdGen â (b,StdGen)) â (StdGen â (a,StdGen)) â (StdGen â (b,StdGen))
02:13:52 <kmc> so the args to bind are:
02:13:55 <o^_^o> also what is (x', seed') = x seed
02:13:57 <kmc> f :: (a â StdGen â (b,StdGen))
02:14:03 <kmc> x :: (StdGen â (a,StdGen))
02:14:07 <kmc> seed :: StdGen
02:14:15 <o^_^o> so x is a function ?
02:14:33 <kmc> yes
02:14:48 <kmc> it's in the type of bind
02:15:08 <kmc> remember that «a -> b -> c» is the same as «a -> (b -> c)» but not the same as «(a -> b) -> c»
02:15:15 <tibbe> dcoutts: you there?
02:15:23 <dcoutts_> tibbe: hia
02:15:38 <o^_^o> kmc, ok
02:15:55 <tibbe> dcoutts_: have you seen the whole "cabal test" soc proposal?
02:15:59 <lars9> ->
02:16:00 <kmc> "(x', seed') = x seed" is a pattern-matching "let" binding
02:16:07 <kmc> you can bind to patterns, not just variables
02:16:08 <kmc> e.g.
02:16:12 <kmc> > let (a,b) = (1,2) in a+b
02:16:13 <lambdabot>   3
02:16:27 <dcoutts_> tibbe: I don't think I've seen the final version, I saw the drafts sent to -cafe
02:16:39 <tibbe> dcoutts_: Can you access this page: http://socghop.appspot.com/gsoc/student_proposal/review/google/gsoc2010/ttuegel/t127076857790
02:16:52 <ivanm> tibbe: aren't they meant to have been submitted already?
02:17:05 <tibbe> ivanm: yes, that's the submitted proposal
02:17:18 <o^_^o> kmc, ok, but I thought x executed with seed as argument and returned (x', seed'), which is fed to f (f x' seed')
02:17:51 <tibbe> dcoutts_: In particular, I think there's a bit too much flexibility in the proposed system, like requiring both an executable and a test stanza per test
02:18:03 <kmc> o^_^o, yes
02:18:09 <kmc> that's what's going on, more or less
02:18:09 <o^_^o> kmc, ok
02:18:17 <kmc> (although the word "execute" usually means something different)
02:18:17 <tibbe> dcoutts_: this leads to lots of spurious executables (which are not marked as being tests in any way)
02:18:22 <dcoutts_> tibbe: I'll have to log in from home
02:18:31 <tibbe> dcoutts_: ok
02:18:50 <dcoutts_> tibbe: I wouldn't be too worried, the details of good design can be worked out at the beginning of the project
02:18:59 <tibbe> dcoutts_: supporting tests that require user input while running doesn't seem all that useful either
02:19:00 <o^_^o> kmc, execute /= function run with arguments ?
02:19:08 <tibbe> dcoutts_: that's true
02:19:18 <dcoutts_> tibbe: the main thing is that the student have the skills and have some thoughts of their own :-)
02:19:31 <tibbe> dcoutts_: yes, the proposal will certainly be accepted
02:19:39 <dcoutts_> tibbe: I agree, I think we only need non-interactive tests
02:20:11 <dcoutts_> tibbe: test stanza per test? you mean for each individual test case/property?
02:21:13 <kmc> o^_^o, in Haskell it's important to make a distinction between evaluation (turning function applications into values) and execution (handing an IO action to the runtime system to be performed)
02:21:33 <kmc> although you might talk about "execution" for other monads, in a somewhat metaphorical sense
02:21:47 <o^_^o> kmc, aha...now I understand
02:22:26 <o^_^o> I am still unable to make the intuitional leap as to how to launch a missile using monads
02:22:27 <kmc> cool :)
02:22:32 <kmc> heh
02:22:36 <o^_^o> kmc, thanks :-)
02:23:02 <o^_^o> >>= and return are able to send output via my parallel port to the missile launch mechnism
02:23:07 <o^_^o> mechanism*
02:23:16 <kmc> yup
02:23:16 <o^_^o> I still don't get how
02:23:17 <Jafet> Usually we skip the IO hassle and use unsafeLaunchMissile
02:23:36 <danderson> you mean unsafeFireZeMissiles
02:23:49 <Jafet> That only fires the useless French missiles.
02:24:22 <o^_^o> once I figure that out, my diabolical plans will come into play </maniacal cackle>
02:24:27 <danderson> I believe that would be unsafeFart yourGeneralDirection
02:25:33 <dobblego> PeakerWork, currently Lastik does no such thing, but it's always on my mind and edwardk and I have discussed how to go about it quite deeply once, but we didn't come to any concrete conclusion -- except he did say that he was currently trying to solve this particular problem and I have come up with a primitive solution (with some limitations). I am very keen on coming up with a practical solution to this problem for probably the same
02:25:34 <dobblego> reasons you asked the question
02:25:41 <ivanm> grrrr....... the Dot spec for Graphviz says that an unquoted String must be a "string of alphabetic ([a-zA-Z\200-\377]) characters, underscores ('_') or digits ([0-9]), not beginning with a digit"
02:25:46 <p_l> Frenchies have some nasty tac-nukes...
02:25:49 <ivanm> and then one of their own examples breaks that! :@
02:26:24 <arcatan> ivanm: what's the example?
02:26:53 <ivanm> arcatan: for me it's in /usr/share/graphviz/graphs/directed/russian.gv
02:27:06 <ivanm> @type ord 'ÐÐ¶
02:27:06 <lambdabot>     lexical error in string/character literal at character '?'
02:27:08 <ivanm> @type ord 'Ð'
02:27:09 <lambdabot>     lexical error in string/character literal at character '?'
02:27:16 <ivanm> > ord 'Ð'
02:27:17 <lambdabot>   1050
02:27:47 <ivanm> > '\377'
02:27:47 <lambdabot>   '\377'
02:27:53 <ivanm> > char '\377'
02:27:54 <lambdabot>   Å¹
02:29:17 <ivanm> is there any way of checking what encoding a file is saved in?
02:29:37 * ivanm wonders if that example is using Latin1, even though Graphviz says you should specify if it does...
02:29:51 <Jafet> Guess and pray
02:30:40 <o^_^o> ivanm, enca
02:30:47 <o^_^o> ivanm, it is a linux command
02:31:04 <fasta> o^_^o, which fundamentally cannot decide that problem.
02:31:30 <ivanm> o^_^o: I want to know what encoding it's in; enca seems to be for conversions :s
02:31:42 <ivanm> hmmm.... file says it's in UTF-8
02:31:46 <fasta> ivanm, you cannot derive that from a bunch of bytes.
02:32:11 <fasta> ivanm, the answer is basically: ask whoever gave you the file.
02:32:19 <o^_^o> enca -g ?
02:32:25 <ivanm> fasta: it's an upstream tarball
02:32:38 <o^_^o> enca -g guesses the file encoding
02:32:43 <ivanm> I figured it was utf-8, because ghc opens it fine, emacs has a U in the mode line
02:32:48 <arcatan> fasta: you can still make educated guesses
02:33:01 <ivanm> o^_^o: nope, it's still confused ;-)
02:33:07 <o^_^o> ivanm, ah...ok
02:33:08 <fasta> arcatan, yes, but there is no guarantee that you are right.
02:33:45 <fasta> ivanm, which project is this?
02:34:05 <ivanm> fasta: hmmm?
02:34:10 <fasta> ivanm, if Emacs opens it fine, you can ask Emacs.
02:34:23 <ivanm> yeah, I can never remember how though :s
02:35:26 <ivanm> _anyway_
02:35:56 <ivanm> the Dot spec says it accepts [a-zA-Z\200-\377]
02:36:11 <ivanm> and the cyrillic characters that file contains are not in that range
02:37:30 <ivanm> and the various Data.Char functions (isALpha, isLetter, etc.) all think that they aren't letters... >_>
02:37:42 * ivanm wonders who is lying
02:37:59 <dobblego> PeakerWork, it would be great if there was a library for general dependency resolution, then another package that depended on it and lastik to put it all together nicely
02:38:12 <Jafet> It's all a big lie
02:38:17 <fatalerrorx> is it possible to make a infinit list of Get
02:38:31 <kmc> it's possible to make an infinite list of any type
02:38:32 <fatalerrorx> get is an monad function
02:38:45 <Jafet> You could try a web browser, they have to deal with any encoding imaginable
02:38:58 <fatalerrorx> for example how do make a infinite list of print x?
02:39:07 <dobblego> fatalerrorx, "get is a monad function" <-- that doesn't sound right, do you mean Get is a data type?
02:39:10 <kmc> > repeat (print 'x')
02:39:11 <lambdabot>   [<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<I...
02:39:16 <kmc> fatalerrorx, a list of IO actions is not an IO action
02:39:28 <kmc> a list of 10 cake recipes is not a single recipe for 10 cakes
02:39:33 <kmc> but you can go between them with
02:39:34 <kmc> :t sequence
02:39:34 <fatalerrorx> lol
02:39:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
02:39:39 <xerox> > sequence . repeat . print
02:39:40 <lambdabot>   {()-><IO [()]>}
02:39:40 <Jafet> > sequence $ (print 'x')
02:39:41 <lambdabot>   Couldn't match expected type `[m a]'
02:39:41 <lambdabot>         against inferred type `GHC.IOB...
02:39:42 <fatalerrorx> ah
02:39:55 * Jafet fails
02:39:58 <dobblego> I think you'd want sequence_ (with the underscore)
02:40:05 <fatalerrorx> thanks
02:40:18 <kmc> yes, if you want to discard the list of result values (which in this case are useless)
02:40:20 <m3ga> is the GHC trac still borked?
02:40:24 <xerox> > sequence_ . repeat . print
02:40:25 <lambdabot>   {()-><IO ()>}
02:40:37 <fatalerrorx> no i need the list of values
02:40:46 <kmc> :t replicateM
02:40:47 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
02:40:48 <xerox> print isn't going to return useful values
02:40:50 <dobblego> those values are of type ()
02:40:53 <lars9> vim' haskell indent is so bad!
02:40:57 <ivanm> oh, wait, it's just that copying the printed cyrillic character and then pasting that in confuses ghci
02:41:05 <Zao> lars9: Are you using the Haskell mode?
02:41:06 <ivanm> but still, the Dot spec seems wrong...
02:41:16 <Zao> lars9: And I'm sure you can tune it. Or learn *shudder* Emacs.
02:41:47 <lars9> Zao: vim's built-in haskell support
02:41:51 <lars9> Zao: im using.
02:42:42 <lars9> Zao: what is haskell mode? is that emacs?
02:43:07 <Kasmene_Marco> ciaooooooooo
02:43:10 <Kasmene_Marco> !list
02:43:24 * ivanm waves idly in Kasmene_Marco's general direction
02:43:27 <baaba> lars9: there's a better haskell indent file for vim floating around
02:43:41 <dobblego> Kasmene_Marco?
02:43:42 <xerox> Kasmene_Marco: what makes you think there's anything to download here
02:44:07 <dobblego> I think lambdabot should respond to !list with a link to The Haskell Platform
02:44:13 <xerox> hahaha
02:44:15 <ivanm> dobblego: hmmm...
02:44:16 <lars9> baaba: what is that?
02:44:29 <ivanm> does anyone know if ghc's locale specific stuff is a runtime or a buildtime thing?
02:44:44 <baaba> http://www.vim.org/scripts/script.php?script_id=1968
02:44:45 <ivanm> (i.e. if I change my locale, will ghc automatically start using that locale?)
02:44:52 <kmc> hahaha dobblego
02:44:54 <baaba> it's still not exactly perfect but it's good enough for me
02:45:53 <baaba> also there's apparently a bunch of stuff here http://projects.haskell.org/haskellmode-vim/
02:45:56 <baaba> but i haven't tried those
02:46:16 <Zao> lars9: The last link by baaba.
02:47:14 <lars9> Zao: baaba you mean this haskellmode-vim one?
02:47:44 <baaba> no i mean the other one that i didn't talk about
02:48:14 <baaba> oh wait that wasn't for me
02:48:39 <paulvisschers> Does anyone know where I can get the dev version of haskelldb, the darcs repos on the site doesn't seem to work?
02:49:24 <fatalerrorx> its a real pain in the ass to read c type structs of disk
02:49:45 <danderson> hsc and a Storable instance?
02:50:01 <danderson> assuming the C app serialized memory to disk without modification
02:51:30 <Zao> fatalerrorx: Not too horribly hard with Binary's Get.
02:51:58 <Zao> Assuming you can be arsed writing up a decent instance for it and have documentation on the disk format.
02:52:10 <Zao> Dumping memory to disk isn't exactly a robust serialization.
02:52:23 <fatalerrorx> i know i parsing pe format
02:52:33 <fatalerrorx> so i'm just reading
02:52:45 <fatalerrorx> but still those structs are huge
02:53:04 <fatalerrorx> and a hundred gets get tiresome
02:58:05 <kmc> if you want to manipulate binaries
02:58:08 <kmc> you might want to use GNU BFD
02:58:25 <quicksilver> fatalerrorx: well, you can shorten the gets quite a bit from what you wrote.
02:58:51 <quicksilver> fatalerrorx: for example, your entire DosHeader 'get' instance is:
02:59:01 <quicksilver> get = DosHeader <$> get <*> get <*> get <*> get
02:59:24 <quicksilver> can't make put quite that concise unfortunately.
02:59:36 <quicksilver> 'derive' will derive binary instances automatically though
02:59:47 <quicksilver> and if you follow some simple convenients they will be the 'right' ones fro reading C-style structs.
03:03:01 <zygoloid> is it possible to access annotations (added using GHC's ANN pragma) from TH?
03:03:43 <fatalerrorx> quicksilver: what about [Word16]?
03:03:55 <fatalerrorx> my struct has those
03:04:36 * hackagebot SybWidget 0.5.3 - Library which aids constructing generic (SYB3-based) widgets  http://hackage.haskell.org/package/SybWidget-0.5.3 (MadsLindstroem)
03:05:36 * hackagebot WxGeneric 0.6.1 - Generic (SYB3) construction of wxHaskell widgets  http://hackage.haskell.org/package/WxGeneric-0.6.1 (MadsLindstroem)
03:12:42 <fatalerrorx> whats wrong with (liftM2 map) put (e_res header)
03:12:43 <fatalerrorx> ?
03:13:18 <ivanm> @type liftM2
03:13:19 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
03:13:21 <ivanm> @type liftM2 map
03:13:22 <lambdabot> forall a b (m :: * -> *). (Monad m) => m (a -> b) -> m [a] -> m [b]
03:13:39 <ivanm> fatalerrorx: so, is put of type m (a -> b) ?
03:13:42 * ivanm doubts it
03:13:47 <ivanm> @src liftM2
03:13:48 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
03:13:50 <ivanm> fatalerrorx: ^^
03:13:56 <ivanm> you sure you understand what liftM2 is doing?
03:14:27 <hpaste>  . (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24852
03:14:27 <fatalerrorx> check the hpaste
03:15:28 <zygoloid> fatalerrorx: maybe you want mapM_ put (e_res header)?
03:15:35 <fatalerrorx> ah
03:15:36 <zygoloid> @type mapM_
03:15:37 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
03:15:52 <fatalerrorx> my bad
03:16:06 <fatalerrorx> for not reading type sig better
03:16:44 <ivanm> noooo!!!! yet _more_ short-hand syntax for graphviz!!! :@
03:16:47 <zygoloid> liftM2 f a b will perform two monadic actions: a and b. mapM f xs and mapM_ f xs will perform f once for each x in xs
03:21:56 <ivanm> is there a nicer version of [ f a b | a <- as, b <- bas ] ?
03:22:05 * ivanm has the sneaking suspicion that liftM2 might apply here...
03:22:08 <xerox> liftM2 f
03:22:14 <ivanm> thought so, thanks xerox
03:22:17 <xerox> sure
03:23:43 <xerox> > liftM2 (,) [1,2] [3,4]
03:23:44 <lambdabot>   [(1,3),(1,4),(2,3),(2,4)]
03:23:44 <xerox> > (,) <$> [1,2] <*> [3,4]
03:23:45 <lambdabot>   [(1,3),(1,4),(2,3),(2,4)]
03:23:56 <xerox> > (,,) <$> [1,2] <*> [3,4] <*> [5,6]
03:23:57 <ivanm> heh, I just tried that myself ;-)
03:23:57 <Jafet> @pl \as bs -> [ f a b | a <- as, b <- bs ]
03:23:57 <lambdabot> (. (return . (b <-))) . (:) . ((f a b | a) <-)
03:23:57 <lambdabot>   [(1,3,5),(1,3,6),(1,4,5),(1,4,6),(2,3,5),(2,3,6),(2,4,5),(2,4,6)]
03:24:03 <Jafet> Hah
03:24:05 <xerox> (scales better)
03:24:10 <ivanm> yeah, @pl doesn't like list comprehensions
03:24:16 <xerox> ?. pl undo do { a<-as; b<-bs; return (f a b) }
03:24:16 <lambdabot> (`fmap` bs) . f =<< as
03:24:18 <xerox> but still :|
03:24:48 <fatalerrorx> is there a bytestring version of System.IO?
03:25:17 <ivanm> fatalerrorx: yes, it's in the bytestring package
03:25:19 <xerox> woops
03:25:30 <ivanm> @pl \ from to -> f from bar to baz
03:25:30 <lambdabot> flip flip baz . flip f bar
03:25:33 <ivanm> :s
03:25:34 <xerox> ?. pl undo \f as bs -> do { a<-as; b<-bs; return (f a b) }
03:25:34 <lambdabot> liftM2
03:25:36 <xerox> this does work
03:25:58 <Jafet> Haskell should have placeholders
03:26:11 <xerox> I think they want to remove them
03:26:34 <Jafet> f ? x = \y -> f y x
03:26:41 <xerox> ?type do { a<- ?as; b<- ?bs; return (?f a b) }
03:26:42 <lambdabot> forall (m :: * -> *) t b t1. (?as::m t, Monad m, ?bs::m t1, ?f::t -> t1 -> b) => m b
03:27:00 <Jafet> Wait a minute, that's valid Haskell
03:27:05 <xerox> the current name is implicit parameters
03:27:20 <xerox> but again, they aren't going to last very long, supposedly
03:27:34 <Jafet> > let f ? x = \y -> f y x in ((/) ? 1) 2
03:27:35 <lambdabot>   2.0
03:27:46 <Jafet> xerox, hs98?
03:27:54 <xerox> no way
03:28:09 <xerox> hs-unsuccessful-experimentation I guess
03:28:15 <Jafet> I had my doubts
03:28:43 <xerox> still, they come in handy on irc
03:29:01 <ivanm> Jafet: what do you mean?
03:29:02 <xerox> DSL-wise, win-win.
03:29:07 <ivanm> xerox: they want to remove what?
03:29:39 <xerox> ?type ?a + ?b
03:29:40 <Jafet> ivanm, the meaning of what?
03:29:40 <lambdabot> forall a. (?a::a, ?b::a, Num a) => a
03:29:48 <ivanm> Jafet: a placeholder
03:29:48 <ski> tensorpudding : i suppose one could add a captcha, like lisppaste has
03:30:28 <Jafet> A symbol that stands in for an argument, and creates a closure to later accept a real argument
03:30:33 <ski> Jafet : what should `f x ?' be ?
03:30:53 <Jafet> ski, f x
03:30:57 <xerox> ivanm: right?
03:31:09 <ivanm> xerox: I have no idea ;-)
03:31:24 <ivanm> but implicit parameters sounds vaguely familiar (from someone giving a talk on Scala)
03:31:36 <ivanm> if that's what you're talking about, I think they're a bad idea
03:31:45 <ivanm> as it means there's too much implicit information being passed around
03:31:50 <xerox> http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#implicit-parameters
03:32:04 <xerox> yep - but they are handy here :)
03:32:09 <ski> Jafet : great, then `\z -> (f x) z y  =  (f x) ? y  =  (f x ?) y  =  (\z -> f x z) y  =  f x y' :)
03:32:18 <ivanm> xerox: oh, I thought you meant "pick the values out of the environment" implicit parameters
03:32:32 <ivanm> having implicit parameters in the type sig might be useful; I've never used them though
03:32:45 <quicksilver> implicit parameters aren't really place holders - they just happen to double up like them in a type checker
03:32:51 <Jafet> Eh eh
03:32:55 <dobblego> implicit parameters are very useful
03:33:05 <quicksilver> implicit parameters are very abhorrent
03:33:16 <ski> placeholders are worse
03:33:22 <dobblego> like type-classes, except more useful
03:33:31 <fasta> Someone who actually uses implicit parameters?
03:33:54 <quicksilver> they're like typeclasses for which you can define new instances locally with a broken notion of dynamic scope
03:33:57 <quicksilver> (aren't they?)
03:34:10 <quicksilver> (or is it lexical? I think it's dynamic)
03:34:15 <xerox> ivanm: best usecase ever, you're golfing and you write something with parameters, instead of going to the right spot and add "\<args> ->" you can put "?" in front of the symbols
03:34:16 <ski> dynamic
03:34:40 <quicksilver> so they're problematic for all the reasons that dynamic scope is generally problematic
03:34:54 <quicksilver> but additionally they break rewriting/refactoring in some annoying ways
03:35:02 <Cale> The only way that I ever use implicit parameters is in conjunction with :t
03:35:06 <quicksilver> somethign to do with the order they take effect through 'let' bindings
03:35:13 <quicksilver> but I've forgotten the details,
03:35:17 <ski> well, at least the types tells you when something depends on an implicit parameter
03:35:42 <Cale> They're handy for that because the inferred types of implicit parameters show up in the context
03:35:57 <Cale> :t mapM ?f ?xs
03:35:58 <lambdabot> forall a (m :: * -> *) b. (?f::a -> m b, ?xs::[a], Monad m) => m [b]
03:37:20 <ski> @type map ?reverse (words "a bc def")
03:37:20 <lambdabot> forall b. (?reverse::String -> b) => [b]
03:37:25 <ski> @type undefined `asTypeIn` \reverse -> map reverse (words "a bc def")
03:37:26 <lambdabot> forall b. String -> b
03:37:30 <ski> @type reverse `asTypeIn` \reverse -> map reverse (words "a bc def")
03:37:30 <lambdabot> [Char] -> [Char]
03:38:30 <ski> (which is handy to show/determine which instance of a polymorphic operation is used at an occurence)
03:38:57 <dolio> It might depend on how you think dynamic scope should work.
03:40:25 <dolio> > let f = (let ?x = 5 in \y -> y + ?x) in let ?x = 4 in f 4
03:40:26 <lambdabot>   9
03:40:42 <ski> @tell solrize in case you haven't seen it, check out srfi-45, too (<http://srfi.schemers.org/srfi-45/>)
03:40:42 <lambdabot> Consider it noted.
03:41:08 <ski> @type let ?x = 5 in \y -> y + ?x
03:41:09 <lambdabot> forall a. (Num a) => a -> a
03:41:37 <Cale> Yeah, I suppose it's not really dynamic scope, but yet another kind of lexical scope
03:42:16 <quicksilver> dolio: I think of dynamic scope as being like a mutable environment which can be modified at each level, but often the modification commands restore the status quo after they've done something
03:42:34 <quicksilver> this intuition comes from how I think elisp works, as elisp is the only dynamically scoped language I've ever used.
03:42:38 <quicksilver> I could be wrong on both points :)
03:43:19 <quicksilver> ah, that's not quite true - perl has a dynamic 'local' but it's not so-often used.
03:43:39 <dolio> Well, oleg thinks that implicit parameters aren't dynamic scope, so you're in good company.
03:43:42 <theorbtwo> quicksilver: That's very nearly how dynamic scope works in perl... but note that dynamic scoping is now almost unknown in perl; lexical scoping has neatly supplanted it.
03:43:45 <Jafet> (let ((+ -)) (increase-frame-height))
03:44:19 <QtPlatypus> common lisp has dynamic scopeif you sk for it as well
03:45:40 <quicksilver> well, dolio's example *is* what I'd call dynamic scope, with one proviso
03:45:50 <quicksilver> you have to think of 'let' as being more imperative than we normally think of it.
03:46:07 <ski> > let f a = (let ?x = (a + 5) in \y -> y + ?x) in let ?x = 4 in f 3 4
03:46:08 <lambdabot>   12
03:46:09 <ski> @type let f a = (let ?x = (a + 5) in \y -> y + ?x) in f
03:46:10 <lambdabot> forall a. (Num a) => a -> a -> a
03:46:16 <quicksilver> so the inner let takes precedence because it 'runs after' the other let and 'overwrites' it therefore.
03:46:16 <ski> > let f :: Num a => a -> (?x :: a) => a -> a; f a = (let ?x = (a + 5) in \y -> y + ?x) in let ?x = 4 in f 3 4
03:46:17 <lambdabot>   12
03:47:35 <quicksilver> hmm but maybe that's not the point here
03:47:38 <Jafet> Looks like some sort of antilexical scope, where the outermost binding has effect
03:48:32 <ski> the issue is when is the inner `?x' fixed. when getting the inner lambda ? or when applying it ?
03:48:56 <ski> implicit parameters in GHC fixes it as early as possible, iiuc
03:51:14 <o^_^o> is there something like a simplest complete monad implementation (which does I/O) ?
03:51:28 <o^_^o> not Maybe or Either
03:51:44 <pastorn> o^_^o: IO?
03:52:02 <pastorn> you can't have any more than that...
03:52:09 <o^_^o> something like make  a light glow which is connected to parallel port
03:52:10 <ski> if you skip the "does I/O" requirement, then the simplest monad is `Identity'
03:52:26 <pastorn> o^_^o: if you can't do something in IO then you're pretty ******
03:52:36 <o^_^o> no I want to do I/O
03:52:49 <pastorn> o^_^o: what's your eng game?
03:52:58 <o^_^o> but I/O like write to parallel port in haskell
03:53:00 <Jafet> Find out how to write to your parallel port, then do it in Haskell
03:53:09 <Jafet> Have you done the first part?
03:53:12 <o^_^o> pastorn, I want to learn how monads are used to do I/O
03:53:27 <Cale> o^_^o: IO just happens to be a monad
03:53:36 <Cale> o^_^o: Monads really have nothing to do with I/O
03:53:39 <o^_^o> Jafet, yeah, but I want some clue how to combine the 2
03:53:39 <pastorn> o^_^o: are you going to code on ghc?
03:53:45 <o^_^o> pastorn, yes
03:53:53 <pastorn> srsly?
03:53:57 <pastorn> ask in #ghc then
03:54:00 <PeakerWork> dobblego: thanks.. I'm currently working on an in-house build system here, and it's basically going to be an FRP-like "Behavior" monad, eventually
03:54:15 <Jafet> Depends, could be as simple as writing to a device file
03:54:15 <Cale> pastorn: Probably o^_^o means that they are using ghc to compile their programs
03:54:28 <PeakerWork> dobblego: one of the requirements is that the dependency graph itself is a result of part of the build process
03:54:41 <Jafet> I don't know how to write to my parallel port... wait, I don't have a parallel port
03:54:43 <o^_^o> Cale, yes
03:54:47 <pastorn> o^_^o: are you out to change how GHC works? (manipulate the source code of GHC)?
03:54:55 <o^_^o> Jafet, I found a machine which has a parallel port just for this
03:55:00 <o^_^o> pastorn, no
03:55:14 <pastorn> then you don't need to worry how the IO monad works
03:55:18 <pastorn> but here it is:
03:55:21 <pastorn> @src IO
03:55:21 <Cale> o^_^o: Monads are just a particular style of library
03:55:22 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
03:55:44 <Cale> I really think that the RealWorld hackery is something we should avoid exposing beginners to
03:55:45 <Jafet> o^_^o, hmm, how do you write to it then?
03:55:57 <o^_^o> Jafet, some C code
03:56:00 <pastorn> Cale: he asked for it :)
03:56:03 <Cale> It's not even a particularly good mental model for how IO works.
03:56:10 <Cale> pastorn: That's not how I read it...
03:56:24 <Jafet> How does the C code write to the port?
03:57:20 <quicksilver> that newtype is utterly useless and should be removed from lambdabot
03:57:32 <quicksilver> the expectation is that lambdabot talks about haskell - or extended haskell.
03:57:38 <fasta> quicksilver, because it is a GHC specific thing?
03:57:44 <quicksilver> that fragment is in a special-purpose, impure, GHC-language
03:57:45 <Cale> quicksilver: I agree, and I think I'll do that
03:57:50 <quicksilver> which has no name, as far as I know
03:57:56 <quicksilver> (and few people understand its semantics well)
03:57:57 <pastorn> o^_^o: i'm guessing that what you might want is something like
03:58:21 <pastorn> type MyMonad a = StateT MyState IO a
03:58:35 <o^_^o> Jafet, I have some old code lying around, or I'll find one on the internet
03:58:50 <Jafet> I was hoping you could describe how it works
03:59:37 <o^_^o> Jafet, but I am less interested in the C code and more interested how to make a monad out of it
03:59:42 <Cale> o^_^o: You'd just be reading from and writing to a device file, wouldn't you?
03:59:54 * zygoloid would much rather that lambdabot had IO "implemented" as a free monad over an IO-action GADT, or newtype IO a = IO (ST RealWorld a), than the current definition.
03:59:56 <Jafet> I don't understand this fixation on monads
04:00:02 <Cale> o^_^o: Are you sure it *is* a monad?
04:00:06 <o^_^o> so I can close the intuitional gap between >>= and return and I/O
04:00:41 <pastorn> o^_^o: why do you have a gap there?
04:00:43 <dankna> >>= is like redefining semicolon
04:00:44 <o^_^o> Cale, yes
04:00:47 <Cale> o^_^o: There is a type of IO actions in Haskell which happens to be a monad.
04:00:52 <dankna> in other words it changes what it means to do two things in sequence
04:00:57 <Cale> But monads have nothing in particular to do with I/O.
04:01:17 <Cale> They're just a particular interface that a library might choose to support.
04:01:45 <o^_^o> pastorn, well I went through the tutorial on monads (several of them), but most of them stop and say there some C code which does the magic of actual random number generation, but that is unimportant etc.,
04:01:58 <o^_^o> Cale, ok....hmmmm
04:02:18 <pastorn> o^_^o: you should trust the tutorials when they say that
04:02:22 <roconnor> ooh a coq extracted library for heaps in Haskell
04:02:26 <Cale> If your library has something whose type is like that of return, and something whose type is like that of >>=, and they interact in a particular way (satisfy 3 laws), then you have a monad, and all the stuff in Control.Monad will work with your library
04:02:31 <Jafet> Monad tutorials are like burrito menus
04:02:34 <pastorn> unless you're going to code on ghc, you don't need to know
04:02:39 <o^_^o> so all I understand is >>= takes a m a and makes an a and return takes a and makes m a
04:02:55 <Cale> You're wrong about >>=
04:03:07 <pastorn> @type (>>=)
04:03:08 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
04:03:35 <dankna> well actually >>= takes two of m a.
04:03:50 <Cale> what?
04:03:54 <Cale> If x is has type m a, and f has type (a -> m b), then x >>= f has type m b
04:03:58 <dankna> oh, no
04:04:00 <dankna> sorry, yeah
04:04:04 <dankna> ignore me
04:04:05 <dankna> it's early
04:04:09 <Cale> s/is//
04:04:26 <o^_^o> it takes m a and a function which takes a and makes m a into a and feeds to function and gives back m b
04:04:37 <Cale> into m b
04:05:04 <zygoloid> o^_^o: 'return' takes some pure value and immerses it in your structure. '>>=' is like an 'and then' for your structure, where the thing you do next can depend on the result of the previous thing.
04:05:30 <Twey> > Just 3 >>= \x -> Just (x + 1)
04:05:31 <lambdabot>   Just 4
04:05:36 <PeakerWork> >>=  takes an "m a", a continuation that given an "a" makes the "next"  m b, and returns an "m b" that represents the composition of the two m's, with the result copied from the "next"
04:06:13 <Cale> Let's look at the example of lists
04:06:21 <o^_^o> yes, it is like stuffing taking the filling out of one burrito and putting it into the other
04:06:28 <Cale> hah
04:06:31 <pastorn> hehe
04:06:31 <zygoloid> oh dear god
04:06:47 <pastorn> zygoloid: no, there's no god here
04:06:49 <Twey> Hahaha
04:06:50 <Cale> Please don't seriously try to understand monads in terms of burritos, that was a joke
04:07:00 <ski> roconnor : priority-queues ?
04:07:05 <roconnor> yes
04:07:08 <pastorn> Cale: actually i found that quite enlightening when i first read it
04:07:09 <Cale> Take m to be the type constructor for lists, so that m a becomes [a]
04:07:34 <Cale> Then the type of (>>=) specialises to [a] -> (a -> [b]) -> [b]
04:07:45 <Cale> Can you think of a function of this type?
04:07:54 <Twey> (or similar)
04:08:07 <o^_^o> map ?
04:08:13 <Twey> :t map
04:08:14 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
04:08:18 <Twey> :t flip map
04:08:19 <Cale> Well, we could start with using map...
04:08:19 <lambdabot> forall a b. [a] -> (a -> b) -> [b]
04:08:23 <zygoloid> don't think of: \a f -> [] or \(a:as) f -> f a :D
04:08:45 <zygoloid> @type flip map
04:08:46 <lambdabot> forall a b. [a] -> (a -> b) -> [b]
04:09:00 <zygoloid> @type flip map :: [a] -> (a -> [b]) -> [[b]]
04:09:01 <lambdabot> forall a b. [a] -> (a -> [b]) -> [[b]]
04:09:02 <Twey> Only allows one result
04:09:05 <Cale> xs >>= f = ... map f xs ... -- if xs :: [a] and f :: a -> [b], then  map f xs  will have type [[b]]
04:09:13 <Cale> So we need to do something more
04:09:35 <zygoloid> @hoogle [[b]] -> [b]
04:09:36 <lambdabot> Prelude concat :: [[a]] -> [a]
04:09:36 <lambdabot> Data.List concat :: [[a]] -> [a]
04:09:36 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
04:09:50 <Cale> I want o^_^o to think, people.
04:10:11 <Cale> We have a list of lists of elements of type b, and we want just one list of elements of type b, what is the natural thing to do (though others have given the answer away)
04:10:33 * zygoloid blames lambdabot
04:11:02 <Jafet> head::NonemptyList a -> a
04:11:17 <ski> (quicksilver : another view is that that fragment is in a special-purpose, uniquely-typed GHC-language, except the type-system doesn't actually check the uniqueness types, so it's unsafe)
04:11:44 * Twey was playing nicely.
04:11:53 <Twey> Blame zygoloid.  ;)
04:11:57 <Cale> o^_^o: So...
04:12:00 <quicksilver> ski: well depending what you mean by 'that language'
04:12:08 <Cale> o^_^o: are you still following?
04:12:23 <o^_^o> Cale, ok I saw the concat thing
04:12:33 <quicksilver> ski: there exist genuinely impure Things# in GHC's haskell-like low level language. I agree that State# on its own could be considered what you just said.
04:12:49 <ski> *nod*
04:12:52 <Cale> o^_^o: right, so the most natural thing to do when you have a list of lists, and you only want one list of elements of the same type, is just to concatenate them all, yeah?
04:13:03 <o^_^o> Cale, yes
04:13:08 <Cale> o^_^o: So we can do that:
04:13:13 <Cale> xs >>= f = concat (map f xs)
04:13:20 <Cale> and this will have the right type
04:13:44 <Cale> and in this case of lists, we will have  return :: a -> [a]
04:14:09 <Cale> What should it do? (Probably your first guess will be the right thing)
04:14:46 <o^_^o> return [a]
04:14:56 <pastorn> o^_^o: return x = [x]
04:15:06 <o^_^o> return a = a:[]
04:15:07 <o^_^o> ?
04:15:12 <pastorn> same thing
04:15:12 <Cale> yeah
04:15:14 <o^_^o> yeah what pastorn said
04:15:50 <Cale> Now, technically, there are some laws which we should check, but it turns out that these definitions make the type of lists into a monad
04:16:21 <Cale> and that means that we can use all the stuff in Control.Monad with lists, and it will work, which saves us the trouble of writing these functions specially for lists
04:16:31 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
04:16:31 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
04:16:51 <o^_^o> Cale, ok...
04:17:02 <Cale> They tend to do lots of useful things in the list case, all of which have the general theme of picking some things in all possible ways
04:17:08 <ski> > return (+) `ap` [100,200] `ap` [3,4,5]
04:17:09 <lambdabot>   [103,104,105,203,204,205]
04:17:24 <Cale> > do x <- [1,2,3]; y <- [4,5]; return (10*x+y)
04:17:24 <lambdabot>   [14,15,24,25,34,35]
04:17:32 <o^_^o> but list is also a functor
04:17:33 <Cale> We can also use the do-notation with lists
04:17:40 <pastorn> @type pure (+)
04:17:41 <lambdabot> forall a (f :: * -> *). (Num a, Applicative f) => f (a -> a -> a)
04:17:41 <Cale> Every monad is a functor
04:17:43 <o^_^o> because functor contains fmap
04:17:47 <o^_^o> ah...
04:18:02 <ski> o^_^o : `liftM' is the same as `fmap'
04:18:16 <ski> @src liftM
04:18:16 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
04:18:21 <o^_^o> Cale, why is the fmap for monads not defined ?
04:18:33 <Cale> Whenever we have a monad, we can define  fmap f x = x >>= (return . f)
04:18:46 <ski> o^_^o : because, for unexplicable reasons, `Functor' is not a superclass to `Monad'
04:18:49 <Cale> Which is the same as saying  fmap = liftM
04:19:15 <Cale> Whenever you run into a library where there's a Monad with no corresponding instance of Functor, it's a library bug, and you should report it.
04:19:47 <o^_^o> ski, ah...but http://4.bp.blogspot.com/_gNlz8IC_a0M/S8BOOlSbq6I/AAAAAAAAADk/qaAWYt5ODeg/s1600/effects.png ?
04:19:49 <Cale> Haskell technically could enforce this, but for stupid historical reasons, the libraries haven't been fixed to do so. :)
04:20:04 <o^_^o> Cale, ah...ok
04:20:20 <Cale> Ah, and then you have the problem that there are all these intermediate things which could possibly get involved
04:20:21 <pastorn> Cale: base5?
04:20:23 <o^_^o> Cale, now I understand, it is a difference between theory and practice
04:20:26 <ski> o^_^o : that's the abstract mathematical situation (applied to Haskell), yes
04:21:00 <ski> `Functor' *should* be a superclass of `Monad', it's just that it's not so defined in the current library
04:21:15 <Cale> Yeah, I guess you could has that every monad is a functor, but not every Monad need be a Functor
04:21:26 <o^_^o> class Functor F => Monad m where ...
04:21:42 <ski> s/F =>/m =>/
04:21:43 <kmc> @hoogle  [a] -> [(a,[a])]
04:21:44 <lambdabot> Data.Char readLitChar :: ReadS Char
04:21:44 <lambdabot> Numeric readFloat :: RealFrac a => ReadS a
04:21:44 <lambdabot> Prelude reads :: Read a => ReadS a
04:22:09 <o^_^o> Cale, ok...
04:22:13 <Cale> Yeah, it'd be  class Functor m => Monad m where ...
04:22:17 <ski> Cale : that's one nice way to phrase the current situation, yes
04:22:28 <Cale> say*
04:22:37 <Cale> for some reason I wrote 'has'
04:22:50 <Cale> too much lolcats and not enough sleep
04:22:52 * ski almost didn't notice
04:24:11 <o^_^o> Cale, are you from sweden ?
04:24:18 <Cale> nope, Canada
04:24:25 <bremner> similar climate
04:24:26 <ski> nope, (but i'm)
04:24:31 <o^_^o> ok, seeing the has I thought you were swedish
04:25:01 <o^_^o> lots of native swedish speakers write has where we write have
04:25:11 <Cale> o^_^o: Basically, you should usually not set out to create a monad. Become aware of the available monads, and design your library in whatever way seems most natural. Maybe check if you can get a monad instance once you've worked out what the basic types and operations are, but don't force the situation.
04:25:27 <o^_^o> Cale, ok
04:26:33 <Cale> It's nice to have the do-notation and the operations in Control.Monad and other libraries when you can get it, but usually not so essential that you'd distort the design of your library in any drastic way to make it happen.
04:27:04 <o^_^o> Cale, ok...
04:27:30 * o^_^o is still trying to think this through:  fmap f x = x >>= (return . f)
04:27:51 <Cale> Maybe I should write that like:  x >>= (\v -> return (f v))
04:28:07 <ski>   return . f =<< x
04:28:20 <o^_^o> no I need to use pen and paper, and work it through
04:28:34 <Cale> yeah, ski's way is what I'd normally do with composites that occur to the right of >>=
04:28:54 <Cale> (but of course, if they begin with return, I'll always substitute in an fmap or liftM
04:28:56 <Cale> )
04:29:08 <ski> (or `x >>= x >>> return')
04:29:46 <ski> (er, that should be `x >>= f >>> return', of course)
04:29:53 <Cale> o^_^o: Maybe check out my tutorials at some point:
04:29:55 <Cale> http://www.haskell.org/haskellwiki/Monads_as_Computation
04:30:00 <Cale> http://www.haskell.org/haskellwiki/Monads_as_Containers
04:30:54 <o^_^o> ah..now I get it...nice :-)
04:31:16 <Cale> and if you just want to understand how IO works in Haskell, I have a very short intro here: http://www.haskell.org/haskellwiki/Introduction_to_IO
04:32:04 <o^_^o> Cale, Ah...cool
04:32:08 <fatalerrorx> is it possible to conver [()] to ()?
04:32:20 <fatalerrorx> its a list of actions
04:32:31 <Jafet> :t sequence
04:32:32 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
04:32:39 <Cale> fatalerrorx: Did you apply mapM or sequence, and you wanted mapM_ or sequence_?
04:32:42 <baaba> then maybe you mean [IO ()] -> IO ()?
04:32:51 <fatalerrorx> :t mapM_
04:32:52 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
04:33:00 <fatalerrorx> nice
04:33:05 <fatalerrorx> thanks
04:34:36 <Cale> o^_^o: The key to how IO works in Haskell is that we have these values called IO actions (whose type looks like IO t, for various types t), and evaluation doesn't cause those actions to actually happen (any more than loading the source code of a program in a text editor would cause the program to run)
04:35:11 <Cale> o^_^o: Instead, there's a separate process of execution, and in the end, you define an action-value called 'main', and it gets executed.
04:35:33 <o^_^o> Cale, ok
04:36:02 <fatalerrorx> ah
04:36:17 <Cale> So, because it's important, I'll rephrase it, evaluation, that is, the reduction of expressions to values, never causes IO actions to execute.
04:36:42 <fatalerrorx> only the call to main does?
04:36:59 <Cale> That 'never' should perhaps be asterisked, because there are some ways in which it's possible to make it happen, but they tend to be dangerous low-level hacks that you don't normally use :)
04:37:01 <fatalerrorx> causes actions to start executing?
04:37:05 <Cale> yeah
04:37:25 <fatalerrorx> still lazy eval
04:37:29 <Cale> The runtime system evaluates main, and executes the action that it describes
04:37:38 <fatalerrorx> just looks imperitive
04:37:45 <BONUS> Cale: dangerous low-level hacks or lazy IO :)
04:37:46 <Cale> hm?
04:37:49 <o^_^o> so if I have a function which is printing something and doing some other calculation, is that not possible ? in the same function ?
04:38:13 <kmc> @pl \x (y,ys) -> (x,y:ys)
04:38:14 <lambdabot> (`ap` snd) . (. fst) . (. (:)) . (.) . (,)
04:38:17 <o^_^o> print intermediate value for example for debugging
04:38:27 <Botje> o^_^o: there is Debug.Trace
04:38:33 <Cale> o^_^o: Normally, you're right.
04:38:35 <Botje> but generally you want to separate printing from calculating
04:38:39 <Cale> o^_^o: (There shouldn't be a way)
04:39:00 <o^_^o> Cale, ah :-), is this one of those theory /= practice  thingies
04:39:02 <Cale> But people have used the low-level hacks to make that possible. Still, you might find it a little weird.
04:39:43 <Cale> The Haskell compiler is allowed to evaluate expressions in *any* order that makes sense (and doesn't unnecessarily cause the program to loop forever when it could terminate)
04:40:29 <Cale> So the order in which the trace messages get printed, and indeed whether they get printed at all, can depend on what the compiler does with your code -- what optimisations are turned on and so on.
04:40:35 <kmc> indeed, if you write a library that produces a big lazy datastructure, the user of that library might evaluate bits of that structure in different threads in a totally nondeterministic order
04:41:21 <kevinulin> i suspect kmc doesn't sleep
04:41:24 <kmc> > let pick [] = []; pick (x:xs) = (x,xs) : pick xs in pick "abcd"
04:41:25 <Cale> Because we want the compiler to have this control over what order the expressions get evaluated, we give up on trying to casually mix I/O into the process of evaluation (normally)
04:41:25 <lambdabot>   [('a',"bcd"),('b',"cd"),('c',"d"),('d',"")]
04:41:33 <kmc> ^^^ i feel like there should be a simpler way to write that
04:41:37 <o^_^o> if that is the case then is there a way to glue parts of programs together to get them to execute in order ?
04:41:52 <o^_^o> Cale, ok
04:41:52 <Cale> o^_^o: *execution* is in order
04:41:58 <Cale> Evaluation is not
04:42:03 <Cale> They are two separate things
04:42:03 <kevinulin> oh no not this again!
04:42:05 <kmc> execution is ordered by (>>=)
04:42:06 <o^_^o> Cale, ah...right
04:42:31 <pastorn> kevinulin: what again?
04:42:33 <kmc> kevinulin yeah... it's maybe the biggest conceptual difference between Haskell and most languages
04:42:35 <kmc> so it comes up a lot ;P
04:42:41 <o^_^o> kevinulin, sorry
04:42:42 <Cale> IO action values explicitly describe what order you want things to happen in, and they get carried out in that order
04:43:07 <kmc> @hoogle [a] -> [([a],[a])]
04:43:07 <lambdabot> Network.CGI formDecode :: String -> [(String, String)]
04:43:08 <lambdabot> Network.CGI.Protocol formDecode :: String -> [(String, String)]
04:43:08 <lambdabot> Network.CGI.Cookie readCookies :: String -> [(String, String)]
04:43:08 <Cale> But the order in which expressions are reduced to values is up to the compiler and runtime system to decide.
04:43:18 <o^_^o> Cale, ah...ok, this concept is like a little door that just opened in my head
04:43:23 <kevinulin> pastorn, i asked a very similar question 4-5 hours ago and got a mass of responses describing the diff between eval and exec
04:43:27 <pastorn> @type splitAt
04:43:28 <lambdabot> forall a. Int -> [a] -> ([a], [a])
04:43:41 <ivanm> grrrrr...... why won't this parser work?!?!?!?!?!?!
04:43:51 <Eelis> it's also true to a (much) lesser extent in C++, where in  f()+g()  it's up to the compiler to decide whether to evaluate f() first or g() first
04:44:13 <Cale> Yeah, which is a mess in C++, because f and g might have visible effects when you evaluate them
04:44:21 <Cale> Evaluation and execution are all mixed up in C++
04:44:34 <Eelis> i think it's the nature of the beast
04:44:47 <o^_^o> does this make it more difficult to understand pre-written haskell code ?
04:44:47 <Cale> Yeah, it's not the worst thing that's wrong with C++ anyway ;)
04:44:58 <Cale> o^_^o: generally it makes it easier
04:45:20 <Cale> o^_^o: because you know for sure what various bits of code absolutely cannot do
04:45:55 <o^_^o> Cale, does this have an effect on performance ? I put in a print somewhere to find out what is happening and suddenly the execution order changes and everything runs slower ?
04:45:57 <o^_^o> Cale, ok
04:45:59 <Cale> o^_^o: functions evaluate for one purpose, and that's to produce their result, and they depend *only* on their parameters, and not some random other stuff that's hard to determine without examining the source code in detail
04:46:10 <ivanm> preflex: seen malcolmw
04:46:10 <preflex>  malcolmw was last seen on #haskell 2 days, 20 hours, 21 minutes and 33 seconds ago, saying: cpphs has always accepted /* and */ and */* are not comment-related - I even used those operators in the source code of cpphs itself, to make sure :-)
04:46:19 <o^_^o> Cale, ah...ok
04:46:20 <tibbe> dcoutts_: accepted
04:46:25 <tibbe> dcoutts: accepted
04:46:31 <Cale> o^_^o: Yeah, if you use Debug.Trace in a bad way, you can turn terminating programs into ones which go into an infinite loop
04:46:41 <Eelis> o^_^o: note that all the nice advantages Cale mentions vanish when your functions are all in the IO monad
04:47:01 <Eelis> so don't do that :)
04:47:04 <o^_^o> Eelis, ok...*shudder*
04:47:14 <Cale> Well, even then, you can be sure that the IO action that you get only depends on the parameters
04:47:29 <Cale> You just can't be certain that when you execute that IO action you'll always get the same result
04:47:40 <Cale> Or what things that IO action's execution might depend on
04:47:57 <o^_^o> I come from the imperative programming world and my programming habit is to litter the code with prints everywhere and take them out in the end, I need to unlearn that
04:48:00 <Cale> The evaluation part is well-behaved, execution is messy and harder to analyse
04:48:19 <o^_^o> Cale, yeah...I am slowly grokking that
04:48:21 <Cale> Well, the nice thing about referential transparency...
04:48:38 <Cale> is that code works the same way in isolation as when you actually use it in the program as a whole
04:48:54 <o^_^o> Cale, aha! :-)
04:49:06 <ivanm> @undo do { a <- pa; pb; return a}
04:49:06 <lambdabot> pa >>= \ a -> pb >> return a
04:49:07 <Cale> So you can test small bits of code in isolation, and you get a fairly good guarantee that if they work in ghci, then they'll work the same way in your big program.
04:49:31 <o^_^o> so I can find out what something does separetely and plug it in and be sure it works the same with the other stuff
04:49:35 <Cale> yeah
04:49:41 <o^_^o> cool :-)
04:50:03 <Cale> Sometimes with more subtle bugs, you might have trouble finding the inputs for which a function fails, and Debug.Trace can be good for that.
04:50:10 <o^_^o> learning haskell is more about unlearning than learning itself :-)
04:50:16 <o^_^o> Cale, ok
04:50:19 <Cale> But then once you have those parameters, you can just go back to testing things separately
04:50:28 <o^_^o> in the beginning atleast
04:50:33 <Cale> indeed
04:50:37 <o^_^o> Cale, ok
04:51:15 <kevinulin> i would suggest using quickcheck in place of where you would have used print in c to test code
04:51:16 <Eelis> debugging is something of an open problem in the Haskell world though, as far as i understand.
04:51:37 <Eelis> there are attempts like the ghci debugger, but it's very hard to use
04:51:45 <o^_^o> kevinulin, quickcheck is a library ?
04:51:48 <kevinulin> it will take a couple hours to get use to it and get in the practice of it, but overall you will save time and you will have code that is easier to maintain
04:51:59 <medical> debugging, as we knew it, no longer exists :)
04:52:03 <McManiaC> debugging is a pain :>
04:52:09 <Cale> Imperative programming is sort of what makes debuggers necessary.
04:52:09 <kevinulin> im not sure what the mathmatical idea behind it is, but it is a library for very simple unit tests
04:52:21 <o^_^o> kevinulin, ok
04:52:33 <Cale> and while it's nice to be able to step through I/O heavy code, for pure functions it's unnecessary
04:52:34 <Eelis> Cale: wow, that's the stupidest thing i've heard in days
04:53:02 <kevinulin> i find that i use quickcheck for everything outside the IO monad and then still can fall back to the prints withen the IO monad
04:53:05 <Cale> Eelis: Well, what is a debugger for? It's for observing the state of your program as it executes, right?
04:53:14 <Eelis> Cale: no, it's for finding bugs
04:53:19 <Eelis> or rather, analyzing them
04:53:31 <Cale> Okay, so perhaps you have a more general definition of 'debugger' than I do.
04:53:37 <Eelis> it would appear so
04:53:50 <dankna> I don't agree at all - I think partly I have a more general definition, but also those imperative debuggers would still be useful to me in Haskell
04:54:03 <Cale> There are lots of tools which might be useful for analysing the behaviour of code, but I usually think of a debugger as a specific sort of tool
04:54:04 <PeakerWork> Cale: I'm really really missing an I/O stepping debugger
04:54:07 <dankna> it can be downright burdensome to define Show instances on everything and then sort through huge trace logs
04:54:22 <Cale> You can use a REPL to find bugs too
04:54:26 <dankna> and I do
04:54:28 <kmc> i never used a debugger all that much in imperative code (Haskell or otherwise)
04:54:34 <dankna> but not all code is clean enough to run in a REPL
04:54:37 <kmc> mostly just to get a stack backtrace from a segfault
04:54:48 <dankna> for example it might have a preprocessor attached to it that ghci doesn't know about
04:54:50 <kmc> in Haskell there is no one magic debug tool
04:54:55 <PeakerWork> Cale: It's not just for observing state as it executes -- it's also for toying around with manipulating state, or doing post-mortem, or deciding which state to print based on previous prints
04:55:00 <quicksilver> I've never found "debugging programs which don't work" hard in haskell
04:55:02 <PeakerWork> (stuff that's hard/impossible with adding prints)
04:55:11 <PeakerWork> quicksilver: Really? I've found it much harder than in any other language
04:55:13 <dankna> I've never found it impossible, but I've found it difficult
04:55:16 <Cale> PeakerWork: All of which make no sense in a referentially transparent context
04:55:24 <quicksilver> I have sometimes found "Debugging programs which run too slow" and "debugging programs which leak memory" to be hard, though.
04:55:37 <dankna> I agree that manipulating state makes no sense in Haskell, but observing state would be very useful
04:55:41 <kmc> i wish GHCi had support for interactively calling functions inside a "let" or "where"
04:55:47 <dankna> kmc: me too!
04:55:47 <kmc> subject to you providing any free variables ofcourse
04:56:01 <kmc> it's annoying to factor out a local binding just so i can debug it
04:56:06 <quicksilver> programs which don't work - as in, crash or do the wrong thing - I have found ghci excellent for.
04:56:07 <dankna> kmc: I've been evolving a style which uses a ton of local bindings
04:56:09 <quicksilver> kmc: Yes, agreed.
04:56:10 <Cale> For the IO monad specifically, it would be nice to step through, perhaps one bind at a time.
04:56:13 <kmc> and one reason i started to use where less and less
04:56:16 <dankna> kmc: and the ghci issue is a big drawback
04:57:06 <kevinulin> what is the point of 'where'? i see it in a lot of code but it seems no different from 'let' to me
04:57:09 <Cale> Another thing which would be nice is a tool for stepwise evaluation of Haskell code, but that would be probably more useful for understanding evaluation mechanisms and possibly for understanding performance, rather than finding bugs.
04:57:29 <opqdonut> kevinulin: yeah, one could replace all wheres with lets
04:57:30 <Cale> kevinulin: 'where' scopes over multiple guards
04:57:36 <quicksilver> kevinulin: in fundamental essence, it is the same thing
04:57:37 <opqdonut> ah, good point that
04:57:41 <quicksilver> kevinulin: it is syntactically quite different though
04:57:49 <quicksilver> kevinulin: it attaches to definitions not expressions
04:57:55 <opqdonut> where is a feature of declarations, let ... in ..., is just an expression
04:57:55 <quicksilver> so it's valid in different places in your program
04:58:08 <quicksilver> scoping over guards is one handy effect of that.
04:58:33 <o^_^o> I thought where was just let....in in reverse
04:58:39 <Cale> Fairly early on in compilation, all the wheres get replaced with lets by the compiler.
04:58:40 <quicksilver> (not only *could* one replace all wheres with lets, but GHC does exactly that)
04:58:45 <dankna> heh.  I never use where because when I was starting out none of the tutorials I used explained that syntax to me.
04:58:49 <o^_^o> I've a lot to learn...it seems
04:58:52 <quicksilver> o^_^o: you were sort of right, but see all the above
04:59:01 <dankna> you just mentioning now that it attaches to definitions explains to me why I could never figure out what the indentation for it should be
04:59:02 <o^_^o> quicksilver, yes
04:59:13 <dankna> I kept trying to put it in the MIDDLE of a do-block, for example
04:59:38 <quicksilver> lambdabot used to have a bug which accepted an invalid 'where' which didn't help.
04:59:41 <o^_^o> I don't know how to use let .... in :-)
04:59:41 <quicksilver> > a where a = 5
04:59:42 <lambdabot>   <no location info>: parse error on input `where'
04:59:47 <o^_^o> because I always have used where
04:59:48 <quicksilver> that's been fixed though :) phew.
04:59:53 <McManiaC> o^_^o:
04:59:56 <McManiaC> shiny name
04:59:56 <McManiaC> :>
05:00:09 <Cale> > let x = 5 in x^2 + x + 1
05:00:09 <lambdabot>   31
05:00:13 <o^_^o> McManiaC, don't ask long story, someone stole my name
05:00:20 <McManiaC> hehe
05:00:58 <McManiaC> let x = a where a = 5 in x
05:01:01 <McManiaC> > let x = a where a = 5 in x
05:01:02 <lambdabot>   5
05:01:20 <McManiaC> :D
05:01:22 <dankna> doesn't that example attach where to an expression, McManiaC?
05:01:31 <Cale> > let in let in let in let in 5
05:01:31 <lambdabot>   5
05:01:46 <manjunaths> > x = a where a = 5
05:01:47 <lambdabot>   <no location info>: parse error on input `='
05:01:49 <dankna> oh!  no I see, it's attaching to the declaration of x
05:01:52 <McManiaC> dankna: the where belongs to "x = ..."
05:02:02 <manjunaths> > let x = a where a = 5
05:02:03 <lambdabot>   not an expression: `let x = a where a = 5'
05:02:08 <Cale> > let 0 = 1 in 0
05:02:09 <lambdabot>   0
05:02:10 <manjunaths> hmph
05:02:14 <McManiaC> lol
05:02:27 <Cale> (sorry, I'm probably not helping here ;)
05:02:32 <McManiaC> > do let x = a where a = 5
05:02:33 <lambdabot>   <no location info>:
05:02:33 <lambdabot>      The last statement in a 'do' construct must be an ...
05:02:36 <McManiaC> :D
05:02:45 <Cale> > let x = a where a = 5 in x^2
05:02:46 <lambdabot>   25
05:02:59 <manjunaths> > do x = a where a = 5
05:03:00 <lambdabot>   <no location info>: parse error on input `='
05:03:19 <manjunaths> that works for functions
05:03:23 <manjunaths> weird
05:03:36 <Cale> > do let x = a where a = 5; u <- [x, x^2, x^3]; return u
05:03:37 <lambdabot>   <no location info>: parse error on input `<-'
05:03:47 <Cale> > do let {x = a where a = 5}; u <- [x, x^2, x^3]; return u
05:03:48 <lambdabot>   [5,25,125]
05:04:01 <Cale> (with no layout, sometimes you need the braces)
05:04:21 <Cale> manjunaths: x = a isn't a valid statement on its own inside a do-block
05:04:26 <ivanm> @ask malcolmw with polyparse, how can I do adjustErr on something like "bracket bra ket p" ? if the ket parser fails, then the entire thing fails; the error message isn't adjusted (and for some reason even when I use a custom definition of bracket which doesn't commit, it doesn't seem to want to go to the next option using `onFail` :s )
05:04:26 <lambdabot> Consider it noted.
05:04:44 <Cale> manjunaths: You need 'let' if you want to introduce declarations in the middle of a do-block
05:04:55 <manjunaths> I have atleast 3 people at work, who've got an haskell infection from me...
05:05:14 <manjunaths> Cale, ok
05:05:21 <Cale> manjunaths: and there's a special syntax inside of do-blocks where you can leave the 'in' part of the 'let' out, and the definitions scope over the rest of the block
05:05:54 <manjunaths> Cale, I've yet to come across them...I think...
05:05:55 <kevinulin> cale i hate that though, it makes my code so unreadable
05:06:11 <kevinulin> makes me want to add a "<- return $"
05:06:24 <Cale> That's better than let?
05:06:26 <dankna> I actually love that syntax
05:06:34 <kevinulin> yes, because the lets just come outta no where!
05:06:39 <Cale> eh?
05:07:17 <manjunaths> I have the same problem I think
05:07:24 <manjunaths> let .... in x
05:07:27 <manjunaths> in what ?
05:08:00 <manjunaths> expression where ... all the things in the above expression are these things
05:08:08 <Cale> If the let is the first line of your do-block, you always have the option of using where instead
05:08:09 <manjunaths> so easy on my newbie brain
05:08:16 <quicksilver> in what? in x!
05:08:23 <quicksilver> let x = 5 in (x+12)
05:08:27 <quicksilver> what could be clearer?
05:08:32 <quicksilver> (parens are for emphasis)
05:08:56 <roconnor> > let x = 5 in (x+12)
05:08:57 <lambdabot>   17
05:09:18 <manjunaths> quicksilver, sometimes there is no expression only something x or y, that is unnerving
05:09:21 <manjunaths> let x = 5 in x
05:09:24 <manjunaths> > let x = 5 in x
05:09:25 <lambdabot>   5
05:09:27 <Cale> > let evens = 0 : map (+1) odds; odds = map (+1) evens in evens
05:09:28 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
05:09:43 <quicksilver> manjunaths: well that is pointless
05:09:46 <manjunaths> everything is subsumed before the in
05:09:53 <quicksilver> manjunaths: "let a = 5 in y" <- quite pointless
05:10:01 <manjunaths> quicksilver, yeah
05:10:10 <quicksilver> the "in-part" must mention at least one of the variables
05:10:11 <manjunaths> ok I got to go for evening breakfast
05:10:14 <quicksilver> otherwise why bother?
05:10:23 <manjunaths> bbl
05:10:31 <opqdonut> quicksilver: but "let x = longexp; y = anotherexp; z = longexp x y in z" is pretty ok
05:10:34 <manjunaths> thanks everyone for all the knowledge :-)
05:11:10 <Cale> and if the in part is equal to one of the variables you defined, you also often might consider just sticking the definition into the in part on its own (provided it's not recursive)
05:11:26 <Cale> But if it's recursive, you might not be able to do that :)
05:11:30 <Jafet> Recursion is easily fixed!
05:11:38 <Cale> sure
05:13:34 * hackagebot gnuplot 0.3.4 - 2D and 3D plots using gnuplot  http://hackage.haskell.org/package/gnuplot-0.3.4 (HenningThielemann)
05:13:34 <Cale> > fix (\ ~(evens, odds) -> (0 : map (+1) odds, map (+1) evens))
05:13:35 <lambdabot>   ([0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,...
05:13:57 <ski> > [(x,xs) | x:xs <- tails "abcd"]  -- kmc
05:13:58 <lambdabot>   [('a',"bcd"),('b',"cd"),('c',"d"),('d',"")]
05:14:16 <ski> Eelis : it'd be nice if there was a working declarative debugger ..
05:19:15 <Twey> kmc:
05:19:24 <Twey> @let chomp = take 1 &&& drop 1
05:19:26 <lambdabot>  Defined.
05:19:36 <Twey> @let pick = map (first head) . takeWhile (not . null . fst) . iterate (chomp . snd) . chomp
05:19:37 <lambdabot>  Defined.
05:19:42 <Twey> > pick "abcd"
05:19:43 <lambdabot>   [('a',"bcd"),('b',"cd"),('c',"d"),('d',"")]
05:20:22 <PeakerWork> Cale: Why does referential transparency make it meaningless to toy around with IO state in a debugger?
05:24:53 <dankna> yeah, I don't think it makes it meaningless at all
05:25:21 <quicksilver> PeakerWork: it doesn't, at all, but toying around with IO State is a niche activity in haskell programming.
05:26:09 <alpounet> > uncurry (++) . (drop &&& take) $ 4 ['a'..'z']
05:26:10 <lambdabot>   No instance for (GHC.Num.Num ([GHC.Types.Char] -> GHC.Types.Int))
05:26:10 <lambdabot>    arisin...
05:26:25 <alpounet> > (uncurry (++) . (drop &&& take)) 4 ['a'..'z']
05:26:26 <lambdabot>   "efghijklmnopqrstuvwxyzabcd"
05:26:29 <quicksilver> your IO state should just be a thin layer injected into some more functional arrangment, in which a traditional debugger probably isn't what you want
05:27:37 <Botje> > uncurry (flip (++)) . splitAt 4 $ ['a'..'z']
05:27:39 <lambdabot>   "efghijklmnopqrstuvwxyzabcd"
05:27:47 <alpounet> > (drop ++ take) 4 ['a'..'z']
05:27:48 <lambdabot>   "efghijklmnopqrstuvwxyzabcd"
05:28:10 <PeakerWork> quicksilver: the question is whether it's rare and thus unusable, or unusable and thus rare :)
05:28:10 <Jafet> :t (++)
05:28:11 <lambdabot> forall m. (Monoid m) => m -> m -> m
05:28:21 <Botje> alpounet: heh, funky :)
05:28:24 <PeakerWork> quicksilver: I really would love a debugger for the IO part of my program
05:28:24 <dankna> > reverse $ dropWhile isSpace $ reverse $ dropWhile isSpace $ "  foo  "
05:28:25 <lambdabot>   "foo"
05:28:31 <dankna> my favorite little Haskell haiku :)
05:28:35 <alpounet> Botje, that's Caleskell afaik
05:28:40 <PeakerWork> dankna: Use . instead of $ for all but the last $
05:28:44 <dankna> oh good point
05:28:54 <dankna> > reverse . dropWhile isSpace . reverse . dropWhile isSpace $ "  foo  "
05:28:56 <lambdabot>   "foo"
05:28:59 <alpounet> @type (++) -- belongs to Monoid here
05:28:59 <Jafet> Nothing wrong with more $
05:29:00 <lambdabot> forall m. (Monoid m) => m -> m -> m
05:29:11 <tibbe> dcoutts, dcoutts_: It would be great if you could give your opinion on the gtk2hs SoC proposal. If you think it's not worth it we might drop it.
05:29:16 <PeakerWork> Jafet: more $'s cannot be cut&pasted into a separate definition
05:29:24 <zygoloid> > ap (zipWith (flip const)) (drop 4 . cycle) ['a'..'z']
05:29:25 <lambdabot>   "efghijklmnopqrstuvwxyzabcd"
05:29:28 <PeakerWork> Jafet: (.) is associative and ($) isn't
05:29:29 <dankna> where can I read that proposal?
05:34:13 * dankna wishes he were eligible to participate in Summer of Code :(
05:35:57 <Botje> enroll your younger $SIBLING :]
05:36:01 <dankna> haha
05:36:19 <Botje> he/she gets a free tshirt and you get the monies
05:36:27 <Botje> and an awesome summer job :P
05:36:36 <dankna> she's not eligible either, and also not a programmer, haha
05:37:32 <dankna> but yeah, it would be about the job more than the money, but I can't afford to just donate my time without the money
05:41:56 <Botje> the perl foundation hands out grants so people can hack
05:42:03 <dankna> do they?  good to know!
05:42:06 <Botje> perhaps if haskell keeps failing at avoiding success, they can do the same :)
05:42:09 <dankna> I wish I were more ofa Perl fan :)
05:42:11 <dankna> yeah hahaha
05:42:14 <dankna> that would rock
05:56:42 <madhadron> Has anyone else been unable to use getPeerCred from Network.Socket in the latest network package on MacOS X?
05:57:05 <madhadron> (It's coming up as not in scope; same code compiles and runs flawlessly on Linux)
05:58:30 <dankna> never tried it... hmmmmmm
06:02:00 <madhadron> Yes, it's not a typical thing in the Haskell world
06:02:11 <madhadron> I think most folks don't try to write daemons communicating via unix domain sockets in Haskell
06:02:22 <madhadron> (Though I have to say, it works great aside from this)
06:05:44 <roconnor> every monad is an arrowchoice?!
06:06:05 <danderson> I've written daemons communicating over unix sockets in haskell.
06:06:05 <roconnor> arrowplus isn't the same as arrowchoice?!
06:06:13 <danderson> Nothing fancy, but the basic use works great.
06:06:15 <vegai> I've written one, badly :)
06:06:24 <madhadron> danderson, I agree.  And on Linux, this is no problem.
06:06:29 <madhadron> But this one function vanishes on MacOS
06:06:43 <vegai> using the RWH example as a starting point might not be the best idea... but then again, what else is there
06:06:50 <danderson> madhadron: huh.
06:07:04 <danderson> does that function exist in the libc on MacOS?
06:07:10 <madhadron> It's supposed to...
06:07:20 <madhadron> It's a required function in the POSIX standard
06:07:30 <danderson> if so, it may just be a configure bug that disables that feature incorrectly (eg. can't find the library because some magic OS X flag doesn't get passed or something)
06:07:41 <danderson> I'd pull down the source of network and poke around in it
06:07:53 <danderson> look for an include guard around the function, then trace it back up to the configure script
06:08:04 <madhadron> I'll give that a try, thanks
06:10:10 <roconnor> @src ArrowChoice
06:10:10 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
06:10:37 <madhadron> Lambdabot, the first of our robot overlords.
06:11:30 <roconnor> this digaram should be added to the haskell wiki: http://4.bp.blogspot.com/_gNlz8IC_a0M/S8BOOlSbq6I/AAAAAAAAADk/qaAWYt5ODeg/s1600/effects.png
06:11:47 <madhadron> Aha, MacOS appears to put its peer credit functions elsewhere.
06:12:34 <madhadron> Right, time to install Linux on VMWare
06:12:43 <dankna> yes - very useful diagram, roconnor
06:12:48 <roconnor> not mine
06:12:50 <gio123> http://osdir.com/ml/lang.swi-prolog.general/2007-03/msg00074.html
06:12:54 <roconnor> http://just-bottom.blogspot.com/2010/04/programming-with-effects-story-so-far.html
06:12:56 <gio123> can one help me wuth this?
06:13:07 <mercury^> roconnor: In what way does a functor compose pure functions with effectful computations?
06:13:10 <roconnor> I didn't realize Category was the same kinda structure as Functors Arrows and Monads
06:13:22 <danderson> madhadron: somewhere else?
06:13:36 <madhadron> danderson, ...or not at all.
06:13:46 <madhadron> Weird.  Well, this is why I don't deploy services on OS X
06:13:50 <mercury^> Also, what's a dynamic DAG?
06:13:50 <danderson> heh
06:13:58 <roconnor> mercury^: map takes a pure function f and an effectful computation, say list A  and transforms that effectuful computation, keeping the effects, but changing the return value.
06:14:15 <danderson> madhadron: by religion, I avoid contact with OS X at all costs, but it's strange that it doesn't implement the POSIX APIs, given its BSD roots.
06:14:19 <gerry__> hello
06:14:26 <Botje> hello!
06:14:33 <madhadron> danderson, Yeah, all they would have to do is not screw up what's already there.
06:14:36 <ivanm> gio123: this doesn't seem like the correct channel for that... >_>
06:14:44 * ivanm waves idly in gerry__'s general direction
06:14:48 <roconnor> mercury^: a dynamic dag is kinda a bad way of saying it.  It means the next effects can be based on the values of previous computations.  Eg. ...
06:14:49 <gio123> :)
06:14:51 <gio123> maybe
06:14:54 <madhadron> I find it comfortable on a laptop, though.
06:14:58 <gerry__> need i master monad to master haskell?
06:15:25 <madhadron> gerry, No, just endofunctors obeying assorted axioms. (:
06:15:25 <danderson> I used a mac laptop for 2 years, then went back to linux on a thinkpad
06:15:32 <danderson> the only thing I miss is the backlit keyboard.
06:15:40 <roconnor> mercury^: consider the difference between liftA3 if' (return True) (Just 5) Nothing  and do {x <- return True; if x then Just 5 else Nothing}
06:15:45 <mercury^> roconnor: "Applying pure functions to effectful computations" might be better for functor I think.
06:15:55 <Botje> gerry__: they will make your code more elegant, yes
06:15:56 * danderson hugs his xmonad, sane APIs, good package manager...
06:15:57 <madhadron> danderson, Huh.  I find the backlighting annoying, but then I haven't actually looked at the keys in years.
06:15:59 <roconnor> mercury^: probably.
06:16:02 <Botje> but they do not add power to haskell by themselves
06:16:09 <roconnor> > liftA3 if' (return True) (Just 5) Nothing
06:16:10 <lambdabot>   Nothing
06:16:11 <Botje> gerry__: except for the IO monad, which does :P
06:16:11 <ivanm> gerry__: there are several tutorials on how to use IO without knowing how monads work
06:16:18 <greedo> pastorn: what about instead of readFile, i use openFile
06:16:25 <ivanm> to eventually "master" haskell, you will need to learn monads at some point
06:16:31 <roconnor> > do {x<-return True; if x then Just 5 else Nothing}
06:16:32 <lambdabot>   Just 5
06:16:34 <ivanm> but you don't have to go and invent a new monad to do so ;-)
06:16:53 <roconnor> ivanm: arguably to master any language you will need to learn monads at some point.
06:16:55 <gerry__> ok, i have to understand monad anyways
06:17:10 <ivanm> roconnor: really?
06:17:13 <roconnor> yep
06:17:20 <ivanm> even if they don't have explicit monads?
06:17:28 <gerry__> roconnor: ?
06:17:33 <roconnor> ivanm: a monad is just a data structure
06:17:35 <ivanm> hmmmm.... what would matlab's monad be? the Matrix monad? :p
06:17:50 <ivanm> roconnor: ((->) a) is a data structure? :o
06:17:51 <ivanm> :p
06:17:53 <madhadron> ivanm, StateT (Map String Matrix) IO
06:17:54 <gerry__> i know scala,clojure both have monad
06:18:01 <ivanm> madhadron: heh
06:18:04 <roconnor> ivanm: there is no Haskell's monad.  There is just readMonad, writerMonad, etc.
06:18:08 <roconnor> those are all languge independent
06:18:15 <Botje> gerry__: don't stare yourself blind at them. learn regular haskell first
06:18:23 <ivanm> roconnor: right, the process they use can all be considered to be monadic
06:18:38 <Botje> gerry__: once you get annoyed at the boilerplate code you write over and over again, look into monads that abstract that away
06:18:42 <roconnor> monad is a very useful abstraction in any language
06:18:43 <ivanm> roconnor: however, there are probably aspects of other languages which haskell doesn't explicitly have that can be considered to be part of haskell as well
06:18:50 * ivanm can't think of any atm, but that doesn't mean they aren't there
06:18:56 <roconnor> though particularly useful in haskell because of haskell's syntaxtic sugar
06:19:13 <ivanm> roconnor: and I don't see how understanding monads would help you for most languages
06:19:14 <mercury^> I don't get how Applicative is parallel composition either. The only thing I understand is Category.
06:19:29 <FunctorSalad> what's the cleanest way to prevent a berserking ghc from stopping the system for a minute? ulimit on memory usage?
06:19:35 <FunctorSalad> or is there some built-in flag
06:19:41 <roconnor> ivanm: how else are you going to write a backtracking stateful search in another language?
06:19:47 <roconnor> ivanm: probably in some crappy way
06:19:49 <FunctorSalad> *ghci, in this case
06:19:59 <ivanm> roconnor: tbh, I wouldn't, since I would do it in Haskell :p
06:20:00 * hackagebot hs-gizapp 0.1.0.2 - Haskell wrapper around the GIZA++ toolkit.  http://hackage.haskell.org/package/hs-gizapp-0.1.0.2 (EricKow)
06:20:13 <gerry__> i know many languages have list comprehension,and i don't know whether they are implemented by monad
06:20:17 <roconnor> ivanm: then you haven't mastered those other languaged :D
06:20:40 <ivanm> roconnor: I don't claim to have mastered Haskell either ;-)
06:20:45 <ivanm> @karma GIZA
06:20:45 <lambdabot> GIZA has a karma of 1
06:20:53 <FunctorSalad> (stoppage due to taking all the memory, followed by trashing, I think)
06:21:02 <Botje> gerry__: haskell list comprehensions are not implemented "by monad" either
06:21:07 <roconnor> mercury^: applicative is kinda like map by now the previously pure function can now be effectful [(+2),(*2)] <*> [1,2,3]
06:21:11 <madhadron> Botje, Any more.
06:21:18 <ivanm> @tell kowey what a way to add karma to GIZA: have hackagebot announce a package which does the karma adding for you!
06:21:18 <lambdabot> Consider it noted.
06:21:23 <madhadron> FunctorSalad, I'd go for your system facilities.
06:21:25 <gerry__> botje: ?
06:21:38 <mercury^> roconnor: Yes, but that isn't parallel composition.
06:21:41 <Botje> madhadron: spj's 1986 book didn't talk about using monads either :)
06:21:44 <roconnor> mercury^: it is really isn't exactly parallel  but all the parameters
06:21:47 <roconnor> mercury^: ya
06:21:58 <mercury^> It's applying an effectful transformation to an effectful value.
06:21:59 <madhadron> gerry, List comprehensions in Haskell used to be monad comprehensions.
06:22:03 <Botje> gerry__: list comprehensions are translated to nested concatMap / filter code
06:22:08 <roconnor> mercury^: I guess the diagram as it is worded now is only helpful if you already understand each box :)
06:22:17 <roconnor> mercury^: maybe it can be improved to be clearer
06:22:50 <madhadron> mercury, Probably better to say "Composing and applying functions on the far side of the functor" for applicative, or something to that effect
06:23:00 <FunctorSalad> madhadron: something like "ulimit -S -m 1000000; ghci"?
06:23:13 <gerry__> Botje: i dont understand
06:23:14 <FunctorSalad> never used ulimit so I'm not sure if the ghci is in its scope that way ;)
06:23:28 <madhadron> FunctorSalad, Honestly, I don't remember.
06:23:55 <FunctorSalad> (that is supposed to set the soft limit for total memory to 1gig)
06:24:52 <Botje> gerry__: [ x | x <- [1..], even x] is translated to filter even (concatMap (\x -> [x]) [1..])
06:25:02 * hackagebot hs-gizapp 0.1.0.3 - Haskell wrapper around the GIZA++ toolkit.  http://hackage.haskell.org/package/hs-gizapp-0.1.0.3 (EricKow)
06:25:19 <gerry__> i only know list comprehension can use do syntax
06:25:49 <Gracenotes> concatMap (\x -> if even x then [x] else [])
06:26:04 <gerry__> Botje: you mean i can't use do syntax in list comprehension now?
06:26:13 <Gracenotes> ..or something like
06:26:40 <Botje> gerry__: what? list comprehensions are not do blocks
06:26:55 <Botje> gerry__: i'm just saying the compiler translates them to filter / concatMap before doing anything else
06:26:59 <FliPPeh> Could someone name me the prime difference between System.Time and Data.Time? Seems like the Data version is recommended, but things like getModificationTime use System.Time
06:27:05 <Botje> they're just syntactic sugar
06:28:29 <roconnor> FliPPeh: System.Time is kinda like the C time library and sucks in all the ways the C time library sucks
06:28:34 <gerry__> Botje: ok,thx
06:28:39 <FliPPeh> roconnor: Works for me!
06:29:32 <ski> roconnor : `ArrowChoice' is roughly that your categoy has coproducts, while `ArrowSum' is similar to being in a preadditive category : each morphism class forms a monoid
06:29:55 <roconnor> ski: a monoidal category?
06:29:57 <roconnor> oh no
06:30:09 <roconnor> the morphisms are the monoid not the objects
06:30:17 <ski> ivanm : yes, `((->) a)' is a data structure type (function)
06:30:18 <FliPPeh> Is there a nice way to convert a System.Time.ClockTime to a Data.Time.UTCTime ?
06:30:37 <ski> roconnor : you define what an enriched category is, relative a monoidal category
06:30:39 <gerry__> Ambiguous module name `Control.Monad.State': it was found in multiple packages: mtl-1.1.0.2 monads-fd-0.0.0.1
06:30:40 <madhadron> roconnor, That one always seems to throw people.
06:30:52 <gerry__> should i hide which one?
06:30:57 <ski> roconnor : think of `ArrowSum' as a category enriched over `Mon', the category of monoids
06:31:07 <madhadron> gerry, Probably hide monads-fd unless you're explicitly using it
06:31:10 <gerry__> mtl or monads-fd?
06:31:22 <FunctorSalad> ulimit -S -t 1; (echo :m +Data.Function; echo fix error;) | ghci -ignore-dot-ghci
06:31:29 <gerry__> madhadron: i have qi installed which need it
06:31:31 <FunctorSalad> (hurr hurr, works)
06:32:03 <FunctorSalad> the -ignore-dot-ghci is just because mine is the debugee here ;)
06:32:05 <madhadron> gerry, Then you'll need to explicitly tell it not to load one or the other.
06:32:11 <madhadron> There's a ghci flag for it, what was it...
06:32:42 <chrisdone> madhadron: hey there :-)
06:32:47 <madhadron> -hide-package
06:32:51 <FunctorSalad> (doesn't fix the error, though)
06:32:58 <FunctorSalad> madhadron: ghc-pkg hide?
06:32:58 <chrisdone> nice documentation on blaze, I was reading it yesterday
06:33:04 <madhadron> chrisdone, Thanks
06:33:46 <madhadron> I realized the ugly truth a while back: I'm probably a better writer than programmer.
06:34:02 <chrisdone> hehe
06:43:01 <cads> Is there a multiset (bag) implementation with a powerset function?
06:43:05 <cads> Heh, powerbag?
06:43:18 <cads> For example 2^{(a,2), (b, 1)} = {{(a,2), (b, 1)},  {(a,1), (b, 1)},  {(a,2)},  {(a,1)},  {(b, 1)}}
06:44:28 <cads> More succinctly 2^{aab} = {{aab}, {ab}, {aa}, {b}}. :P
06:45:13 <Jafet> > (inits >=> tails) [x, x, y]
06:45:14 <lambdabot>   [[],[x],[],[x,x],[x],[],[x,x,y],[x,y],[y],[]]
06:45:36 <Jafet> > [] : filter (not.null) ((inits >=> tails) [x, x, y])
06:45:37 <lambdabot>   [[],[x],[x,x],[x],[x,x,y],[x,y],[y]]
06:45:50 <Jafet> Hm, not quite
06:46:03 <FunctorSalad> hmm, Pow(S) ~ (S -> 2) whereas MultiPow(B) ~ (pi x,  number of x in B)
06:46:07 <cads> > filter (not.null) ((inits >=> tails) [x, x, y])
06:46:08 <lambdabot>   [[x],[x,x],[x],[x,x,y],[x,y],[y]]
06:46:23 <FunctorSalad> +1 even
06:46:28 <FunctorSalad> (the number incremented by 1)
06:46:41 <cads> yup, FunctorSalad
06:47:01 <FunctorSalad> and numbers identified with sets of their cardinality
06:47:09 <cads> > filter (not.null) ((inits >=> tails) [x, y, y])
06:47:10 <lambdabot>   [[x],[x,y],[y],[x,y,y],[y,y],[y]]
06:47:22 <cads> I have no idea why that works :)
06:47:30 <dv-> Anyone know if there's some way to make yi not display -> and \ not display as fancy characters that my term can't render?
06:47:36 <cads> @type (>=>)
06:47:36 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
06:47:40 <Jafet> It generates subsequences, which I confused with multiset subsets
06:47:46 <Jafet> ("multisubsets"?)
06:48:07 <cads> not sure if it'll work for more than two elements then
06:48:27 <cads> > filter (not.null) ((inits >=> tails) [x, z, x, y])
06:48:28 <lambdabot>   [[x],[x,z],[z],[x,z,x],[z,x],[x],[x,z,x,y],[z,x,y],[x,y],[y]]
06:49:01 <cads> I don't see any repeats..
06:50:16 * madhadron looks confused as Xubuntu informs him it is 128% of the way through computing new partitions...
06:50:46 <FunctorSalad> like lolcats "fixing" your computer?
06:50:54 <madhadron> Seems that way
06:50:57 <FunctorSalad> (random association)
06:50:58 <madhadron> Thankfully it's inside VMWare
06:50:58 <greedo> hehe
06:51:15 <greedo> VMWare for the win
06:51:45 <dankna> yay vmware
06:52:14 <p_l> heh, 128%... you should see a battery that has +Inf capacity.
06:52:27 <Axman6> :o
06:52:36 <dankna> my battery has negative-zero capacity :)
06:52:45 <madhadron> p_l, That's not as classic as little Johnny tables, but getting there.
06:53:11 <p_l> madhadron: getting >100% on battery meter is actually perfectly normal
06:53:18 <eevar2> mine's at nan%
06:53:23 <p_l> .me did that several times trying to recover a little of his battery.
06:53:35 <madhadron> Fair enough
06:53:44 <p_l> eevar2: the difference is usually in what mode the calculating code set the FPU...
06:55:42 <cads> 2^{aabc} = {aabc, aab, aac, aa, abc, ab, ac, a, bc, b, c, {}}  -  blahrg, subsequences won't work anyways because consider ..bbb.. ; this produces two copies of the subsequence ..bb..
06:55:49 <EvanR-work> my battery has green 00 capacity
06:56:18 <cads> I think that a 'multisubset' should be called a 'baggie'
06:56:55 <ski> cads : `[x,z]' and `[z,x]'
06:57:26 <cads> oh there's that too
06:57:49 <madhadron> cads, I dunno, subbag's pretty fun, too.  Sounds like something you call someone before getting hit.
06:57:52 <ski> subbag
06:58:09 <madhadron> "Yo, subbag!  You got a problem?"
06:58:21 <EvanR-work> whats the difference between a bag and a set
06:58:34 <ski> `{a,a} = {a}' for sets
06:58:38 <madhadron> EvanR, A bag allows multiple occurrences of an entry
06:58:43 <EvanR-work> ah
06:58:54 <madhadron> But order is still unimportant
06:59:41 <roconnor> A -> bool -- set
06:59:45 <roconnor> A -> Nat -- bag
07:00:15 <madhadron> Got to love #haskell, where a simple question gets a simple answer
07:00:24 <madhadron> in category theory or as a set of defining axioms
07:00:31 <EvanR-work> is there a way to choose a random item from a bag ? :)
07:01:02 <roconnor> a bag is like a pre-sheef over natrual numbers
07:01:07 <roconnor> no wait, that's not right at all
07:01:08 <madhadron> Sure, you just weight by the number of repretitions
07:01:22 <madhadron> Assuming you want an uniform distribution
07:01:52 <cads> EvanR sure, your item's probability for each element is just the count of the element divided by the size of the bag.
07:01:58 <EvanR-work> computationally
07:02:02 <EvanR-work> is what i meant
07:02:25 <madhadron> Well, you would usually represent a bag as a set with a natural number attached to each element to show the repetition
07:02:50 <madhadron> So there are many straightforward ways of doing it
07:03:17 <EvanR-work> so if you had a way of producing uniform between 0 and m where m is total items in bag...
07:03:18 <madhadron> Or if random numbers are cheap, you could select an element, and then with a probability proportional to the repetition reject it
07:03:30 <madhadron> like in Monte Carlo integration
07:03:35 <EvanR-work> m-1
07:03:44 <cads> EvanR, you could construct a discrete distribution reflecting the weights of each item and then sample that distribution to know which item you chose.
07:04:21 <cads> so if you have {aaab}, make a random function that spits out 'a' 75% of the time and 'b' 25% of the time.
07:04:30 <EvanR-work> ok
07:04:55 <EvanR-work> that means 0 through 3 uniform (easy because power of two) and 012 -> 'a', 3 -> 'b'
07:05:08 <dankna> my intuition is that in Haskell random numbers are expensive enogh that you want to do it with only one of them.
07:05:12 <madhadron> Or you could just treat each repetition as a distinct entry, turning it back into a set, and then sample as you would for sets
07:05:22 <madhadron> dankna, That's purely a question of your generator.
07:05:32 <dankna> I was doing a loop computing a million of them and it was taking more than 20ms to do it
07:05:42 <dankna> so I had to change the algorithm to only need a few hundred per iteration
07:05:48 <cads> twenty milliseconds!
07:05:56 <dankna> well, when it's a game, 20ms is a long time :(
07:06:07 <dankna> anyway your needs may vary :)
07:06:10 <madhadron> dankna, Yeah, being profligate with your random numbers isn't a great idea
07:06:22 <madhadron> Though if you only need a few bits you can often do things like sample and takes pieces of the bits
07:06:30 <madhadron> provided your generator has equally nice bits throughout
07:06:38 <EvanR-work> ill need to test the speed of my lazy mwc generator with dieharder or something, though i suspect stdin reduces speed by a factor of 10
07:06:45 <dankna> I'm just offering advice.  But don't assume, measure.
07:07:42 <EvanR-work> and Integer rather than Word32 probably has some overhead ;)
07:07:53 <dankna> haha yes, probably
07:07:54 <madhadron> Evan, Notably...
07:08:10 <EvanR-work> but Integer makes stuff so easy :)
07:08:42 <EvanR-work> i dont know how people cope with C numeric types
07:08:53 <madhadron> You could always go write Common Lisp or Scheme where it's supposed to overflow to arbitrary precision when you need it
07:08:54 <ski> (roconnor : actually `A -> bool' are subsets (of `A') :)
07:09:02 <cads> roconnor: what do we get if we allow A -> Z or A -> R or A -> C as the indicator functions to our screwy sets?
07:09:18 <madhadron> cads, A -> R is fuzzy logic, more or less
07:09:43 <madhadron> A -> Z allows for the existence of anti-elements, a la quantum field theory
07:10:04 <madhadron> (so you could have a set {-a}, which when unioned with {a} is empty set)
07:10:21 <EvanR-work> these are still bags right
07:10:26 <ski> cads : Chu categories (and Dialectica and PV, iirc) does something a but similar .. using an "arbitrary object" (well probably with some restrictions) as a "truth-value object"
07:10:35 <EvanR-work> bags of particles and anti particles
07:10:37 <madhadron> A -> C looks like quantum mechanics on a discrete space
07:10:41 <madhadron> Evan, Right
07:10:46 <madhadron> Sorry, bags, not sets
07:11:07 <Jafet> > let pms [] = [[]]; pms ((x,n):xs) = ap (++) (flip map [1..n] . flip ((:) . (,) x) =<<) (pms xs) in pms [(x,1), (y,2), (z,3)]
07:11:08 <lambdabot>   [[],[(z,1)],[(z,2)],[(z,3)],[(y,1)],[(y,2)],[(y,1),(z,1)],[(y,2),(z,1)],[(y...
07:11:20 <EvanR-work> A -> Q
07:12:32 <madhadron> Evan, Oh come on, you don't want to use a non-Cauchy space as your truth value!
07:12:32 <cads> ski, I've never heard of Dialectica or PV - are these theories of some sort, or perhaps programming systems?
07:12:44 <madhadron> Sorry, incomplete space
07:13:08 <madhadron> (Bad brain, don't confuse Cauchy sequences with completeness...)
07:13:35 <EvanR-work> heh
07:13:50 <cads> hmm, I was reading about something like this where we have toposes with an object BigOmega of truth values in that topos.
07:14:07 <EvanR-work> a sequence which converges but not to anything we previous knew about ;)
07:14:11 <madhadron> cads, Yup.  That's the general setting.
07:14:32 <madhadron> EvanR, Though I suppose there might be situations where you are interested in ratios of particle/antiparticle creation in two parallel universes...
07:14:39 <madhadron> But even then I think you'd end up in R
07:14:49 <madhadron> Life without limits is rough in infinite spaces
07:14:52 <aavogt>  madhadron | You could always go write Common Lisp or Scheme where it's supposed to overflow to arbitrary precision when you need it
07:15:01 <EvanR-work> 'rough' heh.
07:15:10 <aavogt> gmp should represent small integers as machine ones
07:15:10 <madhadron> ...pun unintentional...
07:15:19 <EvanR-work> lol
07:15:25 <Saizan> ?src Integer
07:15:25 <lambdabot> data Integer = S# Int#
07:15:26 <lambdabot>              | J# Int# ByteArray#
07:15:56 <dankna> huh
07:16:09 <dankna> why is it J# Int# ByteArray# and not J# ByteArray#?
07:16:10 <quicksilver> aavogt: GHC does, although GMP doesn't, AIUI.
07:16:26 <fasta> dankna, length?
07:16:35 <dankna> if the Int# is the size field, it's got an upper bound on the size
07:16:46 <dankna> I thought there was some clever representation or something
07:17:04 <dankna> hmm
07:17:24 <EvanR-work> a list of digits 0 through 9 with bool as + or - ;)
07:17:27 <dankna> otoh if Int# is a machine word it can represent anything that can fit in the machine's address space
07:17:36 <ski> EvanR-work : also see the "Boom Hierarchy" .. appears to be explained ok (at quick glance) in <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.49.3252> by Alexander Bunkenburg
07:17:44 <dankna> EvanR: ah!  makes sense
07:18:05 <ski> cads : categories
07:18:15 <gio123> ski:hi
07:18:20 <fasta> What is the book of choice to learn about quantum field theory? (to keep off-topic)
07:18:27 <EvanR-work> Squiggol functions
07:18:31 * hackagebot CSPM-Frontend 0.2.10.2 - A CSP-M parser compatible with FDR-2.83  http://hackage.haskell.org/package/CSPM-Frontend-0.2.10.2 (MarcFontaine)
07:18:31 <madhadron> fasta, What level?
07:18:37 <madhadron> And how applied vs mathematical?
07:19:01 <madhadron> (And why is someone with a biological sequence format as a nick asking about QFT?)
07:19:03 <fasta> madhadron, I want to read something which is not dumbed down, but well written.
07:19:05 <dankna> fasta: Feynman's "Quantum Electrodynamics: The strange theory of light and matter" is an excellent introduction to QED for the intelligent layman.  That isn't what you asked but it's the only quantum-anything book I've ever actually understood?
07:19:28 <madhadron> fasta, Zee's 'Quantum Field Theory in a Nutshell' is a nice volume
07:20:19 <madhadron> Though it assumes a fair knowledge of nonrelativistic quantum mechanics first, as I recall
07:20:27 <madhadron> of the level of, say, Griffiths
07:20:39 <dankna> so QFT is an attempt to integrate quantum stuff with relativity?  interesting!
07:21:15 <madhadron> dankna, Well, originally it was an attempt to handle electromagnetism when the energy scales became comparable to what you need for particle production
07:21:17 <EvanR-work> relativity, not general relativity
07:21:20 <dankna> hmmmm
07:21:21 <dankna> okay
07:21:30 <madhadron> Right, what Evan said.
07:21:45 <madhadron> String theory, loop quantum gravity, and a bunch of others are attempts to make GR fit in the picture
07:21:51 <dankna> right
07:21:56 <dankna> I'm vaguely familiar with those
07:21:58 <fasta> Does QFT have any predictive value over other theories?
07:21:59 <dankna> so SR is easier to fit then
07:22:08 <dankna> which makes sense
07:22:36 <madhadron> fasta, In its domain (standard model, all of fundamental physics besides gravity) it's accurate to a disturbing number of decimal places
07:22:43 <madhadron> There really aren't other theories in that domain
07:22:56 <madhadron> There are alternative formulations, like Schwinger's source theory
07:23:05 <dankna> ("How many string theorists does it take to change a lightbulb?"  "Lightbulbs are theoretical at this time.")
07:23:14 <madhadron> But the math's the same in the end, and it's good to something like 21 decimal places
07:23:33 <madhadron> The limitation being how far out we have managed to calculate and to measure to compare them
07:23:35 <Axman6> dankna: "You'd have to ask a filament theorist
07:23:40 <dankna> Axman: HAH! :D
07:24:05 <EvanR-work> i heard the quark part of qft is computationally intractable
07:24:11 <madhadron> Evan, Horrribly so.
07:24:12 <gio123> ski
07:24:25 <madhadron> It's because the quanta of the field interact with themselves
07:24:25 <gio123> ski:
07:24:25 <dankna> well, that's unfortunate
07:24:27 <EvanR-work> doesnt sound like a great theory to me!
07:24:40 <dankna> well, there's no reason the universe has to be tractable, haha
07:24:44 <madhadron> So you can't just add up fields like in electromagnetism
07:27:57 <madhadron> But then, the perturbation theory series in QED diverge, so there are other issues at hand
07:28:26 <madhadron> and the basic idea of an interaction at a particular point in spacetime between two particles is an approximation, and cannot be taken too seriously...
07:28:54 <madhadron> so this is one of those cases where it's all kind of messy under the hood
07:30:26 <cads> ski, I chuckled at that paper's abstract: "No category theory required!"
07:32:41 <EvanR-work> madhadron: i never could understand where the math ended and real life began, like, experiment set and result data
07:32:50 <EvanR-work> like they were totally different worlds
07:33:11 <madhadron> Evan, That's a very common problem with quantum mechanics in general.
07:33:20 <madhadron> The reason is that the connection is via scattering calculations
07:33:26 <EvanR-work> definitely not as simple as '5 meters' and 5 written there on the stick
07:33:37 <madhadron> If you want to know how to do them, it's in Landau and Lifshitz, vol.3 for the nonrelativistic case
07:33:50 <madhadron> But it's *ugly*
07:33:55 <EvanR-work> scattering, so thats why we spent time on that in intro to qm
07:34:01 <EvanR-work> the boring stuff
07:34:15 <madhadron> Yeah.  The useful stuff.
07:34:35 <madhadron> Everything involving high energies is going to be through scattering data.
07:34:47 <EvanR-work> so theres a 'migration route' from non relativistic scattering to one that feeds on qft
07:35:36 <madhadron> Sure.  It's the same general setup.
07:35:47 <madhadron> The math just gets horrifically more difficult and infinities await you at every turn.
07:36:14 * cads will stay in mathemtics. where it's safe.
07:36:38 <cads> at this moment..
07:36:47 * cads gets monstrously devoured by a stack of sheaves!
07:37:08 <EvanR-work> you can definitely know where you stand in math
07:37:15 <madhadron> Got to watch out for the bundles of sheaves roaming the mathematical veldt.
07:37:41 <madhadron> Evan, Ever wandered off into nonstandard analysis?
07:37:59 * Saizan splits cads into an uncountable number of pieces and puts them back as two copies of him
07:38:02 <EvanR-work> i would imagine you still can say a lot of stuff for sure
07:38:08 <hpaste>  strange Coq response (roconnor)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24855
07:38:22 <madhadron> Evan, Definitely, but you start wondering if there's any ground beneath your feet
07:38:45 <EvanR-work> rather, you wonder if theres any other planets besides these few ;)
07:38:50 * zygoloid hands Saizan the axiom of choice
07:38:51 <EvanR-work> with different surfaces
07:38:54 * ski processes Saizan though a Blum-Shub-Smale machine
07:39:01 <madhadron> But then, who am I to talk?  I'm in biology these days.
07:39:23 * madhadron hides in Nelson's formulation of probability.
07:40:36 <madhadron> You want to talk about a field where you don't know where you stand...
07:41:10 <Axman6> Nelson says: Hey, you! gtfo of my formulation you bastard!
07:41:53 <madhadron> Axman, Naw, Nelson wouldn't do that.  He was very welcoming when I pointed out some oddball constructions to him.
07:41:58 <dankna> All these planets are yours save Europa.  Attempt no landing here.
07:42:10 <EvanR-work> hahaha
07:42:28 <madhadron> dankna, The question is whether we will come across a topos with such a theorem...
07:42:43 <Axman6> madhadron: he's very protective of his formulations though
07:42:47 <greyshrike> I suspected that dankna was a monolith  -- it all fits.
07:42:50 <madhadron> Have you read Egan's "Dark Integers"?
07:42:56 <ski> roconnor : ooc, what does Coq respond with ?
07:43:01 <madhadron> Axman, Oh well.
07:43:15 * Axman6 doesn't actually know who Nelson is
07:43:31 <madhadron> Axman, Professor at Princeton, wrote a little book called "Radically Elementary Probability Theory"
07:43:34 <madhadron> that I cannot recommend enough
07:43:54 <roconnor> ski:
07:43:56 <roconnor> Axioms:
07:43:57 <roconnor> Foo.trivial : True
07:44:32 <madhadron> Anyway, time to go home for the day.  Freedom from my machine...
07:44:41 <ski> roconnor : strange ..
07:45:02 <ski> roconnor : how does it prove the lemma ? .. somehow assuming the axiom to prove it ?
07:45:10 * ski doesn't know very much about Coq
07:45:24 <cads> Saizan: have you seen this: http://www.smbc-comics.com/index.php?db=comics&id=1829#comic ?
07:46:02 <roconnor> ski: not really.  It seems to thing all module parameters are axioms if they occur in the module signature.
07:46:10 <Saizan> cads: eheh, i did yesterday :)
07:49:24 <FliPPeh> Real World Haskell can't be serious
07:49:35 <FliPPeh> Needing 5 functions for something I replaced with "Right . fromJson"
07:49:41 <FliPPeh> With exactly the same result
07:49:56 <FliPPeh> They seem to love to spam functions at simple problems
07:50:12 <FliPPeh> Even if the function is as simple as just being an alias for a type constructor
07:50:29 <danderson> maybe consider that the final code is not relevant, and that it's an attempt to explain certain language concepts instead
07:50:39 <FliPPeh> jvaluesToJAry = JAry
07:50:40 <FliPPeh> jaryOfJValuesToJValue = JArray
07:50:44 <FliPPeh> :s
07:50:57 <ski> (FliPPeh : maybe they wanted to abstract the function from the current datatype representation ?)
07:51:26 <FliPPeh> Seems rather pointless, that function wouldn't be used outside the module at all
07:51:42 <FliPPeh> Because it's 1) not being exported, and 2) only used inside a typeclass instance
07:51:51 * ski sometimes does such factoring of layers, within a module
07:52:11 <ski> (well, i usually don't bother with making local aliases of data constructors, though)
07:54:16 <FliPPeh>  fromJson (JList [JNumber 6, JString "BORK"]) :: Either String [Double]
07:54:22 <FliPPeh> Right [6.0]
07:54:25 <FliPPeh> Autofilter, yay.
07:54:35 <jmcarthur> i tend to excuse books and tutorials teaching a language from writing verbose code because they have to teach those things anyway. it's hard to keep a reader interested if you just switch to a completely new example every time you have a new concept to teach. nicer to just extend an existing example, even if it's not necessary for the problem the example solves
07:54:37 <FliPPeh> Should change this, tho
07:55:00 <jmcarthur> *sometiems nicer
07:55:14 <jmcarthur> ugh, switch some letters around and it makes more sense
07:56:20 <FliPPeh> Probably so, but doesn't teaching include "teach"? I don't think throwing a bad style at people, with long and confusing names that only act as an alias for 4 character-long type constructors
07:56:34 <FliPPeh> I might be a little picky, but this really threw me off
07:56:46 <FliPPeh> "Is this how people really write Haskell? Gosh"
07:56:51 <jmcarthur> i agree with you. there's a threshold where it becomes annoying
07:56:59 <jmcarthur> it's hard to find
07:57:35 <FliPPeh> Even comments in the book think the same
07:58:02 <jmcarthur> maybe it was fixed in the dead tree version?
07:58:15 <FliPPeh> I doubt they changed a whole chapter :x
07:59:01 <FliPPeh> By the way, no that I'm on the topic..
07:59:18 <FliPPeh> If you were to defined, for example "just = Just".. would GHC optimize that away?
07:59:24 <FliPPeh> s/defined/define
07:59:28 <jmcarthur> probably
07:59:28 <EvanR-work> im thinking that programming language books only need to teach the features of the language and how they work, and a separate book for 'how to program the computer somehow' (SICP) applies to all sane languages
07:59:29 <quicksilver> yes.
07:59:33 <quicksilver> GHC inlines small functions.
07:59:50 <quicksilver> many of GHC's optimisations require small functions to inline
07:59:55 <quicksilver> s/function/value/
08:00:13 <jmcarthur> EvanR-work: SICP doesn't teach many of the abstractions we use in haskell
08:00:16 <EvanR-work> so if you read SICP first, which uses zero syntax language scheme, then you know how to program. then you can read what haskell can do for you
08:00:32 <EvanR-work> no, so after that you read haskell
08:00:54 <jmcarthur> if you only teach the language you never learn those abstractions. you have to do more than just the language
08:01:00 <EvanR-work> so my thesis is, cant teach programming and haskell at the same time
08:01:08 <jmcarthur> i disagree
08:01:20 <EvanR-work> or, is more involved
08:01:29 <EvanR-work> separation of concerns, factorization of education
08:01:44 <jmcarthur> i think both should be taught at once, and maybe once that's over with you go back over programming
08:01:54 <EvanR-work> hmm ok
08:02:33 <EvanR-work> i dont know haskell well enough to know, what are the 'strange' abstractions of features that people wont be familiar with?
08:02:34 <jmcarthur> fine to learn programming separately first, then learn a language, but that's not going to be enough because you dont' use haskell like you use scheme
08:03:02 <jmcarthur> for a common example, consider Monad
08:03:16 <jmcarthur> it's an abstraction, not a language feature
08:03:18 <EvanR-work> right, i havent successfully designed a monad
08:03:34 <jmcarthur> you don't design a monad ;)
08:03:51 <Ke> In soviet russia xmonad designs you
08:03:52 <jmcarthur> i mean, that's usually the wrong approach
08:04:23 <EvanR-work> then what, discover the natural monad structure?
08:04:33 <jmcarthur> "i want to write a web app with a new monad!" is not very helpful. "i need abstraction X which happens to be a monad" is a bit closer
08:04:59 <yottis> i usually just create a data type and iterate through all classes i can think of like "can i implement this and if yes, are the semantics sane?"
08:05:36 <yottis> well, at least the most common classes
08:05:37 <jmcarthur> or you can design by semantic model: "i need a type for this and i want it to have the same semantics as X" and if X is a monad then your new type should be a monad too
08:06:06 <jmcarthur> and since you are designing with a semantic model it's much more obvious how your monad should behave
08:12:14 <EvanR-work> jmcarthur: im thinking a lot of the example solutions to stuff in SICP are some form of haskell abstraction
08:13:46 <EvanR-work> im just reaching for a book or website or something that seriously teaches you how to program without the typical OOP dogma
08:14:08 <jmcarthur> OOP is not inherently bad, but i agree if you mean to emphasize the word "dogma"
08:15:00 <EvanR-work> im thinking its possible to do this with haskell
08:15:49 <jmcarthur> EvanR-work: yeah you're right that most of SICP applies to haskell, but SICP doesn't give any information about many of the abstractions we use in Haskell a lot
08:18:29 <vexp> Hi. In the comments for the web version of RWH, one of the comments claimed "IO does not introduce side-effects". Can someone explain this? To a newbie like myself, it seems like IO and a side effect would be the same thing. \:
08:19:14 <quicksilver> IO does not introduce any side effects to the process of evaluating expressions.
08:19:27 <quicksilver> evaluation remains side-effect free and that's what purity is about.
08:19:39 <quicksilver> the IO stuff only happens when you "perform" or "execute" the action
08:19:44 <quicksilver> something entirely separate from evaluation.
08:19:51 <jmcarthur> vexp: IO actions are just values. when evaluated, no side effects are performed. only when executed are they performed. the main function is executed by the runtime
08:20:15 <zygoloid> an expression of type "IO a" is essentially a recipe for performing some IO action which produces a value of type 'a'. that recipe is pure and building it does not introduce side-effects.
08:20:37 <zygoloid> when the program is run and follows the recipe, side-effects may occur.
08:20:54 <quicksilver> at which point I think you can drop the qualifier 'side-' ;)
08:21:06 <quicksilver> they're not side-effects of anything any more. They are the main effect of running the program.
08:21:30 <jmcarthur> vexp: the main distinction is that IO actions can be created without executing them. for example, you could create a list of actions but only execute the first action in the list
08:21:43 <jmcarthur> s/created/evaluated/
08:22:41 <vexp> So, it can only cause an effect once the program is run and that particular action is executed? So the point he was making is that IO in and of itself does not cause side effects, but when the action is performed it may?
08:22:48 <vexp> Or am I still misunderstanding?
08:23:45 <zygoloid> vexp: the point he was making was that evaluating expressions and executing IO are two entirely separate notions in Haskell
08:24:02 <vexp> zygoloid: Oh, okay.
08:24:19 <fasta> vexp, in particular one might say that it is impossible to execute anything in Haskell.
08:24:39 <zygoloid> and, for instance, "getLine >>= putStrLn" is an expression so cannot have side-effects.
08:24:58 <fasta> vexp, execution is beyond what people call Haskell; it is something implemented by something which interprets IO actions.
08:25:07 <gwern> jmcarthur: early on, a lot of sicp is obviated by laziness
08:26:09 <gwern> like the long example introducing HOFs - a haskeller would just define a loop/list and use take
08:29:53 <vexp> Thanks for the help, and sorry for the stupid question.
08:30:51 <quicksilver> vexp: it wasn't a stupid question at all. It was exactly the important question.
08:33:02 <Axman6> vexp: it might be helpful to think about IO as a DSL that creates C code which is compiled by the RTS and executed (it of course doesn't do that, but it helps demonstrate how IO is in a sense pure, and it is only when run that it produces any side effects)
08:33:55 <jmcarthur> i don't like the "it only performs effects when the program is run" explanation. one could make the same argument about a C program
08:34:15 <jmcarthur> the explanation at least needs to explain the different between evaluation and execution, IMO
08:34:18 <jmcarthur> *difference
08:38:13 <vexp> I guess the good news is, after understanding that, the rest of the IO section is pretty simple to understand.
08:38:37 <vexp> Monads really don't seem as difficult as they're cracked up to be, either.'
08:39:00 <quicksilver> they're not, no.
08:39:10 <quicksilver> the trick is not to compare them, in any way, with mexican food.
08:39:13 <quicksilver> that way lies madness.
08:39:26 <vexp> quicksilver: Heh.
08:39:41 <twink> Monads are burritos containing toxic waste?
08:39:59 <jmcarthur> yeah, the difficulty of monads is vastly overstated
08:40:14 <twink> There's so much less to them than meets the eye.
08:41:21 <vexp> I think monads are to haskell what parens/macros are to lisp or pointers are to c: something that's not that diffcult to understand, but for some reason is hyped up to be uber-difficult by people who don't know the language. \:
08:41:40 <aavogt> people hype parentheses?
08:42:02 <vexp> aavogt: That's pretty much the #1 reason I've heard for not learning Lisp: "too many parens!"
08:42:31 <aavogt> sure, but that doesn't say anything about difficulty
08:42:43 <jmcarthur> actually, the only way i find the huge number of parens in lisp to be acceptable is because of editor support. i get very lost without syntax highlighting and visual block indicators
08:43:13 <vexp> jmcarthur: I do agree somewhat. I wouldn't want to edit Lisp with a bare-bones editor, although I've done it before.
08:43:13 <danderson> then again, reading any code without editor support is just inflicting needless pain upon oneself
08:43:17 <danderson> regardless of language.
08:43:23 <jmcarthur> but i admit that the argument doesn't hold much ground if you consider the almost ad hoc fixities of operators that we have
08:43:33 <jmcarthur> at least parens are easy to memorize the rules for
08:43:52 <jmcarthur> and we don't even really have editor support for operator fixity
08:44:04 <aavogt> hopefully you've already learned the fixities of ^*+-
08:44:12 <fasta> jmcarthur, you are right about C, but in C it is not common to juggle with C actions, because you have to declare the type all the type you do that.
08:44:16 <vexp> jmcarthur: It's debatable. You're making a tradeoff when you choose one over the other, am I'm not 100% convinced either is best.
08:44:21 <fasta> the time*
08:44:23 <vexp> *and
08:44:23 <Saizan> operator fixities can be chosen to make "intuitive" sense, though :)
08:44:26 <jmcarthur> i still find fixity to be a bit easier to read since operators are a bit more visual
08:44:51 <aavogt> and using any fixities is optional
08:44:55 <cads> hmm, danderson haskell seems pretty readable without highlighting
08:45:01 <jmcarthur> Saizan: you mean by aligning with historical precedence
08:45:18 <Saizan> jmcarthur: and patterns of usage
08:45:26 <jmcarthur> yeah
08:45:50 <vexp> This is such a nice channel. We've just touched on the issue of prefix vs infix, and not a single holy war has appeared.
08:46:09 <aavogt> > ((+) 1 2)
08:46:10 <lambdabot>   3
08:46:24 <jmcarthur> > ((+) 1 2 3) -- fail
08:46:25 <lambdabot>   No instance for (GHC.Num.Num (t -> a))
08:46:26 <lambdabot>    arising from the literal `1' at <...
08:46:29 <Zao> vexp: circumfix!
08:47:00 <jmcarthur> > foldl1' (+) [1,2,3]
08:47:01 <lambdabot>   6
08:47:06 <cads> vexp, that's because we will break the limbs of religious types and thread them through four monads if they start any holy wards
08:47:15 <cads> wars*
08:47:58 <Zao> cads: notepad for life!
08:48:08 <zomgbie> "we will break the limbs of religious types" - hilarious! LOL
08:48:21 <cads> > let pms [] = [[]]; pms ((x,n):xs) = Control.Monad.ap (++) (flip map [1..n] . flip ((:) . (,) x) =<<) (pms xs) in pms [(1,1), (2,2), (3,3)]
08:48:22 <lambdabot>   [[],[(3,1)],[(3,2)],[(3,3)],[(2,1)],[(2,2)],[(2,1),(3,1)],[(2,2),(3,1)],[(2...
08:48:27 <Saizan> vexp: you should see e.g. Agda where you can define if_then_else_ as an operator and use it like in haskell
08:48:32 <jmcarthur> what is the kind of a religious type?
08:48:45 <jmcarthur> yeah i like Agda fixity
08:49:10 <twink> jmcarthur: You need a new key for "black hole" because * doesn't quite cut it for them.
08:49:20 <vexp> cads: That's part of the reason I've begun avoiding a lot of the Lisp community - too many of them think they're Erik Naggum, and that personal insults are the best response to anything . The haskell community, by contrast, is so nice. (:
08:49:58 <jmcarthur> that's a shame about the lisp community. such a turn off to those curious about functional programming
08:50:26 <quicksilver> jmcarthur: infix operators are a bit more 'bandwidth' for the way notation communicates with the reader.
08:50:36 <jmcarthur> i would probably not have been so drawn to functional programming if it wasn't for the nice people on LtU and in #haskell
08:50:49 <quicksilver> jmcarthur: they confer a qualitively similar advantage to, e.g., using colour or typeface changes.
08:51:08 <quicksilver> it's a fairly small amount of extra bandwidth though (i.e. overuse of infix starts to get confusing again, to the typical reader)
08:51:19 <monochrom> You single-cellular organisms, of course you don't understand why insults are the best responses to anything. <duck>
08:51:22 <jmcarthur> quicksilver: yeah that's kind of qhat i meant when i said they are more visual than parens
08:51:28 <jmcarthur> *what
08:51:37 <jmcarthur> you said it nicer than i, though
08:51:53 <jmcarthur> @slap monochrom
08:51:53 * lambdabot moulds monochrom into a delicous cookie, and places it in her oven
08:51:55 <quicksilver> the thing that surprises me more about the lisp programming community is how little (some of it) values functional programming.
08:52:14 <quicksilver> there is a lot of lisp programming which is stuff full of mutation and other side-effects.
08:52:35 <aavogt> same with haskell
08:52:37 <fasta> quicksilver, because they don't have a SSC.
08:52:44 <quicksilver> aavogt: true enough, but worse, IMO.
08:52:45 <fasta> quicksilver, and neither do we.
08:52:56 <jmcarthur> i suspect it's because lisp evolved alongside imperative languages while ML-derived languages got a bit of a fresh start
08:53:23 <jmcarthur> yeah haskell is doing similar things
08:53:28 <quicksilver> even SML is used in a heavily imperative/mutating style more often than I would have expected.
08:53:30 <zygoloid> fasta: a supersonic car?
08:53:40 <fasta> zygoloid, a sufficiently smart compiler.
08:53:51 <zygoloid> :D
08:53:53 <fasta> zygoloid, in particular to avoid copying.
08:53:54 <monochrom> nonstrictness encourages pure functional style
08:54:03 <quicksilver> I'm not sure that's the main reason why (the SSC).
08:54:03 <jmcarthur> true dat
08:54:18 <quicksilver> only a small proportion of the code in the wild is performance-bound in that sense.
08:54:25 <monochrom> strict pure functional is a pain
08:54:34 <zygoloid> i do sometimes wonder if ghc could be extended to perform linearity analysis
08:54:57 <twink> Linearity analysis being some sort of linear logic -related affair?
08:54:59 <jmcarthur> optionally lazy pure functional (strict by default) needn't be a pain though
08:55:09 <fasta> zygoloid, in EXP time...
08:55:21 <zygoloid> fasta: is it really that bad? :(
08:55:32 <fasta> zygoloid, (which is one reason to use a linear logic based language to begin with)
08:55:34 <zygoloid> twink: deducing linear types
08:55:45 <jmcarthur> i'm yet undecided on whether i like lazy by default. i *definitely* like the ability to specify whether something is lazy or strict though
08:55:58 <cads> hmm, what's up with this code:
08:56:07 <fasta> zygoloid, yes, but I don't know what inputs causes it.
08:56:11 <zygoloid> fasta: i would have thought something quick and conservative could be done to get an approximation. it's ok to say 'this might be aliased' even if a ssc could prove it isn't
08:56:26 <jmcarthur> and i do like lazy by default for its convenience writing lazy code, but is it worth the occasional thunk chain?
08:56:48 <EvanR-work> heresy!
08:56:49 * zygoloid wonders if Disciple does linear type deduction
08:57:12 <cads> let pms [] = [[]]; pms ((x,n):xs) = Control.Monad.ap (++) (flip map [1..n] . flip ((:) . (,) x) =<<) (pms xs)  -- in ghci this gives me a "no instance for (Monad ((->) [[(t,t1)]])) where I try to use with [(1,3)]
08:57:20 <EvanR-work> jmcarthur: isnt the occasional thunk chain eliminated with some directive to force evaluation
08:57:32 <jmcarthur> EvanR-work: one of my favorite qualities about the haskell community is that we (usually) don't have a problem with seriously considering potential flaws in our language of choice ;)
08:58:02 <jmcarthur> EvanR-work: yes, but such directives are kind of ugly, if you ask me
08:58:02 <EvanR-work> php programmer community has the same property! ;)
08:58:10 <thoughtpolice> jmcarthur: well, then your base library needs to have both strict and non-strict components, because otherwise if you're strict by default and want laziness, you'll end up reinventing things because the regular standard library goes and forces values everywhere, and that will hurt your compositionality
08:58:25 <jmcarthur> thoughtpolice: you're right. i've considered that. i'm not so sure it's a bad thing
08:58:32 <cads> somehow lambdabot runs that code correctly though
08:58:34 <jmcarthur> thoughtpolice: we lack strict data types, ourselves
08:58:56 <jmcarthur> i can't even begin to count the number of times i've wanted strict tuples
08:59:02 <jmcarthur> brb meeting
08:59:03 <aavogt> unboxed tuples
08:59:31 <thoughtpolice> jmcarthur: similar to how people always complain we have a 'map' and a separate 'mapM' for monadic actions
08:59:36 <thoughtpolice> well, not always. some people
08:59:53 <thoughtpolice> and that's one problem disciple solves, along with the strict by default and lazy when necessary thing
09:00:06 <quicksilver> cads: import Control.Monad.Instances
09:00:10 <zygoloid> (hooray for disciple, now if only the compiler worked...)
09:00:10 <quicksilver> cads: or +m it, in ghci
09:00:15 <thoughtpolice> but i'm not sure Disciple is ready yet, or if it will ever be ready. I think something else will come along taking it's good parts
09:00:28 <thoughtpolice> maybe GHC, maybe something else.
09:00:43 <Axman6> it was just a PhD project
09:00:49 <thoughtpolice> i realize
09:00:55 <zygoloid> the downside of disciple is that its type system is kinda hard to precisely specify and to implement.
09:01:02 <Axman6> and ben's somewhat moved onto other projects
09:01:03 <thoughtpolice> it can compile toy things if you're nice but not much else.
09:01:29 <quicksilver> one-person projects can occasionally succeed far beyond rational expectations
09:01:34 <quicksilver> but, to be honest, not often :)
09:01:44 <zygoloid> now if it were to get some commercial backing...
09:01:51 * zygoloid glances in the direction of Galois
09:01:53 <quicksilver> examples of success: Linux. examples of failure: almost everything.
09:02:03 <quicksilver> jhc is pretty remarkable for a one-man-show.
09:02:09 * thoughtpolice wishes galois would release halvm already!
09:02:22 <quicksilver> (but still some way short of a useful haskell compiler I believe)
09:02:28 <thoughtpolice> quicksilver: john seems to have picked up development again and jhc seems to be shaping up nicely
09:02:33 <thoughtpolice> but still pretty far off, yeah.
09:02:35 <quicksilver> yes
09:03:11 <thoughtpolice> our experience with it w/ lhc wasn't amazing, even if JHC generates damn good code when it works. the internals were complex :(
09:03:21 <Axman6> :(
09:03:29 <thoughtpolice> and not very nice either
09:03:42 <fasta> thoughtpolice, you mean as in not documented?
09:03:52 <thoughtpolice> hopefully john is making progress on this front, because we sure had a hell of a time trying to rework parts of it
09:04:00 <quicksilver> from hearing John talk about it, some parts of the internals sound very nice indeed
09:04:18 <quicksilver> but I'm sure they're not documented and I'm sure there is all kinds of damp string connecting the bits
09:04:31 <thoughtpolice> well, the code is just really nasty in some places
09:04:54 <thoughtpolice> lots of IORef's over the place. no explanation why some transformations happen before others, or what state the intermediate form should be in when it's transformed by one pass as opposed to another
09:05:00 <fasta> The Coq source code is also "nasty" to say the least.
09:05:29 <thoughtpolice> so when it came to reworking optimizations, most of the time we were left guessing as to what would work and waiting until the compiler internally complained something was fucked up :/
09:05:34 <thoughtpolice> then we had to backtrace the transformation
09:05:40 <fasta> They have a big manual, but there is little correspondence between the code and the manual.
09:05:47 <thoughtpolice> also, as john himself admits, the code was written over the course of like 5 or 6 years
09:06:01 <thoughtpolice> so the code quality varies a lot between even related parts of the compiler
09:06:09 <thoughtpolice> it's just very hard to reason about
09:06:20 <Axman6> sounds like a good project for a hackathon
09:06:25 <Axman6> ... not ours though >_>
09:06:35 <fasta> That's why people suggested pluggable compilers.
09:06:41 <thoughtpolice> john is pretty much the only person who understands a large portion of the code, honestly
09:06:45 <thoughtpolice> OTOH, JHC has some brilliant ideas
09:06:50 <fasta> But in practice everyone wants integrated "fast" stuff.
09:07:02 <fasta> So, it never happens.
09:07:03 <djahandarie> fasta, put a plug in it!
09:07:03 <thoughtpolice> some of john's intermediate language design decisions/changes have had huge impacts on the quality of code JHC can generate
09:07:06 <thoughtpolice> it's really amazing honestly
09:07:10 <djahandarie> Don't crush the idealism
09:07:14 <thoughtpolice> it just needs a lot of honest work :(
09:08:00 <quicksilver> one of the things I like about it is how different it is from GHC
09:08:08 <quicksilver> it's great to have the design place explored
09:08:13 <quicksilver> s/place/space/
09:08:18 <cads> thanks quicksilver
09:08:18 <quicksilver> damn disobedient fingers.
09:08:20 <thoughtpolice> yes, it is
09:08:40 <thoughtpolice> JHC has lots of great ideas. I think it just needs a reimplementation more than anything
09:08:53 <thoughtpolice> other parts of JHC are not very nice at all
09:09:24 <dankna> So.  MLA or APA citation style for an otherwise-informal reference-and-tutorial document for my open-source project?  Discuss. :)
09:09:41 <thoughtpolice> I remember john telling me once about how he didn't plan to have unboxing support in JHC at first, so he didn't think about it in his design. later when he wanted to add it, it turned out to be very non trivial to bolt onto the existing design, so it caused the compiler to be littered with a lot of 'magic' in order to work :/
09:09:58 <thoughtpolice> which is never good
09:10:10 <thoughtpolice> you don't want your compilers to be magical, you want them to be understandable
09:10:16 <thoughtpolice> and predictable
09:10:21 <dankna> yes, I absolutely agree - I love that ghc has an internals wiki
09:10:24 <twink> Bibbity, bobbity, boo!
09:10:25 <dankna> although it's not complete
09:10:30 <dankna> but I found it decently easy to get started with
09:10:48 <dankna> subtelty is the enemy in a project that big
09:10:54 <dankna> *subtlety
09:10:59 <thoughtpolice> quicksilver: some of john's changes to boquist's GRIN however are really awesome and allow it to generate amazing code. I hope john publishes something about that some day
09:12:17 <thoughtpolice> dankna: yes, that was our trouble with jhc. some of the details are extremely subtle
09:12:38 * dankna nods
09:12:54 <thoughtpolice> also, with this whole iPhone programming language restriction stuff, maybe JHC has an ideal target
09:13:03 <thoughtpolice> it generates C code that looks amazingly similar to hand-written C code
09:13:06 <dankna> heh.
09:13:09 <thoughtpolice> some of the best I've ever seen generated by a compiler
09:13:14 <quicksilver> dankna: GHC has helpful developers who respond very rapdily to informed questions.
09:13:17 <dankna> so you think people intending to go against the terms of service are going go find it.
09:13:17 <thoughtpolice> (and fastest, to boot)
09:13:21 <dankna> quicksilver: I've found that :)
09:13:29 <quicksilver> (not saying that other projects don't, but it's most helpful)
09:13:32 * dankna nods
09:13:50 <dankna> *... are going to find it useful
09:14:14 <thoughtpolice> quicksilver: also helps that they're employed to work on it full-time, too :)
09:14:31 <quicksilver> yes
09:14:40 <dankna> I don't really have any intention of going against the terms, heh.  The closest I might come is claiming that a Haskell subunit is a library and the terms only say that the program itself has to be in a preferred language.
09:14:57 <quicksilver> you can choose to interpret those terms in all kinds of ways
09:15:01 <dankna> are they really?  who pays them?
09:15:03 <dankna> oh
09:15:09 <thoughtpolice> dankna: microsoft research
09:15:12 <dankna> nice.
09:15:28 <quicksilver> if I were a lawyer and wanted to sue you, I could choose to interpret them as saying you can't use third party libraries at all (if the libraries use apple APIs)
09:15:34 <dankna> true
09:15:37 <thoughtpolice> they have vague definitions like that so they can apply the restrictions selectively
09:15:46 <quicksilver> of course that's not what they intend, but it highlights the idiocy of them.
09:16:22 <quicksilver> or, more absurd still, that your whole program must be one function, because any other functions which call Apple APIs are an "intermediate layer" from your main.m ;)
09:16:26 <dankna> hrm
09:16:39 <dankna> yes, but I honestly don't think the court would support that interpretation
09:16:55 <dankna> courts aren't as crazy as you think, they do pay attention to established meanings of technical terms in their contexts
09:16:59 <quicksilver> probably not, no.
09:17:05 <quicksilver> do you feel like going to court with Apple, though?
09:17:08 <thoughtpolice> if it's a legal battle you're looking for, have lots of money :(
09:17:13 <dankna> no, but I don't expect it would ever go to court
09:17:13 <quicksilver> I doubt it would be a fun day in the park.
09:17:26 <thoughtpolice> they can pretty much just say 'no' to your application and you're SOL unless you have lots of money to go to court with over it
09:17:46 <thoughtpolice> or unless you rework it to fit their asinine standards. neither option is really that cool.
09:18:05 <thoughtpolice> censoring dictionaries? i mean, that's just ridiculous.
09:18:10 <thoughtpolice> srsly
09:18:45 <dankna> well, there was more to that particular story
09:18:50 <dankna> but it's not important
09:30:20 <cads> Jafet, that multipowerset function you cranked out is pure genius
09:31:09 <jmcarthur> thoughtpolice: my current line of thinking for alt-stdlib would eliminate the distinction between map and mapM, btw
09:33:43 <EvanR-work> :t map
09:33:44 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
09:33:49 <EvanR-work> :t mapM
09:33:50 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
09:34:23 <cads> hmm I keep seeing new articles about how upset developers are at apple's choices but I don't see anything marketed at making joe public care about that. People in the public are used to developers' lives sucking.
09:35:13 <jmcarthur> the only way this affects joe public is fewer new apps on the app store, and i don't know how many fewer it will be
09:35:21 <MadHatterDude> Hmm... I have this somewhat brilliant little regex-like text matcher, with the main type "newtype Pattern = Pattern { runPat :: (String -> Maybe (String, String)) }" But could that be generalized into an Arrow? Or used as a state monad?
09:38:47 <aavogt> MadHatterDude: well how would you compose them?
09:39:11 <aavogt> @unmtl StateT String Maybe a
09:39:11 <lambdabot> String -> Maybe (a, String)
09:39:17 <MadHatterDude> aavogt: That's exactly what I'm trying to figgure out
09:39:29 <cads> jlouis: are there terms preventing cross platform apps? That'd be smart but risk.
09:39:47 <cads> their*
09:40:03 <MadHatterDude> aavogt: I was thinking of making a kind of Arrow that could be serialized and operates on lists, maybe.
09:40:14 <dankna> cads: de facto though not formally, yes there are
09:40:15 <aavogt> MadHatterDude: that's a more general type, if all your useful operations require that a == String... maybe you don't have much to gain by writing it in terms of that
09:40:42 <aavogt> so really, the question is what do you do with Pattern?
09:41:34 <cads> I think they've got a captive audience
09:43:13 <MadHatterDude> aavogt: I was thinking "newtype Pattern a b = Pattern { runPat :: ([a] -> (b, [a])) }"
09:43:41 <MadHatterDude> aavogt: as a more general type which could be used for reducing parse tree builders too...
09:44:02 <aavogt> @unmtl StateT st Maybe a
09:44:03 <lambdabot> st -> Maybe (a, st)
09:44:30 <aavogt> but to be honest, it isn't terribly useful to parameterize over the first parameter of StateT
09:44:52 <aavogt> since it isn't allowed to change between arguments >>=
09:44:59 <aavogt> @type mapStateT
09:45:00 <lambdabot> forall (m :: * -> *) a s (n :: * -> *) b. (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
09:46:44 <MadHatterDude> I'm not sure I get you point, I'm not very experienced with State monad.
09:48:20 <aavogt> the point is that if you have some function :: State String b -> x,  you can't easily combine it with computations that have a different State parameter
09:48:46 <MadHatterDude> aavogt: That's why I'm using arrows?
09:49:32 <MadHatterDude> aavogt: That you have some kind of arrow operation to serialize Pattern arrows and then >>> to "stack" them
09:49:41 <jlouis> cads: there are also terms helping cross platform development
09:49:45 <ezyang> Ha, "chunky evaluation" :^)
09:51:02 <jlouis> cads: witness System.FilePath for instance
09:57:39 <aavogt> MadHatterDude: arrows are quite restrictive
09:57:39 <ezyang> "During the course of this research, we have come to the conclusion that, although non-strict languages seem superficially appealing, they are not, in general, a good idea." Hm.
09:58:14 <gwern> I wonder whether anyone has tried making an hourglass where half the sand is positively & negatively charged, and the rest neutral; you'll get sand that sorts itself, and could make a 5/10 minute timer eg.
09:58:20 <gwern> @quote Shapiro
09:58:20 <lambdabot> No quotes match.
09:59:39 <aavogt> @hoogle threadDelay
09:59:39 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
09:59:48 <aavogt> ^^ this will help, gwern
10:00:05 <aavogt> also opengl or something
10:01:24 <gwern> aavogt: help with what?
10:01:40 <aavogt> making a timer
10:01:53 <gwern> aavogt: I meant a physical timer -_-
10:02:33 <jmcarthur> ezyang: what are you reading?
10:02:53 <gwern> jmcarthur: at a guess, something associated with jonathan shapiro or bitc
10:04:04 <ezyang> jmcarthur: Ennal's thesis on adaptive evaluation
10:06:05 <MadHatterDude> ezyang: What are you reading?
10:07:10 <ezyang> http://research.microsoft.com/~simonpj/papers/optimistic/ennals-thesis.pdf
10:08:30 <Saizan> why is research.microsoft.com always so slow?
10:08:37 <Saizan> from here, at least
10:08:54 <ezyang> well, it is a big thesis
10:08:59 <ezyang> You can also try http://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-730.pdf
10:09:11 * ezyang was lamenting how theses are soooo long 
10:09:55 * hackagebot MonadCatchIO-mtl 0.3.0.1 - Monad-transformer version of the Control.Exception module  http://hackage.haskell.org/package/MonadCatchIO-mtl-0.3.0.1 (DanielGorin)
10:18:39 <MadHatterDude> @src sort
10:18:39 <lambdabot> sort = sortBy compare
10:18:49 <MadHatterDude> @src sortBy
10:18:49 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
10:19:08 <MadHatterDude> @src insertBy
10:19:08 <lambdabot> insertBy _   x [] = [x]
10:19:08 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
10:19:09 <lambdabot>                                  GT -> y : insertBy cmp x ys'
10:19:09 <lambdabot>                                  _  -> x : ys
10:20:33 <nlogax> when doing `cabal upgrade --dry-run`, cabal-install tells me it's not recommended to upgrade core packages, and lists a bunch of packages. how do i know which ones are "core packages"?
10:22:27 <Saizan> if you always installed your packages in the userdb the core ones will roughly be the ones in the global one
10:26:06 <nlogax> thanks. just gotta find out how to list the global ones then :D
10:26:38 <Apocalisp> is there such a thing as a pointed map?
10:26:53 <nlogax> oh, there's a ghc-pkg too.. *fumbling noob*
10:27:37 <Apocalisp> PointedMap k v -> v
10:32:02 <nlogax> will cabal upgrade --user upgrade only packages in the user db?
10:32:31 <nlogax> orrr... i don't know what it would otherwise do
10:33:04 * hackagebot vcd 0.0.0 - Tools for writing VCD files.  http://hackage.haskell.org/package/vcd-0.0.0 (TomHawkins)
10:50:03 <EvanR-work> lunch
10:50:07 <EvanR-work> time to do some haskell!
10:50:39 <pickles> if only everyone had that attitude, evanr
10:58:44 <FliPPeh> Whenever I set in class and we're talking about programming with this whacky Visual Basic for Applications, I can't help but think how much more fun and effective that could be, if it only was written in haskell...
10:58:49 <FliPPeh> s/set/sit/
10:59:06 <burp> VB? wtf
11:02:07 <FliPPeh> burp: Oh yes. VB.
11:06:04 <RORgasm> hey guys
11:06:13 <RORgasm> trying to get into haskell a lilt bit
11:06:18 <RORgasm> i'm a ruby developer mainly
11:06:45 <RORgasm> is there a Haskell Platform installer for os x 10.5 running on a PowerPC mac
11:06:46 <RORgasm> ?
11:07:04 <RORgasm> i couldn't find it on the officila Haskell Platform website
11:07:29 <dankna> I'm fairly certain that the latest Haskell Platform is 10.6-only.
11:07:38 <dankna> Kinda sucks for your situation, I agree.
11:07:53 <RORgasm> that sux
11:07:54 <RORgasm> :(
11:08:01 <dankna> it might be possible to build your own install
11:08:18 <RORgasm> dankna
11:08:22 <RORgasm> who would i do that?
11:08:38 <RORgasm> jsut check out the source and build from it?
11:08:39 <dankna> @tell dons We had someone come in asking about Haskell Platform on OS X 10.5... I don't think this is supported?  The site should make that clear.
11:08:39 <lambdabot> Consider it noted.
11:08:51 <dankna> well, you would start by looking for a binary distribution of ghc
11:08:52 <RORgasm> actually
11:08:57 <RORgasm> it says it is supported on 10.5
11:09:00 <dankna> you need ghc to build ghc, as it's
11:09:01 <dankna> oh!
11:09:01 <dankna> okay
11:09:04 <RORgasm> but only Intel processeros
11:09:07 <FliPPeh> dankna: Don't forget the PowerPC part
11:09:15 <FliPPeh> I think that's even more important
11:09:23 <dankna> @tell dons Forgot to say - he mentioned PowerPC as the architecture.
11:09:23 <lambdabot> Consider it noted.
11:09:26 <jmcarthur> macports should work i think
11:09:47 <jmcarthur> dunno how up to date it is
11:09:54 <dankna> oh - yeah macports will build from source for you
11:09:58 <RORgasm> jmcarthur: yeah i was considering that... i know i'll probably have an older version... but at least it will be enough to get me started
11:10:05 <dankna> that's probably what you want to do, way easier than building from scratch
11:13:27 <jmcarthur> RORgasm: that's an amazing nick
11:14:02 <RORgasm> jmcarthur: lol...thanx
11:14:20 <lispy> ?faq Can Haskell detect sarcasm?
11:14:20 <lambdabot> The answer is: Yes! Haskell can do that.
11:19:18 <BONUS> am i correct in this: ((0 + 1) + 2) + 3 is evaluated as (1 + 2) + 3 --> 3 + 3 --> 6
11:19:37 <BONUS> i mean as ((0 + 1) + 2) + 3 --> (1 + 2) + 3 --> 3 + 3 --> 6
11:19:45 <BONUS> i'm never sure with numbers :\
11:20:30 <lispy> BONUS: I think so.
11:20:35 <lispy> BONUS: how would we test it?
11:20:44 <lispy> BONUS: we could insert undefined
11:20:55 <lispy> > (undefined + 1) + 2 + 3
11:20:55 <lambdabot>   * Exception: Prelude.undefined
11:21:02 <BONUS> ah, of course!
11:21:08 <lispy> but, that's kind of silly, because it will throw that exception anywhere I put it
11:21:15 <BONUS> true yeah
11:21:39 <lispy> BONUS: I think to test it, you need something that has a representation that allows (+) to be lazy
11:21:56 <lispy> > ((a + b) + c) + d
11:21:57 <lambdabot>   a + b + c + d
11:22:09 <shadowspar> use functions that return a number, in place of the numbers
11:22:11 <lispy> But, I'm still not sure what to do from there
11:22:17 <shadowspar> then observe the order they're called in ...?
11:22:30 <glguy> You can't use imprecise exceptions to determine evaluation order
11:24:33 <lispy> BONUS: Why are you asking?
11:25:58 <BONUS> just writing LYAH and i'm modifying my explanation of foldl
11:26:30 <BONUS> i already chose a foldl (+) 0 example but then i saw that i'm not completely sure how evaluation of ((0 + 1) + 2) + 3 goes
11:26:51 <lispy> outside in
11:26:53 <BONUS> but i found this http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl' which says that it is indeed like i thought
11:27:21 <maltem> BONUS, how else should it be evaluated?
11:27:29 <BONUS> maltem: exactly :D
11:27:33 <lispy> x + 3, where x = ((0 + 1) + 2), so now we need x, etc
11:28:33 <BONUS> evaluation of x + y requires both x and y to be evaluated and if y is already in WHNF i guess x is the next to be evaluated
11:28:50 <BONUS> did i say WHNF?
11:29:06 <BONUS> i think i meant NF
11:29:48 <maltem> for primitive data like numbers, there's no difference
11:29:59 <BONUS> yeah
11:31:33 <jmcarthur> should just be WHNF, shouldn't it?
11:31:38 <maltem> and yeah, the primitive numerical operations happen to be strict, and to evaluate their first argument first:
11:31:44 <maltem> > error "left" + error "right"
11:31:45 <lambdabot>   * Exception: left
11:31:54 <jmcarthur> well, nevermind, it depends both on the type and the implementation of (+) for that type
11:35:23 <aavogt> > let x + y = y `seq` (x Prelude.+ y) in error "left" + error "right"
11:35:24 <lambdabot>   * Exception: right
12:01:28 <wolgo> ugg
12:01:36 <wolgo> another day
12:01:44 <wolgo> today I have to program in perl...
12:01:58 <wolgo> I hate my life.
12:01:59 <Zao> At least it's not PHP.
12:02:19 <FliPPeh> Or VB
12:02:30 <mauke> Sir, I am offended
12:03:30 <wolgo> this source file, 200 lines long. 157 lines are made of a nested if structure
12:03:54 <wolgo> the last 16 lines are subroutine decls
12:03:57 <FliPPeh> wolgo: I feel sorry for you :)
12:04:02 <FliPPeh> s/:)/:(/
12:04:15 <wolgo> I am not going towork on this.
12:04:19 <mauke> if it doesn't start with 'use warnings; use strict;', you can throw it away
12:04:21 <wolgo> I am going to work on learning haskell lol
12:04:31 <wolgo> mauke: that is the firstthing I looked for
12:04:33 <wolgo> guess what
12:04:36 <mauke> :-[
12:04:37 <FliPPeh> Not there.
12:04:41 <wolgo> use strict is commented out
12:04:43 <wolgo> hahahah
12:04:43 <mauke> hahaha
12:05:10 <wolgo> I am really starting to respect haskell (even though I have difficulties thinkingin haskell)
12:05:11 <FliPPeh> Continuing work started by others is the worst thing that could happen
12:05:23 <wolgo> the first 30 lines
12:05:36 <wolgo> are: my $domainname = "some.domain";
12:05:45 <wolgo> 29 of which are commented out
12:05:49 <sinelaw> does anyone know of a metric space typeclass?
12:05:54 <wolgo> all with different hardcoded domains
12:05:58 <wolgo> in each line
12:06:14 <wolgo> I saw that and in my mind I said
12:06:17 <wolgo> zomg...
12:06:36 <sinelaw> if no positive answer in 5 seconds, i'll define one.
12:06:38 <wolgo> BONUS:
12:06:39 <sinelaw> 5...4...
12:06:49 <sinelaw> bingo! here i go.
12:07:08 <wolgo> BONUS: I like your book.
12:08:12 <FliPPeh> I want LYAH to cover monads!
12:08:17 <FliPPeh> I want funny monad images
12:08:32 <pickles> probably lots of burritos...
12:08:44 <sinelaw> @quote monad
12:08:45 <lambdabot> <mm_freak1work> says: not to be or to be and (not to be or to be and (not to be or to be and...)), that is the list monad
12:09:02 <sinelaw> @quote monad
12:09:03 <lambdabot> jmcarthur says: web monads are unicorn burritos that have been laying around in the attic for a few years
12:09:07 <sinelaw> there
12:09:51 <wolgo> a monad is like a volcano
12:10:05 <wolgo> it blows my mind
12:10:08 <wolgo> yuk yuk
12:10:09 <sinelaw> you don't know that its a monad until it explodes?
12:10:14 <wolgo> zomg Iwill be here all week
12:10:23 <BONUS> wolgo: hey! thanks so much! :)
12:10:28 <BONUS> one monads coming up!
12:10:34 <FliPPeh> Yay for BONUS!
12:10:37 <sinelaw> wolgo, every visitor here has a limited number of "zomg"s per day.
12:10:38 <BONUS> they are still cooking
12:10:55 <wolgo> sinelaw: yeah,I hit the limit
12:10:59 <jmcarthur> took so long because BONUS had to go unicorn hunting
12:11:02 <wolgo> sorry
12:11:08 <BONUS> at least i have my dinner now!
12:11:20 <wolgo> what is this unicorn business?
12:11:22 <sinelaw> BONUS, the unicorn slayer
12:11:31 <FliPPeh> Unicorns?
12:11:41 <jmcarthur> wolgo: referring to a bad monad metaphor
12:11:55 <wolgo> oh
12:11:58 <jmcarthur> pumpkin made it up i think
12:12:02 <jmcarthur> i don't remember the details anymore
12:12:04 <BONUS> apart from writing about haskell i also deal in wholesaling unicorn meat and other fantasy creature foodstuffs
12:12:11 <wolgo> hahahaa
12:12:21 <wolgo> do you have any bandersnatch testicles?
12:12:27 <BONUS> all out, sorry!
12:12:33 <wolgo> dang
12:12:43 * BONUS goes back to cooking monads
12:12:44 <wolgo> I have to use lotus notes here
12:13:04 <FliPPeh> BONUS: I'd like them medium!
12:13:30 <wolgo> there is this built in IM client called sametime. It is built on top of Eclipse and it takes about three minutes to load on my laptop.
12:13:56 <dankna> sinelaw: does the prohibition on zomgs apply only to the acronym, or does it prohibit the full expansion as well?
12:14:03 <tensorpudding> an IM client built into Eclipse?
12:14:07 <wolgo> tensorpudding: yes
12:14:11 <wolgo> I amnotkidding
12:14:18 <sinelaw> dankna, only acronyms
12:14:23 <dankna> excellent.
12:14:28 <dankna> so I can say "zee oh my god" as much as I like.
12:14:29 <wolgo> oh yeah and my space bar has to be smashed really hard to insert a space
12:14:41 <sinelaw> dankna, yes you can
12:14:55 <sinelaw> sametime? isn't that IBM horridness?
12:14:58 <wolgo> zee oh my god I cannot believe I am using eclipse as an im client
12:15:01 <wolgo> yes
12:15:05 <wolgo> it is shitware
12:15:10 <sinelaw> i used to puke on that daily.
12:15:21 <sinelaw> it's so horrible
12:15:24 <wolgo> as in I wish I could take it into the bathroom and get rid of it for life
12:15:36 <wolgo> I am being forced to use it.
12:15:38 <tensorpudding> What's the rationale for putting an IM client in Eclipse?
12:15:40 <sinelaw> so was I
12:15:45 <wolgo> tensorpudding: do not ask me
12:15:47 <stevenmarky1> enterprise!
12:15:55 <wolgo> it is ENTERPRISE QUALITY
12:16:00 <dankna> The same as the rationale for putting one in Emacs, I suppose.
12:16:05 <wolgo> probably to check in each line of chat into SVN
12:16:10 <tensorpudding> Does it provide some sort of better collaboration with other Java coders to use only a Java-approved IM feature
12:16:16 <dankna> People, hard though it is to believe, like Eclipse and don't want to have to go outside it.
12:16:46 <dankna> Also, again like Emacs, anything written for Eclipse is automatically zee-oh-my-god-cross-platform.
12:16:55 <wolgo> screw that
12:17:00 <jmcarthur> honestly, eclipse is basically the only environment i will use to code java
12:17:10 <tensorpudding> I understand putting an IM client in emacs.
12:17:16 <wolgo> I like to use mutt
12:17:21 <wolgo> and pidgin
12:17:28 <wolgo> not sametime and lotus notes
12:17:31 <jmcarthur> but that's because it sucks so hard to code java that you need a huge IDE with tons of specialized tools for it
12:17:37 <dankna> heh yes, as you say, JMC
12:18:04 <wolgo> java seems tohave a lot of"words" in it
12:18:11 <sinelaw> sametime should be called "sameoldshit"
12:18:22 <sinelaw> i hated using it
12:18:24 <sinelaw> i was also forced to
12:18:26 <wolgo> like you are giving a speech to the greek senate
12:18:31 <wolgo> like a filibuster
12:18:51 <sinelaw> i wonder what percentage of sametime / lotus notes users are forced to use them
12:18:54 <sinelaw> i'm guessing it's 100%
12:18:55 <wolgo> java is like a gigantic government filibuster performed by some windbag
12:19:12 <pickles> the worst language for long names w/ alot of words i had to use was a manufactured variant of C++ they forced us to learn in school
12:19:14 <wolgo> and I feel like that when I use sametime
12:19:27 <pickles> the variable and calss naming convention used both underscores AND camel case
12:19:29 <aavogt> pickles: did it have factories?
12:19:43 <wolgo> I feel like I am in one of those dreams where I and running through mud or sand and I cannot move.
12:19:44 <pickles> i think it mighta, i have tried to purge the experience from my memory
12:19:56 <sinelaw> ExtendedExtensionProviderFactory
12:19:56 <pickles> the worst one I think was the class and method of:
12:20:03 <wolgo> but I cannot wake up because this is real life
12:20:10 <pickles> Least_Cost_Path_Machine.Cost_Of_A_Least_Cost_Path()
12:20:27 <wolgo> wow
12:20:45 <jlouis> sinelaw: isn't that AbstractExtendedExtendingExtensionProviderFactoryInterface?
12:21:17 <sinelaw> jlouis, oh yeah you're citing the more general version
12:23:04 * sinelaw gives up trying to define measure space typeclasses, and falls back to metric spaces
12:25:33 <aavogt> modifyIORef hai (3 :)
12:25:48 <student> hey
12:26:06 <sinelaw> hello student
12:26:06 <student> can anyone here help me with my perl homework? I don't understand something
12:26:19 <aavogt> #haskell wouldn't either
12:26:19 <student> its about encrypting passwords
12:26:37 <sinelaw> student, try #perl
12:26:58 <student> sorry, somewhere online said this was where to go.
12:27:18 <student> stupid question: how do i get to #perl
12:27:37 <sinelaw>  /join #perl
12:27:42 <sinelaw> without the leading space
12:27:48 <student> cool thanks
12:28:12 <iago> someone knows if there is some type-checker for haskell-src-exts?
12:28:29 <wolgo> I just want to be good at haskell so I can write all of my programs in haskell.
12:28:37 <wolgo> I am tired of being a terrible programmer.
12:28:44 <wolgo> I do not want to make things like sametime.
12:28:48 <jmcarthur> we are all terrible programmers
12:28:50 <iago> or for that it's better to use ghc-api
12:29:12 <jmcarthur> people aren'
12:29:14 <jmcarthur> woops
12:29:22 <jmcarthur> people aren't cut out for programming
12:29:41 <aavogt> @hackage hint -- iago
12:29:42 <lambdabot> http://hackage.haskell.org/package/hint -- iago
12:29:51 <sinelaw> woohoo
12:29:55 <sinelaw> class MetricSpace m where
12:29:55 <sinelaw>   distance :: Eq m => m -> m -> Double
12:29:56 <jmcarthur> computers probably would be if we could just figure out enough programming to make them do it for us
12:30:19 <jmcarthur> sorry, i'm rambling
12:30:38 <aavogt> haskell-src-meta if you insist on using haskell-src-exts but still want ghc to typecheck some code
12:30:38 <jmcarthur> MetricSpace? :o
12:30:39 <sinelaw> do those two lines warrant a hackage package? :)
12:31:02 <jmcarthur> what do they do?
12:31:03 <aavogt> sinelaw: why isn't it   class Eq m => MetricSpace m where ...
12:31:29 <iago> aavogt, hint works with String's, which is quite inconvenient if you want to write an analysis tool
12:31:30 <sinelaw> aavogt, someone here told me it's better this way, but i don't know why.
12:31:40 <jmcarthur> weird
12:31:47 <jmcarthur> i'd do what aavogt suggested, myself
12:31:54 <sinelaw> ok, changed :)
12:31:58 <tensorpudding> there's no guarantee just from looking at it that it satisfies the metric space axioms
12:32:05 <sinelaw> tensorpudding, correct
12:32:05 <jmcarthur> anyway, what is it supposed to do?
12:32:12 <sinelaw> but the same applies to some other typeclasses
12:32:23 <sinelaw> jmcarthur, characterize metric spaces
12:32:39 <tensorpudding> a space might have multiple metrics
12:32:48 <sinelaw> hmm....
12:32:51 <sinelaw> that's true
12:32:53 <jmcarthur> sinelaw: why constrain the result to Double?
12:33:02 <sinelaw> jmcarthur, it should be "R"
12:33:09 <jmcarthur> why constraint it to R?
12:33:11 <jmcarthur> *constrain
12:33:18 <sinelaw> that's how its defined
12:33:22 <jmcarthur> oh i see
12:33:26 <jmcarthur> looking at wikipedia now
12:33:31 <jmcarthur> you're right, sorry
12:33:50 <sinelaw> tensorpudding, but more than one useful one?
12:34:14 <aavogt> iago: hmm, what kinds of analyses?
12:34:31 <jmcarthur> tensorpudding: is that really relevant? this is what newtypes are good for, after all
12:34:41 <sinelaw> tensorpudding, ideally we should be able to define typeclasses paremeterized on function values
12:35:04 <jmcarthur> dependent type classes?
12:35:17 <iago> aavogt, it's simpler say that I need the abstract syntax tree annotated with types, just to do some extra typechecking given some annotations
12:35:35 <aavogt> sinelaw: use a multiparametertypeclass?
12:35:48 <mreh> I can has JavaScript written in Haskell?
12:36:07 <jmcarthur> wait, why a multiparameter type class? what's the other parameter?
12:36:09 <sinelaw> aavogt, what will be the other parameter
12:36:15 <sinelaw> in this case
12:36:35 <aavogt>   class F a b where f :: (a -> b), if you want less overlap than    class F a where f :: a; instance F (a -> b) where f = ...
12:37:13 <aavogt> sinelaw: this would be interesting if unbound implicit parameters were allowed in typeclass contexts
12:37:45 <sinelaw> that's not my problem here if i'm getting what you're saying
12:37:48 <sinelaw> the type is ok
12:37:50 <aavogt> like:   class (?f :: a) => F x a where ...
12:37:55 <sinelaw> i just need different instances for the same type
12:38:05 <jmcarthur> newtype
12:38:09 <sinelaw> yeah
12:39:19 <aavogt> oh, parameterizing over _values_
12:40:10 <aavogt> sinelaw: newtypes may be more trouble that just passing around a record functions
12:40:46 <sinelaw> aavogt, i don't really have a concrete case where i need those multiple instances
12:43:43 <EvanR-work> what is the difference between newtype and data
12:43:55 <sinelaw> lifted bottoms
12:44:09 <jmcarthur> EvanR-work: newtype simply creates a new type from an old one. data is an entirely new stucture
12:44:45 <chrisdone> newtypes can derive instances of classes from the subtype
12:44:55 <chrisdone> copumpkin: !!!
12:44:58 <EvanR-work> so can data
12:45:01 <dmhouse> EvanR-work: basically, newtype is a very simple wrapper around an existing type. It's essentially a type synonym apart from you have to do constructor wrapping unwrapping etc
12:45:07 <copumpkin> omg chrisdone
12:45:14 <chrisdone> o{
12:45:16 <dmhouse> EvanR-work: so there are limitations: you can only have a single constructor, which only has a single parametetr
12:45:34 * chrisdone ruffles copumpkin's hair
12:45:35 <EvanR-work> single constructor, single parameter
12:45:37 <EvanR-work> got it
12:45:51 <EvanR-work> its a scalar data ;)
12:45:57 * copumpkin pokes chrisdone 
12:46:04 <dmhouse> EvanR-work: these limitations are done so that at runtime, the compiler can forget your new type exists. It just replaces an instance of your newtype with the unwrapped version without the constructor
12:46:08 <dankna> so that's what it IS, but what's the ration-- ah
12:46:26 <dmhouse> EvanR-work: however, as far as the type system is concerned at compile time, it *is* a completely different type so you can have different instance declarations etc
12:46:34 <chrisdone> EvanR-work: what I mean is that deriving on a newtype can derive using the instances defined for the subtype
12:46:47 <EvanR-work> so can data?
12:46:56 <chrisdone> @google generalized newtype deriving
12:46:57 <lambdabot> No Result Found.
12:47:03 <EvanR-work> instead of subtype, the components
12:47:03 <chrisdone> >:[
12:47:27 <chrisdone> http://hackage.haskell.org/trac/haskell-prime/wiki/NewtypeDeriving
12:47:42 <dmhouse> There's one more restriction: the constructor is always strict, i.e. if newtype NewInt = C Int, then C undefined is undefined. (This is again so that the compiler can unwrap all the runtime representations.)
12:47:49 <aavogt> rhymes with unsafecoerce
12:47:50 <EvanR-work> i think im getting the situations where youd use either. and its mainly the number of constructors and number of components
12:48:29 <dmhouse> EvanR-work: you basically use newtype when a type instantiates a type class, but you want to define a new instance, or multiple instances.
12:48:36 <chrisdone> dmhouse: are newtypes inline for all intents and purposes?
12:48:48 <chrisdone> inlined*
12:49:04 <dmhouse> chrisdone: there is no runtime representation of a newtype'd type
12:49:22 <webwanderer> hi folks.
12:49:36 <chrisdone> dmhouse: how are type classes of newtypes managed?
12:49:40 <dmhouse> A classic example if you're algebraically inclined is defining two instances of a Group typeclass for Int: one with the (*) operation, one with the (+) one
12:49:42 <sinelaw> can I do something like this? instance T1 t => T2 t? (if t is an instance of T1, it's an instance of T2?)
12:49:46 <chrisdone> (if there's no runtime representation)
12:49:49 <dmhouse> sinelaw: yep
12:49:52 <sinelaw> cool.
12:50:05 <copumpkin> sinelaw: yeah, but it's undecidable
12:50:15 <dmhouse> copumpkin: it is?
12:50:17 <sinelaw> undecidable?
12:50:19 <sinelaw> what does that mean
12:50:25 <webwanderer> http://www.haskell.org/all_about_monads/html/meet.html#maybe says the signature of a function as (m a -> (a -> m b) -> m b) and it produces a computation 'm a' but isn't 'm a' a type?
12:50:28 <EvanR-work> is this useful
12:50:34 <copumpkin> unless you have an extra type constructor, I think it is
12:50:37 <EvanR-work> newtype MyType = Foo
12:50:40 <dmhouse> chrisdone: I'm not sure, but I would guess that as types are determined at compile time, all calls to a function in a typeclass are reduced to monomorphic calls at compile time
12:50:40 <copumpkin> I haven't touched haskell in several weeks :)
12:50:56 <chrisdone> dmhouse: good point
12:50:59 <sinelaw> what does "undecidable" mean
12:51:03 <dmhouse> chrisdone: i.e. when you use show at runtime, you know which show you're talking about so it's a concrete tall
12:51:09 <copumpkin> sinelaw: means that it isn't allowed unless you turn on an extension in GHC
12:51:10 <thoughtpolice> it's not undecidable as long as you don't do something like 'instance T2 t => T1 t'
12:51:13 <thoughtpolice> which would be dumb anyway
12:51:21 <copumpkin> and that means that typechecking may not terminate
12:51:26 <thoughtpolice> but you will need UndecidableInstances to just do "instance T1 t => T2 t"
12:51:27 <copumpkin> thoughtpolice: yeah, but you still need the extension turned on
12:51:43 <webwanderer> *'m a' 'm b'
12:52:16 <sinelaw> copumpkin, is there a hint as to when not to use it?
12:52:24 <thoughtpolice> because the instantiation's "head" (i.e. the "T2 t") part is no 'bigger' than the context, that is, T1 t.
12:52:29 <webwanderer> don't bother.. I think I got it.
12:52:40 <pickles> webwanderer: they're type variables
12:52:58 <pickles> so you'll have to fill in what types they actually be based on the context you're using them in
12:53:04 <webwanderer> pickles. I know
12:53:14 <sinelaw> so rather than turn it on i can just repeat my definition for Int, Integer, Float, Double
12:53:17 <webwanderer> but it says that the function produces computations.
12:53:18 <sinelaw> which is ugly.
12:53:20 <thoughtpolice> sinelaw: you don't use it when you want type checking to terminate. but undecidable instances are useful on occasion and it's easy to see many times when type checking will terminate
12:53:24 <kbateman> type Process a b = a -> IO (b, Process a b);
12:53:42 <kbateman>     Cycle in type synonym declarations:
12:53:46 <thoughtpolice> in your case doing something like "instance T1 t => T2 t" is perfectly fine
12:53:57 <sinelaw> T1 = Num
12:53:59 <sinelaw> in my case.
12:54:02 <thoughtpolice> it would only be undecidable if you did something dumb like 'instance T2 t => T1 t" which doesn't make sense anyway
12:54:20 <sinelaw> you can say that again
12:54:22 <c_wraith> kbateman: that would work as a data, but as a type..  It's not allowed to be recursive
12:54:33 <webwanderer> pickles: "produce a new computation for values of that type" is what it says. why is that?
12:54:43 <sinelaw> but thanks :)
12:54:51 <chrisdone> thoughtpolice: what's the difference bwetween T1 t => T2 t and T2 t => T1 t?
12:54:53 <sinelaw> i guess i'll not use it here anyway
12:54:54 <kbateman> Could you help me to get this to work?  I feel like such a newb...
12:55:00 <pickles> webwanderer: in the case of the maybe monad, it just returns the 'm b' from the function you pass it, but that's not always the case
12:55:16 <sinelaw> actually, I will use it.
12:55:25 <c_wraith> kbateman: is data what you actually want?
12:55:39 <kbateman> I just can't quite wrap my brain around it.
12:55:42 <dmhouse> chrisdone: I think thoughtpolice meant that if you included the second one *as well*, typechecking wouldn't terminate
12:55:55 <webwanderer> pickles: true but why does it say that it produces a new computation?
12:55:56 <pickles> webwanderer: i think they say computation because of lazy evalutaion, so it might not necesarily be evaluated right away, but don't quote me on that
12:55:57 <kbateman> I want to handle mouse events and manipulate a MVar within them
12:56:11 <webwanderer> pickles: yes.. i agree.
12:56:20 <webwanderer> That's what I thought as well.
12:56:21 <kbateman> And have some state implicit in the mouse event handler
12:56:42 <pickles> webwanderer: if you look at the state monad, it returns a function (in the monad) to be evaluated to run the code of the bind
12:56:42 <necrobious> Hey #haskell, I am trying to create an instance of Serialize (http://hackage.haskell.org/packages/archive/cereal/0.2/doc/html/Data-Serialize.html) for a UUID type (http://hackage.haskell.org/packages/archive/uuid/1.2.1/doc/html/Data-UUID.html), however UUID's constructor is  not exported (see last few lines: http://hackage.haskell.org/packages/archive/uuid/1.2.1/doc/html/src/Data-UUID.html). What is the best way for me to add a new instance of a type 
12:56:43 <necrobious> to my program, then my instance relies on a a type who's type constructor is not visible?
12:56:46 <thoughtpolice> chrisdone: well, without specifically mentioning what T1 and T2 are, it's hard to tell :)
12:57:12 <thoughtpolice> chrisdone: UndecidableInstances is used a lot of times to provide something like a 'class synonym'
12:57:17 <thoughtpolice> i.e. you do
12:57:24 <philo> hi any legal way to do something like : Just (Local, access, exp, VarEntry (typ@( Inte _ | Che _ )))
12:57:27 <webwanderer> pickles: not quite there yet. thanks for the tip. :)
12:57:28 <thoughtpolice> "instance (A1 a, A2 a, A3 a) => A4 a"
12:57:30 <philo> hi any legal way to do something like : Just (Local, access, exp, VarEntry (typ@( Inte _ | Che _ )))
12:57:41 <thoughtpolice> chrisdone: then in a function you can just say it's type is "f :: A4 a => ..."
12:57:56 <thoughtpolice> chrisdone: so, that's a safe usage of undecidable instances
12:57:57 <c_wraith> kbateman: well, what's the type of the mouse event handler interface in whatever library you're using?
12:57:59 <jmcarthur> omg it's copumpkin!
12:58:00 <pickles> webwanderer: np. if you get stuck on the state monad, look at the definition of >>= to work it out. It took me a lil, but doing that really helped
12:58:03 <copumpkin> omg it's jmcarthur
12:58:14 <copumpkin> preflex: seen mmorrow
12:58:14 <preflex>  mmorrow was last seen on #ghc 84 days, 17 hours and 29 seconds ago, saying: * mmorrow is rtfm'ing
12:58:20 <chrisdone> these are the bad ones:
12:58:20 <chrisdone> -- Context assertion no smaller than head
12:58:20 <chrisdone> instance C a => C a where ...
12:58:20 <chrisdone> -- (C b b) has more more occurrences of b than the head
12:58:22 <thoughtpolice> it just becomes unsafe when you have the instance 'instance T1 t => T2 t' *and* the instance 'instance t T2 => T1 t'
12:58:23 <chrisdone> instance C b b => Foo [b] where ...
12:58:24 <kbateman> I'm using SDL, which uses a type called Event.
12:58:27 <jmcarthur> i suppose you've been prioritizing and being responsible and all that crap
12:58:43 <thoughtpolice> because, obviously, to be an instance of T2, you must be an instance of T1. but to be an instance of T1, you are also an instance of T2
12:58:46 <thoughtpolice> hence GHC will freak out
12:58:50 <webwanderer> pickles: sure will.
12:58:56 <c_wraith> kbateman: well, what's the name of the function that allows you to add an event handler?
12:58:56 <kbateman> In the end, I want my other code to have a (Event -> IO ()) that it can just feed Events to.
12:59:13 <c_wraith> kbateman: ok, that makes sense.
12:59:35 <c_wraith> Also, what's the type (not name) of the function that adds an event handler?
13:00:01 <kbateman> waitEvent :: IO Event
13:00:10 <kbateman> It's a polling API
13:00:25 <thoughtpolice> chrisdone: somewhat make sense?
13:00:31 <c_wraith> I see.  So, then, what were you trying to do with the Process type?
13:01:10 <kbateman> I was trying to solve it generally first.
13:01:33 <c_wraith> solve...  maintining state/
13:01:36 <kbateman> I wrote a makeProcess function that made another MVar to hold the process state
13:01:49 <chrisdone> thoughtpolice: I don't think that's the cause
13:01:58 <thoughtpolice> chrisdone: cause of what?
13:02:09 <kbateman> It was supposed to turn a (a -> IO (b, Process a b)) into a (a -> IO b)
13:03:07 <sinelaw> @hoogle Complex -> Real
13:03:07 <lambdabot> Did you mean: Complex a -> Real /count=20
13:03:07 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
13:03:08 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
13:03:09 <sinelaw> oops.l
13:03:11 <kbateman> but the type checker would have nothing to do with it.
13:03:15 <chrisdone> thoughtpolice: well, I mean C a => C a, and C a => C b, are patently disallowed
13:03:19 <sinelaw> @hoogle Complex -> Double
13:03:19 <lambdabot> Did you mean: Complex a -> Double /count=20
13:03:20 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
13:03:20 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
13:03:24 <sinelaw> ....
13:03:46 <sinelaw> @pl (\a:+b -> a)
13:03:46 <lambdabot> (line 1, column 5):
13:03:46 <lambdabot> unexpected "+"
13:03:46 <lambdabot> expecting "()", natural, identifier, "_" or "("
13:04:30 <kbateman> I guess I could just do it with a MVar (a -> IO ())
13:04:32 <c_wraith> kbateman: well, type can't be recursive, as it's basically just slightly smarter text substitution.
13:05:07 <kbateman> I guess I'm just coming at it from the wrong way.
13:05:09 <EvanR-work> what about newtype
13:07:14 <gwern> wonder if anyone has ever written 'assembly for haskell programmers' :)
13:07:31 <gwern> chrisdone: how goes the mueval merge?
13:07:43 <kniu> mueval merge?
13:07:47 <kniu> into what?
13:08:04 <c_wraith> yes, newtype can be recursive
13:08:18 <chrisdone> gwern: I can't decide how to do it
13:08:49 <c_wraith> kbateman: what's the termination condition, anyway?
13:09:05 <jmcarthur> EvanR-work: there is a little more to newtype than just being an optimization for single constructors. it has different semantics from data, too.  http://www.haskell.org/haskellwiki/Newtype
13:09:07 <sinelaw> are vector spaces implicitly assumed to be a metric space with disance(x,y) = sqrt (<x-y,x-y>)?
13:09:27 <dmhouse> sinelaw: yes
13:09:40 <EvanR-work> jmcarthur: so can you make a recursive newtype?
13:09:42 <chrisdone> gwern: mueval-core needs to be able to be interactive, but then so will mueval, and mueval will have to be an watchdog like haskell-json does right now
13:09:47 <jmcarthur> EvanR-work: yup
13:09:54 <dmhouse> sinelaw: although it's more general than that
13:09:55 <EvanR-work> ok got it
13:10:09 <sinelaw> dmhouse, of course. and i should have said "inner product space"
13:10:12 <c_wraith> kbateman: the type (Process a b -> a -> IO b) only really makes sense if there's some termination condition implicit in the Process.  Otherwise, what's the b the IO action produces?
13:10:13 <dmhouse> sinelaw: to define <,> you need an inner product space.
13:10:18 <sinelaw> :)
13:10:20 <gwern> chrisdone: perhaps mueval can read on stdin, and every new line on stdin resets the watchdog process's timer
13:10:22 <chrisdone> gwern: then I thought, you could make a library out of it and just talk to a "mueval" abstract data type and make requests. then do I need a monad, etc. blargh
13:10:24 <dmhouse> sinelaw: right, but you can define d(x,y) = ||x-y|| in any normed space
13:10:35 <sinelaw> aha.
13:10:35 <chrisdone> gwern: that's what the json service does right now
13:10:39 * hackagebot darcs 2.4.1 - a distributed, interactive, smart revision control system  http://hackage.haskell.org/package/darcs-2.4.1 (ReinierLamers)
13:10:49 <chrisdone> it works well as you'd expect
13:10:50 <kbateman> c_wraith: there isn't really a termination condition.  It's intended for a game interaction loop.
13:10:51 <dmhouse> sinelaw: recall any inner product space is a normed space with ||x|| = sqrt(<x,x>)
13:10:54 <gwern> chrisdone: iirc, you only need persistence of the process for speed, not persistence of bindings/expressions
13:11:03 <chrisdone> gwern: that's right
13:11:06 <kbateman> c_wraith: I just want to be able to throw events at it.
13:11:15 <jmcarthur> general question about FFI. the page i just linked EvanR-work to says this: "Newtypes can be used transparently in FFI wrappers, including IO when using GHC." i knew this, but i had heard that one should not rely on this. are there opinions about it here?
13:11:19 <gwern> chrisdone: so the non-watchdog process can keep getting created & spun off as long as the watchdog process is stil alive
13:11:20 <dmhouse> sinelaw: metric spaces are incredibly general, you don't have any kind of structure (like the linear structure in vector spaces) on the elements
13:11:23 <sinelaw> dmhouse, yeah.
13:11:24 <kbateman> c_wraith: when it's time to quit, I just don't call it anymore.
13:11:32 <chrisdone> gwern: mhm
13:11:39 <c_wraith> kbateman: Oh, I see.  So it's just setting the next handler.
13:11:47 <kbateman> Yep.
13:11:50 <dankna> for example, a non-orientable manifold (exactly what it sounds like) is still a metric space
13:11:54 <sinelaw> i just didn't know if the association between norm as distance is automatically assumed
13:12:08 <sinelaw> or only commonly used
13:12:47 <c_wraith> kbateman: this is actually very tractable using newtype instead of type.
13:14:04 <gwern> chrisdone: this approach also needs minimal re-engineering, I think. pretty much all the changes would be just add an argument (["-i", "run in interactive mode"]), and re-work the watchdog
13:14:16 <gwern> chrisdone: although I suppose I dunno whether that is performant enough
13:14:19 <chrisdone> gwern: I guess I was overthinking it -- you could include mueval as a library and just have, e.g. runMueval { do expr <- eval "1"; ty <- typeOf "1"; ok <- load "test.hs"; return ...; } etc then I got daunted by it
13:14:36 <gwern> chrisdone: well heck, you can basically do that now
13:15:18 <FliPPeh> > (++) <$> Just "Awe" <*> Just "some"
13:15:19 <lambdabot>   Just "Awesome"
13:15:26 <gwern> chrisdone: call Mueal.Interpretor.interpretor
13:15:30 <FliPPeh> :t it
13:15:31 <lambdabot> Not in scope: `it'
13:15:33 <FliPPeh> :(
13:15:44 <gwern> FliPPeh: it's not ghci, it's mueval
13:16:28 <FliPPeh> I don't care, I want it to be ghci >:(
13:16:38 * FliPPeh demands
13:16:40 <FliPPeh> :)
13:16:41 <kbateman> c_wraith: thanks, but I think I'm on a successful track with a MVar (Event -> IO ()) here.
13:16:47 <FliPPeh> @let it = Nothing
13:16:48 <lambdabot>  Defined.
13:16:50 <chrisdone> gwern: well, at some point you need to launch mueval-core so you can impose rlimits separate from your main application..
13:16:50 <FliPPeh> :t it
13:16:51 <lambdabot> forall a. Maybe a
13:16:53 <FliPPeh> :D
13:17:07 <c_wraith> kbateman: however, you'll need the type signature to be more like (Process a b -> IO (a -> IO b))
13:17:13 <FliPPeh> How long will Lambdabot remember @let's?#
13:17:23 <gwern> chrisdone: rlimits aer a separate option which can be toggled on or off
13:17:35 <chrisdone> gwern: but they're pretty important, no?
13:17:40 <gwern> chrisdone: not especially
13:17:48 <gwern> chrisdone: the real work is done by the sandbox and timeouts
13:18:12 <aavogt> FliPPeh: until somebody @undefines or lambdabot has some temporary file removed
13:18:30 <gwern> chrisdone: have you looked at Resources.hs? it just renices the process and sets some ulimits
13:19:25 <hpaste>  . (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24856
13:19:27 <chrisdone> gwern: yeah I've read through it all. I just assumed everything you added was through some deep hardcore underground in the field sandboxing and thus was all important :p
13:19:39 <c_wraith> kbateman: Well, if you're curious, this works:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24856#a24856
13:20:17 <gwern> chrisdone: multiple layers of defense
13:20:49 <chrisdone> gwern: yeah exactly. I went with the safest bet... specially putting this on a live server
13:21:12 <chrisdone> gwern: so you don't think it needs rlimits?
13:21:14 <gwern> chrisdone: I'm not sure how to undo the rlimits, but it's easy to renice back to 0 if that really matters
13:21:17 <chrisdone> 'cause that makes things a lot simpler
13:22:12 <chrisdone> gwern: pretty sure it nices to 20?
13:22:22 <kbateman> c_wraith:  I've updated your hpaste page
13:22:31 <gwern> chrisdone: heck, --rlimits isn't even on by default
13:22:46 <gwern> I think someone would've complained by now if their lack led to problems
13:22:53 <Eelis> the function shown in http://codepad.org/pw1AXmvG works, but i don't get any pleasant reassurance that the cases cover the possible values for o. i could write binOpType out verbosely like "binOpType Plus = ...; binOpType Minus = ...". that would get me the reassurance, but would be very redundant. how do i get the best of both worlds?
13:22:56 <chrisdone> I've been using it
13:23:02 <chrisdone> or at least I think I had O_O
13:23:02 <kbateman> My code doesn't compile
13:23:05 <c_wraith> kbateman: the type on mkprocess isn't what you think.  It's the same type as mine
13:23:16 <gwern> chrisdone: right, but by default all interactive programs run at 0, so if one niced down to 20, the obvious undo is to nice back to 0
13:23:30 <c_wraith> kbateman: in fact, the only difference between our implementations is I used IORef, and you used MVar
13:23:38 <chrisdone> yeah i had, -r
13:23:40 <kbateman> And mine won't compile. :)
13:23:50 <wolgo> hi
13:23:50 <kbateman> The type is old and not current.
13:24:15 <c_wraith> kbateman: oh, you need to unpack your Process.  that's what I used record syntax for
13:24:53 <kbateman> I think I see what you mean
13:24:56 <wolgo> I love cheese. I am eating cheese and chorizo and wheat sesame crackers with a bottle of fine bundabergs ginger beer for lunch
13:24:59 <wolgo> now my life is good
13:25:21 <c_wraith> kbateman: my change should fix that problem
13:25:33 <c_wraith> kbateman: (updated the paste again)
13:25:50 <jlouis> Eelis: looks like we need or patterns http://hackage.haskell.org/trac/ghc/ticket/3919
13:25:55 <chrisdone> gwern: ah right. I'll give it a try
13:26:11 <kbateman> Yes, that works.  Thanks
13:26:35 <gwern> chrisdone: I don't think an extra monad is worth the trouble in this case; eval is already being lifted into IO from the GHC monad
13:26:38 <c_wraith> kbateman: now, is it better to use MVar or IORef in your use case?
13:26:41 <Eelis> jlouis: i guess those would do the trick. but there's no hope with current GHC (and its extensions)?
13:27:24 <wolgo> that or pattern thing looks pretty cool
13:27:29 <kbateman> I suppose MVar would be slightly slower, but it is only being read/updated at a mouse event frequency.
13:27:41 <chrisdone> gwern: sure
13:28:05 <jlouis> Eelis: perhaps you could define the RHS as a separate value and then refer to this value without or-patterns
13:28:06 <c_wraith> kbateman: is your event-handling loop only ever going to be single-threaded?
13:28:14 <chrisdone> gwern: I don't know if running inside the Interpreter monad is any faster. I imagine runInterpreter isn't expensive
13:28:28 <kbateman> I'm not planning on getting fancy.  I'm writing a casual-style game.
13:28:31 <gwern> chrisdone: at runtime I'd expect the layers to have been collapsed
13:28:35 <Eelis> jlouis: hmm
13:28:38 <kbateman> Very low CPU requirements.
13:28:39 <jlouis> Eelis: ugly, I know, but gives better reassurance. I used that trick quite a lot in SML compilers with no or-pattern support
13:29:01 <c_wraith> kbateman: in which case I *might* recommend using IORef instead, but let me look up one thing
13:29:03 <Eelis> jlouis: i guess it's an acceptable workaround. thanks!
13:29:48 <kbateman> c_wraith: I don't see any particular advantage that IORef has.  MVar has consistency guarantees that IORef lacks.
13:29:53 <thoughtpolice> jlouis: you mean mostly everything other than sml/nj ?
13:29:55 <thoughtpolice> :p
13:30:11 <aavogt> jlouis: that's quite similar to generalizing @ patterns to be and patterns (rather than just renaming)
13:31:06 <c_wraith> kbateman: those consistency guarantees only matter if there are multiple threads.
13:31:14 <aavogt> jlouis: it might be worthwhile prototyping as a quasiquoter?
13:31:46 <aavogt>  as in      f [$or|   pattern xyz  |  pattern abc |] = ...
13:32:10 <AnAdorableNick> \la\
13:32:18 <c_wraith> kbateman: anyway, looks like the fancy function I wanted to apply doesn't actually fit in this context.  So, consider it resolved in whichever way you want :)
13:32:26 <aavogt> ghc's syntax is quite extensible without modifying the compiler
13:32:27 <chrisdone> gwern: anyhoo it turns out speed of milliseconds doesn't matter for my needs. I'll probably just stick with what I've got setup, and next time I work on haskell-json rewrite it to use the mueval library to remove the unnecessary process handling and serializing of commands
13:32:43 <gwern> chrisdone: just calling the interpreter function?
13:32:55 <chrisdone> yeah, but with a watchdog
13:33:01 <kbateman> c_wraith: I used to have my mouse event handler pulling mouse events out of a Chan Event, and I was using IORefs.  Then I realized that there was a potential for consistency problems, so I switched to MVars.  Then I realized that the Chan wouldn't guarantee synchronous handling, so I got rid of the Chan.
13:33:13 <chrisdone> gwern: should be enough? would have to test
13:33:31 <AnAdorableNick> webwanderer: If you're trying to understand how Monads work, I wrote a tutorial to help you with that: http://strabismicgobbledygook.wordpress.com/
13:33:32 <EvanR-work> kbateman: whats wrong with Chan?
13:33:33 <c_wraith> kbateman: but as long as only one thread is reading from the Chan, where's the problem?
13:33:50 <gwern> chrisdone: hm. where would the watchdog be? it can't be just a thread
13:34:26 <kbateman> There can be a time gap between when somebody writes to the Chan and the handler responds to it.  I wanted things to be handled synchronously instead.
13:34:47 <webwanderer> AnAdorableNick: Cool.. thanks.. will read after I'm done with this.. http://www.haskell.org/all_about_monads/html/meet.html
13:34:57 <chrisdone> gwern: just use the watchDog function from Parallel?
13:35:06 <chrisdone> what forkedMain' does
13:35:20 <c_wraith> kbateman: but how many handler threads do you have?  if only one thread is calling waitEvent, there's no consistency issue anywhere
13:35:40 <kbateman> Chan never introduced any consistency issues.  Just a delay issue.
13:35:44 <EvanR-work> kbateman: if you write the chan, then it might immediately switch to the other thread to handle it
13:35:49 <gwern> chrisdone: no, a watchdog thread isn't enough. a watchdog thread can be beaten
13:35:51 <EvanR-work> thats an RTS configuration thing
13:35:59 <gwern> chrisdone: that's why mueval does both a watchdog thread and a watchdog process
13:36:01 <kbateman> EvanR-work: *might* is the operative word there.
13:36:20 <EvanR-work> kbateman: just dont use threaded
13:36:32 <chrisdone> gwern: ah so it does have to be a separate process... i gathered from what you said it didn't have to be, oh well
13:36:50 <kbateman> Now, I'm not using any threads.
13:36:50 <c_wraith> anyway, I can certainly see wanting synchronous handling.  But unless you're using forkIO in there, I don't see a consistency issue with IORef use.  still, MVar is cheap, so don't worry about it, I suppose.
13:37:08 <EvanR-work> kbateman: without threaded, according to the docs, forkIO context switches occur on concurrent operations, like writeChan
13:37:15 * chrisdone god bless these infernal headaches. without them I wouldn't be the unproductive grouch I am today
13:37:30 <gwern> chrisdone: a non-allocating thread will beat the watchdog thread. you can see this yourself if you remove the watchdog process and try evaluating let x = x in x, iirc
13:37:43 <EvanR-work> kbateman: of course, such a situation is similar to having no forkIO threads. but it all depends on the problem, does it need to be concurrent
13:37:45 <chrisdone> gwern: surely the timeout would beat it
13:38:02 <gwern> chrisdone: since the timers and whatnot go through the GHC RTS, and the ghc RTS only runs when memory allocation needs to be done, and there is no memory allocation in let x = x in x
13:38:02 <chrisdone> threadDelay .. ; killThread threadId
13:38:03 <kbateman> I understand threads and consistency issues and IORefs vs. MVars and forkIO
13:38:12 <chrisdone> ah right
13:38:16 <gwern> or whatever non-allocating evil expressions I put in tests.sh
13:38:17 <kbateman> Since I'm not using threads anymore I have no need for Chans
13:38:29 <chrisdone> yeah, I know let r = r in r doesn't allocate
13:38:33 <EvanR-work> indeed, you can just call the handler directly
13:38:43 <chrisdone> just sits looping happily
13:39:02 <kbateman> I was also working with openGL before, so I guess that had to do with my choice in event handling methods.
13:39:15 <gwern> chrisdone: right. I was mildly irked when I first learned about that problem :)
13:39:28 <EvanR-work> gl doesnt have much to do with the mouse
13:39:32 <kbateman> glut then
13:39:39 <EvanR-work> ah
13:39:43 <EvanR-work> that thing ;)
13:39:52 <tensorpudding> does GLUT actually deal with mouse and keyboard events/
13:39:55 <chrisdone> gwern: and the sigXCPU doesn't get triggered either?
13:39:58 <EvanR-work> i think so
13:40:00 <gwern> chrisdone: nope
13:40:05 <chrisdone> what a ballache
13:40:18 <kbateman> In GLUT you create mouse and keyboard event handlers and register them.
13:40:45 <RayNbow> hmm, is there a way to find all "subclasses" of a type class using Hoogle or Hayoo?
13:40:58 <gwern> chrisdone: haskell focuses on static safety, not runtime safety :)
13:41:20 <wolgo> hey are scalar products topics of linear algebra or just regular algebra?
13:41:27 <kbateman> http://cvs.haskell.org/Hugs/pages/libraries/GLUT/Graphics-UI-GLUT-Callbacks-Window.html
13:42:18 <kbateman> keyboardMouseCallback $= myeventhandler
13:42:34 <chrisdone> gwern: so, what I need is mueval-watchdog --interactive to call mueval-core --interactive, mueval-core loops calls to interpreter, and mueval-watchdog kills mueval-core if it doesn't respond within a timeout
13:42:55 <gwern> chrisdone: I'd put the looping in the watchdog
13:43:46 <maltem> wolgo, linear algebra is everything about vector spaces
13:44:04 <chrisdone> gwern: well I'd have to test how fast mueval launches. iirc this is why I put the loop in mueval-core, because mueval-core takes a long time to start-up
13:44:13 <gwern> suppose so
13:44:26 <chrisdone> I'd have to check, I'v only got my patched version installed atm
13:44:27 <chrisdone> sec
13:44:39 <wolgo> maltem: thanks.
13:45:50 <Cale> hmm, I'm highlighted, but it's been lost in the scrollback :]
13:46:43 <chrisdone> chris@chrisamilo:~/Haskell/mueval-0.8$ time mueval-core -e 1
13:46:43 <chrisdone> 1
13:46:43 <chrisdone> real0m0.542s
13:46:43 <chrisdone> user0m0.490s
13:46:48 <chrisdone> systemfault: 0m0.040s
13:46:51 <chrisdone> ouch
13:47:00 <chrisdone> gwern: what's the time on your system?
13:47:43 <gwern> 1.6s real; second run, .52s real
13:47:43 <FliPPeh> Cale, the highlights you don't need to pay attention to anymore are the best ones :)
13:47:49 <chrisdone> :/
13:48:18 <chrisdone> gwern: I wonder what part of it is slow. any ideas off the top of your head?
13:48:38 <gwern> chrisdone: ghc. I imagine just loading the ghc bits into memory takes a while
13:48:49 <gwern> mueval-core is 13M here
13:48:59 <dankna> yes, I notice about half a second to load dynamic-plugins the first call to it, too
13:49:10 <dankna> er, direct-plugins
13:49:15 <dankna> can't remember the name of my own utility ><
13:49:15 <nominolo> chrisdone: you stopped responding to the haskell.org redesign thread.  Any particular reasons?
13:50:21 <chrisdone> nominolo: lost interest tbh
13:50:54 <nominolo> chrisdone: did you have a particular plan how to do it?
13:51:20 <nominolo> chrisdone: fair enough
13:51:21 <chrisdone> gwern: so that's two levels of indirection mueval-core -> mueval but nothing speed-wise, and pretty easy to implement, too
13:52:22 <gwern> chrisdone: if you want mueval-core to remain running, then it needs to be rewritten to pipe some String back to mueval-watchdog
13:52:24 <chrisdone> nominolo: I was just going to write a mediawiki skin, it's pretty easy. but then a bunch of new designs and comments about doing it completely differently came up so I'll let those guys do it
13:52:37 <gwern> otherwise, how does the watchdog know when to kill -core or send it new lines to eval?
13:52:58 <nominolo> chrisdone: yeah, there have been no more complaints about my latest proposed design, so I'm planning on going ahead.
13:53:23 <chrisdone> gwern: yeah that's what my patched version does, except i compeltely disregarded mueval-watchdog and implemented it in haskell-json
13:53:45 <chrisdone> so if I just re-do it, but a lot neater, should be ok
13:53:51 <kbateman> c_wraith:  I put my new ugly MVar version on hpaste if you're interested.  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24856#a24859
13:54:15 <kbateman> c_wraith: I'm probably going to switch it back to Process now it's working.
13:54:38 <c_wraith> at this point, that looks simpler :)
13:54:56 <gwern> chrisdone: guess so. I wouldn't want so much to do it, but since you need to do it...
13:55:05 <chrisdone> nominolo: yeah if you grab the wikimedia version of the haskell.org site, you can just write a skin, it's all in php, easy
13:55:48 <nominolo> chrisdone: so the home page will be a separate skin?  and the rest remains wiki, right?
13:56:07 <chrisdone> nominolo: I dunno what you guys decided, but I was going to apply it globally
13:56:21 <gwern> too much discussion. make some changes already
13:56:29 <nominolo> gwern: I will
13:56:29 <chrisdone> yeah, exactly..
13:56:46 <nominolo> gwern: just checking with chrisdone what would work best
13:57:12 <wolgo> hey chrisdone did you make that haskell-fail tweet thingamajig?
13:57:17 <chrisdone> yeah
13:57:17 <nominolo> chrisdone: how hard would it be to have a separate skin for the homepage?
13:57:23 <wolgo> whee,that is cool
13:58:03 <chrisdone> wolgo: haha, did you try it?
13:58:03 <chrisdone> nominolo: fairly easy, ish. if you know php you could write an index page specially, or do a conditional in teh wikimedia skin
13:58:19 <nominolo> chrisdone: ok, i'll just try that then.
13:58:54 <wolgo> chrisdone: no,I was e-stalking random people to steal their papers and you were one of the victims
13:58:58 <wolgo> and I found your site
13:58:59 <chrisdone> :o
13:59:08 <wolgo> that is hilarious
13:59:19 * chrisdone beams
14:00:09 <chrisdone> gwern: what are yew working on?
14:00:22 <gwern> chrisdone: right now, I'm just reading stuff
14:02:21 <chrisdone> yeah I've been meaning to read about category theory for like a week. can't wait till i change jobs
14:02:26 * chrisdone go bed, night
14:02:38 <jlouis> thoughtpolice: yes, almost everything other than sml/nj
14:02:44 <jlouis> thoughtpolice: in particular mlton
14:03:20 <copumpkin> I wish mmorrow would reappear
14:04:41 <jlouis> combinatorrent will need some TLC in its parser and unparser of the wireprotocol it seems. Clearly that is the current bottleneck
14:05:54 <gwern> write it in assembler!
14:07:06 <danderson> jlouis: what is used right now for the parser?
14:07:16 <jlouis> danderson: cereal
14:07:32 <gwern> try eggs. more protein
14:07:34 <siracusa> copumpkin: Yeah, he's not replying to mails, I hope he's well.
14:07:39 <danderson> perhaps the new binary will work better
14:08:14 <jlouis> danderson: I am pretty sure it has a lot of room for improvement
14:08:18 <danderson> though I think it's using pretty much the same innards as cereal for unparsing
14:08:29 <jmcarthur> unparsing?
14:08:36 <jmcarthur> is that pretty printing?
14:08:37 <danderson> serializing, whatever
14:08:41 <jmcarthur> ah
14:09:13 <jmcarthur> i wasn't trying to point out a mistake. it was a legit question. you never know around these parts
14:11:30 <andrewsw> well, life's too short. it runs and I'm off. I'll come back when I have time to figure it out.
14:11:41 <andrewsw> oops... wrong window
14:12:09 <alpounet> guess so
14:12:50 <wolgo> hey
14:12:59 <wolgo> is there a haskell meetup in san francisco?
14:13:03 <wolgo> or just bayfp?
14:13:12 <wolgo> I would like to be the resident haskell noob.
14:13:14 * hackagebot Combinatorrent 0.2.1 - A concurrent bittorrent client  http://hackage.haskell.org/package/Combinatorrent-0.2.1 (JesperLouisAndersen)
14:17:15 <napping> Hello, has anyone read the new Hoopl paper? I wonder if you are guaranteed to reach the least fixedpoint?
14:19:18 <jlouis> ^^ that version of combinatorrent leaks much less than the earlier versions
14:21:05 <napping> I guess it should be fine - I was thinking of a case where you have two blocks which can both loop back to the same point, a statement S in B1 getting rewritten, and a fact that will no longer be justified after the rewrite, but has propagated all the way around through the parallel block - the join taken at the start should clear it up (and I'm not sure you are even allowed to transform like that)
14:21:23 <kbateman> I am puzzled.
14:21:33 <kbateman> fi = fromInteger
14:22:00 <Saizan> kbateman: write "fi x = fromInteger x"
14:22:17 <kbateman> :type fi prints "Integer -> Integer" instead of (Integral a, Num b) => a -> b
14:22:18 <Saizan> or the monomorphism restriction will come to bite you.
14:23:12 <kbateman> I meant to type fi = fromIntegral
14:23:30 <Saizan> kbateman: if you have a definition with no formal parameters which would have a typeclass context in its type, it will get a monomorphic type instead
14:23:52 <napping>  - if you don't give an explicit type signature
14:23:56 <Saizan> you can override that by giving an explicit type signature
14:24:06 <Saizan> or add a parameter, if it's a function
14:24:08 <kbateman> Saizan: without even a warning?  Integer is not part of fromIntegral's type signature.
14:24:11 * stevenmarky1 accidentally went to hoogle.org
14:24:33 <Saizan> kbateman: Num and Integral default to Integer
14:24:45 <Saizan> kbateman: there's a warning for that but it's not on by default
14:24:53 <kbateman> I am unfamiliar with this defaulting behavior.
14:25:13 <Saizan> kbateman: however, the monomorphism restriction is considered quite annoying in general
14:25:41 <kbateman> I have only a fuzzy understanding of the monomorphism restriction.
14:25:50 <Saizan> you could just stick a {-# LANGUAGE NoMonomorphismRestriction #-} and ignore it
14:25:57 <kbateman> I take it to mean that in the end, everything has to have a definite type.
14:26:03 <Saizan> no.
14:26:08 <Saizan> that's unrelated.
14:26:08 <dolio> Defaulting doesn't necessarily have anything to do with the monomorphism restriction.
14:26:08 <napping> defaulting is very limited, but basically if there is a type mentioned in a class constraint that can't be a free variable, it tries to instantiate it with Integer
14:26:13 <xerox> top level def - no unbound type variables
14:26:48 <Saizan> kbateman: the MonomorphismRestriction is just what i explained to you above about parameterless definitions.
14:26:49 <dolio> 'main = print 5' will use defaulting, but it's not related to the monomorphism restriction.
14:27:27 <napping> nice example
14:27:43 <napping> I was thinking like fromIntegral . fromIntegral $ 1
14:28:03 <kbateman> Ok, I see how just using "print 5" is interpreted as print $ fromInteger 5, and some kind of type has to be specified.
14:28:19 * hackagebot hMollom 0.2.2 - Library to interact with the Mollom anti-spam service  http://hackage.haskell.org/package/hMollom-0.2.2 (AndyGeorges)
14:28:42 <kbateman> or defaulted in there
14:28:45 <napping> Yeah, defaulting is the thing that happens in general when something can't be left polymorphic. And the monomorphism restriction says in particular that type classes for top level things have to be resolved
14:29:05 <kbateman> You'd have to have a lot of (:: Integer) annotations otherwise.
14:29:10 <Saizan> top level has nothing to do with the monomorphism restriction.
14:29:26 <Saizan> it applies to let or where bound things too
14:29:36 <dolio> It's definitions of the form 'v = ...'.
14:29:43 <ddarius> The monomorphism restriction and defaulting are both well covered in the Report.  It is quite readable.
14:30:00 <napping> hmm, for some reason I was thinking it didn't apply to local definitions
14:30:47 <kbateman> ok, thanks.
14:31:38 <dolio> Try: let f = \x -> x + x in (f x :: Int, f x :: Integer)
14:31:57 <dolio> That will give an error if the monomorphism restriction is enabled.
14:45:59 <wolgo> brandenburg concerto
14:46:30 <dolio> cellular phone
14:46:53 <wolgo> sorry
14:46:58 <wolgo> I meant to paste something else
14:47:07 <wolgo> hey why is hpaste so unreliable?
14:47:59 <wolgo> I guess that is like asking my mother how internet explorer works
14:53:18 <sm> I'd like to know too
14:58:30 <napping> Hmm, is the constant propagation pass in Hoopl correct?
14:59:04 <napping> the way they use thenFwdRw, it looks like it applies constant propagation, and then simplification
14:59:44 <napping> wait, that composition just describes how rewriting will happen inside the replaced graph, so constProp substitues constants, and then simpl won't add any new references
15:19:44 <wolgo> http://www.pastie.org/916544
15:20:45 <wolgo> each cell will have a wall (1) or a link to the adjacent cell(s) (0)
15:20:51 <wolgo> does that seem like a decent model?
15:21:33 <FliPPeh_> Jessica Alba would be a pretty decent model
15:21:46 * FliPPeh_ bails quickly
15:22:00 <wolgo> yes
15:22:10 <wolgo> let me create a type for that
15:22:11 <wolgo> brb
15:25:10 <FliPPeh_> :)
15:26:30 <wolgo> *Main> b
15:26:30 <wolgo> DatAss {roundness = 1, bounceFactor = 1}
15:26:42 <wolgo> datas
15:33:41 <haldaume> accidentally asked the following question in #ghc but then realized it wasn't the appropriate place... so now i'm trying here:
15:33:47 <haldaume>  I have a quick question about -fext-core.... Suppose I have a file called Foo.hs which contains one line: "addOne x = x+1".... I want to run "ghc -c -fext-core Foo.hs" to get a core out of it, but when I try that, it complains that 'main' isn't defined in Main.  I tried adding -no-hs-main but that doesn't fix it... any ideas?
15:42:07 <ezyang> Hmm, it looks like I can't fold (flip ($)) over a multivariadic function
15:42:46 <byorgey> ezyang: what would be the type of the arguement list?
15:43:05 <byorgey> wait, that's not the problem, the problem is that all the intermediate results need to have the same type
15:43:10 <ezyang> "Not very enlightening" plotWindow :: PlotWindowType a => a
15:43:19 <ezyang> byorgey: Oh, that would make sense.
15:44:12 <byorgey> you might be able to make it work with polymorphic recursion.
15:44:25 <byorgey> if you have a truly multivariadic function.
15:44:48 <byorgey> otherwise you are stuck doing  applyToList f [x,y,z] = f x y z  and so on
15:45:26 <kmc> vprintf :: String -> [exists a. (PrintfArg a) => a] -> IO ()
15:46:15 <ddarius> kmc: That would lead to: vprintf "%d %s" [pack 3, pack "bar"]
15:47:02 <ezyang> Chart's type signatures are making it really difficult for me to figure out how to use the API
15:49:44 <azl> Hello everybody. Say, we have some infinite list of IO actions ([a->IO ()]) and we want to do smth like mapM_ ()
15:50:07 <azl> mapM_ (\ f -> f a) list_of_io
15:50:54 <azl> can we be sure that all actions we have,  performing in the same order?
15:51:19 <FliPPeh_> azl: I think so, yes
15:51:36 <EvanR> off work
15:51:37 <FliPPeh_> It processes the list from head to tail, running each IO action
15:51:37 <byorgey> azl: those actions will definitely be executed in the order they appear in the list.
15:51:40 <EvanR> time for haskell!
15:51:55 <azl> fine!
15:52:00 <azl> thank you!
15:52:01 <ezyang> byorgey: What is polymorphic recursion?
15:52:02 <FliPPeh_> Unless one of your IO actions runs a thread which delays some action, it will all run fine
15:52:09 <ezyang> I couldn't find docs that actually said what it was.
15:52:38 <mauke> ezyang: when a function calls itself at a different type
15:53:05 <ezyang> so, you need to explicitly write the recursion?
15:53:20 <byorgey> ezyang: recursively calling a polymorphic function instantiated at *different* types than the ones in the current instantiation.
15:54:07 <azl> FliPPeh_: But default IO actions (such as writeFile), are they run in the same thread always?
15:54:16 <FliPPeh_> azl: Yep
15:54:21 <azl> good
15:54:34 <FliPPeh_> Unless your purposfully mess with something, it will all run in order
15:54:56 <EvanR> is there a list of common classes, like Monad, Monoid, Ord etc ?
15:55:23 <byorgey> preflex: seen portnov
15:55:23 <preflex>  portnov was last seen on #haskell 1 day, 7 hours, 30 minutes and 59 seconds ago, saying: @hackage chlor
15:55:54 <ddarius> EvanR: See the Typeclassopedia.
15:55:58 <mauke> preflex: seen ndm
15:55:58 <preflex>  ndm was last seen on #haskell 338 days, 12 hours, 37 minutes and 17 seconds ago, saying: plus with current compiler technology, it would be slower
15:56:01 <ddarius> http://www.haskell.org/haskellwiki/The_Monad.Reader
15:56:16 <byorgey> @tell portnov it is very much alive; I plan to do a bunch more work on it soon!
15:56:16 <lambdabot> Consider it noted.
15:56:17 <ddarius> http://www.haskell.org/sitewiki/images/8/85/TMR-Issue13.pdf
15:56:25 <EvanR> ddarius: awesome
15:57:06 <byorgey> Typeclassopedia doesn't cover Ord, but hopefully you can figure that one out on your own =)
15:57:38 <hpc> damn
15:57:40 <ddarius> EvanR: The Report (obviously) covers the standard classes.
15:57:48 <EvanR> ah, i need to check that out
15:57:51 <tensorpudding> How do you change the GHCi prompt?
15:57:54 <hpc_> both my usual nicks are registered
15:57:56 <hpc_> :set prompt
15:57:57 <ddarius> @where report
15:57:57 <lambdabot> http://www.haskell.org/onlinereport/
15:57:58 <byorgey> tensorpudding: :set prompt "foo"
15:58:05 <tensorpudding> Okay
15:58:22 <azl> byorgey: Are there some restrictions in ghc for such recursion? I mean, sometimes there's strange compiler error which is fixed by even more strange header directives.
15:59:08 <byorgey> azl: I think the only gotcha is that it can break type inference.  So you may be required to give a top-level type annotation for a function using polymorphic recursion.
15:59:25 <byorgey> or you may even have to give an inline type annotation at the call site, I forget if that is necessary.
15:59:31 <ddarius> You are required to provide a type annotation to utilize polymorphic recursion.
15:59:40 <ddarius> byorgey: That's not necessary.
15:59:40 <kmc> there is -XRelaxedPolyRec
15:59:46 <byorgey> ddarius: ok, thanks.
15:59:50 <ezyang> oooh, that's why it wasn't working
16:00:06 <byorgey> ezyang: oh, sorry, I should have said that before =)
16:00:12 <kmc> see GHC manual sec. 7.8.8
16:00:17 <azl> byorgey:  So compiler will never say smth like (use XUsePolimorphicRecursion Luke)
16:00:37 <byorgey> azl: I don't know.
16:00:43 <kmc> ghc does sometimes recommend extensions
16:00:52 <ezyang> yeah, it's quite handy
16:01:03 <kmc> particularly when you make a syntax error which would be valid with some extension
16:01:05 <kmc> which is not the case here
16:01:29 <siracusa> Is the result of pprint of an TH Dec supposed to be compilable Haskell code?
16:01:40 <byorgey> yeah, it seems like this would be a difficult extension to suggest.  But I don't know whether GHC ever does actually suggest it or not.
16:02:18 <byorgey> siracusa: I think so; do you have an example where it is not?
16:02:39 <ddarius> azl: Polymorphic recursion isn't an extension.
16:03:37 <siracusa> byorgey: [d| f ('@':_) = undefined|] gives ``f ('@' GHC.Types.: _) = GHC.Err.undefined'' which is not compilable even if I import GHC.Types
16:04:09 <azl> ddarius: unterstood...
16:04:25 <siracusa> byorgey: It says: Not in scope: data constructor `GHC.Types.:'
16:05:34 <byorgey> siracusa: hmm, odd.
16:06:17 <byorgey> siracusa: well, the module that declares the list constructor may not actually be exported by any package
16:06:30 <EvanR> what do you think of this idea, of course, it may have already been done. a web-based haskell interpreter which has its IO functions removed but replaced with commands to control page elements, draw graphics, etc?
16:06:59 <EvanR> display messages
16:07:08 <byorgey> siracusa: I assume it works if you remove the "GHC.Types" part?
16:07:20 <siracusa> byorgey: I'm wondering why the operator is qualified at all
16:07:39 <kmc> EvanR, very cool idea
16:07:44 <kmc> the first part already exists
16:07:45 <byorgey> siracusa: well, because internally TH represents every name in its fully qualified form
16:07:46 <kmc> (Try Haskell)
16:07:49 <EvanR> right
16:08:05 <siracusa> byorgey: Without qualification it works.
16:08:07 <byorgey> siracusa: the pretty-printing isn't smart enough to figure out where it can omit the qualifiers, I guess
16:08:12 <kmc> so you can augment that with an EDSL for describing such stuff
16:08:20 <ddarius> byorgey: It probably doesn't try.
16:08:21 <kmc> and then have the interpreter generate javascript from that
16:08:29 <byorgey> siracusa: anyway, the output of pprint is not *intended* to be actually compiled.
16:08:38 <byorgey> even though it usually can be in practice.
16:08:42 <EvanR> what i was thinking of, is have a predefined EDSL, but its not an interpreter, its just the straight source, you can read it or edit it, then 'rerun'
16:08:54 <EvanR> main = is the program to execute for the page
16:09:03 <byorgey> siracusa: if you want to compile a TH Dec, then you use a splice.
16:09:04 * hackagebot http-wget 0.6.0 - Provide a simple HTTP client interface by wrapping the wget  command line tool.  http://hackage.haskell.org/package/http-wget-0.6.0 (MichaelSnoyman)
16:09:31 <siracusa> byorgey: Ok, using it in a splice won't break compilation?
16:09:58 <byorgey> siracusa: no, it should work fine.
16:10:04 * hackagebot authenticate 0.6.0 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-0.6.0 (MichaelSnoyman)
16:10:48 <siracusa> byorgey: Well, that's all I want it to do, actually. pprint was only for debugging :-)
16:10:52 <byorgey> siracusa: although you can *think* of a splice as doing a textual substitution of the pretty-printed form, I'm sure it does something smarter than that -- i.e. most likely it directly splices in the generated AST into the AST it got from parsing the file
16:11:21 <byorgey> siracusa: ok =)
16:13:46 <EvanR> kmc: complete implementation in js? ;)
16:25:36 <EvanR> is there a function for this:  a - floor(a/b)
16:25:49 <EvanR> erm
16:26:00 <EvanR> a - b*floor(a/b)
16:26:02 * JuanDaugherty notes that the current CACM has an article on combining logic programming and FP
16:29:20 <dolio> EvanR: Is that mod for reals?
16:29:26 <EvanR> i guess
16:29:32 <ddarius> > fractionalPart (103/10)
16:29:33 <lambdabot>   Not in scope: `fractionalPart'
16:29:59 <EvanR> is there a generic way that works for floats and ints
16:30:13 <EvanR> i dont know the numeric stuff verywell yet
16:30:37 <dolio> > 5 `mod'` pi
16:30:38 <lambdabot>   1.8584073464102069
16:30:46 <EvanR> :o
16:30:55 <dolio> 5 - pi * fromIntegral (floor $ 5 / pi)
16:30:58 <EvanR> > 5 - pi*floor(5/pi)
16:30:59 <lambdabot>   Ambiguous type variable `a' in the constraints:
16:31:00 <lambdabot>    `GHC.Real.Integral a'
16:31:00 <lambdabot>   ...
16:31:01 <dolio> > 5 - pi * fromIntegral (floor $ 5 / pi)
16:31:02 <lambdabot>   1.8584073464102069
16:31:35 <EvanR> > 5.0 - pi*floor(5.0/pi)
16:31:36 <lambdabot>   Ambiguous type variable `a' in the constraints:
16:31:36 <lambdabot>    `GHC.Float.Floating a'
16:31:36 <lambdabot>  ...
16:31:44 <EvanR> floor returns an int
16:31:45 <ddarius> @src Fractional
16:31:46 <lambdabot> class  (Num a) => Fractional a  where
16:31:46 <lambdabot>     (/)             :: a -> a -> a
16:31:46 <lambdabot>     recip           :: a -> a
16:31:46 <lambdabot>     fromRational    :: Rational -> a
16:31:46 <dolio> > ((-5) `mod'` pi, (-5) - pi * fromIntegral (floor $ (-5) / pi))
16:31:47 <lambdabot>   (1.2831853071795862,1.2831853071795862)
16:31:53 <ddarius> @src RealFrac
16:31:53 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
16:31:53 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
16:31:54 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
16:32:36 <dolio> mod' is in Data.Fixed, as I recall.
16:32:40 <Draconx|Laptop> EvanR, yeah, which unfortunately makes it hard to define a good floating point remainder function (i.e. something equivalent to C's fmod or remainder functions).
16:33:33 <EvanR> well theres mod 5 pi
16:34:14 <Draconx|Laptop> > 5 `mod'` (0/0)
16:34:15 <lambdabot>   NaN
16:34:31 <EvanR> mod'
16:34:38 <EvanR> @src mod'
16:34:38 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
16:34:43 <Draconx|Laptop> > (1/0) `mod'` pi
16:34:44 <lambdabot>   NaN
16:36:40 <Draconx|Laptop> > 5 `mod'` (1/0)
16:36:41 <lambdabot>   NaN
16:36:50 <Draconx|Laptop> aha, there's a broken one :P
16:37:14 <EvanR> > (1,0) + (0,1)
16:37:15 <lambdabot>   No instance for (GHC.Num.Num (t, t1))
16:37:15 <lambdabot>    arising from a use of `GHC.Num.+' ...
16:37:18 <EvanR> damn
16:38:35 <dolio> Draconx|Laptop: That result isn't particularly surprising.
16:38:43 <dolio> Barring the function specially detecting infinities.
16:39:29 <EvanR> addTuple (a,b) (c,d) = (a+c, b+d)
16:39:30 <Draconx|Laptop> dolio, it is surprising.  The remainder of dividing 5 by infinity is 5.
16:39:49 <Draconx|Laptop> (5 divided by infinity is zero)
16:40:03 <EvanR> the limit of mod' 5 x is 5
16:41:05 <dolio> How are you going to figure that out, though? EvanR's algorithm (which is about the same as mod') gives the answer 5 - infinity * 0.
16:41:45 <Draconx|Laptop> dolio, right, that algorithm is wrong.
16:42:11 <EvanR> ieee defines mod?
16:42:29 <Draconx|Laptop> it defines REM, which is _slightly_ different.
16:43:04 <EvanR> does it say 'x mod inf is x, just is, deal with it' ;)
16:44:54 <dolio> It's actually somewhat surprising that mod' works at all with infinity, because it looks like it uses Rational as an intermediary.
16:44:54 <ddarius> > isInfinity (1/0
16:44:55 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
16:44:56 <ddarius> > isInfinity (1/0)
16:44:57 <lambdabot>   Not in scope: `isInfinity'
16:45:10 <Draconx|Laptop> > isInfinite (1/)
16:45:11 <lambdabot>   No instance for (GHC.Float.RealFloat (t -> t))
16:45:12 <lambdabot>    arising from a use of `GH...
16:45:12 <Draconx|Laptop> > isInfinite (1/0)
16:45:13 <lambdabot>   True
16:45:30 <Draconx|Laptop> > floor (1/0)
16:45:31 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
16:45:34 <dolio> > 1 % 0 -- and this
16:45:34 <Draconx|Laptop> whee...
16:45:35 <lambdabot>   * Exception: Ratio.%: zero denominator
16:46:16 <dolio> > toRational (1/0 :: Double)
16:46:16 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
16:46:55 <dolio> > mod' (1/0) (1/0)
16:46:56 <lambdabot>   NaN
16:47:05 <azl> infonity is sooo small...
16:47:06 <dolio> > div' (1/0) (1/0)
16:47:06 <lambdabot>   1
16:47:25 <EvanR> > floor Infinity
16:47:26 <lambdabot>   Not in scope: data constructor `Infinity'
16:47:31 <Draconx|Laptop> dolio, wow, that's even worse.
16:47:37 <dolio> Draconx|Laptop: Yeah.
16:47:40 <jmcarthur> > realToFrac (1/0 :: Double) :: Double
16:47:40 <lambdabot>   Infinity
16:48:01 <Draconx|Laptop> > realToFrac (0/0 :: Double) :: Double
16:48:02 <lambdabot>   -Infinity
16:48:09 <dolio> div' x y = floor (toRational x / toRational y)
16:48:12 <jmcarthur> @src realToFrac
16:48:12 <lambdabot> realToFrac = fromRational . toRational
16:48:28 <EvanR> i knew there was a finite number greater than all others, it starts with 179769... ;)
16:48:33 <jmcarthur> > (fromRational . toRational) (1/0 :: Double) :: Double
16:48:34 <lambdabot>   Infinity
16:48:49 <Draconx|Laptop> EvanR, well, you just need to take that ellipsis quite literally.
16:49:17 <dolio> Float/Double -> other stuff is kind of wonky in GHC.
16:49:17 <EvanR> > (toRational (1/0 :: Double)) + 1
16:49:18 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
16:49:22 <EvanR> hoho!
16:49:31 <Draconx|Laptop> dolio, including to themselves :P
16:49:34 <jmcarthur> > 179769 + sum (repeat 1)
16:49:40 <lambdabot>   mueval: ExitFailure 1
16:50:15 <jmcarthur> > (toRational (1/0 :: Double)) ^ 2
16:50:19 <lambdabot>   mueval-core: Time limit exceeded
16:50:57 <Axman6> > properFraction pi
16:50:59 <lambdabot>   (3,0.14159265358979312)
16:51:03 <EvanR> > isInfinite (toRational (1/0 :: Double))
16:51:05 <lambdabot>   No instance for (GHC.Float.RealFloat GHC.Real.Rational)
16:51:05 <lambdabot>    arising from a u...
16:51:29 <EvanR> > (toRational (1/0 :: Double)) `div` (10^99)
16:51:30 <lambdabot>   No instance for (GHC.Real.Integral GHC.Real.Rational)
16:51:30 <lambdabot>    arising from a use...
16:52:04 <EvanR> Draconx|Laptop: its an infinite number?
16:52:09 <azl> lets count akkerman's function of graham numbers (g64), is it bigger than 17976931348623159077293051....
16:52:54 <tensorpudding> How many digits is g64, anyway
16:53:02 <dolio> azl: How do you know? lambdabot didn't print the whole number. :)
16:53:06 <Draconx|Laptop> tensorpudding, more than you can possibly imagine.
16:54:08 <azl> dolio: ackkermann(g64,g64) > Infinity?
16:55:11 <EvanR> whats g64
16:55:23 <kmc> ITT we are ultrafinitists
16:56:47 <tensorpudding> g_64 is called Graham's number, it has the dubious honor of being the largest number ever considered as an upper bound in a proof.
16:57:17 <tensorpudding> it's only able to be compactly represented using special notation.
16:57:21 <dolio> Oh, is that where it comes from?
16:57:29 <tensorpudding> That's what I heard.
16:57:52 <tensorpudding> It was for a proof in Ramsey theory
16:57:56 <dolio> I'd always just figured Graham was just sitting around trying to come up with really big numbers.
16:58:02 <EvanR> lol
16:58:46 <Only-One> Hi friends, I invite you to a new network of mIRC, /s -m irc.joinirc.org [join #CService for HELP]
16:58:50 <Gray_> Its actually a bit harder than you would think :P
16:59:09 <Gray_> Have to learn all this pesky notation...
16:59:15 <Draconx|Laptop> g_{g_64} :P
17:00:09 <EvanR> the trick is stopping!
17:00:16 <tensorpudding> xkcd came up with A(g_64,g_64), which would rather make g_64 seem small
17:00:22 <EvanR> (repeat "g_") ++ "64"
17:00:45 <EvanR> if you arent careful you get infinity ;)
17:01:12 <tensorpudding> though the thing with numbers is that no matter what you do, you can make something obscenely larger
17:01:34 <dolio> Unless we actually are ultrafinitists. :)
17:01:42 <tensorpudding> any n you can do, i can do succ(n)
17:02:09 <dankna> that's nothing.  for any function succ(n) you can define, I can define one that grows at least slightly faster!
17:02:13 <mauke> I'll succ your digits
17:03:08 <tensorpudding> Hmm.
17:03:43 <killing-joke> i am looking to set up a web app with access control and a db to keep track of users. i see a few things at haskell.org that look likely, but i doubt that i can evaluate them yet. i'm a complete Haskell n00b.
17:03:55 <killing-joke> can anyone recommend one to start with?
17:10:25 <twink> I guess one can look at http://en.wikipedia.org/wiki/Fast-growing_hierarchy
17:11:11 <kmc> killing-joke, happstack is the popular web app framework for Haskell
17:11:38 <JuanDaugherty> popular as in only?
17:11:41 <EvanR> is polymorphism implemented at runtime with dynamic dispatch
17:11:44 <killing-joke> kmc, cool! thanks!
17:11:51 <kmc> EvanR, what kind of polymorphism?
17:11:57 <kmc> EvanR, and do you mean in GHC code specifically?
17:12:00 <EvanR> ghc
17:12:11 <EvanR> +
17:12:17 <kmc> JuanDaugherty, there are other http servers on hackage.  don' tknow if they count as "frameworks"
17:12:19 <kmc> there's a tutorial at http://tutorial.happstack.com/
17:12:24 <kmc> which is currently giving "connection refused"
17:12:25 <JuanDaugherty> killing-joke, it's freenode channel is #happs (the name of the predecessor pkg)
17:12:27 <dankna> no, not only.  there's also my own FruitTart, but it's unreleased.
17:12:28 <kmc> which does not inspire confidence
17:12:42 <dankna> and undocumented.
17:12:45 <dankna> so I can't really recommend it.
17:12:49 <dankna> especially to a beginner.
17:12:54 <JuanDaugherty> *its
17:13:02 <ddarius> EvanR: Polymorphism is implemented like it is in C only the discipline is enforced by the compiler.
17:13:13 <kmc> EvanR, parametric polymorphism is very simple to implement.  just make sure every value that can be used polymorphically has the same size in memory
17:13:24 <kmc> that's why you can only use boxed values polymorphically
17:13:31 <EvanR> that makes sense
17:13:32 <kmc> they are all represented by a single machine word, a pointer into the heap
17:13:52 <tensorpudding> The typechecker is like the postal system, moving boxes around and assigning labels to them
17:13:58 <EvanR> now theres the case where you have to decide which of several instance function implementations to use
17:14:08 <kmc> EvanR, that's ad-hoc polymorphism
17:14:10 <kmc> as compared to parametric
17:14:15 <EvanR> ok
17:14:18 <kmc> that's implemented in GHC by "dictionary passing"
17:14:20 <kmc> that is, imagine
17:14:25 <Apocalisp> http://sites.google.com/site/womenofhaskell/Pictures829.jpg
17:14:32 <Apocalisp> rawr
17:14:34 <kmc> data EqDict a = EqDict (a -> a -> Bool)
17:14:48 <kmc> now a function of type (Eq a) => a -> b
17:14:54 <kmc> can be converted to one of type EqDict a -> a -> b
17:15:07 <dolio> Note, though, that it doesn't have to be implemented that way.
17:15:07 <kmc> and the call to the typeclass method is replaced by calling the function explicitly inside the "dictionary"
17:15:19 <dolio> jhc implements it differently, for instance.
17:15:34 <kmc> EvanR, then often, constant folding and inlining will make it obvious at compile time which dictionary is involved
17:15:38 <kmc> so you don't always end up passing them
17:15:47 <kmc> but ideally that is just a consequence of some general purpose optimizations
17:16:13 <EvanR> wait, what do these dictionaries do?  (a->a->Bool)...
17:16:56 <kmc> EvanR, compare sort and sortBy
17:17:02 <kmc> one gets its ordering from the type class Ord
17:17:08 <kmc> one gets an explicit (a -> a -> Ordering) function
17:17:12 <kmc> (both of these are in Data.List)
17:17:33 <EvanR> ok
17:18:10 <mail> how cani make a maybe int into an int
17:18:10 <kmc> the idea is that a compiler can translate all type class constrained values into functions that take instances explicitly
17:18:12 <EvanR> so the implementation for the operation is passed into the function at the same time as the value of that type
17:18:18 <kmc> mail, you can't -- it might be Nothing
17:18:24 <kmc> mail, you can pattern match and handle both cases, i.e.
17:18:37 <kmc> > case Just 3 of Nothing -> "not a thing"; Just v -> ("the thing is: " ++ show v)
17:18:41 <lambdabot>   mueval-core: Time limit exceeded
17:18:42 <mail> but i know it will be an int
17:18:53 <kmc> what
17:18:57 <EvanR> make a Nothing case anyway
17:18:59 <kmc> mail, how do you know?
17:19:08 <mail> if then else
17:19:15 <EvanR> ah
17:19:16 <kmc> mail, then you're probably doing it wrong
17:19:17 <EvanR> nevermind
17:19:23 <kmc> you should use case *instead* of the conditional
17:19:24 <dolio> > fromJust (Just 5)
17:19:25 <lambdabot>   5
17:19:25 <EvanR> doing it wrong (tm)
17:19:26 <mail> http://pastebin.com/mj1djYvz
17:19:50 <kmc> mail, find x y = case elemIndex x y of Nothing -> -1; Just v -> v
17:20:14 <EvanR> > maybe "haha" id (Just "hoho")
17:20:16 <lambdabot>   "hoho"
17:20:21 <EvanR> > maybe "haha" id (Nothing)
17:20:22 <lambdabot>   "haha"
17:20:38 <kmc> mail, why do you want a find function with that behavior?
17:20:44 <dolio> > fromMaybe "haha" (Just "hoho")
17:20:45 <lambdabot>   "hoho"
17:20:54 <kmc> using -1 as a special sentinel value -- that's very un-Haskelly.  that's precisely *why* we have things like Maybe
17:20:56 <EvanR> fromMaybe, there you are!
17:20:59 <mail> because ma prof said so :P
17:21:10 <kmc> mail, your prof is assigning problems that will teach bad habits ;P
17:21:10 <mail> and he a java programmer
17:21:15 <kmc> oh dear
17:21:26 <kmc> good luck...
17:21:31 <Gray_> well, theres  your problem :P
17:21:42 <EvanR> learn haskell and teacher prof some new tricks
17:21:45 <mail> yep
17:21:57 <mail> we solve problems in very unhaskelly way with haskell
17:22:02 <kmc> sigh
17:22:06 <EvanR> that must be horrendous
17:22:11 <kmc> is the name of the course "Java Programming in Haskell"?
17:22:25 <dolio> Using -1 instead of Maybe is something the compiler should figure out. :)
17:22:29 <kmc> bring your prof here so we can fight
17:22:30 <mail> it's easier for the people who don't know shit about programming as they are taught the c like languages first
17:23:00 <azl> killing-joke: try vocabulink (google it) it have literal haskell sources on main page... fine point to figure out what you want.
17:23:02 <mail> but yeah this module they taught us Java then haskell
17:23:39 <killing-joke> azl, thanks a bunch!
17:23:40 <EvanR> kmc: ok i get dictionary passing. now why do c++ etc use dynamic dispatch?
17:24:01 <kmc> "in this course we will first teach you how to make a firecracker.  then we will teach you how to make a hydrogen bomb by gluing lots of firecrackers together."
17:24:10 <kmc> EvanR, do you mean that as "by contrast"?
17:24:27 <Axman6> mail: they did it the wrong way around
17:24:28 <EvanR> i guess, it seems less efficient
17:24:51 <kmc> EvanR, they don't seem like alternatives to me
17:24:58 <dolio> What do you think dynamic dispatch is?
17:25:03 <kmc> every function (and every value) in GHC Haskell is dynamically dispatched
17:25:17 <dolio> Isn't it coupling data with a dictionary of methods?
17:25:21 <EvanR> a jump table to virtual method implementations?
17:25:29 <kmc> the dictionary is like a vtable, if you like
17:25:48 <kmc> EvanR, entering a function in GHC-generated code is usually an indirect call
17:25:48 <EvanR> the dictionary isnt the implementation directly?
17:25:52 <kmc> except it will do some optimizations
17:26:43 <kmc> the in-memory repr. of a typeclass dictionary will look a lot like a vtable
17:27:54 <kmc> and the in-memory repr. of an existentially quantified typeclass-constrained variable will look a lot like an object with a pointer to a vtable glued on the front
17:27:57 <dolio> The main difference might be that the way Haskell code tends to be structured makes it easier to statically determine what vtable is used, and therefore eliminate it.
17:28:09 <kmc> EvanR, not sure what you mean by "the dictionary isnt the implementation directly?"
17:28:23 <ezyang> Is there a way to make the heavy-weight Chart interface automatically assign colors for me?
17:28:40 <EvanR> perhaps im thinking of the implementation as a thunk, and the dict as the address of the thunk
17:29:10 <sm> ezyang, I don't think there is
17:29:16 <EvanR> to enter that you jump to that address
17:29:28 <EvanR> rather than looking up the address in a table first
17:29:45 <EvanR> based on a type ?
17:30:14 <EvanR> in this way, you dont have to pass anything to functions besides the value itself, with a type tag
17:30:22 <mail> what does Just v do
17:30:22 <sm> ezyang: I make my own at at the end of http://joyful.com/repos/hledger/Commands/Chart.hs
17:30:40 <ezyang> 404
17:30:47 <EvanR> mail: this
17:30:50 <EvanR> > Just 4
17:30:51 <lambdabot>   Just 4
17:31:05 * sm frowns
17:32:08 <sm> ohh, right.. apache reconfig, one sec
17:33:41 <sm> ezyang: should be ok now
17:34:05 <ezyang> cool, thanks
17:34:47 <ezyang> what does the double indicate?
17:35:47 <sm> ezyang: a basic hue, I wanted different shades of (say) green
17:35:50 <ezyang> aha
17:38:35 <EvanR> dont laugh at this question. is there a way to have 'optional' parameters to a function
17:38:43 <EvanR> default values
17:38:59 <tensorpudding> a function always needs to have the same number of arguments
17:39:08 <EvanR> yes
17:39:13 <tensorpudding> that said, you could make the argument a record type
17:39:19 <dolio> You can kind of mimic it with record update.
17:39:20 <Draconx|Laptop> EvanR, you sort of can, by employing type class hacks.
17:39:23 <tensorpudding> and the record type could have "defaults"
17:39:26 <dolio> Or do some evil stuff with type classes.
17:39:33 <kmc> tensorpudding, yes, and that number is one :)
17:40:08 <kmc> EvanR, http://byorgey.wordpress.com/2010/04/03/haskell-anti-pattern-incremental-ad-hoc-parameter-abstraction/
17:40:21 <kmc> that just about covers it i think
17:40:28 <EvanR> on a smaller scale though, im thinking the best way is defined a new function
17:40:34 <EvanR> f x y z = ...
17:40:40 <EvanR> g x y = f x y 8
17:40:49 <kmc> type classes are useful for actually variadic / dependently typed functions like printf
17:41:03 <ezyang> sm: Hm, I can't figure out where to put the colors
17:41:10 <kmc> this is more like a regular function but you want sugar for leaving out some args
17:41:13 <ezyang> since they don't seem to be the right type
17:41:43 <hpc_> if all your parameters are of the same type, you can use an array or map
17:42:17 <EvanR> checking this antipattern blog
17:43:13 <EvanR> k'
17:43:31 <EvanR> next question
17:43:56 <EvanR> if i want to use the do notation sugar, do i HAVE to make my structure a monad?
17:44:05 <kmc> pretty much yes
17:44:07 <hpc_> yes
17:44:17 <kmc> unless you want to use -XNoImplicitPrelude and redefine (>>=) and return yourself
17:44:24 <kmc> and that puts you into serious crazyland
17:44:36 <EvanR> hm.
17:44:41 <kmc> EvanR, i should say, you have to make your structure an instance of the typeclass "Monad"
17:44:47 <EvanR> yes
17:44:51 <kmc> whether an instance of the typeclass "Monad" is actually a monad depends on whether it follows the monad laws
17:44:55 <kmc> and that's not checked in any way
17:45:12 <kmc> and in fact various instances cheat
17:45:33 <kmc> like the Omega monad only obeys the laws up to reordering of the output list
17:45:49 <EvanR> i seem to have a monoid here, but im not sure. but to combine several monoid elements you use... mconcat [x,y,z,w], i think
17:45:57 <kmc> :t mconcat
17:45:58 <lambdabot> forall a. (Monoid a) => [a] -> a
17:46:09 <kmc> :t mappend
17:46:10 <lambdabot> forall a. (Monoid a) => a -> a -> a
17:46:13 <EvanR> would be nice if i could do x >> y >> z >> w
17:46:21 <kmc> EvanR, why (>>) and not some other operator?
17:46:31 <kmc> such as (++)
17:46:33 <EvanR> because that has do sugar ;)
17:46:52 <EvanR> and because the mappend operation is 'do y after x'
17:46:52 <dolio> That's what writer does.
17:46:56 <kmc> you want to write "do { x; y; z }" instead of "x ++ y ++ z"
17:46:57 <kmc> ?
17:46:59 <dolio> tell x >> tell y >> tell z >> tell w
17:47:12 <hpc_> :t tell
17:47:13 <lambdabot> forall w (m :: * -> *). (MonadWriter w m) => w -> m ()
17:47:18 <napping> haldaume: you need a "module Foo where" line - otherwise you have to have a main. -no-hs-main is unrelated, it's only about making FFI programs where C has the main()
17:47:20 <kmc> yeah, Writer makes sense if you're doing computations and you want to generate monoid elements along the way
17:47:30 <sm> ezyang: figured it out ? I passed them in the _pie_colors field above
17:47:56 <ezyang> sm: Not quite. I don't think I'm using Data.Accessor correctly
17:48:05 <ezyang> let me hpaste
17:48:11 <kmc> EvanR, monoids don't have nearly the structure necessary for the full "do" notation to work
17:48:19 <EvanR> right, >>=
17:48:23 <kmc> "computations generating monoid values on the side" do
17:48:24 <kmc> that's a monad, named Writer
17:48:37 <EvanR> yeah but i dont want to do tell tell tell
17:48:43 <hpaste>  . (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24860
17:48:44 <ezyang> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24860#a24860
17:48:52 <ezyang> oh man, cool
17:49:01 <kmc> EvanR, where do these values come from?
17:49:10 <EvanR> constructors and combinators
17:49:12 <kmc> if they're returned by a function, that function could also apply "tell"
17:49:17 <kmc> but anyway
17:49:37 <kmc> the simplest solution is to use some infix operator other than (>>)
17:49:48 <EvanR> so far its `after`
17:50:03 <kmc> note that you can hide (Prelude.++) and let (++) = mappend
17:50:06 <EvanR> probably would make more sense to call it before
17:50:16 <kmc> :t (++)
17:50:16 <kmc> and it will still work on lists
17:50:16 <kmc> what's with lambdabot
17:50:17 <lambdabot> forall m. (Monoid m) => m -> m -> m
17:50:46 <EvanR> i wonder if im really thinking of a list
17:51:06 <dolio> > map succ . [1..10]
17:51:07 <lambdabot>   No instance for (GHC.Enum.Enum [a])
17:51:07 <lambdabot>    arising from the arithmetic sequence...
17:51:16 <kmc> EvanR, [a] is the "free monoid" on a
17:51:20 <dolio> > succ . [1..10]
17:51:21 <EvanR> right
17:51:21 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
17:51:36 <kmc> meaning basically a monoid without any laws of cancellation or equivalence
17:51:53 <kmc> because a ++ b  never equals  []   for instance
17:51:59 <kmc> but it could in a valid monoid
17:52:02 <ezyang> oh, looks like it's my problem
17:52:15 <kmc> also if you care about operational details, (++) on lists can get slow
17:52:26 <ezyang> fixed!
17:52:40 <ezyang> it doesn't look like I get very much color variety though...
17:52:59 <mail> why can't i find any information on the just keyword
17:53:07 <kmc> mail, it's not a keyword
17:53:14 <kmc> it's a data constructor defined in the standard library
17:53:14 <napping> haldaume: -fext-core works fine on a named module with a trivial function. ghc -c fails even without -fext-core on a module with no name line and no main
17:53:14 <EvanR> @src Maybe
17:53:15 <lambdabot> data Maybe a = Nothing | Just a
17:53:16 <kmc> @src Maybe
17:53:16 <lambdabot> data Maybe a = Nothing | Just a
17:53:21 <EvanR> theres the doc ;)
17:53:22 <tensorpudding> @src Maybe
17:53:22 <lambdabot> data Maybe a = Nothing | Just a
17:53:39 <kmc> any value of type (Maybe a) is either the single value Nothing, or it's a value of the form (Just v) where v is of type a
17:53:58 <kmc> if you like, (Maybe t) is the type of "lists of at most one t"
17:54:02 <mail> ah i see
17:54:22 <kmc> mail, being a constructor, it's both a function  Just :: a -> Maybe a,  and also a building block for pattern matching
17:54:49 <EvanR> ok.
17:55:29 <kmc> err "a ++ b never equals []" is blatantly wrong
17:55:32 <kmc> sorry
17:55:53 <EvanR> so i had possibly infinite paths through the plane as functions, combining them made more complex functions. but now i think i will use list of finite paths. an infinite path is a list of finite paths
17:56:21 <kmc> but a ++ b == mzero  implies  a == mzero and b == mzero
17:56:23 <kmc> for lists
17:56:32 <kmc> but not for arbitrary monoid
17:56:33 <kmc> anyway
17:56:36 <kmc> sounds good EvanR
17:56:55 <EvanR> [] will be 'stopped at the origin'
17:58:15 <ezyang> Say I have function that looks like line (color, (name, ticks)) = ... How can I make that prettier?
17:58:28 <ezyang> it's invoked in: map (Left . toPlot . line) (zip colors fulldata)
17:58:30 <kmc> don't take tuples as args
17:58:42 <kmc> use zipWith instead
17:58:53 <mail> bah indentation mode is fail in haskell
17:58:55 <kmc> line color (name,ticks) = ....; zipWith line colors fulldata
17:58:56 <hpc_> :t zipWith
17:58:57 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
17:59:09 <ezyang> oh, I guess I get a built-in map with that, don't I
17:59:21 <kmc> zipWith is like map yes
17:59:24 <c_wraith> :t zipWith3
17:59:25 <lambdabot> forall a b c d. (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
17:59:26 <kmc> OCaml calls it map2 iirc
18:00:12 <EvanR> mail: 'tab inserts spaces' is a feature of several text editors ;)
18:00:14 <kmc> mail, what's failing?
18:00:20 <kmc> yes, you should avoid using tabs at all
18:00:27 <kmc> if you use tabs you have to be very consistent
18:00:34 <EvanR> and vim has a mode where backspace knows whether it was a 'tab'
18:00:35 <kmc> also other people will hate reading or editing your code
18:01:04 <mail> looks like tabs was the problem
18:01:16 <hpc_> i wouldn't mind seeing tabs become a syntax error automatically in future compilers
18:01:28 <hpc_> since it almost always leads to one anyway
18:01:29 <kmc> there should be a warning you can enable at least
18:01:46 <EvanR> haskell has a way of deciding the winner of tabs vs spaces war ;)
18:01:56 <kmc> or you can opt not to use layout at all
18:02:03 <kmc> and then use whatever whitespace you like
18:02:22 <QtPlatypus> python and YAML have also fell towards tabs being errors
18:02:50 <EvanR> all tabs in python is actually readable though
18:04:20 <hpc_> EvanR: the war isn't tabs vs spaces, the war is 4 spaces vs 2 spaces :P
18:05:00 <gwern> hpc_: I don't see what the problem is. they're both O(1) # of spaces
18:05:07 <gwern> they just differ by a constant factor :)
18:05:12 <hpc_> haha
18:05:34 <hpc_> so real men use a logarithmic indentation scheme?
18:05:47 <Draconx|Laptop> gwern, hm, but the factor is not constant :P
18:05:54 <Niccus> real men type in hyperbolic space
18:06:41 <gwern> hpc: what else would they use?
18:06:47 <ezyang> bah, this still looks ugly zipWith (\x y -> Left . toPlot $ line x y) colors fulldata
18:06:55 <hpc> heh
18:07:28 <gwern> @pl \x y -> Left . toPlot $ lines x y
18:07:28 <lambdabot> ((Left . toPlot) .) . lines
18:08:42 <hpc> </3 (x .) . pointfree style
18:08:54 <ezyang> I don't think i actually want to do that
18:09:40 <gwern> maybe factor it out then
18:17:31 <conal> i like (result.result) (Left . toPlot) lines
18:17:48 <conal> (or s/result/fmap/g )
18:18:16 <ezyang> while I know fmap fmap fmap will do the job here, it doesn't seem sufficiently idiomatic
18:19:08 <conal> and 'fmap fmap fmap' it doesn't generalize as nicely as result.result
18:19:30 <hpc> i think the idiomatic thing to do would be to find part of that expression which you might reuse and give it a name, then use that to shorten the expression
18:21:07 <conal> i guess it depends on your bag of idioms.  once i saw the light (type paths), SECs became nearly effortless for me now to read & write.
18:22:10 <thoughtpolice> SEC?
18:23:00 <conal> @where SEC
18:23:01 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
18:23:17 <EvanR> zipWith f where f x y z = g (line x y); g = Left . toPlot
18:23:24 <EvanR> \i/
18:23:24 <aavogt> @type result
18:23:25 <lambdabot> Not in scope: `result'
18:23:27 <EvanR> o
18:23:40 <conal> which describes a special case of a more general notion.
18:23:42 <conal> @where eros
18:23:42 <lambdabot> http://conal.net/papers/Eros
18:24:02 <conal> for the function arrow, result == (.)
18:24:10 <aavogt> result = fmap?
18:24:19 <conal> aavogt: no.  only for functions
18:24:24 <conal> aavogt: not in general.
18:24:46 <conal> aavogt: it's an arrow notion, not a functor notion.
18:25:17 <conal> ie part of an extension to Arrow.
18:25:20 <conal> @wiki DeepArrow
18:25:20 <lambdabot> http://www.haskell.org/haskellwiki/DeepArrow
18:25:58 <conal> described in the Eros paper (tangible functional programming) and illustrated in the corresponding google tech talk.
18:26:40 <aavogt> @type arr
18:26:41 <EvanR> :t div
18:26:41 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
18:26:42 <lambdabot> forall a. (Integral a) => a -> a -> a
18:26:56 <EvanR> :t /
18:26:57 <lambdabot> parse error on input `/'
18:27:01 <conal> ("fmap fmap fmap" misses that point.)
18:27:02 <EvanR> :t (/)
18:27:03 <lambdabot> forall a. (Fractional a) => a -> a -> a
18:27:29 <hpc> :t (fmap fmap fmap)
18:27:30 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
18:27:37 <hpc> o.O
18:29:39 <conal> :t fmap.fmap
18:29:40 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
18:29:55 <conal> no loss of generality
18:30:33 <conal> the other reason i don't write "fmap fmap fmap".
18:34:04 <altmattr> where do I get a better `read` method?
18:34:14 <altmattr> Prelude.read: no parse
18:34:21 <altmattr> is just not cutting it
18:34:27 <hpc> reads
18:34:35 <hpc> returns [(String, a)]
18:34:53 <hpc> :t reads
18:34:54 <lambdabot> forall a. (Read a) => String -> [(a, String)]
18:35:10 <altmattr> hpc: nice!  thanks
18:36:52 <EvanR> drop elements from the list until a certain condition is true, and the condition depends on the accumulation of elements being dropped
18:37:04 <EvanR> sort of fold, dropWhile
18:37:47 <azazell> offtopic question.... which irc-clients do you use?
18:38:01 <greedo> irssi!
18:38:12 <tensorpudding> ERC.
18:38:15 <hpc> chatzilla, until i have time to code my own
18:38:18 <aavogt> there's one written in haskell
18:38:21 <deco> can anyone reccommend a good haskell for beginners tutorial ?
18:38:27 <tensorpudding> @where lyah
18:38:27 <lambdabot> http://www.learnyouahaskell.com/
18:38:28 <hpc> learn you a haskell
18:38:36 <hpc> heh
18:38:56 <hpc> it doesn't cover monads, but the gentle introduction on the wiki is good for that
18:39:00 <azazell> http://book.realworldhaskell.org/read/
18:39:01 <hpc> @where gentle intro to monads
18:39:02 <lambdabot> http://www.haskell.org/tutorial/
18:39:06 <deco> thanks!
18:39:07 <deco> :)
18:39:16 <blackdog> curious, actually - has anyone here encountered haskell for the first time through RWH or LYAH? how were they?
18:39:28 <hpc> i found it through lyah
18:39:35 <hpc> it is now my language of choice
18:39:59 <tensorpudding> I found Haskell through real people.
18:40:02 <hpc> within a month of finishing the tutorial, i had an IRC bot that did symbolic differentiation
18:40:11 <tensorpudding> Though my first tutorial was the gentle introduction
18:41:50 <azazell> my practice with haskell begun with RWH... I finnaly wrote my first haskell app completely...
18:42:18 <gwern> @wn maury
18:42:20 <lambdabot> No match for "maury".
18:42:53 <azazell> @where rwh
18:42:53 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
18:43:10 <azazell> automagic...
18:43:51 <tomoj> how does cabal have completion built in?
18:45:22 <blackdog> tomoj: it does?
18:46:22 <dcoutts_> it does, yes
18:47:25 <dcoutts_> tomoj: the --list-options flag
18:47:26 <tomoj> but how?
18:47:33 <dcoutts_> it can be used at any point in the command line
18:47:35 <EvanR> dropWhile scanl...
18:47:46 <tomoj> so any binary which has a --list-options flag gets completion in bash?
18:48:04 <dcoutts_> tomoj: oh, no, that's provided by the bash-completion/cabal script
18:48:17 <tomoj> yeah, strange thing is that I can't find that anywhere
18:48:19 <dcoutts_> which calls cabal with the --list-options in the appropriate place
18:48:39 <scotty> I'm reading "A Gentle Introduction to Haskell" and this is blowing my mind: fib             = 1 : 1 : [ a+b | (a,b) <- zip fib (tail fib) ]
18:49:00 <Niccus> is the mindblowing gentle at least
18:49:04 <dcoutts_> tomoj: it's in the source tarball. The problem is, there's no cross-distro standard place to put it. So it requires special support in each distro package.
18:49:26 <tomoj> dcoutts_: I see, thanks. wonder where mine is...
18:49:26 <scotty> The diagram does not help.
18:49:39 <twink> scotty: It's called "tying the knot." Basically it's a recursive data structure that "unfolds as you go"
18:49:58 <kmc> > fix ((0:) . scanl (+) 1)
18:49:58 <dcoutts_> tomoj: if you're using cabal-install from a distro package, and they didn't include it then file a ticket with the distro package maintainer.
18:49:59 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
18:50:07 <scotty> I understand the infinite part.
18:50:15 <dcoutts_> tomoj: in the mean time yo can just copy the file somewhere
18:50:17 <scotty> I just don't see how to even make the base case.
18:50:24 <kmc> scotty, ask yourself "what is the first element?"
18:50:41 <scotty> Won't zip fib (tail fib) go on forever?
18:50:42 <kmc> it's 1 clearly
18:50:47 <kmc> scotty, yes.  fib also goes on forever
18:50:51 <kmc> but it only goes as far as you ask
18:50:59 <kmc> so the first element is 1 -- the definition says as much
18:51:01 <kmc> same for the second
18:51:02 <EvanR> why is programming haskell often reduced to zen mysticism ;)
18:51:17 <kmc> the third element of fib is the first element of [ a+b | (a,b) <- zip fib (tail fib) ]
18:51:20 <hpc> haskell is zen mysticism, performed on a superabacus
18:51:26 <kmc> with me so far?
18:51:27 <BMeph> scotty: Welcome to Haskell, where the turtles really DO "go all the way down"... ;)
18:51:54 <EvanR> > let turtles = "turtle ":turtles in turtles
18:51:55 <lambdabot>   ["turtle ","turtle ","turtle ","turtle ","turtle ","turtle ","turtle ","tur...
18:51:59 <EvanR> shucks
18:52:01 <kmc> > fix error
18:52:02 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
18:52:09 <hpc> haha
18:52:18 <kmc> > fix show
18:52:19 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
18:52:20 <hpc> imagine seeing that in your error log
18:52:45 <hpc> :t fix
18:52:46 <lambdabot> forall a. (a -> a) -> a
18:53:03 <scotty> Okay, this is going to sound dumb...
18:53:04 <scotty> If [ a+b | (a,b) <- zip fib (tail fib) ]
18:53:09 <EvanR> > let turtles = "turtle" : [turtles] in turtles
18:53:09 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
18:53:10 <lambdabot>         against inferred type...
18:53:14 <scotty> has a recursive call in it, how can you ever compute the a+b part?
18:53:22 <kmc> scotty, because "zip" starts to produce elements immediately
18:53:24 <azazell> :info fix
18:53:30 <kmc> scotty, are you familiar with iterators or generators from another language?
18:53:37 <Niccus> >let turtles = "turtle " ++ turtles in turtles
18:53:43 <Niccus> > let turtles = "turtle " ++ turtles in turtles
18:53:45 <lambdabot>   "turtle turtle turtle turtle turtle turtle turtle turtle turtle turtle turt...
18:53:46 <hpc> i think scotty needs a primer on lazy evaluation
18:53:49 <jmcarthur> > let turtles = "turtle" : turtles in turtles
18:53:50 <lambdabot>   ["turtle","turtle","turtle","turtle","turtle","turtle","turtle","turtle","t...
18:53:51 <EvanR> yeah thats just repeating, now make it infinitely nested
18:53:53 <kmc> scotty, so the third element of fibs is the first element of [ a+b | (a,b) <- zip fib (tail fib) ]
18:54:01 <Niccus> wouldn't there be a typing problem
18:54:03 <alp_> scotty, little by little zip will produce (a,b)'s and they'll immediately be used to compute a+n
18:54:05 <alp_> a+b*
18:54:05 <jmcarthur> there would be
18:54:06 <scotty> I know of an iterator.
18:54:08 <EvanR> shucks
18:54:14 <jmcarthur> to infinitely nest you need a newtype wrapper
18:54:20 <scotty> Well, something that visits each element of a list.
18:54:21 <kmc> scotty, so Haskell lists are like iterators.  they only give you stuff as you ask for it
18:54:24 <alp_> as they get produced
18:54:28 <kmc> scotty, to find out what that is, we need to get the first element of (zip fib (tail fib))
18:54:32 <kmc> @src zip
18:54:32 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
18:54:32 <lambdabot> zip _      _      = []
18:55:00 <kmc> from the definition of zip, we can see that we know the first element of (zip fib (tail fib)) once we know the first element of fib and of (tail fib)
18:55:01 <jmcarthur> actually, just use a rose tree
18:55:05 <scotty> I understand zip already.
18:55:10 <hpc> @src fix
18:55:10 <lambdabot> fix f = let x = f x in x
18:55:11 <kmc> and the first element of (tail fib) is just the second element of fib
18:55:25 <hpc> > fix id
18:55:29 <lambdabot>   mueval-core: Time limit exceeded
18:55:31 <kmc> so we have (zip (1 : 1 : ... unknown ...) (1 : ... unknown ...))
18:55:53 <kmc> and we can use the defn. of zip to reduce that to:   (1,1) : zip (1 : ... unknown  ...) (... unknown ...)
18:56:02 <kmc> and so we know the first element of (zip fibs (tail fibs)) is (1,1)
18:56:06 <kmc> with me so far?
18:56:51 <kmc> then we compute (1+1) to get 2, and now we know the third element of fibs.
18:57:15 <kmc> then when we ask for the fourth element, we have more information already computed, and we can see that zip will produce (1,2) and we get 3
18:57:16 <kmc> etc.
18:57:37 <scotty> Yes, this is helping.
18:57:52 <kmc> elements of lists (and most other data structures) are only generated as you ask for them
18:57:53 <jbapple> this is called "productivity" in languages that require programs to terminate (like Coq or Charity or Agda)
18:58:00 <scotty> I think I might need to type out a few iterations.
18:58:04 <kmc> we "ask for" an integer, ultimately, by trying to perform arithmetic on it
18:58:26 <kmc> so strictly speaking (no pun intended) even the "zip" doesn't produce any values until the list comprehension asks for (a+b)
18:58:31 <scotty> Writing "unknown" is helpful to visualize something that's not been computed yet.
18:58:34 <kmc> yes
18:58:41 <kmc> you can also just write in the expression
18:58:50 <EvanR> only because + is built in, not because addition is mystic like that
18:58:59 <scotty> So, can I change the definition to start with 1 : 1 : 2?
18:59:05 <kmc> scotty, yes
18:59:14 <kmc> well, let's see
18:59:21 <kmc> > let fibs = 1 : 1 : 2 : zipWith (+) fibs (tail fibs) in fibs
18:59:22 <lambdabot>   [1,1,2,2,3,4,5,7,9,12,16,21,28,37,49,65,86,114,151,200,265,351,465,616,816,...
18:59:31 <kmc> turns out no
18:59:37 <kmc> > let fibs = 1 : 1 : 2 : zipWith (+) (tail fibs) (drop 2 fibs) in fibs
18:59:37 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
19:00:05 <kmc> EvanR, that gets pretty subtle
19:00:07 <felzix> are there any tutorials for doing simple sprites in opengl with haskell?
19:00:19 <kmc> i think the simple answer is "because + pattern matches on its arguments"
19:00:26 <wavewave> does anyone know how to use dot plugin in gitit wiki?
19:00:53 <kmc> (+) = \a b -> case a of { 0 -> case b of { 0 -> 1; 1 -> 2; ... }; 1 -> case b of { 1 -> 2; 2 -> 3; ... }; ... }
19:00:53 <scotty> :t zipWith (+)
19:00:54 <lambdabot> forall a. (Num a) => [a] -> [a] -> [a]
19:00:55 <EvanR> if we defined + instead of using ghc, then we could have lazy arithmetic
19:01:17 <scotty> :t 3
19:01:17 <lambdabot> forall t. (Num t) => t
19:01:23 <scotty> Whoa
19:01:24 <mail> whats the best haskell reference?
19:01:25 <scotty> Hehe
19:01:28 <kmc> EvanR, yes! you can do lazy arithmetic on peano integers
19:01:34 <kmc> EvanR, and lazy comparison
19:01:45 <kmc> so (genericLength [0..] > 5) returns true
19:01:57 <kmc> mail, reference? http://www.haskell.org/ghc/docs/6.10-latest/html/libraries/
19:02:00 <kmc> and the Haskell Report
19:02:07 <kmc> learning / tutorial? LYAH or RWH
19:02:08 <c_wraith> > genericLength [0..] > (5 :: Natural)
19:02:10 <lambdabot>   Not in scope: type constructor or class `Natural'
19:02:16 <kmc> we lost Natural at some point :/
19:02:22 <c_wraith> that's sad :(
19:02:25 <aavogt> > genericLength [0..] > (5 :: Nat)
19:02:26 <lambdabot>   No instance for (GHC.Num.Num L.Nat)
19:02:26 <lambdabot>    arising from the literal `5' at <int...
19:02:37 <aavogt> @src L.Nat
19:02:37 <lambdabot> Source not found. My mind is going. I can feel it.
19:02:39 <kmc> scotty, yeah numerical literals are overloaded
19:02:39 <hpc> i use ghci's :t, :m, and :b
19:02:43 <aavogt> @src Nat
19:02:43 <lambdabot> Source not found. You speak an infinite deal of nothing
19:02:47 <scotty> zipWith (+) [1..10]
19:02:57 <kmc> Haskell has numeric overloading but no implicit numeric conversions / casts
19:03:00 <kmc> :t zipWith (+) [1..10]
19:03:01 <lambdabot> forall a. (Num a, Enum a) => [a] -> [a]
19:03:15 <c_wraith> aavogt: that Nat is something Cale added for an explanation of lazy arithmetic, but he never did anything with it past that
19:03:15 <kmc> > zipWith (+) [1..10] [100,200...1000]
19:03:16 <lambdabot>   Not in scope: `...'
19:03:19 <kmc> > zipWith (+) [1..10] [100,200..1000]
19:03:20 <lambdabot>   [101,202,303,404,505,606,707,808,909,1010]
19:03:21 <scotty> Whoops
19:03:30 <aavogt> haskell can express implicit numeric conversions / casts however
19:03:32 <scotty> zipWith (+) [1..10] [1..10]
19:03:33 <Cale> What?
19:03:41 <Cale> The Nat is from the numbers package, I think
19:03:53 <c_wraith> wouldn't it have a Num instance if it was?
19:04:04 <kmc> zipWith (+) xs ys   ==   [x + y | (x,y) <- zip xs ys]
19:04:07 <Cale> hmm
19:04:20 <kmc> == map (\(x,y) -> x+y) (zip xs ys)
19:04:25 <kmc> == map (uncurry (+)) (zip xs ys)
19:04:32 <aavogt> Cale: the newest mueval supports -X flags, should I send a patch to enable -XViewPatterns, or is that something you can do now?
19:04:47 <Cale> oh, I see, it really is in L.hs
19:05:10 <aavogt> @src zipWith
19:05:10 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
19:05:10 <lambdabot> zipWith _ _      _      = []
19:05:11 <Cale> What do I have to change?
19:05:21 <aavogt> the run plugin
19:05:22 <Cale> @undefine
19:05:26 <kmc> indeed,  zip = zipWith (,)
19:05:26 <azazell> bg
19:05:33 <kmc> where (,) is \x y -> (x,y)
19:05:36 <scotty> zipWith (+) [1,2] [1,2]
19:05:50 <aavogt> Cale: where it passes args to mueval, add -XViewPatterns too
19:05:57 <Cale> okay
19:06:08 <aavogt> thanks :)
19:06:12 <altmattr> is there a way to get ghci to load a new file without unloading the ones you already have?
19:06:14 <c_wraith> assuming that computer has a new enough version of mueval, of course
19:06:18 <scotty> How are you getting lambdabot to compute things?
19:06:33 <hpc> with >
19:06:41 <altmattr> I have a massive line of :m + in my .ghci file and if I try to load a new module, they are all gone
19:06:43 <scotty> 1 + 2 >
19:06:45 <scotty> > 1 + 2
19:06:46 <lambdabot>   3
19:06:47 <aavogt> @run sum [1..100]
19:06:49 <lambdabot>   5050
19:06:52 <hpc> > putStrLn "This is literate haskell"
19:06:55 <scotty> :D
19:06:55 <lambdabot>   <IO ()>
19:07:04 <hpc> bah
19:07:17 <c_wraith> > (return :: a -> IO a) "hello"
19:07:22 <lambdabot>   mueval-core: Time limit exceeded
19:07:27 <scotty> > zipWith (+) [0,1,2] [1,2,3]
19:07:29 <lambdabot>   [1,3,5]
19:07:55 <c_wraith> ...  time limit exceeded?
19:07:59 <EvanR> > hGetContents "/home/hacker/bankaccount"
19:08:00 <lambdabot>   Not in scope: `hGetContents'
19:08:37 <Cale> @flush
19:08:55 <BMeph> Huh, I never saw that before: uncurry (<>) == (\(x,y) -> (x<>y)). Interesting way to think of it. :)
19:09:03 <scotty> > zipWith (+) [1, 1, 2, 3] [1, 2, 3]
19:09:05 <kmc> @src uncurry
19:09:11 <lambdabot> uncurry f p = f (fst p) (snd p)
19:09:13 <lambdabot>   [2,3,5]
19:09:25 <Cale> try view patterns
19:09:45 <kmc> > (\(succ -> 2) -> ()) 1
19:09:48 <BMeph> kmc: As in "replace the comma in a pair with an operator". :)
19:09:51 <lambdabot>   ()
19:10:27 <scotty> > zipWith (+) [1, 1, 2, 3, 5, 8] [1, 2, 3, 5, 8]
19:10:33 <lambdabot>   [2,3,5,8,13]
19:10:45 <kmc> > let fact 0 = 1; fact (pred -> n) = (succ n) * fact n in fact 5
19:10:51 <lambdabot>   120
19:11:01 <kmc> take that, n+k patterns!
19:11:15 <EvanR> o_O
19:11:24 <pikhq> o.O
19:11:34 <BMeph> kmc: So, n+k patterns don't pred - they succ? ;)
19:11:38 <scotty> Okay, I think I get it.
19:11:44 <kmc> ;)
19:12:06 <aavogt> > let length (_ : (length -> (succ -> n))) = n; length [] = 0; length "hello"
19:12:11 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
19:12:43 <aavogt> > let length (_ : (length -> (succ -> n))) = n; length [] = 0 in length "hello"
19:12:44 <lambdabot>   5
19:12:45 <scotty> So, I can read the first "fib" in this expression as, "whatever we have of fib so far?": zip fib (tail fib)
19:13:08 <aavogt> look ma, no RHS!
19:13:11 <twink> > let fibs n = let a = array (0,n) $ (0,0) : (1,1) : [(k, let h = k`div`2 ; u = a!h ; v = a!(h-1) ; w = a!(h+1) in if odd k then u*u+w*w else u*(u+2*v)) | k <- [2..n]] in a in elems $ fibs 10
19:13:12 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55]
19:13:23 <scotty> Hahahaha
19:13:30 <dolio> > let zipWith f ((f -> g) : (zipWith f -> gs)) ((g -> y) : (gs -> ys) = y : ys ; zipWith _ _ _ = [] in zipWith (+) [1..10] [1..10]
19:13:31 <lambdabot>   <no location info>: parse error on input `='
19:13:36 <scotty> That looks like an obfuscated code contest entry.
19:13:53 <dolio> > let zipWith f ((f -> g) : (zipWith f -> gs)) ((g -> y) : (gs -> ys)) = y : ys ; zipWith _ _ _ = [] in zipWith (+) [1..10] [1..10]
19:13:54 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
19:14:12 <hpc> obfuscated would be all the variable names being ?, ??, ???, ??'?', ?'?''?, etc
19:14:22 <kmc> scotty, every value in Haskell is only what you have so far, until you ask for more
19:14:28 <kmc> the way you "ask for more" is by pattern matching
19:14:36 <kmc> for example
19:14:37 <thoughtpolice> ls
19:14:38 <kmc> > let x = undefined in ()
19:14:39 <lambdabot>   ()
19:14:43 <thoughtpolice> shit, wrong window :(
19:14:48 <hpc> heh
19:14:50 <kmc> we never ask for anything of x
19:14:52 <kmc> but
19:14:59 <kmc> > case undefined of Nothing -> (); Just _ -> ()
19:15:01 <lambdabot>   *Exception: Prelude.undefined
19:15:10 <kmc> we ask "is the undefined a Nothing or a Just value"
19:15:11 <hpc> >let g = f, f = g in ()
19:15:19 <kmc> and the answer is an exception, since "undefined" is totally undefined
19:15:24 <kmc> similarly
19:15:27 <kmc> > head (1 : undefined)
19:15:28 <hpc> > let g = f, f = g in ()
19:15:28 <lambdabot>   1
19:15:29 <lambdabot>   <no location info>: parse error on input `,'
19:15:36 <kmc> > head undefined
19:15:38 <lambdabot>   *Exception: Prelude.undefined
19:16:11 <twink> scotty: It's an O(lg(n)) Fibonacci
19:17:17 <Cale> Well, O(lg(n)) arithmetic operations, anyway
19:18:05 <scotty> twink: Ah
19:19:05 <scotty> twink: How is that possible?
19:19:23 <scotty> twink: How can you create something of length n in ln(n) time?
19:19:55 <hpc> i think each element is lg(n) where n=number of bits in the element?
19:20:00 <BMeph> > let {g = f; f = g} in ()
19:20:01 <lambdabot>   ()
19:20:11 <hpc> but that's just the complexity of arithmetic
19:21:15 <LegendaryPenguin> arithmetic isnt a childs game
19:21:54 <twink> scotty: Try fibs n ! n
19:22:06 <Niccus> child's games are game theory and are a bit beyond arithmetic
19:22:38 <gwern> twink: I think he means that each new fibs n requires at least one arithmetic operation, and so it's linear
19:22:52 <ddarius> Niccus: Why do you think game theory is beyond arithmetic?
19:23:27 <dolio> You don't need to compute fib 1 through fib (n-1) to compute fib n, though.
19:24:06 <gwern> dolio: no, but don't you need to do somethingAtrithmetic(fib n-1) to get fib n, though?
19:24:18 <Niccus> i always thought it was closer to logic and depending on the game maybe with a few bits of psychology
19:25:10 <Niccus> isn't there a formula to get fib n directly using phi
19:25:19 <gwern> Niccus: mm. solid game theory is all numbers. but I suppose things like backwards chaining induction would be hard to arithmetize
19:25:24 <dolio> gwern: No.
19:26:35 <dolio> The fast algorithms rely on your only needing something like fib (n/2) to compute fib n.
19:27:09 <gwern> ah. I got confused about list versus entry
19:27:26 <kmc> > let phi = (1 + sqrt 5 / 2; fib n = floor ((phi^^n - (1-phi)^^n) / sqrt 5) in map fib [1..]
19:27:27 <lambdabot>   <no location info>: parse error on input `;'
19:27:35 <kmc> > let phi = (1 + sqrt 5) / 2; fib n = floor ((phi^^n - (1-phi)^^n) / sqrt 5) in map fib [1..]
19:27:37 <lambdabot>   [1,1,2,3,5,8,13,21,34,54,89,143,232,377,610,986,1596,2584,4181,6764,10945,1...
19:27:43 <copumpkin> Niccus: there is, but you need high precision real calculations
19:28:06 <copumpkin> so it doesn't buy you much for large numbers, over the 2n recurrences
19:28:20 <copumpkin> http://en.wikipedia.org/wiki/Fibonacci_number#Identity_for_doubling_n
19:28:33 <hpc> plus you incur the complexity of computing phi
19:29:30 <Niccus> go for extra pain and calculate it using continued fractions
19:32:27 <Kaidelong> why does Floating not imply Ord?
19:32:52 <dankna> I think it's probably because complex floats aren't ordered
19:33:07 <Kaidelong> ah
19:39:53 <kmc> Float and Double are also not ordered, but that's a dirty little secret
19:39:58 <kmc> > let x = 0/0 in x == x
19:39:59 <lambdabot>   False
19:40:15 <kmc> > let x = 0/0 in compare x x
19:40:16 <lambdabot>   GT
19:40:16 <dankna> haha
19:40:19 <kmc> > let x = 0/0 in x > x
19:40:19 <dankna> I see
19:40:20 <lambdabot>   False
19:41:16 <kmc> @check \(a :: Float) -> a == a
19:41:16 <lambdabot>   Parse error in pattern at "->" (column 15)
19:41:25 <kmc> @check \a -> a == (a :: Float)
19:41:27 <lambdabot>   "OK, passed 500 tests."
19:42:08 <gwern> guess it didn't hit NaN or one of the edge cases
19:42:27 <kmc> that's disappointing
19:42:34 <dankna> it is
19:42:35 <kmc> i was hoping it would check weird cases
19:42:43 <mail> damn i'm stumped
19:42:44 <kmc> floating point numbers are like sausage
19:42:50 <mail> infinte lists are :(
19:42:53 <dankna> don't watch them being made?
19:42:57 <kmc> dankna, yep
19:42:58 <gwern> kmc: sorry, you might want to try @scheck for more exhaustive testing
19:43:03 <kmc> @scheck \a -> a == (a :: Float)
19:43:04 <lambdabot>   "OK, passed 500 tests."
19:43:30 <gwern> hm. that's not smallcheck otuptu
19:43:49 <kmc> mail, can we help?
19:44:15 <gwern> @help scheck
19:44:15 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:44:18 <mail> http://pastebin.com/hHgkj73x
19:44:28 <gwern> @help
19:44:29 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:44:32 <gwern> @list
19:44:32 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
19:44:48 <mail> that will only work for the first number in the list afaics
19:45:06 <mail> if you do something like take 10 multiples
19:45:29 <kmc> mail, ah, because there's an infinite number of multiples of the first number
19:45:35 <kmc> before you even get to the next one
19:45:41 <mail> something like that
19:45:54 <kmc> yes, that's a problem with the list monad
19:46:03 <kmc> (which is what you're using under a list comprehension)
19:46:08 <kmc> here's an alternative:
19:46:10 <kmc> http://hackage.haskell.org/package/control-monad-omega
19:48:48 <kmc> i think you should write a function to get the multiples of a single number
19:48:57 <kmc> and then map that
19:49:02 <kmc> and then interleave the results
19:51:41 <hpaste>  . (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24863
19:51:41 <kmc> mail, like so: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24863#a24863
19:52:18 <kmc> if you want to remove duplicates, "union" for lists is a very inefficient way
19:56:22 * Axman6 frigging hates physics!
19:56:47 <mail> i think it can be done without external libraries kmc
19:57:00 <kmc> mail, of course, you can implement "diagonal" yourself
19:57:07 <jmcarthur> external libraries are not to be feared
19:57:25 <mail> they are when an automarker is used
19:57:34 <jmcarthur> ew
19:57:36 <kmc> oh dear
19:58:13 <kmc> "You will receive 5 points for every class whose name ends in 'Factory', 'Manager', or 'Configuration'."
19:59:22 <wolgo> kmc: where did you get that?
19:59:28 <kmc> what?
19:59:38 <wolgo> every class whose name ends in 'Factory', 'Manager',
19:59:39 <wolgo> etc
20:00:04 <kmc> i'm not sure
20:04:47 <wolgo> mail: what are you working on?
20:06:07 <kmc> indeed you can implement diagonal in a much simpler way than Omega does
20:06:12 <kmc> not sure if that's for performance or what
20:06:15 <mail> Write a function multiples which finds all the multiples of all the numbers in the given list
20:06:47 <aavogt> what do you mean by external libraries?
20:07:00 <aavogt> anything outside of haskell98, base?
20:07:08 <mail> yep
20:07:49 <aavogt> you can probably do what you want with inits, tails, product
20:08:00 <wolgo> mail: what is the given list?
20:08:10 <wolgo> or is it an infinite list?
20:08:10 <mail> list of integers
20:08:20 <wolgo> from 1-inf?
20:08:27 <deco> what does "expressive" mean for a programming language ?
20:08:29 <mail> it can be of any length
20:08:29 <aavogt> if you care about efficiency regarding duplicates, group first?
20:08:30 <wolgo> or any list
20:08:44 <wolgo> deco: dude, I dont know. I was wondering that too
20:08:52 <deco> heh
20:09:46 <kmc> oh god
20:09:53 <kmc> it's beginning
20:11:01 <mail> [union [x*n] [y*n] | n <- [1..]]
20:11:04 <mail> why is that not allowed
20:11:22 <kmc> > let x = 3; y = 4 in [union [x*n] [y*n] | n <- [1..]]
20:11:23 <lambdabot>   [[3,4],[6,8],[9,12],[12,16],[15,20],[18,24],[21,28],[24,32],[27,36],[30,40]...
20:11:44 <copumpkin> not sure why you'd want union there though
20:12:04 <kmc> mail, did you get my original suggestion?
20:12:16 <kmc> mail, compute a list of multiples for each number, then interleave them into one list
20:12:25 <kmc> that's what diagonal :: [[a]] -> [a] does
20:12:33 <kmc> but it's not like you have to use the one from Control.Monad.Omega
20:12:35 <kmc> you can write it yourself
20:12:51 <kmc> like concat, every element of one of the input lists will appear in the output list
20:13:06 <copumpkin> you should use dolio's one that he proved correct
20:13:07 <kmc> unlike concat, each will appear at a finite index, even if some of the input lists are infinite
20:13:13 <kmc> copumpkin, link?
20:13:36 <copumpkin> it's in agda but that's fairly easy to translate to haskell
20:13:47 <copumpkin> http://code.haskell.org/~dolio/agda-share/html/ZigZag.html
20:14:04 <kmc> actually, just submit your set in Agda
20:14:07 <kmc> your prof will be hella impressed
20:14:16 <copumpkin> lol
20:15:14 <copumpkin> actually that agda may not be so trivial to translate to haskell unless you actually know agda
20:15:36 <kmc> we really need agda to be more popular for haskell to be more popular
20:15:43 <copumpkin> :o
20:15:49 <kmc> because "the pragmatic alternative to Agda" is good framing
20:15:55 <copumpkin> lol
20:16:23 <dolio> If all you need is a zig-zag, it shouldn't be that hard to translate to Haskell.
20:16:23 <lament> agda motto: avoid avoid success at all costs at all costs!
20:17:21 <kmc> fix (\x -> avoid x at all costs)
20:17:59 <wavewave> wow.. agda code is very beautiful.
20:18:11 <tensorpudding> > fix succ
20:18:12 <lambdabot>   *Exception: Prelude.Enum.().succ: bad argument
20:18:23 <copumpkin> those two big mutual blocks are exceptionally legible ;)
20:18:31 <copumpkin> three, even
20:18:36 <tensorpudding> > fix (succ :: Intger -> Integer)
20:18:37 <lambdabot>   Not in scope: type constructor or class `Intger'
20:18:41 <tensorpudding> > fix (succ :: Integer -> Integer)
20:18:45 <lambdabot>   mueval-core: Time limit exceeded
20:18:55 <copumpkin> > fix succ :: Natural
20:18:56 <lambdabot>   Not in scope: type constructor or class `Natural'
20:18:58 <lament> wavewave: reminds me of http://www.mrtc.mdh.se/~icc/principia.gif
20:19:14 <tensorpudding> It's too bad that lambdabot isn't infinitely fast, isn't it.
20:20:59 <hpaste>  diagonal (in a weird order) (kmc)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24864
20:21:02 <wavewave> by the way, haskell is already violating its motto these days ;-)
20:21:10 <copumpkin> whoa, we have an hpaste bot now?
20:21:19 <Axman6> s/now/again
20:21:34 <copumpkin> how did that happen if mmorrow is missing?
20:23:52 <kmc> hmm, this doesn't work on an infinite list of lists
20:24:55 <aavogt> copumpkin: it looks at hpaste's rss feed
20:24:56 <kmc> no different from concat . transpose really
20:25:15 <kmc> mail, perhaps concat and transpose are all you need
20:27:08 <Axman6> > let f1 x = 12/(x^14) - 12/(x^8); f2 x = 1/(x^12)-2/(x^6) in f1 0.0283 == f2 0.0283
20:27:09 <lambdabot>   False
20:28:15 <wolgo> http://lisperati.com/landoflisp/panel57.html
20:28:45 <Axman6> > let f1 x = 12/(x^14) - 12/(x^8); f2 x = 1/(x^12)-2/(x^6) in (f1 0.0283, f2 0.0283)
20:28:46 <lambdabot>   (5.677683097041246e22,3.789333011044515e18)
20:29:13 <mail> looks like i can't use sort on infinte lists
20:29:55 <aavogt> it could be slightly productive
20:30:08 <aavogt> > sort (repeat minBound) :: [()]
20:30:13 <lambdabot>   mueval: ExitFailure 1
20:30:32 <aavogt> but that doesn't seem to be the case
20:31:20 <aavogt> @check \x -> x == reverse x
20:31:22 <Axman6> mail: well no, to be able to get the first element, you must find the minimum value, which you can't know without testing all elements in the list at least once
20:31:23 <lambdabot>   "OK, passed 500 tests."
20:31:52 <copumpkin> kmc: omega's one does
20:31:58 <aavogt> Axman6: if sort :: (Bounded a,Ord a) => [a] -> [a]...
20:32:01 <copumpkin> kmc: which "this" doesn't work?
20:32:15 <Axman6> aavogt: sure
20:32:17 <aavogt> you could collect all the minbounds
20:32:21 <kmc> the crappy one i wrote
20:32:25 <copumpkin> kmc: oh
20:32:29 <kmc> it's harder than it sounds...
20:32:33 <copumpkin> yeah
20:32:34 <Axman6> then all the succ minBounds
20:32:53 <copumpkin> kmc: might be easier to start with streams
20:33:00 <copumpkin> kmc: since then you don't have to worry about finite ones
20:33:08 <kmc> yeah
20:33:21 <aavogt> well you only get the succ minBound elements once you're sure there are no more minBoundS left in your infinite list...
20:34:40 <mail> what does the . operator do again ?
20:34:46 <copumpkin> compose functions
20:34:50 <kmc> @src (.)
20:34:51 <lambdabot> (f . g) x = f (g x)
20:35:10 <dancor> has anyone ever done anything cool with forced-infinite data structures other than streams?  i guess the next simplest one is infinite-depth binary tree?
20:35:38 <copumpkin> you could have an infinite game tree
20:35:45 <dancor> game of life
20:35:51 <copumpkin> I mean any game relaly
20:35:57 <copumpkin> your AI would walk the tree using strategies
20:35:58 <aavogt> depending on the game
20:36:09 <copumpkin> yeah, many games won't actually have infinite trees
20:36:11 <copumpkin> but you don't really care
20:36:20 <aavogt> it might only be infinite in the sense that you can't practically evaluate it all
20:37:24 <dancor> i wonder how many packages depend on Stream anyway
20:37:33 <copumpkin> oh you're talking about stream fusion?
20:37:34 <dancor> maybe no one has done anything cool even with streams ;)
20:37:38 <dancor> no
20:37:48 <dancor> Data.Stream
20:37:54 <copumpkin> never even heard of it :)
20:38:31 <copumpkin> makes sense that it exists though
20:38:35 <gwern> dancor: not all games of life trees are infinite. an empty board, for example
20:39:08 <gwern> to construct an infinite game tree you need arrangements that continously grow, like glider guns
20:39:40 <dancor> but couldn't you still consider that infinite, the way (repeat 0) is
20:40:41 <dancor> i guess you could just (++ repeat Pass) to chess etc :)
20:41:07 <dancor> of course allowing passes in chess changes everything so bad example..
20:42:48 <gwern> dancor: I'm not sure I could. how do we tell [0] from repeat 0? because length $ [0] is 1 and length $ repeat 0 is _|_. how do we tell 0 apart from 0?
20:43:21 <dancor> the game of life doesn't bifurcate so that's actually a stream.
20:44:06 <dancor> you could have a spliting rule tho
20:44:12 <gwern> dancor: only if you look forward in time. if you look backwards in time, there are bifurcations because multiple games can converge on the same state
20:44:12 <aavogt> use vacuum
20:44:13 <jmcarthur> dancor: http://bifunctor.homelinux.net/~roel/cgi-bin/hackage-scripts/revdeps/Stream-0.4.1#direct
20:44:28 <dancor> like 3 neighbors -> reality splits and you die in one universe only
20:44:36 <dancor> gwern: ah
20:44:38 <dancor> costream
20:44:50 <jmcarthur> dancor: i have also used Stream in multiple projects which i did not put on hackage
20:45:06 <dancor> jmcarthur: cool
20:45:21 <dancor> jmcarthur: have you used other finite-not-allowed data structures?
20:45:24 <kmc> :t unzipWith
20:45:25 <lambdabot> Not in scope: `unzipWith'
20:45:35 <kmc> :t \f -> unzip . map f
20:45:36 <lambdabot> forall a b a1. (a1 -> (a, b)) -> [a1] -> ([a], [b])
20:45:45 <jmcarthur> dancor: sure. i use them all the time
20:45:54 <mail> Write a function which prints out its own definition
20:45:55 <mail> wtf
20:46:08 <kmc> mail, http://en.wikipedia.org/wiki/Quine_(computing)
20:46:13 <tensorpudding> Quines!
20:46:15 <mail> fuck you professor
20:46:19 <jmcarthur> dancor: one of my packages that uses an infinite structure http://hackage.haskell.org/package/comonad-random
20:46:26 <kmc> damn son, sounds like you're getting a real CS education ;)
20:46:29 <tensorpudding> Where was that lambdabot quine
20:46:44 <copumpkin> that seems like a tricky assignment for someone who's just beginning with the language
20:46:47 <yf> \query lambdabot fmap
20:46:52 <jmcarthur> dancor: btw, that package is not as useful as it sounds, so don't bother using it ;)
20:47:10 <copumpkin> (\x -> x x) (\x -> x x)
20:47:14 <copumpkin> if you turn off types ;)
20:47:18 <jmcarthur> ha
20:47:30 <tensorpudding> is that omega?
20:47:56 <jmcarthur> that's actually _|_, not a quine :P
20:48:11 <dancor> jmcarthur: ha luckily it already co-blew my mind
20:48:18 <copumpkin> jmcarthur: well, it reduces to itself ;)
20:48:20 <copumpkin> > ap (++) show "ap (++) show "
20:48:22 <lambdabot>   "ap (++) show \"ap (++) show \""
20:48:27 <EvanR> how do i 'update' a struct if its not a record
20:48:36 <copumpkin> EvanR: by reconstructing it
20:48:37 <kmc> the hard way
20:48:40 <Administrator> \query
20:48:54 <jmcarthur> dancor: my comonadic random interface is basically an infinite tree of random values
20:48:59 <monochrom> what is a struct if its not a record?
20:49:10 <EvanR> no record syntax
20:49:10 <gwern> an ADT?
20:49:33 <jmcarthur> EvanR: if you mean an ADT, you pattern match it and reconstruct it
20:49:35 <copumpkin> you could use something like fclabels
20:49:39 <copumpkin> or data-accessor
20:50:00 <EvanR> i dont want to update an ADT, but i do want to update a AFT value ;)
20:50:04 <monochrom> update Nothing = Nothing; update (Just x) = Just (x+1)
20:50:04 <EvanR> ADT
20:50:29 <Guest65217> lambdabot: lookup
20:50:36 <jmcarthur> update = fmap (+1)
20:50:38 <kmc> Guest65217, like so
20:50:40 <kmc> :t lookup
20:50:41 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
20:50:43 <kmc> @src lookup
20:50:43 <lambdabot> lookup _key []          =  Nothing
20:50:43 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
20:50:43 <lambdabot>                         | otherwise = lookup key xys
20:50:58 <kmc> Guest65217, type "/msg lambdabot @help" for a private window
20:51:52 <EvanR> ok i rearranged my constructors so as to avoid an update
20:53:54 <Guest65217> @src fmap
20:53:54 <lambdabot> Source not found. Wrong!  You cheating scum!
20:54:06 <copumpkin> lol
20:54:55 <Guest65217> :t fmap
20:54:56 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:55:18 <kmc> copumpkin, starting with streams was a really good idea, thanks
20:55:27 <copumpkin> no problem :)
20:55:34 <copumpkin> you got it working?
20:55:41 <kmc> think so
20:55:49 <copumpkin> cool
20:56:57 <EvanR> is f' conventional to mean strict
20:57:02 <kmc> EvanR, sometimes
20:57:09 <kmc> as in foldl'
20:57:16 <kmc> sometimes it means a variation of another sort
20:57:21 <EvanR> the good think about conventions is you can choose when to adhere to them
20:57:26 <kmc> yeah
20:57:37 <kmc> the great thing about standards is that there are so many to choose from
20:57:43 <monochrom> You can also choose from an array of conventions
20:57:45 <kmc> ! often means strict in an operator
20:57:47 <kmc> as in $!
20:57:51 <kmc> @src ($!)
20:57:52 <lambdabot> f $! x = x `seq` f x
20:58:20 <lars9> hey, how to Import Text.Regex? I have only Text.Regex.Base, Text.Regex.PRCRE, etc
20:58:37 <monochrom> for each meaningful identifier, you can choose from a variety of meanings
21:00:07 <aavogt> > "extremely strict" !! 1
21:00:08 <lambdabot>   'x'
21:00:14 <kmc> haha
21:00:38 <monochrom> > ("extremely strict"!!)
21:00:39 <lambdabot>   *Exception: Prelude.(!!): negative index
21:00:48 <monochrom> boo
21:00:49 <mail> fuck it i'm gonna cheat and not use infinte lists
21:00:54 <mail> and cap it at 1000
21:01:00 <mail> fuck you professor
21:01:59 <lars9> the code with "Import Text.Regex" does not compile here
21:02:31 <kmc> haha
21:02:36 <azazell> parsec question: I want to parse JSON list [json,json,...], which in some cases could be empty... how to handle this& emptyList <|> fullList somehow doesn't work, it tries to parse the whole emptyList pattern and mistakes...
21:02:37 <kmc> 'cause the auto-marker won't know the difference
21:02:41 <kmc> that's great
21:02:55 <aavogt> > ("extremely strict"!!).abs
21:02:56 <lambdabot>   {-3->'r';-2->'t';-1->'x';0->'e';1->'x';2->'t';3->'r'}
21:03:05 <kmc> i enjoy this cycle of the prof trying to defeat the purpose of teaching and the student trying to defeat the purpose of learning
21:03:17 <monochrom> aavogt has extremely strict abs!!
21:04:42 <monochrom> azazell: what is an example string in the empty case? what is an example string in the non-empty case?
21:05:18 <copumpkin> mail: what were you supposed to use infinite lists for?
21:05:29 <monochrom> to fuck the professor?
21:05:38 <copumpkin> oh nice
21:05:42 <copumpkin> that's a good way to get good grades
21:05:49 <mail> this
21:05:50 <mail> http://localhostr.com/files/7bbe8b/capture.png
21:06:22 <copumpkin> that can be tricky indeed
21:06:34 <copumpkin> if the input list can be infinite
21:06:40 <monochrom> I dunno, this chap has said that twice in less than half an hour, therefore it must be the in exam practice question.
21:06:54 <azazell> monochrom: "[ ]" or "[]" in empty case
21:06:55 <copumpkin> well, if the input list can be infinite I don't think there's an answer actually
21:07:05 <aavogt> > [ ]
21:07:06 <lambdabot>   []
21:07:17 <aavogt> case [ ] of [ ] -> [ ]
21:07:21 <aavogt> > case [ ] of [ ] -> [ ]
21:07:22 <lambdabot>   []
21:07:25 <azazell> and smth like "[1,2,4]" in none-empty
21:07:37 <mail> i think the input list won't be infinite
21:07:46 <Draconx|Laptop> copumpkin, as long as duplicates are permitted in the output, it's doable.
21:07:52 <kmc> mail, so i mentioned this before
21:08:00 <kmc> mail, but you can use "map" to make a list of lists of multiples
21:08:01 <copumpkin> Draconx|Laptop: presumably it's supposed to be output in order
21:08:02 <Draconx|Laptop> (and order is irrelevant)
21:08:04 <kmc> one list for each input number
21:08:11 <kmc> mail, and then you can use (concat . transpose)
21:08:15 <copumpkin> ah yeah, if it's not in order
21:08:17 <copumpkin> it's pretty easy
21:08:36 <kmc> but getting order like that is harder
21:08:47 <copumpkin> writing a merge function and folding it over a finite list isn't too bad
21:08:57 <mail> it has to be in order
21:08:58 <Draconx|Laptop> yeah, I meant order, not duplicates.  You can obviously prevent duplicates.
21:09:01 <mail> and no duplicates
21:09:30 <copumpkin> if you have a guarantee that the input list is ordered (but possibly finite) then you can do it
21:09:33 <copumpkin> but it's still tricky
21:09:36 <mail> kmc concat.transpose what?
21:09:39 <copumpkin> possibly infinite, I mean
21:09:44 <kmc> mail, the list of lists of multiples
21:10:05 <kmc> > concat . transpose $ [ [x*y | y <- [1..]] | x <- [2,3,5] ]
21:10:08 <lambdabot>   [2,3,5,4,6,10,6,9,15,8,12,20,10,15,25,12,18,30,14,21,35,16,24,40,18,27,45,2...
21:10:21 * hackagebot CCA 0.1.3 - preprocessor and library for Causal Commutative Arrows (CCA)  http://hackage.haskell.org/package/CCA-0.1.3 (PaulLiu)
21:10:26 <copumpkin> oh my
21:10:47 <aavogt> if the input isn't ordered, is the best you can do is output one of:   inits [2..]
21:10:56 <copumpkin> I wonder if CCAs form a CCC
21:11:11 <copumpkin> I wonder what that would even mean
21:11:27 <mail> i still would need to sort that kmc
21:11:40 <kmc> it's true
21:11:45 <kmc> not sure how to deal with that
21:11:52 <pickles> man, there seem to be quite a number of food related monikers: copumpkin, functorsalad, tensorpudding
21:11:53 <copumpkin> you'd want a merge function
21:12:01 <mail> and since i don't know how many multiples are "taken"
21:12:03 <copumpkin> @hackage data-ordlist
21:12:03 <lambdabot> http://hackage.haskell.org/package/data-ordlist
21:12:10 <kmc> mail, you could do it the other way... filter [1..] against being a multiple of something in the list
21:12:18 <monochrom> Oh haha, aavogt gives me an idea. In order to find multiples in order, don't combine the give numbers; instead, search in [1..] for multiples of the given numbers.
21:12:18 <aavogt> you forgot pickles
21:12:23 <pickles> ROFL
21:12:23 <kmc> haha
21:12:26 <pickles> epic fail
21:12:40 <copumpkin> wow, epic co-fail
21:12:43 <ofDao> ....
21:12:48 <mail> that might be an idea
21:13:17 * aavogt is still puzzled
21:13:23 * copumpkin eats pickles 
21:13:33 * pickles dies
21:13:36 <copumpkin> > unpuzzle aavogt
21:13:37 <lambdabot>   Not in scope: `unpuzzle'Not in scope: `aavogt'
21:14:20 <monochrom> azazell: Do you use something like emptyList = string "[]" <|> string "[ ]"?
21:14:23 <pickles> forgot pickles, how silly i am
21:15:03 <aavogt> twink could be edible too
21:15:18 <pickles> also true
21:15:57 <twink> Well, the culinary metaphor was the basis for the term.
21:16:00 <copumpkin> I didn't realize copumpkins were edible
21:16:03 <Peaker> just yesterday there was a discussion where people said they thought Haskell was just as easy to debug.. now I have a little purely functional Image library I implemented on top of Vty -- and it's misbehaving -- but I can't Debug.trace (it messes up Vty) and there's no IO debugger to use a breakpoint with... :P
21:16:18 <copumpkin> I don't debug haskell
21:16:34 <Peaker> copumpkin: I usually don't either -- but when I do have to -- it's not fun
21:16:45 <kmc> haskell debugs you?
21:16:54 <pickles> was hakell russian?
21:16:58 <pickles> *haskell
21:17:06 <aavogt> then write your own Debug.trace that writes to a file?
21:17:10 <Draconx|Laptop> Peaker, it's not very hard to create a function just like debug.trace that doesn't mess up your terminal.
21:17:28 <kmc> it will make you feel dirty to write it though
21:17:47 <monochrom> Debug.trace is very simply unsafePerformIO with hPutStr stdout. You can write your own for stderr instead. Or something.
21:17:50 <jmcarthur> you can't just pipe stderr to a file?
21:17:59 <jmcarthur> oh trace uses stdout?
21:18:10 <Peaker> I guess redirecting to a file is my best option atm
21:18:14 <kmc> unsafePerformIO $ openFile "log" WriteMode
21:18:14 <jmcarthur> @src Debug.Trace.trace
21:18:14 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
21:18:16 <aavogt> and doesn't the ghci debugger work with IO?
21:18:18 <kmc> that shit's terrible
21:18:19 <kmc> but it'll work
21:18:25 <Peaker> But still -- debugging with breakpoints is much more tolerable
21:18:29 <aavogt> I distinctly recall it working correctly
21:18:31 <kmc> as long as you remember NOINLINE
21:18:46 <kmc> Peaker, yeah.  GHCi debugger doesn't handle IO correctly?
21:19:05 <azazell> monochrom: nope.... I've Just right now found magic `try` word... :)
21:19:05 <Peaker> I usually don't even try the GHCi debugger, because it often just adds to the confusion :)
21:19:07 <aavogt> though I'm not sure about having vty output + ghci's prompt at the same time
21:19:19 <Peaker> Yeah, not sure how it'll behave with Vty
21:19:34 <kmc> if you reopen stdout / stderr
21:19:36 <Peaker> btw: I wish Vty's image type was more powerful -- so I didn't have to wrap it with my own
21:19:37 <aavogt> if you name enough intermediate values it turns out fine
21:19:43 <kmc> does that change which termnial ghci itself talks to?
21:20:20 <Peaker> kmc: Haven't tried -- how would that work?
21:20:35 <Paolo> Guys I was thinking about a new web service: a world community of programmers that works as code repository. Not to re-invent the wheel each time. You can have a copy of all your most used code online, search in others code, provide feedbacks to code,... what do you think about that?
21:20:45 <kmc> don't know of a portable way Peaker
21:20:59 <kmc> ideally Vty would be written so you can specify the tty
21:21:07 <kmc> maybe you can hack or patch that
21:21:07 <Peaker> Paolo: github? :)
21:21:30 <Peaker> gdb + attach-to-pid is nice
21:21:37 <Peaker> If gdb got GHC support...
21:21:39 <lament> cpan?
21:21:49 <Paolo> i wanna try to do better
21:21:58 <tensorpudding> CPAN only has Perl code.
21:22:02 <monochrom> Oh sorry, the doc says Debug.Trace uses stderr on unix, "debug console" on windows. But stderr is very easily redirected.
21:22:20 <aavogt> kmc: how does inlining matter for tracing?
21:22:31 <tensorpudding> No code repo site claims to have everything
21:22:35 <lars9> hey, what does IO Char, IO String, IO MyClass means?
21:22:42 <monochrom> it is not like vty uses stderr for normal purposes
21:23:02 <tensorpudding> IO is used for IO actions
21:23:05 <kmc> lars9, IO Char is a type representing a "recipe" for performing input and output and producing a Char
21:23:15 <kmc> it's not at all the same as a Char
21:23:22 <kmc> lars9, http://haskell.org/haskellwiki/Introduction_to_IO
21:23:32 <Cale> lars9: Also note, you can't put a class there, only types
21:23:44 <Cale> lars9: But you could say  MyClass t => IO t
21:23:46 <Paolo> My service is different: you have your own most used code online, so that when you need to program, anytime, anywhere, your snippets, functions, ... are always there
21:23:53 <monochrom> azazell: yes, "try" is for situations like try (char '['; char ']') <|> (char '['; something else)
21:24:03 <Paolo> moreover it is debugged by the others
21:24:10 <tensorpudding> IO is probably the most asked-about thing in Haskell, after monads
21:24:18 <Paolo> through a feedback system
21:24:20 <kmc> and it's funny how people expect the two to be related ;)
21:24:42 <tensorpudding> IO is a monad but don't let it get to you
21:24:44 <lament> possibly they heard about the "IO monad"???
21:24:45 <kmc> yeah
21:24:46 <aavogt> they are in practice
21:24:55 <azazell> tensorpudding: which is monad in fact :-P
21:25:02 <kmc> IO is a monad, but the questions "how do I do IO" and "what's a monad" are pretty damn unrelated
21:25:08 <aavogt> I don't see you writing user-interactive programs using just 'interact'
21:25:28 <tensorpudding> @quote formed
21:25:29 <lambdabot> ghc says: Malformed predicate
21:25:30 <kmc> and IO is a poor starting point for understanding other monads
21:25:37 <tensorpudding> Not that one...
21:25:41 <tensorpudding> @quote formed
21:25:41 <lambdabot> ghc says: Malformed context in instance header
21:25:45 <Paolo> I am trying to creare something better. I called it "byteinn". You can take a look and any idea to improve it that you may have, you will see it become true in one day
21:25:45 <kmc> @ghc
21:25:46 <lambdabot> ghc says: Ambiguous constraint
21:25:46 <tensorpudding> meh
21:25:56 <tensorpudding> @quote tensorpuding formed
21:25:56 <lambdabot> No quotes for this person. There are some things that I just don't know.
21:26:04 <tensorpudding> well i give up
21:26:04 <Paolo> I am putting much effort in it
21:26:18 <aavogt> you will have to reform that quote
21:26:18 <monochrom> kmc means "how do I add up natural numbers" does not require "how do I add up ring elements in the abstract"
21:26:42 <kmc> monochrom, rather it doesn't require "what's a ring"
21:26:47 <tensorpudding> Everyone knows that 1+2+3+4+5+... = -1/12
21:26:55 <Paolo> take a look at www.byteinn.com
21:26:58 <kmc> "how do i calculate the tip at a restaurant" vs. "what's a cauchy sequence of rationals"
21:27:28 <kmc> aavogt, a global filehandle has to be NOINLINE for the same reason as a global IORef
21:27:40 <monochrom> And I support what kmc says, following Piaget. Concrete before abstract, special before general.
21:28:52 <aavogt> kmc: hmm? it looks like like you can sprinkle appendFile "xyz" though
21:29:00 <kmc> oh hmm that's an idea
21:29:01 <monochrom> Who really champions doing category theory in kindergarten, universal algebra in K-12, groups rings fields in undergrad, complex numbers at PhD level, and finally 1+1=2 for postdocs?
21:29:33 <kmc> monochrom, mathematicians who don't have kids ;P
21:29:35 <azazell> where can several Applicative Parsec examples?
21:29:40 <tensorpudding> With a curriculum like that, the postdocs will be so addled they won't be able to do anything else
21:29:48 <drhodes> Paolo: is the code public domain?
21:29:48 <lambdabot> drhodes: You have 1 new message. '/msg lambdabot @messages' to read it.
21:29:55 <twink> Russell & Whitehead?
21:29:57 <monochrom> Haha, perhaps that's why mathematicians want to screw over other people's kids.
21:30:33 <lars9> so, what does "IO ()" mean?
21:30:54 <kmc> lars9, it's the type of IO recipes which produce no useful result
21:30:55 <azazell> It the type signature
21:31:02 <kmc> lars9, did you read the "Introduction to IO" article?
21:31:34 <lars9> yeah reading,
21:31:41 <kmc> () is a type
21:31:42 <tensorpudding> Hmm.
21:31:47 <aavogt> () is a value
21:31:51 <kmc> it has only one value, which is also named ()
21:31:52 <kmc> :t ()
21:31:53 <lambdabot> ()
21:32:02 <azazell> lars9: this means that this function doesn't return anything usefull. But IO tells us, that there could be some action
21:32:11 <kmc> that's not really correct
21:32:13 <kmc> the function returns a recipe
21:32:18 <kmc> the recipe *is* useful
21:32:23 <kmc> and applying the function does not execute the action
21:32:28 <kmc> but executing the recipe does
21:32:29 <tensorpudding> So main :: IO (), then what is the return value of a Haskell program in the C sense?
21:32:47 <aavogt> you can have  main :: IO Int
21:32:47 <kmc> :t System.Exit.exitWith
21:32:48 <lambdabot> forall a. GHC.IOBase.ExitCode -> IO a
21:32:49 <blackdog> whatever you pass to exitWith
21:32:56 <tensorpudding> Okay.
21:33:04 <tensorpudding> I thought main needed to be IO ()
21:33:06 <monochrom> azazell: Sometimes I write (do { x<-foo; return (Just x) }) and then one day I saw people writing instead (Just <$> foo) and it's so cool. There is also one replacing (do { x<-foox; y<-fooy; return (G x y) }) by <$> and <*>, I forgot the exact form.
21:33:32 <kmc> lars9, the fundamental thing to understand is that in Haskell, evaluation and execution are two distinct processes
21:33:33 <aavogt>  G <$> foox <*> fooy
21:33:43 <jmcarthur> liftA2 G foox fooy
21:33:48 <kmc> evaluation is what happens when you apply a function to arguments and then ask for the result
21:34:01 <scotty> Is there a flatten function in Standard Prelude?
21:34:06 <kmc> evaluation never has an effect on the outside world (e.g. printing a string), and never depends on anything in the outside world
21:34:08 <kmc> :t concat
21:34:09 <lambdabot> forall a. [[a]] -> [a]
21:34:10 <lars9> too abstract for me now... but i'll keep in mind
21:34:23 <kmc> lars9, what's abstract about it?
21:34:34 <aavogt> @hoogle [[a]] -> [a]
21:34:34 <lambdabot> Prelude concat :: [[a]] -> [a]
21:34:35 <lambdabot> Data.List concat :: [[a]] -> [a]
21:34:35 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
21:34:46 <kmc> instead of doing IO, we describe IO which could be done.  the IO-types are the types of those descriptions
21:34:54 <kmc> the only IO which actually gets done is the action you call "main"
21:35:12 <aavogt> why does it help to have so much indirection?
21:35:23 <copumpkin> just add more indirection
21:35:31 <lars9> in IO C, is 'C' related to what is printed or input?
21:35:36 <kmc> lars9, no
21:35:38 <kmc> it's the "result"
21:35:39 <kmc> i.e.
21:35:40 <kmc> :t getChar
21:35:41 <lambdabot> IO Char
21:35:46 <kmc> getChar is a recipe for how to get a character
21:35:48 <kmc> it's not even a function
21:35:52 <kmc> since it has no arguments
21:35:52 <dancor> :t putChar
21:35:53 <lambdabot> Char -> IO ()
21:35:56 <aavogt> 1 + 1 is a recipe
21:36:05 <kmc> putChar is a function that takes a character, and gives you a recipe, but the recipe doesn't have a useful result
21:36:13 <kmc> because its purpose is to print a character, not to give you some value
21:36:24 <kmc> a lot of people get by thinking that "a -> IO b" represents some kind of "function with side effects" that returns type b.... but that's really quite wrong, and will mislead you down the road
21:36:26 <azazell> lars9: let io = getChar doesn't perform actual input
21:36:40 <lars9> oh, so IO C means it needs to give me a C?
21:36:43 <kmc> yes
21:36:44 <tensorpudding> You can imagine IO a as a repository for values of a, which are obtained by doing IO
21:36:47 <kmc> "give "in the sense that you can do this:
21:36:54 <kmc> do { x <- a; ... use x here ... }
21:36:55 <kmc> if a :: IO C
21:36:57 <kmc> then x :: C
21:37:00 <kmc> within the rest of the "do" block
21:37:14 <tensorpudding> It sits there until you try to extract a value from it using (>>=)
21:37:23 <aavogt> @type (=<<)
21:37:24 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
21:37:27 <kmc> anyway this is all covered in "Introduction to IO"
21:37:31 <jmcarthur> @type (<=<)
21:37:32 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
21:37:40 <lars9> i see
21:37:42 <aavogt> that couldn't be application for "function with side effects"
21:38:41 <tensorpudding> the interface with IO is called a monad, and there are many other examples of monads in Haskell
21:38:51 <kmc> it's composition of morphisms in the category (Kleisli m)
21:39:02 <kmc> function composition is composition of morphisms in the category (->)
21:39:28 <aavogt> nobody makes such a big deal that    if b then x else y   doesn't have the side effects of x when b is False  in other languages
21:40:00 <jmcarthur> the only difference between  f . g . h $ x  and  m <=< n <=< p =<< y  is that f, g, and h are "normal" functions and m, n, and p are "monadic" functions.  (<=<) corresponds to (.), and (=<<) corresponds to ($)
21:40:24 <jmcarthur> and x and y are both normal values
21:40:26 <scotty> How would I take something like [(a, a), (a, a)] and produce [a, a, a, a]?
21:40:29 <kmc> isn't it more like (<*>) corresponds to ($)?
21:40:32 <dancor> aavogt: i had a friend that liked to use some lolsy thing in python like [trueVal, falseVal](test)
21:40:33 <kmc> scotty, that's not a valid type
21:40:37 <kmc> [(a,a), (a,a)]
21:40:51 <kmc> or did you mean those to be values?
21:40:55 <scotty> Yes
21:40:55 <dancor> err [trueVal, falseVal][test].. anyway it _did_ have the sideeffects!
21:40:56 <kmc> why are they all 'a' then?
21:41:02 <jmcarthur> i mean x is normal and y and monadic, sorry
21:41:08 <jmcarthur> *and y is
21:41:09 <scotty> I was trying to say that they're the same type.
21:41:12 <kmc> > concatMap (\(x,y) -> [x,y]) [(1,2), (3,4)]
21:41:13 <lambdabot>   [1,2,3,4]
21:41:14 <kmc> scotty, ^^^^
21:41:34 <scotty> Okay, so there's no built in function?
21:41:52 <scotty> I just wanted to use it for the following:
21:41:52 <kmc> not to my knowledge
21:42:08 <kmc> tuples and lists are very different things, esp. in how they're typed
21:42:19 <kmc> and that can be confusing coming from a language like Python where they're much closer
21:42:30 <scotty> > concatMap (\(x,y) -> [x,y]) (zip [1,2,3] [4,5,6])
21:42:31 <lambdabot>   [1,4,2,5,3,6]
21:42:32 <kmc> but in general the types (a,a) and (a,a,a) are not even related to each other, nor to [a]
21:42:34 <dancor> @hoogle \(x,x)->[x]
21:42:34 <lambdabot> Parse error:
21:42:34 <lambdabot>   --count=20 \(x,x)->[x]
21:42:34 <lambdabot>              ^
21:42:38 <dancor> fine!
21:42:46 <jmcarthur> kmc: if (<*>) is to ($), what is to (.)? it isn't (<=<)
21:42:54 <kmc> hmm
21:43:03 <kmc> you're right that (<=<) definitely should be (.)
21:43:05 <dancor> @hoogle (x,x)->[x]
21:43:05 <lambdabot> Data.Ix range :: Ix a => (a, a) -> [a]
21:43:06 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
21:43:06 <lambdabot> Prelude snd :: (a, b) -> b
21:43:13 <jmcarthur> kmc: ??? :: f (b -> c) -> f (a -> b) -> f (a -> c)
21:43:27 <mail> can i return True from a function?
21:43:38 <dancor> mail: yes..
21:43:44 <kmc> mail, if the return type of the function is Bool...
21:43:47 <tensorpudding> > (const True) 10
21:43:47 <lambdabot>   True
21:43:52 <monochrom> f 0 = True; f 1 = False; f _ = f 0
21:43:54 <lars9> kmc: hey, how to make 'Import Text.Regex' compile?
21:43:55 <dancor> :t (== "lol")
21:43:56 <lambdabot> [Char] -> Bool
21:43:57 <jmcarthur> kmc: if we have something for ???, than (<*>) can be like ($)
21:43:59 <aavogt> preflex: seen lunabot
21:43:59 <preflex>  lunabot was last seen on #haskell 72 days, 21 hours, 21 minutes and 12 seconds ago, saying:  31
21:44:12 <tensorpudding> > id True
21:44:13 <lambdabot>   True
21:44:31 <jmcarthur> :t liftA2 (.)
21:44:32 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Applicative f1) => f1 (a -> b) -> f1 (f a) -> f1 (f b)
21:44:39 <kmc> hehe
21:44:45 <jmcarthur> thanks caleskell
21:44:48 <kmc> :t let (f . g) x = f (g x) in liftA2 (.)
21:44:49 <lambdabot> forall t t1 t2 (f :: * -> *). (Applicative f) => f (t -> t1) -> f (t2 -> t) -> f (t2 -> t1)
21:44:55 <pickles> nite all
21:45:09 <aavogt> @type liftA2 (Prelude..)
21:45:10 <lambdabot> forall b c a (f :: * -> *). (Applicative f) => f (b -> c) -> f (a -> b) -> f (a -> c)
21:45:15 <kmc> aha
21:46:09 <azazell> :t Prelude..
21:46:10 <lambdabot> parse error on input `Prelude..'
21:46:27 <monochrom> need moar parentheses
21:46:34 <azazell> meh
21:46:42 <jmcarthur> qualified operators are strange
21:46:44 <monochrom> :t (Prelude..)
21:46:45 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
21:46:51 <aavogt> :t (Prelude.(.))
21:46:52 <lambdabot> Not in scope: data constructor `Prelude'
21:47:03 <azazell> hehe
21:47:11 <jmcarthur> :t (+1) Prelude.. (*2)
21:47:12 <lambdabot> forall a. (Num a) => a -> a
21:48:20 <aavogt> hmm, I thought the new qualified operator syntax was going to be in H10
21:48:44 <azazell> it would be nice
21:49:27 <aavogt> it doesn't really matter
21:56:58 <mail> oooooh yeah
21:57:00 <mail> thanks guys
21:57:38 <scotty> Can someone do a better version of this?: sentence xs = concat (concatMap (\ (x, y) -> [x, y]) (zip xs (repeat " ")))
21:58:33 <Peaker> monochrom: was away -- thanks, I'll try redirecting it
21:58:40 <kmc> map f (zip x y)  ==> zipWith (curry f) x y
21:58:50 <kmc> and curry (\(x,y) -> ...) is just (\x y -> ...)
21:58:55 <mail> http://pastebin.com/WgAgkRP9
21:58:57 <mail> this are working
21:59:02 <Peaker> I wish Unix wasn't stupid enough to set buffering modes based on the FD type.  I'll have to hSetBuffering stderr NoBuffering I suppose, if I redirect it to a file
21:59:09 <mail> probably a better way to do it
21:59:17 <kmc> mail, if p then True else False
21:59:21 <kmc> is the same as:  p
21:59:39 <mail> ooh yeah
21:59:41 <mail> duh
21:59:44 <hpaste>  . (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24870
21:59:48 <Peaker> mail: are you sure you need the base case?
21:59:51 <kmc> i see this pattern a lot... there's some idea that the only place you can use a Boolean value is in a conditional
21:59:53 <mail> i think i need sleep
21:59:58 <mail> 6 am
22:00:04 <Peaker> mail: length xs /= 0   is better expressed as (not . null) xs
22:00:04 <kmc> mail, also,  (length $ xs /= 0)  <=>  (not $ null xs)
22:00:10 <kmc> the latter is significantly faster
22:00:22 <kmc> (\y -> multiple x y) is just (multiple x)
22:00:42 <Peaker> and the base case is probably redundant
22:00:56 <kmc> without the base case, won't it sit forever without producing an element?
22:01:08 <kmc> > filter (const False) [1..]
22:01:11 <lambdabot>   mueval-core: Time limit exceeded
22:01:19 <BMeph> Remember, kiddies: never ask for an answer that you aren't interested in knowing. :)
22:04:46 <mail> beautiful
22:04:50 <mail> now it's down to one line
22:09:41 * hackagebot atom 1.0.2 - A DSL for embedded hard realtime applications.  http://hackage.haskell.org/package/atom-1.0.2 (TomHawkins)
22:09:52 <tensorpudding> real hardtime applications
22:10:17 <blackdog> atom knows how to sing the blues
22:10:45 <tensorpudding> got the embedded-programming-gets-me blues
22:12:01 <blackdog> ain't got no memory, and the clocktick always comes too soon
22:12:35 <blackdog> oh, how i love using subversion. "Don't check in now, we're trying to get a release out. Just, i dunno, be useful or something"
22:16:52 <kmc> is there a paper on how "derive" figures out instance templates from examples?
22:17:30 <aavogt> besides the stuff linked from it's website?
22:17:34 <kmc> haha blackdog
22:17:46 <kmc> @quote subversion
22:17:46 <lambdabot> LinusTorvalds says: The slogan of Subversion for a while was 'CVS done right', or something like that, and if you start with that kind of slogan, there's nowhere you can go. There is no way to do
22:17:47 <lambdabot> CVS right.
22:18:10 <tensorpudding> Subversion is okay to pull from
22:18:14 <mlh> use hg/git/bzr as your svn client
22:18:32 <kmc> aavogt, ah, there it is, thanks
22:18:45 <kmc> CVS is okay to pull from too
22:18:52 <kmc> cp is okay to pull from
22:18:57 <tensorpudding> CVS is not easy to pull from.
22:18:58 <jmcarthur> @pl sentence xs = concat (concatMap (\ (x, y) -> [x, y]) (zip xs (repeat " ")))
22:18:58 <lambdabot> sentence = join . (uncurry ((. return) . (:)) =<<) . flip zip (repeat " ")
22:19:09 <arcatan> CVS isn't okay to pull from, I never can remember the needed flags for the command
22:19:16 <jmcarthur> nori
22:19:18 <jmcarthur> *nor i
22:19:20 <tensorpudding> I've never ever remembered the invocation for CVS.
22:19:36 <tensorpudding> I throughly hated CVS from the moment I laid eyes on it
22:19:36 <blackdog> mlh: I tried git-svn for a bit, but we use a heap of svn externals - it was too much pain.
22:21:26 <blackdog> tensorpudding: it's one of those deeply sarcastic uses of "concurrent"
22:21:27 <killing-joke> i am trying to build ghc from source on CentOS 5.4. i get the predicted "no libtinfo.so.5". i built ncurses from source to see if i could get the so there. not present.
22:22:11 <tensorpudding> CVS = Convulsive, Violent Seizures
22:22:50 * jmcarthur has a coworker that actually likes CVS better than SVN
22:23:29 <blackdog> you're really arguing over the relative tastiness of poison, there.
22:23:49 <Jafet> I use tar.
22:24:00 <jmcarthur> tar toast is tasty
22:24:03 <tensorpudding> tar + netcat is fun
22:24:24 <aavogt> tarcat
22:24:56 <killing-joke> i googled for a half-hour or so, but i don't see any references that might help finish building ghc. can anyone point me in the right direction? thanks.
22:25:16 <kmc> killing-joke, is there some libtinfo package ou can install?
22:25:50 <Jafet> That sounds like a problem with your ncurses library and not with ghc.
22:25:59 <killing-joke> kmc, cent and rpmforge do not offer it separately any more
22:26:14 <killing-joke> jafet, maybe so. it is more modern. :(
22:26:23 <Jafet> Depending on what libtinfo is supposed to be, you could just symlink it to the ncurses library
22:27:15 <Jafet> More modern than 5.7?
22:27:49 <killing-joke> ah, here we go (from Ubu Launchpad)
22:27:51 <killing-joke> The libtinfo.so functionality is built into the libncurses.so shared library. For software that expects the libtinfo.so object, do the following:    sudo ln -s /usr/lib/libncurses.so.5 /usr/lib/libtinfo.so.5    sudo ln -s /usr/lib/libtinfo.so.5 /usr/lib/libtinfo.so
22:28:18 <killing-joke> symlink is the keyword i was missing! :)
22:28:26 <killing-joke> Jafet, thanks.  :)
22:32:03 <scriptdevil> k
22:33:11 <kevinulin> can someone explain how this compile error can come to be: Couldn't match expected type 'a' against inferred type 'BS.ByteString'
22:33:22 <kevinulin> i thought if something was typed for 'a' it could work with anything
22:35:43 --- mode: gibson.freenode.net set +o ChanServ
22:36:13 <kmc> kevinulin, maybe that 'a' is already relating to something else
22:36:31 <kmc> also, polymorphism goes both ways -- if you promise to produce a value of any desired type, you can't fail to do so
22:36:32 <kmc> e.g.
22:36:38 <kmc> :t let x :: a; x = "foo" in x
22:36:39 <lambdabot>     Couldn't match expected type `a' against inferred type `[Char]'
22:36:39 <lambdabot>       `a' is a rigid type variable bound by
22:36:39 <lambdabot>           the type signature for `x' at <interactive>:1:9
22:37:53 <kevinulin> so if i create a function that should work on any type, but inside the function i specifically use one type the compiler will throw that error?
22:38:59 <kevinulin> i dont understand, there must be something I am doing wrong, I have used polymorphic types in 20 different places in this program and this is the first time it has been a problem
22:38:59 <Peaker> kevinulin: yeah
22:39:08 <Peaker> kevinulin: paste?
22:39:09 <tensorpudding> The compiler will throw that error if the way you define the function does not yield as general a type as what is expected in the signature
22:39:25 <kevinulin> the program is too big to paste, ill just do some more digging on my own, just didn't know what to make of that message
22:40:27 <tensorpudding> > (length :: (Integral a) => [b] -> a) [1..10]
22:40:28 <lambdabot>   Couldn't match expected type `a'
22:40:28 <lambdabot>         against inferred type `GHC.Types.I...
22:40:38 <Peaker> kevinulin: polymorphism is good for the consumer of it (for which it is said to be universally quantified: "forall a. ...") and bad for the producer of it (for which it's existentially quantified: "there exists an a that...").  Because the producer must be able to work with any "a", and not a specified one
22:40:44 <tensorpudding> > (length :: [b] -> Int) [1..10]
22:40:45 <lambdabot>   10
22:40:52 <kmc> "so if i create a function that should work on any type, but inside the function i specifically use one type the compiler will throw that error?"
22:40:53 <kmc> yes
22:41:10 <kmc> kevinulin, if you hpaste your code we can take a look
22:41:17 * Jafet throws an error at kmc
22:41:33 <kmc> even just a paste of the full error
22:41:43 <ski> kevinulin : if something is inferred as having type `forall a. [a] -> Maybe a' (e.g.), then you can use/give it with any type where `Foo' is replacing `a' (i.e. `[Foo] -> Maybe Foo' here) ..
22:41:48 <ski> kevinulin : .. however, if something is inferred as having type `[Foo] -> Maybe a', then you can't pretend it has type `forall a. [a] -> Maybe a'
22:41:55 <kevinulin> I appreciate the offer, but I will learn more going through it on my own. I just didn't know where to start.
22:42:20 <ski> (er, "inferred as having type `[Foo] -> Maybe Foo'" that should be in the latter case)
22:42:24 <Jafet> @djinn a -> [b]
22:42:25 <lambdabot> Error: Undefined type []
22:42:48 <ski> kevinulin : (since if that were allowed, you'd be able to use a function of type `[Foo] -> Maybe Foo' as having type `[Bar] -> Maybe Bar' for any other type `Bar' .. which would be unsafe
22:43:12 <FliPPeh_> @pl pointless a b = (,) (id a) (id b)
22:43:12 <lambdabot> pointless = (,)
22:43:34 <FliPPeh_> @pl pointless a a = (,) (somethingComplicated a) (somethingEvenMoreComplicated a)
22:43:34 <lambdabot> pointless = const (liftM2 (,) somethingComplicated somethingEvenMoreComplicated)
22:43:54 <ski> kevinulin : "if i create a function that should work on any type, but inside the function i specifically use one type the compiler will throw that error?" - yes !
22:44:16 <roconnor> FliPPeh_: illegal non-linear pattern detected!
22:44:28 <FliPPeh_> :o
22:44:45 <ski>   x == x = True
22:44:49 <ski>   _ == _ = False
22:44:54 <roconnor> you will be arrested, tried and convicted
22:44:57 <ski> (.. is illegal)
22:45:05 <roconnor> ski:  you too
22:45:13 <ddarius> It just treats it as \a -> \a -> ...
22:45:32 <ski> what .. i didn't do anything ?!  i should showed how to do it !
22:45:38 * ski tries to look innocent
22:45:43 <ddarius> (@pl that is, not Haskell)
22:45:59 <ski> (s/should/just/ ..)
22:46:18 <FliPPeh_> well well
22:46:28 <FliPPeh_> Gotta go, start of a new day and everything
22:47:10 * FliPPeh_ -> out
22:47:17 <ddarius> > let f x x = x in f 'a'
22:47:19 <lambdabot>   Conflicting definitions for `x'
22:47:19 <lambdabot>  In the definition of `f'
22:49:54 <ski> .. interesting error diagnosis
22:50:19 <ski> (it is correct, of course .. i just didn't expect it to phrase it like that)
22:51:00 <ski> > let x = 0; x = 1 in x
22:51:01 <lambdabot>   Conflicting definitions for `x'
22:51:01 <lambdabot>  In the binding group for: x, x
22:51:08 * ski nods
22:54:23 * Axman6 really liked erlang's ability to have f x x only get executed when the first x matched the second. saves a f x y | x == y in haskell land
22:54:47 <dolio> Miranda had it.
22:55:02 <Jafet> Not sure how useful that is
22:55:18 <kmc> it's computational in a hidden way
22:55:26 <kmc> but so are numeric-literal patterns
22:55:33 <copumpkin> yeah
22:55:49 <copumpkin> I guess it could just stick an Eq constraint on the arguments in question
22:55:55 <Jafet> Pattern guards are universal enough
22:55:55 <kmc> i feel like it's also typo-prone
22:56:05 <kmc> like when refactoring to swap args you forget one
22:56:10 <ski> > let (x,y) = (0,1); (y,z) = (2,3) in (x,y,z)
22:56:11 <lambdabot>   Conflicting definitions for `y'
22:56:11 <lambdabot>  In the binding group for: x, y, y, z
22:56:12 <kmc> and you get no error message, but that case just silently fails
22:56:32 <ski> > let (f,x) = (id,0); f x = x*x in f x
22:56:33 <lambdabot>   Conflicting definitions for `f'
22:56:33 <lambdabot>  In the binding group for: f, x, f
22:57:36 * ski thinks it'd possibly be clearer to say something like "In the binding group for: {x, y}, {y, z}" respectively "for: {f, x}, f" in those two cases
22:58:21 <ski> (`let x:xs = ...; x = ... in ..' would then report "In the binding group for: {x, xs}, x")
22:58:59 <ski> Axman6 : yes, it is handy .. but a bit problematic, since Haskell doesn't have semantic equality test (or how one'd phrase it)
22:59:11 <Jafet> "equal?"
22:59:38 <Axman6> what's wrong with it being exactly the same a f x y | x == y?
22:59:47 <ski> there is no language guarantee that `(==)' in `Eq' implements even a partial equivalence relation
23:00:11 <kmc> indeed it does not for Float and Double
23:00:24 <copumpkin> > join (==) (0 / 0)
23:00:26 <lambdabot>   False
23:03:12 <kmc> > let f x ((x ==) -> True) = "equal"; f _ _ = "not equal" in zipWith f [1,2,3] [2,2,2]
23:03:13 <lambdabot>   ["not equal","equal","not equal"]
23:03:21 <kmc> that's pretty ugly ;P
23:03:31 <kmc> but at least you don't name y
23:03:40 <kmc> we have pattern guards; how about some guard patterns?
23:03:41 <ski> however, in Prolog and Mercury .. (=)/2 is "officially" equality
23:03:54 <ski> not sure how Erlang treats equality of functions, though
23:04:19 <ski> kmc : you mean annotating a pattern with a guard ?
23:04:22 <copumpkin> badly, probably
23:04:25 <kmc> i will wager money that you won't like the answer
23:04:26 <quicksilver> compare by name or address I imagine?
23:05:02 <kmc> ski, maybe a variation on view patterns which omits the "True" i had there
23:05:23 <ski> (i know Mercury throws a run-time exception on function equality, rather than erroreously/silently just failing ("returning `false'"))
23:05:38 <kmc> i.e.:   case e of (| p) -> v    ===>    case e of _ | p e -> v
23:06:21 <dolio> You mean case e of x | p x -> v?
23:06:28 <kmc> err yes
23:06:37 <kmc> something like that
23:06:55 <kmc> idea being something like
23:07:06 <kmc> let f x (| (== x)) = ...
23:07:09 <ski> how about `(p | e)' being a pattern equivalent to `((,) () -> (p,const e -> True))' ?
23:07:25 <ski> (er, flip the order of the `p' in the pair ..)
23:07:36 <kmc> uh
23:07:57 <kmc> ok i see
23:08:04 <ski> i.e., it first matches the value with `p', then checks that `e' evaluates to `True' (possibly using bindings from `p')
23:08:55 <dolio> That takes syntax away from people who want or-patterns.
23:09:11 <ski> of course, if `@' was generalized to take a pattern to the left, as well. we could instead expand to `p@(const e -> True)'
23:09:19 <ski> dolio : indeed :) :(
23:09:32 <Jafet> let f (x) \1 = ...
23:09:58 <ski> (ergo, i think guards should not have used `|' to begin with .. however, i think the train has probably left a long time ago, on that matter)
23:10:14 <ski> Jafet : what would that expand to / mean ?
23:10:31 <Jafet> It's a perlism
23:10:41 <dolio> Well, I suppose it could get confusing...
23:11:00 <dolio> f (C1 x y z | C2 x y z) | x == y = z
23:11:01 <kmc> or-patterns being the union of two patterns?
23:11:12 <kmc> seems better to reuse @ for that as ski suggests
23:11:16 <kmc> err
23:11:19 <kmc> that'd be intersection
23:11:45 <ski> kmc : actually, i was suggesting explaining `p | e' more lucidly in terms of the generalized `@' ;)
23:12:30 <dolio> You can't have a pattern on both sides of an @ currently, no?
23:12:38 <ski> (s//merely/)
23:12:47 <ski> right, only an identifier to the left
23:12:51 <dolio> For reasons I'm not really sure of (aside from the fact that it's kind of useless).
23:13:04 <ski> it is not useless in the presence of view patterns
23:13:17 <dolio> Yes, well, useless in H98.
23:13:29 <dolio> Which is what mandates the current behavior.
23:14:05 <dolio> You're not going to get a lot of mileage out of Nothing@(Just x)
23:14:11 <ski> *nod* (to both)
23:14:52 <kmc> dolio, you get a bang pattern ;)
23:15:01 <dolio> Heh.
23:15:02 <ski> hehe
23:15:40 * ski was going to type a better explanation of `let' and `case' patterns for dolio, but forgot about after writing half of it ..
23:15:52 <kmc> let's make everything a pattern
23:15:55 <kmc> and also make patterns first class
23:15:57 <kmc> who's with me?
23:16:07 <ski> what does "make patterns first class" mean ?
23:16:27 <dolio> View patterns, only better. Or something.
23:16:35 <ski> (depending on the details of that, i'm definitely against it, or maybe for it)
23:17:15 <ski> also, not everything *should* be a pattern .. however a weaker "everything could be a pattern", i have much less trouble with
23:17:24 <ski> (the devil being in the details, as always)
23:18:19 <ski> (i.e. give ways to express what you want in several ways, and let the programmer choose the most appropriate one to the task at hand)
23:18:32 <mjrosenb> i have thought of things like that
23:18:34 <kevinulin> kmc, i think instead haskell should implement everything in PL/I
23:18:45 <mjrosenb> where : is both a data constructor
23:18:47 <dolio> I've read a fair number of first-class pattern papers/proposals, and they always strike me as being less pretty than what Haskell currently has.
23:18:55 <dolio> Maybe it's because they're low on sugar.
23:19:11 <mjrosenb> and : is also a function that takes two patterns and joins them together.
23:19:14 <kevinulin> ski i dont like that, there should be one way to do each thing you want to do
23:19:33 <ski> kevinulin : sorites problem
23:19:37 <kmc> first class patterns: a data type representing patterns, with "match p against e" being a primitive construct over two expressions (and binding in the second), and with constructors _ ! ~ @ -> and all them as ordinary functions forming an algebra of pattern combinators or whatever you wanna call it ;)
23:19:39 <mjrosenb> kevinulin: what is this, perl?
23:19:57 <Jafet> mjrosenb, python!
23:20:36 <ski> kevinulin : consider two classes of things you want to do that have different "proper ways" of doing .. now consider a problem being on the border between these two classes .. it is not clear which "proper way" is the correct one
23:21:06 <Jafet> kmc, next you'll want undecidable patterns and you give up and implement them in TH instead
23:21:07 <kevinulin> i dont worry about proper
23:21:17 <ski> kmc : i'm proably against that .. but i'll allow for the possibility that it might be ok
23:21:57 <ski> mjrosenb : in my view, expressions and patterns are two facets of the same thing .. mathematicall expressions/terms ..
23:22:35 <ski> mjrosenb : i should be able to reason declaratively about both patterns and expressions .. and the "same" construction in both patterns and expressions should actually be the same
23:22:49 <mjrosenb> ski: indeed.
23:23:21 <mjrosenb> ski: then you could have something like replicate (a:b:)
23:23:42 <mjrosenb> ski: which would match any list of even length
23:23:52 <ski> mjrosenb : the difference between expressions and patterns being mostly one of view-point .. expressions compute a new value out of values from free variables (i.e. bindings) .. patterns compute values for free variables (i.e. bindings) out of a value to match with (alternatively the matching fails)
23:24:00 <mjrosenb> ski: and bind all of the even elements to a, and odd ones to b :-p
23:24:08 <mjrosenb> ski: it would be GREAT
23:24:25 <ski> also, for efficiency and computability reasons, not all expression forms are allowed in patterns
23:24:45 <mjrosenb> ski: like lambdas?
23:25:02 <ski> (and for modularity reasons, some pattern forms are not allowed as expressions .. `_',`x @ p',`e -> p')
23:25:07 <ski> mjrosenb : e.g., yes
23:25:31 <mjrosenb> although with something like haskell, it should be theoretically possible to match against function applications
23:25:32 <dolio> Agda lets you use _ as an expression.
23:25:37 <dolio> Although it has pretty limited use.
23:25:53 <mornfall> dolio: is there a difference from undefined?
23:25:59 <Peaker> mjrosenb: what would that mean?
23:26:11 <killing-joke> kmc, thanks. ghc installed.
23:26:11 <kmc> agda has absurd patterns and dot-patterns too
23:26:18 <dolio> mornfall: In Agda it means 'infer the value from context.'
23:26:21 <Peaker> mjrosenb: it could match any intermediate evaluation/normalization stage
23:26:25 <mornfall> dolio: Oh. :)
23:26:26 <mjrosenb> Peaker: i was thinking about it as i was passing out, so i am not too sure.
23:26:37 <killing-joke> jafet, symlinking against ncurses was the trick.
23:26:49 <Peaker> mjrosenb: there doesn't seem to be a useful way to do it -- and I am not sure it could be typed at all
23:27:03 <ski> (.. rather, i meant, those pattern forms *are* explicitly allowed for patterns for modularity reasons .. but not really being "pure constructions", they are not allowed in expressions .. (though i think they could possibly be allowed, with some restrictions))
23:27:06 <Peaker> kmc: what are "absurd patterns"?
23:27:40 <ski> mjrosenb : i don't follow/agree with your `replicate (a:b:)' pattern example (unless it was meant as a joke :)
23:27:45 <kmc> Peaker, function cases have to be exhaustive
23:27:58 <kmc> but sometimes you know from one arg that there's no possible value for another arg
23:28:22 <mjrosenb> ski: it was meant as an idea that not all ideas should be drawn to their logical conclusion
23:28:35 <ski> (btw, it is for reasons explicated above that i'm against treating `_' as a synonym for `undefined' or `error "undefined at location ..."' or `assertFalse ...')
23:28:38 <kmc> so you have to assert this fact for checking
23:28:57 <kmc> Peaker, take a look at www.cse.chalmers.se/~ulfn/papers/afp08/tutorial.pdf
23:29:01 <kmc> i find Agda is very approachable
23:29:09 <kmc> as a sort of mutant Haskell with super powers
23:29:23 <kmc> brb
23:29:27 <Peaker> :-)
23:29:33 <Peaker> Does Agda have an IO monad?
23:29:41 <ski> kmc : absurd patterns are great :), i only wish it had absurd expressions to complete the symmetry, too
23:29:43 <Jafet> Agda has too many dependencies!
23:29:56 <Peaker> (sin bins that enable us to solve problems we don't yet fully understand..)
23:29:56 <mornfall> Jafet: Ha-ha. :)
23:31:02 <Jafet> ("Stick yer >>= in the sin bins")
23:31:02 <ski> Peaker : consider
23:31:04 <ski>   at : {A : Set} -> (n : Nat) -> (i : Fin n) -> Vec A n -> A
23:31:25 <Peaker> Set = * right?
23:31:34 <ski>   at Zero ()  -- here, `Fin Zero' is an empty type, so this is an impossible case
23:31:38 <ski> more or less, yes
23:31:55 <falbani> Hi
23:32:33 <Peaker> ski: how does Fin n work?
23:32:46 <ski> matching against `()' "tells Agda" that we're in an impossible case, so we don't need to continue with patterns for the rest of the arguments, nor do give a right-hand-side
23:32:54 <ski>   data Fin : Nat -> Set
23:32:56 <ski>     where
23:33:01 <Peaker> ski: ah, cool
23:33:35 <ski>     FZero :                        Fin (Succ n)
23:33:55 <ski>     FSucc : {n : Nat} -> Fin n -> Fin (Succ n)
23:34:01 <ski> like that
23:34:07 <Axman6> hello falbani
23:34:24 <Peaker> ski: This seems too easy :)
23:34:36 <falbani> playing with a Project Euler problem I needed some function to test the equality of all of its elements... obviously writing it recursively is straightforward, but I wanted to code the less posible, so I searched for one in the standard libraries and found no one... Did I searched right?
23:34:45 <falbani> (searched --> search)
23:34:47 <falbani> hi Axman6
23:34:53 <ski> so if we have a pattern of type `Fin Zero', matching on the absurd pattern tells Agda to realize that there's no applicable constructors at all, so we get away with giving no right-hand-side in this case .. and the function is still deemed total !
23:34:58 <falbani> (non-english speaker here)
23:35:14 <ski> imo, Agda should have an "absurd expression" as well
23:35:18 <Peaker> Ok. I gotta learn Agda...
23:35:21 <ski> using that, we'd write above
23:35:27 <ski>   at Zero () _ = ()
23:35:57 <Saizan> what type would () have?
23:36:01 <ski> we can only use `()' in an expression if we have already matched on an `()' pattern (since that is an imposible case, operationally)
23:36:04 <ski> Saizan : every type
23:36:17 <ski> (just like the `()' pattern already has)
23:36:21 <Saizan> ah, ok, so it's a very special expression
23:36:29 <ski> yes, it is an effectful expression
23:36:39 <ski> like the empty list, in the list monad
23:37:04 <ski> the reason it is ok (i.e. not side-effectful) in this case, is because we have matched on the absurd pattern beforehand
23:37:36 <Peaker> To use "at", how do I typically convert my Nat to a Fin?
23:37:37 <Saizan> i'm not sure i see why it's desiderable though
23:38:16 <Saizan> Peaker: with a decision procedure that checks it's small enough
23:39:11 <ski> Peaker : you can try something like `compareSubtract : (m : Nat) -> (n : Nat) -> (m >= n) + Fin m'
23:39:27 <theorbtwo> This is some hypothetical (), not the () that currently exists in Haskell, then?
23:39:30 <Saizan> in fact you can define "Fin n = exists m. m < n" which is isomorphic to the definition above
23:39:47 <ski> being a function that either tells you a proof that `m' is larger than `n', or "coerces" `n' into type `Fin m'
23:40:33 <dolio> That absurd expression doesn't seem to gel very well with thinking about case expansions of the definitions.
23:40:41 <Saizan> i think you've something backwards in that disjunction :)
23:40:44 <ski> (actually s/Subtract// .. i was thinking on a different operation when i wrote that word)
23:40:52 <kmc> Peaker, yes, Agda uses Haskell as the FFI language for low-level, practical stuff ;)
23:40:53 <dolio> You'd expect an absurd case to be "case e of {}", but that has no right-hand sides either.
23:41:20 <dolio> The absurd pattern is sort of analogous to that.
23:41:43 <dolio> With the absurd expressions it'd be more like "case e of { () -> () }".
23:42:09 <theorbtwo> Seems to me that the absurd pattern is case e of { _ -> fail "absurd pattern matched"
23:42:11 <ski> (except that `()' in Agda is not like `()' in haskell at all)
23:42:33 <ski> theorbtwo : more like `case e of {}' (no branches needed, since there's no constructors in the type)
23:42:43 <hpaste>  datatype question (kevinulin)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24871
23:42:51 <kevinulin> oh look it spams you for me
23:43:02 <ski> (in the Agda case above, there's no applicable constructors .. in the `Void' case in haskell, there's no constructors at all)
23:43:10 <ski> @djinn Void -> a
23:43:11 <lambdabot> f = void
23:43:32 <kevinulin> i think the problem is that i am specifying the type too early, is there a way to change those type definitions so that the final type of the 'a' is determined per call?
23:43:33 <ski>   void x = case x of {}  -- sadly not valid syntax, even with `EmptyDataDecls'
23:44:08 <dolio> Yeah. Someone besides me should hack in empty case expressions.
23:44:11 <theorbtwo> x -> (forall a. a), IIRC.
23:44:32 <Saizan> kevinulin: maybe you need polymorphic components
23:45:05 <ski> dolio : `case e of {}' is useful for types with no constructors at all .. but not for types (with parameters !) which just happen to not have any applicable constructors in the particular case
23:45:20 <theorbtwo> As dolio pointed out, that implies that you can have a non-total case, but the point of the absurd pattern is that you can't have a non-total set of patterns / function.
23:45:35 <theorbtwo> ...and sets of patterns should stay equivelent to case.
23:45:49 <ski> dolio : a similar case in haskell would be `data Foo :: * -> * where FooB :: Bool -> Foo Bool', and then matching on a `Foo Int' .. there's just no applicable patterns
23:47:12 <ski> dolio : the other point being that the type with no (applicable) constructors may be nested inside a list or tuple or whatever .. then one could expect that the code would not be accepted as total if you didn't "hand-lead" the compiler to first match down to the type in question, then use an absurd pattern to claim that *this* sub-value has no applicable constructors
23:47:20 <dolio> In principle, you can elaborate most agda definitions into a splitting tree.
23:47:44 <dolio> Lines with an absurd pattern will elaborate into a tree ending in an empty case.
23:47:57 <ski> (of course, laziness changes this somewhat, since you can easily match `(undefined,42)' of type `(Void,Int)' against `(_,x)' and continue to use `x')
23:48:04 <Saizan> kevinulin: is your reader action supposed to be able to produce any type the caller will pick, or is it supposed to decide a type by itself, internally?
23:48:29 <theorbtwo> Agda is non-Lazy?
23:48:45 <Saizan> it's lazy, but also total, you don't have undefined
23:48:52 <Saizan> unless you turn off some checks
23:49:07 <dolio> Is it lazy? It's kind of hard to tell.
23:49:08 <Saizan> (well, i'm not really sure how lazy the evaluation model is)
23:49:16 <Saizan> yeah
23:49:42 <dolio> In total languages evaluation strategy doesn't matter, so you can't construct any examples that will let you find out.
23:49:42 <glguy> you can check by the behavior of if written as a function used to implement a recursive function, right?
23:49:47 <Saizan> well, codata is arguably lazy
23:49:48 <ski> theorbtwo : *nod* (re absurd patterns)
23:49:50 <glguy> if it was strict then you wouldn't terminate
23:49:56 <dolio> I guess you could try writing something that won't get past the termination checker.
23:50:32 <ski> you can guess at the complexity
23:51:06 <kevinulin> an example of a reader could be System.IO.hGet or Data.ByteString.hGet
23:51:27 <kevinulin> so I'm not sure how to answer your question, but my desire is for the type to be decided per call to the reader function
23:51:33 <ski> one of the reasons i think absurd expressions are good here, is because it would fit nicely with or-expressions
23:51:37 <ski> like
23:52:02 <kevinulin> and i believe it is normally, but because of the way i create NetworkServer it can only have one type per NetworkServer
23:52:04 <ski>   factor :: Either (a,b0) (a,b1) -> (a,Either b0 b1)
23:52:22 <ski>   factor (Left (a,b0) | Right (a,b1)) = (a,Left b0 | Right b1)
23:52:28 <kevinulin> I want a way to change the functions in the NetworkServer to be pointers to the function instead of using the NetworkServer's type
23:52:38 <kevinulin> if that is even possible
23:52:53 <ski> where `Left b0 | Right b1' is a nondeterministic (side-effectful) expression, but the whole stays pure because it is decided by the corresponding pattern
23:53:26 <Saizan> kevinulin: they are already pointers to functions, in a sense, the problem is that they are a single pointer to a single function, so it can't be both System.IO.hGet and Data.ByteString.hGet at the same time
23:53:49 <ski> (i don't however yet have a more compelling argument for specifically absurd expressions .. there could possibly be such, though)
23:54:12 <kevinulin> it doesnt have to be, i just meant that I will leave the get and put up to the user
23:55:05 <Saizan> kevinulin: but you want a single reader to work for multiple types in your code, right?
23:55:12 <hpaste>  non-strict Agda (dolio)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24872
23:55:23 <kmc> hmm... an absurd expression would be like "undefined", except the totality checker proves it's not evaluated?
23:55:24 <dolio> Saizan: It does seem to be moderately non-strict. ^^
23:55:50 <ski> kmc : yes
23:56:22 <ski> (fsvo "like \"undefined\"")
23:57:32 <Saizan> dolio: heh
23:58:01 <kmc> dolio, hmm, i don't know Agda much at all, but i know it has a "codata" keyword... why isn't it necessary for Stream?
23:58:11 <Saizan> dolio: it'd be quite inefficient to unfold eagerly all expressions at type checking
23:58:28 <dolio> kmc: It is necessary if you want the code to pass the termination/productivity checker.
23:58:50 <kmc> and it tells it to look for productivity rather than termination?
23:58:56 <kmc> so this code will not pass?
23:59:01 <dolio> But Agda will try to check the code anyway, and just color the stuff that doesn't pass pink, which is what happens to ones.
23:59:25 <dolio> Rather than failing with an error.
23:59:28 <kmc> mm
23:59:43 <kevinulin> Saizan, no, at least I do not think I do. If I create a reader function and call it each time directly, it will tolerate being used with different sub types. If however I store the reader in the NetworkServer I am force to pick a sub type. Is there a way to keep a reference to the fact that I have created a reader function in my code in the NetworkServer object and nothing more?
23:59:51 <kmc> syntax highlighting according to correctness
23:59:58 <dolio> Unfortunately, you have to be careful. For instance, I defined < in terms of itself accidentally the other day, and then used it in a type before reloading.
