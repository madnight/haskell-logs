00:00:09 <kmc> theorbtwo, yes
00:00:16 <theorbtwo> :t >>=
00:00:17 <lambdabot> parse error on input `>>='
00:00:22 <ski>   forever :: Monad m => m a -> m Void  -- another possible (useful) typing of it
00:00:22 <theorbtwo> :t (>>=)
00:00:23 <kmc> (IO Void) means "the result is unknowable" and (IO ()) means "the result is uninteresting"
00:00:23 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
00:00:35 <kmc> the result from "forever" is unknowable
00:00:57 <Axman6> ok, i'm done with python and C for today
00:01:02 <Axman6> and numerical errors
00:01:11 * ski has used `Void' as "monadic return type" of an action that killed the current thread (in a cooperative thread monad)
00:01:17 <theorbtwo> Ah.  m a to m b.  Void to () is OK.
00:01:25 <ski>   kill :: SystemM Void
00:01:59 <kmc> it'd be good for callCC as well
00:02:05 <theorbtwo> Wow.  Suicide is pretty deeply impure.
00:02:31 <ski> yes, that way you'd not need `RankNTypes', but still get the benefit of the equivalent retyping
00:02:43 <kmc> :t callCC
00:02:44 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
00:02:54 <ski>   callCC :: MonadCont m => ((a -> m Void) -> m a) -> m a
00:02:55 <ski> instead of
00:03:07 <ski>   callCC :: MonadCont m => ((forall b. a -> m b) -> m a) -> m a  -- RankNTypes
00:04:02 <BMeph> Good night, all. :)
00:04:10 <ski> the annoying thing with using `Void' is of course that you have to explicitly use `void :: Void -> a', when you want to use it in an arbitrary context
00:04:23 <ski> instead of just instantiating the type to fit the context
00:04:24 <kmc> let's be pretentious and call that ex_falso_quodlibet
00:04:37 <ski> so, it's both pros and cons to doing this
00:05:05 <olsner> I always thought of () as just a wart resulting from every Monad requiring a type even when there's no useful type to use...
00:05:36 <kmc> it's used in other contexts
00:05:38 <ski> (the other pro might be that you don't mistakenly instantiate "`Void'" (i.e. really `forall a. a'), when you wanted to keep in general)
00:06:00 <ski> olsner : `()' is the unit of the `(,)' binary type operation
00:06:15 <ski> olsner : `Void' is the unit of the `Either' binary type operation
00:06:24 <kmc> it's a natural consequence of having tuples
00:06:27 <kmc> that there's an empty tuples
00:06:34 <Younder> I like objective C (not C++) fr the record
00:06:36 <ski> (both those statements are modulo some bottoms that distinguish them)
00:06:52 <kmc> or if you like, it's a natural consequence of having product types that you have a unit for products, i.e. 1
00:07:04 <theorbtwo> I'm not sure I understand that.  Either of those, really.
00:07:08 <olsner> kmc: I only referred to its use in monads (which corresponds to the circumstances where void in C means "nothing")
00:07:38 <Younder> and vid is still ab bad naming
00:07:44 <Younder> void
00:07:50 <ski> olsner : granted, in many situations, `()' (or `Void') is not exactly very useful .. but they are not harmful, so that's not a valid reason to disallow them (imo) .. and, in some contexts, they really *are* useful
00:08:26 <kmc> a better question is, why *don't* we have the 1-tuple
00:08:34 <ski> olsner : since we get greater symmetry and beauty and simplicity by keeping them, and they're not harmful, i say we should have them
00:08:45 <kmc> ultimately these are just special names for ordinary algebraic types that are in the standard library
00:08:51 <kmc> but why no special name for the 1-element case?
00:08:56 <Younder> if you mean {} why not say it
00:09:06 <kmc> Younder, because no other type is written using set notation?
00:09:19 <kmc> "Empty" is a fine name for "Void" i think
00:09:22 <ski> olsner : this is similar to the question of when you're designing a new datatype : always consider whether you can sensibly add an "empty" case .. even if there doesn't appear to be much direct use of it
00:09:34 <Younder> true so use a empty sequence ()
00:09:57 <ski> Younder : why is `Void' bad naming ? (and don't say "for hysterical raisins")
00:09:59 <kmc> Younder, the empty sequence has one element
00:10:02 <kmc> Void has no elements
00:10:20 <olsner> ski: I don't mean they should be eradicated, of course :)
00:10:27 <Younder> kmc the empty set
00:10:34 <kmc> Younder, ?
00:10:36 <Younder> sequence
00:10:46 <kmc> Younder, there is exactly one 0-length sequence
00:10:56 <kmc> in any reasonable definition of "sequence"
00:11:06 <ski> olsner : i was just phrasing my arguments for keeping them (and also specifically looking for similar things in other situations) ;)
00:11:07 <kmc> so the set of 0-length sequences is not isomorphic to the empty set
00:11:55 <Younder> I am trying to define a language with tuples as it's core and even I can't bring myself to say it..
00:12:48 <temoto> Younder, LISP.
00:12:49 <Younder> SOMETIMES YOU MEAN A EMPTY SET!! {} or Void
00:12:57 * ski thinks that this is possibly one of the situations in which it shows that naming both the value *and* the type `()' was probably not the best choice ..
00:13:08 <kmc> Younder, at this point i have no idea what you're arguing for *or* why you're angry about it
00:13:12 <Younder> temoto, no Formula
00:13:17 <theorbtwo> ski: OTOH, what else do you call it?
00:13:23 <ski> Younder : yes, and sometimes you mean a singleton set, so `{*}' or `()' :)
00:13:36 <kmc> Younder, {}/Void and () are two different types
00:13:38 <ski> theorbtwo : in SML and O'Caml, the type is called `unit'
00:13:40 <kmc> with different uses
00:13:49 <ski> theorbtwo : it could easily be called `Unit', in Haskell
00:14:00 <kmc> data Unit = Unit
00:14:09 <theorbtwo> ski: But that doesn't follow the convention of (Type, Type), or (value, value).
00:14:10 <ski>   data Unit = ()  -- please !
00:14:11 <cybercobra> is there something non-deprecated that defines a day-of-the-week enum?
00:14:17 <olsner> ski: what I think would be prettier than using m () is having some way to say (foo :: m void) and have (foo >>= \x -> bar) not type (pattern matching on 'void', or something like that) - i.e. more like how void in C works
00:14:28 <ski> theorbtwo : yes. those should not be named that way, either =D
00:14:32 <Younder> kmc: and that is a catogorical mistake.. (and what I am angry about)
00:14:39 <kmc> Younder, why?
00:14:58 <ski> Younder : *what* is a categorical mistake ?
00:15:02 <kmc> olsner, sounds like a special case
00:15:03 <Younder> kmc: you fiure it out
00:15:11 <kmc> ok, i'm not going to guess
00:15:50 <ski> olsner : i'm not sure what you're talking about .. are you confusing the `Void' and the `()' types ?
00:16:22 <kmc> no
00:16:26 <kmc> it's not a nonsensical idea
00:16:30 <kmc> it is just more special cases
00:16:46 <theorbtwo> olsner: OTOH, that'd stop you from continuing in any way past an operation returning m Void in a do, even if the defintion of m doesn't require actually executing the m Void and finding the Void it returns.
00:16:47 <kmc> i can't see why that's better than using (), an ordinary algebraic type, in the ordinary way
00:17:04 <ski> (kmc : "that" being ?)
00:17:21 <kmc> ski, having "no-result" IO actions have type (IO Void)
00:17:26 <kmc> for the usual "data Void"
00:17:47 <kmc> it means for example that
00:17:50 <olsner> yeah, it is a special case... it would just add a way to "catch" places that expect an action to return a value although it doesn't
00:17:54 <kmc> putStr "hello" >>= (`seq` putStr "world")
00:17:58 <kmc> is an exception
00:18:04 <kmc> which seems quite odd
00:18:19 <ski> `putStrLn' *should* return `IO ()', while `forever' could plausibly return `m Void', instead of `m a' for every `a'
00:18:23 <kmc> i don't see why you shouldn't be allowed to ask for the result of putStr.  the result is perfectly ordinary and well defined
00:18:27 <kmc> it's just "nothing interesting happened"
00:18:56 <Younder> empty is empty be it a VIOD or a () or a {}.. That's my issue
00:19:02 <kmc> Younder, () is not empty!!
00:19:17 <kmc> it is a *different type* with a *different number of elements*
00:19:28 <kmc> empty is empty be it Void or {} or Bool or Char!
00:19:33 <Younder> kmc, but it SHOULD be
00:19:33 <theorbtwo> ski: Except the branches of an if are required to be of the same type.  Void propagates terribly well.
00:19:35 <ski> Younder : `{}' is an empty set. `{42}' is *not* an empty set .. you're implicitly claiming that it's the same thing !
00:19:47 <Younder> no
00:19:55 <kmc> Younder, no.  the cartesian product over no sets is a singleton set
00:20:04 <ski> Younder : the type `Void' corresponds to the set `{}'
00:20:06 <kmc> there is one 0-tuple
00:20:18 <kmc> this is necessary for example because you want that
00:20:34 <ski> Younder : the type `()' corresponds to the set `{x}', where that `x' is written (a bit confusingly) as `()' in haskell
00:20:38 <cybercobra> whereas you can't even express an element of the void type
00:20:50 <kmc> | X1 x X2 x ... x Xn | = |X1| * |X2| * ... * |Xn|
00:20:59 <Younder> OK I am thouroghly comfused. How is a empty set quivalent to a set of one element?
00:21:04 <kmc> Younder, for fuck's sake
00:21:05 <kmc> it's not
00:21:09 <kmc> we have been saying that *repeatedly*
00:21:09 <ski> Younder : it is not !
00:21:15 <Younder> no shit
00:21:19 <kmc> *you* are the one saying "it SHOULD be"
00:21:41 <kmc> you are claiming on no rational basis that {} and () "should be" the same type
00:22:00 <ski> <Younder> empty is empty be it a VIOD or a () or a {}.. That's my issue
00:22:00 <ski> Younder : you claiming that `()' and `Void' and "empty" all being the same thing, while that's *not* the case
00:22:01 <Younder> an empty sequence is also empty. so () should be equivalent of {}
00:22:10 <kmc> Younder, "an empty sequence is empty"?
00:22:13 <kmc> 0 is an "empty integer"
00:22:17 <kmc> so Int should be the same as {}
00:22:19 <kmc> you are making a category error
00:22:21 <kmc> types versus values
00:22:30 <kmc> an empty list is also empty
00:22:32 <ski> Younder: please don't confuse the *value* `()' with the type `()'
00:22:32 <kmc> an empty binary tree is empty
00:22:34 <olsner> I think my monad thing would need to introduce a new kind for unpopulated types (or a special kind for the magic void type), and saying that you can't inspect a value of that kind
00:22:37 <cybercobra> they're both mzero-es, but they're certainly not equal
00:22:38 <Younder> kmc interesting pointon 0
00:23:06 <kmc> no it's a ridiculous point
00:23:12 <theorbtwo> olsner: Very much like C's void.
00:23:31 <theorbtwo> (Which means "this value has no type", in the context of void *.)
00:23:47 <olsner> (I'm not saing Void should be used instead of (), but that a new kind of magic would be used that isn't a box with an exception or a dummy value, but rather no value at all)
00:23:48 <ski> theorbtwo : not really .. you can "inspect" values of type `void' in C (by ignoring them)
00:23:58 <Younder> kmc :you are right. The 0 element is different for most algebraes.
00:23:58 <theorbtwo> ski: How is ignoring inspection?
00:24:22 <kmc> this is a trainwreck
00:24:24 <kmc> i'll be back later
00:25:37 <ski> theorbtwo : `(void)(printf("%s",s)); ..' ignores the `int' return value of `printf', converting/replacing it with a value of type `void'; then the `;' operator inspects the return value of type `void' of the expression to the left, and continues with executing `...'
00:25:51 <Younder> yes
00:26:08 <cybercobra> Is there something non-deprecated that defines a day-of-the-week enum?
00:26:19 <ski> theorbtwo : this is similar to `putStr s >> ..' if `(>>)' has been defined as `m0 >> m1 = m0 >>= \() -> m1'
00:26:26 <Younder> required under -pedantic setting of gcc
00:26:31 <ski> s/has/had/
00:27:20 <ski> theorbtwo : so, i'm not claiming that ignoring is inspection in general, just that in the case of `void' (or `()' in Haskell), it makes no difference
00:27:41 <ski> (actually it can make a difference in Haskell, since we have laziness so a value of type `()' might diverge)
00:27:48 <theorbtwo> ski: But the ; does *not* inspect the return value of type void.
00:28:11 <Younder> there IS no type viod
00:28:12 <ski> theorbtwo : i'm claiming that `;' ignoring it is the *same* as `;' inspecting it
00:28:14 <theorbtwo> It's not a lazy language; not inspecting a computation does not make it not run.
00:28:17 <Younder> void
00:28:37 <ski> (theorbtwo : i knwo)
00:29:44 <ski> theorbtwo : i think typically, `void' would be represented as an "unboxed zero tuple", i.e. taking up *zero* bits .. so inspecting and ignoring is the same thing
00:30:06 <Younder> ski: well it isn't
00:30:28 <theorbtwo> ski: But the entire point is that you cannot inspect it.  Asking "what is the value at this void pointer" is an error.
00:30:33 <ski> (you could represent it by some arbitrary value taking up bits, as well, but since you're not allowed to distinguish between possibly different representations, that would make no difference either)
00:31:03 <ski> theorbtwo : i'm specifically *not* talking about `void *' (which is another beast entirely)
00:31:13 <Younder> a void is avoid..
00:31:24 <Younder> ;)
00:31:27 <theorbtwo> ski: I specificly *am*, though, which is possibly why we are talking past each-other.
00:31:39 <ski> also, i'm fully aware that you can't make variables of type `void', or arrays with elements of type `void', or `struct's or `union's with members of type `void'
00:31:51 <theorbtwo> The void in void* means "there is a value here, but it is typeless".
00:32:10 <theorbtwo> The void in void foo(int x) means "there is no value here".
00:32:24 <theorbtwo> The first concept is far more interesting then the second one.
00:32:42 <ski> however, i'm claiming those latter restrictions are just "surface-level" restrictions on what programs you can express. imho, the way to think about the type `void' is still that it has exactly one value
00:32:54 <theorbtwo> It is also, I think, what olsner was talking about: "I think my monad thing would need to introduce a new kind for unpopulated types (or a special kind for the magic void type), and saying that you can't inspect a value of that kind"
00:32:58 <ski> theorbtwo : yes, i was talking about that latter case
00:33:44 <ski> theorbtwo : yes, like `cannot_happen exit(int exit_status);', e.g.
00:34:37 <theorbtwo> OK.  Then we're talking about different things.
00:34:41 <ski> (or `longjmp' or maybe `signal' (in the uses where you don't return from the signal handler))
00:35:29 <theorbtwo> The signal case can't really be handled in the type system sanely; you are literally trying to get the type system to solve the halting problem.
00:35:29 <ski> theorbtwo : `void *' is simultaneously like `forall a. Ptr a' and `exists a. Ptr a' (unsafely being able to convert from the latter to the former)
00:36:07 <ski> (in the `signal' case, i was thinking on separating it into one function which never returns and another that possibly does)
00:36:15 <cybercobra> Anyone know of a function returning the combinatorial product of multiple lists? e.g. foo [1,2] ["a","b"] = [[1,"a"],[1,"b"],[2,"a"],["2",b]]  (list of tuples also be acceptable)
00:36:16 <theorbtwo> ski: Ah.
00:36:46 <theorbtwo> Ah, re signal.  Not sure I grok the difference between forall and exists here.
00:36:54 <ski> > liftM (,) [1,2] ["a","b"]
00:36:55 <lambdabot>   Couldn't match expected type `[[GHC.Types.Char]] -> t'
00:36:55 <lambdabot>         against infe...
00:37:13 <ski> > liftM2 (,) [1,2] ["a","b"]  -- er
00:37:14 <lambdabot>   [(1,"a"),(1,"b"),(2,"a"),(2,"b")]
00:37:34 <ski> > liftM2 (\x y -> [x,y]) [1,2] ["a","b"]
00:37:35 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
00:37:35 <lambdabot>    arising from the literal ...
00:37:54 <ski> oh, right, not same type :)
00:38:02 <ski> > liftM2 (\x y -> [x,y]) ["foo","bar"] ["a","b"]
00:38:03 <lambdabot>   [["foo","a"],["foo","b"],["bar","a"],["bar","b"]]
00:38:05 <theorbtwo> I mean, you can convert a void * to any other type of pointer freely in C, yes, but that's a seperate conversation.  You can do that with any type in C, void* just requires slightly less syntax.
00:38:17 <ski> cybercobra : ^ any of those strike your fancy ?
00:38:27 <ski> > sequence [["foo","bar"],["a","b"]]
00:38:28 <lambdabot>   [["foo","a"],["foo","b"],["bar","a"],["bar","b"]]
00:39:25 <ski> theorbtwo : yes, you can't automatically convert from `void *' to `foo_t *', you have to do a (possibly) unsafe case
00:39:39 <ski> theorbtwo : in that sense, `void *' is like `exists a. Ptr a'
00:40:23 <theorbtwo> Ah.  I think I see what you are getting at.
00:40:48 <theorbtwo> exists a. Ptr a is a pointer to some value of unknown type.
00:41:06 <theorbtwo> As opposed to foreach a. Ptr a, which is a pointer to a value that can be of any type.
00:41:06 <ski> however, as `void *' is typically used in most circumstances (afaik), i.e. to simulate either parametric polymorphism (universals) or data types with parts abstracted out (existentials), one could just as well regard `void *' *also* as a synonym for `forall a. Ptr a'
00:41:13 <ski> yes
00:41:38 <theorbtwo> ski: Not only that, but in C (but not C++), the type system will convert it for you, with neither warning nor explicit cast.
00:41:40 <ski> you need the `forall a. Ptr a' to be able to cast to any specific pointer type (such as the one you hope you're actually handling)
00:42:04 <theorbtwo> char *foo; foo = malloc(12); is completely valid code, and malloc returns a void*.
00:42:12 <kingping> Hello people.
00:42:23 <ski> ok, i suppose i'm forgetting things then, since i seemed to recall that C doesn't implicitly cast from `void *' to `foo_t *'
00:42:23 <kingping> Anybody did gfx using HOpenGL ?
00:42:50 <theorbtwo> ski: It implicitly casts *only* on void*, not on a pointer to anything else.
00:42:52 <ski> (oh, you're right .. now i of course see that it must be like that .. out of habit, i suppose :)
00:43:00 <ski> theorbtwo : right
00:43:08 <ski> (that i recalled)
00:43:40 <kingping> My code compiles ok if I support a function with definition normalizeCoords :: (GLfloat, GLfloat, GLfloat) -> (GLfloat, GLfloat, GLfloat), but fails to compile if I use something like normalizeCoords :: (GLfloat a) => (a, a, a) -> (a, a, a) yielding "Type constructor `GLfloat' used as a class"
00:45:08 <ski> (theorbtwo : if we're done now, maybe we'll stop scaring away newbies with arcane discussions of the type structure of C :)
00:45:16 <Axman6> Foo x => x -> y means that x is a type which has implemented the Foo class. GLfloat is not a class
00:45:26 <theorbtwo> ski: Oh.  Sure.
00:45:41 <kingping> Oh
00:45:43 <Axman6> kingping: like it says, GLfloat is a type constructor, not a class
00:46:35 <ski> kingping : you can easily define a type synonym, though
00:46:47 <ski>   type GLfloat3 = (GLfloat, GLfloat, GLfloat)
00:46:54 <ski>   normalizeCoords :: GLfloat3 -> GLfloat3
00:47:21 <kingping> ski: Not sure if that would be good style :\
00:47:27 <ski> (if what you were bothered about was having to retype `GLfloat' so many times ..)
00:47:35 <kingping> Not arguing, I'm just learning Haskell.
00:47:37 <Axman6> sure t would
00:48:01 * ski wouldn't hestitate to do that, if it significantly improved readability and writability
00:48:14 * Axman6 would probably use something like type Gf3 = (GLfloat, GLfloat, GLfloat)
00:48:21 <kingping> :)
00:48:32 <kingping> thanks
00:49:57 <ski> (but i suppose in some cases, a `let' or a `where' in types might be useful, still)
00:50:30 <ski> (alternatively, attaching on type signatures (only))
00:51:57 <kingping> Your braces make me think you come from lisp ;)
00:53:32 <arcatan> ski speaks only in braces
00:54:23 * ski . o O ( "brackets", if i may ! )
00:55:39 <ski> (roconnor : did that O'Cult language enforce that for each two overlapping patterns, there must be a pattern which covers the overlap ?)
00:56:56 <roconnor> ski: I think it was more like that if there are two matching patterns neither is used
00:57:03 <roconnor> or something strange like that
00:58:15 <roconnor> ski: http://adept.linux.kiev.ua/repos/icfpc2006/input/hmonk/hmonk.txt  See Subject: O'Cult Version 1.0 Available
00:58:33 <ski> that sounds strange, yes ..
00:58:37 * ski lookds
00:59:23 <olsner> ah, yes, an unboxed zero-tuple might have the same semantics as the void I'm looking for... would that be spelled #(#) or something? :P
00:59:44 <roconnor> If the rule matches both positions,
00:59:45 <roconnor>          * if one position has strictly more matches, the rule is
00:59:47 <roconnor>            recursively considered for application to *other* position.
00:59:49 <roconnor>            (The rule is least heeded in the position where it is most
00:59:50 <roconnor>            needed.)
00:59:55 <roconnor> * if the rule matches the same number of subterms in both
00:59:56 <roconnor>            positions, the rule is not applied.
01:00:11 <ski> olsner : `(#)' or `(# #)', i would say
01:00:29 <roconnor> @remember O'Cult The rule is least heeded in the position where it is most needed.
01:00:29 <lambdabot> It is forever etched in my memory.
01:00:36 <ski> @kind (# , , #)
01:00:37 <lambdabot> ? -> ? -> ? -> (#)
01:00:48 <ski> @kind (# #)  -- apparently an unboxed uni-tuple
01:00:49 <lambdabot> ? -> (#)
01:01:43 <ski> roconnor : the "the rule is not applied" in the latter case sounds strange, indeed ?
01:01:54 <roconnor> yes, O'Cult is a silly language
01:02:06 <ski> .. would this happen to be dynamically typed ?
01:02:20 <olsner> @where O'Cult
01:02:21 <lambdabot> I know nothing about o'cult.
01:02:27 <ski> (otherwise it would be preferable to just refuse to compile the program in that case, imo)
01:02:32 <roconnor> ski: the rule of applying the least matching rule is also strange
01:02:48 <roconnor> olsner: http://adept.linux.kiev.ua/repos/icfpc2006/input/hmonk/hmonk.txt
01:03:11 <roconnor> ski: I think it is untyped
01:03:35 <roconnor> ski: but at least it has pattern matching :P
01:03:37 <ski> roconnor : i think it's just saying that if the value matches both `(Just a,b)' and `(Just (a:as),False)', then it should use the latter one =
01:03:46 <ski> s/=/?/
01:04:03 <ski> (.. which sounds pretty reasonable, to me)
01:04:43 <roconnor> ski: I think it uses the former one
01:04:48 <ski> (since `(Just a,b)' "has strictly more matches", "the rule is recursively considered for application to *other* position", i.e. `(Just (a:as),False)')
01:05:14 <roconnor> ski: hmm I see how you are interpreting it
01:05:37 <ski> (it is phrased in a cumbersome way, but i think it means to express the sane semantics)
01:06:25 <Beelsebob> heh, it's interesting that people on haskell-cafe want to be able to compare functions, but don't care about the comparison being correct (i.e. they don't mind not bothering to check that the two functions have the same behaviour for bottom)
01:06:58 <roconnor> Beelsebob: I don't care about bottom
01:07:25 <Beelsebob> even when trying to assert that two functions are equal?
01:07:30 <roconnor> yes
01:07:34 <Beelsebob> blimeh
01:08:11 <ski> (and then i suppose "The rule is least heeded in the position where it is most needed." could be interpreted as that since "most" values that matches `(Just a,b)' doesn't match `(Just (a:as),False)', the latter position is the least common case .. but when that is the case it is "the position where it is most needed" .. at least, that's as much sense i can read into that)
01:08:13 <Beelsebob> so f _ = 6 and g x = x `seq` 6 are equal functions to you?
01:08:20 <roconnor> Beelsebob: because
01:08:42 <roconnor> > (undefined :: Int) == undefined
01:08:43 <lambdabot>   *Exception: Prelude.undefined
01:08:49 <roconnor> is neither true nor false
01:08:57 <roconnor> so I don't care how f behaves on undefined
01:09:15 <Beelsebob> that doesn't make sense
01:09:16 <roconnor> I only care that if x == y then f x == f y (and maybe even not that)
01:09:19 <Jafet> instance Eq (a -> b) where (w->x) == (y->z) = tail $ repeat True
01:09:24 <Jafet> Or something
01:09:41 <Beelsebob> roconnor: right, and all bottoms *are* equal â€“ whether haskell can prove it or not
01:09:44 <Jafet> _ == _ probably
01:09:45 <Beelsebob> there is only one bottom in each type
01:09:51 <roconnor> Beelsebob: I only care about what == does
01:10:04 <dolio> You only care if functions are extensionally equal up to some arbitrarily defined (may-not-even-be-equivalence) relation?
01:10:05 <Beelsebob> hmm, interesting point
01:10:13 <roconnor> if x and y are different representations but still enjoy x == y then I only care that f x == f y
01:10:30 <Beelsebob> personally, I would rather my function equality actually was function equality
01:10:35 <Beelsebob> and if it couldn't prove it, it couldn't prove it
01:10:35 <ski>   instance (Compact a,Discrete b) => Discrete (a -> b) where f0 == f1 = forAll $ \a -> f0 a == f1 a
01:10:43 <Jafet> What's function equality?
01:10:53 <roconnor> Beelsebob: why are you more demanding on functions than on data values?
01:11:11 <roconnor> Beelsebob: you don't go around asking == only to return true on identical values
01:11:12 <Beelsebob> roconnor: I'm not â€“ I would rather my data value equality actually was too :/
01:11:21 <roconnor> ah
01:11:24 <Beelsebob> you've pointed out an interesting corner case
01:11:30 <Beelsebob> and now I'm pissed off that I've seen it
01:11:30 <Beelsebob> :(
01:11:38 <roconnor> Beelsebob: so you want (-0.0) and (0.0) to be unequal?
01:11:38 <Jafet> Extensional equivalence?
01:11:44 <Beelsebob> roconnor: no
01:11:47 <roconnor> :)
01:11:55 <Beelsebob> I want _|_ and _|_ to be equal
01:12:12 <ski> undecidable
01:12:16 <Beelsebob> indeed
01:12:17 <roconnor> Beelsebob: that wouldn't be monotonic :)
01:12:23 <Beelsebob> roconnor: hmm?
01:13:01 <Jafet> Just let _|_ == _|_ = _|_
01:13:09 <Jafet> (Wait, that's already the defatul!)
01:13:18 <Jafet> Spelling fail
01:13:18 <arcatan> > _|_ == _|_
01:13:19 <lambdabot>   <no location info>: parse error on input `|'
01:13:26 <roconnor> if _|_ == _|_ = True, and since (_|_ << False) and (_|_ << True), by monotonicity we must have (False == True) = True
01:13:33 <ski> if `f _|_ = y', then `forall x. f x ]= y', where `]=' is "greater than or equal" in the definedness order
01:13:45 <roconnor> @let _|_ = _|_
01:13:46 <lambdabot>   Parse error in expression: WildCard
01:14:00 <ski> @let bot = bot
01:14:02 <lambdabot>  Defined.
01:14:11 <roconnor> where << is the partial order in the Scott sense
01:14:22 <arcatan> i always forget that _|_ isn't real syntax
01:14:24 <dolio> > let _ | True = 5 in 4
01:14:25 <lambdabot>   4
01:15:21 <dolio> I guess I agree with roconnor, but the "bottom isn't a value" argument someone made on haskell-cafe isn't a good one.
01:15:44 <cybercobra> what's my syntax error here?: http://ideone.com/sXS1z
01:16:05 <quicksilver> cybercobra: indentation
01:16:17 <quicksilver> cybercobra: subProducts needs to line up with consToAll
01:16:40 <Athas> Has anyone tried using http://hackage.haskell.org/package/X11-xshape?
01:16:52 <roconnor> Beelsebob: I actually probably would be happy with if x == y then f x == f y when both f x == f x and f y == f y
01:17:13 <Beelsebob> don't you mean f x == g y?
01:17:13 <roconnor> but I'm a liberal
01:17:18 <roconnor> er
01:17:18 <cybercobra> quicksilver: I thought the off-side rule was less picky than that?
01:17:25 <roconnor> ya
01:17:32 <quicksilver> cybercobra: I have no idea what the off-side rule is, but you were wrong.
01:17:38 <roconnor> I'd actually probably would be happy with if x == y then f x == g y when both f x == f x and g y == g y
01:17:41 <Beelsebob> uhhuh
01:17:57 <c_wraith> cybercobra: you have to line things up to make proper blocks.  All definitions that are in parallel need to start on the same column
01:18:19 <cybercobra> quicksilver: http://en.wikipedia.org/wiki/Off-side_rule
01:18:20 <Beelsebob> adding those constraints makes it even less decidable though doesn't it
01:18:32 <Beelsebob> wait no, it doesn't
01:18:33 <quicksilver> cybercobra: subProducts being 'less indented' than consToAll makes it not part of the where, but part of the block enclosing the where, which is a syntax error
01:18:36 <roconnor> though I'm not sure what I have defined is a PER or not ...
01:19:25 <roconnor> maybe I want ... when both f x == f y and g x == g y
01:19:29 <roconnor> I'd have to think about this
01:19:36 <cybercobra> quicksilver: ah, I'll just move the 'where'
01:19:48 <quicksilver> cybercobra: well, the description on that page sums it yup, yes :) "Any non-whitespace token to the left of the first such token on the previous line is taken to be the start of a new declaration"
01:20:16 <cybercobra> quicksilver: right, but I would have figured it started at the "where"
01:20:25 <quicksilver> oh, I see
01:20:43 <quicksilver> yes, that would be a consistent way to read landin, but it's not what haskell does.
01:20:48 <c_wraith> there's a reason a lot of people put the where on the line by itself
01:20:53 <quicksilver> some people always start a new line after the where
01:21:03 <quicksilver> other people just use editors which get it right automatically :)
01:21:11 <cybercobra> I'll just put the where on the previous style ala Python
01:21:55 <c_wraith> But yeah, coding haskell is a real pain if you don't have an editor that understands how to indent
01:22:56 <quicksilver> well, I wouldn't put it that strongly; but if using a dumb editor I'd adopt a simpler style (with more newlines); with a smart editor I don't bother
01:28:22 <cybercobra> type error I can't decipher: http://ideone.com/Utnc2
01:31:40 <c_wraith> ugh.  that placement of the where is terrible
01:33:32 <cybercobra> c_wraith: heh.
01:33:34 <int-e> cybercobra: the right hand side [(item `consToAll` subProducts) | item <- list] has type [[[a]]]
01:33:44 <int-e> cybercobra: and the base case is wrong
01:34:02 <int-e> @type sequence
01:34:03 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
01:34:19 <int-e> > sequence [[1,2],[3],[4,5,6]]
01:34:20 <lambdabot>   [[1,3,4],[1,3,5],[1,3,6],[2,3,4],[2,3,5],[2,3,6]]
01:35:32 <cybercobra> argh! I *tried* to find a library function, but Hoogle showed nothing useful.
01:36:03 <int-e> I can't blame it in this case - you have to make the connection to the list monad to find it.
01:36:10 <roconnor> how does a Galois connection differ from simply a lattice isomorphism?
01:36:57 <roconnor> @hoogle [[a]] -> [[a]]
01:36:57 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
01:36:57 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
01:36:57 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
01:37:49 <cybercobra> int-e: wait, not seeing how that has type [[[a]]]
01:38:05 <int-e> item `consToAll`
01:38:06 <cybercobra> oh, nm
01:38:10 <int-e>   subProducts  has type [[a]]
01:38:13 <cybercobra> needed a flatten step
01:40:25 <cybercobra> > sequence (Data.Set.fromList [1,2]) (Data.Set.fromList [3,4])
01:40:26 <lambdabot>   Not in scope: `Data.Set.fromList'Not in scope: `Data.Set.fromList'
01:43:50 <cybercobra> @type Monad
01:43:51 <lambdabot> Not in scope: data constructor `Monad'
01:43:58 <cybercobra> @kind Monad
01:43:59 <lambdabot> Class `Monad' used as a type
01:44:10 <alpounet> @src Monad
01:44:10 <lambdabot> class  Monad m  where
01:44:10 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
01:44:10 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
01:44:10 <lambdabot>     return      :: a -> m a
01:44:10 <lambdabot>     fail        :: String -> m a
01:44:27 <cybercobra> alpounet: grazi
02:00:51 <int-e> roconnor: instead of f(g(x)) = x, g(f(x)) = x, you have f(g(x)) <= x, x <= g(f(x)) and f . g . f = f; g . f. g = g. An example that is not an isomorphism is f({}) = {}, f({x}) = {b}, f({y}) = {}, f({x,y}) = {a,b}; g({}) = {}, g({a}) = {x,y}, g({b}) = {x}, g({a,b}) = {x,y} (with sets ordered by set inclusion)
02:02:22 <roconnor> int-e: that doesn't sound at all like the fundamental theorem of Galois theory
02:04:47 <inetic> hpaste.org seems to be down so I hope you'll excuse me: http://pastebin.com/jAaDhHwN
02:08:07 <int-e> roconnor: The defining property is that f and g are monotone and f(a) <= b iff a <= g(b). Note that there are also antitone Galois connections which work with antitone functions (order reversing) and satisfy a <= f(b) iff b <= g(a).
02:09:16 <tibbe> I'm giving a high-performance Haskell tutorial at CUFP this year. I'm working on the content now. Is there anything anyone wish they understood better when it comes to Haskell performance (e.g. benchmarking, Core, inlining, unboxing)?
02:09:29 <yitz> roconnor: yes it does (in maclane's formulation at least)
02:10:31 <ivanm> does Ashley Yakeley frequent IRC?
02:10:39 <roconnor> yitz: my definition of the fundamental theorem of Galios theory is about the isomorphism between the subfields of a galois extenstion and the subgroups of the galois group of a galois extenstion
02:10:47 <ski> (int-e : i'd rather say that the proposition (that `f' and `g' form a Galois connection) is not well-defined unless `f' and `g' are both monotonic .. :)
02:11:15 <yitz> roconnor: yes but maclane reduces it to that
02:11:33 <ski> ivanm : istr he did that before, anyway
02:11:36 <roconnor> yitz: what does maclane say the fundamental theorem of Galois theory is/
02:11:42 <kmc> tibbe, some examples of reading Core to find performance problems would be great
02:11:57 <kmc> tibbe, specifically, how can I as an app developer (rather than a GHC hacker) use these techniques
02:12:09 <yitz> roconnor: a pair of almost-inverse mappings between the set of normal subgroups of the Galois group and the set of regular field extensions
02:12:18 <ivanm> ski: because I'm finding it slightly disturbing that someone keeps going on with that line of enquiry after everyone else says it's a stupid idea is responsible for one of the more important packages on hackage rather disturbing :s
02:12:36 <roconnor> yitz: what are regular field extensions?
02:12:42 <kmc> tibbe, the same goes for reading STG / C / LLVM / assembly output, if applicable
02:12:57 * yitz tries to remember the exact definition
02:13:01 <ski> ivanm : sorry, which line of enquiry ?
02:13:15 <ivanm> ski: why isn't (a -> b) on instance of Eq
02:13:34 <ivanm> ski: oh, did you mean int-e for that reply above rather than me? :p
02:13:42 <tibbe> kmc: I will try to cover core in the talk: describe the syntax and how to look for common signs of bad code
02:13:44 <ski> it might be, given that `a' is in `Compact' and `b' is in `Eq', iiuc
02:13:46 <yitz> roconnor: a finite extension that is generated by all the roots of a polynomial
02:13:49 <tibbe> kmc: like lack of unboxing
02:13:51 <yitz> or something like that
02:13:53 <kmc> tibbe, sounds great
02:14:04 <dolio> I don't really understand what people want instances of Eq for a -> b for.
02:14:11 <ski> (but that might collide with more specific cases people maybe want in specific cases ?)
02:14:24 <tibbe> kmc: In addition I'll try to teach how to successively improve performance using criterion
02:14:26 <dolio> I don't think I've ever needed that other than to satisfy an ill-concieved precondition for Num or something.
02:14:30 <inetic> hi guys, could someone please give me some background on this: http://pastebin.com/jAaDhHwN
02:14:34 <tibbe> kmc: anything else?
02:14:35 <yitz> tibbe: how about a specification of the Core language as it is today
02:14:39 <tibbe> kmc: I have 3-4 hours?
02:14:47 <ski> dolio : to check whether an arbiatrary (total) `f :: Stream Bool -> Bool' is constant, of course !
02:15:00 <tibbe> yitz: yes, in fact I plan to write a blog post about it. I have a bunch of notes in a document already
02:15:12 <kmc> tibbe, everything you mentioned sounds useful... Core is the biggest gap there wrt. my own skillset, so it's why i mentioned
02:15:19 * yitz jumps up and down in excitement
02:16:15 <kmc> inetic, there are limits in Haskell 98 on the shape of a typeclass instance
02:16:37 <tibbe> kmc, yitz: what do you think about having a format where I give a few (e.g. 10) rules of thumb for good performance; common patterns that you can use in your Haskell code to get good performance?
02:16:45 <kmc> "instance C (S T)" is not allowed
02:16:53 <kmc> but only "instance C (S a)"
02:16:55 <roconnor> yitz: that sounds like a (finite) normal extension to me.  I don't see why there isn't an exact isomorphism between the normal subgroups of the galois group and the normal field extensions
02:16:57 <tibbe> kmc, yitz: For example, when to have strict vs. lazy spines in data structures
02:16:58 <yitz> dolio: usually it's needed to satisfy an ill-concieved preconception of what a function is.
02:17:10 <kmc> inetic, is it really important to overload the name "draw"
02:17:15 <kmc> why not have drawOne and drawMany?
02:17:19 <kmc> makes the code easier to read, imo
02:17:22 <yitz> roconnor: that's it! a finite normal extension. yes.
02:17:37 <kmc> it will catch more errors too
02:17:43 <roconnor> yitz: but isn't the isomorphism exact?
02:18:11 <inetic> kmc, thank you for your answer (altough I'm not sure I understand it much :-) ), I'm new to haskell, may I ask you what would a real haskeller do?
02:18:12 <roconnor> ivanm: what is so terrible about Ashley's proposal?
02:18:19 <kmc> inetic, probably use two different names
02:18:23 <yitz> roconnor: ah, so maybe that non-exact correspondence is between all subgroups and all finite field extensions. yeah.
02:18:35 <yitz> it's been a few years...
02:18:37 <kmc> inetic, one for drawing Polygon and one for drawing [Polygon]
02:18:38 <ivanm> roconnor: I fail to see the need for it for starters
02:18:40 <ski> (dolio : or even, whether two such `f's are equal ..)
02:18:41 <roconnor> yitz: nope, that is exact too IIRC
02:18:50 <yitz> roconnor: no that definitely isn;'t
02:18:51 <ivanm> plus, the practical concern: how _does_ one test for equality on functions?
02:18:58 <kmc> inetic, any reason you need them to be the same function?
02:19:04 <dolio> ski: That isn't really an answer.
02:19:05 <roconnor> ivanm: he is only concerned about finite domains
02:19:12 <ivanm> roconnor: he initially didn't say so
02:19:18 <kmc> inetic, if you want to introduce more shapes, I'd keep the typeclass, but drop the instance for [Polygon]
02:19:20 <roconnor> ivanm: yes he did
02:19:23 <kmc> then you can make
02:19:25 <ivanm> :o
02:19:27 <inetic> kmc, just find it nice when I dont bloat the code with too many function names
02:19:29 * ivanm goes and checks again
02:19:36 <kmc> drawMany :: (Drawable a) => [a] -> (Int,Int) -> Render ()
02:19:36 <roconnor> ivanm: er well he said bounded enumerable domains
02:19:39 <ski> (dolio : well, granted :)
02:19:46 <dolio> ski: "Why do you need mutable values?" "To mutate things!"
02:19:48 <roconnor> ivanm: which may have not be quite right but close enough
02:19:56 <ivanm> fair enough
02:20:05 <roconnor> ivanm:
02:20:07 <roconnor> instance (Bounded a,Enum a,Eq b) => Eq (a -> b) where
02:20:08 <roconnor>     p == q = fmap p allValues == fmap q allValues
02:20:13 <roconnor> from his first message
02:20:18 <ivanm> roconnor: yeah, I see it now
02:20:21 <kmc> inetic, ah. we tend not to use type classes just to economize on names
02:20:22 <roconnor> I think even Conal may have developed a library for this
02:20:35 <roconnor> and I think we've done it on #haskell in the past too
02:20:37 <ivanm> I didn't consider that to be a finite domain off the top of my head
02:20:42 <ski> dolio : maybe one application could be to serialize datastructures containing functions .. in some cases
02:20:51 <kmc> inetic, i find beginners to Haskell tend to over-use type classes
02:21:09 <ivanm> roconnor: my feeling is that the possible use for this which isn't computationally expensive would be too difficult
02:21:18 <kmc> inetic, what if every drawable object *is* a function
02:21:26 <kmc> data Drawable = Drawable (a -> (Int,Int) -> Render ())
02:21:33 <roconnor> ivanm: http://conal.net/blog/posts/elegant-memoization-with-functional-memo-tries/  is sort of close
02:22:26 <ivanm> roconnor: a quick glance doesn't seem to show any function equality stuff...
02:23:22 <inetic> kmc, hmm, this type of overloading is something I use often in other programming languages, but I guess I'll just have to learn be without it. I'm sorry, I didnt get the last statement of yours
02:24:24 <kmc> inetic, well, functions are values right?
02:24:52 <kmc> inetic, you don't have to go without overloading... i'm just advising some restraint until you understand the language better
02:25:07 <roconnor> yitz: given a E:F a galois extension with galois group G, then the map Sup(G) -> Lat(E/F) defined by H -> E^H is an order reversing **bijection**
02:25:18 <roconnor> with inverse B -> Gal(E/B)
02:25:29 <kmc> inetic, beginners often think that two values which "behave" differently must be of different types
02:25:43 <roconnor> yitz: there is a bijection between the fields between E and F and the subgroups of G
02:25:45 <kmc> because they are used to a restricted sort of OOP where behavior is specified solely by methods of a class
02:25:48 <yitz> nope i don't think so.
02:26:04 <kmc> inetic, but functions are values in Haskell (and every good language), so you don't need a new type to specify a new behavior.  you just store a different function
02:26:18 <kmc> so if a drawable object is defined as "a thing that knows how to draw itself"
02:26:24 <roconnor> yitz: ah well, I copied this from my Galois theory textbook.
02:26:34 <inetic> kmc, oooh, I see :-)
02:26:35 <roconnor> yitz: anyhow, thanks for your help
02:26:38 <kmc> that is, a drawable object is *itself* a wrapper on a function of type (Int,Int) -> Reneder()
02:26:38 <roconnor> :)
02:26:43 <Jafet> > map (fix$(=<<)(!!).((([[]]:).repeat.uncurry(++).(map('0':)&&&reverse.map('1':))).).(.pred)) [1..]
02:26:45 <lambdabot>   [["0","1"],["00","01","11","10"],["000","001","011","010","110","111","101"...
02:26:45 <kmc> then you don't need to invent new types everywhere
02:26:47 <yitz> roconnor: i don't know wat "Lat" and "Sup" are here
02:26:58 <kmc> inetic, this isn't always the best representation but it's good to keep in mind
02:27:07 <roconnor> yitz: Lat is the lattice of fields between E and F
02:27:37 <roconnor> yitz: and Sup is a typo .. sorry ... It was supposed to be Sub, and Sub(G) is the lattice of subgroups of G.
02:27:39 <inetic> kmc, so I would be passing a function to the "draw" function to render, did I get it?
02:28:05 <kmc> data Drawable = Drawable ((Int,Int) -> Render ())
02:28:14 <kmc> draw :: Drawable -> (Int,Int) -> Render ()
02:28:18 <kmc> draw (Drawable f) = f
02:28:29 <kmc> (in fact there is a shorthand for putting that all in one line)
02:29:54 <roconnor> yitz: hmm, wikipedia's Galios connection page says : The motivating example comes from Galois theory: suppose L /K is a field extension. Let A be the set of all subfields of L that contain K,...
02:30:08 <roconnor> yitz: in particular there is no restriction that L / K be a galois extensions
02:30:18 <roconnor> yitz: perhaps there is only a bijection for galois extensions
02:30:25 <ski> (roconnor : how about something like `instance (Compact a,Discrete b) => Discrete (a -> b) where f0 == f1 = forAll $ \a -> f0 a == f1 a' ?)
02:30:32 <yitz> hmm could be that's it...
02:30:59 <yitz> they didn't say finite either :)
02:31:10 <roconnor> true
02:31:22 <roconnor> but even all finite extensions are not galois
02:31:29 <yitz> right of course not
02:31:49 <inetic> kmc, I think I need to digest it and play with it for a while, I'm very grateful for your time and explanations (a bit rare on other chats/forums), thank you!
02:31:51 <yitz> it's always easy to extend a finite extension to be galois though
02:32:13 <roconnor> and I could believe that the maps H -> E^H and B -> Gal(E/B) form a galois connection as you described
02:32:38 <roconnor> yitz: actually what's the difference between a galois connection and an adjuction?
02:32:54 <roconnor> is a galois connection simply an adjunction for partial orders?
02:33:07 <yitz> hmm, so in a galois extension it's a bijection, with normal subgroups corresponding to galois subfields? could be.
02:33:34 <roconnor> yitz: that will be true in at least characteristic 0
02:33:48 <roconnor> yitz: I'd have to pause to think if seperability issues are a problem
02:34:10 <roconnor> If E/F is a seperable field extensions is K/F also seperable for every intermediate field K?
02:34:15 <yitz> i really don't remember anymore.
02:34:28 <kmc> inetic, no problem.  have fun :)
02:34:32 <roconnor> yitz: :)
02:34:47 <roconnor> yitz: anyhow, I find what you said quite plausible
02:34:56 <yitz> back to haskell, it's fresher in my mind
02:35:23 <yitz> anyway, otherwise we're about to be booted to *-blah.
02:47:58 <roconnor> *tweet* *tweet*
02:48:09 <roconnor> *chirp* *chirp*
02:51:20 <yitz> roconnor: http://twitter.com/hackage
02:51:21 <tibbe> hpaste.org is down, who runs that machine?
02:51:33 * hackagebot frquotes 0.1.0 - Lexical extension for Quasi-Quotations using French-Quotes  http://hackage.haskell.org/package/frquotes-0.1.0 (NicolasPouillard)
02:51:51 <yitz> tibbe: mmorrow maybe?
02:52:02 <yitz> preflex: seen mmorrw
02:52:02 <preflex>  Sorry, I haven't seen mmorrw
02:52:07 <yitz> preflex: seen mmorrow
02:52:07 <preflex>  mmorrow was last seen on #ghc 86 days, 6 hours, 54 minutes and 22 seconds ago, saying: * mmorrow is rtfm'ing
02:53:13 <ski> roconnor : btw, Asheley Yakeley was discussing this recently on haskell-cafe, yes ?
02:53:16 <ski> ivanm : also see <http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/>,<http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/> (and <http://www.haskell.org/pipermail/haskell/2004-June/014134.html> "topology in Haskell" for a long paper)
02:53:36 <roconnor> ski: yes I'm aware of those references
02:53:37 <ivanm> ski: yeah
02:53:50 <yitz> tibbe: moonpatio.com is working. but it's full of spam.
02:53:52 <ski> roconnor : note the attribution :)
02:53:58 <roconnor> Asheley should be talking about compact domains and not finite domains
02:54:07 <tibbe> yitz: I posted something on hpaste.org yesterday that I want to retrieve!
02:54:14 <ski> (so, is Asheley talking at haskell-cafe or not ? :)
02:54:20 <roconnor> ski: ah opps
02:54:34 <roconnor> ski:  yes -cafe
02:54:37 <ski> ok, ty
02:56:26 <yitz> tibbe: yeah, the machine hpaste.org points to is owned by mmorrow.
02:56:50 <ivanm> you mean "he who has not been seen online for many a day"?
02:56:55 <ivanm> preflex: seen mmorrow
02:56:55 <preflex>  mmorrow was last seen on #ghc 86 days, 6 hours, 59 minutes and 10 seconds ago, saying: * mmorrow is rtfm'ing
02:57:11 <ivanm> sure takes him a long time to rtfm...
02:59:17 <tibbe> @tell mmorrow hpaste.org is down
02:59:17 <lambdabot> Consider it noted.
03:00:19 <ski> @where impossible
03:00:19 <lambdabot> I know nothing about impossible.
03:00:39 <ski> @where+ <http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/>,<http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/>
03:00:39 <lambdabot> Done.
03:01:20 <ski> @where topology
03:01:20 <lambdabot> I know nothing about topology.
03:03:04 <yitz> @hoogle topology
03:03:04 <lambdabot> No results found
03:03:27 <ski> @where+ topology "topology in Haskell" <http://www.haskell.org/pipermail/haskell/2004-June/014134.html> and "Synthetic topology of data types and classical spaces" <http://www.cs.bham.ac.uk/~mhe/papers/entcs87.(pdf|dvi|ps)> by Martín Escardo
03:03:28 <lambdabot> Done.
03:21:04 <benmachine> @where impossible
03:21:05 <lambdabot> I know nothing about impossible.
03:21:24 <benmachine> ski: did you miss out the actual keyword in your first addition?
03:22:22 <ski> er .. it appears that i did
03:22:23 <ski> ty
03:22:39 <ski> @where+ impossible <http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/>,<http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/>
03:22:39 <lambdabot> Done.
03:23:33 <kmc> the unattainable is unknown
03:23:57 <ski> hence, the known is attainable ?
03:24:09 <benmachine> heh
03:24:37 <dolio> No, un-unknown is un-unattainable.
03:24:38 <ski> (or, maybe s/hence/because/ depending on which you think more obvioous)
03:24:40 <kmc> are you positive?
03:24:44 <kmc> *contra*positive?
03:24:45 * kmc ducks
03:25:13 * benmachine excludes dolio's middle
03:25:18 <kingping> Are divideTriangle (x1, y1, z1) (x2, y2, z2) (x3, y3, z3) (depth+1) = do ...          and     divideTriangle a@(x1, y1, z1) b@(x2, y2, z2) c@(x3, y3, z3) (depth+1) = do ...    equal ?
03:25:37 <ski> dolio : that would work, but i prefer using `because', here :)
03:25:41 <kmc> kingping, the latter will additionally bind a, b, and c
03:25:59 <kingping> kmc: As pattern. But is it safe?
03:26:02 <kmc> kingping, the pattern v@p matches everything matched by the pattern p, but also binds the variable v to the entire thing matched
03:26:04 <kmc> "safe"?
03:26:09 <ski> (btw, there's paper called something about "Language of the Excluded Miracle", iirc)
03:26:15 <kmc> kingping, btw, i wouldn't use N+K patterns, they are going away in Haskell 2010
03:26:19 <kmc> that's the (depth+1)
03:26:20 <benmachine> kingping: they succeed or fail in exactly the same situations afaik
03:26:27 <kingping> I dunno. If it works exactly as I expect it to do :/
03:26:38 <kmc> yes, v@p will match iff p would match
03:26:57 <kingping> Okay.
03:27:11 <kingping> But what with (depth+1) ? I didn't hear about Haskell 2010
03:27:14 <kmc> it just gives you a name for the thing you took apart as well as the parts you got
03:27:31 <ski> @src scanr
03:27:31 <lambdabot> scanr _ q0 []     =  [q0]
03:27:32 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
03:27:32 <lambdabot>     where qs@(q:_) = scanr f q0 xs
03:27:40 <kmc> kingping, a pattern of the form (n+k) where n is a variable and k is an integer literal is called an "N+K pattern"
03:28:01 <kmc> and they are deprecated
03:28:12 <kmc> in the Haskell 2010 language standard, they are not allowed
03:28:16 <kingping> kmc: I know, but since I use tuples here, not just something other that should be put in braces before I can use as-pattern, I wasn't sure they're compatible (tuples and as-patterns).
03:28:22 <ski> > let n+1 = 3 in n
03:28:23 <lambdabot>   n
03:28:26 <ski> hmpf !
03:28:32 <ski> > let f (n+1) = n in f 3
03:28:33 <lambdabot>   2
03:28:41 <ski> > let f ((n+2)+1) = n in f 7
03:28:41 <kmc> kingping, you're asking if you need an extra layer of parentheses?
03:28:42 <lambdabot>   <no location info>: Parse error in pattern
03:28:43 <kmc> the answer is no
03:29:01 <kmc> an as-pattern can be formed from any pattern including a tuple pattern
03:29:10 <dolio> > let _@(n + 1) = 3 in n
03:29:11 <lambdabot>   <no location info>: parse error on input `@'
03:29:19 <dolio> > let v@(n + 1) = 3 in n
03:29:20 <lambdabot>   2
03:29:23 <ski> kingping : this is one of the rare exceptions to "function application binds tightest"
03:29:32 <kmc> > let v@(pred -> n) = 3 in n
03:29:33 <lambdabot>   2
03:29:37 <kmc> > let v@(pred -> n) = 3 in (n,v)
03:29:37 <kingping> kmc: Yes, I think I'd ask that if english were  my native language :)
03:29:38 <lambdabot>   (2,3)
03:30:04 <ski> kingping : so `f xs0 @ (x:xs) = ...' actually means `f (xs @ (x:xs)) = ...', rather than `(f xs) @ (x:xs) = ...'
03:30:34 <ski> dolio : interesting ..
03:30:54 <ski> (.. but, upon reflection, not that surprising, i guess)
03:31:06 <dolio> Not really.
03:31:27 <ski> > let v@(n + 1) = 0 in n
03:31:28 <lambdabot>   *Exception: <interactive>:1:145-157: Irrefutable pattern failed for pattern...
03:31:34 <ski> > let v@(pred -> n) = 0 in n
03:31:35 <lambdabot>   -1
03:31:47 <dolio> > let (pred -> n) = 0 in n
03:31:48 <lambdabot>   -1
03:32:01 <dolio> > let pred -> n = 0 in n
03:32:02 <lambdabot>   <no location info>: parse error on input `->'
03:32:10 <ski> that is strange imo, though
03:32:19 <Twey> n+k patterns are strange :Ã¾
03:32:22 <ski> why required brackets, in that case ?
03:32:27 <benmachine> didn't we have a discussion about this the other day?
03:32:34 <benmachine> it could get quite odd with case
03:32:36 <ski> (Twey : this remark was about view patterns :)
03:32:42 <benmachine> case x of pred -> n -> n
03:32:43 <Twey> ski: Same reason as for (x : xs), I imagine
03:32:46 <ski> benmachine : yes, we talked about it
03:32:50 <ski> it is still strange :)
03:32:54 <benmachine> oic, fair enough
03:32:57 <dolio> > let x : xs = [1] in (x, xs)
03:32:58 <lambdabot>   (1,[])
03:33:09 <ski> (dang, dolio beat me to it !)
03:33:10 <Twey> > let [pred -> n, succ -> m] = [3, 3] in (n, m)
03:33:11 <lambdabot>   (2,4)
03:33:22 <ski> > case [1,2,3] of x : xs -> (x,xs)
03:33:22 <benmachine> case x of pred -> pred; pred -> n -> n + 1
03:33:23 <lambdabot>   (1,[2,3])
03:33:40 <Twey> Hm
03:33:55 <Twey> benmachine: Ah, yeah
03:33:57 <benmachine> I think the trick is making it obvious where the pattern ends
03:33:58 <Twey> That's probably it
03:34:16 <benmachine> I don't think it's ambiguous to parse without parentheses, just obnoxious
03:35:04 <dolio> > let (pred -> pred -> n) = 0 in n
03:35:05 <lambdabot>   <no location info>: parse error on input `->'
03:35:51 <kingping> > let (a, b) = (2+3, 4) in a * b
03:35:52 <lambdabot>   20
03:36:04 <ski> > let (pred -> (pred -> n)) = 0 in n
03:36:05 <ski> > let ((\pred -> pred-1) -> n) = 0 in n
03:36:05 <lambdabot>   -2
03:36:06 <lambdabot>   -1
03:36:17 <benmachine> heh
03:36:50 <dolio> > let (\x -> x -> n) = 0 in n
03:36:51 <lambdabot>   0
03:36:59 <dolio> Wow. I wasn't expecting that.
03:37:12 <kmc> wow
03:37:16 <Twey> Duuude, cool.
03:37:18 <kmc> this will be fun at the next IOHCC
03:37:30 <kmc> :t \() -> () -> ()
03:37:31 <lambdabot> parse error on input `->'
03:37:37 <kmc> :t (\() -> () -> ())
03:37:38 <lambdabot>     Pattern syntax in expression context: \ () -> () -> ()
03:37:49 <kmc> :t (\x -> x -> 0)
03:37:50 <lambdabot>     Pattern syntax in expression context: \ x -> x -> 0
03:37:55 <Twey> Oh wait
03:38:02 <Twey> This means Cale enabled view patterns
03:38:07 <Twey> Thanks, Cale!
03:38:07 <kmc> > let (\x -> x -> n) = 0 in n
03:38:08 <lambdabot>   0
03:38:12 <kmc> Thale
03:38:15 <ski> that's .. interesting
03:38:20 * benmachine hugs kmc
03:38:23 <kmc> > (\x -> x -> n) = 0
03:38:25 <lambdabot>   <no location info>: parse error on input `='
03:38:26 <kmc> > (\x -> x -> n)
03:38:27 <lambdabot>   Pattern syntax in expression context: \ x -> x -> n
03:38:31 * kmc hugs back
03:39:22 <ski> hm, i would still like to write a `\p0 -> e1 -> p' pattern as `let e1 = p in e0'
03:39:51 <ski> > let (\x -> x*2 -> n) = 5 in n
03:39:52 <lambdabot>   10
03:39:54 <dolio> If it can parse that, it's probably possible to parse case e of f -> p -> e'
03:40:11 <ski> > let (let x*2 = n in x) = 5 in n  -- is how one'd use that
03:40:12 <lambdabot>   <no location info>: Parse error in pattern
03:40:37 <benmachine> dolio: so the question is should it be able to parse this, or not be able to parse that?
03:40:43 <dolio> :)
03:40:51 <cybercobra> some type error involving kinds: http://ideone.com/8f9DE  suggestions?
03:40:52 <ski> that appears to me to be clearer than this `\x -> x*2 -> n' (or `(\x -> x*2) -> n' if you prefer :) pattern
03:41:48 <ski> so, `5' would be matched against a new, pattern-local, variable `x' (generally a pattern containing such variables)
03:42:02 <Twey> cybercobra: You can't have a Set Set â€” you need a Set (Set a)
03:42:05 <ski> then `n' is matched against `x*2', and the binding for `n' is exported
03:42:25 <Twey> cybercobra: Because â€˜Setâ€™ is a type-constructor, but â€˜Setâ€™ (the outer one) wants a concrete type
03:42:35 <cybercobra> Twey: that gives a different type error
03:42:50 * ski waits for people to either say that that's incomprehensible nonsense, or lucid way of expression
03:42:58 <cybercobra> Twey: http://ideone.com/XM9k9
03:43:39 <Twey> cybercobra: Well, you need to include the variable in the left-hand side, too
03:43:51 <dolio> ski: So pat ::= ... | let <expr> = <pat> in <pat>?
03:43:58 <Twey> And pass it wherever you use your type
03:45:12 <Twey> cybercobra: http://ideone.com/L3wqh
03:45:33 <fasta> cybercobra, type variables don't just magically appear in Haskell land.
03:46:50 <benmachine> ski: it upsets me to have let ... in <pat> when I am so used to <exp> but maybe that's just force of habit
03:47:08 <benmachine> :t id
03:47:09 <lambdabot> forall a. a -> a
03:47:11 <dolio> The flow is rather reversed.
03:47:26 <ski> dolio : yes, though obviously, you should be able to have several of `<expr> = <pat>' in there
03:47:30 <dolio> Which makes it a bit confusing to think about at first.
03:47:41 <dolio> Yeah, sure.
03:48:03 <benmachine> that could produce some quite sizeable patterns :o
03:48:18 <ski> (i do think it is the "correct" order to say `<expr> = <pat>' rather than `<pat> = <expr>' .. though i suppose one could possibly go with the other way as well)
03:48:49 <ski> benmachine : i'm not suggesting one overuse this, necessarily :)
03:49:02 <ski> just that it might be nice to allow this
03:49:13 <ski> (and it seems to have sensible semantics)
03:49:33 <ski> of course, it'd be nice to see some more relevant/useful motivating examples
03:49:37 <dolio> I still think the case version is confusing.
03:50:13 <ski> dolio : i was indenting it a bit sloppily when i talked about it last time ..
03:50:27 <ski> instead of
03:50:45 <ski>   lookup k0 [         ] = Nothing
03:50:53 <ski>   lookup k0 ((k,v):kvs)
03:51:11 <ski>     | k0 == k   = Just v
03:51:18 <kmc> <pat> ni <pat> = <expr> ... tel
03:51:23 <ski>     | otherwise = lookyp k0 kvs
03:51:31 <ski> kmc :)
03:51:59 <ski> (though i really think using `let' and `in' is appropriate .. we don't use different syntax for tuples or application in patterns, e.g.)
03:52:15 <ski> we can say
03:52:25 <ski>   (case lookup k0 [         ] of
03:52:34 <ski>      Nothing -> n
03:52:55 <ski>      Just v  -> j v)
03:53:01 <ski>     = n
03:53:12 <ski>   (case lookup k0 ((k,v):kvs) of
03:53:16 <ski>      Nothing -> n
03:53:26 <zygoloid> > case "Eek!" of (\x -> x -> x) -> x
03:53:26 <ski>      Just v  -> j v)
03:53:27 <lambdabot>   "Eek!"
03:53:36 <ski>     | k0 == k   = j v
03:53:48 <ski>     | otherwise = case lookyp k0 kvs of
03:53:55 <ski>       Nothing -> n
03:54:02 <ski>       Just v  -> j v
03:54:26 <ski> maybe you can parse how the guards attach better, this way ?
03:54:40 <ski> however, this is somewhat unsatisfactory for two reasons
03:54:42 <benmachine> zygoloid: eek indeed
03:54:56 <benmachine> > case "Eek!" of \x -> x -> x -> x
03:54:57 <lambdabot>   <no location info>: Parse error in pattern
03:55:00 <benmachine> aww
03:55:05 <ski> it is irritating to *have* to say `Just v -> j v' instead of something like `Just -> j'
03:56:16 <ski> also, the last (normal, expression-)`case' seems useless, in some sense
03:56:49 <ski> this latter issue can be alleviate in this case, by writing
03:57:02 <ski>   (case lookup k0 kvs of
03:57:06 <ski>      Nothing -> n
03:57:11 <ski>      Just v  -> j v)
03:57:26 <ski>       = loop kvs
03:57:30 <ski>     where
03:57:39 <ski>     loop [         ] = n
03:57:45 <ski>     loop ((k,v):kvs)
03:57:55 <ski>       | k0 == k   = j v
03:58:06 <ski>       | otherwise = loop kvs
03:58:22 <ski> (which would typecheck, and is nicer)
03:58:52 <ski> dolio : does that make it any clearer ?
04:03:57 <dolio> I'm not sure I buy the 'j v'. Higher-order pattern matching.
04:05:51 <dolio> I suppose it's possible to syntactically fiddle the Just case into a function applied to the v, but it seems non-trivial.
04:08:45 <ski> the idea is, so to speak, to catch the `Nothing'- and the `Just'- continuation (i.e. the function that starts from the corresponding branches in the `case' that is conceptually wrapping the call to `lookup')
04:09:11 <ski> the above was the *declarative* way i could come up with, to express this
04:10:17 <ski> (now, i suppose that *just* having a syntax like this might not be that useful in most cases .. but if it is coupled with something like Olin Shivers' "Multi-return function call" idea, it becomes a bit more interesting)
04:10:40 <ski> (and yes, this is related to my ideas about "unboxed variant"
04:10:43 <ski>  types)
04:11:38 <ski> (also, if we could generalize from `case' to a folding `cata' construction .. this could be used to give a way to guarantee tree deforestation .. i think)
04:13:04 <ski> consider e.g. the problem of "left-associated" calls to `(>>=)' in the `Maybe' monad .. this can be cured by translating into CPS (or, by using a CPS monad)
04:14:09 <ivanm> *sigh* yet another piece of Dot syntax that isn't explained properly by the documentation
04:14:24 <ski> however, it would be much nicer, imo, if we could either have some syntax like above that worked for any algebraic type, that could be used to ensure "non-interpreting" semantics in cases where it is not needed (checking if argument is `Left e', then just returning the same `Left e' in the `Either e' monad)
04:15:35 <ski> or, if we could have "unboxed variant" types (or something similar) that used the normal `case' syntax, but with guarantees of (similar to above) semantics (wrt efficiency)
04:22:15 <cosinelaw> hi, I need help with cabal
04:26:26 <benmachine> cosinelaw: that is not very specific
04:26:35 <writer> Is www.haskell.org down ?
04:26:58 <quicksilver> writer: no.
04:27:23 <quicksilver> http://downforeveryoneorjustme.com/www.haskell.org
04:28:06 <writer> quicksilver: but are you able to open it at your end ?
04:28:10 <quicksilver> yes.
04:28:23 <writer> I noticed even DNS resolution happening for it is also slow.
04:28:47 <quicksilver> that is overwhelmingly likely to be a problem with your (ISP's) DNS servers
04:29:34 <writer> quicksilver: I don't use my ISP's DNS, I run my own DNS.
04:29:57 <writer> seems some intermediate router is bj0rked http://pastebin.com/UVQeZhb8
04:30:03 <quicksilver> then it's probably a problem with your upstream IP connectivity
04:30:11 <quicksilver> but if you run your own DNS you know this well enough I'm sure
04:30:35 <sinelaw> benmachine: sorry i was away.
04:30:48 <sinelaw> I'm trying to build an executable, in the same cabal that builds my lib, which binds to C++
04:30:53 <quicksilver> writer: certainly my route doesn't involve tinet, so let's blame them :)
04:31:12 <writer> yeah :(
04:31:15 <sinelaw> the lib compiles and links, but the executable fails linking - undefined references  to stuff in my own C++ files
04:31:31 <sinelaw> although I DID add "c-sources" section also in the lib
04:31:35 <ivanm> sinelaw: OK, in case you still care, I'm almost done with the latest graphviz release
04:31:42 <sinelaw> and also in the executable, only the executable fails to link.
04:31:45 <ivanm> I've got one more parsing error to track down, then documentation to write, etc.
04:31:50 <sinelaw> ivanm: of course I do! what's new?
04:32:08 <cybercobra> @type foldr
04:32:09 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
04:32:30 <ivanm> sinelaw: well, it can now parse almost all shipped sample .gv files (one has a parsing problem; the other is latin1.gv which has a locale problem so I'm ignoring it)
04:32:35 <quicksilver> sinelaw: c++ has to be linked differently.
04:32:38 <sinelaw> any hints on finding out what the problem is with linking here? could it be that GHC puts the libs in the wrong order on the command line of the linker? (I always forget if that matters)
04:32:41 <ivanm> this involves a lot of parsing errors fixed
04:32:49 <quicksilver> sinelaw: normally one achieves that by using g++ for the linking step
04:33:01 <quicksilver> sinelaw: ...but with ghc that's probably not the answer.
04:33:17 <sinelaw> can I tell ghc to use g++ to link?
04:33:24 <sinelaw> i meant cabal
04:33:29 <quicksilver> I'm not sure.
04:33:39 <quicksilver> I know that I worked some of this out, once
04:33:41 <ivanm> sinelaw: it now also (properly) supports HTML-like labels and record labels (I had fake URL label support that didn't actually work since I had nfi what it was at the time)
04:33:48 <quicksilver> I compiled some modificiations to wx, which is C++
04:33:56 <quicksilver> but I don't remember the answers. Trying to find the code.
04:34:40 <quicksilver> sinelaw: if you paste the error that might help a little, although I'm not confident
04:34:51 <sinelaw> it's just a linker error, but i will.
04:35:45 <sinelaw> wow did a spamming bot attack moonpatio?
04:35:54 <sinelaw> quicksilver: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=10196#a10196
04:36:20 <sinelaw> who owns moonpatio? it's being attacked by spam bots
04:36:42 <BONUS> mmorrow owns moonpatio
04:36:47 <sinelaw> ivanm: sounds good, unfortunately i don't see when i'll be able to take advantage of that
04:36:48 <quicksilver> preflex: seen mmorrow
04:36:48 <preflex>  mmorrow was last seen on #ghc 86 days, 8 hours, 39 minutes and 3 seconds ago, saying: * mmorrow is rtfm'ing
04:36:49 <BONUS> but he's AWOL
04:36:51 <sinelaw> no time
04:37:04 <sinelaw> yeah, he's been away for a long time
04:37:04 <ivanm> sinelaw: heh
04:37:31 <ivanm> sinelaw: however, I'm thinking of doing a tutorial-style blog post this weekend or so; would you be able to look through it and see if it makes sense, etc.?
04:37:53 <sinelaw> sure, if I'll remember.
04:37:59 <sinelaw> :)
04:38:59 <ivanm> heh
04:40:06 <sinelaw> quicksilver: i'm looking at wxcore and there's nothing special there
04:40:18 <sinelaw> or anything that seems relevant that i'm not doing
04:40:27 <sinelaw> but they're building a lib, not an executable
04:40:59 <quicksilver> if you compile 'by hand' with ghc does it work?
04:41:20 <sinelaw> ah wait they have a setup.hs
04:41:21 <Younder> hearing the most beutifu music makkes we wonder.. Is this all there is?
04:41:36 <sinelaw> it also makes your hand shake uncontrollably
04:41:49 <Younder> nop
04:48:09 <sinelaw> quicksilver: c++ name mangling :(
04:48:31 <sinelaw> what do I do?
04:48:50 <quicksilver> why is the name mangling a problem?
04:48:58 <quicksilver> are you trying to access a C++ function via the FFI?
04:50:03 <sinelaw> actually i'm trying to wrap C++ with C stuff
04:50:15 <sinelaw> but then the wrapping function is also C++, come to think of it.
04:50:45 <ski> `extern "C"' ?
04:51:24 <sinelaw> hmm.
04:51:32 <sinelaw> i'll try that
04:52:09 <ski> (wrapping the "wrapping functions" with `extern "C" { ... }' if i remember the syntax correctly)
04:52:36 <sinelaw> yip!
04:52:55 <sinelaw> ski: thanks. i was thinking about it but now i actualyl tried and it works.
04:54:16 <Twey> Don't we have some sort of library for C++ FFI yet?
05:02:01 <Itkovian> anybody did a recent (darcs head) of  ghc + llvm patch?
05:07:48 <mreh> I can't get an intuitive grasp of the exists quantifier the same way as the forall
05:08:16 <dolio> What's your intuitive grasp of forall?
05:08:37 <mreh> I know that the type following a forall must be true for all the type parameters qualified as such
05:09:14 <mreh> so you're restricting your type information to just what you know about that variable
05:09:27 <mreh> i.e. what is listed in the type context
05:09:47 <ski> if you have `forall a. ..a..', you can treat it as having type `..T..' for any type `T' (of appropriate kind) that you want
05:10:10 <mreh> the only one that satisfies that would be _|_
05:10:34 <ski> if you have `..T..' for any type `T', you can treat it like `exists a. ..a..' (not vecessarily replacing all occurances of `T') (here `a' gets the same kind as `T')
05:10:51 <ski> by `forall a. ..a..' i mean e.g. `forall a. [a] -> Int'
05:11:14 <ski> so, you can treat that as having the more specific type `[T] -> Int'
05:12:18 <ski> similarly, if you have
05:12:21 <ski>   (String,Char -> String -> String,String -> Maybe (Char,String),String -> String)
05:12:45 <ski> you can treat that as having the more *abstract* (as in abstract data types) type
05:13:08 <ski>   exists s. (s,Char -> s -> s,s -> Maybe (Char,s),s -> s)
05:13:24 <ski> here `s' could represent a stack of elements of type `Char'
05:14:01 <ski> and the tuple contains the empty stack, the "push" operation, the "topPop" operation, and the "show" operation
05:15:18 <ski> maybe it would be more interesting if we said this represents queues of `Char's, instead, with empty queue, "pushFront" and "topPopBack" operations (and still "show")
05:15:33 <ski> then another way of getting the same abstract type is starting with
05:15:33 <mreh> I should have stoped you when I got lost
05:16:02 <ski>   ((String,String),Char -> (String,String) -> (String,String),(String,String) -> Maybe (Char,(String,String)),(String,String) -> String)
05:16:10 <quicksilver> One way to understand the difference between forall and exists is to think of it like a game. In one case you get to choose the type (and you can choose any type and it will still work). In the other case someone else gets to choose the type (and you have to cope with whatever choice was made)
05:16:33 <ski> using the folklore representation of a queue as a list of a "front" part, and a (reverse) list of a "back" part
05:16:37 <ski> mreh : hehe ;)
05:16:39 <mreh> the first being exists, the latter being forall
05:16:48 <quicksilver> In terms of a library function, it's the difference between "library author gets to choose the type" and "library user gets to choose the type"
05:17:25 <humasect> hey uhh .. with this : http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/Backends/LLVM , and that LLVM supports arm , this means ghc can compile to native arm code ?
05:17:56 * ivanm doubts it
05:18:27 <humasect> how come you doubt it ?
05:18:40 <ski> mreh : anyway, my main point above being that as you can get from `forall a. [a] -> Int' to *both* `[String] -> Int' and `[Handle] -> Int' (and others)
05:18:48 <dolio> The runtime would probably have to be ported to arm.
05:18:53 <humasect> oh, right
05:18:54 <humasect> =)
05:18:56 <quicksilver> it makes it closer, humasect, but not there yet.
05:18:57 * humasect half asleep.
05:19:17 <quicksilver> dolio: the runtime already runs on arm.
05:19:19 <humasect> u guys always wake me up when i come here with questions about big dreams=) thx
05:19:29 <humasect> oh, wait now! =)
05:19:38 <quicksilver> GHC on ARM has worked for years unregisterised.
05:19:43 <quicksilver> you can apt-get install it on debian/arm
05:19:48 <dolio> Ah.
05:19:53 <quicksilver> but unregisterised means slow, of course.
05:19:56 <ski> mreh : similarly, you can get *from* *both* `QueueInterface String Char' and `QueueInterface (String,String) Char' (and many others) into `exists s. QueueInterface s Char'
05:19:59 <ski> assuming
05:20:02 <humasect> yeah, hmm
05:20:18 <ski>   data QueueInterface representationType elementType = QI
05:20:19 <humasect> i am still hoping to use haskell for the upcoming iphone(arm) projects
05:20:28 <ski>     { emptyQueue :: representationType
05:20:35 <quicksilver> humasect: it should be a *relatively* small bit of work to connect the dots to get LLVM/arm playing well with GHC.
05:20:37 <mreh> ski: I've lost you again
05:20:40 <humasect> lua is the closest i can get =(
05:20:45 <ski>     , pushFront :: elementType -> representationType -> representationType
05:20:55 <p_l> humasect: iPhone SDK 4.0 makes it available only for jailbroken phones.
05:20:58 <mreh> humansect: they seem to use arm in all the small devices
05:20:59 <ski>   , topPopBack :: representationType -> Maybe (elementType,representationType)
05:21:09 <humasect> mreh: true~
05:21:10 <mreh> it was in the first generation nintendoDS
05:21:12 <quicksilver> assuming you find someone who understand GHC internals.
05:21:16 <ski>   , showQueue :: ShowS elementType -> ShowS representationType
05:21:17 <ski>   }
05:21:22 <quicksilver> p_l: only if they choose to enforce that clause
05:21:30 <ski> mreh : ok
05:21:41 <quicksilver> p_l: since they don't enforce any other clause in that agreement consistently there is no reason to believe this one would be different.
05:21:43 <humasect> p_l: naw. what quicksilver said. there are many lua apps and other language apps floating around the appstore ~
05:22:04 <p_l> quicksilver: they already went around stripping apps that were recognised for usage of "unofficial" APIs
05:22:22 <humasect> also the recent adjustment appears to be somethign about not using the documented APIs (cocoa et al) unless objc/c/c++
05:22:32 <quicksilver> p_l: the entire agreement could be summarised in one sentence: "we will do what we want, we will tell you if your app is permitted or not when you submit the store."
05:23:07 <humasect> hm QS is wise and the weight on my heart has been lifted as i had some uncertainty left .. thank you =)
05:23:35 <p_l> humasect: that's the one I meant - it specially prohibits any other language, including languages compiled into C... Well, for non-commercial work, it's definitely alright (i.e. if you aren't basing your income on that)
05:23:44 <ski> mreh : when you see `foo :: Foo -> exists a. Bar a' you should read this as a function taking an input of type `Foo' and returning a result of type `Bar a', only you have no idea what `a' will be in each case (it might be different on calling `foo' with different arguments)
05:23:46 <humasect> it does make sense that it is just legal stuff. no one is really worried in practice, i feel
05:24:20 <Twey> Hehehâ€¦ we should make a competition to see who can slip the biggest bugs through Apple's QA department
05:24:25 <ski> mreh : since you have no idea what `a' will be in `Bar a', the only way to handle this is by *you* being polymorphic in `a' : i.e. can handle any `a' at all, and `foo' decides which `a' to use, in each case
05:24:35 <humasect> p_l: for eg. an app can use ObjC for cocoa and apple's libraries, and whatever else internally on their own. a script (for eg lua or haskell) working only in the private api (say, video game AI) is all right =)
05:24:42 <humasect> Twey hehe
05:24:50 <quicksilver> humasect: well, they want to have a wide variety of excuses to choose from then they object to your app. None of the excuses they use is required to be the real reason for the rejection.
05:25:01 <quicksilver> humasect: although that falls foul of the 'no interpreters' rule, which is a separate one.
05:25:04 <quicksilver> (and has been there for ages)
05:25:06 <humasect> Twey: i read today of a C64 emulator that had a secret basic interpreter that was needing to be fixed/hidden
05:25:15 <quicksilver> (and is violated by 100s of the apps on the store)
05:25:21 <Twey> humasect: Haha, sweet
05:25:24 <humasect> quicksilver: yea, makes sense ~
05:25:43 <yitz> i think the point is that want to reserve the right to read - and easily understand - the source code, so they can understand what the app is doing.
05:25:47 <Twey> humasect: If only it were GHC :Ã¾
05:25:53 <humasect> hehe
05:26:09 <Twey> yitz: Yet they permitted C++?  :Ã¾
05:26:11 <yitz> so for that, they need to reserve the right to limit the devel environment to things they know
05:26:11 <fasta> Or you know, we can just completely ignore Apple?
05:26:17 <p_l> humasect: the way I understood the new agreement, the app has to be written in the language... as for interpreters, I think it was against making interpreters for usable stuff that wouldn't go through their AppStore. Dunno. Not planning to use that platform :)
05:26:20 <yitz> Twey: why not?
05:26:30 <humasect> yitz: i think they do not read the code, when one submits the app, it is a zip of the binary and resource files
05:26:39 <Twey> yitz: Nobody understands C++ â˜º
05:26:49 <yitz> C++ is a lot better known that Haskell, or Adobe's new thing, or all kinds of weird API's, etc.
05:26:52 <dmwit> fasta++
05:27:02 <humasect> p_l: it is mostly stuff like downloadable scripts and exploits and even just confusing things they dont understand .. =)
05:27:03 <p_l> fasta++
05:27:05 <fasta> Nobody writing code wants computers to move into the console area. Every programmer for the IPhone is supporting that practice.
05:27:13 <yitz> Twey: hehe. so, they'll reject those most of the time if they need to understand the source code :)
05:27:15 <ski> mreh : if that doesn't help much either .. i think you need to look more at specific examples
05:27:27 <fasta> So, long term, it is simply incredibly stupid to support anything like that.
05:27:40 <Twey> fasta++
05:27:40 <humasect> fasta: not everyone likes their day job =|
05:28:13 <humasect> apple does not check the source code
05:28:15 <Twey> Well, s/computers/smartphones/
05:28:22 <yitz> fasta: console area?
05:28:40 <fasta> humasect, if you can program for a Mac you can program for anything else.
05:28:51 <yitz> humasect: could be not, so far. but it makes sense for them to want to, at least some of the time.
05:29:10 <fasta> yitz, I just mean that you get platforms on which software is loaded, but you cannot load your own software.
05:29:42 <fasta> Tivoization, I think, is the official term.
05:29:43 <humasect> coding for a mac is generally requiring some cocoa and apple api calls anyway, it is not much different than iphone
05:29:52 <yitz> fasta: ah, right. yeah, that's the iphone.
05:30:23 <fasta> yitz, yes, but if people support it on the iphone, they will surely try to add extra platforms or their competitors will.
05:30:29 <yitz> fasta: from a consumer pov, consoles make sense.
05:30:52 <ski> not from a learning pov, though
05:31:02 <yitz> nor from a fsf pov
05:31:05 <fasta> yitz, I think the word "consumer" corresponds to a braindead moron with money, not a person.
05:31:08 <humasect> integration and simplicity is generally more productive than freedom of too much complicated choosing and choices
05:31:31 <humasect> too much choice leaves us goofing around in haskell all the time
05:31:32 <yitz> fasta: please, no insulting, i know a lot of them, some are very nice
05:31:51 <humasect> and now (like me) are spoiled to have to use "lesser" languages
05:32:07 <fasta> yitz, I just mean how corporations see consumers.
05:32:16 <fasta> yitz, they won't ever say that, of course.
05:32:26 <yitz> fasta: oh. no, they won't ever.
05:32:39 <clanehin> It's not just a "leadning/fsf pov" -- many people benefit greatly from freedom of the press who don't own an actual printing press, likewise for free software end-users.
05:32:40 <humasect> okay i dont know what happened but i hope it is not my fault for distracting you guys
05:33:07 <quicksilver> it probably is your fault, but as long as there aren't genuine haskell questions being lost in the noise I don't htink it matters :)
05:33:09 * ski accusingly points at humasect
05:33:10 <humasect> suddenly it is a discussion of political principles and religious whatnot
05:33:18 <ski> you bad person !
05:33:21 <humasect> hehe=)
05:33:47 <fasta> Technology and politics are related.
05:33:48 <yitz> clanehin: ok but then it boils down to what apple's policies are like for allowing or not allowing apps. so far...
05:34:02 <cybercobra> @type foldr
05:34:03 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
05:34:07 <humasect> qs =) thx again, everyone else too !  let us hope our dreams do not become confused from the reality before us!
05:34:31 <fasta> The arrogance of the politicians is directly dependent on the amount of technology they have at their disposal for killing people with other opinions.
05:34:37 <yitz> cybercobra++
05:35:39 <ski> cybercobra : simple exercise. write `unfoldr' using `build' instead of `(:)' and `[]'
05:35:42 <cybercobra> yitz: heh, this is the problem with positional parameters, one always needs to look them up
05:35:44 <ski> @type GHC.Exts.build
05:35:45 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
05:36:27 <ski> (often positional parameters are not hard to figure out, if the type is polymorphic enough)
05:36:31 <yitz> cybercobra: in emacs, it pops up in the message area whenever I type foldr or put the cursor on it
05:36:50 <mpiechotka> Hello. I found myself often defining: f <.> g = fmap f . g :: Functor f => (b -> c) -> (a -> f b) -> a -> f c. I couldn't find anything like that in hoogle - is it not useful or noone bother to add it to, for example, Control.Applicative?
05:37:14 <yitz> ski: you just guess, then ghc tells you if you got it wrong.
05:37:45 <ski> @type (^<<)  -- mpiechotka
05:37:46 <lambdabot> forall c d (a :: * -> * -> *) b. (Arrow a) => (c -> d) -> a b c -> a b d
05:37:49 <cybercobra> yitz: (not an emacs user)
05:38:27 <ski> @type \f -> runKleisli . (f ^<<) . Kleisli
05:38:28 <lambdabot> forall (m :: * -> *) a b c. (Monad m) => (c -> b) -> (a -> m c) -> a -> m b
05:38:41 <ski> hm, that has a `Monad' constraint, rather than `Functor' ..
05:38:44 <mpiechotka> ski: Hmm. For functors there is no standard arrows.
05:39:20 <mpiechotka> ski: And it seems to me a bit overkill for something which is the same to <$> as . to $ ;)
05:39:27 <cybercobra> @hoogle [a] -> (a,a)
05:39:27 <lambdabot> Test.QuickCheck two :: Monad m => m a -> m (a, a)
05:39:27 <lambdabot> System.Random split :: RandomGen g => g -> (g, g)
05:39:27 <lambdabot> Network.BufferType buf_span :: BufferOp a -> (Char -> Bool) -> a -> (a, a)
05:39:38 <Itkovian> "inplace/bin/ghc-stage2" <snip> -o utils/haddock/dist/build/Haddock/Types.o yields an Illegal instruction :-(
05:39:41 <ski> @type let f <.> g = (f .) . g in (<.>)  -- Caleskell :)
05:39:42 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
05:40:32 <ski> @type head &&& head . tail  -- cybercobra
05:40:33 <lambdabot> forall a. [a] -> (a, a)
05:40:55 <yitz> @pl \f g -> (f .) . g
05:40:55 <lambdabot> (.) . (.)
05:41:06 <ski> hm, aha
05:41:07 <yitz> @type ((.).(.))
05:41:07 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
05:41:14 * ski never thought of that
05:41:18 <yitz> it's the owl eyes!
05:41:21 <cybercobra> ski: not quite. looking for something to compute pairings
05:41:31 <mreh> (.,.) <- this is an owl
05:41:31 <ski> "pairings" being ?
05:41:43 <bastl> hi
05:41:47 <ski> lo
05:42:09 <bastl> is there a quick way to see what packages use another package?
05:42:22 <bastl> depends^(-1)
05:42:25 <cybercobra> ski: combinations of 2 items from a list without regard for order
05:42:48 <ski> > liftM2 (,) `join` "abcd"
05:42:49 <lambdabot>   [('a','a'),('a','b'),('a','c'),('a','d'),('b','a'),('b','b'),('b','c'),('b'...
05:42:54 <ski> > liftM2 (,) `join` "ab"
05:42:54 <mpiechotka> @pl \f g -> fmap f . g
05:42:54 <lambdabot> (.) . fmap
05:42:55 <lambdabot>   [('a','a'),('a','b'),('b','a'),('b','b')]
05:43:04 <yitz> bastl: in aptitude, hit 'r'. oh, wait...
05:43:27 <bastl> yitz: how about cabal?
05:43:28 <ski> cybercobra : or maybe you wanted in each pair `(x,y)', the `y' to not precede the `x' in the original list ?
05:43:39 <cybercobra> ski: distinct items (no self-pairing)
05:43:47 <cybercobra> ski: no, that's not a constraint
05:44:00 <ski> cybercobra : or maybe even that each such `x' must come strictly before corresponding `y' in the original list ?
05:44:03 <yitz> bastl: the problem is, the domain is not really defined.
05:44:04 <ski> ok
05:44:22 <yitz> bastl: it's really a question to ask hackage, not cabal
05:44:27 <bastl> haskell packages on hackage.
05:44:31 <ski> cybercobra : what if you start with the list "aba" .. can the latter `a' be combined with the former one ?
05:44:45 <bastl> yeah, i mean a cool flag to cabal-install i didnt know yet ..
05:44:46 * Botje feels like tackling a project euler problem
05:44:49 <bastl> sigh.
05:45:25 <yitz> bastl: althougn, you are right, cabal install does have a list of all packages on haskage. i don't think it builds a database of their dependencies though, it just knows their names.
05:46:14 <bastl> yitz: right, its more a build tool, than a pkg manager. anyhow. other ideas?
05:46:41 <cybercobra> ski: magic "abcd" = [('a','b'),('a','c'),('a','d'),('b','c'),('b','d'),('c','d')] (ordering of result list and ordering within pairs not significant)
05:47:26 <ski> @let mark :: MonadPlus m => [a] -> m ([a],a,[a]); mark [] = mzero; mark (a0:as) = return ([],a0,as) `mplus` do (l,a,r) <- mark as; return (a0:l,a,r)
05:47:27 <lambdabot>  Defined.
05:47:27 <yitz> bastl: go ahead and write it as a separate program, and upload it to hackage.
05:48:02 <ski> > [(a0,a1) | (l,a0,r) <- mark "aba", a1 <- l ++ r]
05:48:03 <lambdabot>   [('a','b'),('a','a'),('b','a'),('b','a'),('a','a'),('a','b')]
05:48:11 <ski> > [(a0,a1) | (l,a0,r) <- mark "abc", a1 <- l ++ r]
05:48:12 <lambdabot>   [('a','b'),('a','c'),('b','a'),('b','c'),('c','a'),('c','b')]
05:48:41 <ski> cybercobra : oh, so you *do* want the "each such `x' must come strictly before corresponding `y' in the original list" constraint, then
05:48:54 <ski> > [(a0,a1) | (_,a0,r) <- mark "abcd", a1 <- r]
05:48:55 <lambdabot>   [('a','b'),('a','c'),('a','d'),('b','c'),('b','d'),('c','d')]
05:49:14 <bastl> i can download the complete list of all cabal files on hackage. Cabal-lib cab (of course) parse them. then one would have to build the dependency graph. not that complicated. But not my problem ATM :-)
05:49:28 <bastl> cab -> can
05:49:51 <benmachine> bastl: google hackage reverse dependencies
05:50:21 <ski> > mark "abcd" :: [(String,Char,String)]
05:50:22 <lambdabot>   [("",'a',"bcd"),("a",'b',"cd"),("ab",'c',"d"),("abc",'d',"")]
05:50:38 <ski> cybercobra : does the above help ?
05:50:43 <benmachine> bastl: okay it is not as easy to find as I remember it being
05:50:44 <bastl> benmachine: embarrasing, i didnt even think about googling before asking :-)
05:50:55 <benmachine> bastl: oh here we go http://bifunctor.homelinux.net/~roel/hackage/packages/archive/revdeps-list.html\
05:50:59 <benmachine> erm
05:51:01 <benmachine> http://bifunctor.homelinux.net/~roel/hackage/packages/archive/revdeps-list.html
05:51:22 <benmachine> bastl: don't worry about it, it's not always obvious what to look for
05:51:34 <bastl> this time it was.
05:51:41 <benmachine> if you insist :P
05:51:58 <bastl> but i'm happy there is a (good) solution :-)
05:52:01 <yitz> benmachine: it's just numbers, not the actual dependencies
05:52:01 <cybercobra> ski: very impressive wizardry, but I haven't the foggiest how that works. guess I'll just code it the 'primitive' way. I'm surprised something similar isn't in the std lib
05:52:13 <benmachine> but by "google" I didn't mean "do your own research and stop wasting our important time" I meant "I know there's something that uses these specific words but can't remember where it is right now"
05:52:19 <bastl> the numbers are links
05:53:02 <yitz> ah i see
05:53:10 <yitz> and this thing is dynamically updated?
05:53:24 <benmachine> yitz: I don't know, I think so
05:53:29 <ski> cybercobra : it is quite simple code, actually, i just throw in `MonadPlus m => ' for generality, you can replace `m ([a],a,[a])' with `[([a],a,[a])]'
05:53:36 <bastl> cool. but it's not obvious what version of a package is considered.
05:53:55 <yitz> it looks like something that is designed to be installed on the hackage site, but wasn't.
05:53:57 <ski> cybercobra : also, if you prefer, you may then use list comprehension syntax, instead of using `do' (and `mplus' is just (++)' and `mzero' is just `[]')
05:54:16 <ivanm> yay! my parser can now parse all the sample .gv files shipped with Graphviz (except the one that uses the Latin1 encoding)! \o/
05:54:18 <benmachine> yitz: it was a proposal I believe; probably still is, just not integrated yet
05:55:26 <bastl> useful when you want to learn how a specific lib is used in other places.
05:58:13 <ski> > [(al,a,ar) | (l,a,r) <- mark "abcd" , al <- l , ar <- r]
05:58:14 <lambdabot>   [('a','b','c'),('a','b','d'),('a','c','d'),('b','c','d')]
05:58:36 <ski> > [[al,a,ar] | (l,a,r) <- mark "abcde" , al <- l , ar <- r]
05:58:37 <lambdabot>   ["abc","abd","abe","acd","ace","bcd","bce","ade","bde","cde"]
05:58:37 <ski> &c.
05:58:45 <bastl> thanks.
06:00:37 <cybercobra> ski: ended up going with: pairings (x:xs) = [(x,y) | y <- xs] ++ (pairings xs); pairings [] = []
06:03:24 <idnar> @src inits
06:03:24 <lambdabot> inits []     =  [[]]
06:03:24 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
06:03:40 <idnar> > inits [1,2,3]
06:03:41 <lambdabot>   [[],[1],[1,2],[1,2,3]]
06:04:05 <idnar> does reverse . inits have a name?
06:04:27 <ski> cybercobra : works as well :) (you don't need the brackets around the recursive call, though)
06:04:36 <Jafet> I would just call it reverse.inits
06:04:47 <int-e> > let pairings xs = [(x, y) | (x:ys) <- tails xs, y <- ys] in parings [1,2,3,4]
06:04:48 <lambdabot>   Not in scope: `parings'
06:04:54 <int-e> > let pairings xs = [(x, y) | (x:ys) <- tails xs, y <- ys] in pairings [1,2,3,4]
06:04:55 <lambdabot>   [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
06:05:02 <Jafet> -XHomophones
06:05:33 <cybercobra> ski: call me paranoid :)
06:06:08 <ski> you, sir, are a paranoid !
06:06:46 <yitz> {-# LANGUAGE: VegetableSkins #-}
06:07:16 * ski just ate a bowl of vegetable soup ..
06:07:49 <cybercobra> yitz: ???
06:08:14 <yitz> cybercobra: parings
06:09:53 <cybercobra> yitz: http://tvtropes.org/pmwiki/pmwiki.php/Main/IncrediblyLamePun
06:11:16 * ski . o O ( "pares" @ <http://srfi.schemers.org/srfi-9/srfi-9.html> )
06:18:13 <yitz> cybercobra: lambdabot needs a @rimshot command
06:21:11 <cybercobra> @let rimshot = putStrLn "(Rimshot!)"
06:21:12 <lambdabot>  Defined.
06:21:17 <cybercobra> > rimshot
06:21:18 <lambdabot>   <IO ()>
06:21:23 <cybercobra> boo
06:21:50 <dmwit> > var "(Rimshot!)"
06:21:50 <lambdabot>   (Rimshot!)
06:22:16 <cybercobra> dmwit: nicely done
06:23:52 <Jafet> @src var
06:23:52 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
06:23:56 <Jafet> @type var
06:23:57 <lambdabot> forall a. String -> Sym a
06:24:17 <dmwit> ?where simplereflect
06:24:17 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
06:24:17 <stevenmarky> What's a Sym?
06:24:29 <yitz> > text "(Rimshot!)"
06:24:30 <lambdabot>   (Rimshot!)
06:24:37 * dmwit answers questions before they're asked
06:24:44 <dmwit> > text "\x93"
06:24:54 <dmwit> hm =)
06:25:03 <dmwit> > var "\x93"
06:25:09 <yitz> oh oh
06:25:17 <yitz> @botsnack
06:25:17 <lambdabot> :)
06:25:24 <ski> > text "a\x93b"
06:25:25 <lambdabot>   aà¤»
06:25:31 <ski> hrm
06:25:38 <dmwit> > text "a\x93\&b"
06:25:39 <lambdabot>   ab
06:25:52 <dmwit> \bot seems to filter out objectionable characters. =)
06:27:22 <npouillard> Does any one knows how to use the new cabal feature "Allow exes to depend on the lib within the same package" ?
06:27:26 <Twey> What is Â“?
06:28:14 <yitz> @slap rim
06:28:14 * lambdabot activates her slap-o-matic...
06:28:28 <Jafet> Twey, SET TRANSIT STATE
06:28:34 <Jafet> Maybe it's a transmogrifier.
06:28:37 <Twey> Interesting
06:28:38 <Twey> Haha
06:31:06 <kingping> $ is a right-associative application, thus  vertex $ Vertex3 x1 y1 z1 and  vertex (Vertex3 x1 y1 z1) are identical, right?
06:31:20 <Botje> yeah
06:31:22 <kingping> It's the only its purpose?
06:31:30 <Twey> That's got nothing to do with its associativity, but yes
06:31:56 <kingping> "Application operator. This operator is redundant, since ordinary application (f x) means the same as (f $ x). However, $ has low, right-associative binding precedence, so it sometimes allows parentheses to be omitted; for example" from Prelude.html
06:31:58 <ski> > map ($ 4) [(+3),(*3),(^3)]
06:31:59 <lambdabot>   [7,12,64]
06:32:18 <fasta> kingping, $ does no computation.
06:32:24 <kingping> hmm, $ 4
06:32:32 <Cale> kingping: The fact that it's right-associative has no effect on the expression you gave
06:32:38 <benmachine> fasta: well, it does as much as id does
06:32:40 <Twey> vertex $ Vertex3 x1 y1 $ z1 -- its associativity allows this (as vertex (Vertex3 x1 y1 (z1)))
06:32:57 <ski> (s/as //)
06:32:59 <Cale> Actually, I feel that the associativity chosen for ($) is the wrong one
06:33:03 <kingping> I see. Okay.
06:33:15 * ski agrees with Cale
06:33:17 <fasta> benmachine, hmm, ok, bad choice of words.
06:33:35 <Twey> If it were left-associative, that would be parsed the other way (as ((vertex) Vertex3 x1 y1) z1)
06:33:39 <Jafet> Cale, import the APL application operator for that
06:33:44 <ski> at least if you compare with `($!)', which definitely should have been left-associative
06:33:47 <Jafet> (I think...)
06:34:00 <benmachine> I remember someone once suggesting â‚¬ as a left-associative $ >_>
06:34:02 <ski> @src foldl'
06:34:03 <Cale> kingping: Whenever you have something like  f $ g $ h $ x, consider replacing it with f . g . h $ x
06:34:03 <lambdabot> foldl' f a []     = a
06:34:03 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
06:34:13 <ski> the recursive clause here can be written as
06:34:18 <yitz> benmachine: haha
06:34:19 <Twey> This would be more useful, as the right-associative one can be expressed using a combination of (.) and a single ($): vertex . Vertex3 x1 y1 $ z1
06:34:36 <ski>   foldl' f a (x:xs) = (foldl' f $! f a x) xs
06:34:44 <yitz> Twey: the reverse is also true, which is what we do now
06:34:47 <kingping> I think it's hard to me atm to remember that all :)
06:34:51 <ski> if both `$!' and `$' were left-associative, we could instead write
06:34:55 <Twey> yitz: What's that?
06:34:56 <ski>   foldl' f a (x:xs) = foldl' f $! f a x $ xs
06:35:01 <ski> which feels more natural
06:35:05 <Cale> Composition (.) is an operator which is actually associative, and so you effectively get more subexpressions than you otherwise would, making the code easier to break down into small parts and understand, or refactor.
06:35:05 <yitz> Twey: oh, that's what you meant I guess
06:35:25 <Cale> (f . g) x = f (g x)
06:35:30 <Twey> yitz: There are cases that could be expressed using right-associative ($) that can't be written without parentheses as is
06:35:35 <dmwit> kingping: The short and lolng of it is that ($) was created to avoid parentheses, but other uses and flaws were discovered later.
06:35:51 <dmwit> -lolng +long
06:35:52 <Twey> Er, using left-associative ($)
06:36:02 <SamB_XP> and when we finally succeed in getting root on the machines hosting the Haskell Report *and* base, your code will be less disrupted
06:36:05 * yitz is used to $ the way it is, and gets along just fine with it
06:36:08 <kingping> dmwit: Flaws? So it's recommended to avoid its usage?
06:36:23 <Botje> map f = zipWith ($) $ repeat f
06:36:29 <fasta> kingping, that is an opinion only some people have.
06:36:30 <dmwit> kingping: Nope. It's great where it's useful... go ahead and use it!
06:36:37 <Twey> Botje: map f = zipWith id $ repeat f
06:36:42 <kingping> okay
06:36:45 <Twey> Botje: map = zipWith id . repeat
06:36:47 <dmwit> kingping: It's just that it could be *more* useful if it were defined slightly differently. =)
06:36:49 <yitz> > (+) 3 `id` (*) 5 `id` 9
06:36:50 <lambdabot>   No instance for (GHC.Num.Num (t -> t))
06:36:50 <lambdabot>    arising from the literal `3' at <...
06:36:52 <Botje> heh, right
06:36:57 <ski> Twey : yes .. but how common are they, compared to how common left-associated use of `$' (and also `$!') would be, if they were left-associative ?
06:37:07 <voker57> @src map
06:37:07 <lambdabot> map _ []     = []
06:37:07 <lambdabot> map f (x:xs) = f x : map f xs
06:37:10 <Botje> but mine has more dollar signs :P
06:37:20 <benmachine> yitz: `id` is probably infixl 9
06:37:21 <SamB_XP> ski: yeah, it's all about $!
06:37:26 <yitz> @info id
06:37:26 <lambdabot> id
06:37:33 <benmachine> @info doesn't exist
06:37:33 <lambdabot> doesn't exist
06:37:37 <Katiebug> hiya
06:37:37 <SamB_XP> yitz: that's @id
06:37:47 <benmachine> it's just @undo and silly spelling correction
06:37:53 <Twey> ski: I'm confused.  Of course they're equally common, which is not particularly common, but since it's entirely redundant as it is right now, we might as well cover them anyway
06:37:53 <SamB_XP> or that
06:37:59 <dmwit> ?undo exists though
06:38:00 <Katiebug> I'm wondering what the proper way is to define a constant in a .hs script
06:38:00 <SamB_XP> @undo
06:38:00 <lambdabot> exists though
06:38:00 <lambdabot> ()
06:38:09 <Katiebug> every time I try it tells me parse error (possibly incorrect indentation)
06:38:10 <SamB_XP> hhahahaha
06:38:16 <dmwit> Katiebug: "x = 3"
06:38:18 <Twey> It might be interesting to add a switch to GHC to switch the associativity of ($) and see how much code breaks
06:38:24 <ski> SamB_XP : there's also `foo a $ bar b (f c) $ baz (g d e) f' as opposed to `foo a (bar b (f c)) (baz (g d e) f)'
06:38:41 <voker57> const is not for constants, in case you were trying it
06:38:43 <Twey> Katiebug: someConstant = foo
06:38:45 <yitz> ghci doesn't report any special infix declaration for id
06:38:55 <benmachine> yitz: yeah, infixl 9 is the default
06:39:28 <Twey> Katiebug: Everything's a constant â˜º
06:39:37 <benmachine> @info do { x; y; }
06:39:37 <lambdabot> x >> y
06:39:38 <dmwit> Katiebug: It's hard to say how to fix it without seeing your code, though...
06:39:39 <dmwit> ?hpaste
06:39:39 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
06:40:00 <cybercobra> how do I constrain (Ord => a) in:   data PairState a = PairState (Set.Set (a,a)) (Set.Set a)  ?
06:40:12 <dmwit> > do { []; []; } -- but, benmachine, be wary of ?undo
06:40:13 <lambdabot>   []
06:40:16 <dmwit> err
06:40:19 <dmwit> huh
06:40:20 <yitz> dmwit: hpaste.org is down, and moonpatio is spammed
06:40:41 <Katiebug> ahh, I was using let
06:40:43 <Katiebug> that's why
06:40:48 <ski> yitz : are you sure `hpaste.org' is down ?
06:40:50 <Katiebug> without let it works fine
06:40:51 <dmwit> Turns out benmachine need not be wary of ?undo, but dmwit should be wary of his Haskell knowledge.
06:40:52 <yitz> and mmorrow hasn't been seen for 3 months
06:41:04 <yitz> ski: was a few hours ago anyway
06:41:11 <EvanR-work> hpaste has been spotty
06:41:11 <dmwit> hpaste WFM
06:41:25 <yitz> ah it came back, good
06:41:33 <benmachine> dmwit: :) I can be paranoid anyway if you like
06:41:33 <yitz> @where hpaste
06:41:33 <lambdabot> http://hpaste.org/
06:41:39 <ski> Katiebug : `let' is to be used *inside* larger expressions (and also in list comprehensions and in `do'-blocks) .. also GHCi uses it to allow definitions of variables, interactively
06:41:52 <Katiebug> I see. Thanks :)
06:42:00 <benmachine> ghci is a bit odd, it's not quite like irb or python
06:42:04 <ski> (Katiebug : since the things you type into GHCi acts mostly like commands that you enter into a `do'-block)
06:42:17 <ski> Katiebug : on the "top-level" of a module, though, you don't use `let'
06:42:26 <dv-> you can use where though
06:42:31 <dv-> module Main where x = 3
06:42:39 <benmachine> dv-: yes but only one
06:42:46 <ski> well, that `where' attaches to the `module' declaration
06:42:48 <benmachine> most people see it as part of the module statement
06:42:58 * ski was talking about the "body" of a module declaration
06:43:00 <kingping> Wow map ($ 4) [(+3), (*3), (^3)] looks really cool. In Erlang for example I'd write it like map(fun(Y) -> Y(4) end, [fun(X)->X+3 end, fun(X)->X*3 end, fun(X)->pow(X,3) end]).
06:43:10 <Twey> kingping: Ouch
06:43:29 <EvanR-work> function(x){return x+3;}
06:43:38 <ski> kingping : operator sections and partial application can yield somewhat more compact and readable code, yes
06:43:40 <Twey> That's almost as bad as Javascript
06:43:46 <kingping> It's called currying afaik.
06:43:53 <Twey> EvanR-work: Yeah :Ã¾
06:44:01 <EvanR-work> Twey: its also php now ;)
06:44:18 <EvanR-work> function($x){return $x+3;}
06:44:20 <ski> kingping : no, currying is going from a function that takes a tuple as argument to a function that takes the arguments "one-by-one" (curriedly)
06:44:33 <Twey> [function(n) { return n + 3; }, function(n) { return n * 3; }, function(n) { return n ^ 3; }].map(function(f) { return f(n); });
06:44:59 <ski> @type \(x,xs) -> xs !! length x
06:45:00 <lambdabot> forall a a1. ([a1], [a]) -> a
06:45:05 <EvanR-work> function($x) using ($lexical_var){ return $x * $lexical_var; }
06:45:06 <ski> @type curry (\(x,xs) -> xs !! length x)
06:45:06 <benmachine> * return f(4)
06:45:07 <lambdabot> forall a a1. [a1] -> [a] -> a
06:45:18 <EvanR-work> err s/using/use/
06:45:35 <Twey> EvanR-work: Yummy.
06:45:43 <cybercobra> how do I constrain (Ord => a) in:  data PairState a = PairState (Set.Set (a,a)) (Set.Set a)  ?
06:45:52 <quicksilver> cybercobra: don't
06:45:53 <benmachine> <generic anti-PHP sentiment>
06:45:57 <ski> cybercobra : the simple answer : don't
06:46:05 <benmachine> cybercobra: you can but it doesn't help
06:46:08 <quicksilver> cybercobra: the constraint will come automatically on the functions which need it and that's probably fine.
06:46:25 <ski> cybercobra : instead constrain each place where you use `PairState' (and you actually want/need the constraint)
06:47:17 <cybercobra> (whacks forehead, looks at clock; gets energy drink)
06:47:33 <ski> cybercobra : the complex answer, use the GADTs syntax for defining `PairState' .. arguably putting constraints on a datatype defined the normal way is buggy, while you can do a more sane variant with GADTs
06:47:47 <ski>   data PairState a
06:47:49 <ski>     where
06:48:03 <benmachine> (interestingly, you don't need Ord to build singleton sets... toList (singleton id) works fine)
06:48:08 <ski>     PairState :: Ord => (Set.Set (a,a)) -> (Set.Set a) -> PairState a
06:48:14 <benmachine> ORd a
06:48:16 <quicksilver> benmachine: right, nor empty ones ;)
06:49:07 <ski> (however, as someone (roconnor ?) noticed some week(?) ago here, this work-around doesn't apply to a type with no constructors)
06:49:34 <ski> (s/doesn't apply/can't be applied/)
06:49:49 <EvanR-work> how do i shorten this
06:50:03 <ski> "ths"
06:50:04 <EvanR-work> do x <- something; seq x (return x);
06:50:47 <benmachine> @. pl undo do x <- something; seq x (return x);
06:50:47 <lambdabot> ap seq return =<< something
06:50:48 <ski>   something >>= ap seq return
06:51:04 <Twey> something >>= seq `ap` return
06:51:05 <quicksilver> or "something >>= (return $!)"
06:51:10 <quicksilver> if you like the $! idiom
06:51:11 <Twey> Damn you people!  :Ã¾
06:51:20 <ski> Twey :P
06:51:25 * benmachine likes the $! idiom
06:51:26 <EvanR-work> $! eh
06:51:35 <Twey> Yeah, the $! is nice too
06:51:45 <Twey> something >>= ($!) return
06:51:52 <ski> hm `(return $!) =<< something' .. ty quicksilver
06:51:59 <Twey> Feels like it should be shortenable
06:52:04 <hpc> :t ($!)
06:52:05 <lambdabot> forall a b. (a -> b) -> a -> b
06:52:21 <hpc> what's $!?
06:52:22 <Twey> hpc: f $! x = x `seq` f x
06:52:22 <ski> Twey : i don't think so ..
06:52:28 <ski> @src $!
06:52:28 <lambdabot> f $! x = x `seq` f x
06:52:33 <Twey> ski: Yeah, I don't think so, either
06:52:39 <byorgey> hpc: strict application
06:52:43 <Twey> Just the combination of return and bind makes me think it should be a fmap
06:52:45 <zygoloid> =<< or join is surprisingly essential; you can't do it with fmap
06:52:46 <hpc> nifty
06:53:12 <Twey> zygoloid: Yeah, but the usual combination of those features I see is â€˜a >>= return . fâ€™, which is of course â€˜fmap f aâ€™
06:53:12 <benmachine> but it's not actually a combination of return and bind, because ($!) is applied to return first
06:53:24 <Twey> Yeah
06:53:50 <zygoloid> @type (join . return $!)
06:53:51 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
06:54:02 <EvanR-work> w
06:54:05 <EvanR-work> oops
06:54:29 <ski> zygoloid : that's not the same thing ..
06:55:04 <ski> @type return `asTypeIn` \return -> (join . return $!)
06:55:05 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m (m a)
06:55:24 <ski> the `return' is not applied to a value of type `a', but of type `m a', in there
06:56:04 <Twey> Is that the comonad operation?
06:56:18 <ski> nope
06:56:29 <ski> @type asTypeIn
06:56:30 <lambdabot> forall a b. a -> (a -> b) -> a
06:56:57 <ski>   asTypeIn a ab = a
06:56:59 <ski>     where
06:57:05 <ski>     b = ab a
06:58:43 <zygoloid> @type join . liftM (return $!)
06:58:44 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m a1
06:59:40 <ski> @type (join Prelude.. return $!)
06:59:41 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
07:00:01 <ski> @type return `asTypeIn` \return -> (join . liftM (return $!))
07:00:02 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
07:00:05 <ski> *nod*
07:01:06 <zygoloid> ski: are there any monads where those two are different?
07:01:10 <ski> (though `join . liftM (return $!)' is of course the same as `(>>= (return $!))' .. and we're back full circle)
07:02:16 <cybercobra> is there a "none" or just "not any" ?
07:02:20 <ski> > isJust ((join . return $!) (Just undefined))
07:02:21 <ski> > isJust ((join . liftM (return $!)) (Just undefined))
07:02:22 <lambdabot>   True
07:02:22 <lambdabot>   *Exception: Prelude.undefined
07:02:40 <ski> > isJust ((return $!) =<< Just undefined)
07:02:41 <lambdabot>   *Exception: Prelude.undefined
07:02:49 <ski> zygoloid : ^ there you go
07:02:52 <cybercobra> erm, any as in the boolean function
07:02:57 <Katiebug> Is it possible to define a function for a multiple input values on a single line? For example, is there any way to do delta(1 or 2,b or c)=2 or do I have to just put each combination on its own line?
07:03:06 <ski> cybercobra : hm, not that i remember
07:03:12 <Katiebug> err, should be 'b' or 'c'
07:03:12 <cybercobra> ski: righto
07:03:51 <ski> Katiebug : sorry, no or-patterns in Haskell :/ (O'Caml has them !)
07:03:59 <Jafet> > and $ map even [2, 4, 6, 10, 14] -- cybercobra
07:04:00 <lambdabot>   True
07:04:01 <Katiebug> ah, damn
07:04:02 <Katiebug> thanks
07:04:19 <ski> Katiebug : in some cases, you can use guards (or pattern guards), to get similar effect, though
07:04:46 <Katiebug> yeah, that would probably take just as long to write out though for this particular function :/
07:04:50 <ski> @src all
07:04:50 <lambdabot> all p =  and . map p
07:04:53 <Katiebug> thanks anyway though :)
07:05:55 <yottis> :O what's that delta(1 or 2,b or  c)=2
07:06:06 <yottis> a partial function for those argument value or what?
07:06:33 <ski> yottis : `delta (1,B) = ...; delta (2,B) = ...; delta (1,C) = ...; delta (2,C) = ...'
07:06:46 <Katiebug> what ski said :3
07:07:06 <yottis> i'm just not familiar at all with the concept
07:07:12 <ski> (with the same body for all of those clause (maybe the `B' and `C' patterns actually bind variables (the same set in both), and those variables are used in the body, too))
07:07:13 <Katiebug> except I meant to say 'b' and 'c' not b and c
07:07:41 <yottis> you mean 'b' or 'c'?-)
07:08:12 <ski> yottis : see <http://rosettacode.org/wiki/Pattern_matching#OCaml> (compare with Haskell version just above)
07:08:34 <zygoloid> > let delta (oneOf [1,2] -> True, oneOf ['B','C'] -> True) = 2; delta _ = 3 in delta (2,'B')
07:08:35 <lambdabot>   2
07:08:38 <yitz> Katiebug: sometimes you can use lists to make it look neater. but of course, then they have to do a tiny bit of computation at runtime, if that matters.
07:08:40 <zygoloid> ^^ view patterns can do that
07:08:58 <ski> Katiebug : what do you mean by matching on both `b' and `c' ? is one of these a variable name ?
07:09:09 <Katiebug> no, they're both just characters
07:09:43 <ski> Katiebug : there is no character which matches two different `b' and `c' characters at the same time ..
07:09:58 <yitz> Katiebug: how many cases do you need to write out?
07:09:59 <ski> > let xs0 @ (x:xs) = "abcd" in (xs0,x,xs)
07:10:00 <lambdabot>   ("abcd",'a',"bcd")
07:10:22 <Katiebug> yitz: 22 in total
07:10:46 <yitz> Katiebug: hmm. not the end of the world, but, yuck.
07:10:47 <Katiebug> ski: It just needs to either match 'b' or 'c'
07:11:11 <ski> you said
07:11:11 <Katiebug> yitz: I'm just concerned that the length will blow up if I try anything more complex
07:11:12 <ski> <Katiebug> except I meant to say 'b' and 'c' not b and c
07:11:20 <ski> note the "and", rather than "or" :)
07:11:22 <Katiebug> and when I said that I meant or not and
07:11:31 <ski> ok, all is well
07:12:06 <yitz> Katiebug: yeah that's a concern. but if so, then it does make sense to build in some computation.
07:12:40 <ski> > let delta (x,y) | oneOf [1,2] x && oneOf ['B','C'] y = 2; delta _ = 3 in delta (2,'B')
07:12:41 <lambdabot>   2
07:13:29 <ski> > let delta (uncurry (&&) . (oneOf [1,2] *** oneOf ['B','C']) -> True) = 2; delta _ = 3 in delta (2,'B')
07:13:30 <lambdabot>   2
07:14:34 <yitz> ski: then again, you could just write out the cases :)
07:14:48 <ski> yitz : in my case, sure :)
07:15:02 <ski> in Katiebug's case, maybe that will explode the number of cases
07:15:29 <yitz> ski: but i wouldn't use that in Katiebug's case either i think
07:15:41 <ski> yitz : or-patterns ? why not ?
07:16:07 <zygoloid> Katiebug seems to be stuck in the unfortunate middle ground of complexity between pattern matching and a parser combinator library
07:17:56 <Katiebug> well basically what I'm doing is writing out the delta-function for a deterministic finite automota
07:17:56 <zygoloid> > let delta (1,y) = delta'12 y; delta (2,y) = delta'12 y; delta'12 'a' = delta'12'ab; delta'12 'b' = delta'12'ab; delta'12'ab = 2 in delta (2,'b')
07:17:57 <lambdabot>   2
07:18:12 <Katiebug> in this case it's a relatively simple one with 7 states and a language of 3 characters
07:18:28 <yitz> ski: f x y | x `elem` Xs && y `elem` Ys = ...
07:18:29 <Katiebug> so, 21 possible combinations for the delta function
07:18:34 <Katiebug> plus delta _
07:19:12 <chot> hi
07:19:27 <yitz> hi chot
07:19:49 <chot> if i have a data MyData = .. and i want to "extend" it with another constructor.. is that possible and what is it called in that case?
07:20:00 <ski> zygoloid : .. yes i know :)
07:20:35 <ski> (zygoloid : it is still irritating, if you have to repeat most of a pattern, with only some small parts varying)
07:20:35 <yitz> chot: you mean in a different module?
07:20:43 <chot> yits: yes
07:20:48 <zygoloid> Katiebug: you could use a lookup table, [([(State, Char)], State)]. if that's too slow a bit of TH could be used to generate better code
07:20:58 <ski> @type oneOf
07:20:59 <lambdabot> forall a. (Eq a) => [a] -> a -> Bool
07:21:01 <Katiebug> TH?
07:21:02 <ski> @type elem
07:21:03 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
07:21:13 <ski> `oneOf' is just `flip elem', right ?
07:21:14 <yitz> chot: if you can't change the original, you have to wrap it in a different type.
07:21:17 <zygoloid> Katiebug: template haskell (running haskell at compile-time to generate haskell)
07:21:21 <zygoloid> ski: right
07:21:25 <Katiebug> oh
07:21:29 <chot> yitz: alright :/ thanx
07:21:33 <Jafet> Psst, that's called an assoc list
07:21:34 * ski is not sure he's seen `oneOf' before
07:21:45 <quicksilver> I definitely haven't.
07:21:48 <Jafet> @src oneOf
07:21:48 <lambdabot> Source not found. Maybe if you used more than just two fingers...
07:21:59 <zygoloid> ski: i @let it to make an earlier example smaller
07:22:01 <yitz> @hoogle oneOf
07:22:02 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
07:22:02 <lambdabot> Text.ParserCombinators.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
07:22:02 <lambdabot> Test.QuickCheck oneof :: [Gen a] -> Gen a
07:22:02 <Jafet> I use one hand, darling.
07:22:46 <ski> chot : sorry, Haskell doesn't have subtyping .. use "has-a", or factor, or phrase as a record instead of as a variant type  (if possible, in all cases)
07:23:32 <ski> (zygoloid : ah, that explains it :)
07:23:59 * ski seems to recall there being a `oneOf' for parsers and/or QC ..
07:24:13 <yitz> oneOf = flip elem, apparently.
07:25:13 <yitz> @type oneOf
07:25:14 <lambdabot> forall a. (Eq a) => [a] -> a -> Bool
07:25:45 <yitz> @djinn [a] -> a -> Bool
07:25:45 <lambdabot> Error: Undefined type []
07:26:08 <cybercobra> getting "not in scope" errors despite having:  data Event = Lecture EventInfo | Section EventInfo | Lab EventInfo; deriving (Show,Eq)
07:26:22 <ski> @djinn Eq a => Maybe a -> a -> Bool
07:26:22 <lambdabot> f a =
07:26:22 <lambdabot>     case a of
07:26:22 <lambdabot>     Nothing -> \ b -> b == b
07:26:22 <lambdabot>     Just c -> (==) c
07:26:31 <ski> .. interesting :)
07:27:06 <ski> cybercobra : remove the `;' before `deriving'
07:27:25 <cybercobra> ski: that was only for pasting purposes
07:27:41 <ski> well, it shouldn't have been there, even for pasting purposes :)
07:27:49 <ski> (just a space would have been fine)
07:28:26 <ski> cybercobra : i assume you've checked that you've imported the module (not qualified) ..
07:29:04 <ski> (.. in case you define `EventInfo' in a different module than the one you define `Event' in, i mean)
07:29:08 <ski> @where paste
07:29:08 <lambdabot> http://hpaste.org/new
07:29:11 <cybercobra> ski: that's my own code and it's all one file, so that's not it
07:29:24 <ski> please paste the code and the error
07:30:01 <hpaste>  . (cybercobra)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24895
07:30:40 <cybercobra> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24895#a24896
07:30:45 <ski> cybercobra : .. and the error ?
07:31:00 <cybercobra> (paste since revised)
07:31:01 <ski> (you can annotate the same paste by pressing the "add revision" link)
07:31:08 <ski> (:
07:31:18 <Katiebug> well thanks for everyon'es help
07:31:46 <quicksilver> cybercobra: you are using Lecture as a type when it is a constructor
07:32:59 <hpaste>  . (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24897
07:33:01 * ski was just about to say that he doesn't see `Lecture',&c. defined anywhere ..
07:33:26 <cybercobra> hm, this is awkward...
07:33:35 <Baughn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24897 <-- Anyone familiar with happstack-state feel like telling me where my hello, world is going wrong?
07:34:19 <ski> Katiebug : yw :)
07:35:26 <cybercobra> quicksilver: onward to typeclasses then
07:35:28 <Saizan_> Baughn: s/query q/query Q/ and s/update (s (succ cur))/update (S (succ cur))/ iirc
07:35:57 <bastl> dreixel: online ?
07:36:07 <quicksilver> cybercobra: incidentally your nested where clause is un-necessary and (to me) ugly.
07:36:17 <Baughn> Oh, so /that's/ where that duplicate type was coming from.. I called St S at first.
07:36:55 <samphippen|lapto> does haskell have the ability to evaluate infix and post fix strings that contain numbers and * + / -
07:37:17 <ski> cybercobra : in the `Final' case, rename it to `FinalExam' (or vice versa)
07:37:31 <jmcarthur> Baughn: yeah, happstack-state uses constructors so that it knows how to serialize them
07:37:51 <Saizan_> samphippen|lapto: if you write or find an already written interpreter
07:38:05 <Jafet> @vixen can Haskell evaluate infix and post fix strings that contain numbers and * + / - ?
07:38:05 <lambdabot> church is my favourite computer scientist.
07:38:09 <Baughn> jmcarthur: As opposed to using an instance of Serialize? Well, I suppose it'll make sense later.
07:38:18 <jmcarthur> Baughn: since it stores "changes" to your data rather than the data itself (aside from snapshots and such)
07:38:23 <dreixel> bastl: yes
07:38:26 <yitz> Jafet: try @faq
07:38:40 <Saizan_> Baughn: it's a primitive way to serialize functions
07:38:43 <jmcarthur> Baughn: it's happstack's way of pretending to serialize functions
07:38:43 <Jafet> @. vixen faw
07:38:43 <lambdabot> Plugin `compose' failed with: Unknown command: "faw"
07:38:45 <Jafet> @. vixen faq
07:38:46 <lambdabot> Ooh, functional programmers are so hot!
07:38:48 <bastl> dreixel: im trying to use zipper.
07:38:52 <Baughn> jmcarthur: That. If the "state" I'm storing is a pretty large tree, what do I need to.. oh...
07:38:57 <quicksilver> cybercobra: since your CollegeEvents all have the same internals (EventInfo) I would probably do this:
07:39:03 <Baughn> jmcarthur: It stores the /function call/? o_O
07:39:07 <Baughn> OKay, that's clever.
07:39:07 <jmcarthur> yes
07:39:13 <quicksilver> cybercobra: data CollegeEvent = CollegeEvent EventType EventInfo
07:39:15 <jmcarthur> that way it's fast
07:39:16 <bastl> I wanted to extract the current value of a location.
07:39:23 <Baughn> jmcarthur: I think I'm in love.
07:39:27 <quicksilver> cybercobra: data EventType = Lecture | Section | Lab
07:39:30 <ski> cybercobra : i would write your `where's at the front of a new line (probably adding a new-line after it, too)
07:39:31 <jmcarthur> yeah i like it a lot
07:39:40 <bastl> the api suggests to use on for that.
07:40:09 <bastl> i tried something like (on id' mylocation) but didnt find a suitable id'
07:40:09 <dreixel> bastl: yes
07:40:31 <bastl> i setteld down to use pattern pmatching with the Loc constructor. but for that I had to make the constructor public.
07:40:38 <jmcarthur> Baughn: it has downsides though.
07:40:58 <dreixel> bastl: ah. I guess id' will be something like to
07:41:07 <Baughn> jmcarthur: Somewhat awkward functions, possibly slow startup.. I can see how that works.
07:41:13 <bastl> how should the current point of focus be extracted ?
07:41:22 <jmcarthur> Baughn: for example, make sure you don't serialize a function call that takes an unhashed password as a parameter, even if the function itself hashes it before putting it in the actual state
07:41:39 <bastl> Is it a problem to use pattern matching? Why is the constructor of Loc hidden ?
07:41:52 <Baughn> jmcarthur: Indeed. I already ran into Paul's blog on the subject.
07:41:56 <jmcarthur> ah
07:42:30 <jmcarthur> well i thought of it independently and at the time that blog post wasn't up... and all the authentication example code i had found at the time had made that exact mistake
07:42:32 <dreixel> bastl: no, you should not pattern match on the Loc. You should use the 'to' function to convert the representation to the value
07:43:15 <ski> (Baughn : "stores the /function call/" meaning ?)
07:43:25 <hpaste>  . (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24898
07:43:29 <bastl> hmm with "on to loc" i get "Inferred type is less polymorphic than expected Quantified type variable `xi' escapes" which is the same i got for my "id' " experiments.
07:44:20 <Baughn> ski: Creates a type per-function such that it can create a value of the type, and use its instance of (something) to rerun the function on-load.
07:44:38 <Baughn> ski: It's pretty clever, although it could use more syntactic support.
07:44:49 <narens> what is the best way to read and write a binary file of numbers?
07:45:01 <Baughn> narens: What kind of numbers?
07:45:06 <narens> ints and floats
07:45:24 <ski> cybercobra : i'd just rename `NonZeroPositiveInt' to `PositiveInt', since all positive numbers are non-zero :)
07:45:27 <Baughn> I think Data.Binary has something to read floats. Maybe.
07:45:38 <Twey> I'm sure it must
07:45:41 <narens> Baughn: k, i shall check
07:45:53 <ski> Baughn : oh, defunctionalization then ?
07:45:56 <Baughn> Ah, it does. I remember. There was commenting on the code being /really slow/.
07:46:25 <Baughn> ski: Arrowization, except it seems to not use arrows. Hmm.
07:46:39 <cybercobra> typeclass quandry (my it's an interesting night): http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24898
07:46:43 <ski> hm, where is docs on this ?
07:46:44 <narens> Baughn: excellent, just want i needed.
07:47:07 <Baughn> narens: Unless what you needed was speed. :P
07:47:19 <Baughn> narens: It may have already been fixed, mind. You can hope.
07:47:57 <narens> Baughn: alright... that may be an issue. I shall check it out. The only reason I want to write the file as binary is for compactness since the file is massive otherwise in tex
07:48:25 <dreixel> bastl: uhm, ok... give me 5 minutes
07:48:37 <quicksilver> cybercobra: well you can't do "Set.Set CollegeEvent" any more if CollegeEvent is a class
07:48:49 <ski> (cybercobra : btw, note that the `hpaste' bot already gave that link here in the channel :) .. however, if you have bothered to fill in name (and possibly title), it'd been easier to know quicker who was the author of that paste :)
07:48:58 <ski> (*hint* *hint*)
07:48:58 <bastl> dreixel: as long as you want ... TIA
07:49:08 <Baughn> narens: The /fast/ options involve unsafeCast from a byte array to a float array, that kind of thing, so it's no wonder nobody has felt the need yet.
07:49:28 <Baughn> It shouldn't be impossibly hard,though
07:49:48 <quicksilver> I"m not sure classes are the right answer; I made another suggestion a few minutes ago.
07:50:02 <ski> Baughn : do you know of docs explaining how that arrowization works in more detail ?
07:50:22 <Baughn> ski: I started working with happstack-state fifteen minutes ago. Ask jmcarthur. :P
07:50:27 <cybercobra> quicksilver: right, but that'd be less typesafe unless I put lots of EventType checks in
07:50:29 <ski> oh
07:50:37 <ski> jmcarthur : same question as ^ :)
07:50:38 <Saizan_> ski: it is a very selective defunctionalization, afaiu
07:50:38 <Baughn> ski: That it might be suspectible to arrowization is merely a guess, right now.
07:50:58 <ski> (Saizan_ : i was suspecting that ..)
07:51:04 <quicksilver> cybercobra: I'm not sure it would, btu I don't quite understand the whole picture.
07:51:32 <jmcarthur> arrowization?
07:51:48 <Saizan_> "update" and "get" are the apply functions, and they are extensible via typeclasses
07:52:04 <Baughn> jmcarthur: Control.Arrow exists specifically for the purpose of creating inspectable functions
07:52:21 <dreixel> bastl: well, ok, that won't work because |to| will return a different type based on the |ix|, and you can't do that, because |on| is universally quantified over the ix
07:52:31 <jmcarthur> Baughn: arr kind of messes up any chance of defunctionalization though :(
07:52:32 <zygoloid> i wonder if the hpaste bot can be made to send arbitrary IRC commands through carefully-crafted hpaste user names and subjects
07:53:03 <ski> jmcarthur : indeed :(
07:53:10 <ski> down with `arr' !
07:53:11 <bastl> how can I force it to use the same ix ?
07:53:16 <jmcarthur> i'm trying to fix this issue in alt-stdlib though :)
07:53:17 <dreixel> but something like f :: phi ix -> r ix -> String will work, for instance
07:53:19 <jmcarthur> very slowly
07:53:22 <narens> I also keep getting this message when I use cabal
07:53:32 <narens> Warning: Module `Prelude' is deprecated:
07:53:33 <narens>                You are using the old package `base' version 3.x.
07:53:33 <narens>                Future GHC versions will not support base version 3.x. You
07:53:33 <narens>                should update your code to use the new base version 4.x.
07:53:38 <bastl> dreixel: yes, i had something like that.
07:53:43 <cybercobra> quicksilver: I wish to prevent   c = Course { lectures = Set.singleton (CollegeEvent Lab someEventInfo)}  and the like
07:53:45 <dreixel> bastl: what do you want to do, exactly? Have you taken a look at ASTZipper.hs and ASTEditor.hs?
07:53:52 <Saizan_> well, it's more like arr let you use normal functions inside your special expressions, though the magic will only apply to your primitives :)
07:54:00 <jmcarthur> ski: in alt-stdlib, there isn't even an Arrow class anymore because i've divided and generalized it so much
07:54:07 <bastl> dreixel: insert a subtree at a location
07:54:31 <ski> jmcarthur : like `Category' and subclasses thereof, i expect ? :)
07:54:43 <dreixel> bastl: ok, for that you need |update|, though
07:54:44 <jmcarthur> ski: well, there is Category, yes
07:54:44 <Saizan_> narens: if it's relative to your package, put an upper bound to your base dependency in the .cabal file, otherwise ignore
07:54:51 <quicksilver> cybercobra: in my design that would just be Course { lectures = Set.singleton (someEventInfo) }
07:54:53 <bastl> yes
07:54:57 <quicksilver> cybercobra: the Lecture part is implicit.
07:55:19 <quicksilver> the API would make sure it put things in the right places of curse
07:55:25 <bastl> but the subtree is a location itself, so i can append the "old" subtree at the end of the new one ...
07:55:52 <ski> jmcarthur : but would you know where to find relevant docs on how this "selective defunctionalization" works in `happstack-state' ?
07:56:07 <Saizan_> jmcarthur, ski: i suspect that Arrow a is entirely equivalent to Category a + Applicative (a e) + some coherency laws
07:56:17 <bastl> then i need to extract the focus of the subtree aka location to insert
07:56:23 <jmcarthur> Saizan_: you can implement arr with Functor and Category, actually
07:56:42 <Saizan_> jmcarthur: yeah, but not (&&&)
07:56:45 <jmcarthur> Saizan_: as for the other things, i'm expressing them as Bifunctor operations on a category
07:56:47 <bastl> well, I get along with the patternmatching atm, but the "right" way to do it would be better ...
07:57:13 <dreixel> bastl: ah. well, actually I think that might be better... because the other way would involve converting back and forth unnecessarily, I think...
07:57:57 <jmcarthur> Saizan_: for example: (***) :: Bifunctor (~>) (&) => a ~> c  ->  b ~> d  ->  (a & b) ~> (c & d)
07:58:05 <bastl> now im confused what is better?
07:58:22 <jmcarthur> ski: i don't know of any docs aside from the source code
07:58:44 <Saizan_> jmcarthur: makes sense, how is Bifunctor defined?
07:58:50 <ski> jmcarthur : ok
07:59:15 <Saizan_> jmcarthur: ah, (***) is the method for Bifunctor (~>) (&) ?
07:59:15 <dreixel> bastl: what you are doing. I think it's like having some new, internal function |update' :: Loc phi I0 ix -> Loc phi I0 ix -> Loc phi I0 ix|, no?
07:59:27 <bastl> right.
07:59:28 <ski> jmcarthur : do you have things like `fstA :: Product (~>) p => p a b ~>', &c. too ?
07:59:36 <jmcarthur> Saizan_: bimap is the method for it, and (***) is just another name for it
07:59:53 <bastl> ah, so because ints "internal" i can use Patternmatching on the Loc constructor
07:59:56 <bastl> i see
08:00:05 <bastl> ints = it's
08:00:06 <jmcarthur> ski: yup
08:00:10 <ski> er, `p a b ~> a' ..
08:00:16 <ski> jmcarthur : great :)
08:00:43 <dreixel> bastl: yes. though I think you can do it using |on| and |update| as well, but it might involve some unnecessary conversions...
08:00:50 <ski>   instance Product ASP Either  -- :)
08:00:52 <jmcarthur> i'm trying to work out equivalences between type classes to make sure i don't do anything redundant, right now
08:00:54 <bastl> ok
08:00:59 <bastl> thanks.
08:01:08 <ski> (where `ASP' standing for "asynchronous stream processor")
08:01:21 <Ke> sounds awesome
08:01:38 <dreixel> you're welcome
08:01:59 <jmcarthur> ski: another cool one:  class Bifunctor (~>) (&) => BifunctorFix (~>) (&) where bfix :: (a & c) ~> (b & c)  ->  a ~> b
08:02:35 <jmcarthur> ski: there's an instance BifunctorFix Hask Either, which i thought was kind of cool
08:03:47 <EvanR-work> @hoogle resolver
08:03:47 <lambdabot> No results found
08:04:00 <EvanR-work> @hoogle dns
08:04:00 <lambdabot> No results found
08:04:01 <jmcarthur> what'll be really fun is playing with categories other than Hask
08:04:45 <ski> dreixel : which zipper alternatively functional reference library is this ? `fclabels' ?
08:05:03 <Saizan_> jmcarthur: how does it work for Hask Either ?
08:05:28 <jmcarthur> Saizan_: keeps applying the function until the result is Left something
08:06:03 <Saizan_> jmcarthur: that's not really a "fix" combinator though, more like a doUntil
08:06:16 <ski> jmcarthur : that is basically `loop', yes ? (which is called "trace" in linear algebra, iiuc)
08:06:46 <jmcarthur> Saizan_: i thought about it a lot before deciding it qualified as a fix. it's not like the terminating condition is artificially imposed. it's natural to the type
08:07:05 <ski> jmcarthur : .. but having an instance of that for `Either' being `(&)' sounds interesting, yes
08:07:30 <Saizan_> jmcarthur: the looping you do is the non-conventional part, imo
08:07:44 <jmcarthur> i suppose
08:07:50 <ski> oh .. looping as opposed to fixing
08:07:53 <jmcarthur> i can't think of a better name... BifunctorLoop?
08:08:16 <jmcarthur> i guess that would be sensible
08:08:23 <ski> `loop' in `ArrowLoop' is supposed to be a kind of `fix' operation (afaiu), not a looping operation (in the iteration sense)
08:08:29 <jmcarthur> yeah
08:08:40 <ski> i.e. the effects of the arrow is only done once
08:08:41 <EvanR-work> i need a mx resolver that is not ADNS
08:08:44 <Saizan_> yeah, so they have mudded the waters there :\
08:08:45 <EvanR-work> because its broken
08:08:51 <EvanR-work> like all the other ffi libs i used
08:09:07 <Saizan_> EvanR-work: write one?
08:09:07 <jmcarthur> it would be a shame to leave sum types out, though. it seems like it could be useful and it makes perfect sense to me that such an instance should be defined
08:09:15 <EvanR-work> not economically viable
08:09:40 <Saizan_> magically materialize one?
08:09:40 <jmcarthur> if i could think of another name i would definitely feel better about it
08:10:18 <EvanR-work> Network.DNS
08:10:25 <EvanR-work> @hoogle Network.DNS
08:10:25 <lambdabot> No results found
08:10:45 <EvanR-work> yes
08:10:53 <Saizan_> jmcarthur: i was thinking of how/if i could define the difference formally
08:11:44 <EvanR-work> warning module prelude is deprecated?
08:12:06 <contrafunktal> the prelude from base-3 will be going away
08:12:15 <Saizan_> base-3 will be going away
08:12:23 <copumpkin> preflex: seen pigworker
08:12:23 <preflex>  Sorry, I haven't seen pigworker
08:12:27 <contrafunktal> though I don't believe the Prelude itself is changed between versions
08:16:55 <jmcarthur> Saizan_: maybe it should be called "feeback" or something
08:16:59 <jmcarthur> *feedback
08:17:27 <EvanR-work> gah
08:17:31 <jmcarthur> although that seems to be mutually exclusive with a fixpoint
08:17:35 <EvanR-work> Network.DNS, deprecated true
08:17:36 <EvanR-work> :S
08:17:41 <EvanR-work> stability provisional
08:17:50 <dreixel> ski: I don't think that has anything to do with the zipper...
08:17:50 <jmcarthur> maybe these just shouldn't be combined into one class :\
08:18:13 <ski> dreixel : sorry, i was talking about several unrelated things at the same time :)
08:18:32 <ski> dreixel : i just wondered what library you and bastl were talking about
08:18:41 <jmcarthur> eh, feedback isn't mutually exclusive from fixpoint, maybe
08:19:00 <jmcarthur> at least for this bifunctor version of fixpoint
08:19:01 <dreixel> ski: ah! http://hackage.haskell.org/package/zipper
08:19:11 <ski> jmcarthur : the Right question to ask is what laws it should support, imo
08:19:15 <jmcarthur> which i'm kind of doubting is actually fixpoint anyway, even without Either
08:19:16 <ski> dreixel : ty
08:19:40 <ski> (dreixel : are you its developer ?)
08:19:44 <jmcarthur> a fixpoint of a function f is a value x such that f(x)=x. i don't see how ArrowLoop looks like this at all
08:19:55 <jmcarthur> things are blurring in my heard
08:19:58 <jmcarthur> *head
08:20:29 * ski can't seem to implement `(Either c a -> Either c b) -> (a -> b)' in an interesting, non-iterating way
08:20:55 <quicksilver> @djinn (Either c a -> Either c b) -> (a -> b)
08:20:56 <lambdabot> -- f cannot be realized.
08:21:04 <jmcarthur> ski: well, a fixpoint is basically iteration, too
08:21:12 <sbpaul> dumb question - how do i loop a string until it reaches a specified length?
08:21:20 <jmcarthur> the difference is that a fixpoint isn't going to impose some terminating condition like Either does
08:21:23 <ski> (quicksilver : obviously, it must be partial, in at least some cases (with total inputs))
08:21:26 <sbpaul> "blah" --> 'blahblahblah" for 12
08:21:35 <jmcarthur> ski: huh? why partial?
08:21:37 <Saizan_> jmcarthur: ArrowLoop builds (d,x) such that f(d,x) = (d,x) and then discards d
08:21:42 <sbpaul> arrowloop
08:21:47 <ski> jmcarthur : i'd rather say that iteration is a special kind of fixpoint :)
08:21:49 <jmcarthur> Saizan_: oh i see
08:21:55 <hpaste>  eqns have 1 arg but its type has none (cybercobra)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24899
08:22:06 <jmcarthur> ski: if that's the case then Either is perfectly valid here...
08:22:08 <copumpkin> ski: seems impossible?
08:22:19 <sbpaul> hmm
08:22:36 <quicksilver> ski: yes, sorry, I'm just following along at home, I hadn't quite caught up :)
08:22:38 <ski> jmcarthur : consider `foo (const (Left ())) ()' if that operation is called `foo'
08:22:52 * hackagebot open-pandoc 1.5.1.1 - Conversion between markup formats  http://hackage.haskell.org/package/open-pandoc-1.5.1.1 (PeterSimons)
08:23:12 <jmcarthur> ski: oh, right, duh
08:23:35 <jmcarthur> i was associating partiality with mere pattern match failure
08:23:43 <dreixel> ski: no, I guess I'm a bit of a maintainer now, but kosmikus is one of the main authors and the maintainer.
08:24:22 <Saizan_> > take 12 (cycle "blah") -- sbpaul
08:24:23 <lambdabot>   "blahblahblah"
08:24:29 <sbpaul> ohhis that it
08:24:30 <sbpaul> dayummm
08:24:44 <sbpaul> graci
08:25:26 <sbpaul> so let's try this
08:25:27 <ski> jmcarthur : more specifically, iteration over e.g. `a -> Either a b' is not a fixpoint on `a -> Either a b', but on `(a -> Either a b) -> (a -> Either a b)' :)
08:25:34 <sbpaul> @let loopd key pt = take (length pt) (cycle key)
08:25:35 <lambdabot>  Defined.
08:25:42 <sbpaul> @let prod2tups pt key = zip pt (loopd key pt)
08:25:43 <lambdabot>  Defined.
08:25:51 <jmcarthur> Saizan_: err, it can't work that way. f :: (a, c) -> (b, c)... f(d, x) can't be (d, x)
08:25:54 <sbpaul> > prod2tups "chaos" "mollywillneverbreakthis"
08:25:55 <lambdabot>   [('c','m'),('h','o'),('a','l'),('o','l'),('s','y')]
08:26:04 <sbpaul> > prod2tups "mollywillneverbreakthis" "chaos"
08:26:05 <lambdabot>   [('m','c'),('o','h'),('l','a'),('l','o'),('y','s'),('w','c'),('i','h'),('l'...
08:26:17 <ski> jmcarthur : iow, in the iteration, the function that is iterating is reached by a fixpoint (normally just a recursive function declaration, in Haskell ..)
08:26:54 <sbpaul> > ord a
08:26:55 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
08:26:55 <lambdabot>         against inferred type...
08:26:58 <Saizan_> jmcarthur: oh, doh, right, so the fixpoint part is only about x, i guess
08:27:03 <sbpaul> > ord 'a'
08:27:03 <jmcarthur> ski: ooh, insightful
08:27:04 <lambdabot>   97
08:27:23 <ski> (jmcarthur : i should probably have been more clear and s/partiality/nontermination/ ..)
08:27:26 <cybercobra> "The equation(s) for `nonZeroPositiveInt' have one argument, but its type `Maybe NonZeroPositiveInt' has none" ^see above hpaste^
08:27:37 <zygoloid> sbpaul: the 'take' is unnecessary. zip stops when either list ends.
08:27:49 <sbpaul> oh yeah
08:27:49 <jmcarthur> ski: oh no, that was clear, i just played an association game
08:27:58 <zygoloid> > length $ zip "ilikecheese" (cycle "badger")
08:27:59 <lambdabot>   11
08:29:42 <ski> jmcarthur : btw, `f :: (a, c) -> (b, c)... f(d, x)' can be `(d, x)', if you flip the order of the pairs in one of the two sides
08:29:43 <sbpaul> @let viGenereCrypt pt key = map (\(x,y)-> ord x + ord y - 194) (zip pt (cycle key))
08:29:44 <lambdabot>  Defined.
08:30:03 <sbpaul> > viGenereCrypt "hello" "zygoloid"
08:30:04 <lambdabot>   [32,28,17,25,25]
08:30:08 <sbpaul> nope
08:30:09 <sbpaul> @undefine
08:30:15 <ski> .. or am i confused ?
08:30:17 <ski> @type loop
08:30:18 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
08:30:26 <ski> @src (->) loop
08:30:27 <lambdabot> Source not found. You untyped fool!
08:30:31 <jmcarthur> ski: i don't understand "flip the order of the pairs in one of the two sides"
08:30:33 <ski> @slap lambdabot
08:30:33 * lambdabot slaps lambdabot with a slab of concrete
08:30:46 <sbpaul> @let viGenereCrypt pt key = (map (\(x,y)-> chr(ord x + ord y)) (zip pt (cycle key)))
08:30:47 <lambdabot>  Defined.
08:30:50 <copumpkin> there's only one meaningful way to write loop isn't there?
08:30:50 <sbpaul> > viGenereCrypt "hello" "zygoloid"
08:30:51 <lambdabot>   "\226\222\211\219\219"
08:31:01 <sbpaul> mmnn...
08:31:06 <sbpaul> @undefine
08:31:08 <copumpkin> loop for (->) that is
08:31:23 <ski> jmcarthur : sorry, i was probably miunderstanding/misreading what Saizan_ wrote
08:31:24 <sbpaul> > 235 mod 5
08:31:25 <lambdabot>   Ambiguous type variable `a' in the constraint:
08:31:25 <lambdabot>    `GHC.Real.Integral a'
08:31:25 <lambdabot>    ...
08:31:30 <sbpaul> crap
08:31:32 <copumpkin> > 235 `mod` 5
08:31:32 <lambdabot>   0
08:31:35 <sbpaul> oh yes
08:31:35 <cybercobra> @slap php
08:31:35 * lambdabot puts on her slapping gloves, and slaps php
08:31:36 <sbpaul> ` for infix
08:31:45 <Saizan_> ski: the point is that if loop works with that type signature, it shouldn't impose f(d,x) = (d,x) like i thought
08:31:58 <sbpaul> @let viGenereCrypt pt key = (map (\(x,y)-> chr((ord x + ord y) `mod` 26)) (zip pt (cycle key)))
08:31:59 <lambdabot>  Defined.
08:32:02 <sbpaul> > viGenereCrypt "hello" "zygoloid"
08:32:03 <lambdabot>   "\DC2\SO\ETX\v\v"
08:32:07 <sbpaul> crap
08:32:10 <sbpaul> now i'm confused
08:32:13 <ski> jmcarthur : `instance ArrowLoop (->) where loop ac_bc a = b where (b,c) = ac_bc (a,c)' is what `ArrowLoop (->)' is doing
08:32:24 <ski> (i think that's what Saizan_ was trying to talk about)
08:32:35 <zygoloid> > zipWith ((+) `on` fromEnum) "hello" (cycle "sbpaul")
08:32:35 <lambdabot>   [219,199,220,205,228]
08:32:57 <jmcarthur> ski: yeah i know what it does, but that doesn't satisfy the definition of fixpoint. at least not the one on wikipedia
08:32:57 <ski> copumpkin : afaik, yes
08:33:18 * sbpaul wracks brain
08:33:23 <ski> (copumpkin : if by "meaningful" you really mean "sensible" :)
08:33:25 <copumpkin> can that be proved? djinn won't touch it because it's circular
08:33:26 <copumpkin> yeah :)
08:33:43 <copumpkin> it seems pretty obvious that there's only one "sensible" way to write it
08:34:14 <sbpaul> @let viGenereCrypt pt key = (map (\(x,y)-> chr(((ord x - 97) + (ord y - 97)))) (zip pt (cycle key)))
08:34:15 <lambdabot>  <local>:1:0:
08:34:15 <lambdabot>      Warning: Pattern match(es) are overlapped
08:34:15 <lambdabot>               In...
08:34:17 <sbpaul> @undefine
08:34:17 <sbpaul> @let viGenereCrypt pt key = (map (\(x,y)-> chr(((ord x - 97) + (ord y - 97)))) (zip pt (cycle key)))
08:34:18 <lambdabot>  Defined.
08:34:20 <ski> jmcarthur : it is not *strictly* a fixpoint .. however, it is more like a fixpoint than an iteration (imho)
08:34:23 <sbpaul> > viGenereCrypt "hello" "zygoloid"
08:34:24 <lambdabot>   " \FS\DC1\EM\EM"
08:34:27 <sbpaul> right
08:34:40 <sbpaul> @let viGenereCrypt pt key = (map (\(x,y)-> chr(((ord x - 97) + (ord y - 97))) + 97) (zip pt (cycle key)))
08:34:40 <lambdabot>  <local>:2:75:
08:34:41 <lambdabot>      No instance for (Num Char)
08:34:41 <lambdabot>        arising from the litera...
08:34:43 <sbpaul> @undefine
08:34:45 <sbpaul> > viGenereCrypt "hello" "zygoloid"
08:34:45 <copumpkin> sbpaul: map (\(x, y) -> ...) . zip ... = zipWith
08:34:46 <lambdabot>   Not in scope: `viGenereCrypt'
08:34:47 <sbpaul> @let viGenereCrypt pt key = (map (\(x,y)-> chr(((ord x - 97) + (ord y - 97))) + 97) (zip pt (cycle key)))
08:34:48 <lambdabot>  <local>:1:75:
08:34:48 <lambdabot>      No instance for (Num Char)
08:34:48 <lambdabot>        arising from the litera...
08:34:54 <ski> jmcarthur : it might be that upon generalizing, the difference goes away, and just becomes a particular property of the specific instance .. but i doubt it
08:34:57 <yitz> > let viGenereCrypt pt key = (map (\(x,y)-> chr((ord x + ord y) `mod` 26 + 96)) (zip pt (cycle key))) in viGenereCrypt "hello" "zygoloid"
08:34:58 <lambdabot>   "rnckk"
08:35:01 <jmcarthur> copumpking: would you call this a fixpoint, feedback loop, or something else? (Either a c -> Either b c) -> (a -> b)
08:35:05 <sbpaul> is that it yitz?
08:35:17 <zygoloid> > zipWith (\x y -> chr ((ord x + ord y) `mod` 90 + 32)) "hello" (cycle "sbpaul")
08:35:18 <lambdabot>   "G3H9P"
08:35:24 <jmcarthur> copumpkin*
08:35:34 <sbpaul> it's not right if there's capital letters and numbers
08:35:34 <copumpkin> jmcarthur: not a clue :) seems like an odd function
08:35:43 <sbpaul> i want it to only work within the domain of lowercase letters
08:35:55 <EvanR-work> well Network.DNS does not work either
08:36:02 <EvanR-work> too bad because the interface is so straight forward
08:36:04 <jmcarthur> copumpkin: it iterates the function until it result in Left something
08:36:07 <jmcarthur> *results
08:36:07 <yitz> sbpaul: ord give the ascii value of the characters, so it's their number in the alphabet plus a base - 64 for uppercase and 96 for lowercase
08:36:07 <ski> (jmcarthur : please flip `Either a c',`Either b c' into `Either c a',`Either c b' so that this looks more like an inverse of `fmap' on `Either c' :)
08:36:08 <zygoloid> > zipWith (\x y -> chr ((ord x + ord y - 194) `mod` 26 + 97)) "hello" (cycle "sbpaul")
08:36:09 <lambdabot>   "zfali"
08:36:18 <EvanR-work> resolve MX "foo.com" goes into an infinite loop
08:36:25 <sbpaul> mmn that looks right
08:36:30 <cybercobra> @let crypt pt key = (map (\(x,y)-> chr(ord 'a' + ((ord x + ord y - ord 'a') `mod` 26))) (zip pt (cycle key)))
08:36:31 <lambdabot>  Defined.
08:36:36 <copumpkin> jmcarthur: yeah, still feels odd to me :) not sure I'd call it a fixed point although it probably could be called one...
08:36:38 <jmcarthur> ski: an interesting aesthetic observation... think there's any meaning to it?
08:36:41 <copumpkin> but I'm no expert :)
08:36:49 <cybercobra> > crypt "hello" "zygoloid"
08:36:50 <lambdabot>   "zvkss"
08:36:59 <byorgey> (Either a c -> Either b c) -> (a -> b)   reminds me of the involution principle from combinatorics
08:37:13 <ski> jmcarthur : actually, it might be that requiring pre- or post- composing with `fmap' yielding `id' would give possibly sensible law(s) for the operation to satisfy
08:37:15 <jmcarthur> ski: i'd say it's distinct from a backwards fmap
08:37:28 <ski> (define "backwards fmap" :)
08:37:30 <jmcarthur> ski: consider the instance for (,), for example
08:37:34 <yitz> cybercobra: really it's - 2 * ord 'a', but you can just leave that part out and it only modifies the cipher a bit
08:37:44 <ezyang> re http://blog.ezyang.com/2010/03/straitjacket-programming/#comment-299 : I can't tell if Frank is being pedantic. It seems clear to me that it's harder to do some thing in a static type system than in a dynamically typed language.
08:37:55 <sbpaul> now the decrypt function....
08:37:57 <sbpaul> o_o
08:38:06 <ezyang> I suspect I'm on the wrong side of the fence though, so comments would be appreciated.
08:38:27 <copumpkin> ezrakilty: not so clear to me, for what it's worth
08:38:28 <ski> jmcarthur : if you `fmap' from `a -> b' into `(c,a) -> (c,b)', and the go back with `foo' into `a -> b', don't you get the same function ?
08:38:31 <sbpaul> @undefine
08:38:35 <copumpkin> ezyang, I mean
08:38:42 <copumpkin> sbpaul: you can also private message lambdabot ;)
08:38:44 <ski> (s/the go/then go/)
08:38:54 <cybercobra> "The equation(s) for `...' have one argument, but its type `Maybe ...' has none" - http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=24899
08:38:55 <ezyang> copumpkin: Oh, hello copumpkin!
08:39:03 <copumpkin> ezyang: ohai 2 u 2!
08:39:04 <jmcarthur> ski: i guess you would
08:39:06 <sbpaul> @let viGenereCrypt pt key = zipWith (\x y -> chr (ord 'a' + (( ord x + ord y - ord 'a') `mod` 26))) (zip pt (cycle key)))
08:39:07 <lambdabot>   Parse error: RightParen
08:39:13 <sbpaul> ff
08:39:16 <ski> jmcarthur : so, does this hold in the `Either' case, as well ?
08:39:18 <jmcarthur> maybe that's useful
08:39:22 <quicksilver> ezyang: that commentor speaks with authority but without content :)
08:39:30 <ezyang> copumpkin: Here's an example: encoding numbers in Haskell's types
08:39:33 <sbpaul> @let viGenereCrypt pt key = zipWith (\x y -> chr (ord 'a' + (( ord x + ord y - ord 'a') `mod` 26))) (zip pt (cycle key))
08:39:34 <lambdabot>  <local>:1:96:
08:39:34 <lambdabot>      Couldn't match expected type `Char' against inferred type...
08:39:38 <ski> (obviously the "converse" composition with `fmap' doesn't yield `id', in the `(,)' case)
08:39:39 <tibbe> dcoutts: did you ever manage to get the binary builder to inline append in such a way that two writeNBuffer calls end up next to each other without an intermediate continuation in between? Whatever I do I only get writeN to inline with a continuation that goes to the next writeN.
08:39:44 <ezyang> It can be done, but it's very tricky.
08:39:55 <quicksilver> ezyang: obviously both typed and untyped languages are capable of representing all computable functions, that's a straw man
08:40:00 <ski> jmcarthur : it's always useful to have laws that ensure your operations are sensible :)
08:40:03 <jmcarthur> ski: i think you might be right
08:40:06 <jmcarthur> i agree
08:40:09 <ezyang> quicksilver: Sure.
08:40:18 <quicksilver> ezyang: it's not a discussion of anything precise like "computability" but rather something much softer
08:40:20 <jmcarthur> i'm glad i brought this up here. it's been interesting and probably useful
08:40:26 <dcoutts> tibbe: I'm pretty sure we did yes
08:40:29 <quicksilver> ezyang: it's about "programmer convenience" or "the hoops you have to jump through"
08:40:33 <copumpkin> ezyang: but why would you?
08:40:37 <quicksilver> ezyang: quite hard to make that precise.
08:40:39 <tibbe> dcoutts: can't get it to work :(
08:40:47 <dcoutts> tibbe: originally I had it so that the bounds check was merged too
08:40:48 <copumpkin> ezyang: you're putting more work to encode numbers in types to get more return
08:40:53 <dcoutts> that used a RULE though
08:40:57 <quicksilver> ezyang: but yes, there are definitely cases where provably correct haskell programs require the use of unsafeCoerce
08:41:03 <tibbe> dcoutts: my builder (the one that tom made initially) looks almost exactly like the binary one, modulo no lazy interleaving yet
08:41:03 <copumpkin> ezyang: you don't have to encode numbers in types in the first place and if you don't, you don't have much of an issue
08:41:14 <quicksilver> ezyang: ...which indicates that thing being expressed can't be conveniently encoded in the haskell type system.
08:41:18 <jmcarthur> ski: we might be getting into edwardk territory now
08:41:25 <dcoutts> tibbe: you mean for Text?
08:41:33 <ezyang> copumpkin: Hm, I think example just imploded on me.
08:41:34 <quicksilver> ezyang: I don't find it a common problem or a big problem, though.
08:41:36 <tibbe> dcoutts: yes
08:41:42 <copumpkin> @remember jmcarthur we might be getting into edwardk territory now
08:41:42 <lambdabot> It is forever etched in my memory.
08:41:51 <jmcarthur> ha
08:41:59 <dcoutts> tibbe: I'd have to look at the code, sadly no time atm
08:42:25 <ezyang> quicksilver: Me neither. It's much more common in "weaker" type system's like C's or Java's :^)
08:42:26 <tibbe> dcoutts: sure
08:42:29 <sbpaul> > crypt "zygoloid" "hello"
08:42:30 <lambdabot>   Not in scope: `crypt'
08:42:37 <sbpaul> > viGenereCrypt "zygoloid" "hello"
08:42:38 <lambdabot>   "gcrzzvmo"
08:42:41 <sbpaul> lovely
08:42:45 <ski> ezyang : how do you encode numbers in types in a dynamically typed language ?
08:43:01 <sclv> dynamically!
08:43:09 <ezyang> haha ==sclv
08:43:14 <ezyang> That's why my example imploded.
08:43:19 <copumpkin> :)
08:43:30 <copumpkin> omg ezyang thanks for getting bostonhaskell revived by the way
08:43:50 <ezyang> copumpkin: My pleasure :)
08:43:52 <ski> jmcarthur : well, that's no problem afaiac, as long as i can understand it :)
08:43:53 <jmcarthur> ski: i'm trying to see if there is a name for such a function (an inverse of fmap)
08:44:02 <copumpkin> inverse of fmap?
08:44:17 <jmcarthur> copumpkin: we've determined that loop is such a function
08:44:23 <copumpkin> (f a -> f b) -> (a -> b) ?
08:44:29 <copumpkin> :t loop
08:44:30 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
08:44:32 <jmcarthur> well, for the examples we've considered
08:44:46 <copumpkin> for some sort of inverted-type pair, I guess
08:44:59 <yitz> ski: you can only do it if the language has infinitely many types. if the only type is "Variant", it's hard to represent very many numbers
08:45:02 <jmcarthur> copumpkin: i've generalized it a bit in alt-stdlib
08:45:04 <copumpkin> ah
08:45:06 <sbpaul> > viGenereDerypt "gcrzzvmo" "hello"
08:45:07 <lambdabot>   Not in scope: `viGenereDerypt'
08:45:09 <jmcarthur> copumpkin: from pairs to bifunctors
08:45:14 <sbpaul> wtf
08:45:15 <copumpkin> have you done anything useful with loop btw?
08:45:21 <copumpkin> has anyone?
08:45:21 <sbpaul> > viGenereDecrypt "gcrzzvmo" "hello"
08:45:22 <lambdabot>   "\DC4\DC3\ESC\t \t\GS\CAN"
08:45:26 * sbpaul sighs
08:45:28 <jmcarthur> copumpkin: i've used Control.Arrow.loop exactly once
08:45:34 <jmcarthur> IRL, that is
08:45:35 <sbpaul> > ord '\DC4'
08:45:36 <lambdabot>   20
08:45:40 <copumpkin> jmcarthur: what fo'?
08:45:51 <jmcarthur> hah, i don't even remember now
08:45:53 <jmcarthur> i just know that i did
08:45:55 <copumpkin> :P
08:45:57 <Baughn> @type loop
08:45:58 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
08:45:59 <quicksilver> fo' PROFIT!
08:46:01 <sbpaul> > viGenereDecrypt "gcrzzvmo" "hello"
08:46:02 <lambdabot>   "nmuczcwr"
08:46:06 <copumpkin> the typical one I've seen is the circuit feedback thing
08:46:09 <zygoloid> > zipWith (\x y -> chr ((ord x + ord y - 194) `mod` 26 + 97)) "hello" (cycle "sbpaul")
08:46:10 <lambdabot>   "zfali"
08:46:12 <zygoloid> > zipWith (\x y -> chr ((ord x - ord y) `mod` 26 + 97)) "zfali" (cycle "sbpaul")
08:46:13 <jmcarthur> that's aside from existing definitions of it, i mean
08:46:13 <lambdabot>   "hello"
08:46:15 <copumpkin> but I can't really think of any other "practical" ones
08:46:16 <sbpaul> well, time to kill myself
08:46:27 <cybercobra> sbpaul: :(
08:46:30 <copumpkin> sbpaul: and all 600 people in here? :P
08:46:37 <sbpaul> you said that, not me
08:46:37 <jmcarthur> copumpkin: anyway, this is where all this Either business came from
08:46:41 <copumpkin> aha
08:46:49 <sbpaul> @undefine
08:47:11 <ezyang> Most excellent misuse of Either: Left or Right to specify what side the axis of Chart should be.
08:47:18 <copumpkin> sbpaul: my point was more that all 600 people in here aren't necessarily too interested in your tinkering with vigenere ciphers, unless you have a particular question about them
08:47:22 <jmcarthur> ezyang: :o
08:47:25 <Baughn> The output of the arrow syntax always struc me as.. horrifying
08:47:26 <ski> yitz : are you sure you're talking about a *dynamically* typed language, there ?
08:47:49 <Baughn> ezyang: Always happy to see an Either a a.
08:47:51 <ezyang> sbpaul: Remember, you can message lambdabot and it will still be helpful
08:48:04 <copumpkin> :)
08:48:06 <ezyang> I do it sometimes to use @pl :-)
08:48:14 <Botje> lambdabot++ # helper!
08:48:15 <yitz> ski: true, if there's only one type then the compiler derives the exact type of every expression at compile time.
08:48:16 <copumpkin> everyone should be ashamed to be using @pl
08:48:29 * ezyang puts on cone of shame 
08:48:37 <ski> jmcarthur : more specifically, we've determined that `loop' (module pair ordering) is a *retraction* of `fmap
08:48:38 <jmcarthur> i use the pointfree package
08:48:39 <ezyang> "I only use it to verify there's not a pretty pointless version!"
08:48:44 <zygoloid> ezyang: data Side = Side; whichSide :: Either Side Side; case whichSide of Left Side -> ...; Right Side -> ... ?
08:48:59 <copumpkin> @pl can be pretty bad at finding elegant pointless versions of things
08:49:00 <lambdabot> can be pretty bad at finding elegant pointless versions of things
08:49:05 <zygoloid> haha
08:49:06 <jmcarthur> ski: is that distinct from a left inverse?
08:49:18 <yitz> copumpkin: i for one was actually enjoying the vigenere cipher stuff sbpaul is doing
08:49:19 <copumpkin> zygoloid: nice!
08:49:23 <quicksilver> copumpkin: exercise for the reader - are @pl's rules confluent?
08:49:24 <copumpkin> yitz: oh ok
08:49:24 <ski> jmcarthur :  `r' is a retraction of `s'  <=>  `s' is a section of `r'  <=>  `r' and `s' form a retract situation  <=>  `r . s = id'
08:49:30 <ezyang> zygoloid: Not that bad. data Axis = ...; Left Axis and Right Axis
08:49:41 <ezyang> but :^)
08:50:03 <copumpkin> yitz: it wasn't so much an invitation to stop as a "keep in mind that people may not be too interested, but carry on if you feel they are"
08:50:08 <copumpkin> maybe it came off as overly hostile :)
08:50:20 <quicksilver> top tip for /msg'ing lambdabot - you have to use @type not :t.
08:50:56 <jmcarthur> @check \f x -> f x == (loop . fmap) (f :: Int -> Int) x
08:50:57 <lambdabot>   Overlapping instances for GHC.Show.Show
08:50:57 <lambdabot>                              (GHC.T...
08:50:58 <yitz> ezyang: i agree with frank that there is an important difference between a straightjacket and structure. though frank came on a little strong.
08:51:11 <jmcarthur> blasted Show instances
08:51:15 <zygoloid> @pl can be a useful tool but often gets things wrong. like this: \x -> [x | x <- xs]
08:51:15 <lambdabot> can be a useful tool but often gets things wrong . like this : return . (<- xs) . join (|)
08:51:45 <ezyang> ^^"
08:51:51 <sbpaul> np: Saosin - 3rd Measurement in C
08:52:16 <yitz> @pl \x -> xs
08:52:17 <lambdabot> const xs
08:52:18 <ski> copumpkin : i almost never use `@pl', instead doing the simplifications in head (sometimes with several attempts, and asking type-correctness from lambdabot)
08:54:04 <yitz> @pl \ f a b c d e g -> f b d a g e c
08:54:04 <lambdabot> (((flip . ((flip . (flip .) . flip) .)) .) .) . flip . (flip .)
08:54:14 <sbpaul> o_o
08:54:22 <jmcarthur> well, i guess loop as written isn't really a left inverse of fmap anyway. wrong type
08:54:39 <ski> yes, "modulo pair swapping"
08:54:48 <yitz> :)
08:55:01 <ski> (hence i wanted you to swap to the "correct" way, in your class)
08:55:31 <copumpkin> yeah
08:55:43 <ski> indeed, imnsho, `Writer',`WriterT' and `State',`StateT' also should swap their pairs ..
08:56:22 <jmcarthur> ski:  loop . fmap swap . fmap  ==  id
08:56:34 <jmcarthur> uglier than the preswapped version
08:57:20 <ski> (as should `random' (and baybe friends ?) .. but not `mapAccumL' and `mapAccumR', which have gotten this right)
08:57:37 <ski> jmcarthur : exactly
08:58:36 <quicksilver> :t runWriter
08:58:37 <lambdabot> forall w a. Writer w a -> (a, w)
08:58:46 <jmcarthur> yeah, writer should be the other way
08:59:01 <jmcarthur> heck, we don't even have an unwrapped instance with the same semantics :(
08:59:06 <quicksilver> interesting, that's backwards from the Functor (,) w instance,
08:59:09 <sbpaul> what did you guys major in in college
08:59:11 <quicksilver> I wonder why.
08:59:14 <ski> jmcarthur : btw, yes "retraction of `f'" is the same as "left- / post- inverse of `f'" (and mutatis mutandis for "section" and "right- / pre- inverse")
08:59:21 <quicksilver> sbpaul: maths
08:59:22 <jmcarthur> instance Monoid o => Monad ((,) o) where...
08:59:35 <sbpaul> i bet i'm the only english major in this room ;)
08:59:44 <sbpaul> probably wrong though
08:59:50 <jmcarthur> CS major, math minor
08:59:55 <Twey> I wouldn't be surprised
08:59:59 <hpc> currently majoring CS
09:00:41 <jmcarthur> i also went through electrical engineering and computer engineering for some time before finally settling on CS
09:00:53 <sbpaul> i feel like an outcast
09:00:53 <ski> quicksilver : no real reason, afaicd (except maybe someone did "empirical analysis" of how common it is that in `(result,state_alternatively_output)', `result' expressions are more commonly small expressions than the other part)
09:01:01 <sbpaul> like
09:01:02 <jmcarthur> at my uni there were enough courses in common that i didn't have to take many more for the switch
09:01:04 <sbpaul> "notes from the underground"
09:01:43 <jmcarthur> @instances MonadReader
09:01:44 <lambdabot> r ((->) r), r (ErrorT e m), r (RWS r w s), r (RWST r w s m), r (Reader r), r (ReaderT r m), r (StateT s m), r (WriterT w m), r' (ContT r m)
09:01:57 <jmcarthur> ah, ((->) r) is in there after all. didn't realize that
09:02:04 <jmcarthur> @instances MonadWriter
09:02:04 <lambdabot> w (ErrorT e m), w (RWS r w s), w (RWST r w s m), w (ReaderT r m), w (StateT s m), w (Writer w), w (WriterT w m)
09:02:13 <jmcarthur> :(
09:02:16 <ski> ?
09:02:28 <sbpaul> do any of you know how to build enciphering machines?
09:02:34 <sbpaul> like, actual physical machines
09:02:36 <ski> oh, missing `(,) w', right ?
09:02:41 <jmcarthur> right
09:02:56 <jmcarthur> not even Monad :(
09:03:01 <jmcarthur> i think it's not even Applicative
09:03:04 <jmcarthur> @instances Applicative
09:03:05 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
09:03:17 <jmcarthur> @instances-importing Control.Applicative Applicative
09:03:18 <lambdabot> ((,) a), ((->) a), Const m, IO, Maybe, WrappedArrow a b, WrappedMonad m, ZipList, []
09:03:22 <jmcarthur> oh nevermind
09:03:26 <jmcarthur> it's just not a Monad
09:03:29 <zygoloid> sbpaul: i have vague notions of how the Enigma machine was constructed
09:03:39 <quicksilver> zygoloid: it was kate winslet, wasn't it?
09:03:41 <quicksilver> oh, hang on...
09:03:48 <sbpaul> i have a bad influence on this chat room
09:03:55 <zygoloid> :)
09:03:56 <ski> (of course, while i see `ErrorT' there .. the `Error e' constraint on instances of `Monad' (and friends) for `Either e' and `ErrorT e m' must die !)
09:04:06 <jmcarthur> ski: heck yes
09:05:06 <ski> (if you really like, define `Error' and `ErrorT' types using that constraint .. but keep my `Either e' (and `EitherT a m') out of the filthy hands of the `Error' class !)
09:05:35 * quicksilver nods
09:05:50 <quicksilver> although there are two distinct, interesting Applicative instances for Either/EitherT
09:06:07 <ski> hm, which is the other one ?
09:06:12 <jmcarthur> more than two
09:06:21 <jmcarthur> oh wait, no just two, sorr
09:06:23 <quicksilver> ski: add a Monoid constraint, and collect multiple errors
09:06:33 <quicksilver> it's really nice sometimes.
09:06:44 <jmcarthur> actually...
09:06:44 <sbpaul> haskell is BEAUTIFUL
09:06:47 <sbpaul> speaking as a poet
09:06:54 <sbpaul> oh boy
09:06:54 <ski> quicksilver : ah, right .. i've considered that idea before (but not on the `Either' type, plain)
09:07:05 <quicksilver> I have used that to make a type whose Applicative instance was not compatible with its Monad instance
09:07:10 <jmcarthur> quicksilver: thisIsAnError >>= whatDoIDo     ?
09:07:14 <sbpaul> i love how twenty or so lines of C get condensed into two lines of haskell
09:07:15 <quicksilver> which felt a bit bad, but it was very useful.
09:07:24 <jmcarthur> oh. *applicative*
09:07:29 <jmcarthur> nevermind again. sorry
09:07:46 <ski> i should really get as many (non-depending) errors as possibly at the same time (can always use `take' at a final stage)
09:07:54 <quicksilver> yes
09:08:02 <quicksilver> I was building a parser
09:08:11 <quicksilver> it was very useful to see *all* the parse errors it could, at once
09:08:20 <quicksilver> I could fix many of them each time
09:08:26 * ski nods violently
09:09:00 <quicksilver> incidentally, I take no credit for this - it's discussed in the Applicative paper.
09:09:15 <quicksilver> mcbride++
09:09:17 <quicksilver> patterson++
09:09:20 <Twey> Sweet.
09:09:23 <sclv> ?karma mcbride
09:09:23 <lambdabot> mcbride has a karma of 1
09:09:28 <sclv> ?karma patterson
09:09:29 <lambdabot> patterson has a karma of 1
09:09:33 <ski> (which one ? the original(?) "idiom" one by McBride and Paterson (?) ?)
09:09:40 <alpounet> @where applicative
09:09:40 <lambdabot> http://darcs.haskell.org/packages/base/Control/Applicative.hs
09:09:44 <quicksilver> the one reference from the Control.Applicative docs
09:09:44 <alpounet> hm, no.
09:10:15 <quicksilver> Applicative Programming with Effects JFP 2008
09:10:19 <quicksilver> http://www.soi.city.ac.uk/~ross/papers/Applicative.html
09:12:26 * sbpaul eats a brownie
09:12:34 <ski> quicksilver : hm, that's recentish (2008), i'm not sure i've read it
09:12:35 <ski> ty
09:12:40 <redrut> http://www.youtube.com/watch?v=QKf3Vhh0iWY
09:12:41 <redrut> http://www.youtube.com/watch?v=QKf3Vhh0iWY
09:12:41 <redrut> http://www.youtube.com/watch?v=QKf3Vhh0iWY
09:12:49 * ski sighs
09:13:08 <sbpaul> somebody else tell me what the video is
09:13:38 * ski is just going to ignore that ever happened, from this point on ..
09:15:22 <ski> @karma- patterson
09:15:22 <lambdabot> patterson's karma lowered to 0.
09:15:26 <ski> @karma+ paterson
09:15:26 <lambdabot> paterson's karma raised to 1.
09:15:30 <sbpaul> @karma+ ski
09:15:30 <lambdabot> ski's karma raised to 9.
09:15:31 <Twey> I would, but I'd rather not add a view.
09:15:32 <sbpaul> @karma+ patterson
09:15:33 <lambdabot> patterson's karma raised to 1.
09:15:43 <sbpaul> wtf
09:15:54 <ski> sbpaul : it should be spelled `paterson', not `patterson'
09:16:04 <Twey> Hey, #haskell is still climbing in size
09:16:06 <sbpaul> @karma+ paterson
09:16:06 <lambdabot> paterson's karma raised to 2.
09:16:13 <ski> @karma- patterson
09:16:13 <copumpkin> it's back to close to where it was last year
09:16:13 <lambdabot> patterson's karma lowered to 0.
09:16:14 <Twey> We seem to be fast approaching 700
09:16:16 * sbpaul sighs
09:16:20 <copumpkin> after RWH was released
09:16:24 <copumpkin> sbpaul: what's up?
09:16:26 <jmcarthur> @users
09:16:27 <lambdabot> Unknown command, try @list
09:16:27 <Twey> Really?  I thought I only saw it around 600
09:16:31 <sbpaul> copumpkin: oh, the usual
09:16:35 <copumpkin> oh ok
09:16:38 <sbpaul> you guys want to read my novel?
09:16:42 <copumpkin> Twey: we hit 699 last year
09:16:47 <jmcarthur> Twey: it's been at this point for a while now afaik
09:16:47 <copumpkin> then it went back down
09:16:47 <Twey> sbpaul: Nothing a bit of functional programming can't fix, eh?
09:16:50 <Twey> copumpkin: Ooh.
09:16:55 <Twey> That's a shame.
09:16:55 <sbpaul> that's true Twey
09:16:58 <sbpaul> that even includes world hunger
09:17:01 <Twey> Hehe
09:17:05 <sbpaul> 100% serious
09:17:10 <Twey> Appropriately applied, of course
09:17:14 * copumpkin is 101% serious
09:17:26 <sbpaul> it's actually a remarkably simple solution
09:17:31 * jmcarthur is seriously kidding
09:17:33 <sbpaul> i don't know how much you guys know about economics
09:18:36 <quicksilver> copumpkin: it dropped when we were forced to force identified users only
09:18:42 <quicksilver> copumpkin: when freenode was being hit by spammers
09:18:47 <quicksilver> I think that's the only reason it dropped
09:18:54 <quicksilver> but it's taken a while for some people to come back
09:19:02 <Twey> Hum
09:19:57 <copumpkin> ah
09:21:51 <ski> ezyang : (re blog) .. ah, so Frank Atanassow are alive and well, i see :)
09:22:06 <contrafunktal> but is the distribution of text per user uniform across freenode?
09:22:20 <quicksilver> ski: is he known for such comments?
09:22:38 <ski> quicksilver : he was known for that on LtU, yes
09:22:57 <ezyang> Hm!
09:24:37 <Twey> ski: Blog?
09:25:44 <copumpkin> ezyang: what's 245s?
09:25:55 <copumpkin> oh
09:26:03 <copumpkin> I can click on the about link and find ot
09:26:33 <ezyang> copumpkin: It's my dorm room :-)
09:26:37 <copumpkin> omg
09:26:39 <ezyang> When I go and move next year I should rename my blog
09:26:40 <copumpkin> what if you move?
09:26:45 <copumpkin> aha
09:27:20 <pickles> anyone know of any examples of Parsec.Pos ?
09:27:35 <pickles> im not getting anything from the documentation in hackage
09:29:03 <quicksilver> pickles: it's a bit fiddly.
09:29:16 <quicksilver> pickles: are you writing your own lexer/
09:29:28 <copumpkin> lex luthor
09:29:35 <ski> Twey : <http://blog.ezyang.com/2010/03/straitjacket-programming/#comment-299> which ezyang pasted almost an hour ago~
09:29:36 <pickles> no, i was just using teh std parsec combinator
09:29:49 <quicksilver> parsing straight onto Strings?
09:29:50 <pickles> can it only be accessed when doing a lexer too?
09:30:00 <pickles> kinda, but yeah, pretty much
09:30:23 <pickles> erm...
09:30:34 <quicksilver> well, the point is you need to associate a Pos with every token - or character
09:30:40 <pickles> no, i take it and process some of the strings and then construct datatypes
09:30:47 <pickles> hm
09:30:51 <quicksilver> I meant Strings as input
09:30:54 <ski> (.. hm "luth lexer" .. might be a nice name for a lexer library)
09:30:56 <pickles> oh, yeah
09:31:01 <quicksilver> I was using my own token type as input [Token]
09:31:10 <pickles> input is in stringform
09:31:18 <copumpkin> ski: that is cute
09:31:26 <quicksilver> ...so it turned into [(SourcePos,Token)]
09:31:35 <quicksilver> and then I used 'tokenPrim' to construct my basic parsers
09:31:49 <pickles> hm
09:31:53 <pickles> i might have to go that route then
09:31:59 <pickles> i just wanted line nums :(
09:32:57 <quicksilver> well - I might be wrong - but I don't think the built in char parsers
09:33:10 <quicksilver> (the stuff in Parsec.Char) include any source pos information
09:33:28 <pickles> ah well
09:33:51 <quicksilver> oh I'm quite wrong
09:33:58 <pickles> rly!? hooray!
09:34:00 <quicksilver> they do it all automatically for you
09:34:03 <quicksilver> it should "just work"
09:34:10 <pickles> guh
09:34:14 <quicksilver> what made you think you *didn't* have position information?
09:34:28 <pickles> my lack of knowledge of parsec is what
09:34:33 <quicksilver> :)
09:34:47 <pickles> so it has the info, can i access it?
09:34:50 <quicksilver> in what context did you want to access position information?
09:35:01 <quicksilver> for example, you should find it automaically appears in error messages, if I remember rightly.
09:35:07 <pickles> right
09:35:26 <pickles> im writing an assembler, and each line has different 'signal' variables
09:35:31 <pickles> and im looking to connect signals
09:36:01 <pickles> so i was hoping to be able to use line numbers to record which lines a signal was present on
09:36:22 <quicksilver> well "getPosition" is a parser which consumes no data, but returns the current position
09:36:26 <quicksilver> presumably that's what you need?
09:36:30 <pickles> yes
09:36:32 <quicksilver> http://hackage.haskell.org/packages/archive/parsec/3.1.0/doc/html/Text-Parsec-Prim.html#v%3AgetPosition
09:36:43 * pickles needs to rtfm
09:37:00 <quicksilver> to be fair to you, the manual doesn't really cover this unless you already know where to look
09:37:08 <pickles> hehe
09:37:10 * ski idly wonders whether Parsec supports `MonadFix'
09:37:12 <quicksilver> if you already knew where to look you wouldn't have asked :)
09:37:19 <pickles> exactly!
09:37:23 <pickles> thank you very much quicksilver
09:37:23 <quicksilver> hopefully you can get getPosition doing what you need
09:37:32 <quicksilver> sorry about that false start
09:37:35 <pickles> it looks like it should work
09:37:45 <pickles> no problem, i wasn't describing my situation very well
09:37:49 <Saizan_> well, you can know about .Prim without knowing all its contents :)
09:37:54 <quicksilver> I was answering a diffeent question, which was : Help! I'm not using Parsec.Char, how do I make sure I have position information?
09:38:04 <quicksilver> which I found to be pretty much undocumented
09:38:04 <pickles> ah
09:38:10 <pickles> heheh
09:38:19 <pickles> yes, this should work
09:38:20 <quicksilver> but the answer is "build your basic parsers with tokenPrim, and embed position information in your token stream"
09:38:22 <pickles> thank you much
09:38:34 <pickles> right
09:38:44 <ski> (.. hm, doesn't look that way .. i wonder whether that is an omission, or whether it is impossible/hard)
09:39:02 <pickles> i was dreading that solution because im lazy and dont want to write more code than i have to
09:40:47 <quicksilver> ski: doesn't seem like it should be fundamentally hard
09:40:54 <quicksilver> ski: Parsec isn't much more than a state monad, really.
09:41:49 * quicksilver looks at the definition
09:41:54 <pickles> quicksilver: thx again
09:42:34 <quicksilver> ParsecT {unParser :: forall b . State s u -> (a -> State s u -> ParseError -> m b) -> (ParseError -> m b) -> (a -> State s u -> ParseError -> m b) -> (ParseError -> m b) -> m b }
09:42:47 <copumpkin> we need a basis of all haskell monads (transformers) from which all others can be built without much work (and yes I've seen sigfpe's post on cont)
09:43:01 <quicksilver> ski: that's a multiple either/state monad which has been CPS-unwrapped, isn't it?
09:43:03 <copumpkin> "without much work" is very formal
09:43:27 <quicksilver> copumpkin: you could build Parsec out of mtl fine
09:43:42 <quicksilver> copumpkin: the problem isn't that mtl isn't expressive - it's that for boring practical reasons it's too slow.
09:43:47 <quicksilver> AIUI.
09:44:34 <pickles> copumpkin: hooray for orthogonal language bases
09:45:15 <ddarius> quicksilver: Parsec is not the composition of monad transformers, though you could certainly represent most of it that way.
09:45:23 <quicksilver> the CPS-transformed versions of monads compile much faster in GHC, as they make much less boxing/unboxing
09:45:36 <ski> quicksilver : yes, something like that .. i'm not sure why there's two of both continuations, though
09:45:47 <ski> (and why does every continuation take `ParserError' ?)
09:45:52 <quicksilver> ddarius: my thesis was you could represent all of it, but I know it isn't like that
09:46:15 <ddarius> quicksilver: Less pattern matching.  However, what Antoine did isn't (just) the same trick that Janis did.
09:46:31 <quicksilver> ski: two cases for "nothing consumed"
09:46:38 <ddarius> ski: Parsec is based off of a four case type.
09:46:39 <quicksilver> ski: (and the other two for "somethig consumed")
09:46:54 <ski> ah
09:47:08 <ddarius> Incidentally, this is part of why it's 1) different than StateT s [] and why it isn't a composition of the standard monad transformers.
09:47:17 <quicksilver> but the CPS-unwrapped versions also have slightly different strictness properties, don't they?
09:47:28 <quicksilver> which probably matters for some things.
09:48:04 <ddarius> quicksilver: Yes, but the monadic version was already different and what behavior it was/is supposed to guarantee is unclear.
09:48:05 <ski> quicksilver : aiui, the compiled code of CPS code 8usually) execute faster, too .. i didn't know the actual compilation in GHC also was faster ..
09:48:33 <quicksilver> ski: sorry, faster execution was actually what I intended to say :)
09:48:34 <ski> (ddarius : who's Antoine and Janis, here ?)
09:48:50 <ski> (quicksilver : i was suspecting that might be what you wanted to say :)
09:48:53 <quicksilver> "compile much faster" was supposed to desugar to "compile into much faster code" ;)
09:49:45 <ski> (quicksilver : and it is to get similar "faster execution" that i'm thinking on and off on "unboxed variants" and `case' patterns :)
09:49:46 <jmcarthur> i think CPS transformed monads associate differently than untransformed ones
09:50:00 <ski> jmcarthur : "associate" meaning ?
09:50:13 <jmcarthur> like the CPS transform causes all binds to be right associative or something like that
09:50:14 <ddarius> Antoine Latter and Janis Voigtlander
09:50:24 <jmcarthur> i could be mixing some ideas up
09:50:48 <marcot> Good afternoon.  Is there a function in the standards libraries to show (convert to String) a number in a different base than 10?
09:50:49 <ski> quicksilver : and, yes, i'm almost sure the strictness changes (like if you were using unboxed tuples instead of ordinary tuples, say)
09:51:28 <ski> ddarius : ty .. are you thinking of a specific paper (or library) ?
09:51:41 <quicksilver> marcot: showIntAtBase
09:51:48 <ddarius> The thing is the (>>=) for a CPSed monad is completely independent of that monad.  So you only pay for using the monad when you actually do something with it.  Another way of looking at it this is just an implementation of Filinski's "Representing Monads"
09:52:28 <quicksilver> > showIntAtBase 16 intToDigit 255 ""
09:52:29 <lambdabot>   "ff"
09:52:31 <quicksilver> marcot: ^^
09:52:56 <marcot> quicksilver: Thanks.  I searched on hoogle for simply Int -> Int -> String
09:52:58 <ski> jmcarthur : yes, that "associate differently" is sortof the point of using CPS, there :)
09:53:05 <marcot> =)
09:53:12 <ddarius> ski: Antoine is the one who made the "CPS transformed" Parsec 3.  As for Janis, http://www.iai.uni-bonn.de/~jv/mpc08.pdf
09:53:27 <ski> ah, ty for the information
09:53:44 <quicksilver> ddarius: Aha, so the underlying implementation of parsec 2 was not of this form?
09:54:08 <ddarius> quicksilver: No.
09:54:28 <jmcarthur> ski: ha i guess so
09:54:28 <quicksilver> Parser (State tok st -> Consumed (Reply tok st a))
09:54:32 <ddarius> (As in, no it wasn't.)
09:54:45 <ski> ddarius : yes, i'm familiar with Filiski's work here (though it's been a while ..)
09:54:51 <jmcarthur> ski: but what i mean is that it makes the binds of the underlying monad associate differently or somesuch
09:54:52 <ski> (s//n/)
09:54:56 <ddarius> ski: I know you are familiar with that work.
09:55:04 <jmcarthur> which is part of the speedup, iirc
09:55:09 <ski> ddarius : sorry for stating the obvious, then :)
09:55:18 <jmcarthur> oh but now i know i'm mixing things up
09:55:50 <jmcarthur> i'm thinking of codensity over free monads
09:56:27 * ski often finds it hard to keep track of who in the haskell community (or even the part i interact with) know what about whom .. or vice versa
09:56:50 <jmcarthur> me too
09:57:11 <jmcarthur> 677 people here with various connections to each other
09:57:20 <jmcarthur> and that's just right now
09:57:47 <ski> jmcarthur : yes, the simple way to explain the point is that in `Monad (Either e)', in `(>>=)', we don't want to percolate up `Left e' step by step, checking/interpreting it all the time
09:57:59 <jmcarthur> right
09:58:23 <ddarius> We don't want to percolate Right a either.
09:58:26 <Saizan_> i remember edwark saying that the CSP speedup was only worth for monads that ended up as Condensity of something after the transformation
09:59:25 <ski> ddarius : well, `Right a >>= amb = amb a', so there's no potential of that .. oh, unless `amb' is `return' of course (which must be what you were talking about)
09:59:36 <ezyang> Does criterion do benchmarking of functionally equivalent code and then give you comparative graphs of them?
09:59:52 <Saizan_> (but in the end you can just take Codensity of your monad and abstract the additional power away, modulo the strictness issues)
10:00:35 <jmcarthur> ezyang: i don't know if it yet generates layered graphs or even graphs that are scaled the same
10:00:48 <ezyang> mmkay
10:01:08 <ddarius> ski: "Percolating" was the wrong word.  Just the checking.  In a run of code that makes no use of effects in the Either monad, you are constantly checking whether or not an exception has occurred.
10:01:08 <jmcarthur> it didn't in the past, i know
10:01:22 <ski> jmcarthur : .. and this is solved by CPS-transforming so that we can "unbox" the pair types that the `Either' gets converted to .. other solutions to this would be to add some kind of "unboxed variants", or maybe some guarantees that certain styles of writing operations returning values in a variant type get similar performance
10:01:31 <sclv> there's a packaged on top of criterion that does the comparative stuff.
10:01:51 <ezyang> sclv: Ah, what's the name?
10:01:55 <jmcarthur> sclv: do you know what it's called? im curious too
10:02:01 <ddarius> ski: In the ContT (Either e) monad, we never check if an exception has occurred except at catch.
10:02:21 <sclv> ezyang: http://chplib.wordpress.com/tag/progression/
10:02:31 <ezyang> excellent!
10:02:42 <jmcarthur> oh this
10:02:46 <jmcarthur> i forgot about it
10:02:48 <jmcarthur> awesome
10:03:09 <ski> ddarius : indeed. when you pass two continuations instead of using `case', there's no "continuously" occuring checking
10:03:11 <ddarius> Much like using reify/reflect.
10:03:20 <ski> ddarius : *nod* and *nod* :)
10:03:31 <ezyang> heh, "the graphs aren't as pretty"
10:03:56 <ddarius> ski: Simply Church encoding an Either type just implements checking a different way, so there's more to it than that.
10:03:59 <jmcarthur> they are grayscale friendly it seems, though
10:04:14 <jmcarthur> well, some of them
10:04:18 <ddarius> ContT (Either e) has only one continuation.
10:04:45 <jmcarthur> @unmtl ContT (Either e) a
10:04:46 <lambdabot> err: `ContT (Either e) a' is not applied to enough arguments, giving `/\A. (A -> a (Either e)) -> a (Either e)'
10:04:55 <ski> Saizan_ : well, iirc, `data Codensity f a = MkCodensity {runCodensity :: forall b. (a -> f a) -> f a}' .. so that's in CPS style inside, yes
10:04:56 <jmcarthur> @unmtl ContT (Either e) r a
10:04:56 <lambdabot> (a -> r (Either e)) -> r (Either e)
10:05:03 <jmcarthur> oops
10:05:07 <ski> (er, s/f a/f b/)
10:05:17 <ezyang> Ugh, Text.Sushi is such a terrible module name
10:05:18 <jmcarthur> :t runContT
10:05:19 <lambdabot> forall r (m :: * -> *) a. ContT r m a -> (a -> m r) -> m r
10:05:26 <ezyang> *TxtSushi
10:05:30 <jmcarthur> @unmtl ContT r (Either e) a
10:05:30 <lambdabot> (a -> Either e r) -> Either e r
10:06:31 <ski> ddarius : hm, you're right
10:07:32 <ski> hm
10:07:39 <jmcarthur> @djinn Either a b -> (b -> Either a c) -> Either a c
10:07:39 <lambdabot> f a b =
10:07:40 <lambdabot>     case a of
10:07:40 <lambdabot>     Left c -> Left c
10:07:40 <lambdabot>     Right d -> b d
10:07:55 <copumpkin> jmcarthur has an Either fetish today
10:08:28 <ski>   forall r. (a -> forall o. (e -> o) -> (r -> o) -> o) -> forall o. (e -> o) -> (r -> o) -> o
10:08:36 <ski> can we simplify that, somehow ?
10:08:53 <gwern> 'There are three roads to ruin: gambling, women â€“ and engineers. The first two are
10:08:56 <gwern> more pleasant, but the last is the most certain.
10:08:58 <jmcarthur> @djinn ((a -> Either e r) -> Either e r) -> (a -> ((b -> Either e r) -> Either e r)) -> ((b -> Either e r) -> Either e r)
10:08:58 <lambdabot> f a b c = a (\ d -> b d c)
10:09:14 <jmcarthur> @. pl djinn ((a -> Either e r) -> Either e r) -> (a -> ((b -> Either e r) -> Either e r)) -> ((b -> Either e r) -> Either e r)
10:09:15 <lambdabot> f = (. flip) . (.)
10:09:38 <ski> jmcarthur : unsuprisingly
10:09:55 <mreh> String -> (forall a . Audio a -> IO b) -> IO b -- how can I cast this without the existential qualifier?
10:10:05 <jmcarthur> quite
10:10:13 <mreh> and get rid of the CPS
10:10:35 <jmcarthur> cast it?
10:10:36 <ski> @djinn ((a -> m r) -> m r) -> (a -> (b -> m r) -> m r) -> ((b -> m r) -> m r)
10:10:36 <lambdabot> f a b c = a (\ d -> b d c)
10:10:49 <ski> jmcarthur : it works uniformly for every `m :: * -> *' ^
10:10:52 <mreh> jmcarthur: as in, I cast something in stone, nothing to do with types
10:10:54 <jmcarthur> ski: right
10:11:01 <copumpkin> mreh: huh
10:11:12 <mreh> s/cast/rewrite/
10:11:34 <jmcarthur> that's not an existential, btw
10:11:35 <copumpkin> mreh: it isn't existential
10:11:41 <ski> mreh : the answer is "no", unless you eliminate the `Audio a', for every possible `a'
10:11:46 <mreh> it's a universal qualifier
10:11:54 <ski> copumpkin : it is existential-modulo-CPS
10:11:58 <sinelaw> hi all
10:14:15 <jmcarthur> it's hard to follow #haskell at the same time as writing low level C
10:14:23 <jmcarthur> i should get off irc
10:14:26 <jmcarthur> more often
10:14:28 <copumpkin> jmcarthur: omg I tweeted something similar to that earlier today
10:14:34 <jmcarthur> hah
10:14:44 <ski> mreh : i.e. you can of course convert that to `String -> IO (Exists Audio)', given `data Exists f = forall a. MkExists {runExists :: f a}' .. but i doubt you'll accept that :)
10:14:59 <zygoloid> mreh: you'll need an existential type: data AnyAudio = forall a. Audio a => AnyAudio a
10:15:12 <zygoloid> mreh: then you can rephrase it as :: String -> IO AnyAudio
10:15:16 <ski> (zygoloid : `Audio' is not a class, here)
10:15:27 <NaCl> Any suggested tutorials for new users (with plenty of examples and exercises?)
10:15:34 <ski> @where lyah
10:15:35 <lambdabot> http://www.learnyouahaskell.com/
10:15:38 <ski> @where rwh
10:15:38 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
10:15:41 <zygoloid> ski: oops, it was a class last time mreh was here with this :)
10:15:49 <ski> zygoloid : ok :)
10:16:35 <NaCl> ski: yay bots
10:16:39 <zygoloid> then: data AnyAudio = forall a. AnyAudio (Audio a)
10:16:44 <NaCl> thanks
10:17:04 <zygoloid> hpaste down?
10:17:07 <ezyang> wow, fclabel views are pretty spiffy
10:17:17 <copumpkin> fclabel in general is pretty spiffy
10:17:26 <copumpkin> and you don't get the HT naming scheme too, which is a big plus
10:17:31 <contrafunktal> which part of fclabels is it?
10:17:34 <ezyang> 'should've blogged about them instead'
10:17:43 <ezyang> copumpkin: HT naming scheme?
10:17:49 <contrafunktal> copumpkin: it's a big minus that people have to be split up over naming schemes
10:18:00 <copumpkin> contrafunktal: I agree, but I still can't stand it
10:18:13 <Apocalisp> naming schemes? What's wrong with LISP?
10:18:26 <copumpkin> ezyang: if you've ever noticed that some modules have unintelligible haddock and require you to import all your modules qualified
10:18:33 <copumpkin> because otherwise you're submerged in thousands of Cs and Ts
10:18:36 <contrafunktal> name all classes C and all data types and constructors T
10:18:41 <copumpkin> then you've encountered said naming scheme
10:18:59 <contrafunktal> would it be better if classes were all H?
10:19:05 <chrisdone> fclabels!!!<33333333
10:19:09 <copumpkin> hah
10:20:24 <contrafunktal> @google mesomorph
10:20:25 <lambdabot> http://www.bodybuildingpro.com/bodytypeinformation.html
10:20:26 <lambdabot> Title: Body Type Information - Ectomorph, Mesomorph, Endomorph
10:20:49 <contrafunktal> oh, it's not a recursion scheme
10:21:07 <ezyang> lol
10:21:11 <Jafet> It's a type!
10:21:39 <chrisdone> i'm an ectomorph
10:21:47 * chrisdone :: Ectomorph
10:21:48 <Cale> I hate that naming scheme of Henning Thielemann's. I've been considering writing a tool specifically to sanitise Henning Thielemann's code.
10:21:49 <ski> we should make it into a recursion scheme, then !
10:21:58 <contrafunktal>  type EndoEndo = Endo Endomorph
10:22:18 <ezyang> Rooting around progression, it looks like the library might be a little too immature for my tastes
10:24:15 <Twey> ski: Ah, thanks
10:24:49 <Twey> What provides the Data typeclass?  SYB?
10:24:51 <bastl> @seen dreixel
10:24:51 <lambdabot> Unknown command, try @list
10:24:55 <bastl> @list
10:24:55 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
10:25:01 <Cale> Ah, cool, haskell-src-exts can produce code exactly as it was parsed... this almost shouldn't be too hard.
10:25:08 <contrafunktal> ghc provides it
10:25:10 <ski> @index Data
10:25:10 <lambdabot> Data.Generics.Basics, Data.Generics
10:25:15 <Twey> Ah, found it
10:25:22 <Twey> contrafunktal: Oh really?  Hm
10:26:14 <contrafunktal>  ghci -hide-all-packages -package base  lets you   import Data.Data
10:26:53 <Twey> #ifdef __HADDOCK__ scares me
10:27:11 <contrafunktal> I suppose that was a bit confusing, since the package name for the ghc-api is ghc
10:28:07 <Saizan_> ski: i was saying something more than "Codensity F is cps", i was saying that only when you transform a monad into an instance of Codensity you get benefits by CPS, and that in some cases you won't find an F such that Codensity F is isomorphic to your monad. As an example this would predict that "forall o. (e -> o) -> (r -> o) -> o" is not a beneficial enough representation for "Either e r"
10:28:19 <whald> hmm, class constraints on functions is simple. but as it seems nobody is talking about class constraints on "data declarations". what am i missing?
10:30:05 <chrisdone> whald: I believe class constraints on data types require rank2 types
10:30:23 <chrisdone> @google haskell rankn rank2 types
10:30:25 <lambdabot> http://cvs.haskell.org/Hugs/pages/users_guide/quantified-types.html
10:30:25 <lambdabot> Title: Quantified types
10:31:25 <philo> how to specify interger constant in binary format
10:31:31 <philo> ?
10:31:43 <ezyang> error: question underspecified
10:32:22 <whald> chrisdone: thanks, but on the first sight i think that if it requires an language extension, i'm doing it wrong ;-)
10:32:24 <ski> Saizan_ : ok
10:32:25 <contrafunktal>  chrisdone, whald  data C a => T a = T a
10:32:32 <contrafunktal> that is allowed
10:32:42 <contrafunktal> supposedly not useful though
10:33:05 <contrafunktal> since you can (and have to?) put the C constraint on the functions that manipulate T
10:33:21 <philo> the equavalent of 0xFF for banary
10:33:23 <philo> binry
10:33:25 <ski> whald : it is widely considered (i think) that the specification of how `data C a => T a = MkT (..a..)' works is not that useful
10:33:31 <philo> binary
10:34:02 <ski> whald : if you want something like this, consider instead usign GADTs style like `data T a where MkT :: C a => ..a.. -> T a'
10:34:04 <whald> what i'm for would look more like "data C => T = T [C]"
10:34:43 <ski> `C' being a zero-arity type class ?
10:34:46 <sinelaw> i managed to control a robot using haskell today!
10:34:59 <sinelaw> "control" being move it at a constant velocity
10:35:02 <chrisdone> sinelaw: wooooooooooo
10:35:04 <Jafet> Safely, I hope
10:35:06 <philo> anyone ?
10:35:23 <sinelaw> not so safe. it's a 70-kilo robot that can probably kill
10:35:23 <whald> i ultimatly want a list of anything that is in the "C" class
10:35:24 <hpc> next step: skynet
10:35:39 <Jafet> philo, meh, hex it
10:35:54 <sinelaw> philo 11111111
10:36:06 <sinelaw> F = 1111
10:36:26 <sinelaw> assuming that was even your question.
10:36:41 <contrafunktal> > showIntAtBase 2 (head . show) 0xFF ""
10:36:42 <lambdabot>   "11111111"
10:37:12 <Veinor> why is it called atbase?
10:37:23 <Jafet> :t readIntAtBase
10:37:24 <lambdabot> Not in scope: `readIntAtBase'
10:37:26 <silver> you can change bases
10:37:34 <contrafunktal> you might otherwise confuse it with showing the base of the int?
10:37:37 <chrisdone> > 0o17
10:37:38 <lambdabot>   15
10:38:17 <Veinor> > 0o20
10:38:18 <lambdabot>   16
10:38:21 <Veinor> ...
10:38:39 <chrisdone> shame there isn't a 0b..
10:38:49 <contrafunktal> > fromRat mouse
10:38:50 <lambdabot>   1.0
10:39:00 <hpc> :t fromRat
10:39:01 <lambdabot> forall a. (RealFloat a) => Rational -> a
10:39:06 <philo> so no 0b equivalent ?
10:39:10 <chrisdone> nope
10:39:13 <philo> ok
10:39:15 <Jafet> > let binary 0 = 0; binary n = binary (n/10) * 2 + if n%10 == 0 then 0 else 1; in binary 101010
10:39:16 <lambdabot>   Ambiguous type variable `t' in the constraints:
10:39:16 <lambdabot>    `GHC.Real.Fractional t'
10:39:17 <lambdabot> ...
10:39:28 <chrisdone> http://www.haskell.org/onlinereport/lexemes.html#sect2.5
10:39:28 <Jafet> > let binary 0 = 0; binary n = binary (div n 10) * 2 + if mod n 10 == 0 then 0 else 1; in binary 101010
10:39:29 <lambdabot>   42
10:40:03 <philo> Jafet from benin ?
10:40:26 <Jafet> Where's benin?
10:40:27 <ski> whald : the "problem" with using `data C a => T a = MkT (..a..)' is that
10:40:38 <ski> whald : (a), you still have to add the `C a' constraint everytime you use `T a', it is just that you are now not allowed to omit it;
10:40:42 <ski> whald : and (b) the more serious issue being that often when you want `C a' as an *input* to a function, you really don't want the type of the function to have the `C a' constraint, rather you want the `C a' constraint to be *automatically* present *inside* the function, since the only way to construct values of type `T a' is when you actually have `C a'
10:40:42 <gwern> the bight of benin! / the bight of benin! / one man came out / where ten went in!
10:41:37 * gwern wonders if anyone recognizes that
10:42:04 <chrisdone> is it Kenny Rogers?
10:42:14 <ski> whald : however, if you use GADTs, instead, then the (b) point disappears, and the (a) point disappears when `T a' is an input to the function (as would be expecteD)
10:42:30 <gwern> chrisdone: not even right medium
10:42:38 <chrisdone> :p I know
10:43:01 <sinelaw> google knows all.
10:43:02 <Jafet> Is that related to the byte of benin?
10:43:09 <sinelaw> @google the bight of benin
10:43:10 <lambdabot> http://en.wikipedia.org/wiki/Bight_of_Benin
10:43:10 <lambdabot> Title: Bight of Benin - Wikipedia, the free encyclopedia
10:43:13 <whald> ski : thanks a lot, somehow i feel this brought me to the next level in the Haskell game
10:43:22 <whald> how many levels are there?
10:43:24 <whald> :-)
10:43:33 <Jafet> whald, time to read some Cantor.
10:44:28 <gwern> sinelaw: that's a source, but not the source of my version, no
10:44:48 <zygoloid> whald: there are fix Succ levels.
10:45:14 <chrisdone> zygoloid: I like your style and I would like to subscribe to your newsletter
10:45:26 <Jafet> Indeed, you can never fix sucking
10:46:14 <sinelaw> Philip McCutchan?
10:46:33 <contrafunktal> laziness however...
10:46:35 <sinelaw> wait no.
10:46:46 <sinelaw> gwern, wikipedia claims it's an "old rhyme"
10:46:54 <gwern> sinelaw: note the numbers differ
10:47:20 <sinelaw> Graham Green?
10:47:30 <sinelaw> however his first name is spelled
10:47:52 <gwern> nope
10:47:55 <sinelaw> @google bight of benin one man came out  where ten went in
10:47:57 <lambdabot> http://afraf.oxfordjournals.org/cgi/reprint/XXXIV/CXXXVII/391.pdf
10:48:32 <gwern>  hint: SF
10:52:06 <zygoloid> gwern: Professor Frank Cox, in a misquotation of an 'old jingle' :)
10:53:00 <gwern> zygoloid: er. I don't remember a Professor Frank Cox characer
10:53:28 <zygoloid> http://www.gresham.ac.uk/event.asp?PageId=4&EventId=696
10:53:40 <Baughn> jmcarthur: If I use an STM value in hackstack-state, will it work correctly, with restarts, persistence and everything?
10:54:25 <gwern> zygoloid: 2007? oh goodness no, this SF novel long predates that
10:54:28 <Baughn> jmcarthur: It seems to break their reader/update distinction somehow, but of course there's also liftSTM.. I'm confused.
11:01:47 <leveld> hi ppl, I am new to haskell, I have a simple question, can someone help me?
11:01:56 <gwern> the novel, if anyone still cares, was _Stand on Zanzibar_ by John Brunner
11:02:07 <Veinor> leveld: just ask your question :)
11:02:24 <Baughn> leveld: If not here, then nowhere
11:02:25 <leveld> ok, I got a parse error on input `,'
11:02:31 <leveld> for these lines:
11:02:32 <Baughn> @paste
11:02:33 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
11:02:46 <sinelaw> gwern, Aha! never heard of it or him.
11:03:02 <leveld> hold on, using pastepin
11:03:15 <gwern> sinelaw: no reason you should've. after all, all his hugos and what not were in the *previous* century
11:03:29 <BONUS> try hpaste.org i think moonpatio.com is down
11:03:50 <sinelaw> gwern, i wonder when the first 2000's kid will join this channel
11:03:56 <leveld> yeah looks like it
11:03:58 <sinelaw> whoever he is, he is now 10 years old.
11:04:03 <leveld> hpaste.org doesn't load either
11:04:23 <leveld> well, the code is not long ( four lines ) is it ok if I just post this here?
11:04:29 <sinelaw> four lines are ok.
11:04:31 <gwern> sinelaw: 10 years is perfectly doable. given the maturity of some commentors, I think such have already entered
11:04:32 <Baughn> jmcarthur: Ah, I suppose the type of initialValue prevents using STM variables in the actual state. Kind of a pity. Hmm.
11:04:38 <leveld> matMult :: (Num a) => [ (a,a), (a,a) ] -> [ (a,a), (a,a) ] -> [ (a,a), (a,a) ]
11:04:45 <sinelaw> gwern, ZOMG NO.
11:04:52 <leveld> matMult [ (x11, x12), (x21, x22) ] [ (y11, y12), (y21, y22) ] =
11:05:00 <leveld> [ ( x11*y11+x21*y12, x12*y11+x22*y12 ),
11:05:01 <gwern> sinelaw: on the internet, no one knows you're a 10 year old dog
11:05:07 <leveld> ( x11*y21+x21*y22, x12*y21+x22*y22 ) ]
11:05:15 * sinelaw barks immaturely
11:05:19 <leveld> just playing around
11:05:23 <leveld> seeing how haskell works
11:05:26 <Veinor> leveld: that last line needs to be indented so Haskell knows it's a continuation of the previous one, I think
11:05:35 <BONUS> leveld: the type's off. there's no such type as [something,something]. try [(a,a)]
11:05:36 <leveld> hmm...
11:05:42 <hpc> also, you can't have [x,y] as a type
11:05:42 <Veinor> oh, that too
11:05:43 <leveld> ok
11:06:11 <BONUS> even if a list of,say, Ints has 3 elements, the type is still [Int] and not [Int,Int,Int]
11:06:36 <hpc> matMult shoudl probably be of type [[a]] -> [[a]] -> [[a]]
11:06:54 <leveld> ok,... but why?
11:07:11 <leveld> BONUS' tutorial shows vector addition with tuples...?
11:07:22 <leveld> addVectors :: (Num a) => (a,a) -> (a,a) -> (a,a)
11:07:33 <hpc> that assumes 2D vectors
11:07:42 <hpc> matricees can have more than 2 rows/columns
11:07:59 <leveld> that's true, but I only wanted 2x2 matrices. For now. :)
11:08:13 <leveld> this is my first haskell function that I've tried to come up with on my own outside of tutorials...
11:08:20 <Jafet> Well, you can block-decompose larger matrices.
11:08:28 <Veinor> you also might want to make a Matrix type so you don't have to keep writing ((a,a), (a,a))
11:08:34 <BONUS> 2D vectors are assumed. i think using tuples/triples is better if you're staying fixed on a certain vector length
11:08:38 <hpc> then you should do matMultTwoTwo :: (Num a) => ( (a,a), (a,a) ) -> ( (a,a), (a,a) ) -> ( (a,a), (a,a) )
11:09:21 <leveld> I guess I need to revisit the brackets vs. the parentheses...
11:09:50 <hpc> depending on your previous background, tuples vs lists can take a while to grok
11:09:57 <contrafunktal> an excelent time to introduce dependent types?
11:10:23 <contrafunktal> well excellent
11:10:57 <zygoloid> leveld: the type (a, b) has values (x, y) where x is of type a and b is of type b.
11:11:02 <gwern> I just thought of tuples as fixed-length lists with funny syntax
11:11:05 <gwern> seemed to work
11:11:06 <mercury^> You don't need dependent types anywhere here.
11:11:19 <zygoloid> leveld: the type [a] has values [], [x1], [x1, x2], [x1, x2, x3], ..., where the xs are all of type a
11:11:22 <jmcarthur> fixed-length heterogeneous lists
11:11:38 <mercury^> You don't need those.
11:11:42 <tensorpudding> tuples!
11:11:45 <hpc> the way i learned it, tuples and arrays both store multiple things, arrays holding lots of one thing, tuples holding a fixed amount of different things
11:11:45 <leveld> zygoloid: thank you!
11:11:47 <BONUS> a list of type [Int] can be of any length but all the elements have to be Ints. with tuples, the elements can be of different types, but the length is determined by the type. for instance, a tuple of type (Int,Char)
11:12:02 <BONUS> well there you go, 5 explanations :)
11:12:10 <leveld> thanks :)
11:12:11 <zygoloid> leveld: [x1], [x1, x2], ... are really just syntactic sugar for  x1:[] ,  x1:x2:[] , ...
11:12:37 <hpc> with parenthesis, that's x1:(x2:[])
11:12:54 <contrafunktal> perhaps it isn't helpful that the syntax in types is very similar to the syntax in values
11:12:59 <hpc> (:) :: a -> [a] -> [a]
11:13:09 <zygoloid> so (:) is a binary thing which takes an 'a' on the left and a list of 'a' on the right, and returns a list of 'a' which is one item longer (with a new item on the front)
11:13:09 <leveld> hpc: hold on, that, I don't get. I thought tuples are different from lists?
11:13:28 <Veinor> leveld: parens are also used for grouping
11:13:30 <zygoloid> leveld: tuples have parentheses and at least one comma
11:13:35 <jmcarthur> parentheses are not just for tuple
11:13:36 <jmcarthur> s
11:13:39 <hpc> i thought of them as having different limitations, but still being things that hold multiple stuff
11:13:47 <tensorpudding> @type (,)
11:13:48 <lambdabot> forall a b. a -> b -> (a, b)
11:13:59 <hpc> and the ubertuple-array would be the C type (void*)[]
11:14:04 <contrafunktal> @type (1,)
11:14:06 <lambdabot> parse error on input `)'
11:14:09 <zygoloid> leveld: () is not a tuple, (a) is not a tuple, but (a, b) is a tuple, as is (a, b, c) and so on
11:14:17 <contrafunktal> > (1,) 2
11:14:18 <lambdabot>   <no location info>: parse error on input `)'
11:14:18 <leveld> ok
11:14:21 <Veinor> zygoloid: () is totally a tuple! :D
11:14:22 <jmcarthur> it is my opinion that (,) should not be special, and should not require parens :(
11:14:37 <tensorpudding> It's not a tuple if it isn't using (,)
11:14:42 <contrafunktal> @ask Cale could you add -XTupleSections please?
11:14:43 <lambdabot> Consider it noted.
11:14:55 <hpc> you actually don't need the parenthesis
11:15:01 <hpc> > 2 , 1
11:15:02 <lambdabot>   <no location info>: parse error on input `,'
11:15:07 <jmcarthur> you need the parens
11:15:08 <contrafunktal> you do in haskell
11:15:10 <tensorpudding> > (,) 1 2
11:15:10 <Veinor> horns.aiff
11:15:10 <zygoloid> @ask Cale could you add -XTemplateHaskell please?
11:15:11 <lambdabot> Consider it noted.
11:15:11 <lambdabot>   (1,2)
11:15:20 <jmcarthur> well, sure (,) works
11:15:22 <contrafunktal> zygoloid: yes, more runIO!
11:15:27 <jmcarthur> but that has parens :P
11:15:31 <EvanR-work> what is the magic words to make my program faster
11:15:42 <Blackheart> () is a unary tuple
11:15:46 <EvanR-work> im guessing its spending most of the time in gc now
11:15:47 <hpc> __asm {mov esp,1}
11:15:49 <hpc> :P
11:15:51 <EvanR-work> after running for a long time
11:15:54 <Blackheart> er, nullary
11:15:54 <tensorpudding> () is not a unary tuple, is a 0-ary tuple
11:15:56 <zygoloid> contrafunktal: lambdabot already has various things blacklisted, and runIO's not even in scope
11:15:57 <jmcarthur> @ask Cale could you add unsafePerformIO please?
11:15:57 <lambdabot> Consider it noted.
11:16:08 <tensorpudding> if you'd like to consider such a silly notion
11:16:10 <ski> (zygoloid : except the nullary tuple `()' doesn't have a comma)
11:16:23 <ski> @slap jmcarthur
11:16:24 * lambdabot would never hurt jmcarthur!
11:16:31 <jmcarthur> :D
11:16:32 * ski protests !
11:16:38 <tensorpudding> (,,) makes a triple, (,) makes a pair, () makes a nulltuple
11:16:42 <jmcarthur> @vixen i love you
11:16:43 <lambdabot> you love me? you don't even know me
11:16:56 <tensorpudding> @vixen is () a tuple?
11:16:57 <lambdabot> nevermind about that
11:17:04 <jmcarthur> good adice
11:17:06 <jmcarthur> *advice
11:17:21 <zygoloid> ski, Veinor: the haskell report is pretty clear that () is not a tuple.
11:17:25 <jmcarthur> what about singleton tuples? :(
11:17:33 <hpc> singleton tuples are just values
11:17:42 <contrafunktal> > Language.Haskell.TH.runIO (print "hai?")
11:17:43 <lambdabot>   Not in scope: `Language.Haskell.TH.runIO'
11:17:53 <leveld> ok, by just using tuples, it compiled fine
11:17:56 <zygoloid> The Report says: "Tuples are written (e1, ..., ek), and may be of arbitrary length k>=2."
11:17:59 <jmcarthur> hpc: all the other tuples have extra boxes around the values
11:18:09 <jmcarthur> just a value is not equivalent
11:18:15 <zygoloid> Identity is a 1-tuple :)
11:18:21 <hpc> haha
11:18:25 <jmcarthur> zygoloid: isn't Identity a newtype?
11:18:26 <ski> (this reminds me, how to descriple `()' in terms of "tuple" or something similar .. "niltuple" ? "nupple" ? "nipple" ? "zepple" ? "aupple" ?)
11:18:35 <zygoloid> jmcarthur: hmm, you could be right
11:18:39 <zygoloid> @src Identity
11:18:40 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
11:18:41 <EvanR-work> nipple
11:18:43 <jmcarthur> it needs to be data to qualify
11:18:47 <ski> maybe "niple"
11:18:52 <leveld> BONUS: I was in Ljubljana last summer, nice city. :)
11:18:59 <hpc> if you can get () to be called nipple, i will be very impressed
11:19:09 <jmcarthur> @let nipple = ()
11:19:09 <zygoloid> much better name than unit
11:19:10 <lambdabot>  Defined.
11:19:16 <ski> ("aupple" coming from "aught")
11:19:35 <hpc> > nipple == ()
11:19:36 <lambdabot>   True
11:19:43 <contrafunktal> zygoloid: template haskell allows more spamminess, ex    @type $(tupleT maxBound)
11:19:55 <jmcarthur> > nipple <$ "hello"
11:19:56 <lambdabot>   [(),(),(),(),()]
11:20:15 <EvanR-work> will the memory usage of the program ever decrease, like, if the workload dies down and the gc collects all the garbage ?
11:20:19 <EvanR-work> like, top
11:20:37 <ski> zygoloid : hm, i was not aware of that .. is there any reasonably reason why not ?
11:20:46 <jmcarthur> EvanR-work: ghc doesn't release memory back to the OS
11:20:59 <jmcarthur> EvanR-work: rather, the ghc runtime doesn't
11:21:08 <EvanR-work> ok
11:21:21 <hpc> it will drop garbage but hold onto the memory for future allocations
11:21:37 <contrafunktal> actually   conE $ tupleDataName maxBound
11:23:32 <contrafunktal> yeah, template haskell would be nice to have
11:23:57 <contrafunktal> that spamminess is already possible anyways..
11:27:35 <Veinor> shouldn't nipple be (.)?
11:27:41 <zygoloid> ski: i assume it's because there's no one-tuple; it'd be inconsistent to have 0-tuples and k-tuples (k >= 2)
11:27:55 <Veinor> 'oh, f nipple g is equal to'
11:28:03 <hpc> haha
11:28:08 <zygoloid> contrafunktal: yeah, TH's tupE says that () is a 0-tuple and 'a' is a 1-tuple of type 'a'
11:28:09 <theorbtwo> But surely nipple is (.)?  A zero-tupple is nullple.
11:28:39 <ski> zygoloid : well, it is still inconsistent .. it's just that the naming doesn't admit that :)
11:28:54 <contrafunktal> count tuple
11:28:57 <Veinor> the nipple combinator
11:29:16 <hpc> then there's (.)(.)
11:29:30 <ski> and also `(.:)'
11:29:36 <ski> @type (.) . (.)
11:29:37 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
11:29:56 <ski> @type let (.) = (Prelude..) in (.) . (.)  -- no Caleskell atm, ty
11:29:57 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
11:29:57 <theorbtwo> Tupples are named vaugely after the latin numbers.  Nulla is latin for zero, or none.
11:30:36 <theorbtwo> I always wonder how lambdabot chooses names for type varaibles.  Why is that a, b, c, a1, and not a, b, c, d?
11:30:36 <ski> well, "nupple" or "nuple" sounds like it might be fine, then
11:30:47 <sinelaw> gotta love #haskell
11:30:51 <EvanR-work> quadruple... triple... ... pair... oneple... zerople
11:31:15 <contrafunktal> nullple
11:31:20 <theorbtwo> quadruple, triple, pair, uniple, nullple.
11:31:34 <EvanR-work> then theres 57-ple
11:31:36 <zygoloid> @type (.)
11:31:37 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:31:51 <zygoloid> @type (Prelude..)
11:31:52 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
11:32:09 <zygoloid> theorbtwo: ^^ that's why. it's using the names from the type annotated on (.) where it can
11:32:10 <hpc> where is lambdabot getting . from?
11:32:19 <zygoloid> hpc: it has a local (.) = fmap
11:32:23 <ski> hpc : Caleskell
11:32:28 <hpc> ah
11:32:34 <theorbtwo> zygoloid: Aha!
11:32:58 <leveld> err... how can I get out of *Main> in ghci?
11:33:11 <hpc> :q
11:33:13 <contrafunktal> where would you go?
11:33:15 <dv-> C-d
11:33:22 <leveld> Prelude?
11:33:29 <leveld> don't I have to?
11:33:31 <contrafunktal> :m Prelude
11:33:50 <contrafunktal> also + and * are allowed as prefixes to modules you load
11:34:03 <contrafunktal> well, maybe not * for builtin modules
11:34:14 <DrSyzygy> If I instantiate a type class, can I add further restrictions on which situations my instance works in?
11:34:15 <leveld> contrafunktal: ty
11:34:17 <contrafunktal> or - too
11:34:40 <contrafunktal> where * means interpreted, + - to add or remove from scope
11:34:53 <DrSyzygy> Specifically, I have a typeclass parametrizing orderings for a library that allows you to change total orders a lot for the things in the library.
11:34:57 <zygoloid> DrSyzygy: yes. instances can have typeclass constraints.
11:35:06 <contrafunktal> and no symbol prefix means to replace the currently loaded environment
11:35:11 <zygoloid> 'instance Ord a => Ord [a] where ...'
11:35:19 <leveld> why am I in a Main anyway, I'm only writing functions in a .hs file and don't have a main
11:35:22 <applicative> instance Eq a => Functor a
11:35:36 <zygoloid> kind error!
11:35:43 <contrafunktal> when you don't name a module, it gets called Main
11:36:17 <sinelaw> kind error, please pass me the salt?
11:36:25 <leveld> oh, that's counterintuitive. I thought it would get named the file name or so... but thanks!
11:36:32 <DrSyzygy> It seems, according to my collaborator who's the one with an issue, that what we want is to be able to get an instance MyClass (MyType a b c) for only those c that are of the shape (AnotherType Int) instead of (AnotherType c).
11:36:33 <applicative> leveld, start with   module Happiness where
11:36:51 <contrafunktal> then you will only have kind errors
11:37:03 <zygoloid> DrSyzygy: you'll need FlexibleInstances for that
11:37:21 <DrSyzygy> zygoloid: Okay. With FlexibleInstances it's easy and obvious?
11:37:31 <zygoloid> DrSyzygy: 'instance MyClass (MyType a b (AnotherType Int)) where ...'
11:38:16 <leveld> applicative: ?
11:38:18 <DrSyzygy> zygoloid: Thanks! I'll see whether he can get further with this.
11:38:26 <zygoloid> no problem, good luck!
11:38:41 <applicative> leveld, so that you don't see   Main>  you see  Happiness>
11:39:00 <leveld> :)
11:39:55 <leveld> well, thanks I appreciate your time. I will go back to lurking and keep quiet... :)
11:45:41 <vexer_> Hi. I'm writing a small little script as my first Haskell program. I've gotten it to run just fine, but it is horribly slow and I was wondering what noob-ish mistakes I was making. I do need high precision integers, so the Integer type is used over Int for a reason. Past that, I'm not sure what to do. Here's the code: http://pastie.org/919828
11:46:19 <EvanR-work> integers are infinitely precise! Int or not!
11:46:40 <Jafet> Double, the lua way
11:48:00 <Jafet> vexer, what's the point of this length'
11:49:02 <zygoloid> vexer_: length' = genericLength (in Data.List) if you need to deal with /really/ long lists. otherwise, length' = fromIntegral . length
11:49:33 <Jafet> I suspect all he needs is -O2
11:49:44 <jmcarthur> if you have lists that long you better hope they are lazy and garbage collected as you count
11:50:06 <zygoloid> vexer_: the real issue is your choice of algorithm. actually performing the multiplication is not the best way.
11:50:18 <vexer_> zygoloid: Oh.
11:50:21 * vexer_ blushes
11:50:36 <Jafet> Well, it may be a valid way, depending on what vexer actually wants
11:50:57 <zygoloid> vexer_: you want the number of trailing zeroes. that's the number of factors of 10 = 2 * 5. in n! there are always more factors of 2 than of 5, so you just need to know the number of factors of 5.
11:51:21 <jmcarthur> > length [0..]  -- terminates fairly quickly on a 32 bit machine, but not on a 64 bit machine. have fun with that
11:51:25 <lambdabot>   mueval-core: Time limit exceeded
11:51:37 <jmcarthur> well, "quickly" meaning "a few minutes"
11:51:57 <Jafet> What about length ([0..]::[Integer]) ?
11:52:26 <jmcarthur> Jafet: my point was that for list lengths you're not even realistically going to notice a difference between Int64 and Integer
11:52:31 <BONUS> why would that change anything?
11:52:36 <BONUS> length just evaluates the spine
11:52:44 <BONUS> oh wait
11:52:52 <BONUS> yeah [0..]::Int is not an infinite list
11:52:54 <jmcarthur> BONUS: the spine is different length on 32 and 64 bit
11:52:57 <jmcarthur> yeah
11:53:13 <copumpkin> > succ maxBound :: Int
11:53:17 <lambdabot>   *Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
11:53:18 <EvanR-work> thats a lame [0..]
11:54:13 <jmcarthur> what else could it do?
11:54:21 <philo> having trouble undertanding quot vs div
11:54:30 <jmcarthur> cycling would be in violation of the combination of Bound and Enum, i think
11:54:30 <copumpkin> difference is on negative numbers
11:54:33 <EvanR-work> > -1 `quot` 1
11:54:34 <lambdabot>   -1
11:54:37 <EvanR-work> > -1 `div` 1
11:54:38 <lambdabot>   -1
11:54:41 <copumpkin> the precedence of - is wrong
11:55:04 <copumpkin> > (-10) `quot` 2
11:55:05 <lambdabot>   -5
11:55:08 <copumpkin> > (-10) `div` 2
11:55:09 <lambdabot>   -5
11:55:10 <copumpkin> oh whoops
11:55:11 <copumpkin> hmm
11:55:12 <hpc> > -1 `quot` -1
11:55:13 <lambdabot>   Precedence parsing error
11:55:13 <lambdabot>      cannot mix `GHC.Real.quot' [infixl 7] and pre...
11:55:24 <sclv> > [(maxBound - 2 :: Int)..]
11:55:25 <lambdabot>   [9223372036854775805,9223372036854775806,9223372036854775807]
11:55:26 <EvanR-work> jmcarthur: ah, didnt know [x..y] has class support
11:55:30 <philo> ok i see
11:55:33 <copumpkin> > (-10) `divMod` (-3)
11:55:34 <lambdabot>   (3,-1)
11:55:37 <copumpkin> > (-10) `quotRem` (-3)
11:55:38 <lambdabot>   (3,-1)
11:55:41 <copumpkin> meh :P
11:55:46 * copumpkin failz
11:55:47 <jmcarthur> :t enumFrom -- EvanR-work
11:55:48 <lambdabot> forall a. (Enum a) => a -> [a]
11:55:54 <jmcarthur> :t enumFromTo
11:55:55 <lambdabot> forall a. (Enum a) => a -> a -> [a]
11:56:08 <jmcarthur> :t enumFromThenTo -- i think
11:56:09 <lambdabot> forall a. (Enum a) => a -> a -> a -> [a]
11:56:14 <jmcarthur> yup :)
11:56:14 <EvanR-work> > [..5]
11:56:15 <lambdabot>   <no location info>: parse error on input `..'
11:56:18 <Jafet> > length ([1..] :: [Int16])
11:56:18 <EvanR-work> shucks ;)
11:56:19 <lambdabot>   32767
11:56:26 <jmcarthur> EvanR-work: the [ .. ] notation is just sugar for those functions
11:56:38 <EvanR-work> cool
11:56:46 <jmcarthur> > [False..]
11:56:47 <lambdabot>   <no location info>: parse error on input `]'
11:56:53 <jmcarthur> > [False ..]
11:56:54 <lambdabot>   [False,True]
11:57:12 <jmcarthur> @instance Enum
11:57:12 <lambdabot> Maybe you meant: instances instances-importing
11:57:16 <jmcarthur> @instances Enum
11:57:17 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
11:57:28 <jmcarthur> > [LT ..]
11:57:29 <lambdabot>   [LT,EQ,GT]
11:57:32 <EvanR-work> > ['a' ..]
11:57:34 <lambdabot>   "abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\134\135\136\137...
11:57:57 <EvanR-work> > [0.0 ..]
11:57:57 <hpc> > ['\000' ..]
11:57:58 <lambdabot>   [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0...
11:57:58 <lambdabot>   "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\S...
11:58:00 <jmcarthur> ugh, Double and Float are bad for that
11:58:09 <EvanR-work> lame
11:58:14 <EvanR-work> > [0.1 ..]
11:58:15 <lambdabot>   [0.1,1.1,2.1,3.1,4.1,5.1,6.1,7.1,8.1,9.1,10.1,11.1,12.1,13.1,14.1,15.1,16.1...
11:58:25 <hpc> > [epsilon ..]
11:58:25 <lambdabot>   Not in scope: `epsilon'
11:58:26 <jmcarthur> > [0.1, 0.2 ..]
11:58:27 <lambdabot>   [0.1,0.2,0.30000000000000004,0.4000000000000001,0.5000000000000001,0.600000...
11:58:41 <hpc> yay float fail
11:58:45 <EvanR-work> > [2 ..]
11:58:46 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
11:58:48 <jmcarthur> > [0.1, 0.2 ..] !! 3000
11:58:49 <EvanR-work> > [2.0 ..]
11:58:49 <lambdabot>   300.0999999999862
11:58:50 <lambdabot>   [2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17.0,18...
11:59:04 <EvanR-work> the hell is wrong with it
11:59:11 <jmcarthur> floats and doubles are imprecise
11:59:19 <jmcarthur> they should not be instances of Enum, IMO
11:59:21 <hpc> it assumes a step size of 1, not epsilon
11:59:29 <Jafet> Lalala abstraction leak
11:59:41 <EvanR-work> hpc: except in this case [0.1 ..]
11:59:51 <jmcarthur> > [0, 0.1 .. 0.5]
11:59:52 <lambdabot>   [0.0,0.1,0.2,0.30000000000000004,0.4000000000000001,0.5000000000000001]
11:59:58 <hpc> no, that assumes step size 1 too
12:00:03 <EvanR-work> eh?
12:00:06 <jmcarthur> it went over 0.5 there
12:00:14 <hpc> > [0.1 ..]
12:00:14 <lambdabot>   [0.1,1.1,2.1,3.1,4.1,5.1,6.1,7.1,8.1,9.1,10.1,11.1,12.1,13.1,14.1,15.1,16.1...
12:00:27 <jmcarthur> > succ 0.3
12:00:28 <lambdabot>   1.3
12:00:45 <EvanR-work> ah you did [0.1, 0.2 ..]
12:00:49 <jmcarthur> yeah
12:01:19 <jmcarthur> > [0, 0.1 ..] :: [CReal]
12:01:21 <lambdabot>   [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1....
12:01:23 <hpc> rational numbers are countably infinite, so it makes sense that they can be enumerated
12:01:23 <jmcarthur> :D
12:01:31 <EvanR-work> haha
12:01:44 <EvanR-work> but in what order
12:01:53 <jmcarthur> a strange one
12:02:02 <EvanR-work> why doesnt the usual one work
12:02:13 <jmcarthur> what usual one?
12:02:19 <EvanR-work> 4/5 < 5/5
12:02:34 <jmcarthur> you mean always getting larger?
12:02:35 <monochrom> > 4/5 < 5/5
12:02:36 <lambdabot>   True
12:02:37 <EvanR-work> yeah
12:02:38 <monochrom> works
12:02:46 <EvanR-work> i mean for enum perpuposes
12:02:51 <EvanR-work> purposes
12:02:56 <jmcarthur> EvanR-work: well, first, we have to clear up the fact that Enum doesn't enumerate an entire domain
12:02:59 <hpc> actually, more accurately, floats have a finite well ordered set of values
12:03:07 <jmcarthur> EvanR-work: hpc is talking about a different idea
12:03:10 <hpc> given a limited number of bits
12:03:11 <monochrom> 0.1 :: Double is inexact.
12:03:16 <jmcarthur> hpc: yes they do
12:03:25 <jmcarthur> assuming they follow a standard
12:03:33 <jmcarthur> some implementations don't (does GHC?)
12:03:37 <monochrom> Enum for Double has a bug violating Haskell 98 in addition.
12:03:56 <hpc> this instance increments by 1, not epsilon though
12:03:59 <jmcarthur> > 0.1 :: Double
12:04:00 <lambdabot>   0.1
12:04:16 <roconnor> monochrom: what bug?
12:04:47 <hpc> GHC uses IEEE float/double, iirc
12:04:57 <roconnor> Enum ought to enumerate the domain.  I think the floating instances of Enum are just wrong.
12:04:59 <jmcarthur> hpc: yeah it would make sense to make succ = (epsilon +)
12:05:01 <jmcarthur> or whatever
12:05:11 <monochrom> last [a..b] is not supposed to be strictly bigger than b. Enum for Double has last [a..b] strictly bigger than b.
12:05:25 <jmcarthur> strictly?
12:05:31 <jmcarthur> > [0 .. 0.1]
12:05:32 <roconnor> monochrom: why do you say this isn't H98
12:05:32 <lambdabot>   [0.0]
12:05:39 <monochrom> > [0, 0.1 .. 1]
12:05:40 <lambdabot>   [0.0,0.1,0.2,0.30000000000000004,0.4000000000000001,0.5000000000000001,0.60...
12:05:45 <monochrom> > last [0, 0.1 .. 1]
12:05:47 <lambdabot>   1.0
12:05:47 <jmcarthur> > [0, 0.1 .. 0.2]
12:05:48 <lambdabot>   [0.0,0.1,0.2]
12:05:49 <zygoloid> > [0, 1 .. 1.9]
12:05:50 <lambdabot>   [0.0,1.0,2.0]
12:05:50 <roconnor> monochrom: they change how enumFromTo delibrately in H98 to what it is now.
12:05:55 <jmcarthur> > last [0, 0.1 .. 0.2]
12:05:56 <lambdabot>   0.2
12:06:01 <jmcarthur> so not strictly
12:06:05 <monochrom> > last [0, 0.1 .. 100]
12:06:06 <lambdabot>   100.00000000000617
12:06:06 <zygoloid> > last [0..1.9] > 1.9
12:06:07 <lambdabot>   True
12:06:16 <zygoloid> > last [0..2.1] > 2.1
12:06:17 <lambdabot>   False
12:06:18 <roconnor> monochrom: Haskell 1.3 or 1.4 behaved like you suggest
12:06:23 <jmcarthur> > last [0, 0.1 .. 0.2] > 0.2
12:06:24 <lambdabot>   False
12:06:34 <zygoloid> > [0..2.4]
12:06:35 <lambdabot>   [0.0,1.0,2.0]
12:06:42 <roconnor> which just goes to show that the Enum instance for floats is just crap
12:06:50 <jmcarthur> it really is
12:06:51 <roconnor> I can't beleive they didn't just drop it entirely
12:07:04 <jmcarthur> i think hpc's suggestion would have been okay
12:07:16 <roconnor> all will be fixed during the Caleskell revolution
12:07:17 <jmcarthur> not very useful though
12:07:18 <hpc> having it increment by epsilon?
12:07:25 <jmcarthur> yeah
12:07:31 <roconnor> heads will roll
12:07:32 <jmcarthur> or to the next expressible number at least
12:07:36 <roconnor> and tails will unroll
12:07:45 <hpc> haha
12:07:47 <EvanR-work> lol
12:07:58 <zygoloid> jmcarthur: that doesn't help for enumFromThenTo
12:08:15 <jmcarthur> @src enumFromThenTo
12:08:15 <lambdabot> Source not found. Take a stress pill and think things over.
12:08:19 <roconnor> I always use fromRational [a .. b] anyways
12:08:21 <jmcarthur> zygoloid: why not?
12:08:25 <roconnor> well, map fromRational
12:08:39 <zygoloid> jmcarthur: because... well, what difference would it make?
12:08:40 <jmcarthur> zygoloid: well, it doesn't make enumFromThenTo very fast anyway
12:09:10 <hpc> you convert the step size to a multiple of epsilon as best you can, then step that many times
12:09:18 <hpc> between appends to the list
12:09:20 <zygoloid> jmcarthur: if i say [0,0.1..1.0] you still have to choose to either round (as we do now) or risk not getting 1.0 sometimes
12:09:44 <monochrom> Oh sorry, I forgot to read a separate paragraph in haskell 98 for Double.
12:09:49 <zygoloid> hpc: what happens when adding k * epsilon doesn't give you a bigger number any more?
12:10:20 <jmcarthur> zygoloid: or you count the steps between 0 and 0.1 and then move that many steps up per element from there
12:10:27 <hpc> then you reached infinity or somehow ended up at NaN
12:10:31 <jmcarthur> even if it's different precision
12:10:35 <zygoloid> jmcarthur: so you start taking steps twice as big when you get to 2?
12:10:38 <jmcarthur> zygoloid: it would be predictable but useless
12:10:40 <jmcarthur> yes
12:10:53 <zygoloid> i disagree that this "would have been okay" ;-)
12:11:06 <hpc> if you want to have arbitrary rational step sizes, use CReal
12:11:09 <jmcarthur> i care more about the predictability
12:11:22 <jmcarthur> yeah. CReal is great :)
12:11:32 <jmcarthur> sort of
12:11:39 <hpc> it can be slow
12:11:54 <zygoloid> hpc: i don't. i'd be happy to have no Enum for Double. but i think the current Enum is pretty much the best compromise we could have.
12:12:06 <jmcarthur> > (1 :: CReal) == (1 + 1e-60)
12:12:07 <lambdabot>   True
12:12:11 <sinelaw> vector-space is cool.
12:12:14 <jmcarthur> that's why CReal is not cool ^^
12:12:20 <roconnor> jmcarthur: shhh
12:12:24 <hpc> haha
12:12:26 <roconnor> jmcarthur: but that stuff can be fixed
12:12:30 <jmcarthur> yes it can
12:12:31 <jmcarthur> and it should
12:12:34 <jmcarthur> and then it would be awesome
12:12:46 <roconnor> my equality works better in my implementation
12:12:53 <roconnor> It's just mine is waaaay slower
12:12:55 <zygoloid> jmcarthur: that's just to keep the comparison total isn't it?
12:12:58 <hpc> rational numbers: confounding standards and dodging implementation since 1960
12:13:06 <jmcarthur> zygoloid: totality at the cost of correctness
12:13:07 <monochrom> CReal == and <= check 40 digits
12:13:16 <jmcarthur> monochrom: and Ord methods
12:13:24 <roconnor> so I recommend CReal even if it's stupid operations that it is forced to have that you should never call are not implemented very well
12:13:40 <Twey> > 1e-60 :: CReal
12:13:41 <lambdabot>   0.0
12:13:46 <monochrom> jmcarthur: and Eq methods too
12:13:50 <copumpkin> roconnor: how does it compare to fewdigits?
12:13:53 <jmcarthur> roconnor: i'd like to have CReal in alt-stdlib once i have a good algebra for it
12:13:59 <tensorpudding> @src Rational
12:14:00 <lambdabot> type Rational = Ratio Integer
12:14:07 <roconnor> copumpkin: how does CReal compare to fewdigits?
12:14:09 <tensorpudding> @src Ratio
12:14:09 <lambdabot> data (Integral a) => Ratio a = !a :% !a
12:14:10 <copumpkin> yeah
12:14:13 <tensorpudding> ah
12:14:17 <zygoloid> jmcarthur: actually iirc it's still not even total since checking the first digit can require knowledge of the entire number
12:14:31 <tensorpudding> just a pair of integers...what's so hard about that
12:14:37 <roconnor> copumpkin: fewdigits has slightly better semantics while CReal is like 100x faster or so I guess
12:14:38 <jmcarthur> zygoloid: yeah. might as well just suck it up and accept partiality
12:14:42 <copumpkin> roconnor: oh wow
12:14:47 <jmcarthur> reals are flaky for computation as it is
12:15:03 <copumpkin> yeah
12:15:06 <copumpkin> reals suck in general
12:15:07 <jmcarthur> computable reals, at least
12:15:17 <roconnor> eh
12:15:24 <roconnor> it is the classical reals at suck
12:15:28 <tensorpudding> noncomputable reals aren't useful though
12:15:28 <roconnor> the computable reals are great!
12:15:32 <jmcarthur> heh, yeah
12:15:42 * copumpkin wants a type of noncomputable reals
12:15:43 <jmcarthur> tensorpudding: yeah... you can't... compute them! yeah!
12:15:56 <tensorpudding> by definition, noncomputable reals aren't useful!
12:15:59 <jmcarthur> copumpkin: data Real;
12:16:18 <tensorpudding> Except in reductio proofs, or for making intuitionists groan.
12:16:27 <tensorpudding> Or if you like completeness.
12:16:38 <jmcarthur> i prefer consistency
12:16:39 <monochrom> noncomputable reals are useful in keeping axioms succint
12:16:56 <roconnor> conputable numbers are computable cauchy computable complete
12:17:12 <zygoloid> copumpkin: data SomeNonComputableReals = ChaitinsConstantTimes CReal
12:17:13 <copumpkin> that's quite the sentence
12:17:24 <tensorpudding> completenes with respect to the metric
12:17:30 <copumpkin> zygoloid: why just stop with coefficience
12:17:33 <copumpkin> coefficients
12:17:44 * tensorpudding doesn't respect the metric
12:17:54 <zygoloid> copumpkin: yeah, CReal adjoin Chaitin's constant is a decent enough field :)
12:17:54 <roconnor> tensorpudding: they are complete with respect to the metric yes
12:17:57 <Jafet> Just implement Real with IO and take the digits from your oracles.
12:18:26 <twink> Concatenate digits of the busy beaver problem?
12:18:34 <zygoloid> Jafet: NOO! there'll be unsafePerformMathematics everywhere!
12:19:00 <zygoloid> twink: not exactly that but a similar idea
12:19:03 <tensorpudding> unsafeAxiomOfChoice
12:19:10 <monochrom> unsafePerformMathematics (1+1 == 2)
12:19:17 <sinelaw> @pl (\f b a -> (f a, b))
12:19:18 <lambdabot> flip . ((,) .)
12:19:21 <roconnor> constructive mathematics has an axiom of choice as a theorem
12:19:23 <Jafet> "HamelBasis, I choose you!"
12:19:32 <sinelaw> @pl (\b f a -> (b, f a))
12:19:33 <lambdabot> (.) . (,)
12:19:37 <BrianHV> when a choice exists between a list comprehension and a call to filter, is there an idiomatic choice that an experienced haskeller would make?
12:19:49 <monochrom> well_order :: t -> t -> Bool
12:19:52 <sinelaw> @pl (\b a -> (b, f a))
12:19:52 <lambdabot> (. f) . (,)
12:20:00 <monochrom> data Blah = .... deriving WellOrder
12:20:11 <roconnor> BrianHV: filter
12:20:17 <c_wraith> BrianHV: generally the call to filter is easier to read and understand
12:20:17 <roconnor> BrianHV: but only by a little
12:20:19 <lpsmith> so can anybody explain to me what "rank" is?   as in:      An immediate observation is that the monad for continuations does not have a rank while the monads for all the other above-mentioned computational effects do.
12:20:19 <jmcarthur> BrianHV: it's a stylistic decision. i tend to avoid list comprehensions, but a lot of us use them all the time
12:20:30 <sinelaw> @type second
12:20:31 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
12:20:33 <Jafet> How is a list comprehension comparable to filter?
12:20:34 <tensorpudding> I want an unsafePerformMathematics that accepts well-formed formulas and produces booleans.
12:20:36 <BrianHV> thanks all
12:20:38 <zygoloid> tensorpudding: (unsafeReconstructSphere *** unsafeReconstructSphere) . performSomeIrrationalRotations . (take 2 &&& take 3) . unsafeSplitSphereInto5Pieces $ sphereOfSolidGold
12:20:44 <lpsmith> I'm reading "Notions of Computation determine Monads"  http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.58.8004
12:21:04 <Twey> I use list comprehensions when I need non-explosive pattern matching in my filter/map, or when it saves on brackets
12:21:06 <Jafet> tensorpudding, bottom's up!
12:21:09 <sinelaw> > arr (const 0 &&& const 1)
12:21:10 <lambdabot>   No instance for (GHC.Show.Show (a b (t, t1)))
12:21:10 <lambdabot>    arising from a use of `M68...
12:21:15 <sinelaw> > (const 0 &&& const 1) 2
12:21:16 <lpsmith> there is a reference, but It's not easily available to me ATM
12:21:17 <lambdabot>   (0,1)
12:21:17 <zygoloid> Jafet: and the enemy's gate is down?
12:21:37 <Jafet> I hope that is not a reference to twinking
12:21:54 <Saizan_> Jafet: [ x | x <- xs; p x ] = filter p xs
12:21:54 <tensorpudding> @quote unsafe
12:21:55 <lambdabot> Binkley says: [Monads as clothes] <Binkley> using unsafePerformIO is kind of like going naked in public, might be safe in some contexts, but you really don't want to know what happensif you do it in
12:21:55 <lambdabot> a really bad one
12:21:59 <zygoloid> Jafet: what's twinking?
12:22:06 <Saizan_> Jafet: s/;/,/
12:22:23 <Jafet> Saizan, oh right. I use that rarely
12:29:33 <Apocalisp> What structure in general describes a functor that can be "empty"?
12:29:49 <Apocalisp> A free monad?
12:30:12 <Apocalisp> no
12:30:24 <BONUS> empty how
12:30:42 <Apocalisp> f a = 1 + g a
12:31:01 <BONUS> oh like Maybe and such. hmm idk
12:31:11 <Apocalisp> Maybe just Maybe :)
12:31:45 <BONUS> would you consider Either e such a functor?
12:32:02 <copumpkin> what do you even mean by empty?
12:32:14 <Apocalisp> BONUS: Yes, I suppose I would
12:32:43 <BONUS> probably that there's such a constructor for which fmap f x = x for every f
12:33:10 <Apocalisp> yes, that's a good property to describe it
12:33:35 <Apocalisp> Seeing that every such functor is isomorphic to Maybe ...
12:33:45 <Apocalisp> maybe I should just use that :(
12:33:49 <Apocalisp> I mean... :)
12:33:55 <BONUS> Apocalisp: what about [a]_
12:34:00 <BONUS> _=?
12:34:23 <Apocalisp> [a] ~= Maybe (a, [a])
12:34:26 <wavewave> how can I make a cabal which also make a c library?
12:34:51 <wavewave> My package will have a source directory of c codes
12:34:58 <wavewave> and makefile for it.
12:35:11 <wavewave> I will call it using FFI from haskell later.
12:35:18 <dcoutts_> wavewave: cabal can compile simple C libs
12:35:53 <wavewave> dcoutts_: my c code has somewhat many dependency with other c libs...
12:36:02 <wavewave> dcoutt_: can I just use makefile for it?
12:36:09 <dcoutts_> wavewave: yes, but it's more work
12:36:16 <dcoutts_> you'll have to write code in Setup.hs
12:36:32 <dcoutts_> wavewave: alternatively, make the C bit separate
12:36:46 <dcoutts_> and have the Haskell lib link to the separate C lib
12:37:11 <wavewave> dcoutts_: hmm. but.. this is just a wrapper function for haskell.
12:37:40 <wavewave> dcoutts_: making seperate library seems to me too much..
12:37:45 <dcoutts_> wavewave: if it's simple C code then you can have Cabal compile the C code and link it into the Haskell libary
12:38:01 <dcoutts_> it's ok that the C code depends on external C libs
12:38:08 <wavewave> dcoutts_: oh.. I see.
12:38:13 <sinelaw> @hoogle (Fractional a , Integral b) => a -> b
12:38:13 <lambdabot> Prelude ceiling :: (RealFrac a, Integral b) => a -> b
12:38:14 <lambdabot> Prelude floor :: (RealFrac a, Integral b) => a -> b
12:38:14 <lambdabot> Prelude round :: (RealFrac a, Integral b) => a -> b
12:38:22 <wavewave> dcoutts_: btw, it's c++..
12:38:37 <sinelaw> @type ^-^
12:38:38 <lambdabot> parse error on input `^-^'
12:38:40 <sinelaw> @type (^-^)
12:38:41 <lambdabot> Not in scope: `^-^'
12:38:42 <wavewave> dcoutts_: is it different
12:38:43 <dcoutts_> wavewave: you just specify that the Haskell package depends on those external libs
12:38:43 <wavewave> ?
12:38:45 <sinelaw> @hoogle (^-^)
12:38:46 <lambdabot> No results found
12:38:55 <sinelaw> damn, lambdabot doesn't know about vector-space.
12:39:11 <dcoutts_> wavewave: you mean the external libs are C++ or the bit of glue code that you will use with the FFI is C++ ?
12:39:22 <sinelaw> @pl (\(x,y) -> (f x, f y))
12:39:22 <lambdabot> f *** f
12:39:35 <sinelaw> ooh is that new?
12:39:38 <BONUS> since when does @pl know about ***
12:39:45 <sinelaw> i mean pl's awareness of ***
12:39:49 <sinelaw> cool!
12:39:54 <wavewave> dcoutts_: it uses some object in some c++ library..
12:39:55 <BONUS> @pl (\(x,y) -> (f x,f y))
12:39:55 <lambdabot> f *** f
12:40:02 <BONUS> wait i mean
12:40:06 <sinelaw> it usually throws the liftM2 (,) thingy i think
12:40:12 <wavewave> dcoutts_: should I change it to C?
12:40:12 <BONUS> @pl (\x -> (f x,g y))
12:40:13 <lambdabot> flip (,) (g y) . f
12:40:19 <sinelaw> @type liftM2 (,)
12:40:21 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
12:40:22 <dcoutts_> wavewave: that's fine, so long as it exports C API functions for the Haskell FFI
12:40:28 <jmcarthur> @pl \f g x = (f x, g x)
12:40:29 <lambdabot> (line 1, column 8):
12:40:29 <lambdabot> unexpected "="
12:40:29 <lambdabot> expecting pattern or "->"
12:40:31 <dcoutts_> wavewave: the FFI is only for C, not C++
12:40:34 <jmcarthur> @pl \f g x -> (f x, g x)
12:40:34 <lambdabot> liftM2 (,)
12:40:35 <BONUS> it doesn't seem to know about &&& though
12:40:55 <dcoutts_> wavewave: so your glue code has to export C functions, which you can do with C or C++
12:41:07 <wavewave> dcoutts_: I see.
12:41:23 <dcoutts_> wavewave: you know about the C++ "extern C" feature I presume
12:41:44 <wavewave> dcoutts_: so cabal can call g++, and FFI needs only C binding.
12:42:41 <dcoutts_> wavewave: cabal actually calls ghc, telling it to compile C code, ghc calls gcc, which compiles the C or C++ code
12:42:55 <dcoutts_> people tell me it works with C++ :-0
12:42:58 * dcoutts_ has never tried
12:43:09 <wavewave> dcoutts_: I see. thanks a lot!
12:43:13 <jmcarthur> makes sense to me
12:43:17 <jmcarthur> that it would work
12:43:17 <dcoutts_> np
12:43:23 <Cale> hmm... if there any good reason that the class and type namespaces aren't separate?
12:43:24 <lambdabot> Cale: You have 4 new messages. '/msg lambdabot @messages' to read them.
12:43:31 <jmcarthur> i'd hate to bind to c++ though. so tedious
12:43:40 <Cale> what, messages...
12:43:49 <dcoutts_> Cale: import/export ambiguity I think, that's all
12:43:55 <Igloo> Cale: Not really. In some cases they are currently ambiguous
12:44:02 <dcoutts_> Cale: I want data types with the same name as a class
12:44:05 <wavewave> I am now using Root / an analysis package..
12:44:07 <jmcarthur> that's all? shame. seems we could work around that
12:44:13 <dcoutts_> Cale: eg for the most general instance of a class
12:44:23 <Igloo> But you can fix that, e.g. exporting "class C" rather than "C"
12:44:41 <wavewave> I think it would be great if we have haskell wrapper for all ROOT.
12:44:52 <jmcarthur> all ROOT?
12:44:57 <Cale> dcoutts_: I'm just running into the issue because I'm writing a dehenningifier
12:45:04 <wavewave> root.cern.ch
12:45:13 <Igloo> heh
12:45:21 <wavewave> it's official analysis package developed for LHC
12:45:22 <copumpkin> lol
12:45:38 <dcoutts_> Cale: what does that do?
12:45:38 <Cale> and I want to rename the type T or class C to the last part of the module path, but there's a possibility of conflicts
12:45:55 <copumpkin> does it take a package as input and give you a new package without HT's naming?
12:46:10 <Cale> copumpkin: That's the idea -- just a module at first
12:46:15 <copumpkin> mmm
12:47:17 <jmcarthur> lol
12:47:25 <jmcarthur> an excellent idea
12:47:46 <copumpkin> using haskell-src-exts?
12:47:51 <Cale> yeah
12:47:52 <applicative> how will the program choose new names?  /usr/bin/dict
12:48:00 <Cale> applicative: The last part of the module path
12:48:10 <jmcarthur> i don't understand HT's style at all... i mean, i see the system, but i see no benefit to it
12:48:17 <Cale> So Foo.Bar.T -> Bar
12:48:26 <Cale> and Foo.Bar.C -> Bar
12:48:54 <Cale> Except that leads to the potential for conflict.
12:48:58 * ezyang is confused why #haskell is still discussing HT style ^^" 
12:49:02 <jmcarthur> if class and type didn't share namespaces we could also have e.g. State instead of MonadState
12:49:04 <applicative> what is the worst module
12:49:08 <jmcarthur> would be much awesome
12:49:11 <applicative> i mean, from this point of view
12:49:15 <Cale> ezyang: Because I'm writing a program to try to undo it?
12:49:23 <ezyang> Cale: Ooh, I missed that message :^)
12:49:30 <copumpkin> ezyang: because he writes stuff that we want but we don't like his style
12:49:31 <applicative> he's writing HTlint
12:50:21 <jmcarthur> oh i didn't get that joke
12:50:28 <jmcarthur> i was googling HTlint
12:50:33 <Cale> In particular, I want to dehenning the numeric-prelude package
12:50:49 <jmcarthur> i want you to do that too
12:50:50 <Cale> and some things which use it
12:50:51 <jmcarthur> ;)
12:51:06 <copumpkin> what will you call your package?
12:51:07 <Cale> I think I'll call it numeric-prelude-sane
12:51:07 <copumpkin> dehenning?
12:51:09 <ski> lpsmith : maybe "rank" there actually was "higher rank" ?
12:51:17 <Cale> My program is called dehenning
12:51:19 <Twey> jmcarthur: They don't share namespaces
12:51:26 <Twey> I think MonadState is just to avoid confusion
12:51:38 <jmcarthur> Twey: umm... are you sure?
12:51:43 <sinelaw> what's down with github?
12:51:46 <applicative> numeric prelude, my god.
12:51:48 <Twey> Pretty sure.  IIRC, I checked it before.
12:51:57 <ski> Apocalisp : maybe related or interesting, edwardk defined a monad `m' to be "ideal", if there is some functor `f' such that `forall a.  m a  ~=  a + f a'
12:51:58 <lpsmith> ski:  I don't think so
12:52:01 <jmcarthur> i thought i had done the same with negative results
12:52:05 <sinelaw> the internetz are crumbling
12:52:07 <Cale> applicative: What about it?
12:52:07 <copumpkin> Cale: be careful, he might release henningify as a response to that and fork all of hackage, with automatic henningification of all packages in it
12:52:12 <ski> Apocalisp : see <http://hackage.haskell.org/packages/archive/category-extras/0.52.0/doc/html/Control-Monad-Ideal.html>
12:52:19 <Cale> copumpkin: He can do that.
12:52:22 <ski> lpsmith : then i have no idea ..
12:52:29 <jmcarthur> Twey: as we discussed above, it's the same namespace so that it's easy to write export lists and such
12:52:33 <ezyang> the Henningopalypse
12:52:37 <jmcarthur> otherwise you can't disambiguate
12:52:43 <Twey> Oh, huh
12:52:54 <Twey> Maybe I misremembered.
12:53:06 <applicative> class (C a, C a, Ord a) => C a where
12:53:09 <copumpkin> misunderestimated
12:53:16 <Cale> I wonder if there actually *is* a module M of Henning's which defines both M.T and M.C
12:53:17 <jmcarthur> i wish we could export with "class State" or something to disambiguate though, instead of having them share name spaces
12:53:32 <jmcarthur> we already do the same for modules
12:53:33 <Cale> applicative: yeah, it makes the documentation unreadable
12:53:50 <Twey> Cale: Write it and append "Class" in case of conflict?
12:54:03 <Twey> Or just "C"
12:54:22 <Cale> I'm starting to wonder if I shouldn't just make it a two-step process...
12:54:23 <roconnor> ezyang: data-accessor is awesome!
12:54:25 <Apocalisp> Thanks, ski
12:54:54 <ski> Cale : i think TH's style is too extreme .. but, it *would* be nice if haddock could disambiguate identifiers in pages where several bindings of the same base identifier(s) are in scope
12:54:56 <Apocalisp> So an ideal monad is isomorphic to its free monad?
12:55:07 <Cale> Collect a list of the Henningisms in a file along with their default renames, and then allow the user to edit it before applying the changes.
12:55:09 <lpsmith> ezyang, Cale:  Henning's style comes from Modula-3,  and it was quite elegant in that setting.   E.G. if you wrote a module called "Vector",  then you'd have Vector.T,  Vector.add,  etc etc.
12:55:30 <applicative> funny, now that you attribute it to a personality, it doesn't seem figuring it out would be as hopeless
12:55:37 <ezyang> lpsmith: I saw your comment. Blame "Henning-ism" on byorgey :o)
12:55:51 <ski> Apocalisp : no, the free monad `m' on a functor `f' is defined as the least `m' satisfying `forall a.  m a  ~=  a + f (m a)' .. note the difference with the above
12:55:59 <Cale> ezyang: hm?
12:56:12 <Cale> ezyang: I didn't think it originated with Brent...
12:56:33 <ezyang> Cale: Oh, as in, the name "Henning-ism" came from a conversation yesterday when Brent was explaining what was up with T and C
12:56:36 <lpsmith> Cale is opposed to qualified names for some reason
12:56:38 <Cale> Oh
12:56:44 <Cale> Yes, I am.
12:56:59 <Cale> Brent's 'species' package suffers from the henningisms in the numeric prelude
12:57:04 <lpsmith> I know you are,  I've heard (at least part) of it before
12:57:06 <roconnor> ezyang: oh I had a long discussion on #haskell once about the difference between data accessor and semantic editor combinators.
12:57:08 <Cale> So it'll be nice to fix it up as well :)
12:57:15 <Apocalisp> ski: OK, yeah, I see
12:57:43 <lpsmith> See,  I think it's unfortunate Haskell didn't have qualified names earlier,  so it is a deeper part of the culture
12:57:46 <Cale> lpsmith: One of the main reasons that I hate qualified identifiers is that the module qualification separator is '.'
12:57:47 <roconnor> semantic editor combintors are just functors.
12:58:07 <Cale> lpsmith: and (.) is the most common infix operator in essentially all the code I write
12:58:09 <roconnor> and only can do the modify operation.  data-accessor has set and get
12:58:15 <ezyang> roconnor: Oh, ok
12:58:17 <jmcarthur> we culd stick with '.' for that if we used unicode composition character ;)
12:58:29 <jmcarthur> *could
12:58:31 <ski> lpsmith : i can agree on that, i think .. however, i don't think it's that good to go out of your way to reuse the same identifiers ..
12:58:32 <roconnor> but you are right in one sense
12:58:35 <Cale> jmcarthur: I hate that idea, because âˆ˜ is too difficult to type
12:58:44 <roconnor> ezyang: every data-accessor is a semantic editor
12:58:49 <jmcarthur> Cale: yeah there's a reason i didn't type it here
12:58:53 <ezyang> Cale: You oughtta see Fortress
12:59:02 * Jafet hands Cale a refurbished APL keyboard
12:59:05 <ezyang> they compile to LaTeX :^)
12:59:08 <Cale> I would actually prefer using âˆ˜ for module separation if it came down to that (but it would be silly)
12:59:15 <jmcarthur> heh
12:59:26 <Cale> âˆ˜ is 3 keypresses for me, and I still think it's way too much.
12:59:31 <lpsmith> Cale:  yes,  I admit that that is one of Haskell's warts,  but I also think that one should usually be putting spaces around infix functions anyway
12:59:40 <Cale> Well, 3 keypresses + ensuring that my keyboard is in the appropriate mode
13:00:00 <roconnor> ezyang: because every data-accessor has a modify function
13:00:02 <Cale> lpsmith: Oh, and I do, it's not the concern over real ambiguity that I worry about
13:00:09 <Cale> lpsmith: It's just that it's visually awful.
13:00:11 <roconnor> granted it isn't a polymorphic modify function
13:00:12 <roconnor> but tsill
13:00:13 <ski> imo qualification is for knowing from where you import your identfiers (when that isn't that obvious) (in some cases because different modules are many to export a uniform interface), and for handling the eventually unavoidable social problem of different people reusing the same identifiers
13:00:14 <roconnor> still
13:00:22 <ezyang> oconnor: Ok, so it's "more powerful" than a semantic editor combinator
13:00:27 <ezyang> *roconnor
13:00:27 <mjrosenb> Cale: so on a terminal where all unicode shows up a "?", this conversation is signifigantly more interesting
13:00:31 <sinelaw> @pl (\(a,b) (c,d) -> (a-c, b-d))
13:00:31 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (-)) . flip . (((.) . (,)) .) . (-))
13:00:37 <Cale> mjrosenb: heh
13:00:43 <mjrosenb> *hows up as
13:00:47 * mjrosenb fail
13:00:51 <lpsmith> ski:  why shouldn't you go out of your way to reuse identifiers?
13:00:53 <sinelaw> uh
13:01:50 <ski> lpsmith : i mean, in the case where you're not specifically trying to comform to the same interface (like defining various `map' functions)
13:02:22 <lpsmith> ski:  ok, yes, that does make more sense;  although at least in Modula-3,  the T convention was handy
13:02:27 <Cale> I also, for a reason I can't identify, just can't stand to use qualified names in types.
13:02:33 <lpsmith> You didn't have to remember type names, by and large
13:02:54 <ski> lpsmith : i can see how it could be useful in some special circumstances, yes ..
13:03:05 <Cale> I'm not sure why, but I think qualified names just look awful and redundant in type expressions.
13:03:10 <lpsmith> It's a bit less useful in Haskell because of type parameters
13:03:33 <mjrosenb> Cale: you *could* say type Foo = Bar.Quux.foo at the top of every module :-
13:03:34 <copumpkin> they add noise
13:03:37 <mjrosenb> *:-p
13:03:38 <ski> (and, it *is* sometimes tiresome to have `Data.Either.Either' or `Control.Monad.State.MonadState', &c.)
13:03:38 <lpsmith> But M3's type constructors weren't parameterizable, so...
13:03:48 <jmcarthur> i avoid qualified types because i think they look cluttered, but i don't think they are inherently bad
13:04:07 <jmcarthur> *qualified identifiers
13:04:52 <Cale> Yeah, and that's another painful thing -- the use of qualified names means that I usually end up having two imports for many modules: one to import qualified the module, and then another to import some things unqualified where that will be unambiguous.
13:05:13 <ski> roconnor : "polymorphic modify function" would be ?
13:05:19 <Cale> Perhaps I should just write  import Data.Set as Set  and only disambiguate where necessary
13:05:24 <jmcarthur> i wish i could have scoped imports
13:05:43 <contrafunktal> yes
13:05:44 <roconnor> ski: fmap
13:05:47 <lpsmith> well,  pythons  "from module import identifiers" is directly taken from Modula-3;  the difference is that M3 made qualified names the default,  with unqualified imports the extra,  which is opposite Haskell of course
13:05:58 <Cale> One thing that I rather like is that you can import multiple modules under the same name :)
13:06:00 * contrafunktal wonders if TH reify could know what was in scope, from which modules
13:06:10 <roconnor> ski: semantic editor comibinator is just a fancy way of saying functor
13:06:13 <lpsmith> Cale:  agreed,  I like that about Haskell too :)
13:06:18 <Cale> So you can import a bunch of SDL modules, say, and name them all SDL
13:06:23 <ski> Cale : yes, it'd be nice if one could both import a module qualified *and* specify some identifiers to import unqualified
13:06:27 <jmcarthur> oh i didn't even know that
13:06:29 <ski> (in one go)
13:06:39 <Cale> ski: yes
13:06:48 <sinelaw> @pl (\(a,b) -> (f a, f b))
13:06:48 <lambdabot> f *** f
13:06:55 <contrafunktal> then you could write:    $(unqualified "Data.Set") ....
13:06:59 <roconnor> ezyang: depends if you think more powerful means having more operations or having a wider scope of applications.
13:06:59 <sinelaw> oops, again.
13:07:04 <sinelaw> @pl (\f -> f *** f)
13:07:04 <lambdabot> join (***)
13:07:09 <sinelaw> aha! coolnes..
13:07:22 <sinelaw> @type join
13:07:23 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
13:07:33 <lpsmith> heh,   import qualified Module (foo,bar)   means that you can only refer to Module.foo and Module.bar
13:07:34 <sinelaw> weird.
13:07:43 <contrafunktal> jmcarthur: alternatively, a quasiquoter that gives some variable renaming
13:07:44 <ezyang> roconnor: True.
13:07:48 <lpsmith> I guess that makes sense given that you can import multiple modules qualified as the same name
13:08:05 <sinelaw> join on functions is passing the same arg twice?
13:08:09 <ski> jmcarthur : sometimes i'm thinking i want submodules (often just for local use, not exporting them) .. maybe that's a sign from $DEITY that i need to split my modules, though
13:08:10 <jmcarthur> contrafunktal: i'm not a huge fan of macros. probably for similar reasons that i'm not a huge fan of qualified imports
13:08:13 <contrafunktal> however, it's not possible to nicely pass arguments to quasiquoters
13:08:17 <philo> any quick way to verifier if x as the form 2^y +1 where y  =< 5 ?
13:08:26 <philo> verify
13:08:42 <sinelaw> @type join (***) fromIntegral
13:08:43 <lambdabot> forall b c. (Integral b, Num c) => (b, b) -> (c, c)
13:09:13 <Cale> > [2^y + 1 | y <- [0..5]]
13:09:14 <lambdabot>   [2,3,5,9,17,33]
13:09:17 <jmcarthur> @. pl djinn (a -> b) -> (a, a) -> (b, b)
13:09:18 <lambdabot> f = (`ap` snd) . (. fst) . (const .) . (ap =<< ((,) .))
13:09:20 <sepp2k> philo: And y >= 0?
13:09:25 <ski> (it would be nice if i could define a datatype, and a couple of "primitive" functions in a sub-module, then defining convenience functions in terms of those abstractly, without being able to access the representation, and finally exporting things without telling the user how i structured the library internally)
13:09:25 <philo> yes
13:09:26 <lpsmith> philo:   is testing that the integer is odd,  then shifting left and ensuring that it is even until you get to one quick enough?
13:09:27 <jmcarthur> o_O
13:09:48 <Cale> > filter (`elem` [2^y + 1 | y <- [0..5]]) [0..20]
13:09:49 <lambdabot>   [2,3,5,9,17]
13:09:49 <jmcarthur> ski: well, with cabal you can just selectively expose modules, at least
13:10:01 <ski> *nod*
13:10:08 <jmcarthur> ski: i was really getting at scoped imports, not sub modules. (both would be very nice though)
13:10:18 <jmcarthur> ski: and while we're at it, parameterized modules :)
13:10:20 <philo> thanks
13:10:46 <lpsmith> err,  shifting right,  for some reason I always get shiftR and shiftL mixed up
13:10:50 <lpsmith> Not in C, mind you
13:10:59 <lpsmith> But for some reason I always make that mistake in Haskell
13:11:17 <philo> i need something fast Cale
13:11:28 <ski> i was just associating to sub-modules and "how i present my library to the user (the interface) should be (possible to be) decoupled from how i choose to organize my library internally"
13:11:35 <lpsmith> :t Data.Bits.shiftR
13:11:36 <lambdabot> forall a. (Bits a) => a -> Int -> a
13:11:43 <lpsmith> :t even
13:11:44 <lambdabot> forall a. (Integral a) => a -> Bool
13:11:48 <lpsmith> :t odd
13:11:49 <lambdabot> forall a. (Integral a) => a -> Bool
13:11:59 <lpsmith> :t (==1)
13:12:01 <lambdabot> forall a. (Num a) => a -> Bool
13:12:01 <lpsmith> :)
13:12:02 <jmcarthur> ski: yes, that is a good separation, in my opinion
13:12:16 <ski> jmcarthur : but yes, that'd be nice, too (e.g. possibly for avoiding the `s' parameters on everything using `ST' .. instead parameterize module (if `s' is uniformly used, i.e.))
13:12:38 <lpsmith> >   17 `Data.Bits.shiftR` 1
13:12:39 <ski> s/internally/internally (the implementation)/
13:12:39 <lambdabot>   Ambiguous type variable `t' in the constraint:
13:12:39 <lambdabot>    `Data.Bits.Bits t'
13:12:40 <lambdabot>      a...
13:12:45 <lpsmith> >   17 `Data.Bits.shiftR` 1 :: Integer
13:12:46 <lambdabot>   8
13:12:50 <Cale> philo: there are only 6 elements of that list to check
13:12:58 <ski> sinelaw : yes
13:13:08 <sinelaw> k
13:13:26 <jmcarthur> ski: that is not a use case i had thought of for parameterized modules
13:13:43 <lpsmith> Actually, what might be even faster is testBit
13:13:51 <wavewave> Hi, I am again stuck with cabal and FFI.
13:14:05 <lispy> wavewave: how so?
13:14:10 <Cale> By messing around with the bits and/or even/odd, you can maybe get something faster, but it's questionable :)
13:14:17 <lispy> wavewave: You might need to use hsc2hs
13:14:24 <wavewave> undefined refence to 'mycfunctionname'
13:14:28 <Cale> I would worry about it after it's shown that the performance is a problem
13:14:35 <lpsmith> >   map (testBit (17 :: Integer)) [1..5]
13:14:36 <lambdabot>   [False,False,False,True,False]
13:14:38 <wavewave> lispy: Ahh...
13:14:40 <lpsmith> >   map (testBit (17 :: Integer)) [0..5]
13:14:41 <lambdabot>   [True,False,False,False,True,False]
13:14:43 <philo> so what if i want the output in the form (y,a) where x = 2*y +a
13:14:58 <sinelaw> cool, i wrote a program that tells my robot to follow faces, in 64 lines of haskell (after all libs are in place :)
13:14:59 <Cale> divmod?
13:15:01 <Cale> divMod
13:15:08 <Cale> > divMod 472891 2
13:15:09 <lambdabot>   (236445,1)
13:15:11 <sinelaw> and its composable!
13:15:14 <wavewave> lispy: so I should not have 'foreign import  ccall' in my hs code?
13:15:15 <philo> :t testBit
13:15:16 <lambdabot> forall a. (Bits a) => a -> Int -> Bool
13:15:20 <sinelaw> not do-notation crap
13:15:25 <ski> jmcarthur : and while we're at it, if we define an operation (e.g. polymorphic in a type variable `a'), then it should be possibly to define local datatypes in a `where' (that must not escape, except hidden inside existentials) (and which can refer to `a' without `a' being an (explicit) parameter of them)
13:15:32 <lispy> wavewave: GHC ignores #includes and whatnot.  There used to be a bug where you could use -fvia-C, but that was fixed.  These days if you want #includes and CPP magic hsc2hs is best
13:15:41 <lispy> wavewave: that part is fine
13:15:52 <lispy> shapr: !
13:15:52 <lpsmith> hmm... although testBit has the issue that how do you know when to stop testing?
13:15:59 <shapr> lispy!
13:16:08 <ski> jmcarthur : i had an example of a function polymorphic in `a',`b',`c', where i defined two temporary types that had to take all these as parameters .. a bit long-winded
13:16:11 <lispy> shapr: how are classes?
13:16:13 <sinelaw> is github down?
13:16:26 <shapr> lispy: My one and only class, InfoSec, is lots of fun!
13:16:40 <lispy> shapr: cool
13:16:53 <Cale> Oh, heh, this problem of renaming is slightly trickier than I thought because of import renaming.
13:17:04 <Cale> hmm
13:17:05 <lispy> wavewave: And using hsc2hs with cabal is pretty much trivial.  You just name your file correctly and Cabal should do the rest
13:17:33 <sinelaw> wavewave if you want to see some example code, i'd link you to it but github is down.
13:17:41 <lispy> wavewave: if you're still stuck, sharing your repository or a simple example on hpaste might help
13:17:43 <philo> Cale ... 2*y+a ?
13:17:44 <wavewave> lispy: I see.. I am now changing some code.
13:18:00 <sinelaw> wavewave, alternatively you can do: cabal unpack HOpenCV and look at the .cabal and the .hsc files there
13:18:03 <Cale> philo: hm?
13:18:10 <Cale> > divMod 472891 2
13:18:11 <lambdabot>   (236445,1)
13:18:15 <wavewave> sinelaw, lispy: thx.
13:18:24 <Cale> > 2*236445 + 1
13:18:25 <lambdabot>   472891
13:18:30 <philo> i emeant i want x = 2^y +a not x = 2*y+a
13:18:41 <Cale> ah
13:19:03 <Cale> Does it have to work for very large x?
13:19:15 <Cale> You could just take a base 2 logarithm
13:19:29 <Cale> (and floor it)
13:19:52 <Cale> If that's insufficient, then just divide by 2 a bunch.
13:20:11 <philo> ok
13:20:55 <Cale> There might be something more effective if the numbers are likely to be extremely large (like testing 2^(2^k) for various k, and then doing bisection)
13:24:06 <lispy> Does gmp provide fast modular exponentiation?
13:24:17 <lispy> If so, it would be cool to expose that through Haskell
13:24:18 <Guest27440> > let ilog2 x = last . map fst . takeWhile ((<= x) . snd) . zip [0..] . iterate (* 2) $ 1 in ilog2 66000
13:24:19 <lambdabot>   16
13:24:59 <lispy> In fact, there are probably other interesting things like that that could be exposed to Haskell
13:25:23 <lispy> But, I don't really know if that makes sense or not
13:25:26 <Guest27440> oh, i'm a "Guest". that means i left my macbook running in the other room. thanks, freenode.
13:25:29 <Cale> GMP contains routines for arbitrary precision floating point arithmetic which might be nice
13:25:54 <lispy> Cale: and most likely much more efficient than rolling our own
13:26:00 <philo> how to do that [32..1] ?
13:26:08 <Cale> [32,31..1]
13:26:10 <jmcarthur> > [32, 31 .. 1]
13:26:11 <lambdabot>   [32,31,30,29,28,27,26,25,24,23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7...
13:26:11 <Guest27440> > [32,31..1]
13:26:12 <lambdabot>   [32,31,30,29,28,27,26,25,24,23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7...
13:26:14 <lispy> > [32,31..]
13:26:15 <lambdabot>   [32,31,30,29,28,27,26,25,24,23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7...
13:26:18 <jmcarthur> lol
13:26:19 <Cale> heh
13:26:21 <philo> lol
13:26:22 <philo> thanks
13:26:23 <tac-tics> What does a ? Mean in a pattern: let ?x = y
13:26:34 <lispy> tac-tics: implicit param
13:26:36 <Cale> tac-tics: Implicit parameters, it's an extension
13:27:01 <lispy> tac-tics: generally they are considered a bad idea, but when you're asking lambdabot for a type it's nice
13:27:13 <lispy> :t ?x * 2
13:27:14 <lambdabot> forall a. (?x::a, Num a) => a
13:28:06 <tac-tics> I just ran across some code with them. How do they affect evaluation?
13:28:37 <Guest27440> @go ghc implicit parameters
13:28:38 <lambdabot> Maybe you meant: google googleit do
13:28:45 <Guest27440> @google ghc implicit parameters
13:28:46 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html
13:28:46 <lambdabot> Title: 7.8.ï¿½Other type system extensions
13:28:55 <Cale> tac-tics: A function which depends on some implicit parameters will have those parameters show up in the class context for its type. The parameters can be set locally using let/in
13:28:58 <tac-tics> Thanks
13:29:48 <Cale> @let foo xs = map ?bar xs
13:29:48 <lambdabot>  <local>:5:13: Not in scope: `?'
13:29:49 <lambdabot>  
13:29:49 <lambdabot>  <local>:5:14: Not in scope: `bar'
13:29:52 <Cale> oh, heh
13:30:48 <Cale> > let foo xs = map ?bar xs in   let ?bar = reverse in  foo ["hello", "there", "implicit", "parameters"]
13:30:49 <lambdabot>   ["olleh","ereht","ticilpmi","sretemarap"]
13:31:25 <BONUS> implicit parameters are so gross. implicit type parameters on the other hand ...
13:31:41 <BONUS> what's the argument against implicit type parameters again?
13:31:51 <contrafunktal> polymorphism
13:31:56 <Twey> I used to think they were a bad idea, but after reading the paper on implicit configurations I think I've changed my mind a little
13:32:10 <tac-tics> > let foo xs = map bar xs in let bar = reverse in foo ["abc"]
13:32:10 <lambdabot>   Not in scope: `bar'
13:32:14 <Twey> I'd quite like a way to specify them that's distinct from let/in, though.
13:32:20 <BONUS> i mean like instance Monoid w => Monad (?a,w) where ...
13:32:32 <tac-tics> > let foo xs = map ?bar xs in let ?bar = reverse in foo ["abc"]
13:32:33 <lambdabot>   ["cba"]
13:32:38 <tac-tics> Ah, I see
13:32:50 <Cale> :t let foo xs = map ?bar xs in foo
13:32:51 <lambdabot> forall a b. (?bar::a -> b) => [a] -> [b]
13:33:32 <tac-tics> > let foo xs = map ?bar xs in foo ["abc"]
13:33:33 <lambdabot>   Unbound implicit parameter (?bar::[GHC.Types.Char] -> b)
13:33:33 <lambdabot>    arising from a ...
13:33:37 <Cale> It's pretty clever in how it works so seamlessly with polymorphism :)
13:33:49 <tac-tics> So they are like lisp dynamic vars, right?
13:33:56 <Twey> Similar
13:34:00 <Cale> > let ?bar = reverse in let foo xs = map ?bar xs in foo ["abc"]
13:34:01 <lambdabot>   ["cba"]
13:34:14 <Cale> ^^ this is sorta weird
13:34:40 <Cale> They're like a strange blend of lexical and dynamic scope
13:34:59 <Twey> > let foo = map ?bar in let baz = foo in let ?bar = reverse in baz ["abc"]
13:35:00 <lambdabot>   Unbound implicit parameter (?bar::[GHC.Types.Char] -> b)
13:35:00 <lambdabot>    arising from a ...
13:35:04 <Twey> Damn
13:35:12 <Twey> > let foo = map ?bar in let baz = foo in let ?bar = reverse in foo ["abc"]
13:35:13 <lambdabot>   Unbound implicit parameter (?bar::[GHC.Types.Char] -> b)
13:35:13 <lambdabot>    arising from a ...
13:35:21 <Twey> Wait, what
13:35:37 <contrafunktal> > let ?f = (+1.0) in ?f 1
13:35:38 <lambdabot>   2.0
13:35:40 <DrSyzygy> So I have this library I've written for a research project. And it defines a typeclass, which requires a couple of functions, parametrized by the type in the typeclass, and one more type.
13:35:44 <DrSyzygy> So
13:35:45 <DrSyzygy> class (Eq t, Show t) => TreeOrdering t where treeCompare :: (Ord a, Show a) => t -> DecoratedTree a -> DecoratedTree a -> Ordering
13:35:58 <contrafunktal> > let g = ?f in let ?f = (+1.0) in g 1
13:35:59 <Cale> > let ?x = 5 in let f y = y + ?x in let ?x = 0 in f 0
13:35:59 <lambdabot>   Unbound implicit parameter (?f::t -> a)
13:35:59 <lambdabot>    arising from a use of implicit p...
13:36:00 <lambdabot>   0
13:36:18 <DrSyzygy> Now, my collaborator has an implementation of TreeOrdering he wants to write, but he wants to restrict it to only work on DecoratedTree Int, instead of more generic DecoratedTree a.
13:36:32 <benmachine> implicit parameters are weird
13:36:36 <DrSyzygy> Is this possible? Or will we need to rewrite our code to do it?
13:37:05 <Cale> DrSyzygy: You will need to redefine the class
13:37:06 <contrafunktal> > $(tupE $ map stringE ["can","haz","TH?"])
13:37:07 <lambdabot>   <no location info>: parse error on input `$'
13:37:19 <DrSyzygy> Cale: Doh.
13:37:22 <Cale> DrSyzygy: Since the class says that the type of treeCompare is completely polymorphic in the type a
13:37:28 <xerox> contrafunktal: cant has.
13:37:30 <DrSyzygy> Cale: I'll need to make the class dependent on a?
13:37:37 <Cale> DrSyzygy: That's one option, yes
13:37:46 <DrSyzygy> Cale: Other options'd be?
13:37:46 * contrafunktal reads stringE as stringy
13:38:09 <contrafunktal> xerox: :(
13:38:13 <Cale> DrSyzygy: Actually, with that type, I don't think there is another option :)
13:38:20 <Cale> DrSyzygy: There are two ways to do it though
13:38:36 <Cale> DrSyzygy: You can either use multiparameter typeclasses, or you can use associated types
13:38:56 <DrSyzygy> ??
13:39:40 <Cale> With multiparameter typeclasses, it would look like:
13:39:41 <ski> (using MPTC allow you to not state FDs, or state more FDs than ATs would imply ..)
13:40:00 <Cale> class (Eq t, Show t) => TreeOrdering a t where treeCompare :: (Ord a, Show a) => t -> DecoratedTree a -> DecoratedTree a -> Ordering
13:40:32 <Cale> Actually, will associated types work in a reasonable way here? I don't think we want a functional dependency.
13:41:07 <DrSyzygy> CAn I then have polymorphic instantiations? So that I'd do something like instance (Ord a, Show a) => TreeOrdering a MyOrder where ...
13:41:23 <ski> BONUS : how would `instance Monoid w => Monad (?a,w) where ...' be interpreted ?
13:41:51 <BONUS> well, ?a would be the parameter that's missing
13:42:02 <BONUS> like instance Monad (Maybe ?a) where
13:42:03 <ski> BONUS : btw, in Scheme, the idea of having "implicit parameters" to macros have come up (and is implemented in PLT/Racket at least, iirc)
13:42:09 <BONUS> hmm
13:42:16 <Saizan_> DrSyzygy: yes, you can write that instance
13:42:27 <Cale> DrSyzygy: yeah, you might need some more extensions, but you can write that
13:42:48 <DrSyzygy> Oh Goody!
13:42:58 <DrSyzygy> Any idea where I find out which extra extensions this requires?
13:43:09 <Cale> DrSyzygy: Just try to compile it and follow GHC's advice
13:43:22 <Cale> You'll probably need at least FlexibleInstances
13:43:41 <Cale> and maybe OverlappingInstances, but that I'm less sure about
13:44:05 <DrSyzygy> Aight. It seems I have work to do. Thanks!!
13:47:27 <Cale> (Generally GHC provides good advice about what extensions you'll need in its error messages)
13:49:29 <jmcarthur> except when it suggests RankNTypes when you really want ScopedTypeVariables
13:51:21 <Saizan_> RankNTypes are good for your diet
13:51:56 <lispy> How do I see which optimizations are turned on by -O2?
13:52:08 <lispy> or even -O1 for that matter
13:53:16 <lispy> Do I have to read the GHC sources?
13:53:29 <contrafunktal> or does  RankNTypes => ScopedTypeVariables
13:53:31 <Saizan_> i think it's documented in the manual
13:53:40 <jmcarthur> contrafunktal: not that i know of
13:53:56 <Saizan_> contrafunktal: no, but they both allow the forall keyword
13:54:28 <jmcarthur> well, ghc manages to distinguish between needing RankNTypes and ExistentialQuantification, though, and they both allow forall
13:54:34 <lispy> Saizan_: hmm...I found this page: http://www.haskell.org/ghc/docs/latest/html/users_guide/options-optimise.html
13:54:42 <jmcarthur> it just doesn't suggest the right thing for STV
13:54:55 <lispy> Saizan_: but it doesn't enumerate the possible options or what -O1 stands
13:55:01 <lispy> "stands for"
13:55:30 <roconnor> > 0/0 == 0/0
13:55:31 <lambdabot>   False
13:55:45 <Saizan_> lispy: http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html <- search for "Implied by"
13:55:46 <jmcarthur> uh
13:55:53 <jmcarthur> that's not a helpful result
13:56:09 * hackagebot GPipe-Examples 0.1 - Examples for the GPipes package  http://hackage.haskell.org/package/GPipe-Examples-0.1 (KreeColeMcLaughlin)
13:56:22 <lispy> Saizan_: thanks!
13:56:28 <jmcarthur> ooh gpipe examples
13:56:38 <contrafunktal> there should be a pretty graphic showing how extensions are related
13:56:41 <jmcarthur> why does hackagebot /me everything?
13:57:26 <wavewave> still cabal with FFI not successful...
13:57:40 <wavewave> I changed them to hsc..
13:58:02 <Saizan_> what problem are you having, in particular?
13:58:05 <wavewave> undefined reference to 'myfunction'
13:58:33 <Saizan_> have you listed the relevant modules in the .cabal file?
13:58:40 <wavewave> Saizan_: I have c code which should be automatically compiled.
13:58:52 <wavewave> I think so...
13:58:58 <contrafunktal> but I suppose it isn't so impressive if this is all there is: http://hackage.haskell.org/packages/archive/haskell-src-exts/1.8.2/doc/html/src/Language-Haskell-Exts-Extension.html#impliesExts
13:59:06 <roconnor> > isNegativeZero (-0.0)
13:59:07 <lambdabot>   True
13:59:10 <roconnor> > isNegativeZero (0.0)
13:59:11 <lambdabot>   False
13:59:25 <wavewave> Saizan_: Exposed-Modules: has my module name which is defined in hsc file.
13:59:42 <ski> > 0.0 == (-0.0)
13:59:43 <lambdabot>   True
13:59:51 <jmcarthur> :o
13:59:58 <wavewave> and in dist directory.. the cpp code seems to have been compiled.
14:00:03 <hpc> IEEE floats are hilarious
14:00:12 <wavewave> I have .o file.
14:00:15 <jmcarthur> > 1 / (-0.0)
14:00:16 <lambdabot>   -Infinity
14:00:19 <tensorpudding> the topic of how IEEE floats are hilarious seems to come up often
14:00:20 <Saizan_> wavewave: tbc, is this .hsc file one for hsc2hs or just a C file?
14:00:36 <jmcarthur> > 1 / (-0.0) == 1 / (-0.0)
14:00:36 <lambdabot>   True
14:00:41 <wavewave> in haskell source directory, I have hsc file.
14:00:52 <Saizan_> yeah, but what does it contain?
14:00:55 <wavewave> Saizan_: and in C++ source directory, I have .cpp file.
14:01:31 <wavewave> Maybe I had better show you the cabal file.
14:01:49 <Saizan_> and the .hsc file :)
14:02:56 <EvanR-work> table :: Map String (String, String)
14:03:13 <wavewave> @hpaste
14:03:13 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
14:03:23 <EvanR-work> is there a way to at least describe what those things are supposed to be besides string?
14:03:35 <Saizan_> wavewave: maybe you've bumped into this http://hackage.haskell.org/trac/hackage/ticket/245 ?
14:04:24 <augur> has anyone heard of Chris Barker, of Iota/Jot fame?
14:04:36 <wavewave> Saizan_: no...
14:05:15 <Saizan_> wavewave: so you're not using #def to define a C function inside your .hsc file?
14:05:24 <wavewave> btw, hpaste seems to be down..
14:05:54 <Saizan_> yeah
14:05:59 <Saizan_> use pastebin.com
14:06:29 <EvanR-work> ah, by using type synonyms
14:12:20 * hackagebot yesod 0.0.0.2 - A library for creating RESTful web applications.  http://hackage.haskell.org/package/yesod-0.0.0.2 (MichaelSnoyman)
14:13:55 <wavewave> Saizan_: http://pastebin.com/MFbmi25W    this is my cabal file.
14:15:22 <Saizan_> and the .hsc file?
14:15:26 <wavewave> Saizan_: http://pastebin.com/E08zrJWD   this is my hsc file.
14:16:33 <Saizan_> that's just an haskell file
14:16:51 <Saizan_> but you've to add {-# LANGUAGE ForeignFunctionInterface #-} at the top
14:17:13 <wavewave> Saizan_ : http://pastebin.com/PrzfSigF  this is my makehist.h file.
14:17:28 <wavewave> Saizan_ : ahh.
14:18:42 <wavewave> Saizan_ : Now I added that pragma, but it didn't work..
14:18:50 <wavewave> so my hsc file is wrong?
14:20:39 <Saizan_> well, that's also a valid .hsc file, tbh
14:20:50 <Saizan_> maybe you've to add #include makehist.h though
14:21:11 <wavewave> where?
14:21:18 <wavewave> before foreign?
14:22:07 <Saizan_> yeah
14:24:40 <cybercobra> I don't grok this type error - http://ideone.com/892HU  any suggestions?
14:25:34 <Twey> cybercobra: There's no argument in that type
14:25:35 <Saizan_> IOW a function can't have type Maybe NonZeroPositiveInt
14:25:40 <Twey> What is the type of â€˜nâ€™?
14:25:50 <mauke> cybercobra: missing parens
14:26:07 <wavewave> Saizan_: it doesn't work.. =/
14:26:08 <Twey> mauke: Eh?
14:26:14 <mauke> line 4
14:26:35 <Twey> Ah, that too
14:26:42 <wavewave> Saizan_: I think I had better make an external C library for this...
14:27:07 <wavewave> Saizan_: making cabal compile my C code automatically is too hard.
14:27:09 <Saizan_> wavewave: but it's something that does work, i.e. the zlib package on windows uses this
14:27:38 <wavewave> Saizan_: Yes.. I noticed several packages do that...
14:27:55 <wavewave> Saizan_: Anyway, thank you very much for looking at this.
14:27:59 <cybercobra> mauke, Twey: thanks, got it workin now
14:28:13 <Saizan_> wavewave: you could try asking on -cafe, making the whole code accessible
14:28:41 <wavewave> Saizan_: I see. I will try to do that.
14:29:09 <inetic_> hi there, if I want to define a type Foo that holds an integer I would do it like this: e.g. "data Foo = Foo { i :: Int }", but what if I don't want it to hold an integer but a member of some class (say Eq), I couldnt find the syntax so far, could some of you please help?
14:29:54 <mauke> Int is a member of Eq
14:30:10 <drhodes> it's a fake example I think
14:30:12 <monadic_kid> mauke: he/she means a type varible
14:30:29 <mauke> monadic_kid: universal or existential?
14:30:34 <monadic_kid> uni
14:30:38 <mauke> that's useless
14:30:41 <Saizan_> or parametrized?
14:30:51 <mauke> there is no value that's in all Eq types
14:31:15 <Saizan_> inetic_: data Foo a = Foo { i :: a } ?
14:31:47 <Saizan_> inetic_: that will let you have types like Foo Int and Foo Char
14:32:07 <Saizan_> inetic_: and your functions can require an Eq constraint in their types
14:32:09 <inetic_> Saizan_: aha, that seems like it
14:32:26 <Saizan_> inetic_: e.g. foo :: Eq a => Foo a -> ...
14:32:55 <inetic_> Saizan_: I see, thank you
14:33:41 <monadic_kid> inetic_: basically don't constrain your parametrized data types, constrain parametrized function types
14:33:48 <inetic_> (I would have joined the conversation sooner, just didnt understand the terms :-), Saizan_, you kind of guessed what I wanted :) )
14:34:20 <drhodes> data (Eq a) => Foo a = Foo {i :: a}     <-  monadic_kid so you're saying this is the more restricive way?
14:34:42 <mauke> that's the bad way
14:34:45 <monadic_kid> yes
14:35:29 <inetic_> it's still good to know that such syntax is possible
14:36:31 <monadic_kid> you wanna do it for existantials though otherwise you wont be able to do much with them
14:36:35 <mauke> data Foo = forall a. (Eq a) => Foo{ i :: a }
14:37:20 <Saizan_> there's also data Foo a = (Eq a) => Foo{ i :: a }, which gives you the context when you pattern match
14:37:32 <Saizan_> but it's not haskell98
14:37:38 <Saizan_> nor 2010
14:38:16 <inetic_> hmm, is there a wiki where I can check out the grammar rules
14:38:57 <Saizan_> there's the haskell report
14:39:33 <monadic_kid> there is a cheatsheet,
14:39:54 <Saizan_> @where report
14:39:54 <lambdabot> http://www.haskell.org/onlinereport/
14:41:10 <inetic_> cool, thank you
14:53:45 <iaefai> When I try to do 'cabal upgrade Cabal', I get an error: cabal: fromFlag NoFlag. Use fromFlagOrDefault    any ideas what this even means?
14:58:18 <ologNation> Haskell is really really great
14:58:53 <monochrom> http://www.hck.sk/users/peter/HaskellEx.htm has grammar plus link to manual sections
14:59:08 <iaefai> Just needs some mainstream applications to prove it to me :P
14:59:37 <[swift]> ologNation: haha, i agree. haskell has really given me a fresh enthusiasm for programming
14:59:39 <Twey> The lack of mainstream applications is better proof in my opinion
14:59:53 <[swift]> ologNation: i just wish it were easier to convince others to try it
14:59:55 <iaefai> Twey: So the lack of use it proof of its greatness?
14:59:58 <cybercobra> huzzah, no compile errors!
15:00:35 <chrisD> I am having a problem with cabal and installing scion for eclipse to run Haskell.  I do the runghc Setup configure/build/install --user.  It installs the modules but it doesn't install scion_server in ~/.cabal/bin
15:01:23 <Twey> iaefai: 1) Mainstream applications are written in mainstream languages.  2) All the current mainstream languages are shite.  3) Therefore, mainstream applications are written in shite languages.  4) Mainstream applications are not written in Haskell.  5) Therefore, Haskell may not be shite.
15:01:42 <Twey> Q.E.D.
15:02:17 <Twey> (intended to be tongue-in-cheek)
15:02:20 <Twey> (please don't hurt me)
15:02:21 <iaefai> 2 is an assertion based completely on your opinion and without a basis, everything after that is invalid. :-)
15:02:37 <iaefai> oh yes, and Lisp isn't allowed here
15:02:44 * djahandarie returns to Philosophy 101 to double-check that argument
15:03:10 <mauke> there's a windmill in my beard. your argument is invalid.
15:03:21 <tensorpudding> @djinn Void -> a
15:03:21 <lambdabot> f = void
15:03:37 * djahandarie contemplates growing a beard just to make that joke
15:03:44 <monadic_kid> iaefai: well there is a lot more apps and libraries written in Haskell than people tend to realize, just have a look at hackage and github
15:04:22 <iaefai> For all seriousness though, I believe that a language to be 'great' it must have some mainstream use. I love certain things about haskell. But I don't see any mainstream applications. darcs could qualify, but xmonad is very niche.
15:04:29 <djahandarie> Don't forget darcshub! ... errr
15:04:34 <tensorpudding> patch-tag
15:04:48 <ivanm> djahandarie: you mean darcsden?
15:04:59 <iaefai> I don't subscribe to the opinion that a 'web application' is an application.
15:05:02 <mauke> darc shub niggurath
15:05:17 <monochrom> "has mainstream app" is an unfair criterion. it is dictated by managers not greatness.
15:05:24 <djahandarie> ivanm, I was actually making a jab, I didn't know that existed. :P
15:05:35 <ivanm> heh
15:05:37 <Twey> I don't think there's much of a correlation between technical superiority and widespread adoption.
15:05:44 <ivanm> well, it doesn't actually exist _yet_ ...
15:05:55 <Twey> History bears that out.  Technically superior solutions are often overlooked for political reasons.
15:06:03 <iaefai> monochrom: I think it is fair because even gnome (or any one of its programs) would be reasonably mainstream. Even if I don't like linux.
15:06:09 <Twey> It's one of the failings of capitalism.
15:06:21 <djahandarie> One of the many
15:07:02 <monadic_kid> iaefai: can you think of program that hasn't already been made and hasn't already pentrated mass-majority that you could write in any language including the language used for the popular app
15:07:03 <tensorpudding> Though technically-superior languages often inspire, even if they don't come to anything themselves
15:07:04 <Twey> I also don't like to say that something â€˜isn't an applicationâ€™ just because its IO mostly occurs via HTTP.
15:07:05 <pvdbrand> I think technical people only look at the technical merits of a given language/technology/whatever, and tend to ignore all the rest around it
15:07:16 <[swift]> iaefai: ironically i was just reading a story about the history of the FSF that painted gnome as a technically inferior solution chosen for political reasons
15:07:40 <benmachine> is that really a failing of capitalism? I thought it was just a failing of not living in the best possible world
15:07:44 <tensorpudding> I was under the assumption that GNOME was started due to the license of Qt.
15:07:50 <iaefai> monadic_kid: A program that hasn't already been made??
15:07:53 <benmachine> (alongside not being friends with fartnoise fartnoise junior)
15:08:00 <Twey> tensorpudding: Indeed
15:08:22 <tensorpudding> Which is irrelevant now, since Qt is dual-licensed
15:08:24 <[swift]> tensorpudding: originally GNU had apparently planned to make a whole windowing system based upon scheme, though
15:08:35 <tensorpudding> Heh.
15:08:49 <[swift]> tensorpudding: for reasons i still don't fully understand, that went out the window
15:08:59 <monochrom> I agree with monadic_kid. The world is too crowded for a new mainstream app. For existing apps why switch language and ditch ten years of code base.
15:09:00 <Twey> benmachine: Capitalism promotes advertisement of the solution whose backers have the most money to pay for advertising, and manager-dictated adoption
15:09:05 <tensorpudding> There's a discussion going on right now in the GNU mailing lists about Scheme and Emacs
15:09:17 <mauke> schemacs
15:09:23 <Twey> tensorpudding: Oh really?
15:09:32 <tensorpudding> Yeah.
15:09:37 <benmachine> Twey: hmm, ok point conceded, although political reasons are present to a lesser degree wherever you go
15:09:44 <mauke> wait, this isn't even #haskell-blah
15:09:48 <Twey> People have been saying they're going to switch out elisp for ages.  I don't think any significant progress has been made on that goal in a mainstream emacs.  It would be nice, though.
15:09:48 <monochrom> You are really lucky to get any marginally used program at all. But then xmonad did it already, end of proof.
15:09:58 <tensorpudding> http://lists.gnu.org/archive/html/emacs-devel/2010-04/msg00538.html
15:10:34 <tensorpudding> that post seems to be about Guile specifically
15:10:55 <[swift]> tensorpudding: there's a great deal more on the subject posted by Tom Lord on the Hacker News article about that very post
15:10:56 <chrisdone> guile scheme?
15:10:57 <tensorpudding> XMonad is niche, definitely.
15:10:59 <chrisdone> i remember that
15:11:04 <[swift]> tensorpudding: on the front page now i believe
15:11:08 <sbpaul> capitalism does NOT promote advertisement
15:11:11 <sbpaul> corporatism does
15:11:17 <monochrom> This is 2010 not 1960. It is not like you just wrote vi last night and the whole internet is all over it tomorrow.
15:11:24 <benmachine> capitalism doesn't promote me either :(
15:11:29 <sbpaul> i did just write vi last night
15:11:35 <sbpaul> you trying to take credit from me??
15:11:43 * sbpaul beats his chest
15:12:00 <pastorn> @slap sbpaul
15:12:00 * lambdabot puts on her slapping gloves, and slaps sbpaul
15:12:05 <monochrom> In 2010 all you can hope is niche.
15:12:08 <pastorn> ==> #haskell-blah
15:12:09 <sbpaul> lambdabot is a "her"?
15:12:16 <pastorn> @slap monochrom
15:12:16 * lambdabot smacks monochrom about with a large trout
15:12:21 <tensorpudding> Yes.
15:12:21 <pastorn> @slap benmachine
15:12:22 * lambdabot submits benmachine's email address to a dozen spam lists
15:12:25 <twink> vi would've been far beyond revolutionary in 1960
15:12:31 <tensorpudding> lambdabot is female.
15:12:38 <tensorpudding> It's why @vixen exists
15:12:39 <pvdbrand> yeah like in 1998 all you could hope for is niche, and then Google got started...
15:12:53 <[swift]> one additional comment: i think the idea that there is not room for another mainstream app in 2010 is utterly wrong, and really betrays a lack of vision
15:12:59 <tensorpudding> In 1960 would there have been machines which could even run vi?
15:13:14 <[swift]> have we really achieved the apex of what computers can do for us? i _really_ think not
15:13:22 <tensorpudding> Assuming it was ported to some kind of timesharing system.
15:13:28 <mauke> http://28.media.tumblr.com/tumblr_l0bc8itx5u1qbot00o1_500.jpg
15:13:31 <pvdbrand> and Google even built a 'web application'
15:13:36 <benmachine> [swift]: no but people have got a lot more ingrained in their habits
15:13:38 <sbpaul> google = satan
15:13:48 <pastorn> copumpkin: hello :)
15:14:19 <benmachine> this is on-topic because it is relevant to haskell uptake that is my story anyway
15:14:19 <twink> It depends on what you think about the future of computing.
15:14:19 <monochrom> vision: http://www.despair.com/vision.html
15:14:19 <pvdbrand> I'm not saying Google /= satan, I'm saying Google /= niche
15:14:19 <monadic_kid> let me rephrase that unless you're making a game (and even then) an application is made to fill a need right? nowadays almost anything you can think of has already been thought of and made and most likely more than one company and one or more of those have pentrated mass-majority. Even with the same language they used to write it you'll have a hard time getting mass-majority to move over to use yours
15:14:20 <[swift]> benmachine: they've got habits for things that computers do for them now, but there are tons of needs that computers do not yet address
15:14:25 <sbpaul> i'm not saying you said anything
15:14:27 <sbpaul> just saying google = satan
15:14:36 <yuriks> is there a way for an iteration on a list comprehension to produce more than one list element?
15:14:54 <[swift]> monadic_kid: i've read articles saying things similar to what you're saying from the 1880s.
15:15:03 <benmachine> [swift]: sure, but it's just not as easy to convince people they need new things
15:15:09 <pvdbrand> sbpaul: I didn't say anything, I was typing something ;)
15:15:12 <monochrom> what is "an iteration on a list comprehension"?
15:15:29 <sbpaul> i can take this road to its logical conclusion pvdbrand
15:15:29 <[swift]> benmachine: it's all in the marketing =)
15:15:35 <yuriks> [l
15:15:36 <yuriks> erm
15:15:38 <sbpaul> both of us crying quietly to ourselves and cursing the rest of the rom
15:15:40 <sbpaul> room*
15:15:40 <copumpkin> pastorn: allo!
15:15:42 <pvdbrand> sbpaul: let' not
15:15:44 <mauke> yuriks: yes, just add more
15:15:44 <stevenmarky1> there's no killer ai app
15:15:46 <cybercobra> yuriks: well, you could have it always produce a sublists and then do a flattening on the result
15:15:52 <monochrom> perhaps it means "execute the list comprehension for just one step". Then no, just one step won't emit more than one element.
15:16:03 <mauke> cybercobra: list comprehensions have flattening built in
15:16:12 <mauke> >>= is concatMap, yo
15:16:12 <yuriks> mauke: how do I do that?
15:16:26 <benmachine> like, [x | x <- xs, xs <- xss]
15:16:29 <monadic_kid> [swift]: my point is what iaefai said is a bit silly, you can use a mass-majority language it doesn't mean you're going to have a "mainstream" app used by millions any more than doing it in Haskell
15:16:32 <mauke> > [ y | x <- "yuriks", y <- [x, x] ]
15:16:33 <lambdabot>   "yyuurriikkss"
15:16:56 <yuriks> oh, interesting
15:17:00 <Twey> > concatMap (replicate 2) "yuriks"
15:17:01 <lambdabot>   "yyuurriikkss"
15:17:19 <sbpaul> > take 500 (cycle "hello mauke! ")
15:17:20 <lambdabot>   "hello mauke! hello mauke! hello mauke! hello mauke! hello mauke! hello mau...
15:17:46 <chrisdone> Twey: can you link me that page about verdana?
15:17:50 <[swift]> monadic_kid: i agree with you on that, but i think the true reason is that only 0.00001% (arbitrary number but you get what i mean) of apps become mainstream, regardless of how they're implemented
15:17:58 <Twey> chrisdone: http://www.xs4all.nl/~sbpoley/webmatters/verdana.html
15:18:05 <chrisdone> cheers big ears
15:18:06 <stevenmarky1> > "yuriks" >>= (\x->[x,x])
15:18:09 <lambdabot>   "yyuurriikkss"
15:18:21 <Twey> You're welcomeâ€¦
15:18:25 <Twey> â€¦ nothing rhymes with â€˜welcomeâ€™
15:18:31 <yuriks> wait, duh, just realized I don't really need to do that =P
15:18:53 <monochrom> Yeah you should always ask the real quesiton.
15:19:16 <Cale> > zip [1..] "yuriks" >>= uncurry replicate
15:19:17 <lambdabot>   "yuurrriiiikkkkkssssss"
15:19:24 <monadic_kid> It's hard to get marketshare on the PC, that is why programmers are flocking to Android/Iphone making simple/silly apps but making money until the market gets saturated
15:19:30 <Twey> Cute
15:19:53 <Twey> > concat $ zipWith replicate [1 ..] "yuriks"
15:19:54 <lambdabot>   "yuurrriiiikkkkkssssss"
15:19:57 <yuriks> ...
15:20:03 <sbpaul> > take 500 (cycle "monogamy!  ")
15:20:04 <lambdabot>   "monogamy!  monogamy!  monogamy!  monogamy!  monogamy!  monogamy!  monogamy...
15:20:10 <sbpaul> > take 500 (cycle "polygamy!  ")
15:20:11 <benmachine> monadic_kid: which is why it sucks we can't GHC anymore :(
15:20:11 <lambdabot>   "polygamy!  polygamy!  polygamy!  polygamy!  polygamy!  polygamy!  polygamy...
15:20:12 <pvdbrand> I've got a technical question: I'm trying to write a small server program which should read from a socket, parse the request, and send back the response. I'm using the Network module. The problem is reading: it blocks if I try to read more than one byte at a time from the Handle. How can I say 'read at most X bytes but less if there are less than X bytes currently available'?
15:20:13 <yuriks> > unzip [(1,2),(3,4),(5,6)]
15:20:13 <Cale> "yuriks" is now the standard example string
15:20:13 <lambdabot>   ([1,3,5],[2,4,6])
15:20:16 <monochrom> @slap everyone
15:20:16 * lambdabot jabs everyone with a C pointer
15:20:20 <chrisdone> Twey: same goes big nose
15:20:30 <benmachine> well, one of the reasons
15:20:33 <yuriks> so, how do I cat those two together now? is there a function for that?
15:20:36 <tensorpudding> ouch, that pointer is sharp
15:20:45 <Twey> yuriks: uncurry (++)
15:21:08 <Cale> > transpose [[1,2],[3,4],[5,6]]
15:21:09 <lambdabot>   [[1,3,5],[2,4,6]]
15:21:12 <Twey> > uncurry (++) $ unzip [(1, 2), (3, 4), (5, 6)]
15:21:13 <lambdabot>   [1,3,5,2,4,6]
15:21:13 <yuriks> oh, interesting
15:21:17 <Cale> > concat . transpose $ [[1,2],[3,4],[5,6]]
15:21:18 <lambdabot>   [1,3,5,2,4,6]
15:21:23 <yuriks> > uncurry (++) $ unzip [(1,2),(3,4),(5,6)]
15:21:24 <lambdabot>   [1,3,5,2,4,6]
15:21:27 <monochrom> pvdbrand: Perhaps simplest to not do that. Instead have a thread to read and parse, who cares if it blocks.
15:21:28 <yuriks> thanks
15:21:28 <Twey> Yeah, that's probably nicer
15:22:07 <Cale> Yeah, worrying about whether some operation will block is a good sign that you should be using threads
15:22:12 <pvdbrand> monochrom: I'm doing that, but I'm sending requests smaller than X bytes, so the thread will wait indefinitely
15:22:39 <monochrom> I am not sure that you must fix a number X.
15:22:47 <Cale> pvdbrand: Won't it just wait until it has enough information to proceed?
15:22:55 <pvdbrand> I just want to read in blocks, instead of a single byte at a time
15:23:06 <pvdbrand> Cale: how do I know that?
15:23:15 <benmachine> pvdbrand: due to laziness!
15:23:18 <Cale> oh, okay
15:23:20 <benmachine> er, maybe sort of
15:23:20 <jmcarthur> ugh, i can't believe how much of real world programming is just taking data from one source, reformatting it, and pushing it to something else
15:23:30 <sbpaul> jmcarthur: uh...all of it?
15:23:39 <monochrom> pvdbrand: hGetBufNonBlocking
15:23:52 <pvdbrand> I can't believe how much of it is changing the right 1's to 0's and back...
15:23:52 <sbpaul> "is this all there is"
15:23:54 <jmcarthur> sbpaul: where "reformatting" doesn't even include any sort of interesting processing
15:24:05 <sbpaul> "coke...sex...functional programming"
15:24:05 <tensorpudding> @vixen is this all there is?
15:24:06 <lambdabot> nevermind about that
15:24:07 <solrize> is anything blatantly suboptimal about  http://pastebin.com/FfYr54kr ?  it works but it's much slower than i'd like
15:24:07 <lambdabot> solrize: You have 1 new message. '/msg lambdabot @messages' to read it.
15:24:11 <sbpaul> "you people are scum...you need people like me"
15:24:19 <tensorpudding> lambdabot is smart
15:24:21 <sbpaul> "to point your fingers at!"
15:24:32 <Cale> pvdbrand: You might be able to use the recv function from network-bytestring
15:24:35 <sbpaul> then you get shot up and the camera pans out, "the lambda is yours"
15:25:03 <Cale> http://hackage.haskell.org/packages/archive/network-bytestring/0.1.2.1/doc/html/Network-Socket-ByteString.html#v%3Arecv
15:25:21 <chrisdone> jaspervdj: who was the guy at google who works on python's templating library for youtube?
15:25:32 <sbpaul> chrisdone: mephistopheles
15:25:38 <tensorpudding> a series of tubes of bytes!
15:25:38 <pvdbrand> hGetBufNonBlocking looks interesting, I wonder why it's not in all the examples I could find
15:25:51 <djahandarie> jmcarthur, didn't you just define a turing machine? :P
15:26:08 <jmcarthur> *sigh*
15:26:16 <jaspervdj> chrisdone: hmmm, frederik was his first name iirc
15:26:33 <benmachine> djahandarie: turing machine are interesting!
15:26:38 <benmachine> +s
15:26:46 <sbpaul> i hope at least one of you got my obvious reference
15:26:56 <tensorpudding> turing machines are people too
15:26:59 <monochrom> Theorem: There are more library functions than there are examples.
15:27:05 <pvdbrand> Cale: I did have a brief look at that, but I was trying to use the "higher level interface" of Network, which uses handles instead of sockets. Perhaps I should go lower and use the socket
15:27:10 <sbpaul> mental faculties are a subset of turing machine faculties
15:27:23 <benmachine> tensorpudding: people are turing machines too :O
15:27:38 <chrisdone> jaspervdj: hmm ok
15:27:55 <jmcarthur> 1. Get data. 2. Deserialize raw data. 3. Serialize data into a message. 4. Send message to another component. 5. Deserialize message. 6. Serialize data into SQL insertion query. 7. Send query. 8. Go to 1.
15:28:05 <tensorpudding> people are my favorite turing machines
15:28:07 <pvdbrand> by examples I could find I also mean source code of packages on hackage which seem to be doing similar things as what I'm trying to do
15:28:09 <jaspervdj> chrisdone: you could ask tibbe or danderson, but they're both not here atm
15:28:11 <benmachine> (is the church-turing thesis relevant to my assertion?)
15:28:17 <sbpaul> tensorpudding: the normal kind aren't very fun to have sex with
15:28:23 <sbpaul> too much machinery
15:28:24 <sbpaul> gears and shit
15:28:43 <chrisdone> jaspervdj: yeah that's why I asked you :p
15:29:10 <pvdbrand> jmcarthur: SQL? that's so old school...
15:29:12 <benmachine> tensorpudding: I prefer http://www.youtube.com/watch?v=E3keLeMwfHY to, say, Nick Griffin
15:29:41 <jmcarthur> pvdbrand: the RDBMS has gone nowhere, despite the mutterings of proggit
15:30:18 <pvdbrand> jmcarthur: I fully agree
15:30:19 <sbpaul> > viGenereDecrypt "blahblah" (viGenereCrypt "hello jmcarthur" "blahblah")
15:30:20 <jaspervdj> chrisdone: hehe, no idea here though :-p
15:30:21 <lambdabot>   "twppmnro"
15:30:24 <sbpaul> oops
15:30:31 <sbpaul> > viGenereDecrypt (viGenereCrypt "hello jmcarthur" "blahblah") "blahblah"
15:30:32 <lambdabot>   "hellonjmcarthur"
15:30:37 <jmcarthur> ?
15:30:40 <sbpaul> ooh yeah, no spaces
15:31:00 <sbpaul> > viGenereDecrypt (viGenereCrypt "helloJmcarthurHowAreYou?" "blahblah") "blahblah"
15:31:02 <lambdabot>   "hellodmcarthurbowuresous"
15:31:11 <sbpaul> ooh yeah, no capital letters
15:31:20 <sbpaul> > viGenereDecrypt (viGenereCrypt "hellojmcarthurhowareyou?" "blahblah") "blahblah"
15:31:21 <lambdabot>   "hellojmcarthurhowareyous"
15:31:21 <Twey> Or punctuation
15:31:28 <sbpaul> w/e
15:31:32 <benmachine> may I recommend a better cipher :x
15:31:33 <sbpaul> the "yous" works fine for me
15:31:38 <jmcarthur> :t viGenereDecrypt
15:31:39 <lambdabot> [Char] -> [Char] -> [Char]
15:31:45 <xerox> no space?
15:31:57 <sbpaul> it only works in the a..z domain
15:32:10 <jmcarthur> > viGenereCrypt "hellojmcarthurhowareyou" "blahblah"
15:32:10 <lambdabot>   "iplspumjbctovchvxlrlzzu"
15:32:19 <jmcarthur> okay
15:32:20 <xerox> > text "foo"
15:32:20 <lambdabot>   foo
15:32:23 <xerox> ^- space
15:32:53 <jmcarthur> xerox: afraid that a type signature will be able to cause a bot loop?
15:32:57 <xerox> right
15:33:06 <jmcarthur> i can't really think of a way
15:33:12 <xerox> ?type ?f
15:33:13 <lambdabot> forall t. (?f::t) => t
15:33:17 <xerox> hmm
15:33:18 <xerox> oh well.
15:33:34 <jmcarthur> @vixen do you put spaces for this?
15:33:35 <lambdabot> yes i do
15:33:39 <jmcarthur> no you don't, liar
15:33:54 <jmcarthur> it would be great if vixen was able to start a bot loop
15:34:20 <jmcarthur> @vixen would you say something with an @ symbol?
15:34:20 <lambdabot> the question isn't would i, but should i
15:34:24 <jmcarthur> lol
15:34:55 <benmachine> preflex: users
15:35:08 <ivanm> jmcarthur: that is precisely why lambdabot normally puts a space in front
15:35:13 <ivanm> benmachine: preflex doesn't have such a plugin
15:35:27 <jmcarthur> ivanm: right
15:35:30 <benmachine> ivanm: mm, I seem to have forgotten
15:35:31 <benmachine> everything
15:35:43 <benmachine> @undo preflex: seen lambdabot
15:35:43 <lambdabot> preflex : seen lambdabot
15:35:48 <ivanm> lambdabot _used_ to have such a plugin
15:35:49 <benmachine> no? :(
15:36:00 <ivanm> preflex: seen lambdabot
15:36:00 <preflex>  lambdabot was last seen on #haskell 17 seconds ago, saying: preflex : seen lambdabot
15:36:28 * monadic_kid is a humous addict
15:36:45 <jmcarthur> @undo @hey
15:36:45 <lambdabot>  Parse error at "@hey" (column 1)
15:38:08 <tensorpudding> preflex: seen ivanm
15:38:08 <preflex>  ivanm was last seen on #haskell 2 minutes and 8 seconds ago, saying: preflex: seen lambdabot
15:39:18 <solrize> so does anyone know if there's a much faster xml parser than hexpat?
15:39:28 <sbpaul> haxml?
15:39:36 <jmcarthur> preflex: seen @vixen
15:39:36 <preflex>  Sorry, I haven't seen @vixen
15:39:38 <sbpaul> honestly that's the only one i know
15:39:46 <sbpaul> i had no problem with it tho
15:39:56 <jmcarthur> oh there's a space anyway
15:40:13 <solrize> i'm trying to remember, is that the fancy one with arrows?  i don't have the impression it was especially fast
15:40:18 <preflex> or is there
15:40:34 <jmcarthur> somebody hijacked preflex omg
15:40:37 <IceDane> Is there a built in function to get n elements of a list?
15:40:38 <ivanm> solrize: I would think hexpat would be fastest since it uses a C library IIRC
15:40:44 <IceDane> eh, nvm
15:40:44 <IceDane> take
15:40:46 <IceDane> brainfart
15:41:04 <sbpaul> no, take takes elements up to n
15:41:07 <solrize> ivanm i did a very simple hexpat benchmark and it's much slower than i'd hoped, but it's possible i did something wrong
15:41:11 <IceDane> sbpaul: that's fine
15:41:21 <solrize> http://pastebin.com/FfYr54kr
15:41:22 <ivanm> solrize: *shrug* or maybe the binding isn't that good...
15:41:46 <IceDane> sbpaul:
15:41:56 <IceDane> > length . take 10 $ [1..20]
15:41:57 <lambdabot>   10
15:42:50 <solrize> i think i want one that uses perfect hashing for the tags and attribute names
15:43:56 <sbpaul> > last (take 19 [1..20])
15:43:57 <lambdabot>   19
15:44:04 <sbpaul> > last (take 9 [1..20])
15:44:05 <lambdabot>   9
15:44:06 <sbpaul> see
15:44:15 <sbpaul> so
15:44:23 <Mathnerd314> take 9 [1..]
15:44:27 <Mathnerd314> > take 9 [1..]
15:44:28 <lambdabot>   [1,2,3,4,5,6,7,8,9]
15:44:30 <sbpaul> > takeNth n list = last (take n list)
15:44:31 <lambdabot>   <no location info>: parse error on input `='
15:44:38 <sbpaul> @let takeNth n list = last (take n list)
15:44:39 <lambdabot>  Defined.
15:44:44 <Mathnerd314> > [1..] !! 9
15:44:45 <lambdabot>   10
15:44:47 <sbpaul> > takeNth 15 [1..1000]
15:44:48 <lambdabot>   15
15:44:58 <sbpaul> > takeNth 8 "hello icedane"
15:44:59 <lambdabot>   'c'
15:45:13 <Mathnerd314> > [1..] !! 0
15:45:14 <lambdabot>   1
15:45:32 <IceDane> sbpaul: lists are zero indexed
15:45:36 <EvanR> heres a cool function :: [a] -> Seed -> [a], produce an infinite stream of randomly chosen elements from a finite list
15:45:38 <IceDane> I asked "takes n elements"
15:45:43 <IceDane> take n takes n elements
15:45:46 <sbpaul> oh i misread ;)
15:45:50 <Ferdirand> eeew, last
15:45:58 <EvanR> how to implement
15:46:08 <Cale> EvanR: randomRs
15:46:08 <sbpaul> there's always a better way to do something in this room
15:46:12 <sbpaul> especially if you do everything wrong
15:46:17 <Cale> :t randomRs
15:46:18 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
15:46:50 <EvanR> Cale: cool
15:46:54 <Cale> Oh, to get a list of indices, and then pack the elements of the original list in an array
15:46:58 <Cale> and select them from there
15:47:26 <EvanR> right, array. i was about to ask about !! ;)
15:47:35 <copumpkin> or just be slow!
15:49:15 <sbpaul> can we have an official haskell nude beach
15:49:27 <sbpaul> i'm starting one right now
15:49:30 * sbpaul takes his clothes off
15:49:31 <chrisdone> how much?
15:49:57 <benmachine> sbpaul: is there wifi on the beach
15:50:09 <sbpaul> no
15:50:15 <EvanR> f ls seed = map (ls !!) $ randomRs (0, length ls) (gen seed)... erm
15:50:16 <benmachine> :(
15:50:18 <benmachine> no deal
15:50:21 <kaol> shapr: Would that ArrowsIntroduction mentioned in http://www.haskell.org/haskellwiki/Arrow happen to be available somewhere?
15:50:22 <sbpaul> too late
15:50:26 <sbpaul> you already signed the contract
15:50:39 <benmachine> unsigned contract;
15:51:31 <EvanR> Cale: i dont suppose we could extend this to work on infinite lists ;)
15:52:00 <c0lin> howdy. is this a good place to pose a n00b question? I'm coming to Haskell from C++ and Scheme
15:52:12 <sbpaul> it's really the only place c0lin
15:52:40 <c0lin> thanks sbpaul. I will try to make it very succing.
15:52:50 <sbpaul> succint* ;)
15:52:59 <jmcarthur> sucking?
15:53:04 <c0lin> succinct!
15:53:04 <benmachine> > let ing = 0 in succ ing
15:53:05 <lambdabot>   1
15:53:10 <c0lin> sry
15:53:15 <sbpaul> oops
15:53:19 <jmcarthur> sokay. just ask :)
15:53:19 * sbpaul blushes
15:53:21 <c0lin> ah, stuff in parens doesn't get sent (odd)
15:53:30 <BONUS> (it doesn't)
15:53:31 <benmachine> > let inct = 1 in succ inct -- spelling makes numbers bigger
15:53:31 <BONUS> ?
15:53:32 <lambdabot>   2
15:53:42 <c0lin> I'm new to IRC as well so it's a steep curve day for me.
15:53:46 <sbpaul> can you clarify c0lin ?
15:53:53 <EvanR> c0lin: (odd) was sent
15:54:08 <jmcarthur> huh?
15:54:17 <jmcarthur> oh end of sentence
15:54:21 <sbpaul> o_o ask your question c0lin
15:54:24 <c0lin> It was! But when I start a line with parens, nothing goes out.  Anyway, my question is not with ircle. I'll get on with it.
15:54:41 <c0lin> I'd like to define a simple type for "vector over a field." So I start with:
15:54:49 <benmachine> I think I used ircle once, it's the mac one isn't it? x-chat aqua is better :P
15:54:59 <sbpaul> i use irssi on every platform
15:55:05 <c0lin> newtype Vec a = Vec [a] deriving (Show)
15:55:11 <benmachine> (opinions differ on colloquy; I didn't get on with it at all)
15:55:20 <copumpkin> there's also linkinus
15:55:22 <copumpkin> but it has issues
15:55:28 <c0lin> I want a little package of vector operations like sum and dot so I write
15:55:41 <c0lin> class VecOps v where
15:55:41 <c0lin>   plus :: v -> v -> v
15:55:41 <c0lin>   dot :: (Num a) => v -> v -> a
15:55:56 <copumpkin> why do you need a class?
15:56:08 <Chaze> hi. i'm trying to sort a list by the length of it's sublists. Why can't I plug this into each other:
15:56:08 <Chaze> (uncurry compare) . curry (length *** length)
15:56:26 <benmachine> :t curry (length *** length)
15:56:27 <lambdabot> forall a a1. [a] -> [a1] -> (Int, Int)
15:56:27 <c0lin> well that's a good question.
15:56:27 <jmcarthur> :t curry (length *** length)
15:56:29 <lambdabot> forall a a1. [a] -> [a1] -> (Int, Int)
15:56:34 <jmcarthur> :t uncurry compare
15:56:35 <lambdabot> forall a. (Ord a) => (a, a) -> Ordering
15:56:38 <copumpkin> :t comparing length
15:56:39 <lambdabot> forall a. [a] -> [a] -> Ordering
15:56:50 <c0lin> I guess it's not necessary. I got started down this route, and, finding frustration at the bottom, began to bang my head
15:57:02 <copumpkin> :t compare `on` length
15:57:03 <lambdabot> forall a. [a] -> [a] -> Ordering
15:57:10 <Chaze> wow, nice
15:57:13 <shapr>  kaol: I think it might be gone forever. It was just a cheesy boiled down version of the original arrows paper though, so no great loss.
15:57:14 <jmcarthur> > sortBy (comparing length) ["foo", "foosball", "bar", "wibble"]
15:57:14 <lambdabot>   ["foo","bar","wibble","foosball"]
15:57:17 <benmachine> c0lin: defining a typeclass is not wrong, though
15:57:21 <alpounet> :t sortBy
15:57:22 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
15:57:23 <benmachine> just might be excessive sometimes
15:57:28 <Chaze> still, (Int, Int) should be (Ord a) => (a, a
15:57:37 <jmcarthur> @instances Ord
15:57:37 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
15:57:38 <c0lin> here's the problem: this won't compile:
15:57:44 <alpounet> > sortBy (compare `on` length) ["foo", "baaaaar", "quuuuuuux"]
15:57:45 <lambdabot>   ["foo","baaaaar","quuuuuuux"]
15:57:52 <alpounet> > sortBy (compare `on` length) ["foo", "baaaaar", "quuuuuuux", "baz"]
15:57:53 <lambdabot>   ["foo","baz","baaaaar","quuuuuuux"]
15:57:55 <c0lin> instance (Num a) => VecOps (Vec a) where
15:57:55 <c0lin>   dot (Vec p) (Vec q) = foldr (+) 0 (zipWith (*) p q)
15:58:04 <jmcarthur> alpounet: comparing = (compare `on`)
15:58:09 <Chaze> where may i find this "on" ?
15:58:09 <alpounet> yes
15:58:12 <c0lin> The complaint is :
15:58:15 <jmcarthur> Chaze: DatalFunction
15:58:16 <jmcarthur> err
15:58:19 <jmcarthur> Data.Function
15:58:22 <Chaze> thanks
15:58:24 <c0lin>     Couldn't match expected type `a1' against inferred type `a'
15:58:24 <c0lin>       `a1' is a rigid type variable bound by
15:58:25 <c0lin>            the type signature for `dot' at ex2.hs:6:14
15:58:25 <c0lin>       `a' is a rigid type variable bound by
15:58:25 <c0lin>           the instance declaration at ex2.hs:9:14
15:58:25 <c0lin>     In the expression: foldr (+) 0 (zipWith (*) p q)
15:58:25 <c0lin>     In the definition of `dot':
15:58:26 <c0lin>         dot (Vec p) (Vec q) = foldr (+) 0 (zipWith (*) p q)
15:58:26 <c0lin>     In the instance declaration for `VecOps (Vec a)'
15:58:34 <jmcarthur> c0lin: woah, use hpaste.org please :)
15:58:47 <c0lin> It seems odd that 'a' and 'a1' aren't compatible.  Aren't they 'irrefutable'?
15:58:56 <jmcarthur> c0lin: on irc we use paste sites to keep from flooding
15:59:16 <c0lin> thank you jmcarthur I will look at that
15:59:37 <benmachine> c0lin: I think the problem is that the a in Vec a is different from the a in the result of dot
15:59:54 <EvanR> looking at RandomGen split method. what is this supposed to do again?
16:00:12 * jmcarthur is tempted to introduce associated types
16:00:27 <benmachine> c0lin: dot says, I will produce a value in any type you like as long as it's Num
16:00:38 <benmachine> c0lin: but you say, I will produce a value of the type that's in the vectors
16:00:46 <benmachine> and then GHC gets upset
16:01:04 <c0lin> I can see why that would be.  It seems that perhaps the class should be parameterzed both on the vector type and the base field...
16:01:07 <EvanR> is the default split implementation of interlacing the original generator not good enough? or it would be the default
16:01:30 <jmcarthur> class VecOps v where dot :: v a -> v a -> a  -- might be a good way to do it unambiguously
16:01:31 <copumpkin> split is the devil
16:01:52 <wavewave> Saizan_: my ffi error seems to be only cpp-related.
16:01:56 <c0lin> It's not obvious how to look inside the type in the class difinition.
16:01:59 * EvanR waits for more info
16:02:05 <jmcarthur> if you don't mind having the class operate on * -> * instead of just *
16:02:27 <benmachine> c0lin: you can't really inspect much in the class definition because you could have all sorts of different instances and the class is the same for all of them
16:02:53 <benmachine> c0lin: in principle I could define an instance VecOps ()
16:02:58 <benmachine> it just wouldn't be very interesting
16:03:03 <jmcarthur> c0lin: okay, there are a number of possible solutions to this. i just gave one. i have at least two others in mind. there are tradeoffs
16:03:04 <c0lin> Slowly I am beginning to get this.  It really is a new kind of discipline to write in this language.  the temptation to flee back to Python is strong :)
16:03:17 <copumpkin> c0lin: keep in mind that your vector has no safety, either, and will silently do the wrong thing if you pass it a 2d vector and a 3d one and dot them together
16:03:19 <EvanR> speaking of the devil
16:03:26 <c0lin> I will try the 1st one you mentioned, jmcarthur
16:03:33 <benmachine> c0lin: I used to like python until I got good at haskell now I look upon it with disdain :P
16:03:48 <benmachine> other things I look upon with disdain apparently include commas
16:03:54 <copumpkin> haskell ruined most languages I knew before learning it for me
16:04:00 <c0lin> copumpkin: my application will be entirely "offline", and so a horrible crash is the right response to a foul-up like that.
16:04:15 <jmcarthur> assuming ti crashes
16:04:17 <jmcarthur> *it
16:04:18 <copumpkin> c0lin: you should make it crash horribly then
16:04:28 <copumpkin> c0lin: zipWith won't crash if you give it two lists of different sizes
16:04:40 <benmachine> > zipWith (*) [1,2,3] [4,5]
16:04:41 <lambdabot>   [4,10]
16:04:44 <c0lin> ah.
16:04:44 <benmachine> no error :o
16:04:53 <sbpaul> haskell rocks
16:04:56 <sbpaul> prelude rocks
16:05:07 <jmcarthur> haskell rocks. prelude is... meh
16:05:12 <xerox> sbpaul scissors
16:05:30 <benmachine> xerox: given the context that doesn't seem a wise position
16:05:42 <sbpaul> i'm a sculptor benmachine
16:05:48 * copumpkin hands xerox some paper
16:05:52 <sbpaul> a master
16:06:07 <xerox> benmachine: oooops.
16:06:21 <c0lin>  (submerging to try an approach discussed here, brb)
16:06:38 <EvanR> > randomIO :: Bool
16:06:39 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
16:06:39 <lambdabot>         against inferred type ...
16:07:15 <copumpkin> not going to happen :)
16:07:36 <EvanR> :(
16:07:51 <benmachine> > True -- chosen by fair coin toss, guaranteed to be random
16:07:52 <lambdabot>   True
16:07:53 <copumpkin> you can't pull something out of IO
16:08:04 <copumpkin> so you lift what you wanted to do into IO
16:08:34 <benmachine> I was going to write an article along those lines
16:08:41 <benmachine> but it sounded too much like a monad tutorial so I ran in fear
16:08:59 <EvanR> > random (mkStdGen 0) :: Bool
16:09:00 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
16:09:00 <lambdabot>         against inferred type ...
16:09:11 <EvanR> > (random (mkStdGen 0)) :: Bool
16:09:13 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
16:09:13 <lambdabot>         against inferred type ...
16:09:13 * copumpkin has the one monad tutorial to rule them all in his mind, but won't write it down
16:09:17 <copumpkin> :t random
16:09:18 <c_wraith> there's always room for another IO tutorial that never uses the word "Monad"
16:09:18 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
16:09:22 <benmachine> against inferred type WHAT
16:09:32 <EvanR> ah
16:09:36 <benmachine> c_wraith: yeah but that's not what I had in ind
16:09:39 <benmachine> m
16:09:45 <EvanR> > (random (mkStdGen 0)) :: (Bool, StdGen)
16:09:46 <lambdabot>   (True,40014 40692)
16:09:49 <EvanR> > (random (mkStdGen 0)) :: (Bool, StdGen)
16:09:50 <lambdabot>   (True,40014 40692)
16:09:58 <benmachine> see I told you True was random
16:09:59 <EvanR> why did i just try that twice
16:10:05 <EvanR> lol
16:10:08 <copumpkin> to see if haskell is deterministic, surely
16:10:27 <copumpkin> > fmap random (random (mkStdGen 0))
16:10:28 <lambdabot>   (-117157315039303149,(-8854136653200549331,2127568003 1780294415))
16:10:39 <EvanR> :o
16:10:46 <benmachine> @let haskellIsStillDeterministic = fst (random (mkStdGen 0)) :: Bool
16:10:46 <lambdabot>  <local>:8:35:
16:10:46 <lambdabot>      Ambiguous occurrence `random'
16:10:47 <lambdabot>      It could refer to eith...
16:10:49 <benmachine> :(
16:10:51 <copumpkin> > random . (random (mkStdGen 0))
16:10:52 <lambdabot>   Ambiguous occurrence `random'
16:10:53 <lambdabot>  It could refer to either `L.random', defined...
16:10:54 <xerox> haha
16:10:57 <xerox> not deterministic.
16:10:57 <copumpkin> eugh
16:11:06 <copumpkin> :P
16:11:08 <benmachine> :t L.random
16:11:09 <lambdabot> forall a. a
16:11:12 <benmachine> wat
16:11:21 <copumpkin> zomg
16:11:32 <copumpkin> that random will return a random value of a random type!!
16:11:36 <xerox> haskell is soooo nondet
16:11:37 <benmachine> heheh
16:11:47 <EvanR> yes, a Random type ;)
16:11:49 <benmachine> > L.random
16:11:50 <lambdabot>   *Exception: MUAHAHAHAH
16:11:56 <benmachine> seems fair
16:12:05 <copumpkin> that's a useful value
16:12:17 <EvanR> wtf is L.random
16:12:18 <benmachine> @let unsafePerformIO = error "nice try."
16:12:19 <lambdabot>  Defined.
16:12:25 <benmachine> oh no wait
16:12:27 <benmachine> @undefine
16:12:36 <benmachine> @let unsafePerformIO = error "nice try." :: IO a -> a
16:12:37 <lambdabot>  Defined.
16:12:42 <benmachine> :t unsafePerformIO
16:12:43 <lambdabot> forall a. IO a -> a
16:12:56 <benmachine> woo
16:13:07 <c_wraith> > unsafePerformIO $ print 10
16:13:08 <lambdabot>   *Exception: nice try.
16:13:12 <xerox> > print "<IO ()>"
16:13:13 <lambdabot>   <IO ()>
16:13:19 <benmachine> *gasp*
16:13:20 <xerox> didn't you get the note, now it works
16:13:25 <benmachine> (you mean putStr, surely)
16:13:34 <EvanR> > unsafePerformIO (randomIO :: IO Bool)
16:13:35 <lambdabot>   *Exception: nice try.
16:13:35 <xerox> oh snap
16:13:48 <c_wraith> you also want two leading spaces
16:14:05 <EvanR> > randomIO :: IO Bool
16:14:06 <lambdabot>   <IO Bool>
16:14:18 <EvanR> oh
16:14:29 <EvanR> now i get what xerox did ;)
16:14:47 <c0lin> jmcarthur: your suggestion of dot :: (Num a) => v a -> v a -> a worked fine!  Thank you
16:16:42 <EvanR> i have a question, i think the answer is 'that isnt possible'
16:16:55 <djahandarie> That isn't possible!
16:16:58 <Eridius> "that isnt possible"
16:17:03 <copumpkin> your question isn't possible
16:17:09 <benmachine> that... am I late
16:17:20 <benmachine> what's the question
16:17:30 <copumpkin> not possible
16:17:36 <xerox> quite
16:17:46 <djahandarie> Indeed
16:17:53 <copumpkin> indubitably
16:17:55 <benmachine> no doubt
16:17:58 * djahandarie puts on his monocle
16:18:05 * benmachine never took his off
16:18:08 * copumpkin fills his pipe
16:18:19 <EvanR> lol
16:18:33 <djahandarie> EvanR, so what was the question again? :P
16:18:37 * xerox remarks that something is elementary
16:19:03 * benmachine takes some cocaine
16:19:33 <EvanR> i would like to create an instance of random which is data Impossible = NoAnswer | No Int, and the possible values are uniformly distributed
16:19:51 <copumpkin> what's wrong with that
16:20:07 <EvanR> instance of Random*
16:20:13 <alpounet> taking in account the "NoAnswer" ?
16:20:21 <EvanR> yes, it might show up
16:20:37 <benmachine> uniformly as in, NoAnswer is as likely as No 4 is as likely as No 7756?
16:20:40 <EvanR> yes
16:20:47 <c0lin> here's one more tiny question having to do with '.' and partial function application.
16:21:01 <benmachine> sounds pretty possible to me
16:21:04 <benmachine> might be awkward though
16:21:06 <c0lin> Why is it not equivalent to replace
16:21:13 <EvanR> benmachine: oh/
16:21:22 <c0lin> plus (Vec p) (Vec q) = Vec (zipWith (+) p q)
16:21:25 <c0lin> with
16:21:38 <c0lin>   plus (Vec p) (Vec q) = Vec . (zipWith (+))
16:21:43 <c0lin> ?
16:21:59 <benmachine> c0lin: . is function composition and makes a function
16:22:11 <benmachine> so the latter RHS is a function, the former RHS is a value
16:22:40 <c0lin> Yes, I see.
16:22:41 <benmachine> Vec . zipWith (+) p $ q -- equivalent to the former, but not really any nicer
16:23:02 <c0lin> I haven't learned $ yet. I'm about 25% of the way through "real world haskell."
16:23:03 <benmachine> the problem is you've got to unwrap the newtypes, so you can't really do the whole partial application implicit arguments thing
16:23:10 <benmachine> oh, $ is really simple
16:23:12 <benmachine> @src $
16:23:13 <lambdabot> f $ x = f x
16:23:17 <ClaudiusMaximus> @pl \p q -> f (g p q)
16:23:18 <lambdabot> (f .) . g
16:23:34 <benmachine> it doesn't do anything :) it just means you don't have to use as many parentheses
16:23:42 <alpounet> if you want it full pointfree, you can define something like unVec (Vec x) = x, and then it becomes : /query lambdabot
16:23:45 <alpounet> hm
16:23:54 <benmachine> i.e. (f . g) (h x) = f . g $ h x
16:24:04 <benmachine> heh
16:24:18 <benmachine> newtype Vec a = Vec { unVec :: [a] }
16:24:38 <Draconx|Laptop> EvanR, the easiest way to generate such things uniformly at random is to generate a superset uniformly at random, and re-roll if you generate something outside of the set you want.  You might miss a few times, though.
16:24:56 <EvanR> Draconx|Laptop: how do you generate a superset of Int
16:24:59 <EvanR> uniformly
16:25:09 <EvanR> using the generator
16:25:16 <EvanR> RandomGen produces Int
16:25:21 <Draconx|Laptop> generate two ints.
16:25:26 <EvanR> :o
16:25:33 <Jafet> (Or more!)
16:25:39 <EvanR> unheard of
16:25:39 <c0lin> that was illuminating, thank you both!  I'll plow through more of the book before bothering y'all again.
16:25:47 <benmachine> :t zipWith (+) `on` getZipList
16:25:48 <lambdabot> forall a. (Num a) => ZipList a -> ZipList a -> [a]
16:25:52 <benmachine> hmmm
16:26:00 <copumpkin> lol
16:26:01 <benmachine> :t ZipList . zipWith (+) `on` getZipList
16:26:02 <lambdabot>     Couldn't match expected type `b -> c'
16:26:02 <lambdabot>            against inferred type `ZipList a'
16:26:02 <lambdabot>     In the first argument of `(.)', namely `ZipList'
16:26:07 <benmachine> whoops
16:26:08 <copumpkin> why not just liftA2 (+) ?
16:26:11 <EvanR> so yes it is possible, but the most basic way would probably not be very fast
16:26:17 <EvanR> well, ok
16:26:19 <EvanR> two ints
16:26:33 <EvanR> if its max + 1, NoAnswer, if its less, No that, otherwise reroll
16:26:36 <benmachine> :t (ZipList .) . zipWith (+) `on` getZipList -- copumpkin, I'm just using ZipList as a token newtype, because I can't define Vec
16:26:37 <lambdabot> forall a. (Num a) => ZipList a -> ZipList a -> ZipList a
16:26:38 <EvanR> you miss half the time
16:26:38 <Draconx|Laptop> EvanR, two ints is quite bad, you should try to get one bit more than you need.
16:26:41 <copumpkin> :t (ZipList .) . (zipWith (+) `on` getZipList)
16:26:42 <lambdabot> forall a. (Num a) => ZipList a -> ZipList a -> ZipList a
16:26:50 <Draconx|Laptop> EvanR, then you only expect to miss once.
16:27:08 <EvanR> Draconx|Laptop: right so we want a random bit generator that only feeds on the ints it needs
16:27:10 <Draconx|Laptop> EvanR, (you can, of course, just discard bits from the second int)
16:27:55 <EvanR> alright, problem boring, im done with that one ;)
16:28:16 <benmachine> copumpkin: oh neat, those are the same even though it's associated differently?
16:28:59 <copumpkin> yeah, but beware of the evil that is (.) sections
16:29:39 <Twey> Yeah, fmap and flip fmap are the way to go ;)
16:29:51 <djahandarie> :t (.)
16:29:52 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:30:00 <benmachine> :t flip (.)
16:30:01 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
16:30:02 <copumpkin> Twey has it right
16:30:05 <copumpkin> :t flip
16:30:06 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
16:30:12 * copumpkin coughs
16:30:16 <djahandarie> Haha
16:30:36 <benmachine> has anyone found a non-contrived use case for that where f is not (t ->)
16:30:54 <interferon> leksah is neat
16:30:56 <copumpkin> I'm sure Cale has
16:32:11 <BONUS> > (+3) . Just 3
16:32:12 <lambdabot>   Just 6
16:32:25 <Twey> BONUS: He meant generalised flip
16:32:34 <BONUS> aahh
16:32:52 <BONUS> generalized flip is weird ya
16:32:54 <benmachine> > flip (Just (+3)) 4
16:32:56 <lambdabot>   Just 7
16:33:06 <Twey> Ooh
16:33:15 <Twey> It's like fmap in reverse
16:33:19 <Twey> cofmap
16:33:32 <Twey> That's pretty cool
16:33:42 <copumpkin> the definition is pretty simple :)
16:33:58 <benmachine> it's basically fmap ($ x) right?
16:34:05 <copumpkin> it is that
16:34:31 <fnord123> has anyone had to retrieve their password from haskell.org? It's taking me a while.
16:34:45 <fnord123> (the email). I'm curious if someone needs to approve the request.
16:41:45 <Ferdirand> speaking of caleskell, we found this the other day
16:41:49 <Ferdirand> > let rotate = (drop ++ take) in rotate 3 [1..10]
16:41:50 <lambdabot>   [4,5,6,7,8,9,10,1,2,3]
16:42:06 <Ferdirand> and i was wondering how to write it nicely if we did not have (++) = mconcat
16:42:08 <c_wraith> there's a monoid instance for functions?
16:42:15 <Cale> yeah, it's just the lifting instance
16:42:39 <Cale> So drop ++ take = \n xs -> drop n xs ++ take n xs
16:43:26 <jmcarthur> Ferdirand: (++) = mappend in caleskell, btw, i'm pretty sure
16:43:38 <Cale> yeah, it's mappend
16:43:43 <Ferdirand> eh, mappend, sorry
16:43:57 <tensorpudding> @type concat
16:43:58 <lambdabot> forall a. [[a]] -> [a]
16:44:16 <jmcarthur> :t mconcat
16:44:17 <lambdabot> forall a. (Monoid a) => [a] -> a
16:44:18 <tensorpudding> didn't do concat = mconcat too?
16:44:25 <jmcarthur> dunno
16:44:26 <Cale> That's a really nice example, btw
16:44:34 <tensorpudding> I guess it's not really that shorter.
16:44:52 <Ferdirand> at first we tried a mess of (&&&), join, curry and uncurry, but couldn't get the dots to connect
16:44:56 <Cale> I suppose you'd want that in the real thing, but yeah, it's not really so essential
16:44:57 <Ferdirand> and @pl wasn't of much help
16:45:46 <contrafunktal> @pl doesnt know about &&&
16:45:46 <lambdabot> (line 1, column 22):
16:45:46 <lambdabot> unexpected end of input
16:45:46 <lambdabot> expecting white space or simple term
16:46:35 <blackdog> contrafunktal: I think the meme is "@pl don't know bout my &&&"
16:46:43 <Cale> The usefulness of monoid instances has a way of sneaking up on you (or at least me :)
16:47:01 <contrafunktal> > let rotate = concat . sequence [drop,take] in rotate 3 [1..10]
16:47:02 <lambdabot>   Couldn't match expected type `[a]'
16:47:02 <lambdabot>         against inferred type `[a1] -> [...
16:47:12 <contrafunktal> > let rotate = (concat .) . sequence [drop,take] in rotate 3 [1..10]
16:47:13 <lambdabot>   Couldn't match expected type `[[a]]'
16:47:13 <lambdabot>         against inferred type `[a1] ->...
16:47:32 <contrafunktal> oh, it needs even more sequence
16:47:40 <Cale> They're nicely composable in a way which is usually more obvious after reading the code than before :)
16:47:40 <djahandarie> MOAR SEQUENCE
16:47:46 <contrafunktal> > let rotate = (concat .) . sequence (sequence [drop,take]) in rotate 3 [1..10]
16:47:47 <lambdabot>   Couldn't match expected type `[[[a]]]'
16:47:47 <lambdabot>         against inferred type `GHC.T...
16:47:52 <contrafunktal> meh
16:48:16 * contrafunktal pm's \bot
16:48:42 <Cale> contrafunktal: You're at Waterloo?
16:48:54 <contrafunktal> yes, I am being educated there
16:48:59 <Cale> cool :)
16:49:07 <dcoutts_> iaefai: I expect that bug is fixed in the later cabal-install version, use cabal install cabal-install
16:49:17 <Cale> (I did pure math undergrad there a few years back)
16:49:25 <Cale> I'm in Brantford
16:49:30 <iaefai> dcoutts_: I had to download it manually
16:49:31 <contrafunktal> I'm doing chemical engineering
16:49:50 <dcoutts_> iaefai: ok, you've got it working ok now?
16:50:04 <contrafunktal> I almost made it there by bicycle on the weekend
16:50:25 <iaefai> dcoutts_: Well in truth I do not know. The manual install worked, so I could not recreate the situation from before.
16:51:01 <dcoutts_> iaefai: ok, btw I would generally recommend using install rather than upgrade
16:51:13 <iaefai> Any particular reason?
16:51:15 <dcoutts_> iaefai: upgrade has an unhelpful way of breaking things :-)
16:51:21 <dcoutts_> it upgrades all dependencies
16:51:31 <dcoutts_> which is not really that helpful for core packages
16:51:33 <iaefai> I see
16:51:35 <EvanR> so yeah, whats the deal with RandomGen split
16:52:09 <dcoutts_> iaefai: install just tries to install the latest version of the thing you ask for, and tries to re-use as many of the existing packages as possible
16:52:58 <Ferdirand> > let rotate = (concat.) . sequence  . sequence [drop,take] in rotate 3 [1..10]
16:52:59 <contrafunktal> > let rotate = (concat .) . sequence . sequence [drop,take] in rotate 3 "hello -- Ferdirand
16:52:59 <lambdabot>   [4,5,6,7,8,9,10,1,2,3]
16:53:00 <lambdabot>   <no location info>:
16:53:00 <lambdabot>      lexical error in string/character literal at end o...
16:53:16 <Ferdirand> haha
16:53:17 <contrafunktal> wut?
16:53:51 <cpx> Hi there. I was in here earlier, getting help with writing a stupid little program in Haskell. I was having some performance problems, so I improved a lot of the algorithms I was using. But after some profiling, I found that the rest of the (rather significant) slowdown is caused by this function: http://pastie.org/920390 . Any suggestions for improving it?
16:54:27 <contrafunktal> you could make f tail-recursive
16:54:53 <contrafunktal> but perhaps there's a better way to calculate that value
16:54:58 <greedo> having trouble passing a argument to a function
16:54:59 <dcoutts_> cpx: and you could use divmod
16:55:20 <dcoutts_> cpx: erm, divMod rather
16:55:26 <greedo> cp <- replicateM (fromIntegral (c1_constant_pool_count c1) - 1) getConstantPool c1_constant_pool_count c1
16:55:46 <contrafunktal> greedo: what's the type of getConstantPool?
16:56:10 <Saizan> > 0 `mod` 5
16:56:11 <lambdabot>   0
16:56:15 <contrafunktal> I'm guessing you want    ...1) (getConstantPool c1_constant_pool_count c1)
16:56:31 <dcoutts_> cpx: if you're only using it at one type, give a type sig
16:56:37 <greedo> yeah that's what i thougt too
16:56:54 <Saizan> cpx: it doesn't seem like that function will ever terminate if you pass it a multiple of 5?
16:57:09 <cpx> dcoutts_: It has a type sig in my code. f :: Int -> Int
16:57:16 <dcoutts_> cpx: ok
16:57:19 <contrafunktal> so   f 5 = infinity
16:57:30 <EvanR> f 5 = _|_ ?
16:57:44 <contrafunktal> if you like looking at things that way
16:58:34 <EvanR> is it considered an error for non termination
16:58:46 <contrafunktal> depends how lazy + i
16:58:48 <contrafunktal> s
16:58:49 <greedo> IO ()
16:59:12 <cpx> No, it terminates with the correct answer of '1' for me when called with 5
16:59:22 <contrafunktal> greedo: then what do you want to do with  c1_constant_pool_count c1?
17:00:31 <contrafunktal> > 5 `div` 5
17:00:32 <lambdabot>   1
17:01:05 <greedo> nvm, i did something else
17:01:11 <contrafunktal> so the actual bad value is 0
17:01:28 <contrafunktal> > 0 `divMod` 5
17:01:29 <lambdabot>   (0,0)
17:02:14 <cpx> Right, which calls the function again with 1, which 1 `mod` 5 is not 0, so it returns 0
17:02:35 <Saizan> ah, right.
17:03:05 <cpx> This function is being called from a parent function only, in such a way that the lowest input will be 1
17:03:07 <contrafunktal> but you still need a guard for the case of 0
17:03:24 <contrafunktal> then that's ok
17:03:32 <cpx> Yep
17:03:45 <cpx> Will using divMod actually speed it up>
17:03:47 <cpx> *?
17:04:10 <cpx> Wow, that's a terrible sentence.
17:04:17 <cpx> *Will the use of divMod speed it up?
17:04:23 <Saizan> the fact that it's not tail recursive is probably a problem too, since (+) is strict
17:06:02 <contrafunktal> http://www.pastie.org/920410
17:06:09 <contrafunktal> except drop the n parametrer
17:06:12 <contrafunktal> *parameter
17:06:18 <contrafunktal> (from f that is)
17:06:47 <Saizan> you've to add a seq for acc
17:06:58 <contrafunktal> isn't + strict enough already?
17:07:24 <contrafunktal> or   acc `seq` go (1+acc) d
17:07:47 <contrafunktal> or   let acc' = 1 + acc in acc `seq` go acc' d
17:07:57 <Saizan> the strictness of (+) is why you've to add seq like that :)
17:08:15 <contrafunktal> so sad that you can't be both pointfree when you use go, and also use $!
17:08:24 * hackagebot vector-algorithms 0.3.1 - Efficient algorithms for vector arrays  http://hackage.haskell.org/package/vector-algorithms-0.3.1 (DanDoel)
17:08:30 <contrafunktal> Saizan: I don't understand
17:08:54 <Saizan> you could write (go $! acc + 1) d
17:09:28 <cpx> ):
17:09:43 <Saizan> contrafunktal: well, without the seq, go will return at the end something that looks like (1+(1+(1+(1+.... 0)))))
17:10:00 <contrafunktal> aren't we just building up one level of indirection by using $ instead of $!?
17:10:30 <contrafunktal> strictness analysis?
17:10:44 <Saizan> contrafunktal: and since (+) is strict, it'll need to go to the deepest addition before it can actually reduce anything, making it use O(n) stack
17:10:59 <contrafunktal> @src foldl'
17:10:59 <lambdabot> foldl' f a []     = a
17:11:00 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
17:11:16 <contrafunktal> ok, so we're inlining this definition of foldl'
17:12:01 <contrafunktal> though the exit condition is different, so you can't exactly use that definition
17:12:13 <contrafunktal> @type until
17:12:14 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
17:12:24 <Saizan> it's the same problem and solution as foldl, it applies to all the function defined with an accumulator made of application of strict functions
17:12:56 <contrafunktal> > until (\x -> x `mod` 5 == 0) (`div` 5) (125*123)
17:12:57 <lambdabot>   15375
17:13:03 <cpx> I am now terribly confused.
17:14:00 <contrafunktal> $! is easier to understand than seq imho
17:14:21 <mail> great my uni has manged to fuck up the student test linux machine
17:14:29 <Saizan> cpx: http://www.pastie.org/920416 <- this is a correct way to write that function
17:14:30 <mail> now how the hell am i going to use GHC
17:14:37 <mail> ghci*
17:16:37 <gwern> mail: may I suggest on your own machine?
17:16:51 <mail> arsed installing ghc
17:17:12 <cpx> Saizan: I have to be 100% honest - that's not the first thing I would have ever thought to write. Clearly, I am terrible at Haskell.
17:17:12 <mail> on windows
17:18:40 <contrafunktal> cpx: perhaps it's a good thing that haskell encourages you to write lazy functions?
17:18:54 <mail> unless it's sort
17:19:04 <contrafunktal> say when you process a stream, what you had is good
17:19:19 <contrafunktal> that form at least
17:19:31 <contrafunktal> that is foldr
17:20:10 <Saizan> cpx: well, i'd probably have written the whole thing either with logarithms or in an higher level
17:20:29 <Saizan> cpx: the code in the paste is quite ugly i admit :)
17:20:45 <cpx> Saizan: It did scare me a little bit.
17:20:49 <Saizan> and there's a typo
17:21:00 <cpx> I'm used to idiomatic Haskell, which looks rather nice. ):
17:21:37 <Saizan> > length . takeWhile (\x -> x `mod` 5 == 0) . iterate (`div` 5) $ 125*125
17:21:39 <lambdabot>   6
17:21:41 <Saizan> > length . takeWhile (\x -> x `mod` 5 == 0) . iterate (`div` 5) $ 125*125 + 1
17:21:42 <lambdabot>   0
17:22:54 <contrafunktal> that's going to be slower
17:23:06 <Saizan> > let f n | n `mod` 5 == 0 = round $ log (fromIntegral n) / log 5 | otherwise = 0 in (f (125*125), f (125*125 + 1))
17:23:08 <lambdabot>   (6,0)
17:23:21 <mail> takeWhile (\x -> x `mod` 5 == 0) . iterate (`div` 5) $ 125*125
17:23:36 <mail> answer me lambdabot !!!
17:23:37 <Saizan> contrafunktal: probably going to be faster than the original or your version without the seq
17:23:48 <Saizan> mail: you need a "> " in front
17:24:00 <mail> > takeWhile (\x -> x `mod` 5 == 0) . iterate (`div` 5) $ 125*125
17:24:01 <lambdabot>   [15625,3125,625,125,25,5]
17:24:20 <mail> sort [1..]
17:24:24 <mail> > sort [1..]
17:24:30 <lambdabot>   mueval: ExitFailure 1
17:25:59 <cpx> I feel like an idiot after realizing that this could have been done with logarithms. Something about learning an new language makes you forget all the simple things... \:
17:26:39 <fax> why is it called logarithm?
17:27:33 <cpx> fax: So people years later could make jokes about lumberjacks and math at the same time.
17:27:41 <Pseudonym> log + arithm
17:27:45 <Pseudonym> ratio-number
17:29:08 <dolio> How about algorithm? Did someone just rearrange the letters of logarithm?
17:29:27 <Pseudonym> No.  Algorithm is named after an Arabic mathematician.
17:29:41 <mail> as was algebra
17:29:43 <cpx> Pseudonym: Did you learn that from Knuth as well?
17:29:54 <cpx> Pseudonym: ...or Wikipedia?
17:29:57 <cpx> (:
17:29:58 <Pseudonym> Khwarizmi.
17:30:01 <Pseudonym> Al-Khwarizmi.
17:30:03 <fax> cool
17:30:19 <Pseudonym> Can't remember where I picked it up.
17:30:28 <Pseudonym> But I did do some Greek way back when.
17:30:31 <fax> so whats new haskell
17:30:43 <mail> do hate calculus
17:30:52 <Pseudonym> mail: Which calculus would that be?
17:30:54 <Pseudonym> Sequent?
17:30:57 <fax> you can't hate calculus, that is ridiculous
17:30:58 <Pseudonym> Hilbert-style?
17:31:04 <Pseudonym> Combinational?
17:31:10 <Pseudonym> Lambda?
17:31:12 <fax> that's like saying you hate wheels
17:31:19 <monochrom> I hate wheels
17:31:20 <fax> it's just ..wrong
17:31:26 <fax> monochrom wheel haters club
17:31:31 <Pseudonym> I'm with monochrom.  Wheels suck.
17:31:45 <Pseudonym> Anything with wheels in it breaks.
17:32:01 <sbpaul> you can't hate calculus
17:32:04 <sbpaul> you can hate learning it
17:32:14 <sbpaul> but that's because your priorities are in the wrong place
17:32:33 <monochrom> hate yourself for entering this school
17:32:54 <Pseudonym> Mind you, they do teach calculus the wrong way.  Well, integral calculus, anyway.
17:33:02 <fax> that's for sure
17:33:20 <cpx> Pseudonym: I'm a fan of Spivak.
17:33:31 <monochrom> People think calculus is taught wrong, the same way people think monad is taught wrong.
17:33:39 <dolio> Hilbert-style is pretty terrible.
17:33:52 <fax> hilbert-style combinator calculus
17:33:52 <fax> lol
17:34:24 <tommd> "Monad is a series of tubes..."
17:34:36 <monochrom> hilbert-style combinator natural lambda sequent wheel
17:34:38 <stevenmarky1> Monad == Internet
17:35:01 <Pseudonym> cpx: What or who is Spivak?
17:35:21 <Pseudonym> I was thinking of Risch.
17:36:37 <fax> I wanna write a progarm
17:37:40 <Pseudonym> fax: I think you should do that.
17:37:49 <gwern> I hate wheels because animals didn't evolve them
17:38:01 <gwern> if wheels were so awesome, how come there aren't wheeled horses?
17:38:02 <gwern> eh eh
17:38:03 <Pseudonym> gwern, the bacterial flagellum is pretty close.
17:38:03 <fax> i can't because im not good at it :(
17:38:27 <gwern> Pseudonym: such pathetic imitations make me spew! pah pah
17:38:42 <Pseudonym> fax: That's why you need to do it.  You don't get better by sitting around moping about how bad you are.
17:38:48 <fax> ;(
17:38:50 * gwern would the flagellums were warm or cold, but they are neither and so I spew you out of my mouth.
17:39:08 <fax> Pseudonym, I don't even understand the algorithm II want to write yet
17:39:14 <Pseudonym> Even better!
17:39:15 <fax> and I have been on it for weeks
17:39:32 <Pseudonym> Working it out by implementing it is the best bit.
17:39:44 <Pseudonym> What's the algorithm?
17:40:09 <fax> Pseudonym, it's invented by Gauss but I don't know if it has a name
17:40:21 <Pseudonym> fax, you've got me intrigued.  Do tell.
17:40:27 <gwern> before the eulers and gausses, we are worms, worms!
17:40:48 <Pseudonym> Yeah, I was about to say.  Euler and Gauss discovered or invented just about everything that's interesting.
17:40:53 <gwern> (the actual quote is "Before the Eulers, Gausses and Newtons, we are worms, worms.", but newton wasn't brought up.)
17:40:55 <Paolo3> that's right! and you can keep an online repository of code. it's www.byteinn.com
17:40:55 <fax> hehe
17:41:19 <Pseudonym> I'm going to add J. Willard Gibbs to that, though.
17:41:32 <Pseudonym> Lesser known, but his name keeps turning up a lot of me lately.
17:41:54 <Pseudonym> I think that the problem with Gibbs is that things tend not to be named after him.
17:42:13 <Pseudonym> So I've been taking to calling the vector cross product the "Gibbs product".
17:42:31 <fax> Pseudonym: it's for calculating expressions of roots of unity, such as (sqrt(5)-1+sqrt(2*sqrt(5)-10))/4
17:42:36 <Pseudonym> Infurate your colleagues today by doing the same!
17:42:43 * gwern makes a note. thwack Pseudonym if he ever starts talking about 'GIBBS/Linux'
17:43:12 * Pseudonym laughs
17:43:15 <contrafunktal> he comes up for his work in thermodynamics frequently
17:43:21 <Pseudonym> Yeah.
17:43:45 <Pseudonym> But also his name turns up in Bayesian modelling.
17:43:49 <fax> I heard about Gibbs phenomenon
17:43:56 <Pseudonym> Gibbs ringing in Fourier analysis, yeah.
17:44:01 <fax> which is the noisy bits in fourier series
17:44:19 <goomba> is that the same gibbs for which gibbs free energy is named
17:44:35 <Pseudonym> goomba: I believe so.
17:44:50 <Pseudonym> Gibbs was actually a physicist, but his name turns up all over the place.
17:45:40 <Pseudonym> He's also known as the father of physical chemistry.
17:45:57 <Pseudonym> He also has a paradox named after him, which is always cool.
17:46:12 <Pseudonym> See, there isn't enough room for polymaths these days.
17:46:25 <fax> I want to be a polymath
17:46:29 <Pseudonym> Yeah, me too.
17:46:46 <benmachine> I want to be a polytope
17:46:47 <fax> but I can barely do ONE math
17:47:04 <Gracenotes> @quote gentoo
17:47:04 <lambdabot> Cale says: Gentoo is a massive waste of electricity.
17:47:10 <Pseudonym> Newton's job title was "physicist, mathematician, astronomer, natural philosopher, alchemist, astrologer, theologian and Warden of the Royal Mint".
17:47:15 <Pseudonym> You never get that these days.
17:47:53 <gwern> Pseudonym: I should hope not
17:48:02 <monochrom> At least it doesn't include "defender of the faith"
17:48:10 <Pseudonym> Mind you, this was back in the day when astrologers still looked at the sky.
17:48:25 <benmachine> I've probably had as much success in alchemy as Newton
17:48:27 <Pseudonym> I'm pretty sure that hasn't happened for at least 200 years.
17:48:54 <gwern> given that I've never seen a horoscope cast for people born in Opiuchus, that seems likely
17:49:03 <Pseudonym> Yeah.
17:49:04 <dolio> monochrom: Henry VIII may have put that one out of style.
17:49:41 <Pseudonym> Anyway, fax.  This algorithm of yours.  Or Gauss'.
17:49:50 <Pseudonym> I'm intrigued.  Tell us more.
17:50:14 <Pseudonym> > (sqrt(5)-1+sqrt(2*sqrt(5)-10))/4
17:50:15 <lambdabot>   NaN
17:50:26 <Pseudonym> sqrt (2 * sqrt 5 - 10)
17:50:30 <Pseudonym> > sqrt (2 * sqrt 5 - 10)
17:50:31 <lambdabot>   NaN
17:50:36 <fax> it's got to be like
17:50:37 <Pseudonym> Oh, duh.
17:50:38 <Pseudonym> Yeah.
17:50:43 <Pseudonym> > sqrt (2 * sqrt 5 - 10) :: Complex
17:50:44 <fax> > ((sqrt(5)-1+sqrt(2*sqrt(5)-10))/4)^5 :: Complex Double
17:50:44 <lambdabot>   `Data.Complex.Complex' is not applied to enough type arguments
17:50:44 <lambdabot>  Expected ki...
17:50:45 <lambdabot>   8.529656777348676e-2 :+ (-9.695959402084306e-2)
17:50:49 <Pseudonym> Right.
17:50:52 <fax> what happened :/
17:50:54 <Pseudonym> > (sqrt(5)-1+sqrt(2*sqrt(5)-10))/4 :: Complex Double
17:50:55 <lambdabot>   0.30901699437494745 :+ 0.5877852522924731
17:50:56 <fax> it says 8
17:51:02 <fax> > ((sqrt(5)-1+sqrt(2*sqrt(5)-10))/4)^7 :: Complex Double
17:51:03 <lambdabot>   1.3898492333766712e-2 :+ 5.52256904953756e-2
17:51:11 <fax> ummm I don't know what is going on there
17:51:16 <fax> it's meant to be 1
17:51:29 <Pseudonym> [ (i, (0.30901699437494745 :+ 0.5877852522924731)^i) | i <- [1..] ]
17:51:37 <Pseudonym> > [ (i, (0.30901699437494745 :+ 0.5877852522924731)^i) | i <- [1..] ]
17:51:38 <lambdabot>   [(1,0.30901699437494745 :+ 0.5877852522924731),(2,(-0.24999999999999997) :+...
17:51:48 <monochrom> "astrologer not looking at sky" is the same as "programmer not looking at machine code"
17:51:57 <Pseudonym> Anyway.
17:52:11 <Pseudonym> fax, looks like you might be suffering from roundoff error there.
17:52:17 <gwern> monochrom: ???
17:52:54 <fax> > ((-sqrt(5)-1+sqrt(2*sqrt(5)-10))/4)^5 :: Complex Double
17:52:54 <Pseudonym> > abs (0.30901699437494745 :+ 0.5877852522924731)
17:52:55 <lambdabot>   1.0000000000000002 :+ 0.0
17:52:55 <lambdabot>   0.6640655130520275 :+ 0.0
17:53:04 <Pseudonym> Aha.
17:53:15 <gwern> :t (:+)
17:53:16 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
17:53:26 <Pseudonym> So what's the algorithm?
17:53:31 <orlandu63> what is (:+)?
17:53:38 <gwern> :i RealFloat
17:53:45 <monochrom> real part and imaginary part
17:53:45 <fax> Pseudonym -- I'm stuck on that bit
17:53:57 <monochrom> x :+ y is x + i y
17:54:04 <orlandu63> a
17:54:07 <orlandu63> ah
17:54:20 <alpounet> @src RealFloat
17:54:21 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
17:54:47 <Pseudonym> fax: Not all roots of unity are expressible with radicals, of course.
17:55:02 <gwern> alpounet: I think @src is intended only for functions, not typeclasses
17:55:03 <fax> Pseudonym: I think they are all supposed to be
17:55:05 <Pseudonym> No.
17:55:14 <alpounet> gwern, it also gives typeclasses
17:55:16 <alpounet> @src Show
17:55:17 <lambdabot> class  Show a  where
17:55:17 <lambdabot>     showsPrec :: Int -> a -> ShowS
17:55:17 <lambdabot>     show      :: a   -> String
17:55:17 <lambdabot>     showList  :: [a] -> ShowS
17:55:27 <gwern> astounding
17:55:37 <fax> Pseudonym: really ? I mean it says here "Gauss generalized his method to
17:55:38 <fax> to find an expression using radicals for any root of unity"
17:55:47 <fax> well
17:55:49 <Pseudonym> Hmm.
17:55:50 <Pseudonym> Maybe.
17:55:51 <fax> that includes cube roots and stuff
17:55:55 <Pseudonym> Oh, right.
17:55:55 <fax> not just square roots
17:56:08 <Pseudonym> Do you know which ones are expressible using square roots?  This will blow your mind.
17:56:15 <fax> fermat primes :)))
17:56:19 <Pseudonym> Yup. :-)
17:56:38 <Pseudonym> Well, a power of two, multiplied by one Fermat prime.
17:56:43 <Pseudonym> Or none, of course.
17:57:12 <Pseudonym> Oh, that's not right.  It's distinct Fermat primes.
17:57:23 <Pseudonym> So it could be 2^8 F0 F3
17:57:30 <Pseudonym> But not 2^8 F0^2
17:57:36 <sbpaul> what's fermat's little theorum?
17:57:54 <fax> sbpaul: that's the one about bracelets
17:57:59 <Pseudonym> sbpaul: a^p = a (mod p) if p is prime
17:58:08 <sbpaul> wow
17:58:25 <mail> e^(pi*i) +  1 = 0
17:58:32 <Pseudonym> sbpaul: Also look up RSA encryption.
17:58:33 <sbpaul> no stipulations on a?
17:58:36 <Pseudonym> Nope.
17:58:37 <sbpaul> yeah i know Pseudonym
17:59:10 <sbpaul> are you sure you phrased that right?
17:59:10 <fax> sbpaul: there is a proof by considering bracelets which is very easy to undertand
17:59:17 <sbpaul> @ Pseudonym
17:59:32 <Pseudonym> I think so, yeah.
17:59:36 <monochrom> If gcd(a,p)=1, you can strengthen to a^(p-1)=1. Otherwise, it's like 0^p=0 "duh"
17:59:38 <benmachine> > 2 ^ 17 `mod` 17
17:59:39 <lambdabot>   2
17:59:41 <Pseudonym> Oh, hang on.  a is coprime to p, yes.
17:59:45 <sbpaul> oh ok
17:59:53 <benmachine> > 3 ^ 17 `mod` 17
17:59:56 <lambdabot>   3
17:59:59 <benmachine> *gasp*
18:00:03 <sbpaul> i misread
18:00:12 <fax> lol you just disproved fermats last theorem
18:00:29 <Pseudonym> Once again, Fermat didn't bother to prove it, citing the length as his excuse..
18:00:36 <Pseudonym> Bastard.
18:00:54 <fax> fermat is so cool
18:01:29 <sbpaul> that's amazing
18:01:46 <fax> > let prime p = all (\a -> (a^p)`mod`p==1) [2..p-1] in filter prime [2..20]
18:01:47 <lambdabot>   [2]
18:02:08 <fax> > let prime p = all (\a -> (a^p)`mod`p==a) [2..p-1] in filter prime [2..20]
18:02:10 <lambdabot>   [2,3,5,7,11,13,17,19]
18:02:16 <gwern> I liked fermatted drinks like mead
18:02:18 <fax> made a mistake first time
18:02:29 <sbpaul> mead is good
18:02:37 <gwern> fax: you could fermat that a little better - spaces wouldn't kill you
18:02:46 <fax> lol
18:02:58 <Pseudonym> I have a couple of questions about mead.  I shall ask them in #haskell-blah
18:03:07 <gwern> fermatters like that, clarity helps
18:03:44 <sbpaul> > let prime p = last (all (\a -> (a^p)`mod`p==a) [2..p-1] in filter prime [2..10000])
18:03:45 <lambdabot>   <no location info>: parse error on input `in'
18:04:01 <gwern> sbpaul: dropped parens
18:04:10 <sbpaul> where
18:04:17 <gwern> jes count'em
18:04:20 <mail> holy moly got automatice putty login
18:04:38 <sbpaul> o_o
18:05:11 <sbpaul> 3 and 3
18:05:19 <fax> 3 and 3?
18:05:35 <sbpaul> i don't see it O_O
18:05:39 <fax> sbpaul
18:05:46 <gwern> sbpaul: yes, but your expressions cross paren boundaries
18:06:11 <gwern> sbpaul: are 'let' and 'in' within the same pair of parentheses?
18:06:20 <sbpaul> oh christ
18:06:24 <gwern> :)
18:06:25 <sbpaul> > let prime p = last (all (\a -> (a^p)`mod`p==a) [2..p-1]) in filter prime [2..10000]
18:06:26 <lambdabot>   Couldn't match expected type `[a]'
18:06:26 <lambdabot>         against inferred type `GHC.Bool....
18:06:35 <sbpaul> fuck it
18:06:37 <sbpaul> time to kill myself
18:07:00 <gwern> despair! despair! this world of inscrutable syntax and type errors has left sbpaul in despair!
18:07:12 * gwern hands sbpaul a rope and points at the nearest lambda
18:07:24 <sbpaul> how am i supposed to hang myself from a lambda
18:07:33 <sbpaul> if i tied it around the crux
18:07:34 <contrafunktal> lowercase works
18:07:34 <benmachine> > let prime p = all (\a -> (a ^ p) `mod` p == a) [2 .. p - 1] in filter prime [2 .. 10000]
18:07:36 <sbpaul> it would just flip upside down
18:07:38 <lambdabot>   mueval-core: Time limit exceeded
18:07:41 <benmachine> :x
18:08:03 <benmachine> > let prime p = all (\a -> (a ^ p) `mod` p == a) [2 .. p - 1] in filter prime [2 .. 100]
18:08:04 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]
18:08:11 <sbpaul> i just want the last prime before 10,000
18:08:25 <fax> sbpaul there is no last prime before 10000
18:08:37 <Pseudonym>  > let prime p = all (\a -> (a ^ p) `mod` p == a) [2 .. p
18:08:46 <gwern> fax: surely there's at least one prime over 9000!
18:08:47 <benmachine> > let prime p = all (\a -> (a ^ p) `mod` p == a) [2 .. p - 1] in last $ filter prime [2 .. 10000]
18:08:51 <lambdabot>   mueval-core: Time limit exceeded
18:08:54 <fax> absoulutely not
18:09:03 <monochrom> @pl \a s -> tacfun (k a) s
18:09:03 <lambdabot> tacfun . k
18:09:10 <Rotaerk> there's obviously a last prime before 10000
18:09:11 <monochrom> I be damned.
18:09:18 <Pseudonym> > let prime p = all (\a -> (a ^ p) `mod` p == a) [2 .. p - 1] in last $ filter prime (2 : [3,5 .. 10000])
18:09:22 <lambdabot>   mueval-core: Time limit exceeded
18:09:40 <benmachine> 9001 is allegedly prime
18:09:45 <sbpaul> > let prime p = all (\a -> (a ^ p) `mod` p == a) [2 .. p - 1] in last $ filter prime
18:09:47 <lambdabot>   Couldn't match expected type `[a]'
18:09:47 <lambdabot>         against inferred type `[a1] -> [...
18:09:49 <sbpaul>                    (2 : [3,5 .. 10000])
18:09:51 <sbpaul> oops
18:10:01 <fax> > let almostPrime p = all (\a -> (a ^ p) `mod` p == a) [2 .. (p-1)`div`2] in filter almostPrime [2 .. 100]
18:10:03 <lambdabot>   [2,3,4,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]
18:10:12 <fax> these are prime enough for government work
18:10:13 <sbpaul> > let prime p = all (\a -> (a ^ p) `mod` p == a) [2 .. p - 1] in last $ filter prime (2 : [9901,9903 .. 10000]
18:10:14 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
18:10:26 <sbpaul> lol
18:10:26 <fax> all the numbers that wanted to be prime but were too scared have a chance now
18:10:31 <sbpaul> i like that phrase
18:10:53 <sbpaul>  > let prime p = all (\a -> (a ^ p) `mod` p == a) [2 .. p - 1] in last $ filter prime (2 : [3,5 .. 10000])
18:11:01 <fax> @let prime p = all (\a -> (a ^ p) `mod` p == a) [2 .. p - 1]
18:11:02 <lambdabot>  Defined.
18:11:05 <sbpaul> > let prime p = all (\a -> (a ^ p) `mod` p == a) [2 .. p - 1] in last $ filter prime (2 : [9903,9905 .. 10000])
18:11:09 <lambdabot>   mueval-core: Time limit exceeded
18:11:10 <fax> > prime 90001
18:11:14 <Pseudonym> @let sieve fs (p:ps) x = let { q = p*p; mults = [[y+s,y+2*s..q] | (s,y) <- fs]; fs' = [(s,last ms)|((s,_),ms)<-zip fs mults]} [x,x+2..q-2` `Data.List.Ordered.minus` foldl Data.List.Ordered.union [] mults
18:11:14 <lambdabot>   Parse error: LeftSquare
18:11:14 <lambdabot>   mueval-core: Time limit exceeded
18:11:15 <fax> > prime 11111
18:11:16 <lambdabot>   False
18:11:20 <fax> LeftSquare ?
18:11:29 * jmcarthur used to have a boss that declared most of his projects "good enough for government work" before abandoning them half done
18:11:33 <Pseudonym> @let sieve fs (p:ps) x = let { q = p*p; mults = [[y+s,y+2*s..q] | (s,y) <- fs]; fs' = [(s,last ms)|((s,_),ms)<-zip fs mults]} in [x,x+2..q-2] `Data.List.Ordered.minus` foldl Data.List.Ordered.union [] mults
18:11:34 <lambdabot>  <local>:3:137: Not in scope: `Data.List.Ordered.minus'
18:11:34 <lambdabot>  
18:11:34 <lambdabot>  <local>:3:169: Not...
18:11:37 <sbpaul> what's erasthoeisnoinesne's sieve in haskell again?
18:11:39 <Pseudonym> Grr.
18:11:39 <benmachine> > 41 * 271
18:11:40 <lambdabot>   11111
18:11:43 <Pseudonym> sbpaul: That.
18:11:48 <Pseudonym> http://www.haskell.org/haskellwiki/Prime_numbers#Multiples_Removal_on_Generated_Spans.2C_or_Sieve_of_Eratosthenes
18:11:49 <sbpaul> ah
18:11:49 <Pseudonym> Or that.
18:12:03 <sbpaul> it's a lot easier to code things when you know what they are
18:12:09 <fax> so
18:12:58 <gwern> it's funny. 'good enough for government work' used to be a compliment.
18:13:04 <sbpaul> gwern: when was that?
18:13:10 <jmcarthur> lies!
18:13:10 <gwern> sbpaul: a long time ago, evidently
18:13:11 <monochrom> @pl \x -> return (concat x)
18:13:12 <lambdabot> return . join
18:13:19 <sbpaul> speaking as a political scientist
18:13:20 <monochrom> @pl \x -> return (f x)
18:13:20 <lambdabot> return . f
18:13:22 <sbpaul> that's never, ever been true
18:13:37 <monochrom> @type fmap
18:13:38 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:13:39 * fax I am reading about Lagrange resolvent
18:13:47 <jmcarthur> return . join  is misunderstood
18:14:19 <contrafunktal> sometimes it's id
18:14:25 <jmcarthur> but not always
18:14:29 <jmcarthur> definitely not for IO
18:14:37 <gwern> sbpaul: I have read it on wiktionary. would it lie to me? http://en.wiktionary.org/wiki/close_enough_for_government_work
18:14:41 <jmcarthur> i have written confusing code with return . join
18:14:47 <jmcarthur> because it looks like id
18:14:56 <gwern> sbpaul: and since when does being a political scientist mean you are an infallible philological expert anyhow?
18:15:01 <sbpaul> i don't know but wikipedia lies to me all the time
18:15:24 <sbpaul> gwern: well, i'm multidisciplinary ;)
18:15:26 <jmcarthur> > return . join $ ["foo", "bar", "baz"]
18:15:27 <lambdabot>   No instance for (GHC.Show.Show (m [GHC.Types.Char]))
18:15:27 <lambdabot>    arising from a use ...
18:15:34 <contrafunktal> Commonly heard in Ontario, Canada and northeast U.S.
18:15:41 * gwern finds 'political scientist' to be funny anyhow
18:15:46 <jmcarthur> > return . join $ ["foo", "bar", "baz"] :: [String]
18:15:47 <lambdabot>   ["foobarbaz"]
18:15:50 <contrafunktal> that reads badly
18:16:07 <benmachine> probably more common that a scientific politician
18:16:18 <sbpaul> it's just social science
18:16:25 <wavewave_> hello. does anybody have some sample code for calling c++ from haskell?
18:16:26 <sbpaul> which is just applied psychology, blah blah blah, physics
18:16:37 <Pseudonym> blah blah blah mathematics
18:16:40 <Pseudonym> Just sayin'.
18:16:46 <jmcarthur> a social scientist is one who experiments with society
18:16:49 <sbpaul> yeah i know
18:16:50 <fax> mathematics is just applied philosophy X)
18:16:53 <sbpaul> god i hate xkcd
18:16:55 <jmcarthur> sounds like a politician to me
18:16:56 <gwern> sbpaul: there's a world of tenuousness embedded in those 'justs'
18:17:10 <wavewave_> I just make c stub code.. but it cannot call c++ from there.
18:17:23 <sbpaul> http://www.goatkcd.com <-- obviously NFSW
18:17:26 <sbpaul> NSFW
18:17:27 <contrafunktal> wavewave_: there are some bindings to qt, though that code is all generated from somewhere
18:17:29 <sbpaul> don't click on that
18:17:32 <sbpaul> under any circumstances
18:17:34 <gwern> chemistry is just applied physics, but it's the rare chemist who whips out the schrodinger wave equation when he needs an answer...
18:17:34 <jmcarthur> not for safe work
18:17:35 <Pseudonym> A piece of music is "just" a time-varying frequency spectrum, but this is not necessarily the best level at which to analyse it.
18:17:48 <sbpaul> Pseudonym: i'm a musician, too
18:17:52 <sbpaul> want to hear my cd?
18:17:55 <wavewave_> contrafunktal: what hackage should I look at?
18:18:08 <jmcarthur> sbpaul: you should play wish haskore
18:18:10 <contrafunktal> I'm not sure it's on hackage
18:18:13 <sbpaul> ?
18:18:18 <Pseudonym> sbpaul: OK, I'm game.
18:18:23 <sbpaul> lol
18:18:26 <gwern> qthaskell is, last I checked, not on hackage
18:18:30 <jmcarthur> i've not tried it, but it is cool in theory
18:18:30 <sbpaul> mmn, which CD to give you
18:18:35 <sbpaul> classical, folk, or weird ambient experimental
18:18:36 <Pseudonym> gwern: YOu should meet my former boss some time.
18:18:39 <gwern> because qthaskell is not really cabalized
18:18:46 <jmcarthur> maybe this music stuff should go to -blah
18:18:54 <Pseudonym> He did whip out the Schroedinger equation when he wanted to calculate the force between two bucky balls.
18:18:57 <contrafunktal> http://qthaskell.berlios.de/ <-- probably not the simplest use of the ffi to get C++
18:19:00 <Pseudonym> Smart guy, that one.
18:19:04 <sbpaul> every time somebody says to take something to blah, the conversation just dies
18:19:11 <wavewave_> I need a cabal package since I am now making it.
18:19:21 <gwern> Pseudonym: how well did it work? bucky balls sound big enough to be computationally demanding..
18:19:24 <jmcarthur> sbpaul: your conversation looks directed enough not to die. it's a music transfer
18:19:34 <Pseudonym> gwern: Turns out the symmetry helps.
18:19:44 <sbpaul> pick one Pseudonym
18:19:53 <jmcarthur> sbpaul: for the record, i'm interested as well, but please. it belongs not here
18:19:59 <Pseudonym> sbpaul: Only one?
18:20:05 <Pseudonym> Yes.  Say it in #haskell-blah.
18:22:11 <mail> why doesn't haskell have e !!!!
18:22:19 <fax> haskEEEEEll
18:22:28 <sbpaul> i like it
18:22:30 <fax> > exp 1
18:22:31 <lambdabot>   2.718281828459045
18:22:51 <contrafunktal> > sqrt (exp 2)
18:22:52 <lambdabot>   2.718281828459045
18:23:00 <mail> :(
18:23:00 <benmachine> mail: too valuable a name to use up on silly constants
18:23:14 <contrafunktal> they did it for pi
18:23:14 <fax> > let fact n = product [1..n] in   999/(fact 999)**(1/999)
18:23:15 <lambdabot>   0.0
18:23:19 <mail> list of all constants pls
18:23:23 <benmachine> pi is less cool than e
18:23:27 <benmachine> as a name
18:23:36 <fax> > let fact n = product [1..n] in   99/(fact 99)**(1/99)
18:23:37 <lambdabot>   2.631362082137783
18:23:42 <sbahra> pi has a cooler symbol.
18:23:48 <fax> > let fact n = product [1..n] in   999/(fact 999)**(1/999) :: CReal
18:23:51 <benmachine> mail: this is a purely functional language you're talking about
18:23:52 <lambdabot>   mueval-core: Time limit exceeded
18:23:59 <benmachine> mail: let me know when you find something that's not a constant :)
18:24:17 <mail> IO stuff?
18:24:30 <fax> > let fact n = product [1..n] in  sum . map (\n -> 1/fact n) $ [1..100]
18:24:31 <lambdabot>   1.7182818284590455
18:24:31 <benmachine> getLine is always getLine
18:24:35 <fax> > let fact n = product [1..n] in  sum . map (\n -> 1/fact n) $ [0..100]
18:24:36 <lambdabot>   2.7182818284590455
18:24:41 <benmachine> the execution is something else
18:25:03 <fax> > log (sqrt(-pi*pi)) :: Complex Double
18:25:04 <lambdabot>   1.1447298858494002 :+ 1.5707963267948966
18:25:44 <fax> > (1+1/9999)**(9999) :: CReal
18:25:45 <lambdabot>   2.7181459132349482202572127477235094879078
18:26:02 <byorgey> > 20 - exp pi + pi
18:26:03 <lambdabot>   9.000208105263141e-4
18:26:18 <dolio> > exp 1 - (1 + 1/9999)**9999 :: CReal
18:26:19 <lambdabot>   0.0001359152240970151030747236291530098495
18:26:20 <fax> byorgey I really enjoyed reading that proof today of pi not rational!
18:26:33 <byorgey> fax: oh, great, glad you enjoyed it! =)
18:26:37 <fax> byorgey - that was great because it was so simple and clear
18:26:46 * contrafunktal isn't rational either
18:26:48 <byorgey> thanks
18:27:06 <byorgey> contrafunktal: prove it
18:27:08 <fax> a bit magic I don't know how he can have thought this up but certainly it makes sense
18:28:03 <Cale> > exp (pi * sqrt 163) :: CReal
18:28:04 <lambdabot>   262537412640768743.9999999999992500725971981856888793538563
18:28:08 <fax> > let epsilon = 1/9999 in (1+epsilon)^(1/epsilon) :: CReal
18:28:09 <lambdabot>   No instance for (GHC.Real.Integral Data.Number.CReal.CReal)
18:28:09 <lambdabot>    arising from...
18:28:15 <fax> > let epsilon = 1/9999 in (1+epsilon)**(1/epsilon) :: CReal
18:28:16 <lambdabot>   2.7181459132349482202572127477235094879078
18:28:19 <byorgey> fax: yeah, I still don't really have a good intuition for how he might have gone about coming up with it
18:28:27 <mail> > realPart $ (exp $ 0:+pi) + 1
18:28:28 <lambdabot>   0.0
18:28:29 <sbahra> @hackage creal
18:28:29 <lambdabot> http://hackage.haskell.org/package/creal
18:28:39 <byorgey> mail: =)
18:28:43 <fax> byorgey: I guess that's why we call it 'mathematician' rather than 'mathology' :D
18:28:49 <byorgey> hehe
18:28:54 <sbahra> Oh.
18:29:09 <dfkjjkfd> fax: which proof?
18:29:11 <byorgey> @hackage thisisnotreallyapackage
18:29:12 <lambdabot> http://hackage.haskell.org/package/thisisnotreallyapackage
18:29:12 <fax> Cale - do you know who created this ?
18:29:22 <Cale> created what?
18:29:43 <fax> Cale - that brilliant expression which is very close to an integer.. it looks ramanujanesquue
18:29:50 <sbahra> @hackage yeah kind of useless
18:29:50 <lambdabot> http://hackage.haskell.org/package/yeah kind of useless
18:29:58 <fax> dfkjjkfd: http://www.mathlesstraveled.com/?p=548
18:30:18 <benmachine> @hackage save somes typing though
18:30:19 <lambdabot> http://hackage.haskell.org/package/save somes typing though
18:30:20 <mail> > (exp pi) - pi
18:30:21 <lambdabot>   19.999099979189474
18:30:23 <dfkjjkfd> fax : thank you
18:30:33 <Cale> exp (pi * sqrt 163) is actually called Ramanujan's constant
18:30:37 <fax> > exp(pi*sqrt(58))-396^4+4 :: CReal
18:30:38 <benmachine> oh, moved my pluralisation by like a word
18:30:38 <lambdabot>   -100.0000001777867585304238076447341877723898
18:30:49 <byorgey> benmachine: yeah, that was funny =)
18:30:50 <Cale> But it wasn't discovered by him
18:31:02 <Cale> It was discovered by Hermite in 1859
18:31:02 <Mathnerd314> @google hackage creal
18:31:03 <lambdabot> http://hackage.haskell.org/package/cereal-0.2
18:31:03 <lambdabot> Title: HackageDB: cereal-0.2
18:31:15 <fax> Cale: oh cool there is a theory for finding such numbers :D
18:31:23 <fax> "Modular Function"
18:31:30 <mail> > (9^2+19^2/22)^(1/4)
18:31:31 <lambdabot>   Ambiguous type variable `t' in the constraints:
18:31:31 <lambdabot>    `GHC.Real.Integral t'
18:31:31 <lambdabot>   ...
18:31:42 <fax> mail it has to be ** rather than ^ ..(I just found this out)
18:31:59 <mail> oh for fractios
18:32:05 <Cale> and Martin Gardner made an April Fools' claim that it was an integer and that and that Ramanujan had predicted it :)
18:32:05 <mail> > (9^2+19^2/22)**(1/4)
18:32:06 <lambdabot>   3.1415926525826463
18:32:14 <fax> haha
18:32:19 <Cale> er, s/and that//
18:32:19 <fax> that's evil
18:34:25 <mail> > sqrt(-1)
18:34:26 <lambdabot>   NaN
18:34:48 <Cale> > sqrt (-1) :: Complex Double
18:34:49 <lambdabot>   (-0.0) :+ 1.0
18:35:06 <mail> does :: perform casting?
18:35:12 <fax> no
18:35:37 <Mathnerd314> > (sqrt (-1) :: Complex Double) - (0 :+ 1)
18:35:38 <lambdabot>   (-0.0) :+ 0.0
18:35:39 <fax> the typeclass will choose a default if it doesn't know better
18:35:42 <Cale> No, it just insists on a particular type
18:35:55 <Mathnerd314> > ((sqrt (-1) :: Complex Double) - (0 :+ 1)) * (1/0)
18:35:56 <lambdabot>   NaN :+ NaN
18:36:29 <Cale> > (sqrt (-1) :: Complex Double) :: Double -- this doesn't work ;)
18:36:30 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
18:36:30 <lambdabot>         against inferred ty...
18:36:53 <Mathnerd314> I just remember there was some case where -0 /= 0
18:37:11 <benmachine> > (-0 :: Double) == 0
18:37:12 <lambdabot>   True
18:37:20 <Cale> > let f x = 1/x in f 0 == f (-0)
18:37:21 <lambdabot>   False
18:37:31 <sbpaul> magicman|sleep:
18:37:31 <Cale> > 0 == (-0)
18:37:32 <lambdabot>   True
18:37:38 <benmachine> > let f x = 1/x in f 0 == f 0
18:37:39 <lambdabot>   True
18:37:39 <Cale> extensionality fail
18:37:42 <fax> lol
18:37:44 <benmachine> oic
18:37:57 <benmachine> > let f x = 0/x in f 0 == f 0
18:37:58 <lambdabot>   False
18:38:00 <Mathnerd314> > 1/((sqrt (-1) :: Complex Double) - (0 :+ 1))
18:38:01 <lambdabot>   NaN :+ NaN
18:38:01 <sbpaul> damn
18:38:02 <sbpaul> did i miss him
18:38:11 <Cale> > let x = 0/0 in x == x
18:38:11 <lambdabot>   False
18:38:50 <Cale> Floating point really sucks sometimes
18:39:00 <benmachine> it's unmathematical
18:39:42 <Mathnerd314> > 1/0
18:39:43 <lambdabot>   Infinity
18:39:46 <Mathnerd314> > 1/-0
18:39:46 <lambdabot>   Not in scope: `/-'
18:39:50 <Mathnerd314> > 1/ -0
18:39:51 <lambdabot>   Precedence parsing error
18:39:51 <lambdabot>      cannot mix `GHC.Real./' [infixl 7] and prefix...
18:39:55 <dolio> Parens.
18:39:55 <Cale> > 1/(-0)
18:39:55 <Mathnerd314> > 1/ (-0)
18:39:56 <lambdabot>   -Infinity
18:39:56 <lambdabot>   -Infinity
18:40:10 <fax> > (5**(1/8))*(35**(1/3)) :: CReal
18:40:11 <lambdabot>   4.0000055937272838377067005082679841181482
18:41:36 <Mathnerd314> @where CReal
18:41:36 <lambdabot> http://darcs.augustsson.net/Darcs/CReal/CReal.hs and http://darcs.augustsson.net/Darcs/CReal/CRealI.hs
18:41:54 <dolio> CReal is in the numbers package.
18:41:58 <dolio> Or maybe Numbers, I forget.
18:42:26 <fax> > ((1/pi)*log(640320^3+744))^2 :: CReal
18:42:26 <lambdabot>   163.0000000000000000000000000000232167779425
18:42:29 <fax> lol
18:42:32 <dolio> Nope. Lowercase n.
18:42:38 <Mathnerd314> @hackage numbers
18:42:38 <lambdabot> http://hackage.haskell.org/package/numbers
18:43:36 <Mathnerd314> maybe someone could tell lambdabot that?
18:43:49 <fax> "To date, no explanation has been given for why Gelfond's constant (eÏ€) is nearly identical to Ï€ + 20,[1]  which is therefore regarded to be a mathematical coincidence."
18:43:50 <mail> > :t ((1::Integer)::Int)
18:43:51 <lambdabot>   <no location info>: parse error on input `:'
18:44:05 <mail> > :?
18:44:05 <lambdabot>   <no location info>: parse error on input `:?'
18:44:28 <dmwit> :t 1 :: Integer
18:44:29 <lambdabot> Integer
18:44:37 <dmwit> :t (1 :: Integer) :: Int -- an error
18:44:38 <lambdabot>     Couldn't match expected type `Int' against inferred type `Integer'
18:44:38 <lambdabot>     In the expression: (1 :: Integer) :: Int
18:44:42 <dmwit> > 1 :: Integer
18:44:42 <lambdabot>   1
18:45:01 <mail> where is lambda bot docs
18:45:12 <fax> > sin(2017*2**(1/5)) :: CReal
18:45:13 <lambdabot>   -0.9999999999999999785677712610609832590685
18:45:19 <dmwit> ?list
18:45:19 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
18:45:29 <dmwit> mail: There, and:
18:45:32 <dmwit> ?where lambdabot
18:45:32 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
18:45:34 <dmwit> there
18:45:35 <greedo> so I'm stuck
18:45:35 <fax> what about a haskell program that finds almost integers?
18:46:05 <fax> > cos(pi*cos(pi*cos(log(pi+20)))) :: CReal
18:46:06 <lambdabot>   -0.9999999999999999999999999999999999606784
18:46:06 <byorgey> greedo: how so?
18:46:29 <greedo> i need to get a constant_pool_count into a function to use for replicateM
18:46:50 <greedo> but i can't figure out how i should do it
18:47:04 <greedo> utf8 <- replicateM (fromIntegral (c1_constant_pool_count c1) - 1) getWord8
18:47:13 <mail> @help
18:47:14 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:47:18 <mail> @list
18:47:19 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
18:47:35 <mail> @vixen
18:47:36 <lambdabot> wanna hear a story?
18:47:45 <dmwit> greedo: That looks fine to me. What goes wrong?
18:47:51 <fax> this one is amazing
18:47:55 <greedo> except that c1_constant_pool_count c1 is not in this function
18:47:57 <mail> wth ..
18:48:02 <Cale> > cos(pi*cos(pi*cos(pi/3))) :: CReal
18:48:03 <lambdabot>   1.0
18:48:06 <mail>  <lambdabot> When i get kinky, i have been known to engage in watersports... Does that turn you on as well?
18:48:12 <mail> @vixen
18:48:12 <lambdabot> have you ever made it with a man?
18:48:13 <greedo> so c1 is not in scope
18:48:17 <byorgey> greedo: and what's wrong with that code you just pasted?
18:48:18 <fax> > sqrt((61421-23*sqrt(5831385)/30)/2 :: CReal
18:48:19 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
18:48:24 <fax> darne
18:48:35 <greedo>  Not in scope: `c1'
18:48:37 <dmwit> greedo: So... make it a parameter of the enclosing function and pass it in.
18:48:41 <fax> Cale ahah what
18:48:50 <fax> that's really an integers
18:48:52 <fax> -s
18:49:05 <mail> > arccos(2)
18:49:05 <lambdabot>   Not in scope: `arccos'
18:49:07 <Cale> fax: yes
18:49:10 <dmwit> > cos(pi/3) :: CReal
18:49:11 <lambdabot>   0.5
18:49:17 <greedo> is that the best way to do that?
18:49:20 <dmwit> > cos(pi/2) :: CReal
18:49:20 <mail> :t CReal
18:49:21 <lambdabot>   0.0
18:49:21 <lambdabot> Not in scope: data constructor `CReal'
18:49:23 <fax> the hardest bit of finding these expressions is probably generating interesting looking ones
18:49:28 <dmwit> :k CReal -- mail
18:49:29 <lambdabot> *
18:49:32 <fax> (theyh have to be relatively interesting to be true)
18:49:37 <byorgey> greedo: it's the only way =)
18:49:43 <dmwit> :t acos
18:49:44 <lambdabot> forall a. (Floating a) => a -> a
18:49:50 <dmwit> > acos 2 -- mail
18:49:51 <lambdabot>   NaN
18:50:11 <benmachine> > acos 2 :: Complex Float
18:50:12 <lambdabot>   0.0 :+ 1.3169578
18:50:28 <Cale> greedo: ... it's the only way :)
18:50:29 <dmwit> greedo: All other ways of doing that are just sugar for that. =)
18:50:48 <dmwit> byorgey, Cale: implicit parameters, reader/state monad, ... probably others
18:50:52 <benmachine> haskell is just sugar for a turing machine
18:51:13 <byorgey> dmwit: yes, I thought about that and then decided to mean implicitly what you said =)
18:51:16 <greedo> http://tamu.pastebin.com/TW7LwZYA
18:51:29 * dmwit nods
18:52:11 <greedo> don't think that works with getConstantPool
18:52:14 <Cale> wow, this looks brutal
18:52:27 <mail> > putStrLn "lol"
18:52:28 <lambdabot>   <IO ()>
18:52:38 <mail> :(
18:52:40 <fax> @lol
18:52:41 <lambdabot> Maybe you meant: do let pl url yow
18:52:56 <Cale> mail: It evaluated the expression like you wanted, it just didn't execute the resulting IO action.
18:53:07 <byorgey> greedo: why not?  add c1 as a parameter to getConstantPool, then pass c1 as an argument when you call getConstantPool in getClass
18:53:11 <dmwit> greedo: What's the exact error? That replicateM looks fine to me.
18:53:19 <mail> how do i exec
18:53:32 <dmwit> Oh, I see.
18:53:42 <dmwit> mail: As in Unix-style exec?
18:53:45 <Cale> mail: lambdabot won't because it's unsafe
18:53:48 <byorgey> greedo: in fact, even better, pass (fromIntegral (c1_constant_pool_count c1) - 1) as an argument to getConstantPool
18:53:52 <fax> Vijayaraghavan <-- there's an interesting name
18:54:00 <mail> eval
18:54:05 <mail> @eval
18:54:12 <dmwit> ?eval "lol"
18:54:22 <dmwit> > "lol" -- well, this way, anyway
18:54:23 <lambdabot>   "lol"
18:54:24 <greedo> byorgey: that's what I was thinking
18:54:32 <dmwit> > "lol" ++ " mail is awesome"
18:54:33 <lambdabot>   "lol mail is awesome"
18:54:37 <Cale> Yeah, you're calling getConstantPool only from a place where you have that number anyway
18:55:00 <jmcarthur> @yow
18:55:01 <lambdabot> Couldn't find fortune file
18:55:05 <greedo> nope
18:55:16 <greedo> ghci still complains
18:55:30 <Cale> greedo: What does it complain about?
18:55:39 <greedo> utf8 <- replicateM (fromIntegral (c1_constant_pool_count c1) - 1) getWord8
18:55:46 <Cale> greedo: Just pass the number in as a parameter to getConstantPool
18:56:03 <Cale> (and make getConstantPool into a function)
18:56:08 <greedo> cp <- replicateM (fromIntegral (c1_constant_pool_count c1) - 1) getConstantPool (fromIntegral (c1_constant_pool_count c1) - 1)
18:56:19 <Cale> That's passing 3 parameters to replicateM
18:56:21 <dmwit> needs more parens
18:56:30 <dmwit> also needs a let for readability
18:56:38 <Cale> yeah
18:56:44 <dmwit> let cpCount = fromIntegral (c1_constant_pool_count c1) - 1
18:56:44 <Cale> Never copy/paste code
18:56:53 <dmwit> cp <- replicateM cpCount (getConstantPool cpCount)
18:56:57 <Cale> (there's enough repetition in this code as it is ;)
18:57:46 <dmwit> ?pl \cpCount -> replicateM cpCount (getConstantPool cpCount) -- I smell an ap
18:57:46 <lambdabot> ap replicateM getConstantPool
18:58:26 <greedo> that still fails
18:58:29 <greedo> argh
18:58:31 <dmwit> I simultaneously recommend and condemn ap.
18:58:39 <Mathnerd314> @type ap
18:58:40 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
18:58:47 <Mathnerd314> oh, fmap for monads
18:58:51 <greedo> parser.hs:158:62: Not in scope: `c1'
18:58:53 <Cale> Not fmap, ap
18:58:55 <dmwit> greedo: Paste the new code (not in-channel, of course) and the exact error, if you can't work it out for yourself.
18:59:01 <Mathnerd314> @src ap
18:59:02 <lambdabot> ap = liftM2 id
18:59:02 <shepheb> dmwit: like Perl? it's horrible, evil, and so useful.
18:59:06 <byorgey> Mathnerd314: no, it's (<*>) for monads
18:59:07 <Cale> fmap for monads is called liftM
18:59:16 <Mathnerd314> @type liftM
18:59:17 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
18:59:24 <Mathnerd314> oh, ok
18:59:30 <Mathnerd314> @type (<*>)
18:59:32 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
18:59:37 <dmwit> shepheb: Yeah, or PHP.
18:59:38 <Cale> (it should always be identical in function to fmap)
18:59:56 <greedo> http://tamu.pastebin.com/4AMysxvg
19:00:33 <Cale> greedo: getConstantPool still doesn't have a function parameter
19:00:34 <dmwit> greedo: ...you didn't change getConstantPool to take a parameter.
19:00:39 <byorgey> greedo: well, you have to change getConstantPool to take an argument, and change the replicateM to use it
19:01:14 <byorgey> stupid lag =(
19:01:20 <dmwit> greedo: The error itself should be pretty clear in this case. Something along the lines of "trying to apply a non-function to an argument", which is a pretty darn good clue IMO.
19:01:27 <fax> "file has been removed for infringement of copyrights" --- but I wanted to infringe of copyrights :(
19:01:48 <Cale> fax: That is really easy enough to do ;)
19:02:17 <Cale> fax: http://eztv.it/ ;)
19:03:39 <clanehin_> wants a good data structure for a most-recently-used queue, but has no idea
19:03:51 <greedo> so, change the definition of getConstantPool
19:04:02 <Cale> greedo: yes, that's what we've been suggesting all along :)
19:04:18 <greedo> i hope i'm doing this right
19:04:23 <byorgey> greedo: so instead of  getConstantPool = ...  you will have  getConstantPool cpCount = ...
19:04:35 <byorgey> then use cpCount in the replicateM later
19:04:49 <c_wraith> clanehin_: You could start from my lrucache package on hackage, but reverse what side new elements are inserted on?
19:04:58 <Cale> greedo: If you need a piece of information to be able to do that which isn't accessible from inside getConstantPool itself, you had better make it a parameter to getConstantPool. Essentially all mechanisms for solving the problem will do this in one way or another.
19:05:07 <mail> > let x = [5,9] in filter (\y -> not $ null [n | n <- x, y `mod` n == 0]) [1..]
19:05:08 <lambdabot>   [5,9,10,15,18,20,25,27,30,35,36,40,45,50,54,55,60,63,65,70,72,75,80,81,85,9...
19:05:25 <mail> > let x = [1..] in filter (\y -> not $ null [n | n <- x, y `mod` n == 0]) [1..]
19:05:26 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
19:05:27 <c_wraith> > () ()
19:05:28 <lambdabot>   Couldn't match expected type `() -> t' against inferred type `()'
19:05:30 <clanehin_> c_wraith: that's about what I want, I'll take a look
19:05:33 <greedo> getConstantPool cpCount = do
19:05:39 <mail> > let x = [2..] in filter (\y -> not $ null [n | n <- x, y `mod` n == 0]) [1..]
19:05:42 <lambdabot>   mueval-core: Time limit exceeded
19:05:45 <Cale> clanehin_: You could use a Data.Sequence
19:06:27 <Cale> clanehin_: Well, I don't really know what a most-recently-used queue is...
19:06:44 <clanehin_> Cale: cons would be O(n), because if the element is already in the sequence, it has to be moved to the front
19:06:45 <byorgey> mail: that last one will just loop because it spends an infinite amount of time checking that 1 is not divisible by any of the numbers [2..]
19:07:00 <clanehin_> Cale: which isn't soooo terrible.
19:07:34 <Cale> clanehin_: hmm, you could use a PSQueue
19:07:40 <mail> > let x = [] in filter (\y -> not $ null [n | n <- x, y `mod` n == 0]) [1..]
19:07:43 <lambdabot>   mueval-core: Time limit exceeded
19:08:12 <Cale> clanehin_: It's a data structure which efficiently supports both the operations of a priority queue and a search tree.
19:08:16 <mail> > let x = [0] in filter (\y -> not $ null [n | n <- x, y `mod` n == 0]) [1..]
19:08:17 <lambdabot>   *Exception: divide by zero
19:08:36 <mail> bah need to catch these expecitons
19:09:16 <dmwit> That or not generate them in the first place.
19:09:53 <Cale> Catching exceptions generated by pure code is awkward
19:10:00 <mail> multiples [] = "Fuck you prefessor"
19:10:14 <byorgey> mail: moderate the language please.
19:10:16 <mail> multiples [0] = "Fuck you professor"
19:10:20 <fax> :S
19:10:26 <fax> aren't we allowed bad language in here
19:10:28 <mail> kk
19:10:31 <clanehin_> Cale, c_wraith, thanks, I think I can make one of these work.
19:10:33 <byorgey> no, we aren't
19:10:39 <mail> yeah didn't realise this was pg
19:10:39 <byorgey> you can say whatever you like in -blah
19:10:49 <Cale> Only lambdabot is allowed to talk dirty
19:10:55 <mail> @vixen
19:10:56 <lambdabot> My sister likes Yahoo better. Her screenname is FoxxyGurl83. If you have yahoo you should message her, she's just as pretty as me :)
19:11:29 <Pseudonym> Ah, here we go.
19:11:41 <Pseudonym> > let{b=10;s c (d:ds) = let { k=b*d; q=k`div`c; ~(d':ds')=s(c+1)ds } in if q==(k+b-1)`div`c then k`div`c:(k`mod`c+d'):ds' else (k+d')`div`c:(k+d')`mod`c:ds';nd q=let(d:ds)=s 2 q in d:nd ds} in 2:nd(fix(1:))
19:11:43 <lambdabot>   [2,7,1,8,2,8,1,8,2,8,4,5,9,0,4,5,2,3,5,3,6,0,2,8,7,4,7,1,3,5,2,6,6,2,4,9,7,...
19:11:49 <fax> woah cool
19:12:00 <Pseudonym> As much e as you can take.
19:12:04 <iaefai> Is hpaste down?
19:12:05 <fax> lol
19:12:14 <dcoutts_> hia byorgey, btw, I'm really quite pleased with the new cabal init, we should advertise it more
19:12:23 <Pseudonym> Note the b=10 at the start; change that if you need a different base.
19:12:28 <dcoutts_> byorgey: I guess I should announce the cabal-install-0.8.x release :-)
19:12:32 <Jafet> > exp 1 :: CReal
19:12:33 <lambdabot>   2.7182818284590452353602874713526624977572
19:12:38 <byorgey> dcoutts_: thanks!  yeah, I was planning to write a blog post about cabal init soon
19:12:39 <jmcarthur> > exp 1 :: CReal  -- as much e as you can take
19:12:40 <lambdabot>   2.7182818284590452353602874713526624977572
19:12:41 <jmcarthur> dang
19:12:43 <jmcarthur> beaten
19:12:44 <dcoutts_> byorgey: cool
19:12:51 <fax> it only works when the digits are in a list
19:12:58 <Cale> Pseudonym: Continued fraction expansion?
19:13:03 <byorgey> dcoutts_: I'm waiting for my circular tuit to arrive
19:13:04 <Jafet> > showCReal 1000 (exp 1 :: CReal)
19:13:05 <lambdabot>   "2.718281828459045235360287471352662497757247093699959574966967627724076630...
19:13:06 <Pseudonym> No, spigot algorith,.
19:13:12 <dcoutts_> byorgey: ;-)
19:13:17 <iaefai> byorgey: What is cabal init?
19:13:26 <dmwit> iaefai: http://downforeveryoneorjustme.com/hpaste.org
19:13:28 <Pseudonym> I do have a continued fraction version sitting around somewhere.
19:13:31 <jmcarthur> > showCReal maxBound $ exp 1
19:13:32 <lambdabot>   "*Exception: Negative exponent
19:13:36 <jmcarthur> o_O
19:13:47 <jmcarthur> > showCReal (maxBound-1) $ exp 1
19:13:48 <lambdabot>   "*Exception: Negative exponent
19:13:50 <jmcarthur> :(
19:13:57 <fax> > showCReal (maxBound-1) $ exp (-1)
19:13:58 <lambdabot>   "*Exception: Negative exponent
19:13:59 <fax> that's better
19:14:00 <iaefai> dmwit: nice site
19:14:03 <fax> now the error is correct
19:14:03 <byorgey> iaefai: you can just type 'cabal init' at a prompt and it will interactively create a .cabal file for your project
19:14:06 <jmcarthur> lol
19:14:16 <dcoutts_> byorgey: only thing I was wondering about is the --no-comments option. We want to encourage people to not have massive fully commented .cabal files when they upload them to hackage, but it's obviously really useful for the first couple times users use it
19:14:19 <iaefai> sweet, is that in cabal-install .8.2?
19:14:23 <mail> > nubBy(((>1) .) . gcd) [2..]
19:14:25 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
19:14:31 <byorgey> iaefai: yep
19:14:35 <fax> what's the shortest way to make primes in haskell?
19:14:43 <Pseudonym> Probably that, fax.
19:14:43 <mail> 03:14 | <mail> > nubBy(((>1) .) . gcd) [2..]
19:14:45 <fax> is it known to be that gcd way?
19:14:53 <Pseudonym> You cna shave a few spaces off.
19:14:59 <iaefai> I might be using that
19:15:12 <byorgey> dcoutts_: yeah, maybe we should instead prompt people whether they want a commented version
19:15:13 <Pseudonym> But the real shortest way is to grab an implementation out of a can.
19:15:15 <dcoutts_> byorgey: ideally we could have it for newbies and turn it off thereafter, perhaps we could make it one of the interactive prompt things?
19:15:20 <dcoutts_> byorgey: just what I was thinking
19:15:25 <byorgey> yep, sounds good
19:16:04 <dcoutts_> byorgey: and a suitable suggestive comment "useful for newbies" so that once people no longer self-identify then they'll stop using it :-)
19:16:21 <mail> >   product [1..6]
19:16:22 <lambdabot>   720
19:16:23 <byorgey> right =)
19:17:01 <mail> > unfoldr (\(f1,f2) -> Just (f1,(f2,f1+f2))) (0,1)
19:17:02 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
19:17:14 <byorgey> dcoutts_: cool, I'll try to code that up soon
19:17:18 <jmcarthur> > let fac = product . enumFromTo 1 in fac 6
19:17:19 <lambdabot>   720
19:17:28 <dcoutts_> byorgey: great
19:17:29 <byorgey> or anyone could, really
19:17:37 <dmwit> > fix (\xs -> 1 : 1 : zipWith (+) xs (tail xs))
19:17:38 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
19:17:41 <dcoutts_> byorgey: true true, find a minion :-)
19:17:55 <jmcarthur> @pl fix (\xs -> 1 : 1 : zipWith (+) xs (tail xs))
19:17:56 <lambdabot> fix ((1 :) . (1 :) . ap (zipWith (+)) tail)
19:18:04 <mail> > [1,1]^3
19:18:05 <lambdabot>   No instance for (GHC.Num.Num [t])
19:18:05 <lambdabot>    arising from a use of `GHC.Real.^' at ...
19:18:07 <byorgey> dcoutts_: ok, if you know of any people wanting to contribute to cabal looking for an easy project, you can send them my way =)
19:18:13 <dcoutts_> byorgey: arguably the advertising is more important
19:18:14 <dmwit> > map (^3) [1, 1]
19:18:15 <lambdabot>   [1,1]
19:18:29 <dmwit> mail: Perhaps you're looking for matrix multiplication...?
19:18:31 <dcoutts_> byorgey: will do, kmc has been doing some great hacking recently, knocking off several tickets
19:18:35 <byorgey> dcoutts_: agreed.  And once we advertise we'll probably get tons of other bug reports + feature requests anyway.
19:18:40 <dcoutts_> :-)
19:18:41 <dcoutts_> right
19:18:50 <benmachine> [1,1]^3 = [1,3,3,1]
19:18:53 <benmachine> I reckons
19:18:57 <Jafet> > fix ((0:) . (1:) . ap (zipWith (+)) tail)
19:18:58 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
19:19:01 <byorgey> I actually already have a few bug reports for cabal init I need to fix
19:19:16 <dmwit> benmachine: ...
19:19:17 <dcoutts_> byorgey: I made a few tweaks in 0.8.2
19:19:26 <dmwit> benmachine: I suppose that's no more arbitrary than any other definition.
19:19:33 <byorgey> dcoutts_: great, what tweaks?
19:19:36 <dcoutts_> @tell kmc perhaps talk to byorgey about a useful Cabal ticket relating to cabal init, he can explain the issue and how to go about it
19:19:36 <lambdabot> Consider it noted.
19:19:53 <byorgey> dmwit: it's far less arbitrary than most.
19:20:06 <jmcarthur> > fix $ (0:) . (1:) <<< zipWith (+) <*> tail
19:20:08 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
19:20:15 <benmachine> dmwit: polynomial coefficients
19:20:16 <dcoutts_> byorgey: I tweaked the BSD license iirc, to match the language and formatting on the OSI site, maybe it was just the form of the copyright line, I forget
19:20:24 <dmwit> > let xs * ys = zipWith (+) (tail xs) xs; xs ^ n = iterate (*xs) xs !! n in [1, 1] ^ 3
19:20:25 <lambdabot>   *Exception: Prelude.tail: empty list
19:20:29 <dcoutts_> byorgey: and I removed a field that I plan to deprecate
19:20:34 <byorgey> oh, yeah, cool, I saw that
19:20:34 <dmwit> ah, right
19:20:39 <byorgey> I remember now
19:21:00 <dcoutts_> byorgey: what else have you had reported?
19:21:36 <hstefan> hey, I'm starting to learn wxHaskell, so, can anyone show me some tutorial/book?
19:22:00 <sshc> hstefan: How did you manage to start learning wxHaskell without a reference?
19:22:12 <dcoutts_> byorgey: oh and I removed the #! runghc line from the generated Setup.hs
19:23:07 <byorgey> dcoutts_: apparently there's a situation where it can crash while searching subdirectories for .hs modules to include in the exported-modules
19:23:12 <byorgey> I forget the details
19:23:17 <hstefan> sshc: that's why I'm asking for any.
19:23:22 <byorgey> also there was a request to allow multiple categories
19:23:27 <dcoutts_> byorgey: ah, perhaps symlinks
19:23:33 <byorgey> yeah, maybe
19:23:55 <sshc> hstefan: http://google.com/ â€” read a tutorial and then the documentation
19:24:06 <byorgey> I have these in my personal bug tracker but I suppose I should really put them into the cabal bug tracker =)
19:24:20 <dmwit> hstefan: There may not be a Haskell-specific wx tutorial.
19:24:20 <dcoutts_> byorgey: it'd help if you want to get a minion to do it
19:24:29 <byorgey> indeed.
19:24:42 <byorgey> I'll do that soon too
19:24:47 <hstefan> dmwit: hmm, ok then...
19:24:50 <dcoutts_> and we're likely to get dups reported to us anyway
19:24:51 <dmwit> hstefan: It's generally assumed that you know one of the GUI libraries before you use the corresponding Haskell binding.
19:25:16 <dmwit> hstefan: This is, admittedly, a pretty bad weakness of our documentation. I encourage you to write down the things that you would have liked to read as you go!
19:25:24 <Pseudonym> fax: I just looked up the Gauss algorithm, and I don't understand it either.
19:25:35 <sshc> I've read several wxHaskell tutorials
19:25:41 <sshc> I just used Google
19:25:55 <fax> Pseudonym -- I think one of the crucial parts is that the automorphism group which fixes Q lets you make new equations from old ones
19:25:56 <dmwit> sshc: Great! Maybe you can recommend which one is good, then.
19:25:57 <hstefan> dmwit: you mean, write my own tutorial for future sharing?
19:26:31 <sshc> dmwit: I can't.  I just don't remember.
19:26:39 <dmwit> hstefan: I mean exactly that! But sshc is suggesting that I may be wrong, and that there are some good ones out there already. =)
19:27:13 <fax> Pseudonym: where did you look it up ?? I have read about 3 different sources and I stil don't really get it
19:27:16 <Pseudonym> fax, I did find Maple code.
19:27:34 <Pseudonym> http://portal.acm.org/citation.cfm?id=240065.240070
19:28:00 <byorgey> dmwit: in an idle moment (hah) we ought to write Haskell bindings to the FogBugz API.
19:28:20 <dmwit> ha!
19:28:24 <dmwit> That would be fun. =)
19:28:30 <hstefan> dmwit: you made a good point, I think that it's an great idea :P
19:28:39 <byorgey> well, it would be fun HAVING them.  I dunno about writing them ;-)
19:29:14 <byorgey> nah, writing them could be fun too =)
19:32:48 <greedo> hpaste fails a lot
19:33:13 <mail> Pseudonym university of bristol?
19:33:25 <Pseudonym> Sorry, what?
19:33:42 <mail> that portal
19:33:52 <Pseudonym> No, it's the ACM.
19:33:52 <Veinor> we should make a fizzbuzz api :O
19:34:04 <dmwit> A fizzbuzz... API?
19:34:17 <contrafunktal> but what is fizzbuzz?
19:34:30 <Veinor> fizzbuzz is the true test of a programmer!
19:34:39 <mail> fizz buzz is a game
19:36:06 <contrafunktal> oh, I get it
19:36:25 <contrafunktal> one two fizz four buzz ...
19:36:33 <mail> haha my lecturer for theory of computation is awesome
19:36:34 <Veinor> yeah
19:36:44 <mail> The last lectures of the course will introduce you to more results in computer
19:36:44 <mail> science of a similarly fundamental nature, including the famous P=NP? problem
19:36:44 <mail> (i.e. the kind of problem that wins you 1m USD from the Clay Institute if you
19:36:44 <mail> solve it).
19:36:49 <Veinor> 11 fizz 13 14 fizzbuzz
19:37:12 <Pseudonym> Unless you don't want the $1M, of course.
19:37:13 <Veinor> can P=NP be undecidable?
19:37:14 <Jafet> Do fizz buzz with dependent types
19:37:35 <Pseudonym> Veinor: There's some indication that a proof, if it exists, may itself be intractable.
19:37:37 <fax> Veinor, that's a good question I want to know too
19:37:42 <dmwit> What did that guy prove? The Poincare conjecture?
19:37:47 <Pseudonym> Yeah.
19:37:52 <mail> just 1 mill to solve this problem whereas charlie sheen gets paid just as much a WEEK to act badly in an unfunny show
19:38:06 <fax> mail, I think you're onto something
19:38:24 <Pseudonym> mail: Philosophers at the University of Berlin announced last week the discovery that life is unfair.
19:38:44 <mail> just last week?
19:38:52 <mail> germans must be a bit slow
19:39:00 <dmwit> Acting has a high average pay, but a very high variance, too. I think I'll stick to thinking -- pretty okay average, and not so much variance.
19:39:07 <Pseudonym> Well, it's been conjectured for a while.
19:39:10 <mail> http://abstrusegoose.com/206
19:39:27 <fax> haha
19:39:35 <mail> haha so true for like 50% taking the module in my uni
19:39:51 <Pseudonym> Actually, the weirdest one is topology.
19:40:06 <Veinor> mail: lol
19:40:23 <Pseudonym> You think it's going to be about Klein bottles and stuff, and you find that it's actually about open and closed sets.
19:41:10 <Veinor> and the ad I got on top of that page is for a furry webcomic.
19:41:13 <Veinor> huh.
19:41:19 <Veinor> maybe it's the 'goose' in the url? :V
19:41:25 <Pseudonym> My boss happens to teach agents at another university (he has two jobs), and comments that a lot of people rock up thinking that it's going to be about AI in games.
19:41:42 <Veinor> agents?
19:41:58 <Pseudonym> Agent-based reasoning or whatever it's called.
19:42:10 <Veinor> what's it about?
19:43:28 <Pseudonym> Oh, it's about modelling problems in terms of interacting agents.
19:43:30 <Pseudonym> Or something.
19:43:38 * Pseudonym is hazy on the details
19:45:10 <Veinor> ahh.
19:49:24 <mail> 2 + 2
19:49:37 <mail> wrong window
19:57:05 <mail> any of you got haskell syntax highlited?
19:58:30 <mail> This is the best one i've found so far - http://localhostr.com/files/492734/capture.png
20:01:28 <dmwit> mail: That file looks blank from here.
20:01:34 <mail> indeed
20:01:39 <dmwit> mail: Anyway, gvim highlights Haskell quite nicely out of the box.
20:01:55 <Jafet> The most beautiful code is no code
20:01:59 <dmwit> I suspect emacs does a quite nice job as well.
20:02:01 <mail> http://i.imgur.com/NjABO.png
20:03:14 <copumpkin> eugh
20:03:20 <copumpkin> no -1s for failure please
20:03:41 <mail> i've been lectured about this already :P
20:03:55 <mail> my prof said do it so i do it
20:04:01 <mail> that is if i want the marks
20:04:03 <copumpkin> lecture your prof
20:04:15 <copumpkin> tell the prof (s)he's a dumbass
20:04:23 <Jafet> In soviet russia
20:05:17 <gwern> -1? wtf, this isn't java
20:05:28 <monochrom> @unmtl MaybeT IO a
20:05:28 <lambdabot> IO (Maybe a)
20:05:33 <gwern> Maybe Int is exactly what the return sig should be
20:05:36 <mail> did i mention my prof is a java programmer?
20:05:40 <hstefan> I'm facing an strange error on wxHaskell. When I create a window, I get an error "Failed to load shared library 'comctl32.dll' (error 126: the specified module could not be found)". Does someone know how to fix it?
20:06:10 <gwern> mail: I am both horrified and not surprised
20:06:16 <Jafet> hstefan, find that DLL and put it somewhere your program can find it
20:06:39 <hstefan> Jafet: I did, but it changes nothing.
20:06:52 <gwern> :t find
20:06:53 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
20:06:59 <Jafet> Then I suspect you didn't
20:07:19 <gwern> mail: also, Data.List > List
20:07:28 <mail> why?
20:07:32 <hstefan> Jafet: it's on same folder of my program, so I think he can find it.
20:07:56 <codolio> List is stuck in 1998.
20:08:03 <gwern> mail: more common, you're going to be depending on base anyway, and data.list has any improvements we've made in the last decade or so
20:08:09 <mail> oh is my mirror function correct btw?
20:08:38 <mail> we? you contribute to haskell source?
20:08:47 * gwern has yeah
20:08:52 <mail> nice
20:09:17 <Jafet> hackage is borg
20:09:21 <gwern> mail: mirror is a sensible definition, although your comment doesn't make sense to me
20:09:52 <mail> so
20:10:02 <mail> take 3 "catamaran" = "cat"
20:10:22 <mail> mirror (take 3) "catamaran" = "ran"
20:10:43 <gwern> ah
20:11:42 <mail> my implementation works on that example but it has to work on any list function
20:11:42 <dmwit> mail: consider "reverse . x $ reverse y" instead, or perhaps even "reverse . x . reverse $ y"
20:12:19 <copumpkin> eww
20:13:09 <gl0w_> i'm having trouble loading the module Data.ByteString and was wondering if i could get some help
20:13:26 <gwern> dmwit: that last is nuttier than a fruitcake
20:13:28 <gl0w_> the line import qualified Data.Bytestring.Char8
20:13:33 <gl0w_> gives me the error:  Failed to load interface for `Data.ByteString.Char8':
20:13:34 <gl0w_>         Could not find module `Data.ByteString.Char8':
20:14:03 <dmwit> gl0w_: Have you got the bytestring package installed, is it unhidden, and is it in your cabal file (if any)?
20:14:25 <dmwit> gwern: Not really. It makes it abundantly clear that you can drop the "y" on both sides of the equation.
20:14:43 <gl0w_> dmwit: yeah i thought that might be the problem, i'm working off of a school server
20:14:51 <gwern> dmwit: so why not just say 'reverse . x . reverse' then?
20:14:52 <gl0w_> dmwit: so i guess they must not have it installed
20:14:52 <dcoutts_> gl0w_: did you perhaps rm -r ~/.cabal at some point?
20:14:53 <gwern> cut to the chase
20:15:04 <ddarius> dmwit: x is a function?
20:15:07 <dmwit> gwern: I would be perfectly happy with that.
20:15:09 <gl0w_> dcoutts: nope
20:15:14 <mail> bah dot notation confuses me as in working out what's going on
20:15:17 <dmwit> ddarius: Believe it or not, yes. Funny naming convention, eh?
20:15:18 <ddarius> I guess that's the implementation of the "mirror" function...
20:15:41 <dmwit> gl0w_: What does ghc-pkg list bytestring say?
20:15:41 <gwern> mail: dot notation isn't too bad. it's when it gets mixed with $s and ()s and stuff that it gets hairy
20:15:54 <dcoutts_> gl0w_: hmm, that message indicates that the module is known but the .hi file is missing (ie the package installation is borked).
20:17:05 <gl0w_> dmwit: just entering that command gives me  /usr/lib/ghc-6.4.2/package.conf:  and thats it
20:17:17 <dmwit> gl0w_: Wow, ghc 6.4!
20:17:31 <dmwit> gl0w_: Anyway, yeah, it looks like you haven't got the "bytestring" package installed.
20:17:34 <gl0w_> dmwit: yeah, they seem to be pretty out of date
20:17:46 <dmwit> gl0w_: Go ahead and grab it (say, from hackage) and have a go at building it with --user.
20:17:54 <dmwit> (Does cabal-install even work with GHC 6.4?)
20:18:16 <gl0w_> dmwit: ok, well currently on my home PC i have windows, is there a recommended way for programming in Haskell on windows?
20:18:16 <dcoutts_> dmwit: yes, if you compile it with ghc-6.6
20:18:23 <brooksbp> Can someone help me understand typing of the term: (\x.x \y.z) ?? So this breaks down to (tau1->tau1  tau2-tau3)... but the typing judgement for application is (tau1->tau2 tau1) ??? WTF ???
20:18:26 <gl0w_> dmwit: or should i use my linux machine?
20:18:39 <dcoutts_> dmwit: just as it works with hugs and nhc, but cannot be compiled by either (I think)
20:19:00 <dmwit> gl0w_: GHC is supposed to Just Work on any operating system it's available for...
20:19:20 <gl0w_> dmwit: ok cool
20:19:26 <ddarius> brooksbp: Look up unification.
20:19:53 <dmwit> brooksbp: Do you mean (\x. x) (\y. z) or (\x. (x (\y. z)))?
20:19:57 <dmwit> brooksbp: And what is z?
20:20:13 <brooksbp> dmwit: I mean (\x.x) (\y.z)
20:20:15 <gl0w_> dmwit: just making sure i'm on the right track, if i'm trying to read in a java class file as bytecode, then using ByteString is the way to go right?
20:20:19 <brooksbp> z is a fv
20:20:25 <gl0w_> dmwit: or would Data.Binary be better?
20:20:42 <brooksbp> ddarius: Can you help explain?
20:20:50 <dmwit> gl0w_: Data.ByteString and Data.Binary are not mutually exclusive.
20:20:59 <dmwit> Two great tastes that taste great together!
20:21:09 <ddarius> brooksbp: Stick unification into Google and then read.
20:21:22 <gl0w_> dmwit: ok cool thanks
20:21:58 <dmwit> brooksbp: It might help to put explicit foralls in your types.
20:22:12 <dmwit> brooksbp: (\x. x) : forall tau1, tau1 -> tau1
20:22:32 <dmwit> brooksbp: (\y. z) : exists tau3, forall tau2, tau2 -> tau3
20:23:04 <dmwit> brooksbp: Since tau1 and tau2 are bound variables, it makes it more obvious what it means to vary their names.
20:23:27 * dcoutts_ reviews yet another patch from kmc :-)
20:23:28 <dmwit> brooksbp: In particular, (\y. z) : exists tau3, forall tau2, tau2 -> tau3 = exists tau3, forall tau1, tau1 -> tau3
20:23:54 <dmwit> (Actually, that "exists" clause is probably misleading. But bound variables are in general misleading.)
20:24:02 <dmwit> arg
20:24:06 <dmwit> s/bound/free/
20:24:07 <ddarius> Indeed.
20:24:33 <mail> Generating truly random numbers is notoriously difficult. But now, using a quantum system, researchers have managed to create 42 genuinely random numbers.
20:24:37 <mail> say what now ...
20:24:41 <ddarius> This term is type checkable in the simply typed lambda calculus.
20:25:03 <Pseudonym> Assuming the Copenhagen interpretation, of course.
20:26:33 <brooksbp> dmwit: I don't see how (tau1->tau1) (tau2->tau3) is type checkable when application is (tau1->tau2) (tau1)
20:27:28 <dmwit> brooksbp: Can you point to the part of my explanation where you first get lost?
20:28:04 <ddarius> dmwit: Doesn't Data.Binary kind of -require- Data.ByteString?
20:28:33 <Saizan> brooksbp: you just add a constraint saying tau1 has to unify with tau2->tau3
20:28:45 <dmwit> brooksbp: Actually, that's not a fair question. I got lost reading my own explanation.
20:28:49 <dmwit> brooksbp: Let me try again.
20:29:08 <dmwit> brooksbp: We've got (\y. z) : forall tau2, tau2 -> tau3.
20:29:21 <dmwit> brooksbp: And we've got (\x. x) : forall tau1, tau1 -> tau1.
20:30:10 <dmwit> brooksbp: Now, we're wishing for the type of the parameter (namely, forall tau2, tau2 -> tau3) to match the type of the first argument (namely, forall tau1, tau1).
20:30:20 <brooksbp> Yes, that makes sense because of typing judgements for variables and abstraction
20:30:42 <dmwit> But foralls quantify over all types, so in particular, tau1 = forall tau2, tau2 -> tau3 is a valid assignment to tau1.
20:30:54 <dmwit> Then we get something like
20:31:19 <dmwit> (\x. x) : forall tau2, (tau2 -> tau3) -> (tau2 -> tau3), which is a *more restrictive* type, but certainly no less valid.
20:31:49 <ddarius> EUNBOUNDVAR
20:31:59 <dmwit> tau3 is unbound because z is unbound
20:32:24 <ddarius> EINVALIDSUBST
20:32:32 <brooksbp> So basically... tau1 takes on the type of tau2->tau3 ?
20:32:52 <dmwit> ddarius: nonsense
20:33:07 <dmwit> ddarius: Just because I swept the quantification under the rug doesn't make the conclusion wrong. =P
20:33:22 <dmwit> brooksbp: correct
20:33:35 <dmwit> brooksbp: The big idea here being that you can specialize types if you need to.
20:33:47 <ddarius> dmwit: tau1 = forall a. X, tau1 -> tau1 = forall a. (X -> X)  Nicht stimmt.
20:34:23 <brooksbp> dmwit: So... why does the typing for app make sense? (tau1->tau2 tau1)... that is so misleading because you can do what we just did.... tau1 can be any type
20:34:28 <ddarius> dmwit: The big idea is tau1 is unified with tau2 -> tau3.
20:34:34 <mm_freak> (as a side note: s/Nicht stimmt/Stimmt nicht/)
20:34:36 <mm_freak> =)
20:34:47 <Saizan> brooksbp: those taus in the inference rules are meta-variables
20:34:47 <copumpkin> mm_freak: nicht stimmt
20:35:04 <mm_freak> copumpkin: ?
20:35:08 <ddarius> mm_freak: Curse you foreign languages, and curse you fallible memory.
20:35:20 <copumpkin> mm_freak: what you just said was nicht stimmt :P
20:35:22 <Saizan> brooksbp: it's like pattern matching on the structure of the type
20:35:27 * ddarius thinks copumpkin is being argumentative.
20:35:32 <copumpkin> surely not
20:35:40 <mm_freak> what i said, stimmt, and what you said, stimmt nicht ;)
20:35:56 <dmwit> ddarius: unification is an algorithm for finding the right specialization
20:36:19 <dmwit> And yes, I am aware that the things I am saying are first approximations to the truth in several important places.
20:36:19 <Saizan> brooksbp: so that tau1 is a placeholder, and using it twice means that you'll need to enforce those two types are equal when you use that rule
20:36:20 <ddarius> dmwit: Of existential quantification.
20:36:21 <copumpkin> :o
20:36:40 <brooksbp> I do not understand the HM unification algorithm... wtffffffff
20:37:06 <ddarius> brooksbp: There isn't a "HM" unification algorithm.
20:37:24 <brooksbp> Ok i guess it's attributed to robinson
20:37:38 <brooksbp> the unify(C) algorithm in TAPL
20:37:41 <ddarius> mm_freak: You get a nice palindrome though.  '"Nicht stimmt" stimmt nicht.'
20:38:13 <ddarius> And then you can iterate!
20:38:26 <mm_freak> hehe yeah
20:38:58 <Jafet> viele Stimmung hier...
20:39:09 <dmwit> > let not '1' = '0'; not '0' = '1' in iterate (\xs -> xs ++ map not xs) "0"
20:39:11 <lambdabot>   ["0","01","0110","01101001","0110100110010110","011010011001011010010110011...
20:39:13 <mm_freak> s/viele/viel/ =)
20:39:38 <uorygl> I feel like implementing heapsort.
20:39:54 * Saizan wonders if it's worth to teach prolog just to let people understand inference rules
20:39:57 <uorygl> But I don't know if that's a good idea.
20:40:07 <ddarius> Saizan: It's worth teach Prolog.
20:40:08 <brooksbp> dmwit: In your explanation... you say "for all"... and ddarius: dmwit: tau1 = forall a. X, tau1 -> tau1 = forall a. (X -> X)  Nicht stimmt...  What's with the "for all"
20:40:09 <mm_freak> > iterate (permutations . concat) ["0", "1"]
20:40:10 <lambdabot>   [["0","1"],["01","10"],["0110","1010","1100","1100","1010","0110","0110","1...
20:40:21 <mm_freak> > map concat $ iterate (permutations . concat) ["0", "1"]
20:40:22 <lambdabot>   ["01","0110","0110101011001100101001100110101011000110101011000011001101010...
20:40:25 <brooksbp> what's with the logic speak?
20:41:13 <uorygl> > iterate (\x -> x ++ reverse x) "01"
20:41:14 <lambdabot>   ["01","0110","01100110","0110011001100110","0110011001100110011001100110011...
20:41:24 <ddarius> brooksbp: After you lookup unification and learn Prolog.  Look up the Curry-Howard correspondence.
20:41:26 <uorygl> That ain't the Thue-Morse sequence.
20:42:05 <copumpkin> brooksbp: follow ddarius's easy steps and you'll be a guru in no time
20:42:14 <dmwit> brooksbp: Well, in STLC there are no type variables, right?
20:42:50 <Saizan> however generalization (i.e. introduction of quantification) is done only for types of let bound variables, not for every subexpression like that, in HM
20:44:09 <brooksbp> So why did you have to explain it with all the logic speak?  Why can't you just say: (tau1->tau1) (tau2->tau3) type checks as tau1 maps to the type tau2->tau3 and the STLC app judgement (tau1->tau2 tau1) is kind of misleading because those are type variables and tau2 may equal tau1 and tau1 may equal a function type????? RAAWWWWRRRR GRRRRRRRRRRRRRRRRRAJSDLKFJASDFAJ
20:44:35 <copumpkin> are you sure you have enough question marks there?
20:44:51 <brooksbp> not enough
20:45:18 <Jafet> > fix (\x -> "Stimmt " ++ show x ++ "?")
20:45:19 <lambdabot>   "Stimmt \"Stimmt \\\"Stimmt \\\\\\\"Stimmt \\\\\\\\\\\\\\\"Stimmt \\\\\\\\\...
20:45:20 <dmwit> But tau1, tau2, and tau3 aren't type variables.
20:45:31 <dmwit> So I can't explain it that way.
20:45:48 <brooksbp> dmwit: in the app judgement rule they are... not in the actual term I'm trying to typecheck
20:46:02 <Saizan> brooksbp: they are meta-variables
20:46:03 <dmwit> brooksbp: No, they're metavariables...
20:46:14 <dmwit> brooksbp: Look, what's the type of (\x. x) in STLC?
20:46:27 <dmwit> Stop and think carefully a second about your answer.
20:46:32 <brooksbp> dmwit: t-t
20:46:35 <dmwit> Because it's a trick question.
20:46:39 <brooksbp> dmwit: t1->t1
20:46:44 <dmwit> brooksbp: That's not a type. No type variables, remember?
20:46:52 <monochrom> I heard that prolog doesn't do all the safety checks needed for unification. Err, I read it in Lawrence Paulson's ML textbook!
20:47:14 <brooksbp> I don't know.
20:47:32 <dmwit> brooksbp: Right. That's because it doesn't have only one type.
20:47:33 <dolio> There are infinitely many possible types for it.
20:47:34 <dmwit> It has many types.
20:47:41 <dmwit> Bool -> Bool is one answer
20:47:50 <dmwit> So is Int -> Int, or (Bool -> Int) -> (Bool -> Int).
20:47:51 <brooksbp> ok. you got me... but how about the
20:47:58 <Saizan> monochrom: well, you can turn the occurs check on :)
20:47:58 <brooksbp> meta type t1->t1
20:48:15 <dmwit> In fact, for all types tau, tau -> tau is a legitimate type for (\x. x).
20:48:20 <dmwit> Now do you see where the forall came from?
20:48:46 <dmwit> brooksbp: I don't know what a metatype is.
20:48:59 <brooksbp> Wait... how is (Bool->Int) valid for \x.x
20:49:05 <dmwit> It's not.
20:49:14 <dmwit> But (Bool -> Int) -> (Bool -> Int) is.
20:49:15 <brooksbp> oh wait. I see.
20:49:18 <monochrom> . o O ( Why the invented-by-you speak? RRRWWWGGGRRR)
20:49:22 <brooksbp> I hate myself
20:49:50 <dmwit> monochrom: Was that aimed at me? Sorry if I invented terms for things that already have a good name... =/
20:50:00 <monochrom> Aimed at "metatype"
20:50:45 <brooksbp> So what other stuff should I be aware of regarding type checking... apparently I missed the bus when it comes to this unification stuff which made me not fully understand the STLC application rule
20:51:17 <dmwit> There's people in here that have dedicated decades to type checking. You want we should open the firehose? =)
20:51:32 <dmwit> Maybe it's safer to ask questions when you come on something you don't understand instead.
20:54:24 <brooksbp> Ok.  Where can I learn how unification works for effect types?
20:54:34 <dmwit> whoa
20:54:43 <dmwit> You're doing effect types...?
20:54:54 <monochrom> perhaps we do want the firehose...
20:55:11 <dolio> Red snapper. Very nice.
20:55:23 <byorgey> Unification is unification.  I don't think it works differently for effect types than for anything else.
20:57:06 <brooksbp> Yeah I'm looking at this effect system and it seems to leave out information on how effects are unified in the app rule... but I see how it works from the examples they give
20:57:48 <dmwit> I would argue that unification is easier to teach when there's only one type constructor (e.g. (->)), and then the generalization isn't so surprising once you've got it.
20:58:15 <dmwit> But anyway, yeah, there's some fine papers out there on unification if that's your thing.
20:58:24 <dmwit> And if it's not, ask again when I'm not about to go to bed. =)
20:58:48 <dmwit> (There may be other people up for walking you through it, too.)
20:58:50 <brooksbp> dmwit: thanks for your help
21:00:50 <ddarius> monochrom: It's fine when viewed as rational tree unification.
21:02:33 <brooksbp> Can I have the firehose?
21:05:20 * copumpkin pulls it out and attaches it to brooksbp's mouth
21:08:12 <monochrom> . o O ( does a firehose provide fire? )
21:08:35 <ddarius> monochrom: Yes.  And a gardenhose provides garden.
21:08:48 <monochrom> pantyhose provides panty
21:09:19 <monochrom> san jose provides san
21:10:07 <dmwit> You heard what the Mexican firemen called his two sons?
21:10:20 <dmwit> Jose and Hose B
21:10:29 <monochrom> hehe
21:11:53 <lpsmith> hpaste is down
21:12:25 <pickles> say something to cheer it up?
21:12:36 <mail> jokes?
21:12:39 <lpsmith> I actually used a firehose once
21:12:40 <mail> in #haskell ?!
21:12:49 * mail checks temp of hell
21:12:54 <lpsmith> It's pretty tiring, really
21:13:07 <lpsmith> And I wasn't using a full-sized firehose either
21:13:58 <pickles> mail: maybe lpsmith's firehose put out hells fire?
21:14:10 <pickles> *hell's
21:14:33 <copumpkin> not sure it's appropriate to be talking about lpsmith's firehose in here
21:14:44 <lpsmith> hahaha
21:15:02 <pickles> heh, that's nothing compared to the nude beach in here earlier
21:15:41 <monochrom> In a non-empty nude beach, there is a person such that if he/she has a firehose, then everyone in the beach has a firehose.
21:15:48 <dcoutts_> kmc: you about?
21:16:12 <pickles> do they spray everyone who does not spray themselves?
21:16:38 <tensorpudding> is a p-adic expansion allowed to have infinitely many terms of negative p powers?
21:18:21 <monochrom> @djinn a -> Not (Not a)
21:18:22 <lambdabot> f a b = b a
21:18:35 <monochrom> @djinn (a -> Not a) -> Not a
21:18:35 <lambdabot> f a b = a b b
21:19:09 <monochrom> @djinn (a -> Not a) -> a -> c
21:19:10 <lambdabot> f a b = void (a b b)
21:20:02 <copumpkin> @djinn Not (Not (Not a)) -> Not a
21:20:02 <lambdabot> f a b = void (a (\ c -> c b))
21:24:26 <pickles> nite all
21:24:37 <ddarius> lpsmith: To put out a fire?
21:25:29 <lpsmith> ddarius, nah,  I was volunteering at a fire department and they got out a hose to wash off their parking lot
21:29:03 <iaefai> I just did a ghc-pkg check and it came up with these errors: http://www.pastebin.ca/1861292  Is this a problem, and if so, what would be a reasonable resolution?
21:29:59 <dmwit> Step one: admit you are a warrior of the Dark.
21:30:19 <dmwit> But no, the easiest thing is to just cabal --reinstall them.
21:30:33 <dmwit> err
21:30:55 <dmwit> that is, --reinstall the broken packages, not the "non-existent" packages (which are probably there, but with a different hash)
21:31:42 <iaefai> ok
21:31:56 <iaefai> Now ghc is saying something about old base 3 and should use base 4
21:32:20 <dmwit> just warnings... right?
21:33:06 <iaefai> yes
21:33:27 <iaefai> But I would like to know more, because I am starting from somebody else's opengl code to customize it completely
21:33:49 <Veinor> tensorpudding: I don't believe so
21:34:57 <iaefai> dmwit: I should admit to being a worshipper of Satan, least of all.
21:35:26 <Saizan> iaefai: if you get that warnings when building your own package you should add an upper bound to the base dependency in your .cabal
21:35:49 <iaefai> so base>4
21:36:10 <Veinor> that's a lower bound :P
21:37:11 <iaefai> Can you restate what you mean in different terms?
21:37:14 <dcoutts_> does someone feel like adding a check to cabal configure to complain about open upper bounds on base?
21:37:26 <dcoutts_> so cabal can give people better advice?
21:37:33 <dcoutts_> volunteers? :-)
21:37:44 <Veinor> I kind of want to work on cabal
21:37:51 <dcoutts_> Veinor: great!
21:38:07 <ezyang> "we've got a lot of work for you good sir
21:38:36 <Veinor> on a scale of 'the linux kernel' to 'hello world', how hard is it to get involved in?
21:38:50 <iaefai> If I run ghc-pkg unregister does it simply remove it from the database? (I would like to remove pandoc)
21:38:54 <dcoutts_> Cabal is not at all like the Augean stables
21:39:25 <dcoutts_> Veinor: we've got a source guide, a list of "easy" tickets, a well maintained bug tracker
21:39:36 <Veinor> oh, hm, this is going to get rapidly annoying
21:39:38 <Saizan> iaefai: yes, it leaves the actual files where they are
21:39:42 <Veinor> any time someone says we've the ve is turned blue
21:40:08 <dcoutts_> heh, dodgy highlighting?
21:40:17 <Veinor> yeah :P
21:40:20 <Veinor> cause of ve
21:41:12 <dcoutts_> Saizan: so, help me here, what do we want cabal to do, to encourage people towards base 4
21:41:26 <Veinor> ok, fixed
21:41:28 <Veinor> anyway
21:41:37 <dcoutts_> cabal selects the latest base when the version is bounded above
21:41:45 <gl0w_> so i'm attemting to use readFile to read in a file but on compilation get the errors: undefined reference to '__stginit_binaryzm0zi5zi0zi2_DataziBinary_'
21:41:52 <gl0w_> coudl anyone enlighten me as to what i did wrong here?
21:42:09 <dcoutts_> dons suggested switching to using that behaviour even without the upper bound, but it'd break old packages
21:42:40 <dcoutts_> so the sensible thing would be for cabal to persuade authors of new packages to add an upper bound
21:42:45 <Veinor> gl0w_: are yo ucompiling with ghc --make
21:42:47 <Veinor> ?
21:42:54 <dcoutts_> so that they end up using base4
21:43:29 <gl0w_> Veinor: nope  just did ghc program.hs
21:44:02 <Veinor> you need ghc --make, someone who actually knows ghc can tell you why :D
21:44:05 <greedo> he's running windows
21:44:09 <Saizan> dcoutts_: Cabal doesn't have easy access to the date when a package got uploaded when configuring, right?
21:44:38 <dcoutts_> Saizan: at the moment not at all, that info will be available with the new server
21:44:59 <gl0w_> Veinor: Thanks a ton, that fixed it ^_^
21:44:59 <dcoutts_> Saizan: unless perhaps it's the file date in the index tarball
21:45:15 <dcoutts_> Saizan: what would we use it for exactly?
21:45:42 <Saizan> dcoutts_: my idea would have been applying the <4 preference only to packages uploaded before base 4 existed
21:45:45 <wavewave_> can we pass some environment variable to cabal? i.e. can I use $HOME in package.cabal ?
21:45:56 <dcoutts_> Saizan: ah I see
21:46:01 <dcoutts_> wavewave_: no
21:46:15 <dcoutts_> wavewave_: packages are supposed to be portable
21:46:29 <wavewave_> dcoutts_: I see.
21:46:55 <iaefai> In the GLUT documentation there is something for windowsize: windowSize :: StateVar Size  but I don't understand how this allows me to change window size.
21:47:16 <dcoutts_> wavewave_: but you can set installation directories etc at configure time, or dirs for C libs, headers etc
21:47:41 <wavewave_> dcoutts_: but then if some package depends on some preinstalled package (which is not cabal package), how can I give the information on this to cabal?
21:48:00 <wavewave_> dcoutts_: what is the best way?
21:48:28 <dcoutts_> wavewave_: eg a C lib that is not installed in the default system locations, you can use the --extra-lib-dirs and --extra-include-dirs configure flags
21:48:43 <dcoutts_> see cabal configure --help
21:49:13 <wavewave_> dcoutts_: I see.. so the user should give the information explicitly.
21:49:29 <dcoutts_> wavewave_: the principle is that the package author designs a portable package and the person building the package gets to specify system-specific things
21:50:02 <dcoutts_> wavewave_: for personal or in-house commercial projects, the author and builder roles are often the same person, which can be a little confusing
21:50:15 <wavewave_> dcoutts_: I got it.
21:50:25 <dcoutts_> we keep the roles distinct to allow for portable distro packages
21:50:44 <Saizan> dcoutts_: btw, has dons stopped putting base < 10 in his .cabal files ?:)
21:51:01 <dcoutts_> Saizan: if he hasn't there's going to be trouble! :-)
21:51:07 <wavewave_> dcoutts_: maybe we need some additional tool corresponding to autoconf?
21:51:16 <dcoutts_> Saizan: I noticed one of his colleagues doing that too
21:51:39 <dmwit> cabal-install is the corresponding tool
21:51:50 <wavewave_> dcoutts_: If I really want to make some package which does not need any user intervention?
21:51:53 <Jafet> (Does he plan to overhaul base 10?)
21:52:16 <wavewave_> dmwit: Hmm, is cabal-install different?
21:52:35 <Saizan> dcoutts_: do you think making an upper bound mandatory for accepting a package on hackage would be too strong?
21:52:38 <wavewave_> dmwit: ahh. if you mean dependency among haskell packages, i understand it.
21:52:50 <dcoutts_> Saizan: we already have that for base
21:53:04 <dcoutts_> Saizan: we cannot do it for all packages because not all packages follow a versioning policy.
21:53:39 <dcoutts_> Saizan: however I would like to allow packages to opt-in to the PVP, and then it might well be reasonable to enforce upper bounds on packages that use the PVP-following ones
21:53:56 <dcoutts_> but correspondingly we need to be able to check PVP compliance
21:54:19 <dcoutts_> we could start with making it a warning for packages following the PVP
21:54:32 <dcoutts_> erm for packages depending on packages that follow the PVP
21:55:41 <Saizan> ah, i thought we were only discussing base-4, since we've the preference only for base
21:56:37 <Saizan> (but i guess that check is what motivated the base < 10)
21:56:59 <iaefai> What does ! mean before a type? eg Size !GLsizei !GLsizei	
21:57:00 <Jafet> re: base, why not do the fix and bump cabal version? That shouldn't harm old packages.
21:57:16 <Jafet> iaefai, a strict constructor.
21:57:27 <iaefai> as opposed to lazy?
21:57:33 <Jafet> Yes.
21:57:37 <dcoutts_> Saizan: but since base does follow the PVP, then it's ok to tell people that they should pick an upper bound, because there is a sensible upper bound for them to pick, 10 obviously being not sensible
21:58:00 <dcoutts_> the sensible upper bound being one more than the current version
21:58:09 <Veinor> what is the PVP exactly?
21:58:26 <dcoutts_> @google Haskell Package Version Policy
21:58:27 <lambdabot> http://www.haskell.org/haskellwiki/Package_versioning_policy
21:58:27 <lambdabot> Title: Package versioning policy - HaskellWiki
21:59:02 <dcoutts_> Jafet: I'm not sure what you mean exactly
21:59:06 <wavewave_> wow, lambdabot can also do google? ;-)
21:59:27 <wavewave_> smart guy~
21:59:28 <Saizan> so i guess the problem is to persuade maintainers to release a new version that takes base-4 in consideration
21:59:30 <wavewave_> or girl
21:59:56 <dcoutts_> Saizan: hmm?
21:59:59 <Jafet> @vixen are you a guy
22:00:00 <lambdabot> no, i'm a woman
22:00:32 <wavewave_> okay, girl...
22:00:37 <dcoutts_> Saizan: I'm mainly talking about new packages, new versions.
22:01:32 <dcoutts_> Saizan: to make sure that people are using base 4 from the start, rather than only noticing before they upload that an upper bound is needed, and not re-testing with base 4
22:02:13 <Saizan> dcoutts_: aaah, ok, i thought the upper bound requirement worked for those
22:02:44 <dcoutts_> Saizan: and I was thinking we add a configure-time warning, so developers get told while they're still hacking, rather than when doing distribution-time checks
22:04:44 <Saizan> dcoutts_: makes sense
22:05:20 <Saizan> dcoutts_: do we also checks for a lower bound?
22:05:45 <dcoutts_> Saizan: I'm not sure, I'd have to go check the code, it should be easy to add if not
22:09:00 <Saizan> dcoutts_: since it's not so obvious which base one ends up using, i think there's quite a risk of saying base >= 3 && < 5 thinking you've tested with both but you didn't
22:09:17 <dcoutts_> that's quite true
22:10:35 <Saizan> last time i tried --constraint didn't really work for base, though maybe --preference does
22:10:48 <dcoutts_> yeah, there's a bug there
22:14:25 <gio123> Cale: oj
22:20:39 <Saizan> dcoutts_: maybe cabal-install or some tool on top of it should be made to gather data about these sort of tests
22:20:49 <leoncamel> If I do "cabal install yesod", then follow a "cabal install mighttpd". I will get a error of "ghc-pkg check" command : dependency "network-2.2.1.7-c873d333afa36ee1d496acf30a14dc9d" doesn't exist
22:20:57 <leoncamel> How can I solve this problem ?
22:21:16 <dcoutts_> Saizan: you mean build reporting?
22:21:17 <Saizan> dcoutts_: i.e. we've the build reports feature, but not a summary
22:21:54 <dcoutts_> Saizan: right, the report info is most useful once we apply some statistical summary techniques
22:22:20 <dcoutts_> Saizan: I expect you know more stats than me, perhaps you can help :-)
22:22:55 <Saizan> leoncamel: can you paste your ghc-pkg list on some pastebin?
22:23:37 <iaefai> On line 16 of the GLFW example (from wiki, pasted here: http://www.pastebin.ca/1861339 ) I get an error anim.lhs:16:0: parse error on input `main'  and I can't for the life of me figure out what the problem is. Any ideas?
22:24:18 <Saizan> dcoutts_: on a (maybe?) simpler scale i was also thinking about something local the maintainer could run on his own build reports to see what he actually tested so far
22:24:40 <dcoutts_> Saizan: right, we record them all locally, but don't have any analysis tools yet
22:25:19 <leoncamel> Saizan: http://pastebin.com/01EKSzMM
22:26:17 <leoncamel> Saizan: It seems that during second command, cabal install mighttpd. It reinstall network package.
22:26:57 <Saizan> leoncamel: that might be actually be the case
22:27:45 <Saizan> leoncamel: what does "cabal install yesod mighttpd --dry-run -v" say?
22:28:33 <leoncamel> Saizan: Shall I clean the ".ghc/x86_64-linux-6.12.1.20100330/" before that ?
22:28:51 <Saizan> leoncamel: no
22:29:40 <leoncamel> Saizan: http://pastebin.com/jLqrVAXv
22:31:29 <Saizan> leoncamel: ah, so the problem is parsec, which being a dependency of network explains why network got reinstalled
22:32:04 <leoncamel> Saizan: Sorry, I will go out for a hour. Can I talk about it later ?
22:32:06 <Saizan> i guess yesod is using HStringTemplate
22:32:31 <dcoutts_> Saizan: eg gentoo have a utility called genlop http://www.karkomaonline.com/index.php/2004/02/genlop-gentoo-log-parser/
22:32:47 <Saizan> leoncamel: maybe, my suggestion would be to try to install HStringTemplate with parsec-3 by editing the .cabal file
22:35:02 <Veinor> OH GOD
22:35:04 <Saizan> dcoutts_: ah, though once you've packages it's quite easier, in a developement envirnment it's harder to tell which logs are relevant to the current code, maybe we just have to leave that part to the user
22:35:14 <pastorn> bye bye :)
22:35:22 <pastorn> that's a nice split :)
22:35:33 <Saizan> dcoutts_: i.e. make it edit the log so that it contains only the relevant info
22:35:52 <Saizan> s/it/him/
22:36:08 <dcoutts_> Saizan: I'm not sure I follow
22:36:43 <dcoutts_> Saizan: I think currently we only make a build log entry for tarball packages, not for every local cabal install
22:37:29 <Saizan> dcoutts_: ah, ok, i was talking about doing them for local ones too
22:37:55 <dcoutts_> Saizan: it's less clear what info we want to keep in that situation, I'd not thought about it
22:38:28 <Saizan> dcoutts_: another option would be to encourage maintainers to have their own hackage-server running, i guess :)
22:38:49 <dcoutts_> Saizan: well yes, we do want to make that possible
22:39:09 <dcoutts_> though I anticipate it being more useful to teams/projects than to individuals
22:39:26 <dcoutts_> eg as a place to publish and test nighly builds or betas
22:40:18 <Saizan> sure
22:43:11 <Saizan> the main problem that came out when we thought about doing that for happstack was how to keep the mapping between an uploaded tarball and a state of the darcs repo, btw
22:43:27 <Saizan> but this is maybe too much of a tangent here :)
22:46:35 <Axman6> so, after using python's C API (well, NumPy C API i guess, but it seems this is how you usually call C from Python), i fully appreciate how good our FFI is
22:47:43 <dcoutts_> Saizan: mm, for darcs versions I guess you want a tag, since that's the only way to actually identify any repo state
22:48:23 <dcoutts_> which is a little annoying as you don't really want to tag all the time with darcs
22:48:34 <dcoutts_> Saizan: perhaps simple date snapshots
22:49:18 <iaefai> There is some C code I would like to call once in my application. Is there any way of easily doing it? It is just two lines (in C).
22:51:46 <dcoutts_> iaefai: yes, see the Cabal user guide
22:52:16 <iaefai> I seem to recall not that long ago trying to do something like this and not for the life of me being able to figure it out
22:53:11 <kingping> Hello folks.
22:54:14 <dcoutts_> iaefai: it's pretty straightforward, see the c-sources field in the cabal user guide
22:54:25 <kingping> I need one constant variable, which is initialized main to be accessible from my callback function. What would be preferrable? IORef ?
22:54:50 <kingping> s/initialized/initialized in/
22:55:53 <azazell> offtopic: does anyone uses git? could you please advice git irc channel, there's too much of them on freenode to list em...
22:57:02 <Saizan> kingping: well, you could also make your callback that that value as an extra argument and then partially apply before you pass it to the callback registration function
22:57:10 <iaefai> dcoutts_: I see the field here now. What is the best way to call a function I then make in C? (say it doesn't take any parameters)
22:57:29 <dcoutts_> iaefai: see the Haskell FFI
22:57:55 <iaefai> might actually be able to do it :-)
22:57:59 <iaefai> Thank you for pointing me
22:58:22 <dcoutts_> np
22:58:55 <kingping> Saizan: Indeed: angle <- newIORef 0.0  ;    displayCallback $= (display angle)                <- this one I suppose will work. I just expected angle to be defined somewhere outside of the function. Damn, I hate C.. :\
23:01:03 <leoncamel> Saizan: around ?
23:01:12 <Saizan> leoncamel: i am
23:01:41 <leoncamel> Saizan: parsec-3.0 is compatiable with parsec-2.x ?
23:02:15 <Saizan> leoncamel: it should
23:03:44 <leoncamel> Saizan: but, how about the network-2.2.1.7 dependency problem.
23:05:27 <Saizan> leoncamel: my idea was that you get HStringTemplate installed with parsec-3, then yesod won't have a reason to require parsec-2, so both yesod and mighttpd will be able to use a network built against parsec-3, making you happy :)
23:07:49 <leoncamel> Saizan: OK.
23:11:16 <leoncamel> Saizan: And, why the second command, "cabal install mighttpd", does not check the dependancy like a "cabal install yesod mighttpd" ?
23:11:32 <leoncamel> Saizan: it is a bug ?
23:20:18 <Saizan> leoncamel: well, cabal install doesn't try to make the new installed package work with all the ones you've already installed, though it's quite unfortunate that it overwrites network like that
23:20:31 <dcoutts_> sigh
23:20:42 <iaefai> I get a parse error on a line that just says import Foreign.C   this is the second time today I have gotten an unexplained parse error.
23:21:07 <Saizan> leoncamel: the idea is to move towards a more persistant database of packages, where you never remove them, but you can have different installations of the same package and same version coexist
23:21:08 <Axman6> what's above that line?
23:21:22 <iaefai> import Control.Monad
23:21:50 <iaefai> The surrounding code from the start of the file: http://www.pastebin.ca/1861388
23:22:03 <iaefai> I am copying code from the wiki
23:22:12 <Saizan> leoncamel: well, you'd still be able to remove them if the user wants to explicitly, of course :)
23:23:38 <iaefai> I had to add {-# LANGUAGE ForeignFunctionInterface #-}
23:23:47 <iaefai> I don't understand why it comes up with parse error though
23:24:23 <Saizan> it can't parse "foreign import ccall unsafe "unbundled" c_unbundled :: IO ()" otherwise
23:25:17 <iaefai> ah, but the parse error was on the import
23:25:31 <iaefai> The first import of foreign.C
23:26:06 <iaefai> It is a terse, but still cryptic error, only out done by the iostream library of C++
23:28:17 <iaefai> But at least it works, and now I don't need a bundled app
