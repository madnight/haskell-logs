00:00:17 <dobblego> > reads "78abcdef" :: [(Int, String)]
00:00:18 <lambdabot>   [(78,"abcdef")]
00:00:21 <dobblego> > reads "abcdef" :: [(Int, String)]
00:00:22 <lambdabot>   []
00:00:36 <Veinor> I just taught a bunch of prefrosh haskell for 30 minutes at 1:30 in the morning
00:00:47 <yuriks_> hmm, and why does it return a list instead of Maybe or something?
00:00:48 <ski> > (reads :: ReadS Int) "78abcdef"
00:00:49 <lambdabot>   [(78,"abcdef")]
00:00:54 <kmc_> Veinor, awesome
00:00:59 <ski> @src ReadS
00:00:59 <lambdabot> Source not found. There are some things that I just don't know.
00:01:06 <ski> @type reads
00:01:07 <lambdabot> forall a. (Read a) => String -> [(a, String)]
00:01:15 <ski>   reads :: Read a => ReadS a
00:01:28 <ski>   type ReadS a = String -> [(a,String)]
00:01:39 <Veinor> well, by a bunch I mean 2
00:01:48 <Veinor> and only one was actually showing signs of understanding >_>
00:01:50 <ddarius> What's a "prefrosh"?
00:01:51 <Veinor> but it was still awesome!
00:01:55 <ski> yuriks_ : and a list is used instead of a `Maybe' to support ambiguous grammars/parsers
00:02:04 <yuriks_> ... huh?
00:02:13 <Veinor> senior in high school visiting a college
00:02:52 <yuriks_> oh, I think I get it
00:02:54 <yuriks_> anyway
00:02:55 <roconnor> Veinor: what was the other showing signs of?
00:03:06 <Veinor> ... not understanding
00:03:09 <yuriks_> just in case I need it in the future, how do I catch the exception thrown by read?
00:03:27 <Veinor> to be fair, it's 1:30 in the morning, and he strikes me as the quiet type
00:03:31 <ski> yuriks_ : however, i'm not quite sure why ambiguous grammars/parsers are supported here .. except for possibly (a) generality, (b) sometimes it is easier to express a parser/grammer if you allow it to locally be (possibly) ambiguous, even if the top parser is intended to not be ambigous
00:03:57 <ski> yuriks_ : you don't, except by doing it from `IO', using `catch'
00:04:06 * ski often defines something like
00:04:32 <ddarius> You don't at all in Haskell 98.
00:04:33 <roconnor> ski: I remember looking through the Haskell 98 standard looking for non trivial uses of the list but I found none.
00:04:42 <ski> @let readM :: MonadPlus m => ReadS a -> String -> m a; readM reads s = do (a,"") <- foldr (mplus . return) mzero (reads s); return a
00:04:43 <lambdabot>  Defined.
00:05:22 <dcoutts_> ski: ReadS style parsing comes from the pre-monad syntax era
00:06:02 <ski> yuriks_ : using that, you only need to use `case readM reads{-or any other value of type `ReadS a'-} s of Nothing -> ...; Just a -> ..a..'
00:06:07 * yuriks_ doesn't even know monads =P
00:06:19 <ski> dcoutts_ : i know, just as `ShowS' does
00:06:37 <yuriks_> just want to parse a number checking for errors =P
00:06:38 <ski> yuriks_ : you can ignore the `m' bit there, and pretend it is
00:06:48 <ski>   readM :: ReadS a -> String -> Maybe a
00:06:58 <yuriks_> ski: it's what I'm writing right now =P
00:07:10 <ski> > readM reads "78" :: Maybe Int
00:07:12 <lambdabot>   Just 78
00:07:16 <ddarius> :t listToMaybe . reads
00:07:17 <lambdabot> forall a. (Read a) => String -> Maybe (a, String)
00:08:22 <ski> yuriks_ : if you need the extra generality of just parsing something from a *prefix* of a string, and getting a hold of the suffix, you can use what ddarius suggests
00:08:45 <ski> @type foldr (mplus . return) mzero . reads  -- or this, for arbitrary `MonadPlus' result
00:08:46 <lambdabot> forall (m :: * -> *) a. (MonadPlus m, Read a) => String -> m (a, String)
00:08:48 <yuriks_> readM :: Maybe a
00:08:49 <yuriks_> readM s = if null l then Nothing else Just fst (head l) where l = reads s
00:08:53 <yuriks_> this is what I have
00:08:55 <scotty> Is this page rather outdated?: http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
00:09:16 <ski> yuriks_ : for that to type check, you need to add `String -> ' before the `Maybe a'
00:09:27 <yuriks_> oh, I forgot
00:09:45 <ski> also, instead of using `null' and `head' and `fst'; use pattern-matching !
00:09:47 <scotty> I try to define the following and it says 'Parser' is not in scope: simple :: Parser Char
00:09:50 <scotty> simple  = letter
00:10:03 <ski> either define a local function in the `where' which pattern-matches for you, or just use a `case'
00:10:26 <yuriks_> hmm
00:10:56 <ski> btw, i keep forgetting whether there is actually name for `foldr (mplus . return) mzero' in some library .. anyone happen to know ?
00:10:59 <ski> @type foldr (mplus . return) mzero
00:11:00 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [a] -> m a
00:11:15 <ski> (it might be called `listToMonadPlus', i suppose)
00:14:02 <yuriks_> http://pastebin.com/r33UU43v
00:14:03 <ski> @type msum
00:14:04 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
00:14:06 <ski> @type mconcat
00:14:07 <lambdabot> forall a. (Monoid a) => [a] -> a
00:14:16 <ski> (it isn't one of those)
00:15:28 <ski> yuriks_ : that looks ok
00:15:53 <ski> just to be on the safe side, you should catch the case of a list with more than one result in it too, i think
00:16:24 <ski> (presumably you want to return `Nothing' in that case, since there isn't a definite single correct answer)
00:16:29 <scotty> Can anyone point me to a tutorial for getting started with Parsec version 3?
00:16:43 <yuriks_> ski: can't I just return the first result?
00:17:08 <yuriks_> ((x, _):_) -> Just x
00:17:11 <yuriks_> that looks odd
00:17:15 <ski> (.. or i suppose there might be duplicate solutions, all duplicates of the same solution .. but to check that, you'd need to require `Eq a' too .. which seems needlessly nongeneral)
00:18:09 <ski> yuriks_ : yes, you *can* generate the first result .. and that might be reasonable in some circumstances (like, "give me any parse, assuming there is at least one parse")
00:18:21 <dcoutts_> scotty: the tutorial on parsec 2 will work fine
00:18:22 <yuriks_> that's good enough for me
00:19:09 <ski> but if you're returning the first result because that is the first, rather than that that is the one that is most easily returned, if one is to return an aribtrary one .. that seems more ad-hoc to me
00:19:37 <dcoutts_> yuriks_: typically I would use ((x, ""): []) -> Just x  to enforce that there is exactly one parse, and that there is no trailing characters
00:19:54 <yuriks_> dcoutts_: that sounds like a good idea
00:19:59 <dcoutts_> or you might check the trailing characters are all spaces, or whatever is appropriate in the circumstances
00:20:34 <ski> (since usualy one doesn't care much about order of generated parses in ambiguous grammars, except to use it to always terminate, or at least generate every possibly solution)
00:20:55 <yuriks_>               ((x, ""):[]) -> Just x
00:20:56 <yuriks_>               _            -> Nothing
00:21:34 <ski> yuriks_ : `((x, ""):[])' (where you don't even need the outer brackets) is the same as `[(x, "")]'
00:21:49 <yuriks_> oh, yeah, lol
00:22:02 <scotty> dcoutts_: I'm using this page: http://legacy.cs.uu.nl/daan/download/parsec/parsec.html.  Is this the tutorial you're referring to?
00:22:09 <ski> dcoutts_ : yuriks_ (for some reason) wanted to return the first solution, if there's several solution .. that only matches in the one-solution case
00:22:38 <yuriks_> ski: my use case is reading a number form input and complaining if it isn't a nunber, so that was good enough ;P
00:22:56 <ski> yuriks_ : but if you want to return the first solution *and* check that the rest of the string is `""', then you should really get the first solution where the rest of the string is `""'
00:22:57 <yuriks_> from input*
00:23:28 <ski> yuriks_ : i.e. `filter' away the solutions that doesn't have `""' as "rest of string", instead of matching on `""'
00:24:11 <yuriks_> I'll keep it in mind, at this point that sounds nedlessly complicated though
00:24:34 <ski> it all depends on what your needs for this are
00:24:41 <dcoutts_> yuriks_: sigh, ski is right, sometimes primitive parsers are ambigious
00:25:19 * ski however likes to write self-contained functions that "does the right thing" even in situations that he doesn't need to use them in
00:25:50 <Cale> It took 12.3 kiloohm farads of patience, but I finally managed to fix the microphone jack on my headset (the internal wiring connecting to it had broken) :)
00:25:54 <ski> (that reduces possibility for errors, if it do reuse it in such a situation later)
00:26:19 <ski> dcoutts_ : example ?
00:26:42 <dcoutts_> ski: I'm trying to think of one, I'm sure I have had that problem before
00:26:54 <dcoutts_> ski: though perhaps that was with ReadP rather than ReadS
00:27:05 <dcoutts_> which we use in Cabal (annoyingly)
00:27:10 <ski> that should probably not matter, i think
00:27:27 <BMeph> Cale: Use a mempacitor! :)
00:27:38 <Cale> hehe
00:27:58 * ski tries to recall whether `ReadP' was the `newtype' wrapper around `ReadS', or the parallel parser ..
00:28:36 * hackagebot Lastik 0.6.3 - A library for compiling programs in a variety of languages  http://hackage.haskell.org/package/Lastik-0.6.3 (TonyMorris)
00:28:40 <ski> Cale : which two of charge, current, flux, voltage are related by a mempacitor ?
00:28:57 <Cale> ski: well, none of those
00:29:28 <ski> @type Text.ParserCombinators.ReadP.readP_to_S  -- ok, looks like the wrapper one
00:29:29 <lambdabot> forall a. Text.ParserCombinators.ReadP.ReadP a -> String -> [(a, String)]
00:29:48 <yuriks_> http://pastebin.com/gSQMnbEV
00:29:52 * ski wonders why `hoogle' used `ReadS' there ..
00:29:54 <Cale> memcapacitors relate the integral of charge to flux
00:29:57 <yuriks_> that stringent enough for you? =P
00:30:06 <ski> Cale : .. oh, interesting
00:30:19 <ski> how about meminductors ?
00:30:37 <Cale> charge to the integral of flux
00:31:01 <Cale> http://cale.yi.org/share/passive.png
00:31:49 <ski> yuriks_ : that looks fine (though, if you prefer, `\(_,r) -> null r' could be replaced by `null . snd') ..
00:31:55 <dcoutts_> ski: ReadP is the parallel parser
00:32:16 <yuriks_> ski: I think the lambda-matched version is clearer, tbh
00:32:16 <ski> yuriks_ : .. except that now you're matching against a singleton list, which makes the `filter' business here needless
00:32:23 <Cale> (I have some handwavy argument that the long diagonals are physically impossible as passive elements, and I have no idea what the thing at the bottom would be (mem-memristor?)
00:32:28 <dcoutts_> ski: it's only virtue is that it is faster than ReadS and that it is in the base package.
00:32:39 <yuriks_> ski: I've always been matching against a singleton list
00:33:00 <yuriks_> ski: and that enforces that it only returns the value when there is a single parse that consumes the entire input
00:33:00 <ski> yuriks_ : the `filter' is needed if you don't want to fail (return `Nothing') in case of several solutions, but still only want to return a solution that have empty rest-of-string
00:33:21 <ski> dcoutts_ : ok, ty (apparently i managed to misinterpret things)
00:33:59 <ski> yuriks_ : if the lambda version is clearer to use, then use that :)
00:34:27 <ski> <yuriks_> ((x, _):_) -> Just x
00:34:48 <yuriks_> ski: for certain definition of 'always' ;P
00:34:49 <ski> yuriks_ : i interpreted that as you considering matching against a non-empty list instead of against a singleton list
00:35:19 <yuriks_> ski: yeah, I changed it half way through
00:35:19 <ski> also
00:35:21 <ski> <yuriks_> ski: can't I just return the first result?
00:35:54 <ski> if you want to match against a singleton list always (i.e. not "return the first result"), then the `filter' business is not needed at all
00:36:01 <yuriks_> yeah, I know
00:36:32 <ski> (only if you want to return the first solution with empty rest-of-string is it needed, because the first such solution might not be the first element in the list)
00:37:40 <yuriks_> I want to return the ONLY solution with empty rest of string, and fail if that isn't the case
00:37:47 <ski> Cale : "bottom" being what ? relating `current' and `voltage' ?
00:38:17 <ski> right, then do as you did in the last past, except skip the `filter' business
00:38:19 <Cale> ski: That's a resistor
00:38:44 <Cale> ski: But perhaps there are other relationships possible in that direction as well
00:38:49 * ski was sortof thinking that (my electronics theory isn't very up to date)
00:39:21 <ski> this is all being linear relationsships (possibly modifiable via some external control), right ?
00:39:23 <Cale> ski: Well, nobody has found a meminductor or a memcapacitor yet
00:39:34 <Cale> This is an arbitrary fixed function
00:40:42 <Cale> Of course, it'll be linear inside some operating region.
00:40:49 <Cale> (or close enough to it)
00:41:35 * ski would like to see a diagram, to grasp how the memresistor,meminductor,memcapacitor relationships relate to the resistor,inductor,capacitor relationships on charge,current,flux,voltage (and probably 1 - 3 more ?)
00:41:49 <yuriks_> is there something to 'unbox' an IO like <- does, but ignoring the value?
00:41:53 <yuriks_> _ <- myFunc?
00:42:01 <ski> right, i was thinking about the ideal behaviour that we're trying to model
00:42:04 <Cale> Well, for a memristor to exist, for instance, it's apparently known that the function relating charge and flux must be monotone increasing
00:42:46 <scotty> dcoutts_: Can you link me to the Parsec tutorial you were referring to?
00:43:17 <Cale> Note that if you stick a linear function connecting charge and flux in there, then you still have a normal linear resistor
00:43:18 <Axman6> yuriks_: myFunc
00:43:25 <Cale> Just differentiate both sides
00:43:37 <dcoutts_> scotty: same one you were referring to earlier
00:43:41 <monadic_kid> yuriks_ : or >> if you're not using do notation.
00:43:45 <ski> (like a resistor modelling a linear relationship between current and voltage, while a potentiometer modelling a variable (i.e. parameterized) linear relationship between those two (or was it charge instead of current in this case ?))
00:44:14 <dcoutts_> scotty: if you don't like that one try googling
00:44:20 <ski> (yuriks_ : to be explicit, just omit the `_ <- ' part)
00:44:56 <ski> Cale : strictly monotone, or just monotone ?
00:44:58 <yuriks_> http://pastebin.com/fctYBzxz
00:45:13 <yuriks_> the ()'s are placeholders, I'll stick something else there later
00:45:14 <Cale> ski: actually, I'm not 100% sure
00:45:45 <scotty> dcoutts_: It seems fine.  I was just having some trouble getting the examples to work.  I think the names of some of the modules has changed.
00:46:02 * BMeph orders a gin-and-monotonic
00:46:28 <monadic_kid> yuriks_: return () what you're doing in that case statement looks a bit odd
00:46:48 <yuriks_> it does?
00:46:54 <ski> (yuriks_ : hm, now that i consider the problem more, i see that you can't just remove the `filter' if you want to check that there is a single solution *with*empty*rest-of-string* .. so keep the `filter' :)
00:47:02 <yuriks_> it's supposed to start over if it can't parse the input or if it isn't one of the options
00:47:07 <dcoutts_> scotty: yep, you'll have to adjust for the module name changes, otherwise it should be pretty compatible
00:47:15 * dcoutts_ disappears
00:47:29 <scotty> dcoutts_: I've been using this page as well: http://hackage.haskell.org/package/parsec-3.0.0.  I can't seem to find the Parser type constructor.
00:47:34 <ski> yuriks_ : you can remove the `return ()' from that code, and it will behave the same
00:48:15 <yuriks_> ski: I was hoping that by putting 'return ()' at the end I could save from typing 'return' on each of the cases
00:49:19 <ski> yuriks_ : i.e. the last part in a `do'-expression can be a `case'- or an `if-' expression, branching so that the last thing executed will be the last thing in each branch (but you do need to add a `do' after `->' and `then' and `else', if you're having more than one `IO'-command in a branch)
00:49:28 <ski> yuriks_ : you need neither
00:49:47 <ski> since `main' alredy returns `IO ()'
00:49:49 <ski>   do main
00:49:53 <ski>      return ()
00:49:58 <ski> is the same as just `main'
00:50:12 <yuriks_> yes, yes
00:50:25 <yuriks_> but haskell was complaining that () wasn't of the type IO () before
00:50:28 <yuriks_> ghc*
00:50:29 <ski> (but otherwise, yes, in other cases it could be good to factor in that way)
00:50:46 <ski> hm, right
00:50:47 <tensorpudding> Well, main = do main; return () would not work so well
00:51:06 <ski> the `1 -> ()' (and similar) branches actually need to be `1 -> return ()',&c.
00:51:08 <yuriks_> which is why I wanted to convert main from IO () to ()
00:51:17 <yuriks_> ski: yeah, I changed that and it compiled
00:51:28 <ski> since the type of `()', which is written `()' is not the same as the type `IO ()'
00:51:49 <yuriks_> but, everything in the do needs to be an IO command, right?
00:51:54 <ski> yes
00:51:58 <yuriks_> and thus I can't have that case returning a non IO ()
00:52:31 <ski> and since the `case's there is put as commands in an `IO'-`do'-block, the branches of those `case's also need to be `IO'-actions
00:52:50 <ski> (either a single such action, or a combination of several commands, using `do' again)
00:52:54 <yuriks_> mhmm
00:52:58 <ski> yuriks_ : right
00:54:10 <Cale> ski: Did you see the YouTube series of lectures on memristors?
00:54:30 <ski> nope .. i only heard about them when you said something about them here, the other day
00:54:43 <Cale> It's not incredibly detailed, but it gives some basic background anyway.
00:54:49 <Cale> http://www.youtube.com/watch?v=QFdDPzcZwbs
00:55:22 <ski> ty
00:56:30 <dolio> What is there after the first guy's lecture (that's the only one I watched so far)?
00:57:14 <dolio> Information on how you actually make them?
01:02:11 <Axman6> ha, http://www.cpedia.com/wiki?q=Haskell&disambig=Functional%20Programming
01:24:34 <roconnor> Axman6: I think you wanted http://www.cpedia.com/wiki?q=Haskell&disambig=Previous
01:25:12 <Axman6> heh
01:25:51 <Axman6> I love how there are titles, which have nothing at all to do with the content under them
01:27:37 <roconnor> Axman6: the monad section is surprisingly good
01:27:57 <Axman6> it's all the tutorials that did it
01:28:23 <kmc_> i like that "Philip Wadler" is a subsection of "Phil Wadler"
01:29:00 <Axman6> lol
01:29:47 <kmc_> "Monads are very common in Haskell programs and yet every time one needs a monad, it has to be defined from scratch."
01:29:53 <kmc_> that's for sure
01:33:05 <ski> (well, i'd say defining a monad by `newtype'-deriving is not defining one from scratch ..)
01:42:56 * hackagebot time 1.2 - A time library  http://hackage.haskell.org/package/time-1.2 (AshleyYakeley)
01:46:11 <mm_freak> ok, shortest possible subsequences implementation?
01:46:24 <mm_freak> > filterM(pure[odd 2..]) "abc"
01:46:25 <lambdabot>   ["","c","b","bc","a","ac","ab","abc"]
01:46:58 <mm_freak> > filterM(pure[1==2..]) "abc"
01:46:59 <lambdabot>   ["","c","b","bc","a","ac","ab","abc"]
01:47:13 <kmc> > filterM(pure[2<1..]) "abc"
01:47:14 <lambdabot>   ["","c","b","bc","a","ac","ab","abc"]
01:47:20 <mm_freak> =)
01:47:46 <BONUS> haha, nice obfuscation
01:48:00 <kmc> writing obfuscated Haskell is fun
01:48:14 <BONUS> mm_freak: the usual way to write this is filterM (const [True, False])
01:48:15 <kmc> i wish for another IOHCC
01:48:55 <dmwit> > filterM([2<1..].)"abc"
01:48:56 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
01:48:56 <lambdabot>         against inferred ...
01:49:01 <mm_freak> BONUS: i think, that idea came from me originally
01:49:07 <dmwit> :t const
01:49:08 <lambdabot> forall a b. a -> b -> a
01:49:10 <dmwit> :t (.)
01:49:11 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
01:49:15 <dmwit> ack
01:49:17 <mm_freak> the usual naive way is to use map
01:49:25 <mm_freak> and foldr
01:49:27 <BONUS> you came up with the filterM (const [True,False]) trick?
01:49:58 <mm_freak> yeah…  maybe someone else had thought of that earlier, but i made it myself and have never seen it before
01:50:20 <BONUS> ah. very cool :)
01:50:33 <mm_freak> > let subseqs = filterM.pure[2<1..] in subseqs "abc"
01:50:34 <lambdabot>   Couldn't match expected type `a -> m GHC.Bool.Bool'
01:50:34 <lambdabot>         against inferre...
01:50:46 <dmwit> > filterM(\_->[2<1..])"abc"
01:50:47 <lambdabot>   ["","c","b","bc","a","ac","ab","abc"]
01:50:49 <BONUS> when i went to figure that out by myself i made it a normal recursive function
01:51:00 <dmwit> > (length "\_->", length "pure")
01:51:01 <lambdabot>   <no location info>:
01:51:02 <lambdabot>      lexical error in string/character literal at chara...
01:51:17 <mm_freak> BONUS: you can do it easily using foldr and map
01:51:17 <dmwit> > (length "\\_->" {- sigh -}, length "pure")
01:51:20 <lambdabot>   (4,4)
01:51:27 <BONUS> mm_freak: yup
01:52:27 <tensorpudding> you can embed the {-...-} comments inline, I didn't know that.
01:54:03 * ksf thinks it should be possible to switch off open recursion for a data type and everything inside it, allowing recursion in wanted places by providing a typeclass instance for the fixpoint.
01:54:28 <mm_freak> :t filterM([2<1..]<$id)
01:54:29 <lambdabot> forall a. [a] -> [[a]]
01:54:47 <roconnor> ksf: sounds like agda a bit
01:54:47 <ksf> right now, as I see it, there's no way at all to guarantee that a haskell term is finite.
01:55:07 <kmc> or productive, or normalizing
01:55:11 <roconnor> and the partiality monad
01:55:51 <ksf> ...the point is that I don't _want_ the term to exhibit turing-completeness, because it is say a term that describes a regular language.
01:56:32 <ksf> ...and it would be great to be able to snatch the fixpoint out of the syntax to make an explicit kleene star.
01:57:24 <roconnor> ksf: yes yes, we all know this
01:57:59 <ksf> so I only have to close my eyes and count to e and it'll be done?
01:58:15 <roconnor> yes
01:58:22 <BONUS> > foldr (\x -> concatMap (\ys -> [x:ys,ys])) [[]] "abc"
01:58:22 <lambdabot>   ["abc","bc","ac","c","ab","b","a",""]
02:00:17 <BONUS> > foldr (\x -> concatMap (sequence [fst, snd] . (x:) &&& id)) [[]] "abc"
02:00:18 <lambdabot>   Couldn't match expected type `(b, b)' against inferred type `[a]'
02:01:51 <mm_freak> haven't had enough scary code?
02:02:01 <mm_freak> > foldM(\x y->[x,x++[y]])[] "abc"
02:02:04 <lambdabot>   ["","c","b","bc","a","ac","ab","abc"]
02:02:04 <ksf> I think the allow open recursion by giving an instance for fix thing is new, though.
02:03:07 <roconnor> ksf: I'm not sure that makes sense
02:03:31 <roconnor> partial functions are typically considered by introducing a partiality monad
02:03:37 <ksf> I've got the advantage of ignorance, there.
02:04:32 <mm_freak> (actually that one is easier to understand than the filterM-based solution
02:17:11 <gerryxiao> hello
02:17:18 <gerryxiao> i'm new to haskell
02:17:31 <gerryxiao> what's cabal,dars,and hackage??
02:18:25 <voker57> @whereis cabal
02:18:25 <lambdabot> Maybe you meant: where where+
02:18:31 <voker57> @where cabal
02:18:31 <lambdabot> http://www.haskell.org/cabal
02:18:35 <voker57> @where darcs
02:18:35 <lambdabot> http://darcs.net/
02:18:39 <voker57> @where hackage
02:18:39 <lambdabot> http://hackage.haskell.org/package/
02:19:14 <gerryxiao> nope, i want know when to use them or why to use them
02:19:40 <dolio> Cabal is a build tool designed to work well for haskell programs. Darcs is a version control system. Hackage is a package repository for cabalized haskell libraries/applications.
02:19:41 <dmwit> gerryxiao: cabal is two things: a library for tracking information about Haskell packages, and an executable for installing packages that have cabal information
02:19:53 <dmwit> ...and dolio's got the rest =)
02:20:34 <paulvisschers> Woop, I got haskelldb to work <:oD
02:20:55 <gerryxiao> dmwit: all haskell packages have cabal information?
02:21:04 <paulvisschers> *Main> main
02:21:04 <paulvisschers> []
02:21:09 <paulvisschers> wooi :)
02:21:10 <dmwit> gerryxiao: No, unfortunately.
02:21:31 <paulvisschers> gerryxiao: a lot of them do though
02:21:37 <gerryxiao> cabal is source installing tool?
02:21:40 <Axman6> gerryxiao: most
02:21:42 <dmwit> gerryxiao: However, the most useful ones either currently have it or are working hard to get it. =)
02:21:49 <dmwit> gerryxiao: Yes.
02:21:50 <dschoepe> the most prominent exception is gtk2hs
02:22:19 <gerryxiao> but then what's dars?
02:22:25 <dmwit> There is a dev-branch of gtk2hs that is cabalized. (Yay!)
02:22:33 <dmwit> gerryxiao: darcs is a revision control system
02:22:42 <kmc> gerryxiao, did you download Haskell Platform?
02:22:48 <Axman6> gerryxiao: darcs, not dars
02:22:49 <gerryxiao> kmc: yes
02:22:57 <kmc> gerryxiao, darcs has the same role as git, cvs, or Subversion
02:23:05 <dmwit> gerryxiao: Lots of Haskell packages offer both stable releases (via Hackage) and unstable versions (via darcs).
02:23:06 <kmc> it's written in Haskell and used by a lot of Haskellers
02:23:14 <dv-> Haskell is the new PHP
02:23:20 <kmc> but it's not required that source control for Haskell be in darcs
02:23:23 <kmc> git is also very popular
02:23:33 <gerryxiao> i have download haskell platform and ghc 6.12.x on ubuntu lucid
02:24:20 <gerryxiao> dmwit: you mean cabal for stable and dars for unstable?
02:24:28 <kmc> it's "darcs"
02:24:30 <kmc> not "dars"
02:24:41 <kmc> gerryxiao, Hackage is the name of this website: http://hackage.haskell.org/packages/archive/pkg-list.html
02:24:42 <gerryxiao> kmc; oops
02:25:03 <gerryxiao> cabal not work
02:25:05 <Axman6> gerryxiao: cabal and darcs aren't really related
02:25:18 <gerryxiao> Axman6: ?
02:25:25 <kmc> gerryxiao, Cabal is a system used to build Haskell programs from source, whether you got them from Hackage, from a darcs or git checkout, or downloaded a tarball, or any other means
02:25:28 <dschoepe> gerryxiao: darcs is for getting the source code, cabal is for installing it(, but it can also fetch packages from hackage)
02:25:49 <Axman6> cabal is basically the package manager part of the haskell world, where as darcs is just a revision control system like git, or CVS, or subversion
02:25:50 <dmwit> gerryxiao: Generally speaking, cabal is used to build both stable versions of packages (from Hackage) and unstable versions of packages (from darcs).
02:25:55 <kmc> the package "cabal-install" available on Hackage (and which comes with Platform) lets you grab a package from Hackage and then install it
02:25:59 <kmc> i.e. "cabal install bytestring"
02:26:11 <gerryxiao> cabal alike apt-get
02:26:15 <kmc> yeah
02:26:24 <Axman6> sort of
02:26:24 <gerryxiao> ok,i know it
02:26:37 <Axman6> except it compiles the source code that it downloads
02:26:38 <gerryxiao> darcs is git
02:26:48 <Axman6> darcs is not git, it's like git
02:26:52 <kmc> well, the command you type is "cabal" but the name of that project is "cabal-install" to distinguish it from the "cabal" library
02:27:00 <kmc> they're closely related though
02:31:54 <gerryxiao> in haskell-platfrom cabal is only 0.6.x,right?
02:32:35 <gerryxiao> it not work with ghc 6.10
02:33:43 <dmwit> You'll have to be more specific.
02:33:54 <gerryxiao> how to fix it? i want to  cabal install yi
02:34:02 <dmwit> What did you try? What was the error?
02:34:16 <gerryxiao> and where is docs of yi?  i mean key bindings
02:40:17 <gerryxiao> hello
02:40:38 <gerryxiao> where can i found docs for yi?
02:41:14 <gerryxiao> i mean key bindings
02:41:36 <gerryxiao> how to call ghci,and others
02:43:41 <gerryxiao> from haskell wiki, i can't find any information about this
02:48:16 <gerryxiao> Ambiguous module name `Control.Monad.State':
02:48:16 <gerryxiao>       it was found in multiple packages: mtl-1.1.0.2 monads-fd-0.0.0.1
02:48:24 <gerryxiao> how to fix it?
02:48:27 <kmc> gerryxiao, why do you want to use yi?
02:48:30 <kmc> it's not very stable / mature
02:48:51 <gerryxiao> kmc: i want to try one editor writen by haskell
02:49:04 <kmc> okay
02:49:11 <kmc> your reason for wanting to use yi is that you want to use yi
02:49:13 <kmc> that's fair enough
02:49:31 <dmwit> leksah is pretty impressive these days
02:49:53 <dmwit> As for your exact problem, is this an error from cabal or ghci?
02:50:13 <gerryxiao> dmwit: ghci
02:50:14 <dmwit> If ghci, you can use ghc-pkg to hide one of the two packages (probably monads-fd, if I had to guess).
02:51:51 <gerryxiao> i just install yi by cabal, it may have installed monads-fd which i havenot installed by default
02:52:41 <gerryxiao> dmwit: leksah?
02:53:18 <kmc> http://hackage.haskell.org/package/leksah
02:54:42 <tensorpudding> Leksah's only for Haskell though.
02:54:45 <gerryxiao> ok,thx
02:55:31 <gerryxiao> how to install it?
02:55:37 <gerryxiao> cabal install leksah
02:56:35 <gerryxiao> Resolving dependencies...
02:56:35 <gerryxiao> cabal: cannot configure leksah-0.8.0.4. It requires glib >=0.10, gtk >=0.10
02:56:36 <gerryxiao> and gtksourceview2 >=0.10.0
02:57:16 <luite> gerryxiao: install gtk2hs manually first
02:57:36 <kmc> can you configure leksah for vim bindings?
02:57:51 <gerryxiao> There is no available version of glib that satisfies >=0.10
02:57:51 <gerryxiao> There is no available version of gtk that satisfies >=0.10
02:57:51 <gerryxiao> There is no available version of gtksourceview2 that satisfies >=0.10.0
02:58:16 <luite> gerryxiao: you cannot yet use cabal-isntall to install gtk2hs
02:59:18 <gerryxiao> what's wrong here?
02:59:40 <gerryxiao> gtk2hs can't be installed
03:00:06 <luite> like I said, you have to install it manually. download the source package and compile it, or download the installer if you're on windows
03:00:53 <gerryxiao> cabal dont know gtk2hs
03:00:58 <luite> or, use a package for your distro, if there's one available
03:01:32 <gerryxiao> cabal: There is no package named gtk2hs
03:01:55 <Axman6> gerryxiao: helping you would be a lot easier if you read what people said to you, instead of repeating your problems
03:02:17 <luite> gerryxiao: download it here.... http://haskell.org/gtk2hs/ (shouldn't have been that hard to find)
03:02:51 <gerryxiao> and it seems libghc6-gtk-dev on ubuntu is broken now
03:05:18 <gerryxiao> hi?
03:08:01 <kmc> i am trying leksah now and i'm not very impressed
03:08:09 <Axman6> i wasn't either
03:08:38 <kmc> it won't autocomplete names from the same file
03:09:09 <lpsmith> is it just me,  or is Integer division in GHC darn slow?
03:09:50 <Axman6> what sort of sized Integers>
03:09:52 <Axman6> ?*
03:09:52 <lambdabot> Maybe you meant: . ? @ v
03:10:34 <dolio> Compared to what?
03:10:57 <dolio> Presumably it's not much slower than what you'd get in C using GMP.
03:11:19 <dolio> Unless GHC is generating particularly bad code.
03:11:33 <lpsmith> well,  I just solved Project Euler 284,  and my solution was darn slow
03:11:40 <pokoko222> this is crazy, blind people do computer science? http://www.scholarships.com/financial-aid/college-scholarships/scholarships-by-major/computer-science-scholarships/nfb-computer-science-scholarship.aspx
03:12:06 <lpsmith> and it seems that any time heavy Integer division is involved with a PE problem,  my solution sucks
03:12:07 <pokoko222> i mean, crazy in an inspiring way
03:12:15 <jlouis> pokoko222: yes?
03:12:39 <pokoko222> jlouis what do these people do, u have information? i mean, how can blind man even type
03:12:48 <Axman6> blind people do lots of things actually
03:12:59 <lpsmith> I mean,  I haven't really dug through the issues,  and I'll admit I have a tendancy to blame division,  but I have this nagging suspicion that somethings wrong.
03:13:00 <lpsmith> sigh
03:13:01 <jlouis> pokoko222: blind people can play music, why shouldn't they be able to type?
03:13:04 <Axman6> i'd bet most blind people can type better than you can pokoko222
03:13:12 <kmc> +5 Insightful
03:13:27 <jlouis> +10 Coffee
03:13:43 <jlouis> ANNOUNCEMENT: The Coffee Zombie roams the streets no longer
03:13:47 <pokoko222> inspiring
03:14:15 <lpsmith> Stephen Hawking does physics by moving his eyes
03:14:31 <dolio> And raps.
03:14:39 <lpsmith> If Hawking can do physics,  surely a blind person can do CS
03:14:40 <lpsmith> lol
03:14:45 <BONUS> actually he does it by thinking
03:14:54 <jlouis> BONUS: lies!
03:15:10 <jlouis> It's the eye movement
03:15:26 <Axman6> pokoko222: did you really think that blind people were incapable of using computers?
03:15:42 <kmc> i can produce better code using only my large intestine than most professional software developers
03:15:52 <lpsmith> BONUS, point taken :)
03:16:02 <jlouis> kmc: +5 insightful
03:16:30 <lpsmith> But my point was that Hawking can't use a pencil and paper;  he needs to keep a lot more in his mind than I can :)
03:16:31 <kmc> :D
03:16:36 <pokoko222> Axman6 well how do they do logic and proofs man? u gotta see the thing and write it
03:16:49 <Axman6> -_-
03:16:52 <jlouis> pokoko222: they feel it
03:16:55 <lpsmith> Me,  I need a text editor,  pencil, and paper to do something complicated
03:16:56 <pokoko222> lool
03:17:04 <chrisdone> at school diagrams would always show the large intestine as a smaller bit of gray sploge, and the small intestine as a large bit of gray sploge
03:17:23 <jlouis> pokoko222: really, theres this board you can use where the letters are written out in braille
03:17:41 <jlouis> so you can literally feel the text
03:17:49 <jlouis> text-to-speech is also popular
03:17:55 <pokoko222> yeah i know so what
03:18:00 <pokoko222> i doubt they can do serious work
03:18:08 <kmc> pokoko222, i doubt you can do serious work
03:18:10 <Axman6> >_<
03:18:11 <kmc> AD HOM'd
03:18:22 <lpsmith> heh
03:18:27 <jlouis> -3 Trollisgh Coffee Zombie
03:18:30 <Axman6> did you just gangstafy latin?
03:18:37 <Axman6> if so, kmc++
03:18:46 <pokoko222> kmc u doubted me at start so what, i solved 50 eulers haskell, 20 in c++, i do 10.0 at college, and from october i join second college on math so ... yeah...
03:19:06 <kmc> ahahaha
03:19:09 <luite> hehe
03:19:13 <chrisdone> channel opts about?
03:19:14 <lpsmith> PE isn't exactly serious work
03:19:21 <kmc> his euler level is over 9000
03:19:23 <Axman6> jesus, you're still on about project euler? do some damn work!
03:19:27 <Axman6> for christs sake
03:19:29 <lpsmith> it can be good fun and a great way to learn a bit
03:19:29 <luite> pokoko222: that should be enough for a turing award
03:19:30 <jlouis> over 9000?
03:19:33 <luite> or maybe a fields medal :p
03:19:34 <jlouis> omg
03:20:00 <Axman6> luite: two i think
03:20:01 <jlouis> Axman6: he can't be bothered doing real work :)
03:20:02 <pokoko222> lpsmith try to do it along college while keeping grades at 10.0
03:20:03 <Axman6> at least
03:20:14 <Axman6> pokoko222: no one cares
03:20:14 <roconnor> @seen ops
03:20:14 <lambdabot> Unknown command, try @list
03:20:23 <kmc> 10.0
03:20:28 <kmc> that's, like, three times what i got in college
03:20:33 <kmc> damn you must be smart pokoko222
03:20:48 <Axman6> 10%?
03:20:49 <pokoko222> kmc damn yeah
03:20:53 <BONUS> that reminds me, where is HaskellLove
03:21:06 <xerox> BONUS: surprise
03:21:11 <pokoko222> got to famous i had to change name :D
03:21:18 <BONUS> haha lol
03:21:38 <kmc> gotta use CoqLove next
03:23:02 <lpsmith> Beethoven wrote the ninth symphony,  the work he's easily best remembered for,  when he was deaf.
03:24:07 <pokoko222> after a lifetime of doing music yes
03:24:07 <lpsmith> If I went blind,  I'd probably have a very difficult time with CS
03:24:23 <lpsmith> but that's not to say somebody else can't
03:24:44 <lpsmith> There are professional musicians who were born deaf
03:24:58 <arcatan> q
03:25:25 <xcvii> o_O name one
03:25:51 <Twey> Coding isn't really an innately visual discipline… I know a blind coder or two
03:25:59 <Axman6> http://en.wikipedia.org/wiki/Category:Deaf_musicians
03:26:12 <Axman6> yay wikipedia
03:27:18 <BONUS> for y'all interested in blind people coding and using computers, this is a very good read: http://forums.somethingawful.com/showthread.php?threadid=2438897
03:27:27 <Axman6> http://www.nfb.org/nfb/NFB_computer_science.asp
03:27:43 <Axman6> NFB = national federation of the blind
03:27:59 <Axman6> hmm, the page has no info on it
03:29:17 <lpsmith> there seems to be an increasing fraction of webpages that seem to exist for absolutely no reason at all
03:29:52 <lpsmith> Others appear to exist for a reason,  but one that's very opaque
03:29:57 <Twey> ‘DIS IS MAI KAT MOGGY SHE IZ VER NAIS’
03:30:12 <Twey> ‘SEE MOAR PIKCHERZ’
03:30:57 <lpsmith> I once ran across domains of what seemed to be "word" lists when trying to get a google whack;   except most of the words were nonsense
03:31:10 <lpsmith> You'd think it was some kind of link farm except without the links
03:32:00 <lpsmith> maybe that's why they existed; to deny people a google whack :-P
03:32:49 <Twey> Yeah… heh, maybe
03:43:40 * hackagebot haskell-src-exts 1.9.0 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer  http://hackage.haskell.org/package/haskell-src-exts-1.9.0 (NiklasBroberg)
04:00:41 <m3ga> i didn't do it, but it looks like the ghc trac has just died.
04:02:47 <chrisdone> sure you didn't
04:04:25 <Axman6> why've you always got to ruin it for everyone else Erik? :P
04:07:31 <m3ga> it wasn't me. i didn't do it. honest!
04:20:17 <marekw2143> How to write maximum function in haskell (that returns maximum eelemnt from the list) so that it could find maximum elements in big lists?
04:20:30 <marekw2143> because recursion version gives stackOverflow
04:21:06 <xerox> > let f (x:xs) = foldl' max x xs in f [1..10000000]
04:21:07 <xcvii> (foldl' max) ?
04:21:07 <lambdabot>   10000000
04:21:07 <luite> marekw2143: you can either make your version stricter manually (use seq), or use foldl'
04:21:29 <luite> marekw2143: note that compiling with optimization will often get rid of the stack overflow automatically
04:22:29 <marekw2143> xerox, xcvii, luite: thanks :)
04:39:32 <mercury^> marekw2143: note that there is a maximum function already.
04:39:52 <marekw2143> mercury^: yes, I know that
04:40:04 <mercury^> It should be defined as foldl1' max I think.
04:40:07 <mercury^> @src maximum
04:40:08 <lambdabot> maximum [] = undefined
04:40:08 <lambdabot> maximum xs = foldl1 max xs
04:40:17 <mercury^> almost
04:40:58 <mercury^> Hrm, actually that seems like a bad definition.
04:41:10 <mercury^> > maximum [1..1000000]
04:41:11 <lambdabot>   * Exception: stack overflow
04:41:26 <mercury^> > foldl1' max [1..1000000]
04:41:27 <lambdabot>   1000000
04:41:34 <mercury^> Yeah, dunno what is up with that.
04:42:31 <b0fh_ua> Hi there
04:42:41 <b0fh_ua> How do I ouptut euro sign in haskell?
04:43:17 <mercury^> > putStr "€"
04:43:18 <lambdabot>   <IO ()>
04:44:44 <b0fh_ua> hmm, it doesn't work well
04:45:32 <b0fh_ua> when opening file in vim, there's no euro sign - but <ac> listed
04:45:44 <smiler> Welcome to encoding hell
04:45:53 <b0fh_ua> probably something is wrong when redirecting output from terminal to a file?
04:46:26 <b0fh_ua> smiler: so what is the remedy? :)
04:46:52 <smiler> Loose a bit of your sanity and enforce utf8 ^^
04:46:52 <mercury^> Setting up your terminal and editor correctly.
04:47:02 <b0fh_ua> I am using Data.ByteString.Char8
04:47:05 <benmachine> mercury^: since max is in the Ord typeclass it's technically possible for it to be lazy
04:47:29 <b0fh_ua> mercury^: LANG=en_US.UTF-8
04:47:32 <mercury^> b0fh_ua: sigh.
04:47:35 <benmachine> well, that doesn't entirely explain it
04:47:41 <benmachine> it's still odd
04:47:45 <mercury^> b0fh_ua: don't use bytestring.
04:47:46 <benmachine> but whatevs
04:47:57 <b0fh_ua> mercury^: well :)
04:48:03 <b0fh_ua> why not?
04:48:12 <b0fh_ua> it should handle UTF-8?
04:48:13 <mercury^> Because you want characters that are not ASCII.
04:48:24 <benmachine> you might be OK with iso-8859-15 though
04:48:34 <benmachine> which is still 8-bit
04:48:58 <mercury^> There is a package for internal UTF8 representations.
04:49:06 <benmachine> er, but ac isn't eurosign in iso-8859-anything
04:49:09 <benmachine> hi Cadynum
04:49:12 <mercury^> The normal strings are converted on IO.
04:49:23 <Cadynum> hello benmachine
04:49:29 <b0fh_ua> hmm
04:50:06 <b0fh_ua> may be it is possible to emit sequence of bytes to create utf-8 representation of euro sign?
04:50:36 <mercury^> You are not using UTF8 IO atm, why would you want that?
04:50:59 <b0fh_ua> well, I have to create output file with euro signs in it
04:51:14 <mercury^> So why don't you just use normal strings?
04:51:39 <b0fh_ua> mercury^: I was told that ByteString is efficient for processing large files
04:51:44 <benmachine> it is
04:51:48 <benmachine> hmm
04:51:56 <benmachine> you could look at Data.Text
04:51:59 <mercury^> ByteSring is not fast either, and you probably don't need performance.
04:52:10 <benmachine> I don't know how it compares for efficiency but it's probably better than String
04:52:22 <benmachine> and it supports some unicode variant
04:52:40 <benmachine> alternatively there are ways to encode stuff
04:52:46 <ManateeLazyCat> Hi all, have you read any book that talk about "API Design" ?
04:52:46 <benmachine> but I can't remember what they are >_>
04:53:01 <Vitka> Is there actually fast implementation of ByteString?
04:53:07 <b0fh_ua> benmachine: most of the text is in plain old latin1 encodning, I just have to deal with those euro signs
04:53:14 <mercury^> Vitka: no.
04:53:30 <Vitka> Any fast alternatives then?
04:53:34 <mercury^> No.
04:53:42 <Vitka> Sad.
04:53:44 * benmachine suspects mercury^ is being facetious
04:53:56 <benmachine> or not facetious but one of those words
04:54:08 <mercury^> I am serious.
04:54:46 <benmachine> well, do you then mean that all Haskell IO is slow, or all IO is slow?
04:54:55 <mercury^> Haskell IO is slow.
04:55:11 <benmachine> hmm
04:55:43 <benmachine> why do you think that is?
04:56:06 <mercury^> It just is. You can try implementing cat with ByteString and in C.
04:56:16 <mercury^> Or wordcount.
04:56:22 <benmachine> just is is not a reason :P
04:58:29 <b0fh_ua> benmachine: thanks, with Data.Text everything works as expected
04:58:34 <b0fh_ua> and not significantly slow
04:58:35 <mercury^> benmachine: http://rohanlean.de/pub/wc/
05:00:13 <mercury^> benmachine: if you have ssse3, you can run all of them.
05:00:25 <mercury^> But otherwise, just running C vs Haskell should show you some difference.
05:04:41 * benmachine tries to think of any actually large documents he has
05:05:20 <mercury^> I could upload my benchmark document, but that seems like a waste of bandwidth.
05:05:28 <benmachine> it does
05:05:52 <benmachine> can I just not owrry about it :P
05:06:56 <benmachine> it's fine if C IO is faster than Haskell but I think it's just confusing if you say "bytestring IO is slow" without explanation
05:07:04 <benmachine> say compared to what
05:07:30 <Twey> C IO is slow
05:09:26 <mercury^> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24812#a24812
05:11:57 <Vitka> Are there FFI wrappers for IO, then?
05:12:29 <Twey> You're doing it wrong, but you should ask dons or someone about beating C.  I just remember that it was done.
05:13:09 <mercury^> It was done when c was using locked getchar/putchar.
05:15:15 <Twey> ‘Just is’ really isn't a reason
05:15:24 <Twey> We should try to isolate the cause
05:15:31 <Twey> Did you profile?
05:16:41 <mercury^> I already talked to dons about it, giving him more detailed measurements.
05:16:49 <mercury^> That was about 10 months ago.
05:20:45 <sadache_> anyone there from the Happs team?
05:20:50 <benmachine> any interesting conclusions?
05:20:59 <roconnor> #happs
05:21:29 <sadache_> ok
05:29:58 <mreh> I'm importing PCM data from a wav file with the HCodecs, but I'm not sure how to parse the data properly because the function polymorphic
05:30:35 <mreh> I can't truncate the words safely unless I know what type of file it is, which is why I'm parsing it
05:30:49 <dankna> I am doing something similar.
05:30:57 <dankna> The way I do it is something like this --
05:31:10 <dankna> I have one function which reads just enough of the file to know what type it is
05:31:51 <dankna> Then another function with a type like :: forall content (Bounded content, Integral content) => Handle -> [content]
05:32:00 <dankna> (your type may differ, but the important bit is the foralled context)
05:32:07 <mreh> dankna: I was hoping I didn't have to do that :)
05:32:08 <dankna> and I turn on ScopedTypeVariables
05:32:12 <dankna> so that within the function I can say
05:32:23 <dankna> (maxBound :: content)
05:32:45 <palmje> anyone know how to binary read/write from a handle?
05:32:46 <dankna> yeah, I'm not sure how you'd do it without that, but if you find another way let me know
05:33:01 <dankna> palmje: look at network-bytestrings (might be called bytestrings-network or something)
05:33:05 <dankna> er wait
05:33:10 <dankna> you don't need net functionality
05:33:11 <xerox> Get monad?
05:33:15 <dankna> just look at bytestrings
05:33:29 <palmje> thanks
05:33:32 <xerox> ?hackage binary
05:33:32 <lambdabot> http://hackage.haskell.org/package/binary
05:33:36 <mreh> xerox: who are you addressing that to?
05:33:52 <dankna> the binary package is for serializing/deserializing Haskell values
05:34:00 <dankna> if that's what you're doing, it's appropriate
05:34:17 <dankna> if you're dealing with some binary format that you don't have the luxury of defining yourself, you want bytestrings
05:41:29 <olsner> you can use binary's get and put monads to do binary parsing
05:42:34 <Jonno_FTW> how can I make Maybe.fromJust return 0 instead of nothing and avoid getting an exception?
05:42:51 <xerox> olsner: that's what I heard, good!
05:42:53 <mauke> step 1: don't use fromJust
05:42:56 <dankna> maybe 0 id myMaybe
05:43:03 <mauke> :t fromMaybe
05:43:04 <Jonno_FTW> :|
05:43:04 <lambdabot> forall a. a -> Maybe a -> a
05:43:14 <mauke> fromMaybe 0
05:45:37 <Jonno_FTW> I'm using this: http://hackage.haskell.org/packages/archive/cgi/3001.1.7.1/doc/html/Network-CGI.html#v:getInput
05:45:45 <dankna> hey I have a question
05:46:11 <dankna> what can I use instead of fromJust that will fail in a monad instead of throwing in pure code.... no never mind, it's trivial to do it myself
05:46:28 <mauke> Jonno_FTW: how can it return 0 if it's a String?
05:46:40 <Jonno_FTW> oh right
05:46:41 <dankna> do you want "" or "0"?
05:46:44 <Jonno_FTW> the string "0"
05:47:22 <dankna> theResult <- getInput "query" >>= return . fromMaybe "0"
05:47:28 <dankna> might need parens in there somewhere
05:48:04 <ski> theResult <- fromMaybe "0" `liftM` getInput "query"
05:48:04 <benmachine> fromMaybe "0" <$> getInput "query"
05:48:14 <benmachine> or, that
05:48:23 <dankna> !
05:48:26 <dankna> :t <$>
05:48:27 <lambdabot> parse error on input `<$>'
05:48:28 <ski> (and if we ignore that that's a return there, you should still do
05:48:30 <dankna> :t (<$>)
05:48:32 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:48:39 <ski>   theResult <- return . fromMaybe "0" =<< getInput "query"
05:48:39 * dankna needs to learn functors
05:48:43 <ski> since that reads better
05:48:44 <ski> )
05:48:55 <benmachine> dankna: Functor is the easiest
05:48:57 <mauke> @src Functor
05:48:57 <lambdabot> class  Functor f  where
05:48:57 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
05:49:05 <benmachine> (<$>) = fmap
05:49:06 <mauke> dankna: there, now you know functors
05:49:14 <benmachine> that's literally all there is to it
05:49:39 <dankna> so a functor is a thing that you can do the following operation on:  given a functor containing a value and a function that does something to that value, do something to that value
05:49:48 <Jonno_FTW> thanks guys
05:49:49 <dankna> what are some examples of functors?
05:49:52 <ski> if you're polymorphic in the monad, then `liftM' is better than `fmap' or `(<$>)', as long as the `Functor'-not-being-superclass-of-`Monad'-problem hasn't been fixed
05:49:52 <dankna> Jonno: np
05:50:13 <benmachine> dankna: all Applicatives are necessarily Functors
05:50:17 <ski> (since that avoids adding an auxilary `Functor' contstraint when the `Monad' one will do just as fine)
05:50:23 <dankna> that would be great if I understood Applicatives :)
05:50:26 <Jonno_FTW> my cgi still doesn't work properly though
05:50:28 <benmachine> dankna: any Monad can be made a Functor too, since liftM has the same typesig
05:50:44 <ski> @type (<$>)  -- see, no `Applicative', in here
05:50:45 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:51:00 <ski> `(<$>)' is just a synonym for `fmap'
05:51:07 <dankna> Jonno: by the way, if you get too frustrated at the Network.CGI library, I wrote direct-fastcgi as a replacement for it.  But I don't have time to really give a tutorial so you probably want to keep doing what you're doing :)
05:51:10 <mauke> dankna: many containers
05:51:16 <mauke> dankna: [], Maybe
05:51:17 <dankna> but I thought I'd advertise anyway
05:51:23 <dankna> hmm
05:51:35 <benmachine> dankna: oh, when I said that's literally all there is to it I forgot the functor laws
05:51:41 <Jonno_FTW> I'm trying to follow the tutorial on http://www.haskell.org/haskellwiki/Practical_web_programming_in_Haskell
05:51:45 <dankna> okay.  what are the functor laws?
05:51:52 <benmachine> functor instances should satisfy
05:51:54 <benmachine> fmap id = id
05:52:03 <benmachine> and fmap (f . g) = fmap f . fmap g
05:52:08 <Jonno_FTW> but use a cookie to display different content
05:52:16 <ski> dankna : to be pedantic, a value of type `f a' here isn't called "a functor containing a value" .. `f' itself is the functor .. the value of type `f a' might be called an `f'-collection or something ..
05:52:25 <dankna> ski: okay, hmm
05:52:35 <benmachine> so Maybe is a functor
05:52:37 <dankna> Jonno: okay, well, stick to the tutorial :)
05:52:52 <benmachine> (Maybe a) isn't?
05:52:52 <ski> (this is similar to `getLine' not being a monad, but a monadic action, for the monad `IO')
05:52:56 <dankna> benmachine: okay, got i.
05:52:56 <ski> right
05:53:21 <dankna> ski: okay.  I believe I see what you're saying.
05:53:31 <benmachine> dankna: basically the laws try to enforce that fmap *only* affects any contained values, not the "structure" of the container
05:53:32 <ski> also, `State s' is a functor (and a monad) for any `s', but `State' isn't really a functor or a monad by itself (though we call it that, by sloppy language)
05:53:35 <chrisdone> Jonno_FTW: which tutorial?
05:53:40 <dankna> benmachine:  yeah that makes intuitive sense
05:53:42 <Jonno_FTW> http://www.haskell.org/haskellwiki/Practical_web_programming_in_Haskell
05:53:48 <chrisdone> Jonno_FTW: I mean which part
05:54:22 <Jonno_FTW> 4.4, but with login instead of file upload
05:54:27 <benmachine> dankna: one interesting thing is, what types aren't functors
05:54:51 <ski> @kind Maybe
05:54:52 <lambdabot> * -> *
05:54:54 <ski> @kind IO
05:54:55 <lambdabot> * -> *
05:54:56 <ski> @kind State
05:54:57 <lambdabot> * -> * -> *
05:54:58 <dankna> benmachine: hmmm, I imagine so.  have you an example in mind? :)
05:54:58 <ski> @kind State Int
05:54:59 <lambdabot> * -> *
05:55:14 <benmachine> dankna: Set is an interesting one
05:55:33 <dankna> (is there a way to ask lambdabot whether State Int is an instance of functor?)
05:55:34 <benmachine> dankna: Sets require that the contents are ordered, but fmap allows you to change the contents into whatever you like
05:55:42 <ski> @instances Functor
05:55:42 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
05:55:46 <dankna> gotcha
05:55:49 <ski> dankna : not directly
05:55:51 <benmachine> dankna: there is, but it's easier to use ghci :info
05:55:59 <benmachine> :i Functor shows all instances of Functor
05:56:07 <benmachine> :i [] shows you that [] is a Functor
05:56:28 <dankna> Benmachine: hmmmm.... right.  so Set can't be an instance then.  even though it might make sense if we were talking about the abstract mathematical notion of a set and not the concrete data type.
05:56:44 <ski> (also, `instances' as above doesn't give you the constraints .. only the raw types being instances)
05:56:56 <dankna> benmachine: ah yes, I need to get in the :i habit
05:56:57 <ski> @instances Monad
05:56:58 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
05:57:03 <ManateeLazyCat> impredicative polymorphism will be simplified or removed in GHC 6.14 ?
05:57:07 <ManateeLazyCat> That's mean i can't run "type EnvFun = forall e . EnvArg e => e -> IO ()" in ghc 6.14?
05:57:12 <benmachine> dankna: yeah, because implementing a Set requires testing for equality at least (and if you want to do it efficiently you need ordering)
05:57:17 <ski> e.g. `Writer w' isn't a monad generally, only when `w' is a `Monoid'
05:57:35 <benmachine> dankna: I guess in mathematics everything is equatable, and efficiency isn't a concern
05:57:52 <dankna> benmachine: right.  I'm well aware - I just implemented my EnumSet last week which uses the context (Ord content, Bounded content, Enum content)
05:58:22 <benmachine> so Set "should" be a Functor but isn't because Haskell doesn't know how to make Set (a -> b) work
05:58:27 <dankna> makes sense
05:58:35 <ski> dankna : one can probably say something like `Set' is a functor on the types of kind `*', *that*supports*`Ord'*
05:58:45 <ski> however, we can't express that in the kind system
05:58:49 <dankna> hmm
05:59:02 <dankna> and for good reason - just imagine an implementation of such a functor
05:59:07 <dankna> it would have to re-make the entire set
05:59:15 <dankna> the simplest way would be to go through a list representation as an intermediate
05:59:23 <benmachine> well, only inasmuch as map has to remake the whole list
05:59:30 <benmachine> or hmm
05:59:33 <benmachine> yeah, maybe
05:59:37 <dankna> well no, because the result might be in a totally different order
05:59:42 <benmachine> ah true
05:59:48 <ski> but instead of `Set :: * -> *', (i think) we'd want to say something like `Set :: {a :: * | Ord a} -> {a :: * | Ord a}'
06:00:05 <ski> and then we'd need a new class for talking about functors over this new kind
06:00:09 <dankna> right hmm
06:00:38 * hackagebot cgi-utils 0.1 - Simple modular utilities for CGI/FastCGI (sessions, etc.)  http://hackage.haskell.org/package/cgi-utils-0.1 (ChrisDone)
06:00:48 <Rosebud_> hey guyz sry to interupt, but can i just ask a quick ques?:p
06:00:52 <ski> (or, better, if it could be done, make a `Functor' class that is polymorphic in what kinds the domain and codomain of the actual functor instances of it must have)
06:01:14 <ManateeLazyCat> Rosebud_: Just ask, don't ask to ask. :)
06:01:18 <chrisdone> preflex: seen mmorrow
06:01:18 <preflex>  mmorrow was last seen on #ghc 83 days, 10 hours, 3 minutes and 32 seconds ago, saying: * mmorrow is rtfm'ing
06:01:26 <dankna> this is fascinating, but now I have to go and obtain kittens :)
06:01:32 <dankna> see y'all later
06:01:41 <Jonno_FTW> wow
06:01:45 <chrisdone> bye dankna
06:01:50 <dankna> bye
06:01:51 <Rosebud_> :) yye... ive got a function which is constructRow :: [Digit] -> Int -> Grid
06:02:00 <Rosebud_> grind is a list of Squares
06:02:02 <Jonno_FTW> greatest exit code ever
06:02:05 <Rosebud_> and Sqaure is an obect
06:02:05 <ManateeLazyCat> chrisdone: mmorrow have seen disappear long time.
06:02:16 <Rosebud_> and when i do this
06:02:17 <Rosebud_> constructRow (x:xs) n
06:02:20 <chrisdone> ManateeLazyCat: yes
06:02:21 <Rosebud_> i get an error :(
06:02:36 <ManateeLazyCat> Rosebud_: Plase paste your error.
06:02:36 <Rosebud_> Does not match : a -> b
06:02:44 <ski> dankna : consider e.g. types of kind `(* -> *) -> (* -> *)', we can say when such types are functor by declaring `class Functor2 t where fmap2 :: (forall a. f a -> g a) -> (forall a. t f a -> t f b)'
06:02:46 <Rosebud_> Digit is Char byw
06:02:49 <chrisdone> @hpaste
06:02:50 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
06:03:22 <Rosebud_> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=9697#a9697
06:03:49 <ski> example of such a functor could be some datastructure, that given an argument `f' representing an ordinary functor, or an `IORef', or something like that, then this new type "enhances" that type in some way
06:04:30 <ManateeLazyCat> @type (:)
06:04:31 <lambdabot> forall a. a -> [a] -> [a]
06:04:35 <ski> e.g. `newtype List ref a = MkL (ref (Cell ref a)); data Cell ref a = Nil | Cons a (List ref a)'
06:05:10 <jmcarthur> i've decided that (<*) is greatly underused. that is all
06:05:56 <ManateeLazyCat> Rosebud_: Best paste the error that ghc return, and with source code.
06:06:10 <ManateeLazyCat> Rosebud_: Your paste looks less helpful.
06:06:19 <Rosebud_> i dont use ghc
06:06:20 <Rosebud_> i use
06:06:21 <Rosebud_> hugs
06:06:22 <ski> `List Identity' is ordinary lists, `List IORef' is lists whose spine are mutable `IORef's, `List []' are actually a kind of tree .. if you will, a nondeterministic list, where each list node can actually contain as many cells as you like, they each of them continues the "list"
06:06:22 <Rosebud_> =//
06:06:27 <ManateeLazyCat> :)
06:06:31 <Rosebud_> ok ill paste it with some code
06:07:38 * ski notes dankna left the channel ..
06:07:47 <Rosebud_> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=9698#a9698
06:08:19 <ManateeLazyCat> chrisdone: mmorrow busy on it's own Haskell-Compiler, perhaps we can see mmorrow when he finish job. :)
06:08:42 <Rosebud_> i get the error on the third line =/
06:08:44 <Bynbo7> Rosebud_: you're one of a very small number of people who use hugs
06:08:47 <ski> Rosebud_ : that's not all of the relevant code
06:08:57 <ManateeLazyCat> Rosebud_: last line is wrong.
06:09:07 <jmcarthur> Bynbo7: some people are required to use hugs for their courses
06:09:12 <jmcarthur> :(
06:09:13 <Rosebud_> exactly
06:09:21 <Rosebud_> :(
06:09:21 <ski> (there is not provided subexpression `xs n', which the error is talking about)
06:09:30 <ski> so, what's the rest of the code ?
06:09:40 <ManateeLazyCat> Rosebud_: you should write "cR (x:xs) n = do something"
06:09:54 <ski> also, you need an equals sign, and an exr .. what ManateeLazyCat says :)
06:09:58 <Rosebud_> yee but ive got the guards underneath
06:10:02 <ManateeLazyCat> Rosebud_: Your function is un-complete.
06:10:22 <ski> ok, you need to tell the guards and the corresponding bodies then, too
06:10:24 <ManateeLazyCat> Rosebud_: Please paste complee code.
06:10:32 <Rosebud_> ok just a sec
06:10:35 <Rosebud_> ;
06:10:35 <Rosebud_> )
06:10:38 <ski> Rosebud_ : click the "modify" link and update
06:11:56 <ski> (and btw, if `xs' is a list, and `n' is a number, you're trying to apply the list as a function to the number
06:12:15 <Rosebud_> ok
06:12:18 <ski>  .. maybe you're missing brackets ?  .. or maybe you really wanted `xs !! n' (though that is usually not advicable))
06:12:20 <Rosebud_> update it
06:12:50 <ski> ok, so too much brackets :)
06:12:58 <ski> `cR(xs n)' should just be `cR xs n'
06:13:07 <ski> (in both places)
06:13:12 <ManateeLazyCat> Rosebud_: Should be "cR xs n" ?
06:13:21 <ski> no C-style application brackets in haskell
06:13:23 <ManateeLazyCat> Rosebud_: (xs n) is not list match [Char]
06:13:36 <Rosebud_> well why?? xs is the [Char]
06:13:43 <Rosebud_> is the rest of the list
06:13:59 <Rosebud_> which is a list .. =/
06:14:12 <ski> `cR(xs n)' says "call the function `xs' on argument `n', and then call the function `cR' on the result of that"
06:14:17 <ski> .. which is not what you want
06:14:28 <ManateeLazyCat> Rosebud_: Update that page.
06:14:39 <ski> `cR xs n' says "call the function `cR' on the argument `xs', and on the argument `n'"
06:14:45 <Rosebud_> already updaed it
06:15:13 <Rosebud_> `cR xs n' says "call the function `cR' on the argument `xs', and on the argument `n'" <--- this is what i want =/
06:15:20 <Rosebud_> xs is the rest of the list .
06:15:21 <ski> also, the brackets around the calls to `digitToInt' are needless
06:15:33 <ski> function application always binds tightest in expressions
06:15:39 <Rosebud_> hmm ok :)
06:15:43 <ski> Rosebud_ : yes, we know :)
06:15:47 <ManateeLazyCat> Rosebud_: Because you write "cR (xs n)", then compiler will consider (xs n) is list match [Char]
06:15:48 <ManateeLazyCat> Rosebud_: And right format should be (cR xs n)
06:16:13 <Rosebud_> aaaaaaaa got it ..
06:16:31 <Rosebud_> i was binding 2 values into 1 ! :O
06:16:58 <ski> btw, instead of testing  x == '0'  in a guard, you can pattern-match on the digit directly, which is nicer
06:17:12 <Rosebud_> ye ill change that as well
06:17:26 <Rosebud_> ;)
06:17:29 <ski> (at least, all things else being the same)
06:17:33 <ManateeLazyCat> Rosebud_: Works now?
06:17:35 <Rosebud_> yee
06:17:41 <Rosebud_> it was a syntax error GR
06:17:44 <Rosebud_> and another thing
06:17:45 <Rosebud_> ermm
06:17:46 <ManateeLazyCat> Rosebud_: BTW, use ghc instead hugs.
06:17:58 <Rosebud_> can i convert Char to String ??
06:18:08 <ski> > 'x' : []
06:18:09 <lambdabot>   "x"
06:18:15 <ski> > ['x']
06:18:16 <lambdabot>   "x"
06:18:18 <Axman6> > (\x -> [x]) 'a'
06:18:19 <lambdabot>   "a"
06:18:27 <ski> > let character = 'a' in [character]
06:18:28 <lambdabot>   "a"
06:18:29 <Axman6> > (:[]) 'a'
06:18:30 <lambdabot>   "a"
06:18:41 <Rosebud_> well i want to put x for example in a list of Chars?
06:18:43 <ManateeLazyCat> > let convertChar2String char = [char]
06:18:44 <lambdabot>   not an expression: `let convertChar2String char = [char]'
06:19:09 <ski> Rosebud_ : if you want to add `x' to the front of a list of chars, `ys', then say 'x:ys'
06:19:28 <ski> > let x = 'a'; ys = "bcd" in x : ys
06:19:28 <lambdabot>   "abcd"
06:19:37 <Rosebud_> i mean this: | bla bla bla  = [x] ++ cR(xs n)
06:19:44 <Rosebud_> which x is String
06:19:50 <Rosebud_> sry Char.
06:20:12 <ski> you still need to fix `cR(xs n)' into `cR xs n', there
06:20:18 <ManateeLazyCat> Rosebud_: Yes, [x] is String
06:20:28 <Rosebud_> a ok works.. ye i fixed it :)
06:20:33 <ski> doing that, then if `cR xs n' is a string, then `[x] ++ cR xs n' will also be a string
06:20:42 <ski> you can also write `x : cR xs n'
06:20:42 <ManateeLazyCat> Rosebud_: Just remember, String = [Char]
06:21:10 <Rosebud_> ok:) ive only done 3 weeks in hask so im pretty .. :p
06:21:16 <Rosebud_> ok thanks guyz:)
06:21:24 <ManateeLazyCat> You're welcome. :)
06:21:40 <Rosebud_> :) :D
06:22:34 * ManateeLazyCat Bye all. :)
06:24:21 <Rosebud_> btw ive got GHC but how do i load my *.hs on it?
06:24:36 <Axman6> use ghci
06:24:42 <Axman6> it's basically the same as hugs
06:25:16 <Rosebud_> this is what ive got... but im using winHugs and just open the file
06:25:22 <Rosebud_> there is no such thing in
06:25:25 <Rosebud_> GHCi
06:25:30 <Axman6> you'll need to do it from cmd
06:26:09 <Rosebud_> hmm lets say i find it from cmd how do i open it
06:26:11 <Rosebud_> gchi
06:26:15 <Rosebud_> its like a
06:26:18 <Rosebud_> termial
06:26:29 <Rosebud_> but the win commands wont work :O
06:26:34 <Axman6> ghci fild.hs
06:26:37 <Axman6> file*
06:26:56 <Rosebud_> aa ok :) thanks :p, dough makes sense :p
06:39:31 <interferon> does haskell' include any changes to record syntax?
06:39:40 <interferon> like r.x instead of (x r)
06:39:56 <Axman6> there is no haskell' anymore
06:40:05 <Axman6> we're having yearly language updates
06:41:40 <interferon> oh
06:41:42 <interferon> :)
06:41:49 <interferon> does Haskell 2010 include any changes to record syntax?
06:43:47 <monadic_kid> interferon: record update pattern
06:44:13 <Twey> monadic_kid: Link?
06:44:38 <monadic_kid> interferon: foo myRec@RecType { ... } = myRec { ... }
06:44:57 <monadic_kid> interferon: fill in "..."
06:45:05 <mauke> that doesn't look new
06:45:12 <monadic_kid> i never said it was
06:45:21 <interferon> no, that's not new
06:45:26 <mauke> <interferon> does Haskell 2010 include any changes to record syntax?
06:45:38 <monadic_kid> okay i'm not reading carefully
06:46:36 <Twey> Oh
06:46:41 <Twey> Thought you meant something new
06:48:40 <interferon> so...is it being updated?
07:08:15 <Rosebud_> im trying to split a string into a list of strings.. where the legth of each indivual list is 3. Any ideas how to do that ? :)
07:09:27 <chrisdone> > splitEvery 3 "hello dave"
07:09:28 <lambdabot>   Not in scope: `splitEvery'
07:09:34 <chrisdone> http://hackage.haskell.org/packages/archive/split/0.1.1/doc/html/Data-List-Split.html#v%3AsplitEvery
07:09:47 <chrisdone> > Data.List.Split.splitEvery 3 "hello dave"
07:09:48 <lambdabot>   Not in scope: `Data.List.Split.splitEvery'
07:09:53 <chrisdone> >:(
07:10:52 <Rosebud_> i was thinking.. doing that my self :)
07:11:14 <DrTeggy> iterate (take 3)
07:11:40 <Rosebud_> hmm
07:12:00 <chrisdone> Rosebud_: you want to implement it yourself?
07:12:10 <twink> unfoldr (\xs -> if not $ null xs then Just $ splitAt 3 xs else Nothing) ?
07:12:25 <Rosebud_> ye
07:12:42 <chrisdone> tonnes of ways to do it
07:12:44 <Rosebud_> to make a function that does that ..
07:12:52 <chrisdone> what have you tried?
07:13:04 <Rosebud_> in theory
07:13:09 <Rosebud_> ill go over the list
07:13:29 <twink> The unfoldr conveniently produces a finite output when given a finite input.
07:13:39 <Rosebud_> hvae a counter ... and when that is 3
07:13:39 <Twey> unfoldr $ join (Just . splitAt 3 ?? const Nothing) . not . null
07:13:50 <Rosebud_> ill take 3
07:14:12 <Rosebud_> but ill have to use an aux function to do that .. i think
07:15:16 <chrisdone> Twey: (Just . x ?? const Nothing) seems to be a common idiom
07:15:24 <twink> Where's (??) come from?
07:15:32 <chrisdone> Data.List.Higher
07:15:58 * twink doesn't have it hmm
07:16:33 <Twey> chrisdone: Yes
07:16:37 <Twey> Data.List now?
07:16:50 <chrisdone> oh, sorry
07:17:13 <chrisdone> probably Data.Bool.Higher
07:17:28 <chrisdone> twink: http://hackage.haskell.org/packages/archive/higherorder/0.0/doc/html/Data-Bool-Higher.html
07:55:36 <ManateeLazyCat> I have above code, I have use "forall e . EnvArg e =>" in Keymap declaration, but ghc said, I mismatch "e" with `PageArgs`, and `PageArgs` have instance `EnvArg`
07:55:37 * ManateeLazyCat pasted "my code." at http://paste2.org/get/768775
07:55:54 * ManateeLazyCat code at http://paste2.org/get/768775
07:58:27 <ManateeLazyCat> code "type Keymap = forall e . EnvArg e => Map Text (e -> IO ())" is wrong?
08:09:53 <portnov> byorgey: hi. How is your `diagrams'? I read that "The library is currently undergoing a major rewrite to use a more   flexible and elegant constraint-solving layout engine.". Is it alive? )
08:10:43 <Jafet> From what I've heard, it's newspeak for "we're porting it to different backends"
08:12:05 <portnov> oh. I.e. other than cairo%
08:12:06 <portnov> ?
08:12:13 <Jafet> Pretty much
08:12:26 <portnov> it's intresting too.
08:12:40 <ManateeLazyCat> @hackage diagrams
08:12:40 <lambdabot> http://hackage.haskell.org/package/diagrams
08:15:08 <portnov> i try to implement DSL for some type of diagrams (mostly like entity-relationship diagrams). Tried to use funcmp. It's good, but problems arise when logic and drawing are in different places (logic in haskell, drawing in metapost).
08:15:40 <portnov> for example, i cannot know sizes of text labels...
08:17:38 <drhodes> ManateeLazyCat: have you figured out your problem with http://paste2.org/get/768775? I don't know the solution, but I think I'm having the same issue
08:18:00 <ManateeLazyCat> drhodes: No, haven't any idea.
08:18:27 <ManateeLazyCat> drhodes: I want define a "class EnvArg a where"
08:19:09 <ManateeLazyCat> drhodes: Then in "type Keymap = forall e . EnvArg e => Map Text (e -> IO ())", i can call those "polymorphic function"
08:20:22 <ManateeLazyCat> drhodes: Example, PageArgs instance of EnArg "instance EnvArg PageArgs where", then every PageArgs function "(PageArgs -> IO ())" should match (e -> IO ()) in Keymap declaration.
08:20:51 <ManateeLazyCat> drhodes: But ghc told me mismatch.
08:21:09 <ManateeLazyCat> drhodes: Have any hint?
08:21:36 <drhodes> Sorry, no, still looking.
08:21:59 <ManateeLazyCat> drhodes: Perhaps need some secret trick that i don't know. :)
08:24:16 <ManateeLazyCat> drhodes: If http://paste2.org/get/768775 works, we will get "polymorphic functions" and not just "polymorphic type". :)
08:24:25 <portnov> @hackage chlor
08:24:25 <lambdabot> http://hackage.haskell.org/package/chlor
08:24:55 <ManateeLazyCat> drhodes: Perhaps ghc don't support it, perhaps my code somewhere is wrong.
08:25:36 <drhodes> ManateeLazyCat: have you tried something like: newEditor _ =  newTab PageEditor "/test/Download/Embedded.hs" <insert some explicity args>
08:26:30 <roconnor> @where TTFP
08:26:30 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
08:26:57 <ManateeLazyCat> drhodes: If you use "_", how to get "args"?
08:28:00 <drhodes> ManateeLazyCat: maybe args doesn't match some property of class EnvArg in some way
08:30:07 <ManateeLazyCat> drhodes: My idea is, don't care `args` is which type, if a type (such as PageArgs) instance of EnvArgs, then `execute` (in class EnvArg) will pick corresponding arguments from `Environment`.
08:31:57 <ManateeLazyCat> Then use those pick arguments build PageArgs for function "PageArgs -> IO ()"
08:32:47 <ManateeLazyCat> But now "forall a . EnvArg e => (e -> IO ())" don't match functin (PageArgs -> IO ())".
08:34:07 <ManateeLazyCat> is "forall e . EnvArg e => (e -> IO ())"
08:35:33 <drhodes> ManateeLazyCat: what's the type signature of newTab?
08:35:44 <ManateeLazyCat> newTab :: PageType -> PagePath -> PageArgs -> IO ()
08:44:10 <mreh> fromJust is an amazing hack
08:44:12 <mreh> use it all the time
08:44:33 <mreh> oh, old scrollback
08:44:55 <mreh> why has this person encapsulated the Either monad in an IO monad
08:44:57 <ManateeLazyCat> mreh: Don't use fromJust
08:45:05 <mreh> can't they just throw an exception?
08:45:08 <ManateeLazyCat> mreh: Use fromMaybe instead
08:45:22 <Twey> It's not that useful… I tend to end up using fromMaybe or else direct non-exhaustive pattern-matching instead
08:45:30 <mreh> fromJust = fromMaybe (err "I failed")
08:45:30 <drhodes> newEditor :: (EnvArg e) => e -> IO ()
08:45:33 <ManateeLazyCat> mreh: "fromJust Nothing" will got exception then crash your program
08:45:36 <drhodes> oops ^^ ManateeLazyCat
08:45:45 <Twey> mreh: Yeah
08:45:54 <drhodes> ManateeLazyCat: if that doesn't do anything usefull . I have no idea, sorry.
08:46:24 <mreh> is Either a monad?
08:46:31 <mreh> surely not
08:46:59 <Twey> Error e => Either e is
08:47:10 <Twey> In Control.Monad.Instances
08:47:19 <mreh> I'm not familiar with that class
08:47:24 <mreh> I'll check it out
08:52:24 <ManateeLazyCat> drhodes: I have some idea, paste code later. :)
08:52:46 <siracusa> How would I traverse all data constructors of a certain data type and get the number of parameters for each in TH?
08:53:23 <orlandu63> i have a bunch of packages that are broken according to ghc-pkg -- what would be the easiest way to reinstall all of these packages?
08:54:06 * ManateeLazyCat pasted "TH.hs" at http://paste2.org/get/768825
08:54:07 <ManateeLazyCat> siracusa: Looks above
08:54:31 <ManateeLazyCat> siracusa: Looks `packVariantList`
08:54:34 * hackagebot statistics-linreg 0.1 - Linear regression between two samples, based on the 'statistics' package  http://hackage.haskell.org/package/statistics-linreg-0.1 (AlpMestanogullari)
08:55:20 <whald> hello. i'm trying to get grasp on haskell by toying around with a raytracer (guess that's not that uncommon) :-)
08:55:21 <ManateeLazyCat> siracusa: In `packVariantList` declaration, (NormalC name fields) got constructor's type name and fields.
08:55:35 <ManateeLazyCat> siracusa: About number of parameter, just (length fields)
08:55:52 <siracusa> ManateeLazyCat: I see, reify is what I need, thanks!
08:56:00 <ManateeLazyCat> siracusa: `let packVarint` in `packVariantList` is function for scan every constructor.
08:56:32 <ManateeLazyCat> siracusa: Then you do `mapM (\x -> return $ packVarint x) constructors`, you will scan all constructors in data type.
08:56:40 <whald> things went pretty smooth until i decided to go stochastic; now i need random numbers; and google came up with some information and i think a somehow got it
08:57:05 <siracusa> ManateeLazyCat: Ok
08:57:31 <whald> but i'm currently stuck with converting an "[IO t]" into an "IO [t]"
08:57:36 <ManateeLazyCat> siracusa: Hold on, TH's syntax is alien, but very cool on some situation.
08:57:46 <whald> does that make any sense at all?
08:57:55 <alpounet> whald, sequence ?
08:57:57 <alpounet> @type sequence
08:57:58 <monadic_kid> whald: sequence
08:57:58 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
08:58:00 <whald> i'm confused...
08:58:06 <ManateeLazyCat> siracusa: Read this: http://www.haskell.org/bz/thdoc.htm
08:58:45 <whald> alpounet: thanks for the hint, i'll have a look into that
08:58:58 <ManateeLazyCat> siracusa: http://www.haskell.org/bz/thdoc.htm is *brilliant*
08:59:19 <ManateeLazyCat> siracusa: And this http://www.haskell.org/bz/th3.htm
09:00:02 <ManateeLazyCat> siracusa: You will understand TH completely after you read those two links.
09:00:34 <siracusa> ManateeLazyCat: Ok, thanks for the links
09:00:40 * ManateeLazyCat I'm confusion always until i read above two links.
09:00:50 <ManateeLazyCat> siracusa: I just understand TH yesterday. :)
09:01:21 <ManateeLazyCat> siracusa: Speical http://www.haskell.org/bz/thdoc.htm , it teach you step by step.
09:02:04 <monadic_kid> http://www.coyotos.org/pipermail/bitc-dev/2010-March/001809.html
09:02:24 <ManateeLazyCat> siracusa: You can use "runQ [| ... |]" debugging TH in ghci.
09:15:44 <mreh> I don't get it, I'm using a polymorphic type (define by a function definition) that contains the subset of classes required by another function, but the compiler doesn't like it
09:18:01 <siracusa> mreh: Can you paste it and the error?
09:52:56 <ManateeLazyCat> drhodes: Still there? I got it! :)
10:05:18 * ManateeLazyCat pasted "polymorphic function" at http://paste2.org/get/768910
10:05:19 <ManateeLazyCat> Above is my code that how build "polymorphic function"!
10:05:44 <ManateeLazyCat> mreggen: You can see http://paste2.org/p/768910
10:06:11 <ManateeLazyCat> @tell drhodes Looks http://paste2.org/get/768910 for "polymorphic function"
10:06:11 <lambdabot> Consider it noted.
10:08:50 <ManateeLazyCat> If you build "class EnvArg" and polymorphism function: "forall e . EnvArg => e -> IO ()", then you need some type wrap those polymorphism function, for http://paste2.org/get/768910 , i use "data Action = for e . EnvArg e => Action {actionFun :: e -> IO () }
10:09:33 <ManateeLazyCat> When you want pick those "polymorphism function", just use "(Action {actionFun = x}) -> execute env x"
10:09:39 <ManateeLazyCat> That's all, enjoy!
10:10:11 <ski> ManateeLazyCat : that `Action' type is what is usually called an "existential data type" (assuming s/for/forall/)
10:10:44 <ski> therefore, the `Action' data constructor there doesn't wrap a polymorphic function
10:11:13 <ski> that would be `data Action = Action {actionFun :: forall e. EnvArg e => e -> IO ()}'
10:16:03 <ManateeLazyCat> ski: Yes, but if you don't use Action contain polymorphism function, compiler won't pass.
10:16:04 <ManateeLazyCat> :)
10:18:05 <ManateeLazyCat> ski: BTW, `data Action = Action {actionFun :: forall e. EnvArg e => e -> IO ()}` is wrong in my case.
10:18:08 <kamatsu> i've written a little library using LHS
10:18:15 <kamatsu> should I also write haddock docs?
10:18:18 <kamatsu> what's the procedure here?
10:18:29 <Jafet> The usage should be clear from the types
10:18:54 <ski> ManateeLazyCat : i'm not sure what "if you don't use Action contain polymorphism function, compiler won't pass" means
10:19:04 <ManateeLazyCat> ski: If you use `data Action = Action {actionFun :: forall e. EnvArg e => e -> IO ()}`,
10:19:15 <ManateeLazyCat> `Couldn't match expected type `e' against inferred type `PageArgs' error.
10:19:33 <ski> where `instance EnvARgs PageArgs' ?
10:20:01 <ManateeLazyCat> ski: Yes, but if you write `forall` in Action, will got above error.
10:20:37 <ski> because a function of type `PageArgs -> IO ()' is not polymorphic (with type `forall e. EnvArg e => e -> IO ()')
10:20:47 <ski> which is not surprising
10:21:07 <ski> so, since you don't want this here, you don't want to store a polymorphic function
10:21:07 <ManateeLazyCat> Yes, that's why.
10:21:33 <ski> you just want to store any function `e -> IO ()', where `EnvArg e' holds
10:22:44 <monochrom> Oh, data Action = forall e. EnvArg e => Action { actionFun :: e -> IO () } ?
10:22:44 <ManateeLazyCat> ski: Yep, that's point.
10:22:55 <ManateeLazyCat> monochrom: Yep.
10:23:09 <ski> of course, that means that any function that takes `Action' as input, and matches on it, so that you get a function of type `e -> IO ()' where `EnvArg e', *itself* to be polymorphic in `e' (since it doesn't know what `e' is) .. it only knows that `EnvArg e'
10:23:12 <ManateeLazyCat> monochrom: Then i can build "type Keymap = Map Text Action"
10:23:30 <ski> s/to be/has to be/
10:23:34 <kamatsu> uh, haddock seems to crash
10:23:39 <kamatsu> this could be related to my recent ghc upgrade
10:23:44 <ManateeLazyCat> ski: Yes, you got it .:)
10:23:49 <kamatsu> haddock: internal Haddock or GHC error: de-package: openBinaryFile: does not exist (No such file or directory)
10:24:19 * ski got existential types a long time ago :) .. just checking that you've understood the consequences fully :)
10:25:02 <ManateeLazyCat> ski: You're deceived by ghc?
10:25:16 <monochrom> OTOH mine is unusable
10:25:43 <ski> ManateeLazyCat : what do you mean ? GHC using deception !?
10:26:49 <ManateeLazyCat> ski: In my first version http://paste2.org/get/768775
10:27:01 <ManateeLazyCat> ski: GHC told me `Couldn't match expected type `e' against inferred type `PageArgs'
10:27:30 <ManateeLazyCat> ski: I was think: "Oh, that's not key, ghc must be deceive me"
10:27:55 <seydar> hellllllOOOOOOOOOOO
10:28:42 <ManateeLazyCat> ski: So i use Action as "polymorphism functoin" wrap type, make ghc pass "type check", then pick up "polymorphism function" from Action.
10:29:23 <aavogt> ManateeLazyCat: well what happens if somebody adds another instance of EnvArg?
10:29:29 <ski> `Action' does *not* store a polymorphic function
10:29:42 <ManateeLazyCat> aavogt: As result, i got clean layout.
10:29:55 <seydar> so i have a random question
10:29:55 <ManateeLazyCat> aavogt: I can add any function in Keymap.
10:30:15 <ManateeLazyCat> aavogt: Just that polymorphism function instance from EnvArg
10:30:48 <seydar> I am applying for Ruby Summer of Code
10:30:49 <ManateeLazyCat> aavogt: That's mean, i don't care how number parameter of function in Keymap.
10:31:03 <ManateeLazyCat> ski: Yep, just wrap.
10:31:11 <ManateeLazyCat> ski: Not store.
10:31:18 <seydar> and I would appreciate it if someone could review my application. here it is: http://pastie.org/914297
10:31:25 <ManateeLazyCat> ski: I should be use *wrap* :)
10:31:57 <aavogt> seydar: is this going to be the best-informed channel for that?
10:32:25 <ManateeLazyCat> aavogt: You have better version than http://paste2.org/get/768910 ?
10:32:30 <seydar> aavogt: does it need to be? My goal is project funding. If you can read english and are familiar with programming, you are as qualified as they come
10:32:53 <aavogt> @nixon
10:32:53 <lambdabot> I don't want to see this country to go that way.  You know what happened to the Greeks.  Homosexuality destroyed them. Sure, Aristotle was a homo, we all know that, so was Socrates.
10:33:13 <monadic_kid> seydar: you realize this isn't a ruby chat room
10:33:19 <aavogt> is nixon responsible for enumerating all combinations of  known and unknown?
10:33:31 <seydar> monadic_kid: yes i do. I don't understand why that's relevant.
10:34:06 <seydar> monadic_kid: I just want you guys to review a project proposal because you are all smart and technologically oriented
10:34:10 <monadic_kid> seydar: it's relevant because it doesn't make much sense asking in here
10:34:16 <ManateeLazyCat> ski: Any improve for http://paste2.org/get/768910 ?
10:34:27 <seydar> monadic_kid: the fact that it's a ruby project is irrelevant
10:34:49 <monadic_kid> it's quite relevant, why not ask in a ruby room
10:34:53 <aavogt> I don't know if a proposal is supposed to be flattering and have much indirection
10:35:24 <aavogt> the question of style is better answered by the community which will be reviewing it
10:35:24 <seydar> monadic_kid: i did. the ruby channels are largely dead. i already got feedback there
10:35:44 <seydar> aavogt: can you elaborate your qualms with it?
10:36:17 <ManateeLazyCat> ski: `forall` have many tips i haven't found. :)
10:36:39 <aavogt> there are meaningless sentences like: "Obviously, there are two unknowns: the known-unknowns and the unknown-unknowns. Since I, by definition, don???t know about the unknown-unknowns, I will only talk about the known-unknowns.
10:37:02 <seydar> aavogt: ah. i seem to have a habit of doing that. thank you
10:37:18 <aavogt> but maybe some people like that
10:37:53 <aavogt> so perhaps it's bad advice to suggest that you remove it
10:39:04 <seydar> aavogt: no, this is exactly the kind of advice i was looking for. thank you!
10:40:12 * ManateeLazyCat pasted "TH code." at http://paste2.org/get/768941
10:40:12 <ManateeLazyCat> aavogt: I have above code, `$(packVariantList "packDaemonSignalArgs" ''DaemonSignalArgs)` is right, but `mkFunDec "packDaemonSignalArgs" (packVariantList_ ''DaemonSignalArgs)' can't pass.
10:40:32 <ManateeLazyCat> `Not in scope: `x[a6ui]' error
10:40:51 <ManateeLazyCat> aavogt: Something wrong with `packVariantList_` ?
10:41:01 <ManateeLazyCat> aavogt: Looks `newName` is right.
10:41:02 * hackagebot generators 1.0 - Actually useful monadic random value generators.  http://hackage.haskell.org/package/generators-1.0 (LiamOConnorDavis)
10:41:05 <aavogt> probably
10:42:04 <ManateeLazyCat> aavogt: Can you review `packVariantList_` thanks?
10:42:59 <aavogt> this is what you're doing:    case ... of Dat {} -> [toVariant x,toVariant y ... ]
10:43:09 <ManateeLazyCat> aavogt: Yep.
10:43:20 <aavogt> variables x y and so on are not magically in scope
10:43:30 <ManateeLazyCat> aavogt: `packVariantList` handle that, but need use $
10:44:01 <ManateeLazyCat> aavogt: I can't understand.
10:44:03 <aavogt> what do you mean by "need use $"
10:44:34 <ManateeLazyCat> aavogt: If i use `packVariantList` not `packVariantList_`, i need write `$(packVariantList "packDaemonSignalArgs" ''DaemonSignalArgs)`
10:44:41 <ManateeLazyCat> aavogt: But i want use your mkDec
10:45:18 <ManateeLazyCat> aavogt: Then i can make `mkDec` and `data declaration` in same file.
10:45:39 <aavogt> big deal, packVariantList already does the right thing
10:46:43 <aavogt> there is too much redundancy in that paste for me to understand
10:46:49 <ManateeLazyCat> aavogt: Your TH code looks more advanced.
10:47:17 <ManateeLazyCat> aavogt: When use `caseE` ?
10:47:39 <aavogt> no, it does the same, only it abstracts out some things into separate functions
10:47:45 <aavogt> @type caseE
10:47:46 <lambdabot> Not in scope: `caseE'
10:47:52 <aavogt> @type Language.Haskell.TH.caseE
10:47:53 <lambdabot> Language.Haskell.TH.Lib.ExpQ -> [Language.Haskell.TH.Lib.MatchQ] -> Language.Haskell.TH.Lib.ExpQ
10:48:05 * hackagebot generators 1.0.1 - Actually useful monadic random value generators.  http://hackage.haskell.org/package/generators-1.0.1 (LiamOConnorDavis)
10:48:18 <aavogt> it's when you want a    case 1stArgument of matches
10:49:18 <ManateeLazyCat> aavogt: So `caseE` in `packVariantList_` is unnecessary?
10:49:52 <aavogt> no because you actually want to bind some variables in the expression (recP d [])
10:49:57 <aavogt> rather than binding none
10:50:12 <ski> ManateeLazyCat : i don't see anything specific at <http://paste2.org/get/768910>  to improve
10:50:34 <ManateeLazyCat> ski: Thanks. :)
10:52:36 <kamatsu> i just wrote that generators module to scratch an itch and figured that other people will find it useful too
10:52:41 <kamatsu> it's very simple and quite powerful
10:56:00 <ManateeLazyCat> aavogt: In logic, `packVariantList_` should be right, but `Not in scope: `x[a6ui]' error looks i use wrong with `newName`, have any tips for `newName` ?
10:56:12 <aavogt> no, it's broken in logic
10:56:33 <aavogt> you're referring to unbound variables in the generated code
10:57:40 <ManateeLazyCat> aavogt: Detail?
10:57:59 <litb> hello folks
10:58:20 <aavogt> aavogt | this is what you're doing:    case ... of Dat {} -> [toVariant x,toVariant y ... ]
10:58:29 <ManateeLazyCat> aavogt: yes.
10:58:38 <aavogt> isn't it apparent that x, y and so on are not bound anywhere?
10:59:08 * ManateeLazyCat pasted "DBus code." at http://paste2.org/get/768952
10:59:13 <ManateeLazyCat> aavogt: Like above.
11:00:18 <ManateeLazyCat> aavogt: Oh, i got it.
11:00:25 <aavogt> well it's sort of by definition that this will not be accepted (due to a variable being out of scope):     $( do x <- newName "x"; varE x )
11:00:33 <aavogt> otherwise newName is broken
11:00:52 <aavogt> (if that expression would be accepted)
11:07:02 <ManateeLazyCat> aavogt: I know why now.
11:07:59 <ManateeLazyCat> aavogt: In "packVariantList`, i write "clause [conP name pats]" for build "[PatQ]"
11:08:43 <ManateeLazyCat> in `mkDec`: `funD (mkName str) [clause [] (normalB f) []]`, is `[]`.
11:09:19 <ManateeLazyCat> aavogt: So even i use `newName`, i'm not binding `PatQ` with Name, then i got unbound variable.
11:09:44 <ManateeLazyCat> aavogt: Is that?
11:10:21 <aavogt> of course. You have to generate valid haskell code
11:10:48 <aavogt> the AST can represent invalid code too
11:14:06 <ManateeLazyCat> aavogt: Thanks for your help. :)
11:19:14 * hackagebot generators 1.0.2 - Actually useful monadic random value generators.  http://hackage.haskell.org/package/generators-1.0.2 (LiamOConnorDavis)
11:20:01 * ManateeLazyCat I need go to bed, by all. :)
11:35:18 * hackagebot hashed-storage 0.4.11 - Hashed file storage support code.  http://hackage.haskell.org/package/hashed-storage-0.4.11 (EricKow)
11:37:44 <alpounet> what's best for quick&dirty plotting 2D points ?
11:37:50 <alpounet> +of
11:40:12 <alpounet> (and potentially some lines)
11:40:48 <dmwit> gnuplot?
11:42:43 <dancor> so TH can never splice actual functions?
11:42:45 <dancor> thFunc :: Int -> (String -> Int) -> Q Exp
11:42:45 <dancor> thFunc defA readA = [| maybe defA readA (Just "5") |]
11:43:17 <alpounet> hmm, yeah, thanks dmelani
11:43:19 <alpounet> dmwit*
11:44:29 <roconnor> alpounet: Haskell Charts!
11:45:07 <roconnor> s/s//
11:45:09 <roconnor> er
11:45:15 <roconnor> *Chart!
11:45:36 <alpounet> roconnor, okay, I'll try it.
11:48:55 <aavogt> dancor: unfortunately [| |] goes through the syntax
11:50:21 <aavogt> but you could ex. write     thFunc :: Int -> String -> ExpQ; thFunc defA readA = [| maybe defA $(dyn readA) (Just "5") |]
11:50:45 <aavogt> where readA is a string that names the function
11:51:50 <aavogt> this means that before you use   $(thFunc 1 "readA"), you need to have a variable readA in scope
11:51:54 <aavogt> with appropriate type
11:52:00 <dancor> right
11:52:27 <aavogt> the other option is to accept an Exp
11:53:07 <dancor> i could also just generate haskell with haskell
12:07:48 <hpaste> test  http://hpaste.org//fastcgi/hpaste.fcgi/view?id=24820
12:09:57 <chrisdone> k, looks good. can I let haste sit in here then?
12:10:25 <dmwit> I doubt anybody will complain.
12:10:33 <dmwit> The doubled slash is funny looking. =)
12:11:09 <chrisdone> don't worry about that, I'll clean that up and re-join it
12:11:30 <dmwit> Anyway, we used to have a bot for this (before hpaste2), so I think it's generally welcome.
12:11:34 <dmwit> Thanks for writing it!
12:13:00 <carnieri> > map (+1) [1..5]
12:13:00 <lambdabot>   [2,3,4,5,6]
12:13:53 <hpaste> test paste (chrisdone)  http://hpaste.org//fastcgi/hpaste.fcgi/view?id=24819
12:14:47 <alpounet> @type repeatM
12:14:48 <lambdabot> Not in scope: `repeatM'
12:14:54 <alpounet> @hoogle repeatM
12:14:54 <lambdabot> No results found
12:15:00 <chrisdone> not quite right, I'll test in #hpaste-test
12:15:33 <aavogt> alpounet: forever
12:15:43 <alpounet> oh
12:15:44 <alpounet> yeah
12:15:44 <alpounet> right
12:15:58 <aavogt> the naming is not terribly consistent
12:16:02 <brunodea> hey, is it too hard to implement an AVL tree in haskell?
12:16:07 <aavogt> mostly because there are a couple ways to look at it
12:17:09 <hpaste> a test paste (chrisdone)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24822
12:17:20 <dmwit> Nice!
12:17:47 <ddarius> brunodea: I've implemented an AVL tree in the type system.
12:18:11 <chrisdone> ah, I thought it was broken. it's working perfect
12:18:22 <ddarius> ly
12:20:05 <brunodea> ddarius: was it too hard?
12:20:14 * chrisdone waits
12:20:47 <aavogt> you could have implemented it already
12:21:15 <brunodea> i'm not that good in haskell, just started learning
12:21:23 <brunodea> some weaks ago
12:21:27 <brunodea> weeks
12:21:57 <benmachine> you know what would be a useful tool for developers? an option to make cabal build against the *oldest* libraries that satisfy the dependencies
12:22:16 <benmachine> so that you could work out if your constraints were correctly specified
12:22:25 <Polarina> benmachine, Hehe. :)
12:22:45 <Polarina> benmachine, but what if someone has their constraints set too high?
12:22:48 <aavogt> better would be a guess-my-dependencies mode
12:22:51 <benmachine> Polarina: you try both
12:23:03 <benmachine> aavogt: like a binary search or something?
12:23:26 <aavogt> yeah, or something smarter involving module interfaces
12:23:38 <Polarina> benmachine, guess-my-dependnecies would probably scan for imports, functions, check types, etc.
12:24:31 <benmachine> first you find the modules imported, then you ask ghc-pkg which packages they are in, then you search back in their past to see for how long they've been there like that...
12:25:01 <Polarina> Correct.
12:25:26 <benmachine> you might not even need those versions of the package installed, just a sort of API specification
12:26:08 <aavogt> well if the maintainer has to build his package 100 times with various versions, I don't think that would be too bad
12:26:14 <aavogt> so long as it's automated ;)
12:27:21 <dcoutts_> benmachine: yes, that would be useful, it's also quite doable. There's a place in the resolver where it applies the "latest" heuristic, it'd be simple enough to add a flag to prefer oldest versions instead
12:27:32 <dcoutts_> benmachine: feel free to file a feature request
12:27:54 <benmachine> would that be for Cabal or cabal-install?
12:29:30 <dcoutts_> benmachine: cabal-install
12:29:36 <dcoutts_> it has the dependency resolver
12:29:45 <hpaste> > "a test, ignore" -- (smr)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24823
12:29:46 <lambdabot>   "a test, ignore"
12:29:51 <stevenmarky> hoho!
12:29:56 <benmachine> ok, right
12:30:08 * chrisdone beams
12:30:21 <stevenmarky> gj.
12:30:52 <dmwit> Now, if lambdabot just had a command to submit something to hpaste, we could get a proper bot loop going on. ;-)
12:31:09 <chrisdone> dmwit: yeah, I liked how it used to do that. hpaste2 supports it but for some reason (apparently) it didn't work on the server it's currently on so it's disabled. I just got around it by making a feed out of hpaste and using rss2irc :)
12:31:17 <chrisdone> dmwit: haha
12:32:38 <benmachine> hmm I went to the hackage trac register form and firefox pre-fills the password field for me
12:32:43 * benmachine raises an eyebrow
12:32:54 <benmachine> (note register, not login)
12:33:09 <benmachine> unfortunately doesn't pre-fill the "confirm password" field :P
12:33:41 <dmhouse_> Oh my god. Literally nothing is more annoying than a flaky wireless driver.
12:34:25 <chrisdone> I think I'll patch rss2irc to pad the start of messages..
12:34:49 <benmachine> oh I do already have an account
12:34:53 * benmachine tries to remember the password
12:35:17 <dancor> aavogt: using Q Exp seems to work well in my case, thanks
12:35:55 * benmachine fails
12:35:57 <tensorpudding> Hmm, so Integer is almost a real mathematical integer
12:36:09 <tensorpudding> Is it possible to make an arbitrary-precision floating point?
12:36:14 <ddarius> Sure.
12:36:27 <dmwit> > pi :: CReal
12:36:28 <lambdabot>   3.1415926535897932384626433832795028841972
12:36:41 <Jafet> > showCReal 200 pi
12:36:42 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
12:36:45 <aavogt> you can't test for equality in general
12:36:50 <dmwit> Note that CReal can only represent the computable reals.
12:36:50 <tensorpudding> I thought that Double's were limited in precision.
12:36:56 <benmachine> they are
12:36:57 <Jafet> aavogt, sure you can, to arbitrary precision
12:37:10 <benmachine> but Doubles aren't the only way to represent noninteger values
12:37:16 <tensorpudding> Is CReal arbitrary-precision?
12:37:18 <dmwit> But I guess it would be a tough sell if you told me you had invented a representation for non-computable reals. =)
12:37:22 <dmwit> tensorpudding: yes
12:37:25 <tensorpudding> Okay.
12:37:26 <ddarius> tensorpudding: Not exactly.
12:37:39 <benmachine> I guess CReal might not be "floating-point" if you're being pedantic
12:37:51 <benmachine> actually I'm not sure
12:37:54 <dancor> the way it is now, implementing lazyShowFullCReal would be annoying
12:38:10 <dancor> you'd have to keep calling showCReal with higher digit counts
12:38:11 <tensorpudding> So it could represent uniquely any real number with a terminating decimal expansion.
12:38:47 <Jafet> benmachine, currently decimal floating point I think
12:39:01 <twink> Isn't there some spigot-ish radix conversion algorithm?
12:39:03 <benmachine> tensorpudding: Rational can do that too
12:39:18 <dancor> and Rational is a much more sane way to do that
12:39:20 <benmachine> trouble is that you can't square root rationals, or sin them
12:39:24 <Jafet> tensorpudding, pi has no terminating expansion, and CReal represents it fairly uniquely
12:39:38 <tensorpudding> Does it?
12:39:54 <benmachine> presumably as an algorithm to compute pi
12:39:58 <dancor> :t pi
12:39:59 <lambdabot> forall a. (Floating a) => a
12:40:22 <benmachine> (digits of)
12:40:22 <benmachine> which is possible to do
12:40:36 <tensorpudding> It can approximate pi to any precision you want, which I suppose is to say that you've got everything you can expect to get on a computer.
12:40:38 <Jafet> pi is 4*atan 1 I think, and atan derives an implicit power series from somewhere
12:40:41 <twink> Continued fractions are probably not a great way to do real numbers. I'm guessing if it came down to it an arbitrary-precision integer exponent and mantissa will do it.
12:40:48 <dancor> instance Floating CReal where
12:40:48 <dancor>   pi = 16 * atan (fromRational (1 % 5))
12:40:48 <dancor>                 - 4 * atan (fromRational (1 % 239))
12:41:30 <dancor> i wonder why that one was chosen
12:41:40 <aavogt> maybe it converges relatively quickly?
12:41:44 <tensorpudding> Continued fractions are nice though
12:41:51 <tensorpudding> For pi, it isn't helpful
12:42:13 <tensorpudding> but for e, it provides a fairly compact representation
12:42:33 <dancor> compactness of infinite sequences
12:42:43 <Jafet> dancor, Machin's well-known equation atan 1 == atan (1/5) - 4 atan (1/239)
12:42:49 <Jafet> And yes, plug that into the power series
12:42:54 <tensorpudding> Machin's equation is old though.
12:42:54 <dancor> lazy infinite bzip anyone?
12:43:22 <Jafet> It could be cooler and use one of the hypergeometric series
12:43:42 <Jafet> Or BPP, if it ever switches to binary floating point
12:54:36 <aavogt> hmm, do any of the record libraries allow updates for   data T a = T { field :: a }  to change the type variable a?
12:55:34 <aavogt> fclabels derives      set field :: a -> T a -> T a
12:56:01 <aavogt> more general would be     set field :: b -> T a -> T b
12:57:13 <tensorpudding> How would that know which field to set if there were more than one?
12:58:26 <aavogt> I mean that updates with haskell's builtin record syntax may be clunky, but they can let you change type variables
12:58:45 <aavogt> so      \a -> a { field = 1 } :: T a -> T Int
12:59:02 <aavogt> the equivalent with fclabels requires that a == Int
12:59:10 <aavogt> * ~
13:00:12 <aavogt> tensorpudding: by more than one, you mean    data T a = T { x,y :: a } ?
13:00:57 <tensorpudding> Yes
13:01:14 <tensorpudding> Though also, what if you have something like data T a = T { field :: IO a }
13:01:50 <aavogt> that IO case sounds reasonable
13:02:14 <tensorpudding> how would a function b -> T a -> T b work generically?
13:02:40 <aavogt> for multiple fields involving the same parameter, you can't really have  b -> T a -> T b
13:03:23 <aavogt> I mean you can with some generic programming, but that's not the point of named fields
13:32:20 <hpaste>  how to check a guess then output... (wolgo)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24825
13:32:38 <wolgo> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24825#a24825 - how can I check the guess then output the guesses submitted?
13:32:55 <wolgo> having problems figuring out how to pass the value around.
13:33:35 <dmwit> um
13:33:40 <dmwit> Is that the exact code you're using?
13:33:53 <dmwit> Because that first "playHangman" case sure seems like it would shadow all the others.
13:35:09 <Jafet> > hangman "han"
13:35:09 <lambdabot>   Not in scope: `hangman'
13:36:15 <dmwit> wolgo: ooookay
13:36:39 <dmwit> wolgo: Keep in mind that in Haskell, variables don't.
13:37:09 <dmwit> (:) is a function that takes an list and constructs a new one -- it doesn't modify the old one.
13:37:52 <dmwit> So "head guess : guesses" is a list that includes the player's guess, but is *not* a command to modify the list stored behind the name "guesses".
13:37:56 * hackagebot time 1.2.0.1 - A time library  http://hackage.haskell.org/package/time-1.2.0.1 (AshleyYakeley)
14:05:12 <benmachine> hackage's trac has started redirect looping me again :(
14:07:43 <avenge> :t id
14:07:44 <lambdabot> forall a. a -> a
14:08:39 <tensorpudding> @djinn a
14:08:40 <lambdabot> -- f cannot be realized.
14:13:46 <dmwit> ?djinn a -> a
14:13:46 <lambdabot> f a = a
14:13:48 <dmwit> ?src id
14:13:49 <lambdabot> id x = x
14:13:53 <dmwit> aww
14:13:59 <dmwit> ?djinn id :: x -> x
14:13:59 <lambdabot> Cannot parse command
14:14:06 <kmc> @. pl djinn a -> a
14:14:06 <lambdabot> f = id
14:14:25 <dancor> aavogt: this is what it was for http://github.com/dancor/rr/blob/HEAD/src/Opt.hs
14:15:24 <HugoDaniel> hi
14:16:01 <aavogt> dancor: but where is Data.PolyOpt?
14:17:38 <dancor> aavogt: http://github.com/dancor/polyopt
14:17:45 <mercury^> Twey: ok, you can unban me. It might actually become slightly interesting.
14:18:43 <aavogt> haskell98 dependency??
14:18:58 <Twey> mercury^: Maybe a little later
14:19:18 <mercury^> Then all the discussions will have ceased probably.
14:20:06 <kolmodin> Igloo: seems c.h.o needs some care
14:20:07 <aavogt> too bad the syntax highlighting doesn't like template haskell
14:20:08 <Ke> code.haskell.org down perhaps?
14:20:55 <dancor> aavogt: i've always put that in and never known why.. gone now
14:21:32 <wolgo> dmwit: oh okay thanks, I am learning. Sorry for not responding. Wife started bothering me.
14:21:41 <aavogt> I mean stuff like here: http://github.com/dancor/polyopt/blob/master/src/Data/PolyOpt.hs
14:22:34 <dancor> aavogt: ya it can't handle 'name
14:24:08 <aavogt> it's simple enough to only change the highlight if there's a ' within a couple chars
14:24:21 <RSchulz> Is there an op around?
14:24:37 <aavogt> almost certainly
14:24:58 <RSchulz> What's the protocol for getting their attention?
14:25:15 <aavogt> you can be annoying like:
14:25:15 <bremner> start spamming?
14:25:17 <aavogt> @where ops
14:25:17 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
14:25:19 <dancor> ha
14:25:29 <RSchulz> Ah. Dibblego.
14:25:30 <benmachine> that list is a little bit old I think
14:25:47 * wli is still around.
14:26:01 <dmwit> Hi, wli!
14:26:14 <RSchulz> Well, a guy by the nick of "tolkad" is over in #scala wondering if he could get un-banned here.
14:26:21 <dcoutts_> @slap aavogt for waking all the ops up
14:26:22 * lambdabot karate-chops aavogt for waking all the ops up into two equally sized halves
14:26:30 * wli mostly uses a less laggy connection.
14:26:32 <glguy> ?
14:26:39 * twink = wli
14:26:54 <mercury^> Twey: can you tell me more about that "complement"? Why is it distinguished from the nominative?
14:27:35 <glguy> Questions about bans can be discussed in #haskell-ops, this now not the correct channel fo r that
14:27:45 <RSchulz> Sorry. I'll pass it on.
14:28:18 * twink recommends finding whoever put the ban in place.
14:29:08 <mercury^> Twey: "she hopefully eats it" means that she certainly eats it in a hopeful state of mind.
14:30:07 <benmachine> it's supposed to mean that, but using it otherwise is common enough
14:30:29 <kmc> yes, everyone knows it's wrong and nobody cares
14:30:31 <aavogt> consider how common that interpretation would be as compared to the other one
14:31:35 <benmachine> kmc: most people don't care :)
14:31:42 <mercury^> Yes, but just before Twey argued that the complement (of which I had not heard before) should be gramatically equivalent to the nominative.
14:31:50 <dancor> no one uses the simple present that way anyway
14:31:58 <dancor> no one anyway uses..
14:33:44 <redocdam> dons?
14:37:47 <Philonous> Is there a way to daemonize a haskell program? System.Posix.Process.createSession fails with EPERM, and forkProcess p >> exitImmediately kills the haskell IO manager according to the documentation
14:39:04 <aavogt> @hackage hdaemonize
14:39:05 <lambdabot> http://hackage.haskell.org/package/hdaemonize
14:39:10 <aavogt> that one has worked for me
14:40:18 <Philonous> aavogt: And you where able to perform handle based IO in the newly created process?
14:40:24 <HugoDaniel> Philonous: i use the screen command
14:40:46 <HugoDaniel> http://www.gnu.org/software/screen/
14:41:15 <jmcarthur> that's not daemonizing!
14:41:20 <Philonous> HugoDaniel: That's not an option, sorry
14:41:28 <aavogt> Philonous: does a hdbc connection count?
14:41:52 <jmcarthur> i've only ever daemonized C programs, but i'm curious if there's a way to daemonize haskell programs reliably
14:41:54 <aavogt> somewhere that library does handle IO
14:42:06 <HugoDaniel> jmcarthur: screen command :P
14:42:16 <HugoDaniel> just compile it as you usually do, and screen it
14:42:19 <jmcarthur> HugoDaniel: i already said that's not daemonizing :P
14:42:30 <HugoDaniel> :)
14:42:37 <Philonous> aavogt: Ok. Because the ghc manual says "forkProcess comes with a giant warning: since any other running threads are not copied into the child process, it's easy to go wrong: e.g. by accessing some shared resource that was held by another thread in the parent.  Another example is the I/O manager thread: since the I/O manager isn't running in the child, attempting to do any Handle-based I/O will deadlock. "
14:43:14 <Philonous> Oh, and btw. why the double-fork?
14:43:32 <glguy> double fork hands the process off to init so that you don't have to wait for it
14:44:12 <aavogt> Philonous: right, I don't  openFile before passing stuff off
14:44:53 <benmachine> can't you just (./blah &) &
14:45:02 <benmachine> leave it to the shell
14:45:07 <benmachine> or exec blah, possibly
14:45:10 <HugoDaniel> :P
14:45:17 <HugoDaniel> or screen it...
14:45:25 <benmachine> yes but screen is overkill
14:45:26 <aavogt> daemonizing is a delicate procedure
14:45:42 <benmachine> why, what do you need to do?
14:45:46 <Philonous> benmachine: Actually, I can't.
14:46:13 <benmachine> oh
14:49:03 <Philonous> benmachine: Well, it's not in my hand. I'm working with a program that, when daemonizing, starts hogging CPU time and doesn't exit as it should, but when run in foreground it works well.
14:50:14 --- mode: ChanServ set +o mauke
14:50:14 --- mode: mauke set -b *!*@unaffiliated/tolkad
14:52:14 --- mode: mauke set -o mauke
14:59:17 <yuriks_> http://pastebin.com/7GF6SpEe
14:59:27 <yuriks_> what's the matter with this? I just can't get it to work
14:59:46 <yuriks_> I thought the return was only the last action in the do block, why is it worrying about the return from the readM?
14:59:58 <mauke> ew, color scheme
15:00:23 <monochrom> what a lame coloring
15:00:30 <mauke> yuriks_: missing argument to readM
15:00:54 <mauke> did you mean readLn?
15:01:14 <yuriks_> oh
15:01:21 <yuriks_> wow, what an non-intuitive message =P
15:01:47 <monochrom> I disagree passionately.
15:01:54 <mauke> it made sense to me
15:02:17 <mauke> you have readM, it expected some IO () value, but it got a function instead
15:02:24 <yuriks_> hmm, I guess
15:03:09 <yuriks_> I thought it was complaining that the "num <- readM" line wasn't matching the type of the block, not that the argument was wrong, though
15:03:46 <yuriks_> thanks, anyway
15:03:47 <mauke> what's the difference?
15:04:04 <chrisdone> can we replace the @where hpaste factoid with http://hpaste.org/ ? I'm not sure of the syntax
15:04:10 <mauke> num <- readM isn't matching the type of the block, which is in fact the problem
15:04:17 <mauke> @where hpaste
15:04:17 <lambdabot> http://hpaste.org/
15:04:21 <mauke> what
15:04:26 <chrisdone> ah, cool. last I saw it said moonpatio
15:04:30 <yuriks_> is hpaste up already?
15:04:43 <mauke> @where hpaste2
15:04:44 <lambdabot> http://hpaste.org/
15:04:46 <chrisdone> yeah
15:16:54 <yuriks_> how do I pattern match in an if?
15:17:04 <yuriks_> like, I want to know if something is nothing
15:17:12 <monochrom> can't. use an explicit case expression
15:17:15 <aavogt> if doesn't contain patterns
15:17:19 <yuriks_> hm, ok
15:17:31 <Jafet> :t if'
15:17:32 <lambdabot> Not in scope: `if''
15:17:38 <aavogt> @hoogle Maybe a -> Bool
15:17:38 <lambdabot> Data.Maybe isJust :: Maybe a -> Bool
15:17:38 <lambdabot> Data.Maybe isNothing :: Maybe a -> Bool
15:17:38 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
15:17:40 <yuriks_> I can have non exhaustive cases, right?
15:17:44 <tensorpudding> if evaluates the predicate, and it can only have type Bool, so pattern-matching on it would be kinda boring
15:17:51 <Jafet> Why is it in scope one week and not in another
15:18:20 <aavogt> @let if' a b c = if a then b else c
15:18:20 <dankna> Jafet: phase of the moon
15:18:21 <lambdabot>  Defined.
15:18:23 <tensorpudding> You *can* have non-exhaustive pattern matching, but it'll give you a warning.
15:18:23 <aavogt> :t if'
15:18:24 <lambdabot> forall t. Bool -> t -> t -> t
15:18:26 <dankna> Jafet: it'll be back in scope in three weeks
15:18:36 <Jafet> Good to know.
15:18:41 <yuriks_> hmm, it's probably not what I want anyway
15:19:22 * aavogt prescribes Functor Maybe
15:19:24 <dancor> it's just an implicit   _ -> error "non-exhaustive"   anyway
15:19:51 <tensorpudding> At the very least, if the pattern match you're excluding is being excluded because the input should, never, ever be in that state, maybe you should make it return a specific error to that effect instead of the default non-exhaustive error
15:20:07 <yuriks_> nah, it's in a do block
15:20:24 <aavogt> non-exhaustive matches are better than error because they give a source location
15:20:35 <yuriks_> wanted something like, { if (x is Nothing) { blah; } barf; }
15:20:43 <tensorpudding> More useful for debugging, maybe.
15:21:12 <aavogt> that's nicer than    error $( location >>= stringE . show )
15:21:27 <aavogt> but Loc seems to be missing a show instance
15:21:59 <tensorpudding> It doesn't explain to the person receiving the error why this pattern match failed.
15:22:15 <aavogt> right, they have the source code though
15:22:50 <tensorpudding> If you're going to have it "silently" do a non-exhaustive pattern match, there should be comment in the source why, so that someone who is debugging can figure it out.
15:23:07 <dancor> we've really run with this
15:23:21 <monochrom> For example a complete proof that the missing cases do not happen.
15:23:29 <aavogt> in terms of not actually answering the question?
15:23:52 <dancor> yuriks_: do you just want something like (if isNothing x then print "lol" else print "ok")?
15:23:54 <aavogt> it's hard to prove things involving typeclasses
15:24:14 <dancor> aavogt: how does that work out in like agda
15:24:18 <aavogt> since somebody could write an evil instance after the fact
15:24:33 <aavogt> dancor: I don't know
15:24:38 <tensorpudding> The function that is passing the values to the pattern match should have a test which explicitly determines if the function outputs the offending value.
15:24:46 * aavogt confuses dancor and dankna
15:24:55 <Twey> dancor: print $ maybe "lol" (const "ok") x
15:25:15 <alpounet> damn
15:25:19 <alpounet> code.haskell.org's down
15:25:20 <Saizan> in agda there aren't typeclasses, but you can still prove something about a general e.g. Monoid by using the laws
15:25:37 * dankna is confused with dancor by aavogt
15:25:38 <Saizan> since an instance needs to prove that they hold
15:25:50 * dancor refuses to use passive tense
15:26:07 <dancor> right
15:26:27 <Twey> Passive isn't a tense >.>
15:26:36 <dancor> Twey: surely we can refactor so that we aren't reusing 'o'..
15:26:57 <Twey> ‘o’?  Did you confuse me with someone?
15:27:00 <aavogt> you mean Twoy?
15:27:30 <Twey> Oh, I see.  Haha.
15:27:31 <dancor> @pl \ o -> print $ maybe ("l" ++ o ++ "l") (const $ o ++ "k") x
15:27:31 <lambdabot> print . flip (ap (maybe . ('l' :) . (++ "l")) (const . (++ "k"))) x
15:27:41 <Twey> Eww :þ
15:28:09 <yuriks_> dancor: no, something like (if isNothing then (do print "lol"; anotherIO) else (anotherIO))
15:28:19 <yuriks_> isNothing x*
15:28:26 <aavogt> see 'when'
15:28:39 <dancor> :t when
15:28:40 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
15:28:47 <aavogt>  do when (isNothing blah) $ print "lol"; anotherIO
15:29:04 <yuriks_> ah, thanks
15:29:19 <aavogt> do we really need the kind signatures here?
15:29:41 <Twey> aavogt: No, it's implicit
15:29:45 <BONUS> :t lift
15:29:45 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
15:29:51 <BONUS> ugh!
15:29:55 <Twey> Like the whole forall, in fact
15:30:07 <BONUS> since when are the kinds displayed
15:30:13 <aavogt> I mean whether \bot should have them disabled
15:30:23 <BONUS> yeah
15:30:48 <monochrom> lambdabot has displayed kinds for years
15:31:03 <dmwit> > 350 * 0.039296
15:31:04 <lambdabot>   13.753599999999999
15:31:15 <aavogt> :t 1
15:31:16 <lambdabot> forall t. (Num t) => t
15:31:23 <Saizan> -fglasgow-exts shows them
15:31:33 <Saizan> (for higher-kinded vars)
15:31:47 <edwardk> preflex: xseen tibbe
15:31:47 <preflex>  tibbe was last seen on freenode/#ghc 2 days, 7 hours, 32 minutes and 58 seconds ago, saying: JaffaCake: How about this: "1. I discovered the workaround more or less my accident while trying to solve a different problem. I only later understood the problem it actually solved."
15:31:54 <BONUS> really? did't it just used to quantify variables of type constructors without displaying their kinds?
15:32:16 <aavogt> the newest mueval lets you specify individual -XFlags
15:36:19 <yuriks_> what module is when in?
15:36:34 <aavogt> @ohogle when
15:36:34 <lambdabot> Maybe you meant: google hoogle
15:36:40 <aavogt> @hoogle when
15:36:40 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
15:39:11 <monadic_kid> literally finished porting all lessons now: http://github.com/snkkid/LazyFooHaskell
15:40:20 <Twey> monadic_kid: I don't think you're the first to do that…
15:41:34 <yuriks_> hmm, I CAN pattern match with <-, right? (on do blocks)
15:41:43 <dmwit> sure
15:41:59 <dmwit> If the pattern fails, it will call "fail" with an appropriate error message.
15:42:57 <monadic_kid> Twey: do you actually know anyone, since i've never seen any fully complete
15:46:23 <wavewave> Hi, I would like to use strict ST monad with forkIO.
15:46:55 <wavewave> two long strict ST monad calculation (i use STUArray)
15:47:11 <wavewave> later sum up the result from each monad.
15:47:26 <wavewave> parallelize them using forkIO..
15:47:58 <wavewave> but it just calculates both sequentially.
15:48:18 <dmwit> Are you running with +RTS -N2 or more?
15:48:24 <wavewave> Yes.
15:48:50 <wavewave> strict ST monad has no problem with it?
15:48:51 <dmwit> ?hpaste
15:48:51 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
15:49:27 <monadic_kid> wavewave: I can't see how you can do this without using MVar/STM when using forkIO
15:49:33 <FliPPeh_1> I think it's rather ugly to have to add a compiler pragma just to have instances of String and other lists!
15:49:48 <FliPPeh_1> And I think it's ugly that my nickname is changing wildly because of my internet provider!
15:49:50 <Twey> monadic_kid: Hm, no, but I've heard lots of people start it.  I did so myself at one point.
15:50:26 <monadic_kid> Twey: lots of people start and lots of people get stuck usually never finish
15:50:56 <dmwit> monadic_kid: Congratulations! That sounds like a lot of work.
15:51:41 * hackagebot hMollom 0.2 - Library to interact with the Mollom anti-spam service  http://hackage.haskell.org/package/hMollom-0.2 (AndyGeorges)
15:52:17 <monadic_kid> dmwit: thanks, i wouldn't say lots but I don't get much time to work on it because of work so it took a while
15:52:51 <wavewave> monadic_kid: I am using MVar..
15:53:01 <Twey> monadic_kid: Maybe so ☺  Nicely done, then.
15:55:13 <monadic_kid> thanks, I wanted to gain 2 things from it. Get lots of practice at Haskell and maybe help other people so
15:55:16 <dmwit> wavewave: It's probably impossible for us to help further without seeing some concrete code. That is why I suggested hpaste above. ;-)
15:55:31 <wavewave> my main is like this : http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=9728#a9728
15:55:50 <wavewave> dmwit: I know :) I am processing my source code.
15:56:16 <wavewave> myread is a long ST monad calculation...
15:56:55 <wavewave> It's rather a big code in total.
15:56:55 <dmwit> wavewave: result1 and result2 are likely being forced only in the "main" thread, not the two forked threads.
15:57:22 <dmwit> If you're confident that you've got the proper strictness on result1 and result2, then you can try
15:57:26 <dmwit> putMVar mvar2 $! result1
15:57:33 <wavewave> dmwit... aha..
15:57:40 <wavewave> let me try to do that...
15:58:20 <dmwit> wavewave: Also, as a stylistic thing, it's not that common to mix indentation with explicit {;} the way you're doing there...
15:58:23 <wavewave> great!
15:58:41 <wavewave> it is working! thanks a lot!
15:58:45 <aavogt> I'm afraid that I'm writing unreadable code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24832#a24832
15:58:46 <wavewave> I see.
15:59:16 <dmwit> wavewave: You can just drop all the {}'s and ;'s in your code and it should still work the same way. =)
15:59:20 <aavogt> can somebody confirm or deny?
15:59:57 <aavogt> yeah, you're already using layout correctly
16:00:02 <wavewave> dmwit: I changed as you suggested ;-) thanx.
16:00:18 <blackdog> aavogt: eesh. dude, use a function name once in a while:)
16:02:06 <hpaste>  can this make sense? (aavogt)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24832
16:02:38 <Saizan> aavogt: the [] as third argument to match is quite annoying
16:02:49 <dmwit> wavewave: I would also suggest taking a look at Control.Parallel.Strategies; you can specify pure computations to run in parallel with it without using IO.
16:03:55 <Saizan> aavogt: aside from that it makes sense
16:04:15 <aavogt> yeah, I've used a:     let guards x = [match wildP (guardedB x) []]
16:04:26 <wavewave> dmwit: Yes, in fact I am reading those. Currently, I just think the easiest way for me is using forkIO. Thanx.
16:04:42 <Craig`> ello
16:04:48 <dmwit> owdy
16:05:45 <hpaste>  xmoand.hs (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24833
16:05:47 <hpaste>  xmonad.errors (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24834
16:06:58 <alpounet> what extension do I need to have type level fixed points compile ?
16:08:02 <edwardk> alpounet: there isn't one
16:08:20 <edwardk> alpounet: you'd need to shut off the 'occurs check' which would basically shut off the type system ;)
16:08:24 <edwardk> since everything would unify
16:08:25 <Saizan> you mean those that get you an "infinite type" error?
16:09:01 <alpounet> edwardk, oh
16:09:03 <alpounet> I had a typo
16:09:27 <chrisdone> hmm what would a type leve fix point require
16:09:28 <edwardk> alpounet: if you ever really want it you can always make a newtype wrapper for your fixed point and plumb it through
16:09:29 <alpounet> works now
16:09:46 <alpounet> edwardk, that's not necessary
16:10:00 <edwardk> alpounet: i figured as much, just finishing the answer for sake of completeness ;)
16:10:03 <chrisdone> alpounet: can i see your yype level fix point?
16:10:04 <alpounet> I'm just playing around type level 'numbers' and type level fix
16:10:24 <alpounet> I got inspired from http://www.haskell.org/pipermail/haskell-cafe/2006-August/017142.html
16:11:00 <edwardk> alpounet: note they needlessly use data rather than newtype there
16:11:05 <alpounet> yeah
16:11:23 <RichardBarrell> newtype Mu a = Mu (a (Mu a)), right?
16:11:29 <edwardk> Richardyeah
16:11:38 <alpounet> yeah RichardBarrell
16:12:48 <lelf> ?src Mu
16:12:48 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
16:12:53 <hpaste>  type level numbers + fixed points (Alp)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24835
16:13:00 <alpounet> haha
16:13:06 <alpounet> got caught :x
16:13:08 <alpounet> chrisdone, ^^^
16:13:15 * chrisdone beams
16:13:16 <alpounet> yeah, we can replace by newtype
16:13:25 <edwardk> newtype Fix =)
16:13:35 <edwardk> otherwise i buy it
16:13:53 <chrisdone> Mu = satori
16:13:55 <dmwit> Is that a Unicode arrow there?
16:14:01 <edwardk> now the better version, write a version that uses base 2 rather than peano arithmetic
16:14:06 <jbapple> I didn't know newtypes could be recursive in that way
16:14:08 <RichardBarrell> This means that given (data Strict a = Strict !a), the only occupant of (Mu Strict) is ⊥, right?
16:14:48 <edwardk> jbapple: yeah the newtype is just playing the role of the isorecursive roll/unroll
16:15:04 <edwardk> Richard yeah
16:15:10 <RichardBarrell> dmwit → wants to be using emacs, M-x ucs-insert :)
16:15:38 <alpounet> dmwit, oh yeah, sorry, just pasted the code from my emacs
16:15:53 <lelf> dmwit: and ∷ ;)
16:16:04 <RichardBarrell> alpounet: out of curiosity, what input mode do you use?
16:16:36 <dmwit> I would call it a bug if emacs puts something different into the clipboard than what it puts into a file when you hit save.
16:16:49 <edwardk> jbapple: without the newtype you get an extra bottom in something like data ListF a b = Cons a b | Nil; type List a = Mu (ListF a) compared to using [a]
16:16:57 <edwardk> in each cons cell
16:17:24 <alpounet> edwardk, by the way
16:17:25 <RichardBarrell> dmwit: doesn't GHC happily parse unicode arrows and lambdas now, or is it merely that you can have unicode identifiers?
16:17:26 <jbapple> edwardk: ok, but . . .
16:17:41 <alpounet> I just replaced "data" by "newtype"
16:17:42 <dmwit> RichardBarrell: I think you may need to enable an extension.
16:17:54 <alpounet> but I'm pretty sure I mostly saw record-based definitions of Fix before
16:17:57 <alpounet> any particular reason ?
16:18:04 <edwardk> alpounet: record based being data?
16:18:10 <alpounet> non
16:18:10 <edwardk> alpounet: i always used newtypes
16:18:12 <alpounet> more like
16:18:22 <jbapple> jbapple: ok, I see
16:18:24 <alpounet> newtype Fix a = InF { outF :: a (Fix a) }
16:18:27 <RichardBarrell> Oh, you mean record syntax.
16:18:32 <jbapple> I mean: edwardk: ok, I see
16:19:33 <RichardBarrell> alpounet: that's exactly equivalent to newtype Fix a = InF (a (Fix a)), followed by outF :: Fix a -> Fix a, and outF (Fix a) = a
16:19:41 <edwardk> mostly so you have a 'psi' for an ananorphism that is build in as an accessor rather than written as a separate line outF :: Mu f -> f (Mu f)
16:19:43 <RichardBarrell> alpounet: it's just a syntactic sugar.
16:19:51 <alpounet> yeah RichardBarrell I know
16:20:01 <alpounet> but I'm asking why it's generally preferred ?
16:20:07 <alpounet> because of the accessor for free I guess ?
16:20:09 <edwardk> it has the advantage that you export Fix(..) and get outF with it
16:20:19 <edwardk> otherwise you have to export Fix(..) and outF separately
16:20:20 <RichardBarrell> Oh, I thought that you asked because you thought there might be some runtime different. Sorry.
16:20:26 <alpounet> yeah ok
16:20:41 <alpounet> np RichardBarrell
16:20:47 <edwardk> you might also have a very small chance of a runtime difference, in that the latter may not be spotted to be a simple unwrapping across module boundaries
16:21:12 <edwardk> and there is some support in ghc for dealing with field accessors specially during GC
16:21:41 <edwardk> in general if something is just a dumb field accessor i try to export it as such
16:22:05 <alpounet> ok
16:22:12 <alpounet> another question now
16:22:22 <edwardk> iirc wadler was the one who first found the accessor space leak issue, but i doubt if it applies to newtypes.
16:23:47 <alpounet> imagine I want to write a toNatural :: Integer -> Natural
16:24:17 <edwardk> http://homepages.inf.ed.ac.uk/wadler/topics/garbage-collection.html
16:24:18 <alpounet> is there a fix or iterate based approach here ?
16:25:19 <edwardk> toNatural 0 = Z; toNatural n = Succ (toNatural (n  - 1))
16:25:28 <aparent> Why are variables called variables in haskell if you can't change them?
16:25:44 <chrisdone> aparent: in f x = .., x varies depending on what you give it
16:25:46 <edwardk> aparent: they do vary, across instantiations of the function
16:26:22 <alpounet> edwardk, yeah I got this one. no alternative using fix ?
16:26:34 <edwardk> alpounet: you can always write that function using fix, but you don't win anything
16:26:38 <Taejo> aparent: "variable" had the Haskell-meaning in mathematics long before it took on the "assignable" meaning in imperative programming
16:26:45 <alpounet> edwardk, fix-fu ? =)
16:26:46 <edwardk> you can convert it to an anamorphism though
16:27:27 <aparent> Well then quality responses.  Troll failed.
16:27:29 <edwardk> define cata :: Functor f => (f a -> a) -> Fix f -> a -- then you can define evalNatural using cata
16:27:33 <FliPPeh> Realworldhaskell is uterly confusing...
16:27:39 <FliPPeh> -- ok: any number of fields and constructors
16:27:40 <FliPPeh> data TwoFields = TwoFields Int Int
16:27:46 <FliPPeh> -- bad: more than one field
16:27:46 <FliPPeh> newtype TooManyFields = Fields Int Int
16:27:48 <alpounet> ok thanks edwardk
16:27:51 <FliPPeh> What?
16:27:52 <chrisdone> go back to /prog/ where you belong!
16:27:59 <edwardk> and ana :: Functor f => (a -> f a) -> a -> Fix f -- and define your toNatural using that
16:28:31 <edwardk> FliPPeh: a newtype can only be used when you have a single argument.
16:28:32 <FliPPeh> Both have 2 fields
16:28:43 <FliPPeh> Oh, the first was a data...
16:28:44 <edwardk> FliPPeh: data can be used in a lot more cases.
16:29:09 <edwardk> newtypes are cheaper (free) at runtime
16:29:14 <FliPPeh> There was 6 newtypes and 1 data
16:29:14 <FliPPeh> Bad, bad, bad.
16:29:36 <edwardk> alpounet: you should also add Functor Nat
16:29:59 <alpounet> edwardk, yeah
16:30:00 <FliPPeh> I knew before than newtype can only be of one constructor with one argument, but that got me confused, because I thought it was "newtype" and not "data"
16:30:01 <edwardk> and then you can make the rather deep connection that Nat = Maybe
16:30:08 <alpounet> yeah
16:30:13 <alpounet> they're obviously isomorphic
16:30:44 <edwardk> *nods*
16:32:36 <edwardk> alpounet: and you can also try to swap out Fix for other interesting fixpoint-like constructions. Free and Cofree ;)
16:33:31 <edwardk> data Free f a = Return a | Free (f (Free f a)); data Cofree f a = Cofree a (f (Cofree f a)) -- both work like Mu/Fix in a lot of ways, but add an extra argument.
16:34:16 <alpounet> ok
16:34:44 <edwardk> Free can take any functor and give you a monad, Cofree can take any functor and give you a comonad.
16:34:54 <alpounet> yeah, I remember that
16:34:58 <edwardk> the definition of the monad for free is rather enlightening
16:35:26 <aavogt> can encoding this function be done more efficiently in TH: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24832#a24836 ?
16:35:37 <edwardk> (and in many ways speaks to the fact that monads are all about substitution and renormalization)
16:35:38 <aavogt> currently it tends to run out of memory
16:35:56 <aavogt> not the generated expression, but deriving the whole thing
16:36:10 <edwardk> aavogt: can you provide a bit more context as to what it means?
16:36:31 <aavogt> basically I have   [ (Version,Version, Exp -> Exp) ]
16:36:56 <aavogt> and I want to write a splice that  has type    Version -> Version -> (Exp -> Exp)
16:37:16 <aavogt> so out of the input list of possible AST transformations, I want to pick the range that apply
16:37:17 <edwardk> what does the list mean?
16:37:29 <aavogt> actually the list only contains one Version
16:37:40 <aavogt> the release version to which the transformation applies
16:37:57 <edwardk> so this is basically a way to try to automatically generate a way of converting between various versions of a syntax tree for instance?
16:38:02 <aavogt> yes
16:38:21 <Mathnerd314> @src filterM
16:38:22 <lambdabot> Source not found. Where did you learn to type?
16:38:33 <edwardk> the fact that you're overflowing seems to speak to the fact that your recursion lacks a base case of some sort
16:38:52 <edwardk> but beyond that i'm afraid the function is somewhat opaque to the uninitiated ;)
16:38:56 <aavogt> oh no. It does complete
16:39:04 <dmwit> edwardk: (Free fa) >>= f = Free (fmap (>>= f) fa) -- ?
16:39:15 <edwardk> dmwit: looks about right to me
16:39:19 <aavogt> only if I have lots of updates, ghc gets really slow
16:39:25 <edwardk> dmwit: congratulations, you now understand free monads
16:39:38 <dmwit> hm
16:39:44 * dmwit puts on his skeptical face
16:40:05 <edwardk> Return a >>= f = f a -- is just one of the monad laws
16:40:23 <dmwit> Yeah, the rest of the definition is pretty straightforward.
16:40:25 <aavogt> edwardk: so currently I write out all possible combinations of   (LowVersion, HighVersion, Exp -> Exp)
16:40:44 <edwardk> the other in the other case you have a functor wrapper around either an a or an f (Free f a) -- so you just need to recurse in and repeat the process, expanding it inside
16:40:58 <aavogt> selecting all subsequences from my  [(Version, Exp -> Exp)]
16:41:34 <aavogt> would it be helpful to group those common subexpressions manually?
16:41:46 <alpounet> ok I think I have cata and ana
16:41:49 <edwardk> dmwit: the effect is that you have a tree of Free (f ...)'s which have Return 'a's marking the leaves. you recurse through and expand the leaves.
16:42:05 <dmwit> I'm trying to think about what (Free f) is for different 'f's.
16:42:08 <dmwit> It's a little weird.
16:42:19 <dmwit> Free Id is a value annotated with a natural number...?
16:42:25 <aavogt> edwardk: the whole code is at  code.haskell.org/~aavogt/public_html/XMonadConfigUpdater
16:42:41 <dmwit> Which number gets ignored in the monad class functions.
16:42:41 <hpaste>  . (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24837
16:42:52 <edwardk> Free Id = Return a | Id (Return a) | Id (Id (Return a) | ... -- is a 'partial evaluation monad'
16:43:00 <aavogt> a revision that doesn't consider what the version of the old and new should be
16:43:11 * aavogt tries CSE
16:43:12 <edwardk> well, when Id is a data rather than a newtype it is anyways
16:43:31 <aavogt> edwardk: should I keep trying to explain?
16:43:43 <edwardk> aavogt: sorry. not sure i can add much value here =/
16:44:07 <aavogt> well thanks for the moral support ;)
16:44:19 <alpounet> oh I don't have cata and ana typechecking yet
16:44:26 <dmwit> I don't understand how Free Id relates to partial evaluation.
16:45:11 <edwardk> er sorry not "partial evaluation", "partiality" -- as in you can run the monad for a given number of steps and either get an answer or something you can keep running
16:45:39 <Saizan> with a non-newtype Id
16:45:58 <edwardk> data Part a = Part a; type Partial = Free Part; run :: Int -> Part a -> Either (Part a) a
16:46:00 <edwardk> Saizan: yeah
16:46:13 <edwardk> er
16:46:23 <edwardk> run :: Int -> Partial a -> Either (Partial a) a
16:47:46 <Sgeo_> Partial a?
16:48:18 <edwardk> run _ (Return a) = Right a; run 0 f = Left f; run n (Free (Part f)) = run (n - 1) f
16:49:26 <dmwit> Free Maybe a = Return a | Nothing | Just (Return a) | Just Nothing | Just (Just (Return a)) | Just (Just Nothing) | ...
16:49:30 <dmwit> hm
16:49:45 <dmwit> Free Maybe a = Partial (Maybe a), I guess
16:50:49 <edwardk> the neat thing about free is it works for any functor to make a monad. Free ((->)e), Free [], Free (Either a), Free Maybe, Free (Free Maybe), Free (Free (Free Maybe)), etc.
16:51:15 <dmwit> Okay, next up: Free ZipList
16:51:20 <edwardk> =)
16:52:52 <edwardk> dmwit: i wrote a brief post on free monads a long time ago: http://comonad.com/reader/2008/monads-for-free/
16:53:31 <stevenmarky> let a b = (1, 2) didn't do what I expected. Needs to be let (a, b). What's the purpose of allowing my initial syntax?
16:53:55 <Eelis> :t let a b = (1, 2) in a
16:53:56 <lambdabot> forall t t1 t2. (Num t2, Num t1) => t -> (t1, t2)
16:54:00 <edwardk> stevenmarky: your initial syntax defined a function named a that had an argument b that it ignored and returned the pair (1,2)
16:54:11 <edwardk> > let a b = (1,2) in a "Hello"
16:54:14 <lambdabot>   (1,2)
16:55:16 <dmwit> > let a b = (b, succ b) in a 1
16:55:16 <lambdabot>   (1,2)
16:55:17 <edwardk> = can do two things, it can be a 'destructuring assignment' or a function definition. you were looking for destructuring, but wrote out a function definition
16:55:39 <alpounet> edwardk, I guess I have to use fmap at some point in ana & cata
16:55:44 <edwardk> alpounet: yeah
16:56:14 <edwardk> alp: if you want http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Morphism-Cata.html can provide you a cheatsheet ;)
16:56:27 <alpounet> no no no
16:56:31 <alpounet> wanna do it by myself
16:56:32 <dmwit> ah!
16:56:32 <alpounet> I'm clos
16:56:33 <alpounet> +e
16:56:35 <stevenmarky> I see, thanks edwardk.
16:56:53 <edwardk> dmwit: it clicked?
16:57:00 <dmwit> edwardk: This sentence was the light bulb for me "(>>=) substitutes 'subtrees' for all of the naked variables".
16:57:09 <dmwit> I think you even said that earlier in here, but I hadn't gotten to the switch yet. =)
16:57:14 <edwardk> dmwit: yeah =)
16:57:27 <edwardk> dmwit: this is what people mean when they say that monads are about 'substitution'
16:57:41 <edwardk> dmwit: you substitute for the 'return' and then perhaps, normalize the tree
16:58:15 <edwardk> dmwit: this is why mathematicians prefer to define monads using fmap, return and join rather than return and (>>=)
16:58:40 <alpounet> ok
16:58:41 <alpounet> I got ana
16:58:54 <edwardk> alpounet, now write it out pointfree
16:59:02 <edwardk> alpounet: and you can probably guess cata from that
16:59:10 <alpounet> hmm
16:59:16 <alpounet> writing it pointfree is straightforward
16:59:30 <alpounet> ok done
16:59:32 <alpounet> ohhhh yeah
16:59:35 <edwardk> now, hylo
16:59:43 <dmwit> slave driver edwardk
17:00:03 <john343> ..........
17:00:05 <alpounet> haha
17:00:08 <edwardk> hylo :: Functor f => (f b -> b) -> (a -> f a) -> a -> b
17:00:20 <edwardk> you can generalize cata and ana to give hylo easily
17:00:22 <john343> i just joined this at random......
17:00:39 <john343> i typed in what i thought was a random word and the.............
17:00:42 <john343> >.<
17:00:54 <dmwit> john343: Welcome to #haskell! =)
17:01:02 <dmwit> john343: Can we interest you in a new programming language?
17:01:06 <dmwit> It's one of the most beautiful around.
17:01:07 <john343> sure?
17:01:14 <dmwit> ?where lyah
17:01:14 <lambdabot> http://www.learnyouahaskell.com/
17:01:23 <edwardk> alpounet: and then you can see how cata and ana are just special cases of hylo
17:01:25 <dmwit> ?where gentle
17:01:26 <lambdabot> http://www.haskell.org/tutorial/
17:01:37 <dmwit> ^^ My favorite, but mis-named by a long shot. =)
17:02:11 <edwardk> alpounet: any luck with hylo?
17:02:27 <tensorpudding> The gentle introduction is gentle depending on what your knowledge of programming is.
17:02:28 <alpounet> hmm
17:02:36 <alpounet> I think I'm not far
17:02:38 <john343> so what is this place?
17:02:49 <Eelis> that's what they've been trying to tell you ever since you joined
17:02:51 <edwardk> alpounet: what does your ana look like?
17:02:57 <azl> excuse me, can someone define what is hylo? (math noobie)
17:02:58 <cleanguy> a place to get help for haskell
17:03:08 <alpounet> edwardk, ana f = Fix . fmap (ana f) . f
17:03:11 <edwardk> john343: this is a channel devoted to talking about the programming language Haskell
17:03:17 <john343> well i got that
17:03:18 <tensorpudding> john343: This is the official IRC channel for Haskell, a lazy pure functional programming language
17:03:21 <alpounet> and I got hylo
17:03:22 <edwardk> alpounet: and your cata?
17:03:24 <john343> but only that?
17:03:27 <edwardk> alpounet: nice =)
17:03:30 <edwardk> john343: yeah
17:03:34 <tensorpudding> Well, we talk about a lot of things related to Haskell.
17:03:39 <edwardk> john343: there are er.. just a few of us interested in it ;)
17:03:39 <alpounet> edwardk, cata unF = unF . fmap (cata unF) . outFix
17:03:45 <cleanguy> does anyone here also program Clean ?
17:03:53 <tensorpudding> Like category theory
17:04:02 <aavogt> sorry, haskell is dirty
17:04:03 <alpounet> outFix is the field in Fix's record
17:04:03 <edwardk> cleanguy: i've written clean, but i always feel dirty when i do so ;)
17:04:03 <Eelis> cleanguy: they made me do it at school :(
17:04:19 <john343> how many people are in here?
17:04:31 <dmwit> john343: Surely your IRC client can tell you that.
17:04:32 <edwardk> alpounet: and hylo just gets rid of the use of your fix point
17:04:41 <alpounet> yeah
17:04:42 <cleanguy> well I'm having problems with clean that I don't have in Haskell, and I really wanted to understand why
17:04:43 <john343> im that lazy
17:04:44 <cleanguy> it's very simple
17:05:24 <blackh> john343: 653 people in the room - are you a programmer?
17:05:30 <edwardk> cleanguy: a lot of it comes down to the fact that their type system lacks a lot of the simplicity of haskell's. the way they handle uniqueness sometimes bites them in the ass.
17:05:35 <john343> tried it once or twice
17:05:59 <cleanguy> edwardk: uniqueness is very interesting in that it makes a simple hello world program be 5 lines!
17:06:03 <edwardk> cleanguy: especially w.r.t partial application, polymorphic recursion,e tc.
17:06:07 <edwardk> cleanguy: yeah
17:06:10 <cleanguy> edwardk: here's my little problem:
17:06:31 <cleanguy> edwardk: in haskell if I write: map (++"_") ["a", "b"] I get  "a_", "b_" , which is what I'd expect
17:06:40 <edwardk> alpounet: congratulations btw, you are actually 3/4 of the way through 'bananas, lenses and barbed wire' ;)
17:06:45 <cleanguy> edwardk: in clean however i get "_a", "_b"
17:06:48 <alpounet> nice heh
17:06:51 <cleanguy> edwardk: and it pisses me off
17:07:05 <dmwit> What, aren't all monoids commutative? ;-)
17:07:18 <alpounet> edwardk, now i'm trying to write evalNatural :: Natural -> Int  with cata
17:07:25 <blackh> john343: Haskell is very different to other programming languages, and really amazing because of it, so it's good to learn it if you are new to programming, because then you don't have to unlearn anything.
17:07:27 <azl> cleanguy: (flip ++) "_" ???
17:07:27 <edwardk> alpounet: good call
17:07:35 <cleanguy> edwardk: plus I have to actually write it like so: map ((+++)"_") ["a","b"]
17:07:43 <john343> ahhh thats cool
17:07:49 <cleanguy> azl: in this example I'm trying to add an underscore to the end of every string
17:07:58 <dmwit> cleanguy: Well, to be fair, that gives the same as the analog in Haskell:
17:08:00 <blackdog> blackh: of course, it means you'll bitch like hell when you learn other langs:)
17:08:01 <edwardk> cleanguy: well, by writing (+++)"_" you make "_" the first rather than the second argument to tyhe fucntion
17:08:05 <dmwit> > map ((++)"_") ["a", "b"]
17:08:07 <lambdabot>   ["_a","_b"]
17:08:16 <dmwit> cleanguy: ...what edwardk said =)
17:08:30 <cleanguy> edwardk: but clean won't let me to map (+++"\n") ["a","b"]
17:08:34 <john343> OH ****
17:08:37 <cleanguy> edwardk: it says it's missing the first arg
17:08:40 <edwardk> cleanguy: you'll find that sectioning and partial application isn't as well developed as in haskell
17:08:50 <azl> map ((flip ++)"_") ["a", "b"]
17:08:50 <edwardk> cleanguy: write it with a full lambda
17:08:51 <dmwit> > map (\x -> (++) x "_") ["a", "b"] -- cleanguy, is there a lambda available?
17:08:52 <lambdabot>   ["a_","b_"]
17:08:56 <cleanguy> dwyes i know he is right, i understand that compeltely, but clean doesnt give me another option
17:09:03 <edwardk> cleanguy: (\x -> x +++ "\n")
17:09:20 <cleanguy> dmwit: yes I can make it work like this: map (\x = x+++"_") ["a","b"]
17:09:31 <dmwit> Right, do that, then.
17:09:34 <cleanguy> edwardk: but lambda shouldnt be necessary
17:09:37 <edwardk> cleanguy: sadly, clean is not haskell ;)
17:09:45 <cleanguy> edwardk: haha i hear you
17:09:48 <dmwit> cleanguy: Even in Haskell, sections are just sugar for a lambda.
17:10:00 <cleanguy> dmwit: well clean is lacking some serious sugar then
17:10:08 <cleanguy> dmwit: i wanted to do +++"\n"
17:10:11 * dmwit pats cleanguy
17:10:15 <cleanguy> there's nothing mystical about it
17:10:15 <edwardk> cleanguy: you'll find out quite how much as you go ;)
17:10:19 <tensorpudding> Is Clean still updated?
17:10:26 <tensorpudding> Last I checked, their website suggested otherwise.
17:10:29 <cleanguy> tensorpudding: i'd hope so
17:10:30 <alpounet> i'm almost there
17:10:31 <edwardk> cleanguy: eventually you'll slink back to haskell ;)
17:10:32 <alpounet> yay
17:10:42 <edwardk> alpounet: not so bad?
17:10:45 <cleanguy> edwardk: but clean is so nice with its guy and native bindings to gui
17:10:55 <alpounet> a bit confused, but getting over it ;)
17:10:58 <cleanguy> edwardk: haskell is too unix-oriented for my taste
17:11:11 <edwardk> alpounet: now, you can define the other toNatural as an anamorphism
17:11:13 <tensorpudding> Doesn't Clean only run on Windows?
17:11:18 <alpounet> yeah
17:11:22 <tensorpudding> I remember wanting to try it and being turned away by that.
17:11:27 <cleanguy> tensorpudding: no, there';s versions for linux too
17:11:32 <edwardk> though, to be anal retentive technically, you have an implementation of the 'conaturals' rather than the naturals
17:11:38 <edwardk> because you have an extra element
17:11:44 <dmwit> azl: In case nobody answered, http://en.wikipedia.org/wiki/Hylomorphism_(computer_science)
17:12:01 <edwardk> infinity = Fix (Succ (infinity))
17:12:15 <c_wraith> is there such a thing as a hyrulemorphism?
17:12:15 <cleanguy> edwardk: how do you do windows gui easily with haskell?
17:12:25 <cleanguy> edwardk: clean has such nice support for windows gui
17:12:28 <edwardk> cleanguy: gtkhs
17:12:37 <cleanguy> edwardk: but gtk is not windows native gui
17:12:37 <alpounet> there even is a binding of the Win32 API
17:12:50 <edwardk> cleanguy: well, i don't think anyone has bothered writing a nice windows api wrapper
17:12:52 <tensorpudding> I thought there was support for windows forms in a library
17:13:09 <alpounet> @hackage Win32
17:13:09 <lambdabot> http://hackage.haskell.org/package/Win32
17:13:10 <alpounet> iirc.
17:13:16 <edwardk> c_wraith: sadly no ;)
17:13:20 <alpounet> yeah.
17:13:22 <cleanguy> edwardk: i understand that people prefer unix and whatnot, but a language can't just ignore the most popular OS around
17:13:30 <alpounet> cleanguy, ^^^
17:13:30 <azl> dmwit: oh i see :)
17:13:40 <dmwit> cleanguy: wxHaskell?
17:13:42 <cleanguy> alpounet: i'll check it out now, cthanks
17:13:49 <edwardk> cleanguy: it just happens that haskell has had a largely linux-centric culture despite being built largely by microsoft research
17:13:56 <tensorpudding> While they're at it, they should make some Cocoa bindings too
17:13:57 <alex404> So I had a sendline function which opened a handle within itself (so this open handle woudl be called every sendline), but then changed it so that it took a handle as an argument. Does this speed things up?
17:13:58 <cleanguy> dmwit: but wx is yet another linux gui right? not windows native
17:14:04 <dmwit> cleanguy: There's also Qt bindings, OpenGL bindings, and Gtk+ bindings.
17:14:14 <dmwit> cleanguy: wx binds to native widgets whenever they're available.
17:14:24 <cleanguy> dmwit: orly?
17:14:27 <ddarius> edwardk: Have I pointed you at Jason Reeds work embedding substructural logics into intuitionistic logic?
17:14:29 <cleanguy> dmwit: that i never knew
17:14:42 <edwardk> cleanguy: there is http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Win32
17:14:50 <edwardk> ddarius: i don't think so
17:14:57 <yuriks_> Expected kind `*', but `t' has kind `* -> *'
17:15:01 <yuriks_> what does this error mean?
17:15:02 <cleanguy> dmwit: and what do you guys user as a programming ide for haskell? using notepad++ makes it look unprofessional
17:15:04 <dmwit> cleanguy: Well, it's in the first five sentences on the wxWidgets website...
17:15:05 <cleanguy> edwardk: thanks
17:15:14 <dmwit> gvim =)
17:15:15 <yuriks_> I'm having trouble with stuff all the time where it shows up but I don't really know what it mean
17:15:17 <edwardk> yuriks_: you had one too many or too few type arguments
17:15:18 <yuriks_> means*
17:15:22 <aavogt> it means you're passing a type constructor when it's expecting a type, yuriks_
17:15:30 <azl> dmwit: i (personally) like wx. win32 and qt libraries are pourly documented.
17:15:33 <cleanguy> dmwit: ugh
17:15:35 <edwardk> yuriks_: "Maybe" has kind * -> *, "Maybe Int" has kind *
17:15:37 <aavogt> > 1 :: Maybe
17:15:39 <lambdabot>   `Data.Maybe.Maybe' is not applied to enough type arguments
17:15:39 <lambdabot>  Expected kind `...
17:15:46 <aavogt> > Just
17:15:47 <lambdabot>   {()->Just ()}
17:15:48 <cleanguy> dmwit: anything nicer?
17:15:51 <stevenmarky> on windows I was also using notepad++ with nppExec macros to compile/execute
17:16:05 <dmwit> cleanguy: Hard to say, when your most eloquent complaint is "ugh".
17:16:27 <cleanguy> dmwit: somethign less unix-centric
17:16:28 <dmwit> I wouldn't use it if I didn't find it quite nice, so you'll have to tell me what you're wishing for.
17:16:40 <cleanguy> dmwit: something more like visual studio ;)
17:16:45 <ddarius> edwardk: http://www.cs.cmu.edu/~fp/papers/substruct10.pdf http://www.cs.cmu.edu/~jcreed/  That first paper isn't available on his page but is listed on Frank Pfenning's page.
17:16:45 <Twey> cleanguy: emacs
17:16:49 <cleanguy> dmwit: no need for all the ammenities though
17:16:52 <azl> cleanguy:  using vim, others use emacs. on windows i still use the same ;)
17:16:53 <edwardk> cleanguy: the link i gave above is direct support for low level win32 machinery
17:17:08 <dmwit> cleanguy: gvim, plus :set compatible=windows ...?
17:17:11 <hpaste>  . (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24838
17:17:12 <edwardk> ddarius: bookmarked
17:17:14 <cleanguy> Twey: i dont want to have to learn something that hard. emacs is a whole world to learn
17:17:28 <Twey> cleanguy: Depends how much you want to use
17:17:30 <edwardk> ddarius: i'll be on vacation this week, i'll see if i can drag a copy along with me for the flight
17:17:31 <cleanguy> edwardk: probably what i was looking for , thx
17:17:35 <Twey> You can pretend it's Notepad if you want ;)
17:17:55 <cleanguy> Twey: emacs is more for people that want to get the most out of their text editor
17:18:05 <dmwit> I guess it's considered kosher to mention leksah and yi at this point, as well.
17:18:06 <cleanguy> Twey: i really need a LOT less than what emacs offers
17:18:14 <Twey> cleanguy: So use Notepad
17:18:14 <edwardk> ddarius: currently reading the dissertation of another of pfenning's students. himanshu jain.
17:18:22 <Twey> cleanguy: Or vi ;)
17:18:33 <azl> cleanguy: emacs or vim - are bests, I like vim.
17:18:59 <cleanguy> it's a real shame that haskell doesnt have even a simple ide for itself like clean has
17:19:09 <cleanguy> it makes everything so much more complicated
17:19:09 <ddarius> edwardk: Frank Pfenning is a good source for interesting work.
17:19:21 <edwardk> hrmm. i wonder if there is a notion of a 'linear SAT solver' ;)
17:19:25 <dmwit> cleanguy: Have you looked at all of gvim, emacs, leksah, and yi before you made that claim?
17:19:35 <Twey> cleanguy: We prefer not to reinvent the wheel
17:19:39 <azl> cleanguy: there's lot of languages that doesn't have it too.
17:19:46 <Twey> On the whole.
17:19:54 <bremner> language specific ide = ghetto
17:20:05 <Twey> I'm inclined to agree.
17:20:14 <azl> bremner: +1
17:20:15 <cleanguy> dmwit: so which of those all is the best for use in windows? the best not being the one with most features, but the one LESS in the way of programming
17:20:28 * dmwit feels as though he is being skillfully trolled
17:20:35 <Twey> cleanguy: If you want less, use Notepad.  If you want more, use emacs.
17:20:44 <ddarius> Twey: s/LESS/least
17:20:48 <edwardk> alpounet: you get the anamorphism?
17:20:54 <cleanguy> Twey: that's like choosing between a grain of salt and a mountain
17:20:56 <Twey> If you don't know what you want, go away and figure it out, and come back when you do.
17:21:03 * ddarius started using vim in Windows.
17:21:10 <cleanguy> ddarius: true, my fault
17:21:20 <tensorpudding> If you're on Windows, there are several different native editors, along with ports of gvim and emacs
17:21:20 <Twey> Like I said, emacs is only as complicated as you want it to be.  You can pretend it's Notepad if that's what floats your boat.
17:21:40 <edwardk> just be careful not to use notepad on a utf8 encoded file or you will get a BOM and not know why stuff doesn't run on linux after
17:21:43 <cleanguy> Twey: the problem is that TextEditor != IDE
17:21:51 <Twey> cleanguy: How so?
17:21:59 <cleanguy> Twey: come on now
17:22:03 <azl> Twey: for me, it became too hard to configure... i'm lazy
17:22:11 <cleanguy> Twey: i don't need to explain that
17:22:17 <azl> Twey: i mean emacs
17:22:26 <edwardk> cleanguy: if you _really_ need an IDE on windowd for haskell there are a couple of versions of VisualHaskell
17:22:28 <Twey> cleanguy: Well, I don't know of any ‘IDE’ feature that emacs doesn't provide.
17:22:31 <edwardk> but they work with old versions of ghc
17:22:41 <Twey> cleanguy: So I'm wondering where you draw the line.
17:22:50 <tensorpudding> Notepad++ is kinda sorta popular with Windows people.
17:22:51 <cleanguy> edwardk: lemme do a search on that VisualHaskell thingy
17:23:12 <Sgeo_> I use Notepad++, but it's indentation isn't particularly smart
17:23:15 <edwardk> cleanguy: it is hard to argue that emacs isn't an ide, but most of the others mentioned i agree don't qualify ;)
17:23:17 <cleanguy> Twey: emacs in an editor with ide features. it's a hybrid. it does too much. an ide is just an ide, not meant for other things
17:23:21 <Sgeo_> I might try Leksah at some point
17:23:32 <Twey> cleanguy: So an IDE is not an editor?
17:23:49 <Sgeo_> s/it's/its
17:23:52 <cleanguy> Twey: ide is an editor just for one language
17:24:02 <tensorpudding> So Eclipse isn't an IDE?
17:24:02 <Twey> cleanguy: So Visual Studio is not an IDE?
17:24:04 <Sgeo_> cleanguy, so what's Visual Studio?
17:24:07 <cleanguy> Twey: not for everything including plain text
17:24:18 <edwardk> Twey: but by that token eclipse or visual studio aren't IDEs because they support multiple languages ;)
17:24:24 <edwardk> er s/Twey/cleanguy
17:24:28 <cleanguy> Sgeo_: an ide for c# and f# and vb, but not for things like plain text or HTML or whatever you're in the mood for
17:24:40 <Twey> cleanguy: You haven't used it much, have you?  :þ
17:24:48 * dmwit now feels as though all of #haskell is being skillfully trolled
17:24:48 <cleanguy> Twey: havent used what much?>
17:24:50 <edwardk> cleanguy: visual studio includes editors for those ;)
17:24:54 <Twey> cleanguy: It does do HTML, plain text, and many other things.
17:25:00 <Saizan> dmwit: i wish that's correct :)
17:25:04 <alpounet> edwardk, hum I need some time to figure things out a bit here
17:25:07 <Twey> dmwit: Heh
17:25:08 * edwardk stops feeding what has become from a POSIWID perspective, an effective troll ;)
17:25:09 <cleanguy> Twey: no it really doesnt
17:25:20 <Sgeo_> I think cleanguy wants his IDE to have nice GUI stuff to compile several files together, or something
17:25:33 <edwardk> alpounet: whats got you stuck?
17:25:34 <joed> And indent and suggest code.
17:25:36 <Twey> emacs has that, though we generally prefer makefiles.
17:25:41 <Twey> emacs does that.
17:25:47 <cleanguy> Sgeo_: yes thank you
17:25:49 <Sgeo_> Twey, any nice GUI for it?
17:25:51 * joed knows that.
17:25:54 <cleanguy> joed: yes!
17:25:57 <tensorpudding> Build systems are language-specific.
17:25:57 <Twey> Sgeo_: Of course.  By default.
17:26:00 <edwardk> cleanguy: actually yes, visual studio does. ;)
17:26:01 <joed> cleanguy: Emacs does that.
17:26:07 <tensorpudding> You're not going to use make for everything
17:26:16 <cleanguy> Twey: no if you go to stackoverflow and look for "intellisense emacs" you'll see there's really no good solution
17:26:22 <Twey> tensorpudding: I tend to use make to invoke the other stuff
17:26:22 <cleanguy> joed: it doesnt, see above
17:26:25 <azl> tensorpudding: but we could
17:27:03 <alpounet> edwardk, the argument of ana
17:27:04 <blackdog> cleanguy: i've been playing around with ghc-mod - it's pretty nice, and does do completion
17:27:05 <tensorpudding> Cabal is a better solution for Haskell than Makefiles.
17:27:09 <alpounet> the "functoring" function
17:27:14 <joed> Yeah, okay, no, I'll not argue with you, mind you since I write Java for a living, I think intellisense is what I use the least.
17:27:21 <edwardk> ddarius: did you ever look at display logic?
17:27:41 <cleanguy> joed: intellisense was just an example...
17:27:53 <ddarius> edwardk: Very briefly recently.  Jason Reed has an unpublished paper on a (potential) example of an "undisplayable" logic.
17:28:01 <edwardk> ddarius: cute
17:28:17 <ddarius> It's the "Queue Logic" paper in his drafts.
17:28:31 <bremner> presumably f# is supported by visual studio, if that is the main criteria
17:28:37 <azl> tensorpudding: I could not find possibility to execute several *.bat files while setuping cabal package
17:28:39 <tensorpudding> F# is supported by VS
17:28:39 <edwardk> ddarius: i was using display logic as my 'meta-logic' for embedding all sorts of other logics in an old toy language design
17:28:43 <Twey> cleanguy: It gives code-completion and inline type display, which is pretty much everything
17:28:52 <edwardk> ddarius: basically doing curry-howard over display logic
17:28:56 <alpounet> edwardk, I actually want to write toNatural with a single definition
17:29:02 <alpounet> not pattern matching on the integer
17:29:06 <Sgeo_> Twey, I'm going to want a tutorial on that soonish
17:29:09 <dcoutts_> azl: cabal is mainly intended for portable Haskell packages
17:29:14 <Sgeo_> It will convince me to switch to Emacs, probably
17:29:19 <edwardk> alpounet: ultimately you need two cases.
17:29:38 <Twey> Sgeo_: Just dabbrev + haskell-mode
17:29:39 <dcoutts_> azl: it's less good for custom and platform-specific build systems
17:29:53 <azl> dcoutts_: of course! thats why for installation of several haskell application we need some other means.
17:29:57 <dcoutts_> azl: that said, you can do that using the Setup.hs and hooks
17:30:02 <edwardk> alpounet: toNatural = ana psi where psi 0 = Z; psi n = Succ (n - 1)
17:30:16 <dcoutts_> azl: I'm not sure I follow
17:30:20 * Twey sleep now
17:30:22 <azl> hooks?
17:30:32 <alpounet> yeah
17:30:34 <alpounet> better
17:30:43 <dcoutts_> azl: the UserHooks interface that you can use in the package Setup.hs
17:31:25 <Saizan> edwardk: no n+k patterns?:)
17:31:32 <dcoutts_> azl: provides a bunch of hooks, for each stage of the configure/build/install, lets you execute arbitrary IO actions
17:31:34 <edwardk> Saizan: i try to avoid them =)
17:32:28 <azl> dcoutts_:answers for my stupid sentences sometimes gives me a good research point.... thanks....
17:32:37 <edwardk> besides the code i put up here should be haskell2010 compliant ;)
17:32:38 <dcoutts_> azl: for example, executing .bat files is pretty useless for a package that you might upload to hackage, though it may make more sense in an in-house custom build process.
17:33:21 <azl> dcoutts_: in my case its absolutely in-house...
17:33:51 <dcoutts_> azl: so you can hack as much as you like in Setup.hs, it might not be pretty however :-)
17:34:19 <cleanguy> well the Clean guys are working on making Haskell work on their IDE so I guess I'll just wait for that
17:34:55 <cleanguy> since otherwise the Haskell community as a whole is unix-centric and gui-hating ;)
17:35:07 <edwardk> cleanguy: nah, we just have different priorities
17:35:28 <bremner> cleanguy: if you want gui-hating, you should visit #emacs
17:35:30 <edwardk> cleanguy: the clean guys are just so windows loving and stuck on writing guis rather than working on their core language ;)
17:35:38 <cleanguy> edwardk: right, like discussing unsafeIO or whatever that is
17:35:46 <azl> cleanguy: my work in haskell is windows-specific for now...
17:36:01 <cleanguy> azl: but your a linux guy, right?
17:36:35 <bremner> I always had the impression there was a big proportion of OS/X users here.
17:36:51 <bremner> maybe they are just loud :)
17:37:02 <azl> cleanguy: yeahh.... gui hater... :)
17:37:10 <cleanguy> azl: that's what i'm saying then
17:37:23 <cleanguy> azl: it's rare to find people that don't like linux, using haskell
17:37:24 <azl> cleanguy: I like when everything works itself
17:37:45 <cleanguy> azl: i like to double click to install my programs
17:37:59 * Saizan wonders which UI he'd like for Combinatorrent
17:38:02 <cleanguy> azl: and i dont like to mount my DVD drive and unmount it to eject
17:38:05 <cleanguy> azl: :D
17:38:15 <azl> cleanguy: I like when i don't even need to click to install programs
17:38:30 <cleanguy> azl: that's right, it's all keyboard for linux...
17:38:30 <Saizan> maybe the process should just listen to a socket so it's easy to write separate clients
17:38:31 <alpounet> ok I think I got them
17:38:35 <cleanguy> azl: they think using a mouse is too hard
17:38:40 <cleanguy> azl: too time wasting
17:38:48 <cleanguy> azl: they dont have time for that because they code so hard
17:39:00 <cleanguy> azl: no time to think about the code, just type quick quick chop chop
17:39:06 <tensorpudding> I'd like a mind-control UI for CombinaTorrent
17:39:47 <cleanguy> azl: well you go ahead an enjoy your CLI OS
17:39:49 <Saizan> well, i'd like a mind-control UI for everything.
17:39:53 <cleanguy> azl: im out
17:39:56 <azl> cleanguy: it's not hard, but when you attended to actually write code with keyboard, it's absolutely inconvinient to use mouse...
17:39:57 <blackdog> tensorpudding: but once you have the mind-control, presumably the secondary stage of actually uploading the movie/music/software directly into your brain is a trivial corollary.
17:40:10 <tensorpudding> Yes.
17:40:21 <tensorpudding> So what if the UI makes the program unnecessary?
17:40:51 <Saizan> you still have to download the thing before you can upload it into your brain
17:41:13 <Saizan> or do you want your brain to process the torrent protocol?
17:41:39 <ddarius> Saizan: Just give the users the belief that they have downloaded whatever.  Much more efficient.
17:42:00 <Saizan> ddarius: and have already watched it?
17:42:28 <ddarius> Sure.
17:42:46 * blackdog loves #haskell's ability to turn random trolling into surreal speculation
17:43:05 <azl> it's fun
17:43:09 <tensorpudding> Lets turn the random speculation into surreal trolling
17:44:03 <blackdog> tensorpudding: your mother wears mobius boots
17:44:18 <yuriks_> is there a function that does this: x `myfunc` 5 $ `myfunc` 2 $ `myfunc` 9 $ `myfunc` 1, etc., given a myfunc\a lambda and [5, 2, 9, 1]?
17:45:03 <yuriks_> erm, ignore the $'s
17:45:09 <Saizan> foldl' ?
17:45:20 <Saizan> > foldl' f x [5,2,9,1]
17:45:21 <lambdabot>   f (f (f (f x 5) 2) 9) 1
17:45:27 <blackdog> foldl1, maybe
17:45:29 <ddarius> Which way is `myfunc` associating?
17:46:04 <ddarius> Based on the $, I'm assuming right which would be (a variant on) foldr.
17:46:10 <yuriks_> ((((x `myfunc` 5) `myfunc` 2) `myfunc` 9) `myfunc` 1) like this
17:46:13 <Twey> > foldr1 f x [5, 2, 9, 1]
17:46:15 <lambdabot>   Couldn't match expected type `[a]'
17:46:15 <lambdabot>         against inferred type `SimpleRef...
17:46:18 <yuriks_> the $'s were a mistake, sorry
17:46:19 <ddarius> yuriks_: That's foldl'
17:46:20 <Twey> > foldr1 f [5, 2, 9, 1]
17:46:21 <lambdabot>   Ambiguous type variable `a' in the constraints:
17:46:21 <lambdabot>    `SimpleReflect.FromExpr ...
17:46:25 <Twey> Ych
17:46:28 <Twey> > foldr1 f [5, 2, 9, 1] :: Expr
17:46:29 <lambdabot>   f 5 (f 2 (f 9 1))
17:46:50 <blackdog> hm, that's cute. what's Expr?
17:46:59 <Twey> SimpleReflect type
17:47:16 <Twey> Has a Num instance that produces pretty representations instead of doing calculations
17:47:24 <ddarius> @hackage simplereflect
17:47:24 <lambdabot> http://hackage.haskell.org/package/simplereflect
17:47:38 <ddarius> @hackage simple-reflect
17:47:38 <lambdabot> http://hackage.haskell.org/package/simple-reflect
17:47:45 <blackdog> how does it handle f not having a definition?
17:47:54 <Twey> f is an Expr too
17:47:55 <Twey> :t f
17:47:56 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
17:48:00 <blackdog> oh, ok.
17:48:09 <aavogt> @hoogle String -> Version
17:48:10 <lambdabot> Prelude read :: Read a => String -> a
17:48:10 <lambdabot> Text.Read read :: Read a => String -> a
17:48:10 <lambdabot> Prelude error :: [Char] -> a
17:48:13 <yuriks_> > foldl1 f [5, 2, 9, 1] :: Expr
17:48:14 <lambdabot>   f (f (f 5 2) 9) 1
17:48:26 <yuriks_> that sounds about right, thanks
17:48:45 <blackdog> yuriks_: should it work on the empty list, though?
17:48:51 <tensorpudding> > foldl' f 0 [1..7] :: Expr
17:48:52 <lambdabot>   f (f (f (f (f (f (f 0 1) 2) 3) 4) 5) 6) 7
17:49:04 <yuriks_> blackdog: oh, hmmm, perhaps, it's not a dealbreaker though
17:49:11 <yuriks_> > foldl1 f [] :: Expr
17:49:12 <lambdabot>   * Exception: Prelude.foldl1: empty list
17:49:14 <ddarius> yuriks_: Use foldl'/foldl1' rather than foldl/foldl1.
17:49:44 <blackdog> yuriks_: that's what foldl' is for - you can give it an initial value, so that the empty list gets a sensible value
17:49:52 <yuriks_> ddarius: I don't have those
17:50:02 <Saizan> import Data.List
17:50:02 <ddarius> @hoogle foldl'
17:50:03 <lambdabot> Data.ByteString foldl' :: (a -> Word8 -> a) -> a -> ByteString -> a
17:50:03 <lambdabot> Data.Foldable foldl' :: Foldable t => (a -> b -> a) -> a -> t b -> a
17:50:03 <lambdabot> Data.List foldl' :: (a -> b -> a) -> a -> [b] -> a
17:50:08 <yuriks_> oh
17:50:14 <ddarius> Cripes.
17:50:50 <yuriks_> :t foldl1'
17:50:51 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
17:51:00 <yuriks_> hmm, which one is the initial type here?
17:53:12 <yuriks_> oh, foldl' has an initial value
17:53:48 <hpaste>  type-level peano numbers / fixed point (Alp)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24840
17:54:38 <codolio> We have a paste announcing bot now?
17:54:55 <alpounet> seems so
17:55:16 <aavogt> it's an independent bot
17:56:16 <Saizan> yeah, not like those mainstream ones
17:56:28 <Saizan> however, those aren't type-level numbers.
17:57:06 <alpounet> yeah they are conaturals
17:57:42 <yuriks_> hmm, what's the difference between foldl and foldl'?
17:58:08 <dmwit> foldl' is stricter
17:58:24 <yuriks_> ... and what does that mean?
17:58:47 <aavogt> > const 'a' $! undefined
17:58:48 <lambdabot>   * Exception: Prelude.undefined
17:58:51 <aavogt> > const 'a' $ undefined
17:58:52 <lambdabot>   'a'
17:59:04 <aavogt> yuriks_: it's like the difference between those ^^
17:59:20 <blackdog> yuriks_: you know about laziness and strictness?
17:59:33 <yuriks_> blackdog: probably not
17:59:42 <Saizan> well, it's more than that, because of the recursion and stack usage
17:59:44 <yuriks_> hmm, does foldl' evaluate the entire thing?
18:00:12 <blackdog> yuriks_: ok. so in a normal imperative language, only a few constructs are lazy, like "if". in haskell, by default everything's lazy
18:00:14 <Saizan> yuriks_: foldl' f , evaluates the applications of f step by step
18:00:23 <yuriks_> blackdog: yes, I know that much
18:00:54 <Saizan> yuriks_: foldl f instead creates a big expression made of all those nested applications, which gets evaluated all at once at the end
18:00:57 <blackdog> yuriks_: cool. so this is great for some things, but quite often, when you're folding over a list, you know that it's finite, and that you're going to need the whole thing
18:01:14 <blackdog> so any effort and space spent in setting up thunks to evaluate later will be wasted
18:01:19 <yuriks_> ah, I see
18:01:51 <Saizan> well, actually, if your 'f' is lazy enough, the most efficient would be a foldr
18:01:54 <blackdog> foldr is occasionally useful, because you can use it as a stream processor
18:02:08 <Saizan> foldl just can't exploit the laziness anyway, so it's better to go all the way to foldl'
18:02:22 <Saizan> i wouldn't say occasionally :)
18:02:28 <dolio> foldr is more than occasionally useful.
18:02:45 <dolio> Unless all you're ever doing is computing things like Int and Integer.
18:04:39 <blackdog> dolio: can be hard to get into the habit of thinking lazily, though. for a beginner, foldl' is much more useful
18:22:49 <mreh> has anyone tried to make a purely AFRP GUI toolkit?
18:23:39 <stevenmarky> What does the A stand for?
18:23:48 <mreh> stevenmarky, Arrowised
18:24:13 <azl> and for me, what is FRP?
18:24:33 <wolgo> :t `on`
18:24:34 <lambdabot> parse error on input ``'
18:24:37 <wolgo> :t on
18:24:38 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
18:24:48 <stevenmarky> azl: Functional Reactive Programming
18:25:04 <wolgo> > 3 `on` 3
18:25:05 <lambdabot>   No instance for (GHC.Num.Num (a -> b))
18:25:06 <lambdabot>    arising from the literal `3' at <...
18:25:10 <wolgo> ba dum bum
18:25:26 <dolio> Fruit?
18:26:46 <mreh> dolio: yeah, that seems like the best bet
18:27:12 <mreh> seems to be plagued with incomplete parts and slowness, but I think that might be sytemic to AFRP
18:27:39 <dolio> You mean, compared to all the speedy, complete non-arrow FRP libraries?
18:28:03 <mreh> dolio :) you can't fool me
18:28:52 <mreh> we need some personality types in the community that actually enjoy completing a project before it gets too boring
18:29:31 <mreh> lets make a  website
18:30:01 <wolgo> I can only complete things that are not boring.
18:30:11 <mreh> I just realised what I said
18:30:39 <mreh> *rather than quitting early because it gets repetitive"
18:31:11 <blackdog> there are always boring parts, though, after that initial rush of creative flow
18:31:33 <wolgo> yeah, like my noob hangman game.
18:31:39 <wolgo> I am bored now.
18:31:41 <wolgo> whee
18:32:09 <mreh> go do something new, that always helps get the creative juices flowing
18:32:11 <blackdog> i think the trick is writing something that replaces that rush with something else. having actual users is fun
18:32:18 <mreh> normally that means *gasp* stepping away from the computer
18:32:57 <greedo> so I'm trying to go from ASCII to decimal is that possible?
18:33:03 <mreh> can I plug software I've written in here?
18:33:10 <pastorn> greedo: look in Data.Char
18:33:14 <blackdog> mreh: if you can't, i'm in real trouble:)
18:33:21 <azl> does anybody knows what is coinductive data type?
18:33:27 <dolio> What is "decimal"?
18:33:33 <mreh> haskelloids
18:33:43 <mreh> there's a n00b game for you
18:33:48 <pastorn> greedo: here you go: http://haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/Data-Char.html
18:34:27 <Mathnerd314> azl: everything "lazy" in haskell
18:35:28 <greedo> i see Char -> Bool
18:35:38 <pastorn> greedo: look harder
18:36:00 <azl> ... i see, how is it connected to coinductive data types?
18:36:27 <greedo> digitToInt?
18:36:45 <pastorn> greedo: try them out in ghci until you find the one you need
18:37:11 <mreh> greedo: reverse the list and accumulate, multiply by ten each step
18:37:23 * greedo is being stocked
18:37:37 <mreh> that's like functional programming 101 :)
18:38:02 <user42> Hi. I'm having some trouble with some typefu, if anyone is willing to help.
18:38:25 <mreh> user42: don't ask to ask, just ask :)
18:38:27 <user42> I stuck some sample code that produces the problem here: http://gist.github.com/363184
18:38:44 <greedo> mreh: accumulate?
18:38:58 <kmc> user42, what do you expect?
18:39:01 <tac-tics> Anyone know why trac is down? Its been down all day
18:39:06 <kmc> the two branches of an "if" have to have the same type
18:39:12 <user42> I'm trying to construct a monad with a different configuration based on user input
18:39:23 <kmc> c1 and c2 don't have the same type, as you noted
18:39:33 <mreh> greedo: you have to accumulate the result somehow, do you know what I mean?
18:39:39 <user42> tac-tics: yea, I know. I'm to find a way around this.
18:39:41 <kmc> user42, so maybe you want c to have type:  exists c. MyConfig c
18:39:48 <kmc> which is not valid GHC Haskell
18:39:54 <kmc> but you can make an existential wrapper
18:40:04 <Mathnerd314> kmc: would a type class work?
18:40:11 <kmc> Mathnerd314, no
18:40:23 <kmc> to "forget" the implementation type you need existentials
18:40:46 <greedo> reverse + 1 * 10
18:40:57 <kmc> user42, data SomeMyConfig = forall c. SomeMyConfig (MyConfig c)
18:41:01 <tac-tics> User42: its totally cramping my style.
18:41:08 <kmc> LANGUAGE ExistentialQuantification
18:41:27 <mreh> greedo: you want a string of digits to be converted into a single integer value correct?
18:41:41 <mreh> [0-9]
18:41:43 <user42> tac: I'll try that
18:43:02 <greedo> mreh: maybe I'm approaching this all wrong, but I'm trying to find the number of items in the constant pool from a .class file
18:46:04 <tdmackey> greedo: ord
18:46:51 <azl> greedo: fromEnum '1' - 48
18:47:00 <azl> fromEnum '1' - 48
18:49:08 <mreh> > let digitsToInt acc [] = acc ; digitsToInt acc (n:ns) = digitsToInt (Data.Char.digitToInt n + acc * 10) ns in digitsToInt 0 "123"
18:49:09 <lambdabot>   123
18:49:18 <mreh> greedo: there you go
18:49:23 <Sgeo_> Are there nice two-dimensional structures in Haskell?
18:49:35 <pastorn> Sgeo_: Array (Int,Int) is nice
18:49:36 <greedo> mreh: cool
18:49:50 <pastorn> Sgeo_: but writing to them is O(n)
18:50:02 <pastorn> (you copy all of the array when updating an element)
18:50:06 <azl> foldl (\ a b -> (a * 10) + b) 0 $ map c "431"
18:50:22 <Sgeo_> pastorn, there are in-place arrays with pure interfaces, right?
18:50:24 <pastorn> Sgeo_: there are ways around that, though
18:50:35 <pastorn> Sgeo_: yes, STArray, i blieve
18:50:43 <pastorn> (+ spelling)
18:52:04 <dolio> azl: Inductive types are defined by what their values are built of. You specify constructors, and the type is the 'least' type closed under all those constructors.
18:52:41 <azl> azl: what about coinductive?
18:53:01 <dolio> That gives you an induction principle, which lets you specify what to do in the case of each constructor to automatically obtain a function from the inductive type to some other type.
18:53:23 <kmc> pastorn, writing to Array (Int,Int) is O(n)?
18:53:25 <kmc> what do you mean?
18:53:27 <kmc> what's n?
18:53:28 <dolio> Coinductive types are kind of the opposite. They're defined by what you can observe about their elements.
18:53:38 <mreh> azl: very elegant
18:54:11 <greedo> azl: does it work?
18:54:14 <azl> mreh: let c a = fromEnum a - 48 -- forgot
18:54:18 <pastorn> kmc: n is the number of elements in the array
18:54:20 <dolio> You specify a bunch of of things you might see when you perform an observation on one of its values, and it's the 'largest' type that supports those observations.
18:54:54 <azl> mreh: it work in ghci6.10 at least
18:55:17 <azl> Prelude > foldl (\ a b -> (a * 10) + b) 0 $ map (\cc ->(fromEnum cc) -48) "431"
18:55:18 <azl> 431
18:55:27 <kmc> Sgeo_, consider also Data.Mapa
18:55:29 <kmc> Data.Map*
18:55:30 <dolio> And it has a coinduction principle, which says that if you have any other type that can support such observations, then there is a function from that type to the coinductive type, such that applying the function will give an element that yields identical observations.
18:55:53 <kmc> you can use a pair like (Int,Int) as your key
18:55:53 <pastorn> Sgeo_: what are you trying to build?
18:56:00 <kmc> and it will have good sharing between updated versions
18:56:05 <mreh> i'm sure that map and fold could be inlined
18:56:09 <Sgeo_> pastorn, nothing yet, but pondering a Befunge avatar
18:56:12 <Sgeo_> *interpreter
18:56:23 <pastorn> haha
18:56:29 <pastorn> coolt
18:56:30 <greedo> pastorn: is that all on one line?
18:56:43 <pastorn> greedo: is what on one line?
18:57:06 <greedo> pastorn: i asked the wrong person
18:57:09 <greedo> sorry
18:57:20 <greedo> mreh: is that all on one line?
18:57:49 <mreh> greedo: only because I wrote it that way, azl has provided you with a one-line version using foldl
18:58:04 <mreh> greedo: one line and readable :)
18:58:34 <dolio> azl: Does that make any sense?
18:58:44 <user42> kmc: it seems to have worked (passed the type checker at least), thanks.
18:58:52 <greedo> mreh: so what will the name of the fold be?
18:59:07 <greedo> foldl*
18:59:08 <user42> kmc: btw, sorry for confusing you with tac-tics :p
18:59:27 <mreh> greedo: how much haskell/FP experience have you got?
18:59:47 <greedo> mreh: this is my first semester
19:00:09 <mreh> greedo: you better hit the haskell wiki and read up about foldr and foldl
19:00:35 <azl> dolio: self-study.... I've got no wikipedia page for coinductive types so i asked...
19:01:12 <azl> mreh: If you ever see the first version of same code... :))
19:01:28 <dolio> azl: The paper A Tutoral on (Co)Algebras and (Co)Induction is pretty good.
19:02:15 <azl> dolio: I see, now I almost know where to search... :)
19:02:31 <mreh> is there an easy way of looking at a problem and saying "I can't do that with a foldr because"
19:02:46 <mreh> "but I can do it with a foldl"
19:02:48 <aavogt> bah, ghc takes too much ram to compile this TH generated code
19:03:09 <greedo> mreh: I'm actually trying to do this http://tamu.pastebin.com/haK7henJ
19:04:19 <aavogt> %GC time      42.6%  (38.5% elapsed)
19:04:41 <dons> that's GHC's stats?
19:04:46 <mreh> greedo: you could write a parser in parsec
19:04:53 <aavogt> yeah
19:05:23 <mreh> in my first semester of FP I was reversing strings, maybe shuffling a list or two, nothing like this!
19:06:02 <greedo> mreh: would that be that easiest way to do the problem?
19:06:28 <greedo> mreh: i think my prof is mad
19:06:34 <aavogt> dons: it works fine if I make the TH generate roughly half the original code
19:07:04 <aavogt> something to do with unfolding the whole expression...
19:07:12 <aavogt> is not going well with ghc
19:08:03 <mreh> greedo: sounds like a research type
19:08:25 <mreh> they always set inappropriate coursework
19:08:54 <mreh> I must go to sleep, I have to do many things tomorrow and it's already 3am
19:09:25 <greedo> mreh: so parsec might be best?
19:12:46 <greedo> how hard would parsec be?
19:12:58 <azl> greedo: parsec is very good for everything concerting texts processing... :)) regexps are suck...
19:13:01 <greedo> and would that be the best way to do this
19:13:50 <siracusa> greedo: What format are these class files of? Java bytecode?
19:14:09 <azl> greedo: rather easy, having starting example.... try realworldhaskell
19:14:54 <greedo> siracusa: yes, .class
19:15:20 <dmwit> For binary file formats, Data.Binary is nice.
19:16:00 <siracusa> greedo: This is a first semester task? O.O
19:17:01 <greedo> siracusa: opened it as a binary and now I'm having trouble finding the constant_pool_constant?
19:17:19 <greedo> constant_pool_count*
19:17:43 <greedo> siracusa: first semester FP class
19:19:07 <siracusa> greedo: incredible ...
19:19:14 <gwern> greedo: are you like, a grad student?
19:19:31 <greedo> gwern: no, undergrad
19:19:53 * gwern finds it hard to believe an undergrad 1st semester intro to fp class would assign a task like parsing java bytecode, unless java bytecode is radically simpler than I thought
19:20:11 <Axman6> aye
19:20:51 <gwern> I mean, I'm not sure I'd assign that to an upper level class. design a bytecode, sure, but parsing a industrial strength decades old format like jvm?
19:20:55 <aavogt> dons: turns out it can build given a bit of swap in addition to 4G ram
19:21:39 <bremner> maybe the class file structure is not so bad as the bytecode.
19:22:17 <greedo> gwern: this is my first upper level class
19:22:19 <pastorn> creating class files isn't too hard... we did it in our compiler construction course...
19:22:30 <pastorn> though then we didn't use any arrays or objects...
19:22:39 <bremner> its just a struct
19:22:39 <gwern> ok, juniors/seniors, I could see a little more
19:22:49 <bremner> http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html
19:23:03 <greedo> gwern: we learn both haskell and java in one semester
19:23:17 <gwern> good luck
19:23:23 <bremner> parsec is overkill imho
19:23:35 <gwern> greedo: wait. what were you using as frosh and sophs then?
19:23:35 <pikhq> It seems that Java bytecode is actually easy to parse.
19:24:05 <greedo> gwern: C++
19:24:21 <gwern> oh. well, if you survived c++, you should be fine then
19:24:36 <pikhq> Each opcode is a byte. A few opcodes have a few more bytes following. Piece of cake.
19:24:43 <greedo> we have the creator of C++ here
19:24:59 <greedo> so they really put it
19:25:06 <pikhq> Stroustrup? Urgh.
19:25:12 <greedo> yeah
19:25:16 <gwern> what doesn't kill you, etc.
19:25:20 <monochrom> oh what fun
19:25:34 <dons> aavogt: wow
19:25:45 <dons> might be worth a bug report (and test program) to help optimize -fth
19:25:51 <monochrom> what doesn't kill you gives you trauma and flashbacks for life
19:26:02 <greedo> anyways i need to finish this
19:26:16 <greedo> so i have javabyte code
19:26:41 <aavogt> dons: I don't think it's due to TH... I think it's more likely that the generated code (nested cases at least 20 deep) is just bad
19:26:56 <monochrom> give a man a c++ program, and he has a nightmare for a night. teach him c++, and he has nightmares for life.
19:27:41 <pastorn> hehe
19:27:43 <Zao> My nightmares tend to be about type checking and MatLAB.
19:27:58 <gwern> make him teach c++, and ia! ia! f'taghn shub-niggurath of <<>>S
19:28:19 <pastorn> greedo: so you're supposed to write what function?
19:28:27 <pastorn> f :: ClassFile -> ???
19:28:28 <Zao> gwern: <<> >, you mean?
19:28:44 <Zao> The C++03 parser can't handle >> for closing template arguments :P
19:28:46 <greedo> pastorn: yes
19:28:53 <blackh> monochrom: The trouble is, I can't wake up.
19:28:53 <gwern> Zao: it's not safe to know what I mean
19:29:00 <Zao> I do, unfortunately.
19:29:01 <greedo> by 4/12/10
19:29:07 <pastorn> greedo: what's the ??
19:29:10 <greedo> at 11:59
19:29:21 <greedo> http://tamu.pastebin.com/9hRsQSic
19:29:25 <Zao> pastorn: Yay, homework?
19:29:33 <Zao> greedo: Plenty of time.
19:29:44 <greedo> so that's the javabyte code
19:29:46 <pastorn> greedo: is that a class file?
19:29:50 <pastorn> cool
19:29:52 <greedo> yes
19:29:59 <pastorn> greedo: you want to use Data.Binary
19:30:00 <pastorn> for this
19:30:07 <ManateeLazyCat> Anyone use mercurial? Can do compare with darcs ?
19:30:13 <pastorn> i'll show you my TGA-loader, written with that library
19:30:52 <greedo> http://tamu.pastebin.com/khP33LLJ
19:31:00 <greedo> that's what i have so far
19:31:29 <greedo> so I can't find the constant_pool_count
19:31:57 <aavogt> dons: if you're interested, that code is at:  code.haskell.org/~aavogt/public_html/XMonadConfigUpdater
19:32:43 * ManateeLazyCat Perhaps i need switch to mercurial, Google Code just support mercurial and svn
19:32:45 <aavogt> since apache is down there, but you can pull over ssh
19:34:03 <hpaste>  targa loader (pastorn)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24841
19:34:10 <pastorn> oh shit
19:34:26 <pastorn> i was about to link that, but it did it automagically
19:34:28 <pastorn> awesome :)
19:34:30 <pastorn> greedo: ^^^
19:34:32 <azl> greedo: you'll have problems with those take-drop
19:35:16 <pastorn> greedo: check my code there (and look at the semi-specs here while reading the code: http://en.wikipedia.org/wiki/Truevision_TGA )
19:35:41 <dons> aavogt: ooooh
19:35:52 <dons> Igloo: apache down on c.h.o
19:36:13 <ManateeLazyCat> versioncontrolblog.com/comparison/Arch/Bazaar/Git/Darcs/Mercurial/Monotone/index.html for compare Git, Bazaar, Arch, Darcs, Mercurial, Monotone
19:36:20 <Cale> ManateeLazyCat: It's good to be aware of this: http://zooko.com/badmerge/concrete-good-semantics.html
19:36:30 <greedo> pastorn: yoah, so that's cool
19:36:44 <aavogt> it has awful dependencies... but soon enough they will be standard
19:36:53 <pastorn> greedo: Data.Binary + Control.Applicative, that's how you should do it :)
19:36:55 <greedo> pastorn: and long
19:37:15 <aavogt> the INSTALL should describe everything
19:37:28 <dcoutts_> dons: fixed
19:37:29 <pastorn> also note that the TargaHeader-type has all its data in the order that they occur in the file
19:37:29 <ManateeLazyCat> Cale: Now, i just care hosting. VersionControl enough is okay.
19:37:56 <ManateeLazyCat> Cale: Haven't any Darcs hosting better git-hub or GoogleCode
19:37:56 <pastorn> greedo: without data TargaHeader having that order, it wouldn't be possible to use Applicative
19:38:11 <ManateeLazyCat> Cale: And git is not friendly on Windows and Mac
19:38:33 <ManateeLazyCat> Cale: If darcs have awesome hosting, i will stay in darcs.
19:38:47 <Cale> Well, all you need to host a darcs project is an arbitrary directory on a webserver.
19:39:23 <dcoutts_> aavogt: note that you should no longer need Cabal-1.9 for XMonadConfigUpdater, latest 1.8.x release should work
19:39:25 <Saizan> ManateeLazyCat: is patch-tag awesome enough?
19:39:28 <aavogt> dcoutts_: any chance for the executables depending on included library feature being in a release of cabal?
19:39:41 <dcoutts_> aavogt: :-)
19:39:43 <ManateeLazyCat> Cale: No, that's not enough, i need make user easy to see changelog. And make developer can use VersionControl in any platform.
19:39:49 <greedo> pastorn: what does your program do?
19:39:56 <ManateeLazyCat> Saizan: patch-tag is cool, but not cool enough.
19:40:23 <ManateeLazyCat> I just consider "Darcs, Mercurial, Git"
19:40:23 <pastorn> greedo: it reads a file and parses it as if it was un uncopmressed targa file
19:40:28 <Saizan> i don't think there's anything better than that for darcs, currently
19:40:30 <dons> aavogt: got it.
19:40:35 <gwern> ManateeLazyCat: I once tried to drum up support for showing changelog on hackage. no one seemed interested
19:40:36 <bremner> ManateeLazyCat: I'm probably biased because I only use git, but the number of people who know git well is more than those that know mercurial well.
19:40:45 <tensorpudding> Patch-Tag doesn't compare to Bitbucket or Github though.
19:41:17 <ManateeLazyCat> bremner: Mercurial is easy as Darcs.
19:41:26 <ManateeLazyCat> bremner: Git looks complicated for newbie.
19:41:26 <greedo> azl: why?
19:41:27 <pastorn> greedo: loadTGA is the exported function (loadTGA :: FilePath -> ((Int,Int), [Color4 Word8] (not exactly true, but anyway); data Color4 a = Color4 a a a a)
19:41:41 <dons> Results 1 - 10 of about 223,000 for git complicated
19:41:56 <dons> Results 1 - 10 of about 311,000 for darcs simple
19:42:01 <dons> mwhaha. all win.
19:42:07 <greedo> azl: they work for checking the magic number
19:42:15 <ManateeLazyCat> dons: Mercurial.
19:42:15 <Cale> huh... I would think if you want to see the changelog, you just use darcs changes on the repo
19:42:25 <bremner> ManateeLazyCat: no idea about that. I learned git first.  I think git is much easier than Haskell :)
19:42:37 <dons> Results 1 - 10 of about 2,380,000 for mercurial so what?
19:42:45 <Cale> bremner: You're comparing a revision control system to a programming language? ;)
19:42:55 <ManateeLazyCat> dons: I'm reading versioncontrolblog.com/comparison/Arch/Bazaar/Git/Darcs/Mercurial/Monotone/index.html
19:42:55 <kmc> git, like Haskell, is based largely around immutable datastructures
19:43:02 <greedo> pastorn: wonder if I could use the same idea to .class binary
19:43:06 <dons> kmc: except for all the mutation...
19:43:09 <dons> rebase!
19:43:12 <kmc> dons, in which?
19:43:14 <kmc> rebase doesn't mutate
19:43:19 <pastorn> greedo: you probably could :)
19:43:22 <kmc> except for moving your branch pointer, which "merge" does too
19:43:30 <bremner> Cale: I'm comparing two technologies that people complain about before they understand them.
19:43:31 <azl> greedo: I mean, I'd better use Parsec or Binary
19:43:32 <dons> it's far more about destructive updates than i'd expect for a persitant structure
19:43:40 <aavogt> dcoutts_: so cabal-install 0.8.2 handles that library+executable situation?
19:43:43 <dons> all vcs *have* to support persistance in some form -- that's their job
19:43:48 <kmc> you can't destructive update any object in the git repository
19:43:49 <kmc> period
19:43:53 <kmc> unless you find a SHA1 collision
19:44:02 <dcoutts_> aavogt: I believe so. I hear that haddocking currently fails however.
19:44:04 <bremner> kmc: well, refs are destroyed
19:44:06 <pastorn> azl: not parsec for stuff like a class file
19:44:08 <kmc> right
19:44:18 <kmc> they're not objects, they're mutable cells containing objects
19:44:22 <kmc> like IORef cells
19:44:27 <greedo> azl: i just need to fastest, easiest and hopefully consise solution to this
19:44:35 <kmc> but all of history is stored in a persistent way
19:44:49 <pastorn> greedo: do like me; use Data.Binary :)
19:44:50 <Cale> My main complaint about most revision control systems is the broken way in which they do 3-way merges that ignore all the history involved in each branch of changes.
19:44:52 <kmc> (except the meta-history of where your refs were, i suppose.  that is stored but it's a secondary / ad-hoc thing)
19:45:00 <kmc> Cale, including git?
19:45:02 <Cale> yes
19:45:13 <Cale> (but not including darcs)
19:45:33 <pastorn> greedo: you might not be able to do it ill with Applicative style if you want to read fields with variable sizes (like cp_info)
19:45:43 <azl> pastorn: ok, i see now...
19:46:03 <greedo> pastorn: so you read in the hex?
19:46:16 <greedo> or what are you reading? binary?
19:46:30 <deech> <vent> yowza, HXT has a sharp learning curve! </vent>
19:46:49 <pastorn> greedo: here are the functions for reading: http://hackage.haskell.org/packages/archive/binary/0.5.0.2/doc/html/Data-Binary-Get.html
19:47:01 <azl> greedo: I'm not pretending. :) pastorn knows that kind of job better, i never parsed binaries...
19:47:05 * ManateeLazyCat I firmly resolve to abandon it, everytime Emacs crash or freeze, elisp is reallllllly bad language for big project like Emacs.
19:47:43 <gwern> ManateeLazyCat: go use yi, and you can bitch about a whole new set of problems
19:47:45 <greedo> pastorn: ok, so my code is not reading the binary currently?
19:47:45 <Cale> deech: Yeah, it's horribly complicated, which is not much of a surprise given that essentally everything XML has ever come into contact with is a horrifying monstrosity.
19:48:00 <ManateeLazyCat> gwern: yi is not enough, just editor.
19:48:07 <greedo> i think it is ASCII
19:48:17 <gwern> ManateeLazyCat: see? you're already settling in nicely
19:48:28 <deech> Why do I feel like the Perl/Ruby/Python guys have it a lot easier when it comes to XML?
19:48:28 <pastorn> greedo: i haven't seen your code... all i've seen are the class specs and some \lol\NUL\WHATEVER paste
19:48:31 <wavewave> is yi usable in production?
19:48:34 <ManateeLazyCat> gwern: I have did a replace.
19:48:36 <ddarius> ManateeLazyCat: emacs is written in C.
19:48:42 <ManateeLazyCat> ddarius: I know.
19:48:47 <Sgeo_> Has anyone made Haskell apps for Android using LambdaVM?
19:48:52 <greedo> pastorn: http://tamu.pastebin.com/khP33LLJ
19:49:05 <gwern> Sgeo_: does lambdavm work?
19:49:06 <ManateeLazyCat> ddarius: http://www.emacswiki.org/emacs/AndyStewart my homepage
19:49:14 <Cale> deech: I've never really seen any indication that they do...
19:49:15 <Sgeo_> gwern, don't know
19:49:26 <wavewave> what is the best library for shell command execution in haskell?
19:49:26 <sacha> Does haskell have any functions for checking a posix system's pagesize?
19:49:27 <pastorn> greedo: see, what you do here is that you manually have to take and dump stuff, which is annoying
19:49:37 <ManateeLazyCat> ddarius: But most emacs extension is written by elisp, that's really bad.
19:49:42 <deech> Cale: Or at least have better documented libraries :)
19:50:14 <pastorn> in Data.Binary you traverse along your data, like a stream, each step saying how many bytes (and in what format) to chew off the head of the stream :)
19:50:23 <ManateeLazyCat> @type runProcess
19:50:24 <lambdabot> Not in scope: `runProcess'
19:50:29 <Cale> deech: Are you primarily using HXT to generate or to parse XML?
19:50:38 <gio123> if in lambd aterm, bind variables occur one or more time in the redex, what is called such term?
19:50:43 <ManateeLazyCat> wavewave: runProcess
19:50:47 <aavogt> @quote documentation
19:50:47 <lambdabot> adaptec says: [in documentation for their raid chipsets] We have a disclaimer because there may be corner cases
19:50:52 <greedo> pastorn: so it is a stream like in java
19:50:59 <aavogt> @quote for.documentation
19:50:59 <lambdabot> kmc says: types substitute for documentation much better than documentation substitutes for types
19:51:00 <ManateeLazyCat> wavewave: http://hackage.haskell.org/packages/archive/process/1.0.1.1/doc/html/System-Process.html
19:51:00 <pastorn> dunno... maybe
19:51:02 <gwern> wavewave: HSH
19:51:12 <pastorn> greedo: anyway, you can't go back
19:51:34 <gio123> if in lambd aterm, bind variables occur one or more time in the redex, what is called such term?
19:51:37 <Cale> gio123: I'm not sure it has a particular name... "used variable"?
19:51:42 <Sgeo_> Maybe I should just relearn Java
19:51:44 <greedo> pastorn: ah, i see your point
19:51:48 <ManateeLazyCat> wavewave: Just remember, don't use `forkProcess`, use `runProcess` replace it anyway.
19:52:05 <ManateeLazyCat> wavewave: `forkProcess` is not safe when spawn process.
19:52:05 <Sgeo_> I mean, I know C#, how bad can Java be?
19:52:09 <dons> wavewave: i've heard people are using yi for daily stuff. i was for a while in 2005, so i bet it's in a decent state.
19:52:11 <deech> Cale: Basically I have a bunch of XML files which I need to parse, swap some node names if they exist and make some new ones, and rewrite the new XML to a file. I'm trying to upgrade some Maven 1 project.xml to Maven 2 pom.xml.
19:52:27 <wavewave> so two best choices : process and hsh
19:52:33 <Cale> deech: Okay, so both at once...
19:52:35 <gwern> I use yi just for my ireader mode, and haskell editing
19:52:47 <gio123> Cale: if there is single occurence bind variables it has name linear, if 1 or 0 variables affine
19:52:48 <gwern> wavewave: hsh is more high level, but process is usually installed
19:52:56 <gwern> so I do use yi daily
19:53:08 <dons> gwern: yeah, you've been using yi for a long time, iirc?
19:53:12 <gio123> if, 1 or more variables i think is denoted by I, but do not know name
19:53:17 <gwern> goodness, yeah
19:53:17 <ddarius> Sgeo_: Java is significantly worse than C# (which is somewhat amazing)
19:53:19 <deech> I didn't think XML was that complicated. It's just a tree right?
19:53:22 <wavewave> how is the status of yi GUI?
19:53:23 <gwern> years by this point
19:53:28 <dons> someone switched to yi for their w3m editing very very early on
19:53:30 <wavewave> is it GTK application now?
19:53:40 <dons> wavewave: yeah, and console if you like that
19:53:41 <gwern> wavewave: I dunno. I keep having problems with install gtk2hs
19:54:13 <ManateeLazyCat> dons: Yi use different back-end limit it's feature.
19:54:29 <deech> gwern: I found the documentation on how to install Leksah the best for installing gtk2hs.
19:54:32 <ManateeLazyCat> gwern: What's problem, please report to gtk2hs mail-list.
19:54:38 <gwern> ManateeLazyCat: better than getting locked in
19:54:39 <Cale> deech: It's an overcomplicated tree. ;)
19:54:39 <wavewave> dons: how can I install yi GTK? in fact, I installed yi but it's only in console mode.
19:54:48 <gio123> Cale: do u get?
19:54:56 <gwern> ManateeLazyCat: I have reported problems in the past, but they seem to be exclusive to my machine
19:55:02 <ManateeLazyCat> gwern: Axel is merging my patch to build gtk2hs cabal package.
19:55:04 <greedo> pastorn: so I should use a bytestring?
19:55:27 <Cale> gio123: No idea what you'd call it.
19:55:36 <ManateeLazyCat> wavewave: You need install gtk2hs first.
19:55:52 <gio123> there is no name for it?
19:55:55 <pastorn> greedo: yes
19:55:55 <ManateeLazyCat> gwern: After Axel finish work, gtk2hs can installed by cabal.
19:56:10 <Cale> gio123: There might be a name for it, but I don't know it
19:56:11 <pastorn> greedo: just copy my loader and replace with what you need
19:56:15 <wavewave> ManateeLazyCat: I already installed gtk2hs..
19:56:19 <gio123> ok
19:56:21 <gio123> :)
19:56:24 <ManateeLazyCat> wavewave: yi --help
19:56:34 <ManateeLazyCat> wavewave: Then set back-end with gtk
19:56:43 <Sgeo_> Maybe I should learn Scala
19:56:49 <wavewave> frontend not found.
19:56:56 <Cale> deech: It's a tree with lots of weird additional structure, like processing instructions, CDATA, attributes, ...
19:57:04 <wavewave> ManateeLazyCat: maybe I should reinstall yi again?
19:57:25 <greedo> do i need Color4 and Word?
19:57:27 <hamishmack> wavewave: cabal install -f pango
19:57:30 <ManateeLazyCat> wavewave: You must make sure gtk2hs installed before yi.
19:57:38 <gwern> ManateeLazyCat: well, that's great but I don't see any new patches
19:58:07 <ManateeLazyCat> gwern: I push so much patch to update gtk2hs APIs, so it's difficult to Axel. :)
19:58:15 <ManateeLazyCat> gwern: Just waiting :)
19:58:34 <Axman6> Sgeo_: why?
19:58:50 <Sgeo_> Axman6, so I can write apps for Android in a functional language?
19:58:50 <ManateeLazyCat> gwern: If Axel finished, i will try to update gtk2hs to Gtk+ 2.20, then update GIO to newest, GIO in gtk2hs is really old.
19:58:56 <Sgeo_> Or is Scala not considered functional
19:59:01 <wavewave> by the way, as a haskell programmer, what is the best use of yi?
19:59:06 <Sgeo_> Haven't actually looked into Scala >.>
19:59:17 <wavewave> I am a haskell-mode user of emacs.
19:59:26 <gwern> Sgeo_: asking whether scala is functional or not is trolling, incidentally
19:59:39 <Sgeo_> ??
19:59:42 <pastorn> greedo: i'm helping you get started....
19:59:48 <ManateeLazyCat> wavewave: Maybe you can waiting my project release. :)
19:59:50 <pastorn> writing the first two steps :)
19:59:51 <gwern> wavewave: it;s basically the same. you get unicodifying, c-c c-l to load the buffer into ghci, etc.
19:59:54 <Cale> Sgeo_: it's functional by some measures, but not terribly principled about it.
20:00:07 <gwern> wavewave: well, assuming your yi.hs is set up right
20:00:15 <Sgeo_> :(.
20:00:19 <gwern> wavewave: I can tell you that yi's indenting is much better though!
20:00:20 <wavewave> unicodifying sounds great. So now \x -> lambda x?
20:00:31 <Cale> Well, this is compared to Haskell
20:00:36 <gwern> wavewave: sure. didn't you try it in emacs?
20:00:41 <Cale> Compared to Java, it's lovely
20:00:53 <ddarius> Sgeo_: The question is whether it is enjoyable and effective for that purpose, not whether it is functional or not.
20:00:54 <greedo> pastorn: thx, however there is a lot of your code that I don't currently understand
20:01:05 <wavewave> gwern: I didn't. I am using just plain emacs23 with haskell-mode
20:01:07 <pastorn> greedo: just ask
20:01:25 <gwern> wavewave: you should try it. I find unicode mode much easier on my eyes
20:01:43 <greedo> pastorn: ((i,i), [Color4 Word8]), what is that for?
20:01:55 <wavewave> so emacs key binding is still the same in yi?
20:02:12 <wavewave> changing editor is a really big task. :)
20:02:16 <gwern> wavewave: yi has multiple modes
20:02:20 <pastorn> it returns a size and the list of all elements in the image
20:02:26 <gwern> emacs mode is decent
20:02:34 <gwern> I use emacs in general, and yi for haskell or ireader tasks
20:02:37 <wavewave> how about remote editing ? I like emacs remote editing.
20:03:05 <pastorn> i use (Integral i) => (i,i) instead of (Int,Int) because i want to use the data as "GLsizei" in the caller of loadTGA (it's for OpenGL stuff)
20:03:20 <pastorn> haskell casts that automagically for me
20:03:24 <greedo> ok
20:03:51 <monochrom> I love emacs and haskell-mode
20:03:58 <wavewave> gwern: what is ireader task?
20:04:16 * ManateeLazyCat Mercurial and Darcs are awesome
20:04:18 <gwern> wavewave: read the module code
20:04:23 <gwern> hard to explain
20:04:33 <gwern> monochrom: I don't think haskell-mode is that great
20:04:42 <gwern> indentation is a real problem for it
20:05:04 * ManateeLazyCat If have better hosting i will stay in Darcs, more haskell style. 
20:05:09 <monochrom> I love haskell-mode indentation
20:05:26 <gwern> but it's so frequently wrong and mindless!
20:05:38 <hpaste>  submode (aavogt)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24842
20:05:40 <ManateeLazyCat> GoogleCode provide 2GB storage for project.
20:05:48 <wavewave> gwern: I agree with you. I had some problem with if then else indentation with haskell-mode
20:06:02 <wavewave> with lots of other issues.
20:06:03 <heatsink> let if_empty = <tab><tab><tab><tab> ARGH
20:06:08 <monochrom> if-then-else indentation has long been solved in haskell-mode
20:07:06 <monochrom> I agree about mindless, but it cannot possibly be a criticism. If haskell-mode knew how to write the program for you, you would have no reason to exist.
20:07:24 <wavewave> monochrom: I see. I need to upgrade mine. thx .
20:07:34 <monochrom> I disagree about frequently wrong. Every time it offers choices, and every time some choice is right.
20:07:41 <ManateeLazyCat> gwern: Yes, indentation is really big problem, speical when coding deep structure
20:07:43 <wavewave> by the way, my yi failed to be compiled..
20:08:03 <gwern> wavewave: that happens sometimes
20:08:13 <gwern> wavewave: if you aren't using darcs yi, no on cares
20:08:34 <deech> gwern: I have yi installed correctly but how do I use it (beyond using the emacs analogs) ? Is there a manual I am missing?
20:08:36 <greedo> any idea how i can get this constant_pool_count?
20:08:38 <ManateeLazyCat> monochrom: Just need smart indentation than haskell-mode. :)
20:08:46 <wavewave> gwern: I see. I have to get it from darcs.
20:09:07 <wavewave> so current hackage version uses strange monad transformer library.
20:09:20 <gwern> deech: there's no manual. really, best to consult the Yi/Users/ directory for configs
20:09:37 <wavewave> which seems to have a name conflict with mtl.
20:09:43 <pastorn> greedo: yes :)
20:09:46 <pastorn> working on that now
20:09:50 <pastorn> just to show you :)
20:10:09 <deech> gwern: Ah. Do the config files tell me what the default (M-x) commands are?
20:10:23 <gwern> deech: nope. you would have to look at the source
20:10:35 <greedo> pastorn: thx
20:11:05 <deech> Or how it might make Haskell programming easier? ie tighter integration with GHCI, Cabal etc.
20:11:14 <gwern> deech: read the source is a common answer. the sets of yi users and devs overlap considerably
20:11:25 <gwern> deech: oh, actually, it does have better cabal support. ot
20:11:43 <deech> gwern: gottit! just thought there was something I was missing.
20:11:46 <gwern> it's much less common to sit in the top level dir, open a file, and have your ghci fail to load things
20:11:49 <gwern> than with emacs
20:11:50 <wavewave> i am darcs-getting yi now :)
20:11:58 <wavewave> excited...
20:12:11 <gwern> with emacs, it's very much a crap shoot whether ghci will work on a buffer or not
20:12:16 <deech> Does it do a better job searching for function signatures?
20:12:39 <gwern> something to do with haskell-mode not opening ghci in the right directory or not reading stuff from .cabals
20:12:55 <gwern> deech: dunno
20:13:23 <gwern> deech: I don't think anyone does anything besides shelling out to hoogle
20:13:28 <wavewave> i want to haskellizing my life more :)
20:13:32 <gwern> though maybe leksah does soemthing
20:14:00 <aavogt> @faq can leksah help me write haskell backwards?
20:14:00 <lambdabot> The answer is: Yes! Haskell can do that.
20:14:20 <deech> gwern: yes leksah does read your current .cabal directory and read function signatures from all your installed packages.
20:14:52 <monochrom> @fan can haskell write leksah backwards?
20:14:52 <lambdabot> The answer is: Yes! Haskell can do that.
20:15:02 <gwern> deech: all installed packages? how does it do that? it can't be using the ghc api to load them all because that'd lead to name clashes and be way too slow
20:15:10 <gwern> maybe it's parsing .his?
20:15:11 <aavogt> @fqa yes?
20:15:11 <lambdabot> Maybe you meant: faq ft
20:15:36 <monochrom> what is ft?
20:15:37 <deech> gwern: dunno, but the first time you start leksah it processes all your packages.
20:15:38 <hamishmack> If you are feeling adventurous and have darcs yi working with -f pango you can try darcs Leksah with -f yi
20:15:49 <aavogt> free theorems?
20:16:04 <monochrom> @ft f :: a->a
20:16:05 <lambdabot> Done.
20:16:06 <hamishmack> then turn on yi support in the preferences page of Leksah
20:16:10 <deech> gwern: and I don't have to refer to Hoogle/Hayoo.
20:16:14 <wavewave> hamishmack: oh.. Leskah has yi interface?
20:16:27 <aavogt> @ft a -> b
20:16:28 <lambdabot> Done.
20:16:34 <aavogt> @list
20:16:34 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
20:16:38 <hamishmack> It is still really really incomplete
20:16:46 * monochrom now racks his brain what does @ft do that produces "Done"
20:16:57 <hamishmack> It does not support functions needed for autocomplete yet
20:17:18 <BMeph> @help ft
20:17:19 <lambdabot> ft <ident>. Generate theorems for free
20:17:21 <gwern> deech: oh, maybe it loads each one, dumps them, and stores it in a database
20:17:21 <hamishmack> and it is hard coded to use the Yi vim bindings
20:17:31 <aavogt> @ft map
20:17:32 <lambdabot> Done.
20:17:57 <deech> hamishmack: Where is the "Yi" preference setting? I have leksah open now and I don't see it.
20:17:59 * BMeph puts a li'l english on monochrom's brain - thanks for the rack... ;
20:17:59 <tensorpudding> lemmas for nothing, and your theorems for free
20:18:29 <hamishmack> At the bottom of the Editor page
20:18:46 <hamishmack> But it only works if you built Leksah with -f yi
20:19:22 <gwern> tensorpudding: clever parody of the christian rock band AD/BC, 'kindly deeds'
20:19:25 * gwern likes it
20:19:30 <deech> hamishmack: I see it now. With the big fat "Experimental (could wipe your files)"
20:19:35 <wavewave> hmm: my yi compilation again failed.
20:19:39 <deech> unsafeYIIO
20:19:47 <wavewave> :(
20:20:24 <hamishmack> deech: Yes its only 25% done I would say
20:20:34 <wavewave> seems some name conflict..
20:20:35 <gwern> wavewave: are you going to say what the error was or what?
20:20:49 <wavewave> Yi.Keymap.output vs Gtk.output
20:21:12 <wavewave> Ambiguos occurrence `output'
20:21:20 <deech> hamishmack: too beta for my blood :) But nice to know it's being worked on.
20:21:51 <wavewave> It happened when it compiles Yi.UI.Pango.Control .
20:23:04 <wavewave> maybe I can just comment out some import in the source code?
20:23:54 <pastorn> how do i cast a Word32 which i used Data.Binary into a Float?
20:23:58 <pastorn> unsafeCoerce?
20:24:02 <pastorn> or is there a better way?
20:24:06 <Saizan> wavewave: it'd make more sense to add an "hiding (control)" somewhere.
20:24:28 <Saizan> "which i used Data.Binary"?
20:24:40 <wavewave> Saizan: that's right. I will try and come back.
20:25:18 <hamishmack> wavewave: oops I think that might be my fault
20:26:20 <wavewave> hamishmack: you are developing Yi?
20:27:02 <hamishmack> wavewave:  Yi.UI.Pango.Control is the interface I am making for Leksah to use
20:28:00 <wavewave> okay, I succeeded in.
20:28:09 <pastorn> greedo: soon...
20:28:17 <wavewave> import Graphics.UI.Gtk as Gtk hiding(Action, Point, Region, get,output)
20:28:41 <greedo> pastorn: yeah, I reading up on Data.Binary
20:28:43 <wavewave> I hid output.. in Control.hs
20:29:01 <wavewave> yi/src/Yi/UI/Pango/Control.hs
20:29:05 <pastorn> greedo: doesn't it seem cool?
20:29:13 <wavewave> it passed  compilation.
20:29:15 <wolgo> hey I have a question
20:29:20 <pastorn> wolgo: shoot!
20:29:28 <greedo> pastorn: I just don't understand this runGet thing
20:29:32 <wolgo> I want to create a parser for arithmetic expressions
20:29:39 <wolgo> so I can get a handle on IO
20:29:45 <kmc> pastorn, this is the kosher way: http://hackage.haskell.org/package/data-binary-ieee754
20:29:46 <wolgo> and implement some common data strctures
20:30:12 <wolgo> I would like to implement basic algebra support
20:30:12 <greedo> wolgo: i have an example of that in my book
20:30:17 <wolgo> which one
20:30:21 <pastorn> kmc: i found an instance of Get Float in Data.Binary
20:30:26 <kmc> oh
20:30:35 <greedo> wolgo: Programming in Haskell, Hutton
20:30:58 <kmc> pastorn, i actually benchmarked a bunch of ways of casting Word64 <-> Double while keeping the bits the same
20:31:10 <kmc> unsafeCoerce was the fastest but very dodgy
20:31:17 <carpdiem> any idea why the following would generate a "parse error on input `:'" ?
20:31:19 <kmc> because you have no guarantee that a Word64 closure and a Double closure look the same
20:31:32 <pastorn> kmc: hehe... is there a sanity check for Float?
20:31:32 <kmc> "unsafeCoerce# :: Double# -> Word64#" is a better idea, and the same speed
20:31:32 <carpdiem> tackOnToList list "-" = getContents >>= (\input input:list)
20:31:36 <pastorn> like... isWellFormedFloat?
20:31:54 <pastorn> @hoogle Float -> Bool
20:31:55 <lambdabot> Prelude isDenormalized :: RealFloat a => a -> Bool
20:31:55 <lambdabot> Prelude isIEEE :: RealFloat a => a -> Bool
20:31:55 <lambdabot> Prelude isInfinite :: RealFloat a => a -> Bool
20:32:03 <altmattr> > 5
20:32:04 <lambdabot>   5
20:32:08 <Saizan> carpdiem: you forgot a ->
20:32:08 <altmattr> > mkQ 1 ((\x -> 2)::Char -> Int) :: (Typeable a => a -> Int)
20:32:09 <pastorn> kmc: which one?
20:32:10 <lambdabot>   {()->1}
20:32:20 <kmc> pastorn, what?
20:32:21 <carpdiem> @saizan, ahh, thanks!
20:32:21 <lambdabot> Unknown command, try @list
20:32:31 <mle-lucca> Word64  / unsafeCoerce# might be endian-dependent
20:32:38 <wavewave> heck.. it just failed at the last moment.
20:32:44 <mle-lucca> and yeah, I know no one cares about other architectures anymore, but stilllll.
20:32:45 <pastorn> kmc: my hoogle search... should i use 'isIEEE'? and what's 'isDenormalized'?
20:32:49 <wavewave> some package failed to install
20:32:50 <kmc> pastorn, no idea
20:32:56 <wavewave> ExitFalure 9
20:32:58 <Veinor> philosophical question: i'm going to write a RSS feed parser library
20:32:58 <Axman6> 27**(1/3)
20:33:02 <Axman6> > 27**(1/3)
20:33:03 <lambdabot>   3.0
20:33:11 <kmc> mle-lucca, all it does is pretend your architecture's native representation for Word64 is its native representation for Double
20:33:28 <Veinor> to do so, I need to use an XML library. HXT is nice, and I know it, but it has the problem that anything that uses it compiles to like 10 MB
20:33:58 <gwern> Veinor: xml-light, and don't we already have rss parsers?
20:34:00 <mle-lucca> kmc: which is great, but the resulting Word64's aren't portable between systems, so mucking with the bits in them is a bad idea.
20:34:12 <altmattr> @type mkQ 1 ((\x -> 2)::Char -> Int) :: (Typeable a => a -> Int)
20:34:13 <lambdabot> forall a. (Typeable a) => a -> Int
20:34:15 <kmc> mle-lucca, yeah, it shouldn't be used for actual serialization
20:34:16 <Saizan> does anything that uses xml actually care about binary size?
20:34:24 <altmattr> lambdabot? why won't ghci do that?
20:34:33 <Saizan> i don't think you'd be parsing rss feeds on an embedded system
20:34:39 <altmattr> anyone else have an idea :)
20:34:44 <Veinor> gwern: it looks like we only have an rss generator
20:34:52 <wavewave> yi itself was compiled.
20:34:53 <monochrom> My program using HXT is only 4MB.
20:34:58 <kmc> Saizan, arduino kiddies will
20:35:03 <Veinor> monochrom: really? hm
20:35:05 <Sgeo_> Scala's flip looks ugly
20:35:05 <monochrom> 3999412 to be exact.
20:35:09 <Veinor> anyway
20:35:12 <Sgeo_> But maybe I should learn Scala before judging
20:35:16 <Veinor> is it stripped?
20:35:23 <monochrom> Yes
20:35:26 <Veinor> ahh
20:35:35 <Veinor> yeah, if you strip and gzip it compresses down to like, a couple megs
20:35:36 <Saizan> altmattr: you might need to import some modules in your ghci
20:35:44 <monochrom> I don't gzip. Just strip
20:35:50 <altmattr> Saizan: done that
20:35:57 <monochrom> Just for the record, disputing misinformation.
20:36:01 <Saizan> altmattr: what error do you get?
20:36:04 <altmattr> Saizan: a restart has done the job :/
20:36:09 <Veinor> er, yeah
20:36:10 <Veinor> anyway
20:36:27 <Veinor> my point is that if you want to distribute a program compiled against it to a non-haskell crowd, you have to give them binaries
20:36:30 <wavewave> yi is compiled, but installation failed to copy the binary file to my .cabal directory.
20:37:06 <wavewave> I can run my yi from my source directory but I cannot enter text since some keymap is not installed.
20:37:12 <Veinor> although... I don't think a 2-meg, or even 4-meg binary is horrible
20:37:27 <wavewave> "Keymap not defined, 'q' to quit, 'h' for help"
20:37:48 <Veinor> oh hey, we do have an RSS library
20:37:50 <Saizan> wavewave: try the h route.
20:37:59 <Veinor> called feed
20:38:03 <hamishmack> wavewave: perhaps you sudo your last install?
20:39:00 <wavewave> so yi needs system-wide install?
20:39:09 <hamishmack> no
20:39:10 <Saizan> it doesn't
20:39:35 <hamishmack> wavewave: but it if your old install was owned by root
20:39:37 <wavewave> hmm. I didn't use sudo at all. what makes that failure?
20:39:49 <Saizan> wavewave: what error did you get, specifically?
20:39:55 <wavewave> okay.. let me see.
20:40:22 <pastorn> greedo: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24843#a24843
20:40:23 <hpaste>  incomplete .class parser (pastorn)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24843
20:40:29 <wavewave> Linking dist/build/yi/yi ...
20:40:30 <wavewave> cabal: Error: some packages failed to install:
20:40:48 <wavewave> yi-0.6.2.2 failed during the building phase. The exception was:
20:40:49 <wavewave> ExitFailure 9
20:40:54 <wavewave> that's it.
20:41:03 <gwern> new one on me
20:41:28 <dcoutts_> exist code 9 is SIGKILL
20:41:30 <dcoutts_> exit
20:41:43 <Veinor> wavewave, how much memory do you have?
20:41:53 <dcoutts_> most likely the OOM killer killed the linker
20:42:05 <wolgo> sorry back
20:42:09 <greedo> pastorn: thank you, how did you end up finding the magic number?
20:42:18 <pastorn> it was in the spec
20:42:24 <wolgo> greedo: you wrote that book?
20:42:30 <pastorn> greedo: 4.1
20:42:45 <wavewave> oh it succeeded!!
20:42:54 <wavewave> I just erase old yi binary in ./cabal/bin
20:43:00 <pastorn> "The magic item supplies the magic number identifying the class file format; it has the value 0xCAFEBABE."
20:43:10 <Veinor> I love hex magic numbers
20:43:14 <wavewave> then reran cabal again... then succeeded.
20:43:19 <wavewave> :) happy happy
20:43:21 <wolgo> I also want to make a roguelike floor plan generator but I will wait  until I get some data structures under my noobie belt
20:43:23 <greedo> wolgo: no, Programming in Haskell by Graham Hutton
20:43:37 <Veinor> I want the PGP key DECA FBAD
20:43:48 <pastorn> greedo: try to stay clear of do-notation when you can
20:43:57 <pastorn> iirc using applicative style is faster
20:44:30 <wavewave> how can I make yi.hs?
20:44:37 <wavewave> any sample?
20:44:58 <mle-lucca> starting yi without it should make one for you
20:45:00 <greedo> pastorn: thanks for the advice, i've been using the do-notation a lot
20:45:22 <pastorn> greedo: it also leads to cleaner code :)
20:45:59 <pastorn> greedo: check my function 'getConstantPool'
20:46:04 <pastorn> case 3
20:46:19 <pastorn> that's nice looking code... try to keep it that way if you can
20:46:36 <pastorn> but for case 4 you have to do a sanity check...
20:46:58 <pastorn> then you *need* do-notation, otherwise you can't do tests on the variable
20:47:15 <greedo> pastorn: http://pastebin.com/Ab4N1RWp
20:47:36 <greedo> my friend started this
20:47:50 <Saizan> pastorn: what makes you think that using applicative operators results in faster code, for Get?
20:48:04 <wavewave> hmm..... yi runs but I cannot still enter text...
20:48:11 <pastorn> i dunno... i heard someone say something about it once...
20:48:16 <pastorn> maybe they were lying
20:48:35 <Saizan> were they specifically talking about the Get monad?
20:48:49 <pastorn> nope
20:48:53 <wavewave> for vty frontend, I can do that..
20:48:55 <pastorn> was probably some other monad...
20:49:03 <wavewave> but not for gtk frontend.
20:49:06 <wavewave> hmmm :(
20:49:34 <pastorn> Saizan: or maybe it was the applicative parsers vs. monadic parsers
20:50:05 <Saizan> ah, ok, in general it's true that defining (<*>) directly you can do some optimization, but for Get you've (<*>) = ap, so it's just implemented in terms of >>=
20:50:23 <pastorn> Saizan: oh, ok :)
20:50:51 <pastorn> wavewave: i couldn't install yi either :(
20:51:13 <pastorn> derive-2.3.0 depends on haskell-src-exts-1.6.1 which failed to install.
20:51:21 <Saizan> and parsers that don't support a monadic interface at all can in general do some more in-depth analysis of the grammar statically
20:51:57 <wavewave> finally succeeded!!
20:52:13 <wavewave> I downloaded yi.hs from yi wiki.
20:52:39 <wavewave> I uncommented  import Yi.UI.Pango (start) in yi.hs.
20:52:53 <wavewave> Now I can enter text in gtk mode.
20:53:01 <dcoutts_> Saizan, pastorn: applicative Get/Put could potentially be faster by merging range checks, it does not currently do that however (my early prototype did)
20:53:04 <wavewave> pastorn: you can do it. :)
20:53:30 <pastorn> wavewave: did you have trouble with src-exts as well?
20:54:22 <wavewave> pastorn: not that one.
20:54:27 <pastorn> aww
20:54:41 <pastorn> i did cabal install yi -fgtk
20:55:09 <wavewave> pastorn: today's lesson.. do not install from hackage..
20:55:18 <pastorn> haha
20:55:28 <wavewave> pastorn: I downloaded it using darcs.
20:55:39 <pastorn> oh, ok
20:55:52 <wavewave> pastorn: I needed to change the source code a little bit.
20:56:20 <pastorn> wavewave: heh... as any user friendly program should require :D
20:56:42 <wavewave> import Graphics.UI.Gtk as Gtk hiding(Action, Point, Region, get,output)
20:57:00 <wavewave> in yi/src/Yi/UI/Pango/Control.hs
20:57:21 <wavewave> pastorn: erase your old binary file in .cabal/bin/
20:57:55 <wavewave> uncomment import Yi.UI.Pango (start) in yi.hs in ~/.yi/
20:58:25 <wavewave> pastorn: that's it.. btw I have to leave this coffeshop right now. it's closing time.
20:58:27 <carpdiem> what would make something appear as a different type in the interpreter than in compiled code?
20:58:30 <pastorn> wavewave: don't have one
20:58:32 <dcoutts_> wavewave: what problem requires deleting the old binary?
20:58:34 <pastorn> this is my first install
20:58:55 <wavewave> dcoutts_: I do not know why it happened.
20:59:13 <wavewave> by the way, I need to leave just now.. see you guys.
20:59:18 <dcoutts_> wavewave: I think your ld problem were with memory, not the presence of the old binary
20:59:32 <dcoutts_> I suspect it was just coincidence
20:59:46 <applicative>  carpdiem: is this a trick question
20:59:48 <carpdiem> i'm trying to track down a "couldn't match expected type IO b against inferred type [String]" error on the following code
20:59:52 <wavewave> dcoutts_: I see. I will inspect it. Thx.
21:00:26 <carpdiem> tackOnToList list "-" = do
21:00:31 <carpdiem> input <- getContents
21:00:35 <carpdiem> (lines input) ++ list
21:01:00 <carpdiem> applicative: nope, it's just when i try to execute that code in the interpreter, checking with :t
21:01:15 <aavogt> the last line carpdiem
21:01:16 <carpdiem> i get [String] for :t (lines input)
21:01:33 <aavogt> you probably want   return $ lines input ++ list
21:01:40 <aavogt> or whatever else you want to do with that stuff
21:01:54 <carpdiem> hrm... ok, i'll try that
21:05:11 <applicative> @type getContents
21:05:12 <lambdabot> IO String
21:05:45 <Cale> carpdiem: ghci automatically applies the 'print' function to anything which isn't an IO action
21:06:17 <applicative> Cale, but the mystery was that he says it compiles..
21:07:06 <wolgo> I am using RWH. There is a definition for a tree type: data Tree a = Node a etc etc
21:07:09 <wolgo> what is the a for?
21:07:24 <wolgo> an argument variable?
21:07:24 <blackdog> for the fruits of the tree
21:07:29 <Cale> wolgo: The type of elements held in the nodes of the tree
21:07:31 <tensorpudding> It represents the value.
21:07:31 <blackdog> you want to hold something in it, right?
21:07:41 <wolgo> blackdog: zomg froots
21:07:44 <wolgo> yeah
21:07:48 <wolgo> so it is just an argument
21:07:54 <wolgo> like Num a
21:08:09 <tensorpudding> It's an argument to the constructor Tree, yes
21:08:32 <wolgo> cool
21:08:37 <Cale> Somewhat like that. Num a is like a condition which could be true or false about the type a, while Tree a will be a separate type for each type a
21:09:16 <applicative> carpediem, i see.  you're saying, it seems to type check in the interpreter, but doesn't compile.
21:09:49 <carpdiem> cale, thanks
21:09:55 <applicative> carpediem, indeed the ghci is a somewhat odd world, you're deep in an IO structure.   It knows it will have to print
21:10:09 <carpdiem> applicative, yeah, but aarvgt's solution helped it out
21:10:55 <applicative> yeah it makes the last line an IO type
21:11:39 <carpdiem> applicative, so the interpreter strips the IO from the type?
21:11:59 <pastorn> compiling yi is pretty recource hungry...
21:12:00 <applicative> well what you gave it in the last line, doesn'thave an io type.
21:12:16 <applicative> carpdiem, but it was implied.
21:12:35 <carpdiem> i think i see
21:12:50 <pastorn> i can't even SSH into my machine that's compiling it anymore :/
21:13:08 <pastorn> (2 GB RAM + 2 GB swap)
21:13:14 <carpdiem> so, adding the "return $ (lines input) ++ list" makes it return a type "IO [string]"
21:13:30 <applicative> in a sense when in the ghci, you type 3 + 3 and then hit return, what it does is perform PRINT for the SHOW of the result of the caluculation, which is itself a number not a string.
21:13:42 <pastorn> greedo: you getting anywhere?
21:14:04 <greedo> yeah, slowly
21:14:06 <carpdiem> ok
21:14:35 <pastorn> greedo: can you use the code i wrote?
21:14:39 <applicative> carpdiem, so you could say it is adding IO to everything.   It's actually a little difficult to think about.
21:15:00 <carpdiem> is there any way to make it work while just returning a type "[String]" ?
21:15:14 <greedo> pastorn: i haven't tried it yet
21:15:18 <carpdiem> i'm still just barely getting used to the whole IO Monad thing
21:15:20 <applicative> not with do notation.  not in IO
21:15:42 <pastorn> greedo: you should just copy that incomplete parser i wrote and build off it
21:15:51 <applicative> actually do notation can be used with lists too, since the list types hook together to form a monad too
21:15:51 <pastorn> greedo: have you understood the run-thing yet?
21:16:03 <greedo> pastorn: yes, understand it better now
21:16:08 <carpdiem> all right, but what do you do if you need to go from type "IO [String]" to type "[String]" in another function call?
21:16:11 <pastorn> cool :)
21:16:32 <applicative> carpdiem, basically you can't do that
21:16:43 <greedo> pastorn: why are their so many cases under getConstantPool?
21:17:00 <pastorn> greedo: read the spec
21:17:14 <applicative> carpdiem, when you are writing the program, you don't know what the string will be.  so you program not with the string, but with the action of getting it.
21:17:24 <pastorn> i didn' build all the constructors for ConstantPoolEntry
21:17:34 <pastorn> there should be one for each case
21:17:34 <greedo> sure
21:17:51 <applicative> carpdiem, so the whole program has to take account of this,
21:17:57 <greedo> is this using parsec?
21:18:01 <carpdiem> applicative, i think i see
21:18:08 <greedo> just curious
21:18:19 <pastorn> greedo: no, this is using 'binary'
21:18:28 <greedo> cool
21:18:36 <pastorn> greedo: parsec is what you use for parsing stuff like source code
21:18:39 <carpdiem> but let's say that i'm trying to compile a big list of strings from multiple sources, and then sort that list
21:18:42 <greedo> ah
21:18:42 <pastorn> human readable stuff
21:19:08 <carpdiem> surely there's a way to still be able to use the sort function from Data.Lists after compiling the big list of strings from different inputs?
21:19:12 <applicative> carpdiem, but in another sense, of course, the do notation trick    do {contents <- getContents; rputStrLn . reverse $ contents} -- there you 'extract the string' as "contents"
21:19:13 <pastorn> greedo: http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#20080
21:19:48 <yuriks> hmm, why is it that I can runghc my program fine
21:19:55 <greedo> ah, thanks
21:20:04 <yuriks> but if I try to compile it with ghci it complains it's missing a .hi file for my module?
21:20:25 <pastorn> greedo: instead of just giving a [Word8] which the spec says it should be i give back parsed data
21:20:34 <pastorn> which is nicer
21:20:55 <yuriks> oh, nevermind, I need --make
21:20:59 <greedo> yeah, i'm using Word32
21:21:20 <pastorn> greedo: using the constructors makes it so that you can do a function that cases on what kind of stuff that are in the constant data
21:21:25 <pastorn> greedo: won't do
21:21:30 <pastorn> you should do like i do
21:21:45 <carpdiem> applicative, ok, so you'd have to use the "<-" to get the list out of the IO monad then?
21:23:10 <pastorn> Is it normal that a computer hangs when compiling YI?
21:23:38 <pastorn> i seem to have gotten stuck at 'Compiling Language.Haskell.Exts.InternalParser'
21:25:04 <applicative> carpediem, you don't exactly get it out.  you get an expression, that you can apply regular string functions to.
21:25:55 <carpdiem> applicative, ok, i see the distinction there
21:26:03 <applicative> carpediem, but you can only do this, because in the end you are going to apply a function that brings everthing back into an IO value
21:26:41 <applicative> carpdiem, consider the list monad, we can use it with lambdabot.
21:26:45 <applicative> > do { possible_values_of_getContents <- ["hahaha", "hohoho", hehehe", "hihihi"]; return . reverse $ possible_values_of_getContents}
21:26:46 <lambdabot>   <no location info>:
21:26:46 <lambdabot>      lexical error in string/character literal at end o...
21:26:56 <applicative> woops
21:27:49 * pastorn is worried his hard drive will explode
21:27:55 <greedo> ...
21:27:59 <greedo> really?
21:28:03 <pastorn> yes
21:28:06 <applicative> > do { possible_values_of_getContents <- ["hahaha", "hohoho", "hehehe", "hihihi"]; return . reverse $ possible_values_of_getContents}
21:28:07 <lambdabot>   ["ahahah","ohohoh","eheheh","ihihih"]
21:28:23 <pastorn> i'm guessing it's swapping, but the computer is totally unresponsive :/
21:28:29 * pastorn is using his laptop
21:28:41 <greedo> running *nix?
21:28:57 <applicative> carpdiem, (was missing a quote) -- here I don't get my hands on The String, and then apply 'reverse' to it, exactly
21:30:35 <pastorn> greedo: yes
21:30:44 <pastorn> though this irc session is on another computir
21:30:55 <greedo> ah
21:31:50 <greedo> good man
21:31:58 <pastorn> no, not really :(
21:32:15 <pastorn> i was watching a movie and not i can't because of swapping bonanza
21:32:22 <carpdiem> applicative, ok, i think i see what you're getting at
21:32:26 <applicative> carpediem, since there isn't anything that's THE STRING.  There's a number of strings, but I generate a sort of bound variable that ranges over all of them in my list, and then i attach "reverse" to that variable.  When I "return" I am back with a list of strings.
21:33:47 <pastorn> COOL!
21:33:50 <pastorn> it completed!
21:34:11 <carpdiem> applicative, ahh, ok
21:34:20 <applicative> carpdiem, when you actually run the program with IO, of course, there will be an actual string, so it will print it.  But you can't get your hands on it while programming -- anyway it's different strings different times you run the program.
21:35:22 <carpdiem> applicative, so there's one more related bit in this program that's giving me problems, where my follow-up questions are coming from
21:35:56 <carpdiem> applicative, out in main, I'm trying to use "bigList <- foldl tackOnTolist [] args"
21:36:41 <carpdiem> applicative, this is where the compiler is getting upset that tackOnToList returns type "IO [String]" rather than "[String]"
21:37:51 <carpdiem> applicative, is there any way to get around that?
21:39:13 <applicative> carpdiem, the problem is that when you repair it like aavogt said, you get an error here?
21:40:26 <carpdiem> applicative, yeah, it's complaining about expected type [String] matching against inferred type IO [String]
21:41:29 <carpdiem> applicative, tackOnToList has type [String] -> [String] -> IO [String]
21:41:34 <applicative> with aavogts revision it does return IO [String], but for your fold, you want it to be returning [String]
21:41:59 <pastorn> how do i fix this when installing yi? <command line>: cannot satisfy -package-id QuickCheck-2.1.0.3-c7b5f1e3b76c706567a383a74dea1b89
21:43:07 <applicative> i think you should make tackOnToList a pure function, why isn't it just    tackOnToList list input = lines input ++ list
21:43:53 <carpdiem> applicative, input is a filename that it then reads in, and tacks onto the list it was passed
21:44:11 <carpdiem> so args in the foldl line is a list of filenames
21:44:14 <applicative> carpdiem, this isn't about inputs, in particular of course, it's just that we're going to use it with inputs
21:45:09 <greedo> pastorn: this is what i got
21:45:12 <greedo> http://tamu.pastebin.com/fqfQm18U
21:45:23 <carpdiem> applicative, how's that now?
21:45:38 <pastorn> greedo: DUDE!
21:45:42 <pastorn> stop with the drop stuff
21:45:50 <pastorn> Get does taht automatically for you
21:46:07 <applicative> > let tackOnToList input list = lines input ++ list ; let args = "hahah, hohoho" in foldl tackOnToList args
21:46:08 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
21:46:22 <pastorn> greedo: just copy what i have instead... your code gives me a headache
21:46:26 <applicative> damn, syntax loser tonight
21:46:42 <greedo> oh, that B.drop part?
21:46:45 <applicative> > let tackOnToList input list = lines input ++ list ; args = "hahah, hohoho" in foldl tackOnToList args
21:46:46 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
21:46:46 <lambdabot>         against inferred type...
21:46:49 <pastorn> greedo: YES!
21:46:58 <applicative> > let tackOnToList input list = lines input ++ list ; args = "hahah, hohoho" in foldl tackOnToList [] args
21:46:59 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
21:46:59 <lambdabot>         against inferred type...
21:47:03 <greedo> could I improve that?
21:47:11 <pastorn> greedo: check the function 'getClass1'
21:47:16 <pastorn> here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24843
21:47:27 <applicative> carpdiem,sorry, I should be shot for not putting this past lambdabot privately.
21:47:41 <pastorn> it automagically gives you a value AND drops as many bytes as the value was
21:47:44 <dmwit> greedo: woooow
21:47:57 <pastorn> so that next time you use a get function you are at the right spot
21:47:57 <dmwit> greedo: There's a monad law that says do { a <- getWord32be; return a } === getWord32be
21:48:00 <carpdiem> applicative, no worries, you've been super helpful anyway
21:49:47 <applicative> anyway, my thought was that you should be -- its the conventional wisdom - be getting a lot of these definitions out of IO, then main = contents <- getContents; writeFile "blah.conf" (mymonsterpurefunction contents)
21:49:59 <greedo> dmwit: oh, really?
21:50:00 <pastorn> greedo: the reason i made the datatype Class1 is that no matter what you've gotten before that, the first section will ALWAYS have the same format
21:50:13 <applicative> carpdiem, except of course there I forgot the 'do'.
21:50:30 <dmwit> greedo: yarly
21:50:33 <pastorn> it's not until you get to the constant_pool that you need to know what you've read
21:50:46 <edwardk> preflex: xseen tibbe
21:50:46 <preflex>  tibbe was last seen on freenode/#ghc 2 days, 13 hours, 51 minutes and 57 seconds ago, saying: JaffaCake: How about this: "1. I discovered the workaround more or less my accident while trying to solve a different problem. I only later understood the problem it actually solved."
21:50:46 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
21:51:39 <edwardk> @tell alpounet looks like you got it
21:51:39 <lambdabot> Consider it noted.
21:53:18 <greedo> pastorn: there is nothing to open the file with?
21:53:32 <pastorn> greedo: check in Data.ByteString
21:53:39 <pastorn> greedo: and check my Targa loader
21:53:41 <pastorn> i use it there
21:54:07 <pastorn> it's probably called readFile, that's why i have that qualified import
21:54:27 <greedo> can i just throw it into main
21:54:43 <pastorn> greedo: yes
21:55:43 <pastorn> main = do { bs <- BS.readFile "myClass.class"; c <- runGet getClass bs; printStuff c; }
21:56:03 <wolgo> is thunk pronounced T-hunk or thunk?
21:56:08 <greedo> i need to pass in args
21:56:19 <greedo> (args:_) <- getArgs
21:56:31 <pastorn> greedo: well, whatever
21:56:40 <greedo> ok, i see
21:57:12 <pastorn> main = do { (fp:_) <- getArgs; bs <- BS.readFile fp; c <- runGet getClass bs; printStuff c; }
21:57:18 <edwardk> thunk
21:58:12 <blackdog> edwardk: recursive and non-productive definition, that
22:01:28 <edwardk> blackdog: was thinking the same =)
22:03:59 <kevinulin> if i do "return (a+b) >>= forkIO f" is the (a+b) always executed prior to the forkIO?
22:04:10 <kmc> kevinclark, (a+b) is not executed
22:04:13 <kmc> because it's not an IO action
22:04:34 <kmc> "execute" means to carry out an IO action.  "evaluate" means to compute on function applications and get a value
22:04:53 <kmc> (return x >>= f) is equivalent to (f x)
22:04:57 <kmc> that's a monad law
22:05:33 <kevinulin> so if i want to require that something is created before the thread is started where should I look? I am creating a unique ID outside of the thread, or trying to
22:05:35 <edwardk> kevinulin: this is where the interpretation that a monad is about ordering of effects gets you. (a + b) is just a deferred computation. regardless of the use of a monad, or anything
22:05:47 * BMeph says: Who'da thunk it? ;
22:05:52 <edwardk> forkIO f $! a + b
22:06:02 <pastorn> BMeph: www.instantrimshot.com
22:06:08 <Zao> edwardk: Depending on what + means, of course.
22:06:14 <edwardk> Zao: of course
22:07:05 <greedo> pastorn: hmm, printStuff?
22:07:11 <edwardk> let apb = a + b in rnf apb `seq` forkIO f apb
22:07:21 <pastorn> greedo: yeah... well, your code looks like shit
22:07:27 <pastorn> and you do prints everywhere
22:07:48 <greedo> Cortar: see
22:07:56 <BMeph> pastorn: Thank you very much, I'll be here all week - try the veal! :)
22:07:59 <pastorn> greedo: first do all the parsing into one big structure, THEN do all your printing
22:08:17 <kevinulin> i thought "a >>= b" was just short hand for "do a' <- a; b a"
22:08:23 <Cortar> greedo: Well I could have told you that, I blame our teacher not actually teaching any haskell
22:08:37 <kmc> kevinulin, >>= is the more fundamental form
22:08:38 <kmc> "do" is sugar
22:08:58 <edwardk> Zao: or hrmm.... f $!! x = everything seq (`seq`()) x `seq` f x
22:08:59 <kmc> what edwardk is correct but it's probably solving the wrong problem for you
22:09:02 <greedo> pastorn: me and Cortar are working on the same thing
22:09:04 <edwardk> kmc: yeah
22:09:16 <kmc> kevinulin, you should not depend on the order of evaluation for program correctness, period
22:09:20 <kmc> that's why we have "do" and >>=
22:09:25 <pastorn> greedo: why did you do all the drop stuff? why not just build on this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24843
22:09:27 <kmc> they define the order of *execution*
22:09:31 <kmc> which is a different thing from evaluation
22:10:03 <kevinulin> ya, but its a battle
22:10:07 <kmc> kevinulin, what do you want to use these IDs for?
22:10:25 <kmc> often thread IDs are used for communication
22:10:43 <Cortar> pastorn: we did that bc we were using getWord16be but everytime I used it, it just got the same thing
22:10:49 <dmwit> Hm, are we doing people's homework these days?
22:10:57 <kmc> but it's not necessary in Haskell, because Chan and MVar are first-class values
22:11:00 <pastorn> Cortar: haha
22:11:03 <kevinulin> im creating a map of connected clients to a server, and i want to create the clientID outside of a thread i spawn to manage the handle reading and writing
22:11:11 <pastorn> well, you need to use them in sequence
22:11:24 <monochrom> I like doing people's homework. I like to build webpages to do people's homework automatically.
22:11:28 <pastorn> Get drops stuff automagically
22:11:36 <kmc> kevinulin, ok.  where do the IDs come from?
22:11:45 <pastorn> but if you do this:
22:11:47 <kevinulin> i just take the max mapid and increase it atm
22:11:50 <kevinulin> i mean max map key
22:11:54 <kmc> ah
22:12:08 <pastorn> do { a <- runGet getWord16be bs; b <- runGet getWord16be bs }
22:12:16 <pastorn> then a == x
22:12:18 <greedo> monochrom: our prof is crazy
22:12:19 <pastorn> *a == b*
22:12:22 <pastorn> Cortar: ^^^
22:12:49 <Cortar> pastorn: ya thats exactly what I was doing
22:12:59 <pastorn> yeah... bs doesn't change...
22:13:05 <dmwit> (a, b) <- runGet (do { a <- getWord16be; b <- getWord16be; return (a, b) }) bs -- the right way, Cortar
22:13:09 <pastorn> you can't manipulate data in haskell
22:13:13 <Cortar> i noticed
22:13:17 <pastorn> haha
22:13:19 <pastorn> :p
22:13:41 <kmc> kevinulin, something like:   let myID = succ (findMax threadMap) in forkIO ( ..... stuff using myID here .... )
22:13:43 <pastorn> Cortar: that's why you should place *everything* in one big get-function, composed of many smaller get-functions
22:13:52 <dmwit> Cortar: Notice that there's only one runGet.
22:14:11 <kmc> kevinulin, then you have to insert into the map and make sure to use the new map the next time
22:14:13 <pastorn> yeah... check my *WORKING* targa loader
22:14:27 <Cortar> ok, that makes sense
22:14:29 <kmc> kevinulin, but i'm not sure what the IDs are needed for
22:14:32 <kmc> does the protocol require them?
22:14:48 <greedo> Cortar: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24841
22:15:03 <greedo> that's his targa loader
22:15:43 <kevinulin> theres no specific protocol im trying to implement, its just sort of me playing with haskell and trying to make something complex at the same time
22:15:58 <kmc> kevinulin, ok
22:16:16 <kevinulin> i was just wondering how i could create a value in one thread and be certain the value was set prior to the creation of a sub thread
22:16:27 <kmc> kevinulin, why do you care?
22:16:32 <kmc> values don't get "set"
22:16:36 <kmc> a value is an immutable thing
22:16:37 * Axman6 was wondering the same thing
22:16:40 <kmc> when did 3 get set?
22:16:42 <kevinulin> well 'claimed' i gues
22:16:52 <kevinulin> i dont want 2 threads to try to put the same key in the map table
22:17:00 <kmc> kevinulin, how are you sharing the map between threads?
22:17:10 <kmc> kevinulin, typically you might put it in an MVar
22:17:25 <kevinulin> and it seems that with tvars, you can be sure that you can read the value without it being modified, but you cannot be certain that your writeTVar will happen before someone else changes it
22:17:27 <kmc> in which case only one thread can "take" it at any given time
22:17:48 <kmc> kevinulin, the point of STM is that, if two threads interfere like that, one will revert and retry
22:17:53 <kmc> that's what "atomically" means
22:17:56 <kmc> atomically :: STM a -> IO a
22:18:04 <greedo> pastorn: thanks for the help
22:18:06 <kmc> it makes sure that all the stuff in the STM action goes through "at once"
22:18:18 <kmc> kevinulin, did you read the concurrency and STM chapters in Real World Haskell?
22:18:19 <pastorn> greedo: is your code prettier now?
22:18:37 <kevinulin> maybe i do not understand the scope of atomically, because if i do: x <- atomically $ readTVar v
22:18:54 <kmc> anyway, caring about when (2+3) is reduced to 5 is the wrong way to approach this problem
22:18:56 <kevinulin> then atomically $ writeTVar x 1234  40 min later
22:18:59 <greedo> pastron: it's getting there
22:19:06 <Axman6> getNewID :: MVar IntSet -> IO Int; getNewID mv = set <- takeMVar mv; let newID = succ (findMax set); set' = insert newID set; putMVar mv set'; return newID
22:19:06 <kmc> kevinulin, only the stuff inside a single call to atomically is atomic
22:19:12 <Axman6> with a do
22:19:19 <kmc> atomically $ do { x <- readTVar v;  writeTVar v (x+3) }
22:19:33 <kmc> STM would be pointless if you only used atomically directly on primitives like readTVar and writeTVar
22:19:38 <c_wraith> if you're only doing one read or write within an atomically, you might as well be using an IORef
22:19:41 <kmc> i strongly recommend the RWH chapter on STM
22:19:51 <kmc> best intro i've seen by far
22:19:57 <kevinulin> oh i see, i did not realize it could contain do, thats my whole problem
22:19:57 <kmc> http://book.realworldhaskell.org/read/software-transactional-memory.html
22:20:08 <kmc> kevinulin, "do" is just syntax
22:20:18 <kmc> a "do" block contains statements, but the "do" block itself is an expression
22:20:22 <Axman6> kevinulin: everything that happens inside atomically is an atomic action. if you do atomically f; atomically y, then f and y are not run in an atomic action, but atomically (f >> y) is
22:20:24 <kmc> so it can be passed as an argument to a function
22:20:25 <dmwit> pastorn: That's code for "I went and did it all with drop and foldr and SCREW you, Get monad!" ;-)
22:21:06 <kmc> kevinulin, of course we can also say:  atomically (readTVar v >>= (writeTVar v . (+3)))
22:21:08 <kevinulin> ya i see, i just find myself forgetting the easy stuff
22:21:12 <kmc> not using "do", but it's the same thing
22:21:15 <pastorn> hehe
22:21:24 <kmc> kevinulin, probably because it's easy in Haskell but hard or impossible in most languages
22:21:26 <kevinulin> sorry dumb question
22:21:32 <kmc> not at all, no worries
22:21:32 <dmwit> kevinulin: Don't worry, before long, you'll find yourself forgetting the hard stuff, too.
22:21:49 <kmc> most developers aren't used to the level of freedom we have
22:21:52 <kevinulin> i plan to never know the hard stuff to begin with
22:21:53 <Axman6> kevinulin: http://en.wikipedia.org/wiki/Haskell_features#STM_monad
22:22:00 <Axman6> uh
22:22:14 <Axman6> kevinulin: http://en.wikipedia.org/wiki/Concurrent_Haskell
22:22:15 <kmc> er, "Haskell 98 features", "ST monad"?
22:22:17 <kmc> that's wrong
22:22:21 <kmc> ST requires RankNTypes
22:22:35 <Axman6> kmc: fix it!
22:22:44 <kmc> lazy
22:23:00 <kmc> err it only requires Rank2Types really
22:24:39 * Axman6 is quite proud of the STM section on http://en.wikipedia.org/wiki/Concurrent_Haskell
22:25:16 <Axman6> annoyingly it got moved from the Haskell (Programming Language) page, so the history of me writing it is gone
22:25:27 <ezyang> byorgey needs more google juice. when I google "byorgey species" his blog is, like, the fifth result
22:29:51 <wavewave> i have a question. how can i set yi editor to show unicode for haskell code?
22:30:21 <wavewave> \x  to lambda x, -> to arrow..
22:30:48 <wavewave> \join #yi
22:31:43 <pastorn> wavewave: there you are
22:32:00 <wavewave> pastorn: yes, I came back home.
22:32:15 <pastorn> wavewave: did you get any weird quick check errors?
22:32:25 <pastorn> <command line>: cannot satisfy -package-id QuickCheck-2.1.0.3-c7b5f1e3b76c706567a383a74dea1b89
22:32:41 <wavewave> pastorn: no..
22:32:51 <pastorn> amgagad fail...
22:32:53 <kmc> hmm, strange idea
22:32:58 <kmc> since everyone wants more monad tutorials
22:33:11 <kmc> has anyone written "monads are generalized list comprehensions"?
22:33:11 <pastorn> kmc: what idea?
22:33:27 <tensorpudding> i want a monad tutorial written in lojban
22:33:31 <kmc> list comprehensions are a pretty well-liked idea
22:33:37 <kmc> and are considered practical and reasonable and complete
22:33:42 <kmc> and understandable by mere mortals
22:33:47 <ezyang> kmc: I think lots of people have alluded to it.
22:33:48 <kmc> monads are considered none of that
22:34:01 <ezyang> but I haven't seen one with that particular angle
22:34:15 <tensorpudding> but monads are practical, reasonable and understandable by mortals
22:34:15 <ezyang> In particular, you still have to convince people that generalizing over list comprehensions is worthwhile.
22:34:22 <kmc> tensorpudding, yes
22:34:35 <kmc> but nobody thinks that until they've been converted to our side ;P
22:34:37 <tensorpudding> it's just hard to motivate it in full generality until the person totally understands
22:34:56 <kmc> "monads are generalized list comprehensions" might get through to the many people who like python but think haskell is too hard to be worth the effort to learn
22:35:21 <ezyang> Oh, I think someone wrote something about making the maybe monad with list comprehensions
22:36:52 <wavewave> pastorn: which version of ghc are you using?
22:37:15 <pastorn> The Glorious Glasgow Haskell Compilation System, version 6.12.1
22:37:55 <wavewave> pastorn: does it compile to the end and quick check?
22:38:13 <pastorn> huh?
22:38:25 <wavewave> pastron: when is it stuck?
22:38:45 <hpaste>  . (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24844
22:38:51 <pastorn> wavewave: ^^
22:40:23 <wavewave> do you have QuickCheck installed?
22:41:00 <wavewave> pastorn : cabal info QuickCheck
22:41:05 <kmc> @remember LukePalmer ...when you use an advanced feature, you need a yet more advanced feature to abstract over it... But all you need to abstract over a function is another function.
22:41:05 <lambdabot> Done.
22:41:23 <wavewave> pastorn: mine shows 2.1.0.3 is installed.
22:41:24 <Axman6> .. hpaste? :o
22:41:27 <edwardk> kmc: good one
22:41:40 <cvk> Hi
22:41:42 <ezyang> +1
22:41:47 <ezyang> cvk: 'allo
22:42:05 <kmc> yeah that stuck with me
22:42:07 <kmc> from http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
22:42:15 <pastorn> wavewave: reload that paste
22:42:29 <aavogt> what is with all these provocative haskell blog posts
22:42:45 <aavogt> it looks like everybody is out there saying xyz is completely wrong
22:42:46 <kmc> tl;dr is "don't use typeclasses just because you forgot you can put functions in records"
22:42:56 <cvk> Hello. I am just starting to learn Haskell..
22:43:06 <kmc> cvk, you're in the right place :)
22:43:13 <cvk> looks to be a great language. Thanks :)
22:43:19 <Axman6> it sure is
22:43:23 <Axman6> with a great community
22:43:30 <Axman6> which you just found. LEVEL UP!
22:43:31 <aavogt> preaching to the choir though
22:43:45 <kevinulin> cvk please dont learn faster than me
22:43:59 <pastorn> cvk: how are you learning? do you have a goal of some sort or are you just playing?
22:44:01 <kmc> haha kevinulin
22:44:04 <cvk> I was just curious to know if for a Functional Programming newbie, Haskell, Scheme or Lisp would be better?
22:44:14 <Axman6> haskell
22:44:18 <cvk> Pastorn: I am just interested.. :)
22:44:20 <kmc> cvk, Haskell has a lot of concepts not present in Scheme or LISP
22:44:22 <Axman6> it forces you to think the right way
22:44:23 <kmc> cvk, notably, static types
22:44:29 <pastorn> cvk: we might be a bit biased...
22:44:46 <pastorn> cvk: what are you interested in?
22:44:46 <kevinulin> haskell is the best, scheme and lisp are purely academic, ml/ocaml if you for some reason refuse to use haskell
22:44:49 * ezyang learned Scheme as his first functional language 
22:44:58 <ezyang> but Haskell really solidified a lot of concepts for me.
22:45:02 <cvk> kmc: Oh.. no problem at all. :)  With a great community like this, learning is pleasure :)
22:45:09 <cvk> Great!
22:45:13 <kmc> cvk, Scheme is a tiny, beautiful language.  it is very flexible and the dark side of that is that there's very little structure keeping you from writing nonsense
22:45:15 <pastorn> cvk: like... what sorts of applications do you hope to build?
22:45:21 <kmc> static types provide that structure for Haskell
22:45:33 <kmc> i think that everyone should learn Scheme although it's not very useful for practical things
22:45:36 <cvk> @pastorn: Nothing specific in mind...
22:45:37 <lambdabot> Unknown command, try @list
22:45:40 <kevinulin> neither scheme or list are lazy are they?
22:45:44 <kevinulin> lisp i mean
22:45:46 <kmc> a great way to learn Scheme (and introductory CS for that matter) is this book: http://mitpress.mit.edu/sicp/full-text/book/book.html
22:45:49 <ezyang> kevinulin: You can add lazy extensions
22:45:50 <Axman6> cvk: no need for the @
22:45:52 <ezyang> but not by default
22:45:53 <cvk> i was just hoping to learn concepts of Functional Programming
22:45:56 <kmc> kevinulin, no, but you can make explicitly lazy values in any functional language
22:46:01 <edwardk> kevin: eli barzilay has a lazy scheme, but in general, no they aren't
22:46:03 <pastorn> kmc: have you seen fluxus?
22:46:04 <cvk> Axman6: Sure..
22:46:05 <kmc> cvk, in Haskell you will learn not only FP but also strong static typing
22:46:06 <solrize> cvk have you seen LYAH?
22:46:07 <kmc> pastorn, no
22:46:13 <solrize> @where lyah
22:46:13 <lambdabot> http://www.learnyouahaskell.com/
22:46:17 <pastorn> kmc: then stop saying scheme isn't useful :p
22:46:17 <cvk> solrize : no
22:46:29 <wavewave> pastorn: you had better download yi from darcs.
22:46:39 <kmc> pastorn, that's very cool
22:46:39 <cvk> lambdabot : thanks a lot
22:46:49 <kevinulin> hah, using atomically correctly has cut my code in half
22:46:51 <edwardk> #haskell is the only community i've ever seen this prone to tripping over themselves in a rush to help a newcomer ;)
22:47:14 <wavewave> darcs get --lazy http://code.haskell.org/yi/
22:47:27 <blackdog> @quote stereo
22:47:27 <lambdabot> LoganCapaldo says: * LoganCapaldo must resist urge to mention stereo
22:47:37 <edwardk> pastorn: ok, i'll say it ;)
22:47:38 <ezyang> byorgey is lamenting the inability to define nonregular species in his species-pearl. I wonder if such a facility would be useful in Haskell.
22:47:38 <kmc> edwardk, that's because we are True Believers
22:47:39 <pastorn> wavewave: wut?
22:47:48 <cvk> Thank you all :)
22:47:53 <wavewave> pastorn: I haven't succeeded in installing yi using cabal install yi.
22:47:56 <blackdog> hm. @quote majestic
22:48:05 <solrize> @quote majestic
22:48:05 <lambdabot> Anonycale says: Welcome to #haskell, where your questions are answered in majestic stereo!
22:48:07 <edwardk> ezyang: you can define them, you just need encapsulation over the effect of selecting a member
22:48:25 <pastorn> wavewave: i did solve this magic hash thingy once for another package... got help there though...
22:48:36 <blackdog> solrize: yeah, that one:) fat fingers today
22:48:49 <ezyang> edwardk: Yeah, so I'm wondering if that encapsulation is burdensome in practice.
22:49:16 <edwardk> ezyang: sadly, it is.
22:49:20 <cvk> Have a great day!! Thanks again. Will start reading the book now. :)
22:49:27 <wavewave> pastorn: i do not know what is going on with that magic hash thing.
22:49:28 <ezyang> edwardk: :-(
22:49:33 <ezyang> "we should fix it!"
22:49:47 <wavewave> pastorn: maybe some trick with ghc-pkg ?
22:50:15 <pastorn> maybe... ok, i have the source now
22:50:49 <pastorn> wtf?  can't find file: HackerMain.hs
22:51:12 <ezyang> hmm, I wonder what happens if you treat the generating function lazily
22:51:18 <ezyang> i.e. move laziness into the type system.
22:51:54 <aavogt> lazy type systems?
22:52:02 <aavogt> or something else?
22:52:03 <hpaste>  . (wolgo)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24846
22:52:08 <edwardk> ezyang: the generating function doesn't uniquely determine the type
22:52:14 <ezyang> aavogt: Something like that.
22:52:25 <ezyang> edwardk: Really?
22:52:36 <ezyang> aavogt: I'm sort of babbling right now.
22:53:24 <edwardk> ezyang: data Cotree a = Bin (Cotree a) (Cotree a) -- evaluate its generating function ;)
22:53:24 <aavogt> dynamic types are like lazy types: they don't show up until you force them
22:53:36 <aavogt> so I think you're on to something else
22:53:40 <pastorn> cvk: so have you gotten ghc installed yet?
22:53:51 <aavogt> *at runtime
22:53:56 <cvk> pastorn: Just installed it
22:53:57 <wolgo> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24846#a24846
22:54:07 <pastorn> cvk: go write hello world!
22:54:10 <wolgo> I want to represent a connection with another cell as a 0 or 1
22:54:21 <ezyang> aavogt: Hm, that's a good way of putting it.
22:54:33 <cvk> Sure!! :)
22:54:35 <edwardk> ezyang: codata screws you up, even in the presence of just data it simply says there exists an isomorphism, not that that isomorphism is at all sensible or useful
22:54:41 <pastorn> cvk: do you know any other languages?
22:54:56 <cvk> I know C, Java and some Python
22:55:09 <pastorn> cvk: you're in for a world of pain :)
22:55:12 <wolgo> cvk: I started with haskell.
22:55:16 <edwardk> ezyang: having the same generating function is necessary for two data types to be the same, but not sufficient
22:55:19 <wolgo> three days ago
22:55:21 <solrize> that's not too bad, just 3 languages to unlearn before haskell makes sense ;)
22:55:23 <ezyang> edwardk: Eew.
22:55:27 <kmc> solrize, haha
22:55:27 <cvk> pastorn: Oh :(
22:55:33 <pastorn> cvk: you should perhaps use this: http://www.haskell.org/~pairwise/intro/intro.html
22:55:33 <solrize> @quote unlearn
22:55:33 <lambdabot> monochrom says: Learning is unlearning. Intuition is experience. Understanding is feeling.
22:55:36 <ezyang> edwardk: I haven't yet figured out what codata is useful for yet
22:55:38 <kmc> at least Python has first-class functions
22:55:43 <kmc> so you won't be 75 years behind
22:55:49 <kmc> like the people who only know Java
22:55:52 <kmc> ;)
22:56:03 <edwardk> ezyang: ones = 1 : ones ;)
22:56:04 * ezyang found himself wanting coroutines in Java the other day... 
22:56:11 <cvk> pastorn: Oh.. Sure ... I ll read that.. thanks
22:56:17 <kevinulin> cvk dont read too much
22:56:18 <ezyang> Oh, that's codata? Cool.
22:56:32 <wolgo> after wasting an hour on a heap implementation and implementing the same thing in haskell in five minutes.
22:56:44 <aavogt> kmc: how does that matter so much? You can't write haskell in python very prettily
22:56:54 <cvk> pastorn: Actually, I started with Lisp a few days back , but dint get anywhere :(
22:57:34 <kevinulin> cvk, use http://www.haskell.org/haskellwiki/Learn_Haskell_in_10_minutes and ghci
22:57:39 <kevinulin> reading is boring and rots yer brain
22:57:43 <pastorn> cvk: haskell is like lisp, except you files will only load properly 1/20th of the time
22:57:56 <kevinulin> then make something you want to make, and when you get to a part you don't know, then read :)
22:58:04 <cvk> pastorn: Oh
22:58:38 <pastorn> cvk: you'll get type errors like never before :)
22:58:40 <edwardk> ezyang: codata vs. data is just the fact that you can build a (co)recursive structure without a base case.
22:58:40 <cvk> kevinulin: You are right.. I should get started with the book that was suggested.. Maybe ill learn soon too
22:58:49 <cvk> just hoping
22:58:55 <pastorn> cvk: but it's good, only good code will load
22:59:06 <pastorn> cvk: "if it typechecks - it works"
22:59:08 <ezyang> edwardk: doesn't the 1 in your ones case count as a sort of pseudo base case?
22:59:12 <cvk> pastorn: Ohh
22:59:21 <edwardk> ezyang: wrong, side. the base case would be the []
22:59:35 <pastorn> cvk: well, that's not ALWAYS true, but most of the times it is :)
22:59:35 <edwardk> er wrong side
22:59:45 <kevinulin> it depends on if yer using c libraries really :)
22:59:52 <ezyang> but... you never get there.
22:59:57 <edwardk> exactly
23:00:04 <cvk> pastorn : One last question, if you dont mind... Do you recommend me to learn Haskell or Scheme.?
23:00:10 <pastorn> haskell
23:00:25 <cvk> Given that i dont know anything in both..
23:00:37 <kmc> cvk, learn both
23:00:41 <kmc> they are complimentary but different
23:00:42 <ezyang> hmmmmmmmm
23:00:48 <edwardk> ezyang: productive corecursion says you get a new outermost constructor in a bounded amount of work as opposed to well-founded recursion which says you get the whole answer in a bounded amount of work
23:00:50 <pastorn> if you learn yourself a haskel (*baradish*) you'll get to learn more stuff, and scheme will probably be very easy for you when you know haskell
23:01:00 <cvk> kmc:oh..
23:01:21 <cvk> pastorn: Sure.. Ill start with Haskell then. :)
23:01:21 <ezyang> Time to reread Piponi's post o the matter!
23:01:36 <edwardk> data must therefore be finite, codata can be unbounded, as long as you can get to the next level eventually
23:01:49 <kmc> cvk, Scheme is like a small subset of Haskell, with no compile-time type checking
23:01:52 <edwardk> here the layers are (:)'s
23:01:56 <kmc> and with a much more regular syntax
23:02:06 <ezyang> edwardk: But corecursion doesn't have to be productive?
23:02:26 <cvk> kmc : Oh.. ok
23:02:42 <edwardk> ezyang: nor does recursion have to be well founded
23:02:48 <Cale> kmc: That is a weird characterisation...
23:03:00 <edwardk> ezyang: you can get bottoms in either of those cases
23:03:06 <kmc> Cale, it's true
23:03:10 <edwardk> ezyang: you get a bottom asking for the next constructor that never comes in corecursion
23:03:19 <ezyang> right-o
23:03:22 <kmc> Cale, but perhaps useful as a capsule summary for someone who knows neither?
23:03:22 <edwardk> or youg et a bottom asking for the structure to finish being built in the recursive construction
23:03:25 <kmc> i don't know, maybe it's misleading
23:03:27 <ezyang> OH!
23:03:27 <Cale> Scheme and Haskell are pretty different, though I suppose a lot of the features of Haskell are formalisations of things that Scheme programmers have been doing for a long time
23:03:28 <kmc> Cale, what would you say?
23:03:37 <ezyang> but codata and data must result from well-behaved instances
23:03:58 <mtnviewmark> quick question: What happens if an IO operation blocks in a forkIO thread? do all my forkIO threads block, since the OS's IO call is blocking?
23:04:07 <kmc> mtnviewmark, no
23:04:08 <kmc> just that thread
23:04:19 <kmc> threads are the typical way of doing async IO in haskell
23:04:21 <kmc> in GHC that is
23:04:23 <kmc> GHC haskell
23:04:25 <mtnviewmark> is that because the IO subsystem doesn't make any OS blocking calls?
23:04:27 <Cale> I think Haskell is a better first language to learn overall, but Scheme does have SICP in its favour.
23:04:29 <edwardk> yes, productiveness is all you need of corecursion to reason about it, whereas you need well-foundedness to reason about recursion
23:04:40 <kmc> mtnviewmark, yes, GHC will use select() or poll() behind the scenes
23:04:50 <wavewave> cvk: did you try http://learnyouahaskell.com/ ?
23:04:50 <solrize> if you use scheme's force/delay to simulate lazy evaluation (that just wraps closures around things), do you get the same efficiency as haskell's graph reduction?
23:04:59 <ezyang> Cale: I will admit, SICP is a smidge impenetrable to the working programmer.
23:05:00 <roconnor> solrize: no
23:05:00 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
23:05:08 <kmc> solrize, yes.  SICP goes into the details of how to implement sharing for that
23:05:14 <mtnviewmark> okay, so if I, er, call something in say HDBC-mysql --- then I'm S.O.L.
23:05:15 <roconnor> kmc: really?
23:05:18 <kmc> yeah
23:05:20 <mtnviewmark> since that library is really blocking
23:05:24 <roconnor> using mutation?
23:05:26 <cvk> wavewave: Yes.. I am going through that and http://www.haskell.org/~pairwise/intro/intro.html#abstract
23:05:31 <solrize> kmc, yeah, that makes sense, but you have to arrange the sharing manually?
23:05:33 <kmc> in the cool part of SICP you implement Scheme in Scheme and then hack on language extensions
23:05:39 <kmc> solrize, no
23:05:43 <kmc> you bake a mutable variable into the thunk
23:05:49 <roconnor> ah
23:06:06 <solrize> right, but does that give you the same effect?
23:06:11 * roconnor didn't think of using mutable variables for some reason
23:06:42 <edwardk> induction lets you reason about bigger and bigger things, starting from a base case, coinduction lets you reason about parts of a thing, starting from a thing for which a property holds and a law that lets you infer that it holds for a part.
23:06:46 <kmc> solrize, yes
23:06:51 <solrize> cool
23:06:57 <kmc> solrize, unless i misunderstand what you ask
23:07:11 <cvk> sorry if this seems stupid, but does GHC have its own IDE?
23:07:17 <tensorpudding> no
23:07:30 <kmc> cvk, there are IDEs for Haskell, such as Leksah
23:07:38 <wolgo> cvk: if you are interested I am a haskell noob too and I just started working on making a rogueline
23:07:39 <kmc> they don't seem to be that popular, compared to a regular editor like emacs or vim
23:07:39 <tensorpudding> ghci has a debugger though
23:07:41 <aavogt> ghci does quite a few things
23:07:41 <wolgo> like*
23:07:43 <kmc> both of which have haskell support
23:07:51 <pastorn> cvk: what platform are you on?
23:08:00 <tensorpudding> and ghc has some fun profiling support
23:08:00 <cvk> kmc: Oh.. Thanks!
23:08:14 <cvk> pastorn : I am on a Mac (Intel)
23:08:24 <pastorn> cvk: cool, then you have proper terminals
23:08:51 <kevinulin> cvk, also if you are looking for a more ide like feel in emacs, i suggest ecb
23:08:56 <kevinulin> it isnt great, but its something
23:08:57 <tensorpudding> as opposed to improper ones?
23:09:16 <cvk> kevinulin: Oh.. ok .. Ill check that out..
23:09:21 <kmc> solrize, roconnor see http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%_sec_3.5.4 "Implementing delay and force"
23:09:29 <blackdog> tensorpudding: windows terminals act all courtly, but they ain't no real gentlemen.
23:09:33 <solrize> thx
23:10:03 <tensorpudding> cmd.exe, while lacking in features, never gave me abuse
23:10:41 <roconnor> kmc: yes, but haskell's laziness can do more than lazy streams.  It can do seemingly impossible functions.
23:11:11 <solrize> kmc, yeah, i read sicp and remembered how that worked, but wanted to know if ghc was doing something somehow more sophisticated.  i read spj's book too and graph reduction seemed fancier than just force/delay with a mutable slot in the thunk, but i wasn't sure
23:11:12 <roconnor> oh
23:11:21 <roconnor> sorry, I'm reading more carefully now
23:11:27 <ezyang> aw, looks like codata isn't a keyword
23:11:47 <solrize> ezyang you know of turner's total functional programming paper?
23:12:11 <solrize> http://www.jucs.org/jucs_10_7/total_functional_programming
23:12:17 <solrize> it explains codata
23:12:27 <ezyang> it's been downloaded and added to my reading queue :-)
23:12:31 <edwardk> ezyang: all data in haskell is codata ;)
23:13:10 <kmc> roconnor, if you replace every "case x" with "case (force x)"
23:13:13 <ezyang> edwardk: Oh, well fine, a "data" keyword :-)
23:13:14 <edwardk> though you can simulate 'data' by using !'s on all the members
23:13:20 <kmc> and every ctor applicaton (C x) with (delay (C x))
23:13:25 <kmc> then i don't see the difference
23:13:29 <ezyang> the strictness annotation hm!
23:13:44 <kmc> in strict-by-default languages, laziness is always available but explicit
23:13:47 <ezyang> Doesn't that also unbox?
23:14:18 <edwardk> ezyang: only if you -funbox-strict-fields
23:14:23 <ezyang> aha!
23:14:30 <edwardk> and only if it isn't polymorphic
23:14:50 <ezyang> hmm
23:14:51 <edwardk> kmc: (usually or sometimes available) ;)
23:15:10 <kmc> always available unless your language has no first-class functions, in which case why even bother talking about it?
23:15:27 <ezyang> Using ! for data leads me to some ideas about the perf characteristics
23:15:46 <ezyang> like, sometimes we want to pretend something is codata for performance purposes
23:15:54 <ezyang> even though it's actually data if we need it to be.
23:16:14 <dolio> It'd be unavailable if it's pure, as well.
23:16:45 <kmc> hmm, good point
23:17:49 <edwardk> ezyang: sure
23:19:09 <edwardk> ezyang: there are performance issues on either side of the data/codata divide though, you can easily build up a tower of thunks that exhausts memory, and you can easily try to over-eagerly evaluate something that evaluates to botton
23:19:11 <edwardk> er bottom
23:19:37 <ezyang> Yeah
23:19:53 <ezyang> "It'll terminate eventually" strikes again!
23:21:41 <ezyang> I wonder if, eventually, we'll understand the performance of codata as much as we do for data.
23:22:10 <ezyang> it might be enlightening for the performance of lazy languages
23:22:17 <edwardk> well, in many ways we can get there now by playing around with speculative evaluation
23:22:22 <wavewave> By the way, this paper seems to be relevant for force/delay to simulate lazy evaluation. http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.35.9427
23:22:33 <edwardk> rob ennals had a wonderful thesis on the topic
23:22:58 <edwardk> http://berkeley.intel-research.net/rennals/pubs/thesis.pdf
23:24:11 <ezyang> ok, time for bed
23:24:17 <edwardk> night man
23:24:19 <ezyang> with any luck, dreams of codata will dance in my head
23:24:22 <edwardk> =)
23:24:27 <ski> relevant to `force'/`delay'-simulations of lazy (or even by-name) evaluation :
23:24:56 <ski> <http://srfi.schemers.org/srfi-45/> "SRFI 45: Primitives for Expressing Iterative Lazy Algorithms" by Andre van Tonder
23:25:07 <ski> (see the "The SRFI Document" link for the document)
23:25:26 <solrize> wavewave that even-odd paper looks interesting
23:25:47 <pastorn> wavewave: i'm giving up on yi now
23:25:52 <pastorn> gvim is nice enough :)
23:26:01 <edwardk> i never really liked the delay/force model.
23:26:14 <ski> (basically `(define (loop) (delay (force (loop))))' and evaluating `(force (loop))' will not run in bounded space as it should, you need to fix this problem by changing the set of primitives)
23:26:16 <wavewave> pastorn: :-)
23:26:24 <solrize> ennals thesis also looks good
23:26:54 <ski> edwardk : you've seen srfi-45 before, i assume ?
23:27:10 <solrize> early pfpl drafts had a rant saying strict was more powerful than lazy, but that got removed from later versions
23:27:17 <edwardk> yeah
23:27:50 <ski> (which model for lazy data in a strict language do you prefer to "the delay/force model" ?)
23:28:13 <edwardk> ski: the model of not using a strict language  ;)
23:28:23 <ski> hehe :)
23:30:14 <solrize> laziness seems like concurrency in that even after you've gotten rid of the obvious bugs there can still be subtle ones waiting to clobber you or bleed you slowly, and there's no simple way to tell when they're all gone
23:31:14 <solrize> i wonder if ennals' optimistic evaluation is anything like "lenient evaluation"
23:31:47 <edwardk> solrize: the speculative stuff maintains non-strict (lazy) semantics.
23:32:01 <solrize> yeah, i don't know if lenient evaluation does that
23:32:17 <edwardk> solrize: it'll do a bounded amount of work before giving up, and eventually penalize the thunk so it'll shut off speculation, so in the end the asymptotics won't change
23:32:55 <ski> wavewave : yes, that's a classic
23:32:56 <edwardk> basically every time it evaluates something that gets gc'd before it gets used, speculation on that thunk gets blamed for wasted performance.
23:33:36 <edwardk> none of the lenient evaluation models i've seen have anything remotely like a comparable guarantee
23:33:50 <solrize> cool
23:34:43 <edwardk> and the eager haskell stuff used a much less robust abortion mechanism, which just restarted every so often, rather than tuned its depth, so while ennals' approach saw a 10-20% speed win, the eager haskell stuff saw a marked speed loss
23:35:37 <edwardk> i do like that the speculative approach leads to a better debugger experience though
23:35:49 <wavewave> any benefit from fully laziness?
23:35:54 <ski> edwardk : that sounds comparable to giving the guarantees that proper tail recursion gives  (namely an unbounded number of tail contexts may be active at the same time)
23:36:42 <edwardk> wavewave: fully lazy as in let floating?
23:36:58 <solrize> i guess with enough concurrent threads you can gc a lot before a speculated value gets used
23:37:08 <wavewave> yes.
23:37:51 <edwardk> wavewave: you get sharing wins with it, at the risk of space leaks for when it is cheaper to just recompute
23:38:29 <wavewave> I am interested in this thesis..
23:38:35 <wavewave> http://thyer.name/phd-thesis/
23:38:48 <wavewave> this is more lazier approach..
23:39:00 <edwardk> *nods*
23:39:17 <wavewave> lazy -> fully lazy -> complete lazy :)
23:39:20 <edwardk> iirc luke palmer is/was a big fan of that approach as well
23:39:41 <wavewave> infinite ladder of partial evaluation
23:40:47 <wavewave> similar to template programming in C++ but more profound.
23:40:54 <edwardk> i think it would be nice to be able to offer a non-id :: a -> a partial evaluator, but i hesitate to think of what such a function would mean
23:41:35 <edwardk> or even a -> IO a
23:42:30 <tensorpudding> Isn't return the only valid function of type a -> IO a?
23:42:37 <edwardk> nah
23:42:48 <tensorpudding> rather, forall a. a -> IO a
23:42:48 <edwardk> i can do arbitrary io side effects in there too
23:42:51 <ski> @type return . not
23:42:52 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m Bool
23:43:02 <dolio> \x -> print "no" >> return x
23:43:03 <edwardk> \x -> putStrLn "Hello" >> return x
23:43:45 <tensorpudding> I suppose \x -> unsafeLaunchMissiles >> return a would be pretty bad
23:44:03 <tensorpudding> err, return x
23:44:04 <wavewave> this evaluation topic always fascinates me :)
23:45:01 <wavewave> strict/ lenient / optimistic/ lazy / fully lazy / complete lazy
23:45:19 <wavewave> so large design space.
23:45:24 <aavogt>  / never
23:45:35 <wavewave> :)
23:45:43 <wavewave> whatever.
23:45:51 <wavewave> evaluate garbage.
23:47:22 <dolio> Strict is an entire class of evaluation strategies.
23:47:42 <edwardk> as of course is lazy
23:47:45 <dolio> All your others could be described as non-strict.
23:47:51 <dolio> No, lazy is a specific strategy.
23:48:17 <edwardk> fair enough, with the clustering of all the others as non-strict
23:48:40 <dolio> There are, of course, a bunch of relatively undesirable non-strict ones left out of the list, too. :)
23:49:00 <dolio> Like call-by-name.
23:49:59 <dolio> And "normal order", although I've never been able to figure out if that's just another term for call-by-name.
23:50:11 <edwardk> call-by-name is useful when you really can't mutate to make a memo-thunk
23:51:18 <dolio> Yes, well, "it's good when you can't do anything better" isn't exactly a ringing endorsement. :)
23:51:56 <ski> is "speculative" the same as "optimistic", here ?
23:52:27 <wavewave> by the way, ghc now seems to fix the default evaluation to 'lazy'?
23:52:43 <lars9> why this doesnt work in ghci?:  getLine >>= (\(IO String s) -> return (s ++ s))
23:52:43 <wavewave> to weak head normal form.
23:53:20 <kmc> lars9, \(IO String s)  is a pattern-match argument
23:53:23 <ski> dolio : iirc, applicative vs. normal order is wrt full normalization, i.e. evaluating under lambda too, while by-value vs. by-name refers to the ordinary not-under-lambda evaluation
23:53:25 <dolio> Speculative is what edwardk was describing, where it keeps track of what's been wasting time, no?
23:53:26 <wavewave> optimistic evaluation has been studied but now not included in main branch.
23:53:29 <tensorpudding> lars9: you can't patten-match like that, first off
23:53:39 <kmc> lars9, it's as if you're trying to take apart a value whose data constructor is IO
23:53:53 <wavewave> fully laziness was implemented for -O2 option before..but now it is also removed.
23:53:54 <kmc> lars9, what do you think that does?
23:54:00 <kmc> why not just write (\s -> return (s ++ s))
23:54:09 <dolio> I think optimistic is where you evaluate for a while before entering a function, but stop if it takes too long, and don't do any kind of extra bookkeeping.
23:54:29 <tensorpudding> (>>=) unwraps the string for you
23:54:31 <lars9> kmc: tensorpudding, oh \s -> return s++s works!
23:54:36 <kmc> yeah
23:54:44 <lars9> kmc: tensorpudding thank you
23:54:51 <kmc> lars9, we don't declare the type of a variable by writing it before the variable
23:54:53 <ski> @type \s -> return s++s
23:54:53 <dolio> ski: Ah, that makes sense, I guess.
23:54:54 <lambdabot>     Occurs check: cannot construct the infinite type: a = m a
23:54:54 <lambdabot>       Expected type: m a
23:54:54 <lambdabot>       Inferred type: a
23:55:05 <kmc> if you need a type annotation, it'd be:   \(s :: String) -> return (s ++ s)
23:55:45 <tensorpudding> the type annotation is unnecessary
23:56:15 <ski> (of course, partial evaluators often evaluate under lambda, in a sense)
23:56:18 <tensorpudding> getLine is type IO String, so s can only be a String
23:56:50 <lars9> kmc: tensorpudding yeah, i messed it up, getLine >>= will only inject a String
23:57:11 <kmc> lars9, but the syntax \(String s) is still wrong for this
23:57:33 <kmc> and yeah the annotation is unnecessary
23:57:45 <tensorpudding> String is special, it doesn't have a type constructor
23:57:48 <kmc> Haskell does not require you to write down types
23:57:52 <kmc> tensorpudding, ?
23:58:01 <lars9> kmc: so if i want to make sure s is a string, i should use \s::String -> s++s ?
23:58:10 <kmc> lars9, yes, but we almost never do
23:58:16 <lars9> kmc: thanks
23:58:21 <kmc> lars9, the general rule of thumb is to put type signatures on top-level bindings only
23:58:28 <kmc> maybe on "let" or "where" bindings if you like
23:58:38 <kmc> type signatures are mostly for machine-checked documentation
23:58:43 <kmc> like a comment that can't be wrong :)
23:58:48 <tensorpudding> Does it have a type constructor in the primitive code?
23:58:55 <lars9> i see
23:58:57 <aavogt> @src String
23:58:57 <lambdabot> type String = [Char]
23:59:10 <lars9> @src IO
23:59:10 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
23:59:14 <tensorpudding> Oh wait, what was I thinking of
23:59:19 <dolio> There's also the non-strict strategy where you spark threads to evaluate arguments. I forget what term people use to describe that.
23:59:47 <tensorpudding> Though it is *still* special, since "..." is a special syntax for String values
23:59:59 <lars9> how can I use '@src' in ghci?
