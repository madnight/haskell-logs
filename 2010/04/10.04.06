00:00:20 <Jafet> Is there a more elegant way to generate all subsequences?
00:02:54 <Axman6> how interesting, Clang includes a spell checker to give hints about what you meant to type if it doesn't know about a certain name
00:03:13 <glguy> > let subseqs = inits >=> tails in subseqs [1..3]
00:03:14 <lambdabot>   [[],[1],[],[1,2],[2],[],[1,2,3],[2,3],[3],[]]
00:03:15 <Axman6> Jafet: concat . map inits . tails?
00:03:37 <Axman6> > concat . map inits . tails $ [1..4]
00:03:38 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,2,3,4],[],[2],[2,3],[2,3,4],[],[3],[3,4],[],[4],[]]
00:03:48 <Axman6> > filter (not.null) . concat . map inits . tails $ [1..4]
00:03:49 <lambdabot>   [[1],[1,2],[1,2,3],[1,2,3,4],[2],[2,3],[2,3,4],[3],[3,4],[4]]
00:04:11 <glguy> filter (not.null) $ inits <=< tails , rather :-D
00:04:56 <Jafet1> > ([] :) $ filter (not.null) $ inits <=< tails $ [1..]
00:04:57 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[...
00:06:01 <Jafet1> Ah, I see a problem in my question. ℵ1 is not enumerable
00:06:23 <Axman6> > filter (not.null) . inits =<< . tails $ [1..4]
00:06:24 <lambdabot>   <no location info>: parse error on input `.'
00:06:36 <Axman6> > filter (not.null) $ inits =<< tails [1..4]
00:06:37 <lambdabot>   [[1],[1,2],[1,2,3],[1,2,3,4],[2],[2,3],[2,3,4],[3],[3,4],[4]]
00:07:41 <glguy> Jafet: were you referring to ℕ as in the naturals or does ℵ mean something else?
00:07:44 <Jafet1> A refined question might be, generate all subsequences of the first n items first
00:08:10 <Axman6> @pl \xs ->  filter (not.null) $ inits =<< . tails xs
00:08:10 <lambdabot> (line 1, column 39):
00:08:10 <lambdabot> unexpected "."
00:08:10 <lambdabot> expecting space or simple term
00:08:15 <Axman6> @pl \xs ->  filter (not.null) $ inits =<< tails xs
00:08:15 <lambdabot> filter (not . null) . (inits =<<) . tails
00:08:37 <Axman6> @pl \xs ->  filter (not.null) $ (>>= inits) . tails xs
00:08:37 <lambdabot> filter (not . null) . ((inits =<<) .) . tails
00:08:42 <Axman6> o.O
00:08:44 <Jafet1> ℵ1 is the cardinality of P(ℕ)
00:08:55 <glguy> meaning "transfinite"?
00:09:13 <Jafet1> Well, yes, they're all transfinite
00:09:23 <Jafet1> This one is just transfinitely transfinite
00:09:36 * glguy is searching for that character looking for its meaning. "transfinite" came up
00:09:50 <Jafet> It's hebrew aleph
00:09:50 <Adamant> aleph one
00:10:54 <Cale> Jafet: That assumes the continuum hypothesis
00:11:05 <glguy> P(ℕ) being the set of all subsets of the naturals?
00:11:10 <Axman6> "C++ is a power tool that gives you plenty of rope to shoot yourself in the foot as well as mix your multi-paradigmed metaphors"
00:11:15 <Cale> Aleph_1 is the next larger cardinality after Aleph_0
00:11:29 <Jafet> Cale, oh. I meant the other hebrew letter then
00:11:30 <Cale> and it's independent of ZFC whether that's equal to the cardinality of P(N) or not
00:13:13 <mpiechotka> Hello. How to set up default TAB size in yi?
00:13:17 <Jafet> There isn't even an other hebrew letter. Must read book again
00:14:54 * glguy reads http://en.wikipedia.org/wiki/Aleph_number
00:15:30 <Jafet> They're beth numbers apparently
00:15:37 <Axman6> I counted to Aleph 2 once
00:15:54 * glguy breaks out some Unicode: ℵ₁
00:17:44 <Jafet> :t (>=>)
00:17:45 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
00:17:56 <Jafet> Cool
00:18:11 <Axman6> @src (>=>)
00:18:11 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
00:18:37 <glguy> f >=> g = \ x -> f x >>= g
00:21:13 <glguy> ?type (.)
00:21:14 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:21:21 <glguy> Which definition is that?
00:21:37 <glguy> (.) reassigned to fmap?
00:22:03 <idnar> yes, (.) = fmap
00:22:14 <Jafet> Glorious hascale
00:23:06 * glguy would have expected
00:23:06 <glguy> ?type (Control.Category..)
00:23:07 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
00:23:09 <glguy> to show up
00:24:02 <Jafet> Let's not confuse the newbies!
00:24:29 <dancor> haskell-advanced
00:24:48 <glguy> Jafet: with definitions from the base library?
00:25:16 <Jafet> Which base library
00:25:53 <glguy> ?hackage base
00:25:53 <lambdabot> http://hackage.haskell.org/package/base
00:26:48 <Jafet> It changes every few months
00:28:39 <glguy> That's what software does...
00:28:58 <Jafet> A programming language shouldn't that often, I think
00:29:28 <glguy> I thought we were talking about base
00:29:37 <glguy> Not the language
00:31:09 <Axman6> @instances Control.Category.Category
00:31:09 <lambdabot> (->), Kleisli m
00:51:19 <Cale_> http://hackage.haskell.org/package/records-0.0.0.0 -- this is quite an impressive application of type families :)
01:01:40 <FliPPeh> Darn
01:01:49 <FliPPeh> People should stop writing monad tutorials
01:01:54 <FliPPeh> And start with dem arrows!
01:05:53 <kmc> an arrow is like *two* burritos
01:06:07 <cads> FliPPeh, I bet writing your own monad tutorial is a great way of learning them
01:06:28 <cads> but it might not be any better at helping anyone else besides you than the other million tutorials out there
01:06:36 <cads> too bad monad tutorials aren't composable
01:07:19 <dancor> Cale: hm but idk how to actually use it.  do you need something like (data Surname = Surname) etc before doing the example (X :& Surname := "Jeltsch" :& Age := 33 :& Room := "HG/2.39")
01:08:10 <FliPPeh>  kmc Two burritos?
01:08:17 * FliPPeh tries to understand the logic :(
01:08:44 <Jafet> @remember kmc an arrow is like *two* burritos
01:08:44 <lambdabot> Done.
01:08:49 <Jafet> @quote burrito
01:08:49 <lambdabot> kmc says: an arrow is like *two* burritos
01:08:57 <Jafet> @quote burrito
01:08:57 <lambdabot> kmc says: an arrow is like *two* burritos
01:09:13 <Jafet> Hrm, who said it
01:09:13 <FliPPeh> @quote sunglass
01:09:13 <lambdabot> islands says: how will people know I'm cool if I'm not wearing my sunglasses?
01:09:20 <FliPPeh> @quote sunglass
01:09:20 <lambdabot> islands says: how will people know I'm cool if I'm not wearing my sunglasses?
01:09:22 <kmc> @where burrito
01:09:23 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
01:09:25 <kmc> anyone running another IOHCC?
01:10:55 <FliPPeh> > first (*6) &&& second (*3) $ (5,5)
01:10:56 <lambdabot>   ((30,5),(5,15))
01:11:07 <FliPPeh> > (*6) &&& (*3) $ (5,5)
01:11:08 <lambdabot>   No instance for (GHC.Num.Num (t, t1))
01:11:08 <lambdabot>    arising from the literal `6' at <i...
01:11:12 <Cale> dancor: Yeah, unfortunately you have to define one-element types for all your fields, and make them instances of the Name class
01:11:20 <FliPPeh> > first (*6) *** second (*3) $ (5,5)
01:11:21 <lambdabot>   No instance for (GHC.Num.Num (d1, b1))
01:11:21 <lambdabot>    arising from the literal `5' at <...
01:11:24 <FliPPeh> :(
01:11:37 <FliPPeh> It worked yesterday
01:12:07 <dancor> Cale: oh i see in the documentation now
01:12:39 <FliPPeh> > (*6) *** (*3) $ (5,5)
01:12:40 <lambdabot>   (30,15)
01:12:42 <FliPPeh> :)
01:15:02 <kmc> learning to use the Arrow combinators for (->) is much more useful than learning to use arrows in general or the "proc" notation for arrows
01:18:10 <FliPPeh> Function arrows?
01:19:08 <kmc> @instances Arrow
01:19:09 <lambdabot> (->), Kleisli m
01:19:52 <FliPPeh> Like what I just did before
01:19:55 <kmc> right
01:20:07 <FliPPeh> > first reverse ("Hello", "World")
01:20:08 <lambdabot>   ("olleH","World")
01:22:10 <FliPPeh> > reverse >>> reverse >>> reverse $ ":/"
01:22:13 <lambdabot>   "/:"
01:22:22 <FliPPeh> I think I'm doing it wrong
01:22:31 <FliPPeh> > reverse . reverse . reverse $ ":/"
01:22:33 <lambdabot>   "/:"
01:22:51 <Gracenotes> nice, 180 degrees rotation
01:23:09 <FliPPeh> :)
01:23:31 <FliPPeh> I an also make a happy face a sad face
01:23:36 <FliPPeh> > reverse ":)"
01:23:37 <lambdabot>   "):"
01:24:49 <kmc> http://makesad.us/
01:26:36 <FliPPeh> :)
01:27:16 <FliPPeh> Are there any "practical" arrow tutorials? I know they can be chained, monads on steroids, but that's all, I'm still unsure how to use them in the real world.
01:28:16 <quicksilver> I don't think there are any good ones, FliPPeh
01:28:18 <kmc> not many people do use them in the real world
01:28:26 <quicksilver> there is one in the wikibook but in my opinion it completely misses the point
01:28:34 <FliPPeh> Yep, I read that
01:28:42 <kmc> the Haskell XML Toolbox has an arrow API
01:28:44 <FliPPeh> The good ol' factory metaphore
01:28:57 <quicksilver> HXT is probably a much better example of what arrows are
01:29:00 <cads> did byorgey's typclassopedia cover arrows in practice?
01:29:01 <kmc> as do some FRP systems
01:29:03 <quicksilver> "functions with a bit more"
01:29:05 <kmc> cads, don't think so
01:29:36 <kmc> to me arrows are primarily function-like things (meaning they can be composed), with "plumbing"
01:29:48 <kmc> and it's only secondary that you have arr :: (a -> b) -> (a ~> b)
01:29:52 <kmc> in fact i think that should be in another class
01:30:07 <quicksilver> "transformation/selection"
01:30:19 <quicksilver> well kmc, you can invent your own words if you want (and that's fine)
01:30:21 <kmc> because i've often run into use cases where i want composition and plumbing but can't lift an arbitrary Haskell function in
01:30:25 <quicksilver> but that's not what 'arrow' means ;)
01:30:40 <quicksilver> you want Control.Category, it sounds like
01:30:43 <Gracenotes> then you can get fun things like bidi Arrows, can't you?
01:31:05 <cads> hey FliPPeh, have you gone through the typeclassopedia?
01:31:08 <kmc> quicksilver, more than just Category, because i care about the flexibility of "proc" notation, which depends on using first, second, (***), (&&&) etc
01:31:22 <kmc> it's not just a category, it's a category with products of some sort
01:31:34 <FliPPeh> cads: Yup
01:31:44 <cads> kmc: the arrow typeclass is introduced and described a bit, but I don't know if it's "real world" application stuff.. I haven't gotten to that place, eitehr
01:31:45 <quicksilver> you're in good company because conal made the same annoying (to me) abuse of terminology with tangible values
01:31:46 <kmc> an instance of Arrow seems to consist of a category with a particular structure, together with a functor to that category from Hask
01:32:06 <kmc> and i wish those were two different classes
01:32:16 <cads> kmc: it lets us work with categories outside of hask?
01:32:20 <quicksilver> an instance of Arrow is a category which, when partially applied, is also a Functor and Applicative
01:32:41 <quicksilver> given an Arrow (~>), then Functor ((~>) a) is enough to give you 'arr'
01:32:54 <quicksilver> and Applicative ((~>) a) gives you first, second, (***) etc
01:33:33 <kmc> but i want first, second, (***) without arr
01:33:41 * quicksilver nods
01:33:45 <quicksilver> I've not thought that through
01:34:00 <quicksilver> asking for Applicative without Functor sounds odd...
01:34:04 <quicksilver> but I do understand why you want it.
01:34:20 <cads> hey quicksilver what's going on!
01:34:45 <kmc> it would not be as general as Applicative either
01:34:55 <cads> seems it's been a while since I saw you around :)
01:35:07 <kmc> (a ~> (b -> c)) -> (a ~> b) -> (a ~> c) is asking quite a lot
01:35:11 <quicksilver> I doubt that. I'm always here. Maybe you were somewhere else? :)
01:36:16 <quicksilver> I wonder how much of proc notation you have to give up if you don't have 'arr'
01:36:34 <cads> quicksilver: yes! in -blah
01:41:27 <fasta> How can index files be created? Like the ones cabal install depends on?
01:42:00 <fasta> Seeing that there is no hackage package on Hackage...
01:43:28 <dankna> fasta: the hackage source is on code.haskell.org somewhere
01:47:41 <Gracenotes> fasta: http://darcs.haskell.org/hackage-scripts/
01:48:40 <Gracenotes> things like user logins and the like not so much included
01:49:33 <Tau> hi.
01:50:40 <Gracenotes> Tau: hello
01:51:21 <Gracenotes> fasta: seems post-upload-hook takes care of it
01:52:16 <Tau> hi Gracenotes .
01:53:20 <HugoDaniel> how do i time only one function in haskell ?
01:54:34 <FliPPeh> Time?
01:54:53 <FliPPeh> You mean profile the execution of said function?
01:54:59 <HugoDaniel> im generating a 512x512 perlin texture in about 0.5s but that time includes opening a opengl context, rendering and closing
01:56:15 <FliPPeh> Well, I don't know the REAL solution to that, but I'd fire up GHCI, Data.Time.getcurrentTime (or anything with more resolution, run that function, take another time and difference that
01:56:42 <dankna> Hugo: you could also generate ten of them into one context
01:56:51 <dankna> and time that and divide by ten
01:57:23 <Tau> hey, what is the version of haskell which there is more adept ?
01:57:34 <FliPPeh> The current one
01:57:46 <Tau> i am wanting to get it i don't know for where i would begin.
01:57:56 <FliPPeh> Tau, grab the Haskell Platform
01:58:11 <FliPPeh> http://hackage.haskell.org/platform/
01:58:20 <FliPPeh> That's the best starting point
01:58:30 <Tau> FliPPeh:  i am using linux, can i do it by giving a apt-get ? heheh.
01:58:40 <Tau> oh, i think i can.
01:58:40 <FliPPeh> Tau, ubuntu?
01:58:44 <Tau> FliPPeh:  debian.
01:58:58 <FliPPeh> 10:57:11 (Tau:FliPPeh:  i am using linux, can i do it by giving a apt-get ? heheh.)
01:59:01 <FliPPeh> 10:57:21 -!- desu [desu@unaffiliated/desu] joins -> #haskell
01:59:02 <FliPPeh> Wrong copy
01:59:04 <FliPPeh> 10:57:21 ( Tau) oh, i think i can.
01:59:05 <FliPPeh> http://packages.debian.org/sid/haskell-platform
01:59:07 <FliPPeh> There
01:59:09 <FliPPeh> Whoops
01:59:13 <FliPPeh> Debian package is provided :)
01:59:18 <Tau> sure.
01:59:58 <Tau> FliPPeh:  what is the book which you recomends ?
02:00:10 <Tau> FliPPeh:  do you know about one which there is on internet to download ?
02:00:15 <FliPPeh> I didn't read any haskell books :/
02:00:24 <FliPPeh> But there's a good one, let me grab the link
02:00:32 <FliPPeh> http://book.realworldhaskell.org/read/
02:00:34 <Tau> FliPPeh:  sure, thank you.
02:00:35 <FliPPeh> You can read this online
02:00:37 <FliPPeh> Or buy it
02:00:40 <FliPPeh> Your choice
02:00:42 <Tau> FliPPeh:  you helped me very much.
02:00:53 <Gracenotes> ~lyah
02:01:01 <Gracenotes> @where lyah
02:01:01 <lambdabot> http://www.learnyouahaskell.com/
02:01:04 <FliPPeh> It MIGHT be a bit fast moving, so there's a "slower" one
02:01:08 <FliPPeh> lyah, yep
02:01:13 <FliPPeh> I recommend both of them
02:01:17 <Gracenotes> you're not javabot, lambdabot!
02:01:31 <Tau> sure.
02:01:48 <FliPPeh> I actually think for haskell there's more online than printed ressource
02:02:45 <Tau> well, i have more a question, what is the version whci i would be learning by studying such tutorials recomended by you , FliPPeh  ? i heard about the existence of some versions of haskell such as gofer etc, i am a bit confuse on this point.
02:02:54 <FliPPeh> GHC
02:02:57 <FliPPeh> GHC and GHCi
02:03:07 <FliPPeh> It's the de-facto
02:03:30 <FliPPeh> GHC compiles to native binaries, and GHCi is a bytecode interpreter
02:03:34 <mjrosenb> or if you are on a crazy system that ghci cannot run on, then hugs98
02:03:48 <mjrosenb> but they have not released anything for 4 years or so
02:03:52 <FliPPeh> Tau: Both are in the haskell-platform
02:04:12 <FliPPeh> Once you download that, you're good to go
02:04:20 <Tau> FliPPeh:  sure, thank you.
02:04:32 <FliPPeh> Tau: No prob :)
02:05:11 <Tau> other point which i would be great it would know if there is some kind of library to construct graphical interfaces and deal with sockets such as there is in java and in other languages.
02:05:22 <FliPPeh> Tau: gtk2hs for GUI
02:05:32 <Tau> FliPPeh:  oh nice.
02:05:33 <FliPPeh> And networking is within the Haskell Platform, too
02:05:45 <FliPPeh> I also think there's wxHaskell for wxWindow
02:06:04 <HugoDaniel> so, i have a quadcore and if i run my program with -N4 everything it goes in about 3s
02:06:15 <HugoDaniel> if i run it with -N5
02:06:22 <HugoDaniel> then it goes about several minutes
02:06:32 <Tau> FliPPeh:  good, do you program for how much times in haskell ?
02:06:51 <kamatsu> Tau: how much times?
02:06:54 <FliPPeh> Tau: You mean how long I've been into haskell?
02:06:58 <Tau> yes.
02:07:01 <Tau> sorry.
02:07:07 <Tau> english isn't my native language.
02:07:21 <kamatsu> what is?
02:07:28 <Tau> kamatsu:  portuguese.
02:07:37 <FliPPeh> Tau: First interest grew about a year ago, and I've been learning it itensivly for a few months
02:07:38 <kamatsu> ah
02:07:39 <HugoDaniel> Tau: you from portugal ?
02:07:45 <kamatsu> brazil?
02:07:47 <Tau> HugoDaniel:  i am from brazil, and you ?
02:07:50 <Tau> yes, kamatsu .
02:07:50 <HugoDaniel> pt
02:08:04 <bastl> hey guys.
02:08:12 <Tau> HugoDaniel:  nice. i like portugal, is a good country, good foods, good roots.
02:08:21 <HugoDaniel> yes
02:08:28 <HugoDaniel> i have family in brazil, s. paulo
02:08:48 <Tau> FliPPeh:  is haskell hardly to grab than c++, for example ?
02:09:11 <kamatsu> I think C++ is stupidly difficult
02:09:22 <FliPPeh> Tau: It is different, very different, and that's what makes it different for people coming from a C-like background
02:09:26 <FliPPeh> I had a hard time
02:09:29 <Tau> HugoDaniel:  nice, i lived at s.paulo for a bunch of months, later i returned to my native state.
02:09:35 <kmc> C++ is hard because there are many tricks and gotchas, and you have to learn a lot of standard workarounds for language flaws
02:09:36 <kamatsu> Haskell has some difficulties, but it's not difficult for no reason like C++
02:09:45 <FliPPeh> I've been doing programming since I was 14, but only imperative programming
02:09:59 <Jafet> C++ is difficult because of the industry reps
02:10:11 <Jafet> "Sorry you can't remove trigraphs, we still use them somewhere"
02:10:24 <mjrosenb> c++ is easy to use if you know C, however there are thousands of annoying things that you don't know about until you see someone else use it.
02:10:51 <kmc> put another way: Haskell is difficult to *learn*, C++ is difficult to *use*
02:10:57 <bastl> When I know algebraic specifications (i.e. signatures, algebras, and the like), what is a data declaration in Haskell then. A signature I suppose? But what is the algebra / algebraic datatype then? And finally: What are the objects of Hask really?
02:11:01 <Tau> kmc:  observing on this point you are saying the truth, i studied logical languages only its 'version's from mathematic, it was very convincent in some points.
02:11:15 <Tau> kmc:  so, i think maybe haskell would be more easy to grab, maybe.
02:11:22 <kmc> in fact i enjoyed C++ much more when i was learning
02:11:34 <kmc> Tau, if you have a mathematical and logical background then you will probably like Haskell a lot
02:11:47 <kmc> and if you are used to thinking abstractly, some of the biggest challenges in learning will be not so bad
02:11:53 <bastl> Or rather: what are the carrier sets for the datatypes / algebras in Haskell?
02:12:16 <FliPPeh> The problem with Haskell is, unlike C++ where I really learned, in Haskell I go nuts on something, and the next day it's all "wow, I got it"
02:12:16 <Tau> FliPPeh:  me too, my frist language was C, later i studied c++, pascal, awk, java. but i just use c and awk.
02:12:20 <FliPPeh> Frustrating.
02:12:24 <kamatsu> bastl: can you be a bit clearer with your question?
02:12:44 <kmc> learning C++ was fun, just like learning Brainfuck is fun
02:12:45 <bastl> what is a datatype in haskell?
02:12:47 <Tau> kmc:  yes, it was a recomendation from my teacher to get learning haskell.
02:12:52 <kamatsu> bastl: like a struct or union in C
02:12:59 <kmc> using C++ to write serious code every day is not fun, just as using Brainfuck to write serious code every day is not fun
02:13:03 <FliPPeh> kamatsu: More like a union
02:13:08 <z1y> c is faster than haskell (!?)
02:13:10 <FliPPeh> Until you're talking about records
02:13:13 <kamatsu> FliPPeh: depends on what data type
02:13:14 <FliPPeh> Which are struct'y
02:13:14 <felzix> I don't have those backgrounds and I enjoy haskell because its typing doesn't require me to remember lots of details a compiler could handle for me.
02:13:14 <bastl> data is just a signature. where are the base sets ?
02:13:29 <kamatsu> bastl: the built in types
02:13:47 <Tau> kmc:  hehe. c++ sometimes was useful to me. it is fabulous as you can write sometimes hadly in C and the same things easily in C++.
02:14:06 <kmc> bastl, "data" declares a type which is a sum of products of other types
02:14:17 <Tau> the point of view on c++ is very wide in contrast to c.
02:14:20 <kmc> and allows recursion including mutual recursion between those types
02:14:29 <bastl> kamatsu: what about ''data Nat = Zero | Succ Nat'' ?
02:14:33 <bastl> no base type
02:14:40 <kamatsu> bastl: well, yes there is. Nat
02:14:47 <kmc> that's the least fixed point of the functor "data NatF a = Zero | Succ a"
02:14:53 <bastl> no set, just signature
02:15:00 <kmc> which is just NatF ~ Maybe, Zero ~ Nothing; Succ ~ Just
02:15:05 <kamatsu> it's an inductive definition
02:15:09 <kmc> that is, your Nat above is isomorphic to (Mu Maybe)
02:15:17 <kmc> Mu is the least-fixed-point combinator on types
02:15:22 <kmc> @src Mu
02:15:22 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
02:15:46 <quicksilver> you can't say Nat is a base type in data Nat = Zero | Succ Nat
02:15:47 <Tau> oh, other point which occured to me would haskell more slow than other languages by its structure be functional ?
02:16:05 <kamatsu> Tau: not really
02:16:05 <kmc> Tau, speed is an issue of implementations, not language
02:16:12 <kmc> Haskell has a powerful optimizing compiler named GHC
02:16:19 <kamatsu> and Haskell's implementations are quite fast
02:16:20 <FliPPeh> Tau: GHC produces highly optimized native codes
02:16:33 <Tau> FliPPeh:  good.
02:16:33 <kmc> Haskell programs are not usually the fastest around, but they strike a very good balance of speed vs. programmer productivity
02:16:41 <bastl> kmc: what is a type? I learned a type somethign like a: F(A) -> A.
02:16:48 <kmc> the Haskell motto for performance is "get it working, then make it fast where necessary"
02:16:54 <bastl> then F is the data decl, but i miss the carrieer set "A" ...
02:16:58 <kmc> unlike C++ where you have a hard time getting it working, and the result is also fast
02:17:07 <FliPPeh> Tau: Functional programs can be optimized really good, because there's so much static values
02:17:09 <Tau> i am wanting to grab haskell because i want to code a IA of chess. i will begin to study a displine in my university called 'introduction to IA".
02:17:13 <kmc> bastl, i'm not familiar with this definition
02:17:16 <Jafet> kmc, if only that were true
02:17:37 <kmc> yeah... in C++ you have a hard time getting it working, and it's also slow because you copy data because it might mutate
02:17:37 <kamatsu> Tau: English acronym is AI
02:17:40 <kmc> but anyway...
02:17:42 <Tau> so, i want to create some projects on it. would haskell exactly the pefect language to program such kind of softwares ?
02:17:51 <kamatsu> Haskell isn't bad for that sort of stuff
02:18:12 <kamatsu> in fact, i'd say it's pretty good
02:18:17 <Jafet> I learn Haskell to make lists of numbers
02:18:21 <Tau> kamatsu: heheh, sure.
02:18:43 <kmc> Tau, http://www.cs.chalmers.se/~rjmh/Papers/whyfp.html
02:18:52 <Gracenotes> @hackage oeis
02:18:53 <lambdabot> http://hackage.haskell.org/package/oeis
02:19:03 <Twey> I love lazy game trees
02:19:04 <Tau> thank you kmc .
02:19:06 <Twey> ♥
02:19:06 <kmc> this is a paper about writing alpha-beta minimax AI, of the sort you'd use for chess
02:19:16 <kmc> as a motivating example for why Haskell and functional programming are worthwhile
02:19:24 <bastl> quicksilver, what did you mean with your note?
02:19:43 <danderson> Tau: with the right data structures, a Haskell implementation could be as/more efficient than a C++ implementation (unless you spend a lot of time getting the memory management and mutation stuff right in the C++ version)
02:20:01 <kmc> in any case, Haskell code can call C code easily
02:20:14 <Jafet> Typical chess engine involves a lot of mutation and complex data structures, but you can abstract the former away using caches
02:20:17 <danderson> and it will definitely be more beautiful
02:20:26 <Jafet> kmc, not sure what that's an argument for
02:20:28 <quicksilver> bastl: I meant it's absurd to call Nat a base class in the sense you meant
02:20:41 <quicksilver> bastl: that was a recursive definition, it didn't use any base types.
02:20:41 <danderson> the algorithm will actually be visible, rather than hidden under layers of syntax and support struts
02:20:50 <Tau> danderson:  yes.
02:20:54 <danderson> (imho that's one of the really nice things about haskell)
02:21:06 <bastl> no, i didnt call it a base type. I just look for the carrier sets of that "signature" ...
02:21:17 <bastl> is it initial semantics ?
02:21:26 <quicksilver> bastl: you didn't call it that, no, someone else did
02:21:28 <Tau> engine of chess is one thing very complicated, i can't imagine for where to get.
02:21:31 <quicksilver> bastl: I was saying they are wrong.
02:21:46 <quicksilver> bastl: it's normally viewed as a least fixed point semantics
02:21:52 <Tau> i hope it will became better than me for playing chess.
02:21:55 <bastl> thtats the same IMHO
02:21:57 <quicksilver> bastl: keywords to search for are 'scott domains' and 'CPOs'
02:22:09 <bastl> not my "domain" :-)
02:26:31 <danderson> it's not that hard to make a reasonably hard chess AI. Making a truly excellent one is harder
02:26:47 <danderson> but if you really want a challenge, try creating a good AI for Go :)
02:27:27 <fasta> danderson, making a good AI only requires a lot of CPU power.
02:27:44 <Tau> danderson:  heheh, i already played go, i don't get grab that.
02:27:46 <fasta> danderson, not to do the actual evaluation when playing, but to compute the strategy.
02:27:53 <kmc> sure, with enough CPU power you can precompute the Universe
02:28:34 <kmc> "numerical estimates show that the number of possible games of Go far exceeds the number of atoms in the known universe"
02:28:36 <Tau> i was thinking on to find some stuffs to get playing that truely.
02:28:37 <danderson> fasta: the trick relies in designing an AI that makes smart use of that CPU
02:28:58 <Jafet> kmc, stream them through rzip
02:29:00 <danderson> given large amounts of CPU power, an AI which doesn't waste time on stupid options will win over one which brute forces :)
02:29:35 <fasta> danderson, the real problem is not really big problems, but the small ones.
02:30:14 <fasta> danderson, that is, algorithms for Go on normal sized boards are hard to find, but for boards much bigger are easy to find.
02:30:47 <Jafet> orly
02:30:48 <kmc> there's some result which can be summarized as "Go is PSPACE-complete"
02:30:53 <Tau> i think if one day we get to prove one machine is able to create other machine equal or better than itself then we will be able to create such machine.
02:30:55 <fasta> danderson, (because the time to find the algorithm disappears in the additive constant after some time)
02:30:56 <kmc> i don't remember the exact decision problem
02:31:12 <Jafet> Heck, sokoban and nob's rush hour are pspace
02:31:13 <kmc> but it's in _Computational Complexity_ by Papadimitriou
02:31:29 <Tau> it is a kind of paradox.
02:31:40 <Jafet> Maybe I should rewrite my sokoban generator in haskell
02:32:34 <Jafet> Chess AI is still in a sense incomplete, in that it relies on the human engineer's evaluation functions and more importantly, opening books
02:32:35 <fasta> Jafet, the _algorithms_ are easy to find, not actually executing those algorithms, which might take a long time, however them being optimal within a small additive constant.
02:32:50 <Jafet> fasta, I see
02:33:06 <fasta> So, really, we live in the wrong universe ;)
02:36:53 <PeakerWork> Hey, I am finding a bunch of problems with the network-data package.  It's probably not OK to upload a new version of it with fixes, right? Only via the maintainer?
02:37:32 <FliPPeh> PeakerWork: If the license grants it, you can of course file a new entry
02:37:40 <FliPPeh> But the smarter way would be telling the maintainer
02:38:40 <PeakerWork> It's using the Binary instance of "Int" to parse a wire format.. That can't be right?
02:38:54 <PeakerWork> "Int" changes its size
02:39:12 <fasta> PeakerWork, that sounds horribly wrong, yes.
02:39:32 <FliPPeh> More like Word32, amirite?
02:39:35 <PeakerWork> Yeah
02:39:43 <PeakerWork> It's parsing TCP wrong here, and that seems to explain it
02:41:34 <PeakerWork> do I need any extension to give a type signature to a bind result in a do block?
02:41:40 <PeakerWork> do { x::Int <- ... }
02:46:43 <quicksilver> PeakerWork: Yes.
02:46:53 <quicksilver> PeakerWork: PatternSignatures or whatever it's called
02:47:04 <PeakerWork> quicksilver: In a "let" I can give an explicit signature
02:47:09 <PeakerWork> what's the "canonical" way for a do bind?
02:47:45 <Jafet> Append the m Int to the end?
02:47:58 <Jafet> But ugly
02:48:25 <PeakerWork> Need to mention the "m" which might be a lot
02:49:13 <PeakerWork> that code also assumed about endianness it seems, yuck
02:49:38 <Jafet> -X86
02:50:36 <PeakerWork> I don't understand how this parser worked for him at all.. everything is wrong!
02:50:49 <PeakerWork> (I guess he only ever looked the ports/sn/an which are the only correctly parsed part of the packet)
02:55:44 <fasta> PeakerWork, huh, you are saying something that disagrees with the "well-typed programs cannot go wrong mantra". That is impossibe.
03:06:15 <kmc> :D
03:14:39 <HugoDaniel> how do i disable the garbage collector ?
03:14:41 <HugoDaniel> :P
03:15:38 <quicksilver> set the parameters so high it never gets invoked
03:15:52 <quicksilver> (i.e. higher than the total memory usage of your program)
03:16:58 <HugoDaniel> hmm ok
03:17:02 <HugoDaniel> how do i do that ? :D
03:17:29 <quicksilver> read the manual.
03:17:39 <HugoDaniel> oh, i wanted to be lazy
03:19:19 <Jafet> I want to ask "Why?", but I won't.
03:19:21 <dobblego> is there a way to start ghci ignoring ~/.ghci ?
03:19:25 <HugoDaniel> :)
03:19:41 <z1y> Hi all, I have a file with 55423666 lines.  With this file, the `wc`version  http://pastebin.com/zXf7KRnN (inspired from the first chapter of http://book.realworldhaskell.org/) failed , it was KILLED before it finishes. (I use ghc with -O option to compile .hs source). The native `wc` from FreeBSD system needs about 10s to get the right result. Any idea?
03:19:41 <HugoDaniel> Jafet just so i can save those 0.5s that the GC eats
03:19:52 <ivanm> z1y: use -O2
03:20:11 <HugoDaniel> right now im generating a 1024x1024 perlin texture (and displaying it in a nice glut window) in 2.4s
03:20:11 <Jafet> I think you should find out what scientific measurement means
03:20:15 <ivanm> and at a guess, if it's from the first chapter of RWH it's not doing it efficiently
03:20:19 <HugoDaniel> and a 512x512 in 0.5s
03:20:30 <Jafet> For stress testing you could generate 3D perlin clouds
03:20:43 <HugoDaniel> theoretically 1024x1024 should be 4*(512x512), but the GC gets in the way
03:20:52 <z1y> ivanm: thank you, I will try
03:20:52 <dobblego> @hoogle Identity
03:20:52 <lambdabot> module Control.Monad.Identity
03:20:53 <lambdabot> Control.Monad.Identity newtype Identity a
03:20:53 <lambdabot> Control.Monad.Identity Identity :: a -> Identity a
03:20:55 <Jafet> Are you sure it's the garbage collector?
03:21:06 <arcatan> dobblego: ghci -ignore-dot-ghci
03:21:11 <ivanm> z1y: realistically, for wc Bytestrings would make more sense
03:21:19 <HugoDaniel> Jafet: GC    time    1.81s  (  0.61s elapsed)
03:21:42 <dobblego> arcatan, thanks
03:21:58 <Jafet> Blah, go what whatever quicksilver said
03:22:50 <ivanm> dobblego: any particular reason for wanting such a thing?
03:24:07 <dobblego> ivanm, because sometimes I want to override my usual defaults
03:24:24 <ivanm> aha
03:24:46 <dobblego> ivanm, e.g. by default I have MR turned off
03:25:07 <ivanm> *nod*
03:25:09 <z1y> ivanm: my Haskell version of `wc` is still killed :). I should consider Bytestrings :)
03:26:00 <Jafet> It's killed due to stack overflow, so avoid that
03:26:31 <dobblego> wtf? there is no instance Show Identity
03:26:45 <ivanm> @hoogle Identity
03:26:45 <lambdabot> module Control.Monad.Identity
03:26:45 <lambdabot> Control.Monad.Identity newtype Identity a
03:26:45 <lambdabot> Control.Monad.Identity Identity :: a -> Identity a
03:26:54 <dobblego> occasionally the haskell libraries throw me a curve ball
03:26:58 <ivanm> dobblego: shouldn't it be (Identity a) anyway?
03:27:07 <dobblego> (Show a) => Identity a
03:27:14 <fasta> z1y, that means the laziness isn't working as it should.
03:27:35 <ivanm> hmmm, Identity only has instances for Monad, Functor and MonadFix
03:27:38 <ivanm> interesting...
03:27:44 <dobblego> Identity is a list, like Maybe with a maximum length of 1, but with a minimum length of 1
03:27:56 <ivanm> dobblego: yeah, I hate libraries that don't just derive Show, Read, Eq, Ord, etc.
03:28:00 * ivanm stares at fgl
03:28:03 <fasta> z1y, if you simplify the expression (removing the extra stuff that it computes) should solve it.
03:28:11 <dobblego> when I write my own haskell it won't be like that!
03:28:19 <z1y> fasta: thank you (i am just a Haskell newbie) :)
03:28:32 <ivanm> dobblego: do you mean that Identity also has a max length of 1? >_>
03:28:57 <dobblego> ivanm, yes, like Maybe
03:29:06 <ivanm> so it's just a single value, not a list... >_>
03:29:13 <ivanm> dobblego: why are you using Identity anyway?
03:29:22 <dobblego> ivanm, I'm just offering an alternative view
03:29:28 <ivanm> *nod*
03:29:41 <dobblego> ivanm, i.e. I often describe Maybe as a list with a maximum length of 1 (to noobs)
03:29:59 <ivanm> yeah, that makes sense
03:30:11 <ivanm> but saying that something is a list with precisely one element is a little silly IMHO
03:30:43 <dobblego> it offers some insights
03:30:47 <dobblego> e.g. it's clearly a functor
03:30:52 <dobblego> and a Show
03:31:12 <fasta> z1y, the "problem" is probably that the loops are not merged.
03:31:46 <fasta> z1y, it might be that GHC simply cannot do this, or that you need to use e.g. -O2.
03:32:00 <dobblego> ivanm, [] represents 0 or many theorems, Maybe 0 or 1, Identity 1 and only 1, NonEmpty 1 or many
03:32:10 <fasta> z1y, you can see the actual code being generated via the ghc-core package on Hackage.
03:41:43 <HugoDaniel> i should really start to comment my haskell code more
03:41:52 <HugoDaniel> it is so cowboy style :/
03:43:26 <kamatsu> alright
03:43:31 <kamatsu> which one of you is aaron defazio?
03:45:31 <Jafet> unsafeOpenBayDoor pliers >> print "Yeeehaaaw"
03:46:41 <kamatsu> Jafet: you don't seem to pay any attention to the ImAfraidICantDoThat exception
03:47:12 <Jafet> Of course not. It's not even correctly spelled.
03:47:24 <kamatsu> it isn't?
03:48:56 <Jafet> Its correctness is negated by the language's contractions' apostrophes' absence
03:49:11 <FliPPeh> unsafePutOnSunglasses >> shout "YEEEEAAAAAH"
03:49:21 <FliPPeh> I should stop with CSI memes
03:49:51 <Jafet> You forgot panCameraToCitySkyline
03:50:18 <FliPPeh> followBoatAcrossRiver
03:51:02 <danderson> also, why is putting on sunglasses unsafe? Doesn't shouting imply IO, which would make the call putOn sunglasses >> pan camera citySkyline >> shout "YEEEEAAAAAH" ?
03:51:26 <theorbtwo> (Forgetting Sarah Marshal)++ # the title characters met "Crime Scene: Scene of the Crime".
03:51:32 <FliPPeh> Hey, it changes the state of the world after all
03:51:36 <FliPPeh> Glass -> No Glass
03:51:39 <Jafet> Because it's CSI; any character action is unsafe
03:52:06 <FauxFaux> In the traditional CSI meme he doesn't actually apply sunglasses.
03:52:24 <Jafet> It's worse in Lost, where you are sent periodic CastTerminated exceptions.
03:55:11 <theorbtwo> It's interesting how, in the sort of show where characters come and go a lot, the original cast are essnesially the only ones that stick well.
03:55:13 <Twey> Hahaha
03:55:23 <theorbtwo> You see that very much on both Heroes and Lost.
04:01:45 <luqui> What is the best array interface to use when I am just interested in loading data from file and passing it to opengl via a Ptr?
04:02:13 <FliPPeh> ByteString?
04:02:30 <FliPPeh> Ignore me
04:02:38 <FliPPeh> Probably not a good choice
04:03:13 <luqui> well the data has to be parsed first anyway.  going from a stringified list of floats to an array of floats
04:03:24 <luqui> otherwise i might agree with you
04:03:55 <FliPPeh> It must be an array the directly maps to a C-style one, right?
04:04:03 <luqui> yeah
04:04:10 <FliPPeh> Doesn't the Foreign package include something like that?
04:04:35 * luqui looks
04:06:03 <luqui> Foreign.Marshal.Array.newArray :-)
04:06:14 <FliPPeh> :)
04:06:25 <luqui> do you know if I have to free it manually?
04:06:40 <FliPPeh> Uhm, I think the Parshal part means that it'll be garbage collected
04:06:50 <FliPPeh> s/Parshal/Marshal
04:07:23 <FliPPeh> But you should probably see an expert on this topic, it's not really my strength :)
04:09:15 <dobblego> which is preferable: instance T U goes in the same module as T or U?
04:09:29 <FliPPeh> I'd say U
04:12:24 <luqui> lame can't use newArray
04:12:29 <luqui> i need to create these things outside of IO
04:12:44 <FliPPeh> There's your problem ;/
04:12:52 <luqui> (i may still convert them to Ptr in IO)
04:12:58 <FliPPeh> I think these things have to be IO
04:13:06 <quicksilver> outside of IO, use a list, and pray everything fuses nicely in practice?
04:13:17 <luqui> what about all that stuff in IArray?
04:13:19 <quicksilver> certainly that would be my first draft solution.
04:13:33 <luqui> that's pure, but I can't convert it to a ptr?
04:13:39 <quicksilver> I don't think there is any point making an IArray if your destination is Ptr because they don't have the right memory layour
04:13:47 <luqui> hmmm
04:13:54 <quicksilver> the simplest Ptr-creators use lists for input
04:14:11 <quicksilver> certainly I used lists (to build Ptrs) in my VBO code and it seemed to be workably fast
04:14:21 <quicksilver> I didn't attempt to check if it was actually doing stupid work though :)
04:15:29 <luqui> hmm, i don't know.  i could make it work by putting IO in the right spot, I suppose
04:15:50 <luqui> might have to do that anyway, go through IO to turn this pure model description into a runnable OpenGL action
04:16:06 <luqui> so it can allocate textures and whatnot..
04:16:20 <luqui> yeah that's true. ok you convinced me.
04:16:21 <luqui> :-P
04:42:01 <hasenov> hello, is there a way to define data type in ghci interpreter directly, rather than defining it in external file?
04:42:32 <FliPPeh> hasenov: I think not
04:42:55 <Jafet> Use ghci to write to a file and load it
04:43:12 <FliPPeh> Good one, I never thought about that
04:43:34 <hasenov> thanks
04:45:57 <Jafet> Or you could use screen, but I dislike screen
04:46:33 <kmc> why?
04:46:36 <kmc> screen is great
04:50:11 <FliPPeh> I like tmux
04:50:14 <FliPPeh> Screen++
04:50:15 <FliPPeh> :)
04:50:28 <mreh> @karma screen
04:50:29 <FliPPeh> It actually manages to set my terminal title...
04:50:29 <lambdabot> screen has a karma of 1
04:50:39 <FliPPeh> screen--
04:50:41 <FliPPeh> @karma screen
04:50:42 <lambdabot> screen has a karma of 0
04:50:47 <FliPPeh> Good one.
04:50:53 <FliPPeh> @karma flippeh
04:50:53 <lambdabot> You have a karma of 0
04:50:57 <FliPPeh> WHYYYY
04:51:30 <Polarina> @karma Polarina
04:51:30 <lambdabot> You have a karma of 1
04:51:32 <Polarina> o.O
04:51:48 <FliPPeh> What do you have that I don't?
04:51:50 <FliPPeh> :(
04:51:55 <bremner> FliPPeh--
04:51:59 <bremner> there yah go
04:52:07 <Polarina> lol
04:52:11 <FliPPeh> nag nag
04:57:07 <mjrosenb> @karma lambdabot
04:57:07 <lambdabot> lambdabot has a karma of -3
04:57:12 <mjrosenb> odd.
04:57:20 <Eelis> this cafe thread about the hackagedb real name policy is turning out very interesting, with numerous supporters on either side of the dispute. will be interesting to see how this is resolved (if it is at all)
04:58:56 <mreh> it's not a problem if you can register a pseudonym
04:59:19 <Eelis> the current policy forbids that, which is exactly the problem :)
05:00:04 <Gracenotes> it has a very political tenor
05:00:16 <mreh> no one would know if you were to register an google inbox with a fake address
05:00:22 <mreh> then apply for the account
05:00:36 <fasta> I wonder what would happen if someone decided to compete with Hackage ;)
05:00:39 <Gracenotes> reminds me of when I subscribed to the English Wikipedia mailing list.. before (during) that filled up with noise, at least.
05:01:08 <Eelis> mreh: unfortunately there is actually a human doing the account creation, and if they already know you by pseudonym, you lose. also, a gmail address isn't enough: people have reported that the human creating the account demanded that they use their university email account
05:01:14 <Jafet> fasta, cabal install hackage?
05:01:26 <Eelis> fasta: i would sign up! :)
05:01:28 <Jafet> runhaskell hackage
05:01:33 <mreh> Eelis: i'm registered with a google account
05:01:50 <fasta> Jafet, that doesn't work.
05:01:55 <Eelis> mreh: that's another part of the problem: this particular human doing the account creation seems to apply and invent rules completely capriciously
05:01:56 <Gracenotes> fasta: a challenger appears! http://bifunctor.homelinux.net/~roel/hackage/packages/hackage.html
05:02:24 <Gracenotes> ...okay, it's a mirror with reverse dependencies.
05:04:11 <mreh> my uncle writes under a pseudonym, it's still a real name, t if that's the issue
05:04:27 <mreh> my uncle writes under a pseudonym, it's still a real name though, if that's the issue, I can't see the problem
05:04:52 <Eelis> mreh: if you don't see the problem, i recommend that you read the cafe thread i mentioned
05:04:53 <Twey> Who is the human?
05:04:58 <Eelis> paterson
05:05:14 <Twey> Hmm
05:05:31 <fasta> Didn't Paterson develop the code for Hackage?
05:05:32 <mreh> I read it before it became TL;DR
05:05:36 <Eelis> fasta: no idea
05:05:59 <fasta> Or anyway, if Paterson controls it currently and he says no, you can do only one thing.
05:06:07 <fasta> Well, actually, two.
05:06:08 <Twey> Fork fork fork?
05:06:20 <fasta> Ignore it, or implement your own version of Hackage.
05:06:29 <Eelis> fasta: i'm not sure a hackage clone would be a good solution. perhaps all we need is for "cabal install" to be able to take urls to tarball/repo's, and for .cabal files to be able to associate repo/package url's with package names
05:06:32 <Twey> Isn't the code free?
05:06:50 <Eelis> this way we'd skip the silly centralized model altogether
05:07:09 <fasta> Eelis, that would be a very simple solution.
05:07:20 <Twey> Aye
05:07:24 <Vanadium> Then hackage would be just another github?
05:07:30 <Eelis> Vanadium: exactly
05:07:42 <fasta> What I don't like about Hackage is that every time you do cabal install you can be downloading malware.
05:07:57 <Vanadium> I kind of like the idea that putting something on hackage implies that everybody is entitled to improve it
05:08:14 <Vanadium> while everything on places like github or bitbucket is tagged with the owner's name
05:08:15 <fasta> Not because the package authors did something wrong, but simply because of a trivial man in the middle attack.
05:08:17 <Eelis> Vanadium: that is implied whenever you release code with an open source license, no?
05:08:24 <Vanadium> Eelis: I mean in-place
05:08:59 <mreh> fasta: can we not encrypt the trasmission?
05:09:03 <Eelis> Vanadium: i'm not sure what you mean. if you want to have a patch incorporated into a hackage package you have to negotiate with the maintainer, just like for any piece of open source software
05:09:08 <Jafet> @faq can you write malware in haskell?
05:09:09 <lambdabot> The answer is: Yes! Haskell can do that.
05:09:32 <fasta> mreh, of course you can, but Hackage doesn't do so.
05:09:41 <Vanadium> Eelis: I was just thinking about hackage urls not including the owner's name directly
05:09:43 <fasta> mreh, and you still need to have a PKI.
05:09:44 <mreh> mini-project :)
05:10:05 <mreh> get hackage a public-private key pair, easy
05:10:08 <Jafet> Do it using openssl!
05:10:27 <Eelis> just use git and its signed commits :P
05:13:25 * mjrosenb has no idea how c.h.o works.  can you use whatever rcs you want?
05:13:31 <Eelis> i wonder if a "cabal install" patch adding the ability to do "cabal install url/to/package-tarball" would be rejected. that would be a good start
05:13:35 <mreh> "anything that keeps the 1337 h4x0r nicks of hackage"++
05:14:00 <Eelis> er.. i mean, such a patch would be a good start, not its rejection :)
05:14:20 <bremner> well, you could legally change your name to 1337 h4x0r, that would fix em.
05:14:42 * p_l wonders what is wrong with hackage for ya, since he always took it as a goal to reach...
05:14:48 <mjrosenb> fasta: not to make fun of your paranoia, but typesafe malware sounds *awesome*
05:14:58 <Eelis> p_l: see the "Hackage accounts and real names" thread on cafe.
05:15:22 <Jafet> mjrosenb, polymorphic malware is the norm these days
05:15:32 <Jafet> Maybe you could model that behaviour with GADTs
05:15:43 <mreh> what judge would change your name to 1337 h4x0r?
05:15:44 <mreh> :)
05:16:08 <p_l> mreh: given what wacky names people got due to some idiotic officials long ago...
05:16:10 <Eelis> Jafet: i'm sure oleg could conjure up a clever Infestee idiom modelled after Iteratee
05:16:25 <mjrosenb> Jafet: is haskell's type system turing complete yet?
05:16:41 <Jafet> UndecidableInstances
05:16:46 <Jafet> Sounds complete to me
05:16:54 <fasta> mjrosenb, what do you consider to be type safe?
05:17:27 <mjrosenb> fasta: haskell sans unsafePerformIO
05:17:48 <fasta> mjrosenb, ok, so everything without unsafe operations.
05:18:07 <fasta> mjrosenb, too bad that Cabal allows arbitrary code execution when it installs something.
05:18:50 <fasta> mjrosenb, so, even if you never use the package, you only install it you are already in trouble.
05:18:58 <Jafet> Clearly we need correctness proof system over cabal installers
05:28:01 <benmachine> we need either blind trust or human auditing
05:28:09 <benmachine> well
05:28:25 <benmachine> there are packages you can guarantee safe, but no method will catch every dangerous package
05:28:36 <benmachine> things like network operations are pretty much always a potential danger
05:29:00 <fasta> benmachine, proof carrying code can be used in theory. In practice however it only generated grant money.
05:29:56 <benmachine> fasta: I just mean that a package whose only IO is putStrLn can not really do any harm
05:30:12 <benmachine> okay you can forkbomb but it's hard to do permanent damage like that
05:30:15 <Adamant> fasta: you can say that about most formal methods related stuff
05:30:30 <Adamant> in terms of actual impact beyond a select few fields
05:30:32 <fasta> Adamant, I don't really agree with that. \
05:30:51 <fasta> Adamant, formal methods will have huge impact, it is just a matter of time.
05:31:14 <fasta> E.g. Coq is getting more influential as far as I am concerned.
05:31:15 <Adamant> fasta: maybe, but at this point the evidence for them is in general about that for PCC
05:31:35 <Adamant> and PCC is formal method related anyway
05:31:36 <fasta> Coq simply needs even better documentation and a more readable implementation.
05:31:40 <benmachine> aaaanyway
05:32:09 <benmachine> there are SSL bindings on hackage but I think they're not ready for use
05:32:14 <benmachine> and anyway they require C libs which is a pain
05:32:25 <benmachine> but writing good security software is even more of a pain
05:32:43 <benmachine> so what do we do about the immediate problem of unsecured connection?
05:32:57 <ivanm> anyone here familiar with how cabal 1.8 does dependencies (specifically having an executable depend on the library that it ships with)?
05:33:02 <benmachine> that is a solvable problem, we just need to work out the details
05:33:02 <ivanm> since dcoutts doesn't seem to be around...
05:53:25 <Eelis> heh, paterson plays his cards well, arguing that he is willing to make exceptions on the real names policy, but reserving for himself full autonomy in deciding which individuals have a legitimate need for privacy and which do not.
05:53:41 <Eelis> in true dictatorial style.
05:54:07 <jmcarthur> *sigh*
05:55:33 * bremner is reminded of John Kenneth Galbraith on Economics departments: Why are the fights so vicious? Because the stakes are so low.
05:58:03 <Adamant> benmachine: they require C libs for a reason, AFAIK Haskell doesn't have the ability to ensure some of the guarantees a fair amount of crypto plumbing needs, as currently constituted.
06:00:29 <FliPPeh> Based on the assumption that most stuff in Haskell resides on the heap, how does it handle failed memory allocations for stuff?
06:00:41 <quicksilver> it runs the GC and tries again
06:00:58 <EvanR> and if you run out of memory? boom!?
06:01:06 <quicksilver> no, it runs the GC again and tries again
06:01:12 <EvanR> forever
06:01:18 <FliPPeh> @faq Can haskell run without memory?
06:01:18 <lambdabot> The answer is: Yes! Haskell can do that.
06:01:34 <quicksilver> it will keep trying :)
06:01:41 <FliPPeh> Forever?
06:01:48 <quicksilver> well eventually it hits a hard failure
06:02:16 <FliPPeh> But it won't just crash you like "meh, I tried"? Good to know :)
06:02:24 <EvanR> heh, im reminded of linux malloc ;)
06:02:26 <quicksilver> but because of the nature of memory use/reclaimation not until several iterations
06:02:29 <EvanR> never returns NULL
06:02:44 <FliPPeh> EvanR: So THIS is why I could allocate 100 GiB of memory
06:02:48 <quicksilver> and assuming your machine has a virtual memory system and you're rlimited
06:02:55 <quicksilver> and you're *not* rlimited
06:03:11 <quicksilver> your machine normally slows to an unreponsive crawl while successively faster and faster GCs thrash your swap
06:03:28 <FliPPeh> quicksilver: Oh, I know that.
06:03:33 <FliPPeh> It happened to me a few days ago.
06:03:39 <FliPPeh> 98% memory and 100
06:03:42 <FliPPeh> % swap.
06:04:07 <Jafet> linux is the only system I know of that you can thrash without a swap partition
06:04:37 <int-e> is mmap so uncommon?
06:04:40 <Jafet> The effect is similar to a forkbomb, except it's done by the system
06:04:58 <Jafet> mmap on linux does not follow the POSIX standard in one crucial respect.
06:05:14 <Jafet> Allowing you to reserve physical memory space.
06:05:34 * jmcarthur growls at the OOM killer
06:22:28 <gspr> As someone quite new to Haskell, I keep finding myself in the following pattern when making some simple functions: 1) Create a worker function fooWorker that (tail-)recursively does the useful work. Let's say it recursively builds up a list. 2) let foo = fooWorker []
06:22:43 <gspr> what's the proper way to do this more neatly?
06:24:43 <ivanm> gspr: depends on what fooWorker does
06:24:48 <ivanm> can you paste up an example?
06:26:06 <HugoDaniel> im trying out criterion
06:26:24 <sepp2k> gspr: Note that due to haskell's laziness it is not always preferable to define functions tail-recursively.
06:26:39 <gspr> sepp2k: Yeah, I guess that's true
06:26:41 <xerox> gspr: one thing is doing f <args> = f' args [] where f' <args> [] = ... f' <args> (x:xs) = ...
06:26:48 <gspr> ivanm: I'll write up a quick example
06:27:12 <gspr> xerox: Yeah, that's what I'm doing... but it feels so repetitive, I was thinking there maybe was some neat way to do it
06:28:11 <HugoDaniel> criterion is saying: ERROR: output type SVG 432 324 not supported on this platform
06:28:15 <HugoDaniel> how can i correct this ?
06:28:35 <ivanm> HugoDaniel: build it with chart support
06:28:39 <HugoDaniel> ah
06:28:45 <HugoDaniel> how ?
06:28:45 <ivanm> HugoDaniel: if you don't, it won't produce _any_ images
06:28:46 <HugoDaniel> :)
06:29:22 <ivanm> HugoDaniel: install chart, then rebuild criterion
06:29:35 <ivanm> (note: this needs gtk2hs)
06:30:09 <xerox> gspr: what's repetitive, the different f' defs?
06:30:43 <gspr> xerox: Yeah, I mean the pattern is always: "The real function is the prime-function with the first argument being (say) an empty list"
06:31:01 <gspr> This is of course not a real problem, it just feels... ugly :)
06:31:19 <xerox> gspr: for that, it's just two lines, not worth abstracting (imho) - if the problem is that f' = g' then abstracting is worth it imo
06:31:44 <Twey> gspr: Use higher-level functions that abstract away the pattern you're attempting to achieve
06:31:57 <gspr> xerox: I guess you're right
06:32:12 <HugoDaniel> great, it doesn't build on ghc6.12
06:32:22 <HugoDaniel> it somehow requires template haskell 2.3.0.1
06:32:26 <gspr> Twey: Yeah, in every single example I can think of to show you guys, I always easily find a way to abstract away what I'm doing... but still, it feels like a problem when doing real work :)
06:32:38 <gspr> maybe I'll come back if I can think of a real problem again :)
06:32:52 <xerox> anytime
06:33:03 <Twey> gspr: Explicit recursion is not very Haskelly… there are some problems where it's necessary, but if you find yourself using it you should definitely think twice
06:33:13 <ivanm> HugoDaniel: there's no 6.12 compatible release of gtk2hs
06:33:24 <gspr> Twey: Ah, good to know... because I keep finding myself doing it aaaalll the time
06:33:28 <Twey> gspr: You can also use State or something like that rather than passing arguments
06:33:56 <gspr> State is the next thing I was going to try, as a matter of fact
06:35:03 <HugoDaniel> well, chart breaks on data-accessor-template
06:35:16 <HugoDaniel> because it requires template haskell oldschool
06:35:55 <HugoDaniel> here i go about trying to fix this kind of errors again and again :(
06:36:07 <EvanR-work> fold unfold untilM...
06:36:43 <xerox> gspr: for starters it makes sense to look into those two:
06:36:45 <xerox> ?src foldr
06:36:45 <lambdabot> foldr f z []     = z
06:36:45 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
06:36:47 <xerox> ?src foldl
06:36:48 <lambdabot> foldl f z []     = z
06:36:48 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
06:38:08 <gspr> xerox: Heh, yeah, you're right... I've just been unbelievably stupid, forgetting that folds with a list accumulator is exactly what I want... d'oh :(
06:39:18 <gspr> Hey, I have another newbee question, while I'm at it... I feel like I'm constantly making a mess whenever playing CArray. I can always make it work, but I feel I end up making a mess every time. Does anybody know of a document explaining CArray?
06:39:33 <gspr> xerox: Thanks for pointing the above out!
06:39:42 <xerox> hey, no problem mate
06:39:44 <EvanR-work> make sure you actually need an array
06:39:47 <roconnor> I remember when I first figured out (not so long ago) that it was really simple to write reverse using foldl because reverse simply needs an accumulator.
06:39:52 <roconnor> @src reverse
06:39:53 <lambdabot> reverse = foldl (flip (:)) []
06:40:02 <gspr> EvanR-work: I do... I'm playing with the FFT package, which operates entirely on CArrays
06:40:02 <roconnor> then I saw that reverse was defined using foldl.
06:40:36 <xerox> cool, what are you fourier transforming?
06:41:04 <gspr> xerox: Just some random data at the moment... playing with a simple compressed sensing signal recreation algorithm
06:41:31 <luite> does anyone here happen to know NP-hard machine scheduling problems for which there is an algorithm with known exponential time complexity (Say O(n^c) for some known c)?
06:43:31 <gspr> I guess my problems with CArray will disappear when I just slow down and take it one step at a time.. I keep getting confused by the generality of Shapable as well as the process for making CArrays out of other data (lists or arrays)
06:44:14 <sepp2k> luite: n^c is polynomial, not exponential.
06:44:25 <luite> euh oops
06:44:33 <zygoloid> > flip (^) n c
06:44:35 <gspr> and then I do the worst thing: handle type problems by randomly trying things (if there's one thing I've learned about haskell so far, it's "take time and take your type problems seriously!")
06:44:36 <Twey> Hehe
06:44:40 <lambdabot>  Terminated
06:45:22 <lpsmith> I don't suppose anybody has experience with prepared SQL statements and takusen?
06:45:39 <xerox> Terminated
06:45:42 * SamB_XP is tempted to make that say "Governated" occasionally
06:45:50 <xerox> Censored
06:45:53 <Twey> You should :þ
06:46:17 <SamB_XP> but I can't figure out what occasion it should do that on ;-)
06:46:42 <exDM69> hi guys
06:46:57 <exDM69> I'm thinking of applying to GSoC with Haskell
06:47:27 <exDM69> are there any mentors present?
06:47:27 <xerox> randomly, SamB_XP
06:47:54 <HugoDaniel> im going to ditch criterion and use old school timing functions
06:48:05 <Jafet> gspr, it could be worse, you might be randomly trying things in python
06:49:26 <gspr> Jafet: Hehe. Man, Python's ducktyping has driven me crazy many a time :(
06:50:12 <SamB_XP> yeah, everythings like [Duck] -> Duck in Python
06:50:19 <SamB_XP> plus, no IO monad
06:50:27 <SamB_XP> everything impure
06:50:38 <gspr> Python should include a feature to force execution of every code path so that you don't stumble upon type errors by accident during runtime
06:50:47 <etpace> Hmm, whats the difference between par and pseq?
06:51:02 <Jafet> One is magic, the other is more magic
06:51:07 <FliPPeh> I always hated that about dynamically typed languages
06:51:16 <FliPPeh> 99% of the errors happen when you do NOT expect them
06:51:18 <gspr> While I'm still far from confortable with Haskell, I really do love its static typing
06:51:38 <FliPPeh> I never actually had any bug inside the program once it compiled
06:51:47 <FliPPeh> It just does not happen :/
06:52:01 <danderson> all functions in python run under unsafePerformWhatever, and have types something -> otherthing
06:52:05 <danderson> it's so simple!
06:52:07 <gspr> FliPPeh: exactly! Doesn't matter if you can write code incredibly quickly (as I'll admit you can in python) if a common reason for crashing is some code branch demanding that a kitten quacks
06:52:27 <EvanR-work> lpsmith: we are using HDBC with prepared statements
06:52:34 <Jafet> @quote generalisation
06:52:35 <lambdabot> ksf says: ...premature generalisation is the root of all procrastination.
06:52:38 <etpace> Hmm, par: "it evaluates its left argument to weak head normal form, and returns its right.", pseq: "it evaluates the expression on the left to WHNF before returning the expression on the right.", whats the difference?
06:52:42 <Jafet> @quote benmachine generalisation
06:52:42 <lambdabot> benmachine says: unsafeCoerce is just a generalisation of id
06:53:24 <arcatan> exDM69: http://hackage.haskell.org/trac/summer-of-code/wiki/People2010 lists some possible mentors, possibly with IRC nicks
06:53:25 <xerox> natural generalization I'd say
06:53:52 <lpsmith> EvanR-work, cool, for some reason I keep getting run-time errors with takusen
06:54:06 <exDM69> lambdacube is not in the ideas list any more :(
06:54:08 <lpsmith> I'm seriously contemplating switching to HDBC
06:54:22 <SamB_XP> etpace: well, par's documentation is actually lying ;-P
06:54:23 <EvanR-work> lpsmith: what kind of errors, exceptions or segfaults
06:54:31 <etpace> that was from RWH SamB_XP
06:54:50 <lpsmith> EvanR-work, exceptions,  only when I use prepared statements
06:54:57 <SamB_XP> anyway, you may notice that there was no "before" in the description of par
06:55:06 <EvanR-work> lpsmith: we had a problem with that
06:55:09 <SamB_XP> there's a reason for that
06:55:11 <EvanR-work> we were using the api wrong
06:55:27 <etpace> ah, so par just executes the LHS in parallel, but doesnt guarantee its executed before returning the right
06:55:43 <EvanR-work> lpsmith: but using the mysql driver we get spurious segmentation faults, that is, if the database is going up and down and exception handling
06:55:44 <SamB_XP> etpace: pretty sure, yeah
06:55:45 <lpsmith> EvanR-work, with Takusen,  or HDBC?   In either case,  do tell
06:56:04 <EvanR-work> HDBC
06:57:08 <SamB_XP> etpace: anyway, the reason I claim it's lying is that I heard that if you spark off too many "sparks" (which are the special thread-like things that par makes to evaluate the LHSes), GHC starts dropping them on the floor
06:57:28 <SamB_XP> at least, that's what I heard
06:57:35 <EvanR-work> fear uncertainty and doubt!
06:57:38 <SamB_XP> of course, this doesn't affect the semantics
06:58:06 <lpsmith> EvanR-work, so you were gettting segfaults when using HDBC,  mysql, and prepared statements incorrectly?
06:58:09 <SamB_XP> but it might negate any performance gains you were hoping for ;-)
06:58:39 <EvanR-work> lpsmith: separate things. ill reexplain. exceptions were thrown when using prepared statements wrong
06:58:54 <lpsmith> ok
06:59:01 <EvanR-work> segfault from trying to robustly reconnect to the server if certain exceptions were thrown
06:59:04 <etpace> hmm ok SamB_XP
06:59:26 <lpsmith> do you recall how you were using prepared statements wrong?
06:59:29 <SamB_XP> (which is probably related to why automatic, "why should I have to say anything about it in my code?" approaches to paralellization didn't work out so well ...
06:59:50 <SamB_XP> lpsmith: he prepared statements for the wrong disasters
06:59:55 <EvanR-work> lpsmith: quickQuery does an auto fetchRows, which fails if your statement doesnt result in rows
07:00:10 <SamB_XP> i.e. for hurricane and tsunami, but not for blowing up the WTC
07:00:13 <EvanR-work> solution, connect, prepare, execute, commit
07:00:15 <EvanR-work> manually
07:02:01 <lpsmith> hmm
07:02:27 <EvanR-work> one thing that might help is tell the channel what your exception said
07:10:34 <lpsmith> EvanR-work, the exception said:   Takusen: DBError ("","") 1 ""
07:11:05 <lpsmith> However,  the row that I was trying to insert does appear in the database
07:13:28 <EvanR-work> thats a fairly useless error
07:13:40 <EvanR-work> hdbc gave real error messages
07:23:44 <narens> folks, does sequence_ build up the stack (through recursion) as it goes along or is it just a simple loop or does it depend on the action its running?
07:24:00 <Twey> sequence_ shouldn't build up a stack
07:24:02 <EvanR-work> @src sequence_
07:24:02 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
07:24:16 <narens> thats what i thought....
07:24:24 <narens> and anything that is tail recursive shouldn't either right?
07:24:33 <Twey> That's not necessarily the case
07:24:45 <narens> can you tell me if this will? because it seems like it is.
07:24:47 <roconnor> dmwit: have you seen nixos?
07:24:47 <narens> untilM_ (liftIO (getV h) >>= \v ->
07:24:48 <narens>            liftIO (putStrLn ("ep len: " ++ show (R.length v))) >>
07:24:48 <narens>            updateHidden hData v) (liftIO (hIsEOF h))
07:24:51 <lpsmith> > foldl (+) 0 [1..1000000]
07:24:54 <lambdabot>   * Exception: stack overflow
07:25:35 <EvanR-work> scheme like tail recursion is something that applies to strict evaluation strategy right?
07:25:41 <roconnor> dmwit: or nix rather.
07:26:10 <roconnor> EvanR-work: tail recursion is a special case of tail call elimination
07:26:11 <lpsmith> roconnor, do you use nix?
07:26:12 <Twey> EvanR-work: Mostly, yes
07:26:14 <roconnor> lpsmith: yep
07:26:29 <lpsmith> sweet,  how do you like it?
07:26:52 <EvanR-work> so im not sure how you could even identify a tail call in haskell
07:26:52 <roconnor> lpsmith: other than the fact I have to write my own packages for some software I want, it is great
07:27:21 <roconnor> EvanR-work: it's best not to.  I didn't even realize that ghc had a stack until last year.
07:27:56 <roconnor> EvanR-work: and I think it is possible to write a stackless haskell implementation
07:28:27 <EvanR-work> you can sort of identify a stack in a basic graph reduction implementation
07:28:49 <roconnor> EvanR-work: where do you see it?
07:29:03 <EvanR-work> 'unwinding the spine'
07:29:44 <EvanR-work> left most sequence of application nodes
07:30:05 <roconnor> EvanR-work: except that it is all on the heap right?
07:30:19 <roconnor> (though it is a stackish structure)
07:30:46 <EvanR-work> i suppose thats the most obvious choice
07:31:19 <roconnor> someone said you need a stack in order to a depth first traversal of your tree (graph actually)
07:31:31 <EvanR-work> and you can use auxilliary stack(s) to build up the arguments to a built in function
07:31:39 <roconnor> though I still think you could do clever things with flipping pointers backwards.
07:31:52 <narens> how to force a monadic action to be evaluated immediately?
07:31:57 <roconnor> and xoring pointers
07:32:05 <roconnor> narens: evaluate
07:32:12 <roconnor> @type evaluate
07:32:15 <narens> that only works for IO?
07:32:16 <lambdabot> Not in scope: `evaluate'
07:32:36 <Saizan> "monadic action to be evaluated immediately" <- this sounds like you're somewhat confused to me
07:32:38 <roconnor> narens: the notion of "immedattely" doesn't have any meaning in haskell denotations.
07:32:39 <EvanR-work> roconnor: well theres no need to traverse the tree in the implementation i was describing, but i dont know how ghc works
07:32:57 <narens> Saizan: Well, i meant strictly
07:32:58 <EvanR-work> narens: force the evaluation of any expression with seq
07:33:01 <roconnor> EvanR-work: ghc uses some sort of stack when evaluating case statements.
07:33:10 <EvanR-work> ah
07:33:14 <Twey> narens: evaluate will initiate the evaluation of any expression (to WHNF)
07:33:19 <zygoloid> narens: can you be more specific about what you want?
07:33:32 <Saizan> narens: why do you care when a monadic action get evaluate?
07:33:32 <Twey> Beyond that, use seq or one of its relations to propagate the evaluation as far as you need it
07:33:44 <Saizan> *gets evaluated
07:33:53 <zygoloid> @type (>>= (return $!))
07:33:54 <lambdabot> forall a (m :: * -> *). (Monad m) => m a -> m a
07:34:02 <narens> i have an untilM_ loop and in it I am running an two actions. One of which is putStrLn which if i run by itself does not trhow stack overflow... but with the other as well it does...
07:34:09 <benmachine> zygoloid: isn't that like
07:34:12 <benmachine> :t join seq
07:34:13 <lambdabot> forall a. a -> a
07:34:28 <benmachine> oh no I guess not
07:34:35 <benmachine> I suppose it's fmap seq
07:34:36 <roconnor> @src untilM_
07:34:36 <lambdabot> Source not found. My brain just exploded
07:34:44 <benmachine> except not that either
07:34:51 <benmachine> but close
07:34:57 <EvanR-work> untilM_ the most popular function not defined ;)
07:35:05 <roconnor> @src untilM
07:35:05 <lambdabot> Source not found. Wrong!  You cheating scum!
07:35:23 <Saizan> roconnor: untilM_ is something narens defied
07:35:47 <roconnor> ?untilM_
07:35:48 <lambdabot> Unknown command, try @list
07:35:49 <narens> any ideas why that might be? I should imagine because the second action is not getting evaluated each time in the loop but is building up.. ?
07:35:50 <roconnor> er
07:35:51 <roconnor> sorry
07:35:53 <Saizan> narens: well if the action is sequenced in a do-block it gets evaluated before the side-effects are executed
07:36:06 <Saizan> narens: can you show the code?
07:36:13 <narens> its pasted somewhere above
07:36:38 <benmachine> narens: so updateHiddenData is stack overflowing?
07:36:43 <roconnor> narens: what is your other monad?
07:36:45 <roconnor> state?
07:36:47 <Saizan> link?
07:36:49 <narens> its a stateT
07:36:50 <narens> yea
07:36:56 <zygoloid> Saizan: 14:24 GMT
07:37:11 <roconnor> narens: use strict stateT perhaps
07:37:25 <benmachine> you could try liftIOing evaluate
07:37:28 <narens> roconnor: i thought state was strict by default
07:37:36 <roconnor> I thought it was lazy by default
07:37:36 <benmachine> no it's lazy by default
07:37:42 <narens> okay
07:37:43 <benmachine> at least normal state it
07:37:44 <benmachine> is
07:37:49 <benmachine> so I assume StateT is
07:38:34 * roconnor worries strict StateT isn't strict enough for narens
07:38:43 * Saizan too
07:39:00 * benmachine doesn't worry because he is too easygoing for that
07:39:01 <EvanR-work> not sure where the problem is
07:39:04 <Saizan> if you never observe your state you've to add some strictness annotations
07:39:17 * Saizan is not sure either because he couldn't see the code yet
07:39:29 <EvanR-work> nothing to do with i/o actions, its just the algorithm is causing stack over flow?
07:39:41 <roconnor> EvanR-work: I think so
07:39:45 <narens> Saizan: can't show the code i'm afraid...
07:39:52 <EvanR-work> secret codes!
07:39:55 <narens> lol
07:40:29 <narens> My state just has an int and a mutable vector
07:41:03 <Saizan> is it a tuple?
07:41:11 <narens> Saizan: no
07:41:30 <Saizan> well, if importing Control.Monad.State.Strict didn't help
07:41:31 <narens> and updateHidden only updates the vector
07:41:38 <roconnor> narens: you probably want to add some strictness annoations to your updateHidden function .. I think.
07:41:44 <Saizan> ah, that's weird
07:41:44 <narens> actually, updatehidden just reads... doesn't even write
07:41:58 <roconnor> oh?
07:42:05 <benmachine> but if you remove it you get stack overflow?
07:42:10 <roconnor> *update*Hidden doesn't write anything?!
07:42:12 <benmachine> er
07:42:13 <benmachine> don't
07:42:21 <narens> updatehidden writes to an ioref...
07:42:24 <narens> not to the state
07:42:30 <EvanR-work> sounds like a messed up attempt at OOP
07:42:38 <Saizan> ah, then maybe the stackoverlow is hidden inside the IORef
07:42:40 <roconnor> strange you'd get a stack overflow
07:42:48 <roconnor> Saizan: ah
07:42:53 <Saizan> try being strict there
07:42:55 <benmachine> writeIORef $!
07:42:56 <roconnor> there is a strict IORef write isn't there?
07:43:11 <Saizan> what benmachine wrote :)
07:43:11 <EvanR-work> @src ($!)
07:43:12 <lambdabot> f $! x = x `seq` f x
07:43:15 <jmcarthur> i think in some package
07:43:17 <benmachine> there's a Data.IORef.Strict
07:43:19 <Twey> writeIORef ref $!
07:43:27 <benmachine> what Twey wrote :)
07:43:54 <benmachine> oh, Data.IORef.Strict is in the strict-io packagr
07:43:55 <narens> EvanR-work: well, its a non-liner opt code... so the state hold the current param estimates and then updateHidden uses that and data to do hidden data estimation (which is in an ioref) and then another loop takes the ioref and updates the params in state... for soem reason i didn't want to put both into the sate
07:43:56 <benmachine> package
07:45:00 <narens> okay, using strict state fixed it
07:45:31 <luqui> How do I tell cabal-install to install documentation.  preferably always.
07:46:25 <roconnor> narens: was it a one line change to your import statement?
07:46:31 <narens> weird... doing Contorl.Monad.State.Lazy fixes it..
07:46:35 <narens> don't know whats up with that
07:47:07 <roconnor> ya, I think the state monad has nothing to do with it.
07:47:17 <roconnor> since you aren't writing anything to the state.
07:47:40 <narens> roconner... but, it clearly overflows otherwise
07:47:43 <Saizan> luqui: "documentation: True" in your config
07:48:36 <luqui> Saizan, thanks!  Do you know if that will add to my local hoogle db automatically?
07:48:59 <Saizan> luqui: it won't
07:49:15 <Saizan> luqui: it'd be cool to add something like that though :)
07:49:30 <luqui> so i basically have to reinstall hoogle if i want it too?
07:49:32 <jmcarthur> luqui: graphics-geometrycombinators :o
07:49:32 <luqui> *to
07:49:38 <roconnor> narens: you say importing Control.Monad.State gives a stack overflow, but Control.Monad.State.Lazy does not?
07:49:50 <roconnor> narens: that is incrediable because the first simply rexports the second
07:50:32 <narens> roconnor: I am just checking it again.. make sure i am not insane
07:50:39 <luqui> jmcarthur, yeah :-)  it's real early though and i might abandon it, since the collada loader does everything we need except for transforming and appending
07:50:40 <Saizan> luqui: reinstall hoogle? well, one problem is that cabal-install won't generate the .txt file hoogle wants so that you could add it manually to your hoogle db
07:51:07 <luqui> Saizan, oh?  how did it get it in the first place?
07:51:25 <luqui> i have a local hoogle db that was magically generated somehow
07:51:36 <Saizan> ah :D
07:51:57 <Saizan> well, if you pass --hoogle to haddock it'll generate a .txt file
07:52:10 <Saizan> that hoogle can transform in its own binary format
07:52:18 <Saizan> and merge together with an existing db
07:52:27 <jmcarthur> huh i did not even think about the possibility of running hoogle locally with a local db
07:52:30 <jmcarthur> i must do this tonight
07:52:45 <luqui> jmcarthur, i have a local one for the packages installed and another local one just for the scope of this project
07:52:49 <luqui> it's pretty nice :-)
07:52:51 <jmcarthur> nice
07:53:00 <Saizan> the hoogle installation came with a premade db in the past, not sure what it does now
07:53:00 <EvanR-work> NICE
07:53:51 <Saizan> luqui: so you don't know how the one for your project got generated?:D
07:54:45 <luqui> i do know that.  i don't know how the one for the rest of the system got generated.
07:54:57 <luqui> in .cabal/packages.hoo or whatever
07:56:03 <Saizan> it simply got copied from the tarball
07:56:26 <Saizan> there's a database directory with lots of prebuilt ones
08:01:40 <luqui> ah
08:01:47 * juhp just discovered Haskellers Meeting 2010 Spring, in Tokyo...
08:02:06 <juhp> and is booked on a flight that night out of Tokyo hmm
08:02:14 <juhp> I may change...
08:02:32 <roconnor> juhp: how did you find out?
08:03:43 <juhp> because it is on the haskell.org front page :)
08:03:59 <juhp> which I just happened to check
08:04:18 <juhp> maybe because of the website thread??
08:04:50 <juhp> (it is only an evening meeting)
08:05:07 <juhp> but since I will be in Tokyo
08:10:43 <clouds> dons?
08:23:39 <flazz> is there a good intro to Vty? google is failing me
08:25:45 <Jafet> The documentation?
08:30:00 <dskippy> I am having a problem with record update syntax. I'm not sure if there's an elegant way to do what I want to do. I have a record and I would like to define many functions capable of updating it in various ways. But those functions are rather bulky. For example:
08:30:42 <Twey> dskippy: See the Data.Accessor package
08:30:48 <dskippy> data Person = { eyeColor :: Color, hairColor :: Color, height :: Int }
08:31:16 <dskippy> grow p = p { height = (height p) + 1 }
08:31:18 <Twey> data Person = Person { eyeColor, hairColor :: Color, height :: Int }
08:31:34 <dskippy> I'd prefer { height += 1 } if possible.
08:33:19 <FliPPeh> How'd I parse a file with a structure of "%KEY%\nvalue1\nvalue2\n...\n\n%KEY2%\n..."?
08:33:29 <fasta> Something like x{succ some_field_of_x} would be kind of nice.
08:33:33 <FliPPeh> lines, group by empty lines sounds wrong
08:33:58 <fasta> But there is always a price to be paid, because it complicated the language.
08:34:10 <fasta> complicates*
08:34:15 <Twey> FliPPeh: Why?
08:34:26 <Twey> Iteratees are probably the best solution, of course
08:34:47 <FliPPeh> What's up with Iteratees anyways?
08:34:53 <FliPPeh> I hear it too often to ignore it
08:34:58 <dskippy> If the field accessor were first-class it could work without much complication.
08:35:02 <fasta> dskippy, consider that you want to add some other expression to you height+=1 text. How do you do that?
08:35:08 <fasta> your*
08:35:11 <dskippy> Because I could then define the += operator.
08:35:23 <Twey> dskippy: That's basically what Data.Accessor gives you.
08:35:36 <fasta> dskippy, it would seem that you have to delete it and write it using the general syntax again.
08:35:38 <dskippy> Twey, yeah I'm reading it.
08:35:59 <dskippy> fasta: I don't think so. I'm reading Data.Accessor right now.
08:36:15 <Twey> FliPPeh: It's an approach to input designed to supplant lazy IO with something safer
08:36:39 <fasta> dskippy, Accessor has its own advantages and disadvantages.
08:38:02 <FliPPeh> That just confuses me even more :/
08:38:18 <FliPPeh> Let's see what giggitygoogle tells me about it
08:39:09 <Twey> FliPPeh: You really need to read Oleg's presentation to grok them
08:39:13 <Twey> Maybe a couple of times :þ
08:39:22 <FliPPeh> Is it worth it? :/
08:39:37 <Twey> Basically, it's a generalisation of folds to allow external input and to hide the state
08:39:42 <Twey> Heck yes
08:40:13 <FliPPeh> That paper looks really... naked
08:40:17 <FliPPeh> Without any examples
08:40:38 <Twey> I don't know about the paper, but the presentation has lots of examples.
08:40:52 <FliPPeh> http://okmij.org/ftp/Streams.html#iteratee
08:50:49 <ksf> hell's bells.
08:51:00 <fax> hi
08:51:03 <ksf> I put an undefined in my monad instance because I couldn't be bothered to figure out the typing.
08:51:04 <Twey> The netsplits have returned
08:51:10 <Twey> Heh
08:51:13 <ksf> the scary thing is: the code actually runs.
08:51:22 <fax> spooky!!!
08:51:50 <Twey> It's almost like Haskell doesn't care whether you have an undefined so long as nobody ever looks at it
08:52:02 * ksf replaces undefined with error "FIXME if needed..."
08:52:18 <Twey> Heh
08:52:23 <Twey> You're just going to leave it there?  :þ
08:53:04 <ksf> erm
08:53:05 <ksf> no.
08:53:07 <ksf> doesn't seem so.
08:53:13 <ksf> second test fails.
08:53:16 <Jafet> Could be a future gsoc!
08:55:13 <Twey> Heheh
08:58:06 <EvanR-work> implementation of functional programming languages lists a lot of FP languages with lazy evaluation, but i havent heard of any of them. are they all defunct now?
08:58:44 <Twey> Like what?
08:58:48 <EvanR-work> sasl, ponder, miranda
08:59:03 <Twey> Haskell superseded a lot of them
08:59:06 <EvanR-work> i see
08:59:10 <Twey> And others were proprietary
08:59:33 <fax> what do you mean defunct? None of them have active IRC channels on this network
08:59:48 <Twey> Ponder is special-purpose
08:59:57 <EvanR-work> they jsut didnt show up last time someone asks 'what are some other lazy "mainstream" languages
08:59:59 <Twey> SASL begot Miranda which begot Haskell
09:00:01 <EvanR-work> '
09:00:20 <Twey> Miranda was proprietary… don't know about SASL
09:01:37 <EvanR-work> is lazy becoming unpopular?
09:01:40 <EvanR-work> haskell is the last stand? :)
09:01:46 <fax> lazy has never been 'popular'
09:02:11 <fax> people still think garbage collection is for lazy people
09:02:12 <Jafet> Laziness is rather popular
09:02:24 <fax> and type systems 'hold you back' and stuff like this
09:02:33 <Jafet> Oh, you mean lazy evaluation
09:02:36 <EvanR-work> heh
09:02:58 <flux> I would like resource acquisition be handled more nicely in current modern type systems, though
09:03:23 <flux> while you can have a monad for a resource and prevent leaking that way, linear type feel like they are a better solution for it
09:03:38 <sungji> hm... how can a list of chars be represented as a binary tree, when the leafs carry the chars (in a preorder fashion) ?
09:03:46 <flux> but perhaps I'd better try one (miranda) before making broad statements about its greatness :)
09:03:54 <Twey> Lazy evaluation is becoming more popular
09:03:56 <flux> uh, s/miranda/clean/
09:04:08 <EvanR-work> clean is the other one
09:04:21 <EvanR-work> the one thats not haskell ;)
09:04:22 <Twey> It's seeping into mainstream languages in the forms of things like generators
09:04:51 <fax> sungji: in T(n) ways?
09:04:55 <Twey> And ‘Iterable’ interfaces
09:05:46 <sungji> fax, heh sorry. I'm trying to understand the datastructure in order to implement a solution to this problem in haskell :)
09:06:49 <fax> sungji: if you consider a string "sungji" as  ['s'] ++ ['u'] ++ ['n'] ++ ...  the number of trees you can do is the number of ways to parenthesise that I guess, which would be stirling numbers (?)
09:07:07 <sungji> I have to implement a function that returns the character at position i    (characters are stored in data RTree a = RLeaf a | RNode Int (Rtree a) (Rtree a), where the nodes carry the lengths of their sublist
09:07:16 <fax> what's that Int for?
09:07:22 <sungji> the length of the sublist
09:07:25 <fax> ah of course
09:09:07 <ksf> @djinn (Int -> m ( Iteratee c t m a)) -> (a -> Iteratee c t m b) -> Int -> m (Iteratee c t m b)
09:09:08 <lambdabot> Error: Undefined type Int
09:09:13 <ksf> ...
09:09:27 <Jafet> No Prelude for free.
09:10:05 <ksf> ...at least I've got the type nailed down by now.
09:11:18 <sungji> fax, i mean I could traverse the tree and build a list (preorder) and build a list of chars, then zip it with [1..] and get the char by using list comprehension.
09:11:38 <sungji> fax, but it should be easier :)
09:11:45 <fax> actually that is the easiest way
09:11:49 <sungji> oh ok
09:11:56 <fax> but it's not most efficient
09:12:09 <EvanR-work> is list comprehension useful
09:12:32 <Twey> No, just pretty
09:12:44 <ksf> the usefullnes of forks depends on whether you're eating soup.
09:13:19 <jmcarthur> speaking of regions... i don't suppose anybody knows how to keep a particular resource from being used in a particular child region without preventing other resources from being used in it?
09:13:41 <jmcarthur> probably would have to change the monad a bit even if it's possible at all
09:13:45 <sungji> I think I could come up with a better (more elegant) solution, once I got how a list is transformed in a binary tree (preorder) and that's my problem at the moment.
09:13:58 <sungji> s/in/into
09:14:02 <ksf> jmcarthur, don't pass it in?
09:14:17 <EvanR-work> sungji: what criteria are you using for elegant here
09:14:19 <fax> sungji, there are multiple trees for a given string
09:14:24 <fax> http://www.pasteit4me.com/287005
09:14:30 <jmcarthur> ksf: that's what i want to prevent
09:14:31 <fax> but let us consider a particular one, just for example
09:14:37 <fax> sunji, see this paste?
09:14:45 <fax> how will you find the 4'th character ('g')
09:14:46 <ksf> jmcarthur, think capability based systems
09:14:48 <sungji> fax, hang on a sec
09:15:01 <sungji> fax, yes sir
09:15:03 <ksf> one capability is to transfer capabilities
09:15:16 <jmcarthur> ksf: here's some context: within this child region there is another resource which invalidates the resource i want to block until it's closed
09:15:31 <sungji> EvanR-work, i think the TAs made use of the lengths, stored in the nodes or something...
09:15:58 <EvanR-work> sungji: fastesr? or smaller code? or
09:16:04 <ksf> I think you're overdesigning.
09:16:15 <fax> sungi,  RNode 3 (RNode 2 (RNode 1 (RLeaf 's') (RLeaf 'u')) ...
09:16:16 <sungji> EvanR-work, definitely not faster, probably smaller code
09:16:34 <fax> sungji, that is the data which this picture I pasted corresponds to -- you see the relation ?
09:16:43 <sungji> fax, yes
09:16:54 <ksf> the problem starting with expressing what "to invalidate" means
09:16:57 <jmcarthur> ksf: that is, i have resource X. i expose a function that creates resource Y from resource X and accepts a continuation taking resource Y as an argument, and that continuation is in a child region. i want to prevent resource X from being used in that continuation
09:17:13 <fax> so you see how to find fourth character ('g') .. you need not travel down the left hand path
09:17:19 <sungji> fax, hm but when does one decide when to "split" the tree (the node that carries "3")
09:17:19 <sungji> ?
09:17:32 <jmcarthur> ksf: i know it's a sucky design, but i'm wrapping an abstraction around mapping vertex buffer objects into memory
09:17:32 <fax> sungji, what do you mean - this tree is given we are not making a tree
09:17:43 <sungji> fax, ah ok
09:17:46 <jmcarthur> ksf: currently i just have an unsafe function to do it, but i'd rather make it type safe
09:17:47 <ksf> don't you want to pass ressource X back to the parent?
09:17:54 <fax> sungji, there are many trees for any given string -- uppose we are given any particular one: How do we find the i'th character
09:18:01 <jmcarthur> ksf: resource X is in the parent already
09:18:11 <ksf> er yes ressource Y
09:18:21 <jmcarthur> no, resource Y should be closed at the end of the continuation
09:18:45 <jmcarthur> well, alternatively it could be retained, but that woudl require more hackery to prevent resource X from being used until resource Y is closed
09:19:01 <ksf> then pass the child Y -> (Y -> IO a) -> IO a
09:19:11 <ksf> er without the first Y
09:19:17 <ksf> and return it to the parent I mean
09:19:26 <fax> sungji, the 'best' tree is that which the left and right branches are almost equal in size
09:19:33 <ksf> do an existential to keep it from escaping
09:19:39 <Twey> with*?
09:19:39 <fax> sungji, (my paste is the best tree)
09:19:41 <jmcarthur> ksf: that's not the issue
09:19:51 <jmcarthur> ksf: the issue is preventing resource X from being used in the continuation
09:20:00 <jmcarthur> ksf: i'm already preventing Y from escaping
09:20:07 <fax> sungji, it means you only will have to take roughly log(n) steps to find a character
09:20:07 <ksf> now I see
09:20:18 <sungji> fax, I see. I just thought there's a convention or a rule I didn't consider (i'm really weak when it comes to datastructures)
09:20:20 <fax> sungji, (log(n) corresponding to repeated division by two)
09:20:32 <ksf> I'd say, it's possible.
09:20:38 <fax> sungji, yes but the point is that we don't need it to be best, it can be any tree and the algorithm should still work
09:20:49 <jmcarthur> ksf: i could just prevent *all* external resources from being used in the continuation, but i don't want that. i only want to prevent a certain one from being used
09:20:51 <fax> sungji, it is just that, if the tree is best -- we will find the character quickly
09:20:53 <ksf> and I'd dub the solution capability barriers, where everything is reauthed.
09:21:09 <sungji> fax, mhm alright.
09:21:12 <fax> sungji, in some sense lists [Character] are the worst
09:21:23 <sungji> fax, oh yeah, it could be O(n)
09:21:27 <sungji> instead of log(n)
09:21:31 <fax> sungji, because it's a tree with always '1' in every RNode
09:21:32 <sungji> if the tree is linear
09:21:34 <fax> yes
09:21:58 <ksf> jmcarthur, when you do that, be sure to tell someone interested in OS design about your implementation.
09:22:49 <jmcarthur> ksf: when i do what? prevent the one or prevent all? i can already prevent all :P
09:22:56 <fax> sungji, I just realized -- I've been saying that 'g' is the fourth character... but it is normal to count starting from 0 -- so I should really say that g is the third character
09:23:09 <ksf> when you can prevent all, then you can allow some.
09:23:17 <Twey> Not with ordinals, we don't
09:23:23 <Twey> It's the fourth character, in position 3
09:23:31 <jmcarthur> ksf: have you used the regions package?
09:23:35 <ksf> nope
09:23:42 <jmcarthur> well, that's the context i'm in
09:25:57 <sungji> fax, that's ok. I'm trying to find the solution and will be back in a few. thanks!
09:27:19 <JoelMcCracken> I've always been under the impression that haskell does memoization automatically; is this correct?
09:27:42 <Twey> It does some types of memoisation (sharing) automatically
09:29:09 <quicksilver> JoelMcCracken: short answer "No".
09:29:20 <jmcarthur> JoelMcCracken: the evaluation model will not evaluate shared values more than once, but that's not quite memoization
09:29:36 <jmcarthur> JoelMcCracken: because not all identically computed values are shared
09:29:51 <quicksilver> or it is (in a sense) a simple special case of memoization but it is generally not what most people are thinking of
09:30:02 <quicksilver> most people are thinking of memoizing the (results of) functions (applied to particular arguments)
09:30:10 <JoelMcCracken> hmm, so then i guess i'll need to do  the mentioned on the haskell wiki
09:30:48 <jmcarthur> JoelMcCracken: most memoization tricks rely critically on sharing, which just adds to the confusion
09:30:50 <ksf> now my code runs _and_ barfs Prelude.undefined.
09:31:00 <ksf> whithout a single undefined in my code.
09:31:30 <Axman6> whoot!
09:33:06 <ksf> :t (\c -> kk c >>= (\kc -> return $ kc >>= k) )
09:33:07 <lambdabot> Not in scope: `kk'
09:33:21 <ksf> @pl (\c -> kk c >>= (\kc -> return $ kc >>= k) )
09:33:21 <lambdabot> ((k =<<) `fmap`) . kk
09:33:52 <ksf> :t (\kk c -> kk c >>= (\kc -> return $ kc >>= k) )
09:33:53 <lambdabot>     Couldn't match expected type `a -> m b'
09:33:54 <lambdabot>            against inferred type `Expr'
09:33:54 <lambdabot>     In the second argument of `(>>=)', namely `k'
09:34:09 <ksf> :t (\k kk c -> kk c >>= (\kc -> return $ kc >>= k) )
09:34:10 <lambdabot> forall t (m :: * -> *) (m1 :: * -> *) a b. (Monad m, Monad m1) => (a -> m1 b) -> (t -> m (m1 a)) -> t -> m (m1 b)
09:35:28 <ksf> @hoogle (Monad m, Monad m1) => (a -> m1 b) -> (t -> m (m1 a)) -> t -> m (m1 b)
09:35:28 <lambdabot> Language.Haskell.TH.Quote dataToQa :: Data a => (Name -> k) -> (Lit -> Q q) -> (k -> [Q q] -> Q q) -> (b -> Maybe (Q q)) -> a -> Q q
10:03:32 <Jafet> Does ghc unbox arrays as an optimization?
10:03:45 <Jafet> Say, an array of Int64s
10:04:09 <lispy> Jafet: I think you have to use unboxed arrays
10:04:21 <zygoloid> Jafet: that's not an optimization since it changes the semantics of your program.
10:04:37 <quicksilver> zygoloid: well, that's not quite fair
10:04:39 <zygoloid> Jafet: an array of Int64s can contain 'undefined's; an unboxed array cannot
10:04:40 <lispy> Jafet: but I'm not sure.  If you need good array performance, look into something like vector.
10:04:53 <quicksilver> GHC will unbox individual Ints if it knows that it *won't* change semantics
10:05:01 <quicksilver> in principle you can imagine it might do that for arrays
10:05:07 <quicksilver> (however, it is not that smart, so it doesn't)
10:05:11 <Jafet> It won't infer that for arrays, then
10:05:17 <c_wraith> yeah, look at the vector package
10:05:19 <quicksilver> correct, it won't
10:05:34 <Jafet> Ok, I'll change to Unboxed
10:05:38 <zygoloid> quicksilver: hrm, good point :)
10:07:00 <quicksilver> I thought someone (dons?) had written a post about haskell and modern array-ish libraries but I can't find it
10:07:09 <quicksilver> I think you probably want to consider vector, anyhow
10:08:48 <c_wraith> yeah, dons wrote about vector replacing uvector, now that dph has progressed significantly
10:18:42 <ksf> do we have copy on write Ptrs?
10:19:09 <ksf> I hate to alloc all the time, and common usage should be to discard stuff quickly
10:23:05 <ksf> google.
10:23:22 <ksf> you search for "copy on write" and get results on how to feed cattle.
10:24:33 <fax> % cabal install agda
10:24:33 <fax> Resolving dependencies...
10:24:33 <fax> cabal: cannot configure QuickCheck-2.1.0.3. It requires ghc -any
10:24:33 <fax> There is no available version of ghc that satisfies -any
10:24:37 <fax> does anyone know how to sort that?
10:24:43 <fax> my ghc is not any ghc
10:26:08 <Saizan> fax: that's referring to the ghc package
10:26:21 <Saizan> fax: which is the one exporting the ghc-api lib
10:26:30 <Saizan> i think, at least.
10:27:20 <Saizan> not sure why QuickCheck needs that though
10:27:37 <Younder> ksf: ? :)
10:28:11 <ksf> ...seems everyone is relying on fusion, instead
10:28:35 <ksf> currently, I'm mallocing a new buffer for everything I get send over the network
10:29:22 <ksf> ...but it's not written to, except when the next packet arrives.
10:29:28 <Younder> ksf: google adjusts it's profile depending on the links you have chosen in the past.. Have you expressed a particular interest in the bovine comunity?
10:29:47 <benmachine> :q
10:29:49 <ksf> I think it's just translating copy on write to cow
10:29:52 <benmachine> that didn't happen
10:30:45 <ksf> as 99% of all those buffers will have been fully analysed before I read the next (that's a guesstimation), it doesn't really make sense to malloc all the time.
10:31:02 <Saizan> fax: i could be wrong though
10:31:23 <ksf> otoh, I guess the gc is doing a fine job of making those mallocs cheap.
10:32:00 <Younder> ksf: none of my top 10 hits refer to cow's. the first is http://en.wikipedia.org/wiki/Copy-on-write
10:32:16 <ksf> second page. without quotes.
10:32:26 <ksf> oh, and with haskell.
10:33:37 <fax> The following packages are broken, either because they have a problem
10:33:37 <fax> listed above, or because they depend on a broken package.
10:33:37 <fax> ghc-6.12.1
10:33:37 <fax> bin-package-db-0.0.0.0
10:33:40 <fax> that is scary
10:33:43 <fax> apparently ghc is broken
10:33:58 <ksf> using a ring buffer or such would also allow me to sensibly get rid of fionread
10:34:05 <ksf> that's another userspace/kernel roundtrip.
10:35:50 <Saizan> fax: you often have to reinstall your ghc to fix that
10:36:02 <fax> I wish I could do cabal install ghc
10:37:33 <Saizan> the binary tarball works quite well in the meantime :)
10:37:39 <jmcarthur> yeah that'd be awesome
10:47:15 <mmaruseacph2> hi, can i ask for more feedback on a gsoc proposal?
10:48:12 <lispy> mmaruseacph2: better to just ask :)  also, I've seen others asking on haskell-cafe
10:48:22 <mmaruseacph2> http://www.haskell.org/pipermail/haskell-cafe/2010-April/075748.html
10:48:25 <mmaruseacph2> it is allready there
10:48:39 <mmaruseacph2> but I've received no feedback since posting it
10:48:52 <mmaruseacph2> (I did receive some before, it's true)
11:04:25 <sungji> fax, data RTree a = RLeaf a  | Rnode Int (RTree a) (RTree a). ... step case: getat (RNode x l r) i = | i + len r >= x    =  getat r (i - len l)    otherwise = getat l i     (the trick was to somehow get information beforehand (done here using a separate length (len) function)
11:04:30 <sungji> fax, thanks again!
11:04:45 <fax> :)
11:05:01 <fax> you have got this wrong
11:05:12 <sungji> hang on a sec
11:06:01 <lispy> mmaruseacph2: I like the idea of this project very much.  I asked some people here to comment when I saw your post yesterday.  Too bad  no one is jumping on it.
11:06:07 <sungji> fax, hmmmmmmmmmmmmmmmmmm but it seemed to work on paper :)
11:06:19 <fax> sungji -- look at my picture in that paste:  Are those numbers correct?
11:06:21 <lispy> mmaruseacph2: I agree that Haskell needs better debugging facilities
11:06:34 <sungji> fax, looking...
11:07:00 <lispy> When you're having FFI bugs and what not, it seems that currently people are up to individual heroics and cleverness to resolve them
11:07:01 <sungji> fax, hm doesn't the 1 have to be a 2 ?
11:07:11 <sungji> (left hand side)
11:07:13 <fax> which 1
11:07:16 <lispy> Ideally, we have some introspection into our programs to aid our reasoning
11:07:50 <fax> there are three 1's
11:08:19 <sungji> fax, I would have numbered them (ltr) : 2,3,6,3,2  (length leaf = 1)
11:08:28 <sungji> (them == nodes)
11:08:34 <fax> who says to number it this way?
11:08:42 <lispy> mmaruseacph2: important considerations in your proposal: 1) can you convince us there is community impact (should be easy for you), 2) Can you convince us that your proposal is reasonable for your skills and alloted time.  Specifically, can you make a detailed specification/roadmap of what you'll deliver and when?  Break it out by week.  Build in time for getting stuck.
11:09:06 <sungji> fax, the text "every node stores the length of the list it represents in the Int argument."
11:09:14 <fax> hmm okay
11:09:18 <lispy> mmaruseacph2: tell us how you'll work around the most likely roadblocks
11:09:26 <sungji> fax, but it's still wrong, right? :)
11:09:32 <fax> sungji, well that sucks
11:09:36 <fax> my way is much better
11:10:00 <sungji> fax, no, what I meant was: my solution is still incorrect, even with my numbering
11:10:02 <sungji> ?
11:10:12 <fax> sungji, you can see that if we have   RNode x _ (RNode y _ _)   x - y gives the numbering I was using
11:10:26 <fax> and with that you can implement this search without needing 'len'
11:10:31 <lispy> mmaruseacph2: how will you negotiate your changes with the devs?  Do you know their policies for accepting patches?  (note: working in seclusion and then handing them the repo when you're done and letting them merge is a very unattractive idea.  Think continual integration.)
11:10:51 <mmaruseacph2> thanks lispy
11:10:52 <fax> sungji, wait a second, maybe I misunderstood you
11:10:56 <fax> sungji, is len O(1)?
11:10:56 <mmaruseacph2> i'll answer soon
11:11:06 <sungji> yes
11:11:11 <fax> sungji, I was thinking len is O(n) but if it's O(1) then that is fine
11:11:12 <c_wraith> Is anyone around involved with the snap web framework project?
11:11:14 <lispy> mmaruseacph2: okay.  I don't watch this channel much, so I may not see it :)
11:11:16 <sungji> fax,  len (RNode s _ _) = s
11:11:31 <mmaruseacph2> i'll respond to the haskell-cafe thread
11:11:36 <fax> yes okay I don't think it's wrong anymore -- I ws thinking of a different numbering
11:11:38 <lispy> mmaruseacph2: great
11:11:44 <fax> I think the way I number it gives simpler algorithm though...
11:11:48 <sungji> fax, phew :D
11:13:00 <sungji> fax, I think they put that 'weird' numbering in to provide an additional obstacle. Nevertheless, my other solution was way less elegant, but I've had it finished way earlier :D
11:14:01 <sungji> fax, on the other hand, why would you number a node with two leafs as a 1?
11:14:21 <fax> sungji, I just count what's on the left tree
11:14:28 <sungji> fax, oh ok
11:14:35 <fax> that way you don't need len
11:19:57 * hackagebot hxt-xpath 8.5.3 - The XPath modules for HXT.  http://hackage.haskell.org/package/hxt-xpath-8.5.3 (UweSchmidt)
12:07:42 <sshc> GHCi runtime linker: fatal error: I found a duplicate definition for symbol fps_minimum whilst processing object file /usr/local/lib/bytestring-0.9.1.6/ghc-6.12.1/HSbytestring-0.9.1.6.o This could be caused by: * Loading two different object files which export the same symbol* Specifying the same object file twice on the GHCi command line* An incorrect `package.conf' entry, causing some object to be loaded twice.  GHCi cannot safely continue in this situatio
12:10:03 <Cale> sshc: Need help with this?
12:10:26 <Cale> sshc: When does it happen? Every time you start GHCi?
12:10:59 <mercury^> Why would it link bytestring?
12:11:30 <Cale> Well, okay, that would be strange :)
12:11:39 <sshc> Cale: It happens every time "Loading package bytestring-0.9.1.6 ..." is printed, and that error is printed immediately after that
12:12:00 <mercury^> I would suggest not to use bytestring, but probably that doesn't satisfy you. ;)
12:12:02 <Cale> sshc: Can you hpaste the result of running  ghc-pkg list ?
12:12:26 <sshc> Cale: hpaste?
12:12:31 <mmaruseacph2> lispy: answered to your feedback, thanks
12:12:32 <Cale> hpaste.org/new
12:13:06 <sshc> Of course
12:14:59 <mmaruseacph2> here is my updated proposal for the GSoC
12:15:00 <mmaruseacph2> http://www.haskell.org/pipermail/haskell-cafe/2010-April/075848.html
12:15:10 <sshc> Cale: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24723#a24723
12:15:21 <mmaruseacph2> I'll be more than grateful if more people will give more feedback
12:15:22 <mmaruseacph2> :D
12:15:37 <sshc> I should probably run
12:15:46 <sshc> ghc-pkg check
12:16:07 <sshc> XFCE's terminal (not using the wm) is horrible with paste
12:16:35 <EvanR-work> 14:14 < mmaruseacph2> I'll be more than grateful if more people will give more  feedback
12:16:40 <EvanR-work> 14:15 < EvanR-work> 14:14 < mmaruseacph2> I'll be more than grateful if more  people will give more  feedback
12:16:49 <jmcarthur> ...
12:17:08 <EvanR-work> there ya go ;)
12:17:57 <mmaruseacph2> EvanR-work: i don't understand:/
12:18:18 <EvanR-work> feedback, bah nevermind
12:18:20 <Cale> sshc: hmm, well, you do have two versions of bytestring installed. While that theoretically shouldn't be a problem, bytestring is one of those packages which it's usually not a good idea to have more than one version of
12:18:58 <Cale> (because building things against different versions of bytestring will cause them to become incompatible with one another and you end up in dependency hell)
12:19:17 <applicative> can he just do ghc-pkg hide bytestring etc
12:19:28 <sshc> Cale: How do I remove the older versions?
12:19:39 <benmachine> I appear to have six versions of haskell-src-exts installed
12:19:46 <applicative> ssch, try the simple hide expedient first
12:19:51 <mmaruseacph2> EvanR-work: well, without feedback there will be no improvements
12:19:57 <sshc> Loading package bytestring-0.9.1.5 ... linking ... done.
12:20:04 <sshc> Loading package bytestring-0.9.1.6 ...
12:20:09 <sshc> <error>
12:20:19 <benmachine> what are you trying to do that needs both?
12:20:23 <Cale> Hmm, I wonder which one you should keep.
12:20:33 <sshc> The newer one
12:20:35 <Cale> You should probably keep whichever one came with GHC 6.12
12:20:38 <sshc> But how do I remove or hide teh oder one?
12:20:44 <benmachine> 0.9.1.5 is what I've got
12:20:55 <benmachine> (with 6.12)
12:21:03 <Cale> Okay, so keep that one, ditch the other
12:21:12 <sshc> Ok.  How?
12:21:34 <Cale> ghc-pkg unregister bytestring-0.9.1.6 --- or replace 'unregister' with 'hide'
12:21:35 <applicative> sshc, there is ghc-pkg hide and ghc-pkg  unregister
12:22:09 <sshc> ghc-pkg: unregistering bytestring-0.9.1.6 would break the following packages: utf8-string-0.3.6 hslogger-1.0.10 network-2.2.1.7 parse
12:22:27 <benmachine> what would unregistering 0.9.1.5 break
12:22:28 <sshc> ghc-pkg: unregistering bytestring-0.9.1.5 would break the following packages: QuickCheck-2.1.0.3 regex-compat-0.92 X11-xft-0.3 parsec-3.0.1 binary-0.5.0.2 utf8-string-0.3.4 bin-package-db-0.0.0.0 regex-posix-0.94.1 ghc-binary-0.5.0.2 xmonad-contrib-0.9.1 regex-base-0.93.1 ghc-6.12.1 ghc-mt
12:22:32 <applicative> try hide, it's ess radical anyway
12:22:33 <benmachine> hmm
12:22:33 <Cale> Yeah, you probably have a bad situation now where lots of things are built against the wrong version of bytestring
12:22:49 <sshc> applicative: Hide which?
12:22:59 <sshc> Cale: What should I do then?
12:23:04 <Cale> It's always best to stick with the version of bytestring that came with ghc, since the ghc package itself relies on it.
12:23:18 <Cale> and hence, everything which relies on that package relies on it
12:23:47 <benmachine> sshc: every package you use in a project has to be built against the same version
12:23:54 <Cale> So I guess unregister and reinstall all the packages which depend on the newer bytestring
12:24:00 <applicative> so this is why cale is saying remove the later
12:24:17 <benmachine> which is only four by the looks of things
12:24:19 <benmachine> not so bad then
12:24:21 <applicative> sorry, i keep echoing accidentally
12:25:43 <applicative> presumably hslogger can go first.  are network and utf8string likely to be independent?
12:26:21 <benmachine> network could be unpleasant
12:27:00 <Cale> I wish the package system was a little smarter about not getting itself into these situations...
12:27:01 <applicative> this isn't a haskell platform installation, he only has one network, but it uses a later bytestring
12:27:05 <benmachine> 220 direct and 150 indirect dependencies on network-2.2.1.7
12:27:19 <benmachine> according to the reverse deps thing
12:27:32 <benmachine> on all of hackage
12:27:45 <applicative> oh, sshc didn't print everything that would break?
12:27:56 <benmachine> pass
12:28:15 <benmachine> either I'm expecting the dependencies of network to break and they won't
12:28:21 <benmachine> or cabal-install doesn't realise they will break
12:28:24 <applicative> sshc only has 56 packages
12:28:34 <benmachine> yes
12:28:55 <benmachine> all I meant with those numbers is that network is quite a used package
12:29:28 <EvanR-work> whats the difference between network that comes with ghc and the hackage package
12:29:37 <applicative> sshc do ghc-pkg unregister network and see how threatening it is
12:30:18 <benmachine> EvanR-work: there isn't a network that comes with ghc is there?
12:30:31 <EvanR-work> i thought there was
12:30:39 <benmachine> don't think so
12:30:53 <benmachine> it's one of those things you need to install while bootstrapping cabal if I recall correctly
12:30:56 <applicative> the riddle is that his network uses a later bytestring
12:31:13 <EvanR-work> benmachine: about a year ago when i first tried haskell, i never used cabal
12:31:30 <EvanR-work> maybe things were different back then
12:31:33 <benmachine> maybe
12:33:52 <sshc> I just did "ghc-pkg unregister --force bytestring-0.9.1.6" and then "cabal install --global --reinstall utf8-stringhslogger network 'parsec >= 3'" and the installation went well
12:33:59 <sshc> But how I unhide bytestring?
12:34:37 <sshc> Ah, expose
12:34:38 <applicative> ghc-pkg expose bytestring...
12:34:55 <sshc> Everything works greatly now :)
12:35:05 <applicative> excelllent!
12:35:44 <applicative> network has given me trouble, no doubt inevitably.  I remember a comment in the c bits:  /* ultra-evil... */
12:36:06 <Twey> Of course.  It's in C.  ;)
12:36:38 <applicative> I think he was thinking its c so it's evil, bit this..../* ultra-evil... */
12:37:00 <Twey> Heh
12:38:18 <EvanR-work> at least c has a type system
12:38:24 <EvanR-work> this php is super ultra evil
12:39:02 <Twey> PHP has about as much of a type system as C does
12:39:22 <applicative> surely real men don't need type systems
12:39:33 <benmachine> C has variable declaration though
12:39:35 <bremner> what C lacks is millions of weekend warrior programmers
12:39:41 <jmcarthur> at least C's type system is somewhat predictable
12:39:47 <benmachine> I really like variable declaration I don't understand why everyone seems to have stopped using it
12:39:57 <jmcarthur> i don't like variable declaration
12:40:05 <jmcarthur> what's the point?
12:40:26 <benmachine> well, I've written python in which a typo is an extremely subtle runtime error
12:40:34 <Ke> makes typos less probablt
12:40:36 <benmachine> where it really should be compile-time
12:40:43 <benmachine> not that python is compiled
12:40:45 <benmachine> but whatver
12:40:47 <benmachine> +e
12:41:02 <benmachine> and anyway it makes things easier to understand imo
12:41:09 <zygoloid> PHP trivia: how can '$y ? $x / $y : 0' generate a division-by-zero error? :)
12:41:10 <benmachine> you can see what's going to be around and when
12:41:21 <jmcarthur> benmachine: that has less to do with lack of declarations than with lack of static typing
12:41:35 <pikhq> zygoloid: !!!
12:41:40 <benmachine> jmcarthur: okay but I still like declarations
12:41:41 <arw_> zygoloid: $y = "0foobar"?
12:41:44 <benmachine> they make scoping clearer
12:41:59 <jmcarthur> type annotations serve the purpose of declarations as far as sanity checking
12:41:59 <zygoloid> arw_: $y = "0.0" is enough :)
12:42:10 <jmcarthur> meh, i don't feel like i'm ever confused over scoping
12:42:20 <benmachine> lucky you
12:42:29 <benmachine> we can't all be so brilliant :P
12:42:35 <jmcarthur> reasonable code formatting is all that's necessary to make it clear
12:42:43 <jmcarthur> i really don't think this has to do with intelligence :P
12:43:08 <benmachine> well, okay
12:43:23 <arw_> jmcarthur: reasonable formatting and a language where scoping isn't broken...
12:43:25 <benmachine> I feel unable to argue any further because I haven't done any PHP or anything in a while
12:43:35 <benmachine> maybe I just like them because I learnt C first and it's a hard habit to shake
12:43:53 <benmachine> but I just like seeing what's going to happen in this block before it does
12:44:03 <benmachine> in a crude sort of fashion
12:44:24 <jmcarthur> arw_: i guess if we're talking about php or perl specifically then scoping could be a more interesting topic than i'm making it out to be, but i avoid those languages ;)
12:45:07 <benmachine> the frustrating thing about scoping is it's so easy in C
12:45:13 <benmachine> a thirty year old language
12:45:27 <benmachine> seems like a lot of languages have gone backwards from there
12:45:38 <pikhq> Yes. Scoping is easy to do right and people still fuck it up.
12:48:30 <olsner> is it easier to do it wrong perhaps?
12:48:53 <pikhq> Apparently.
12:52:39 <Baughn> Wasn't there some kind of in-memory database library written entirely in haskell? Using logging for persistence?
12:53:51 <jmcarthur> Baughn: like happstack-state?
12:53:53 <Twey> Are you thinking of Happstack.State?
12:54:01 <Twey> It's not really a database, but the rest fits
12:54:01 <Baughn> Likely. Thanks
12:54:10 <jmcarthur> there's also something called tcache or something
12:54:20 <jmcarthur> i forget the name
12:54:42 <c_wraith> persistent-cache is the name of the package
12:54:42 <Baughn> And it integrates with STM, yay. ^_^
12:54:49 <jmcarthur> ah that's it
12:54:52 <c_wraith> persistent-cache isn't very good
12:55:02 <Baughn> TCache exists
12:55:06 <jmcarthur> i've used happstack-state and like it
12:55:17 <jmcarthur> never used persistence-cache or tcache
12:55:21 <c_wraith> TCache is the one from the persistent-cache package
12:55:22 <Baughn> But yes, I think I'll use happstack-state.
12:55:32 <c_wraith> I have used it.  It has space leaks
12:55:33 <Baughn> It's probably faster than sqlite, and my data /does/ fit in memory
12:55:45 <Baughn> (And if it isn't faster, I don't care.)
12:55:47 <Twey> I like the idea behind MACID, but I'm a little scared of limiting myself to $total_ram_size of data
12:55:52 <Twey> It is faster
12:56:38 <Twey> But I think I'd be happier sacrificing a little speed for assurances that things aren't going to blow up if I exceed 1GB of data in my case (admittedly that's probably not the case for biiig sites)
12:56:50 <jmcarthur> i would like to see hints for happstack-state about whether to favor data being in memory or not
12:57:07 <jmcarthur> where things can be serialized out to hard drive exclusively if needed
12:57:54 <jmcarthur> hard drives aren't fast, but they have a lot of capacity, and i think it's kind of a waste not to use it for many kinds of data
13:01:39 * hackagebot NumLazyByteString 0.0.0.1 - Num, Enum, Eq, Integral, Ord, Real, and Show instances for Lazy ByteStrings  http://hackage.haskell.org/package/NumLazyByteString-0.0.0.1 (ThomasDuBuisson)
13:03:40 <Baughn> jmcarthur: FWIW, I agree with everything you've said. Using memory for storage is not a major issue right now, as this is a research project anyway and it's reasonable to state "happstack's interface lends itself to adding such cues", but it sure would be nice if they already existed. ;)
13:04:03 <Baughn> jmcarthur: Something for a SoC project, maybe? It's almost the only thing missing to make the thing completely general.
13:04:07 <Twey> jmcarthur: Aye
13:05:23 <Baughn> Or.. well, it probably wouldn't take a full summer. Something like "clean up minor issues on these more-or-less core packages that we can't be bothered to clean ourselves" seems a bit /demeaning/, though.
13:06:09 <Twey> Heheh
13:06:10 <jmcarthur> yeah...
13:06:26 <EvanR-work> benmachine: wait, how old is c now? :)
13:06:36 <Baughn> Forty.. thirty-five years?
13:06:58 <EvanR-work> whenever i try to calculate stuff like that i for some reason use 'current year' as 1998 or something ;)
13:07:08 <EvanR-work> which is starting to accumulate some error
13:07:45 <ville> Stuck with C++?
13:07:55 <olsner> it seems there's often a specific time in life at which you learn how old things are
13:08:02 <jmcarthur> the 80s started 20 years ago to me
13:08:15 <EvanR-work> heh
13:08:20 <jmcarthur> i guess my reference date is 200
13:08:22 <jmcarthur> *2000
13:08:38 <jmcarthur> worked great until around 2005
13:08:48 <benmachine> EvanR-work: haha me too :x
13:09:43 <EvanR-work> in a lot of ways everything still feels like 1998 :S
13:10:29 <olsner> the computers are just slightly faster
13:10:39 <olsner> and ghc had fewer type-system extensions
13:20:31 <Baughn> "ghc: dist/build/Happstack/Data/Default.o: unknown symbol `sybzmwithzmclasszm0zi6zi1_DataziGenericsziSYBziWithClassziInstances_constrZMacNkZN_closure'" <-- I love it when this happens. It really makes my day.
13:21:06 <EvanR-work> sybzmwithzmclasszm0zi6zi1_DataziGenericsziSYBziWithClassziInstances_constrZMacNkZN_closure, ive had problems with that one
13:22:29 <aavogt> Baughn: build syb-with-class without documentation
13:22:36 <aavogt> haddock messes things up
13:22:45 <benmachine> I thought there was a fix for that
13:22:53 <benmachine> a partial one at least
13:23:03 <Baughn> aavogt: Seriously? That's.. aagh.
13:23:06 <aavogt> syb-with-class contributes by exporting symbols generated by TH
13:23:23 <Baughn> So that's how.
13:23:24 <aavogt> and those are more or less random every time
13:23:44 <Baughn> Right. Thanks. Let the insanity continue.
13:23:52 <aavogt> so haddock runs ghc over the source files, causing inconsistency between the .o and .his
13:23:56 <aavogt> or something like that
13:24:03 <bluetaslem> Can I get debug help?
13:24:29 <bluetaslem> Please?
13:25:07 <bluetaslem> Anyone?  D:
13:25:18 <Baughn> bluetaslem: You have yet to ask a question, therefore no.
13:25:31 <Baughn> @quote ask
13:25:31 <lambdabot> Lemmih says: inv2004: Haskell isn't like all the other mainstream languages. You really need to read a tutorial.
13:25:34 <bluetaslem> Hm?
13:25:44 <Baughn> ..that was not what I was going for. THough it works.
13:25:54 <Baughn> bluetaslem: Well, what's the issue?
13:26:00 <aavogt> depends what the problem is anyways
13:26:03 <bluetaslem> I am reading a tutorial, trying out a simple program by myself.
13:26:14 <bluetaslem> Evidently, its not working at all.
13:26:20 <Baughn> @quote zygohistomorphic
13:26:20 <lambdabot> roconnor says: sounds like you need a zygohistomorphic prepromorphism
13:26:33 <aavogt> @quote layout
13:26:33 <bluetaslem> isprime 1 _ = True
13:26:33 <bluetaslem> isprime x y = if mod y x == 0 then False  else isprime x y-1
13:26:33 <lambdabot> skorpan says: i love the layout of lyah. makes me feel like having some chunky bacon.
13:26:45 <Baughn> bluetaslem: In what manner is it not working? Are we talking hello, world level?
13:26:56 <aavogt> you're missing parentheses around (y-1)
13:26:57 <bluetaslem> Its for a test if a number is prime.
13:27:02 <bluetaslem> Is that really it/?
13:27:20 <bluetaslem> Wow, thanks.
13:27:39 <aavogt> it would be nice if whitespace affected operator precedence
13:27:39 <bluetaslem> Okay, new error..
13:27:45 <xerox> you mean coprime
13:27:46 <Baughn> aavogt: No. No, it wouldn't.
13:27:57 <aavogt> where you could write     x+y * y+z
13:27:58 <xerox> no you mean prime, ok, but you can do better
13:28:04 <sungji> hm is it possible to do something like this in haskell [a,b | (a,b) <- list] ?
13:28:06 <aavogt> to mean  (x+y) * (y+z)
13:28:08 <bluetaslem> I'm a beginner.
13:28:25 <aavogt> sungji: what's that supposed to do?
13:28:30 <xerox> sungji: what you mean by a,b just (a,b) ?
13:28:49 <aavogt> have type:   [(a,a)] -> [a]?
13:28:56 <sungji> aavogt, xerox: basically unzip and merging two lists
13:29:15 <xerox> ?type uncurry (++) . unzip
13:29:16 <lambdabot> forall b. [(b, b)] -> [b]
13:29:19 <aavogt> you can write    concat [[a,b] | (a,b) <- list]
13:29:20 <arcatan> concat [[a,b] | (a,b) <- list]
13:29:23 <Baughn> aavogt: 1 * 2+3  - 4 to mean (1 * (2+3))-4?
13:29:32 <sungji> xerox,aavogt: awesome
13:29:34 <sungji> thanks!!!
13:29:50 <xerox> sungji: it might not be exactly what you needed
13:29:53 * hackagebot HDBC 2.2.4 - Haskell Database Connectivity  http://hackage.haskell.org/package/HDBC-2.2.4 (JohnGoerzen)
13:30:08 <aavogt> Baughn: no, counting multiple spaces would be craziness
13:30:23 <aavogt> that would be   1*(2+3)-4
13:30:31 <Baughn> aavogt: Pot, kettle. ^^;
13:30:34 <ski> > [ab | (a,b) <- [(0,1),(2,3),(4,5),(6,7)], ab <- [a,b]]
13:30:35 <lambdabot>   [0,1,2,3,4,5,6,7]
13:30:38 <aavogt> with the regular precedence of * and - coming into play
13:30:41 <ski> sungji : ^
13:31:18 <ski> > [(0,1),(2,3),(4,5),(6,7)] >>= \(a,b) -> [a,b]  -- also
13:31:20 <lambdabot>   [0,1,2,3,4,5,6,7]
13:31:24 <Baughn> aavogt: Hmm. f 2+3 would be (f 2) + 3, but f  2+3 would be f (2+3)?
13:31:49 <Baughn> aavogt: Or should we drop one precedence level per space? That could allow some excellent code.
13:32:18 <aavogt> function application doesn't have a precedence number yet
13:32:49 <aavogt> > let (+) = Prelude.(+); infix 10 + in 1 + 2
13:32:50 <lambdabot>   <no location info>: Precedence out of range
13:32:51 <sungji> ski, thank you
13:33:10 <Baughn> aavogt: I always just figured it had precedence 10
13:33:35 <aavogt> record update precedence goes to 11
13:33:39 <ski> Baughn : that's crazy talk !
13:33:49 <ski> (re precedence by number of spaces)
13:34:01 <xerox> ski: awesome
13:34:10 <ski> xerox ?
13:34:15 <Baughn> ski: You're right, it would be inconvenient. We should use tabs; make one tab = 3 spaces.
13:34:20 <xerox> >>= \(a,b)->[a,b] :)
13:34:25 <benmachine> @pl \(a,b)->[a,b]
13:34:25 <lambdabot> uncurry ((. return) . (:))
13:34:29 <ski> (: ok
13:34:42 <xerox> I was looking for the point-free version of... what \bot just spit
13:35:08 <Baughn> ..are you sure that's what you want?
13:35:24 <xerox> just for fun
13:35:29 <bluetaslem> Thanks guys!
13:35:33 <bluetaslem> I got it working, yays!
13:35:39 <bluetaslem> My first Haskell program, all on my own.
13:35:49 <ski> Baughn : e.g. what if i want to align `a + f   xs' on one line with `b + f (y:ys)' on another line ?
13:36:02 <benmachine> alignment is for chumps
13:36:15 <aavogt> code needs more dimensions?
13:36:21 <Baughn> ski: Use unicode zero-width spaces to align it.
13:36:21 <benmachine> one thing I like about haskell is how it looks ok even in not fixed-width
13:36:34 <benmachine> aavogt: what like, a three-dimensional array of characters?
13:36:47 <Baughn> Four-dimensional!
13:36:55 * benmachine head asplode
13:37:03 <bluetaslem> 11 dimensional is the maximum according to stirng theory.
13:37:04 * ski thinks most code looks crappish in non-fixed-width
13:37:04 <xerox> and you program by looking at projections into three-space
13:37:07 <Baughn> You can map the fourth to time
13:37:27 <benmachine> bluetaslem: maths has infinite-dimensional spaces
13:37:30 <Baughn> So your editor shows 3D code that varies with time, and you just synchronize your typing to the variation
13:37:36 <benmachine> maths 1 real world 0
13:37:39 <ski> (exceptions might be using a structural editor that does aligning for you .. like to some extent Alfa)
13:38:11 <Baughn> (Of course, the fourth would be cyclical)
13:38:21 <benmachine> of course!
13:50:28 <c_wraith> So, a question from the future:  What web framework has won the battle, in terms of stability and flexibility?
13:51:38 <c_wraith> I really want to implement a very tiny web service in haskell using a good web framework.  What's out there that's in the big battle that will probably be starting soon?
13:51:41 <burp> salvia seems interesting
13:51:49 <fax> what the fuck
13:52:07 <burp> though the most popular is probably happstack
13:52:14 <monochrom> happstack seems to be pretty popular
13:52:17 <c_wraith> I'm not a fan of happstack, having used it
13:52:27 <monochrom> I have not measured stability or flexibility.
13:52:27 <fax> it's taken me this long to realize you are not talking about drugs
13:52:31 <burp> then you could have a look at salvia
13:52:45 <burp> seems a clean thing to me
13:52:51 <monochrom> haskell is not a drug?! :)
13:52:53 <c_wraith> checking it out now.  Thanks for the pointer
13:53:03 <c_wraith> haskell is certainly a mind-expanding drug :)
13:53:03 <EvanR-work> see how deep this rabbit hole goes
13:53:04 <burp> but I had no time to look into it further myself
13:55:21 <odyssomay> I'm trying to compile ghc, but during configure i get: checking for path to top of build tree... /usr/lib/gcc/x86_64-pc-linux-gnu/4.3.4/../../../../x86_64-pc-linux-gnu/bin/ld: pwd.o: relocation R_X86_64_32S against `base_GHCziBase_ZC_con_info' can not be used when making a shared object; recompile with -fPIC
13:55:24 <odyssomay> what to do?
13:55:36 <dons> strong recommend to read the new parallel arrays paper, http://www.reddit.com/r/programming/comments/bnalc/new_repa_automagic_parallel_arrays_for_haskell/
13:56:02 * hackagebot hoopl 3.7.0.0 - A library to support dataflow analysis and optimization  http://hackage.haskell.org/package/hoopl-3.7.0.0 (NormanRamsey)
13:56:46 <dons> woo!
13:56:56 <dons> all the post-icfp uploads
13:58:58 <jlouis> dons: quick skim says awesome paper
13:59:54 <Ke> how come there is still something interesting in data parallel arrays?
14:00:26 <siorai> ke: ?
14:00:31 <siorai> Why not? =p
14:00:32 <Ke> that's like 1800s
14:00:59 <siorai> Ke: saw a talk recently on vectorisation of data parallel arrays that was really interesting
14:01:24 <siorai> Ke: Fundamental concepts in CS tend to cycle quite a bit
14:01:38 <bluetaslem> Um, who wrote lambdabot?
14:01:38 <siorai> e.g. concurrency =p
14:01:45 <benmachine> various
14:01:46 <siorai> bluetaslem: Who hasn't?
14:02:00 <Twey> I don't think there's any of my code in there… :þ
14:02:07 <siorai> Last I knew, though, dons was taking care of it
14:02:16 <siorai> but that knowledge is ages ago
14:02:22 <c_wraith> bluetaslem: a lot of people have contributed.  Cale runs the one in here, but he claims he's not actually the maintainer, whatever hackage says.
14:02:23 <benmachine> http://code.haskell.org/lambdabot/AUTHORS
14:02:28 <Twey> I think Cale maintains her now, though I don't know about code
14:02:35 <Twey> Oh
14:02:39 <sizzler> in http://web.archive.org/web/20080502201644/www.cs.vu.nl/boilerplate/testsuite/paradise/Main.hs how is the increase function allowing no binding for Company given in its type signature
14:02:50 <benmachine> ohhh ddarius = derek elkins
14:02:54 <benmachine> magic :o
14:02:58 <siorai> lol really?
14:03:00 <siorai> i didn't know that
14:03:02 <siorai> amazing
14:03:10 <benmachine> apparently
14:03:11 <Twey> @nazi-on
14:03:11 <lambdabot> Not enough privileges
14:03:17 <Twey> What is this for?
14:03:39 <benmachine> heheh
14:03:46 <burp> lol
14:04:12 <benmachine> @redo x >>= f
14:04:12 <lambdabot> Maybe you meant: do read todo undo
14:04:18 <benmachine> @do x >>= f
14:04:18 <lambdabot> do { a <- x; f a}
14:04:21 <benmachine> oic
14:04:31 <benmachine> @help read
14:04:31 <lambdabot> read "<foo>". Print <foo>
14:04:38 <benmachine> @read "2"
14:04:38 <lambdabot>  2
14:04:40 <benmachine> odd
14:04:45 <benmachine> @help todo
14:04:46 <lambdabot> todo. List todo entries
14:04:48 <benmachine> @todo
14:04:48 <lambdabot> 0. SamB: A way to get multiple results from a google search
14:04:48 <lambdabot> 1. dons: improve formatting of @dict
14:04:48 <lambdabot> 2. dons: write Haskell Manifesto
14:04:48 <lambdabot> 3. lispy: don't let lambdabot's prettyprinter split the sequence @foo across lines
14:04:48 <lambdabot> 4. TheHunter: priviledged users should get priviledged listcommands.
14:04:50 <lambdabot> [29 @more lines]
14:04:53 <ski> @. read run "foo" ++ "bar"
14:04:54 <lambdabot>  foobar
14:04:55 <benmachine> o_o
14:05:05 * ddarius didn't realize his true identity was a secret.
14:05:15 <lispy> whoa
14:05:20 <benmachine> ddarius: it wasn't I just never made the connection :P
14:05:21 <lispy> That's a really old todo item
14:05:24 <bluetaslem> GUys?
14:05:29 <ddarius> dons: Is there a hackage package?  (I've been reading the paper today.)
14:05:32 <ski> lispy : indeed ..
14:05:53 <bluetaslem> I had an idea, but i might just be weird..
14:06:02 <bluetaslem> Couldn't bots with shared memory, you know..
14:06:12 <bluetaslem> Automatically send data to all of the channels?
14:06:13 <ski> (i assume TheHunter still hasn't been sighted ..)
14:06:29 <bluetaslem> So that every channel can talk to the others simultaneously?
14:06:41 <benmachine> bluetaslem: kind of defeats the point of channels
14:06:51 <benmachine> also, flood limiting
14:06:58 <benmachine> freenode will kill you
14:07:00 <bluetaslem> Um, whats it called...
14:07:06 <bluetaslem> Activation characters or something?
14:07:12 <arcatan> if the channels are in different networks, that could be useful
14:07:21 <arcatan> bridging two networks together
14:07:37 <EvanR-work> they have something like that in... #winapi ?
14:07:40 <benmachine> would be interesting if one was a bitlbee network
14:07:47 <benmachine> ooh I shoudl run a lambdabot on MSN
14:07:49 <benmachine> that would be fun
14:08:34 <bluetaslem> Like, this channel could speak with Lua, or any other programming channels..
14:08:44 <bluetaslem> like, "++ChannelName++Texthere"
14:08:53 <bluetaslem> And the bots would repeat it on the other channel
14:08:59 <benmachine> doesn't really provide any advantage over
14:09:03 <benmachine> just joining that channel
14:09:06 <benmachine> and saying it
14:09:11 <bluetaslem> It does.
14:09:24 <EvanR-work> why would you want to talk about haskell is both haskell, lua, php, c, etc
14:09:25 <bluetaslem> You could ask them questions, and not get flooded by their speech, jsut recieve an answer.
14:09:47 <EvanR-work> talking to a specific person, use privmsg
14:10:50 <bluetaslem> My point is that Bots can be helpful in more ways than they are yet used.
14:10:59 <bluetaslem> What about a google search bot, or something like that?
14:11:06 <benmachine> @google google search bots
14:11:07 <Philonous> @google lambdabot
14:11:07 <lambdabot> http://www.google.com/support/webmasters/bin/answer.py?hl=en&answer=35769
14:11:07 <lambdabot> Title: Webmaster guidelines - Webmaster Tools Help
14:11:08 <bluetaslem> Linking bos could also be used to contact other bots.
14:11:08 <lambdabot> http://www.haskell.org/haskellwiki/Lambdabot
14:11:08 <lambdabot> Title: Lambdabot - HaskellWiki
14:11:13 <burp> let's not overdo it :>
14:11:35 <benmachine> why would you want to contact other bots
14:11:45 <benmachine> in any way other than directly
14:11:57 <arw_> you can already send messages to different channels. most have it disabled because its mostly a source of spam...
14:12:29 <bluetaslem> Well for one, it keeps the flow in one page.
14:12:37 <bluetaslem> You don't have to flip between windows or tabs.
14:12:46 <benmachine> separation is useful
14:12:49 <benmachine> that's why we have channels
14:12:58 <arw_> you also don't have to flip if you use an appropriate irc client.
14:13:06 <benmachine> not every client puts every channel in a different window/tab
14:13:16 <benmachine> nearly every client does because that's what nearly every user wants
14:13:32 <EvanR-work> bluetaslem: make your own client!
14:13:44 <benmachine> I actually started that
14:13:50 <benmachine> but got bored and did something else instead
14:13:52 <EvanR-work> it will be like a custom user interface involving 3d graphics and gloves instead of a keyboard
14:14:16 <Philonous> EvanR-work: Sounds like hollywood will be your only customer
14:14:24 <arw_> bitchx displays all channels in one window by default iirc.
14:14:40 <arw_> and every nick is just prefixed by the channel name.
14:14:55 <arw_> you just have to switch which channel you want to talk to.
14:15:26 <arw_> but with more than 5 channels, it gets annoying because you can't really follow any discussions that way.
14:17:08 <jmcarthur> i've thought about making a client that behaves that way and provides nice ways of filtering discussions
14:17:39 <benmachine> I wanted to make one which dynamically merged consecutive joins/parts
14:17:53 <benmachine> into a single message
14:18:00 <EvanR-work> perhaps pressing alt N will switch between which chan messages are shown at the moment
14:18:08 <benmachine> yeah something like that
14:18:12 <jmcarthur> even adaptively, like if you are conversing with somebody and that somebody also is conversing with somebody else you can see the somebody else as well automatically, but that stops after some depth or something
14:18:14 <PeakerWork> benmachine: that doesn't warrant a whole new client
14:18:29 <jmcarthur> i should have named all those "somebody"s
14:18:35 <benmachine> /ignores should be retroactive and reversible
14:18:51 <PeakerWork> benmachine: they are reversible.. Not sure retroactivity is that important
14:18:59 <PeakerWork> oh, not scrollback reversible, yeah
14:19:05 <benmachine> mm that's what I meant
14:19:07 <PeakerWork> sort of a "capture filter" rather than "display filter"
14:19:13 <benmachine> hm?
14:19:23 <benmachine> er
14:19:26 <benmachine> maybe
14:19:30 <PeakerWork> The /ignore switch is a capture filter, rather than a display filter, in wireshark/sniffer terminology
14:19:35 <benmachine> oh
14:19:37 <benmachine> yes
14:19:41 <benmachine> and it should be a display filter
14:19:44 <PeakerWork> yeah
14:19:48 <jmcarthur> agreed
14:19:48 <benmachine> that would be cool
14:20:10 <jmcarthur> i just want adaptive filters that tune to the conversations you are holding
14:20:22 <PeakerWork> It would be nice if capture/display filters in wireshark had the same language!
14:20:27 <PeakerWork> in tcpdump, I guess
14:20:34 <PeakerWork> tcpdump/wireshark are rotten
14:20:38 <ddarius> dons: I like footnote 4.
14:21:12 <jmcarthur> or maybe even instead of filters just have a way to dim the messages that the client thinks you are less interested in
14:21:55 <benmachine> retroactive highlights
14:21:59 <jmcarthur> heh
14:22:05 <jmcarthur> something like that
14:22:23 <benmachine> man
14:22:31 <benmachine> IRC clients would be so awesome if we wrote them
14:22:53 <jmcarthur> i've thought about starting one
14:23:01 <jmcarthur> but i always have something that i deem more important
14:23:05 <benmachine> heh
14:23:06 <benmachine> yeah
14:23:06 <ddarius> There is (was) definitely one IRC client written in Haskell by someone on #haskell.  I'd be surprised if there wasn't one or two more.
14:23:15 <benmachine> yeah I've heard of one
14:23:36 <etpace> iirc, wasnt there a development enviroment released for haskell on windows, that included a bunch of extra libraries and profilers, etc?
14:23:45 <benmachine> http://www.mirrorservice.org/sites/www.haskell.org/hircules/
14:24:13 <benmachine> seven years old, nice
14:24:23 <benmachine> well, six and a half
14:27:09 <benmachine> hircules is hosted in cvs :(((
14:27:40 <ddarius> benmachine: That was before the DVCS revolution.
14:27:48 <benmachine> yeah
14:28:09 <Twey> There was an update yesterday
14:28:19 <benmachine> Twey: wat
14:29:34 <Twey> Someone updated some IRC client yesterday
14:29:37 <Twey> hackagebot announced it
14:29:40 <benmachine> oh
14:29:40 <PeakerWork> The way lazy vs. strict bytestrings are handled is not very pretty/elegant.. More type-classes!
14:29:40 <Twey> I forget the name
14:29:53 <jmcarthur> hirculese was last updated around 17 months ago
14:30:01 <jmcarthur> *hircules
14:30:09 <jmcarthur> at the the repo was
14:30:11 <benmachine> Twey: http://hackage.haskell.org/packages/archive/recent.html any of these?
14:30:12 <jmcarthur> *at least
14:30:52 <jmcarthur> hircules is on hackage, heh
14:30:54 <jmcarthur> http://hackage.haskell.org/package/hircules
14:31:32 <jmcarthur> and it has a link to a darcs repo, but nothing's there :(
14:31:44 <benmachine> interesting
14:32:09 <Twey> Hm, maybe I was thinking of Combinatorrent.  :-\
14:36:53 <benmachine> can template haskell access compiler options?
14:37:08 <benmachine> I'm thinking like, could it implement conditional compilation
14:37:19 <benmachine> it would be nice if it could replace cpp(hs)
14:40:48 <ivanm> benmachine: I've never used TH, so wouldn't know; but seeing as how no-one has done it before I suspect not :s
14:41:18 <benmachine> ivanm: it'd be a neat idea, right?
14:41:32 <srush> any tricks for debugging <<loop>>
14:41:52 <ivanm> I dunno; I've had issues with programs that use TH (usually due to linking problems with C libs)
14:42:02 <ivanm> srush: test smaller parts of your program?
14:42:51 <ddarius> srush: If you are not trying to do crazy knot tying stuff, look for code like: let x = f y x in ...
14:43:35 <ddarius> Turn on warnings about shadowing variables.
14:43:46 <srush> I was hoping I could break into the stack
14:44:07 <benmachine> haskell doesn't have a stack like you'd expect
14:44:14 <benmachine> otherwise it'd overflow all the time
14:45:20 <grok> is there an easy way to take only the even elements in a list?
14:45:56 <srush> so what does :trace do in ghci
14:46:10 <benmachine> grok: the elements that are even, or the elements at even indices?
14:46:18 <grok> i'm trying to remove the elements in a list that are in the odd position.
14:46:22 <grok> even indice
14:46:23 <ivanm> that's the ghci debugger; I've never managed to work out how to use it (mainly because I've never tried)
14:46:39 <kmc> :t concat . zipWith ($) (cycle [return, mzero]) $ [1..10]
14:46:40 <lambdabot> forall b. (MonadPlus ((->) b), Num b, Enum b) => [b]
14:46:58 <grok> i.e. [1,5,3,61,134,12342,23] becomes [1,3,134,23]
14:47:16 <ivanm> kmc: hmmm.... isn't there a variant of that that doesn't need the concat?
14:47:16 <kmc> > concat . zipWith ($) (cycle [return, const mzero]) $ [1..10]
14:47:17 <lambdabot>   [1,3,5,7,9]
14:47:30 <Cale> > [x | (k,x) <- zip [0..] [1,5,3,61,134,12342,23], even k]
14:47:31 <lambdabot>   [1,3,134,23]
14:47:34 <ivanm> using something like [id, f] (where I have no idea what f is) ?
14:47:45 <kmc> seems impossible ivanm
14:47:49 <ddarius> catMaybes
14:47:50 <kmc> you can't not return an element
14:47:57 <kmc> > catMaybes . zipWith ($) (cycle [return, const mzero]) $ [1..10]
14:47:58 <lambdabot>   [1,3,5,7,9]
14:48:27 <Cale> > map snd . filter fst . zipWith (cycle [True, False]) $ [1,5,3,61,134,12342,23]
14:48:28 <lambdabot>   Couldn't match expected type `a -> b -> c'
14:48:28 <lambdabot>         against inferred type `[...
14:48:36 <Cale> > map snd . filter fst . zip (cycle [True, False]) $ [1,5,3,61,134,12342,23]
14:48:37 <lambdabot>   [1,3,134,23]
14:48:57 <benmachine> > (\xs -> foldr (\x (a, b) -> let b' = not b in if b then (x:a, b') else (a, b')) ([], False) xs) [1,5,3,61,134,12342,23]
14:48:58 <lambdabot>   ([5,61,12342],True)
14:49:14 <benmachine> > (\xs -> foldr (\x (a, b) -> let b' = not b in if b then (x:a, b') else (a, b')) ([], True) xs) [1,5,3,61,134,12342,23]
14:49:14 <lambdabot>   ([1,3,134,23],False)
14:49:45 <Cale> > let evens [] = []; evens (x:xs) = x : odds xs; odds [] = []; odds (x:xs) = evens xs in evens [1,5,3,61,134,12342,23]
14:49:46 <lambdabot>   [1,3,134,23]
14:50:16 <kmc> > catMaybes . takeWhile isJust . map listToMaybe . iterate (drop 2) $ [1..10]
14:50:17 <lambdabot>   [1,3,5,7,9]
14:51:03 <Cale> > map head . takeWhile (not . null) . iterate (drop 2) $ [1,5,3,61,134,12342,23]
14:51:04 <lambdabot>   [1,3,134,23]
14:52:34 <Cale> Lots of good ways to do it :)
14:52:59 <grok> thanks, still learning the language
14:53:16 <Cale> > map snd . filter (even . fst) . zip [0..] $ [1,5,3,61,134,12342,23]
14:53:17 <lambdabot>   [1,3,134,23]
14:53:57 <Cale> zip [0..] is a really handy function for pairing elements in a list with their indices
14:54:10 <Cale> and then map/filter/etc. can act on those indices as well as the elements of the list
14:54:58 <kmc> grok, we all are :) just at different stages
14:55:25 <Cale> I like it because it casually shows how infinite lists are very useful.
14:56:13 <grok> what does the $ command do?
14:56:24 <kmc> it's just an infix operator
14:56:25 <Cale> $ is function application, but with really low precedence
14:56:28 <kmc> @type ($)
14:56:29 <lambdabot> forall a b. (a -> b) -> a -> b
14:56:30 <benmachine> f $ x = f x
14:56:30 <Cale> f $ x = f x
14:56:31 <kmc> @src ($)
14:56:31 <lambdabot> f $ x = f x
14:56:33 <Cale> heh
14:56:34 <kmc> haha
14:56:46 <kmc> grok, here it's used to avoid parens
14:56:56 <kmc> i.e.  f . g . h $ x   is equivalent to   f (g (h x))
14:56:57 <Cale> So, when I write something like f . g . h $ x, it means the same as (f . g . h) x
14:57:02 <benmachine> a b c $ d e f = (a b c) (d e f)
14:57:06 <Cale> which is the same as f (g (h x))
14:57:15 <kmc> grok, but it's a real infix operator, and has other uses
14:57:21 <kmc> > map ($ 3) [succ, pred]
14:57:23 <lambdabot>   [4,2]
14:57:43 <Cale> > zipWith ($) [(+2), (*2), (^2)] [5,6,7]
14:57:44 <lambdabot>   [7,12,49]
14:58:17 <Cale> (.) is function composition, it glues functions together end-to-end
14:58:33 <Cale> So (f . g) x = f (g x) -- and this is actually the definition from the Prelude :)
14:59:04 <Cale> A common idiom is to chain a bunch of functions together using (.), and then apply it to a parameter using ($)
14:59:53 <stevenmarky> I want to do some in memory image stuff like resizing images and converting from bmp to jpg, which package will let me do this?
15:00:22 <kynky> cairo ?
15:00:35 <kynky> gdk
15:00:49 <kynky> in gtk2hs
15:01:06 <ivanm> stevenmarky: there's hsmagick
15:01:29 <ivanm> and gd
15:03:19 <stevenmarky> I'll check those out, thanks
15:03:36 <ivanm> check out the rest of the graphics section
15:04:08 <Cale> (on here: http://hackage.haskell.org/packages/archive/pkg-list.html)
15:04:20 <odyssomay> I seem to get a lot of 'can not be used when making a shared object; recompile with -fPIC' errors, what's the reason for this?
15:04:23 <odyssomay> oops
15:04:27 <odyssomay> wrong channel, nvm
15:05:56 <Cale> -fPIC turns on position independent code, which if I recall correctly is required to be able to make the code work properly inside another process' memory space
15:06:22 <PeakerWork> Why does Haskell refuse the last comma in comma-separated things? In tuples I guess it looks like a section, but in records and list sugar, it should really have been allowed
15:06:26 <Cale> (but I am hazy on such low-level details of how shared objects work)
15:06:41 <kmc> PeakerWork, in tuples it *is* a section, with the right GHC 6.12 extension
15:06:45 <xerox> :t (,)
15:06:46 <lambdabot> forall a b. a -> b -> (a, b)
15:06:48 <kmc> i agree about the other cases
15:06:50 <Cale> :t (5,)
15:06:50 <PeakerWork> kmc: well, for ever
15:06:51 <lambdabot> parse error on input `)'
15:06:57 <PeakerWork> kmc: for everything else it makes less sense
15:07:07 <olsner> xerox: hmm, I think that's just a type constructor in function-form, not a section
15:07:11 <benmachine> I just think [4,5,] is ugly
15:07:12 <Cale> PeakerWork: It looks just... wrong to me.
15:07:13 <PeakerWork> Cale: -fPIC allows the code to be mapped to any address
15:07:14 <kmc> yeah
15:07:22 <kmc> it'd be nice in records
15:07:28 <PeakerWork> benmachine: It's ugly to have an exceptional entry in a list
15:07:31 <olsner> hmm, but with optional-extra-comma, (,) should also be alternate syntax for () :P
15:07:38 <kmc> >do { return 3; } :: Maybe Int
15:07:41 <kmc> > do { return 3; } :: Maybe Int
15:07:42 <lambdabot>   Just 3
15:07:42 <Cale> PeakerWork: Maybe the programmer forgot an entry that they meant to type? It seems like it's a good idea to catch that to me.
15:07:44 <kmc> > do { return 3;;; } :: Maybe Int
15:07:45 <lambdabot>   Just 3
15:08:05 <Cale> It's a bit of a fluke that you can have empty statements inside a do-block
15:08:20 <kmc> > do { ;;;return 3;;; } :: Maybe Int
15:08:20 <lambdabot>   Just 3
15:08:26 <kmc> what's the fluke?
15:08:31 <PeakerWork> Cale: I think it's much much more common to just want to have a bunch of items in a list or record, each in their own line, and being able to cut&paste them around without any one of them requiring special care when moving around
15:09:10 <Cale> Well, I suppose the fluke is that ; can appear like a statement terminator rather than a separator because of empty statements.
15:09:14 <PeakerWork> when I cut&paste the last list line I have to manually add/remove the comma. When the comma is used prefix-style, the first line is special
15:09:17 <Cale> I didn't mean that nobody considered it.
15:09:44 <PeakerWork> I remember it was a breath of fresh air back when I could use trailing commas in Python
15:10:07 <benmachine> someone had a layout proposal
15:10:15 <benmachine> that was sort of related to this
15:10:44 <olsner> e.g. using layout for list item separation instead of commas?
15:10:52 <Cale> weird
15:11:36 <olsner> it would somehow make sense if the syntax was [a;b;c], with those semicolons handled in the usual layouty way
15:12:13 <shrughes> layout with a right bracket at the end would be weird
15:12:35 <olsner> [a;b;c; then? :P
15:12:51 <aavogt> PeakerWork: they are allowed in export lists
15:12:54 <PeakerWork> it would be nice to use layout for list members, yes..
15:13:00 <PeakerWork> aavogt: cool, didn't know that
15:13:07 <PeakerWork> aavogt: inconsistent and weird, though
15:13:16 <aavogt> I think import lists too
15:13:53 <Reisen> What's the GC like in haskell? I know it's a bland question but, I'm curious for details. Does it slow it down a lot? Does it clean often? That kindof thing
15:14:16 <Cale> Reisen: In GHC?
15:14:20 <olsner> shrughes: I don't really find it that weird, I could definitely get used to it
15:14:35 <Reisen> Yeah sorry, I don't know what drugs I was on to say 'haskell', GHC indeed
15:15:06 <Cale> It's a generational mixed copy + mark/sweep collector
15:15:24 <Cale> It handles lots of short-lived things very efficiently
15:16:14 <PeakerWork> I didn't know it also used mark/sweep
15:16:26 <PeakerWork> I thought it was just generational copy-discarding-unref'd?
15:16:50 <Cale> It uses mark/sweep to compact the heap
15:16:58 <Cale> Only when the heap is very close to being full
15:17:01 <Cale> http://hackage.haskell.org/trac/ghc/wiki/GarbageCollectorNotes
15:17:15 <Reisen> Ah brilliant, thanks Cale
15:17:20 <Reisen> Checking that link out now
15:17:25 <pikhq> Generational + mark/sweep? Sounds like it's pretty much the sane thing to do when you've got exact pointer information.
15:17:42 <pikhq> Erm. Generational copying.
15:18:43 <Cale> That page seems unfortunately incomplete
15:18:56 <pikhq> It does.
15:21:12 <Cale> Oh, curious, according to: http://hackage.haskell.org/trac/ghc/wiki/GMPMemoryManagement  the garbage collector can't run when GMP operations on Integers are executing. I wonder if one could construct a pathological program to abuse that :)
15:21:17 <PeakerWork> When I define a record -- with -Wall, I may get warnings about unused record field names -- because I don't use them all. Any simple solution to avoid this warning?
15:21:49 <Cale> Don't use -Wall because it complains about stuff that doesn't matter all the time?
15:21:58 <ezyang> PeakerWork: What happens if you explicitly export all of the fields?
15:22:06 <Cale> Hehe, or that ;)
15:22:16 <PeakerWork> ezyang: Then I expose my implementation details :(
15:22:23 <ezyang> but... you're not using it?
15:22:25 <benmachine> or you can use -fno-warningname to disable the warning
15:22:29 <ezyang> then comment out the fields...
15:22:30 <PeakerWork> Cale: I really hate having redundant imports, I don't like hitting non-exhaustive pattern matches (that are meant to be exhaustive) at runtime, etc.
15:22:59 <PeakerWork> ezyang: I am using the fields -- just not by name
15:23:03 <ezyang> ohhh
15:23:03 <Cale> PeakerWork: There are lots of individual warning flags you can turn on -- maybe there's a way to turn them off as well...
15:23:08 <PeakerWork> I guess I could use them by name there
15:23:17 <ezyang> blah. That's kind of lame
15:23:23 <PeakerWork> Cale: Well, I really like knowing about which pieces of code are dead code
15:23:46 <PeakerWork> (So I'd rather not disable the warning about dead code)
15:23:49 <benmachine> try naming the fields in question _
15:23:52 <benmachine> or starting with a _
15:23:56 <Cale> -fno-warn-unused-binds
15:24:23 <benmachine> I think GHC waives unused warnings for bindings that start with underscores
15:24:35 <Cale> istr that was the case as well
15:24:51 <PeakerWork> benmachine: thanks
15:24:57 <Cale> A definition is regarded as "used" if (a) it is exported, or (b) it is mentioned in the right hand side of another definition that is used, or (c) the function it defines begins with an underscore. The last case provides a way to suppress unused-binding warnings selectively.
15:25:10 <PeakerWork> Yeah that works
15:25:38 <PeakerWork> I don't see how people use GHC without -Wall, myself :)
15:25:59 <Cale> I can't stand -Wall
15:26:13 <PeakerWork> If you've gone all the way to Haskell, wouldn't you want to know at compile-time when you're going to get non-exhaustive pattern-matches at runtime?
15:26:34 <PeakerWork> Correctness guarantee over convenience
15:26:37 <Cale> I never write non-exhaustive pattern matches.
15:26:39 <ezyang> Pretty pictures! http://blog.ezyang.com/img/zipper/right-context.png
15:26:55 <grok> even' [] = []
15:26:56 <grok> even' (x:xs) = map snd . filter (even . fst) . zip [0..] $ xs
15:27:11 <Cale> grok: Don't need the base case
15:27:14 <grok> somehow i'm doing something wrong, and just getting the odd indices elements, any help?
15:27:27 <Cale> even' xs = map snd . filter (even . fst) . zip [0..] $ xs
15:27:31 <Cale> or:
15:27:33 <PeakerWork> I wonder if hlint comments on that - it's a pretty common error
15:27:34 <Cale> even' = map snd . filter (even . fst) . zip [0..]
15:27:51 <PeakerWork> he's discarding x there
15:27:54 <Cale> yeah
15:27:59 <PeakerWork> not sure if purposefully
15:28:08 <PeakerWork> if he used -Wall, he'd get a warning about it to make sure :)
15:28:25 <Cale> You're discarding the first element of the list and only applying the function you really wanted to the remainder of the list, which is why you were getting the odd elements
15:28:42 <PeakerWork> Yet another win for -Wall :-)
15:29:13 <Cale> PeakerWork: Just as often, I have intentionally unused names in patterns
15:29:43 <PeakerWork> Cale: Prefix them with underscores then
15:29:54 <PeakerWork> to differentiate meaningful/neglectful discarding
15:29:55 <Cale> I think it looks ugly.
15:30:13 <PeakerWork> Beauty follows function
15:30:25 <benmachine> haskell programs are artworks
15:30:28 <benmachine> functionality is incidental
15:30:34 <PeakerWork> :-)
15:30:44 <benmachine> (*works of art)
15:30:52 <grok> cale you are a godsend.
15:31:05 <benmachine> truth
15:31:13 <Cale> I actually really dislike the underscore character in general for some reason. I'm not sure why.
15:31:40 <ezyang> The underscore represents excess
15:31:43 <Cale> some_people_really_like_to_name_things_like_this but I think it looks awful.
15:31:54 <ezyang> the willy nilly throwing away of information
15:31:55 <xerox> oleg'likes'this'style
15:32:02 <ezyang> Cale: Oh, you're not talking about single underscores
15:32:09 <Philonous> underscoresAreStillBetterThanCamelsInMyCode
15:32:15 <fax> iJustWriteThisWayInHaskellBecauseThat'sWhatTheStandardLibraryDoes
15:32:22 <Cale> The only style of that sort which I find nicer than camelCase is hyphens.
15:32:32 <benmachine> I have a pathological tendency to use single characters
15:32:37 <ezyang> ==benmachine
15:32:48 <PeakerWork> Cale: I think underscore is more readable than camelcase, and I value correctness > readability > beauty
15:32:49 <benmachine> I mean everyone does but I really overdo it >_>
15:33:01 <PeakerWork> (Though in Haskell I use camelCase to blend in)
15:33:01 <benmachine> I think camelcase is more readable than underscore
15:33:05 <Cale> I use single characters for function parameters in any function whose definition is not very long.
15:33:11 <benmachine> as long as it's not java and your names are a billion lines long
15:33:29 <benmachine> mapM > map_M
15:33:32 <benmachine> or map_m
15:33:33 <Becquerel> anotherFunctionToDoSomethingSimilarToTheLastFunctionButABitDifferent
15:33:35 <PeakerWork> benmachine: thenWhyDoWeUseSpacesInSentencesWhichAreMuchMoreSimilarToUnderscoresThanToCamelCase?
15:33:39 <Cale> Yeah, it's easier to type as well
15:33:47 <benmachine> PeakerWork: function names are words, not sentences
15:33:49 <benmachine> imo
15:34:01 <Cale> PeakerWork: It's not a comparison. Spaces are different from underscores.
15:34:07 <PeakerWork> benmachine: well, then camelcase == underscore :)
15:34:10 <benmachine> takeWhile I read as a single thing, not as "take while"
15:34:19 <fax> I think we could use spaces in names for a computer language syntax
15:34:26 <PeakerWork> benmachine: I read it as two words
15:34:30 <Becquerel> unsafe Perform IO
15:34:37 <benmachine> well then we are different!
15:34:45 * hackagebot funion 0.0.2 - A unioning file-system using HFuse  http://hackage.haskell.org/package/funion-0.0.2 (NathanWiegand)
15:34:45 <PeakerWork> fax: If we just use syntax as a presentational tool, and not an encoding you actually edit, then we're free to do that easily
15:34:54 <Philonous> You could just use an invisible character other than space
15:34:55 <fax> I meant literally
15:35:01 <fax> not just as presentation
15:35:11 <fax> that's true about presentationally as well
15:35:14 <Cale> One reason which might convince me to make Haskell a bit more sensitive to whitespace regarding infix operators is that we could allow - in function names.
15:35:33 <fax> Cale it is possible to use hypenated names in agda
15:35:37 <Cale> Though that would be a big change in convention :)
15:35:37 <Philonous> HFuse... good lord
15:35:41 <PeakerWork> Cale: I think foo-bar being different from foo - bar is terrible
15:36:07 <benmachine> Cale: we could just special-case emdash as an identifier character :P
15:36:21 <benmachine> PeakerWork: I think it's something we could get used to
15:36:21 <PeakerWork> But we really just need to make syntax a rendering preference -- so you can switch between the different syntaxes with a press of a hotkey
15:36:23 <jmcarthur> i thought whitespace sensitive operators sounded horrible until i used agda
15:36:26 <Cale> That's silly. Too irritating to type.
15:36:50 <benmachine> 'sjust alt-minus for me
15:36:57 <Philonous> PeakerWork: You mean like glasses mode in emacs?
15:36:59 <PeakerWork> The keyboard keys should be bound to meaningful changes of the abstract syntax, rather than character insertions/deletions
15:37:01 <benmachine> but then that is because I do weird things to my keyboard layout
15:37:03 <PeakerWork> Philonous: not sure what that is
15:37:20 <benmachine> PeakerWork: haskell files should be kept in AST representation and then indented/formatter upon editing!
15:37:20 <Cale> Well, I can type — but it's 4 keystrokes for me.
15:37:31 <Cale> — is compose - - -
15:37:35 <Philonous> PeakerWork: It transparently converts camel case to underscores, bold face characters or whatever you prefer
15:37:57 <PeakerWork> benmachine: I think AST is just an encoding of the ASG -- they should be stored and edited as an ASG -- only one of the presentation options to screen should be a syntactic view (You might want a graph view or others as alternates)
15:38:05 <PeakerWork> Philonous: ah, heh, something like that
15:38:22 <PeakerWork> benmachine: AST + namespaces/names  encodes the ASG
15:38:27 <benmachine> PeakerWork: hm, I guess so
15:38:41 <jmcarthur> i'm all for a nice graph to manipulate directly with various presentation modes... but who's going to write it for me? ;)
15:38:46 <PeakerWork> by editing the ASG we could also get rid of namespaces and make names documentation
15:39:03 <PeakerWork> jmcarthur: It's my pet project that I intend to work on full time in a while :)
15:39:10 <jmcarthur> PeakerWork: sweet!
15:39:24 <jmcarthur> it would also be nice to integrate that into version control somehow :)
15:39:54 <jabes> Hello!  Does anyone know how to show a full float instead of with the exponent?  e.g. show 0.01 should be "0.01", not "1.0e-2" ?
15:40:13 <Cale> camelCase has the nice property of just using shift to separate the words, which essentially counts as half a keystroke (you only have to press shift down before hitting the next key)
15:40:34 <benmachine> @hoogle Double -> String
15:40:35 <lambdabot> Prelude show :: Show a => a -> String
15:40:35 <lambdabot> Text.Show show :: Show a => a -> String
15:40:35 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
15:40:39 <benmachine> hmm
15:40:43 <Cale> > showFFloat 0.01 ""
15:40:44 <lambdabot>   No instance for (GHC.Real.Fractional
15:40:44 <lambdabot>                     (Data.Maybe.Maybe ...
15:40:46 <Cale> er
15:40:58 <Cale> :t showFFloat
15:40:59 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
15:41:01 <Cale> oh, right
15:41:11 <Cale> > showFFloat (Just 4) 0.01 ""
15:41:12 <lambdabot>   "0.0100"
15:41:13 <benmachine> jabes: the Numeric module has showEFloat and showFFloat and showGFloat
15:41:15 <Cale> > showFFloat (Just 2) 0.01 ""
15:41:16 <lambdabot>   "0.01"
15:41:17 <alex404> How do you check function precedence in ghci?
15:41:20 <Cale> > showFFloat Nothing 0.01 ""
15:41:21 <lambdabot>   "0.01"
15:41:22 <benmachine> they all do different things and one of them is interesting
15:41:28 <benmachine> alex404: operator precedence? try :i +
15:41:50 <jabes> benmachine: Thanks!
15:42:09 <alex404> benmachine: Thanks!
15:42:13 <benmachine> :D
15:42:21 <benmachine> double kill
15:42:26 <benmachine> jabes: cale is actually being more useful than me though :P
15:42:29 <Becquerel> rampage
15:43:51 <jabes> Oh, sorry cale.  I just saw benmachine's name in red, referring to me.  Thanks as well!
15:45:52 <jlouis> I wonder what i means that MAIN MAIN takes all the time in the profiling output when -auto-all is enabled
15:46:45 <benmachine> in the cumulative thing or the individual thing?
15:47:13 <jlouis> benmachine: individually
15:47:30 <jlouis> it inherits to 100% as I would expect
15:48:09 <jlouis> also, it reports a number of ticks elapsed which is the wall-clock time of the running program, while it spent considerably fewer seconds actually doing either MUT or GC
15:48:34 <jlouis> That baffles me
15:50:07 <Saizan> maybe time to post to the ghc mailing list? hoping the simons can help?:)
15:50:51 <jlouis> Saizan: that is the next move
15:51:08 <jlouis> Because I am quite perplexed over these reports
15:51:34 <jlouis> this is with -threaded btw
15:59:08 <sfultong> can someone point me to when one should use foldl rather than foldl' ?
15:59:25 <Eridius> probably never :p
15:59:28 <zygoloid> @src reverse
15:59:28 <lambdabot> reverse = foldl (flip (:)) []
15:59:57 <sfultong> yes, but afaik, reverse would not be broken by using foldl' instead
16:00:39 <zygoloid> it would build the entirety of the list if you just wanted the head
16:01:07 <zygoloid> for reverse that's not necessarily bad, but if the combining function is expensive it could be
16:01:44 <hape> @src id
16:01:44 <lambdabot> id x = x
16:01:59 <benmachine> sfultong: reverse with foldl' forces the elements of the list I think
16:02:10 <Saizan> benmachine: no.
16:02:16 <zygoloid> benmachine: it shouldn't; the accumulator is a list so it just forces the cons cells
16:02:19 <Saizan> it only forces the (:) constructor
16:02:22 <benmachine> hm
16:02:25 <Saizan> which is there anyhow
16:02:29 <benmachine> I'm sure I remember there being a difference though
16:02:39 <benmachine> between reverse with ' and without
16:02:40 <zygoloid> foldl' generates a list, foldl generates a chain of thunks
16:02:48 <zygoloid> (in the reverse case)
16:02:55 <Saizan> so using foldl' for reverse wouldn't only waste a little time to make sure that (:) is evaluated
16:02:58 <hape> @type id
16:02:59 <lambdabot> forall a. a -> a
16:03:25 <hape> in "forall a. a -> a"  how to do yo speek the dot after forall a?
16:03:26 <Saizan> zygoloid: when the applied function is a constructor i don't think there's really a difference
16:03:34 <hape> is this an composition .
16:03:50 <benmachine> no hape
16:04:04 <benmachine> it's just a separator
16:04:14 <benmachine> between the forall bit and the actual type
16:04:26 <zygoloid> Saizan: i was wondering about that :)
16:04:28 <hape> benmachine: ah i see
16:04:48 <hape> benmachine: how do you say (when you talk)?
16:05:08 <Saizan> "for all ei, ei arrow ei"
16:05:12 <zygoloid> hape: leave a slight pause, as you would for a comma
16:05:18 <hape> thank yo both :-)
16:05:58 <jbapple> How can I refer to qualified infix operators, like "Prelude.+"
16:05:59 <jbapple> ?
16:06:11 <zygoloid> > 1 Prelude.+ 1
16:06:12 <lambdabot>   2
16:06:20 <jbapple> hm
16:06:44 <zygoloid> there's a haskell' proposal to change it to: 1 `Prelude.(+)` 1
16:07:08 <zygoloid> but for now we're stuck with that monstrosity ;-)
16:07:14 <sfultong> zygoloid: I'm having trouble thinking of an instance where you could pull something usable out of the top level thunk of foldl
16:07:26 <Saizan> i think 1 Prelude.+ 1 is much better
16:07:47 <hape> i like   1 Prelude.+ 1  to
16:07:48 <hape> i like   1 Prelude.+ 1  too
16:08:01 <Saizan> > foldl (flip const) undefined [1..10]
16:08:02 <zygoloid> Saizan: my brain sees that as (1 Prelude) .+ (1)
16:08:03 <lambdabot>   10
16:08:21 <Saizan> ah, i can see that :)
16:08:22 <sfultong> Saizan: ah, thanks
16:09:38 <Saizan> but legitimate uses of foldl are quite rare, indeed
16:10:09 <strobedream> hey umm is there a way to run a set a commands and see the output from a file?
16:11:02 <stevenmarky> do you mean system commands?
16:11:07 <atomizer_> :i interact
16:11:20 <strobedream> okay I'll try :i
16:12:13 <strobedream> no I'm just doing a file of commands aka a cheat sheet and it would be nice to be able to run it instead of copy/paste the output.
16:12:20 <strobedream> *being lazy*
16:12:35 <Saizan> you can pipe it into ghci
16:13:29 <strobedream> yeah thats what I was thinking. I just was wondering if there was "correct" haskell way
16:14:33 <Saizan> well, haskell the language doesn't talk about these "dynamic" features, there are some wrappers for the ghc-api (which is what ghci uses) though
16:16:43 <PeakerWork> did anyone use Haskell to send raw packets?
16:16:55 <jlouis> Saizan: most of the time, we catch it waiting for something :) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24725#a24725
16:17:47 <jlouis> poormansprofiler always work when the RTS is written in C, hehe
16:18:12 <Saizan> hah :D
16:18:59 <sfultong> > foldl' (flip const) undefined [1..10]
16:19:00 <lambdabot>   10
16:19:05 <sfultong> ??
16:19:27 <benmachine> strobedream: you can define a : command in ghci to do this for you
16:19:33 <jlouis> sfultong: aint lazy evaluation beautiful?
16:19:41 <Saizan> > foldl' (flip const) undefined ([1..5] ++ [undefined] ++ [6..10])
16:19:42 <lambdabot>   * Exception: Prelude.undefined
16:19:46 <Saizan> > foldl (flip const) undefined ([1..5] ++ [undefined] ++ [6..10])
16:19:47 <lambdabot>   10
16:19:48 <benmachine> strobedream: something like :def source readFile
16:20:05 <sfultong> oh, ok
16:20:11 <benmachine> strobedream: then :source blah.ghci runs blah.ghci as a series of ghci commands
16:20:52 <benmachine> maybe that's not quite what you want
16:20:52 <strobedream> benmachine: thanks I'll try that
16:20:57 <benmachine> but it's interesting anyway
16:21:58 <jabes> Hello again.  Sorry for the stupid question, but if I define a type like "data Thing = I Int | F Float", how do I make my own show function?  Also, is this the wrong way to do it?
16:22:19 <benmachine> jabes: data Thing = I Int | F Float deriving (Show)
16:22:21 <Saizan> instance Show Thing where show ...
16:22:31 <benmachine> you can derive other classes too
16:22:38 <benmachine> jabes: data Thing = I Int | F Float deriving (Show, Eq, Ord, Read)
16:23:15 <benmachine> wrt "wrong way to do it", depends what you are trying to do; there's nothing particularly wrong with that on its own
16:23:35 <benmachine> (you could argue the names are a little unhelpful but I'm assuming they're illustrative :P)
16:23:57 <anger_> Is there a library function to split a list every n elements, like [[1,2],[3,4],[5,6],[7,8]...]?
16:24:28 <ezyang> anger_: Have you hoogled it?
16:24:53 <anger_> I looked and couldn't find it, so I'm asking here
16:25:04 <jabes> Saizan: Hmm. Okay.  I'll give the instance thing a go.  Thanks.
16:25:14 <benmachine> http://hackage.haskell.org/package/split this has lots of useful things, but I don't know if what you want is one of them
16:25:27 <benmachine> it wouldn't be too hard to write the function yourself using splitAt
16:25:46 <jabes> benmachine: Thanks, I tried deriving, but the built in show isn't quite right for me.
16:26:09 <benmachine> jabes: does it have to be show? you coudl just define your own Stuff -> String function
16:26:34 <benmachine> jabes: when people use Show it's nice to get consistent behaviour i.e. to get a string that looks like a valid haskell expression
16:27:00 <benmachine> jabes: I say "it's nice" - it's not compulsory at all, but often if I want a generic stringising function I just invent my own
16:28:38 <stevenmarky> anger_: chunk or splitEvery in split
16:28:39 <jabes> benmachine: I'm not really sure.  I'm trying to use the fgl graphviz library to output a file, and it seems to use show to print the vertex labels.  But that means when I print a float I get 1.0e-3 for instance in the output file, which isn't what I want.
16:28:42 <PeakerWork> hmm.. how come sendTo on a raw socket, as root, returns a permission denied?
16:28:44 <benmachine> > let splitsAt n xs = first : splitsAt n rest where (first, rest) = splitAt n xs in splitsAt 2 [1 .. 8]
16:28:45 <lambdabot>   [[1,2],[3,4],[5,6],[7,8],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
16:28:48 <benmachine> whoops
16:29:16 <jabes> benmachine: So I thought if I wrote my own instance of show I could prevent that.
16:29:23 <benmachine> jabes: oh, that sounds reasonable
16:29:27 <stevenmarky>  > chunk 3 "yourface"
16:29:33 <stevenmarky> oops.
16:29:39 <benmachine> jabes: btw, there's a silly trick that you can use to get GHC's derived show code
16:29:41 <grok> looking for a function to return a list of the first n primes. having issues figuring it out though.
16:29:59 <jabes> benmachine: do tell...
16:30:24 <benmachine> jabes: have you heard of the StandaloneDeriving extension?
16:30:37 <benmachine> (probably not, I'm guessing; you're using GHC right?)
16:31:10 <jabes> benmachine: No, I haven't, and I am using ghc.  I just haven't had the need for extensions yet.
16:31:15 <benmachine> well
16:31:37 <benmachine> you don't need them in your actual code, just for the silly trick
16:31:49 <jabes> Oh right.
16:31:59 <benmachine> StandaloneDeriving basically allows you to derive typeclasses using a different syntax
16:32:23 <benmachine> just on a normal line you can write deriving instance Show YourType
16:32:50 <benmachine> the reason this is interesting for you is because if the derived code fails to typecheck it dumps the whole thing into the type error
16:33:33 <benmachine> so if you do deriving instance Show YourType and then add a field to YourType that contains a function (say), then GHC will fail (because you can't show functions) and give you the entire derived instance
16:33:38 <benmachine> so you can see why it failed
16:33:54 <benmachine> then you take the code, remove the function field, and disable the extension
16:33:54 <Saizan> that's evil :D
16:33:55 <benmachine> tada
16:34:10 <benmachine> I emphasise the "silly" in "silly trick"
16:34:13 <benmachine> but it works :P
16:34:44 <jabes> Haha.  That's great.  I'm going to use that, I think.
16:35:13 * hackagebot hoopl 3.7.1.0 - A library to support dataflow analysis and optimization  http://hackage.haskell.org/package/hoopl-3.7.1.0 (NormanRamsey)
16:35:36 <Saizan> woot
16:35:46 <Veinor> oh hey, 143 unread messages to haskell-cafe
16:35:52 * Veinor marks all as read
16:37:11 <benmachine> heheh
16:37:29 <benmachine> I did that a while ago when I broke my mail reception on benmachine.co.uk and didn't notice
16:37:40 <benmachine> two weeks of backlog, like 150 threads
16:37:48 <benmachine> I got about 50 in then went "screw this"
16:59:35 <benmachine> jabes: oh hey, I just found out about ghc's -ddump-deriv - I think the output is less friendly but it's also less work to get :)
17:03:52 <glguy> Is it the case that you must use record syntax to provide haddock documentation for the parameters to a constructor?
17:04:28 <jabes> benmachine: Oh, right.  That does the same as your StandaloneDeriving trick then?
17:05:05 <benmachine> jabes: not quite, but similar
17:08:49 <fax> I've written a game AI in haskell  main = print "The only winning move is not to play.
17:09:10 <tensorpudding> Sounds like a wiseguy.
17:09:19 <kevinulin> your game ai doesnt compile
17:09:33 <felzix> I'd use putStrLn, myself. It wouldn't have quotes in the output.
17:10:24 <liyang> Isn't that a quote, though?
17:10:29 <benmachine> yes
17:10:41 <liyang> So it ought to have quotes in the output.
17:10:56 <benmachine> mm, suppose so
17:11:36 <benmachine> hmm, GHC's "quickest" build flavour uses its own clever definition of the word "quick" which I had not yet come across
17:11:42 <Sgeo> WHen using case of, is there any equivalent to guards as when you're writing several partial definitions for the function?
17:12:07 <benmachine> Sgeo: yes, the equivalent is use guards
17:12:34 <Sgeo> So I can write case something of { a | True -> whatever }
17:12:49 <Sgeo> (Not sure if that's how it's de-layoutized
17:13:21 <benmachine> yes
17:13:33 <benmachine> this isn't covered in many tutorials I think
17:13:38 <benmachine> it's a shame because it comes in handy
17:13:41 <fax> case () of _ | ... -> ...
17:16:39 * Sgeo 's asked this before, but where's the download link for the Windows version of the new Platform? code.haskell.org seems to be working again
17:17:09 <Sgeo> n/m found it
17:19:30 <Sgeo> Is WinGHCi any better in the new Platform?
17:19:39 <Sgeo> I tried WinGHCi once, didn't like it that much
17:21:04 <siracusa> Are these case guards Haskell98-compliant?
17:22:47 <Cale> siracusa: yes
17:25:37 <Sgeo> If I just install Platform 2010, will everything just work?
17:25:48 <Sgeo> Without uninstalling the previous Platform?
17:32:16 <Sgeo> Why the the installer install perl?
17:32:52 <EvanR> not sure if this is related, but perl is required to run gnu autofriends
17:33:07 <EvanR> which may be involved with ghc somehow
17:34:08 <liyang> BLACK MAGIC and/or VOODOO.
17:34:17 <c_wraith> a few pieces of the platform require perl.  like, um... happy
17:34:29 <Axman6> and possibly still GHC
17:34:43 <Axman6> if you want to use the -fvia-C flag
17:36:49 <ddarius> Perl and Haskell, the unlikely bedmates of the stars.
17:37:34 <liyang> Face it, Perl is just a better language.
17:37:46 <c_wraith> must I?  facing it makes my eyes bleed. :(
17:37:48 <Eridius> Perl is used for the Evil Mangler
17:37:58 <liyang> Evil is Good.
17:38:10 <Saizan> Slavery is Freedom.
17:38:59 <EvanR> why php superceded perl i do not know
17:39:12 <drhodes> brackets
17:40:09 <PeakerWork> is it possible to use "deriving" with Arbitrary?
17:40:24 <Saizan> no
17:40:27 <PeakerWork> bummer
17:40:42 <Saizan> there might be a Derivation in Data.Derive though
17:40:52 <PeakerWork> what do you mean?
17:41:32 <Sgeo> Grr at WinGHCi not defaulting to a monospaced font
17:41:53 <Saizan> PeakerWork: a TH macro
17:42:00 <PeakerWork> Saizan: Oh, that's as good as a "yes" :)
17:43:11 <Saizan> http://hackage.haskell.org/packages/archive/derive/2.3.0/doc/html/Data-Derive-Arbitrary.html <- here it is
17:43:23 <Saizan> $(derive makeArbitrary ''YourType)
17:43:38 * kmc hits the source link for that value
17:43:42 * kmc vomits a little in his mouth
17:44:30 <Saizan> hehe, looks like it got generated by the guessing mechanism :)
17:44:35 <kmc> guessing?
17:45:27 <Sgeo> Is it safe to say that in all but the simplest cases, case of is better than multiple definitions?
17:45:40 <Saizan> iirc, there's a function in there that given an instance for a specific datatype it'll write out a makeFoo
17:45:41 <kmc> no
17:45:49 <kmc> Saizan, haha
17:45:59 <kmc> monkey see monkey do
17:46:16 <kmc> Sgeo, it really depends on circumstance
17:46:27 <kmc> often i think multiple equations for a function is clearer
17:46:49 <kmc> "case of" is useful to take apart a value which is the result of some computation
17:47:30 <Sgeo> case of allows common where clauses for each branch, and makes it easier to add arguments to the function later
17:47:33 <Darkone> Hmm, after you finish Learn you a Haskell, I take it that it's probably best to move on to real world haskell, until Learn You is complete? :<
17:47:59 <kmc> Darkone, RWH is great
17:48:20 <Darkone> Yea, it's lots of detail... but also a bit long winded :P
17:48:24 <Cale> Darkone: yeah, you could try RWH, or if there are specific topics you're interested in, there are often good articles specifically about those things
17:48:32 <Darkone> Oh?
17:48:36 <Cale> (and academic papers)
17:48:47 <Cale> SPJ's papers in particular are really good
17:48:47 <Darkone> Was thinking to get the rest of the basics, like Monads and that
17:49:14 <Darkone> Then go look up some stuff on using external libraries with haskell, game design, and how threading works in haskell.
17:49:26 <Cale> http://www.haskell.org/haskellwiki/Monads_as_Computation
17:49:28 <kmc> RWH covers concurrency and parallelism
17:49:32 <kmc> quite well i think
17:49:37 <kmc> you could skip ahead to those chapters
17:49:37 <Darkone> Oooo.
17:49:39 <Philonous> Well, except that Monads are not basic and you can't "get them"
17:49:39 <Cale> http://hackage.haskell.org/packages/archive/pkg-list.html -- packages :)
17:49:52 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html -- basic libraries
17:50:05 <kmc> monads are pretty basic.  "Monad" is a typeclass with only two methods
17:50:15 <kmc> it's just an API that certain types conform to
17:50:18 * Axman6 still thinks that monads are easier to use than 'get'
17:50:31 <Darkone> Philonous, bah, people make things out to be too complicated all the time, instead of sitting down, and just thinking it through slowly (and possibly with alot of visualization! :P)
17:50:36 * kmc thinks that monads are easier to use than git
17:50:45 * Darkone rimshot!
17:50:46 <Cale> I think that in order to understand monads, it helps to first understand the way that functional programmers write programs
17:51:17 <Saizan> and how typeclasses really work.
17:51:20 <Cale> We write what are called alternately "combinator libraries" or "embedded domain specific languages"
17:51:23 <felzix> I'm still not sure what classes are in haskell.
17:51:33 <Darkone> Like functors and applicative functors made perfect sense after reading the examples, though not after you forget them 5 minutes later when you see something shiny.. D:
17:51:53 <Darkone> Cale, Bau ghn was talking about a combinator Library.
17:52:01 <Cale> and we've done this often enough that we've started to notice some patterns in how these things are constructed (some common shapes that the APIs often have)
17:52:05 <Darkone> Never explained that they were though :P
17:52:08 <Cale> and monad is just one of those
17:52:18 <solidsnack> Cale: I think this is an interesting approach.
17:52:33 <Cale> A combinator library is just a library with a rich enough API that it becomes like its own miniature special-purpose programming language.
17:52:35 <EvanR> felzix: set of types which have a common interface, function which takes that class doesnt need to know about individual instances
17:52:36 <solidsnack> Cale: Instead of going categories->functors->monads.
17:52:44 <Cale> It will define some primitive computations
17:52:52 <Darkone> Yea, LYaH said that monads were partially a way to emulate things like state and that.
17:52:54 <Darkone> Ahhh.
17:52:57 <Cale> and it'll define some means of combining those primitive computations into richer ones
17:53:01 <fax> solidsnack what approach /
17:53:02 <fax> ?
17:53:06 <Darkone> So a simplest possible library
17:53:15 <felzix> EvanR: They enable polymorphism?
17:53:19 <EvanR> yes
17:53:20 <solidsnack> fax: Right now, Cale's approach.
17:53:31 <fax> what is it
17:53:37 <Darkone> Of base functions, and then a sort of set of... uhh... computations? That combine the building blocks.
17:53:42 <EvanR> felzix: + is a good example of an interface for things that can add
17:53:46 <solidsnack> fax: Not mentioning functors at all but instead talking about composable EDSLs.
17:53:51 <fax> oh
17:53:53 <Axman6> @src Identity (>>=)
17:53:53 <lambdabot> m >>= k  = k (runIdentity m)
17:53:55 <Cale> Well, for example, a combinator library for drawings might define some very simple primitive drawings: lines, curves, some other shapes maybe
17:54:03 <Axman6> @src Identity return
17:54:03 <lambdabot> return a = Identity a
17:54:08 <Cale> and then ways to transform and combine drawings
17:54:09 <Axman6> @src Identity
17:54:10 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
17:54:20 <felzix> EvanR: Ah, thanks. To understand something, it helps me to know the intent behind it.
17:54:25 <Darkone> Helps that alot of haskell concepts are synonymous with certain game systems of magic ;)
17:54:29 <Cale> So, scaling, rotating, putting one drawing on top of another, putting drawings side-by-side
17:54:31 <Darkone> Cale, right.
17:54:32 <EvanR> felzix: so if your function uses + on the values, you dont need to write one for Ints, one for Floats
17:54:32 <kmc> Darkone, to emulate state, or to describe actual stateful computations
17:54:37 <theorbtwo> I get the impression that the BBC is somewhat constrained about what they can say about elections that haven't been called, so they did an orgy of coverage today.
17:54:50 <Cale> and then maybe some even richer stuff like "replace all the lines in this drawing with a copy of this other drawing"
17:55:08 <Darkone> Basic shapes and objects, combinations of them, operations on them, advanced combinations, advanced operations, etc etc.
17:55:08 <theorbtwo> Everybody else has been saying that the election would be may 6th for ages, so it's not as big a deal.
17:55:23 <kmc> i.e. the monad "State" implements state by passing an extra arg to your function calls, but "ST" implements state with actual in-place update to mutable cells
17:55:24 <Darkone> Cale, I think LYaH already shows a small example of that, indirectly.
17:55:26 <Philonous> Darkone: If you are looking at monads coming from Functors, Appllicatives and Arrows they actually do make sense. What I meant was that monads are a group a data structures sharing a common interface and not a thing in it's own right. But since all the structures already have to provide the functionality you want to access via the monad interface you don't necessarily need to know the abstract interface just to use rthe structure
17:55:42 <theorbtwo> That was the wrong channel.  Sorry.
17:55:45 <Cale> A combinator library for food recipes might define primitive recipes, like single ingredients, and then recipe-combinators that combine other recipes in some formulaic way (whip, layer, etc.)
17:56:09 <Darkone> Where you might have Point (a,b), and then Line composed of two points, and then etc etc etc.
17:56:12 <Darkone> Right? :P
17:56:30 <kmc> Darkone, take a look at http://www.haskell.org/ghc/docs/6.10-latest/html/libraries/pretty/Text-PrettyPrint-HughesPJ.html
17:56:31 <Cale> and then have functions which recursively act on the structure of how the recipe was built up -- for example, computing the sugar content based on the sugar in the ingredients, and then how each operation affects it
17:56:36 <Darkone> And maybe a 2d transform that takes a line, and rotates it about another point
17:56:41 <Cale> Darkone: yeah
17:56:44 <kmc> this is a library for building "documents" in such a way that they can be output with nice formatting
17:56:47 <kmc> I think it's covered in RWH, too
17:57:11 <Darkone> Yes, you make your own pretty print module
17:57:12 <Cale> Darkone: Or, more to the monadic side of things, let's talk about parsers, which I think are a really good example of a monad.
17:57:20 <theorbtwo> Text.PrettyPrint is.  I can't remember if they mention .HughesPJ.
17:57:25 <Darkone> Though I kind of skipped past that to read... uhh
17:57:44 <Darkone> Went back to LYaH when I got to the JASON library in RWH
17:57:46 <Saizan>  /win 21
17:57:46 <Cale> Darkone: You might have a library for parsing which starts by defining the simplest possible parsers: ones which match just a single character, say.
17:58:01 <Darkone> Yea, I see what you mean now :P
17:58:11 <Cale> Darkone: and then various operations to combine parsers: concatenation, alternation, and so on
17:58:32 <solidsnack> Darkone: JASON?
17:58:37 <kmc> JSON?
17:58:43 <Cale> Now, parsers (usually) have a result -- some kind of data structure which is constructed from the parsed string
17:58:43 <Darkone> kmc got it.
17:59:00 * Axman6 loves parsing in haskell
17:59:17 <Darkone> Right, and you might have a construct to represent a single piece of data, and then a complex structure of that data
17:59:21 <Cale> Darkone: We might envision an operation >>= where if x is some parser, and f is a function which takes the result of parsing with x, and makes us another parser, glues those two things together in the obvious way
17:59:53 <Darkone> Thinking deeper, alot of common... things? Structures. in languages are actually similar to what you're talking about.
17:59:55 <Cale> So x >>= f is the parser which parses first with x, getting some result v, and then parses the rest of the string with the parser f v
18:00:04 <Cale> okay?
18:00:04 <Darkone> You have basic data types, like int, string, char, etc etc
18:00:19 <Darkone> And then you combine then to form more advanced types, like person, place, thing
18:00:36 <Darkone> Yea.
18:00:37 <Cale> This operation >>= is called 'bind' and is one of the two things that we need in order for our parsers to be a monad.
18:00:45 <Darkone> That was in applicative functors
18:00:52 <Darkone> Wait.
18:00:56 <Cale> actually, this one isn't in applicative functors
18:00:59 <Darkone> No, that was after that, monads
18:01:02 <Darkone> Yea.
18:01:06 <Cale> right
18:01:20 <Darkone> Went over how do blocks are pretty versions of things like >>= and >>
18:01:36 <Cale> and then the other one is 'return', being a function which takes a value, and gives the parser which just always returns that value without eating any of the string
18:02:04 <Cale> and these together with the type constructor, Parser, give us a monad
18:02:10 <Darkone> getLine >>= putStrLine I think is an example? Forgot what the getLine was.
18:02:19 <Cale> So, x :: Parser t, means that x is a parser which has a result of type t
18:02:24 <Darkone> s/forgot what/forgot how/
18:02:30 <Cale> yeah, that's in a different monad, the IO monad
18:02:31 <Darkone> Yep.
18:02:39 <Darkone> Ahh, right.
18:02:57 <Darkone> Dealing specifically with IO, otherwise, >>= and >> etc are general, aren't they?
18:03:02 <Cale> yeah
18:03:05 <theorbtwo> Cale: Can you give an example of a monad where return is non-trivial?
18:03:07 <Cale> and return is too
18:03:16 <Cale> theorbtwo: return is *supposed* to be trivial
18:03:20 <kmc> what's "trivial"?
18:03:29 <dankna> @hoogle on
18:03:29 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
18:03:30 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
18:03:30 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
18:03:31 <EvanR> Cale: im actually trying to follow along here. x >>= f is a parser which uses parser x to parse some of the string, and passes the result plus the rest of the string to f ?
18:03:50 <Darkone> return in IO just wraps a value up as an IO value, so that it can be the last value in an IO block, or something like that.
18:04:04 <Cale> EvanR: Yeah, or, better, it parses the remainder of the string with f v, where v is the result of parsing the first part with x
18:04:09 <EvanR> Cale: and f would presumably append ITS result to the previous result when it 'returns' ?
18:04:14 <Axman6> Darkone: has nothing to do with being last
18:04:15 <Cale> no
18:04:22 <EvanR> by append i mean combine
18:04:29 <Cale> The result of the overall parser is the result of f v
18:04:38 <kmc> you often use "return" at the end of a "do" block but it's useful in other places too
18:04:43 <Darkone> Cale, EvanR, I think it would be right to say that  x >>= y   generally means a function x that passes it's result to a function y?
18:04:46 <Cale> So, to run x >>= f, you:
18:04:46 <Axman6> Darkone: return in IO just gives you an Io computation, which when run returns what you gave return and performs no actual IO
18:04:51 <Darkone> kmc, right.
18:04:57 <Cale> 1) parse the initial portion of the string with x, getting some result v
18:05:03 <Saizan> it's still common for the result of f v to contain v somewhere though
18:05:09 <Cale> 2) parse the remainder of the string with f v, getting some result w
18:05:13 <Cale> 3) return the result w
18:05:17 <Darkone> Axman6, yea, it wraps it in an IO comp, without doing anything to it otherwise.
18:05:25 <Axman6> @src IO return
18:05:26 <lambdabot> return x    = returnIO x
18:05:28 <Saizan> (if we're talking about parsers)
18:05:30 <Cale> Or, in do notation, it's just:
18:05:31 <Axman6> @src IO returnIO
18:05:32 <lambdabot> Source not found. My mind is going. I can feel it.
18:05:36 <Darkone> Cale, so I was fairly close :P
18:05:37 <Axman6> @src returnIO
18:05:37 <lambdabot> Source not found. My pet ferret can type better than you!
18:05:42 <Axman6> bah!
18:05:44 <Cale> x >>= f is equal to do v <- x; w <- f v; return w
18:05:45 <EvanR> Cale: ok and where is the string during all this
18:05:52 <theorbtwo> kmc: By trivial, I meant just wrapping it's argument up into some sort of structure, with a constructor, or something very close.
18:06:13 <Cale> EvanR: Implicitly passed along by the parsing machinery.
18:06:28 <EvanR> so v encodes part of the string and the value
18:06:30 <Cale> EvanR: The parsers might contain function values which take the string as a parameter
18:06:33 <Cale> no
18:06:35 <ddarius> @src State return
18:06:36 <lambdabot> Source not found. That's something I cannot allow to happen.
18:06:38 <Cale> v only encodes the result
18:06:44 <Cale> not the remainder of the string
18:06:47 <Darkone> Cale, similar to uhhh return.f.x except with things to make it conform to IO stabndards?
18:06:49 <EvanR> the string is embedded in the monadic type
18:07:06 <Cale> Let's do this more concretely and it'll become clearer
18:07:18 <Darkone> Yea, I think I got it, looking at your example.
18:07:22 <Cale> I'm going to define a parser for values of type t using the datatype:
18:07:35 <Cale> data Parser t = P (String -> [(String, t)])
18:08:02 <Cale> So a parser for values of type t, is effectively equivalent to a function which takes a string, and gives a list of possible parses
18:08:15 <Cale> and each parse consists of a depleted string, and a resuly
18:08:17 <Cale> result*
18:08:22 <Cale> good?
18:08:25 <EvanR> ok
18:08:31 <Darkone> Hmm. So thats a type that is a function that takes a string, and returns a list of string, t pairs. Correct? :)
18:08:34 <theorbtwo> With you so far.
18:08:40 <Cale> yes
18:09:05 <Cale> So to "run" one of these parsers and get a list of possible parses is going to be trivial, because we constructed the type to make it easy
18:09:22 <Cale> runParser :: Parser t -> String -> [(String,t)]
18:09:28 <Cale> runParser (P f) s = f s
18:10:15 <theorbtwo> Right.
18:10:18 <Darkone> Right, 'unwraps' the function in the parser, and applies it to the supplied string.
18:10:19 <EvanR> how do we combine two parsers
18:10:33 <Cale> Right, so there are lots of ways to combine two parsers, which one do you want :)
18:10:48 <EvanR> A followed by B
18:10:49 <Darkone> Cale, would I be correct in assuming reducing that to runParser (P f) = f would cause an error?
18:11:01 <Cale> Darkone: No, that would be equivalent to what I wrote
18:11:11 <Cale> I was just being extra explicit so as not to confuse anyone :)
18:11:20 <Darkone> Ahh kay. Had read somethign about doing that sometimes causing errors
18:11:24 <Darkone> Yea :P
18:11:41 <Darkone> I'm a lazy bastard, so I love things like that.
18:11:53 <EvanR> followedBy :: Parser t -> Parser t -> Parser t
18:11:57 <Darkone> Saving a whole 4 characters! :D
18:12:00 <Cale> Yeah, you can get bit by the dreaded monomorphism restriction if you remove the last explicit parameter of a function
18:12:15 <Darkone> Let me guess
18:12:19 <theorbtwo> It'll cause errors, just by programmers and not programs.
18:12:24 <Cale> EvanR: Well, it's actually easier to define that once we're finished defining >>=
18:12:36 <EvanR> ok
18:12:38 <Cale> because  followedBy x y = x >>= const y
18:12:40 <Darkone> followedBy (P f) (P x) = f.x ?
18:12:42 <kmc> Darkone, i think it's more clear too.  saying "function f is the same as function g" is more direct than saying "function f is a function such that, for any x, f x is the same as g x"
18:12:52 <theorbtwo> EvanR: Er, wouldn't that be Parser a -> Parser b -> Parser (a,b) ?
18:12:53 <Darkone> kmc, EXACTLY.
18:13:04 <Cale> It depends on what you want.
18:13:14 <Darkone> Less.... rubbish? on the screen.
18:13:20 <EvanR> theorbtwo: i figure we are talking about a bunch of parsers to develop the same result from the input
18:13:20 * theorbtwo very rarely wants to throw out part of his parse.
18:13:25 <Cale> But if you really want to, we can define followedBy first
18:13:30 <EvanR> it doesnt throw out part of the parse
18:13:40 <EvanR> t is a type, not a value
18:13:41 <Darkone> theorbtwo, trying to make a new parser from two parsers.
18:13:41 <lispy|web> :t >>= const y
18:13:42 <lambdabot> parse error on input `>>='
18:13:50 <lispy|web> :t (>>= const y)
18:13:51 <lambdabot>     Couldn't match expected type `m b' against inferred type `Expr'
18:13:52 <lambdabot>     In the second argument of `(>>=)', namely `const y'
18:13:52 <lambdabot>     In the expression: (>>= const y)
18:13:55 <Cale> :t (\x y -> x >>= const y)
18:13:56 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
18:14:01 <theorbtwo> :t (>>=) const y
18:14:02 <lambdabot>     Couldn't match expected type `(b1 -> a) -> a -> b'
18:14:02 <lambdabot>            against inferred type `Expr'
18:14:02 <lambdabot>     In the second argument of `(>>=)', namely `y'
18:14:14 <Cale> okay, let's stay on track here
18:14:26 <Cale> Maybe let's start with return
18:14:28 <lispy|web> theorbtwo: that's the wrong section :)
18:14:40 <Philonous> I like how the arrow interface allows one to build parsers for context free grammars whereas a monadic interface suffices to describe context-sensitive grammars. I think it demonstrates beautifully their descriptive power.
18:14:43 <Cale> return v is supposed to be the parser which doesn't eat any characters and simply succeeds with result v
18:14:53 <Darkone> Cale, why do you use >>= type stuff, instead of just extracting the functions, and composing them?
18:14:56 <Cale> return v = ...
18:15:16 <Darkone> return v = v, I would guess, or  YOURTYPE v
18:15:18 <Cale> Darkone: They're not the right type to compose like that
18:15:30 <Darkone> Cale, oh?
18:15:31 <Cale> Remember, return v is supposed to be a Parser
18:15:46 <Cale> The only way we have to build a Parser value right now is the data constructor P
18:15:50 <Darkone> Yea.
18:15:51 <Cale> So we might as well use it
18:15:54 <Cale> return v = P ...
18:15:55 <EvanR> return v = P (\s -> [(v, s)])
18:15:55 <kmc> Philonous, that's not correct
18:16:02 <ddarius> Understand the Haskell type system, and everything else becomes clear.
18:16:07 <Cale> and P takes a function String -> [(String,t)]
18:16:09 <kmc> "context sensitive" is a larger class of grammars than "context free"
18:16:15 <Cale> so it might as well be a lambda
18:16:18 <theorbtwo> return v = P (\str -> (str, v))
18:16:19 <Cale> return v = P (\s -> ...)
18:16:44 <Cale> and this list on the right of the lambda, we only want one result for our parser, so it'll be a simple list of length 1
18:16:44 <Philonous> kmc: Oh, you are right. I got it the wrong way around.
18:16:48 <Cale> return v = P (\s -> [...])
18:16:52 <kmc> Applicative gets you context-free grammars
18:16:53 <Darkone> Cale, look at EvanR's
18:16:57 <kmc> Monad describes context-sensitive grammars
18:17:00 <EvanR> mine is backwards
18:17:02 <kmc> I'm not sure what Arrows would be good for in parsing
18:17:06 <theorbtwo> return v = P (\str -> [(str, v)])
18:17:09 <Cale> right
18:17:17 <Cale> and theorbtwo has it 100% correct now :)
18:17:25 <Darkone> Yea, but close enough, EvanR :D
18:17:28 <Cale> I just wanted to go through the steps of writing the function one at a time
18:17:31 <theorbtwo> I forgot this was a multiple-guess parser.  (There's probably a better term for that.)
18:17:36 <Philonous> kmc: I'm pretty sure it's context free. Note how the nested pairs resemble a stack
18:17:43 <EvanR> Darkone: the trick was to remember the type of a parser ;)
18:17:52 <Cale> to illustrate how you should think when doing this sort of thing and keep track of what you have left to write
18:17:58 <kmc> Philonous, with Arrow?
18:18:05 <Philonous> kmc: Yes
18:18:13 <EvanR> a top down approach is very good
18:18:16 <kmc> you can rewrite any monadic action to use arrows
18:18:22 <kmc> so they give you at least context-sensitive grammars
18:18:23 <Cale> Now, we could go and write a parser for single characters
18:18:26 <Darkone> So, you have to use binds, because... err  v <- x;   in an IO sense, you have to bind the IO to a vlue?
18:18:27 <EvanR> i notice in php alot they think from bottom up, enclosing things in for loops and whatnot
18:18:31 <Cale> That makes a rather good primitive
18:18:42 <Cale> Or characters that satisfy a given predicate
18:18:47 <Cale> That's another good one
18:18:54 <Philonous> kmc: No, you can't express join in terms of arrow combinators.
18:18:58 <Darkone> I missed something earlier.
18:19:04 <Cale> Darkone: v <- x means "run the action x, calling its result v"
18:19:11 <Darkone> Right.
18:19:18 <ddarius> kmc: You have to think in terms of the provided interface, not examples.
18:19:19 <Darkone> Used in IO to seperate pure from impurse.
18:19:20 <kmc> Philonous, oh, you're right
18:19:21 <Cale> Darkone: and such a thing always occurs inside of a do-block which itself defines another action
18:19:25 <Darkone> impure*
18:19:30 <dankna> backtracking.  that's the better term for "multiple-guess".
18:19:39 <kmc> every monad is an arrow, but you need ArrowApply for an arrow to be a monad
18:19:43 <EvanR> v <- x  ===>  x >>= (\v -> ... ;)
18:19:52 <Darkone> Cale, exactly, so the binds are because we're working with something like IO, that needs that seperation
18:20:01 <ddarius> Every Monad -induces- an Arrow.
18:20:13 <Darkone> If our parsers handled data internally, they could use composition, couldn't they?
18:20:19 <Axman6> Induce Arrow, stat!
18:20:26 <Cale> Darkone: Parsers don't use IO
18:20:32 <SamB_XP> Axman6: Kleisli to the rescue!
18:20:44 <Cale> Darkone: But we still want to turn them into a monad. Monads don't really have anything to do with IO
18:20:52 <Darkone> Okay.
18:20:54 <Cale> and they don't really have anything to do with state
18:20:59 <Cale> these are common misconceptions
18:21:03 <Darkone> I think I know how to word this now.
18:21:09 <Cale> There is an IO monad, and there are state monads
18:21:09 <SamB_XP> Cale: they have SOMETHING to do with them
18:21:13 <Darkone> Why do we want it as a monad? What are the benefits?
18:21:15 <Cale> But that's not really what monads are about
18:21:32 <SamB_XP> there's the "is-a-somewhat-convenient-notation-for" relation
18:21:32 <theorbtwo> dankna: Thanks.  I suppose they are equivelent... the parser we are building doesn't really feel like a backtracing parser, but I guess in the presence of lazyness, it is.
18:21:36 <Cale> The advantage is that we get a library full of generic functions which work in any monad for free
18:21:37 <EvanR> Darkone: were about to combine parsers with combinators that are easy to define using >>=
18:21:40 <ddarius> Darkone: Things are or are not monads whether we want them to be or not.
18:21:41 <EvanR> which we havent defined yet
18:21:41 <dankna> theorbtwo: yeah...
18:21:43 <Cale> If we define our parsers to be a monad
18:21:46 <Cale> Things like...
18:21:48 <Cale> :t sequence
18:21:49 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
18:21:52 <Cale> :t mapM
18:21:53 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
18:21:54 <Darkone> Ahhh.
18:21:59 <Cale> :t zipWithM
18:22:00 <lambdabot> forall a b (m :: * -> *) c. (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m [c]
18:22:02 <Darkone> So, it's kind of a compatibility thing.
18:22:02 <Cale> and so on
18:22:17 <Cale> Yeah, or reuse of code thing.
18:22:18 <kmc> yes, "Monad" is an API.  when we say a type "is a monad" we mean it's compatible with that API
18:22:21 <Darkone> If we make it a monad, it will fit into other functions more neatly.
18:22:29 <Darkone> Ahhh. That makes sense xD
18:22:31 <Cale> It gets us lots of useful operations on parsers that we don't have to write
18:22:35 <kmc> Darkone, it's convenient to express parsers using the "do" notation
18:22:40 <kmc> and using functions like sequence and mapM
18:22:41 <Cale> because they've already been written to work with any monad
18:23:00 <Cale> That's what polymorphism is all about :)
18:23:03 <Darkone> Huh
18:23:14 <Darkone> What's the   a.    in forall ?
18:23:23 <EvanR> a type
18:23:23 <Darkone> Or is that period extraneous?
18:23:35 <dankna> the a is the type variable you're quantifying over, and the period is just a separator
18:23:35 <kmc> the period separates the quantified type variables from the rest of the type
18:23:50 <Darkone> I know what the a itself is ;P
18:23:55 <dankna> (personally I put a space before the period to make that clearer, but that's a little nonstandard)
18:23:56 <kmc> in Haskell 98 the stuff to the left of the period would not be there
18:24:04 <Darkone> Ahh, yea.
18:24:09 <kmc> it's only with certain GHC extensions that you want to write "forall"s explicitly
18:24:09 <Cale> forall a. just makes it explicit that what follows works for all types a
18:24:14 <kmc> although they are pretty essential extensions, imo
18:24:15 <Darkone> IF there was a space, it would definitely be clearer.
18:24:31 <Cale> The . isn't composition or anything, it's just punctuation
18:24:42 <SamB_XP> kmc: oleg may or may not agree ;-)
18:24:43 <Darkone> Yea.
18:24:47 <Cale> okay
18:24:56 <Cale> So now let's write our >>= operation
18:25:02 <Cale> x >>= f = ...
18:25:05 <EvanR> what does that do again?
18:25:08 <Darkone> (m :: * -> *)  meaning that m has to take a concrete type, and return a concrete type, right?
18:25:13 <kmc> yes
18:25:16 <Cale> Remember that x >>= f is the same as:
18:25:21 <Cale> do v <- x
18:25:27 <Cale>    w <- f v
18:25:30 <Darkone> EvanR, runs f with the output of x.
18:25:31 <Cale>    return w
18:25:38 <Darkone> And returns its output, right.
18:25:48 <Darkone> KEep forgetting that last part :P
18:25:55 <EvanR> x returns what?
18:25:56 <Cale> So, we run x on the initial part of the string, and then run f v on the depleted string.
18:25:57 <EvanR> f takes what/
18:26:12 <EvanR> string? list of parses?
18:26:16 <Cale> f takes a value of whatever type x produces
18:26:24 <Darkone> Think of it as...
18:26:27 <EvanR> that is the result of a parser, t
18:26:28 <Cale> (>>=) :: Parser a -> (a -> Parser b) -> Parser b
18:26:44 <Cale> stare at that for a minute
18:26:50 <Darkone> Lets say you wanted NOTHING but lower case characters.
18:26:52 <Cale> It can be pretty complicated at first
18:27:03 <Darkone> And you have a function that removes anything that isn't a character.
18:27:11 <Cale> uhh...
18:27:12 <Darkone> And one that removes anything that's uppercase
18:27:18 <Darkone> Am I on the right track?
18:27:25 <Darkone> s/function/parser
18:27:40 <Cale> Let's take this example, suppose you have a file which starts with a number, followed by that number of lines of data that you need to read
18:27:54 <EvanR> ok so f is how we will control how the parsers get combined
18:28:03 <Cale> So you want to start by parsing that number, and using it to decide how to continue
18:28:16 <Cale> (how many times to parse a single line of data)
18:28:22 <Darkone> Da.
18:28:31 <Cale> yeah, f will be the "continuation"
18:29:02 <theorbtwo> Right.  OK, now things are starting to make slightly more sense.
18:29:10 <Cale> Okay... so let's start to write this thing...
18:29:14 <Cale> x >>= f = ...
18:29:19 <Cale> we know it's got to be a parser
18:29:24 <EvanR> P
18:29:40 <Cale> Yeah, so we don't have much other than P yet, so might as well start that way :)
18:29:43 <Cale> x >>= f = P ...
18:30:01 <Cale> and then similarly as before, might as well be a lambda, so we can write things in terms of our initial string
18:30:05 <Cale> x >>= f = P (\s -> ...)
18:30:21 <Cale> okay, now we said we were going to run x with the initial string s
18:30:39 <Cale> but hmm... we'll get a whole list of possible depleted strings s'
18:30:43 <Cale> and results v
18:30:53 * theorbtwo smells a map.
18:30:53 <Cale> So in order to cope with all this, let's use a list comprehension
18:30:59 <theorbtwo> ...or not.
18:31:05 <EvanR> heh
18:31:06 <Cale> We could use map, but I think the list comprehension will turn out better
18:31:23 <Cale> After all, list comprehensions are a shorthand for concatMaps
18:31:29 <Darkone> Yes!
18:31:29 <EvanR> so x returns a number?
18:31:34 <Darkone> Let me think
18:31:42 <Cale> In our previous example it did
18:31:50 <EvanR> that example is over?
18:31:56 <Cale> x >>= f = P (\s -> [... | (s',v) <- runParser x s,  ...])
18:32:07 <Cale> well, we're writing the full >>=
18:32:11 <EvanR> ok
18:32:12 <Darkone> [ ... |
18:32:14 <Darkone> D'awww
18:32:22 <Darkone> Was working it out :P
18:32:37 <theorbtwo> ...but if we do it that way, then our >>= only allows for (Integral n) => P n, so isn't a true >>=.
18:32:38 <EvanR> runs the parser x on the initial string s
18:32:38 <Cale> Maybe look away and see that you get the same thing ;)
18:32:43 <EvanR> which produces a list of parses
18:32:52 <Cale> yep
18:33:19 <EvanR> so why arent we done yet
18:33:21 <Darkone> Right, and by using a list comprehension, you can use every member of a list with something else.
18:33:22 <Cale> and we capture each one of those by using the list comprehension, so for each depleted string s', and result v, we're going to continue with... whatever's next :)
18:33:25 <EvanR> what is f supposed to do
18:33:40 <Cale> f is going to take this result v, and give us our next parser, f v
18:33:50 <Cale> and we wanted to run f v on the depleted string s'
18:33:53 * benmachine idly notices that the tuple order seems to be the other way around from ReadS
18:34:01 <benmachine> not that anyone cares ever
18:34:13 <Cale> this will give us an even-more-depleted string s''
18:34:15 <Cale> and a result w
18:34:23 <Cale> benmachine: yeah
18:34:34 <EvanR> we want to actually run the parser using the result of f ?
18:34:39 <Cale> benmachine: I'm using the natural order, ReadS gets it wrong :P
18:34:46 <benmachine> heh ok
18:35:01 <Cale> EvanR: The result of f when we apply it to v will itself be a parser
18:35:03 <theorbtwo> Cale: Except it'll be a list of even more depleated strings.
18:35:05 <Cale> benmachine: I'll explain why later
18:35:18 <Darkone> Yes.
18:35:29 <Cale> theorbtwo: yeah, so we'll use the list comprehension to bind them
18:35:36 <benmachine> Cale: I'll have gone to bed by then; is it to do with the functor instance for tuples?
18:35:42 <Cale> x >>= f = P (\s -> [... | (s',v) <- runParser x s, (s'',w) <- runParser (f v) s'])
18:35:47 <Cale> benmachine: yes
18:35:50 <benmachine> oh ok
18:36:08 <Darkone> Right.
18:36:12 <Cale> So we now have our result(s) w and our final depleted strings s''
18:36:12 <EvanR> what is going on :S
18:36:30 <Darkone> cale, maybe rewrite with less ' s
18:36:32 <Cale> I'm a bit sorry that it's all on one line like this
18:36:49 <Cale> perhaps I should number the s's?
18:37:19 <EvanR> ok so you got (s', v) and (s'', w)
18:37:20 <Cale> x >>= f = P (\s0 -> [... | (s1,v) <- runParser x s0, (s2,w) <- runParser (f v) s1])
18:37:27 <Darkone> x >>= f = P (\string -> [... | (parsedonce, firstvalue) <- runParser x string, (parsedtwice, secondvalue) <- runParser (f firstvalue) parsedonce])
18:37:27 <Cale> yep
18:37:50 <Cale> okay, and so now what goes in our actual list?
18:38:00 <EvanR> do you want all combinations of (s', v) and (s'', w)
18:38:04 <Darkone> Uhhm. return something.
18:38:22 <Cale> We want all the (s'',w)
18:38:34 <Darkone> What are we doing again? returning the value, or a new parser?
18:38:41 <Darkone> Or technically both?
18:38:45 <EvanR> f returns a new parser
18:38:59 <Cale> We're in the middle of a list of values of type (String,b)
18:39:04 <Cale> and f v :: Parser b
18:39:11 <Cale> so w :: b
18:39:24 <Cale> remember f :: a -> Parser b
18:39:26 * SamB_XP hopes we are also of type (String,b) or we aren't going to compile
18:39:28 <theorbtwo> Well, (x >>= f) returns a parser, but that was what the P does -- takes a function from a string to a list of (depleated string, semantic value) pairs.
18:39:29 <Cale> and v :: a
18:39:30 <Darkone> Right.
18:39:33 <fax> For other ways to find out more about Haskell:
18:39:34 <fax> * Download Haskell
18:39:37 <fax> -_-
18:39:40 <Darkone> f is a... type constructor? right
18:39:44 <Cale> No
18:39:51 <Cale> f is a function, it's on the value level
18:39:53 <Darkone> I forgot the term
18:39:55 <Cale> not the type level
18:39:55 <Darkone> Oh right.
18:40:01 <Darkone> P is the constructor
18:40:03 <Darkone> ?
18:40:07 <Cale> P is a data constructor
18:40:10 <Cale> Parser is a type constructor
18:40:19 <theorbtwo> Darkone: constructors always start with capital letters.
18:40:20 * Sgeo tried to install GHC on his school's Linux system
18:40:32 <Darkone> theorbtwo, yea, was looking at it wrong
18:40:32 <EvanR> so the ... is just (s'', w)
18:40:33 <theorbtwo> As do names of types, but not type variables.
18:40:34 <Cale> fax: Yeah, I'm sad about that too
18:40:42 <Cale> fax: It just sounds retarded to me.
18:40:46 <Sgeo> No luck so far. Complained about something or other. Googled it, apparently it requires GHC to be installed in order to install GHC.
18:40:49 <Cale> EvanR: right
18:40:54 <EvanR> hmm.
18:41:05 <EvanR> gotta do some house work before the woman gets home from work!
18:41:08 <Cale> x >>= f = P (\s -> [(s'',w) | (s',v) <- runParser x s, (s'',w) <- runParser (f v) s'])
18:41:09 <SamB_XP> Sgeo: only if you build it yourself!
18:41:18 <Cale> and there it is, in all its majesty
18:41:24 <Darkone> So we return just the fully depleted string, and the fully run value. Is it returned as a parser, right?
18:41:25 <SamB_XP> it's kinda like you need a cc to compile gcc
18:41:30 <Sgeo> SamB_XP, I didn't see the binaries in the thing that supposedly contained the binaries
18:41:31 <EvanR> monadic parser combinators
18:41:34 <EvanR> for the win
18:41:42 <SamB_XP> Sgeo: what distro ?
18:41:51 <Cale> Darkone: The whole expression to the right of the = sign is a Parser
18:42:00 <Sgeo> Not sure offhand, but I just took a generic package, since I don't exactly have root
18:42:01 <fax> Cale I agree!
18:42:04 <EvanR> parse failure, theres two = ;)
18:42:04 <Darkone> I think you said earlier, the return type is.. uhh, just a second, let me scroll up :P
18:42:09 <Cale> The thing inside of the P (...) is a function String -> [(String,b)]
18:42:22 <Cale> and then to the right of the -> in the lambda is just a list [(String,b)]
18:42:41 <Cale> and then the thing to the left of the | in the list comprehension is of type (String, b)
18:42:50 <Darkone> Back
18:43:03 <Darkone> Yea, forgot about the P and lambda
18:43:13 <Darkone> Was looking too hard at the list comprehension :P
18:43:17 <Cale> okay
18:43:39 <theorbtwo> Cale: I see how this is an implementation of >>= for our parser.  I am unclear, however, why it is something I want to do.
18:43:46 <Darkone> Wait.
18:43:54 * Sgeo goes to watch Avatar [the Last Airbender, not the movie]
18:43:58 <Cale> theorbtwo: Well, that will become clearer with use.
18:44:09 <Darkone> Cale, P takes only one input though, correct?
18:44:18 <theorbtwo> Sgeo: Both good.  The Last Airbender very good.
18:44:29 <Cale> theorbtwo: Basically, it's a generalisation of concatenation where we can make use of the result of the first parser
18:44:40 <Cale> Darkone: yes, a function
18:45:10 <Sgeo> theorbtwo, I can't see Avatar 3D except at a movie theater, and I don't think it's.. normal to go to a movie by oneself
18:45:25 <Cale> So now we can write various useful things in terms of >>=
18:45:27 <Darkone> We're passing it one input in the form of a tuple of a string and a value?
18:45:55 <Darkone> I'm probably not paying enough attention. It's late here ;P
18:45:56 <Cale> Like, pair x y = x >>= (\v -> y >>= (\w -> return (v,w)))
18:46:19 <Cale> which in do-notation just looks like  pair x y = do v <- x; w <- y; return (v,w)
18:46:39 <Cale> which is the notion of concatenation that someone else suggested above
18:46:44 <Cale> So >>= is more general than that :)
18:46:50 <Darkone> D'oh
18:46:59 <Cale> pair :: Parser a -> Parser b -> Parser (a,b)
18:47:05 <Darkone> Forgot that the list comprehension was part of the lambda
18:47:10 <ddarius> :t liftA2 (,)
18:47:11 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f (a, b)
18:47:25 <Cale> Probably should stick to liftM2 (,) for now ;)
18:47:39 <Cale> but yeah, the Control.Monad library will make things like this much simpler to write
18:47:50 <theorbtwo> Cale: Except the defintion we just wrote throws out the result of the first parser, doesn't it?
18:47:54 <Cale> Now that our Parser type constructor is a monad
18:48:11 <Cale> theorbtwo: it doesn't throw it out, it passes it to f and lets f decide what to do with it
18:48:53 <Cale> theorbtwo: So if f throws it out, then you might lose it, but if f produces a parser that includes that result as part of its own, then we keep it.
18:48:55 <Darkone> theorbtwo, which definition?
18:49:04 <Cale> x >>= f = P (\s -> [(s'',w) | (s',v) <- runParser x s, (s'',w) <- runParser (f v) s'])
18:49:07 <Cale> ^^ this one
18:49:08 <ddarius> My point is that that "concatenation" combinator is expressible with Applicative which is strictly "weaker" than Monad.
18:49:14 <Darkone> The one before with the list comp, or the new- right
18:49:22 <Cale> The result(s) of the first parser is v
18:49:26 <EvanR> Cale: how efficient is a parser that uses this technique
18:49:28 <theorbtwo> Darkone: x >>= f = P (\s -> [(s'',w) | (s',v) <- runParser x s, (s'',w) <- runParser (f v) s'])
18:49:32 <Cale> and it passes it along to f v
18:49:33 <Darkone> Yea.
18:49:52 <Cale> EvanR: To be honest, this is rather inefficient, but there are monadic parsers which are much more efficient
18:50:07 <Darkone> Right, it doesn't throw it out unless f throws it out, as f uses it as an input of sorts :P
18:50:09 <Cale> This is just a whole lot easier to understand
18:51:00 <Cale> Real parsing libraries go to extra trouble to ensure that the initial part of the parsed string will be possible to garbage collect earlier.
18:51:02 <Darkone> Like how  hurdur x y = y.x    only throws out the first parameter if y is like randomNumber = 4 :V
18:51:03 <theorbtwo> ...but f is just a parser.  It's supposed to take a string and parse it, not a string and a whatever-the-other-parser-returned.
18:51:11 <Cale> theorbtwo: no
18:51:20 <fax> Darkone what
18:51:25 <Cale> f is a function from the results of the parser x, to parsers for parsing the remainder of the string
18:51:29 <Darkone> fax ?
18:51:37 <fax> that did not make sense
18:51:48 <EvanR> theorbtwo: yeah, f takes the result of the previous parse
18:51:53 <Cale> To rephrase that, it's a function which gets to decide which parser to use, based on the result of x
18:51:55 <Darkone> fax, he was saying that the recently made thing throws out x
18:52:13 <fax> :S
18:52:31 <theorbtwo> Right.  OK.  Makes more sense now.
18:52:32 <Cale> Darkone: maybe you mean if y is a constant function
18:52:37 <Darkone> The recently made function though, is similar in VERY BROAD TERMS (cover my ass!) to composition
18:52:44 <grok> edwardk++
18:52:57 <kmc> :t (<=<)
18:52:58 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
18:53:10 <Cale> While it has a similarity with function composition, it's actually more like an analogue of function application, lifted to parsers
18:53:13 <Cale> (and flipped over)
18:53:20 <Cale> :t (>>=)
18:53:21 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
18:53:24 <Cale> :t (=<<)
18:53:25 <kevinulin> does anyone know, of the symmetric-key encryption modules, what is the best maintained and supported, im less worried about security as long as it does what it is suppose to dependably
18:53:25 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
18:53:27 <kmc> :t ($)
18:53:29 <Cale> :t ($)
18:53:29 <lambdabot> forall a b. (a -> b) -> a -> b
18:53:30 <lambdabot> forall a b. (a -> b) -> a -> b
18:53:40 <grok> and cale++ thanks guys for the help with my assignment. i managed to get it done before the deadline. i wouldn't have if not for this channel.
18:53:45 <ddarius> :t ap
18:53:46 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
18:53:49 <Darkone> So, hurdur x y = y.x    will use x in all cases where y outputs something based on an input.
18:53:55 <Cale> So here you can see from the type, that it looks rather similar to the type of ($) with some m's stuck into it
18:54:06 <Darkone> If y is a PRNG, it will use x
18:54:27 <applicative> kevinulin, no clue here.
18:54:31 <Darkone> If y is     randomNumber = 4, it throws out x, BUT NOT BECAUSE hurdur is throwing it out.
18:54:47 <Cale> Yeah, actually, let's take another look at this (<=<) operation which was mentioned
18:54:58 <Mathnerd314> @type liftM2 ($)
18:54:59 <lambdabot> forall a2 b (m :: * -> *). (Monad m) => m (a2 -> b) -> m a2 -> m b
18:55:10 <kmc> @type ap
18:55:10 <Cale> (f <=< g) x = do v <- g x; f v
18:55:11 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
18:55:16 <Cale> Or:
18:55:28 <Cale> (f <=< g) x = f =<< (g x)
18:55:32 <Axman6> :t (<*>)
18:55:33 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
18:55:36 <Darkone> Reading the :t of <+<
18:55:39 <Darkone> Err <=<
18:55:44 <Cale> and =<< is just the flipped-over version of the operation >>= that we were writing
18:55:49 <kmc> @src (=<<)
18:55:50 <lambdabot> f =<< x = x >>= f
18:55:50 <Mathnerd314> @type liftA2 ($)
18:55:51 <lambdabot> forall b b1 (f :: * -> *). (Applicative f) => f (b -> b1) -> f b -> f b1
18:56:19 <Cale> <=< takes a function (b -> m c) and a function (a -> m b) and composes them to get a function a -> m c
18:56:25 <lispy|web> :t id :: (a -> b) -> a -> b
18:56:26 <lambdabot> forall a b. (a -> b) -> a -> b
18:56:28 * theorbtwo is tempted to rewrite that as i =<< x = x >> i just to regain the symmetry.
18:56:29 <Cale> So it's analogous to normal function composition
18:57:05 <Cale> f =<< x = x >>= f  is already a palindrome :)
18:57:12 <Cale> of sorts
18:57:23 <Cale> (the <'s get flipped to >'s :)
18:57:51 <SamB_XP> Cale: I was just going to ask if you were going to quibble about the f's going in the same direction
18:58:04 <theorbtwo> Cale: Yes, but f isn't symmetric to f in the same way that > is symmetric to <.
18:58:09 <kmc> but i has serifs (usually)
18:58:10 <Cale> yeah :/
18:58:18 <kmc> o =<< x = x >>= o
18:58:21 <Cale> Oh, I see what you mean
18:58:22 <Axman6> @let x >>== f = x >>= f
18:58:23 <lambdabot>  Defined.
18:58:24 <Cale> yeah
18:58:29 <Cale> okay
18:58:36 <Cale> So, let's see what this has bought us
18:58:41 <Axman6> @let i ==<< x = x >>== i
18:58:42 <lambdabot>  Defined.
18:58:45 <Cale> We get all the stuff in Control.Monad for our parsers
18:58:50 <fax> I like this  (=<<) = flip (>>=)
18:58:51 <fax> :)))
18:58:53 <Cale> So, for example, we get sequence
18:58:54 <SamB_XP> I knows it!
18:58:55 <fax> you could do it automatically
18:58:55 <Cale> :t sequence
18:58:56 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
18:59:03 <Cale> specialising the type gives us:
18:59:09 <Cale> sequence :: [Parser a] -> Parser [a]
18:59:11 <fax> any time an 'directional' looking operator is defined, its flip gets defined too
18:59:23 <Cale> It takes a list of parsers, and gives us a parser whose result is a list
18:59:25 <SamB_XP> @let xx ===<< x = x >>=== xx
18:59:26 <lambdabot>  <local>:9:15: Not in scope: `>>==='
18:59:31 <SamB_XP> aww
18:59:34 <Cale> and how does it work? Well, it does the obvious thing
18:59:37 <SamB_XP> @type (>>==)
18:59:38 <lambdabot>     Ambiguous occurrence `>>=='
18:59:38 <lambdabot>     It could refer to either `L.>>==', defined at <local>:7:2
18:59:38 <lambdabot>                           or `Lava.>>==', imported from Lava
18:59:44 <SamB_XP> whoa
18:59:47 <Cale> It runs each of the parsers in the list in order, and produces a list of the results
18:59:48 <SamB_XP> Lava!
19:00:01 <Cale> Oh, is Lava still imported?
19:00:02 <fax> that's not right is it?
19:00:03 <Axman6> :t (Lava.>>==)
19:00:04 <applicative> whats Lava
19:00:04 <lambdabot> Signal Int -> Signal Int -> Signal Bool
19:00:14 <Cale> Lava is a circuit simulation library
19:00:18 <alex404> Does anyone know why ghci won't let me load programs with {- LANGUAGE XParallelListComp -}
19:00:19 <Axman6> :\
19:00:22 <SamB_XP> Cale: why, is it a security hole ?
19:00:30 <Axman6> alex404: -X
19:00:34 <applicative> strike the x
19:00:34 <SamB_XP> alex404: the X is wrong
19:00:36 <kmc> alex404, {-# LANGUAGE ... #-}
19:00:41 <SamB_XP> that's only for the command line
19:00:42 <Cale> SamB_XP: It's not, it just gets in the way a bit by defining... I think it might have been <*>
19:00:55 <applicative>  {-# LANGUAGE ParallelListComp #-}
19:00:56 <alex404> Err, I've got the # in there
19:00:57 <Axman6> {-# LANGUAGE ParallelListComp #-}
19:00:57 <Cale> :t (<*>)
19:00:58 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
19:01:00 <Cale> hmm
19:01:01 <Cale> nope
19:01:06 <alex404> I'll try without the X
19:01:13 <Cale> I forget which one it was
19:01:22 <Cale> One of the common combinators.
19:01:38 <SamB_XP> alex404: well obviously GHC is not going to complain about a pragma that isn't!
19:01:53 <alex404> Huzzah! It was the X
19:02:08 * hackagebot BlogLiterately 0.3 - A tool for posting Haskelly articles to blogs  http://hackage.haskell.org/package/BlogLiterately-0.3 (RobertGreayer)
19:02:17 <SamB_XP> alex404: also known as a comment ;-)
19:02:28 <alex404> Why is the ghci flag -XParallelListComp (i.e. with the X)
19:02:42 <applicative> because its a flag
19:02:52 <Cale> Because X is the prefix for language extension flags
19:02:55 <SamB_XP> alex404: -X means "now I'm going to give a LANGUAGE name"
19:02:59 <alex404> I see.
19:03:07 <Cale> The syntax is -X<name of language extension>
19:03:14 <Cale> yeah
19:03:15 <alex404> Hmmm... I can't talk about flags without thinking about eddie izzard.
19:03:21 <SamB_XP> -X came after LANGUAGE, I believe
19:03:23 <Cale> @quote flags
19:03:23 <lambdabot> shapr says: GHC has more flags than the UN
19:03:33 <alex404> Amazing.
19:03:37 <applicative> @quote flags
19:03:37 <lambdabot> shapr says: GHC has more flags than the UN
19:03:45 <SamB_XP> -X is helping with this issue, but only a little
19:03:54 <Cale> Uh, did it?
19:04:08 <Cale> I was pretty sure that -X came a little before LANGUAGE
19:04:10 <ddarius> "I know how to lessen the number of flags!  Let's add another flag!"
19:04:19 <SamB_XP> Cale: huh?
19:04:32 <SamB_XP> ddarius: it works a lot better than "lets add ten more!"
19:05:01 <Cale> SamB_XP: First they split up the -fglasgow-exts into the -X flags and then added LANGUAGE pragmas, I thought
19:05:14 <Cale> I could be mistaken about that
19:05:19 <SamB_XP> we must duel to death!
19:05:27 <SamB_XP> but, but, I've got the comonad!
19:05:33 <SamB_XP> OI, that is
19:05:36 <Cale> @quote voob
19:05:36 <lambdabot> No quotes match. :(
19:05:39 <Cale> aww
19:05:47 <SamB_XP> @google boov
19:05:49 <lambdabot> http://www.smekday.com/
19:05:49 <lambdabot> Title: The True Meaning of Smekday
19:05:55 <SamB_XP> @google boov comonad
19:05:56 <lambdabot> http://blog.sigfpe.com/2008/06/categories-of-polynomials-and-comonadic.html
19:05:56 <lambdabot> Title: A Neighborhood of Infinity: Categories of polynomials and comonadic plumbing
19:06:12 <Cale> it was on the old wiki quotes page I think
19:06:18 <ddarius> @quote boov
19:06:19 <lambdabot> No quotes match.
19:06:23 <ddarius> Cale: It was.
19:06:58 <Cale> http://www.haskell.org/hawiki/QuotesPage :(
19:07:11 * Cale wonders if anyone made a mirror
19:07:28 <ksf> ...and we don't even have -XH98 and -XH2010
19:07:45 <ddarius> http://web.archive.org/web/20070609061216/http://www.haskell.org/hawiki/QuotesPage
19:07:57 <ddarius> Cale: There is a snapshot of the wiki.
19:08:00 <Cale> yaaaay
19:08:25 <Cale> I actually think the old wiki somehow worked better than the new one.
19:08:30 <Cale> I'm not sure why
19:08:38 <Cale> But there was more of a community nature to it
19:09:07 <SamB_XP> maybe moinmoin is just more community-oriented than mikiwidea?
19:09:09 <lispy|web> if the wiki isn't easy to find via google, then it doesn't exist
19:09:16 <SamB_XP> er. mediawiki.
19:09:19 <Cale> SamB_XP: maybe
19:10:10 <Darkone> Back, sorry for disapearing
19:10:14 <Cale> This probably has something to do with Wikipedia's heavy handed policies about talking in the middle of encyclopedia articles ;)
19:10:15 <Darkone> Had to- ack, brb again D:
19:10:44 <lispy|web> Actually, I bet there has just been a general trend of change within the Haskell community.  Haskell-Cafe has certainly gotten a lot more verbose and trollful these days.  IMO.
19:10:51 <ddarius> Cale: I think it had to do with different "standards" for the wiki and just that it was a different community then.
19:11:10 <kmc> lispy|web, a true sign of success
19:11:39 <applicative> lispy|web: yes, some creepy things.  like gender meditations, man
19:13:06 <kmc> avoiding success keeps the community small and friendly
19:13:17 <applicative> I see its the {-#OPTS_GHC #-} that still have -Xs
19:14:22 <applicative> {-# OPTIONS_GHC -XDeriveDataTypeable -F -pgmF she #-}
19:14:23 <lispy|web> I tease dons that when I first met him, he literally knew the whole Haskell community
19:14:34 <lispy|web> That's clearly no longer the case, but through no fault of dons
19:15:03 <SamB_XP> Cale: oh, I just figured the UI was too heavy-handed ;-)
19:15:33 <Cale> lispy|web: It's partly dons' fault
19:15:53 <SamB_XP> Cale: well, it's not for lack of willingness to know them or anything
19:16:16 <SamB_XP> it's just plain not possible anymore
19:16:30 <Cale> Yeah, I just mean that he's worked toward the goal of a larger community, to the point that it's getting hard to know everyone
19:16:40 <SamB_XP> I figured that was what you meant
19:16:41 <lispy|web> heh, gotcha
19:16:48 <SamB_XP> but you can't really BLAME him for that
19:16:59 <ddarius> SamB_XP: Sure I can.
19:17:01 <SamB_XP> unless you're actually a PHPista
19:17:16 <Cale> NO, I CAN. DONS IT IS YOUR FAULT THAT I CAN'T KNOW EVERYONE.
19:17:18 <lispy|web> okay, ddarius can blame him for it, but not Cale.  Now on to axiom 2.
19:17:42 <SamB_XP> what about ICANN?
19:17:49 <lispy|web> Cale: stop writing proofs by contradiction.  We need to stick to intuitionistic logic here
19:18:20 <SamB_XP> lispy: usually you can get away with that in intuitionistic logic too, though
19:18:27 <SamB_XP> in specific instances, I mean
19:18:58 <hasenov> hello i am preparing for haskell presentation and i would like to get a detail about lazy evaluation before i make a fool of myself
19:19:21 <Cale> hasenov: okay
19:19:46 <hasenov> is it true that lazy evaluation in haskell works because it does not matter as much at what point in time a function is executed?
19:19:54 * lispy|web hands hasenov a G-machine
19:20:15 <kmc> hasenov, be careful about "execute" versus "evaluate"
19:20:15 <ddarius> SamB_XP: Like all of propositional logic...
19:20:36 <kmc> hasenov, in Haskell, evaluation never has a side effect (unless you cheat or look at some particular low level details)
19:20:42 <lispy|web> hasenov: Well, I think we started with purity and we were able to implement run-time systems that used laziness as the evaluation strategy because of it.
19:20:59 <ddarius> lispy|web: No, it was the other way.
19:21:03 <Cale> lispy|web: Historically, it was the other way
19:21:06 <kmc> hasenov, we typically reserve the word "execution" to mean something different from what happens when functions are applied to arguments
19:21:30 <Axman6> hasenov: it's important to remember that purity is very important in allowing you to have lazy evaluation
19:21:32 <hasenov> kmc: yeah, but thats not true anymore with monads
19:21:38 <Cale> If we want lazy evaluation, it doesn't make so much sense to add effects to evaluation because the evaluation order is difficult enough to predict that adding effects makes you go crazy.
19:21:40 <kmc> hasenov, oh?
19:21:42 <Veinor> now I get to learn how to write... CGI!
19:21:42 * lispy|web apologizes for trying to rewrite history
19:21:43 <Axman6> (probably not essential, but makes it a lot easier)
19:21:49 <Veinor> yay!
19:21:49 <kmc> hasenov, a function of type (String -> IO ()) is still a pure function
19:21:53 <lispy|web> Veinor: it's not too hard
19:21:57 <kmc> hasenov, and applying that function to an argument does not cause a side effect
19:22:02 <kmc> putStrLn is a pure function
19:22:09 <kmc> its return value is a recipe for how IO *could* be performed
19:22:14 <lispy|web> Veinor: stdout is the browser, stderr is the log file, and stdin is the browser
19:22:17 <Cale> hasenov: When you run a Haskell program, it's best to imagine that there are two separate interleaved processes taking place:
19:22:28 <SamB_XP> lispy|web: I think this is that "hair shirt" that was mentioned in a title a ways back ?
19:22:31 <kmc> what we mean by "execute" is when the runtime system inspects such a recipe and actually carries out the steps so described
19:22:34 <Cale> hasenov: There's evaluation, which turns expressions into values, and has no effect other than this.
19:22:39 <SamB_XP> we have to wear it to get lazy evaluation
19:22:52 <Cale> hasenov: and there's execution which takes IO action values, and carries out the effects that they describe
19:22:53 <lispy|web> SamB_XP: Hmm...I see.  Good point.
19:23:02 <lispy|web> SamB_XP: that's an SPJ talk, BTW
19:23:15 <kmc> hasenov, monads are *not* a mechanism for tagging certain functions to be impure
19:23:25 <ddarius> SamB_XP: What the heck are you talking about?
19:23:25 <SamB_XP> lispy: yeah, I knew it was an SPJ talk and/or paper
19:23:48 <ddarius> Nevermind.
19:23:53 <SamB_XP> ddarius: well, maybe I'm misusing the metaphor, but it's hard to tell with titles like this!
19:23:54 <lispy|web> ddarius: do you know the phrase, wearing the hairshirt?
19:23:59 <SamB_XP> @google wearing the hear shirt
19:24:00 <lambdabot> http://www.popsugar.com/Photos-Jennifer-Lopez-Wearing-Heart-Shirt-Shopping-Miami-6963209
19:24:02 <Cale> hasenov: Actually, GHC doesn't *quite* work in this way, instead doing lots of cheating and hackery behind the scenes, implementing execution in terms of evaluation-with-effects, but it's a good mental model regardless.
19:24:11 <SamB_XP> @google wearing the hair shirt
19:24:12 <lambdabot> http://www.wisegeek.com/what-is-a-hair-shirt.htm
19:24:13 <lambdabot> Title: What is a Hair Shirt?
19:24:16 <lispy|web> ddarius: it's a reference to great sacrifice for great good (I think it originated with stories of Jesus)
19:24:20 <SamB_XP> @google wearing the hair shirt Simon
19:24:22 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/papers/haskell-retrospective/haskellretrospective.pdf
19:24:22 <ddarius> lispy|web: I know the phrase and the paper.
19:24:22 <lambdabot> Title: Wearing the hair shirt Wearing the hair shirt
19:24:38 <ddarius> I just misread what SamB_XP said.
19:24:44 <lispy|web> ah
19:24:53 <SamB_XP> I am claiming that the hairshirt is in fact purity
19:24:54 <kmc> i thought it was a reference to hurting yourself for no reason
19:25:03 <Cale> hasenov: So, for example, if I simply *evaluate* (putStrLn "hello"), nothing is printed on the screen.
19:25:09 <kmc> > putStrLn "hello"
19:25:10 <lambdabot>   <IO ()>
19:25:22 <hasenov> Cale: so in C or java or any other eager evaluation language, the result is calculated at evaluation part, and in lazy evaluation language, it is evaluated at execution???
19:25:22 <SamB_XP> but luckily we found out hair was comfier than it sounded ;-)
19:25:39 <kmc> hasenov, you could invent a lazy language with impure functions.  but it's hard to use such a language
19:25:52 <kmc> because you need to think about lazy evaluation order, which is harder than thinking about strict evaluation order
19:26:01 <ddarius> kmc: ALGOL 60 was such a language.
19:26:03 <Cale> hasenov: Oh, here, I'll describe the different systems, the difference between lazy and strict evaluation is mostly just the order in which you reduce subexpressions
19:26:05 <kmc> the point of modeling side effects with monads is that we don't need to think about evaluation order at all
19:26:15 <Cale> hasenov: So, let me give my favourite example
19:26:18 <SamB_XP> ddarius: oh, is that why nobody ever uses Algol
19:26:20 <kmc> ddarius, really?
19:26:23 <Cale> Suppose we have the program  double x = x + x
19:26:24 <lispy|web> hasenov: instead of lazy, think of it as evaluation when it's needed (or demanded)
19:26:33 <Cale> and we're evaluating the expression double (double 5)
19:26:34 * Axman6 awaits another let double x = x+x in .. tutorial from Cale
19:26:40 <Axman6> XD
19:26:43 <SamB_XP> Axman6: too late!
19:26:43 <Cale> hehe
19:26:50 <SamB_XP> I got Cale's message first
19:27:01 <Axman6> me too
19:27:06 <Cale> So, under strict evaluation, it goes like this:
19:27:09 <Cale> double (double 5)
19:27:10 * lispy|web pulls up a log and sits next to Cale's tutorial campfire
19:27:12 <Cale> -> double (5 + 5)
19:27:14 <Cale> -> double 10
19:27:17 <Cale> -> 10 + 10
19:27:18 <Cale> -> 20
19:27:27 <theorbtwo> "A dozen lazy functional programmers" just makes me think that nobody could be bothered to get the tea.
19:27:29 <SamB_XP> lispy: are you seeing if he's just copy-pasting it ?
19:27:35 * lispy|web wonders if Cale has these scripted in his irc client :)
19:27:39 <Cale> Strict evaluation is innermost-first
19:27:43 <Cale> lispy|web: I do not.
19:27:47 <SamB_XP> lispy: see, you said you're pulling up a log ;-P
19:27:55 <hasenov> Cale: ok
19:27:56 <SamB_XP> so I figured you were checking on just that
19:28:07 <lispy|web> SamB_XP: hehe
19:28:08 * SamB_XP waits for it ...
19:28:23 <ddarius> kmc: ALGOL 60 had both call-by-value and call-by-name parameter passing modes.
19:28:27 <Cale> hasenov: So in strict evaluation we evaluate the function's parameters and then substitute the results into the body of the function. However, this is sometimes suboptimal
19:28:35 <SamB_XP> ddarius: but no call-by-need?
19:28:45 <Cale> What if the function doesn't actually end up needing the values of some of its parameters?
19:28:49 <Darkone> ARgghh
19:28:57 <Darkone> Now to scroll back up to see what I missed :(
19:28:58 <Cale> Then we might evaluate them accidentally just to throw them away
19:29:25 <Cale> So, we could try another way of doing things, where we evaluate outermost-first
19:29:41 <Cale> That way, if a function doesn't use its parameter, maybe that parameter won't be evaluated at all
19:29:54 <Cale> However, in our example, we'll see a simple problem with this:
19:29:59 <Cale> double (double 5)
19:30:05 <Cale> -> (double 5) + (double 5)
19:30:12 <Cale> -> (5 + 5) + (double 5)
19:30:14 <Cale> -> 10 + (double 5)
19:30:18 <Cale> -> 10 + (5 + 5)
19:30:21 <Cale> -> 10 + 10
19:30:23 <Cale> -> 20
19:30:36 <Cale> We duplicated the expression double 5, and had to evaluate it twice
19:30:50 <Cale> because the x parameter to the function double occurred twice in the body
19:31:20 <Cale> So innermost-first evaluation always evaluates all the parameters once, and outermost first evaluation evaluates each parameter zero or more times
19:31:27 <Cale> Can we get the best of both worlds?
19:31:34 <Darkone> You would want to do strict on the one to the right.... what was the command again?
19:31:40 <Darkone> Or function, I mean
19:31:52 <Cale> Sure, we'll just agree that whenever a function parameter occurs more than once in the body, we share the results of evaluating it between the copies.
19:32:01 <Cale> and that's all there is to lazy evaluation
19:32:19 <Cale> So, if you let me use 'let ... in ...' syntax to represent this sharing, we have:
19:32:23 <Cale> double (double 5)
19:32:32 <Cale> -> let x = double 5 in x + x   -- still outermost-first
19:32:37 <Cale> -> let x = 5 + 5 in x + x
19:32:43 <Cale> -> let x = 10 in x + x
19:32:46 <Cale> -> 10 + 10
19:32:47 <Cale> -> 20
19:32:54 <Cale> and now there's no wasted work
19:33:08 <Cale> Lazy evaluation evaluates each of the parameters to a function 0 or 1 times.
19:33:25 <Mathnerd314> does it matter if it evaluates them?
19:33:59 <Cale> Yes, in some cases.
19:34:04 <Mathnerd314> :-(
19:34:12 <Cale> What if the evaluation of a parameter would be an infinite loop?
19:34:26 <Mathnerd314> then move on to the next parameter...
19:34:38 <Mathnerd314> or return "Infinite Loop"
19:34:45 <Cale> Then maybe not evaluating it saves the program from going into an infinite loop, and it actually terminates.
19:34:46 <fax> ;D
19:34:56 <Cale> For example...
19:35:14 <Cale> > let loop = loop + 1; f x = 15 in f loop
19:35:15 <lambdabot>   15
19:35:20 <Cale> > let loop = loop + 1; f x = 15 in loop
19:35:24 <lambdabot>   mueval-core: Time limit exceeded
19:35:29 <hasenov> Cale: great, do u think i can use this example tomorrow? i'll include your name if u dont mind. Now what about pure function that kmc was mentioning?
19:35:38 <Cale> hasenov: Sure thing
19:35:44 <ManateeLazyCat> I have many function need Text as argument, but i need use `Data.Text.Lazy.pack` wrap String always, so have language option that convert String to Text for me automatically. Don't need use `pack`
19:35:45 <Mathnerd314> well, I'm asking if there's ever a case where Haskell *does* evaluate them when you don't want it to
19:35:59 <Cale> Mathnerd314: Oh, well, no.
19:36:05 <Axman6> hasenov: Cale is licenced uncer the creative commons share and share alike licence
19:36:16 <kmc> hasenov, i was saying that every function you typically run into in Haskell is a "pure function"
19:36:17 <Cale> Mathnerd314: Well, at least, unless it really has to.
19:36:31 <hasenov> i thought pure function meant that there is no outside state being modified, but in "putStr" function there is
19:36:38 <kmc> what that means is that the output is completely determined from the input, and that applying the function and getting a result has no side effect
19:36:40 <Axman6> under*
19:36:54 <kmc> hasenov, *evaluating* (putStr "foo") does not modify the outside world.  *executing* it does
19:36:57 <Axman6> hasenov: putStr isn't a pure function
19:37:01 <kmc> Axman6, yes it is
19:37:02 <SamB_XP> Axman6: sure it is!
19:37:07 <Axman6> heh
19:37:13 <Cale> hasenov: Right, so, separate from (but not completely orthogonal to) this matter of lazy evaluation is that Haskell is pure, or referentially-transparent
19:37:26 <Darkone> getLine isn't, though ;)
19:37:28 <Darkone> Right?
19:37:29 <kmc> if we see Haskell as a machine only for doing evaluation of the sort Cale described, we will get no side effects.  even if we use every IO action in the book
19:37:37 <kmc> Darkone, right, because it's not a function ;)
19:37:41 <Darkone> Yes! :V
19:37:45 <SamB_XP> lol
19:37:45 <Cale> which means that the results of functions in Haskell are completely determined by the parameters to the function and nothing else
19:37:55 <SamB_XP> good one, Darkone :-D
19:38:07 <Mathnerd314> @type seq
19:38:08 <lambdabot> forall a t. a -> t -> t
19:38:10 <Cale> and so if f and g produce the same result for the same parameters, you can replace one with the other without changing the meaning of the program
19:38:14 * Darkone dances
19:38:17 <applicative> ManateeLazyCat, can OverloadedStrings do that?
19:38:34 <Mathnerd314> Cale: does ($) == seq?
19:38:40 <Cale> Mathnerd314: no
19:38:43 <ManateeLazyCat> applicative: Thanks, i try.
19:38:45 <Sgeo> putStrLn is a function that takes a string and returns an IO ()
19:38:48 <lispy|web> Mathnerd314: no, ($) = id
19:38:50 <kmc> hasenov, in some sense, Haskell provides no way to "do" IO, only a way to describe IO which could be done later
19:38:56 <SamB_XP> @type [($), seq]
19:38:57 <lambdabot> forall a. [(a -> a) -> a -> a]
19:39:01 <SamB_XP> @type ($)
19:39:02 <kmc> but of course in real implementations, the runtime system is kind enough to actually do the IO that you described ;)
19:39:02 <lambdabot> forall a b. (a -> b) -> a -> b
19:39:04 <SamB_XP> @type seq
19:39:05 <lambdabot> forall a t. a -> t -> t
19:39:11 <Sgeo> That IO () is an action, that, if it were performed, results in output. But the same IO () will always result from the same input to putStrLn
19:39:33 <ManateeLazyCat> applicative: Wow, cool. Thanks a lot! :)
19:39:42 <Cale> seq is a magic primitive such that evaluating (seq x y) will ensure that x is evaluated up as far as determining its top-level constructor before the result of evaluating y is available
19:39:47 <kmc> indeed, getChar is not even a function.  it's an IO action, and it's always the same one.  you can evaluate it without anything interesting happening.  but if you *execute* it, you get a character
19:39:53 <Mathnerd314> @pl f x y = y
19:39:54 <lambdabot> f = const id
19:40:02 <applicative> ManateeLazyCat, check out the files in the "scripts" folder in the Data.Text package.
19:40:09 <Mathnerd314> @type const id
19:40:10 <lambdabot> forall a b. b -> a -> a
19:40:13 <kmc> seq isn't *that* magic, in that you can write it for individual types yourself
19:40:17 <applicative> thats where I saw it
19:40:18 <Cale> That is, seq x y is semantically equivalent to y, unless x doesn't terminate, in which case, it's equivalent to x
19:40:18 <kmc> seqBool True x = x; seqBool False x = x
19:40:24 <ManateeLazyCat> applicative: Thanks, i will.
19:40:29 <Draconx|Laptop> kmc, for *some* individual types.
19:40:42 <kmc> right
19:40:46 <kmc> seq works on abstract types
19:40:48 <Mathnerd314> so seq != const id?
19:40:48 <Cale> It's the function types for which it's a bit magic
19:40:53 <Cale> and other abstract types
19:40:59 <Cale> Mathnerd314: right
19:41:02 <Mathnerd314> @djinn b -> a -> a
19:41:02 <lambdabot> f _ a = a
19:41:13 <Cale> Mathnerd314: It's a magical function which is different from const id
19:41:14 <lispy|web> ?pl f _ a = a
19:41:14 <lambdabot> f = const id
19:41:26 <Mathnerd314> The type system is missing!
19:41:28 <ezyang> Is there a functional equivalent of a splay tree?
19:41:35 <Cale> Mathnerd314: and mildly controversial in that it breaks parametricity a little bit
19:41:51 <Cale> Mathnerd314: But not too badly, it's possible to cope :)
19:42:03 <Mathnerd314> Cale: so are there any other seq-like functions I should watch out for?
19:42:10 <hasenov> ok, so evaluation is pure, and execution is impure, whereas in impure languages evaluating at different times gives different results and in pure languages evaluating it gives one result..
19:42:10 <Darkone> Cale, where do you suggest I look for monad info, given that I missed half the discussion? Skip to it in RWH?
19:42:19 <lispy|web> Well, we could imagine that all data types have deriving (Seq).  Would it break paramaticity then?
19:42:27 <Cale> Mathnerd314: Well, there's pseq (which is very much like seq, except a little more operationally specified)
19:42:36 <Cale> and there's par
19:42:58 <Cale> evaluating (par x y) will put x in a queue of things to be evaluated on some processor if there's time before resulting in y
19:43:08 <Cale> and (par x y) is semantically equivalent to y
19:43:17 <Sgeo> What happens if you use two operators of the same precedence and opposite um, fixity?
19:43:27 <Draconx|Laptop> A parse error.
19:43:49 <SamB_XP> > (a =<< b >>= c)
19:43:50 <lambdabot>   Precedence parsing error
19:43:50 <lambdabot>      cannot mix `Control.Monad.=<<' [infixr 1] and...
19:43:52 <Cale> Darkone: http://www.haskell.org/haskellwiki/Monads_as_Computation and http://www.haskell.org/haskellwiki/Monads_as_Containers
19:43:58 <SamB_XP> Sgeo: like that!
19:44:02 <Cale> Darkone: are my tutorials. They link to some other ones too
19:44:07 <Darkone> Ahh, kay.
19:44:10 <Darkone> Thankyou
19:44:44 <Cale> Darkone: But it's really better to go and make sure you understand about typeclasses and such too
19:44:45 <Darkone> Cale, which do you suggest first?
19:45:04 <Darkone> Yes, unless you mean something deeper, typeclasses were covered in LYaH :P
19:45:07 <Cale> Well, they're two different approaches, but the Computation one is more traditional.
19:45:13 <Cale> ah, okay
19:45:14 <SamB_XP> Darkone: buy another screen and read them both at the same time ;-P
19:45:19 <Cale> haha
19:45:24 <Mathnerd314> so when do you use typeclasses and *not* feel like you're doing something wrong?
19:45:31 * SamB_XP wishes he had another screen
19:45:41 <Cale> Mathnerd314: Well...
19:45:52 <Darkone> I actually have another screen, and the capability for dual screen output.
19:45:53 <Cale> Mathnerd314: If you have a general interface which has lots of implementations
19:45:58 <Darkone> Unfortunately, the other screen is AWEFUL.
19:46:15 <Cale> Mathnerd314: and you want to be able to write functions which work on all of the types implementing that interface
19:46:17 <Darkone> And my current one is hardly in any better condition.
19:46:17 <Darkone> 19" 1440x900 >.<
19:46:33 <Mathnerd314> Cale: ah, the old "my program is too big to write correctly"
19:46:37 <Mathnerd314> ;-)
19:46:40 <Darkone> Ewwww horrible pixel density :(
19:46:47 <Cale> If you only have one implementation in your program, don't bother with a typeclass, it'll just make things more complicated senselessly.
19:47:12 <Cale> But look at the examples of typeclasses in the Prelude and such
19:47:21 <Cale> Things like Eq and Ord and Num
19:47:35 <kmc> beginners sometimes overuse typeclasses
19:47:50 <kmc> in many OO languages (that is, the bad ones) you need to declare a new type to get a new behavior
19:47:59 <SamB_XP> yeah, it helps to save designing a typeclass until you have two types that you think should be instances
19:48:06 <kmc> and to replicate that in Haskell you might declare a new type and a typeclass instance
19:48:07 <Cale> yeah, there's a bit of a temptation to go ahead and define the most general interfaces you can possibly imagine and then write only one instance ;)
19:48:21 <kmc> but in Haskell you can define new behaviors in a much more direct way
19:48:33 <kmc> because behavior means "function" or "action", and those are first-class values
19:48:44 <Cale> another thing that people forget about is traditional functional programming
19:48:45 <kmc> so often what you want is just a record or other datastructure filled with functions or actions
19:48:58 <Cale> You can pass functions around, and group them into records
19:49:07 <Cale> There's something to be said for doing that sometimes too :)
19:49:13 <Cale> yeah
19:49:26 <Mathnerd314> hmmm... there must be some way to do that for Show/Read :-)
19:49:26 <SamB_XP> @src Q
19:49:26 <lambdabot> Source not found. Where did you learn to type?
19:49:31 <SamB_XP> @hoogle Q
19:49:31 <lambdabot> Language.Haskell.TH data Q a
19:49:31 <lambdabot> Language.Haskell.TH.Syntax data Q a
19:49:31 <lambdabot> Language.Haskell.Lexer QConId :: (String, String) -> Token
19:49:40 <kmc> in fact every typeclass can be translated mechanically into a record type
19:49:44 <kmc> and every instance into a record value
19:49:47 <SamB_XP> @docs Language.Haskell.TH
19:49:47 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/template-haskell/Language-Haskell-TH.html
19:49:51 <kmc> and every typeclass constraint on a function into a simple argument
19:49:59 <kmc> and in fact this is how GHC implements typeclasses
19:50:10 <Mathnerd314> right, I've heard that before, besides the last part
19:50:43 <SamB_XP> of course, I'm not sure there's an extension yet that would allow you to write the types of these records!
19:51:01 <Veinor> why does Text.XHTML produce stuff with newlines in the middle of tags? O_o
19:51:06 <Veinor> so it looks like <head
19:51:07 <Veinor> >
19:51:15 <SamB_XP> Veinor: because that's the safe place to put 'em
19:51:28 <SamB_XP> if it puts them anywhere else, they might get interpreted as content
19:51:34 <Veinor> ... true
19:51:35 <SamB_XP> depending on the DTD
19:51:38 <Veinor> and you do want newlines
19:51:48 <Mathnerd314> SamB_XP: what is the Q monad? o_O
19:52:17 <SamB_XP> http://haskell.org/ghc/docs/latest/html/libraries/template-haskell/src/Language-Haskell-TH-Syntax.html#Q
19:52:22 <Veinor> hey, it didn't output valid XHTML 1.0 Transitional!
19:52:25 <SamB_XP> it's a little gem, that looks like this:
19:52:31 <SamB_XP> newtype Q a = Q { unQ :: forall m. Quasi m => m a }
19:52:36 <Mathnerd314> so many Q's...
19:53:17 <SamB_XP> it's the free Quasi, actually
19:53:20 <lispy|web> Veinor: one thing you should know about programs compiled with ghc is that they all respond to +RTS options, even cgi programs.  This can be exploited to have the RTS overwrite files that the cgi process has permissions to access.
19:53:35 * SamB_XP waits for Cale to explain what the free Foo is ;-)
19:53:55 <Veinor> lispy|web: how could a script pass +RTS options though?
19:54:03 <Saizan> SamB_XP: it's the church encoding of a free Quasi :)
19:54:05 <lispy|web> Veinor: from the URL
19:54:18 <SamB_XP> Saizan: hmm ?
19:54:20 <Saizan> but they are isomorphic, so..
19:54:29 <lispy|web> Veinor: http://blah/cgi-bin/yourapp+RTS... (or whatever the syntax is)
19:54:35 <SamB_XP> lispy|web: how would they hit the command line ?
19:54:46 <SamB_XP> isn't that stuff in the HTTP_ vars ?
19:54:55 <SamB_XP> or possibly CGI_ vars
19:54:55 <lispy|web> +RTS -s/etc/passwd
19:54:57 <SamB_XP> I'm not sure
19:55:19 <lispy|web> They recently fixed this, but I don't think a stable GHC release has been made yet
19:55:50 <SamB_XP> fixed it in what way ?
19:55:51 <teurastaja> is haskell too hard for a non-mathematician? i know haskell is hard to learn so i want to convince myself its rewarding enough before even trying. id like to know the benefits of embarking that journ
19:55:52 <Saizan> SamB_XP: the most common presentation for free structures looks like a term algebra, while Q a above is the church encoding of that
19:56:08 <SamB_XP> Saizan: ah
19:56:16 <lispy|web> SamB_XP: by making it so that you have to ask for +RTS/-RTS at compile time, otherwise the rts won't respond to it
19:56:25 <Cale> The free Foo? It's just the left adjoint to the forgetful Foo.
19:56:30 <SamB_XP> lispy: have to ASK?!?!?!?!
19:56:33 <Axman6> teurastaja: haskell's easy
19:56:36 <Veinor> lispy|web: ... that will pass it? O_o
19:56:37 <Jafet> teurastaja, programming is hard if you have no idea of mathematics
19:56:39 <SamB_XP> that sounds crazy
19:56:39 <Veinor> how bizarre
19:56:51 <Veinor> SamB_XP: so presumably you'll say --enable-rts
19:56:53 <Cale> @where lyah
19:56:54 <lambdabot> http://www.learnyouahaskell.com/
19:56:54 <lispy|web> I should find the ticket
19:56:57 <Cale> teurastaja: ^^
19:57:01 <SamB_XP> how was this making it on the command line in the FIRST plcae ?
19:57:04 <Veinor> lispy|web: how do I stop them from doing this?
19:57:24 <Cale> teurastaja: It's no harder than your first programming language :)
19:57:36 <lispy|web> Veinor: stop whom?
19:57:41 <Veinor> I mean
19:57:54 <shepheb> FastCGI is my favourite solution
19:57:59 <Veinor> how can I stop Mallory from passing malicious RTSs?
19:58:02 <Saizan> Cale: i was trying to figure out why that's a sensible definition, i.e. how it captures the intuition that the free Foo is the one with no additional properties
19:58:17 <lispy|web> http://hackage.haskell.org/trac/ghc/ticket/3910#comment:1
19:58:39 <teurastaja> monads are directly from category theory i just thought it was a bot
19:58:41 <lispy|web> Veinor: Well, I think apache can forbid the bad URLs
19:58:44 <teurastaja> *a bit tough
19:58:50 <lispy|web> Veinor: but I don't know the apache config necessary
19:59:32 <shepheb> doesn't CGI use the QUERY_STRING env var, not the first argument?
19:59:33 <SamB_XP> oooh, I love the IESG note at the top of RFC 3875
19:59:36 <Saizan> teurastaja: for a programmer, Monad is just a new interface with lots of useful instances
19:59:38 <Veinor> ugh.
20:00:06 <lispy|web> Maybe I'm wrong about the CGI aspect
20:00:13 <lispy|web> But, I thought that was part of the original report
20:00:18 <Jafet> teurastaja, there are many useful ways to think about Haskell Monads
20:00:29 <Jafet> @quote invisible
20:00:29 <lambdabot> kmc says: a monad is like an invisible train filled with jello traveling backwards in time
20:00:31 <Veinor> looks like it says it was fixed in... 6.12.1?
20:01:14 <Cale> teurastaja: You don't really have to understand what monads are in the context of category theory to understand what they mean in the context of Haskell (even though you eventually might be enticed into learning some category theory and understanding it)
20:01:21 <Veinor> still rather funny given how secure stuff's supposed to be due to the IO monad >_>
20:01:50 <teurastaja> uh... is a monad a sort of pipe accumulator?
20:02:03 <SamB_XP> SCRIPT_NAME, PATH_INFO and QUERY_STRING
20:02:08 <pastorn> teurastaja: it's just a typeclass that happends to give you do-notation
20:02:13 <lispy|web> Veinor: it was reported against 6.12.1, IIUIC
20:02:18 <Veinor> ah
20:02:34 <pastorn> teurastaja: because otherwise the do-notation would be only available for IO
20:02:37 <Cale> teurastaja: A monad is a type constructor together with an implementation of a couple functions, called return and (>>=), which have particular types, and are expected to interact in a particular way
20:02:56 <Cale> teurastaja: But basically, it's just a common sort of API which shows up in a lot of different libraries
20:03:00 <pastorn> teurastaja: too many cooks?
20:03:07 <lispy|web> Veinor: I'm really wondering about the CGI case. Maybe I mispoke
20:03:10 <teurastaja> cooks?
20:03:14 <Veinor> what is a monad? a miserable little pile of secrets! but enough of this talk, have at you!
20:03:17 <Veinor> wait
20:03:18 <lispy|web> Veinor: I can't find the email that I read about it in
20:03:31 <Cale> teurastaja: and there are lots of useful things we can write in terms of this return and >>= function which will work with an arbitrary monad
20:03:36 <pastorn> teurastaja: forty people explaining the same thing in different words, at the same time
20:03:37 <Veinor> well, in any case they'd only be able to scribble over my own stuff
20:03:48 <Cale> teurastaja: so to avoid rewriting similar code over and over, we abstract it out
20:03:53 <SamB_XP> oh shit
20:04:00 <SamB_XP> Section 4.4 is our issue, I think
20:04:00 <pastorn> SamB_XP: WAT!?
20:04:14 <Cale> teurastaja: I suppose I can try to explain what exactly monads are in more detail
20:04:19 <applicative> teurastaja, if you are only beginning to learn Haskell, don't let them talk to you about monads
20:04:26 <Veinor> the httpd for this hosting service has some awesome configuration to limit risks in case someone writes a sploitable script
20:04:27 <applicative> ask them about fmap
20:04:39 <pastorn> teurastaja: fmap is AWESOME
20:04:44 <Mathnerd314> @type fmap
20:04:45 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:04:50 <Mathnerd314> nothing to it
20:04:51 <Cale> But yeah, since you're an absolute begnner, it's probably better to wait until you understand the basics of the language and the type system
20:04:55 <Veinor> fmap is one of my favorite functions in Haskell
20:04:57 <teurastaja> uh... who do i answer to?
20:04:58 <SamB_XP> http://tools.ietf.org/html/rfc3875#section-4.4
20:04:59 <pastorn> > fmap (+ 1) [1,2,3] -- teurastaja
20:05:01 <lambdabot>   [2,3,4]
20:05:02 <applicative> > fmap even [1..10]
20:05:03 <lambdabot>   [False,True,False,True,False,True,False,True,False,True]
20:05:15 <pastorn> teurastaja: noone :)
20:05:17 <applicative> > fmap even ("Hahaha",2)
20:05:19 <lambdabot>   ("Hahaha",True)
20:05:29 <Saizan> all this excitement about fmap feels quite kinky.
20:05:30 <Mathnerd314> @src [] fmap
20:05:31 <lambdabot> fmap = map
20:05:34 <Mathnerd314> @src map
20:05:34 <lambdabot> map _ []     = []
20:05:34 <Cale> > fmap even (Just 5)
20:05:34 <lambdabot> map f (x:xs) = f x : map f xs
20:05:35 <lambdabot>   Just False
20:05:37 <pastorn> applicative: dud, how did you do that?
20:05:38 <maxsu> note that fmap f X = map f X if X is a list
20:05:41 <pastorn> *dude*
20:05:50 <lispy|web> Veinor: even better, use SELinux
20:05:53 <applicative> > fmap even (Just 3)
20:05:53 <lambdabot>   Just False
20:06:00 <teurastaja> yes id like to know more about the real category theory way cale
20:06:11 <aavogt> pastorn: there's a Functor instance for tuples
20:06:14 <Cale> teurastaja: what's your mathematical background like?
20:06:18 <Jafet> @remember applicative if you are only beginning to learn Haskell, don't let them talk to you about monads. ask them about fmap
20:06:18 <lambdabot> It is forever etched in my memory.
20:06:31 <turiya> hi
20:06:32 <applicative> what other functor instances to we have available with lambdabot
20:06:45 <dancor> > fmap (+ 1) (1000, 3)
20:06:46 <lambdabot>   (1000,4)
20:06:48 <aavogt> functions
20:06:53 <Jafet> @instances Functor
20:06:56 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
20:06:57 <Cale> teurastaja: I'll do a bisective search :) Do you know what functors are?
20:07:01 <aavogt> > fmap (+1) (*2) $ 1
20:07:02 <lispy|web> :t fmap even
20:07:02 <lambdabot>   3
20:07:03 <lambdabot> forall a (f :: * -> *). (Integral a, Functor f) => f a -> f Bool
20:07:06 <teurastaja> i just dont get what is going on
20:07:06 <ddarius> The "real category theory" way has not too much to do with Haskell, particularly how Haskell is used commonly.
20:07:15 <pastorn> > fmap (+1) ("hello",2)
20:07:16 <lambdabot>   ("hello",3)
20:07:16 <SamB_XP> Veinor: did you see the RFC link above ?
20:07:17 <maxsu> @type (flip fmap) ("puppy", 0)
20:07:18 <lambdabot> forall a b. (Num a) => (a -> b) -> ([Char], b)
20:07:21 <SamB_XP> that's our issue, I believe
20:07:22 <pastorn> > fmap (+1) (2,2)
20:07:23 <lambdabot>   (2,3)
20:07:26 <Cale> teurastaja: Yeah, this channel can be a bit noisy... come to #haskell-overflow perhaps
20:07:28 <applicative> teurastaja: don't ask them about functors either, ask them about fmap
20:07:46 <Cale> applicative: He wants to understand the categorical foundation, so...
20:07:49 <maxsu> @type (flip fmap) (0, "kitteh")
20:07:50 <lambdabot> forall b t. (Num t) => ([Char] -> b) -> (t, b)
20:07:52 <teurastaja> i think i know what functors r
20:07:54 <Axman6> we have a haskell-overflow?
20:08:04 <lispy|web> Since when is "hello" + 1 = "hello".  Seems like I'm missing something
20:08:21 <lispy|web> hmm
20:08:30 <applicative> No better way to  learn the categorical foundations than finger exercises with fmap
20:08:36 <lispy|web> :t \f -> fmap f (?a,?b)
20:08:37 <Axman6> @src (,) fmap
20:08:37 <lambdabot> fmap f (x,y) = (x, f y)
20:08:37 <lambdabot> forall a b t. (?a::t, ?b::a) => (a -> b) -> (t, b)
20:08:37 <applicative> and a few similar 'combinators'
20:08:41 <Cale> teurastaja: okay, so if we have two categories C and D, a functor F: C -> D assigns to each object X in C an object FX in D, and to each arrow a: X -> Y in C, an arrow Fa: FX -> FY in D.
20:08:41 <dancor> lispy|web: fmap f (a, b) = (a, f b)
20:08:47 <kmc> <teurastaja> uh... is a monad a sort of pipe accumulator? <-- no, it's totally a burrito!
20:08:48 <kmc> @where burrito
20:08:48 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
20:09:05 <Jafet> Mmm, burrito
20:09:06 <Cale> teurastaja: satisfying the laws that F(a.b) = (Fa) . (Fb), and F(id_X) = id_(FX)
20:09:08 <Cale> yeah?
20:09:17 <applicative> kmc, '@where burrito' is cruelty to poor kowey
20:09:20 <Veinor> SamB_XP: tools.ietf.org is acting up for me
20:09:31 <Cale> teurastaja: Is that familiar?
20:09:37 <lispy|web> applicative: to kowey?
20:09:39 <maxsu>  @type (flip fmap) (0, "kitteh", False)
20:09:46 <lispy|web> applicative: you mean byorgey?
20:09:48 <teurastaja> nope lol
20:10:01 <SamB_XP> Veinor: well, I suggest you try another provider of RFCs and locate section 4.4 yourself, then ;-)
20:10:01 <Cale> teurastaja: Okay, this is from the pure mathematics, and not the programming side of things
20:10:16 <Cale> teurastaja: How about a category?
20:10:19 <applicative> byorgey attacks monad tutorials (rightly) kowey is the author of the infamous burrito tutorial
20:10:35 <Veinor> ahh
20:10:37 <lispy|web> applicative: oh, heh he is?
20:10:40 <Cale> (the technical term, not the English word ;)
20:10:42 <maxsu> applicative: was it better than the space suite tutorial?
20:10:43 <teurastaja> what do u mean by how about a category?
20:10:45 <SamB_XP> applicative: oh, there is actually a burrito tutorial?
20:10:55 <Cale> I mean, do you know the definition from mathematics :)
20:11:10 <SamB_XP> I thought that was made up and/or written AFTER the blog entry in question
20:11:14 <applicative> i think there is an actual burrito tutorial, though I have only seen kowey publically disowning it
20:11:26 <Cale> The definition of a monad from mathematics is part of category theory, so if you want to understand things from that direction, it's important to know the basic definitions
20:11:26 <kmc> teurastaja, your original question was about whether Haskell would be rewarding to learn for a non-mathematician
20:11:29 <applicative> 'as the author of the infamous burrito tutorial'....
20:11:46 <kmc> teurastaja, the current conversation seems totally contrary to answering that question and i'd like to verify that you recognize that ;)
20:11:54 <applicative> @faq v
20:11:54 <lambdabot> The answer is: Yes! Haskell can do that.
20:11:56 <ddarius> Kowey wrote the spacesuit "tutorial"
20:11:59 <teurastaja> if i describe it as being a sort of structure will i get wiped?
20:12:00 <Mathnerd314> applicative: http://blog.plover.com/prog/burritos.html
20:12:07 <kmc> if you want to know category theory, go ahead, but it's not got much to do with how to write Haskell code
20:12:10 <Cale> Yes, this is all completely excessive if you just want to use monads to program.
20:12:10 <applicative> oh, i'm getting my monad tutorial history wrong!
20:12:11 <applicative> sorry
20:12:13 <Veinor> SamB_XP: I'm trying to see if I can replicate this
20:12:19 <lispy|web> applicative: I can't seem to find it on kowey's blog
20:13:05 <lispy|web> I didn't really think it was something kowey would have written.  I talk to him regularly so I expected I would have recognized his name on it
20:13:17 <Jafet> The history of monad tutorials is fraught with poor returns and categorial errors
20:13:24 <lispy|web> heh
20:13:25 <kmc> categorical fail, more like
20:13:30 * kmc rimshot
20:14:10 <teurastaja> kmc im not a mathematician but i try to learn on my own even though i suck
20:15:14 <ddarius> lispy|web: http://koweycode.blogspot.com/2006/04/monad-tutorial-slow-darcs.html
20:15:43 <kmc> teurastaja, to learn math?
20:15:45 <kmc> or to learn Haskell?
20:16:20 <ddarius> lispy|web: His original rendition was on an older blog of his that I don't think is available anymore.
20:16:39 <applicative> i'm so disappointed that there was no actual burrito tutorial
20:17:03 <lispy|web> ddarius: ah.  That is definitely kowey's writing
20:17:11 <ddarius> Ah, no.  Here we go: http://koweycode.blogspot.com/2007/01/think-of-monad.html
20:17:16 <lispy|web> You can tell by the apologetic voice that dances around
20:17:39 <applicative> http://en.wikibooks.org/wiki/Talk:Haskell/Understanding_monads/Nuclear_waste
20:18:22 <lispy|web> hah, "What is the half-life of the StateT monad?"
20:18:31 <Veinor> SamB_XP, lispy|web
20:18:33 <SamB_XP> heh, this looks funny: http://byorgey.wordpress.com/2009/01/30/fad-diets-are-like-burrito-tutorials/
20:18:36 <Veinor> even though you can do this, you can't get to the RTS
20:18:39 <Veinor> because it splits on +
20:18:50 <SamB_XP> Veinor: url-escape a + ?
20:18:52 <lispy|web> Veinor: but, you can encode + I think
20:18:57 <Veinor> ooh
20:20:09 <Veinor> oh yeah
20:20:09 <kmc> @quote explanation
20:20:10 <lambdabot> dmwit says: analogies are endofunctors in the category of bad explanations
20:20:12 <Veinor> %2B
20:20:27 <applicative> the remark of "Mitch" on the fad diet post is great Ah, now it makes sense. Since I started learning Haskell I?ve been struggling to understand intuitively what a ?monad tutorial? is, and this metaphor really made it click for me. Thanks!
20:20:34 <kmc> hahaha
20:20:45 <Sgeo> SamB_XP, the comments are better
20:20:58 <Sgeo> Oh, applicative has those covered
20:21:07 <Veinor> hm
20:21:10 <Veinor> I still can't get the RTS to trigger
20:21:13 <SamB_XP> Sgeo: I was just seeing the blurb from the byorgy post
20:22:53 <Sgeo> Monads are like THINGS. Things can be combined with functions that return things, and the method used to do so is defined by the type of thing. The function that takes a .. not a thing and returns a thing may be utilized any number of times
20:23:10 <Sgeo> When combined with the thing, and the combination is, itself, a thing
20:23:32 <SamB_XP> @google "strings to lists of"
20:23:34 <lambdabot> http://www.math.uiuc.edu/Macaulay2/doc/Macaulay2-1.3.1/share/doc/Macaulay2/Macaulay2Doc/html/_strings_spand_spnets.html
20:23:34 <lambdabot> Title: strings and nets
20:23:37 <Veinor> haha, I just told my haskell script to scribble over itself
20:23:47 <SamB_XP> @google "a parser's a function from strings to lists of"
20:23:48 <lambdabot> No Result Found.
20:24:00 <SamB_XP> @google a parser's a function from strings to lists of
20:24:01 <lambdabot> http://jonathan.tang.name/files/scheme_in_48/tutorial/parser.html
20:24:02 <lambdabot> Title: Write Yourself a Scheme in 48 hours
20:24:08 <SamB_XP> @google a parser's a function from strings to lists of suess
20:24:09 <lambdabot> http://books.google.com/books?id=olp7lAtpRX0C&pg=PA75&lpg=PA75&dq=a+parser's+a+function+from+strings+to+lists+of+suess&source=bl&ots=IvLWlt0E6Z&sig=QtNJC1vt2kxtWPBv0eQ62bE8r_w
20:24:09 <lambdabot> Title: Programming in Haskell - Google Books
20:24:14 <SamB_XP> arg
20:24:14 <Jafet> Sgeo, nice. You've just created a monad tutorial template
20:24:38 <Jafet> Sgeo, no doubt this will revitalize the health of monad tutorialogy around the world
20:24:55 <SamB_XP> Jafet: just when we thought we'd killed it off!
20:25:45 <lispy|web> Veinor: and it worked?
20:26:06 <kmc> so i used to hang out here a bit in, like, 2006
20:26:10 <Jafet> Any enemy of the monad tutorial will be bound purely, never to return, and force fed burritos of radioactive waste
20:26:11 <kmc> and then took a long break
20:26:24 <kmc> and i noticed a few new community memes that weren't there before
20:26:28 <kmc> which made me very happy
20:26:35 <kmc> one being identifying the burrito problem with monad tutorials
20:26:43 <kmc> another being "Haskell is the world's best imperative language"
20:26:56 * Sgeo heard that on a Python wiki
20:26:57 <kmc> i remember the attitude before being more anti-IO
20:27:20 <SamB_XP> oh, I'm not sure I like to write my imperative programs using IO anyways
20:27:38 <SamB_XP> that's one of the things that makes Haskell the world's best!
20:27:43 <SamB_XP> I don't have to!
20:27:54 <Veinor> lispy|web: hm
20:27:56 <kmc> hmm
20:28:00 <Veinor> I wasn't able to scribble over the file itself
20:28:05 <kmc> you mean by building your own problem descriptions and then executing them?
20:28:08 <kmc> that's a nice technique
20:28:13 <lispy|web> Veinor: but, you can get the RTS to respond to options?
20:28:18 <Veinor> yeah
20:28:22 <kmc> though you risk a sort of inner-platform effect against the IO monad itself
20:28:23 <Veinor> I was able to get it to overwrite a file
20:28:30 <Veinor> via +RTS -t -RTS
20:28:35 <Mathnerd314> s/thing/monad/, and you've got an explanation
20:28:51 <Mathnerd314> from way above, when I wasn't paying attention
20:28:52 <Veinor> and there's no way to disable the RTS, is there?
20:28:57 <kmc> ha
20:29:04 <kmc> only if you want your program not to run
20:29:06 <lispy|web> Veinor: right, unless you have that patch in the ticket I linked
20:29:10 <Veinor> right
20:29:16 <Veinor> kmc: disable RTS arguments, I mean
20:29:20 <kmc> oh haha
20:29:25 <lispy|web> Veinor: but you could have your webserver deal with it
20:29:35 <Veinor> I don't own the server
20:29:38 <kmc> well, you can write your own main() in C and munge over argv before you invoke any haskell code
20:29:52 <lispy|web> Veinor: But, you could use .htaccess to deal with it, AFAIK
20:29:53 <Veinor> I still want to know why people didn't catch this sooner >_>
20:30:13 <lispy|web> Veinor: that's a valid complaint.
20:30:17 <lispy|web> Veinor: I don't know why not.
20:30:24 <turiya> i am having trouble understanding the value defaultHints in Network.Socket
20:30:30 <applicative> teurastaja	, have they scared you off yet?
20:30:47 <turiya> does any body know what it is
20:30:49 <applicative> > fmap (fmap even) ("Hahaha",[2,3,4])
20:30:50 <lambdabot>   ("Hahaha",[True,False,True])
20:30:50 <kmc> turiya, it has type AddrInfo
20:30:54 <kmc> AddrInfo is a record
20:31:01 <SamB_XP> Veinor: because most people have better things to do than know all the intracacies of how CGI works ?
20:31:02 <applicative> > fmap (fmap even) [("Hahaha",2),("Hohoho",3),("Hehehehe",4)]
20:31:03 <lambdabot>   [("Hahaha",True),("Hohoho",False),("Hehehehe",True)]
20:31:10 <kmc> turiya, you can use record update syntax to override some defaults
20:31:21 <Veinor> okay
20:31:26 <dancor> hm haskell-src-meta seems to be a mess under 6.12.1
20:31:26 <kmc> turiya, are you clear on what the AddrInfo type does?
20:31:27 <Veinor> if you pass -- as the first argument
20:31:35 <Veinor> then it treats all +RTS-y stuff as normal arguments
20:31:41 * Sgeo should go eat now, and stuff
20:31:49 <Veinor> and so will therefore silently discard them
20:31:50 * Sgeo could eat a monad right now]
20:31:50 <lispy|web> Veinor: so write a wrapper that does that?
20:31:57 <turiya> kmc, i am not sure what this definition means http://hackage.haskell.org/packages/archive/network/2.2.1.7/doc/html/src/Network-Socket.html#defaultHints
20:31:59 <Veinor> but I don't want to have to do that!
20:32:04 <Veinor> :P
20:32:07 <kmc> turiya, syntactically?
20:32:21 <kmc> it's constructing a record
20:32:22 <lispy|web> Veinor: just write the wrapper in like 1 line of perl or shell and be done with it :)
20:32:23 <aavogt> dancor: http://moonpatio.com/repos/haskell-src-meta_NEW_TH/
20:32:29 <turiya> i can understand that defaultHints is of type AddrInfo
20:32:36 <dancor> aavogt: ty
20:32:43 <applicative> >  (even <$>) <$> [("Hahaha",2),("Hohoho",3),("Hehehehe",4)]
20:32:43 <kmc> it's equivalent to just:  AddrInfo [] AF_UNSPEC NoSocketType defaultProtocol undefined undefined
20:32:44 <lambdabot>   [("Hahaha",True),("Hohoho",False),("Hehehehe",True)]
20:32:48 <turiya> but after that .. whatever code is there.. i cant understand it
20:32:51 <aavogt> I dunno why that one has not been uploaded to hackage yet
20:32:58 <kmc> turiya, you should read about the syntax of Haskell's records
20:33:02 <kmc> it's basically sugar
20:33:13 <kmc> and not great sugar at that
20:33:15 <turiya> i read abt it in realworldhaskell
20:33:23 <lispy|web> Veinor: good luck, I'm going to crash.
20:33:25 <kmc> this is the record construction syntax
20:33:25 <aavogt> yes. it's all sugar
20:33:28 <turiya> the addrFlags is a function right
20:33:32 <Sgeo> So applicative's line maps (even <$>) over that list
20:33:38 <kmc> turiya, within the { } they are just names
20:33:41 <aavogt> you should be using unlambda already
20:33:43 <kmc> that's part of the confusingness
20:33:45 <Sgeo> How are tuples functors?
20:34:04 <aavogt> Sgeo: leave out the last element of the tuple
20:34:07 <BMeph> Sgeo: Clumsily. ;)
20:34:10 <aavogt> @type (1,2,)
20:34:11 <lambdabot> parse error on input `)'
20:34:15 <aavogt> @type \x -> (1,2,x)
20:34:16 <turiya> rwh says they are functions
20:34:16 <lambdabot> forall t t1 t2. (Num t, Num t1) => t2 -> (t, t1, t2)
20:34:41 <kmc> turiya, sure.  outside of special record syntax
20:34:46 <Sgeo> Well, now I need to learn how functions are functors
20:34:49 <kmc> inside they are just names
20:34:51 <aavogt> then you have the appropriate kind to be an instance of Functor
20:35:05 <turiya> kmc, also my main problem is how can you set a [] to addrFlags?
20:35:10 <applicative> tuples are not functors
20:35:20 <kmc> turiya, the addrFlags field of an AddrInfo structure has type [AddrInfoFlag]
20:35:24 <applicative> (String, _) is a functor
20:35:29 <Sgeo> applicative, so then how could you map (even <$>)... ah
20:35:34 <kmc> it's not "setting" anything.  it's just a way to provide names for the arguments to a constructor
20:35:46 <aavogt> Sgeo: well that's kind of inaccurate to say that because it's a function you can make it an instance of Functor...
20:35:47 <kmc> it doesn't affect the global definition of addrFlags
20:35:50 <kmc> which is a function as you said
20:35:58 <applicative> yes map is <$> restricted to lists
20:36:19 <Sgeo> :info <$>
20:36:25 <Sgeo> What's <$>'s fixity?
20:36:32 <aavogt> infixl 4
20:36:41 <kmc> > succ <$> [1,2,3]
20:36:43 <lambdabot>   [2,3,4]
20:36:54 <Sgeo> So (a <$> b) <$> c, right?
20:36:57 <applicative> so since it was a list  [("Hahaha",2),("Hohoho",3),("Hehehehe",4)], we can write
20:36:59 <aavogt> yes
20:37:11 <applicative> >  map (even <$>) [("Hahaha",2),("Hohoho",3),("Hehehehe",4)]
20:37:12 <lambdabot>   [("Hahaha",True),("Hohoho",False),("Hehehehe",True)]
20:37:19 <Sgeo> applicative, I get that part
20:37:30 <aavogt> but it's more sensible to remember that   f . g <$> x . y  =  (f . g) <$> (x . y)
20:37:42 <aavogt> or whatever other functions you use with <$>
20:37:56 <applicative> but of course not       map (map even)  [("Hahaha",2),("Hohoho",3),("Hehehehe",4)]
20:38:06 * Sgeo has issues with parenthesization sometimes
20:38:21 <Sgeo> Maybe I should switch to a Lisp, where there are no needless parentheses
20:38:25 <kmc> haha
20:38:46 <Sgeo> Every ( is sacred
20:38:51 <aavogt> no, you can still have excess parentheses there
20:38:57 <Sgeo> Every ) is great
20:39:07 <aavogt> (+ (+ 1 2) (+ 3 4))  vs.   (+ 1 2 3 4)
20:39:10 <Veinor> blaaaah, this sucks
20:39:10 <applicative> Sgeo, if you are just learning, I totally recommend running everything through the hlint program,
20:39:29 <kmc> aavogt, ah, but what if i monkeypatch (+) to count how many times it's applied? ;)
20:39:36 * aavogt is assuming these numbers are sensible
20:39:41 <Sgeo> applicative, I've been _reading_ about Haskell for some time, but only starting to write it now
20:39:43 <applicative> i find it hard to get infix levels straight, but Hlint cures you for each thing you actually use
20:39:44 <lispy|web> Veinor: you could just ignore it for now.  It's not really a serious exploit at the moment.
20:39:49 <Jafet> Make + syntax
20:39:55 <Sgeo> So yeah, I should get hlint
20:40:01 <Veinor> lispy|web: it lets people scribble over whatever file you have write bits to
20:40:04 <scutigera> :t (<$>)
20:40:05 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:40:06 <lispy|web> Veinor: the attacker has to know you used haskell and then they have to be creative about it to figure out how to attack you
20:40:14 <applicative> there is a temptation to write way too many parentheses -- which is okay
20:40:28 <Sgeo> Wait, what exploit?
20:40:41 <aavogt> there is a temptation to write too few, but you get rejected ;)
20:40:50 <Veinor> Sgeo: haskell's RTS has the ability to output profiling data to a file
20:40:51 <Jafet> Hm, can you write haskell programs without parentheses?
20:41:00 <Veinor> you can pass command-line arguments to a CGI script
20:41:10 <Veinor> therefore, a haskell CGI script can scribble over files
20:41:48 <lispy|web> Sgeo: the problem is that you cannot disable the handling of +RTS/-RTS for your haskell programs (but this is fixed in GHC HEAD)
20:42:02 <lispy|web> anyway, I'm out
20:44:00 * Veinor flails
20:44:11 <aavogt> is hlint pronounced with one sylable?
20:45:20 <SamB_XP> no, it's pronounced ecchi-lint
20:45:27 <SamB_XP> ;-P
20:45:47 <Jafet> Mmm, ecchi
20:46:00 * SamB_XP feels the urge to repost http://www.willamette.edu/~fruehr/haskell/seuss.html
20:48:38 <aavogt> escheria-lint
20:48:46 <Sgeo> Dr. Seuss is dead?
20:49:03 <SamB_XP> Sgeo: has been for a while
20:50:14 <fax> he died recently
20:51:09 <SamB_XP> time is relative!
20:51:15 <SamB_XP> you're probably a bit older than I am ;-)
20:51:16 <Sgeo> > arr id
20:51:17 <lambdabot>   No instance for (GHC.Show.Show (a b b))
20:51:17 <lambdabot>    arising from a use of `M72324557...
20:51:28 <SamB_XP> Sgeo: it's not speak like a pirate day is it ?
20:51:38 <alpounet> @type arr id
20:51:39 <lambdabot> forall b (a :: * -> * -> *). (Arrow a) => a b b
20:52:14 <kmc> escherichia lint
20:54:03 * BMeph sings: Your <$> was made to succ my list!
20:55:11 <SamB_XP> ????
20:55:19 <SamB_XP> your song doesn't sound very well-typed
20:58:25 <BMeph> SamB_XP: My list is full of Ints - succ it! ;
20:58:49 <SamB_XP> oh, to succ the ELEMENTS of your list!
20:58:50 <winxordie> Good god! Milner's dead?
20:59:04 <idnar> @type <$> succ
20:59:05 <lambdabot> parse error on input `<$>'
20:59:12 <idnar> @type (succ <$>)
20:59:14 <lambdabot> forall a (f :: * -> *). (Enum a, Functor f) => f a -> f a
20:59:29 <Jafet> winxordie, that doesn't sound like the connivance of a good god
20:59:34 <BMeph> winxordie: About a week-and-a-half now, thx for noticing... :(..
20:59:47 <winxordie> I was on vacation :(
21:00:21 <Gracenotes> okay, I've typed up some thoughts about improving Hackage for SoC 2010
21:00:25 <Jafet> It's okay, you can still give a eulogy.
21:00:55 <BMeph> Hm, more like two-and-a-half weeks, actually. :(
21:00:57 <fax> > 1/sqrt(-1)::Complex Double
21:00:59 <lambdabot>   0.0 :+ (-1.0)
21:01:28 <kmc> Jafet, indeed, he was still working
21:01:28 * Gracenotes sends it off to haskell-cafe
21:01:35 <fax> > sqrt(1/-1)::Complex Double
21:01:36 <lambdabot>   Not in scope: `/-'
21:01:40 <fax> wtf
21:01:43 <fax> haskell sucks
21:01:52 <kmc> haha
21:02:01 <kmc> @faq Does Haskell suck?
21:02:02 <lambdabot> The answer is: Yes! Haskell can do that.
21:02:11 <Cale> haha
21:02:18 <Jafet> @let a/-b = a/(-b)
21:02:19 <lambdabot>  Defined.
21:02:41 <Jafet> > sqrt(1/-1)::Complex Double
21:02:42 <lambdabot>   (-0.0) :+ 1.0
21:02:49 <fax> wizard!!!
21:03:09 <scutigera> :t a/-b
21:03:10 <lambdabot> Expr
21:03:16 <scutigera> :t /-
21:03:17 <lambdabot> parse error on input `/-'
21:03:19 <fax> why does haskell screw with me
21:03:26 <scutigera> :t (/-)
21:03:27 <fax> I ust want to divide by negative one
21:03:27 <lambdabot> forall a. (Fractional a) => a -> a -> a
21:03:31 <kmc> fax, as a test of your faith
21:03:47 <kmc> > 1 / pred 0 :: Complex Double
21:03:48 <lambdabot>   No instance for (GHC.Enum.Enum
21:03:48 <lambdabot>                     (Data.Complex.Complex GH...
21:03:48 <Jafet> Because you don't get it in real life
21:03:51 <ddarius> Dividing by negative one is silly.
21:04:43 <scutigera> real programmers multiply by negative one
21:04:57 <fax> @check \x y -> sqrt(x/y) == sqrt(x)/sqrt(y::Complex Double)
21:04:58 <lambdabot>   No instance for (Test.QuickCheck.Arbitrary
21:04:58 <lambdabot>                     (Data.Comple...
21:05:00 <fax> wnat
21:05:03 <kmc> real programmers use a savagely optimized hand-tuned assembly routine
21:05:05 <fax> @check \x y -> sqrt(x/y) == sqrt(x)/sqrt(y)
21:05:06 <lambdabot>   "Falsifiable, after 0 tests:\n0.0\n0.0\n"
21:05:12 <kmc> real programmers care not for your pitiful "abstraction"
21:05:14 <fax> @check \x y -> y == 0 || sqrt(x/y) == sqrt(x)/sqrt(y)
21:05:15 <lambdabot>   "Falsifiable, after 1 tests:\n3.25\n3.75\n"
21:05:19 <fax> oh my god -_-
21:05:34 <fax> itos not my day
21:06:25 <Veinor> ha ha, floating point math
21:06:28 <Cale> @check \x y -> y == 0 || abs (sqrt(x/y) - sqrt(x)/sqrt(y)) < 0.005
21:06:28 <lambdabot>   "Falsifiable, after 7 tests:\n2.0\n-0.25\n"
21:06:29 <aavogt> @check \x y -> y == 0 || (sqrt(x/y) - sqrt x / sqrt y) < 1e-10
21:06:30 <lambdabot>   "Falsifiable, after 1 tests:\n-1.0\n2.0\n"
21:06:46 <kmc> sqrt (-1.0 / 2.0)
21:06:49 <kmc> > sqrt (-1.0 / 2.0)
21:06:50 <lambdabot>   NaN
21:06:57 <kmc> NaN /= NaN
21:07:06 <kmc> Float is not even partially ordered
21:07:08 <Cale> @check \x y -> x <= 0 || y <= 0 || abs (sqrt(x/y) - sqrt(x)/sqrt(y)) < 0.005
21:07:09 <lambdabot>   "OK, passed 500 tests."
21:07:45 <Cale> @check \x y -> x > 0 && y > 0 ==> abs (sqrt(x/y) - sqrt(x)/sqrt(y)) < 0.005
21:07:46 <lambdabot>   No instance for (Test.QuickCheck.Testable
21:07:46 <lambdabot>                     (Test.QuickCh...
21:07:52 <Cale> er...
21:08:01 <Cale> Not sure why that doesn't work
21:08:07 <aavogt> @type property
21:08:08 <lambdabot>     Ambiguous occurrence `property'
21:08:08 <lambdabot>     It could refer to either `Test.QuickCheck.property', imported from Test.QuickCheck
21:08:08 <lambdabot>                           or `Lava.property', imported from Lava
21:08:23 <Cale> @undefine
21:08:25 <idnar> wait what
21:08:26 <Jafet> flipSign a = unsafeCoerce ((unsafeCoerce a::Word64) `xor` 0x8000000000000000) :: Double
21:08:27 <aavogt> do people use lava here?
21:08:29 <Cale> @type property
21:08:29 <idnar> what the heck is (/-)?
21:08:30 <lambdabot>     Ambiguous occurrence `property'
21:08:30 <lambdabot>     It could refer to either `Test.QuickCheck.property', imported from Test.QuickCheck
21:08:30 <lambdabot>                           or `Lava.property', imported from Lava
21:08:33 <Cale> hmm
21:08:43 <Cale> oh, must've added it to the @type list explicitly...
21:09:05 <Cale> idnar: something they defined a while ago
21:09:06 <aavogt> @type Lava.property
21:09:07 <fax> lol
21:09:07 <lambdabot> forall a. (Checkable a) => a -> Lava.Property
21:09:12 <idnar> oh
21:09:15 <Cale> x/-y = x/(-y)
21:09:17 <kmc> IRC is the premier collaborative work environment for hardware design
21:09:33 <idnar> yeah, missed that
21:09:53 <djahandarie> kmc, with my new patented materializer it is!
21:10:17 <djahandarie> You just need millions of dollars of equipment
21:10:48 <Cale> @type property
21:10:49 <lambdabot> forall prop. (Testable prop) => prop -> Property
21:10:53 <Cale> there we go
21:11:33 <Sgeo> @check const a b == b
21:11:34 <lambdabot>   "Falsifiable, after 0 tests:\n"
21:11:36 <aavogt> @check property True
21:11:37 <lambdabot>   No instance for (Test.QuickCheck.Testable
21:11:37 <lambdabot>                     Test.QuickChe...
21:11:43 <aavogt> @check property $ \x -> True
21:11:43 <lambdabot>   No instance for (Test.QuickCheck.Testable
21:11:44 <lambdabot>                     Test.QuickChe...
21:12:00 <kmc> > const a b
21:12:01 <lambdabot>   a
21:12:03 <kmc> > a == a
21:12:04 <lambdabot>   True
21:12:25 <djahandarie> kmc, sanity check? :P
21:13:03 <kmc> apparently a is a
21:13:23 <djahandarie> > a == b
21:13:23 <lambdabot>   False
21:13:34 <fax> > x == x
21:13:35 <lambdabot>   True
21:13:39 <fax> > x == y ==> y == x
21:13:40 <lambdabot>   Not in scope: `==>'Precedence parsing error
21:13:40 <lambdabot>      cannot mix `GHC.Classes.==...
21:13:43 <fax> ufffffff
21:13:50 <djahandarie> ufff? :P
21:13:51 <fax> what's the point
21:14:15 <djahandarie> @type a
21:14:16 <lambdabot> Expr
21:14:21 <SamB_XP> > \x {- <- this is -} -> x + x
21:14:22 <lambdabot>   {-3->-6;-2->-4;-1->-2;0->0;1->2;2->4;3->6}
21:14:22 <kevinulin> is there a way to go between monads? I want to use an IO monad in a function that returns a Gen monad
21:14:25 * BMeph 's sanity checks always bounce... ;
21:14:32 <Veinor> dear god
21:14:33 <fax> lol
21:15:02 <Veinor> I hate everything
21:15:09 <fax> all of it?
21:16:19 <djahandarie> @kind Expr
21:16:20 <lambdabot> *
21:16:23 <kmc> kevinulin, there's not a *general* way
21:16:31 <kmc> for some pairs, yes
21:16:37 <aavogt> liftIO maybe
21:16:41 <kmc> where's "Gen" defined?
21:16:46 <kevinulin> quickcheck
21:16:49 <djahandarie> Yeah
21:16:54 <kmc> (also, the values are not called "monads"... the monad is the type itself, e.g. IO or Gen)
21:17:09 <aavogt> see quickcheck2. It has some stuff for testing monads
21:17:11 * edwardk waves hello.
21:17:19 <ezyang> hallo!
21:17:30 <djahandarie> Didn't quickcheck2 regress a bit? I recall that when I looked at it last
21:17:31 <Veinor> hey ezyang :D
21:17:53 <aavogt> kmc: see pedantic ;)
21:18:00 <edwardk> ezyang: started playing with compiling everything down to AIGs or NNF instead of CNF
21:18:49 <ezyang> ooh, isn't AIG what minisat uses?
21:19:07 <aavogt> Test.QuickCheck.Monadic isn't very documented, but if you go by the types it shouldn't be too difficult
21:19:10 <ezyang> actually, I might be confusing it with abc
21:19:12 <kmc> kevinulin, why do you want to use IO actions in your Gen?
21:19:17 <kmc> are you implementing Arbitrary?
21:19:20 <edwardk> ezyang: abc uses it, so do aiger and boolector
21:19:22 <kevinulin> yes
21:19:28 <ezyang> mhm
21:19:30 <edwardk> ezyang: minisat+ had some aig support iirc
21:19:42 <edwardk> ezyang: still coming up to speed on the problem domain
21:19:42 <aavogt> oh, I'm completely off
21:19:49 <kevinulin> im trying to quickcheck some code that uses the AES library and it has a function to generate a random key
21:20:06 <kevinulin> but the monad is of type IO when quickcheck seems to operate on Gen
21:20:08 <edwardk> ezyang: i did come up with a nice hoas encoding for what universally quantified fragments i want to work with though.
21:20:22 <kmc> kevinulin, ah
21:20:44 <kmc> kevinulin, yes, qc wants to control the generation of randomness itself
21:20:46 <kmc> for reproducibility etc.
21:21:06 <edwardk> it turned out to be surprisingly painless and completely type-level hackery free to support variadic foralls like assert $ forall $ \x y z -> (x && y) ...
21:21:44 <ezyang> O.o
21:21:55 <kevinulin> guess ill just rewrite the key generator
21:22:12 <djahandarie> edwardk, what are you compiling?
21:23:59 <djahandarie> Aiger and boolector only do low level circuit/bit-vector sorts of things, don't they?
21:24:01 <edwardk> djahandarie: i have a sat/qsat monad that i've been working with that lets you just use the surrounding monad to call out to a sat solver and get back an answer which you can use to decode back haskell values from the result.
21:24:30 <ddarius> edwardk: Isn't it just class Forall t where forall :: Var -> t; instance Forall Expr where ...; instance Forall t => Forall (Var -> t) where forall v = forall v . forall
21:24:52 <edwardk> ddarius: more or less. it basically wrote itself.
21:25:03 <Sgeo> Can Haskell's callCC be used the way Scheme's call/cc can?
21:25:07 <kmc> Sgeo, mostly
21:25:18 <kmc> you can only use it within a continuation monad
21:25:21 <Sgeo> So not just as a sort of break
21:25:27 <ezyang> Sgeo: Yup.
21:25:30 <kmc> you can, if you're in a monad supporting callCC
21:25:31 <edwardk> ddarius: you have it flipped around a little bit iirc
21:25:42 <kmc> you can think of such monads as being syntactic sugar for a continuation-passing transformation
21:25:54 <ezyang> But it's not as impressive, since everything is a function and first-class values in Haskell
21:26:10 <kmc> Sgeo, we tend not to rely on continuations as much, because laziness gets you a lot of the uses of continuations for free
21:26:20 <edwardk> class Forall t where forall :: t -> Bit; instance Forall Bit where forall = id. -- empty quantifier -- instance ForAll a => Forall (Bit -> a) where ...
21:26:47 <Sgeo> Is there a point to the Cont monad without callCC?
21:26:53 <o-_-o> does alephnull hang out here
21:26:54 <edwardk> but you have the intuition
21:27:08 <kmc> Sgeo, maybe with mapCont?
21:27:12 <kmc> but no, not generally
21:27:21 <kmc> callCC is the only way that you actually get a continuation
21:27:22 <ddarius> edwardk: I made a variadic recv for a pi-calculus embedding.
21:27:34 <kmc> unless you want to use the Cont / ContT value constructors directly
21:27:36 <ddarius> edwardk: But yeah, I forgot to make it higher order.
21:27:54 <kmc> in which case, well, you can implement callCC or anything else you need
21:28:02 <ddarius> o-_-o: He was here fairly regurlarly for a while a bit ago.
21:28:40 <kmc> it is cool that one can add something strongly resembling first-class continuations to Haskell using only a few lines of code
21:28:45 <ddarius> preflex: seen alephnull
21:28:46 <preflex>  alephnull was last seen on #perl 49 days, 20 hours, 32 minutes and 24 seconds ago, saying: buu: Yes, you are right. It appears that gnumeric is being too smart for it's own good.
21:29:15 <edwardk> right now i'm looking to encode non-prenex form AIGs and some word level properties so i can support the bitvector ops, and probably arrays. which i guess takes me into SMT territory somewhere around AUFBV
21:29:41 <edwardk> Sgeo: very very much so
21:29:47 <ddarius> edwardk: You might find this paper interesting: http://www.itu.dk/~carsten/papers/lcmtt.pdf
21:29:52 <edwardk> kmc: there is a point to Cont without callcc!
21:29:56 <kmc> what is it?
21:30:17 <djahandarie> edwardk, sometimes it seems like you are speaking a different language.
21:30:28 <ddarius> Here comes the Codensity spiel.
21:30:45 <ezyang> om nom nom
21:30:49 <edwardk> kmc: check http://www.haskell.org/pipermail/haskell-cafe/2010-January/071762.html as an example
21:31:03 <edwardk> ddarius: =) i'm fairly predictable ;)
21:31:18 <deech> Hi all, does Haskell provide a way to mock actions? For example, for code that uses a database connection can I mock up a way to test the code if the database dies suddenly?
21:31:23 <edwardk> kmc: also check http://wwwtcs.inf.tu-dresden.de/~voigt/mpc08.pdf
21:31:29 <edwardk> both of those use 'Cont without call/cc'
21:31:37 <edwardk> the former to backtrack
21:31:42 <scutigera> edwardk: even if you made all that up, it was an impressive job of invention.
21:31:45 <edwardk> the latter to avoid retraversing the tree
21:31:56 <ezyang> deech: Not in the way you might do it in a traditional language.
21:31:58 <edwardk> scutigera: hah
21:31:59 <ezyang> But effect-wise, yes.
21:32:05 <ddarius> deech: You do it the same way you do it anywhere else.  Abstract.
21:32:24 <deech> Could you elaborate a little?
21:32:28 <edwardk> kmc: but in short, codensity can affect the asymptotics of your algorithm when used wisely
21:32:44 <scutigera> A formula of the predicate calculus is in prenex[1] normal form if it is written as a string of quantifiers followed by a quantifier-free part (referred to as the matrix).
21:32:59 <deech> Do I need to create a drop-in module that has the same interface as my database connection module?
21:33:16 <ddarius> deech: That's one approach.
21:33:19 <edwardk> scutigera: correct, and since i intermix assertions with existential variable creation in my sat monad, the result is non-prenex
21:33:40 <edwardk> which is funny because aig/nnf sat solvers spend a fair bit of time rederiving the information prenex throws away
21:33:58 <ddarius> deech: Code to an interface, however you want to represent that interface, and then you can swap out implementations later.
21:34:40 <deech> ddarius: what do you mean?
21:35:46 <ddarius> deech: I was not using specialized terms there.  That is plain English.
21:36:35 <deech> ddarius: Oh I think I see .. Sorry it took me a while.
21:37:04 <kmc> deech, you can also store your database operations in an ordinary datatype
21:37:21 <kmc> then it's easy to make new interfaces, or even functions on interfaces (i.e. "talk to the real DB but with 1% chance of failure added")
21:38:06 <kmc> that is, you can write a function that takes an interface and returns a nondeterministically failing version of that interface
21:38:11 <kmc> or one that traces ever call you make to a file
21:38:30 <scutigera> deech: take ddarius' advice to heart, focusing on the interface leads to better programs than focusing on the implementation.  once you do this you will find that designing a clean interface is very challenging.
21:39:23 <deech> scutigera: yes I see how that makes sense.
21:39:38 <deech> kmc: is a module the only way to package up an interface in Haskell?
21:39:43 <kmc> deech, definitely not
21:40:06 <kmc> data DBInterface = { dbOpen :: IO Handle; dbQuery :: Handle -> String -> IO Result; dbClose :: Handle -> IO () }
21:40:43 <kmc> that's just an ordinary datatype; one of its fields is an IO action and the other two are functions returning IO actions
21:40:45 <Sgeo> @hoogle MaybeT
21:40:45 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
21:41:00 <Sgeo> @hoogle ListT
21:41:00 <lambdabot> Control.Monad.List newtype ListT m a
21:41:00 <lambdabot> Control.Monad.List ListT :: m [a] -> ListT m a
21:41:00 <lambdabot> Language.Haskell.TH ListT :: Type
21:41:04 <deech> kmc: Gotcha ...
21:41:05 <kmc> and you can write a function e.g. addRandomFailures :: Float -> DBInterface -> DBInterface
21:41:14 <kmc> which adds a specified percentage failure
21:41:20 <kmc> or traceCalls :: DBInterface -> DBInterface
21:41:50 <scutigera> what's a good way to print intermediate computations without a) monadizing everything or b) returning a great big bundle of intermediate terms to print ?
21:42:01 <opqdonut> trace
21:42:02 <kmc> deech, if you need to "hide" an implementation-specific type within your implementation of the interface, you'd use the "existential types" extension in GHC
21:42:08 <opqdonut> :t Debut.trace
21:42:09 <lambdabot> Couldn't find qualified module.
21:42:11 <opqdonut> :t Debug.trace
21:42:12 <lambdabot> Couldn't find qualified module.
21:42:16 <opqdonut> :t Debug.Trace.trace
21:42:17 <lambdabot> forall a. String -> a -> a
21:42:23 <opqdonut> that one
21:42:24 <kmc> deech, with records and existential types we basically get object-oriented functional programming
21:42:26 <arcatan> unsafePerformIO!
21:42:34 <opqdonut> it uses unsafePerformIO but it is handy for debugging
21:42:38 <kmc> scutigera, for debugging or for production?
21:43:06 <Sgeo> > [] >> [1,2,3]
21:43:07 <lambdabot>   []
21:43:07 <kmc> btw the two solutions are actually the same one.  returning the IO action (print a >> print b) is not very different from returning [a, b] and then mapM print over it
21:43:12 <Sgeo> > [5] >> [1,2,3]
21:43:13 <lambdabot>   [1,2,3]
21:43:19 <kmc> > [1..] >> 'x'
21:43:20 <lambdabot>   Couldn't match expected type `[b]'
21:43:20 <lambdabot>         against inferred type `GHC.Types...
21:43:23 <kmc> > [1..] >> "x"
21:43:24 <lambdabot>   "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
21:43:38 <kmc> :t ([1..]>>) . return
21:43:39 <lambdabot> forall b. b -> [b]
21:44:18 <scutigera> kmc: I'd say it's more debuggig.  lot's of numerical computations, and when something unexpected happens, which could just be excessive error (not a "fail" error) I have to start looking at the intermediate values.
21:44:19 <Sgeo> > [1,2..1]
21:44:20 <lambdabot>   [1]
21:44:37 <kmc> scutigera, trace sounds good then
21:44:41 <maxsu> hey how do I get the privaleges to leave people messages through lambdabot?
21:44:50 <deech> kmc: So existential types is the same as phantom types, right? So something like data a DBConnection = DBConnection {...}, and data Mock DBConnection = {...}?
21:44:58 <kmc> deech, it's not the same
21:45:06 <kmc> and that doesn't syntax check
21:45:08 <arcatan> maxsu, you don't need any
21:45:32 <Sgeo> > do { a <- [1..]; b <- [1..]; c <- [1..]; return $ a + b - c }
21:45:32 <arcatan> maxsu, @tell person blah blah
21:45:33 <lambdabot>   [1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20...
21:45:33 <maxsu> maybe I need to register my nick?
21:45:40 <kmc> what i mean is, say the Handle type differs between different dbs
21:45:42 <maxsu> ah
21:45:46 <maxsu> I was using @msg
21:45:49 <ddarius> deech: You've been revealed as an MLer!
21:45:49 <arcatan> maxsu, yes
21:45:49 <scutigera> kmc: is there a way to enable/disable the trace output, because I do that a lot (so I have a var called verbose and lot's of when's)
21:45:50 * Sgeo should stop playing around now
21:46:06 <kmc> scutigera, as long as you're breaking the rules, you can use a global IORef
21:46:13 <kmc> and write your own "trace" that checks it
21:46:18 <kmc> but it will still slow things down
21:46:24 <kmc> that's smoething i'd do with conditional compilation
21:46:34 <Sgeo> globalRef = unsafePerformIO $ newIORef False
21:46:43 <Sgeo> --Don't actually do that for anything important
21:46:46 <kmc> it's only hard if you want to change while the program runs
21:46:53 <kmc> which is where you'd need the global ioref
21:47:08 <scutigera> kmc: no I don't need state change during the run.
21:47:08 <deech> ddarius: not at all! What makes you say that? Is using tagging type an ML thing?
21:47:34 <kmc> scutigera, then trace' = if verbose then trace else flip const
21:47:46 <scutigera> kmc: conditional compilation ? ifdef ??
21:48:06 <kmc> hopefully ghc will constant fold your conditional anyway
21:48:12 <kmc> if you really care about performance, use ifdef
21:48:15 <kmc> deech, e.g.  data DBIface = forall h. DBIface { dbOpen :: IO h, dbQuery :: h -> String -> IO Result; dbClose :: h -> IO () }
21:48:24 <kmc> deech, this way we hide the handle type from the user
21:48:28 <kmc> h is existentially quantified
21:48:46 <kmc> and so we can write mysqIFace :: DBIface, and its dbOpen can have type IO MySQLHandle
21:49:00 <kmc> and pgIFace :: DBIface, and its dbOpen has type IO PGHandle
21:49:19 <scutigera> :t flip
21:49:20 <kmc> but when the user gets this record of operations, the handle type is totally opaque and all they can do is pass it back into those functions
21:49:20 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
21:49:25 <kmc> deech, makes sense?
21:49:27 <deech> kmc: Sweet! I ddin't know you could do that!
21:49:56 <kmc> deech, it's an extension provided in GHC (and some other compilers)
21:49:59 <kmc> it's not in Haskell 98
21:50:01 <scutigera> :t const
21:50:02 <lambdabot> forall a b. a -> b -> a
21:50:10 <kmc> deech, http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#existential-quantification
21:50:37 <kmc> you need -XExistentialQuantification on the cmd line or {-# LANGUAGE ExistentialQuantification #-} at the top of your file
21:50:43 <kmc> for it to compile
21:50:48 <deech> kmc: is it safe to leave it 'forall h'? Since you could put anything in there?
21:51:15 <kmc> deech, safe how?
21:51:41 <kmc> when a user gets a DBIface the only thing they know about 'h' is that they can get one from dbOpen and they can pass it to dbQuery and dbClose
21:51:59 <kmc> everything else about the type is hidden
21:52:28 <kmc> sometimes an existentially-quantified variable has a typeclass constraint.  that's not any different really, you can imagine putting all the typeclass methods into your record explicitly
21:52:50 <deech> kmc: Oh I get it! That's really neat.
21:52:57 <kmc> it is
21:53:16 <kmc> it is my main tool in convincing OO programmers that Haskell incorporates everything they know and love as a trivial special case of something more wonderful
21:53:21 <deech> Must fight sleep and play with new toy.
21:54:01 <kmc> though, record syntax leaves a lot to be desired
21:54:23 <scutigera> kmc: don't you think type classes are knd of CLOS like ? or is it the other way around.  I always liked CLOS.
21:54:24 <deech> kmc: there really needs to be a page on the haskell wiki explaining how OO idioms (like mocking) translate to Haskell.
21:54:34 <kmc> deech, there are some pages about OO
21:54:48 <kmc> somewhat bizarrely, the syntax is easier for mutable objects -- you just call a function to get a "mutate" action, rather than immutable objects, where you have to use the terrible record-update syntax
21:54:55 <kmc> however there are libraries to get better syntax for that
21:55:02 <kmc> scutigera, i don't know CLOS well enough to say
21:55:21 <ddarius> scutigera: I would not say type classes are much like CLOS or any other OO system.
21:55:32 <kmc> typeclasses give you (static) type-directed dispatch and can generalize to multiple arguments
21:55:42 <kmc> which i understand is something CLOS can do and not many mainstream OO languages can
21:55:46 <kmc> multimethods essentially
21:56:49 <deech> kmc: and things such as "existential quantification" should not be considered advanced techniques. I wish I'd known it a long time ago. Even RWH doesn't cover them. And BTW "existential quantification" is a _scary_ name.
21:56:49 <kmc> typeclasses are interfaces, and an existential over a typeclass-constrained variable might be the closest translation of a C# or Java object into Haskell
21:57:10 <kmc> deech, sure
21:57:15 <kmc> you have to get past the names in Haskell
21:57:17 <ddarius> deech: There's nothing particularly OO about mocking.  As I said (and they say), it's just providing a different implementation of an interface.
21:57:24 <kmc> and we live in a world where lambda is considered an advanced technique
21:57:27 <scutigera> kmc: right, but they dispatch on the type, so essentially you are instantiating a function for each type . close methods are the same.
21:57:35 <kmc> although perhaps you mean considered by Haskell people specifically
21:57:50 <deech> kmc: yes that last thing you said.
21:57:52 <kmc> ah
21:58:00 <kmc> i don't know, some people think it's hard to explain
21:58:03 <kmc> you seem to have got the idea quickly
21:58:21 <kmc> i recommend reading chapter 7 of the GHC manual
21:58:24 <kmc> to see all the nifty extensions
21:58:47 <kmc> what i like is that if you are doing existential OO in Haskell, there's nothing separating "class" and "object"
21:59:18 <deech> I understand it as some number of types orbiting freely some number of fixed types. Sort of a electron/nucleas thing.
21:59:22 <kmc> because that's a distinction born of an arbitrary restriction on how first-class functions can be used
21:59:32 <arcatan> I thought Wikibooks explains it reasonably clearly
21:59:44 <kmc> in that sense OO in Haskell might be called singleton- or prototype-based
21:59:58 <kmc> you can easily write things that would be "functions over classes" in other languages
22:00:15 <kmc> or things that'd be metaclasses
22:00:18 <deech> except that immutability means there is no encapsulated state floating freely.
22:00:27 <scutigera> kmc: no need for "friend" or the related non-sense
22:00:27 <kmc> you can make mutable objects too
22:00:39 <ddarius> kmc: From a Smalltalk point of view, in that version a class is an object factory, i.e. a function that produces the DBInterface record.  From a C++ and co. view, a class might be identified with the record (data) declaration.
22:01:04 <kmc> ddarius, right, but C++ forces one type per implementation, whereas we have one type per interface
22:01:10 <kmc> scutigera, yeah
22:01:17 <kmc> closures are enough to implement OO-style abstraction and hiding
22:01:31 <kmc> this is used in perl, weirdly enough
22:01:46 <pikhq> Yeah, Perl just likes to bless its closures.
22:01:57 <pikhq> (And yes, the term is "bless")
22:02:07 <kmc> perl's OO system is wacky as hell
22:02:19 <kmc> it's flexible and interesting
22:02:24 <pikhq> Perl's everything is wacky as hell.
22:02:26 <kmc> yeah
22:02:34 <pikhq> It's kinda a design philosophy.
22:02:36 <deech> pikhq: the perl community does have a sense of humor.
22:02:40 <ddarius> I don't think existential+records cleaves particularly closer to prototyped-based OO than class-based OO.
22:02:43 <pikhq> deech: Also true.
22:02:48 <edwardk> kmc: though with newtypes that restriction is pretty minimal
22:02:57 <edwardk> and mostly a syntactic dodge for the dispatch issue
22:03:10 <kmc> edwardk, yeah
22:04:16 <scutigera> the only thing form oo that doesn't seem to translate is simple inheritance, if everything has a origin(point), then I can move everything by operating on the origin.
22:05:00 <kmc> scutigera, that's interface inheritance, not implementation inheritance, correct?
22:05:09 <kmc> the two are pretty different and it's a shame that C++ (in particular) confuses them
22:05:22 <edwardk> scutigera: think of haskell OOP as 'blackbox' inheritance rather than 'whitebox' inheritance. you get classes (interfaces) which are mostly implementation free and wire them up to prebuilt components
22:05:30 <scutigera> kmc: honestly I'm not sure.  haven't touched c++ in about 10 years
22:05:38 <kmc> right but this is not a C++ concept
22:05:43 <kmc> it's an OO concept that C++ gets *wrong*
22:06:10 <kmc> implementation inheritance in Haskell would just mean that your "constructor" (not in the algebraic sense) calls another "constructor"
22:06:21 <luite> what would be a good way to smooth outlines of scanned letters, fast enough to run on an ebook reader?
22:06:42 <kmc> separable gaussian blur kernel
22:06:50 <ddarius> edwardk: "blackbox" inheritance = delegation
22:06:53 <kmc> but why not preprocess
22:07:09 <scutigera> kmc: I think I might be talking implementation, I have orgin (x,y) and all of my more "complicated" objects incorporate.  has-a, not is-a.
22:07:19 <kmc> oh
22:07:28 <edwardk> ddarius: yes.
22:07:52 <kmc> it would be nicer with extensible records
22:07:55 <kmc> but yes, you can do that
22:08:39 <edwardk> scutigera: its easy actually. import something like fc-labels. make class HasOrigin t where origin :: t :-> Origin
22:09:52 <edwardk> scutigera: i propose the HasOrigin bit because it gives you one name for both getting and setting the origin property
22:10:25 <edwardk> then you can define things like moveNorth :: HasOrigin t => Int -> t -> t
22:10:30 <luite> kmc: a non-separable kernel would probably still be fast enough, since it will be only a few pixels wide. currently, having adobe acrobat trace each letter to a smoothed vector outline results in much crisper and more readable rendering. the problem is that those files are large, and slow to load
22:11:28 <scutigera> edwardk: very interesting.  didn't know about fc-labels !
22:12:09 <edwardk> scutigera: you can bypass the need for fc-labels, just by providing getters and setters by hand, getOrigin :: t -> Origin; setOrigin :: Origin -> t -> t
22:12:40 <ski> (edwardk : `(:->)' being the type constructor for natural transformations ?)
22:12:59 <edwardk> ski: a :-> r -- being an alias for (a -> r, r -> a -> a)
22:13:12 <ski> ah, functional reference / lens / accessor
22:13:17 <edwardk> ski: fc-labels provides, get, set, and modify methods based on it
22:13:18 <edwardk> yeah
22:13:38 <Sgeo> I don't _quite_ understand All About Monad's definition of the Identity monad
22:13:40 <Sgeo> http://www.haskell.org/all_about_monads/html/identitymonad.html
22:13:54 <scutigera> edwardk: so t is a record but simply contains a field "origin"
22:13:57 <Sgeo> Shouldn't the bind result in something of type Identity a?
22:14:12 <Sgeo> So shouldn't it be (Identity x) >>= f = Identity $ f x
22:14:20 <Sgeo> ?
22:14:29 <ski> Sgeo : `f' already returns something of type `Identity b'
22:14:30 <edwardk> scutigera: the nice thing is you can make the methods that just require the the properties of the origin, and of course the fact that labels 'compose'
22:14:38 <Sgeo> Oh, right >.>
22:14:44 <kmc> Sgeo, that's fmap, not (>>=)
22:14:45 <ski> `Identity $ f x' would have type `Identity (Identity b)'
22:14:53 <kmc> fmap f (Identity x) = Identity (f x)
22:15:16 <Sgeo> Ok, I get the point, I had a brain failure
22:15:20 <edwardk> 'f a' returns a value of 'Identity b' -- so you don't need to rewrap it or you'd get Identity (Identity a)
22:15:39 <Sgeo> I'm pretty sure that this comment "-- i.e. return = id " is wrong though
22:15:53 <kmc> return = id, modulo wrapping / unwrapping
22:16:00 <ski> Sgeo : modulo the `Identity' constructor, is it right
22:16:04 <kmc> it's metaphorical
22:16:11 <kmc> but yeah, AAM is known to be confusing in these ways
22:16:24 <ski> (and implementation-wise, the `Identity' constructor is a noop (O(0)))
22:16:59 <Sgeo> Surely it has an effect on the type
22:17:05 <ski> yes
22:17:16 <edwardk> Sgeo: but the type doesn't exist at runtime, its not like we carry around tags saying what type you have
22:17:29 <edwardk> Sgeo: some languages might, but haskell is daring
22:17:41 <edwardk> well most implementations of it are anyways
22:18:12 <Sgeo> So that's what's meant by "newtype is free"
22:18:19 <edwardk> yeah
22:18:46 <Sgeo> It occurs to me that newtypes are kind of like Joel's idea of hungarian notation, except compiler enforced
22:18:48 <edwardk> newtypes have literally zero performance cost (unless the compiler is having a really bad day or you map them and it doesn't spot its an identity function or can't for other reasons, etc.
22:18:54 <kmc> Joel's?
22:18:59 <Sgeo> Joel on Software
22:19:05 <kmc> Joel didn't invent HN
22:19:07 <kmc> also HN is terrible
22:19:18 <kmc> "newtype Foo a = Bar x"  ==>  "data Foo a = Bar !x"  is a valid implementation of newtype, but would be less efficient in GHC than what GHC actually does
22:19:19 <edwardk> HN is Simonyi ;)
22:19:59 <Sgeo> No, but he describes his interpretation of what it should be and how it's a good thing, e.g. marking unsafe strings as usSomeString
22:19:59 <edwardk> kmc: but joel had a bit to say about hungarian notation is all i think sgeo was referring to
22:20:02 <kmc> oh
22:20:06 <kmc> okay
22:20:06 <Sgeo> edwardk, yes
22:20:23 <kmc> funny to have a language where you have to write the types *and* they're useless so you have to add more typing yourself
22:20:35 <edwardk> kmc: =)
22:20:57 <tensorpudding> Hungarian notation is pretty nasty.
22:21:50 <BMeph> Cale: Have you seen the "original" Chua paper? :)
22:21:56 <kmc> types substitute for documentation much better than documentation substitutes for types
22:22:02 * ski . o O ( `newtype k (Foo a) = MapBar (k a)' )
22:22:32 <tensorpudding> That said, I like some regional things that are reminiscent of it.
22:22:44 <tensorpudding> For example, Ruby's tendancy to name destructive methods with a ! at the end
22:22:50 <jbapple> Requiring capital letters for types and constructors reminds me of Hungarian notation
22:23:14 <edwardk> @remember kmc types substitute for documentation much better than documentation substitutes for types
22:23:15 <lambdabot> Done.
22:23:21 <Jafet> Really? It's Germanic
22:23:24 <kmc> ski, ?
22:23:29 <ski> tensorpudding : i would assume that's borrowed from Scheme
22:23:38 <tensorpudding> True.
22:23:44 <kmc> Haskell's "unsafe" might be considered an example
22:23:46 <tensorpudding> But it's a similar idea.
22:23:50 <jbapple> I think I remember reading that capital letters help parsing work properly
22:23:53 <edwardk> jbapple: i'm less apalled by that than the consequences of the alternative
22:23:54 <kmc> but "unsafe" means vastly different things depending on context
22:24:00 <tensorpudding> Yeah, "unsafe" is a Haskellism.
22:24:20 <kmc> perhaps Haskell should get a type-level mechanism to tag impure or type-unsafe functions
22:24:21 <ski> kmc : an idea of mine, to cope with `<edwardk> newtypes have literally zero performance cost (unless ... you map them and it doesn't spot its an identity function or can't for other reasons, etc.")
22:24:24 <Jafet> Unsafe just means that in that particular case you have to read the documentation
22:24:25 <jbapple> edwardk: howso?
22:24:36 <kmc> ski, interesting
22:24:39 <kmc> sounds doable with families
22:24:52 <edwardk> jbapple: foo x y z = .... -- is that binding x y and z because foo is a constructor or is that binding foo because it is not?
22:25:03 <Jafet> kmc, but how do you write an unsafe function to get around that mechanism!
22:25:06 <edwardk> jbapple: you need to know all data types forwards and backwards to answer that question
22:25:10 <ski> kmc : the idea being that that `newtype' declaration declares the constructor `MapBar' to have type `forall k a. k a -> k (Foo a)'
22:25:25 <kmc> edwardk, obviously in the former case one should write "typename foo x y z = ..."
22:25:28 <kmc> ;)
22:25:30 <jbapple> edwardk: How does Agda do it right?
22:25:32 <edwardk> jbapple: foo x = assuming foo IS a function, is that binding x or is it using the x constructor in scope
22:25:51 <edwardk> jbapple: they suck it up and read all the modules, and STILL sometimes get it wrong.
22:25:55 <Sgeo> ski, does your name come from the combinators? (Or whatever those things are called, I think they're in Unlambda [as well as other places of course])
22:25:59 <ski> kmc : so, e.g. you could do `case MapBar (Just 42) of Just x -> x', and that then has type `Foo Int' :)
22:26:00 <jbapple> haha
22:26:05 <ski> Sgeo : correct
22:26:16 <edwardk> jbapple: the 'alternative' i was mentioning was agda ;)
22:26:51 <ski> kmc : so applying or matching on `MapBar' adds or removes `Foo' in a *context* `k' of the type
22:26:52 <edwardk> also it means that a change in a library you import that simply adds a definition can change the semantics of your code. where your code was just binding a variable with t he same name!
22:27:05 <kmc> that's awkward
22:27:22 <ski> kmc : .. (which was the whole point)
22:27:29 <ski> kmc : awkward why ?
22:27:54 <ski> because you have to have exactly a `k' context ? (if so, then i agree that's a bit awkward)
22:27:59 <edwardk> jbapple: you can fix it. one of the ways i've been thinking about doing that is by saying something in kata like foo x y z <- definition -- is a destructuring assignment and foo x y z -> ... is a member/method definition
22:28:20 <edwardk> jbapple: but that starts to look very erlangy on the definitions, and in this era of utf8 symbols, the -> looks kinda hokey ;)
22:28:28 <kmc> ski, no i meant the agda thing
22:28:43 <kmc> sorry
22:29:26 <ski> (iow, you can't `MapBar' an `[Maybe Int]' and expect to get `[Maybe (Foo Int)]', you have to first convert to `Compose [] Maybe Int', then get `Compose [] Maybe (Foo Int)', then unwrap to `[Maybe (Foo Int)]' .. given `newtype Compose f g a = C (f (g a))', naturally)
22:30:21 <edwardk> ski: another ski-wish-list language feature?
22:30:33 <ski> edwardk : hehe, yes :)
22:30:34 <kmc> it sounds implementable
22:30:47 <jbapple> I think proofgeneral for Isabelle will render some ASCII art arrows (or LaTeX abbrevs) as their unicode equivalent
22:30:52 <ski> yes, i don't think there's very much problem with implementing it
22:31:12 <ski> the questions are more how useful/awkward this feature is
22:31:16 <ski> and whether it could be improved
22:31:34 <ski> (and possibly also if it would break some type-system invariants of some kind ..)
22:31:59 <edwardk> ski: w.r.t the cost of unwrapping a newtype, you can always provide an Iso type that uses unsafeCoerce, or which uses the newtype soundness hacks folks have mentioned before.
22:32:14 <edwardk> which rely on generalizednewtypederiving to write impossible functions
22:32:23 <ski> naturally, it would only work with `newtype' .. and there should be some restrictions on where `k' can appear in the body
22:32:39 <edwardk> http://www.haskell.org/pipermail/haskell-cafe/2010-March/074305.html
22:33:20 <ski> edwardk : iiuc, ghc does (or plans to do ?) introducing an equality for each `newtype', that could possibly be accessed in local scopes
22:33:42 <edwardk> ski: yeah
22:33:51 <alex404> How useful can the INLINE pragma be for performance?
22:34:08 <edwardk> but for the moment you can use it to quickly provide a nice little newtype iso unwrapper that can unwrap through functors ;)
22:34:12 <maxsu> Hey I've got a function intsqrt = floor.sqrt.fromIntegral. Its type should be integral a => a -> a. I compiled a bunch of files against a module containing this function and when it gets to the file that uses this function on an int, it fails.
22:34:16 <edwardk> alex404: insanely
22:34:23 <maxsu> Loading the function in ghci I get the type integer -> integer
22:34:34 <maxsu> @type floor.sqrt.fromIntegral
22:34:35 <lambdabot> forall b a. (Integral b, Integral a) => a -> b
22:35:02 <ski> (edwardk : of course, the above would work for any `f :: * -> *' (or possibly with other domain and codomain, as well), not just `Functor's)
22:35:26 <alex404> edwark: Do you have any soft guidelines as to when it should be used?
22:35:32 <ski> (sorry, renamed my `k' to `f')
22:35:42 <maxsu> could it be that it compiled the module for an earlier file where the function was used in the integer-> integer sense, and now I'm running into the specialized code when I'm trying to compile a separate file?
22:35:48 <Axman6> :t let isqrt x = floor . sqrt . fromIntegral $ x in isqrt
22:35:49 <lambdabot> forall a b. (Integral a, Integral b) => a -> b
22:36:04 <edwardk> ski: sure
22:36:08 <Axman6> :t let isqrt :: Integral a => a -> a; isqrt x = floor . sqrt . fromIntegral $ x in isqrt
22:36:09 <lambdabot> forall a. (Integral a) => a -> a
22:36:25 <kmc> alex404, GHC is pretty aggressive about inlining even without the pragma
22:36:50 <kmc> and that's essential for good performance, since we have so much abstraction and indirection and boxing of values etc.
22:36:56 <alex404> Indeed
22:37:01 <edwardk> alex404: in short, using inline when you want inlining across module boundaries
22:37:10 <edwardk> alex404: beyond that it becomes a bit of a black art
22:37:16 <alex404> Ahh, okay
22:37:25 <pastorn> edwardk: i read that mail... don't really get it... :/
22:37:28 <alex404> So within a module, GHC will probably have my back?
22:37:29 <pastorn> what's he doing?
22:37:31 <kmc> black art = reading Core?
22:38:05 <jmcarthur> INLINE is not a bad idea when there are rewrite rules for that function. INLINE keeps the function "intact" until it's already been inlined and rules have been applied, then functions inside that will be inlined
22:38:06 <edwardk> pastorn: the codensity monad there is allowing me to ask 'er.. will i do something with this reference in the future?'  and get back a yes or no
22:38:35 <pastorn> edwardk: contiuations deluxe?
22:38:44 <jmcarthur> that kind of behavior is being tinkered with in GHC HEAD though, as i understand it
22:38:45 <kmc> meaning the answer is "no", and if you use it then you time-travel back here and the answer is "yes"?
22:39:01 <jmcarthur> so it might be changing
22:39:05 <edwardk> pastorn: if you're told no, and go to use the reference, what happens is i timetravel back and tell you 'yes' instead. if you still don't use the reference i don't bother to change my answer
22:39:13 <edwardk> yeah
22:39:20 <ski> @type (floor.sqrt.fromIntegral) `asTypeOf` id
22:39:21 <lambdabot> forall a. (Integral a) => a -> a
22:39:22 <pastorn> hmm...
22:39:24 <kmc> it's like excluded middle :)
22:39:24 <edwardk> kmc: exactly
22:39:35 <pastorn> edwardk: is this some weird lazyness-hackaround?
22:39:47 <alex404> Thanks for all the tips...
22:39:48 <pastorn> sounds pretty cool...
22:39:51 <edwardk> kmc: or the devil's bargain version of Not (Not (Not a)) -> Not a
22:40:01 <Sgeo> Does do notation also work with Arrows?
22:40:03 <kmc> heh
22:40:07 <Sgeo> [I barely know what arrows are]
22:40:09 <kmc> Sgeo, they have their own notation, "proc"
22:40:15 <kmc> arrows are in general much less commonly used than monads
22:40:25 <edwardk> Sgeo: they have proc sugar, which interestingly uses the do keyword overagain for another use
22:40:32 <jmcarthur> pastorn: such explanations always sound magical, but of course they are not. knowing that usually doesn't help understand it though
22:40:43 <Sgeo> What other things have sugar like that?
22:40:43 <kmc> edwardk, what does "codensity" mean in this context?
22:40:44 <jmcarthur> which is a shame
22:40:49 <edwardk> Sgeo: if you have an arrow that is an 'ArrowApply' it can be wrapped into a monad though
22:41:00 <jmcarthur> Sgeo: list comprehensions are sugar
22:41:07 <kmc> Sgeo, list comprehensions are a variant form of "do" which works only for the list monad.  in some versions of Haskell it worked for every monad ("monad comprehension")
22:41:14 <ski> (pastorn : .. hm, which mail ?)
22:41:21 * Sgeo wonders if it's possible to get ill from Haskell, due to the excessive sugar
22:41:23 <pastorn> ski: edwardk's link
22:41:25 <edwardk> kmc: its a topology term, which comes from the fact that the construction is dual to the 'density comonad', but that is a bit of a non-answer ;)
22:41:28 <jmcarthur> record syntax is sugar, too
22:41:30 <kmc> Sgeo, there's lots of sugar in general, are you looking for a particular sort?
22:41:40 <kmc> [a,b..c]  ==> enumFromThenTo a b c
22:41:46 <Sgeo> kmc, more do-notation like, I guess, now that I learn of some "proc" thing
22:41:51 <kmc> ah
22:41:58 <kmc> there's do and proc and list comprehensions
22:41:58 <jmcarthur> 5  ==>  fromIntegral 5
22:41:59 <Sgeo> Which I've never heard of before
22:42:08 <kmc> Sgeo, if you read about arrows you'll run into it
22:42:15 * Sgeo headaches
22:42:19 <kmc> in some sense most of Haskell is sugar
22:42:24 <kmc> because Core is a vastly smaller language
22:42:32 <kmc> if you like, typeclasses are sugar for implicit arguments
22:42:43 <Sgeo> implicit arguments?
22:42:50 <kmc> and multiple equations for functions are sugar for "case"
22:42:52 <jmcarthur> i wish whitespace was just sugar for ($) so we could overload it
22:42:54 <kmc> and "where" is sugar for "let"
22:43:16 <ski> edwardk : hm, i don't see (at quick glance) codensity used at <http://www.haskell.org/pipermail/haskell-cafe/2010-March/074305.html> ..
22:43:18 <kmc> jmcarthur, write a preprocessor :)
22:43:34 <edwardk> ski: pastorn was talking about another paste from earlier
22:43:46 <jmcarthur> kmc: not an entirely bad idea
22:43:46 <edwardk> http://www.haskell.org/pipermail/haskell-cafe/2010-January/071762.html
22:43:51 <ski> oh, ty
22:43:57 <kmc> jmcarthur, i'd like to see it... wonder what insane hacks can be had
22:44:06 <kmc> for starters, "trace"ing every function application
22:44:06 <Sgeo> Wait, can you do, say f a = b
22:44:08 <edwardk> ski: in which i used the codensity monad of STM
22:44:08 <kmc> by source line too!
22:44:14 <Sgeo> f = \g -> d
22:44:15 <Sgeo> ?
22:44:19 <maxsu> Here is where my intsqrt function is defined: http://github.com/maxsu/Project-Euler/blob/master/Euler.hs
22:44:24 <Sgeo> Or is that syntactically fail?
22:44:25 <jmcarthur> kmc: constraints in type sigs would get very crazy
22:44:27 <kmc> Sgeo, in what context?
22:44:38 <Sgeo> Multiple equations for a function
22:44:39 <Jafet> > let f a = b in f a
22:44:39 <lambdabot>   b
22:44:43 <jmcarthur> at least in full generality they would
22:44:47 <kmc> Sgeo, each equation must have the same number of formal parameters
22:44:49 <kmc> this is unfortunate
22:44:52 <maxsu> for some reason both the intsqrt and prime functions shake out to Integer -> Integer
22:45:20 <kmc> > let f 0 = 1; f = id in f
22:45:21 <lambdabot>   Equations for `f' have different numbers of arguments
22:45:21 <lambdabot>    <interactive>:1:4-...
22:46:35 <jmcarthur> kmc: other niceties would be treating anything that can be modeled as a function... as a function! for example, [a] can be treated like  Nat -> a, so   "foobarbaz" 5 == 'r'
22:46:52 <edwardk> jmcathur: did you see my cheesy hack for that the other day?
22:46:53 <jmcarthur> and other obviously things, like Data.Map
22:47:00 <jmcarthur> edwardk: no, what was it?
22:47:11 <ski> > let f = \x -> case x of 0 -> 1; x -> x in f `map` [-2,-1,0,1,2]
22:47:12 <lambdabot>   [-2,-1,1,1,2]
22:47:24 <jmcarthur> edwardk: you've seen mine, right? (the type class, at least, not the sugar)
22:47:35 <edwardk> @hpaste
22:47:35 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
22:48:13 <edwardk> jmcarthur: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=9319
22:48:30 <ski> jmcarthur : hehe, `tail xs n = xs (n + 1)' :)
22:48:31 <edwardk> you can use application with those arrays or use them like arrays
22:48:36 <jmcarthur> Array?!
22:48:46 <edwardk> jmcarthur: you can do the same with list
22:49:13 <jmcarthur> ski: woah, that takes it to yet another level
22:49:37 <jmcarthur> ski: would be nice to use church encodings to play with actual ADTs
22:49:55 <psykotic> edwardk: i'm reviewing the old 'essence of dataflow programming' paper. is there a sense in which their 'comonad with zipping' is a kind of coapplicative functor? an applicative's signature is f (a -> b) -> (f a -> f b). the 'comonad with zipping' signature is (f a, f b) -> f (a, b). i'm thinking of the product/exponential adjunction, etc.
22:50:01 <jmcarthur> actually, that's not a church encoding...
22:50:07 <ski> jmcarthur : well, that's just the same as you were saying, just taken to its conclusion (definitions, not just expressions)
22:50:14 <jmcarthur> right
22:50:16 <edwardk> jmcarthur: i've been a fan of allowing constructors to define their meaning in the presence of 'overapplication' - the kata language design permits it in theory
22:50:53 <jmcarthur> edwardk: you mean allowing things to be used in different ways which obey isomorphisms?
22:51:20 <mornfall> :( the time package is such a mess
22:51:40 <edwardk> psykotic: coapplicative would be a different beast and deals with coexponentials for the most part, which we can't have, but that said, 'kinda'. did you read my zipping posts?
22:51:52 <psykotic> edwardk: no, i'll google them. thanks.
22:52:16 <Sgeo> Has any work been done on a Python <-> Haskell bridge?
22:52:18 <ski> jmcarthur : actually, i think it would be rather nice, if one could define things like `runState (ma >>= amb) s0 = runState (amb a) s1 where (a,s1) = runState ma s0' .. that would read so much nicer than `ma >>= amb = State $ \s0 -> let (a,s1) = runState ma s0 in runState (amb a) s1'
22:52:38 <ski> jmcarthur : of course, there's potentially some ambiguity here, to be sorted out
22:52:43 <maxsu> Hmm.. once I added intsqrt :: (Integral a, Integral b) -> a -> b, intsqrt works on Ints as well.. now to see if the same trick will generalize the prime :: Integer -> bool function... I still don't understand why the interpreter is inferring these more specialized types
22:53:25 <edwardk> psykotic: http://comonad.com/reader/2008/deriving-strength-from-laziness/ and  http://comonad.com/reader/2008/cozipping/ the latter is far more relevant though
22:53:49 <maxsu> :t even
22:53:50 <lambdabot> forall a. (Integral a) => a -> Bool
22:53:55 <jmcarthur> ski: i like it
22:54:16 <kmc> Sgeo, there are a few packages that bind to the CPython API
22:54:19 <ski> jmcarthur : this would be specifically for `newtype'-destructors like `runState', i think
22:54:25 <kmc> which is pretty hairy
22:54:26 <kmc> i don't know of anything nicer or higher level
22:54:32 <edwardk> psykotic: er and http://comonad.com/reader/2008/zipping-and-unzipping-functors/#comments
22:54:49 <ski> jmcarthur : possibly one could change the syntax of them to read like `RunState' or something, to avoid the concrete syntactical ambiguity ..
22:54:50 <edwardk> psykotic: the first comment there ties zipping to Applicative
22:55:20 <ski> psykotic : btw, having `forall a b. i (a -> b) -> (i a -> i b)' is equivalent to having `forall a b. (i a,i b) -> i (a,b)' .. (assuming relevant laws in each case)
22:58:12 <tensorpudding> @djinn Void -> a
22:58:13 <lambdabot> f = void
22:58:25 <ski> @type uncurry ((<*>) . (pure (,) <*>))
22:58:26 <edwardk> jmcarthur: nah, mostly just permit adhoc overloading of application in places where haskell leaves it deliberately a type error.
22:58:26 <lambdabot> forall (f :: * -> *) a a1. (Applicative f) => (f a1, f a) -> f (a1, a)
22:58:26 <ski> @type uncurry ((<*>) . ((,) <$>))
22:58:27 <lambdabot> forall (f :: * -> *) a a1. (Applicative f) => (f a1, f a) -> f (a1, a)
22:58:38 <ski> psykotic : ^
22:58:47 <edwardk> ski: yeah
22:58:51 <psykotic> ski: yeah, i have pretty good intuition for applicatives/idioms.
22:59:22 <psykotic> and getting better about comonads, but i was trying to see how this notion of 'comonad with zipping' could be crystalized
22:59:55 <ski> psykotic : so your "comonad with zipping" actually is "almost" an `Applicative'
23:00:29 * ski ponders that
23:01:05 <edwardk> ski: yeah its the top half. you can use it as a the basis for a coideal comonad though. =)
23:03:00 <shrughes> every time i try some scheme i rediscover why i love haskell (and ghc)
23:03:12 <edwardk> shrughes: hahahah
23:03:29 <kmc> i like scheme
23:03:31 <edwardk> everytime i try scheme i rediscover why i love hackage ;)
23:03:35 <kmc> more for learning than for using
23:04:37 <shrughes> and it's really the simple things, like MVars and haddock, that i miss
23:05:06 <shrughes> (and functions that have one argument and one (read it: ONE) return value!)
23:05:16 <ddarius> PLT Scheme has some pretty sophisticated tools/libraries.
23:05:35 <edwardk> shrughes: you can steal my currying macros if you really want haskell-like application
23:05:52 <shrughes> there are currying macros in plt scheme already actually, thanks
23:06:01 <ski> @type let zip = uncurry (((<*>) . ((,) <$>))) in curry (fmap (uncurry ($)) . zip)
23:06:02 <lambdabot> forall b b1 (f :: * -> *). (Applicative f) => f (b -> b1) -> f b -> f b1
23:06:04 <edwardk> ddarius: but surprisingly few functional data structures. at last check there wasn't a single non-imperative tree library in PLT
23:06:09 <ski> that's the other direction
23:06:18 <edwardk> shrughes: none of which deal with overapplication
23:06:28 <ddarius> edwardk: That's the problem with Smalltalk although it's not surprising in that context.
23:06:38 <edwardk> ddarius: *nods*
23:06:56 <Jafet> For me SICP was a lesson in reimplementing Prelude
23:07:15 <ski> so, we just need that `i' is a `Functor', to be able to convert between the `forall a b. i (a -> b) -> (i a -> i b)' and the `forall a b. (i a,i b) -> i (a,b)' form
23:07:17 <edwardk> Jafet: hah, so was writing my plt monad lib
23:07:51 <edwardk> jafet: oh look, i need const, and id, and flip, and ....
23:08:07 * ski realizes edwardk already informed jmcarthur that coapplicative would be something else ..
23:08:10 <Jafet> I also added, ironically, do-syntax
23:08:20 <edwardk> ski: yeah
23:08:35 <ski> edwardk : why do you call it "top half" ?
23:08:54 <ski> (and what does "coideal" mean, here ?)
23:09:25 <kmc> Jafet, was it overloaded for all monads?
23:09:32 <edwardk> a coideal comonad is a comonad of the form a * f a, where extract takes 'fst'
23:09:44 <Jafet> Well, no monads were harmed in the making
23:10:04 <edwardk> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Comonad-Coideal.html
23:10:08 <Jafet> It was just a nicer way to write imperatively
23:10:25 <kmc> ah
23:10:30 <edwardk> they have the interesting property that they have a well defined notion of comonadic product
23:10:39 <kmc> Jafet, how did it differ from (begin ...)
23:11:10 <edwardk> they are the dual of ideal monads, which are monads of the form a + f a -- where return = Left -- and there is a generalized notion of monadic coproduct
23:11:42 <edwardk> the free monad and cofree comonad happen to be ideal and coideal
23:12:23 <edwardk> ski: as for the meaning, i believe, based on a conversation with him, that tarmo uustalu pulled the name out of thin air ;)
23:12:38 <Jafet> kmc, define and set! are longer to type than <-
23:12:43 <edwardk> ski: though, he coined ideal monads, and i just flipped them to make the obvious comonad
23:12:55 <Jafet> And let is just ugly
23:12:58 <ski> comonadic product being a categorical product in the category of comonads ?
23:14:07 <ski> (yes, i can see how [co]free would imply [co]ideal)
23:15:07 <ski> edwardk : hm, do you have any idea in which paper tarmo did introduced (or elaborated on) that ?
23:15:11 <edwardk> ski: lets talk ideal monadic coproduct first. the ideal monadic coproduct looks like a + (f (a + g (a + ...)) + g (a + f (a + ...)))
23:15:32 <edwardk> for the coideal comonadic product swap * in for +
23:15:38 <maxsu> hmm some [co]ffee would be actually ideal
23:15:57 <edwardk> ski: afaik it was never published. i saw a couple of slides in a slide deck once
23:16:17 <ski> .. oh :/
23:16:35 <edwardk> hrmm i stand corrected 'Coproducts of Ideal Monads' by Uustalu and Ghani
23:16:48 <ski> ah, ty
23:17:28 <Veinor> raaaage
23:17:42 <ski> edwardk : hm, so the `f's and `g's alternating, and giving both choices at the top ?
23:18:07 <edwardk> ski: yeah, and in the comonadic case you get access to both the f and the g at the top with alternating layers as you go down
23:18:50 <edwardk> basically you use the coidealize/idealize method i have in category extras to 'compact' each layer. but you don't necessarily have any distributive law to move the layers over each other
23:19:08 <edwardk> so the number of layers continues to grow
23:19:44 <ski>   (IdealMonad f + IdealMonad g) a = a + f (FreeMonad (\x -> g (a + f x)) a) + g (FreeMonad (\x -> f (a + g x)) a)  -- iiuc
23:20:35 <edwardk>  (\x -> a + g (a + f x)) --- but yes
23:21:04 <ski> doesn't `FreeMonad' give the outer `a +', there ?
23:21:05 <edwardk> oh
23:21:06 <edwardk> i see
23:21:08 <edwardk> yeah
23:21:10 <edwardk> i just parsed that
23:21:19 <edwardk> that works
23:21:37 <edwardk> but i'm not sure you can use the free monad there
23:22:19 <ski> (where `IdealMonad f a = a + f a' and `FreeMonad f a = a + f (FreeMonad f a)')
23:23:01 <edwardk> ski: the question is if bind would work right using free there vs. the mutual construction and the call to f and g's idealize
23:23:23 <edwardk> you might wind up lifting f and g operations into something a bit bigger than you want
23:23:30 * ski still doesn't see how the right-hand-side above would be an instance of an `IdealMonad', though ..
23:23:55 <ski> hrm .. maybe. i was just considering the types here
23:24:00 <edwardk> yeah
23:24:07 <edwardk> typewise i buy your definition completely
23:24:21 <orpras> Is anyone here using hfann?
23:24:29 <orpras> Can anyone tell me why hfann can't find the fann headers but my fann code can?
23:24:56 <edwardk> the existence of a class of monads that have a well defined coproduct was the whole point of exploring ideal monads in their own right
23:25:15 <edwardk> lots of monads are ideal. Either a, Maybe, etc.
23:25:23 <ski> yeah .. so the coproduct of two ideal monads ought to be an ideal monad .. but i don't see it
23:25:49 <edwardk> ski: take the types and try to make them fit, its a fun 30 minute exercise or so
23:25:58 <ski> ok :)
23:26:38 <tensorpudding> What's the justification for calling the monads ideal?
23:26:39 <ski> (i have no problem with the dual, more than with this one)
23:26:43 <edwardk> i apparently lost the code i had for it for category-extras, i think i implemented it around the time comonad.com crashed a couple of summers ago
23:27:39 <edwardk> tensorpudding: uustalu coined the name, i stopped looking to fully translate his motivations a long time ago ;)
23:27:54 * ski str pondering `data Foo a = Return a | LiftIO (IO a)' before .. which would be `IdealMonad IO'
23:29:16 <tensorpudding> With so much mathematical terminology being bandied about, I figured it might bear some relation to ideal rings.
23:29:17 <edwardk> you might argue that like ideals in abstract algebra they are a subset of aring that generalizes some important integer-like properties -- in this case regarding having a canonical construction for a coproduct, but i wasn't there ;)
23:29:54 <edwardk> er like how in abstract algebra ideals are a subset of a ring.. not that these are a subset of a ring
23:30:28 <ski> (hm, a sub-rng, iirc ?)
23:30:34 <tensorpudding> It's not just that ideals are a subring, but they have the property that their product with arbitrary ring elements stays in the ideal
23:30:35 <ezyang> I wonder what the data type that corresponds to e^x is.
23:30:45 <edwardk> tensorpudding: yeah
23:30:57 <ski> ezyang : bag of elements of type `x', i think
23:30:59 <tensorpudding> What's the analogy to a ring product in the type system?
23:31:10 <edwardk> ezyang: your answer is here http://comonad.com/reader/2008/generatingfunctorology/
23:31:24 <ezyang> aha!
23:31:26 <tensorpudding> Presumably a data type for e^x would represent 1+x+x^2/2 + ... + x^n/n!?
23:31:35 <ski> ezyang : `e^x = 1 / 0! + x / 1! + x^2 / 2! + x^3 / 3! + ...'
23:31:58 <tensorpudding> But I thought sigfpe talked a lot about that stuff.
23:32:01 <ski> the `/ n !' part factors out by permutations of the `n'-tuples
23:32:03 <ezyang> damn, should've seen it
23:32:05 <ezyang> :-)
23:32:37 <ezyang> (I've been reading the first chapter of generatingfunctionology)
23:32:46 <tensorpudding> So an ideal monad is related in some sense to a "larger" monad?
23:32:48 <edwardk> ezyang: data Bag a; instance Functor Bag insert :: a -> Bag a; grab :: Bag a -> IO (Maybe (a, Bag a) ) -- you can put elements in, map them around, but you can't take them out in a predictable order.
23:33:14 <ski> s/IO/NonDet/
23:33:16 <edwardk> ezyang: they are one of the simpler species.
23:33:34 <ski> (with `choose :: forall a. NonDet a -> IO a', of course :)
23:33:39 <edwardk> ski: yeah, just using IO as the closest thing to a sinbin i have ;) there is a rik you could seed your NonDet monad ;)
23:33:43 <edwardk> hah
23:33:48 <edwardk> er risk
23:33:49 <ski> ("rik" ?)
23:33:51 <ski> ok
23:33:58 <ezyang> edwardk: The reason I was thinking about this was because one-hole contexts involve differentiation, so I was wondering, "what datatype can be used as a context for itself"
23:34:13 <edwardk> ezyang: yeah a bag. you take one element out and you still have a bag
23:34:34 <edwardk> ezyang: sinh and cosh are bags of odd and even numbers of elements respectively
23:34:37 <ezyang> and then whether or not this would at all be useful as a zipper
23:34:39 <edwardk> so they are each others' derivatives
23:34:49 <ezyang> edwardk: Hah!
23:35:11 <ski> tensorpudding : as i understood it, a monad `m' being ideal just means that there is some `f' such that `m a = a + f a'
23:35:12 <edwardk> x^n/n! is a bag of exactly n elements.
23:35:35 <tensorpudding> How is that well-typed?
23:35:42 <edwardk> x^n/n is a cycle of n elements
23:35:50 <ski> tensorpudding : so you can check whether `ma :: m a' is actually of the form `return a :: m a', for some `a' (which is extracted)
23:35:52 <ezyang> edwardk: *nod*
23:36:01 <edwardk> tensorpudding: you need species or you need an api wrapping it that enforces the appropriate discipline
23:36:05 <tensorpudding> THe book Generatingfunctionology by Wilf is a great read, as an aside
23:36:13 <edwardk> and then the derivative of a cycle is a list ;)
23:36:34 <edwardk> you take one element outof the cycle and it tells you a starting point, the list is the rest of the cycle but you now determined its head
23:36:38 <ski> tensorpudding : e.g. with `data Foo a = Return a | LiftIO (IO a)', you can check whether any `IO' was definitely not performed ..
23:36:40 <tensorpudding> There's at least three things in that I've never heard of or understood.
23:37:10 <ski> (at least, afaiui .. maybe there's problems with `LiftIO (return a)' not being equal to `Return a', though ..)
23:40:03 <edwardk> ezyang: my favorite zipper was found by taking the derivative of an applicative parser. i wound up with a higher order zipper where i knew that the leaves took some token type t, and applied a Match constructor, but that the intermediate types were all existential.
23:40:48 <edwardk> so i could know the type of the root, the and the type of the leaf nodes, but everything in the middle i had to rely on the existentials in my path GADT
23:41:13 <ezyang> That's pretty zonky.
23:41:28 * ezyang is tempted to start zipperifying all sorts of data structures and see what he gets 
23:42:39 <edwardk> data Path root leaf a where AppL :: Path root leaf b -> Grammar leaf (a -> b) -> Path root leaf a ...
23:42:50 <ezyang> I also remember you talking about this several months ago at Boston Haskell, but it didn't really click till now :-)
23:42:50 <kmc> how do we decide what the "division by an integer" operator on types means?
23:43:18 <edwardk> kmc: Joyal has a theory of species that covers that. http://bergeron.math.uqam.ca/Species/especes.html
23:43:42 <ezyang> edwardk: Bah, no PDF :-)
23:45:07 <ski> edwardk : in `a -> b', is the `->' pointing in the "wrong direction", like it customarily does in grammar theory ?
23:45:08 <edwardk> kmc: but in essence the 'number on a string' in a generating function sense *cough* (generating series to appeals Cale) is the number of ways the structure can encode n elements. the division is a quotient over the ways you can discriminate between those structures.
23:45:45 <edwardk> ski: that was because the derivative was to descend into the left side of the applicative, so its a derivative and inversion at the same time
23:46:15 * hackagebot hsbackup 0.1 - simple utility for rolling filesystem backups  http://hackage.haskell.org/package/hsbackup-0.1 (PetrRockai)
23:46:45 <ski> (edwardk : .. like how `Expr --> Atom "+" Expr' really means something like `Expr <- Atom * Plus * Expr' )
23:46:52 <edwardk> ski: there is a similar path of type AppR that descends one level down the right hand side of an App :: Grammar leaf (a -> b) -> Grammar leaf a -> Grammar b constructor
23:47:36 <edwardk> ezyang: lemme see if i can find the paper i wanted to share
23:48:00 <ski> edwardk : hm, it might help if i knew what the type of the corresponding `App' constructor was in the original applicative parser type ..
23:48:10 <edwardk> http://www.cas.mcmaster.ca/~carette/species/
23:48:19 <edwardk> ski: that was the App i just pasted ;)
23:48:37 <ski> .. oh, so you did :)
23:49:08 <ski> edwardk : hm, so is this top-down / direct contexts, or bottom-up / inverted contexts ?
23:49:23 <edwardk> i take a Grammar and then use that Path to turn it inside out so that i'm looking at it from the bottom of the tree.
23:49:46 <ski> hm .. "inside out" seems to imply bottom-up / inverted contexts
23:49:48 <edwardk> in the end i wind up with a Path root leaf leaf
23:50:19 <ezyang> "I think some pictures are in order"
23:50:32 <ski> in that case, i think all is well :)
23:50:43 <edwardk> i start at the root of a Grammar leaf a, and wind up with a [Path a leaf leaf] describing all of the distinct leaf nodes in my parser.
23:50:47 <ski> (i worked through direct vs. inverted contexts of GADTs a few days ago)
23:50:54 <edwardk> i cheat and rederive sharing through stable names in the process
23:51:06 <edwardk> er
23:51:08 <edwardk> sorry
23:51:19 <edwardk> i wind up with a [(Path a leaf leaf, Grammar leaf leaf)]
23:51:32 <edwardk> where the Grammar is known to be a 'Match' node my parser GADT
23:51:36 <ski> the list for the nondeterminism of many leaves ?
23:52:26 <edwardk> well, i don't use my zipper as a zipper i really just wanted to find all of the distinct leaves, and recover the sharing information about how the paths from them can reach the root with all the attendant cycles
23:53:01 <edwardk> that lets me recover the context free grammar that underlies the attribute grammar  represented by my data (not-codata) applicative structure.
23:53:20 <edwardk> pure nodes are epsilons in my grammar, but affect the attribute grammar
23:53:46 <ski> (it might be nice to have a monad with basically a `newRef' and `readRef' and `eqRef' operations, but no `writeRef', to specify sharing ..)
23:53:51 <edwardk> (i need the structure to be 'data' because if its codata i never terminate)
23:54:04 <edwardk> i hate monadic sharing. the APIs look terrible
23:54:04 <ski> (yes)
23:54:08 <edwardk> i've given in and use stablenames
23:54:12 <edwardk> they look so much prettier
23:54:15 <ski> mhm
23:54:18 <edwardk> my sat monad is far happier
23:55:34 <edwardk> with observable sharing i can just use let bindings, throw things in where clauses, and basically the where clause plays the role of that unreadable arrow sugar
23:55:46 <edwardk> you just wire things up with =
23:55:57 <ezyang> edwardk: What does the CFG look like when you pull it out of your parser?
23:56:12 * ski still wonders what the "proper" way of doing that is ..
23:56:24 <ski> (edwardk : also, elaborate on "allowing constructors to define their meaning in the presence of 'overapplication'" ? .. or was that explained in one of those posts ?)
23:56:37 <edwardk> ezyang: well, you could rederive it with the equivalent of andy gill's Data.Reify
23:57:04 <edwardk> > (:) 1 [] 2
23:57:05 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[t2]'
23:57:18 <edwardk> allowing overriding for that
23:57:26 <ezyang> edwardk: Amazing!
23:57:36 <ezyang> oh my
23:57:59 <edwardk> ezyang: but the just is the CFG looks like i built it out of some graph library
23:58:09 <edwardk> er but the cfg just looks like
23:58:19 * ezyang nods 
23:58:36 <ezyang> I'll need to work through the entire derivation myself, but that's cool.
23:58:47 <edwardk> ski: did you see the cheesy 'farray' paste i made earlier demoing arrays you can use like functions?
23:58:51 <edwardk> sure
23:59:08 <edwardk> i was using it for automatically generating _bottom_up_ parallel parsers
23:59:12 <ezyang> (any recommended parser applicative to use?)
