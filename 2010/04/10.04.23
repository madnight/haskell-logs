00:00:17 <c_wraith> DanC: "f g y" is not the same as "f (g y)".  it's the same as "(f g) y"
00:00:49 <ski> DanC : yes, `f(x)' is `f x', but `Leaf f x' is not `Leaf (f x)' (i.e. `Leaf(f(x))', which you intended), but rather `(Leaf f) x' (i.e. `(Leaf(f))(x)') which you didn't intend
00:01:05 <ski> similar for the other equation
00:01:07 <DanC> oh. So where I wrote Double f z I meant Double (f z). (but it even that isn't right)
00:01:23 <ski> right
00:01:27 <ski> you need recursion
00:01:42 <ski> if we correct
00:01:44 <ski>   DanC> mapTree f (Double z) = Double mapTree f z -- maybe?
00:01:45 <ski> into
00:01:55 <ski>   mapTree f (Double z) = Double (mapTree f z) -- maybe?
00:02:02 <ski> then that is closer, but not quite right
00:02:29 <c_wraith> much closer, yes.
00:02:50 <DanC> mapTree f (Double (Leaf l) (Leaf r)) = ... ugh... I'm going backward again. I think I'm too tired.
00:02:54 <ski> the left-hand side is mapping `f :: a -> b' over `Double z :: Tree a', and should return something of type `Tree b'
00:03:46 <ski> DanC : do you agree that we want something like
00:03:56 <ski>   mapTree f (Double z) = Double (..z..)
00:03:57 <ski> ?
00:04:20 * DanC thinks... f :: a -> b might be more clear as f :: levelx -> levelx_plus_1
00:04:45 <ski> you can think of `f :: Int -> String', if you want it more concrete
00:05:00 <ski> (e.g. `f' could be `show :: Int -> String')
00:05:20 <DanC> oooh.
00:05:37 <DanC> so it turns a whole tree of Ints into a tree of Strings.
00:05:42 <ski> yes
00:05:53 <ski> (of course, that's only one possibility)
00:06:16 <DanC> I'm slow to get this parametric polymorphism stuff.
00:07:05 <DanC> mapTree f (Double z) = Double (mapTree f z) -- just to stare at it...
00:07:34 <c_wraith> This is very similar to recursion on lists
00:07:36 * DanC can't see anything wrong with it
00:07:41 <ski> parametric polymorphism is "just" the type-encoding of that `map' doesn't really care what the elements of the structure (list,tree,whatever) is, it just applies its argument function to each element, constructing a new structure with the same "shape"
00:07:57 <DanC> mapTree f (Double z) = case ...
00:08:05 <c_wraith> mapTree f (Double (z1, z2)) = ....
00:08:18 <ski> c_wraith : that's not type-correct
00:08:26 <c_wraith> Oh, I'm backwards
00:08:40 <ski> DanC : assume `f :: Int -> String', ok ?
00:08:49 <DanC> ok
00:09:07 <ski> and then the argument, i.e. `Double z' in this case, should have type `Tree Int'
00:09:23 <ski> (since we're to map `f :: Int -> String' over a tree of `Int's)
00:09:28 <ski> also, since
00:09:37 <ski>   mapTree :: (a -> b) -> (Tree a -> Tree b)
00:09:41 <ski> is our goal
00:10:04 <ski> we should strive for `mapTree f (Double z) :: Tree String' (when `f :: Int -> String')
00:10:19 <ski> that's the left-hand side of the `='
00:10:48 <DanC> left?
00:10:50 <ski> so, we have got the type of `f', now we want to determine the type of `z' as well
00:11:00 <ski>   mapTree f (Double z) = ...
00:11:18 <ski>   ^^^^^^^^^^^^^^^^^^^^ is the left-hand side of `='
00:11:31 <DanC> yes, but... never mind... ok.
00:11:45 <ski> from the definition of `Tree' follows
00:11:50 <ski>   Leaf :: a -> Tree a
00:11:50 <ski> and
00:11:56 <ski>   Double :: Tree (a,a) -> Tree a
00:12:00 <ski> so, if
00:12:05 <ski>   Double z :: Tree Int
00:12:08 <ski> then it must be that
00:12:13 <ski>   z :: Tree (Int,Int)
00:12:16 <ski> ok ?
00:12:37 <DanC> ouch... need to think about that...
00:13:52 * DanC scrolls up to see where we get Double :: Tree (a,a) -> Tree a
00:14:26 <DanC> from defn Tree, backwards
00:14:29 <ski>   data Tree a = Leaf a
00:14:30 <ski>               | Double (Tree (a,a))
00:14:51 <ski> `Leaf' takes an argument of type `a', and of course is a constructor for `Tree a', so `Leaf :: a -> Tree a'
00:14:59 <DanC> ok, I think I'm following. I can't imagine how mere mortals are expected to do this.
00:15:21 <ski> `Double' takes an argument of type `Tree (a,a)', and is also a constructor for `Tree a', so `Double :: Tree (a,a) -> Tree a'
00:15:40 <ski> DanC : with a bit of practice :)
00:16:18 <ski> so, did you follow how we got the type of `z' from the type of `Double z' ?
00:16:27 <DanC> yes
00:16:52 <ski> now, we're "really" after a tree of `Int's here, but the program doesn't "know" that
00:17:24 <ski> from the program's point of view, since `z :: Double (Int,Int)', `z' really *is* a tree of `(Int,Int)'-pairs
00:17:57 <DanC> mapTree f (Double Tree(l, r)) = mapTree f Tree(l, r) -- staring at this now
00:18:13 <ski> not quite there .. :)
00:18:16 <DanC> yes, the lightbulb about (Int, Int) tuples serving as a (or b?) went off at some point
00:18:19 <ski> let's take one step at a step
00:18:53 <ski> `z :: Tree (Int,Int)' is *not* (as someone else above were thinking a short while) a pair of trees
00:19:08 <DanC> mapTree f (Double (l, r)) = mapTree f Tree(l, r) -- staring at this now
00:19:44 <ski> it is a tree, i.e. a bunch of `Double' constructors with a `Leaf' constructor inside them .. and inside that, a nested pair, like `(((0,1),(2,3)),((4,5),(6,7)))'
00:20:18 <ski> DanC : if we had defined `data Tree a = ... | Double (Tree a,Tree a)', that would have been in the right directl
00:20:25 <ski> s/directl/direction/
00:21:04 <ski> but, now we actually had `data Tree a = ... | Double (Tree (a,a))', which is another thing (and, admittedly, slightly harder to wrap your head about)
00:21:30 <ski> let's say we define, for the sake of argument
00:21:42 <ski>   data TreeB a = LeafB a
00:21:55 <ski>                | DoubleB (Tree a,Tree a)
00:22:07 <ski> then, one possible value of this is
00:22:24 <ski> (actually the `Tree's in there should be `TreeB's, i forgot)
00:22:39 <DanC> TreeB doesn't have the balancing constraint, though, right?
00:23:04 <ski>   DoubleB (DoubleB (Leaf 0,Leaf 1),DoubleB (Leaf 2,Leaf 3)) :: TreeB Int
00:23:08 <ski> DanC : exactly
00:23:15 <ski> this is similar to
00:23:23 <ski> (similar, but different)
00:23:40 <ski>   Double (Double (Leaf ((0,1),(2,3)))) :: Tree Int
00:24:02 <ski> and, as you say, `Tree' doesn't allow imbalanced trees, but `TreeB' does
00:24:33 <ski>   DoubleB (LeafB 0,DoubleB (LeafB 1,DoubleB (LeafB 2,LeafB 3))) :: TreeB Int
00:24:45 <DanC> mapTree f (Double Leaf(i) ) = Double (Leaf (f i)) -- base case
00:24:57 <kulin> i have to sit through a programming languages class this quarter, everytime the teacher speaks, all i can think is 'haskell doesnt have that problem'
00:25:13 <ski> i would say you've already convered the base case (barring the bracket problem)
00:25:34 <ski> <DanC> mapTree f (Leaf x) = Leaf f x
00:25:36 <DanC> darn; I was afraid of that.
00:25:36 <ski> i.e.
00:25:46 <ski>   mapTree f (Leaf x) = Leaf (f x)
00:26:07 <ski> usually when mapping, you only have to consider *one* constructor in each case
00:26:46 <ski> so, since you're considering the `Double' constructor in the other case, you don't need to (and probably shouldn't) consider any extra constructor, there
00:27:02 <ski> so
00:27:11 <ski>   mapTree f (Double z) = ...
00:27:22 <ski> is fine, re the left-hand side
00:27:41 <ski> `z' is a tree of type `Tree (Int,Int)', and you don't need to match on it anymore
00:27:48 <ski> DanC : ok ?
00:27:50 <DanC> yes
00:28:26 <ski> you suggested
00:28:28 <DanC> mapTree f (Double z) = Double (mapTree f z)
00:28:29 <ski> <DanC> mapTree f (Double z) = Double mapTree f z -- maybe?
00:28:35 <ski> i.e. .. what you said :)
00:28:58 <ski> and the idea is not that far off .. it just needs to be worked through, and corrected :)
00:29:16 <ski> since we're mapping, we should "replace structure with the same structure"
00:29:30 <DanC> I think I'm too tired to rub 2 brain cells together. I just keep moving the pieces around
00:29:53 <ski> in the base case, the `Leaf' constructor in the input is replaced with a `Leaf' constructor in the output (which holds the output of the argument function applied to the element)
00:30:22 <juhp> mm - ghc has 2375 tests in its testsuite!
00:30:24 <ski> and, in the recursive case, we similarly should replace `Double' with a `Double', just making sure to recur in a sane way
00:30:57 <ski> so, let's say
00:31:08 <ski>   mapTree f (Double z) = Double (..f..z..)
00:31:10 <ski> so far
00:31:32 <DanC> f should get applied twice, no?
00:31:41 <DanC> i.e. we have to branch somehow
00:31:42 <ski> DanC : if you think you're too tired, maybe we should continue this another day .. your choice
00:31:50 <DanC> I dunno how to get to the parts of z
00:32:03 <ski> yes, we have to "branch somehow" .. that is the rub of the problem .. how to do that ?
00:32:53 <ski> the parts of `z' are all lying *beneath* a load of more `Double' constructors (which lies over the single `Leaf' constructor, which is wrapping the nested pair)
00:33:41 <ski> what we've managed to do, so far is to remove the top `Double' constructor in the "plate stack"
00:34:06 <ski> we can really only continue to do so, until we reach the `Leaf' (the bottom of the "plate stack")
00:35:20 <ski> also, if/when ever we manage to map over `z', (having moved all but the top `Double' back again "on the stack"), we finally move the top `Double' back again
00:35:23 <ski> i.e.
00:35:26 <ski>   mapTree f (Double z) = Double (..f..z..)
00:35:53 <ski> DanC : is my analogue working ?
00:36:09 <DanC> the plates? yes, they make sense
00:36:46 <ski> so, hopefully it makes sense now that we should continue the recursion, i.e. call `mapTree' inside that call to `Double'
00:36:55 <ski> i.e. we should have
00:37:08 <ski>   mapTree f (Double z) = Double (mapTree.....)
00:37:30 <ski> (moving closer to your suggestion, but not quite going to it)
00:37:40 <ski> now, it's handy to examine the types, again
00:37:42 <ski> we know
00:37:49 <ski>   f :: Int -> String
00:37:56 <ski>   Double z :: Tree Int
00:38:04 <ski>   mapTree f (Double z) :: Tree String
00:38:14 <ski>   z :: Tree (Int,Int)
00:38:18 <ski> ok ?
00:38:20 <DanC> yes
00:38:54 <ski> so, since `mapTree f (Double z)' is claimed to be equal to `Double (mapTree.....)' by the defining equation .. they should have the same type !
00:38:58 <ski> i.e., we also have
00:39:07 <arcatan> hmm. planet.haskell.org isn't working.
00:39:08 <ski>   Double (mapTree.....) :: Tree String
00:39:51 <ski> DanC : ok with that ?
00:40:12 <DanC> right, so I'm trying to figure out how to apply f to the 2 ints to get 2 strings so that Double work get us back to one String (in Tree String)
00:41:16 <ski> (another way of saying the same thing : since `mapTree' is meant to return something of type `Tree String' when passed `f :: Int -> String', and `Double z :: Tree Int'; obviously the expression that we actually return, i.e. `Double (mapTree.....)' must then *have* the return type `Tree String')
00:41:30 <DanC> I guess there's a lot of Ints. in fact, I'm starting to wonder how the base case works.
00:41:43 <ski> you will see in a short while :)
00:41:54 <ski> let's go look at
00:41:59 <ski>   Double (mapTree.....) :: Tree String
00:42:18 <ski> you got how we derived the type of this return expression, right ?
00:42:22 <DanC> yes
00:42:39 <DanC> the only ways to get a Tree String is from a Double(String, String) or a Leaf(String)
00:42:42 <ski> so, similarly to how we derived the type of `z' from the type of `Double z', we do that same here
00:42:49 <ski> i.e., since
00:42:59 <ski>   Double :: Tree (a,a) -> Tree a
00:43:00 <ski> and
00:43:02 <ski>   Double (mapTree.....) :: Tree String
00:43:04 <ski> we must have
00:43:12 <ski>   mapTree..... :: Tree (String,String)
00:43:14 <DanC> the mapTree... :: Tree (String, String)
00:43:19 <ski> exactly :)
00:43:37 <ski> so, now we're reaching the interesting parts
00:43:57 <ski>   mapTree :: (a -> b) -> (Tree a -> Tree b)
00:44:02 <ski> was the type of `mapTree'
00:44:30 <DanC> oh... so we have to conjure a new f'
00:44:32 <ski> and here we "have" (it's not written yet) an expression `mapTree.....' of type `Tree (String, String)'
00:44:43 <ski> so, we actually want to use `mapTree' in the special case
00:45:13 <ski>   mapTree :: (a -> (String,String)) -> (Tree a -> Tree (String,String))
00:45:14 <ski> here
00:45:23 <DanC> mapTree ((l, r) -> (f l, f r)) ...
00:45:24 <ski> otherwise, we couldn't get to `Tree (String,String)'
00:45:40 <ski> and, *which* tree should we recursively map over ?
00:46:06 <DanC> z?
00:46:13 <ski> DanC : you're closing in on the solution, i see :)
00:46:24 <ski> yes, the only available trees are `z' and `Double z'
00:46:40 <ski> and it's no use to use `Double z' .. since why did we take it apart then ?
00:46:43 <ski> and we have
00:46:48 <ski>   z :: Tree (Int,Int)
00:46:51 <ski> so, actually
00:46:56 <ski>   mapTree :: (a -> (String,String)) -> (Tree a -> Tree (String,String))
00:46:58 <ski> must then be
00:47:06 <ski>   mapTree :: ((Int,Int) -> (String,String)) -> (Tree (Int,Int) -> Tree (String,String))
00:47:14 <ski> in the recursive call, as you're already guessing
00:47:22 <ski> so, we have
00:47:23 <DanC> mapTree (Double z) = Double( mapTree g z) where mapTree (l, r) = (f l, f r) -- something like that?
00:47:27 <DanC> phpht
00:47:33 <DanC> mapTree (Double z) = Double( mapTree g z) where g(l, r) = (f l, f r) -- something like that?
00:47:59 <ski> that's right ! (except you're missing the `f' on the left-hand-side)
00:48:10 <DanC> mapTree f (Double z) = Double( mapTree g z) where g(l, r) = (f l, f r) -- something like that?
00:48:16 <ski> yes, that's right
00:48:22 <ski> you can also write this as
00:48:30 <DanC> the g(l,r) is OK? that's how you apply g to a 2-tuple?
00:48:39 <ski>   mapTree f (Double z) = Double (mapTree (\(l,r) -> (f l,f r)) z)
00:48:47 <ski> that is the same as
00:48:55 <ski>   mapTree f (Double z) = Double (mapTree g z)
00:48:57 <ski>     where
00:49:02 <DanC> I wasn't sure how to combine tuple notation with lambda
00:49:04 <ski>     g (l,r) = (f l,f r)
00:49:17 <dobblego> @type join (***)
00:49:18 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
00:49:22 <ski> a tuple is just a single value that happens to contain a bunch of values
00:49:38 <dobblego> @type uncurry (join (***))
00:49:39 <ski> `g' is a normal function, taking one argument, which happens to be a pair
00:49:39 <lambdabot> forall b c. (b -> c, (b, b)) -> (c, c)
00:49:51 <dobblego> @type uncurry . join (***)
00:49:52 <lambdabot>     Couldn't match expected type `b -> c'
00:49:52 <lambdabot>            against inferred type `(c1, c1)'
00:49:52 <lambdabot>     Probable cause: `***' is applied to too many arguments
00:50:01 <DanC> yes, but \(l,r) uses pattern matching or some such
00:50:11 <SonOfLilit> Good morning
00:50:21 <dobblego> hello SonOfLilit
00:50:36 <ski> as dobblego is hinting, you can also write `\(l,r) -> (f l,f r)' as `f *** f' (which one small difference which we can gloss over here)
00:50:39 <SonOfLilit> I'd be very thankful if someone would volunteer to review my code
00:51:13 <SonOfLilit> I'm trying to learn Haskell, and it would do me much good to get evaluated by someone more experienced
00:51:18 <ski> DanC : yes, pattern-matching is possible in lambda-notation, as well .. though usually you'd only match on patterns which you know can't fail
00:51:19 <SonOfLilit> http://github.com/SonOfLilit/ahscheme/blob/master/ahscheme.hs
00:51:46 <DanC> the space complexity of mapTree looks pretty high.
00:51:53 <ski> DanC : so, maybe we should walk through a simple example to see how the recursion works ?
00:52:13 <DanC> I see how it works now, I'm pretty sure
00:52:16 <ski> (the space complexity of `mapTree' should be linear in the number of nodes)
00:52:32 <ski> ok
00:52:56 <DanC> linear... hmm... thinking about that...
00:53:00 <ski> <DanC> I guess there's a lot of Ints. in fact, I'm starting to wonder how the base case works.
00:53:07 <ski> the answer to that is just
00:53:13 <SonOfLilit> would anyone have a look, or should I stop waiting and just continue coding?
00:53:15 <ski>   mapTree f (Leaf x) = Leaf (f x)
00:53:40 <ski> though, for trees with more element, when this is reached, `x' is actually not just a single "element", but a nested pair of elements
00:53:43 <DanC> at that point, f takes a 2^n tuple, where n is the depth of the tree
00:53:56 <DanC> SonOfLilit, you haven't hinted at what your code does
00:53:58 <ski> and the `f' there is the original `f', but modified so that it works over the nested tuple
00:54:02 <dobblego> SonOfLilit, I'll take a look, but I warn you that I am on extremely strong narcotic drugs at the moment (though I can see some obvious improvements)
00:54:05 <DanC> or why anyone would want to look
00:54:47 <SonOfLilit> DanC: My code is a reimplementation from memory of the beginning of the "Make a scheme in 48 hours" tutorial
00:54:48 <ski> DanC : anyway, the rub of polymorphic recursion is this :
00:54:55 <ski> the type of `mapTree' is
00:55:03 <ski>   mapTree :: (a -> b) -> (Tree a -> Tree b)
00:55:10 <DanC> how many f's does the compiler make, I wonder? I guess just 1 new one?
00:55:35 <SonOfLilit> I was assuming - correctly, it appears - that I didn't internalize enough of what was written by simply typing the code exactly as it was presented, so I chose to implement it again without looking at the tutorial
00:55:38 <ski> but the type of `mapTree', used in the *recursive*call*, is the *specialized*version* of that :
00:55:50 <SonOfLilit> dobblego: Thank you :)
00:55:55 <ski>   mapTree :: ((a,a) -> (b,b)) -> (Tree (a,a) -> Tree (b,b))
00:56:18 <ski> DanC : it makes a new `f' for each recursive step, i.e. for each `Double' constructor it passes
00:56:40 <ski> so if the tree has `2^n' elements, then it makes `n' new versions of `f'
00:56:45 <SonOfLilit> currently, I have a parser for things like "( this   is the 2 nd (scheme parser) "that I've written" !)
00:57:04 <DanC> you mean new closures, not new compiled code, right? the compiler is not around a run-time, is it?
00:57:31 <ski> so, the would be logarithmic space complexity in terms of the number of elements, which is dwarfed by the number of calls to the final `f' to each element
00:57:43 <ski> new closures, yes
00:58:33 <ski> DanC : anyway, looking at
00:58:35 <DanC> I was thinking that the args to the specialized f got populated on the way down... but they don't. it's just log n closures and then n calls to the original f. cute.
00:58:41 <ski>   mapTree :: (a -> b) -> (Tree a -> Tree b)  -- general type
00:58:50 <ski>   mapTree :: ((a,a) -> (b,b)) -> (Tree (a,a) -> Tree (b,b))  -- type used in recursive call
00:59:11 <DanC> yeah... that's the sort of stuff that makes my head hurt
00:59:14 <ski> we see that the type used in the recursive call is *not* the *same* as the general polymorphic type (it is an instance of it)
00:59:21 <ski> and *that* is polymorphic recursion
00:59:26 <ski> if you have
00:59:31 <ski>   length :: [a] -> Int
00:59:31 <DanC> using (a, a) as an instance of a
00:59:38 <ski> then the recursive call will still be
00:59:42 <ski>   length :: [a] -> Int
00:59:50 <ski> so, if you want, you could define it like
00:59:57 <ski>   length :: [String] -> Int
01:00:01 <ski>   length [    ] = 0
01:00:10 <ski>   length (s:ss) = 1 + length ss
01:00:18 <ski> and that would work
01:00:43 <ski> but, you can't do that for a function that is polymorphically recursive, you really *need* to define it as a polymorphic recursion
01:01:17 <ski> usually polymorphic recursion appears because we have defined *non-regular* parametric data types like
01:01:34 <ski>   data Tree a = Leaf a
01:01:35 <ski>               | Double (Tree (a,a))
01:02:07 <ski> this is not "regular", because you don't just use `Tree a' (the type being defined, to the left of the `=') recursively
01:02:20 <dobblego> SonOfLilit, just some obvious things http://paste.pocoo.org/show/205225/
01:02:34 <ski> instead you "call `Tree' recursively" with another argument than `a' (i.e. `(a,a)', here)
01:03:13 <ski> (mind, in some cases, you *can* get polymorphic recursion even if you're working with normal "regular" data types .. but it's not that common)
01:03:27 <DanC> the haskell standard library (in the report) looks pretty small. I guess the rest is more of a CPAN approach than the python batteries-included approach?
01:03:38 <ski> DanC : i think that sums it up, if you don't have any more comment or question on it
01:03:44 <DanC> are there good high-performance IO libraries? non-blocking, async, and all that?
01:04:00 <DanC> no, thanks, ski
01:04:10 <ski> ok
01:04:12 * ski bows
01:06:54 <DanC> so... where's the mutable data?
01:07:08 <DanC> I've looked at record update and arrays, and both of them seem to be copy-on-write
01:07:23 <ski> there's `IORef', there's `IOArray', there's version of that for `ST'
01:07:40 <ski> there's `MVar' and `Chan' and `SampleVar' for concurrency
01:07:59 <dv-> DanC: check out hackage.haskell.org
01:08:07 <ski> for STM, there's `TVar' (and probably an array type, too, but i don't use STM much)
01:08:44 <DanC> hackage seems analagous to CPAN... unless I've missed a layer of peer-review/QA/policy
01:08:52 <Cale> Yeah, there's TVar, TMVar, TChan, and TArray
01:08:56 <ski> mutable data are generally handled through monads, usually one of `IO',`ST s',`STM' (or something built from them)
01:10:01 <ski> `DiffArray' does copy-on-write, sortof, and doesn't require living in a monad, but is considered a bit inefficient
01:10:41 <DanC> wild... an HTML 5 package ( http://hackage.haskell.org/package/tagsoup ). is that a re-implementation or a wrapper?
01:11:12 <ski> often immutable (/"functional") update is enough, though, so you construct new tree nodes on the changed path, and use record update (but the syntax is not the best, there)
01:12:21 <ski> sometimes, you want to do local updates in a datastructure, moving about locally .. here zippers can help
01:12:49 <ski> also, functional references / lenses / accessors for representing a location in a data structure
01:14:08 <DanC> I asked whether "In Haskell, we de-emphasise code that modifies data. " was an understatement, and somebody said no, code that modifies data is possible. Is it possible in haskell? or only in C extensions or some such?
01:14:53 <ski> it is possible in haskell, using `IORef', or `IOArray' or similar
01:15:04 <DanC> how is IORef implemented?
01:15:12 <ski> by the compiler
01:15:17 <ski> its a primitive type
01:15:26 <ski> just like `Int' and `(->)'
01:15:26 <roconnor> ski: though techinically speaking that code doesn't by itself modify data, it is simply instructions to modify data :)
01:15:56 <DanC> that doesn't sound like "in haskell" to me
01:16:06 <ski> roconnor : yeah, but shifting to the kleisli category, it does modify data :)
01:16:14 <roconnor> :)
01:16:31 <roconnor> DanC: so it depends on your perspective
01:17:00 <ski> DanC : you're correct that Haskell doesn't provide any means for creating "really mutable" data structures, apart from builting them out of `IORef',`IOArray', &c.
01:17:21 <ski> DanC : otoh, a function of type `State -> State' in a sense is modifying a `State'
01:17:27 <roconnor> to use a very misleading analogy, it is like whether objects change state over time, or whether the universe is one big static spactime continum
01:17:27 <DanC> @google IORef
01:17:28 <lambdabot> http://cvs.haskell.org/Hugs/pages/libraries/base/Data-IORef.html
01:17:28 <lambdabot> Title: Data.IORef
01:17:41 <ski> so, as roconnor says, it depends on your perspective, whether it's "real modification" or not
01:18:52 <ski> DanC : that `STArray' uses "real in-place modification" is a "compiler optimization" that can't be observed (except possibly that your code is faster and uses less space)
01:19:26 <ski> in theory, a Sufficiently Smart Compiler could replace many uses of functions of type `State -> State' with "real in-place modification" as well
01:19:37 <DanC> I don't see stuff like IORef and STArray in the report; are they specific to one compiler?
01:19:50 <ski> in practice, that is not that common .. except in the language Clean (which is sort of a sister language to Haskell)
01:20:51 <DanC> where do I find this State thingy?
01:21:22 <roconnor> huh, I don't see IORef in the 98 report either
01:21:34 <roconnor> maybe giveing formal semantics to IO won't be so hard afterall
01:23:33 <dv-> DanC: Control.Monad.State
01:24:23 <DanC> @google Control.Monad.State
01:24:24 <lambdabot> http://cvs.haskell.org/Hugs/pages/libraries/mtl/Control-Monad-State.html
01:24:24 <lambdabot> Title: Control.Monad.State
01:24:45 * DanC wonders how that relates to hackage
01:25:05 <dv-> That's from Hugs though. You probably want the ghc docs
01:25:59 <ski> DanC : my `State' above was just an example, e.g. it could be `data GameState = ...'
01:26:24 * DanC still struggles to read: class Monad m => MonadState s m | m -> s
01:26:36 <DanC> Monad m is a context
01:26:46 <ski> `IORef' and `IOArray' and `STRef' and `STArray' are "standard extensions" .. i'm not quite sure where in the documentation they are described, though
01:27:03 <dv-> DanC: http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
01:28:07 <DanC> heh... "RealWorld is deeply magical." -- http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.1/Control-Monad-ST.html
01:28:23 <ski> `class Monad m => MonadState s m | m -> s' is read as "`MonadState' is a type class with two arguments. to make an instance of `MonadState s m', there must already be an instance of `Monad m', also for each `m', there can be at most one `s' having an instance `MonadState s m'"
01:28:36 <Axman6> DanC: it's one of the few types that the compiler treate specially
01:28:40 <Axman6> treats*
01:30:20 <ski> DanC : in GHC, `IO' is implemented roughly as `data IO a = IO (RealWorld -> (a,RealWorld))'
01:30:54 <ski> (so, in this case, my `State' example from above would be `RealWorld', the current state of the world outside the running program)
01:31:37 <ski> @type random
01:31:38 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
01:32:25 <ski> `random' is a function that takes a pseudo-random generator (seed) of type `g', and produces a random element of type `a' and a new generator of type `g'
01:32:45 <ski> if you call `random' again on the original generator (seed), you get the same result of type `a'
01:33:15 <ski> to get a different random value next time, you must use the "next" generator (seed), continuing with the most recent one
01:33:23 <DanC> an instance of Monad m? really? I was reading it as "given m is an instance of Monad, ..."
01:33:29 <ski> (btw, being able to reuse earlier seeds is useful for debugging)
01:33:40 <ski> DanC : yes, that's the same thing
01:33:55 * DanC whimpers
01:34:23 <SonOfLilit> dobblego: Thank you very much
01:34:29 <ski> "given `m' is an instance of Monad, you can make `s' and `m' an instance of `MonadState'" is the same as "`MonadState' is a type class with two arguments. to make an instance of `MonadState s m', there must already be an instance of `Monad m'"
01:34:30 <SonOfLilit> I'm going over the diff
01:34:42 * roconnor still prefers the IOTree explaination of IO.
01:34:42 <SonOfLilit> sorry that it took me a while, I was deep into some writing
01:34:46 <SonOfLilit> what does join do?
01:35:42 <SonOfLilit> oooh, the awesomeness of Haskell's laziness keeps hitting me in unexpected moments
01:35:44 <root___> hello
01:35:47 <ski> SonOfLilit : when an action `join m' is executed, first `m' is executed, yielding a result that is also an action. then *that* action is executed (and the result of that is the result of the whole `join m' action)
01:35:55 <root___> disconnect
01:35:56 <ski> @type join
01:35:57 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
01:35:59 <ski> e.g.
01:36:08 <ski>   join :: IO (IO Int) -> IO Int
01:36:09 <ski> or
01:36:24 <ski>   join :: Parser (Parser SExp) -> Parser SExp
01:36:28 <ski> or
01:36:36 <ski>   join :: [[a]] -> [a]
01:36:49 <ski> (i'll let you figure out what that last one does ..)
01:38:35 <ski> DanC : anyway, the `State' monad, and `MonadState' is meant to abstract over the tedium of writing and using functions like `random :: StdGen -> (Int,StdGen)', making sure you don't goof up and use an earlier seed when you shouldn't
01:39:00 <ski> @type State random
01:39:01 <lambdabot> forall s a. (Random a, RandomGen s) => State s a
01:39:11 <SonOfLilit> so if parsesTo String -> String -> Test, why is parsesToIdentity = join parsesTo the same as parsesToIdentity a = a `parsesTo` a ?
01:39:27 <ski> SonOfLilit : that is because
01:39:36 <ski>   instance Monad (a ->)
01:39:53 <ski> in this monad, `join' works like
01:40:16 <ski>   join :: (e ->) ((e ->) a) -> (e ->) a
01:40:17 <ski> i.e.
01:40:35 <ski>   join :: (e -> (e -> a)) -> (e -> a)
01:40:35 <ski> i.e.
01:40:42 <ski>   join :: (e -> e -> a) -> (e -> a)
01:40:44 <ski> defined by
01:40:52 <ski>   join f a = f a a
01:41:27 <SonOfLilit> mmm, I've totally lost you
01:41:36 <SonOfLilit> firs, what is (x ->)?
01:41:45 <ski> so, using `join f' to mean `\x -> f x x' is a neat little trick that some find cute and some find irritating
01:42:09 <ski> `(->)' is a type constructor, like `Maybe' and `Either'
01:42:23 <ski> it just happens to be usually written infix, as an operator
01:42:31 <ski> so
01:42:35 <ski>   instance Monad (a ->)
01:42:36 <SonOfLilit> really?
01:42:37 <ski> i.e.
01:42:43 <ski>   instance Monad ((->) a)
01:42:44 <SonOfLilit> that's surprising
01:42:45 <SonOfLilit> wow
01:42:47 <ski> is similar to writing
01:42:57 <ski>   instance Monad (Either a)  -- and this is a valid monad, yes
01:44:20 <ski> (note, afaik, it is not allowed to actually write `(a ->)' in code, you have to write `(->) a' .. but since we can write `(3 /)' instead of `(/) 3', i think we should be able to write `(a ->)' in types as well .. and it is handy when explaining, i think)
01:44:42 <DanC> is it sort of normal/idiomatic that http://hackage.haskell.org/packages/archive/fgl/5.4.2.2/doc/html/Data-Graph-Inductive-Graph.html#t%3ANode gives type Node = Int rather than leaving the type abstract?
01:45:50 <SonOfLilit> what is the idiomatic way to choose between $ and . ?
01:45:53 <ivanm> DanC: there are reasons for having it
01:46:06 <ski> i'm not sure why Erwig doesn't keep `Node', &c. abstract there
01:46:06 <ivanm> SonOfLilit: . is for function composition, $ is for function application
01:46:09 <DanC> performance?
01:46:11 <ivanm> ski: because it's old
01:46:18 <ivanm> DanC: to an extent, yes
01:46:26 <ivanm> especially if you use something like a Map
01:46:27 <ski> i'd either keep them abstract (with extraction operations), or at least use `data' or `newtype'
01:46:29 <SonOfLilit> ivanm: yes, but in many cases code could use both
01:46:41 <ivanm> the RoseTree module uses an IntMap IIRC
01:46:52 <ivanm> SonOfLilit: right, you can usually use $ instead of . (but not vice versa)
01:46:54 <ivanm> in that case, use .
01:47:02 <ski> SonOfLilit : i usually prefer to use `.' to `$', when possible (without much more unreadable code)
01:47:02 <SonOfLilit> I mean, (.) is very different from ($), but iiuc a . b c == a $ b c
01:47:11 <ivanm> e.g. f . g . h $ x is nicer than f $ g $ h $ x
01:47:16 <Jafet> SonOfLilit, are you composing behaviour or applying functions?
01:47:22 <ivanm> SonOfLilit: that isn't true
01:47:36 <ivanm> SonOfLilit: (a . b c) d == a $ b c d
01:47:49 * Jafet finds some way to sneak in the word "idiomatic"
01:47:59 <ivanm> DanC: note that in my kinda free time I'm working on a new set of graph classes that does leave the node type abstract
01:48:14 * ski gently passes Jafet through an applicative functor
01:48:28 <SonOfLilit> why is . preferred/
01:48:31 <SonOfLilit> ?*
01:48:31 <lambdabot> Maybe you meant: . ? @ v
01:48:41 <ivanm> SonOfLilit: because its less intrusive then $
01:48:41 <DanC> ugh... haskell has the import * problem. When I'm reading http://hackage.haskell.org/packages/archive/fgl/5.4.2.2/doc/html/src/Data-Graph-Inductive-Query-MaxFlow.html#augmentGraph and I see insEdges , I have to look at all the imported modules to see which one it comes from
01:48:48 <ivanm> and usually its used in places where you _can't_ use $
01:49:00 <ivanm> DanC: "import * problem"?
01:49:05 <ivanm> you mean where modules get re-exported?
01:49:10 <ski> SonOfLilit : in `f . g . h . i $ x', all of `f . g . h',`g . h . i',`f . g',`g . h',`h . i' can be considered valid subexpressions
01:49:28 <DanC> http://www.upfrontsystems.co.za/Members/izak/sysadman/import-considered-harmful
01:50:03 <ivanm> SonOfLilit: "f . g . h" /= "f $ g $ h"
01:50:03 <ski> SonOfLilit : so if you want to factor out a part, you can just cut out, and replace with your new identifier, as opposed to the case with `$' (which is often not *that* much harder, but still)
01:50:44 <Jafet> DanC, parseltongue is evil.
01:50:45 <ivanm> DanC: in most cases, that isn't a problem
01:50:52 <ivanm> (since you should be doing explicit imports anyway)
01:50:57 <Jafet> So is blithe imitation of Dijkstra.
01:51:01 <ivanm> (and because functions like that rarely clash)
01:51:15 <ski> DanC : yes, that's why some want to only/mostly use qualified imports : `import qualified Data.Map as DM'
01:51:16 <ivanm> Jafet: parseltongue is evil? really?
01:51:23 <ivanm> so a non-existent language is evil?
01:51:36 <ivanm> ski: why qualified imports over explicit imports?
01:51:40 <Jafet> It would be more evil if it existed!
01:52:08 <DanC> haskell makes it harder to explicit/qualified imports than unqualified?
01:52:19 <DanC> grates against my style
01:52:21 <quicksilver> DanC: arguably that problem would be solved by better tools (which could tell you where insEdges comes from)
01:52:23 <ivanm> DanC: it does?
01:52:27 <ivanm> not that much harder...
01:52:29 <quicksilver> DanC: but, yes, I basically agree.
01:52:36 <ski> ivanm : explicit imports is also possibly, but then you still have to vgrep (or ..) the `import' lists .. which a well-chosen mnemonic, you can faster see which module imported something
01:52:38 <ivanm> DanC: are you asking a question?
01:52:39 <ivanm> :p
01:52:42 <quicksilver> explicit imports are a pain so nobody can be bothered to do them.
01:52:48 <quicksilver> (for some value of 'nobody')
01:52:52 <quicksilver> again, tool support would help.
01:53:00 <DanC> my question is: should I expect to be able to navigate thru haskell code without tools?
01:53:05 <ivanm> ski: yet I find too many qualified imports makes code harder to read due to too many qualifications littering the code
01:53:12 <quicksilver> DanC: you can't in any other language :)
01:53:12 <DanC> the way I can with python, and the way I cannot with Java?
01:53:15 <ivanm> DanC: sure, why not?
01:53:22 <ski> quicksilver : fwiw, i often do explicit imports (including writing type signatures in comments) ;)
01:53:34 <quicksilver> ski: you're obviously 'nobody' then :)
01:53:34 <ivanm> ski: in your import list you mean? :o
01:53:36 <DanC> the python community is largely agreed that import * is poor style
01:53:39 <ivanm> ski: have any samples then?
01:53:54 <ivanm> quicksilver: they're not _that_ much of a pain
01:53:55 * ski is nobody, it is confirmed ! :)
01:53:57 <DanC> so you can follow-your-nose thru python code
01:54:06 <DanC> the Java community is the other way; they assume you have tools
01:54:06 <ivanm> the only part of the "pain" is having to add another import when you want it
01:54:34 <quicksilver> DanC: no you can't.
01:54:34 <ivanm> DanC: I don't follow your examples; when I did Java I looked at documentation to see where something came from (but I didn't use many external libs)
01:54:40 <ski> ivanm : but, yes, there's a tradeoff between qualified imports and other means
01:54:43 <quicksilver> DanC: much of python code is method calls.
01:54:46 <ivanm> and I didn't do that much python programming
01:54:51 <ivanm> ski: *nod*
01:55:02 <quicksilver> DanC: method calls aren't specifically listed even in explicit imports
01:55:18 <quicksilver> DanC: and since python is dynamically typed I can't even reliably decide what the class of an object is.
01:55:21 <DanC> in python, it's typical to avoid inline qualifications a la: from urllib import urlparse
01:55:31 <Cain_> I seem to remember a search engine for haskell documentation where you can search by function signature, yet a can't find it. Does such a thing exist? And if so, what is it called?
01:55:33 <DanC> then you can just use urlparse() rather than urllib.urlparse()
01:55:39 <ivanm> Cain_: hoogle and hayoo
01:55:41 <ivanm> @where hoogle
01:55:41 <lambdabot> http://haskell.org/hoogle
01:55:43 <ivanm> @where hayoo
01:55:43 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
01:55:44 <Cain_> ahah!
01:55:50 <Cain_> thanks
01:55:53 <ivanm> @hoogle g a b -> Int -> a
01:55:53 <lambdabot> Data.Graph.Inductive.Graph lab :: Graph gr => gr a b -> Node -> Maybe a
01:55:53 <lambdabot> Control.Monad.State.Lazy execState :: State s a -> s -> s
01:55:53 <lambdabot> Control.Monad.State.Strict execState :: State s a -> s -> s
01:55:55 <DanC> but given a call to urlparse(), you can follow your nose to the import statement at the top to see where it came from
01:56:01 <quicksilver> DanC: but if you have an object 'foo' and you see "foo.bar()' you have no idea which source file to go to get the source of bar()
01:56:17 <ivanm> Cain_: hoogle seems to produce better results (IMHO), but hayoo indexes all of hackage so it has more results
01:56:26 <Cain_> okay
01:56:29 <quicksilver> DanC: ...and code which heavily uses objects is quite idiomatic python, or that's how it seems to me.
01:56:37 <DanC> quaestor, true...
01:56:41 <DanC> er...
01:56:57 <quicksilver> so I don't honestly think the python situation is any better (or worse) than the haskell one
01:57:01 <ski> (DanC : you can say `import Monad (mapM)', if that's one thing you're wondering about)
01:57:03 <DanC> quicksilver, true about foo.bar()... but foo's class is usually/often documented
01:57:18 <quicksilver> but foo itself could be returned as "foo = baz.bam()"
01:57:27 <quicksilver> and then we need to find the source of bam() to even guess what the class of foo is
01:57:30 <DanC> my question is not (mainly) what I can say, but what is typical for other haskell hackers to say
01:57:39 <DanC> i.e. what I can expect when I read haskell code
01:57:40 <quicksilver> ..in order to find out what bar() does
01:58:27 * ski typically uses explicit imports, sometimes qualified import .. barring `Prelude' and sometimes some other modules
02:04:20 * ski drops a needle on the floor
02:04:20 <bastl> Hello. Is anyone aware of a good webclient to access this channel ?
02:04:30 <Bjorn^2> mibbit?
02:05:31 <ivanm> the freenode one is better
02:07:22 <fasta> You cannot use mibbit on Freenode.
02:07:42 <fasta> So, clearly the freenode one is better, because it is the only one. ;)
02:07:52 <Bjorn^2> sorry, didn't knew that
02:09:12 <bast_web> hi from java.freenode ...
02:09:18 <bastl> hi
02:09:26 <bastl> hmm
02:09:41 <bastl> thanks ivanm.
02:09:55 <ivanm> no worries
02:10:03 <ivanm> fasta: I hate mibbit anyway
02:10:24 <fasta> ivanm, and why would that be?
02:10:37 <ivanm> the continual ads
02:10:48 <fasta> ivanm, heh, I have never seen an ad.
02:10:50 <ivanm> how it keeps flashing the tab as soon as I look at a different tab in firefox
02:11:12 <fasta> ivanm, ok, that's a personal thing.
02:15:28 <bastl> Hmm. never noticed that my host is shown like this. Is that dangerous ? Are there simple means to obfuscate it ?
02:17:36 <fasta> bastl, the military could triangulate your position and nuke you, so it is very dangerous.
02:18:34 <Axman6> bastl: you can request a hostmark cloak in #freenode, thought you may need to sponsor them first
02:18:46 <bastl> no seriously. this channel is quite crowded, and i'm no experienced IRC-Geek, Is it possible and should I obfuscate my IP ?
02:18:51 <fasta> bastl, clocks are free.
02:19:04 <fasta> bastl, cloacks*
02:19:16 <Axman6> -c
02:19:17 <xerox> cloaks*
02:19:23 <silver> bastl, you shouldn't
02:19:37 <bastl> i guess i should keep my host safe, eh?
02:19:45 <Axman6> no really
02:19:47 <silver> no one cares on IRC.. bout anything
02:19:49 <fasta> bastl, if you want "protection", just don't use a system you don't understand.
02:20:12 <bastl> I'm not sure if I understand my car ...
02:20:23 <bastl> or my bank
02:20:26 <fasta> bastl, and lots of people die in cars, see the correlation.
02:20:34 <bastl> right :-)
02:21:03 <Younder> if you cloak you IP (Tor etc) you can be expelled. IRC doesn't like zero accountabillity..
02:21:04 <fasta> bastl, the American revolution was because people didn't like that banks.
02:21:05 <bastl> But it has safety-belts ...
02:21:15 <fasta> bastl, the banks*
02:21:25 <fasta> bastl, see, not a lot has changed.
02:21:44 <bastl> Nah. getting OT and procastinating ...
02:21:49 <bastl> lunch calls.
02:22:06 <Younder> The american revolition is a fight againt the whole idea of a upper class..
02:22:14 <burp> Younder: freenode has a tor server
02:22:36 <burp> as a hidden service
02:25:29 <Adamant> The American Revolution, like every other political event, is a bunch of different things to different people.
02:25:39 <ivanm> bastl: I prefer it when the hostmask isn't cloaked, as it gives me an idea of where someone is from (as in which country)
02:25:53 <ivanm> that way it explains why they aren't answering me when it's 3AM for them ;-)
02:34:22 * hackagebot IrrHaskell 0.1.1 - Haskell binding to the Irrlicht game engine.  http://hackage.haskell.org/package/IrrHaskell-0.1.1 (MaciejBaranski)
02:45:26 * hackagebot hsp 0.5.1 - Haskell Server Pages is a library for writing dynamic server-side web pages.  http://hackage.haskell.org/package/hsp-0.5.1 (NiklasBroberg)
02:52:57 <avsm> hi, I've got a fresh cabal install from macports on snow leopard, and am trying to install Epic; but 'cabal install —user' gives me a rather mysterious error message: "cabal:  : does not exist"
02:53:21 <avsm> does cabal need some setup before using it? I deleted ~/.cabal and did "cabal update", same error
02:55:40 <Axman6> > logBase 2 99000000000
02:55:41 <lambdabot>   36.526709474065875
03:05:05 <dv-> avsm: try without -user?
03:25:18 <ivanm> @. elite keal
03:25:18 <lambdabot> bE+TEr b3 A+L3asT 16X16 (O1OR Wi7|-| 3x7eNDeD Az(Ii Se7
03:27:01 <xerox> @keal
03:27:01 <lambdabot> are you saying i am MegaMonad?
03:27:03 <xerox> @keal
03:27:04 <lambdabot> can haskell pipe the raw irrational megaequation into an analog device
03:27:12 <xerox> did he really say that
03:27:51 <ivanm> presumably
03:27:53 <ivanm> @help keal
03:27:53 <lambdabot> keal. Talk like Keal
03:32:18 <Adamant> @. elite nixon
03:32:18 <lambdabot> i P1aYeD 8Y TH3 RuLEz oF P01iti(5 az0rz I fouND +HEm.
03:32:40 <ivanm> "az0rz"?
03:32:50 <Adamant> as, I think
03:33:33 <Adamant> when you're combining Nixon and eliteness, strange things will happen.
03:33:34 <ivanm> hmmm...
03:35:02 * hackagebot redis 0.5.2 - A driver for Redis key-value database  http://hackage.haskell.org/package/redis-0.5.2 (AlexanderBogdanov)
03:35:13 <scree> ?faq can haskell pipe theraw irrational megaequation into an analog device
03:35:13 <lambdabot> The answer is: Yes! Haskell can do that.
03:36:45 <Adamant> Informatica non tanta est de computratris, quanta astronomia de telescopiis. - Edsger Wybe Dijkstra
03:36:59 <Adamant> he's much clearer in the original Latin.
03:37:04 <ivanm> heh
03:39:22 <wvd> Doesn't + 5 + 5 need an infinite lookahead?
03:40:03 * hackagebot hpage 0.6.0 - A scrapbook for Haskell developers  http://hackage.haskell.org/package/hpage-0.6.0 (FernandoBenavides)
03:41:25 <rajeshsr> hi
03:41:44 <rajeshsr> is there any good article on type arithmetics with haskell?
03:43:18 <ivanm> rajeshsr: what do you mean?
03:43:26 <ivanm> type-level numerics?
03:43:38 <ivanm> IIRC someone (oleg?) has implemented peano arithmetic on the type system...
03:43:45 <ivanm> s/on/in/
03:43:47 <rajeshsr> ivanm, well, Peano's arithmetics and stuffs like that..
03:43:51 <rajeshsr> yep
03:43:56 <ivanm> in the type system?
03:44:09 <ski> wvd : not if you eliminate the left-recursion
03:44:16 <ivanm> @google haskell church numerals type system
03:44:17 <lambdabot> http://okmij.org/ftp/Computation/lambda-calc.html
03:44:17 <lambdabot> Title: Lambda Calculus and Lambda Calculators
03:44:38 <rajeshsr> yep and some example of its implications. I have always heard about the *use* of implementing such things..
03:44:54 <ivanm> rajeshsr: have a look there
03:45:00 <ivanm> don't know why you would want such a thing...
03:45:08 <rajeshsr> ivanm, hmm, ok!
03:45:46 <ivanm> rajeshsr: also http://www.haskell.org/haskellwiki/Category:Type-level_programming
03:45:50 <rajeshsr> well, just want to check what it is out of curiosity as it is kept thrown in reddit_haskell and some other places too..
03:49:22 <wvd> How does 4 * 5 get parsed?
03:49:56 <Axman6> (4 * 5)...
03:50:01 <wvd> I mean.
03:50:05 <wvd> It looks up * and knows what to do?
03:50:10 <wvd> Or does it get translated to (*) 4 5
03:51:29 <Axman6> you can define your own infix functions
03:51:35 <wvd> I know.
03:52:02 <ivanm> wvd: if a type isn't specified, it will be inferred and defaulted
03:54:04 <Jonno_FTW> @src nub
03:54:05 <lambdabot> nub = nubBy (==)
03:54:18 <Jonno_FTW> @src nubBy
03:54:18 <lambdabot> nubBy eq []             =  []
03:54:18 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
03:54:51 <Jonno_FTW> does this mean that nub is lazy?
03:55:47 <ivanm> yes
03:55:52 <ivanm> and O(n^2)
03:56:06 <ivanm> but it does work on infinite lists, whereas simple variants using sorting or Data.Set don't
03:56:45 <zygoloid> wvd: 4 * 5 gets desugared to (*) (fromInteger a) (fromInteger b), where a is the Integer representation of 4 and b is the Integer representation of 5
03:57:24 <zygoloid> wvd: (that's Prelude's fromInteger rather than the fromInteger in scope unless you use -XNoImplicitPrelude)
03:57:26 <wvd> zygoloid, ok, thanks.
03:57:59 <zygoloid> (*) is looked up and presumably found as (Prelude.*) in typeclass Num
03:58:35 <ivanm> zygoloid: or you do import Prelude hiding (fromInteger)
03:58:58 <zygoloid> ivanm: really? huh.
03:59:15 <ivanm> yes, you can do that
03:59:29 <quicksilver> ivanm: no.
03:59:38 <zygoloid> ivanm: nope, that doesn't work.
03:59:39 <quicksilver> hiding fromInteger does not change the desugaring of numeric literals.
03:59:42 <quicksilver> zygoloid was right.
03:59:53 <quicksilver> you need -XNoImplicitPrelude to turn that off
03:59:55 <ivanm> oh, right, that only works if you use fromInteger yourself
04:00:13 * ivanm has in the past had to hide LT because a library re-defined it
04:00:43 <quicksilver> "4" desugars to "magicalFromInteger 4" where magicalFromInteger is Prelude.fromInteger and is *always* available irrespective of scope and hiding.
04:00:44 <zygoloid> ivanm: if you use fromInteger yourself then it uses whichever one is in the innermost enclosing scope (which might be the one found from the implicit import of Prelude and might not)
04:01:00 <ivanm> right
04:01:07 <quicksilver> with -XNoImplicitPrelude it uses the currently visible fromInteger instead.
04:01:20 <quicksilver> which possibly lets you do horrendous things with 'let'
04:01:36 <zygoloid> i don't really like saying "4 desugars to fromInteger 4" since it just seems to beg the question...
04:01:50 <quicksilver> right, it is a bit of a clumsy thiing to say.
04:01:52 <int-e> let fromInteger _ = 4 in 42 --> loop?
04:02:17 <zygoloid> ivanm: yep
04:02:25 <int-e> yes! :)
04:02:32 <zygoloid> s/ivanm/int-e/
04:02:35 <peterNovice> If I have a question about hmatrix crashing ghc 6.10.4 should I ask here or the maintainer of hmatrix?
04:02:54 <zygoloid> peterNovice: here or #ghc
04:02:57 <ivanm> peterNovice: you can ask here, but if it's anything specific to the internals of hmatrix you'll proabably have to ask luis
04:03:11 <zygoloid> crashing ghc sounds like it's probably a ghc bug though
04:03:40 <ivanm> or else a dodgy binding
04:03:42 <int-e> or template haskell nasties.
04:03:52 <ivanm> hmatrix uses TH? :o
04:04:05 <int-e> I don't know.
04:04:13 <ivanm> nope, it doesn't appear to
04:04:23 <ivanm> but it does link to 3 C libraries
04:04:29 <zygoloid> ivanm: i'd think dodgy bindings would crash at runtime?
04:04:40 * ivanm hopes that hstatistics means that hmatrix won't have the gsl bindings any more
04:04:48 <peterNovice> ivanm: when I use the Data.Packed.Random functions in ghci I get: "Process haskell bus error (core dumped)" if you use 6.10.4 you can try it yourself.
04:05:08 <ivanm> peterNovice: paste your code up somewhere so we can
04:05:13 <peterNovice> It works when I compile it though.
04:05:14 <ivanm> though I've got 6.12.1 atm
04:05:22 <ivanm> peterNovice: right, probably a dynamic linking problem
04:05:31 <ivanm> a lot of linking things don't work in ghci but do when compiled
04:05:32 <int-e> heh. configure.hs: user error (Pattern match failure in do expression at configure.hs:98:4-7)
04:05:42 <ivanm> int-e: what's that in?
04:05:50 <int-e> hmatrix-0.8.3.1
04:06:05 <peterNovice> Ivanm: the problem is not with my code as far as I know, any Data.Packed.Random function crashes it.
04:06:10 <peterNovice> int-e: yes
04:07:00 <ivanm> int-e: :/
04:07:31 <int-e> probably a Cabal version issue
04:08:11 <dcoutts> int-e: hmm?
04:08:22 <int-e> (cabal-install uses Cabal-1.6.0.3, but I have 1.8.0.2 installed)
04:08:37 <ivanm> int-e: you mentioned the magic C-word!
04:08:37 <int-e> dcoutts: hmatrix does this: Just bInfo <- maybeGetPersistBuildConfig "dist"
04:08:46 <ivanm> int-e: get the latest cabal-install then
04:08:51 <ivanm> cabal install cabal-install should do it ;-)
04:09:10 <peterNovice> Because Alberto Ruiz page says "I am very happy to receive contributions, suggestions, and bug reports. " I was wondering if I should report this?
04:09:28 <int-e> dcoutts: and I guess Cabal-1.8 can't find the configuration generated with 1.6
04:09:39 <int-e> dcoutts: in any case, not your fault this time :)
04:09:52 <ivanm> peterNovice: he's lying; _no-one_ is happy to receive bug reports
04:10:01 <ivanm> peterNovice: but can you paste some code up so we can check that it isn't just your system?
04:10:45 <dcoutts> int-e: yep, but why is it using that at all?
04:11:00 <dcoutts> int-e: it's also broken since it cannot hard-code "dist"
04:11:08 <ivanm> int-e: do you have lapack, blas and gsl installed?
04:11:28 <peterNovice> ivanm: "Prelude Numeric.LinearAlgebra> uniformSample 777 2 [(0.0,1.0)] " for instance crashes it
04:11:50 <dcoutts> int-e: ah, ok, it's not doing that in it's Setup.hs
04:12:07 <int-e> dcoutts: it's extracting the extraLibs and frameWorks fields. right, it's an extra configure program
04:12:19 <ivanm> peterNovice: works here with 6.12.1 and hmatrix 0.8.3.1
04:12:42 <int-e> ivanm: no, but that wasn't the cause of that error. now it has a more helpful message.
04:12:45 <ivanm> so it's either something with your system or soemthing with 6.10.4 that's the problem
04:13:22 <dcoutts> int-e: wierd, what is the configure.hs for? it's not called by Setup.hs
04:14:10 <int-e> dcoutts: it uses autoconfUserHooks, which runs configure, which runs configure.hs
04:14:37 <peterNovice> ivanm: well, I guess I could look at the source code of randomVector and see which function there crashes it.
04:14:51 <ivanm> peterNovice: which version of gsl do you have?
04:14:56 * ivanm has 1.14
04:14:57 <dcoutts> int-e: what a roundabout method!
04:15:15 <dcoutts> and not portable to windows
04:15:16 <peterNovice> ivanM: 1.13 fedora 12
04:15:45 <ivanm> peterNovice: so it _could_ be to do with that version of gsl
04:15:54 <ivanm> peterNovice: email luis if you want, just to ask if he knows what could be causing that problem
04:16:32 <ivanm> peterNovice: how about lapack and blas? which versions?
04:17:27 <peterNovice> ivanm: lapack 3.2.1, blas 3.2.1, I am just using old regular fedora 12
04:17:54 <ivanm> peterNovice: I have no idea what fedora uses ;-)
04:18:16 <ivanm> any idea which _type_ of lapack and blas? atlas, clapack, reference lapack, etc.?
04:18:48 <ivanm> by the version, I guess clapack or maybe lapack-reference
04:18:48 <ivanm> since my lapack-atlas install is 3.9.23
04:19:52 <ivanm> and if it is clapack, then on gentoo at least that version is masked for having static links causing problems
04:24:52 <peterNovice> ivanm: I am not sure how to answer "which type" of lapack, I guess I can ask around at #fedora-haskell
04:25:22 <ivanm> nothing to do with haskell ;-)
04:25:22 <ivanm> peterNovice: check its documentation, etc.
04:25:27 <ivanm> see if there are other variants of lapack available
04:28:05 <int-e> ok, works for me. atlas 3.8.3-20, gsl 1.14+dfsg-1 (debian sid), linux, x86
04:28:25 <ivanm> peterNovice: looks like you have the reference version of lapack
04:28:32 <ivanm> which is slower than the atlas one
04:29:27 <peterNovice> ivanm: i have atlas 3.8.3 installed
04:29:58 <peterNovice> So fedora is an odball distro huh? :)
04:30:22 <ivanm> this is atlas as in math-atlas.sourceforge.net ?
04:30:50 <peterNovice> ivanM: yes the the optimized linalg
04:31:02 * ivanm wonders which one gets used...
04:31:05 <ivanm> *shrug*
04:32:55 <peterNovice> ivanm: the funny thing is that the tests for hmatrix all passed
04:33:08 <ivanm> heh
04:33:56 <peterNovice> Prelude> Numeric.LinearAlgebra.Tests.runTests 20
04:36:25 <ivanm> *sigh* I'm trying to work out how to structure the docs for graphviz; the way that's best to be shipped with the library itself isn't going to work so well for the website :s
04:39:02 <yaxu> Hi all, I'm wondering, what does the M in MVar start for?  Memory?
04:39:29 <theorbtwo> Mutable.
04:39:37 <yaxu> aha, thanks
04:39:43 <yaxu> not Magic then
04:40:07 <dv-> that's TMVar
04:40:08 <Botje> Moomoo.
04:41:05 <ski> wvd : btw, if you want to parse the grammar `<p> ::= <a> | <p> <b>', first rewrite it to `<p> ::= <a> <q> ; <q> ::= <eps> | <b> <q>' (this is removing left-recursion)
04:41:35 <wvd> ski: not really doing that, but I can always use LL(*) since I'm using ANTLR
04:41:53 * ski has no idea what `ANTLR' is
04:42:08 <theorbtwo> <eps>?
04:42:17 <Jafet> Can't parsec work around left recursion?
04:42:24 <ski> the epsilon syntactic category
04:42:56 <theorbtwo> Jafet: It's supposed to be able to, if you use try.
04:43:07 <ski> Jafet : it can't
04:43:08 <theorbtwo> ski: Empty, in other words?
04:43:11 <ski> yes
04:43:20 <Jafet> Anyway, antlr is a parser generator
04:43:28 <quicksilver> you have to left-factor yourself
04:43:41 <quicksilver> parsec's model is too flexible to do its own left-factoring
04:43:46 <ski> theorbtwo : `try' is a way to get the usual non-deterministic disjunction/alternative .. not a way to remove left-recursion
04:44:05 <quicksilver> haskell expressions aren't sufficiently introspectable to detect it.
04:44:16 <ski> maybe with an applicative parser, one could detect left-recursion
04:44:26 <quicksilver> you can imagine a parser combinator which starts with a rather concrete ADT-type model of the grammar
04:44:30 <ski> or would that require stable names or something like that ?
04:44:34 <Jafet> Could one bottom-up parse with combinators?
04:44:36 <quicksilver> I believe it requires names, ski.
04:44:54 <Jafet> I expect it would require a lot of internal bookkeeping
04:44:58 <quicksilver> I wrote a parser generator which dealt with left-recursion and certainly I did it with names
04:45:13 <quicksilver> once I'd done that it was pretty easy to build first-token lookup tables too
04:45:22 <quicksilver> although I never tested to see if that was actually faster :)
04:45:24 <ski> Jafet : possibly edwardk has done something like that ..
04:45:25 <quicksilver> it just seemed fun.
04:48:38 <ski> Jafet : is `antlr' like `Happy' and `yacc', i.e. does it take a program in its own syntax .. or does it just take a datastructure ?
04:48:53 <Jafet> Like happy, I would suppose
04:48:58 <Jafet> And, er, yacc
04:49:11 <ski> ok
04:49:37 <Jafet> I wonder if you can specify grammars in Haskell that are compiled statically
04:50:16 <Jafet> And perhaps, resolve at compile-time to a proper parser, removing left-recursion, creating lookup tables where appropriate, etc.
04:50:17 <ski> using applicative or arrow parser combinators, it should be possible, modulo recursion, at least
04:50:35 <Jafet> I don't know much about those typeclasses...
04:51:27 <ski> (where "compiled statically" is interpreted as "parser is generated once, first time it is forced, then just reused")
04:51:45 <Jafet> Hm, that works too
04:51:52 <Jafet> (As long as you make your compiler a daemon!)
04:52:38 <ski> well, the "compiler" would in this case just be the `parse :: Parser a -> (String -> Maybe a)' function
04:53:44 <ski> (where that is a "true curried" function, that does "real work" before given its second argument)
04:54:50 <ski> the advantage to using applicative or arrow parsers would be that in
04:54:53 <ski> @type (>>=)
04:54:54 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
04:55:08 <ski> we can avoid the non-inspectable `a -> m b' part
04:55:24 <ski> @type (<*>)
04:55:25 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
04:56:34 <Jafet> It would even compile the parser lazily, huh
04:57:05 <ski> if `f' is our `Parser', then `(<*>)' could more or less just call a constructor on `Parser', so that we can decompose it into its constituent parts and do an analysis of whether sub-parsers can possibly accept the empty string, as well as determining the set of possible tokens that the words it accepts can start with
04:57:25 <ski> similarly for
04:57:28 <ski> @type (>>>)
04:57:29 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
04:57:38 <ski> @type (Control.Arrow.>>>)
04:57:39 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
04:57:44 <ski> bah
04:58:51 <ski> (except that for `Arrow' we can still have the nasty `arr :: Arrow (~>) => (a -> b) -> (a ~> b)' base case (though maybe not that nasty in this application, since its pure) .. so possibly something like `Category' would be better)
04:59:19 <int-e> <eps> = epsilon, the empty word.
04:59:28 <int-e> ignore that.
04:59:40 <ski> Jafet : maybe .. if it doesn't need to traverse the whole parser tree to determine how to handle the part that actually needs to be used in a specific parse
05:05:32 <quicksilver> ski: in the context of parsers, 'arr' is  not a problem. 'arr' is the parser which doesn't consume any data, but transforms the result.
05:05:57 <quicksilver> ski: so it doesn't change first-token sets, it doesn't consume anything, it doesn't have any problem with backtracking or recursion.
05:07:17 <ivanm> I'm about to start writing a website for graphviz; what would be better in terms of having a documentation/FAQ section: one big page or having it split up?
05:07:25 <ski> (quicksilver : see "(though maybe not that nasty in this application, since its pure)" :)
05:08:24 <Jafet> ivanm, docbook!
05:08:40 <amosrobini> ivanm: I usually like one big page because I can scroll through and read the whole thing without being interrupted
05:08:41 <ivanm> Jafet: I was planning on using pandoc so I could have a markdown file to ship with the actual library
05:08:47 <ivanm> amosrobini: *nod*
05:09:07 <ivanm> one big file is easiest for me; just wondering if a big wall of text could get too difficult to navigate
05:09:33 <amosrobini> often I find the answer tells me more about its relevance than the question
05:10:25 <Jafet> ivanm, doesn't matter, the internal linking is more important
05:10:27 <silver> you can do both, like "version for printing" and "for online reading"
05:10:33 <ivanm> Jafet: *nod*
05:10:39 <Jafet> But one subsubsection per page does get annoying
05:10:41 <zygoloid> quicksilver: in the context of parser *generators*, 'arr' can be a problem, though
05:10:47 <silver> (like on gentoo's web-site)
05:10:47 <ivanm> two versions might be too much of a pain
05:10:54 <silver> oh
05:11:18 <ivanm> since with pandoc, to have separate pages I need to have separate pages from the beginning (which makes it more difficult to set the title, etc.)
05:11:26 <blackh> Is there anything resembling a standard monadic iterator? You could define one as m (Maybe a), where you interpret "Nothing" to be the end of the enumeration. Is there any precedent for this, or has anyone done anything like this
05:11:41 <arcatan> ivanm: one big file has the plus side that you can easily search inside the page
05:11:48 <ivanm> yeah
05:11:55 <quicksilver> zygoloid: yes, if a parser generator wants full optimisation/re-arrangement possibilities it wants to work on a very inspectable ADT for the first pass, at least
05:12:06 <quicksilver> zygoloid: its "compiled" representation could involve an arrow.
05:12:07 <ivanm> blackh: btw, are you going to be staying with blackdog because you know each other or just because of your similar nicks? :p
05:12:48 <Baughn> Something I've been wondering. FilePaths are Strings, which are unicode - so how do you open a file whose name is not valid unicode?
05:13:10 <ski> blackh : you mean something like `newtype List f a = List (f (Cell f a)); data Cell f a = Nil | Cons (List f a)' ?
05:13:21 <ski> (where `f' can be `IO' or `IORef' or what-you-will)
05:13:22 <Jafet> Baughn, I wonder where you'd get files like that
05:13:24 <blackh> ivanm: We did some work on Mac library support on GHC.
05:13:39 <Baughn> Jafet: .jp
05:13:45 <ivanm> blackh: ahhh
05:13:50 <Baughn> Jafet: Shift-jis, AIUI
05:14:03 <blackh> ski: Yes - that's the kind of thing I'm talking about. Has someone established any sort of precedent for this?
05:14:04 <ivanm> blackh: this isn't helping your claim that you're different people you know :p
05:14:04 <Jafet> ByteString, then?
05:14:20 <Baughn> POSIX specifies that filenames are Bytestrings, sure
05:14:26 <blackh> ivanm: I'm just like blackdog except I talk funny eh
05:14:36 <Jafet> And fix the filenames in some posix ffi...
05:14:38 <ivanm> heh
05:14:40 <ski> blackh : i've used such a `List' a little .. and i seem to recall someone else using something a bit similar .. but i'm not sure who
05:14:55 <Baughn> Jafet: ..nasty workaround. I think this counts as a library bug, actually.
05:15:08 <Baughn> type FilePath = ByteString should work better
05:15:20 <Jafet> Only if you consider ghc to be based more on posix than on unicode
05:15:23 <blackh> ski: The background is that I want to implement a chunked XML parser, and I need some type to act as the iterator to get the next tag.
05:15:29 <Jafet> Or Haskell
05:15:38 * hackagebot primitive 0.3 - Wrappers for primitive operations  http://hackage.haskell.org/package/primitive-0.3 (RomanLeshchinskiy)
05:15:47 <ski> blackh : is it that which is called SSAX ?
05:16:07 <Baughn> Jafet: Well, I'll point it out at least.
05:16:24 <Jafet> Point it out to the japanese!
05:16:32 <o-_-o> I have a category theory question
05:16:41 <blackh> ski: SAX is generally flat - this is going to be a tree structure. It's going to be part of my hexpat package.
05:16:59 <o-_-o> A ----> B, f:A --->B
05:17:04 <o-_-o> this is ok
05:17:22 <o-_-o> A -----> A, f: Id(A) is also ok
05:17:43 <ski> blackh : btw, on rereading, it seemed like you asked for a "mutable iterator", i.e. each time you execute `m (Maybe a)' it will progress through the generated items
05:17:59 <o-_-o> A ---------> A, with f /= Id(A) is this possible ?
05:18:11 <quicksilver> o-_-o: certainly.
05:18:12 <ski> o-_-o : what does `f: Id(A)' mean ?
05:18:23 <quicksilver> o-_-o: there are in general many non-identity arrows A -> A
05:18:26 <o-_-o> f: is an identity transgorm
05:18:29 <o-_-o> f: is an identity transform
05:18:44 <blackh> ski: Yes - that's really what I'm after.  Also iteratee might have some relevant ideas, but all my attempts to understand it so far have failed.
05:18:48 <quicksilver> o-_-o: in the category Set, for example, n |-> n + 1 is a non-identity arrow on the integers
05:19:08 <o-_-o> quicksilver, ah...cool, thanks
05:19:31 <quicksilver> in fact, if a category has no non-identity arrows A->A for all objects A, then it is a pre-order. I think.
05:19:32 <o-_-o> ski, Id(A) is an identity transform
05:19:56 <quicksilver> the notation is normally Id_A and the word is 'morphism' not 'transform'
05:19:57 <quicksilver> ;)
05:20:19 <o-_-o> quicksilver, heh...yeah, I am in the first page :-p
05:20:29 <ski> o-_-o : if you had written `f = Id(A)', then i would have agreed .. but `f: Id(A)' i'm not sure what it is supposed to mean
05:20:50 <o-_-o> ski, the pdf I am reading uses something like that
05:20:56 <ski> in category theory, there should be exactly one identity morphism for each object
05:21:29 <ski> (or rather, *the* morphism that `Id(A)' singles out *is* the one that is called "identity")
05:22:09 <zygoloid> Baughn: in 6.8.3, GHC seems to be truncating to the lowest 8 bits of each Char before passing it to Linux
05:22:26 <zygoloid> no idea what happens with the new io lib
05:22:38 <ski> blackh : `iteratee' being the hackage package (which i should rsn look closer at) ?
05:22:58 <o-_-o> quicksilver, any category theory textbooks which are good ?
05:23:10 <quicksilver> yes, although they're mostly very dry.
05:23:21 <quicksilver> MacLane is thorough, but very dry.
05:23:30 <blackh> ski: Yes - that's the one.  I can't find any introductory docs on iteratee.
05:23:41 <Jafet> Like Principia Mathematica?
05:24:21 <quicksilver> Barr & Wells is good, and appears to be available for free online.
05:24:57 <quicksilver> o-_-o: have a poke around http://www.cs.le.ac.uk/people/akurz/books.html
05:25:07 <quicksilver> and watch the catsters' videos on youtube.
05:25:19 <o-_-o> quicksilver, Ah...cool :-)
05:25:32 <o-_-o> quicksilver, ok catsters' videos are difficult
05:25:50 <o-_-o> I can't take in information that fast
05:25:56 * o-_-o <-------- old
05:26:01 <quicksilver> I suspect Leinster's lecture notes will be good (on that page I linked)
05:27:13 <o-_-o> quicksilver, thank you very much, wow!
05:27:57 <quicksilver> you're welcome.
05:29:05 <o-_-o> yikes Mac Lane is Rs. 4011
05:29:46 <Baughn> zygoloid: Same thing. It's not supposed to do that. It's /wrong/.
05:32:42 * hackagebot vector 0.6 - Efficient Arrays  http://hackage.haskell.org/package/vector-0.6 (RomanLeshchinskiy)
05:33:58 <FliPPeh_> Gah
05:34:26 <FliPPeh_> It's so annoying when you ahve a great idea or motivation to do something, and WANT to do it, and on the next day it's just all gone again :(
05:34:37 <ivanm> heh
05:34:38 <FliPPeh_> I have no idea what to do. I'm bored and I want to code something.
05:34:53 <ivanm> FliPPeh_: what kind of stuff do you like coding?
05:34:59 <FliPPeh_> I already wrote a functional tag-lib backend to do something fun
05:35:02 <ski> FliPPeh_ : do what i do, write notes of interesting things you think about, and then (almost) never look at them again !
05:35:08 <FliPPeh_> ivanm: Haskell of course :)
05:35:13 <FliPPeh_> Well, I'm a fan of network applications
05:35:29 <ivanm> hmmmm.....
05:35:32 <ivanm> nope, I've got nothing
05:35:35 <FliPPeh_> I wrote IRC Bots in 10 languages.
05:35:43 <FliPPeh_> About 4 revisions in each
05:35:50 <FliPPeh_> It starts to bore
05:35:58 <FliPPeh_> But it's the only thing I could think of :)
05:36:00 <dv-> Make a reddit clone in haskell
05:36:21 <FliPPeh_> I don't use reddit.. no idea of what it's about
05:36:42 <ski> make a simple collaborative editor ?
05:36:49 <ivanm> FliPPeh_: someone posts an "interesting" link, then people comment and vote on it (and vote on the comments)
05:36:50 <ski> (i have no idea how hard that is)
05:36:59 <fasta> Or make something that people actually want.
05:37:07 <ivanm> FliPPeh_: help out with darcsden?
05:37:12 <mreh> take 4 . iterate (+1) $ 1 -- is there an efficient implementation of this?
05:37:25 <quicksilver> would be much more considerate if the people just wanted something that FliPPeh_ actually made.
05:37:30 <ski> mreh : `[1,2,3,4]' ?
05:37:30 <FliPPeh_> fasta: What do people want? I hate people! They always want too much!
05:37:40 <quicksilver> mreh: as it stands it doesn't even type-check?
05:37:41 <mreh> ski: in the general case :)
05:37:47 <luite> mreh: enumFromTo ?
05:38:02 <quicksilver> :t iterate
05:38:02 <mreh> I got it wrong
05:38:02 <lambdabot> forall a. (a -> a) -> a -> [a]
05:38:14 <mreh> > (!! 4) . iterate (+1) $ 1 -- is there an efficient implementation of this?
05:38:15 <lambdabot>   5
05:38:34 <quicksilver> suprisingly, I think that way is reasonably efficient.
05:38:35 <FliPPeh_> I think I never ever made anything (besides a PHP server checking script that only lives on my webserver that's gotten pretty popular in the asian countries) that people want
05:38:42 <FliPPeh_> I finish less than 10% of my projects :)
05:38:51 <ski> oh, you want `Integer -> (forall a. (a -> a) -> (a -> a))'
05:39:01 <mreh> quicksilver: even having to iterate through the list?
05:39:02 <Baughn> Am I a bad person for wanting an AutomaticallyDeriveIntrospectionClasses pragma?
05:39:13 <ivanm> Baughn: by the sounds of things, yes
05:39:15 <ivanm> ;-)
05:39:30 * Baughn writes "deriving(Typeable,Data)" for the Nth time
05:39:31 <luite> that's an awfully long pragma name
05:39:46 <ski> luite : well, if you only have to write it once ..
05:39:49 <Baughn> luite: I could shorten it to ACID
05:39:55 <ski> argh, no
05:39:59 <FliPPeh_> ADIC?
05:40:07 <Baughn> FliPPeh_: No, ACID. French, you see.
05:40:08 <luite> hehe that's worse :)
05:40:20 <mreh> @hoogle Int -> (a -> a) -> a -> a
05:40:21 <lambdabot> Data.Sequence adjust :: (a -> a) -> Int -> Seq a -> Seq a
05:40:21 <lambdabot> Data.IntMap adjust :: (a -> a) -> Key -> IntMap a -> IntMap a
05:40:21 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
05:40:39 <ski> @slap hoogle
05:40:39 * lambdabot decomposes hoogle into several parts using the Banach-Tarski theorem and reassembles them to get two copies of hoogle!
05:40:52 <ski> (oh no, what have i done ?!)
05:40:58 <FliPPeh_> @slap ski
05:40:59 * lambdabot beats up ski
05:41:02 <FliPPeh_> That's how it works
05:41:04 <ski> ty
05:41:10 <theorbtwo> @slap lambdabot
05:41:10 * lambdabot clobbers lambdabot with an untyped language
05:41:14 <Baughn> ski: Since computers are not infinite, the banach-tarski theorem does not apply
05:41:55 <ski> (Baughn : well, maybe hoogle runs on a Blum-Shub-Smale machine ..)
05:41:55 <Baughn> (And thus neither does the axiom of choice. Gah. Well, but since they're not infinite, I don't care..)
05:42:09 <mreh> you haven't answered my question :(
05:42:35 <fasta> Baughn, you don't know that.
05:42:53 <Baughn> mreh: The one you wrote looked pretty good..
05:42:55 <fasta> Baughn, by saying that you say that the universe only has finite state.
05:43:07 <Baughn> fasta: No, I'm saying /computers/ have finite state
05:43:09 <fasta> Baughn, which might be true, but it is not a fact, AFAIK.
05:43:16 <fasta> Baughn, and computers have I/O.
05:43:19 <ski> mreh : quicksilver semi-answered it as that using `iterate' surprisingly probably is reasonably efficient
05:43:20 <Baughn> fasta: The universe definitely has finite /reachable/ state, though
05:43:27 <quicksilver> mreh: well, a list is a for loop. the question you ask basically requires some kind of for loop
05:43:31 <fasta> Baughn, what is "reachable"?
05:43:40 <quicksilver> whilst I doubt it's universally optimal assembly I suspect it's OK
05:43:43 <Baughn> fasta: "Can affect your future light cone"
05:43:45 <quicksilver> it should be cache local and run OK
05:43:55 <mreh> quicksilver: thanks
05:44:12 <fasta> Baughn, speed of light is irrelevant for some models.
05:44:14 <Baughn> fasta: That is, of course, assuming it has finite resolution. Which seems likely.
05:44:24 <Baughn> fasta: What models would that be?
05:44:52 <fasta> Baughn, models in which http://en.wikipedia.org/wiki/Alcubierre_drive works.
05:45:18 <Baughn> fasta: Do such models actually exist?
05:45:46 * hackagebot gf 3.1.6 - Grammatical Framework  http://hackage.haskell.org/package/gf-3.1.6 (KrasimirAngelov)
05:46:01 <fasta> Baughn, AFAIK, there are some strange assumptions.
05:46:18 <fasta> Baughn, anyway, I would not say it is "impossible", more like "we don't know".
05:46:21 <FliPPeh_> Anyone else agreeing with me about PCLinuxOS being a very, very stupid name?
05:46:46 <Baughn> fasta: Krasnikov tubes or wormholes seem.. less unlikely to work on this universe, but those don't let you actually breach lightspeed for the purposes of reaching more of the universe, so yeah
05:47:01 <Baughn> (They only let you do FTL /backwards/)
05:47:53 <Baughn> ((And of course, nobody has quite figured out how to /control/ an alcubierre drive. Maybe crashing it into a star would stop it?))
05:48:29 <fasta> Baughn, I recently tried to read a book on quantum field theory; I was not able to understand it, so I am really not qualified to talk on the subject any further.
05:48:55 <Baughn> fasta: http://lesswrong.com/lw/r5/the_quantum_physics_sequence/ <-- Have this.
05:50:00 <fasta> Baughn,  Eliezer_Yudkowsky doesn't actually publish in journals, etc. So, as far as I am concerned he has no credentials.
05:50:26 <fasta> Baughn, does he even have a theoretical physics background?
05:50:41 <Baughn> Well, he does now
05:51:14 <Baughn> But the thing is, everything in that series is relatively easily checkable. It's mostly the /explanation/ that's unique.
05:51:39 <fasta> Baughn, ok, that's enough, in principle.
05:52:52 <Baughn> fasta: And so, if I tell you that physicists you would agree have credentials have looked it over without finding meaningful flaws?
05:53:22 <Baughn> fasta: Apart from the whole "MWI wins outright" thing, which I agree with but which does not actually matter for experimental predictions based on what you'd be reading
05:55:38 <Baughn> fasta: Most QM textbooks attempt to explain QM in terms of normal, everyday physics. Eliezer does it the other way around. So does reality. That's a major attraction for me; it made it much easier to understand, as the simple things in QM, while simple, do not match up with simple events at macroscopic levels.
05:57:33 <fasta> Baughn, The book I was talking about was: quantum field theory in a nutshell by Zee. I clearly don't have the background to read that. It seems that you should be able to write a theory down in less pages without a degree in theoretical particle physics.
05:58:04 <quicksilver> Baughn: hollywood demands that controlling an alucbierre drive would require torturing or abusing an alien race or a minority group
05:58:13 <quicksilver> Baughn: that would create the correct plot hooks.
05:59:47 <Baughn> fasta: I haven't read it, but part of the problem might be that QFT is a high-level QM application; it depends on already understanding the low-level bits such as decoherence, the schrodinger equation, etc.
06:00:13 <fasta> Baughn, I understand the two concepts you mention.
06:00:27 <Baughn> Ah.
06:00:29 <fasta> Baughn, one other part is that I don't have the tools to verify anything of it.
06:00:45 <Baughn> That's true, you'd pretty much have to assume they're not lying
06:00:45 <fasta> Baughn, which makes me disconnected from the theoretical ideas.
06:00:50 <Baughn> fasta: Anyhow, elizer's series is pretty short. Why not give it a go? You might benefit from another perspective
06:01:11 <fasta> Baughn, yes, you already convinced me, by saying that other people already looked at it.
06:01:23 <fasta> Baughn, of course, you could also by lying ;)
06:01:28 <fasta> be*
06:01:46 <Baughn> fasta: True, but you can confirm my statement pretty easily by reading the comments. :P
06:01:58 <Baughn> fasta: There /were/ flaws. Those are, apparently, fixed.
06:02:39 <Baughn> (Mainly things such as multiplying by i instead of -i)
06:03:48 <fasta> Baughn, I basically don't buy the whole "it is random"-theory. I think there are some theories that also don't assume that.
06:04:15 <Baughn> fasta: Who actually says that? It's provably false.
06:04:45 <Baughn> fasta: ..you'll like the QM series, I think. The MWI perspective removes all randomness.
06:05:07 <fasta> Baughn, ah, great that someone already proved what I believed to be true; no need to change my model ;)
06:06:03 <Baughn> fasta: Mm. I believe Eliezer shoots that theory down in, oh, the second real chapter or so. :P
06:06:29 <Baughn> It hasn't just been disproven, you'll get an explanation of /how/ it was disproven.
06:07:10 <fasta> Baughn, did anyone actually do an experiment to prove it?
06:07:48 <Baughn> Not for that specific purpose, I don't think. It's too simple.
06:07:49 <Jafet> It's called "interpretation" for a reason
06:08:19 <Baughn> Mm, and it has some pretty severe theoretical issues
06:08:27 <Baughn> Metaphysical issues, I should say.
06:09:29 <Baughn> The chance of experiencing a world is the square of the amplitude of its wavefunction..
06:09:48 <Baughn> Why the /square/? That still needs to be explained.
06:10:26 <Baughn> It means that if you're looking at an MWI universe for the outside, you can't just count timelines; you need an additional fact that the probability of someone experiencing a particular one is the square of its amplitude.. nasty.
06:12:20 <o-_-o> is there any non-dry category theory book ?
06:12:23 <Dari[work]> Hi there
06:12:36 <o-_-o> something with real world applications as examples...
06:12:53 <Dari[work]> I got a question, I'm starting Haskell, and I'm trying to parse an HTTP request
06:13:15 <Dari[work]> And I'm looking for an easy way to extract the method from the String of the request
06:13:15 <ivanm> Dari[work]: any particular reason you don't go and use a pre-defined library for that?
06:13:23 <ivanm> HTTP, URI, etc.
06:13:27 <Dari[work]> Ah
06:13:29 <Dari[work]> Yes
06:13:36 <Dari[work]> I did'nt know they existed
06:13:38 <Dari[work]> :p
06:13:40 <Dari[work]> Okay
06:13:41 <ivanm> @where hackage
06:13:42 <lambdabot> http://hackage.haskell.org/package/
06:13:45 <ivanm> Dari[work]: ^^ have a look!
06:13:48 <ddarius> o-_-o: Read Barr and Wells ESSLLI lecture notes, or alternatively, read Computational Category Theory by Rod Burstall.
06:13:51 <Dari[work]> On my way :)
06:15:36 <siracusa> What is the easiest way to create a simple list view with several columns in Gtk2Hs, a TreeView with a ListStore?
06:15:52 <dcoutts> siracusa: yes
06:15:59 <dino-> Reading that reddit about contributing, I'm confused about complaints like this "Gtk2hs is almost impossible to install on Mac (at least without X11)"
06:16:12 <siracusa> dcoutts: Ok
06:16:17 <dino-> Forgetting all about Haskell, isn't X11 a requirement for the Gtk stuff?
06:16:32 <dcoutts> dino-: I think the native OSX Gtk+ bakcend is harder to install
06:16:49 <dino-> dcoutts: Ah, I didn't know they had their own no-X11 Gtk thing.
06:17:03 <dcoutts> dino-: it's less mature, but people think they want it, because of the allure of "native", even if it's worse :-)
06:19:02 <EvanR> gtk works on windows
06:19:05 <EvanR> among others
06:22:00 <eevar2> ^^ supposedly
06:23:20 <dcoutts> it certainly does work on windows
06:28:20 <siracusa> dcoutts: How to set the data for the different columns? treeViewSetModel only lets me set a single list
06:28:44 <dcoutts> siracusa: you specify projection functions (fields) see the demos
06:29:01 <portnov> @hoogle concatMapM
06:29:01 <lambdabot> No results found
06:29:11 <dcoutts> siracusa: ie your model uses a record type, you set field functions for the columns
06:29:34 <siracusa> Oh
06:29:49 <portnov> @hoogle (Monad m) => (a -> m [b]) -> [a] -> [b]
06:29:49 <lambdabot> No results found
06:29:55 <portnov> :/
06:29:55 <lambdabot> portnov: You have 1 new message. '/msg lambdabot @messages' to read it.
06:34:20 <idnar> @type mapM
06:34:21 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
06:34:26 <idnar> @type fmap concat . mapM
06:34:27 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
06:34:54 <idnar> hmm, no
06:35:01 <idnar> @type (fmap concat .) . mapM
06:35:02 <lambdabot> forall a (f :: * -> *) a1. (Functor f, Monad f) => (a1 -> f [a]) -> [a1] -> f [a]
06:35:09 <idnar> @type (liftM concat .) . mapM
06:35:10 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a1 -> m [a]) -> [a1] -> m [a]
06:35:22 <idnar> portnov: ^^^ like so?
06:35:34 <portnov> idnar: yes, thanks :)
06:35:37 <IceDane> What is an alternative to Data.Array that allows me to do incremental updates on any given element, but efficient?
06:38:34 <EvanR-work> IceDane: DiffArray, but not really :)
06:38:45 <IceDane> EvanR-work: So there's nothing?
06:38:53 <EvanR-work> an IOArray or IOUArray
06:39:03 <IceDane> It also needs to be possible to work with it as a 2d array in one way or another
06:39:09 <EvanR-work> you mean mutable array
06:39:17 <EvanR-work> thats try sticky bit here
06:39:22 <EvanR-work> s/try/the/ :(
06:39:35 <IceDane> Ah
06:39:48 <EvanR-work> make sure your problem needs a mutable array
06:40:02 <EvanR-work> and if so, see if an IntMap would be good enough
06:40:19 <IceDane> There might be a way to impelement this stuff without using a 2d array, but the standard algorithm for it assumes mutability isn't an issue
06:40:24 <IceDane> I'll have to think on it :P
06:40:33 <IceDane> Thanks
06:40:47 <EvanR-work> that happens a lot, the imperative mutable algorithm doesnt translate as cleanly to haskell, there might be another way
06:41:29 <djahandarie> EvanR-work, what is wrong with DiffArray?
06:41:44 <EvanR-work> it seems to get a lot of discussion
06:42:17 <EvanR-work> im just repeating what i heard in here, that its current implementation is slow
06:42:29 <IceDane> I read that in RWH as well
06:42:34 <EvanR-work> unnecessarily slow
06:43:09 <djahandarie> Okay, I hadn't heard that before.
06:43:59 <djahandarie> Is there any reason it hasn't been fixed?
06:45:06 <EvanR-work> i dont know, maybe research the ghc development blogs
06:47:42 <EvanR-work> :kind Writer
06:47:48 <EvanR-work> @kind Writer
06:47:49 <lambdabot> * -> * -> *
06:47:58 <EvanR-work> @src Writer
06:47:58 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
06:50:03 <zygoloid> IceDane: if you really need a mutable array, STArray or STUArray might be a good choice.
06:50:15 <EvanR-work> newtype Writer w a = Writer { runWriter :: (a,w) }
06:50:18 <IceDane> Yeah, I might have to look at those
06:50:24 <EvanR-work> instance (Monoid w) => Monad (Writer w) where
06:50:25 <zygoloid> that way you can at least present a pure interface for your mucky imperative code ;-)
06:50:36 <EvanR-work> why in the instance does Writer have one type parameter rather than two
06:51:00 <quicksilver> so you can choose the type of thing you're writing
06:51:07 <quicksilver> as well as the type of calculation you're returning
06:51:12 <quicksilver> state and reader are similar.
06:51:22 <EvanR-work> its like, partially evaluated type?
06:51:29 <quicksilver> yes, precisely.
06:51:38 * EvanR-work head explode
06:51:42 <o-_-o> > factorial (1024)
06:51:43 <lambdabot>   Not in scope: `factorial'
06:51:44 <quicksilver> that happens a lot round here
06:51:48 <o-_-o> > fact (1024)
06:51:48 <lambdabot>   Not in scope: `fact'
06:51:52 <o-_-o> > fact 1024
06:51:53 <quicksilver> do you think we chose that wallpaper because we liked it?
06:51:53 <lambdabot>   Not in scope: `fact'
06:51:54 <quicksilver> ;)
06:52:04 <zygoloid> > product [1..1024]
06:52:05 <lambdabot>   541852879605885728307692194468385473800155396353801344448287027068321061207...
06:52:06 <EvanR-work> lo
06:52:20 <o-_-o> so it is pretty big
06:52:23 <o-_-o> hmm...
06:52:37 <EvanR-work> > log $ produce [1..1024]
06:52:38 <lambdabot>   Not in scope: `produce'
06:52:40 <zygoloid> > length . show $ product [1..1024]
06:52:41 <lambdabot>   2640
06:52:42 <EvanR-work> > log $ product [1..1024]
06:52:43 <lambdabot>   Infinity
06:52:59 <siracusa> dcoutts: Any ideas why module Graphics.UI.Gtk.Glade can't be found?
06:53:01 <theorbtwo> Infinity?  It's not *that* big?
06:53:13 <zygoloid> @type log
06:53:14 <lambdabot> forall a. (Floating a) => a -> a
06:53:15 <EvanR-work> no but 10^2640 is bigger than biggest double
06:53:30 <zygoloid> good ol' defaulting
06:53:55 <quicksilver> > log (1 :: CReal)
06:53:56 <lambdabot>   0.0
06:54:07 <quicksilver> > log (product [1..1024] :: CReal)
06:54:10 <lambdabot>   mueval-core: Time limit exceeded
06:54:15 <quicksilver> hah. Take that lambdabot )
06:54:27 <zygoloid> hey lambdabot, the answer is 2640
06:54:34 <quicksilver> wasn't sure if there was a Floating instance for CReal. There is but evidently a slow one.
06:54:46 <o-_-o> ok I have a problem
06:55:05 <o-_-o> my friend here wants to test some cluster which has 1024 nodes
06:55:07 <zygoloid> o-_-o: a problem shared is a problem we all have
06:55:10 <quicksilver> > take 1 . show . log (product [1..1024] :: CReal)
06:55:11 <lambdabot>   Couldn't match expected type `f a'
06:55:11 <lambdabot>         against inferred type `Data.Numb...
06:55:16 <EvanR-work> o-_-o: <- pikachu?
06:55:26 <quicksilver> > take 1 . show . log $ (product [1..1024] :: CReal)
06:55:30 <lambdabot>   mueval-core: Time limit exceeded
06:55:31 <o-_-o> EvanR, no kerry
06:55:37 <o-_-o> anyway
06:55:39 <zygoloid> o-_-o: well, if the cluster is a problem, i'll take ownership :)
06:55:39 <quicksilver> hmm, even only forcing the first char takes too long. Sad.
06:55:41 <EvanR-work> wild kerry appears
06:55:46 <o-_-o> he wants to send a message from one node another
06:55:54 <o-_-o> but none of the nodes should repeat
06:56:18 <o-_-o> so if 0 -> 1, then 2 -> 3 at the same time
06:56:25 <o-_-o> so on and so forth
06:56:41 <o-_-o> so he wents all possible combinations like this for all the 1024 nodes
06:57:01 <o-_-o> so is there an easy way ?
06:57:06 <zygoloid> so he wants to test all 1024*1023 directed arcs between nodes?
06:57:22 <o-_-o> zygoloid, yes
06:57:47 <zygoloid> o-_-o: perform 1023 iterations. on iteration i <- [1..1023], node n sends a message to (n+i) `mod` 1024
06:58:58 <o-_-o> zygoloid, what is n ?
07:00:01 <zygoloid> number the nodes from 0 to 1023. n is the number of the node
07:00:26 <o-_-o> zygoloid, all nodes should be talking to each other at the same time,
07:01:02 <o-_-o> so they sync on a barrier or something and when all nodes have the destination nodes they send a buffer
07:04:58 <EvanR-work> @src reverse
07:04:58 <lambdabot> reverse = foldl (flip (:)) []
07:05:12 <EvanR-work> @src foldl
07:05:12 <lambdabot> foldl f z []     = z
07:05:12 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
07:05:50 <o-_-o> zygoloid, wow...I mean wow dude!
07:06:41 <EvanR-work> > take 5 $ reverse [1..100]
07:06:42 <lambdabot>   [100,99,98,97,96]
07:07:02 <EvanR-work> reverse is sort of strict isnt it
07:07:43 <Jonno_FTW> how can i have a multiline string in .hs file?
07:08:00 <EvanR-work> using any result of foldl will force evaluation of the whole list
07:08:13 <EvanR-work> Jonno_FTW: like this "hello\
07:08:17 <EvanR-work>                      \world"
07:08:21 <Jonno_FTW> ok
07:08:33 <EvanR-work> dont ask me how i did that
07:08:37 <gwern> EvanR-work: strict on the spine, I think the phrase goes
07:09:23 <gwern> > take 1 $ reverse [undefined, undefined, undefined, 1] -- let's see
07:09:24 <lambdabot>   [1]
07:09:49 <EvanR-work> it must traverse the entire spin
07:09:50 <EvanR-work> e
07:10:30 <EvanR-work> > take 2 $ reverse [undefined, undefined, undefined, 1]
07:10:31 <lambdabot>   [1,*Exception: Prelude.undefined
07:11:56 <Axman6> > last (repeat undefined)
07:12:01 <lambdabot>   mueval: ExitFailure 1
07:12:07 <EvanR-work> whats better, [(x, Maybe y)] or ([x], [Maybe y])
07:12:26 <Axman6> depends what the data is supposed to be representing
07:12:27 <byorgey> well, they are different.
07:12:27 <lambdabot> byorgey: You have 1 new message. '/msg lambdabot @messages' to read it.
07:12:41 <byorgey> the first one enforces that there are always the same number of x's as Maybe y's
07:12:49 <EvanR-work> i suppose the first is better, its always the same number
07:12:51 <byorgey> whereas with the second one there could be different numbers
07:12:53 <EvanR-work> the x goes with the maybe y
07:13:05 <byorgey> yup, if they are supposed to be matched up then the first is better
07:13:06 <koeien37> and if the values "belong" to each other, then the first is better
07:13:17 <gwern> EvanR-work: then the tuple. otherwise you had to march down two lists
07:13:34 <gwern> and as people say, you forfeit some guarantees with the double lists
07:13:35 <byorgey> note you can easily convert between them with  zip/unzip
07:13:54 <EvanR-work> > zip [1,2,3] ['a','b']
07:13:54 <lambdabot>   [(1,'a'),(2,'b')]
07:14:06 <EvanR-work> dropped my three
07:14:11 <byorgey> well, technically  uncurry zip
07:14:23 <byorgey> EvanR-work: right, what did you expect it to do with the 3 ?
07:14:32 <EvanR-work> in javascript, (3, undefined) :)
07:14:41 <EvanR-work> which sucks
07:14:44 <EvanR-work> so yeah
07:15:06 <EvanR-work> [(x,y)] it is
07:15:24 <byorgey> you can also make your own version of zip which matches unpaired elements with default values.
07:15:54 <byorgey> so that  defaultZip 0 'x' [1,2,3] ['a','b'] would give you [(1,
07:15:59 <dcoutts_> siracusa: you didn't install the glade package
07:16:05 <byorgey> [(1,'a'),(2,'b'),(3,'x')]
07:17:22 <EvanR-work> if i build a list by using ++, and 'march down' the result... the ++ wont be evaluated until I get to it?
07:17:29 <siracusa> dcoutts_: Oh, I didn't know it's a separate package
07:17:52 <EvanR-work> at which point i have [] ++ rest, and its simple
07:17:58 <EvanR-work> ?
07:18:06 <quicksilver> yes, that is roughly true
07:18:18 <quicksilver> > ([1..4] ++ undefined) !! 2
07:18:19 <lambdabot>   3
07:18:23 <EvanR-work> nice
07:18:34 <McManiaC> > undefined == undefined
07:18:35 <tromp_> the ++ will be pushed down the list while you consume it
07:18:35 <lambdabot>   *Exception: Prelude.undefined
07:18:48 <dcoutts_> siracusa: it's one of the gtk2hs components, if you're building gtk2hs from source, make sure you've got the glade C dev package installed
07:19:01 <EvanR-work> so ++ is an ok way to combine big lists, in some circumstances
07:19:08 <EvanR-work> rather than using Data.Sequence
07:19:11 <o-_-o> zygoloid, there is one problem
07:19:39 <o-_-o> zygoloid, when I am generating the numbers, when 1 -> 2 , 2 should not send to anyone
07:19:45 <dcoutts_> siracusa: for gtk2hs, ./configure --enable-glade will force it to enable the glade component so that it'll fail rather than disabling the optional component
07:19:51 <o-_-o> zygoloid, 2 should just receive
07:20:09 <o-_-o> zygoloid, A node should only be either sending or receiving
07:22:00 <fasta> dcoutts_, did you get my message?
07:22:14 <dcoutts_> fasta: no
07:22:30 <fasta> dcoutts_, I sent it to dcoutts, not dcoutts_. Does that matter?
07:23:14 <quicksilver> EvanR-work: it's only a linear cost as long as you nest it correctly
07:23:27 <quicksilver> EvanR-work: if you nest it left-associatively it can be a quadratic cost
07:23:51 <quicksilver> as you end up pushing a tower of (++) along for each step, to borrow tromp's phrasing.
07:24:02 <EvanR-work> so i want to do a ++ (b ++ (c ++ d))
07:24:05 <quicksilver> Data.Seq is sublinear, so it's quite a lot better.
07:24:07 <greedo> I'm trying to find the best way to scraper web pages
07:24:10 <quicksilver> yes, that's right EvanR-work
07:24:27 <EvanR-work> which means building it in reverse
07:24:28 <EvanR-work> ?
07:24:34 <quicksilver> not particularly
07:24:40 <quicksilver> it just means using a right fold to build, generally
07:24:50 <greedo> i saw tagsoup anything better out there?
07:24:54 <quicksilver> right folds aren't so much the reverse of left folds as inside-out. Or something.
07:25:13 <EvanR-work> what if a >> b = r a ++ r b, then using do notation
07:25:40 <quicksilver> the definition of >>= forces things to associate to the right
07:25:47 <EvanR-work> cool
07:25:52 <quicksilver> and the default defn. of >> just uses >>=
07:26:11 <EvanR-work> a >>= f = r a ++ f (r a)
07:26:11 <applicative> greedo, whats wrong with tagsoup?
07:26:50 <EvanR-work> quicksilver: good
07:27:56 <greedo> applicative: I'll give it a try I was just asking
07:32:41 <EvanR-work> @src repeat
07:32:41 <lambdabot> repeat x = xs where xs = x : xs
07:32:48 <EvanR-work> @src cycle
07:32:48 <lambdabot> cycle [] = undefined
07:32:48 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
07:32:58 <EvanR-work> @src replicate
07:32:58 <lambdabot> replicate n x = take n (repeat x)
07:33:20 <EvanR-work> how to repeat a list n times
07:34:14 <mreh> EvanR-work : concat . repeat n
07:34:33 <mreh> > concat . repeat 3 $ [1..3]
07:34:34 <lambdabot>   Couldn't match expected type `a -> [[a1]]'
07:34:34 <lambdabot>         against inferred type `[...
07:34:46 <EvanR-work> eh
07:34:52 <mreh> o_0
07:34:55 <IceDane> > concat . replicate 3 $ [1..3]
07:34:56 <lambdabot>   [1,2,3,1,2,3,1,2,3]
07:35:30 <EvanR-work> IceDane wins, flawless victory
07:35:38 <IceDane> M-M-MEGA KILL
07:36:10 <mreh> :t repeat 3 [1..3]
07:36:10 <lambdabot>     Couldn't match expected type `[t1] -> t'
07:36:11 <lambdabot>            against inferred type `[t2]'
07:36:11 <lambdabot>     In the expression: repeat 3 ([1 .. 3])
07:36:19 <mreh> oh...
07:36:54 <mreh> I hate when doing something in an imperative language is easier than in a functional one
07:37:38 <IceDane> I tend to feel the same way sometimes.. But I assume it's due to my gigantic handicap when it comes to functional programming
07:37:51 <mreh> IceDane: you might be right
07:37:54 <EvanR-work> mreh: this isnt one of those cases ;)
07:38:04 <mreh> I'm talking about something else
07:38:20 <mreh> I have to implement this in haskell http://cvit.iiit.ac.in/thesis/ranjeethMS2007/thesis/node21.html
07:38:53 <mreh> a nested forloop, not hard in haskell, but the iterations are not independent of each other
07:39:31 <IceDane> If there's anything I've found easy to do in haskell, it's often been math stuff
07:39:53 <mreh> it's all math
07:40:20 <quicksilver> a nested loop is just a nested map, mreh
07:40:26 <quicksilver> (occasionally a nested mapM)
07:40:36 <IceDane> yeah
07:40:47 <EvanR-work> :t map map
07:40:48 <lambdabot> forall a b. [a -> b] -> [[a] -> [b]]
07:40:48 <mreh> quicksilver: yeah, but I can't work out how to structure this problem
07:40:49 <EvanR-work> ;)
07:41:07 <siracusa> dcoutts_: I use your minimal GHC 6.10.4 build, is it possible to add the glade component to that build afterwards?
07:41:42 <mreh> I think I need a mapM, state monad possibly
07:42:11 <dcoutts_> siracusa: ahh, not easily.
07:42:55 <siracusa> dcoutts_: That means on Windows it's impossible :-P
07:43:02 <EvanR-work> mreh: well you can use mutable variables from inside the loop
07:43:08 <EvanR-work> MVar / IORef
07:43:11 <EvanR-work> STRef
07:43:44 <mreh> EvanR-work, I thought that was against the whole point of Haskell ;P
07:43:59 <EvanR-work> you just said you were doing an imperative algorithm ;)
07:44:39 <EvanR-work> foldl' is a way to do a loop not independent of the other iterations
07:44:56 <EvanR-work> nested folds
07:45:15 <mreh> foldl surely?
07:45:24 <EvanR-work> foldl' for good measure
07:50:11 <Sgeo> It's here!
07:54:32 <applicative> mreh, I notice there is a perceptron implementation in http://hackage.haskell.org/package/morfette but it is indeed very 'imperative' ...
07:56:11 <zygoloid> o-_-o: that's not such a problem. divide each phase into two: in phase 1a, you have 1->2, 3->4, 5->6, etc. in phase 1b you have 2->3, 4->5, ..., 1024->1
07:56:35 <o-_-o> zygoloid, hmm....
07:56:54 <zygoloid> because 1024 is a power of two, you can show that that division is always possible
07:58:20 <o-_-o> hmm...
08:04:25 <gwern> @hoogle [a->Bool] -> a -> Bool
08:04:26 <lambdabot> Data.Foldable all :: Foldable t => (a -> Bool) -> t a -> Bool
08:04:26 <lambdabot> Data.Foldable any :: Foldable t => (a -> Bool) -> t a -> Bool
08:04:26 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
08:05:00 <greedo> when I try to install base-4.2.0.1 with cabal it says it needs ghc-prim and integer
08:05:21 <dcoutts_> greedo: you can't upgrade/downgrade base
08:05:32 <dcoutts_> greedo: the version is fixed for each ghc release
08:06:10 <greedo> ok, so i just need the newest version of ghc
08:07:25 <applicative> greedo, what are you trying to install
08:07:33 <greedo> tagsoup
08:09:11 <applicative> greedo, what version of ghc do you have.  I have tagsoup with 6.10.something,
08:10:05 <greedo> applicative: looks like version 6.8.2
08:10:14 <applicative> I see.
08:11:50 <applicative> I don't know how much trouble you'd get into if you tried cabal install tagsoup-0.6
08:12:33 <greedo> applicative: the ubuntu repos for ghc are a little out of date
08:12:33 <applicative> greedo, that is supposed to have been built with 6.8.2   what version of base does  > ghc-pkg list     show you
08:12:41 <dcoutts_> you can use --dry-run to see what it'd do
08:13:09 <zygoloid> o-_-o: how're you getting on?
08:13:14 <applicative> right, of course.    cabal install tagsoup-0.6 --dry-run
08:13:57 <greedo> In order, the following would be installed (use -v for more details):
08:13:57 <greedo> tagsoup-0.6
08:14:12 <greedo> guessing that works
08:14:14 <applicative> well that looks pretty good then.
08:14:35 <greedo> worked
08:15:00 <applicative> you will also want to cabal unpack tagsoup-0.6  in some suitable place if you want to study the code for that version
08:15:26 <greedo> is the import module named tagsoup
08:16:02 <dcoutts_> greedo: cabal info tagsoup-0.6
08:16:16 <applicative> the modules are 'haddocked' on http://hackage.haskell.org/package/tagsoup-0.6
08:17:01 <greedo> woah, there are a lot
08:18:49 <gwern> libraries are complex because your needs are complex
08:20:06 <gwern> greedo: but tagsoup comes with examples. it's really not that hard to do simple stuff
08:20:38 <greedo> gwern: yeah, I've been looking at the examples online, they are good
08:21:04 <applicative> the stuff from most of the modules is exported in Text.HTML.TagSoup  soyou can import that for most of the 'library' materials, looks like.
08:21:13 <greedo> ya
08:23:55 <applicative> I hadn't understood that haddock can hunt down the type signatures of re-exported functions.
08:26:57 <greedo> i'm trying to also find the name of the Network.HTTP package
08:27:04 <Jonno_FTW> what file is cabal looking for when it wants: * Missing C library: fcgi
08:27:19 <EvanR-work> libfcgi?
08:27:22 <EvanR-work> .so
08:27:23 <greedo> is there a standard naming scheme
08:27:35 <dcoutts_> Jonno_FTW: re-run with -v3, you'll see what it runs and what the linker says
08:27:52 <greedo> or does cabal have a search function similar to aptitude
08:28:11 * Jonno_FTW is running on windows
08:28:18 <Jonno_FTW> i got fcgi to compile
08:28:24 <Jonno_FTW> and locate the header file
08:28:35 <Jonno_FTW> but i can't find the library
08:29:30 <dcoutts_> Jonno_FTW: so when you find the fcgi library (.dll/.lib/.a) then configure the Haskell package with --extra-lib-dirs=
08:29:33 <applicative> greedo, yes  there is a standard naming system.  The haddocked material shows the relationships http://hackage.haskell.org/package/HTTP
08:30:33 <Jonno_FTW> i found it
08:30:33 <mdmkolbe> Where did the documentation for Control.Monad.Reader et al. go?  I don't see it on http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
08:31:00 <LMolr> haskell, i miss you! one day i'll come back to learn you!     (sorry..)
08:31:24 <Jonno_FTW> was hiding in fcgi-2.4.0/libfcgi/.libs
08:31:27 <applicative> LMoir, no.. stay...
08:31:31 <byorgey> mdmkolbe: it's no longer in the libraries that come with ghc which is why it isn't there any more
08:31:42 <byorgey> mdmkolbe: you'll have to look at the docs for mtl on hackage
08:31:46 <byorgey> @hackage mtl
08:31:46 <lambdabot> http://hackage.haskell.org/package/mtl
08:31:56 <dcoutts_> Jonno_FTW: hmm, that looks like the dir of a build tree, sounds like you might need to install it first
08:32:18 <Jonno_FTW> well cabal install fcgi fine
08:32:36 <dcoutts_> Jonno_FTW: no I mean the C lib sounds like it's not installed, just built
08:33:21 <dino-> Oh no! I think Text.Regex doesn't support non-capturing groups, commonly used for alternation: (?:foo|bar)
08:33:27 <dino-> At least the regex-compat I've got here
08:33:39 <eikke> is it in haskell possible to define something (I assume a monad) which would allow me to encode, on type-system level, that when some code is executed in a database transaction, access to IO should be forbidden?
08:33:56 <eikke> I'd think it is... but pointers on how to work on something alike would be nice :)
08:36:51 <siracusa> eikke: What kind of code can be executed in a transaction?
08:37:40 <eikke> siracusa: calls to the DB to retrieve data, and pure calculations on this data
08:37:41 <b0fh_ua> Hi there! What is the best way to hide data constructors - but expose access to data properties in modules? Enumerating all properties in "where" is a bit annoying...
08:38:04 <eikke> siracusa: so I assume what I want is a way to 'limit' access to IO, only allowing some specific functions (execute query, basically)
08:38:10 <Jonno_FTW> Now i get the error: Loading package fastcgi-3001.0.2.2 ... <interactive>: fcgi: The specified module could not be found.
08:38:13 <Jonno_FTW> can't load .so/.DLL for: fcgi (addDLL: could not load DLL)
08:39:11 <Tass_> playing with ghci - what's wrong with fun p q r s = p and q or r and s # ?
08:39:27 <FauxFaux> s/fun/let/
08:39:29 <fasta> eikke, what you can do is provide a module in which you can do these operations. You then basically put a stamp on it saying that only that code can execute IO stuff. Then you use that interface to do all your other computations.
08:39:39 <applicative> b0fh_ua, I think you could mean different things. Which things are you calling constructors, and which 'properties'
08:39:52 <fasta> eikke, and a monad is a common way to present that functionality.
08:40:13 <Tass_> FauxFaux, should be a function
08:40:28 <dino-> b0fh_ua: I'm taking that to also mean you deliberately don't want to be able to pattern match these types.
08:40:39 <eikke> fasta: what sort of 'stamp' would that be?
08:41:02 <applicative> > let fun p q r s = p && q || r && s in fun True True False False
08:41:03 <lambdabot>   True
08:41:08 <fasta> eikke, that would be a type.
08:41:22 <fasta> eikke, so you wrap the IO type and only expose a few functions.
08:41:36 <Tass_> ahhh
08:41:48 <fasta> eikke, so, your users get access to e.g. the DBIO type.
08:41:50 <applicative> > let fun p q r s = p && q || r && s in fun True Fasle  False False  --  Tass_ is this what you mean?
08:41:50 <lambdabot>   Not in scope: data constructor `Fasle'
08:42:01 <Tass_> yep
08:42:02 <eikke> fasta: that'd be the idea, and then I guess I need some runTransaction function as well
08:42:33 <applicative> Tass_ note the (natural) precedence for && and ||
08:42:33 <fasta> eikke, the running of the transaction would imply be getting the constructed io value.
08:42:35 <Tass_> applicative, and can I let it iterate over all possible combinations easyly too? :-)
08:42:48 <Tass_> applicative, precedence is in order?
08:43:19 <applicative> && binds more tightly than ||  -- like * and +, which they're like in other ways.
08:43:48 <applicative> when you say, "can I let it iterate over all possible combinations easyly too" you mean, go through the truth table so to speak
08:43:58 <Tass_> applicative, I'm actually doing some exercises with propositional logic - I assume haskell behaves the same way as prop logic does?
08:44:06 <Tass_> applicative, yeah. :-)
08:44:18 <dino-> b0fh_ua: If you mean you'd like consumers of a module to be able to see values inside data types without deconstruction or record-style, then you may need to write your own 'accessor' functions like record-style would have, in that module where it does have access to the constructor.
08:44:19 <applicative> Tass_ it will be easy to write the definitions.
08:44:54 <Tass_> applicative, but applying them? ...
08:46:00 <siracusa> Tass_: The easiest way would be to use list comprehensions
08:46:12 <eikke> fasta: think I'll take a look to Halfs, which should do something similar :)
08:46:16 <b0fh_ua> dino-: let me pastebin :)
08:46:26 <Tass_> siracusa, there we are at learning haskell ;-)
08:47:10 <applicative> Tass_ there are a lot of things you might want to do here
08:47:18 <DanC> "Seriously, there's no good way to use a human brain to talk about quantum physics in English." -- http://lesswrong.com/lw/pp/decoherence/
08:47:35 <greedo> so I'm trying to pass a string through to this openURL function
08:47:38 <greedo> http://pastebin.com/jVAkgYqd
08:47:49 <fasta> eikke, consider reading from the data base, which has type IO. You can create such a value by saying DBIO (myfunction_which_accesses_db). The >>= function will then take the result of that and pass it to another DBIO action.
08:47:56 <fasta> eikke, it is a really simple idea.
08:48:01 <b0fh_ua> dino-: http://pastebin.com/pU0Hapst
08:48:19 <greedo> but I'm pretty sure I'm doing this incorrectly
08:48:25 <fasta> eikke, the "unsafe" code is all the stuff which is in the monad, which is not in the Monad type class.
08:48:35 <fasta> eikke, that is, specific to your particular monad.
08:48:45 <b0fh_ua> so now I don't want to allow creation of Credentials with something other than makeCredentials
08:48:46 <applicative> Tass_, there's a pleasant thread from a few years ago http://www.haskell.org/pipermail/haskell-cafe/2007-February/022219.html
08:48:55 <fasta> eikke, does that make sense to you?
08:49:05 <b0fh_ua> but I still need to extract username and password from UserPwdCredentials
08:49:13 <eikke> fasta: yes, from a theoretic POV :)
08:49:19 <dino-> Oh does that work? Mixing record style with empty constructor?
08:49:21 <dino-> Never tried that
08:49:38 <fasta> eikke, you might want to experiment first a bit with other monads, I suppose.
08:49:39 <eikke> fasta: I mean, I understand how it should work, but that doesnt imply I can write it to code :)
08:49:48 <b0fh_ua> dino-: it does
08:49:55 <fasta> eikke, I know the feeling; I am just past it.
08:50:05 <Tass_> applicative, what's the precendece of && || btw?
08:50:18 <b0fh_ua> so I just want to make abstract credentials type users can't access directly to create one
08:50:57 <dino-> b0fh_ua: I understand, you may need to write your own functions like getCredUsername :: Credentials -> String and similar
08:51:26 <b0fh_ua> dino-: well, I can rewrite it as following
08:51:30 <dino-> In which case, I'd probably ditch the record-style altogether.
08:51:30 <Tass_> applicative, awesome thread btw ;-)
08:51:50 <b0fh_ua> dino-: http://pastebin.com/GnTyac2g
08:51:57 <siracusa> greedo: Your wiki function has to return a value of type (), so does it help to add a `return ()'?
08:52:00 <b0fh_ua> username and password seems to be generated by haskell for me
08:52:28 <b0fh_ua> but I still need to list them in exports
08:52:50 <applicative> Tass_ do you have ghc installed.  in general you can type :info ||   and it will tell you the type and the precedence information and where it's defined
08:54:28 <applicative> Tass, so in this case, > :i &&  > (&&) :: Bool -> Bool -> Bool 	-- Defined in GHC.Classes  infixr 3 &&
08:54:40 <applicative> and > :i || (||) :: Bool -> Bool -> Bool 	-- Defined in GHC.Classes
08:54:41 <applicative> infixr 2 ||
08:54:43 <greedo> http://pastebin.com/BtU2t8pQ
08:54:43 <eikke> fasta: heh, thought I remembered something, and seems to be correct: there's a part of RWH about my above 'problem' :D
08:55:02 <greedo> siracusa: it does actually
08:56:00 <fasta> eikke, I don't think RWH gives insight on monads, if you don't already have it.
08:56:22 <gwern> Noone can *show* you the Monad, Greedo
08:56:30 <applicative> Tass_, infixr means, the (unwritten) parentheses pile up to the right.  3 is higher than 2 so && binds more than ||
08:56:31 <fasta> eikke, their monad transformer example does not demonstrate that the authors used it extensively.
08:56:58 <Tass_> applicative, ah oke
08:57:13 <gwern> fasta: not sure I would accuse bos or dons of ideological impurity
08:57:15 <EvanR-work> are all monoids monads ?
08:57:18 <gwern> EvanR-work: no
08:57:31 <dino-> b0fh_ua: Still looking at it..
08:57:38 <gwern> EvanR-work: consuder + or * on Integers; both are monoids, neither monads
08:57:41 <applicative> so  p && q && r || s || t && u  is three dijoined propositions
08:57:45 <fasta> gwern, bos admitted that he was "learning about monad transformers" when he wrote the book.
08:57:54 <fasta> gwern, I am not accusing anyone of anything.
08:58:03 <gwern> fasta: monad transformers aren't solved; no one has 'learned' them
08:58:12 <fax> I have learned them
08:58:13 <fax> gwern
08:58:17 <EvanR-work> gwern: can any monoid be 'promoted' to a monad via some simple recipe?
08:58:19 <applicative> Tass_, ( p && q && r ) || s || (t && u)
08:58:23 <quicksilver> you're coming across as just being defensive of them, gwern
08:58:31 <fax> I agree with you that they are probably not the best solution though
08:58:40 <fasta> gwern, well, I am pretty sure that some people would consider that they understand them.
08:58:42 <fax> right now they are what we've got
08:58:44 <quicksilver> just because they're smart, nice guys, and wrote a book doesn't mean they get everything right.
08:59:01 <gwern> EvanR-work: I can't think of any. you could probably hack something together, but it'd be a hack, like defining multiplication on Strings
08:59:25 <EvanR-work> i mean, >> is like mappend, in some sense
08:59:29 <gwern> EvanR-work: it'd be like asking, can any object be 'promoted' to an implementor of the Num typeclass via some simple recipe
08:59:45 <fax> EvanR, I think >> calles mappend in the writer monad? :P
08:59:57 <EvanR-work> yes, for example
09:00:07 <fax> so there is definitely a connection there
09:00:14 <applicative> Tass_  you can just supply the parentheses if you are confused.
09:00:30 <mdmkolbe> @t lift
09:00:30 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
09:00:33 <quicksilver> EvanR-work: yes, in a strong sense.
09:00:44 <mdmkolbe> @type lift
09:00:45 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
09:00:51 <quicksilver> EvanR-work: "return ()" and ">>" make "m ()" into a Monoid, for all Monads m
09:01:12 <EvanR-work> thats that way
09:01:18 <gwern> let's see, how does it go? all monads are monoids, but not all monoids are monads? haven't read my typeclassopedia in a while
09:01:18 <EvanR-work> but what about the other way
09:01:35 <quicksilver> well any Monoid is a Monad which doesn't actually compute anything
09:01:38 <quicksilver> hence the (), above
09:01:46 <EvanR-work> for example you can put a norm on any vector space with an inner produce sort of thing
09:01:50 <quicksilver> to turn a Monoid into a 'real' Monad you need to deicde to store something there.
09:01:51 <EvanR-work> product
09:02:08 <dino-> b0fh_ua: Ah, the where goes after the export list.
09:02:16 <EvanR-work> quicksilver: something besides the monoid values?
09:02:26 <EvanR-work> cant we just use those
09:03:35 <quicksilver> no, you can't.
09:03:45 <quicksilver> polymoprhism says you can put any kind of value in there
09:04:15 <quicksilver> if m is a Monad, I can have 'm Int' which computes Ints, m Char which computes Chars,
09:04:27 <EvanR-work> so monads only make sense when we are doing something uniform with 'any type of value'
09:04:47 <dino-> b0fh_ua: Yeah, that works. I was shaky on it myself, exporting the record names separately. Interesting.
09:05:10 <quicksilver> yes, the structure of the Monad cannot restrict the kind of value inside
09:05:18 <quicksilver> because "return foo" is a valid expression
09:05:39 <quicksilver> ... for all monads, and all possible foo of all possible types.
09:06:01 <EvanR-work> that helps me figure out what possible uses of monads are
09:06:45 <b0fh_ua> dino-: yep, I mistyped that
09:06:46 <EvanR-work> so, a data structure that can a set of values of any type?
09:06:47 <b0fh_ua> interesting
09:06:55 <EvanR-work> can contain
09:07:06 <EvanR-work> like ['a', 0, True]
09:07:19 <EvanR-work> return 'a' >> return 0 >> return True
09:08:04 <gwern> > ['a', 0, True]
09:08:05 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
09:08:05 <lambdabot>         against inferred type...
09:08:15 <b0fh_ua> dino-: http://pastebin.com/W7eamvjY
09:08:15 <gwern> EvanR-work: we don't have heterogenous lists
09:08:44 <b0fh_ua> see, if several data types are sharing same property name, the function for that property name seems to be exported for all of them
09:08:49 <pikhq> Can't be done in a well-typed manner.
09:09:13 <pikhq> (modulo some hackish tricks such as Oleg coding, or Dynamic)
09:09:30 <fax> what is the value of ['a', 0, True]?
09:09:37 <gwern> fax: one hand clapping
09:09:55 <idnar> fax: a type for that can't be inferred
09:10:13 <EvanR-work> ignore that expression
09:10:13 <fax> @pl head ['a', 0, True]
09:10:14 <lambdabot> 'a'
09:10:16 <EvanR-work> discuss this
09:10:16 <gwern> EvanR-work: when it says 'm a', 'a' doesn't change
09:10:18 <fax> @pl tail ['a', 0, True]
09:10:18 <lambdabot> [0, True]
09:10:23 <fax> I don't see a problem
09:10:31 <dino-> b0fh_ua: Interesting. Also, note that if you had another data type with 'username', it would collide.
09:10:35 <gwern> fax: pl doesn't check types. it's syntax
09:10:39 <EvanR-work> return 'a' >> return 0 >> return True
09:10:39 <idnar> > ['a', 0, True] :: [forall a. (Show a) => a]
09:10:40 <lambdabot>   Couldn't match expected type `a'
09:10:40 <lambdabot>         against inferred type `GHC.Bool.Bo...
09:10:51 <fax> so what we ned is syntaskell?
09:10:55 <gwern> fax: you can trick pl into emitting even incorrect syntax. it's not that great
09:11:02 <idnar> hmph, I think you need a newtype to pull that trick off
09:11:04 <idnar> or something
09:11:07 <fax> none of those sily types stopping perfectly sensible programs from working
09:11:17 <zygoloid> @pl \xs -> [x | x <- xs]
09:11:18 <lambdabot> return . ((x | x) <-)
09:11:24 <pikhq> EvanR-work: Yes, the value of that is of type (Monad m)=>m Bool
09:11:26 <idnar> zygoloid: haha, nice
09:11:29 <b0fh_ua> dino-: I don't think so
09:11:30 <mdmkolbe> @type fmap2
09:11:30 <lambdabot> Not in scope: `fmap2'
09:11:31 <gwern> idnar: you mean something like 'data Foo = Foo Char | Foo Int | Foo Bool' and then EvanR-work's list is :: [Foo]?
09:11:33 <EvanR-work> ok
09:11:36 <fax> pl just makes some unpopular assumptions
09:11:36 <gwern> that'd work
09:11:39 <b0fh_ua> cuz it will use correct function on correct data
09:11:39 <zygoloid> @@ @pl @undo \xs -> [x | x <- xs]
09:11:40 <lambdabot>  id
09:11:40 <harlekin> When writing a Happstack application using Happstack's own HTTP server will it be hard to migrate to a FCGI application?
09:11:43 <idnar> gwern: well, no, I was thinking of existentials
09:12:32 <Tass_> is there also a truth operator for `implies` in haskell ?
09:12:45 <zygoloid> ['a', 0, True] :: (Char ~ Bool, Num Bool) => [Bool] ;-)
09:12:46 <pikhq> > ['a', 0, True] :: [exists a. (Show a) => a] -- This?
09:12:47 <lambdabot>   <no location info>: parse error on input `.'
09:12:51 <Tass_> as in logical implementation
09:12:59 <idnar> pikhq: yes, except that syntax doesn't exist
09:13:03 <Tass_> ehh implication
09:13:11 <pikhq> idnar: As I discovered.
09:13:13 <pikhq> :)
09:13:14 <fax> > [show 'a', show 0, show True]
09:13:15 <lambdabot>   ["'a'","0","True"]
09:13:34 <idnar> I think you can't have a list of bare existentials, the existential has to be wrapped in a data or newtype
09:13:38 <pikhq> And now fax demonstrates the real way to do it. By stringising. :)
09:13:44 <zygoloid> @type [?a, 0, True] :: (?a :: Bool, Num Bool) => [Bool]
09:13:45 <lambdabot>     No instance for (Num Bool)
09:13:45 <lambdabot>       arising from an expression type signature at <interactive>:1:0-48
09:13:45 <lambdabot>     Possible fix: add an instance declaration for (Num Bool)
09:13:46 <fax> > let x a f = (show x, f x) in [x 'a', x 0, x True]
09:13:46 <lambdabot>   Occurs check: cannot construct the infinite type:
09:13:47 <lambdabot>    t = (t2 -> t -> t1) ->...
09:13:49 <fax> damn
09:13:50 <dino-> This makes us do things like data Foo = Foo { fooUser, fooPwd :: String }
09:14:00 <idnar> data Showable = forall a. (Show a) => Showable a
09:14:13 <fax> > let x a = (show x, f x) in [x 'a', x 0, x True]
09:14:14 <lambdabot>   Ambiguous type variable `t' in the constraints:
09:14:14 <lambdabot>    `GHC.Show.Show t'
09:14:14 <lambdabot>      a...
09:14:37 <idnar> [Showable 'a', Showable 0, Showable True] :: [Showable]
09:15:23 <EvanR-work> so that idea is out the window, nevermind
09:15:55 <zygoloid> > let k :: (forall a. Show a => a -> b) -> [b]; k f = [f 'a', f 0, f True] in k show
09:15:56 <lambdabot>   ["'a'","0","True"]
09:16:31 <gwern> '34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
09:17:39 <applicative> Tass_, you can define your own material conditional
09:17:44 <applicative> > let p ==> q = p || not q in [True ==> False, True ==> True, False ==> False, False ==> True]
09:17:45 <lambdabot>   [True,True,True,False]
09:17:51 <zygoloid> > let k :: (forall a. Typeable a => a -> b) -> [b]; k f = [f 'a', f 0, f True] in k (\x -> fromJust $ show <$> (cast x :: Maybe Integer) <|> show <$> (cast x :: Maybe Char) <|> show <$> (cast x :: Maybe Bool))
09:17:52 <lambdabot>   ["'a'","0","True"]
09:18:09 <fax> http://i.imgur.com/96e61.png <-- haskell used to be a lot cooler in the middle ages
09:18:32 <Tass_> applicative, funky!
09:18:46 <zygoloid> applicative: you mean p ==> q = q || not p, right?
09:19:08 <zygoloid> fax: awesome :)
09:19:39 <applicative> zygloid, thanks,
09:19:56 <Tass_> > let p ==> q = q || not p in [True ==> False, True ==> True, False ==> False, False ==> True]
09:19:57 <lambdabot>   [False,True,True,True]
09:20:15 <EvanR-work> ==> ?
09:20:19 <applicative> > let p ==> q = not p || q in [True ==> False, True ==> True, False ==> False, False ==> True]
09:20:20 <lambdabot>   [False,True,True,True]
09:20:22 <EvanR-work> ah
09:20:34 <EvanR-work> fancy
09:20:36 <applicative> Tass_ sorry, my conditional was backwards...
09:21:03 <applicative> Tass_ sorry, I see you corrected it...
09:25:22 <EvanR-work> are there built in monoid methods like ... 5*x for some x in the monoid
09:25:30 <EvanR-work> where 5* means 5 mappends
09:25:36 <fax> no I don't think so
09:25:46 <Tass_> applicative, got a <==> lying around too? ;-)
09:25:50 <fax> (wouldn't you write x^5 though?)
09:26:01 <eikke> fasta: I got RWH at home :-)
09:26:14 <eikke> fasta: btw, http://gist.github.com/376738 is +- what I wanted (extremely simplified, obviously)
09:26:18 <EvanR-work> fax: whatever
09:26:23 <EvanR-work> im thinking of mappend as +
09:26:45 <EvanR-work> i dont want a literal *, just some 'do n mappends'
09:26:48 <fax> oh I see what you mean
09:26:54 <fasta> eikke, that is exactly what I said, no?
09:27:02 <fax> write 5`x`x
09:27:11 <fax> or 5(x)x (unicode symbol)
09:27:11 <EvanR-work> :o
09:27:12 <fax> just define it
09:27:28 <fax> it sucks there's no Nat type in Predude
09:27:33 <EvanR-work> with built in stuff, i guess its mconcat $ replicate n x
09:27:34 <fax> to define stuff like this with a fold
09:27:44 <eikke> fasta: yes, and what I meant ;) but I couldnt find code samples :)
09:27:47 <djahandarie> lol, predude
09:28:04 * EvanR-work makes the beavis and butthead laugh noise
09:28:24 <fasta> Who invented this "prelude" word in the context of Haskell anyway? What was wrong with "standard library"?
09:28:39 <Tass_> applicative, mergh. use ==
09:28:46 <fax> fasta the standard library is much bigger than the prelude
09:28:48 <djahandarie> fasta, it's actually the "standard prelude"
09:29:07 <fasta> fax, ah, true.
09:29:17 <siracusa> Tass_: <==> is easy, you can define it in terms of ==>
09:29:22 <EvanR-work> > mconcat $ replicate 5 9
09:29:23 <lambdabot>   Ambiguous type variable `a' in the constraints:
09:29:23 <lambdabot>    `Data.Monoid.Monoid a'
09:29:24 <lambdabot>  ...
09:29:48 <Tass_> siracusa, well, I can use == as well, can't I?
09:29:52 <EvanR-work> > mconcat $ replicate 5 (9 :: Monoid Int)
09:29:53 <lambdabot>   Class `Data.Monoid.Monoid' used as a type
09:29:59 <k23z__> how many tests does Hugs have ? the CORE language I mean ... ?
09:30:02 <k23z__> or ghc
09:31:08 <EvanR-work> monoids mappend must be associative right
09:31:16 <mauke> yes
09:31:20 <chrisdone> forkablemonad, nice idea
09:31:25 <EvanR-work> i never remember to 'prove' this for monoids icome up with
09:31:48 <hydo> Is there a way to get the values of several Maybe's?  I'm parsing form data in a web application and the function that parses the data out of the request gives it back as Maybe String.  So at the moment, for every value I want I have to say 'let name = fromJustDef "" $ get x xx'.  Is there a better way to get these values?
09:31:52 <chrisdone> atm i have to do get >>= \st -> forkIO $ runStateT ... st
09:32:01 <k23z__> how many tests does Haskell have ?
09:32:05 <k23z__> ghc or hugs in particular
09:32:09 <siracusa> Tass_: Sure you can, that would be even more easy :-)
09:32:09 <chrisdone> hydo: catMaybes is one way
09:32:12 <chrisdone> :t catMaybes
09:32:13 <lambdabot> forall a. [Maybe a] -> [a]
09:32:18 <Tass_> > [(p,q,r, ((not p) == ( q ==> (not r))), ( q ==> (not r)) | p <- [True, False], q <- [True, False], r <- [True, False]]
09:32:19 <lambdabot>   <no location info>: parse error on input `|'
09:32:25 <Tass_> meh.
09:32:28 <k23z__> how many tests does Haskell have ?
09:32:29 <k23z__> ghc or hugs in particular
09:32:37 <hydo> chrisdone: ooo.. thanks!
09:32:41 <chrisdone> :D
09:32:41 <hydo> looking...
09:33:20 <Tass_> where's my syntax error?
09:34:47 <siracusa> > [(p,q,r, ((not p) == ( q ==> (not r))), ( q ==> (not r))       )       | p <- [True, False], q <- [True, False], r <- [True, False]]
09:34:48 <lambdabot>   Not in scope: `==>'Not in scope: `==>'
09:34:51 <chrisdone> > [(p,q,r, ((not p) == ( q ==> (not r))), ( q ==> (not r))) | p <- [True, False], q <- [True, False], r <- [True, False]]
09:34:53 <lambdabot>   Not in scope: `==>'Not in scope: `==>'
09:34:56 <siracusa> Tass_: Missing )
09:34:58 <chrisdone> tee hee
09:35:13 <Tass_> siracusa, uh, thanks
09:35:13 <fax> @let (==>) = 6
09:35:14 <lambdabot>  Defined.
09:35:16 <fax> there you guys go
09:35:23 <chrisdone> type error anyway
09:35:32 <chrisdone>  Couldn't match expected type `Bool'  against inferred type `Property'
09:35:33 <fax> > (==>) + (==>)
09:35:33 <applicative> you have to keep ==> in scope
09:35:34 <lambdabot>   12
09:36:00 <k23z__> how many tests does Haskell have ?
09:36:01 <k23z__> ghc or hugs in particular
09:36:06 <chrisdone> k23z__: what is a test?
09:36:29 <k23z__> chrisdone, well when you write an app, you write tests to ensure you weed out bugs faster and stuff like that
09:36:38 <mauke> k23z__: don't make me kick you
09:36:40 <k23z__> chrisdone, so when they wrote the Haskell hugs compiler they wrote tests
09:36:57 <applicative> > let p ==> q = p || not q in [(p,q,r, ((not p) == ( q ==> (not r))), ( q ==> (not r)) ) | p <- [True, False], q <- [True, False], r <- [True, False]]
09:36:58 <lambdabot>   [(True,True,True,False,True),(True,True,False,False,True),(True,False,True,...
09:37:09 <k23z__> chrisdone, I was looking on the hugs source right now to see how many tests there are and couldn't find hte answer for myself
09:37:29 <gwern> k23z__: ghc doesn't come with many tests itself. core packages like cabal and syb will come with a fair number of tests
09:37:34 <k23z__> mauke, why would you kick me ? I asked how many tests hugs has, I downloaded hugs source code and I couldn't figgure it woudl for myself
09:37:48 <k23z__> gwern, ok, how can I count them ?
09:37:50 <gwern> k23z__: really, all of Hackage is GHC's tests
09:38:02 <mauke> k23z__: and how often did you ask?
09:38:07 <gwern> dcoutts_ and others run each ghc RC against hackage
09:38:07 <k23z__> gwern, but the interpreter itself doesn't have tests ?
09:38:09 <applicative> Tass_, it was missing a last parenthesis for the 5-tuple where it said, before the |
09:38:17 <gwern> k23z__: ghc isn't an interpreter. it's a compiler
09:38:42 <k23z__> hugs
09:38:50 <applicative> Tass_,  the error message meant, "I was reading this fine till I got to the '|'..."
09:38:51 <gwern> k23z__: hardly anyone uses hugs these days
09:39:12 <k23z__> ok ghc then
09:39:21 <Tass_> applicative, kk
09:39:23 <gwern> k23z__: heck, hugs hasn't even had a release since 2006
09:39:30 <applicative> hugs is great!
09:39:57 <gwern> k23z__: there is the nofib suite of tests, but that's aimed at performance regressions and benchmarking and is pretty obscure
09:40:17 <gwern> applicative: I'd agree that hugs are great, not that hugs is great :)
09:40:23 <applicative> let a hundred implementations blossom, let a hundred language extensions contend
09:40:39 <gwern> he who chases two hares eats neither
09:40:55 <applicative> gwern, what are you going to do if SPJ gets hit by a car?
09:41:05 <gwern> applicative: pray for his immortal soul if he has one
09:41:13 <applicative> well, of course that
09:41:50 <gwern> applicative: I don't worry; ghc is develoepd using a RAIS - redundant array of independent simons
09:42:52 <applicative> What if the Anti-Simon League takes them from us?  (One shudders to think.)
09:43:28 <djahandarie> Don't worry they are already busy with Marlow
09:43:28 <gwern> k23z__: why are you so fixated on number of tests? you can't even do a cross-language comparison number of quickcheck tests to unit tests. just asking 'how many tests' strikes me as fodder for clueless blog posts
09:43:54 <k23z__> gwern, no blog posts
09:44:20 <djahandarie> gwern, there are non-clueless blog posts? That's kind of how I define blogs in general
09:44:29 <chrisdone> :(
09:44:33 <gwern> djahandarie: of course there are. just go read some sigfpe
09:44:37 * chrisdone deletes his blog forever
09:45:23 <applicative> chrisdone, don't worry, you dont have a blog, you have documentation
09:45:46 <fax> hey k23z___
09:46:03 <applicative> i mean, that's what it would properly be called.
09:46:25 * chrisdone stops worrying
09:48:08 <fax> "Category theory is doing/has done a stellar job on Set, FinSet, Grp, Cob, Vect, cartesian closed categories provide a setting for -calculus" ...
09:48:11 <k23z__> hey fax , sup ?
09:48:12 <fax> but what the heck is COB?
09:48:32 <fax> k23z__ I have implemented some numbers like naturals, fractions and complexes
09:48:40 <fax> but I haven't done any of the algebraic stuff
09:48:46 <k23z__> fax, can you push to github please ?
09:48:49 <fax> okay
09:49:01 <applicative> fax http://ncatlab.org/nlab/show/cobordism+hypothesis
09:49:24 <fax> ahhh I have been hearing about 'cobordism' every so often...
09:49:42 <fax> came up in that 'how to divide by 3' paper
09:49:46 <zygoloid> k23z__: i believe this is the testsuite which ghc patches are expected to pass: http://darcs.haskell.org/testsuite/
09:51:03 <k23z__> zygoloid, how much tests are there ?
09:51:09 <k23z__> zygoloid, or how do I write something to count them ?
09:51:28 <k23z__> zygoloid, can I grep them out of the files ? what extension does a testfile have ? where are the testfiles located there ?
09:51:32 <zygoloid> what meaning do you hope to extract from a number of tests?
09:51:47 <zygoloid> what do you count as one test?
09:52:03 <k23z__> I read here http://hackage.haskell.org/trac/ghc/wiki/Building/RunningTests  ---> "Each test in a test.T file is specified by a line the form"
09:52:09 <k23z__> that correct ?
09:52:59 <k23z__> zygoloid, my hunch(and hope) is that a language nearly as complicated as Haskell will have around the same number of tests and one could predict when that other language will be done by seeing how close to the number of tests it gets
09:53:08 <k23z__> zygoloid, you understood what I meant, it's very intuitive
09:53:25 <zygoloid> k23z__: your hunch is meaningless since number of tests is not objectively measurable
09:53:40 <k23z__> zygoloid, yes I know it's not objective
09:53:56 <k23z__> zygoloid, subjective is fine with me
09:54:29 <zygoloid> suppose i have one test which says 'main = putStrLn $ product [1..10]' on the one hand, and six tests on the other hand which test individual things like putStrLn, product, lists, integers, enumFromTo
09:54:38 <zygoloid> is the one less than the six?
09:54:50 <zygoloid> or should we count that first test as six separate tests?
09:56:09 <k23z__> zygoloid, you are right
09:56:16 <zygoloid> the tests in that testsuite are quite high-level for the most part, so if you're comparing against a testsuite with lower-level tests you'll find that ghc has fewer
09:56:16 <k23z__> zygoloid, still I'd like an estimate on the number of tests
09:56:52 <zygoloid> k23z__: well, you should be able to work that out for yourself. you already know how.
09:57:10 <k23z__> zygoloid, I don't that's the problem
09:57:16 <zygoloid>  "Each test in a test.T file is specified by a line the form"
09:57:41 <zygoloid> so find the .T files and count the number of lines of whatever form they give in that page
09:57:47 <k23z__> ghc-6.10.1 # find -name *.T | xargs cat | grep test | wc -l
09:57:47 <k23z__> 72
09:57:52 <k23z__> that's not possible ...
09:57:58 <k23z__> I'm sure there are much more than 72 tests
09:58:02 <gwern> oy gevalt
09:58:12 <gwern> you're really testing our patience here
09:58:29 <fax> k23z___ ???
09:59:34 <AMOne-77> :quit
10:09:24 <zygoloid> k23z__: ok, i give in. using a non-incompetent search, there are 2437 tests.
10:10:46 <djahandarie> zygoloid, but surely that is too [many|few]!
10:10:48 <orlandu63> @pl (\g a b c -> f a b 3 c)
10:10:49 <lambdabot> const (flip flip 3 . f)
10:11:19 <zygoloid> djahandarie: oh no, whatever will we do!
10:11:49 <djahandarie> @pl (\g a b c d e f h i j -> f a b c d e f h i 3 j)
10:11:50 <DigitalKiwi> obviously we [remove|add] a bunch!
10:11:52 <lambdabot> const (flip flip 3 . ((flip . ((flip . ((flip . ((flip . ((flip . (flip .)) .)) .)) .)) .)) .) . flip flip id . ((flip . ((flip . ((flip . (ap .) . flip) .) . flip) .) . flip) .) . flip . flip id)
10:12:02 <djahandarie> Oh... whoops
10:12:15 <djahandarie> @pl (\g a b c d e h i j -> f a b c d e h i 3 j)
10:12:15 <lambdabot> const (flip flip 3 . ((flip . ((flip . ((flip . ((flip . (flip .)) .)) .)) .)) .) . f)
10:12:19 <orlandu63> now that's what i call readable
10:12:43 <djahandarie> As to why you'd have a function like that...
10:13:54 <orlandu63> oh, it's not actually a funcction. i just wanted to see how it can be written point-free
10:18:05 <djahandarie> @pl (\x a b c d e f g h -> \y a b c d 0 e f g h)
10:18:06 <lambdabot> (line 1, column 44):
10:18:06 <lambdabot> unexpected ")"
10:18:06 <lambdabot> expecting pattern or "->"
10:18:12 <djahandarie> @pl (\x a b c d e f g h -> y a b c d 0 e f g h)
10:18:12 <lambdabot> const (flip flip 0 . ((flip . (flip .)) .) . y)
10:18:30 * djahandarie stops
10:21:50 <[swift]> is there any way to refer to a value i compute in a guard?
10:21:55 <lispy> djahandarie: lambdabot responds to /msg so you're welcome to continue in private :)
10:22:12 <[swift]> as an example of the idea (that doesn't work): f xs | u@(head xs) > 0 = u
10:22:38 <lispy> [swift]: use where/let, right?
10:22:42 <mauke> f xs@(u : _) | u > 0 = u
10:23:13 <[swift]> mauke: that works in this case, but my real problem involves ByteStrings so i can't use real pattern matching
10:23:30 <mauke> pattern guards
10:23:35 <[swift]> lispy: yeah, that's a possibility; just makes the code more verbose
10:23:54 <[swift]> mauke: looking it up
10:25:37 <[swift]> mauke: oh wow, that's perfect! now i just have to hope template haskell supports them
10:27:03 <Younder> well there's always liskell
10:27:58 * gwern whispers sinisterly in Younder's ear: bitrot oohh!
10:28:02 <Younder> haskell with lisp syntax and macroes. Its in a branch of the haskell VCS
10:28:07 <zygoloid> [swift]: that particular case can be written as: f xs@(u:_) | u > 0 = u
10:28:13 <[swift]> excellent, template haskell supports them too
10:28:26 <mauke> zygoloid: welcome to 5 minutes ago
10:28:38 <aavogt> no view patterns in TH though :(
10:28:50 <gwern> Younder: a branch = abandoned and bitrotten
10:29:05 <aavogt> or at least that the guards are part of the rest of the syntax, and not part of Pat
10:29:17 <[swift]> aavogt: yeah, i had problems with view patterns in TH, which prompted me to ask this question
10:29:51 <aavogt> > case () of _ | x <- 1, x <- x, x <- x, x <- x, x <- x, x <- x -> x
10:29:52 <lambdabot>   1
10:30:08 <zygoloid> mauke: wow, retro!
10:30:12 <idnar> my poor head
10:31:26 <aavogt> [swift]: somebody just has to design the AST for that... ghc-hq needs help!
10:31:40 <zygoloid> > case () of (\x -> x -> x) -> x
10:31:41 <lambdabot>   ()
10:32:25 <zygoloid> > case () of (\x -> x -> x) | x <- x -> x
10:32:26 <lambdabot>   ()
10:33:13 <EvanR-work> does #!/usr/bin/ghc work ;)
10:33:29 <[swift]> aavogt: is the AST used internally by GHC not suitable as a starting point?
10:33:32 <zygoloid> EvanR-work: for making self-compiling files? :)
10:33:41 <EvanR-work> then run
10:33:43 <zygoloid> EvanR-work: see runhaskell and runghc
10:33:49 <EvanR-work> ok
10:34:01 * ezyang think sit's kind of unfortunate that runghc is shorter than runhaskell 
10:34:10 <aavogt> [swift]: apparently not... I suppose the reason is to have TH somewhat separate from GHC?
10:34:24 <zygoloid> EvanR-work: looks like runghc interprets rather than compiling :(
10:34:39 <EvanR-work> good enough
10:34:50 <aavogt> but what would your runhaskell call but ghc?
10:34:53 <aavogt> hugs?
10:35:22 <ezyang> zygoloid: well, then you should compile it...
10:35:24 <[swift]> aavogt: ah, makes sense
10:35:38 <ezyang> aavogt: "Haskell's a language, not a compiler!"
10:35:56 <ezyang> in practice, I feel like everyone uses GHC, but it's a nice fantasy
10:36:35 <aavogt> as opposed to other languages?
10:37:28 <aavogt> the idea is that you can call runhaskell and whichever compiler/interpreter is installed, some unspecified version of the language will be run
10:38:13 <aavogt> ezyang: I think the run in the name already disambiguates haskell-the-report from haskell-as-implemented-somewhere
10:38:47 * ezyang nods 
10:41:25 <Berengal> I'll be holding a talk about functional programming and haskell to my coworkers. Any thoughts on how I should structure this?
10:42:24 <Berengal> I was thinking; why FP? -> Intro to FP? -> comparison with Java -> code like crazy
10:47:00 <aavogt> Berengal: needs more fibonacci and factorials
10:47:15 <Berengal> aavogt: There will be plenty of those
10:48:19 <Berengal> I'm also considering a somewhat theoretical introduction to Haskell before the coding. Evaluation vs execution, datatypes, currying etc.
10:48:21 <djahandarie> QuickCheck is pretty cool for anyone who has trudged through doing normal unit testing
10:48:38 * Berengal nods
10:49:26 <Berengal> I'm a bit tempted to just put on a video of Steele talking about Java and Scheme, then SPJ talking about Haskell and be done with it...
10:49:55 <djahandarie> lol
10:50:23 <mauke> "this lecture is about lazy evaluation. ... are there any questions?"
10:50:34 <hydo> hahah
10:50:42 <Berengal> mauke: The one thing I'm very sure I'll say in one form or the other
10:51:51 <Berengal> One problem I have is that I want it to both be a talk and a lecture at the same time. I want them to both want and be able to start learning FP at once
10:52:03 <kmc> haha mauke
10:52:06 <gwern> mauke: I also liked the one about pouring diesel into the car
10:52:16 <Berengal> gwern: Which one was that?
10:52:24 <jml> Berengal: ever watched the SICP lectures?
10:52:31 <Berengal> jml: Some of them
10:52:50 <jml> Berengal: I kind of like the first few as FP intros
10:53:20 <Berengal> jml: Indeed. I was planning on watching them again to steal ideas
10:53:28 <kmc> Berengal, what's the purpose of the talk? do you want to convince them to use Haskell or FP for practical things?
10:53:39 <gwern> Berengal: a proponent of static typing and one of dynamic typing are in a car going to the beach. the dynamic typer is explaining how types are really unnecessary. they run out of gas and the static typer goes to the diesel and starts pumping, as the dynamic typer gets all flustered. the static typer tells him, but doesn't type-checking not matter?
10:53:47 <gwern> Berengal: or something lijke that. someone surely has the link
10:54:51 <Berengal> kmc: I want to convince them that it's possible. I've harangued them about Haskell for quite some time, so they finally gave me a slot to try to talk them into it for real
10:55:24 <Berengal> gwern: Ah, nice. They're quite satisfied with static typing though
10:55:34 <gwern> Berengal: ah, I muffed the story
10:55:39 <chrisdone> seem to be a lot of posts about unicode problems on haskell-cafe
10:55:39 <gwern> Berengal: it goes, ' A disciple of another sect invited Markus Mottl to the beach. As he is driving his car along, he tells Markus: "Dynamic Typing makes me more productive! I can write my program faster if I do not have to worry about the compiler complaining about types". Since it is a long trip, the disciple of Dynamic Typing decides to make a stop for petrol. He enters the station to pay for the fuel and purchase a slurpee, while Markus attends to ...
10:55:44 <aavogt> @remember mauke  "this lecture is about lazy evaluation. ... are there any questions?"
10:55:45 <lambdabot> I will never forget.
10:55:45 <gwern> ... the refueling. Markus notes that the petrol pump is in use, so he starts pumping diesel fuel into the disciple's car. The disciple cries out, "Hey! What are you doing, this is a petrol car!". Markus replies, "Well, I wanted to get to the beach faster".'
10:55:49 <gwern> http://web.archive.org/web/20041012103936/http%3a//www.bagley.org/~doug/ocaml/Notes/okoans.shtml
10:55:52 <applicative> Berengal, but they might like type inference
10:56:04 <hydo> Berengal: might be good to provide examples of things that Haskell does that would make their jobs easier.  The more closely you can tie it with day to day work the better.
10:56:30 <kmc> Berengal, there's a lot of practical aspects of Haskell that don't get covered in the usual factorial-and-infinite-lists intro
10:56:47 <kmc> Berengal, in particular i'd show off some higher-order imperative concurrent programming
10:56:56 <kmc> i like the example of an async logger daemon in three lines of code
10:57:11 <twink> What's that look like?
10:57:16 <Berengal> applicative: Yes. They like static typing for it's safety, but they don't know about the compiler-aid yet
10:57:54 <kmc> twink, Berengal like this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25017#a25017
10:58:43 <kmc> the key points here are: a) lightweight threads b) message passing c) actions returning functions returning actions
10:59:00 <Berengal> kmc: And yes, I want to get away from purely pure programming rather quickly. It's nice during the introduction of the underlying concepts (LC), but something "real" would be nifty too. Better yet, if I have time, live-code something in both Haskell and Java for comparison
10:59:01 <kmc> and the effect is to present a simple api... the user doesn't need to know about threads or channels, they just call a function
10:59:57 <mauke> @forget mauke  "this lecture is about lazy evaluation. ... are there any questions?"
10:59:57 <lambdabot> Done.
11:00:33 <aavogt> I see, it's due that page gwern linked
11:00:34 <kmc> funnier without the ellipsis
11:01:03 <kmc> Berengal, how much time do you have?
11:01:31 <kmc> Berengal, and do you actually want to teach them how to write Haskell code, or just convince them that they should care to learn?
11:04:09 <Berengal> kmc: I don't know how much time yet. I could probably use up to two hours if I wanted to.
11:04:21 <kmc> that's cool
11:04:28 <kmc> though keeping attention might be difficult
11:05:05 <Berengal> That's why I want to do the live-coding. Get them involved, let them write some haskell themselves (with me driving)
11:05:18 <kmc> ah
11:05:52 <kmc> i would do some examples with STM too
11:06:01 <Berengal> We're few enough and know eachother well enough that making the whole thing a dialogue is no trouble
11:06:05 <kmc> ok
11:06:39 <epssy> I want to check Int b is in the range of 1 to 15 int but b == [1 .. 15] gives me a syntax error.  what have I misunderstood?
11:06:56 <kmc> epssy, you are comparing a number to a list for equality
11:07:07 <kmc> epssy, are you sure it's a syntax error and not a type error?
11:07:11 <kmc> > 2 == [1,2]
11:07:12 <lambdabot>   No instance for (GHC.Num.Num [t])
11:07:12 <lambdabot>    arising from the literal `2' at <inter...
11:07:29 <epssy> syntax error, ... not expected
11:07:33 <kmc> oh
11:07:36 <kmc> > [1..15]
11:07:37 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]
11:07:38 <epssy> how should I test a number against a range of numbers without typing them out?
11:07:43 <epssy> oh!
11:07:52 <Berengal> > 5 `elem` [1..15]
11:07:53 <kmc> epssy, but == is still not what you want
11:07:53 <lambdabot>   True
11:08:03 <gwern> > all (==2) [1..10]
11:08:04 <lambdabot>   False
11:08:07 <kmc> epssy, == checks if two values are the same thing, and a number will never be the same thing as a list of numbers
11:08:17 <gwern> > all (==2) $ take 100 [2..]
11:08:18 <lambdabot>   False
11:08:31 <gwern> > all (==2) $ take 100 $ repeat 2
11:08:31 <lambdabot>   True
11:08:34 <Taejo> > any (==2) [2..100]
11:08:35 <lambdabot>   True
11:08:39 <kmc> epssy, the best is ((b >= 1) && (b < 15))
11:08:47 <Berengal> > ((&&) <$> (1<=) <*> (>= 15)) 5 -- the fancy way
11:08:48 <lambdabot>   False
11:09:00 <Berengal> > ((&&) <$> (1<=) <*> (<= 15)) 5 -- the correct fancy way
11:09:01 <lambdabot>   True
11:09:15 <epssy> kmc, I see.  thank you very much :) ... my first attempt at haskell and it is pretty cool
11:10:18 <tensorpudding> That code looks a little scary though
11:10:35 <epssy> kmc, unexpected symbol &&.  I am using this in a where clause
11:10:40 <kmc> > liftA2 (&&) (1<=) (<= 15) 5
11:10:41 <lambdabot>   True
11:10:46 <tensorpudding> epssy: import Control.Applicative
11:10:53 <Berengal> Applicatives are highly overkill for this problem...
11:10:56 <kmc> err, not for (&&)
11:11:09 <kmc> epssy, can you put your code on hpaste.org
11:11:10 <tensorpudding> oh wait, that's &&
11:11:12 <kmc> so we can see
11:11:18 <kmc> epssy, what are you using to learn Haskell
11:11:25 <gwern> @hpaste
11:11:25 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
11:11:29 <tensorpudding> (&&) is in the Prelude...
11:12:12 <epssy> kmc, http://pastebin.com/BBijSAhT .  I am using hugs from the ubuntu repo.
11:12:21 <kmc> epssy, you should probably use ghci instead of hugs
11:12:51 <tensorpudding> Unfortunately there are sources which suggest that hugs is a better option than ghci, and these sources are pretty out-of-date.
11:12:57 <kmc> it's probably in a package called ghc6
11:13:03 <[swift]> > or $ map (== 2) [1..15]
11:13:04 <lambdabot>   True
11:13:06 <kmc> epssy, i meant also, what sort of book or document are you reading?
11:13:25 <kmc> > any (==2) [1..15]
11:13:26 <lambdabot>   True
11:13:30 <kmc> > 2 `elem` [1..15]
11:13:31 <lambdabot>   True
11:13:36 <epssy> I must use hugs for university assignments, not just these examples I'm working through, so it is probably best I learn hugs issues
11:13:37 <kmc> ... but that's much unnecessary work
11:13:41 <kmc> epssy, weird
11:13:48 <gwern> academia can be conservative
11:13:59 <[swift]> i'm not as advanced at making absurd implementations as some of you haha
11:14:03 <epssy> kmc, a list of problems to solve in haskell to get used to the language provided by my uni
11:14:34 <epssy> gwern, I can post on my course mailing list to see why we still use hugs.  I'd suggest the lecturers simply haven't bothered to stay modern
11:14:36 <kmc> epssy, that's a list of problems... do you have some document that explains haskell
11:15:50 <epssy> gofer-wentworth, and a gentle intro to haskell 98, and a chapter in my textbook.  so, mainly google.  the haskell website and wiki are very handy
11:16:04 <tensorpudding> Gentle Intro isn't.
11:17:03 <Berengal> Is there a cheatsheet for Haskell?
11:17:12 <epssy> it jumps right in to very detailed things without covering simple things like checking a variable against a range which is a little annoying.
11:17:28 <epssy> Berengal, this website seems to be great for me right now http://www.haskell.org/haskellwiki/Learn_Haskell_in_10_minutes
11:17:34 <EvanR-work> Berengal: making a cheatsheet is a good way to review haskell
11:17:45 <tensorpudding> @where lyah
11:17:45 <lambdabot> http://www.learnyouahaskell.com/
11:18:03 <tensorpudding> is a popular web tutorial for Haskell
11:18:22 <mercury^> @pl flip ap
11:18:22 <lambdabot> flip ap
11:18:23 <Berengal> EvanR-work: That's true. Good for memorizing the syntax as well, which I always find to be the most boring part of learning a language
11:18:37 <Berengal> @unpl flip ap
11:18:37 <EvanR-work> luckily haskell doesnt have much syntax
11:18:37 <lambdabot> (\ b c -> c >>= \ e -> b >>= \ d -> return (e d))
11:18:43 <epssy> so basically I could easily compare a list but since we have to use 98 standard I can't ...
11:19:03 <Berengal> epssy: Not really. The type of (==) is (Eq a) => a -> a -> Bool
11:19:11 <mercury^> @pl flip map
11:19:11 <lambdabot> flip map
11:19:18 <Berengal> epssy: Which means that the two things you compare need to be of the same type
11:19:35 <tensorpudding> > [1,2,3,5] == [1,2,3,5]
11:19:36 <lambdabot>   True
11:19:36 <EvanR-work> > [1,2,3] == [1,2]
11:19:37 <lambdabot>   False
11:19:49 <epssy> I used the wrong term; could easily check if some thing is in the range I want
11:19:54 <Berengal> epssy: You could define your own operator though, something like (==..) or whatever...
11:20:02 <EvanR-work> epssy: look at Bounded class
11:20:11 <EvanR-work> erm Ix class
11:20:21 <EvanR-work> @src Ix
11:20:22 <lambdabot> class (Ord a) => Ix a where
11:20:22 <lambdabot>     range           :: (a,a) -> [a]
11:20:22 <lambdabot>     index           :: (a,a) -> a -> Int
11:20:22 <lambdabot>     inRange         :: (a,a) -> a -> Bool
11:20:22 <lambdabot>     rangeSize       :: (a,a) -> Int
11:20:38 <EvanR-work> > inRange (0,5) 7
11:20:38 <lambdabot>   False
11:20:40 <Berengal> > inRange (1,15) 5
11:20:41 <lambdabot>   True
11:20:44 <epssy> oh, nice
11:20:58 <Makoryu> > inRange ('a', 'z') '?'
11:20:59 <lambdabot>   False
11:21:31 <tensorpudding> could you use Typeable to create a function that returned True if the arguments had the same type?
11:21:49 <aavogt> no
11:21:56 <aavogt> err, yes
11:22:11 <zygoloid> > let sameType :: (Typeable a, Typeable b) => a -> b -> Bool; sameType a b = typeOf a == typeOf b in sameType True False
11:22:12 <lambdabot>   True
11:22:13 <aavogt> @type (==) `on` typeOf
11:22:14 <lambdabot> forall a. (Typeable a) => a -> a -> Bool
11:22:14 <zygoloid> > let sameType :: (Typeable a, Typeable b) => a -> b -> Bool; sameType a b = typeOf a == typeOf b in sameType True 42
11:22:15 <lambdabot>   False
11:22:23 <tensorpudding> Okay, cool.
11:22:42 <zygoloid> the type of 'of' isn't general enough for that :(
11:22:47 <zygoloid> s/of/on/
11:23:03 <EvanR-work> the type on 'on' isn't general enough for that :(
11:23:04 <aavogt> yeah, I'm not sure how it could work otherwise
11:23:05 <Berengal> @type \x y -> catMaybes [Just x, cast y] == 2
11:23:06 <lambdabot> forall a a1. (Typeable a1, Typeable a, Num [a]) => a -> a1 -> Bool
11:23:07 <EvanR-work> ;)
11:23:23 <mercury^> Who else thinks that Applicative could do with flipped versions of <$> and <*>?
11:23:34 <aavogt> @type <**>
11:23:34 <zygoloid> EvanR-work: missing a 'length' methinks
11:23:35 <lambdabot> parse error on input `<**>'
11:23:38 <aavogt> @type (<**>)
11:23:39 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f (a -> b) -> f b
11:23:44 <aavogt> mercury^: that one is sort of flipped
11:23:54 <tensorpudding> When I was first learning Haskell I had want of doing something like that, but only because I was thinking of my problem in a non-Haskelly kind of way.
11:23:55 <aavogt> though I believe that the effects of the first argument happen first
11:24:14 <applicative> epssy, the 'where' clause doesn't make sense
11:24:18 <mercury^> @type (<$$>)
11:24:19 <lambdabot> Not in scope: `<$$>'
11:24:21 <mercury^> :(
11:24:23 <zygoloid> mercury^: i wouldn't like a flipped <*>. i like knowing the evaluation is left-to-right.
11:24:34 <zygoloid> fsvo evaluation
11:24:37 <Berengal> mercury^: A commonality of the applicative functions is that effects happen left-to-right, no matter which way the values flow
11:24:52 <epssy> applicative, I don't understand? I want that function where the value of b is between 1 and 15?
11:25:06 <edon> why would this (http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25018#a25018) cause a stack overflow even for very small data sets?
11:25:07 <applicative> > let  numtohex b = if b < 10 then chr (b + 48) else chr (b + 55) in map numtohex [100..150]
11:25:08 <lambdabot>   "\155\156\157\158\159\160\161\162\163\164\165\166\167\168\169\170\171\172\1...
11:25:29 <Berengal> epssy: Applicative is a typeclass. It has nothing to do with checking ranges
11:26:04 <mercury^> Berengal: that's ok. The "pseudoflip" is fine too. But is there also one for <$>?
11:26:15 <applicative> epssy, the 'where' is for when you are writing a definition, but you want to use some term that you are going to define later in the course of the same definition
11:26:20 <mercury^> Well, not that effects matter in that case.
11:26:28 <Schalken> I have a function f :: a -> Writer [String] (Either String b). It returns a value or an error string, and also generates a log. If I were to instead build it using a monad transformer, which order should be the stack be in? Would I use WriterT [String] (Either String b) or EitherT String (Writer [String] b)?
11:26:41 <aavogt> @hoogle pamf
11:26:41 <lambdabot> No results found
11:27:09 <Berengal> mercury^: No, there isn't
11:27:25 <epssy> applicative, that statement is beyond what I understand of functional programming.  is using a where not the best way to range check b to ensure its within 0 and 15?
11:27:31 <tensorpudding> > let isInMyRange x | x <= 15 && x >= 5 = True | otherwise = False in (isInMyRange 10, isInMyRange 20)
11:27:32 <lambdabot>   (True,False)
11:28:57 <applicative> epssy, your function is from Int to Char, it's valid for all  Ints
11:29:41 <applicative> epssy, if you want it to return an error or something for values outside [0..15] various things can be done
11:29:48 <newsham> can anyone help me understand something in lpalmer's frp post? http://www.mail-archive.com/haskell-cafe@haskell.org/msg74645.html
11:29:56 <Berengal> epssy: 'where' is used to introduce names, not check conditions
11:29:57 <newsham> the Continuous defn is hurting
11:30:39 <epssy> applicative, ah I see.  I didn't realise the prototype was that rigid in its purpose.  I will investigate limiting it properly
11:30:47 <EvanR-work> can i instance on types as well as newtypes
11:30:57 <EvanR-work> or does that define an instance for the base type
11:31:18 <Berengal> EvanR-work: It defined an instance for the base type
11:31:28 <EvanR-work> hm
11:31:40 <EvanR-work> and if it already has an instance, im screwed
11:31:45 <EvanR-work> guess i need new type
11:32:18 <mreh> is using state monad without a return type the same as a fold?
11:32:52 <epssy> thank you for your help applicative, :)
11:33:28 <tensorpudding> Is there an easy way to define a type that represents a finite subset of Int?
11:33:40 <fax> tensorpudding: type Subset = Int or newtype Subset = Int
11:33:42 <fax> er
11:33:43 <fax> SubsetIn
11:33:46 <fax> Subset Int
11:34:15 <mreh> and a function makeSubsetInt
11:34:15 <epssy> could I use a subset like that in my function :: Int -> Char prototype?
11:34:47 <applicative> epssy, here's a bit of where syntax you could use in your definition, not that you need it. http://pastebin.com/uKYLJvTw
11:34:53 <Berengal> epssy: You could use it if you change the type to Subset -> Char
11:35:16 <tensorpudding> also, Haskell folk don't call those things prototypes, they call them type signatures.
11:35:16 <EvanR-work> tensorpudding: luckily theres no non finite subsets of Int ;)
11:35:54 <epssy> applicative, that's pretty cool.  thank you :)
11:35:55 <Berengal> epssy: But then you need to create a Subset value before calling your function, and now you're suddenly wandering very close to dependent types
11:36:00 <tensorpudding> EvanR-work: Yes, but I mean just saying "here's a range of values I want supported, and you handle when I send a value out of bounds"
11:36:18 * CosmicRay solicits feedback on http://thread.gmane.org/gmane.comp.lang.haskell.cafe/73748
11:36:38 <EvanR-work> you can make a constructor which does undefined if you try to use out of range
11:36:38 <epssy> Berengal, I'll wander away from dependant types until I get to (abstract?) types
11:36:55 <Schalken> I have a function f :: a -> Writer [String] (Either String b). It returns a value or an error string, and also generates a log. If I were to instead build it using a monad transformer, which order should be the stack be in? Would I use WriterT [String] (Either String b) or EitherT String (Writer [String] b)?
11:36:58 <Makoryu> epssy: Remember, "foo where bar" is syntactic sugar for "let bar in foo"
11:37:17 <Berengal> epssy: Dependent types are very fun, but they are to Haskell what Haskell is to "regular" imperative programming
11:37:19 <EvanR-work> make x | x > 5 = X x; | otherwise = undefined
11:37:34 <epssy> already know that one.  did ten problems of 'make this where in to a let' and back again :/
11:38:18 <dons> proto-types
11:38:28 <dons> types that specify protocols, in haskell terms, i guess :)
11:38:33 <CosmicRay> heh
11:39:04 <fax> > ((-1 + sqrt(-3))/2)**3 :: Complex Double
11:39:05 <lambdabot>   0.9999999999999997 :+ 6.432490598706544e-16
11:39:43 <twink> > let i = 0 :+ 1 in i ** i
11:39:44 <lambdabot>   0.20787957635076193 :+ 0.0
11:40:26 <twink> > let i = 0 :+ 1 in i ** i - exp (- pi / 2)
11:40:27 <lambdabot>   0.0 :+ 0.0
11:44:49 <EvanR-work> ((-1 + sqrt(-3))/2)**3 :: Complex CReal
11:44:51 <EvanR-work> > ((-1 + sqrt(-3))/2)**3 :: Complex CReal
11:44:55 <lambdabot>   mueval-core: Time limit exceeded
11:45:08 <fax> :(
11:45:16 * EvanR-work plays computer
11:45:21 <EvanR-work> 1 :+ 0
11:49:00 <EvanR-work> > mappend (1,2) (3,4)
11:49:01 <lambdabot>   Ambiguous type variable `t' in the constraints:
11:49:01 <lambdabot>    `GHC.Num.Num t' arising ...
11:49:12 <EvanR-work> > mappend (1,2) (3,4) :: (Int, Int)
11:49:13 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
11:49:13 <lambdabot>    arising from a use of...
11:50:17 <EvanR-work> > mappend ([1], [3]) ([2], [5])
11:50:18 <lambdabot>   ([1,2],[3,5])
11:50:21 <EvanR-work> yay
11:50:34 <EvanR-work> numbers dont have default monoid instances :(
11:50:58 <dcoutts_> EvanR-work: it's deliberate, you need to decide which numeric monoid you want
11:51:04 <EvanR-work> how?
11:51:06 <zygoloid> > (Sum 1, Product 2) `mappend` (Sum 3, Product 4)
11:51:07 <lambdabot>   (Sum {getSum = 4},Product {getProduct = 8})
11:51:13 <EvanR-work> ah
11:51:21 <zygoloid> > getSum *** getProduct $ (Sum 1, Product 2) `mappend` (Sum 3, Product 4)
11:51:21 <lambdabot>   (4,8)
11:52:11 <EvanR-work> > ([], [], [], [], [], []) `mappend` ([], [], [], [], [], [])
11:52:12 <lambdabot>   No instance for (Data.Monoid.Monoid
11:52:13 <lambdabot>                     ([a], [a1], [a2], [...
11:52:19 <EvanR-work> > ([], [], [], [], []) `mappend` ([], [], [], [], [])
11:52:19 <lambdabot>   ([],[],[],[],[])
11:52:30 <EvanR-work> sextuple has no instance :(
11:52:58 <newsham> how about (a,(b,(c,(d,(e,f)))))  ? :)
11:53:09 <EvanR-work> hah
11:53:25 <dcoutts_> EvanR-work: file a ticket, these things are usually defined up to at least 7
11:53:37 <EvanR-work> > () `mappend` ()
11:53:38 <lambdabot>   ()
11:53:45 <newsham> kinda wish (a,b,...) was synonym for (a,(b, ...))
11:54:03 <EvanR-work> () mappend, isomorphic to 0 + ;)
11:54:33 <EvanR-work> newsham: but then youd need a singleple
11:54:58 <newsham> sounds good to me
11:55:10 <EvanR-work> suddenly theres a reason to have (x) !
11:55:47 <EvanR-work> it would be kind of weird, to have only exactly 1 and exactly 2ples
11:55:59 <newsham> and ()
11:56:09 <EvanR-work> but () isnt a tuple
11:56:33 <newsham> (a, ())    (a,(b,()))   (a,(b,(c, ())))
11:56:42 <EvanR-work> ok, cons cells
11:56:47 <newsham> no, not cons
11:56:59 <newsham> well, not data cons
11:57:00 <newsham> at least
12:00:14 <[swift]> for anyone who's worked with template haskell: is there a way to disable the automatic uniquing of variable names in TH quotations? i know how to work around it but it would make things a lot less verbose if I could just disable it somehow
12:01:46 <shapr> You want UNhygienic macros?
12:01:53 * shapr throws uncommon lisp at [swift] 
12:02:20 <[swift]> shapr: i'd like the option =)
12:03:20 <[swift]> shapr: the thing is that i'm composing the results of several TH macros, and the uniquing makes it hard for them to refer to values that the others have defined
12:03:22 <shapr> I don't remember reading about allowing unhygienic macros in TH.
12:03:33 <shapr> Perhaps they should be pure?
12:03:43 <[swift]> shapr: i don't need the uniquing anyway as I'm writing TH's output to a file
12:04:20 <[swift]> shapr: well i can just write pure functions to construct the needed AST, but quotation is extremely convenient except for (in this case) the uniquing
12:05:07 <shapr> [swift]: Heard of Higher Order Abstract Syntax?
12:05:17 <EvanR-work> > mconcat [Just [1,2], Nothing, Just [3]]
12:05:17 <lambdabot>   Just [1,2,3]
12:05:18 <[swift]> shapr: i haven't
12:06:00 <EvanR-work> > mzero :: Maybe [Int]
12:06:01 <lambdabot>   Nothing
12:06:58 <EvanR-work> oops, mzero is something else
12:07:05 <EvanR-work> > mempty :: Maybe [Int]
12:07:05 <lambdabot>   Nothing
12:07:07 <aavogt> @type mkName
12:07:08 <lambdabot> Not in scope: `mkName'
12:07:15 <aavogt> @type Language.Haskell.TH.mkName
12:07:15 <lambdabot> String -> Language.Haskell.TH.Syntax.Name
12:07:21 <aavogt> @type Language.Haskell.TH.dyn
12:07:22 <lambdabot> String -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp
12:07:33 <aavogt> [swift]: those are for being unhygenic
12:08:34 <[swift]> aavogt: ah, this may be the key. i know and use mkName, but i'm not familiar with dyn
12:08:38 <IceDane> @src mconcat
12:08:38 <lambdabot> Source not found.
12:08:41 <IceDane> bah
12:09:10 <aavogt> [swift]: then you've been unhygenic
12:09:29 <aavogt> dyn is just a shortcut for    varE . mkName
12:09:32 <[swift]> aavogt: right; i know how to do it, but it makes things much less readable
12:09:39 <[swift]> aavogt: that's what i figured
12:10:53 <[swift]> maybe i could _truly_ get what i want by creating a unhygenic quasiquoter?
12:11:14 <EvanR-work> times :: (Integral b, Monoid a) => b -> a -> a
12:11:16 <[swift]> might be pretty easy to do that actually
12:11:23 <EvanR-work> times n x = mconcat $ replicate (fromIntegral n) x
12:11:35 <aavogt> [swift]: it's not that bad to write   [|   $(dyn "f") $(dyn "x") |]
12:12:04 <[swift]> aavogt: i agree, it's not that bad, but i find it pretty elegant when you're literally just typing haskell code between the [| |]'s
12:12:44 <aavogt> which other macros are you composing?
12:13:12 <aavogt> as in those defined as  ExpQ, or  Q [Dec] ones?
12:13:36 <[swift]> aavogt: i have instances of both, but the latter is the most important case
12:13:55 <[swift]> aavogt: basically i've got a lexer/parser generator and i want to be able to vary the lexer, parser, and "wrapper" independently
12:14:17 <EvanR-work> how does data deriving work, can classes configure this behavior or is it automagic and only for built in classes
12:14:43 <aavogt> [swift]: maybe this is worse than using nonunique names, but you can use IORefs in TH...
12:15:03 <[swift]> aavogt: haha, i think i'll stick with nonunique names over that =)
12:15:17 <Makoryu> EvanR-work: I'm certain I saw an extension for custom derivable classes...
12:15:19 <p_l> afk
12:15:34 <EvanR-work> so by default its something you can do for Eq Ord Show Read Enum etc
12:15:40 <EvanR-work> not... Monoid?
12:16:08 <aavogt> EvanR-work: see derive or drift
12:16:35 <aavogt> but frequently there are multiple interesting Monoid instances
12:16:52 <EvanR-work> ah
12:17:11 <aavogt> so I think those ones derive those that recurse on the components
12:17:50 <EvanR-work> so a Monoid for (M1, M2) would be (mempty1, mempty2)
12:17:52 <gwern> EvanR-work: I told you of an example of multiple monoids earlier - * and + on ints
12:18:06 <EvanR-work> yes
12:18:19 <aavogt> or First and Last for Maybe
12:18:20 <EvanR-work> this is a question about deriving
12:18:32 <EvanR-work> not monoids
12:18:37 <aavogt> > Just () `mappend` Nothing
12:18:38 <lambdabot>   Just ()
12:19:00 <gwern> wouldn't have asked whether one could always derive monoids if you remembered that
12:19:30 <EvanR-work> i dont know how deriving works
12:19:37 <aavogt> gwern: no, you can derive some monoid instances
12:19:38 <EvanR-work> i know how monoids work
12:19:42 <gwern> aavogt: some, not all
12:20:02 <EvanR-work> replace Monoid with Ix
12:20:06 <aavogt> well the builtin deriving doesn't work for all data types anyways
12:20:16 <aavogt> @src Ix
12:20:16 <lambdabot> class (Ord a) => Ix a where
12:20:16 <lambdabot>     range           :: (a,a) -> [a]
12:20:16 <lambdabot>     index           :: (a,a) -> a -> Int
12:20:16 <lambdabot>     inRange         :: (a,a) -> a -> Bool
12:20:16 <lambdabot>     rangeSize       :: (a,a) -> Int
12:21:23 <EvanR-work> data Ord a1 a2 => A = A a1 a2 deriving (Ix) ?
12:21:57 <aavogt> you don't need the constraint in the data
12:22:03 <EvanR-work> k
12:22:15 <EvanR-work> data A = A x y deriving (Ix) ?
12:22:35 <aavogt> the written instance probably involves:      instance (Ix a, Ix b) => Ix (A a b) where ...
12:23:14 <kmc> EvanR-work, you can derive: a) Eq Ord Enum Bounded Read Show; b) Typeable Data Functor Foldable Traversable; c) any class for a newtype.  a in H98; b,c with GHC extensions
12:23:31 <EvanR-work> got it
12:23:47 <EvanR-work> for a), does it always work?
12:24:04 <EvanR-work> if the components are members of that class
12:24:21 <kmc> on H98 types, yes.  however the instance might itself have a constraint
12:24:29 <kmc> well, hmm
12:24:33 <kmc> that's not true
12:24:43 <aavogt> -XGeneralizedNewtypeDeriving is strange
12:24:52 <aavogt> kmc: yes it will
12:25:06 <aavogt> you can write   data Maybe a = Nothing | Just a deriving Eq
12:25:22 <aavogt> and the derived instance requires a to be in Eq
12:25:24 <kmc> you can do that
12:25:48 <kmc> but you can't do data Foo = Foo (Char -> Char) deriving (Show)
12:26:03 <kmc> even though you could write an instance (Show (Char -> Char)) => Show Foo
12:26:10 <kmc> but i guess that instance is not H98 anyway
12:26:24 <EvanR-work> h98 types?
12:26:35 <EvanR-work> types definable with h98?
12:26:37 <aavogt> oh, your comment about that's not true applies to "it always works"
12:26:57 <kmc> EvanR-work, yeah
12:27:12 <EvanR-work> (Char -> Char) isnt?
12:27:23 <EvanR-work> or data Foo = Foo (Char -> Char)
12:27:27 <kmc> EvanR-work, it is H98
12:27:32 <kmc> but the context is not
12:27:45 <kmc> in H98 all contexts have the form (C x y z) where C is a class and x y z are vars
12:27:57 <EvanR-work> k
12:28:08 <kmc> well actuall
12:28:09 <aavogt> just use -XFlexibleInstances already
12:28:10 <kmc> (C x)
12:28:17 <kmc> because classes are single-param in H98
12:28:27 <kmc> and yeah -XFlexibleInstances lifts this
12:28:41 <kmc> i can write "deriving instance (Show (Char -> Char)) => Show Foo" using -XStandaloneDeriving -XFlexibleContexts -XUndecidableInstances
12:29:25 <aavogt> why do you need the undecidable instances?
12:30:20 <kmc> because (Char -> Char) is not smaller than Foo
12:30:29 <aavogt> sure it is
12:30:46 <kmc> Paterson condition b) is "The assertion has fewer constructors and variables (taken together and counting repetitions) than the head"
12:33:04 <aavogt> then it is
12:41:07 <lpsmith> So I tried uncompressing the bz2 tarball that the binary ghc distribution uses and recompressing it with lzma
12:41:27 <lpsmith> It dropped from 106 megabytes to 72 megabytes
12:42:47 <lpsmith> many recent variants of the tar command support lzma compression;  dpkg and rpm supports them as well
12:43:17 <IceDane> lpsmith: Was the compression/decompression time any different?
12:44:02 <lpsmith> well, I didn't try recompressing with bz2,  but bz2 usually takes about the same amount of time to decompress than to recompress
12:44:34 <lpsmith> It took longer to recompress with lzma than decompress bz2
12:44:40 <lpsmith> But decompression is faster
12:44:40 <IceDane> I see
12:44:51 <IceDane> Then that's not a reason not to use it
12:46:00 <EvanR-work> i just invented the best compression
12:46:25 <EvanR-work> sha1 (veryLargeTextFile)
12:46:40 <EvanR-work> beat that
12:46:40 <lpsmith> heh
12:46:43 <Younder> lol
12:46:44 <IceDane> heh
12:46:47 <IceDane> EvanR-work: decompress that
12:46:54 <IceDane> See you in 3 millenia
12:46:55 <EvanR-work> still working on that part
12:46:58 <IceDane> if you have a really, really fast computer
12:47:01 <Younder> try LOSSLESS compression
12:47:05 <EvanR-work> i didnt say it was easy / fast to decompress
12:47:20 <pickles> and that, my friends, is how marketing works
12:47:20 <EvanR-work> Younder: heres how it works...
12:47:45 <IceDane> EvanR-work: Using RLE you could easy decompress a 9 byte file into 2^64 bytes :P
12:47:53 <EvanR-work> Younder: search for all texts of the original size that have that hash, this could take a while. choose the one with the least entropy, end
12:48:10 * EvanR-work becomes rich
12:50:23 <Younder> EvanR, now all you need is a quantum computer to do the computation. got it! simple.
12:50:56 <djahandarie> What about quantum computation? :P
12:51:11 <EvanR-work> quantum search algorithm
12:51:12 <EvanR-work> done
12:51:33 <djahandarie> Grover's?
12:51:51 <idnar> im in ur particles, breaking ur crypto
12:52:19 <IceDane> "A thirty-member Spanish medical team has achieved the world's first full face transplant. [...] It is unknown whether he now looks more like John Travolta or Nicolas Cage."
12:52:22 <djahandarie> Quantum Cryptography is... exciting
12:55:18 <lpsmith> Yeah,  unfortunately even if you could build a quantum computer with enough qbits to reverse image SHA1 using grover's algorithm,  a quadratic speedup wouldn't really be enough :)
12:55:57 <EvanR-work> still working on the exponential speed up version
12:56:01 <lpsmith> lol
12:56:27 <EvanR-work> problem is, i am automatically generating this algorithm using a search through all possible programs
12:56:31 <EvanR-work> chicken and the egg
13:23:22 <Schalken> How do I translate an instance of a monad into an instance of a combined monad? a :: Maybe _, b :: WriterT _ (Maybe _), b = ... a ... ?
13:26:43 <edwardk> Schalken: there is no law that allows you to combine arbitrary monads,
13:26:55 <edwardk> Schalken: it turns out to be quite a pain in the ass actually ;)
13:27:07 <edwardk> Schalken: there are a number of special cases
13:27:22 <dolio> I suspect the answer he wants is lift :: (Monad m, MonadTrans t) => m a -> t m a
13:27:37 <djahandarie> edwardk, know much about Ringel-Hall algebras?
13:27:40 <edwardk> dolio: very true
13:28:04 <edwardk> djahandarie: not really
13:28:18 <djahandarie> Okay, it has nothing to do with CT, just some abstract algebra stuff
13:28:32 <edwardk> *nods* i've seen the term, but its never been something I explored
13:29:02 <djahandarie> It's specifically used for forming a quantum group out of an arbitrary quiver
13:30:18 <Schalken> dolio: Err, that might be helpful, but I dont think it works if I instead have: a :: Maybe _, b :: MaybeT (Writer _ _), b = ... a ...
13:30:44 <edwardk> in the case of maybe what you want is something like
13:31:01 <edwardk> fromMaybe (Just x) = return x; fromMaybe Nothing = mzero
13:31:06 <Schalken> dolio: In which case lift would turn a Writer into a MaybeT (Writer ...), but I want to turn a Maybe into a MaybeT (Writer ...) instead.
13:31:11 <edwardk> though that answer doesn't generalize
13:32:01 <dolio> If you want Maybe a -> MaybeT (Writer w) a, then it's (MaybeT . fmap return)
13:32:02 <edwardk> you can construct similar functions for, say, State s and StateT s m, just just using the 'return' of the wrapped monad where appropriate
13:32:26 <dolio> lift gets you Maybe a -> WriterT w Maybe a, though, which I think is what you originally asked.
13:32:37 <edwardk> gotta run
13:32:44 <edwardk> djahandarie: i'll take a look further when i get a chance
13:32:57 <djahandarie> edwardk, ok, you don't need to, I was just wondering
13:33:02 <djahandarie> >_>
13:33:18 <Schalken> dolio: Yeah, sorry, what I originally asked was wrong.
13:33:43 <Schalken> dolio: Dont liftM and fmap do the same thing in the case of monads?
13:33:53 <dolio> Yes.
13:34:08 <dolio> Actually, I may be wrong about that implementation...
13:34:32 <Schalken> dolio: ...wrong about (MaybeT . fmap return) ?
13:34:45 <dolio> Yeah. I guess it's just MaybeT . return.
13:34:52 <dolio> @type MaybeT
13:34:53 <lambdabot> Not in scope: data constructor `MaybeT'
13:35:16 <Schalken> @type EitherT String
13:35:17 <lambdabot> Not in scope: data constructor `EitherT'
13:35:17 <lambdabot> Not in scope: data constructor `String'
13:35:24 <Schalken> Aww.
13:35:43 <dolio> @kind ErrorT String
13:35:44 <lambdabot> (* -> *) -> * -> *
13:37:43 <Schalken> So it takes a monad (* -> *) and an inner type for the data (*) and returns a new type (*).
13:39:06 <aavogt> or look at it as   (* -> *) -> (* -> *)
13:39:31 <aavogt> as a function over some type constructor
13:40:50 <fax> Twice f x = f (f x)
13:40:56 <fax> then Twice [] x is the same as [[x]]
13:41:09 <fax> as an example of that kind Twice :: (* -> *) -> (* -> *)
13:41:50 <aavogt> so you're not restricted to monad transformers
13:42:15 <aavogt> though they are a convenient motivating example for this language feature
13:48:22 <tiglionabbit> If you have created a new type, how do you define what should happen if someone calls 'show' on it?
13:49:27 <EvanR-work> tiglionabbit: making an instance of Show for that type
13:49:42 <EvanR-work> which lets you define the function show :: YourType -> String
13:50:10 <EvanR-work> often you can just use the deriving (Show) clause to get a good default
13:50:11 <tiglionabbit> an instance of Show?
13:50:18 <sepp2k> tiglionabbit: instance Show YourType where show x = "bla"
13:50:41 <tiglionabbit> I've never used instances.  What are they?
13:50:50 <EvanR-work> @instances Show
13:50:51 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, ST s a, Sum a, [a]
13:51:05 <tiglionabbit> I mean in a theoretical sense
13:51:26 <EvanR-work> particular types that support a type classes interface
13:51:27 <Cale> tiglionabbit: Do you know what a typeclass is?
13:51:34 <djahandarie> > (a, b, c, d)
13:51:35 <lambdabot>   (a,b,c,d)
13:51:37 <djahandarie> > (a, b, c, d, e)
13:51:38 <lambdabot>   (a,b,c,d,e)
13:51:48 <EvanR-work> > show (1,2,3,4,5)
13:51:49 <lambdabot>   "(1,2,3,4,5)"
13:51:52 <EvanR-work> lies
13:52:00 <Cale> tiglionabbit: A typeclass is essentially a predicate which may be true or false of some type, together with a collection of functions which must be implemented in order to make it true.
13:52:16 <tiglionabbit> I see
13:52:18 <Cale> (or other values)
13:52:30 <Cale> tiglionabbit: An instance provides a witness for those values, making the predicate true.
13:52:46 <Cale> Typeclasses are used to constrain the types over which type variables range.
13:53:40 <Cale> So, for instance, while the 'length' function cares nothing about the elements of the list that it receives and so can be completely polymorphic in that type: length :: [a] -> Int, something like 'sort' is not so lucky
13:53:56 <Cale> A sort function needs to know that the elements of the list it gets can be ordered in some way
13:54:10 <Cale> So it will have type  (Ord a) => [a] -> [a]
13:54:52 <Cale> Where Ord is a typeclass defined in the Prelude that defines (<), (<=), (>), (>=), and compare (and is a subclass of Eq which defines equality testing)
13:55:11 <Cale> an instance of Ord for a specific type will provide implementations of those functions
13:59:54 <EvanR-work> @hoogle <>
13:59:54 <lambdabot> Text.PrettyPrint.HughesPJ (<>) :: Doc -> Doc -> Doc
13:59:54 <lambdabot> Language.Haskell.TH.PprLib (<>) :: Doc -> Doc -> Doc
14:08:54 <Mathnerd314> hmm... how would I find the first number *not* in a list of numbers?
14:09:35 <Botje> find (not . (`elem` list))
14:10:07 <Botje> or dropWhile (`elem`list)
14:10:10 <idnar> @type notElem
14:10:11 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
14:10:19 <EvanR-work> is this right data Rect = Rect !Int !Int !Int !Int
14:10:29 <Botje> idnar: or that, haha :)
14:11:40 <EvanR-work> it says ' no corresponding way to make function arguments strict'
14:11:45 <EvanR-work> but what about bang patterns
14:12:22 <idnar> EvanR-work: those are an extension, I think
14:15:44 <EvanR-work> @src Complex
14:15:44 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
14:19:13 <fax> Booo
14:23:09 <roconnor> EvanR-work: who says?
14:23:32 <EvanR-work> the gentle intro
14:24:20 <c_wraith> bang patterns for function arguments are an extension, yes
14:24:27 <roconnor> bang patterns are an extension
14:26:19 <fffej> Hi - I'm trying to play with Open GL having downloaded the latest Haskell platform - when I run one of the examples I get a message "undefined symbol glutGet" - any ideas where to start debugging this?  I've seen bug #1712 but it doesn't make much sense to me!
14:29:47 <aavogt> fffej: are you compiling with --make?
14:30:08 <aavogt> or  -package opengl... or whatever it's name is (which you can ask ghc-pkg for)
14:30:32 <fffej> aavogt: I was just trying in ghci
14:32:46 <tromp_> @t inits
14:32:46 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
14:33:01 <tromp_> :t inits
14:33:02 <lambdabot> forall a. [a] -> [[a]]
14:33:44 <fffej> aavogt: compiling with make gives more undefined references - not sure what you mean with -package?
14:34:44 <EvanR-work> undefined references, do you have the prereq libraries installed, like libglut.so
14:35:17 <EvanR-work> should have come with your gl implementation / video driver
14:36:17 <fffej> I can see that /usr/lib/lubglut.so exists and I've apt-get installed libglut so I think so
14:36:26 <EvanR-work> did you do ldconfig
14:36:41 <EvanR-work> if so then youre build command isnt using the right linker flags
14:36:48 <EvanR-work> your*
14:37:25 <fffej> just tried ldconfig and then recompiled with ghc --make and still the same result :(
14:43:45 <fffej> success - ghc -lglut --make mycode.hs and I'm all set!
14:45:23 <Peaker> fffej, There's a known bug with that.. and I have a fix for you
14:45:40 * hackagebot hpage 0.6.1 - A scrapbook for Haskell developers  http://hackage.haskell.org/package/hpage-0.6.1 (FernandoBenavides)
14:45:51 <fffej> peaker: thanks, that was quick :)
14:45:55 <Peaker> fffej, I think I reported it -- if libXaw is missing or so, at the "configure" step of the glut package -- it will mistakenly continue, but register the glut package in your DB without the "-lglut" flag
14:46:43 <Peaker> I forget which file has the "package DB" containing all the options
14:48:36 <Peaker> fffej, Anyway, try to find the glut-related file in ~/.ghc/<your-arch> and add "extra-libraries: glut"
14:49:45 <fax> > let x = (((5+sqrt(26))**(1/3))^2-1)/((5+sqrt(26))**(1/3)) in x^3+3*x::Complex Double
14:49:46 <lambdabot>   10.000000000000004 :+ 0.0
14:51:28 <fffej> peaker: thanks for the help - I'll dig around that
14:57:47 <miasma> hmm, this is a bit hilarious, but did you know that "Haskell and OCaml in particular have severe fundamental problems with it such that parallelizing your code makes it slower. Erlang and Clojure parallelize well, in that performance scales up proportionally as cores are added." - the one who commented is a long time C/C++ compiler veteran :P
14:58:11 <miasma> forgot the link http://www.digitalmars.com/webnews/newsgroups.php?art_group=digitalmars.D&article_id=109175
14:59:37 <fax> miasma: lol well when I tried to parallelize some sort algorithm it did make things slower
14:59:49 <fax> miasma, but that's because I didn't know what I was doing
15:00:51 <miasma> fax: sure
15:01:00 <lispy> miasma: That's a weird statement.
15:01:53 <Peaker> I would speculate that Erlang is better at scaling to multiple machines, and Haskell is better at parallelizing on cores, due to purity and laziness
15:02:03 <lispy> miasma: I can't speak for OCaml, but in Haskell the purity is actually nice for parallelizing.  It's true that for concurrency sometimes you need to avoid laziness in places.  But, overall it seems to be a win. (purity + laziness, when you need parallelism)
15:03:06 <EvanR-work> parallel concurrency!
15:03:17 <monochrom> The statement is clearly wrong. I propose this correction: Some people's understanding of Haskell has severe fundamental problems such that their method of parallelizing code makes it slower.
15:03:24 <ddarius> Haskell is better at scaling up on cores because it has the infrastructure.  Erlang is better at scaling up on computers because it has the infrastructure.
15:03:32 <miasma> lispy: I didn't say I agree with the text I quoted. of course parallel algorithms are also possible in functional languages
15:04:01 <EvanR-work> i think pure functional makes parallel more sanely realizable
15:04:13 <lispy> miasma: I didn't think you did, but I felt compelled to comment on what I see is the reality :)
15:05:40 <miasma> EvanR-work: the purity is just a layer on top of the machine code. on lower level there are other kinds of problems which can be huge
15:05:55 <monochrom> A chariot veteran speaking about "fundamental problems" of pulling a raceboat by multiple dolphins.
15:06:45 <applicative> funny I was just having my first go at Control.Parallel.Strategies and slowed things down... only slightly ... I think there wasn't enough there for it to help, maybe.
15:06:56 <EvanR-work> miasma: im sure there are, but less than those encountered in doing the same thing with a for loop of data mutation commands
15:07:13 <k23z__> > let balls = soft;
15:07:14 <lambdabot>   not an expression: `let balls = soft;'
15:07:43 <EvanR-work> > let balls = soft in kick balls
15:07:43 <lambdabot>   Not in scope: `soft'Not in scope: `kick'
15:13:38 <miasma> EvanR-work: how I see it, the hardware level problems can also be modelled in declarative way, at least to some extent (the idea is to guide the data flow from memory to cpus without causing congestion problems). I'm hoping myself that purity on language level can harness the potential low level power. I also fail to see how message passing can beat raw power of SIMD/SPMD/SIMT & haskell & data-parallelism in some problems
15:16:04 <EvanR-work> i also invented a better computer, in the same line of reasoning that brought you the sha1 compression algorithm
15:17:05 <EvanR-work> with this computer, you reduce the instruction set to SK[I] combinators, and implement a reduction machine with speeds 10^5 faster than currently possible with N cores. now reduce
15:17:16 <EvanR-work> because the instruction set is so simple you can implement the machine super fast
15:17:38 <Apocalisp> is there a name for the (-> a) cofunctor?
15:18:34 <EvanR-work> miasma: this leads me to believe that a fundamental bottle neck is getting the data from memory into the computer and back
15:18:48 <ddarius> EvanR-work: Unfortunately neither S or K are particularly simple operations.  Furthermore, compiling into S and K potentially increases the code size quadratically.
15:19:00 <EvanR-work> i noticed that
15:19:09 <EvanR-work> disk space is cheap ;)
15:19:26 <miasma> EvanR-work: yea, there are several problems. the most advanced systems use sparse networks for routing messages and distributed memory. e.g. current x86 SMP has serious problems
15:19:28 <EvanR-work> i defer to the problem of memory bandwidth
15:19:34 <Associat0r> Peaker: pervasive lazyness isn't good for parallelism
15:19:57 <ddarius> EvanR-work: Instruction cache isn't.  And having quadratically more operations in your code also is bad for time performance.
15:20:06 <EvanR-work> right
15:20:36 <EvanR-work> there are optimizations that can limit the quadratic size increase
15:20:38 <Peaker> Associat0r, It is good at allowing parallelism annotations to be specified separately from the logic -- it is bad if left unchecked because of making data jump between cores. That's not hard to solve with "using"
15:20:47 <Adamant> OISC ft what?
15:21:47 <EvanR-work> miasma: im thinking the computing parts of the machine are often gonig to be idle, waiting for the damned data to get there from the cache
15:22:00 <EvanR-work> thats intolerable
15:22:23 <miasma> EvanR-work: yes. there are ways to solve this. you need bigger memory bandwidth and a thing called parallel slackness
15:23:20 <EvanR-work> parallel slackness?
15:23:56 <miasma> EvanR-work: the idea is to run other threads while the fetch from the memory is on its way. the cpus can do other things during the period
15:24:41 <miasma> e.g. nvidia gpus use this kind of system
15:24:58 <ddarius> I put some cores in your cores so you can execute while you execute.
15:25:59 <systemfault> :/ It missed the "Yo dawg" part
15:26:22 <bremner> Yo dawg I herd you liek the Yo dawg part
15:35:15 <k23z__> who wants to talk with me on skype ?
15:37:14 <yaaang> i just downloaded ghc 6.12 binaries for generic linux, but on my ubuntu 9.10 box i get "ld: cannot find -lgmp" for 'main = putStrLn "hello"'
15:37:20 <yaaang> any hints?
15:37:36 <k23z__> yaaang, you don't have libgmp ?
15:37:41 <yaaang> k23z__, i do
15:37:53 <k23z__> yaaang, maybe you don't have it in LD_LIBRARY_PATH
15:38:12 <yaaang> k23z__, it's in /usr/lib
15:38:34 <k23z__> yaaang, just compile it yourself then
15:38:44 <k23z__> yaaang, get sources to haskell and compile it
15:39:13 <yaaang> k23z__, i'm already doing so, but i'd like to understand this particular problem
15:39:14 <monochrom> yaaang: apt-get install libgmp3-dev
15:39:42 <yaaang> monochrom, thanks
15:41:53 * monochrom feels sad about people spewing wrong advice.
15:42:25 <Zao> monochrom: I assume that the erronous advice here is "build from source"?
15:42:39 <Zao> Especially as that requires a working GHC in the first place.
15:42:47 <yaaang> i'm trying to build haskell platform 2010, but i'm getting "The core package base-4.2.0.0 is missing. It should have been distributed with 6.12.1". i installed the generic linux ghc 6.12.2 binaries. where do i find these extra packages?
15:42:57 * monochrom couldn't care less about "I have good intentions". Tired of good intentions. The road to hell is paved with good intentions.
15:43:59 <fffej> yaang: might be easier to just use 6.12.1 and the Haskell platform - that's the currently supported version of the platform (and it's pretty easy to get going with it)
15:44:50 <yaaang> fffej, once ghc 6.12.2 has been installed into /usr/local (using make install), is there a way to remove it so that i have a clean install of 6.12.1?
15:44:53 <Philippa> monochrom: it wouldn't be so bad if it weren't typically other people who ended up in hell due to it, either
15:45:28 * Philippa doesn't necessarily object so much to wrong advice that's given with qualifiers suggesting it may not be good
15:46:04 <fffej> yaang: i'm not sure - maybe make clean would remove it, but I've no idea to be honest :(
15:47:15 <monochrom> yaaang: http://groups.google.com/group/comp.lang.haskell/msg/a38908521c5a6e6b?pli=1 still applies
15:48:23 <yaaang> monochrom, interesting, thanks
15:48:30 <monochrom> it says where are the files so you know what to erase.
15:50:18 <Saizan> yaaang: if you're on linux you could also ignore the haskell platform and continue with just cabal-install
15:50:43 <Saizan> (on windows it's harder to build packages with C deps)
15:51:23 <Peaker> (forall task. on windows it's harder to <task>)
15:52:43 <monochrom> Counterexample: on windows it's not harder to boot windows
15:53:02 <glguy> <<loop>>
15:53:29 <monochrom> Counterexample: on windows it's not harder to use IE8
15:54:24 <siracusa> Is there a performance difference in GHC between pattern matchings in function definitions and in case alternatives?
15:54:30 <glguy> Windows makes it harder because you have to use IE8 to install your web browser, rather than your distro's package manageer
15:54:59 <tensorpudding> Not necessarily.
15:55:08 <tensorpudding> There are "package managers" for Windows.
15:55:17 <glguy> that you'd have to go and install using IE8?
15:55:26 <Saizan> siracusa: i wouldn't think so
15:55:32 <monochrom> I don't think there is a performance difference.
15:55:38 <tensorpudding> They just are as heterogenous and ad-hoc as you'd imagine something like that would be.
15:55:49 <monochrom> And also...
15:55:53 <glguy> its not a huge deal because eventually you've downloaded something using IE8 to replace IE8
15:56:00 <monochrom> > "use IE8" == "install your web browser"
15:56:01 <k23z__> who wants to talk with me on skype ? ...
15:56:01 <lambdabot>   False
15:56:12 <monochrom> So I don't understand what is glguy's point.
15:56:21 <glguy> it is apparently very subtle
15:56:37 <tensorpudding> @vixen Is IE8 only useful for installing Chrome/Firefox/Safari?
15:56:37 <lambdabot> is that really what you want to know?
15:58:01 <tensorpudding> I guess I forgot Opera.
15:58:12 <glguy> tensorpudding, ha, so did everyone else ;)
15:58:26 <tensorpudding> Not sure why I remembered Safari though.
15:58:55 <c_wraith> opera is pretty painful to include as a development target if you're doing anything non-trivial with javascript
15:59:03 <Adamant> I need to download IE8 on my Macintrash so I can download Safari. pls help.
15:59:07 <Adamant> :P
15:59:19 <fax> Adamant don't you have curl?
15:59:30 <tensorpudding> Can IE8 run in Wine?
15:59:36 <Adamant> fax: I hear there is this thing called Terminal
15:59:48 <Adamant> I wouldn't know, I'm not supposed to touch it
15:59:53 <fax> okay
15:59:55 <glguy> Adamant, you don't have a Macintosh, the built-in spell-checker in all the text boxes would have detected your spelling "Macintrash"!
16:00:20 <glguy> and would have added the "tm" to boot :-D
16:00:25 <tensorpudding> Terminal.app can be coerced into being a usable terminal emulator.
16:00:44 <Adamant> glguy: His Turtleneckness hasn't made spell check corrections mandatory
16:00:48 <Adamant> .... yet.
16:02:14 <mle> give the guy credit; he made emacs keybindings pervasive through most of the core apps
16:03:16 <Adamant> mle: now you've just given vimmers ammunition
16:03:19 <ivanm> tensorpudding: try ie4linux maybe...
16:03:34 <ivanm> (it's a bash script to download IE and get it working with wine)
16:03:38 <ivanm> shapr!!!
16:03:51 <tensorpudding> I wish more Linux applications used emacs keybindings.
16:04:09 <tensorpudding> I keep using C-s to search in Chrome, and getting the save dialog instead.
16:04:17 <ivanm> tensorpudding: yet those that do do it badly usually
16:04:21 <ivanm> since they're not customisable, etc.
16:04:29 <ivanm> e.g.: matlab's emacs keybindings are _atrocious_
16:04:32 <Zao> Just integrate the applications into EMACS instead.
16:04:41 <Zao> ivanm: Amen.
16:04:42 <glguy> yeah... why mix the operating systems?
16:04:46 <ivanm> tensorpudding: yeah, I do that in firefox as well :s
16:05:08 <ivanm> glguy: *sigh* find a new non-witty comeback please
16:05:22 <ivanm> that one is getting rather stale
16:05:27 <glguy> This old tired ones are working quite well
16:05:31 <glguy> these*
16:05:44 * BMeph associates C-s with Windows Save dialogs...
16:06:03 <tensorpudding> Linux desktop applications try too hard to be like Windows ones.
16:06:26 <glguy> outside of emacs ^S is pretty much universally "save", isn't it?
16:06:52 <tensorpudding> Adamant claimed that OS X apps use emacs keybindings.
16:07:07 <Adamant> tensorpudding: I did not
16:07:07 <tensorpudding> I've not used OS X nearly long enough to know that though.
16:07:28 <tensorpudding> Sorry, that was mle.
16:07:28 <mle> tensorpudding: I'm asserting that most apple apps (save itunes) respect emacs cursor movement keys
16:07:49 <Adamant> tensorpudding: some of them are partially common, only with use of the Apple key.
16:08:06 <ivanm> mle: heh, and they would be the emacs keybindings I _don't_ use, even in emacs ;-)
16:08:11 <Adamant> not going to bother looking through all of them :P
16:09:05 <mle> ivanm: too many years fiddling with emacs on terminals with no arrows or meta I guess.
16:09:21 <ivanm> fair enough
16:09:30 <tensorpudding> I got the understanding that the apple key was used in a manner analogous to control in Windows
16:09:51 <tensorpudding> I use the emacs movement keys all the time.
16:10:08 <Adamant> tensorpudding: yeah, but the ctrl key also exists.
16:11:01 <tensorpudding> It's actually saner that way, because it's easier to hit alt/apple instead of control
16:14:25 <mle> I just make capslock my control
16:14:47 <tensorpudding> I do the same.
16:14:47 <cads> hey, I'm looking for the tools I'd need to use to 1) find the name of the directory a cabal file is being installed to 2) rewrite the cabal install file slightly to reflect some platform specific compilation settings, and 3) download some files from the internet and and unpack them into the target directory.
16:15:08 <ivanm> cads: cabal files aren't installed...
16:15:14 <cads> This seems like a lot of work just to get cabal install working seamlessly with a package on windows
16:15:24 <tensorpudding> presumably the location a cabal package is installed to is determined by your cabal config
16:15:25 <cads> but I'm not sure if there's another way
16:15:49 <ivanm> cads: using cabal-install: cabal unpack foo; cd foo-<version>; edit foo.cabal; cabal install
16:16:00 <blackdog> what are the extra packages you're installing? could you get around it by requiring an extra package on windows and doing that work in that package?
16:16:11 <ivanm> ghc-pkg list will say where an installed librarie's files can be found
16:16:13 <dcoutts_> cads: do you mean where the file of the package get installed? like the executables, lib files, data files etc
16:16:42 <ivanm> blackdog: oh, wrt your comment on haskell reddit about c2hs using hubris, would you keep using it now that dcoutts_ has released a 6.12 compatible version?
16:16:52 <cads> dcoutts: yes, in windows it's C:\program files\haskell by the haskell platform's default
16:17:38 <dcoutts_> cads: so when you configure/install you can specify the location of all the various bits (--prefix, --libdir etc)
16:18:00 <dcoutts_> cads: and can pass some compile settings too, eg where to look for C libs & headers
16:18:29 <dcoutts_> cads: none of that requires modifying the package
16:18:51 <Kaidelong> Does haskell have any notion of algebraic data types having Eq if all their content types have Eq?
16:19:06 <Kaidelong> IE checks for isomorphism and the equality of the members of the algebraic type
16:19:16 <ivanm> Kaidelong: if you derive Eq, then yes
16:19:18 <EvanR> Kaidelong: deriving (Eq)
16:19:37 <blackdog> ivanm: hm. maybe
16:19:39 <Kaidelong> when do you do that, when declaring the algebraic type or instantiating it?
16:19:50 <ivanm> blackdog: unless you really want a broken definition of CLDouble :p
16:19:59 <ivanm> Kaidelong: when declaring the datatype
16:20:05 <cads> dcoutts_ as it stands right now, for a windows install a user must download a special library archive, unpack that to a stable destination, and add some lines to the project's cabal file so that it can see the correct file directory
16:20:06 <dcoutts_> blackdog: are you using CLDouble?
16:20:10 <blackdog> the difficulty is that I want to move to being able to install haskell code into a ruby interpreter that's installed after the fact
16:20:11 <ivanm> data Foo a = Bar a a deriving (Eq)
16:20:16 <blackdog> dcoutts_: not directly.
16:20:24 <Kaidelong> ivanm: but the instance will not be equatable if the members in it are not equatable
16:20:28 <cads> basically there's no include or lib folder in windows and the user has to specify what he'd like to use
16:20:42 <dcoutts_> cads: no, you can specify the location of the C lib when building the package without having to modify the package
16:20:44 <EvanR> Kaidelong: the members will either need to be in Eq or they will be restricted
16:20:44 <Kaidelong> do you have to make a seperate type that is equatable and one that isn't?
16:20:46 <blackdog> dcoutts_: i've got a wrapper between ruby and haskell, though, so i guess if someone's using a long double in ruby, it'd be good to handle it in haskell
16:20:52 <ivanm> Kaidelong: right; values of type Foo (a -> b) don't have == defined
16:20:55 <blackdog> dcoutts_: but there's no code to handle it now
16:21:09 <ivanm> Kaidelong: no, deriving takes care of both cases for you
16:21:16 <ivanm> even if you have multiple type parameters
16:21:16 <Kaidelong> oh ok
16:21:22 <EvanR> oh, you can have Foo X where X is not Eq ?
16:21:30 <cads> dcoutts, using --prefix and --libdir and the like?
16:21:31 <ivanm> yes
16:21:42 <dcoutts_> blackdog: so what I did in the recent c2hs release is to make it an error to bind long double if the C compiler or Haskell compiler do not support it. That applies to ghc-6.12 at the moment, though obviously that may change in future.
16:21:43 <blackdog> the difficulty is that I want to move to being able to install haskell code into a ruby interpreter that's installed after the fact
16:21:57 <dcoutts_> cads: no, using --extra-lib-dir and --extra-include-dir
16:22:05 <applicative> Kaidelong, you can find the Eq instances in http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.1/Data-Eq.html
16:22:06 <blackdog> dcoutts_: that'd be fine. my problem was just not being able to install c2hs
16:22:09 <Kaidelong> so Haskell has implicit structural equality in that you don't need to give it an overload for (==) but it's more explicit in that you still have to say that your structure can be structurally equatable?
16:22:11 <ivanm> if you want equality when the type parameters don't have Eq instnaces, _then_ you need to have a custom instance of Eq for your datatype
16:22:21 <dcoutts_> cads: --prefix and --libdir are to specify where the files of this package will be installed, not about where to look for C libs
16:22:34 <ivanm> Kaidelong: that sounds about right
16:22:38 <dcoutts_> blackdog: ok, so that should work fine now with c2hs-0.16.2
16:22:43 <blackdog> the only other problem is that it means i need to have c2hs installed at runtime, and accessible in the path, and blah blah blah... is probably easier to do things myself
16:22:52 <cads> dcoutts_ I'll try that out
16:22:57 <dcoutts_> blackdog: at runtime?
16:23:11 <ivanm> blackdog: well, if c2hs is needed at build time for hubris, then you can probably assume it's available at runtime
16:23:23 <ivanm> dcoutts_: I think he's doing automagic conversion to/from Ruby via C
16:23:32 <ivanm> and was using c2hs to assist in doing so
16:23:38 <cads> dcoutts_ how would I take that a step further and have "cabal install hmatrix" be all that a windows user would need to type to get it to work?
16:23:53 <blackdog> dcoutts_: yeah, more or less - was using it to do some processing of ruby.h
16:24:07 <blackdog> but the ruby package containing ruby.h may not be installed at the time i install hubris
16:24:29 <blackdog> a lot of ruby hackers use rvm to switch versions, so it'd be good to have it working with all of them
16:24:32 <ivanm> blackdog: put it this way: how hard/difficult would it be for hubris to do it manually?
16:24:51 <dcoutts_> blackdog: so hubris does runtime code generation and dynamic loading of Haskell code?
16:24:56 <cads> blackdog: you're working with hubris?
16:25:02 <blackdog> ivanm: not terribly hard:) i'm not really using c2hs's more advanced stuff
16:25:11 <blackdog> just used it to get started
16:25:24 <blackdog> cads: working on, really:) you've heard about it?
16:25:46 <blackdog> dcoutts_: yes, exactlyy
16:25:47 <cads> yes
16:26:03 <dcoutts_> cads: if you want it more automatic, there has to be some way to find the C libs automatically. If there is a way, you can code that into the Setup.hs for hmatrix.
16:26:08 <blackdog> dcoutts_: thanks to all that fantastic work on dynamic libraries from well-typed :)
16:26:15 <dcoutts_> heh :-)
16:26:39 <dcoutts_> blackdog: so if you're not using the c2hs {# call #} stuff then it's not really buying you much.
16:26:52 <EvanR> i know that ls ++ ms is an ok value if ls is infinite, iterating through ls ++ ms will simply never get to ms. but what about this? ls ++ last ls
16:26:53 <dcoutts_> that's the killer feature, cross-language type safety
16:27:02 <blackdog> speaking of - any clue how the dynlib for mac code is going?
16:27:11 <Kaidelong> couldn't you write C code that will confound any attempt at that?
16:27:19 <dcoutts_> blackdog: no idea, I've not worked on that bit
16:27:40 <blackdog> dcoutts_: yep. i've got a really nice test case coming up - I want to reimplement Treetop, a ruby parser library, but have it be API compatible
16:27:50 <blackdog> dcoutts_: if i can do that, Hubris is done and dusted
16:28:11 <blackdog> dcoutts_: ok, i'll bother igloo.
16:28:51 <cads> dcoutts_ hmm, then I think I'm looking at getting the setup script to download http://code.haskell.org/hmatrix/gsl-lapack-windows.zip and proceed from there
16:29:14 <cads> otherwise getting the libraries is a true pain for the users
16:29:47 <cads> (I gave up on getting hmatrix to work 3 times before getting my wits about me and diving into the code to see what was up :)
16:32:00 <mreh> cads: what were you doing with it?
16:32:13 <mreh> I've only ever used the basic matrix stuff
16:32:15 <dcoutts_> cads: doing network operations in Setup.hs is a no-no
16:33:13 <dcoutts_> blackdog: Igloo is not working on the osx dyn libs either as far as I know, I don't recall who was doing the OSX side of things
16:33:46 <blackdog> dcoutts_: well, stephen blackheath and i wrote it
16:33:53 <dcoutts_> blackdog: ahh, ok :-)
16:33:55 <blackdog> but it hadn't been merged last time i looked
16:34:05 <dcoutts_> blackdog: I see
16:34:14 <cads> mreh: I'm looking to write a little numerical sim with it
16:34:58 <mreh> cads: a Will Wright sim?
16:35:24 <EvanR> why doesnt this work :( http://codepad.org/kUSBBL3Y
16:35:57 <glguy> (x:xs) matches [x]
16:36:04 <EvanR> oh
16:36:08 <cads> mreh, a little solar system simulator :)
16:36:16 * hackagebot testpack 2.0.0 - Test Utililty Pack for HUnit and QuickCheck  http://hackage.haskell.org/package/testpack-2.0.0 (JohnGoerzen)
16:36:20 <EvanR> (x:[])
16:36:49 <EvanR> and gotta rearrange
16:37:32 <EvanR> http://codepad.org/dwuGZ57l
16:37:44 <mreh> cads: fun, i'd quite like one of those, I was going to make an inter planetary trading simulator
16:37:45 <dcoutts_> cads: a first step would be to reduce the installation instructions down to just two steps: 1) download gsl zip file & unpack to location ${GSL}  2) cabal install hmatrix --extra-lib-dir=${GSL} --extra-include-dir=${GSL}
16:38:18 <glguy> mreh, have you played Eve Online?
16:38:31 <mreh> glguy: yes
16:38:40 <mreh> it's horrible
16:39:00 <mreh> well... very nice, but I got too bored
16:39:41 <mreh> maybe if I were a market trader I could run it behind my excel spreadsheets
16:40:00 <mreh> I was hoping for something a bit more like pizza tycoon
16:40:13 <[swift]_> template haskell's pretty printer could really use some work; it produces code that ghc won't compile
16:40:56 <[swift]_> the main problem is that it qualifies things that ghc doesn't like when qualified; for example, "++" becomes "GHC.Base.++", which ghc won't accept
16:41:55 <glguy> [swift], why doesn't GHC like that?
16:42:31 <glguy> > 20 Prelude.* 30
16:42:32 <lambdabot>   600
16:43:31 <EvanR> > repeat []
16:43:32 <lambdabot>   [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
16:43:49 <glguy> > cycle [1,2]
16:43:50 <lambdabot>   [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,...
16:43:52 <[swift]_> glguy: maybe that was a bad example, i guess ghc will accept that if you import GHC.Base. however, it won't accept "GHC.Types.[]" even if you import GHC.Types
16:46:43 <newsham> "inter planetary trading simulator" like the old game Elite?
16:48:48 <jbapple> Xavier Leroy announced that the next released OCaml will support polymorphic recursion: https://forge.ocamlcore.org/docman/view.php/77/112/leroy-cug2010.pdf
16:49:07 <fax> wow!
16:50:01 <jbapple> IIRC, this could be simulated already with modules, but this makes things easier
16:50:09 <jbapple> (An example is given in the slides)
16:50:37 <jbapple> (see also Chris Okasaki's thesis or Louis Wasserman's recent priority queue proposal)
16:50:40 <fax> oh cool local open, agda does that
16:51:46 <amosrobini> does that mean you can make crazy types like e.g. y combinator ?
16:52:12 <cads> dassault uses ocaml, eh?
16:52:17 <cads> I wonder what for
16:52:57 <jbapple> amosrobini: the types it allows you to write are not so unusual, but the functions are
16:53:22 <jbapple> And the y combinator is a value, not a type
16:53:33 <newsham> polymorphic recursion like in finger trees?
16:53:39 <jbapple> But I think its type isn't so astonishing
16:53:43 <jbapple> newsham: yes, exactly
16:53:55 <newsham> it didnt already do that?  wow :(
16:54:40 <jbapple> A simple example is Data PTree a = Nil | PTree a (PTree (a,a)) . Writing a length function on this type requires some kind of polymorphic recursion
16:55:05 <jbapple> (There are a few cases of PR that are sometimes distinguished)
16:55:13 <cads> mreh, it's actually a dream of mine to make an open space sim game that allows both scientists and players room for interesting discovery
16:55:25 <jbapple> O'Caml allowed one to write functions like this via modules, I think
16:55:36 <jbapple> I think there was a Planet Haskell post about this a month or so ago:
16:56:01 <ddarius> newsham: Polymorphic recursion was one of the unique things about Haskell.  I'm not sure if Clean has it.
16:56:44 <ddarius> Nested data types quickly lead to polymorphic recursion, but there are examples that don't use nested data types.
16:57:05 <jbapple> There was also this: http://forge.ocamlcore.org/projects/pa-polyrec/
16:57:33 <jbapple> ddarius: What is an example that doesn't use nested data types?
16:57:35 * glguy hasn't heard about clean in a year or two
16:58:06 <Cale> It seems a bit weird to me that polymorphic recursion wouldn't be supported.
16:58:08 <fax> nested data types are crazy
16:58:25 <fax> jbapple your posts about them were a lot of fun
16:58:50 <ddarius> > let f :: Show a => Int -> a -> String; f 0 a = show a; f n a = f (n-1) (a,a) in f 3 'x'
16:58:51 <lambdabot>   "((('x','x'),('x','x')),(('x','x'),('x','x')))"
16:59:00 <jbapple> fax: thank you
16:59:01 <ddarius> > let f 0 a = show a; f n a = f (n-1) (a,a) in f 3 'x'
16:59:02 <lambdabot>   Occurs check: cannot construct the infinite type: a = (a, a)
17:00:34 <ddarius> Cale: It required a bit more effort to add to the type system and it's rarely used (in Haskell.)  It is nice that Haskell had it though, so explorations of nested types could be done.
17:00:40 <mreh> cads: I thought you said open source, and I felt a bit sick
17:01:23 <jbapple> ddarius: ok, but Show + the instance you use is very close toa nested datatype Show a = Show (a -> String) (Show (a,a))
17:01:43 <fax> can anyone show me some ring theory in universal algebra in category theory?
17:02:14 <mreh> cads: we'll find an accurate way to model the evolution of a universe, then we're half way there
17:02:31 <fax> programming with nested data types is like learning recursion again
17:02:49 <cads> mreh: I don't think I'll actually go into making games, but the idea would be that it would use some hyper realistic simulation engine that would allow users to build their own technologies, so it would require users with strong engineering to create effective spaceships
17:02:54 <ddarius> jbapple: I can do it without a constraint too.  E.g. you can do a bit-reversal permutation by constructing a list of 2-tuples (of 2-tuples of ...).
17:02:59 <monochrom> you have to learn recursion again everyday.
17:03:07 <ddarius> I.e. creating a complete binary tree and then flattening it.
17:03:20 <monochrom> learning recursion is like learning recursion again
17:03:26 <fax> lol
17:03:43 <mreh> that's self reference... oh, right
17:03:53 <jbapple> ddarius: can you show us?
17:04:19 <cads> mreh: at the same time, there would be a lot of distributed computing horsepower pouring into the game from users and this might be usable for scientists working on designing the technologies
17:04:41 <cads> hehe, in my dream, these simulated technologies are also somehow useful in the real world
17:04:42 <jbapple> http://www.church-project.org/reports/electronic/Hal+Kfo:BUCS-TR-2004-004.pdf : "Programming examples needing polymorphic recursion"
17:04:43 <jbapple> "
17:04:44 <mreh> cads: sounds insanely difficult to do
17:05:18 <cads> yeah, it's grandiose
17:06:05 <ddarius> > let bitrev :: [a] -> [a]; bitrev = uncurry (++) . unzip . bitrev . pairUp where pairUp [] = []; pairUp (x:y:xs) = (x,y):pairUp xs in bitrev [0,1,2,3,4,5,6,7]
17:06:07 <lambdabot>   *Exception: stack overflow
17:06:23 <ddarius> > let bitrev :: [a] -> [a]; bitrev [x] = [x]; bitrev = uncurry (++) . unzip . bitrev . pairUp where pairUp [] = []; pairUp (x:y:xs) = (x,y):pairUp xs in bitrev [0,1,2,3,4,5,6,7]
17:06:24 <lambdabot>   Equations for `bitrev' have different numbers of arguments
17:06:24 <lambdabot>    <interactive>...
17:06:43 <ddarius> I remember doing both of those errors before.
17:06:53 <ddarius> > let bitrev :: [a] -> [a]; bitrev [x] = [x]; bitrev xs = uncurry (++) . unzip . bitrev . pairUp $ xs where pairUp [] = []; pairUp (x:y:xs) = (x,y):pairUp xs in bitrev [0,1,2,3,4,5,6,7]
17:06:54 <lambdabot>   [0,4,2,6,1,5,3,7]
17:07:47 <jbapple> very nice
17:08:13 <mreh> cads: I was thinking more along the lines of faction wars in space, I'm going to cut my teeth on something more established first
17:08:28 <mreh> getting a job in the industry is just impossible though
17:09:45 <cads> mreh, but imagine going into a battle, letting loose hundreds of autonomous drones armed with thermonuclear warheads and masers and antimatter drives, accelerating at 40 gees and engaging in unbelievably complex tactical battles with huge sensor blinding explosions, electronic counter-counter measures, and you in the cockpit of your space hulk trying to stay alive
17:10:26 <mreh> my space accountant would not approve
17:10:38 <ddarius> cads: Wouldn't you just be sitting there waiting for the end of the battle or your time to run away if necessary?
17:10:45 <monochrom> and the CPU overheating, the computer shutting down automatically, and the game aborting.
17:12:08 <ddarius> monochrom: Shutdown sequence overriden
17:13:08 <cads> ddarius: you could try to get away from the opponent by going silent and hiding behind radioactive wreckage or something :)
17:13:30 <monochrom> "windows has aborted the game because the display driver has crashed"
17:13:44 <cads> but then you're running on passive sensors, and she pings you you're boned
17:13:49 <monochrom> I actually get that sometimes.
17:13:59 <monochrom> The object world is only as good as the meta world.
17:15:33 <cads> ddarius: what bugs me is that I don't think this would be tractable for a single player - for example in submarines you have a whole crew operating the tactical functions
17:15:49 <mreh> but only one captain
17:16:23 <monochrom> take the human out of the loop
17:16:41 <ickabob> Is there a reason why many parameterized tree types I've encountered in haskell stores data elements exclusivly in the leaves?  ie a structure like: Data Tree a v = Leaf a v | Branch v (Tree a v) (Tree a v)
17:17:17 <monochrom> unknown reason
17:17:22 <ddarius> Most people don't use a generic binary tree type.
17:17:32 <monochrom> In fact see Data.Tree, data stored in internal nodes
17:17:42 <fax> I don't get it, how come universal algebra is so great if you can't even do fields with it?
17:17:56 <ddarius> fax: Because fields aren't algebraic structures.
17:18:17 <fax> but they're in my algebra book
17:18:31 <tensorpudding> Rings aren't algebraic structures?
17:18:42 <ddarius> tensorpudding: Rings are.  But not all rings are fields.
17:18:58 <monochrom> I thought we went over this last night. Haskell fields suck, but Haskell is still great. The same should apply to universal algebra.
17:19:12 <tensorpudding> But all fields are rings, so if rings are algebraic structures, then so are fields.
17:19:35 <Saizan> nice overloading of field there
17:19:55 <monochrom> class Fieldable t where field :: ....
17:20:08 <mreh> forcefields
17:20:10 <jbapple> back up the truck: fields aren't algebraic?!?
17:20:11 <ddarius> tensorpudding: And the real numbers are fields too so the real numbers should be an algebraic structure.
17:20:14 <mreh> cornfields
17:20:24 <fax> jbapple: the 0 <> 1 axiom doesn't seem to fit
17:20:24 <Cale> tensorpudding: Fields require a rule which is conditional.
17:20:32 <ddarius> fax: Exactly.
17:20:38 <monochrom> the exception catcher in the record field
17:20:42 <tensorpudding> What's the difference between a structure which satisfies algebraic properties and an "algebraic structure"?
17:20:51 <ddarius> Algebraic structures, in the sense of universal algebra, are ones that are specified by equational laws.
17:20:54 <jbapple> hm
17:21:01 <ddarius> Fields require an inequation.
17:21:11 <tensorpudding> Which inequation?
17:21:17 <ddarius> tensorpudding: 1 /= 0
17:21:23 <monochrom> if x/=0 ...
17:21:25 <Cale> Specifically, one of the field axioms says "for all a in F, if a is not equal to 0, then there exists some b in F for which ab = 1."
17:21:31 <twink> It needs an additive identity which is a multiplicative annihilator, and a multiplicative identity.
17:21:45 <ddarius> Categories fall into a class called "almost-algebraic structures" because they require equational laws that only sometimes apply.
17:21:53 <Cale> The "a is not equal to 0" part is what kills it.
17:21:59 <tensorpudding> What is the motivation for this definition?
17:22:05 <ddarius> tensorpudding: The rationals.
17:22:17 <monochrom> nullity
17:22:21 <jbapple> forall a, either (exists b, a*b = 1) or (a = 0)
17:22:49 <tensorpudding> I meant, what is the motivation for the definition of "algebraic structure" to refer to equalities and not inequalities?
17:23:13 <ddarius> tensorpudding: Because that captures a whole lot of algebraic structures and it has nice properties/is easy to work with.
17:23:29 <fax> what is there beyond ring which is an algebaric structure?
17:23:41 <ddarius> fax: Any algebraic semantics.
17:23:48 <tensorpudding> Nice properties in what sense?
17:23:50 <monochrom> groups monoids rings lattices all have solely equational laws.
17:24:03 <tensorpudding> "algebraic semantics"
17:24:15 <tensorpudding> It feels like you're speaking a different language of mathematics than me.
17:24:24 <ddarius> tensorpudding: Algebraic semantics is computer science.
17:24:50 <Cale> I thought we were talking about universal algebra
17:24:51 <tensorpudding> Computer science is different than mathematics?
17:24:53 <Cale> http://en.wikipedia.org/wiki/Universal_algebra
17:25:29 <monochrom> > "computer science" == "mathematics"
17:25:30 <lambdabot>   False
17:25:56 * BMeph wonders if anyone's ever tried using GMail or Google Docs as a platform for collaborative editing...
17:26:03 <monochrom> (Personally I'm really tired of "why is this different from what I know")
17:26:40 <tensorpudding> How am I supposed to accept new things without questioning what they are?
17:27:06 <fax> tensorpudding: do you know the Term and Alg categories?
17:27:33 <monochrom> (Even forgetting for a moment that everyone knows only a tiny reality bubble. People don't even agree on whether 0 is a natural number or not. Why should they agree on what is algebra and what is not algebra?)
17:28:04 <cads> BMeph: a programming group I was part of was using it for collaborative notes
17:28:05 <ddarius> monochrom: What is an algebra and what is not depends on the context.
17:28:12 <monochrom> Precisely.
17:28:24 <monochrom> Even 0 and natural number.
17:28:41 <Cale> tensorpudding:  In universal algebra, you restrict yourself to 'unquantified' equational laws, which you can also think of as laws where you have some universal quantifiers applied to a simple equation with no other logical structure.
17:28:59 <twink> Well, rings are all Z-modules, and fields are rings.
17:29:08 <BMeph> cads: Hmm, sounds interesting...
17:29:26 <cads> BMeph: it's free and works pretty well.. I'd imagine there are groupware CMS-like solutions out there that work to exchange larger varieties of files - For example StarOffice for CAD/CAE collaboration between design offices
17:29:32 <jbapple> That wikipedia page on universal  algebra is pretty vague. It would be nice to see a grammar of what formulas are valid for specifying a UA
17:30:03 * BMeph notices the time
17:30:17 <jbapple> One section seems to imply that only equations are permitted
17:30:33 <BMeph> Oof, time to joing the not-so-merry throng on the highways... ;)
17:30:34 <gwern> monochrom: if 0 isn't a natural number, then what does one call 0+natuals?
17:30:48 <ddarius> Here's a book chapter that discusses algebraic semantics: http://www.cs.uiowa.edu/~slonnegr/plf/Book/Chapter12.pdf
17:30:49 <jbapple> However, clearly existentials are permitted, since groups have inverses
17:31:30 <xerox> gwern: N^0
17:31:36 <Cale> jbapple: they can be removed
17:31:45 <Cale> You define groups by saying that you have 3 operations: one binary (multiplication), one unary (inversion), and one nullary (the identity)
17:31:46 <ddarius> jbapple: You write that by providing an operation inv and giving the equation g*inv(g) = e
17:31:48 <gwern> xerox: indeed. how would one pronounce that?
17:32:04 <xerox> i wouldn't, i like my zero natural
17:32:13 <Cale> and then you can write the axioms for a group in a purely equational fashion, with only universally quantified variables
17:32:15 <cads> when I do cabal install -w, which directory should I point to if I'd like to use my ghc-6.12 installation - doing -w [...]ghc-6.12.1 doesn't seem to work
17:32:29 <xerox> but they do use N^0 or N_0 i forget
17:32:42 <jbapple> Cale: you can't do the same for the relation "<>"?
17:32:44 <Cale> You can't do the same trick with a field, because inversion doesn't really correspond to an operator on the field (because it's undefined for 0)
17:32:52 <Cale> There are no relations allowed.
17:32:57 <dcoutts_> cads: the -w flag is to point to the ghc executable, either a full path or one on the %PATH%
17:33:05 <Cale> Only a set of k-ary operations
17:33:09 <jbapple> I must be misremembering by UA
17:33:12 <jbapple> *my
17:33:19 <Cale> A^k -> A for various k
17:33:37 <dcoutts_> cads: ie it does not point to a directory but the actual ghc executable file
17:34:01 <cads> I see
17:34:08 <monochrom> gwern: there are a whole bunch of names for 0+natural. whole numbers. non-negative integers.
17:34:16 <blackdog> dcoutts_: the general idea is to have a different cabal for each ghc installation, right? in a different path?
17:34:31 <blackdog> i've had most success by just changing the PATH and keeping them ignorant of each other
17:34:34 <jbapple> Well, why not simply denote true with 1 and false with 0? Then <> is a binary function
17:34:47 <ddarius> jbapple: Category theory has an excellent story for universal algebra (two actually!) that makes it reasonably clear what is "nice" about what universal algebras talk about.
17:35:00 <dcoutts_> blackdog: what do you mean exactly by a different cabal?
17:35:22 <Cale> jbapple: So how do you write the inverse law in a purely equational way?
17:35:27 <ddarius> jbapple: You can add a "<>" operator to the signature, but there is no way to relate it to the actual equality of the algebraic terms.
17:35:32 <dcoutts_> blackdog: if you mean the program 'cabal', I use one instance of that with all 5 versions of ghc that I've got installed.
17:35:35 <blackdog> dcoutts_: well, having a separate installation of ghc/packages/cabal-install in a different directory
17:35:39 <blackdog> oh, really?
17:35:40 <blackdog> hm
17:35:43 <blackdog> that works ok/
17:35:44 <blackdog> ?
17:35:46 <Cale> jbapple: Note that there are not allowed to be any conditions on when the law applies.
17:35:59 <dcoutts_> blackdog: the Cabal library obviously has to be installed for each ghc, as with all other libs
17:36:02 <gwern> I wish we had a Nat type. would it really be so bad to floor subtraction at 0?
17:36:09 <Cale> It has to be an equation which is universally true for any assignment of the variables which occur in it
17:36:15 <idnar> @hoogle Nat
17:36:15 <lambdabot> Text.Parsec.Token natural :: GenTokenParser s u m -> ParsecT s u m Integer
17:36:16 <lambdabot> Text.ParserCombinators.Parsec.Token natural :: GenTokenParser s u m -> ParsecT s u m Integer
17:36:16 <lambdabot> Text.Parsec.Token naturalOrFloat :: GenTokenParser s u m -> ParsecT s u m (Either Integer Double)
17:36:22 <idnar> bah, I keep doing that
17:36:23 <blackdog> dcoutts_: sure. how does the cabal binary know which to use?
17:36:51 <idnar> gwern: http://hackage.haskell.org/package/nat
17:37:05 <dcoutts_> blackdog: it's all backwards compatible. The latest Cabal works with ghc-6.4+, though the cabal-install package only builds with ghc-6.6+
17:37:28 <ivanm> dcoutts_: does anyone still use versions of GHC that old that you need to keep testing them?
17:37:39 <dcoutts_> ivanm: I do :-)
17:37:39 <idnar> gwern: or do you just want a non-negative Integer?
17:37:46 <blackdog> dcoutts_: sure, but how do you tell it "install this library using this compiler"?
17:37:58 <ivanm> dcoutts_: in development, or just for testing backwards compatability?
17:38:04 <jbapple> Cale: How about: let the multiplicative inverse be denoted by mi : F -> F, and let mi 0 = 0. Then (x * (mi x) = 1) + (x = 0) == 1
17:38:05 <dcoutts_> blackdog: I do: for ghc in ghc-6.4.2 ghc-6.6.1 ghc-6.8.2 ghc-6.10.4 ghc-6.12.1; do cabal install -w $ghc; done
17:38:18 <blackdog> so then the ghc itself knows which ghc-pkg to use?
17:38:29 <cads> dcoutts, hah!
17:38:33 <blackdog> i've always been a bit fuzzy on the relationships there, forgive the n00b questions
17:38:34 <ivanm> with the ubuntu LTS ending soon (if it hasn't already), can't we soon start dropping base-3 compatability and assume 6.10+ ?
17:39:01 <dcoutts_> blackdog: ghc doesn't actually call ghc-pkg, it reads the package db directly, the package dbs are separate for each ghc version
17:39:14 <Cale> jbapple: I'm not sure I understand your notation
17:39:21 <jbapple> Where "=" is the computational equals inside the system and "==" is for the laws of the UA
17:39:21 <ivanm> dcoutts_: so _that's_ why you wrote cabal-install: to make it easier for you to test building different libraries without worrying about symlinks, etc.!
17:39:28 <dcoutts_> blackdog: cabal can usually correctly find the ghc-pkg corresponding to a ghc instance
17:39:28 <idnar> heh
17:39:30 <Cale> jbapple: Is this = thing a new binary operator? What equations must it satisfy?
17:39:31 <blackdog> ok, but surely ghc-pkg has to be called when you're actually installing the lib?
17:39:38 <Cale> (apart from this one)
17:39:46 <jbapple> ddarius: I see what you mean
17:39:48 <blackdog> ok. so the knowledge is inside cabal
17:39:50 <ivanm> blackdog: Cabal does that methinks
17:40:09 <blackdog> so it works it out from the path?
17:40:13 <dcoutts_> blackdog: eg if ghc-x.y.z is found in $dir, then cabal looks for ghc-pkg-x.y.z in the same place. It double checks the versions match.
17:40:46 <dcoutts_> if you have ghc-pkg somewhere cabal cannot find it, then you can specify it explicitly
17:41:20 <dcoutts_>  -w --with-compiler=PATH           give the path to a particular compiler
17:41:20 <dcoutts_>     --with-hc-pkg=PATH             give the path to the package tool
17:41:29 <jbapple> Cale: good question. (x = x) == 1, certainly. There would have to be a binary function <>, so (x <> 0) + (x + y = y) == 1
17:41:36 <dcoutts_> blackdog: ^^ from cabal configure --help
17:41:40 <Cale> jbapple: Can I have a "field" where I just define x = y to always give a value v where v + v = 1?
17:42:07 <blackdog> dcoutts_: ok. just trying to work out the golden path, without too much fiddling
17:42:26 <blackdog> is there an environment variable I can set in general to say "use this compiler"?
17:42:50 <dcoutts_> blackdog: there's two ways, one is to make "ghc" be first on the $PATH
17:43:05 <Cale> Or I should say, v + v == 1
17:43:12 <Cale> since we have awkward notaton now :)
17:43:27 <dcoutts_> the other is to use the ~/.cabal/config to specify a default value for the "with-compiler" setting
17:43:32 <jbapple> Cale: Not with (x = x) == 1, right, unless 1+1 == 1
17:43:41 <blackdog> something like gcc_select modified for ghc would be enough, then
17:44:34 <dcoutts_> blackdog: generally we have versioned ghc executables and the unverisoned one points to the one you installed most recently
17:44:36 <Cale> jbapple: But you see the problem, right? There's nothing which says that x = y always has to be either 0 or 1
17:44:39 <DigitalKiwi> dumb question, is that even reliably possible to have two values add to 1? due to floating point and such...
17:44:54 <DigitalKiwi> two of the same value ofc
17:44:58 <fax> > 0.5 + 0.5
17:44:59 <lambdabot>   1.0
17:45:03 <cads> hmm, this is strange
17:45:19 <Cale> DigitalKiwi: In floating point? Yes, provided that the base is divisible by 2.
17:45:42 <Cale> (It usually is 2, since we use binary computers)
17:45:52 <DigitalKiwi> file permissions!
17:46:04 <jbapple> Cale: I think I see
17:46:42 <cads> I do a cabal update but it says to run cabal install cabal-install (I have 0.6.2). I do this and it runs through compiling cabal install 0.6.4 and it compiles 34 items
17:47:04 <cads> but then when I run cabal --version it's still 0.6.2
17:47:05 <blackdog> dcoutts_: ok. my problem is that i quite frequently have multiple installs around and i haven't had a good way to manage them, but if 'ghc' is the only selection point I think i can manage that. cheres.
17:47:17 <DigitalKiwi> hrm, is ubuntu still moving to base 10 like apple? >.>
17:47:18 <ivanm> cads: check your $PATH
17:47:20 <cads> and cabal update gives me the same message
17:47:23 <dcoutts_> cads: check your %PATH%, sounds like you have multiple instances installed
17:47:25 <ivanm> DigitalKiwi: IIRC, yes
17:47:33 <DigitalKiwi> bah!
17:47:35 <cads> ah
17:47:46 <ivanm> DigitalKiwi: yeah, I see more and more stupid things coming out from Ubuntu
17:48:04 <ivanm> e.g. removing the notification area
17:48:10 <dcoutts_> blackdog: so I have multiple versions too, I find the versioned exe + default works quite well. I usually only need special versions when testing things.
17:48:11 <DigitalKiwi> ubuntu is why we can't have nice thing
17:48:12 <DigitalKiwi> s
17:48:13 <cads> it's installing in c:/program files/haskell/bin
17:48:17 <ivanm> I don't want a friggin menu for every applet I have in my notification area
17:48:20 <ivanm> DigitalKiwi: exactly!
17:48:22 <jbapple> Cale: I don't yet understand why it is impossible. In particular, it seems like the model I proposed would be too lose
17:48:24 <Cale> DigitalKiwi: Yeah, I'm thinking that at some point I'm just going to switch back to Debian.
17:48:24 <jbapple> *loose
17:48:28 <ivanm> especially when stupid people think that linux == ubuntu
17:48:39 <DigitalKiwi> s/stupid/ignorant/
17:48:46 <Cale> jbapple: Yeah, you'd probably get a bunch of other weird things, in addition to the fields.
17:48:51 <DigitalKiwi> though a lot of ignorance is due to stupidity
17:48:54 <jbapple> Cale: So what models of fields are valid with the reified "=" and "<>" that are not actual fields?
17:48:54 <ivanm> DigitalKiwi: fine, if you want to be PC
17:48:56 <DigitalKiwi> and #ubuntu ops
17:49:00 <Cale> (I can't really say for sure what they are)
17:49:02 <ivanm> heh
17:49:05 <cads> ivan, I think ubuntu "isA" linux :)
17:49:15 <DigitalKiwi> i once had an argument over them of whether users should be expected to learn how to use google
17:49:27 <cads> I don't understand how someone would thing ubuntu "equals" linux
17:49:29 <ivanm> DigitalKiwi: let me guess: they said no
17:49:36 <FauxFaux> DigitalKiwi: Unleash the /argh!
17:49:49 <DigitalKiwi> their take on it "no", my take "they should know how to use google if they are going to use a computer at all"
17:52:30 <DigitalKiwi> hehe, i lawled to myself, want to know why? here's why I was thinking of "knowing how to use google to find info you want is a basic necessity, and then using that knowledge to find info for how to fix your computer is just a hop skip and a jump away" and i thought of the mitch hedberg joke:
17:52:36 <DigitalKiwi> I asked this guy for directions to the store. He said "Oh, that's just a hop, skip and a jump away." Well... that ain't how I'm getting there. You got any directions for those who are walking?
17:53:23 <idnar> people are always asking me questions, which I answer by searching the web
17:53:31 <idnar> then they're amazed at how I seem to know everything
17:53:52 <idnar> I'm never quite sure how to burst their bubble
17:54:11 <cads> idnar: you still have a better ontology than they do so you know the right questions to ask
17:54:23 <cads> there's a saying "you can't learn something without knowing it already"
17:54:54 <cads> this is the difficulty a "newb" faces when told to google something
17:55:06 <Cale> jbapple: There's a theorem (admittedly I don't know this stuff too well), that says that if you have a variety of algebraic structures defined in this restricted way, then it is closed under the operations of homomorphism, subalgebra, and direct product. But we know that fields aren't closed under direct product -- in general you get a ring with zero divisors if you try to take the product of two fields. (In particular
17:55:06 <Cale> , you have that (1,0) and (0,1) are nonzero, but multiply to 0)
17:55:37 <idnar> cads: that's true to an extent, but most people are pretty bad at searching the web even in areas where they have the "vocabulary" to do it
17:55:43 <DigitalKiwi> simply typing an error message into googles prompt often returns the solution >.>
17:55:51 <DigitalKiwi> i can't find how that is hard to do
17:55:57 <Cale> jbapple: So for that reason, it ought to be impossible to define a variety of algebras which exactly consists of the fields.
17:56:00 <idnar> cads: I guess there's a subtle art in being able to craft or recraft the right search query, and evaluate the results quickly to isolate what you're looking for
17:56:02 <blackdog> cads: "Knowledge is of two kinds. We know a subject ourselves, or we know where we can find information on it." - Samuel Johnson
17:56:16 <aavogt> expected type: Int  inferred type: Char
17:56:17 <blackdog> everything old is new again...
17:56:18 <idnar> cads: but sometimes it's just stupid things like "what is the timezone in $CITY?"
17:56:24 <cads> oh jesus
17:56:27 <jbapple> Cale: that's a nice theorem
17:56:35 <blackdog> there's certainly an art to asking google the right question
17:56:39 <monochrom> Thanks Cales, that nails it.
17:56:41 <DigitalKiwi> they should teach in school how to find information you are looking for
17:56:43 <idnar> cads: which is trivially solved by searching for "timezone in Johannesburg" or whatever
17:56:44 <DigitalKiwi> oh wait
17:57:15 <DigitalKiwi> i always wondered what the purpose of all those research papers was!
17:57:21 <cads> idnar: people like that must have very little idea of any kind of theory of knowledge and what a search engine does :)
17:57:25 <DigitalKiwi> it was to make me learn how to find solutions to problems!
17:57:27 <idnar> cads: heh
17:57:30 <Cale> jbapple: Apparently the converse is also true, but much harder to prove.
17:57:41 <DigitalKiwi> what assholes they were! i could just ask people in irc channels!
17:57:48 <idnar> cads: you also get the people who just can't grasp the idea that they can think on their own
17:57:59 <cads> those people are best made into food
17:58:11 <idnar> cads: like they'll join an IRC channel, and say "help, my program doesn't compile, I get a message 'expected semicolon but found right parenthesis'"
17:58:13 <monochrom> Cale: I was thinking along: given a sig and a bunch of equational axioms that includes the ring ones, turn any model into a new non-field one, therefore the sig and axioms still can't capture "field".
17:58:25 <idnar> cads: so you tell them "that error message means that the compiler expected a semicolon, but it found a right parenthesis"
17:58:32 <idnar> cads: and they go "oh, thanks! I fixed it!"
17:58:33 <DigitalKiwi> can we get a remember for that cads comment? :D
17:58:52 <ivanm> DigitalKiwi: if you want to remember it, do it
17:58:54 <cads> idnar, to be fair to those guys, people don't grow up in a culture where they're encouraged to hack on stuff
17:59:16 <ivanm> cads: e.g. ip{od,hone,ad} ?
17:59:20 <idnar> cads: they don't grow up in a culture where they're encouraged to think at all
17:59:25 <idnar> cads: it's rather depressing
17:59:27 <Cale> monochrom: Yeah, that's basically the idea. We can extend all the operations (no matter which new ones you define) to act on pairs componentwise
17:59:40 <cads> idnar: it should just mean you're at an advantage
17:59:41 <ivanm> idnar: thinking? pffffftttt, who needs _that_?
17:59:43 <ivanm> :s
17:59:43 <Cale> and then the equational axioms will of course still be satisfied
17:59:51 <blackdog> DigitalKiwi: we're a friendly channel, remember
17:59:58 * ivanm codes and does math by _instinct_
18:00:00 <Cale> But there will be zero divisors
18:00:05 <blackdog> not like those assholes over in #ocaml
18:00:06 <monochrom> idnar, cads: they don't grow up in a scientific culture. scientific culture would at least make them tell you how to reproducible the whole error situation.
18:00:12 <DigitalKiwi> blackdog: i know, one of the friendliest i've seen
18:00:18 * blackdog knows nothing about #ocaml, comedic purposes only, please don't hit me
18:00:18 <monochrom> not just "this is the error message"
18:00:22 <DigitalKiwi> and i'm an irc channel slut
18:00:27 <tensorpudding> So in some sense, the structure of being a field is not suitably invariant?
18:00:28 <DigitalKiwi> i've seen a lot of irc channels in my day
18:01:02 <cads> monochrom: yeah, they should thing "what conditions are sufficient for bringing on this error message"
18:01:12 <cads> as a very first step
18:01:14 <DigitalKiwi> blackdog: if you had said ##c or #c++ i could assure you that you were spot on :D
18:01:21 <ivanm> or ##java
18:01:22 <jbapple> monochrom: In the example I cooked up above, (1,0) = (1,1) == (1,0), which is neither 1 nor 0
18:01:27 <monochrom> Cale: Oh haha nice. I was thinking of extending a model R to the polynomial ring R[X], but of course I get no assurance of how R[X] satisfies the unknown extra axioms.
18:02:11 <dark> blackdog, the haskell community seems to be more alive, vivid.. my impression is that ocaml is dying due to lack of interest from the 'owners' for improvements in implementation, solution to old problems, etc
18:02:35 <dibblego> ##java is the gutter trash of freenode
18:03:02 <dark> blackdog, i may be wrong, but the community is something that attracts me to haskell. to hear that people are doing llvm stuff seems to me like haskell is very alive
18:04:38 <cads> idnar: I often find myself "hitting the wall", as it were, on some problem, and not being able to proceed without time or external help
18:04:49 <aavogt> there's plenty of rotted haskell code though
18:04:58 <DigitalKiwi> #lua and #haskell are two of the most friendly and helpful channels i've been to, #archlinux is another extremely helpful one, but a lot of them aren't friendly, but most of them will/can help with advanced problems, even if they aren't nice about it >.>
18:05:21 <cads> the time is usually time to research a solution after the initial dazedness wears off
18:06:05 <DigitalKiwi> #lua i would say is slightly more helpful than #haskell, but that is mostly because they are smaller so they can provide more individual attention than #haskell, not for lack of effort on #haskells part
18:06:19 <DigitalKiwi> #ubuntu should be #lolubuntu
18:06:38 <DigitalKiwi> ask a question and in 2 seconds it is off the screen and nobody cares anymore >.>
18:06:38 <[swift]_> strangely enough i got on ok in #c++; maybe because i know my c++ pretty well
18:06:43 <idnar> cads: well, I regularly experience the phenomenon where I spend hours trying to solve a problem
18:06:55 <[swift]_> didn't have a great experience being a newb in #python tho
18:06:58 <tensorpudding> #ubuntu and #debian have a ton of people in them but neither of them are as helpful as #haskell
18:07:01 <idnar> cads: then then about 500 milliseconds after I ask about my problem in a public IRC channel, I work it out myself
18:07:11 <[swift]_> #haskell is the most helpful channel i've used on freenode
18:07:15 <DigitalKiwi> tensorpudding: most of them don't know much
18:07:20 <dark> DigitalKiwi, yeah, i like to be here. (i also like #ocaml, but it is less active (i also like #ruby-lang (#bash also)))
18:07:22 <HugoDaniel> how do i open a opengl 3.2 context in haskell ?
18:07:25 <DigitalKiwi> it's kind of blind leading blind there
18:07:27 <aavogt> idnar: so you should ask first... obviously
18:07:33 <idnar> aavogt: heh heh
18:07:36 <tensorpudding> Or rather, they feel less personable and more like a support system and not friendly chat
18:07:49 <tensorpudding> People have specific problems, they get them answered
18:07:56 <DigitalKiwi> i used to sit in there and try to help people before it was too late (getting fed wrong/stupid answers, etc.) but i got frustrated
18:07:57 <tensorpudding> Or everyone ignores them, or points them to read the manual
18:08:41 <cads> haha, idnar, there seems to be something associated with the act of writing a problem out so that mere schlubs on irc like you can understand the problem that actually tends to solve the problem - almost as if the problem you were struggling with was much larger in imagined magnitude than the problem distilled into language
18:08:57 <DigitalKiwi> cads: talk to a teddy bear
18:09:01 <idnar> cads: yeah, but it's weird
18:09:16 <cads> DigitalKiwi: or a rubber ducky! :)
18:09:17 <idnar> cads: sometimes I've even framed the problem in essentially the exact same words as I use to describe it online
18:09:28 <idnar> cads: but until I actually take that step of communicating it, the pieces won't fall into place
18:09:28 <DigitalKiwi> i know a guy who had a programming instructor who made you explain your problem to the teddy bear before you asked him
18:09:45 <idnar> the teddy bear thing doesn't work for me, because it's artificial :P
18:09:50 <DigitalKiwi> usually the people would figure it out while explaining it
18:09:51 <idnar> I just can't take it seriously
18:10:04 <ddarius> Did you have to explain it until the teddy bear grokked in fullness?
18:10:05 <DigitalKiwi> it's feedback is unimportant!
18:10:06 <cads> I just read about "rubber ducky" programming a few weeks ago, and I was reminded by a friend of mine who will literally pronounce all the characters he sees in a code listing
18:10:08 <tensorpudding> Maybe if it was a real bear
18:10:13 <idnar> tensorpudding: haha
18:10:20 <idnar> tensorpudding: that reminds me of...
18:10:34 <DigitalKiwi> tensorpudding: that eats you if you don't explain it fast enough?
18:10:45 <cads> "f x equals x asterisk x"
18:11:22 <cads> ddarius: teddy bears grok in fullness after minimal explanation
18:11:28 <DigitalKiwi> i was trying to help someone in my fortran class run a test program, and said "tack" instead of "hyphen/dash" and he was like "huh?"
18:11:37 <DigitalKiwi> that was when I realized i was a geek and he was not :(
18:11:37 <idnar> tensorpudding: "Usually the protocol is this: I appoint someone for a task, which they are not qualified to do.  Then, they have to fight a bear if they don't want to do it." -- Glyph Lefkowitz
18:12:21 <idnar> cads: man, I hate reading code out loud
18:12:34 <ddarius> cads: That's because they are Zen.
18:12:42 <idnar> cads: although there are a few people I know well enough that I can actually read code out to them efficiently
18:12:52 <idnar> cads: I mostly do that by leaving out a lot, much to the confusion of anyone else in earshot
18:13:00 <DigitalKiwi> hehe
18:13:02 <ddarius> DigitalKiwi: I have no idea where "tack" comes from.
18:13:35 <DigitalKiwi> you have never heard it?
18:13:56 <ddarius> Nope.  Except for the common everyday object, a thumb tack.
18:14:22 <DigitalKiwi> oh
18:14:25 <DigitalKiwi> nub!
18:14:49 <idnar> I seem to annoy people by pronouncing "SQL" as "ess queue ell" instead of "sequel"
18:15:07 <HugoDaniel> :)
18:15:21 <ddarius> idnar: I used to, and often still do, but I have caved there.
18:15:24 <DigitalKiwi> http://revision3.com/forum/showthread.php?t=29819
18:15:30 * cads goes from stranger to stranger asking "will thou share water with me and be my brother nest-mate?"
18:15:36 <DigitalKiwi> idnar: you do it right!
18:15:47 <idnar> the converse is that when people say "sequel", I stand there going "huh??" for about 3 seconds until my brain catches up
18:16:10 <aavogt> prequel
18:16:26 <DigitalKiwi> ddarius: read link!
18:16:31 <ddarius> DigitalKiwi: I did.
18:16:31 <HugoDaniel> lets all pronounce "haskell" as "ferrari"
18:16:40 <DigitalKiwi> ddarius: yay
18:16:52 <DigitalKiwi> maybe there is hope for you yet!
18:16:55 <ddarius> DigitalKiwi: And I guess I may have heard it in that (the military) sense before, though not from a programmer and not to refer to code.
18:17:18 <DigitalKiwi> if it matters, the person who got me saying it is both an old school hacker and former marine >.>
18:17:27 <cads> #!, #!, oh! when # moves, # moves!
18:17:34 <ddarius> DigitalKiwi: Well, I'm in the military...
18:17:52 <DigitalKiwi> well, once a marine always a marine, >.>
18:17:52 <idnar> <3 <# <3 <#
18:17:54 <ddarius> cads: I'll have to give you points on that one.
18:17:59 <idnar> (you make my heart pound)
18:18:04 <Aepe> Is there a better way to write 'head . filter f $ list' in order to get the first element of the list matching a certin condition?
18:18:12 <ddarius> idnar: You, however, should be shot.
18:18:12 <blackdog> dark: there's been a good example set by the elders :) ruby used to be a bit that way - "matz is nice so we are nice". DHH shook that up a bit, sadly...
18:18:17 * idnar ducks
18:18:20 <fax> Aepe no that's good
18:18:22 <ddarius> Aepe: find
18:18:24 <ddarius> :t find
18:18:25 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
18:18:28 <fax> dammit I am wrong
18:18:40 <cads> ddarius: ricky martin was secretly a unix hacker!
18:19:21 <blackdog> Aepe: there's Data.List.find
18:19:27 <blackdog> but that'll return a Maybe
18:19:35 <blackdog> remember head is unsafe in most cases
18:19:45 <Aepe> Ah, I guess that won't help, because I'm trying to write a code golf
18:19:55 <blackdog> > find (==1) [2..18]
18:19:56 <lambdabot>   Nothing
18:20:16 <blackdog> yeah, the fromJust'll kill you... maybe apply it in a monadic context?
18:20:54 <DigitalKiwi> head is unsafe?
18:21:00 <blackdog> > head []
18:21:01 <aavogt> > (length "(fromJust.).find",length "(head.).filter")
18:21:01 <lambdabot>   *Exception: Prelude.head: empty list
18:21:02 <lambdabot>   (16,14)
18:21:43 <aavogt> also you have to consider that fromJust isn't in the prelude
18:21:44 <blackdog> the dupe elimination idiom makes it ok - map head . group . sort
18:22:07 <DigitalKiwi> are there built in to haskell dequeues and queues and linked lists and stacks? =D
18:22:35 <DigitalKiwi> well technically a queue is a linked list...
18:22:35 <blackdog> a haskell list is a stakc, basically
18:22:39 <aavogt> that's assuming group still behaves the same
18:22:52 <blackdog> DigitalKiwi: not quite - you can't access the front and back in constant time
18:23:11 <blackdog> there's Data.Sequence if you need that
18:23:16 <Twey> > length "head<$>filter"
18:23:17 <lambdabot>   13
18:23:24 <DigitalKiwi> in which can't you?
18:23:29 <aavogt> you can make a first-in-last-out queue with a pair of lists
18:23:31 <blackdog> haskell list
18:23:39 <DigitalKiwi> oh
18:23:47 <blackdog> aavogt: that's only asymptotically constant, right?
18:24:22 <aavogt> blackdog: if you amortize the occasional reverses on the input list over all the other operations
18:24:33 <DigitalKiwi> what does asymptotically mean?
18:24:44 <DigitalKiwi> i've seen it a few times in the past few days but am like "Huh?"
18:24:47 <aavogt> I'm not sure either here
18:24:48 <Twey> Approaching but not touching
18:25:07 <DigitalKiwi> oh that makes sense
18:25:12 <blackdog> DigitalKiwi: in this context, it means that any individual access _may_ take linear time
18:25:18 <blackdog> but summed across all of them, it'll be constant
18:25:20 <DigitalKiwi> i didn't see the "asymptot" in it
18:25:29 <Saizan> blackdog: that's the meaning of amortized, i'd think
18:25:58 <aavogt> since some operations take time linear in the number of elements you have added
18:26:00 <blackdog> blah. did i say asymptotically? i meant amortised, sorry. coffee hasn't kicked in yet
18:26:13 <DigitalKiwi> what about binary trees?
18:26:16 <DigitalKiwi> are they in haskell?
18:26:30 <blackdog> you can write them
18:26:33 <blackdog> and libraries exist
18:26:36 <DigitalKiwi> oh well that's no fun!
18:26:37 <blackdog> they're not part of the core
18:26:39 <DigitalKiwi> :(
18:26:48 * DigitalKiwi had to make all of these in fortran
18:26:49 <blackdog> even lists aren't _really_ part of the core. they're in the prelude
18:26:50 <DigitalKiwi> oh god
18:26:52 <aavogt> Data.Tree isn't a binary tree
18:26:52 <idnar> cads, ddarius: http://manga.clone-army.org/t42r.php?page=122&lang=
18:26:53 <DigitalKiwi> i want to die :(
18:26:58 <aavogt> but you can use it like one
18:26:58 <Saizan> DigitalKiwi: you mean binary search trees?
18:27:12 <Saizan> DigitalKiwi: just import Data.Map
18:28:15 <Saizan> haskell has almost nothing built-in, but these data structures are in the base or core libraries anyway
18:28:34 <DigitalKiwi> k
18:28:51 <DigitalKiwi> i like haskell more and more when i learn about it
18:28:59 <DigitalKiwi> but i suck at learning it :(
18:29:06 <ivanm> blackdog: the syntactic sugar for lists are
18:29:11 <blackdog> DigitalKiwi: it's a design decision, really. the more you include as part of the core, the less flexible you are. most functional languages try to come up with powerful combination methods, and build the other functionality up in libraries
18:29:14 <DigitalKiwi> i should sit down this summer and read some books without interruption
18:29:25 <blackdog> ivanm: true.
18:29:26 <ivanm> and I'm not sure if you can define [] in your own code
18:29:42 <dibblego> you can't
18:29:43 <DigitalKiwi> blackdog: i think python is bloated >.>
18:29:52 <DigitalKiwi> <3 lua
18:30:45 <Twey> I think apples have seeds.
18:30:48 <Twey> <3 oranges
18:31:18 <ivanm> Twey: I hate to tell you this, but oranges have seeds as well...
18:31:23 <aavogt> you could using NHC apparently
18:31:44 <Twey> ivanm: Not good old American GM oranges, how God intended them!
18:32:23 <ivanm> Twey: _right_ ...
18:32:40 <DigitalKiwi> <3 clementines
18:32:41 <Twey> Probably pomegranates vs. grapes or something would have been a better analogy, but then it misses the ‘apples vs. oranges’ idiom.
18:32:52 <Twey> (okay, GM grapes too)
18:33:14 <DigitalKiwi> since when does a defunkt car company produce fruits!? D:
18:33:20 <DigitalKiwi> defunct*
18:33:26 <Twey> Heh
18:33:37 <ivanm> Twey: grapes don't have to be GM to not be seedless
18:33:44 <ivanm> DigitalKiwi: which car company?
18:33:52 <DigitalKiwi> GM :P
18:34:01 <DigitalKiwi> or are they still around
18:34:13 <Twey> ivanm: Really?  How do they do it, then?
18:34:16 <idnar> DigitalKiwi: the main problem with python is that most of the stuff in the stdlib is garbage
18:34:19 <Twey> I thought it was selective breeding.
18:34:34 <idnar> DigitalKiwi: code quality tends to be inversely proportional to the number of stdlib imports
18:34:35 <dibblego> I can think of many more "main problems with python" than that
18:34:41 <ivanm> Twey: I believe they're infertile cross breeds
18:34:49 <DigitalKiwi> http://en.wikipedia.org/wiki/General_Motors <--
18:34:49 <ivanm> DigitalKiwi: oh, right; they're still around IIRC
18:35:00 <DigitalKiwi> did the government buy them?
18:35:01 <idnar> dibblego: well, in that context, anyhow :P
18:35:19 <Twey> ivanm: Hm, okay.
18:35:24 <ivanm> Twey: oh, you're going with the _proper_ definition of GM (which recognises that all domesticated animals, etc. are GM) as opposed to GE...
18:35:42 <Twey> I was, but WP says it's not proper at all.  ☺
18:36:03 <aavogt> General Electric?
18:36:05 <DigitalKiwi> now we have general electric doing breeding
18:36:07 <DigitalKiwi> aavogt: lol
18:36:22 <DigitalKiwi> and wordpress is giving us information!
18:36:33 <ivanm> aavogt: genetic engineering
18:36:43 <DigitalKiwi> what is GM then?
18:36:48 <dark> blackdog, DHH?
18:36:50 <ivanm> genetic modification
18:36:53 <aavogt> why not just call is recombinant dna?
18:37:02 <DigitalKiwi> what is the difference between GM and GE?
18:37:10 <ivanm> which it is arguable includes selective breeding
18:37:21 <aavogt> does it include haskell?
18:37:25 <DigitalKiwi> lmao
18:37:31 <DigitalKiwi> somehow yes...
18:37:38 <blackdog> dark: david heinemeier hansson - rails developer
18:38:09 <DigitalKiwi> RMS
18:38:14 <dark> blackdog, and what's his problem?
18:38:45 <dibblego> -- rails developer
18:38:53 <blackdog> dark: he tends to foster a very cocky, opinionated approach
18:39:29 <blackdog> quite happy to tell people to go fuck themselves
18:39:59 <DigitalKiwi> why do we call richard stallman "stallman", and "RMS", but linus torvalds "linus" (not torvalds), and certainly never "LBT"
18:40:17 <rado_> hello, i am learning haskell
18:40:22 <ivanm> DigitalKiwi: because there are a lot of richards, but not many linus'
18:40:24 <tensorpudding> Because his email was rms, I think.
18:40:27 <ivanm> rado_: yay!
18:40:28 <DigitalKiwi> rado_: go away we are talking about genetics
18:40:28 <aavogt> because you might confuse with haskellgbt
18:40:39 <tensorpudding> Also he might used it as a signature.
18:40:39 <blackdog> rado_: he's joking. having a problem?
18:41:04 <rado_> anyways, i am looking for code showing how to do oop in haskell
18:41:12 <Makoryu> rado_: Oh boy
18:41:13 <blackdog> rado_: ooh, bad news on that.
18:41:13 <rado_> or least the equivalent of oop
18:41:29 <Axman6> you don't want to do oop
18:41:32 <ivanm> rado_: you don't
18:41:33 <Makoryu> blackdog: Well, not entirely bad news
18:41:35 <rado_> cool, i dont like it
18:41:35 <blackdog> haskell can be a pretty decent imperative language, but OOP in haskell is just ugly
18:41:42 <ivanm> there _is_ OOHaskell and Timber, but anyway
18:41:45 <aavogt> @where oohaskell
18:41:45 <lambdabot> http://homepages.cwi.nl/~ralf/OOHaskell/
18:41:52 <rado_> but i want to look at some mid size code
18:41:59 <rado_> mid-size project
18:42:05 <rado_> how they do it without oop
18:42:08 <ivanm> rado_: in what sense?
18:42:11 <Axman6> timber is oop? i thought it was a real time programming language
18:42:12 <ivanm> rado_: because we use FP
18:42:14 <idnar> DigitalKiwi: "richard" is a far more common name than "linus", I guess
18:42:25 <ivanm> rado_: guess what, people managed to program before OOP was "discovered"
18:42:31 <blackdog> rado_: check out xmonad - it's pretty small, but does something serious
18:42:46 <rado_> i am saying oop for a lack of better word
18:42:49 <ivanm> blackdog: arguably, it isn't that good an example because its full of little discrete modules
18:42:53 <blackdog> and you'll see how to structure code better
18:42:53 <DigitalKiwi> the linux kernel is one of the most bloated pieces of software out there and is C! :P
18:42:57 <aavogt> ivanm: and people managed before basically everything was discovered though...
18:43:01 <Axman6> rado_: what are you actually looking for?
18:43:06 <ivanm> rado_: don't use the term "industrial" or "enterprise"...
18:43:12 <HugoDaniel> yeh
18:43:13 * blackdog just realises we're flooding the poor bastard
18:43:15 <ivanm> aavogt: managed to _program_
18:43:16 <rado_> nah, i am a hobbyist
18:43:20 <idnar> rado_: the things people mostly like about "OOP" don't actually have anything to do with objects or OOP at all
18:43:21 <HugoDaniel> why do you need OOP if you have haskell ?
18:43:23 <HugoDaniel> :P
18:43:28 <HugoDaniel> i really can't understand the need
18:43:32 <idnar> like encapsulation, polymorphism, etc.
18:43:32 <Axman6> aye
18:43:45 <rado_> i don't need oop, i want to see how haskell deals with the problems that oop supposedly solves
18:43:46 <DigitalKiwi> most things you write will be 20 times shorter than any other language anyway!
18:43:47 * ivanm tries to think of a good quality (wrt code quality) mid-sized haskell package
18:44:00 <Axman6> ghc?
18:44:00 <idnar> of course, if OOP is all you know, then it'll take a fair amount of getting used to programming in, say, Haskell
18:44:01 <rado_> for example encapsulation
18:44:02 <Axman6> darcs?
18:44:08 <blackdog> ivanm: why not xmonad? do you really want huge files?
18:44:16 <idnar> I'm not sure how accessible the GHC and Darcs codebases are
18:44:19 <rado_> i am guessing xmonad might be too big
18:44:23 <ivanm> blackdog: it's not really interconnected; that's why
18:44:25 <rado_> is there a small game or something
18:44:27 <blackdog> rado_: have you been through RWH?
18:44:27 <Axman6> Xmonad is quite small
18:44:29 <ivanm> Axman6: their documentation sucks
18:44:31 <aavogt> it's probably too small
18:44:35 <blackdog> ivanm: that's good haskell style, though.
18:44:42 <rado_> half-way through RWH
18:44:44 <ivanm> blackdog: true
18:44:46 <Makoryu> rado_: In fact, Xmonad is probably smaller than most of the Haskell games out there
18:44:46 <idnar> yeah, xmonad is relatively small
18:44:50 <rado_> oh ok
18:44:54 <ivanm> rado_: well, it covers how we do stuff
18:44:56 <blackdog> combinable parts, rather than interwoven dependencies
18:45:02 <idnar> I still haven't written anything more than Project Euler toys in Haskell :/
18:45:13 <ivanm> Makoryu: "most of": there aren't that many haskell games though, are there?
18:45:20 <rado_> yeah, i do project euler mostly too
18:45:42 <rado_> so I was curious about bigger projects, will take a look at xmonad
18:45:42 <idnar> I guess part of the problem is that I rarely write new software from the ground up
18:45:54 <Makoryu> ivanm: Probably half of them were written by increpare :p
18:45:56 <DigitalKiwi> 20:44 < blackdog> ivanm: that's good programming style, though.
18:46:06 <ivanm> Makoryu: heh
18:46:08 <idnar> I'm usually building on a dozen or so existing projects, typically in Python (which where I spend most of my time)
18:46:21 <idnar> *which is
18:46:22 <ivanm> blackdog: are you referring to xmonad or -contrib?
18:46:29 <blackdog> ivanm: xmonad
18:46:32 <ivanm> I thought you meant contrib, which is more a library than an actual decent project
18:46:33 <Axman6> rado_: http://www.haskell.org/haskellwiki/Xmonad/Guided_tour_of_the_xmonad_source
18:46:34 <blackdog> the contrib stuff is secondary in that sense
18:46:37 <ivanm> blackdog: in that case, nvm me ;-)
18:46:41 <idnar> I'm hoping something will come along that'll give me an opportunity to tackle it in Haskell
18:46:44 * ivanm leaves so he can actually go and do some non-computer-stuff for a while, and before he starts his anti-project-euler rant again
18:46:52 <Gwern-away> no one can refer to xmonad-contrib as small :)
18:47:01 <aavogt> or pretty!
18:47:08 <rafael> scotty: hello
18:47:13 <blackdog> idnar: i'm sort of kicking myself that i didn't try using haskell at work sooner
18:47:17 <scotty> hey
18:47:19 <blackdog> managed to use it for a load tester yesterday
18:47:22 <blackdog> worked like a charm
18:47:28 <idnar> project euler is kinda silly, but it's also kinda fun
18:47:36 <Gwern-away> even xmonad is at like 1700 lines now or something
18:47:37 <tensorpudding> And yet a great number of people use xmonad-contrib anyway.
18:47:39 <blackdog> ... in the sense that it left starling squealing on the floor, begging for mercy
18:47:48 <DigitalKiwi> ivanm: i've never heard your anti-project-euler rant!
18:47:52 <idnar> blackdog: my work code is all Python stuff
18:47:54 <DigitalKiwi> ivanm: i want to hear it!
18:48:01 <blackdog> idnar: and mine is all ruby
18:48:04 <idnar> blackdog: and it's hard to find an edge to slip Haskell in
18:48:09 <blackdog> but for testing tools you can use what you like
18:48:25 <ivanm> DigitalKiwi: put it this way; there's a reason I stopped listening to Haskelllove...
18:48:33 <idnar> blackdog: that's a purely technical difficulty, even; I'm the one making all the technology decisions, so I don't have to fight with anyone else to get Haskell in
18:48:40 <DigitalKiwi> ivanm: oh man i forgot about him
18:48:42 <tensorpudding> @quote euler complete
18:48:42 <lambdabot> No quotes for this person. I've seen penguins that can type better than that.
18:48:43 <Gwern-away> I wonder who suggested xmonad-contrib? I can't remember at all
18:49:04 <tensorpudding> @quote eulers
18:49:04 <lambdabot> lament says: <HaskellLove> Can eulers be solved in Prolog? <lament> HaskellLove: no <lament> prolog is not euler-complete
18:49:04 <ivanm> DigitalKiwi: he has a new nick; pokopoko222 or something IIRC
18:49:05 <aavogt> Gwern-away: it's existence?
18:49:08 <Gwern-away> aavogt: yes
18:49:22 <blackdog> idnar: sure. if other people have to work on it, it's a much bigger commitment
18:49:24 <Gwern-away> aavogt: it feels like my kind of suggestion, but I can't be sure
18:49:33 <aavogt> hehe
18:49:43 <ivanm> Gwern-away: I think because dons and sjanssen wanted xmonad to be a minimal WM that did just what they wanted
18:50:01 <DigitalKiwi> dons wrote xmonad?
18:50:08 <Gwern-away> DigitalKiwi: sjannsen started ot
18:50:21 <idnar> blackdog: even if it was just me, there's so much existing infrastructure (written in Python) that the project depends on, it's hard to find something I could write in Haskell that wouldn't involve reimplementing half the project in Haskell, or introducing painful artificial RPC interfaces
18:50:52 <DigitalKiwi> how big is the project?
18:51:00 <DigitalKiwi> half of a project is relative!
18:51:10 <idnar> DigitalKiwi: heh
18:51:13 <dark> idnar, it's sad to see how much software isn't interoperable those days
18:51:13 <blackdog> idnar: sure. you have to pick and choose your battles
18:51:32 <blackdog> but in modern web dev it's pretty common to have independent servers communicating over HTTP
18:51:41 <dark> i bed in the future, if you code something, it will be solved, and there will be no need of solving it again
18:51:43 <blackdog> and on the internet, no-one knows you're a lambda
18:52:12 <idnar> DigitalKiwi: the main codebase is 33k SLOC of Python
18:52:23 <idnar> DigitalKiwi: probably another 30k SLOC of JavaScript
18:52:28 <dark> software is interoperable in a loose sense (you can hook with some glue code, etc) but
18:53:03 <tensorpudding> There's .NET and JVM
18:53:13 <tensorpudding> They allow for code sharing on their platforms
18:53:16 <idnar> and probably another 50k SLOC of Python dependencies
18:53:20 <Gwern-away> hm. the first mailing mention of xmonadcontrib is by dons on 4/29/07. but we would have been discussing it in #xmonad before, I think
18:53:35 <idnar> dark: well, it's a trade-off
18:53:44 <dark> tensorpudding, yeah, but this is still limited IMO
18:53:50 <idnar> dark: to make some component "interoperable", you need to build stable interfaces around it
18:53:57 <DigitalKiwi> idnar: so like 1500 lines of haskell!
18:54:05 <DigitalKiwi> you can crank that out in a few days ;p
18:54:19 <idnar> dark: often the work involved in doing that isn't really worth it
18:54:23 <idnar> DigitalKiwi: hah
18:54:35 <dark> idnar, maybe because we aren't using the right tools for this work?
18:54:54 <blackdog> dark: I think you're being a bit optimistic
18:54:57 <idnar> dark: I think it's a fundamental limitation, but I guess I can't prove that
18:55:16 <blackdog> for instance, if i have a haskell program and i'd like to use some python functionality, i can't plug it in without knowing something about the types
18:55:35 <tensorpudding> Isn't Python extensible with C?
18:55:39 <DigitalKiwi> why would you do such a thing
18:55:40 <blackdog> so i at least need a glue layer which will throw an exception if python tries to hand me back a banana rather than an apple
18:55:51 <dark> this issue also happens with verified code. it's too much of a pain to write it, but it seems that we don't have the right tools for it. (it used to be like this with concurrent code, but this clearly improved)
18:55:51 <tensorpudding> I know there's Cython
18:55:54 <DigitalKiwi> aaaand we are back to fruits
18:56:01 <idnar> tensorpudding: Cython is just a C code generator
18:56:11 <tensorpudding> Oh, then what is that thing I'm thinking of...maybe pyrex?
18:56:13 <idnar> tensorpudding: but yes, CPython has a C API for writing extension modules
18:56:20 <strobedream> :t .
18:56:21 <lambdabot> parse error on input `.'
18:56:24 <DigitalKiwi> pypy is faster than cpython >.>
18:56:28 <strobedream> :t (.)
18:56:29 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:56:36 <idnar> tensorpudding: cython is a fork of pyrex, they both just take a Python-like input syntax, and emit C code that calls the Python C API
18:56:48 <idnar> blackdog: well, that goes in both directions
18:56:53 <tensorpudding> Okay, but that's still interoperability in some crude sense.
18:56:54 <blackdog> verified code has the same problem, yes - you need to prove global properties
18:56:57 <dark> blackdog, well, type inference changed a lot of things, i think that there is room for 'insights' in the places we have difficulties
18:57:12 <blackdog> and type inference is very global too
18:57:21 <idnar> blackdog: the DB library (it's sort of but not quite an ORM) we're using uses sqlite on the backend, but all of the schema definition happens in the Python code
18:57:22 <dark> type inference, formal definition of programming languages
18:58:13 <idnar> blackdog: so if you want to pass database objects over to Haskell code, or whatever, you'd need some way of translating the Python schema definitions into Haskell types
18:58:56 <fax> dark hm?
18:58:57 <idnar> really, to glue any two components together, you have to actually define and stabilize the interface
18:59:03 <blackdog> idnar: exactly. there's some impedance mismatching to be done
18:59:05 <dark> hi fax
18:59:14 <idnar> even if you're using a dynamically typed language, it's not like types suddenly don't matter
18:59:19 <blackdog> idnar: i'm trying to address this in hubris to some extent
18:59:26 <idnar> whether you have explicit type declarations or an implicit contract, you still have types
18:59:48 <blackdog> so you can automatically get an interface to a haskell lib from ruby with all the things that "make sense" in ruby land
18:59:57 <dark> blackdog, what is needed seems to be a meta-type system, that would make very different type systems interoperable. its unlimited form would probably not always converge, but in successful cases it could do a lot of things. [but yes, i don't know if this is actually possible]
19:00:03 <blackdog> but enforcing constraints that exist in the ruby side is much harder
19:00:25 <blackdog> dark: did i say you were optimistic before? What I meant was that you scare the crap out of me:)
19:00:31 <idnar> anyhow, I've been thinking about pushing some of our data into a Cassandra database as an optimisation, and that would probably be just as easily accessed from Haskell as from Python
19:00:56 <idnar> so I might take a crack at rewriting some of our reporting code in Haskell; it's probably the part of the codebase that most frequently makes me go "damn, I wish I was writing this in Haskell"
19:01:04 <blackdog> idnar: yeah, that sort of network interface basically demands serialisation anyway
19:01:21 <blackdog> i was using the memcache interface for the haskell load tester - worked fine
19:01:23 <dark> blackdog, :D [now explain to me what means 'scare the crap out of me', my english isn't very good]
19:01:39 <blackdog> dark: oh, I just mean that that's a huge, huge, huge project
19:01:54 <blackdog> even adding (static) types to a single dynamic language is hard
19:01:56 <idnar> there are significant portions of code there that are just begging for a refactoring, but Python just doesn't have the abstract power to do it properly
19:02:00 <blackdog> look what happened with erlang
19:02:20 <Kaid> isn't python trying to do that right now?
19:02:23 <blackdog> idnar: the sad thing about the stuff i'm working on at work is that ruby _does_ have the abstraction power, we just don't use it
19:02:30 <blackdog> it's like java in ruby
19:03:40 <idnar> blackdog: heh
19:04:11 <idnar> blackdog: at least good Python programmers seem to know that Python is bad
19:04:24 <dark> blackdog, yeeeah! when i talk about future, i don't say next decade, but next century. (yeah, i can't predict it.. just small talk)
19:04:48 <blackdog> dark: and you have to think about what you actually gain from this exercise
19:05:00 <dark> blackdog, i think the problem of interoperability will eventually be solved, it's too much of a constraint. (computing will surely change a lot, but i think it will converge into giving programmers more freedom for coding)
19:05:21 <DigitalKiwi> idnar: i don't see many of those
19:05:32 <DigitalKiwi> all i ever see is "zomg python is so awesome!"
19:05:41 <dark> the assembly->haskell path surely gave more programming freedom
19:05:55 <dark> (here putting haskell on the top)
19:06:01 <idnar> DigitalKiwi: yeah, well, those are probably the people using Python stdlib modules ;)
19:06:49 <blackdog> dark: but think about the dynamics of the system
19:06:51 <idnar> DigitalKiwi: I guess on the whole, Python sits in the sweet sopt between productivity and not being completely horrible
19:07:01 <blackdog> you have this wonderful type system that can incorporate all the current languages
19:07:22 <blackdog> then someone comes up with some wonderful abstraction that can't sit in the one type system to rule them all
19:07:30 <blackdog> do you think they're going to avoid writing a new language?
19:07:35 <idnar> DigitalKiwi: in the sense that there are a lot of Python programmers / libraries / whatever out thre, but it's not as awful as, say, C++
19:07:43 <DigitalKiwi> hehe
19:07:53 <DigitalKiwi> C4eva!
19:07:55 <idnar> that's not to say that you can't be productive in Haskell or Erlang or whatever, obviously, but it's a lot harder
19:08:22 * DigitalKiwi likes him some Lua
19:08:38 <dark> blackdog, of course not
19:09:40 <aavogt> blackdog: they are going to add -X flags like ghc :P
19:12:30 <siracusa> Is `cmd' a Haskell keyword with any language extensions enabled?
19:12:43 <monochrom> No.
19:21:06 <Gwern-away> @hoogle cmd
19:21:06 <lambdabot> Network.Socket data ShutdownCmd
19:21:30 <Gwern-away> is it just me or does this page repeat half way down? http://seoul.usembassy.gov/t_contract.html
19:21:33 <Gwern-away> searcg 'local family'
19:30:08 * hackagebot HDBC 2.2.5 - Haskell Database Connectivity  http://hackage.haskell.org/package/HDBC-2.2.5 (JohnGoerzen)
19:36:02 <dons> hdbc roxors
19:36:02 <lambdabot> dons: You have 3 new messages. '/msg lambdabot @messages' to read them.
19:36:08 <dons> '/msg lambdabot @messages
19:37:08 <blackdog> dons: through a combination of trickery and fast talking, i got paid for writing haskell yesterday. it felt pretty good.:)
19:38:36 <DigitalKiwi> blackdog: nice! :P
19:38:46 <DigitalKiwi> i wish i got paid to code :(
19:39:13 <blackdog> in other news, haskell is pretty damn good at load testing
19:56:16 * hackagebot HDBC 2.2.6 - Haskell Database Connectivity  http://hackage.haskell.org/package/HDBC-2.2.6 (JohnGoerzen)
19:57:23 <siracusa> What's wrong with this, the dialog shows up a second time if I press the OK button: http://dpaste.com/187123/
19:58:50 <siracusa> It's Gtk2Hs code btw.
20:07:15 <rafael> i know this will sound sorta stupib, but is there a debugger haskell?
20:07:22 <tensorpudding> ghci has a debugger
20:07:27 <tensorpudding> It's not really popular though.
20:07:29 <rafael> umm.
20:07:40 <rafael> thanks
20:08:03 <tensorpudding> Mostly because it's limited.
20:09:49 <rafael> i'm writing a parser for haskell with a friend, and we are having some problems with our lambda function
20:10:00 <rafael> it will compute (+ x 3)
20:10:13 <rafael> but it wont compute ( + x x)
20:14:01 <[swift]_> rafael: paste the problem code at hpaste.org and we might be able to help you
20:16:51 <Gwern-away> > let x = 3 in ( + 3 3)
20:16:52 <lambdabot>   Ambiguous type variable `t' in the constraint:
20:16:52 <lambdabot>    `GHC.Num.Num t' arising f...
20:17:09 <Gwern-away> huh. wasn't expecting that error
20:17:48 <Makoryu> Heh. If you see how it parses, it makes sense.
20:18:04 <Makoryu> :t 3 3
20:18:05 <lambdabot>     Ambiguous type variable `t' in the constraint:
20:18:05 <lambdabot>       `Num t' arising from the literal `3' at <interactive>:1:2
20:18:05 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
20:18:09 <dcoutts_> siracusa: use dialogRun or onResponse, not both. One is for synchronous use, the other for async.
20:18:24 <Makoryu> > let x = 3 in (+) x x
20:18:25 <lambdabot>   6
20:20:59 <rafael> thanks a lot
20:21:01 <rafael> i will try
20:21:13 <[swift]_> > let x = 3 in foldr (+) 0 $ replicate (2 * x) 1
20:21:14 <lambdabot>   6
20:21:23 <Makoryu> （　≖‿≖）
20:21:38 <rafael> yeah, they issue is that we are writing out own grammar
20:21:51 <rafael> and the code has to be generic
20:22:04 <siracusa> dcoutts_: But without onResponse the dialog cannot be closed when clicking on OK.
20:22:23 <siracusa> Err, wait
20:22:38 <rafael> my friend is telling me that we might be parsing the inputs wrongly
20:22:55 <dcoutts_> siracusa: clicking ok makes dialogRun return
20:23:20 <dcoutts_> siracusa: if you use the async pattern, then you'd use onResponse but not dialogRun
20:25:37 <siracusa> dcoutts_: Ok, it works now
20:26:41 <dons> blackdog: well done!
20:26:48 <dons> blackdog: now you can give a talk at CUFP :)
20:29:37 <blackdog> dons: heh. don't think a 1-hour load testing proggy really qualifies me for an international conference:)
20:29:56 <blackdog> but there's a certain schadenfreude in watching ruby programs wither under load
20:37:09 <CosmicRay> blackdog: just watch somebody try to upgrade a rails program
20:37:49 <blackdog> CosmicRay: heh. yes.
20:38:03 <blackdog> we're still on ruby 1.8.5 and rails 2.3
20:38:14 <CosmicRay> blackdog: I am still excited because I moved all of my repos from a redmine install on my server to github.
20:38:27 <CosmicRay> got to apt-get --purge remove ruby1.8 libruby1.8 rake etc....
20:38:46 <CosmicRay> i tell ya, even googlebot can bring my server to its knees with that thing
20:39:12 <CosmicRay> I can't imagine how twitter managed to make it work for so long
20:39:24 <blackdog> weirdly enough, the thing i was testing was starling
20:39:30 <blackdog> which was twitter's queue for a while
20:39:33 <blackdog> it is not terribly robust
20:39:48 <blackdog> i've started using rvm for ruby interpreters
20:40:53 <[swift]_> blackdog: i'm curious about the testing you're talking about. do you have a blog post about it or something?
20:40:57 <blackdog> still curious as to what went wrong - i hit "too many files open", even though i'd set ulimit -n. must have been some internal limit, i guess
20:41:04 <blackdog> [swift]_: no, I don't. maybe i should.
20:41:28 <blackdog> oh, but all the code's at work... i'll post it after the weekend.
20:41:41 <[swift]_> cool; i'd be interested to read about it
20:42:16 <blackdog> you're using starling? or you just want to see a haskell-ruby beatdown?
20:43:05 <idnar> blackdog: /proc/sys/fs/file-max maybe?
20:43:30 <[swift]_> mainly the beatdown, but it's not that i have anything against ruby; i'm mostly curious to hear _why_ ruby encountered problems
20:43:35 <ddarius> blackdog: No one ever tires of haskell-ruby beatdowns.
20:43:53 * djahandarie takes out his bat
20:45:39 <tensorpudding> I like ruby, I've written a few scripts in it.
20:46:08 <newsham> beatdown.rb.lhs?
20:46:16 <Makoryu> Ruby got me into Haskell
20:46:33 <tensorpudding> Admittedly, they are very simple scripts.
20:46:35 <Axman6> heh
20:46:43 <Axman6> @remember Makoryu Ruby got me into Haskell
20:46:43 <lambdabot> Done.
20:47:34 <newsham> ruby: the gateway drug
20:47:46 <scotty> Hey, can someone demonstrate, how I might insert multiple key-value pairs into a Data.Map from two lists which store the keys and values?
20:47:59 <Axman6> zip them together first
20:48:08 <scotty> Can you insert things as tuples?
20:48:15 <Axman6> > zip [1..] ["hello","world"]
20:48:16 <lambdabot>   [(1,"hello"),(2,"world")]
20:48:23 <Axman6> you should be able to
20:48:26 <scotty> Okay
20:48:46 <scotty> Then I need to use Prelude.map maybe?
20:48:48 <Axman6> @hoogle Data.Map.Map k a -> [(k,a)] -> Data.Map.Map k a
20:48:48 <lambdabot> Parse error:
20:48:48 <lambdabot>   --count=20 "Data.Map.Map k a -> [(k,a)] -> Data.Map.Map k a"
20:48:48 <lambdabot>                  ^
20:48:49 <dons> blackdog: we've done some nice load testing on haskell-impl. web apps at work
20:48:56 <dons> i wonder if we can publish the stats ...
20:49:01 <Axman6> @hoogle Map.Map k a -> [(k,a)] -> Map.Map k a
20:49:01 <dons> hmm. they're good.
20:49:02 <lambdabot> Parse error:
20:49:02 <lambdabot>   --count=20 "Map.Map k a -> [(k,a)] -> Map.Map k a"
20:49:02 <lambdabot>                 ^
20:49:08 <scotty> Or does Data.Map have a function to add lists of tuples into a map?
20:49:09 <dons> prob. not surprising, i guess.
20:49:09 <Axman6> @hoogle Map k a -> [(k,a)] -> Map k a
20:49:09 <lambdabot> Data.Array.IArray (//) :: (IArray a e, Ix i) => a i e -> [(i, e)] -> a i e
20:49:10 <lambdabot> Data.Graph.Inductive.Graph delEdges :: DynGraph gr => [Edge] -> gr a b -> gr a b
20:49:10 <lambdabot> Data.Array.IArray accum :: (IArray a e, Ix i) => (e -> e' -> e) -> a i e -> [(i, e')] -> a i e
20:49:14 <dons> concurrency + compiled + optimized
20:49:23 <scotty> Axman6: Awesome!
20:49:39 <tensorpudding> i don't see any there though
20:50:00 <Axman6> scotty: i haven't found the answer you want yet
20:50:07 <tensorpudding> @hoogle Map.Map k a -> (k,a) -> Map.Map k a
20:50:08 <lambdabot> Parse error:
20:50:08 <lambdabot>   --count=20 "Map.Map k a -> (k,a) -> Map.Map k a"
20:50:08 <lambdabot>                 ^
20:50:16 <tensorpudding> @hoogle Map k a -> (k,a) -> Map k a
20:50:16 <lambdabot> Data.Array.IArray (//) :: (IArray a e, Ix i) => a i e -> [(i, e)] -> a i e
20:50:16 <lambdabot> Data.Graph.Inductive.Graph delEdge :: DynGraph gr => Edge -> gr a b -> gr a b
20:50:16 <lambdabot> Data.Graph.Inductive.Graph insNode :: DynGraph gr => LNode a -> gr a b -> gr a b
20:50:20 <tensorpudding> meh
20:50:44 <tensorpudding> you could fold a list of pairs using Map.insert
20:50:46 <Cale> scotty: Data.Map.insert is what you're looking for
20:51:04 <Axman6> you could use fromList, and union or something
20:51:07 <Cale> yeah
20:51:34 <Cale> > M.fromList [(1,"Hello"),(2,"World)]
20:51:35 <lambdabot>   <no location info>:
20:51:35 <lambdabot>      lexical error in string/character literal at end o...
20:51:39 <Cale> > M.fromList [(1,"Hello"),(2,"World")]
20:51:40 <lambdabot>   fromList [(1,"Hello"),(2,"World")]
20:51:59 <Axman6> source level identity!
20:52:02 <tensorpudding> something like foldr1 (\(k,v) map -> insert k v map) myMap
20:52:34 <Axman6> shouldn't need to be foldr1
20:52:37 <newsham> > M.fromList (zip [1..] ['a'..'z']) M.! 17
20:52:38 <lambdabot>   'q'
20:52:44 <Cale> > M.union (M.fromList [(2,"There"),(3,"World")]) (M.fromList [(1,"Hello"),(2,"World")])
20:52:45 <lambdabot>   fromList [(1,"Hello"),(2,"There"),(3,"World")]
20:53:35 <tensorpudding> err, right
20:53:42 <tensorpudding> that won't work
20:54:27 <scotty> Cale: Thanks, I just discovered that after I left.
20:54:35 <tensorpudding> foldr (\(k,v) map -> insert k v map) myMap listOfPairs
20:54:52 <scotty> Cale: I misread what he said.  I thought there was an insert that took a list of tuples.
20:54:58 <newsham> foldr? I just met'r
20:55:09 <tensorpudding> doh
20:55:24 <aavogt> unions
20:55:36 <blackdog> dons: i'm not at all surprised. i did a bit of hacking with c10k and mighttpd at RailsCamp, and was getting some pretty decent numbers without too much work
20:55:46 <blackdog> dons: have to play with bos's event lib though
20:55:59 <blackdog> the 1024 file handles thing bites a bit
20:56:06 <aavogt> :(  no Text.Regex.PCRE on c.h.o
20:59:18 <tensorpudding> > Data.Map.assocs $ foldr (\(k,v) map -> Data.Map.insert k v map) Data.Map.empty [("haskell",1),("ocaml", 0)]
20:59:19 <lambdabot>   Not in scope: `Data.Map.assocs'Not in scope: `Data.Map.insert'Not in scope:...
20:59:25 <tensorpudding> oh darn
20:59:36 <Cale> Just use M.
20:59:52 <tensorpudding> > M.assocs $ foldr (\(k,v) map -> M.insert k v map) M.empty [("haskell",1),("ocaml", 0)]
20:59:53 <lambdabot>   [("haskell",1),("ocaml",0)]
21:01:30 <Dustin6> Hello?
21:01:37 <tensorpudding> hello
21:01:57 <Dustin6> Anybody here familiar with java? I was seeking some advice =/. Completely stuck - and yes, it's homework.
21:01:59 <Dustin6> lol
21:02:18 <tensorpudding> Afraid this is #haskell, ##java is another room.
21:02:26 <QtPlatypus> Dustin6: You relize this is a haskell channel don't you?
21:02:28 <Dustin6> No idea how I managed to join the wrong one =/ lol
21:02:59 <tensorpudding> I guess h is close to j on a qwerty keyboard
21:03:57 <monochrom> hi I need help with jashell homework
21:04:08 <tensorpudding> Not sure how you confuse #haskell for ##java.
21:04:08 <BlackM> lol
21:04:50 <dons> blackdog: yup.
21:04:57 <dons> haskell-event ftw
21:05:03 <dons> talk to tibbe for more infos
21:06:21 <newsham> at least he wasnt looking for help for his polysci homework
21:07:01 <tensorpudding> polysci?
21:07:06 <tensorpudding> Is that polymer science?
21:07:08 <blackdog> dons: shall do. i have three whole days of uninterrupted hacking ahead of me
21:07:17 <shapr> yay code!
21:07:22 <blackdog> god bless that great australian tradition of the carry-over holiday
21:07:35 <tensorpudding> lazy australians
21:07:50 <shapr> lol is not a period. It is not a way to end a sentence. In fact, it has no place in a sentence at all.
21:07:53 <shapr> NOT EVEN THAT SENTENC!
21:08:03 <BMeph> Tell me: am I just drunk on the Power of Haskell, or are FSM really not that much of a challenge to whip up here? :)
21:08:10 <tensorpudding> If lol is the first word in a sentence, are you required to capitalize it?
21:08:17 <blackdog> what're you talking about? the weekend is the only time i get to do any real work!
21:08:21 <shapr> tensorpudding: I can kick ban it.
21:08:40 <dons> BMeph: FSM?
21:08:46 <shapr> finite state machine?
21:08:49 <BMeph> tensorpudding: capatalizeing is 4 loZerz. speeling 2, lol
21:08:49 <tensorpudding> I think kickbanning poor English would make this channel less friendly
21:08:51 <blackdog> flying spaghetti monster, obviously
21:08:57 <shapr> tensorpudding: Hm, could be.
21:08:59 <monochrom> lazy australians, who don't do real work for 365-3 days a year.
21:09:03 <dons> federated search mashups?
21:09:05 <blackdog> can haskell make fun of religion?
21:09:11 * shapr shrugs
21:09:12 <BMeph> dons: What shapr guessed. :)
21:09:17 <shapr> blackdog: We make fun of people who like java.
21:09:20 <blackdog> monochrom: i can't win...
21:09:34 <shapr> blackdog: We make fun of people who like Ruby, because that's clearly a religion.
21:09:40 * shapr ducks
21:09:48 <tensorpudding> Java is a public, static and void religion.
21:09:51 <ddarius> BMeph: FSM aren't much trouble to whip up anywhere.
21:09:52 <monochrom> frequency shift modulation
21:09:55 <shapr> tensorpudding: hah
21:09:55 <blackdog> shapr: in fairness, the rubyists have taken to hubris more than the haskellers:)
21:09:57 <ddarius> BMeph: You can do them nicely in assembly.
21:10:01 <shapr> blackdog: ouch
21:10:20 <ddarius> blackdog: That just makes sense.
21:10:34 <tensorpudding> Is that a pun?
21:11:03 <blackdog> shapr: haskellers are maybe a little more given to fanboyism. rubyists in general are used to working on many-tiered systems
21:11:38 <blackdog> (and i say this as someone who went to RailsCamp and did 3 projects, each of them haskell reimplementations of ruby code)
21:11:57 <ddarius> blackdog: Haskellers are used to working in Java and C# (depending on whether they are students or industry.)
21:12:28 <blackdog> ddarius: sure. and even there, people are more inclined to go for the one-true-language approach
21:12:31 <blackdog> cf GWT
21:12:39 <BMeph> ddarius: So why are so many people asking "can you do that in Haskell" with them? For that matter, I'd imagine pushdown automata would be even more straightforward. It seems like it's as much challenge as an HP calculator simulation in Factor. :)
21:12:53 <blackdog> rubyists tend to be comfortable in CSS,javascript, html, sql...
21:13:14 <ddarius> BMeph: Actually, a HP calculator simulation would be -extremely- easy as well.  Possibly even easier.
21:13:32 <ddarius> blackdog: What professional programmer isn't comfortable with all of those?
21:14:01 <blackdog> ddarius: quite a few, i think
21:14:13 * BMeph coughs in a way that sounds suspiciously like *cough* Python! *cough*
21:14:27 <blackdog> segmentation into server and front-end programmers is relatively common. i know i didn't do much front end work for a very long time
21:15:06 <blackdog> anyway, i've clearly let shapr whip me up into a frothy rant:)
21:15:19 <shapr> haha
21:15:22 <ddarius> blackdog: Yeah shapr is a well-known troll here.
21:15:24 <shapr> Wasn't trying to bait you :-)
21:15:28 <shapr> Oh no!
21:15:54 <ddarius> @shapr
21:15:54 * lambdabot secretly deletes  source code
21:15:57 <ddarius> Hah
21:15:58 <shapr> aieee!
21:16:06 <shapr> @shapr shapr
21:16:06 <lambdabot> why on earth would I slap shapr?
21:16:10 <shapr> ?!
21:16:11 <lambdabot> Maybe you meant: . ? @ v
21:16:24 <shapr> Have I been special cased?
21:16:25 <ddarius> Oh lambdabot, you entertain me so.
21:16:39 <aavogt> @slap edit distance
21:16:39 * lambdabot puts on her slapping gloves, and slaps edit distance
21:16:44 <shapr> heh
21:16:56 <monochrom> This is by far the best mutation of @slap. None of my mutations beat it.
21:16:57 * BMeph wonders if anyone's given shapr a good spin and fluffed up his hair...
21:20:05 <shapr> BMeph: Not recently.
21:20:42 * hackagebot maid 2010.4.24 - A simple static web server  http://hackage.haskell.org/package/maid-2010.4.24 (JinjingWang)
21:21:36 <ddarius> Jinjing Wang is the crazy, redefine-(.) guy, no?
21:23:13 <BMeph> ddarius: Heh, heh, that's funny. As if there's just one person in the Haskell community who could be called "the crazy, redefine-(.) guy"... :)
21:23:33 <ddarius> (.) = flip ($)
21:24:43 * Axman6 thought Cale was the crazy redefine=(.) guy
21:24:46 <BMeph> Can you make operators using '#' without -XMagicHash? As in a di/trigraph?
21:24:47 <Axman6> -*
21:25:23 <ddarius> Axman6: No, his redefinition is somewhat annoying for lambdabot for didactic reasons, but is otherwise at least benign.
21:26:00 <aavogt> BMeph: it should be a regular operator character then
21:26:00 <Axman6> > show . "hello"
21:26:00 <BMeph> Axman6: I think it's more fun^Wfair to categorize Cale as "the crazy, redefine-*/g guy"
21:26:01 <lambdabot>   ["'h'","'e'","'l'","'l'","'o'"]
21:26:12 <monochrom> Yes you can use # in operator names.
21:26:15 <Axman6> BMeph: aye
21:26:23 <aavogt> magichash is for using it as a letter too
21:26:55 <ddarius> > let ( # ) = (+) in 3 # 4
21:26:56 <lambdabot>   7
21:27:23 <BMeph> Aah, that's...mildly disturbing. Thanks for the clari7n. ;)
21:27:54 <ddarius> There's absolutely nothing special about # unless you enable extensions.
21:35:33 <Axman6> > replicateM 3 [0,1,2]
21:35:34 <lambdabot>   [[0,0,0],[0,0,1],[0,0,2],[0,1,0],[0,1,1],[0,1,2],[0,2,0],[0,2,1],[0,2,2],[1...
21:35:41 <Axman6> > replicateM 2 [0,1,2]
21:35:42 <lambdabot>   [[0,0],[0,1],[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]
21:35:54 <Zeiris> I want GHCI to work in reverse polish notation.
21:36:15 <Axman6> write a reverse polish notation calculator
21:36:35 <Zeiris> Hm, although I guess currying might not work too well with that. Unless it only collapsed the stack if the types matched, and curried otherwise.
21:36:55 <Zeiris> Basically I want something as awesome as my Hp50g, but on the computer.
21:38:04 <tensorpudding> There are RPN calculators for the computer.
21:45:12 <mail> Who says I can't get stoned.
21:50:12 <Gracenotes> I'm not sure if people ever thought an on-screen button-filled calculator was actually a good interface design decision, compared to one which used a keyboard exclusively
21:50:41 <monochrom> People do think so, but the premise is touchscreen.
21:50:42 <Gracenotes> they probably did, otherwise there wouldn't be so many. And it is something people are familiar with after all.
21:51:08 <Gracenotes> it makes sense with touchscreen. with a mouse... meh.
22:06:48 <Zeiris> The mouse-driven button calculators are a tad insane, yeah. It might be nice to have something like Matlab/R/Mathematica/SciPy, but RPN-based, though.
22:07:25 <Zeiris> Although I suppose Excel's push-based updates are even better than RPN.
22:08:34 <tensorpudding> Emacs calc-mode is RPN, it's supposedly based on the HP-48
22:09:53 <Zeiris> I wonder if there's any good computation libraries available for Forth. I'll have to test the emacs thing.
22:11:23 <tensorpudding> It's complex and singular in its design, much like emacs itself
22:14:29 <Axman6> http://conway.rutgers.edu/~ccshan/wiki/blog/posts/Circularity/ is this just tying the knot in some other language?
22:15:13 <Makoryu> Is that lazy ML?
22:15:50 <Axman6> no idea
22:15:54 <Axman6> looks fugly though
22:16:05 <tessier> dons: I am often interested in the things you post to reddit.com/r/haskell/ but is there any way to make more than just the title appear in the rss feed? Is that something within your control or is that a reddit limitation?
22:16:14 <monochrom> caml or ocaml. see the "let rec".
22:16:27 <dons> mmm
22:16:36 <dons> tessier: its under reddit's control
22:16:45 <dons> i imagine they want you to click on the link :)
22:16:50 <tessier> Bummer. Often the titles are not very enlightening.
22:16:50 <Makoryu> monochrom: There's no "let rec" in other ML dialects?
22:16:58 <dons> you could write a tool to pull in more content though
22:17:05 <dons> i wonder if such a thing exists.
22:17:08 <tessier> Unfortunately with me it works the other way since I already have too much stuff in my rss feed as it is.
22:17:13 <tessier> If it isn't clearly interesting I skip it.
22:17:15 <dons> heh
22:17:56 * tessier currently has 621 unread items in his rss feed and is skimming for good stuff
22:18:59 <ddarius> tessier: Are you sure the "good stuff" is worth your effort of filtering for it?
22:19:12 <tessier> ddarius: No, I'm not.
22:21:11 <BMeph> Okasaki's version looked better, even if it's, what - 15 years old, now? :)
22:30:41 <rafael> hey ya'll, has any of you experience problems with whitespace/space while trying to code?
22:31:08 <rafael> today the most ridiculous thing has happened to me
22:31:37 <rafael> i can't type spaces, or else the code will break
22:31:42 <BMeph> Hmm, never mind; Okasaki's paper at least the one I was thinking of, is ten years old; Bird's one which has the structure/algorithm I was thinking of, is 25+ years old.
22:31:50 <Zao> rafael: Mixing spaces and tabs maybe?
22:32:12 <BMeph> rafael: Have you considered typing spaces, and not typing the tabs? ;)
22:32:20 <rafael> yeah
22:32:41 <rafael> BMeph: but even between words it's become a problem
22:33:04 <Zao> rafael: What "problem"?
22:33:11 <Zao> Compiler error, cat attack?
22:33:27 <rafael> like
22:33:51 <rafael> arg <- many1(identifier)
22:33:55 <rafael> arg <- many1 (identifier)
22:34:01 <rafael> the second one will break
22:34:12 <rafael> and the code won't compile
22:34:21 <Makoryu> Wut
22:34:58 <rafael> yep... it's pissing me off because initially i thought it was the text editor
22:35:03 <ddarius> It's a blight the gods put on you for using superfluous parentheses.
22:35:48 <Zao> rafael: With what errors?
22:36:05 <Zao> It's rather rare that GHC bails out with "your code is so ugly, I won't touch it, lol".
22:36:15 <rafael> lol
22:36:41 <rafael> i wrote it like that because it was the only way it accepted
22:37:25 <Makoryu> Are you sure you're not somehow typing nonbreaking spaces or something
22:37:53 <rafael> i don't know
22:38:01 <Cale> rafael: What editor are you using?
22:38:03 <BMeph> I'm'a gonna go with the mem-response: "pix, or it didn't happen!" ;)
22:38:07 <rafael> but i restarted the text editor and now it's working
22:38:37 <rafael> Cale: now gedit
22:38:44 <rafael> before was kate
22:39:18 <ddarius> Oh man.  If I had to "restart" my text editor to get it to handle basic editing correctly I would give up on programming and computers altogether.
22:39:29 <rafael> lol
22:39:39 <Cale> hehe
22:39:40 <rafael> i'm about to
22:39:57 <rafael> this is the first time this has happened to me
22:40:36 * ddarius isn't so sure he shouldn't give up on programming and computers anyway.
22:40:54 <Cale> rafael: gedit *ought* to work okay. Just make sure that the checkbox "Insert spaces instead of tabs" is checked in the preferences.
22:42:00 <BMeph> About that CC Shan-referenced paper: Why didn't they just use an imperative rep for a Zipper, and rebuild the tree from the zipper? Or am I reading too much into things... :)
22:42:01 <ddarius> Cale: If the example he gave above is accurate, I'm not sure there is any context where it could lead to an error if it was just a matter of space v. tab.-
22:42:03 <rafael> Cale: I just added it
22:42:29 <Cale> ddarius: Yeah, it doesn't seem likely that it was the problem in that case...
22:42:49 <ddarius> BMeph: The how was the goal, not the what.
22:43:08 <ddarius> I'm not sure anyone has ever actually wanted the repmin function.
22:43:11 <portnov> @pl \f y -> \x -> f x y
22:43:11 <lambdabot> flip
22:43:43 <BMeph> ddarius: <shrugs> That's fair.
22:44:09 <Saizan> i wonder if it'd still work with s/<Leaf future>/<Leaf !present>/
22:45:03 <ddarius> I'm pretty sure those are some kind of quasi-quotes and that there is also some kind phase distinction.
22:45:10 <Saizan> yeah
22:45:30 <Saizan> that's why i thought it'd work, all the writes should have happened when that code runs
22:45:44 <Saizan> though maybe there's some problem with making references cross stages
22:45:50 <ivanm> is everyone else getting delivery status notification messages on -cafe?
22:45:55 <ivanm> it's really starting to piss me off
22:47:17 <blackdog> ah, emacs tramp. how glad i am not to rely on you any more.
22:47:35 <newsham> without a computer, who will type check your programs, ddarius?
22:47:45 <ivanm> blackdog: why, what do you use now?
22:47:53 <blackdog> samba sharing
22:47:54 * ivanm _hates_ tramps; specifically how it interferes with ido
22:47:55 <blackdog> got too much
22:47:56 <ivanm> ahhh
22:48:03 <blackdog> ivanm: hm. maybe that was the problem
22:48:05 <blackdog> i heart ido
22:48:16 <blackdog> but i seemed to just get these hung sessions
22:48:18 <blackdog> i tried
22:48:19 <ivanm> yeah
22:48:28 <blackdog> sshing in manually, even turning ido off, and it just hung
22:48:38 <blackdog> (i mean, manual ssh worked fine)
22:48:52 <ddarius> newsham: Type checking is not necessary for the code I write.
22:50:28 <ivanm> ddarius: because you're perfect or because the code is that simplistic?
23:23:59 <AxleLonghorn> What should I do about this error message from GHC: "Ambiguous module name `Control.Monad.Identity': it was found in multiple packages: transformers-0.1.4.0 mtl-1.1.0.2"
23:25:33 <Saizan> AxleLonghorn: hide one, e.g. ghc-pkg hide transformers
23:29:32 <AxleLonghorn> Saizan: thank you
23:30:58 <ivanm> AxleLonghorn: if you use Cabal, it solves this for you
23:31:17 <ivanm> using a dirty hack in ghc, you can also specify which library you want; this is highly _not_ recommended however
23:32:16 <AxleLonghorn> why? I'm using the -hide-package flag.
23:33:54 <Saizan> -hide-package is fine
23:34:09 <[swift]> it seems like the builtin quasiquoters that template haskell uses aren't accessible, so I can't, say, reuse their parsing functions. is that correct or am I missing something?
23:34:45 <Saizan> that's correct
23:35:00 <[swift]> bummer, but thanks for confirming it for me =)
23:35:04 <Saizan> there's a package for doing that via haskell-src-exts on hackage though, haskell-src-meta
23:35:17 <Saizan> (and i guess you could whip up something with the ghc-api)
23:35:20 <[swift]> awesome!
23:36:28 <[swift]> thanks for pointing this stuff out; it looks like a great starting point
23:52:20 <Saizan> np
