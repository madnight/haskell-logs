00:00:19 <Twey> Er, you mean a
00:00:25 <Twey> ‘do let { a = x }; a’ desugars to ‘let a = x in a’
00:00:30 <Twey> Which is why it doesn't need a monad
00:01:00 <Pseudonym> Twey: Do you know what the report says the type rules should be?
00:01:09 <Pseudonym> That is, is it legal or not?
00:01:11 <Twey> For do-blocks?
00:01:14 <Pseudonym> Yeah.
00:01:23 <Twey> I don't think do-blocks have special type-rules
00:01:31 <Twey> They're just desugared and the result checked normally
00:01:51 <Twey> No reference for that, though
00:01:58 <Veinor> hm
00:02:08 <Pseudonym> Hugs> (do let { a = 5 }; a) :: Int
00:02:09 <Pseudonym> ERROR - Type error in type annotation
00:02:09 <Pseudonym> *** Term           : do {...}
00:02:09 <Pseudonym> *** Type           : a b
00:02:09 <Pseudonym> *** Does not match : Int
00:02:11 <Pseudonym> That's why I ask.
00:02:13 <Veinor> I think I can't use ` for my tmux prefix anymore
00:02:22 <Twey> Hm
00:02:25 <Veinor> because it messes with pasted haskell code
00:02:35 <Veinor> and... regular haskell coding too
00:02:55 <Pseudonym> Twey, sounds like you might have found a fault in the spec.
00:03:02 <Kaidelong> Is Notepad++ the most mature development environment on windows at this point?
00:03:37 <Twey> Or hugs… need to go to college, but I'll read up on it in class
00:03:47 <Twey> Kaidelong: emacs runs on Windows
00:04:01 <Kaidelong> Twey: looks like even the emacs extension is a bit buggy, though
00:04:02 <Cale> As does vim
00:21:38 <proqesi> Notepad is a development environment?  I thought it was just a text editor
00:24:15 <blueonyx> hi, what does parsec mean by "unexpected end of input, expecting end of input, "\n\r", "\r\n", "\r" or "\n""?
00:24:44 <Veinor> proqesi: notepad++ is not the same as notepad
00:24:55 <Veinor> it has actual features
00:25:03 <proqesi> Veinor: I'm aware of that, and I've seen both
00:25:09 <koala_man> blueonyx: it expected an end of line or file
00:25:31 <koala_man> wait
00:25:42 <blackdog> it's a bit of a baffling error message, hey:)
00:25:47 <blueonyx> :D
00:25:52 <koala_man> trippy
00:26:45 <proqesi> emacs otoh isn't a development environment, it's an OS
00:27:17 <blackdog> proqesi: if emacs is an OS, it should do better process management *grumpy*
00:27:26 <arw> since the day i've seen eclipse, i swore never to criticize emacs for bloat...
00:27:40 <proqesi> blackdog: well it's starting to show its age
00:28:08 <blackdog> arw: yeah, emacs is pretty trim, considering
00:28:24 <blackdog> but you want an emacs built on the chrome model, really
00:28:31 <blackdog> i think ManateeLazyCat was working on something similar
00:28:48 <Veinor> I dislike how slow emacs can be to start up sometimes
00:29:40 <blackdog> Veinor: you start emacs up more than once a month?
00:29:45 <proqesi> someone should make a mode that shows a progress bar and says "booting Emacs OS"
00:30:17 <Veinor> blackdog: true.
00:30:46 <Veinor> I remember reading about an emacs script that let you do arbitrary key chords for commands
00:31:06 <Veinor> so like, pressing asdf all at once could select the entire document
00:31:30 <blackdog> hm. that'd be tricky
00:31:39 <blackdog> you'd need to register every key to a timeout or something
00:31:48 <proqesi> would that be any easier that C-x h?
00:32:24 <Veinor> http://www.emacswiki.org/emacs/key-chord.el
00:32:41 <Veinor> proqesi: I was just picking a random example :P
00:34:09 <Cale> http://thedailywtf.com/Articles/Poke-a-Dot.aspx -- lol
00:34:13 <blueonyx> is there a way to stop endBy till eof?
00:34:28 <blueonyx> *before eof
00:40:45 * hackagebot Mhailist 0.0 - Haskell mailing list manager  http://hackage.haskell.org/package/Mhailist-0.0 (LarsKotthoff)
00:47:44 <Axman6> TacticalGrace: did you get any interest from people about AusHac?
00:56:23 <Axman6> the one thing i really miss in haskell: the ability to define numeric types with arbitrary min and max bounds.
00:57:49 * Axman6 really wants a number type that is 0-31, without having to write data ThirtyTwo = Zero | One | Two | Three | ... | ThirtyOne
00:58:17 <ManateeLazyCat> If anyone interested GIO and want try to use new APIs, access https://patch-tag.com/r/AndyStewart/gio-branch/home
00:58:20 <ManateeLazyCat> Any patches are welcome.
00:59:35 <ManateeLazyCat> Note: https://patch-tag.com/r/AndyStewart/gio-branch just temporary repository for gio branch, i will merge this branch to gtk2hs main repo when Axel have time to review those code.
01:00:57 <ManateeLazyCat> After install `glib` and `gtk` package from gtk2hs darcs repository, then install gio by "cabal install".
01:01:25 <Saizan> Axman6: newtype Bounded min max = B Int and smart constructors?
01:01:56 <Axman6> i'd rather have a nice compiler checked version
01:02:16 <Saizan> that entirely depends on the methods you expose :)
01:02:37 <ManateeLazyCat>  Currently, gio binding is un-complete, I plan to finish gio binding in this week, any suggestions and patches are welcome. :)
01:02:42 <Saizan> s/methods/API/
01:03:43 <Saizan> though it's true that you can't statically check constants
01:04:39 <Axman6> Ada has a nice feature where you can specify value ranges for your own types
01:05:23 <ManateeLazyCat> If any emacser want to help me binding gio, use my gtk2hs extension (http://www.emacswiki.org/emacs/gtk2hs.el) to transform documentation automatically, ApiGen can't works with gio library now.
01:37:38 <cizra> gahh
01:37:47 * cizra can't figure out the use of monadic environments
01:38:19 <Botje> is that terminology?
01:38:31 <Botje> or can you show what you're struggling with
01:38:50 <cizra> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25236#a25236 --
01:39:14 <cizra> I'm following the "write yourself a Scheme", trying to do the exercises
01:39:26 <cizra> The task was to extend Lisp strings to allow \" inside.
01:40:05 <Botje> ah
01:40:36 <cizra> Does this listifying only work with non-monadic stuff? That can't be
01:40:50 <Botje> return [...] looks very suspect
01:41:04 <cizra> yea, it's the line generating the error
01:41:14 <cizra> Basically, the problem is that a non-" is a character,
01:41:19 <cizra> but \" is a string
01:41:28 <Botje> yeah
01:41:46 <Botje> i'm checking the parsec docs
01:41:59 <Botje> iirc you can do string "\\\"" to match a literal \"
01:42:35 <Botje> yeah.
01:42:48 <cizra> uh
01:43:10 <cizra> But the problem is not in matching \", but in making the char into a one-char string?
01:43:20 <Botje> you don't have to
01:43:33 <Botje> you can do string "\\\"" >> return '"'
01:44:06 <Botje> so you match \", and if it matches, return a single char "
01:44:12 <cizra> Oh, hm.
01:44:26 <cizra> Now to think about it, it's really what I want :-D
01:45:12 <Botje> so the end result should be something like many (string "\\\"" >> return '"' <|> noneOf "\"")
01:45:50 <Botje> however, you'll still get an error on \n, for example.
01:45:57 <Botje> wait
01:46:00 <Botje> no, you won't :D
01:46:28 <Botje> do you see how the string function and the >> work together?
01:46:33 <mauke> did you mean: noneOf "\"\\"
01:47:22 <mauke> many ((char '\\' >> anyChar) <|> noneOf "\"\\")
01:47:33 <Botje> pah, that's advanced :P
01:47:45 <Botje> also, that will fold "\\n" into "n"
01:47:50 <mauke> yes
01:47:55 <mauke> isn't that what lisp does?
01:48:03 <Botje> (and i think it's one of the next assignments for scheme in 48h)
01:48:40 <Botje> scheme interprets "\n"
01:48:59 <Botje> but lisp throws the \ away, yeah
01:49:16 <cizra> uh
01:49:28 * cizra tries
01:51:01 <cizra> \o/ It works, it's understandable.. what else can you want.
01:51:17 <Botje> cizra++ # learning!
01:51:33 <cizra> By the way, how to rewrite that >> into do-notation? The thing that troubles me is <|>
01:51:45 <cizra> Do I have to make a function for the do-block, then <|> it with noneOf?
01:51:55 <Botje> is it complaining?
01:51:58 <mauke> (do char '\\'; anyChar) <|> noneOf "\"\\"
01:52:10 <Botje> you can just put parens around the string >> return or char >> anyChar
01:52:22 <cizra> oh, no
01:52:25 <cizra> I'm just curious.
01:53:30 <cizra> Botje: I've been learning Haskell for ages.. I'm pretty comfortable around basic pure functional stuff. The real world is what frightens me :-D
01:53:40 <Cale> cizra: The translation rules for do-notation are:
01:53:50 <Cale> do { x } = x  (base case)
01:54:08 <Cale> do { x ; <stmts> } = x >> do { <stmts> }
01:54:15 <Cale> do { v <- x ; <stmts> } = x >>= \v -> do { <stmts> }
01:54:31 <Cale> do { let { <decls> } ; <stmts> } = let { <decls> } in do { <stmts> }
01:55:02 <cizra> Cale: Thanks
01:58:45 <monadic_kid> is the version of cabal install on hackage has support for cabal init?
02:01:51 <Jafet> http://codepad.org/BgfupqFg (needs http://unicode.org/Public/UNIDATA/UnicodeData.txt)
02:32:49 <kamatsu> monadic_kid: cabal is the program that has cabal init, not cabal install
02:33:22 <kamatsu> and, i believe the cabal on hackage does support cabal init
02:33:44 <dcoutts> cabal-install version 0.8 and later, yes
02:33:45 <lambdabot> dcoutts: You have 2 new messages. '/msg lambdabot @messages' to read them.
02:35:26 <monadic_kid> one of you says cabal and the other says cabal-install
02:37:28 <Saizan> "cabal" is the name of the executable, "cabal-install" is the package containing it
02:37:32 <dcoutts> monadic_kid: the package name is cabal-install, the command line program that supplies is 'cabal'
02:37:44 <Saizan> "Cabal" is the name of the library :)
02:37:48 <dcoutts> monadic_kid: the unfortunate naming is because there was already the library package called Cabal
02:38:14 <dcoutts> so we write: cabal install Cabal cabal-install :-)
02:38:21 <dcoutts> and everyone is confused :-)
02:38:31 <monadic_kid> I installed the hackage version of cabal-install but cabal init wasn't there, anyways i've just installed hackage version of cabal
02:39:03 <monadic_kid> I'm not using the latest version of ghc or haskell platform
02:39:08 <dcoutts> monadic_kid: you need the latest version (which isn't yet the default version): cabal install 'cabal-install >= 0.8'
02:39:42 <dcoutts> monadic_kid: the cabal init feature is in the 0.8.x release, the default version is still 0.6.x however
02:40:04 <dcoutts> though that's going to change shortly because I'm happy that 0.8.x is now sufficiently stable
02:40:21 <monadic_kid> dcutts: cool, getting it now
02:40:26 <monadic_kid> dcutts: thanks
02:40:26 <dcoutts> monadic_kid: clear as mud? :-)
02:41:13 <monadic_kid> dcutts: are the guy who writes the blogs Brent -> [String]?
02:41:38 <dcoutts> monadic_kid: no
02:41:42 <monadic_kid> k
02:42:06 * dcoutts blogs at blog.well-typed.com
02:43:48 <monadic_kid> dcutts: when you're asked for which license do I type in the number or license name?
02:45:47 <dcoutts> monadic_kid: the number I think
02:47:28 <monadic_kid> dcoutts: for the project category you can't put in more than one category?
02:47:48 <dcoutts> monadic_kid: you can, edit the .cabal file after running cabal init
02:48:01 <monadic_kid> dcoutts: I guess :P
03:01:04 <Jonno_FTW> how can I have the words function but have a comma delimiter?
03:02:17 <Twey> Can't
03:02:28 <Twey> See the Data.List.Split module from the split package on Hackage
03:06:13 <monadic_kid> Jonno_FTW: intercalate
03:07:08 <monadic_kid> > intercalate "," ["foo", "bar"]
03:07:09 <lambdabot>   "foo,bar"
03:07:19 <Jafet> intersperse is sort of the inverse.
03:07:35 <Jafet> intercalate is unrelated.
03:08:01 <Twey> monadic_kid: words, not unwords
03:08:27 <Jafet> Don't need a whole module, it's a one-liner
03:11:23 <ManateeLazyCat> Have similar libraries as http://library.gnome.org/devel/gio/unstable/networking.html in hackage?
03:11:38 <ManateeLazyCat> I'm binding GIO, and found GIO have those libraries.
03:11:53 <quicksilver> ManateeLazyCat: well, most of that functionality is in Network or Network.Socket
03:11:59 <quicksilver> not the FDList stuff though
03:12:06 <ManateeLazyCat> And i won't binding those libraries if them can't found in hackage.
03:12:23 <ManateeLazyCat> s/can't/can
03:13:22 <ManateeLazyCat> quicksilver: Have any other library except FDList, if those no exist libraries is useful, i will binding it.
03:14:17 <quicksilver> It looks to me like FDLIst is intended to do accept()-style stuff, and that's handled by GHC's IO manager.
03:14:27 <quicksilver> the other stuff looks like it overlaps with Network.Socket
03:14:34 <quicksilver> but I haven't looked deeply.
03:15:37 <ManateeLazyCat> quicksilver: I don't know whether Network stuff support unicode well.
03:15:53 <quicksilver> irrelevant.
03:15:58 <quicksilver> Network stuff pushes bytes around.
03:16:10 <quicksilver> it's up to you what you put in the bytes
03:16:17 <quicksilver> you may chose to encode some text there if you wish.
03:16:58 <ManateeLazyCat> quicksilver: Okay, thanks, i won't binding those libraries, include GUnixFDList, because it's just for Unix platform.
03:17:41 <ManateeLazyCat> quicksilver: BTW, i found some functions in System.Directory and System.FilePath can't support unicode, i plan to use GIO functions replace them.
03:18:14 <quicksilver> yes
03:18:22 <quicksilver> because the reality is rather ugly
03:18:37 <quicksilver> platforms do weird and inconsistent things with the way they use encodings for filenames
03:18:45 <quicksilver> I remember JaffaCake discussing it
03:18:47 <ManateeLazyCat> quicksilver: Example, doesFileExist and doesDirectoryExist not support unicode.
03:19:03 <quicksilver> well you can make it work
03:19:11 <quicksilver> but it's ahrd to make it platform independent.
03:19:22 <ManateeLazyCat> quicksilver: And `System` stuff just handle String, and it's trouble, i always need decode and encode it.
03:19:25 <quicksilver> yes
03:19:26 <JaffaCake> ManateeLazyCat: what platform?
03:19:39 <ManateeLazyCat> quicksilver: Yes, that's why i choose GIO, it's cross-platform.
03:19:48 <quicksilver> systems / filesystems have historically not been clear on what encoding is used for filenames.
03:19:57 <quicksilver> on unix it's 'really' just bytes
03:20:02 <ManateeLazyCat> quicksilver: Yes.
03:20:06 <quicksilver> but by gnome convention, those bytes are considered UTF8?
03:20:08 <quicksilver> I think.
03:20:17 <quicksilver> On Win32, I believe, they are UTF16?
03:20:27 <Jafet> Or UCS-2.
03:20:35 <ManateeLazyCat> quicksilver: Because GIO use GFile wrap those information, so you can handle those file and don't need decode/encode.
03:20:38 <Jafet> (Flip a coin...)
03:20:47 <quicksilver> Jafet: it landed on its edge.
03:20:48 <ManateeLazyCat> quicksilver: And platform detail is hidden by GIO>
03:21:31 <Twey> Jafet: It is, but it's useful to standardise
03:21:44 <Twey> Also, Data.List.Split does clever performance tricks
03:21:56 <JaffaCake> ManateeLazyCat: System.Directory should be all Unicode on Windows, but on Unix it's still strip-the-upper-bits
03:22:13 <ManateeLazyCat> quicksilver: After i binding GIO and test complete, i will try to persuade people use GIO instead System.Directory and System.FilePath.
03:22:30 <ManateeLazyCat> JaffaCake: Yes, I use Linux, some function in System.Directory can't work.
03:22:39 <quicksilver> it would be better if we had a fixed System.Directory
03:22:56 <JaffaCake> ManateeLazyCat: you'll need to use utf8-string or something
03:23:19 <ManateeLazyCat> JaffaCake: But problem, i need do many decode/encode work.
03:23:49 <ManateeLazyCat> JaffaCake: Yes, i know utf-string can work, but for other coding? I'm developing file-manager and editor.
03:24:09 <JaffaCake> there's an iconv binding that uses bytestrings
03:24:18 <JaffaCake> cabal install iconv
03:24:45 <JaffaCake> or you could hook up to the encoders in GHC.IO.Encoding somehow
03:24:46 <ManateeLazyCat> JaffaCake: Well, perhaps that's works, but i think use GIO binding is simpler.
03:24:59 <JaffaCake> it probably is, yes
03:25:20 <dcoutts> JaffaCake: speaking of which, we have a problem with unicode and passing command line parameters on windows
03:25:29 <adamdunkley> Hi all. I'm using abstract monads MonadState & MonadWriter, but I want to call functions that use MonadReader & MonadWriter (where the reader environment is the old state). Any ideas on how to acheive this?
03:25:39 <ManateeLazyCat> JaffaCake: I GIO binding, you don't need handle those decode/encode, just need call it's APIs.
03:25:45 <ManateeLazyCat> s/I/In
03:25:50 <dcoutts> JaffaCake: the [String] args to the process get done as 8-bit it looks like
03:26:10 <dcoutts> that, or something else weird is going on
03:26:12 <JaffaCake> dcoutts: yes, I saw a ticket for that go past I think
03:26:25 <dcoutts> JaffaCake: certainly a couple filed against Cabal
03:26:41 <JaffaCake> not clear what to do on Unix
03:26:44 <ManateeLazyCat> quicksilver: Have similar libraries as http://library.gnome.org/devel/gio/unstable/resolver.html in hackage? Thanks.
03:27:11 <ManateeLazyCat> quicksilver: I want filter duplicate libraries before binding them.
03:27:34 <dcoutts> JaffaCake: I think there it's not so bad since the raw utf8 bytes will be passed through from getHomeDir to process [String] flags
03:28:22 <JaffaCake> dcoutts: right, we better make sure we don't fix just one of those :)
03:28:26 <dcoutts> JaffaCake: the problem there is we cannot in general display them
03:28:49 <Jafet> adamdunkley, you want the state to persist?
03:29:01 <ManateeLazyCat> quicksilver: Have same libraries as http://library.gnome.org/devel/gio/unstable/highlevel-socket.html ?
03:30:22 <adamdunkley> Jafet: Yes, in the reader monad (think of it as a "readonly" function) allowing a function that uses the reader monad to be called from one that is decorated with the state monad carrying the state
03:30:55 <ManateeLazyCat> dcoutts: I agree, i use utf-string with System sutff handle file attribute, too many transform and trick, logic is disorder.
03:31:05 <adamdunkley> I can construct "readonly" when not using abstract monads (just using non transformer State and Writer)
03:31:11 <adamdunkley> State and Reader*
03:31:19 <Jafet> Sounds like you want transformers, then
03:33:15 <adamdunkley> How do abstract monads differ from monad transformers?
03:33:45 <adamdunkley> Sorry, to solve another problem... I was told it would be easier to use abstract monads (which have helped to clean up my types a lot)
03:35:08 <ManateeLazyCat> dcoutts: Can you talk look http://library.gnome.org/devel/gio/unstable/ ? Those binding looks unnecessary for Haskell: network, dns, streaming I/O
03:35:16 <ManateeLazyCat> s/talk/take
03:35:28 <dullard> Newbie here, how do I make a function where arguments of ["bcd","efg"] and 'a' give a result of ["abcd","efg"]?
03:35:34 <Peaker> What are "abstract monads"?
03:35:39 <dcoutts> ManateeLazyCat: I agree
03:36:06 <ManateeLazyCat> dcoutts: Thanks, i binding rest libraries.
03:36:07 <Peaker> dullard, I'd define:  atHead f [] = [] ; atHead f (x:xs) = f x : xs
03:36:30 <Peaker> dullard, then I'd say:  prependHead x xs = atHead (x:) xs
03:36:41 <Peaker> @let atHead f [] = [] ; atHead f (x:xs) = f x : xs
03:36:42 <lambdabot>  Defined.
03:36:45 <adamdunkley> Peaker: I thought they were just monad transformers, they're applied like: (MonadState s m, MonadWriter [l] m) => Int -> m ()
03:36:46 <ManateeLazyCat> dcoutts: I have finish some stuff at https://patch-tag.com/r/AndyStewart/gio-branch , you can try to use it if you have time. :)
03:36:48 <Peaker> @let prependHead x xs = atHead (x:) xs
03:36:49 <lambdabot>  Defined.
03:37:05 <Peaker> > prependHead 'a' ["bcd", "efg"]
03:37:07 <lambdabot>   ["abcd","efg"]
03:37:13 <dullard> thanks Peaker, let me scratch my chin
03:37:39 <Peaker> dullard, "atHead" applies a given function only at the head element.  (x:) prepends x.  Applying (x:) at the head, prepends it only to the first element
03:38:47 <Peaker> @hlint f x = x
03:38:47 <lambdabot> No module "f x = x" loaded
03:38:58 <Peaker> @hlint Control.Monad
03:38:58 <lambdabot> No module "Control.Monad" loaded
03:39:00 <dullard> Brill
03:39:52 <Peaker> @wn Brill
03:39:54 <lambdabot> *** "brill" wn "WordNet (r) 2.0"
03:39:54 <lambdabot> brill
03:39:54 <lambdabot>      n : European food fish [syn: {Scophthalmus rhombus}]
03:40:18 <dullard> :D short for brilliant
03:40:45 <ManateeLazyCat> @wn Manatee
03:40:46 <lambdabot> *** "manatee" wn "WordNet (r) 2.0"
03:40:46 <lambdabot> manatee
03:40:46 <lambdabot>      n : sirenian mammal of tropical coastal waters of America; the
03:40:46 <lambdabot>          flat tail is rounded [syn: {Trichechus manatus}]
03:40:56 <ManateeLazyCat> :)
03:41:17 <Jafet> @urbandict brill
03:41:18 <lambdabot> Unknown command, try @list
03:41:49 <bastl> to generate html, what is the most stable package? hakyll looks nice but is very young ... Can it be used for dynamic pages ?
03:42:29 <adamdunkley> hakyll is entirely static
03:42:58 <blackdog> bastl: there isn't a clear favourite yet, i think. hamlet is interesting - haml for haskell, basicallyy
03:43:15 <blackdog> and there's BlazeHtml - set of very fast html combinators
03:43:48 <bastl> hm. i ask for stability and get something at versio 0.0.0 :-)
03:44:28 <quicksilver> the xhtml is more conservative in design
03:44:32 <Jafet> I wonder what the mean version of hackage libraries is
03:44:41 <quicksilver> and quite a lot slower, but then performance only matters when it matters.
03:44:44 <blackdog> bastl: heh. sorry, missed that bit. there are older packages, i just like the shiny.
03:45:15 <Entroacceptor> I've seen HSP in use
03:46:07 <Entroacceptor> (otherwise I don't really like creating html, I like filling in templates)
03:46:52 <bastl> Entroacceptor: right. templates are good. that's why I looked at hakyll
03:47:58 <Entroacceptor> and I've come across hStringTemplate
03:48:06 <Entroacceptor> which is some kind of port from java
03:48:58 <bastl> yes, i used that already. But I need something easy to use for a longer term. I'll try out hakyll first
03:48:59 <adamdunkley> bastl: For stability, I would look at xhtml; templates == functions which fill in holes in the xhtml datatype you form, surely?
03:49:35 <bastl> adam. ok. that's true. but write a page in that way with only a few holes ?
03:51:02 <blackdog> bastl: why not?
03:51:06 <adamdunkley> bastl: You're going to have the same amount of holes no matter what solution you use, surely? (each hole == data)
03:51:14 <bastl> blackdog: hard to maintain.
03:51:19 <blackdog> there are some quoting things you'd lose, I suppose
03:51:48 <blackdog> bastl: what sort of templates do you want, exactly? is it just string interpolation?
03:51:51 <adamdunkley> Use higher order functions etc to abstract various parts of the xhtml 'templates', and you don't have a maintenance issue
03:52:34 <blackdog> adamdunkley: it is a different style of solution, though. frequently you want to pass templates to designers in a form they can edit, which is where the combinator approach loses
03:52:56 <blackdog> and yes, it'd be lovely if they could do everything with CSS, but it's not always possible
03:53:10 <whald> does anyone know about a fast prng besides the one in System.Random.Mersenne (unfortunately I can't use that one because it lives in the IO monad)
03:53:13 <bastl> adam. hmm. still, editing the static html is harder with combinators.
03:53:34 <Jafet> whald, what's wrong with the default?
03:53:37 <bastl> anyway. thanks so long.
03:53:55 <blackdog> whald: bos wrote about it a while ago, i think
03:54:02 <blackdog> http://www.serpentine.com/blog/2009/09/19/a-new-pseudo-random-number-generator-for-haskell/
03:54:29 <whald> in my program it's responsible for 16% cpu time and 23% of all allocations
03:54:32 <blackdog> and it runs in the ST monad
03:54:32 <adamdunkley> blackdog: I concede that point, designers should learn haskell... our lives would be a lot simpler
03:54:40 <blackdog> adamdunkley: ha
03:54:41 <blackdog> :)
03:54:55 <Jafet> Note that L'Ecuyer's is persistent; I doubt Marsaglia designs for that
03:54:59 <blackdog> whald: check out the statistics library
03:55:04 <monadic_kid> I have a cabal file but runhaskell can't find SDL packages even though I do them installed
03:55:36 <dcoutts> monadic_kid: try 'cabal' instead of "runhaskell" they have different defaults (see the FAQ)
03:56:50 <whald> blackdog: yeah, the blog post makes me think the statistics package has some stuff worth trying, thanks!
03:57:06 * blackdog is in that weird hinterland where you don't have enough mental energy to hack on real problems but isn't tired enough for bed. hence, dicking around with elisp and hanging out on #haskell...
03:57:38 <Jafet> You've just described my default mode of life
03:58:00 <monadic_kid> dcoutts: I just had to use --user flag to get it working
03:58:33 <blackdog> Jafet: github is good for times like this. you can hack on someone else's code, offer up a fork and walk away...
04:00:00 <dcoutts> monadic_kid: yes, that's the main difference between the cabal program and runghc Setup, that different default.
04:00:09 <Jafet> If I wanted any hope of getting people to use my patches, I would have gone into the nicotine industry
04:00:16 <dcoutts> monadic_kid: since you've got the cabal program, there's no need to use runghc Setup.hs at all.
04:00:27 <dcoutts> monadic_kid: it just confuses to use both :-)
04:00:45 <Oejet> Jafet: Heh.
04:00:55 <blackdog> Jafet: i _know_ you're trolling for a @remember there:)
04:01:18 <blackdog> @remember Jafet: If I wanted any hope of getting people to use my patches, I would have gone into the  nicotine industry
04:01:19 <lambdabot> Nice!
04:01:46 <Jafet> But ah! forget my fate
04:02:50 <dancor> has anyone used monadiccp?  when in examples/ i do "ghci Queens.hs" and (:m + Control.CP.ComposableTransformers Control.CP.FD.Solvers Control.CP.FD.OvertonFD.Sugar), on (solve dfs (nb 100 :- db 25 :- bb newBound) $ nqueens 4) it says "Not in scope: data constructor `:-'"
04:03:25 <Jafet> That code looks like it thinks :- is an operator
04:03:32 <Entroacceptor> @help remember
04:03:32 <lambdabot> quote <nick>
04:03:32 <lambdabot> remember <nick> <quote>
04:03:32 <lambdabot> Quote somebody, a random person, or save a memorable quote
04:04:02 <dancor> Jafet: the line (solve dfs (nb 100 :- db 25 :- bb newBound) $ nqueens 4) is from http://tomschrijvers.blogspot.com/2009/01/monadic-constraint-programming.html
04:04:09 <dancor> maybe the format changed in the code..
04:04:16 <blackdog> oops, I just credited that bastard Jafet: with the estimable Jafet's quote
04:05:06 <dancor> but ':-' is defined in Control.CP.ComposableTransformers.hs as (data Composition es ts solver a where (:-) :: ...)
04:05:50 <Jafet> @forget Jafet: If I wanted any hope of getting people to use my patches, I would have gone into the  nicotine industry
04:05:50 <lambdabot> Done.
04:11:33 <cizra> hpaste is down?
04:11:38 <cizra> 500 Internal Server Error
04:11:39 <cizra> 58030 5: database is locked
04:14:38 <dancor> cizra: maybe backup?  it wasn't down ~10min ago iirc
04:15:36 <cizra> dancor: oh, possible
04:16:42 <turiya> hi
04:17:05 <turiya> can socketToHandle be used more than once
04:22:10 <jlouis> turiya: I think so, but it might create some really hard to find bugs
04:23:26 <Jonno_FTW> how can I make this work: comma "" n = n
04:23:27 <Jonno_FTW> comma x n= (takeWhile (/= ',') x): n : (comma (dropWhile (/= ',') x) [])
04:23:34 <turiya> jlouis, how can i read and write from/to the same tcp socket? should it be done with two handles or just one
04:23:48 <quicksilver> Jonno_FTW: you want ++ [n] ++
04:23:49 <Jonno_FTW> i want it so that comma "some, string" -> ["some","string"]
04:23:56 <quicksilver> Jonno_FTW: not ": n :" in
04:23:59 <quicksilver> the middle of that expression.
04:24:11 <Jonno_FTW> ok
04:24:16 <quicksilver> although I'm not sure what that 'n' is for.
04:24:35 <Jonno_FTW> it was to build up the list on, but i guess it's obsolete
04:25:40 <quicksilver> ok I might have misunderstood
04:25:44 <quicksilver> maybe you did want : there
04:26:26 <Jonno_FTW> this might require guards
04:26:41 <Jonno_FTW> in the case where ',' is not an element of the list
04:27:18 <dancor> for my problem i added Composition(..) to the export list of Control/CP/ComposableTransformers.hs, but now i get a new crazier error :3
04:27:58 <Jonno_FTW> quicksilver: it just hangs after getting the first string, and i actually want a list of strings
04:28:04 <dancor> Couldn't match expected type [incredibly long thing] against inferred type `FDConstraint s' NB: `Control.CP.Solver.Constraint' is a type function, and may not be injective  When generalising the type(s) for `it'
04:28:19 <dancor> i wonder if this is all things that stop working in ghc 12.1
04:29:51 <ivanm> dancor: the only thing I've found that I use that doesn't work with 6.12 is gtk2hs (without the patch that is)
04:30:06 <quicksilver> there were some subtle changes to type families and type functions, I believe
04:30:23 <quicksilver> mostly bugfixes but they could potentially break things which relied accidentally on the buggy behaviour?
04:31:07 <dancor> Saizan: are you using monadiccp
04:32:34 * jlouis conjures a spell and tries to resummon turiya
04:32:45 <Jonno_FTW> @hpaste
04:32:45 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
04:32:55 <jlouis> My spell-fu is failing me
04:32:57 <monadic_kid> trying to use data-files: in cabal file but the build process doesn't seem to copy over to the install location
04:33:46 <Jonno_FTW> how come this doesn't stop? http://pastebin.ws/7l9h5s
04:34:01 <Jonno_FTW> with the input: comma "some, string"
04:34:22 <Jonno_FTW> it just returned ["some","","".....
04:34:35 <Jonno_FTW> with only empty strings on the end
04:34:43 <quicksilver> Jonno_FTW: imagine what happens if the first character is a comma
04:34:52 <quicksilver> which case does it end up in, and what happens then?
04:35:07 <Jonno_FTW> the empty string that comes before the comma?
04:35:33 <quicksilver> imagine your function (comma) being called on the string ",hi"
04:35:35 <quicksilver> what happens?
04:35:46 <Jonno_FTW> infinite list of empty strings
04:36:06 <quicksilver> yes you told me that
04:36:11 <quicksilver> I'm tell you to look at your code
04:36:15 <Jonno_FTW> takeWhile (/= ',') returns the empty string
04:36:15 <quicksilver> and tellm e what the code says it will do
04:36:19 <quicksilver> right
04:36:25 <quicksilver> and what does the dropwhile return?
04:36:26 <dcoutts> monadic_kid: really? should work fine. If you think there's a bug we'll need more details.
04:37:05 <Jonno_FTW> the non-empty string following the comma
04:37:17 <Jonno_FTW> so it never gets caught
04:37:25 <quicksilver> nope
04:37:35 <quicksilver> > dropWhile (/= ',') ",hi"
04:37:36 <lambdabot>   ",hi"
04:37:48 <quicksilver> it returns the same thing.
04:37:51 <Jonno_FTW> yep
04:37:55 <quicksilver> so your recursive call loops forever
04:37:59 <Jonno_FTW> so i need tail x?
04:38:08 <quicksilver> yup
04:40:44 <Jonno_FTW> now i just get ["some",""]
04:48:07 <turiya> hi
04:48:11 <Jonno_FTW> hello
04:48:12 <fax> hello turiya
04:49:13 <Jonno_FTW> quicksilver: I fixed it up but it always drops the last very word
04:49:28 <quicksilver> Jonno_FTW: ok, let's see what you have now?
04:49:30 <Jonno_FTW> i have: | otherwise = (takeWhile (/= ',') x) : (comma (tail $ dropWhile (/= ',') x )n)
04:49:55 <Jonno_FTW> | ',' `notElem` x = n
04:50:09 <quicksilver> surely you mean 'x' not 'n'
04:50:12 <quicksilver> in the notElem case.
04:50:20 <Jonno_FTW> it gives a type error
04:50:24 <fax> what is this??
04:50:32 <quicksilver> good point
04:50:34 <quicksilver> you mean [x]
04:50:37 <Jonno_FTW> yep
04:50:41 <Jonno_FTW> all good now ^_^
04:50:41 <quicksilver> because you want a list of one item
04:50:46 <quicksilver> containing the last word which is x.
04:51:01 <Jonno_FTW> thanks for the help
04:51:26 <Jonno_FTW> my goal is to turn some references I have that are in harvard form into bibTex form
04:52:08 <quicksilver> you could use Data.List.split, by the way
04:52:18 <quicksilver> but perhaps this process has been useful to you ;)
04:52:20 <quicksilver> I hope so.
04:52:25 <Jonno_FTW> yep
04:52:35 <Jonno_FTW> @source split
04:52:35 <lambdabot> split not available
04:52:40 <Jonno_FTW> D:
04:52:49 <Jonno_FTW> :t split
04:52:50 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
04:53:02 <Jonno_FTW> RandomGen?
04:53:21 <monadic_kid> typeclass for random generators
04:53:32 <Jonno_FTW> but... why
04:53:33 <Jonno_FTW> ?
04:53:41 <monadic_kid> and the Random typeclass is for numbers which can be randomized
04:53:54 <monadic_kid> so you can use different random generators
04:54:09 <quicksilver> Jonno_FTW: no.
04:54:13 <quicksilver> Jonno_FTW: Data.List.Split.split
04:54:19 <quicksilver> it's a package on hackage
04:54:21 <quicksilver> @hackage split
04:54:22 <lambdabot> http://hackage.haskell.org/package/split
04:54:25 <Jonno_FTW> yep, i found it
05:00:25 <Oejet> I hope that "split" will be included in The Haskell Platform.
05:02:59 <Jonno_FTW> it is included
05:07:58 <fax> so haskell whats up
05:08:15 <Jonno_FTW> @source up
05:08:16 <lambdabot> up not available
05:08:32 <`0660>  /wii haskell
05:08:43 <Jonno_FTW> what?
05:09:24 <Jonno_FTW>  i think /wii is for a server
05:20:24 <Twey> Jonno_FTW: '/wii foo' means '/whois foo foo', which is a more verbose version of '/whois foo'
05:21:18 <Jonno_FTW> interesting
05:21:28 <poucet> Twey: what about /ps3 foo
05:22:24 <Twey> Heh
05:25:52 <adamdunkley> RE: my earlier problem whereby I wanted to move from MonadState to MonadReader (carrying the existing state). I made a pastebin to show the problem: http://pastebin.com/35XbAWVX
05:28:05 <whald> can s.o. give me a hint how to use the System.Random.MWC package? whats PrimMonad? i don't see how to get a single random float out of this... :-/
05:28:16 <quicksilver> adamdunkley: yes, that is a very useful thing to do
05:28:46 <quicksilver> adamdunkley: one way to do it is to change the signature of anotherfunction
05:29:12 <quicksilver> adamdunkley: (MonadReader SomeState m, MonadWriter [Output] m) => m String
05:29:23 <quicksilver> (i.e. don't mention the type SecondMonad, just the capabilities you require)
05:29:38 <quicksilver> and then write the MonadReader instance for FirstMonad as well as SecondMonad
05:30:06 <adamdunkley> ah, this instance of MonadReader was what I had suggested to me by a friend
05:30:11 <adamdunkley> but I wasn't quite sure what they meant
05:31:20 <quicksilver> it may be possible to run *any* SecondMonad action in FirstMonad
05:31:30 <quicksilver> but you haven't given me enough information to prove that :)
05:31:32 <quicksilver> so I can't be sure.
05:31:41 <quicksilver> you'd need to write the combinator
05:31:54 <quicksilver> runSecondInFirst :: SecondMonad a -> FirstMonad a
05:32:11 <quicksilver> but in general, I find it's better design to use a capability system in your type sigs.
05:32:31 <quicksilver> myFunction :: MonadCanDoThisStuff m => m a
05:32:39 <quicksilver> rather than concrete types.
05:32:50 <quicksilver> then you can automatically use myFunction in any monad which can do that stuff.
05:33:34 <fax> wait memristor has something to do with quantum computing??
05:34:49 <adamdunkley> Yeh, I was going for the latter really... surely I would need to map the state in MonadState to MonadReader at some point, that is what I am unsure of
05:35:45 <adamdunkley> this is a bit of a learning curve for me, but I feel like I am -almost- there with what I want from it
05:38:41 <monadic_kid> adamdunkley: Are you using monad transformers? if so then you could just get the state and create a new reader. If you have two seperate monads you have to "get out of" the state monad before you create a reader
05:39:31 <quicksilver> transformers don't solve this problem
05:39:44 <quicksilver> because there might be something 'underneath'
05:39:46 <monadic_kid> quicksilver: I never said it solves the problem
05:40:01 <monadic_kid> quicksilver: I was asking what he's using
05:40:49 <adamdunkley> Aren't monads, when put in constraints, always monad transformers?
05:40:53 <adamdunkley> I was confused about this
05:41:19 <adamdunkley> They are initialised as monad transformers
05:42:24 <quicksilver> no.
05:42:35 <Jafet> The last program I worked on had three layers of monad transformers, I rewrote it all with continuation passing before I could get anything done
05:42:36 <quicksilver> MonadState is a class; you might see it in a constraint.
05:42:46 <quicksilver> StateT is a transformer
05:42:51 <quicksilver> you might use it to build a type.
05:43:24 <adamdunkley> So specific instances of the MonadState class build different State/StateT etc?
05:43:32 <monadic_kid> adamdunkley: no
05:43:37 <adamdunkley> hmm
05:43:42 <quicksilver> instances don't build anything.
05:43:50 <quicksilver> You can write a monad of your own, and provide instances for it.
05:43:57 <quicksilver> or you can build it using the transformers
05:44:03 <quicksilver> in which case you'll automatically get some instances.
05:44:34 <adamdunkley> I see
05:50:44 <adamdunkley> quicksilver: So when you said there wasn't enough info to prove it's possible to run any action of SecondMonad in FirstMonad, what would you need to know?
05:50:52 * adamdunkley feels slow on the uptake
05:51:35 <quicksilver> adamdunkley: well for all I know, SecondMonad as well as its State and Writer instances, also has primitive to shave the cat and distill whisky.
05:52:06 <quicksilver> whereas first monad is only capable (beyond its instances shown) of washing tablecloths.
05:52:17 <quicksilver> in that case I clearly can't run secondmonad actions in first monad.
05:52:58 <adamdunkley> indeed
05:54:49 <quicksilver> so, the point is, the instances just tell me some things about what the monad can do, not everything.
05:55:02 <quicksilver> on the other hand a polymorphic function signature is a much stronger declaration:
05:55:14 <quicksilver> foo :: MonadReader m e => m a
05:55:24 <quicksilver> since 'foo' can be run in *any* monad which supports MonadReader
05:55:32 <quicksilver> I know that the only things it does are the reader primitives
05:55:41 <quicksilver> because it must run in every imaginable monadreader
05:57:56 <adamdunkley> okay
05:58:10 <adamdunkley> I am going to give it some thought, and chop around my code a bit
06:01:02 <Vitka> I've written simple optimization using state monad: "opt guess treshold = evalState (do {result <- gets computeStuff; return $ if (guess - result) < treshold then result else opt result treshold}) guess". Can it be done more elegantly?
06:03:08 <dmwit> Vitka: Any reason you're using the State monad there?
06:04:11 <quicksilver> wow.
06:05:27 <Vitka> No particular reason, expect maybe I'll need it for keeping several results in case of more complex algorithms.
06:05:40 <EvanR> a list holds many results
06:06:25 * hackagebot HList 0.2.2 - Heterogeneous lists  http://hackage.haskell.org/package/HList-0.2.2 (GwernBranwen)
06:06:25 <Vitka> So should I try simple recursion with accumulator?
06:06:26 <EvanR> above, your iterations use different State
06:06:43 <Vitka> ...good point.
06:07:01 <EvanR> its recursively and sort of stateful, just use recursion alone. if you have state, you can do a loop
06:07:09 <EvanR> untilM, forever, etc
06:07:37 <Vitka> Hmm.
06:09:14 <EvanR> for more complex algorithms that depend on previous results, you often can use foldr foldl foldl'
06:09:26 * hackagebot ipprint 0.4 - Tiny helper for pretty-printing values in ghci console  http://hackage.haskell.org/package/ipprint-0.4 (GlebAlexeyev)
06:09:48 <EvanR> those are good for 'i need an accumulator'
06:19:30 * hackagebot hpage 0.7.3 - A scrapbook for Haskell developers  http://hackage.haskell.org/package/hpage-0.7.3 (FernandoBenavides)
06:22:27 <monadic_kid> Vitka: I don't know all the details but you can use ST monad, you can do flipi evalState guess $  to get rid of the brackets. Without know more details what you're trying to do it's hard to say what are better ways
06:24:37 <monadic_kid> Vitka: you got mapAccumL/R as well as folds
06:24:58 <Vitka> I see, thanks.
06:25:33 <monadic_kid> Vitka: what are you trying to do, optimize, write better/more elegant code?
06:25:58 <roconnor> yes, Repa has been released
06:26:23 <roconnor> now I need to write Repaint
06:26:52 <roconnor> oh
06:26:57 <roconnor> i need ghc head
06:27:35 <roconnor> ah I can use ghc 6.12, but it will just be slow
06:27:37 <roconnor> that is fine for now
06:27:58 <quicksilver> roconnor: what does "shape polymorphic" mean?
06:28:13 <roconnor> shap means the type of indices of arrays
06:28:15 <Vitka> I'm looking for a way to elegantly express optimization methods like steepest descent and more complex ones.
06:28:23 <roconnor> shape
06:29:02 <quicksilver> "Repa means "turnip" in Russian. If you don't like turnips then this library probably isn't for you"
06:30:23 <poucet> quicksilver: what about arepa?
06:30:27 <roconnor> hmm I only have ghc 6.10
06:31:29 <bashrc_> can somebody help me with fold? i want to calculate from a list of a list like [[9,8,7],[6,5,4],[4,3,2]] the diff of the maximum. in this case 9-(6-(4)).
06:31:36 <bashrc_> this is my code and my error
06:31:37 <bashrc_> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=25245#a25245
06:31:56 <bashrc_> the function maxlist gives the maximum of a list, and it is working
06:32:04 <bashrc_> sublist isnt working
06:32:14 <roconnor> > map maxium [[9,8,7],[6,5,4],[4,3,2]]
06:32:15 <lambdabot>   Not in scope: `maxium'
06:32:20 <quicksilver> you misunderstand the type of fold, bashrc_
06:32:23 <roconnor> > map maximum [[9,8,7],[6,5,4],[4,3,2]]
06:32:24 <lambdabot>   [9,6,4]
06:32:33 <quicksilver> quicksilver: your inner function will never be called with two lists as parameters
06:32:43 <roconnor> > foldr1 (-) $ map maximum [[9,8,7],[6,5,4],[4,3,2]]
06:32:44 <lambdabot>   7
06:32:44 <quicksilver> so it's wrong to call 'maxlist' on both of them.
06:32:59 <quicksilver> :t foldr1
06:33:00 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
06:33:17 <quicksilver> in fact, you cant use foldr1 for your case at all
06:33:22 <roconnor> > foldr1 f [a,b,c]
06:33:23 <lambdabot>   f a (f b c)
06:33:28 <quicksilver> foldr1 requires the result "a" to be the items in the list
06:33:45 <quicksilver> your list is  [[Int]], so the items are [Int]
06:33:51 <quicksilver> but you want to return Int not [Int]
06:34:37 <bashrc_> so what can i do to solve it using fold?
06:34:59 <bashrc_> i mean foldr is good for this or not? doing foldr (-) 0 list
06:35:13 <quicksilver> actually roconnor gave you the answer
06:35:15 <bashrc_> but this time i want to run foldr on the result of maxlist
06:35:22 <quicksilver> but I was trying to explain why yours doesn't work
06:35:28 <quicksilver> yes, you will have to use foldr not foldr1
06:35:37 <quicksilver> because it doesn't have the restriction I was describing.
06:35:40 <quicksilver> :t foldr
06:35:40 <ivanm> I assume he wants subtract and not fold?
06:35:41 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
06:35:46 <ivanm> s/fold/(-)/
06:36:10 <bashrc_> yes i want to subtract
06:36:31 <ivanm> > foldr1 (flip subtract) [1..10]
06:36:32 <lambdabot>   -5
06:36:37 <ivanm> > foldr1 (-) [1..10]
06:36:38 <lambdabot>   -5
06:36:46 <ivanm> oh, using (-) does work there
06:36:50 <quicksilver> bashrc_: you need to look at the type of foldr
06:37:02 <quicksilver> bashrc_: I"m not sure how to give you more clues without just doing it for you :)
06:37:24 <bashrc_> @type foldr1
06:37:25 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
06:37:41 <bashrc_> @type foldr
06:37:43 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
06:38:13 <ivanm> quicksilver: what's the actual problem here?
06:38:35 <quicksilver> bashrc_: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=25245#a25245
06:38:42 <bashrc_> ivanm: i want to calculate from a list of a list like [[9,8,7],[6,5,4],[4,3,2]] the diff of the maximum. in this case 9-(6-(4)).
06:38:43 <quicksilver> ivanm: I meant to paste that to you.
06:38:56 <quicksilver> the problem is an exercise in using folds.
06:39:04 <ivanm> aha
06:39:06 <quicksilver> roconnor already gave him a different solution.
06:40:48 <bashrc_> i think my problem is to understand, how i to use the answer of maxlist.
06:41:14 <ivanm> bashrc_: OK, let's let me try explaining this
06:41:23 <ivanm> bashrc_: lets consider your lambda function to sublist
06:41:37 <ivanm> now, foldr (and foldr1) expect a function of type (a -> b -> b)
06:41:44 <ivanm> in this case, what are a and b?
06:42:05 <bashrc_> a and b is the input and b is the output
06:42:16 <ivanm> what _types_ are they?
06:42:33 <ivanm> and that's not quite right, as there is a value of type b being passed in as well
06:42:36 <bashrc_> a is a list, b is and iteger?
06:42:42 <ivanm> yes!
06:42:54 <bashrc_> b is an integer, sorry for misspelling
06:42:57 <ivanm> so, if b is an Int, does it make sense to call maxlist on the b value?
06:43:08 <bashrc_> no
06:43:19 <ivanm> OK, that's one problem fixed
06:43:26 <ivanm> now, lets consider foldr vs foldr1
06:43:30 <ivanm> @type foldr1
06:43:31 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
06:43:51 <ivanm> foldr1 assumes that the final type is the same as the input list type
06:43:55 <ivanm> does that make sense in this case?
06:44:16 <bashrc_> hmm, i think not
06:44:37 <bashrc_> cause a is a list, so the output have to be a list
06:44:52 <ivanm> right
06:45:02 <bashrc_> sublist mylist = foldr (\a b -> maxlist(a) - b) 0 mylist
06:45:08 <ivanm> so, we have to use plain old foldr
06:45:12 <bashrc_> this should be okey than?
06:45:12 <ivanm> @type foldr
06:45:13 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
06:45:22 <ivanm> so, how can we get that initial `b' value for foldr?
06:45:32 <bashrc_> 0 ?
06:45:54 <ivanm> do you really want 0?
06:46:03 <ivanm> I don't know what the criteria for your function is
06:46:28 <bashrc_> zero should be ok, i want to subtract the maximum of every list in the list.
06:46:38 <bashrc_> doing max1 -(max2 - (max3 -0)))
06:47:15 <ivanm> ummm... yeah, that should be OK then
06:47:19 * ivanm got confused with foldl
06:47:29 <ivanm> I thought the first arg was applied directly, but no, that's foldl
06:48:07 <bashrc_> i think i got the answer now, thank you all for your help
06:48:32 <bashrc_> i changed maxlist(b) to b and added 0 as initialvalue
06:48:59 <bashrc_> so i matched the right type with a->b->b
06:49:36 <ivanm> yup
06:51:53 <bastl> Is there a good way to search the archives of #haskell ? google does not seem to index the logs (which is good), but I'd like to look for older conversations.
06:52:07 <ivanm> bastl: google archives part of it...
06:52:09 <ivanm> but see the topic
06:52:32 <bashrc_> i am asking me how i could do it with map. sublist mylist = foldr (-) 0 map maxlist mylist  something like this
06:52:50 <bashrc_> the way roconnor did
06:52:50 <bastl> yeah, I know tunes.org. But I dont know how to search the logs there ?
06:55:46 <ivanm> bashrc_: foldr (-) 0 (map maxlist mylist)
06:57:29 <SallySue> Hello gentlemen! I am an actual woman; That's right, I have one of those where your penis goes. Now listen, I am issuing a challenge: If you can make a useful Haskell program you get to have your way with my special place. I feel safe that nobody will manage this.
06:58:25 <ivanm> darcs is useful
06:58:32 <SallySue> Did you write it?
06:58:33 --- mode: ChanServ set +o poucet
06:58:35 <ivanm> but unfortunately droundy doesn't appear to be here
06:58:48 <ivanm> anyway, it depends on your definition of "useful"
06:59:03 <ivanm> I find haskell-updater useful, but unless you use haskell packages on gentoo then you probably won't
06:59:04 <SallySue> It generates an income
06:59:06 <ivanm> as such.... TROLL!!!!!
06:59:14 --- mode: ChanServ set +o dibblego
06:59:17 --- kick: SallySue was kicked by dibblego (SallySue)
06:59:18 <ivanm> bah, "useful" /= "commecercial"
06:59:37 --- mode: poucet set +b *!*55c89673@gateway/web/freenode/x-vzqnpwomjyhdyzhw
06:59:38 --- kick: SallySue was kicked by poucet (SallySue)
06:59:38 <ivanm> SallySue:  "useful" /= "commecercial"
06:59:53 --- mode: dibblego set -o dibblego
06:59:55 * poucet coughs
06:59:59 <ivanm> let's see if she's dumb enough to try again...
07:00:06 <ivanm> (assuming it _is_ a "she")
07:00:28 <killing-joke> "my special place"?   i don't think so
07:00:57 <siracusa> Can you listen to a keypress in Gtk2Hs if the program is not the currently active program?
07:01:31 <ivanm> probably not
07:01:50 <poucet> that would be awesome
07:01:54 <poucet> password loggers here I come =)
07:01:56 --- mode: poucet set -o Polarina
07:01:59 --- mode: poucet set -o poucet
07:03:11 <siracusa> Or another way to achieve it on any system? On windows I could call getAsyncKeyState in a loop IIRC
07:03:41 <poucet> siracusa: think about it ,it means you could snoop keypresses being sent to another application
07:03:47 <poucet> siracusa: I doubt any decent OS allows that
07:03:47 <Oejet> dibblego, poucet: Isn't it usual to state a reason, when kicking someone from the channel?
07:04:00 <poucet> Oejet: sorry, I forgot <virtual nudity>
07:04:02 <roconnor> I've used haskell programs I've written to make a little money, but not by selling it.
07:04:05 <ivanm> Oejet: methinks it was obvious
07:04:46 <kamatsu> i really don't get this "female haskellers don't exist" meme
07:04:58 <kamatsu> my best friend is a female haskeller
07:05:10 <poucet> kamatsu: it's a snowclone of "femalle programmers don't exist"
07:05:16 <poucet> -l
07:05:24 <roconnor> fax is a female haskeller AFAIK
07:06:40 <ivanm> roconnor: I dunno, she tends to spend more time doing math than haskell here AFAICT
07:06:59 <roconnor> perhaps she is more of an agda programmer...
07:07:18 <kamatsu> well, my best friend is also from the maths side of things
07:07:49 <kamatsu> but i would've thought if you were generalizing there would be less female mathematicians than there are programmers
07:09:08 <fryguybob> I don't think that's true.
07:09:13 <ivanm> what is?
07:09:15 <Oejet> poucet, ivanm: Yes, but does it really happen so often, that a warning couldn't be given first?
07:09:15 <ivanm> *isn't
07:09:39 <poucet> Oejet: seriously, did you see any constructive dialogue evolving with someone that entered a channel that way?
07:10:14 <poucet> Oejet: and is this really something you want to spend time discussing?  I saw no added value in keeping that person, I think we're wasting our breaths arguing about this
07:10:20 <ivanm> Oejet: I think it was quite obvious that she (?) was trolling
07:10:41 <ivanm> and not in a "let's play along and have some fun" sense
07:11:01 <ivanm> but in a "nerd boys have never been with a female" sense
07:11:19 <poucet> right it wasn't even a supposed noobie troll
07:11:41 <ivanm> besides, assuming her (?) offer _was_ genuine, the logistics of accepting the "reward" would have possibly been difficult... :p
07:12:14 <kamatsu> poucet: do you mean the "I'm new to haskell, but, how does functional programming have any real world applications? To me it seems like it doesn't." ?
07:12:15 <Oejet> poucet: Yes, I did in fact. And no, I am not going to discuss it further.
07:12:29 <poucet> kamatsu: yes, we've seen those trolls before, and we tend to indulge them a bit more and try to educate them.
07:12:32 <fryguybob> So... anyone know a package for doing REPL on a DSL?
07:12:36 <poucet> kamatsu: some are slightly more antagonistic
07:12:48 <kamatsu> poucet: right
07:12:57 <ivanm> fryguybob: the prompt monad?
07:13:04 <kamatsu> fryguybob: can't you just forever $ interact .. ?
07:14:43 <quicksilver> this is a very forgiving and friendly channel - the friendliest I've ever been in - but it is also the most 'family-friendly'
07:14:59 <quicksilver> anyone who starts offering adult services - whether its in jest or in troll - is going right out.
07:15:22 <ivanm> it's a SFW channel!
07:15:24 <ivanm> ;-)
07:15:29 <kamatsu> quicksilver: i like the way you assume that any adult services offered are either jests or trolls
07:15:31 <ivanm> preflex: seen Axman6
07:15:32 <preflex>  Axman6 was last seen on #haskell 6 hours, 10 minutes and 52 seconds ago, saying: Ada has a nice feature where you can specify value ranges for your own types
07:15:44 <kamatsu> quicksilver: what if someone was serious? :P
07:15:45 <ivanm> kamatsu: all others belong in -blah ;-)
07:15:56 <ivanm> since they're not on-topic
07:16:06 <kamatsu> hm
07:16:48 <kamatsu> hmm, Axman6's quote reminded me
07:16:51 <fryguybob> kamatsu: You couldn't ":quit" out of that right?
07:16:59 <kamatsu> I was going to try and write a ranged number type in Agda
07:17:03 <kamatsu> fryguybob: ah, this is a good point
07:17:44 <fryguybob> I have my code doing what I want now, but I feel like I'm reinventing the repl wheel.
07:18:33 <quicksilver> in some cases you can cheat and use ghci
07:18:47 <quicksilver> but for something more serious, I thin you just write a few top-level commands like ':quit' yourself
07:18:51 <quicksilver> it's not that hard really :)
07:18:59 <quicksilver> I haven't seen anything prepackaged for it.
07:19:19 <fryguybob> Right, just wondering if it was prepackaged somewhere, like what does ghci do?
07:19:36 <kamatsu> ah, it uses readline doesn't it?
07:19:42 <kamatsu> you might want to look at haskeline
07:19:46 <quicksilver> ghci is a moderately complex custom repl
07:19:48 <fryguybob> ok
07:19:55 <quicksilver> its parts are mostly not re-usable.
07:19:57 <quicksilver> it used to use readline
07:20:02 <kamatsu> http://hackage.haskell.org/package/haskeline-0.6.2.2
07:20:07 <quicksilver> more recently it experimented with editline before switching to haskeline.
07:20:12 <fryguybob> quicksilver: that's what I figured
07:20:28 <fryguybob> kamatsu: I'll take a look, thanks.
07:22:04 <bastl> there was a trick do simulate pattern matching on functions. But I cant remember, and dont find anything on the  et
07:22:07 <bastl> Net *
07:22:21 <ivanm> bastl: what do you mean?
07:22:56 <bastl> depending on a function argument, do different things.
07:22:58 <ivanm> quicksilver: though I've experienced haskeline having the same bugs as editline (e.g. emitting control characters when hitting home or end)
07:23:13 <ivanm> bastl: care to provide an example?
07:23:24 <ivanm> because that sounds exactly like _normal_ pattern matching...
07:23:35 <killing-joke> rms will be speaking at Stanford in a few hours. if any women show up, i will ask them if they program in Haskell.
07:23:44 <bastl> no, i mean "function-argument" like in map
07:24:10 <bastl> myhigherordef :: (a->b) -> c
07:24:19 <ivanm> bastl: that... doesn't make sense
07:24:20 <bastl> myhigherorderf (id) = Nothing.
07:24:21 <ivanm> nor is it safe
07:24:43 <bastl> myhigherorderf (someotherfunction) = Just something
07:24:46 <ivanm> quicksilver: ^^ you know anything about what bastl is talking about?
07:24:54 <bastl> sigh
07:25:10 <quicksilver> he's talking rubbish :)
07:25:20 <ivanm> thought so ;-)
07:25:21 <quicksilver> functions are not introspectable or comparable.
07:25:46 <bastl> that's why i asked for the "trick".
07:26:10 <quicksilver> you can of course build an explicit ADT for some particular scheme of functions and work over that.
07:26:28 <bastl> something like that.
07:27:05 <bastl> and ivanm: I got a ver good answer to this question just here and can't find it on the logs ...
07:27:10 <bastl> *very
07:27:21 <bastl> quicksilver: any example of that ?
07:29:15 <quicksilver> not off the top of my head
07:31:13 <fax> what wuold happend if haskell had dependent types
07:31:15 <fax> ?
07:31:39 <dolio> It would be called Cayenne.
07:32:09 <noteventime> Do I have to import some special module to get a monad instance for Behaviour in Reactive?
07:32:24 <quicksilver> noteventime: you need to change the laws of physics.
07:32:53 <dolio> Or Idris, maybe.
07:32:54 <noteventime> quicksilver: The documentation seems to imply that there is one
07:33:16 <quicksilver> there can't be a Monad instance for Behaviour without serious hackery.
07:33:23 <quicksilver> really, which documentation?
07:33:37 <noteventime> http://hackage.haskell.org/packages/archive/reactive/0.11.4/doc/html/FRP-Reactive-Behavior.html
07:34:00 <noteventime> It doesn't say it's actually implemented
07:34:05 <quicksilver> noteventime: right, it's not.
07:34:23 <noteventime> But it discusses its semantics
07:34:25 <quicksilver> whilst it's obvious that the semantics have monad methods on them, they're not implementable in that implementation.
07:34:32 <noteventime> I see
07:34:36 <quicksilver> fortunately it feels like you don't need it.
07:34:37 <noteventime> I suspected something like that
07:34:38 <quicksilver> it's just an annoying.
07:34:50 <noteventime> Yea, it was just for some notational convenience
07:34:53 <quicksilver> in my expreience you can always twist things around and get away with just applicative.
07:49:27 <Eelis> @hoogle [a] -> Int -> Maybe a
07:49:28 <lambdabot> Prelude (!!) :: [a] -> Int -> a
07:49:28 <lambdabot> Data.List (!!) :: [a] -> Int -> a
07:49:28 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
07:49:50 <Eelis> hm, so there's no total list indexing function in the base libraries?
07:49:53 <Eelis> how bizarre..
07:52:27 <Eelis> @type \n -> listToMaybe . drop n -- i guess this isn't so bad
07:52:28 <lambdabot> forall a. Int -> [a] -> Maybe a
07:54:20 <quicksilver> Eelis: yes, that's what I'd use.
07:58:03 <Eelis> it feels a bit dirty though, because the name "listToMaybe" always sounds to me like one should really only expect to get /an/ element from the list, not necessarily the head. it would've been much better if that function was called maybeHead or something
07:58:34 <quicksilver> yes, it's a bit of a funny name
07:58:45 <ivanm> well, there are a lot of functions like that
07:58:46 <quicksilver> I get the impression they just couldn't think of a better one.
07:59:00 <quicksilver> it's certainly an important function, whatever you call it.
07:59:01 <Jafet> Can't you see, it's begging for an alternative implementation
07:59:02 <ivanm> e.g. filter: every now and then I expect it to _discard_ those elements for which the predicate is true
07:59:15 <idnar> safeHead
07:59:23 <ivanm> I think though that with listToMaybe, you can consider that there is no other sensible choice
07:59:24 <idnar> or just call it head, and rename head to unsafeHead :P
07:59:31 <quicksilver> sounds too much like something the W.H.O. would be recommending.
07:59:32 <ivanm> you could make it the last element, except for infinite lists
07:59:39 <idnar> quicksilver: hahaha
07:59:43 <ivanm> anything else (second, third, etc.) would fail on other lists
08:00:01 <quicksilver> no, it could just return Nothing for other lists.
08:00:14 <quicksilver> listToMaybe (x:y:ys) = Just y; listToMaybe _ = Nothing
08:00:17 <Jafet> listToMaybe = const Nothing
08:00:23 <quicksilver> it could be quite sensible for any element
08:00:31 <quicksilver> but there is something obviously canoncial about the first, certainly.
08:01:03 <idnar> listToMaybe = unsafeCoerce, right?
08:01:20 <Jafet> @quote unsafeCoerce
08:01:20 <quicksilver> in GHC, as it happens, yes.
08:01:21 <lambdabot> ghc says: Dangerous-looking argument. Probable cause: bad unsafeCoerce#
08:01:21 <ivanm> quicksilver: OK, the current implementation is the one that makes the _most_ sense out of all possible implementations
08:01:38 <quicksilver> but that's only because the constructors happen to be defined in the corresponding order.
08:01:48 <idnar> yeah.
08:01:55 <idnar> well, I guess unsafeCoerce is besides the point
08:02:03 <ivanm> really? listToMaybe uses unsafeCoerce?
08:02:06 <quicksilver> no, it doesn't.
08:02:11 <ivanm> *phew*
08:02:17 <quicksilver> it just happens that it would work, if it did, in GHC.
08:02:17 <ivanm> > unsafeCoerce [1,2] :: Maybe Int
08:02:18 <Eelis> heh
08:02:18 <lambdabot>   Not in scope: `unsafeCoerce'
08:02:20 <idnar> but the correspondence between the constructors seems relevant
08:02:43 <quicksilver> well it seems natural, certainly.
08:02:57 <Jafet> ivanm, the number of implementations is uncountably infinite
08:03:03 <idnar> [] -> Nothing, (:) -> Just
08:03:09 <Jafet> Maybe there isn't a most sensible implementation!
08:03:16 <ivanm> Jafet: right
08:03:23 <idnar> Jafet: haha
08:03:30 <idnar> Jafet: Just take the head!
08:03:31 <ivanm> but I would say that you could order the sensibility of such implementations
08:03:45 <ivanm> idnar: nah, the head would be const Nothing
08:03:46 <Eelis> the number of pure Haskell implementations is surely only countably infinite?
08:03:53 <idnar> sortBy (comparing sensibility)
08:03:53 <Jafet> You'd also have to show there is an upper bound
08:04:09 <idnar> ivanm: hmm?
08:04:33 <ivanm> <idnar> Jafet: Just take the head!
08:04:37 <idnar> oh
08:04:52 <Jafet> Hmm
08:05:05 <idnar> o/` what is it good for? o/`
08:05:10 <Jafet> listToMaybe (generateImplementations listToMaybe)
08:05:32 <idnar> fix listToMaybe
08:06:10 <Jafet> @src forever
08:06:10 <lambdabot> Source not found. :(
08:06:52 <Jafet> Useless fact: forever = fix . (>>)
08:07:15 <idnar> @type mfix
08:07:16 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
08:07:17 <idnar> @type forever
08:07:19 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
08:07:22 <Twey> Everybody knows that :þ
08:07:40 <idnar> @type fix
08:07:41 <lambdabot> forall a. (a -> a) -> a
08:08:13 <fax> why isn't it called fixM?
08:08:28 <Twey> :t mfix
08:08:29 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
08:08:35 <Twey> Because…
08:08:37 <Twey> Because.
08:08:38 <idnar> because it's a different thing
08:08:39 <Twey> :-\
08:08:47 <idnar> fixM sounds like fix lifted into Monad
08:08:50 <fax> is it beacause the constraint is MonadFix rather than Monad?
08:08:58 <idnar> like mapM etc.
08:09:16 <Berengal> fixM :: (Monad m) => m (a -> a) -> m a ?
08:09:25 <quicksilver> I think fax is right.
08:09:31 <Twey> idnar: Well, isn't it?
08:09:35 <quicksilver> it could perfectly well be called fixM from its type
08:09:45 <fax> :t ((return . fix) <=<)
08:09:46 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m (a -> a)) -> a1 -> m a
08:09:50 <quicksilver> but because it's a method of a new class, not a combinator which works for all monads
08:09:54 <quicksilver> it's not called fixM
08:10:10 <Twey> Berengal: mapM ≠ liftM map
08:10:10 <idnar> Twey: not really, because it's a "primitive" (hence MonadFix, instead of Monad)
08:10:19 <quicksilver> like 'get' isn't called 'getM'
08:10:20 <palmje> anyone know of a good haskell tcp server tutorial?
08:10:21 <Berengal> if liftM lifts function to works on monads, what does lift do?
08:10:33 <Twey> quicksilver: Fair enough
08:10:35 <Twey> :t lift
08:10:35 <quicksilver> Berengal: lifts functions up one level in a MonadTrans stack.
08:10:36 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
08:10:39 <ivanm> palmje: I don't there is any such specific tutorial
08:10:43 <quicksilver> Berengal: not very useful very often.
08:10:52 <Twey> s/functions/actions/
08:10:56 <quicksilver> thanks, twey.
08:11:05 <quicksilver> lazy C programmer habit there.
08:11:06 <Berengal> Twey: (m a -> m a) -> m a then
08:11:35 <Berengal> quicksilver: It doesn't seem related to liftM, or at the very least, their names should be swapped...
08:11:41 <jmcarthur> do we generically call functions of the form (a -> m b) "actions"? i thought "actions" was reserved for things of type (IO a)
08:11:57 <Twey> jmcarthur: I think it's used for anything of type ‘m a’.
08:12:11 <jmcarthur> ah i meant (m a), not (a -> m b)
08:12:26 <fax> what is the name for  a0 -> a1 -> ... an -> m b ?
08:12:32 <jmcarthur> still, i thought it was reserved for IO a
08:12:39 <Twey> It certainly makes sense to consider things like State ‘actions’
08:12:42 <EvanR-work> Berengal: i could have used lift instead of liftIO in my StateT over IO, to do IO actions
08:12:43 <Berengal> jmcarthur: I use "action" for types 'm a', calling a -> m b things functions
08:12:44 <jmcarthur> it feels weird to call (a -> b) an action
08:12:46 <Twey> I think it does for all monads
08:12:49 <palmje> ivanm: well, any good site mapping out the tcp networking api?
08:13:02 <fax> it seems like a false implication to call it a procedure
08:13:26 <ivanm> palmje: no idea
08:13:52 <palmje> k
08:14:09 <jmcarthur> i would call (a -> m b) a kleisli arrow if it wasn't a mouthful compared to "function"
08:15:03 <benmachine> jmcarthur: there are definitely ST actions... I think it's more about what it does than its type :P
08:15:04 <fax> interesting
08:15:23 <jmcarthur> benmachine: i agree with you on ST
08:15:30 <fax> so then we could use   a0 -> m (a1 -> ... m an)  ?
08:15:42 <fax> as a nary arrow
08:15:45 <jmcarthur> haha
08:20:14 <bastl> is there a standard name for concatenation of two stacks ?
08:20:28 <fax> back to back or front to back?
08:20:44 <bastl> front to backl
08:20:45 <fax> back to back is queue, front to back is a zipper
08:20:49 <gwern> I wonder if there is any way to download all haskell github repos
08:21:03 <gwern> I should like them all, but I see no obvious way to get the list
08:21:34 <bastl> fax: hmm i want to extend a zipper's stack by this operation :-)
08:21:36 <Jafet> Not really a queue, but that is a way to implement queues with stacks
08:21:47 <fax> I don't understand
08:21:52 <benmachine> gwern: do you like, hate hard drive space
08:21:53 <bastl> never mind
08:22:04 <gwern> benmachine: don't be silly. it won't take more than 10 gigs or so
08:22:12 <benmachine> if you say so
08:22:21 <gwern> benmachine: hell, I have all of patchtag and c.h.o in 4 or 5 gigs
08:22:31 <losl> Is it possible for a custom type class to store a curried function as one of its values?
08:22:38 <gwern> and that's most of the old darcs projects; recent git repos would be even smaller
08:22:55 <benmachine> gwern: I can tell you where mine is if it helps :P it's 26M apparently
08:22:55 <gwern> losl: typeclasses don't store anything...
08:23:46 <gwern> losl: are you thinking of records?
08:23:58 <losl> yes, sorry.
08:24:21 <gwern> losl: then sure, you can include a partially applied function
08:24:46 <gwern> benmachine: technically my ~/bin is 5.7G but that includes all the isntalled libraries and binaries as well, so...
08:24:51 <losl> How do I say that when I'm prototyping the record?
08:24:53 <xezz> hey folks
08:25:00 <xezz> got a question
08:25:27 * BMeph thinks gwern is playing GitHubMon - gotta download 'em all! ;)
08:25:27 <xezz> i have a function wich compares if an element in a list is > 50 and then gives True or False
08:25:38 <xezz> first we got it with a foldr
08:25:39 <xezz> cmp50 = foldr (\k acc -> if k > 50 then True else acc) False
08:25:41 <gwern> losl: well, you would do something like Foo { cont :: Int, add :: Int -> Int -> Int }
08:25:52 <gwern> losl: functions are data, so it works fine
08:25:52 <losl> Thanks!
08:25:53 <xezz> this one ist terminatiing even on an infinite list
08:26:07 <gwern> BMeph: having all repos is useful!
08:26:09 <Jafet> repeat MasterBall
08:26:39 * gwern once used up the masterball on an abra. it then took ~70 ultra balls to capture mewtwo
08:26:48 <xezz> but the same one with foldl does not terminate... cmp50' = foldl (\acc y -> if y > 50 then True else acc) False
08:26:56 <xezz> why is that so xD?
08:27:14 <gwern> @src foldl
08:27:15 <lambdabot> foldl f z []     = z
08:27:15 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
08:27:15 <gwern> @src foldr
08:27:15 <lambdabot> foldr f z []     = z
08:27:16 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
08:27:24 <BMeph> xezz: Short answer: UR DOIN IT RONG! ;)
08:27:41 <xezz> yeha i know the soruce
08:27:42 <xezz> and
08:28:25 <xezz> foldr after soem steps:
08:28:25 <xezz> f 47 (f 16 ( f 58 False)
08:28:25 <xezz> foldl after some steps:
08:28:25 <xezz> (f(f(f False 47) 16) 58)
08:28:30 <benmachine> > foldr (\k acc -> if k > 50 then True else acc) [1 ..]
08:28:31 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
08:28:31 <lambdabot>         against inferred type ...
08:28:35 <benmachine> > foldr (\k acc -> if k > 50 then True else acc) False [1 ..]
08:28:36 <lambdabot>   True
08:28:39 <xezz> on a list like [47,16,58]
08:29:28 * BMeph weeps every time he sees an 'if ... then True...' construction
08:29:36 <benmachine> BMeph: :P
08:29:49 <benmachine> xezz: so you want to know why foldr terminates when foldl doesn't?
08:30:13 <BMeph> benmachine: I guess it's a step up from 'if (x > 50) == True then...' ;)
08:30:14 <xezz> well its for homework.. and a classmate had the soulution with foldl me with foldr.. and so we are thinkg about it
08:30:15 <xezz> yes
08:30:35 <benmachine> xezz: because of laziness
08:30:47 <benmachine> specifically, foldr has some and foldl doesn't
08:30:54 <xezz> and i know that u dont like if then else but in this case its the shortest solution (i think)
08:31:18 <xezz> ok
08:31:18 <benmachine> xezz: if x then True else y = x || y
08:31:26 <benmachine> for all x, y
08:32:04 <benmachine> generally speaking, if you have booleans in a then/else then there is a shorter way of writing it
08:32:21 <benmachine> in this case, foldr (\k acc -> k > 50 || acc)
08:32:32 <BMeph> xezz: Here's a hint: 'if a then True else b' is the same thing as saying 'a || b'. -That's_ what I'm saying.
08:32:43 <benmachine> anyway there's a lot of stuff about foldl/foldr on the wiki
08:32:55 * benmachine goes to check if his step evaluator can demonstrate this one
08:33:03 <xezz> so its just that the foldr terminates as soon as it hits a True?
08:33:20 <xezz> and the foldl doesnt cause it works of the hole list?
08:33:23 <benmachine> pretty much
08:33:24 <quicksilver> and if you have foldr with something on one side, that's a foldr after a map.
08:33:39 <sioraiocht> xezz: if you unfold a foldl
08:33:42 <quicksilver> foldr (\k acc -> k > 50 || acc) == foldr (||) . map (>50)
08:33:44 <quicksilver> I think.
08:33:51 <xezz> this || does what? its an or isnt it?
08:33:54 <quicksilver> yes.
08:34:05 <scree_> one useful thing can be to expand out the definitions
08:34:10 <sioraiocht> you get something like ((x * y) * z) * t
08:34:10 <benmachine> quicksilver: is that preferable though?
08:34:17 * gwern lols again at some old code: 'mapM_ (\x ->runProcess "darcs" ["get", "--lazy", "http://patch-tag.com"++x] Nothing Nothing Nothing Nothing Nothing) targets'
08:34:18 <sioraiocht> where * is an arbitrary operator
08:34:23 <quicksilver> benmachine: well it turns into any . map (>50)
08:34:30 <sioraiocht> it can't give you any result until it computes the whole list
08:34:31 * jmcarthur lols at gwern's old code
08:34:37 <gwern> 4 Nothings is annoying; 5 Nothings is qutie funny
08:34:38 <quicksilver> benmachine: no, "or $ map (>50)"
08:34:44 <quicksilver> which is just "any (>50)"
08:34:45 <quicksilver> IIRC.
08:34:46 <benmachine> right
08:34:47 <BMeph> Since there's already a function named 'or', I used the function that does "or" instead of saying it. That's my fault, though.
08:34:51 <benmachine> I guess so
08:35:00 <sioraiocht> whereas foldr would be x * (y * (z * t))
08:35:07 <sioraiocht> it can give you x without computing the rest
08:35:10 <scree_> hasLargeThing (x::xs) = if x > 50 then True else hasLargeThing xs
08:35:14 <sioraiocht> or x * y without computing (z*t)
08:35:16 <scree_> is foldr
08:35:39 <fax> scree_, yeah folrd
08:35:40 <quicksilver> gwern: that code would be much more readbe if you did "badger = Nothing; mushroom = Nothing; mapM_ (\x ->runProcess "darcs" ["get", "--lazy", "http://patch-tag.com"++x] badger badger badger badger mushroom)
08:35:41 <fax> foldr*
08:35:52 <gwern> quicksilver: a meme I've never understood
08:36:11 <xezz> well with this solution  foldr (\k acc -> k > 50 || acc)
08:36:24 <idnar> gwern: http://www.weebls-stuff.com/songs/badgers/
08:36:25 <xezz> its clear why foldr does not have to compute the rest and foldl has
08:36:26 <scree_> hasLargeThing (x::xs) seenOneSoFar = hasLargeThing xs (seenOneSoFar || x > 50)
08:36:30 <scree_> is foldl
08:36:34 <Jafet> quicksilver, maaaake! maaaake!
08:36:35 <gwern> idnar: nor that I wish to understand
08:37:12 <quicksilver> it's actually not true that foldl has to calculate every item in the list
08:37:13 <xezz> well thx ill try to explain to my classmate xD
08:37:20 <quicksilver> but it does have to calculate the *spine* of the list
08:37:23 <quicksilver> not quite the same thing
08:37:26 <benmachine> yeah it basically starts from the back
08:37:38 <benmachine> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=foldl+(\acc+k+->+k+>+50+||+acc)+False+[1%2C2%2C3%2C51%2C4%2C5%2C6] clear as mud but gets the job done :P
08:37:51 <xezz> but the back is > 50 on [1..]
08:37:53 <quicksilver> > let (.||.) = flip (||) in foldl (.||.) [undefined,undefined,True] False
08:37:54 <CalJohn_> http://privatepaste.com/759ed99e23 <- could someone who has used c2hs before point me in the correct direction with wrapping this single function?
08:37:54 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
08:37:54 <lambdabot>         against inferred type ...
08:38:02 <benmachine> xezz: the back is nonexistent on [1..]
08:38:04 <quicksilver> > let (.||.) = flip (||) in foldl (.||.) False [undefined,undefined,True]
08:38:05 <lambdabot>   True
08:38:09 <gwern> I wonder if anyone has tried to make an analogy between foldl's order of evaluation and the IO monad? :)
08:38:17 <benmachine> xezz: it keeps looking for the back and never finds it
08:38:22 <quicksilver> ^^ doesn't touch the first two elements, but it does build the spine
08:38:33 <xezz> ah right
08:38:45 <quicksilver> there are two things at work here
08:38:51 <quicksilver> one is the basic shape of foldr
08:38:54 <quicksilver> and the other is the details of ||
08:39:04 <quicksilver> it's a detail of || that it doesn't touch its right argument if the left one was True.
08:39:19 <quicksilver> and the basic shape of foldr is that if its function doesn't touch its right argument it never builds that part of the list
08:39:22 <idnar> @type (||)
08:39:23 <lambdabot> Bool -> Bool -> Bool
08:39:26 <idnar> @type or
08:39:27 <lambdabot> [Bool] -> Bool
08:39:33 <quicksilver> so foldr works well with functions which are (sometimes) right-lazy.
08:40:02 <benmachine> if your function is sometimes left-lazy then 1. you are perverse 2. flip it :P
08:40:56 <fax> hmm
08:41:07 <xezz> hehe ok
08:41:11 <fax> @src or
08:41:11 <lambdabot> or    =  foldr (||) False
08:41:14 <fax> @src and
08:41:15 <lambdabot> and   =  foldr (&&) True
08:41:28 <fax> what is the nature of these functions
08:41:46 <idnar> > or [a, b, c]
08:41:47 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
08:41:48 <lambdabot>         against inferred type ...
08:41:54 <idnar> doh
08:42:02 <gwern> > or [False, False, True, undefined]
08:42:03 <lambdabot>   True
08:42:07 <scree_> I wonder what happens if you do folds on things that are sometimes left lazy and sometimes right lazy
08:42:07 <gwern> > and [False, False, True, undefined]
08:42:08 <lambdabot>   False
08:42:18 <scree_> bad things probably
08:42:31 <gwern> good ol' short-circuiting, or as we like to call it 'limited hardwired laziness'
08:42:47 <benmachine> scree_: you can't have a binary function that decides which argument to be lazy in without inspecting one of them
08:43:41 <scree_> benmachine: a function superOr :: Bool -> Bool -> Bool s.t. superOr True _|_ = True = superOr _|_ True, does exist
08:43:47 <xezz> mh that and and or are folds is got to know :P
08:43:57 <benmachine> scree_: only with cheating
08:44:12 <benmachine> unamb using unsafePerformIO
08:44:23 <ddarius> xezz: Most list consuming functions can be expressed as some sort of fold.
08:44:24 <idnar> if you have unamb, is using it really cheating?
08:44:30 <BMeph> Laziness: When you don't do as much work as someone else wants you to do. Nice definition. :)
08:44:43 <ddarius> benmachine: You can use something safer than that.
08:44:54 <benmachine> ddarius: superOr _ _ = True?
08:44:55 <idnar> BMeph: I want a procrastinating programming language, instead of a lazy programming language ;)
08:45:23 <benmachine> idnar: I dunno, it's not very haskelly because it relies on you to satisfy the precondition
08:45:28 <benmachine> and if you don't it breaks... everything
08:46:01 <scree_> cheating is fun
08:46:11 <ddarius> benmachine: No.  You can add a primitive parallel or operation which is pure and from it all other such operations can be defined.  In this case, it directly defines the relevant function.
08:46:11 <benmachine> idnar: just my opinion though
08:46:19 <benmachine> ddarius: adding primitives is also cheating :P
08:46:27 <benmachine> sort of
08:46:32 <quicksilver> but ddarius's primitive is at least semantically sound
08:46:35 <benmachine> I would like a primitive like that
08:46:38 <quicksilver> whereas unamb is not.
08:47:26 <benmachine> I don't know how it would affect efficiency; it would probably be quite a subtle decision when to use it or not
08:47:46 * gwern sends off an email asking about github
08:48:02 <scree_> right; a fold that spawns new threads at each iteration, some of which continue with the fold and some of which test the current element ... could be fun
08:48:08 <benmachine> because if you start pattern matching in parallel you're pretty much guaranteeing that some work will be wasted, but at the same time some work will be saved
08:48:20 <idnar> wasn't there some higher-level thing that was sound?
08:48:24 <idnar> I can't remember the details now
08:48:49 <scree_> the number of threads you actually get would depend on how hard your list elements were to compute
08:48:54 <BMeph> xezz: Just think of "foldr" as Haskell's way of doing for-loops. You'd do "foldl" if you're doing a count-down, but if you don't know where you're gonna start counting down, it'd be weird to try it that way. :)
08:50:11 <xezz> yeha we got it now xD after evaluating by hand :P
08:50:53 <xezz> and with ur solution with || it makes sense that it is how it is but didnt know that if then else does like it
08:51:31 <xezz> and btw. at university the first things we had to do where if then else functions xD
08:52:26 <Twey> Do we have a boolean xor, by the way?
08:52:35 <ddarius> Twey: /=
08:52:45 <Twey> Oh!
08:52:48 <Twey> D'oh :-D  Thanks
08:52:54 <xezz> simple
08:52:55 <xezz> ^
08:53:06 <Berengal> Booleans are
08:53:14 <Twey> Aye
08:53:42 * Twey realised the other day that ‘parity = foldr xor 0’ (or 1) and was quite impressed.
08:54:01 <scree_> is there a GHC extension that bans the if/then/else syntax?
08:54:07 <ddarius> foldr1 (/=)
08:54:28 <xezz> @src foldr1
08:54:28 <lambdabot> foldr1 _ [x]    = x
08:54:28 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
08:54:28 <lambdabot> foldr1 _ []     = undefined
08:54:48 <Twey> Doesn't handle the [] case and doesn't allow odd parity
08:56:11 <aavogt> > foldr (/=) False [True,False,False,True,True]
08:56:12 <lambdabot>   True
08:56:36 <Twey> Right
08:56:36 <jmcarthur> :t any
08:56:37 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
08:56:44 <Twey> jmcarthur: Different
08:56:45 <idnar> hmm
08:56:49 <idnar> (/=) is xor?
08:57:00 <Twey> idnar: Yeah
08:57:06 <idnar> ah yes
08:57:10 * idnar reads up
08:57:15 <Twey> idnar: Truth table FTTF
08:57:19 <scree_> > foldl' (/=) False . take 1000000 $ cycle [True, False]
08:57:20 <lambdabot>   False
08:57:21 <jmcarthur> oh
08:57:34 <scree_> > foldr (/=) False . take 1000000 $ cycle [True, False]
08:57:36 <lambdabot>   *Exception: stack overflow
08:57:41 <idnar> what about (->)?
08:57:55 <xezz> @src foldl'
08:57:56 <lambdabot> foldl' f a []     = a
08:57:56 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
08:58:02 <benmachine> what about it
08:58:15 <xezz> @src foldl
08:58:15 <lambdabot> foldl f z []     = z
08:58:15 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
08:58:22 <idnar> boolean (->), I mean
08:58:30 <benmachine> implication?
08:58:34 <idnar> yes
08:58:47 <quicksilver> not a || b
08:58:55 <jacobian> :)
08:59:04 <quicksilver> @pl \a b -> not a || b
08:59:04 <lambdabot> (||) . not
08:59:08 <idnar> heh
08:59:15 <jacobian> omg
08:59:26 <jacobian> pointless representation bot?
08:59:46 <Twey> Isn't that ‘(foldl' f $! f a x) xs’?
08:59:47 <xezz> @pl listsum x = foldl (-) 0 $ L.sortBy (flip compare) $ foldl (++) [] x
08:59:47 <lambdabot> listsum = foldl (-) 0 . L.sortBy (flip compare) . foldl (++) []
09:00:21 <BMeph> xezz: It's just something that more experienced programmers find minorly annoying - making up a calculation that's more involved than it needs to be. Like, for instance, doing an "if-then-else" statement, and putting the same value in the "then" part as in the "else" part.
09:00:25 <gwern> > 98 + (20 * 98)
09:00:26 <lambdabot>   2058
09:00:44 <scree_> @pl let f x = g (x+1); g x = f (x-1) in f
09:00:44 <lambdabot> fst (fix (uncurry (flip ((,) . (. (1 +))) . (. subtract 1))))
09:01:11 <scree_> gosh
09:01:12 <xezz> ist this pontless thing really usefull?
09:01:24 <benmachine> sometimes
09:01:25 <idnar> it depends
09:01:35 <idnar> in the case of scree_'s function, it's pretty pointless :P
09:01:42 <xezz> example of scree isnt xD?
09:01:46 <benmachine> you have to judge whether what it comes out with is better or worse than the explicit versino
09:01:48 <xezz> ok
09:01:49 <quicksilver> it's interesting, not useful most of the time.
09:01:58 <quicksilver> only in very simple cases would most people consider the output nicer.
09:02:03 <benmachine> @pl \f g -> f x (g x)
09:02:03 <lambdabot> (. ($ x)) . ($ x)
09:02:07 * benmachine blinks
09:02:16 <quicksilver> @pl x -> (f (g (h x)))
09:02:17 <lambdabot> (line 1, column 3):
09:02:17 <lambdabot> unexpected ">" or "-"
09:02:17 <lambdabot> expecting variable, "(", operator or end of input
09:02:21 <benmachine> @pl \f g x -> f x (g x)
09:02:22 <lambdabot> ap
09:02:26 <quicksilver> @pl \x -> (f (g (h x)))
09:02:26 <lambdabot> f . g . h
09:02:33 <quicksilver> ^^ that's nicer, for example :)
09:02:44 <xezz> what is ap?
09:02:49 <benmachine> :t ap
09:02:50 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
09:02:56 <benmachine> it's from Control.Monad
09:03:00 <xezz> ok dunno about monads right now so..
09:03:02 <quicksilver> ap is function application lifted into a monad
09:03:09 <quicksilver> that *particular* example is using the function monad
09:03:12 <benmachine> in this case it is applied with m = (->) r
09:03:13 <quicksilver> a.k.a reader monad
09:03:32 <quicksilver> it's an instructive example but only when you understand enough of the building blocks to get the point
09:03:36 <quicksilver> before then it's just obfuscation.
09:03:46 <benmachine> sry :P
09:04:48 <scree_> @unpl fst (fix (uncurry (flip ((,) . (. (1 +))) . (. subtract 1))))
09:04:48 <lambdabot> fst (fix (uncurry (\ i c -> ((,)) (\ o -> c (1 + o)) (\ r -> i (subtract 1 r)))))
09:04:59 <xezz> @pl cmp50 = foldr (\k acc -> k>50 || acc) False
09:04:59 <lambdabot> cmp50 = foldr ((||) . (> 50)) False
09:05:06 <xezz> fascinating :P
09:05:34 <scree_> it'd be more useful if unpl turned the meaningless gibberish into readable code
09:05:53 <idnar> @writemycode
09:05:54 <lambdabot> Unknown command, try @list
09:06:35 <quicksilver> @pl often generalises the type
09:06:35 <lambdabot> often generalises the type
09:06:42 <xezz> is using curry and uncurry a "good" or a "bad" thing?
09:06:42 <quicksilver> so then @unpl can't reconstruct any more
09:06:56 <quicksilver> can be handy, xezz, but not needed very often
09:07:12 <quicksilver> you only need them at the interface between functions which are using tuples and functions which don't want tuples.
09:07:23 <quicksilver> in the standard library there really aren't many functions which use tuples
09:07:26 <quicksilver> so it doesn't come up much.
09:07:32 <scree_> though fix -> recursive would be nice
09:08:04 <quicksilver> scree_: yes, that would be nice, but it wouldn't disentangle mutual recursion like your example
09:08:08 <quicksilver> (there is no canonical way to do that)
09:09:53 <scree_> what is it doing the other way? inlining?
09:10:08 <hiato> Hello all
09:10:30 <ManateeLazyCat> hiato: HI.
09:10:44 * ManateeLazyCat Bla, bla, bla for rest. :)
09:10:53 <uorygl> What do the Greek "ana" and "cata" mean, again?
09:11:24 <Twey> uorygl: ‘Upwards’ and ‘downwards’, respectively
09:11:52 <uorygl> So if I analyse something, I'm cutting it upwards?
09:11:54 <uorygl> Neat.
09:12:23 <scree_> oh, it's fst $ fix (\(f, g) -> (\x -> g (x+1), \y -> f (x-1))) isn't it
09:12:28 <hiato> I have with me, today, yet another (what must be a) trivial question question: if I define, say data abc = abc { blah blah }, why can I not define data xyz = xyz { qrs :: abc -> lmno } ?
09:12:33 <hiato> ManateeLazyCat: heh
09:12:36 <xezz> @src repeat
09:12:36 <lambdabot> repeat x = xs where xs = x : xs
09:12:53 <benmachine> hiato: you can't?
09:12:54 <Twey> uorygl: In the Greek, ‘breaking up’
09:13:06 <uorygl> That makes a bit more sense.
09:13:30 <hiato> benmachine: Unless I spelled it wrong, it tells me " Not a data constructor"
09:13:30 <uorygl> hiato: well, the result type of qrs has to be xyz, no?
09:13:41 <ManateeLazyCat> hiato: Should be "data Abc" and "data Xyz"?
09:13:48 <uorygl> hiato: also, capitalisation is quite important.
09:13:59 <hiato> ah, ok, lt me giv that a shot
09:14:30 <uorygl> data Xyz = Xyz { qrs :: Abc -> Lmno }
09:14:33 <gwern> you're cutting it up, that's for sure
09:14:56 <hiato> Yep, that sotved that problem. Thanks guys :)
09:15:28 <ManateeLazyCat> hiato: If you define data, you should be use Capital, you should use downcase if you define function.
09:15:53 <hiato> ManateeLazyCat: thanks, noted
09:16:41 <hiato> also, do I have do define Abc = [Xyz] in order to effect data Lmn = Lmn { pqr = [Xyz] }?
09:16:58 <hiato> that is, use a, er, synonym type?
09:17:14 <quicksilver> hiato: no you can use [Xyz] directly.
09:17:19 <hiato> hmmm
09:17:22 <quicksilver> you don't need [Xyz] to have a name of its own.
09:17:36 <quicksilver> data Abc = [Xyz] is illegale though.
09:17:44 <ManateeLazyCat> hiato: You should use "data Abc = Abc [Xyz]
09:17:45 <hiato> right
09:17:47 <quicksilver> you either want "type Abc = [Xyz]" which is a plain synonym
09:17:54 <quicksilver> or data Abc = Abc [Xyz]
09:17:56 <ManateeLazyCat> hiato: Or "type Abc = [Xyz]"
09:18:02 <ManateeLazyCat> quicksilver: :)
09:18:04 <uorygl> Hmm, a functor is a type of morphism.  Wikipedia lists a couple of types of morphisms with Greek prefixes; I suppose you can also stick these onto the word "functor" to get monofunctors, epifunctors, isofunctors, endofunctors, and autofunctors.
09:18:07 <quicksilver> I personally find type synonyms to be something very close to useless.
09:18:18 <quicksilver> except possibly as a rather weak form of documentation.
09:18:22 <hiato> Right, yeah
09:18:48 <ManateeLazyCat> quicksilver: No, type synonyms useful when you build polymorphism functions.
09:19:10 <gwern> quicksilver: they're convenient when you don't want to go wholehog with newtype tags
09:19:29 <quicksilver> they don't offer a real abstraction benefit
09:19:40 <hiato> heh, nevermind, it wasn't that that was the problem anyway
09:19:47 <quicksilver> because you're relying on the goodwill of your consumers not to accidentally violate the encapsulation and use the underlying types.
09:20:02 <quicksilver> they do offer a shorthand benefit, in the underlyg type is particularly long and hard to type :)
09:22:46 <FliPPeh> Hey... how can I instruct GHC to omit creating/automatically remove the .hi and .o files?
09:23:20 <quicksilver> it can't not create them, they're important.
09:23:42 <FliPPeh> well, that's right...
09:23:43 <quicksilver> find . -name "*.hi" -or -name "*.o" | xargs rm '{}' should get rid of them for you afterwards
09:23:49 <FliPPeh> Can I change their location?
09:23:50 <quicksilver> at the cost of making the next compile expensive.
09:23:52 <quicksilver> yes.
09:23:53 <FliPPeh> Like a tmp/ folder?
09:23:55 <quicksilver> -hidir -odir
09:24:13 <benmachine> there are a few options for controlling that sort of thing
09:24:20 <ManateeLazyCat> FliPPeh: Cabal?
09:24:21 <benmachine> I could never quite make them do exactly what I wanted
09:24:28 <benmachine> which is about the time I switched to using Cabal instead, yeah
09:24:51 <ManateeLazyCat> FliPPeh: Cabal can make .hi and .o in separate directory and give your clean source code space. :)
09:24:52 <quicksilver> FliPPeh: http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#options-output
09:25:04 <FliPPeh> Cabal is overkill
09:25:08 <FliPPeh> I just have 3 files
09:25:27 <quicksilver> then why do the .o files and .hi files bother you? ;)
09:25:31 <benmachine> cabal doesn't do much killin'
09:25:46 <ManateeLazyCat> FliPPeh: Cabal make your live eaiser even you just have three files. :)
09:25:50 <FliPPeh> quicksilver: They clutter my directory, and pollute my tab completion :(
09:25:54 * hackagebot dyre 0.8.3 - Dynamic reconfiguration in Haskell  http://hackage.haskell.org/package/dyre-0.8.3 (WillDonnelly)
09:26:19 <EvanR-work> FliPPeh: vim tab completion solves that
09:26:35 <EvanR-work> pressing tab over and over doesnt get you stuck at Main.
09:26:36 <quicksilver> FliPPeh: most ridiculous reason ever.
09:26:44 <EvanR-work> you press twice and you get Mainn.hs
09:27:00 <quicksilver> :)
09:27:08 <FliPPeh> I said "pollute", not "block" - that's 2 wasted key presses!
09:27:42 <EvanR-work> in bash its tab h tab s <extra tab> enter ;)
09:27:59 <EvanR-work> 4 extra
09:28:20 <benmachine> I don't like the cycling tab style
09:28:26 <benmachine> shortest-prefix 4eva
09:28:33 <FliPPeh> Not in ZSH, it will auto fill in the first thing it finds and let me use my arrow keys to pick any more
09:28:48 <EvanR-work> sounds like an improvement
09:29:23 <FliPPeh> It certainly is :)
09:29:45 <FliPPeh> But really impratical for several files with the same name with different extensions, when you only want one
09:32:47 <quicksilver> tell zsh to ignore .hi and .o files then
09:33:09 <quicksilver> that's definitely a better solution than deleting valuable files for the benefit of your tab completion :P
09:33:18 <Zao> FliPPeh: Sounds like you've got some silly tab completion mode then, as my sane zsh doesn't do that :D
09:34:08 <fax> fasta is a biological term
09:34:23 <ManateeLazyCat> Hehe, so many zsher. Me too. :)
09:34:31 <fax> and me
09:34:34 <benmachine> I still use bash but I don't like it very much
09:34:37 * uorygl looks up that biological term.
09:34:44 <benmachine> someone write me a shell in haskell :(
09:34:52 <fax> hash
09:35:03 <uorygl> It appears to be a DNA and protein sequence alignment software package first described by David J. Lipman and William R. Pearson in 1985.
09:35:08 <uorygl> GHCi!
09:35:09 <benmachine> (because as everyone knows the usability of an application is solely dependent on the language in which it is written)
09:35:35 <ManateeLazyCat> @package hash
09:35:36 <lambdabot> http://hackage.haskell.org/package/hash
09:35:39 <ddarius> I wouldn't call it a biology term.
09:35:46 <quicksilver> when I cared what my shell could do, I chose zsh.
09:35:48 <fasta> Neither would I.
09:36:01 <ManateeLazyCat> lambdabot: You should say "Ooops, 404" :)
09:36:02 <fasta> It is a file format.
09:36:12 <fasta> http://en.wikipedia.org/wiki/FASTA_format
09:36:13 <quicksilver> but these days I don't find fancy shell features compelling enough to bother to install zsh on a new machine.
09:36:41 <seeg> hello
09:36:49 <ManateeLazyCat> seeg: Hello.
09:36:56 <fasta> IMHO, the fancy shells are all broken in some ways because they didn't have millions of users.
09:37:01 <seeg> i have a test.hs file with the following line: main = sum [ n | n <- [1..1000 - 1], n `mod` 5 == 0 || n `mod` 3 == 0]
09:37:09 <fasta> The popular shells are broken because there is no parallelism.
09:37:33 <seeg> but when i run ghc --make test.hs i get this error:
09:37:35 <seeg> No instance for (Integral (IO t))
09:37:35 <seeg>       arising from a use of `mod' at id_0001.hs:9:37-45
09:37:35 <seeg>     Possible fix: add an instance declaration for (Integral (IO t))
09:37:35 <seeg>     In the first argument of `(==)', namely `n `mod` 5'
09:37:35 <seeg>     In the first argument of `(||)', namely `n `mod` 5 == 0'
09:37:35 <seeg>     In the expression: n `mod` 5 == 0 || n `mod` 3 == 0
09:37:40 <uorygl> seeg: what do you want the program to do with that number?  The value of main must be some action; if you want your program to print the number, you have to say so.
09:37:43 <sepp2k> seeg: main has to return an IO, not an int
09:37:46 <ManateeLazyCat> seeg: Please paste code.
09:37:50 <benmachine> fasta: everything is broken >_>
09:37:55 <ManateeLazyCat> sepp2k: hpaste.org?
09:37:56 <uorygl> ManateeLazyCat: he did.
09:37:58 <fasta> benmachine, yes, so nothing new there.
09:38:07 <fasta> benmachine, well, actually I think some things are not broken.
09:38:12 <ManateeLazyCat> uorygl: I mean use some code-site do that.
09:38:12 <seeg> sorry, i'm new to this language :)
09:38:34 <fasta> seeg, if you are new, you should not be using monads.
09:38:36 <sepp2k> seeg: Basically you want to do print (sum ...)
09:38:47 <seeg> ah, ok
09:38:53 <uorygl> ManateeLazyCat: the code is just one line; did you mean to paste the error?
09:39:00 <sepp2k> I mean main = print (sum ...)
09:39:07 <ManateeLazyCat> uorygl: Yep
09:39:11 <lpsmith> is there a convenient way of determining which version of GHC an executable was compiled with?
09:39:17 <seeg> ok, but now i get some linking errors...
09:39:18 <benmachine> fasta: I think if a word is going to be useful one should normalise the criteria so that the set to which it does not apply is nontrivial :P
09:39:44 <seeg> some pthread stuff...
09:39:50 <fasta> benmachine, to what does that apply?
09:40:10 <seeg> ah, ok, -threaded solved it
09:40:19 <seeg> it works great now :)
09:40:58 <benmachine> fasta: I dunno I just think "broken" is a bit of a hopeless word?
09:41:30 <benmachine> lpsmith: I'm not sure if application +RTS --info tells you the version it compiled with or the version you have now
09:41:43 <benmachine> I'd guess the former but now that dynamic linking is a possibility I dunno
09:42:16 <lpsmith> benmachine, that worked, thanks
09:42:28 <lpsmith> it returned a GHC version I don't have installed on the machine, so...
09:42:32 <benmachine> neat
09:42:48 <uorygl> Can you tell GHC to exclude the RTS flags?
09:42:50 <benmachine> it says "information about the RTS used by this program"
09:43:03 <benmachine> uorygl: I think I read something about that in the 6.12.2 release notes
09:43:17 <benmachine> so you might be able to do so as of very recently
09:43:31 <benmachine> don't quite remember though, and don't have that version to check
09:45:07 <ManateeLazyCat> What's most new feature in 6.12.2?
09:45:28 <jmcarthur> point releases are just tweaks and bug fixes, aren't they?
09:46:16 <ManateeLazyCat> Maybe i need update to it.
09:48:06 <Twey> @src Float show
09:48:07 <lambdabot> Source not found. My brain just exploded
09:48:12 <Twey> ☹
09:48:28 <c_wraith> @src Show []
09:48:28 <lambdabot> Source not found. I've seen penguins that can type better than that.
09:48:43 <c_wraith> @src ([] a) Show
09:48:44 <lambdabot> Source not found. Just try something else.
09:48:46 <c_wraith> @src ([] a) show
09:48:47 <lambdabot> Source not found.
09:48:52 <c_wraith> nope, it doesn't have any of 'em
09:49:10 <Twey> I'm trying to work out the algorithm used to convert 12345.678 into "12345.678"
09:49:26 <Twey> I'm mentally blocking at how to split the fractional digits
09:52:08 <CalJohn_> I'm getting link errors like "(.text+0xcf): undefined reference to `HandEval'".  This is a C function I am calling through C2HS, how do I get ghc to find the C file, which is in the current working directory?
09:52:27 <CalJohn_> it seems people usually link with "-lfoolib"
09:52:40 <Saizan> CalJohn_: pass it as an argument
09:53:16 <Saizan> (or maybe you've to compile it separately and pass the .o as an argument?)
09:53:57 <CalJohn_> thanks for that
10:03:14 <MadHatterDude> Stupid linker...
10:04:55 <MadHatterDude> Can somebody help me with ever cryptic compilation errors?
10:05:49 <Entroacceptor> maybe?
10:05:56 <Entroacceptor> depends on your errors, I guess
10:06:09 <Entroacceptor> a psychatrists is maybe the last resort...
10:06:41 <MadHatterDude> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25248#a25248
10:06:44 <MadHatterDude> This is my code
10:07:05 <kmc> MadHatterDude, 99% of linker errors from GHC are fixed by using ghc --make
10:07:17 <kmc> otherwise, please continue :)
10:07:36 <MadHatterDude> kmc: __stginit__ ring any bells?
10:07:47 <copumpkin> what was the reason ghc --make isn't the default?
10:07:55 <copumpkin> is it just to keep #haskell active?
10:08:12 <Saizan> hysterical raisins
10:08:26 <kmc> there is a ticket about it
10:10:50 <MadHatterDude> god fukken damnit. Who would design a compiler like that!
10:11:33 <MadHatterDude> "ghc -c Something.hs" doesnt work, but "ghc --make Something" does! WTF?!
10:11:53 <BMeph> MadHatterDude: Seriously: people who are unafraid to say,"Well, go ahead and make you own compiler, we don't mind." ;)
10:12:37 <c_wraith> I think they do it to encourage the use of cabal
10:13:08 <c_wraith> (which is really quite pleasant since the init command was added)
10:13:12 <MadHatterDude> Congrats, GHC, you made me facepalm so hard I am now bleeding from my nasal orifices.
10:14:26 <mreh> isn't there a spelling mistake in the cabal file from an init?
10:14:38 <mreh> maybe it was my fault and I blamed it on init
10:16:12 * uorygl tries to remember why he's studying category theory.
10:16:45 <uorygl> I seem to remember lamenting that the traditional definition of a function as a set of ordered pairs didn't work for functions capable of taking and returning themselves, such as id.
10:16:46 <c_wraith> The one time I used init, it worked fine.
10:17:01 <uorygl> And so someone said that category theory provides a way to get around that problem.
10:17:23 <kmc> id can't take and return itself (in Haskell)
10:17:24 <kmc> not really
10:17:33 <c_wraith> > id id
10:17:34 <lambdabot>   {()->()}
10:17:40 <kmc> you can instantiate id at one type, such that it can take and return id instantiated at a different type
10:17:40 <MadHatterDude> Well, compilation scrip modified, everything works like a charm...
10:18:08 <c_wraith> MadHatterDude: seriously, look into using cabal.  It's really both easy to use and powerful
10:18:17 <kmc> MadHatterDude, the reason is that --make dramatically changes the behavior of the compiler-driver in a way that is unexpected to people using gcc etc.
10:18:49 <c_wraith> > let i = id in i i
10:18:50 <lambdabot>   {()->()}
10:18:52 <MadHatterDude> c_wraith, I am, for installing packages at least...
10:18:55 <kmc> > (\x -> x x) id
10:18:56 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
10:19:08 <kmc> ^^^^ because lambda binds are monomorphic
10:19:09 <c_wraith> kmc: I see what you mean now
10:19:15 <uorygl> kmc: hmm, so could you formalise id as a function taking a type and returning the instantiation?
10:19:46 <c_wraith> MadHatterDude: it really does work well for compiling your own packages, too.
10:20:15 <uorygl> I don't think that would work if you had something like "newtype Boink = Boink (Boink -> Boink)".
10:20:46 <MadHatterDude> c_wraith: So far I have not had the need, I am, for now, a hobby programmer (although a gifted one).
10:21:06 <kmc> uorygl, in systems like System F you have explicit type abstraction and type application
10:21:10 <c_wraith> MadHatterDude: It just makes managing things easier.  That's valuable to everyone! :)
10:21:31 <MadHatterDude> c_wraith: Advice taken :)
10:21:48 <kmc> so you'd write:   id = ΛT. λ(x : T). x
10:22:02 <kmc> where Λ (capital lambda) is a type abstraction
10:22:18 <kmc> and λ (lower case lambda) is a value abstraction, with an explicit type for the argument (no inference)
10:22:31 <kmc> this gives the type
10:22:42 <kmc> id : ∀T. T -> T
10:22:51 <c_wraith> I was looking at the Curry-Howard correspondence last night, and the type of fix.  That *really* drove home how different intuitionist logic is.  (a -> a) -> a doesn't work in classical logic.  But fix works!
10:23:12 <fax> c_wraith can you elaborate a bit ?
10:23:36 <MadHatterDude> c_wraith: You should see Berengals sig on XKCD
10:23:50 <kmc> uorygl, and type application too
10:23:51 <kmc> e.g.
10:24:06 <kmc> id [Int] 3  ~~>  3
10:24:11 <kmc> where by ~~> i mean "evaluates to"
10:24:23 <kmc> so you could then say
10:24:34 <uorygl> kmc: what if I don't want to do that stuff explicitly?
10:24:41 <kmc> id [(A->A)->(A->A)] (id [A->A])
10:24:58 <kmc> uorygl, then you use a type system like Haskell's where it's implicit
10:25:19 <kmc> when you say (id id) the Haskell typechecker will do some unification and will figure out these type instantiations
10:25:29 <uorygl> Hmm.
10:25:40 * uorygl reads about Martin-Löf type theory.
10:25:47 <c_wraith> fax: in classical logic, (a -> a) -> a isn't valid, because it can be used to prove anything.  But fix has an implementation, and even is a useful function.  And by the Curry-Howard correspondence, that means (a -> a) -> a is valid in intuitionist logic.  I still haven't fully wrapped my head around that.
10:26:02 <kmc> fix doesn't have an implementation in a total language
10:26:08 <kmc> and partial functions are logically unsound
10:26:15 <MadHatterDude> how does id id id evaluate (syntactically, I mean)? When I open GHCi and type "let x = id id id" it doesnt cause trouble?
10:26:31 <kmc> MadHatterDude, (a b c) is ((a b) c)
10:26:38 <kmc> in order that currying behaves like multi-arg functions
10:26:41 <kmc> > id id id
10:26:42 <lambdabot>   {()->()}
10:26:48 <MadHatterDude> kmc: really?
10:26:53 <MadHatterDude> kmc: cool
10:26:58 <kmc> MadHatterDude, what else would it mean?
10:27:08 <MadHatterDude> kmc: I dunno, an error?
10:27:12 <uorygl> MadHatterDude: well, that's (id id) id.  I guess the first id takes the type ((a -> a) -> a -> a) -> (a -> a) -> a -> a, the second one takes the type (a -> a) -> a -> a, and the third one takes the type a -> a.
10:27:16 <kmc> MadHatterDude, then how would multi-arg functions work?
10:27:22 <MadHatterDude> kmc: considering that id takes a single argument
10:27:29 <kmc> MadHatterDude, every function takes a single argument
10:27:35 <texodus> Why can't I declare an instance Ord [MyType] with -XOverlappingInstances?  Is not "Ord [MyType]" more specific than "(Ord a) => [a]" ?
10:27:37 <kmc> \a b -> c is sugar for \a -> \b -> c
10:27:47 <MadHatterDude> ok, level with me guys
10:27:49 <kmc> texodus, i don't think constraints are considered, only the instance head
10:27:57 <MadHatterDude> I am a language designer kind of person
10:28:15 <kmc> uorygl, if you're interested, "ghc -fext-core" will dump Core (one of GHC's intermediate languages) to a *.hc file, and Core has explicit type application, much as System F does
10:28:35 <c_wraith> kmc: it doesn't have an implementation in a total language because it's not guaranteed to terminate?
10:28:37 <fax> MadHatterDude cool what are you working on
10:28:41 <MadHatterDude> id id id, would be like (in C or similar) doing: "id(a) { return a; }" and then saying id(id, id)
10:28:41 <kmc> c_wraith, right
10:28:52 <c_wraith> kmc: ok, that makes sense.
10:28:58 <fax> MadHatterDude, no
10:28:59 <kmc> MadHatterDude, no
10:29:00 <kmc> it'd be like
10:29:02 <uorygl> MadHatterDude: here, it's more like id(id)(id).
10:29:03 <kmc> (id(id))(id)
10:29:05 <fax> apply(apply(id,id),id)
10:29:13 <MadHatterDude> I see...
10:29:16 <fax> whitespace in haskell applies things
10:29:26 <fax> just because you don't see it doesn't mean it's not there
10:29:26 <MadHatterDude> Cool. thanks. *haskell is awesome*
10:29:27 <kmc> MadHatterDude, every Haskell function has exactly one argument
10:29:30 <kmc> never zero, never more than one
10:29:42 <kmc> a "multi-argument function" takes a first argument and returns a function which takes a second argument
10:30:10 <MadHatterDude> kmc: Yeah, I get the single arg function thing, I was just slow on the syntactical implements.
10:30:19 <fax> ?
10:30:25 <kmc> that's why you can't translate it to C id(id, id)
10:30:38 <MadHatterDude> fax: I am working on a forbidden love child between haskell and APL
10:30:38 <texodus> kmc, what does that mean exactly, "isntance head"?
10:30:44 <fax> wow cool
10:30:51 <fax> I like the APL family
10:30:53 <uorygl> You know, Python is a neat language, in that both C-like code and Haskell-like code can be compiled into it pretty much directly.
10:30:55 <kmc> texodus, if i'm using it correctly (which is not certain), it means the stuff after the constraints
10:30:56 <MadHatterDude> fax: But I am not that far
10:31:02 <kmc> uorygl, except for all the static checking
10:31:07 <MadHatterDude> fax: and it won't be that advanced.
10:31:17 <MadHatterDude> gtg, dinner
10:31:19 <kmc> c_wraith, (A->A)->A is not a theorem of either classical or constructive logic
10:31:22 <uorygl> Right, static checking is lost.
10:31:31 <kmc> (unless either of those is inherently inconsistent)
10:31:46 <texodus> kmc, ok, so is not "[MyType]" mroe specific than "[a]"?  -XOverlappignInstances lets me declare the above isntances, it just cant choose between them when I call compare on a [MyType]
10:32:10 <kmc> texodus, hmm, i see
10:32:12 <kmc> i think you are right
10:32:14 <kmc> let me play with it
10:33:19 <texodus> ghc even marks "Ord [MyType]" as [overlap OK] in the error message
10:33:37 <texodus> but it seems totally decideable (to me, in my limited understanding)
10:33:48 <kmc> did you turn on -XUndecidableInstances?
10:33:52 <kmc> i think it's not necessary
10:34:05 <texodus> no, let me try
10:34:16 <kmc> that should be unrelated
10:34:43 <kmc> with my test case I get the more specific instance
10:34:52 <texodus> can I see you test case?
10:34:57 <texodus> maybe Im doing somethign stupid
10:35:22 <kmc> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25250#a25250
10:36:11 <texodus> thanks!
10:37:52 <kmc> texodus, ah, but i see what you wanted to do is a bit different
10:38:12 <texodus> only a bit
10:38:15 <texodus> in your example too though
10:38:19 <texodus> inst [1,2,3]
10:38:41 <kmc> inst ([1,2,3] :: [Int]) works
10:38:51 <kmc> the difficulty is that it's possible that [1,2,3] has type [T]
10:38:58 <texodus> aha
10:38:59 <kmc> if someone somewhere else added an instance Num T
10:39:04 <kmc> so it really is ambiguous
10:40:03 <texodus> i c
10:40:07 <texodus> that makes sense
10:40:53 <texodus> "[MyType]" shouldnt be ambiguous though - even if "instance Ord MyType" exists
10:41:03 <texodus> i think
10:41:17 <CyberGarp> I got a grammar specified in Happy, excepting files. Now it complains about shift/reduce errors and reduce/reduce errors on compile. How can I locate the rules causing these, other than deleting things from the grammar till they go away?
10:41:23 * hackagebot Combinatorrent 0.3.0 - A concurrent bittorrent client  http://hackage.haskell.org/package/Combinatorrent-0.3.0 (JesperLouisAndersen)
10:42:12 <kmc> texodus, the instance "(Ord a) => Ord [a]" in Prelude or whatever is not [overlap ok]
10:42:16 <kmc> so it's not willing to be overlapped
10:42:30 <kmc> that's because -XOverlappingInstances was not set when *that* module was compiled
10:42:38 <texodus> ah
10:42:46 <texodus> that makes sense then
10:43:13 <texodus> ok, thanks for you help!
10:43:55 <kmc> :)
10:44:49 <darq> hello. im a new to haskell and i would like to print out or (generate a list)  the tail of the list ... but tille the end .. example list ["img1","img2","img3"].. output [["img1","img2","img3"],["img2","img3"],["img3"]].. can somebofy tell me how to do it?
10:46:22 <Ytinasni> > tails ["img1","img2","img3"]
10:46:23 <lambdabot>   [["img1","img2","img3"],["img2","img3"],["img3"],[]]
10:46:31 <pastorn> @src tails
10:46:31 <lambdabot> tails []         = [[]]
10:46:31 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
10:47:36 <darq> thnx
10:49:26 <HugoDaniel> how do i define an instance of the Vector type class ?
10:49:34 <HugoDaniel> i want to have vectors of my data type
10:50:00 <FliPPeh> instance Vector YourType where
10:50:03 <FliPPeh> :x
10:50:41 <HugoDaniel> right
10:51:23 <HugoDaniel> now how do i do it with these methods: http://hackage.haskell.org/packages/archive/vector/0.6.0.1/doc/html/Data-Vector-Generic.html#t%3AVector ?
10:51:24 <HugoDaniel> hmm
10:51:37 <HugoDaniel> ill look at the source code to see how they did it for Int and whatnot
10:52:48 <dschoepe> Instead you can also define an instance of Storable for your data type which gives you a Vector instance for free
10:53:12 <HugoDaniel> ah, really ?
10:54:37 <dschoepe> yes, that's what the "Storable a => Vector Vector a" in the docs means.
10:55:02 <HugoDaniel> ah :)
11:05:47 <CalJohn> I'm adding -I/usr/include/poker-eval/ to GHC's command line, but it's not actually finding my includes, am I doing something wrong?
11:06:02 <CalJohn> (I'm using C2HS)
11:11:40 <Olathe> Are there any nice, simpler examples of compilers written in Haskell ?
11:11:52 <jmcarthur> tons
11:12:16 <Olathe> Any recommended ones ?
11:12:29 <jmcarthur> can't think of any in particular. sorry
11:12:32 <dolio> You want actual compilers?
11:12:36 <fax> O_o
11:12:40 <fax> tons ??
11:12:45 <Olathe> Yeah, it doesn't have to be Haskell compilers, just written in Haskell.
11:12:48 <jmcarthur> oh if you mean to machine code, i don't know of many
11:12:51 <fax> there isn't a single readable compiler written in haskell
11:12:57 <jmcarthur> fax: ?
11:13:12 <dolio> UHC is supposed to be built to be readable/understandable for easy extension.
11:13:27 <jmcarthur> http://notvincenz.blogspot.com/2007/06/simplistic-compiler-in-haskell.html
11:13:36 <fax> yeah but I wasn't able to add GADTs to UHC
11:13:38 <jmcarthur> just found that by googline
11:13:40 <jmcarthur> *googling
11:14:11 <uorygl> I once had a really vague idea for a compiler monad.
11:14:24 <uorygl> I think it was vague enough that I didn't really know whether it was supposed to be a monad or something else.
11:16:40 <jmcarthur> Olathe: just making sure you saw the link i pasted ^^
11:17:42 <fax> http://augustss.blogspot.com/
11:17:57 <fax> this is good actually but it is not something a beginner would undesrtand
11:18:36 <jmcarthur> indeed
11:19:08 <dolio> How about Epic? Is it readable?
11:19:23 <fax> I didnot bother trying because I couldn't compile it
11:19:40 <fax> maybe it will now
11:20:19 <jmcarthur> woah, hackage has prettified literate haskell source listings
11:20:23 <jmcarthur> never realized that
11:20:43 <dolio> Oh?
11:20:44 <jmcarthur> well, where "prettified" means "different font between code and prose"
11:20:49 <jmcarthur> http://hackage.haskell.org/packages/archive/epic/0.1.5/doc/html/src/Epic-Compiler.html
11:21:06 <jmcarthur> that's probably not the best example, but it's the one i noticed it in
12:00:10 <EvanR-work> @src Num
12:00:10 <lambdabot> class  (Eq a, Show a) => Num a  where
12:00:10 <lambdabot>     (+), (-), (*)           :: a -> a -> a
12:00:10 <lambdabot>     negate, abs, signum     :: a -> a
12:00:10 <lambdabot>     fromInteger             :: Integer -> a
12:00:12 <EvanR-work> @src Integral
12:00:13 <lambdabot> class  (Real a, Enum a) => Integral a  where
12:00:13 <lambdabot>     quot, rem, div, mod :: a -> a -> a
12:00:14 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
12:00:15 <lambdabot>     toInteger           :: a -> Integer
12:05:04 <EvanR-work> Nums have addition and additive inverse, Integral has division
12:09:40 <EvanR-work> @hoogle a -> a -> Bool -> a
12:09:41 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
12:09:41 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
12:09:41 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
12:10:44 <chrisdone> seems like rss2irc doesn't reconnect when it loses connection to the ircd. i thought it was my hpaste feed grabber but that's been chugging along going fine for weeks i can see in the screen session. i was gonna bring the rss2irc bot back but it looks like there's been loads of spam recently
12:11:12 <CalJohn> Is there any way to get GHC to link my files with .so files?
12:11:25 <CalJohn> (and still be static?)
12:11:36 <CalJohn> or is that stupid
12:12:50 <monadic_kid> what be static?
12:12:54 <chrisdone> i believe .a files are static libraries and .so are dynamic
12:13:04 <monadic_kid> chrisdone: yes it is
12:13:37 <chrisdone> so i suspect one does not link to dynamic libraries statically
12:14:37 <monadic_kid> you can have a statically library using symbols from a dynamic library
12:15:05 <CalJohn> monadic_kid: that sounds like what I would want
12:15:07 <monadic_kid> you can have a statically linked application that dynamically links to CRT
12:15:31 <CalJohn> there is a foo.so file provided by my distro, and I would like to use the contents of it to create a static ghc binary (with the ffi)
12:15:32 <chrisdone> what is CRT?
12:15:43 <monadic_kid> c-runtime
12:16:17 <CalJohn> monadic_kid: is that possible?
12:17:01 <EvanR-work> is there a way to make data 'inherit'. that is, this data has all the same fields as another data, plus some more
12:17:32 <monadic_kid> CalJohn: you want to make a Haskell binding basically, when you making a binding it's going to be statically linked package unless you make that a dynamically library
12:17:40 <chrisdone> EvanR-work: not in standard Haskell 98 / without boilerplate code or generators
12:18:14 <monadic_kid> CalJohn: you're trying to write a binding to a C/C++ library?
12:18:16 <chrisdone> (I meant not in standard haskell 98 + ghc extensions)
12:18:22 <CalJohn> monadic_kid: yes, exactly that
12:18:39 <EvanR-work> i suppose thats not very interesting. but in principle you could pass a specialized data to one that accepts the base
12:18:52 <EvanR-work> not sure if it would be useful though
12:19:05 <CalJohn> monadic_kid: and i can still do that against .so files?
12:19:07 <monadic_kid> CalJohn: yes your binding library doesn't need to be shared libary(.so)//DLL
12:20:10 <monadic_kid> CalJohn: does this .so come with an import library? if not then you're going to have to dynamically load the symbols yourself in C I guess
12:20:39 <monadic_kid> CalJohn: so shared libraries come import libraries (a statically library) makes it easy to use
12:20:42 <CalJohn> I'm not sure what an import library is, monadic_kid
12:20:50 <CalJohn> oh no, it doesn't
12:21:10 <CalJohn> that would be .a
12:21:12 <CalJohn> right?
12:21:46 <ologNation> Does anyone use the module Ratio?
12:21:49 <chrisdone> EvanR-work: you can do it quite well with type classes if you don't mind writing accessors and updaters yourself
12:21:50 <ologNation> That looks like a  pretty good idea.
12:22:24 <EvanR-work> chrisdone: i figured as much, but it seems too java
12:22:35 <chrisdone> jninja: you are the first ninja I've ever seen coming
12:22:42 <monadic_kid> CalJohn: yep. it just makes it easier to use a shared library/DLL. If can get one (usually you get them with devel packages in linux) then you have to write code which dynamically loads and binds function ptrs to the dll
12:23:18 <monadic_kid> CalJohn: I mean if you can't get one
12:24:07 <EvanR-work> can a data be uninitialized, like in C
12:24:17 <ddarius> EvanR: No.
12:24:19 <CalJohn> monadic_kid: this is the filelist of the library I am trying to bind: packages.debian.org/squeeze/i386/libpoker-eval-dev/filelist
12:24:33 <EvanR-work> i get a weird warning if using record syntax and not filling out all fields
12:24:38 <EvanR-work> is that an error?
12:24:45 <ljungk> hi, what is it possible to have multiple patterns in a "case" construct share the same result? Like the ptrn1|prtn2) in bash.
12:24:52 <Miller`> is `ceiling . sqrt . fromIntegral n` invalid because `fromIntegral n` is not a function, but `ceiling . sqrt . fromIntegral $ n` is valid because it causes the `n` to be fed as an argument to `ceiling . sqrt . fromIntegral` instead of  just `fromIntegral`?
12:25:04 <fax> yes
12:25:17 <Miller`> fax: thanks
12:25:19 <benmachine> ljungk: no, but it's usually simple to give the result a name and then use it multiple times
12:25:31 <EvanR-work> n >$> fromIntegral >$> sqrt >$> ceiling ;)
12:26:00 <ljungk> benmachine:okay
12:26:08 <benmachine> ljungk: also, a wildcard _ pattern will match anything of course
12:26:11 <ddarius> EvanR-work: Uninitialized fields of a record get filled with the value undefined.
12:26:25 <EvanR-work> ah
12:26:26 <EvanR-work> cool
12:27:07 <ologNation> What I would really like to see is a simple example of how to declare a rational number.
12:27:15 <EvanR-work> > 5 % 4
12:27:15 <lambdabot>   5 % 4
12:27:29 <Miller`> EvanR-work, what is the `>$>` called ?
12:27:54 <tensorpudding> @hoogle (>$>)
12:27:55 <lambdabot> No results found
12:27:56 <EvanR-work> Miller`: i dont know, i dont think its a standard function. let x >$> f = f x
12:28:19 <Miller`> ah, okay
12:28:35 <tensorpudding> @hoogle a -> (a -> b) -> b
12:28:36 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
12:28:36 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
12:28:36 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
12:28:38 <ologNation> EvanR, cool.
12:29:08 <EvanR-work> let (>$>) = flip ($)
12:29:27 <burp> >_>
12:30:27 <monadic_kid> CalJohn: I don't know about that library but typically in linux distributions the packages for libraries they usually have two packages to install, one is just the binraries and would be called say "SDL" the other is the dev which contains headers and typically static import libraries and would called "SDL-devel", see if your package manager has a "devel" version of your library, you're probably going to need it for the headers anyways
12:31:37 <CalJohn> monadic_kid: ok, the debian convention for this is -dev, and there is no .a file :(
12:31:54 <CalJohn> monadic_kid: is there anything extra I have to do now?
12:33:56 <monadic_kid> CalJohn: yes you're going to need to write a bit of boiler plate code (you have to do this  irregardless of haskell because of the lack of import libraries) okay you need to dynamically link and bind symbols yourself which is platform specific, linux you would use dlopen, you need to get get the address of all the functions inside the shared library and map them to function ptrs
12:34:06 <ologNation> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25254#a25254
12:34:21 <ologNation> I'm still not sure how this module Ratio works,
12:34:24 <ologNation> but it seems really cool.
12:34:33 <EvanR-work> @vixen irregardless
12:34:33 <lambdabot> do you have toys?
12:35:14 <EvanR-work> im going to start proudly using the world irregardless
12:35:27 <EvanR-work> word
12:36:20 <monadic_kid> okay you had your fun but i'm trying to help someone so it's not funny
12:37:26 <ologNation> What's wrong with saying:
12:37:27 <ologNation>  let c = map (\x -> (a%x)) [1..19]
12:37:28 <ologNation> ?
12:37:52 <EvanR-work> take a chill pill
12:37:57 <benmachine> monadic_kid: you don't have to use dlopen for all dynamic linking, just runtime
12:37:57 <ologNation> Or maybe I'm conflating % and /.
12:38:03 <EvanR-work> ologNation: nothing?
12:38:10 <fax> :t map (\x -> (a%x)) [1..19]
12:38:11 <EvanR-work> except a may not be defined
12:38:11 <lambdabot> [Ratio Expr]
12:38:19 <ologNation> EvanR-work,
12:38:29 <ologNation> Yeah, I think it was because a was defined as (3%5).
12:38:30 <monadic_kid> benmachine: he doesn't have an import library
12:38:37 <ologNation> I got confused because in other languages, you use % to divide.
12:38:38 <EvanR-work> ologNation: check type of %
12:38:41 * ologNation is fixing it up. 
12:38:42 <EvanR-work> :t (%)
12:38:43 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
12:38:47 <ologNation> EvanR-work,
12:38:49 <ologNation> Good idea.
12:38:54 <ologNation> --oh.  You just did it.
12:38:57 <ologNation> Cool.
12:38:57 <benmachine> oh
12:38:58 <ologNation> That's great.
12:39:06 <CalJohn> monadic_kid: i think this could be way over my head...
12:39:21 <CalJohn> I'm looking up up dlopen
12:39:38 <monadic_kid> CalJohn: it's not that tricky really, but it would be alot easier if you had an import library for that shared library
12:39:44 <benmachine> dlopen is pretty scary
12:41:59 <EvanR-work> ologNation: if you are talking about modulo, thats `mod`
12:42:06 <EvanR-work> > 5 `mod` 4
12:42:07 <lambdabot>   1
12:42:12 <Zao> Or `rem`
12:42:16 <Zao> Depending on intended semantics.
12:42:32 <EvanR-work> > (-5) `rem` 4
12:42:33 <lambdabot>   -1
12:42:36 <CalJohn> monadic_kid: I have the source for this library (uses the gnu configure/make stuff).  Is there any way to generate an import library from this?
12:42:45 <benmachine> `mod` is usually what you want if you're a mathematician
12:42:58 <EvanR-work> Zao: i thought remainder was always between 0 and divisor
12:43:11 <EvanR-work> for positive divisor
12:43:40 <benmachine> EvanR-work: that'll be the "intended semantics" comment
12:43:43 <Zao> EvanR-work: The semantics differ for negative integers, I believe.
12:43:57 <benmachine> what you say is true of mod and not rem
12:44:04 <monadic_kid> CalJohn: check the configure options "./configure --help"
12:44:13 <EvanR-work> my book calls it remainder, i guess its not the same as rem in haskell
12:44:48 <monadic_kid> CalJohn: it probably will generate one if you build it yourself
12:44:56 <benmachine> the relevant invariant is y * (x `div` y) + x `mod` y == x
12:45:03 <benmachine> this is true of div/mod and quot/rem but in different ways
12:46:48 <CalJohn> monadic_kid: there is an --enable-static flag, but I can't see any .a's that have been generated
12:47:08 <ologNation> What is 341726920908004537603880/379695691490363214074299
12:47:09 <ologNation> ?
12:47:16 <fax> > 341726920908004537603880/379695691490363214074299
12:47:17 <lambdabot>   0.9000021031755048
12:47:41 <monadic_kid> CalJohn: did you do make after configure?
12:48:02 <EvanR-work> > 341726920908004537603880 % 379695691490363214074299
12:48:03 <lambdabot>   341726920908004537603880 % 379695691490363214074299
12:48:22 <EvanR-work> olog's number
12:48:31 <ologNation> I am not olog.
12:48:35 <ologNation> wait.
12:48:36 <ologNation> I am.
12:48:39 <ologNation> I am not oleg.
12:48:52 <monadic_kid> CalJohn: i think that --enable-static flag will probably just make that library complete static library. I don't know if that is what you want, depending on the license
12:49:33 <CalJohn> it's GPLv3, and I don't might that, I think it was probably on when I first ran make (by default), but I'm running again just to be sure
12:50:09 <monadic_kid> configure, make and make install
12:51:20 <EvanR-work> > gcd 3 6
12:51:21 <lambdabot>   3
12:51:25 <CalJohn> monadic_kid: libpoker-eval.a <-- success!
12:51:29 <EvanR-work> > gcd 341726920908004537603880 379695691490363214074299
12:51:30 <lambdabot>   1
12:53:55 <CalJohn> monadic_kid: I'm using -L/usr/local/lib -lpoker-eval, but I'm still getting a linker error, are those the wrong options?
12:54:26 <ologNation> Here's a question.
12:54:40 <ologNation> How do i get the numerator and denom back as an integer?
12:54:44 <ologNation> a = 3%4
12:54:50 <ologNation> > let a = 3%4
12:54:51 <lambdabot>   not an expression: `let a = 3%4'
12:55:15 <ologNation> (numerator (3%4))/(denominator(3%4))
12:55:20 <monadic_kid> CalJohn: it looks okay
12:55:21 <ologNation> >(numerator (3%4))/(denominator(3%4))
12:55:27 <aavogt> @hoogle Rational a -> a
12:55:28 <lambdabot> Did you mean: Rational -> a /count=20
12:55:28 <lambdabot> No results found
12:55:33 <aavogt> @hoogle Ratio a -> a
12:55:34 <lambdabot> Data.Ratio denominator :: Integral a => Ratio a -> a
12:55:34 <lambdabot> Data.Ratio numerator :: Integral a => Ratio a -> a
12:55:34 <lambdabot> Prelude id :: a -> a
12:56:05 <aavogt> ologNation: but  /   doesn't work for Integer
12:56:13 <tensorpudding> > let num (a % _) = a, denom (_ % b) = b in (num (1 % 2)) % (denom (1 % 2))
12:56:14 <lambdabot>   <no location info>: Parse error in pattern
12:56:17 <tensorpudding> err
12:56:23 <CalJohn> monadic_kid: http://privatepaste.com/8188ac53cf <- here is some more information
12:56:23 <tensorpudding> > let num (a % _) = a; denom (_ % b) = b in (num (1 % 2)) % (denom (1 % 2))
12:56:24 <lambdabot>   <no location info>: Parse error in pattern
12:56:25 <ologNation> gotta run.
12:56:28 <ologNation> Be back in an hour.
12:56:31 <ologNation> >1/2
12:59:33 <aavogt> @hoogle Ratio a -> (a,a)
12:59:34 <lambdabot> System.Random split :: RandomGen g => g -> (g, g)
12:59:34 <lambdabot> Network.BufferType buf_span :: BufferOp a -> (Char -> Bool) -> a -> (a, a)
12:59:34 <lambdabot> Network.BufferType buf_splitAt :: BufferOp a -> Int -> a -> (a, a)
12:59:39 <monadic_kid> CalJohn: I think maybe it's the order, try ghc -L'...' -l... --make Foo.hs
13:00:11 <EvanR-work> ologNation: let (a%b) = 5%4 in (a,b) :: (Integer, Integer)
13:00:17 <EvanR-work> > let (a%b) = 5%4 in (a,b) :: (Integer, Integer)
13:00:18 <lambdabot>   <no location info>: Parse error in pattern
13:00:20 <EvanR-work> :(
13:02:04 <tensorpudding> ...why isn't this working...
13:02:25 <shapr> Needs more Olegs
13:03:25 <tensorpudding> Can you not pattern match on Ratio's at all?
13:03:48 <BMeph> NEED MOAR OLEGS!!!!11!11eins1!1
13:04:16 <tensorpudding> Oh wait, Data.Ratio doesn't export the constructor?
13:04:30 <shapr> Yes, I think the complexity of your type system is (O)leg
13:04:51 <CalJohn> monadic_kid: hmm, still nothing
13:08:50 <monadic_kid> CalJohn: try something simple without make, make a dummy C program and try and link it.
13:09:31 <mmmdonuts> shapr: shouldn't that be O(leg) ?
13:09:32 <monadic_kid> CalJohn: link it to your static library
13:09:36 <shapr> mmmdonuts: Oh right
13:09:48 <shapr> the complexity of your type system is O(leg)
13:09:50 <shapr> hmm
13:11:39 <CalJohn> monadic_kid: gcc linking works fine with the dummy program
13:12:11 <CalJohn> wait, maybe not
13:14:40 <BMeph> Ah, the joys of Windows...BRB, rebooting. :(
13:16:09 <gwern> I love rebooting. I can watch people do it from my linux box all day
13:16:43 <fax> lol
13:17:42 <CalJohn> monadic_kid: thanks so much, I've finally gotten everything working!
13:22:29 <monadic_kid> CalJohn: no worries
13:22:44 <whald_> assume there is a person who has understood how State / runState works -- how would you explain that person ST / runST?
13:23:59 <patch-tag>  :t Data.Text.Lazy.IO.readFile :: Data.Text.Lazy.IO.readFile :: FilePath -> IO text-0.7.1.0:Data.Text.Lazy.Internal.Text
13:24:04 <EvanR-work> its State on steroids
13:24:14 <EvanR-work> STeroids if you will
13:24:26 <whald_> State on crack is my guess... :-)
13:24:31 <monadic_kid> whald_: ST monad gives you localized mutable cells inside a pure function, pure on the outside, dirty on the inside
13:24:39 <patch-tag> why does the lazy version use the internal type, whereas the strict version of Text IO just using plain Data.Text type?
13:24:53 <patch-tag> and how can I get from internal type to regular type when using Data.Text?
13:25:11 <whald_> i have something similar to http://www.haskell.org/all_about_monads/examples/example15.hs
13:25:28 <whald_> i have no problem with that
13:25:40 <whald_> except StdGen is really slow
13:26:02 <whald_> so i want to swap StdGen for System.Random.MWC
13:26:17 <patch-tag> also the internal type doesn't appear to be reflected in the haddock: http://hackage.haskell.org/packages/archive/text/0.7.1.0/doc/html/Data-Text-Lazy-IO.html
13:26:48 <whald_> which brings me away from State and forces me to use ST because of some PrimState restriction I have no clue what it means in the first place
13:28:22 <patch-tag> (now asking about this on cafe)
13:45:58 <patch-tag> What's a good way to incrementally process a large (multigb) file one line at a time?
13:46:05 <EvanR-work> hmm i wonder if >=> is useful
13:46:16 <patch-tag> If I use readFile that puts the whole thing in memory, right? whether strict or lazy version doesn't matter
13:46:19 <bluetaslem> Isn't Haskell (for large applications ) typically embedded within an imperative program?
13:46:49 <ddarius> patch-tag: The lazy version won't put the whole file in memory.
13:47:08 <bluetaslem> That is to say, a language like C++ will call on Haskell to solve a problem, while the bulk of the program is in C++?
13:47:14 <bluetaslem> Would I be right?
13:47:19 <mauke> bluetaslem: I've never seen that
13:47:29 <bluetaslem> Hm, well, in short..
13:47:42 <patch-tag> ddarius, hm, I'll try readFile then.
13:47:48 <bluetaslem> Although it goes against common sense, for fun, I'm making a parser in Haskell that can run a weird sort of imperative syntax.
13:47:52 <benmachine> EvanR-work: that's an odd sort of thing to wonder
13:48:15 <benmachine> patch-tag: many people will try to tell you that lazy IO is evil
13:48:19 <daviddarais> bluetaslem: that's not all that uncommon
13:48:30 <benmachine> they've got a point sort of; if you feel like learning something new maybe you should look at iteratee
13:48:33 <benmachine> s
13:48:37 <benmachine> they seem to be the "in thing"
13:48:43 <bluetaslem> As an imperative language? I doubt that.
13:49:09 <fax> Some C++ programmers, when encountering a problem  think "I'll embed haskell". Now they have two problems
13:50:08 <daviddarais> bluetaslem: are you talking about using haskell as an imperative language or using it to parse or interpret imperative syntax? both uses are common
13:50:25 <bluetaslem> Parse an imperative syntax.
13:50:57 <daviddarais> so, like parsing C syntax using haskell?
13:51:29 <benmachine> there's actually a library for that
13:51:29 <bluetaslem> Not C, a sort of simplified language.
13:52:05 <bluetaslem> I like Haskell's type system and operand system, so I'll incorporate them into it.
13:53:34 <BMeph> bluetaslem:  Check out augustss.blogspot.com with tags C, BASIC or LLVM.
13:54:10 <benmachine> BASIC >_>
13:54:12 <bluetaslem> ?
13:54:23 <bluetaslem> Well, I have to go. Bye.
13:54:39 <BMeph> benmachine: Yes, Lennart's a tricksy hobbit. ;)
13:55:46 <fax>                     http://www.youtube.com/watch?v=9Yrt9qkBQ2Q
13:55:52 <fax> lurgh
13:55:56 <fax> I didn't mean to past that
13:56:05 <patch-tag> How can I get a value of type GHC.Word.Word8, ie, so I can split a bytestring on newlines using Data.ByteString.Word8.split?
13:56:27 <patch-tag> Data.Text would be perfect here, except I can't seem to use the lay version due to some silly thing I mentioned earlier
13:57:53 <c_wraith> patch-tag: the internal type is the same type as the external one
13:57:56 <Liskni_si> MarcWeber: any news regarding the patch I gave you a week or two ago?
13:58:01 <c_wraith> the main library just re-exports the type
13:58:07 <mauke> patch-tag: Data.ByteString.Char8.split :: Char -> ByteString -> [ByteString]
13:58:18 <c_wraith> So ghci is showing you the original location of the type.  but it's the same thing
13:58:18 <patch-tag> oh ok
13:58:38 <patch-tag> never mind
14:06:00 <edwardk> patch-tag: you can also import the Char8 version... oh wait mauke beat me to it
14:11:15 <ologNation> Can someone remind me the name of a channel on which to ask a general question about using Debian (say Ubuntu)
14:11:41 <_2x2l> #ubuntu ....
14:12:59 <ologNation> _2x2l, Thanks.
14:13:07 <mreh> ologNation: doesn't your client list all the channels?
14:13:13 <ologNation> There was another one.   I don't remember the name.  Something for general for linux..
14:13:18 <ologNation> Hmm..
14:13:23 <ologNation> I'm using Xchat.
14:13:36 <ologNation> mreh, There it is.
14:14:01 <mreh> ologNation, me too :)
14:16:35 <ologNation> Wow.  There are a lot of channels.
14:16:42 <ologNation> It's like having a list of urls for the internet.
14:17:25 <mreh> ologNation, it's only one server, not hard to do... sorry to destroy the magic
14:17:32 <c_wraith> freenode is a rather large network.  Many networks have smaller channel lists. :)
14:17:52 <mreh> s/server/network/
14:19:25 <edwardk> patch-tag regarding the lazy version, check my answer on haskell-cafe ;)
14:26:55 <scotty> Why can't I do the following?: http://pastebin.com/hNgRQkn7  Also, I know that I can just put 2 * x inside the list comprehension.
14:27:23 <edwardk> preflex: xseen copumpkin
14:27:23 <preflex>  copumpkin was last seen on freenode/#haskell-blah 3 hours, 29 minutes and 59 seconds ago, saying: sounds like they made it up
14:27:45 <fax> > [ 2 * x | x <- [1..10]]
14:27:46 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
14:27:49 <fax> Yes We Can!
14:28:14 <scotty> fax: I just said I knew I could do that.  There's a reason I want to do what I did.
14:28:16 <mauke> scotty: because x is not in scope there
14:28:22 <mauke> we don't have dynamic scope
14:28:25 <ddarius> > map (2*) [1..10]
14:28:25 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
14:28:40 <scotty> Ah
14:28:55 <scotty> ddarius: You just gave me what I was looking for.
14:29:09 <mauke> what, a function?
14:29:20 <ologNation> scotty, Maybe a space?
14:29:23 <scotty> I just wanted to clean up my list comprehension, but I couldn't think of how to do it.
14:29:34 <ologNation> s/tx/t x/
14:29:38 <fax> scotty: lol I read it is "I know I can't just put 2 * x in ..."
14:29:44 <fax> why do I do that sometiems
14:29:51 <scotty> Oh
14:29:54 <ddarius> fax: Because you are fallible.
14:30:10 <fax> yeah but much more fallible than normal people
14:30:12 <scotty> Yeah, it makes sense that you shouldn't be able to do it because of scope I guess.
14:31:12 <scotty> I don't know why I didn't think of using a map.  I'm still new to haskell and I don't always have that insight.
14:31:31 <fax> > [2,4..20]
14:31:32 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
14:31:33 <ologNation> scotty, It works for me if I put the space there.
14:31:52 <scotty> ologNation: What works?
14:31:57 <mauke> t x
14:32:16 <ologNation> Uh.. I just copied your code into emacs and then put spaces and ran it and it worked.
14:32:25 <scotty> Oh, yeah, of course!
14:32:27 <ologNation> s/tx/t x/
14:32:33 <scotty> 'Cause now t is a function.
14:32:36 <ologNation> yep.
14:32:46 <edwardk> copumpkin: did my xseen to preflex summon you or did I just have good timing? =)
14:32:47 <scotty> It's just another way to do something map-like.
14:32:55 <scotty> It's actually prettier.
14:33:04 <mauke> edwardk: the former
14:33:06 <copumpkin> edwardk: I had a sudden urge to come on IRC, so I think it's your mental powers
14:33:24 <copumpkin> :)
14:33:26 <edwardk> copumpkin: glad to see they are still good for something. god knows i have enough trouble trying to use them to solve problems ;)
14:33:27 <mauke> huhu
14:35:22 <scotty> Also, I need some programming advice.  I was wondering, do any of you all impose a limit on the number of characters you will use to name a function?  What's a better than "sphericalToCartesian?"  "sphereToCart?" XD
14:35:36 <fax> sphericalToCartesian is MUCH MUCH better than sphereToCart
14:35:52 <scotty> But it's sooo long!
14:36:06 <scotty> Maybe stoc! :-P
14:36:10 <scotty> lol
14:36:11 <fax> you could call it (Spherical --> Cartesian)
14:36:24 <fax> assuming --> is a valid operator ..
14:36:36 <scotty> And define Spherical and Cartesian as type constructors for a point?
14:36:42 <fax> they are names
14:36:58 <fax> data CoordinateSystem = Spherical | Cartesian | Cylindrical
14:37:08 <scotty> Uh-huh.
14:37:21 <twink> There's always "s2c"
14:37:34 <scotty> What is "-->?"  I don't know if I've seen that.
14:37:39 <fax> what do you mean by "Uh-huh"
14:37:41 <poucet> or simply squarify
14:37:54 <scotty> fax: I thought there was more. XD
14:38:24 <scotty> fax: Now that it seems there is not, I must know what "-->" is.
14:38:32 <fax> (-->) :: CoordinateSystem -> CoordinateSystem -> Vector 3 -> Vector 3
14:38:44 <sepp2k> Wouldn't --> be a comment saying ">" ?
14:39:26 <copumpkin> or you could parametrize your vector type by the coordinate system
14:39:45 <copumpkin> convert :: Vector a 3 -> Vector b 3
14:40:10 <scotty> Yeah, I don't know if I like that, but I still don't understand what fax is doing even though it looks pretty.
14:40:13 <copumpkin> where Vector is a GADT in a language other than haskell that supports type-level number literals :P
14:40:32 <fax> lol
14:41:50 <scotty> fax: Can you explain or refer me to an explanation of "-->?
14:42:05 <scotty> fax: It's not the same as "->," right?
14:42:20 <scotty> Oh wait
14:42:22 <fax> The best thing is to call it sphericalToCartesian
14:42:23 <scotty> I'm stupid.
14:42:45 <twink> I'm holding out for "s2c"
14:42:45 <scotty> I see you just defined it yourself.  I thought it was a part of the language or something.
14:43:22 <scotty> I don't yet know all of Haskell's syntax, so I assumed it was part of the language.
14:43:50 <mreh> isn't it C++ where you can overload operators arbitrarily but not define new ones
14:44:22 <scotty> Yeah
14:44:52 <mreh> that must result in some serious programming lulz
14:44:59 * cizra saw the light.
14:45:03 * cizra saw the beauty of monads.
14:45:41 <cizra> mreh: O yes. Try overloading comma, for example.
14:48:45 <scotty> fax: Are you saying that Vector is a constructor where the first argument is the number of elements?
14:49:10 <fax> scotty, I just invented Vector because you didn't name the type you are using to represent coordinates
14:49:22 <scotty> Right, but you wrote "Vector 3."
14:49:38 <scotty> Wouldn't the 3 have to be an argument?
14:49:41 <dv-> That's an interesting idea actually
14:49:50 <fax> scotty: well I assume you're working in 3D
14:50:45 <scotty> fax: Yes, you're right.  I'm just trying to figure out what it is you implied.  I was just using (Double, Double, Double).
14:51:05 <fax> (-->) :: CoordinateSystem -> CoordinateSystem -> (Double, Double, Double) -> (Double, Double, Double) then
14:51:36 <scotty> Right, I know.  I was just interested in what you would call Vector.
14:51:56 <mreh> (Double, Double, Double) is the perfect candidate for some moar abstraction
14:52:14 <scotty> Yessss
14:52:31 <timofonic> Double p...
14:53:16 <scotty> I don't have enough control to stop myself from writing the most general fucking program I can! :P  Also, I want to get better at programming in Haskell, so I can afford to be less pragmatic.
14:55:15 <mreh> i was just suggesting a synonym for (Double, Double, Double)
14:55:23 <mreh> but yeah, make a typeclass
14:55:29 <copumpkin> might as well unbox those unless you have reason not to
14:55:41 <copumpkin> or at least strictify them
14:55:41 <ddarius> A type like data Vector3 = V3 !Double !Double !Double would be better in many ways.
14:55:59 <mreh> how does one unbox something?
14:56:08 <mreh> i go for the ! pattern
14:56:28 <fax>  im scared of the !'s
14:56:45 <ddarius> fax: Then you are silly.
14:56:51 <copumpkin> adding bangs means that you can -funbox-strict-fields
14:56:53 <lpsmith> don't fear the bang pattern
14:56:54 <fax> :P
14:56:59 <copumpkin> embrace the bang
14:57:16 <c_wraith> why isn't unboxing strict fields the default?
14:57:34 <ddarius> Because it can have negative performance implications in some cases.
14:57:47 <c_wraith> can it reduce opportunities for sharing in some cases?
14:57:58 <copumpkin> you can't share
14:58:25 <fax> sharing is caring
14:59:04 <jmcarthur> ! rocks
14:59:24 <jmcarthur> i prefer it in ADTs than patterns though
14:59:55 <mreh> yeah, that's what I meant
15:00:10 <c_wraith> If it prevents sharing, that definitely does have performance implications in some cases.
15:00:24 <c_wraith> Is there any way to tell it to unbox just some fields? >_>
15:00:32 <jmcarthur> yes
15:00:37 <c_wraith> Even while making them all strict?
15:00:46 <ddarius> Sure.
15:00:46 <copumpkin> {-# UNBOX #-}
15:00:47 <jmcarthur> data Foo = Foo {-# UNPACK #-} !Int !Int
15:00:50 <copumpkin> oh yep
15:00:53 <c_wraith> aha.  cool.
15:00:54 <jmcarthur> the first is unboxed and the second is not
15:01:00 <copumpkin> I still don't understand the varying terms for it
15:01:04 <mreh> oh, that's what that means
15:01:06 <copumpkin> we should be consistent
15:01:15 <jmcarthur> copumpkin: yeah i don't get it either
15:01:31 <copumpkin> or maybe adopt the principle of least surprise :P
15:01:36 <copumpkin> understand both of them
15:01:42 <copumpkin> -funpack-strict-fields
15:01:52 <copumpkin> same with -X language markers
15:08:52 <scotty> Whoa, it looks like someone already hit on what we were talking about: http://www.haskell.org/pipermail/haskell-cafe/2010-March/074734.html
15:09:06 <scotty> And only a month ago!
15:11:25 <daviddarais> nice find
15:12:52 <sepp2k> It appears that loading haskell-mode in emacs sets my delete-selection-mode setting to false for some reason. Did that ever happen to anyone else? Is there a way to fix that?
15:18:41 <jao> (add-hook 'haskell-mode-hook '(lambda () (delete-selection-mode 1)))
15:18:47 <jao> (but that's a bit rough)
15:19:38 <sepp2k> jao: Thank you very much. Any idea why the setting is changed in the first place?
15:21:09 <jao> sepp2k: no, i'm afraid not
15:22:55 <jao> sepp2k: also, it could be haskell-indentation-mode instead of haskell-mode
15:23:06 <scotty> Is there something in prelude that takes [1,2] and [3,4] and gives [1,3,2,4]?  Alternatively, how might I specify elements two at a time in a list comprehension (eg. [x, 42 | x <- [1, 2, 3]] = [1, 42, 2, 42, 3, 42])?
15:23:52 <sepp2k> jao: Adding the hook fixed it, thanks.
15:25:27 <sepp2k> > concat [ [x,42] | x <- [1,2,3] ]
15:25:28 <lambdabot>   [1,42,2,42,3,42]
15:26:25 <scotty> > concat [[1],[2]]
15:26:26 <lambdabot>   [1,2]
15:26:39 <scotty> sepp2k: Thanks!
15:26:55 <sepp2k> np
15:27:55 <BMeph> > concat (zipWith (\x y -> [x,y]) [1,2] [3,4])
15:27:57 <lambdabot>   [1,3,2,4]
15:28:41 <BMeph> Ooh, look at the time, gotta go spend my paycheck... :)
15:30:26 <scotty> > :t zipWith
15:30:27 <lambdabot>   <no location info>: parse error on input `:'
15:30:33 <Cale> :t zipWith
15:30:34 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
15:30:43 <_2x2l> in haskell, what's () called? unit?
15:30:49 <Cale> > zipWith (+) [1,2,3,4] [10,20,30,40]
15:30:50 <lambdabot>   [11,22,33,44]
15:30:56 <sepp2k> _2x2l: Yes.
15:31:05 <Cale> _2x2l: Yeah, or I tend to call it "the empty tuple"
15:31:12 <sepp2k> :t ()
15:31:13 <lambdabot> ()
15:31:39 <sepp2k> Ok, I was kinda expecting it to say Unit...
15:32:43 <rizzix> yep its called ()
15:32:58 <scotty> > zipWith (\x y -> [1,2,3]) [0,0] [0,0]
15:32:59 <lambdabot>   [[1,2,3],[1,2,3]]
15:33:30 <kmc> data Unit = Unit
15:33:37 <copumpkin> > Unit :: 1
15:33:38 <lambdabot>   No instance for (GHC.Show.Show GHC.Generics.Unit)
15:33:38 <lambdabot>    arising from a use of ...
15:34:25 * ddarius calls it exists a. a
15:34:41 <ddarius> Or the colimit over all objects.
15:35:13 <kmc> exists a. a doesn't have decidable equality ;P
15:35:40 <ddarius> kmc: a == b = a `seq` b `seq` True
15:35:48 <kmc> ;P
15:36:12 <sungji> can anyone tell me, how many cases have to be covered in order to be able to use the induction hypothesis to prove the following statement by using strong induction: http://gist.github.com/385844
15:36:14 <sungji> ?
15:36:24 <ddarius> Your instructor probably can.
15:37:44 <kmc> that's not actually valid haskell
15:37:58 <kmc> it's a clever trick though
15:38:39 <zachk> kmc: whats the trick
15:38:52 <kmc> to rewrite maths homework so it looks like Haskell
15:38:57 <kmc> and ask about it here
15:38:57 <fax> hahaha
15:38:59 <zachk> ahhhh
15:39:11 <sungji> hang on a  second...
15:39:14 <fax> sungji: N Leaf = H Leaf though
15:39:26 <fax> sungji: oh nvm I am making mistakes AGAIN
15:39:33 <kmc> i think you'd want n Leaf = 1
15:39:38 <fax> 2^0 = 1
15:39:43 <sungji> kmc, check again
15:39:59 <fax> sungji, to be proper haskell N and H should be n and h
15:40:06 <kmc> n Leaf = 1; n (Node x y) = n x + n y + 1
15:40:12 <zachk> otherwise haskell would think they are types
15:40:15 <bolmar> sungji: the general case and a specific one
15:40:24 <kmc> h Leaf = 0; h (Node x y) = 1 + (max (h x) (h y))
15:40:39 <fax> sungji, let us define P(t) := (N t) < 2^(H t),  now P :: Tree -> *
15:41:18 <fax> sungji, we would like to prove forall t, P(t), so lets use induction: P(Leaf) and (forall t1 t2, P(t1) and P(t2) ==> P(Node t1 t2)) ==> forall t, P(t)
15:41:58 <fax> is that clear?
15:42:16 <sungji> fax, yes... so you wouldn't use strong induction?
15:42:44 <fax> sungji: :(
15:43:20 <sungji> fax, forall m < n . P(m)
15:43:35 <fax> sungji, I was quite happy with my way
15:44:30 <sungji> fax, ok :) hm.... I was wondering how the proof works when strong induction is being used
15:44:48 <fax> sungji: are you saying that the induction method I suggested doesn't work
15:44:57 <fax> sungji: Or does your problem sheet say "use strong induction"?
15:45:30 <lpsmith> Is there a convenient and efficient way to convert ints to bytestrings?
15:46:33 <ddarius> lpsmith: Use Binary(?)
15:47:46 <lpsmith> hmm.
15:48:58 <sungji> fax, it's saying "prove by induction" ... I was just wondering how one could use strong induction to prove it
15:49:06 <lpsmith> ddarius, I want   BS.pack . show,  basically
15:49:13 <fax> sungji: Have you done it the way I suggested yet?
15:49:22 <lpsmith> except more efficient, if possible
15:50:04 <copumpkin> use a proof assistant
15:50:33 <ddarius> Bash head against proof assistant.  Repeat until proved.
15:50:40 <fax> hehe
15:51:26 <copumpkin> that's basically what I do :P
15:51:56 <dcolish> yay is for mindless proof hacking
15:52:16 <monochrom> There is nothing wrong with "mindless" proof hacking.
15:52:25 <ddarius> "If it compiles, it works."
15:52:37 <fax> monochrom: I think they mean a different sort of mindless
15:52:46 <dcolish> there's nothing right with it either
15:52:54 <twink> "If it compiles, ship it."
15:52:58 <dcolish> lo
15:53:12 <monochrom> Do not pretend that your use of the computer is not mindless. You don't even know the quantum mechanics that makes it all work.
15:53:36 <ddarius> monochrom: Says you.
15:53:46 <djahandarie> monochrom, quantum mechanics? There are no cats nor poison viles in my computer
15:53:46 <monochrom> You basically live your whole life pretty mindlessly.
15:55:08 * fax pokes sungji
15:55:16 * ddarius would find a history of chip fabrication interesting just to see how the various processes were arrived at.
15:56:04 <dcolish> fax: have you worked with agda or Curry ?
15:56:38 <fax> dcolish - not really I have read about them though
15:57:47 <dcolish> ditto, i've even installed both, but have yet to do any actual work with either. Coq is doing what i need for now
15:58:20 <fax> dcolish: I really need to try and _finish_ more things, it's a lot of fun expirmenting but after a while I feel like I have not really done anything :S
15:59:00 <Veinor> monochrom: there's a quote somewhere that says the goal of civilization is to decrease the amount of thought required or something
15:59:12 <roconnor> fax: write a thesis :)
15:59:36 <gwern> Veinor: whitehead. civilization advances in proportion to the number of things we need not think about, or something
15:59:41 <roconnor> fax: I had a though today and was like, doing this would make a good chapter in my thesis ....
15:59:48 <roconnor> fax: but now I have no thesis to write :(
15:59:54 <Veinor> yeah, that's the quote
16:00:00 <fax> roconnor aw :P
16:00:07 <dcolish> roconnor: there are alawys conference papers
16:00:10 <mamalujo> djahandarie: your computer may not have schrnödinger's cat setup inside it, but it does have thunks, and in them the cat is surely either dead or alive, if only you aren't too lazy to evaluate it (rephrasing a comic)
16:00:12 <dcolish> *always
16:00:45 <gwern> roconnor: send newton a letter with your thought in an anagram; then you can claim priority when someone later puts in the hard work to make it worthwhile
16:00:55 <roconnor> :)
16:02:22 <sungji> fax, yes, i've done it the way you suggested
16:04:10 <fax> sungji, cool - so now you see why strong induction does not make any sense to apply here?
16:05:42 <sungji> fax, I'm afraid not
16:05:53 <fax> well show your proof
16:05:59 <fax> I will tell you if it's correct
16:06:09 <sungji> fax, ok
16:06:15 <c_wraith> fax is an automated proof verifier
16:06:49 * djahandarie wonders what sort of pain he must have gone through
16:07:03 <Twey> Bitten by a radioactive Agda
16:07:11 <monochrom> hahaha
16:08:20 <Twey> He gains the ability to sense non-following implications and hurl dependent types at nearby buildings
16:08:46 <Eduard_Munteanu> Hi.
16:09:11 <Twey> Hullo
16:09:25 <monochrom> He then went to a math conference and punched holes into every presentations.
16:09:36 <Twey> Heheh.
16:10:19 <Eduard_Munteanu> Holes?
16:11:39 <Eduard_Munteanu> Ah, nvm.
16:15:21 <kmc> is there a standard integer logarithm function?
16:16:17 <Twey> :t log
16:16:18 <lambdabot> forall a. (Floating a) => a -> a
16:16:25 <Twey> That'll do?
16:16:33 <Gracenotes> probably none without floor
16:16:49 <Twey> Integer-only logs are not that useful
16:16:52 <Gracenotes> or your own divmod implementation
16:17:05 <mle> or shift and test shenanigans.
16:17:08 <Gracenotes> or even more creative log(number of bits)
16:17:16 <Gracenotes> uh. implementations.
16:17:26 <Twey> Heh
16:18:13 <kmc> integer only logs are useful
16:18:23 <kmc> there's an implementation in the Report, sec 14.4
16:18:30 <kmc> but it's not actually part of the stuff Prelude is supposed to export
16:18:41 <sungji> fax, http://gist.github.com/385875   but something's wrong
16:19:07 <fax> what is wrong?
16:19:55 <sungji> fax, the < after the the induction hypothesis doesn't seem to hold
16:20:21 <Gracenotes> kmc: Hacker's Delight has fancy algorithms if you know the base (especially for 2) and #bits
16:20:25 <fax> sungji: You shouldn't call it "base" and "step" case, it is "Leaf" and "Node" case
16:22:05 <sungji> fax, they taught me to do that... but I'll switch to what you said, asap :)
16:22:29 <fax> Node case: P(t1), P(t2) ==> P(Node t1 t2) (N t1) < 2^(H t1), (N t2) < 2^(H t2) ==> (N (Node t1 t2)) < 2^(H (Node t1 t2)) (N t1) < 2^(H t1), (N t2) < 2^(H t2) ==> (N t1) + (N t2) + 1 < 1 + (max (H t1) (H t2))
16:22:36 <fax> actually scrap that
16:22:39 <fax> it was meant to be 3 lines
16:23:12 <fax> sungji, http://gist.github.com/385880
16:23:19 <sungji> fax, does the website I linked to, show you an edit button?
16:24:40 <fax> oops
16:24:55 <fax> sungji, I just corrected my mistake
16:27:35 <sungji> fax, so I can't substitute the functions the way I did in my proof?
16:27:48 <fax> sungji, well there is a lot of important stuff missing
16:28:09 <sungji> fax, oh really??
16:28:13 <fax> imo
16:28:34 <sungji> fax, tell me what's left out :)
16:29:32 <fax> give me a moment
16:31:05 <fax> http://gist.github.com/385880
16:31:32 <fax> this is the sort of detail that convinces normal people that proving programs correct is impractical
16:32:32 <fax> sungji: is it clear?
16:33:39 <Eduard_Munteanu> fax: is that any formal language?
16:34:11 <fax> Eduard_Munteanu: no
16:34:28 <sungji> fax, I'm still reading :)
16:34:31 <kmc> normal people ;)
16:35:02 <mamalujo> wee, so Hs'10 report draft is created http://www.haskell.org/pipermail/haskell-prime/2010-April/003165.html
16:37:10 <mamalujo> would hypothetical future acceptance of a mechanism like view patterns make pattern guards obsolete? They don't seem particularly orthogonal?
16:38:41 <fax> Eduard_Munteanu: BUt it is a common presentation layout
16:38:52 <Eduard_Munteanu> fax: oh.
16:39:08 <Twey> mamalujo: No
16:39:17 <Twey> There's some overlap between them, but they serve different purposes
16:47:27 <Eduard_Munteanu> mamalujo: is that a draft newer than the Haskell prime thingy a few months ago?
16:48:23 <sungji> fax, why is line #12 true?
16:48:42 <fax> what is ti
16:48:51 <fax> ?
16:48:57 <sungji> <= 2^(H t1) + 2^(H t2)   in your version
16:49:05 <fax> you need 3 lines
16:49:20 <fax> to make sense
16:49:22 <mamalujo> Eduard_Munteanu: the mail announcing it is from yesterday, but I don't know if some version of it was online few months ago
16:49:36 <sungji> fax, sorry, just a sec...
16:49:53 <fax> just paste the bit like: a { justification } R b
16:50:23 <sungji> fax,  ... < 2^(H t1) + 2^(H t2) + 1     { definition of < on integers }     <= 2^(H t1) + 2^(H t2)
16:51:08 <fax> doh that's wrong
16:51:12 <sungji> :)
16:51:13 <fax> good find
16:51:28 <mamalujo> Eduard_Munteanu: I do remember an older haskell prime draft from years ago, it is definitely different from that
17:07:56 <sungji> fax, have you been able to correct the error?
17:09:08 <fax> no
17:09:53 * hackagebot HTicTacToe 0.1 - A tic-tac-toe game.  http://hackage.haskell.org/package/HTicTacToe-0.1 (KorcanHussein)
17:12:47 <sungji> fax, me neither. btw, I did the very same mistake (that's what I was referring to after I published the link to my version)
17:43:28 <gwern> hm. I need a one-syllable word starting with 'm' that means 'fair' 'worthy' 'beautiful'
17:43:33 <gwern> 'meet' maybe?
17:43:45 <tensorpudding> meet doesn't mean that
17:43:53 <gwern> tensorpudding: sure it does.
17:44:01 <ivanm> @wn meet
17:44:02 <lambdabot> *** "meet" wn "WordNet (r) 2.0"
17:44:03 <lambdabot> meet
17:44:03 <lambdabot>      adj : being precisely fitting and right; "it is only meet that she
17:44:03 <lambdabot>            should be seated first" [syn: {fitting}]
17:44:03 <lambdabot>      n : a meeting at which a number of athletic contests are held
17:44:04 <lambdabot> [33 @more lines]
17:44:11 <ivanm> looks like it does
17:44:12 <gwern> see?
17:44:16 <ivanm> but it's no longer current english
17:44:24 <tensorpudding> I see that fair might fit.
17:44:24 <gwern> I speak the english of all ages!
17:44:35 <Veinor> tensorpudding: fair starts with m now?
17:44:37 <tensorpudding> I definitely don't see beautiful or worthy though
17:44:37 <gwern> as terence said, 'nothing human is alien to me'
17:44:47 <tensorpudding> might fit as a synonym for meet
17:44:54 <ivanm> @wn kempt
17:44:55 <lambdabot> *** "kempt" wn "WordNet (r) 2.0"
17:44:55 <lambdabot> kempt
17:44:55 <lambdabot>      adj : (used of hair) neat and tidy; "a nicely kempt beard" [syn: {tidy},
17:44:55 <lambdabot>             {trim}]
17:44:59 <gwern> tensorpudding: the meaning can be kind of loose, which is why I gave at least 3 possibilities
17:45:11 * gwern is trying to get a verse of the _Havamal_ into fully alliterating form
17:45:17 <tensorpudding> Anyway, I call archaic usage on that.
17:45:35 <gwern> a pox on your 'archaic usage'!
17:45:41 <tensorpudding> hah
17:45:48 * ivanm is trying to work out why mumamo doesn't like his markdown + haskell mode
17:47:35 <ivanm> gwern: how are you with elisp?
17:47:50 * gwern isn't doing anything with it
17:48:11 <ivanm> have you ever used it much?
17:48:17 <ivanm> or just copy-pasted config settings?
17:48:58 <gwern> ivanm: I've used it plenty. my .emacs is quite large
17:49:44 <ivanm> can you see where the error is here? error: http://paste.pocoo.org/show/208276/
17:49:52 <ivanm> elisp: http://paste.pocoo.org/show/208278/
17:51:08 <gwern> whoa wtf
17:51:52 <gwern> I take it that's from *messages*?
17:52:21 <ivanm> yeah
17:52:35 <DanHaraj> And I thought C++ template errors were a textplosion
17:53:46 <gwern> I'm not even sure where the backtrace ends
17:53:51 <gwern> and regular messages begin
17:54:35 <ivanm> gwern: the entire thing was highlighted
17:54:38 <ivanm> by mumamo
17:54:48 <ivanm> so I _think_ the entire thing is backtraces
17:54:52 <gwern> what, all the way down to   call-interactively(ido-execute-command nil nil) ?
17:55:02 <ivanm> I tried putting some (message "foo") messages in, but they dind't seem to do anything
17:55:18 <ivanm> gwern: well, that's the backtrace, since I did M-x (using ido-execute-command) revert-buffer
17:55:55 <gwern> ok, I *think* the error is around line 16 or so
17:56:08 <gwern> <16 seems to be baroque error handling
17:56:30 <Veinor> oh god
17:56:33 <Veinor> there's 666 people in here
17:56:37 <gwern> so '(progn (mumamo-find-possible-chunk pos min max (quote mumamo-markdown-named-chunk-start-bw) (quote mumamo-markdown-chunk-end-bw) (quote mumamo-markdown-named-chunk-start-fw) (quote mumamo-markdown-chunk-end-fw)))'
17:56:55 <gwern> ivanm: possibly an off by one error?
17:56:59 <Veinor> ... and the 667th person is SonOfLilith. hah.
17:57:12 <ivanm> gwern: :s I'm not doing any numerics though
17:57:15 <ivanm> elisp: http://paste.pocoo.org/show/208278/
17:57:28 <gwern> ivanm: I'm suspicious of mumamo-markdown-named-code-chunk
17:57:35 <gwern> ivanm: you may not be doing nay numerics but it may be
17:57:40 <gwern> indices
17:57:53 <ivanm> yeah
17:58:20 <Eelis> i've narrowed a strictness problem in my application down to a problem with partitionEithers, which appears to be overly strict. if you look at its source, its local left/right functions really should delay the pattern match on the pair like this:   left a p = (a:fst p, snd p)
17:58:27 <Eelis> at least this fixes the strictness problem in my application
17:58:32 <gwern> @hoogle partitioneithers'
17:58:33 <lambdabot> No results found
17:58:33 <gwern> @hoogle partitioneithers
17:58:34 <lambdabot> Data.Either partitionEithers :: [Either a b] -> ([a], [b])
17:58:36 <gwern> @src partitioneithers
17:58:37 <lambdabot> Source not found. Just try something else.
17:58:40 <Eelis> (here's the partitionEithers source: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/src/Data-Either.html#partitionEithers )
17:58:41 <gwern> @src partitionEithers
17:58:42 <lambdabot> Source not found. Where did you learn to type?
17:58:44 <gwern> bah
17:59:26 <gwern> Eelis: did you quickcheck the equivalence?
17:59:27 <Eelis> my question is: should i go ahead and file a library submission for this, or is there some policy in place stating that these aren't legitimate complaints?
17:59:49 <aavogt> it's a common situation in the libraries that   (a,b) should really be   ~(a,b)
17:59:52 <gwern> ivanm: I would be particularly suspicious of 'mumamo-markdown-chunk-end-bw
18:00:00 <gwern> ivanm: maybe could try some messages in that
18:00:12 <Eelis> gwern: without the fix,   head $ fst $ partitionEithers (Left () : undefined)   yields undefined. with the fix, it yields ()
18:00:18 <gwern> ivanm: I'm suspicious because that could easily run off the end of the buffer I think
18:00:32 <ivanm> hmmm...
18:00:47 <ivanm> gwern: I'm throwing a message in there, but none of them fire :s
18:00:51 <Eelis> aavogt: i'm not familiar with that ~. is it some sort of lazy pattern match that makes it equivalent to my fst/snd solution?
18:00:54 <ivanm> it's just (message "foo"), right?
18:00:59 <gwern> Eelis: that seems reasonable, but does it change any behavior in non-undefined situations?
18:01:02 <aavogt> Eelis: yes, it's the same
18:01:02 <ivanm> Eelis: yes
18:01:16 <gwern> ivanm: I think so
18:01:35 <Eelis> gwern: it shouldn't.
18:01:45 <Eelis> aavogt: neat :)
18:02:02 <Eelis> aavogt: so i should go ahead and file a ticket about it?
18:02:47 <aavogt> Eelis: hmm, if you include undefined in this prop: prop_partitionEithers x = partitionEithers x == (lefts x, rights x)
18:03:29 <aavogt> it looks like your     head $ fst $ partitionEithers(Left () : undefined) -- should be accepted
18:04:34 <ivanm> eh, I'm heading off
18:04:41 <ivanm> I'll bash my head some more against this later on
18:05:10 <Eelis> aavogt: are you saying that quickcheck should already have spotted my problem?
18:05:21 <Eelis> i thought quickcheck didn't check undefined values
18:05:41 <DanHaraj> Hey, anyone want to entertain a few beginner questions?
18:05:56 <kmc> sure
18:06:05 <aavogt> I'm saying the property there suggests you should be ok with your undefined value
18:06:17 <aavogt> > lefts (Left () : undefined)
18:06:18 <lambdabot>   [()*Exception: Prelude.undefined
18:06:20 <ivanm> thanks gwern
18:06:38 <aavogt> > partitionEithers (Left () : undefined)
18:06:39 <lambdabot>   *Exception: Prelude.undefined
18:06:52 <DanHaraj> Alright, I've been looking at the state monad documentation in mtl, and there is no mention of put or get. These come up in a lot of tutorials. Is there any reason why I can't find it in the doc?
18:07:17 <kmc> DanHaraj, they're defined in a type class
18:07:23 <kmc> DanHaraj, http://www.haskell.org/ghc/docs/6.10-latest/html/libraries/mtl/Control-Monad-State-Class.html
18:07:25 <Eelis> aavogt: i don't know what you mean by "you should be ok". do you mean "you should suck it up" ?
18:07:29 <kmc> so that they work on for example both State and StateT
18:07:36 <aavogt> not at all
18:07:46 <DanHaraj> aha. Of course it's in the page I don't check out of the three.
18:07:52 <aavogt> I mean that the   lefts == fst . partitionEithers
18:08:11 <aavogt> as in, you should be ok dealing in undefined values
18:08:12 <Eelis> aavogt: that would be a nice identity to have. my whole problem is that we currently don't have it
18:08:26 <DanHaraj> So I'm looking at StateT because I'm writing a minilanguage interpreter. Since I'm doing IO and I need to do some bookkeeping, I want to use StateT with IO. Does that seem like the proper strategy?
18:09:00 <kmc> DanHaraj, probably
18:09:05 <kmc> DanHaraj, note that IO also has its own form of state
18:09:09 <kmc> which is rather different from StateT
18:09:30 <Cale> DanHaraj: I usually think that IO already has enough features without using monad transformers over it.
18:09:45 <kmc> DanHaraj, state variables in IO are in Data.IORef
18:10:02 <kmc> DanHaraj, StateT like State is just sugar around passing states in a pure fuctional way
18:10:04 <Cale> Transforming the IO monad has the unfortunate effect of requiring you to lift all the IO actions that you're using.
18:10:12 <kmc> whereas IORefs are real mutable in-place-update reference cells
18:10:18 <kmc> the interface and implementation are both different
18:10:36 <DanHaraj> hmm
18:10:56 <kmc> so look at both and see what you want
18:11:04 <Eduard_Munteanu> If you simply want to pass things around, you could try the Reader monad.
18:11:14 <kmc> @unmtl StateT s IO a
18:11:14 <lambdabot> s -> IO (a, s)
18:11:30 <Cale> Usually if you're writing an interpreter and just want to maintain local bindings, the plain reader monad alone is not bad.
18:11:36 <aavogt> freedom from StateT
18:11:42 <DanHaraj> Well I was thinking that if I wasn't doing IO, I would have used State, but if IO has its own stuff I really don't want to make it more complicated than it should be.
18:12:33 <Cale> But if your interpreter is doing IO in the midst of things, just using IO directly probably won't be so bad.
18:12:37 <danh> rats, this name is registered.
18:13:03 <Cale> People go to a lot of trouble to avoid passing parameters, but often just passing around a couple of things explicitly isn't so bad.
18:13:16 <fax> hey Cale
18:13:26 <fax> does memristor have something to do with quantum computing?
18:13:34 <Cale> fax: no
18:14:24 <Cale> fax: Though they are down at the nanoscale side of things, they're not quantum. They're just a particularly nice way of doing classical computing.
18:14:42 <fax> alright
18:14:47 <gwern> Eelis: I think in general most people don't care if an update makes a function defined on more inputs; they do care if it changes defined output. so quickchecking old == new is just a sanity check
18:15:02 <gwern> Eelis: but your change should be no trouble beside the usual libraries-related apathy
18:15:49 <danharaj> I just realized I am being misleading. It isn't so much of an interpreter so much as something that receives commands and pushes data around based on it. The state being threaded is the state of the data.
18:15:57 <mamalujo> Twey: really? but according to this ticket on adding view patterns to TH http://hackage.haskell.org/trac/ghc/ticket/2399 , apart from slightly different syntactic sugar, the only difference between view p. and p. guards is that the latter are not part of the pattern syntax, and hence not compositional. But if a pat guard were a part of pattern syntax, then (f->p) would be the same thing as (x | pat <- exp x)
18:16:26 <Eduard_Munteanu> Also there's the possiblity of passing a data structure.
18:16:57 <Eelis> gwern: i found a ticket about it: http://hackage.haskell.org/trac/ghc/ticket/3709  -- it seems like it actually got fixed five months ago, so i don't understand why the fix isn't in the current base package
18:16:57 <Eduard_Munteanu> No need for any monadic magic then, unless you intend to make it behave like _global_ data.
18:17:09 <Eduard_Munteanu> i.e. mutable.
18:17:11 <gwern> Eelis: versoning?
18:17:21 <Eelis> gwern: i'm pulling the darcs repo now to inspect
18:17:35 <AnAdorableNick> danharaj: I've written a tutorial on the State monad: http://strabismicgobbledygook.wordpress.com/ — Lt me know how it goes for you? :)
18:17:48 <danharaj> Sure :p
18:18:23 <Cale> fax: Basically, a memristor is a bit like a normal resistor, in that it ends up relating voltage and current, except that the manner in which it does this is dependent on how much current has passed through it -- it has a 'memory' in that sense. Run current through it one way and the resistance goes up, run it through the other way and the resistance goes back down again
18:18:37 <Eduard_Munteanu> Ah, memristors.
18:19:03 <Eduard_Munteanu> Yeah, simply put, you "write" them in DC and read them with AC.
18:19:15 <Cale> Really, the memristor is providing a constant monotone relationship between the integral of current (charge) and the integral of voltage (flux)
18:19:23 <Eduard_Munteanu> (with mean value zero)
18:19:35 <fax> that is wild
18:19:53 <tensorpudding> They're not even that complicated either.
18:20:10 <fax> in this talk he said they made a C compiler which turned things into NAND gaets and another which turned stuff into memristors -- and the memristor one was about 3x better
18:20:27 <Cale> Which talk?
18:20:29 <tensorpudding> They were representing an alternate logic in memristors.
18:20:32 <Cale> (Is it online?)
18:20:42 <tensorpudding> It was a talk by the HP Labs guy who discovered memristors
18:20:47 <gwern> hm. so you can set the resistance to anyting you want. I see why they talk about it being a stable memory - you could probably fit more than a few bits into the resistance
18:20:51 <fax> this one http://www.youtube.com/watch?v=bKGhvKyjgLY
18:21:04 <danharaj> I think I'll use IORef instead of State. It seems much cleaner than StateT in this context.
18:21:04 <Eduard_Munteanu> Actually, crossbar latches and all that stuff put forth by HP, "that's going to replace transistors", are really memristors.
18:21:11 <Eelis> gwern: ok, the fix is there in the darcs repo. i guess i'll just have to wait then..
18:21:16 <tensorpudding> The logic was supposedly one using material implications as given by Russell in the PM.
18:21:18 <gwern> Eelis: that's good then
18:21:43 <Cale> There's a very simple, but really neat thing you can do with memristors -- just build a straightforward crossbar array of them -- wires running horizontally, and wires running vertically with a memristor at each intersection. By driving the lines appropriately, you not only get memory, but you can compute logical implication.
18:21:46 <Eduard_Munteanu> gwern: probably not.
18:22:01 <Eduard_Munteanu> You could use multi-state logic, but then again nobody really cared.
18:22:06 <Cale> and logical implication + false is computationally complete
18:22:07 <gwern> Eduard_Munteanu: ?
18:22:16 <tensorpudding> Yes, that was the gist of it.
18:22:30 <tensorpudding> By using this reduced logical operation set, the logic can be made significantly denser.
18:22:30 <Eduard_Munteanu> gwern: you could, but you wouldn't really do it. Noise margins are a better compromise.
18:22:39 <gwern> Eduard_Munteanu: what are noise margins?
18:23:01 <tensorpudding> And the fact that the operations map cleanly onto memristors means that memristor logic will be spectacularly more efficient
18:23:03 <Cale> So your crossbar array of memristors is not only your memory, but can act as (a large part of) your CPU as well :)
18:23:26 <Cale> Need more processing? Just trade some memory for it :)
18:23:27 <tohava> Let's say I want to implement addition in Haskell for a 2-d tuple type
18:23:33 <tohava> what is the easy way to do this?
18:23:45 <Cale> add (x,y) (x',y') = (x+x',y+y')
18:23:46 <Cale> ?
18:23:47 <tensorpudding> A hybrid DRAM + CPU replacement using memristors would be revolutionary
18:23:52 <Eduard_Munteanu> gwern: if you got 2 states, the signal (voltage) differences are greater between them. If you fit 3 states in the same range, you've got yourself more sensitivity to noise.
18:23:56 <tohava> Cale: but using the plus operator
18:24:04 <danharaj> Revolutionary enough to debase the ubiquity of the transistor?
18:24:07 <tohava> Cale: i.e. (x,y) + (a,b) = (x + y, a + b)
18:24:07 <Cale> tohava: In that case, you'll need to write an instance of Num
18:24:19 <Cale> instance (Num a, Num b) => Num (a,b) where
18:24:19 <tohava> Cale: so there's no way around it
18:24:20 <tohava> Cale: bummer
18:24:23 <gwern> Eduard_Munteanu: well sure. good ol shannon telling us the limit of how much signal we can fit in
18:24:33 <Cale>   (x,y) + (x',y') = (x+x',y+y')
18:24:38 <Cale>    ... other operations ...
18:24:50 <tohava> Cale: yes, I was hoping there was some way to do it only for plus
18:25:10 <Cale> You could hide the Prelude (+), but that tends to be awkward
18:25:14 <tohava> Cale: but I see now that it is impossible due to amibguity with the existing plus operator of the Num class
18:25:17 <Cale> You could also just define your own operator
18:25:23 <Cale> .+. works nicely
18:25:26 <tohava> Cale: yes, that would be sad, I guess I'll either do that or just define an addPos
18:25:29 <tohava> Cale: thanks
18:25:38 <tensorpudding> Defining a Num instance is a pain.
18:25:53 <Eduard_Munteanu> Wasn't there a 'map' for tuples of a given size, say 2?
18:26:01 <Cale> yeah, pairs do make a perfectly good instance of Num
18:26:10 <danharaj> There should be a typeclass for vector spaces.
18:26:19 <Cale> Eduard_Munteanu: nope
18:26:31 <Cale> Eduard_Munteanu: there's fmap which applies a function to the second component
18:26:32 <tohava> Cale : one thing that I do not understand though, didn't anyone implement something like this already in Haskell? does it mean that everyone that does linear algebra in haskell has to use custom made operators?
18:26:46 <Cale> tohava: There are linear algebra libraries on Hackage
18:26:47 <tohava> Cale: or do libraries are simply built by implementing Num fully and using generalized types
18:26:51 <Eduard_Munteanu> Cale: fmap? Are pairs monads?
18:26:59 <tensorpudding> No.
18:27:08 <Cale> Eduard_Munteanu: (,) m is a monad when m is a monoid.
18:27:12 <Eduard_Munteanu> Ah.
18:27:23 <Cale> and (,) m is always a functor regardless
18:27:35 <Eduard_Munteanu> Yeah, fmap is defined for Functor.
18:28:03 <Cale> tohava: I tend to like the convention of writing ^ or . on the sides of the operator which take a vector parameter
18:28:19 <tohava> Cale: I guess it's possible, don't know, seems nasty though
18:28:30 <Cale> tohava: So (a *. v) is scalar multiplication with the scalar on the left
18:28:50 <tohava> Cale: then again, I guess that the Haskell way is like a compromise between the C++ way where operators can be defined for everything under the sun and the java way where they can never be
18:29:09 <Cale> tohava: Well, they're just names of functions which happen to be made of symbol characters
18:29:28 <Eduard_Munteanu> Actually, you can't really define arbitrary operators in C++, but you pretty much can in Haskell.
18:29:40 <danharaj> Fixity gets dicey though.
18:29:43 <Eduard_Munteanu> C++ only allows you to overload existing stuff.
18:29:49 <tohava> Eduard: I agree
18:30:09 <Cale> > let x &^*! y = x^2 + x*y + y^2 in 5 &^*! 10
18:30:10 <lambdabot>   175
18:30:32 <Cale> (that's a terrible name, but you get the idea ;)
18:30:36 <danharaj> Is it too cumbersome to use `sum` ?
18:30:48 <Cale> :t sum
18:30:49 <lambdabot> forall a. (Num a) => [a] -> a
18:30:57 <danharaj> :|
18:31:39 <Cale> danharaj: We'll still need transistors when moving to memristive systems, but one memristor can replace an entire flip-flop.
18:32:15 <Cale> danharaj: So, they can dramatically simplify some circuits
18:32:51 <danharaj> But say, take the x86 platform. What is a feasible roadmap for phasing in memristors?
18:33:27 <fax> you compile your chip into -> rather than XOR right?
18:33:37 <Cale> fax: yeah
18:33:41 <Eduard_Munteanu> As long as you make it invisible and compatible, you can do it now, given you have the technical means.
18:33:47 <Cale> That would be the somewhat less revolutionary way to design things
18:34:23 <electrogeek> .
18:34:26 <Eduard_Munteanu> I'd also like to see chipmakers transition to clockless systems.
18:34:44 <Eduard_Munteanu> (though that's going to be relatively harder)
18:34:57 <Cale> The x86 instruction set doesn't quite look right for a memristor CPU -- at least, I don't think so. But you could do a bunch of stuff in transistors which drives the lines on your memristor array to simulate all the instructions of x86.
18:35:24 <danharaj> The x86 instruction set needs to die :|
18:35:41 <Eduard_Munteanu> Heh, agreed :))
18:35:48 <tensorpudding> A new architecture built on it which was presented for a mobile platform would be able to get around the x86 monopoly
18:35:55 <Cale> I think that something closer to a functional programming template instantiation makes a lot more sense as a primitive language for a memristor CPU.
18:36:29 <Cale> Your memory and your CPU are identified, so there's no von-Neumann bottleneck to speak of
18:36:37 <danharaj> If you can manage to get trillions of lines of code running on your new platform, then I will follow you to the promised land.
18:36:38 <Eduard_Munteanu> Cale: btw, I was looking for ways to devise functional instruction sets / machines. Somebody suggested S/K combinator calculus.
18:36:48 <tensorpudding> Wonder what memristors could due for GPU's
18:36:49 <Eduard_Munteanu> Looked a bit on it, seems interesting, but not sure how helpful that is.
18:36:56 <theorbtwo> It doesn't seem terribly likely that the x86 instruction set, or general archeture, will be dying any time soon.
18:37:09 <Cale> It might look something like the Reduceron.
18:37:15 <theorbtwo> Especially with Apple switching *from* PPC *to* apple.
18:37:32 <Cale> theorbtwo: You mean to Intel.
18:37:41 <theorbtwo> ARMs have a great installed base in cell phones, though.  (Semi-native java helps.)
18:37:43 <Cale> I actually find that a bit sad.
18:37:43 <stepcut> apple makes me sad :(
18:37:45 <theorbtwo> Cale: Er, yes.
18:37:48 <Cale> PPC was cool.
18:37:50 <danharaj> They could at least stop the instruction wars and phase out the depecrated crap that supports programs that don't run anymore anyway. (Amd and intel)
18:38:20 <Cale> But I've never really cared for Apple anyway.
18:38:20 <Eduard_Munteanu> That would be relatively easy if more stuff were open-source.
18:38:22 <danharaj> But anyway I came here to learn the ways of the lambda, not stand on a soapbox :p
18:38:34 <Eduard_Munteanu> You'd just recompile the damn thing.
18:38:39 <saml> @pl (\(a,_) (b,_) -> compare a b)
18:38:39 <lambdabot> (`ap` snd) . (. fst) . (const .) . compare . fst
18:38:43 <danharaj> Speaking of compliation
18:38:49 <saml> is there a function like that?
18:38:59 <danharaj> I spent all of yesterday trying to get wxhaskell to build on my win7 + haskellplatform
18:39:03 <Eduard_Munteanu> danharaj: you need to find the lambda within yourself, not seek it on the outside :P
18:39:03 <saml> apply compare for fst of pairs
18:39:27 <danharaj> Cabal only gave me bitter tears and the essence of frustration distilled into a string of failures.
18:39:38 <Eduard_Munteanu> danharaj: oh noes, just go with Gtk2Hs.
18:39:46 <danharaj> Probably.
18:39:49 <Cale> danharaj: http://video.google.com/videoplay?docid=-1518197558546337776# -- If you're interested in this sort of thing, this talk is about an FPGA implementation of an architecture which is more natural for functional programming, and to me it looks like quite a lot like the sort of model which would work wonderfully for a memristor array.
18:40:02 <Eduard_Munteanu> Interesting.
18:40:04 <danharaj> I'm a bit disappointed there isn't an official functional-idioms gui.
18:40:14 <Eduard_Munteanu> Grapefruit?
18:40:28 <Eduard_Munteanu> Oh, not official, and not functional in the other sense :)
18:40:31 <aavogt> that's arrows though
18:41:01 <aavogt> by idiom you mean Applicative?
18:41:03 <Eduard_Munteanu> GTK is pretty nice with that model-store concept.
18:41:25 <danharaj> I mean functional-style instead of imperative style, although the lines blur when you can embed one in the other.
18:42:26 <aavogt> ok, I wasn't sure, because some sources call 'applicative functors' 'idioms'
18:42:34 <danharaj> O.o
18:42:42 * theorbtwo shrugs.  Most gui toolkits aren't especially imperative.
18:43:08 <mamalujo> yeah, various fruits were exploring such designs. I think grapefruit and reactive are current libraries of that style
18:43:37 <theorbtwo> They tend to be pretty eventy, which often ends up being more functional then imperitive.
18:43:51 <danharaj> Speaking of applicative functors, can someone translate 'applicative' into categorese? I'm a math student, and I understand things in math-speak better.
18:43:55 <Cale> Well, wxHaskell and Gtk2Hs seem fairly imperative in style to me.
18:44:58 <Cale> danharaj: Applicative functors are a special case of monoidal functors
18:45:02 <ddarius> danharaj: I believe it translates to a lax monoidal functor.
18:45:07 <Cale> yeah
18:45:33 <danharaj> ah.
18:45:46 <danharaj> I wonder if Maclane talks about those.
18:45:58 <Cale> A lax monoidal functor where you choose the monoidal structure in a somewhat boring way, so you get a natural transformation phi_A,B : (FA, FB) -> F(A,B)
18:46:15 <Cale> (using half Haskell notation and half categorical ;)
18:46:55 <ddarius> danharaj: If my Mac Lane you mean Categories for the Working Mathematician, he talks about strict monoidal functors, but not lax ones.
18:47:00 <danharaj> ah
18:47:24 <Cale> I suppose it would be phi :: (f a, f b) -> f (a,b) which is just the curried version of f a -> f b -> f (a,b), and if you can do that, then you can get (<*>) :: f (a -> b) -> f a -> f b in a somewhat-obvious way
18:47:52 <ddarius> uncurried version
18:48:05 <Cale> :t fmap (uncurry ($))
18:48:06 <lambdabot> forall b b1 (f :: * -> *). (Functor f) => f (b -> b1, b) -> f b1
18:48:19 <Cale> ^^ you just compose that on the end :)
18:48:21 <ddarius> uncurry liftA2
18:48:27 <ddarius> :t uncurry liftA2
18:48:28 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c, f a) -> f b -> f c
18:48:38 <ddarius> :t uncurry (liftA2 (,))
18:48:38 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (f a, f b) -> f (a, b)
18:48:56 <Eduard_Munteanu> :t liftA2
18:48:57 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
18:48:58 <Cale> yeah, and there's the other direction :)
18:49:26 <Eduard_Munteanu> :t liftM2
18:49:28 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
18:49:53 <lpsmith> so why does parsec-3.1,  iteratee,  and others use a   instance Monad Parsec ... where  (>>=) = parsecBind  ... {-#  INLINE parsecBind #-} kind of idiom?
18:53:08 <Eduard_Munteanu> Oh, new South Park online...
18:53:18 * Eduard_Munteanu goes watch
18:53:32 <Kaidelong> I can't seem to find good resources on how to define types in haskell
18:53:44 <Kaidelong> also could I do something like
18:54:07 <gwern> Kaidelong: 'data', 'type', 'newtype' are the relevant keywords
18:54:13 <Kaidelong> compare = (compare :: (Num c) => c -> c -> Ordering)
18:54:17 <Kaidelong> err
18:54:27 <Kaidelong> compare = (compare :: (Num c) => c -> c -> Ordering) `on` cost
18:54:38 <fax> Kaidelong: just write  compare = compare `on` cost
18:54:45 <Kaidelong> fax: that is an error
18:55:02 <Eduard_Munteanu> :t (on)
18:55:03 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
18:55:04 <lpsmith> Kaidelong,  {-# LANGUAGE NoMonomorphismRestriction #}
18:55:06 <fax> Kaidelong: if you want something that actually works try  compare = compring cost
18:55:09 <fax> comparing*
18:55:16 <lpsmith> err,  #-},  but yeah
18:55:30 <Kaidelong> I'll try that then fax, thanks
18:56:25 <danharaj> I don't understand why the do notation is sugar
18:56:46 <danharaj> "foo <- bar" is basically "bar >>= \foo ..." isn't it?
18:57:29 <Corrido> ghci> 3 * 2.1 results in 6.300000000000001, is this broken ?
18:57:54 <danharaj> floats are 'broken' in every language. :p
18:58:00 <syntaxglitch> Corrido, yes, you've found a bug in every language ever
18:58:11 <Corrido> bc is correct tho
18:58:19 <aavogt> it's more than that:
18:58:25 <kmc> Corrido, you can use the type "Rational" for arbitrary-precision rational numbers
18:58:34 <mauke> Corrido: no
18:58:36 <kmc> ghci defaults to Double which, like every floating-point type, has a fixed resolution
18:58:39 <aavogt> @undo do [x] <- return "hello"; return x
18:58:39 <lambdabot> return "hello" >>= \ a -> case a of { [x] -> return x; _ -> fail ""}
18:58:49 <Corrido> kmc: ah ok
18:58:54 <kmc> fwiw Python 2.5.5 says 6.3000000000000007
18:58:56 <kmc> ;)
18:59:17 <lpsmith> > (0.1 + 0.2) + 0.3
18:59:17 <lambdabot>   0.6000000000000001
18:59:21 <kmc> > 3 * (21 % 10)
18:59:22 <lambdabot>   63 % 10
18:59:22 <danharaj> Ah, so you can do implicit pattern matching with it
18:59:22 <Kaidelong> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25257#a25257
18:59:27 <lpsmith> > 0.1 + (0.2 + 0.3)
18:59:27 <Kaidelong> this builds without a problem
18:59:28 <lambdabot>   0.6
18:59:29 <danharaj> that seems... not desirable.
18:59:31 <theorbtwo> > (0.1::CReal + 0.2) + 0.3
18:59:32 <lambdabot>   <no location info>: parse error on input `0.2'
18:59:41 <Kaidelong> c will have to be whatever class represents a source of randomness
18:59:45 <mauke> preflex: calc '2 0.1
18:59:45 <preflex>  0.00011001100110011001100110011001100110011001100110011
18:59:47 <theorbtwo> ...or not.
18:59:53 <Kaidelong> looking that up now
18:59:55 <kmc> Kaidelong, doesn't make sense
19:00:05 <Kaidelong> kmc: if there is a problem, please tell me
19:00:10 <Corrido> never mind, the question was obviously uninformed on my part :)
19:00:29 <Corrido> i hardly ever use doubles or floats
19:00:34 <kmc> Kaidelong, firstly, c is a type variable; it'd be a type, not a type class
19:00:48 <Kaidelong> kmc: I misspoke
19:01:02 <Kaidelong> I meant that c should be an instance of the class of random number generators, I think there was one
19:01:05 <danharaj> Does haskell have fixed point numbers?
19:01:16 <kmc> Kaidelong, that won't work, because you need to "thread" the generator state
19:01:17 <aavogt> danharaj: sometimes the fail method for the Monad instance you use is enough error handling
19:01:29 <kmc> the same generator value always gives you the same next random number
19:01:42 <lpsmith> > drop 50000 (scanl (+) 0 (repeat 0.1))
19:01:43 <lambdabot>   [5000.0000000006585,5000.100000000659,5000.200000000659,5000.30000000066,50...
19:01:49 <lpsmith> > drop 500000 (scanl (+) 0 (repeat 0.1))
19:01:50 <lambdabot>   [*Exception: stack overflow
19:01:51 <danharaj> That may be true, but, I guess I just like explicitly writing out fail cases in code.
19:01:54 <lpsmith> > drop 500000 (scanl' (+) 0 (repeat 0.1))
19:01:55 <lambdabot>   Not in scope: `scanl''
19:01:57 <kmc> Kaidelong, you can pass in an infinite list of random values
19:01:59 <lpsmith> :-/
19:02:22 <kmc> Kaidelong, the best thing might be to use the MonadRandom package off hackage
19:02:23 <lpsmith> > drop 100000 (scanl' (+) 0 (repeat 0.1))
19:02:24 <kmc> in which case
19:02:25 <lambdabot>   Not in scope: `scanl''
19:02:29 <lpsmith> > drop 100000 (scanl (+) 0 (repeat 0.1))
19:02:30 <lambdabot>   [10000.000000018848,10000.100000018849,10000.20000001885,10000.30000001885,...
19:02:37 <kmc> spawn :: (RandomGen g) => Rand g a
19:02:50 <aavogt> > do [a,b] <- ["he","123","AAA","32"]; return (a,b)
19:02:51 <lambdabot>   [('h','e'),('3','2')]
19:02:53 <kmc> mate :: (RandomGen g) => a -> a -> Rand g a
19:03:11 <kmc> Kaidelong, or a simpler solution is to commit to using the IO monad and StdGen
19:03:12 <kmc> in which case
19:03:19 <kmc> spawn :: IO a
19:03:22 <kmc> mate :: a -> a -> IO a
19:03:25 <aavogt> danharaj: sometimes those 'fail' cases are just cases where you don't want to search
19:03:40 <kmc> i would use MonadRandom as you get more control
19:04:26 <Kaidelong> kmc: the way I understood it was, you send in the RNG, and when you need the next value, you recurse with a new RNG with the next state, and if you want to use StdGen you need to call your function inside an IO monad
19:04:34 <Kaidelong> so that's what I was thinking when I wrote it
19:04:44 <danharaj> aavogt: fair enough
19:05:04 <Kaidelong> an infinite list of random values sounds better though
19:05:19 <kmc> Kaidelong, i like the infinite list but in practice it's not always clean to use
19:05:21 <absentia> how would you sort two infinit lists?
19:05:25 <danharaj> They should be called colists :p
19:05:27 <absentia> e
19:05:38 <kmc> you can't sort an infinite list productively
19:05:42 <kmc> unless your type has a lower bound
19:05:44 <Kaidelong> kmc: wouldn't it just make passing the next state equivalent to the tail of the list?
19:05:50 <kmc> Kaidelong, yeah
19:05:57 <absentia> kmc: well, how would you start.. to go about it ?
19:06:06 <absentia> (I was asked this for an interview question)
19:06:08 <kmc> Kaidelong, i think you should learn randomness in a simpler setting first
19:06:13 <kmc> absentia, a Haskell interview? o.O
19:06:16 <aavogt> such as, do you know if you have duplicates?
19:06:28 <fax> absentia: it's impossible
19:06:45 <fax> absentia: suppose the list was [2,3,4,5,6,7,8,9,....] there's no way to know that you might see a 1 eventually
19:07:00 <absentia> :-)
19:07:00 <kmc> if your type has a least element, you can produce a stream of occurrences of that element as you encounter them
19:07:04 <kmc> you'll never produce a higher element
19:07:12 <fax> what does that mean
19:07:17 <kmc> and you'll stall nonproductively if the list doesn't contain an infinite number of the least element
19:07:39 <danharaj> conceptually it doesn't make sense to sort an infinite list does it?
19:07:47 <kmc> sort (repeat False) should be equivalent to (repeat False)
19:07:49 <absentia> it was an interview question
19:07:55 <danharaj> Your basic operations are head and tail.
19:07:56 <kmc> but (sort (repeat True)) will never produce any elements
19:08:09 <kmc> (except sort doesn't actually have that property in standard Haskell)
19:09:10 <kmc> Kaidelong, the basic problem is, how does the function that's *calling* spawn or mate get the new generator state?
19:09:13 <kmc> after spawn or mate returns
19:09:15 <fax> absentia: what did you answer?
19:09:48 <Kaidelong> kmc: I take it the Rand class handles that. Couldn't I return a tuple of the next random generator and the chromosome, though?
19:10:00 <kmc> "I take it the Rand class handles that"
19:10:01 <kmc> how?
19:10:08 <kmc> you're right that you can return a tuple
19:10:15 <kmc> that's exactly what the Rand monad does behind the scenes
19:10:16 <Kaidelong> kmc: the return type you propose was Rand
19:10:19 <Kaidelong> ok
19:10:19 <absentia> I asked what was the goal of attempting to do this since the storage woudl quickly get out of hand... if there was a practical goal here, perhaps it could be addressed with something that wasn't the exact same as trying to retain all the values in sorting two infinite lists.
19:10:23 <kmc> Kaidelong, oh.  Rand isn't a class
19:10:27 <kmc> then
19:10:28 <Kaidelong> right
19:10:29 <Kaidelong> instance
19:10:30 <Kaidelong> sorry
19:10:31 <kmc> no
19:10:34 <kmc> it's not an instance
19:10:37 <kmc> it's a data type
19:10:43 <Kaidelong> data constructor
19:10:50 <Kaidelong> hmm
19:10:51 <kmc> or yeah a "type constructor"
19:11:36 <danharaj> Can you turn any haskell type constructor into a functor?
19:11:45 <Kaidelong> what are the advantages of using Control.Monad.Random and Rand over using a tuple?
19:11:50 <danharaj> Seems like you should, barring weirdness.
19:11:58 <kmc> Kaidelong, lighter weight syntax
19:12:05 <kmc> Kaidelong, the "plumbing" is hidden
19:12:17 <kmc> and you can use "do" notation and the functions from Control.Monad and Control.Applicative
19:12:21 <kmc> instead of threading that generator yourself
19:13:19 <kmc> a "do" block in the Rand monad is basically an imperative mini-language where the only "side effect" you can do is generate random values
19:13:51 <Cale> danharaj: Not really, no
19:14:09 <Cale> danharaj: Consider something like  data Foo a = F (a -> a)
19:14:11 <kmc> and the result of such an imperative program is a pure function of the input generator
19:14:14 <absentia> guys asked me what "haskell" was .. in my interview today.
19:14:18 <kmc> which is what evalRand gives you
19:14:19 <absentia> I told them it was lisp++
19:14:21 * absentia rofls.
19:14:23 <kmc> heh
19:14:27 <Cale> absentia: haha
19:14:32 <absentia> (that wasn't my full response) .
19:14:37 <aavogt> who for?
19:14:43 <absentia> Time, Inc.
19:15:18 <BlackM> absentia: Wow, it seems Time really _is_ on your side!
19:15:20 <danharaj> Dur. Thanks Cale. Mindfart there. 'Polynomial' type constructors though...
19:15:28 <BlackM> Yes, it is! ;
19:15:34 <absentia> yes, it is.
19:15:36 <fax> hehe
19:15:51 <Kaidelong> kmc: Okay, I'll learn Control.Random.Monad
19:15:51 <Cale> danharaj: yeah
19:15:58 <Kaidelong> I would have had to learn System.Random anyway
19:16:07 <kmc> Kaidelong, they interact
19:16:15 <Kaidelong> although I'd grasped some of the theory behind it
19:16:27 <Kaidelong> basically, the random generator returns a random number and the new world it left
19:16:36 <Kaidelong> so you make a new one with the new world the old one made
19:16:36 <kmc> Rand is very much like (State g) for g your generator type
19:16:45 <kmc> where State is from C.M.State
19:17:00 <Kaidelong> that's how I understood it anyway
19:17:08 <Cale> danharaj: I think new versions of GHC can even derive Functor instances
19:17:14 <danharaj> cool.
19:17:36 <danharaj> The problem with your example, btw, is that you are plugging a into both sides of Hom(-,-) which has mixed variance, right?
19:20:41 <Eduard_Munteanu> I'd view sorting an infinite list as an online sort.
19:20:53 <Eduard_Munteanu> That is, sort data as you receive it.
19:22:03 * BMeph majored in Random at Monad.State
19:31:03 <danharaj> I really wish C++ had algebraic data types, first class functions, and pattern matching :|
19:31:27 <copumpkin> I really wish c++ were not c++
19:31:33 <danharaj> Just ++ ?
19:32:01 <pikhq> danharaj: It posssesses first-class typelevel functions and typelevel pattern matching. That close enough? :P
19:33:33 <kmc> yeah
19:33:46 <Kaidelong> kmc: mate :: (RandomGen g) => a -> a -> Rand g a
19:33:53 <Kaidelong> how do you feed this the generator?
19:34:11 <kmc> when you first learn Haskell every feature seems exciting new and experimental... then after a while you see that some of them really are, and others are just basic things that most languages should but don't have
19:34:13 <Kaidelong> shouldn't it be g -> a -> a -> Rand g a?
19:34:17 <kmc> i think algebraic data is in the latter category
19:34:24 <kmc> Kaidelong, the argument is implicit
19:34:30 <Kaidelong> kmc: F# had algorithmic data types
19:34:32 <danharaj> Its type system is turing complete. It makes you wonder why the hell it doesn't have a modern basic type system.
19:34:47 <Kaidelong> kmc: I don't understand that at all
19:34:50 <kmc> sure, F# and SML and OCaml and Scala have algebraic types
19:34:56 <kmc> Haskell is far from the only language that does
19:34:59 <Kaidelong> algebraic
19:35:03 <kmc> but it's surprising how many don't
19:35:09 <Kaidelong> fingers... type things...
19:35:32 <danharaj> C++ also needs a modern module system. I like Haskell's
19:35:43 <Kaidelong> kmc: I am hoping Scala and F# will gain some traction, F# was a joy to work with and largely is the reason I'm learning Haskell now
19:35:44 <danharaj> Maybe it could be a little better, like exporting qualified.
19:35:45 * twink likes OCaml's module system.
19:35:54 <kmc> Kaidelong, a value of type (Rand g a) is very much like a function of type (g -> (a, g))
19:36:03 <kmc> @unmtl State g a
19:36:03 <lambdabot> g -> (a, g)
19:36:13 <kmc> Kaidelong, you supply the "initial" generator when you call runRand or evalRand etc
19:36:27 <Kaidelong> kmc: So the type constructor can actually build a function as well as a value?
19:36:34 <kmc> functions are values
19:36:40 <Kaidelong> err, well, true
19:36:50 <Kaidelong> oh I see
19:36:52 <kmc> that's a basic CS fact that's obscured by shitty language design
19:37:18 <kmc> Kaidelong, you might want to learn the State monad first
19:37:21 <kmc> Rand is very similar
19:37:29 <kmc> and implemented in terms of it
19:37:30 <kmc> just provides some specialized accessors
19:37:36 <Kaidelong> kmc: so this is just a use of currying then
19:37:45 <kmc> Kaidelong, not especially
19:37:50 <kmc> newtype State s a = State (s -> (a,s))
19:38:02 <kmc> runState :: State s a -> s -> (a, s)
19:38:05 <kmc> runState (State f) = f
19:38:09 <Kaidelong> oh okay
19:38:20 <Kaidelong> so I have to call "runRand" or the equivalent first
19:38:25 <kmc> right
19:38:31 <kmc> http://www.haskell.org/ghc/docs/6.10-latest/html/libraries/mtl/src/Control-Monad-State-Lazy.html may be instructive
19:38:56 <kmc> what continually amazes me about this abstraction called "monad" is that it allows you to extend the language in very few lines of code
19:39:34 <ddarius> It doesn't allow you to extend the language at all.
19:39:38 <kmc> metaphorically
19:40:13 <ddarius> If we had call/cc you could take a perspective like that.  It could be viewed as "extending" the "call/cc-less" subset of the language with a new primitive.
19:40:47 <kmc> i don't follow
19:40:49 <danharaj> you can do call/cc with monads can't you?
19:41:18 <kmc> danharaj, essentially yes
19:42:04 <kmc> in a broad sense, every monad uses "do" as sugar for something.  Cont uses it as sugar for a continuation-passing transform of your code
19:42:09 <ddarius> kmc: The problem with monads is that using a monad is a global transformation.  If we had call/cc we could add things like mutable state by defining local operations.
19:42:36 <kmc> so it's important that Haskell (and every other functional language) already supports explicit continuation passing
19:42:57 <kmc> which is just a consequence of having first-class functions and tail calls
19:43:25 <kmc> Cont just makes the syntax feel more like programming with actual first class continuations a la scheme
19:43:26 <danharaj> I think it's not 'monad' that is essential, but the fact that the type system is expressive enough to give a type to a wide variety of kinds of computation. The fact that many kinds of computations are monadic is an interesting theoretical fact.
19:44:18 <kmc> danharaj, i think the important thing is that "do" notation and general purpose control flow functions like mapM and guard are overloadable
19:44:36 <kmc> it means less re-learning when someone introduces a new embedded language
19:44:52 <kmc> which makes it more reasonable to solve a larger set of problems with embedded languages
19:45:09 <kmc> (understanding "embedded language" in a broad sense that encompasses most if not all monads)
19:45:44 <danharaj> I don't think sugar is that important.
19:46:13 <kmc> not having to redefine mapM and liftM2 and <*> every time is not sugar
19:47:15 <danharaj> That's a consequence of what a monad (applicative functor) is.
19:47:35 <kmc> the types are important too but i think monadic-style programming would catch on in dynamically typed languages if they had good syntax (either a direct sugar like "do", or just better syntax for defining and applying first-class functions)
19:47:43 <kmc> Lisp and Scheme would be the interesting candidates there
19:47:52 <ddarius> There are monad libraries for Scheme.
19:48:01 <danharaj> There is a monad library for C++
19:48:25 <kmc> every FP library for C++ is basically a cruel joke
19:49:10 <kmc> with the standard <algorithm> library, a call equivalent to (filter (<x)) takes about 20 lines of code to set up properly
19:49:33 <ddarius> kmc: You should see XSLT.
19:50:19 <danharaj> FC++ looks pretty decent
19:51:08 <danharaj> Template metaprogramming is like a midget taming a grizzly bear. If you can manage it, well you can get something remarkable. Of course, compile times will be a bitch.
19:51:24 * kmc reads FC++ tutorial
19:51:35 <danharaj> Still, the fact that functions -still- aren't first class in C++ is frustrating.
19:51:46 <danharaj> Let the functional revolution come in incremental language updates!
19:51:55 <ddarius> danharaj: If you can program Haskell, C++ template metaprogramming is just a straightforward syntactic translation away.
19:52:03 <arw> template metaprogramming is like postscript documents calculating the results they display. while its possible and cool, its still ugly.
19:52:40 <kmc> i don't see what all the confusion is about
19:52:44 <kmc> C++ is an esoteric language
19:52:54 <p_l> haha
19:52:56 <p_l> I agree
19:53:05 <kmc> like Brainfuck or INTERCAL
19:53:13 <kmc> it has bizarre concepts not found anywhere else
19:53:24 <kmc> design features that interact in obscure ways
19:53:47 <kmc> divergent implementations none of which implement the standard
19:53:55 <ddarius> Haskell with extensions has all of those.
19:54:23 <aavogt> there is no standard for haskell extensions
19:54:30 <kmc> yeah
19:54:48 <aavogt> or do you count the papers which describe something subtly different from what is actually implemented?
19:56:02 <kmc> writing simple programs in C++ templates or in Brainfuck or using -XUndecidableInstances for logic programming all seem about equivalent to me
19:56:18 * absentia actually qite likes bf
19:56:38 <ddarius> No, Brainfuck is quite a bit more tedious and impractical than either of those.  Of those, C++ templates is the most practical and straightforward (if noisy.)
19:56:39 <aavogt> you need a bunch more -X flags
19:56:41 <pikhq> kmc: Quite easier in Brainfuck.
19:56:47 * pikhq can read Brainfuck.
19:56:52 * pikhq cannot read C++ templates
19:57:22 <ddarius> pikhq: You can read SK combinators too, but that doesn't make the language of SK combinators more practical.
19:57:54 <pikhq> ddarius: SK combinators only become nice when you implement lambda calculus as sugar. ;)
19:58:02 <kmc> equivalent in that they are fun exercises and i am impressed by anyone who can do any of those well, but i'm skeptical of any real-world application
19:58:25 <pikhq> At which point they become quite usable, oddly enough.
19:58:35 <kmc> skeptical not implying that there aren't any, of course
19:58:41 <ddarius> There are tons of real world applications of C++ template metaprogramming and as I said, modulo a very verbose syntax, C++ template metaprogramming is pretty straightforward functional programming.
19:58:55 <danharaj> Well, it lets you hack in more complicated type constructors.
19:58:58 <kmc> C++ has this property where the syntax is so awful to parse and generate that you're better off using the built in clunky metalanguage than implementing a proper metaprogram yourself
19:59:31 <kmc> but as a metalanguage it lacks some very basic things
20:00:05 <BMeph> If Brainfuck weren't so trivial to code in C, it would entertain me. As it is, it makes me go, "Meh." :|
20:00:08 <ddarius> One of the first Haskell programs I wrote made a little Haskell like language with pattern matching, higher order functions, recursion and translated it to type-level C++.  The translation was literally "fill
20:00:11 <ddarius> in the blanks"
20:00:14 * Eduard_Munteanu just likes plain C macro magic :P
20:00:22 <danharaj> template metaprogramming was kind of an accident
20:00:35 <absentia> bmeph: threaded bf...
20:00:47 <kmc> BMeph, you mean trivial to implement?
20:00:53 <kmc> the fun of bf isn't in implementing
20:01:10 <kmc> though a JIT compiler or a FPGA implementation may be entertaining to make
20:01:12 <ddarius> The whole point of Brainfuck is to have small implementations.
20:01:28 <ddarius> Otherwise Brainfuck is a rather boring language.
20:01:56 <danharaj> x86 assembly is more of a brainfuck anyway :p
20:02:17 <kmc> x86 assembly is :psyduck:
20:02:28 <kmc> 300 useless instructions and only 6 registers
20:02:43 * hackagebot bmp 1.0.0.0 - Read and write uncompressed 24bit BMP image files.  http://hackage.haskell.org/package/bmp-1.0.0.0 (BenLippmeier)
20:03:26 <BMeph> kmc: Well, its triviality of implementation in C just reminds me how C is easily thought of as a wordier form of BF. It takes the fun out of coding silly stuff in it - for me, anyway.
20:03:28 <pikhq> kmc: Implementing Brainfuck *well* is actually an interesting thing.
20:03:42 <Eduard_Munteanu> I imagine writing "asm" for a NISC CPU... that would be total literal brain fucking.
20:03:51 * kmc is still reading about FC++
20:04:06 <danharaj> that must mean you find it intriguing :p
20:04:10 <Eduard_Munteanu> And yes, that stands for No Instruction Set CPU, IOW you simply control internal signals.
20:04:28 <kmc> Eduard_Munteanu, there's some microcontroller where the only instruction is "move"
20:04:29 <ddarius> Eduard_Munteanu: It's called VHDL.
20:04:31 <kmc> and all operations are memory-mapped
20:04:35 <kmc> move-to-ALU, etc
20:04:43 <pikhq> (JIT compilation, highly-optimizing compilation, implementing *in another esolang*, these are all interesting. Basic implementations? Those are things you code up in half an hour and then toy with.)
20:04:57 <kmc> FC++ has ornate complicated things with scary names like "monomorphic direct functoids"
20:05:02 <kmc> and i think what they actually give you is quite basic
20:05:12 <kmc> but it occurs that a beginner to Haskell would say the same about monads or whatever
20:05:27 <Eduard_Munteanu> ddarius: that for describing hardware, writing software is another deal :)
20:06:06 <ddarius> Eduard_Munteanu: The behavioral specification part of such tools, is just a programming language.
20:06:33 <Veinor> is hjson good?
20:06:47 <Veinor> or, what should I use for simple JSON stuff?
20:07:17 <Eduard_Munteanu> ddarius: yeah.
20:07:57 <Eduard_Munteanu> kmc: hm, I contemplate mov ALU.operation, '+' :)
20:08:55 <Eduard_Munteanu> Actually, in a NISC CPU the compiler has to schedule microoperations, increment the PC and all that stuff.
20:09:03 <Eduard_Munteanu> Quite a lot to deal with in software.
20:13:04 <dmode> Hi there. Does anyone know of any examples of startups using Haskell? I've always been curious about how Haskell's strong, static typing would affect a rapidly-developed application.
20:13:09 <danharaj> Should I be threading an IORef s through a bunch of a -> IO (IORef s) or is this doin it rong?
20:13:58 <kmc> dmode, i think it'd be a win on balance, if you have smart and knowledgeable people
20:13:59 <aavogt> danharaj: so you're making new IORefs?
20:14:07 <kmc> spend less time writing tests and more time writing types
20:14:13 <danharaj> No, I'm just passing an IORef in and then returning it, so that it gets threaded to the next one.
20:14:20 <kmc> danharaj, why return it?
20:14:22 <aavogt> that's no necessary
20:14:29 <kmc> danharaj, an IORef value is the name of a box in memory where values are put
20:14:42 <danharaj> ah so it's really a global variable.
20:14:48 <danharaj> And I've been using it like State.
20:14:52 <Eduard_Munteanu> Don't let monadic stuff creep in places where it shouldn't be.
20:15:02 <Eduard_Munteanu> especially IO.
20:15:14 <danharaj> This is at the top level of the program.
20:15:17 <dmode> kmc: Yeah, I was thinking that the initial cost of thinking the program out ahead of time would pay off when you have little to no simple, stupid errors later on down the road
20:15:29 <kmc> danharaj, "global"? the box is globally accessible in a sense, but you need the name to get it, and the name is passed and scoped the same as any other value
20:15:37 <kmc> by "name" i mean the IORef value
20:15:54 <danharaj> right. So my functions should return IO () instead of IO IORef
20:16:37 <Eduard_Munteanu> Yes.
20:16:42 <danharaj> k
20:16:47 * hackagebot bmp 1.0.0.1 - Read and write uncompressed 24bit BMP image files.  http://hackage.haskell.org/package/bmp-1.0.0.1 (BenLippmeier)
20:16:51 <danharaj> And the way I was thinking about it would have been using StateT?
20:17:45 <Eduard_Munteanu> I'm not very familiar with that stuff :/
20:19:28 <danharaj> Yay. Alright everything is working the way I would like. Now I can start designing the command parser.
20:22:08 <patch-tag> how smart is dph? Say I have a data munging task that can be partitioned by first letter somehow. So, 26 tasks can be done in parallel adn it would get done. Will dph backburner stuff so that memory won't get exhausted?
20:22:35 <patch-tag> Assuming that any 1 task is doable, but say, 10 tasks at full bore might exhaust memory?
20:22:54 <nus> sparking is lazy
20:23:05 <patch-tag> nus: u talkin 2 me?
20:24:26 <nus> "A spark is an indication that a thunk might usefully be evaluated in parallel, not that it must be evaluated in parallel"
20:26:20 <patch-tag> hmmmmm... thans nus. i will muse.
20:27:41 <Cale> He was asking about data parallelism...
20:27:52 <Cale> hmm
20:28:42 <Cale> I don't think dph or par is so smart about conserving memory as of yet. They mostly try to complete tasks as quickly as possible.
20:35:18 <nus> http://hackage.haskell.org/trac/ghc/wiki/DataParallel/SMP
21:03:22 <siracusa> I can't get a list from a map with all elements in that order they where inserted into the list, can I?
21:04:10 <Veinor> so, how would you represent the JSON object {f:1, g:"foo"} in Haskell?
21:04:33 <DigitalKiwi> hehe i almost just answered siracusa question thinking this was #lua :(
21:04:43 <dino-> Veinor: (1, "foo") perhaps
21:04:44 <Veinor> siracusa: what do you mean?
21:05:09 <Veinor> ahhh, JSValue
21:05:13 <copumpkin> haskell + JSON isn't too pretty
21:05:29 <SubStack> Veinor: http://www.haskell.org/haskellwiki/Heterogenous_collections
21:05:49 <SubStack> although there are already json libs
21:05:54 <Veinor> yeah, I know
21:05:58 <Veinor> I was just wondering how they handle that
21:07:12 <siracusa> Veinor: When I insert key/value pairs into a map and later retrieve all elements by toList, the are sorted by the key values. But I want the original order the where inserted.
21:07:21 <SubStack> looks like some hacking about with Data and Typeable instances
21:08:25 <Veinor> I... don't think that's possible
21:08:33 <SubStack> siracusa: you can always keep track of the order of key insertions in a list
21:08:57 <jbapple> But then you couldn't do deletions
21:09:02 <SubStack> sure you can
21:09:10 <jbapple> not in O(lg n)
21:09:15 <SubStack> pfft, whatevs
21:09:32 <SubStack> you can do them is what's important
21:09:41 <jbapple> You could make a new type MyMap k v = Data.Map k (Int,v)
21:10:13 <jbapple> actually, MyMap k v = MyMap Int (Data.Map k (Int,v))
21:10:33 <jbapple> The Int associated with the map stores the number of values inserted
21:10:46 <jbapple> (It does not decrement on delete)
21:11:27 <siracusa> Yeah, I hoped I could avoid that extra effort
21:11:41 <jbapple> Then, insert takes the k and v, finds the count of the MyMap, uses that as the Int to glom on the v, then returns a new map with the values inserted and the count incremented
21:12:05 <jbapple> Well, if you package it up and submit it to hackage, the next person can avoid the extra effort :-)
21:12:24 <siracusa> Is that worth an extra package?
21:12:33 <jbapple> I don't know how merge would work exactly, without being O(n+m)
21:13:18 <Veinor> wouldn't merge be O(min(n,m))?
21:13:57 <Veinor> er, hm
21:14:00 <DigitalKiwi> O(n*m)!
22:09:53 <ManateeLazyCat> Hi all, i have finish GIO 2.24.0 binding at https://patch-tag.com/r/AndyStewart/gio-branch, welcome to test. :)
22:12:09 <ManateeLazyCat> You just need install three packages (tools, glib, gtk) from gtk2hs darcs repo, then you can install gio with "cabal install"
22:12:09 <ManateeLazyCat> Enjoy!
22:40:14 <Runar> If I have a natural tranformation between functors F and G, but constrained so that it's only defined on elements for Fx -> Gx, where x is a monoid, is it still a natural transformation?
22:41:54 <Cale> Runar: so F and G are functors on the category of monoids?
22:42:17 <Cale> (to some other category)
22:42:20 <Cale> sure
22:42:46 <Cale> If F and G are any two parallel functors C -> D, then you can talk about natural transformations F -> G
22:43:06 <Cale> It doesn't matter which categories C and D are.
22:43:30 <Cale> (as long as they're the same C and D for the two functors)
22:45:06 <Runar> concrete example: Say F is [] and G is Identity. I want to talk about foldr as a natural transformation. Is that appropriate?
22:45:23 <Runar> foldMap, rather
22:46:15 <Runar> OK, yes, I see what you mean. They will be the same categories.
22:46:21 <Runar> Thanks, Cale.
22:48:02 <mamalujo> haskell.org is down?
22:52:04 <humasect> @src zip
22:52:04 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
22:52:05 <lambdabot> zip _      _      = []
22:52:35 <humasect> .oO{ ok, so this would translate to about 50-100 lines of C }
22:53:04 <humasect> hmm... how does a haskeller get his fix when not able to use haskell ?
22:53:33 <pikhq> humasect: Many, many, many crazy ways.
22:53:36 <humasect> there is some code that is very difficult to convert , but then maybe one was simply spoiled with haskell  ...
22:53:50 <humasect> hmm, yeah ? =)
22:53:57 * humasect listening
22:54:15 <pikhq> I've done lambda in C, myself.
22:54:22 <humasect> hm interesting
22:54:26 <pikhq> Yes, it is as frightening as it sounds.
22:54:38 <humasect> depends how desperate one is! =)
22:54:48 <djahandarie> Guys, C is a purely functional language anyways. ;)
22:54:54 <humasect> yeah , that is true hehe
22:55:10 <pikhq> djahandarie: :)
22:55:37 <humasect> i have a lot of constructive solid geometry math in haskell that are mostly one-liners. it is making me nautious to contemplate how much typing/spelling/work/reading/navigating source will be required to "downgrade"
22:56:16 <humasect> i haven't cried in a long time .. but suddenly i feel it might be the only solution, hehe
22:57:03 <BenceF> use COBOL
22:57:09 * humasect investigates
22:57:28 <pikhq> Thanks a lot, Grace Hopper.
22:57:47 <humasect> i don't think i can =)
22:59:29 <BenceF> http://bartoszmilewski.wordpress.com/2009/10/21/what-does-haskell-have-to-do-with-c/ this is interesting
22:59:39 <humasect> hmm - i just found this : http://github.com/mogeneration/functionalkit
22:59:46 <SubStack> humasect: in opengl?
22:59:59 <humasect> the haskell version was opengl yep
23:00:02 <SubStack> nifty
23:00:03 * glguy throws some Agda into the mix http://www.galois.com/~emertens/treerec/preorder.html
23:00:10 <humasect> (custom binding)
23:00:32 <humasect> glguy: hmm that looks nice =)
23:00:35 <SubStack> I wrote an analytic root finder for haskell in opengl that can do csg with min() and max() >:D
23:00:48 <SubStack> well, most of the work happened in the shader which is written in C
23:01:10 <humasect> hehe, cool=)
23:01:12 <SubStack> with some crzy macro tricks and cpphs preprocessing for function parameterization
23:01:35 <SubStack> also has cpu emulation
23:01:37 <humasect> hmm, yes .. looking at BenceF's link too i am considering c++templates as well as cpp
23:01:44 <SubStack> it's a mess though
23:02:24 <humasect> hehe, with all the layers ? =)
23:02:27 <glguy> humasect: let me know if you read through it and have any feedback
23:02:32 <BenceF> humasect: hes using the new --std= . and its always gonna be ugly as hell
23:02:36 <glguy> It is under construction
23:03:35 <BenceF> D might be better for this kind of stuff, maybe. however i dont think D is a reliable language as it is
23:03:47 <BenceF> but nor is c++ :)
23:03:57 <humasect> D .. isnt it poor man's ruby ?
23:04:03 <ivanm> when did this turn into #D?
23:04:08 <humasect> c++ has a few more years and maturity
23:04:21 <humasect> ivanm: oh but it all relates to haskell!
23:04:42 <humasect> glguy: i would use it, if i could! it looks very nice . also pretty=)
23:05:14 <BenceF> if you could eliminate backwards compatibility with C, and sort out template syntax, c++ would be quite good
23:05:57 <humasect> glguy: oh, there is more! i am missing some symbols, what kind of font or encoding shall i select for further browsing ?
23:06:07 <ivanm> humasect: _sure_ it does
23:06:34 <humasect> BenceF, ivanm: this project i am needing to convert some heavily computative modules from haskell to objective-c
23:06:42 <glguy> humasect: it is UTF-8 encoded
23:06:51 <glguy> it works for me in Firefox and Safari
23:07:14 <ivanm> aha
23:07:59 <glguy> humasect: for one, ∎ is actually supposed to be a black box :)
23:08:27 <humasect> glguy: most of the symbols become white-square at the bottom of Algebra.Morphism for eg. (loading safari to test)
23:09:11 <humasect> oh there it is ... why do you tempt me with this beauty in my fragile state?? =)
23:09:34 <glguy> humasect: you wasted no time in diving into the directory index :-D
23:09:36 <BenceF> havent tried objective-c. however nextstep looked rad back then
23:09:47 <humasect> glguy: hehe, true.
23:11:27 <humasect> is it called 'Agda' ?
23:11:59 <glguy> humasect: yeah. http://wiki.portal.chalmers.se/agda/pmwiki.php
23:12:06 <humasect> BenceF: its much cleaner than c++ ! conveniently too, c++ and objc can be mixed in the same file... so i am curious to look at templates again to help me with my quest
23:13:16 <humasect> hmm interesting
23:15:38 * hackagebot process-leksah 1.0.1.3 - Process libraries  http://hackage.haskell.org/package/process-leksah-1.0.1.3 (HamishMackenzie)
23:16:44 <ivanm> seriously, leksah needs to fork all these libraries?
23:16:57 <humasect> hehe (i get this in twitter)
23:17:01 <hamishmack> ivanm: yes
23:17:17 <ivanm> hamishmack: can't you get upstream to apply your changes?
23:17:47 <hamishmack> I have submitted a patch
23:17:58 <hamishmack> but process comes with ghc
23:18:05 <ivanm> ahhhh
23:18:14 <hamishmack> having multiple versions causes headaches
23:18:19 <ivanm> and this way you avoid the diamond dependency problem
23:18:55 <hamishmack> also uses different namespace to avoid problems with ghc --make
23:19:07 <ivanm> right
23:25:20 <max_atre1des> i'm reading Read World Haskell right now and i'm finding that Regex examples from chapter 8 are not giving the same results on my ubuntu lucid machine. Is that a known issue?
23:25:30 <max_atre1des> *this
23:25:39 <max_atre1des> *Real World Haskell
23:26:55 <ivanm> max_atre1des: which version of the regex libraries are you using?
23:28:33 <max_atre1des> how do I find out? :)
23:28:47 <max_atre1des> i'm assuming it's the latest since it's newest Ubuntu edition
23:29:14 <Jafet> Hah
23:30:32 <max_atre1des> never mind, it works now
23:30:38 <max_atre1des> sorry to bother you
23:31:30 <Jafet> There is cabal info
23:32:34 <Jafet> Nevermind, Text.Regex isn't a separate package
23:33:04 <ivanm> I take it cabal info is just a wrapper around ghc-pkg info?
23:34:20 <Jafet> You mean describe? Maybe
23:34:23 <BenceF> i dont think haskell comes with cabal in default on ubuntu
23:34:55 <Jafet> I don't think you should use the haskell implementations from the repositories on ubuntu
23:35:36 <Saizan> ivanm: except that it gives you informations that ghc-pkg doesn't know about
23:36:03 <BenceF> i'm using arch. but i shouldnt use the package from there neither. but its too late :)
23:36:10 <ivanm> Saizan: oh, right, from the cabal file?
23:36:11 <Saizan> but it does call ghc-pkg to see what you have installed
23:36:17 <Saizan> ivanm: yeah
23:36:23 <ivanm> BenceF: it does; cabal comes with GHC
23:36:26 <BenceF> last time i checked nothing compiled from cabal
23:36:31 <ivanm> cabal-install, on the other hand, is a separate package
23:36:51 <Saizan> "Cabal" comes with ghc, the library
23:36:53 <ivanm> BenceF: just about everything except ghc and gtk2hs use cabal for compilation (and gtk2hs is getting there)!
23:37:06 <Saizan> "cabal" the executable comes in the cabal-install package
23:38:18 <BenceF> i should clean up my haskell installation, cause its turning into a mess. im just too lazy. and my connection as well
23:40:27 <BenceF> i mean my connection is lazy too
23:42:48 <BenceF> i tried to install yi 2 times. gave up
23:45:28 <ivanm> yeah, yi is a horrible beast to get working
23:51:18 <BenceF> now im quite content with my vim
23:51:53 <glguy> I tried yi, but it insisted on allowing the cursor to run off the end of the line
23:52:32 <glguy> $ would send the cursor to: end[ ] instead of en[d]
23:53:15 <opqdonut> end[ ] is a perfectly valid place to put the pointer IMO
23:53:17 <Jafet> Does en[d] place the cursor before or after the 'd'?
23:53:29 <glguy> on the d
23:53:32 <BenceF> i tried to write a vi-like editor for my phone in j2me. but it didnt want to obey and use monospace font and i got butthurt
23:53:32 <glguy> and then you press i or a
23:53:33 <Jafet> (The logical cursor, rather than the display one.)
23:53:36 <glguy> to edit before or after
23:53:38 <BenceF> maybe ill revisit it
23:53:50 <Jafet> I see
