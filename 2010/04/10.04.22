00:00:10 <ManateeLazyCat> Good news, i have finish convert WebKit package to Cabal, i will build new repository for WebKit later.
00:00:15 <ezyang> ok, the action of the functor on te arrows is the interesting bit
00:00:26 <kamatsu> blackdog: well, it's  either that or the UniBar
00:00:31 <kamatsu> blackdog: neither seem like a good option
00:00:56 <blackdog> kamatsu: I was thinking perhaps of venturing into the city
00:01:05 <blackdog> where a plenitude of good bars awaits us
00:01:17 * blackdog is not completely sure that's a word but is going to roll with it anyway
00:01:18 <ezyang> wait, how does that make sense
00:01:37 <ezyang> by definition doesn't if X -> Y, then F(X) -> F(Y)?
00:01:59 <ddarius> ezyang: Yes, but F doesn't need to be faithful.
00:02:09 <kamatsu> blackdog: plentitude, rather
00:02:18 <ezyang> I don't have a good intuition for faithfulness
00:02:42 <ski> a functor is faithful iff each morphism-class mapping is injective
00:02:54 <ski> a functor is full iff each morphism-class mapping is surjective
00:02:56 <blackdog> kamatsu: actually, plenitude seems to work
00:03:02 <blackdog> a great sufficiency
00:03:11 <ezyang> oh, so is this the "forgetful functor"?
00:03:22 <ddarius> ezyang: No.
00:03:28 <ski> "forgetful functor" is a vague concept
00:03:30 <ddarius> A particular species is a particular functor.
00:03:48 <ezyang> well, I'm wondering if you'd describe a species as a forgetful functor
00:04:06 <ddarius> ezyang: No, you wouldn't in most cases.
00:04:16 <ezyang> ok
00:04:35 <ezyang> so a species can drop some of the bijections as long as it doesn't tread on any laws
00:04:38 <ezyang> I think I can buy that
00:04:48 <ddarius> ezyang: s/drop/merge/
00:04:57 <ezyang> aha
00:05:16 <ddarius> For example, we could map every bijection U -> U to the identity bijection F(U) -> F(U).
00:05:27 <ski> (typically a forgetful functor "forgets" the extra structure of a concrete category (such as groups over sets) to just give you the "underlying" category (sets, in the example) .. however, one often defines a concrete category `B' as a category `A' and a "forgetful functor" from `B' to `A')
00:06:07 <ezyang> right-o
00:06:13 <ezyang> oh.
00:06:22 <ezyang> now it seems really obvious from the definition byorgey writes initially
00:06:53 <ski> (often, a forgetful functor is faithful, but that's not strictly necessary, afaiui .. e.g. if you have a category where each object has two carriers, then a functor that forgets one carrier (and operations and laws related to it), would be considered forgetful (provided it preserves the rest of the structure))
00:06:58 <ezyang> Now I just don't believe the endo- bit :-)
00:07:17 <ddarius> ezyang: The "endo" part isn't too important except for functorial composition.
00:08:03 <ezyang> Ok. So, finite set can have extra structure.
00:08:23 <ezyang> it now seems clear
00:10:12 <Saizan> "map every bijection U -> U to the identity bijection F(U) -> F(U)" <- is this defining a species that doesn't "contain" the elements?
00:10:38 <ddarius> ezyang: This extra structure is in your head though.  The bijections don't preserve it.  Rather, what you do is only allow the bijections that do preserve it.  So it is implicit.
00:11:02 <ezyang> OHHH!
00:11:13 <ezyang> "It is not what is there, but what is not there." Very zen.
00:15:07 <Axman6> hmm, netsplit?
00:15:20 <ezyang> Hm.
00:15:38 <ezyang> I was thinking about this some more. Would this imply that the same finite set can show as an object in the category more than once?
00:16:49 <Saizan> it could rather show up as the image of two different functors
00:21:13 <ddarius> ezyang: Let L be the list species and S the permutation species, i.e. the set of bijections on the given finite set.  |L([n])| = n! = |S([n])|  So there are just as many bijections on [n] as lists on [n], however, if you apply a bijection [n] -> [n] that produces a different list but doesn't change the set of bijections at all.  So given a bijection f : U -> U, L(f) /= id unless f = id, but S(f) = id for all f.
00:23:59 <kamatsu> can someone explain to me why C++ calls it's "functors"  functors?
00:24:07 <kamatsu> cos to me they don't look like functors
00:25:08 <koeien37> sounds like "functions"
00:25:17 <monochrom> because different communities use the same word for different meanings
00:25:48 <kamatsu> as far as  I was aware
00:25:49 * ski . o O ( `forall f : U -> U. L f = id => f = id' )
00:25:56 <kamatsu> the word functor came from  category theory
00:26:14 <kamatsu> and the haskell usage of functor seems closer to category theory than anything in C++
00:26:22 <kamatsu> well, not C++ functors anyway
00:26:28 <olsner> C++ is doing it wrong, as usual :)
00:26:32 <eevar2> kamatsu: can you explain why the FP communities call data structures 'persistent', even when they aren't persisted to permanent storage? :p
00:26:34 <kamatsu> so C++ people just  chose a random category theory word for no reason?
00:26:50 * ski thinks that sounds a bit like injectivity ..
00:26:55 <ddarius> kamatsu: I'm pretty sure they developed it independently.
00:26:58 <LeoD> functor stands for function object in C++'s case afaik
00:27:01 <arcatan> maybe it's just short for function call operator or something
00:27:27 <ddarius> ski: L is faithful.
00:27:39 <ski> ddarius : is that equivalent ?
00:28:02 <ski> "functor" have been used by logicians (well, at least in logic programming) to mean "function symbol" (when building expressions/terms)
00:28:14 <kamatsu> arcatan: apparently Function Object, but I don't see how it relates
00:28:44 <ski> in Prolog, "functor"s behave like constructors, i.e. they are injective and disjoint (unless they are the same functor)
00:29:00 <kamatsu> that sort of makes sense
00:29:06 <kamatsu> fun ctor
00:29:13 <kamatsu> fun (ction) (constru)ctor
00:29:45 <monochrom> Two communities create the same new word all the time.
00:29:53 <aavogt> it's worse with acronyms
00:30:11 <kamatsu> i just don't see why they chose to use "functor"
00:30:17 <kamatsu> it's an odd word and it confuses category theorists
00:30:29 <kamatsu> if the functor definition is different
00:30:32 <arcatan> C++ folks probably didn't take the term from category theory
00:30:34 <monochrom> Try "monad" some other day. You'll be surprised category theory didn't create it first, someone else famous created it centuries ago.
00:31:09 <kamatsu> so, then, why did category theory use a bunch of fun words from elsewhere?
00:31:17 <ddarius> As another example, let L+ be the species of non-empty lists and C be the species of cycles.  |L+([n])| = |C([n])|  And again, the difference is that for any bijection f, L+(f) is not the identity (except when f is), while C(f) is the identity in the cases where f "rotates" the labels.
00:31:48 <arcatan> a few years ago there was a blog post by some computer scientist, who complained that Ruby is confusing, because [1,2] + [3,4] == [1,2,3,4] and he totally expected it to be something else, like [4,6]
00:32:08 <ddarius> kamatsu: I don't think the name "monad" in category theory was particularly well motivated at all, though it is somewhat better than "standard construction" or "triple."
00:32:10 <arcatan> this conversation reminds me of it
00:32:33 <kamatsu> arcatan: I have no problem with that, but I do dislike perl's:
00:32:37 <kamatsu> @a = (1,2)
00:32:37 <lambdabot> Maybe you meant: activity activity-full admin all-dicts arr ask . ? @ v
00:32:39 <kamatsu> @b = (3,4)
00:32:39 <lambdabot> Maybe you meant: b52s babel bf bid botsnack brain bug . ? @ v
00:32:46 <kamatsu> @c =  (@a,@b)
00:32:47 <lambdabot> Maybe you meant: check choice-add choose clear-messages compose . ? @ rc v
00:32:53 <kamatsu> # --> (1,2,3,4)
00:32:58 <monochrom> It is probably wrong to assume that category theorist even knew that "monad" was already a word.
00:33:38 <monochrom> They just needed to mutate "monoid" somewhat.
00:33:50 <monochrom> perhaps s/need/want/
00:33:56 <aavogt> it also comes up in some discussions of how many arguments a function takes
00:34:15 <monochrom> monadic second-order logic
00:34:19 <ddarius> monochrom: I'd actually be surprised if the movers and shakers of CT during the time that name was coined/popularized weren't well aware of the, at least, two other meanings of the word.
00:34:59 <kamatsu> why reuse  existing words when the concepts are not analogous?
00:35:06 <ddarius> They probably, and mostly correctly, assumed that the issue of confusion wouldn't come up.
00:35:07 <kamatsu> why not just call them quapzangoloids
00:35:30 <monochrom> Haha "John Monad" and "Monad Proxy"
00:35:31 <ddarius> kamatsu: Because words have connotations as well as denotations.
00:35:31 <Guest24763> homographs
00:35:35 <Guest24763> they exists.
00:35:37 <Guest24763> -s
00:35:49 <theorbtwo> kamatsu: For what it's worth, I don't.  @foo is generally the elements of the array.  When you want to talk about the array as a whole, \@foo is what you want... but you aren't alone.  Perl 6 will change the meaning of (@a, @b) to be the same as (\@a, \@b).
00:36:09 <kamatsu> theorbtwo: yay
00:36:13 <theorbtwo> People generally don't like coining completely new words.
00:36:35 <kamatsu> theorbtwo: I get what it means, but it seems less useful to me.
00:36:50 <theorbtwo> kamatsu: It's often highly useful.
00:36:56 <Guest24763> like: lead
00:37:10 <ddarius> Anyway, humanity has proven time and again that it's up to handling such ambiguity.
00:37:31 <kamatsu> but, what if we end up in a situation where both concepts are used?
00:37:59 <ddarius> Then you say "CT monad" and "Leibniz monad."  Or you locally choose different terms.
00:38:13 <kamatsu> wah, qualified imports :(
00:38:19 <ddarius> This corresponds to qualification and renaming in programming.
00:39:24 <Guest24763> if one word isn't enough use two, three, ..., n, ..
00:47:12 <monochrom> I emphatically disagree with ddarius. Humanity has proven time and again the opposite. I was a kid in Hong Kong. One day I suggested to my parents that I wished to play in the "ball room". (Speaking "ball room" in English and the rest of the sentence in Chinese.) I was a kid and the only "ball room" I knew was the Ikea one with lots of plastic balls where kids play. The other "ball room" they, adults, knew meant places for danc
00:47:12 <monochrom> ing, and those were the days when gangsters dominated most dancing places. My parents scolded me, "those places are full of bad people, you are wrong to want to go." Excuse me? Ikea is full of bad people? You just brought me there one week ago, and watched me played in the "ball room" there. Why would I be talking about any other "ball room" whatever the other meanings are? Once again, humanity proves to not only fail at ambigu
00:47:12 <ski> kamatsu,(theorbtwo) : it would be nicer if you had to say `@a = @(1,2)', `@b = @(3,4)', and then `@c = (@a,@b)' to get `c' to be `(1,2,3,4)'
00:47:13 <monochrom> ity, but also fail at context. Humanity is worse than amoeba.
00:47:38 <ski> ddarius : well, maybe we just don't hear about the cases where the ambiguity wasn't handled ?
00:48:13 <theorbtwo> monochrom: Your parents are all of humanity?
00:48:35 <monochrom> Yes.
00:48:39 <kamatsu> ski: i like that  too
00:49:12 <theorbtwo> ski: I think the difference between wanting (1,2,3,4) and wanting ([1,2], [3,4]) should be where you are putting them together, and not where you are defining their contents.
00:49:22 <ski> kamatsu : so `@' works like a "reflection" operation on arrays (really lists), like in Filinski's "Abstracting Monads"
00:49:38 <kamatsu> yep
00:49:45 <theorbtwo> That said, $a = [1,2]; $b = [3,4]; $c = [$a, $b];
00:50:33 <ski> if we assume `!' (i don't know perl) is a corresponding reflection operation, then the third command could also be phrased `c = !(@a,@b)'
00:50:46 <ski> theorbtwo : resulting in what contents of `c' ?
00:51:06 <ski> theorbtwo : also, what do you mean by "putting them together" ?
00:51:59 <theorbtwo> ski: In [$a, $b], a reference to an array, consisting of two references to other arrays.
00:52:18 <theorbtwo> (1, 2) is a list of two elements.  [1, 2] is a reference to an array of two elements.
00:52:47 <ski> (well, if perl wants `$' prefix for array variables, then i guess the third command would be `$c = !(@a,@b)', then)
00:52:59 <theorbtwo> (Ignore the difference between an array and a list for the moment.)
00:53:22 <ski> theorbtwo : ok, kamatsu was talking about arrays, so i just assumed that the round brackets created arrays :)
00:53:53 <theorbtwo> ski: Parens create lists.  Square brackets create array *references*.
00:54:24 <theorbtwo> A reference to something is singular, so a variable holding it gets a $ prefix.
00:55:47 <monochrom> Perl is Hungarian notation gone wrong.
00:56:19 <theorbtwo> Sometimes.  Most of the time, it's hungarian notation gone right.
00:57:20 <theorbtwo> ski: The difference between lists and arrays in perl is subtle, and not at all the same thing haskell programmers use the words for.
00:57:36 * ski wasn't really assuming that :)
00:57:52 <theorbtwo> In @a = (1, 2), (1, 2) is a list, and @a is an array.  \@a and [1, 2] are both references to arrays.
00:58:27 <theorbtwo> Lists are immutable, but arrays are mutable.
00:59:28 <ski> oh, so lists and arrays appear to be really the same thing, only two different view-points
00:59:33 <ski> is that correct ?
00:59:50 <ski> (hm, no, you said something about mutability, too ..)
01:00:40 <theorbtwo> A list is a value, and an array is a container.
01:01:04 <theorbtwo> Arrays always contain lists.
01:01:39 <ski> i see, so like `IORef (Array Int a)' vs. `Array Int a', then ?
01:02:37 <theorbtwo> Yes, I think.
01:02:40 <ski> so, can you write `$c = \(@a,@b)', then ?
01:02:51 <theorbtwo> ski: Yes.
01:02:56 <ski> ah, nice :)
01:03:15 <theorbtwo> Somewhat annoyingly, that's the same as (\@a, \@b), not the same as [@a, @b].
01:03:25 <ski> (and i assume `c' will contain `(1,2,3,4)' with the above definitions of `@a' and `@b', then)
01:03:28 <theorbtwo> I would have expected the second one two; I avoid the construct.
01:03:38 <theorbtwo> s/two/too/
01:03:58 <ski> hrm, so `$c' becomes a reference to an array of size two ?
01:04:09 <theorbtwo> Yes.
01:04:18 <ski> (instead of a reference to an array containing `(1,2,3,4)')
01:04:24 <theorbtwo> Exactly.
01:04:25 <ski> ok, that's bad then ;)
01:04:34 <theorbtwo> Yeah, I agree.
01:04:51 <theorbtwo> It's one of those things that we are, unfortunately, rather stuck with now.
01:05:14 * ski sympathizes
01:05:52 <theorbtwo> BTW, reference to an array normally gets shorted to arrayref.  It saves quite a lot of typing.
01:06:34 <ski> so, `[@a,@b]' will create a (mutable) array initialized from the elements of `$a' and `$b', yes ?
01:06:44 <ski> (or maybe you can't say `$a' after having defined `@a' ?)
01:09:01 <theorbtwo> ski: Correct.  And yes, $a and @a are two different variables.
01:09:31 <theorbtwo> Oh.  Not quite.  [@a, @b] will create a mutable array-ref initialized from the elements of @a and @b.
01:09:41 <fasta> What language is this?
01:09:45 <theorbtwo> Of course, it will also create the array that it refers to.
01:09:47 <theorbtwo> fasta: Perl.
01:13:35 <ski> (fasta : fyi, we were talking (amongst other things) of reflection and reification (in the Filinski sense of "Reflecting Monads", more or less) to go between arrays and lists ("contents of arrays"))
01:18:22 <fizruk> is it true??? http://arxiv.org/abs/1004.3702
01:18:39 <roconnor> fizruk: no
01:20:08 <fizruk> sure?
01:21:53 * roconnor ponders what odds he would take
01:22:35 <roconnor> fizruk: I'll bet $70 at 99:1 odds
01:23:38 * roconnor needs the 70 cents
01:24:12 <fizruk> roconnor: i dont know what to think of that... maybe it's worth to read?
01:24:22 <roconnor> nope
01:24:31 <roconnor> fizruk: do you have an account at arxiv?
01:24:34 <dolio> Did you look at it?
01:24:47 <fizruk> no
01:25:02 <dolio> I am. You should look at it.
01:25:12 <roconnor> fizruk: then I'll mention a tidbit of information that you don't have.  The author's email address ends in @yahoo.com
01:25:17 <dolio> Then you won't bet roconnor.
01:25:56 <roconnor> dolio: what do you mean?
01:27:20 <deteego> hey I was given an example yesterday with
01:27:22 <deteego> data Mapping a b = Mapping (a â†’ a)
01:27:27 <dolio> I'm pretty sure after he sees that it's 4 pages, and only has an English description of the algorithm and proof, and says things like "we only need to consider 12 nodes at a time" for non-convincing reasons, he'll keep is 70 cents.
01:27:41 <deteego> in storing functions in data types, how do I then use a datatype from that function
01:27:54 <deteego> I mean how do I use that function from the datatype
01:28:02 <fizruk> roconnor: @yahoo.com says me that the news is fake?
01:28:47 <roconnor> fizruk: hey, interpret it however you like. I'm just trying to level the information between us.
01:28:55 <theorbtwo> fizruk: People who care about their online presence tend not to use free webmail addresses publicly, I think.
01:29:14 <Jonno_FTW> is hoogle broken at the moment?
01:29:34 <Jonno_FTW> s/hoogle/ hackage documentation/
01:29:36 <roconnor> dolio: 12 eh?
01:29:40 <theorbtwo> Either they'll get a vanity domain, or use an acidemic domain name.
01:29:58 <fizruk> theorbtwo: maybe he just does not care about this )
01:30:26 <deteego> anyone?
01:30:33 <theorbtwo> The first, especially, doesn't imply they aren't hosting with a free web mail service, of course.  I do.  But my public address is james@mastros.biz.  theorbtwo@gmail.com is just an implementation detail.
01:31:11 <theorbtwo> fizruk: People who don't care about their web presence are more likely to say stupid things in public online then people who do care.
01:31:30 <dolio> roconnor: Yeah, because every graph can be partitioned into subgraphs of 12 or less nodes. Or something.
01:32:20 <dolio> It also says "(or 11, or 10 ...)" at some point, but 12 is the number the author chose for some reason, I guess.
01:32:33 <roconnor> oh the email address is in the paper.
01:32:35 <roconnor> pfffft
01:32:43 <theorbtwo> Doesn't mean everything they say is worthless, of course.  It's just an additional indicator.
01:32:47 <roconnor> I guess harvesters are too lazy to harvest pdfs
01:33:03 <theorbtwo> roconnor: Or he doesn't mind being harvested.
01:33:34 <theorbtwo> I refuse to live in fear of saying my address out loud.  I have decent spam filters.
01:34:20 <wunki> is it normal that what I do a cabal --reinstall of a package, all it's dependencies also get reinstalled?
01:34:35 <paulvisschers> Is it possible to change a function of type IO a -> IO b to MonadIO m => m a -> m b?
01:34:57 <dolio> No.
01:35:25 <theorbtwo> There is no function (IO a -> IO b) -> (MonadIO m => m a  -> m b?
01:35:57 <dolio> MonadIO only lets you lift results, not lower arguments.
01:35:59 <ski> deteego : i'm not sure what you mean, "I use that function from the datatype" ?
01:36:13 <theorbtwo> OTOH, if you have the source of the function handy, try changing the type declation.
01:36:31 <paulvisschers> I thought so, that really hampers the generality of my library
01:36:32 <ski> paulvisschers : this is the "monad tunneling problem"
01:36:55 <deteego> ski: http://pastebin.com/4BaZRVGG
01:36:59 <dolio> There was some discussion on the libraries list about what would be an appropriate counterpart.
01:37:08 <deteego> obviously the line test2 doesn't work
01:37:36 <dolio> I see two proposals.
01:38:19 <dolio> morphIO :: C m => (forall b. (m a -> IO b) -> IO b) -> m a
01:38:48 <dolio> Or: joinIO :: C m => IO (m a) -> m a ; partIO :: C m => m a -> IO (m a)
01:41:07 <ski> hm, you can't do `partIO' when `m' is `StateT s IO', e.g.
01:41:17 <deteego> ski: how exactly would I use the testFunc straight from foobar
01:41:51 <ski> well, define a function
01:42:03 <ski>   applyMapping :: Mapping a b -> (a -> b)
01:42:13 <deteego> so I have to define another function in order to use that?
01:42:13 <ski>   applyMapping (Mapping f) = f
01:42:16 <ski> but !
01:42:22 <ski> you get this for free if you say
01:42:27 <ski>   #
01:42:38 <ski>   data Mapping a b = Mapping {applyMapping :: a -> a}
01:42:49 <ski> hm, probably you want s/a -> a/a -> b/, there
01:43:02 <ski> then instead of saying
01:43:17 <ski>   test2 = foobar "roar"
01:43:20 <ski> you say
01:43:21 <deteego> ah I see, with records it makes a first class function
01:43:24 <ski>   test2 = applyMapping foobar "roar"
01:43:25 <ski> or
01:43:33 <ski>   test2 = foobar `applyMapping` "roar"
01:44:05 <deteego> ok thanks
01:44:13 <deteego> thats a nice use of records
01:44:20 <theorbtwo> http://www.haskell.org/pipermail/haskell-cafe/2007-July/028501.html is fascinating.
01:44:50 <ski> (note that `applyMapping' can both be seen as a "unary" function, extracting the function part of a `Mapping a b', *or* as a "binary" function that applies the function part of a `Mapping aa b' to an `a')
01:44:53 <deteego> ski: thanks heaps
01:44:57 <ski> yw
01:45:08 <SubStack> @src concat
01:45:08 <lambdabot> concat = foldr (++) []
01:45:14 <SubStack> o_O
01:45:16 <ski> (hrm .. "both .. or .." :)
01:45:19 <paulvisschers> theorbtwo: Yeah it is, I read that a year or so ago
01:45:44 <SubStack> @src (++)
01:45:44 <lambdabot> []     ++ ys = ys
01:45:44 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
01:45:44 <lambdabot> -- OR
01:45:44 <lambdabot> xs ++ ys = foldr (:) ys xs
01:45:54 <paulvisschers> theorbtwo: But since you need a new type class, it's not really a solution
01:46:16 <ski>   concat = foldr (flip (foldr (:))) []  -- ergo
01:46:49 <theorbtwo> Shrug.  It is if you can get the monads you are actually intersted in to be members of that class.
01:48:34 <ski> *nod*
01:48:53 <ski> the question is really whether it'd be a general *enough* solution
01:49:37 <paulvisschers> theorbtwo: yes if you use IO callbacks in your own MonadIO thingy, then it's useful. I want to make a library that provides a monad transformer on top of a MonadIO monad
01:51:28 <ski> dolio : hm, do you have any link to those two proposals ?
01:51:42 <ski> (Guest53331 : .. why ?)
01:52:37 <paulvisschers> I'm making a library that provides optimistic locking on databases, which database libraries should I support?
01:53:04 <HugoDaniel> i so much love it when ghc breaks loose: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25006#a25006 :( :( :( :(
01:53:14 <Botje> GHC SMASH!
01:53:35 <dolio> ski: http://www.haskell.org//pipermail/libraries/2010-April/013497.html
01:53:38 <HugoDaniel> it happens to me with quite the right frequency (whenever i really need to get things done fast)
01:54:20 <dolio> ski: http://www.haskell.org//pipermail/libraries/2010-April/013525.html
01:54:36 <ski> @type let foo :: (forall b. ((s -> IO (a,s)) -> IO b) -> IO b) -> (s -> IO (a,s)); foo m s = m (\k -> k s) in foo
01:54:37 <lambdabot> forall s a. (forall b. ((s -> IO (a, s)) -> IO b) -> IO b) -> s -> IO (a, s)
01:54:42 <ski> dolio : ty
01:55:10 <ski> (that shows `morphIO' above (better name, anyone ?), works when `m' is `StateT s IO')
01:56:00 <dolio> There's a big list of morphIO implementations somewhere in there.
01:56:18 <ski> @type let foo :: (forall b. (StateT s IO a -> IO b) -> IO b) -> StateT s IO a; foo m = StateT (\s -> m (\k -> k `runStateT` s)) in foo  -- prettier
01:56:19 <lambdabot> forall s a. (forall b. (StateT s IO a -> IO b) -> IO b) -> StateT s IO a
01:56:27 <quicksilver> yitz-- # "only a toy"
01:56:29 <dolio> Actually, a generalized proposal was for MonadTrans t => (forall b. (t m a -> m b) -> m b) -> t m a
01:56:40 <dolio> Or a new class.
01:56:47 <dolio> But you can implement lift with that, apparently.
01:58:54 * ski doesn't see it
01:59:31 <paulvisschers> dolio: This reminds me of some stuff I played with in February: http://pastebin.com/uLdhxHWF
01:59:42 <ski> (also, this is probably some kind of Kan extension)
02:00:06 <quicksilver> ski: everything is some kind of Kan extension :P
02:00:51 <ski> quicksilver : yes, the question is just how :)
02:01:05 <paulvisschers> dolio: It's a bit of a mess, but you see the idea I hope (almost free instances for the simple monad transformers)
02:02:04 <ski> paulvisschers : somewhat related, i'm been toying a little with `class MonadFunctor t where tmap :: (Monad m,Monad n) -> (forall x. m x -> n x) -> (t m x -> t n x)'
02:02:31 <ski> (er replace the initial `->' with `=>')
02:03:12 <paulvisschers> ski: That could be interesting as well
02:03:22 <paulvisschers> ski: Any concrete applications?
02:03:53 <ski> you can also consider `tjoin :: Monad m => t (t m) a -> t m a' as well as `tbind :: (Monad m,Monad n) => t m a -> (forall x. m x -> t n x) -> t n a'
02:04:01 <dolio> ski: Well, the proposed definition is lift m = morph (\k -> m >>= k . return), but that gets complaints that Monad m doesn't imply Monad (t m).
02:04:09 <ski> (and `treturn' is just `lift :: Monad m => m a -> t m a' ..)
02:04:14 <dolio> So I'm not sure what was going on on the mailing list.
02:05:24 <Arnar> heh... "If u cn rd ths, u cn gt a jb in fncnl prg (if thr wr any)." -Peter Norvig
02:05:25 <ski> paulvisschers : not directly concrete, just based on that in `t m a', you should not only be able to change the `a' (with `fmap'/`liftM') into any `b', but also change the *`m'* part into any (monad) `n'
02:05:35 <dolio> Of course, that will be the case by convention, but that isn't available to the type system.
02:05:42 <ski> Arnar : i can't read that, .. too ambiguous
02:06:21 <Arnar> ski: just make it type [Sentence], then ambiguity is no problem
02:06:28 <paulvisschers> ski: Could you also make a MonadApplicative and MonadMonad?
02:06:43 <ski> paulvisschers : probably .. the question is how useful they would be
02:07:00 <ski> paulvisschers : i do recall someone who actually wanted `FunctorFunctor', though
02:07:38 <paulvisschers> ski: We're functional programmers, we don't let some pesky thing like lack of utility stop us :)
02:08:47 <paulvisschers> btw, what happened to the weekly news, I haven't gotten one since 8 march
02:09:29 <dolio> You mean the whenever news?
02:09:53 <paulvisschers> dolio: yes :P
02:10:36 <paulvisschers> dolio: But it did seem to be somewhat weekly before
02:10:43 <ski> dolio : hm, but `(MonadTrans t,Monad m)' doesn't give you `Monad (t m)' currently, does it ?
02:11:14 <ski> (or maybe the argument is that it ought to, in a sensible definition of `MonadTrans')
02:11:36 <dolio> Yes. There was a period before that though (before the new author took over) where it had similarly stopped being weekly.
02:11:44 <dolio> And prior to that it was relatively weekly.
02:12:10 <dolio> ski: There's no good way to do it with type classes at least.
02:13:08 <ski> paulvisschers : iirc, that someone had defined something like `data Foo ref a = ...' where `ref' was typically instantiated to things like `Identity',`IORef',`MVar',&c., and wanted an `fmap'-like operation on `Foo' that allowed changing the underlying `ref' used
02:13:42 <ski> dolio : i was just speaking conceptually, here, not whether the current type class system will allow it
02:13:46 <dolio> Even if you could declare a (Monad m, MonadTrans t) => Monad (t m) instance sensibly, I don't think there's enough in Trans to let you define the operations.
02:14:03 <ski> right, i don't see how one could make `(>>=)'
02:14:10 <paulvisschers> ski: That actually sounds pretty nice
02:14:13 <dolio> If you have lift, you can get return, but not bind.
02:14:19 <ski> (right)
02:14:31 <ski> .. so, where people complaining that `morphIO' didn't suffice, either ?
02:14:32 <paulvisschers> ski: And I actually have a similar data type in what I'm working on now, but that just hardcoded IORefs
02:14:36 <dolio> Maybe morph is better, but we're trying define lift with morph, and that requires return, which requires lift.
02:14:51 <ski> oh, hum .. a cycle
02:17:18 <ski>   morph . runCont :: Foo m => (forall o. ContT m (t m) a) -> t m a
02:18:00 <ski> this looks, sortof, like a double-negation elimination rule
02:19:00 <ski> (hm, s/ContT m/ContT (m o)/,s/runCont/runContT/)
02:19:22 <ski> do we have the converse ?
02:19:47 * ski doubts the above is correct
02:21:02 <ski>   morph . runContT :: Foo m => (forall o. ContT o m (t m a)) -> t m a  -- rather
02:21:50 <ski> so, given `t m a' and `t m a -> m o', can we construct `m o' ? ..
02:21:53 <ski> .. yes, obviously
02:22:37 <dolio> The converse is just return for the codensity transformer, or whatever you want to call it.
02:22:42 <ski> so, do we expect an isomorphism here .. ore only a retract situation ?
02:25:16 <ski> well, at least we want `(morph . runContT) . (\tma -> ContT (\k -> k tma))  =  id', i think
02:26:03 <ski> ("doing nothing" in the codensity transformer, then merging back, should be the identity on `t m a')
02:27:36 <ski> if we had just `forall o. (t m a -> o) -> o', then i'd say the converse should hold, as well, since the former can't do any continuation effects
02:28:07 <ski> s/the converse should hold/the converse composition should be identity/
02:28:10 <sepp2k> @src []
02:28:10 <lambdabot> data [] a = [] | a : [a]
02:33:10 <ski> > (`asTypeOf` []) . (`runContT` return) $ do x <- ContT (\k -> k 0 ++ k 1); y <- ContT (\k -> k 2 ++ k (3 + x)); return (x,y)
02:33:11 <lambdabot>   [(0,2),(0,3),(1,2),(1,4)]
02:34:00 <ski> > (`asTypeOf` []) . (`runContT` return) $ do x <- ContT (\k -> k 0 ++ k 1); y <- ContT (\k -> k 2) `mplus` ContT (\k -> k (3 + x)); return (x,y)
02:34:01 <lambdabot>   No instance for (Control.Monad.MonadPlus
02:34:01 <lambdabot>                     (Control.Monad...
02:34:14 <ski> ho hum ..
02:35:08 <HugoDaniel> my favourite command: ghc-pkg list | xargs -n1 sudo ghc-pkg --force unregister
02:35:09 <HugoDaniel> :(
02:35:50 * ski wonders whether there's a particular reason why there's no `instance MonadPlus m => MonadPlus (ContT o m)' ..
02:41:01 <ski> > (`asTypeOf` []) . (`runContT` return) $ do (x,y) <- callCC $ \c -> do {x <- ContT (\k -> k 0 ++ k 1); when (x > 0) (c (x,10)); y <- ContT (\k -> k 2 ++ k (3 + x)); return (x,y)}; z <- ContT (\k -> k (4 + x) ++ k (5 + y)); return (x,y,z)
02:41:02 <lambdabot>   [(0,2,4),(0,2,7),(0,3,4),(0,3,8),(1,10,5),(1,10,15)]
02:41:42 <ski> > (`asTypeOf` []) . (`runContT` return) $ do x <- ContT (\k -> k 0 ++ k 1); y <- ContT (\k -> k 2 ++ k (3 + x)); z <- ContT (\k -> k (4 + x) ++ k (5 + y)); return (x,y,z)
02:41:43 <lambdabot>   [(0,2,4),(0,2,7),(0,3,4),(0,3,8),(1,2,5),(1,2,7),(1,4,5),(1,4,9)]
02:42:51 <ski> > (`asTypeOf` []) $ do x <- [0,1]; y <- [2,3 + x]; z <- [4 + x,5 + y]; return (x,y,z)
02:42:52 <lambdabot>   [(0,2,4),(0,2,7),(0,3,4),(0,3,8),(1,2,5),(1,2,7),(1,4,5),(1,4,9)]
02:43:40 <ski> hm .. though i suppose this doesn't really answer the question anyway
02:45:13 <Arnar> my cabal system is broken.. once again :(
02:45:22 <Arnar> after upgrading to 6.12
02:45:43 <ski> (.. since the answer type wasn't polymorphic, i.e. ..)
02:46:53 <Arnar> i'm having the same problem as this guy: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17141
02:47:14 <Arnar> when getting cabal to upgrade itself (via an older ghc-6.10.4)
02:47:27 <Arnar> any ideas?
02:47:46 <fasta> Arnar, it probably means the old-time dependency is not listed.
02:48:03 <ski> @type do (x,y) <- callCC $ \c -> do {x <- ContT (\k -> k 0 ++ k 1); when (x > 0) (c (x,10)); y <- ContT (\k -> k 2 ++ k (3 + x)); return (x,y)}; z <- ContT (\k -> k (4 + x) ++ k (5 + y)); return (x,y,z)
02:48:04 <lambdabot> forall a (m :: * -> *) r. (Monad m, Num a, Monoid (m r), Ord a) => ContT r m (a, a, a)
02:48:23 <fasta> Arnar, anyway, the correct response is to bug the author if it doesn't work.
02:48:25 <Arnar> fasta: ok.. will try installing old-time..
02:48:39 <fasta> Arnar, I don't really think that will do it.
02:48:46 <Arnar> fasta: ok
02:48:57 <fasta> Arnar, you have to list it as a dependency, which is different from just installing it, AFAIK.
02:48:58 <ski> (oh, actually it *is* polymorphic in `r' (once you instantiate `m' to `[]', and then simplify `Monoid (m r)' to the true constraint)
02:49:22 <Arnar> fasta: bug the author of cabal-install you mean?
02:49:26 <fasta> Arnar, and again, by not reporting this issue, you just make sure that someone else will have the same problem in the near future.
02:49:43 <fasta> Arnar, look at what the author "promises" that should work.
02:49:52 <fasta> Arnar, if that doesn't work, bug the author.
02:49:59 <Arnar> yup
02:50:01 <Arnar> thanks
02:50:23 <ski> (blame tracking ftw ! :)
02:50:27 <fasta> Arnar, an alternative is to make a package named ArnarVersionOfFooThatActuallyWorks.
02:50:49 <fasta> Arnar, that last is, IMHO, the most optimal solution, since people lag.
02:56:54 <ski> .. so, i would guess since `forall o. ContT o m a' can do more (not just more efficiently) than `a', possibly `forall o. ContT o m (t m a)' is also more powerful than `t m a' (included into the former via codensity `return') ?
02:57:34 <amosrobini> hi. I'm having trouble with cabal: I have a bunch of packages that are broken due to recursive dependencies. I try to reinstall the broken packages, and it seems to work, but then every one in five packages will break a bunch again... I'm toying with deleting my ~/.ghc/package.conf and starting from scratch,.. is this a bad idea?
02:58:09 <ski> hm, but maybe `(forall o. ContT o m (t m a)) -> t m a' really boils down to `m (t m a) -> t m a' (modulo efficiency), then ?
02:58:46 <ski> (i.e. the `joinIO' mentioned above)
02:59:32 <augur> haskelliers, i come to you with a question
03:00:21 <Jafet> I thought we were haskelleurs
03:00:33 <ski> haskellites ?
03:00:55 <amosrobini> haskellerasts?
03:00:56 <augur> perhaps, but haskelleurs and haskellites dont evoke images of stephen king's langoliers
03:06:51 --- mode: bartol.freenode.net set +o ChanServ
03:06:51 <augur> infact, i think thats the only inducible ordering you can have
03:14:43 <ski> augur : i'm not sure what you mean by "the concatenations occur 0-a-b-c""
03:15:26 <augur> well, lets say just a-b-c. if you start with the string "a", and then concatenate the string "b", either on the left or right, and then onto that you concatenate "c" either left or right
03:15:26 <ski> augur : i thought you were talking about constructing the subset order on the particular subset, from the general concatenation order
03:15:30 <augur> you get the four sentences
03:16:03 <augur> so you construct the sentences by concatenation of the elements "a", "b", and "c", in that order
03:16:04 <ski> (i.e. `forall as0 as1.  as0 =< as1  <=>  exists as2 as3. as2 ++ as0 ++ as3 = as1')
03:16:57 <mxc> anyone ever get a linker issue when building happstack-data?
03:16:57 <mxc> unknown symbol `_sybzmwithzmclasszm0zi6zi1_DataziGenericsziSYBziWithClassziInstances_dataTypeZMad6eZN_closure'
03:16:58 <mxc> i tried cabal install syb-with-class --reinstall
03:16:58 <mxc> didn't wokr :(
03:17:16 <Zao> What command do you build happstack-data with?
03:17:27 <ski> augur : hm, you want to break down the lists into the set of largest fragments that is sufficient for generating your original set of lists ?
03:17:51 <augur> eh, not really.
03:18:10 <augur> the relevant set of sentences is just a set of concatenations, right
03:18:26 <mxc> cabal install happstack
03:18:30 <ski> what is "a set of concatenations" ?
03:18:40 <ski> a set closed under concatenation ?
03:19:06 <augur> if your alphabet is {a,b,c}, the set {abc,bac,cab,cba} is a set of concatenations of the alphabet
03:19:26 <ski> why is `acb' not in there ?
03:19:30 <mxc> zao: fyi, the internal error: strange closure you helped me with in #ghc the other day - it was because of unsafeFreeze on IOArray
03:19:42 <augur> ski: good point, and that leads to the second issue
03:20:27 <mxc> apparently, unsafeFreeze on an IOArray is much more dangerous than on an IOArray
03:20:28 <ski> hm, maybe by "a set of concatenations" you just mean a (finite ?) subset of the set of (finite) lists over the alphabet ..
03:20:32 <augur> the set there is generable by the regular grammar S -> C; C -> cB | Bc; B -> bA | Ab; A -> a
03:20:39 <mxc> ^ than on an IOUArray (unboxed is safer)
03:20:39 <augur> well it could be infinite, so
03:21:01 <augur> i'm just using a finite example because we dont have infinite space or time to enumerate the members of the infinite varieties ;)
03:21:43 <augur> so you see this grammar as generating hierarchical concatenations of the symbols a, b, and c
03:21:52 <augur> a concatenates first with b, in whatever order
03:21:54 <ski> you could still enumerate them (assuming the alphabet is enumerable), it just won't terminate
03:22:00 <augur> and the result concatenates with c in whatever order
03:22:38 <augur> hence why you dont get acb: a must first concatenate with b, and theres no way to concatenate with b first but end up with c closer to a
03:22:57 <ski> hm, so you have an ordering on `{a,b,c}', as well ?
03:23:17 <augur> not inherently. its just an ordering that emerges from the grammar
03:23:34 <augur> theres a hierarchy, essentially
03:23:44 <ski> yes, but in "<augur> if your alphabet is {a,b,c}, ...", there was no mention of a grammar :)
03:23:52 <augur> im just using the grammar as an example
03:24:08 <augur> the point is to induce either the grammar, or at minimum, the hierarchy
03:24:27 <ski> what is the "hierarchy" ?
03:24:31 <ski> a partial order ?
03:24:51 <augur> no, in terms of the grammar its just the hierarchical structure of the tree
03:25:09 <ski> which tree ? (sorry if i'm being dense)
03:25:18 <augur> the parse tree for any of the relevant sentences
03:25:25 <augur> if were viewing this grammar-wise
03:25:52 <augur> given the grammar above, "abc" has the parse tree [S [C [B [A a] b] c]]
03:25:59 <ski> hm, do you always allow concatenating on either side ?
03:26:07 <augur> yes
03:26:30 <augur> alternatively you can view it as a distance thing, right
03:26:31 <ski> and do you always concatenate with a single element, or can you concatenate any two (already generated) phrases ?
03:26:49 <augur> the unsigned distance from b to a is always less than or equal to the unsigned distance from c to a
03:27:09 <augur> assume concatenation is always complex + symbol
03:27:46 <augur> to give you a slightly more concrete explanation
03:28:23 <augur> i have a set of "sentences" that are composed of at most one occurrance of symbols in the vocabulary
03:28:55 <ski> how about the grammar `S -> C; C -> c B0 | B0 c | c A0 | A0 c; B0 -> b A1 | A1 b; A0 -> a B1 | B1 a; A1 -> a; B1 -> b' ?
03:29:06 <augur> and what i want to determine is whether or not the sentences are just W* or something of this sort
03:29:30 <augur> er
03:30:06 <ski> (you can change into `S -> D' and add `D -> d C | C d', if you prefer)
03:30:09 <augur> that might work, i have no idea. i dont know if the example sentences are characterizable strictly by a single grammar like this
03:30:18 <augur> i dont know.
03:30:28 <augur> nor does it matter; if there are multiple such grammars, i'd like to now that
03:30:45 <augur> its just more about inducing a grammar of this sort
03:30:59 <augur> or, alternatively, inducing a hierarchy
03:31:16 <ski> what's `W' above ? (assuming `*' is the Kleene star)
03:31:21 <augur> W is the words
03:31:26 <augur> so W = {a,b,c} in my sentences
03:31:39 <ski> the alphabet ?
03:31:50 <augur> sure.
03:32:07 <augur> i come form a linguistics background so grammars for me are words/sentences, not alphabet/words
03:32:07 <augur> ;)
03:32:20 * ski has seen finite *lists* with elements from the alphabet called "words", before ..
03:32:26 <ski> ok
03:33:44 <ski> hm, unless `W' is empty, `W*' is infinite, so then you probably can't decide whether a subset of it is the full subset
03:34:12 <augur> right
03:34:28 <ski> .. so maybe you meant something else ?
03:34:37 <augur> but suppose that we have the constraint that the number of occurances of any w is at most 1
03:34:43 <augur> and potentially 0
03:35:04 <ski> so you have a set of singletons, and maybe the empty word ?
03:35:16 <augur> doesnt have to be, ofcourse, if we had cyclic rules, but
03:35:42 <ski> .. oh "the number of occurances of any w"
03:36:32 <ski> i thought you were saying that the number of occurances of words in a phase is at most 1 (regardless of which words are in there)
03:36:55 <augur> yeah so like
03:37:11 <augur> if theres an "a" in the sentence, theres exactly one a
03:37:53 <ski> (hm .. so your words are affine resources)
03:38:00 <augur> sure.
03:38:05 <augur> again, you could make it infinite
03:38:08 <augur> so consider the grammar
03:38:48 <ski> so, the maximum set you're considering is the set of all permutations of the alphabet (represented as lists of words)
03:38:53 <augur> S -> C; C -> cB | Bc; B -> bA | Ab; A -> a | aC | Ca
03:39:26 <augur> in which case you again sort of have the same hierarchy, modulo the cyclicity of it
03:39:28 <ski> and then you get possible repetition
03:39:33 <augur> right
03:39:38 <augur> but you still have the hierarchy
03:40:08 <ski> hm, yes instead of a list `[a,b,c]', you get a *cycle*
03:40:20 <augur> but its a hierarchical cycle, crucially
03:40:24 <augur> its not a linear cycle
03:40:25 * ski wonders whether this is related to species
03:40:33 <ski> *nod*
03:40:39 <augur> in my case its related to verbal morphology :)
03:40:47 <ski> a rational treem
03:41:04 <ski> s/m//
03:41:37 <ski> (possibly byorgey or Cale could answer that ..)
03:42:27 <augur> hmm. i have what looks like potentially an algorithm. but i dont know how well it works
03:43:16 <ski> i'm still not sure whether you're considering my example of a grammar (a bit above)
03:43:24 <augur> if you know what the initial word is (e.g. suppose "a" is the initial word) and you know that it's always in the sentences
03:43:35 <ski> (i.e. whether that is a possible grammar to consider, in your domain)
03:43:39 <augur> then you can count up the distances from it that the other elements have, linearly
03:43:47 <IceDane> How bad is it to construct a partial algebraic data type? As in, if I'm parsing a file and one function grabs a part of the header, and returns it in one field of a custom data type, without putting anything in the others?
03:43:52 <augur> (assuming a finite set of sentences with single appearance)
03:44:31 <ski> i.e. must your grammars be "linear" like above, or could you "start" with possibly different elements in the leaves, and adjoin to it to get longer phrases ?
03:44:34 <augur> and whichever one always appears with the same distance, when it appears, is the "next" out
03:45:01 <augur> well, im assuming that there is a designated innermost/initial element
03:45:15 <augur> that is always present in all the sentences
03:45:19 <ski> one initial element for each phrase ?
03:45:31 <augur> thats actually a fact about the data, more so than the principle of the thing, but who knows
03:45:33 <ski> or one element, which is initial for each phrase ?
03:45:39 <ski> (in a particular grammar)
03:46:25 <augur> \exists e : e is an element [\forall s : s is a sentence [e is initial in s]]
03:46:36 <ski> IceDane : well, if you don't mind getting strange errors about undefined fields in unrelated parts of the program .. :)
03:46:53 <ski> augur : ok, the latter, then :)
03:46:58 <augur> :)
03:47:04 <augur> hooray unambiguous logic
03:48:13 <augur> hmm yes
03:48:16 <amosrobini> whoa! my numpad doesn't work in xmonad!
03:48:16 <augur> i think i have the algorithm
03:48:17 <IceDane> ski: Yeah, throws an exception if I try to show it without it being initialized fully
03:48:19 <ski> IceDane : if you know you'll not look at the undefined parts until after you've filled them in, then that's ok, imo
03:48:24 <augur> i think its universally applicable too
03:48:26 <IceDane> Yeah
03:48:27 <IceDane> hmm
03:48:43 <fasta> IceDane, for the costs that undefined gives you, you can just as well use Maybe values.
03:48:45 <amosrobini> oh. ha. I have mouse keyboard magic turned on..
03:49:06 <augur> ski: let w be the non-initial words, let s be the sentences
03:49:28 <fasta> IceDane, because essentially what you want to express is data KnownAlready a = Yes a | No
03:49:30 <ski> IceDane : if you don't want to / can't fill them in, but don't think you really need to *use* the extra fields .. then maybe it's ok, or maybe you should make a new datatype (or look for an alternative, at the least)
03:49:32 <augur> er, ws and ss :P
03:49:47 <IceDane> It's just a nifty way to do the state thing.. I'm trying to write this stuff without using the state monad, then seeing how I can benefit from using it afterwards
03:49:55 <IceDane> I think the Maybe is a good idea, thanks
03:50:19 <augur> map (\w -> (w, max (distances w init ss)) ws
03:50:26 <ski> (IceDane : not filling in things *you* don't use can be bad, if you pass the record to code that possibly *do* expect that all things are filled in .. such as `show', e.g.)
03:50:39 <augur> i think that'll work, ski.
03:50:45 <IceDane> yeah, I figured as much
03:50:52 <augur> for each word, map it to its maximum distance form the initial element
03:51:02 <ski> (amosrobini : what is this mouse magic you speak of ?)
03:51:46 <ski> fasta : that doesn't work for a fixed datatype, with non-polymorphic fields, though ..
03:51:50 <augur> no that doesnt guarantee it tho
03:53:06 <amosrobini> ski: oh, I'm using gnome+xmonad, and gnome has this setting where you can control the mousepointer, click etc, with the numpad
03:54:13 <ski> augur : btw, possibly this doesn't really matter, but i'm instinctively wanting to change your `A -> a' into `A -> a E | E a; E -> eps' ;)
03:54:39 <fasta> ski, AFAIK, his problem is that he is sending Foo undefined undefined something_defined to some function somewhere else currently and wants to have something cleaner, but maybe I missed something.
03:54:40 <augur> yeah thats why i had 0 in my initial one ;)
03:54:56 <ski> (i suppose that would give ambiguity of whether to adjoin the initial element to the left or to the right of the empty phrase, though ..)
03:55:11 <augur> yeah
03:55:36 <augur> but since the initial element is always there and is non-empty, its better to just leave the empty string out of it
03:56:10 <ski> fasta : my guess was that s/he didn't have control over the `Foo' datatype, so either needed to work with it, as-is, or make a new datatype
03:56:36 <ski> (and maybe the last option would mean that some code would have to be reimplemented )
03:58:08 <amosrobini> yay! so I just deleted my ~/.ghc/x86/package.conf/... , reinstalled stuff with cabal, and things seem to work now
03:58:37 <ski> (ty for being quiet for awhile, so that i could catch up ;)
03:59:14 <ski> augur : "for each word, map it to its maximum distance form the initial element" <- this explains better to me what your question actually is :)
03:59:32 <ski> you want to reconstruct a grammar, from a set of words, aiui
03:59:50 <augur> it doesnt actually work tho
04:00:00 <augur> i _sort of_ want to reconstruct a grammar
04:00:14 <augur> what i care about is the hierarchy, ultimately. thats the single most important factor
04:00:32 <ski> isn't it isomorphic to the grammar, for your class of grammars ?
04:00:46 <ski> hm
04:00:56 <augur> sure, but the problem might be easier when computed in a non-grammar-theoretic way
04:01:19 <ski> sure, just trying to get a grip on what the problem to solve *is* :)
04:06:26 <roconnor> woah, the system() function in Glibc executes /bin/sh
04:06:29 <roconnor> crazy
04:07:19 <augur> ok i think i have a partial algorithm
04:08:07 <augur> it'd be nice if regex's had an order shuffle operator
04:08:32 <LoRe> roconnor: what should it execute instead?
04:08:52 <roconnor> I'm not sure
04:10:06 <roconnor> LoRe: I would have expected you to only be able to execute executables
04:12:36 <Botje> roconnor: then you want the exec* family of functions
04:12:47 <roconnor> Botje: sure
04:12:57 <roconnor> I'm just surprised that system exists as such
04:13:03 <LoRe> roconnor: it does exactly what the standard tells it to do: http://korn.shell.la/Doc/susv3/functions/system.html :)
04:13:22 <Botje> it was an attempt to add more whipuptitude to C, I guess :)
04:13:59 <roconnor> LoRe: that standard, to me, assumes way too much about how operating sytems must work
04:14:28 <roconnor> BTW, I really hate this "if it's documented it is okay" style of argument.
04:15:34 <roconnor> oh wait
04:15:42 <roconnor> hmm, is glibc not the same as libc?
04:15:50 <Botje> glibc = gnu libc
04:15:55 <theorbtwo> glibc is an implementation of libc.
04:15:56 <Botje> there is presumably also a bsd libc
04:16:14 <Botje> and a ulibc, come to think of it
04:16:22 <theorbtwo> Confusingly, there is also a glib, which is something completely different.
04:16:32 <Zao> Not to mention the assorted MS CRTs.
04:16:56 <roconnor> okay
04:17:11 <roconnor> system() is a little (not much) more reasonable for glibc
04:17:49 <roconnor> Still I'm surprised that I have to lay out my binaries in specific places for glibc functions to operate correctly
04:18:04 <roconnor> presumable glibc should be restricted to wraping up system calls.
04:19:32 <Botje> seriously?
04:20:34 <roconnor> Botje: seriously, but I'm pretty ignorate about this subject, so there is a good possibility I'm wrong.
04:20:41 <roconnor> ignorant
04:22:20 <roconnor> according to http://www.gnu.org/software/libc/:
04:22:26 <roconnor> Any Unix-like operating system needs a C library: the library which defines the ``system calls'' and other basic facilities such as open, malloc, printf, exit...
04:23:05 <roconnor> I don't really see how using system to call some random shell program that you have no idea what it does is very helpful
04:23:53 <Botje> the posix standard defines how /bin/sh should behave
04:23:53 <roconnor> or are there some minimal guarentees on what /bin/sh will do?
04:24:11 <Botje> so presumably glibc has some fine print somewhere that it requires posix conformance
04:25:10 <roconnor> does system() always call /bin/sh or is it distribution dependent?
04:26:56 <Zao> roconnor: As far as a C program cares, it's implementation dependent.
04:26:56 <ski> the man page says it will call `<shell path>/sh', "where <shell path> is an unspecified pathname for the sh utility."
04:27:11 <Zao> But should "be similiar to an interactive command line".
04:27:14 <Zao> Or suchlike.
04:27:14 <roconnor> ski: I read that too.  I'm not sure what it means
04:27:59 <Botje> note that system is in section 3 of the manual
04:28:05 <Botje> so it's not a part of the C spec
04:28:24 <Zao> http://codepad.org/t5Osci3l
04:28:24 <roconnor> so system() is specific to glibc?
04:28:31 <Zao> That's C99 on system().
04:28:34 <Botje> libc, i think.
04:28:40 <Zao> system is very much standard C.
04:29:00 <Botje> oh. heh
04:29:02 <Zao> The behaviour of it is very loosely specified as per that paste.
04:29:05 <Botje> CONFORMING TO C89, C99, POSIX.1-2001.
04:29:08 <roconnor> Zao: on neat, you can test to see if a shell exists or not.
04:29:08 <Botje> ignore me :\
04:29:13 <roconnor> oh
04:29:25 <roconnor> that's a good start
04:29:44 <Zao> roconnor: If a null pointer is passed, it returns non-zero if a command processor is present.
04:29:55 <Zao> Otherwise, the return value is implementation-defined.
04:30:22 <roconnor> so OS's aren't required to have a command shell
04:30:28 <roconnor> that makes me feel much better
04:32:04 <Zao> roconnor: You always have the whole free-standing vs. hosted distinction too.
04:32:14 <Zao> Where the slimmer one is allowed to omit just about anything.
04:35:36 <roconnor> free-standing vs hosted?
04:36:27 <ski> free-standing needn't run under an OS, needn't require `main' (with or without arguments) to start the program, &c.
04:37:28 <ski> iiuc, free-standing is mostly meant to write your own OS in, or programs that need to run when there's no OS around, or programs on embedded devices (which often doesn't have much in the way of OS)
04:39:43 <augur> ski: incase you're curious why im looking at this, theres this phenomena in linguistics in which verbs can be marked for different components of meaning by means of an affix of some sort
04:40:26 <augur> and theres question about whether or not the order of these affixes ever show up in any particular order, or are instead freely ordered
04:41:47 <ski> ah
04:42:11 <ski> what do these different components of meaning signify, e.g. ?
04:42:17 <augur> tense, for instance
04:42:22 <augur> work-ed
04:42:27 <augur> Verb-Tense
04:42:35 <roconnor> ok
04:43:37 <augur> i figure if i can find a sufficiently large corpus of glossed verbs, i can try to run this algo over them to see if they show any patterns
04:46:00 <augur> i think i found the appropriate algo tho, ski.
04:47:34 <ski> mhm ..
04:49:01 <augur> the algo is basically to consider the left and right sides of the initial element seperately
04:49:16 <augur> and to find all the orderings of symbols
04:49:57 <augur> form this we can ask what the assymmetric orderings are
04:50:16 <augur> e.g. which pairs of symbols always appear one closer to the initial symbol than the other
04:50:33 <augur> we can also ask which symbols symmetric, in that they appear in either order
04:52:43 <IceDane> :|
04:52:53 <IceDane> I just had the "ah" moment on the state monad
04:53:10 <byorgey> =D
04:53:27 <IceDane> My life is now complete.
04:53:27 <roconnor> IceDane: w00t
04:53:38 <roconnor> IceDane: now do the Cont monad
04:53:43 <IceDane> wat
04:53:44 <roconnor> then the J monad
04:54:23 <IceDane> I think the first thing I'll be doing is asking my family to take me back after these years of solitude trying to grok the state monad
04:54:27 <IceDane> it consumed me.
04:54:30 <roconnor> :)
04:54:46 <BONUS> do the Logic monad next!
04:54:47 <roconnor> @quote state.monad
04:54:48 <lambdabot> mmorrow: says: right, that's just beggin for a State monad.
04:54:51 <roconnor> @quote state.monad
04:54:51 <lambdabot> jmcarthur says: what good is a state monad if your state is basically "i have no idea what the hell my state is"?
04:55:04 <roconnor> @quote state.monad
04:55:04 <lambdabot> jmcarthur says: what good is a state monad if your state is basically "i have no idea what the hell my state is"?
04:55:05 <roconnor> :(
04:55:11 <fasta> roconnor, what is a J monad?
04:55:17 <IceDane> @uote state.monad
04:55:17 <lambdabot> Maybe you meant: quote vote
04:55:23 <IceDane> @quote state.monad
04:55:23 <lambdabot> mtnviewmark says: [on the State monad] "If I had a sta-ate, I'd compute it in the morning.... I'd compute it in the evening.... All over this la-and!"
04:55:32 <IceDane> lolwat.
04:55:32 <roconnor> newtype J r a = J {runJ : (a -> r) -> a}
04:55:46 <fasta> roconnor, ah, I already found some reddit post with it.
04:56:15 <roconnor> ah
04:56:19 <BONUS> is that even a functor?
04:56:19 <roconnor> @quote is.no.state
04:56:20 <lambdabot> MonadState says: Do not try to change the state; that's impossible. Instead only try to realize the truth: There is no state.
04:56:26 <BONUS> or is it a cofunctor or whathaveyou
04:56:44 <roconnor> BONUS: is is a monad
04:56:58 <roconnor> @djinn (a -> b) -> ((a -> r) -> a) -> (b -> r) -> b
04:56:58 <lambdabot> f a b c = a (b (\ d -> c (a d)))
04:57:08 <BONUS> hmm!
04:57:09 <roconnor> obviously a functor isn't it
04:57:11 <roconnor> :P
04:57:16 <BONUS> haha, yeah
04:57:36 <roconnor> @djinn ((a -> r) -> a) -> (a -> (b -> r) -> b) -> (b -> r) -> b
04:57:36 <ManateeLazyCat> I have write `#if ... #else ... #endif" in my .chs file, so how to make .cabal support it?
04:57:37 <lambdabot> f a b c = b (a (\ d -> c (b d c))) c
04:57:49 <roconnor> so easy!
04:58:23 <Spockz> what is that supposed to be?
04:58:40 <roconnor> Spockz: I haven't had the ah moment with the J monad yet
04:58:57 <yottis> 14:55 < lambdabot> MonadState says: Do not try to change the state; that's impossible. Instead only try to realize the truth: There is no state.
04:59:06 <fasta> roconnor, do you have a complete definition somewhere? The reddit.com post misses some parameters.
04:59:08 <yottis> i really like these anarchist quotes on #haskell ;)
04:59:20 <roconnor> yottis: anarchist?
04:59:31 <fasta> roconnor, it is a joke. He knows it is not about that.
04:59:53 <yottis> roconnor: don't limit yourself to some computational state :)
04:59:53 <roconnor> fasta: I think I just gave the complete definition
05:00:03 <roconnor> yottis: lol
05:00:10 <fasta> roconnor, that is just the type.
05:00:29 <roconnor> fasta: map is @djinn (a -> b) -> ((a -> r) -> a) -> (b -> r) -> b
05:00:34 <roconnor> fasta: bind is @djinn ((a -> r) -> a) -> (a -> (b -> r) -> b) -> (b -> r) -> b
05:00:37 <roconnor> and return is
05:00:45 <roconnor> @djinn a -> (a -> r) -> a
05:00:45 <lambdabot> f a _ = a
05:00:49 <fasta> roconnor, OK
05:00:57 <Adamant> yottis: now do you see the violence inherent in the sysadmin?
05:01:40 <BONUS> @djinn (a -> b) -> ((a -> r) -> a) -> (b -> r) -> b
05:01:40 <lambdabot> f a b c = a (b (\ d -> c (a d)))
05:01:40 <yottis> yes, i feel the pain
05:01:57 <fasta> roconnor, so, it seems that r is basically a dummy sink for results.
05:02:13 <roconnor> fasta: J bool is Escardo's search monad
05:03:33 <ManateeLazyCat> Hi all, have you know any temrinal emulator support model/view split design? (except term.el in Emacs), i haven't found any exist temrinal emulator support that, if not, i plan to use Cairo/Pango write one.
05:04:05 <ManateeLazyCat> model/view split mean you can use different window seen same terminal context.
05:04:23 <osfameron> like different viewports on it?
05:04:37 * ManateeLazyCat And don't suggestion "Screen", it's just work on console, i want temrinal emulator widget.
05:04:47 <ManateeLazyCat> osfameron: Yes, like TextBuffer and TextView in Gtk+
05:04:49 <fasta> roconnor, ah, that's quite elegant.
05:05:29 <osfameron> *does* screen offer that, even?
05:05:36 <ManateeLazyCat> osfameron: VTE widget is cool, but don't support mode/view split.
05:05:40 * osfameron doesn't understand even a fraction of screen's capabilities
05:05:49 <ivanm> ManateeLazyCat: there is one IIRC
05:05:54 <fasta> ManateeLazyCat, what is mode/view split?
05:05:56 <ivanm> it might be on suckless
05:06:15 <osfameron> ManateeLazyCat: out of interest, what's your use-case for viewports?  It sounds cool, but I can't actually think of a realistic case I'd want to use them...
05:06:24 <ManateeLazyCat> osfameron: I don't want screen, i want widget that can running in my framework.
05:06:38 <ManateeLazyCat> osfameron: Wait.
05:06:54 <ManateeLazyCat> osfameron: http://www.emacswiki.org/emacs/MultiTerm
05:07:12 <ManateeLazyCat> osfameron: Above is my temrinal extension for Emacs, support model/view split.
05:07:41 <ManateeLazyCat> osfameron: It's advantage is, you can use different viewport seen different part of same terminal.
05:07:54 <ManateeLazyCat> osfameron: Example, run man in it.
05:09:26 <ManateeLazyCat> osfameron: I have embedded in my framework, like this: http://farm3.static.flickr.com/2628/3952175905_9295a7421a_o.png , but it's different widget and not different viewport for same widget.
05:09:27 <ivanm> ManateeLazyCat: you want tiling within the terminal window?
05:09:33 <ivanm> or do you want to have something like Dr Scheme?
05:10:14 <ManateeLazyCat> ivanm: Well, it's a design problem.
05:10:31 <ManateeLazyCat> ivanm: VTE library haven't consider this when it start.
05:10:31 <ivanm> that... doesn't answer my question :p
05:11:17 * hackagebot base 4.2.0.1 - Basic libraries  http://hackage.haskell.org/package/base-4.2.0.1 (RossPaterson)
05:11:19 * hackagebot filepath 1.1.0.4 - Library for manipulating FilePaths in a cross platform way.  http://hackage.haskell.org/package/filepath-1.1.0.4 (RossPaterson)
05:11:21 * hackagebot hpc 0.5.0.5 - Code Coverage Library for Haskell  http://hackage.haskell.org/package/hpc-0.5.0.5 (RossPaterson)
05:11:23 * hackagebot old-time 1.0.0.4 - Time library  http://hackage.haskell.org/package/old-time-1.0.0.4 (RossPaterson)
05:11:30 <ManateeLazyCat> ivanm: Yes, i want split current terminal with many *tiling* (if you think so), and those *tiling* just different viepowrt of current terminal.
05:11:44 <ivanm> different viewports?
05:11:48 <ivanm> that doesn't make sense...
05:12:07 <osfameron> those don't seem to be viewports
05:12:07 <ManateeLazyCat> ivanm: No, it's efficient.
05:12:12 <osfameron> in that .png I mean
05:12:17 * hackagebot template-haskell 2.4.0.1 -   http://hackage.haskell.org/package/template-haskell-2.4.0.1 (RossPaterson)
05:12:19 <osfameron> they look like they'd be different processes
05:12:19 <ManateeLazyCat> ivanm: I use my multi-term.el in Emacs everyday.
05:12:20 <ivanm> osfameron: what png?
05:12:36 <osfameron> ivanm: the one ManateeLazyCat linked to above
05:12:43 <ivanm> ManateeLazyCat: you want the same bash/zsh/whatever session to have multiple "windows" using it?
05:12:49 <ivanm> osfameron: I didn't see any pngs there...
05:12:59 <ivanm> oh, wait, way down the bottom
05:13:05 <ManateeLazyCat> osfameron: Yes, because they're different widget in window, so they're in different process.
05:13:19 * hackagebot unix 2.4.0.1 - POSIX functionality  http://hackage.haskell.org/package/unix-2.4.0.1 (RossPaterson)
05:13:21 * hackagebot Win32 2.2.0.2 - A binding to part of the Win32 library  http://hackage.haskell.org/package/Win32-2.2.0.2 (RossPaterson)
05:13:23 <ivanm> ManateeLazyCat: is each one a different shell process?
05:13:56 <ivanm> if so, see terminator: http://www.tenshu.net/terminator/
05:13:56 <ManateeLazyCat> ivanm: You know TextBuffer and TextView in Gtk+?
05:14:01 <ivanm> there are a few others like it IIRC
05:14:02 <gal_bolle> @hoogle Either a b -> Maybe b
05:14:02 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
05:14:02 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
05:14:03 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
05:14:04 <ivanm> ManateeLazyCat: nope
05:14:08 <ivanm> ManateeLazyCat: I don't do GUIs
05:14:49 <ManateeLazyCat> ivanm: I have use terminator, but that's model/view design, it's just build new terminal widget (new shell process) when you do split action.
05:15:11 * ivanm still doesn't get what ManateeLazyCat 
05:15:30 <ManateeLazyCat> ivanm: Wait, i give you screenshot.
05:15:40 <ivanm> I saw the screenshot on emacswiki
05:15:55 <ivanm> so do you want one window with multiple different terminal instances inside it?
05:16:32 <IceDane> Is there not a function that works like fmap but whose type signature is something like: (a -> b) -> [m a] -> [m b] ?
05:16:33 <ManateeLazyCat> ivanm: No, you don't catch my point, wait my screenshot.
05:16:46 <ivanm> IceDane: fmap . fmap
05:16:48 <ivanm> @type fmap . fmap
05:16:49 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
05:16:54 <IceDane> aah
05:17:24 <alpounet> @type fmap `fmap` fmap
05:17:25 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
05:17:46 <ivanm> @type (.)
05:17:47 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:17:49 <zygoloid> @type fmap fmap fmap
05:17:50 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
05:17:51 <ivanm> grrr....
05:19:51 <alpounet> ivanm, you don't like caleskell ? heh
05:20:14 <ivanm> nope
05:20:41 <ManateeLazyCat> ivanm: http://farm5.static.flickr.com/4027/4542631529_f435373ccb_o.png
05:20:41 <koeien37> caleskell ftw
05:21:25 <ivanm> ManateeLazyCat: I doubt that such a thing would work with shells
05:21:37 <ivanm> actually, it _might_ work with fish since it seems to be a bit more concurrent than the others
05:22:00 <ManateeLazyCat> ivanm: Above screenshot is TextBuffer and TextView in Gtk+ , if for model/view split design.
05:22:08 <ivanm> I very rarely have the same buffer open twice in emacs; I doubt I'd ever want such a thing for a terminal instance
05:23:05 <ManateeLazyCat> ivanm: I have search long time, but haven't any terminal emulator support that (except term.el in Emacs)
05:23:21 <ivanm> well, I doubt any do
05:23:26 <ManateeLazyCat> ivanm: Split window is very useful for compare.
05:23:31 <ivanm> since AFAIK doing so in term.el works because you show the same buffer twice
05:23:44 <ivanm> ManateeLazyCat: yes, for files; but for terminal interaction?
05:25:19 <ManateeLazyCat> ivanm: For different temrinal interaction, you can switch different tab.
05:27:35 * ManateeLazyCat Looks just few people know this, i will use Cairo/Pango develop new one.
05:30:25 <ManateeLazyCat> Bye all, maybe we will release new version in this week.
05:33:58 <quicksilver> screen and tmux support what manateelazycat was talking about.
05:34:24 <quicksilver> @tell ManateeLazyCat GNU screen, and tmux, both support some of the split window / multiple views on same session you were discussing.
05:34:25 <lambdabot> Consider it noted.
05:36:18 <hpc> is there anywhere to download caleskell? google is failing me
05:36:22 <quicksilver> nope.
05:36:26 <hpc> D:
05:36:30 <quicksilver> I don't think so, anyway.
05:36:45 <quicksilver> it's just an informal name for a few alternative definitions inside lambdabot.
05:43:18 <alpounet> it's here iirc : http://code.haskell.org/lambdabot/State/L.hs
05:43:47 <ivanm> evil! evil I say!
05:44:19 * ivanm -> sleep
05:45:06 <alpounet> > drop 3 ++ take 3 $ ['a'..'z']
05:45:07 <lambdabot>   "defghijklmnopqrstuvwxyzabc"
05:48:10 <flazz> anyone know how to get haskell-src-exts-1.8.2 to install on snow leopard?
05:56:32 * hackagebot directory 1.0.1.1 - library for directory handling  http://hackage.haskell.org/package/directory-1.0.1.1 (IanLynagh)
06:01:08 <amosrobini> alpounet: what do you have to import do to get that drop ++ take magic to work?
06:01:41 <alpounet> it's caleskell
06:01:53 <alpounet> ++ has been generalised to any monoid
06:02:02 <alpounet> it becomes equivalent to mappend
06:02:05 <alpounet> @type (++)
06:02:06 <lambdabot> forall m. (Monoid m) => m -> m -> m
06:02:17 <amosrobini> ohh okay
06:02:33 <alpounet> i'll let you work out which monoid is being used here :)
06:02:35 * hackagebot redis 0.5.1 - A driver for Redis key-value database  http://hackage.haskell.org/package/redis-0.5.1 (AlexanderBogdanov)
06:03:23 <amosrobini> @type mappend (take 3) (drop 3)
06:03:24 <lambdabot> forall a. [a] -> [a]
06:03:35 * hackagebot scan 0.1.0.5 - lexical style suggestions for source code  http://hackage.haskell.org/package/scan-0.1.0.5 (ChristianMaeder)
06:04:15 <amosrobini> it almost seems like magic
06:04:31 <koeien37> but it is not
06:04:36 <koeien37> what is the type of take 3 ?
06:04:54 <amosrobini> [a] -> [a]?
06:04:59 <koeien37> correct
06:05:04 <Philonous> mathemagic
06:05:20 <koeien37> can you find a monoid on this type?
06:05:31 <koeien37> i.e. a zero and an associative operator
06:05:57 <amosrobini> is zero \x -> [] ?
06:06:33 <Philonous> mzero = id; mappend = (.)
06:07:17 <amosrobini> and that works for a -> a, not just [a] -> [a]?
06:07:25 <koeien37> that would be a monoid a -> a
06:07:49 <koeien37> exactly
06:08:42 <Philonous> Still, it is one possible monoid. But you are right, \x -> [] is the zero that is used
06:09:05 <Philonous> But you can generalize that as well!
06:09:12 <koeien37> const mzero ?
06:09:18 <amosrobini> with functors...? or?
06:10:11 <Philonous> amosrobini: Well, no. But what if instead of [] we had any monoid m? Would that still work?
06:12:10 <amosrobini> hmm. I don't understand. changing (\x -> []) to (\x -> ..)? or.. defining a monoid for some monoid m?
06:12:46 <Philonous> amosrobini: The former
06:13:55 <Philonous> amosrobini: Actually, both. Suppose you look at a -> m b where m is a monoid. Is that a monoid as well?
06:13:58 <amosrobini> \x -> mzero ?
06:14:07 <Philonous> Yep
06:15:38 <amosrobini> oh.. wow. I like that you don't need to do a hack for n-arg functions like you would in a non-curried language
06:17:38 <EvanR> for my next trick, lazy transpose
06:17:55 <EvanR> > take 5 $ transpose [[0..], [0..], [0..]]
06:17:56 <lambdabot>   [[0,0,0],[1,1,1],[2,2,2],[3,3,3],[4,4,4]]
06:18:20 <EvanR> thank you, thank you
06:18:55 <amosrobini> so is mappend for (a -> m b) just (\x y -> x `mappend` y) ?
06:19:22 <amosrobini> EvanR: I like how the numbers are the same in one group but different in others
06:21:15 <EvanR> amosrobini: oh?
06:21:55 <amosrobini> any idea how to scroll up in the buffer in irssi ?
06:22:26 <koala_man> pageup, alt-p. pagedown, alt-n to go down
06:24:35 <HandheldPenguin> I want to write something that prints all the multiples (in order) of a given list of ints like this...
06:24:40 <HandheldPenguin> take 10 (multiples [2,3])
06:24:40 <HandheldPenguin> [2,3,4,6,8,9,10,12,14,15]
06:24:55 <HandheldPenguin> What I have so far is this ... multiples (y:ys) = [ y * x | x <- [1,2..] ]
06:25:00 <HandheldPenguin> Which isn't doing as I would like :(
06:25:27 <HandheldPenguin> Pastebin here: http://haskell.pastebin.com/3gVaz5dc
06:25:56 <Phyx-> Is there a stable link to the GHC docs? 6.12.2's release seems to have broken some links again
06:26:08 <RayNbow> HandheldPenguin, wouldn't it be easier to do something like...
06:26:14 <RayNbow> multiples 2 `merge` multiples 3
06:27:16 <amosrobini> maybe something like multiples ys = [ y * x | y <- ys, x <- [1..]] ?
06:27:32 <Botje> HandheldPenguin: you have two problems, 1) generating a list of multiples for each number, 2) merging all those lists
06:27:51 <Botje> you seem to have solved the first one, but you still need to solve the second one :)
06:27:51 <RayNbow> > let multiples x = iterate (*x) 1 in multiples 2
06:27:52 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
06:28:03 <RayNbow> hmm wait
06:28:07 <RayNbow> > let multiples x = iterate (*x) x in multiples 2
06:28:08 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,26...
06:28:13 <RayNbow> ah crap
06:28:22 <HandheldPenguin> mm tricky :D
06:28:23 * RayNbow shouldn't be using iterate :p
06:28:25 <amosrobini> (+x) ?
06:28:27 <HandheldPenguin> That merge sounds ok
06:28:36 <amosrobini> iterate (+x), maybe?
06:28:41 <RayNbow> ah right
06:28:46 <RayNbow> > let multiples x = iterate (+x) x in multiples 2
06:28:47 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
06:31:23 <HandheldPenguin> ooh nice
06:33:45 <HandheldPenguin> thanks very much
06:35:05 <EvanR-work> > take 5 $ sort r where r = randoms g; g = mkStdGen
06:35:06 <lambdabot>   <no location info>: parse error on input `where'
06:35:39 <EvanR-work> > let r = randoms g; g = mkStdGen in take 5 $ sort r
06:35:40 <lambdabot>   No instance for (System.Random.RandomGen
06:35:40 <lambdabot>                     (GHC.Types.Int...
06:36:00 <EvanR-work> > let r = randoms g :: Int; g = mkStdGen in take 5 $ sort r
06:36:00 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
06:36:01 <lambdabot>         against inferred type ...
06:36:03 <EvanR-work> >_<
06:36:04 <HandheldPenguin> hangon, how would I merge the output for several items in the input list?
06:36:31 <Botje> HandheldPenguin: repeatedly merge :)
06:36:48 <Botje> (hint: foldl)
06:40:20 <EvanR-work> > let r = randoms g :: [Int]; g = mkStdGen 0 in take 5 $ sort r
06:40:24 <lambdabot>   mueval-core: Time limit exceeded
06:40:46 <gwern> you're sorting an infinite list?
06:41:03 <EvanR-work> guess that doesnt work! ;)
06:41:14 <gwern> well, I can help you there - the first entry is minBound :: Int...
06:42:25 <EvanR-work> is it never going to produce even one number
06:43:28 <EvanR-work> whoa it just exhausted my systems memory, and OOM killed my ghci and a random one of my chrome tabs :)
06:43:49 <EvanR-work> random three
06:45:31 <gwern> EvanR-work: well, as I said. given infinite time and space, the first entry will be minBound :: Int
06:45:51 <EvanR-work> given infinite time and space, i think it will never produce one result
06:46:12 <Claudius1aximus> wouldn't all the entries be minBound::Int?
06:46:19 <EvanR-work> 'all' ;)
06:47:27 <gwern> ClaudiusMaximus: well, I think there would be an countably infinite number of minBouds, a countably infinite number of minBounds-1...
06:47:30 <gwern> er +1
06:47:33 <EvanR-work> i suppose theres a one to one mapping between [0..] and the occurances of minBound in the list ;)
06:48:25 <ClaudiusMaximus> true, infinities are confusing
06:49:01 <EvanR-work> so yeah, for all indexes of the result, result !! n is minBound ;)
06:49:22 <EvanR-work> counter intuitive. of course, the fact that the algorithm makes no sense may have something to do with that
06:50:11 <ClaudiusMaximus> > takeWhile (==minBound) . sort . randoms $ mkStdGen 0
06:50:12 <lambdabot>   Ambiguous type variable `a' in the constraints:
06:50:13 <lambdabot>    `GHC.Show.Show a'
06:50:13 <lambdabot>      a...
06:50:23 <ClaudiusMaximus> > takeWhile (==(minBound::Int)) . sort . randoms $ mkStdGen 0
06:50:28 <lambdabot>   mueval: ExitFailure 1
06:50:48 <EvanR-work> dont sort first
06:52:01 <ClaudiusMaximus> hmm, sort is not clever enough to know there won't be anything less than minBound, d'oj
06:52:15 <ClaudiusMaximus> :)
06:52:26 <EvanR-work> > filter (==(minBound::Int)) (randoms $ mkStdGen 0)
06:52:30 <lambdabot>   mueval-core: Time limit exceeded
06:52:36 <Phyx-> Is there a stable link to the GHC docs? 6.12.2's release seems to have broken some links again
06:52:44 <gwern> ClaudiusMaximus: well, how would it be that clever?
06:53:25 <ClaudiusMaximus> sortBounded :: (Bounded a, Ord a) => [a] -> [a]
06:54:18 <EvanR-work> then what could it do
06:54:40 <EvanR-work> if it sees a minBound, put it in order?
06:54:53 <EvanR-work> (the beginning)
06:55:09 <ClaudiusMaximus> yes, would be really ugly code i imagine
06:55:20 <RichardBarrell> That could be counting sort.
06:55:55 <ClaudiusMaximus> ah, is that what it's called - going via a histogram for a bounded set
06:57:15 <EvanR-work> the sorted list could be constructed step by step
06:57:30 <EvanR-work> but i guess its invalid until the algorithm 'stops' ;)
06:59:53 <ClaudiusMaximus> > (minimum &&& maximum) . take 1000 . randoms $ mkStdGen 0
06:59:56 <lambdabot>   (-9192907461814544734,9221459100110493291)
07:00:11 <greedo> http://www.networkworld.com/news/2010/041910-computer-science-cheat.html
07:00:34 <greedo> interesting article
07:01:01 <EvanR-work> 'excessive collaboration'
07:01:43 <ClaudiusMaximus> > join (***) (\x -> fromIntegral x / fromIntegral (maxBound `asTypeOf` x)) . (minimum &&& maximum) . take 1000 . randoms $ mkStdGen 0
07:01:44 <lambdabot>   Ambiguous type variable `a' in the constraints:
07:01:44 <lambdabot>    `System.Random.Random a'...
07:07:00 * hackagebot uuagc 0.9.20 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-0.9.20 (ArieMiddelkoop)
07:10:16 <HandheldPenguin> Ok botje I have this so far...
07:10:21 <HandheldPenguin> multiples y = foldl (multi) 0 [y]
07:10:28 <HandheldPenguin> multi x = iterate (+x) x
07:10:42 <HandheldPenguin> But there is a problem with my foldl line :(
07:10:44 <Botje> uh, that sounds wrong
07:10:51 <Botje> you had a working multiples before
07:11:04 <Botje> multiples y = [ y * x | x <- [1..] ]
07:11:36 <Botje> you should use foldl to merge your list of lists of multiples into one list
07:12:14 <Gracenotes> if it helps -- foldl takes a list and accumulates it into a single value
07:12:23 <HandheldPenguin> hmm ok
07:14:24 <HandheldPenguin> Still not sure where to go with foldl lol
07:15:27 <fasta> let multiples x = x : multiples (x+x)
07:15:42 <fasta> I like that definition myself. Completely trivial.
07:16:05 <Botje> fasta: except it only gives you power-of-2 multiples
07:16:18 <Botje> HandheldPenguin: map multiples numbers gives you a list of lists of multiples
07:16:54 <Botje> for example, map multiples [1,2,3,4] gives you [[1,2,3,...],[2,4,6,...],[3,6,9,...],[4,8,12,...]]
07:16:58 <fasta> Botje, ah, ok, I thought earlier code also did that.
07:17:39 <Botje> HandheldPenguin: you can combine these lists into one big list with foldl1 merge (map multiples [1,2,3,4])
07:18:03 <Botje> (where merge merges two lists in ascending order)
07:18:52 <koeien37> why a left fold and not a right fold?
07:19:05 <koeien37> because it doesn't make sense on infinite lists anyway?
07:19:42 <Botje> right fold will work too
07:19:55 <Botje> and merge is associative anyway
07:19:59 <Botje> so it doesn't matter
07:20:14 <Botje> (or at least it should be :P)
07:20:18 <fasta> > let multiples x = foldr (\prev rest -> (prev + prev) : rest) [] [x..] in multiples 2
07:20:19 <lambdabot>   [4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54...
07:20:35 <koeien37> Botje: maybe that depends on your (==) ?
07:20:39 <koeien37> or (<)
07:20:48 <fasta> :t scanl
07:20:51 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
07:21:00 <Botje> koeien37: can you give an example?
07:21:48 <koeien37> Botje: no, I was just thinking. If your (<) is well-behaved it should go OK. otherwise, I am not sure
07:22:03 <Botje> i'm assuming < is sane, yes :)
07:23:06 <Jafet> > let multiples x = (x:) . concat . map (\y -> [y,y+x]) $ multiples (x+x) in multiples 5
07:23:07 <lambdabot>   [5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100,105,110,115,12...
07:29:11 <HandheldPenguin> Ok, i have this but it's still not doing waht I want...
07:29:13 <HandheldPenguin> multiples (x:rest) = foldr(\prev rest -> (prev + prev) : rest) [] [x..]
07:29:18 <HandheldPenguin> I really don't get haskell lol
07:31:02 <Botje> i gave you the solution above.
07:31:52 <EvanR-work> HandheldPenguin: if you dont get foldr, you can look at the source ;)
07:31:55 <EvanR-work> @src foldr
07:31:55 <lambdabot> foldr f z []     = z
07:31:55 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
07:32:09 <dibblego_> I am not a number I am a free man!
07:32:27 <HandheldPenguin> urgh
07:32:48 <EvanR-work> @src foldl'
07:32:48 <lambdabot> foldl' f a []     = a
07:32:49 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
07:32:53 <EvanR-work> eww ;)
07:40:37 <harlekin> @src seq
07:40:37 <lambdabot> Source not found. stty: unknown mode: doofus
07:43:19 <EvanR-work> :t seq
07:43:20 <lambdabot> forall a t. a -> t -> t
08:02:15 <HandheldPenguin> grr exploding head
08:03:32 <Jonno_FTW> what's the meaning of all this head exploding?
08:04:05 <EvanR-work> @quote explode
08:04:05 <lambdabot> EvilTerran says: you've got bottoms everywhere that'll explode if you look at them
08:04:13 <HandheldPenguin> multiples y = foldl (map multip y) multip :: [Integer] -> [Integer]
08:04:13 <HandheldPenguin> multip (y:ys) = [ y * x | x <- [1,2..] ]
08:04:18 <EvanR-work> lol
08:04:20 <HandheldPenguin> my foldl isn't working :(
08:04:35 <HandheldPenguin> my multip is fine
08:04:48 <HandheldPenguin> Trying to merge 2 lists
08:04:53 <Jonno_FTW> what is it you are trying to do?
08:05:10 <HandheldPenguin> I want to write something that prints all the multiples (in order) of a given list of ints like this...
08:05:11 <HandheldPenguin> [14:24:14] <HandheldPenguin> take 10 (multiples [2,3])
08:05:11 <HandheldPenguin> [14:24:14] <HandheldPenguin> [2,3,4,6,8,9,10,12,14,15]
08:05:12 <HandheldPenguin> I want to write something that prints all the multiples (in order) of a given list of ints like this...
08:05:12 <HandheldPenguin> [14:24:14] <HandheldPenguin> take 10 (multiples [2,3])
08:05:12 <HandheldPenguin> [14:24:14] <HandheldPenguin> [2,3,4,6,8,9,10,12,14,15]
08:05:14 <HandheldPenguin> I want to write something that prints all the multiples (in order) of a given list of ints like this...
08:05:14 <HandheldPenguin> [14:24:14] <HandheldPenguin> take 10 (multiples [2,3])
08:05:15 <HandheldPenguin> [14:24:14] <HandheldPenguin> [2,3,4,6,8,9,10,12,14,15]
08:05:18 <sioraiocht> AHH
08:05:22 <sioraiocht> hpst.org
08:05:22 <HandheldPenguin> woops sorry
08:05:24 <sioraiocht> hpaste.org
08:05:25 <sioraiocht> lol
08:05:26 <sioraiocht> np
08:06:05 <Botje> 16:10 < Botje> multiples y = [ y * x | x <- [1..] ]
08:06:12 <Botje> 16:16 < Botje> for example, map multiples [1,2,3,4] gives you  [[1,2,3,...],[2,4,6,...],[3,6,9,...],[4,8,12,...]]
08:06:16 <Botje> 16:17 < Botje> HandheldPenguin: you can combine these lists into one big list  with foldl1 merge (map multiples [1,2,3,4])
08:06:28 <HandheldPenguin> foldl1?
08:06:50 <Jonno_FTW> combining lists is done with concat
08:07:02 <EvanR-work> he wants to merge the lists
08:07:02 <Botje> yes, since there is no sensible default you can give to foldl merge.
08:07:11 <Botje> HandheldPenguin: so all you have to do is write merge.
08:07:26 <Jonno_FTW> sort $ concat ?
08:07:29 <Botje> which has type Ord a => [a] -> [a] -> [a] and which combines two lists in sorted order.
08:07:42 <HandheldPenguin> This doesn't work:
08:07:42 <HandheldPenguin> multip :: [Integer] -> [Integer]
08:07:42 <HandheldPenguin> multip y = [ y * x | x <- [1..] ]
08:07:46 <EvanR-work> Jonno_FTW: you mean sort . concat
08:07:52 <Jonno_FTW> nub . sort . concat ?
08:07:58 <Botje> HandheldPenguin: because y is not a list of integers.
08:08:01 <Botje> it's an integer.
08:08:03 <Jonno_FTW> that is the naive method
08:08:24 <EvanR-work> Jonno_FTW: not sure if thats the goal, but if hes trying to merge sorted, that would work instead ;)
08:08:37 <Jonno_FTW> how about
08:08:37 * Baughn wonders who had the bright idea of instancing Enum for a 64-bit CDev
08:09:20 <Jonno_FTW> multiples xs ys = sort $ nub $ concat [x*y|x<-xs,y<-ys]
08:10:17 <Jonno_FTW> @let multiples xs ys = sort $ nub $ concat [x*y|x<-xs,y<-ys]
08:10:19 <lambdabot>  Defined.
08:10:39 <Jonno_FTW> > take 5 $multiples [1..5] [6..10]
08:10:41 <lambdabot>   No instance for (GHC.Enum.Enum [a])
08:10:41 <lambdabot>    arising from the arithmetic sequence...
08:10:47 <Jonno_FTW> :\
08:11:08 <Jonno_FTW> @let multiples xs ys = sort $ nub [x*y|x<-xs,y<-ys]
08:11:09 <lambdabot>  <local>:10:18:
08:11:09 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a...
08:11:11 <Jonno_FTW> > take 5 $multiples [1..5] [6..10]
08:11:12 <lambdabot>   No instance for (GHC.Enum.Enum [a])
08:11:12 <lambdabot>    arising from the arithmetic sequence...
08:11:44 <EvanR-work> when you @let, does it check your types?
08:11:56 <Jonno_FTW> yes
08:12:02 <Jonno_FTW> i'll try this in ghci first
08:12:59 <Jonno_FTW> strange
08:13:28 <Jonno_FTW> @let multiples xs ys = sort $ nub [x*y|x<-xs,y<-ys] :: [Integer]
08:13:28 <lambdabot>  <local>:10:18:
08:13:29 <lambdabot>      Couldn't match expected type `Integer' against inferred ...
08:13:40 <Jonno_FTW> @let multiples xs ys = sort $ nub [x*y|x<-xs,y<-ys]
08:13:41 <lambdabot>  <local>:10:18:
08:13:41 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a...
08:13:49 <Jonno_FTW> YOU STUPID BOT
08:14:28 <Jonno_FTW> > let multiples xs ys = sort $ nub [x*y|x<-xs,y<-ys] in take 5 $ multiples [1..4] [6..10]
08:14:29 <lambdabot>   [6,7,8,9,10]
08:14:34 <Jonno_FTW> is this what you want?
08:16:28 <Jonno_FTW> HandheldPenguin: is what i did above what you need?
08:18:34 <HandheldPenguin> xs ys?
08:18:41 <HandheldPenguin> It only takes one [Integer]
08:18:51 <Jonno_FTW> what?
08:18:55 * Botje feels ignored
08:19:04 <HandheldPenguin> Sorry Botje
08:19:13 * Jonno_FTW doesn't understand the client's needs
08:19:53 <Jonno_FTW> so you want all possible products of the numbers inside the list?
08:20:09 <HandheldPenguin> What it is, is multiples [2,3]
08:20:18 <HandheldPenguin> prints 2,3,4,6
08:20:25 <EvanR-work> the list has exactly two?
08:20:28 <EvanR-work> (2,3)?
08:20:35 <HandheldPenguin> no
08:20:36 <HandheldPenguin> any size
08:20:39 <HandheldPenguin> I've got it working for 2
08:20:48 <EvanR-work> so you want n*2+m*3 ?
08:20:49 <HandheldPenguin> multiples [x,y] = [m | m <- [1,2..], (m `mod` x) == 0 || (m `mod` y) == 0]
08:21:09 <HandheldPenguin> No no go on for ad infinitum
08:22:58 <Jonno_FTW> and what is this for?
08:23:30 <Botje> oh well
08:23:30 <HandheldPenguin> Coursework :s
08:23:34 <Botje> i've got better things to do
08:23:40 <Jonno_FTW> homework
08:23:44 <HandheldPenguin> Thanks anyway Botje :)
08:23:50 <Jonno_FTW> you could try asking on stackoverflow
08:24:13 <EvanR-work> > (,) 4 5
08:24:14 <lambdabot>   (4,5)
08:24:21 <EvanR-work> > return 5
08:24:22 <lambdabot>   No instance for (GHC.Show.Show (m t))
08:24:22 <lambdabot>    arising from a use of `M4801889816...
08:30:54 <ski> @type let multiples xs ys = sort $ nub [x*y|x<-xs,y<-ys] in multiples
08:30:55 <lambdabot> forall a. (Num a, Ord a) => [a] -> [a] -> [a]
08:30:58 <ski> @type multiples
08:30:59 <lambdabot> forall a. (Ord a, Num [a]) => [[a]] -> [[a]] -> [a]
08:31:33 <ski> hmm
08:31:44 <ski> @let f False = 0
08:31:45 <lambdabot>  Defined.
08:31:49 <ski> @let f True = 1
08:31:50 <lambdabot>  Defined.
08:31:53 <ski> @type f
08:31:54 <lambdabot>     Ambiguous occurrence `f'
08:31:54 <lambdabot>     It could refer to either `L.f', defined at <local>:10:0
08:31:54 <lambdabot>                           or `SimpleReflect.f', imported from SimpleReflect at State/L.hs:74:0-32
08:31:58 <ski> @type L.f
08:31:59 <lambdabot> forall t. (Num t) => Bool -> t
08:32:04 <ski> .. interesting
08:32:30 <ski> @let somethingElse = "somethingOther"
08:32:31 <lambdabot>  Defined.
08:32:35 <ski> @let f _ = 2
08:32:36 <lambdabot>  <local>:13:0:
08:32:36 <lambdabot>      Multiple declarations of `L.f'
08:32:36 <lambdabot>      Declared at: <local>:...
08:32:56 <zygoloid> > let merge (a:as) (b:bs) | a < b = a:merge as (b:bs) | a > b = b:merge (a:as) bs | otherwise = a:merge as bs; merge as bs = as++bs; multiples ns = foldr merge [] $ (\n -> (n*) <$> [1..]) <$> ns  in multiples [2,3,5]
08:32:57 <lambdabot>   [2,3,4,5,6,8,9,10,12,14,15,16,18,20,21,22,24,25,26,27,28,30,32,33,34,35,36,...
08:33:36 <ski> Jonno_FTW : the problem was that it already had an equation for `multiples', so when you tried to add more, they all got added together, and the result didn't type-check
08:34:20 <applicative>  > let { or = (\f g x -> f x || g x) ; mul n x = x `mod` n == 0 } in filter (foldr1 or (map mul [2,3,5])) [1..100]
08:34:55 <applicative>  > let { or = (\f g x -> f x || g x) ; mul n x = x `mod` n == 0 } in filter (foldr1 or (map mul [2,3,5])) [1..100]
08:34:56 <ski> @type let foo [x] = x; foo x = x in foo  -- cyclic unification problem like in this case
08:34:57 <lambdabot>     Occurs check: cannot construct the infinite type: t = [t]
08:34:57 <lambdabot>       Expected type: t
08:34:57 <lambdabot>       Inferred type: [t]
08:35:05 <zygoloid> applicative: you have a space before the >
08:35:14 <applicative> curses
08:35:20 <zygoloid> ncurses
08:35:21 <ski> ncurses ?
08:35:24 <EvanR-work> ncurses
08:35:25 <applicative> > let { or = (\f g x -> f x || g x) ; mul n x = x `mod` n == 0 } in filter (foldr1 or (map mul [2,3,5])) [1..100]
08:35:26 <lambdabot>   [2,3,4,5,6,8,9,10,12,14,15,16,18,20,21,22,24,25,26,27,28,30,32,33,34,35,36,...
08:35:32 <zygoloid> where n = 4
08:35:34 <EvanR-work> lol
08:36:54 <zygoloid> > liftM2 (+) [2,3,4,5,6,8,9,10,12,14,15,16,18,20,21,22,24,25,26,27,28,30] [30,60..]
08:36:54 <lambdabot>   [32,62,92,122,152,182,212,242,272,302,332,362,392,422,452,482,512,542,572,6...
08:37:01 <zygoloid> > liftM2 (+) [2,3,4,5,6,8,9,10,12,14,15,16,18,20,21,22,24,25,26,27,28,30] [0,30..]
08:37:02 <lambdabot>   [2,32,62,92,122,152,182,212,242,272,302,332,362,392,422,452,482,512,542,572...
08:37:07 <zygoloid> d'oh
08:37:15 <zygoloid> > liftM2 (+) [0,30..] [2,3,4,5,6,8,9,10,12,14,15,16,18,20,21,22,24,25,26,27,28,30]
08:37:16 <lambdabot>   [2,3,4,5,6,8,9,10,12,14,15,16,18,20,21,22,24,25,26,27,28,30,32,33,34,35,36,...
08:42:53 <Baughn> @hoogle Real a => a -> Integer
08:42:55 <lambdabot> Prelude toRational :: Real a => a -> Rational
08:42:55 <lambdabot> Data.Fixed mod' :: Real a => a -> a -> a
08:42:55 <lambdabot> Data.Fixed div' :: (Real a, Integral b) => a -> a -> b
08:43:43 <ski> @type [ceiling,floor,round]
08:43:44 <lambdabot> forall a b. (RealFrac a, Integral b) => [a -> b]
08:44:21 <ski> @type truncate  -- too, i guess
08:44:22 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
08:44:37 <EvanR-work> :t [map, filter]
08:44:38 <lambdabot> [(Bool -> Bool) -> [Bool] -> [Bool]]
08:44:47 <EvanR-work> :t [map, filter, fix]
08:44:48 <lambdabot>     Couldn't match expected type `[Bool] -> [Bool]'
08:44:48 <lambdabot>            against inferred type `Bool'
08:44:48 <lambdabot>     In the expression: fix
08:45:08 <ski> sometimes it would be nice with a way to check that two expressions have the *same* general type, not just that they have common instances
08:45:12 <EvanR-work> was checking what happens if you make a list of different types
08:45:33 <EvanR-work> though map and filter have different types
08:49:04 <ski> @type let _ = head `asTypeOf` length in ()  -- huh ?
08:49:05 <lambdabot> parse error on input `in'
08:49:29 <ski> @type let _ = head `asTypeOf` length in ()
08:49:30 <lambdabot> ()
08:49:50 <ski> (some stange character must have sneaked in, i suppose ..)
08:50:00 <mtnviewmark> :t [($), id]
08:50:01 <lambdabot> forall a b. [(a -> b) -> a -> b]
08:50:04 <mtnviewmark> heh
08:51:17 <Jafet> > ord '?'
08:51:18 <lambdabot>   63
08:52:43 <ski> (hm it appears that the space after `_' was possibly a shift-space or something like that)
08:53:04 <ski> @type \f -> let _ = f `asTypeOf` length in ()
08:53:05 <lambdabot> forall a. ([a] -> Int) -> ()
08:53:27 <ski> (.. and that doesn't work)
08:54:36 <shapr> Goood Morning #haskell!
08:55:01 <Kaidelong> is wxHaskell known to not work on 64 bit windows?
08:55:03 <ski> good evening
08:55:16 <shapr> Looks like I got here at the right time, everybody else is showing up too.
08:55:42 <shapr> hej ski
08:55:44 <Kaidelong> because if the answer is something like "it's not supported and there are no plans to do so" then at least it'd save me a lot of trouble
08:56:20 <shapr> Kaidelong: I don't use Windows, I don't know.
08:57:17 <Kaidelong> I imagine it should work fine anywhere wxWidgets does unless there is something weird about marshalling through the FFI or something
08:58:00 <quicksilver> it probably works as long as wxWidgets is compiled 'the same way' as your ghc
08:58:09 <quicksilver> so a 32-bit compiled ghc needs a 32-bit compiled wxwidgets
08:58:33 <quicksilver> does GHC actually run in 64 bits in windows?
08:58:38 <ski> hejhej, shapr :)
08:58:45 <Kaidelong> huh!
08:58:49 <Kaidelong> now that got me thinking
08:59:04 <Kaidelong> I didn't want to bootstrap GHC so I installed it from a binary release
08:59:10 <quicksilver> I think not. I think GHC only runs in 32 bit on windows.
08:59:21 <quicksilver> So that means you need a 32bit wxwidgets to match.
08:59:27 <Kaidelong> so I'll have to somehow compile wxWidgets as a 32 bit application
08:59:44 <quicksilver> library, rather
08:59:46 * hackagebot vcd 0.1.2 - Tools for reading and writing VCD files.  http://hackage.haskell.org/package/vcd-0.1.2 (TomHawkins)
08:59:52 <Kaidelong> which means passing some or other argument to mingw32's make
09:01:53 <ski>   import qualified Control.Arrow.Transformer as AT
09:01:54 <ski>   import qualified Control.Arrow.Transformer.All as AT
09:02:03 * ski didn't know you could do that ..
09:02:16 <HandheldPenguin> Botje: I found that this works multi xs = [x*y | y <- [1..], x <- xs ]
09:02:22 <HandheldPenguin> stack overflow
09:03:34 <ski> HandheldPenguin : how are you using `multi' ?
09:05:30 <alpounet> ski, both modules' content comes under the same qualification "AT" ?
09:05:44 <xerox> > foldl' (flip ((*) . uncurry (*))) 1 . zip [1..] $ [1,2,3]
09:05:46 <lambdabot>   36
09:05:46 <xerox> > foldl' (flip ((*) . uncurry (*))) 1 . zip [1..] $ [1..10^4]
09:05:47 <lambdabot>   810119417121405300389123222879881328534991702812961247663485705236762934402...
09:06:22 <ski> alpounet : i would assume so, yes
09:06:31 <alpounet> ok
09:06:59 <ski> never thought about whether that could work, before
09:07:09 <alpounet> no reason to, i guess heh
09:07:25 <FliPPeh> Meh, I hate it when people don't pick my answer on stackoverflow, despite it being the only one being the correct solution :(
09:08:44 * ski wants a shorhand way to saying that something is the only thing satisfying some property, if indeed there exists anything satisfying that property
09:09:07 * Kaidelong supposes he could boot into linux, set up something there, and cross-compile
09:09:32 <Kaidelong> by the looks of it I will have to cross-compile wxWidgets anyway
09:09:33 <ski> (i.e. how to say `forall y. P y => x = y' for given `x' and `P', in english ?)
09:10:14 <ski> (to say `forall y. P y <=> x = y' is easy : "`x' is *the* single/only thing satisfying `P'")
09:10:52 <quicksilver> "x is the only thing satisfying P, if any"
09:11:06 <ski> that's cumbersome
09:11:19 <Kaidelong> Oh, it looks like since I was building it with mingw32 it did build a 32 bit library
09:11:22 <ski> i want to get rid of the "the"
09:11:25 <Kaidelong> so the problem is something else
09:11:34 <mtnviewmark> smiles at FliPPeh - I konw what you mean!
09:11:44 <Kaidelong> then again I might be reading out of date newsgroups
09:12:28 <Kaidelong> but from what I get so far using GCC to build 64 bit windows applications is still experimental and not something you'd do by default
09:12:48 <FliPPeh> mtnviewmark: To add insult to injury, it was downvoted.
09:12:56 <Kaidelong> anyway the lack of getting GUI development going on haskell has been frustrating, particularly after a long string of successes in other areas
09:13:46 <ski> (FliPPeh : "forgive them, because they know not what they do" ? ;)
09:14:13 <siracusa> Hey, I've got a panic from GHC :-)
09:14:16 <mtnviewmark> downvote w/o comment is just mean - I think SO should not allow it!
09:14:17 <shapr> hah, yes
09:14:23 <shapr> forgive them...
09:14:27 <mtnviewmark> but hey, it's just SO!
09:14:30 <fasta> siracusa, which version?
09:14:43 <siracusa> fasta: 6.10.4
09:14:51 * Kaidelong peeks at qtHaskell
09:14:54 <xerox> ski: why do you want to get rid of "the"
09:14:56 <fasta> siracusa, that's not really news worthy ;)
09:15:09 <fasta> siracusa, upgrade.
09:15:20 <siracusa> fasta: Yeah, I'm trying the same in 6.12.1 now ...
09:15:22 <shapr> Kaidelong: Are you searching for cross-platform GUI dev in Haskell?
09:15:30 <gwern> I have a theory that guis suck in haskell because we keep thinking, I don't want to do this, I want FRP!
09:15:39 <Kaidelong> shapr: exactly, that is the main reason for me not doing this all on .NET
09:15:39 <fasta> siracusa, also, if you use type-families it is also not really news worthy.
09:15:47 <ski> xerox : because afaics "the" signifies existence (and more), here
09:16:00 <shapr> Kaidelong: Do you have a blog where you document your results?
09:16:04 <mtnviewmark> > let multi xs = [x*y | y <- [1..], x <- xs ] in take 20 in multi [2,6]
09:16:05 <Kaidelong> shapr: wxWidgets has been several days of frustration building applications that segfault immediately at runtime
09:16:05 <lambdabot>   <no location info>: parse error on input `in'
09:16:12 <shapr> I'd like to know how it turns out.
09:16:15 <Kaidelong> shapr: no, perhaps I should start blogging
09:16:30 <mtnviewmark> > let multi xs = [x*y | y <- [1..], x <- xs ] in take 20 $ multi [2,6]
09:16:31 <lambdabot>   <no location info>: lexical error at character '\FS'
09:16:34 <fasta> Kaidelong, IMHO, GTK2HS if you know GTK is easy.
09:16:36 <shapr> Kaidelong: Would be easier for me to keep track of the results.
09:16:41 <mtnviewmark> > let multi xs = [x*y | y <- [1..], x <- xs ] in take 20 (multi [2,6])
09:16:42 <lambdabot>   <no location info>: lexical error at character '\FS'
09:16:47 <mtnviewmark> feh
09:16:50 <shapr> fasta: Works fine on Windows 32 and 64?
09:17:18 <fasta> shapr, I don't know about that.
09:17:21 <Kaidelong> fasta: works fine with GHC 12?
09:17:32 <lispy> GHC 12??
09:17:34 <Kaidelong> I thought you needed 10.4 to make gtk2hs stuff build
09:17:38 <fasta> Kaidelong, with some effort, sure.
09:17:39 <lispy> Oh man, I'm still on 6.12
09:17:54 <ski> > chr (ord '@' + ord '\FS')
09:17:54 <fasta> Kaidelong, e.g. using the darcs version.
09:17:55 <lambdabot>   '\\'
09:17:55 <shapr> lispy: Hey, what did you want earlier?
09:18:24 <lispy> shapr: $10000000, can you give me a loan?
09:18:26 <Kaidelong> fasta: I have had trouble getting darcs to build via cabal, filed something on their tracker about it
09:18:30 <Kaidelong> type error
09:18:31 <ski> > let multi xs = [x*y | y <- [1..], x <- xs ] in take 20 (multi [2,6])  -- mtnviewmark, removed the `^\' character
09:18:32 <lambdabot>   [2,6,4,12,6,18,8,24,10,30,12,36,14,42,16,48,18,54,20,60]
09:18:45 <lispy> shapr: Actually, I was looking for a GSoC person who could accept my adivisor application
09:18:48 <mtnviewmark> so - it doesn't work in this case -- the result list isn't sorted!
09:18:50 <Kaidelong> http://bugs.darcs.net/issue1826
09:19:02 <lispy> shapr: tibbe fielded
09:19:03 <Kaidelong> thinking I will try a darcs binary
09:19:05 <shapr> lispy: I can loan you five dollars. That's all the cash I have at the moment.
09:19:26 <Kaidelong> the old versions of darcs are still available with a binary windows installer last I checked
09:19:34 <FliPPeh> @src Data.List.nub
09:19:34 <lambdabot> Source not found. Where did you learn to type?
09:21:31 <Kaidelong> @src Data.List(nub)
09:21:31 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
09:21:32 <ski> @src nub
09:21:32 <lambdabot> nub = nubBy (==)
09:21:52 <FliPPeh> @src nubBy
09:21:52 <lambdabot> nubBy eq []             =  []
09:21:52 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
09:22:05 <Kaidelong> that works
09:22:53 <ski> (hm, that sounds like a possibly good candidate for deforestation ..)
09:23:44 <Kaidelong> does its definition prevent it the way it is written right now? I'm still trying to grasp how to make GHC use deforestation
09:28:10 <Kaidelong> the way I'd write it instinctively is make a new tree set and list and accumulate on both until the input list is empty
09:28:47 <Kaidelong> which I think would be an asymptotic improvement over filtering the tail each time in the worst case
09:29:53 <Saizan> accumulator for the list would be bad, you want to return the elements as early as possible, not after looking at the whole list
09:29:57 <lispy> Kaidelong: the darcs build error looks like hashed -storage is making too many unix assumptions for windows.
09:30:37 <Kaidelong> Saizan: right, lazy evaluation is still new to me, you want to use cons because the tail isn't evaluated... still getting used to that =)
09:30:50 <Kaidelong> I'm used to cons being bad because it uses just slightly more memory than an accumulator
09:31:29 <Saizan> if by "tree set" you mean something like Data.Set then it'd require Ord for the elements, not just Eq like in the signature of nub, but you're right that it would be asymptotically faster
09:32:02 <lispy> Does John Lato hangout here?
09:32:05 <Kaidelong> Ah, that's right. Same in F#, IStructuralEquatable doesn't imply IComparable
09:32:40 <Kaidelong> now it makes sense
09:32:55 <lispy> Kaidelong: ah, are you coming here from an OCaml/F# background?
09:33:01 <Kaidelong> Yes
09:33:31 <Kaidelong> lispy: I assumed as much, a lot of my problems with building stuff on cabal stemmed from assumptions that don't make a lot of sense on windows (IE having perl)
09:33:36 * ski is trying to figure out whether `nubBy' can be written using `foldr' and `build' ..
09:34:11 <dcoutts_> Kaidelong: there's not much that needs perl, only a couple packages I know of
09:34:15 <gwern> lispy: who is jon lato?
09:34:20 * gwern doesn't think so
09:34:35 <lispy> gwern: he's written several packages for using iteratees
09:34:52 <lispy> Some of  the haddocks are confusing me, so I wished I could ask him about them
09:34:53 <gwern> lispy: 'twould help if you knew his nick; then you could query preflex
09:34:55 <dcoutts_> Kaidelong: the bigger problem with packages on windows is the lack of the C libs or any sensible way of getting those C libs for windows users
09:34:58 <BMeph> ski: It'd arguably be better English to drop the "only" than to drop the "THE". :)
09:35:09 <lispy> gwern: I agree, hence my question :)
09:35:41 <Kaidelong> dcoutts_: yes, I was very surprised by GHCi complaining I didn't have stdc++, then later finding out that I wasn't SUPPOSED to
09:35:50 <Kaidelong> I was concerned for a while
09:36:18 <ski> BMeph : hm, how about "`x' is an only thing satisfying `P'" ?
09:36:30 <dcoutts_> Kaidelong: what package was that ooi? there are even fewer that use C++ code
09:37:06 <Kaidelong> dcoutts_: it's actually interesting. I was trying to load the wx package. Someone hardcoded the stdc++ check even though it wasn't actually needed to load wx.
09:37:16 <Kaidelong> something to do with it fixing a problem on OS X
09:37:23 <Kaidelong> but then it goes and breaks it for windows
09:37:34 <dcoutts_> Kaidelong: ah, so wx is one of those few bindings to C++ a lib
09:37:59 <Kaidelong> dcoutts_: on windows, the needed functionality is statically linked in the generated library
09:38:10 <Kaidelong> so it doesn't need stdc++
09:38:17 <Kaidelong> it comes with it
09:38:18 <zygoloid> ski: 'the' not 'an'
09:38:44 <dcoutts_> Kaidelong: sounds like a lack of testing, it is supposed to be a cross-platform lib and binding afterall
09:38:50 <ski> zygoloid : i don't want to claim there is an `x' satisfying `P', only that if there is any `y' satisfying `P', then it must be `x'
09:39:10 <zygoloid> ski: "nothing other than `x' can satisfy `P'
09:39:17 <BMeph> ski: No, that definitely doesn't work - "an" is indefinite. "x is the thing that satisfies P." would be better (FSVO "better"). :)
09:39:26 <Kaidelong> dcoutts_: yes, what it looked like to me was that some person changed GHCi to work on his configuration without realizing it broke windows
09:39:44 <dcoutts_> Kaidelong: well, not changed ghci, changed the wx package
09:39:49 <somnium> http://gist.github.com/375462 << I suppose I must be doing something stupid here to get this 'last statement in a do construct must be an expression' error
09:39:54 <ddarius> ski: If you don't mind be slightly obscure, "P describes x"
09:40:04 <ski> BMeph : the latter doesn't work, since that (at least to me) implies that `x' actually *does* satisfy `P'
09:40:21 <Kaidelong> dcoutts_: I don't know the details. GHC actually works with -package wx and will compile a program that segfaults immediately
09:40:31 <Kaidelong> GHCi will complain it can't find stdc++
09:40:32 <ski> it appears to me that this is a bug / missing feature in english
09:40:45 <ski> (not claiming that other natural languages are better)
09:40:56 <ski> ddarius : hm, i'll ponder that. ty
09:41:00 <Kaidelong> the segfaulting appears to be unrelated
09:41:03 <zygoloid> ski: "only x can satisfy P", or "nothing other than x can satisfy P"
09:41:07 <dcoutts_> Kaidelong: they use different linkers, runtime vs static, so there are sometimes differences when you're doing hairy things with lots of C libs
09:41:53 <dcoutts_> Kaidelong: eg perhaps the static linker does find a stdc++ static lib, but GHCi is looking for a dll
09:42:18 <zygoloid> ski: "anything satisfying P must be x"
09:42:29 <Kaidelong> dcoutts_: http://www.mail-archive.com/wxhaskell-devel@lists.sourceforge.net/msg00540.html
09:42:30 <ski> zygoloid : consider e.g., "i <em>drink</em> only coffee" .. would that suggest to you that "i actually drink coffee" ?
09:42:34 <Kaidelong> this was the message I found
09:42:46 <Baughn> @djinn CTime -> Integer
09:42:46 <lambdabot> Error: Undefined type CTime
09:42:51 <BMeph> ski: Yeah, if you're going to disclaim existence, then you'd need to be more  wordy. English lost a lot of terseness by dropping most of its inflection mechanisms. :)
09:42:52 <Baughn> @djinn Rational -> Integer
09:42:52 <lambdabot> Error: Undefined type Rational
09:43:13 <Baughn> @djinn Ratio Int -> Integer
09:43:13 <lambdabot> Error: Undefined type Ratio
09:43:29 <zygoloid> ski: no, but i have training as a mathematician :)
09:43:35 <ski> (oh, nice word, "disclaim" :)
09:43:39 <dcoutts_> Kaidelong: ok, good so they're aware of it. Looks like an easy workaround you could try too.
09:43:59 <ddarius> ski: Something that is perhaps less likely to lead to confusion and more likely to lead to the correct interpretation is "P characterizes x"
09:44:01 <zygoloid> ski: "i don't drink anything other than coffee", or "if it's not coffee then i don't drink it"
09:44:24 <ski> BMeph : you don't like one of `[floor,ceiling,round,truncate]' ?
09:44:32 * BMeph agrees with zygoloid's constructions
09:44:47 <zygoloid> ddarius: isn't that backwards? i would say that means that x has the characteristic of P (and that other things might also)
09:45:44 <FunctorSalad_> ski: "I *drink* only coffee" seems to emphasize the contrast to "For *ANY* verb v, I $v only coffee". *grin*
09:47:02 <ski> ddarius : hm, doesn't that imply that `P x' ? .. or, hm, "so and so characterizes (up to isomorphism) any categorical product of `A' and `B'" doesn't imply the categorical product need to exist ..
09:47:08 <BMeph> ski, FunctorSalad_: Yes, saying I *drink* only coffee suggests other verbs could apply to similar substances, bathing, perhaps.
09:47:17 <Baughn> :t floor . fromRational . toRational
09:47:18 <lambdabot> forall b a. (Integral b, Real a) => a -> b
09:47:21 <ddarius> zygoloid: In common (American) English "characterize" is somewhat stronger than that.  In mathematics, it's stronger still: "Characterization - In mathematics, the statement that "Property P characterizes object X" means, not simply that X has property P, but that X is the only thing that has property P."
09:47:56 <Baughn> "Being a non-odd integer characterizes 2"
09:48:02 <Baughn> *non-odd prime
09:49:01 <zygoloid> ddarius: i wouldn't recognise that implication. but i'm british :)
09:50:10 <FunctorSalad_> I noticed that peculiarity in math too
09:50:26 <FunctorSalad_> what's the strongness in plain american image?
09:50:27 <ddarius> ski: "Characterize" doesn't usually imply existence.
09:50:28 <FunctorSalad_> *english
09:51:00 <ski> BMeph,FunctorSalad_ : hm, sorry, that emphasis was misplaced since i got a bit confused (about placing of `only' and the role of the emphasis), rephrasing into "i only drink <em>coffee</em>" (as oppossed to `<em>i</em> only drink coffee", or "i only <em>drink</em> coffee")
09:51:24 <ddarius> FunctorSalad_: Pretty much the same as the mathematical one though a bit weaker.  When you say "P characterizes John" you usually mean that P distinguishes John from other (relevant) people.
09:51:40 <FunctorSalad_> emphasis or hyphen displacement tends to produce funny results :)
09:51:52 <FunctorSalad_> ddarius: I see
09:52:23 <zygoloid> ddarius: i would say that "if T X means not simply that F X, but that G X" means "T X implies F X and G X" so that "characterize" by that definition implies P X :p
09:52:38 <FunctorSalad_> ski: what was it you wanted to emphasize? that the sentence is true, rather than any part of it?
09:52:51 <FunctorSalad_> ski: "It is important to realize that I do, in fact, drink coffee"
09:52:53 <FunctorSalad_> ;)
09:53:31 <zygoloid> "if i drink it, then it's coffee"
09:53:38 <ski>      only (drink i (em coffee))
09:53:44 <ski>   =  reset (drink i (em coffee))
09:53:49 <ddarius> Here's a wordnet definition: "the act of describing distinctive characteristics or essential features"
09:53:50 <Kaidelong> the way I thought of it was that the implication changes depending where the emphasis is (just reading what ddarius was writing) even if the meaning of the sentence is intact
09:53:51 <ski>   =  reset (drink i (shift P in forall x. P x => x = coffee))
09:53:54 * xerox runs naked through the code
09:53:57 <ski>   =  reset (let P x = drink i x in forall x. P x => x = coffee)
09:53:57 <bastl> hey, there was a cool thing that plotted ASTs of arbitrary terms to a graphic-display ...
09:53:59 <ski>   =  forall x. drink i x => x = coffee
09:54:08 <bastl> can someone give me a pointer, I cant remember
09:54:14 <ddarius> bastl: vacuum?
09:54:22 <bastl> right :-)
09:54:24 <bastl> tx
09:54:25 <zygoloid> bastl: (void*)0xdeadbeef
09:54:34 * zygoloid ducks
09:54:35 <ddarius> ski: Do you want to look at the theory of descriptions?
09:54:41 <ski> is the derivation of meaning of "i only drink <em>coffee</em>", employing delimited continuations
09:54:45 <FunctorSalad_> bastl: weren't *you* the one who wrote such a thing based on multirec? *confused*
09:55:07 <ddarius> ski: Also it sounds like you -really- want to look at Paul Taylor's rendition of the notion of soberness.
09:55:16 <ddarius> ski: I'll get you a link.
09:55:17 <bastl> FunctorSalad: yes, GTK based, now I wanna visualize terms for a better imagination
09:55:49 <ddarius> ski: http://www.paultaylor.eu/ASD/loccpct#sobsc
09:56:00 <FunctorSalad_> ski: "I drink coffee exclusively"?
09:56:21 <FunctorSalad_> "I drink coffee to the exclusion of all other drinks" to make it clear what is exclusive
09:56:42 <FunctorSalad_> ski: I must be missing the `reset' reference :)
09:57:11 <FunctorSalad_> bastl: graphviz?
09:57:46 <ski> ddarius : hm, ty
09:58:04 <ski> (hearing "the theory of descriptions", i think of Russel)
09:58:57 <ddarius> ski: That or variations on that are what I was referring to with that.  As the abstract for the Paul Taylor states, sobriety captures a notion of "definite description."
09:59:10 <ski> ddarius : re "\"Characterize\" doesn't usually imply existence.", i'm not sure that is relevant here, since in "`P' characterizes `x'", `x' is free
09:59:50 <ddarius> ski: I agree.  It doesn't really make sense to say whether it implies existence or not (in the formal situation.)
10:00:28 <ski> FunctorSalad_ : `reset' and `shift' as in the delimited/composable continuation operations
10:00:46 <FunctorSalad_> ski: ok, outside my knowledge :)
10:01:02 <ski> FunctorSalad_ : there's probably a paper by Chung-Shieh Chan, or Barker, that explains how those are useful in semantics of natural language
10:01:14 <ddarius> ski: There definitely is.
10:01:27 <FunctorSalad_> ski: is there a short intro about what they are in haskell?
10:01:38 <FunctorSalad_> heard about it on hackage o_o
10:02:09 <ski> (i don't really recall where i read about it, but those two are the only people doing (computational) linguistics that i have read and what i can remember names of)
10:02:58 <p_l> ski: you mean "delimited continuations in natural language" or something like that?
10:03:11 <ski> p_l : quite possibly :)
10:03:14 * p_l had seen it referenced somewhere when learning about continuations.
10:03:25 <Saizan> ?google genuine shift reset
10:03:26 <ddarius> @google site:lambda-the-ultimate.org shan linguistics "delimited continuations"
10:03:26 <lambdabot> No Result Found.
10:03:27 <lambdabot> No Result Found.
10:04:53 <FunctorSalad_> is it about the points where you "extract" the ContT m a a's value by passing 'return' as a cont..?
10:05:04 <FunctorSalad_> random guessing \o/
10:05:38 <ddarius> http://arxiv.org/abs/cs.CL/0404006
10:07:10 <Adamant> ddarius: you know, type stuff did make more sense to me when I started to think about it in the same terms as grammar.
10:07:32 <Adamant> like, natural language grammer, deconstructing a sentence into parts, etc.
10:07:39 <Adamant> *grammar even
10:07:41 <ddarius> And a few other papers listed on Chung-chieh Shan's publications page.
10:08:43 <FunctorSalad_> I guess it'd be better to start at the haskell or math definition without the complications of linguistics ;)
10:08:50 <ski> FunctorSalad_ : `reset :: Cont o o -> Cont p o', `shift :: ((o -> p) -> Cont p p) -> Cont p o', in terms of `Cont'
10:08:56 <FunctorSalad_> (that is not @ the people talking about linguistics specifically now)
10:11:01 <ski> in an impure language, assume we have expressions forms `reset <expr>' and `shift <var> in <expr>'
10:11:22 <dantheman_> Hey all. I have a program that calls out to c code in a dll generated in visual studio. I can complie it to a working .exe using ghc, but I was wondering if it is possible to load the dll in ghci?
10:11:31 <ski> also, assume we have `letCC <var> in <expr>' (corresponding to `callCC')
10:11:44 <ski> (for comparisions sake)
10:11:50 <ski> then, if we evaluate
10:12:05 <ski>   1 + (10 * letCC k in k 100)
10:12:13 <ski> we get `100'
10:12:53 <chrisdone> reet lads
10:13:22 <ski> > (`runCont` id) $ (1 +) `liftM` ((10 *) `liftM` callCC (\k -> k 100))  -- haskell version
10:13:23 <lambdabot>   1001
10:13:44 <Cale> I was about to say "why 100?"
10:13:50 <ski> er, of course lambdabot is right
10:14:12 <Cale> Perhaps you meant letCC k in 1 + (10 * k 100)
10:14:24 <ski> what i should have said .. what Cale wrote :)
10:14:48 <ski> > (`runCont` id) $ callCC $ \k -> (1 +) `liftM` ((10 *) `liftM` k 100)
10:14:49 <lambdabot>   100
10:14:54 <ski> also
10:15:13 <ski> > (`runCont` id) $ (1 +) `liftM` (callCC $ \k -> (10 *) `liftM` k 100)
10:15:13 <lambdabot>   101
10:15:37 <ski> so `1 + letCC k in 10 * k 100' is `101'
10:15:50 <zygoloid> dancor: what happens if you try?
10:16:23 <zygoloid> s/dancor/dantheman_/
10:16:52 <gio123> ski: hi
10:17:51 <ski> now, in `1 + letCC k in 10 * k 100', `k' represents `\x -> ..(1 + x)..' where the `....' stands for whatever we're going to do with the result of the expression (in the above case, nothing more, since we called `runCont' directly using `id' as initial continuation)
10:18:30 <ski> however, we can replace `letCC' by `shift', and use `reset' to *delimit* how large part of the surrounding computation we want to capture
10:18:52 <ski> we don't have to capture all of it, we only capture a *functional* part of it
10:18:59 <ski> in
10:19:27 <ski>   1 + reset (10 * shift c in c 100)
10:19:46 <ski> `c' is a function, namely the function `\x -> 10 * x', so calling it will return
10:19:51 <ski> if we try
10:19:56 <ski>   1 + reset (10 * shift c in c (c 100))
10:20:02 <ski> this will simplify to
10:20:17 <ski>   1 + (let c x = 10 * x in c (c 100))
10:20:19 <ski> i.e.
10:20:22 * hackagebot c2hs 0.16.2 - C->Haskell FFI tool that gives some cross-language type safety  http://hackage.haskell.org/package/c2hs-0.16.2 (DuncanCoutts)
10:20:28 <ski>   1 + (10 * (10 * 100))
10:21:15 <ski> that's the basic idea of delimited/composable continuations
10:23:11 <ski> FunctorSalad_ : that helped any ?
10:24:06 <pastorn> ski: ouch
10:24:09 <pastorn> my head...
10:24:35 <pastorn> ski: i read through the wikibooks article on MonadCunt yesterday
10:24:41 <ski> (or .. maybe you're wondering what delimited continuations are *good* for ?)
10:24:42 <pastorn> this is too much :(
10:24:43 * Kaidelong realizes he could writing his application to use a web interface instead...
10:24:58 <Kaidelong> write
10:25:05 <Cale> Of course, (`runCont` id) acts a bit like reset in that it's delimiting for us as well :)
10:25:07 <FunctorSalad_> ski: sorry I was elsewhere
10:25:32 <Cale> pastorn: Do you understand the basic idea of callCC?
10:25:38 <pastorn> Cale: yes
10:25:41 <ski> Cale : indeed, no inherent continuations in haskell that we can catch in `Cont' :)
10:26:11 <ski> Cale : also, `reset = Cont . evalCont' :)
10:26:12 <pastorn> Cale: it's like goto, but you remain you give the value given to k to the calling line of callCC
10:26:18 <pastorn> ehm.
10:26:20 <Cale> pastorn: So rather than calling the *whole* current continuation, instead you're just calling a fragment of it, out to the nearest reset
10:26:27 * pastorn rewrote that in the middle of writing it :/
10:26:51 <pastorn> Cale: is a 'reset' a usage a callCC?
10:26:56 <ski> no
10:27:02 <ski> it is a usage of `reset'
10:27:13 <ski> which is one of the basic operations of delimited continuations
10:27:17 <ski> (the other is `shift')
10:28:04 <ski> @let evalCont :: Cont o o -> o; evalCont = (`runCont`)
10:28:04 <lambdabot>   Parse error: RightParen
10:28:10 <ski> @let evalCont :: Cont o o -> o; evalCont = (`runCont` id)
10:28:11 <pastorn> ski: ok... simple question: what does delimited continuations provide that normal continuations doesn't?
10:28:11 <lambdabot>  Defined.
10:28:12 <Cale> I must admit that I haven't fully grasped what the obsession is over these things. :)
10:28:20 <ski> @let reset :: Cont o o -> Cont p o; reset = Cont . evalCont
10:28:21 <lambdabot>  <local>:15:31:
10:28:21 <lambdabot>      Occurs check: cannot construct the infinite type: o = (o...
10:28:54 <Kaidelong> Jinjing Wang chooses some interesting names for his packages
10:29:05 <Kaidelong> so far seen "loli" "maid" and "moe"
10:29:12 <Cale> There are 18 million different sorts of control operators with different magical powers, and I don't really understand why you'd want to use them for the most part :)
10:29:23 <ski> @let reset :: Cont o o -> Cont o p; reset = return . evalCont  -- oh, right
10:29:24 <lambdabot>  <local>:15:48:
10:29:24 <lambdabot>      Couldn't match expected type `p' against inferred type `...
10:29:42 <ski> @let reset :: Cont o o -> Cont p o; reset = return . evalCont  -- oh, right
10:29:43 <lambdabot>  Defined.
10:29:45 <pastorn> another continuation thing that's messing with my head:
10:30:02 <pastorn> this code is found in this article: http://matt.might.net/articles/programming-with-continuations--exceptions-backtracking-search-threads-generators-coroutines/
10:30:05 <pastorn> (define (current-continuation)
10:30:07 <pastorn>  (call/cc (lambda (cc) (cc cc))))
10:30:18 <pastorn> that seems VERY untype-safe
10:30:36 <ski> Cale : well, i don't really understand why you'd want to use anything else but `shift' and `reset' (or generalizations thereof to multiple levels of continuations)
10:31:37 <ski> @let shift :: ((o -> p) -> Cont p p) -> Cont p o; shift f = Cont (\c -> evalCont (f c))
10:31:38 <lambdabot>  Defined.
10:32:08 <ski> pastorn : that's not really that useful, afaiu
10:32:27 <ski> (if you really want, you can do that in Haskell, though, using a `newtype')
10:32:34 <fax> why (cc cc) rather than cc
10:32:37 <pastorn> i can?
10:32:57 <pastorn> won't it just be an infinite type however i do it?
10:33:04 <ski> fax is right, just `cc' is simpler
10:33:16 <killerstorm2> hey. ((+) . sum) has type [a] -> a -> a.  Is it possible to make function with signature a -> [a] -> a via function composition?
10:33:17 <Cale> Well, that's like getCC
10:33:31 <ezyang> (pseudorandom idea): type-checked "common specializations" of type signatures
10:33:39 <fax> :t sum . map (+)
10:33:40 <lambdabot> forall a. (Num (a -> a), Num a) => [a] -> a -> a
10:33:53 <Cale> It returns the continuation in which it was evaluated.
10:33:56 <fax> no that is not right
10:34:10 <ahihi> :t flip ((+) . sum)
10:34:10 <lambdabot> forall a. (Num a) => a -> [a] -> a
10:34:37 <ski>   newtype SelfCont o m = SC (forall a. SelfCont o m -> m a)
10:34:52 <pastorn> ski: you're nasty
10:34:53 <ski> pastorn : using something like that ^, it will type-check
10:34:59 <killerstorm2> ahihi: cool. I did suspect there is a function like flip...
10:35:06 <Cale> getCC = callCC (\c -> let x = c x in return x) -- it's a bit similar in purpose to this
10:35:16 <mercury^> ahihi: aka foldl (+)
10:35:28 <ski> (you don't really need the polymorphic `a' or parametric `o',`m', if you fix them, just added them for generality)
10:35:29 <ahihi> true
10:35:33 <ahihi> you probably want foldl' though
10:35:42 <mercury^> sum is defined using foldl
10:35:46 <mercury^> @src sum
10:35:46 <lambdabot> sum = foldl (+) 0
10:36:08 <pastorn> Cale: does that really evaluate to something useful?
10:36:16 <Cale> (If you have optimisations turned on, many calls to foldl will be turned into the equivalent of foldl' anyway)
10:36:18 <pastorn> it seems bottomless to me :/
10:36:22 <Cale> pastorn: Sure :)
10:36:32 <ski> pastorn : i actually had a definition like `newtype Thread = T ([Thread] -> SystemM Void)', so each thread accepts a list of all the other threads, before continuing :)
10:36:34 <Cale> @let getCC = callCC (\c -> let x = c x in return x)
10:36:35 <lambdabot>  Defined.
10:36:51 <pastorn> \c -> let x = c x <-- how can this actually become something useful?
10:37:02 <c_wraith> much the same way fix does
10:37:05 <ski> ezyang : manual or automatic ?
10:37:07 <c_wraith> @src fix
10:37:07 <lambdabot> fix f = let x = f x in x
10:37:08 <killerstorm2> mercury^: I feel dumb now...
10:37:32 <Cale> > (`runContT` return) . execWriter $ do here <- getCC; tell ["hello"]; here
10:37:33 <lambdabot>   Couldn't match expected type `[[GHC.Types.Char]]'
10:37:33 <lambdabot>         against inferred ...
10:37:37 <Cale> er, oops
10:37:44 <Cale> > execWriter . (`runContT` return) $ do here <- getCC; tell ["hello"]; here
10:37:45 <lambdabot>   No instance for (Control.Monad.Writer.Class.MonadWriter
10:37:46 <lambdabot>                    ...
10:37:47 <pastorn> Cale: would getCC get the closest 'k' that has been declared?
10:38:08 <Cale> > execWriter . (`runContT` return) $ do here <- getCC; lift (tell ["hello"]); here
10:38:09 <lambdabot>   ["hello","hello","hello","hello","hello","hello","hello","hello","hello","h...
10:38:21 <ezyang> ski: Manual, just like explicit type signatures are
10:38:22 <Cale> It's like setting a first class label
10:38:37 <pastorn> goto!
10:38:40 <Cale> exactly
10:38:46 <pastorn> nasty
10:38:49 <ezyang> but I guess there could be some use for automatic generation of these
10:38:56 <ski> ezyang : hm, isn't there a `SPECIALIZE' pragma for that in GHC ?
10:39:05 <pastorn> Cale: but isn't that only for jumping backwards?
10:39:21 <Cale> pastorn: well, yes. You have to capture the continuation before you can call it.
10:39:31 <ski> that's true of `callCC', too
10:39:36 <Cale> @let getCC' x0 = callCC (\c -> let f x = c (x, f) in return (x0, f)
10:39:36 <lambdabot>   Parse error: SemiColon
10:39:37 <ezyang> ski: Yeah, but that actually increases the space your program uses
10:39:48 <Cale> whaaaaat
10:39:55 <ski> you have to capture the continuation "on the way in", before you can jump back to the same point "now on the way out"
10:39:57 <ezyang> whereas this is more like "hey look, don't be scared by that really general type, here is a simpler version that you're probably actually interested in"
10:40:00 <Cale> @let getCC' x0 = callCC (\c -> let f x = c (x, f) in return (x0, f))
10:40:01 <lambdabot>  Defined.
10:40:05 <Cale> there we go :)
10:40:33 <ski> @type getCC
10:40:34 <ski> @type getCC'
10:40:34 <lambdabot> forall (m :: * -> *) b. (MonadCont m) => m (m b)
10:40:35 <lambdabot> forall t (m :: * -> *) b. (MonadCont m) => t -> m (t, t -> m b)
10:40:37 <pastorn> how do i do to jump 'downwards'?
10:40:52 <pastorn> is it possible?
10:40:55 <ski> hm .. that looks like the state-in-context comonad hiding in there ..
10:41:00 <c_wraith> pastorn: you pass a continuation created later back to one created earlier
10:41:17 <pastorn> c_wraith: ow! my head!
10:41:29 <wavewave> hi, i have a question on type family.
10:41:43 <Cale> > (`runCont` id) $ do (x, jump) <- getCC' 0; if x > 10 then return x else jump (x+1)
10:41:44 <lambdabot>   11
10:41:50 <pastorn> oh, oh, so 'exit0 exit1'
10:41:54 <wavewave> can type family output have some constraint?
10:41:57 <Cale> goto with parameters :)
10:42:05 <wavewave> type family Something a
10:42:30 <wavewave> then I want to have (Something a) is an instance of SomeClass..
10:42:34 <ski> ezyang : so, you're suggesting allowing type signatures that doesn't necessarily do anything else but calling the generic code directly, just for readability ?
10:42:49 <pastorn> Cale: super nasty
10:42:59 <Cale> pastorn: I don't think it's so bad :)
10:43:39 <pastorn> Cale: well, you're used to it
10:43:55 <pastorn> i only used callCC for the first time less than 24 hours ago
10:44:06 <Cale> One would hope that something like this was possible to do somehow.
10:44:21 <ezyang> ski: Yep.
10:44:36 <pastorn> Cale: something like what?
10:44:53 <ezyang> and of course, it should be compiler verified
10:45:13 <Saizan> wavewave: you can add constraints like SomeClass (Something a) to your functions
10:45:23 <Cale> pastorn: These examples with getCC and getCC'
10:45:47 <pastorn> Cale: well didn't you just run them?
10:45:49 <ski> ezyang : interesting proposal. i assume you want this so that one doesn't have to add unchecked simplified signatures in documentation
10:46:15 <wavewave> Saizan: but it's not possible to add it as a typeclass level?
10:46:22 <Cale> pastorn: I mean, it would indicate something far worse if it weren't possible to do this at all.
10:46:31 <ezyang> ski: precisely
10:46:35 <ski> maybe having compiler-checked examples of evaluation would fit in here somewhere, as well
10:46:38 <wavewave> Saizan: I mean when I define type family in typeclass.
10:46:45 <ezyang> ski: "Oh man!"
10:47:01 <Cale> I think this getCC and getCC' ought to be in Control.Monad.Cont, since they are somewhat non-obvious.
10:47:05 <ezyang> it's sort of like those Python code blocks in doc blocks. those are good ideas.
10:47:12 <ski> Cale : agreed
10:47:21 <Saizan> wavewave: you could write e.g. "class Foo (F a) => Bar a where type F a; ..."
10:47:25 <ski> (but we need a better name than "getCC'", i think)
10:47:29 <pastorn> Cale: write a patch :)
10:47:39 <pastorn> i like the
10:47:39 <wavewave> Saizan: Oh.. that's the answer I want.
10:47:46 <wavewave> Saizan: Thanks.
10:48:22 <pastorn> Cale: is getCC the correct name?
10:48:30 <glguy> labelCC :: (ContM m) => a -> m (a, Label m a)
10:48:42 <zygoloid> can you do that with a type family, or do you need an associated type to add a context?
10:48:42 <Cale> pastorn: I think so
10:48:44 <wavewave> Saizan: I just thought something like "class Bar a where type (Foo (F a)) => F a ; "
10:48:47 <glguy> jump :: (ContM m) => a -> Label m a -> m b
10:48:49 <Cale> It gets the current continuation
10:49:29 <Cale> glguy: I don't see what the deal is with the separate Label type
10:49:38 <glguy> more polymorphism
10:49:45 <glguy> you get to pick a new 'b' every time you use it
10:49:52 <pastorn> Cale: i would claim that the 'current continuation' is the 'k' that was last declared
10:49:56 <ski> it gets an action, that when executed, will invoke the current continuation, thereby letting `getCC' return again (with the same action)
10:50:11 <glguy> :t getCC
10:50:12 <lambdabot> forall (m :: * -> *) b. (MonadCont m) => m (m b)
10:50:13 <pastorn> Cale: but then i don't fully grasp all tis yet
10:50:28 <glguy> forall (m :: * -> *) (MonadCont m) => m (forall b. m b)
10:50:32 <Cale> pastorn: It gets its *own* current continuation
10:50:49 <ezyang> Actually, we really don't have any excuse for not doing this, seeing that most of our functions are pure by default
10:50:50 <bastl> Is there a way to let vacuum, preferably vacuum-cairo, also print the types of the constructors?
10:50:55 <ski> Cale : yes, but the `b' ought to be polymorphic on each *use* of the returned action
10:51:04 <Cale> pastorn: (which of course, has to be some sort of fixed point, since its own current continuation is going to include calls back to itself)
10:52:01 <Cale> glguy: Oh, I see, it's because lambda bindings are monomorphic.
10:52:25 <Cale> (at least, normally)
10:52:36 <Cale> So you need some extra machinery to work around that :)
10:53:42 <ski> ezyang : how about writing like `{-# TESTCASES Just 3 = lookup 2 [(2,3)] #-} e.g., the idea being that that translates to `case lookup 2 [(2,3)] of Just 3 -> ..ok..; _ -> ..bad..' ?
10:54:34 <ski> (so it looks like a value binding in a `let', only that it is matching strictly)
10:54:38 <pastorn> Cale: how do you get new code into the standard libraries?
10:55:08 <pastorn> it's through the 'mtl' library, right?
10:55:50 <ski> (ezyang :) maybe not so related, but if we ever get something like JohnMeacham's superclass proposal, it would be nice if one could *generalize* the type of members in a superclass, and not just remove members
10:56:14 <Cale> pastorn: If I knew how to do it unilaterally, the standard libraries would look a bit different ;)
10:56:38 <ski> there's a possible problem with ambiguity, but maybe one could require that the tightest available constraints that make the code type-check should be used
10:57:03 <FliPPeh> Is there a function to check if a list contains an item, with a predicate?
10:57:23 * ski wonders how to ensure the unicity of that, and how costly it would be to check
10:57:25 <Cale> not . null . filter p
10:57:34 <FliPPeh> elemWith (\(x,y) -> x == 4) [(5,3), (2,8)]
10:57:36 <FliPPeh> For example
10:57:46 <Cale> FliPPeh: ^^
10:57:51 <Cale> or any
10:57:54 <Cale> any p
10:58:01 <FliPPeh> Thanks Cale :)
10:58:13 <FliPPeh> @src any
10:58:13 <lambdabot> any p =  or . map p
10:58:15 <FliPPeh> Heh
10:58:24 <pastorn> are there any plans to rewrite the Num class? to i.e. an Additive class and a Multiplicative class?
10:58:36 <pastorn> (algebra-like stuff)
10:58:41 <Cale> There are lots of ways to put such a function together ;)
10:58:53 <dschoepe> pastorn: http://hackage.haskell.org/package/numeric-prelude-0.1.3.4
10:59:24 <Cale> dschoepe: It's too bad that numeric-prelude is infected with the Henning-sabotage
10:59:57 <Cale> Which reminds me, I should keep working on my tool for automagically removing Henning's convention.
11:00:22 <pastorn> Cale: henning-sabotage?
11:00:29 <Cale> He names all his types T and all his typeclasses C, and it makes the documentation impossible to read, and forces people to use qualified imports.
11:00:43 <ski> Cale : will you make a converse as well, and ensure that you've got a retract situation ? ;)
11:01:39 <Cale> ski: Actually, there's a bit of a problem with even just this direction because of the fact that types and typeclasses (for some stupid reason) live in the same namespace.
11:02:33 <Cale> So if any module happens to define both M.T and M.C, I already run into the problem that I can't rename them both to M.M
11:03:48 <bastl> Hmm, does vacuum know about the types of the values it dumps ?
11:04:05 <Cale> So what I think I'm going to do is split it into two programs: one will collect a list of the henningisms, along with what their default renamings would be, and then you can sift through and edit it, and then the other tool will take such a list of renamings and apply them throughout the code.
11:04:12 <ski> Cale : sometimes i think of type-classes as having kinds, like `MonadPlus :: (m :: * -> *) -> Monad m => class'
11:04:55 <Cale> bastl: I'm not 100% sure, but I don't think it could.
11:05:12 <Cale> (unless it's using new ghci-debugger magic)
11:06:38 <ski> @type let x :: MonadPlus Tree => (); x = () in x
11:06:39 <lambdabot>     No instance for (MonadPlus Tree)
11:06:39 <lambdabot>       arising from a use of `x' at <interactive>:1:41
11:06:39 <lambdabot>     Possible fix: add an instance declaration for (MonadPlus Tree)
11:07:01 <ski> (so that would then be thought of as a kind error, sortof)
11:09:02 <wavewave> is type-level dot (function composition) possible?
11:09:07 <wavewave> just curious.
11:09:22 <wavewave> type family F a
11:09:24 <wavewave> data G a
11:09:32 <wavewave> (F . G)  a
11:09:54 <wavewave> I just checked it's not possible. but something similar must be useful..
11:09:55 <fax> wavewave: huh ?
11:10:28 <c_wraith> . does not compose kinds, it's true
11:10:38 <fax> . doesn't exist
11:10:42 <Cale> (or types)
11:11:06 <wavewave> so i just suggest :)
11:11:16 <pastorn> hmm... is there any performance to be gained on writing your code in CP style?
11:11:28 <pastorn> *gained by*
11:11:44 <bastl> is there an accessible introduction to type-level programming ?
11:11:48 <wavewave> if the type level namespace is strictly split from value level,
11:12:01 <wavewave> then maybe we can use (.) ($)... something like that.
11:12:07 <fax> accessible to whom
11:12:11 <bastl> to me :-)
11:12:19 <fax> um
11:12:24 <fax> I guess I don't know you that well
11:12:29 <fax> so I can't really suggest anything
11:12:45 <Cale> read the HList paper, maybe
11:13:28 <Nebasuke> bastl: you could try some of the slides of the AFP course I did
11:13:33 <Nebasuke> http://www.cs.uu.nl/wiki/bin/view/Afp/CourseSchedule
11:13:42 <fax> wavewave http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25010#a25010
11:14:34 <fax> wavewave, it is utterly useless though since we cannot leave out x
11:14:35 <Nebasuke> and then especially lecture 10 and 11 (and 12 for agda)
11:14:47 <fax> wavewave, i.e. we can't define data X f where X :: X (C F G)
11:14:48 <wavewave> fax: hmm interesting..
11:15:08 <fax> wavewave, so all this really does is give us another [longer] way to write F (G x)
11:15:16 <wavewave> fax: it's partial application..
11:15:19 <fax> ?
11:15:26 <wavewave> fax: ahh.. not?
11:15:37 <fax> What I am saying is you cannot partially apply it like in the X example
11:16:12 <chrisdone> ohh i think i'll try out happstack tonight
11:16:23 <chrisdone> specifically happstack-state
11:16:29 <wavewave> fax: my mind is boggling.... :)
11:16:51 <fax> wavewave: The reason GHC doesn't let you do that is because you can start to do some really interesting programming if it was allowed
11:17:22 <wavewave> fax: hmm? what does it mean?
11:17:40 <wavewave> fax: ghc is rather on conservative side? you mean
11:17:42 <wavewave> ?
11:17:52 <fax> yes
11:18:00 <wavewave> understandable..
11:18:19 <wavewave> this must be a kind of nightmare for implementer. ;-)
11:18:26 <wavewave> although it's fun.
11:19:00 <ski> (ddarius : btw, re descriptions, when i looked at a discussion of that in a book some time ago, they explained (iirc) `P (iota x. Q x)' as either possibly being `exists x. P x /\ Q x' or being `forall x. P x => Q x' (or maybe a combination thereof) (neither being "stable" under negations, e.g.), whereas i'd prefer `P (iota x. Q x)' to not be well-formed when there is no unique `x' such that `Q x' ..)
11:19:57 <ski> (ddarius : .. so, do you have any suggestion of what to read on descriptions ? (apart from that Taylor paper, which i will read of course))
11:20:01 <bastl> Nebasuke: exactly what I was looking for ...
11:20:04 <bastl> thanks.
11:20:21 <bastl> well, a textbook on the subject would be even better ...
11:21:15 <ski> wavewave : if it was allowed, you could probably get the type-checker into loops
11:22:48 <Nebasuke> bastl: an interesting paper for you might be "fun with type functions": http://haskell.org/haskellwiki/Simonpj/Talk:FunWithTypeFuns
11:24:11 <wavewave> ski: you mean undecidable things?
11:24:43 <ski> e.g., yes
11:25:54 <absz> Hi.  I just installed the Haskell Platform on my Mac (running OS X 10.5.8), and when I run cabal, I get the error "dyld: unknown required load command 0x80000022".  Googling turns up http://bit.ly/9RUBPD , where it's implied that the best solution is to download cabal and build it myself.  However, it's not entirely clear, and I was wondering if there was a better option.
11:34:39 <dons> absz: ah interesting.
11:34:54 <dons> absz: that's probably a good plan -- rebuild cabal, and add notes to the bug report ticket
11:36:10 <absz> dons: OK, I'll do that.  It shouldn't be too bad to rebuild cabal (and having a laptop without Haskell just feelsâ€¦Â wrong :-P)
11:36:55 <dons> heh
11:37:07 <dons> sorry about the bug, we're still trying to make sure every platform has identical functionality
11:38:20 <absz> thanks for the help
11:41:29 <ralph__> I'm installing drift.
11:41:32 <ralph__> Has anyone used that?
11:43:41 <gwern> ralph__: I cabalized it. but no, never actually used it except for apps that needed it like jhc
11:43:47 <aavogt> I've used derive
11:45:41 <ski> paulvisschers : btw, (looking closer at that paste), i'm not sure that those `liftSnd',`liftLeft',`liftList' are that useful/good
11:45:53 <pastorn> What are parsers that are deep (inspectable) called?
11:45:58 <absz> dons: Just FYI, neither happy nor alex works (same error), but haddock, GHC, GHCi, and hsc2hs all do.
11:47:33 <ski> paulvisschers : if you have a function `\m -> m >>= ...' of type `m a -> m ...', why not just use `...' with type `a -> m ...' instead (using `(>>=)' at call sites instead) ?  .. except in the situation where you must conform to an existing interface
11:48:04 * hackagebot haskore 0.1.0.3 - The Haskore Computer Music System  http://hackage.haskell.org/package/haskore-0.1.0.3 (HenningThielemann)
11:48:28 <tromp_> @src scanl
11:48:28 <lambdabot> scanl f q ls = q : case ls of
11:48:28 <lambdabot>     []   -> []
11:48:28 <lambdabot>     x:xs -> scanl f (f q x) xs
11:48:33 <ski> paulvisschers : what i'm thinking is that implementing `liftSnd :: (Monad m) => (m a -> m b) -> m (a,c) -> m (b,c)' such that the function argument always get an action of form `return a' as argument is not really that good/useful
11:49:29 <ski> paulvisschers : ideally, we'd like the effects of the `m (a,c)' argument to happen whenever the `m a -> m b' executes its argument, i think
11:50:13 <pastorn> ghc runs in haiku?
11:50:33 <EvanR-work> :t error
11:50:34 <lambdabot> forall a. [Char] -> a
11:50:59 <ski> paulvisschers : i'm not claiming that is necessarily possible here, though .. just that you should not just consider how to implement the operations of `MonadTransformer' type-correctly, but also consider reasonable laws they should support, and check that instances support them
11:51:16 <ralph__> gwern, Well, thanks for cabalizing it.
11:52:17 <ski> (for interested bystanders, the paste in question is <http://pastebin.com/uLdhxHWF>)
11:52:27 <gwern> ralph__: are you actually using the cabalized version?
11:53:30 <pastorn> i'm reading the GHC 6.12.2 release notes... what's meant by
11:53:33 <pastorn>     *
11:53:35 <pastorn>       Importing qualified names is now an error.
11:53:58 <gwern> I think it means you can no longer write 'import Foo as Bar (Bar.quux)'
11:53:59 <pastorn> is the keyword 'qualified' deprecated now?
11:54:02 <gwern> but don't hold me to it now
11:54:08 <gwern> *qualified
11:54:14 <EvanR-work> yes, import qualified is now deprecated ;)
11:54:21 <pastorn> EvanR-work: :p
11:54:29 <gwern> EvanR-work: you speak lies with a forked tongue!
11:54:29 <EvanR-work> you must use the full path
11:54:47 <pastorn> EvanR-work: what was allowed before and how must it look now?
11:55:02 <EvanR-work> Data.ByteString.Lazy.etc.etc.etc
11:55:06 <paulvisschers> ski: you might be right
11:55:08 <gwern> {{fact}}
11:55:21 <EvanR-work> it will look just like java
11:55:25 <EvanR-work> which is very innovative
11:55:34 <pastorn> EvanR-work: import Graphics.UI.Swing.*
11:55:37 <pastorn> :D
11:56:24 <EvanR-work> you can get arounds this slight inconvenience by using names that arehard to collide, like pleaseDistributeTheThingamagjicCarefully method
11:57:06 <pastorn> EvanR-work: import qualified Data.ByteString.Lazy as BS <-- could you change this into something that's no longer allowed?
11:57:29 <EvanR-work> thats not allowed
11:57:34 <pastorn> WAT?
11:57:42 * pastorn is never upgrading
11:57:57 <EvanR-work> i havent said a true thing this whole time
11:58:02 <pastorn> so 'as X' is what's no longer allowed?
11:58:06 <paulvisschers> ski: Ah right I understand what you mean now
11:59:45 <gwern> pastorn: you're so adorable. can I take you home?
12:00:03 <pastorn> gwern: fagg u :p
12:00:16 <pastorn> seriously, i never got a clear answer
12:00:28 <gwern> pastorn: you did see my comments to EvanR-work no?
12:00:29 <paulvisschers> ski: Are you sure that this is a problem in this case though?
12:00:44 <EvanR-work> pastorn: that change log message is indeed hilarious
12:00:46 <Twey> pastorn: 19:53:34 < gwern> I think it means you can no longer write 'import Foo as Bar (Bar.quux)'
12:01:49 <pastorn> Twey: what gwern said there is a bit ambiguous; it's not clear if it's 'as Bar' or '(Bar.quux)' that's no longer allowed
12:01:59 <Twey> pastorn: It's the â€˜Bar.quuxâ€™ bit.
12:02:09 <Twey> Should just be â€˜import Foo as Bar (quux)â€™
12:02:27 <pastorn> oh, cool
12:02:58 <Twey> Of course they're not going to forbid qualified imports or randomly change the syntax for something that's established and used in half the packages on Hackage.  Common sense, person.  ;)
12:03:04 * gwern was very surprised the first time I saw that Bar.quux was valid
12:03:26 <EvanR-work> :t undefined
12:03:27 <lambdabot> forall a. a
12:07:11 * hackagebot hfiar 1.0.1 - Four in a Row in Haskell!!  http://hackage.haskell.org/package/hfiar-1.0.1 (FernandoBenavides)
12:11:08 <EvanR-work> whats the smart way to do  foo >>= return . f >>= bar
12:11:40 <paulvisschers> liftM f foo >>= bar?
12:11:47 <FliPPeh> let if' p t e = if p then t else e
12:11:52 <FliPPeh> Anything like this in prelude?
12:12:02 <FliPPeh> An inline if without special syntax?
12:12:04 <EvanR-work> pastorn: ah
12:12:12 <EvanR-work> :t liftM
12:12:13 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
12:12:34 <ski> paulvisschers : i suspect it is
12:12:51 <ski> (.. but i'm too tired to consider it properly, atm)
12:12:58 <paulvisschers> ski: Me too
12:13:26 <EvanR-work> paulvisschers: does this harm readability?
12:13:54 <Twey> FliPPeh: Sadly no
12:14:04 <tromp_> how to ask for point free definition again?
12:14:06 <ski> EvanR-work : `bar =<< liftM f foo'
12:14:16 <ski> @pl pointless x = x
12:14:16 <lambdabot> pointless = id
12:14:18 <EvanR-work> :t =<<
12:14:19 <lambdabot> parse error on input `=<<'
12:14:21 <ski> @pl \x -> x
12:14:21 <lambdabot> id
12:14:23 <EvanR-work> :t (=<<)
12:14:24 <Twey> EvanR-work: But in the HigherOrder package, (??) is defined ((y ?? n) p = if p then y else n)
12:14:24 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
12:14:26 <FliPPeh> Twey: About time!
12:14:30 <Twey> Er, FliPPeh**
12:14:33 <tromp_> @pl (\s t -> retail t (tail s))
12:14:33 <lambdabot> flip retail . tail
12:14:37 <ski> EvanR-work : `(=<<) = flip (>>=)'
12:14:48 <FliPPeh> > let if' p t e = if p then t else e in if' True 42 55
12:14:49 <paulvisschers> ski: But those functions were never meant to be used in a generally, so if they are okay here, there's no harm
12:14:49 <lambdabot>   42
12:14:53 <FliPPeh> > let if' p t e = if p then t else e in if' False 42 55
12:14:53 <EvanR-work> i was about to ask for a flip liftM
12:14:54 <lambdabot>   55
12:15:12 <tromp_> thx
12:15:23 <Twey> :t ?f <$> ?bar >>= baz
12:15:24 <lambdabot> Not in scope: `baz'
12:15:26 <paulvisschers> EvanR-work: f `liftM` foo >>= bar might be more readable
12:15:27 <Twey> :t ?f <$> ?bar >>= ?baz
12:15:28 <lambdabot> forall a a1 (m :: * -> *) b. (?f::a -> a1, ?bar::m a, Functor m, ?baz::a1 -> m b, Monad m) => m b
12:15:34 <Twey> :t (?f <$> ?bar) >>= ?baz
12:15:35 <lambdabot> forall a a1 (m :: * -> *) b. (?f::a -> a1, ?bar::m a, Functor m, ?baz::a1 -> m b, Monad m) => m b
12:15:37 <Twey> Oh good
12:15:47 <ski> paulvisschers : i'm suspecting, that with a reasonable law for `mapLift', the instances that uses those will not be correct
12:15:49 <EvanR-work> paulvisschers: its still weird since foo 'happens first'
12:15:52 <Twey> Then, f <$> foo >>= bar
12:16:06 <paulvisschers> fmap, (<$>) and liftM are all the same function, but with different class restrictions
12:16:17 <xerox> ?type (.) -- too
12:16:18 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:16:58 <Twey> EvanR-work: â€˜foo >>= return . barâ€™ = â€˜liftM bar fooâ€™ = â€˜fmap bar fooâ€™ = â€˜bar <$> fooâ€™, forall foo bar.
12:17:51 <ski> EvanR-work : you can also use `foo >>= (f >>> bar)' ..
12:17:59 <paulvisschers> and apparently also bar . foo :)
12:18:30 <bastl> hmm, vacuum-cairo segfaults ...
12:18:33 <EvanR-work> well not im getting liftM and fmap
12:18:38 <EvanR-work> now*
12:18:52 <wvd> If I want to be able to embed Haskell code in other languages - what would be the best aproach(es)?
12:19:07 <paulvisschers> fmap is a generalization of map
12:19:15 <ski> paulvisschers : actually, `(<$>)' has the same type as `fmap'
12:19:51 <paulvisschers> ski: I know, luckily they did it correct there
12:19:55 <EvanR-work> i decided to do x <- foo; bar $ f x
12:19:58 <EvanR-work> er
12:20:06 <EvanR-work> something
12:20:29 <bastl> gtg, good night everyone.
12:20:41 <ski> (EvanR-work : ymmv, but i would not use `$', unless possibly if `f' is really a big expression)
12:21:05 <EvanR-work> look at what i just wrong, i wrote bar (f x) instead
12:21:07 <paulvisschers> EvanR-work: that is definitely prettier
12:21:09 <siracusa> wvd: You want to use Haskell in conjunction with other languages, or you want to embed Haskell code say in C++ code?
12:21:21 <wvd> siracusa: Second, if possible.
12:21:29 <ClaudiusMaximus> wvd: you can mix haskell with C quite easily, just need to start the haskell runtime if your main is C not Haskell, and i used hsplugins for one project of mine (which has now bitrotted), i think there are other options now (GHC API, hint (?), ...)
12:22:00 <paulvisschers> Anyway I'm off, ski we can talk about this some more later if you like
12:22:32 <ClaudiusMaximus> i meant my project bitrotted, don't know about hsplugins
12:22:37 <wvd> ClaudiusMaximus: The language is not in C/C++ actually, but I could write some DLL and call functions from that.
12:24:52 * EvanR-work shudders at C++
12:25:13 <EvanR-work> if you value your life you use C as the glue
12:27:00 <Twey> :t ?foo >>= ?bar >>> ?baz
12:27:01 <lambdabot>     Precedence parsing error
12:27:01 <lambdabot>         cannot mix `>>=' [infixl 1] and `>>>' [infixr 1] in the same infix expression
12:27:03 <Twey> Ew
12:27:59 <ClaudiusMaximus> wvd: it's been a while since i used it, but you can "foreign export" functions from haskell to C, and "foreign import wrapper" (iirc) to get a factory for making function pointers from haskell functions
12:29:37 <siracusa> wvd: I'm still not sure if we mean the same thing, that would require a special parser for that other language, wouldn't it?
12:30:17 <wvd> siracusa: It wouldn't really, just call a function to eval line N to M using the Haskell interpreter or whatever.
12:31:19 <EvanR-work> except you cant eval lines in haskell, you have to evaluate an expression
12:34:27 <siracusa> wvd: So you could call `ghc -e expr' to evaluate the expression expr, if this is what you want.
12:34:59 <wvd> siracusa: Yeah, but I'm more looking for an 'interactive console', so if I define something it's possible.
12:35:06 <wvd> But it's hard.
12:35:59 <EvanR-work> i would like to see a standalone one of these
12:36:05 <EvanR-work> interactive console that lets you define stuff ;)
12:36:42 <siracusa> GHCi is interactive and lets you define things!?
12:36:54 * siracusa is confused
12:37:15 <EvanR-work> with special commands?
12:37:47 <siracusa> You can do :def command IIRC
12:37:59 <ClaudiusMaximus> mixing code of different languages in one source file is possible, i think i managed to get a file be compiled as both .c and .lhs once, with some help from here
12:38:01 <wvd> siracusa: but 'ghc -e let a = [1, 3]', if I do 'ghc -e' again, e is not found?
12:38:12 <wvd> ClaudiusMaximus: I did it with Python/TCL/Ruby already.
12:38:13 <EvanR-work> then maybe wvd wants a ghci
12:38:26 <siracusa> wvd: Ah, I see
12:38:27 <EvanR-work> with a :def command
12:38:46 <wvd> siracusa: Python e.g. has the C api or the InteractiveConsole module
12:39:16 <EvanR-work> wvd: haskell interactive consoles dont let you let a = b like that and have it be permanent
12:39:21 <EvanR-work> let is for local definitions
12:39:42 <EvanR-work> > let x = 5 in x
12:39:42 <lambdabot>   5
12:39:45 <EvanR-work> > x
12:39:46 <lambdabot>   x
12:39:48 <wvd> EvanR-work: If you do "let" in ghci you can still access it.
12:39:59 <wvd> I'm looking for global variables iirc.
12:40:06 <EvanR-work> it does? then it seems you are in an invisible do block
12:40:20 <EvanR-work> > do let x = 5; x
12:40:21 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
12:40:27 <wvd> Prelude> let a = 5
12:40:27 <wvd> Prelude> a
12:40:27 <wvd> 5
12:40:41 <siracusa> but only for that session
12:40:45 <wvd> true.
12:40:47 <EvanR-work> yeah, but you cant define data types
12:40:54 <wvd> yeah
12:41:09 <wvd> Maybe I could treat it as a text file.
12:41:41 <EvanR-work> my idea was for the 'interpreter' to be a text area, you can change any part of it, including top level definitions, 'run' is to reinterpret the whole file
12:42:09 <EvanR-work> and it evaluates main
12:42:11 <wvd> The embedded Python code works like:
12:43:00 <siracusa> yeah, collect all definitions and merge them into a single file, then main = the main expression and finally ghc -e main
12:43:05 <wvd> Use some function which is the startpoint of the python code, define the python code, use a function which is the end point of the Python code. Eval the identifiers of mIRC first, send all lines between the functions to the interpreter and see what it returns.
12:44:12 <DigitalKiwi> wait people still use mIRC?
12:44:26 <wvd> DigitalKiwi: It's by far the most popular IRC client.
12:44:37 <wvd> (On windows)
12:44:42 <DigitalKiwi> irssi > weechat > xchat > mirc
12:44:58 <wvd> Irssi/weechat/xchat > not for Windows.
12:45:04 <wvd> Well, XCHat is.
12:45:06 <DigitalKiwi> xchat is on windows
12:45:07 <DigitalKiwi> nub
12:45:08 <DigitalKiwi> ;p
12:45:27 <wvd> Many people tend to laugh at mSL.
12:45:33 <wvd> But it was good where it was designed for.
12:45:52 <EvanR-work> > last ([0..] :: [Int])
12:45:56 <lambdabot>   mueval-core: Time limit exceeded
12:45:56 <DigitalKiwi> mSL?
12:46:02 <wvd> mIRC Scripting Language
12:46:03 <DigitalKiwi> and you can use irssi and weechat on windows
12:46:18 <wvd> DigitalKiwi: Under Cygwin?
12:46:23 <ClaudiusMaximus> > last ([0..] :: [Word16])
12:46:24 <lambdabot>   65535
12:46:26 <chrisf> mSL is horrible :(
12:46:37 <EvanR-work> > last ([0..] :: [Word32])
12:46:40 <lambdabot>   mueval-core: Time limit exceeded
12:46:45 <DigitalKiwi> http://irssi.org/
12:46:52 <DigitalKiwi> ctrl+f windows
12:46:53 <wvd> chrisf: Why?
12:47:02 <DigitalKiwi> and yes if nothing else there is cygwin >.>
12:47:16 <wvd> DigitalKiwi: Wait.. irssi for Windows, that would be actually amazing..
12:47:16 <EvanR-work> what is the maximum length of a list?
12:47:41 <EvanR-work> @src length
12:47:41 <lambdabot> Source not found. Sorry.
12:47:43 <ClaudiusMaximus> :t length
12:47:47 <lambdabot> forall a. [a] -> Int
12:47:53 <ClaudiusMaximus> :t genericLength
12:47:57 <lambdabot> forall b i. (Num i) => [b] -> i
12:48:08 <chrisf> either run irssi directly on windows, or run it on a *nix box somewhere and use ssh+screen
12:48:10 <EvanR-work> so there is no max
12:48:18 <EvanR-work> but length will fail for a very long list
12:48:22 <wvd> chrisf: I'm happy with mIRC.
12:48:26 <DigitalKiwi> weechat you have to use cygwin still it looks like
12:48:59 <ClaudiusMaximus> > genericLength [1..1000] :: Word8
12:49:00 <DigitalKiwi> so you paid the 30 dollars or you are a leech who doesn't pay for shareware? :P
12:49:00 <lambdabot>   232
12:49:07 <wvd> DigitalKiwi: I paid 30 dollars.
12:49:22 <wvd> DigitalKiwi: Been using it for 6 happy years.
12:49:24 <DigitalKiwi> i should have stated first that either way you're an idiot ;D
12:49:34 <DigitalKiwi> jk
12:49:35 <DigitalKiwi> kind of
12:49:39 <EvanR-work> > genericLength [1..1000] :: Integer
12:49:40 <lambdabot>   1000
12:49:51 <Mathnerd314> what?
12:50:06 <Mathnerd314> > genericLength [1..1000] :: Double
12:50:07 <lambdabot>   1000.0
12:50:14 <wvd> DigitalKiwi: I paid $40 for the dragon book which I haven't read 100 pages of it yet :P
12:50:20 <wvd> So mIRC was a better investment
12:50:26 <DigitalKiwi> what is the dragon book?
12:50:42 <chrisf> http://en.wikipedia.org/wiki/Dragon_Book_(computer_science)
12:51:18 <wvd> About compilers and such
12:51:54 <DigitalKiwi> ah
12:52:04 <wvd> It's really -complex-
12:52:21 <wvd> But I'm just a newbie who programs for 4 years so I don't wonder why it's :P
12:53:10 <lowSodium> haskell98 states that a program must be called Main and export a value main, is that really the case?  It seems as though ghc doesn't need a Main or to have the main value explicitly exported
12:53:23 <thoughtpolice> there are better introduction books than the dragon book for compiler writing IMO
12:53:42 <EvanR-work> genericLength for the win
12:53:52 <RichardBarrell> There aren't any others with giant pictures of dragons on them, though.
12:53:53 <olsner> lowSodium: if you don't specify a module name yourself, the default is "module Main (main) where"
12:54:04 <wvd> thoughtpolice, i also bought the ANTLR book by terence parr & about DSL's
12:54:21 <thoughtpolice> wvd: http://www.amazon.com/Engineering-Compiler-Keith-Cooper/dp/155860698X
12:54:25 <thoughtpolice> that book is great
12:54:59 <thoughtpolice> very practical introduction and it covers a large swath of information regardless
12:55:11 <thoughtpolice> if you're feeling daring afterwords you can try steven muchnick's book, but it is highly advanced
12:55:42 <lowSodium> olsner: then the file name doesn't need to match the module name "Main", is that right?
12:56:07 <wvd> thoughtpolice: well, the dragon book is about a lot more then just compilers imo
12:56:11 <olsner> lowSodium: yeah, that's right
12:56:38 <lowSodium> that's confusing, Haskell98 makes it seem a lot more strict than it actually is
12:57:16 <EvanR-work> > map (-1) [1,2,3,4]
12:57:17 <lambdabot>   No instance for (GHC.Num.Num (a -> b))
12:57:17 <lambdabot>    arising from a use of syntactic n...
12:57:18 <olsner> the module you compile would still be Main exporting main, it just happens to be contained in a file with a different name
12:57:20 <EvanR-work> > map (- 1) [1,2,3,4]
12:57:21 <lambdabot>   No instance for (GHC.Num.Num (a -> b))
12:57:21 <lambdabot>    arising from a use of syntactic n...
12:57:27 <EvanR-work> :(
12:57:38 <EvanR-work> > map (+-1) [1,2,3,4]
12:57:39 <lambdabot>   Not in scope: `+-'
12:57:43 <EvanR-work> > map (+ -1) [1,2,3,4]
12:57:44 <lambdabot>   The operator `GHC.Num.+' [infixl 6] of a section
12:57:44 <lambdabot>      must have lower prece...
12:57:53 <olsner> @ty subtract
12:57:54 <lambdabot> forall a. (Num a) => a -> a -> a
12:58:06 <EvanR-work> > map (-(1)) [1,2,3,4]
12:58:06 <lambdabot>   No instance for (GHC.Num.Num (a -> b))
12:58:07 <lambdabot>    arising from a use of syntactic n...
12:58:14 <olsner> > map pred [1,2,3,4]
12:58:14 <EvanR-work> > map (subtract 1) [1,2,3,4]
12:58:15 <lambdabot>   [0,1,2,3]
12:58:15 <lambdabot>   [0,1,2,3]
12:58:20 <thoughtpolice> wvd: it's pretty compiler oriented just by looking at the TOC - what are you referring to?
12:58:35 <EvanR-work> > pred 5
12:58:36 <lambdabot>   4
12:59:00 <olsner> the dragon book has a lot of material on lexing and parsing, but that's very much compiler related imo
12:59:24 <thoughtpolice> olsner: well, pretty much any book on compilers contains a few chapters on lexing, parsing and semantic analysis
12:59:31 <thoughtpolice> torczon & cooper's book does as well
12:59:57 <olsner> wvd: so what parts of the dragon book did you find unrelated to compilers?
13:00:10 <wvd> olsner: well, it looks like it spend pretty much time on parsing.
13:00:15 <orlandu63> > (- 1)
13:00:16 <lambdabot>   -1
13:00:18 <wvd> where I'm much more interested in the thing behind it.
13:00:18 <orlandu63> > (-1)
13:00:19 <lambdabot>   -1
13:00:24 <orlandu63> > ((-) 1)
13:00:25 <lambdabot>   {-3->4;-2->3;-1->2;0->1;1->0;2->-1;3->-2}
13:00:29 <wvd> Parsing is just at hwo your language looks like
13:00:40 <fax> wvd: this is a very old book
13:00:42 <thoughtpolice> wvd: right, but like I said almost any compiler book has a chapter or two about things like that, so it's not really special
13:00:49 <fax> wvd:  would only read it for historical intrest
13:01:01 <wvd> fax: last version is 10 years ago probably?
13:01:04 <thoughtpolice> also, parsing/syntax is a very important part of a language even if a compiler book makes it out to be dull and boring
13:01:05 <olsner> the new edition is from 2006 iirc
13:01:07 <wvd> thoughtpolice: It has 5/6?
13:01:14 <wvd> idd
13:01:26 <olsner> http://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools#Second_edition <-- yep, 2006
13:01:28 <wvd> Well, i've just been programming for 4 years, but I'm just exploring.
13:01:42 <shapr> Programming is good!
13:01:56 <fax> so is mash
13:02:49 <orlandu63> does darcs have a haskell api?
13:03:17 <thoughtpolice> orlandu63: yes, you can use darcs as a library
13:03:48 <wvd> But most modern languages use AST's?
13:04:01 <thoughtpolice> wvd: yep
13:04:23 <wvd> I've made a simple DSL
13:04:36 <wvd> Book looks interesting
13:05:15 <wvd> Anyway, g2g.
13:08:15 <FunctorSalad_> ski: (better late than never, thanks for trying to explain) I'll have to parse that slowly; I haven't even completely wrapped my mind around vanilla callCC
13:08:50 <gwern> I find continuations harder than monads. I wonder if I'm alone in that
13:08:54 <FunctorSalad_> ski: (I had gone afk, then returned to other channels)
13:09:07 <olsner> gwern: nope, you're not alone in that
13:09:55 <FunctorSalad_> gwern: me too, but then, I didn't know any scheme beforehand, but I had seen monads in CT ;)
13:16:57 <EvanR-work> im using printf to format log messages, do you recommend another way
13:17:19 <gwern> EvanR-work: use a bunch of ++s!
13:17:43 <EvanR-work> seriously?
13:17:55 <mauke> I'd rather use printf
13:18:08 <gwern> EvanR-work: if ghc can forbid qualified imports, the rest of us can forbid printf
13:18:25 <Gracenotes> ..ghci?
13:19:36 <gwern> Gracenotes! you lack... context.
13:19:52 <EvanR-work> indeed!
13:20:40 <FunctorSalad_> use Printf-TH
13:20:44 <FunctorSalad_> best of both worlds.
13:20:45 <Gracenotes> gwern: 1 out of 2 conversationalists say context isn't needed for productive discussion!
13:21:05 <gwern> Gracenotes: you are weak. do you know why you are weak? because you lack hatred^Wcontext
13:21:07 <FunctorSalad_> make a snippet in your editor so you don't have to type the awkward ($printf "bla=%s")
13:21:17 <FunctorSalad_> printf-th is so underhyped
13:21:27 <EvanR-work> :S
13:21:28 <FunctorSalad_> $(printf ...) actually
13:21:29 <aavogt> FunctorSalad_: use the CPP to hide the $( )!
13:21:43 <FunctorSalad_> aavogt: hehe
13:21:50 <FunctorSalad_> or that
13:22:04 <EvanR-work> wheres perl when you need it
13:22:26 <gwern> template-haskell instead of runtime printf. why settle for the *lesser* of two evils/
13:22:59 <FunctorSalad_> because it's a lot more concise than ++?
13:23:24 <FunctorSalad_> printf-th even saves you the 'show', by virtue of its %H fstr
13:23:39 <aavogt> TH is unportable
13:24:06 <gwern> unportable, hell, it's unreliable
13:24:12 <FunctorSalad_> ?
13:24:15 <thoughtpolice> unportable? sure. realistically? show of hands of how many people are actively using a compiler that doesn't support template-haskell?
13:24:37 <FunctorSalad_> and in case of emergency you can just compile down to plain haskell on linux
13:24:47 <FunctorSalad_> then compile on the other box
13:24:49 <aavogt> FunctorSalad_: how do you do that?
13:25:04 <FunctorSalad_> aavogt: there's a util 'zeroth' or so
13:25:10 <gwern> aavogt: there's probably an 'emit intermediate results' option
13:25:18 <FunctorSalad_> aavogt: maybe a ghc flag too? -ddumps-splices kinda does it, but just the splices
13:25:20 <aavogt> there is -ddump-splices, gwern
13:25:24 <thoughtpolice> i'm willing to bet it's close to 0 people using any other compiler in any sort of serious environment, sans perhaps nhc or something on an embedded system
13:25:35 <gwern> FunctorSalad_: well, for example. I've run into the diamond dep problem because template-haskell DOESN'T RESPECT PACKAGE VERSIONS YOU SPECIFY
13:25:48 <aavogt> thoughtpolice: ghc on some platforms doesn't do TH though
13:26:13 <gwern> 'what's that gwern? you'd like to compile lambdabot against bytestring x? no, I think I'd rather compile *this* module against bytestring x+1 and screw the entire build!'
13:26:14 <aavogt> IIRC you basically need to have ghci able to work
13:26:19 <thoughtpolice> aavogt: true, I forgot that restriction. so it's stage2 only - how many platforms does that rule out?
13:26:27 <gwern> I really hope that bug was fixed
13:26:52 <FunctorSalad_> gwern: AFAIK a ghc version is hardwired to the th that comes with it
13:27:06 <thoughtpolice> aavogt: i know that debian for example has a lot of unregistered ghc builds for different architectures
13:27:15 <FunctorSalad_> gwern: bad things happened when I tried to change the TH version and over-install my modded th
13:27:38 <gwern> and then there are the times TH just fails on loading a library
13:27:42 <gwern> oh those are so fun
13:27:49 <aavogt> which ones?
13:27:58 <thoughtpolice> aavogt: so those qualify for not having TH, but I think pretty much any binary distributed by the HP Team or GHC HQ itself is going to have it
13:28:02 <FunctorSalad_> bus once it does startup, I never had reliability issues
13:28:38 <FunctorSalad_> gwern: maybe the file had no language pragma and relied on a package-wide one
13:28:48 <FunctorSalad_> to explain the seeming randomness
13:29:02 <thoughtpolice> aavogt: I normally don't buy the portability argument w.r.t. GHC since practically speaking everybody is going to use GHC, but TH is a particularly special case, so i'll agree there since you mentioned that :)
13:29:13 <FunctorSalad_> or like me, you have the language pragma in your .ghci ;)
13:29:15 <gwern> FunctorSalad_: no, I mean it'd fail in the loading ancillary packages step, not in the local file module itself
13:29:20 <FunctorSalad_> (then try in some other context)
13:29:30 <aavogt> FunctorSalad_: unfortunately, zeroTH has not kept pace with TH
13:29:39 <FunctorSalad_> aavogt: oh :(
13:30:00 <aavogt> http://hackage.haskell.org/packages/archive/zeroth/2009.6.23.3/logs/failure/ghc-6.12
13:30:17 <thoughtpolice> yeah, the TH library changed in 6.12
13:30:20 <FunctorSalad_> gwern: hmm, I don't know then
13:30:27 <thoughtpolice> to add support for associated type syntax, I think
13:30:38 <FunctorSalad_> and kind sigs IIRC
13:30:44 <FunctorSalad_> the fix is easy
13:30:54 <gwern> FunctorSalad_: sometimes it's obvious how to fix em, like when it reports libz.a missing, but other times...
13:30:57 <aavogt> well this failure is due to something being rearranged
13:31:06 <thoughtpolice> motivation was so TH instance generators can generate type family instances too, since lots of libraries like multirec and regular need that
13:31:15 <FunctorSalad_> (you just need to add the wrapper/unwrapper for the new AST elements, if your code doesn't care about them)
13:31:37 <aavogt> FunctorSalad_: what is this wrapper/unwrapper?
13:31:57 <aavogt> you get to pretend that the TH AST is much smaller?
13:32:02 <FunctorSalad_> aavogt: IIRC you need to wrap types in type-without-kind-sig where kind sigs would be allowed
13:32:07 <FunctorSalad_> aavogt: maybe I misremember
13:35:31 <FunctorSalad_> isn't there a web interface to the ghc repository somewhere?
13:35:41 <FunctorSalad_> then we could just look at the changes
13:36:09 <FunctorSalad_> aavogt: smaller? no, it had become a bit more complex due to this new KindedType type
13:36:54 <FunctorSalad_> aavogt: sorry, the name is "TyVarBndr"
13:37:04 <FunctorSalad_> data TyVarBndr = PlainTV Name | KindedTV Name Kind
13:37:24 <FunctorSalad_> and it's about vars, not types
13:37:48 <FunctorSalad_> I think Pred is new too
13:37:54 <FunctorSalad_> data Pred = ClassP Name [Type] | EqualP Type Type
13:38:04 <FunctorSalad_> type Cxt = [Pred]       -- Defined in Language.Haskell.TH.Syntax
13:38:12 <EvanR-work> updates to a Data.Map arent inefficient? the entire structure doesnt get reconstructed, right?
13:39:07 <aavogt> EvanR-work: all the nodes in the path to your element from the root are replaced
13:39:08 <FunctorSalad_> EvanR-work: just the path to the leaf in question (and just the tree 'skeleton' there, not the keys stored there)
13:39:34 <EvanR-work> ok
13:41:31 <FunctorSalad_> not sure how much overhead that is over the imperative version...
13:43:15 <flazz> is there support to highlight the current line in yi?
13:43:24 <EvanR-work> with a sane allocator it should be good enough, seems like it would be about as bad as operating on a short list
13:56:04 <EvanR-work> > transpose [1]
13:56:05 <lambdabot>   No instance for (GHC.Num.Num [a])
13:56:05 <lambdabot>    arising from the literal `1' at <inter...
13:56:19 <EvanR-work> > transpose [[1]]
13:56:20 <lambdabot>   [[1]]
13:56:28 <ologNation> I'm trying to use DrIft.
13:56:35 <ologNation> I installed and compiled it.
13:56:46 <ologNation> I ran it on a simple haskell script.
13:56:50 <ologNation> The output looked nice.
13:57:05 <ologNation> But then I got an error that isPrefixOf is not in scope.
13:57:13 <ologNation> I wonder how to resolve this.
13:57:29 <aavogt> you must add an import
13:57:32 <siracusa> ologNation: import Data.List
13:57:34 <aavogt> @index isPrefixOf
13:57:34 <lambdabot> Data.List
13:57:42 <ologNation> Ok.  Thanks.
13:58:16 <FliPPeh> I have a list of strings (the source), and another list of strings (the targets) and a string (the replacements).. now I'd like to be able to do something like 'merge ["source", "burger", "list", "apple"] ["burger", "apple", "pie"] "food"' and get something like ["source", "food", "list"] out of it
13:58:21 <FliPPeh> What's the easiest way to do that?
13:58:40 <FliPPeh> I think mapping all the matching strings to the merge string and calling "nub" on it could work
13:58:54 <FliPPeh> But it sounds raather unclean
13:59:41 <byorgey> FliPPeh: are these really lists?  or are they actually sets?
13:59:49 <FliPPeh> byorgey: Real lists
14:00:09 <siracusa> FliPPeh: I think there's Data.List.union
14:00:14 <EvanR-work> nub . concat
14:00:27 <byorgey> let me rephrase that.  is the ordering on the lists, and the possibility of having multiple occurrences, important?
14:00:41 <ologNation> Wow.  It's working.
14:00:51 <ologNation> Do you guys ever get surprised when stuff works?
14:00:59 <ologNation> Or do you just expect it to work.
14:01:00 <byorgey> ologNation: all the time.
14:01:03 <FliPPeh> byorgey: Ordering: not important - multiple occurerences: would be nice to avoid
14:01:06 <sproingie> it's haskell.  if it compiles, it probably works.
14:01:20 <byorgey> FliPPeh: in that case, it seems like you ought to use Sets instead of lists.
14:01:27 <ologNation> Man, linux has changed.
14:01:30 <ologNation> Stuff works now.
14:01:37 <FliPPeh> That'd mean rewriting my whole code :(
14:01:52 <byorgey> then you could just use Set difference.
14:02:00 <sproingie> ologNation: wifi is still usually broken enough for anyone who wants to feel nostalgia
14:02:24 <byorgey> FliPPeh: well, if you're sticking with lists what you proposed sounds like the easiest way
14:02:42 <ologNation> sproingie, That's so sweet.
14:02:59 <ologNation> I mostly just like feeling nostalgic about my own, still broken code.
14:03:05 <FliPPeh> sproingie: I've NEVER had wifi problems :)
14:03:11 <FliPPeh> And I had a bunch of cards and dongles
14:03:19 <FliPPeh> PCI, USB
14:03:30 <siracusa> FliPPeh: What is you "food" supposed to replace?
14:03:35 <siracusa> your
14:03:35 <sunrayser> any idea what this means? cabal.exe: dependencies conflict: ghc-6.12.2 requires Cabal ==1.8.0.3 however Cabal-1.8.0.3 was excluded because ghc-6.12.2 requires Cabal ==1.8.0.4
14:03:43 <byorgey> > let merge source targets repl = nub $ map (\s -> if s `elem` targets then repl else s) source in merge ["source", "burger", "list", "apple"] ["burger", "apple", "pie"] "food"
14:03:44 <lambdabot>   ["source","food","list"]
14:03:49 <sproingie> sound's another fun one.  mostly because distros change to some new and even more broken API every other week
14:04:19 <FliPPeh> Nice :)
14:04:27 <FliPPeh> I was halfway finished with mine
14:04:29 <tromp_> > showIntAtBase 8 intToDigit  230  ""
14:04:30 <lambdabot>   "346"
14:04:58 <FliPPeh> siracusa: "food" will replace ["burger", "apple", "pie"]
14:05:08 <mauke> sunrayser: http://www.haskell.org/cabal/FAQ.html#dependencies-conflict
14:05:08 <FliPPeh> All of those will be replaced with "food"
14:05:15 <tromp_> > showIntAtBase 8 intToDigit  172  ""
14:05:16 <lambdabot>   "254"
14:05:19 <siracusa> FliPPeh: Yeah, I got it now :-)
14:05:19 <FliPPeh> And in the end, nub'd to only include one
14:05:21 <FliPPeh> :)
14:05:47 <ologNation> FliPPeh, The use of the word "set" is a bit misleading.  The data structure called a set in Data.Set actually emphasizes that the elements have an ordering.
14:05:58 <sunrayser> mauke: thanks
14:06:26 <tensorpudding> Though sets can be ordered too
14:06:31 <EvanR-work> there must be a better interface for printing numbers in different bases
14:06:58 <EvanR-work> @hoogle Integral a => a -> Int -> String
14:06:59 <lambdabot> Prelude replicate :: Int -> a -> [a]
14:06:59 <lambdabot> Data.List replicate :: Int -> a -> [a]
14:06:59 <lambdabot> Network.BufferType buf_toStr :: BufferOp a -> a -> String
14:08:25 <sunrayser> mauke: ah it seems it wasn't such a good idea to install 6.12.2 right on top of the RC...
14:12:22 <mreh> @instances (,)
14:12:22 <lambdabot> Couldn't find class `(,)'. Try @instances-importing
14:12:31 <mreh> uuhhh
14:12:37 <mreh> what do I want
14:12:45 <mreh> @list
14:12:45 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
14:13:15 <mreh> @instances Ord
14:13:16 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
14:13:27 <mreh> is this Caleskall?
14:13:39 <mreh> Caleskell, rather
14:13:49 * hackagebot hsx 0.7.0 - HSX (Haskell Source with XML) allows literal XML syntax to be used in Haskell source code.  http://hackage.haskell.org/package/hsx-0.7.0 (NiklasBroberg)
14:13:53 <IceDane> Wow.. I never realized how powerful the haskell type system is until now, reading data-structures in RWH(The expression parser)
14:14:10 <IceDane> And I have feeling that's not even close to showing all its potential
14:14:13 <IceDane> brb
14:14:15 <EvanR-work> data is awesome
14:15:31 <ologNation> IceDane, What is RWH?
14:15:33 <gwern> IceDane: it's turing complete with extensions you know
14:15:36 <gwern> @where RWH
14:15:36 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
14:15:54 <FunctorSalad_> EvanR-work: btw, now that you ask it, I wonder if nodes with 2 children are such a good idea in FP?
14:16:15 <FunctorSalad_> maybe it's a dumb question
14:16:18 <EvanR-work> why are they a good idea in not FP
14:16:39 <FunctorSalad_> but wouldn't you get less allocations of nodes with, say, branching factor 100
14:16:40 <EvanR-work> are we talking about BST or a Cons
14:16:54 <FunctorSalad_> I'm talking about implementing Data.Map
14:17:00 <gwern> FunctorSalad_: think it's one of them 'trade-off' things
14:17:02 <EvanR-work> yeah i dont know how it works
14:17:09 <FunctorSalad_> pretty sure Data.Map is binary
14:17:25 <c_wraith> Data.Map is a red-black binary search tree, yes
14:17:26 <EvanR-work> the doc says what it is
14:18:03 <EvanR-work> i dont know if allocation is the biggest thing to worry about
14:19:01 <FunctorSalad_> you'd also have less nodes in general
14:19:29 <FunctorSalad_> (I'm thinking of an array of 100 child-pointers here)
14:19:44 <EvanR-work> a mod 100 search tree
14:19:57 <EvanR-work> sort of like a hash table
14:20:14 <FunctorSalad_> well, if the type supports it, that's great, but even with just Ord, you can handle a node with binary search, right?
14:20:17 <EvanR-work> now if you update one of the 100, you must reconstruct the 100 array
14:20:33 <aavogt> http://hackage.haskell.org/package/HsJudy
14:20:37 <FunctorSalad_> IIRC you just need a rotation, EvanR-work
14:20:42 <FunctorSalad_> just changes 2 pointers
14:20:52 <FunctorSalad_> (out of the 100, and some other ones elsewhere)
14:21:18 <EvanR-work> so you are talking about indirection ?
14:21:32 <EvanR-work> we have to remember all the pieces parts must be immutable
14:21:44 <EvanR-work> a 100 immutable array sounds not so fast to update
14:22:05 <FunctorSalad_> hmm, is it more indirection than usual? but right, I was expecting mutable arrays
14:22:10 <FunctorSalad_> hmm
14:22:23 <yitz> The old Data.FiniteMap, replaced by Data.Map, had a branch factor of 5.
14:22:26 <FunctorSalad_> ok, that would be bad
14:22:57 <FunctorSalad_> you would indeed have to copy all the 100-elt arrays along the path to what you were updating
14:23:37 <c_wraith> Data.Sequence uses 2-3 trees
14:23:49 <EvanR-work> iw as about to say that ;)
14:23:50 <mauke> I thought it only used one
14:24:09 <EvanR-work> FunctorSalad_: i wouldnt even want to update one of the 100 arrays, for just updating one of the children
14:24:47 <EvanR-work> i think B trees are an example of non binary trees
14:24:52 <EvanR-work> used in file systems
14:25:03 <FunctorSalad_> somehow I thought you can use mutating arrays inside and present a pure interface, but that was a confused idea
14:25:12 <FunctorSalad_> yep, I had B-trees in mind
14:25:17 <mauke> just use STâ„¢
14:25:28 <EvanR-work> STMap ;)
14:25:38 <c_wraith> DiffArray also uses mutation internally...  It really frightens me.
14:25:43 <FunctorSalad_> mauke: but then "insert","delete" etc are in ST
14:25:53 <Twey> http://www.copyright.gov/title17/92chap1.html#101
14:26:06 <Cale> c_wraith: So does evaluation
14:26:07 <Twey> Â« A â€œcomputer programâ€ is a set of statements or instructions to be used directly or indirectly in a computer in order to bring about a certain result. Â»
14:26:13 <FunctorSalad_> the program using the ST tree could be pure to the outside, of course
14:26:27 <Cale> c_wraith: But DiffArray really does have some bugs with regard to multithreading.
14:26:27 <Twey> Does this mean that Haskell â€˜programsâ€™ are not programs?  And therefore not copyrightable?
14:26:42 <pikhq> Twey: A Haskell program is still a set of statements.
14:26:57 <EvanR-work> if we want more than a few branches, then we might as well use a hash table, especially if were allowing mutable
14:27:01 <FunctorSalad_> and sets are patentable? ;o
14:27:06 <FunctorSalad_> *copyright
14:27:21 <Twey> pikhq: No it isn't â€” it's a set of expressions
14:27:30 <EvanR-work> its a single expression ;)
14:27:36 <FunctorSalad_> (list, but that's totally besides the point)
14:27:47 <Twey> Heheh.
14:27:55 <FunctorSalad_> Twey: hmm, decls according to the asts
14:28:00 <pikhq> Twey: They are not using CS notions of "statement" here.
14:28:09 <FunctorSalad_> that is, a module contains decls
14:28:18 <pikhq> In their notion, "expression" and "statement" are synonyms.
14:28:22 <absz> Another cabal question: I'm trying to install some cabal packages (e.g. hxt), and I'm getting the error "cabal: dependencies conflict: ghc-6.12.1 requires directory ==1.0.1.1 however directory-1.0.1.1 was excluded because ghc-6.12.1 requires directory ==1.0.1.0", which doesn't make any sense.  Does anyone have any idea what's going on?  I fixed that error by explicitly installing both versions, but now I'm getting a similar error for filepath ==1.1.0.3 / filep
14:28:23 <absz> ==1.1.0.4.
14:28:42 <Twey> pikhq: Odd.  In what sort of strange language is that the case?
14:28:43 <dcoutts_> absz: see the Cabal FAQ
14:28:46 <EvanR-work> that patent sounds imperative
14:28:56 <pikhq> Twey: Legalese.
14:29:12 <absz> dcoutts_: oh wow, I can't believe I missed that.  Sorry, and thanks :)
14:29:15 <FunctorSalad_> pikhq: my argument was more in the direction of "a set as an abstract entity" vs "this concrete set I wrote down on my computer"
14:29:22 <FunctorSalad_> but I guess that leads nowhere
14:29:23 <pikhq> Mmkay.
14:29:39 <EvanR-work> a set of letters in a text file
14:29:42 <EvanR-work> no particular order ;)
14:29:42 <FunctorSalad_> well, for patent right it may matter more
14:29:52 <FunctorSalad_> but copyright isn't impressed by the argument AFAIK
14:29:54 * hackagebot HJScript 0.5.0 - HJScript is a Haskell EDSL for writing JavaScript programs.  http://hackage.haskell.org/package/HJScript-0.5.0 (NiklasBroberg)
14:30:01 <FunctorSalad_> s/right/law/
14:30:16 <Twey> I suppose Haskell definitions can be considered statements of equivalence.
14:30:55 * hackagebot hsp 0.5.0 - Haskell Server Pages is a library for writing dynamic server-side web pages.  http://hackage.haskell.org/package/hsp-0.5.0 (NiklasBroberg)
14:31:41 <FunctorSalad_> Twey: hmm? only in the trivial sence that a thing is equal to its definition
14:31:50 <FunctorSalad_> (to the body of its definition)
14:31:56 <FunctorSalad_> extensionally, anyway
14:33:19 <FunctorSalad_> that's a difference between math and programming; programs usually remain silent about the relations between the items they define
14:33:44 <FunctorSalad_> the relations just work implicitly to make the program work correctly
14:34:10 <EvanR-work> declarative programming like haskell is similar to math definitions
14:34:16 <FunctorSalad_> with 'relations' I mean, for example, the associativity of addition
14:34:35 <FunctorSalad_> it applies to programs, but they never mention it (except with dep types)
14:34:53 <EvanR-work> nevermind the fact that floating addition isnt associative ;)
14:34:56 <FunctorSalad_> EvanR-work: right, but just *definitions*
14:34:59 <FunctorSalad_> no *theorems*
14:35:11 <FunctorSalad_> since these are irrelevant for producing output
14:35:17 <fax> ah yes
14:35:23 <fax> programs tend to compute things
14:35:23 <EvanR-work> we dont get theorems, we get evaluation rules
14:35:29 <fax> so we miss out on the really fun stuff
14:35:33 <fax> (the why)
14:35:34 <FunctorSalad_> (I mean, it's irrelevant whether the proof is preresented in your source file)
14:36:14 * RayNbow wonders why this diagram is said not to commute... http://www.reddit.com/r/haskell/comments/bumal/haskell_type_constraints_unleashed_talk/c0on0ln
14:36:16 <FunctorSalad_> EvanR-work: ah yes, floating point ;))
14:37:32 <RayNbow> ...because I don't see why it wouldn't commute
14:38:10 <RayNbow> (the Haskell type Set is a functor on a subcategory of Hask, right?)
14:38:24 <FunctorSalad_> EvanR-work: the eval rules can be used to define what programs are equal
14:38:37 <FunctorSalad_> EvanR-work: but programs itself still don't state any relations/properties
14:38:43 <FunctorSalad_> *themselves
14:38:52 <EvanR-work> there are no extra theorems, no
14:38:58 <FunctorSalad_> except in dependent types as I mentioned
14:39:27 <FunctorSalad_> and in simple types too, I guess
14:39:31 <ddarius> RayNbow: That diagram doesn't even make sense.
14:39:50 <FunctorSalad_> (the simple types do prove some properties, after all)
14:40:35 <EvanR-work> like True False?
14:41:07 <RayNbow> ddarius: well, yeah, the F on the horizontal arrows is a bit odd
14:41:33 <RayNbow> if it was pure or return, then the diagram made sense
14:41:50 <FunctorSalad_> I find this apparent split interesting between mathematical data that is "informative", and properties that lurk in the background to make things work, but never have to be represented because "it's true" contains no data
14:42:21 <FunctorSalad_> (the proofs themselves may have data; this leads to the whole proof irrelevance issue in coq)
14:42:33 <FunctorSalad_> (and the separation of Prop and Type)
14:42:55 <EvanR-work> i havent looked much at coq yet
14:43:15 <mreh> why do they call it coq?
14:43:38 <FunctorSalad_> mreh: that's at the start of the faq, but seems a bit of a cop-out
14:44:37 <mreh> I didn't actually think it was derived from the french for rooster
14:45:22 <mreh> :t tails
14:45:22 <lambdabot> forall a. [a] -> [[a]]
14:45:51 <FunctorSalad_> but I mean that proofs being informative objects are a bit of an artifact of curry-howard; I still think Props per se and "data" are qualitatively different
14:45:57 <mreh> :t transpose
14:45:58 <lambdabot> forall a. [[a]] -> [[a]]
14:46:32 <fax> FunctorSalad_ - there is also cases when you have non-Prop data which acn be erased at compile time (like indices and witnesses)
14:46:55 <mreh> > zipWith (++) . (transpose &&& id) . tails $ [1..10]
14:46:56 <lambdabot>   Couldn't match expected type `[a]'
14:46:56 <lambdabot>         against inferred type `([[a1]], ...
14:47:03 <FunctorSalad_> (it doesn't have any effect on the Real World *who* inhabits the Prop, but it does have real meaning whether it's inhabited or not)
14:47:40 <mreh> > transpose . tails $ [1..3]
14:47:41 <lambdabot>   [[1,2,3],[2,3],[3]]
14:47:46 <FunctorSalad_> fax: 'witness' is a synonym for value of some type interpreted as a proposition, in my book
14:48:00 <ddarius> RayNbow: Incidentally, binary trees are both functors and monads.
14:49:20 <EvanR-work> i cant seem to make a generator that produces a stream of Bools starting with False, using mkStdGen
14:49:20 <mreh> > (transpose . tails $ [1..3]) == tails [1..3]
14:49:21 <lambdabot>   False
14:49:27 <ddarius> :t Set.singleton
14:49:28 <lambdabot> Couldn't find qualified module.
14:49:33 <ddarius> :t S.singleton
14:49:34 <lambdabot> forall a. a -> S.Set a
14:49:39 <EvanR-work> > take 5 $ randoms $ mkStdGen 0
14:49:40 <RayNbow> ddarius: I can see how they are functors...
14:49:40 <lambdabot>   [-117157315039303149,-8854136653200549331,-2598893763451025729,-21049421333...
14:49:43 <mreh> > (transpose . tails $ [1..3]) ++ []  == tails [1..3]
14:49:44 <lambdabot>   False
14:49:45 <EvanR-work> > take 5 $ randoms $ mkStdGen 0 :: [Bool]
14:49:46 <lambdabot>   [True,True,True,False,False]
14:49:52 <EvanR-work> > take 5 $ randoms $ mkStdGen 99 :: [Bool]
14:49:53 <lambdabot>   [True,True,False,True,False]
14:49:58 <EvanR-work> :\
14:50:19 <EvanR-work> goal, find a seed for mkStdGen which leads to [False, something..]
14:50:42 <RayNbow> hmm... and I can also see how they form a monad :)
14:51:32 <byorgey> > map head . randoms . mkStdGen $ [0..100] :: [Bool]
14:51:33 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
14:51:33 <lambdabot>         against inferred type ...
14:51:45 <Saizan> what should y --- F ---> yF represent in that diagram?
14:51:51 <Twey> :t zipMap
14:51:52 <lambdabot> Not in scope: `zipMap'
14:51:56 <Twey> Damn
14:52:02 <byorgey> > map (head . randoms . mkStdGen) $ [0..100] :: [Bool]
14:52:03 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
14:52:28 <byorgey> > and $ map (head . randoms . mkStdGen) [0..10000]
14:52:29 <lambdabot>   True
14:52:32 <Twey> @let zipMap = flip fmap fmap (fmap (flip fmap fmap) (fmap join)) (flip zip)
14:52:33 <lambdabot>  Defined.
14:53:07 <Twey> > filter (not . fst) $ zipMap (take 5 . randoms . mkStdGen) [1 .. 100]
14:53:08 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
14:53:08 <lambdabot>         against inferred type ...
14:53:09 <EvanR-work> byorgey: i found them with filter, starting at 53668 :(
14:53:12 <Twey> > filter (not . snd) $ zipMap (take 5 . randoms . mkStdGen) [1 .. 100]
14:53:13 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
14:53:13 <lambdabot>         against inferred type ...
14:53:17 <Twey> Ehh.
14:53:23 <mreh> does transpose not like ragged lists?
14:53:49 <EvanR-work> i dont suppose there are any statistical laws that say the first thing should be independent from the seed value
14:53:53 <mreh> > transpose [[1],[1,2],[1,2,3]]
14:53:54 <lambdabot>   [[1,1,1],[2,2],[3]]
14:53:58 <Twey> Oh, haha
14:54:00 <mreh> that's betterer
14:54:09 <Twey> > filter (not . snd) $ zipMap (head . randoms . mkStdGen) [1 .. 100]
14:54:10 <lambdabot>   []
14:54:18 <Twey> > filter (not . snd) $ zipMap (head . randoms . mkStdGen) [1 .. 1000]
14:54:19 <lambdabot>   []
14:54:22 <Twey> Huh.
14:54:27 <EvanR-work> try 100000
14:54:29 <Twey> 53668, you say.
14:54:32 <mreh> It's lower triangular
14:55:01 <mreh> try 3, that's the last number it'll suspect
14:56:22 <lispy> RayNbow: It's weird to write xF for F applied to x
14:56:57 <EvanR-work> lispy: unless youre using javascript ;)
14:57:03 <byorgey> lispy: it makes perfect sense with the direction arrows are written, actually
14:57:10 <lispy> RayNbow: and then gF seems even weirder.
14:57:34 <byorgey> F : A -> B, G : B -> C   then  F;G : A -> C
14:57:42 <byorgey> and x (F;G) = (xF)G
14:58:01 <EvanR-work> getelement().mutateelement().explodeelement().hideelement()
14:58:11 <byorgey> but it's certainly not standard.  but sometimes I wish it were.
14:58:37 <SonOfLilit> Hello
14:58:44 <byorgey> hi SonOfLilit
14:58:52 <EvanR-work> byorgey: ive been using <$ to be flip $
14:58:59 <SonOfLilit> I'm a newbie to Haskell
14:59:07 <EvanR-work> flip ($)
14:59:08 <SonOfLilit> have to say, been enjoying my stay this far
14:59:13 <byorgey> SonOfLilit: welcome! you've come to the right place
14:59:41 <SonOfLilit> I'm trying to recreate what I've learned in the first chapters of the 48 hour scheme tutorial without looking
14:59:51 <SonOfLilit> and with some unit testing
14:59:56 <byorgey> EvanR-work: sure. I often use >$> because of its similarity to (>>>) = flip (.) for functions
15:00:33 <byorgey> SonOfLilit: sounds like a fun approach.  How is it going so far?
15:00:34 <EvanR-work> at >>>
15:00:37 <EvanR-work> ah*
15:00:42 <EvanR-work> interesting
15:00:46 <SonOfLilit> well
15:00:53 <mreh> > inits [1..3]
15:00:54 <lambdabot>   [[],[1],[1,2],[1,2,3]]
15:00:55 <byorgey> so I can write   x >$> f >>> g >>> h  and so on
15:00:58 <SonOfLilit> there'd been some good times and some bad
15:01:09 <mreh> > transpose . inits $ [1..3]
15:01:10 <lambdabot>   [[1,1,1],[2,2],[3]]
15:01:12 <EvanR-work> nice
15:02:07 <SonOfLilit> for example, when I realised I was marooned away from a net connection without docs for Parsec, I got very pissed off at Haskell Platform
15:02:07 <SonOfLilit> for not including them
15:02:07 <mreh> *unit testing*
15:02:07 <SonOfLilit> I have a unit test that checks that "5a", not being a legal atom, gives a parse error
15:02:07 <mreh> I've vowed never to write one of those again for pure code
15:02:07 <SonOfLilit> unfortunately, it gets parsed as a number
15:02:38 <SonOfLilit> I can't seem to find a way around it, before I add the list parsing code
15:02:41 <EvanR-work> mreh: yeah pure code cant have bugs ;)
15:03:05 <EvanR-work> and i/o code cant be made bug free
15:03:13 <byorgey> SonOfLilit: maybe you need to specify that the parse must end with an eof?
15:03:20 <c_wraith> SonOfLilit: check for parsing as number followed by eof
15:03:23 <byorgey> SonOfLilit: otherwise it may just parse the "5" and ignore the "a"
15:03:26 <c_wraith> err, byorgey beat me
15:03:37 <mreh> pure code can't have bugs that have nothing to do with the code, if you catch my drift
15:03:44 <aavogt> @type (<$)
15:03:45 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
15:03:52 <EvanR-work> @hoogle (>>>)
15:03:52 <lambdabot> Control.Arrow (>>>) :: Category cat => cat a b -> cat b c -> cat a c
15:03:53 <lambdabot> Control.Category (>>>) :: Category cat => cat a b -> cat b c -> cat a c
15:04:40 <aavogt> SonOfLilit: that will make it a bit inconvenient when you also import Control.Applicative, where the same function is defined
15:05:02 <byorgey> aavogt: I think you meant EvanR-work?
15:05:09 <aavogt> maybe?
15:05:23 <byorgey> EvanR-work was talking about using (<$), not SonOfLilit
15:05:26 <aavogt> definitely
15:05:36 <chrisdone> what is hanging my ethnic brothers
15:05:38 <aavogt> sorry
15:05:43 <EvanR-work> >>> is in Control.Applicative too?
15:05:54 <aavogt> maybe it's reexported?
15:05:59 <byorgey> EvanR-work: it's defined in Control.Category, but Applicative reexports it
15:06:06 <byorgey> er, I mean Arrow
15:06:15 <byorgey> it is definitely not in Applicative
15:06:19 <SonOfLilit> so something like: parse (eof >>= parseExpression) "lisp" expr
15:06:25 <SonOfLilit> ?
15:06:26 <gwern> chrisdone: our ethnic confreres are all chilling the shiznit
15:06:50 <mauke> SonOfLilit: parseExpression <* eof
15:07:19 <SonOfLilit> not in scope: <*
15:07:38 <byorgey> mauke: that requires importing Control.Applicative and making sure Parsec has an Applicative instance if SonOfLilit is using version 2
15:08:15 <SonOfLilit> then what's the simpler way?
15:08:46 <mauke> a <* b = do x <- a; b; return x
15:08:53 <SonOfLilit> the tutorial did something like (spaces >>= otherParser) to  have something followed by spaces, can't I do something of the sort?
15:09:10 <mauke> that's something preceded by spaces
15:09:29 <byorgey> mauke: true, I guess you can just define it easily enough =)
15:09:34 <RayNbow> lispy: xF for F applied to x might be weird, but isn't that how it's written in ML?
15:09:48 <mreh> :t ((++) . f)
15:09:49 <lambdabot> forall a (f :: * -> *). (Monoid a, SimpleReflect.FromExpr (f a), Functor f) => f (a -> a)
15:09:53 <byorgey> SonOfLilit: you can just copy mauke's definition of <* there
15:10:12 <byorgey> SonOfLilit: f <* g  runs f and then g, but discards the output of g and returns the output of f instead
15:10:14 <mreh> :t ((++) . tail)
15:10:14 <RayNbow> so things like 'a list
15:10:15 <lambdabot> forall a. [a] -> [a] -> [a]
15:10:23 <SonOfLilit> did that
15:10:25 <SonOfLilit> it works
15:10:27 <SonOfLilit> thanks
15:11:51 <mreh> :t (&&&)
15:11:52 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
15:12:56 <chrisdone> http://chrisdone.com/images/spjdisregardfemalesacquirecurrency.png
15:13:11 <newsham> > (head &&& tail) ([1,2,3], [4,5,6])
15:13:12 <lambdabot>   Couldn't match expected type `[c]'
15:13:12 <lambdabot>         against inferred type `([t], [t1...
15:13:27 <newsham> > (head &&& tail) [1,2,3]
15:13:28 <lambdabot>   (1,[2,3])
15:14:18 <gwern> @wn loupe
15:14:19 <lambdabot> *** "loupe" wn "WordNet (r) 2.0"
15:14:19 <lambdabot> loupe
15:14:19 <lambdabot>      n : small magnifying glass (usually set in an eyepiece) used by
15:14:19 <lambdabot>          jewelers and horologists [syn: {jeweler's loupe}]
15:14:36 <aavogt> @wn loup
15:14:36 <lambdabot> No match for "loup".
15:14:42 <chrisdone> that's not what she used
15:14:44 <gwern> aavogt: that's french mon
15:14:52 <aavogt> wolf man
15:15:07 <chrisdone> @vixen do you have a loupe?
15:15:08 <lambdabot> maybe. do you?
15:15:11 <gwern> oh noes! look out for that troup de loup ahead!
15:18:16 <SonOf> so if unit tests are the wrong approach, how would you guys (mauke, esp. you) test a parser?
15:18:28 <mauke> easy, I just don't test my code
15:18:45 <SonOf> then how do you know if it works?
15:18:54 <aavogt> use the type system of course
15:19:13 <mauke> SonOf: I look at it sternly and pray
15:19:24 <SonOf> aavogt: I would very much like you to elaborate on that point
15:19:42 <SonOf> how do I use the type system to ensure the correctness of my code?
15:19:58 <chrisdone> why are unit tests the wrong approach?
15:20:20 <c_wraith> because lots of people somehow believe quickcheck properties aren't unit tests
15:20:49 <gwern> quickcheck properties are a lot of unit tests
15:20:57 <chrisdone> so?
15:21:06 <aavogt> SonOf: I just mean encoding simple properties like, ex  (a,[a]) is a nonempty list
15:21:10 <chrisdone> that doesn't explain why unit tests are the wrong approach
15:21:29 <Cale> Unit tests are the special case of QuickCheck properties with no parameters.
15:21:34 <c_wraith> chrisdone: my point was that most people who say "I don't use unit tests" often follow it with "I use quickcheck"
15:21:45 <gwern> @check \_ -> 1+1==2
15:21:47 <lambdabot>   "OK, passed 500 tests."
15:21:47 <aavogt> so instead of the parser built with  many1  returning a plain list, it could return a nonempty list... if you do things later on that require it to be nonempty
15:21:54 <gwern> Cale: well I'll be you're right! :)
15:21:59 <mauke> @check 1+1==2
15:22:00 <lambdabot>   "OK, passed 500 tests."
15:22:09 <mauke> gwern: NO PARAMETERS
15:22:14 <c_wraith> @check \l -> l == reverse l
15:22:15 <lambdabot>   "OK, passed 500 tests."
15:22:23 <gwern> mauke: what is the sound of an ignored parameter?
15:22:34 <chrisdone> c_wraith: sure. quickcheck generates some unit tests for you, so you're using unit tests. ok. i thought someone was suggesting using unit tests was a bad idea
15:22:38 <mauke> const!
15:22:39 <aavogt> possibly forcing recomputation of the value
15:22:39 <DigitalKiwi> i dunno but does it make one when the tree falls?
15:22:45 <ezyang> I think the most immediate objects some people might have with quicktest checking only is "it's not reproduceable" and "it doesn't count as regression tests"
15:23:05 <gwern> ezyang: qc is reproducible. you take its counterexample and plug it in
15:23:16 <aavogt> ezyang: you can provide the random seeds if you go to that effort
15:23:26 <ezyang> gwern: Right, but at that point you've reified it into an explicit unit test.
15:24:14 <chrisdone> but you can use generated tests and regression tests side by side
15:24:21 <chrisdone> so what's the problem
15:24:43 <ezyang> *shrug* It's just slightly misleading that to say we don't do unit tests at all.
15:24:47 <ezyang> We just don't do them by default.
15:25:06 <c_wraith> I like just making my Arbitrary instance carefully, so that it functions as an exhaustive cover.
15:25:18 <c_wraith> white-box testing, if you will
15:25:35 <ezyang> It's a good practice in both domains.
15:26:10 <SonOf> so... I have a parser. How do I test it?
15:26:22 <mauke> run it on all possible inputs
15:26:52 <chrisdone> i'd use quickcheck and define any special cases you need to know are satisfied
15:26:53 <ezyang> If you have a serializer, generate data structures and check if they serialize and then parse into the same form
15:27:56 <SonOf> what I'm doing right now is tests like:
15:28:14 <SonOf> "parse an atom" ~: [parsesToIdentity "anAtom",
15:28:22 <SonOf> "parse a list" ~: parsesToIdentity "(a b c)"
15:28:32 <SonOf> which de- and re- serializes
15:28:44 <chrisdone> right
15:28:46 <SonOf> parseError "5a"
15:29:06 <chrisdone> basically testing something like show . read = id
15:29:15 <EvanR-work> c_wraith: whitebox testing?
15:29:16 <ezyang> so, you want to be able to generate those string on the right side automatically
15:29:18 <SonOf> I'm using the string representation because I couldn't figure out how to write an Eq for my algebraic data type
15:29:25 <ezyang> ah
15:29:29 <ezyang> troublesome
15:29:53 <SonOf> that would be pretty, yeah
15:30:13 <megaTherion> Anyone can recommend a good online tut/pdf about Haskell's Classes and Monads?
15:30:24 <ezyang> I, uh, don't really believe you.
15:30:24 <chrisdone> @google real world haskell monads
15:30:26 <lambdabot> http://book.realworldhaskell.org/read/monads.html
15:30:26 <lambdabot> Title: Chapter 14. Monads
15:30:43 <chrisdone> @google real world haskell type classes
15:30:44 <lambdabot> http://book.realworldhaskell.org/read/using-typeclasses.html
15:30:44 <lambdabot> Title: Chapter 6. Using Typeclasses
15:30:53 <SonOf> though I'm not sure I need to - I only want to check the simple cases, to make sure I'm not doing stupid mistakes -- I trust Parsec not to have bugs that only show up in complex cases
15:31:13 <chrisdone> megaTherion: go go go!
15:31:19 <megaTherion> yeah ok thanks :)
15:31:30 <SonOf> and some of these simple cases are e.g. with several spaces instead of one, and other non-canonical representations
15:31:32 <ezyang> Well, the idea behind the type system is to eliminate a large swath of stupid mistakes
15:31:57 <ezyang> anyway, we should think about why you don't have an Eq instance on your type
15:32:01 <FunctorSalad_> quickCheck has been suggested already I suppose
15:32:06 <ezyang> won't deriving (Eq) do the trick?
15:32:12 <chrisdone> if it costs little, type checking is better than no type checking. if it costs little, unit testing is better than no unit testing
15:32:17 <SonOf> how do you do that?
15:32:28 <lispy> ezyang: ah, I thought the type system was just there to give compiler writers something to do ;)
15:32:38 <Axman6> data Foo = Bar | Baz deriving Eq
15:32:40 <lispy> I've heard their job gets too easy otherwise
15:32:57 <ezyang> smirk
15:35:24 <FunctorSalad_> btw @ everyone not using their distro for haskell: there's a program 'paco' that keeps track of who installed what to /usr/local :)
15:35:43 <FunctorSalad_> cooperates nicely with cabal
15:36:11 <FunctorSalad_> alternatively, there's gnu stow which relies on symlinks instead of monitoring
15:36:46 <FunctorSalad_> (paco has to be invoked with "cabal install blah" as an argument)
15:36:56 <lispy> I just install things to $HOME if I'm doing it outside of my distro
15:37:28 <lispy> After all, no place like 127.0.0.1 -- er wait, wrong joke
15:37:39 <FunctorSalad_> hmm I'm the only user here too, I mean to get installed-file-lists
15:38:02 <FunctorSalad_> I don't really need the disk space, but it's handy to see where some data file went too
15:41:08 <ezyang> I'm trying to think of other usual quickcheck properties for checking that parsing is correct.
15:43:50 <siracusa> With a data type `data Tree = Leaf (forall e . Elem e => e) | ... ', how would I create a concrete value of it, like Leaf "a"?
15:44:27 <mauke> first you need a value that's in all types at the same time
15:44:38 <mauke> well, all types that are an instance of Elem
15:45:11 <siracusa> How do I create it out of say a String, when String is an instance of Elem?
15:45:33 <mauke> you can't
15:45:48 <mauke> a string is not a member of all types, it's a String
15:46:12 <siracusa> :-S
15:46:42 <mauke> your type is not useful
15:47:59 <siracusa> Yeah. What I want is a Tree where each leaf can hold a value of a different type, and then a function that folds that tree to a single value.
15:48:35 <mauke> data Tree = forall e. Elem e => Leaf e
15:48:44 <EvanR> how about a class of types which can be converted to a leaf
15:48:48 <EvanR> and converted back
15:50:06 <siracusa> mauke: Why is that type different?
15:50:20 <FunctorSalad_> should hackage make it easier to fork and re-integrate stuff? especially for a case of easy-to-fix bitrot where the maintainer can't (quickly) be reached
15:50:27 <mauke> siracusa: because that's how the syntax works?
15:50:34 <FunctorSalad_> (github-like)
15:50:59 <SubStack> cabal should just integrate with github
15:51:04 <FunctorSalad_> (but wouldn't need fancy VC for a start)
15:51:10 <SubStack> like rubygems used to do and possibly still does
15:51:11 <EvanR> siracusa: so your tree can contain any Elem, what can you do with an Elem besides put it in the tree?
15:51:34 <FunctorSalad_> SubStack: that's possible?
15:51:48 <SubStack> affirmative
15:51:56 <siracusa> EvanR: Make a new Elem from two Elems
15:52:02 <SubStack> or else hackage could have a "sync with github" button
15:52:04 <SubStack> that'd be neat
15:52:09 <EvanR> siracusa: like, addition?
15:52:27 <FunctorSalad_> SubStack: as I see it, the main advantage would be that your fix is advertised on the package's hackage page
15:52:36 <siracusa> EvanR: Yes, something like that
15:52:58 <FunctorSalad_> which would motivate people :)
15:53:01 <EvanR> well, in that case you can make the tree have Num rather than Elem ;)
15:53:16 <SubStack> FunctorSalad_: that would be quite nifty
15:53:55 <SubStack> also I think cpan can integrate with github too
15:54:02 <siracusa> EvanR: Actually it's not addition ;-) Elem is a Gtk widget and a create a new widget out of two widgets.
15:54:15 <EvanR> so widget compose
15:54:45 <FunctorSalad_> there's a haskellwiki page for quick bitrot fixes, but I guess nobody finds it
15:55:22 <FunctorSalad_> (btw, I still think the dependency upper version bounds are often too paranoid)
15:55:30 <EvanR> siracusa: often widgets can contain widgets, and thats your tree right there, no need for a separate tree
15:55:48 <FunctorSalad_> maybe upper bounds should be recommendations, rather than a scary fatal error
15:56:16 <FunctorSalad_> could be wrong...
15:56:40 <FunctorSalad_> (unless the bound is known to be a hard one)
15:57:03 <FunctorSalad_> I'm just talking about pessimistic default upper bounds
15:57:54 <siracusa> EvanR: My tree determines how the widgets are composed
15:59:31 <EvanR> siracusa: but a group of widgets is also a widget, if you move it or resize it, it moves children
15:59:40 <EvanR> your leaves arent widgets and dont have widget properties
16:00:10 <EvanR> s/leaves/branches/
16:00:22 <siracusa> EvanR: Why not?
16:00:44 <EvanR> not sure, you didnt list the branch constructor, just the leaf
16:01:59 <siracusa> EvanR: Well, I really simplified the data type
16:04:22 <siracusa> mauke: So with your definition of Leaf, is it possible to create a function like foldTree (Leaf x) = x? GHC can't infer the type
16:04:55 <mauke> what would its type be?
16:05:15 <EvanR> Elem a => Tree a -> a
16:05:29 <mauke> yeah, no
16:05:35 <siracusa> I dont' know
16:05:42 <mauke> Tree :: *
16:06:26 <IceDane> Has anyone written a moderately simple equation solver in haskell that can tell me how complex it is?
16:07:24 <EvanR> Elem a => Tree -> a
16:08:22 <siracusa> EvanR: Unfortunately this doesn't work
16:08:24 <mauke> EvanR: that means the caller gets to choose the type
16:08:49 <EvanR> yes
16:09:14 <mauke> which doesn't work
16:09:24 <EvanR> what doesnt work
16:09:47 <mauke> foldTree has to return a value of the type expected by the caller
16:10:01 <EvanR> which Elem instances can somehow do right
16:10:01 <mauke> all it has is some value stored in a Leaf, whose type is unknown
16:10:38 <EvanR> or is the caller just left with some Elem
16:11:16 <siracusa> The caller only wants an Elem, which one doesn't matter
16:12:40 <daviddarais> f :: Elem a => Tree -> a means the caller gets to choose the type of Elem, not that f can return anything that is an instance of Elem
16:14:13 <siracusa> Yes, I see the problem, but don't know how to solve it.
16:14:29 <mauke> that depends on what you're trying to do
16:15:57 <scotty> Can someone give me the most bare-bones code for parsing something with a Parsec Parser and returning a user-defined type?  I don't know much about monads and I keep getting all these errors.
16:16:35 <c_wraith> data X = X ; return X
16:16:46 <c_wraith> You didn't say useful. :)
16:17:12 <c_wraith> "return X" is a parser that matches no input, and returns X as its result
16:17:12 <scotty> Er... one sec.  Let me show you what I'm working with.
16:18:16 <siracusa> p = do { xs <- many 'a'; return $ length xs } is a parser that parses multiple 'a's and returns the number of them.
16:18:31 <mauke> no
16:18:35 <mauke> many (char 'a')
16:18:47 <siracusa> Oh yes :-)
16:21:11 <scotty> Alright, instead of printing out a character, I want to return a "Mine": http://pastebin.com/nJ0H1XUu
16:21:55 <SonOf> I'd reached a milestone: A parser of everything I need before I can start evaluation
16:22:02 <SonOf> I'd love to hear comments
16:22:03 <SonOf> http://github.com/SonOfLilit/ahscheme/blob/master/ahscheme.hs
16:22:14 <c_wraith> scotty: you're doing the printing *outside* the parser.
16:22:47 <SonOf> as this /is/ the first piece of nontrivial haskell that I've ever written
16:23:19 <scotty> c_wraith: Yes, I see that.
16:23:58 <scotty> I guess what I would like is for the parser to read in an Integer, return it, and then somehow have run return a Mine.
16:24:36 <c_wraith> scotty: you're using parsec 3?
16:24:52 <scotty> I don't know.  I'm just trying to go from parsing something to getting a result back that I know how to work with.  Like I said, I know barely anything when it comes to monads.
16:24:57 <scotty> c_wraith: Yes
16:27:22 <c_wraith> scotty: well, think of this in two steps.  First you need an intParser.  Then you can build a mineParser from it.
16:27:47 <c_wraith> I can't recall if Parsec 3 gives you an easy primitive for an int
16:28:03 <scotty> c_wraith: I read the Parsec intro pdf.  I understand very abstractly how to use all of Parsec's functions.  However, I don't know how to get anything back.
16:28:42 <scotty> c_wraith: In other words, I am able to write the parser that parses what I want and run it with run, but I don't know how to get back any actual results.
16:29:07 <c_wraith> scotty: the most explicit way is something like:  do { val <- someSortOfParser ; return $ someFunction val }
16:29:48 <c_wraith> scotty: that will create a new parser that applies a function to the result of another parser.
16:31:00 <c_wraith> (there are shortcuts that give you the same functionality a lot less verbosely, but it's useful to start with the most flexible, and learn the shortcuts later)
16:31:48 <scotty> c_wraith: I'm unclear as to what the signature of someFunction would be.
16:32:08 <scotty> c_wraith: Can you possibly modify the example code I put on pastebin, or would it be too much to write?
16:33:08 <c_wraith> scotty: I'm mostly unfamiliar with Parsec3, and just working from the fact that it fits several known interfaces.  Hence why I'm not producing anything concrete.
16:34:45 <scotty> c_wraith: Okay, thanks.  I'll mess with it and get back to you.
16:36:10 <c_wraith> scotty: basically, you can use <- to bind the result of a parser in a do block, and use return to create a parser that will result in what you gave it.
16:36:26 <c_wraith> scotty: if you've used <- and return in IO actions, they work the exact same way in parsec
16:37:36 <c_wraith> (and in any other monad.  They're actually what "monad" really means...  something that supports that interface in do blocks.)
16:41:48 <webwanderer> Hi, is it possible to use the do notation within the REPL?
16:41:56 <mauke> yes
16:42:07 <ddarius> A do-block is just an expression.
16:42:14 <webwanderer> mauke: can you show me an example here?
16:42:25 <mauke> > do { 42 }
16:42:26 <lambdabot>   42
16:42:30 <ddarius> Furthermore, for GHCi, the REPL is implicitly in a do-block so you can use statements from a do-notation in it.
16:42:38 <webwanderer> why the curly braces?
16:42:50 <mauke> because that's how do notation works
16:44:18 <kyagrd> Does anyone have problems with wxHaskell or other libraries not able to link to libstdc++.so in Debian or other linux?
16:44:21 <c_wraith> > let f x = do { return x } in f 10 :: [] Int
16:44:22 <webwanderer> but this works too
16:44:22 <lambdabot>   [10]
16:44:25 <webwanderer> > do 42
16:44:26 <lambdabot>   42
16:44:29 <c_wraith> > let f x = do { return x } in f 10 :: Maybe Int
16:44:30 <lambdabot>   Just 10
16:45:38 <kyagrd> wsHaskell tries to find libstdc++.so which does not exist. what exists in my debian system is libstdc++.so.6
16:46:05 <kyagrd> Wondering how cabal install wx succeeded to configure ... hmm
16:46:42 <pikhq> kyagrd: How very odd. The linker must've done funny things...
16:57:51 <kyagrd> Well wxHaskell doesn't work even after making a symbolic link from libstdc++.so.6 to libstdc++.so :(
16:58:42 <ClaudiusMaximus> did you re-run ldconfig?
16:59:53 <kyagrd> Well I didn't myself before. I just ran it as a root, but still the same
17:00:36 <ClaudiusMaximus> ok, that's me out of ideas then
17:03:21 <danderson> I'm confused about something. I have the following definition: morphIO :: (forall b. (m a -> IO b) -> IO b) -> m a
17:03:33 <kyagrd> I did both ldconfig -v and ldconfig -p but nothing changes ... wonder if this is just the problem of wxHaskell or general problem of other libraries trying to link to libstdc++
17:03:47 <danderson> it seems to me that it could be more clearly expressed as (forall b. (m a -> IO b) -> (IO b -> m a))
17:04:18 <danderson> is there a problem with expressing it in that way?
17:04:36 <danderson> The first definition I gave is one I got from a mailing list, so I'm trying to understand the reasoning.
17:04:54 <danderson> So far, all I have is that the author wanted to limit the scope of the new type variable
17:05:11 <danderson> but in doing that, the purpose of the function is very much confused
17:06:02 <pikhq> danderson: Looks to me like a means of implementing unsafePerformIO.
17:06:08 <kyagrd> Wondering how people uses wxHaskell hmm
17:06:37 <danderson> pikhq: it's actually the definition of "MonadMorphIO", an abstraction that allows you to pack/unpack monad stacks to and from IO
17:07:05 <pikhq> So, limited to those monads where you can do that sanely. Got it. :)
17:07:16 <danderson> that is, given a MonadIO, morphIO gives you a way to get an IO action which reconstructs the full stack when executed
17:07:21 <danderson> yeah
17:07:29 <danderson> well, the definition isn't limited in that way
17:07:41 <danderson> but all instance definitions recursively invoke morphIO, except for the instance on IO
17:07:45 <ddarius> danderson: You are reassociating the definition incorrectly.
17:08:20 <ddarius> danderson: It's ((A -> B) -> B) -> C which is -very- different from (A -> B) -> B -> C
17:09:10 <danderson> um
17:09:23 <danderson> okay, then the original definition doesn't parse for me.
17:09:37 <tensorpudding> @djinn c -> (a -> c)
17:09:37 <lambdabot> f a _ = a
17:09:40 <danderson> can you translate it to english for me? Clearly I'm missing what it does.
17:09:54 <ddarius> danderson: morphIO takes a function that takes a function.
17:10:01 <ddarius> morphIO is a unary function
17:10:30 <tensorpudding> @djinn Void -> a
17:10:30 <lambdabot> f = void
17:12:21 <aavogt> can you think of the higher-rank polymorphism here as like:    ((m a -> IO ()) -> IO ()) -> m a?
17:12:52 <aavogt> since you can't do much more with   () than you can with (forall a. a)
17:13:43 <danderson> hmm.
17:13:48 <danderson> clearly I need to ponder this more.
17:13:55 <danderson> ddarius: thanks, that helped. I think.
17:14:19 <aavogt> danderson: where are the instances of this class?
17:15:07 <danderson> aavogt: this was from an email on libraries@
17:15:15 <danderson> this is the code in question: hpaste.org/fastcgi/hpaste.fcgi/view?id=25012#a25012
17:17:27 <Saizan> aavogt: with the polymorphic type you're required to return a value returned by the callback, with () you don't
17:18:02 <Saizan> where you = the function passed to morphIO
17:20:11 <IceDane> How efficient is incrementally updating a Data.Array? It's implemented as a tree, right? So it's not terribly inefficient?
17:20:22 <EvanR> its not a tree
17:20:24 <EvanR> its an array
17:20:45 <blackh> ...so it is terribly inefficient. :)
17:20:52 <IceDane> I must have misread, then
17:20:53 <aavogt> you may be thinking of Data.Map
17:20:59 <syntaxglitch> If you want an int-indexed tree, use IntMap
17:21:10 <IceDane> aavogt: yeah, think that is it
17:21:24 <EvanR> array is good for fast read-only ;)
17:21:49 <BrianHV> am I correct in my determination that I can't export a list through FFI?
17:22:02 <syntaxglitch> I believe IntMap is a good bit more efficient than Map if your keys are ints or trivially converted to such
17:22:12 <gwern> IceDane: beware the data.array, the updates that bite, the GC that snatches! beware the vector, and shun the frumious uvector fusion!
17:22:25 <ClaudiusMaximus> @hoogle withArray
17:22:25 <lambdabot> Foreign.Marshal.Array withArray :: Storable a => [a] -> (Ptr a -> IO b) -> IO b
17:22:25 <lambdabot> Foreign.Marshal.Array withArray0 :: Storable a => a -> [a] -> (Ptr a -> IO b) -> IO b
17:22:25 <lambdabot> Foreign.Marshal.Array withArrayLen :: Storable a => [a] -> (Int -> Ptr a -> IO b) -> IO b
17:22:27 <aavogt> Saizan: I see now
17:22:29 <IceDane> Haha
17:22:50 <blackh> BrianHV: You save to "poke" the list using one of the poke list functions, then you can
17:23:03 <gwern> IceDane: haskell has good arrays; in fact, it has every kind of array. unfortunately, no one knows what the good ones are
17:23:23 <EvanR> DiffArray, in theory
17:23:28 <EvanR> or IOArray
17:23:37 <aavogt> IOUArray
17:23:43 <syntaxglitch> gwern, I just wish more people knew which the bad ones are
17:24:01 <syntaxglitch> Such as using !! with lists
17:24:05 <syntaxglitch> that's not a good array
17:24:05 <yuriks> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
17:24:10 <gwern> syntaxglitch: are they data.rray, IOArray, Diffarray, IOUArray or...?
17:24:11 <BrianHV> blackh: huh.  I'll google for that.  thanks.
17:24:20 <yuriks> what happened with the prelude reference? it's 404ing
17:24:24 <aavogt> DiffArray is supposed to be bad
17:24:59 <aavogt> yuriks: this one is fine: http://haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.1/Prelude.html
17:25:11 <blackh> BrianHV: The function you want is Foreign.Marshal.Array.pokeArray
17:25:23 <gwern> auugh. a fifth array!
17:25:28 <aavogt> @docs Prelude
17:25:28 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
17:25:39 <yuriks> aavogt: it seems like some symlink in the server broke in the last few days
17:25:49 <yuriks> that link was working a few days ago when I last accessed it
17:25:52 <aavogt> hmm, I suppose the old links were removed due to ghc-6.12.2 being released?
17:26:01 <yuriks> http://haskell.org/haskellwiki/Applications_and_libraries#Haskell_library_collections < this needs to be updated too
17:26:08 <gwern> @quote array
17:26:08 <lambdabot> nlogax says: because people don't go "but what are arrays, *really*???" about JS or whatever. i can use monads, i can use JS arrays..
17:26:15 <BrianHV> blackh: got it, thanks... presumably I can't export an infinite list, anyway.
17:26:16 * syntaxglitch has found broken links to GHC docs before as well :(
17:26:36 <EvanR> what the hell does that quote even mean
17:26:53 <blackh> BrianHV: You could do it with callbacks if you really wanted to.
17:27:29 <gwern> EvanR: it means that arrays are confusing and counterintuitive and opaque structures, and people tolerate them, so they can tolerate monads
17:27:50 <BrianHV> blackh: I don't think I do. :)  I was trying to figure out the feasibility of using haskell for my data layer and python for the UI.  not sure it's worth it.
17:28:19 <EvanR> gwern: sounds like a marketting problem, its called an array, which is simple in c ;)
17:28:27 <gwern> BrianHV: unless your data layer heavily leverages haskell, don't bother.
17:28:34 <gwern> python isn't *that* bad a language
17:28:52 <syntaxglitch> gwern, arrays aren't counterintuitive to most people, assuming you define counterintuitive as "doesn't exist in $LANGUAGE_PERSON_ALREADY_KNOWS"
17:28:55 <EvanR> its funny how much at work the stuff we end up doing is 'that bad'
17:28:59 <syntaxglitch> which seems to be the standard definition
17:29:03 <gwern> syntaxglitch: no one is born knowing arrays
17:29:07 <BrianHV> gwern: no, I like python.  but I'd like to jump into the pool as much as I can and start forcing myself to think functionally
17:29:09 <EvanR> which i always remind people to realize that means its bad to some extent
17:29:27 <blackh> BrianHV: If you want to figure out a way to do the FFI stuff, I'll try to help.  I'm quite good with FFI.
17:29:30 * DanC is interested in grokking max flow algorithms... thinking about parallel/functional implementations... struggles to grok http://hackage.haskell.org/packages/archive/fgl/5.4.2.2/doc/html/Data-Graph-Inductive-Graph.html#t%3AGraph and http://hackage.haskell.org/packages/archive/fgl/5.4.2.2/doc/html/src/Data-Graph-Inductive-Query-MaxFlow.html#augmentGraph
17:29:35 <gwern> EvanR: well, you have to keep in mind the costs of interfacing haskell to python. it's not trivial or free
17:29:45 <EvanR> yes
17:29:49 <syntaxglitch> gwern: yes, I'm being sarcastic about people being too lazy to learn new things :(
17:30:23 <gwern> EvanR: so unless using haskell has a payoff high enough to beat python, and also more than pay for the interface costs...
17:31:12 <gwern> BrianHV: if you want to learn haskell, do it all in haskell. half and halfing it is not much good. when it's all haskell, most haskellers can help. when it's half haskell and errors might be due to hacking around to get interfacing working...
17:31:26 <EvanR> right, so i dont see why pythons in the picture
17:31:29 <gwern> (or due to errors in the python ecosystem or your code)
17:31:37 <BrianHV> gwern: good point.  then the question becomes how easy it is to do the GUI work in haskell
17:31:42 <gwern> EvanR: right; it's an unhappy medium.
17:31:53 <gwern> go one way or the other, but the middle is worst of both worlds
17:32:29 <gwern> BrianHV: well, I hear that our opengl support is a thing of beauty. but I guess you mean gtk or qt or wxhaskell
17:32:34 <blackh> BrianHV: gtk2hs is really brilliant to use, though installing it can be a little frustrating.  Once you get it installed, though, it's very nice to work with.
17:33:07 <DanC> BrianHV, what is it you're doing? (I must have missed the beginning of the discussion)
17:33:15 <BrianHV> I'm familiar with the more mainstream wx editions, so that would probably be my default.  a bonus would be the option to go straight-cocoa on mac
17:33:34 <syntaxglitch> I don't think I'd normally use "opengl" and "beauty" in the same sentence...
17:33:35 <BrianHV> DanC: don't have anything concrete.  I was just messing around with interfacing haskell and python
17:33:36 <EvanR> objC bindings!
17:33:45 <DanC> I eat/sleep/breath python and I'm struggling to grok haskell, so I'm curious
17:34:10 <blackh> BrianHV: There is no decent Cocoa support for Haskell.
17:34:22 <mlh> gtkhs is easy o intsall if you're using fedora/ubuntun and I think debian
17:34:26 <DanC> gee... that seems odd... "I have these two pointy tools, so I thought I'd juggle them and see what happens." ;-)
17:34:40 <EvanR> haha
17:35:03 <blackh> DanC: Haskell is a warm fuzzy tool
17:35:07 <gwern> syntaxglitch: so I hear. the person was comparing it to python opengl bindings, which they said was a straight transcription of the C interface and so bad
17:35:21 <Pseudonym> blackh: You mean it's a monad tool.
17:35:26 <Pseudonym> Where monad == warm fuzzy thing.
17:35:39 <syntaxglitch> gwern: the Haskell bindings aren't much more than a wrapper around the C interface, from what I've seen
17:35:48 <DanC> I'm struggling to see what's warm fuzzy about: augmentGraph :: (DynGraph gr,Num b,Ord b) => gr a b -> gr a (b,b,b)
17:36:04 <DanC> (context: http://hackage.haskell.org/packages/archive/fgl/5.4.2.2/doc/html/src/Data-Graph-Inductive-Query-MaxFlow.html#augmentGraph )
17:36:11 <Pseudonym> DanC: What's your favourite programming language?
17:36:28 <syntaxglitch> Haskell's type system seems to improve the opengl interface to some extent, whereas I can imagine a dynamic language would have the opposite effect on opengl
17:36:42 <DanC> I'm most comfortable in C, but since swimming around in Scala a bit, I'm starting to grok functional stuff more
17:36:43 * Pseudonym would argue that there's nothing inherently warm or fuzzy about flow problems on graphs
17:36:45 <DanC> phpht
17:36:47 <syntaxglitch> On the other hand, OpenGL is the most ridiculously stateful API I have ever seen
17:36:47 <EvanR> everything works with the opengl interface in python ;)
17:36:51 <DanC> most comfortable in python, rather
17:36:51 <EvanR> you dont have to worry about types! ;)
17:36:55 <DanC> (I've done plenty of C too)
17:36:58 <Pseudonym> My point is there's nothing warm or fuzzy about most programming languages.
17:37:12 <Pseudonym> Seen from the point of view of someone unfamiliar.
17:37:32 <Pseudonym> Most people find Welsh hard to understand, but the Welsh have no problem with it.
17:37:33 <DanC> what's a typical way to learn haskell? (python has a great tutorial)
17:37:34 <syntaxglitch> Pseudonym, LOLCODE is warm and fuzzy
17:37:45 <Pseudonym> I CAN HAS OPENGL?
17:37:55 <EvanR> DanC: several popular tutorials, and online books
17:38:01 <EvanR> learn you a haskell for great good
17:38:05 <DanC> EvanR, care to recommend one?
17:38:06 <blackh> DanC: Speaking really generally, the advantage that Haskell gives you over Python is that the type system constrains your program so you can eliminate most runtime debugging.  The cost of that is things like "augmentGraph :: (DynGraph gr,Num b,Ord b) => gr a b -> gr a (b,b,b)".  But for big programs, the payoff is huge.
17:38:06 <EvanR> real world haskell
17:38:14 <Saizan> @where lyah
17:38:14 <lambdabot> http://www.learnyouahaskell.com/
17:38:17 <Saizan> @where rwh
17:38:17 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
17:38:19 <blackh> DanC: I'd recommend learnyouahaskell
17:38:29 <DanC> right, I'm familiar with the costs/benefits of static typing
17:38:34 <syntaxglitch> yeah, can't go too wrong with RWH for a fairly standard style of intro
17:39:32 <EvanR> DanC: you typed a complex type signature for a complex function, for a lot that quick python scripts do, you can leave off the types in haskell
17:39:33 <BrianHV> DanC: FWIW, I'm finding real world haskell more my speed than learn you a haskell... my recent background is python and C#
17:39:38 <DanC> the blog specificaly? or http://book.realworldhaskell.org/read/ ?
17:40:15 <Pseudonym> Many dynamic type proponents complain that a lot of time is spent "satisfying the whim of the compiler" wrt type errors.
17:40:26 <Pseudonym> What you're actually doing is debugging.
17:40:32 <blackh> DanC: Haskell is static typing done really well.
17:40:41 <BrianHV> DanC: you mean me?  I mean read/
17:40:46 <DanC> "In Haskell, we de-emphasise code that modifies data." <- isn't that an understatement?
17:40:48 <EvanR> you spend so much time fixing random runtime errors in a dynamic language its not even funny
17:40:59 <Pseudonym> DanC: No, it's about right.
17:41:07 <Pseudonym> We do have code that modifies data.
17:41:10 <DanC> just de-emphasize? not eliminate?
17:41:13 <Pseudonym> Right.
17:41:28 <Pseudonym> You need shared mutable data for many concurrency-like applications, for example.
17:41:30 <EvanR> writeIORef ptr "foobar" ;)
17:41:30 <SubStack> all side effects must be accounted for in triplicate and must abide by all state and federal regulations
17:41:34 <Pseudonym> Sometimes, communication channels aren't enough.
17:41:44 <Pseudonym> But even then, we do it in a principled way.
17:41:59 <Pseudonym> We make you think hard about whether or not you really need mutable data.
17:42:14 * DanC chuckles @ "... triplicate ..."
17:42:14 <Pseudonym> Same with OO programming, by the way.
17:42:39 <Pseudonym> OO languages make you think hard about who gets to see a piece of data, too.
17:43:21 <syntaxglitch> Pseudonym, either that or you just toss it in a "Singleton pattern" to "control access"
17:43:37 <Pseudonym> I thought that singletons were considered gauche these days.
17:43:40 <SubStack> OO encapsulation is like a dungeon crawler with locked doors and keys
17:43:41 <EvanR> so many misuses of oo
17:43:45 <SubStack> and dragons
17:43:57 <syntaxglitch> It's said that design patterns represent missing features from a language; singleton represents the missing feature of "piles of mutable global variables" :)
17:44:21 <Pseudonym> syntaxglitch: Right, perhaps what I should have said is that OOAD make you think hard about who gets to see a piece of data, though most OO languages don't enforce it.
17:44:23 <fax> @check \x -> gcd (x^2+3) (x^2+4) == 1
17:44:24 <lambdabot>   "OK, passed 500 tests."
17:44:28 <Pseudonym> Resulting in a lot of badly engineered code.
17:44:43 <SubStack> I recently wrote an ordered hash lib in javascript that achieved pretty much all of its functionality through foldr
17:44:47 <SubStack> catamorphisms++
17:45:01 <Pseudonym> Neat!
17:45:04 <Pseudonym> Did you profile it?
17:45:07 <syntaxglitch> (on the other hand, the "Interpreter Pattern" seems to represent the missing feature of "not being Lisp", har har har)
17:45:08 <SubStack> nah
17:45:15 <Pseudonym> I realise that profiling JavaScript is a waste of time in most cases...
17:45:16 <SubStack> probably it's slow as beans since it's an immutable interface
17:45:28 <Pseudonym> As slow as NetBeans?  That's pretty slow!
17:45:34 * DanC is happy to see that ubuntu satisfies "In this book, we assume that you're using at least version 6.8.2 of GHC"
17:45:47 <Pseudonym> Ubuntu++
17:45:50 * syntaxglitch implements a Javascript profiler: profileJavascript = const "Too slow!"
17:45:51 <SubStack> well the app that depends on it isn't noticably slower since the switchover
17:46:44 <DanC> re foldr... seen gjs's talk on "foldr considered (slightly) harmful"? all that code that cdrs down a list... not multi-core happy
17:47:10 <blackh> DanC: GHC version 6.10.X is the most stable
17:47:25 <Pseudonym> DanC: I would imagine that this really isn't what foldr is for.
17:47:33 <DanC> apt-get conjures up ghc6 6.10.4-1ubuntu2
17:47:35 <Pseudonym> It's the reduce part of mapreduce.
17:47:38 <EvanR> DanC: you cant parallelize a fold, its a big data dependency chain
17:47:48 <BrianHV> while we're talking about learning materials, can anyone recommend a good way to learn about persistent or other functional-friendly data structures?
17:47:49 <DanC> can't parallelize: exactly
17:47:59 <Pseudonym> powerSeries x cs = foldr (\c r -> c + x*r) 0 cs
17:48:03 <EvanR> but thats precisely the kind of for loop that you also cant parallelize
17:48:05 <Pseudonym> Hard to parallelise.
17:48:07 <DanC> the whole talk is about re-thinking data dependencies
17:48:22 <syntaxglitch> DanC, he advocated something more like a tree structure reduced as monoids, didn't he?
17:48:41 <DanC> yes. "use trees rather than lists whenever you can" is a good summary
17:48:45 <Pseudonym> Which is nice if your problem can be structured like that.
17:48:56 <Saizan> BrianHV: okasaki's book
17:49:15 <DanC> well, this graph code seems to qualify:
17:49:16 <DanC> getRevEdges ((u,v):es) | notElem (v,u) es = (v,u,0):getRevEdges es
17:49:16 <DanC>                        | otherwise        = getRevEdges (delete (v,u) es)
17:49:38 <DanC> there's no real data dependency; it's a set of edges
17:49:48 <blackh> DanC: Thanks for the recommendation about the talk - I'm interested in that subject.
17:49:55 <DanC> need a pointer?
17:50:00 <BrianHV> Saizan: thanks... I think I've come across that before, but I'll look again
17:50:01 <syntaxglitch> I suspect far more problems could be structured as parallel decomposition -> monoid reduction than actually are
17:50:48 <syntaxglitch> the problem is that cons lists are the first data structure many functional programmers reach for without thinking about it
17:50:48 <gwern> 'the more I look, the more evidence the law of 5s becomes'
17:50:50 <DanC> I looked at his slides; I later found a video but haven't actually watched it
17:51:10 <DanC> "law of 5s"?
17:51:29 <fax> ;_;
17:51:52 <gwern> back in the 90s, everyone would have understood what I meant
17:52:07 * Pseudonym consulted his pineal gland and now understands
17:52:13 <Cale> 5 standard deviations?
17:52:15 * gwern hands Pseudonym a hotdog without bun
17:52:22 <Pseudonym> Thanks, it's even Friday!
17:52:36 <gwern> not here, unfortunately. I'll just watch
17:53:05 <Pseudonym> I can't beat shapr for dedication, though.  He actually changed his surname legally to Erisson.
17:53:13 <twink> Lists are a lot of times like control stacks.
17:53:14 <joed> Hahaha
17:53:37 <gwern> Pseudonym: he wasn't born erisson?
17:53:41 <Pseudonym> Nope.
17:53:47 * gwern didn't know that
17:54:12 <syntaxglitch> changing his name to Erisson would have been even more impressive if it was his birth name
17:54:19 <Pseudonym> True!
17:54:31 <gwern> DanC: the law of 5s is a principal tenet of Discordianism. it says that everything is 5 or part of 5 in some way; if the connection to 5 isn't apparent, one needs to look harder
17:54:34 <Pseudonym> I wonder what happens if you try to legally change your name to your name.
17:54:47 <gwern> DanC: my commentary was that like monads, once you have the monoid concept, you start to see it everywhere
17:54:52 <syntaxglitch> Pseudonym, only one way to find out
17:54:53 <Pseudonym> DanC: The point being that just about any tenuous link can be justified if you try hard enough.
17:54:54 <gwern> DanC: like 5s
17:54:58 <EvanR> Pseudonym: society goes into a dead lock
17:55:08 <DanC> has anybody here been involved in haskell long enough to know if the compiler error messages used to be really bad? they're really bad in scala; I hope they get better. (see http://www.advogato.org/person/connolly/diary/71.html for my horror stories)
17:55:23 <EvanR> the messages are easy
17:55:27 <gwern> DanC: yes, they used to be really bad. one of the main reasons to use hugs was better errors
17:55:27 * Pseudonym considered getting out of jury duty by claiming Discordian Pope status, but turned out to be ineligible for other reasons
17:55:32 <gwern> DanC: ghc has gotten better though
17:55:35 <EvanR> instance not found for T1 T2, hint, add an instance
17:56:21 * gwern won't defend that one
17:56:30 <DanC> I keep reading articles about monoids, hoping it'll soak in. no light bulb so far, though I sorta grok the abstract mathematical concept
17:56:33 <syntaxglitch> Pseudonym, I've heard that just telling them you're a software developer will usually get you excused
17:56:38 <scotty> c_wraith: Hey, are you still here?
17:56:44 <syntaxglitch> Lawyers don't like jurors with analytical mindsets
17:56:47 <EvanR> monoids are simple
17:57:11 <Pseudonym> Actually, it depends on the case.
17:57:13 <gwern> DanC: did you try sigfpe's tree one?
17:57:19 <DanC> monoids seem to be simple in the way that binary digits are simple. you can build anything out of them, but it's not immediately clear how. ;-)
17:57:30 <EvanR> you are probably talking about monads
17:57:36 <DanC> oops
17:57:36 <DanC> yes
17:57:40 <c_wraith> scotty: yeah
17:57:42 * gwern almost said 'the sigfpe', sorter like 'the oleg'
17:57:45 <syntaxglitch> gwern, incidentally, have you noticed that the class definition for Monad is five lines of code?
17:57:52 <syntaxglitch> ;)
17:57:58 <gwern> syntaxglitch: hail Eris!
17:58:13 <EvanR> when i was a kid i thought i was the only one who knew about that crap
17:58:15 <DanC> I don't recall reading it, gwern
17:58:18 <gwern> syntaxglitch: notice how many letters 'monad' has
17:58:32 <syntaxglitch> indeed
17:58:37 <scotty> c_wraith: I guess I'll ask the people who are here again.  I went to go eat dinner, but now I think I've got some code that pretty clearly demonstrates what I'm trying to do.
17:58:48 <gwern> syntaxglitch: also, do you know what the other name of Haskell was? notice how many letters it too has!
17:58:51 <Pseudonym> So should the unit of use of obscure category theory in Haskell programs be the Wadler, the Cale or the Sigfpe?
17:59:06 <Mathnerd314> the monad
17:59:14 <gwern> Pseudonym: I'd call it the edwardk
17:59:21 <Pseudonym> Also a good choice.
17:59:23 <syntaxglitch> yeah, I'm with gwern
17:59:28 <syntaxglitch> note who maintains category-extras
17:59:33 * gwern prefers edward to jacob
17:59:33 <Pseudonym> True.
17:59:35 <DanC> heh... "Remain fearless in the face of error messages" -- http://book.realworldhaskell.org/read/getting-started.html
17:59:53 <scotty> Hey, can anyone help me with this Parsec code?  I'm pretty new to Haskell and don't know much about IO and how monads work.  My intentions should be pretty clear from the code.  http://pastebin.com/uxPV7vNh
17:59:59 <c_wraith> it's good advice.  some error messages are hard :)
18:00:09 <gwern> DanC: I will face my error and permit it to pass through me, and where it has passed there will be nothing. Only I will remain...
18:00:34 <Cale> scotty: That semicolon in simple is oddly-placed
18:00:37 <aavogt> scotty: if you do some IO, your function result should be  IO Char
18:00:45 <scotty> I got something like this: Couldn't match expected type `Char' against inferred type `IO b'
18:00:52 <EvanR> heres an error i get a lot, couldnt match expected type X against inferred type Y -> X, and its because i didnt pass enough parameters to the friggin function
18:01:11 <EvanR> so it would be nice if the message was 'you didnt pass enough parameters to the friggin function', but it cant, because thats a valid use sometimes
18:01:14 <scotty> aavogt: How do I "pull out" the value?  I want to dump the IO.
18:01:21 <Cale> scotty: run doesn't produce a Char
18:01:37 <daviddarais> scotty: the short answer is you never "pull out" a value from IO
18:01:41 <Cale> scotty: do putStr "parse error at"; print err -- is not a Char value
18:01:47 <syntaxglitch> lately I've been seeing a lot of errors that are 60+ lines of errors about missing or ambiguous class instances
18:01:56 <syntaxglitch> but that has more to do with me than with GHC...
18:02:09 <EvanR> :S
18:02:09 <scotty> Cale: Yeah, I know.  I was just demonstrating what I want to do.
18:02:10 <Cale> scotty: Instead, it's an IO action which has a result of type ()
18:02:11 <aavogt> EvanR: you could have warnings for partially applied functions... ocaml does
18:02:22 <EvanR> aavogt: even when they are well typed?
18:02:33 <aavogt> well they are optional warnings
18:02:43 <gwern> -Wall is quite common
18:02:45 <Cale> scotty: So, perhaps what you want is really something more like  run :: Show a => Parser a -> String -> IO ()
18:02:51 <scotty> I have a program that doesn't have anything to do with IO and I want to take the result of a parser and pass it to that program.
18:03:05 <Cale> scotty: And then in the second branch, where the parse succeeds, you'll want to, say, print the value that you parsed.
18:03:12 <syntaxglitch> all programs do something with IO in the end, that's the only way to run them
18:03:20 <scotty> Blah
18:03:26 <scotty> How can I explain this.
18:03:41 <Cale> scotty: Or you want to have the IO action produce a Maybe Char, so it'll have type IO (Maybe Char)
18:03:56 <daviddarais> scotty: here is my suggestion; rather than printing the error as an IO action in a do block, just call (error ("parse error at" ++ err))
18:04:31 <daviddarais> and then your function can be free of IO monad
18:04:37 <syntaxglitch> I wish people wouldn't use error
18:04:41 <DanC> hmm... [True, False, "testing"] is erroneous... in scala, it's fine; it's a List[Any]. haskell has no Any type?
18:04:42 <scotty> I guess what I need to do is get the character, do some evaluation, and then print out my value.  It seems that run will be the entry and exit point of my program
18:04:48 <Cale> Of course, that doesn't work so well if you intend to actually handle the error properly.
18:05:00 <pikhq> DanC: No, Haskell is not dynamically typed.
18:05:10 <DanC> scala is not dynamically typed either
18:05:11 * ddarius does s/error/(fix id)/ over all Haskell source code.
18:05:21 <syntaxglitch> DanC, it actually sort of does, but you can't do anything useful with it
18:05:26 <pikhq> "Any" implies the existence of dynamic typing. :)
18:05:34 <EvanR> @src Any
18:05:34 <lambdabot> Source not found. I feel much better now.
18:05:47 <EvanR> @instances Any
18:05:48 <lambdabot> Couldn't find class `Any'. Try @instances-importing
18:05:51 <ddarius> DanC: Haskell has no subtyping and thus no implicit conversions between types.
18:05:56 <syntaxglitch> DanC, what would scala code do with a list like that?
18:06:03 <aavogt> EvanR: so that kind of warning isn't the one you expect
18:06:19 <DanC> as I said: it becomes a List[Any]
18:06:24 <EvanR> i use a lot of partially applied functions
18:06:33 <pikhq> DanC: How is that well-typed? ;)
18:06:53 <EvanR> DanC: a list with any random types has like no use
18:06:54 <DanC> scala has a top type
18:06:54 <Cale> DanC: What operations are supported on values of type Any?
18:07:03 <aavogt> equality, no?
18:07:11 <DanC> yeah, equality
18:07:16 * DanC isn't sure what others
18:07:19 <Cale> DanC: If a value could be anything at all, then there is precisely nothing that you could really do with it.
18:07:38 <syntaxglitch> equality meaning "pointer equality" I presume
18:07:40 <Cale> (Though, perhaps "Any" doesn't really mean *anything*)
18:07:51 <EvanR> syntaxglitch: so basically, void*
18:08:00 <DanC> well, not pointer equality exactly, cuz booleans aren't boxed
18:08:02 <dolio> Cale: Clearly you're thinking too purely. :)
18:08:14 <EvanR> i bet theres an unsafe way to return the Any to a normal typed value
18:08:14 <pikhq> See the function id. It is the only not-pathological function of type a->a. :)
18:08:35 <DanC> yes, EvanR, scala has x.asInstanceOf[typeX]
18:08:41 <DanC> which can fail at runtime
18:08:45 <EvanR> this reminds me of C#
18:08:46 <Cale> Yeah, any function of type a -> a will either be id, or will fail to terminate on all inputs.
18:08:47 <syntaxglitch> well that's no fun
18:09:03 <EvanR> where that sort of dynamic cast is encouraged
18:09:16 <ddarius> EvanR: No it isn't.
18:09:27 <EvanR> and it can be safe with the 'typeOf' crap
18:09:33 <DanC> it's definitely discouraged in scala... especially in the #scala channel next door ;-)
18:09:38 <Cale> and any function of type a -> Bool will either be const True, const False, or will fail to terminate on all inputs.
18:09:47 <aavogt> @type typeOf
18:09:48 <lambdabot> forall a. (Typeable a) => a -> TypeRep
18:10:09 <dolio> @free a -> Bool
18:10:09 <lambdabot> Extra stuff at end of line
18:10:11 <ddarius> @hoogle isBottom
18:10:11 <lambdabot> Test.QuickCheck.Batch isBottom :: a -> Bool
18:10:14 <dolio> @free f :: a -> Bool
18:10:14 <lambdabot> f = f . g
18:10:25 <Saizan> since no one mentioned it: Scala's Any ~ Haskell's Dynamic, though you need explicit injections/projections
18:10:26 <DanC> hmm... Typeable... I wonder if that's like RefAny in scala
18:10:29 <daviddarais> isn't something like [forall a. (Show a) => a] supported through an extension?
18:10:40 <Cale> DanC: For values whose type is an instance of the Typeable class, you can use Data.Dynamic
18:11:03 <EvanR> why would you want these things ? :S
18:11:07 <ddarius> daviddarais: Yes, but that doesn't mean what I think you think it means.
18:11:12 <DanC> (Show a) <- on my stack of haskell idioms I don't yet grok
18:11:37 <EvanR> part of a type constraint
18:11:55 <EvanR> :t print
18:11:56 <lambdabot> forall a. (Show a) => a -> IO ()
18:11:59 <Cale> DanC: (Show a) is a class constraint. It's a way to insist that the type 'a' must be a member of the class Show, which means that it implements certain operations, in this case,  show :: a -> String
18:12:06 <syntaxglitch> DanC, "forall a. (Show a) => a" means a type you know nothing about except that it's an instance of Show
18:12:28 <DanC> ah. that reminds me... scala's Any has toString() a la java, I'm pretty sure
18:12:43 <EvanR> show is like toString
18:12:50 * DanC nods
18:13:01 <syntaxglitch> though I can't really think of anywhere that "forall a. (Show a) => a" would be a useful type
18:13:07 <Cale> syntaxglitch: actually, that means a type which is polymorphic and whose values can be treated as any particular instance of Show.
18:13:17 <DanC> Show is in the prelude, yes?
18:13:35 <Cale> It's not a useful type because the Show class has no operations which produce values of an arbitrary member of that class.
18:13:44 <Cale> DanC: yeah
18:13:52 <Cale> Read on the other hand...
18:13:57 <Cale> :t read "5"
18:13:58 <lambdabot> forall a. (Read a) => a
18:14:01 <dolio> exists a. (Show a, a) would make more sense.
18:14:06 <Cale> > read "5" :: Integer
18:14:07 <lambdabot>   5
18:14:10 <Cale> > read "5" :: Double
18:14:11 <syntaxglitch> Cale: ah, really? okay, I'm not entirely clear on how that bit of the language works
18:14:11 <lambdabot>   5.0
18:14:17 <Cale> > read "5" :: Complex Float
18:14:18 <lambdabot>   *Exception: Prelude.read: no parse
18:14:35 <Cale> okay, the parser for Complex is picky ;)
18:14:53 <dolio> Of course, that's isomorphic to String.
18:15:03 <dolio> Just like exists a. a is isomorphic to ().
18:15:08 <EvanR> > read "5 :+ 3" :: Complex Float
18:15:08 <syntaxglitch> dolio, modulo a bit of laziness
18:15:09 <lambdabot>   5.0 :+ 3.0
18:15:12 <Cale> But you can see that I can treat this value   read "5"  as members of various types, and the parser which is used is selected based on how I treat the value.
18:15:45 <Cale> > read "[1,2,3]" :: [Integer]
18:15:46 <lambdabot>   [1,2,3]
18:15:49 <Cale> > read "[1,2,3]" :: [Float]
18:15:50 <lambdabot>   [1.0,2.0,3.0]
18:16:09 <Cale> :t read "[1,2,3]"
18:16:10 <lambdabot> forall a. (Read a) => a
18:16:21 <Cale> :t 5
18:16:22 <lambdabot> forall t. (Num t) => t
18:16:41 <Cale> 5 is a value which is also polymorphic on its own
18:16:54 <Cale> It can be used as a value of any numeric type
18:17:07 <Cale> :t length
18:17:08 <lambdabot> forall a. [a] -> Int
18:17:08 <dolio> syntaxglitch: It probably wouldn't be unreasonable for a first-class exists to be unlifted.
18:17:11 <scotty> Okay, so maybe something like this: http://pastebin.com/LnqwXki0
18:17:26 * syntaxglitch always gets confused about when forall. actually means universal quantification vs. existential
18:17:27 <scotty> I stil have some errors though.
18:17:39 <Cale> On the other hand, the type for length doesn't have any constraints. The length function doesn't care *at all* about what operations are supported by the members of the list.
18:17:47 <Cale> It's only going to examine the list structure
18:17:53 <Cale> :t sort
18:17:54 <lambdabot> forall a. (Ord a) => [a] -> [a]
18:18:07 <Cale> sort, on the other hand, needs to have an ordering on the elements of the list
18:18:08 <ddarius> syntaxglitch: It's easy.  It always means universal quantification.
18:18:23 <aavogt> scotty: drop your type signature simple :: Parser Char
18:18:32 <Cale> Many types, particularly things like functions and IO actions, are not ordered or even orderable in any natural way
18:18:33 <aavogt> because it's wrong
18:19:27 <scotty> aavogt: I get that impression, but it appears as if Parser must be followed by one of a few pre-defined types.  Is that true?
18:19:30 <Cale> scotty: You modified simple so that now it's a Parser Scooby
18:19:40 <scotty> Cale: You can write Parser Scooby?
18:19:44 <Cale> Of course.
18:19:46 <EvanR> zoinks
18:19:48 <aavogt> you did
18:19:53 * DanC chuckles
18:19:53 <Cale> You can have Parser t for any type t
18:20:01 <scotty> Oh, okay.  Good!
18:20:14 <Cale> and Scooby is a type, so you can have parsers which return a value of that type
18:20:25 <ddarius> But, but... what will one do in a world without arbitrary restrictions?
18:21:01 <EvanR> this
18:21:06 <scotty> I still get: Couldn't match expected type `Scooby' against inferred type `a'
18:21:10 * DanC ponders 3 + 2 :: (Num t) => t
18:21:15 <scotty> In the expression "(eval x)'
18:21:18 <EvanR> > take 5 $ transpose [[0..], [0..], [0..]]
18:21:19 <lambdabot>   [[0,0,0],[1,1,1],[2,2,2],[3,3,3],[4,4,4]]
18:21:20 <EvanR> ;)
18:21:38 <scotty> What does that mean?
18:21:53 * ddarius considers an introduction to Haskell that starts with Prolog.
18:21:55 <scotty> It thinks eval should take an 'a'?
18:22:13 <Cale> DanC: Right, so what will happen is that when you pick a specific type for that expression (or it gets defaulted to something like Integer by numeric defaulting), the implementation for (+) and how to interpret the integer literals will be passed in as a sort of implicit function parameter
18:22:14 <EvanR> DanC: 3 and 2 are polymorphic, 3+2 can be any Num
18:22:17 <Saizan> ddarius: then goes through HM?
18:22:31 <dolio> You should start with twelf.
18:22:33 <ddarius> Saizan: That shouldn't even be necessary at that point.
18:22:34 <Cale> :t (+)
18:22:35 <lambdabot> forall a. (Num a) => a -> a -> a
18:22:47 <Cale> > (3 + 2) :: Integer
18:22:48 <lambdabot>   5
18:22:50 <Cale> > (3 + 2) :: Double
18:22:51 <lambdabot>   5.0
18:22:54 <Cale> > (3 + 2) :: Complex Double
18:22:55 <lambdabot>   5.0 :+ 0.0
18:22:58 <Cale> > (3 + 2) :: Complex CReal
18:22:59 <lambdabot>   5.0 :+ 0.0
18:23:05 <Cale> > (3 + 2) :: Rational
18:23:06 <lambdabot>   5 % 1
18:23:06 <syntaxglitch> Q: How many Prolog programmers does it take to change a light bulb?
18:23:23 <gwern> True
18:23:25 <DanC> ok... in scala, that would be: def +[A <: Num](a: A, b: A): A
18:23:28 <dolio> n + 1
18:23:49 <ddarius> gwern: It's "No."
18:24:06 <gwern> ddarius: bah. so I can't remember stereotypical jokes that are older than I am
18:24:06 <syntaxglitch> I've heard both punch lines
18:24:11 <Pseudonym> How many Prolog programmers does it take to change a light bulb?
18:24:13 <Pseudonym> 1 ;
18:24:14 <Pseudonym> 1 ;
18:24:15 <Pseudonym> 1 ;
18:24:19 <scotty> lol
18:24:20 <Pseudonym> Repeat ad nausaeum.
18:24:21 <syntaxglitch> but "No." seems more, uhh... accurate. At least to my experiences with Prolog :(
18:24:54 <Cale> DanC: Yeah, but rather than using subtyping, we instead have these things called typeclasses, which you can think of as being like predicates on types (things which are either true or false of any given type), and if the predicate is true, it means there's an implementation available of a particular set of functions or other values.
18:24:58 <Pseudonym> syntaxglitch: Use Mercury.
18:25:10 <DanC> frown... the hello-world program in section "A simple program" uses syntax that hasn't been explained so far.
18:25:12 <Cale> So Num itself is not a type, but a typeclass to which various types may belong
18:25:21 <Cale> Oh, where?
18:25:31 <EvanR> > print "Hello World"
18:25:32 <lambdabot>   <IO ()>
18:25:33 <DanC> in http://book.realworldhaskell.org/read/getting-started.html
18:25:45 <gwern> EvanR: did you really expect lambdabot to execute arbitrary IO?
18:25:47 <twink> I think Mercury's a spiffy language too.
18:25:49 <EvanR> no
18:26:04 <gwern> EvanR: that there was an example of Show defined for IO :)
18:27:06 <scotty> Cale: Did you see my last message?  Do you know what I'm still doing wrong?  When I change "print (eval x)" to "print 0," it of course works.  x must not be what I think it is.
18:27:30 <scotty> Cale: I thought x was a Scooby.
18:28:12 <scotty> http://pastebin.com/4uNQzVns
18:28:17 <Cale> scotty: It should be the result of your parser... do you have a paste of... ah :)
18:28:34 <Spockz> scooby snack?
18:28:45 <scotty> He-he...
18:29:11 <scotty> I should change my type to Doo and "eval" to "scooby"
18:29:15 <Cale> scotty: Your parser is p, which is a parameter to run
18:29:26 <scotty> Cale: Yes
18:29:33 <Cale> scotty: and the type signature for run says that the parser parameter is polymorphic
18:29:40 <scotty> Cale: Yes
18:29:46 <Cale> It's of type Parser a, for any type a which is in the class Show
18:29:56 <DanC> lots of sales pitch in "Why care about types?" I don't need that. I'm happy for a tutorial to presume I'm sold and just want to get down to business. maybe I should look for another.
18:29:57 <scotty> Cale: Doh
18:30:07 <Cale> and so in particular, you're not allowed to assume that it's a Parser Scooby specifically
18:30:10 <scotty> Cale: Scooby needs show defined
18:30:17 <ddarius> DanC: Then skip that section.
18:30:31 <Cale> Even if Scooby was an instance of Show, you couldn't apply eval to the result of the parser p
18:30:36 <EvanR> DanC: what do you expect from a business oriented book ;)
18:30:40 <Cale> scotty: Because p might be a Parser Integer, for instance.
18:30:42 <EvanR> that one is sold in bookstores
18:30:47 <Cale> scotty: Or a Parser [String]
18:30:51 <scotty> Cale: Oh, yeah, I see that.
18:30:59 <ddarius> EvanR: It's not the only one sold in bookstores.
18:31:04 <DanC> I didn't realize it was business-oriented; it was recommended to me when I asked about typical ways to learn the language
18:31:14 <scotty> Cale: So, what can I do if I still want to do some evaluation?
18:31:25 <Cale> scotty: So if you want to assume that the parser p is going to give you a Scooby value, you'll need to change the type of 'run'
18:31:36 <EvanR> one of the hurdles of haskell at work is convincing people its worth it, so you need sales pitch material ;)
18:31:59 <DanC> I'm tempted to try the language spec. I'm often satisfied with those.
18:32:07 <ddarius> DanC: It's pretty readable.
18:32:11 <scotty> Cale: Is it poor design to make run less general?
18:32:16 <Cale> scotty: So that it'll only be possible to pass in a value of type Parser Scooby, and you'll be able to apply eval to the result.
18:32:30 <Cale> scotty: Not if it's what's required to write your program.
18:32:33 <EvanR> DanC: theres a gentle introduction too
18:32:35 <DanC> a quick google search yields http://www.haskell.org/onlinereport/ , ddarius ; is that what I should read?
18:32:47 <ddarius> DanC: Yes, if you want to read the specification.
18:32:49 <Spockz> scotty: you could pass along functions that `fold' over the eitehr
18:32:51 <EvanR> @google haskell gentle
18:32:51 <lambdabot> http://www.haskell.org/tutorial/
18:32:52 <lambdabot> Title: A Gentle Introduction to Haskell, Version 98
18:32:58 <scotty> Cale: So, there's no other preferred way to do this?
18:33:16 <scotty> Spockz: I'm afraid I don't understand what you mean.
18:33:24 <Spockz> scotty: so then you can instantiate the run function with a specific function for Right and Left
18:33:51 <DanC> this "real world languages" book talks about "several more of the most common base types"; I instantly want to know what types are built in to the langauge
18:33:52 <Cale> Or just handle the Right case.
18:34:15 <Cale> You could add a parameter (a -> IO ()) to the run function which would specify what to do with the result of the parser
18:34:23 <Cale> (in the case that it succeeds)
18:34:24 <EvanR> DanC: the interpreter is a good place for that, for example :info Num
18:34:37 <scotty> Woo, it works at least! :)
18:34:40 * DanC finds http://www.haskell.org/onlinereport/basic.html#basic-types-and-classes
18:35:12 <DanC> interesting... otherwise isn't syntax.
18:35:16 <Cale> DanC: Yeah, that's a description of the pre-defined stuff.
18:35:22 <scotty> So, anytime you have a "do" in your function, is the expected return value always of IO?
18:35:28 <Cale> right, it's just a defined constant :)
18:35:31 <scotty> No, that can't be right.
18:35:36 <scotty> 'Cause simple has a "do."
18:35:40 <Cale> scotty: Not quite right :)
18:35:47 <Cale> scotty: It's got to be some monad.
18:36:02 <Spockz> http://pastebin.com/4UMtQHPX
18:36:05 <Spockz> maybe that'll help
18:36:16 <Cale> scotty: and all the actions listed inside the do must be of the same monad, and the type of the do-block as a whole will have the same type as the last action in it
18:36:20 <scotty> So, when I do return (Scooby x), I'm really returning some kind of monad with a Scooby?
18:36:37 <Spockz> it's late here, but if you want to know more about folds: http://alessandrovermeulen.me/2009/12/17/haskell-datatypes-and-folds/
18:36:40 <Spockz> good night
18:36:42 <aavogt> @type uncurry either
18:36:43 <lambdabot> forall a c b. (a -> c, b -> c) -> Either a b -> c
18:36:47 <Cale> return (Scooby x) will be an action in some monadic type
18:37:03 <Cale> It will be of type  m Scooby  for some monad m
18:37:15 <scotty> Oh...
18:37:50 <DanC> head-popper: (x,y) and (,) x y produce the same value
18:38:08 <scotty> I can't wait until I've finished reading Gentle Intro to Haskell and all this makes sense.  Unfortunately, I am doing a school assignment and I'm kind of having to rush.
18:38:10 <EvanR> > (,) 1 2
18:38:11 <lambdabot>   (1,2)
18:38:32 <aavogt> > (1,) 2
18:38:33 <lambdabot>   <no location info>: parse error on input `)'
18:38:44 <aavogt> Cale: is \bot on ghc-6.12?
18:38:49 <Cale> aavogt: no.
18:39:01 <Cale> It's 6.10.4 iirc.
18:39:08 <aavogt> otherwise that could be made to work
18:39:09 <Cale> Maybe .3
18:39:15 <EvanR> > 1 `(,)` 2
18:39:16 <lambdabot>   <no location info>: parse error on input `('
18:39:22 <Cale> lol
18:39:29 <EvanR> > 1 `((,))` 2
18:39:30 <lambdabot>   <no location info>: parse error on input `('
18:39:33 <scotty> I chose to do my assignment in Haskell because I wanted to get better, but I'm running out of time to do my project and I'm only about 1/3 of the way though Gentle Intro.
18:39:35 <Cale> That'd be fun
18:39:51 <Cale> scotty: The Gentle intro is not particularly gentle
18:40:03 <scotty> Cale: I'm doing okay with it, but I'm taking my time.
18:40:20 <scotty> Cale: Does it get harder toward the end?
18:40:41 <Cale> scotty: Yeah, well, it sort of races along and if you spend lots of time thinking about things away from the tutorial, you should be fine.
18:40:50 <scotty> Cale:
18:40:56 <scotty> That's what I've been doing.
18:40:58 <Cale> yeah
18:41:12 <scotty> Cale: I kind of just read it before bed and right some code to test things.
18:41:17 <scotty> *write
18:41:26 <Cale> anyway...
18:41:28 <Cale> :t return
18:41:29 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
18:41:35 <Cale> Ignore the first part of that...
18:41:40 <Cale> (Monad m) => a -> m a
18:42:00 <aavogt> kinds aren't that hard to read
18:42:07 <Cale> For any monad m, the return function takes a value of any type at all, a, and produces a value of type m a
18:42:25 <Cale> So, for example, since Parser is a monad, return can be used as type  Scooby -> Parser Scooby
18:42:56 <Cale> In particular, it'll give you the parser which "does nothing" (doesn't eat any of the input string), and always produces the value you specified.
18:43:31 <Cale> It can also be used at the type  Integer -> IO Integer
18:43:34 <IceDane> is there a way to transform an array into a list, so to speak?
18:43:42 <IceDane> Data.Array, btw
18:43:51 <EvanR> toList ?
18:44:00 <IceDane> doesn't seem so
18:44:01 <Cale> and it'll give you an IO action, which "does nothing" (does no input or output), and simply produces the given integer as its result
18:44:39 <Cale> IceDane: elems, or assocs
18:44:48 <Cale> :t elems
18:44:49 <lambdabot> forall i e. (Ix i) => Array i e -> [e]
18:44:51 <Cale> :t assocs
18:44:51 <IceDane> ah, yes
18:44:52 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)]
18:44:53 <IceDane> thanks
18:45:11 <IceDane> I was going to do zip (indices arr) (elems arr)
18:45:17 <IceDane> but assocs does exactly that
18:45:27 <Cale> yeah
18:45:39 <c_wraith> @src Ix
18:45:40 <lambdabot> class (Ord a) => Ix a where
18:45:40 <lambdabot>     range           :: (a,a) -> [a]
18:45:40 <lambdabot>     index           :: (a,a) -> a -> Int
18:45:40 <lambdabot>     inRange         :: (a,a) -> a -> Bool
18:45:40 <lambdabot>     rangeSize       :: (a,a) -> Int
18:45:50 <Cale> It's good for when you want to iterate over all the values in the array
18:45:54 <c_wraith> ah, it has range.
18:46:08 <Cale> Turn it into a list using assocs, and either recurse or fold or something over it. :)
18:46:54 <EvanR> is Rational a good way to do "dollars and cents"
18:47:04 <EvanR> 1/100 of a dollar
18:47:13 <c_wraith> Integer is a good way to do dollars and cents
18:47:18 <Cale> EvanR: It's workable, but not all that convenient.
18:47:19 <EvanR> right, fixed point
18:47:25 <ddarius> c_wraith: By just doing cents?
18:47:28 <c_wraith> yep
18:47:29 <Cale> You could also used Data.Fixed
18:47:33 <DanC> in particular, Integer is a good way to do cents
18:47:44 <EvanR> k , just figured Rational might be more natural
18:47:44 <c_wraith> dollars only show up at display time
18:47:51 <c_wraith> just do all your ops in cents
18:48:01 <Cale> grumble... someone fucked up the documentation URI's again
18:48:03 <EvanR> but wait! what about 'mils'
18:48:08 <applicative> But if one is compounding interest and so on.
18:48:09 <EvanR> 1/1000 of dollar
18:48:20 <Pseudonym> Either way, it gets quantised eventually.
18:48:39 <Cale> > 1.56 :: Centi Integer
18:48:40 <c_wraith> applicative: banks round (or floor, or whatever their specific policy is) to the cent on each interest payment
18:48:40 <lambdabot>   Not in scope: type constructor or class `Centi'
18:48:44 <Cale> ah, no import
18:48:46 * DanC ponders... Maybe is a Monad
18:49:01 <Pseudonym> If you need the granularity of 1/1000 of a dollar, use that in Data.Fixed or whatever.
18:49:17 <Cale> oh, right, Centi is a type on its own
18:49:21 <Pseudonym> c_wraith: Some wholesale items cost a fraction of a cent per unit.
18:49:24 <applicative> But in calculating the payment don't they have to work with a continuous function, at least in theory? (I don't know anything about it of course)
18:49:25 <EvanR> DanC: dont try too hard, maybe as a monad is useless ;)
18:49:33 <Pseudonym> But you can only buy multiples of 1000 units.
18:49:34 * EvanR waits for flames
18:49:57 <DanC> well, in scala, it's useful to do flatMap on Maybe[A]
18:50:13 <EvanR> is that like
18:50:14 <Cale> It's sometimes quite useful that Maybe is a monad, but that's rarely a defining characteristic of something
18:50:17 <EvanR> :t catMaybes
18:50:18 <lambdabot> forall a. [Maybe a] -> [a]
18:50:21 <ddarius> EvanR: It's bind.
18:50:41 <Cale> Saying 'foo is a monad' doesn't tell you a whole lot about 'foo' except that it's a type constructor, and there are a handful of operations available.
18:50:46 <syntaxglitch> Maybe as a monad is useless by definition; the only time you care is when all that happens is Nothing :)
18:50:51 <c_wraith> I use the fact that Maybe is a Functor and an Applicative a lot more than the fact that it's a Monad.
18:51:13 <syntaxglitch> the Applicative syntax is usually nicer anyhow
18:51:14 <idnar> @kind Centi
18:51:15 <lambdabot> Not in scope: type constructor or class `Centi'
18:51:17 <Cale> I don't understand the sentiment that Maybe is a useless monad instance.
18:51:32 <Saizan> the monadic interface of Maybe is quite useful when you're doing some simple "parsing"
18:51:37 <applicative> It's very useful for understanding what a monad is....
18:51:49 <Cale> Often it's really quite useful to chain together some operations, each of which might fail, and you want to collect all the failures.
18:51:49 <ddarius> The monadic interface of Maybe is quite useful.
18:51:51 * syntaxglitch was joking, though in many cases Either is preferable
18:51:58 <applicative> better than the Identity monad
18:52:23 <syntaxglitch> Nothing is about the least informative error possible
18:52:36 <ddarius> syntaxglitch: But it's informative in a highly local scope.
18:52:37 <EvanR> when learning haskell the maybe monad was a classic example of a monad, so i thought it actually got used that way
18:52:39 <Cale> syntaxglitch: Sometimes it's exactly as informative as it needs to be
18:52:45 <[swift]> anyone seen a good example of constructing ADTs with template haskell?
18:53:07 <idnar> EvanR: I'm pretty sure plenty of people use the Maybe instance of Monad
18:53:11 <yuriks> gah....
18:53:16 <syntaxglitch> ddarius, it's better than evaluating to bottom, to be sure
18:53:25 <yuriks> implementing Dijkstra's algo in haskell is kicking my ass -_-
18:53:34 <Cale> EvanR: It does get used, just maybe not as often as you'd expect.
18:53:45 <ddarius> syntaxglitch: I'm saying if your code can only fail in one way in some particular scope, you don't get any benefit out of using Either.
18:53:46 <idnar> Cale: no pun intended, eh?
18:54:00 <Cale> idnar: Hah, I hadn't even noticed that :)
18:54:06 <Cale> yuriks: I've implemented A* in Haskell...
18:54:08 <idnar> :)
18:54:21 <syntaxglitch> ddarius, fair enough
18:54:27 <applicative> Maybe is used for other things besides failure, for example, 'optional' arguments.
18:54:47 <copumpkin> ew
18:55:00 <applicative> (But that isn't likely to used its monadness)
18:55:10 <DanC> "All basic datatypes except for functions and IO are instances of this class." (i.e. Eq) but I don't see what "basic datatypes" are. maybe I skipped around too much
18:55:42 <syntaxglitch> DanC: probably means something like "datatypes that are in the Prelude"
18:55:42 <EvanR> Char Integer Int Bool Float Double Rational
18:55:55 <aavogt> also tuples, Either, Maybe...
18:56:03 <Cale> yuriks: If you'd like, I can give some pointers on how to translate imperative algorithms into functional ones.
18:57:06 <Cale> yuriks: Or, what in particular are you getting stuck on?
18:57:28 <Cale> DanC: Probably means the ones defined in the Prelude.
18:57:37 <Cale> that are not function types ;)
18:57:41 <DanC> could be more clear.
18:57:44 <Cale> (or IO)
18:58:20 * DanC feels his spec-reviewing habits kick in... wonders where comments are supposed to be sent
18:58:41 <Cale> Eq has just about everything which you could sensibly imagine an algorithm to compare the equality of two members of that type
18:59:12 <Cale> DanC: You'll find the specific instances for Eq in the Prelude itself.
18:59:15 <aavogt> Eq a => Bool -> a
18:59:21 <EvanR> @instances Eq
18:59:21 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
18:59:24 <Cale> (if you want a more precise specification of which instances exist)
18:59:52 <DanC> is the prolog part of the spec?
18:59:56 <DanC> prelude
19:00:01 <Cale> Yeah.
19:00:14 <DanC> aha... "In this chapter the entire Haskell Prelude is given."
19:00:17 <yuriks> Cale: the fact I don't have a mutable array I can modify, and that recreating lists all the time instead feels crappy
19:00:20 <Cale> Which is a bit of a problem, in that it's hard to change, and yet there are things about it which many people would like to change.
19:00:27 <Cale> yuriks: Use Data.Map
19:00:51 <yuriks> my professor has a pdf explaining how to implement it, I didn't understand any of it before and decided I would implement on my own, but I guess I'll give it another read
19:02:03 <EvanR> i know IO (), but what else is () good for?
19:02:34 <Cale> yuriks: If you understand how to implement something imperatively, there's a cheesy way to turn it into a functional program: turn each step of the imperative algorithm into a function, turn all mutable variables of the imperative program into function parameters, and have the functions call each other according to the control flow of the original imperative program
19:02:42 * DanC hates it when formal grammars are actually only semi-formal, e.g.: return 	 -> 	 a carriage return 
19:02:52 <DanC> is it really so hard to use something like \x0D?
19:03:10 <yuriks> DanC: even better, CR =P
19:03:32 <yuriks> Cale: and cheesy =P
19:04:50 <danderson> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25014#a25014
19:04:57 <Cale> yuriks: Does that description of mine make sense? I offer it up because I've actually done this before in order to make sense of what imperative programs are doing. The resulting functional program is usually kind of awkward to read, but since it's pure, you can feel a lot safer about refactoring it.
19:05:23 <Cale> I also *sort of* used it when working out how to implement A* in Haskell.
19:05:40 <Cale> (from the imperative description on wikipedia :)
19:05:41 <danderson> I came up with this lovely definition of all prime numbers. It takes around 5s of 99% computation (1% GC) to compute the sum of all primes < 10 million
19:05:46 <blackh> EvanR: I used () as a type in a type family for "layer id" in the case where I didn't want any layers in my space.  () is an instance of Enum, Ix and so on, so it did the job beautifully.
19:06:06 <danderson> are there obvious inefficiencies in its implementation?
19:06:20 <yuriks> Cale: yeah, I understood, just, it's cheesy XD
19:06:23 <DanC> ew... HotComments (11  Compiler Pragmas)
19:06:34 <danderson> (talking more of how haskell behaves with that program than the primality test - I went for a naive version of that)
19:06:38 <fax> what are the names of the two diagonal lines
19:06:40 <fax> ?
19:06:44 <Cale> danderson: It's quite a lot like my favourite one, except that you compute the sqrt rather than just sticking to integer arithmetic (which is more efficient, but the ideal would be to have an integer sqrt routine)
19:06:50 <fax> like there's horizontal and vertical for straight lines
19:06:56 <fax> but what about diagonals?
19:07:10 <Cale> danderson: It's not optimal, there are better algorithms.
19:07:16 <danderson> Cale: yeah, I lazed out on the sqrt. I couldn't find a squaring function and didn't feel like defining my own :)
19:07:36 <ManateeLazyCat> How to use "--cpp-include" in .cabal file?
19:07:36 <lambdabot> ManateeLazyCat: You have 1 new message. '/msg lambdabot @messages' to read it.
19:07:41 <idnar> Cale: would an integer sqrt be faster than taking the second power?
19:08:03 <EvanR> > sqrt 2
19:08:04 <lambdabot>   1.4142135623730951
19:08:06 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p*p <= n) $ primes
19:08:07 <lambdabot>   not an expression: `let primes = 2 : filter isPrime [3,5..]; isPrime n = al...
19:08:08 <EvanR> > 2^2
19:08:09 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p*p <= n) $ primes in primes
19:08:09 <lambdabot>   4
19:08:10 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
19:08:28 <danderson> right, exactly.
19:08:47 <c_wraith> @hackage primes
19:08:47 <lambdabot> http://hackage.haskell.org/package/primes
19:08:47 <Cale> idnar: an integer sqrt of n only has to be computed once, whereas you have to square each prime you're going to test
19:08:57 <idnar> Cale: oh, of course
19:09:14 <danderson> c_wraith: I wasn't proposing to use this definition. I just found the definition very zen in how it defines itself in terms of itself :)
19:09:32 <c_wraith> the paper referenced in the Primes package is worth reading.
19:09:37 <c_wraith> It's short, simple, and pretty informative
19:09:52 <c_wraith> the O'Neil paper, that is
19:10:07 <yuriks> is there a function that will delete an element matching a condition to a list and return that element (along with the new list)?
19:10:23 <yuriks> from a list*
19:10:24 <Cale> danderson: If you want some brilliantly fast primes implementations there's a lovely paper by Melissa O'Neill about the various functional implementations of the Sieve of Eratosthenes, and their complexity analysis...
19:10:26 <danderson> c_wraith: thanks for the reference, enqueued.
19:10:27 <ManateeLazyCat> I have file "struct.hsc" include "VteCharAttrFields.h", i have use "Extra-Source-Files" tag include ""VteCharAttrFields.h" this file, but struct.hsc haven't found this header file. And Axel tell me need "cpp-include", so how to use "cpp-inlude" in .cabal file?
19:10:31 <Cale> http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
19:10:42 <danderson> Cale: yup, c_wraith just pointed to it. Thanks!
19:11:03 <Pseudonym> yuriks: Not offhand, but you can do it with takeWhile/dropWhile.
19:11:12 <Pseudonym> If you don't want to bother rolling your own, that is.
19:11:23 <danderson> like I said, my main reason for posting was that I really liked the definition, and that I was wondering if it might trigger some obvious inefficiency in the runtime
19:12:35 <Cale> danderson: No, it's actually quite efficient.
19:13:08 <Cale> danderson: One problem with it is that the list of primes will remain in memory forever, being a top-level value, but that has advantages sometimes too.
19:13:24 <danderson> right, it's an extreme case of memoization
19:13:43 <danderson> so by far not the best choice for a single primality test
19:13:50 <danderson> but if a sieve is needed, very cool.
19:13:54 <Cale> yeah
19:15:36 <Cale> If you want to do a serious implementation, there are ones which are just a little bit longer (unfortunately just out of reach of the lambdabot one-liner range ;) which use a priority queue and wheel, and they're asymptotically and practically much faster.
19:16:22 <danderson> neat. In that paper you linked I presume?
19:16:30 <Cale> yeah
19:16:39 <danderson> cool, I'll find out about it soon then :)
19:16:56 <Pseudonym> Is there any other programming lanugage channel where when someone asks a question, the answer is "go read this paper"?
19:17:16 <scotty> Woo!  http://pastebin.com/LYF42zsJ
19:17:40 <EvanR> Pseudonym: theres a paper on that subject i believe
19:18:05 <danderson> Pseudonym: more to the point, is there any other programming language channel where "go read a paper" is taken as genuine help, rather than offending the person seeking answers
19:18:05 <Pseudonym> The Journal of Haskell Pragmatics.
19:18:14 <tensorpudding> Saying "look at this paper" usually isn't the thing you hear in programming language channels because they focus on working codebases over papers
19:18:38 <Pseudonym> Also, their papers are harder to read.
19:18:50 <Pseudonym> Have you ever tried to read a C++ committee draft?
19:19:01 <danderson> they lack the appropriate language to express thoughts :)
19:19:13 <tensorpudding> Many papers linked to on here are hard to read.
19:19:17 <danderson> obviously this complicates attempts at passing on those thoughts
19:19:54 <tensorpudding> Though it's not due to the lack of articulation, just the difficulty of what is being said.
19:20:09 <danderson> and that would be the difference :)
19:20:20 <Pseudonym> Right.  Easy Haskell is easy.
19:21:26 <tensorpudding> But a lot of the hard papers have little to do with Haskell and more to do with type/category theoretical maneuverings like those you'd read in those more difficult blogs
19:21:36 <danderson> hmm, could isPrime in the definition I/Cale gave be parallelized?
19:21:56 <danderson> My machine is pegged at a pathetic 25% of CPU usage, because only a single core is computing the sieve
19:22:34 <Cale> danderson: hmm...
19:23:27 <danderson> my initial instinct is that each individual computation in isPrime is too small to be worthy of parallelization
19:23:51 <EvanR> sum $ map (\n -> if prime n then n else 0) [1.1000000]
19:23:56 <EvanR> now parallelize map ;)
19:24:10 <danderson> cheater :P
19:24:16 <EvanR> lol
19:24:58 <scotty> Do any of you guys use the '$?'  Do you think it is more readable than using parentheses?
19:25:13 <orlandu63> it's more convenient
19:25:14 <tensorpudding> It's good to use $
19:25:26 <tensorpudding> But only if it makes things more readable
19:25:45 <danderson> random nugget of information: an Integer prime sieve up to 181223513 consumes 300M of ram
19:26:01 <scotty> Part of me like typing less code, but part of me things '$' is an awful choice of character.
19:26:03 <danderson> it's actually still going, the rts hasn't grown in a while.
19:26:06 <Makoryu> scotty: I tend towards writing "foo . bar . baz $ quux" rather than "foo (bar (baz quux))"
19:26:38 <blackh> scotty: I agree with you (why $ ??)
19:26:47 <DanC> while reading that paper on primes, I suddenly wonder: what of the technique of instrumenting programs with "print statements"?
19:26:57 <tensorpudding> I agree with the foo . bar . baz $ quux
19:26:58 <EvanR> blackh: the only ascii char left? :)
19:26:59 <DanC> I know it's gross, but...
19:27:09 <Cale> scotty: I use (.) a lot more than ($), but I will compose a bunch of functions using (.) and then apply the composite with ($)
19:27:09 <danderson> DanC: I recall simon PJ does that
19:27:19 <danderson> with careful application of unsafePerformIO at strategic locations
19:27:21 <scotty> Hm...
19:27:38 <EvanR> DanC: Debug.Trac
19:27:42 <EvanR> Debug.Trace
19:27:43 <Cale> There's no need to use unsafePerformIO directly
19:27:56 <tensorpudding> I looked at $ as being "hey, less parens to match and parse"
19:28:02 <danderson> yeah, but where's the fun in being safe
19:28:08 <DanC> Debug.Trace... ok
19:28:11 <Cale> Yeah, you can use Debug.Trace. It's less useful for debugging directly than it is for getting hold of inputs on which a program fails.
19:28:23 <Makoryu> Hmmm. Really, what alternatives do we have to ($) as the name for that operator?
19:28:27 <danderson> but yeah, shiny Debug.Trace. Sounds neat.
19:28:34 <Cale> (and then once you have those, just use ghci to evaluate things)
19:28:43 <shapr> hej juhp!
19:29:01 <juhp> shapr: yo - what's up? :)
19:29:08 <Cale> The usual trick for using trace is to add an extra guard to the top of a function which always fails:
19:29:11 <shapr> Playing with a pure Haskell tcp/ip stack, what's up with you?
19:29:25 <Makoryu> :t on
19:29:26 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
19:29:31 <shapr> :t off
19:29:31 <lambdabot> Not in scope: `off'
19:29:34 <shapr> foo!
19:29:36 <juhp> shapr: trying to get ghc to build again on fedora :)
19:29:38 <Cale> foo x y z | trace (unwords [show x, show y, show z]) False = undefined
19:29:45 <shapr> juhp: Ah, something actually useful!
19:29:47 <Cale> ^^ something like that
19:29:50 <juhp> hehe
19:30:01 <Cale> Note that it can make your function stricter
19:30:11 * shapr spanks his function
19:30:17 <[swift]> argh, i suck at monads
19:30:20 <Cale> and so just by annotating a program with such traces, you can break it, if it relied on laziness
19:30:23 <juhp> shapr: mm been running into some weird build issues
19:30:29 <[swift]> how do i make this work: [(DataD _ _ _ _ classes)] = runQ [d| data T = T deriving (Eq, Ord, Show) |]
19:30:30 <shapr> juhp: Evil Mangler?
19:30:38 <juhp> nah
19:30:39 <shapr> That's just so much fun to say :-)
19:30:45 <Cale> (I've done that before ;)
19:31:00 <[swift]> just need to pull the result of runQ out of the monad, but i'm confused as to how to do it
19:31:06 * DanC starts to grok ...where... syntax; in scala, it would be def
19:31:23 <EvanR> > x where x = 4
19:31:24 <lambdabot>   <no location info>: parse error on input `where'
19:31:26 <juhp> shapr: just the "ghc-stage1" command becoming "" in my builds...
19:31:27 <Cale> [swift]: Very interesting that you're writing template haskell code before understanding monads. ;)
19:31:28 <EvanR> :(
19:31:34 <aavogt> > let x = y where y = 1 in x
19:31:35 <lambdabot>   1
19:31:35 <shapr> juhp: Huh, that is weird.
19:31:41 <juhp> yeah pretty
19:31:41 <Cale> [swift]: do [(DataD _ _ _ _ classes)] <- runQ [d| data T = T deriving (Eq, Ord, Show) |]
19:31:52 <Makoryu> DanC: "foo where bar" is just sugar for "let bar in foo"
19:31:52 <juhp> did someone mention my name? :)
19:31:54 <Cale> [swift]: and then continue the do-block somehow
19:32:11 <[swift]> Cale: well i understand how to do it with do notation, but i really don't want a do block =) is that the only way?
19:32:29 <DanC> hmm... how come sometimes you write case ... of... and sometimes you just write f pat1 = ... f pat2 = ... ?
19:32:55 <fax> DanC well case doesn't define a new function but f does
19:32:59 <EvanR> function definitions are like case expressions
19:33:06 <EvanR> with a name
19:33:41 <Makoryu> DanC: The "f = foo; f = bar" syntax is also sugar for "f = case ... of foo; bar"
19:33:54 <aavogt> f can match on multiple arguments, which is more awkward with case
19:34:19 <DeathC200> hello
19:34:23 <DeathC200> everyone
19:34:32 <Makoryu> Yeah, desugaring by hand can make it hard to read
19:34:38 <Makoryu> That's why the sugar is there to begin with
19:34:40 <Makoryu> DeathC200: Sup
19:34:49 <EvanR> moar sugar
19:34:50 <aavogt> and to accomplish the same, you would write  \x y -> case (x,y) of (p1,p2)  -> ...
19:35:43 * DanC is still absorbing \x
19:36:09 <EvanR> > map (\x -> x + 1) [1,2,3]
19:36:10 <lambdabot>   [2,3,4]
19:36:13 <Makoryu> DanC: "f x y = foo" == "f = \x y -> foo"
19:36:15 <EvanR> > map (+1) [1,2,3]
19:36:15 <lambdabot>   [2,3,4]
19:36:19 <EvanR> \o/
19:36:36 <aavogt> it's the same as   (x =>  ...) in scala
19:36:44 <aavogt> if I remember correctly
19:36:56 <dibblego_> yes correct
19:37:28 <gwern> man, roman is so demanding
19:37:35 <DanC> ok, that's the impression I was getting
19:37:36 <jeffwheeler> Is there a more general term for an "accumulator" variable? E.g., if it holds the depth that increments on each recursive call.
19:37:46 <aavogt> what about latin?
19:38:11 <dibblego_> jeffwheeler State perhaps?
19:38:18 <jeffwheeler> dibblego_, I suppose that could work
19:38:20 <dibblego_> @type State
19:38:21 <lambdabot> forall s a. (s -> (a, s)) -> State s a
19:38:35 <gwern> 'are there really many foldl users?' 'over 2000' 'but that doesn't list the examples' 'fine, here's the 2000, the line, and file for each' 'that doesn't really help me though because they don't come with 2000 explanations of why foldl and not foldl'"
19:38:40 <gwern> at which point I feel like giving up
19:38:43 <aavogt> you can probably get by with Reader in that case
19:38:54 <jeffwheeler> dibblego_, Not looking for the actual Haskell type, just the generic term
19:39:03 <jeffwheeler> dibblego_, actually, just writing C, but couldn't think of the name
19:39:24 <aavogt> though that's only if you don't care how deep it went without looking at the function's result
19:40:04 <dibblego_> I think "state monad" might be the term
19:40:14 <jeffwheeler> I was thinking something like "collector", but "state" works too
19:46:21 <siracusa> How do you set the background color of a Gtk2Hs label?
19:54:02 <Pseudonym> I suspect that 80% of the time, foldl gets transformed to foldl' if it's correct anyway.
19:54:16 <Pseudonym> Admittedly, that's a completely made-up number.
19:54:47 <Pseudonym> But strictness analysis is pretty good these days.
19:54:54 <Pseudonym> And foldl is almost always inlined.
19:58:38 <gwern> Pseudonym: don't you have to turn on -O2?
19:58:47 <gwern> cabal defaults to -O
19:58:52 <Pseudonym> Maybe.
19:59:00 <Pseudonym> Why does cabal default to -O?
19:59:19 <gwern> Pseudonym: well, it's hardly going to default to no optimizations
19:59:23 <ddarius> Pseudonym: To minimize compilation times and because it allegedly doesn't make "that much difference."
19:59:41 <ivanm> and on some architectures -O2 is apparently bad
19:59:48 <Pseudonym> OK, _that_ I believe.
20:00:05 <gwern> ivanm: I don't rmember that; 'twas -O3 that was sometimes bad I thought
20:00:06 <Pseudonym> Which suggests that some options need to be juggled between -O and -O2.
20:00:17 <ivanm> gwern: for C, yes
20:00:20 <tensorpudding> People use O3?
20:00:26 <gwern> tensorpudding: until it was removed
20:00:27 <ivanm> but on sparc I think even O2 is bad
20:00:30 <Cale> -O3 is meaningless
20:00:31 <p_l> tensorpudding: sometimes
20:00:45 <gwern> ivanm: we have many sparc users?
20:00:46 <EvanR> -O9999
20:00:47 <Cale> ghc clamps the number to 2
20:00:55 <ivanm> gwern: dcoutts_ used to use sparc...
20:00:58 <tensorpudding> I vaguely remember seeing gcc -O3 back in the day.
20:00:59 <Cale> Though in the past, -O3 did nothing at all, silently
20:00:59 <ivanm> don't know if he still does
20:01:04 <tensorpudding> It was only on Gentoo though.
20:01:11 <gwern> actually, I'm not sure sparc is worth supporting at all. has oracle said it's going to continue supporting it?
20:01:14 <ivanm> and ben got the free sparc box from sun to make the NCG for it...
20:01:31 <Pseudonym> If you need Sparc, Sparc is what you need.
20:01:34 <ivanm> tensorpudding: gentoo docs recommend against -O3 strenuosly
20:01:46 <Pseudonym> That sounds like a tautology, I know.
20:01:53 <gwern> Pseudonym: yes. it does.
20:02:00 <Pseudonym> But if you lose money for every minute of downtime, Sparc is a good option.
20:02:02 <ivanm> Pseudonym: ... but?
20:02:06 <gwern> sparc! it has what sparc-cravers crave!
20:02:09 <ivanm> oh, there's the but
20:02:14 <tensorpudding> It was in other people's config files, I never once saw Gentoo's examples use O3
20:02:32 <gwern> Pseudonym: can't remember the last time my processor crashed...
20:02:39 <gwern> even though it's x86
20:02:52 <Pseudonym> Sparc has even redundant backplane busses.
20:03:08 <EvanR> and rear spoilers
20:03:13 <gwern> "Numbers that fool the Fermat test are called Carmichael numbers, and little is known about them other than that they are extremely rare. There are 255 Carmichael numbers below 100,000,000....In testing primality of very large numbers chosen at random, the chance of stumbling upon a value that fools the Fermat test is less than the chance that cosmic radiation will cause the computer to make an error in carrying out a 'correct' ...
20:03:19 <gwern> ... algorithm.\u000aConsidering an algorithm to be inadequate for the 1<sup>st</sup> reason but not for the 2<sup>nd</sup> illustrates the difference between mathematics and engineering."
20:03:26 <Pseudonym> No, me neither.  But I knew someone who did IT support for a stock exchange.
20:03:32 <Pseudonym> They were allowed 30 min downtime a year.
20:03:44 <Pseudonym> Preferrably planned downtime.
20:03:58 <tensorpudding> Nice HTML tags there.
20:04:17 <gwern> tensorpudding: timely or text, pick one >.<
20:05:47 <[swift]> hmm, i guess i see the real problem, you just can't pull stuff out of the quotation monad, perhaps because you can run IO inside it
20:06:26 <ddarius> Stuff isn't "in" a monad(ic value) there to be "pulled out."
20:06:43 <gwern> > head [1]
20:06:44 <lambdabot>   1
20:06:50 <ddarius> > head []
20:06:50 <lambdabot>   *Exception: Prelude.head: empty list
20:07:26 <ddarius> :t let safePerformIO io = error "No value" in safePerformIO :: IO a -> a
20:07:27 <lambdabot> forall a. IO a -> a
20:07:39 <Nola> hi I am having a problem with Haskell
20:07:48 <ddarius> Nola: Switch to Perl.
20:07:54 <Pseudonym> You've come to the right place, Nola.
20:08:10 <ivanm> ddarius: :O I thought (unlike other langauge channels) we were meant to be _nice_ to new users
20:08:17 <ivanm> has the policy changed or something?
20:08:17 <gwern> ddarius: but then Nola has two problems
20:08:21 <[swift]> ddarius: how do you mean? doesn't "return x" wrap x with the monad's data constructor? hence once can imagine the inverse operation of removing the outer constructor
20:08:22 <ivanm> gwern: lol
20:08:35 <ddarius> [swift]: No.  It doesn't.
20:08:43 <Pseudonym> gwern: One of them being ddarius.
20:08:45 <ivanm> [swift]: it's not that simple in most cases
20:08:54 <ivanm> Pseudonym: well, that makes 3 then
20:09:20 <gwern> ivanm: oh, the policy has always been 'avoid success at all costs'. the higher ups finally realized #haskell was not proactively forwarding the core competencies of the collective vision
20:09:29 <Pseudonym> Bingo, sir.
20:09:32 <ivanm> gwern: ahhh
20:09:38 <Nola> i am creating a group of records in a file/module and a few of them have record fields with the same name
20:09:47 <Pseudonym> We should calendar some facetime so we can move forward on this.
20:09:51 <Nola> its not true that this language actually *cant* have 2 getters for fields with the same name?
20:09:54 <ivanm> Nola: huh?
20:09:57 <Nola> i must be overlooking something
20:10:07 <ivanm> Nola: right, you can't have two different record data types with the same field name
20:10:13 <gwern> ivanm: Foo { bar = x, bar = y} is the issue
20:10:13 <ivanm> since then they would have different types
20:10:15 <gwern> I think
20:10:34 <Nola> ok forget haskell
20:10:35 <ivanm> gwern: nah, Foo { bar :: Int } and Baz { bar :: Int} is the issue methinks
20:10:39 <gwern> oh right right
20:10:40 <ivanm> Nola: why?
20:10:42 <EvanR> haha
20:10:43 <Nola> too many problems with basic stuff
20:10:46 <holmak> Nola: I like to put them in separate modules and use namespacing
20:10:59 <EvanR> the standard way is a separate namespace
20:11:01 <ivanm> Nola: that's because the selectors are _functions_
20:11:15 <Nola> ivanm, so ?
20:11:18 <ivanm> EvanR: *shrug* it's not a mandatory standard, so who cares
20:11:20 <Nola> that doesnt make it any less horrible
20:11:31 <EvanR> right, but i think this would make Nola feel better
20:11:36 <ivanm> Nola: why is it a problem?
20:11:39 <[swift]> ivanm, ddarius: i will have to try to get a better grasp of monads, then; i guess the type signature of return is misleading me
20:11:43 <holmak> records aren't the most pleasant part of Haskell, but they are worth it
20:11:48 <gwern> Nola: there's no agreement on what a better record system would be. there have been a *lot* of proposals
20:11:49 <Nola> cause this is like programmign language basic feature #15
20:12:03 <Nola> you cant even have 2 fields with the same name how can you take haskell seriously?
20:12:07 <ivanm> everyone agrees that the record _syntax_ is broken, but I don't see any problem with disallowing different record datatypes from having the same function
20:12:25 <Pseudonym> ivanm: With the caveat that it's only a problem if they're in the same module.
20:12:28 <ddarius> ivanm: I don't agree with that at all.
20:12:29 <gwern> Nola: that's about as sensible as saying 'you can't even have 2 global variables how can you take haskell seriously?'
20:12:31 <EvanR> field names arent as critical as in other languages
20:12:49 <ivanm> Nola: let's say we have "data Foo = Foo { baz :: Int }" and "data Bar = Bar { baz :: Int }"; if I now use the baz function somewhere, which datatype does it use?
20:12:53 <fax> Nola: fields with the same name? O_o
20:12:57 <holmak> It's unfortunate, but easy to work around. Don't let this deter you!
20:12:58 <Pseudonym> FWIW, I agree with ddarius.  Haskell's only real wart is the namespace/module system.
20:13:00 <ivanm> ddarius: that it's broken?
20:13:01 <fax> Nola: btw if it was up to me there would be NO records
20:13:06 <Nola> ivanm: thats irrelevant
20:13:07 <Pseudonym> It's better than having _no_ module system, of course.
20:13:18 * Pseudonym is glad it's not up to fax
20:13:19 <ivanm> Nola: how is it irrelevant? _that_ is precisely the problem!
20:13:23 <fax> :)
20:13:25 <gwern> fax: the records just desugar down to ADTs
20:13:25 <Nola> its not a problem
20:13:30 <gwern> fax: or so I understood
20:13:31 <ddarius> ivanm: Correct.  Records are rather simplistic, but they aren't broken.
20:13:35 <fax> gwern rots your teeth
20:13:39 <EvanR> i havent had a problem with records so far
20:13:44 <Nola> Theres a million other syntax solutions you could use instead of the "1 most broken and conflicting one you could possibly present" which you just presented
20:13:45 <gwern> fax: and gives you cancer of the semicolon
20:13:46 <EvanR> or the namespaces
20:13:46 <ivanm> ddarius: OK, not "broken", but "not done right"
20:13:50 <fax> yes!
20:14:03 <Nola> i say theres a problem so you post "current syntax" and then show me how it doesnt work
20:14:04 <fax> "Theres a million other syntax solutions" -- I agree with this
20:14:05 <Nola> whats the point of that
20:14:06 <ivanm> Nola: so you know more than all the people who designed Haskell?
20:14:07 <EvanR> Nola: if you dont use a namespace, then you cant complain about conflicting names
20:14:12 <fax> and THAT is the reason I would throw out records
20:14:19 <fax> out of amillion things, ONE has to be better
20:14:23 <Makoryu> I dunno about you guys but I like the way OCaml handles duplicate method names
20:14:34 <ivanm> Nola: just because language Blub does things differently means that Haskell's way is wrong
20:14:38 * Pseudonym agrees with Makoryu
20:14:43 <gwern> Nola: incidentally, 'I want two conflicting record fields' is one of those 'you're probably doing that wrong' things; why do you want such a thing? likely you actually want to do something different, like use a typeclass
20:14:44 <ivanm> Makoryu: what's that?
20:14:45 <Makoryu> It would be nice if we could somehow unify that with typeclasses
20:14:57 <ddarius> ivanm: There's a solution today that solves the "problem" with records that everyone complains about, they are just too lazy to do it.  I think the "correct" solution, using Haskell's namespacing mechanisms for namespacing rather than adding a new one, can be extended in a simple and natural way to solve the "problem" with records and provide other benefits as well.
20:15:01 <Nola> how about RecordType.getter
20:15:13 <ivanm> that's ugly
20:15:17 <Nola> so what
20:15:27 <Nola> whats the big deal
20:15:28 <monochrom> Nola comes from a world without type inference. Therefore whenever you write "s.baz" clearly we know whether it's Foo's baz or Bar's baz because clearly s has a manually declared type.
20:15:29 <holmak> unfortunately period is already used for a ton of other things
20:15:29 <EvanR> Nola: how about RecordType.fieldName
20:15:31 <Pseudonym> ivamn: Is it more or less ugly than structnameField?
20:15:37 <gwern> Nola: RecordType.getter? and presumably a .setter? that's definitely a 'you're doing that wrong' sounding thing
20:15:37 <EvanR> Nola: which haskell already has
20:15:37 <ivanm> Nola: let's consider times when you export the record selector function but not the constructor
20:15:43 <Pseudonym> Which is what people tend to do anyway.
20:15:59 <Nola> EvanR: thats what I mean
20:16:01 <ivanm> Pseudonym: I would argue that if you have that kind of situation, you're doing something wrong
20:16:05 <Nola> a function called Animal.name
20:16:12 <EvanR> Nola: haskell already does this
20:16:20 <Nola> no it doesnt
20:16:23 <EvanR> yes it does
20:16:24 <ivanm> EvanR: yes, for _modules_
20:16:30 <EvanR> import qualified Animal
20:16:33 <Nola> I dont want to create 500 .hs files
20:16:37 <EvanR> why not
20:16:38 <ivanm> Nola: you have to define it in a separate module
20:16:41 <Nola> because thats ridiculous
20:16:43 <gwern> EvanR: you're not helping
20:16:49 <Nola> i am grouping things together how they are in my mind
20:16:51 <ivanm> Nola: why are you defining 500 record-based datatypes?
20:16:54 <Makoryu> ivanm: In OCaml, you can have an abstract type signature that will match any object that has the specified field names with the specified types
20:16:55 <Pseudonym> Nola: If you have 500 records with the same field name, you really ARE doing something wrong.
20:16:57 <Nola> not in some filesystem insanity just because of a language flaw
20:16:59 <syntaxglitch> just use the record system in HList, problem solved
20:17:01 <[swift]> Nola: people in the Java world do that routinely, fyi =)
20:17:06 <gwern> syntaxglitch: you're not helping either!
20:17:06 <ivanm> Makoryu: so kind of implicit typeclasses?
20:17:09 <syntaxglitch> :D
20:17:12 <Makoryu> ivanm: Pretty much
20:17:26 <ddarius> I've only written Perl thrice, but I'm pretty sure this issue doesn't come up in Perl (one way or another...)
20:17:26 <ivanm> Nola: I think you're trying to bring over how you programmed from other languages into Haskell
20:17:29 <syntaxglitch> "use type hackery" is my solution to far too many problems
20:17:35 <EvanR> exactly, records arent for everything, only for records. and how many records do you think youll need in a given project
20:17:37 <Nola> ivanm thats not an excuse for the problem
20:17:47 <Pseudonym> ddarius, Perl has its own problems in this regard, yes.
20:17:47 <holmak> Nola, an easy solution is "data Foo { String :: fooName, Int fooHeight }"
20:17:49 <ivanm> no, that's the root cause of the problem
20:17:52 <ivanm> Haskell /= C
20:17:56 <gwern> holmak: that's a hack.
20:17:57 <ivanm> or Java, or any other langauge
20:18:08 <holmak> absolutely
20:18:13 <ivanm> holmak: that doesn't even make sense...
20:18:18 <Pseudonym> Nola, one other thing you should keep in mind is that in Haskell, you're encouraged to use abstract types rather than concrete ones.
20:18:19 <holmak> why not?
20:18:29 <ivanm> holmak: String :: fooName? wtf?
20:18:41 <ivanm> Pseudonym: precisely
20:18:42 <holmak> Did I get that backward?
20:18:42 <gwern> holmak: the right solution is for Nola to describe what Nola really wants, us to tell him the idiomatic solution, and then conclude that records are not that common and so it isn't a huge deal
20:18:43 <Pseudonym> If you find yourself needing to access a record field, then you're working on concrete data rather than an abstraction.
20:18:46 <ivanm> holmak: yup
20:18:59 <holmak> Sorry, I typed faster than I thought
20:19:01 <ddarius> (Incidentally, the Java solution would be 500 .class files...)
20:19:02 <EvanR> i agree with gwern
20:19:08 <Pseudonym> Yes, I agree.
20:19:12 <Pseudonym> So, Nola, what are you trying to do?
20:19:25 <Nola> i give up im too frustrated
20:19:26 <holmak> I don't use records very often :D
20:19:30 <Nola> i will check back on haskell in a few years
20:19:38 <EvanR> when it supports java? ;)
20:19:43 * syntaxglitch wishes someone would just explain to him how to pound nails in with this screwdriver instead of talking about hammers :(
20:19:44 <ivanm> Nola: when you say that you've visualised how the data types all go together, that to me indicates you've thought about how you would write it in some other language
20:19:52 <Nola> When it can do "basic things"
20:19:52 <Makoryu> Nola: Okay. I suggest that in the meantime, you read your SICP
20:20:09 <ivanm> heh, at least Nola isn't as bad as the person who bitched and refused to touch Haskell because of negation syntax...
20:20:24 <Makoryu> ivanm: I dunno, negation syntax bugs me too
20:20:25 <Pseudonym> Nola: Did you know that Welsh (mentioned earlier) doesn't have words for "yes" and "no"?
20:20:26 <ivanm> (and that you had to do something like "map (subtract 3)" )
20:20:28 <EvanR> Nola: basic things like mutable global variables?
20:20:39 <Makoryu> Really, "-5" should be one token
20:20:43 <ivanm> Makoryu: but how often do you have to do it that its such a big deal?
20:20:44 <Pseudonym> Most people would think those basic things in any language.
20:20:59 <Pseudonym> Just sayin'.
20:20:59 <syntaxglitch> Some languages don't have basic things like lambda abstractions, complaining about Haskell's records is pretty minor in comparison
20:21:00 <tensorpudding> That sounds like a snowclone
20:21:03 <ivanm> Pseudonym: how about true and false? :p
20:21:10 <ivanm> syntaxglitch: exactly
20:21:11 <Pseudonym> ivanm: Don't know about that.
20:21:30 <ivanm> this to me sounds too much like a Blub programmer complaining that they have to change how they think/program
20:22:01 <Makoryu> Yeah! Why should people have to change how they think when learning a language with a reputation for changing how you think?!
20:22:09 <Pseudonym> gwern, you have a Welsh-sounding name.  Wyt ti'n gallu siarad Cymraeg?
20:22:17 <tensorpudding> (there are a lot of programming language aphorisms which are snowclones"
20:22:20 <gwern> ivanm: yes, but it'd be rude to go all paul graham or perlis on them
20:22:33 <gwern> Pseudonym: it is welsh-sounding, yet I don't know welsh. sorry
20:22:39 <Pseudonym> Right, just curious.
20:22:40 <monochrom> I am not sure why you people have a soft spot or something for announcements of the form "I'm frustrated, I will forget haskell because of trivial technicality X".
20:22:41 <ivanm> Makoryu: lol
20:22:43 * syntaxglitch doesn't like record syntax either, but it's not even in the top 10 things in Haskell he'd complain about most
20:22:48 <ivanm> @remember Makoryu Why should people have to change how they think when learning a language with a reputation for changing how you think?!
20:22:48 <lambdabot> It is forever etched in my memory.
20:22:59 <blackh> Nola: The record stuff you mention is really not a big deal.
20:23:14 <Pseudonym> Nola, the point is that what is considered basic in one language may be marginal in another language.
20:23:21 <gwern> Pseudonym: interesting that google can right away tell me that that is 'Do you speak welsh?'
20:23:22 <ivanm> tensorpudding: there are? where?
20:23:30 <gwern> @flush
20:23:34 <Pseudonym> gwern: There you go.
20:23:35 <ivanm> ta gwern
20:23:57 <tensorpudding> The hammer/screwdriver one.
20:24:09 <ddarius> gwern: Soon researchers will stop striving for human level AI and start striving for Google level AI.
20:24:11 <tensorpudding> Though I guess that isn't explicitly related to programming.
20:24:56 <gwern> ddarius: 'we are making progress. yesterday, our program proved fermat's next-to-last theorem.'
20:25:26 <ivanm> ddarius: "google level"?
20:26:39 <Pseudonym> You know, English doesn't have a third-person netural personal pronoun.  Some people think _that's_ a basic feature.
20:26:43 <Nola> its a big deal for me
20:26:52 <Nola> i have a really tricked out text editor i worked on for a long time
20:27:01 <Pseudonym> Cool.
20:27:05 <Nola> and it does some special stuff for editing files
20:27:14 <Pseudonym> What sort of thing?
20:27:15 <Nola> haskell forces me to create endless files on the filesystem
20:27:19 <Nola> that isnt compatible with me
20:27:28 <Nola> i dont like that and i will never get used to that
20:27:40 <Nola> so I gotta find a new language
20:27:43 * gwern reflects that Nola sounds stranger by the second
20:27:50 <bremner> Nola: ok, good luck.
20:27:53 <DanC> ew... f.. 	 f .. (two tokens)  ; F.. 	F.. (qualified `.')
20:27:57 <ivanm> gwern: agreed?
20:27:59 <gwern> what sort of tricked out text editor requires one to create reams of records?
20:28:13 <syntaxglitch> fortunately with Haskell you can create endless files safely, since only the ones you actually use will be created
20:28:14 <Pseudonym> Nola, Haskell is hardly the only language that has one file per namespace.
20:28:18 <gwern> how can it even know what records are in haskell? Nola surely isn't competent to user haskell parsers
20:28:21 <Pseudonym> Java was previously mentioned.
20:28:29 <Makoryu> Nola: How about Scheme. Read SICP
20:28:31 <ivanm> gwern: I was under the impression that Nola was using a "tricked out" editor to edit files, but it's so "tricked out" it doesn't like things being in more than one file
20:28:49 <EvanR> lol
20:28:55 * DanC wonders if he can delegate knowledge of haskell lexical syntax to emacs...
20:28:58 <gwern> ivanm: that would prevent him from creating multiple files, not encourage them
20:29:05 * ivanm wonders which editor is possible of being more than "tricked out" than emacs, which is more than capable of dealing with Haskell files
20:29:19 <syntaxglitch> maybe Nola is using ed
20:29:24 <syntaxglitch> it is the standard editor, after all
20:29:26 <gwern> the standard text editor
20:29:31 <EvanR> emacs has a lot of stuff for haskell
20:29:33 <ivanm> Nola: oh, and Haskell doesn't force you to use endless files; in fact, GHC will complain if a file doesn't end@!
20:29:35 <ivanm> :p
20:29:37 <ivanm> s/@//
20:29:53 <gwern> @quote sicp
20:29:54 <lambdabot> gwern says: I sometimes think a CS degree could be replaced by reading Alice in Wonderland, GEB, and SICP
20:29:55 <DanC> eek... no haskell mode?!?
20:29:57 <bremner> now your just trolling the guy. Who might deserve it, but...
20:30:07 <EvanR> DanC: i heard theres haskell mode
20:30:10 <tensorpudding> Will GHC complain if a file doesn't end, or just never stop compiling?
20:30:19 <EvanR> how would ghc know if the file never ended
20:30:23 <ivanm> tensorpudding: well, probably the latter...
20:30:23 <bremner> DanC: there is a haskell mode for emacs, but not ed
20:30:26 <DanC> ubuntu's emacs doesn't seem to grok .hs out of the box
20:30:32 <gwern> tensorpudding: you're forcing evaluation of the compilation of the file
20:30:32 <fax> can anyone convince me that GEB is worth reading?
20:30:32 <ddarius> gwern: Most CS degrees could be replaced by reading Dr. Seuss.
20:30:36 <gwern> tensorpudding: so never end
20:30:39 <bremner> DanC: apt-get install haskell-mode
20:30:39 <ddarius> fax: It isn't.
20:30:45 <fax> ddarius that didn't help :P
20:30:45 <ivanm> has Nola ever said _what_ [s]he is trying to do?
20:30:46 <gwern> DanC: no, it's in... yeah, bremner beat me to it
20:30:57 <gwern> ivanm: no. I've suggested they say so a few times now...
20:30:59 <DanC> whew.
20:31:17 <Pseudonym> I thought Nola was writing a text editor, no?
20:31:22 <Pseudonym> Did I misunderstand that?
20:31:37 <ivanm> Pseudonym: [s]he says [s]he _has_ a text editor
20:31:38 <EvanR> learning haskell, i thought
20:31:43 <Pseudonym> Ah, OK.
20:31:43 <gwern> Pseudonym: no no Nola was using it, I understand it in Outer Qwqlphm
20:32:18 <gwern> *Qwghlm
20:32:22 <Pseudonym> gwern: That's "Qwglhm".  I realise that was a typo, but even so, you've just insulted my mother in Qwghlmese.
20:33:22 <DanC> nope... emacs parses f.. like F..
20:34:00 <gwern> Pseudonym: it was a witty pun on Inner Qwglhmese, I beg your pardon
20:34:21 * syntaxglitch really wishes he would actually get tired or something in the evenings, getting more than 4hrs of sleep for once would be pretty awesome
20:34:25 <Pseudonym> Oh, of course.  Beg your pardon.
20:34:30 <gwern> DanC: what do you expect from some hacked up regexps? you want accurate highlitghting, go use yi or leksah
20:34:46 <Pseudonym> syntaxglitch, have you considered finding a political podcast in a language you don't understand?
20:34:49 <gwern> Pseudonym: if I had been insulting your mother, it would've been 'Outer Qwlqphm'
20:34:52 <Pseudonym> Preferrably an hour-long one.
20:34:59 <gwern> syntaxglitch: I suggest taking melatonin.
20:35:00 <DanC> regexps are more than capable of distinguishing F from f
20:35:01 <Pseudonym> Believe it or not, it works for me.
20:35:09 <Pseudonym> gwern: Melatonin isn't available anywhere.
20:35:13 <syntaxglitch> Pseudonym, I think that'd drive me to suicide before sleep...
20:35:23 <Pseudonym> I tried it once, it didn't work.  Then I discovered it was homeopathic, which explains it.
20:35:26 <gwern> Pseudonym: piffle
20:35:39 <gwern> to your former; homeopathy is piffle itself, so I'd agree
20:35:51 <syntaxglitch> And melatonin doesn't really seem to help me
20:36:01 <ivanm> Pseudonym: really? I thought it was a brain chemical...
20:36:03 <gwern> syntaxglitch: what did you try?
20:36:26 <gwern> ivanm: ignore him; melatonin is available pretty widely. in the us you can get it in grocery stores
20:36:27 <Pseudonym> ivanm: As noted, I discovered that melanonin isn't available over-the-counter, and I'd actually been taking a homeopathic version.
20:36:37 * Pseudonym isn't in the US
20:36:40 <syntaxglitch> gwern: various dosages, anywhere from 5-60min before bed, no noticeable effect
20:36:40 <ivanm> Pseudonym: ahhh
20:36:52 <ivanm> right, you're in Melbourne
20:36:58 <monochrom> @hoogle melatonin
20:36:58 <lambdabot> No results found
20:37:02 <Pseudonym> Right.
20:37:04 <DanC> headpopper: (-) is syntax for (\ x y -> x-y)
20:37:16 * ivanm thought he'd read that melatonin sales in the USA had been curbed by the post office prohibiting mail order sales...
20:37:19 <monochrom> Not a brain chemical in lambdabot. :)
20:37:29 <ivanm> monochrom: heh
20:37:39 <gwern> ivanm: certainly hasn't interrupted my parcels
20:37:42 <lambdabot> That's why I'm superior.
20:37:43 <syntaxglitch> lambdabot never sleeps, thus needs no melatonin
20:37:52 <gwern> Pseudonym: my understanding was that aussies were allowed to import melatonin
20:37:57 <Pseudonym> Perhaps.
20:38:11 <Pseudonym> Haven't tried that.
20:38:16 <Pseudonym> Tryptophan is another option.
20:38:37 <gwern> mm. melatonin is more directly hooked into the sleep system
20:38:38 <ivanm> you mean Dr Karl Kruszelnicki _lied_ to me? :o
20:38:48 <Pseudonym> ivanm: What did he say?
20:38:49 <syntaxglitch> Tryptophan is a serotonin precursor, innit?
20:38:58 <gwern> 'Melatonin is a hormone produced from the amino acid, tryptophan, via serotonin in the pineal gland.
20:39:24 <gwern> 'It cannot be prescribed in Australia and is not available as a foodstuff, although people are able to bring personal supplies into the country. ' from '97 http://www.australianprescriber.com/magazine/20/4/artid/234/
20:39:46 <ivanm> Pseudonym: one of his books had a section on melatonin, with the anecdote that in the USA they only way they could stop people from getting ill from overusing melatonin was by the post office banning sales because of false advertising (or something like that)
20:39:48 <Pseudonym> Right.
20:40:27 <DanC> oh for pete's sake... section 2.6  Character and String Literals uses CR in the grammar; why not the earlier section?
20:40:52 <ddarius> Alternatively one could eliminate the people who get ill from overusing melatonin.
20:41:09 <gwern> who would be?
20:41:26 <gwern> melatonin is safer than iron supplements
20:41:43 * syntaxglitch is pretty sure melatonin is harmless in doses massively exceeding normal quantities
20:42:04 <gwern> overuse melatonin and you feel like shit and don't go do it again; overuse iron, and you'll be in the hospital getting chelation therapy. if that even works with iron.
20:42:13 <Pseudonym> The problem is that each country's Relevant Authority needs to believe it for themselves.
20:42:31 <syntaxglitch> I'll also note that it's possible to get sick and die from overusing water
20:42:49 <syntaxglitch> in fact, that happens on a fairly regular basis to at least a handful of people
20:42:57 <Pseudonym> It's kind of bizarre what countries allow what medications.
20:43:18 <Pseudonym> It shocked me to learn how few pain relief options are available for childbirth in the US, for example.  They don't even have nitrous oxide.
20:43:52 * syntaxglitch just wishes he didn't have to jump through so many hoops for a prescription he's on :(
20:44:05 <ddarius> There's no condition trephination can't solve.
20:44:15 <holmak> treppanation?
20:44:20 <Pseudonym> ddarius: It can't cure imbalance of humours.
20:44:22 <gwern> never seen that spelling before
20:44:25 <Pseudonym> Or hysteria.
20:44:37 <Pseudonym> But I believe it can cure St. Vitus' Dance.
20:44:49 <gwern> Pseudonym: can it handle scrofula?
20:44:51 <holmak> pardon me, trepannation
20:44:55 * syntaxglitch prefers therapeutic phrenology
20:45:03 <fax> lol
20:45:11 <Pseudonym> Anyway, perhaps the armchair medicine discussion could get moved to -blah.
20:45:17 * ddarius has decided to be done talking about random crap in #haskell.
20:45:31 <syntaxglitch> yeah, I should try and get to bed anyway
20:45:35 <gwern> you have sat too long for any good you have been doing. In the name of god, leave!
20:45:48 <Pseudonym> Was that a curse?
20:46:03 <gwern> Pseudonym: apposite Cromwell quote
20:46:08 <Pseudonym> Ah, right.
20:46:17 * Pseudonym is clearly insufficiently erudite to have noticed
20:46:27 <gwern> knowledge is power!
20:46:31 <syntaxglitch> gwern, thanks anyway for the melatonin suggestion
20:47:01 * DanC reaches 2.7  Layout, which helps significantly in reading http://hackage.haskell.org/packages/archive/fgl/5.4.2.2/doc/html/src/Data-Graph-Inductive-Query-MaxFlow.html#augmentGraph
20:47:04 <gwern> syntaxglitch: I will note that I've read a few people say that they experimented with all sorts of large doses and then really small ones worked out for them
20:47:21 <syntaxglitch> though unless there's someone else with the same handle, I'm pretty sure I've seen you recommend it elsewhere already...
20:47:30 <gwern> syntaxglitch: I'm sure you have :)
20:47:52 <Pseudonym> In which case, you have no excuse.
20:47:54 <ivanm> DanC: "2.7 layout'?
20:48:05 <DanC> in http://www.haskell.org/onlinereport/lexemes.html
20:48:46 * syntaxglitch attempts sleep :\
20:49:24 <ivanm> aaahhhhhhhh!!!
20:49:45 <ivanm> is anyone else getting Delivery Status Notification(Failure) emails about not being able to be delivered to c10b66c97b5cd09384aa9f82ecd95c2b@orangeat.blackberry.com ?
20:49:50 * ivanm just got 4 of them
20:50:23 <ddarius> Someone should modify FGL to use view patterns as originally intended.
20:50:24 <ivanm> DanC: how does that help with augmentGraph?
20:50:39 <ivanm> ddarius: I'm kinda working on an alternate implementation
20:50:45 <ivanm> and I think the hnn people are as well
20:51:05 <DanC> the #augmentGraph is spurious; sorry, ivanm
20:51:15 <DanC> it helps reading the overall module syntax
20:51:15 <ivanm> *phew*
20:51:18 <ddarius> ivanm: I'm not talking about replacing it.  I'm saying that the source code should be modified stylistically.
20:51:29 <ivanm> ddarius: tbh, I think FGL needs a rewrite
20:51:36 <ivanm> e.g. using 4-tuples for Contexts
20:51:54 <ivanm> DanC: so what bit _does_ it help with?
20:52:08 <dmead> hey channel
20:52:27 <dmead> i'm trying to get some parsec code working, but the notFollowedBy parser is sort of screwy
20:52:48 <dmead> ie, i want to say ; notFollowedBy (string blah)
20:52:56 <dmead> but i got me some type errors :/
20:53:12 * ivanm hasn't used parsec, so probably can't help
20:53:23 <Saizan> dmead: paste the real code and error
20:53:29 <Saizan> ?type notFollowedBy
20:53:30 <lambdabot> Not in scope: `notFollowedBy'
20:53:35 <DanC> module... where...
20:53:37 <Saizan> ?hoogle notFollowedBy
20:53:37 <ivanm> @hoogle notFollowedBy
20:53:38 <lambdabot> Text.Parsec.Combinator notFollowedBy :: (Stream s m t, Show t) => ParsecT s u m t -> ParsecT s u m ()
20:53:38 <lambdabot> Text.ParserCombinators.Parsec.Combinator notFollowedBy :: (Stream s m t, Show t) => ParsecT s u m t -> ParsecT s u m ()
20:53:38 <lambdabot> Text.Parsec.Combinator notFollowedBy :: (Stream s m t, Show t) => ParsecT s u m t -> ParsecT s u m ()
20:53:38 <lambdabot> Text.ParserCombinators.Parsec.Combinator notFollowedBy :: (Stream s m t, Show t) => ParsecT s u m t -> ParsecT s u m ()
20:53:58 <DanC> maybe it's not just section 2.7, but the whole of section 2, that allows me to read haskell at the lexical level
20:54:04 <ivanm> DanC: what's so strange about how FGL does it?
20:54:17 <DanC> before, I struggled to understand what was language syntax and what wasn't (e.g. data vs. otherwise)
20:54:21 * ivanm has no idea what those types mean...
20:54:23 <Saizan> ivanm: DanC is just learning haskell
20:54:29 <ivanm> oh...
20:54:32 <ivanm> that explains it ;-)
20:55:55 <monochrom> Because Pete was not on the haskell committee, Pete's sake wasn't considered in various decisions. :)
20:56:35 <gwern> surely we ought to
20:56:46 <monochrom> Interestingly, Simon was on the committee.
20:57:11 <gwern> simon says a lot of things
20:57:18 <ivanm> monochrom: lol
20:57:45 <gwern> I don't know Jack, if he was on or no
20:58:05 <DanC> oh. duh. \ is read as lambda
20:58:13 <monochrom> haha
20:58:15 <DanC> (section 3  Expressions)
20:59:01 <dmead> Saizan: here is a pastebin
20:59:02 <dmead> http://pastebin.com/aP4EjjS7
20:59:16 <Saizan> it looks more like a lambda when in parentheses -> (\ x -> ..
21:00:02 <dmead> i guess i'll have to roll my own notfollowedby
21:00:10 * DanC ponders left section and right section...
21:00:14 <ivanm> dmead: any particular reason use use explicit braces and semicolons in your do blocks?
21:00:19 <gwern> it looks more like a lambda when yi or leksah or emacs turns on unicodifying...
21:00:32 <dmead> ivanm: because thats how the parsec docs do it, no actual reason
21:01:01 <blackh> DanC: Sections are _very_ useful
21:01:02 <dmead> i just got into the habit when doing stuff with parsec
21:01:07 <dmead> and only when doing parsec
21:01:14 <ivanm> dmead: mapM_ (notFollowedBy . char) "select" ?
21:01:23 <dmead> hmm
21:01:23 <ivanm> (where char is the character parser, whatever parsec calls it)
21:01:32 <dmead> char is the right parser
21:01:35 <dmead> hold on
21:01:53 <dmead> does my idea to do recursion like that make sense?
21:03:14 * ivanm has no idea
21:03:25 <blackdog> wheeee, just got paid for writing haskell
21:03:26 <blackh> DanC: This is how a pirate looks a list of indices up in an array: map (arr !) indices  (pirates don't name their variables very imaginatively)
21:03:30 <blackdog> first time ever!
21:03:42 <ddarius> The latest version of Parsec 3 has a more general type for notFollowedBy.
21:03:54 <ivanm> blackdog: :o
21:03:57 <DanC> chuckle
21:04:00 <blackh> blackdog: You are in the got-paid-for-writing-Haskell club!  Hmm... it needs a better name
21:04:01 <ddarius> @hoogle arr
21:04:02 <lambdabot> Control.Arrow arr :: Arrow a => (b -> c) -> a b c
21:04:02 <lambdabot> module Data.Array
21:04:02 <lambdabot> module Foreign.Marshal.Array
21:04:21 <ivanm> blackdog: whom for?
21:04:25 <blackdog> blackh: it seems i AM an awesome enough dudebro
21:04:30 <DanC> professional Haskell programmer seems the obvious name
21:04:36 <dmead> i've gotten paid for writting haskell
21:04:46 <blackdog> ivanm: just for westfield - testing the starling queue
21:04:51 <Rotaerk_> nah, the "professional haskell programmer... seriously" club
21:04:55 <blackdog> it falls over pretty easily
21:05:02 <blackdog> dmead: congrats:)
21:05:14 <ivanm> blackdog: "starling queue"? why are they queueing birds?
21:05:14 <Pseudonym> There are a lot of programmers who write Haskell on the sly, though.
21:05:17 <dmead> it was a big giant data processing contract
21:05:29 <dmead> and i was the only one in the shop who knew haskell xD
21:05:33 <Pseudonym> Prototyping, for example.
21:05:33 <blackdog> ivanm: it's a memcache protocol compliant queue written in ruby
21:05:38 <blackdog> used for queuing up jobs
21:05:42 <DanC> head-popper: - f x + y parses as	 (- (f x)) + y
21:05:56 <Pseudonym> Seriously, though, congrats to blackdog.
21:05:57 <blackdog> (falls over at about 20 concurrent connections with 1200 requests each on my box)
21:06:39 <dmead> ddarius: is that on hackage?
21:06:48 <ivanm> blackdog: so you had  _real_ reason to use hubris then?
21:06:53 <blackdog> ivanm: ha
21:06:53 <blackdog> no
21:06:56 <blackdog> it's just a network thing
21:07:16 <blackdog> used the memcache client interface in haskell to throw requests at it
21:07:25 <blackdog> basically a glorified test script
21:07:28 <ivanm> so how did you use haskell to test a ruby queueing implementation?
21:07:29 <ivanm> ahhhh
21:08:00 <blackdog> btw: seriously, seriously looking forward to bos and johan's event manager
21:08:07 <DanC> "However, implementations may well use a post-parsing pass to deal with fixities, so they may well incorrectly deliver the former parse." !?!!? parsing isn't well-defined?!?!?
21:08:31 <DanC> hmm.. "incorrectly"
21:08:32 <blackdog> started playing around with c10k stuff at railscamp, and mighttpd + c10k looks pretty cool, but it'd be much nicer to have it all in the one process
21:08:44 <monochrom> I can't tell the difference between blackdog and blackh
21:09:00 <blackdog> monochrom: he has a beard. HTH!
21:09:10 <blackh> monochrom: At the risk of exploding your head, I am going to visit blackdog !
21:09:32 <blackh> That's sure to create a chain reaction that will accelerate every atom in the universe to light speed!
21:09:59 <blackdog> at last, we will be seen in the same room at once and confound those damned rumours.
21:09:59 <ivanm> blackh: how about yo do so during july, so you can come along to AusHack! \o/
21:10:11 <blackdog> ivanm: you have your implication arrow around the wrong way:)
21:10:12 <ivanm> monochrom: blackdog does hubris; I have no idea what blackh does
21:10:35 <ivanm> blackdog: ahhh, so he comes to AusHack just so he can be in the same room with you? :p
21:10:45 <blackdog> blackh does mad-keen iphone and dynlib hacking
21:10:48 <blackh> ivanm, monochrom: My hackage contributions include hexpat, SMTPClient, BerkeleyDB.  I'm also working on a commercial video game in Haskell.
21:10:53 * DanC ponders... all Haskell types include _|_
21:11:05 <ivanm> DanC: almost; unboxed types don't
21:11:17 <ivanm> blackh: *nod*
21:11:32 <monochrom> although, unboxed types don't exist in the report
21:11:42 <blackh> ivanm: I'll see you at AusHac - my flights are booked
21:11:46 <ivanm> DanC: it's analogous to OO languages which have null references, except that in Haskell you don't usually ahve to bother checking for nulls
21:12:01 <DanC> I think it's more than null references; it's all runtime errors.
21:12:06 <ivanm> the undefined chain just progresses upwards rather than causing errors when you try to apply a function to an undefined value
21:12:06 <DanC> "Since Haskell is a non-strict language, all Haskell types include _|_"
21:12:11 <Saizan> it's not like null references
21:12:13 <ivanm> blackh: you are coming? :o
21:12:24 <blackh> ivanm: Yes!
21:12:32 <ddarius> Saizan: I strongly agree with Saizan about this.
21:12:48 <monochrom> void *Henry_marriage = null;
21:13:08 <ivanm> ooooohhhhh.....
21:13:30 <ivanm> ddarius: did you mean to address that to someone else
21:13:36 <monochrom> monochrom: I agree with monochrom. Wait, I disagree.
21:13:43 <ivanm> blackh: must have missed you in the signup list
21:13:48 <ddarius> ivanm: er, not really...
21:13:51 <ivanm> blackh: where are you going to be staying?
21:14:00 <ddarius> not really directed to anyone in particular
21:14:03 * monochrom becomes _|_ thusly
21:14:04 <blackh> ivanm: My real name is Stephen Blackheath.  I'm staying with blackdog.
21:14:06 <ivanm> ddarius: so you told Saizan that you agree with Saizan? :s
21:14:12 <ivanm> blackh: ahhh, right
21:14:40 <ivanm> you guys did get my email regarding schedule, etc. didn't you??
21:14:44 <blackh> ivanm: hamishmack is also coming, so that's two of us New Zealanders.
21:15:00 <ivanm> yeah, I knew hamishmack was coming, didn't realise you were as well
21:15:13 <Saizan> anyhow, the point is that _|_ is not supposed to be checked at all, it's there only because haskell doesn't force all functions to be total.
21:15:31 <ddarius> _|_ is in Java.  Just in different places.
21:15:54 <DanC> "Because e1 could be a data constructor..." huh? what's a data constructor? missing forward-reference?
21:15:56 <blackh> ivanm: Yes - got it (11 Apr). Just reading it again.
21:16:21 <ivanm> good; just checking because out of the 17 people I emailed only one person replied :s
21:16:31 <Saizan> in fact i'm not sure i agree that unboxed types don't have _|_
21:16:40 <monochrom> yes, forward reference to "data Haha = FunFun Int | BoingBoing String"
21:17:03 <blackh> DanC: If you define "data Length = Metres Int | Feet Int" then Metres and Feet are data constructors
21:17:27 <ddarius> Saizan: The -types- don't have bottom, but arrow types may add a bottom to the codomain (as they do in Java).
21:17:29 <monochrom> To understand the report, you must first understand the report.
21:17:31 <blackdog> ivanm: i figured the wiki was the canonical repo
21:17:51 <ivanm> blackdog: right, but there haven't been many changes to their either
21:18:10 <ivanm> and I was trying to get a discussion going wrt whether people want talks, etc.
21:18:11 <blackh> ivanm: I'm very happy with your proposed programme. Would love to hear from chak.
21:18:18 <Saizan> ddarius: oh, right
21:18:31 <ivanm> blackh: right, so now we've just got to convince chak to talk :p
21:18:34 <ivanm> Axman6: you around?
21:18:46 <ddarius> ivanm: Just fill him with alcohol.
21:18:56 <ivanm> heh
21:19:03 <ivanm> you have experience at this I take it?
21:19:05 <DanC> the report says in no uncertain terms that _|_ is in every type; e.g. it's the result of a pattern expression that fails to match
21:19:09 <ddarius> ivanm: Nope.
21:19:19 <DanC> I don't see how unboxed types are special
21:19:29 <ddarius> DanC: Unboxed types are an extension.
21:19:32 <monochrom> perhaps unboxed types never fail to match
21:20:06 <DanC> I was assuming unboxed types were things like Int and Bool. poor assumption?
21:20:19 <monochrom> null and void assumption
21:20:38 <blackdog> Int can still be lazy
21:20:39 <ivanm> unboxed types are like Int#
21:20:56 <monochrom> no unboxed types in the report
21:20:58 <blackh> DanC: Int and Bool are boxed but GHC aggressively optimizes to unboxed types.  You never need to use unboxed types explicitly in practice.
21:21:01 <ddarius> DanC: Well considering monochrom said earlier that unboxed types weren't in the Report, it does seem like a poor assumption.
21:21:30 <ddarius> There's no reason to be talking about unboxed types at all and they shouldn't have been brought up in the first place.
21:21:52 <DanC> you're assuming strict evaluation of conversational topics in my mind, ddarius ;-)
21:21:53 <monochrom> so much so that the report doesn't even bother to say "boxed"
21:22:26 <ddarius> "box" and "unbox" are implementation-level terms.
21:22:40 <monochrom> like a kindergarten textbook on natural numbers just say "number" not bothering with "natural"
21:23:55 <monochrom> There are truths, damn truths, and Kripke structures.
21:24:07 <DanC> LOL!
21:24:47 <DanC> my kids are asleep, man! don't crack me up so bad I wake them up!
21:25:30 <juhp> anyone built ghc-6.12.2 from src yet?
21:25:31 <DanC> 3.5  Sections... more caveats than spec in there. ew.
21:25:53 <dmead> juhp: yea, but in portage
21:26:06 <juhp> ok thanks
21:26:13 <juhp> will try to download again
21:26:22 <juhp> dmead: can you tell me the md5sum?
21:26:35 <juhp> my tarball looks broken...
21:26:46 <Saizan> (so "in Java" if you have "x = f(y);" x and f(y) "have" different types, it's a partiality monad.)
21:26:55 <dmead> no can do, not able to connect to my machine at home
21:26:57 <juhp> and why is it 33MB :-(
21:27:05 <juhp> dmead: ok
21:27:35 <monochrom> Saizan: that shouldn't pass the typechecker
21:27:50 <ddarius> Saizan: Indeed.  The (initial) assignment corresponds to bind.
21:27:52 <juhp> anyway looks like my download was incomplete < 33M - so no worries
21:28:03 <ddarius> (That's why bind is called bind.)
21:28:04 <juhp> thanks
21:28:21 <ivanm> juhp: I just did
21:28:24 <ivanm> haven't installed it though
21:28:40 <ivanm> dmead: oh? has trofi or kolmodin already built a bootstrapping binary?
21:29:11 <ivanm> ooooohhhhh..... GHC throws out deprecation warnings when building itself...
21:29:19 <Makoryu> Nice ï¼ˆã€€â‰–â€¿â‰–ï¼‰
21:29:22 <DanC> "The list constructor is :, and the empty list is denoted []." is it also correct to say that [] is a nullary list constructor?
21:29:25 <ivanm> ahhh, that's from HPC
21:29:27 <juhp> ivanm: debian?
21:29:31 <DanC> earlier in the report, they say 'a' is a nullary Char constructor
21:29:33 <Makoryu> DanC: Yep!
21:29:41 <ivanm> juhp: on a ubuntu machine at uni, yes
21:29:45 <juhp> ok
21:29:49 <DanC> then "*The* list constructor" is confusing.
21:30:02 <juhp> let's see if my download completes this time :-/
21:30:51 <ivanm> juhp: wget http://haskell.org/ghc/dist/6.12.2/ghc-6.12.2-src.tar.bz2
21:31:00 <monochrom> Indeed, "the wrong thing to do" is also confusing.
21:31:13 <juhp> ivanm: yea thanks
21:31:46 <dmead> ivanm: no idea, i get it from portage :)
21:32:02 <ivanm> dmead: the overlay or the tree?
21:32:16 <juhp> shame about the bloating of the ghc src though :(
21:32:17 <ivanm> and which arch?
21:32:18 <dmead> the tree
21:32:21 <ivanm> juhp: huh?
21:32:25 <dmead> no overlays for me
21:32:33 <ivanm> dmead: wow, they've put 6.12.2 there already? :o
21:32:44 <juhp> ivanm: 6.10.4 was only 7.7M
21:32:44 <dmead> yea, iirc
21:32:46 <juhp> ;)
21:32:52 <ivanm> must be to stop people like you bitching when we don't put untested ebuilds into the tree ;-)
21:32:56 <juhp> 6.12.1 22M
21:32:57 <ivanm> juhp: it was? I doubt that...
21:33:05 <juhp> and not 6.12.2 33M ;)
21:33:06 <DanC> "and t is an instance of class Enum" class? what's a class? (missing forward reference again). am I reading the latest haskell report? is this thing maintained? should I send my editorial bug reports somewhere?
21:33:14 <juhp> ivanm: heh well don't take my word for it
21:33:23 <dmead> http://gentoo-portage.com/dev-lang/ghc
21:33:27 <juhp> not->now
21:33:40 <dmead> 6.12.1
21:33:53 <juhp> so guess 6.14 will be about 50MB *runs* ;-P
21:34:00 <ivanm> hummmmm.... so it is
21:34:09 <juhp> anyway it is just ""garbage""
21:34:27 <ivanm> DanC: typeclasses are how Haskell does polymorphism
21:34:30 <juhp> ivanm: 6.12.1 got gnu src tarballs for mingw
21:34:32 <ivanm> dmead: there's no 6.12.2 there...
21:34:38 <ivanm> juhp: yeah
21:34:42 <juhp> and 6.12.2 got random stage3 crap ;)
21:34:46 <juhp> :(
21:34:47 <ivanm> damn windows whiners...
21:35:18 <juhp> perhaps they can throw in a few oo.o and eclipse builds for the next release ;-P
21:35:18 <dmead> :<
21:35:26 <juhp> ugh
21:35:27 <Makoryu> ï¼ˆã€€Â°âˆ€Â°ï¼‰
21:35:34 <juhp> anyway enough bitching :)
21:35:45 <DanC> my point is editorial, ivanm . the report as written refers to a notion of "class" that has not yet been discussed. it should have a forward reference there, as it does usefully in many other such places
21:36:25 * ivanm has never read the report....
21:36:35 <dmead> DanC it's not class as in object
21:36:39 <dmead> class as in classification
21:36:48 <dmead> a set, sharing attributes
21:36:50 <dmead> etc
21:36:53 <ivanm> dmead: so it looks like you were lying about having built 6.12.2 ...
21:37:00 <dmead> yea i'm full of liez
21:37:15 <ivanm> *tsk, tsk*
21:37:23 <ivanm> dmead: any particular reason for not using the haskell overlay?
21:37:25 <DanC> I don't doubt you, dmead. to repeat: my point is editorial.
21:37:31 <blackdog> dmead: sure, but he's talking about being able to understand it from reading the report, not from absorbing folk culture from the channel;)
21:37:50 <Pseudonym> Folk culture is way more interesting than any "report".
21:37:53 <DanC> heh
21:37:57 <dmead> ivanm: i'm on shit for shit dsl connection and it takes forever to sync
21:38:18 <dmead> if the report does not inspire you to become part of haskell lore and legend, i can't help you
21:38:29 <dmead> hac phi in one month
21:38:30 <dmead> ec etc
21:38:48 <Pseudonym> "In the beginning, Frege created the calculus of sequents."
21:38:49 <blackdog> there's value in having clear statements of semantics
21:39:01 <ivanm> dmead: so what, you install libraries that aren't in the tree by hand then?
21:39:19 <dmead> ivanm i got a shiny new version of cabal
21:39:21 <dmead> so i get it that way
21:39:25 <dmead> cabal install, etc
21:39:35 <Pseudonym> "And Wadler saw it, and though that Frege was a nasty character, but the calculus was good."
21:39:51 <ivanm> humph.... you're one of _those_ people... >_>
21:39:55 <ivanm> Pseudonym: who's Frege?
21:39:57 <dmead> "and milner said let there be types, and there were types"
21:40:00 <Pseudonym> Gottlob Frege.
21:40:03 <dmead> "and it was good"
21:40:25 <Pseudonym> He was... well, the inventor of sequent calculus.  He was also a Nazi.
21:40:43 <dmead> wadler talks about him in his lecture at google
21:40:48 <Saizan> oh, well, no one is perfect.
21:40:56 <dmead> wadler called him a storm trooper etc etc
21:40:59 <DanC> Translation box about list comprehensions suggests that concatMap is akin to scala's flatMap
21:41:00 <tensorpudding> Frege invented a set theory didn't he?
21:41:23 <Pseudonym> I haven't seen his google lecture, but I've seen his "obvious in retrospect" talk in person
21:41:28 <DanC> (for comprehensions in scala compile to flatMap, filter, and ... umm... I can't remember the 3rd function)
21:41:29 <dmead> neat
21:41:30 <dmead> http://video.google.com/videoplay?docid=-4167170843018186532#
21:41:34 <dmead> thats his lecture at google
21:41:36 <Pseudonym> George Boole was also, apparently, a kook.
21:41:39 <Saizan> tensorpudding: the first stratified one i think
21:41:41 <dmead> Pseudonym: where do you live?
21:41:48 <Pseudonym> Melbourne.
21:41:51 <Pseudonym> Australia, not Florida.
21:41:54 <dmead> :)
21:41:55 <tensorpudding> I wasn't sure if I confused Frege with Frechet.
21:42:01 <dmead> my advisor is from melbourne
21:42:07 <Pseudonym> Oh?  Who?
21:42:15 <dmead> wyatt? i'm sure you don't know him
21:42:20 <Pseudonym> First name?
21:42:21 <dmead> he graduated there in like 71
21:42:23 <dmead> richard?
21:42:24 <Pseudonym> Ah.
21:42:29 <Pseudonym> I've heard the name.
21:42:29 <ivanm> there's a Melbourne in Florida?
21:42:32 <Pseudonym> Probably read it on a paper.
21:42:33 <dmead> really?
21:42:35 <dmead> perhaps
21:42:41 <Pseudonym> ivanm: Yes, named after the one in Australia.
21:42:48 <dmead> you're at melborne university?
21:42:49 <ivanm> those crazy yanks
21:42:51 <Pseudonym> WHich is, in turn, named after the Prime Minister of Britain
21:43:06 <Pseudonym> dmead: I work on the campus, but not for the university.
21:43:10 <dmead> ah
21:43:12 <Pseudonym> Well, I have an honorary appointment.
21:43:22 <Pseudonym> That's just so I can use the library and stuff.
21:43:25 <dmead> ah
21:43:32 <dmead> i think he was a math major there?
21:43:34 <dmead> long time ago
21:43:42 <DanC> Kripke structures have about the same status as Monads in my understanding... I've grokked them for periods of about 20 minutes, but it doesn't stick.
21:43:59 * ivanm kept getting confused when Heroes talked about things in Odessa and wondering how they managed to travel to Eastern Europe so quickly
21:44:13 <Pseudonym> Oh, Richard Wyatt was a famous sculptor.  That's where I've heard the name.
21:44:25 <Pseudonym> As you were. :-)
21:44:33 <dmead> ahh
21:44:33 <blackh> Don't believe the hype that monads are like burritos. They're actually more like takeaway food in general.
21:44:34 <juhp> then there's Brisbane in CA...
21:44:40 <DanC> "let is often called letrec in other languages" heh. language*s*? other than scheme?
21:44:40 <tensorpudding> I thought Frege died at the turn of the century
21:44:49 <dmead> how did you see wadler in person?
21:44:52 <Pseudonym> Every capital city in Australia is named after someone apart from the capital.
21:44:56 <Pseudonym> dmead: He was visiting.
21:44:56 <Makoryu> DanC: "let rec" in OCaml
21:45:03 <dmead> gotcha
21:45:11 <dmead> ICFP is at upenn this year
21:45:14 <dmead> i wonder if he'll go there
21:45:22 <tensorpudding> Hmm, he lived just long enough to be familiar with Nazism
21:46:03 <Saizan> DanC: i think some kind of kripke structures give rise to a monad
21:46:49 * DanC suffers brain explosion at the thought
21:47:02 <Pseudonym> Varying values of beeta give rise to dom!
21:47:49 <Saizan> (or was it kripke models?)
21:48:47 <killing-joke> looking for advice on hosted webmail. is there a good channel for that? thanks. :)
21:49:14 <Pseudonym> First person who rolls their own in Haskell gets a prize.
21:49:20 <DanC> least fixpoint operator... yet another concept that goes *poof* whenever I stop concentrating hard on it for half an hour
21:50:09 <killing-joke> Pseudonym, just the GUI, or the SMTP MTA as well?
21:50:48 <Pseudonym> The prize would vary. :-)
21:50:54 <killing-joke> hah! :)
21:51:02 <Pseudonym> Yeah, this google talk is the one I saw in Melbourne.
21:51:31 <ivanm> Pseudonym: you going to be coming to AusHack?
21:52:06 <Pseudonym> Where is it?
21:52:22 <juhp> July?
21:52:40 <ivanm> Pseudonym: July at UNSW
21:52:41 * Pseudonym sadly has a life, which tends to get in the way of such things
21:52:50 <juhp> anyone know that the license of the haskell logo on the wiki is?
21:52:52 <ivanm> Pseudonym: http://www.haskell.org/haskellwiki/AusHac2010
21:52:59 <Pseudonym> The chance of me getting to UNSW in July is slim to none, sadly.
21:53:04 * ivanm doesn't have one, so he has no problem going to such things :p
21:53:08 <juhp> http://haskell.org/sitewiki/images/a/a8/Haskell-logo-60.png
21:53:16 <ivanm> juhp: probably the same as the entire wiki
21:53:18 <juhp> ivanm: me too ;-P
21:53:37 <juhp> ivanm: that is what I was guessing
21:53:52 <ivanm> Simple Permissive License
21:53:56 <juhp> jeff suggested i tried haskell-cafe
21:54:08 <juhp> I need a definite answer :)
21:55:11 <ivanm> yeah, try -cafe
21:56:04 <DanC> 3.14  Do Expressions makes sense... I think the "Dan groks Monads" bit is on now... let's see how long it lasts. Are >> and >>= the whole story? are those bind and ... umm.. what's the other one?
21:56:20 <monochrom> return. fail.
21:56:52 <monochrom> OTOH to desugar do-notation, you just need to know >>=, >>, and fail.
21:57:22 <dmead> DanC: monad is a type class with two members you need to know
21:57:26 <DanC> fail sticks _|_ in the burrito?
21:57:27 <dmead> >>= and return
21:57:48 <dmead> just leave it at that, unless you're studying abstract algebra
21:57:57 <ivanm> DanC: fail is used when something doesn't work out, but it's usually considered a wart
21:58:09 <ivanm> @src MonadPlus
21:58:09 <lambdabot> Source not found.
21:58:11 <ivanm> bah
21:58:25 <dmead> just use exceptions
21:58:29 <dobblego> s/usually/always
21:58:36 <dmead> on an eeenvening such as this
21:58:40 <dmead> it's hard to tell if i exists
21:58:42 <monochrom> fail is for pattern matching.  Â«do { [] <- haha; ... }Â»  What happens if the list is non-empty? fail is called.
21:58:45 <dmead> pack the car and leave this town
21:58:48 <dmead> who will notice that i'm not around
21:58:52 <dmead> i could hide out under there
21:58:55 <DanC> hmm... I expected to see IO show up in the spec for do notation. but I guess do is for monads in general?
21:58:58 <dmead> i just made you say underwear
21:59:07 <dobblego> DanC, yes that is correct
21:59:17 <dmead> DanC: do is syntactic sugar for bind
21:59:32 <dmead> it's part of template haskell or whatever the compiler wants to call it internally
21:59:56 <dmead> i got my parser working
21:59:59 <dobblego> do is syntactic sugar for (>>=), (>>) and return and has nothing to do with template haskell
22:00:02 <dmead> who wants to get drunk?
22:00:15 * DanC ponders the warm fuzziness of "As indicated by the translation of do, variables bound by let have fully polymorphic types while those defined by <- are lambda bound and are thus monomorphic."
22:00:21 <dmead> dobblego: the syntactic sugar is done with template haskell, no?
22:00:23 <ivanm> dmead: how's you do it?
22:00:31 <ivanm> and what are you writing? language-sql or something?
22:00:33 <jmelesky> is it possible to get drunk off of syntactic sugar?
22:00:42 <copumpkin> fermented syntactic sugar
22:00:42 <DanC> only if you ferment it
22:00:46 <dmead> ivanm: just a semester project
22:00:50 <dmead> i'm writting an sql interpreter
22:00:53 <jmelesky> syntactic rum?
22:00:59 <dmead> i could make it fancy though
22:01:04 <dmead> i cheated to get it to work
22:01:19 <dmead> i made my parser read two versions of select
22:01:20 <monochrom> syntactic balsamic
22:01:23 <dmead> nselect and select
22:01:23 <ivanm> dmead: *shudder*
22:01:30 <dmead> yeaa
22:01:33 <ivanm> an "sql interpreter"? that sounds scary :s
22:01:39 <dmead> meh
22:01:46 <dmead> i wrote the backend already
22:01:49 <dmead> it's just a small subset
22:01:55 <dmead> i could do the rest of the language though
22:03:10 <dmead> i need to roll my own notFollowedBy though
22:03:16 <dmead> the default one sucks alot
22:03:25 <dmead> like, it only looks at characters
22:03:28 <dmead> for some god awful reason
22:03:35 <dmead> so i cant' do like
22:03:43 <dmead> notfollowedby "select"
22:03:56 <dmead> i've gotta use that char version you suggested, which doesn't make the parser fail when it should
22:04:03 <dmead> it's gotta fail on the whole string
22:04:38 <dmead> man i want some pizza
22:04:43 <dmead> PEPPERONI pizza
22:05:07 <timofonic> You made me remember Lucas Arts adventure games :P
22:05:15 <timofonic> (Hi)
22:05:15 <ivanm> dmead: sounds like a plan!
22:05:45 <dmead> is anybody else going to hac phi?
22:05:57 <DanC> indeed, section 3.15  Datatypes with Field Labels smells of "hard cases make bad law"
22:06:00 <dmead> i think i'm gonna help brent with his diagram thingy
22:06:10 <holmak> Does anyone know why my project, which I am building with "cabal configure && cabal build", immediately crashes with a segfault when it runs?
22:06:17 <timofonic> Uhm
22:06:25 <dmead> sounds like your ram is fucked, bro
22:06:34 <dmead> compiler segfaults = hardware problems
22:06:43 <timofonic> Do you all think Haskell could be interesting for audio generation? And radio communications? :)
22:06:57 <dmead> isn't supercollider written in haskell?
22:06:57 <holmak> Sorry, I was unclear; the compiler isn't segfaulting, the program is
22:07:19 <holmak> I suspect a linking problem
22:07:20 <dmead> holmak: i'd post on a list, see if it's a bug
22:07:22 <dmead> me too
22:07:27 <dmead> but you could hit a bug in something
22:07:30 <blackdog> holmak: binding any C in there?
22:07:33 <holmak> yep
22:07:41 <dmead> there you go
22:07:44 <ivanm> holmak: a bug in your code methinks
22:07:48 <holmak> It has worked before now
22:07:55 <blackdog> compile with -g, run under gdb
22:07:56 <dmead> id test your C code against a driver in C
22:07:58 <dmead> so you can debug
22:08:01 <ivanm> holmak: so building it with ghc --make works?
22:08:03 <dmead> can you use gdb with hgc?
22:08:06 <dmead> *ghc
22:08:19 <blackdog> should be able to. it won't give you anything useful if it's dying in haskell code
22:08:29 <holmak> I just wanted to know if there are any big known segfaulty problems going around; I haven't compiled any Haskell in a while
22:08:33 <blackdog> but it will if the c is compiled with debugging symbols
22:08:37 <blackdog> holmak: no:)
22:08:41 <timofonic> "It provides anÂ interpreted object-oriented language which functions as a network client to aÂ state of the art, realtime sound synthesis server."
22:08:50 <holmak> ivanm: I didn't try, cabal has been working well for me. I can try that.
22:08:57 <timofonic> Ok, so you don't use Haskell to generate with it, but some intermediate language
22:10:07 <dmead> if my C external calls were segfaulting, i'd write a test driver in C
22:10:15 <dmead> and not ever have to deal with debugging inside ghc
22:10:58 <holmak> If the interop is the problem, it is probably in my marshaling values across the boundary. I seem to remember having that problem before.
22:11:37 <DanC> 3.17  Pattern Matching ... looks like scala grabbed this wholesale
22:12:16 <DanC> I heard they're still working out pattern matching bugs in the scala compiler.
22:12:21 <DanC> interesting to see "3.17.2  Informal Semantics of Pattern Matching"
22:16:24 <DanC> scala doesn't have n+k patterns, though
22:16:36 <Makoryu> That is very considerate of it
22:17:25 <DanC> ah... "Many people feel that n+k patterns should not be used. These patterns may be removed or changed in future versions of Haskell . "
22:17:48 <fax> what bugs me is they are all "oh lets remove n+k because it's a weird excpteional case"
22:17:58 <fax> .. but they leave if/then/else in the language...
22:18:06 <holmak> Interesting fact: the segfault occurs in openGL, on my first call to an openGL function, no matter which one
22:18:19 <holmak> might be a problem with my Ubuntu install...
22:18:22 <ivanm> holmak: is there something wrong with your C opengl libraries?
22:18:30 <ivanm> do you have the appropriate -dev libraries installed?
22:19:38 <holmak> ivanm: cabal happily compiles my C code, which #includes the opengl libs. I'm leaning toward a driver problem.
22:19:52 <ivanm> hmmm....
22:21:58 <hydo> fax: So I'm not weird for never having used if/then/else in Haskell?  That's a bit of a relief.
22:22:12 <fax> hydo (we're the only two)
22:22:30 <dobblego> why come?
22:22:40 <hydo> fax: That's fine.  As long as there's at least one other person as crazy as I am.
22:23:39 <DanC> ok... on to the meaty bits... http://www.haskell.org/onlinereport/decls.html
22:23:45 <hydo> dobblego: I've always felt subconsciously that if I need to use if/then/else then there's probably a better way to approach the problem.
22:23:54 <Makoryu> At least if/then/else is easier to desugar by hand
22:23:57 <dobblego> hydo, that sounds interesting
22:24:14 <Makoryu> Whereas n+k requires a bit more effort to rewrite, and also results in a different type...
22:24:59 <hydo> dobblego: Probably best not to listen to me though.  I make things hard on myself because I'm convinced that it makes me a better programmer.  So far I've seen no evidence to support that theory though.
22:25:40 <fax> Makoryu, we can implement n+k patterns now
22:25:48 <fax> using a subtract view pattern
22:25:57 <dobblego> hydo, I'm pretty safe when listening to others, but it still sounds interesting (i.e. I wonder if I could be convinced in whole or partially)
22:26:01 <fax> (extension)
22:27:19 <DanC> kinds... value/type/kind violates the 0/1/many rule, no? I wonder why value/type/kind/meta-kind/meta-meta-kind/etc. isn't needed
22:27:44 <Makoryu> Where can I find this 0/1/many rule
22:28:02 <DanC> @google zero one many
22:28:03 <lambdabot> http://catb.org/jargon/html/Z/Zero-One-Infinity-Rule.html
22:28:04 <lambdabot> Title: Zero-One-Infinity Rule
22:28:56 <fax> DanC: there are some languages which have an infinite hiereachy
22:29:06 <DanC> I 1st ran across kinds when looking at twelf and proof carrying compilers and such... it's always stuck in my craw
22:29:27 <fax> DanC: the thing is every syntactically well formed kind is a well formed kind -- so they have a trivial type system
22:29:28 <DanC> I guess the typed lambda calculus is one, huh fax?
22:29:31 <fax> so it's just ignored
22:29:43 <fax> DanC, yeah
22:29:52 <ivanm> DanC: it sounds like it doesn't apply to this situation
22:30:02 <fax> DanC, but I mean it's just technical stuff to avoid "set of all sets"
22:30:07 * DanC makes his peace with it, moves on...
22:30:09 <fax> of course that's not an issue in haskell
22:31:10 <dmead> would anyone know how to make a parser fail?
22:31:25 <at0mizer> ())
22:31:29 <dmead> eh?
22:31:32 <DanC> ah... "kinds are entirely implicit and are not a visible part of the language"
22:32:02 * DanC knows how to make a scala combinator parser fail; wonders if the clue would work for dmead
22:32:14 <ivanm> dmead: well, in polyparse you just use fail "foo"
22:32:20 <ivanm> dunno know parsec does it
22:32:37 <fax> DanC: (I use extensions where the kinds are actually part of programming.. so that statement doesn't give the full reason)
22:32:51 <dmead> hmm
22:33:41 <DanC> head-popper: type values
22:36:22 * DanC ponders... The declarations data T ... or newtype T ... add the type constructor T to the type vocabulary.
22:38:07 <ivanm> DanC: it means that you have a dictionary of valid type names and that T is added to it
22:38:15 <fax> but where does it *come from*?
22:38:15 <ivanm> so you can use T in type signatures, etc.
22:38:22 * DanC nods
22:38:32 * ivanm would ask fax what she means, but she has him on /ignore
22:40:02 <Makoryu> fax: Where does what come from?
22:40:51 <timofonic> ivanm: Is she a fem? You opened the Pandora's box, lots of horny haskellers will pm her...
22:41:01 <ivanm> timofonic: it's known that fax is female
22:41:06 <ivanm> she used to be called MissPiggy
22:42:00 <timofonic> ivanm: And she didn't get scared away back then?
22:42:05 <ivanm> nope
22:42:10 <timofonic> ivanm: That's a suggesting namy, right?
22:42:14 <ivanm> just bitched when I @slap'd her
22:42:21 <ivanm> for saying something stupid
22:42:43 <ivanm> then changed nicks, and bitched when I did it again (even though I didn't know it was the same person)
22:43:07 <DanC> what the heck?! "For convenience, we write cx => t even if the context cx is empty, although in this case the concrete syntax contains no =>."
22:43:15 <timofonic> ivanm: Love-hate relationships are hard...
22:43:35 <ddarius> :t undefined :: () => a
22:43:35 <ivanm> no love at all ;-)
22:43:36 <lambdabot> forall a. a
22:43:49 <dmead> ddarius: do you know about parsec?
22:43:55 <ddarius> dmead: Yes.
22:44:05 <ivanm> DanC: rather than saying "a type signature of cx => t or just plain t ..."
22:44:10 <dmead> how do i make a parser fail?
22:44:18 * ivanm knows _about_ parsec, just not how to _use_ parsec :p
22:44:42 <dmead> i've got a bunch of parsers seperated by <|>
22:44:50 <dmead> how do i explicitly make one fail and move to the next one?
22:44:57 <ddarius> dmead: fail or mzero or several other ways.  Also, note that (the old) notFollowedBy takes a parser that -returns- a character, it isn't limited to only -parsing- a character.
22:45:11 <c_wraith> 90% of what I know about parsec is "it provides a monad interface".  The other 10% is "it's not non-deterministic".
22:45:29 <ivanm> ddarius: except I don't think dmead wanted anything returned, which was the problem
22:45:33 * DanC got eliminated from a grade school spelling bee for spelling separate as "seperate". sticks out like a sore thumb ever since
22:45:42 <ivanm> c_wraith: you don't even know about Applicative? :o
22:45:55 <dmead> i want to use notFollowedBy on a string, but mapping it wuth Mmap_ isn't really doing it
22:46:03 <ivanm> yeah, I can never remember the proper spelling of separate
22:46:09 <ddarius> ivanm: It doesn't matter, notFollowedBy doesn't return anything.
22:46:10 <dmead> ivanm: me too
22:46:14 <c_wraith> ivanm: that's a subset of monad.  Knowing it's a monad tells me it's also applicative.
22:46:25 <timofonic> How do haskellers deal with procrastination? Closing the IRC client? :D
22:46:38 <ivanm> c_wraith: not quite; ideally it is, but atm  you don't have class (Applicative m) => Monad m where ...
22:46:39 <SubStack> coffee
22:46:51 <ivanm> timofonic: I don't.... :s
22:46:57 <timofonic> ivanm: I see
22:46:59 <ivanm> (but I _should_)
22:47:18 <dmead> ddarius: i have as ivanm suggested:  mapM (notFollowedBy . char) "select"
22:47:29 <ddarius> dmead: That doesn't make any sense.
22:47:35 <dmead> right, thats what i thought
22:47:43 <ddarius> Just write: notFollowedBy (string "select" >> return undefined)
22:48:05 <timofonic> I should be rich, have lots of girls, know a lot more advanced computing stuff, have a muscled and nice body, able to learn 10 different languages fluently...
22:48:08 <DanC> => is not a very appealing syntax for contexts. contexts seem to read as "... such that ..." or "... where ..." but... hmm... in the other order.
22:48:13 <timofonic> But I don't :)
22:48:21 <ivanm> gah! I wanted to replace my current ghc install with a new one, but doing "make install" expects that the old ghc is still there! :@
22:48:42 <DanC> :@ . now that would be a nice syntax for contexts ;-)
22:48:55 <ddarius> dmead: Also, notFollowedBy isn't something you should be using too much.  It's kind of like Prolog's negation as failure.
22:49:04 <dmead> hah i gotcha
22:49:04 <ivanm> DanC: nah, contexts are better thought of as "Given that foo has an instance of Bar ..."
22:49:14 <dmead> well
22:49:19 <ivanm> ddarius: why does it need to return _anything_ then?
22:49:20 <dmead> it doesn't quite work
22:49:30 <ddarius> ivanm: It doesn't need to.
22:49:36 <dmead> my parser just exits with an exception from prelude.undefined
22:49:43 <ivanm> ddarius: so why is the "return undefined" there then?
22:49:46 <ivanm> dmead: lol
22:49:47 <ddarius> dmead: Okay, then return an actual character.
22:49:54 <ddarius> It uses the token for the error message.
22:50:52 <dmead> i thought if you have the <|> combinator, it'll move to the next one?
22:50:52 <ivanm> hmmm.....
22:50:57 <ivanm> that sounds stupid
22:50:57 <dmead> why is it just exiting?
22:51:09 <ivanm> dmead: it's strictly evaluating it for some reason?
22:51:16 <dmead> maybe?
22:51:32 <dmead> this seems weird
22:51:46 <ddarius> In p <|> q, q is only executed if p fails -without consuming anything-.
22:51:53 * ivanm sticks with his nice lazy polyparse parser
22:52:08 <ivanm> ddarius: so no backtracking? :o
22:52:29 <dmead> hmm
22:52:39 <ivanm> oh, wait, isn't that what try is for?
22:52:40 <ivanm> @hoogle try
22:52:40 <lambdabot> Control.Exception try :: Exception e => IO a -> IO (Either e a)
22:52:41 <lambdabot> Control.OldException try :: IO a -> IO (Either Exception a)
22:52:41 <lambdabot> Control.Exception.Base try :: Exception e => IO a -> IO (Either e a)
22:52:42 <c_wraith> I really feel like parsec is the worst option of all the parser combinator libraries
22:52:48 <dmead> how are you supposed to know when to fail without consuming anything?
22:52:51 * ivanm really, really likes polyparse
22:52:51 <ddarius> ivanm: It has backtracking.  It will "backtrack" when p doesn't consume anything.  You can also use try to explicitly say "without consuming anything."
22:53:00 <ivanm> ddarius: *nod*
22:53:08 <ivanm> whereas with polyparse I just do p `onFail` q
22:53:12 <ivanm> or oneOf [p, q]
22:53:45 <ivanm> and it does backtracking for free! (after the bug in discard is fixed and I define and use a lazier variant of bracket that backtracks properly...)
22:53:47 <ddarius> ivanm: You can define another operator/function that is try p <|> q, but you don't want to use it everywhere (if you care about efficiency.)
22:54:10 <ddarius> ivanm: The explicit use of try was a design decision, not some limitation to how Parsec works.
22:54:21 * ivanm should try to port bos' parser benchmark to polyparse to see how it fares
22:54:32 <ivanm> ddarius: how come?
22:55:00 <ivanm> "In Parsec, you must explicitly add a try combinator at any location where backtracking might be necessary. Users often find this a bit of a black art. In PolyParse by contrast, all parsers are backtracking unless you explicitly add a commit (or one of its variations). It is easy to tell where to add a commit point, because you have already parsed enough of a data structure to know that only one outcome is possible.In Parsec, you must explicitly add a
22:55:01 <ivanm> try combinator at any location where backtracking might be necessary. Users often find this a bit of a black art. In PolyParse by contrast, all parsers are backtracking unless you explicitly add a commit (or one of its variations). It is easy to tell where to add a commit point, because you have already parsed enough of a data structure to know that only one outcome is possible."
22:55:06 <ivanm> gah, overly long quote :s
22:55:15 <ivanm> http://www.cs.york.ac.uk/fp/polyparse/ under "How do I use it"
22:55:21 <ddarius> ivanm: Because in a recursive descent parser, never committing to any choice means 1) all the input is held in memory and 2) you easily get exponential worst-case scenarios.
22:55:29 * ivanm wonders if he should bother using commit anywhere in his Dot parser
22:55:46 <ivanm> ddarius: hmmm.......
22:56:34 <timofonic> Supossing I have a big multicore headless computer. My machine is slow, but want to take advantage of it for compiling Haskell programs. How to automatize the process? Some wrapper?
22:56:56 <ivanm> timofonic: atm there's no automatic build system for GHC
22:57:10 <DanC> so... data constructors... you don't have to give implementations of them, right? the compiler just does that magically?
22:57:13 <ivanm> so you'd have to build each module by hand, after determining the correct order
22:57:14 <dv-> ghc isn't that slow is it?
22:57:21 <ivanm> DanC: what do you mean?
22:57:31 <ivanm> dv-: GHC is really slow for large datatypes... >_>
22:57:47 <ivanm> was that bug where modules with names longer than 10 characters were really slow ever fixed?
22:58:01 <timofonic> ivanm: But maybe a GHC wrapper that sends the stuff to the remote computer and does the task there?
22:58:08 <DanC> the report has this example: data Eq a => Set a = NilSet | ConsSet a (Set a)
22:58:11 <ivanm> DanC: data Foo a = Bar a a <-- you define the Bar datatype there
22:58:25 <ivanm> timofonic: uggghhh, sounds fugly
22:58:32 <timofonic> ivanm: Why?
22:58:42 <DanC> that's all there is to say about ConsSet, right? you don't have to give a body or anything like a normal function, right?
22:58:43 <ivanm> timofonic: I would also guess that you would spend more time in most cases doing network stuff than compiling
22:58:53 <ddarius> DanC: Yes.
22:58:59 <ivanm> DanC: huh? it's not a function, why does it need a body?
22:59:12 <ivanm> well, it's a cosntructor function I suppose...
22:59:13 <ddarius> DanC: It's just like declaring a struct in C.
22:59:19 <timofonic> ivanm: Not if the original machine is quite faster. Sending the entire source code and then building, then receiving the binary stuff
22:59:27 <timofonic> ivanm: I mean, if the remote machine...
22:59:42 <ivanm> timofonic: might work for binaries, but for libraries you have registration with ghc-pkg to worry about as well
22:59:50 <timofonic> ivanm: I see
22:59:53 <ivanm> timofonic: but then you want the C libraries to be the same version as well
23:00:00 <timofonic> ivanm: :P
23:00:08 <timofonic> ivanm: Some crosscompiling environment...
23:00:09 <DanC> I was thinking of it like a class constructor... I guess thinking of it like a C struct helps
23:00:11 <DanC> a little
23:00:21 <ivanm> timofonic: GHC produces statically linked binaries.... except for C libs
23:00:25 <DanC> (class constructur as in Java/python/C++)
23:00:42 <ivanm> I've had a problem where the version of GMP installed on one machine was different from another, so my pre-built binary didn't work :s
23:00:44 <timofonic> ivanm: :P
23:01:05 <timofonic> ivanm: Not possible to force it?
23:01:07 <ivanm> DanC: no, there's no internal mutable variables or anything that needs to be set with a Java-styule constructor
23:01:25 <ivanm> timofonic: IIRC, you can fudge it such that it will statically link all C libraries as well, except for glib or something
23:01:44 <DanC> now I'm starting to wonder how some of this is implemented. I hope I can leave that to another day; gotta get some sleep, eventually
23:01:46 <timofonic> ivanm: :P
23:01:58 <dmead> hey guys
23:02:03 <dmead> can you all take a peek at this?
23:02:04 <dmead> http://pastebin.com/Lhf1q6qH
23:02:08 <ivanm> "No, I'm not sleeping because I'm procrastinationg, I'm trying to make sure I remember everything I learnt" http://news.bbc.co.uk/2/hi/health/8638551.stm
23:02:34 <ivanm> dmead: as ddarius says, do >> return 'd' or soemthing
23:02:39 <dmead> i did, it fails
23:02:41 <ivanm> s/says/said/
23:02:45 <ivanm> dmead: still :o
23:02:53 <dmead> it doesn't move to the next option
23:03:44 <ddarius> dmead: That's because it has committed to the first option once you've successfully parsed "select"
23:03:51 <dmead> oh.
23:03:59 <dmead> ooooh
23:04:02 <ddarius> dmead: Are you familiar with parsing theory?
23:04:10 <dmead> not really
23:04:21 <ivanm> dmead: maybe split it into: try (string "select" >> fail "blah") <|> do tablename <- word; char ';'; return ...
23:04:21 <dmead> i've read some of the paper describing parsec
23:04:34 <ddarius> dmead: I'm talking context free grammars and such.
23:04:40 <dmead> oh, sure
23:04:41 <dmead> yea
23:04:45 * ivanm hasn't
23:04:58 <dmead> i've read syntactic structures
23:05:13 <ddarius> dmead: So you're familiar with things like left factoring a grammar?
23:05:21 <dmead> not really
23:05:31 <dmead> i don't remember eveything
23:05:58 <dmead> you mean like a left-grammar or right-grammar?
23:06:03 <ddarius> Well, what you need to do is left factor the grammar (and in general I would -highly- recommend writing out the (E)BNF of whatever you are trying to parse and modeling your code off it.)
23:06:24 <dmead> hmm alright
23:06:48 <ddarius> dmead: Right now your grammar looks like <select> ::= a b c | a b d.
23:06:59 <dmead> yea
23:07:32 <ddarius> The parser doesn't know which to choose until it sees a c or d.  The way parsec works is it commits to a branch once it successfully starts on a branch (in the example, once it parses the first 'a' it commits to the first branch.)
23:07:35 <dmead> i was under the impresion that at any point in a parser, you can fail and go to the next one
23:07:45 <dmead> right right
23:07:53 <ddarius> What you want is for your grammar to be LL(1), i.e. it knows which way to go by looking only at the next token.
23:08:12 <dmead> LL?
23:08:39 <ddarius> So you want to pull out the common parts of each of the prefixes of those do blocks until you get to the part that differs and then do a choice on that.  Incidentally, that will reduce redundancy in your code.
23:08:42 * ivanm wrote his Dot parser by mucking around with polyparse until he got something that seemed to work...
23:08:50 <dmead> does try avoid having to commit to a branch?
23:09:05 <DanC> ouch... this hurts my brain:  data D1 = D1 Int -- those two D1's refer to different beasties, yes?
23:09:15 <ivanm> DanC: right
23:09:17 <dmead> DanC: type and type constructor
23:09:20 <dmead> can be the same
23:09:22 <ivanm> the first one is the type name, the second is the constructor
23:09:27 <ivanm> they have different namespaces
23:09:38 <DanC> yuk. ew. barf.
23:09:50 <DanC> I *constantly* get bit by scala's 2 namespaces
23:09:54 <dmead> DanC: be careful when casting types whose type is named the same as it's constructor
23:09:54 <ddarius> dmead: Yes, but then you'll end up reparsing the same stuff over and over and you won't be able to throw away the input until some later part commits.
23:10:18 <dmead> ddarius: right, but i don't really see an alternative
23:10:23 <ivanm> DanC: for even more fun, classes live in yet another namespace (I think) :p
23:10:27 * ivanm goes off to check that
23:10:29 <ddarius> dmead: I already told you what to do.
23:10:44 <dmead> right i'll give writting out the EBNF a try
23:11:02 <ddarius> dmead: That's a good thing to do, but that's not what I was just now referring to.
23:11:03 <ivanm> oh, no
23:11:12 <ivanm> classes and types share a namespace
23:11:26 <ivanm> so you only have two namespaces to worry about
23:11:36 <Axman6> ivanm: i'm around now
23:11:37 <DanC> hmm.. I can't make heads or tails of this:   d1 (D1 i) = 42
23:11:38 <dmead> make it LL(1) you mean?
23:11:46 <ddarius> [01:07] <ddarius> So you want to pull out the common parts of each of the prefixes of those do blocks until you get to the part that differs and then do a choice on that.  Incidentally, that will reduce redundancy in your code.
23:11:47 <roconnor> what's the name for hyperbolic space that looks the same from every point?
23:11:50 <roconnor> isosomething
23:11:59 <ivanm> Axman6: have you heard anything recently from any AusHack attendees?
23:12:13 <dmead> ahh
23:12:22 <Axman6> Roman L... thingo has signed up with possibles, but that's it
23:12:25 <dmead> oh, right
23:12:28 <ivanm> *nod*
23:12:33 <dmead> ddarius: you mean use the <|> inside a do-block
23:12:35 <ddarius> dmead: That corresponds to turning the grammar <t> ::= a b c | a b d into <t> ::= a b <s> ::= c | d
23:12:40 <ivanm> the only people I know about that are considering staying in a hostel or something are myself and that Fallen* guy from ANU
23:12:44 <ddarius> dmead: Yes.
23:12:50 <dmead> i understand
23:12:58 <dmead> thanks for the input
23:13:14 <DanC> oh...   d1 (D1 i) = 42 -- like def d1(i: D1) := 42
23:13:20 <Axman6> ivanm: guess people will be organising their own accommodation then
23:13:31 <dmead> ddarius: but it's still OK to define this stuff recursivly?
23:13:31 <ivanm> everyone else apparently either lives in Sydney or is planning on staying in a proper hotel (like you and Sarah)
23:13:43 <dmead> whats goin on in sydney?
23:13:45 * DanC thinks that syntax smells funny
23:13:47 <blackdog> ivanm: stephen's staying with me
23:13:47 <Axman6> i still think that we should look at getting a bus or something for the weekend
23:13:55 <ivanm> blackdog: yeah, he said
23:13:58 <Axman6> dmead: AusHac2010, jusy 16-18
23:14:04 <dmead> ah
23:14:10 <ivanm> s/jusy/july/
23:14:13 <dmead> hac phi is coming up in may
23:14:18 <Axman6> nah, i moved it ivanm :P
23:14:19 <ivanm> Axman6: we need to get together and organise transportation soon
23:14:25 <ivanm> Axman6: heh
23:14:25 <ski> dmead : yes, as long as you avoid left-recursion
23:14:30 <ivanm> dmead: we announced first though!
23:14:44 <dmead> ski:  it's most definitely right
23:14:49 <dmead> ivanm: :P
23:15:04 <ivanm> byorgey just stole our thunder :(
23:15:08 <Axman6> bastard
23:15:11 <ski> (.. what's most definitely right ?)
23:15:12 <ivanm> yeah
23:15:13 <dmead> upenn students :>
23:15:22 <dmead> ski my grammar i'm trying to parse
23:15:38 <ivanm> we've got about 16 people who say they're going to be there, but some of them only for the saturday
23:15:58 <dmead> i wasn't at hac phi last year, but it had a good turnout
23:16:00 <dmead> dons was there apparently
23:16:15 <dmead> i usually go to a group in philadelphia called philly lambda
23:16:23 <dmead> it's got an assortment of functional language junkies
23:16:23 <ddarius> Parsec has some nice combinators for handling situations that would naively be coded with left recursion.
23:16:28 <ski> (dmead : i still don't understand what the rightness of the grammar has to do with how you express it, i.e. whether you use left-recursion or not ..)
23:16:58 <ivanm> blackdog: but he's coming along on the saturday whereas you have to go do that mysterious thing known as "work"?
23:17:27 <dmead> ski: parsec has problems with left recursion?
23:17:47 <ski> dmead : the recursive descent approach to parsing has problems with left-recursion
23:17:49 <ddarius> dmead: Just don't write something like: rule3 = do rule3; rule2 or rule3 = rule1 <|> rule3 or anything that would inline to that.
23:17:49 <ivanm> preflex: seen juhp
23:17:49 <preflex>  juhp was last seen on #ghc 1 hour, 12 minutes and 2 seconds ago, saying: well if there is a new tarball guess I will replace it for fedora anyway :)
23:17:53 <blackdog> i'll be there saturday and sunday
23:17:58 <blackdog> monday will be back at westfield
23:18:06 <juhp> ?
23:18:11 <ivanm> blackdog: we're doing it fri -> sun
23:18:13 <dmead> k
23:18:14 <ivanm> juhp: wrt AusHack, where are you planning on staying?
23:18:33 <ivanm> blackdog: oh, my question was meant to be "friday", not saturday
23:18:40 <blackdog> ivanm: it amounts to the same, i suppose
23:18:45 <ivanm> yeah
23:18:45 <blackdog> but yes. working on friday.
23:18:45 <juhp> ivanm: good question
23:19:10 <juhp> ivanm: maybe one of the halls or backbackers?  any suggestions? :)
23:19:25 <ddarius> dmead: I guess the only tricky case is something like: rule1 = do rule2; rule1 where rule2 can succeed without consuming any input.  Don't do that either.
23:19:25 <ivanm> juhp: well, I'm probably going to stay at the nearby backpackers
23:19:46 <juhp> ivanm: ok
23:19:46 <ivanm> Fallen_Demon said he was going to do the same, but he's not getting there till the Saturday
23:19:50 <dmead> ddarius: sure sure
23:20:25 <juhp> ivanm: what are they like? :)
23:20:33 <ivanm> so, the only non-Sydney-sider I don't know about then is bernie pope, since hamishmack is going to be at a hotel and blackh is staying with blackdog
23:20:45 <ivanm> juhp: no idea; hopefully cheap but decent :p
23:20:47 <juhp> and is there an upper age-limit? ;-)
23:20:49 <juhp> ok :)
23:21:13 <ivanm> juhp: there is a list of accom places on the wikipage
23:21:20 <juhp> ivanm: yeah :)
23:21:30 <juhp> guess there is still good time? :)
23:21:34 <ivanm> yeah
23:21:39 <juhp> ivanm: so the date is fixed right? :)
23:21:44 <ivanm> yup
23:21:47 <juhp> awesome
23:21:54 <ivanm> juhp: my big thing was, if there was a decent number of us, we might have been able to push for a discount
23:22:00 <juhp> ah
23:22:08 <ivanm> but that doesn't appear to be the case :s
23:22:12 <juhp> ok
23:22:34 <juhp> then I may ponder a bit longer :)  thanks for asking
23:22:39 <ivanm> no worries
23:22:56 <juhp> I may ask you again nearer the time
23:23:00 <ivanm> Axman6: oh, and Pseudonym is apparently unable to make it, so there's still only the one melbournian coming
23:23:06 <ivanm> juhp: no probs
23:23:22 <Axman6> ok
23:23:42 <ivanm> and juhp is the only (current) brisbanite
23:24:04 <ivanm> unless dobblego has registered and youv'e neglected to inform me...
23:24:13 <juhp> perhaps I should advertise on BFG
23:24:30 <juhp> hm no dibblego around
23:24:30 <ivanm> juhp: you mean dobblego hasn't already? :o
23:24:34 <ivanm> he said he was going to!
23:24:35 <juhp> dunon
23:24:37 <dmead> ddarius: my parser works now
23:24:38 <juhp> no
23:24:40 <juhp> erm
23:24:42 <juhp> dunno
23:24:45 <dmead> if you come to hac-phi will buy you beer
23:24:45 <ivanm> juhp: dibblego == dobblego == dabblego
23:24:51 <dmead> thanks :)
23:24:56 <juhp> haha
23:25:24 * ivanm might head off home
23:25:26 <ivanm> bye all
23:25:47 <dobblego> juhp, wossup?
23:25:48 <Axman6> o/
23:25:55 <juhp> dobblego: nothing
23:25:57 <juhp> :)
23:26:01 <dmead> ddarius, ivanm http://pastebin.com/yjMqzeq9
23:26:05 <dobblego> juhp, /join bfpg if you like
23:26:06 <juhp> ivanm: sorry he did
23:26:07 <dmead> ddarius++
23:26:13 <dmead> ivanm++
23:26:21 <ivanm> juhp: oh, so _you're_ the one that's lying!
23:26:34 <ivanm> dobblego: I apologise for thinking poorly of you... juhp misled me :s
23:26:46 <ivanm> dmead: even though I mainly kept paying out parsec rather than helping? :p
23:26:47 <juhp> dobblego: just forgot where I saw the AusHac first
23:26:55 <juhp> ivanm: sorry that was mostly typo
23:27:30 <ivanm> humph
23:27:32 <juhp> was trying to write "dunno"
23:27:32 <dmead> :P
23:27:43 <juhp> anyways all good
23:27:46 <ivanm> and with that, I'm gone
23:28:10 <juhp> perhaps worth repeating though
23:31:15 <juhp> dobblego: I sent a reminder to the meetup list or tried to anyway :)
23:32:02 <dobblego> for AusHac you mean?
23:32:21 <Axman6> we have a list?
23:32:35 <dobblego> Brisbane Functional Programming Group does
23:32:41 <Axman6> ah
23:33:19 <ski> dmead,DanC : s/type and type constructor/type and data constructor/
23:34:02 <ski> DanC : i would usually name the data constructor differently from the type (constructor), like `data D1 = MkD1 Int' if i can't come up with a better name
23:34:16 <dobblego> FWIW, the chance that I will make AusHack has increased considerably in the last 24 hours
23:34:39 <DanC> yeah, ski, it seems to me that The Report is unnecessarily confusing/tricky there
23:34:44 <ski> DanC : using that, your `d1' function becomes `d1 (MkD1 i) = 42' .. so you see that doesn't really correspond exactly to `def d1(i: D1) := 42'
23:35:08 <DanC> hmm
23:35:12 <DanC> then how do I read it?
23:35:28 <ski> the argument of `d1' has type `D1'
23:35:52 <ski> that argument is *matched* against the pattern `MkD1 i', so that `i' becomes an `Int'
23:36:02 <DanC> (MkD1 i) is a pattern?
23:36:04 <DanC> ah. yes.
23:36:14 <ski> if you call `MkD1 17', (`17' being an `Int' in this case), you construct a `D1'
23:36:41 <ski> when you define functions, you can "go the other way", from a `D1', via a pattern, to the parts that it was composed of
23:37:35 <DanC> so the scala translation is more like: def d1 := MkD1(i) => 42
23:37:38 <ski> but, if you have defined a function `foo :: Int -> D1; foo x = MkD1 (x*x)', then you can't match on `foo', i.e. you can't say `d2 (foo i) = ..i..', and expect that to work
23:38:12 <wvd> Is lambdabot opensource?
23:38:14 <ski> (in patterns you can only match on *constructor* functions)
23:38:28 * DanC nods
23:39:01 <DanC> in scala, you can match case classes and other deelies with an unApplySeq method... or some such magic.
23:39:09 <wvd> Nvm, got it.
23:39:11 <ski> DanC : i don't really know Scala, but that looks like it could be similar, if `.. => ..' is the notation of anonymous functions in Scala
23:39:37 <dobblego> unapply
23:39:51 <DanC> I think I got the => syntax not quite right; but there's some syntax for pattern matching functions
23:40:33 <ski> DanC : jfyi, you can also write `d1 (MkD1 i) = 42' as `d1 x = case x of MkD1 i -> 42'
23:41:32 <DanC> or in spelled-out scala: def d1(x: D1) := case x of MkD1(i) => 42
23:41:49 * DanC wonders if you can avoid the D1 in scala... thinks not
23:42:37 <dobblego> def d1(x: D1) = match x { case MkD1(i) => 42 }
23:42:44 <dobblego> def d1(x: D1) = x match { case MkD1(i) => 42 }
23:42:52 <DanC> oops; right; forgot the match
23:44:00 <DanC> I think I'm getting tired... I just can't absorb the polymorphic recursion example in http://www.haskell.org/onlinereport/decls.html 4.4.1
23:44:53 <DanC> how could x == 1 make sense given x :: T Int ?
23:45:51 <ski>   f x == 1
23:46:01 <ski>   f x :: Int
23:46:55 <DanC> but the expression is x == 1, not f x == 1. I don't see your point
23:47:06 <ski> you're misreading
23:47:13 <ski>   f (K x y) =  if f x == 1 then f y else undefined
23:47:22 <ski> note the `f' before the `x == 1', there
23:47:31 <ski> `f x == 1' is parsed as `(f x) == 1'
23:47:31 <DanC> ah!
23:47:33 <DanC> thanks
23:47:40 <ski> np
23:47:42 <DanC> I read right past that f
23:47:53 <ski> DanC : (imo) an example easier to grasp could be to consider a type of perfectly balanced trees
23:47:58 <ski>   data Tree a = Leaf a
23:48:03 <ski>               | Double (Tree (a,a))
23:48:20 <DanC> yeah... I hate foo/bar examples.
23:48:32 <ski> examples of values are
23:48:40 <ski>   Leaf 17 :: Tree Int
23:48:53 <ski>   Leaf (17,42) :: Tree (Int,Int)
23:49:02 <ski>   Double (Leaf (17,42)) :: Tree Int
23:49:46 <ski>   Double (Leaf (Just (17,42)) :: Tree (Maybe (Int,Int))
23:50:09 <ski> er, actually, that last was wrong, it should be
23:50:24 <ski>   Double (Leaf (Just 17,Just 42) :: Tree (Maybe Int)
23:50:45 <ski>   Leaf ((17,42),(28,496)) :: Tree ((Int,Int),(Int,Int))
23:50:54 <ski>   Double (Leaf ((17,42),(28,496))) :: Tree (Int,Int)
23:51:04 <ski>   Double (Double (Leaf ((17,42),(28,496)))) :: Tree Int
23:51:34 <ski> so, the idea is that you start with a nested pair of pairs, of things of type `a' (all at the same "level/depth")
23:51:41 <DanC> that last one is not Tree(Int, Int)?
23:51:59 <DanC> hmm... maybe I see.
23:52:03 <ski> you wrap it with `Leaf' to construct a tree from that, then you wrap it in `Double' as many times as you had nested pairs, so that you finally end up with `Tree a'
23:52:27 <ski> it's a trick to be able to ensure in the types that the number of elements must be a power of two
23:52:46 <DanC> ok, i see
23:53:04 <ski> so, how to e.g. define a "map" function on this type ?
23:53:15 <ski> you've met `map' for lists, right ?
23:53:45 <ski> > map floor [1,1.3 .. pi]
23:53:46 <lambdabot>   [1,1,1,1,2,2,2,3]
23:54:04 <ski> > let f x = (x,floor x) in map f [1,1.3 .. pi]
23:54:05 <lambdabot>   [(1.0,1),(1.3,1),(1.6,1),(1.9000000000000001,1),(2.2,2),(2.5,2),(2.8,2),(3....
23:54:06 <DanC> sure... map is a friend from lisp/scheme/python
23:54:16 <ski> ok, so, the question is, how to define
23:54:24 <ski>   mapTree :: (a -> b) -> (Tree a -> Tree b)
23:54:27 <ski> ?
23:54:32 <DanC> er... oh... strongly typed map
23:55:06 <ski> you get a tree of `a's and a function that can translate individual `a's into individual `b's
23:55:16 <ski> and you has to create a tree of `b's
23:55:27 <c_wraith> can't the compiler do that by itself these days? >_>
23:55:43 <ski> (also, for it to actually be a "map", it should "preserve the structure of the tree, only touching the elements)
23:55:44 * c_wraith points at the new deriving functor stuff
23:55:49 <DanC> mapTree f (Leaf x) = Leaf f x
23:56:00 <ski> c_wraith : i think it can for regular types .. not sure about non-regular
23:56:17 <ski> DanC : yes (modulo missing brackets)
23:56:35 <DanC> mapTree f (Double l r) = ... hm...
23:56:46 <DanC> mapTree f (Double l r) = Double f l f r
23:56:53 <ski> that's not quite right
23:56:59 <ski> `Double' only takes one argument
23:57:29 <ski> it's not `data Tree a = ... | Double (Tree a) (Tree a)' but `data Tree a = ... | Double (Tree (a,a))'
23:57:54 <c_wraith> ooh.  that means polymorphic recursion, which means that the compiler can't infer it.
23:58:04 <c_wraith> It probably can't derive functor for this case.
23:58:04 <ski> so, if you get a `Tree a', and it is of the `Double'-form, then the type definition says that the argument/part of `Double' is of type `Tree (a,a)'
23:58:24 <DanC> mapTree f (Double z) = Double f z -- that doesn't seem right either
23:58:36 <c_wraith> DanC: needs more recursion
23:58:42 <DanC> mapTree f (Double z) = Double mapTree f z -- maybe?
23:58:43 <ski> well, probably you'll need a recursion, don't you think ?
23:58:45 <c_wraith> DanC: also more aprens
23:58:48 <c_wraith> err, parens
23:59:27 <ski> if you start
23:59:35 <ski>   mapTree f (Double z) = ...
23:59:36 <DanC> hmm... I thought f(x) could be written f x. where are parens needed?
23:59:38 <ski> then, assuming
23:59:42 <ski>   Double z :: Tree a
23:59:47 <ski> then you get
23:59:50 <ski>   z :: Tree (a,a)
