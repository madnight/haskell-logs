00:03:53 <lars9> dmwit: in the fibs and wavefront examples, the array is defined in a recursive way, so it's possible that when i take a!(x,y) from 2-d array a, all related cells are evaluated on demand?
00:07:22 <solrize> is there any weird space leak issue with groupby, like there is with minimum?  this is about the same problem as last night, i'm still puzzling over it
00:08:04 <dmwit> lars9: yes
00:09:44 <lars9> dmwit: so the order of definition does not matter at all? e.g.: array (1,n) [(i, f i) | i <- [1..n]] the same as ... i <- reverse [1..n]
00:12:27 <dmwit> lars9: yes =)
00:12:54 <lars9> dmwit: cool, thanks
00:14:27 <nus> @src groupBy
00:14:27 <lambdabot> groupBy _  []       =  []
00:14:28 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
00:14:28 <lambdabot>     where (ys,zs) = span (eq x) xs
00:14:48 <solrize> nus, yeah, i was looking at that too
00:14:52 <nus> "weird space leak issue"?
00:15:22 <solrize> yeah, like "maximum [1..1000000] will run out of stack
00:15:23 <nus> groupBy holds on each span (zs)
00:16:55 <solrize> it tries to figure out zs before you've peeled off all the ys's?
00:17:32 <Saizan> no
00:18:14 <Saizan> > head . group $ [1,1,2] ++ undefined
00:18:15 <lambdabot>   [1,1]
00:18:24 <solrize> k
00:18:25 <Saizan> > head . group $ [1,1] ++ undefined
00:18:26 <lambdabot>   [1,1*Exception: Prelude.undefined
00:19:27 <solrize> > map (take 5) $ group (repeat 1)
00:19:30 <lambdabot>   mueval-core: Time limit exceeded
00:19:33 <solrize> hmm
00:19:48 <solrize> > head $ map (take 5) $ group (repeat 1)
00:19:49 <lambdabot>   [1,1,1,1,1]
00:19:58 <solrize> that's what i meant
00:21:30 <nus> @src map
00:21:30 <lambdabot> map _ []     = []
00:21:30 <lambdabot> map f (x:xs) = f x : map f xs
00:35:49 <dmwit> > take 12 . show . map (take 5) . group . repeat $ 1
00:35:50 <lambdabot>   "[[1,1,1,1,1]"
00:35:56 <dmwit> ...and then it loops =)
00:37:15 <lars9> cycle [1]
00:37:33 <lars9> replicate 12 [1]
00:37:54 <osaunders> lars9: Try prepending with >
00:38:06 <osaunders> > 1 + 1
00:38:07 <lambdabot>   2
00:38:11 <lars9> osaunders: thanks
00:38:37 <lars9> osaunders: will cycle [1] crash bot?
00:38:43 <osaunders> No.
00:38:54 <lars9> osaunders: cool
00:38:59 <dmwit> > cycle [1] -- just try it =)
00:38:59 <osaunders> > cycle [1]
00:39:00 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
00:39:00 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
00:39:11 <dmwit> lars9: \bot has been battle-tested for over a decade
00:39:28 <lars9> > cycle (cycle [1])
00:39:29 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
00:39:42 <lars9> dmwit: cool
00:39:58 <osaunders> > cycle [cycle]
00:39:58 <lambdabot>   [*Exception: Prelude.cycle: empty list
00:40:27 <dmwit> ha
00:40:28 <dmwit> cute
00:40:40 <dmwit> That's a good head-scratcher for a few seconds. =)
00:40:56 <Axman6> yeah.. what?
00:41:08 <osaunders> Yeah, I don't understand what happened there.
00:41:12 <dmwit> The show instance for ([] -> []) tries to feed it an empty list first.
00:41:14 <nus> @src cycle
00:41:14 <lambdabot> cycle [] = undefined
00:41:14 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
00:41:43 <timofonic> I', switching to Clyde too...
00:41:46 <Axman6> ah, thanks dmwit
00:42:02 <dmwit> > (>>= replicate 3) :: [()] -> [()]
00:42:03 <lambdabot>   []->
00:42:03 <lambdabot>    []
00:42:03 <lambdabot>  [()]->
00:42:03 <lambdabot>    [(),(),()]
00:42:03 <lambdabot>  [(),()]->
00:42:05 <lambdabot>    [(),(),(),(),(),()]
00:42:07 <lambdabot>  [(),(),...
00:42:14 <timofonic> Are you playing a Z machine game here or what? haha
00:42:19 <dmwit> > cycle :: [()] -> [()]
00:42:20 <lambdabot>   *Exception: Prelude.cycle: empty list
00:42:31 <osaunders> > cycle
00:42:32 <lambdabot>   *Exception: Prelude.cycle: empty list
00:42:41 <osaunders> > map
00:42:42 <lambdabot>   {{()->()}->{[]->[];[()]->[()];[(),()]->[(),()];[(),(),()]->[(),(),()]}}
00:42:59 <timofonic> It's that "Haskell: the game"?
00:43:46 <timofonic> > kill humans
00:43:47 <lambdabot>   Not in scope: `kill'Not in scope: `humans'
00:44:06 <timofonic> Oh, it's safe then :)
00:44:36 <c_wraith> > cake
00:44:37 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
00:44:47 <timofonic> > the cake is a lie
00:44:48 <lambdabot>   Not in scope: `the'Not in scope: `is'Not in scope: `lie'
00:44:59 <c_wraith> > cake !! 25
00:45:00 <lambdabot>   "An entry called 'how to kill someone with your bare hands.'"
00:45:01 <osaunders> > murder myDog
00:45:02 <lambdabot>   "OK, I killed it."
00:45:24 <timofonic> > murder emacs
00:45:25 <lambdabot>   Not in scope: `emacs'
00:45:46 <dmwit> > don't murder myDog
00:45:47 <lambdabot>   "OK, fine, I won't."
00:45:55 <osaunders> lol
00:46:02 <c_wraith> :t don't
00:46:03 <lambdabot> forall t t1. t -> t1 -> [Char]
00:46:04 <timofonic> > kill allHumans
00:46:05 <lambdabot>   Not in scope: `kill'Not in scope: `allHumans'
00:46:19 <osaunders> So, anyway... :P
00:46:23 <c_wraith> > don't () ()
00:46:24 <lambdabot>   "OK, fine, I won't."
00:46:30 <Axman6> :t don't
00:46:31 <lambdabot> forall t t1. t -> t1 -> [Char]
00:46:44 <Axman6> > don't
00:46:45 <lambdabot>   {()->{()->"OK, fine, I won't."}}
00:46:46 <dmwit> c_wraith: There's really not that many possible implementations with that type. =)
00:46:59 <timofonic> Ohh
00:47:14 <timofonic> Haskell olympics
00:47:27 <Axman6> what're you on about timofonic?
00:47:41 <timofonic> Axman6: newbie...
00:48:03 <Axman6> well, time to start learning then ;)
00:48:07 <timofonic> Axman6: Looking to haskellizing myself
00:48:47 <lars9> what is the complexity of Array's (!)?
00:48:54 <dmwit> O(1)
00:48:57 <Axman6> O(1)
00:48:58 <dmwit> well
00:49:02 <dmwit> It depends on the Ix instance.
00:49:04 <Axman6> ish
00:49:11 <dmwit> But most built-in Ix instances are O(1).
00:49:17 <lars9> O(1) on any Ix?
00:49:22 <lars9> dmwit: i see
00:49:35 <Axman6> @instances Ix
00:49:36 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
00:49:45 <Axman6> @instances-importing Data.Array Ix
00:49:46 <timofonic> Axman6: Tried to learn emacs and elisp fail, tried to learn C and failed too, females tons of crashes. Now going to Haskell and try C again, it's a necessary evil :)
00:49:46 <lambdabot> (), (a, b), (a1, a2, a3), (a1, a2, a3, a4), Bool, Char, Int, Integer, Ordering
00:50:03 <lars9> so it's cooler than Data.Map if we dont need to update?
00:50:07 <dmwit> Okay, all of those instances are O(1). =)
00:50:26 <dmwit> lars9: It's cooler than Data.Map if you don't need to update, you know the exact range ahead of time, and your mapping is dense.
00:50:32 <Axman6> lars9: depends what you want to do. also, there are mutable arrays
00:50:34 <dmwit> lars9: i.e. it's cool when you need an array. =)
00:51:06 <lars9> dmwit, Axman6 yeah i see, thanks:)
00:51:06 <Axman6> yeah, Arrays are pretty good at being arrays
00:51:07 <timofonic> Okay, now I understand why lispers are sissies compared to haskellers :P
00:51:41 <Axman6> timofonic: how so?
00:51:43 <timofonic> Now I'm scared about being able to learn Haskell
00:51:52 <Axman6> haskell's easy
00:51:55 <timofonic> Axman6: Uhhh, lot's of nerd powers
00:51:55 <Axman6> @src map
00:51:55 <lambdabot> map _ []     = []
00:51:55 <lambdabot> map f (x:xs) = f x : map f xs
00:52:18 <Axman6> map applies the function f to each element of a list
00:52:28 <timofonic> Axman6: I'll try to learn...
00:52:28 <osaunders> I want to write a simple whitespace parser that returns a tree.
00:52:50 <osaunders> Where indentation determines nesting.
00:53:04 <timofonic> Axman6: So you specify a function? Do you mean "f" is a function already exists?
00:53:15 <Axman6> yes
00:53:17 <osaunders> Where should I begin?
00:53:18 <lars9> the exercise im doing now is dynamic programming in haskell, the examples are using Array because it can be defined recursively. But map is not good in DP because it cannot, right?
00:53:19 <dmwit> osaunders: sounds like fun!
00:53:27 <Axman6> osaunders: parsec
00:53:31 <timofonic> Axman6: Uhh
00:53:32 <dmwit> osaunders: Take a look at the Parsec documentation. That's the defacto standard for parsing.
00:53:47 <Axman6> > map \(x -> x*x) [1,2,3,4,5]
00:53:48 <lambdabot>   <no location info>: parse error on input `\'
00:53:52 <osaunders> Actually I want to do it without Parsec.
00:53:54 <Axman6> > map (\x -> x*x) [1,2,3,4,5]
00:53:55 <lambdabot>   [1,4,9,16,25]
00:53:57 <timofonic> Funny, I remember a game with a similar name :P
00:54:08 <osaunders> Because I have to write it in another language and I want to see what it's like in Haskell.
00:54:21 <dmwit> osaunders: Okay, there's several other options. ReadP, AttoParsec, happy, etc.
00:54:26 <Axman6> make your own parser combinators :P
00:54:27 <dmwit> osaunders: Wait, I don't understand your reason.
00:54:36 <dmwit> osaunders: Did you think that Parsec is not Haskell...?
00:54:36 <Saizan> lars9: it can, to build a Map you only have to force the keys, not the elements
00:54:43 <Axman6> osaunders: parsec _is_ how you'd do it in haskell ;)
00:54:54 <osaunders> The other a languages won't have any fancy tools.
00:55:07 <dmwit> So...?
00:55:11 <osaunders> So I won't be able to make the translation.
00:55:16 <dmwit> I would blame the other language for that, not Haskell.
00:55:20 <Saizan> lars9: though using a Map would just be slower
00:55:57 <osaunders> Huh? I'm blaming Haskell?
00:56:03 <dmwit> You can do parsing combinators in any language, anyway. There's even a website showing how to do it in C. =O
00:57:04 * ddarius has implemented parser combinators in Javascript.
00:57:35 <timofonic> Oh, javascript
00:58:04 <pastorn> osaunders: if you wanna do it in C++ you have boost, which has parser combinator stuff
00:58:07 <timofonic> Even web developers use tools to generate the javascript code, people don't want to touch it with a stick
00:58:50 <dmwit> osaunders: Anyway, I don't think a language comparison exercise that restricts Haskell to the subset of features available in the other language is really fair.
00:58:52 <timofonic> pastorn: C++0x? Or C++ 21XX :D
00:59:04 <pastorn> timofonic: it just needs to support templates
00:59:10 <pastorn> timofonic: boost is a library
00:59:16 <timofonic> pastorn: How many centuries?
00:59:24 <dmwit> I feel similarly about restricting in the other direction, in case that matters.
00:59:31 <timofonic> pastorn: Yes, but it's like a craddle for future C++ stuff, right?
00:59:52 <pastorn> timofonic: i don't know any c++, so i'll just shut up now
01:00:31 <Saizan> dmwit: is it a language comparison? i understood it more like prototyping
01:00:34 <timofonic> pastorn: boost.org yes... there's the next C++ standard and is getting stuff from Boost. But years and years, worser than HTML5...
01:00:38 <timofonic> pastorn: oh ok
01:00:53 <lars9> Saizan: i see thanks
01:00:56 <pastorn> "worser" :p
01:01:27 <dmwit> Saizan: "I have to write it in another language and I want to see what it's like in Haskell" <- sounds like a comparison to me, but I'm often wrong
01:01:48 <lars9> when importing Data.Map and Data.Array at the same time, (!) and fromList becomes ambiguous... how to make it compile?
01:02:08 <pastorn> lars9: 'import qualified Data.Map as M'
01:02:10 <dmwit> use Data.Map.! vs Data.Array.! or import with an extra name
01:02:23 <dmwit> e.g. import Data.Map as M, then use M.!
01:02:27 <pastorn> lars9: then you call M.insert k v instead of the normal one
01:03:02 <pastorn> lars9: to make your type signatures still look nice, also have 'import Data.Map (Map)'
01:03:15 <lars9> ok, but m M.! k looks a wierd
01:03:45 <dmwit> I feel like importing qualified is a knee-jerk reaction. For Map and Array it makes sense, but people should be aware that it's only really necessary for modules that define functions that overlap with the Prelude.
01:03:46 <pastorn> lars9: why are you using both Arrays and Maps in one module then?
01:04:15 <dmwit> lars9: Yeah, it looks weird. Them's the apples, I'm afraid.
01:05:08 <pastorn> lars9: you can do 'import Prelude hiding (!!)' and then redifen !! as A.! or something similar
01:05:20 <pastorn> *redefine
01:05:33 <lars9> i see, thanks. pastorn: because im doing exercises..
01:09:20 <temoto> Hello.
01:09:28 <dmwit> howdy
01:09:28 <pastorn> hi
01:09:32 <temoto> Can this be written with list in front?
01:09:39 <dmwit> ?hpaste
01:09:40 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
01:09:53 <temoto> > map (+1) >>> filter odd $ [1..9]
01:09:54 <lambdabot>   [3,5,7,9]
01:10:19 <pastorn> @faq can that be written in haskell with list in front?
01:10:19 <lambdabot> The answer is: Yes! Haskell can do that.
01:10:27 <dmwit> > ($ [1..9]) $ map (+1) >>> filter odd
01:10:27 <lambdabot>   [3,5,7,9]
01:11:04 <dmwit> > const [1..9] >>> map (+1) >>> filter odd $ ()
01:11:04 <temoto> Oh right i was going to ask about some (`op` list) magic :)
01:11:04 <lambdabot>   [3,5,7,9]
01:11:29 <dmwit> > const [1..9] >>> map (+1) >>> filter odd
01:11:30 <lambdabot>   {()->[3,5,7,9]}
01:13:23 <nus> > map (+1) <<< filter odd $ [1..9]
01:13:24 <lambdabot>   [2,4,6,8,10]
01:13:57 <ivanm> am I able to use pre-defined Exception instances, or do I have to roll my own?
01:14:01 <dmwit> For functions, you might as well use (.) instead of (<<<).
01:15:16 <Saizan> ivanm: you've to pay a fee
01:15:25 <ivanm> Saizan: :(
01:15:40 * ivanm wanted to use IOException, but it appears he can't since the constructor isn't exported :s
01:16:05 <temoto> iothrow?
01:16:13 <ivanm> @hoogle iothrow
01:16:13 <lambdabot> No results found
01:16:19 <Saizan> maybe there are some smart constructors
01:16:48 <ivanm> temoto: hayoo can't find iothrow either...
01:16:56 <Saizan> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/System-IO-Error.html
01:16:56 <pastorn> @type throw
01:16:57 <lambdabot> Not in scope: `throw'
01:17:01 <ivanm> Saizan: doesn't appear to be (they're not in COntrol.Exception at least)
01:17:03 <ivanm> Saizan: ahhh
01:17:10 <temoto> @hoogle throwio
01:17:10 <lambdabot> Control.Exception throwIO :: Exception e => e -> IO a
01:17:10 <lambdabot> Control.OldException throwIO :: Exception e => e -> IO a
01:17:10 <lambdabot> Control.Exception.Base throwIO :: Exception e => e -> IO a
01:17:20 <dmwit> ?hoogle ioError
01:17:20 <lambdabot> Prelude ioError :: IOError -> IO a
01:17:21 <lambdabot> Control.Exception ioError :: IOError -> IO a
01:17:21 <lambdabot> Control.OldException ioError :: IOError -> IO a
01:17:46 <Saizan> those accept IOException's, they don't create them :)
01:17:57 <dmwit> ioError :: IOError -> IO a
01:18:04 <dmwit> IOError /= IOException
01:18:15 <Saizan> type IOError = IOException
01:18:29 <dmwit> argh
01:18:32 <dmwit> Yes, you're right.
01:18:47 <dmwit> but
01:18:52 <dmwit> ?hoogle userError
01:18:52 <lambdabot> Prelude userError :: String -> IOError
01:18:53 <lambdabot> System.IO.Error userError :: String -> IOError
01:18:53 <lambdabot> Control.OldException userErrors :: Exception -> Maybe String
01:18:58 <dmwit> ?hoogle mkIOError
01:18:58 <lambdabot> System.IO.Error mkIOError :: IOErrorType -> String -> Maybe Handle -> Maybe FilePath -> IOError
01:19:01 <ivanm> yeah, looks like I want userError
01:19:07 <ivanm> which matches what the problems are going to be anyway...
01:19:31 <dmwit> It's an eye-dee ten tee error. ;-)
01:20:42 <ivanm> dmwit: heh, not qutie
01:20:52 <Adamant> errors involving the identity function are actually surprisingly common
01:20:59 <Adamant> oh wait :p
01:21:10 * Adamant is joking, of course
01:21:41 <ivanm> dammit, I was going to drop the unsafePerformIO'd version of a function, except I need that for part of my test suite (admittedly it isn't used atm since the Arbitrary instances aren't smart enough, but still...)
01:22:39 <ivanm> I suppose I can just unsafePerformIO it in the test suite itself
01:23:46 <dmwit> Well, maybe I can still salvage some sleep from this night.
01:23:59 <temoto> Huge refactoring or one little goto?
01:24:56 <temoto> ivanm, http://xkcd.com/292/
01:25:30 <ivanm> temoto: not huge at all
01:25:59 <ivanm> I was previously using error if something went wrong, and figured that that would be a _bad_ thing to do
01:26:49 <temoto> ivanm, why?
01:27:17 <ivanm> why I was using, or why it would be bad?
01:28:01 <ivanm> *using it
01:28:22 <temoto> Why it would be bad.
01:28:34 <temoto> Why you was using it, is pretty much obvious to me.
01:29:11 <ivanm> because the errors that would result are IO based
01:29:28 <ivanm> e.g. the command it calls can't be found, or it can't find an image being referenced, etc.
01:30:37 <temoto> So you could return something like Left ("command is not found", additionalData) ?
01:31:01 <ivanm> I'm converting from an Either value :p
01:31:15 <ivanm> temoto: this is for stuff that _should_ work, if you did stuff properly
01:31:34 * ivanm heads off
01:31:50 <solrize> Rewrite of MediaWiki parser
01:31:50 <solrize> On the software side, the long-standing goal to rewrite the MediaWiki parser "in a more friendly and accessible implementation" was achieved on 1 April by porting it to the LOLCODE programming language.
01:32:42 <temoto> ivanm, I'm not an expert or even any good at it, but AFAIK haskell teaches that exceptions are what the name suggests: they're define exceptional case, while command not found is a normal case for invalid user input.
01:32:43 <osfameron> does lolcode do recursion using the YO DAWG! construct?
01:32:47 <ivanm> solrize: methinks you're a bit late :p
01:33:16 <ivanm> temoto: this is for my graphviz library; if the user wants to use it they _should_ have the Graphviz suite of tools installed
01:33:58 <ivanm> and I'm uncomfortable using error when something is going to be staying in IO anyway
01:34:25 <kmc_> temoto, http://goatkcd.com/292/sfw (mostly but not entirely sfw)
01:35:03 <mxc> hm
01:35:10 <mxc> anyone ever see this:  "internal error: evacuate: strange closure type 0"
01:35:37 <kmc_> i would run screaming if i saw that
01:35:52 <mxc> if only i had somewhere to run to
01:36:12 * osfameron points at the hills
01:38:47 <solrize> kmc_ argggh  ;)
01:38:51 <solrize> ivanm oh well ;)
01:39:04 <solrize> ivanm, that was just in the wikipedia newsletter
01:39:15 <solrize> oh wait it's an old issue
01:39:18 <solrize> heh
01:40:27 <solrize> that goatkcd is crazy, like garfield without words
01:41:06 <osfameron> I never got garfield-sans-garfield, or whatever it was called
01:41:13 <osfameron> then again, I didn't really get garfield iether
01:41:15 <solrize> yeah, that's what it was
01:41:22 <solrize> garfield without garfield
01:41:39 <osfameron> "minus" apparently
01:41:42 <solrize> yeah
01:42:22 <solrize> it's brilliant for the first minute or so
01:42:57 <osfameron> actually, that's better than I remembered it
01:43:06 <temoto> kmc, what is 'sfw'?
01:43:19 <solrize> safe for work
01:43:35 <temoto> Safe for work?
01:43:39 <solrize> click "original" to see the nfsw version, blecch
01:43:53 <solrize> yeah, nfsw (not safe for work) means something you don't want on your screen at the office
01:44:08 <osfameron> like COBOL
01:44:12 <solrize> heh
01:44:38 <temoto> oh
01:48:45 <muhtimin> win 35
01:48:48 <muhtimin> ... sorry
02:03:25 <solrize> speaking of cobol, has anyone looked at scala?  is it promising at all?
02:03:39 <BONUS> it's a pretty neat cobol dialect
02:03:54 <solrize> ic
02:05:36 <roconnor> > 1327/15706
02:05:37 <lambdabot>   8.44900038201961e-2
02:07:50 <timofonic> > 127263/58762*2837653+$8576%777&&
02:07:51 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
02:08:27 <timofonic> > 555 && 123
02:08:28 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
02:08:28 <lambdabot>    arising from the literal `55...
02:08:51 <timofonic> :D
02:13:52 <luite> instance Num Bool where fromInteger 0 = False \n fromInteger _ = True  etc ;)
02:14:32 <hpaste>  DigitalKiki, we found a problem! (haskellspain)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24941
02:14:51 <timofonic> It was me
02:15:04 <timofonic> Oh, kiwi. Sorry, didn't know it showed here
02:18:41 <Axman6> win 20
02:18:44 <Axman6> whoops
02:19:23 <Liskni_si> MarcWeber: http://store.lisk.in/tmp/patches-for-marc.mbox <- fixes for the two bugs in tracker and one more
02:20:22 <timofonic> Uh?
02:20:37 <timofonic> Liskni_si: Sending patches under an .mbox format? :D
02:20:56 <Twey> Hahaha
02:21:00 <Liskni_si> timofonic: there was no darcs send in git
02:21:01 <Twey> Cute
02:21:03 <Axman6> probably darcs' defauls format
02:21:11 <Axman6> or failgit
02:21:35 <timofonic> Oh, that's why I've seen Haskell people coding a morse code app...
02:21:36 <Liskni_si> timofonic: so i just git git format-patch --stdout and uploaded, it can be viewed using mutt -f and applied using git am, so everything seems to be quite okay :-)
02:21:57 <Liskni_si> s/git/did/
02:21:58 <Liskni_si> :-)
02:22:06 <timofonic> Liskni_si: Do you use morse code over two glasses of plastic too? :-)
02:22:30 <Liskni_si> bah
02:22:36 <Liskni_si> how should have i done it?
02:22:38 <timofonic> Liskni_si: But Mutt devs use Mercurial to code, not git :(
02:23:22 <timofonic> Liskni_si: I'm just bored and need to laugh a bit, don't care of my stupidities :)
02:23:35 <timofonic> Liskni_si: But... it's funny :D
02:23:46 <Liskni_si> it's not funny!
02:30:59 <HugoDaniel> hi
02:31:54 <timofonic> Liskni_si: But envy because you know to code better than me :)
02:32:17 <timofonic> Liskni_si: My code seems like punching the keyboard with the ass...
02:33:40 <Liskni_si> :-)
02:39:58 <lars9> how to achieve this purpose in haskell? say f is a method, when (f x) has never been evaluated before, eval it, otherwise just fetch it from cache.
02:40:52 <yottis> http://www.haskell.org/haskellwiki/Memoization
02:42:19 <timofonic> If there's a key combination for everything in emacs... there's a solution for everything in haskell? I need money...
02:42:37 <arcatan> @faq Can Haskell solve your financial problems?
02:42:38 <lambdabot> The answer is: Yes! Haskell can do that.
02:43:15 <timofonic> @faq Can Haskell solve your hair loss problems?
02:43:15 <lambdabot> The answer is: Yes! Haskell can do that.
02:43:38 <timofonic> Anyway, I have a strong and pretty curly hair... ;)
02:44:15 <lars9> @faq can haskell not answer this question?
02:44:15 <lambdabot> The answer is: Yes! Haskell can do that.
02:44:32 <timofonic> Going to eat something, then wait and play with C/Haskell and complain (aka crying)
02:44:33 <lars9> @faq can haskell not do that?
02:44:33 <lambdabot> The answer is: Yes! Haskell can do that.
02:46:02 <timofonic> @faq Can I use Haskell to win to Godzilla and Mazinger Z in a battle using bottles of wine and having it running on a zx-81?
02:46:02 <lambdabot> The answer is: Yes! Haskell can do that.
02:46:27 <timofonic> ohhh
02:46:32 <timofonic> See you
02:51:48 <lars9> how to get max item in a [Int]?
02:52:06 <nff> lars9, maximum
02:52:10 <nff> @type maximum
02:52:11 <lambdabot> forall a. (Ord a) => [a] -> a
02:53:07 <lars9> nff: thanks
03:50:33 <kamatsu> @faq can haskell be worse than ocaml?
03:50:33 <lambdabot> The answer is: Yes! Haskell can do that.
03:51:24 <kamatsu> I suppose "worse" is very subjective
03:51:48 <danderson> indeed
03:52:25 <danderson> if you're talking just performance, both are roughly at the same point afaik (ie. fast enough by default that it doesn't really matter any more)
03:55:30 <benmachine> http://en.wikiquote.org/wiki/Rasmus_Lerdorf heehee
03:55:35 <kamatsu> i know
03:55:37 <kamatsu> >_>
03:55:49 <kamatsu> I thought it might've been Guido before I read the origin of that quote
04:05:21 <sepp2k> @faq Can haskell satisfy my wife?
04:05:21 <lambdabot> The answer is: Yes! Haskell can do that.
04:12:02 <timofonic> kamatsu: I use Clyde for Archlinux and runs finer than Pacman :)
04:15:29 <timofonic> kamatsu: Guess on what's coded Pacman... C. Clyde on this weird crap :D
04:17:03 <kamatsu> timofonic: good to know? why do you mention this to me?
04:17:24 <kamatsu> i mean, i use arch
04:17:30 <kamatsu> but.. seems odd
04:17:33 <timofonic> kamatsu: Oh nothing
04:17:52 <timofonic> kamatsu: Sorry. I did think you being new and saying about this shit being slow :P
04:18:05 <kamatsu> i was speaking in good humour
04:18:17 <timofonic> kamatsu: Oh, ok sorry
04:18:18 <kamatsu> i'm an experienced haskeller
04:18:19 <kamatsu> ;)
04:18:30 <timofonic> kamatsu: Not me
04:22:25 <timofonic> kamatsu: I'm the eternal novice on everything :P
04:22:42 <Axman6> less time on IRC, more time writing code
04:23:51 <timofonic> Axman6: Yes, I'll concentrate more. Also, I tried to massive flirting IRL but enough luck so going back to geek stuff :P
04:24:07 <timofonic> Axman6: Better luck next time...
04:34:03 <dv-> Has anyone used Control.Concurrent.Process from the eprocess package?
04:42:04 <Axman6> > do { last . repeat; is;} 3
04:42:05 <lambdabot>   <no location info>: parse error on input `3'
04:42:13 <Axman6> > (do { last . repeat; is;}) 3
04:42:13 <lambdabot>   Not in scope: `is'
04:42:18 <Axman6> > (do { last . repeat; id;}) 3
04:42:19 <lambdabot>   3
04:42:45 <pastorn> can a Chan be used between more than two treads?
04:43:02 <Twey> pastorn: Of course
04:43:34 <Axman6> they can be used to broadcast messages if you like
04:43:36 <pastorn> Twey: how does it know what's the sending part and what's the recieving?
04:43:41 <bastl> hi
04:43:46 <pastorn> bastl: hello
04:43:47 <Twey> pastorn: It doesn't ‘know’ anything
04:43:51 <Axman6> pastorn: a Chan is just a string of MVars
04:43:56 <Axman6> @src Chan
04:43:57 <lambdabot> Source not found. Just try something else.
04:43:58 <pastorn> ok
04:43:59 <Axman6> bah
04:44:01 <Twey> pastorn: Some threads send, some threads receive
04:44:07 <pastorn> ok :)
04:44:12 <Twey> It's possible, if not usually particularly useful, for them to be the same thread
04:44:18 <hpaste>  . (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24942
04:44:27 <Axman6> something like.. data Chan a = MVar (a,Chan a)... though not that
04:44:29 <dv-> can someone look at that ^
04:44:51 <pastorn> Axman6: why is it nested like that?
04:45:11 <Axman6> well, it isn't like that. one sec, i'll get the actual definition
04:45:24 <pastorn> Axman6: no, you don't have to
04:45:31 <pastorn> i just want to know the idea behind it
04:45:33 <Axman6> i want to :P
04:45:38 <pastorn> hehe
04:45:45 <Axman6> data Chan a
04:45:46 <Axman6>  = Chan (MVar (Stream a))
04:45:46 <Axman6>         (MVar (Stream a))
04:45:55 <Axman6> type Stream a = MVar (ChItem a)
04:45:55 <pastorn> Axman6: it'll probably be overly complicated
04:45:56 <Axman6> data ChItem a = ChItem a (Stream a)
04:46:02 <pastorn> as i said
04:46:03 <Axman6> it's not too bad
04:46:05 <pastorn> overly complicated
04:46:13 <pastorn> (for making a point)
04:46:26 <Saizan> pastorn: it's like a linked list of MVar's, where you keep a reference to both ends though
04:46:38 <Axman6> the only thing that complicates it is that you need to know where both ends are
04:46:57 <Saizan> pastorn: anyhow it's an unbounded buffer, at an higher level
04:47:15 <pastorn> why do you need the chain?
04:47:48 <benmachine> one for each item in the chan
04:47:56 <Saizan> pastorn: as opposed to?
04:48:10 <pastorn> i thought chain were one-item deals
04:48:15 <Saizan> dv-: what's the problem with that code?
04:48:31 <benmachine> pastorn: then they'd be the same as MVars, wouldn't they?
04:48:50 <pastorn> benmachine: yes... maybe i don't see the point of them
04:48:52 <pastorn> *Chan*
04:49:13 <Saizan> a Chan can hold an unlimited amount of items written in it
04:49:22 <Axman6> pastorn: one thread can keep stuffing stuff into a Chan, and keep on going without another thread having to take it out before the first thread can do more work
04:49:44 <pastorn> Axman6: oh, so it works like a FIFO?
04:49:48 <pastorn> between threads?
04:49:50 <Axman6> yes
04:49:53 <pastorn> cool :D
04:50:00 <Axman6> though, more than FIFO
04:50:07 <pastorn> yes?
04:51:03 <Axman6> well, you can also take things from the place they were inserted (unGetChan)
04:51:22 <Saizan> and there's dupChan
04:51:22 <Axman6> wait, unGetchan puts something back at the receiving end
04:52:02 <pastorn>  Saizan does that copy all items in the current queue?
04:52:06 <pastorn> (spelling?)
04:52:22 <Saizan> no
04:52:41 <pastorn> so what does it do?
04:52:42 <Saizan> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/Control-Concurrent-Chan.html#v%3AdupChan
04:52:58 <pastorn> does it link two threads to recieve items from one sender?
04:53:17 <Axman6> read the cods :P
04:53:23 <Axman6> http://www.haskell.org/ghc/docs/6.12-latest/html/libraries/base/Control-Concurrent-Chan.html
04:53:26 <Axman6> docs even
04:53:37 <benmachine> I was wondering whether that was an elaborate haddock/fish pun
04:53:57 <cods> Axman6: yes, because I'm not related to this :p
04:53:57 <pastorn> is Chan + STM a good idea?
04:54:16 <Twey> Haha
04:54:18 <Twey> I like it
04:54:18 <benmachine> there's TChan I believe
04:54:20 <Saizan> pastorn: STM has its own queue type, it's called TChan
04:54:25 <Axman6> they can work together, but i there is TChan i think
04:56:19 <Axman6> :t typeOf
04:56:20 <lambdabot> forall a. (Typeable a) => a -> TypeRep
04:56:36 <roconnor> @type asTypeOf
04:56:36 <Axman6> > typeOf 3
04:56:36 <lambdabot> forall a. a -> a -> a
04:56:37 <lambdabot>   Integer
04:56:44 <Axman6> > typeOf (3 :: Int)
04:56:45 <lambdabot>   Int
04:56:50 <roconnor> > typeOf (asTypeOf)
04:56:51 <lambdabot>   Ambiguous type variable `a' in the constraint:
04:56:51 <lambdabot>    `Data.Typeable.Typeable a...
04:57:16 <roconnor> > typeOf (typeOf 3)
04:57:17 <lambdabot>   TypeRep
04:57:22 <roconnor> > fix typeOf
04:57:22 <lambdabot>   TypeRep
04:57:59 <Axman6> > typeOf (fix typeOf)
04:58:00 <lambdabot>   TypeRep
05:00:04 <chrisdone> Twey: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24930
05:02:09 <Twey> chrisdone: Saw it… cute :þ
05:03:44 <pastorn> chrisdone: Graphics.GD?
05:04:04 <chrisdone> ja
05:04:13 <pastorn> what is it?
05:08:27 <Axman6> dv-: what was the problem with your code btw?
05:10:47 <chrisdone> pastorn: libgd package from hackage
05:12:10 <zygoloid> > map ord "█▓░ "
05:12:11 <lambdabot>   [9608,9619,9617,32]
05:12:27 <zygoloid> > map chr [9608..9617]
05:12:28 <lambdabot>   "\9608\9609\9610\9611\9612\9613\9614\9615\9616\9617"
05:12:29 <pastorn> > █
05:12:29 <lambdabot>   <no location info>: parse error on input `█'
05:12:49 <dv-> Axman6: I don't see how to send something back from p1 to p2
05:13:11 <dv-> Axman6: since to get the Handle you have to spawn p1, but once it's spawned you can't change p1
05:14:04 <Twey> > text $ map chr [9608 .. 9617]
05:14:05 <lambdabot>   █▉▊▋▌▍▎▏▐░
05:14:41 <Axman6> what are the types of spawn and makeProcess?
05:14:51 <roconnor> @hoogle spawn
05:14:52 <lambdabot> No results found
05:15:34 <dv-> spawn :: MonadIO m => Process r k -> m (Handle r)
05:15:45 <dv-> makeProcess :: (m t -> IO s) -> ReceiverT r m t -> Process r s
05:16:10 * Axman6 sees the dreaded T suffix and walks away
05:16:26 <dv-> just ignore the T
05:18:53 <dv-> It seems you can only send messages forward...
05:20:50 <zygoloid> dv-: sounds like you need MonadFix
05:22:34 <dv-> I'll look it up
05:22:52 <dv-> I really wish more hackage packages came with simple examples
05:23:09 <zygoloid> i doubt there's any guarantees that it'll work, but there's a chance
05:24:31 <zygoloid> something like: mfix (\h -> spawn $ makeProcess (getprint "1") (sendRecv h True))
05:24:49 <pozic> MonadFix is a great way to complicate your code, imho.
05:25:16 <zygoloid> pozic: you could say the same about mutually-recursive let bindings
05:25:43 <pozic> zygoloid: you could, but that is less of an issue in my experience.
05:26:40 <hpaste>  Install problem under Clyde (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24943
05:26:56 <pozic> In 90% of the cases I rewrote my code such that it didn't use mfix.
05:27:25 <zygoloid> pozic: i don't think dv-'s case is /possible/ without mfix
05:28:12 <zygoloid> a little nicer, maybe: mdo let process = makeProcess (getprint "1") (sendRecv handle True); handle <- spawn process; return handle
05:28:22 <pozic> zygoloid: mdo is deprecated.
05:28:37 <zygoloid> pozic: sure, but lambdabot doesn't support do rec
05:28:50 <pozic> zygoloid: but you might be right, I didn't look in detail.
05:28:52 <zygoloid> (and i was playing in lambdabot a second ago trying it...)
05:31:30 <zygoloid> pozic: a little background here: http://hackage.haskell.org/trac/ghc/ticket/2798
05:36:00 <micah> I think that I understand what a functor is
05:36:03 <micah> but I'm not sure
05:36:10 <micah> and I'd like to know what  a cofunctor is
05:36:27 <benmachine> I understand what a functor is but I can't help you with cofunctors
05:36:35 <micah> ok
05:36:40 <pozic> zygoloid: I know the ticket.
05:36:42 <zygoloid> micah: ok, first, do you see why: "newtype X a = X (a -> b)" is /not/ a functor
05:36:43 <dobblego> class Cofunctor f where comap :: f a -> (b -> a) -> f b
05:36:44 <benmachine> erm, you're talking about haskell instances of Functor right?
05:36:51 <benmachine> not category theory
05:36:55 * Axman6 wonders if cofmap :: (a -> b) -> f b -> f a
05:37:04 <micah> well I don't really know the difference between the two
05:37:09 <zygoloid> Axman6 is correct
05:37:12 <Axman6> gross, i was right
05:37:37 <micah> zygoloid: I don't really see why
05:37:39 <benmachine> zygoloid: wait, where does the b come from?
05:37:44 <Axman6> it is possible to implement that instance isn't it? (though if i remember rightly, in a nontermination function)
05:37:48 <dobblego> newtype Eq a = E (a -> a -> Bool) -- Eq is a Cofunctor
05:37:50 <zygoloid> benmachine: some constant. say b = Int
05:37:53 <benmachine> oic
05:38:08 <zygoloid> micah: ok, so what would you need to do to define a Functor instance for X?
05:38:20 <micah> isn't it fmap?
05:38:32 <micah> that you need to define?
05:38:36 <micah> or something else?
05:38:40 <zygoloid> yes, it's fmap
05:38:46 <zygoloid> why can't you define fmap?
05:39:20 <micah> well there's no value of type a in the structure
05:39:25 <micah> just a function that takes as
05:39:29 <micah> I think?
05:40:14 * Axman6 is mentally trying to stuff the f in fmap f into the space between the a and -> in X (a -> b) and failing
05:40:43 <micah> yes I see it now
05:40:44 <micah> ok
05:40:49 <micah> I think
05:42:14 <micah> I have to go now :P
05:46:06 <wvd> Are there any good books for Haskell/FP?
05:46:19 <mreh> wvd: tonnes
05:46:44 <wvd> mreh, which is the best :)?
05:46:49 <mreh> wvd: there's loads of free stuff too, Learn You A Haskell is pretty good I'm told
05:47:31 <wvd> I'm looking for some compact guide, not single tutorials on internet, preferably
05:47:41 <Axman6> try lyah
05:47:41 <wvd> My first FP (expect for Erlang, but I want a good introduction)
05:47:45 <wvd> ok
05:47:49 <Axman6> @where lyah
05:47:49 <lambdabot> http://www.learnyouahaskell.com/
05:47:50 <mreh> wvd: LYAH is quite complete
05:48:04 <Axman6> mreh: except for the unwritten bits :P
05:48:23 <wvd> So reading that fully will give me a good understanding and then I'm able to write usefull apps?
05:48:44 <Axman6> depends how copetent you are ;)
05:49:06 <mreh> wvd: almost! you probably want to learn what a Monad is too
05:49:21 <mreh> and some specific examples of Monads
05:49:49 <wvd> i'll see :)
05:49:54 <wvd> I'll read that site first
05:50:10 * Axman6 has a theory: the longer the time between a haskell newbie starting to learn haskell, and hearing/seeing the word monad, the better haskell programmers they will be (due to the lack on anticipation)
05:50:20 <mreh> haha
05:50:36 <wvd> oh..
05:50:38 <wvd> so I'm doomed?
05:50:40 <wvd> :)
05:50:59 <mreh> if you tell them what a monad *is* rather than building it up you'd save so much time
05:51:12 <mreh> a Monad is a container and two functions, that's all
05:51:17 <mreh> and some laws
05:51:41 <mreh> but you only need the laws if you're writing your own, you soon get used to specific instances of Monads
05:51:50 <Botje> mreh: and a warm fuzzy thing!
05:51:52 <mreh> but you need to do some background reading before that
05:51:54 <wvd> I've heard FL are interesting because they speed up development time
05:52:08 <mreh> wvd: FL?
05:52:16 <wvd> Functional languages
05:52:27 <mreh> oh right... yes, that's true
05:52:38 <bremner> if you don't count learning the language
05:52:41 <mreh> without exception
05:52:45 <mreh> :P
05:53:30 <mreh> haskell has a good type system too, so you eliminate, in my experience 99% of errors after thing compiles correctly
05:54:02 <bremner> mreh: what is the largest program you have written?
05:54:27 <mreh> bremner: thousands of lines, less than 10,000
05:54:48 * Botje has two compilers, 2kLOC each
05:54:52 <bremner> ok, if your 10,000 line program was correct when it compiled, I'm impressed :)
05:55:19 <mreh> bremner: there were many intermediate steps
05:56:16 <bremner> mreh: sure, I didn't mean to pick on you, I just think "X is the software silver bullet" is _highly_ suspect for all X.
05:59:02 <mreh> yeah alright, it wasn't concurrent, it wasn't a GUI, it wasn't a web application, it was kind of trivial
05:59:09 <MarcWeber> Liskni_si: Can you tell me the scion revision this patch applies to ? I want to make sure that I test the same revision
05:59:27 <wvd> Arethmic operators are actually functions?
05:59:38 <mreh> yes
06:00:24 <mreh> functions of two numbers
06:00:40 <benmachine> a good type system eliminates a large percentage of errors, but mostly ones that are quite easy to fix anyway
06:00:48 <Axman6> :t (+)
06:00:49 <lambdabot> forall a. (Num a) => a -> a -> a
06:00:53 <Axman6> definitely a function
06:00:54 <benmachine> so basically it just saves you a bunch of effort usually
06:01:08 <wvd> So an infix operator is a function where the function is inbetween the arguments?
06:01:16 <wvd> erh, infix function
06:01:21 <Axman6> sure
06:01:43 <BorisL> > let add a b = a + b in 2 `add` 2
06:01:44 <lambdabot>   4
06:01:50 <quicksilver> benmachine: also improves code maintenance by ruling out a large class of errors which might be introduced by refactoring or careless bugfixing.
06:01:54 <Axman6> in maths, you coudl easily write a + b as (+)(a,b)
06:02:05 * mreh hands benmachine the "understatement of the day" award
06:02:16 <mreh> :D
06:02:30 <benmachine> both of you: yes acknowledged :P
06:03:18 <mreh> it also allows huge optimisations
06:03:26 <benmachine> I don't know if type errors are actually the best thing about the type system though
06:03:58 <benmachine> well I suppose it's a matter of perspective
06:04:05 <quicksilver> the textual form of the errors certainly isn't :)
06:04:08 <benmachine> heh
06:04:25 <benmachine> it took me literally months to get the hang of the difference between expected and inferred >_>
06:04:35 <applicative> wvd, the distinction between a two place function and an 'operator' is somewhat lost in haskell, they just follow different rules for infix and prefix, but either can be used either way
06:04:35 <mreh> i think it's a matter of how restrictive you want your language to be
06:04:44 <applicative> > (+) 1 2
06:04:45 <lambdabot>   3
06:05:15 <Liskni_si> MarcWeber: the patch is against your repo and I've got the latest scion from git (devel branch). The exact sha1 is in the issue tracker, I'm on mobile now.
06:05:17 <wvd> So (+) 1 2 works, can I think of them as trees you see in AST? i.e. (+ 1 2)
06:05:25 <benmachine> mreh: it's not how much you restrict, it's what you restrict
06:05:26 <applicative> > "hahahah" `mappend` "hohoho"
06:05:27 <lambdabot>   "hahahahhohoho"
06:05:37 <Twey> :t (++)
06:05:38 <lambdabot> forall m. (Monoid m) => m -> m -> m
06:05:44 <applicative> > mappend "hahahah" "hohohoho"
06:05:45 <lambdabot>   "hahahahhohohoho"
06:05:55 <benmachine> what haskell restricts is stuff you didn't want to do anyway :P
06:05:56 <applicative> > (++) "hahahaha" "hohohohoh"
06:05:57 <lambdabot>   "hahahahahohohohoh"
06:06:09 <benmachine> I am making a very confused point
06:06:10 <applicative> > "hahahahah" ++ "hohohohohoh"
06:06:10 <wvd> So when you want infix instead of prefix?
06:06:11 <lambdabot>   "hahahahahhohohohohoh"
06:06:34 <applicative> if it takes two arguments, you can use it either way, infix or prefix
06:06:51 <benmachine> anyway the type system is lovely and I want to hug it
06:07:23 <Twey> wvd: Backticks convert a prefix identifier to infix.  Brackets convert an infix identifier to prefix.
06:07:25 <applicative> but it its made with punctuation like concatenation -- ++ or the usual +  *   ^  then you add parentheses around if for prefix
06:07:52 <applicative> if the function name uses letters, you put backticks around it for infix
06:08:01 <applicative> so the distinction is purely stylistic.
06:08:39 <Twey> :t (`id`)
06:08:40 <lambdabot> parse error on input `)'
06:08:57 <Twey> Hmph
06:09:00 <applicative> @quote monochrom fugue
06:09:01 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
06:09:04 <Twey> I feel that should work
06:09:48 <applicative> Twey well its not like ` ` and ( ) are themselves functions
06:09:56 <applicative> maybe you could see them that way
06:10:31 <applicative> but they care whether whats enclosed with them is made with punctuation marks or letters.... not very functionlike...
06:10:34 <Twey> applicative: No, but if `id` is an infix identifier, then () should convert it to prefix like any other infix identifier
06:11:04 <Twey> Especially since the prefix-conversion is just a special case of sections, which are allowed for backtick'd functions
06:11:06 <applicative> I didn't know it was that robust
06:12:02 <applicative> but wait, id isn't infix, its only one place
06:12:20 <applicative> @ type id (+)
06:12:22 <quicksilver> Twey: they're both lexical things
06:12:31 <EvanR> :t (`mod`)
06:12:31 <quicksilver> Twey: the lexical syntax of haskell is not composable.
06:12:32 <lambdabot> parse error on input `)'
06:12:41 <Twey> quicksilver: I said ‘should’ :þ
06:12:42 <quicksilver> just as you can't say 1.5.5
06:12:48 <zygoloid> > let flip f a = (`f` a) in flip const 1 2
06:12:49 <lambdabot>   2
06:12:59 <Twey> Well, 1.5.5 doesn't make much sense
06:13:18 <applicative> @type (reverse `fmap`)
06:13:19 <lambdabot> forall a (f :: * -> *). (Functor f) => f [a] -> f [a]
06:13:28 <benmachine> it does seem odd that (`elem` xs) would be allowed but (`elem`) not
06:13:37 <EvanR> 1.5.5 => 1.75 ;)
06:13:45 <zygoloid> iirc the haskell' QualifiedOperators thing allows `(+)`
06:15:05 <Peaker> Note how in mathematics, usually functions that take 2 args are infix, and more than that, are infix in more dimensions :)  Above/below the function name (e.g: Sigma/et al)
06:15:09 <applicative> quicksilver, but I think Twey's point is, you are often surprised that something isn't 'lexical syntax'
06:15:52 <applicative> i'm worried we've frightened off wvd
06:16:57 <wvd> applicative: haha no
06:17:00 <wvd> silently reading the site
06:17:01 <applicative> @type (<$>)
06:17:02 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:17:30 <zygoloid> Peaker: often in mathematics, functions which take 2 or more arguments take them implicitly and are phrased simply as 'variables'. :)
06:17:33 <applicative> @type (<$> [1,2,3])
06:17:34 <lambdabot> forall a b. (Num a) => (a -> b) -> [b]
06:17:42 <Peaker> zygoloid, example?
06:18:32 <zygoloid> Peaker: z = x^2 + y^2
06:18:32 <applicative> Sorry, I'm lost, what is an example where I'd include more than one expression in backticks?
06:19:01 <Peaker> zygoloid, ah, usually only used in a "system of equations"?
06:19:17 <quicksilver> applicative: yes, occasionally.
06:19:28 <quicksilver> applicative: I'm surprised prefix - isn't lexical syntax.
06:19:37 <quicksilver> applicative: (it's a special case unary prefix operator)
06:19:44 <quicksilver> ...although I do understand the reason, too.
06:19:48 <Peaker> Haskell's unary minus is a yucky quirk
06:19:48 <zygoloid> Peaker: yeah. i find it disappointing how even a degree-level mathematics education hasn't explicitly taught me what a 'variable' really is :)
06:20:07 <applicative> quicksilver, I just can't think of an example  maybe foldr
06:20:25 <quicksilver> applicative: [3,4,5] `zipWith (+)` [5,6,7]
06:20:30 <quicksilver> applicative: is the one which normally comes up here.
06:20:39 <xerox> zygoloid: never hand logic courses? :)
06:20:42 <xerox> *had
06:21:07 <applicative> right, I was going to make a fold.   you need a three place function is the point.   It then has the nice effect of of flipping the first two arg places
06:21:27 <applicative> I kept thinking of two place functions.
06:21:36 <zygoloid> xerox: sure have. but they don't explain 'variable' in a way which matches its actual usage
06:22:05 <quicksilver> zygoloid: contrariwise, I'm sure I was taught in my maths education at least two or three times what a variable was.
06:22:07 <zygoloid> where "actual" means "in other, non-logic courses"
06:22:11 <applicative> zygloid, but that's because they saw through 'variable' in its actual usage in the 1880's
06:22:26 <quicksilver> zygoloid: different, inconsistent, definitions not applicable here, of course.
06:22:29 <applicative> Frege campaigned against the expression for decades
06:22:47 <zygoloid> quicksilver: i think we're seeing this same coin from opposite sides :D
06:23:36 <applicative> "the population of Berlin is a variable number'
06:23:51 <hpaste>  . (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24944
06:24:06 <wvd> maximum "hello world" returns the char which has the biggest number representing it in the charset?
06:24:16 <mrothe> How do I run "runhaskell Setup configure [..]" to *disable* a flag? Normally I enable it by appending --flags=cgi for example, but I have no idea how to disable a flag...
06:24:26 <applicative> @type maximum
06:24:27 <lambdabot> forall a. (Ord a) => [a] -> a
06:24:32 <zygoloid> i think a probabilistic approach, where 'variable' is defined similarly to 'random variable' as a function from some universal set, and equations are subset selection, is the best mental model i have
06:24:43 <applicative> > maximum "hohoho"
06:24:43 <lambdabot>   'o'
06:25:11 <zygoloid> wvd: yes, where 'the charset' is always unicode.
06:25:22 <wvd> Oh cool!
06:25:42 <applicative> wvd, the answer seems to be yes.   "helloworld" is a list of chars, and Char is an Ord type
06:27:54 <lpsmith> I really wish there was a caseM :-/
06:31:31 <zygoloid> doCaseM e = do e >>= case e of CaseE e ms -> [| $e >>= \x -> $(CaseE [|x|] ms) |]; _ -> error "caseM given non-case!"
06:31:47 <Peaker> lpsmith, no need for that, just need a case that is a function:   \case of ...  meaning \x -> case x of ...   then you can use >>= \case ->
06:32:13 <zygoloid> #define caseM(stuff) $( doCaseM [| case stuff |] )
06:32:23 <hpaste>  . (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24945
06:33:01 <zygoloid> then... do caseM( lookup maybeGetX table of ... )
06:33:28 <lpsmith> Peaker, that would work too;  I'm not sure it would be as syntactically pleasing,  but I have liked that suggestion too
06:33:30 <Peaker> why have a caseM that does both >>= and the \x -> case x of ... ?  Why not do the >>= outside?
06:33:38 <applicative> quicksilver, zygloid, http://tinyurl.com/tarski-against-variables is Tarski's textbook, which considers the use of 'variable' in physics computation etc. to be beneath contempt, not science, etc
06:33:54 <Peaker> I agree that:  \x -> case x of ...  is ugly, just like  \x -> f x  is ugly
06:34:12 <applicative> he dispenses with it in the first few pages of the book so he can move on to real thinking.
06:34:31 <Peaker> lpsmith, btw: I usually prefer pattern matching functions (folds/catas) over "case" so I can use something like:  >>= foldr ...  or  >>= maybe ...
06:36:00 <lpsmith> Peaker:  I like   >>= maybe  :)
06:36:14 <EvanR-work> :t (>>= maybe)
06:36:15 <lambdabot> forall a a1. ((a1 -> a) -> a) -> (a1 -> a) -> Maybe a1 -> a
06:37:00 <EvanR-work> :t (>>=)
06:37:01 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
06:37:04 <lpsmith> :t  \m alt f ->  m >>= maybe alt f
06:37:05 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (Maybe a) -> m b -> (a -> m b) -> m b
06:37:16 <Peaker> > [Just 1, Nothing, Just 3] >>= maybe [] return
06:37:17 <lambdabot>   [1,3]
06:37:19 <hpaste>  ghci doesen't compute them. Why? (Blkt)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24946
06:37:43 <Blkt> could anyone tell me why I ghci gets this definition wrong? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24946#a24946
06:38:09 <opqdonut> how does it get it wrong?
06:38:12 <zygoloid> Blkt: well, prod and product are different identifiers
06:38:26 <applicative> :t \a b f -> a >>= maybe alt f
06:38:27 <lambdabot> Not in scope: `alt'
06:38:34 <applicative> :t \a b f -> a >>= maybe b f
06:38:35 <Blkt> sum doesn't work either
06:38:35 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (Maybe a) -> m b -> (a -> m b) -> m b
06:38:52 <zygoloid> Blkt: sum looks ok. in what sense does it not work?
06:39:17 <zygoloid> > let sum [] = 0; sum (x:xs) = x + sum xs in sum [1..5]
06:39:18 <lambdabot>   15
06:39:47 <Blkt> zygoloid: I call "sum [1..5]" and ghci says "non-exhaustive patterns in function sum"
06:40:05 <Blkt> ah
06:40:16 <Blkt> is let kinda volatile?
06:40:31 <Blkt> I mean
06:40:33 <zygoloid> yes, in that it shadows previous bindings
06:40:37 <lpsmith> :t (>>= maybe mzero return)
06:40:38 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m (Maybe a) -> m a
06:40:48 <zygoloid> > let sum [] = 0 in let sum (x:xs) = x + sum xs in sum [1..5]
06:40:49 <lambdabot>   *Exception: <interactive>:1:163-185: Non-exhaustive patterns in function sum
06:40:53 <EvanR-work> let x = 4 in x, x is only defined this way in this expression
06:40:59 <zygoloid> Blkt: you mean ^^ that sort of thing?
06:41:20 <EvanR-work> is this definition of sum inefficient?
06:41:30 <zygoloid> Blkt: i'm guessing that at ghci you wrote 'let sum [] = 0' then 'let sum (x:xs) = x + sum xs'?
06:41:40 <applicative> > let sum' [] = 0 in let sum' (x:xs) = x + sum' xs in sum' [1..5]
06:41:40 <lambdabot>   *Exception: <interactive>:1:168-192: Non-exhaustive patterns in function sum'
06:41:43 <zygoloid> the latter will hide the former rather than augment it
06:41:54 <Blkt> zygoloid: I see, thank you
06:42:10 <applicative> > let {sum' [] = 0 ; sum' (x:xs) = x + sum' xs} in sum' [1..5]
06:42:11 <lambdabot>   15
06:42:12 <zygoloid> Blkt: 'let sum [] = 0; sum (x:xs) = x + sum xs' should work
06:42:18 <Blkt> zygoloid: it does
06:42:33 <applicative> > let {sum [] = 0 ; sum (x:xs) = x + sum xs} in sum [1..5]
06:42:34 <lambdabot>   15
06:43:11 <applicative> :t sum
06:43:12 <lambdabot> forall a. (Num a) => [a] -> a
06:43:46 <EvanR-work> > let sum [] = 0; sum (x:xs) = x + sum xs in sum [1..100]
06:43:47 <lambdabot>   5050
06:43:52 <EvanR-work> > let sum [] = 0; sum (x:xs) = x + sum xs in sum [1..1000000]
06:43:53 <lambdabot>   *Exception: stack overflow
06:44:04 <applicative> > let {sum [] = 0 ; sum (x:xs) = x + sum xs} in product [1..5]
06:44:05 <lambdabot>   120
06:44:35 <applicative> is the last term in    let {sum [] = 0 ; sum (x:xs) = x + sum xs} in sum [1..5]     *my* sum, or the Prelude's
06:44:45 <EvanR-work> > foldl' (+) 0 [1..1000000]
06:44:46 <lambdabot>   500000500000
06:45:01 <opqdonut> applicative: those are all your sums
06:45:04 <EvanR-work> > foldl (+) 0 [1..1000000]
06:45:05 <lambdabot>   *Exception: stack overflow
06:45:08 <wvd> What's a singleton list?
06:45:12 <opqdonut> wvd: [x]
06:45:16 <opqdonut> a list with one element
06:45:22 <Peaker> wvd, length singletonList == 1
06:46:01 <applicative> opqdonut, i see, the last chunk of " let ... = .... in (.....)" holds my sum to the one defined in "let ..."  so to speak,
06:48:03 <opqdonut> yes, the definitions that a let makes shadow earlier definitions
06:48:37 <applicative> yeah, i'm seeing, "let" "=" and "in
06:49:16 <applicative> all go together, so it makes sense, like (\sum -> sum [1,2,3])
06:49:30 <applicative> > (\sum -> sum [1,2,3]) sum
06:49:31 <lambdabot>   6
06:49:49 <applicative> here the last sum is the prelude's the first two are my own, i guess
06:50:14 <applicative> > (\sum -> sum [1,2,3])  product
06:50:15 <lambdabot>   6
06:50:47 <EvanR-work> > (\sum -> sum [1,2,3]) reverse
06:50:48 <lambdabot>   [3,2,1]
06:50:56 <EvanR-work> :t (\sum -> sum [1,2,3])
06:50:57 <lambdabot> forall t t1. (Num t) => ([t] -> t1) -> t1
06:51:31 <applicative> > (\reverse -> reverse "hahahaha") maximum
06:51:32 <lambdabot>   'h'
06:51:53 <applicative> you could generate a lot of obscurity this way....
06:52:18 <EvanR-work> yeah but even if you tried, it would be straight forward to decipher
06:52:24 <EvanR-work> unlike some languages
06:52:45 <EvanR-work> with more complex scoping
06:52:48 <quicksilver> applicative: 'beneath contempt' may be just little harsh.
06:52:54 <quicksilver> applicative: sounds like the kind of thing I'd say :)
06:53:30 <applicative> quicksilver, okay, i was exaggerating.  It's the standard logical view, from Frege in the 1880's  I think
06:54:31 <applicative> quicksilver, Frege says things like "the population of Berlin is not a variable number, it's a function from times to numbers; neither the function nor the numbers vary"
06:55:09 <EvanR-work> compare and contrast the terminology 'random variable'
06:55:19 <roconnor> random variables are
06:55:27 <roconnor> neither random nor do they vary
06:55:31 <Eelis> how does one use something like (Set.\\) as an infix operator while still using the qualification?
06:55:48 <applicative> Frege and Tarski would say:
06:56:00 <roconnor> > (+1) Prelude.. (*2) $ 3
06:56:01 <lambdabot>   Not in scope: `Prelude..'
06:56:11 <applicative> > repeat 'A'
06:56:11 <lambdabot>   "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA...
06:56:32 <EvanR-work> what would be a legitimate use of the word variable, i mean, the letter on the page never varies either ;)
06:57:11 <IceDane> > replicate 10 'F' ++ repeat 'U'
06:57:12 <lambdabot>   "FFFFFFFFFFUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU...
06:57:14 <sepp2k> Eelis: set1 Set.\\ set2
06:57:41 <applicative> I think they think it's a  confusion.  Frege just calls them 'letters'  he has one for the quantifiers (Gothic letters) , one for so called free variables (latin) and one for lamba abstraction, in his form, greek
06:57:53 <Eelis> sepp2k: ah, splendid! for some reason i mistakenly assumed parentheses would be necessary
06:58:58 <lpsmith> Eelis, the parens turn it into a prefix op :)
06:58:59 <sepp2k> Parentheses are used when you *don't* want an operator to be infix.
06:59:16 <Eelis> yes, it's just that without parentheses, the qualification looked so.. bare
06:59:16 <timofonic> IceDane: Haha, that was unintentionally funny to me :P
06:59:48 <lpsmith> > (Data.Set.\\) (Data.Set.fromList [1..10]) (Data.Set.fromList [2,4..20])
06:59:48 <lambdabot>   Not in scope: `Data.Set.\\'Not in scope: `Data.Set.fromList'Not in scope: `...
06:59:53 <lpsmith> aww
07:00:51 <timofonic> > divide 4 'A' ++
07:00:52 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
07:01:23 <timofonic> > replicate 4 'E' 4+2
07:01:24 <lambdabot>   Couldn't match expected type `t -> a'
07:01:24 <lambdabot>         against inferred type `[GHC.T...
07:02:19 <timofonic> > replicate 4 'E' ++ replicate 4 'S' ++
07:02:20 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
07:02:30 <timofonic> f***
07:02:44 <benmachine> Eelis: I've always thought that syntax a little weird
07:02:50 <lpsmith> > replicate 4 'E' ++ replicate 4 'S'
07:02:51 <lambdabot>   "EEEESSSS"
07:03:22 <IceDane> timofonic: hehe
07:04:09 <timofonic> > replicate 10 'WTF' ++
07:04:10 <lambdabot>   <no location info>:
07:04:10 <lambdabot>      lexical error in string/character literal at chara...
07:04:15 <alpounet> " "
07:04:19 <lpsmith> although, it would be kind of nice if you could write  (f ++ g ++)  as a kind of section
07:04:20 <jmcarthur> i love #haskell http://metaleks.net/internet/elitism-in-irc
07:04:55 <timofonic> I need to try to understand Haskell better before playing :P
07:05:00 <EvanR-work> :t ([] ++ [] ++)
07:05:01 <lambdabot>     The operator `++' [infixr 5] of a section
07:05:01 <lambdabot>         must have lower precedence than that of the operand,
07:05:02 <lambdabot>           namely `++' [infixr 5]
07:05:06 <EvanR-work> :t (([] ++ []) ++)
07:05:07 <lambdabot> forall a. [a] -> [a]
07:05:28 <Peaker> @check liftA2 (==) (([] ++ []) ++) id
07:05:29 <lambdabot>   "OK, passed 500 tests."
07:05:31 <applicative> quicksilver, I don't know if you can read unicode, but Frege would write ? x + y = y + x     ? ? a b ( a + b ) = b + a )  and ? x + y = ? (? (?+ ?)) ^ y ^ x
07:05:42 <timofonic> I need to look like if I know C this week, maybe I'll get a job. Then the rest :P
07:05:43 <applicative> uhoh i can't read it
07:06:23 <lpsmith> > concat (replicate 10 "WTF")
07:06:24 <lambdabot>   "WTFWTFWTFWTFWTFWTFWTFWTFWTFWTF"
07:06:28 * timofonic punchs himself after seeing math formulae
07:06:59 <Peaker> Is there any reason to choose fclabels over data-accessor-template or vice versa?
07:07:06 <lpsmith> jmcarthur,  yeah,  I've been on a few channels like that
07:07:07 <timofonic> > concat (replicate 10 "WTF ")
07:07:08 <lambdabot>   "WTF WTF WTF WTF WTF WTF WTF WTF WTF WTF "
07:07:28 <lpsmith> > intercalate " " (replicate 10 "WTF")
07:07:29 <lambdabot>   "WTF WTF WTF WTF WTF WTF WTF WTF WTF WTF"
07:07:37 <EvanR-work>  > sort $ concat (replicate 10 "WTF ")
07:07:55 <EvanR-work> > sort $ concat (replicate 10 "WTF ")
07:07:56 <lambdabot>   "          FFFFFFFFFFTTTTTTTTTTWWWWWWWWWW"
07:08:09 <EvanR-work> \o/
07:08:48 <timofonic> > intercalate "is Haskell?" (replicate 10 "WTF ")
07:08:48 <lambdabot>   "WTF is Haskell?WTF is Haskell?WTF is Haskell?WTF is Haskell?WTF is Haskell...
07:08:54 <lpsmith> hah,  I never realized that sort "WTF" == "FTW"
07:09:06 <zygoloid> > reverse "wtf"
07:09:07 <lambdabot>   "ftw"
07:09:21 <wvd> A typeclass describes the behavior of a specific type?
07:09:32 <lpsmith> that's probably the most useless factoid ever
07:09:48 <zygoloid> wvd: a collection of types
07:09:57 <zygoloid> (an /extensible/ collection of types, even)
07:10:02 <wvd> zygoloid: ah ok
07:10:06 <wvd> i'll read through this
07:10:31 <lpsmith> > intercalate " FTW! " (replicate 3 "Haskell")
07:10:32 <lambdabot>   "Haskell FTW! Haskell FTW! Haskell"
07:10:34 * hackagebot vcd 0.1.1 - Tools for reading and writing VCD files.  http://hackage.haskell.org/package/vcd-0.1.1 (TomHawkins)
07:10:42 <jmcarthur> wtfftw
07:11:39 <hpaste>  Frege's "letters" (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24947
07:11:53 <IceDane> > intercalate " " $ zipWith3 (\x y z -> x:y:[z]) (repeat 'O') (repeat 'M') (repeat 'G')
07:11:54 <lambdabot>   "OMG OMG OMG OMG OMG OMG OMG OMG OMG OMG OMG OMG OMG OMG OMG OMG OMG OMG OM...
07:12:12 <HugoDaniel> :D
07:12:14 <aavogt> > cycle "OMG " -- IceDane
07:12:15 <lambdabot>   "OMG OMG OMG OMG OMG OMG OMG OMG OMG OMG OMG OMG OMG OMG OMG OMG OMG OMG OM...
07:12:18 <IceDane> aavogt: hehe, I know
07:12:22 <aavogt> :)
07:12:55 <timofonic> replicate (sort $ intercalate "L" "O" "L") 10
07:13:03 <applicative> quicksilver, I managed to write the ways Frege uses letters in the paste  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24947   He doesn't  use the upside down A for "all"
07:13:07 <EvanR-work> > nub $ cycle "OMG "
07:13:10 <timofonic> > replicate (sort $ intercalate "L" "O" "L") 10
07:13:10 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
07:13:11 <benmachine> > intercalate " " $ zipWith3 (\x -> (x:) . (. pure) . (:)) (repeat 'O') (repeat 'M') (repeat 'G')
07:13:11 <lambdabot>         against inferred ty...
07:13:11 <lambdabot>   Couldn't match expected type `c -> [GHC.Types.Char]'
07:13:12 <lambdabot>         against inferr...
07:13:12 <lambdabot>   mueval: ExitFailure 1
07:13:17 <EvanR-work> :(
07:13:18 <benmachine> blark
07:13:20 <lpsmith> :t intercalate
07:13:21 <lambdabot> forall a. [a] -> [[a]] -> [a]
07:13:26 <benmachine> @pl \x y z -> [x,y,z]
07:13:27 <lambdabot> (. ((. return) . (:))) . (.) . (:)
07:13:40 <benmachine> @pl \y z -> [x,y,z]
07:13:40 <lambdabot> ((x :) .) . (. return) . (:)
07:13:48 <benmachine> agh, I was nearly ther
07:13:51 <lpsmith> timofonic, intercalate only takes two arguments :)
07:13:59 <timofonic> I need to forget the way of thinking in C, yep
07:14:00 <EvanR-work> nub . cycle == nub
07:14:15 <dmwit> noooo
07:14:18 <benmachine> > nub . cycle $ "blah"
07:14:23 <lambdabot>   mueval: ExitFailure 1
07:14:25 <EvanR-work> :(
07:14:35 * hackagebot cltw 1.1.4 - Command line Twitter utility  http://hackage.haskell.org/package/cltw-1.1.4 (DinoMorelli)
07:14:51 <benmachine> it can't tell the difference between cycle "blah" and concat (replicate 10000 "blah") ++ "bloh"
07:14:58 <IceDane> hah, nub . cycle $ "FOO" murdered by ghci
07:14:59 <lpsmith> unfortunately lambdabot can't spit out the output it did produce before it enters the infinite non-productive loop
07:15:00 <IceDane> my*
07:15:02 <benmachine> at least not quickly
07:15:21 <lpsmith> or in the case of lambdabot,  a half-second non-productive loop or whatever the limit actually is
07:15:21 <benmachine> > take 4 . nub . cycle $ "blah"
07:15:22 <lambdabot>   "blah"
07:15:47 <wvd> How would I range from 5.1 to 5.3?
07:16:00 <EvanR-work> > [5.1, 5.2, 5.3]
07:16:00 <lambdabot>   [5.1,5.2,5.3]
07:16:04 <zygoloid> wvd: what do you mean?
07:16:05 <IceDane> haha.
07:16:15 <zygoloid> > range (5.1, 5.3)
07:16:16 <lambdabot>   Ambiguous type variable `t' in the constraints:
07:16:16 <lambdabot>    `GHC.Real.Fractional t'
07:16:16 <lambdabot> ...
07:16:17 <wvd> e.g. [5.1..5.4]
07:16:29 <benmachine> wvd: specify the second number
07:16:33 <zygoloid> wvd: still, what do you mean? what result do you want to get?
07:16:36 <benmachine> like, > [10, 20 .. 100]
07:16:40 <benmachine> er
07:16:48 <benmachine> > [10, 20 .. 100]
07:16:49 <lambdabot>   [10,20,30,40,50,60,70,80,90,100]
07:16:52 <masklinn> > [5.1, 5.2, .., 5.9]
07:16:52 <lambdabot>   <no location info>: parse error on input `..'
07:16:57 <wvd> Ah it works when specifying the second.
07:17:07 <zygoloid> wvd: it defaults to a step of 1 iirc
07:17:12 <zygoloid> > [5.1..9.4]
07:17:13 <lambdabot>   [5.1,6.1,7.1,8.1,9.1]
07:17:14 <wvd> I've thought it would've increased by 0.1 because there's just 1 number after the comma
07:17:19 <masklinn> > [5.1, 5.2..5.9]
07:17:20 <lambdabot>   [5.1,5.2,5.300000000000001,5.400000000000001,5.500000000000002,5.6000000000...
07:17:20 <timofonic> > replicate (sort $ intercalate (concat WTF) (concat OMG)) 10
07:17:21 <lambdabot>   Not in scope: data constructor `WTF'Not in scope: data constructor `OMG'
07:17:29 <masklinn> > [5.1, 5.2..5.6]
07:17:29 <lambdabot>   [5.1,5.2,5.300000000000001,5.400000000000001,5.500000000000002,5.6000000000...
07:17:34 <benmachine> wvd: that'd be weird; what would [5.10 .. 5.90] do?
07:17:40 <masklinn> works, but it looks fugly
07:17:43 <timofonic> Oh, now I mixed lisp with C. My head is full of shit
07:17:50 <dmwit> > [0.5 .. 10]
07:17:51 <lambdabot>   [0.5,1.5,2.5,3.5,4.5,5.5,6.5,7.5,8.5,9.5,10.5]
07:17:51 <lpsmith> the roundoff error is accumulating!
07:17:55 <dmwit> surprise!
07:18:01 <wvd> ah..
07:18:03 <wvd> true
07:18:15 <lpsmith> > drop 1000 [5.1, 5.2 ..]
07:18:16 <lambdabot>   [105.10000000000417,105.20000000000418,105.30000000000419,105.4000000000042...
07:18:21 <masklinn> > drop 50 [5.1, 5.2..20]
07:18:22 <lambdabot>   [10.100000000000007,10.200000000000006,10.300000000000006,10.40000000000000...
07:18:34 <masklinn> > drop 50000 [5.1, 5.2..]
07:18:35 <lambdabot>   [5005.100000012365,5005.200000012365,5005.300000012366,5005.400000012366,50...
07:18:38 <dmwit> ...did I surprise anyone? =P
07:18:53 <benmachine> dmwit: we already know floating point numbers are the devil
07:19:03 <dmwit> =(
07:19:09 <masklinn> > drop 5000000 [5.1, 5.2..]
07:19:10 <lambdabot>   [500005.10008506296,500005.200085063,500005.30008506303,500005.40008506307,...
07:19:11 <lpsmith> dmwit, not I =)
07:19:16 <timofonic> > concat "hello"
07:19:17 <lambdabot>   Couldn't match expected type `[a]'
07:19:17 <lambdabot>         against inferred type `GHC.Types...
07:19:27 <dmwit> benmachine: But at least halfs are supposed to be perfectly representable...
07:19:28 <EvanR-work> wvd: you cant cleanly compute a sequence of floating point numbers that are exactly certain base 10 fractions
07:19:31 <masklinn> > take 1 $ drop 500000000 [5.1, 5.2..]
07:19:35 <lambdabot>   mueval-core: Time limit exceeded
07:19:41 <EvanR-work> wvd: and theres also sound accumulation error here
07:19:45 <EvanR-work> some
07:19:45 <benmachine> dmwit: true, so I guess you have to add the perversity of Enum Float
07:19:49 <masklinn> > take 1 $ drop 50000000 [5.1, 5.2..]
07:19:49 <benmachine> err, perversion
07:19:53 <lambdabot>   [5000005.117779343]
07:20:08 <benmachine> but that is actually really a consequence of the evil of floating point
07:20:12 <masklinn> > take 1 $ drop 100000000 [5.1, 5.2..]
07:20:16 <lambdabot>   mueval-core: Time limit exceeded
07:20:16 <timofonic> Where's lambdabot runs on? That weird FPGA hardware?
07:20:26 <EvanR-work> a toaster
07:20:33 <quicksilver> lambdabot runs on an x86_64 linux box.
07:20:35 <masklinn> lambdabot doesn't run
07:20:36 <masklinn> lambdabot is
07:20:39 * hackagebot scan 0.1.0.3 - lexical style suggestions for source code  http://hackage.haskell.org/package/scan-0.1.0.3 (ChristianMaeder)
07:20:42 <benmachine> @vixen do you run?
07:20:42 <lambdabot> maybe. do you?
07:20:52 <benmachine> what an interesting philosophical question
07:21:21 <zygoloid> > findIndices (==10) $ zipWith (/) [1..1000] [0.1, 0.2 .. 100]
07:21:22 <lambdabot>   [0,1,7,8,9,10]
07:21:37 <lpsmith> > drop 50000 (map (/ 10) [50..])
07:21:38 <lambdabot>   [5005.0,5005.1,5005.2,5005.3,5005.4,5005.5,5005.6,5005.7,5005.8,5005.9,5006...
07:21:44 <timofonic> masklinn: Oh, that makes me remember about apocaliptical novels and movies :)
07:22:01 <benmachine> zygoloid: hah
07:22:10 <timofonic> masklinn: So Haskell is really an intelligence test for humans?
07:22:11 <lpsmith> works so much better than [5.0, 5.1 ..]
07:22:50 <lpsmith> > drop 50000 ([5, 5.5..])
07:22:50 <benmachine> > map fromRational [5, 26 % 25, ..]
07:22:51 <lambdabot>   [25005.0,25005.5,25006.0,25006.5,25007.0,25007.5,25008.0,25008.5,25009.0,25...
07:22:51 <lambdabot>   <no location info>: parse error on input `..'
07:22:55 <benmachine> > map fromRational [5, 26 % 25 ..]
07:22:56 <lambdabot>   [5.0,1.04,-2.92,-6.88,-10.84,-14.8,-18.76,-22.72,-26.68,-30.64,-34.6,-38.56...
07:23:01 <benmachine> eeerm
07:23:03 <benmachine> whoops
07:23:06 <benmachine> > map fromRational [5, 26 % 5 ..]
07:23:06 <lambdabot>   [5.0,5.2,5.4,5.6,5.8,6.0,6.2,6.4,6.6,6.8,7.0,7.2,7.4,7.6,7.8,8.0,8.2,8.4,8....
07:23:10 <benmachine> also whoops
07:23:22 <benmachine> > map fromRational [5, 51 % 50 ..]
07:23:22 <lambdabot>   [5.0,1.02,-2.96,-6.94,-10.92,-14.9,-18.88,-22.86,-26.84,-30.82,-34.8,-38.78...
07:23:27 * benmachine facepalm
07:23:54 <benmachine> I made one mistake, then fixed it and made a different mistake, but not satisfied with that went back to making the first mistake again
07:23:57 <benmachine> > map fromRational [5, 51 % 10 ..]
07:23:58 <lambdabot>   [5.0,5.1,5.2,5.3,5.4,5.5,5.6,5.7,5.8,5.9,6.0,6.1,6.2,6.3,6.4,6.5,6.6,6.7,6....
07:24:00 * benmachine sigh
07:24:12 <hpaste>  . (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24948
07:24:13 <lpsmith> :0
07:24:37 <timofonic> benmachine: You are human after all :D
07:24:59 <timofonic> benmachine: Do you work at Microsoft?
07:25:04 <benmachine> no :(
07:25:13 <timofonic> benmachine: oh...
07:26:01 <danderson> waah, hpaste broken
07:26:11 <timofonic> benmachine: It can be worse, it could be like me :P
07:27:30 <timofonic> benmachine: I'm a mistake, that does mistakes by mistake :P
07:27:44 <benmachine> hmm
07:27:46 <benmachine> sounds recursive
07:28:15 <timofonic> benmachine: Recursively useless, that is!
07:28:33 <benmachine> uselessly recursive?
07:28:49 <danderson> So, I have this code, and it's not building, and I'm confused by the error (below the code in the paste) : http://codetidy.com/23
07:28:49 <timofonic> benmachine: Probably too...
07:28:52 <danderson> help?
07:29:15 <danderson> clearly I'm confused about how I declare the instance for ReaderT, but I don't see why my definition is not working out.
07:29:51 <benmachine> danderson: try forcing the type of st
07:30:05 <timofonic> Compiling haskell stuff is making this machine more lagging than me at reading math stuff...
07:30:37 <danderson> huh.
07:30:40 <timofonic> Poor old DELL. Need to get more CPU power... it uses GCC as backend, right?
07:30:45 <danderson> benmachine: yeah, that worked. How did you figure that one out?
07:30:47 <timofonic> GHC -> GCC ?
07:31:03 <danderson> and also, how can I sufficiently hint ghc so that it doesn't need the type hint?
07:31:03 <masklinn> timofonic: are you sure it's not a disk issue as well?
07:31:29 <masklinn> timofonic: (also, I think if you don't use -fvia-c ghc has no reason to call gcc, does it?)
07:31:38 <timofonic> masklinn: IO?
07:31:41 <benmachine> danderson: it's a bit like show . read
07:32:14 <benmachine> which show and which read are used depends on what the type is in between - but there's no more information, so GHC can't know which to use
07:32:15 <masklinn> timofonic: yeah, reading and writing a bunch of crap on the disk => slow as hell if you have a not-in-its-best-shape HDD with lots of fragmentation & everything
07:32:17 <timofonic> masklinn: I see, ok. I did think GHC lacked a native code generator
07:32:27 <masklinn> (of course if you're using an SSD, then that's not what's happening)
07:32:40 <benmachine> in this case, the places that st are used don't give you enough information about it to select the instance
07:32:43 <timofonic> masklinn: It's EXT4? Let me see
07:32:51 <timofonic> masklinn: No, the original Seagate 4gb crap
07:32:51 <danderson> benmachine: okay, but in this case, the type in between suspend and resume is constrained by the monad stack that suspend executes in. At least, I'd have expected so.
07:32:51 <benmachine> danderson: hmm, maybe you need a functional dependency (or associated type)
07:33:14 <masklinn> timofonic: ghc should have an NGC, unless you're on a platform where it doesn't that is
07:33:21 <benmachine> danderson: suppose you also gave an instance SuspendableMonad Int (ReaderT r m)
07:33:37 <timofonic> Uh, ext4
07:33:40 <benmachine> danderson: then either instance could match given the current information
07:33:45 <timofonic> mak__: x86 32
07:33:51 <danderson> oh, so ghc refuses to compile if another instance *could* match, even if none is defined?
07:34:05 <masklinn> timofonic: then it's possible that the hard drive makes you lag more than the CPU, as the OS and the compiler fight for HDD access and everybody loses (I get the same thing when I compile elementtree on my macbook with its oh-snap-bought-the-wrong-drive crap)
07:34:24 <masklinn> timofonic: I start the compilation, and the machine becomes completely unusable for as long as it happens
07:34:43 <benmachine> danderson: mm, sort of... it's more that GHC doesn't know st is a tuple, so it doesn't know that your instance matches
07:34:47 <masklinn> timofonic: x86/32 should be handled by the NGC, so no GCC involved I believe
07:35:05 <benmachine> danderson: I'm a bit hazy on the precise details though; the advice I offered was partially a guess
07:35:10 <danderson> heh
07:35:28 <timofonic> masklinn: Uhm, then I can make it to suck less by having some NFS over a machine with better HDD or changing it? I see
07:35:58 <timofonic> masklinn: I mean... I have access to a virtual machine and maybe two computers... I could use them to compile...
07:36:00 <masklinn> timofonic: I think you can, but I might also be completely wrong
07:36:09 <danderson> benmachine: well, if you have any pointers on how to help ghc make the right decision, I'm all ears. Just defining this type class is stretching my haskell-fu to breaking point, correctly hinting the type system as well is currently beyond me.
07:36:13 <danderson> thanks!
07:36:40 <benmachine> danderson: well, an explicit type signature is by no means a wrong solution here, I think, but you might want to consider a functional dependency if it's relevant
07:36:54 <quicksilver> danderson: "so ghc refuses to compile if another instance *could* match, even if none is defined?"
07:36:58 <quicksilver> danderson: Yes.
07:37:09 <quicksilver> danderson: because that other instance might be in another module, not as-yet compiled.
07:37:15 <danderson> benmachine: it's not wrong, but afaict it would prevent me from writing generic functions using suspend/resume, which don't have knowledge of the particular monad stack
07:37:26 <quicksilver> danderson: it has no well of telling what you might ask it to compile next :)
07:37:30 <danderson> eg. a fork variant which can suspend/resume any SuspendableMonad across forkIO
07:38:02 <wvd> Any recommend Haskell IDE/notepad/editor for Windows?
07:38:07 <benmachine> danderson: if I wanted to help you with that, I'd have to better understand what suspendable monads actually are for; but quicksilver is better at this anyway :P
07:38:19 <timofonic> Going to mount some iron, I understand too little of the conversation and the compy is getting slow
07:38:34 <quicksilver> wvd: I recommend emacs on all platforms, including windows, but it's not a traditional IDE and it may not suit you ;)
07:38:41 <danderson> benmachine: okay, well I'll try to explain :P
07:38:51 <wvd> quicksilver: I've heard of Emacs.
07:38:55 <wvd> It might be worth to try.
07:38:58 <timofonic> quicksilver: Why not Yi? :P
07:39:06 <EvanR-work> ive probably asked this before. how do i convert an IO a into an IO () shorter than (ioa >> return ())
07:39:07 <danderson> this type class is an attempt to implement what I discussed here a few weeks back
07:39:09 <wvd> quicksilver: It's a cross-language editor like Notepad++?
07:39:23 <benmachine> EvanR-work: (() <$ ioa)
07:39:29 <benmachine> where <$ is in Control.Applicative
07:39:30 <EvanR-work> nice
07:39:43 <timofonic> quicksilver: Why a haskeller recommends emacs? :)
07:39:53 <danderson> the problem I want to solve is that I have some complex monad stack (eg. ReaderT Foo (StateT Bar IO)), and I want to fork a thread to run a computation under that same stack
07:39:56 <timofonic> quicksilver: It's emacs better than yu?
07:40:00 <timofonic> yi
07:40:23 <benmachine> I think it'd be fair to say yi is less mature than emacs
07:40:29 <danderson> that is, within a ComplexMonad, I want a spawn :: ComplexMonad () -> ComplexMonad (), so that I don't have to do all the unwrapping/rewrapping of state across the thread boundary myself.
07:40:39 <timofonic> benmachine: But less annoying too?
07:41:00 <timofonic> benmachine: Linux is less mature than emacs, emacs has... 30 years?
07:41:01 <quicksilver> timofonic: emacs is a phenonmenally powerful programmable editor with a huge range of facilities which apply to all kinds of tasks, of which haskell editing is just one.
07:41:05 <benmachine> timofonic: I don't know enough about either editor to comment, I use vim
07:41:13 <aavogt> ETA reductions make my code arrive FASTER
07:41:16 <benmachine> (and get along very nicely with it)
07:41:25 <quicksilver> timofonic: yi is an almost entirely new editor with a few admittedly very nice features.
07:41:35 <danderson> enter SuspendableMonad: for any monad which has state that can be transported across a thread fork (ReaderT, StateT), suspend gives you an opaque blob of saved state, and resume uses a suspended blob to resume a computation of that same monad
07:41:49 <timofonic> quicksilver: To me is also a pain in the ass, lacking multithreading or something to to making it with lack of user responsiveness
07:41:54 <edwardk_> danderson: its a bit of a pain in the ass to wrap/rewrap the complicated monad transformer set around a lot of operations that expect IO actions, especially when they expect them as arguments.
07:42:07 <quicksilver> timofonic: it is indeed not multithreaded but I've never found it unresponsive.
07:42:08 <danderson> this type class would then let me write betterForkIO, essentially looking like what `test` looks like in the code I pasted
07:42:36 <danderson> suspend the current stack, forkIO, and resume from the suspended stack
07:42:58 <timofonic> quicksilver: You can even do surgical operations and travel to other dimensions with emacs, but beware of not being multithreaded...
07:43:00 <benmachine> danderson: so, it wouldn't make sense to have an instance SuspendableMonad a m as well as a SuspendableMonad b m?
07:43:15 <timofonic> quicksilver: I found it, even on faster hardware
07:43:19 <danderson> benmachine: correct. For each m, there is exactly one matching a.
07:43:24 <edwardk_> danderson: another set of functions to look at are the 'withFoo :: Bar -> (Baz -> IO a) -> IO a -- kinds of functions, those also could use some typeclass loving ;)
07:43:39 <timofonic> quicksilver: But well, I find most environments as crap to the user
07:43:41 <benmachine> danderson: there are two broadly equivalent solutions then, associated types and functional dependencies
07:43:48 <timofonic> quicksilver: Even the famous BeOS, now Haiku
07:43:56 <benmachine> danderson: I like associated types personally
07:44:07 <danderson> edwardk_: so, the SuspendableMonad stuff is aimed exactly at that: instead of forkIO + lots of painful transformer wrapping, you just spawnIO $ myComplexMonadComputation
07:44:11 <benmachine> but I don't necessarily understand all of the implications involved
07:44:14 <danderson> and it should Just Work
07:44:24 <danderson> benmachine: okay, I don't know how to use either associated types or functional dependencies :)
07:44:32 <edwardk_> danderson: what is your type signature for spawnIO ?
07:44:38 <timofonic> quicksilver: Maybe I configure or overload my systems by the weird way I use them, it could make sense too
07:44:49 <timofonic> I configure wrong or...
07:44:56 <edwardk_> danderson: they aren't all that scary, don't worry ;)
07:45:17 <danderson> edwardk_: something like spawnIO :: (SuspendableMonad s m) => m () -> m ()
07:45:26 <timofonic> away
07:45:34 <benmachine> danderson: basically functional dependencies constrain a multi parameter type class so that one of the parameters depends on another, i.e. a m and b m aren't both allowed
07:45:46 <danderson> that is, spawnIO foo will run foo in a new thread, using a suspended/resumed copy of the original thread's monad stack
07:46:12 <edwardk_> danderson: class SuspendableMonad m where type Suspended m :: *; spawnIO :: SuspendableMonad m => m () -> m () -- is probably better like benmachine says
07:46:22 <danderson> for any monad which can be suspended (eg. WriterT cannot be suspended, because I can't extract the state from within the WriterT context)
07:46:24 <benmachine> that's an associated type
07:46:27 <benmachine> associated types are cool
07:46:56 <danderson> benmachine: right, I see (sorry, was multitasking with edwardk_, but I am reading :)
07:47:00 <edwardk_> that way methods like spawnIO, which don't care about the existence of s don't have it cluttering up their type signatures. =)
07:47:15 <danderson> hmmm.
07:47:37 <benmachine> danderson: I tried to fork your code on codetidy but according to their captcha I'm not human >_>
07:47:40 <edwardk_> they may care about it internally, but its not part of the 'surface' type' exposing their implementation details
07:47:49 <edwardk_> benmachine: your nick gave you away
07:47:58 <danderson> benmachine: yeah, I'm barely human. I needed 4 or 5 tries to get it right.
07:48:10 <danderson> their captcha is nuts. I only posted there because hpaste is borked :)
07:48:32 <danderson> benmachine: maybe use pastebin.com instead?
07:48:37 <uys> hi. wondering if someone can shed some light on this,
07:48:54 <uys> Hask is a cartesian closed category
07:48:54 <edwardk_> danderson: there is of course, perhaps a better way to marshal the data back and forth. you can always go the IOref route
07:49:01 <edwardk_> or a temporary MVar
07:49:09 <edwardk_> and marshal it in and out behind the scenes
07:49:15 <uys> yet, it's possible to do linear algebra in Haskell
07:49:22 <danderson> edwardk_: so, in your definition, how does the Suspended type come into play?
07:49:35 <uys> i.e. operations associated with Abelian closed categories
07:49:47 <uys> which are not cartesian closed
07:49:48 <danderson> it seems superfluous, since spawnIO doesn't use it
07:49:50 <quicksilver> danderson: have you read the monadic tunelling email thread on the cafe?
07:49:51 <edwardk_> danderson: i presume you have some kind of suspend :: m s -- method? the signature just changes to suspend :: m (Suspended m)
07:49:53 <uys> any thoughts?
07:50:34 <danderson> edwardk_: ah, right. I was looking at it in terms of having just spawnIO in the type class. Makes sense then.
07:50:39 <danderson> quicksilver: no? Looking.
07:51:07 <danderson> quicksilver: recent? Thread subject?
07:51:09 <lpsmith> uys:  is a subgroup of a normal subgroup also normal?
07:51:14 <edwardk_> danderson: done right you can probably have just suspend and resume in the class and implement spawnIO generically in terms of them
07:51:33 <Peaker> Data-Accessor-Template and fclabels seem like duplicates :(
07:51:37 <quicksilver> danderson: approaching its third birthday :)
07:51:37 <uys> as far as I know, yes
07:51:39 <edwardk_> danderson: http://www.haskell.org/pipermail/haskell-cafe/2007-July/028501.html
07:51:39 <quicksilver> danderson: http://www.haskell.org/pipermail/haskell-cafe/2007-July/028501.html
07:51:44 <edwardk_> @stereo
07:51:44 <lambdabot> Unknown command, try @list
07:51:50 <edwardk_> @quote stereo
07:51:50 <lambdabot> monochrom says: Welcome to #haskell, where @remember's are in majestic stereo!
07:51:55 <danderson> edwardk_: right, that's what I was aiming for. My current implementation works, but requires fixing the type at suspend's call site. Looks like using your definition might give enough data to ghc to make it Just Work.
07:52:00 <lpsmith> uys, I don't think so;  I forget a counterexample off the top of my head though
07:52:05 <quicksilver> danderson: whilst in some ways you have already come further than that post, you might find that thread has some background you missed.
07:52:29 <lpsmith> but I seem to recall producing such a counterexample ages ago
07:52:32 <danderson> thanks, I'll give it a read. It seems like I'm not the only one to have noticed that some things are clunky with monad stacks :)
07:52:48 <benmachine> @quote overused
07:52:48 <lambdabot> edwardk says: @remember Baugn @remember lambdabot fasta says: I think the @remember command is way overused.
07:52:54 <benmachine> erm
07:52:57 <Peaker> What's clunky about them? Callbacks, mainly, I guess?
07:53:12 <quicksilver> Peaker: in intent, yes. in detail they used to differ quite a lot although perhaps they are approach a common interface?
07:53:14 <edwardk_> Peaker: callbacks are hellish, yeah
07:53:18 <benmachine> @quote stereo.*quote
07:53:18 <lambdabot> omnId says: geez, how many metastereo quotes are going to be @remembered?  >_>
07:53:26 <benmachine> what that is not even the one I wanted
07:53:29 <benmachine> @quote stereo.*quote.*overused
07:53:29 <lambdabot> dolio says: fasta: At least the 'stereo' quote is no longer in lambdabot. That was _way_ overused.
07:53:33 <benmachine> >:|
07:53:41 <danderson> Peaker: I have a stack of ReaderT Config (StateT State IO)) . From within a computation of that type, I want to forkIO a thread that runs another computation of that type.
07:54:07 <danderson> I must now manually disassemble the stack with ask and get, forkIO, and runStateT (runReaderT) by hand
07:54:14 <edwardk_> danderson: the tricky part is that not every function of the form (a -> IO b) -> IO b -- can be wrapped the same way
07:54:24 <edwardk_> especially when State is involved
07:54:30 <Peaker> danderson: completely separate? then it's not so bad to just ask and get and use those with runReader/runState?
07:54:44 <Peaker> danderson: oh, yeah
07:54:54 <danderson> I want to be able to pass any instance of MonadIO and some magic type class to a spawnIO function
07:54:54 <edwardk_> because you can give the call back your _current_ state, but that state may no longer be current when the callback is invoked, so State is a little bit wonky
07:55:01 <danderson> and have it do the unwrapping and rewrapping itself
07:55:04 <edwardk_> otoh, the withFoo methods all use it immediately
07:55:14 <uys> lpsmith: thanks, got some reading to do
07:55:16 <danderson> so I can just pass any computation of the same type as the current computation, and have it Just Work
07:55:27 <danderson> yeah, callbacks are a different problem
07:55:40 <edwardk_> and similarly forking, in an ideal world you'd be able to join your states back together as well
07:55:42 <quicksilver> well I think they're basically the same problem, danderson  ;)
07:55:46 <danderson> my problem of forking threads is somewhat simpler, in that I don't need the states to remain in sync
07:55:51 <quicksilver> but they're a slightly different cases.
07:55:55 <lpsmith> uys:  shouldn't be hard though;   take S_4,  take the subgroup of even permutations, and because that has index 2 it's obviously normal;   surely that has a non-normal subgroup, however.
07:56:01 <danderson> if I want explicit communication between threads, I'll use MVars or IORefs
07:56:09 <edwardk_> at least when you're spawning threads
07:56:19 <danderson> it would also be kinda cool to have ThreadSafeStateT, which magically synchronizes across threads
07:56:22 <Peaker> In many ways, transformers seem "glued" on-to Haskell later, rather than designed to fit in well
07:56:39 <danderson> but that's orthogonal to being able to traverse the forkIO gulf with less pain :)
07:56:54 <edwardk_> sadly MonadIO doesn't see much use
07:57:22 <jmcarthur> in apis you mean
07:57:26 <edwardk_> jmcarthur: yeah
07:57:49 <Peaker> edwardk_: I am not sure MonadIO is so great -- seeing as it wouldn't work very well for other monad types
07:57:55 <edwardk_> jmcarthur: i'd be much happier with a MonadST somewhere in the prelude, with as much code as possible lifted into it and specialized to IO or ST s
07:58:18 <edwardk_> Peaker: you can do the same for MonadSTM ;)
07:58:30 <edwardk_> there aren't many other 'base-only' monad types
07:58:57 <shapr> Yow!
07:59:04 <shapr> Yow!  Legally-imposed CULTURE-reduction is CABBAGE-BRAINED!
07:59:09 <edwardk_> well, you can make them up, but the idea in general is that the primitive stuff that talks to the OS is really the only machinery that would benefit from generalizing the monad in question
07:59:24 <benmachine> @help get-shapr
07:59:24 <lambdabot> get-shapr. Summon shapr instantly
07:59:24 <edwardk_> shapr: annoyed at your gen eds?
07:59:37 <benmachine> ^ what does this actually do
07:59:45 <edwardk_> @get-shapr
07:59:45 <lambdabot> shapr!!
07:59:48 <edwardk_> it gets shapr
07:59:49 <edwardk_> obviously
07:59:56 <edwardk_> @yow
07:59:57 <lambdabot> Couldn't find fortune file
07:59:59 <benmachine> oic
08:00:07 <edwardk_> see, he's here
08:00:09 <edwardk_> so it worked
08:00:15 <benmachine> it worked RETROACTIVELY
08:00:17 <edwardk_> correlation is causation and all that
08:00:19 <edwardk_> yeah
08:00:24 <benmachine> lambdabot is that good
08:01:05 <shapr> edwinb: You called?
08:01:06 <quicksilver> @tell edwardk It's very rude to log off when I'm halfway through typing a sentence to you!
08:01:06 <lambdabot> Consider it noted.
08:01:12 <shapr> haha
08:01:35 <shapr> Er, ETABCOMPLETION ...
08:01:41 <quicksilver> @tell edwardk Furthermore, it tends to subject poor edwinb to misdirected messages.
08:01:41 <lambdabot> Consider it noted.
08:01:51 <shapr> @tell edwardk Yeah, what he said.
08:01:51 <lambdabot> Consider it noted.
08:01:54 <fax> haskeal
08:01:57 <fax> haskal
08:02:00 <shapr> @keal
08:02:01 <lambdabot> i only trust opensource tools. where can i download haskell for windows?
08:02:26 <quicksilver> @tell edwardk However, I am finding public correspondance with you to be quite an amusing way to present a narrative to the rest of the channel. Small things amuse small minds.
08:02:26 <lambdabot> Consider it noted.
08:02:30 * shapr laughs
08:02:42 <shapr> I finally got the TCP/IP stack from LightHouse to build with ghc 6.12 yesterday.
08:02:50 <idnar> poor edwardk
08:04:59 <edwinb> quicksilver: it does subject me to misdirected messages, but it reminds me to pay attention to this channel more often ;)
08:06:59 <sunrayser> hi, I'm trying to get started with Template Haskell and I'm looking for the best starting point. I ended up at this page: http://www.haskell.org/haskellwiki/Template_Haskell should I begin with the user manuals or with the tutorials? (if I'm at the right place at all)
08:07:23 <aavogt> or the papers
08:08:13 <sunrayser> actually I need to write something like a code generator (tree traversing etc) in Haskell and everything points to TH
08:08:41 <wvd> Why this gives an error: "reverse' [] = []"?
08:08:49 <aavogt> ghc can derive  Traversable
08:08:53 <aavogt> and Functor
08:09:07 <aavogt> so perhaps you don't need to write the code generator?
08:09:08 <pozic> wvd: the monomorphism restriction?
08:09:28 <aavogt> it shouldn't apply there
08:09:34 <aavogt> since you have an argument
08:09:44 <wvd> http://gist.github.com/371134
08:09:53 <pozic> aavogt: right.
08:09:53 <gwern> @flush
08:09:58 <mdmkolbe> Where is a good summary of how the Yi syntax highlighter works (specifically with regard to indentation sensitivity with Haskell)?
08:10:01 <lpsmith> sunrayser, are you writing a code generator for Haskell,  or a code generator for say, C?
08:10:04 <wvd> Complains about an infinite type
08:10:13 <aavogt> wvd: your problem is   the    reverse' xs ++ x
08:10:31 <pozic> wvd: the error was not on the line you claimed.
08:10:31 <aavogt> if you really want to write it with ++, use    reverse' xs ++ [x]
08:10:46 <wvd> pozic: The line count starts with 0?
08:11:13 <wvd> Ah.
08:11:18 <aavogt> @type (++)
08:11:19 <lambdabot> forall m. (Monoid m) => m -> m -> m
08:11:24 <aavogt> @type (Prelude.++)
08:11:25 <lambdabot> forall a. [a] -> [a] -> [a]
08:11:44 <aavogt> (++) takes two lists containing equal types
08:11:57 <aavogt> (x:xs)  gives you    xs :: [a],  and   x :: a
08:11:57 <sunrayser> I'm trying to write a code generator in Haskell which generates code for ...um.. basically what a compiler does, traversing a syntax tree, passing semantic infos and an interface for plugging custom transform methods into this thing..
08:12:02 <wvd> So my problem was that x was a number?
08:12:11 <sunrayser> the compiler itself is in Haskell
08:12:47 <sunrayser> so the generated code should be as well...  the final transformation will be into C but that's the final stage of our compilation process and does not apply here
08:13:42 <gwern> mdmkolbe: there is no good summary. your best bet is the yi blog
08:13:52 <sunrayser> what I need to write is something that does transformations in a generic way on a Haskell representation of an imperative AST
08:14:05 <lpsmith> sunrayser, you probably want to transform an AST to another AST, not to Haskell then
08:14:08 <pozic> sunrayser: then TH has nothing to do with your problem.
08:14:20 <pozic> sunrayser: unless you want more problems, of course.
08:14:22 <lpsmith> sunrayser, you might want to take a look at syb
08:14:30 <mdmkolbe> gwern: ok, thanks
08:14:36 <lpsmith> "scrap your boilerplate"
08:15:21 <sunrayser> lpsmith: umm I actually need to generate code that does that transformation.. because the traversal functions (by hand until now) are around 1000 lines
08:15:41 <aavogt> wvd: so to satisfy    [a] = a, a must be an infinitely nested list
08:15:50 <lpsmith> yeah, syb can do some of that for you.
08:16:01 <lpsmith> TH might work too
08:16:05 <sunrayser> lpsmith: and what do you mean by syb? google threw many irrelevant things
08:16:05 <wvd> aavogt, ok
08:16:25 <lpsmith> sunrayser, syb = "scrap your boilerplate"
08:17:07 <sunrayser> I mean I specify the structure of the imperative AST and I want this generator to generate all the traversal functions for it
08:17:42 <lpsmith> What do you mean "imperative AST",  as in,  an AST for an imperative language?
08:17:48 <lpsmith> SYB will do that
08:18:13 <lpsmith> Or do you mean "imperative AST",  as in you use IORefs inside your AST and mutate it?
08:18:15 <sunrayser> yes, an AST for C to be more precise
08:18:44 <sunrayser> we have a DSL based on Haskell and we transform the functional code into this AST
08:19:14 <sunrayser> then we do some transformations on the AST (that's where I need the generator), then finally we pretty-print that into C code
08:19:27 <aavogt> wvd: but since infinite types are most likely a mistake (as they are in your case), they are not allowed without being wrapped in a data or newtype
08:19:54 <lpsmith> sunrayser, http://www.google.com/search?q=syb+haskell
08:21:19 <sunrayser> lpsmith: ok so based on what I told you, you think I should begin with this instead of TH?
08:21:31 <sunrayser> and see if it's enough?
08:21:39 <lpsmith> sunrayser, I couldn't tell you for certain
08:22:22 <lpsmith> I think SYB is a bit easier to use though;  i haven't used either SYB or TH (especially TH) enough to consider myself an expert
08:23:26 <aavogt> SYB is all at runtime
08:23:51 <aavogt> so if you make some mistakes, its less likely that you will have a type error
08:23:58 <lpsmith> yeah,  SYB traversals are often less than optimal too.
08:24:13 <lpsmith> sunrayser, you might look at UUAG too, though I've never used that
08:24:21 <quicksilver> sure, but as I understand it he wasn't suggesting doing the *actual work* at compile time
08:24:31 <aavogt> that is, you can run transformations or queries on data structures for which you will never have any elements that match
08:24:36 <quicksilver> he was suggesting using TH to generate traversal functions (at compiler time) which are then used at runtime
08:24:40 <quicksilver> this is exactly like SYB.
08:24:49 <quicksilver> and, in fact, SYB could be written in TH although I don't think it is.
08:25:09 <quicksilver> so the right question to ask seems to be 'does SYB give you the traversal functions you need?'
08:25:12 <aavogt> I'm not sure how ghc writes Data instances for you
08:25:20 <mdmkolbe> sunrayser: TH is better when you want to do more meta-programming-ish stuff (e.g. calculate a new datatype declaration from another one) but SYB is better for more generic-programming-ish stuff (e.g. take the average of all salaries in this large tree)
08:25:26 <quicksilver> (or, given how obscure most people find it, can you even tell if it does)
08:25:37 <quicksilver> uniplate is a simpler interface than SYB if it does what you need.
08:27:32 <sunrayser> the transformations could be for example unrolling a loop or some other optimization techniques called "plugins".. the whole thing is to give an interface for that and plugins only need to specify what to do at the "nodes" (what to do with a "loop")
08:27:52 <sunrayser> and this plugin architecture interface is what I need to generate
08:28:05 <sunrayser> which involves many traversal functions for example
08:28:34 <sunrayser> so the basic idea is to write (generate) those functions once, and use them in plugins
08:28:55 <sunrayser> so that plugins don't have to implement the traversing themselves
08:30:13 <lpsmith> yeah, I don't know enough about the specifics of what you want to say for sure,  but SYB or Uniplate,  TH,  and UUAG are all things to look at;  if you can,  write a traversal or two in each one and see how it goes
08:30:17 * hackagebot atom 1.0.3 - A DSL for embedded hard realtime applications.  http://hackage.haskell.org/package/atom-1.0.3 (TomHawkins)
08:31:13 <sunrayser> ok, I'll have a look at them, thanks
08:34:37 <wvd> a -> a -> a are basically two functions which both return a and both have a as parameter?
08:35:18 <Botje> no
08:35:19 <quicksilver> you wouldn't normally call that two function
08:35:27 <quicksilver> it's either one function which takes two parameters
08:35:35 <EvanR-work> (+) :: a -> a -> a
08:35:35 <Botje> it's one function that takes an a that returns a function that takes an a that returns an a
08:35:40 <quicksilver> or a function taking one parameter which returns a function taking one parameter
08:35:41 <EvanR-work> where a is Num ;)
08:35:58 <mdmkolbe> wvd: a -> a -> a is the same as a -> (a -> a) which is a function that takes "a" and returns a function of type "a -> a"
08:35:59 <Botje> or, it's a function that takes "two a's in a row" and produces an a
08:36:21 <wvd> mdmkolbe: and the function that it returns takes another a as parameter and returns an a?
08:36:29 <mdmkolbe> wvd: yes
08:37:00 <Peaker> I'm trying to depend on data-accessor-template in a .cabal file -- using ghc 6.12.1. I need to specify a cabal flag "template_2_4". This works if I: "cabal install data-accessor-template -ftemplate_2_4" but not if I try to install something that depends on data-accessor-template.. Anyone knows how to: A) Make cabal flags propagate in, or B) Have .cabal files specify flags for their deps?
08:37:59 <mdmkolbe> wvd: idiomatically this basically amounts to a function that takes an "a" and then another "a" to produce the final "a" (this is because in Haskell function application "f x y" is really "(f x) y" so first "x" gets applied then "y" gets applied to the result)
08:38:25 <quicksilver> Peaker: you are not the first to have this problem but unfortunately I don't know what the answer is.
08:38:26 <wvd> Looks like a nice concept
08:38:29 <wvd> Same with lazy evaluation
08:41:10 <EvanR-work> im having trouble with layout. how do i layout a do block which is in a let which is in a do block, but which does not start on the same line as the let
08:41:36 <Peaker> quicksilver: thanks. time to edit 00 tar files :)
08:41:42 <EvanR-work>   let foo = do
08:41:47 <EvanR-work>       a
08:41:53 <EvanR-work> says empty do expression
08:42:05 <jmcarthur> right because it looks like a should be another let binding
08:42:05 <fax> try one more space
08:42:10 <EvanR-work> ahhh
08:42:12 <fax> before the a
08:42:52 <EvanR-work> worked
08:42:53 <EvanR-work> tricky
08:44:33 <danderson> benmachine: still there?
08:45:12 <danderson> http://pastebin.com/7VW52pZY is, AIUI, the correct definition of the suspendable type class using an associated type. However, I don't grok how to define an instance of that class.
08:45:25 <danderson> could you get me started by helping me define SuspendableMonad IO ?
08:45:47 <otulp> http://pastebin.com/L2znqyBH <-- looking for some pointers. The main program creates a large [[Int]] and sends it into mergeSRsToStdout, which should sequence I/O actions accordingly. But this fails (stops outputting and starts eating all memory) if the inner list is more than one element long. I'm guessing the problem is with my lazy I/O, but haven't been able to figure out how to solve it.
08:45:58 <danderson> (in which suspend returns a placeholder, and resume just LiftIOs the passed in computation, ignoring the suspended state)
08:50:46 <EvanR-work> otulp: i suppose the lesson is dont do lazy i/o
08:50:52 <otulp> Hm. Perhaps if I instead of just using a [[Int]] use a [[(Int,Int)]], which signify startbyte and number of bytes to read. Then I would know how far to read in readSr, and hence could stuff everything into a buffer there instead of using hGetContents from ByteString.Lazy. That would perhaps work.
08:51:11 <otulp> EvanR-work: I've read that a few times, but don't really know about alternatives.
08:51:24 <EvanR-work> what about this
08:51:47 <danderson> benmachine: unping, got it to work.
08:51:49 <EvanR-work> the module that produces the list of data does strict i/o, and writes it to a chan. then make a lazy list from reading the chan on the other side
08:52:16 <EvanR-work> then errors in the i/o module can be h andled / crash, and the chan simply has no more data
08:53:18 <otulp> But I'm not confident that reading strictly will not result in devouring the whole input before starting the processing. The problem is that there's a lot of data.
08:53:57 <EvanR-work> otulp: thats true, and doing it this way theres no way to know 'how fast' to read it, but you are free to read it slower
08:54:22 <EvanR-work> you dont wont be able to get an automatic fit of read speed to processing speed, one will stall if you arent exactly right
08:54:46 <wvd> So because take is "Int -> [a] -> [a]", I can define: "let take5 = take 5", because then you have "5 -> [a] -> [a]", where [a] gets filled in when you give the second parameter?
08:54:55 <fax> no
08:55:10 <fax> it's "[a] -> [a]" the Int is given by 5
08:55:16 <EvanR-work> otulp: another way is to make the processing work on chunks, and 'manually' feed the chucks you read to the processor one at a time
08:55:20 <otulp> EvanR-work: Could you define for me what you mean by "chan". I'm guessing there's some "channel I/O" thing that I don't know about. :)
08:55:22 <EvanR-work> i.e. non lazy
08:55:33 <jmcarthur> EvanR-work, otulp: aka, iteratees
08:55:37 <EvanR-work> otulp: Control.Concurrent.Chan
08:55:57 <wvd> fax: oh right.
08:56:54 <otulp> Any nice & friendly tutorial/introductions around somewhere? I've seen some slides about iteratees and decided wait some time before trying to learn them proper.
08:56:57 <EvanR-work> ive heard iteratees being thrown about in here lately, is it some sort of abstraction on non lazy i/o
08:57:02 <EvanR-work> ?
08:57:16 <jmcarthur> EvanR-work: it's an abstraction over chunked input, basically
08:57:33 <jmcarthur> hence an abstraction which can replace lazy IO with something more predictable
08:58:14 <jmcarthur> otulp: unfortunately, "friendly" is not how i would describe most of the iteratee documentation out there :(
08:58:17 <benmachine> danderson: my router thinks it's fun to randomly start dropping half of my packets sometimes :(
08:59:00 <danderson> heh
08:59:06 <danderson> good grief, associated types are awesome
08:59:16 <danderson> now that my brain has clicked on how to use them
08:59:17 <jmcarthur> there's always truly manually chunked input in the worst case, which is no worse than most languages at least
08:59:20 <danderson> it's full of win
08:59:24 <EvanR-work> dropRandom (packets benmachine)
08:59:26 <otulp> EvanR-work: I'll look at chan. I'm not really worried about the speed, but rather about exhausting all memory.
08:59:34 <danderson> EvanR-work: unsafeDropRandom, please
08:59:43 <jmcarthur> i don't understand the Chan suggestion
08:59:52 <EvanR-work> dropRandom (packets benmachine) 7
08:59:54 <EvanR-work> 7 is the seed
09:00:04 <EvanR-work> otulp: it wont work
09:00:24 <burp> has anyone written a mathematical function parser, "x*a + 30*c^2*x + exp(7)" etc.?
09:00:26 <otulp> Oh.
09:00:31 <EvanR-work> you are right, the input part will read as much as possible put dump it to the chan, so the lazy part is useless
09:00:33 <wvd> What's wrong here? (Indentation error) - http://gist.github.com/371134
09:01:02 <jmcarthur> i'd go for either manually chunked input or iteratees
09:01:15 <benmachine> wvd: not an indentation error, does ghc say parse error (possibly indentation?)
09:01:17 <benmachine> er )?
09:01:25 <benmachine> paraphrased
09:01:25 <wvd> Yeah.
09:01:40 <benmachine> wvd: what line/column
09:02:04 <wvd> It says 9, but if it starts counting from 0, it's the second line, otherwise the first.
09:02:20 <benmachine> what's the last thing before the first line?
09:02:30 <gwern> @remember RasmusLerdorf "I don't know how to stop it [PHP], there was never any intend to write a programming language [...] I have absolutely no idea how to write a programming language, I just kept adding the next logical step on the way."
09:02:30 <lambdabot> Good to know.
09:02:34 <gwern> @flush
09:02:35 <gwern> @quote php
09:02:36 <lambdabot> qwe1234 says: i'm still waiting for the list of differences between lisp and php that matter.
09:03:28 <wvd> benmachine: Oh you're right.
09:04:09 <benmachine> wvd: btw, even though there's no indentation error in your paste, there is a type error :)
09:04:22 <wvd> I know.
09:04:27 <benmachine> k
09:04:56 <wvd> The tutorial uses this: "# zipWith' :: (a -> b -> c) -> [a] -> [b] -> [c]  ", but why? I'm creating a function which takes a function and two lists. It creates a new list and applies the functions to these lists.
09:05:32 <benmachine> that typesig takes a function and two lists
09:05:48 <benmachine> yours takes a thing and two lists
09:05:56 <benmachine> first of all, the thing can be any thing at all, function or not
09:06:08 <benmachine> secondly, the lists are specified to be the same type (as each other and the result)
09:06:11 <wvd> But why (a -> b -> c) is a function then?
09:06:19 <fax> because of the arrows
09:06:33 <fax> it's actually taking a to b -> c
09:06:36 <greedo> actually i need something like: ('rsync -avz -e ssh remoteuser@machine:/home/users/' date ' /home/users')
09:06:39 <benmachine> -> makes function types
09:06:45 <siracusa> burp: Maybe you could use the parseExp function of haskell-src-exts?
09:06:58 <wvd> fax, what if I feed it a function which is like a -> b -> c -> d?
09:07:22 <fax> yes
09:07:33 <fax> that takes a to (b -> c -> d)
09:07:46 <benmachine> :t (\a b c -> d)
09:07:47 <lambdabot> forall t t1 t2. t -> t1 -> t2 -> Expr
09:08:01 <benmachine> :t zipWith (\a b c -> d) [2,3] [4,5]
09:08:02 <fax> you can think of it as a function which takes an a, b and a c to a d
09:08:02 <lambdabot> forall t. [t -> Expr]
09:08:17 <benmachine> hmm I am probably jsut confusing things ignore me
09:08:41 <wvd> A function with "a -> b -> c" takes a as argument, returns b and creates c out of b?
09:09:05 <EvanR-work> returns b -> c, if you only give a
09:09:08 <mdmkolbe> wvd: no
09:09:11 <benmachine> wvd: a function "a -> b -> c" takes one argument and produces "b -> c" which takes one argument and produces "c", so in total it takes two arguments
09:09:24 <wvd> yes
09:09:37 <mdmkolbe> wvd: don't read "a -> b -> c" as "a -> b" and "b -> c".  Read it as "a -> (b -> c)".
09:09:57 <wvd> Wait.
09:09:58 <mdmkolbe> wvd: i.e. it is not like "0 < x <= y" in Perl 6.
09:10:10 <wvd> So (b -> c) is evalled before?
09:10:20 <zygoloid> b -> c is a type.
09:10:23 <benmachine> that is just a weird question
09:10:31 <otulp> Yey. My idea of using not only start bytes, but rather start bytes and spans worked wonderfully. I can keep my lazy I/O :)
09:10:35 <sepp2k> wvd: -> is right associative, if that's what you mean.
09:10:39 <wvd> i.e. - a -> (b -> c), a returns the result of (b -> c)?
09:10:49 <EvanR-work> wvd: parentheses tells you precedence, but that does not mean order of operations
09:10:50 <mdmkolbe> wvd: yes
09:11:15 <jmcarthur> otulp: sounds like as much trouble as strict IO to me ;)
09:11:17 <wvd> Okay, so the zipWith' function, is: (a -> b -> c) - but what if the function takes more then two arguments?
09:11:21 <zygoloid> wvd: more specifically, b -> c is the type of functions which take a value of type 'b' and produce a value of type 'c'. so a -> (b -> c) is the type of functiosn which take a value of type 'a' and return a function which takes a value of type 'b' and returns a value of type 'c'.
09:11:35 <benmachine> burp: I think this might be relevant to your interests: http://hackage.haskell.org/packages/archive/parsec/3.1.0/doc/html/Text-Parsec-Expr.html
09:11:36 <EvanR-work> wvd: then it will be a type error
09:11:42 <zygoloid> wvd: another way of looking at it is, a -> (b -> c) is the type of functiosn which take an 'a', then take a 'b', then produce a value of type 'c'.
09:11:49 <benmachine> EvanR-work: well, maybe maybe not
09:12:00 <zygoloid> wvd: finally, a -> (b -> c) == a -> b -> c because -> is right-associative.
09:12:05 <EvanR-work> ?
09:12:20 <benmachine> EvanR-work: you'll probably just get a list of functions
09:12:24 <wvd> zygoloid: So if I want to change order, (a -> b) -> c, would work?
09:12:40 <EvanR-work> benmachine: guess i dont get the question ;)
09:12:41 <zygoloid> wvd: (a -> b) -> c would be the type of a function which takes a function as an argument.
09:12:47 <benmachine> :t zipWith (\a b c d -> a + b + c + d) [1,2,3] [3,4,5]
09:12:48 <lambdabot> forall b. (Num b) => [b -> b -> b]
09:13:25 <zygoloid> wvd: like map :: (a -> b) -> [a] -> [b]. map takes a function as its first argument.
09:13:58 <EvanR-work> benmachine: that lambda matches the type for the first parameter of zipWith?
09:14:03 <benmachine> EvanR-work: yup
09:14:22 <wvd> Ah I got it now. The function can only have two arguments, since I only got two lists to zip.
09:14:25 <EvanR-work> if you put parens in the right place ;)
09:14:36 <Berengal> @djinn (a -> b -> c) -> Maybe a -> Maybe b -> Maybe c
09:14:37 <lambdabot> f a b c =
09:14:37 <lambdabot>     case b of
09:14:37 <lambdabot>     Nothing -> Nothing
09:14:37 <lambdabot>     Just d -> case c of
09:14:37 <lambdabot>               Nothing -> Nothing
09:14:39 <lambdabot>               Just e -> Just (a d e)
09:14:39 <benmachine> EvanR-work: if you substitute c with a function type
09:15:18 <EvanR-work> :t zipWith
09:15:19 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
09:15:45 <EvanR-work> benmachine: implementing type checking just got a lot more complex in my brain ;)
09:15:52 <benmachine> zipWith expects (a -> b -> c) and the lambda is type (Num n) => n -> n -> n -> n -> n, so that's fine if a = n, b = n, c = n -> n -> n
09:16:07 <zygoloid> EvanR-work: remember that (->) is a type constructor like any other
09:16:10 <benmachine> EvanR-work: nah, it's not that bad
09:16:34 <benmachine> yeah, matching c against n -> n -> n is in principle just as easy as matching it against, say, Maybe Int
09:16:47 <wvd> So if I want to make a function which applies a certain function to every element in a list I would need - (a -> b) -> [a] -> [b]?
09:16:53 <zygoloid> EvanR-work: zipWith can take a function of type (a -> b -> Reader r c), so why not (a -> b -> ((->) r c)) ?
09:16:57 <benmachine> wvd: yup
09:17:08 <EvanR-work> zygoloid: yes
09:17:33 <EvanR-work> type constructor algebra
09:19:04 <zygoloid> if you have: f a ~ g b c d, then you know that f ~ g b c, and a ~ d. incidentally this is broken by type synonyms (which are expanded first) and type functions (which can't be matched this way)
09:19:33 <EvanR-work> ~ ?
09:19:39 <benmachine> type equality
09:19:39 <zygoloid> "is the same type as"
09:20:07 <EvanR-work> interesting
09:20:09 <zygoloid> @type let x :: (m Int ~ Just a) => m a; x = return 42 in x
09:20:10 <lambdabot> Not in scope: type constructor or class `Just'
09:20:16 <zygoloid> @type let x :: (m Int ~ Maybe a) => m a; x = return 42 in x
09:20:17 <lambdabot> Maybe Int
09:21:09 <benmachine> @type let x :: (m Int ~ Maybe a) => m a; x = x in x
09:21:10 <lambdabot> Maybe Int
09:21:12 <benmachine> :P
09:21:43 <burp> benmachine: thanks
09:22:04 <wvd> bench: Finally I think I understand it now, thanks!
09:22:23 <benmachine> bench what
09:23:36 <wvd> ehm,
09:23:38 <wvd> benmachine*
09:23:39 <wvd> :P
09:24:18 <benmachine> it's a surprisingly common mistake
09:34:30 <EvanR-work> what structure do i use for a fifo queue which can be convert to and from a list
09:34:44 <opqdonut> a list is a fifo queue
09:35:12 <opqdonut> or rathery, you can use a list
09:35:14 <EvanR-work> i want efficient enqueue, dequeue. i dont necessarily need to have efficient dropping of certain elements
09:35:30 <opqdonut> look at okasaki's functional deque
09:35:31 <EvanR-work> which is the other operation ill be doing on it
09:35:50 <opqdonut> Data.Sequence is nicer for general purpose operations
09:35:52 <danderson> Here's another infinite type problem that I can't figure out, help? http://pastebin.com/zY1YLvdJ
09:36:00 <opqdonut> fast access to both ends, fast split and concat
09:36:02 <EvanR-work> i saw data.sequence
09:36:07 <opqdonut> those are about the operations you need, right?
09:36:17 <danderson> I suspect it has to to with runStateT returning m (a,s) instead of m a, but I don't see why that would bork the followup resume call
09:36:34 <EvanR-work> that, and the ability to filter the entire queue, which i can do by converting to a list, filter, then convert back
09:37:44 <opqdonut> IIRC you can filter a Sequence as-is
09:37:59 <danderson> benmachine: ^ , if you're still around ?
09:38:06 <zygoloid> EvanR-work: what's wrong with []?
09:38:07 <EvanR-work> which class is that, traversable
09:38:23 <EvanR-work> zygoloid: appending to the end is O(n) ?
09:38:34 <zygoloid> EvanR-work: oh, fifo not lifo, oops :)
09:38:50 <opqdonut> anyway, you _can_ use a lazy list as a fifo
09:38:57 <EvanR-work> yes
09:39:01 <zygoloid> DList would be better but still imperfect
09:39:09 <EvanR-work> DList?
09:39:12 <opqdonut> if you don't append, but evaluate the tail lazily
09:39:18 <zygoloid> @hoogle DList
09:39:18 <lambdabot> Text.Html dlist :: Html -> Html
09:39:18 <lambdabot> Text.XHtml.Frameset dlist :: Html -> Html
09:39:18 <lambdabot> Text.XHtml.Strict dlist :: Html -> Html
09:39:20 <zygoloid> :(
09:39:28 <zygoloid> @hackage dlist
09:39:28 <lambdabot> http://hackage.haskell.org/package/dlist
09:39:35 <opqdonut> no reason to use dlist instead of data.sequence
09:39:35 <opqdonut> IMO
09:39:53 <jmcarthur> no dlist wouldn't be better
09:40:02 <jmcarthur> it would be worse i think
09:40:20 * hackagebot Lucu 0.7 - HTTP Daemonic Library  http://hackage.haskell.org/package/Lucu-0.7 (MasatakeDaimon)
09:40:33 <jmcarthur> if you will be interleaving enqueue and dequeue then you will not be getting the benefits of sharing as you would with Data.Sequence
09:41:01 <zygoloid> jmcarthur: i was saying DList would be better than [], not better than Seq
09:41:05 <jmcarthur> ah
09:41:37 <jmcarthur> dlist basically just gives you one free reverse
09:42:22 <jmcarthur> well, and i guess appends, as long as you don't ned intermediates
09:42:27 <jmcarthur> *need
09:44:55 <benmachine> danderson: tbh I can't work it out either
09:45:12 <benmachine> danderson: oh hold on
09:45:42 <benmachine> danderson: the problem is you're expecting the recursive call to return mio a
09:45:44 <benmachine> because that's what you need
09:46:05 <benmachine> but as you say you're giving it m (a, s) so it wants to return mio (a, s)
09:46:07 <EvanR-work> i suppose i can filter on a data.sequence because its a instance of foldable?
09:46:13 <EvanR-work> @src filter
09:46:14 <lambdabot> filter _ []     = []
09:46:14 <lambdabot> filter p (x:xs)
09:46:14 <lambdabot>     | p x       = x : filter p xs
09:46:14 <lambdabot>     | otherwise = filter p xs
09:46:24 <EvanR-work> hm
09:46:35 <benmachine> so in order for it to typecheck you get a = (a, s) = ((a, s), s) = (((a, s), s), s) and then GHC cries
09:46:54 <EvanR-work> > filter even (Data.Sequence.empty)
09:46:55 <lambdabot>   Not in scope: `Data.Sequence.empty'
09:47:51 <EvanR-work> ah, filter is apparently defined in Data.Sequence, but not in the docs
09:50:12 <danderson> benmachine: hmmm, drat.
09:50:26 <danderson> yeah, I see.
09:52:32 <jmcarthur> EvanR-work: http://www.haskell.org/ghc/docs/latest/html/libraries/containers-0.3.0.0/Data-Sequence.html#v%3Afilter  ??
10:03:57 * hackagebot haskell-src-exts-qq 0.2.2 - A quasiquoter for haskell-src-exts.  http://hackage.haskell.org/package/haskell-src-exts-qq-0.2.2 (MathieuBoespflug)
10:06:22 <timofonic> Can I use distributed building over a network of computers for building Haskell programs under GHC? :P
10:07:31 <Lemmih> ?faq Can Haskell do distributed builds?
10:07:31 <lambdabot> The answer is: Yes! Haskell can do that.
10:07:44 <Lemmih> ^^ Disregard that. The answer is no.
10:07:55 <timofonic> Lemmih: :/
10:08:08 <timofonic> Lemmih: Really?
10:08:32 <Lemmih> timofonic: Yeah, really. /:
10:08:45 <benmachine> it can as long as you write the code for GHC yourself
10:08:55 <timofonic> Lemmih: Even lisp can...
10:09:01 <benmachine> even lisp?
10:09:03 <Katiebug> how on earth am I supposed to build a list in Haskell without using a recursive function?
10:09:05 <EvanR-work> lol
10:09:13 <boegel> anyone in here happen to know someone in Iceland who can confirm that a second volcano has started to erupt?
10:09:19 <benmachine> Katiebug: who says you should?
10:09:25 <chrisdone> :t unfoldr
10:09:26 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
10:09:35 <timofonic> Oh, it did work?
10:09:35 <EvanR-work> :t randoms
10:09:36 <lambdabot> forall g a. (Random a, RandomGen g) => g -> [a]
10:10:02 <timofonic> Maybe "even lisp works" worked to motivate people to think how to do it on Haskell...
10:10:22 <Katiebug> benmachine, this assignment
10:10:30 <Katiebug> I also can't use list comprehensions
10:10:58 <timofonic> @faq can "even lisp can..." be a motivational phrase starter for haskellers to code something?
10:10:58 <lambdabot> The answer is: Yes! Haskell can do that.
10:11:01 <EvanR-work> you cant use list comprehensions or recursive functions, well unfoldr is recursive
10:11:07 <dcoutts_> Peaker: if data-accessor-template is changing it's API based on a flag, then it's doing it wrong
10:11:12 <chrisdone> perhaps one could read the .hi files and detect files which can be compiled separately?
10:11:18 <benmachine> Katiebug: depends on the list
10:11:21 <timofonic> benmachine: But... GHC can generate C code!
10:11:33 <mux> is there a default timeout on mueval? I don't see this mentioned in the help screen but lambdabot doesn't seem to pass a -t option anymore and I'm having timeouts on a slow box
10:11:35 <Katiebug> EvanR, sorry I should have mentioned we are able to use foldl and foldr
10:11:42 <timofonic> benmachine: GHC -> distcc doesn't give advantages?
10:11:50 <EvanR-work> Katiebug: then you can use fold and : to build a list
10:11:50 <Katiebug> but the function we build can't explicitly make any recursive calls
10:11:50 <benmachine> timofonic: no idea, maybe
10:12:18 <timofonic> benmachine: Uh
10:12:21 <benmachine> Katiebug: have a look at foldr (:) []
10:12:23 <mux> ah, there is, looking at the code
10:12:24 <Katiebug> EvanR-work, not without the function that builds the list using fold being recursive...
10:12:27 <timofonic> Anyone tried it?
10:12:28 <chrisdone> mux: yeah it has a default limit of 5
10:12:37 <mux> chrisdone: thanks, just saw that in ArgsParse.hs
10:12:38 <benmachine> timofonic: you are confusing me with someone who is in any way helpful to you
10:12:40 <EvanR-work> Katiebug: ?
10:12:41 <benmachine> sorry :P
10:12:48 <mux> chrisdone: any idea what the unit is? :-)
10:12:57 <EvanR-work> > foldr (:) [] [1,2,3,4]
10:12:58 <lambdabot>   [1,2,3,4]
10:13:13 <EvanR-work> that worked
10:13:14 <Katiebug> hmm
10:13:20 <Katiebug> I'll try that then...
10:13:21 <benmachine> Katiebug: foldr recurses for you
10:13:29 <Katiebug> benmachine, I know that
10:13:29 <benmachine> @src foldr
10:13:29 <lambdabot> foldr f z []     = z
10:13:30 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
10:13:33 <Katiebug> I had to build my own foldr
10:13:36 <dcoutts_> Peaker: I would suggest getting the maintainers of that package to do it differently, if it's a simple adaptation to the version of TH, then they can do it with a bit of cpp, rather than having to use flags.
10:13:44 <chrisdone> mux: n*{-# LANGUAGE TypeFamilies #-}
10:13:44 <chrisdone> module Control.Monad.Suspendable where
10:13:44 <chrisdone> import Control.Monad.Error
10:13:44 <chrisdone> import Control.Monad.Reader
10:13:49 <Katiebug> but foldr doesn't return a list usually
10:13:52 <mux> chrisdone: seems to be seconds, but it also seems to be quite inaccurate
10:13:54 <Katiebug> it just returns a single value
10:14:06 <EvanR-work> it returns a list if the operation is :
10:14:10 <benmachine> Katiebug: no reason why that value can't be a list type
10:14:16 <benmachine> err, of a list type
10:14:29 <chrisdone> clipbard fail
10:14:32 <chrisdone> I hope I didn't spam the hell out of everyone
10:14:39 <benmachine> chrisdone: only four lines
10:14:44 <chrisdone> phew
10:15:20 <timofonic> benmachine: At least you try to seem helpful, that's more than most people and specially my pathetic sentimental relationships (with females only, I'm sorry gay (are there females here?) haskellers but no dirty maths to me) :)
10:15:41 * benmachine attempts to parse timofonic's nested parentheses
10:15:51 <EvanR-work> stack overflow
10:15:51 <benmachine> erm, okay
10:16:21 <danderson> benmachine: so, to fix this infinite type thing, I decided to be a smartass, and redefine: resume :: (MonadIO mio) => m a -> Suspended m -> mio b
10:16:27 <IceDane> 19:14 <+fsck> IceDane: tbh, haskell is incredibly over-complicated considering  how limited its uses are
10:16:31 <IceDane> -_-
10:16:43 <danderson> since in theory, I don't see a particular reason why resume should return the same type, although it happens to be true for most instances
10:16:48 <timofonic> benmachine: It's an old wird tradition from young days. I was able to do 15 nested phrarenthesis on text phrases in my best days, maybe some more :)
10:16:49 <fax> IceDane trolling aint easy
10:16:52 <IceDane> And no, he's not trolling
10:16:59 <chrisdone> fax: trolling is hard, let's go haskelling!
10:17:06 <IceDane> He's genuine
10:17:12 <IceDane> The type to talk about stuff he hasn't touched
10:17:19 <benmachine> genuinely a troll?
10:17:20 <timofonic> So you guys are still talking about suspend/resume since I got slept at the sofa. Oh nice, YOU NERDS :D
10:17:30 <danderson> and now haskell is complaining about my instance of SuspendableMonad for IO, because it can't figure out what I meant by the liftIO call :)
10:17:43 <EvanR-work> timofonic: better get used to it ;)
10:17:50 <IceDane> benmachine: I define troll as "intentionally saying stupid shit to make nerds go crazy"
10:17:53 <benmachine> danderson: it figured it out, it just decided it didn't like it
10:17:59 <danderson> heh.
10:18:00 <IceDane> And he is not a troll by that definition
10:18:01 <benmachine> IceDane: oh, fair enough
10:18:11 <benmachine> yes that is a reasonably definition
10:18:29 <chrisdone> hpaste's down AGAIN??
10:18:30 <benmachine> (although it's possible to troll non-nerds)
10:18:35 <benmachine> (possible and morally reprehensible!)
10:18:36 <IceDane> true
10:18:44 <timofonic> IceDane: Also, I like his nickname and he seems funny. Maybe because still not so emotionally attached to Haskell (still newbie, and who knows when I'll not)
10:18:59 <IceDane> timofonic: He hasn't tried it, whatsoever, heh
10:19:01 <danderson> benmachine: specifically, http://pastebin.com/8fxpRGSd
10:19:14 <timofonic> IceDane: Uh, then real world troll nerds constantly!
10:19:23 <timofonic> IceDane: Even to wannabe ones like me :P
10:19:26 <danderson> this puzzles me, because my type signature for resume shouldn't prevent an instance where a == b
10:19:29 <benmachine> :t liftIO
10:19:30 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
10:19:31 <danderson> but ghc seems to think it does
10:19:56 <chrisdone> danderson: i haven't seen associated types but i guess that's what you'r eusing right? pretty cool
10:20:13 <benmachine> danderson: imagine you gave resume the type signature a -> b
10:20:15 <danderson> chrisdone: yup, associated types, and they make that code awesome and neat
10:20:20 <benmachine> then your instance would match with that so it'd be fine right?
10:20:35 <benmachine> :P
10:20:48 <timofonic> Anyone knows if GHC -> distcc can give any speed advantage? Or building C code is nearly as slow as native one? :P
10:20:50 <benmachine> thing is, you don't get to choose what a and b are in the instance
10:20:59 <danderson> grmbl
10:21:01 <timofonic> (and dendind it to remote machines for building)
10:21:12 <benmachine> someone might pass resume an IO String and ask it for a IO Int
10:21:26 <benmachine> and according to that typesig it's gotta make that happen somehow
10:21:32 <danderson> right, I see.
10:21:44 <benmachine> I think you were right with mio a
10:21:52 <Katiebug> thank you very much for your help
10:22:03 <danderson> what I'm looking for is a type signature that allows both m a -> mio a and m a -> mio (a,s), basically.
10:22:18 <danderson> that is, resume may return additional data on top of the plain a
10:22:25 <danderson> which is the case when you resume a StateT
10:22:35 <benmachine> danderson: hmm, sounds unpleasant
10:22:41 <danderson> one option is to just throw the new state away and just return the a
10:22:47 <benmachine> you could make the return type of resume an associated type
10:22:51 <benmachine> but that would be slightly eek
10:23:08 <zygoloid> that's probably the right option though
10:23:09 <EvanR-work> can i import qualified 'as' and import selected symbols not qualified from the same module?
10:23:23 <zygoloid> EvanR-work: yes, but you need a separate import line
10:23:28 <EvanR-work> great
10:23:37 <danderson> but that breaks the identity that resume . suspend gives you back the original stack, with all its power
10:23:49 <danderson> in the case of StateT, you lose access to the updated state
10:26:01 <timofonic> At the cost of additional messages, lazy functional languages support the dynamic and lazy communication between processes. <---- This sounds like a perfect marketing phrase for Haskell. Are you LAZY? Use Haskell (but nah, it's a lie)
10:27:02 <EvanR-work> question: i keep editing the first line in a do block before the do, now i have to re-indent the entire block, solution? smaller doblocks?
10:27:13 <timofonic> A lie to attract non-nerds :P
10:27:29 <BONUS> EvanR-work: newline after do
10:27:33 <timofonic> Oh, do Haskell also suffers the indentation syndrome?
10:27:34 <EvanR-work> ah
10:27:42 <zygoloid> EvanR-work: don't listen to people when they tell you the indent depth should vary depending on the other stuff on the line
10:27:46 <jmcarthur> timofonic: syndrome?
10:28:01 <jmcarthur> timofonic: haskell indentation is a lot nicer than python's, actually
10:28:07 <zygoloid> EvanR-work: my preference is that 'do' is always the last thing on the line, and the next line is indented two spaces more.
10:28:07 <timofonic> jmcarthur: If I forget an indent, will it eat my children?
10:28:09 <jmcarthur> and it's optional. you can also just use ;
10:28:11 <timofonic> jmcarthur: Oh
10:28:18 <edwardk_> timofonic: it can be cured with manual { }'s if you need to break out of the discipline
10:28:22 <EvanR-work> zygoloid: thats usually what i do, i just forgot in this case and was frustrated
10:28:53 <jmcarthur> i never use { }
10:28:55 <timofonic> jmcarthur: Oh, good. So it has the C way
10:29:11 <jmcarthur> it's not even out of spite for it. i just don't feel like the indentation rules get in my way at all
10:29:14 <EvanR-work> i still dont understand how to use { } ; ;)
10:29:25 <jmcarthur> do { foo; bar; baz }
10:29:38 <EvanR-work> right but what if bar was let x = y; z = w;
10:29:44 <timofonic> EvanR-work: Never coded in C? Wow
10:29:55 <EvanR-work> timofonic: >_>
10:30:01 <jmcarthur> EvanR-work: i don't see how that complicates anything
10:30:01 <zygoloid> EvanR-work: then do { foo; let { x = y; z = w }; baz }
10:30:02 <timofonic> EvanR-work: Even my kittens did it
10:30:07 <EvanR-work> ah
10:30:15 <EvanR-work> you have to put the let in its own { }
10:30:17 <zygoloid> jmcarthur: it introduces ambiguity.
10:30:28 <EvanR-work> and have its own ;
10:30:32 <EvanR-work> thats what i didnt get
10:30:37 <jmcarthur> do { foo; let x = y; let z = w; baz }
10:30:42 <jmcarthur> would that not work?
10:30:54 <EvanR-work> the last entry in let does not have ; ?
10:30:56 <zygoloid> jmcarthur: suppose y uses z and w uses x
10:31:15 <timofonic> EvanR-work: At least C is better than BASIC, perl, Python, AES encryption...
10:31:31 <jmcarthur> ah. i typically treat let as ordered anyway. regardless, an explicit block in that case makes sense to require anyway
10:31:52 <jmcarthur> "better"?
10:33:07 <timofonic> jmcarthur: It drives you less insane, is a lot more useful and efficient, even it has some valid usages in real world ouside markething and programmer farms of code monkeys for corps...
10:33:46 <chrisdone> take it to #haskell-blah?
10:33:49 * zygoloid puts on tinfoil hat to ward off language warring
10:33:56 <timofonic> chrisdone: ye right
10:34:09 <timofonic> chrisdone: Sorry
10:36:43 <Katiebug> is there  quick way to just add the same value to all elements of a list?
10:37:09 <chrisdone> > map (+1) [1..5]
10:37:10 <lambdabot>   [2,3,4,5,6]
10:37:17 <mxc> is anyone familiar with this type of error:   "internal error: evacuate: strange closure type 0"
10:37:17 <Twey> > map (+ 3) [7 .. 18]
10:37:18 <lambdabot>   [10,11,12,13,14,15,16,17,18,19,20,21]
10:37:25 <mxc> i do have some code that uses unsafeCoerce to store doubles and ints in the same array, i'm wondering if that could be the cause
10:37:30 <Katiebug> ahh thanks
10:37:32 <Twey> mxc: Run for your life!
10:37:36 <Twey> mxc: I suspect so
10:38:09 <zygoloid> mxc: that's probably the cause. what's the type of the array?
10:38:19 <benmachine> unsafeCoerce on anything other than a type to itself, or a type to a newtype of it or back, is strictly no warranty :P
10:38:23 <mxc> i wrote it so it 'should' be impossible to access an uninitialized elemnt of the array
10:38:28 <benmachine> oh wait there's Any as well isn't there
10:38:50 <mxc> if there is a better way to have a really fast, unboxed array of ints and doubles, i'm all ears
10:38:56 <zygoloid> mxc: if the GC finds a value there which doesn't match the type it's expecting, strange things could possibly happen
10:39:00 <EvanR-work> mxc: use the ffi ? :)
10:39:15 <zygoloid> mxc: again, what's the type of the array you're using?
10:39:22 <mxc> IOUArray
10:39:42 <mxc> its IOUArray SubID Word64
10:39:42 <zygoloid> ouch, that's not going to work
10:40:00 <zygoloid> well, Word64 might be ok :)
10:40:01 <EvanR-work> your id is a double ?
10:40:08 <mxc> where subID is a newtyped, abstracted int
10:40:10 <jmcarthur> timofonic: those arguments are not really backed up by any evidence. C is efficient, yes. C is useful, yes. but those other languages (with the exception of BASIC... and why did you even mention AES?) also serve purposes which C can only handle less elegantly
10:40:18 <mxc> no, essentially newtype SubID = SubID_ Int
10:40:25 <mxc> and the data constructor isn't exported
10:40:38 <mxc> to make sure that no uninitialized values are accessed
10:40:55 <EvanR-work> uninitialized values in haskell?
10:40:57 <mxc> (my preivous implementation was with intmaps and DiffArrays before that)
10:41:19 <mxc> i think for the problem i'm doing, i need that speed though
10:41:24 <Twey> QotD: ‘C is better than AES encryption’
10:41:24 <jmcarthur> undefined is not quite the same as uninitialized
10:41:32 <timofonic> jmcarthur: Yes, they are quite good for making fanboy communities. AES because that stupid joke about perl :)
10:41:39 <zygoloid> mxc: so basically your code is doing the equivalent of: case unsafeCoerce (d :: Double) :: Word64 of W64# w -> putInArray w
10:41:47 <chrisdone> EvanR-work: data T = T { myT :: Int }
10:41:47 <chrisdone> EvanR-work: myT (T { }) -- here myT is uninitialised
10:41:48 <zygoloid> mxc: that seems quite likely to fall over
10:41:50 <mxc> yes
10:42:11 <EvanR-work> how did you do that!
10:42:12 <timofonic> Twey: So it's better than Perl? :)
10:42:23 <jmcarthur> timofonic: you seem to have subscribed to a fanboy's religion yourself :P
10:42:35 <chrisdone> what?
10:42:39 <timofonic> jmcarthur: Yes, I'm vegan :P
10:42:44 <timofonic> jmcarthur: Unfortunately...
10:42:49 <mxc> so, is there a 'safe' way to store Int64s and Doubles just as their 8-byte representations?
10:43:02 <zygoloid> the Storable instance is one way to go
10:43:05 <jmcarthur> mxc: what for?
10:43:32 <zygoloid> jmcarthur: mxc wants an untagged union of Int64 and Double to use as an element in an unboxed array
10:43:46 <jmcarthur> untagged? huh
10:43:50 <zygoloid> presumably this array is huge, and can't reasonably be split into two arrays
10:44:11 <jmcarthur> mxc: are these interleaved in an at all predictable fashion?
10:44:13 <mxc> so i lied, sort of.
10:44:22 <mxc> the indices of my array are (FieldID, SubID)
10:44:36 <mxc> and FieldID completely determines if it is a double or int
10:44:46 <jmcarthur> ah, FieldID is a tag
10:45:05 <mxc> FieldID can be something like Bid, Ask (both newtyped doubles) or BidSize, AskSize (newtyped ints)
10:45:19 <mxc> this is for a trading system, and this one bit of it needs to be fast
10:45:25 <timofonic> benmachine: http://www.macs.hw.ac.uk/~dsg/gdh/
10:45:29 <jmcarthur> it being an index seems to imply that there is a natural grouping of doubles and int64s in the array as well?
10:45:39 <mxc> basicaly, i'm usuing this array to store incoming data
10:45:42 <timofonic> http://www.macs.hw.ac.uk/~dsg/gdh/
10:45:48 <timofonic> oops
10:46:04 <jmcarthur> mxc: what are the access patterns of this array?
10:46:31 <mxc> jmcarthur: very frequent writes to a infrequently changing set of SubIDs
10:46:32 <jmcarthur> mxc: if you are in that much of a bind for speed then you should be worrying about things like cache coherency as much as data packing
10:46:40 <mxc> and very frequent reads too
10:46:44 <benmachine> timofonic: great
10:46:59 <mxc> i was going one step at a time
10:47:23 <mxc> the IntMap implementation was getting far too slow
10:47:49 <mxc> (also, i handled the fields differently, so there was no ugly unsafeCoerce going on
10:47:51 <jmcarthur> this way lies madness (not that you have much choice if you are going for C-like efficiency)
10:48:28 <jmcarthur> mxc: is there any inherent reason you can't just have one array for the Int64s and one for the Doubles?
10:49:21 <mxc> it would take a bit of reworking the code
10:49:31 <mxc> i thought unsafeCoerce wasn't this dangerous
10:49:36 <mxc> i didn't realize it
10:49:39 <jmcarthur> mxc: just a new way to index it, really
10:49:45 <dons> it's arbitrarily dangerous
10:49:53 <dons> you pick your own threat level
10:50:00 <luite> perhaps its name is not scary enough
10:50:01 <erikc> Orange
10:50:56 <shepheb> dontEvenThinkAboutItCoerce. sweetJesusCoerce. crashProgram.
10:50:59 <mxc> i can verify that my marshall . unmarshall = a
10:51:06 <mxc> i can verify that my marshall . unmarshall = id
10:51:10 <mxc> i thought that was enough
10:51:12 <wvd> "But apart from getting rid of parentheses, $ means that function application can be treated just like another function. That way, we can, for instance, map function application over a list of functions." - Could anyone show an example explaining this?
10:51:29 <mxc> especially since any combination of 64 bits is a "legal" word64
10:51:39 <aavogt> no, it's different with respect to type inference for higher rank polymorphism
10:51:57 <mxc> luite - it was pretty scary, i've never used an 'unsafe' function before...
10:51:57 <jmcarthur> > map ($5) [(+1), (*2), (/3)]
10:51:58 <lambdabot>   [6.0,10.0,1.6666666666666667]
10:52:02 <jmcarthur> wvd: ^^
10:52:19 <aavogt> > sequence [(+1), (*2), (/3)] 5
10:52:20 <lambdabot>   [6.0,10.0,1.6666666666666667]
10:52:25 <jmcarthur> > map ($x) [f, g, h]
10:52:26 <lambdabot>   Ambiguous type variable `b' in the constraints:
10:52:26 <lambdabot>    `GHC.Show.Show b'
10:52:26 <lambdabot>      a...
10:52:29 <jmcarthur> meh
10:52:36 <wvd> jmcarthur, ah like that, thanks.
10:53:54 <timofonic> Uhhh, joke hackages? I doubt if they are real... http://hackage.haskell.org/package/acme-now
10:53:57 <mxc> so even if marshall . unmarshall = id, unsafeCoerce is still dangerous?
10:54:32 <jmcarthur> mxc: this is not something i would use unsafeCoerce for
10:54:51 <benmachine> seems my unicode is being truncated by hPutStrLn on a socket
10:55:01 <benmachine> I thought this was supposed to Just Work in GHC 6.12
10:55:26 <benmachine> *hPutStr
10:55:46 <jmcarthur> mxc: i wouldn't only consider unsafeCoerce for cases where the haskell type system is not powerful enough to determine that type A and type B are actually the same in some circumstance, not to cast a value of one type to another type
10:55:51 <jmcarthur> *i would only
10:56:00 <chrisdone> benmachine: Just Work how?
10:56:04 <mxc> ok
10:56:15 <mxc> thanks for help
10:56:15 <benmachine> chrisdone: that's not in the specification of Just Working :P
10:56:20 <jmcarthur> i've also seen people use unsafeCoerce with newtype stuff, but even then you risk changing some semantics
10:56:39 <benmachine> chrisdone: I don't know, I'm making a server that you're supposed to connect to with telnet, any advice would be appreciated
10:56:43 <mxc> "un"newtyping something with unsafeCoerce seems more dangerous
10:56:49 <benmachine> as to how I can get non-ASCII to turn up on my telnet screen
10:57:10 <jmcarthur> nah, newtypes have the same runtime representation as their underlying type
10:57:22 <chrisdone> benmachine: are you using utf8-string's hPutStrLn?
10:57:23 <fax> here is my advice:  Don't use functions that have 'unsafe' in the name
10:57:33 <jmcarthur> good advice
10:57:42 <benmachine> chrisdone: no, but I was under the impression that utf8-string was only necessary on the 6.10 series
10:57:45 <jmcarthur> unsafe is for working with the compiler, not with the language
10:57:54 <chrisdone> benmachine: why?
10:57:58 <benmachine> chrisdone: I'm using 6.12 for which unicode is meant to be better in some way
10:58:14 <benmachine> but I could be confusing issues
10:58:36 <chrisdone> isn't unicode stored as UCS in GHC?
10:59:04 <chrisdone> utf-16
10:59:09 <EvanR-work> writing a String to a handle involves an encoding process doesnt it? one that you can configure?
10:59:21 <chrisdone> pretty sure you'll have to encode it still, to UTF-8, using utf8-string'
10:59:35 <EvanR-work> that should be the default
10:59:39 <EvanR-work> in my opinion
10:59:48 <chrisdone> well utf8 is slower
10:59:50 <jmcarthur> the default should be whatever your locale is set to
10:59:56 <jmcarthur> which is what i think the default actually is
10:59:56 <EvanR-work> but there should also be a way to change the handle output encoding, also in my opinion ;)
10:59:58 <jmcarthur> in 6.12
11:01:24 <EvanR-work> > text "日本語"
11:01:25 <lambdabot>   日本語
11:03:07 <EvanR-work> yay it came back in one piece ;)
11:03:27 <dv-> I just see squares
11:04:06 <pikhq> Yeah, you just are missing the font.
11:04:12 <jmcarthur> looks good to me! :)
11:04:19 * benmachine too
11:04:24 <EvanR-work> good old gnu unifont
11:04:51 <danderson> benmachine: so, you said that specifying the return type of resume as an associated type would be eek. Any specific reason why?
11:05:05 <jmcarthur> works all the way through weechat->screen->zsh->ssh->zsh->sakura :D
11:05:35 <danderson> I now have both StateT and ErrorT which can't be adequately expressed with my current SuspendableMonad, which bothers me deeply.
11:05:48 <opqdonut> why can't they?
11:06:00 <Katiebug> how exactly do I return a function?
11:06:06 <benmachine> danderson: no, just generally eek
11:06:09 <jmcarthur> danderson: is this a type class or something?
11:06:11 <opqdonut> Katiebug: just do it
11:06:18 <danderson> jmcarthur: yes, a type class. Once sec, pastebinning.
11:06:25 <jmcarthur> ew pastebin
11:06:43 <danderson> well, I also have local version control, I can stick it online that way too.
11:06:43 <Katiebug> oh wait...
11:06:46 <jmcarthur> pastebin is hard for me to read
11:06:52 <opqdonut> > let f x = \y -> 1+y in (f 1) 2
11:06:52 <lambdabot>   3
11:06:53 <jmcarthur> what's wrong with hpaste?
11:06:55 <opqdonut> which is the same as
11:06:58 <Katiebug> I can define the function I want to return using where can't I?
11:07:06 <opqdonut> yes
11:07:10 <Katiebug> awesome
11:07:12 <danderson> jmcarthur: hpaste was broken earlier. However, it's back now, thanks for pointing it out :)
11:07:18 <jmcarthur> rock
11:07:20 <benmachine> danderson: I dunno it just seemed to me that any problem could be solved by throwing sufficiently many associated types at it until the function isn't really that generic anymore
11:07:42 <hpaste>  . (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24949
11:07:43 <danderson> jmcarthur: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24949#a24949
11:08:16 <danderson> one possible use of the type class is illustrated by the forkIO implementation at the bottom of the paste.
11:08:43 <lowsodium> qq: I need some help with groupBy, in particular, I'm not sure why groupBy (<) [1,2,3,2] returns [[1,2,3,2]]
11:08:57 <danderson> note that with the current type signature of resume, the StateT instance discards the updated state, instead of returning it as a non-suspended-resumed runStateT would
11:09:04 <opqdonut> lowsodium: you should give an _equality_ function
11:09:11 <BONUS> lowsodium: groupBy doesn't work that way, it needs an equivalence relation
11:09:15 <danderson> this is what bothers me, the StateT instance loses data across suspend/resume.
11:09:45 <BONUS> because instead of comparing adjecent element, it takes the first 1 and then keeps comparing while < is true
11:09:49 <danderson> and ErrorT, with its Either return value, is even worse.
11:10:02 <lowsodium> i see, so it only checks the first in the previous list, is that right?
11:10:14 <danderson> Ideally, I'd be able to define a type signature for resume which allows me to return the complete resumed return value, rather than being constrained in the way it is now.
11:10:16 <jmcarthur> danderson: eep. doesn't appear to be very well defined to me
11:10:44 <EvanR-work> @src groupBy
11:10:44 <lambdabot> groupBy _  []       =  []
11:10:44 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
11:10:44 <lambdabot>     where (ys,zs) = span (eq x) xs
11:10:53 <danderson> jmcarthur: how would you improve on it?
11:11:32 <danderson> this is my first brush with defining a type class of this complexity, so I'm probably missing completely obvious better ways of doing it. If you have time, please educate me :)
11:11:34 <jmcarthur> danderson: first of all, why does resume require MonadIO?
11:11:44 <wvd> What's the best way to iterate over a list and when I find a certain thing stop iterating and return something? I've got fold now and use `elem`, but that's not really decent I guess.
11:11:50 <brooksbp_> Does anyone have any good resources for learning how to write a type checker for the simply typed lambda calculus?
11:11:52 <brooksbp_> or for System F
11:12:04 <brooksbp_> I haven't found any coding examples
11:12:16 <EvanR-work> wvd: you just want the first element that satisfies the condition?
11:12:38 <jmcarthur> danderson: in fact, please explain resume to be in full
11:12:39 <wvd> EvanR: Or not, I could use a list comprehesion.
11:12:44 <EvanR-work> filter condition list, gives you all of them, which may be empty
11:12:50 <danderson> jmcarthur: mostly because the use case which made me create this type class requires resume to provide some IO-based monad stack.
11:12:54 <wvd> Oh right
11:13:03 <EvanR-work> list comprehension is just a fancy map/filter
11:13:16 <jmcarthur> danderson: what is resume's first parameter?
11:13:32 <danderson> jmcarthur: okay, given the forkIO implementation at the bottom, do you see why I want suspend/resume?
11:14:05 <danderson> Control.Concurrent's forkIO requires me to manually deconstruct/reconstruct a monad stack, if I want to fire off a thread running a computation in the same monad stack as the current thread
11:14:10 <jmcarthur> danderson: i see it, but i don't understand the interface you have chosen. rather than simply propose something i'd like to understand your rational first (i also don't know what to propose at this point)
11:14:16 <jmcarthur> right
11:14:46 <danderson> suspend gives you an opaque blob of saved state from the current monad stack. resume takes a computation in the same monad stack, and a saved state
11:14:55 <jmcarthur> danderson: why did you choose to go with suspend/resume instead of having an overloaded fork instead?
11:14:59 <danderson> and runs that computation using the saved state
11:15:21 <danderson> because suspend/resume also potentially allows for things like rollbacks
11:15:29 <jmcarthur> not for IO
11:15:45 <jmcarthur> which you explicitly require in the type signature of resume
11:15:53 <danderson> true, so the MonadIO requirement breaks that use.
11:16:31 <danderson> okay, so if the MonadIO restriction is lifted, does the use case of being able to roll back state make sense to you?
11:16:45 <danderson> or should I just limit myself to a type class which defines a generic forkIO?
11:17:39 <danderson> I don't actually need the state rollback aspect right now, although it might come in handy for some future configuration reloading code I was thinking of. But my main use case is that I don't want to have to deconstruct/reconstruct monad stacks across forkIO.
11:17:54 <jmcarthur> danderson: while i love generality, if your goal is to be able to fork IO that's been wrapped in transformers then you should just do that
11:18:26 <danderson> but, but, but, it's too specific! :)
11:18:37 <jmcarthur> it's not all that specific
11:18:57 <jmcarthur> i actually like your idea of suspended computations, but i don't think it makes much sense in IO
11:19:03 <danderson> but yeah, you're probably right. That I'm running into the problems I am running into should tell me that the abstraction is leaky
11:20:15 <danderson> okay, so, as a thought exercise, if I were to define the type class for suspended computations, how would I alter my type class, other than the removal of the MonadIO bit?
11:20:37 <danderson> I still need to allow more flexibility in the return value of resume, if it's to be adaptable to all of ReaderT/StateT/ErrorT
11:21:29 <adulteratedjedi> I have been thinking of using haskell to write a DLA (Digital Life assistant) and teach myself more haskell along the way, current knowledge is just using it for configuring xmonad. Is anyone else interested in such a project, trying to think where to start
11:21:35 <jmcarthur> danderson: to do so in a way that is compatible with forkIO might be tough. i'd need to sit on it for a little bit. it's especially difficult right now because i'm writing C code here at work right now
11:21:54 <danderson> heh
11:22:28 <EvanR-work> C code is permanently in IO :)
11:22:49 <danderson> jmcarthur: while compatibility with forkIO would be nice, if it's not, c'est la vie. And I'm not on a tight schedule myself, so when/if you have time and feel like it is fine.
11:23:06 <jmcarthur> danderson: at first glance, it seems to me that what you are doing is capturing the data you would use to "run" that monad
11:23:25 <jmcarthur> :t runState
11:23:26 <lambdabot> forall s a. State s a -> s -> (a, s)
11:23:27 <jmcarthur> :t runReader
11:23:28 <lambdabot> forall r a. Reader r a -> r -> a
11:28:05 <jmcarthur> danderson: suspending and resuming like this is something that typically makes me think of Cont or ContT
11:28:23 <jmcarthur> but i don't think that's what you want
11:33:02 <danderson> jmcarthur: well, something like that, but ContT requires you to explicitly add another layer of transformer to get something that a type class should be capable of doing
11:33:33 <jmcarthur> danderson: well, not, not something that a type class should be capable of doing. they are different things
11:33:37 <jmcarthur> *weel, no
11:33:40 <jmcarthur> i suck
11:33:44 <jmcarthur> *well, no
11:33:56 <danderson> right.
11:34:08 <danderson> but yes, it does feel continuation-ey
11:34:25 <jmcarthur> danderson: but my point is that maybe thinking of it as suspension and resumption is the wrong way to go, as real suspension and resumption is clearly not what you want
11:34:48 <danderson> so it's more like save/freeze and run/thaw, or something.
11:34:57 <jmcarthur> what you want is a way to get out of and back into whatever monad wrapper you're using
11:35:24 <danderson> well, not necessarily out, right?
11:35:27 <jmcarthur> which will of course only work for some monads
11:35:51 <danderson> a way to grab a copy of the monad stack state at some point, and reuse that state on some other computation at another point
11:36:57 <danderson> but I'm no longer sure I see an API for this that actually makes sense to use.
11:37:13 <jmcarthur> popT :: Monad m => t m a -> m (TData t, a)
11:37:20 <danderson> maybe I should let it stew until I have an actual need, rather than just invent solutions in search of problems
11:37:29 <jmcarthur> pushT :: Monad m => m (TData t, a) -> t m a
11:37:33 <jmcarthur> just ideas
11:37:55 <Null-A> So monads can be side effect free, how can you tell from the interface if it is?
11:38:31 <danderson> Null-A: if by side-effects you mean strictly IO, does the monad incorporate IO at its base (if it's a monad transformer stack), or is it an instance of MonadIO ?
11:38:35 <jmcarthur> Null-A: monads themselves abstract side effects. their interfaces are inherently pure
11:38:54 <danderson> if so, it may have side-effects beyond your control as the invoker of monads
11:39:02 <jmcarthur> eh
11:39:16 <jmcarthur> i'd say the most reliable way to tell if it will do IO when you run it is to look at the run function
11:39:29 <Null-A> okay, so it's possible to use a monad in a pure function, but not an IO monad?
11:39:30 <jmcarthur> just because it doesn't expose IO in its type or MonadIO in its constraints doesn't mean it doesn't do IO
11:39:37 <jmcarthur> Null-A: IO is pure
11:39:52 <jmcarthur> Null-A: it's the "run function" (main for IO) that makes the side effects visible
11:39:55 <danderson> jmcarthur: good point.
11:39:59 <Null-A> but can I hide the IO type signature?
11:40:01 <Null-A> in a pure function
11:40:12 <danderson> are you trying to execute side-effects in a pure function?
11:40:27 <Null-A> no, i'm just trying to understand the situation
11:40:29 <jmcarthur> Null-A: your question suggests that you don't really understand what i mean
11:40:36 <Null-A> that seems likely
11:40:48 <EvanR-work> Null-A: you can return IO actions from your function to be executed later
11:40:57 <jmcarthur> Null-A: (IO a) is the type of a pure value. you can manipulate it in pure functions without executing the action it represents
11:41:30 <jmcarthur> Null-A: if, however, you wish for the execution of that action to be a part of your function implementation then your function itself must form an IO action
11:41:49 <Null-A> right
11:42:08 * Null-A thinks
11:42:31 <jmcarthur> Null-A: so (foo >>= bar) is pure. you can even put it in, say, a pure list
11:42:36 <EvanR-work> you cant make IO actions happen because theres no runIO function ;)
11:42:51 <EvanR-work> oh wait, unsafePerformIO ;)
11:42:52 <jmcarthur> EvanR-work: the runtime is the runIO function, and it applies it to main ;)
11:43:01 <jmcarthur> EvanR-work: ssshhhhhhhh. don't say that word
11:43:03 <EvanR-work> haha
11:43:09 <danderson> unsafeFireZeMissiles
11:43:13 <Null-A> if I make my own monad, there's an equivilent run function I have to call?
11:43:24 <bremner> you can make one, depends on the monad
11:43:26 <danderson> Null-A: if you build your own monad, you have to define the function that runs it
11:43:28 <jmcarthur> Null-A: with no run function, you can never escape the monad
11:43:42 <jmcarthur> but "run function" can be loosely defined sometimes
11:43:45 <danderson> or else stay stuck in it, which is not terribly useful in most cases
11:43:46 <bremner> well, e.g. with Maybe, you can pattern match
11:44:02 <bremner> as a way of "escaping the monad"
11:44:04 <jmcarthur> bremner: right. pattern matching fits this loose definition of "fun function"
11:44:09 <jmcarthur> err
11:44:11 <jmcarthur> *run function ;)
11:44:15 <bremner> fun run
11:44:22 <EvanR-work> runction
11:44:30 <jmcarthur> munctional!
11:44:30 <cvic> snakes on a monad
11:44:36 <EvanR-work> lol
11:46:04 <cvic> Version: 6.8.2dfsg1-1ubuntu1 -> I hate this.
11:46:25 <cvic> It's antique
11:47:12 <trofi> current ubuntu should have ghc-6.10 IIRC
11:47:38 <burp> debian has ghc 6.12 in testing
11:47:53 <cvic> lsb_release -r
11:47:55 <cvic> Release:	9.04
11:48:04 <cvic> Yeah, upgrading would be my first step
11:48:14 <cvic> Or just install another distro
11:48:46 <Jafet> apt-get remove ghc && wget a-lovely-mirror/ghc-6.12.1.tar.gz && tar -xzf ghc-6.12.1.tar.gz && pushd ghc-6.12.1 && configure && make && make install && popd
11:48:57 <trofi> cvic: 9.10 likely has 6.10
11:49:21 <cvic> ghc -v
11:49:21 <cvic> Glasgow Haskell Compiler, Version 6.10.4, for Haskell 98, stage 2 booted by GHC version 6.8.2
11:49:30 <cvic> I already installed the latest version
11:49:41 <trofi> nice
11:50:09 <cvic> Yeah, but I'm having problems installing other packages. That want depend on ghc6.8.2
11:50:12 <cvic> Tricky
11:50:21 <cvic> *depend,
11:50:34 <trofi> bad, bad packages! should be fixed
11:50:55 <wvd> Is this a decent function in Haskell terms? http://gist.github.com/371430 (Basically a function which returns wether the number is a prime or not)
11:50:58 <cvic> Don't know about the bad part, but most are ooold
11:51:35 <EvanR-work> the lead developers for ghc work for microsoft? :)
11:51:49 <Null-A> scary thought
11:51:57 <cvic> Conspiracy theory itc
11:52:05 <Null-A> what do you guys think of F#?
11:52:10 <jd10_> microsoft research
11:52:21 <cvic> One thought: it's more interesting than Scala.
11:52:28 <jmcarthur> cvic: yeah, just use cabal-install instead of aptitude
11:52:47 <jmcarthur> jd10_: actually, microsoft research is more involved with Haskell
11:52:48 <cvic> jmcarthur: cabal works. Most of the time
11:52:49 <solrize> f# more interesting than scala?  i thought f# was basically ocaml
11:53:04 <cvic> f# is in the ML family
11:53:10 <jd10_> jmcarthur: than with ghc?
11:53:15 <cvic> Scala is... a mutant
11:53:29 <jmcarthur> jd10_: oh i thought you were responding to the F# thing
11:53:39 <cvic> C++ is to C what Scala is to Java.
11:53:45 <jmcarthur> and i also worded that wrong
11:53:48 <cvic> Scary thought
11:54:01 <jmcarthur> they don't expend more effort on ghc than on f#, or at least i didn't mean to say that
11:54:04 <solrize> "c++ is to c as lung cancer is to lung"
11:54:05 <Null-A> lol, C++ is highly mutated, and mutilated
11:54:17 <Zao> Null-A: And awesome.
11:54:20 <cvic> But people swear on it
11:54:24 <Null-A> Yep, I have to use it at work
11:54:27 <cvic> And use it for voodoo
11:54:33 <jd10_> jmcarthur: nope... i've always thought that microsoft research is kinda different than microsoft although part of the same group / corp.
11:54:43 <jmcarthur> jd10_: right. they basically are
11:54:46 <jmcarthur> as i understand it
11:54:53 <solrize> scala actually seems pretty interesting--maybe evil, but interesting.  f# just seems, well, yawn.
11:55:07 <Null-A> C++ is my most knowledgeable language, the one I've invested the most in, and I agree it's pretty bad, but still feels fun to work with
11:55:10 <jd10_> they've done a good amount of cool research on computer graphics etc.
11:55:31 <Null-A> for beginners F# has nice tools
11:55:32 <cvic> Null-A: C++ is a post-modern programming language. Just like Perl (;
11:55:45 <fax> haskell is better than F#
11:55:49 <jmcarthur> on the one hand, i want to encourage people to use F# because it's a step in the right direction. on the other hand, i want to just slap them in the faces and scream "HASKELL"
11:55:55 <Jafet> Computer graphics belongs forever to xerox parc!
11:55:57 <cvic> f# has a bigger ecosystem
11:56:00 <fax> hahaha
11:56:00 <cvic> So, meh
11:56:02 <k23z__> cvic: what's that supposed to mean ?
11:56:07 <solrize> ndm blogged about comparing f# with haskell and ocaml
11:56:09 <cvic> libraries?
11:56:12 <Null-A> haskell lacks realism... like where's the debugger, now honestly
11:56:20 <fax> THIS IS HASKAAAAAAAAAL
11:56:21 <Null-A> for the markets anyways
11:56:22 <solrize> k23z, f# is well-integrated with .net
11:56:24 <jmcarthur> Null-A: in GHC
11:56:31 <cvic> *potentially* bigger
11:56:34 <Null-A> jmcarthur: ? can I step through code
11:56:41 <k23z__> cvic: I asked you what did you mean about Perl ?
11:56:42 <jmcarthur> Null-A: yes
11:56:47 <EvanR-work> Null-A: debugger? haskell cant have bugs :)
11:56:57 <Null-A> jmcarthur: so it's like gdb? I guess I take it back then..
11:57:05 <Null-A> I didn't think there was a debugger
11:57:09 <Jafet> Null-A, read the ghc manual.
11:57:11 <solrize> ghci has a debugger
11:57:12 <fax> I like how all the F# arguments are totally unspecific terms that aren't anything to do with the actual language
11:57:17 <Mirey> Can anyone help point me in the direction of how to make a function that prints its own definition? I have no idea of where to start.
11:57:21 <solrize> it's not that usable though, imho
11:57:32 <fax> Mirey, lol
11:57:37 <jmcarthur> Null-A: but it's different than you might think. since haskell is non-strict the debugger will hop around as things are evaluated rather than doing things in the sequential, line-by-line order you may be used to
11:57:38 <cvic> Ah, Perl. Well, it was a reference to http://www.wall.org/~larry/pm.html
11:57:41 <fax> Mirey, this is not the sort of thing you ask someone help on
11:57:42 <solrize> mirey, http://en.wikipedia.org/wiki/Quine_%28computing%29
11:57:48 <jmcarthur> Null-A: as such, i don't find debuggers very useful for haskell
11:57:56 <jmcarthur> at least not stepping
11:57:57 <solrize> but yes, you should figure it out yourself
11:58:02 <cvic> Who needs a debugger when you have Haskell
11:58:04 <Jafet> The best debugger is trace
11:58:07 <EvanR-work> > ""
11:58:08 <lambdabot>   ""
11:58:10 <EvanR-work> there ;)
11:58:11 <jmcarthur> agreed
11:58:12 <jmcarthur> trace rocks
11:58:18 <solrize> hmm
11:58:19 <Mirey> Okay. Thanks
11:58:28 <solrize> i never had such good luck with trace either
11:58:52 <EvanR-work> hPutStr "hPutStr "hPutStr "hPutStr "... ;)
11:59:14 <solrize> lol
11:59:25 <jmcarthur> > fix error
11:59:25 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
11:59:33 <solrize> hahaha
11:59:48 <danderson> aside from the transformers in mtl, are there any other interesting ones that I should consider for my improved forkIO?
11:59:53 <cvic> Choose fp. Choose no side effects. Choose monads. Chose Haskell.
11:59:55 <jmcarthur> funny how reading that in english makes it seem that the output is exactly the opposite of what it says
12:00:10 <Null-A> How would you output to log files in a bunch of pure code? pass around a list of log lines?
12:00:15 <solrize> choose space leaks ;)
12:00:24 <Null-A> in any large system, you'd probably want to log fairly often during computations
12:00:31 <EvanR-work> Null-A: theres Writer
12:00:40 <cvic> solrize: yeah, somebody needs to write a book about avoiding those
12:00:52 <jmcarthur> Null-A: you would either pass around a log, use Writer, or not use pure code for that
12:01:09 <jmcarthur> Null-A: you'd be surprised how seldomly you actually want to log the goings on in pure code
12:01:10 <solrize> evanr-work you end up putting your whole program in WriterT IO  or something like that?
12:01:20 <gwern> Big Compiler is watching.
12:01:21 <Null-A> jmcarthur: hmh true
12:01:28 <jmcarthur> Null-A: pure code doesn't really warrant logging ;)
12:01:34 <EvanR-work> solrize: nah, just the parts that you want logging ;)
12:01:46 <BMeph_> fax: Have you done a demotivator poster yet? (This is HAAAAAAAAAASKEEEEEEEEELLL!) :)
12:01:47 <cvic> Lots of Logs == LoL
12:02:43 <Twey> Why do mathematicians like nature parks?  Because of all the natural logs.
12:02:47 <solrize> hehe
12:02:55 <cvic> Hahaa
12:02:57 <Null-A> Do you guys use haskell for any business related tasks?
12:02:59 <jmcarthur> @slap Twey
12:03:00 * lambdabot is overcome by a sudden desire to hurt Twey
12:03:02 <Twey> :-D
12:03:10 <EvanR-work> Null-A: see my name ;)
12:03:28 <jmcarthur> Null-A: i haven't written any major haskell projects at work, but i've used it for various scripting and testing related tasks
12:03:30 <Twey> Null-A: http://cufp.org/
12:03:30 <cvic> Remembered about http://img689.imageshack.us/img689/5373/eff.png
12:03:33 <jmcarthur> and i've also prototyped with it
12:03:38 <cvic> Good stuff
12:03:45 <Null-A> EvanR-work: your whole company?
12:03:51 <EvanR-work> no, a sub project
12:03:56 <jmcarthur> i work with a bunch of linux kernel hackers though, so haskell isn't the most culturally appropriate technology to use around these parts :(
12:03:58 <Null-A> Twey: thanks
12:04:03 <solrize> i've used haskell at work but not for anything really substantial
12:04:10 <EvanR-work> we are using haskell database interface, smtp client, and adns
12:04:16 <danderson> jmcarthur: haskell and kernel code? Interesting mix. Where do you work?
12:04:20 <jmcarthur> google apparently is using haskell for a few things
12:04:22 <cvic> And it seems that Google is using Haskell for various
12:04:28 <jmcarthur> danderson: there's actually a way to write kernel modules in haskell
12:04:28 <cvic> Haha, all in one mind
12:04:32 <Null-A> cvic: really, link?
12:04:35 <cvic> One sec
12:04:36 <danderson> yes, we do use haskell in places.
12:04:40 <danderson> not enough places.
12:04:44 <danderson> I'm working on it :P
12:04:46 <Null-A> I did an internship at google, didn't see much FP
12:04:50 <cvic> 20:21 < cvic> Now this is interesting http://www.reddit.com/r/programming/comments/bm1u8/safe_robust_programming_practices_in_haskell_via/c0nqcn2
12:05:05 <danderson> (not really, other than evangelism, my day job is work enough atm)
12:05:05 <cvic> Now that was a mini-flame-fest
12:05:39 <cvic> Those Ocaml guys are bitchy
12:05:41 <Jafet> Why is it always google, linux, or my-little-office
12:05:42 <Null-A> cvic: this article states google uses haskell?
12:05:42 <danderson> Null-A: an early version of Wave's OT implementation was in haskell
12:05:47 <solrize> cvic, you mean jdh30?  :)
12:05:50 <gwern> Null-A: quick, go tell harrop how little fp or haskell you saw at google!
12:05:52 <cvic> Exactly
12:05:52 <Jafet> It smells of hype
12:05:55 <BMeph_> wvd: your function is too wordy. Think about how you could do it in half the space. ;)
12:05:58 <cvic> It smells of... meh
12:06:03 <cvic> Just rumours
12:06:06 <jmcarthur> cvic: jdh30 is financially motivated to bash haskell
12:06:06 <gwern> then harrop can drown in a spoonful of water
12:06:11 <danderson> there is also <censored> and <censored> that use haskell extensively
12:06:24 * gwern is trying new idioms from http://www.lefthandedtoons.com/714/
12:06:28 <Null-A> danderson: *nods* I vaguely remember hearing that, still I don't believe wave has a single production line
12:06:30 * cvic shrugs 
12:06:34 <danderson> and Ganeti (our open source mini-cluster management system) uses Haskell to load-balance the cluster
12:07:42 <cvic> And speaking of Google Wave, have you used it by now?
12:08:05 <k23z__> I'd like to learn how to eliminate recursion in a program
12:08:08 <Null-A> I think the problem with businesses like google which build distributed systems, is there's so much networking interfacing going on, that side effects are rampant, you can only build pure functions to an extent..
12:08:11 <k23z__> is there a paper I could read on that ?
12:08:23 <k23z__> by eliminating recursion I actually mean writing my own stack ...
12:08:24 <Null-A> cvic: sure
12:08:27 <pikhq> k23z__: Impossible.
12:08:30 <jmcarthur> Null-A: quite the contrary. side effects are precisely what haskell is good for
12:08:33 <pikhq> Oh, you mean "writing your own stack".
12:08:39 <k23z__> pikhq: yes
12:08:46 <jmcarthur> Null-A: haskell is one of the only languages i know of that gives you such explicit control over side effects
12:08:49 <pikhq> That is called "implementing a call stack".
12:08:57 <Peaker> dcoutts: thanks
12:09:00 <k23z__> pikhq: yes I would like to study that please
12:09:04 <pikhq> Uh... I'm not sure of *specific* links.
12:09:09 <cvic> Null-A: I heard about a Haskell hackathon on Google Wave. With 100+ people
12:09:12 <cvic> That's cool
12:09:16 <solrize> k23z__ are you asking about continuation passing style?  that is explained in SICP
12:09:19 <pikhq> Probably just about any book on compilers?
12:09:20 <solrize> @where sicp
12:09:20 <lambdabot> http://mitpress.mit.edu/sicp/
12:09:32 <pikhq> solrize: C-style function semantics, it seems more like.
12:09:35 <solrize> that is the generalized form of tail recursion elimination
12:09:40 <pikhq> Which should be in, really, *any* book on compilers.
12:09:41 <solrize> oh, i see
12:09:47 <cvic> This is also cool http://jonathan.tang.name/files/scheme_in_48/tutorial/overview.html
12:09:47 <k23z__> solrize: no, I just want to implement my own stack instead of using the system stack
12:09:50 <solrize> yeah, SICP explains that too
12:09:58 <k23z__> solrize: yes ?!
12:10:10 <k23z__> solrize: was your last reply aimed at me ?
12:10:10 <solrize> yeah, you should read that book on general principles
12:10:20 <solrize> k23z, yes, read SICP, it will do you good ;)
12:10:22 <k23z__> solrize: what book on general principles ?
12:10:25 <Jafet> The question of what a stack is becomes important when you introduce continuations
12:10:34 <gwern> I sometimes think a CS degree could be replaced by reading Alice in Wonderland, GEB, and SICP
12:10:39 <Null-A> jmcarthur: Well you get control over it, but the benefits of 'proving' are reduced significantly
12:10:40 <solrize> gwern :)
12:10:55 <gwern> solrize: you think I am joking
12:10:57 <cvic> gwern: true
12:11:03 <Null-A> jmcarthur: even something like a sorting algorithm get's distributed between many different applications
12:11:05 <k23z__> gwern: I have a friend reading GEB, he's completely fascinated by it, I on the other hand think it's popular science
12:11:08 <solrize> @remember gwern I sometimes think a CS degree could be replaced by reading Alice in Wonderland, GEB, and SICP
12:11:08 <lambdabot> It is forever etched in my memory.
12:11:18 <gwern> but I assure you, I am not.
12:11:19 <k23z__> gwern: although I have heard many time SICP recommended so I would thank that's correct
12:11:44 <pikhq> gwern: That should cover many important chunks, yes.
12:11:47 <Jafet> GEB has even less substance than SICP. I would take Gardner any day
12:11:47 <Null-A> jmcarthur: I guess I'm reaching a little, there's probably better reasons to explain why haskell isn't the best choice for google
12:11:47 <gwern> k23z__: GEB is the very best popular science. I wouldn't recommend it for college-age peeps, but it's terrific for middleschool and highschoolers
12:11:49 <jmcarthur> Null-A: you can't really prove a whole lot in haskell like you can with a theorem prover anyway. ability to reason about code easily is an important feature of haskell, but proofs are another story
12:11:51 <pikhq> At least enough to make self-study quite viable.
12:12:07 <jmcarthur> Null-A: i will strongly disagree with whatever you come up with ;)
12:12:11 <gwern> of course, one of the good things about SICP is all the ancillary resources for studying it
12:12:12 <Null-A> jmcarthur: performance
12:12:19 <danderson> Null-A: actually, I think haskell might be very nice for distributed systems, although I don't have a lot of proof. Despite the stigma, it's okay to have lots of code living in IO if you're implementing an I/O heavy network server
12:12:34 <gwern> the MIT quiz site, the IRC channel, the free PDFs/HTML pages, the free Scheme implementations etc
12:12:42 <jmcarthur> Null-A: haskell is also used to generate C a lot
12:12:47 <jmcarthur> Null-A: see Atom, for example
12:12:49 <Null-A> jmcarthur: binaries which are slower by a factor of 2 basically eat their entire ad sense margins
12:12:54 <danderson> and the pure parts would really really gain from aggressive compiler optimization and QuickCheck property testing
12:13:09 <jmcarthur> Null-A: factor of 2 is not realistic
12:13:24 <jmcarthur> Null-A: i generally see a slowdown of around 10% or 15% compared to C
12:13:28 <Null-A> jmcarthur: you don't that represents haskell's performance when compared to hand tuned C++?
12:13:36 <jmcarthur> Null-A: and that's accounted for by the garbage collector!
12:13:36 <cvic> Haskell is used to generate ASM code. Check this out http://lambda-the-ultimate.org/node/3147
12:13:37 <Jafet> Haha C++
12:13:39 <k23z__> solrize: so SICP describes implementing your own call stack right ?
12:13:40 <cvic> Coconut
12:13:43 <zygoloid> gwern: "The name of the poem is called 'Haddock's eyes'."
12:13:53 <pikhq> Null-A: Rarely is C or C++ going to be "hand-tuned for performance".
12:13:54 <tromp_> :t showIntAtBase
12:13:55 <solrize> k23z yes, it explains how compilers work in general
12:13:55 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
12:13:59 <k23z__> solrize: so it's worth learning a whole new language just to read SICP ?
12:14:09 <Mirey> :t reverse
12:14:10 <lambdabot> forall a. [a] -> [a]
12:14:12 <pikhq> The normal trick in *C* is "write it cleanly, do low-level stuff to make important chunks faster".
12:14:15 <solrize> k23z, scheme is pretty simple and yes you should learn it
12:14:15 <danderson> Null-A: as an engineer currently working for google, I'd like to point out that not all code is on the serving path for Google Search queries
12:14:18 <Null-A> pikhq: at google this happens more often than you think, because of the small margins
12:14:28 <gwern> k23z__: scheme really is easy to learn. if you know haskell, you know most of scheme
12:14:32 <pikhq> And the normal trick in most other languages is "write it cleanly, link with C, then do low-level stuff to make important chunks faster."
12:14:34 <tromp_> > showIntAtBase 8 showDigit 1161 ""
12:14:35 <lambdabot>   Not in scope: `showDigit'
12:14:39 <danderson> there is a whole mass of code that is infrastructure, batch etc.
12:14:41 <Jafet> Null-A, what do you know about google?
12:14:46 <danderson> where latency is not a major factor
12:14:53 <tromp_> @hoogle Int->Char
12:14:54 <lambdabot> Data.Char chr :: Int -> Char
12:14:54 <lambdabot> Data.Char intToDigit :: Int -> Char
12:14:54 <lambdabot> Data.ByteString.Char8 index :: ByteString -> Int -> Char
12:14:56 <Null-A> danderson: *nods* and of course hence the use of python, etc
12:14:59 <pikhq> Null-A: Yes, I'd imagine Google has more low-level tricks going on than is the norm.
12:15:01 <cvic> Google - there be Dragons
12:15:03 <tromp_> > showIntAtBase 8 intToDigit 1161 ""
12:15:04 <lambdabot>   "2211"
12:15:11 <danderson> youtube runs frontend server code in Python, that's the prime example
12:15:25 <danderson> if they can use youtube to serve one of the biggest sites on the web, haskell definitely has a place
12:15:36 <Null-A> ah really, I didn't know they had frontend python
12:15:47 <tensorpudding> Wait, Youtube uses Haskell?
12:16:02 <pikhq> tensorpudding: No, Python.
12:16:05 <danderson> there are always tradeoffs going on: if you waste 10% of CPU, but develop new features in a month instead of 6, that would probably be a win, because you can then spend 5 months optimizing what you have iteratively
12:16:11 <tensorpudding> Oh, then what's the deal?
12:16:18 <cvic> Google uses: C++, Java, Javascript, Python
12:16:21 <Null-A> aren't there ways to limit python functionality to speed up python performance significantly? and does google do this?
12:16:24 <cvic> Those are the major languages, no?
12:16:25 <danderson> tensorpudding: no, python. I was using youtube as an example of places where Google scales just fine despite not using hand-tuned C++.
12:16:25 <pikhq> Google doesn't use it because Google doesn't use it.
12:16:30 <Null-A> the computer language shootout benchmarks for python are hysterical
12:16:37 <sykopomp> cvic: I think those are the _only_ languages allowed.
12:16:50 <cvic> Exactly
12:16:53 <danderson> sykopomp: no. There are more. But those are the major ones.
12:16:54 <cvic> And I understand why
12:16:54 * Twey wants an Integral a => showFloatAtBase (radix :: a) (digits :: a -> String) (separator :: String) (number :: a) (tail :: String) :: String
12:16:54 <pikhq> sykopomp: Perhaps for production stuff.
12:16:55 <tensorpudding> I thought that was obvious? (that languages other than C++ can scale that high)
12:16:58 <jmcarthur> performance critical C seems like it would be a very minor thing at google to me, actually. aren't they so much more concerned about scalability?
12:17:03 <pikhq> 20% time stuff is *probably* fair game.
12:17:21 <danderson> pikhq: we do have haskell code on real 80% prod code as well
12:17:24 <sykopomp> pikhq: I meant for production. I'm sure some random projects happen to use more obscure languages, and it's not like Google is lacking in the language nerd department.
12:17:29 <pikhq> danderson: Good to know.
12:17:30 <danderson> a tiny fraction compared to other languages, but it is there.
12:17:40 <sykopomp> danderson: ah okay.
12:18:08 <Null-A> jmcarthur: I don't follow, increased scalability can be gained by improving performance of code, as one of the factors
12:18:18 <tensorpudding> Haskell's still too niche for use at a site as big as Youtube.
12:18:19 <cvic> Guido van Rossum works for Google. Go figure
12:18:29 <gwern> cvic: he has to work somewhere
12:18:34 <Jafet> ghc is still too undeveloped.
12:18:36 <benmachine> tensorpudding: doesn't facebook use some?
12:18:40 <danderson> so, if you want the real insider scoop on why haskell is not used more inside google
12:18:48 <gwern> Jafet: what's undeveloepd about ghc?
12:18:50 <pikhq> Null-A: Google does scalability by making it so you can literally throw more machines at a problem.
12:18:51 <jmcarthur> Null-A: i mean scaling horizontally
12:18:54 <tensorpudding> I don't know about that.
12:19:02 <danderson> here we go: mostly, it's a question of inertia
12:19:03 <Jafet> Although, I'm not sure how they cope with cpython, if that's what they use.
12:19:17 <Null-A> danderson: not sure if you can discuss.. but what's been the uptake of go internally..
12:19:21 <Jafet> gwern, for clustering and distributed things
12:19:22 <danderson> all engineers at google know Java/C++/Python to some extent, and thus can apply their brains to most of the codebase
12:19:29 <pikhq> And by making it very, very, *very* easy to throw machines at things.
12:19:31 <jmcarthur> Null-A: a 10% performance hit means you just need 10% more machines, in a completely horizontally bound system
12:19:45 <gwern> Jafet: is that really ghc's concern?
12:19:56 <tensorpudding> What is GHC's concern?
12:19:59 <danderson> comparatively very few (still a lot compared to the general programming population, but few) know haskell
12:20:17 <danderson> so, there is the concern of creating code silos that only a select few understand
12:20:18 <Jafet> gwern, simon says so!
12:20:19 <Null-A> jmcarthur: It's partly a matter of trade offs between engineer time cost and additional resource cost
12:20:22 <Jafet> (I forget which simon)
12:20:26 <danderson> which is dangerous for long-lived code that has to be maintained as people move on.
12:20:27 <cvic> I doubt Google will push Haskell forward.
12:20:32 <cvic> Simpon Python Jones?
12:20:34 <Null-A> jmcarthur: at their scale, over optimizing certain code areas is more cost effective
12:20:38 <cvic> *Simon
12:20:47 <Jafet> cvic, well done
12:20:52 <danderson> Null-A: you're conflating two things. One is latency, the other is scalability.
12:20:56 <jmcarthur> Null-A: at google they are almost always willing to focus on horizontal scaling over vertical scaling, would be my guess
12:21:05 <danderson> For ridiculously low latency response, hand-tuned C++ can sometimes be the way to go.
12:21:22 <danderson> for scalability, C++, Java and Python just get in the way, frankly.
12:21:24 <cvic> C++, fugly, but gets the job done
12:21:29 <jmcarthur> Null-A: they have a philosophy of using tons of cheap hardware rather than just a few more expensive machines, for example
12:21:37 <cvic> Yah, Google should use Erlang
12:21:48 <cvic> For fun and prophet.
12:22:21 <jmcarthur> yeah i've always thought that erlang seemed a very googly language and wondered why it wasn't one of their big four
12:22:38 <drk-sd> cvic: :D
12:22:40 <cvic> Google Language == mature, lots of docs
12:22:47 <cvic> And stuff
12:22:54 <danderson> brb, but I can keep ranting in a bit :)
12:22:54 <drk-sd> jmcarthur: they don't need erlang, they've Go
12:22:54 <solrize> do they use Go much?
14:23:03 --- topic: '["Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/", "RIP Robin Milner"]'
14:23:03 --- topic: set by Pseudonym!~ajb@torchwood.alicorna.net on [Tue Mar 23 22:11:43 2010]
14:23:42 <ddarius> > let a ^ n = mconcat (replicate n a) in "hi"^10
14:23:42 <lambdabot>   "hihihihihihihihihihi"
14:24:43 <fax> > x^3
14:24:44 <lambdabot>   x * x * x
14:24:46 <fax> > x^8
14:24:46 <lambdabot>   x * x * (x * x) * (x * x * (x * x))
14:24:53 <fax> damn
14:25:09 <fax> > let (*) = (+) in x^8
14:25:10 <benmachine> damn?
14:25:10 <lambdabot>   x * x * (x * x) * (x * x * (x * x))
14:25:17 <fax> no way to get the sharing out of this
14:25:26 <benmachine> what are you talking about
14:25:31 <fax> haskell
14:25:41 <benmachine> well yes I assumed that
14:27:03 <gwern> fax: does doing that let really redefine * inside the definition of ^?
14:27:12 <benmachine> ...no
14:27:39 * gwern didn't think it would. maybe in a lisp...
14:27:45 <hpaste>  Suspendability (dankna)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24954
14:27:53 <Cale> > map (toEnum . (+ fromEnum 'h') . fromEnum . head) . transpose . iterate (\xs -> xs ++ map not xs) $ [False] :: String
14:27:54 <lambdabot>   "hiihihhiihhihiihihhihiihhiihihhiihhihiihhiihihhihiihihhiihhihiihihhihiihhi...
14:28:00 <fax> > let (>>) = (+) in do 3 ; 4 ; 5
14:28:01 <lambdabot>   No instance for (GHC.Num.Num (m b))
14:28:01 <lambdabot>    arising from the literal `5' at <int...
14:28:05 <dankna> A difficult question...  I believe I understand why I get the errors in the linked paste, but what can I do about them?
14:28:54 <dankna> My understanding is that the compiler is (correctly) determining that it's not the same type for the two occurrences of innerResult and outerResult, and complaining.
14:29:47 <dankna> you'll notice that it works fine for the instances on plain monads, but the instances on monad transformers cause trouble
14:30:01 <ra1m0> how to implement logging in haskell programs?
14:30:32 <ra1m0> do I have to use IO on my otherwise pure functions to do logging
14:30:33 <EvanR-work> log, log, its big its heavy its wood
14:30:47 <EvanR-work> log, log, its better than bad, its good
14:30:49 <Berengal> @type log
14:30:50 <Cale> ra1m0: You have to do IO at the top level to log things.
14:30:50 <lambdabot> forall a. (Floating a) => a -> a
14:30:54 <jutaro> ra1m0: try the hslogger package
14:31:19 <EvanR-work> ive heard the Writer monad is cool
14:31:30 <benmachine> you've heard correctly!
14:31:38 <dankna> nobody? :(
14:32:00 <dankna> well, I know it's a hard problem :/
14:32:55 <aep> the stuff on hackage is release versions, is it?
14:33:02 <ra1m0> hslogger seems very neat
14:33:05 <tromp_> > showIntAtBase 8 intToDigit  38033 ""
14:33:06 <lambdabot>   "112221"
14:33:31 <jmcarthur> aep: many packages explicitly state their stability
14:33:35 <aep> ah
14:33:40 <jmcarthur> aep: but hackage is not just for mature packages
14:33:47 <aep> can i install only packages that actually compile?
14:34:01 <ra1m0> so I have to break my pure crunching functions to return the control to top level once in a while to do logging
14:34:03 <jmcarthur> aep: how would you install packages that don't compile?
14:34:21 <aep> i dunno. whenever i use cabal install, half of packages are broken
14:34:41 <aep> maybe there is a --stable switch
14:34:46 <jmcarthur> aep: a lot are. what version of ghc are you using?
14:35:03 <aep> 6.12.1
14:35:40 <ra1m0> should I create a monad that my custom functions use to store the logging data that I will later really log on top level IO code?
14:35:50 <jmcarthur> 6.12.1 is not officially considered mature, but the root of the problem is probably more the immaturity of a lot of hackage packages, not ghc specifically
14:36:05 <monoidal> anyone installed lambdabot on 6.12.1?
14:36:22 <aep> so, no stable switch? :(
14:36:27 <jmcarthur> aep: 6.10 might have better luck with hackage if it's convenient for you (but i just use ghc 6.12.1 and deal with it, personally)
14:36:37 <benmachine> livin' on the edge
14:36:41 <aep> i dont know HOW to deal with it
14:36:52 <jmcarthur> aep: if it's a dependency chasing issue it's pretty easy to just get a local copy of the package and edit the .cabal file
14:37:04 <jmcarthur> aep: you can use cabal unpack to get a local copy of the package source
14:37:17 <jmcarthur> aep: sometimes the issue is deeper than that though
14:37:25 <benmachine> cabal unpack package && cd package-version && fix package.cabal && cabal install
14:37:29 <benmachine> sorted
14:37:31 <orlandu63> i'm reading the Parsec docs and i came across this:
14:37:33 <jmcarthur> aep: what packages are failing for you?
14:37:34 <aep> for example containers-0.2.0.1  fails to install. cabal whines about lack of base in build deps. but its there. i dont see whats wrong
14:37:50 <orlandu63> data Consumed a = Consumed a | Empty !a
14:37:51 <blackh> ra1m0: Here's a suggestion: Make your crunching code have this type:  crunch :: (String -> m ()) -> WhateverIn -> m WhateverOut
14:37:54 <gwern> aep: containers
14:37:57 <orlandu63> what does the (!) operator do?
14:37:57 <gwern> ?
14:38:07 <gwern> you shouldn't be installing containers, I don't think
14:38:08 <monoidal> array subscript
14:38:12 <gwern> @hoogle (!)
14:38:12 <lambdabot> Data.IntMap (!) :: IntMap a -> Key -> a
14:38:12 <lambdabot> Data.Map (!) :: Ord k => Map k a -> k -> a
14:38:12 <lambdabot> Text.Html (!) :: ADDATTRS a => a -> [HtmlAttr] -> a
14:38:15 <aep> gwern: thats the package name. i dont know what that is.
14:38:19 <chrisdone> if i have a function that needs a value of an instance passed as an argument to get an instance for the function, is that called a witness?
14:38:22 <monoidal> orlandu63: um, that's strictness
14:38:23 <blackh> ra1m0: Or better still, use a typeclass, like this:
14:38:35 <chrisdone> like bob :: Typeable a => a -> a
14:38:36 <Cale> orlandu63: In a datatype declaration, it's a strictness annotation, not an operator.
14:38:37 <benmachine> aep: I think it might be a core GHC library
14:38:38 <gwern> aep: containers is a core package. at least on 6.10 and lower, reinstalling core packages could lead to major problems
14:38:39 <blackh> ra1m0: Loggable m => WhateverIn -> m WhateverOut
14:38:47 <orlandu63> i see
14:38:57 <aep> happstack depends on it. hm lemme check the chain
14:39:06 <Cale> orlandu63: It means that whenever that constructor is pattern matched on, to force the evaluation of that field as well.
14:39:10 <monoidal> orlandu63: data X a = Y a is essentially equivalent to newtype
14:39:20 <monoidal> * (Y !a)
14:39:23 <fax> equivalent in what sense ?
14:39:26 <Cale> monoidal: not really, no
14:39:34 <blackh> ra1m0: The point of this is that even though you are writing your code in a monadic way, it is still completely pure except for the logging function.  You could use the Identity monad for m and then it is pure.
14:39:38 <hpaste>  . (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24955
14:39:45 <Cale> In fact, it's almost an opposite to newtype's behaviour
14:40:07 <aep> gwern: http://codepad.org/2OiPeR4w
14:40:28 <monoidal> hm. Isn't data X = X (!Integer) essentialy newtype X = X Integer?
14:40:31 <Cale> no
14:40:41 <gwern> aep: do you have a containers installed?
14:40:42 <monoidal> ah, right
14:40:44 <gwern> ghc-pkg list
14:40:47 <blackh> ra1m0: If your logging is for debug only, of course you can just leave it as is and use Debug.Trace.
14:40:55 <aep> gwern: yes
14:41:00 <benmachine> > case undefined of Endo _ -> 4
14:41:01 <lambdabot>   4
14:41:09 <Cale> Suppose we have  newtype N = N Integer and  data D = D !Integer, and we write  case undefined of N x -> 5  No evaluation has to be done to determine if it matches, and the result is 5
14:41:20 <jmcarthur> aep: either you can change the happstack dependencies to use a newer containers or you can change the containers.cabal file to specify the base version explicitly
14:41:21 <monoidal> yes, thanks
14:41:21 <gwern> aep: what version? happs-tutorial says 'containers  (≥0.2.0.0 & <0.3.0.0)'
14:41:34 <aep> 0.3.0.0
14:41:41 <gwern> well, there's you problem
14:41:48 <aep> i need to remove that first?
14:41:51 <Cale> But with case undefined of D x -> 5, it will evaluate to decide if the pattern matches, and because of the strictness annotation even case D undefined of D x -> 5 will fail
14:41:51 <jmcarthur> no
14:42:01 <jmcarthur> you can have multiple versions of the same package installed
14:42:10 <jmcarthur> aep: either you can change the happstack dependencies to use a newer containers or you can change the containers.cabal file to specify the base version explicitly
14:42:20 <aep> uuh
14:42:35 <ra1m0> blackh: I was actually wondering how to do configurable logging when it's a feature and not a development tool and your suggestion seems perfect for my problem
14:42:41 <gwern> jmcarthur: yeah, you can have multiple versions if you don't mind the risk. aep should not be installing multiple containers
14:42:52 <jmcarthur> gwern: what risk?
14:43:04 <gwern> jmcarthur: diamond dep, is it not? I ran into that so often with bytestring
14:43:25 <jmcarthur> gwern: eh, i guess that can happen
14:43:34 <jmcarthur> i haven't seen it happen with containers though
14:43:40 <aep> i think i'll just clean my ~/.ghc
14:43:48 <jmcarthur> aep: that won't help
14:43:52 <aep> damn
14:43:55 <Cale> ra1m0: But what is your code doing logging things in the middle of a pure computation anyway? :)
14:44:10 <jmcarthur> aep: the happstack stuff is specifying the older containers, but the older containers doesn't specify the up to date base that's required
14:44:11 <blackh> ra1m0: This "creeping monadification" is one of the things that the Disciple people are trying to solve, but that's a completely new experimental language, so it'll take a while.  But it's not so bad in Haskell if you restrict your type - the code doesn't lose any purity - it just looks a little uglier.
14:44:13 <jmcarthur> you will have to edit something
14:44:17 <aep> containers compiles with an explicit base version.
14:44:25 <Cale> ra1m0: Note that another option is just to produce a (lazy?) list of logging output along with its usual result.
14:44:37 <aep> jmcarthur: complicated >_<
14:44:37 <gwern> I think you'd be better off just editing happs-tutorial and adding a <=
14:44:48 <jmcarthur> i agree with gwern
14:44:55 <hpaste>  . (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24956
14:44:56 <aep> gwern: for base?
14:45:02 <jmcarthur> aep: for containers
14:45:03 <roconnor> ... or you could have used a monad
14:45:09 <benmachine> don't use <=
14:45:12 <benmachine> just use < 0.4
14:45:15 <jmcarthur> yeah
14:45:16 <aavogt> linear implicit parameters
14:45:23 <Cale> heh
14:45:31 <aep> jmcarthur: my guess is, it wont compile with 0.3 if it doesnt say so :D
14:45:36 <gwern> benmachine: <= would work though since 0.3.0.0 was the upper bound and exactly the one aep has
14:45:43 <jmcarthur> aep: it will compile i bet
14:45:48 <jmcarthur> and work
14:45:51 <aep> okay i'll try. thanks
14:45:51 <gwern> aep: try it and see. containers doesn't change that much
14:46:04 <jmcarthur> aep: containers didn't see very sweeping changes in that version bump iirc
14:46:05 <benmachine> gwern: won't work for anything else though :P
14:46:15 <ddarius> blackh: The rising popularity of the Applicative class also mitigates some of the syntactic burden.
14:46:17 <gwern> benmachine: make as few changes as necessayr...
14:46:57 <jmcarthur> my preferred way to specify dep versions in .cabal files now is the form:  containers == 0.3.*  ... at least by default
14:47:13 <jmcarthur> once you cross multiple major version numbers though that won't work
14:47:26 <blackh> ddarius: I was thinking about that. How would you do ra1m0's logging thing with Applicative?
14:47:35 <benmachine> jmcarthur: not compatible with GHC 6.8 though
14:47:46 <Eelis> glguy: do you have any tentative plans to release utf8-string 0.3.7, or won't that happen until more substantial changes are made?
14:47:47 <benmachine> (nor is anything else interesting :P)
14:47:47 <jmcarthur> benmachine: nothing i write is ghc 6.8 compatible anyway ;)
14:48:07 <benmachine> yeah I wouldn't care except my webhost is still on ancient things
14:48:10 <ddarius> blackh: Even if you use a monad, you can still use the applicative combinators in many cases.
14:48:33 <jmcarthur> benmachine: my entry in the google ai challenge was severely crippled because the server running the contest only had ghc 6.8.2 :(
14:48:39 <Eelis> glguy: thanks for committing my patch by the way!
14:48:52 <gwern> @wn truckle
14:48:54 <lambdabot> *** "truckle" wn "WordNet (r) 2.0"
14:48:54 <lambdabot> truckle
14:48:54 <lambdabot>      n : a low bed to be slid under a higher bed [syn: {trundle bed},
14:48:54 <lambdabot>           {trundle}, {truckle bed}]
14:48:54 <lambdabot>      v 1: yield to out of weakness
14:48:56 <lambdabot> [3 @more lines]
14:49:00 <blackh> ddarius: Right - I see.  I think you do need the type to be a monad, otherwise you can't use IO.
14:49:15 <ddarius> blackh: Who says you have to use IO?
14:49:45 <blackh> ddarius: Well, if you wanted the caller to have the option of using IO you would need the type to be Monad m => ... m ()
14:50:18 <Cale> logging doesn't necessarily require immediate I/O
14:50:23 <ddarius> blackh: I don't really know what all of the requirements are.
14:50:33 <gwern> well. this is entertaining. in asm, 'mul' puts the result in the ax register if you chose an 8-bit quantity, dx & ax if 16 bit, and edx and eax if 32 bit.
14:50:55 <blackh> ddarius: Just to do logging in otherwise pure code without resorting to Debug.Trace
14:51:05 <gwern> and I was just telling myself that assembly wasn't too bad
14:51:06 <DevHC> > sp4m
14:51:07 <lambdabot>   Not in scope: `sp4m'
14:51:12 * benmachine pokes DevHC in the eye
14:51:13 <ddarius> blackh: As Cale said, logging doesn't immediately require IO.
14:51:22 <DevHC> ohai
14:51:31 * benmachine is somewhat surprised that sp4m is a single identifier
14:51:36 <ddarius> gwern: That's the x86 and it makes sense and it isn't too uncommon for assembly languages to do similar things.
14:51:36 <benmachine> oh no of course it is
14:51:39 <benmachine> as in
14:51:43 <benmachine> > writeList2Chan
14:51:49 <benmachine> ...
14:52:00 <lpsmith> blackh, SML is prone to "reference creep" as well :)
14:52:01 <benmachine> @botsnack
14:52:04 <ddarius> gwern: However, if that really bothers you, you can abuse the FPU or the SIMD instructions.
14:52:13 <benmachine> that wasn't me was it
14:52:20 <gwern> ddarius: I'm not up to those yet
14:52:51 * gwern guesses I'll just have to memorize the implicit operands for mul
14:53:06 <blackh> ddarius: Laziness is an option if it's a long-running computation and you want logging to happen as it runs, but that gets you into lazy IO which I think is worse than Monad m => .. m ()
14:53:26 <ddarius> gwern: The x86 is probably the worst remotely common architecture that has crazy limited operations like that.
14:53:29 <jmcarthur> huh?
14:53:32 <benmachine> blackh: not necessarily lazy IO
14:53:39 <benmachine> lazy list generation
14:53:42 <gwern> ddarius: worse is better, I guess
14:53:50 <gwern> x86 won and that's that
14:53:50 <benmachine> lazy construction of a [String]
14:53:54 <jmcarthur> blackh: you can just have a lazily evaluated, pure log which is evaluated at the top level
14:54:00 <benmachine> or a String even
14:54:12 <jmcarthur> which is not lazy IO
14:54:53 <jmcarthur> Writer :)
14:55:00 <jmcarthur> pretty nice with dlist
14:56:58 <ddarius> gwern: x86 won for desktops.
14:57:24 <sykopomp> hm. Is there a term for type systems like Haskell's that emphasize type-class-like things, as opposed to classic OO?
14:57:29 <Eridius> x86_64 is supplanting x86 though
14:57:30 <dolio> For servers, it's all Itanium!
14:57:42 <gwern> itanium forever! the dream will never die
14:57:57 * cvic arm ftw 
14:58:00 <ddarius> gwern: Really, the crazy limited opcodes are annoying for compiler code generation, but aren't that bad for a human.  The limited register file, though, is really a pain for both compiler and human.
14:58:09 <gwern> next year in jerusalem, my OS/2 comrades
14:58:13 <tromp_> > showIntAtBase 8 intToDigit  174696138  ""
14:58:24 <cvic> OS/2 is making a comeback, I tell ya
14:58:54 <gwern> ddarius: the limited number of registers already worries me. looks like one has to do a lot of shuffling in and out of ram
14:58:59 <shepheb> VMS really is back, but with different names and a lot more RAM.
14:59:11 <ddarius> NC4000 all the way
14:59:20 <cvic> We're ramming VMS up your throat
14:59:21 <jmcarthur> sykopomp: sane?
14:59:29 <jmcarthur> ;)
14:59:30 <shepheb> cvic: up it from the inside?
14:59:37 <cvic> Ofc
14:59:42 <sykopomp> jmcarthur: ;)
15:00:00 <sykopomp> but seriously, I see more and more type systems that at least pretend to be somewhat like this.
15:00:08 <sykopomp> Go's seems to be that way, for example.
15:00:20 <sykopomp> So I'm wondering what this is called, if anything.
15:00:32 <jmcarthur> sykopomp: sometimes we consider type classes to be apart from the type system, just calling them constraints
15:00:38 <lpsmith> Burroughs MCP forever!
15:00:40 <jmcarthur> i don't know if that is what you are looking for
15:00:56 <sykopomp> hmm
15:01:03 <dolio> I don't remember Go's type system being very much like Haskell's.
15:01:06 <ddarius> gwern: Most opcodes being able to directly access memory mitigates the limited register file somewhat, but it's still annoying.
15:01:10 <gwern> (bleh. so for mul, I need to memorize 9 things; the hardwired second argument's location, the result, and what bit length that's valid for)
15:01:47 <ra1m0> where can I find an explanation of applicative functors for stupid people?
15:01:56 <ddarius> gwern: You'll probably only ever use 32-bit multiplies, you'll often not care about the overflow, and the registers used are the "obvious" registers.
15:01:59 <sykopomp> dolio: its interfaces make me think of Haskell's type classes.
15:02:03 <jmcarthur> sykopomp: or rather, the part of type classes that plays a role in type checking is constraints
15:02:04 <gwern> ddarius: they're not obvious to me!
15:02:06 <fax> ra1m0: applicative functors are a really special kind of functor which is nice and very useful
15:02:14 <jmcarthur> eh, a lot of languages have interfaces, but interfaces are not type classes
15:02:15 <EvanR-work> ddarius: baloney
15:02:25 <EvanR-work> ddarius: i would like to have the overflow for my rng
15:02:38 <jmcarthur> *not necessarily type classes
15:02:41 <lpsmith> ra1m0, I just follow the types;  if you understand monads,  you can start introducing things such as <$> into your code incrementally
15:02:56 <gwern> ddarius: I'm not even a third of the way through Duntemann's _Assembly Language Step by Step: Programming with Linux_; maybe by the end, the registers will be obvious to me, but they're sure as heck not obvious now
15:02:58 <sykopomp> alright.
15:03:00 <dolio> sykopomp: I thinkt hey're more like structural typing.
15:03:07 <lpsmith> and <*>,  that's pretty easy to understand (and important) too
15:03:09 <ddarius> EvanR-work: Yes, and I wanted it when I implemented by extended precision numerals, but it's not what you get with C's or Haskell's (*) and people rarely complain about those.
15:03:12 <dolio> Not that I'm a Go expert.
15:03:21 <sykopomp> not that I am, either. I'm speaking from impressions.
15:03:27 <gwern> dolio: still above 10 kyu eh?
15:03:31 <gwern> maybe you should play more
15:03:33 <sykopomp> and not like I know Haskell's type system very well, either :\
15:03:35 <dolio> :)
15:03:53 <gwern> Go has a type system - everything is one type, 'stone'
15:03:58 <gwern> it's like lisp
15:04:01 <EvanR-work> ddarius: well it would be nice if ghc gave me `mul` or something
15:04:02 <fax> lol
15:04:17 <fax> but I don't want functional programming!
15:04:21 <sykopomp> gwern: how is that like lisp?...
15:04:26 <gwern> sykopomp: everything's a list!
15:04:38 <sykopomp> gwern: that's not true.
15:04:40 <gwern> fax: if lambdabot were here, I should pull up that quote
15:05:05 * gwern introduces sykopomp to humor. humor, sykopomp. sykopomp, humor. humor's friend artistic license will be dropping by soon.
15:05:18 <sykopomp> heh
15:05:38 * hackagebot redis 0.5 - A driver for Redis key-value database  http://hackage.haskell.org/package/redis-0.5 (AlexanderBogdanov)
15:05:38 <lpsmith> ra1m0,  when your applicative functor is also a monad,   f <$> m  = do { x  <- m;  return (f x) }
15:05:43 <chrisdone> gwern tumor. tumor oh we're not jokineg about that anymore
15:05:45 <ddarius> EvanR-work: I agree.  There's a lot of things the hardware has that it would be really nice if they were exposed in a high level language.
15:06:00 <gwern> chrisdone: that reminds me of a story
15:06:07 <chrisdone> gwern: tell me! please!!
15:06:45 <gwern> chrisdone: well, it goes that I was arguing with a guy after an anime club meeting. 'there's nothing funny about child abuse!' I tell him
15:07:02 <chrisdone> gwern: keep talking
15:07:06 <gwern> chrisdone: he begged to disagree. I challenged him to prove it, and he asked for 5 minutes
15:07:24 <gwern> chrisdone: at the 4 minute mark, he raised his head, and began telling a joke
15:07:38 <sioraiocht> Arnar: ping?
15:07:40 <lpsmith> so whenever you might write something like  "do { x <- foo;  let blah = f foo; ... }",  you can write "do { blah <- f <$> foo; ... }" instead and avoid introducing another name
15:07:41 <gwern> chrisdone: 'What's more fun than beating your child with a board game?' quoth he
15:07:50 <gwern> chrisdone: 'I dunno, what?'
15:07:59 <gwern> chrisdone: 'Beating him with anything else.'
15:08:19 <gwern> chrisdone: after a second or two, I conceded defeat
15:08:34 <gwern> and that's how I learned child abuse is funny
15:08:45 <ddarius> gwern: That's not funny.
15:08:45 <fax> I don't get the joke
15:08:53 <ra1m0> lpsmith: did you meant to use x on the first example?
15:09:07 <ra1m0> do { x <- foo; let blah = f x; ...} ?
15:09:21 <lpsmith> ra1m0, err, yes
15:09:27 <chrisdone> those 'im saying something shocking on the punch line' jokes are lame
15:09:31 <ra1m0> ok, seems to make sense
15:09:41 <benmachine> gwern got outvoted
15:09:43 <gwern> chrisdone: nevertheless, I admire his presence of mind
15:09:53 <benmachine> humour is a democracy after all
15:10:07 <gwern> benmachine: no it isn't. it's an aristocracy
15:10:10 <chrisdone> gwern: points for effort
15:10:27 <gwern> benmachine: point in case: all in-jokes and allusions
15:11:26 <chrisdone> gwern: i like jokes that are funny because they're not, and double entendres, those two sets intersect often. got any?
15:11:35 * gwern gives it to chrisdone 
15:11:40 <chrisdone> more
15:11:46 * gwern gives it harder
15:11:55 <fax> well the reason people make jokes about people dying and stuff is so that if you don't laugh they can act like it's your fault
15:11:56 <chrisdone> ~_~
15:12:07 <gwern> (I stole that joke from wikipedia)
15:12:10 <fax> rather than the chance that it's just not funy
15:12:17 <shepheb> onoes, lambdacats is offline :(
15:12:26 <lpsmith> ra1m0, also,   f <*> m = m >>= f,   so when you write something like "do { x <- foo;  blah <- f x; ... }" you can write "do { blah <- f <*> foo; ... }"
15:12:28 <ddarius> fax: I don't think that's why people make such jokes.
15:12:31 <dolio> lambdacats has been gone for months.
15:12:38 <chrisdone> gwern: hear the one about the magic tractor that was driving down the road and turned into a field?
15:12:53 <gwern> shepheb: and the lambdacats email is dead
15:12:58 <gwern> chrisdone: don't believe so
15:13:06 <ddarius> gwern: That was the "joke."
15:13:18 <gwern> ddarius: I don't approve
15:13:20 <benmachine> I liked it
15:13:24 <lpsmith> of course, these assume that 1.  your applicative functors are monads,  and 2.  the person writing the instances for the two classes are sane and the definitions overlap correctly
15:13:32 <chrisdone> gwern: i lol'd hard when i heard the tractor joke. that's what i mean by me liking jokes that are awful and double entendres
15:13:37 <gwern> puns. the lowest form of humor.
15:13:48 <benmachine> says the man who just did a child abuse joke
15:14:08 <benmachine> hi helgikrs I hope you liked your introduction
15:14:19 <ddarius> benmachine: Child abuse is funny; just gwern's associate's joke wasn't.
15:14:20 <chrisdone> gwern: is it?
15:14:21 <ra1m0> lpsmith: when's the time to use <*>, *> or <*?
15:14:33 <gwern> ddarius: you do better then
15:14:43 <gwern> chrisdone: sure. like miming is the lowest form of acting
15:14:47 <lpsmith> :t (<*>)
15:14:49 <benmachine> chrisdone: good puns are awesome, bad puns are only slightly less awesome
15:14:54 <benmachine> this is proven empirical fact
15:14:58 <ddarius> gwern: Imitation is the highest form of flattery.
15:15:10 <gwern> chrisdone: check the USDA acting pyramid; your daily mimery is lowest in quantity
15:15:17 <lpsmith> preflex,  :t (<*>)
15:15:31 <lpsmith> @bots
15:15:38 <fax> I agree with benmachine
15:15:42 <chrisdone> puns make me laugh because they're so poor
15:15:54 <lpsmith> are all the bots down?
15:16:03 <shepheb> the all-time best puns are a painful, grudging kind of funny. a facepalm covering your unwilling smile.
15:16:08 <chrisdone> i can never tell if the person thinks the pun's clever or is being ironic :d
15:16:10 <benmachine> preflex: seen lpsmith
15:16:10 <preflex>  lpsmith was last seen on #haskell 16 seconds ago, saying: are all the bots down?
15:16:11 <ra1m0> I noticed the type signature but couldn't figure out scenario where it would make sense to use it
15:16:14 <fax> I like puns because when you read one it's the same feeling as when you solve some kind of problem
15:16:21 <benmachine> whatever happened to lunabot
15:16:22 <fax> like *snap* in your head
15:16:34 <chrisdone> yeh
15:16:36 <benmachine> I agree with fax
15:16:42 <lpsmith> preflex,  @type (<*>)
15:16:43 <lispy> benmachine: I think mmorrow was running that bot
15:16:54 <benmachine> oh :(
15:16:57 <lpsmith> yeah
15:17:07 <lispy> oh, is lambdabot down?
15:17:10 <benmachine> seems so
15:17:16 <byorgey> lpsmith: (Applicative f) => f (a -> b) -> f a -> f b
15:17:31 <lpsmith> byorgey :)
15:17:33 <chrisdone> my driving instructor used to make puns all the time. but really stretched ones that required in depth knowledge of some subject. his drawn out explanations and final grin of pride made me lol
15:17:38 <lispy> 19983 cale      15   0  125m  56m 6956 S    0 15.7  21:39.58 lambdabot
15:17:43 <lispy> hmm...
15:18:11 <Cale> Sometimes it comes back on its own
15:18:17 <Cale> But I can reset it
15:18:18 <lpsmith> ra1m0, you often see things such as "f <$> a1 <*> a2"
15:18:19 <benmachine> *she
15:18:20 <shepheb> does lambdabot compile under 6.8.2? I want to build my own for a random channel, but that's all the server I can use has.
15:18:22 <benmachine> *her
15:18:22 <benmachine> :P
15:18:27 <chrisdone> haha cale treats lambdabot like a runaway daughter
15:18:35 <lispy> Cale: hmm... just killed the pid of lambdabot, will runlambdabot bring it back?
15:18:41 * Cale treats lambdabot like a machine
15:18:56 <gwern> chrisdone: like a red-headed stepchild
15:19:01 <lispy> Guess I should have checked for the parent process
15:19:08 <ddarius> lambdabot is a program, neither a daughter nor a machine.
15:19:08 <lispy> Cale: thanks for restarting it :)
15:19:11 <chrisdone> gwern: child abuse is not funny!!
15:19:18 <lispy> ?vixen are you a daughter or a machine?
15:19:21 <gwern> chrisdone: didn't we just establish that it is?
15:19:25 <lambdabot> yes, i am
15:19:29 <benmachine> haha
15:19:45 <chrisdone> gwern: i'm pretty sure we unequivocally established it ain't
15:20:13 <ddarius> chrisdone: No, we unequivocally established that one particular joke wasn't funny.
15:20:20 <chrisdone> ddarius: don't encourage him
15:20:25 <mreh> how do I get the profiling library with cabal again?
15:20:41 <lispy> --enable-library-profiling
15:20:48 <mreh> gotcha
15:20:56 <lispy> I find it's best to put that in your ~/.cabal/config
15:21:07 <mreh> lispy: yes along with the documentation
15:21:22 <lispy> mreh: oh, I should probably enable documentation
15:21:23 <ddarius> chrisdone: He'd probably be better behaved if he was beat more as a child.
15:21:42 <mreh> lispy: can I get offline cabal documentation?
15:21:42 <shepheb> one of my schoolmates puts out 4-6 puns of varying quality in an average day. you can see them coming, when his background processes have got the seed of a pun and he's trying to work it into a complete sentence.
15:22:03 <lispy> mreh: cabal documentation as in the cabal command?
15:22:10 <shepheb> they range from painful to painful but hilarious.
15:22:11 <chrisdone> ddarius: at games, you mean. chess, checkers, etc
15:22:18 <lispy> mreh: or do you mean documentation for the things you install via cabal-install?
15:22:25 <mreh> lispy: nah, the cabal build too
15:22:26 <mreh> l
15:22:50 <lispy> mreh: cabal --help :)
15:23:04 <ddarius> chrisdone: If you want to involve a belt in checkers... okay.
15:23:07 <lispy> mreh: failing that you could do cabal unpack cabal-install and read the source :)
15:23:15 <gwern> @quote Sarah
15:23:15 <lambdabot> sarah says: "But I don't _want_ functional programming!" -- Sarah Peyton Jones, age 11, upon hearing the rules of Go
15:23:30 <lpsmith> ra1m0, my current level of appreciation for applicative functors came from reading and writing parsers that used them;  oddly enough, this was also critically important for my understanding of monads.
15:23:41 <medfly> kids of extremely nerdy people
15:23:48 <mreh> if you're on a long train journey and you don't have access to the internet it's a real pain when you can't remember how to do something on cabal
15:23:51 <chrisdone> ddarius: checkers is an intense game but i don't think you need a seatbelt, come on
15:24:01 <lpsmith> ra1m0, I never really understood monads until I read "Monadic Parser Combinators" by Graham Hutton
15:24:04 <gwern> checkers is stupid and solved
15:24:19 <mreh> noughts and crosses
15:24:31 * benmachine hugs chrisdone 
15:24:32 <lpsmith> gwern, it's a good intro strategy game for kids :)
15:24:43 <gwern> better than tic-tac-toe, I suppose
15:24:49 <lpsmith> strategy as opposed to luck
15:25:05 <mreh> there is a strategy in checkers where you can always win/force a draw that you can memorise?
15:25:05 <medfly> solved strategy games are fun, it's not mindblowing to come to their solution yourself and then when you grow up you start to think that maybe you were sort of smart as a kid
15:25:31 <lpsmith> mreh, I'm not sure you can memorize the strategy,  that would be a massive undertaking (and an impressive feat)
15:25:33 <medfly> tic-tac-toe and such
15:25:46 <lpsmith> basically,  the computer will win against a human at this point.
15:25:48 <fax> when I read about smart people I know I was never smart
15:25:55 <lpsmith> The human will make a mistake somewhere
15:26:04 <mreh> lpsmith: minimax non?
15:26:15 <chrisdone> lpsmith: why do i detect a hint of cold, hard, metallic "THE HUMAN" in your tone of voice?
15:26:16 <medfly> it sucks knowing you're mediocre
15:26:26 <gwern> fax: if you're here and following half the conversations, then you're up in the smart percentiles
15:26:37 <fax> it doesn't suck
15:26:46 * gwern wonders if anyone here is below the 95th percentile IQ-wise
15:26:50 <fax> gwern, it's not hard to follow this channel XD
15:26:51 <medfly> me I guess
15:26:55 * chrisdone raises hand
15:26:58 <medfly> but I have never had an IQ test...
15:27:02 <lpsmith> mreh:  minmax what?
15:27:14 <lpsmith> chrisdone: heh :)
15:27:21 <fax> what does 95th percentile mean? IQ of <= 95
15:27:23 <mreh> lpsmith: the minimax algorithm, surely no computer can evaluate the game tree for checker in any decent time
15:27:32 <gwern> medfly: are you american? many american kids are given IQ tests in school at some point
15:27:39 <mreh> fax: smarter than 95% of the population
15:27:41 <medfly> fax, I think it's less straightforward as it's supposed to have a normal distribution
15:27:56 <medfly> fax, but IQ=100 is the middle point
15:27:58 <benmachine> 15 IQ points = 1 standard deviation iirc
15:28:06 <medfly> ah
15:28:07 <lpsmith> mreh, yeah, I know what minimax is, but I don't know enough to say
15:28:07 <gwern> iirc, 95th is 125 or above on a few
15:28:17 <mreh> IQ=100 is not the mean anymore, it's drifting up, flyn effect
15:28:34 <mreh> gwern: that depends on what scale you're using
15:28:34 <medfly> I actually don't have enough statistical background to go from 1 statistical deviation to what 95% roughly is :(
15:28:36 <mreh> :)
15:28:39 <gwern> mreh: don't be so sure. flynn seems to have stopped in many countries
15:28:39 <medfly> 3 statistical deviation?
15:28:45 <benmachine> given that it's normal I guess it's strictly speaking possible to have a negative IQ
15:28:46 <lpsmith> but it's fairly well established that even with a truncated minimax search,  computers pretty handily beat the best checkers players
15:28:59 <lpsmith> (best human players, that is)
15:29:04 <gwern> mreh: and I buy the theory that flynn was driven by an decrease in stupid outliers
15:29:47 <medfly> okay, 130 is about right then.
15:29:52 <mreh> maybe... or maybe you doubt the power of the morphogenetic field!
15:29:53 <IceDane> is there any easy way to incorporate the index of an element in a list without doing something like zipWith (,) list [0..] and then dealing with tuples? In a map, for example
15:29:59 <gwern> mreh: I do :)
15:30:07 <medfly> gwern, I am not American.
15:30:16 <gwern> IceDane: nope, tuples is the usual approach I use
15:30:23 <byorgey> IceDane: no, but note that you can simplify that to  zip list [0..]
15:30:26 <gwern> poor medfly
15:30:27 <medfly> gwern, I was given all sorts of weird tests when I was a child, but I didn't really get their results.
15:30:29 <medfly> hahaha
15:30:44 <lpsmith> I made up a form of checkers with triple castling once;   I forget exactly what the triple castle did but I recall it allowed you to move onto the white squares
15:30:44 <shepheb> medfly: be glad you haven't been subjected to that stats. I felt so betrayed by my own intuition, which consistently led me astray
15:30:47 <gwern> medfly: yeah. I saw the result of one IQ test by sheer accident
15:30:50 <IceDane> byorgey: Ah, thanks :)
15:31:03 <lpsmith> I think that was second grade maybe :-P
15:31:03 <byorgey> IceDane: however, you could easily write a combinator for doing things with lists + indices, and then use that combinator instead of dealing with the indices directly
15:31:12 <gwern> lpsmith: the third castle was moving back to your side?
15:31:18 <medfly> shepheb, oh, I do remember my intuition constantly misleading me when I got some basic stats, but it seems to make more sense lately.
15:31:24 <IceDane> byorgey: Combinator? I'm not very down with the lingo, heh
15:31:29 <lpsmith> gwern, yup
15:31:30 <byorgey> IceDane: for example, for a map you could write a function of type   (Int -> a -> b) -> [a] -> [b]
15:31:31 <medfly> shepheb, I actually helped someone who is studying a basic statistics course by pure intuition!
15:31:56 <mreh> is anyone 140+ here? I'm not, never met anyone who is
15:31:58 <byorgey> IceDane: that function would be implemented using zip and tuples etc. but then later you could just use that function directly
15:32:03 <IceDane> byorgey: Ah, yes
15:32:06 <IceDane> I see, I was thinkign the same thing
15:32:13 <medfly> mreh, well, would you trust it if someone said so online?
15:32:19 <IceDane> I just would have called it "wrapper function" or something
15:32:23 <benmachine> I have an IQ of 6000
15:32:28 <pikhq> IceDane: A combinator is a function that takes a function as an argument.
15:32:31 <gwern> mreh: I was in the 130s as a kid. it's *possible* I'm in the 140s!
15:32:34 <fax> Ihave an IQ of 9999999999999999999
15:32:34 <IceDane> pikhq: Oh, I see
15:32:35 <lispy> benmachine: It's over 9000!
15:32:41 <medfly> mreh, if someone is proud of it in front of >600 people, then he's pretty arrogant, and may be lying
15:32:43 <IceDane> lispy: Hahaha, I was just about to say that
15:32:44 <BMeph_> I recall seeing that signature for a Vector function (imap) and wondered why it wasn't one in Data.List
15:32:49 <benmachine> (i.e. the same as twelve thousand car parking attendants)
15:32:53 <chrisdone> the internet told me im really smort
15:32:56 <lpsmith> > product [1..9000]
15:32:57 <lambdabot>   809958998668719085829131208009794964758281463929464089222191306909090154073...
15:33:00 <IceDane> If you want to say "some X is over Y" on the internet, y better be 9000
15:33:05 <pikhq> (there's a few other details to the definition, but unessential to just having a vague feel for what a combinator *is*)
15:33:11 <mreh> medfly: my interest is purely statistical
15:33:31 <shepheb> > length.show.product$[1..9000]
15:33:33 <lambdabot>   31682
15:33:33 <mreh> and seeing as we're all pretty high IQs evidently, there's bound to be atleast 1
15:33:55 <medfly> almost 700 people here and I'm pretty sure we have a slightly above average IQ as an average... there are definitely some
15:34:40 <BMeph_> gwern: Huh, I was also in the 130's as a kid. It still didn't keep me from graduating late from HS, 'cause I was too bored and non-self-motivated. :\
15:34:40 <lispy> Anyway, this isn't really germane to haskell though.  Maybe we should save the IQ debate for #haskell-blah
15:34:45 <lpsmith> medfly, well, I doubt many people here have below average IQ,  as much as IQ is even a meaningful measurement
15:34:49 <lpsmith> I have my doubts
15:34:57 <shepheb> IceDane: one of my professors is fond of using too-small units so that he can (obviously deliberately but without undue emphasis in class) point out that values are over 9000.
15:35:11 <gwern> BMeph_: you should've gotten more demanding parents
15:35:12 <medfly> heh
15:35:15 <IceDane> shepheb: Haha, that's awesome
15:35:18 <shepheb> challenged after class on it, he told me to do a barrel roll
15:35:30 <IceDane> How old is he?
15:35:35 <shepheb> late 20s?
15:35:40 <IceDane> Oh, then it's understandable
15:35:41 <medfly> man, professors are weird.
15:35:43 <lpsmith> shepheb, it's better to put spaces around infix operators, especially (.),  as then it makes it clear it's not a qualified name
15:35:51 <gwern> shepheb: barrel rolls are easy. just tap his shoulder
15:35:52 <IceDane> It'd be seriously cool if he was ancient and still down with the internet memes
15:36:06 <medfly> "ancient" :(
15:36:11 <shepheb> lpsmith: I make no claims to the quality of my lambdabot code. I always use space in my real code.
15:36:18 <shepheb> gwern: well played.
15:36:19 <medfly> I actually went to uni with my mother, and she went to the same uni...
15:36:20 <IceDane> medfly: Greater than young.
15:36:23 <lpsmith> :)
15:36:39 <medfly> we were eating together, and she said "do you see that guy there? he taught me this one course"
15:36:53 <gwern> shepheb: I license that response to you royalty-free. next time he tries that quip, you'll be ready
15:37:14 <shepheb> gwern: I wrote my final on Saturday, so my chances are gone.
15:37:48 <shepheb> I /should/ be studying for group theory on Thursday, my final-final-final. terrifying thought.
15:38:03 <BMeph_> gwern: Demanding how? They demanded plenty from themselves... ;)
15:39:55 <mreh> why does haddock have such strange dependencies?
15:40:35 <gwern> mreh: what's strange about them?
15:40:48 <gwern> it needs ghc to read & run haskell files, it needs xhtml for obvious reasons, etc
15:41:21 <quuxman> I'm almost surprised that I can't find any google hits about targeting Haskell to Tracemonkey
15:41:25 <mreh> gwern: the versions of GHC is quite specific for each, often between minor version numbers
15:41:35 <gwern> mreh: it's the GHC API, what do you expect?
15:41:43 <quuxman> I think Firefox would be a really cool environment for Haskell programming
15:41:48 <mreh> gwern: only but the best
15:41:59 <gwern> quuxman: the yhc js backend might be up your alley
15:42:00 <mreh> gwern: I have no idea what to expect TBH
15:42:29 <gwern> mreh: the ghc api changes constantly, is painful to work with, etc.
15:42:36 <quuxman> gwern: not really. I want a Firefox plugin that interprets / compiles Haskell so I can create an IDE based in the browser
15:42:42 <gwern> which is why I always go through hint these days
15:42:52 <mreh> i have to say I'm dead impressed with the tools that come with haskell
15:43:10 <gwern> quuxman: that sounds like a horrible idea, but godspeed
15:43:16 <quuxman> gwern: why so horrible?
15:43:17 <mreh> was automatic dependency resolution something that *noone* had thought of before
15:43:41 <gwern> quuxman: why firefox? why a plugin? you've immediately added an extra layer to your ide
15:43:46 <quuxman> Firefox has good UI primitives... it deals with input events, sound, and graphics all pretty well, and has convenient tie in with the www
15:43:54 <gwern> ides are hard enough without dealing with tieing into firefox
15:44:11 <gwern> quuxman: maybe you'd be better off just hacking on leksah
15:44:24 <chrisdone> and leksah needs contributors
15:45:38 <quuxman> gwern: possibly. Does leksah have convenient libraries on hand for playing audio, capturing mouse events, drawing PDF / Cairo style graphics, doing web requests, rendering HTML, blah blah blah?
15:45:56 <gwern> quuxman: it actually works
15:46:03 <gwern> bird in hand, versus PDF in bush
15:46:04 <quuxman> Does Leksah have a huge install base with an automatic upgrade system with a plugin repository ?
15:46:58 * gwern doesn't see how the plugins repo matter; yo dawg...
15:47:01 <quuxman> I've downloaded, built, and experimented with Leksah a couple times. I haven't done it recently though
15:48:46 <quuxman> my interest in running Haskell in a browser environment (specifically Firefox) is not just based on creating an IDE around it. That's just one idea. There's another interesting possibility
15:50:05 <quuxman> Create plugin dependent websites / web applications (like ones that use Flash, except this would be an open source plugin). Because Haskell is a general purpose more rigorous programming language than ActionScript, you could potentially do a lot more, and do it more easily, on the client side
15:50:25 <quuxman> than you could in ActionScript or JavaScript
15:50:38 <kilimanjaro> How could you do more?
15:50:48 <kilimanjaro> Doing things more easily I understand
15:51:08 <quuxman> Well, the plugin could support concurrency primitives for example, and some network primitives perhaps
15:51:25 <Berengal> There's a reason there are no concurrency primitives for JS
15:51:48 <quuxman> Berengal: malicious use of CPU?
15:52:34 <Berengal> Doesn't have to be malicious. Incompetent works equally well
15:52:39 <quuxman> Berengal: you can very easily bog down any browser with an infinite loop in JavaScript. With better concurrency primitives implemented this could actually be avoided
15:53:19 <_martin_> Is it possible to export a function of type [[[Char]]] -> [[[Char]]]  with "foreign export ccall"?  I am getting this error: Unacceptable result type in foreign declaration: [[[Char]]]
15:53:33 <kmc> _martin_, no
15:53:36 <quuxman> Berengal: go to this url in Firefox: javascript: while(true) { }
15:53:56 <_martin_> kmc: thanks
15:53:59 <kmc> _martin_, Haskell lists are linked lists of heap-allocated values
15:54:04 <kmc> there is no obvious C counterpart
15:54:15 <kmc> the FFI provides correspondances for only very basic types, and expects you to write marshalling code for the rest
15:54:32 <kmc> the FFI chapter in RWH has good examples
15:55:44 <_martin_> kmc:  that makes sense
15:55:52 <quuxman> kilimanjaro: you could allow for more functionality by implementing a more rigorous meaningful security model, instead of the adhoc ones currently implemented for JavaScript
15:56:54 <quuxman> kilimanjaro: for example, it's not a real security measure to make it impossible to change the appearance of an <input type="file"> tag (this is honestly a security measure taken by all existing browsers)
15:57:10 <dankna> it is a security measure
15:57:22 <dankna> it deals with social-engineering exploits
15:57:34 <dankna> you would still need that measure even in the presence of better concurrency support
15:57:43 <quuxman> dankna: it's not an effective one. I have a JavaScript library that's cross-browser friendly that turns any element in to a file input button by putting invisible file input tags on top of it in a clever way
15:57:56 <dankna> hrm.  okay then.
15:58:20 <quuxman> dankna: it's slapping security on the UI level, which is not appropriate. Yes, this has nothing to do with concurrency
15:58:30 <dankna> that's fair enough
15:58:32 <quuxman> dankna: it's just an example of the ridiculous existing security model
15:58:46 <idnar> security is important at the UI level, but it doesn't work when it's an afterthought
15:59:32 <quuxman> idnar: hm, I prefer security on a logic level, and the UI be implemented within that logic
16:00:03 <kilimanjaro> you still have a fundamental problem
16:00:05 <mreh> I thought compiling with optimisations and profiling were mutually exclusive
16:00:07 <kilimanjaro> even if you create a better system
16:00:08 <quuxman> security is tricky, and I don't trust myself or any programmer to implement it on a UI level (given the UI has an interesting degree of complexity)
16:00:11 <kilimanjaro> nobody will use it
16:00:20 <lispy> mreh: nope.
16:00:35 <quuxman> kilimanjaro: I will use it to write web apps that our used within my own company
16:00:35 <lispy> mreh: but, profiling will make it slower than without it
16:00:36 <mreh> lispy: can't remember where I got that idea from
16:00:38 <quuxman> kilimanjaro: so that's wrong
16:00:58 <mreh> lispy: I thought if you passed -O2 -prof it would complain
16:01:01 <lispy> mreh: and not all optimizations will fire the same way, because the profiling code can interfere with the detection of optimizations
16:01:12 <kilimanjaro> quuxman, ahh
16:01:18 <quuxman> kilimanjaro: I have the influence to say "all you employees install Firefox and this plugin" and that will make my development work easier enough for it to be worth it
16:01:33 <lispy> mreh: Nah, GHC kicks ass :)
16:01:47 <quuxman> kilimanjaro: however, it's not worth my development work if I have to implement this plugin on my own, because it's a pretty serious programming project
16:01:47 <idnar> quuxman: well, the point is, the UI needs to accurately reflect the behaviour layer
16:01:50 <lispy> It's a seriously high quality piece of software when you get down to ti
16:01:52 <mreh> with its cousin cabal, they form an ass kicking team
16:01:58 <quuxman> idnar: yeah
16:01:59 <mreh> they each only have one leg
16:02:04 <lispy> mreh: GHC kicks ass, and cabal takes names :)
16:02:10 <mreh> I like it
16:02:15 <idnar> quuxman: I suppose you might just view that as solid UI design
16:02:32 <idnar> but then, security is just solid authority design ;)
16:02:44 <quuxman> idnar: or solid software engineering... reduce a problem to a fundemental logic, create a DSL or language around that logic, than write the rest
16:03:32 <quuxman> I'm just a little surprised there isn't more stuff already on the web about implementing a GHC backend for Tracemonkey
16:03:47 <quuxman> it seems that would be the easiest approach to create this sort of plugin
16:04:11 <dankna> there is a ghc backend for javascript but it has bitrotted
16:04:31 <quuxman> I'm not interested in generating JavaScript, because JavaScript honestly has a pretty crappy interface to the browser internals
16:04:42 <rodriago> Can someone help me with some probles installing libraries with Cabal in windows?
16:04:44 <quuxman> and to the rest of the OS environment
16:06:37 <rodriago> after installing the hmatrix library, seems like ghc doesn't recognize the modules that come with the package, which shows when running the tests
16:06:57 <rodriago> what could be done with this issued?
16:08:40 <quuxman> I guess a far more reasonable approach would just be to create a Firefox plugin package...
16:09:11 <Saizan> rodriago: does "ghc-pkg list hmatrix" lists it?
16:10:26 <rodriago> yeah, it does list it
16:11:34 <Saizan> which module are you importing in particular?
16:12:03 <rodriago> Numeric.LinearAlgebra.Tests
16:12:19 <rodriago> but it doesn't recognize any of the other ones either
16:12:36 <Saizan> weird, what's the exact error that you get?
16:13:15 <rodriago> C:\haskell\hmatrix-0.8.3.1>runhaskell examples\tests.hs  examples\tests.hs:1:7:     Could not find module `Numeric.LinearAlgebra.Tests':       Use -v to see a list of the files searched for.
16:14:34 <Saizan> "ghc-pkg check" ?
16:14:52 <rodriago> no problems there
16:15:00 <Saizan> also, "ghc-pkg field library-dirs hmatrix" will give you a directory, you should check that it contains the .hi files for the modules
16:15:55 <rodriago> it doenst recognize hmatrix as a field
16:17:19 <Saizan> oh, sorry, it's "ghc-pkg field hmatrix library-dirs"
16:17:30 <rodriago> lol already guessed so
16:18:30 <rodriago> it does contain them in other folders
16:19:38 <rodriago> C:\haskell\hmatrix-0.8.3.1>ghc-pkg field hmatrix library-dirs library-dirs: C:\Users\Santi\AppData\Roaming\cabal\hmatrix-0.8.3.1\ghc-6.12.1               C:\haskell\bin
16:19:57 <rodriago> the first one contains the folders with the .hi files
16:21:04 <Saizan> i'm not sure then, unless runhaskell is using a distinct ghc installation
16:21:55 <rodriago> no, when I try :m in ghci for any of those modules it doesnt work either
16:23:20 <Saizan> ghc --make examples\tests.hs ?
16:24:09 * hackagebot glpk-hs 0.3.1 - Comprehensive GLPK linear programming bindings  http://hackage.haskell.org/package/glpk-hs-0.3.1 (LouisWasserman)
16:24:28 <rodriago> same error
16:29:07 <Saizan> i don't know then :\
16:29:20 <rodriago> well, thanks anyway ^^
16:29:33 <rodriago> I'll try asking again in a while to see if someone knows
16:44:18 <pastorn> can i force certain packages to be used in the head of a fileL
16:44:20 <pastorn> ?
16:44:24 <pastorn>     Ambiguous module name `Control.Monad.RWS':
16:44:26 <pastorn>       it was found in multiple packages: mtl-1.1.0.2 monads-fd-0.0.0.1
16:44:37 <gwern> pastorn: why not just ghc-pkg hide one?
16:44:52 <pastorn> gwern: i just want to do it for this project
16:44:53 <gwern> pastorn: there is an evil ghc extension which lets you import Control.Monad.RWS from x-package
16:45:07 <pastorn> why is it evil?
16:45:50 <gwern> because modules shouldn't be specifying the packages an imported module comes from
16:46:02 <gwern> that's cabal's job
16:46:45 <pastorn> gwern: this isn't exactly cabal worthy code...
16:46:49 <pastorn> it's my IRC bot...
16:47:00 <gwern> fine then, use the evil extension and be damned to you!
16:47:08 <pastorn> what's it called?
16:47:13 * gwern shan't say
16:48:51 * pastorn cries
16:49:35 <mreh> haskell program seems to be lagging up, but the CPU is hardly running at more than 20%
16:49:35 <gwern> it were well that one should have to work to work evil
16:49:43 <mreh> that's odd
16:50:30 <Saizan> mreh: memory use?
16:50:38 <pastorn> BONUS: nice pirate ship :)
16:50:42 <mreh> Saizan: minimal
16:51:02 <mreh> Saizan: it relies on HGL... need I say more?
16:51:22 <pastorn> BONUS: i don't get the G at the top, though :(
16:51:23 <mreh> profiling doesn't seem to show any heavy reliance on functions from the HGL the library though
16:51:25 <Saizan> ah, no.
16:54:38 <gwern> > 5.4 / 1.5
16:54:38 <lambdabot>   3.6
16:54:45 <fax> > 54 / 15
16:54:46 <lambdabot>   3.6
16:54:50 <fax> wrong
16:54:52 <pastorn> gwern: i give up... how do i hide stuff?
16:54:54 <ddarius> Okay, next day of what should ddarius read: Clifford analysis or combinatorial species?
16:55:04 <fax> combinatorial species
16:55:08 <fax> wait
16:55:10 <fax> Clifford analysis
16:55:14 <gwern> pastorn: look on the extensions list
16:55:28 <pastorn> i did... there's like fiddy of them
16:55:57 <kilimanjaro> combinatorial species
16:58:17 <pastorn> -XPackageImports ??
16:58:48 <Saizan> that's the one
16:58:55 <malosh> Hi. Say I'm doing things in a monad, for instance with refs, then calling different functions to modify the refs. If I have half a dozen of refs, is there a syntactic sugar for factoring all these arguments, except allocating a record type ?
17:00:17 <malosh> The problem is, unboxed tuples would do the trick but they can't be passed between functions. By the way, they cannot even be used as arguments
17:00:39 <philo> how do i do to interract with the shell command ? like lauching other progs and reding their output ?
17:01:06 <malosh> philo : System.Command ?
17:01:16 * BMeph_ says malosh is doing Nothing in a monad! ;)
17:01:33 <malosh> :-)
17:02:02 <malosh> philo : actually it is http://www.haskell.org/ghc/docs/latest/html/libraries/process-1.0.1.2/System-Cmd.html
17:02:07 <ddarius> > forever (do Nothing)
17:02:08 <lambdabot>   Nothing
17:02:11 <Saizan> philo: System.Process as well
17:02:17 <philo> thanks
17:02:24 <mtnviewmark> @pl \f a -> f a a
17:02:24 <lambdabot> join
17:02:35 <philo> system.Command deos exist ?
17:02:38 <mtnviewmark> :t join
17:02:39 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
17:02:56 <malosh> By the way, this System.Cmd stuff is quite bizarre. Forking is simpler to do even in C !
17:03:34 <mtnviewmark> :t join (*)
17:03:35 <lambdabot> forall a. (Num a) => a -> a
17:03:44 <Saizan> what you do with System.Cmd is not really the same as forking
17:04:12 <Veinor> thing I just realized: a set is essentially a predicate
17:04:51 <dmwit> Given a suitable universe, yes.
17:05:20 <Veinor> right.
17:05:22 <malosh> Saizan : well, I don't know how it works in windows, but unix _has_ to fork to do this
17:05:23 <danderson> if someone has time, I'd appreciate a documentation review for http://natulte.net/random/forkable-monad/Control-Concurrent-Forkable.html
17:05:27 <danderson> before I push to hackage
17:05:48 <danderson> I'm quite sure I'm not using the correct terminology to refer to monad stuff.
17:07:44 <malosh> danderson : does it reexport the original Control.Concurrent, so that it can replace it without changing the program ?
17:08:00 <danderson> malosh: no, but that's a good idea.
17:09:03 <Saizan> danderson: the main problem is that there isn't really a concept of current state defined in general for any monad
17:09:19 <Saizan> danderson: OTOH it's quite easy to guess what you mean
17:09:53 <ddarius> Veinor: Welcome to higher order type theory.
17:09:56 <Saizan> except that it wasn't clear from just the documentation what the State instance would have done
17:10:09 <danderson> Saizan: right, the definition of what is transplanted is currently fuzzy at best. I'm just not sure how to better express it.
17:10:25 <Saizan> err, from just the text, it's clear from the code
17:10:47 <danderson> right. But ideally, the documentation should also make the module usable without browsing the source
17:10:55 <blackh> danderson: Here's another suggestion (because I did some code like this) - I found it good to generalize it to handle exceptions as well.
17:11:12 <danderson> can I actually add Haddock docs to each instance? Will that display things correctly?
17:11:24 <danderson> that would allow me to document exactly what is meant by "transplant" for each instance.
17:11:43 <danderson> blackh: handle them in what way?
17:13:02 <Saizan> per instance documentation still needs to be implemented, iirc
17:13:22 <blackh> danderson: Looking at my code, all I implemented was finally.
17:13:27 <philo> data ProcessHandle in System.Process doesnt have a definition... ?
17:14:29 <danderson> hmm.
17:14:46 <danderson> blackh: I see that it would be nice to incorporate exception handling, but I'm not sure how to go about it.
17:15:05 <blackh> danderson: Do you want me to give you this code in case it gives you an ideas?
17:15:25 <MarcWeber> dcoutts: I've thought about the hackage issue that you can't just replace existing packages easily again. What about introducing revisions ? They should replace existing versions indicating that the uploader tried fixing minor bugs such as cabal verion constraints which may be necessary to keep the package building.. ? Just a thought. Hackage could list all revisions, but the hackage index should only contain the latest.
17:15:57 <MarcWeber> It happened to the WashNGo project now. I forgot to add the constraint parsec < 3.
17:16:32 <danderson> blackh: why not. I think I have the exact same case in my own code, so what I'm really interested in is figuring out how to express that in the API such that it's not ugly
17:16:48 <Gracenotes> MarcWeber: revisions just in the .cabal file, maybe?
17:16:50 <blackh> danderson: I just have to ask my boss for permission.
17:17:11 <danderson> sure thing
17:17:29 <Gracenotes> or in the whole package, but that might actually change how things build...
17:17:44 <MarcWeber> Gracenotes: In fact there was another issue. I was told some files are latin-1 and I should change them to utf-8. I consider this being a minor change as well. So no, overriding the .cabal file is not enough. You may want to upadate README files as well
17:19:08 <Gracenotes> kind of a social contract there, things being a minor change or not.
17:19:38 <MarcWeber> Gracenotes: Yes. But it is a real issue. For exactly this reason I started a repository containing .cabal patches only.
17:20:04 <MarcWeber> Gracenotes: You can have multiple links: links pointing to the specific revision or a link pointing to the latest revision.
17:20:35 <Gracenotes> or, even better, links to a revision that compiles the package right :)
17:20:46 <Gracenotes> ..hopefully the latest one
17:21:06 <MarcWeber> If its not the latest you can fix it yourself and upload it.. Then it is the latest.
17:21:28 <MarcWeber> But less broken versions will be visible to the common user not digging for all revisions..
17:21:48 <MarcWeber> and tools such as cabal-install have less packages to take into account when calculating installation plans.
17:27:04 <philo> is there any way to capture the ouput of runCommand in a variable ?
17:27:17 <fax> :t runCommand
17:27:18 <lambdabot> Not in scope: `runCommand'
17:28:20 <philo> :t
17:28:20 <philo> :t dsf
17:28:21 <lambdabot> Not in scope: `dsf'
17:28:27 <Gracenotes> from System.Process?
17:28:31 <blackh> danderson: http://hip-to-be-square.com/~blackh/haskell/Transformer.hs  I hope you find that useful.
17:28:36 <philo> :t System.Process.runCommand
17:28:37 <lambdabot> String -> IO System.Process.Internals.ProcessHandle
17:28:49 <Gracenotes> there are many methods for a variety of outputs
17:28:49 <philo> Gracenotes:  yes
17:29:19 <Gracenotes> try to read through them.. there are almost too many options :) in your case, readProcess :: FilePath -> [String] -> String -> IO String -- jumps out
17:30:10 <philo> ok thanks
17:30:25 <Gracenotes> and runInteractiveProcess is pretty much as flexible as you can get
17:31:29 <danderson> blackh: aah, I see, another parallel type class for transformed exception handlers. Crafty.
17:31:44 <danderson> need to meditate upon this some more, but I could definitely use something like this myself.
17:32:28 <fax> why not have like
17:32:31 <fax> data [] a = ...
17:32:39 <BMeph_> See y'all at home...
17:32:48 <fax> then if f :: a -> b you could have [f] :: [a] -> [b]?
17:32:50 <danderson> blackh: thanks, that code is very insightful!
17:32:54 <fax> and Maybe f :: Maybe a -> Mybe b
17:32:58 <fax> and stuff like that
17:33:08 <fax> why not ?
17:33:08 <blackh> danderson: A generic monad transformer stack forkIO does have some semantics that need thinking about in places - I think it's a very useful thing to have, so I'm glad you're packaging it up in Hackage.  Let me know if I can help in any other way.
17:33:23 <dolio> [f] is already a value expression.
17:33:24 <fax> maybe it's not possible to always find that function
17:33:28 <dolio> Denoting a singleton list.
17:33:36 <fax> I don't want singleton lists
17:33:53 <dolio> Anyhow, you can only do that stuff for covariant functors.
17:34:01 <fax> ohh
17:34:18 <dolio> That's how it's actually typically denoted in category theory.
17:34:50 <dolio> Given a functor F, given f : A -> B, Ff : FA -> FB
17:35:33 <ddarius> dolio: It would be easy enough to extend the scheme to contravariant functors and mixed variant functors in the multiple type parameter case.
17:35:41 <dolio> Sure.
17:36:21 <monoidal> is it possible to catch exceptions outside IO monad?
17:37:19 <Cale> monoidal: not IO exceptions, and not the exceptions thrown by calling 'error'
17:37:44 <dolio> GHC can auto-derive Functor now, so it's not out of the realm of conceivability that it could figure out which type constructors you could use like that.
17:37:45 <Cale> monoidal: You can use things like Either or Maybe
17:37:59 <dolio> But you'd have to clean up some stuff.
17:38:01 <monoidal> what is the explanation? I vaguely remember that "evaluation order is not defined"
17:38:11 <dolio> (,) denoting tuple types, for instance.
17:38:26 <Cale> monoidal: That's part of it. It destroys referential transparency to allow it.
17:38:47 <monoidal> hm. How?
17:39:41 <monoidal> for example, (&&) is always computed from the left
17:40:02 <dolio> catch (throw x + throw y) (\e -> ...)
17:40:12 <monoidal> :q
17:40:40 <danderson> blackh: for starters, I think I'm going to release a 0.1 with just raw forkIO, without extras. Then, I'll start meditating on 0.2, with Control.Exception support. The source is at http://bitbucket.org/danderson/forkable-monad , thoughts/suggestions/patches are most welcome.
17:40:50 <monoidal> dolio, is evaluation order of (+) undefined?
17:41:39 <dolio> No, but allowing catch in pure code exposes the evaluation order of (+).
17:42:58 <dolio> So the value of pure expressions would no longer be independent of evaluation order, up to definedness.
17:43:12 <dolio> Which is the definition of purity.
17:43:21 <dolio> Or part of it, anyway.
17:43:30 <monoidal> thanks, I understand now
17:45:49 <dolio> Conceivably, the compiler could reorder the evaluation, too.
17:46:05 <dolio> Which would be invalid if purity were not maintained.
17:46:30 <dolio> So throw x + throw y would look like throw x in one place, and throw y in another.
17:46:42 <blackh> danderson: Great stuff! (I had a read of the code.) One thing you could think about is whether it can be used with CGIT in the CGI module.  The exception catching issue can come up there.  (I don't know the answer to this.)
17:46:56 <dolio> Which is a violation of referential transparency.
17:47:09 <dolio> Or something like that.
17:47:51 <danderson> blackh: noted, sounds useful.
17:49:39 <danderson> blackh: actually, is it okay if I dump your Transformer.hs into the repository, as reference material for 0.2?
17:50:08 <danderson> if I don't version control it, with my organizational skills I'm sure to lose it eventually. However, I can see that it may be a problem with your work.
17:50:39 <russell_h> is there a way to express a patern like (x:xs) "in reverse", ie, (xs:x) such that x is the tail of the list?
17:51:45 <blackh> danderson: Sure - go ahead.  The company doesn't care too much about the copyright so we can change the license if it's annoying that it's BSD3.  Just trying to get some free publicity out of it. :)
17:52:03 <quuxman>     
17:52:04 <blackh> But it's only 70 lines of code.
17:52:05 <Cale> russell_h: nope -- the operation of splitting the last element off of a list is O(n) as well. You could use a where clause with init and last
17:52:22 <Cale> russell_h: But normally you try to avoid it if you can.
17:52:40 <danderson> blackh: nah, that's cool, forkable-monad is BSD3 as well. I'll commit as-is, leaving the author and copyright statements intact for the leet credz.
17:53:51 <russell_h> Cale: ok, thanks!
17:53:51 <blackh> We don't necessarily deserve free publicity for a mere 70 lines of code.  We'll contribute a whole lot of stuff when we've finished this project.
17:55:17 <Cale> russell_h: Oh, you might want to try view patterns. If you define a function initLast :: [a] -> ([a],a), say, you could use a view pattern like foo (initLast -> (xs,x)) = ...
17:55:54 <aavogt> aka reverse
17:56:21 <danderson> meh, credit is credit, no matter how small :)
17:57:08 <aavogt> > let f (reverse -> ('a':(reverse -> xs)) = "ends in a" in f "ohla"
17:57:09 <lambdabot>   <no location info>: parse error on input `='
17:57:19 <aavogt> > let f (reverse -> ('a':(reverse -> xs))) = "ends in a" in f "ohla"
17:57:20 <lambdabot>   "ends in a"
17:58:33 <Cale> Ah, right, view patterns are nicely composable :)
18:01:28 <monoidal> :t fmap . ask
18:01:29 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, MonadReader (a -> b) f1, Functor f1) => f1 (f a -> f b)
18:01:41 <dolio> Why the second reverse?
18:02:06 <monoidal> hm. GHC asked ":t fmap . ask" tells me the same type as fmap
18:04:47 <monoidal> :t (fmap . ask) :: (Functor f) => (a -> b) -> (f a -> f b)
18:04:48 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:05:50 <ddarius> > ask 3
18:05:51 <lambdabot>   3
18:06:14 <aavogt> dolio: depends how you want to look at the right end of the list
18:06:32 <monoidal> oh. ask is identity for (->) instance of MonadReader
18:06:33 <aavogt> either as a mirror image, or as just splitting of the last element
18:06:51 <dolio> Well, you're not even looking at it.
18:07:11 <aavogt> yes
18:07:22 <ddarius> :t ap ask ask
18:07:23 <lambdabot> Top level:
18:07:23 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
18:07:23 <lambdabot>       Expected type: a -> b
18:07:38 <dolio> :t asks ask
18:07:39 <lambdabot> forall r (m :: * -> *). (MonadReader r m) => m r
18:08:01 <aavogt> dolio: it's for pedagogical purposes
18:08:08 <dolio> Ah, okay.
18:09:25 <QtPlatypus> I'm looking for a function [a] -> [a] -> [a] which would alternate between elements from the two lists given, I tried hoogle and didn't see anything like that, I've written my own function to do it but if there is something from the prelude or standard libaries that does it I would prefer to use it.
18:11:02 <pastorn> @pl (\(x,y) -> (x : y))
18:11:02 <lambdabot> uncurry (:)
18:11:19 <aavogt> @type curry curry curyy
18:11:20 <lambdabot> Not in scope: `curyy'
18:11:23 <aavogt> @type curry curry curry
18:11:23 <lambdabot>     Couldn't match expected type `(a, b)'
18:11:24 <lambdabot>            against inferred type `(a1, b1) -> c'
18:11:24 <lambdabot>     In the first argument of `curry', namely `curry'
18:11:35 <pastorn> aavogt: stop that
18:11:38 <pastorn> i'll get a headache
18:11:44 <ddarius> QtPlatypus: I don't think there is anything as good as a straight-forward recursive definition.  It is probably defined in some library somewhere though.
18:11:47 <aavogt> it works for uncurry
18:12:13 <pastorn> @pl (\(x,y) -> (x : y :))
18:12:13 <lambdabot> uncurry ((. (:)) . (:))
18:12:22 <monoidal>  \a b -> concatMap (\(x,y) -> [x,y]) $ zip a b
18:12:35 <hpaste>  . (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24957
18:12:40 <monoidal> for same length lists
18:14:32 <defun> hey guys. I have an open source question. Let's say I release code under one of BSD/GPL/MPL. And I have a copyright (c) defun 2010. If someone modifies and redistributes, do they replace my copyright, with theirs or do they add additional copyright or what?
18:14:48 <danderson> silly question, but how do I install the documentation for the ffi and rts packages? Since they're not on hackage, I can't just trick a rebuild with cabal install --reinstall with the appropriate config options.
18:14:53 <ddarius> > let f xs ys = concat (transpose [xs,ys]) in "ace" "bdfh"
18:14:54 <lambdabot>   Couldn't match expected type `t1 -> t'
18:14:54 <lambdabot>         against inferred type `[GHC....
18:14:55 <pikhq> defun: Additional.
18:15:00 <ddarius> > let f xs ys = concat (transpose [xs,ys]) in f "ace" "bdfh"
18:15:01 <lambdabot>   "abcdefh"
18:15:33 <defun> pikhq: thanks.
18:16:47 <ddarius> defun: What they would be copyrighting is their changes.
18:18:20 <glguy> Eelis: I'm just hesitant to release is for such a non-change and cause people all over to have cabal start downloading it and rebuilding
18:18:52 <glguy> I guess as there aren't likely to be a lot of other changes that a release could be OK
18:19:45 <rodriago> can someone help me with a libraries and directories problem in windows?
18:19:56 <defun> ddarius: I see. Even better.
18:20:08 <Cale> rodriago: What is the problem?
18:20:17 <Cale> (I don't use windows, but I might know anyway)
18:20:43 <rodriago> Cale: I have installed with cabal install the hmatrix package
18:21:04 <Cale> okay
18:21:21 <rodriago> Cale: but when I try running the tests it doenst recognize the modules
18:21:47 <Cale> do  ghc-pkg list hmatrix
18:22:47 <Cale> (does it show up?)
18:22:54 <rodriago> yeah
18:23:15 <Cale> okay, how are you trying to run the tests?
18:23:30 <Cale> uh, oh, does it show up in parens by any chance?
18:24:09 <rodriago> well the package has some tests in it, they just import Numerical.LineralAlgebra.Tests and run some
18:24:21 <rodriago> but it doesnt recognize the module
18:24:38 <vermin_slam> hello, still having some trouble installating yi ("cabal install yi") (I got some help yesterday, so I came back XD, thanks btw). The one problem I'm having now is a parse error in a file that makes up the package dyre-0.8.2. I'm too noob to understand what is broken about the file, could someone take a look? (I'm trying to get yi installed so I can study some real haskell and learn.)
18:24:48 <hpaste>  yi installation failure (error + code) (vermin_slam)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24958
18:25:41 <gwern> > 28 + 26
18:25:42 <lambdabot>   54
18:26:14 <gwern> looks like for some reason CPP isn't doing {-# LANGUAGE ForeignFunctionInterface #-}
18:26:28 <gwern> I wonder what '#if defined(mingw32_HOST_OS) || defined(__MINGW32__)' should actually be
18:26:46 <gwern> vermin_slam: I think it should work if you remove the cpp pragmas from around that FFI extension
18:26:52 <rodriago> :Cale do you have any idea wht could it be?
18:27:16 <Cale> rodriago: I'm not sure. If you could put the full error message on hpaste, I might be able to get a better idea
18:28:13 <vermin_slam> hmm, i think i see what you mean, i'll try it
18:28:22 <rodriago> :Cale ok I'll do that
18:31:00 <hpaste>  module issues (rodriago)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24959
18:31:54 <gwern> vermin_slam: work?
18:32:11 <vermin_slam> dyre built, i'm waiting to see whether yi builds too
18:32:18 <vermin_slam> thanks a ton :)
18:32:23 <timofonic> :rodriago uhhh?
18:32:28 <timofonic> Nothing happens
18:32:39 <vermin_slam> i don't think I ever would have figured that out
18:32:45 <rodriago> I'm getting that error and I have the package installed
18:33:04 <mun> does it make sense in a first order logic theory to define a term twice? e.g., foo ::= x + y and foo ::= a * b?
18:33:26 <Cale> rodriago: Is there a directory called 'Numeric' in the current directory?
18:33:32 <dolio> What's ::=?
18:33:46 <gwern> vermin_slam: you just needed to count the lines
18:33:50 <mun> dolio, a definition operator
18:33:52 <ddarius> mun: It depends on how you define the scoping, but no it doesn't, a priori, make sense to try to give the same name two different definitions.
18:34:05 <rodriago> no, but the library shows up in ghc-pkg list hmatrix
18:34:10 <gwern> vermin_slam: although it does help to be able to connect the FFI extension to an error on an ffi statement...
18:34:29 <aavogt> -fffi
18:34:37 <ddarius> What aavogt said.
18:34:54 <aavogt> perhaps that's being passed by cabal
18:35:05 <vermin_slam> one line missing, so you went to the inclusion guards, that makes sense
18:35:48 <dolio> mun: I don't think 'definition operators' would typically be part of a first-order theory. They'd be meta-level phenomena.
18:36:06 <tromp_> > showIntAtBase 8 intToDigit  76633  ""
18:36:07 <lambdabot>   "225531"
18:36:15 <mun> ddarius, but from a logic viewpoint, it's often the case isn't it? assume one wants to axiomatise physics and define velocity: v ::= momentum / mass; v ::= sqrt(2*kinetic energy / mass); etc.
18:36:21 <tromp_> > showIntAtBase 8 intToDigit  8329  ""
18:36:22 <lambdabot>   "20211"
18:36:31 <mun> dolio, yes, that'd be in the meta-level.
18:36:38 <ddarius> mun: One is a definition, the other a theorem.
18:36:44 <danderson> If anyone is still interested, revised documentation for the generic forkIO: http://natulte.net/random/forkable-monad/Control-Concurrent-Forkable.html
18:36:53 <ddarius> It would be meaningluss to have them both be definitions.
18:37:05 <rodriago> Cale: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24959#a24960 there it shows the ghc-pkg outputs
18:37:14 <tromp_> > showIntAtBase 8 intToDigit  66633  ""
18:37:15 <lambdabot>   "202111"
18:37:25 <danderson> Saizan: if you have a second to take a look, does the above update better convey what forkIO is doing to the monad stack?
18:38:15 <dankna> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24954#a24954 -- anybody around able to help with this?  I'm thinking it may simply be the case that MPTCs and fundeps can't do what I want.  Would type families help?  I've never used them before...
18:38:21 <mun> right
18:38:22 <mun> thanks
18:38:23 <dmwit> > 0o202111
18:38:24 <lambdabot>   66633
18:39:04 <Cale> rodriago: I just tried installing hmatrix 0.8.3.1 with cabal install hmatrix, and then I unpacked the package and tried the same command you were using (albeit on linux), and it worked.
18:39:10 <Cale> rodriago: hmm
18:39:24 <Cale> rodriago: If you try importing that module from ghci, will it load?
18:39:28 <dankna> I /think/ it's saying that it doesn't know the types of innerResult and outerResult in the recursive calls
18:39:36 <rodriago> Cale: No, that doesnt work either
18:39:42 <dankna> which is true, because they aren't relevant to those calls
18:40:10 <rodriago> Cale: sadly changing to linux isnt an option now :P
18:40:23 <dmwit> dankna: Each type in a class should include enough of the type variables to fix all of them.
18:40:32 <dankna> dmwit: hmm.......
18:41:11 <dankna> dmwit: so in principle the fundeps innerResult -> m, outerResult -> m would work, except that I can't use those because they're untrue and over-restrictive?
18:41:16 <dmwit> dankna: For example, the value "suspend :: m state" doesn't have enough information to fix the types of innerResult and outerResult, so it won't know which class instance to choose.
18:41:27 <blackh> Err... fmapM ?
18:41:38 <dankna> dmwit: hmmmmm.....  so I need to make innerResult and outerResult not be part of the MPTC then, I guess.
18:41:42 <dmwit> dankna: No, you can't use them because they're not restrictive enough. =)
18:41:46 <dankna> dmwit: oh :)
18:42:03 <dolio> You could split out suspend.
18:42:09 <dolio> And unsuspend.
18:42:12 <aavogt> dankna: you can add a Num constraint, then use the  default keyword
18:42:17 <dankna> make them not part of the typeclass?
18:42:22 * aavogt hides
18:42:25 <dolio> Make them a separate type class.
18:42:28 <dankna> hmm
18:42:30 <dankna> good idea
18:42:30 <dmwit> dankna: Make them part of a separate class, yes.
18:42:31 <dolio> With only m and state parameters.
18:42:46 <dankna> that makes a lot of sense.  I'll try it and report back :)
18:42:59 <dolio> And then have the resume class depend on that class.
18:43:02 <dankna> right
18:43:57 <Cale> rodriago: How about ghc --make examples/tests.hs
18:43:58 <dmwit> suspend and unsuspend look an awful lot like get and put from MonadState.
18:44:02 <Cale> any difference?
18:44:11 <dmwit> dankna: (that was aimed at you)
18:44:19 <rodriago> Cale: gets the same error as runhaskell
18:44:42 <dankna> dmwit: they are.  in fact they're basically nops on non-state-like monads.
18:44:52 <Cale> rodriago: Okay, and  ghc -package hmatrix examples/tests.hs  ?
18:45:14 <dmwit> dankna: Are they enough like it that you could get away with class MonadState s m => SuspendableMonad ...?
18:45:28 <Cale> rodriago: maybe something weird happened while installing hmatrix
18:45:48 <dankna> I don't think so, I want them to eventually work on readerT and writerT too
18:45:48 <Cale> rodriago: It looks installed, but if the exposed modules aren't there, something is wrong.
18:46:10 <rodriago> Cale: I'll add the error I got with the last one to the file
18:46:26 <dmwit> dankna: I don't see how that changes the answer to my question.
18:46:33 <dankna> hm
18:46:52 <dankna> let me look at the definitions of readerT and writerT then
18:46:57 <dankna> I'll just be a moment
18:47:02 <dmwit> dankna: Surely if you can write suspend and unsuspend, you can write get and put (which have the same types).
18:47:13 <dankna> oh
18:47:14 <dankna> duh
18:47:17 <dankna> yes, I can, you're right
18:47:34 <dankna> okay, how does using MonadState as the context help?
18:47:44 <dmwit> dankna: It gives you suspend and unsuspend. =)
18:47:47 <dankna> oh!
18:47:49 <dankna> er, yes, so it does
18:47:52 <dankna> good
18:48:16 <rodriago> Cale: ok, I added it http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24959#a24961
18:48:45 <Cale> aha
18:48:54 <Cale> So the installation of hmatrix is broken
18:49:08 <rodriago> Cale: seems so :P
18:49:30 <rodriago> Cale: I'll try reinstalling it
18:51:23 <rodriago> Cale: didn't work, I tried cabal install --user --reinstall, which had no problem, but still has the same error as before
18:51:47 <Cale> ghc-pkg check
18:52:11 <rodriago> Cale: no problems there
18:52:14 <blackh> So, how would I define a function that works like mapM, except that it works with any functor instead of just with lists.  Anyone know this one?
18:52:14 <Cale> hmm
18:52:27 <danderson> well, darn. I'm all ready to upload my first haskell package to Hackage, I've linted and checked it for errors and warnings, it's all good to go
18:52:33 <danderson> ... And I don't have a Hackage account.
18:52:41 <danderson> I guess that means bed time and upload tomorrow :)
18:52:45 <fax> blackh, f (m a) -> m (f a) ? not possible
18:52:57 <Cale> Well, it seems to be reporting that something is wrong with the QuickCheck-1.2.0.0 and haskell98-1.0.1.1 packages
18:53:20 <rodriago> Cale: I'll try reinstalling them
18:53:23 <Cale> blackh: It's not quite possible, but that's what Data.Traversable is for
18:53:25 <dmwit> blackh: Check out Traversable/Foldable.
18:54:38 <rodriago> Cale: didn't work, same problems
18:54:56 <Cale> :/
18:55:03 <Cale> I'm not sure what's going on there.
18:55:25 <blackh> Sounds like the right track - the type would be something like (Traversable f, Monad m) => (a -> m b) -> f a -> m (f b)
18:55:42 <rodriago> Cale: wish someone was, I've been trying to do that for a whole day
18:55:48 <blackh> Aha - mapM from Traversable looks right
18:56:42 <vermin_slam> gwern, thanks, yi installed!
18:56:43 <aavogt> it works for applicative too!
18:57:42 <Cale> rodriago: I don't even have QuickCheck-1.2.0.0 at the moment though... hmm
18:57:43 <vermin_slam> off to more mundane things, work to do and whatnot, cya guys
18:57:51 <blackh> It works!  I like Haskell.  Did I mention that?
18:58:00 <Cale> (I have 2.1.0.3)
18:58:20 <rodriago> Cale: I'll check my version
18:59:41 <rodriago> Cale: cabal info QuickCheck says I have that version as well
19:00:21 <Cale> Maybe try  ghc-pkg hide QuickCheck-1.2.0.0
19:01:41 <rodriago> Cale: did it, with no problems, but the error is still there, the same one
19:02:21 <Cale> okay, now that the old version is hidden, try rebuilding hmatrix. Maybe it'll compile against the new one.
19:02:37 <rodriago> Cale: ok
19:04:30 <rodriago> Cale: ok, I reinstalled hmatrix, but the error is still there
19:05:53 * blackh needs more applicative foo
19:07:25 <Cale> rodriago: okay, I have no idea...
19:07:40 <rodriago> Cale: okay, thanks anyway ^^
19:07:47 <Cale> Hey, are there any actual windows users to help rodriago try to work out what's wrong? :)
19:08:27 <dankna> not me, heh
19:13:06 <interferon> so do GADT's make dependent typing unnecessary?
19:13:08 <gwern> 'Haskell actually is quite useful - in one context. It's an excellent teaching language for advanced students in a first-rate undergraduate CS program. Learning Haskell cannot help but teach you many challenging concepts, and it is inevitable that those who are both smart and dedicated will master these concepts. The rest will not. And thus the university system performs its principal function, the assignment of rank. If you venture to suggest that the ...
19:13:14 <gwern> ... same function could be performed, at two orders of magnitude less cost, by an IQ test and three weeks at Parris Island, you are probably some kind of a fascist.'
19:13:17 <gwern> heh. http://unqualified-reservations.blogspot.com/2007/08/whats-wrong-with-cs-research.html
19:13:48 <dankna> IQ tests don't work, haha
19:13:50 <dolio> interferon: No.
19:14:13 <blackh> I don't even know where Parris Island is.
19:14:22 <dankna> isn't it in Vietnam?  heh
19:14:38 <gwern> mencius is insane, of course, as he then goes on to say function composition is obfuscation and higher order functions bad
19:14:43 <gwern> but it's a funny insane
19:14:51 <gwern> blackh: off the coast of one of the carolinas, iirc
19:15:04 <gwern> (parris island is, of course, the marine island)
19:15:08 <dankna> and no, it's a training center.  but I was at least right about the military association.
19:15:39 <Adamant> Mencius really hates type systems
19:16:17 <goomba> that is one of the longest blog posts i have ever seen
19:16:25 <Adamant> he's not completely off about university systems being about ranking, though.
19:16:36 <tensorpudding> anything higher than the untyped lambda calculus is unnecessary obfuscation
19:16:40 <dankna> oh certainly; I'm not arguing that
19:17:11 <gwern> Adamant: well, he is right that type systems have generated an astounding amount of work for academia, and I'm not sure they've panned out that much in practice
19:17:31 <Adamant> gwern: I agree there, and I like type systems.
19:18:03 <timofonic> The univerity system performs its principal function: segmentation and limit access of useful information to people. And other negative things
19:18:32 <Adamant> I do think we're getting to the point we have pretty coherent methods of scaling software correctness.
19:18:42 <gwern> 'Certainly this is the style of every attempt to teach Haskell that I've ever seen. It is all done on a tutorial basis. You learn by doing. Whereas when you see a language like Python, or even a language like C, taught, ordinary programmers tend to learn from documents - K&R being the great classic - that are hardly more than annotated versions of the reference manual. If you tried to teach Haskell this way half the class would die of a brain aneurysm.'
19:18:46 <Adamant> depending on how much correct you want.
19:19:10 <Adamant> K&R was classic for the late 1970's
19:19:14 <timofonic> K&R is unsmokable
19:19:16 <Adamant> it's horrible in a modern context
19:19:52 <timofonic> It's valid for the armchair and such...
19:19:59 <timofonic> Adamant: Always has been :)
19:20:47 <timofonic> Adamant: They should have given those annotations to specialized pedagogists :P
19:20:59 <kniu> So.
19:20:59 <timofonic> Adamant: Or more experience people on the matter :P
19:21:04 <Adamant> timofonic: it's kind of like 'Applied Cryptography' in that if you just think you can do activity X well by reading that book, you are wrong, wrong, wrong
19:21:10 <kniu> When are you guys removing the monomorphism restriction?
19:21:18 <fax> right NOW
19:21:26 <kniu> DO IT
19:21:49 <timofonic> No, I'm tired now. Tomorrow :D
19:21:52 <monoidal> :set -fno-monomorphism-restriction
19:22:10 <aavogt> get with the times -XNOMONOMORPHISMRESTRICTION
19:22:47 <dolio> Are you from the future, where flags are all caps?
19:23:06 <danderson> his cool is on cruise control
19:23:11 <timofonic> Adamant: He comes from Gentoo maybe...
19:23:31 <danderson> (because capslock is cruise control for cool, even if you still have to steer)
19:24:04 <timofonic> Capslock is and useless key...
19:24:17 <timofonic> Better suited as a function key :P
19:24:21 <aavogt> dolio: just like ghci's :browse! command!
19:24:33 <aavogt> extra emphasis where it counts
19:24:58 <timofonic> aavogt: right!!!!!!!!!111111111111111111111111111111
19:25:21 <aavogt> see :browse! for yourself
19:26:12 <timofonic> WeeChat and from MIT, oh you are cooler...
19:26:39 <timofonic> Away, see you
19:28:13 <monoidal> is there any REPL (like GHCi) that allows to define types?
19:28:21 <kmc> maybe Hugs does?
19:28:35 <monoidal> it doesn't
19:28:38 <aavogt> you can script ghci such that it can
19:28:53 <monoidal> what do you mean?
19:28:54 <aavogt> that is, you abuse :def  to get ghci to load a file
19:29:06 <aavogt> whose contents define your types
19:29:11 <kmc> clever
19:29:48 <aavogt> somebody pasted a serious script that did this
19:29:52 <aavogt> but I don't recall
19:42:51 <hpaste>  . (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24962
19:43:08 <Mathnerd314> @help spell
19:43:08 <lambdabot> spell <word>. Show spelling of word
19:43:25 <Mathnerd314> ?
19:47:58 <dankna> @spell spell
19:48:21 <patch-tag> hey I'm trying to install hdbc-odbc (git head from git clone git://git.complete.org/hdbc-odbc) and getting
19:48:23 <patch-tag> dist/build/Database/HDBC/ODBC/Connection_hsc_make: error while loading shared libraries: libodbc.so.1: cannot open shared object file: No such file or directory
19:48:25 <patch-tag> any idea?
19:48:54 <dmwit> Have you got ODBC installed, including the -dev package (if any)?
19:49:20 <patch-tag> I installed from source, after initially apt-getting
19:49:34 <patch-tag> and I can connect to db using isql
19:50:00 <patch-tag> locate libodbc.so.1 shows up /usr/local/lib/libodbc.so.1
19:50:04 <dmwit> Is libodbc.so.1 in your LIBRARY_PATH...?
19:50:25 <patch-tag> nothing's in LIBRARY_PATH
19:51:30 <Saizan> is libodbc.so.1 an ld script or the real binary?
19:51:55 <Saizan> the ghci linker doesn't like ld scripts, though i'm not sure if it's involved here
19:52:04 <patch-tag> export LIBRARY_PATH=/usr/local/lib, cabal install again -> same error
19:52:12 <patch-tag> how can I tell?
19:52:23 <patch-tag> oh I guess if it's text
19:53:12 <patch-tag> lrwxrwxrwx 1 root root 16 2010-04-19 19:09 /usr/local/lib/libodbc.so.1 -> libodbc.so.1.0.0
19:53:13 <patch-tag> thartman@ubuntu:~/haskellInstalls/hdbc-odbc>ls -l /usr/local/lib/libodbc.so.1.0.0
19:53:13 <patch-tag> -rwxr-xr-x 1 root root 1760888 2010-04-19 19:09 /usr/local/lib/libodbc.so.1.0.0
19:53:38 <patch-tag> and the link target is a binary
19:54:10 <dmwit> odd
19:54:34 <patch-tag> is installing from source usually the same result as package-dev?
19:54:38 <patch-tag> I never really understood that.
19:55:00 <dmwit> They're generally comparable.
19:56:14 <appamatto> Is there a good resource for learning about instances?  I'm trying to use Data.Heap for a MinHeap of lists that calculates priorities based on the first element of the list
19:57:09 <appamatto> I'm not sure how to "override" the Data.Heap.split method for my type
19:58:29 <appamatto> For instance, instead of inserting (priority, list) I would like to insert list and have the priority calculated in some way that I define
19:59:45 <Veinor> appamatto: you could just write a wrapper function insertWithPrio
20:00:16 <aavogt> is that method a member of the typeclass?
20:00:21 <Veinor> it is
20:00:32 <Veinor> :t split
20:00:33 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
20:00:38 <Veinor> :t Data.Heap.split
20:00:39 <lambdabot> Couldn't find qualified module.
20:00:58 <Veinor> bah
20:01:57 <appamatto> Veinor, yes that's a possible solution
20:01:58 <Mathnerd314> @type (.)
20:01:59 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:02:09 <Mathnerd314> is this the origin of that? http://blog.willdonnelly.net/2009/08/24/the-magic-dot/
20:02:19 <aavogt> @type flip (.)
20:02:20 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
20:02:25 <dmwit> appamatto: Well, there's an example in the documentation.
20:02:43 <dmwit> appamatto: Not so many libraries use associated types, so that's kind of neat.
20:03:20 <ddarius> So, the species of lists, L, is equal to Π_i (1 + X^(2^i)) which is essentially a positional (numeric) representation.  For a list of length n, we choose 1 or X^(2^i) depending on whether the ith bit of n is clear or not.
20:04:03 <ddarius> Mathnerd314: No.
20:05:27 <appamatto> dmwit, which example are you referring to?
20:05:52 <dmwit> http://hackage.haskell.org/packages/archive/heap/1.0.0/doc/html/Data-Heap.html#t%3AHeapItem
20:05:58 <dmwit> data Max Policy, etc.
20:06:02 <dmwit> err
20:06:05 <dmwit> data MaxPolicy -- of course
20:06:06 <appamatto> dmwit, the example in Data.Heap docs uses instances to create a new kind of heap policy, whereas I'm trying to modify the behavior of the value
20:06:33 <Mathnerd314> ddarius: what is?
20:06:44 <aavogt> newtype an allowed keyword for associated types?
20:07:11 <dmwit> appamatto: That class seems to be exactly the one you want to make an instance for, no?
20:07:43 <appamatto> Right, ... maybe?  I really don't know :p
20:07:44 <dmwit> appamatto: e.g. split would be the function that computes a priority given your list
20:07:46 <aavogt> I'm quite confused by that documentation, dmwit
20:08:00 <appamatto> basically I have no idea what that code does
20:08:23 <dmwit> appamatto: All the magic is in the Ord instance.
20:08:35 <aavogt> it has an associated   data and an associated type
20:08:38 <dmwit> appamatto: Notice that it switches the argument order: compare (MaxP x) (MaxP y) = compare y x
20:08:46 <ddarius> Mathnerd314: Probably just simple observation.  It's not hard to see.  Certainly, for as long as the reader monad has been known would be a latest point, but really categorists have realized this for as long as category theory existed.
20:08:47 <dmwit> appamatto: So it turns a min heap into a max heap.
20:09:08 <aavogt> it looks  like a typo that it uses  newtype there, no?
20:09:19 <dmwit> I think newtype is fine.
20:09:29 <dmwit> Although I admittedly don't know much about associated types.
20:09:42 <appamatto> That makes sense
20:10:31 <dmwit> appamatto: It just turns out that computing the "priority" here was trivial, so "split" doesn't seem to do much, but in your case of course split would be the one doing all the work and compare would be the trivial one.
20:10:58 <appamatto> So I would be defining a new "policy", not necessarily a new behavior for my type for the existing policies?
20:11:05 <Mathnerd314> ddarius: but Control.Category defines (.) :: cat a b -> cat c a -> cat c b
20:11:19 <dmwit> appamatto: probably, yes
20:11:29 <appamatto> I see
20:11:33 <Mathnerd314> ddarius: and I don't see how that fits (.) = fmap
20:11:33 <aavogt> oh, you are allowed associated newtypes
20:12:40 <kmc> a newtype is fine too
20:12:49 <dmwit> Mathnerd314: All small categories form a category with functors as arrows.
20:12:53 <kmc> there's no "newtype family" but you can have a "newtype instance" of a "data family"
20:13:04 <dmwit> Mathnerd314: So (.) = fmap in that category.
20:13:14 <aavogt> I've only needed  'type' and not 'data'
20:13:27 <ddarius> dmwit: Wrong directionality for that =
20:13:27 <appamatto> Thank you for your help
20:13:41 <dmwit> you're right
20:14:58 <ddarius> Mathnerd314: In any category (not restricting to Haskell), (.) is the action of the covariant Hom-functor on arrows.
20:17:59 <Mathnerd314> ddarius: you lost me at "covariant"
20:20:09 <ddarius> Mathnerd314: If we generalize functor to operate between arbitrary Categories, class (Category cat, Category cat') => CatFunctor cat cat' f where catMap :: cat a b -> cat' (f a) (f b), then this generalizes the normal Functor class and we have instance (Category cat) => CatFunctor cat (->) (cat c) where catMap = (.)
20:20:15 <BMeph> Mathnerd314: 1) Category (->); 2) Functor ((->) t)
20:24:37 <ddarius> As a side note, the functors whose action is equivalent to (.) are very special in CT.
20:26:34 <fax> what is the action fo a functor action?
20:26:35 <ddarius> As an extremely simple example of this phenomenon, the functor data Double a = Double a a is equivalent to the functor (Bool -> a) [each functorial in a].
20:27:14 <ddarius> (Ignoring bottoms a bit.)
20:28:04 <ddarius> (It might actually work out even not ignoring bottoms since adding a bottom element is a colimit...)
20:36:13 <Saizan> very special?
20:36:48 <codolio> They're called 'representable functors', I believe.
20:37:00 <codolio> And they get used all over.
20:40:46 <Mathnerd314> so... there are 3 (.)'s - Prelude.., fmap, and Category..
20:41:24 <Mathnerd314> Prelude.. is an instance of both of the others
20:41:40 <ddarius> Saizan: What codolio said.  In my opinion category theory almost -is- the study of representable functors.
20:42:11 <ddarius> Mathnerd314: There's also (>>>)
20:42:20 <Mathnerd314> :t (>>>)
20:42:21 <mail> wonder how hard it is to implement pushdown automata in haskell
20:42:21 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
20:42:35 <ddarius> Well, I guess that has been absorbed into Category now.
20:42:43 <ddarius> mail: Not hard at all.
20:42:47 <Mathnerd314> yeah Category.. == (>>>)
20:42:55 <ddarius> But then they aren't hard to implement in any language.
20:43:18 <mail> gotta do it in C
20:43:31 <mail> but I think it would be easier in haskell
20:43:42 <ddarius> mail: It would.
20:44:20 <kmc> pretty easy in either language
20:44:24 <kmc> easier in Haskell
20:45:27 <Mathnerd314> so there's some sort of square lifting thing; prelude.. -> (>>>) and fmap -> catMap?
20:46:49 <Mathnerd314> can I define a functor instance for category?
20:48:25 <ddarius> If you mean a Functor instance, then not in general, because there's no way to turn a -> b into cat a b, but you could for an Arrow as it includes an operation that does just that.
20:49:01 <ddarius> I'm not sure if the Haskell implementation will swallow a "general" instance though.
20:49:13 <ddarius> I doubt it.
20:50:18 <Saizan> instance Arrow a => Functor (a b) where -- should be definable with enough flags
20:50:30 <ddarius> instance (Arrow arr) => Functor (arr a) where fmap f = (arr f .)
20:50:47 <ddarius> Saizan: Yes, with some unpleasant flags.
20:55:04 <Mathnerd314> so arrows are functors, and functors are CatFunctors, and... where does it end? :p
20:55:53 <aavogt> when you don't have any useful instances
20:56:13 <ddarius> Mathnerd314: They are all special cases of categorical functors and CatFunctor is pretty much the best you can do for covariant functors in Haskell.
20:56:27 <BMeph> mail: Quick, before it's taken! Fill ot the pushdown automata Monad instance, and put it on Hackage! Hurry, time's running out! ;)
20:56:42 <BMeph> Fill *out...
20:56:58 <ddarius> BMeph: -Much- more likely to be a comonad.
21:00:04 <Mathnerd314> ddarius: your definition of CatFunctor looks like http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor-Categorical.html except with the functor at the end
21:00:42 <BMeph> :t (Control.Arrow.<<<)
21:00:43 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
21:01:07 <BMeph> :t (Control.Category..)
21:01:08 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
21:01:28 <ddarius> BMeph: The Monoid m => m -> a comonad models a simple type of automaton.
21:02:18 <ddarius> Mathnerd314: As I said, it's about the best you can do for covariant functors in Haskell.
21:02:53 <Mathnerd314> but there's no instance like you describe there
21:04:12 <BMeph> mail: See, ddarius has it already figured out, but it's too easy, so he'll let it sit - now is the time for you to Strike! ;)
21:04:14 <ddarius> Mathnerd314: All the instances listed there are equivalent to normal Functor instances.
21:07:03 <Mathnerd314> yeah; the source is just cmap = fmap
21:07:24 <Mathnerd314> so why didn't he do instance Functor f => CFunctor f Hask Hask?
21:08:43 <ddarius> Mathnerd314: Because the compiler won't accept that.
21:08:55 <Mathnerd314> ah, it requires UndecidableInstances
21:08:56 <Saizan> so when you've a representable functor you usually work with the isomorphic Hom functor?
21:09:34 <dolio> There are lots of theorems about hom functors. So if your functor is equivalent to one, you automatically get a bunch of results about it.
21:09:53 <ddarius> Saizan: You don't have to, but knowing that it is isomorphic to a Hom functor immediately gives you certain properties, e.g. continuity properties, specifically, all (covariantly) representable functors preserve all limits.
21:11:32 <Saizan> i see
21:13:44 <ddarius> Saizan: Also, the representative of a hom-functor usually "internalizes" the idea behind the functor.  E.g. if Hom is the Hom functor for a category C with products then the functor \X.Hom(X,A)xHom(X,B) [i.e. (pointwise) the cartesian product of sets] is represented by \X.Hom(X,AxB).
21:15:01 <ddarius> Note that that example is a special case of Hom preserving limits.
21:16:28 <greedo> How many strings with five or more characters can be formed from the letters SEERESS?
21:17:28 <ddarius> > product [1..7] `div` 36
21:17:29 <lambdabot>   140
21:17:47 <greedo> that low
21:18:01 <greedo> really?
21:18:08 <ddarius> Oh, I solved a different problem.
21:18:16 <nus> 36?
21:18:41 <dolio> 140 is the number of unique permutations, no?
21:18:49 <ddarius> dolio: Yep.
21:19:11 <dolio> I don't think I've seen a good formula for the problem in question.
21:19:11 <greedo> that seems too low
21:19:12 <ddarius> nus: 6^2
21:20:19 <nus> 'with five or more characters' suggests infinity?
21:20:44 <ddarius> nus: The longest string is seven characters.
21:20:55 <greedo> no
21:22:21 <greedo>  5<=x<=7
21:23:59 * BMeph thinks ddarius and edwardk should collaborate on a blog, called..."The CT Limits"... :D
21:24:05 <ddarius> greedo: Using a bit of brute force, you only need to consider 30 cases many of which are redundant and so the number of cases to consider is less than that.
21:24:14 <dolio> Anyhow, ddarius' number comes from n!/(i! * j! * k! * ...), where n is the total number of characters, and i, j, k, etc are the multiplicities of each character.
21:24:55 <ddarius> E.g. see the multinomial coefficient.
21:26:35 <greedo> ddarius: so that's how you got 36?
21:26:55 <ddarius> 7!/3!1!3!
21:26:55 <dolio> 36 = 3! * 3! * 1!
21:27:08 <greedo> thanks
21:27:21 <ddarius> That handles the exactly 7 character case.
21:27:57 <greedo> yes
21:28:18 <ddarius> Now you have the problem 7 more times with 6 characters and you know how to solve the exactly n character case now.
21:28:23 <greedo> i need the cases for 5 and 6
21:28:43 <ddarius> (And I see I had an off-by-one error, so there are 42 cases, but again, a significant amount of redundancy.)
21:29:07 <greedo> hmm, so for 6 cases
21:29:26 <ddarius> Really, there is only three cases and then two or three cases for each of those three cases, plus counting how many times each case comes up.
21:30:05 <greedo> > product [1..6] `div` 36
21:30:06 <lambdabot>   20
21:30:20 <ddarius> BMeph: I rather prefer (co)ends to (co)limits, or more generally, indexed (co)limits to (conical) (co)limits.
21:30:45 <ddarius> So 11 cases total.
21:31:18 <greedo> product [1..6] `div` 12
21:31:26 <ddarius> (well 12 if you count the 7 character one)
21:31:27 <greedo> > product [1..6] `div` 12
21:31:28 <lambdabot>   60
21:32:18 <kniu> how do I get what the precedence of an operator?
21:32:27 <dmwit> :info
21:32:32 <dmwit> :i for short
21:33:00 <kniu> okay
21:33:08 <greedo> hmm, would EERSSS be a unique solution from EEERSS
21:34:00 <nus> greedo, why not?
21:34:05 <ddarius> Yes, but you can exploit the symmetry to reduce the cases even more.
21:34:12 <ddarius> greedo: I would recommend drawing a tre.
21:34:13 <ddarius> tree
21:34:30 <kniu> is 0 higher or lower precedence than 1?
21:34:49 <greedo> love this discrete math
21:34:56 <dolio> 0 is lowest.
21:35:00 <nus> greedo, this is combinatorics
21:35:12 <ddarius> nus: Combinatorics arguably falls under discrete math.
21:35:26 <dancor> does C's cbrt() on doubles have any guarantee like it will be a double which is <= the exact cuberoot
21:35:34 <nus> ddarius, discrete math sounds as vague to me as Chinese
21:35:49 <kniu> okay, so if I set some operator to have precedence 999999999, it will most likely get applied before everything else?
21:35:58 <tensorpudding> Discrete math sounds disagreeable to me
21:36:07 <tensorpudding> as a general term
21:36:09 <dancor> discrete math makes sense to me..
21:36:27 <ddarius> nus: It's broad, not vague.
21:36:28 * QtPlatypus likes discrete math, doesn't trust continious.
21:36:37 <ddarius> QtPlatypus: Strict finitism ho!
21:36:38 * nus has seen like nth taxonomies for what discrete math is, each somehow unique
21:36:56 <tensorpudding> Combinatoric is a fancy way of saying counting
21:36:58 <dancor> i know it when i see it :)
21:37:18 <ddarius> nus: At any rate, for any reasonable notion of "discrete" math, combinatorics would certainly fall under it.
21:37:28 <tensorpudding> is algebra over a finite field discrete math?
21:37:29 <ddarius> At least, enumerative combinatorics would.
21:37:42 <nus> ddarius, sure. It's the core.
21:37:43 <ddarius> tensorpudding: Sure.
21:37:44 <dancor> combinatorics, in counting, is very much about integers
21:38:14 <Saizan> kniu: precedences range from 0 to 9, and prefix function application counts as >9 anyway
21:38:17 <tensorpudding> But obviously fields like R are not discrete
21:38:41 <ddarius> dancor: Wikipedia distinguishes within combinatorics calling combinatorics in general: "...the study of finite or countable discrete structures."
21:38:46 <dancor> http://en.wikipedia.org/wiki/Continuous_combinatorics
21:38:50 <greedo> what have i started
21:39:09 <ddarius> tensorpudding: Yes and fields like R aren't discrete math.
21:39:25 <ddarius> Certainly though, there is many blatant connections between continuous and discrete math.
21:39:42 <tensorpudding> I don't see "discrete math" as having any specific meaning
21:40:14 <dancor> i would say algebra over a finite field is discrete
21:40:15 <ddarius> tensorpudding: It's math dealing with discrete structures which seems pretty well-defined.
21:40:39 <tensorpudding> But what makes discrete structures worthy of being treated separately from continuous ones?
21:40:46 <greedo> > product [1..5] `div` 12
21:40:46 <lambdabot>   10
21:41:09 <greedo> > product [1..5] `div` 6
21:41:10 <lambdabot>   20
21:41:26 <tensorpudding> Is a finite-dimensional vector space a discrete structure?
21:41:27 <dancor> i think continuity frequently changes the game
21:41:28 <ddarius> tensorpudding: There are usually significant differences between discrete and continuous cases.
21:41:40 <greedo> > product [1..5] `div` 4
21:41:41 <lambdabot>   30
21:41:46 <tensorpudding> Or is it only discrete if it's a vector space over a finite field?
21:42:08 <ddarius> tensorpudding: I doubt it would be considered discrete when viewed over the reals or complex numbers.
21:42:15 <ddarius> It certainly would be over a finite field.
21:42:21 <tensorpudding> But what is the difference?
21:42:33 <ddarius> tensorpudding: Countable sets v. uncountable sets.
21:42:48 <ddarius> If you aren't using any uncountable sets, then you are almost certainly doing discrete math.
21:43:01 <dancor> man went on to prove that black equals white and was killed in the next zebra crossing
21:43:07 <dolio> Decidable (in)equality?
21:43:10 <tensorpudding> I mean, what is the qualitative difference in handling vector spaces over finite fields differently than those over fields which are not countable?
21:43:36 <greedo> gotta love blaise pascal
21:43:41 <ddarius> tensorpudding: No one said splitting mathematics into discrete v. continuous is always the best thing to do.
21:44:12 <tensorpudding> Hmm, is the discrete topology discrete mathematics?
21:44:55 <greedo> so i have: EEESS, EEESR, EESSR, EESSS
21:44:57 <ddarius> tensorpudding: It's a "cross cutting" concern to use software engineering speak, but there other ways to slice the domain.
21:45:01 <tensorpudding> Or any topology with a countable basis
21:45:10 <greedo> did i forget any for 5
21:45:51 <greedo> ESSSR
21:46:19 <dancor> the meta-cut is interesting, of areas-its-worth-splitting-on-discrete-vs-not vs when-its-not
21:47:51 <ddarius> tensorpudding: You can have a discrete topology on an uncountable set, and many uncountable sets have countable bases.  If your main object of study is an uncountable set or classes of uncountable sets, you are probably doing continuous mathematics.
21:48:14 <ddarius> tensorpudding: Certainly, discrete v. continuous is more well-defined than algebraic v. geometric.
21:48:31 <tensorpudding> I've never heard a good definition of either of them.
21:48:39 <tensorpudding> So I guess I could agree.
21:48:48 <dancor> but finite vs infinite is even cleaner
21:48:55 <ddarius> I gave a pretty strong definition above.
21:49:14 <tensorpudding> I meant, of neither algebraic nor geometric.
21:49:23 <dolio> Can't you do continuous mathematics with constructive reals, which would be countable (when viewed from classical mathematics)?
21:49:33 <ddarius> tensorpudding: There are, actually, some formal notions that correspond to that dichotomy.
21:49:56 <ddarius> tensorpudding: Look at Chu spaces.
21:50:21 <dancor> dolio: ya it gets interesting if you consider that computers/minds?/universe?/computation? are inherently discrete..
21:50:50 <ddarius> Indeed.  Most computing topics are considered to fall under the rubrik of discrete math.
21:51:05 <nus> dancor, don't confuse computers with universes
21:51:21 <dancor> which one are we in right now
21:51:32 <Saizan> yeah, universes are only there to prevent paradoxes
21:51:45 <dancor> unIOverse
21:52:15 <tensorpudding> I don't believe they are sure that the universe is discrete, but it does have a scale beyond which physics make any sense
21:52:30 <nus> dancor, "once in IO, always in IO" (-;
21:53:02 <dancor> anyway i guess you can do continuous math in a discrete proof system
21:53:27 <hpaste>  . (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24963
21:53:34 <dancor> axiomatized geometry
21:53:35 <ddarius> Logic is usually considered to fall under discrete math, so, arguably, all math is discrete math.
21:53:56 <dolio> Well, as far as I'm aware, people tend to represent constructive reals as Q -> Q, or N -> Q, or something of that sort (ignoring, say, abstract stone duality).
21:53:57 <tensorpudding> in what sense is logic discrete?
21:54:06 <dancor> {True, False}
21:54:18 <dolio> Or a quotient thereof, actually.
21:54:18 <nus> tensorpudding, F|T
21:54:26 <ddarius> tensorpudding: It's syntactic.  It's just manipulation of proof trees and they are definitely countable.
21:54:31 <nus> dancor, you were faster (-;
21:54:47 <dolio> Which would still be characterized as not having decidable (in)equality.
21:54:48 <tensorpudding> So why does that imply that "all math is discrete"?
21:54:52 <dancor> but it's still an examination of, or a statement about, something continuous
21:55:00 <dancor> platonically
21:55:24 <dolio> Of course, I'm not sure what you'd consider Q.
21:55:50 <nus> tensorpudding, there's no agreable upon definition of mathematics, what do you want, "characteristica universalis"?
21:56:12 <dancor> i still want to know what is the formal system in which godel's proof can be stated
21:56:16 <tensorpudding> I want to know what ddarius meant
21:56:31 <ddarius> tensorpudding: Because mathematicians, arguably, only manipulate proofs.  The end result is a countable (finite actually) amount of symbols on paper.  The rest is just imagination.
21:56:52 <tensorpudding> Does the fact that axiomatizations of set theory are countable mean that uncountable sets do not exist?
21:57:00 <Saizan> dancor: there's an implementation in Coq by roconnor
21:57:04 <dancor> ah
21:57:05 <ddarius> tensorpudding: The notion of "uncountable" is relative.
21:57:25 <tensorpudding> It has a perfectly well-defined meaning.
21:57:32 <dancor> Saizan: and is Coq more than ZFC
21:57:46 <ddarius> tensorpudding: Indeed, it does, but it is still relative.
21:58:11 <dancor> does it have extra axioms
21:58:15 <dolio> dancor: I think Coq has been shown equivalent to ZFC + an inaccessible cardinal, or something like that.
21:58:17 <dmwit> Everything is finite.
21:58:22 <dmwit> There is a largest number.
21:58:24 <dmwit> Prove me wrong.
21:58:39 <Saizan> (+1)
21:58:40 <tensorpudding> Does ZFC actually imply directly the existence of the tower of cardinals?
21:58:52 <dolio> Coq isn't really anything like ZFC, though.
21:58:56 <ddarius> tensorpudding: Set theory is axiomatized in first order logic and the Skolem-Lowenheim theorem says that all theories in first-order logic have countable models.  So, there is a countable model of sets which has "uncountable" sets, a seeming contradiction until you realize (and this is what led to the realization) that "uncountable" is a relative notion.
21:59:34 <tensorpudding> I need you to be more explicit of what you mean by relative.
22:00:50 <dolio> It means that there's no bijection *in the model* between the reals and the naturals, but the reals in the model may be meta-countable.
22:01:04 <tensorpudding> In any case, I'm not sure what a model means in this sense.
22:01:35 <dolio> So you can interpret uncountability as a lack of a certain sort of function, rather than a statement about how many things are in each set.
22:01:54 <ddarius> tensorpudding: http://en.wikipedia.org/wiki/L%C3%B6wenheim%E2%80%93Skolem_theorem and the pages it references.  It's worth reading regardless.
22:02:16 <dmwit> L-S is wack
22:02:49 <dolio> Which makes a lot of sense in thinking about constructive mathematics, where everything is sort of computable.
22:02:50 <dancor> i always thought it was cool that there are tiers such that one mathemetician's "theoretical math" is the "practical math" of a mathemetician one circle closer to hell
22:03:09 <ddarius> But yes, dolio got the gist of it for uncountability.  A set may be uncountable because we don't have enough "functions" to witness the bijection.
22:03:27 <dolio> So there are (classically) only countably many computable reals, but the computable reals are also computably uncountable, in that there are no computable bijections between the reals and the naturals.
22:03:47 <ddarius> dolio: Good point/example!
22:03:55 <ddarius> Recursive v. recursively enumerable.
22:04:58 <dolio> And Cantor's diagonal argument used in constructive math is one way to prove that.
22:05:08 <dancor> so you could consider that the reals and naturals have a bijection which is simply not computable?
22:05:09 <nus> dolio, could that be rephrased as "no dichotomy has exact boundaries"?-)
22:06:00 <dolio> nus: I don't really know what that means.
22:07:01 <ddarius> dancor: You could make an intuitionistic set theory and use a model in computable sets and the (computable) reals would not be computably countable and thus would be uncountable in that set theory, even though there are (as dolio said) classically only countable many computable reals.
22:08:08 <dolio> dancor: Oh, incidentally, it may be that Coq is equivalent to ZF + inaccessible cardinal(s). It seems unlikely to have C.
22:08:18 <dolio> I wasn't thinking.
22:08:43 <dancor> right, the diagonalization argument still says something even when you restrict to computable things
22:08:55 <dolio> And it may be IZF, unless you add the law of the excluded middle as an axiom or something.
22:09:37 <dancor> doesn't it make sense to have a very minimal core and then add various popular axioms
22:09:43 <nus> every dichotomy is a decision, some decisions are unagreeable upon in multi-decider model without a dictator/arbiter
22:09:43 <dancor> in places ppl want to use them
22:10:05 <dancor> a lot of these proof systems seem to be willy-nilly in their axiom selection..
22:10:56 <dancor> modular axioms ftw
22:11:24 <ddarius> dancor: Usually you want to encode your system into the given system (and this is the LF methodology) so that you are guaranteed consistency.
22:12:14 <ddarius> @djinn (EM a) => a
22:12:14 <lambdabot> Error: Class not found: EM
22:12:28 <ddarius> @djinn-add class EM a where em :: Either a (Not a)
22:12:35 <ddarius> @djinn (EM a) => a
22:12:35 <lambdabot> -- f cannot be realized.
22:12:59 <ddarius> @djinn (EM a) => Not (Not a) -> a
22:12:59 <lambdabot> f a =
22:12:59 <lambdabot>     case em of
22:12:59 <lambdabot>     Left b -> b
22:12:59 <lambdabot>     Right c -> void (a c)
22:14:02 <orclev> is there a webdevel channel, or would such questions be addressed in here?
22:14:16 <dmwit> Is it web development using Haskell?
22:14:20 <dmwit> If so, here's fine.
22:14:24 <orclev> yeah, happstack
22:15:20 <orclev> I had some code that was working, but recently it stopped and is complaining about not MonadIO instance for ServerPartT... only thing I can figure it I updated a module somewhere
22:15:33 <orclev> anyone know enought about happstack to point me in the right direction?
22:15:49 <orclev> s/not/no/
22:16:57 <Saizan> Happstack.Server.SimpleHTTP should be the module defining that type, in the happstack-server package
22:17:27 <orclev> hmm, guess I'll see if that's been updated recently
22:17:31 <dmwit> I'm not a happstack expert, but I think that even if I were, that wouldn't be enough information for me to help you. Things that might make it easier: the exact error you get, what version of happstack you're using, maybe some actual source code to stare at (say, on hpaste).
22:17:53 <Saizan> yeah, that'd help
22:18:29 <Saizan> there's also #happs btw, not sure how much lively it is though
22:18:29 <orclev> well, I can get all that together but it'll take a little while, I was sort of hoping this was a known problem with a recent update to happstack
22:20:54 <Saizan> you could try asking on the google group
22:21:35 <orclev> yeah, if I don't get it resolved in the next couple minutes I'll probably send an e-mail about it tomorrow to the webdevel mailing list
22:22:35 <orclev> it's probably something dumb I'm doing, but it's sort of wierd that the code just stoped compiling all of a sudden... wish I knew what all I've updated since the last time I successfully built it
22:27:27 <orclev> hmm, well, looking at Happstack.Server.SimpleHTTP, there is in fact no MonadIO instance declared for ServerPartT... let me see what version of happstack this is
22:27:39 <dibblego> are there any higher-order combinators to improve http://paste.pocoo.org/show/203928/ ?
22:28:10 <dibblego> mapM with StateT?
22:29:15 <ddarius> dibblego: You have what I assume is a typo.  j' isn't used.
22:29:33 <dibblego> ddarius, this is true, thanks
22:29:45 <dibblego> http://paste.pocoo.org/show/203929/
22:29:55 <ddarius> dibblego: Also, it looks like a foldr.
22:30:02 <dibblego> yes
22:30:13 <orclev> jf you have multiple versions of a package installed, does it always use the latest one?
22:30:31 <orclev> assuming you don't specify otherwise in a cabal file
22:30:50 <Saizan> not necessarily
22:31:18 <orclev> well, it looks like I have 0.3.3, and 0.4.1 installed, but I'm not sure which one is actually being used
22:31:20 <dibblego> ddarius, let me check that's actually what I want (foldr seems to conflict in my head)
22:31:25 <Saizan> if you're doing "cabal install" it might pick an older version because the latest one appears to be incompatible
22:31:41 <ddarius> dibblego: I believe you could push j all the way to the right and include it into the monad (i.e. effectively add a ReaderT layer.)
22:31:55 <Saizan> orclev: use "cabal install --dry-run -v" it'll show which one is chosen
22:32:06 <dibblego> ddarius, by "push to the right" you mean in the argument order?
22:33:56 <Saizan> that's definitely mapM in "StateT j"
22:34:30 <dibblego> that's what I was thinking, but perhaps there is a better way
22:35:15 <ddarius> dibblego: http://paste.pocoo.org/show/203930/
22:35:19 <dibblego> is that how you'd write it?
22:35:35 <dibblego> ddarius, thanks
22:37:11 <ddarius> I think Saizan's right.
22:37:52 <dibblego> ok that was my suspicion too
22:43:31 <ddarius> This is a beautiful, though not very deep, result: Given an endofunction on finite sets, it can be identified with a permutation of disjoint rooted trees.
22:49:48 <hpaste>  deadsimple (orclev)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24964
22:50:26 <orclev> ok, I tried to get the simplest possible happstack program I could, it's more or less the hello world from the happstack docs
22:51:14 <Saizan> orclev: you should annotate with the error you get
22:51:31 <orclev> doing so now
22:51:58 <orclev> ok, its got the error on there now as well
22:53:47 <Saizan> well, it's really lacking the instance, you can either use lift instead of liftIO there, or define the MonadIO instance yourself
22:54:34 <orclev> Saizan: yeah, but according to the haddock there's an instance already defined... but for whatever reason the version I have installed seems to be missing it... I even tried re-installing off hackage
22:54:49 <orclev> I just unpacked the hackage version, going to look at the source
22:55:11 <dibblego> @pl  \ f -> evalStateT . mapM f
22:55:11 <lambdabot> (evalStateT .) . mapM
22:55:25 <Saizan> orclev: maybe it's exported from some other module
22:57:21 <sykopomp> cross-platform GUI for a haskell newbie writing his first app: GTK or wx?
22:58:08 <kmc> first haskell app ever?
22:58:24 <sykopomp> yup
22:58:49 <dons> sykopomp: hard to say. they're both pretty active
22:58:55 <dons> maybe gtk2hs has more features
22:59:19 <sykopomp> Have some data, want to display it and allow some interaction, so it's nothing too fancy, but I'd like to be able to send binaries to users in different platforms.
22:59:54 <orclev> hmm, if you use GeneralizedNewtypeDeriving, do you have to explicitly export the declarations, or will just exporting the newtype do the trick?
23:00:01 <dons> sykopomp: well, both are cross platform
23:00:13 <dons> if its simple, maybe write the app in both, and tell us which was easier!
23:01:16 <dibblego> @type \ f -> evalStateT . mapM (StateT .
23:01:17 <lambdabot> parse error (possibly incorrect indentation)
23:01:18 <dibblego> @type \ f -> evalStateT . mapM (StateT . f)
23:01:19 <lambdabot> forall s (m :: * -> *) b a. (Monad m) => (a -> s -> m (b, s)) -> [a] -> s -> m [b]
23:01:31 <sykopomp> well, if they're both about the same and no one can speak for whether one API is generally nicer, I guess I'll just eenie-meenie-miney-mo it :P
23:01:34 <dibblego> thanks Saizan
23:01:34 <sykopomp> dons: thanks
23:01:46 <dibblego> @pl \ f -> evalStateT . mapM (StateT . f)
23:01:46 <lambdabot> (evalStateT .) . mapM . (StateT .)
23:05:30 <orclev> I must be missing something... ServerPartT is declared with deriving MonadIO... shouldn't that be enough to provide an instance of MonadIO?
23:06:23 <dibblego> orclev, you need GeneralizedNewtypeDeriving
23:06:35 <orclev> dibblego: it has that pragma set
23:07:56 <kmc> sykopomp, i think GTK is a more developed toolkit generally
23:08:01 <kmc> on Linux it's much more popular than wx
23:08:44 <kmc> i think it's more popular among Haskell apps too
23:08:46 <kmc> but i have no hard data
23:08:48 <orclev> kmc: I'd argue wx is more popular in Windows, although that's not much of an argument considering that both GTK and wx are hardly used in windows at all
23:09:07 <kmc> i chose GTK over wx for a Python project, because GTK had a more flexible treeview control and that was important for the particular task
23:09:52 <kmc> if you are using C++, the wx native API is nicer than the basic GTK+ C API, but i don't know if gtkmm is nicer than wx
23:09:57 <kmc> that's mostly irrelevant here :)
23:18:38 <orclev> ok, ServerPartT is declared using GeneralizedNewtypeDeriving, and deriving MonadIO... yet, I still get error messages about no instance declaration or MonadIO (ServerPartT IO)... how can that possibly be?
23:18:59 <DigitalKiwi> why am i here
23:19:02 <DigitalKiwi> i don't know haskell
23:19:15 <DigitalKiwi> i don't learn anything here through osmosis :(
23:20:17 <Twey> DigitalKiwi: So study
23:20:33 <DigitalKiwi> i do study
23:20:41 <DigitalKiwi> but for school :(
23:20:58 <DigitalKiwi> so crap like german (suck at), maths, and fortran :(
23:21:26 <kmc> DigitalKiwi, you're here because all the cool kids are
23:21:42 <kmc> i've learned a lot here through osmosis
23:21:45 <kmc> and still do every day
23:22:09 <orclev> never underestimate the power of osmosis
23:23:27 <kmc> but you probably need some concentrated study first, to reach the level where that will work
23:23:42 <orclev> to bad large gradients don't improve mental osmosis the way they do physical osmosis
23:25:00 <orclev> ok, it's really late here... or possibly early, depends on your perspective, so I guess I'll punt my question to the web-devel mailing list
23:29:34 <dmead> anybody else gonna go to hac phi?
23:30:06 <dmead> dmwit, poke
23:34:50 <dibblego> @pl \u -> (u, v)
23:34:51 <lambdabot> flip (,) v
23:42:28 <Gracenotes> @type (,True)
23:42:29 <lambdabot> parse error on input `True'
23:46:27 * hackagebot syb 0.2.1 - Scrap Your Boilerplate  http://hackage.haskell.org/package/syb-0.2.1 (JosePedroMagalhaes)
23:50:07 <chrisdone> Gracenotes: expecting a -> (a,Bool)?
23:50:22 <Gracenotes> thought it was added as pretty sugar
23:52:37 <fffej> hi - I'm trying to do some image processing.  I'm using Array (Int,Int) Double as my datatype but I'm finding I can't easily write an efficient function to do something like go over every pixel and process the neighbours of it (for example, the ixmap maps indices and map maps values, but I can't find anything to do both.
23:53:21 <fffej> Am I using the right data type?
