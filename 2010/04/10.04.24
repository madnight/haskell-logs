00:03:46 <tomberek> hello
00:04:29 <jbapple> I am having trouble figuring out the best way to install an updated "containers". I have cabal-install 0.6.0, Cabal 1.6.0.1 and GHC 6.10.1
00:04:54 <jbapple> $ cabal upgrade containers
00:04:55 <jbapple> Resolving dependencies...
00:04:55 <jbapple> cabal: cannot configure containers-0.3.0.0. It requires base >=4.2 && <6
00:04:55 <jbapple> There is no available version of base that satisfies >=4.2 && <6
00:05:16 <jbapple> OK, no problem, I think to myself, I'll just install the new GHC
00:05:21 <aavogt> cabal install containers?
00:05:28 <tomberek> jbapple, sounds reasonable
00:05:28 <Saizan> you need the new ghc
00:05:37 <Saizan> but you need to upgrade your cabal-install first
00:05:45 <Saizan> cabal install "cabal-install >= 0.8"
00:06:12 <tomberek> Saizan: hey there, I've been gone for almost a month,,, anything interesting, new? noteworthy?
00:06:29 <jbapple> Saizan: thank you
00:06:53 <jbapple> While I'm here, though, the GHC install page says that the platform provides GHC 6.10.4
00:07:20 <jbapple> but the platform page implies 6.12.somethign
00:07:24 <Saizan> tomberek: wrt hnn and/or graphs? not that i know of, but i didn't follow much
00:07:48 <tomberek> Saizan: sure, with those projects.  Or anything else.
00:07:55 <Saizan> jbapple: i think the ghc page is outdated and the latest HP works with ghc-6.12.1
00:13:06 <ivanm> tomberek: I'm about to release a new version of graphviz if you care about that... >_>
00:13:25 <tomberek> ivanm: ooooh,,, actually, i am
00:13:29 <ivanm> :D
00:13:39 <ivanm> just have to finish writing documentation first (since kowey asked for it)
00:13:45 <tomberek> i was looking for some flexible viewers
00:14:25 <ivanm> for?
00:14:36 <tomberek> graphs
00:14:52 <ivanm> ahhh
00:15:01 <ivanm> well, graphviz now has a quick-preview function...
00:15:07 <ivanm> but still, mainly FGL graphs for now :s
00:15:40 <tomberek> ok, have you seen my Data.Vector using instance of fgl Graph?  good performance increases
00:20:59 <tomberek> ivanm?
00:21:15 <ivanm> nope
00:21:19 <ivanm> has this been released?
00:23:18 <blackdog> is there a better way to write "return $ if (errCode == ExitSuccess); then Nothing; else Just blah blah blah" ?
00:23:26 <blackdog> i'm already in the IO monad there
00:23:34 <tomberek> ivanm: i'm talking to fgl author to get it added, but do you think it would be used?
00:23:57 <ivanm> sure
00:24:01 <tomberek> ok
00:24:05 <ivanm> but FGL could do with a serious re-write
00:24:10 <ivanm> e.g. stop using 4-tuples
00:24:22 <ivanm> tomberek: oh, and please please _please_ have Show and Read instances for it
00:24:26 <ivanm> that alone would make me use it :D
00:24:35 <ivanm> blackdog: when?
00:24:38 <ivanm> @hoogle when
00:24:38 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
00:24:47 <ivanm> hmmm.... there's a monoid version
00:24:48 <tomberek> ivanm: yeah, some people have begun to talk about that, edwardk had some ideas for the graphs, but I think its complexity (though probably very powerful) was too much for me to use
00:24:49 <ivanm> @hoogle guard
00:24:49 <lambdabot> Control.Monad guard :: MonadPlus m => Bool -> m ()
00:24:49 <lambdabot> Language.Haskell.TH data Guard
00:24:49 <lambdabot> Language.Haskell.TH.Syntax data Guard
00:24:52 <ivanm> aha!
00:24:59 <ivanm> blackdog: ^^
00:25:06 <ivanm> tomberek: *nod*
00:25:22 <blackdog> sure, but if i write "guard condition", that'll return in the IO monad, not the Maybe monad
00:25:47 <Saizan> blackdog: return $ guard (errCode /= ExitSuccess) >> return blah
00:25:53 <Saizan> blackdog: not much nicer though
00:26:04 <Saizan> monad comprehensions would be very nice there :)
00:26:39 <tomberek> ivanm: we ran into problems with fgl as well while trying to get good neural networks.... I want to encourage a larger project to make a new graph library.  We even have some interest from Okasaki.
00:26:50 <Saizan> return [ blah | errCode /= ExitSuccess ]
00:27:01 <ivanm> tomberek: oooohhhh...
00:27:25 <ivanm> tomberek: well, I'm kinda working on this generic graph class thingy, but I'm willing to help out with writing a good defualt instance for it, etc. as well
00:27:39 <ivanm> blackdog: return . guard ?
00:28:20 <blackdog> yeah, ended up with '       return $ guard (errCode /= ExitSuccess) >> return (errCode, unlines ["output: " ++ out, "error: " ++ err])
00:28:36 <tomberek> ivanm: he said he'd give us one of his students....... thanks, the problem is that none of use are "haskell-sages" yet, and some of those big design decisions need that.
00:28:56 <ivanm> tomberek: get Cale involved
00:29:00 <blackdog> which is a bit nicer. Saizan: that syntax is nice, pity we don't have 'em:/
00:29:33 <Saizan> mmh, monad comprehensions via quasiquoting? [$c|  blah | errCode /= ExitSuccess |]
00:29:34 <tomberek> ivanm: i think he expressed interest, but like so many others, he is busy,,,,, but thanks, i'll try to get in touch with him.
00:29:46 <ivanm> heh
00:30:00 <blackdog> Saizan: heh, don't think i want to get TH involved just for this:)
00:30:14 * ivanm wonders if tomberek loves multi-tuples like Martin Erwig...
00:30:15 <ivanm> :p
00:30:17 <blackdog> the doubled return still feels a bit weird, but i guess it makes sense
00:31:05 <Saizan> you could use Just if it's less weird :)
00:31:12 <tomberek> ivanm: i'm under the impression that the massive amount of packing/unpacking slows it down
00:31:20 <blackdog> Saizan: yep, just made that change. :) funny what makes you feel better
00:31:50 <ivanm> tomberek: with non-tuple datatypes? really?
00:31:59 <ivanm> I thought it was just that old that Martin didn't know of any better way...
00:32:09 <tomberek> ivanm: no, the tuples,, unpacking to get inside them
00:32:31 <tomberek> i agree that they're annoying
00:32:54 <ivanm> tomberek: I was referring to your usage of multiple commas ;-)
00:32:59 <tomberek> plus we need a better way to transform graphs without so much allocation, GC is a killer with the default instances.  Data.Vector helps.
00:33:16 <tomberek> ivanm: oh.... i use them as fillers-----see???????
00:33:28 <ivanm> are you using ropes (forget who was doing all the rope stuff with vectors)?
00:33:33 <ivanm> tomberek: heh
00:34:32 <tomberek> edwardk was using them, but i fear it won't get quite the performance we need, especially for maps over the whole graph
00:34:50 <ivanm> :(
00:34:59 <tomberek> then again, i could be wrong
00:35:45 <ivanm> heh
00:35:55 <tomberek> i'd like him to create a quick rope version of fgl and run a competition vs mine,,, but what i really want is a better-fgl, and run competitions on that
00:37:36 <ivanm> @where PVP
00:37:36 <lambdabot> http://www.haskell.org/haskellwiki/Package_versioning_policy
00:40:41 <blackdog> ok, i need some design help. i'm about to rewrite a big chunk of Hubris
00:40:54 <blackdog> i need to be able to represent the capabilities of a ruby interpreter
00:41:19 <blackdog> currently i'm binding it at Hubris compile-time, but that's no good if i want to have it work with ruby interpreters that are installed afterwards
00:41:38 <ivanm> blackdog: so you want code generation?
00:41:45 <blackdog> so i need to represent a ruby interpreter somehow. i'm thinking either a record of functions, or an instance of a class
00:42:05 <ivanm> preflex: seen sinelaw
00:42:05 <preflex>  sinelaw was last seen on #haskell 6 days, 11 hours and 41 minutes ago, saying: hi all
00:42:25 <blackdog> ivanm: sort of. i'm doing the code generation already
00:43:05 <blackdog> i'm using HINT to test what haskell functions are 'bindable'
00:43:37 <Saizan> mh, how did you use quasiquoting?
00:44:06 <DigitalKiwi> i hate fortran
00:44:10 <blackdog> but currently, that's using a c binding, so that needs to change or i won't be able to sub a new library/header file in
00:44:14 <DigitalKiwi> :(
00:44:45 <ivanm> DigitalKiwi: which version?
00:44:52 <DigitalKiwi> 90/95
00:45:00 <ivanm> I didn't mind it too much
00:45:07 <ivanm> I found it a hell of a lot nicer than C
00:45:14 <ivanm> and I prefer 90/95 to 77 ;-)
00:45:40 <tensorpudding> Fortran used to be really primitive
00:47:14 <ivanm> can people please have a look at the current state of the documentation for graphviz I've got here and tell me if they think it's OK? http://code.haskell.org/graphviz/FAQ
00:47:18 <DigitalKiwi> i can't make it do what i want :(
00:47:28 <ivanm> DigitalKiwi: what do you want?
00:47:58 <DigitalKiwi> I have a string such as "((55+4)+(3/(4$(3-(9/8)))))" and somehow need to put each element in a stack
00:48:07 * ivanm has no idea how to do that
00:48:07 <DigitalKiwi> where 55 is one element
00:48:14 <DigitalKiwi> yeah me neither :(
00:48:21 <ivanm> write a parser? :s
00:48:31 <ivanm> DigitalKiwi: why are you doing something like that?
00:48:39 <DigitalKiwi> i have  a stack, i have a push function, but i can't figure out how to make 55 be one element and not two :(
00:48:52 <DigitalKiwi> cause it is for school and we have the most retarded program ever
00:49:11 <ivanm> DigitalKiwi: if you get another digit, pop the stack, combine them, push
00:49:12 <DigitalKiwi> http://cse.unl.edu/~nbenes/fortran/p4/p4.pdf
00:49:43 <DigitalKiwi> hrm
00:49:49 <DigitalKiwi> i hadn't thought of it that way...
00:50:02 <DigitalKiwi> i was trying to combine them before pushing
00:50:15 <ivanm> hence why you asked how to do it here ;-)
00:50:29 <ivanm> stuff tokenising/lexing: treat it one character at a time! :D
00:52:06 <rankles> hello ivanm
00:52:27 <ivanm> hi rankles
00:52:41 * ivanm wonders why rankles is saying hello to him specifically...
00:52:48 <rankles> i took your advice, and i now idle on #haskell
00:52:51 <blackdog> ivanm: does it ... rankle?
00:52:52 <ivanm> oh, COMP1100 student
00:52:54 <ivanm> ;-)
00:52:58 <rankles> haha
00:53:08 <ivanm> rankles: that was _Axman6's_ advice, not mine!
00:53:15 <rankles> oh right
00:53:21 <blackdog> rankles: don't listen to Axman6
00:53:29 <rankles> is he a fiend?
00:53:35 <blackdog> not only is he a scoundrel of the first water, he's from _Canberra_
00:53:38 <ivanm> he uses a Mac
00:53:41 <rankles> hey hey hey
00:53:44 <ivanm> blackdog: so is rankles...
00:53:46 <ivanm> and now me
00:53:50 <rankles> lets give some credit to canberra
00:53:53 <blackdog> yes. therein lies the joke:)
00:53:58 <rankles> i see
00:54:01 <rankles> this humor thing
00:54:09 <ivanm> blackdog: at least it isn't Sydney though...
00:54:15 * ivanm hates sydney
00:54:16 <aavogt> what's the second water?
00:54:16 <rankles> i just wish freenode allowed arbitrary hostmasks
00:54:16 <blackdog> rankles: i credit canberra with isolating canberrans from australia proper:)
00:54:28 <rankles> we do think we're a cut above the rest
00:54:35 <ivanm> rankles: you do, if you pay them methinks
00:54:37 <rankles> think = know???
00:54:39 <blackdog> ivanm: i took alex out for a beer and he saw a domestic about a dog
00:54:41 <blackdog> it was pretty funny
00:54:49 <ivanm> rankles: I know you can get them; _how_ to get them I'm hazy about
00:54:54 <blackdog> tell him he can't even take care of a f***ing puppy some time
00:54:59 <ivanm> blackdog: ... right ...
00:55:15 <rankles> haha
00:55:29 <rankles> yeah, i read on their website you need to be apart of particular projects
00:55:38 <rankles> wikipedians get their own hostmasks
00:58:48 <hotaru2k3> hmmm... a lot of links on hoogle are broken
00:59:04 * ivanm -> dinner
01:00:52 <hotaru2k3> pretty much everything in base, the links point to pages in http://haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/, which doesn't exist... should be http://haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.1/ instead
01:01:20 <ivanm> hotaru2k3: ghc 6.12.2 just got released, so the hoogle index needs to be updated
01:02:54 <Cale> I really dislike how with every ghc release, they forget to recreate the un-version-numbered links
01:03:18 <Cale> It breaks all my browser bookmarks.
01:03:35 <tomberek> hey Cale
01:03:39 <Cale> hey
01:04:00 <tomberek> how you been?
01:04:04 <Cale> okay
01:04:23 <tomberek> i'm still trying to recruit for a graph rewrite........
01:05:45 <Cale> graph rewrite?
01:06:21 <tomberek> yes, i think haskell should have a more useful graph library
01:07:11 <ivanm> Cale: he's talking about re-writing FGL to use Vector or something
01:07:17 <tomberek> enough so that whenever people need to use a graph or something in their code, they don't write their own, but have a handy library to draw from
01:07:35 <ivanm> Cale: kind of complementary to my generic graph class project
01:08:07 <tomberek> ivanm: i have a Vector instance for fgl already, but I think fgl itself needs some work.... yeah, get some generics out there, then enough flesh to make it usable to for the casual user.
01:10:32 <Cale> http://xkcd.com/730/ -- haha, just saw this :)
01:12:35 <tomberek> hehe, scarab beetles
01:13:35 <thoughtpolice> weee
01:13:49 <thoughtpolice> canvas apps using haskell: http://github.com/thoughtpolice/canvas-hs/blob/master/t/simple.hs
01:14:14 <thoughtpolice> because nobody actually wants to write javascript when there are typed alternatives
01:17:13 <blackdog> thoughtpolice: an awful lot of js hackers hate GWT with a fiery passion
01:17:53 <Adamant> aren't there a bunch of competing libs
01:18:02 <Adamant> like jQuery and other stuffs
01:18:12 <tomberek> http://xkcd.com/723/   funny thing about this: i know some people who were about to land a plane during the earthquake last month.  Apparently, they weren't used to the landing area moving around so much without it being a carrier.
01:19:52 <thoughtpolice> blackdog: yes, but then again java isn't exactly the latest and greatest in typed programming languages
01:20:18 <DigitalKiwi> hrm
01:20:23 <DigitalKiwi> ivanm:  :(
01:21:02 <blackdog> thoughtpolice: heh. yes. hard to get that across to ruby/js types, though.
01:21:05 <DigitalKiwi> how do i keep track of if the last thing was a digit and the new thing is a digit to know if i pop or not? :(
01:21:58 <chrisdone> thoughtpolice: hamlet looks neat
01:22:09 <thoughtpolice> blackdog: but i think this approach works pretty well :)
01:22:48 <thoughtpolice> chrisdone: it is pretty neat
01:23:44 <chrisdone> thoughtpolice: i did something similar to that for Raphael :D. haskell javascript monads == awesome
01:24:50 <thoughtpolice> chrisdone: i particularly like hamlet + hjscript, because hamlet is compile-time checked and hjscript is also very typeful and complete
01:25:15 <thoughtpolice> so you get compile-time checked templates and statically typed javascript code generation
01:25:23 <portnov> btw. Is anyone here intrested in YAML RPC implementation in haskell? :)
01:25:26 <ivanm> DigitalKiwi: pass a boolean around
01:25:37 <monadic_kid> RPC?
01:25:43 <portnov> remote procedure call
01:25:44 <ivanm> role playing character?
01:25:46 <chrisdone> thoughtpolice: i was just wondering if it was compile time checked. that's awesome. reading the docsnow
01:25:48 <portnov> :)
01:26:02 <DigitalKiwi> don't know where to change the bool :(
01:26:15 <DigitalKiwi> maybe i should just go to sleep...
01:26:19 <ivanm> DigitalKiwi: if the current character is a digit, set it to true; otherwise set it to false
01:33:16 <DigitalKiwi> mhr
01:34:56 * hackagebot dow 0.2.0 - Dungeons of Wor  http://hackage.haskell.org/package/dow-0.2.0 (GergelyPatai)
01:36:30 <eldragon> hi guys, can GHC 6.12.2 use the option -flto of the compiler GCC 4.5.0 during the creation of the executable for tunning better the performance?
01:36:49 <ivanm> eldragon: I doubt it
01:37:17 <kbp> I'm new to Haskell. Since Haskell doesn't support "elseif", is it correct with these indents ? http://codepad.org/apmTria6
01:37:18 <ivanm> eldragon: and in most cases, it doesn't matter: unless you use -fvia-c then ghc uses the native code generator on most architectures, which usually produces better results than -fvia-c
01:37:35 <ivanm> if you _really_ want to use -fvia-c, there's probably some way of specifying C flags
01:37:59 <ivanm> kbp: Haskell doesn't support elseifs, but in those kinds of situations you probably want to use guards rather than nested if statements
01:38:19 <ivanm> kbp: however, those indentations look alright to me
01:38:25 <ivanm> probably more indentation than you need
01:38:52 <chrisdone> i've seen haskell code where the else ifs were formatted like c, it doesn't look too bad
01:39:34 <kbp> im not sure what is guard ... anyway but if it looks ok then... thank you guys for checking :D
01:39:46 <chrisdone> if (a==b) then      a=a+1
01:39:46 <chrisdone> else if (a==c) then a=a-1
01:39:46 <chrisdone> else                a=0
01:40:07 <chrisdone> I think this looks like the c version and is quite readable
01:40:25 <DigitalKiwi> so close...
01:40:31 <kbp> oh i see, it can be just like that
01:41:11 <chrisdone> yep
01:41:39 <ivanm> kbp: guard version: http://codepad.org/Hs5FjmN4
01:41:55 <ivanm> note that the "a = a-1" stuff isn't haksell
01:42:38 <kbp> oh so the | thing is called guard....
01:43:20 <ivanm> kbp: the | <condition> is a guard
01:43:21 <kbp> im actually writing an if inside a guard
01:43:31 <ivanm> the | character by itself is usually called a pipe
01:43:39 <ivanm> kbp: that kind of defeats the point :p
01:43:40 <chrisdone> kbp: that sounds like a messy idea
01:43:54 <kbp> http://codepad.org/Rla4rBfY <---- here, but somehow I cannot put "if" statement inside it, any idea about the order ?
01:44:09 <kbp> (as u can see syntax error from codepad)
01:44:10 <monadic_kid> @src abs
01:44:10 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
01:44:32 <DigitalKiwi> bah! I hate strings in fortran :(
01:45:14 <monadic_kid> guards are great for pieewise functions, they where born for each other
01:45:40 <ivanm> monadic_kid: you mean "piecewise"?
01:45:44 <monadic_kid> yeah
01:45:46 <ivanm> hmmmmm.... pie-wise functions...
01:45:50 <chrisdone> mmm
01:46:01 <DigitalKiwi> ivanm: i think i almost have it
01:46:12 <monadic_kid> abs x | x < 0 = -x | x >= 0 = x
01:46:17 <ivanm> kbp: yeah: don't
01:46:26 <ivanm> what you have there doesn't even make sense
01:46:28 <DigitalKiwi> my functions for pop/push weren't set up for greater than 1 length strings :(
01:46:40 <ivanm> also, output == True is redundant ;-)
01:46:44 <ivanm> DigitalKiwi: :(
01:47:17 <ivanm> dinner's ready; bbl
01:47:30 <kbp> ivanm: i think i've realised it now :) easy to fix , thank you :)
01:48:32 <DigitalKiwi> SWEET =D
01:50:06 <ivanm> grrr, not quite done yet...
01:50:08 <ivanm> kbp: no worries ;-)
01:50:15 <ivanm> cycloid_: you want me?
01:50:19 <ivanm> DigitalKiwi: it's working?
01:50:30 <DigitalKiwi> ivanm: yup yup
01:50:33 <ivanm> :D
01:51:00 <cycloid_> ivanm: nope, sorry to disturb.
01:51:19 <ivanm> heh, just saw all these CTCP messages from you, that's all
01:51:41 <cycloid_> I'm futzing w/Colloquy, probably not very competently
01:51:58 <ivanm> what's that?
01:52:05 <cycloid_> IRC client for MacOS
01:52:14 <DigitalKiwi> failboat
01:52:20 <DigitalKiwi> I'm on a boat!
01:52:25 <ivanm> heh
01:52:53 <silver> Do you think Death could possibly be a boat? (c)
02:12:07 <portnov> Q. Are there any bindings to Avahi/Zeroconf for Haskell?
02:24:22 <ivanm> portnov: don't think so
02:25:24 <deteego> has anyone here used template haskell?
02:26:47 <ivanm> some people have; anyone who's actually paying attention at the moment is a different story...
02:28:25 <deteego> ivanm: yeah, I wish TH was better documented...
02:30:31 <Oejet> portnov: Do you know how to write bindings using the Foreign Function Interface?
02:34:00 <ivanm> hmmm.... why doesn't parsec's home page refer to parsec-3?
02:34:48 <dolio> I think people stopped updating it a long time ago.
02:36:01 <AmunRa> hello, I'm learning Haskell.. and I'm quite confused by cabal.. `cabal install leksah` errors "cabal: cannot configure leksah-server-0.8.0.5. It requires ghc >=6.10.1" ... I have 6.12.1 installed
02:36:30 <dolio> The home page was, I think, made by the original authors. But ddarius has been in charge of the actual package since 3.
02:39:04 <portnov> Oejet: as I see avahi uses DBus interface. There are some bindings for DBus on hackage, so problem is only to use them to talk with avahi.
02:41:49 <Oejet> portnov: Ah, ok.
02:44:06 <kbp> I have a question: if we have a function with 5 pattern matching parts, and if Haskell finds the input variable is pattern 1, will it continue to search and check pattern 2,3,4,5? or will it exit instantly without checking the others!?
02:44:57 <chrisdone> it short-circuits
02:44:58 <shrughes> it will "exit instantly"
02:45:10 <ivanm> preflex: seen Gwern-away
02:45:10 <preflex>  Gwern-away was last seen on #haskell 6 hours, 28 minutes and 1 second ago, saying: huh. wasn't expecting that error
02:45:32 <kbp> that's a nice part of haskell
02:45:32 <chrisdone> famous last words
02:45:38 <ivanm> chrisdone: heh
02:45:40 <kbp> lol
03:09:32 * hackagebot gf 3.1.6.1 - Grammatical Framework  http://hackage.haskell.org/package/gf-3.1.6.1 (KrasimirAngelov)
03:09:42 <Associat0r> http://wadler.blogspot.com/2010/04/bull-bear-and-python.html
03:09:57 <deteego> also on another note, does anyone know how template haskell works with haddock
03:14:26 <portnov> deteego: how should it work?
03:15:14 <deteego> portnov: well in regards to making documentation with data types that you create through template haskell
03:16:01 <portnov> haddock `sees' declarations generated by TH, not TH constructs theirself.
03:16:58 <deteego> portnov: right but if you want to create custom comments in order to add to the documentation
03:17:26 <portnov> afaik TH cannot generate comments. Am I wrong?
03:17:33 * hackagebot gf 3.1.6.2 - Grammatical Framework  http://hackage.haskell.org/package/gf-3.1.6.2 (KrasimirAngelov)
03:18:00 <deteego> portnov: well im having a look
03:18:49 <deteego> but the TH documentation, is well, funky
03:19:21 <Phyx-> morning
03:20:03 <portnov> deteego: seems Bulat's tutorials are the best of TH docs.
03:23:04 <deteego> if only TH worked like conventional C macros
03:23:09 <deteego> but then again, that would be unsafe
03:23:26 <deteego> and would be more macros then templates =D
03:23:30 <ivanm> portnov: are his tutorials as bad as his email messages? :s
03:24:50 <portnov> ivanm: have not read his messages :)
03:25:06 <portnov> deteego: may be you need {-# LANGUAGE CPP #-} ;)
03:25:07 <portnov> ?
03:25:21 <ivanm> portnov: in all his emails to -cafe, I can barely read them due to the lack of grammar, capitalisation, etc.
03:25:31 <ivanm> oh, and to me they often have a tinge of arrogance
03:25:58 <deteego> portnov: hmmm, how is that gonna work
03:26:05 <deteego> oh nvm
03:41:38 <roconnor> when I open a file, is there any guarentees about what I read write and seek from the file?  Or can other programs interfere with me arbitrarily?
03:41:54 <mauke> I'd expect the latter
03:45:06 <roconnor> so the semantics of file IO really is just reading from and writing to a big soup that could do anything
03:45:21 <dolio> Roughly.
03:45:28 <dolio> Might depend on the operating system.
03:45:49 <Peaker> somewhat like an MVar/IORef
03:45:57 <Peaker> You can get a file that you somehow know is exclusively yours..
03:45:58 <roconnor> but if H98 were to have IO semantics, it would have no guarentees about the relation to reading and writing from the same file handle
03:46:10 <roconnor> Peaker: can you?
03:46:15 <roconnor> exclusively?
03:46:42 <Peaker> roconnor, I think Windows has exclusive file handles
03:47:30 <dolio> Linux can at least have files that don't have a name anywhere in the actual file system.
03:47:48 <dolio> Other programs would probably have to go to great lengths to interfere with those.
03:49:00 <dolio> (At least, I think that's roughly correct.)
03:49:52 <dolio> I'm not really sure if you can create such files that don't exist at your whim, though.
03:50:13 <dolio> It may be reserved for when you unlink a file that's been opened by a program.
03:50:51 <roconnor> Basically Haskell 98 IO is basically the free Monad of file read writes and seeks
03:50:58 <roconnor> s/basically//
03:55:14 <olsner> where would you go to learn what "the free Monad of" means?
03:55:36 <dolio> I wrote an article of dubious quality about it.
03:55:38 <dolio> On the wiki.
03:55:53 <roconnor> olsner: it is a syntax tree
03:56:15 <roconnor> with leaves of hold data of type "a"
03:56:20 <roconnor> s/of/that/
03:56:25 <LouisJB> hi, I'm learning FP from originally a procedural / OO background, I'm familiar with many concepts but reading Why FP matters I came across function composition defined as: (f . g) h = f (g h) - could someone help me understand that better - I kind of get it but want to make sure it's clear in my mind.
03:57:02 <solrize> sqrt(sin(x)) = (sqrt . sin) (x)
03:57:04 <olsner> so "the free monad" means something like the "natural" definition of monad given this syntax tree data type?
03:57:21 <scree> olsner: any string of monadic combinators that you string together is distinct
03:57:47 <scree> it's the "most general monad" in the sense that it has no other structure
03:57:51 <LouisJB> solrize: it's as simple as that? is that legal in Haskell to compose with functions like that?
03:58:00 <solrize> LouisJB, yep
03:58:03 <LouisJB> awesome
03:58:21 <LouisJB> the syntax is (f1 f2) or how does it look?
03:58:32 <solrize> instead of sqrt(x) we just say sqrt x
03:58:39 <roconnor> olsner: and the non-leaf nodes will be exactly your primitive monad actions
03:58:43 <solrize> so to compose f1 and f2,  it's f1 . f2
03:58:55 <solrize> dot is the composition operator.  you should probably read LYAH
03:58:57 <solrize> @where lyah
03:58:57 <lambdabot> http://www.learnyouahaskell.com/
03:59:17 <LouisJB> I could say f3 = f1.f2  f3 x roughly speaking?
03:59:18 <roconnor> so return x = leaf x
03:59:42 <solrize> LouisJB, yes, watch:
03:59:50 <solrize> >let f = sqrt . sin in f 2
03:59:57 <solrize> > et f = sqrt . sin in f 2
03:59:58 <lambdabot>   <no location info>: parse error on input `='
03:59:59 <solrize> darn
04:00:00 <solrize> sec
04:00:05 <solrize> > let f = sqrt . sin in f 2
04:00:06 <lambdabot>   0.9535708819095106
04:00:08 <solrize> there
04:00:12 <solrize> forgot the space after the >
04:00:16 <solrize> > sqrt 2
04:00:17 <lambdabot>   1.4142135623730951
04:00:20 <solrize> > sin 1.414
04:00:21 <lambdabot>   0.9877326197620127
04:00:22 <solrize> see
04:00:28 <LouisJB> thanks for the link, I was part way through Programming Haskell
04:00:30 <roconnor> write handle char = WriteNode handle char (Leaf ())
04:00:34 <solrize> oh cool
04:00:38 <LouisJB> that's really neat, looks very powerful
04:00:51 <LouisJB> is that kind of related to the idea of point free programming then?
04:01:01 <solrize> err, only kinda sorta
04:01:03 <roconnor> read handle char = ReadNode handle (\ch -> Leaf ch)
04:01:23 <LouisJB> I will read up that link, been looking for good Haskell resources
04:01:31 <solrize> also look at rwh
04:01:32 <solrize> @where rwh
04:01:32 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
04:01:44 <roconnor> Leaf x >>= f = f x
04:01:45 <solrize> http://book.realworldhaskell.org/read/
04:02:05 <solrize> lyah is a little more beginner friendly, rwh gets into more practical topics
04:02:07 <LouisJB> strangely I've come via C/C++ to Java and C# to Scala and Clojure to finally Haskell, strange route I guess, some of these ideas are a little new heh
04:02:11 <olsner> roconnor: yeah, that's how you'd make an instance of Monad for the IO syntax tree :) but whence the "free" monad?
04:02:23 <eldragon> is there any tutorial for how to program Haskell using monads or printing I/O operations?
04:02:26 <solrize> if you've been using clojure then haskell should come to you
04:02:35 <roconnor> olsner: it is freely made from ReadNode and WriteNode
04:02:58 <solrize> eldragon, umm, rwh?
04:03:09 <LouisJB> sure, I see many similarities in these languages
04:03:28 <LouisJB> I've read some of RWH - must have missed the part on function composition
04:03:35 <solrize> scala also
04:04:02 <eldragon> ok solrize
04:04:26 <solrize> here's one for you
04:04:33 <LouisJB> yeah, Scala is quite neat (I  like it) but nothing appears quite so elegant sometimes as Haskell
04:04:35 <solrize> > let f = (2 +)  in f 5
04:04:35 <lambdabot>   7
04:05:10 <eldragon> i want to print a list of primes to a text files, i don't know how.
04:05:45 <mauke> ;t writeFile
04:05:46 <xerox> ?type writeFile
04:05:47 <lambdabot> FilePath -> String -> IO ()
04:05:50 <solrize> oh, you want to know how to open files etc.   hmm,
04:06:11 <eldragon> with the loop of printing each prime
04:06:22 <mauke> why a loop?
04:06:26 <solrize> have you seen "gentle introduction to haskell" which actualy isn't all that gentle?
04:06:34 <eldragon> mauke, because i'm silly.
04:07:04 <eldragon> i'll read it.
04:07:10 <solrize> eldragon, actually you could look at some of dons' older blog posts.... http://donsbot.blogspot.com i think
04:07:36 <solrize> sorry  donsbot.wordpress.com
04:09:06 <LouisJB> solrize: thanks for the help, I'm going to go read LYAH
04:09:41 <eldragon> is 6.12.2 faster than 6.10.4 in the dual core laptop?
04:10:20 * solrize still using 6.10,4.
04:10:40 <eldragon> i'm confuse if 6.10.4 is using both cores or not.
04:11:31 <eldragon> are there portable editions of 6.10.4 and 6.12.2 for windows?
04:12:23 <c_wraith> neither version will use multiple cores without runtime flags
04:13:19 <eldragon> i want these flags for reducing the computation time of X hours to X/2 hours.
04:13:43 <c_wraith> +RTS -N2
04:13:47 <eldragon> thanks
04:13:52 <c_wraith> That tells the runtime to use two cores.
04:14:05 <c_wraith> If it gets any gain out of it depends heavily on the algorithm
04:15:05 <c_wraith> Also, you have to have built the program with the -threaded flag for the runtime to support that option
04:15:55 <olsner> I think I'm starting to get what the deal with "free" structures is now
04:22:33 <eldragon> does GHC have the profiling flags for tunning the performance?
04:22:58 <olsner> reminds me of conal's ideas of composing data types that already have the right applicative and monoid instances, instead of implementing the semantics you want "from scratch"...
04:23:51 <olsner> i.e. finding something where the free structure matches what you want instead of making a non-free structure
04:23:52 <eldragon> with profiling, i'll try to reduce the time to X/3 hours.
04:29:47 <eldragon> GHC + Mosix could be a good idea
04:31:17 <eldragon> or GHC + Kerrighed.
04:45:04 * hackagebot ldif 0.0.6 - The LDAP Data Interchange Format (LDIF) parser  http://hackage.haskell.org/package/ldif-0.0.6 (RadoslavDorcik)
04:45:16 <roconnor> olsner: I guess I didn't mean that there was anything really fancy about the H98 IO monad being free.
04:45:22 <kbp>  http://codepad.org/tz0JF0rX <---- could anyone please help me with this? I dont know why it gives syntax error
04:45:29 <roconnor> olsner: I just ment it as a compact way of describing it.
04:45:53 <roconnor> olsner: in some ways free monads are quite uninteresting, and it is practially a failure for the H98 IO monad to be free.
04:45:58 <mauke> kbp: unmatched '('
04:46:00 <Twey> kbp: Extra opening bracket on (xs == [])
04:46:07 <Twey> Actually, you don't need any brackets there
04:46:34 <Twey> Then you'll get a type error because x is not a function so you can't compose it with ‘func_name’
04:46:47 <kbp> oh i see!! bad @-@!!! probably a result from 4 hr coding none-stop
04:53:48 <Twey> Hehe
04:53:58 <Twey> kbp: Also: getFunc name = fmap funcBody . listToMaybe . filter ((== name) . funcName)
04:55:30 <ivanm> which version of haddock comes with 6.12.2?
05:06:26 <benmachine> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25025#a25025 thinking of uploading this to hackage, what do you guys think?
05:06:32 <benmachine> too trivial?
05:07:58 <ivanm> I think so, yes
05:08:07 <benmachine> aww
05:08:21 <ivanm> since the few times I've used asType it's been for more compliceated examples
05:08:23 <ivanm> @hoogle astype
05:08:23 <lambdabot> Prelude asTypeOf :: a -> a -> a
05:10:43 * benmachine adds asList asString asMaybe
05:14:21 <sepp2k> @src asTypeOf
05:14:21 <lambdabot> asTypeOf = const
05:14:30 <sepp2k> ok, uhm, why?
05:14:56 <roconnor> sepp2k: the types are different
05:15:03 <mauke> :t 42
05:15:04 <lambdabot> forall t. (Num t) => t
05:15:08 <mauke> :t 42 `asTypeOf` length ""
05:15:09 <lambdabot> Int
05:15:32 <sepp2k> Ah. Got it. Thanks.
05:59:14 <deteego> man, my head is about to explode from learning templates in Haskell
05:59:46 <ivanm> any particular reason you are doing so?
06:00:28 <medfly> I recall someone saying something about how if your head is not exploding then you are not learning fast enough
06:00:46 <deteego> well yeah kinda need it for what Im doing, but the way that Haskell approaches templates is different
06:00:53 <deteego> to other languages
06:01:46 <ivanm> why do you need it though?
06:02:07 <deteego> because I have a lot of boilerplate code which can be automatically generated through templates
06:03:23 <deteego> I just need to work out how the Q monad works with everything else
06:03:28 <ivanm> deteego: yes, but is this the kind of stuff that can be generated once and that's it?
06:03:35 <ivanm> or does it have to be dynamically generated?
06:04:06 <deteego> ivanm: no its stuff that will be changed
06:04:10 <deteego> dynamically
06:04:28 <ivanm> right
06:04:48 <deteego> its something I would want to learn either way
06:04:57 <deteego> since it is interesting
06:06:31 * ivanm has never had a use for TH
06:06:40 <ivanm> I have some generated code, but I generate it manually with a script
06:09:12 <gerryxiao> hello
06:09:30 <gerryxiao> hGetContents: invalid argument (invalid UTF-8 byte sequence)
06:09:32 <gerryxiao> what's wrong
06:09:55 <deteego> gerryxiao: are you doing ghc-pkg -recache?
06:10:34 <gerryxiao> deteego: no, using cabal
06:10:53 <deteego> see I got that same error
06:10:55 <gerryxiao> deteego: when ghc-pkg,i also got that  error msg
06:10:59 <deteego> yeah
06:11:08 <deteego> for me it linked to a certain file
06:11:14 <deteego> which I deleted and the erorr went away
06:11:17 <HugoDaniel> hi
06:11:35 <gerryxiao> it seems the problems of  postinstall script of ghc
06:11:48 <deteego> are you using archlinux?
06:11:59 <gerryxiao> deteego: nope, ubuntu
06:12:02 <deteego> hmm
06:12:13 <deteego> for me
06:12:13 <gerryxiao> lucid
06:12:17 <deteego> it happend when I installed a package
06:12:27 <deteego> which couldn't unregister due to another package (it was an update)
06:12:34 <deteego> and the error came up
06:12:43 <gerryxiao> same with me
06:13:26 <gerryxiao> ghc-pkg: /home/gerry/.ghc/x86_64-linux-6.12.1/package.conf.d/binary-shared-0.8-00180db675f2ea73ce16a4820071cd80.conf: hGetContents: invalid argument (invalid UTF-8 byte sequence)
06:13:41 <deteego> yup
06:13:42 <deteego> i have
06:13:50 <deteego> /usr/lib/ghc-6.12.1/package.conf.d/binary-shared-0.8-4f69b96682333c17a8bed7f0c8706a22.conf
06:14:23 <deteego> probably should report it
06:14:35 <gerryxiao> ur is system config script and me is user config script
06:14:45 <deteego> yeah
06:14:58 <gerryxiao> anyone know how to fix it?
06:15:27 <gerryxiao> it's annoying
06:16:13 <deteego> I would submit a bug report
06:16:15 <deteego> for GHC
06:16:21 <deteego> I will also confirm the problem
06:22:57 <gerryxiao> i want to try xmonad, when install xmonad-contrib,i got that msg
06:23:57 <deteego> anyone in here use Template Haskell?
06:53:45 <mreh> how could I make a HOF strict?
06:53:59 <mreh> i.e. it returns a function
06:55:58 <mauke> the same way as any other function
06:56:17 <mreh> that doesn't make a whole load of sense I suppose
06:56:46 <mreh> I've just realised what I need to do is evaluate all the other arguments to the function fully first
06:57:04 <mreh> it's a HOF that returns a partial application of a function
06:58:13 <blackdog> is there a way to mandate certain cabal options in a package?
06:58:31 <blackdog> my package doesn't make any sense if --enable-shared isn't on, for example
07:01:07 <mreh> blackdog: do you mean a compiler option?
07:01:47 <Eelis> > let y = "bla"; f x = x + length y in (f 3, f 2) -- will ghc compute "length y" once or twice here?
07:01:48 <lambdabot>   (6,5)
07:02:12 <mreh> Eelis: once
07:02:15 <mreh> graph reduction
07:02:20 <Eelis> great :)
07:02:28 <mreh> Eelis: I'm just reading about this
07:02:32 <mreh> http://en.wikibooks.org/wiki/Haskell/Graph_reduction
07:02:34 <blackdog> mreh: yes
07:03:27 <mreh> blackdog: sure is, you can specify compiler options like optimisation
07:03:29 <blackdog> i had "ghc-options: -dynamic" in the cabal file, but ./Setup dist got cranky about that
07:04:07 <blackdog> actually, sorry - --enable-shared is a cabal option
07:04:10 <mreh> blackdog: I'm not really familiar with what you're doing, so I couldn't really help much
07:04:21 <mreh> are you using "cabal build"?
07:04:33 <Eelis> mreh: that page seems awfully sketchy
07:04:37 <blackdog> yep.
07:04:47 <blackdog> well, ./Setup configure, anyway
07:05:04 * hackagebot hashed-storage 0.4.12 - Hashed file storage support code.  http://hackage.haskell.org/package/hashed-storage-0.4.12 (PetrRockai)
07:05:08 <mreh> Eelis: fix it if you like :)
07:05:31 <Eelis> mreh: i think i'll pass.
07:07:02 <blackdog> mreh: the basic problem is that cabal gets --enable-shared from ~/.cabal/config, in the 'shared' variable
07:07:14 <blackdog> but i'd like to mandate that it be on at least for this package
07:07:26 <blackdog> because otherwise it has no possible use
07:08:06 <mreh> blackdog: and the .cabal file doesn't override that setting?
07:08:34 <mreh> this is what "cabal build" is for
07:08:56 <mreh> i'd recommend using cabal for all builds
07:09:13 <blackdog> mreh: it does exactly the same thing.
07:09:38 <mreh> I don't think I can help really
07:09:45 <blackdog> no worries
07:09:48 <mreh> stick around, someone will read the scrollback
07:13:15 * shapr throws lambdas at blackdog
07:13:52 * blackdog quotes the lambda and it falls to the floor, inert and harmless
07:14:10 <mreh> they used to be pointy lambdas
07:14:26 <blackdog> shapr: how's your cabal-fu?
07:14:35 <shapr> I got kicked out of the cabal.
07:14:54 <shapr> And there are tornadoes here...
07:15:21 <blackdog> serious?
07:15:24 <shapr> Yeah
07:15:39 <shapr> Still trying to understand your cabal problem though.
07:15:50 <blackdog> oh, right
07:16:01 <blackdog> well, this is for hubris, right? building shared libs for ruby
07:16:14 <blackdog> so if you haven't enabled --enable-shared, the whole thing is gonna fall over
07:16:23 <blackdog> so in the best case, i'd mandate --enable-shared
07:16:33 <blackdog> worst case, i'd at least like to fail with a decent error message
07:16:50 <shapr> But cabal does not allow you to specify --enable-shared?
07:16:57 <blackdog> it does
07:17:00 <blackdog> but on the command line
07:17:03 <blackdog> i want it to be the default
07:17:07 <blackdog> from inside the cabal file
07:17:22 <shapr> oh
07:17:43 <shapr> So this is a mismatch between what can be specified on the command-line vs what can be specified in the config file?
07:17:44 <blackdog> i figure i'm going to have ruby hackers using it
07:17:51 <blackdog> so it needs to be pretty smooth
07:17:51 <blackdog> yep.
07:18:28 <shapr> blackdog: http://www.weather.com/weather/map/interactive/35630 Red stuff is scary, I'm between Florence and Tuscumbia.
07:19:31 <shapr> blackdog: Is this a case where cabal allows you to pass arbitrary command line arguments, but does not have an ADT value for this particular arg?
07:19:47 <shapr> What version of cabal are you using?
07:19:51 <blackdog> yow, that's close
07:20:01 <blackdog> whatever came with 6.12.1
07:20:07 <blackdog> think i'm running 0.8 of cabal-install
07:20:18 <blackdog> yeah, that's more or less the shape of it
07:20:26 <shapr> Hm, cabal-cache show cabal fails
07:20:49 <edon> why is the prelude file in hoogle is down since yesterday?
07:21:03 <shapr> blackdog: So, there is not a way to pass arbitrary args in the cabal file?
07:21:22 <blackdog> shapr: there might be, but i haven't found it yet.
07:21:25 <shapr> Or perhaps not to the particular part of the build process that you want?
07:22:29 <shapr> If cabal is nicely orthogonal, it should be the same process both ways, so if you find how it gets passed from the command line, you can probably do it from the cabal file.
07:22:52 <blackdog> you would think so
07:22:54 <shapr> Hm, that sentence needed another period or two.
07:23:09 <deteego> does anyone here use Template Haskell by any chance?
07:23:18 <blackdog> but it has an error message that shows the args it will accept, and it's distressingly short
07:23:28 <shapr> blackdog: Show me?
07:23:42 <shapr> I have cabal 1.8 installed, dunno if they're comparable.
07:39:06 <catsai> hi
07:39:17 <catsai> is it easy to write large apps in haskell?
07:39:19 <shapr> hi catsai
07:39:34 <shapr> catsai: About as easy as writing a large app in another language, in my opinion.
07:39:52 <xerox> import Gtk; main = makeHugeWindow >> ...;
07:40:10 <nominolo_> preflex: seen dons
07:40:10 <preflex>  dons was last seen on #haskell 9 hours, 22 minutes and 55 seconds ago, saying: heh
07:40:41 <shapr> xerox: haha
07:41:17 <catsai> ok
07:41:28 <catsai> cause someone in f# was saying in haskell its hard to write large apps
07:41:49 <catsai> <Associat0r> catsai: it's mutliparadigm for a good reason
07:41:49 <catsai> <Associat0r> catsai: it's very hard to write big apps in haskell
07:41:50 <catsai> <Associat0r> catsai: because of lack of proper modularity
07:41:50 <catsai> <Associat0r> catsai: http://lorgonblog.spaces.live.com/blog/cns!701679AD17B6D310!511.entry
07:41:52 <Twey> catsai: You expected something else from someone in an F# channel?  :þ
07:41:52 <catsai> what do u think?
07:41:55 <nominolo_> edon: because a new version of ghc has been released
07:42:49 <catsai> you would?
07:43:08 <blackdog> catsai: you shouldn't believe us or the F# guys. neither of us are trustable a priori. Do some research and make up your own mind.
07:43:42 <blackdog> That said, there are a few big systems written in Haskell - the compiler is one, xmonad is another, and a bunch of banks have a lot of internal code written in haskell
07:43:56 <blackdog> the other pat answer is that if you build it right, it doesn't turn into a big app.
07:44:08 <BMeph> xerox: I think you just copied that... ;p
07:45:39 <Twey> I think it is harder to build a big app in Haskell because it tends to end up being a bunch of smaller apps.
07:45:43 <Twey> Modularity does that.
07:46:17 <BMeph> Twey: "proper modularity" ;)
07:46:20 <bremner> Twey: examples?
07:46:38 <Twey> bremner: happstack, xmonad
07:50:15 <Twey> I don't think the author of this article has tried Serious Functional Programming — they're getting bogged down in things like first-class functions, and not considering resulting patterns like combinator libraries, which are a much more important indicator of ‘functionality’, considering that everybody and his dog has first-class functions these days
07:51:48 <portnov> "I'm Serious Cat. This is Serious Functional Programming." ;)
07:53:24 <Gwern-away> portnov: no no. I are serious cat. this are serious fp
07:54:01 <portnov> :)
07:55:44 <Gwern-away> hm. wonder who admins code.haskell.org
07:55:58 <Gwern-away> let's see if /etc/sudoers will tell me!
07:56:16 <Gwern-away> :( permission denied what the heck
07:57:15 <Gwern-away> adm:!:4:igloo
07:57:21 <Gwern-away> guess that's the best I can do
07:59:30 <catsai>  catsai: I don't know why I'm bothering but ... Theres no one best way to do things. As people like to say not everything is a nail. F# gives you your choice of a hammer, screwdriver, and spanner but only has one of each. Haskell on the other hand lacks screwdrivers and spanners but gives you many different types of hammers to choose from. Both can be advantages for different things.
08:00:03 <Mathnerd314> hmmm... does xmonad work on windows?
08:00:09 <Twey> Mathnerd314: No
08:00:17 <Twey> catsai: Again, that sounds like someone who hasn't used much Haskell.
08:00:23 <BMeph> I find it interesting how folks bring up how you can do "lazy" programming in eager languages, but there's never an explanation of why they don't use it.
08:00:34 <blackdog> Twey: really? what's stopping it? If you've got an X server there...
08:00:52 <Twey> blackdog: Windows doesn't have an X server :þ
08:00:57 <blackdog> not built in
08:00:58 <Twey> Oh wait… it does now, doesn't it?
08:01:04 <blackdog> but there are X servers that run on windows
08:01:05 <Twey> What was it called, again?
08:01:12 <Twey> Xlong or something?
08:01:14 <blackdog> been years since i used it
08:01:17 <Gwern-away> BMeph: well, they do sometimes. every language has lazy conditionals, pythoners use generators, schemers use streams...
08:01:22 <blackdog> i run a civilised platform:)
08:02:07 <Twey> catsai: It would be more accurate to say that Haskell provides only screwdrivers, but also comes with many pre-fabricated configurations of screwdrivers that serve as extra-flexible hammers and spanners.
08:02:53 <catsai> Many Haskell solutions have a "big enough hammer to pound in many different types of screws" feel to them IMO. (especially the type system hackery stuff)
08:02:55 <catsai> ok
08:03:06 <catsai> so i guess u two agree then
08:03:17 <blackdog> holy flashdancing christ, didn't we get enough metaphors in the great monad tutorial wars?
08:03:19 <EvanR> type system hacker?
08:03:19 <EvanR> y
08:03:20 <BMeph> Twey: Xming? :)
08:03:21 <catsai> <TheSleepingOnion> Many Haskell solutions have a "big enough hammer to pound in many different types of screws" feel to them IMO. (especially the type system hackery stuff)
08:03:41 <Twey> BMeph: Ah, that's it!
08:03:59 <EvanR> catsai: are you like pasting from #fsharp or something
08:04:10 <Twey> blackdog: *grin*
08:04:41 <Gwern-away> @qutoe hammer
08:04:42 <lambdabot> scodil says: you say sledgehammer like it's a bad thing
08:04:43 <Twey> blackdog: ‘Monads are like velociraptors’ will never cease to amuse me
08:04:58 <Twey> \b: now with typo-correction
08:05:00 <mercury^> So you're saying that Haskell is big enough to give proper poundings?
08:05:04 <Gwern-away> 'Information No results found for "monads are like velociraptors".'
08:05:08 <Twey> She's going to run this channel soon
08:05:16 <Gwern-away> Twey: it's always had that
08:05:19 <Twey> (if she doesn't already)
08:05:24 <Twey> Gwern-away: Never noticed :-\
08:05:25 <blackdog> Twey: they know no fear and cannot be stopped?
08:05:36 <BMeph> DAAAAAMN, Smokey! I'm going to have to put that scodil quote in my cookie file. :)
08:05:55 <Gwern-away> shoot an 'error' in their head, and they'll stop just like anything else
08:06:31 <blackdog> i'd like to shoot an error into cabal's head right now
08:06:47 <blackdog> orthogonal to the point of uselessness
08:07:02 * blackdog doesn't mean it baby, he's just angry
08:07:19 <Gwern-away> don't you believe him Cabal, he hit you once, he'll hit you again
08:08:06 <blackdog> that outburst aside, can anyone suggest a way to get Cabal to reject attempts to build my package when --enable-shared is not on (either on the command line or in ~/.cabal/config) ?
08:08:37 <blackdog> you can pass extra options to ghc IF the label's on, but there doesn't seem to be a way to say "set buildable to false if enable-shared isn't on"
08:09:25 <blackdog> i know she's a strong independent woman, but i'm running out of persuasive arguments
08:09:56 <Gwern-away> hm. not shure that's a flag
08:10:13 <Gwern-away> and what sort of package fails if shared libs aren't enabled?
08:10:14 <EvanR> im wondering how to make this function circle :: Double -> Double -> Integer -> Complex Double, circle r w t = ? so that it works for all time t
08:10:43 <blackdog> Gwern-away: Hubris. the whole point is to build a dynamic library that ruby can then suck in
08:11:14 <Gwern-away> blackdog: couldn't you write a custom Setup.hs that adds it if not already there?
08:11:24 <EvanR> assuming r and w are normal values
08:11:27 <blackdog> if i don't have enable-shared on, the thing will build, but fail at runtime
08:11:38 <Gwern-away> blackdog: looks like an option available: Simple/Setup.hs:         configSharedLib (\v flags -> flags { configSharedLib = v })
08:11:40 <blackdog> Gwern-away: hm. I guess so. Haven't written my own Setup.hs before
08:11:54 <catsai> i like doing that
08:12:05 <mercury^> EvanR: what do the parameters represent?
08:12:21 <EvanR> radius speed time
08:13:09 <mercury^> exp(log(r)+iwt)
08:13:18 <EvanR> t is an integer
08:13:38 <EvanR> so it wont be a perfect circle
08:13:51 <EvanR> eventually it will be a circle NaNs ;)
08:14:00 <EvanR> circle of
08:16:32 <Mathnerd314> conceptually, is a thunk like an eagerly evaluated `() -> a` ?
08:18:23 <blackdog> Gwern-away: sorry to ask dumb questions, but i'm a bit stuck again - where can you actually change the value of a flag? preConf seems to want a HookedBuildInfo back, which doesn't seem to contain ConfigFlags
08:18:55 <Gwern-away> blackdog: dunno. I've never written a setup.hs
08:18:58 <Gwern-away> it just looks possible
08:19:12 <blackdog> righto, i'll keep digging. cheers.
08:21:00 <BMeph> EvanR, meet "fromIntegral". fromIntegral, EvanR. ;)
08:21:22 <EvanR> revisiting the restrictions, it has to work for all time
08:21:25 <EvanR> i think i have a solution
08:22:45 <EvanR> divide the circle into n incremental arcs of size (something) which is how far the circle goes per time unit, mod time by n, now use fromIntegral
08:23:28 <EvanR> for very fast speed this will be inaccurate, but thats unavoidable
08:24:41 <EvanR> im thinking i can just eliminate time if its an integer
08:25:04 <EvanR> the above allows an infinite list circle that never messes up
08:27:29 <EvanR> > 2*pi/100
08:27:30 <lambdabot>   6.283185307179587e-2
08:27:48 <EvanR> > [0,2*pi/10..2*pi]
08:27:49 <lambdabot>   [0.0,0.6283185307179586,1.2566370614359172,1.8849555921538759,2.51327412287...
08:27:57 <EvanR> > [0,2*pi/2..2*pi]
08:27:58 <lambdabot>   [0.0,3.141592653589793,6.283185307179586]
08:29:44 <EvanR> > let inc = 6.283185307179587e-2 in [0,inc..2*pi - inc]
08:29:45 <lambdabot>   [0.0,6.283185307179587e-2,0.12566370614359174,0.1884955592153876,0.25132741...
08:29:48 <EvanR> nice :)
08:32:38 * EvanR delves into the black magic of Floating
08:34:59 <blackdog> has anyone got an example of a cabal confHook?
08:37:14 <blackdog> alright, failing that: what's a really complicated package that's likely to be using some weird stuff in Setup.hs?
08:43:07 <malosh> Hi. I need to quickly draw Bezier surfaces in OpenGL to check the result of a numerical computation. I saw that the old hopengl page has an example of how I can do this, but unfortunately it doesn't compile anymore with the new API. Any pointer ?
08:43:48 <malosh> (and Bezier surfaces are _not_ stable under projections :-(
08:54:16 <blackdog> Gwern-away: thanks, that worked out. had to find a Setup.hs to mimic, though.
08:54:27 <blackdog>    confHook = \ info flags ->  (confHook simpleUserHooks) info (flags { configSharedLib = Flag True })
09:03:45 * hackagebot control-monad-free 0.5.0.1 - Free monads and monad transformers  http://hackage.haskell.org/package/control-monad-free-0.5.0.1 (PepeIborra)
09:11:48 * hackagebot iso3166-country-codes 0.1 - A datatype for ISO 3166 country codes  http://hackage.haskell.org/package/iso3166-country-codes-0.1 (JonFairbairn)
09:12:33 <Gwern-away> blackdog: see? extensibility ftw
09:13:18 <srush> is there a reason there is no non-IO logging lib on haskell
09:13:20 <blackdog> Gwern-away: you are _not_ suggesting that the userHooks architecture is a shining light of extensibility, surely.
09:13:28 <blackdog> there's an apology on the manual page!
09:13:38 <srush> do people just roll their own?
09:13:43 <blackdog> srush: Debug.Trace
09:14:07 <blackdog> past that, order of evaluation is not really guaranteed, so logging gets a bit weird
09:14:22 <EvanR> Debug.Trace isnt for logging, its for debugging
09:14:28 <srush> yeah
09:14:35 <EvanR> pure logging doesnt make much sense
09:14:35 <srush> I want logging
09:14:40 <blackdog> EvanR: sure. but that's the closest we've got.
09:14:40 <EvanR> its i/o
09:14:44 <srush> why not?
09:14:48 <EvanR> because its i/o
09:14:52 <blackdog> you can restrict it by putting it in a Writer monad
09:14:56 <blackdog> it's a bit more restricted than IO
09:14:58 <EvanR> ah yeah
09:15:00 <EvanR> Writer
09:15:11 <EvanR> now logging make sense ;)
09:15:14 <srush> yeah, that's what I was thinking
09:15:22 <Gwern-away> blackdog: the point is that even crappy extensibnility is good
09:15:31 <Gwern-away> blackdog: it's like being turing-complete - you only need a toe in the door
09:15:49 <blackdog> extensibility is like pizza? :)
09:15:51 <srush> all the cool stuff of hslogger, but just not IO
09:16:31 <blackdog> srush: you can't really have it both ways. calling unsafePerformIO on hsLogger probably won't kill you, but you'll get weird orderings
09:16:50 <blackdog> if you want it ordered, then you should have put a monad on it
09:16:56 * blackdog hums beyonce innocently
09:17:05 <srush> hmm
09:17:11 <srush> I disagree
09:17:26 <srush> I can have writer without having IO
09:17:30 <BMeph> Extensibility is like a velociraptor in a space suit, on a burrito and pizza binge...
09:17:36 <EvanR> you have to write the result of writer at some point
09:17:42 <EvanR> in IO
09:17:49 <srush> fine, but that's true with everything
09:18:03 <EvanR> well, unsafePerformIO breaks the rule
09:18:24 <srush> I wasn't planning on using unsafePerformIO
09:30:32 <franka> Quiet, eh?
09:30:33 <b0fh_ua> Hi there! "cabal list" results in "cabal: Couldn't read cabal file "./HDBC/2.2.6/HDBC.cabal""
09:30:42 <b0fh_ua> how can I fix that?
09:31:22 <franka> Saa, ne.
09:34:17 <dcoutts_> b0fh_ua: what does cabal --version say?
09:35:34 <b0fh_ua> dcoutts_: cabal-install version 0.6.4
09:35:40 <b0fh_ua> using version 1.6.0.3 of the Cabal library
09:36:01 <dcoutts_> blackdog: see darcs or the new gtk2hs packages, they've got complex Setup.hs scripts
09:36:23 <blackdog> dcoutts_: google was my friend, i sorted it out. thanks, though.
09:36:30 <blackdog> i'm doing some thoroughly filthy stuff in there
09:36:39 <blackdog> shelling out to call ruby from Setup.hs...
09:36:58 <blackdog> the things we do to avoid making users type in a flag or two
09:39:08 <dcoutts_> b0fh_ua: hmm, I can't check very easily atm. I suggest for the moment just don't try and list every package, be more selective.
09:39:21 <Gwern-away> blackdog: come to think of it, isn't there a ghc flag for shared libraries you could just toss into ghc-options:?
09:39:54 <blackdog> yeah, -dynamic
09:40:06 <Gwern-away> so why bother with a setjup/hs?
09:40:16 <dcoutts_> can't just chuck it into ghc-options however, it needs more than that
09:40:23 <blackdog> i had that before, but then you end up with objects that are built dynamically that cabal thinks are built statically
09:40:32 <dcoutts_> right
09:40:48 <blackdog> it gets confusing, i'd rather avoid the hassle (or at least keep the hassle in areas that i know about)
09:43:01 <blackdog> dcoutts_: I am having one problem, though. I have a file "Includes.hs" which is generated as part of a confHook.
09:43:03 <EvanR> is there like an unfold for monads
09:43:28 <blackdog> if i include the module in the exposed modules section of my library, everything's great, except that ./Setup sdist complains
09:43:35 <EvanR> im passing an update value recursively to an IO function, must be a fancier way
09:43:38 <EvanR> updated
09:43:50 <blackdog> as it's generated straight into the dist/build directory.
09:44:03 <blackdog> am I doing things hideously bass-ackward?
09:44:06 <dcoutts_> blackdog: you'll need to hack the sdist hook in Setup.hs, I think the darcs Setup.hs does that
09:44:15 <dcoutts_> blackdog: no, it all works except sdist
09:44:48 <blackdog> ah, ok. thanks, i'll check out the darcs setup
09:45:45 <Twey> @index unfoldM
09:45:45 <lambdabot> bzzt
09:45:46 <Twey> @index unfoldrM
09:45:47 <lambdabot> bzzt
09:45:50 <Twey> ☹
09:47:46 <mreh> how can I get a list of expressions into whnf?
09:48:21 <Twey> seq it?
09:48:39 <mreh> doesn't that just give me back the same list unevaluated
09:48:52 <mreh> or sec each element?
09:48:55 <Twey> It'll give you the list in WHNF, i.e. evaluated to the first constructor
09:48:55 <mreh> seq*
09:49:14 <Twey> Do you want the list to be in WHNF, or each expression in the list?
09:49:17 <mreh> oh sorry, how can I get *each element* in the list in WHNF
09:49:19 <Twey> Ah
09:49:25 <Twey> Then yeah, map seq
09:49:32 <mreh> :t seq
09:49:33 <lambdabot> forall a t. a -> t -> t
09:49:53 <mreh> :t map (join seq)
09:49:54 <lambdabot> forall a. [a] -> [a]
09:50:03 <Twey> join seq is not useful
09:50:11 <Twey> You want to tie it to the list itself, I guess
09:50:41 <Twey> whnf list = map (seq list) list
09:51:01 <Twey> whnf = join (map . seq)
09:51:25 * mreh is mildly confused
09:51:31 <Exyph> foldr seq ?
09:51:33 <Twey> Then evaluating the top-level of the list will evaluate all its elements to WHNF
09:51:38 <b0fh_ua> How do I convert between Data.ByteString.Char8 and Data.ByteString.Lazy ? I am using Curl to download content as Data.ByteString.Char8, and I need to calculate MD5 checksum
09:51:38 <portnov> :t join (map . seq)
09:51:39 <lambdabot> forall a. [a] -> [a]
09:51:43 <Twey> Exyph: That'll return the last element
09:51:45 <Twey> Not a list
09:51:58 <b0fh_ua> pureMD5 module accepts lazy bytestrings only
09:51:58 <Exyph> foldr seq list `seq` list
09:52:26 <Exyph> you can look NFData or something like that there is already those whnf hnf etc...
09:52:28 <Twey> That'd do it
09:52:30 <Twey> Yeah
09:52:36 <Twey> That's the smart way :þ
09:53:55 <Exyph> b0fh_ua: fromChunks, I guess
09:54:01 <blackdog> argh. there isn't a way to tell sdist "bugger off, i know what i'm doing"? performUnsafeCabalJiggeryPokery or something?
09:54:17 <mreh> :t (\l -> foldr seq l `seq` l
09:54:18 <lambdabot> parse error (possibly incorrect indentation)
09:54:19 <mreh> :t (\l -> foldr seq l `seq` l)
09:54:20 <lambdabot> forall b. b -> b
09:54:28 <Exyph> b0fh_ua: LBS.fromChunks [BS.pack "xxx"] -- that's what I do often
09:54:30 <kbateman> I'm trying to remember how to wrap diverse types up in a class so you can put them all in a list.
09:54:51 <b0fh_ua> Exyph: okay, thanks a lot
09:55:02 * hackagebot clevercss 0.2 - A CSS preprocessor  http://hackage.haskell.org/package/clevercss-0.2 (GeorgBrandl)
09:55:02 <mreh> I'm still a bit confused about the second argument of `seq`
09:55:16 <mreh> the first one is the thing you want to evaluated to WHNF
09:55:40 <Exyph> mreh: (foldr seq) - forces elements to be converted to whnf
09:56:02 <dcoutts_> blackdog: sure, you can do stuff before and after and you can modify the description that is passed to sdist (eg filter out the generated module)
09:56:28 <Exyph> mreh: there is also `par` from Control.Concurrent (I guess)
09:56:37 <blackdog> dcoutts_: so if i filter out the generated module from the package description, it'll escape the check?
09:56:51 <mreh> Exyph: that's for parallel evaluation
09:57:21 <Exyph> mreh: yes, that's exactly what I'm trying to point. their FP semantic is the same
09:57:26 <dcoutts_> blackdog: it's not so much a check, as it's trying to find the module so it can put the source file in the tarball, it's not just a spurious enforcement check, it's trying to do something useful and not make broken tarball
09:58:19 <blackdog> sure. but the net effect would be that it'd ship happily without that package, and so long as the configure hook creates it, we'll all be happy?
09:59:11 <dcoutts_> blackdog: I think so
09:59:51 <blackdog> ok. what does an Exposed-Module equate to in PackageDescription terms? would just filtering it out of extraSrcFiles be enough?
10:00:07 <Exyph> mreh: consider (flip const) = (seq) = (par) from functional point of view
10:00:08 <blackdog> sorry for continual questions, it's been a while since i delved into cabal
10:00:38 <mreh> Exyph: I understand, I'm more interested in the operational details
10:01:01 <mreh> i'm optimising memory usage
10:01:31 <Exyph> mreh: seq forces inlining of first argument to head (i.e. (a,b) will force evaluation of (,), but not a and b itself)
10:01:32 <blackdog> ah, no. follow Library down. think i got it
10:01:52 <mreh> Exyph: that applies to lists also I guess?
10:02:06 <Exyph> mreh: exactly, but instead of (,) there is (:)
10:02:08 <dcoutts_> blackdog: exposed modules are the ones that other packages can import, other modules are hidden
10:02:36 <mreh> @src zipWith
10:02:36 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
10:02:37 <lambdabot> zipWith _ _      _      = []
10:02:46 <Exyph> mreh: that's why its much easier to use class/instance to force calculation
10:02:59 <mreh> Exyph: huh?
10:03:16 <mreh> you mean strict data fields?
10:03:28 <Exyph> i.e. instance (NFData a, NFData b) => NFData (a,b) where nf (a,b) = nf a `seq` nf b
10:04:06 <mreh> that's Data.Evaluation.Strategies isn't it?
10:04:26 <mreh> or something
10:04:49 <Exyph> mreh: I don't remember exactly. there should be two places one for NFData and other for Strategies/Concurrent
10:05:02 <Exyph> in first place you define how to force calculation
10:05:18 <Exyph> in other you specify how to apply that forcing for data
10:05:20 <fax> @pl nf (a,b) = nf a `seq` nf b
10:05:20 <lambdabot> nf = fix ((`ap` snd) . (. fst) . (flip =<< (((.) . seq) .)))
10:05:36 <fax> @unpl uncurry . seq`on`nf
10:05:36 <lambdabot> (\ c -> uncurry (on seq nf c))
10:05:41 <fax> fffff
10:05:59 <fax> @pl nf' (a,b) = nf a `seq` nf b
10:05:59 <lambdabot> nf' = uncurry ((. nf) . seq . nf)
10:06:00 <Exyph> my mystake nf (a,b) = nf a `seq` nf b `seq` ()
10:07:08 <Exyph> mreh: Stratgies allows you to process several  chunks of list in parallel (in case when list structure is calculated faster than elements)
10:13:53 <Mathnerd314> @type uncurry
10:13:54 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
10:14:54 <Mathnerd314> what's the inverse of a -> b -> c? with an uncurried function, it would just be c -> (a,b), but currying seems to make it complicated.
10:15:43 <Exyph> Mathnerd314:  (flip . curry) ?
10:15:50 <Mathnerd314> :t flip . curry
10:15:51 <lambdabot> forall a b a1. ((a1, a) -> b) -> a -> a1 -> b
10:16:06 <franka> The type is (b->c)->a.
10:16:54 <Mathnerd314> I'm looking for the inverse; function g such that g . f = id
10:17:27 <fax> that does not type check
10:18:08 * hackagebot hubris 0.0.3 - Support library for Hubris, the Ruby <=> Haskell bridge  http://hackage.haskell.org/package/hubris-0.0.3 (MarkWotton)
10:18:25 <franka> If you ask for an inverse of a->b->c you are asking for an inverse of a curried function, namely a closure which has received a term of type a but not of type b.
10:18:26 <blackdog> that feels better:)
10:18:45 <franka> It is different from an inverse of (a,b)->c.
10:19:27 <Mathnerd314> :t curry . uncurry
10:19:28 <lambdabot> forall a b c. (a -> b -> c) -> a -> b -> c
10:19:28 <franka> Because a->b->c = a->(b->c).
10:20:57 <EvanR> how do i collect the results of a repeated IO action maybe, until i get Nothing
10:21:18 <EvanR> @hoogle IO (Maybe a) -> IO [a]
10:21:18 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
10:21:18 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
10:21:18 <lambdabot> Network.Socket getAddrInfo :: Maybe AddrInfo -> Maybe HostName -> Maybe ServiceName -> IO [AddrInfo]
10:21:57 <Mathnerd314> :t (:)
10:21:59 <lambdabot> forall a. a -> [a] -> [a]
10:24:00 <Mathnerd314> :t uncurry . (:)
10:24:01 <lambdabot>     Couldn't match expected type `b -> c' against inferred type `[a]'
10:24:01 <lambdabot>     Probable cause: `:' is applied to too many arguments
10:24:01 <lambdabot>     In the second argument of `(.)', namely `(:)'
10:24:53 <Mathnerd314> :t uncurry (:)
10:24:54 <lambdabot> forall a. (a, [a]) -> [a]
10:25:43 <Mathnerd314> so the inverse of that is something like split :: [a] -> (a, [a])
10:26:22 <Mathnerd314> so how would you write that curried?
10:28:28 <Exyph> Mathnerd314: language doesn't implement such things usually
10:29:20 <Exyph> Mathnerd314: that's almost the same as differentiation of function. you can implement it, but there is no magic function that will do it without any sacrifice like additional data carried with a function
10:30:04 <shapr> Has anyone played with the cabbage "tcp" ? Is there a tutorial for how to hack on that tcp/ip stack?
10:30:53 <Gwern-away> cabbage?
10:31:05 <shapr> Cabal package == cabbage?
10:31:16 <dcoutts_> heh
10:31:22 <Twey> Haha
10:31:23 <Mathnerd314> Exyph: I want some way to "curry" it so I can "pull" an argument out easily to get a function tail :: [a] -> [a]
10:31:38 * Gwern-away doesn't like cabbage. we don't have a vegetable theme
10:31:47 * EvanR throws a celery into the channel
10:32:18 <shapr> Well, Python has eggs, ruby has gems...
10:32:27 <Gwern-away> eggs smell; gems shatter
10:32:30 <shapr> I think Haskell is far more pragmatic and should be a staple food, so ...
10:32:42 <Gwern-away> vegetables have the opposite connotations of intelligence and speed that we should want
10:33:13 <shapr> Ok, what do you suggest?
10:33:16 <dcoutts_> shapr: anyway, wasn't hackage supposed to be a haskell package?
10:33:26 <dcoutts_> and hackagedb, the collection thereof
10:33:26 <Gwern-away> shapr: 'package'
10:33:33 <Gwern-away> crazy I know
10:33:37 <Gwern-away> but I think we can pull it off!
10:33:42 <BMeph> Meat!
10:33:45 <Twey> :t whileM
10:33:45 <shapr> dcoutts_: hm, I could go for that.
10:33:46 <lambdabot> Not in scope: `whileM'
10:33:49 <Twey> Hmph
10:33:50 <shapr> haskell package == hackage.
10:33:51 <dcoutts_> shapr: but in typical use we've just shortened it to hackage for the collection
10:33:59 <shapr> Yeah, the collection should have a different name.
10:34:30 <Gwern-away> @hoogle whileM
10:34:30 <lambdabot> No results found
10:34:39 <EvanR> untilM
10:34:46 <EvanR> ^
10:34:59 <Gwern-away> @hoogle until
10:34:59 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
10:35:24 <Polarina> BONUS, ping!
10:35:25 <Twey> untilM p a = a >>= flip when (untilM p a) . p
10:35:26 <shapr> So anyway, has anyone used the hackage "tcp"? It's Peng Li & Steve Zdancewic's TCP/IP stack. I'm curious how it compares to the tcp/ip stack used in h0p/House/LightHouse.
10:35:39 <Twey> :t let untilM p a = a >>= flip when (untilM p a) . p in untilM
10:35:40 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> Bool) -> m a -> m ()
10:35:42 <Polarina> BONUS, "This comes in use when you're dealing with monoids as results of computations that may have failed. Because of this instance, we don't have to check if the computations have ***falied*** by seeing if they're a Nothing or Just value; we can just continue to treat them as normal monoids."
10:35:45 <Polarina> BONUS, spelling error.
10:35:49 <Twey> untilM isNothing action
10:36:06 <Twey> @hoogle untilM
10:36:06 <lambdabot> No results found
10:36:06 <EvanR> ah
10:36:15 <Twey> Yeah, untilM is one I miss
10:36:16 <EvanR> then ill grab an untilM
10:37:30 <Exyph> :t head . catMaybes
10:37:31 <EvanR> Twey: how about :: IO (Maybe a) -> IO [a]
10:37:31 <lambdabot> forall a. [Maybe a] -> a
10:38:23 <Exyph> :t liftM (head . catMaybes)
10:38:24 <lambdabot> forall a (m :: * -> *). (Monad m) => m [Maybe a] -> m a
10:38:51 <EvanR> hm opposite
10:39:59 <Exyph> :t liftM (head . catMaybes) . liftM repeat
10:40:00 <lambdabot> forall a (m :: * -> *). (Monad m) => m (Maybe a) -> m a
10:40:25 <Exyph> something wrong... :)
10:40:37 <Mathnerd314> :t liftM maybeToList
10:40:39 <lambdabot> forall a (m :: * -> *). (Monad m) => m (Maybe a) -> m [a]
10:40:50 <EvanR> nice
10:41:05 <EvanR> but it doesnt return the right list
10:41:05 <Twey> EvanR: Don't know… I'll play with it when I get back
10:42:12 <Exyph> :t (liftM (head . catMaybes) . sequence . repeat)
10:42:13 <lambdabot> forall a (m :: * -> *). (Monad m) => m (Maybe a) -> m a
10:42:17 <Exyph> that's better
10:42:45 <EvanR> whats the head for
10:42:47 <Exyph> ahh... it will continue forever
10:42:57 <Exyph> EvanR: to take first Maybe x
10:46:10 <BMeph> ...and if there _is_ no "first Maybe x"? :)
10:46:26 <EvanR> i dont see how the first maybe x is important
10:46:34 <Exyph> it should go forever as expected, as I understand
10:46:41 <EvanR> no
10:46:47 <EvanR> the list stops at Nothing
10:46:54 <mamalujo> hi ppl! um, anyone perhaps have idea what might get standardizes in Hs'11 ? there are very few tickets in their trac for now..
10:47:14 <EvanR> does the IO action until Nothing and returns the IO list of fromJusts so to speak
10:47:46 <jd10_> is there a way of comparing equality of doubles with a given threshold, or should I just write a function for that?
10:48:00 <jd10_> not that it's a complex thing to do -- just wondering.
10:53:02 <burp> write your own
10:53:18 <jd10_> okay thx
10:59:40 <EvanR> cool, haskell has for loop! ;)
10:59:50 <EvanR> forM_ [1..N] $ do... ;)
11:02:33 <sunrayser> A quick question about TH: I have a value of type "Q [Dec]". I created it using [d| ... |]. How can I print out the abstract representation to the console?
11:03:05 <siracusa> sunrayser: runQ [d|...|]
11:03:37 <sunrayser> siracusa: I tried that but that didn't print anything. Is it possible?
11:04:08 <sunrayser> actually, it was "runQ $ representation" and representation defined in another module
11:04:30 <siracusa> Hhm, what about putStrLn =<< (runQ ...)?
11:05:17 <sunrayser> Couldn't match expected type `Char' against inferred type `Dec'
11:05:37 <sunrayser> Q String vs Q [Dec]
11:06:10 <siracusa> Oh yes, a show is missing :-)
11:07:06 <sunrayser> putStrLn =<< (show (runQ representation)) gives an error (IO String vs String)
11:07:31 <siracusa> Argh, one moment ...
11:07:32 <sunrayser> runQ already returns an IO
11:07:38 <sunrayser> ok :)
11:07:59 <dmwit> runQ representation >>= print -- ?
11:08:10 <osaunders> Can anyone suggest a cleaner way of doing this <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25030>?
11:08:44 <sunrayser> dmwit: yes, that's working, thanks!
11:09:04 <dmwit> osaunders: Take a look at Data.List.Split
11:09:06 <dmwit> ?hackage split
11:09:06 <lambdabot> http://hackage.haskell.org/package/split
11:09:22 <dmwit> osaunders: If there's a better way, it's in there. If it's not in there, you should write a patch. ;-)
11:09:24 <siracusa> Yes, print or putStrLn =<< liftM show (runQ [d| a = 1|])
11:10:05 <dmwit> putStrLn =<< liftM show x === print =<< x
11:11:12 <sunrayser> thanks guys, every line here teaches me more than all the docs out there
11:12:47 <Eelis> can anyone think of a less evil implementation (preferably in terms of pure Haskell, or perhaps using TH) of:   #define matches(pattern) (\x -> case x of pattern -> True; _ -> False)
11:13:01 <Eelis> the problem is that patterns aren't first class entities
11:13:11 <osaunders> dmwit: Thanks.
11:14:26 <osaunders> dmwit: You don't think there's a nicer way with just Data.List?
11:15:48 <osaunders> NM.
11:15:49 <fax> Eelis, it's a few pages longer but you can implement first class patterns using GADTs (though I would not recommend it)
11:15:54 * osaunders goes away
11:16:53 <Eelis> fax: hm, i was hoping to also use things like view patterns, which i don't suppose would be very easy to do with that GADT approach? :)
11:17:31 <Eelis> can't TH be of service here?
11:17:33 <Exyph> Eelis: as I understand you want to get some kind of partial matching like in Curry or Prolog?
11:18:04 <Eelis> Exyph: i'm perfectly happy with the functionality of that #define. i just don't like using the preprocessor, so i'm hoping for a cleaner implementation of the same functionality
11:19:27 <Exyph> Eelis: how about class PatternMatch pattSelector value where matches pat val = ... ?
11:19:53 <Eelis> Exyph: then i'd have to construct a value encoding of patterns, no?
11:20:09 <Exyph> yes
11:20:20 <Eelis> which would completely change the usage syntax
11:20:33 <Eelis> especialy since i want to be able to use things like view patterns
11:20:38 <Exyph> Eelis: that's pure Haskell
11:20:56 <Eelis> i can think of lots of pure Haskell things that don't do what i want :)
11:22:04 <Exyph> than you have to use your TH, but you'll need to encode patterns in TH data structures
11:22:17 <Eelis> hmm
11:22:43 <Eelis> maybe i'll dig into TH at some point. i think for now i'll just stick to the macro
11:23:46 <Exyph> i.e. $(matches (ExpQ ...)) -- should produce lambda  according to first argument, p.s. don't remember those ExpQ
11:24:30 <mamalujo> hm, just ran into this paper: http://www.cs.mu.oz.au/~sulzmann/manuscript/objects-unify-type-classes-gadts.ps sounds like a very elegant, scala inspired unification of typeclasses and gatds supporting oo-like idioms..
11:27:41 <Exyph> Eelis: http://www.haskell.org/haskellwiki/Template_Haskell#Select_from_a_tuple - that's looks like similar task
11:28:27 <Eelis> Exyph: interesting
11:36:58 <EvanR> $ is so useful, how about making function application right associative, use parens to use the 'normal' way
11:37:31 <EvanR> eliminating $
11:39:57 <Eelis> EvanR: you'd honestly prefer to write "(map f) l" instead of "map f l" ?
11:41:03 <EvanR> usually f or l is more complex
11:41:32 <EvanR> there can be a 'reverse' $ for simple cases, map f $ l
11:41:50 <Eelis> so much for your scheme of eliminating $ :)
11:42:03 <EvanR> question is which way uses $ more
11:44:29 <flux> should be relatively simple. take a few thousands lines of representative haskell code and make the transformation manually. then evaluate :)
11:44:33 * hackagebot transformers 0.2.1.0 - Concrete functor and monad transformers  http://hackage.haskell.org/package/transformers-0.2.1.0 (RossPaterson)
11:44:38 <flux> possibly generate white paper in the process..
11:47:36 <byorgey> EvanR: I think that's a terrible idea.  Now every time you have a function of the form  W -> X -> Y -> Z and just want to apply it to a few simple arguments you have to write ((f w) x) y
11:47:49 <byorgey> whereas right now you can just write  f w x y
11:47:51 <EvanR> probably right
11:48:27 <byorgey> although I guess writing things like  f (w (x y)) isn't too uncommon either
11:48:42 <byorgey> but usually I'd write that  f . w . x $ y
11:49:07 <EvanR> f w x y is more common if you have more definitions, f . w . x $ y is more common if you spell it out inline
11:49:55 <EvanR> my idea basically only applies to control.monad and do expressions
11:51:12 <byorgey> how's that?
11:51:25 <EvanR> thats where find a lot of $
12:10:18 <mreh> I have a stack overflow and I  can't find it
12:12:43 <EvanR> profiling?
12:12:56 <tensorpudding> You can make the stack larger using RTS
12:12:59 <Gwern-away> mreh: try prefixing a http, as in, http://www.stackoverflow.com
12:16:34 <Peaker> Is fromEnum a homomorphism w.r.t Ord?
12:18:26 <Peaker> if a > b then fromEnum a > fromEnum b ?
12:19:51 <wvd> What do you guys think about "Write yourself a Scheme in 48 hours"
12:19:57 <franka> Peaker, I think that is the intention inasmuch as I think Prelude instances respect it.
12:20:30 <franka> Dunno if programs actually rely on it.
12:21:30 <guerrilla> so, when i do 'cabal install array', i get this (http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25033) output.. googling isnt telling me much. any suggestions as to how to resolve this?
12:21:31 <franka> I think write is not a reflexive verb.
12:22:01 <dcoutts_> guerrilla: the solution is not to re-install the array, package, the version that comes with ghc will do fine.
12:23:16 <guerrilla> dcoutts_: ok. good to know.. i'll go back to my original problem that caused me to think i should reinstall array then :) thanks
12:26:07 <benmachine> > fix (compare LT)
12:26:11 <lambdabot>   mueval-core: Time limit exceeded
12:26:51 <orlandu63> @src fix
12:26:51 <lambdabot> fix f = let x = f x in x
12:27:25 <orlandu63> how is that useful?
12:27:35 <benmachine> useful for encoding recursion
12:27:45 <benmachine> @pl forever a = a >> forever a
12:27:45 <lambdabot> forever = fix (ap (>>))
12:27:59 <EvanR> is fix the same thing as Y
12:28:12 <benmachine> I believe so
12:28:41 <franka> fac n = fix (\f -> if n == 0 then 1 else f (n-1)
12:28:44 <alise_> Why oh why is there no function satisfying "pow :: Int -> Rational -> Rational"?
12:28:50 <alise_> @hoogle Int -> Rational -> Rational
12:28:50 <lambdabot> Data.Bits clearBit :: Bits a => a -> Int -> a
12:28:51 <lambdabot> Data.Bits complementBit :: Bits a => a -> Int -> a
12:28:51 <lambdabot> Data.Bits rotate :: Bits a => a -> Int -> a
12:28:53 <alise_> @hoogle Integer -> Rational -> Rational
12:28:53 <lambdabot> Data.Ratio (%) :: Integral a => a -> a -> Ratio a
12:28:54 <lambdabot> Data.Ratio approxRational :: RealFrac a => a -> a -> Rational
12:28:54 <lambdabot> Data.Fixed mod' :: Real a => a -> a -> a
12:28:55 <franka> brrr
12:29:13 <franka> fac n = fix (\f -> if n == 0 then 1 else n * f(n-1))
12:29:17 <benmachine> alise_: huh? raising the Int to a Rational power, or vice versa?
12:29:28 <benmachine> or c. other
12:29:29 <alise_> benmachine: raising the integral (or rational; I don't care) to a rational power, yes.
12:29:43 <benmachine> alise_: what would pow 2 (1 % 2) give you
12:29:55 <alise_> Well, true.
12:30:00 <benmachine> :)
12:30:09 <alise_> Oh, I know.
12:30:13 <benmachine> there are like three different exponentiation functions
12:30:17 <alise_> I'm defining a computable-real type anyway, so I'll just use that
12:30:20 <benmachine> things have to be in the right type
12:30:26 <alise_> there, pow 2 (1%2) would give the perfect answer :-)
12:30:37 <benmachine> well ok, but it wouldn't be Rational
12:30:51 <alise_> ugh, I can't even do that since my reals are Integer->Rational
12:31:01 <alise_> benmachine: well pow 2 (1%2) would return some value "in the vicinity" of sqrt 2
12:31:04 <alise_> ideally
12:31:08 <benmachine> heh
12:31:14 <alise_> preferably, with paramaterisable precision
12:31:20 <alise_> since my reals are basically precision -> approximation
12:31:35 <benmachine> that sounds like quite a niche use if you ask me
12:32:02 <alise_> It is! But I want it anyway ...
12:32:16 <alise_> I'm trying to implement the Chudnovsky algorithm to have a pi value :-)
12:32:21 <alise_> I should just use Few Digits, but this is more fun.
12:33:35 <alise_> I'll just use the Gregory-Leibniz series.
12:33:37 <alise_> How upsetting.
12:35:22 <nus> @type rnf
12:35:23 <lambdabot> forall a. (NFData a) => a -> Done
12:35:32 <nus> @type rdeepseq
12:35:33 <lambdabot> Not in scope: `rdeepseq'
12:35:37 <nus> @type deepseq
12:35:38 <lambdabot> Not in scope: `deepseq'
12:35:43 <fax> > 1/(sum $ map (\k -> (-1)**k * 12 * factorial (6*k) * (13591409 + 545140134*k) / (factorial (3*k) * factorial k ^3 * 640320**(3*k+3/2))) [0..2])
12:35:44 <lambdabot>   3.1415926535897936
12:35:54 <alise_> fax: yeah but the ** is the problem
12:35:57 <alise_> it's not defined for Rational
12:36:08 <alise_> and I need it to arbitrary precision :-(
12:36:26 <Veinor> fax: O_o
12:36:33 <alise_> Veinor: how's that O_o
12:36:37 <Veinor> it converges fast
12:36:38 <alise_> http://en.wikipedia.org/wiki/Chudnovsky_algorithm
12:36:41 <alise_> yes
12:36:44 <alise_> it's the state of the art :)
12:37:08 <alise_> ...which gregory-leibniz definitely /isn't/, but it also has no pesky **
12:37:19 <julietm> join/ #social-engineer
12:37:47 <alise_> yay; I can approximate pi to a gigantic rational
12:37:50 <alise_> now to get that as a decimal...
12:38:08 <fax> > sqrt 12 * (sum $ map (\k -> (-3)**(-k)/(2*k+1)) [0..20])
12:38:09 <lambdabot>   3.141592653595635
12:39:06 <EvanR> > pi
12:39:07 <lambdabot>   3.141592653589793
12:39:11 <alise_> *Main> pi :: CReal
12:39:11 <alise_> ~ \_ -> 3.142591654339543
12:39:18 <alise_> Takes about half a second to even return that approximation.
12:39:28 <EvanR> > pi :: CReal
12:39:29 <lambdabot>   3.1415926535897932384626433832795028841972
12:39:31 <alise_> And that's only evaluating to precision 1000.
12:39:37 <alise_> EvanR: mine's a different creal
12:39:53 <tensorpudding> What formula do they use for pi...
12:40:00 <fax> probably atan
12:40:02 <tensorpudding> maybe Machin's formula?
12:40:05 <alise_> *Main> fromRational $ (pi::CReal) 1
12:40:05 <alise_> 2.6666666666666665
12:40:10 <alise_> I think Few Digits uses atan
12:40:15 <alise_> but I dunno if that's the CReal in lambdabot
12:40:23 <fax>   pi = 16 * atan (fromRational (1 % 5))
12:40:23 <fax>                 - 4 * atan (fromRational (1 % 239))
12:40:34 <joejacobs> hey guys! quick question. is there any way to get the definition of a function from within haskell?
12:41:01 <tensorpudding> You can use the hoogle search engine to find haddocks that contain definitions
12:41:04 <tensorpudding> @where hoogle
12:41:04 <lambdabot> http://haskell.org/hoogle
12:41:16 <alise_> joejacobs: @src in lambdabot/GoA
12:41:45 <Saizan_> those are not really "from within", but there's nothing closer than that
12:42:08 <joejacobs> sorry but what is GoA?
12:42:13 <fax> > 768*sqrt(2-sqrt(2+sqrt(2+sqrt(2+sqrt(2+sqrt(2+sqrt(2+sqrt(2+sqrt(2+1)))))))))
12:42:14 <lambdabot>   3.1415904632367617
12:42:16 <nus> @where GoA
12:42:17 <lambdabot> http://haskell.org/haskellwiki/GHC/GHCi#GHCi_on_Acid
12:42:19 <alise_> ghci on acid; ghci with lambdabot grafted in
12:42:21 <xerox> alise_: what about this http://en.wikipedia.org/wiki/Bailey%E2%80%93Borwein%E2%80%93Plouffe_formula
12:42:39 <alise_> the nice thing about the gregory-leibniz series is that all the individual terms are rational...
12:42:40 <xerox> it's parallelizable! :D
12:42:54 <alise_> which is basically required for the way i'm doing things (dumbly)
12:43:11 <wvd> What do you guys think about "Write yourself a Scheme in 48 hours"
12:43:17 <alise_> wvd: I don't like it
12:43:33 <wvd> alise_: Why?
12:43:42 <wvd> IT sounds interesting since i'm interested in compilers and Haskell
12:43:56 <fax> wvd: it's not very good imo
12:44:05 <wvd> Ok
12:44:13 <wvd> So not recommend as first Haskell book?
12:44:35 <alise_> Read Learn You a Haskell; or Real World Haskell.
12:44:39 <alise_> (Or both.)
12:44:51 <nus> @where RWH
12:44:51 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
12:44:53 <tensorpudding> @where rwh
12:44:53 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
12:44:54 <nus> @where LYAH
12:44:54 <lambdabot> http://www.learnyouahaskell.com/
12:45:21 <wvd> Both free?
12:45:30 <alise_> yes. see the second like of rwh
12:45:32 <alise_> and the only link of lyah.
12:45:38 <wvd> ok
12:45:44 <alise_> You can buy a dead tree Real World Haskell if you so desire.
12:46:13 <alise_> Learn You a Haskell is nice for someone who doesn't really have any experience how to "program functionally"; if you can't stand silly cartoons don't read it.
12:46:24 <alise_> Also it ends a bit early, so I'd move on to Real World Haskell afterwards.
12:46:45 <wvd> Ok
12:46:53 <wvd> Thanks :)
12:49:00 <wvd> I might read RWH from the beginning then, even when I don't got FL experience.
12:49:01 <silver> sicp is nice for the FP fundamentals if ypu can stand scheme and all the stuff that comes with it :)
12:49:20 <wvd> But RWH seems to also mention 'real-world' examples such as buidling libs
12:49:23 <wvd> building*
12:49:24 <alise_> wvd: Learn You a Haskell is a much better introduction for the non-IO programming, I think.
12:49:28 <alise_> At the beginning.
12:49:37 <alise_> Then Real World Haskell gets you Doing Stuff quickly.
12:49:45 <EvanR> i liked sicp
12:49:52 <alise_> SICP has nothing to do with Haskell guys :P
12:50:07 <wvd> alise_: Right, but where should I step in at RWH? And you'll get stuff like "as we did in chapter .. "
12:50:20 <alise_> wvd: Well, I'd just start with Learn You a Haskell.
12:50:32 <alise_> Then you should be able to read RWH, skipping every chapter that appears completely trivial. :P
12:50:39 <alise_> RWH doesn't devote too much time to the intro stuff.
12:50:43 <alise_> So there should not be /too/ much overlap.
12:50:45 <wvd> k
12:53:20 <EvanR> this is annoying
12:54:03 <EvanR> if i put top level types, for example foo :: Word32 -> X, then i have to import something just to get the Word32 type, if i dont have the type, i dont have to import it ;)
12:55:28 <aavogt> then whichever other modules you import to get functions over Word32 should have reexported Data.Word
12:55:41 <EvanR> it doesnt
12:55:51 <aavogt> which is it?
12:55:59 <EvanR> Graphics.UI.SDL
13:08:53 <DigitalKiwi> ivanm: hulp
13:18:58 * hackagebot ght 0.3.0 - Trivial routines for inspecting git repositories  http://hackage.haskell.org/package/ght-0.3.0 (ConradParker)
13:29:15 <mreh> is there no HOF that can transform a function to be strict?
13:29:30 <ddarius> :t ($!)
13:29:31 <lambdabot> forall a b. (a -> b) -> a -> b
13:29:55 <mreh> that evaluates the argument
13:29:57 <nus> @src ($!)
13:29:57 <lambdabot> f $! x = x `seq` f x
13:30:05 <ddarius> That's what strict means.
13:30:19 <mreh> hmmm
13:30:48 <EvanR> maybe you want to defer a strict application ;)
13:31:39 <EvanR> sounds tricky
13:33:41 <roconnor> EvanR: what does merh
13:33:46 <roconnor> EvanR: what does mreh want?
13:34:05 <mreh> strict evaluation in haskell :)
13:34:16 <mreh> i think I'll use a deep seq
13:34:28 <EvanR> nevermind
13:34:43 <EvanR> (f ($!)) transforms a function to be strict
13:34:48 <EvanR> erm
13:34:52 <EvanR> (f $!)
13:37:14 <EvanR> mreh: just wondering, what application needs strict evaluation everywhere
13:37:38 <mreh> EvanR: memory efficient haskell
13:37:47 <mreh> EvanR: building a gram matrix
13:38:07 <mreh> all the inner products cause a big stack overflow
13:42:47 <mreh> > (+) `foldr` 0 [1..10]
13:42:48 <lambdabot>   Ambiguous type variable `t' in the constraints:
13:42:49 <lambdabot>    `GHC.Num.Num t' arising ...
13:43:35 <Saizan_> foldr (+) stack overflowing is not about lazyness at all
13:44:34 <mreh> I know, I'm uzing zipWith in my code
13:45:14 <mreh> I was just wondering if you could use a ternary operator infix
13:45:52 <Saizan_> > (+) `foldr` 0 $ [1..10]
13:45:52 <hda5>  /j #archlinux-ru
13:45:53 <lambdabot>   55
13:47:15 <rfh> how would the construction of the positive numbers as a recurse datatype look like?
13:47:30 <EvanR> homework? :)
13:47:33 <rfh> *recursive
13:48:01 <lament> data Homework = Assignment | More Homework
13:48:10 <rfh> "self study exercise"
13:48:10 <mreh> rfh: Paeno Arithmetic
13:48:35 <EvanR> @google paeno
13:48:36 <lambdabot> No Result Found.
13:48:49 <rfh> data Nat = Zero | Succ Nat would be the natural numbers
13:48:55 <rfh> but what about all positive numbers
13:48:58 <lament> :|
13:48:59 <xerox> @remember lament <rfh> how would the construction of the positive numbers as a recurse datatype look like? <lament> data Homework = Assignment | More Homework
13:48:59 <lambdabot> Okay.
13:49:12 <mreh> lol, wut
13:49:16 <lament> rfh: data Nat = One | Succ Nat -- ?????
13:49:40 <mreh> rfh: the natural numbers are all positive
13:49:50 <EvanR> simple, you change the definition to include only the positives
13:49:56 <rfh> mreh: true
13:50:01 <EvanR> alternatively, 'zero isnt a natural'
13:50:10 <mreh> I didn't say that
13:50:45 <rfh> but 0.1 isnt in Nat
13:50:54 <lament> oh
13:50:59 <lament> you mean all positive numbers
13:51:09 <mreh> real numbers
13:51:15 <lament> do you mean all positive rational numbers, or all positive real numbers?
13:51:24 <lament> or all possible computable numbers, or something else?
13:51:26 <rfh> guess so
13:51:35 <lament> you need to be more specific
13:51:42 <mreh> ask a mathematician
13:51:43 <rfh> all real numbers
13:51:46 <EvanR> all numbers that can be considered positive somehow ;)
13:51:59 <rfh> all positive real numbers, sorry
13:52:00 <mreh> irrational numbers?
13:52:09 <lament> rfh: you can't do that.
13:52:26 <rfh> i mean, its like a recursive datatype within a recursive datatype
13:52:35 <lament> oh wait, can you?
13:52:38 <lament> i guess you can
13:52:49 <EvanR> computables
13:52:59 <lament> it's just a binary tree
13:53:10 <rfh> haskell is lazy so dont bother about that
13:53:44 <lament> or just a list with two elements
13:54:06 <EvanR> that includes zero doesnt it ;)
13:54:30 <EvanR> he only wants positives
13:54:54 <lament> oh, i see
13:54:56 <lament> interesting
13:55:19 <rfh> when construct as a tree than each brach would have "infinity" many branches i suppose
13:56:02 <EvanR> unlimited branches doesnt mean you can write a program to construct the tree for any real number, right
13:56:11 <rfh> its like a extension of Nat = Zero | Succ Nat
13:56:27 <lament> you don't need unlimited branches, you just need an infinite list with two possible elements
13:56:36 <lament> that gives you [0,1]
13:56:43 <EvanR> [Bool]
13:56:51 <rfh> Just that between Zero and Succ Zero and Succ(Succ Zero) and .... is also a recursive definition
13:56:54 <lament> er, not [0,1]
13:57:10 <lament> [0,2)
13:57:27 <EvanR> depends on what you consider the first place to be
13:57:28 <lament> i mean [0,2]
13:57:38 <lament> yeah
13:57:42 <EvanR> first place is 1/2, then its [0,1]
13:58:02 <lament> but if you specifically want to exclude 0 then it's trickier
13:58:16 <EvanR> im reminded of components of the form 1/n
13:58:39 <EvanR> egyptian style ;)
13:59:45 <rfh> exercise: Construct the positive numbers as a recursive datatype.
13:59:58 <EvanR> positive real numbers
14:00:39 <lament> :t (.) (.)
14:00:40 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
14:00:45 <rfh> since 1.42 is a positive number, i can assume the author means positive reals too
14:00:55 <EvanR> what book is thi
14:00:56 <EvanR> s
14:01:20 <rfh> introduction into functional programming using haskell
14:01:21 <roconnor> EvanR: what does merh
14:01:23 <roconnor> oops
14:01:25 <roconnor> sorry
14:01:27 <rfh> from richard bird
14:01:28 <EvanR> time warp
14:01:33 <roconnor> :)
14:01:41 <roconnor> wibbly wobbly
14:02:39 <EvanR> data R = Recip Integer | Cons R R
14:03:11 <EvanR> a real is either 1/n for some n, or a an arbitrary sum of 1/n
14:03:26 <fax> wait what is Cons ?
14:03:27 <burp> um, that's rational isn't it?
14:03:45 <EvanR> you can get irrationals like this with an infinite sum
14:03:45 <fax> EvanR, I suppose that is not unique either?
14:03:52 <EvanR> i doubt it, i just made it up
14:03:54 * roconnor is confused
14:04:03 <roconnor> fax: what's going on?
14:04:04 <fax> you cannot use infinite lists in haskell to represent infinite sequences like tht
14:04:21 <EvanR> why not
14:04:30 <fax> roconnor well I just got here
14:04:36 <EvanR> that explains it
14:04:49 <fax> EvanR what explains what?
14:04:52 <EvanR> we just finished saying that you can represent reals in [0,1] with a [Bool]
14:05:05 <fax> EvanR, I'm talking about R
14:05:07 <fax> that one you just defined
14:05:13 <Saizan_> roconnor: rfh is asking about defining an ADT for positive real numbers
14:05:24 <EvanR> fax: either way its a possibly 'infinite' structure
14:05:51 <Saizan_> rfh: are you sure the exercise is not simply talking about the positive natural numbers?
14:05:52 <roconnor> Saizan_: stern-brocot tree?
14:06:21 <fax> EvanR, You have to put a condition on the Conses if you want this to be infinite and usable
14:06:31 <fax> such as, they all get smaller
14:06:36 <rfh> Saizan_: than the solution would be 2 pages before data Nat = Zero | Succ Nat
14:06:38 <EvanR> first of all i never said this is usable
14:06:55 <EvanR> yes, it seems you can have a divergance
14:07:00 <EvanR> oh well
14:07:10 <rfh> Saizan_: but that doesnt matter anymore, i m just interested in a construction for positive reals, if possible
14:07:50 <EvanR> rfh: 1/n OR an arbitrary sum of arbitrary 1/ns where n positive
14:07:51 <EvanR> integer
14:07:59 <Saizan_> roconnor: i'm not sure how i'd write an ADT for describing the vertices of this tree http://en.wikipedia.org/wiki/Stern–Brocot_tree
14:08:27 <roconnor> Saizan_: [Bool]
14:08:32 <EvanR> look someone made a better way
14:08:54 <EvanR> but it uses continued fractions
14:09:40 <Saizan_> roconnor: oh, duh
14:11:03 <EvanR> fax: so we want one which has a 1 to 1 correspondence with positive reals?
14:11:16 <fax> EvanR: I don't think thats possible
14:11:28 <EvanR> got a proof? :)
14:11:33 <fax> yes
14:11:39 <fax> I shouldn't say "think" when I know something I guess
14:12:22 <EvanR> ok?
14:13:44 <kbp> http://codepad.org/Fc77xG2F <----- could anyone please help me? I cant find any "unexpected `}`" :(
14:13:56 <mreh> is there a zipWith'?
14:13:59 <mreh> like foldl'
14:14:10 <mreh> I should propose one
14:14:42 <aavogt> @type zipWith . ($!)
14:14:42 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
14:15:05 <mreh> that's not the same as what I'm thinking of
14:15:08 <mreh> @src zipWith
14:15:08 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
14:15:09 <lambdabot> zipWith _ _      _      = []
14:15:14 <aavogt> that's not as strict as foldl' in a way
14:15:49 <mreh> zipWith f (a:as) (b:bs) = f a b `seq` f a b : zipWith f as bs
14:15:54 <mreh> would that work?
14:16:02 <aavogt> you need a let in there
14:16:07 <mreh> right
14:16:14 <mreh> let x = f a b
14:16:38 <aavogt> that's still a right fold though...
14:17:00 <mreh> zipWith is a foldr?
14:17:07 <aavogt> at least in that you can get some results back before the whole thing is done
14:18:00 <mreh> I'm taking the inner product of some long vectors
14:18:12 <mreh> the result would be much shorter than the redex
14:18:32 <mreh> maybe my inner product needs to be strict
14:19:46 <mreh> halp?!
14:19:48 <sepp2k> kbp: When I try to compile the code, I get a Syntax error, but not "unexpected }". When I remove the last line, I get type errors.
14:20:59 <kbp> sepp2k: oh i see it now, thank you :)
14:20:59 <sepp2k> The last line is wrong because it's an expression outside of any function.
14:26:35 <orlandu63> @src null
14:26:35 <lambdabot> null []     = True
14:26:35 <lambdabot> null (_:_)  = False
14:26:47 <orlandu63> wouldn't null _ = False suffice for the latter?
14:27:03 <xerox> yep
14:27:23 <BONUS> > null undefined
14:27:24 <lambdabot>   *Exception: Prelude.undefined
14:27:28 <BONUS> depends
14:27:37 <orlandu63> on what?
14:27:53 <BONUS> what kind of behavior you want when you apply null to undefined
14:27:58 <EvanR> whether undefined is null or not ;)
14:28:05 <BONUS> oh wait
14:28:07 <BONUS> forget i said that
14:28:25 <EvanR> > let null _ = False in null undefined
14:28:25 <lambdabot>   False
14:28:26 <BONUS> the first pattern forces some evaluation either way
14:28:42 <EvanR> > let null [] = False in null undefined
14:28:42 <lambdabot>   *Exception: Prelude.undefined
14:28:46 <BONUS> to WHNF
14:28:59 <BONUS> so yeah, it doesn't really matter
14:29:14 <orlandu63> so the (_:_) removes the laziness of _?
14:29:18 <orlandu63> if that makes sense
14:29:27 <Gracenotes> any kind of pattern matching fails for undefinedness
14:29:30 <scree> EvanR: I think you can prove that you can't have bijective correspondence with positive reals
14:29:44 <EvanR> really?
14:29:54 <orlandu63> interesting
14:29:59 <scree> EvanR: if you have an infinite product of finite sets as your representation
14:30:01 <EvanR> what about x -> -x
14:30:10 <EvanR> ah
14:30:46 <scree> so, you want "far away" bits of your data structure to be steadily less significant
14:31:11 <aavogt> > let notUsefulNull ~(_:_) = True in notUesfulNull undefined
14:31:12 <lambdabot>   Not in scope: `notUesfulNull'
14:31:19 <aavogt> > let notUsefulNull ~(_:_) = True in notUsefulNull undefined
14:31:20 <lambdabot>   True
14:31:30 <scree> you put a metric that does this, like \sum_i 2^-i d(x_i, y_i)
14:31:42 <orlandu63> what does the ~ do?
14:31:49 <scree> so your translation function should be continuous
14:31:51 <benmachine> Gracenotes: how about this one:
14:31:58 <benmachine> > case undefined of Endo _ -> True
14:31:59 <lambdabot>   True
14:32:15 <Gracenotes> that doesn't do pattern matching
14:32:15 <scree> but (I think) the product representation is compact, which the reals aren't
14:32:30 <benmachine> Gracenotes: there's a constructor right there :P
14:32:32 <Gracenotes> the newtype constructor doesn't exist! open your eyes, man
14:32:35 <aavogt> > case undefined of Any {} -> True -- this looks more fancy
14:32:36 <lambdabot>   True
14:32:42 <benmachine> aavogt: heh, neat
14:33:12 <djahandarie> Is there a good way to hash IPv4?
14:33:36 <ulfdoz> may be the same one you hash 32bit integers.
14:33:43 <aavogt> orlandu63: it's an irrefutable pattern match
14:34:09 <EvanR> scree: hmmm :S
14:34:25 <aavogt> it's used to match on the results regardless of whether you actually have that constructor passed
14:34:48 <djahandarie> I just don't want it to be possible to determine the IP from the hash given the hash function within a small amount of operations
14:34:51 <aavogt> > case [] of ~(_:_) -> "one"; [] -> "two"
14:34:52 <lambdabot>   "one"
14:35:00 <djahandarie> Is that even possible with such a small range of values?
14:35:02 <orlandu63> oh
14:35:13 <benmachine> case x of ~p -> r is pretty much like case x of t -> let p = t in r
14:35:37 <aavogt> in combination with @ in patterns it's convenient to have less nesting:
14:36:10 <ulfdoz> djahandarie: Its safe to assume, that all values up to 32bit are known by lookup tables for every reasonable widespread hash-function.
14:36:45 <aavogt>   main = do { args @ ~(one:two:three:_) <- getArgs; when (null args) $ error "too few args"; ... here assume that at least 'one' is defined }
14:38:01 <djahandarie> ulfdoz, so basically it'd be unreasonable to think that you could store an IP address securely?
14:38:19 <ulfdoz> djahandarie: No, blow it up with a secret string.
14:38:33 <djahandarie> ulfdoz, and what if the attacker knows the secret string?
14:38:48 <ulfdoz> djahandarie: Then, it isn't secret.
14:39:04 <djahandarie> Right, those are the parameters I'm working under.
14:39:13 <orlandu63> aavogt: interesting
14:40:08 <orlandu63> so what would be contained in two and three if the list is only one element long? []?
14:40:18 <aavogt> you'll get an error
14:40:28 <aavogt> but only when you try to use two or three
14:40:54 <orlandu63> > lol
14:40:55 <lambdabot>   Not in scope: `lol'
14:40:56 <orlandu63> this error?
14:41:22 <aavogt> > case [] of ~[x] -> show x
14:41:23 <lambdabot>   "*Exception: <interactive>:1:133-157: Irrefutable pattern failed for patter...
14:41:47 <aavogt> no, you get a runtime error
14:41:48 <orlandu63> ok
14:42:20 <aavogt> I think you can catch those though
14:42:32 <aavogt> anyways, that style is quite uncommon
14:43:22 <djahandarie> ulfdoz, basically, the attacker will know hash function H(x) and its domain. The domain's size would be the size of IPv4, which is about 4 billion.
14:43:56 <djahandarie> ulfdoz, so I'm assuming it'd be impossible to protect against just constructing a lookup table for those values fairly quickly?
14:44:18 <djahandarie> Unless I make H(x) slow enough, I guess.
14:44:19 <ulfdoz> djahandarie: Without preparing that IPv4 adress it is.
14:44:52 <djahandarie> ulfdoz, even if I do H(f(x)) where f prepares the IPv4 address, they will know f() as well. And f() won't change the size of the domain.
14:44:53 <ulfdoz> djahandarie: Crypt is "broken" this way for all passwords up to 8 characters (so called rainbow tables)
14:45:48 <ulfdoz> djahandarie: No, it wont, it doesn't even increase the enthropy of the input. But it "moves" the domain to a totally different set of values.
14:46:28 <djahandarie> Correct, but it still wouldn't be difficult to construct rainbow tables from those new values, due to the small size of the domain.
14:47:42 <djahandarie> What I'm trying to do is allow "anonymous" file upload, but still be able to ban certain users from the site.
14:47:47 <ulfdoz> djahandarie: Depends on your preparation. Assume you simply append a random string. Without that random string, there is no fast way for reconstructing the original value. If you change that random string for each input value, you'd have to bruteforce for every input value the whole domain.
14:48:13 <djahandarie> ulfdoz, correct, but the purpose of my hashing is for comparing it later, so a random string would not work.
14:48:16 <Gwern-away> perhaps one could make the hash very intensive. if it takes a second to hash, then 4 billion seconds to make a rainbow table
14:48:29 <Gwern-away> blowfish/openbsd does this I think - adjustable hash difficulty
14:48:37 <djahandarie> Gwern-away, right, that was the only idea I could come up with
14:48:39 <ulfdoz> Gwern-away: Is gracefully parallelizable.
14:48:58 <ulfdoz> 64cores make 64sec to one second.
14:49:02 <Gwern-away> ulfdoz: nobody has 4 billion spare processors
14:49:08 <EvanR> djahandarie: if you dont want someone to have some data, dont send it to them :)
14:49:19 <Gwern-away> ulfdoz: and as djahandarie says, what else to do?
14:49:24 <ulfdoz> Gwern-away: But it reduces the time by "5 bits".
14:49:26 <EvanR> perfect encryption ^
14:49:53 <Mathnerd314> hmm... what is the type of a side effect?
14:49:55 <ulfdoz> even 6 bits.
14:50:46 <djahandarie> EvanR, well, the issue I'm trying to tackle here is an authority seizing the data for whatever reason and trying to lookup the IPs. So in that case I'd have to give them any possible functions I'm running on the IP x, whether I'm salting it or hashing it.
14:51:06 <ulfdoz> djahandarie: Essentially I think, that is unsolved. The best you can do, is to use a salt.
14:51:27 <EvanR> djahandarie: ok
14:51:58 <djahandarie> Hm, okay, thanks.
14:52:00 <EvanR> djahandarie: rig your server with plastic explosive and write a python program to detonate via a signal from your smart phone if you determine that the authorities are there
14:52:05 <djahandarie> EvanR, haha
14:52:15 <Gwern-away> jamming
14:52:21 <EvanR> gah
14:52:25 <ulfdoz> A big red button on your Keyboard.
14:53:26 * monochrom remembers "boss mode" in games in the MSDOS days.
14:56:56 <mreh> can `seq` improve performance?
14:57:21 <mreh> my profiling output is confusing, either the program is running longer with it, or seq is increasing throughput
14:58:45 <c_wraith> It mostly improves memory use.  But there could be locality issues that add up to running faster.
15:00:01 <c_wraith> and of course, if it makes your program avoid swapping, it'll run *way* faster.
15:00:10 <Cale> seq can only increase the number of steps it takes to evaluate an expression, but the additional steps can also ensure that the expression stays small.
15:00:11 <monochrom> Chinese proverb: water can float boat, water can also sink boat.
15:00:34 <monochrom> can seq improve performance? seq can float boat, seq can also sink boat.
15:00:43 <Cale> (well, increase, or have no effect on the number of steps)
15:01:06 <c_wraith> yeah, the "have no effect" case can be easy to prove in many cases. :)
15:02:24 <Cale> If you count the reduction of seq x y to y, where x is already evaluated, as a step, then it strictly increases the number of steps.
15:02:44 <Cale> But often the compiler will get rid of those.
15:03:33 <kbp> is it true that we can only do pattern matching iff the data type is derived from (Eq) class?
15:03:54 <Draconx|Laptop> no, it is not true.
15:09:28 <kbp> hm... trying to test but it gives this error http://codepad.org/4oqLHa9i @@
15:11:26 <kbp> by the way just loaded it on Hugs and ur right, no need Eq class to do pattern matching
15:11:32 <Cale> kbp: The Eq class is needed for testing with (==) and (/=), as well as pattern matching against numbers.
15:11:43 <Cale> (as in  f 0 = ... )
15:11:50 <c_wraith> But being an instance of Num requires Eq, right?
15:11:52 <c_wraith> @src Num
15:11:52 <lambdabot> class  (Eq a, Show a) => Num a  where
15:11:52 <lambdabot>     (+), (-), (*)           :: a -> a -> a
15:11:52 <lambdabot>     negate, abs, signum     :: a -> a
15:11:52 <lambdabot>     fromInteger             :: Integer -> a
15:11:53 <Cale> yes
15:12:10 <Cale> (for that reason, though it's a stupid reason)
15:12:44 <Cale> kbp: You're trying to run this with runhugs or something?
15:12:46 <c_wraith> It's a practical reason.  But not really a necessary one.  The compiler would tell you when you're trying to pattern match against a non-Eq Num
15:13:06 <aavogt> same reason for fail being part of Monad
15:13:43 <aavogt> > let "yes" = "no" in ()
15:13:44 <lambdabot>   ()
15:13:51 <kbp> Cale: yea just normal hugs
15:13:52 <Cale> That's a slightly different reason.
15:13:56 <aavogt> > case "yes" of "no" -> ()
15:13:57 <lambdabot>   *Exception: <interactive>:1:133-156: Non-exhaustive patterns in case
15:14:10 <Cale> kbp: The 'undefined variable "main"' error is because you haven't defined main
15:14:18 <c_wraith> > cast "yes" of "no" -> Just 55
15:14:19 <lambdabot>   <no location info>: parse error on input `of'
15:14:20 <c_wraith> err
15:14:24 <c_wraith> > case "yes" of "no" -> Just 55
15:14:25 <lambdabot>   *Exception: <interactive>:1:141-169: Non-exhaustive patterns in case
15:14:29 <Cale> kbp: and so there's nothing for the program to actually do when it's run
15:14:38 <aavogt> there's an implict == there
15:15:05 <Cale> Is there?
15:15:11 <kbp> Cale: oh you mean that, nah it was Codepad... but after that i loaded that code into my hugs and it worked fine
15:15:13 <Cale> It's just a normal list pattern match
15:15:51 <c_wraith> > do { Just x <- Nothing ; Just x }
15:15:52 <lambdabot>   Nothing
15:15:59 <aavogt> Cale: well at some point there == on the CharS that make it up...
15:16:00 <c_wraith> There, that's fail in action.
15:16:01 <Cale> I suppose you could try to say that pattern matching Char values is the same as equality testing on them.
15:16:16 <Cale> But the report treats Char values as data constructors of the Char type
15:16:58 <aavogt> ok, so the definition of (==) is inlined then :)
15:17:46 <monochrom> observationally equivalent
15:18:10 <c_wraith> > do { Just x <- Nothing ; [x] }
15:18:11 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe b'
15:18:11 <lambdabot>         against inferred ...
15:18:45 <c_wraith> > do { [Just x] <- [Nothing] ; [x] }
15:18:46 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe a'
15:18:46 <lambdabot>         against inferred ...
15:18:50 <monochrom> > do { Just x <- [Nothing]; [x] }
15:18:51 <lambdabot>   []
15:18:58 <c_wraith> oh, right
15:19:08 <aavogt> monochrom: you could hide the (==) instances and substitute your own
15:19:14 * monochrom refrains from saying "fail" for pun :)
15:19:30 <aavogt> but then you're not using something specified in the report
15:19:42 <Cale> fail should be in its own class, or we should go back to the Haskell 1.4 translation of the do-syntax.
15:20:08 <monochrom> We should go back to Gofer. So we can all be golfers.
15:20:33 <fax> :D
15:20:43 <monochrom> Imagine "The 12th Gofer Golfing Competition"
15:29:12 <DigitalKiwi> mhr
15:29:56 <Gwern-away> monochrom: 'no gofers were harmed in the making of gofer'
15:30:31 <monochrom> haha
15:32:14 <monochrom> We need that for Haskell Platform. No haskellers were harmed in the making of Haskell Platform (SHP 3928)
15:34:15 <glguy> Cale: can't you rebind do-notation on lambdabot so that fail is in its own class?
15:34:36 <Cale> glguy: That is a good question
15:34:40 <Cale> I don't think that I can.
15:34:48 <Cale> Not without screwing everything up.
15:35:17 <Cale> I would have to redefine the Monad class, which would break compatibility with Control.Monad, and all the other libraries which use the Prelude Monad class
15:49:16 <Saizan> Cale: i think you'd only have to hide Control.Monad.fail (and from everywhere it gets exported..) with NoImplicitPrelude
15:57:10 <mreh> http://paste.ideaslabs.com/show/Zq6awnJsed -- I can't make this woooork
15:57:30 <mreh> it keeps stack-overflowing when I give it too many vectors
15:57:40 <Cale> Saizan: oh, hmm, that's an idea...
15:58:16 <Cale> mreh: I'll take a look
15:58:30 <mreh> Cale: \o/
15:58:42 <Cale> one sec, brb
16:00:08 <Cale> okay, let's see what you're doing here.
16:00:37 <Cale> hmm
16:01:02 <mreh> Cale: do you know what a gram matrix is?
16:01:47 <Cale> A matrix of inner products of a set of vectors?
16:01:49 <mreh> this is a kernel matrix, which is like a gram matrix, which is the inner product between all vectors
16:02:14 <mreh> the kernel matrix just adds one to every inner product as a feature of the mathematics
16:02:28 <mreh> Cale: yes
16:03:06 <Saizan> you have x' `seq` x' : map' f xs, itym x' `seq` (x' : map' f xs)
16:03:26 <Cale> I'm wondering about how that associates
16:03:53 <Cale> seq has really low precedence (as low as ($))
16:04:10 <Saizan> ah, maybe they are the same then
16:04:35 <mreh> I thought they were
16:04:55 <Cale> I'm not sure that I understand the purpose of this map' anyway though.
16:05:19 <Cale> It will ensure that the function is evaluated as you walk down the list
16:05:43 <mreh> Cale: it's meant to stop it stack-overflowing
16:05:50 <Cale> Does it help?
16:06:10 <mreh> Cale: a little it seems, profiling demonstrates it uses half as much memory roughly
16:06:31 <mreh> i.e. it runs twice as long before it overflows its stack
16:07:05 <Cale> okay
16:09:13 <Cale> So, is this whole thing equivalent to [[kernelF v w + 1 | w <- xs] | v <- xs] ?
16:09:28 <Cale> (up to differences in strictness)
16:10:03 <Cale> Well, there's this trnspsJoin that I'm not sure I understand
16:10:23 <mreh> Cale: yeah, I was trying to make it more efficient with trnspsJoin to only compute half the innerproducts due to symmetry
16:10:37 <Cale> init, btw, is extremely expensive
16:10:45 <mreh> Cale: ha, okay
16:11:04 <Cale> Because it has to reconstruct the whole list
16:11:56 <Cale> hmmm
16:12:16 <mreh> I was thinking it wasn't as expensive as computing the inner product
16:12:28 <Cale> Well, that might be true
16:12:52 <mreh> but it only increases efficiency by a constant factor, so for simplicity I say drop it
16:13:05 <Cale> You have O(n^2) more inner products, vs. O(n^2) more list cells to build
16:13:37 <Cale> If you use [[kernelF v w + 1 | w <- xs] | v <- xs], then it shouldn't stack overflow
16:13:48 <mreh> really?
16:13:59 <Cale> If it does stack overflow in that case, then the problem is elsewhere.
16:14:01 <mreh> I am still such a newbie
16:14:10 <mreh> yeah, it must be
16:15:08 <Cale> Basically, the stack consists of case expressions who are waiting for their scrutinee to be sufficiently evaluated so they can pattern match
16:15:54 <mreh> the idea of using the list comprehension was the last thing on my mind too, but it simplifies things a lot
16:16:30 <Cale> So are you still seeing a stack overflow there?
16:16:41 <mreh> yes, it must be elsewhere in the code
16:16:56 <Cale> Let's take a look at the code which generates the vector you're working with
16:17:01 <ivanm> *sigh* looks like even with the patch for 6.12.1, gtk2hs fails to build on 6.12.2 :s
16:17:03 <mreh> the list comprehension is infact much faster
16:17:09 <Cale> (or maybe the code for the kernelF you're using)
16:17:18 <dcoutts_> ivanm: I don't believe it!
16:17:35 <ivanm> dcoutts_: is that sarcastic?
16:17:51 <dcoutts_> ivanm: :-)  so what's the problem?
16:17:58 <mreh> Cale: you are thinking the lists aren't fully evaluated aren't you?
16:18:04 <Cale> It could also be the code which is summarising the result.
16:18:06 <ivanm> something about a qualified import being wrong
16:18:17 * ivanm is building again as there was too much noise from other packages being built
16:18:19 <Cale> You don't necessarily want lists to be fully evaluated
16:19:11 <ivanm> dcoutts_: tools/c2hs/base/syms/Attributes.hs:100:5:    Illegal qualified name in import item: Map.findWithDefault
16:19:24 <Cale> The places where you want strictness are where you're taking a "large" datastructure (or a large collection of single values) as input, and somehow collapsing that down into a result which is "small" in the sense that it doesn't have many parts which could be evaluated separately
16:19:26 <nus> ivanm, there was something about qualified imports in the release notes
16:19:38 <ivanm> oh, and this probably doesn't help: can't find file: gtk/Graphics/UI/Gtk/Pango/Types.hs
16:19:52 <ivanm> nus: for what? 6.12.2 or gtk2hs?
16:19:59 <dcoutts_> ivanm: na, that's just an earlier build error
16:19:59 <nus> former
16:20:21 <ivanm> nus: ahhh
16:20:30 <dcoutts_> ivanm: seems to be fixed in the darcs version, try patching
16:20:48 <ivanm> ahhh, could be this: Failed to load interface for `System.Glib.UTFString'
16:20:51 <ivanm> that's the last error
16:20:57 <mreh> Cale: I'll show you the code that generates the data, it's reading flat files and converting the data into a custom data type
16:21:02 <Cale> mreh: An inner product is a good example of that. You want the summation to be computed strictly, if the vectors are high-dimensional.
16:21:30 <Cale> mreh: If the vectors are low-dimensional (less than 100k elements) then don't worry about that part.
16:21:34 <mreh> Cale: quite, that's why I'm using the kernel trick also :D
16:21:57 <mreh> it bypasses the high dimensional space entirely, so no need to worry
16:22:10 <Cale> okay
16:22:14 <mreh> http://paste.ideaslabs.com/show/DUeP6LmAe8
16:22:32 <mreh> that reads the flat files into a datatype
16:22:41 <Cale> php error
16:22:45 <Cale> You should use hpaste ;)
16:22:55 <mreh> scroll down?
16:23:02 <Cale> oh, but it's down too :)
16:23:16 <Cale> oh, it just hadn't finished loading
16:23:19 <mreh> both hpaste mirrors are down
16:23:31 <Cale> glguy: isn't that your server?
16:23:34 <joejacobs> hey guys, another quick question. is it possible to apply a power function on two rationals without converting to integers? Ive tried *, **, ^ and ^^ but none of them work.
16:23:51 <Cale> joejacobs: You could convert to Double
16:24:00 <Cale> joejacobs: In general, the result won't be rational.
16:24:11 <Cale> Unless the exponent is an integer.
16:24:23 <dcoutts_> ivanm: for reasons I've never worked out, the make does not stop at the first error, so since c2hs did not build then you get the next problem about things that required c2hs
16:24:42 <Cale> mreh: aha!
16:24:57 <mreh> this sounds promising
16:25:00 <joejacobs> Cale: no way to keep them as rationals and apply a power function then?
16:25:01 <Cale> mreh: How long is the sequence you pass to tallyAminoAcids?
16:25:11 <ivanm> dcoutts_: *nod*
16:25:15 <ivanm> dcoutts_: that appears to be it
16:25:17 <mreh> Cale: that's not causing the stack overflow
16:25:20 <Cale> joejacobs: Consider something like 2^(1/2)
16:25:25 <Cale> joejacobs: It's not a rational number
16:25:40 <ivanm> dcoutts_: anyway, complete build log
16:25:44 <ivanm> http://paste.pocoo.org/show/205811/
16:25:48 <Cale> mreh: are you sure? You're building up large expressions which look like (1 + (1 + (1 + ...)))
16:26:07 <Cale> er... (((...) + 1) + 1) rather
16:26:14 <mreh> Cale: profiler does not report that function is used, anyway, I knew that :)
16:26:18 <Cale> okay
16:26:25 <joejacobs> Cale: thx for the help
16:26:28 <Cale> but that is a stack overflow waiting to happen regardless :)
16:26:59 <dcoutts_> ivanm: have you tried patching tools/c2hs/base/syms/Attributes.hs ?
16:27:06 <ivanm> dcoutts_: not yet
16:27:20 <ivanm> dcoutts_: gimme a minute, I just got up and am reading all my emails, etc.!
16:27:21 <mreh> okay, i'll fix it
16:27:28 <Cale> mreh: hmm
16:27:29 <dcoutts_> ivanm: :-)
16:27:42 <mreh> Cale: there's more code
16:27:52 <Cale> mreh: okay
16:29:21 <mreh> is there a decent paste site that doesn't fuck up the syntax highlighting for haskell?
16:30:07 <ivanm> dcoutts_: OK, sedding time...
16:32:22 <mreh> i've got y' and it thinks it's a character
16:33:16 <mreh> http://pastebin.com/PaNSvQMN
16:33:45 <mreh> all this evaluation hell makes me wonder why I shouldn't go back to Java
16:34:07 <Gwern-away> even with evaluation hell, haskell is more pleasant
16:35:14 <QtPlatypus> evaluation hell?
16:35:57 <EvanR> seems like hard numerics is a good place to use C or fortran ;)
16:36:24 <mreh> QtPlatypus, the operational symatics of a compiler
16:36:37 <ivanm> DigitalKiwi: so, did you get it working?
16:38:07 <DigitalKiwi> ivanm: i got that bit working
16:38:32 <DigitalKiwi> now i'm trying to get it to go into the tree :(
16:38:33 <ivanm> yay!
16:39:27 <DigitalKiwi> i'm failing at recursion :(
16:39:41 <Cale> mreh: The variable 'epochs' -- how large is it?
16:39:51 <mreh> Cale: 1
16:39:59 <Cale> okay
16:40:09 <Cale> So that iterate/!! is safe...
16:40:21 <DigitalKiwi> ivanm: don't suppose you might be able to help me? :D
16:40:35 <ivanm> DigitalKiwi: heh, I haven't used fortran for a few years
16:40:41 <ivanm> and even then I didn't do any string mangling :s
16:40:45 <DigitalKiwi> well it might just be a logic thing
16:42:00 <Cale> mreh: Just checking, you're compiling with -O2, right?
16:42:06 <Younder> What is the name of the paper by Simon P. Jones on the implementation of Haskell?
16:42:13 <mreh> Cale: nooo
16:42:20 <Cale> (I always have to check this when people have stack overflows)
16:42:21 <ivanm> DigitalKiwi: can't stay for long though
16:42:32 <DigitalKiwi> ivanm: k
16:42:47 <mreh> Cale: why can this help/hinder?
16:43:08 <DigitalKiwi> ivanm: http://pasteit.ghost1227.com/2839
16:43:28 <monochrom> Younder: something like "implementing functional languages"
16:43:31 <DigitalKiwi> it never goes past     the_tree%ll = construct_tree1(leftexp)
16:44:11 <DigitalKiwi> tbh i don't know how to do this so i am basing it off of pseudocode the instructor gave and i don't know how good that is working :(
16:44:18 <ivanm> not sure how recursive stuff in fortran works :s
16:44:46 <ivanm> DigitalKiwi: when is this due?
16:45:24 <DigitalKiwi> may 4th but i told the professor i would work on it this weekend and email him sunday about what i think they need to cover in the study session
16:45:38 <DigitalKiwi> i'm like the only person who has ever programmed before in the class >.>
16:46:41 <DigitalKiwi> it's a glguy_ !
16:47:06 <Cale> mreh: Strictness analysis is turned off unless you use at least -O
16:47:19 <Cale> mreh: Strictness analysis removes a lot of stack overflows automatically.
16:47:33 <DigitalKiwi> ivanm: the problem is it gets to the stop before actually adding to the tree anything :(
16:47:42 <Cale> In particular, things like 'sum' will cause stack overflows on lists that are too long if you don't have at least -O
16:47:43 <mreh> this amazes me
16:48:06 <ivanm> DigitalKiwi: the "IF (tmp /= "(") THEN" stop?
16:48:12 <DigitalKiwi> right
16:48:23 <DigitalKiwi> but that's how the pseudocde says to have it so i'm lost >.>
16:48:29 <ivanm> Cale: OK, with how martin is giving FGL up for adoption, what changes would you want to make you start using it?
16:48:30 <mreh> even with -O2 it still stack overflows
16:48:33 <orlandu63> is ++ left- or right-associative?
16:48:44 <DigitalKiwi> http://cse.unl.edu/~nbenes/fortran/p4/p4pcode.pdf
16:48:45 <Cale> ivanm: Name the functions sanely.
16:48:46 <mreh> the most inefficient
16:48:57 <mreh> orlandu63, ^
16:48:58 <ivanm> DigitalKiwi: hang on, no-one has programmed before and they're doing recursive stuff in _Fortran_? :o
16:49:05 <DigitalKiwi> yeah
16:49:05 <Cale> orlandu63: right
16:49:07 <ivanm> @slap DigitalKiwi's professor
16:49:07 * lambdabot pokes DigitalKiwi's professor in the eye
16:49:11 <Cale> orlandu63: (which is the efficient way)
16:49:24 <DigitalKiwi> implementing linked lists and binary trees and stacks and reverse polish notation...
16:50:09 <ivanm> DigitalKiwi: what's the sample input you're using?
16:50:24 * ivanm hazards a guess that it doesn't start with a "(" and thus fails
16:50:54 <ivanm> DigitalKiwi: put a "write(*,*) tmp" before that IF statement
16:50:55 <DigitalKiwi> str = "((57+4)+(3/(4$(3-(9/8)))))"
16:51:27 <DigitalKiwi> it correctly gets the left subtree
16:51:30 <DigitalKiwi> ( 57+ 4 )
16:51:40 <fax> what's $
16:51:41 <DigitalKiwi> but then recurses and widdles it down further until it stops ::(
16:51:46 <QtPlatypus> I wonder if recursion is hard if you don't introduce then to more procedural models first.  The other part of my wonders if recursion is inherently hard, people struggle with proof by induction as well which is essentioanly the same thing.
16:51:51 <DigitalKiwi> exponentiation
16:52:07 * ivanm would answer fax if it weren't for that /ignore ...
16:52:08 <Younder> monochrom, found it, thanks
16:52:19 <fax> I never struggled with recursion of proof by induction and I am by no means smarter than average
16:52:29 <fax> I think it's a self perpetuating myth that these things are difficult
16:52:35 <Adamant> QtPlatypus: recursion is sort-of easy if you explain it right
16:53:04 <fax> I remember once asking a question in class (about something that was not induction, which I understood completely at this point) -- and the teacher misunderstood my question and re-explained induction to me
16:53:05 <Adamant> in terms of base case and 'modifying' case
16:53:46 <ivanm> DigitalKiwi: put a "write(*,*) tmp" before that IF statement and see where it's stopping
16:53:56 <Twey> My physics teachers do that all the time.  It's infuriating.
16:54:12 <monochrom> QtPlatypus: I see extra pedagogical flaws in most teaching of induction.
16:54:31 <QtPlatypus> monochrom: Could you expand on what you see as flaws?
16:54:38 <SubStack> I hate how physics professors abuse intermediate state so much
16:55:03 <DigitalKiwi>  57tmp stop
16:55:12 <fax> I think "induction is difficult" might be because nobody knows what a proof is
16:55:17 * ivanm notices even dons is getting into the "why are you downvoting me?" whining on reddit...
16:55:33 <fax> You can probably pass an undergraduate maths degree without knowing what a proof is
16:55:36 <ivanm> DigitalKiwi: so it isn't even parsing the entire left subtree
16:55:41 <DigitalKiwi> it is
16:55:51 <Cale> mreh: How many pairs in the list passed to findKernelPerceptronWeights?
16:56:07 <DigitalKiwi> that is the third time it is recursed
16:56:08 <Adamant> no, you can't, but some classes try to make folks do proofs without having ever bothered to teach proofs.
16:56:15 <ivanm> DigitalKiwi: hmmm... *shrug*
16:56:23 <fax> there is also a very strong link between induction and recursion, and not exploiting that just makes both harder to tearch
16:56:31 <QtPlatypus> fax: Well "What is a proof" is an open question in the philosphy of mathmatics.
16:56:44 <ivanm> sorry, I've g2g; my brother's band is marching in the ANZAC day parade today and I said I'd go watch it on TV since I'm not going to go watch it in person
16:56:44 <DigitalKiwi>  http://pasteit.ghost1227.com/2840
16:56:49 <DigitalKiwi> k :(
16:56:52 <DigitalKiwi> thanks
16:56:53 <mreh> Cale: more than 500 stack overflows
16:56:53 <monochrom> Firstly the distinction between ((∀n.Pn) ⇒ (∀n.P(n+1))) and (∀n. Pn⇒P(n+1)) is not explicitly made to answer students' worry of circularity. Secondly prior teaching shows forward proofs exclusively, even to the point of banning backward proofs; but induction is a backward-proof step, doesn't fit.
16:57:28 <fax> QtPlatypus: I think the work from Frege, Russel, Godel, Gentzen, and many others have answered this question sufficently -- education certainly hasnt' caught up though
16:57:34 <theorbtwo> By backward proof, you mean RAE?
16:58:00 <Cale> mreh: Replace the insertWith in adjustWeight with insertWith'
16:58:15 <QtPlatypus> fax: If your a formulist yes.
16:58:28 <Cale> mreh: also, it looks like you're accumulating things in both parts of the pair that is the state there.
16:58:41 <mreh> okay
16:58:41 <QtPlatypus> But this is getting very off topic
16:58:54 <monochrom> By forward proof I mean processing premises until the desired conclusion emerges. By backward proof I mean processing the desired conclusion until the premises emerge. Induction tells you to process the desired conclusion for one step.
16:59:16 <Cale> Not only will operations on the Map build up, the i counter will build up because there's nothing which is forcing its evaluation until the very end either
17:00:00 <QtPlatypus> monochrom: I've always fround backwards proofs easer to find.
17:00:43 <monochrom> Generally, processing the more complex side first is easier. Usually.
17:01:09 <monochrom> But highschool teachers explicitly ban backward proofs.
17:01:36 <QtPlatypus> monochrom: I've noticed that, why?
17:02:13 <fax> maybe if they showed people how to do backward proof the kids might learn something :P
17:02:35 <monochrom> Because following a 2000-year-old tradition.
17:03:51 * QtPlatypus recalls presenting a proof that the thing I wished to poove was logicaly equiverlent to 0=0.  And since 0=0 was true then my statement must be true as well.
17:04:03 <fax> yes!
17:04:05 <QtPlatypus> And having my high school teacher reject it.
17:04:05 <fax> a = b
17:04:06 <Zao> No matter the direction, proving things by randomly applying axioms until you get a result annoys me.
17:04:06 <monochrom> Indeed what fax says, ignoring for example what Gentzen did.
17:04:09 <fax> a*0 = b*0
17:04:11 <fax> 0 = 0
17:04:15 <fax> hence a = b! :)
17:04:49 <Zao> It's quite fun when you try to prove that sqrt(5) is imaginary and end up with 3 = 5.
17:05:04 <monochrom> It is true that no matter which direction you do you must clearly say it so readers can check. It is not true that one of the directions is unsound.
17:05:48 <mreh> Cale: i gets used every iteration
17:05:50 <Twey> sqrt(5) is imaginary?
17:05:56 <Twey> o.@
17:05:56 <mreh> but, i'll try and see what happens!
17:06:14 <QtPlatypus> Twey: sqrt(5) is imaginary implies 3=5
17:06:33 <Twey> How?
17:07:10 <QtPlatypus> (F -> F) is a true statement.
17:07:13 <luite> ex falso quodlibet
17:07:26 <monochrom> recursion in programming should be slightly easier than induction in math classes because in programming at least you can test and it takes only a minute to test. if you hand in proof homework for math class it takes 2 weeks to grade.
17:07:46 <Cale> mreh: does it?
17:07:48 <Twey> Unless the proof is in Agda?  ;)
17:08:01 <mreh> Cale: yeah, it's used in insertWith
17:08:11 <Cale> mreh: It's used in that insertWith, which is used in alpha', which isn't being evaluated
17:08:12 <fax> should we talk about this in more depth in #haskell-blah ?
17:08:15 <fax> this proof stuff
17:08:30 <monochrom> Yeah, an educational proof checker would help.
17:08:33 <Twey> QtPlatypus: Sure, but I assumed there was some particular (and interesting) proof behind that.
17:08:48 <monochrom> And I am writing a primitive one in Haskell.
17:08:51 <Twey> I mean to learn to use one of those myself at some point
17:08:52 <fax> Pierce wrote "lambda the ultimeta TA"
17:09:02 <fax> although that is for a more advanced level than high school
17:09:13 <Twey> monochrom: What's missing from the current ones?
17:09:20 <monochrom> I think I may use view patterns.
17:09:23 <mreh> Cale: I think i'm getting somewher with this, time for bed though
17:09:36 <monochrom> Haskell is missing from the current ones. :)
17:09:48 <Twey> Isn't Agda in Haskell?
17:09:56 <monochrom> I don't know.
17:10:00 <dolio> Yes.
17:10:08 <Twey> Yes, it is.
17:10:11 <Twey> It's even on Hackage.
17:10:12 <dolio> So is Ivor.
17:10:12 <monochrom> Also it's more for my education than other people's education.
17:10:17 <Twey> Fair enough.
17:10:34 <dolio> And Idris, which is on top of Ivor.
17:10:46 <monochrom> They are all on hackage? Neat.
17:10:49 <dolio> Idris might not be suitable for a proof assistant, though.
17:11:13 <fax> I think Idris is sort of the big inside a proof assistant
17:11:26 <Twey> The big?
17:11:39 <fax> there's like an example of a tactic based proof thing on top of it
17:11:43 <fax> (in about a page of code)
17:11:47 <fax> bit*
17:11:52 <dolio> Ivor is the core proof assistant.
17:12:06 <dolio> Not intended for human use, apparently.
17:12:12 <monochrom> I haven't completed the proof-checking yet. I actually completed the counterexample-checking first. Given a Kripke structure and a formula, does the Kripke structure force the formula? (And then also a single-world version for classical logic.)
17:12:15 <dolio> Idris is the language on top of it.
17:12:33 <fax> What does force the formula mean?
17:12:57 <monochrom> "force" is constructive-logic speak for "satisfy"
17:13:03 <dolio> But I think Idris is billed as not worrying about how to solve every programming problem The Right Way with dependent types, but instead being more like Haskell with dependent types.
17:13:03 <fax> okay
17:13:05 <monochrom> or "model"
17:13:30 <dolio> So I wouldn't be surprised if it allows general recursion and stuff.
17:14:05 <monochrom> If you think that a formula is unprovable in constructive logic (and yet provable in classical logic so you really wonder), for example:
17:14:19 <monochrom> @djinn Either a (Not a)
17:14:19 <lambdabot> -- f cannot be realized.
17:14:46 <monochrom> Then a Kripke structure that doesn't "force" the formula will help confirm.
17:18:04 <fax> monochrom: this is good because I thought forcing was some scary thing.. but I can understand it :)
17:19:04 <dolio> Oh, is that the same forcing that gets used to show that the continuum hypothesis (or whatever) is independent of ZFC?
17:19:11 <monochrom> I don't know.
17:21:11 <monochrom> pesca
17:22:22 <Twey> http://haskell.pastebin.com/pR3Jnzm — hwæt?
17:22:25 <Twey> Er
17:22:27 <Twey> http://haskell.pastebin.com/pR3Jnzmu
17:24:02 <ickabob> I'm trying to understand newtype vs type and I've come up wht this example. newtype Weight = W Int.  so then the W constructor converts between Weight and an Int right?  Do i need to then redeclare Weight for all the instances of typeclasses the Int belongs to?
17:24:19 <monochrom> alex is not even a library
17:24:40 <EvanR> type is for type synonyms, newtype is for new types
17:24:44 <monochrom> Do you have /home/twey/.cabal/bin on your PATH?
17:24:54 <kbp> ... is it possible to modify a global variable inside a function in Haskell?
17:25:07 <kbp> s/inside/using
17:25:07 <EvanR> whats a global variable
17:25:29 <Twey> monochrom: Oh.  :þ
17:25:30 <dolio> Set theoretic forcing is, apparently, taking a model of set theory, and augmenting it into a new model such that the proposition in question is true or false. So I guess that's similar.
17:25:31 <EvanR> you can say g = unsafePerformIO newEmptyMVar
17:25:31 <Twey> monochrom: Thanks
17:25:32 <ickabob> EvanR: just say i wanted to create a totaly new type, the type Weight
17:26:05 <kbp> EvanR: ok :) ty
17:26:20 <EvanR> kbp: you arent actually going to use that are you ;)
17:26:21 <ickabob> once you declare a newtype must you redeclare it as an instance of all the typeclasses the newtypes parameter was a instance of
17:26:54 <kbp> EvanR: it's the only way to do i guess
17:27:01 <Saizan_> ickabob: well, if you want to, and there's NewtypeDeriving to make that extremely simple
17:27:08 <EvanR> kbp: are you sure?
17:27:14 <mamalujo> kbp, an ignorant reply - you should be writing pure code, so you shouldnt modify anything?
17:27:45 <ickabob> Saizan_: deriving analogous to the deriving for Data type constructors?
17:28:23 <kbp> ...?
17:28:39 <Saizan_> ickabob: yeah, but it can derive any class the newtyped type is an instance of (unless that type is too complex)
17:28:58 <EvanR> kbp: mutable global variables are bad in regular languages, even worse in haskell
17:29:26 <Saizan_> ickabob: http://www.haskell.org/ghc/docs/latest/html/users_guide/deriving.html#newtype-deriving
17:31:26 <ickabob> sweet, thanks. I'm trying to write a module to do some basic tree functions, toList, head and smart contructors for leaf and branchs. Although everything is getting very confusing once i try to implement a measuring scheme for the tree with monoids
17:31:29 <kbp> EvanR: im still thinking...
17:32:55 <mamalujo> as I understand it, your functions should only depend on the values of explicit parameters
17:33:16 <Saizan_> yeah
17:33:19 <EvanR> unless of course, they do IO
17:33:29 <Twey> Functions never do IO
17:33:43 <ickabob> IO is an action
17:33:45 <ickabob> not a function
17:33:48 <Twey> Right
17:33:48 <EvanR> theres the sticky bit where functions never actually do anything but compute IO actions
17:33:49 <Twey> A value
17:33:56 <mamalujo> and even when that is done, that should be a minimal wrapper around a pure core, if possible
17:33:57 <ickabob> a computation tha results in a value
17:33:58 * EvanR waves hands
17:34:18 <ickabob> yay that makes me hapy i understand that
17:34:25 <Saizan_> however the produced IO-script can use global variables without breaking referential transparency and all the nice things
17:34:39 <EvanR> Twey: despite the theoretical facts of the matter, a function returning IO is usually harder to verify than one that doesnt, whether or not you consider it performing IO
17:34:51 <Saizan_> it's quite an unflexible design though.
17:34:52 <ickabob> what is referential transparency?
17:35:11 <Twey> EvanR: No it isn't.
17:35:51 <Twey> It might be harder to verify that the result of performing the IO does what you want, but it's trivial to verify that the function returns the IO you expect.
17:35:58 <mamalujo> I think thats the point of referential transparency - function considers only values of its parameters, and it allways gives the same results for the same parameters (ie is stateless)
17:36:01 <Cale> ickabob: The property that the meaning of a function is completely determined by how it associates outputs to its parameters
17:36:01 <EvanR> yes, besides IORefs and MVars games, you have the fact that IO is happening
17:36:17 <Twey> IO does not happen during the evaluation of a function.
17:36:23 <Twey> unsafePerformIO aside.
17:36:26 <EvanR> thats beside the point
17:36:45 <Cale> ickabob: Another way of saying that is that if f x = g x for all x, then f can be replaced with g throughout a program without changing its meaning.
17:37:49 <Twey> EvanR: No it isn't — functions returning IO are pure functions just like any other, and therefore no easier/harder to verify
17:37:51 <ickabob> Cale: that makes sense. Thanks
17:38:15 <EvanR> Twey: an external api may have tricky IO functions that must be sequenced in the right order, you cant just look at the function and tell that its right as if it simply needs to return the correct value
17:38:28 <mamalujo> and surely the gods of haskell put casual users of unsafePerformIO in some particularly tortured afterlife
17:38:54 <Twey> EvanR: It does simply need to return the correct value.
17:39:06 <Saizan_> Twey, EvanR: it's just that a value of type "IO a" is generally quite a complex beast
17:39:31 <Twey> Just so
17:39:45 <Saizan_> not a small just in practice :)
17:40:26 <EvanR> then i would suggest you try writing the entire program in the IO monad and see if it doesnt make it harder
17:41:59 <EvanR> IORefs used for local mutable variables ;)
17:42:23 <EvanR> or MVar deadlock
17:42:47 <mamalujo> well, the syntax is quite verbose, explicit read & write functions to deal v just a variable..
17:43:02 <EvanR> besides that
17:43:32 <Saizan_> EvanR: that's more about comparing haskell to other languages where you regurarly use mutable constructs, not IO code vs non-IO code within haskell
17:44:26 <mamalujo> btw, are there any plans to segment the IO monad, like in that recent monadic zipper parer?
17:44:33 <mamalujo> *paper
17:45:18 <EvanR> Saizan_: well you cant access i/o or concurrency otherwise
17:45:49 <EvanR> though you can have mutable references
17:46:01 <EvanR> ill complain about those if you want ;)
17:47:50 <mamalujo> no, sorry, I meant the datatypes la carte one, where they have sigs like cat :: FilePath -> Term (Teletype :+: Filesystem) ()
17:48:36 <dolio> No plans in motion, at least.
17:49:04 <Saizan_> even if i wrote everything in the IO monad because i'm poor at separating code into different functionalities, i wouldn't use mutable references for the sake of it, since it's just harder for no reason, and that's how the fact that functions producing values of type "IO a" are pure surfaces in practice
17:49:53 <hangal> hi. i'm a newbie user to haskell. GEtting an error trying to install haskell platofrm on snow leopard mac os x. it just says the installer encountered an error, contact software manufacturer
17:50:15 <hangal> any obvious things to check ? is there an install log somewhere ?
17:50:44 <EvanR> Saizan_: except that i would expect someone to, if given the option to use IO anywhere, to use it
17:51:08 <EvanR> someone 'poor'
17:51:56 <EvanR> in that case it would be harder to verify
17:51:56 <Saizan_> the language will actively fight against that, at least :)
17:52:18 <Saizan_> but i agree in that context
17:55:00 <Saizan_> hangal: it seems we lack OS X users at the moment :) you could ask on haskell-cafe
17:55:35 <hangal> k, thanks.
17:56:06 <mamalujo> hangal, there's also a haskell-platform mailinglist, they should know, I presume
17:56:46 <hangal> in the mac installer, should i select "install new ghc" and then install platform ?
17:57:29 <hangal> but selecting "install new ghc" ghc doesn't work either. goes straight from License to installation type, and says "click install". but the install button is greyed out.
17:58:38 <hangal> what platform do folks recommend for haskell if not mac ? linux ?
17:59:03 * EvanR throws a penguin at hangal 
18:01:10 <Saizan_> on linux i had no problems in the past using the right ghc version
18:01:33 <mamalujo> I use it on debian, yes, and installed it under windows. but osx is officially supported, by the looks of it. it wouldnt make sense to change os for it, its supposed to be a robust platform..
18:03:35 <cypher> I have this tiny little program that I'm using to play with Criterion, and if I time it using time command it runs around 5s on my machine.. but if I run it using Criterion, I get that the mean execution time is around 3s.. O_o
18:03:41 <cypher> why could that be?
18:04:11 <ManateeLazyCat> Have a way that convert tuple to array? Example: tupleToArray :: (a,b,c) -> (forall a . a => a -> d) -> [d]"
18:04:25 <EvanR> array or list?
18:04:50 <EvanR> and both cant have different types
18:04:54 <EvanR> tuples can
18:05:11 <aavogt> @djinn a -> b
18:05:11 <lambdabot> -- f cannot be realized.
18:05:13 * ManateeLazyCat pasted "Action" at http://paste2.org/get/792330
18:05:15 <ManateeLazyCat> EvanR: Above is Action.
18:05:21 <aavogt> @hackage tuple
18:05:21 <lambdabot> http://hackage.haskell.org/package/tuple
18:05:33 <EvanR> a b c are the same type?
18:05:37 <ManateeLazyCat> EvanR: Infact, tuple is contain "actionFun :: a -> IO b"
18:05:40 <ManateeLazyCat> EvanR: No
18:05:46 <ManateeLazyCat> EvanR: http://paste2.org/get/792330
18:06:22 <aavogt> you can't in general go from  a -> b safely
18:07:36 <Maxdamantus> http://learnyouahaskell.com/syntax-in-functions
18:07:48 <Maxdamantus> How is this "pattern matching"?
18:07:48 <Maxdamantus> # ghci> let xs = [(1,3), (4,3), (2,4), (5,3), (5,6), (3,1)]
18:08:09 <Maxdamantus> Oh nvm, it's in the [|] bit.
18:08:47 <aavogt> xs is the pattern
18:08:52 <ManateeL`> EvanR: Possible?
18:09:27 <ManateeL`> aavogt: Have a exist function do that? Tuple to Array?
18:09:27 <EvanR> you cant conver a b c to d unless you made them specifically instances of some convertible-to-d class
18:09:40 <aavogt> ManateeL`: I guess not
18:10:28 <ickabob> Would somone be so kind as to ensure I have the write idea about the use of haskells typeclasses and instanceing mechanisms? I've rolled up a quick example using a Tree structure.  I've commented fairly heavily my intentions
18:10:43 <ickabob> I'd really appreciate it
18:10:53 <ickabob> oops one second i ment to include the link
18:11:11 <ickabob> http:codepad.org/Zw4wcxG4
18:11:11 <ManateeL`> EvanR: I think it's possible, because Tuple accept different type, so i just need a function to loop element in Tuples.
18:11:34 <ickabob> http://codepad.org/Zw4wcxG4
18:11:41 <EvanR> ManateeL`: and do what with them
18:12:17 <EvanR> heres a function to make 3 Ints into a list of ints
18:12:17 <ivanm> you can't loop within tuples...
18:12:28 <EvanR> f (x,y,z) = [x,y,z]
18:12:35 <EvanR> ok that works for x y z being any type
18:12:37 <ivanm> oh, and if you're using more than a 4-tuple (being generous), you're probably doing it wrong
18:12:56 <aavogt> ickabob: Measure is a useless class
18:13:10 <ickabob> could you explain why?
18:13:35 <ManateeL`> EvanR: Yes, i know how to convert tuples that element less 3.
18:13:45 <ickabob> aavogt: to me, it seems there is a class of things that are measurable and those that are not
18:13:49 <EvanR> you also cant make a function that takes a tuple of any size
18:13:59 <ManateeL`> EvanR: Why?
18:14:06 <EvanR> because a function can only take one type
18:14:14 <EvanR> and (,) is different type from (,,)
18:15:01 <ickabob> aavogt: sorry, that didnt come off how i intended.  Is there a way I can incorperate monoids into a tree structure wihtout the measure class?
18:15:14 <aavogt> ickabob: the method measure is supposed to return any type
18:15:32 <aavogt> so you can't write any useful instances
18:15:44 <EvanR> ManateeL`: maybe you are thinking of python tuples, (1,2,3) are not very different from lists there. in haskell tuples and lists are very different
18:15:56 * ManateeL` pasted "Source code for Keymap" at http://paste2.org/get/792343
18:15:57 <ManateeL`> EvanR: Above is all my source code for Keymap, i'm try to write this function make it possible.
18:16:14 <SubStack> @pl \(x,y,z) -> [x,y,z]
18:16:14 <lambdabot> (line 1, column 6):
18:16:15 <lambdabot> unexpected ","
18:16:15 <lambdabot> expecting letter or digit, operator or ")"
18:16:15 <lambdabot> ambiguous use of a non associative operator
18:16:18 <ickabob> well measure only returns a weight for the instance of Weight
18:16:32 <Saizan> ickabob: the type "measure :: a -> w" means that the caller can choose any type it likes for 'w'
18:16:35 <EvanR> ManateeL`: a keymap, ok, use Data.Map Key Command
18:16:35 <ickabob> aavogt: measure has type a -> w
18:16:37 <ManateeL`> EvanR: I know what's tuple, i want a function to scan tuple with any size.
18:16:45 <EvanR> you cant
18:16:48 <EvanR> use a list instead
18:16:52 <Saizan> ickabob: the implementation of measure can't pick one itself
18:17:39 <ickabob> aavogt, Saizan: i dont see where it does, I've assigned measure to the specific function weight in the instance declaration of Weight
18:18:09 <ickabob> oh
18:19:02 <EvanR> ManateeL`: you are only using 2ples there, so many your function work on (a,b)
18:19:09 <EvanR> s/many/make/
18:19:13 <Saizan> ickabob: you're not allowed to use "weight" as an implementation for measure in fact, it won't typecheck
18:19:33 <ivanm> ManateeL`: the only way you can is by defining a Tuple class and making each different tuple size an instance of it... but I'm not sure if that's feasible
18:19:38 <mamalujo> interesting question though, I think I saw somewhere some technique to encompass say the zipWith family
18:19:40 <ivanm> better option: don't use tuples
18:19:41 <ickabob> I know :(!
18:20:06 <aavogt> code generation, ivam!
18:20:17 <Saizan> ickabob: what you want is "class Monoid w => Measure a w where measure :: a -> w"
18:20:26 <EvanR> a countable number of type classes for the win
18:20:27 <aavogt> ivanm even
18:20:28 <ickabob> Saizan: I'm not sure how to seperate measure from the impelementation Weight as a instance of the class Measure
18:20:32 <ManateeL`> aavogt: Oh, i was think a another before code generate. :)
18:20:35 <EvanR> or instances
18:20:37 <Saizan> ickabob: so that you can say which things get measured with what
18:21:14 <ickabob> Saizan: what about the complaints that classes are not able to have multiple parameters?
18:21:18 <ivanm> aavogt: yeah, but I think there are probably going to be other problems with such a class
18:21:18 <Saizan> ickabob: btw, http://hackage.haskell.org/packages/archive/fingertree/0.0.1.0/doc/html/Data-FingerTree.html
18:21:30 <Saizan> ickabob: turn on MultiParamTypeClasses :)
18:21:31 <EvanR> ManateeL`: use more specific data types rather than arbitrary tuples, use lists instaed of arbitrarily large tuples.
18:21:54 <ivanm> unless you specifically have the only function being toList :: (Tuple t a) => t a -> [a]
18:22:14 <aavogt> tuples encode the size in their type
18:22:17 <ivanm> actually, I can't even work out how to express it unless you use FDs or ATs
18:23:10 <aavogt> in that case your  t  is a partially applied tuple constructor
18:23:21 <ickabob> Saizan: I was looking at that FingerTree package, specifically FingerTree.PriorityQ to implement a huffman tree :)
18:23:27 <mamalujo> ManateeL, try this paper, havent read it but it does speak of generalising over unzip etc. probably not worth the effort, but interesting http://www.seas.upenn.edu/~sweirich/papers/aritygen.pdf
18:23:31 <ickabob> well the building of a huffman tree
18:23:36 <ManateeL`> EvanR: Infact, `keymap` in http://paste2.org/get/792343 is enough, but i just want find a lazy way that don't need write "map (second Action).
18:24:09 <ivanm> aavogt: yeah, which won't work
18:24:22 <aavogt> why not?
18:24:37 <ivanm> you need to have something like class Tuple t a | t -> a, where instances are of the form "instance Tuple (a,a,a,a) a"
18:24:57 <EvanR> ManateeL`: i suggest building your functions and tables from smaller pieces rather than making one big data structure and defining the rest as slices of it
18:25:22 <EvanR> zip rather than map (second)
18:25:31 <EvanR> snd
18:25:34 <aavogt> ManateeL`: just use a different function than (,)
18:25:50 <aavogt> a list of    ["M-x" ==> newDired.... ]
18:26:58 <mamalujo> hm, but its specific for the Generic Haskell preprocessor. I think other generics libraries have absorbed its functionality, but probably in a different way..
18:27:21 <ManateeL`> aavogt: Interested.... :)
18:28:51 <aavogt> ivanm: I guess you take as too inconvient to use as something that's not useful
18:29:10 <ivanm> hmmm?
18:29:44 <ivanm> @undo do { a <- as; b <- bs; return $ f a b }
18:29:45 <lambdabot> as >>= \ a -> bs >>= \ b -> return $ f a b
18:29:52 <ivanm> @. pl undo do { a <- as; b <- bs; return $ f a b }
18:29:52 <lambdabot> (`fmap` bs) . f =<< as
18:30:04 <aavogt> as in FDs don't allow you to write more instances
18:30:17 <ivanm> aavogt: they don't?
18:30:18 <ManateeL`> aavogt: What's FDs?
18:30:21 <aavogt> so you can do the same without them, only with lots of type signatures
18:30:24 <ivanm> Functional Dependencies
18:30:36 <ManateeL`> ivanm: Link?
18:30:45 <ivanm> aavogt: how would you write a tuple -> list function's type signature then?
18:30:45 <aavogt> ManateeL`: check the ghc-manual
18:30:50 <ivanm> @where functional dependencies
18:30:50 <lambdabot> I know nothing about functional.
18:30:55 <ivanm> @google functional dependencies
18:30:55 <lambdabot> http://en.wikipedia.org/wiki/Functional_dependency
18:30:55 <lambdabot> Title: Functional dependency - Wikipedia, the free encyclopedia
18:31:02 <ivanm> that's probably not it
18:31:04 <ivanm> @google functional dependencies haskell
18:31:06 <lambdabot> http://www.haskell.org/haskellwiki/Functional_dependencies
18:31:06 <lambdabot> Title: Functional dependency - HaskellWiki
18:31:09 <ivanm> there we are
18:31:16 <EvanR> @quote hammer
18:31:17 <lambdabot> weitzman says: Sometimes it's ok to polish diningware with a hammer, as long as it gets the job done
18:31:21 <aavogt> ivanm: exactly the same as  class Tuple t a | t -> a, where instances are of the form "instance Tuple (a,a,a,a) a"
18:31:24 <ivanm> EvanR: lol
18:31:40 <ivanm> aavogt: so you're saying to not use FDs, must MPTCs?
18:31:56 <ivanm> what then stops you from writing "instance Tuple (a,a,a,a) b" ?
18:32:06 <aavogt> sanity
18:32:16 <ivanm> heh
18:32:36 <ivanm> well, that's why I was saying using FDs, because then there's one less possible problem
18:32:50 <ivanm> and if you have the instances generated at compile time with TH or something...
18:33:16 * ManateeL` TH is evil..... :)
18:33:20 <aavogt> hmm, overlapping instances to select only teh types that match
18:34:00 <EvanR> ManateeL`: btw, do you want to be able to update the keymap during runtime
18:34:20 <ManateeL`> EvanR: Possible at runtime?
18:34:29 <ivanm> _anyway_ this is missing the point: you shouldn't be having that large a tuple that you would need a typeclass like this
18:34:31 <aavogt> but you can already write those with gmapQ
18:34:38 <uorygl> I just found myself torn between making some nachos and writing something about coordinate systems in a fiber bundle.
18:35:00 <ManateeL`> EvanR: I'm try to tweak different keymap in compile time with TH.
18:35:01 <uorygl> I seem to have opted for the latter.
18:35:01 <aavogt> writing about nachos and making fiber bundles
18:35:02 <EvanR> ManateeL`: yes its possible, do you want to? or is it a static map
18:35:19 <EvanR> TH :(
18:35:22 <ManateeL`> EvanR: How? If runtime handle is safe, yes, i want.
18:35:24 <ivanm> aavogt: mmmmm..... nachos.....
18:35:32 <uorygl> Making fiber bundles is boring.  Everyone knows how to grab a piece of paper, cut off a strip, and tape the ends together with a bend.
18:35:42 <EvanR> ManateeL`: you can insert, adjust, etc a Data.Map
18:35:46 <mamalujo> this might be interesting http://www.brics.dk/RS/01/10/BRICS-RS-01-10.pdf and oleg's http://okmij.org/ftp/Haskell/polyvariadic.html
18:38:45 <ManateeL`> EvanR: But i think a better idea than use Tuple, in `keymap`, i just need Map [(Text, Action)], so the only i need to do is write "toAction :: forall a b . (ActionInputArgs a, ActionOutputArgs b) => Text -> (a -> IO b) -> (Text, Action)" then bulid a [(Text, Action)].
18:38:51 <uorygl> Now, just to make sure, if cheese smells like exacerbated feet, that means it should be thrown out, right?
18:39:08 <ivanm> yeah, most probably
18:39:18 <EvanR> ManateeL`: do you need all these classes?
18:39:20 <ivanm> unless it's meant to be some french stinky cheese or something
18:40:21 * uorygl throws away the stinky cheese and briefly ponders how to express a Mobius strip as a quotient space of ADTs.
18:42:40 * uorygl unwraps the two-pound block of cheese, ponders what he's going to do with the ungrated portion, and wonders what letters to use for Mobius strip coordinates.  r and theta?
18:43:20 <EvanR> u v !
18:43:56 <EvanR> but um one of those coordinates doesnt make sense
18:44:22 <ManateeL`> EvanR: Wait my code, i will show you how to do.
18:44:29 <ivanm> EvanR: lemme guess, the `!' one?
18:44:59 <ivanm> uorygl: wrap it back up and chuck it in the fridge for next time
18:48:38 * ManateeL` pasted "New keymap" at http://paste2.org/get/792440
18:48:38 <ManateeL`> EvanR: Looks above
18:49:03 <ManateeL`> aavogt: I have write new version at http://paste2.org/get/792440 , thanks for your great tip! :)
18:49:15 * uorygl puts the remainder in a gallon Ziploc bag and comes up with a way to get Haskell to support quotient spaces.
18:49:44 <uorygl> EvanR: don't worry, it's a two-dimensional space, so we only need two coordinates.
18:50:23 <EvanR> uorygl: okie
18:52:21 <ManateeL`> EvanR: Look the declaration of `Keymap` and `Action`, i use class `ActionInputArgs` and `ActionOutputArgs` build polymorphism functions, then Keymap can contain any function that have instance above classes.
18:53:02 <EvanR> i just dont understand why youd need that, or how it would work
18:56:50 * ManateeL` pasted "Why need Keymap and Action." at http://paste2.org/get/792640
18:56:51 <ManateeL`> EvanR: Looks above, keymap accept any functions with any input or output.
18:58:18 <ManateeL`> EvanR: Because Action in `type Keymap = Map Text Action" can be any function, and those funtion have different input and output argument.
19:00:36 <ManateeLazyCat> EvanR: Sorry, Emacs crash.
19:01:08 <ManateeLazyCat> EvanR: class `ActionInputArgs` and `ActionOutputArgs` build a uniform interface that tweak different functions in one keymap.
19:01:37 <EvanR> sounds very general
19:01:45 <aavogt> polymorphism isn't good for error messages
19:02:12 <ManateeLazyCat> aavogt: But polymorphism make extension is possible.
19:02:27 <aavogt> maybe you don't need it
19:02:41 <EvanR> probably less typing to just make a single data type and extension is by adding constructors
19:02:56 <EvanR> and adding cases to functions that take that type
19:03:03 <aavogt> you don't necessarily have to add constructors
19:03:39 <ManateeLazyCat> aavogt: You can write data Action = WindowAction ... | TabAction ... | OtherAction ... in one file, but when add keymap, you need modified "Action" declaration, it's ineffective and not flexible.
19:04:14 <EvanR> Action.WindowAction Action.OtherAction, redundant ;)
19:04:20 <ManateeLazyCat> aavogt: No, I'm build framework, then i will build interface let Extension add keymap in runtime.
19:05:18 <ManateeLazyCat> aavogt: So i write class `ActionInputArgs` and `ActionOutputArgs` to absolute those polymorphism functions, any functions that have instance can add in Keymap during runtime.
19:06:26 <aavogt> what do you use to write instances at runtime?
19:07:16 <ivanm> aavogt: not sure if you can...
19:07:31 <ivanm> unless you use hint or something :s
19:07:55 <ivanm> ManateeLazyCat: I think an approach ala xmonad and yi might be a better idea than trying to change things at runtime
19:08:37 <aavogt> situation looks dyre
19:09:28 <ManateeLazyCat> ivanm: I was think this way, after you write extension code, then let GHC check those code at compile time, then link .o to running program.
19:09:32 <ivanm> aavogt: *groan*
19:09:46 <ivanm> ManateeLazyCat: that sounds fraught with peril
19:09:46 * hackagebot hpage 0.6.2 - A scrapbook for Haskell developers  http://hackage.haskell.org/package/hpage-0.6.2 (FernandoBenavides)
19:10:05 <EvanR> hsplugins?
19:10:12 <ManateeLazyCat> aavogt: I have similar thing like dyr, except for all project than one configuration file.
19:10:33 <ivanm> EvanR: now called plugins I believe
19:10:35 <ivanm> and probably bitrotted
19:11:54 <ManateeLazyCat> aavogt: Above is my "hot swap" code for one project.
19:11:54 * ManateeLazyCat pasted "Core.hs" at http://paste2.org/get/792729
19:11:59 <ManateeLazyCat> aavogt: http://paste2.org/get/792729
19:13:12 <aavogt> right, so we have to use classes rather than data because there isn't a Binary instance for functions
19:13:22 <ManateeLazyCat> aavogt: When i finish extension code, i save current state, then compile entire project, after compile finish, i will restore state in new binary entry.
19:15:00 <aavogt> then this is exactly like dyre
19:15:41 <ManateeLazyCat> aavogt: dyre design just for user configuration, my code for all project.
19:16:00 <aavogt> there is no distinction
19:16:12 <ManateeLazyCat> aavogt: That mean, you can modified all code in project, then recompile and relaunch.
19:16:55 <aavogt> that's assuming your State doesn't change too much
19:16:57 <ManateeLazyCat> aavogt: I have one version use dyre, but i always need wait author add new feature, so i write myself version.
19:17:39 <aavogt> what did you find was missing from dyre?
19:18:03 <aavogt> is your app state really large enough to merit using binary?
19:20:01 <fax> JordiGH?
19:20:03 <fax> oops
19:20:04 <fax> wrong channel
19:20:48 <ManateeLazyCat> aavogt: My aim is use Manatee write itself, when new code compile pass, update itself during runtime
19:21:16 <EvanR> sounds like a job for erlang
19:21:24 <ManateeLazyCat> aavogt: But looks now, i just Save/Restore Gtk+ state when relaunch.
19:22:33 <blackdog> ivanm: i remembered the other reason i want to ditch c2hs
19:22:43 <blackdog> it's broken on mac atm
19:22:54 <blackdog> it can't handle blocks syntax
19:23:12 <blackdog> (or mac is broken in pretending that blocks syntax is C, whichever way you want to look at it)
19:23:34 <Axman6> one day it will be C hopefully
19:23:55 <ivanm> aha
19:24:00 <ivanm> dcoutts_: ^^ any comment on this?
19:24:18 <blackdog> C is C. Trying to add stuff decades later is just disingenuous.
19:24:27 <pikhq> blackdog: C99 did it.
19:24:43 <pikhq> As did C90.
19:24:48 <dcoutts_> blackdog: in the snippet you posted it was protected by a __BLOCK__ define or something like that
19:25:09 <Axman6> well, it's a pretty simple way of keeping C relevant, by making it easy to write code that takes advantage of multicore machinesw
19:25:11 <ManateeLazyCat> aavogt: Problem is, you can't save Gtk+ widget's state and restore them when relaunch, so i pick some information for rebulid those widget after relaunch, such as "cursor position, frame layout, window state"
19:25:12 <Axman6> -w
19:25:18 <dcoutts_> blackdog: did you figure out how to exclude those bits using cpp?
19:25:20 <blackdog> pikhq: sure. but they're relatively small changes, and already implemented in compilers
19:25:33 <blackdog> dcoutts_: no, I haven't
19:25:40 <pikhq> blackdog: C99 provided some fairly large changes.
19:25:44 <Axman6> block is also a feature already implemented in compilers ;)
19:25:53 <Axman6> including GCC
19:25:57 <pikhq> For instance, being able to intersperse declarations and statements.
19:26:06 <pikhq> And doing a declaration in a for loop.
19:26:12 <pikhq> Also wide chars...
19:26:17 <aavogt> ManateeLazyCat: shouldn't that be something that the gtk binding can do for you?
19:26:19 <ManateeLazyCat> dcoutts_: Are you author of gconf in gtk2hs?
19:26:27 <blackdog> pikhq: that's a reasonably small semantic change, though. it's not anything close to general blocks.
19:26:30 <dcoutts_> ManateeLazyCat: originally, yeah
19:26:43 <ManateeLazyCat> aavogt: I haven't found any binding do that.
19:26:49 <pikhq> blackdog: Oh, fine.
19:26:57 <pikhq> blackdog: Function declarations.
19:27:16 <pikhq> This added new levels of *type checking* to C.
19:27:54 <ManateeLazyCat> dcoutts_: Now, just gio, gstreammer, and gconf haven't convert to Cabal (all other package i have convert), but in gconf, have problem i can't fix, can you take a look (gtk2hs-devel list).
19:28:28 * ManateeLazyCat Axel convert gio and gstreammer, i conver other packages.
19:29:47 * ManateeLazyCat pasted "gconf problem" at http://paste2.org/get/792745
19:29:49 <ManateeLazyCat> dcoutts_: Above
19:30:06 <blackdog> dcoutts_: ah, you little beauty. thanks, undeffing __BLOCKS__ worked fine.
19:30:19 * ManateeLazyCat We can release gtk2hs-0.10.5 after we convert all non-core packages to Cabal.
19:30:31 <blackdog> if someone's trying to use C blocks, ruby and haskell together in the same project they can lodge a bug report:)
19:30:41 <ivanm> ManateeLazyCat: why not 0.10.2?
19:30:46 <ivanm> blackdog: heh
19:30:48 <dcoutts_> blackdog: heh heh
19:30:58 <ManateeLazyCat> ivanm: Because have new module add in.
19:31:05 <ManateeLazyCat> ivanm: Like vte and webkit.
19:31:54 <aavogt> ManateeLazyCat: I mean that serializing widget state is something that could be added to the bindings
19:31:58 <pikhq> blackdog: :D
19:32:43 <ManateeLazyCat> aavogt: Yes, you can write your own package do that, but for keep gtk2hs simple, i think Axel will refuse that feature.
19:32:45 <ivanm> ManateeLazyCat: so?
19:32:46 <blackdog> pikhq: what'd you mean by function declarations, btw? the non k&r syntax for types of function arguments?
19:32:58 <ivanm> ManateeLazyCat: how does 0.10.5 indicate that better than 0.10.2?
19:33:01 <pikhq> blackdog: Yes.
19:33:07 <ManateeLazyCat> ivanm: Cabal install.
19:33:11 <ivanm> arguably, 0.11 would be better as its a major version bump
19:33:13 <ivanm> ManateeLazyCat: huh?
19:33:17 <pikhq> The one that *allows for cross-file type checking*.
19:33:27 <dcoutts_> aavogt: I don't think you can serialise the widget state without a lot of help from the C layer. There's lots of hidden state.
19:33:44 <pikhq> I'd call that fairly large. Goodness knows that it took quite a while for it to be common.
19:33:50 <ManateeLazyCat> ivanm: For version number, you need ask Axel, i just a patcher.
19:33:57 <ivanm> *shrug*
19:34:14 <ManateeLazyCat> ivanm: But i think Axel will release 0.10.5
19:34:35 <ManateeLazyCat> ivanm: Because new cabal file write " gtk >= 0.10.1 && gtk <= 0.11"
19:34:40 <ManateeLazyCat> ivanm: Because new cabal file write " gtk >= 0.10.t && gtk <= 0.11"
19:34:46 <ivanm> ... so?
19:34:47 <ManateeLazyCat> ivanm: Because new cabal file write " gtk >= 0.10.5 && gtk <= 0.11"
19:34:47 <blackdog> pikhq: fair enough, that was a pretty big change 10 years after k&r
19:34:59 <blackdog> but there's a sort of simulated annealing thing going on with language changes, you'd think
19:35:03 <ivanm> ManateeLazyCat: I read you the first time; you don't have to tell me that thrice!
19:35:05 <ivanm> ;-)
19:35:35 <blackdog> 30 years on, blocks are a pretty big feature
19:35:46 <ManateeLazyCat> ivanm: So simple is, 0.10.5 for Cabal install, 0.11 for add Gtk+ 2.18.3 and Gtk+ 2.20
19:35:57 <ivanm> blackdog: lego blocks have been popular for a while now... >_>
19:35:58 <ivanm> :p
19:36:15 <ManateeLazyCat> ivanm: All Gtk+ 2.18.3 patches in other repository, need review and fix some bugs.
19:36:15 * blackdog groans
19:36:15 <ivanm> ManateeLazyCat: ummm.... the version number should change when the API changes
19:36:27 <ivanm> blackdog: :D
19:36:42 <dcoutts_> ivanm: if it's following the PVP, which it isn't
19:36:48 <ManateeLazyCat> ivanm: Yes, changed, but not too much in 0.10.5
19:37:00 <blackdog> ivanm: if you make jokes that bad at aushack i'll throw something at you
19:37:08 <Axman6> right, breakfast time
19:37:35 <ManateeLazyCat> ivanm:  0.11 will including all Gtk+ functions to Gtk+ 2.20
19:38:24 <ManateeLazyCat> dcoutts_: Can you take a look problem in gconf? I'm now use gconf, so i don't know the implement detail.
19:38:46 <dcoutts_> ManateeLazyCat: I'm not sure what has changed there
19:39:07 <dcoutts_> ManateeLazyCat: perhaps it'd help to track down what change broke it
19:39:34 <pikhq> blackdog: More of an Objective C feature that got backported to C for convience, though...
19:39:34 <ManateeLazyCat> dcoutts_: In darcs version, gconf compile pass, and i haven't change any source code. Just switch to Cabal, i got new error.
19:39:53 <ivanm> dcoutts_: I was hinting that it should ;-)
19:40:08 <ManateeLazyCat> dcoutts_: I can send you Cabal package for gconf.
19:40:09 <ivanm> blackdog: :(
19:40:18 <ivanm> blackdog: but that's about as much personality as I have!
19:40:23 <dcoutts_> ManateeLazyCat: sure, paste it somewhere
19:40:33 <dcoutts_> ManateeLazyCat: are you using any language extensions?
19:41:39 <blackdog> ivanm: you'll have to synthesise something better than that before july
19:41:48 <ivanm> yeah
19:42:00 * ManateeLazyCat pasted "First error." at http://paste2.org/get/792753
19:42:01 <ManateeLazyCat> dcoutts_: When i switch gconf to Cabal (haven't change any source code), i got above error, so i add "TypeSynonymInstances" extension
19:42:21 <ivanm> blackdog: out of interest, how far from UNSW do you live (in terms of blackh making his way there on the friday)?
19:43:10 <dcoutts_> ManateeLazyCat: try OverlappingInstances instead
19:43:12 * ManateeLazyCat pasted "second error" at http://paste2.org/get/792754
19:43:12 <ManateeLazyCat> dcoutts_: After add "TypeSynonymInstances", i got above error, then i add "OverlappingInstances".
19:43:19 <blackdog> ivanm: ashfield
19:43:26 <blackdog> 15 min train to central
19:43:46 <ivanm> on the other side of sydney I take it?
19:43:48 <blackdog> it's friday->monday, right? i can show him where to go then join you on saturday
19:43:53 * ManateeLazyCat pasted "last error" at http://paste2.org/get/792756
19:43:53 <ManateeLazyCat> dcoutts_: Yes, but when add "OverlappingInstances", i got last error like above.
19:43:55 <blackdog> few stations out from newtown
19:43:56 <ivanm> blackdog: friday -> monday
19:44:02 <ivanm> gah
19:44:03 <blackdog> sunday, i mean
19:44:04 <ivanm> friday -> sunday
19:44:06 <blackdog> it's ok
19:44:11 <ivanm> as did I ;-)
19:44:12 <blackdog> i think we both made the same mistake
19:44:25 <ivanm> yeah, but you caused my mistake ;-)
19:44:28 <blackdog> are there drinking plans for friday night?
19:44:30 <aavogt> ManateeLazyCat: ScopedTypeVariables?
19:44:34 <blackdog> i'd be keen to meet up
19:44:53 <ivanm> blackdog: probably; maybe make a proper dinner on saturday when there'll be more people there
19:45:00 <blackdog> are you guys all staying around UNSW, or in the city?
19:45:01 <ManateeLazyCat> aavogt: Oh, works.
19:45:09 <ivanm> blackdog: but I don't imbibe and have no idea of the facilities in that respect in the area
19:45:10 <aavogt> presumably you could look into the original build scripts to find those flags
19:45:25 <dcoutts_> ManateeLazyCat, aavogt: previously it was using -fglasgow-exts
19:45:26 <ivanm> blackdog: juhp, Fallen_Demon and myself will probably stay at the backpackers near UNSW
19:45:43 <ivanm> Axman6 and his girlfriend will be at some hotel somewhere, as will hamishmack and his family
19:45:47 <blackdog> ivanm: ok, guess it makes sense to stay local then
19:45:53 <BMeph> I'm jumping in into the middle, but...would "cabal init" help out any? :)
19:45:59 <ivanm> no idea about bpope, and then everyone else is a sydneysider AFAIK
19:46:18 <aavogt> BMeph: does it guess extensions?
19:46:30 <blackdog> ivanm: i've just got back from railscamp, and it was an absolute blast.. if aushack goes well, I reckon an equivalent HaskellCamp would be a fantastic ide
19:46:31 <ivanm> aavogt: nope
19:46:33 <blackdog> a
19:46:35 <ManateeLazyCat> Ok, just rest "gio" and "gstreamer" haven't finish.
19:46:44 <ivanm> BMeph: to me, the problem sounds like the build system did magic stuff, and now ManateeLazyCat has to get cabal to do the same
19:46:49 <ManateeLazyCat> dcoutts_: Can you help us convert gio and gstreamer ?
19:46:50 <blackdog> the schtick is: out in the bush, no internet, just hacking:)
19:47:15 <ivanm> blackdog: nah, won't work; we need internet for #haskell and to get suckers^w the community to test what we write overnight!
19:47:16 <dcoutts_> ManateeLazyCat: no, sorry. I didn't write either and I don't have the time to look at them.
19:47:26 <blackdog> ivanm: you'd be surprised
19:47:35 <blackdog> you cache hackage, it's easy as pi
19:47:36 <BMeph> I'll page up and read, then... :)
19:47:38 <ManateeLazyCat> dcoutts_: Nevermind, i'm waiting Axel do that. :)
19:47:40 <ivanm> blackdog: hmmm...
19:47:48 <ivanm> blackdog: but then there's no dcoutts_, Cale, etc. on call!
19:48:02 <blackdog> it's a bit harder than usual, but you get this funny camaraderie out of it
19:48:03 <EvanR> cache them too
19:48:09 <dcoutts_> hah hah
19:48:15 <blackdog> yes, you'll have to understand the code yourself! scary, no? :)
19:48:38 * dcoutts_ would fear meeting a cached copy of himself
19:48:40 <ivanm> EvanR: heh
19:48:54 <ManateeLazyCat> BTW, Use cabal insall gtk2hs is "damon fast"
19:48:57 <ivanm> dcoutts_: who do you call dcoutts then? :p
19:49:01 <ManateeLazyCat> And less bug report.
19:49:08 <BMeph> Sounds like out in the bush, you'd be writing caches that you couldn't check (cheque?)... ;)
19:49:12 <blackdog> dcoutts_ _is_ the cached copy
19:49:19 <dcoutts_> ivanm: do you ever see us in the same room together?
19:49:34 <blackdog> BMeph: *double groan*
19:50:03 <iaefai> I present to you, a path leading up to Haskell Peak: http://www.summitpost.org/view_object.php?object_id=414556
19:50:28 <ivanm> BMeph: don't make us start talking about the czech being in the male...
19:50:33 <blackdog> anyway, it seemed to work pretty well at railscamp - they had a bunch of mirrors, and set up DNS servers so twitter/irc/ubuntu/ports/gems Just Worked
19:50:39 <ivanm> dcoutts_: sure; here and #gentoo-haskell!
19:51:23 <dcoutts_> blackdog: should be straightforward to set up a hackage mirror
19:51:46 <blackdog> dcoutts_: i set up a ghetto version when i went
19:52:09 <blackdog> the l2mlogistics guy had a little shell script that just cached everything locally
19:53:51 <ManateeLazyCat> Haha, i finish gconf.
19:54:08 <ManateeLazyCat> aavogt: Thanks you guy, lovely.
19:55:35 <ivanm> blackdog: anyway, how'd you get to/from railscamp? train?
19:55:38 * ivanm ducks
19:55:45 * SubStack quacks
19:55:57 <blackdog> ha. ha. ha.
19:56:22 <ManateeLazyCat> dcoutts_: Looks you busier than Axel. :)
19:56:24 <blackdog> the ultimate disproof of duck typing: it looks like a joke, and it quacks like a joke...
19:56:35 <ivanm> heh
19:56:38 <EvanR> lol
19:56:49 <ivanm> @remember blackdog the ultimate disproof of duck typing: it looks like a joke, and it quacks like a joke...
19:56:49 <lambdabot> I will never forget.
19:56:58 <blackdog> we probably could have got a train if it was somewhere civilised, but we decided to hold it in Canberra instead.
19:57:24 <BMeph> ivanm: No, no, that's the Renaissance Faire exhibit - the Czech's in the (Chain) Mail! <insert rimshot>
19:58:10 <ivanm> BMeph: I was referring to this: http://www.jamesfuqua.com/lawyers/jokes/czechbear.shtml
19:58:33 <ivanm> actually, and Australian variant, but anyway
19:59:37 <tensorpudding> That joke was so painful
20:07:46 * ManateeLazyCat Try to convert gio to Cabal.
20:09:47 <winxordie> that joke may have been the corniest thing I've heard in a while
20:11:38 <ivanm> winxordie: you're welcome
20:12:00 <winxordie> ty ivanm
20:12:11 <deteego> ooh
20:12:23 <ivanm> *ding* we have mail!
20:12:23 <ivanm> :p
20:12:24 <deteego> im czech, and I love czech beer too!
20:12:34 * ivanm needs to get off the pun juice
20:12:39 <deteego> lol
20:12:55 <deteego> I also like czech bears
20:13:00 <deteego> both are goo
20:13:01 <deteego> *good
20:13:18 <tensorpudding> czech beer is good.
20:13:32 <tensorpudding> though i've only had the kinds you can get in the usa
20:14:11 <deteego> well the Americans made their own "Pilsner"
20:14:17 <deteego> which I heard tastes shitty
20:14:34 <deteego> and they even sued the original Czech brewery
20:14:41 <EvanR> beer, good idea
20:15:04 <blackdog> deteego: do you mean budweiser?
20:15:30 <blackdog> still looking forward to doing a beer tour of poland/czech republic
20:15:34 <deteego> somy bad
20:15:37 <deteego> it was budweiser
20:15:42 <deteego> *my
20:15:44 <ivanm> deteego: yeah, but then again american beer is like making love in a canoe...
20:15:51 * ivanm cues the bruces
20:15:51 <blackdog> ivanm: you don't even drink!
20:15:53 <deteego> fuccking close to water
20:16:03 <deteego> =D
20:16:05 <ivanm> blackdog: what does that have to do with Monty Python?
20:16:12 <blackdog> american beer is actually pretty bloody good. i was shocked.
20:16:19 <blackdog> unless you drink the mass market stuff
20:16:26 <ivanm> gah! I amd frigging sick of all these delivery status notification messages from blackberry!
20:16:29 <tensorpudding> Everyone hates on American beers, but most of the foreign beers that are mass imported here are worse.
20:16:32 <ivanm> surely I'm not the only one to be getting them :@
20:16:43 <blackdog> hoppy portland beers = doubleplusextragood
20:16:44 <ivanm> tensorpudding: are they imported or manufactured under license?
20:16:51 <tensorpudding> I wouldn't know.
20:16:58 <EvanR> tensorpudding: wheres that
20:17:32 <ivanm> most of the foreign beers available in Australia at pubs, etc. are just made under license
20:17:37 <tensorpudding> In the USA.
20:17:44 <ivanm> but the bottle-os are starting to sell imported beer
20:17:47 <tensorpudding> Yeah, they're probably brewed here.
20:18:20 <blackdog> oh, i was gonna ask - anyone know what the theoretical power of a PEG-based parser is?
20:18:44 <blackdog> am i going to run into trouble trying to implement a PEG parser using something like attoparsec?
20:19:50 <ivanm> no idea what a PEG parser is, but isn't attoparsec geared more towards parsing low-level stuff like network protocols?
20:20:11 <blackdog> ivanm: yes, i think so, but it'd be interesting to see how far you could push it.
20:20:22 <ivanm> hmmm....
20:20:32 <blackdog> got this situation atm - people are using treetop, a very nice but slow ruby parser
20:20:43 <blackdog> if i can reimplement it in haskell with the same api behind hubris, it'd be a net win
20:21:02 <ivanm> blackdog: language-ruby? :p
20:21:38 <blackdog> language-ruby?
20:22:52 <ivanm> blackdog: there's language-c, etc. on hackage
20:22:59 <blackdog> you mean actually implementing ruby as a haskell DSL?
20:23:03 <ivanm> so would you call your theoretical library lanaguage-ruby
20:23:05 <ivanm> ?
20:23:12 <blackdog> oh, no
20:23:17 <ivanm> awwww
20:23:31 <blackdog> hubris would be the equivalent of language-ruby, i guess
20:23:40 <blackdog> although it's not doing parsing
20:23:57 <ivanm> well, that's the whole point of language-c (the parsing)
20:23:58 <blackdog> the library's called leafy :) i'm given to bad puns too
20:24:07 <blackdog> i'm not interested in parsing ruby itself, though
20:24:14 <ivanm> why "leafy"?
20:24:36 <blackdog> the PEG stuff is basically about writing new grammars that have ruby code attached
20:24:38 <ivanm> wait, I thought you were wanting to write a ruby parser...
20:24:41 <blackdog> reimpl of treetop
20:24:44 <ivanm> or do you mean a ruby parser library?
20:24:50 <blackdog> nono, a parser _in_ ruby
20:24:54 <ivanm> ahhhhh
20:25:12 <blackdog> so i want to pretend that it's still written in Ruby _with_ hubris
20:25:15 <ivanm> blackdog: I hate to tell you this, but I don't think too many ruby hackers would want to use a haskell-based parsing library...
20:25:27 <blackdog> ivanm: the whole point would be to be api compatible
20:25:30 <ivanm> use hubris for the FFI or to generate the code?
20:25:35 <ivanm> *nod*
20:25:50 <blackdog> hubris, of course. i know the guy who maintains it, i think i can twist his arm to add whatever features i need.
20:26:08 <blackdog> anyway, i'm off to lunch. later!
20:26:22 <ivanm> cya
20:26:31 <ivanm> I meant use hubris to generate the code
20:26:32 <ManateeLazyCat> Haha, gio finish.
20:26:59 <blackdog> ivanm: the idea would be to link it in at multiple places, i think
20:27:43 <blackdog> each grammar would be represented as a ruby class with haskell code linked in, but the expression constructors at each node would still be in ruby
20:28:11 <blackdog> ManateeLazyCat: nice work. ;) still looking forward to having a real go with yi & gtk
20:28:28 <blackdog> emacs is the king of editors and must be deposed.
20:28:31 <ManateeLazyCat> blackdog: Now just gstreamer haven't finish.
20:28:46 <ManateeLazyCat> blackdog: Yes, emacs is dying
20:29:27 <gwern> 'there is a great deal of ruin in a nation'
20:29:31 <ManateeLazyCat> blackdog: I'm wating Axel change Setup.hs, then i can push all non-core Cabal packages (except gstreamer).
20:30:34 <ManateeLazyCat> blackdog: I'm try to convert gstreamer, if success, then all packages can install by Cabal.
20:30:49 <ManateeLazyCat> blackdog: Then it's time to release gtk2hs-0.10.5
20:33:25 <sm_> evening all
20:33:45 <ManateeLazyCat> blackdog: Elisp is evil language to write core.
20:33:50 <gwern> sm_: go fornicate yourself with a goat!
20:33:51 <ManateeLazyCat> blackdog: Elisp is evil language to write editor.
20:34:00 <blackdog> ManateeLazyCat: you're not kidding.
20:34:02 <gwern> sm_: er. that was for someone else
20:34:04 <blackdog> anyway, really going now.:)
20:34:07 <gwern> mischan
20:34:28 <ManateeLazyCat> blackdog: I'm create new one to replace Emacs completely.
20:34:49 <ManateeLazyCat> Any dynamic type check is evil and UNSAFE !
20:35:01 <gwern> alas, poor ManateeLazyCat! I knew him well, blackdog, a man of infinite jest
20:35:46 <Axman6> @remember gwern "sm_: go fornicate yourself with a goat!" "sm_: er. that was for someone else"
20:35:46 <lambdabot> It is stored.
20:35:49 <Axman6> >_>
20:35:57 <fax> Why can't I download articles from JFP?
20:36:14 <ivanm> because you have to pay for it
20:36:34 <sm_> would anyone know how to get pandoc to show table of contents in restructured text ?
20:36:42 <ManateeLazyCat> gwern: infinite jest?
20:36:50 <gwern> sm_: does it not have a --toc option?
20:36:56 <gwern> ManateeLazyCat: yes, that's how the quotations runneth
20:37:02 <ivanm> sm_: if you tried --toc, then my guess is that it doesn't know how
20:37:08 <ivanm> maybe you need to use a custom template
20:37:32 <ManateeLazyCat> gwern: I don't understand "infinite jest". My English is not always best.
20:37:47 <gwern> ManateeLazyCat: most people have difficulty with shakespeare, yeah
20:37:50 <gwern> @wn jest
20:37:52 <lambdabot> *** "jest" wn "WordNet (r) 2.0"
20:37:52 <lambdabot> jest
20:37:53 <lambdabot>      n 1: a humorous anecdote or remark intended to provoke laughter;
20:37:53 <lambdabot>           "he told a very funny joke"; "he knows a million gags";
20:37:53 <lambdabot>           "thanks for the laugh"; "he laughed unpleasantly at
20:37:54 <lambdabot> [7 @more lines]
20:37:56 <ivanm> since she won't listen to me, can someone please tell fax that I can download the free articles from JFP just fine
20:38:13 <ivanm> gwern: how is "jest" shakespeare?
20:38:19 <gwern> ivanm: hamlet fool
20:38:34 * gwern pities da fool who doesn't know the graveyard speech about yorick
20:38:36 <ivanm> but jest predates shakespeare, does it not?
20:38:39 <ManateeLazyCat> gwern: I'm not joke, i'm on the way replace Emacs.
20:38:52 <ivanm> oh, you were paraphrasing that bit before
20:39:07 <gwern> -_- yes, was it obscure?
20:39:14 <ivanm> no, I just missed it
20:39:30 <ivanm> I thought you were implying that the term "jest" comes from shakespeare
20:39:40 <gwern> ivanm: the phrase 'infinite jest' sure as heck does
20:39:51 <ivanm> @tell fax I can download the free JFP articles just fine here
20:39:52 <lambdabot> Consider it noted.
20:39:59 <ivanm> gwern: quite possibly
20:41:24 <ivanm> which, of course, means "a man full of humour/jokes"
20:41:32 <ivanm> in more modern terminology
20:41:35 <gwern> as befits the court jester
20:41:41 <ivanm> "infinite jest" by itself doesn't make much sense
20:41:57 <gwern> worked for david foster wallace
20:45:17 <ManateeLazyCat> gwern: Are you use Emacs? Or vi?
20:45:22 <gwern> emacs and yi
20:45:48 <ManateeLazyCat> gwern: Emacs has dying, Are you agree?
20:45:56 * ivanm doesn't
20:46:21 <gwern> its share of the market is ever declining, and I wonder whether its userbase is increasing even absolutely
20:46:23 <tehgeekmeister> ionno if anyone else here is using kowey's mediawiki branch of pandoc, but i've cabal installed it and can't find any of the mediawiki readers he's supposedly added when i import pandoc.  maybe i'm importing the wrong version of pandoc?  help?
20:46:24 <gwern> soudns like dying to me
20:46:44 <ivanm> tehgeekmeister: you probably need to import the extra modules
20:47:12 <ivanm> tehgeekmeister: which package is this?
20:47:22 <ivanm> there's mediawiki on hackage, but it isn't by kowey...
20:47:33 <tehgeekmeister> ivanm: it's source http://github.com/kowey/pandoc/blob/mediawiki
20:47:35 <ManateeLazyCat> gwern: Emacs design is awesome, but choose bad language to implement it.
20:47:42 <tehgeekmeister> the mediawiki on hackage was made by me, and is horrid
20:47:47 <tehgeekmeister> i should get that removed
20:47:48 <ivanm> tehgeekmeister: seems to be in pandoc 1.5+ as well
20:48:00 <gwern> yes stallman made a bad decission. emacs was always going to be slow, so he had no reason to not use scheme
20:48:01 <tehgeekmeister> ivanm: as a reader?  i need to consume, not produce
20:48:08 <ivanm> teoh...
20:48:25 <ivanm> tehgeekmeister: as a library or command line?
20:48:35 <tehgeekmeister> ivanm: library
20:49:01 <ManateeLazyCat> gwern: Do you know, everyday, everyday Emacs will crash or freeze, i can't suffer it anymore.
20:49:19 <gwern> ManateeLazyCat: how unlucky of you
20:49:24 <ivanm> tehgeekmeister: maybe you have to import Text.Pandoc.Readers.MediaWiki
20:49:25 <ManateeLazyCat> gwern: I always lost everything because some sub-module freeze.
20:49:47 <megaTherion> does haskell know bitwise operations?
20:49:49 <sm_> sorry, phone. gwern, excellent suggestion, I didn't know about it. thanks!
20:49:59 <aavogt> Data.Bits
20:50:03 <gwern> @hoogle (.|.)
20:50:04 <lambdabot> Data.Bits (.|.) :: Bits a => a -> a -> a
20:50:15 <sm_> next puzzle is how to get hakyll to invoke it that way, some hacking required I guess
20:50:27 * ivanm only has emacs freeze when gnus is sending an email...
20:50:34 <ManateeLazyCat> gwern: So i build a new multi-processes frame for protect any sub-module, any sub-module won't crash any other sub-modules.
20:50:37 <ivanm> of course, it sometimes makes _xmonad_ freeze (and I have nfi why...)
20:50:58 <tehgeekmeister> ivanm: nope, that doesn't work.
20:51:02 <gwern> ivanm: maybe emacs is doing xgrabkeyboard?
20:51:05 <gwern> and not releasing?
20:51:10 <ManateeLazyCat> ivanm: Because elisp is dynamic check, elisp bugs is endless.
20:51:27 <ivanm> tehgeekmeister: hang on, lemme check how I use pandoc as a library
20:51:29 <sm_> emacs dying ? what is this crazy talk
20:51:55 <ManateeLazyCat> sm_: Yes, emacs is dying, i'm develop new one to replace it.
20:52:04 <ivanm> gwern: no, for some reason xmonad + X start chewing up all the CPU and not recognising any commands to it, and then suddenly all the commands I tried to do go really quickly
20:52:11 <ivanm> sm_: agreed
20:52:13 <tehgeekmeister> ivanm: oh, it appears i've grabbed the wrong branch.
20:52:14 <gwern> ivanm: never ehard of that one. curious
20:52:21 <tehgeekmeister> ivanm: that'd explain not having mediawiki support.
20:52:27 <ivanm> gwern: I think only one other person has said they've experienced it
20:52:32 <ivanm> tehgeekmeister: lol
20:52:40 <gwern> ManateeLazyCat: well, good luck harpooning your white whale
20:52:46 <ManateeLazyCat> gwern: Key is software always has bugs, but we need some way to protected core, any non-core crash won't crash all program.
20:52:47 <ivanm> gwern: heh, agreed
20:52:54 <LegendaryPenguin> is there a good way of implementing groupBy to use the last element of the grouped by element in the comparison
20:52:59 <sm_> ManateeLazyCat: ah great, I'll start uninstalling emacs on my boxes so as to be ready
20:53:06 <sm_> :)
20:53:16 <gwern> LegendaryPenguin: don't even know what you mean
20:53:19 <LeNsTR> =)
20:53:22 <ManateeLazyCat> sm_: Okay, i will le you know when i release it.
20:53:25 <ManateeLazyCat> :)
20:53:37 <ivanm> gwern: groupBy does all comparisons by the first element
20:53:47 <LegendaryPenguin> like, say I have [1,2,4,5] and I do groupBy, and i give it an equality function (\x y (x == y || x + 1 == y || x - 1 == y))
20:53:59 <LegendaryPenguin> i want to group sequences of values into sublists
20:54:06 <gwern> ivanm: I thought group was the one that hardwired the comparison, and groupBy let you specify your test
20:54:08 <ivanm> @src groupBy
20:54:08 <lambdabot> groupBy _  []       =  []
20:54:09 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
20:54:09 <lambdabot>     where (ys,zs) = span (eq x) xs
20:54:20 <aavogt> LegendaryPenguin: it compares against the first element of the group
20:54:27 <ivanm> LegendaryPenguin: there is an alternate definition somewhere; lemme see if I can find it
20:54:33 <sm_> night all
20:54:37 <ivanm> cya sm_
20:54:40 <aavogt> @type unfoldr
20:54:41 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
20:54:42 <ManateeLazyCat> gwern: Another shakespeare words?
20:55:00 <ivanm> LegendaryPenguin: http://en.wikipedia.org/wiki/Infinite_Jest
20:55:14 <ivanm> LegendaryPenguin: probably better, by Cale: http://old.nabble.com/nubBy,-groupBy-specification-td26983104.html
20:55:15 <deteego> does anyone know if its possible to splice in a data type decleration for Template Haskell
20:55:19 <LegendaryPenguin> lol
20:55:24 <deteego> in quotations?
20:55:46 <ivanm> LegendaryPenguin: looks like the original report's definition does what you want
20:55:51 <aavogt> well you're not supposed to use those *By functions with non-equivalence relations
20:56:07 <ManateeLazyCat> deteego: Ask aavogt , it's a TH master :)
20:56:15 <ivanm> aavogt: IIRC, that's a GHC-ism; _not_ what the report says
20:56:20 <LegendaryPenguin> is there a way of seeing a functions definition from ghci
20:56:25 <LegendaryPenguin> like how you did @src
20:56:39 <ivanm> oh, wait, the report definition is the same
20:56:40 <ivanm> LegendaryPenguin: nope
20:56:46 <deteego> aavogt: is it possible to splice in data type qoutations
20:56:49 <ivanm> LegendaryPenguin: @src just has a small db of function definitions
20:56:55 <ivanm> it isn't complete nor perfect
20:57:04 <aavogt> ivanm: no, check http://haskell.org/onlinereport/list.html
20:57:11 <ivanm> LegendaryPenguin: see also http://coder.bsimmons.name/blog/2010/02/an-alternative-definition-for-datalistgroupby/
20:57:21 <ivanm> aavogt: yeah, I got confused where Cale was talking about nubBy as well
20:57:25 <deteego> aavogt: such as doing something like this [d| data ($func a) | (%func a) Int String |]
20:57:28 <aavogt> "the predicate is assumed to define an equivalence"
20:57:52 <aavogt> deteego: you're probably out of luck using quotations for that
20:58:00 <deteego> yeah I thought so
20:58:14 <deteego> seems like that sought of splicing only works for expressions
20:58:40 <deteego> ah well, just means my code is gonna be harder to read
20:59:27 <aavogt> well if it would work, the syntax would be     [d| data $(func a) = $(func2 a) Int String |]
20:59:56 <deteego> yupm that | instead of the = was an accident
21:00:11 <aavogt> but yeah, you should look into dataD or whatever those functions are in Language.Haskell.TH
21:00:23 <deteego> I believe its due to the way that the AST is done for data types
21:00:41 <deteego> for expressions, the ADT* allows you to splice
21:01:21 <deteego> however for data types, the whole ADT is a list (with more lists in that list)
21:01:36 <LegendaryPenguin> ivanm, can you see if that implementation compiles
21:01:38 <deteego> so you cant really splice stuff out, would be nice if you could though
21:02:30 <aavogt> I suppose you could write a quasiquoter for data declarations
21:02:44 <aavogt> which could eventually be incorporated in [d| |]
21:02:54 <deteego> I mean I have already done the template using the standard DataD, just be nicer using quotations
21:02:57 <deteego> hmm
21:03:19 <deteego> Ill have a look into the quasiquoter
21:03:29 <gs4> anyone use the lisperati.com haskell tutorial?
21:03:56 <tensorpudding> that was an intriguing tutorial
21:04:06 <aavogt> well that's provided you write or adapt a parser to produce the Exp which represents the TH AST
21:04:24 <gs4> im putting together a list of useful tutorials as a side-project, and im just wondering if anyone used that one and found it helpful
21:04:49 <deteego> aavogt: yeah seems like a bit of work
21:05:23 <tensorpudding> i didn't actually use it as a tutorial but i skimmed it
21:05:37 <LegendaryPenguin> whats wrong with http://coder.bsimmons.name/blog/2010/02/an-alternative-definition-for-datalistgroupby/ "Parse error on input |"  (The first one)
21:05:38 <gs4> any thoughts?
21:05:41 <tensorpudding> it developed a simulated annealing algorithm
21:05:49 <gs4> really? hm.. thats cool
21:06:37 <ivanm> LegendaryPenguin: which line?
21:06:55 <ivanm> oh, wait, you said
21:07:00 <LegendaryPenguin> 9 for me, but its the first |
21:07:01 <ivanm> LegendaryPenguin: is it indented enough?
21:07:19 <aavogt> as pasted it's fine
21:07:33 <LegendaryPenguin> oh wow, was indentation
21:07:37 <ivanm> heh
21:08:22 <gs4> anyone know a good webcomic having to do with haskell?
21:08:28 <deteego> LegendaryPenguin: yeah careful, Haskell is whitespace/indentation specific
21:09:03 <ivanm> gs4: there was closed cartesian comic
21:09:07 <ivanm> but it appears to be dead now
21:09:07 <aavogt> it's a lot less specific than is mostly expected
21:09:17 <aavogt> gs4: lambdacats
21:09:26 <ivanm> aavogt: I don't think that website exists anymore
21:09:27 <tensorpudding> it's a poor tutorial in some respects though, since it mostly shoves a bunch of code and explains it after the fact
21:09:32 <aavogt> :(
21:09:40 <gs4> hehehe, ill check it out, thanks, hadnt heard of that one
21:09:40 <tensorpudding> also, not for people who don't understand programming
21:09:48 <ivanm> aavogt: http://arcanux.org/lambdacats.html is a blank page
21:09:59 * ivanm still wonders where shillelagh - who owns that domain - disappeared to...
21:10:00 <tensorpudding> blank pages are hi-larious
21:10:05 <gs4> hehe
21:10:17 <gs4> tensorpudding: ok, good to know, thanks
21:10:20 <ivanm> @google closed cartesian comic
21:10:22 <lambdabot> http://ro-che.info/ccc/
21:10:22 <lambdabot> Title: Cartesian Closed Comic #8: SKI
21:10:26 <ivanm> gs4: ^^
21:11:02 <gs4> sweet, thanks
21:21:39 <EvanR> why of why did you make that duck typing joke, now i cant stop researching it. blog after blog from 2006 claiming it improves performance of this or that web framework
21:31:18 <ivanm> EvanR: you have never heard of duck typing before? :o
21:48:40 <killing-joke> on #lua, the pythoners call it duck punching
21:51:26 <fax> how come the intial algebra is recursion
21:54:25 <tehgeekmeister> i'm trying to build the mediawiki branch of this repository (http://github.com/kowey/pandoc), and i get an error, in which this seems to be the relevant line: setup: can't find source for Paths_pandoc in src, dist/build/autogen
21:54:39 <tehgeekmeister> it seems there's something wrong with the cabal file, but I don't know what.
21:55:05 <tehgeekmeister> (and it's been tested with the version of ghc i'm using (6.10.4), so i'm really not sure why it should have any problems.)
21:55:44 <CraigSJD> Hello.  I am trying to cabal install darcs on my Windows 7 machine, but hashed-storage will not build due to differences between CChar and CWchar, and CString and CFilePath.  Could someone take a look at this log by chance and assist me?  Google hasn't helped.  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25035#a25035  (this is for the code at http://hackage.haskell.org/packages/archive/hashed-storage/0.4.12/doc/html/src/Bundled-Posix.
21:55:44 <CraigSJD> html with the lstat lines at the bottom)
21:56:01 <CraigSJD> I know the comment states lstat is broken on win32, but im on win64
21:56:04 <dcoutts_> tehgeekmeister: hmm, odd, Cabal creates dist/build/autogen/Paths_pandoc.hs at build time
21:56:23 <tehgeekmeister> dcoutts_: yep, it does.
21:56:27 <CraigSJD> (ghc 6.12.1)
21:58:28 <tehgeekmeister> dcoutts_: any idea what this might mean?
21:59:01 <dcoutts_> tehgeekmeister: what command are you running? cabal build?
21:59:11 <tehgeekmeister> cabal install
22:00:46 <dcoutts_> tehgeekmeister: do a cabal clean and post the log of "cabal install -v" somewhere, I'll see if there's anything obvious
22:02:14 <dcoutts_> CraigSJD: you can try checking the darcs-users archive or darcs bug tracker or ask in #darcs
22:02:37 <tensorpudding> It'd be really nice if there weren't so many broken links in Hoogle
22:03:38 <CraigSJD> dcoutts_, ok thank you ill look there
22:04:02 <tehgeekmeister> dcoutts_: http://pastebin.com/k5YyPiKN
22:06:02 <dcoutts_> tehgeekmeister: that's not the same package as the git repo you pointed to
22:06:18 <dcoutts_> tehgeekmeister: what you're installing there is pandoc-mw, the git repo is pandoc
22:06:36 <tehgeekmeister> i specified at the beginning i'm working off the mediawiki branch
22:06:39 <dcoutts_> but that probably also explains the problem, someone has renamed it without changing the import
22:06:40 <tehgeekmeister> the master is pandoc
22:06:47 <tehgeekmeister> the mediawiki branch is pandoc-mw
22:07:16 <dcoutts_> ok, you could have pointed me at the right url :-)
22:07:28 <tehgeekmeister> oh, i thot that was it.  sorry.
22:07:34 <tehgeekmeister> i didn't know there were branch specific links
22:07:39 <dcoutts_> ok, so that .cabal file has the problem
22:08:16 <tehgeekmeister> easy fix?
22:08:17 <dcoutts_> the package name is pandoc-mw but it's looking for the Paths_pandoc module
22:08:34 <dcoutts_> yes, easy fix
22:08:34 <tehgeekmeister> should it then be Paths_pandoc-mw?
22:08:40 <dcoutts_> -/_ yes
22:08:44 <tehgeekmeister> okay!
22:09:21 <portnov> hm. Are any of pandoc developers here? )
22:09:57 <ivanm> portnov: usually not
22:10:06 <tehgeekmeister> this is something kowey's making on his own, it's not in the default pandoc repository
22:10:07 <ivanm> I've used pandoc before, and I think gwern has supplied some patches
22:10:19 <ivanm> otherwise, there's a mailing list and John is pretty helpful
22:10:33 <ivanm> oh, you were asking on behalf of tehgeekmeister
22:10:39 <tehgeekmeister> dcoutts_: cabal says cabal: pandoc.cabal:188: Parse of field 'other-modules' failed.
22:11:09 <dcoutts_> tehgeekmeister: did you switch the - for a _ ?
22:11:22 <tehgeekmeister> dcoutts_: no
22:11:24 <dcoutts_> ok
22:11:24 <tehgeekmeister> should i?
22:11:29 <dcoutts_> -/_ yes
22:12:56 <tehgeekmeister> bah, just my luck, it fails again.  (and after cabal clean, too.)
22:15:55 <tehgeekmeister> http://pastebin.com/VnwBVjbt
22:16:00 <scriptdevil> Is yi still under development?
22:16:08 <tehgeekmeister> dcoutts_: if you care to check ==^'
22:16:46 <ivanm> scriptdevil: apparently
22:17:30 <dcoutts_> tehgeekmeister: is that everything? did that capture stdout too? I would have expected an error message
22:17:37 <dcoutts_> erm stderr
22:18:00 <tehgeekmeister> dcoutts_: i did cabal install -v &> tmp and then pasted from tmp
22:18:09 <tehgeekmeister> and nothing printed to stdout
22:19:11 <scriptdevil> ivanm: Hmmm. Sorry :) I did not check the code.haskell.org/yi. I noticed that the blog google code havent been updated since early 2009. Doing a darcs get now :)
22:21:18 <dcoutts_> tehgeekmeister: if you run ./dist/setup/setup configure --verbose=2  manually, does that also fail with no error message?
22:22:36 <tehgeekmeister> dcoutts_: permission denied.
22:23:22 <dcoutts_> tehgeekmeister: sounds like the linker got interrupted when making ./dist/setup/setup
22:23:35 <dcoutts_> tehgeekmeister: which will mean that clean also failed :-)
22:23:43 <tehgeekmeister> then i will redownload
22:23:44 <tehgeekmeister> and retry
22:23:45 <dcoutts_> tehgeekmeister: rm -r dist and try again
22:23:58 <tehgeekmeister> or that
22:24:17 <dcoutts_> tehgeekmeister: no need to redownload, the ./dist/setup/setup is created by cabal when you configure
22:28:24 <tehgeekmeister> dcoutts_: http://pastebin.com/sj5CkxEp
22:29:32 <dcoutts_> tehgeekmeister: I expect you can work this one out
22:30:23 <tehgeekmeister> oh, really.  they made that same error in multiple places?
22:30:24 <tehgeekmeister> lame.
22:34:38 <tehgeekmeister> it's compiling now.  =D
22:36:38 <dcoutts_> tehgeekmeister: I filed a ticket about that confusing problem: http://hackage.haskell.org/trac/hackage/ticket/665
22:36:47 <tehgeekmeister> dcoutts_: thanks!
22:37:49 <tehgeekmeister> i also have twittered kowey about fixing that problem in his mediawiki branch of pandoc.  =]
22:43:06 <ivanm> anyone here want to check the FAQ I've written for graphviz and see if there's anything else I should add to it?
23:02:59 <ivanm> preflex: seen sinelaw
23:02:59 <preflex>  sinelaw was last seen on #haskell 7 days, 10 hours, 1 minute and 54 seconds ago, saying: hi all
23:17:53 <fax> > sum [1..100]/product [1..100]
23:17:54 <lambdabot>   5.411126955033611e-155
23:21:55 <tensorpudding> > let n' = fromIntegral n, gamma n = log n' - (sum . take n $ map (\n -> 1/n) [1.0..n']) in gamma 20
23:21:56 <lambdabot>   <no location info>: parse error on input `,'
23:22:04 <tensorpudding> > let n' = fromIntegral n and gamma n = log n' - (sum . take n $ map (\n -> 1/n) [1.0..n']) in gamma 20
23:22:05 <lambdabot>   <no location info>: parse error on input `='
23:22:13 <tensorpudding> meh
23:22:24 <SubStack> hooray, I can now mutate pointfree code randomly in a type-safe way
23:22:39 * SubStack took apart lambdabot
23:22:47 <scriptdevil> let and seems like ml...
23:23:10 <scriptdevil> Does and exist in haskell?
23:23:21 <tensorpudding> that was me being silly
23:23:23 <tensorpudding> @type and
23:23:24 <lambdabot> [Bool] -> Bool
23:23:40 <tensorpudding> > and $ replicate 100 True
23:23:41 <lambdabot>   True
23:24:09 <scriptdevil> tensorpudding: See? You tried to use it to let 2 statements in gamma 20
23:24:45 <scriptdevil> let n' = {fromIntegral n; gamma n = log n' - (sum . take n $ map (\n -> 1/n) [1.0..n'])} in gamma 2
23:24:48 <scriptdevil> > let n' = {fromIntegral n; gamma n = log n' - (sum . take n $ map (\n -> 1/n) [1.0..n'])} in gamma 2
23:24:49 <lambdabot>   <no location info>: parse error on input `{'
23:24:56 <scriptdevil> Oops. Never mind :(
23:25:18 <tensorpudding> > let gamma n = (sum . take n $ map (\n -> 1/n) [1.0..n']) - log n' where n' = fromIntegral n in gamma 200
23:25:19 <lambdabot>   0.5797135815734098
23:25:54 <fax> that is correct to two places :)
23:26:17 <tensorpudding> Yeah, that's a really slowly-converging sequence there.
23:26:29 <fax> This is a really interesting number
23:26:39 <fax> I wonder if I can get one of those layman pi style books on it
23:28:19 <tensorpudding> I've said that it feels more mysterious than e or π or φ or most of the other famous numerical constants.
23:28:39 <fax> I agree!
23:29:52 <tensorpudding> as far as φ feels more tangible, and e and π are central to mathematics.
23:30:39 <fax> I think φ lost most of its mystique when we learned that you can't REALLY summon demons through a pentagram
23:31:11 <tensorpudding> it's a pleasing number, the kind you could imagine yourself deriving and thinking was especially pleasant
23:31:35 <tensorpudding> also, it's intimate with the Fibonacci numbers
23:36:16 <ivanm> when writing copyright statements, what is the normal procedure if you don't want to write a closing year (so you don't have to change/update it each year)?
23:39:27 <dons> ivanm: just leave off the date
23:39:40 <ivanm> just 2008 - onwards or something?
23:39:43 <dons> IANAL, but you should be able to assert it based on commits etc.
23:39:54 <dons> i'm sure 'onwards' doesn't stand up.
23:40:05 <ivanm> hmmm...
23:40:12 <dons> better not to have a date, since the copyright is to do with the code, not the year
23:40:29 <ivanm> dons: the license template says it's meant to be Copyright (c) <YEAR>, <OWNER>
23:40:53 <dons> yeah, the only lawyer i've spoken to about this says you need to add the year (or range) each time it changes, and you edit the flie.
23:41:14 <dons> so 2009..10, or 2009, 2011. etc.
23:41:29 <ivanm> *sigh* fine, I'll just have to remember to update it next year
23:41:37 <dons> yep. just if you edit the file and notice
23:42:06 <dons> our revision control systems should be able to do this, but asserting copyright isn't a high priority on free software
23:42:12 <ivanm> yeah
23:42:35 <ivanm> dons: oh, and wrt taking over FGL: have I become _that much_ of a sucker wrt graph libraries that you immediately thought of me?
23:43:02 <ivanm> I mean, I'm flattered and all... but people are still bitching about SourceGraph to me let alone updating FGL as well! :p
23:44:57 <Jafet> You need the year if you care about how people use your software in the next century or so
23:45:25 <Jafet> ...depending on how much American media spends on lobbying in the next few decades
23:45:26 <ivanm> yes, people should be acknowledging how great my code is in 1e100 years time!
23:47:04 <ivanm> OK, I think this latest version of graphviz is ready to go
23:47:22 <ivanm> I just want to make a website for it and write a blog post tutorial, and it's set for release!
23:54:38 <tehgeekmeister> in what module will i find a function to run a command in the shell?
23:55:02 <ivanm> System.Process IIRC
23:55:20 <ivanm> tehgeekmeister: it's better to _not_ run it in a shell if you can though (as that makes it more portable)
23:55:28 <SubStack> tehgeekmeister: do you want the process exit code? the output on stdout, stderr? want to pipe stdin to it?
23:55:34 <ivanm> yeah, System.Process
23:55:59 <tehgeekmeister> i don't care about portability in this case, it'll only ever be run on this system, and i'll be removing this bit before it becomes at all important
23:56:07 <tehgeekmeister> don't need results in any form of the command
23:56:12 <tehgeekmeister> or to feed it anything from stdin
23:57:13 <SubStack> then you have the choice of whether you want to wait for it to finish or disown it
23:57:19 <ivanm> @hoogle system
23:57:19 <lambdabot> No results found
23:57:30 <ivanm> tehgeekmeister: System.Process.system might be what you want
23:57:32 <SubStack> probably just system will do
23:57:56 <SubStack> but there are lots of ways to do it
23:58:09 <tehgeekmeister> system will do just fine
23:58:10 <tehgeekmeister> thanks
23:59:02 <ivanm> np
