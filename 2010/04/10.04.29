00:00:07 <Jafet> Patch rxvt with hardware graphics
00:00:51 <p_l> Peaker: VT510 reconfigured for 38400 baud?
00:01:11 <Peaker> p_l, :-P
00:01:27 <p_l> or get rid of Xft, for it is slow as hell and idiotic
00:01:45 <Peaker> Xft?
00:01:47 <p_l> (but then you'd need to write a new extension for X.Org xD)
00:01:56 <Peaker> What's that?
00:02:01 <Jafet> Throw in inefficient and buggy
00:02:13 <p_l> Peaker: the stuff that some people decided was good way to render vector fonts on X11
00:02:20 <tensorpudding> Xft is the library that does all that font anti-aliasing
00:02:35 <Jafet> No wait, I'm thinking of the xterm standard interface
00:03:17 <p_l> tensorpudding: anti-aliasing comes later, the main point is advanced usage of modern fonts... except instead of doing that, they decided to sidestep it and send bitmaps to be composed...
00:03:44 <p_l> Sun proposed a server side solution, iirc, but it got scrapped
00:04:50 <tensorpudding> rxvt is slow?
00:05:49 <p_l> btw, for fast display, you could make the screen buffer of terminal into a 32bit texture, where instead of pixels, each "pixel" actually describes which character from a font is supposed to be there and what color/bold/underline etc. should it be, then prerender the font into another texture and use a shader to generate the graphic output...
00:06:07 <ezyang> wait, waht?
00:06:27 <ezyang> I switched to urxvt because it didn't flash when I jumped around XMonad windows...
00:07:10 <p_l> ezyang: true, but I suspect that nothing short of disabling vector fonts or doing crazy stuff will help him, if even rxvt is slow :P
00:07:36 <ezyang> Oh yeah... I can't really stand non anti-aliased fonts
00:08:01 <p_l> I'm not really that into anti-aliasing, as into subpixel rendering and proper hinting.
00:08:09 <p_l> there is a visible, giant difference in quality
00:08:24 <ezyang> Words... I don't think I know what they mean :o)
00:09:17 <p_l> ezyang: subpixel rendering simply takes notice of the fact that LCDs have pixels composed of 3 differently colored bars and uses that to triple the resolution in one dimension :)
00:14:44 <Jafet> It's actually a form of correction, because the three colour components have different offsets
00:17:55 <tensorpudding> don't you still need xft to do hinting?
00:22:19 <Peaker> p_l, isn't "triple the resolution" an overstatement? You don't get all the colors in the high res.
00:31:45 <tibbe> .
00:39:34 <p_l> Peaker: it's used only for very fine tuning of curves, you don't recognize it 95% of the time.
00:39:51 <killing-joke> you notice it when it's not there
00:39:52 <p_l> tensorpudding: hinting data etc. is from font renderer
00:39:56 <p_l> killing-joke: right
01:31:43 <Peaker> quiet!
01:35:27 <zax> http://i.imgur.com/tSuG0.jpg
01:35:29 <zax> lovely
01:40:07 <Jonno_FTW> been on reddit i see
01:52:56 <Peaker> I think that joke was rehashed too many times :)
01:55:00 <Jonno_FTW> yep
01:59:44 <ivanm> anyone here tried the multi-mode emacs stuff recently? http://haskell.org/haskellwiki/Literate_programming#Multi-mode_support_in_Emacs
02:00:10 <ivanm> thinking of trying to use it with markdown-mode rather than latex-mode to write up a literate blog post, run pandoc on it and then upload that
02:03:45 <Younder> listening to Carl Orff ' carmina burana
02:05:00 <Younder> amost forgotten the important 10.0 update of ubuntu on friday
02:07:05 <Jonno_FTW> what ever happened to haskell discussion?
02:07:05 <Younder> mathematics is all good but sometimes we got to remember it's musical origins
02:07:43 <ivanm> Jonno_FTW: as soon as someone asks something, we'll all jump straight in!
02:08:38 <Younder> The problem is Haskell is too logical. I rarely have to ask..
02:08:45 <Younder> I just know..
02:09:15 <Jonno_FTW> how would i go about making a code generator in haskell?
02:09:26 <ivanm> Jonno_FTW: for which language?
02:09:31 <Jonno_FTW> sql
02:10:09 <ivanm> probably use a DSL
02:10:11 <ketil> ivanm: multi-mode sounds really nice.
02:10:18 <Jonno_FTW> a what?
02:10:32 <ivanm> ketil: I've had problems with it before though, it has problems changing modes :s
02:10:40 <Younder> SQL is not really a language
02:10:47 <ivanm> Jonno_FTW: you basically have a way of representing SQL code in Haskell
02:10:56 <ketil> If somebody is collecting wishlists, I'd like to be able to do C-c C-l on literate emails to load them into a GHCi buffer.
02:10:57 <Jonno_FTW> hmmmm
02:10:59 <ivanm> Younder: well, no, it isn't turing complete...
02:11:16 <ivanm> ketil: M-x literate-haskell-mode; C-c C-l
02:11:17 <ivanm> ;-)
02:11:28 <ivanm> why, what do you use for your email client?
02:11:29 <ketil> Structured Query L...something?
02:11:43 <ivanm> Jonno_FTW: I think that's what the various DB libraries do...
02:11:46 <ivanm> *hint, hint*
02:11:48 <Jonno_FTW> ok
02:11:51 <Jonno_FTW> thanks
02:11:51 <ketil> ivanm, Huh.
02:12:03 <Jonno_FTW> i have a project soon and all I know is that it involves SQL
02:12:34 <ivanm> ketil: alternatively, bind C-c C-l to inferior-haskell-load-file for all modes
02:12:46 <ketil> I should have thought of that.  Thanks.  Somehow I've only used haskell-mode for "real" source files.
02:12:48 <ivanm> Jonno_FTW: there are a few haskell DB/SQL libraries already
02:12:52 <ivanm> ketil: heh
02:12:58 <ivanm> ketil: what do you use for email?
02:13:02 <ketil> ivanm, Yes, or *Article*-mode (mml something, I forget)
02:13:05 <ketil> Gnus.
02:13:12 <ivanm> yeah, so am I
02:13:12 <Jonno_FTW> how is MySQL different to SQL?
02:13:21 <ivanm> I really need to find time to set gnus up properly...
02:13:22 <Younder> Jonno_FTW, well you need to know there is a string monad class that is much more efficient than the buildt in strings
02:13:28 <ivanm> Jonno_FTW: MySQL is a database, SQL is a language
02:13:40 <Jonno_FTW> ok, thanks
02:13:46 <ivanm> Jonno_FTW: haven't you done _any_ DB stuff before? :o
02:13:51 <Jonno_FTW> nope
02:14:09 <ivanm> you lucky bastard!
02:14:16 <Younder> lol
02:14:22 <ivanm> Jonno_FTW: have a look at the RWH stuff on DBs for how to do it in Haskell
02:14:49 <Jonno_FTW> ok, will do
02:14:53 <knight_> wow, NO database experience?!
02:14:58 <knight_> seriously, a lucky man
02:14:58 <Jonno_FTW> none
02:15:07 <Younder> unlikely these days
02:15:12 <ivanm> Younder: after my first year at uni, the IT degree was revamped and I had the option of switching to it; pros were actual majors and one less compulsory DB subject
02:16:00 <ivanm> cons were that a first year Java subject I had done would have been useless (and I was doing 2 degrees and had no slots for useless subjects) and I would instead have to do a C subject which by all accounts was a killer :s
02:16:07 <ketil> ivanm, it wasn't quite that easy.  I need to save the file first, apparently (calling inf-hask-load-file prompts for a file name)
02:16:22 <ivanm> ketil: ahhh.... yeah, didn't think about that
02:16:37 <Younder> I've done bekeley DB object databases mostly lately
02:16:40 <ivanm> that's because you can't define data structures, etc. straight into ghci, so it has to load from file :s
02:16:47 <Younder> so less SQL
02:16:47 <ketil> Can I somehow save it to a random temp file?  Automatically, that is?
02:16:49 <ivanm> Younder: how do they differ from relational ones?
02:16:58 <ivanm> ketil: I think so; lemme check
02:17:14 <Younder> ivanm, They handle graphs better
02:17:29 <ivanm> ketil: no, wait, I was getting confused with attachments :s
02:17:40 <ketil> my emacs-fu is a bit rusty...
02:17:42 <ivanm> Younder: as in have an actual graph structure inside the relationships?
02:17:48 <ivanm> ketil: as is mine :s
02:18:10 <Younder> many to many structures are ugly in SQL
02:18:20 <Younder> and inefficient5
02:18:47 <Jafet> ivanm, MySQL is a language too!
02:18:48 <ketil> ivanm, I thought if there was an easy way to attach a buffer with a filename (which could be just ~/.temporary.hs or whatever), this would all work out..
02:19:14 <ivanm> Jafet: oh?
02:19:24 <ivanm> ketil: doens't even have to be .hs
02:19:27 <ketil> one solution is to bind C-c C-l to (progn (save-buffer "blah blah") (haskell-blah-inferior-something))
02:19:30 <ivanm> but yeah, I have no clue :s
02:19:53 <ivanm> ketil: with-temp-file looks like it might be relevant
02:20:42 <ivanm> ketil: do you use the same emacs session for email and for actual work?
02:20:48 <ketil> ivanm, sure.
02:21:14 <ivanm> OK, so you won't have the problem of your email ghci overriding your work ghci
02:21:16 <ivanm> (like I would)
02:23:30 <Younder> ivanm, I use it for semantic relationaships
02:23:43 <ivanm> hmmm
02:23:54 <Younder> a\data grabbed from the web
02:26:22 <Younder> ivanm, I don't know if you know of allegro graph?
02:26:31 <ivanm> nope
02:26:47 <Younder> ivanm, If not you might wanna look into it.
02:27:11 <ivanm> well, wikipedia doesn't seem to know about it...
02:27:14 <ivanm> oh, wait, no space
02:27:36 <Younder> Lisp is not dead, it just smells funny ;)
02:27:53 <ivanm> then again, I have no real need for databases, so *shrug*
02:28:08 <Younder> ivanm, lucky you
02:28:25 <ivanm> heh
02:28:58 <Younder> I have a 35 terrabyte database to manage
02:29:26 <Jafet> Use lunabytes!
02:29:38 <Younder> and it is gving me plenty headaches belive me
02:29:56 <ivanm> preflex: seen gwern
02:29:56 <preflex>  gwern was last seen on #xmonad 5 hours, 45 minutes and 7 seconds ago, saying: and 'darcs apply foo.dpatch'
02:30:40 <Younder> all that CERN data...
02:32:30 <Younder> apparently we are using 1/3 of the worlds computing power..
02:32:51 <mietek> Apparently size(<<127:7>>) returns 0
02:33:03 <mietek> Is there any way to get the number of bits in a bitstring?
02:33:04 <ivanm> Younder: you're at CERN? :o
02:33:16 <Younder> ivanm, not any more
02:33:24 <ivanm> :(
02:33:37 <Jonno_FTW> how was it?
02:33:46 <Younder> ivanm, but I took a theoretical phsics degree there
02:33:48 <ivanm> mietek: "bitstring"?
02:33:53 <ivanm> Younder: cool
02:34:29 <mietek> ivanm: yes.
02:34:35 <ivanm> what's a bitstring?
02:34:40 <mietek> A string of bits.
02:34:43 <mietek> :)
02:34:45 <Younder> duh
02:34:46 <ivanm> ... in Haskell?
02:34:46 <mietek> bit_size/1
02:34:53 <ivanm> that looks like erlang....
02:35:02 <mietek> That looks like the wrong channel.
02:35:03 <mietek> My bad.
02:35:04 <ivanm> #erlang is that-away <----
02:35:14 <ivanm> (left due to alphabetical ordering)
02:35:20 <ivanm> mietek: hence the confusing ;-)
02:35:20 <mietek> Sorry about that.
02:35:25 <ivanm> so you should be!
02:35:28 <Younder> I like Oz
02:35:37 <ivanm> yeah, it's a great place to live
02:35:46 <ivanm> pity it's so far from everywhere...
02:35:52 <Younder> lol
02:35:55 <ivanm> :D
02:36:07 <fasta> Haskell GHC #2 	Timed Out	1h 00 min		176. Avoiding success seems to be going fine.
02:36:18 <fasta> http://shootout.alioth.debian.org/u32/performance.php?test=knucleotide
02:36:34 <ivanm> oh, and I'm not referring to a place with pathways that are composed of clay bricks that appear to have a colour composed of red and green
02:36:42 <Younder> My current system has 577 64 bit CPU's
02:37:04 <Younder> so it is quite the chore keeping them all active
02:37:09 <ivanm> so, where are you now then if you're not at CERN?
02:37:28 <Younder> Norsk regnesentral
02:37:52 <ivanm> what's that?
02:37:55 <fasta> Younder, you mean other than waiting for memory?
02:38:16 <fasta> A Norwegian computer center, I suppose.
02:38:27 <Younder> fasta, yes
02:38:54 <fasta> Younder, that's why I like Sun's architecture. They hide memory latency.
02:39:00 <Younder> We do our bit in making sense of that CERN data
02:39:30 <ketil> Younder, part of the NOTUR, or private iron?
02:40:03 <Younder> Now I am trying to make a new language Formula to make more efficient use of our computer resources
02:41:18 <Younder> Paralell is the key
02:41:56 <Younder> proving quite difficult though
02:43:20 <Younder> ketil no NOTUR is mostly meterological
02:54:29 <Younder> ivanm, where do you work?
02:56:42 <Twey> Lajla: Because #linguistics is filled with crap that has nothing to do with linguistics, whereas this channel is at least 80% on-topic and much more amusing when it isn't?
02:57:12 * Lajla hugs Twey
02:57:51 <Younder> fasta, the cellon core has a 12 MB level 3 cashe and besides the ddr3 is 1.66 GHz so i generally keeps up
02:58:03 <Younder> it
02:59:18 <Younder> They tell me it has 1.9 billion transistors..
02:59:54 <Younder> pretty impressive considering that the first PC hd 30 000
02:59:57 <Jafet> Many of them implementing useless instructions
03:00:11 <Younder> true
03:00:22 <Jafet> Although admittedly most of those are microcoded now
03:03:13 <Lajla> Twey, hug me back.
03:03:48 <knight_> wow, 577 64-bit cpus...
03:03:52 <knight_> sounds like fun
03:04:07 <Younder> it is :)
03:04:59 <Younder> note that half of them is due to hyperthreading.
03:05:28 <ivanm> Younder: PhD student at ANU
03:05:31 <Younder> another intel tecknology
03:05:55 <Younder> ANU?
03:06:13 <cebewee> Younder: so 287.5 real cores? ;)
03:06:46 <ivanm> Australian National University
03:06:57 <ivanm> my supervisor is Brendan McKay of nauty fame
03:06:58 <Younder> well there are 48 6 core processors with HT
03:07:19 <dancor> off by 1 error?
03:07:35 <Younder> ivanm, Yes I've heard of him
03:09:38 <ivanm> preflex: seen Axman6
03:09:39 <preflex>  Axman6 was last seen on #haskell-blah 6 hours, 18 minutes and 33 seconds ago, saying: I tend to space things out a fair bit, but a whole line consisting of { annoys me too. thought a line with } is necessary to me
03:10:16 <Eelis> what i hate most is having to put "where" on a line of its own
03:10:21 <Younder> I am usually terse
03:10:43 <ivanm> Eelis: you don't have to...
03:10:54 <Eelis> ivanm: you do if you don't use a fixed-width font
03:11:09 <Eelis> the Haskell layout rule is a bitch in that it favours fixed-width fonts
03:11:12 <ivanm> why don't you use a fixed width font? :o
03:11:20 <Eelis> because it's ugly and pointless
03:12:15 * ivanm doesn't think DejaVu Sans Mono is ugly...
03:12:25 <quicksilver> Eelis: well, a sufficiently smart editor could do the right thing with a proportional font I'm sure
03:12:34 <quicksilver> but since we don't have a sufficiently smart editor, sure
03:12:55 <quicksilver> after 20 years of writing code in fixed-width fonts I can't say it bothers me
03:12:59 <Younder> then it's a word processor not a editor..
03:13:46 <Jafet> Haskell favours fixed-width fonts? Spaces are just spaces.
03:13:50 <ivanm> quicksilver: have you ever used mmm-mode for literate haskell support in emacs?
03:13:54 <mauke> Younder: what, your editor doesn't let you choose a font?
03:13:55 <Eelis> i changed to fixed-width a few years ago and will never go back. it never causes problems, *except* in relation to this stupid layout rule in this particular language
03:13:55 <Jafet> Hmm, in some cases.
03:14:01 <Eelis> to variable-width i mean
03:14:16 <Younder> mauke, I use emacs!
03:14:18 <ivanm> Eelis: about to say...
03:14:29 <mauke> Younder: pretty sure emacs can use multiple fonts
03:14:37 <Saizan> Eelis: write foo = bar where \n ... instead of foo = bar \n where \n ..
03:14:39 <Jafet> Mathematica's graphical repl has interesting things with non-fixed fonts
03:15:08 <mauke> Eelis: alternatively, use { }
03:15:08 <Eelis> Jafet: the layout rule contains clauses like "if the columns on the subsequent lines line up, then ...". in a variable-width font, you don't line up non-initial columns of different lines
03:15:26 <Younder> so of cource it does. I choose bitmapped fonts as thgey give me proper allignment
03:15:51 <Jafet> Let's pool to buy the standardizers a stack of punch cards this christmas
03:16:14 <benmachine> it'd be nice to have an editor which knew about the layout rule and which things you usually wanted lined up
03:16:28 <benmachine> in fact I'm a little surprised it's not more common to have editors pretty much handle whitespace for you
03:16:33 <Eelis> i consider the layout rule's attachment to fixed-width fonts to be on the order of stupidity of makefiles being bound to tabs
03:16:36 <quicksilver> ivanm: no.
03:16:41 <Twey> benmachine: haskell-mode tries
03:16:42 <ivanm> k
03:16:59 <Younder> yes it does
03:16:59 <benmachine> Twey: yes but as we all know there are no other editors than vim
03:17:01 <theorbtwo> Younder: Thankfully, a font does not have to be bitmapped to be fixed-width.  (Nor, for that matter, is a bitmapped font neccessarly fixed-width.)
03:17:05 <Twey> Variable-width fonts harm readability.  Ideally we'd fix English so it didn't have variable-width characters.
03:17:05 <ivanm> Eelis: if it isn't, how would you line them up properly?
03:17:16 <Twey> benmachine: You call that an editor?  ;)
03:17:19 <ivanm> since different fonts could use different widths for characters
03:17:22 <benmachine> Twey: :D
03:17:33 <Jafet> ivanm, I think that's kind of the point.
03:17:35 <quicksilver> benmachine: emacs does very well at that
03:17:39 <Eelis> ivanm: i haven't given thought to alternative formulations. i'd have to look into it.
03:17:44 <benmachine> I'd use yi but it upsets me by scrolling half-pages at a time
03:17:52 <Taejo> you could get your editor to use a brace style in the saved file, but display an indented bersion that depends on the font
03:17:54 <ivanm> Jafet: which then makes knowing how much to indent difficult
03:17:54 <osfameron> elastic tabs + variable width fonts might work?
03:17:57 <benmachine> and not supporting bits of vim that I've got used to
03:18:05 <Jafet> We're assuming that spaces all have the same width, I assume
03:18:06 <mauke> osfameron: not really
03:18:10 <Younder> it doesn't seem terribly important to me
03:18:14 <benmachine> Taejo: I'd like an editor that saves haskell files in a sort of AST
03:18:20 <ivanm> osfameron: maybe...
03:18:26 <Younder> I just type,
03:18:28 <Jafet> (Unlike in word processors where you get kerning)
03:18:31 <benmachine> and then you can re-indent or transform the whole thing easily
03:18:50 <Younder> Though I like LaTex
03:18:53 <Taejo> benmachine: I'd rather my editor *saved* normal haskell source, but *operated* on ASTs
03:18:58 <Jafet> benmachine, you could adapt paredit
03:19:03 <Jafet> (!)
03:19:17 <benmachine> there are a lot of things I could do if I had the time :P
03:19:28 <benmachine> (what's paredit?)
03:19:33 <Younder> and I am a lisper who uses peredit yes
03:19:37 <benmachine> it's much easier to just complain about them loudly
03:19:52 <Taejo> complaining is more parallelizable than coding
03:20:15 <Younder> rotfl
03:21:16 <Jafet> @remember Taejo complaining is more parallelizable than coding
03:21:16 <lambdabot> I will remember.
03:21:38 <benmachine> is there any way to cross-compile Haskell source from linux to windows?
03:21:43 <benmachine> *easy way
03:21:51 <benmachine> *preferably easy way
03:21:52 <Twey> -fvia-c and mingw?
03:22:15 <Younder> benmachine, n
03:22:17 <Younder> no
03:22:42 <benmachine> drat
03:22:55 * benmachine wonders who he knows owes him a favour
03:23:07 <benmachine> and has windows and GHC and SDL
03:24:02 <Younder> GHC is pretty much the same regardless of platform. It's all in the libraries you use.
03:24:44 <benmachine> oh this is going to be pretty painful then
03:24:57 <Younder> usually is
03:25:09 <benmachine> :)
03:38:28 <zygoloid> benmachine: ask again in 10 hours' time :)
03:40:18 <benmachine> zygoloid: well, I haven't actually written the program that I plan to cross-compile yet :P
03:40:40 <Younder> well that helps
03:40:46 <Jafet> You have ten hours to do it!
03:40:49 <benmachine> he
03:40:50 <benmachine> h
03:41:09 <Saizan> benmachine: did you figure out how to keep sharing in your evaluator?:)
03:41:21 <Younder> If you KNOW it is going to be cross ompiled you will fare much better
03:41:46 <benmachine> Saizan: I'm stuck with some correctness bugs at the moment so I haven't looked at it, I have some ideas though
03:42:11 <benmachine> Saizan: I'd prefer a non-strict, slow, but accurate evaluator to one that just gets things plain wrong :)
03:43:01 <benmachine> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=take+2+(repeat+'x') <-- this is what is worrying me at the moment, it just forgets about the let
03:43:01 <Saizan> benmachine: sure, btw i think there's a paper by wadler wrt representing call-by-need evaluation syntactically
03:43:27 * benmachine pokes through his paper collection
03:43:46 <benmachine> do you have a link?
03:44:01 <zygoloid> benmachine: ah, i see you're local :)
03:44:11 <Younder> benmachine, then you willl hate Perl
03:44:17 <benmachine> Younder: :D
03:44:23 <benmachine> zygoloid: local eh?
03:44:46 <benmachine> zygoloid: depends on your locality I guess :P
03:44:57 <Saizan> benmachine: http://homepages.inf.ed.ac.uk/wadler/papers/need/need.ps
03:45:19 <Younder> I in a perverse kinda way actually like Perl.
03:45:22 <zygoloid> benmachine: well, unless the SRCF are giving out accounts to /outsiders/ now :)
03:46:07 <benmachine> zygoloid: no, I'm a current student
03:46:36 <benmachine> there's quite a few cambridge around, but I keep forgetting who :P
03:46:36 <zygoloid> hmm, i'd have expected a 'case let xs = 'x' : xs in 'x' : xs of ...' between steps 5 and 6
03:46:48 <zygoloid> Phillipa is local iirc
03:46:57 <benmachine> yeah that's another oddity
03:47:11 <benmachine> could be a bug
03:47:31 <zygoloid> in fact, i'd have expected that instead of step 6; step 7 looks right
03:47:33 <benmachine> mm, she's not who I was thinking of
03:47:47 * benmachine summons the mighty grep
03:49:16 <Younder> no that's right
03:49:59 <benmachine> oh it was dmhouse I was talking to
03:50:34 * osfameron laughs at benmachine's grep and strikes him with 'ack'
03:50:50 * benmachine falls over
03:52:13 <Younder> equinox 4 rolls over my speakes
04:01:30 <zygoloid> benmachine: how does your reduce-o-matic work?
04:05:14 <benmachine> zygoloid: haskell-src-exts and manual twiddling
04:05:41 <benmachine> zygoloid: the source is on github if you want to see it, but basically it's just manipulating ASTs
04:46:15 <ivanm> gah!!! why won't mmm-mode work? :s
04:53:31 <quicksilver> ivanm: all the cool kids have deserted it
04:53:36 <quicksilver> ivanm: mumamo is the new black
04:53:49 <ivanm> but I thought muamamo mode only worked with nxml...
04:53:52 <quicksilver> (I have used mumamo to combine HTML, javascript, and TT in one buffer and it appeared to work)
04:53:58 <quicksilver> nope
04:54:06 <quicksilver> it's bundled with nxml, perhaps, but its scope is larger.
04:54:17 <ivanm> hmmm...
04:55:49 * benmachine wants to speed this up: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25198#a25198
04:55:53 <cads> @check \ x -> gcd(x, x+1) == 1
04:55:54 <lambdabot>   No instance for (GHC.Real.Integral (t, t))
04:55:54 <lambdabot>    arising from a use of `GHC.Re...
04:56:05 <benmachine> I've done basically no optimisation in my life
04:56:12 <benmachine> hmm I should probably post more detail
04:56:53 <cads> ah
04:56:53 * benmachine adds the definition of the type synonyms invovled
04:57:14 <benmachine> @check \x -> gcd x (x + 1) == 1
04:57:15 <lambdabot>   "OK, passed 500 tests."
04:57:30 <cads> #check \x->  gcd x (x+1) == 1
04:57:36 <cads> :(
04:57:42 <benmachine> #?
04:57:47 <quicksilver> hpaste is back!?
04:57:50 <cads> I'm so sleepy
04:57:51 <benmachine> looks like it
04:57:57 <ivanm> quicksilver: with nxml or nxhtml
04:57:57 <quicksilver> did someone manage to get hold of mmorrow?
04:57:58 <ivanm> ?
04:58:01 <cads> @check \x->  gcd x (x+1) == 1
04:58:02 <lambdabot>   "OK, passed 500 tests."
04:58:04 <ivanm> preflex: seen mmorrow
04:58:05 <preflex>  mmorrow was last seen on #ghc 101 days, 9 hours and 19 seconds ago, saying: * mmorrow is rtfm'ing
04:58:08 <cads> fantastic
04:58:09 <benmachine> I don't think so, mmorrow is moonpatio
04:58:09 <quicksilver> ivanm: I don't remember
04:58:11 <ivanm> doesn't looks like it... >_>
04:58:18 <benmachine> which is still down afaik
04:58:21 <cads> morros is moonpatio
04:58:22 <cads> ?
04:58:27 <quicksilver> oh they just repointed hpaste.org?
04:58:29 <quicksilver> sensible.
04:58:31 <cads> we need to track that guy down
04:58:38 * benmachine shrugs
04:58:48 <cads> I'd go on a roadtrip and go pick him up outta whatever it is that's going in
04:59:24 <quicksilver> benmachine: try swapping Word32 for Int and seeing if that's faster?
04:59:34 <quicksilver> just in the interests of eliminating possibilities.
04:59:37 <cads> "seriously guys, my life is going well- -- I'm married now.. I have a car.. I'm working for google on mums secret level stuff
04:59:57 <benmachine> quicksilver: well it's going into an SDL pixel array, so I kind of need to guarantee it's 32 bits wide
05:00:00 <benmachine> but I could try I guess
05:00:25 <fax> cads; what?
05:00:42 <fax> did you make that up or is it a real message from him
05:01:21 <benmachine> hmm part of my problem is that I don't really have a reliable way to verify performance
05:01:45 <quicksilver> well then it's going to be a bit hard to get better
05:01:53 <quicksilver> I suggest you at least time a known workload a few time
05:01:59 <quicksilver> so you can monitor improvements
05:02:09 <BenceF> benmachine: a stopwatch is always reliable if you dont go at speeds near lightspeed
05:02:25 <benmachine> I think I just need to tell SDL not to wait on events
05:02:59 <quicksilver> or do the work in an SDL timer or SDL idle callback
05:04:28 <Jafet> What is the minimum range of Int?
05:04:40 <ivanm> Jafet: according to the report?
05:04:47 <ivanm> 28 bits IIRC
05:04:48 <Jafet> BenceF, it's still reliable as long as both him and the computer are travelling at the same velocity
05:04:51 <Jafet> ivanm, thanks
05:04:58 <ivanm> or it could be 22; something like that
05:05:10 <Jafet> I only need 2^21, so that still works
05:05:18 <quicksilver> it's 29 I believe.
05:05:31 <quicksilver> GHC gives you 32 or 64 depending on architecture.
05:05:33 <ivanm> I actually found it interesting that GHC operates differently than other languages wrt Int types, since C, etc. have 32bit ints on all architectures
05:05:48 <benmachine> you can get 64 bit int sometimes
05:05:50 <benmachine> it's just rare
05:06:00 <BenceF> Jafet: true
05:06:05 <Jafet> Well, C implementations use 32 bits because lazy programmers always meant int to be 32-bit
05:06:10 <benmachine> yeah
05:06:16 <benmachine> so things tend to break for stupid reasons
05:06:20 <Jafet> So you see things like union { int x; char y[4]; }
05:06:27 <quicksilver> the x86_64 ABI does change the meaning of 'long' though
05:06:39 <quicksilver> so they did change something; they just weren't brave enough to change int.
05:07:24 <quicksilver> overall though it's quite rare to not care what size your numbers are. For general robust programming your normally need to know. K&R got it wrong; C should have had int8; int16; int32 types explicitly from the start.
05:08:20 * hackagebot scgi 0.3.2 - A Haskell library for writing SCGI programs.  http://hackage.haskell.org/package/scgi-0.3.2 (StephenBlackheath)
05:08:37 <koala_man> and int12
05:08:38 <benmachine> ow my CPU is burning my legs :x
05:09:11 <koala_man> and int36 and all those. but how would that be handled on x86?
05:09:15 <ivanm> preflex: seen gwern
05:09:15 <preflex>  gwern was last seen on #xmonad 8 hours, 24 minutes and 26 seconds ago, saying: and 'darcs apply foo.dpatch'
05:09:17 <BenceF> my friend had to design a tree class at a job interwiev and it had to be 4bytes. he was kinda confused
05:09:27 <BenceF> a pointer is 8 bytes at x64
05:10:30 <koala_man> the entire tree class had to be 4 bytes?
05:10:52 <Bjorn^2> did he prune the tree to a half pointer?
05:10:56 <BenceF> yeah and it had to be store all kind of boolean information
05:11:04 <dancor> amortized struct cost
05:11:47 <BenceF> he didnt do it. and he said he didnt even want to get the job from there on
05:12:07 <dino-> So, I'm doing something with zip-archive and found an apparently perfectly fine zip file that it crashes-and-burns with. I don't see any info on hackage about getting it via a revision control system. Is there somewhere that everything on hackage is darcs (or what have you) gettable?
05:12:11 <BenceF> i can relate
05:12:35 <benmachine> hmm, if I import the Array type from Data.Array.Unboxed, it's still only an ordinary Array?
05:12:39 <koala_man> just make a struct node* table[65536] and use indices of that?
05:12:42 <theorbtwo> Hell.  You can do that, if the payload is small enough, and with a small enough maximum tree size... but it's a stupid thing to want.
05:13:14 <BenceF> koala_man: maybe. but how nasty is that in 2010?
05:13:51 <koala_man> BenceF: nasty, but not completely obscure. did this company write software for tumble dryers and other 8bit/1kb cpus?
05:14:19 <BenceF> koala_man: i think they were into anti-virus software
05:14:19 <benmachine> huh
05:14:34 <benmachine> the profiles I have for using Array versus UArray look extremely similar
05:14:53 <benmachine> but time ./program reports 20sec versus 40sec
05:15:07 <koala_man> BenceF: "anti-virus", I see. how to fit the most data into a page worth of buffer overflow..
05:15:18 <BenceF> thats quite a difference
05:15:40 <benmachine> yeah I'm surprised there's no noticeable difference in the two profiles though, suggests I suck at profiling
05:16:27 <BenceF> koala_man: and there was a question like what is 0x1234 << 4 ^ 2
05:16:44 <theorbtwo> Ah.  If you are doing virus research, that's a reasonable question to ask.
05:16:48 <BenceF> i cant even count 7*15 in head
05:16:50 <theorbtwo> Or, at least, more reasonable.
05:17:05 <koala_man> sounds like the entire interview was designed by a 40 year old guy who taught himself C
05:18:11 <BenceF> yes. its strange how obsolete your knowledge can get in computers in a few years
05:18:18 <theorbtwo> If part of your job is using a disassembler to figure out what viruses are doing in a small payload which is explicitly designed to not be understandable, then it's a reasonable question.
05:19:20 <BenceF> its enough to know what it does i think
05:19:32 <BenceF> you dont have to be a human calculator
05:19:58 <BenceF> i think even wincalc can do bitwise operations
05:21:00 <benmachine> oh hey it doubles in speed again if I disable profiling :P
05:23:08 <quicksilver> sometime the point of interview questions is not the answer
05:23:18 <quicksilver> sometimes the point is to see your attitude and how you approach the question.
05:23:40 <quicksilver> although I'd think twice (seven times?) before hiring someone who admitted they couldn't do 7*15 in their head.
05:24:28 * theorbtwo finds, to some relief, that he can.
05:24:39 <theorbtwo> Oh.  Except I just got it wrong.
05:26:37 <koala_man> 15*2*3 + 15
05:26:55 <quicksilver> koala_man gets bonus points for showing his working.
05:26:59 * quicksilver hands koala_man a cookie.
05:27:17 <zygoloid> 7*10 + 7*5 = 70 + 35 = 105
05:27:19 <BenceF> for me its 7*10 + (7/2)*10
05:27:27 <BenceF> since were in base10
05:27:33 * koala_man eats the cookie in a surprisingly gloaty way
05:27:48 <theorbtwo> I did what zygoloid did, but somehow managed to muck it up along the way.
05:27:56 <zygoloid> 8*16 - 16 - 7 = 128 - 16 - 7 = 112 - 7 = 105 :)
05:28:01 <quicksilver> I'd probably use zygoloid's method, except that 7*15 is just one I happen to remember.
05:28:21 <BenceF> we all should join #math
05:28:32 <BenceF> or #meth
05:28:33 <fax> #arithmetic*
05:28:34 <quicksilver> last I was there, it wasn't such a nice place.
05:28:38 <zygoloid> 7*15 = 2*7*7+7 = 49 * 2 + 7 = 98 + 7 = 105 ;D
05:29:07 <fax> > 7*15
05:29:08 <lambdabot>   105
05:29:25 * zygoloid might use fax's method :D
05:29:39 <fax> that is the ONLY way I will ge thte right answer
05:29:56 <koala_man> in this interconnected world, who's to say lambdabot isn't in your head
05:30:14 <adamvh> Alright.  Clueless n00b here.  Once I have "cabal install"'d some package, how do I use it?
05:30:30 <zygoloid> (and for bonus marks, work out 105^2) in your head :D
05:30:31 <adamvh> i.e. in ghci
05:30:41 <quicksilver> adamvh: you will have to restart ghci if you had it running
05:30:48 <quicksilver> but otherwise it should be 'there' automatically
05:30:58 <quicksilver> ghci always loads all your visible packages.
05:30:58 <adamvh> 11025
05:31:01 <BenceF> :m to import
05:31:25 <quicksilver> yeah, :m to bring modules into scope.
05:31:33 <ivanm> quicksilver: ugh, I can't work out how to even use mumamo mode :s
05:31:37 <quicksilver> :m +Foo.Bar
05:31:52 <quicksilver> ivanm: I remember it being not absolutely straightforward and I think I've forgotten.
05:31:58 <ivanm> heh
05:32:06 <quicksilver> ivanm: you could try those nice chaps in #emacs ;-S
05:32:14 <ivanm> it doesn't help that I want to use bird-style literate haskell, which is harder to find beginnings and ends for :s
05:32:15 <ivanm> quicksilver: heh
05:33:00 <adamvh> Can I not have more than one?
05:34:09 <adamvh> i.e. module loaded into ghci?
05:35:09 <max_atre1des> hey there. i started learning haskell yesterday and i've been having trouble with this polindrome function to compile for a while: http://haskell.pastebin.com/YpkfLRXp Any ideas what I'm doing wrong?
05:35:31 <ivanm> adamvh: you can, :m + Foo
05:35:42 <adamvh> thanks
05:36:09 <quicksilver> adamvh: the modules are always loaded, :m is changing scope and no more.
05:36:22 <quicksilver> adamvh: you can always use the fully qualified name like Foo.Bar.baz if you want.
05:36:40 <quicksilver> max_atre1des: you may not begin a function with a capital letter
05:36:43 <quicksilver> max_atre1des: (Reverse)
05:37:26 <max_atre1des> ooooh
05:37:32 <max_atre1des> thanks, there goes an hour of my life
05:37:45 <quicksilver> that's why the error message talks abotu data constructors
05:37:54 <quicksilver> because capital letters are reserved for data constructors.
05:38:19 <max_atre1des> i see, thanks again
05:39:27 <BenceF> :t null
05:39:27 <lambdabot> forall a. [a] -> Bool
05:39:33 <BenceF> ahh
05:40:46 <adamvh> Thanks again.  Including libraries seems to be the biggest hairpuller for me in just about every new programming language I learn.
05:45:55 <ivanm> preflex: seen Baughn
05:45:55 <preflex>  Baughn was last seen on #haskell 4 days, 2 hours, 23 minutes and 53 seconds ago, saying: Implement dynamic optimization of some sort in ghc. ;)
05:46:21 <saml> off topic: can you have a set of infinite loops ?
05:46:24 <saml> trick question
05:46:57 <BenceF> on multiple threads of if they call each other, you can
05:47:02 <fax> I don't get it
05:47:08 <Baughn> ivanm: I'm right here
05:47:10 <saml> you can't! such set solves halting problem
05:47:31 <ivanm> Baughn: any ideas on how to do literate haskell in emacs with markdown-mode being used for the "comments"?
05:47:35 <saml> > let f = f in f
05:47:38 <lambdabot>   mueval-core: Time limit exceeded
05:47:47 <ivanm> (since mmm-mode apparently doesn't do syntax highlighting for new emacs :@ )
05:47:47 <Baughn> ivanm: I never even got it to work the /normal/ way. That code needs an overhaul.
05:47:55 <ivanm> heh
05:48:35 * ivanm is trying to adapt http://www.loveshack.ukfsn.org/emacs/haskell-latex.el to work with bird-tracks, but has no idea what it's doing there with the excursion stuff :s
05:49:18 <koala_man> saml: you mean the set of all infinite loops?
05:49:43 <quicksilver> the set of all infinite loops can't perfectly well 'exist'; it's just not a computable set.
05:49:50 <quicksilver> sorry it *can* perfectly well exist.
05:49:58 <ivanm> about to say...
05:50:03 <quicksilver> unless you take an extremely constructivist view on what it means for something to exist
05:52:06 <saml> koala_man: yes
05:52:42 <saml> quicksilver: ah i should've said "all"
05:53:20 <quicksilver> it still exists, it's just not computable.
05:53:35 <quicksilver> It's unusual to consider non-computable sets not to exist
05:53:44 <quicksilver> then the real numbers don't exist, for example.
05:53:47 <saml> it seems like you cannot have an infinite set of infinite elements (set of all real numbers. a real number can be infinite)
05:53:50 <Jafet> Silly platonists, I have a bridge to sell them
05:54:07 <Adamant> Jafet: is it ideal?
05:54:17 <saml> oh. computable!!!
05:54:21 <scree_> saml: set of all subsets of naturals?
05:54:31 <fax> saml what are you saying
05:54:31 <quicksilver> saml: that's not true either, but I'm not inclined to discuss it here :)
05:54:37 <fax> saml in SET THEORY or HASKELL?
05:54:41 <Jafet> Adamant, well, it is abstract
05:54:55 <saml> ok  /end off topic
05:54:58 <fax> lol
05:55:04 <Jafet> I would ask for imperfect real money, though
05:55:50 <codolio> The set of computable reals is a computable set, and it's an "infinite set of infinite elements."
05:56:02 <scree_> I've never tried so spend Platonic money, but I'm sure someone would take it
05:58:17 <Taejo> dolio: in what model of computation are the computable reals a computable set?
05:59:23 <dolio> I suppose the set may not be computable, depending on what you mean by that.
05:59:39 <quicksilver> it's semi-decidable isn't it?
05:59:39 <scree_> random question: is there a (known) minimal set of list combinators, that can be used to generate all other lists functions *non-recursively*?
05:59:45 <quicksilver> or semi-recursive, or whatever the term is
05:59:53 <Taejo> given a real number, determine in a finite number of steps whether it is computable
06:00:24 <fax> how can a real number be given?
06:00:27 <Taejo> it's not obvious to me that it's even semi
06:00:28 <dolio> The 'real numbers' in constructive mathematics would be a set of computable reals, though.
06:00:33 <Taejo> ok
06:00:46 <Taejo> if it's your universe then "const True" is its indicator function
06:00:47 <quicksilver> scree_: fix, map, and foldr would probably do it
06:00:48 <dolio> So to decide if a number in that set is computable, you say "yes".
06:01:15 <scree_> quicksilver: fix was rather the one I was trying to aviod
06:01:20 * quicksilver shrugs
06:01:24 <Taejo> fax: one model (that I'm most familiar with) is to have a turing machine with an infinite input and output tape
06:01:28 <benmachine> seems direct manipulation of the SDL pixel array is barely faster than copying it all off, messing with it, and putting it all back
06:01:32 <quicksilver> well you can hide from it with some other general recursion combinator
06:01:45 <Taejo> and the output of the machine is the limit of the contents of the output tape (but the output tape is write-once)
06:01:48 <sepp2k> @src transpose
06:01:48 <lambdabot> transpose []             = []
06:01:48 <lambdabot> transpose ([]   : xss)   = transpose xss
06:01:48 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
06:02:15 <scree_> quicksilver: context is thinking about infinite streams (in the stream-fusion sense)
06:02:21 <quicksilver> but you certainly need a general recursion combinator, and they're all equivalent to fix
06:02:26 <Taejo> if you allow multiple writings on the output tape, you get a reasonable definition of limit-computability on infinite objects
06:02:37 <quicksilver> (in the presence of other simple necessary building blocks)
06:03:02 <quicksilver> there might be an aesthetic or practical reason to prefer one
06:03:25 <scree_> quicksilver: so, I'm assuming List becomes abstract
06:03:38 <scree_> how would I then do (repeat ())?
06:04:02 <quicksilver> > fix (():)
06:04:03 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
06:04:12 <ivanm> quicksilver: gah! mumamo mode is sending me nuts! so many little useless functions that don't do anything!
06:04:15 <scree_> (:) is abstract :)
06:04:30 <quicksilver> ok then you need something to make new lists and something to combine them
06:04:39 <quicksilver> pure + mappend, perhaps.
06:05:04 <scree_> quicksilver: infinite lists, so pure = repeat in this case
06:05:23 <quicksilver> > fix (pure () `mappend`) :: [()]
06:05:24 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
06:05:29 <quicksilver> scree_: well that's not the pure I meant.
06:05:31 <Saizan> foldr and unfoldr ?
06:05:33 <quicksilver> you call it what you like :)
06:05:41 <quicksilver> call it singleton or return if you prefer.
06:06:16 <scree_> quicksilver: right, but in my crazy universe [] doesn't exist; we only have Stream a = (:~) a (Stream a)
06:06:59 <quicksilver> you could use unfoldr, then
06:07:27 <quicksilver> > unfoldr (\x -> Just ((),())) ()
06:07:28 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
06:07:33 <scree_> so foldr, unfoldr (& fmap) should be sufficient?
06:07:43 <quicksilver> your unfoldrs shouldn't be permitted to return Nothing, I guess.
06:07:52 <scree_> right, it has a different type
06:08:05 <quicksilver> foldr lets you produce objects of other types though, do you want that?
06:08:11 <fax> scree: just unfold
06:08:13 <quicksilver> for example, with foldr you can produce finite lists.
06:08:27 <scree_> not without a list constructor
06:08:27 <benmachine> seems fromIntegral takes ages
06:08:37 <benmachine> comparatively
06:08:40 <quicksilver> benmachine: that's why I told you to change to Int from Word32
06:08:48 <benmachine> ah
06:09:04 <quicksilver> there are many optimisations for Int
06:09:04 <scree_> I'm stuck with rubbish like (fix \(x:~y:~xs) -> (x,y) :~ xs)
06:09:15 <quicksilver> which are not duplicated throughout the numerical hierarchy.
06:09:23 <quicksilver> scree_: do you have any constructors at all?
06:09:30 <quicksilver> scree_: or is your universe just () and Stream a?
06:09:40 <scree_> I have tuples
06:09:41 <quicksilver> so the only types are (), Stream (), Stream (Stream ())
06:09:56 <scree_> but yes, that's it apart from that
06:10:00 <quicksilver> Stream () is not a very interesting type
06:10:03 <scree_> maybe strict tuples as well
06:10:04 <quicksilver> it only has one element
06:10:08 <quicksilver> Stream () ~~ ()
06:10:19 <scree_> *everything* should have only one non-bottom element
06:10:24 <scree_> that's the idea
06:10:37 <scree_> it's my playground for predicting stack overflow
06:10:39 <quicksilver> well then all you have is a kooky way of encoding the natural numbers.
06:10:50 <quicksilver> () = 0, Stream () = 1, Stream (Stream ()) = 2
06:11:20 <scree_> so, the type theory and the denational semantics are pretty boring
06:11:29 <scree_> it's the operational semantics I care about
06:12:06 <scree_> s/denational/denotational
06:14:38 <benmachine> http://hackage.haskell.org/package/array this is annoying :/ (no haddocks)
06:15:23 <benmachine> it's odd because 0.2 has haddocks
06:15:36 <benmachine> 0.2 fails to build on 6.12 and 0.3 on 6.10
06:15:41 <benmachine> 0.2 gets docs and 0.3 doesn't
06:16:09 <benmachine> maybe it's because they fail in different ways
06:16:28 <quicksilver> benmachine: I'm guessing that 0.2 built successfully once in the past and the docs got saved
06:16:31 <quicksilver> only guessing, though.
06:16:57 <benmachine> hmm, but 0.3 should build fine on 6.12
06:17:09 <benmachine> at least, it has no build failure log
06:17:33 <quicksilver> then it may just be the docs haven't appeared yet
06:17:45 <quicksilver> there is some kind of delay
06:18:50 <benmachine> uploaded date dec 15 2009 :P
06:19:00 <EvanR> > let ans x = x : ans (concat . map (\x -> ['0':x, '1':x]) $ x) in ans ["0", "1"]
06:19:01 <lambdabot>   [["0","1"],["00","10","01","11"],["000","100","010","110","001","101","011"...
06:19:15 <EvanR> > let ans x = x : ans (concat . map (\x -> ['0':x, '1':x]) $ x) in (ans ["0", "1"]) !! 5
06:19:16 <lambdabot>   ["000000","100000","010000","110000","001000","101000","011000","111000","0...
06:19:51 <quicksilver> > replicateM 5 "01"
06:19:52 <lambdabot>   ["00000","00001","00010","00011","00100","00101","00110","00111","01000","0...
06:20:15 <quicksilver> although EvanR's ordering is different.
06:20:19 <quicksilver> > map reverse $ replicateM 5 "01"
06:20:20 <lambdabot>   ["00000","10000","01000","11000","00100","10100","01100","11100","00010","1...
06:20:26 <EvanR> whats that, list monad?
06:20:30 <quicksilver> oh, and you have 6
06:20:33 <quicksilver> > map reverse $ replicateM 6 "01"
06:20:33 <lambdabot>   ["000000","100000","010000","110000","001000","101000","011000","111000","0...
06:20:36 <quicksilver> yes, list monad.
06:20:57 <quicksilver> > [1..] >>= \n -> replicateM n "01"
06:20:58 <lambdabot>   ["0","1","00","01","10","11","000","001","010","011","100","101","110","111...
06:20:59 <Wooga> hello, can i somehow combine let and case constructions? i am trying to do something like this: http://paste2.org/p/800279
06:21:13 <quicksilver> Wooga: ues
06:21:16 <Wooga> but ghc complains about wrong identation
06:21:22 <quicksilver> Wooga: just indent that 'in' by one more space
06:21:25 <EvanR> quicksilver: i have a list of successive 'all finite lists of 01'
06:21:50 <Wooga> quicksilver: oh, thank you!
06:21:55 <quicksilver> Wooga: if the 'in' is on the same indentation as the let, it starts a new statement of its own
06:21:59 <quicksilver> but that's a syntax error
06:22:08 <quicksilver> ('in' can't start a statement)
06:22:10 <EvanR> quicksilver: i suppose this is different from [1..] being all naturals, i dont have 'all reals'
06:22:45 <quicksilver> EvanR: you can get all the rationals that way, (in binary expansion) but not all reals
06:22:59 <quicksilver> EvanR: crticially, the reals include all the infinite lists too
06:23:19 <quicksilver> well, almost all. There is a slight equivalent relation over infinite tails of 11111111
06:24:05 <EvanR> right.. so since i never get 'an infinite list' i never get one irrational
06:24:08 <maartenm> it's a long shot.. but I suppose noone here knows anything about windows programming? I want to make a quick add-on that adds a menu item to windows. but I have no idea where to start or how this goddamn OS even works
06:24:18 <maartenm> *drop-down menu item
06:24:38 <EvanR> thats frustrating
06:24:57 <EvanR> quicksilver: but what about the claim that we have computable reals as an infinite list of digits for that real
06:25:20 <EvanR> my list is infinite
06:25:22 <EvanR> if you choose
06:25:27 <EvanR> ill continue at work
06:25:28 <EvanR> late
06:27:40 * Saizan applies the diagonal argument
06:28:20 <Saizan> unless we manage to say that haskell's lists can be transfinite
06:30:17 <Jafet> They are! You just can't compute most of them.
06:30:45 <Jafet> You could read them from a transfinite-order oracle using hGetContents
06:31:27 <BenceF> oh we're still discussing infinite sets. we get there fast from 7*15 the got stuck. its a logarithmic shorthistory of maths
06:32:58 <Saizan> ah! i guess Cantor never thought of lazy IO
06:33:58 <Jafet> (Given reasonable anthropocentric assumptions on the ultimate laws of physics, you could open a socket to this IRC channel)
06:39:07 <benmachine> okay I've removed all my fromIntegrals by using explicit recursion
06:39:14 <benmachine> the expensive bit seems to be adding 1 to a Double
06:39:17 <dolio> Uncomputable Haskell lists aren't Haskell lists.
06:39:36 <benmachine> ooh, Floats are much faster
06:39:46 <dolio> Faster than Double?
06:39:53 <benmachine> yes
06:40:05 <benmachine> still much slower than Int but never mind
06:40:36 <roconnor> <dolio> The 'real numbers' in constructive mathematics would be a set of computable reals, though.
06:40:41 <roconnor> This isn't really true
06:40:51 <dolio> No?
06:41:28 <roconnor> In constructive math I can define the set of turning machines that produce real numbers
06:41:40 <quicksilver> benmachine: somethign is wrong. Float should be slower than Double.
06:41:42 <roconnor> but I cannot prove every constructive real number is generated by one of these machines
06:42:35 <BenceF> i always tought float is faster
06:42:39 <EvanR-work> but isnt there some 'path' through my binary tree of 0 1 branches that leads to irrational numbers, and i list the tree as an infinite list
06:42:41 <roconnor> there are models where this holds and models where this doesn't hold.
06:42:41 <roconnor> more clearly
06:42:41 <benmachine> quicksilver: really? I thought that's what floats were *for*
06:42:41 <roconnor> there are some models of constructive real numbers where the real numbers are isomorphic to the computable reals
06:42:41 <quicksilver> benmachine: no, floats are for taking up less memory space
06:42:41 <roconnor> and there are other models of constructive real numbers where the real numbers are isomorphic to the classical real numbers.
06:42:50 <benmachine> also I have an obiwan somewhere :(
06:42:57 <BenceF> then why is it used? more space eficcient?
06:43:02 <EvanR-work> i suppose thats like saying you can print all naturals, but you cant say 'look i printed all subsets'...
06:43:03 <quicksilver> benmachine: (and, more recently, float is for communication with 3D hardware which uses floats)
06:43:23 <quicksilver> benmachine: of course, floats taking up less memory will help if you are memory bandwidth constrained
06:43:29 <xerox> roconnor: http://mathoverflow.net/questions/22923/
06:43:31 <benmachine> hmm
06:43:35 <quicksilver> but that's normally counterbalance by the constant conversions to/from Double
06:43:39 <benmachine> I'm flooring them
06:43:40 <quicksilver> and alignment problems.
06:44:23 <EvanR-work> bah
06:44:35 <EvanR-work> so is there a way to make a list of all computable reals
06:44:40 <dolio> roconnor: So you can't constructively prove that the constructive reals are in correspondence with some subset of the constructively defined Turing machines?
06:44:48 <dolio> Is what you're saying?
06:44:49 <quicksilver> EvanR-work: yes, by enumerating the turing machines that generate them
06:44:57 <quicksilver> EvanR-work: not by working directly on the binary expansions of them.
06:45:08 <roconnor> xerox: thanks.
06:45:31 <roconnor> dolio: yes, further more it is consistent for this to be valid or invalid.
06:45:44 <dolio> Well, this doesn't surprise me.
06:46:05 <dolio> I was coming more from the perspective that every function in constructive mathematics is computable in a sense.
06:46:30 <roconnor> again that isn't really true
06:47:04 <roconnor> there are models where every function is computable and there are models with uncomputable functions in the function space.
06:47:38 <BenceF> sometimes im pretty sure im the dumbest person in #haskell
06:47:58 <quicksilver> I think when dolio said "Every function", in that particular sentence, he meant "every finitely describable function"
06:48:10 <dolio> So, if my constructive mathematics is, say, Agda? Not all Agda functions are computable?
06:48:15 <dolio> Or Coq.
06:48:19 <fax> not all computable functions are agda
06:48:39 <dolio> That's true.
06:48:45 <roconnor> dolio: when you universally quantify over A -> B in Coq, you could feed the lemma non computable functions and there would be no explosion.
06:48:49 <roconnor> in theory
06:49:22 <roconnor> same in Agda
06:50:01 <fax> this is a surprising result but it does make sense: There's countably many programs yet cantor diagonalization still works
06:50:09 <roconnor> exactly
06:50:16 <roconnor> that's a good point
06:50:28 <roconnor> in Coq and Agda I can prove that 2^N is uncountable
06:50:41 <dolio> Yes, I know. I've done that.
06:50:44 <roconnor> (though interestingly I cannot do the same for 2^2^N.)
06:51:06 <fax> what's this about 2^2^N? :)
06:51:16 <fax> is that something Andrej wrote about
06:51:20 <roconnor> fax: 2^2^N is isomorphic to N don't you know ;)
06:51:24 <quicksilver> roconnor: can you not proof X uncountable ==> 2^X uncountable ?
06:51:24 <xerox> not even in any equivalent way?
06:51:27 <fax> I had no idea
06:51:31 <fax> I will try and prove this
06:51:34 <xerox> lol.
06:51:40 <roconnor> quicksilver: no, see 2^2^N :)
06:51:50 <roconnor> fax: try to prove what?
06:51:54 <quicksilver> roconnor: well I did read what you said. I was expression surprise in a different way.
06:52:08 <fax> 2^2^N ~ N but now I'm guessing the justification uses topology
06:52:10 <quicksilver> forall X . X uncountable => 2^X uncountable sounds like it ought to be provable
06:52:21 <quicksilver> fax: that part was a joke.
06:52:34 <roconnor> fax: oh, ya sorry
06:52:46 <roconnor> I cannot prove in Coq that 2^(2^N) is countable
06:52:55 <dolio> 2^2^N ~ N doesn't hold in plain constructive mathematics. You need anti-classical axioms of some sort.
06:52:58 <fax> I was thinking it had something to do with 'seemingly impossible' programs
06:53:00 <ddarius> ((N -> _|_) -> _|_) -> N
06:53:22 <xerox> i can't tell who's joking and who's not
06:53:27 <roconnor> sorry sorry
06:53:27 <dolio> quicksilver: http://math.andrej.com/2009/10/12/constructive-gem-double-exponentials/
06:53:30 <fax> hehe
06:54:04 <fax> the question is roughly: how many N indexed sets of streams are there
06:54:50 <bashrc_> hi together, how can i use "fold" to see if a list contains a value greater than 70? i tried it with contructions like foldr (\x -> (x>70)) but didnt work. can anybody help me with this?
06:55:28 <fax> oh that explains it
06:55:41 <dolio> In the comments someone links to an article about the topos of topological spaces which would be one model that validates the 2^2^N ~ N axioms.
06:55:45 <fax> that makes sense about the 'backwards compatible'ness
06:56:11 <roconnor> quicksilver: the proof that 2^N is uncountable relies on the decidability of equality of N IIRC.
06:57:24 <ddarius> Surely N has a discrete topology and thus a decidable equality relation.
06:57:27 <quicksilver> roconnor: ah, interesting.
06:58:04 <quicksilver> I thought diagonalisation just relied on the set having two elements.
06:58:23 <alpounet> bashrc_, take a look at the type of foldr
06:58:24 <alpounet> @type foldr
06:58:25 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
06:59:03 <fax> "I should warn you that the anti-classical axioms are the mathematical equivalent of psychoactive drugs: they take some getting used to, they are addictive and warp your sense of reality.
06:59:28 <ToRA> any opinions on what value ([] :: [Bit]) should have if interpreted as a 2s compliment list of bits?
06:59:34 <bashrc_> alpounet: i am new to haskell. i am not sure how to interpret this type. does this mean i have to return a list?
06:59:49 <bastl> hey, how can i configure the place where binaries should be installed to when using cabal ?
06:59:56 <alpounet> bashrc_, well, you can replace 'a' by Int or Integer here
06:59:58 <fax> ToRA: should it even be a value? since [0] and [1] are already taken
07:00:02 <alpounet> to ease the interpretation of the type
07:00:05 <fax> ToRA, maybe the best thing is to pretend it doesn't exist ?
07:00:07 <Jafet> ToRA, its value is always [].
07:00:15 <alpounet> and you can to return a bool
07:00:16 <Jafet> If you don't like it, use a nonempty list type.
07:00:25 <alpounet> which is : does my list contains something bigger than 70
07:00:34 <alpounet> so the type becomes :
07:00:44 <Jafet> I'm not sure how you can have a twos' complement list of bits, either
07:00:55 <alpounet> (Integer -> Bool -> Bool) -> Bool -> [Integer] -> Bool
07:01:46 <dolio> roconnor: So, to clarify my thinking a bit, since, say, models of classical set theory are (due to 'backward compatibility') also models of constructive set theory, it's not correct to say that the constructive stuff is necessarily computable?
07:01:48 <ToRA> Jafet: e.g. from2C :: [Bit] -> Int , from2C [0] = 0, from2C [1] = -1, from2C [1,1] = -1, from2C [1,0] = 2, from2C [] = ?
07:02:02 <bastl> Is there a library function for this split function ? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25202#a25202
07:02:21 <Jafet> You can have it cause an error, or use a nonempty list.
07:02:23 <ToRA> fax, pretending it doesn't exist could be done. just wondering whether it has a natural base case like and [] or or []
07:02:31 <quicksilver> bastl: http://hackage.haskell.org/package/split
07:03:11 <ToRA> *from2C [1,0] = -2
07:03:15 <bastl> hmm. Didnt expect that it is that obvious :-)
07:07:31 <benmachine> oh wow mod' is slow
07:07:35 <Saizan> bastl: ~/.cabal/config , see the install dirs sections
07:07:54 <Wooga> why may i have no `bracket' in System.IO ?
07:08:10 <Saizan> it's in Control.Exception
07:08:36 <Wooga> then why this guide showing it here: http://en.wikibooks.org/wiki/Haskell/Hierarchical_libraries/IO ?
07:08:42 <bastl> Saizan: thanks, found it already.
07:09:00 <edwardk> wooga: because it is a _wiki_book, ;)
07:09:50 <quicksilver> wiki stands for Wrong It Kommonly Is
07:10:07 <Wooga> oh
07:10:13 <xerox> haha
07:11:01 <edwardk> to be fair, bracket was originally defined in the non-hierarchical module 'IO', so they may have just assumed it moved to System.IO with most of its other content.
07:11:50 <gwern> {{sofixit}}
07:14:38 <bashrc_> alpounet: Couldn't match expected type `a -> a' against inferred type `Bool'
07:14:52 <bashrc_> alpounet: i don't get it. somethiong went wrong
07:15:14 <alpounet> bashrc_, can you paste your code on http://hpaste.org/ or any such pastebin site ?
07:15:40 <bashrc_> alpounet: sure, wait a second
07:17:49 <Saizan> if you give me a surjection from 2^N to 2^2^N i can prove false in agda.
07:18:17 <bashrc_> alpounet: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=25203#a25203
07:18:33 <opqdonut> Saizan: can you show me the code?-)
07:18:42 <alpounet> bashrc_, so
07:18:51 <alpounet> let's take a look again at the type i gave above
07:18:56 <alpounet> (Integer -> Bool -> Bool) -> Bool -> [Integer] -> Bool
07:19:09 <alpounet> the first argument to foldr
07:19:15 <alpounet> must be a function
07:19:17 <alpounet> taking *two* arguments
07:19:22 <alpounet> one which is an integer
07:19:25 <alpounet> and a bool
07:19:28 <alpounet> and give back a book
07:19:32 <alpounet> let's focus on this function for now
07:19:39 <alpounet> in your code
07:19:44 <alpounet> the fucntion you give only takes one argument
07:19:46 <alpounet> an integer
07:19:58 <Saizan> opqdonut: http://code.haskell.org/~Saizan/cantor/
07:20:04 <alpounet> you may have hard figuring out what the second bool represents
07:20:09 <edwardk> proving false in agda is the purpose of agda, it is the game of oneupsmanship that defines that community ;)
07:21:00 <alpounet> bashrc_, the bool argument to the function represents the result of "foldr"ing the rest of the list with that very same function
07:21:05 <alpounet> so, at some point in the list
07:21:08 <ManateeLazyCat> Function `doesFileExist` and `doesDirectoryExist` don't support unicode?
07:21:08 <alpounet> to have your result
07:21:16 <alpounet> either the current element is > 70
07:21:28 <alpounet> or one of the elements in the rest of the list will be
07:21:34 <Saizan> opqdonut: see CantorDiag, unless i'm wrong about the possibility of instantiating Y to 2^N and X to 2
07:21:38 <Jafet> edwardk, one-up them by proving that Agda is consistent!
07:22:14 * hackagebot toktok 0.5 -   http://hackage.haskell.org/package/toktok-0.5 (GregoireDetrez)
07:22:14 <alpounet> bashrc_, so, your function is a lambda of the form \x b -> ???
07:22:14 <alpounet> x being an integer
07:22:20 <alpounet> b being a bool representing the result on the rest of the list
07:22:24 <alpounet> now, fill in the "???"
07:22:29 <bashrc_> alpounet: so i have to use \x y -> if (x>70) then True else False ?
07:22:47 <edwardk> Jafet: a better and more frustrating proof would be an existential one. i.e. there exists a version of agda that has existed, which is consistent, but not prove that its the current one ;)
07:22:48 <alpounet> bashrc_, no
07:22:52 <alpounet> because you don't use the y here
07:22:58 <alpounet> whereas you *have to* use it
07:23:17 <alpounet> see :
07:23:18 <alpounet> <alpounet> either the current element is > 70
07:23:18 <alpounet> <alpounet> or one of the elements in the rest of the list will be
07:23:33 <Jafet> (Could you also then claim to have written the first metacircular evaluator?)
07:24:28 <alpounet> b (or y, but b is more adequate for a boolean) represents the result on the rest of the list, that is : b will be True if an element in the rest of the list is greater than 70, False otherwise. But you don't know it in advance, so you have to use b as-is
07:25:22 <ManateeLazyCat> I have use utf-8 directory test `doesDirectoryExist`, it return False. And same problem with utf-8 filename and `doesFileExist`.
07:25:28 <bashrc_> alpounet: i am thinking, but the problem i am thinking is, the y is the return value right? so i can only return y with true or false?
07:25:51 <edwardk> Jafet: well they have a proof (rather, an implementation) of coq in coq, it might be better to have a proof of incorrectness for a version of agda in agda.
07:26:35 <bashrc_> how about this: seventy mylist = foldr (\x y -> (x > 70)) then True else y) False mylist ?
07:26:54 <Jafet> You could try going for x -> True
07:26:57 <alpounet> bashrc_, you're missing an 'if' here
07:27:04 <alpounet> but anyway
07:27:12 <bastl> Can I configure the bindir of a cabalized project per executable ? I have CGIs and other scripts, that use a common library ...
07:27:14 <dolio> edwardk: It wouldn't be that surprising if the consistent version of Agda isn't the current one, since novel stuff keeps getting added. :)
07:27:18 <dmwit> seventy = any (>70) -- ?
07:27:28 <alpounet> bashrc_, what you wrote is equivalent to : x > 70 || y
07:27:50 <alpounet> which is a straight translation of "either the current element is > 70, or one of the elements in the rest of the list will be"
07:28:07 <bashrc_> seventy mylist = foldr (\x y -> if (x > 70) then True else y) False mylist
07:28:38 <dmwit> > (any (>70) [1..100], any (>70) [1..70])
07:28:39 <lambdabot>   (True,False)
07:28:55 <alpounet> > foldr (\x y -> if (x > 70) then True else y) False [1..100]
07:28:56 <lambdabot>   True
07:29:02 <bashrc_> seems like to work :) cool, thank you very much alpounet
07:29:06 <alpounet> > foldr (\x y -> if (x > 70) then True else y) False [1..70]
07:29:07 <lambdabot>   False
07:29:15 <edwardk> dolio: exactly =)
07:30:08 <dolio> The best proof of the inconsistency of Agda would probably be a proof of the consistency of Agda in Agda. Someone should work on that.
07:30:29 <dmwit> ?check liftM2 (==) (foldr (\x y -> if (x > 70) then True else y) False) (any (>70))
07:30:30 <lambdabot>   "OK, passed 500 tests."
07:30:43 <dmwit> ?check liftM2 (==) (foldr (\x y -> x > 70 || y) False) (any (>70))
07:30:44 <lambdabot>   "OK, passed 500 tests."
07:31:00 <bashrc_> alpounet: now i understand it, thanks to your explanation. it is pretty difficult to think the "haskell" way
07:31:30 <alpounet> bashrc_, heh, at the very beginning it definitely isn't that easy
07:32:08 <alpounet> but regarding folds you may want to take a look at : http://upload.wikimedia.org/wikipedia/en/thumb/3/3f/Fold-diagrams.svg/424px-Fold-diagrams.svg.png
07:32:21 <alpounet> (yi.org is down :( )
07:33:15 <edwardk> dolio: hah that is the right twist of circular reasoning i was looking for
07:34:28 <benmachine> yi.org worksforme
07:35:22 <ManateeLazyCat> doesDirectoryFile and doesFileExist don't support unicode, but GIO functions works fine.
07:41:33 * ManateeLazyCat Plan to use GIO functions replace all System.FilePath and System.Directory functions in my project.
07:42:13 <dolio> edwardk: Ah, so, implementing a lot of data structures using finger trees is about being able to split and join them at the right spot, assisted by the monoid.
07:42:34 <edwardk> dolio: exactly! =)
07:42:45 <dolio> That was part that I never really grokked. I was always trying to imagine what sort of monoid you would use that would automatically keep the elements in the right order.
07:43:16 <edwardk> thats why i like the priority queue example, which doesn't bother sorting the elements
07:44:31 <dcoutts_> http://blog.well-typed.com/2010/04/parallel-haskell-2-year-project-to-push-real-world-use/
07:44:37 <edwardk> the OrdSeq example is also interesting because while it works like a more traditional tree, the values in the nodes as you go up the tree are quite different
07:44:42 <quicksilver> edwardk: can a fingertree do 2D-nearest-neighbour lookup?
07:44:51 * quicksilver has a very poor intuition for what  a fingertree can do
07:45:23 <edwardk> quicksilver: hrmm. the trick would be finding the right monoid/encoding.
07:45:29 <ManateeLazyCat> dcoutts_: I plan to build gio branch, when Axel have much spare time, i will request him merge my patches.
07:45:43 <quicksilver> edwardk: yes. My gut says that 2D shouldn't be possible but 1D should
07:45:54 <quicksilver> edwardk: because a 2D position isn't a Monoid in a very expressive way.
07:46:01 <ManateeLazyCat> dcoutts_: Looks Axel don't want accept more patches now.
07:46:21 <edwardk> well, you could drop points into the tree, and compute a kd-tree as the monoid, but you'd want your monoid to contain the subtrees, preferably as fingertrees ;)
07:46:41 <edwardk> then you can do nearest neighbor lookup via the kd-tree
07:46:57 <quicksilver> hm
07:47:20 <edwardk> so while it _can_ do it, the question is should it be involved, because all you've really done is worsen your asymptotics i think
07:47:28 <ManateeLazyCat> dcoutts_: Because GIO functions is very import to me, and same functions in `System` can't support unicode well.
07:47:40 <quicksilver> edwardk: well I wanted sharing for better updates
07:48:03 <quicksilver> edwardk: but it's quite possible I didn't grok kd-trees very well.
07:49:03 <edwardk> quicksilver: one option for 2d nearest neighbor, use a space-filling curve based NN search.
07:50:28 <edwardk> so take your point, map it back to its 1d location in a hilbert curve, split the fingertree at that point, grab the node to your left and right, then play the distance games you can with space filling curves to say what is/are the window(s) of the curve that can be closer than that point, scan those parts of the fingertree by splitting.
07:50:43 <edwardk> now you're using the fingertree's strengths
07:51:10 <edwardk> but it is of course subject to the limitations of space-filling curve based NN match
07:51:32 <quicksilver> I had not heard of that.
07:51:44 <quicksilver> I know what a space-filling curve is, but I'd not heard of them being applied to NN calculation.
07:52:00 <quicksilver> (google is finding lots of papers on the subject)
07:52:01 <edwardk> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.27.9232 for example
07:52:04 <edwardk> yeah
07:52:23 <quicksilver> maybe an ordinary kd-tree is all I need
07:52:27 <edwardk> personally i prefer working with something with better guarantees, be it kd, etc.
07:52:45 <quicksilver> each time I try to read a proper description of a kd-tree algorithm I get turned off by the fiddly details
07:52:52 <quicksilver> especially attempts to rebalance after insertion
07:54:05 <edwardk> personally i rather like x-trees and the various r*-tree variants
07:54:07 <quicksilver> Hmm. Maybe I should just use a quadtree actually.
07:54:34 <edwardk> i used to use an octree of bsps for a lot of 3d graphics work to good effect
07:54:45 * quicksilver nods
07:54:56 <edwardk> subdivide until the bsp construction was trivial then build
07:55:08 <quicksilver> my application was two dimensional, and the natural properties would tend to lead to a fairly even space distribution
07:55:16 <quicksilver> so a simple quadtree should be fine actually.
07:55:19 <edwardk> *nods*
07:55:36 <quicksilver> except...
07:55:44 <quicksilver> damn I'm sure I thought this through properly once before.
07:55:56 <edwardk> so what is your problem?
07:56:02 <quicksilver> quadtrees have poor nearest neighbour behaviour near the creases, don't they?
07:56:09 <bastl> wasn't there a way to get haddock comments into the synopsis ??
07:56:17 <edwardk> and what keeps you from just doing a voronoi tesslation and walking through it somehow?
07:57:07 <edwardk> bastl: iirc you can throw comments at the top of the module, in the list of exports, and in the body before each commentable declaration
07:57:13 <edwardk> (or after to be pedantic)
07:57:34 <quicksilver> edwardk: points can move, and it's expensive to re-compute the tesselation?
07:57:40 <quicksilver> edwardk: (I'm not sure... I think that was why)
07:58:03 <edwardk> its not that expensive to remove and reintroduce a point in a voronoi diagram/delaunay triangulation.
07:58:22 <edwardk> the effects are basically local edge flipping
07:58:40 <quicksilver> OK. that's probably what I want then.
07:58:44 <quicksilver> Thanks.
07:58:47 <edwardk> np
07:58:54 <quicksilver> (How do you know everything about algorithms in the world?)
07:59:11 <edwardk> practice ;)
07:59:34 <edwardk> that and this fell into computational geometry which is my old stomping ground before i discovered haskell ;)
08:00:09 <alpounet> any reference book for computational geometry by the way ?
08:00:13 <edwardk> yes
08:00:24 <bastl> hmm. I want a one-line api-comment for each exported function.
08:00:39 <edwardk> http://maven.smith.edu/~orourke/books/discrete.html is hands down the best book out there in this space
08:00:40 <alpounet> bastl,
08:00:47 <edwardk> its also enormous
08:00:49 <alpounet> -- | Here is a comment about foo
08:00:53 <alpounet> foo a b = ...
08:01:15 <bastl> but in the list of exports at the module-declaration ?
08:01:16 <edwardk> but if you want to know pretty much the asymptotics of anything even remotely related to computational geometry, it is the definitive place to go
08:02:00 <bastl> javadoc takes the first sentence for the TOC of a class-reference
08:02:26 <edwardk> nicely they grabbed experts in each subfield of discrete and computational geometry and had them each write a chapter summarizing the state of their field with a huge emphasis on what are the proven upper and lower bounds on the asymptotics of each operation
08:03:04 <edwardk> http://books.google.com/books?id=QS6vnl8WlnQC&lpg=PP1&dq=handbook%20of%20discrete%20and%20computational%20geometry&pg=PA533#v=onepage&q&f=false
08:03:06 <alpounet> bastl, i don't remember, but if you see a package that shows what you want, you can just take a look at its source file
08:03:28 <edwardk> skim through the google book summary ;)
08:03:55 <bastl> a had a vague remembrance, probably false :-)
08:04:13 <alpounet> edwardk, thanks
08:04:16 <alpounet> looks interesting
08:04:44 <pchiusano> hello
08:04:45 <edwardk> a thousand+ pages of # of substructures in arrangements of n lines in a plane for m faces is big Theta(m^(2/3)n^(2/3) + m + n)....
08:05:06 <pchiusano> random question - is there something magical about :> as a constructor name?
08:05:29 <pchiusano> like, ghc does not complain about data Foo a = Nil | a :> (Foo a)
08:05:44 <edwardk> pchiusano: the :
08:05:47 <pchiusano> but if I use ++++ as the ctor
08:05:54 <edwardk> pchiusano: TypeOperators are allowed to start with :
08:06:08 <edwardk> it is a generalization of : being the only infix type
08:06:15 <edwardk> (by default)
08:06:21 <quicksilver> infix data constructors are required to start with :
08:06:23 <pchiusano> ahhhh
08:06:23 <edwardk> ghc just added an extension to allow user defined type operators
08:06:36 <edwardk> just added as in simply, not recently ;)
08:06:47 <quicksilver> I din't think this is what we call a 'type operator'
08:06:54 <quicksilver> that's an infix *type* constructor isn't it?
08:06:56 <edwardk> infix data constructor
08:07:14 <quicksilver> data a ~> b = MagicArrow (a -> b)
08:07:14 <edwardk> i use it for infix type constructor as well
08:07:15 <edwardk> yeah
08:07:20 <alpounet> infix type constructor would be something like : type a :> b = (a, b)
08:07:23 <quicksilver> that ~> is a type operator
08:07:51 <edwardk> pchiusano: going through the slides from last night?
08:08:07 <pchiusano> edwardk: okay, cool, thanks - i was looking through your finger tree slides - wasn't able to make it last night but looks like it was a cool talk
08:08:09 <zygoloid> alpounet: that's an infix type synonym, not really an infix type constructor :)
08:09:01 <jmcarthur> the use of finger trees i am most proud of was in an algorithm to find anagrams. i should dig that up and blog it
08:09:03 <alpounet> yeah
08:09:26 <pchiusano> edwardk: ya :)
08:09:53 <jmcarthur> it wasn't the most efficient possible algorithm, but considering i didn't know any anagram algorithms and i invented it i liked how it turned out
08:11:15 <pchiusano> edwardk: I might be interested in giving a talk at next Haskell meeting, presenting an alternate abstract machine for a non-strict language, with more predictable strictness analysis
08:11:23 <pchiusano> if I can get my act together...
08:11:56 <pchiusano> edwardk: it is very experimental, might actually be a silly idea, but I thought it could be interesting for the group
08:13:03 <edwardk> pchiusano: sold =)
08:13:25 <edwardk> pchiusano: i think nirav also wants to give a talk next time, so if you split the time between you i think it'll be a good session
08:13:47 <Apocalisp> What would nirav's talk be about?
08:14:00 <jmcarthur> the element type of words, and the monoid was a bitset representing letters in the words. i ordered the words such that i could pick a word with an 'e' in it and then split the finger tree at the point that there are no more 'e's, etc. sometimes you had to "rake" the fingertree a bit to make sure you got all the words containing some letter out. it was kind of ad hoc, but it was surprisingly efficient
08:14:01 <jmcarthur>  if you arranged the words to minimize the impact of the raking
08:14:54 <edwardk> pchiusano: i'm going to set up the straw polls for choosing the day of the week and all that soon, i'd like to give folks more notice than they've been getting
08:15:25 <edwardk> Apocalisp: he mentioned at the end of the meeting kind of loosely but i was a bit distracted and didn't catch all the details
08:15:30 <pchiusano> edwardk: you mean you want to give more than the 2 days that ravi would typically give?? :)
08:15:36 <edwardk> pchiusano: yeah
08:16:31 <jmcarthur> i forget why i didn't just use a trie. i think there was some other constraint (it was a little competition)
08:17:05 <edwardk> jmcarthur: ooh nice
08:17:26 <edwardk> jmcarthur: yeah, a trie would be what i would usually expect in that case
08:18:04 <jmcarthur> i probably still have the code. maybe i documented why i didn't use a trie
08:18:19 <dons> upmods plz http://www.reddit.com/r/programming/comments/bxvmx/msr_funding_a_2year_project_to_mature_parallel/ :) !
08:18:30 * dons loves investments in the toolchain
08:18:40 <edwardk> pchiusano: did apocalisp mention that you can of course in whatever scala implementation i'm sure you guys will generate as a consequence of this meeting, that you can of course just substitute 'Reducer x y ' for 'Measured y x'
08:19:03 <byorgey> dons: awesome!
08:19:12 <byorgey> dons: btw, I finally got a copy of RWH, it just arrived =)
08:19:15 <edwardk> dons: nice!
08:19:29 <Apocalisp> edwardk: I had not mentioned it, but I'm already replacing Measured with Reducer in my FingerTree impl.
08:19:31 <byorgey> I'll be using it to teach a half-credit Haskell course for undergrads in the fall
08:19:42 <pchiusano> edwardk: no, but I remember Apocalisp and I figured that out independently a while ago
08:19:53 <quicksilver> jmcarthur: you probably wrote -- tries don't work, so we do this:
08:19:53 <Apocalisp> pchiusano: I don't recall that :)
08:20:00 <quicksilver> jmcarthur: so we'll never recover that train of thought
08:20:13 <jmcarthur> quicksilver: you're probably right :(
08:20:28 <pchiusano> Apocalisp: you don't?? Okay maybe I figured that out and forgot to tell you :)
08:20:30 <dcoutts_> g'morning dons :-)
08:21:02 <ManateeL`> I have build "http://patch-tag.com/r/AndyStewart/gio-branch/home", any patches are welcome, i will merge my branch to gtk2hs when Axel have much spare time.
08:21:12 <edwardk> byorgey: nice!
08:21:22 <pchiusano> I remember looking at finger tree Measured and thinking - that's a reducer, and I could have sworn you were there...
08:21:32 <byorgey> I've been talking it up so there are already like 15 students signed up
08:21:37 <byorgey> they won't know what hit them =)
08:21:51 <edwardk> pchiusano: you start seeing them everywhere after a while, its a mild form of madness
08:21:59 <Apocalisp> pchiusano: Yeah, I'll have to get better at reading your thoughts.
08:22:10 <pchiusano> Apocalisp: you were there in spirit :)
08:22:20 <quicksilver> edwardk: "mild" ? ;)
08:22:29 <pchiusano> edwardk: I believe we have actually taken them one step further...
08:22:39 <Apocalisp> quicksilver: As in mildly pleasant
08:22:50 <edwardk> quicksilver: yeah, when you start seeing right seminearrings everywhere, then you know you've gone off the deep bend
08:22:56 <edwardk> or so my wife reliably informs me
08:23:07 <jmcarthur> edwardk: oh i remember. tries would only work if you are looking for anagrams made up of only one word. i was generating phrases
08:23:33 <dcoutts_> ManateeL`: I don't see Axel refusing your patches, in the emails I've seen he's making suggestions for you to improve them so that he can apply them
08:23:40 <edwardk> jmcarthur: ah nice
08:23:45 <jmcarthur> edwardk: so i could pick a word from the finger tree and then prune out all the words that share letters with it efficiently
08:23:50 <jmcarthur> then pick another
08:23:53 <ManateeL`> dcoutts_: I think Axel haven't time do that.
08:24:03 <Apocalisp> edwardk: Oh yeah, pchiusano and I have a monad for chaining reducers into multiple passes over a data structure.
08:24:21 <Apocalisp> I was going to mention that
08:24:38 <edwardk> how so?
08:24:43 <ManateeL`> dcoutts_: No, i mean branch for news APIs. not cabal package.
08:25:26 <dcoutts_> ManateeL`: is there a need for a new branch? the problem is getting the patches into a fit state for the mainline isn't it?
08:25:36 <ManateeL`> dcoutts_: Because Axel want release gtk2hs next version as quick as possible, and haven't time add new GIO functions before release.
08:26:16 <jmcarthur> there is apparently an algorithm for anagram phrases that works with tries, but i don't know much about it
08:26:17 <dcoutts_> ManateeL`: ok, so we wait, that's ok. You've got your own public darcs repo with the patches.
08:26:37 <ManateeL`> dcoutts_: So we haven't more time review/test GIO functions before release.
08:26:43 <edwardk> Apocalisp: trying to figureout how the multiple passes work
08:26:49 <quicksilver> dcoutts_: good luck with the parallel stuff. Excited to see how it goes.
08:26:52 <pchiusano> edwardk: you need Generator
08:26:55 <dcoutts_> quicksilver: :-)
08:27:02 <ManateeL`> dcoutts_: So i want add GIO functions in my public repo, when Axel have time, i will merge to gtk2hs main repo.
08:27:13 <dcoutts_> ManateeL`: sounds like a sensible plan
08:27:31 <edwardk> pchiusano: with you so far, so are you just running multiple monoids over the same generator at separate occasions with the generating being held on to by the monoid as a context or reader?
08:27:52 <edwardk> er with the generator being held on to by the monad as a state or environment
08:27:57 <edwardk> wow that got mangled
08:27:58 <pchiusano> edwardk: basically, this multi-pass contains one or more reducers - when you apply it to an Generator f => f a, it can make multiple passes over that f a
08:28:20 <ManateeL`> dcoutts_: I'm make Axel crazy, so i build new public repo and test gio functions in my project. When Axel have much spare time, i will send request let him check my new functions, i just want save Axel's time now. :)
08:28:32 <edwardk> isn't it better to do all your traversals at once if possible?
08:28:48 <edwardk> i.e. reduce a with the product monoid?
08:28:49 <pchiusano> edwardk: yes, and you can do that by zipping your passes
08:29:03 <pchiusano> edwardk: but there are cases where you have an actual dependency
08:29:06 <edwardk> yeah
08:29:10 <pchiusano> as in monadic bind
08:29:15 <edwardk> i buy that
08:29:21 <pchiusano> like a reducer a m, and a m => reducer a m2
08:29:40 <edwardk> so your monad is just a reader monad with the generator as the environment and then it just reduces the environment?
08:29:50 <pchiusano> a good example is something like computing variance
08:30:05 <pchiusano> first pass computes the mean, second pass the variance
08:30:30 <edwardk> Sum s <- asks reduce; (Count c, Max c) <- asks reduce
08:30:34 <edwardk> yeah
08:30:38 <Jengax> Hi
08:30:41 <Apocalisp> edwardk: So Reducer is a monoid m with unit (a -> m). We added counit (m -> b) and captured as (Linker a b) hiding the monoid.
08:30:55 <edwardk> well
08:31:00 <edwardk> you don't need two passes for mean and variance
08:31:06 <edwardk> you compute the first two moments
08:31:12 <edwardk> and then derive mean and variance from that ;)
08:31:29 <byorgey> hi Jengax
08:31:38 <pchiusano> edwardk: damn, I did not know that
08:31:45 <pchiusano> edwardk: link?
08:31:48 <edwardk> given the sums of the xs and the sums of squares you have everything you need (and a count)
08:32:54 <edwardk> google "moment around zero"
08:34:01 <edwardk> you can go back and forth between moments around zero and 'central moments' variance is the second 'central moment' which can be reconstructed from the first two 'moments around zero'
08:35:04 <pchiusano> edwardk: is a moment different from 'moment around zero'
08:35:21 <edwardk> a central moment is defined with respect to the mean
08:35:31 <edwardk> a moment around zero is defined around, well, 0 ;)
08:36:04 <edwardk> i have some statistics monoids lying around here somewhere for computing mean, variance, skew, kurtosis, etc.
08:36:28 <pchiusano> edwardk: I see
08:36:34 <pchiusano> edwardk: I would love to see those
08:36:46 <edwardk> a good starting point would be http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance
08:36:50 * hackagebot hpage 0.7.1 - A scrapbook for Haskell developers  http://hackage.haskell.org/package/hpage-0.7.1 (FernandoBenavides)
08:37:02 <edwardk> the most important piece is Chan et al's parallel algorithm
08:37:10 <edwardk> which you can see is readily converted into a monoid
08:37:15 <gwern> huh. amazon now has a cloud datacenter in singapore
08:37:33 <edwardk> Terriberry's extension of Chan's formula to higher moments gives you skew and kurtosis, etc.
08:38:26 <gwern> terriberry? now you're just having us on
08:38:39 <edwardk> http://people.xiph.org/~tterribe/notes/homs.html
08:38:41 <edwardk> ;)
08:39:46 <zygoloid> T.B.Terriberry?
08:39:52 <pchiusano> edwardk: awesome
08:40:14 <edwardk> the more redundant code i can remove from the world the better ;)
08:40:24 * zygoloid just hopes the T.B. stands for Terry Berry
08:40:30 <quicksilver> hmm. that hpage or \page think looks interesting.
08:40:34 <edwardk> zygoloid: haahahaha
08:40:44 <edwardk> sadly it is timothy
08:40:48 <quicksilver> although I don't entirely understand what is.
08:40:53 <zygoloid> timothy bimothy terriberry?
08:40:58 <quicksilver> lais. The T B stands for Tastes Brilliant
08:41:18 <dantheman_> Hey all, I'm trying to upgrade my darcs version using cabal (i.e. cabal upgrade darcs). However it keeps failing with the following error message 'Could not find module GHC.IO.Exception'.  I can't seem to find this file anywhere (ghc 6.10.4 ). The full message is at http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=25206#a25206. Has anyone run into this before?
08:41:42 <gwern> zygoloid: almost as good as Major Major Major
08:41:47 <dcoutts_> dantheman_: try cabal install darcs instead, it doesn't upgrade all the core packages
08:42:13 * dcoutts_ should disable cabal upgrade completely
08:42:14 <dantheman_> thanks dcoutts. I'll try that
08:42:29 <zygoloid> gwern: Ed McBain?
08:42:45 <edwardk> dcoutts_: failed experiment?
08:42:48 <dcoutts_> dantheman_: if that still fails, you should look with ghc-pkg to see if you've already accidentally installed later versions of core packages
08:42:58 <gwern> zygoloid: I know no ed mcbain
08:43:05 <dcoutts_> edwardk: it doesn't do what people expect
08:43:06 <zygoloid> hm, that's Detective Meyer Meyer innit
08:43:24 <dantheman_> dcoutts, what would be the best way to go about reverting them if I have/
08:43:25 <dantheman_> ?
08:43:41 <dcoutts_> ghc-pkg --user unregister $thepkg
08:43:57 <quicksilver> edwardk: it's not capable of recognising which packages would be a Really Bad Idea to upgrade
08:44:04 <edwardk> dcoutts: if you had a blank slate what upgrade do differently?
08:44:12 <dcoutts_> edwardk: people think "upgrade, yes I want to upgrade program X" but "install" installs the latest version too, what upgrade means is "try to install the latest version of all dependencies"
08:44:12 <edwardk> quicksilver: ?
08:44:23 <edwardk> ah
08:44:35 <dcoutts_> edwardk: I'm considering eliminating it and adding a flag to install --upgrade-deps
08:44:54 <dcoutts_> suggestion for the ideally named flag welcome :-)
08:45:08 <dantheman_> dcoutts, well it definitely fooled me! Sounds like a good idea.
08:45:15 <edwardk> dcoutts_: like the idea, i agree the name of the flag is a little ugly
08:45:44 <dcoutts_> edwardk: good, like I said, if you can think of a better one that'd be excellent
08:46:10 <dcoutts_> edwardk: would probably be good to consult prior art from distros
08:46:22 <edwardk> nah, just comiserating ;) 'dependencies' is ugly coz its long, but ad hoc abbreviations make flags harder to remember
08:46:47 <dcoutts_> edwardk: we can add both! :-)
08:46:56 <edwardk> now you're talking ;)
08:47:06 <dcoutts_> edwardk: seriously, make --help show the long one but accept the short one too
08:47:18 <dcoutts_> we already accept unique prefixes
08:48:07 <quicksilver> accepting unique prefixes is a two-edged sword
08:48:14 <edwardk> not a bad idea
08:48:20 <quicksilver> my muscle memory has :b for :browse hardwired for ghci
08:48:23 <dcoutts_> quicksilver: I know, but it's the default behaviour of GetOpt
08:48:30 <quicksilver> and when they added :breakpoint or something it broke
08:48:38 <dcoutts_> quicksilver: arg, yes, that one annoyed me too!
08:48:49 <dcoutts_> edwardk: so gentoo's emerge tool uses --update --deep for the same purpose
08:49:09 * quicksilver ponders --recursive / -R
08:49:30 <edwardk> hrmm, i wonder if unique prefixes is the better answer, or if 'first prefix found' would be a nicer heuristic in general, that way existing scripts wuld never break unless the exact text of a previous abbreviation was added as a new flag
08:49:43 <edwardk> not an option for existing code, but just thinking in general about it
08:49:57 <jmcarthur> a lot of people advocate using your package manager to, well, manage haskell packages. my problem with that is that many package managers don't make it very convenient to have more than one version of a library installed at once without unique package names
08:49:59 <edwardk> cabal install --deep ?
08:50:16 <edwardk> jmcarthur: ahh good point
08:50:22 <dcoutts_> edwardk: cabal always does --deep
08:50:44 <edwardk> yeah i suppose the name is kinda useless ;)
08:50:53 <dcoutts_> edwardk: it does not have a mode to say "never reinstall any packages"
08:51:34 <BMeph> dcoutts_: cabal install --pkg-upgrade
08:51:39 <BMeph> ?
08:51:52 <jmcarthur> like, i have my package manager set up to sync hackage packages, but it will still fail on many things. for example, if A depends on parsec 2 then i can't install parsec 3 through the package manager :(
08:52:07 <dcoutts_> BMeph: the point to get across to users is that the option only affects what we do for the dependencies of the target you've asked for
08:54:01 <quicksilver> jmcarthur: surely the correct answer to that is to include the versionnumber in the name
08:54:13 <quicksilver> jmcarthur: (as far as your package manager treats it)
08:54:26 <quicksilver> that's the way dkpg has handled multiple versions at once since the stone age and it seems OK to me.
08:54:47 <jmcarthur> quicksilver: yeah, that would work for manually created packages
08:55:05 <quicksilver> I don't see why that technique would not be automatically applicable
08:55:07 <jmcarthur> quicksilver: but the tool i use just relies on cabal2arch and installs directly from hackage
08:55:08 <quicksilver> if you chose to apply it :)
08:55:24 <quicksilver> sounds like cabal2arch is broken then...
08:55:28 <quicksilver> but the fix should be simple.
08:55:32 <edwardk> dcoutts: i like --upgrade-dependencies with --upgrade-deps as a silent alias
08:55:34 <jmcarthur> perhaps cabal2arch could be updated to append major version numbers to package names
08:55:58 <quicksilver> exactly.
08:56:16 * jmcarthur considers it
08:56:50 <dcoutts_> edwardk: thanks for your vote :-)
08:56:53 <edwardk> jmcarthur: major? or the major.minor so that you comply with the PVP that incompatible changes are reflected in those two digits?
08:57:10 <jmcarthur> edwardk: i think hackage policy refers to the first two numbers as major
08:57:17 <edwardk> ah
08:57:29 <edwardk> ok, then we're in wordy agreement ;)
08:58:09 <jmcarthur> dons: what do you think of the above idea? have cabal2arch append major version numbers to package names so that multiple major versions can be installed at once
09:00:09 <jmcarthur> at least for libraries
09:08:58 <edwardk> Apocalisp: what laws can you assume about unit and counit?
09:09:43 <edwardk> Apocalisp: so in haskell terms you'd have something like data Linker a b = forall m. Monoid m => Linker (a -> m) (m -> b) -- ?
09:12:02 <edwardk> or would it be more like: class (a `Reducer` Link a b)  (b `Coreducer` Link a b) => Linker a b where type Link a b :: * -- with Coreducer providing counit ?
09:12:20 <edwardk> er s/)   (/,/
09:13:32 <Apocalisp> edwardk: Hmmm, interesting idea. :)
09:15:50 <dantheman_> Hey all, I'm now having a problem installing regex-base (the latest version), which I need to install the latest version of darcs. It fails at the configure step (see http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25207#a25207), but the message it gives is pretty uninformative (to me anyway). Any ideas?
09:16:07 <Apocalisp> edwardk: What we have is more like: class (Generator f) => Linker a b where fold :: f a -> (b -> c) -> c
09:16:12 <dantheman_> ghc-6.10.4 on Windows btw
09:16:38 <quicksilver> dantheman_: that message means it is simultaneously linking against old-time-1.0.0.4 and old-time-1.0.0.2
09:16:50 <quicksilver> so you have some packages compiled against the one and some against the other.
09:16:51 <quicksilver> I think.
09:17:20 <dantheman_> ah, ok. Any suggestions for how to find out which, and how to go about going removing one?
09:17:20 <quicksilver> you appear to have base-3 and base-4 installed at the same time
09:17:25 <quicksilver> I'm not sure if that's a good plan
09:17:59 <quicksilver> you need a cabal expert now :(
09:18:07 <dcoutts_> @arr!
09:18:07 <lambdabot> I'll keel haul ya fer that!
09:18:14 <Apocalisp> edwardk: And then smart constructor single :: Reducer a m -> (m -> b) -> Linker a b,
09:18:16 <dantheman_> ha.
09:18:24 <quicksilver> dantheman_: quick. There he is. grab him before he runs away.
09:18:41 <dantheman_> haha.
09:18:52 <dantheman_> * virtual grab *
09:18:57 <quicksilver> dcoutts_: does dantheman_ have two base versions installed? looks ugly to me
09:19:04 * dcoutts_ wanders off to get some tea
09:19:27 <Apocalisp> edwardk: We actually subvert the Scala type system internally to be able to hide the monoid (avoiding a HList of monoids)
09:19:48 <edwardk> Apocalisp: so the linker depends on the generator?
09:20:04 <dantheman_> well my haskell platform folder has subfolders for base-3.0.3.1 and base-4.1.0.0
09:20:26 <edwardk> or just a, m, and b?
09:20:33 <edwardk> and is polymorphic in the generator?
09:21:06 <Apocalisp> edwardk: Actually, that was a little wrong.
09:21:15 <Saizan> dantheman_, quicksilver: it seems it's linking in two versions of old-time at once
09:21:27 <Apocalisp> More like ... class Linker a b where fold :: (Generator f) => f a -> (b -> c) -> c
09:21:28 <siracusa> quicksilver: I thought GHC ships with both, base 3 and 4!?
09:21:37 <Saizan> dantheman_: when building setup.exe !
09:21:47 <edwardk> Apocalisp: ahhh
09:21:52 <edwardk> that makes perfect sense
09:22:00 <Apocalisp> It does? Yay!
09:22:04 <dantheman_> Ah. Is there anyway I can stop it doing that  Saizan?
09:22:53 <quicksilver> Saizan: yes, I thought that
09:22:57 <quicksilver> Saizan: but I couldn't see why
09:23:15 <quicksilver> Saizan: (it must be pulling them in via different libraries; what does Setup.exe depend on?)
09:23:21 <edwardk> isn't the cps redundant?
09:23:21 <Saizan> quicksilver: probably the older is the one Cabal is linked against, and the other is the latest
09:23:39 <Apocalisp> edwardk: So yeah, you can see how (Linker a) is a monad, and >>= makes a linker that passes over F twice with two reducers.
09:23:41 <edwardk> i.e. an equivalent but simpler 'fold :: Generator f => f a -> b'
09:24:10 <Saizan> dantheman_: "ghc-pkg hide old-time-1.0.0.4" could be a way
09:24:52 <edwardk> data Linker a b = Linker (forall f. Generator f => f a -> b) -- instance Monad Linker a) where ...
09:25:12 <dcoutts_> dantheman_: so sounds like you've got local packages linked against inconsistent versions of stuff
09:25:34 <dcoutts_> dantheman_: the solution will be to unregister the extra local versions, stick with the global ones that came with ghc
09:25:36 <edwardk> now Linker a can be a monad ;)
09:25:54 <dcoutts_> dantheman_: and then rebuild broken stuff
09:25:54 <edwardk> which goes back to my earlier observation
09:26:01 <dantheman_> how do I know which are the locals?
09:26:07 <Apocalisp> edwardk: Yes, it totally is reduntant.
09:26:08 <edwardk> that your ' Linker a' monad is equivalent to Reader (f a)
09:26:22 <edwardk> where f is a generator
09:26:28 <dcoutts_> dantheman_: ghc-pkg list, look for the same packages in the global and local sections
09:26:39 <dantheman_> ah ok, thanks!
09:26:44 <Saizan> regex-base-0.93.1 could use a build-type: Simple btw
09:27:07 <edwardk> just trying to see what is fundamental to the idea, and what is tangential
09:27:16 <Apocalisp> edwardk: Oh wait, so the result of each "pass" is Either b (Linker a b)
09:27:42 <edwardk> just for efficiency?
09:28:10 <Apocalisp> and the (b -> c) is provided so that the following pass can be Either c (Linker a c)
09:28:25 <edwardk> but you can fmap ;)
09:28:31 <Apocalisp> yeah, truth
09:29:02 * Apocalisp tells pchiusano to simplify since he's in that code right now
09:29:09 <edwardk> and if you want the knowledge of whether or not the function is constant you can cheat a bit, and defunctionalize the arrow slightly.
09:29:26 <edwardk> data a :-> b = K b | F (a -> b)
09:29:30 * mux is really in awe before the genius of the datatype definition for 2-3 trees that enforces the structural constraint that all leaves are at the same level
09:29:43 <pchiusano> sorry, was not following... going back
09:30:16 <pchiusano> was busy finding an important wedding singer clip
09:30:20 <pchiusano> :)
09:30:25 <Apocalisp> edwardk: I don't follow that last part
09:31:02 <edwardk> Apocalisp: well, the observation was that the Either c (Linker a c) is equivalent to redefining Linker slightly
09:31:26 <edwardk> data Linker a b = Linker (forall f. Generator f => f a :-> b)
09:32:26 <Apocalisp> OK yeah, I follow that. Thanks :)
09:32:49 <edwardk> but you only need that if you ever actually care that your function could be constant.
09:32:58 <edwardk> it matters for things like functional reactive programming
09:33:07 <edwardk> but in haskell it mostly just gets in the way ;)
09:33:16 <edwardk> er in day-to-day haskell
09:33:46 <pchiusano> Apocalisp: I am confused, the signature of Link.fold is already fold :: f a -> b
09:34:45 <benmachine> I wonder if I could install GHC in WINE
09:35:25 <Apocalisp> pchiusano: fold[F[_],C](a: F[A], f: B => C)(implicit g: Generator[F]): C
09:35:44 <pchiusano> Apocalisp: ah, okay, nm, I thought you were referring to apply
09:40:50 <XniX23> im having a problem following lyah tutorial, the code looks like ->   lucky :: (Integral a) => a -> String
09:41:07 <XniX23> but when i write this in ghci i get some error
09:41:41 <gwern> XniX23: the ghci prompt is more like the do monad than a source file
09:41:47 <dantheman_> Hey again dcoutts et al. I don't seem to have any packages intalled locally (in the user database). However I do have to versions of old-time installed in the database (see http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25210#a25210 ). Any suggestions as to which I should remove? I get warnings about dependencies when I try to remove either.
09:42:01 <bastl> I have a number of different versions of a package under my .cabal. How can I switch back to an older version of an executable ?
09:42:08 <gwern> XniX23: you would be better writing a file, and then loading it into ghci
09:42:22 <gwern> bastl: I think cabal just overwrites any existing binaries doesn't it?
09:42:31 <bastl> gwern: that's the point
09:42:43 <gwern> bastl: so... reinstall the old version?
09:42:45 <dcoutts_> bastl: sadly at the moment the exes overwrite each other in the ~/.cabla/bin dir. I suggest you adjust your ~/.cabal/config in the following way...
09:42:57 <XniX23> gwern: oh i see, could you tell me how to load from file? i didnt see that in the tutorial so far
09:43:07 <gwern> XniX23: well, 'ghci foo.hs' works
09:43:19 <XniX23> gwern: ty very much
09:43:20 <gwern> XniX23: and then if you'er editing the file somewhere else, you can ':reload' in ghci
09:43:43 <XniX23> gwern: so i can load only 1 file?
09:44:01 <gwern> XniX23: you can load multiple files as long as they don't clash I think
09:44:32 <XniX23> gwern: so when i do :reload` then it will reload all of them or the last one?
09:44:48 <gwern> XniX23: dunno. try it and see
09:44:51 <bastl> dcoutts: the following way?
09:44:59 <gwern> (it would probably load any file which has a changed mod-time)
09:45:00 <dcoutts_> bastl: set the program-suffix to be -$version, then set the symlink-bindir dir to be ~/bin/ or something like that that's on your $PATH
09:45:11 <bastl> ah :-)
09:45:11 <XniX23> gwern: ty again ^^
09:45:29 <gwern> dcoutts_: is program-suffix a new field in .cabal/config?
09:45:31 <dcoutts_> bastl: I think that the symlink-bindir will not use the program-suffix, but I'm not 100% sure. You can experiment and let me know :-)
09:45:38 <dcoutts_> gwern: not very new
09:45:46 <bastl> ill try it out
09:46:01 <Saizan> dantheman_: did you reinstall Cabal? and does "ghc-pkg check" say anything?
09:46:03 <gwern> dcoutts_: new to me, then
09:46:04 <dcoutts_> bastl: this may be the sensible default configuration, so yes it'd be useful to know if it works already with just adjusting the config.
09:46:29 <Apocalisp> edwardk: One of the things I like least about Linker is that in order to lift Linker a b -> Linker (g a) (g b), we need to sort of "unbind" it.
09:47:15 <dcoutts_> gwern: configure flags since Cabal 1.4
09:47:18 <Apocalisp> i.e. we need to lift the leftmost Reducer in the chain.
09:47:32 <pchiusano> Apocalisp: what is wrong with that? :)
09:47:36 <edwardk> thinking about that
09:47:50 <pchiusano> the problem is that Linker has lost type info on what the monoid is
09:47:58 <Apocalisp> pchiusano: What's wrong with it is that it's difficult to type in Scala.
09:48:00 <gwern> @wn borage
09:48:02 <lambdabot> *** "borage" wn "WordNet (r) 2.0"
09:48:02 <lambdabot> borage
09:48:02 <lambdabot>      n 1: hairy blue-flowered European annual herb long used in herbal
09:48:02 <lambdabot>           medicine and eaten raw as salad greens or cooked like
09:48:02 <lambdabot>           spinach [syn: {tailwort}, {Borago officinalis}]
09:48:03 <bastl> dcoutts: no problem
09:48:04 <lambdabot>      2: leaves flavor sauces and punches; young leaves eaten in
09:48:05 <dcoutts_> gwern: like the bindir etc it can use the $version or $os / $arch vars, eg if you have NFS homedirs with different arch machines
09:48:06 <lambdabot>         salads or cooked
09:48:09 <bastl> works well
09:48:23 <pchiusano> Apocalisp: I think Haskell would be the same
09:48:27 <dantheman_> hey saizan, ghc-pkg check doesn't say anything. I'll try and reinstall caball now
09:48:32 <gwern> dcoutts_: interesting. maybe cabal should do that by default and create a symlink from the non-modified name
09:48:36 <Saizan> dantheman_: no, wait
09:48:36 <dcoutts_> bastl: so the prefix/suffix is not used in the symlink right? and it points correctly to the versioned on in the ~/.cabal/bin ?
09:48:46 <gwern> dcoutts_: and every install repoint the symlink to the newly installed binary
09:48:48 <dcoutts_> gwern: yes, I think that would be sensible
09:48:49 <pchiusano> personally I don't think it matters, since the unbinding is just an implementation detail
09:48:58 <Saizan> dantheman_: reinstalling Cabal-1.6.0.3 is what could have caused this breakage
09:49:06 <dantheman_> uh oh... too late!
09:49:19 <edwardk> Apocalisp: thinking about your linker problem in other terms
09:49:23 <Apocalisp> pchiusano, edwardk: I think the only way to not lose the monoid type for the unbind is to track the chain of monoids in HList.
09:49:26 <dcoutts_> gwern: yes it should do that automatically already, it's probably a matter of adjusting the config. Though we do have an issue with the $PATH still, not everyone has ~/bin on the $PATH.
09:49:32 <pchiusano> I have no problems doing non-typesafe things internally as long as the public api is safe :)
09:49:37 <edwardk> that is one way, but the question is if that is necessary
09:49:48 <Apocalisp> edwardk: Other terms are good. I'm not convinced that it's necessary.
09:49:53 <dcoutts_> gwern: http://hackage.haskell.org/trac/hackage/ticket/289
09:49:59 <gwern> dcoutts_: no, but this symlink thing is useful no matter where you're installing to
09:50:00 <dcoutts_> gwern: comments welcome
09:50:04 <gwern> dcoutts_: if you're installing at all...
09:50:06 <edwardk> or if you can further generalize Linker to intrinsically support lifting
09:50:13 <bastl> dcoutts: oh wait, i hadnt changed symlink-bindir
09:50:35 <dcoutts_> gwern: true, even if you're using the symlink bindir the same as the bindir
09:50:46 <Apocalisp> edwardk: It feels like it should be possible to support lifting without unwinding the binds. But this is only a vague instinct on my part.
09:50:54 <gwern> dcoutts_: so I don't think that request is the same as what I;m saying
09:51:05 <pchiusano> "Sometimes you encounter a problem and think 'I know, I'll use HLists'. Now you have two problems."
09:51:09 <edwardk> a derivation from Linker a b => Linker (f a) (f b) -- doesn't appear to be canonical. it relies on some properties of f beyond just, say, f being a functor.
09:51:25 <gwern> @quote hlist
09:51:25 <lambdabot> <JohnMeacham> says: of course any minute now oleg is going to come along and actually express the second law of thermodynamics via functional dependencies as a purely incidental part of improving
09:51:25 <lambdabot> HList syntax or something.
09:51:28 <dcoutts_> gwern: you'd use versioned binaries by default and put a symlink in the same dir right?
09:51:36 <Saizan> dantheman_: if you reinstalled a Cabal-1.6.0.3 globally it overwrote the one you had, probably breaking a lot of things, since the ABI will be different
09:51:39 <edwardk> pchiusano: you could always replace HList with my type level fingertrees ;)
09:51:50 <edwardk> pchiusano: now you have three problems
09:51:51 <gwern> dcoutts_: yeah, so my ~/bin/ would hold 'darcs -> darcs-2.4', 'darcs-2.3', 'darcs-2.2' etc
09:51:54 <pchiusano> lol
09:51:59 <mornfall> How do you normally "specialise" an instance?
09:52:03 <gwern> dcoutts_: or my .cabal/bin if I hadn't set my config to point to ~/bin etc.
09:52:15 <bastl> dcoutts: seems to work.
09:52:16 <Apocalisp> I know! A type-level monoid zipper.
09:52:28 <gwern> @quote hlist
09:52:28 <lambdabot> <JohnMeacham> says: of course any minute now oleg is going to come along and actually express the second law of thermodynamics via functional dependencies as a purely incidental part of improving
09:52:29 <lambdabot> HList syntax or something.
09:52:38 <mornfall> I'd say instance Foo x and instance Foo Bar, but that's incoherent. :(
09:52:41 <dcoutts_> gwern: right, so I think as a default, I'd prefer to have symlinks in ~/bin pointing to ~/.cabal/bin and then people do not need ~/.cabal/bin on their $PATH
09:52:43 <bastl> the symlink has the binary without versions, but in .cabal/bin i have the binaries _with_ version
09:52:45 <edwardk> what properties of 'f' does your Linker (f a) (f b) derivation require, just zipping?
09:52:56 <gwern> @quote hlist.*answer
09:52:56 <lambdabot> gwern says: if hlist is the answer, I don't want to know the question
09:53:03 <Apocalisp> edwardk: Turns out that f needs to be traversable and yeah zippable.
09:53:03 <edwardk> i presume you're working with corresponding elements in f?
09:53:12 <bastl> dcoutts: yes. that bothered me too
09:53:16 <dcoutts_> gwern: though they'd be free to do so, it'd mean you'd have the versioned ones available too, which some people might like but can also be a bit annoying for bash tab completion.
09:53:24 <mornfall> Liskni_si: ^^ are you reading? :)) (about HList)
09:53:33 <dcoutts_> bastl: ok, so that's working as intended then I think.
09:53:35 <gwern> dcoutts_: a step too far; the versioning need have nothing to do with the controversial 'where do we stick binaries by default' question
09:53:37 <edwardk> okay, i buy those restrictions.
09:53:39 <pchiusano> Apocalisp: I am actually not so sure Traversable is needed
09:53:52 <Apocalisp> pchiusano: Prove it!
09:53:59 <gwern> dcoutts_: also, the -versioned binaries are longer than the original name, so tab completion still goes to the 'default' binary first
09:53:59 <Apocalisp> :(
09:54:00 <edwardk> pchiusano: to swap out the a's with b's you do
09:54:03 <Apocalisp> I mean... :)
09:54:06 <and1li> hey how do you grey out a group box depending on an option selected in a drop down list on visual basics c++
09:54:10 <Apocalisp> (blasted icelandic keyboard)
09:54:14 <edwardk> pchiusano: otherwise you can't use the positional info
09:54:19 <gwern> dcoutts_: 'The features are quite separate. You can install versioned binaries or not. You can add symlinks to some other dir or not.'
09:54:32 <dcoutts_> gwern: yeah, but then you need to hit space, a whole extra keypress!!!111
09:54:52 <dcoutts_> gwern: you're right, they're orthogonal, but I'm talking about switching the default config
09:54:57 <dcoutts_> and I'd like to do both
09:55:03 <gwern> dcoutts_: wouldn't it be 'dar<tab>-<tab>'?
09:55:31 <edwardk> hrmm maybe not
09:55:32 <dcoutts_> gwern: I mean for the common case of using the primary version, "dar<tab><space>"
09:55:48 <edwardk> i may have fooled myself
09:55:58 <dcoutts_> gwern: if the -$versioned ones are not on the $PATH then you don't need to hit the extra space, it's automagic
09:56:17 <pchiusano> gwern: that is a hilarious quote
09:56:21 <gwern> dcoutts_: but the original binary 'darcs' is the shortest string, so 'dar<tab>' gives you 'darcs' not 'darcs-' or whatever
09:56:24 <pchiusano> the @quote hlist
09:56:29 <bastl> earlier this day, I asked for splitting lists and got "Data.List.Split". Now I see that missingh has also some similar functionality in Data.List.Utils. Which would you prefer? Data.List.Split is experimental and uses some GHC-Extensions ...
09:56:29 * hackagebot MonadCatchIO-transformers 0.2.2.0 - Monad-transformer compatible version of the Control.Exception module  http://hackage.haskell.org/package/MonadCatchIO-transformers-0.2.2.0 (AriePeterson)
09:56:50 <edwardk> so one option is to change the monoid a bit
09:56:53 <gwern> bastl: split. goerzen has been abandoning stuff, so I wouldn't rely on a catchall like missingh
09:57:00 <dcoutts_> gwern: yes exactly, it gives you "darcs" where as if there are no "darcs-x.y" progs on the path then you get "darcs "
09:57:27 <gwern> dcoutts_: oh. you really think that's much of a problem?
09:57:32 <dcoutts_> gwern: it's all about the extra keypress
09:57:44 <dcoutts_> gwern: people have different tastes on that
09:57:59 <gwern> bastl: also, split is I think used more, and you would find split much easier to understand and maintain if need be
09:58:11 <gwern> (plus, focused libraries are better)
09:58:19 <edwardk> given (a `Reducer` m) we should be able to define an (f a `Reducer` ZipReducer f m) -- where we say data ZipM f m = Empty | ZipM (f m)
09:58:30 <bastl> gwern: exeactly my feelings, but my coworker insists :-)
09:58:41 <edwardk> we can choose mappend ~ fzipWith mappend
09:58:47 <gwern> bastl: is your coworker goerzen? ~-~
09:58:49 <edwardk> and mempty = Empty
09:58:55 <bastl> no :-)
09:59:20 <bastl> joking ...
09:59:24 <edwardk> and unit fa = ZipM (unit <$> fa)
10:00:20 <Apocalisp> edwardk: We use Traversable in unbind to (f (Maybe (a -> Linker b c))) -> Maybe (f (a -> Linker b c)) since unbind might not find a bind.
10:00:22 <edwardk> so now we have a way to lift a reducer into your functor. it had to pick up a base case, because we don't have a unit for fzip
10:00:52 <pchiusano> edwardk: what is ZipReducer ?
10:01:12 <edwardk> pchiusano: defined above as ZipM coz i change the name half-way through making it up
10:01:28 <pchiusano> edwardk: heh, okay
10:01:52 <edwardk> Apocalisp: not sure i understand unbind
10:03:10 <edwardk> oh
10:03:28 <pchiusano> Apocalisp: we don't need traversable to convert a f (Reducer a m) to a Reducer (f a) (f m)
10:03:33 <edwardk> i mean i see why you use traversable there, but not why that is needed to define the aforementioned reducer
10:03:36 <edwardk> yeah
10:03:53 <pchiusano> we just need zip + fmap
10:03:56 <bastl> dcoutts: My executables use a library, will the "versioned" binaries use the right version of the library ??
10:04:16 <edwardk> pchiusano: well, you don't have a unit for f m
10:04:17 <bastl> or will they use always the currently registered?
10:04:28 <edwardk> pchiusano: you have a semigroup unless you add that extra element i added above
10:04:33 <dcoutts_> bastl: it makes no difference to how the binary is built, it's just a name used at install time
10:04:39 <pchiusano> edwardk: yes, you do
10:04:47 <edwardk> or have a 'ziplist' style unit
10:04:54 <edwardk> which would depend on f
10:05:03 <pchiusano> well, hang on
10:05:20 <bastl> so when the lib changes, the executable may not work anymore ...
10:05:22 <pchiusano> if we have a Monoid m => Reducer a m
10:05:31 <pchiusano> and an f (Reducer a m)
10:05:40 <pchiusano> and a Zippable, Functor => f
10:06:00 <edwardk> i'm not parsing "f (Reducer a m)"
10:06:06 <pchiusano> the unit of the reducer becomes fmap unit
10:06:26 <and1li> anyone know c++ in here!!!
10:06:41 <edwardk> pchiusano: by unit i mean unit in the sense of 'unit of the monoid' or mempty
10:06:58 <pchiusano> the identity of the monoid becomes fmap (const mepty) (f a)
10:07:00 <edwardk> pchiusano: somewhat confusing given my nomenclature for reducers ;)
10:07:19 <edwardk> you don't have an f a lying around necessarily though
10:07:39 <edwardk> you'd have to sneak a peak at your generator to grab one
10:07:49 <pchiusano> edwardk: in our case we do...
10:07:52 <edwardk> ?
10:08:20 <pchiusano> we have a f (Reducer a m) value
10:09:12 <edwardk> again with me not parsing that statement. ;0
10:09:21 <dcoutts_> bastl: currently we use static linking so binaries do not break if you uninstall libs
10:09:51 <edwardk> you have a functor that has as its contents dictionaries describing the unit, mempty and mappend operations?
10:10:20 <pchiusano> edwardk: I am just talking about writing the function transpose :: (Zippable f, Functor f) => f (Reducer a m) -> Reducer (f a) (f m)
10:10:50 <edwardk> data Reducer a b = ?
10:11:05 <edwardk> the dictionary?
10:11:07 <pchiusano> edwardk: oh, okay, I see
10:11:11 <pchiusano> yeah
10:11:13 <Apocalisp> I think pchiusano is referring to implementation detail of lifting a Linker that has been constructed with a l1 >>= f
10:11:22 <edwardk> i'm fine with that =)
10:11:28 <pchiusano> edwardk: Reducer is not a typeclass in our code
10:11:36 <pchiusano> it is a first class value
10:11:46 <edwardk> problem
10:11:56 <pchiusano> with a unit and a first class monoid
10:12:04 <edwardk> f (Reducer a m) -- you can have multiple reducers from a to m inside of f, which do you pick?
10:12:10 <edwardk> worse
10:12:35 <pchiusano> edwardk: yes, exactly, you have one for each position in the collection
10:12:36 <edwardk> f may contain no Reducer a m's, where does the new Reducer (f a) (f m) come from?
10:12:46 <Apocalisp> edwardk: You pick the corresponding one for each position
10:12:49 <edwardk> ah
10:12:58 <edwardk> ok
10:13:04 <edwardk> that works
10:13:09 <Apocalisp> There is a problem though if you encounter an empty f of reducers.
10:13:13 <pchiusano> edwardk: in our case, we aren't actually using zip - the structure of zip is the smaller of the two
10:13:31 <edwardk> thats the usual zip convention
10:13:32 <pchiusano> edwardk: we use align, where the structure is the larger of the two, and holes are explicit
10:13:43 <edwardk> hrmm
10:13:56 <edwardk> so here if you have holes you just don't get a monoidal value for that slot?
10:13:58 <pchiusano> edwardk: that way, after the first pass, the f (Reducers) will have a reducer for every possible position in the generator
10:14:02 <edwardk> oh this works a bit nicer
10:14:06 <Apocalisp> (but the empty case will never happen in practise since you got it by mapping b -> Reducer a c) over an f b
10:14:10 <edwardk> that makes me much happier about this
10:14:40 <edwardk> one limitation though is you do have 'a filter of positions that make sense' given that if your original f (Reducer a m) -- didn't have a given position then your new
10:15:12 <edwardk> Reducer (f a) (f m) obviously can't populate an m in that position so it will only produce f m's that contain the positions from the original f m.
10:15:34 <Apocalisp> that's true
10:15:54 <pchiusano> edwardk: correct, which is why you only do this operation on f's that are produced by linking the whole series coming from the generator
10:16:12 <pchiusano> otherwise yeah you are hosed
10:17:11 <Apocalisp> edwardk: incidentally all type class instances are first-class in Scala
10:17:13 <edwardk> class MonoidZip f where zipM :: Monoid m => f m -> f m -> f m; reduceM :: (Generator t, MonoidZip f) => (Elem t -> f a) -> t -> f m
10:17:26 <edwardk> Apocalisp: yeah, which is both good and bad
10:17:32 <Apocalisp> :)
10:18:10 <edwardk> er reduceM should probably be something like mapReduceM in my monoids lib terminology
10:18:56 <edwardk> but that doesn't capture your 'reducer per position' mentality
10:19:12 <edwardk> what types do you have for f anyways?
10:19:16 <edwardk> as an example?
10:19:28 <Apocalisp> Map k
10:19:29 <tibbe> dcoutts_: Bryan applied my builder path to the Data.Text repo. If you like to give some feedback that would be great. That way we could apply your suggestions (if any) before we make the module publi
10:19:32 <tibbe> public*
10:19:43 <dcoutts_> tibbe: ok
10:20:12 <Apocalisp> edwardk: We have one that's isomorphic to Data.Tree, for example.
10:21:13 <Apocalisp> rather, (Tree . Map k)
10:24:33 <Apocalisp> data Tree k a = (a, Map k (Tree k a))
10:25:18 <pchiusano> i'm always amazed at how effective one can communicate even in irc with random snippets of type signatures...
10:25:31 <fax> yeah it's cool
10:25:35 <fax> programming languages :P
10:25:55 * pchiusano tries to imagine the equivalent conversations in #java
10:26:02 <Apocalisp> hahaha
10:26:14 <and1li> does anyone know how to enable/disable group boxes depending on the option selected in a drop down list on visual basics c++
10:26:19 <Apocalisp> Oh the pointy brackets!
10:26:34 <aavogt> you can write signatures on patterns if you want
10:27:09 <aavogt>  f (theIntThatIsPassedToF::Int) (theStringThatIsPassedToF::String) = ... :: IO ()
10:27:49 <twink> ML-style, nice
10:28:35 <aavogt> but only with extensions!
10:29:29 <fax> this is one very useful extension I like it
10:31:07 <djahandarie> edwardk, was there some Boston meet for Haskell recently?
10:31:17 <Apocalisp> djahandarie: last night
10:31:35 <djahandarie> I need to get on that mailing list or whatever
10:31:55 <Apocalisp> http://www.haskell.org/haskellwiki/Boston_Area_Haskell_Users%27_Group
10:32:16 <Apocalisp> http://groups.google.com/group/bostonhaskell rather
10:36:48 * hackagebot sqlite 0.4.2.1 - Haskell binding to sqlite3  http://hackage.haskell.org/package/sqlite-0.4.2.1 (AdamWick)
10:37:49 <edwardk> djahandarie: we have a haskell user group out here that meets ~ once a month
10:38:18 <edwardk> i basically threaten that if nobody else comes up with something to talk about, i'll ramble on about something terribly abstract and send the newbies running ;)
10:38:27 <djahandarie> haha
10:38:45 <Apocalisp> edwardk: I feel we needed more CT
10:39:01 <djahandarie> Anything I would talk about would be equally abstract, probably
10:40:02 <djahandarie> And have nothing to do with Haskell in the slightest
10:41:01 <ManateeLazyCat> I have add ^dist/ in boring file, why darcs still including `dist` directory when i run "darcs add -r *" ?
10:46:08 <edwardk> Apocalisp: I appreciate the note of support ;)
10:46:59 <Apocalisp> edwardk: You mean on the category theory?
10:47:17 <edwardk> yeah
10:47:42 <Apocalisp> Yeah man, the noobs need to just toughen up.
10:48:05 <cizra> Hi guys. I'm unsuccessfully trying to convert a do-block into >>= chain. I'm getting a type error -- expecting Char, inferred [Char]. I can't really see how it'd be possible by just changing the form of the code, but then I don't grok it fully either. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25212#a25215
10:48:47 <Apocalisp> @undo do { x <- eff; return x }
10:48:47 <lambdabot> eff >>= \ x -> return x
10:49:03 <zygoloid> cizra: the problem is that your second line is a let, not a <- binding.
10:49:07 * twink would just go over "I used this monad transformer stack for this problem" -type things and show code.
10:49:24 <zygoloid> cizra: try the more straightforward translation before going to pointsfree
10:49:43 <fryguybob> Anyone know a good package for basic read eval print loop?
10:49:52 <cizra> zygoloid: By straightforward you mean <-? I'll try.
10:49:53 <zygoloid> cizra: many1 digit >>= (\str -> let n = read str in return $ Number n)
10:49:57 <sepp2k> > foldl f x [y,z]
10:49:58 <lambdabot>   f (f x y) z
10:50:05 <zygoloid> cizra: i mean, with a lambda for the str binding
10:50:11 <edwardk> so, teasing apart the monoid/reducer machinery
10:50:27 <edwardk> it looks like you really need a better combinator than 'zip'
10:50:34 <edwardk> as a straw man
10:51:04 <edwardk> something like class Accum f where accum :: f (b, a -> b) -> f a -> f (b, a -> b)
10:51:12 <zygoloid> cizra: ... = many1 digit >>= (\str -> return $ Number (read str)) = many1 digit >>= (return . (Number . read)) = Number . read <$> many1 digit
10:53:23 <edwardk> with that you can quickly model the f (Reducer a m) -> Reducer (f a) (f m) transformation:
10:55:26 <edwardk> hrmm, but perhaps not as efficiently as one would like
10:56:58 <zygoloid> @@ @pl @undo do str <- many1 digit; let {n = read str}; return $ Number n
10:56:58 <lambdabot>  (line 1, column 30):
10:56:58 <lambdabot> unexpected "{"
10:56:58 <lambdabot> expecting "()", natural, identifier or "in"
10:57:18 <edwardk> apocalisp: a cheesy answer is to include the template in the helper: class Accum f where accum :: f (Reducer a m) -> f m -> f m -> f m
10:57:20 <edwardk> er
10:57:36 <zygoloid> @undo do str <- many1 digit; let {n = read str}; return $ Number n
10:57:36 <lambdabot> many1 digit >>= \ str -> let { n = read str} in return $ Number n
10:57:37 <zygoloid> hmm. is there any @command i could use to strip out those braces? :(
10:57:56 <edwardk> no, wait, thats fine, Reducer a m there justifies the m being a monoid (in potentially multiple ways)
10:57:57 <dmhouse> You could just not type them in in the first place
10:58:02 <Apocalisp> edwardk: Accum is pretty applicative-like
10:58:04 <dmhouse> @undo do str <- many1 digit; let n = read str; return $ Number n
10:58:05 <lambdabot>  Parse error at end of input
10:58:10 <edwardk> Apocalisp: intentionally so
10:58:15 <zygoloid> @pl many1 digit >>= \ str -> let n = read str in return $ Number n
10:58:15 <lambdabot> (Number . fix . const . read) `fmap` many1 digit
10:58:19 <dmhouse> Oh, perhaps not. (It should work though.)
10:58:38 <dmhouse> > do x <- Just 4; let y = 2*x; return y
10:58:38 <edwardk> the latter Accum definition does looks to be sufficient, though perhaps too permissive
10:58:39 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
10:58:45 <zygoloid> dmhouse: no, it shouldn't. the braces are inserted in the wrong places
10:58:57 <zygoloid> that's: do x <- Just 4; let {y = 2*x; return y}
10:59:14 <dmhouse> Oh, sorry.
10:59:36 <zygoloid> @type fix . const
10:59:36 <lambdabot> forall a. a -> a
10:59:45 <zygoloid> hmm, good work lambdabot :)
11:00:24 <ManateeLazyCat> How to config boring file for darcs?
11:00:56 <ManateeLazyCat> I have use "darcs setpref boringfile ./.boring", but not work.
11:01:24 <alpounet> ManateeLazyCat, ask on #darcs
11:01:46 <ManateeLazyCat> alpounet: Yep, i have ask, but no response. :)
11:03:01 <mornfall> ManateeLazyCat: You need to record that patch, too.
11:03:14 <ManateeLazyCat> mornfall: I don't understand.
11:03:23 <mornfall> ManateeLazyCat: After you setpref, you need to record.
11:04:02 <ManateeLazyCat> mornfall: I try.
11:04:28 <sepp2k> @src scanl
11:04:28 <lambdabot> scanl f q ls = q : case ls of
11:04:28 <lambdabot>     []   -> []
11:04:28 <lambdabot>     x:xs -> scanl f (f q x) xs
11:07:56 <ManateeLazyCat> mornfall: Works, thank you very much!.
11:08:07 <mornfall> Np.
11:09:13 * ManateeLazyCat Now i don't need clean and recompile after add boring filter. Sweet.
11:14:45 <cizra> zygoloid: It took time, but I figured it out \o/ Thanks!
11:15:30 <cizra> zygoloid: A stumbling block was that "read" is a pure function, not a monadic action, thus it doesn't need <-, nor >>=.
11:18:59 <chrisdone> what'up my lambda knights?
11:19:03 <cizra> Yo dawg
11:19:53 <chrisdone> cizra: how's tricks?
11:19:54 <cizra> An idle thought: this works: parseNumber = (many1 digit) >>= (\s -> return . Number . read $ s)    -- now if liftM takes any function and makes it a monadic action, I should be able to chain it explicitly. Something like parseNumber = many1 digit >>= liftM read >>= return Number, which doesn't work.
11:20:15 <cizra> chrisdone: Haven't really been juggling for a while now..
11:20:34 <cizra> o wait, return Number is a pure function as well..
11:21:15 <cizra> that is, it takes a pure argument
11:21:23 <chrisdone> http://blog.well-typed.com/2010/04/parallel-haskell-2-year-project-to-push-real-world-use/
11:21:23 <chrisdone> awesome!
11:22:46 <equaeghe> I have an infinite [IO ()]; how do I get it to stdout? I'll end the program with Ctrl-C.
11:23:41 <dv-> sequence_
11:24:23 <dv-> @type sequence_
11:24:23 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
11:24:31 <cizra> equaeghe: map? mapM?
11:24:35 <sepp2k> @src scanr
11:24:35 <lambdabot> scanr _ q0 []     =  [q0]
11:24:35 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
11:24:35 <lambdabot>     where qs@(q:_) = scanr f q0 xs
11:24:48 <cizra> chrisdone: So, any ideas?
11:24:49 <Twey> :t typeIn
11:24:50 <lambdabot> Not in scope: `typeIn'
11:24:54 <Twey> What's that function called?
11:24:56 <Twey> :t typeAs
11:24:57 <lambdabot> Not in scope: `typeAs'
11:24:59 <Twey> Damn
11:25:06 <aavogt> @type typeOf
11:25:07 <lambdabot> forall a. (Typeable a) => a -> TypeRep
11:25:11 <aavogt> @type asTypeOf
11:25:11 <lambdabot> forall a. a -> a -> a
11:25:25 <Twey> Ah, that's the one
11:25:26 <Twey> Thanks
11:25:26 <aavogt> @type asTypeIn
11:25:27 <lambdabot> forall a b. a -> (a -> b) -> a
11:25:37 <aavogt> though asTypeIn is only in \bot
11:25:56 * aavogt considers asType<random preposition>
11:26:39 <Twey> :t sequence_ `asTypeIn` flip id [print "hi"]
11:26:40 <lambdabot> [IO ()] -> IO ()
11:26:40 <equaeghe> dv-: sequence_ did the trick, thanks
11:27:38 <aavogt> :t sequence_ :: [IO ()] -> IO () -- more direct
11:27:39 <lambdabot> [IO ()] -> IO ()
11:28:12 <dv-> :t sequence_ [print 1, print 2, print 3]
11:28:13 <lambdabot> IO ()
11:28:44 <aavogt> all this asTypeOf stuff is mostly useful when you aren't allowed to write a type signature, which is mostly lifted by -XScopedTypeVariables
11:29:23 <aavogt> but then again, there are still times when syntax to support partial type signatures would be nice
11:29:52 <aavogt> ex. some shortcut for:    foo  `asTypeOf` (undefined :: a -> (b -> a) -> (a,a))
11:30:11 <aavogt> though I doubt that's going to happen
11:30:17 <dantheman_> Hi, trying to apply a patch using darcs apply 835-001.bin, but it fails. Anyone know what might give the error msg: darcs.exe: mmap of '_darcs/index' failed: does not exist (No such file or directory)  ?
11:30:54 <aavogt> dantheman_: is your current working directory the darcs repo
11:31:07 <mornfall> dantheman_: Are you on windows?
11:31:08 <aavogt> I recall there being some issues of darcs-2.4 on windows....
11:31:30 <dantheman_> aavogt, I'm in the directory which itself contains _darcs/index
11:31:32 <mornfall> dantheman_: If so, you need 2.3.1, or 2.4.2 (to appear).
11:31:42 <dantheman_> Yes, I'm on windows
11:31:48 <mornfall> 2.4 and 2.4.1 are broken on win32, sadly...
11:31:54 <dantheman_> Ah ok.
11:32:28 <dantheman_> So I have to uninstall the existing darcs somehow.. what's the easiest way to revert to 2.3.1?
11:33:07 <dantheman_> Thanks anyway, been stuck on that for a while.
13:50:38 --- topic: '["Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/", "RIP Robin Milner"]'
13:50:38 --- topic: set by Pseudonym!~ajb@torchwood.alicorna.net on [Tue Mar 23 22:12:43 2010]
13:50:38 --- names: list (clog cheater2 bo0ts__ conal absentia daviddarais erg0t_ edlinde zakwilson zark4711 phyrex1an1 zurk aluink nettok_ aconbere cying LukeL_ jsgf scm jninja ttuegel littlebear hiato cocon bgs100 psychicist_ yaxu1 MoALTz pickles jsdelfino ketil amiri BMeph thou novas0x2a Adamant dark M| siplux augur Gertm applicative erikc Athas jacobian shaleny Philippa MacCoaster dual mamalujo mahogny meanburrito920 dnolen Philonous monadic_kid mreh agemo_ Meow`` lopex)
13:50:38 --- names: list (winxordie CalJohn_ mun Jantaro Fabse Eridius alip u_quark dolio Metamucil bolmar Beetny ystael shintah SonOfLilit epokal_ Zephyrus Vulpyne Kate JBGood hipertracker c_wraith boyscared drk-sd bos cyanoacry raichoo Feuerbach dpratt71 nuvw Amadiro kpreid dmpots mtnviewmark MrFahrenheit gonsor pookleblinky jon_of_arc Saizan jmelesky iratsu cizra Walt exDM69 PhilRod ulfdoz comak jonafan fbru02 vimzard Olathe nick8325 dancor prateek Dashkal BCoppens dmhouse noam)
13:50:38 --- names: list (XniX23 mrsolo tov SyntaxNinja issal dv- fabiim OnionKnight jbapple dimmy Mowah roconnor neurogeek||m mail Nshag confounds max_atreides Cadynum jimmyjazz14_ pchiusano eagletmt dcoutts_ jethomas IIcke triplez pmaes bashrc_ shapr RORgasm Darkone orbitz Anoq edon trie saml Associat0r gbeshers zachk tavelram nniro dju__ heath TacticalGrace jmv wisemanby twink danvet fax maurer_ lenbust twanvl Ikke rv2733 nominolo_ TR2N systemfault metasyntax` dschoepe jrib)
13:50:38 --- names: list (mm_freak objorn carlocci Mr_Awesome nathanic stepnem maxter dibblego gogonkt magicman theorbtwo Asztal juhp lux` htoothrot astroboy pukka janbanan ricky gio123 ivanm siracusa m3ga m-i-l-a-1 dfkjjkfd Stalafin hackagebot chittoor Bjorn^2 Gracenotes radhermit det pasc leifw lispy ingy frey alexsuraci orlandu63 shadowspar caligula_ teukka teratorn otto_s bqf Zeiris stepcut sshc Sgeo iizukaway fonz StefanK1 tumult sjanssen Choko Lajla encryptio clarkb saccade)
13:50:38 --- names: list (jsk-afk Cale myu2 quicksilver SubStack te idnar AnAdorableNick alec aep tafryn ville lyndon fnordus flux vili1 dqd \net kwinz eugene_ thetallguy1 olsner zax nlogax orclev muhtimin Jiten Sisu Ke Ferdirand borism espadrine Taggnostr2 tomaw Cthulhon ClaudiusMaximus regalia welterde Poeir xinming_ Spockz helgikrs mdordal2 fryguybob matt_m snorble ronwalf eyck sepeth mwc Colours gereedy medical dcolish Axman6 bigorilla MarcWeber ddarius nothingmuch smorg kfish)
13:50:38 --- names: list (Jaak hc_e bgs1001 scree_ LeoD dever_ quaestor hugin chr1s_ koala_man killing-joke companio1_square AndyP_ cYmen_ snr eek ksandstr noj_ kolmodin_ BONUS mietek tew88 aiko- khiroc tltstc waterlaz `0660 levitation[A] Younder tab potatishandlarn EvanR-work Hunner stenobot2010 shortcircuit netcat dionoea burp tromp_ kevinclark Raku^ djinni thorkilnaur Valodim otulp Eghie Contra nekochan Draconx araujo birkenfeld dfeuer dubhrosa mun_ Ycros lsthemes dreixel tilman)
13:50:38 --- names: list (ydo DigitalKiwi gwern Bassetts taybin Mathnerd314 quuxman ilhvm pikhq Polarina aristid Trafalgard fnord123 bbee jaj LouisJB jmg PsiOmega droidcore HeMan PepeSilvia mjrosenb FauxFaux alpounet pielgrzym lambdabot Igloo eldragon JaffaCake Entroacceptor cozmic raymonvw IceDane Agnostos StarFire equanimity samulihs nominolo rankles lpsmith twobitsprite preflex mauke pkrumins LoRe timofonic b4taylor shrughes Eelis woggle [swift]1 Sam__ sm_ newsham cognominal)
13:50:38 --- names: list (voker57 michael| joni6128 yahooooo sm mexisme integral Aisling Liskni_si ptrf MadX` Botje McManiaC deadguys rtaycher eno phnglui Zao ps-auxw SimonRC flori alexbobp Aikawa QtPlatypus kynky _2x2l m4thrick Twey kniu Apocalisp tensorpudding thetallguy electrogeek kermit mle dons rsaarelm frederik dwon benmachine jorizma mornfall solrize jvoorhis Maxdamantus sohum joga miasma wto hiredman drhodes mindCrime_ inr Tass_ nathanic_work wagle mfp lomeo nasloc__)
13:50:38 --- names: list (shepheb Khisanth a11235 edwinb d-snp glith kyagrd kennethd trez cjay nimred byorgey mq opqdonut ziman gdsx Vq Gabbie galdor DustyDingo Tinned_Tuna yottis qebab p_l danderson erg Deewiant endojelly soeren jayne koninkje_away xerox tviyLog ahlmal kar-1 luite jvogel Runar o-_-o npouillard andrewsw djahandarie impl vpetro gds Laney fabjan ibid Innominate amontez creichen mfoemmel Jon igorgue arkx dropdrive Rooz inclement strobedream ve Boney drbean zygoloid)
13:50:38 --- names: list (defn Reisen greedo felipe_ josswr uorygl gbacon dogmaT_ cypher etpace clanehin futilius bd_ Davse_Bamse muep pettter epmf Lemmih shachaf norm2782 ibt beatmox hellige taruti sebbe1991 davidL jdsc_ Wolong koeien untwisted Veinor joed Ytinasni russell_h BrianHV willb pwerken mk64ftw_ shutdown_-h_now tridactyla jmcarthur Nanar mlh TML syntaxglitch Stephan202 kosmikus inhortte erk_ karld dino- Paradox924X ido chromakode palmje allbery_b ski jml ctrlfrea1 twn)
13:50:38 --- names: list (Ornedan_ chrissbx slabanja Counter-Strike cebewee srcerer profmakx jrockway Tomas MrDomino^ jd10_ UnderTaLker canvon megaTherion xcvii Cerulean majoh guerrilla Blub\0 aleator tamiko harlekin cods Astro laz0r ath copton mattam mrshoe AnMaster inimino sbok skaar suiside kalven @ChanServ regulate thoughtpolice go|dfish mokus_ Baughn pastorn aslhk kaol ahf mrd __marius__ DrSyzygy albertosantini ernst noddy davean monochrom ezyang stroan matthew-_ And[y] amx jql)
13:50:38 --- names: list (wolverian companion_cube mercury^ andersk ahihi jamwt dixie fab__ Nereid Milo- ToRA HandheldPenguin jix ra1m0 bremner dilinger saiam nornagon int-e tmug ponzao____ helino CosmicRay tyfon icee SamB_irssi Gilly jlouis ehamberg aavogt theclaw _br_ osfameron mux eintopf EvanR emias sproingie ennen duairc dumael Becquerel pshc Bleadof dejones arcatan PHO_ liff zsol)
13:50:44 <zakwilson> p_l - he'd most likely have to write one in Lisp before he could use it from Haskell. If he's doing that, he's going to have to learn some Lisp anyway.
13:50:55 <p_l> zakwilson: well, true :D
13:51:09 <matt_m> Someone up to explaining the difference between StateT and Lazy.StateT?
13:51:15 <zakwilson> CL has a pretty small core and a big standard library. After learning the basics, it's easy to look up anything you don't understand.
13:51:26 <sproingie> sorry that was old-fashioned lisp.  (IS-EASY-TO-LEARN-AND-UNDERSTAND commonlisp)
13:51:30 <sproingie> there we go
13:51:40 <p_l> sproingie: actually #'EASYP was better
13:51:48 <edlinde> ok so you saying learning c-lisp is easy?
13:51:56 <p_l> edlinde: CL, not c-lisp :)
13:52:01 <zakwilson> I might hesitate to say it's easy to someone who's only used VB, but I have no problem telling someone who already knows Haskell that CL is easy.
13:52:08 <edlinde> ok same shit p_l :)
13:52:33 <p_l> edlinde: http://www.gigamonkeys.com/book/ http://www.cs.cmu.edu/~dst/LispBook/
13:52:37 <edlinde> zakwilson: yeah I have done no haskell
13:52:38 <sproingie> CL can get tricky with macros and functional code.  usually it's used pretty much imperatively tho
13:53:00 <edlinde> are there similarities between CL and Haskell?
13:53:00 <zakwilson> edlinde: So, you don't know CL or Haskell, and you want to use Haskell to extend a system written in CL?
13:53:11 <tensorpudding> They're both functional languages.
13:53:17 <edlinde> zakwilson: yeah I want to learn haskell over summer
13:53:24 <sproingie> CL is more what you might call "multiparadigm"
13:53:34 <edlinde> this extension stuff is mostly writing prototypes and messing with stuff
13:53:35 <p_l> Gentle Introduction (the one under hosted on CMU) has good chapter explaining applicative, recursive and imperative approaches, and PCL has quite good introduction to OOP in CL
13:53:37 <tensorpudding> But CL has a ton of imperative stuff, is impure, dynamically-typed, and has a vastly better macro system.
13:54:13 <sproingie> it also has more implementations than useful apps :p
13:54:14 <p_l> the typing is a mix of static and dynamic, I'd say.
13:54:14 <zakwilson> edlinde: I wish you luck in doing so, but if your actual goal is to extent a system written in CL, learn CL. There's nothing to say you can't *also* learn Haskell.
13:54:24 <tensorpudding> Also it has CLOS, which is an object system.
13:54:25 <edlinde> i was recommended to look at "Learn yourself a Haskell"
13:54:32 <sproingie> good idea
13:54:49 <edlinde> and then there was another one I forget
13:54:55 <edlinde> real world haskell?
13:54:58 <p_l> sproingie: most "visible" apps are either server-side, done in commercial implementations or completely internal bespoke software.
13:55:01 <matt_m> ok nevermind
13:55:01 <p_l> AFK
13:55:02 <tensorpudding> @where rwh
13:55:02 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
13:55:03 <sproingie> that's also good, LYAH is a better intro
13:55:10 <mrsolo> i like real world haskell
13:55:21 <tensorpudding> LYAH has a good exposition but doesn't nearly have the depth of RWH
13:55:23 <edlinde> ok cool .. those are the ones I will be going through soon
13:55:34 <sproingie> lots of RWH would have confused the hell out of me if i didn't already know the basics
13:55:40 <sproingie> it's ... uneven
13:55:47 <tensorpudding> Yeah.
13:55:49 <mrsolo> right
13:55:49 <edlinde> so it doesn't have a good flow?
13:55:51 <systemfault> sproingie: Same for me...
13:55:56 <mrsolo> it does
13:55:57 <sproingie> parts have a good flow.  others don't
13:55:59 <edlinde> so its best to start with LYAH?
13:56:01 <tensorpudding> RWH is the big-name book, but it's definitely not perfect.
13:56:11 <systemfault> edlinde: IMHO, yes.
13:56:13 <mrsolo> but difficulity level goes way up when it starts to talk about monads
13:56:14 <sproingie> LYAH is incomplete but it does the basics well
13:56:21 <sproingie> LYAH doesn't cover monads at all
13:56:31 <edlinde> ok
13:56:38 <tensorpudding> RWH doesn't cover monads until many chapters in.
13:56:40 <sproingie> but it covers applicative functors so by the time you learn monads you wonder what the fuss was about
13:56:44 <edlinde> it will take a while to get the hang of the basics I suppose Anyway
13:56:59 <edlinde> is there a lot of sample haskell code I can get to look at someplace ?
13:57:00 <tensorpudding> I learned about applicatives from the typeclassopedia
13:57:03 <mrsolo> dunno.. learing cl and haskell at same time is a tall order :-)
13:57:03 <sproingie> hackage
13:57:08 <systemfault> sproingie: I found monoids harder to understand than applicative functors
13:57:19 <systemfault> sproingie: Because for me, they just made no sense.
13:57:26 * hackagebot hpage 0.7.2 - A scrapbook for Haskell developers  http://hackage.haskell.org/package/hpage-0.7.2 (FernandoBenavides)
13:57:33 <sproingie> at some point it's just all abstract and no analogy works
13:57:39 <tensorpudding> Monoids make a lot of sense if you've heard about them before Haskell.
13:57:44 <zygoloid> systemfault: weird :)
13:57:49 <sproingie> monoid has identity and an operator that works a certain way and that's all there is to say about it
13:58:15 <systemfault> zygoloid: I was wondering.. Why would I use mappend instead of ++ for lists... etc..
13:58:16 <sproingie> it's more like shapes that fit together a certain way than objects that behave like anything real-world
13:58:36 <zygoloid> systemfault: why would you use (=<<) rather than concatMap? :)
13:58:45 <tensorpudding> monoids are everywhere
13:58:54 <systemfault> zygoloid: I'm still learning :/
13:59:17 <sproingie> it's a good time to learn haskell.  people finally stopped trying to explain monads by analogy a few years back
14:00:33 <tensorpudding> Analogies have gotten a lot better than "nuclear waste container"
14:00:56 <sproingie> burritos of course
14:01:03 <temoto> Is  type operator left or right associative?
14:01:06 <xerox> still that one is pretty on top in the lattice of analogies
14:01:08 <zygoloid> space suits full of nuclear waste are so passe
14:01:17 * sproingie read that as lettuce of analogies
14:01:18 <zygoloid> temoto: right
14:01:19 <xerox> temoto: right
14:01:22 <temoto> Thanks.
14:05:43 * uorygl reads about category theory.
14:06:20 <uorygl> So, I think it's conventional to refer to the category of Haskell types as "Hask".
14:06:30 <sproingie> tis
14:06:41 <uorygl> Then the Functor class tries to formalize the notion of a functor whose domain is Hask?
14:07:13 <byorgey> uorygl: whose domain and codomain is Hask.
14:07:24 <uorygl> That too.
14:07:26 <CyberGarp> Instead of fiddling with Parsec, I decided to give Happy a try. I've written a tokenizer that works for my target language. I'm quite pleased at this point. Got one questions.
14:07:33 <sproingie> if it's in haskell, the domain and codomain is always going to be Hask
14:07:38 <CyberGarp> Anyone got happy to print parse errors with linenumber/col?
14:07:38 <sproingie> or some subset thereof
14:07:41 <zygoloid> uorygl: a covariant functor, specifically
14:08:15 <zygoloid> Functor: covariant endofunctors on Hask
14:08:28 <uorygl> zygoloid: does "covariant functor" mean one whose codomain is the same as its domain?
14:09:40 <zygoloid> uorygl: covariant means arrows X -> Y are mapped to arrows F X -> F Y (as opposed to contravariant functors which lift arrows to F Y -> F X)
14:10:37 <uorygl> Oh, so it's like...
14:11:07 <c_wraith> So the Functor type class describes covariant functors, then.
14:11:16 <uorygl> A covariant functor is a type of functor in the same sense than an apple is a type of either-apple-or-banana.  :P
14:11:39 <uorygl> Or maybe I need to learn what the definition of "functor" is.
14:11:50 <uorygl> Anyway, is an endofunctor one whose codomain is its domain?
14:12:16 <c_wraith> yes
14:12:30 <c_wraith> all haskell functors are endofunctors
14:12:57 <uorygl> And it looks like I was right about the either-apple-or-banana.
14:15:21 <byorgey> more like either-apple-or-upside-down-apple
14:16:27 <uorygl> I suppose a definition of a contravariant functor in Haskell would look like the Functor class except the fmap would have a type more like (a -> b) -> c b -> c a
14:16:37 <byorgey> exactly
14:16:59 <byorgey> there is precisely such a class in the category-extras library
14:17:10 <byorgey> I forget what it's called, probably ContraFunctor or somesuch
14:17:14 <uorygl> Does it have any instances?  :P
14:17:17 <dibblego> Cofunctor
14:17:25 <byorgey> uorygl: lots!
14:17:33 <uorygl> Hmm, that's more than I was expecting.
14:17:50 <dibblego> newtype Eq a = Eq (a -> a -> Bool); instance Cofunctor Eq where ... -- have fun!
14:17:52 <uorygl> I guess -> sort of forms a cofunctor on its first argument and a functor on its second.
14:17:52 <aavogt> cocontainers
14:18:03 <byorgey> uorygl: indeed!
14:18:05 <mauke> coconuts == nuts?
14:18:53 <uorygl> Let's see.  If a can be turned into b, then equality comparison on b can be used as equality comparison on a...
14:18:59 <byorgey> uorygl: not even "sort of"; this can be made quite precise.  look up "hom functor"
14:19:03 <uorygl> Gosh, that sounds like something there should be a name for.
14:19:08 <monochrom> intuitionism says that coconuts is different from nuts
14:19:26 <uorygl> Cocococonuts, on the other hand, are the same as coconuts, right?
14:19:44 <fax> C^op^op = C
14:19:48 <monochrom> Yes. Also cococo = co
14:19:52 <uorygl> Right.
14:20:36 * uorygl makes a Facebook post about the coconuts.
14:20:38 <CyberGarp> http://mathworld.wolfram.com/MonkeyandCoconutProblem.html
14:20:55 <CyberGarp> Heh. There's a black hole of personal time.
14:21:21 <fax> oh I've solved that problem once
14:22:47 <uorygl> I've heard of that problem, but never solved it or anything.
14:24:35 <uorygl> Hmm, fixed points of Haskell functors are fun.
14:24:40 <CyberGarp> It's a fun one. Gardner's solution involved using negative coconuts, then inferring the positive answer from the negative one.
14:25:07 <uorygl> Hmm, that seems correct somehow.
14:27:01 <uorygl> Yeah.  Divide the coconuts into n shares, removing the remainder and one of the shares, and putting the rest of the shares back in?  There ought to be a negative fixed point of that.
14:28:11 <uorygl> If the remainder is one coconut, and there are six men, then -5 is a fixed point: each man gets -1, you take your -1, and you give the 1 to the monkey.
14:29:01 <uorygl> I'm not sure how to proceed from there.
14:29:35 <CyberGarp> Then you know the answer is a multiple of a given number, thus you subtract -5 (or is it -4?) from that number.
14:30:16 <uorygl> You mean you know the answer is -5 plus a multiple of a given number?
14:31:13 <uorygl> I guess it seems each round should eliminate a specific fraction of the possible answers.
14:31:46 <uorygl> If there are six men, 5/6 of the possible answers.  So start with 1, and for each round, multiply by 6, and then subtract 5 and hope that's the answer.
14:32:41 <fax> I wonder if there'd be a way to unify parametrised modules, GADTs and constraint rules
14:33:05 <Makoryu> We have parameterized modules now?
14:33:17 <fax> I'm working on it
14:33:17 <Makoryu> And nobody told me? T_T
14:33:19 <Makoryu> Ahh
14:34:04 <uorygl> Hmm.  Looks like I was close, at least.
14:34:31 <uorygl> I don't know if I was taking into account the special thing that happens at the end.
14:35:03 <uorygl> Pondering it a bit more, I conclude that nothing special happens at the end after all.
14:35:15 <CyberGarp> uorygl, multiple of a given number
14:35:21 <Philippa> fax: you get a very, very long way if you parameterise datatypes on instances/modules and do the 'obvious' System F + explicit evidence passing + coercions, AFAICT
14:35:43 <CyberGarp> 5^5 - 4
14:35:46 <CyberGarp> 3121
14:36:16 <CyberGarp> er, that's the older version
14:36:46 <CyberGarp> Since N is divided six times into five piles, 5^6 can be added or subtracted from any answer. Aka modulo 5^6
14:36:59 <CyberGarp> -4 is a solution
14:37:19 <CyberGarp> So, 5^6 - 4 => 15,621 coconuts.
14:37:26 <uorygl> So it's -4 plus a multiple of 5^6.
14:37:34 <CyberGarp> correct
14:38:46 <CyberGarp> Start with -4, toss one to the monkey, -5. Divides into fives piles, a -1 coconut in each. After hiding one, that leaves -4.
14:38:51 <CyberGarp> The fixed point!!!
14:39:25 <CyberGarp> I'm coco for cococonuts
14:39:46 <CyberGarp> Actually, I've ODed on Happy.
14:40:09 <Sadache> let something = readLn :: IO String in  something >>=  print
14:40:19 <Sadache> what is wrong with my code?
14:40:34 <Sadache> it seams there is no instance of Read for String?
14:41:58 <benmachine> yes there is
14:42:15 <benmachine> but keep in mind it's not the identity
14:42:21 <benmachine> so read "foo" doesn't give you "foo"
14:42:27 <benmachine> you need to read "\"foo\""
14:44:27 <uorygl> I guess the thing I don't understand is the factor of (1 + n k) or (n - 1 + n k).
14:45:30 <gwern> CyberGarp: I'm coco for cocaine
14:45:42 <CyberGarp> ;)
14:55:52 <ivanm> gwern: do you do any literate programming stuff with pandoc?
14:56:37 <aavogt> iliterate disfunctional programming
14:56:50 <gwern> ivanm: I have some quasi tutorials/blog essays working through writing my wikipedia programs
14:56:51 <ivanm> :o
14:57:02 <gwern> aavogt: dys
14:57:09 <ivanm> gwern: *nod* how do you set up emacs for that?
14:57:14 <ivanm> do you have some multimode thing setup?
14:57:37 <gwern> ivanm: markdown mode; I lose haskell highlighting, but since I already wrote the program and debugged it...
14:57:50 <gwern> and when I'm editing through gitit, just keep a non-edit tab open
14:57:56 <ivanm> *nod*
14:57:56 <aavogt> gwern: you missed one spelling mistake though
14:58:08 <gwern> aavogt: the iliterate is funny
14:58:12 <gwern> disfunctional isn't
14:59:53 <fax> 22
15:02:00 <applicative> fax, 22?
15:02:10 <fax> sorry didn't mean to type that
15:02:11 <fax> +
15:02:13 <fax> fffff
15:02:23 <tommd> He ment:
15:02:23 <tommd> > reverse "22"
15:02:24 <lambdabot>   "22"
15:02:40 <applicative> > read . reverse $ "22"
15:02:41 <lambdabot>   *Exception: Prelude.read: no parse
15:02:55 <applicative> what'd i do wrong, what a loser.
15:03:18 <mauke> > read . reverse $ "22" :: Integer
15:03:18 <lambdabot>   22
15:03:49 <companion_cube> > take 15 $ scanl (+) 1 [2..]
15:03:49 <lambdabot>   [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120]
15:05:00 <applicative> > let myread = read :: String -> Int in myread . reverse $ "22"
15:05:00 <lambdabot>   22
15:05:28 <mauke> > succ . read . reverse $ "22"
15:05:29 <lambdabot>   *Exception: Prelude.Enum.().succ: bad argument
15:05:34 <mauke> tee hee
15:05:53 <applicative> > (+1) . read . reverse $ "22"
15:05:53 <lambdabot>   23
15:06:45 <c_wraith> > succ 1.5
15:06:46 <lambdabot>   2.5
15:06:48 <applicative> > (+0) . read . reverse $ "22"
15:06:49 <lambdabot>   22
15:08:55 <applicative> why does lambdabot say 'no parse' when it can't tell what you want to 'read' something as; ghci says the sensible "Ambiguous type variable `a' in the constraint: `Read a' ..."
15:09:15 <mauke> > read "()"
15:09:15 <lambdabot>   ()
15:09:17 <c_wraith> because lambdabot is defaulting to ()
15:09:40 <applicative> I see, and it can't read "22" as one of the () values.
15:10:31 <mauke> yes
15:10:44 <mauke> > id
15:10:45 <lambdabot>   {()->()}
15:10:51 <applicative> I see, the no parse is of course what ghci says for
15:10:54 <applicative> > (+1) . read . reverse $ "hahah"
15:10:55 <lambdabot>   *Exception: Prelude.read: no parse
15:11:44 <benmachine> > succ undefined :: ()
15:11:45 <lambdabot>   *Exception: Prelude.Enum.().succ: bad argument
15:11:59 <benmachine> succ fails lazily o_o
15:13:27 <c_wraith> why would the Enum implementation for () ever need to examine its argument?
15:13:59 <c_wraith> > enumFromTo () ()
15:14:00 <lambdabot>   [()]
15:14:19 <benmachine> > enumFromTo undefined ()
15:14:20 <lambdabot>   *Exception: Prelude.undefined
15:14:26 <benmachine> > enumFromTo () undefined
15:14:27 <lambdabot>   *Exception: Prelude.undefined
15:14:32 <benmachine> hmm
15:14:46 <c_wraith> heh.  that implementation is too strict!
15:15:02 <applicative> > > (read undefined ) :: ()
15:15:03 <lambdabot>   <no location info>: parse error on input `>'
15:15:09 <applicative> > (read undefined ) :: ()
15:15:10 <lambdabot>   *Exception: Prelude.undefined
15:15:24 <benmachine> uh
15:15:30 <benmachine> > read "blib" :: ()
15:15:31 <lambdabot>   *Exception: Prelude.read: no parse
15:15:43 <benmachine> I'd like to see *that* not inspect its argument
15:15:52 <Veinor> read without reading!
15:18:56 <Makoryu> > read "()" :: ()
15:18:57 <lambdabot>   ()
15:19:02 <Makoryu> > read "( )" :: ()
15:19:03 <lambdabot>   ()
15:19:08 <Makoryu> > read "() " :: ()
15:19:09 <lambdabot>   ()
15:19:14 <Makoryu> > read "()\n" :: ()
15:19:15 <lambdabot>   ()
15:19:34 <fax> > ( )
15:19:34 <lambdabot>   ()
15:19:58 <Makoryu> > read "(\n)" :: ()
15:19:59 <lambdabot>   ()
15:20:22 <mauke> > read "{- -}()"
15:20:23 <lambdabot>   *Exception: Prelude.read: no parse
15:20:53 <Makoryu> > read "() -- Lulz" :: ()
15:20:54 <lambdabot>   *Exception: Prelude.read: no parse
15:20:57 <Makoryu> Hmmm
15:22:45 <Sadache> let something = readLn :: IO String in  something >>=  print
15:22:59 <Sadache> what is wrong with this code?
15:23:23 <fax> :t let something = readLn :: IO String in  something >>=  print
15:23:24 <lambdabot> IO ()
15:23:41 <fax> seems fine, putStr[Ln] instead of print if you like better output
15:24:08 <Sadache> fax: it wont work, it types well though
15:24:17 <mauke> what doesn't work?
15:24:20 <Makoryu> Sadache: Okay, what does it do wrong
15:24:28 <applicative> @src readLine
15:24:28 <lambdabot> Source not found. Just what do you think you're doing Dave?
15:24:37 <Sadache> fax: it seems that there is no Read String instance
15:24:47 <applicative> must be (read <$> getLine)
15:24:54 <mauke> Sadache: then that code wouldn't compile
15:25:10 <Cale> Sadache: There is a read instance for String, it requires that you put the string in quotes.
15:25:21 <Makoryu> > read "\"Look at me, I'm a string!\"" :: String
15:25:22 <lambdabot>   "Look at me, I'm a string!"
15:25:39 <applicative> @> read "Look at me I'm a string"
15:25:39 <lambdabot> Maybe you meant: . ? @ v
15:25:45 <Cale> (if you want to get a line of text from the user without quotes, just use getLine instead)
15:25:46 <applicative> > read "Look at me I'm a string"
15:25:47 <lambdabot>   *Exception: Prelude.read: no parse
15:25:52 <Sadache>  user error (Prelude.readIO: no parse)
15:26:01 <mauke> Sadache: then you gave wrong input
15:26:06 <Sadache> that what the code outputs
15:26:20 <Cale> Sadache: You didn't input a valid String value.
15:26:28 <Sadache> but if I change the type to IO Int and I input an Int it works fine
15:26:40 <mauke> you didn't input a valid String
15:26:42 <Cale> Sadache: Did you actually type a String, quotes and all?
15:26:44 <Sadache> Cale: ah ok I got you
15:26:52 <Sadache> no I didnt
15:26:56 <applicative> Sadache, exactly, you gave a good numeral, but not a good string representation
15:27:06 <Sadache> I didnt know you need to quote a stringm but now I get it
15:27:10 <applicative> Sadache, you gave it a string, not the representation of a string.
15:27:14 <sioraiocht> I get the error File `lhs2Tex.fmt' not found in search path: after installing lhs2TeX via cabal-install
15:27:27 <Sadache> applicative: ok thank you for the explanation
15:27:34 <sioraiocht> is tehr a common reason for this?
15:27:40 <sioraiocht> am running Mac OS x
15:28:22 <applicative> siraiocht, is this error coming from LaTeX or ghc
15:28:27 <Cale> sioraiocht: Read the lhs2TeX documentation
15:28:44 <Cale> sioraiocht: There are additional steps you have to take to install some things for TeX
15:28:48 <sioraiocht> applicative: from the lhs2TeX program
15:28:54 <sioraiocht> Cale: okay, thanks, should have done that before =)
15:29:20 <Cale> (I could tell you what the steps were, but I don't remember so clearly, and they're listed in the documentation anyway :)
15:30:43 <sioraiocht> np, cheers =)
15:33:26 <cads> @hoogle Integral a => a -> [b] -> [[b]]
15:33:27 <lambdabot> Data.List genericDrop :: Integral i => i -> [a] -> [a]
15:33:27 <lambdabot> Data.List genericTake :: Integral i => i -> [a] -> [a]
15:33:27 <lambdabot> Data.List genericReplicate :: Integral i => i -> a -> [a]
15:33:59 <cads> it's fantastic how amazingly suggestive a function's type is
15:34:28 <cads> @hoogle Int -> [a] -> [[a]]
15:34:29 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
15:34:29 <lambdabot> Prelude drop :: Int -> [a] -> [a]
15:34:29 <lambdabot> Prelude take :: Int -> [a] -> [a]
15:36:23 <Anon434> hello
15:36:48 <Anon434> anybody here?
15:36:58 <djahandarie> Anon434, sure
15:37:59 <ivanm> no, we've all realised that we're just wasting our lives away programming and should be out having fun instead
15:38:02 <ivanm> ;-)
15:38:46 * ddarius goes out to have fun right now incidentally.
15:38:47 * ivanm promptly goes off and does so
15:38:47 <applicative> sioraiocht, I see, lhs2tex looks all over for the fmt files, but not where cabal inevitably hides them, in .cabal/share/lhs2tex-... so you can move them or be lazy and add export LHS2TEX=~/.cabal/share....
15:39:02 <ivanm> if by "having fun" you mean "going to uni to read more papers" :s
15:39:05 <applicative> strange, i never had any fun until i started to program
15:39:16 <sioraiocht> applicative: oddly,they were in one of the search paths that lhs2TeX mentionds
15:39:20 <dcoutts_> applicative: really? that could easily be fixed in lhs2tex
15:39:27 <sioraiocht> applicative: namely /usr/local/share/lhs2TeX-1.15
15:39:33 * djahandarie pretends to walk out of the room to "have fun" but stays here and continues reading
15:39:36 <dcoutts_> applicative: since Cabal lets packages know at runtime where data files got installed
15:39:40 <ivanm> applicative: I too was once like you, misled by all the shiny lights and dreams of being a world famous professional Haskell programmer
15:40:02 <applicative> ivanm, I would never be so foolish as to make that error...
15:40:10 <djahandarie> Maybe if world == haskell community...
15:40:12 <ivanm> but then I saw the light: we already have dons and don't need anyone else; as such that dream isn't possible to reach (sans murder...)
15:40:27 <ddarius> Murder is always an option.
15:40:38 * ivanm pushes his chainsaw out of view
15:41:00 <applicative> sioraiocht, how did you install lhs2tex?
15:41:13 <sioraiocht> sudo cabal install --global lhs2Te
15:41:16 <sioraiocht> X
15:41:31 <ivanm> sioraiocht: you have to specify the .fmt files in the path that _latex_ looks for them
15:41:35 <ivanm> not lhs2tex
15:41:36 <cads> is there anyone that can spy on my steamy private sessions with lambdabot?
15:41:46 <kosmikus> somnium: permission problem?
15:41:47 <sioraiocht> ivanm: even though lhs2TeX is the one giving me the error?
15:41:59 <ivanm> :o
15:42:02 <djahandarie> cads, depends, is your connection encrypted?
15:42:05 <ivanm> is it running latex though?
15:42:12 <sioraiocht> ivanm: no
15:42:13 <kosmikus> sioraiocht: ^^
15:42:14 <cads> I forget who lambdabot's owner is
15:42:18 <ivanm> sioraiocht: anyway, you've brought kosmikus in
15:42:20 <djahandarie> cads, Cale takes care of it
15:42:22 <ivanm> let him deal with it :p
15:42:24 <sioraiocht> oh noes! heh
15:42:26 <ivanm> cads: Cale runs her
15:42:32 <kosmikus> well, I was about to go to sleep
15:42:34 <ivanm> but no-one owns her!
15:42:41 <ivanm> @vixen does anyone own you?
15:42:42 <lambdabot> what about me?
15:42:43 <kosmikus> what's the problem?
15:42:51 * ivanm -> uni
15:42:55 <sioraiocht> kosmikus: (File `lhs2Tex.fmt' not found in search path:
15:42:58 <cads> @vixen smack my rump and call me p-diddy
15:42:58 <lambdabot> okay, i'm dialing
15:43:07 <sioraiocht> I got the same for polycode.fmt
15:43:15 <sioraiocht> and it lists a search path where the file lives
15:43:31 <fryguybob> cads: should lambdabot be concerned about what you could share?
15:43:40 <kosmikus> sioraiocht: sounds like permission problem is the most likely solution
15:43:43 <Cale> sioraiocht: I made a texmf directory under my home directory
15:43:51 <sioraiocht> kosmikus: ....oops
15:44:40 <sioraiocht> kosmikus: thanks =)
15:44:48 <kosmikus> sioraiocht: glad I could help :)
15:45:01 <sioraiocht> kosmikus: yep, that fixe dit!
15:45:52 <kosmikus> sioraiocht: great. good night :)
15:45:57 <sioraiocht> goodnight!
15:48:24 <cads> fryguybob: sometimes I make a whole lot of type and syntax errors all in a row and I'm self conscious :)
15:48:36 <fryguybob> cads: lol
15:48:37 <applicative> dcoutts_, i was all wet as usual, ~/.cabal/share ... is in the default lhs2tex searchpath, confusion overtook me.
15:49:20 <applicative> dcoutts_, it isn't one of the places listed in the documentation, so I guess that's an error.
15:54:12 <cads> > let partition n = unfoldr (\ n -> if null list then Nothing else Just (take n xs, drop n xs)) = partition 4 [1..10]
15:54:13 <lambdabot>   <no location info>: parse error on input `='
15:54:23 <cads> crud!
15:54:29 <cads> > let partition n = unfoldr (\ n -> if null list then Nothing else Just (take n xs, drop n xs)) in partition 4 [1..10]
15:54:31 <lambdabot>   Not in scope: `list'Not in scope: `xs'Not in scope: `xs'
15:54:52 <cads> double crud!
15:55:01 <cads> this is how I normally write things btw!
15:55:19 <cads> > let partition n = unfoldr (\ xs -> if null xs then Nothing else Just (take n xs, drop n xs)) in partition 4 [1..10]
15:55:20 <lambdabot>   [[1,2,3,4],[5,6,7,8],[9,10]]
15:55:50 <cads> beautiful!
15:56:08 <EvanR> successfully casting a haskell spell requires a 3d6 roll against your magic skill, plus modifiers
15:56:19 <fryguybob> readability explosion.
15:56:41 <cads> EvanR and a decent amount of Lore
15:56:43 <EvanR> target gets a saving through against compiler errors
15:56:52 <EvanR> throw*
15:56:59 <SonOfLilit> Cale: Hello again
15:57:05 <SonOfLilit> was thrown off the net for a while
15:57:20 <EvanR> cads: but no charisma
15:57:29 <cads> unless you're dons
15:57:30 <SonOfLilit> so... I checked and my function does get called again and again with the same arguments
15:57:37 <SonOfLilit> how do I get it memoized?
15:57:40 <cads> can you guys think of a simpler (and perhaps more readable) version of what I wrote above?
15:58:17 <EvanR> cads: Data.List.Split has basically all split methods known to man. the doc says so
15:59:05 <cads> SonOfLilit: try data-memecombinator for a simple memoization function
15:59:17 <cads> I'm sorry, memocombinator
16:00:08 <cads> son of a bitch
16:00:09 <EvanR> meme combinator, compose simpler memes into even stupider ones
16:00:26 <cads> @hoogle Int -> [e] -> [[e]]
16:00:27 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
16:00:27 <lambdabot> Prelude drop :: Int -> [a] -> [a]
16:00:27 <lambdabot> Prelude take :: Int -> [a] -> [a]
16:00:29 <EvanR> all your lol cats
16:00:41 <jlouis> are belong to us
16:00:57 <cads> @type Data.List.Split.splitEvery
16:00:58 <lambdabot> Couldn't find qualified module.
16:01:15 <cads> splitEvery ::  Int  -> [e] -> [[e]] !!
16:01:25 <EvanR> daviddarais:
16:01:27 <EvanR> chunk :: Int -> [e] -> [[e]]
16:01:46 <EvanR> > chunk 3 [1,2,3,4,5,6,7,8]
16:01:47 <lambdabot>   Not in scope: `chunk'
16:01:55 <EvanR> > Data.List.Split.chunk 3 [1,2,3,4,5,6,7,8]
16:01:56 <lambdabot>   Not in scope: `Data.List.Split.chunk'
16:02:02 <cads> yeah, chunk and splitevery are synymous - I know because I used them just a few weeks ago
16:02:16 <cads> hmm
16:02:26 <cads> I though that hoogle searches hackage as well
16:02:32 <cads> I wonder if hayoo does
16:02:38 <mauke> <LeoNerd> Babbage's Indifference Engine: It could compute any function in constant time, it just can't be bothered to.
16:03:27 <aavogt> > let partition n = unfoldr (\(span n -> r@(a,_)) -> do guard (null a); return r) in partition 4 [1..10]
16:03:28 <lambdabot>   No instance for (GHC.Num.Num (a -> GHC.Bool.Bool))
16:03:29 <lambdabot>    arising from the lite...
16:03:56 <aavogt> > let partition n = unfoldr (\(splitAt n -> r@(a,_)) -> do guard (null a); return r) in partition 4 [1..10]
16:03:57 <lambdabot>   []
16:04:07 <aavogt> > let partition n = unfoldr (\(splitAt n -> r@(a,_)) -> do guard (not $ null a); return r) in partition 4 [1..10]
16:04:08 <lambdabot>   [[1,2,3,4],[5,6,7,8],[9,10]]
16:04:48 <cads> what the blimey..
16:05:07 <cads> we do not need to get the @ sign involved in it!
16:05:48 <cads> I didn't know you could put a pattern in a lambda
16:06:16 <aavogt> lambdas are patterns
16:06:20 <aavogt> have
16:08:08 <cads> I know that for simpler constructors like (:) and (,)
16:08:26 <EvanR> is there a data type for 'bitflags'
16:08:32 <EvanR> a set i suppose
16:08:56 <EvanR> something which is as good as bitflags for set testing
16:09:01 <cads> @type (\(splitAt n -> r@(a,_))
16:09:02 <lambdabot> parse error (possibly incorrect indentation)
16:09:27 <cads> @type (\(splitAt n -> r@(a,_)) -> do guard (not $ null a); return r)
16:09:28 <lambdabot>     Illegal view pattern:  (splitAt n -> (r@(a, _)))
16:09:29 <lambdabot>     Use -XViewPatterns to enable view patterns
16:09:46 <aavogt> > let partition n (splitAt n -> (a,b)) | [] <- a = Nothing | otherwise = a : partition n b in partition 4 [1..10]
16:09:47 <lambdabot>   Couldn't match expected type `[[a]]'
16:09:47 <lambdabot>         against inferred type `Data.Ma...
16:10:11 <aavogt> > let partition n (splitAt n -> (a,b)) | [] <- a = [] | otherwise = a : partition n b in partition 4 [1..10]
16:10:12 <lambdabot>   [[1,2,3,4],[5,6,7,8],[9,10]]
16:11:02 <aavogt> that's odd how @type and @run don't have some coherent set of flags for mueval
16:11:44 <aavogt> > let partition n (splitAt n -> (a,b)) = do a; return $ a : partition n b in partition 4 [1..10]
16:11:45 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
16:11:55 <aavogt> > let partition n (splitAt n -> (a,b)) = do a; a : partition n b in partition 4 [1..10]
16:11:57 <lambdabot>   [[1,2,3,4],[5,6,7,8],[9,10],[9,10],[5,6,7,8],[9,10],[9,10],[5,6,7,8],[9,10]...
16:12:26 <aavogt> > let partition n (splitAt n -> (a,b)) = do take 1 a; a : partition n b in partition 4 [1..10]
16:12:27 <lambdabot>   [[1,2,3,4],[5,6,7,8],[9,10]]
16:14:48 <aavogt> EvanR: there's Data.Bits if you want that...
16:15:02 <EvanR> hm.
16:15:44 <cads> so the  f n (g n -> y) = h y    is of type   n -> y -> y'  where g: n - > y,  h: y -> y'?
16:16:16 <aavogt> cads: g takes 2 arguments
16:16:21 <cads> wait that's right
16:16:53 <aavogt> so   g :: n -> y -> y'
16:17:06 <cads> and h:y' -> y''
16:17:10 <aavogt> sure
16:17:22 <aavogt> there's no need to put any functions on the RHS anymore
16:17:54 <aavogt> @quote view.pattern
16:17:54 <lambdabot> benmachine says: let (\x -> case x of (\x -> x -> x) -> x -> x) = 0 in x / best view pattern evar
16:18:35 <cads> why not write f n x = h . g $ x?
16:18:47 <fax> f n = h . g is nicer
16:18:50 <aavogt> that's not the same
16:18:56 <orclev> @hoogle [m [a]] -> m [[a]]
16:18:56 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
16:18:56 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
16:18:56 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
16:18:58 <cads> oh. right
16:19:20 <cads> eta reduction!
16:19:40 <aavogt> well I mean that you aren't giving g the n
16:19:52 <aavogt> also, pattern mathcing
16:20:24 <cads> oh shoot
16:20:36 <cads> I'm all sorts of wrong on that
16:20:54 <orclev> hmm... since [] is a monad, couldn't sequence technically be generalized to m1 m2 a -> m2 m1 a?
16:21:12 <fax> orclev no
16:21:13 <aavogt> you need parens around (m2 a)
16:21:19 <aavogt> and  (m1 a)
16:21:25 <aavogt> otherwise it means something else
16:21:28 <fax> orclev lists are special
16:22:10 <orclev> ah, there seems to be an awful lot of special cases with monads...
16:22:20 <cads> lets see   f n (g n -> y) = h y     ===    f n = h . (g n) ?
16:22:21 <fax> it's not about monad
16:22:21 <aavogt> it works for some m1, like [], Maybe, Data.Sequence.Seq
16:22:29 <fax> list being a monad doesn't come into it
16:22:34 <aavogt> so there's a class for those in Data.Traversable
16:22:36 <fax> that's' why it can't generalize
16:22:43 <EvanR> can a variable be named default
16:22:44 <applicative> I was going to say, sequenceA :: Applicative f => t (f a) -> f (t a)
16:23:27 <cads> @type (\n (g n -> y) -> h y)
16:23:28 <lambdabot>     Illegal view pattern:  (g n -> y)
16:23:28 <lambdabot>     Use -XViewPatterns to enable view patterns
16:23:57 <aavogt> the h is strictly unnecessary here
16:23:58 <Cale> oops, sorry about that. I should probably update the type plugin to allow view patterns as well
16:23:59 <orclev> hmm... so it can generalized to Applicative?
16:24:09 <applicative> is a method of Traversable
16:24:26 <orclev> ah, I see
16:24:27 <applicative> so it looks like, that you can do a sequencey thing is a further constraint?
16:24:31 <aavogt> @hoogle sequenceA
16:24:31 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
16:24:31 <lambdabot> Data.Foldable sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
16:24:56 <Kaidelong> so today the professor corrected the word "peek" in my example for a stack to "peak" because he didn't think "peek was a word in the English language"
16:25:12 <orclev> Kaidelong: you're kidding right?
16:25:14 <Kaidelong> No
16:25:24 <aavogt> in the professor's english language
16:25:34 <fax> orclev, travesable basically means list-like
16:25:35 <Kaidelong> His English leaves something to be desired
16:25:54 <EvanR> people arent allowed to be elitist about english
16:25:56 <fax> orclev, it's not a generalization in the sense you mentiond (to monad)
16:26:15 <Kaidelong> He's not being elitist, he just didn't know what the word "peek" meant
16:26:22 <Kaidelong> I had to explain it later
16:26:33 <aavogt> are there Traversable that are not Monad, fax?
16:26:44 <EvanR> > peek = inverse poke
16:26:45 <lambdabot>   <no location info>: parse error on input `='
16:27:14 <aavogt> they could have called it peep
16:27:22 <applicative> @instances Traversable
16:27:23 <lambdabot> Couldn't find class `Traversable'. Try @instances-importing
16:27:55 <aavogt> oh, Array
16:28:15 <applicative> fax, the instances in Control.Traversable are Maybe,List, Array i and StateR s a = StateR { runStateR :: s -> (s, a) }
16:28:42 <orclev> hmm... Maybe is an instance of traversable... I never really considered maybe to be "list like"... wonder how that works
16:29:02 <aavogt> a list of at most one element
16:29:08 <applicative> ... and of course newtype Id a = Id { getId :: a }  very easy to traverse
16:29:18 * hackagebot hfov 1.0.1 - Field-of-view calculation for low-resolution 2D raster grids.  http://hackage.haskell.org/package/hfov-1.0.1 (JeremyApthorp)
16:31:20 <applicative>  sorry, the state thing isn't traversable of course; readng too quickly
16:31:55 * BMeph perversely likes the definition: data List a = Maybe (nonEmptyList a)... ;)
16:32:03 <applicative> ...so we are left with Maybe, List, Array and Id, and fax is clearly right.
16:33:03 <BMeph> Off to home; TTYL..
16:34:01 <fax> bye
16:38:02 <orclev> hmm... interesting... so, even if something is Nothing, ghci refuses to print it if it thinks it's of type Maybe GHC.Prim.Any
16:38:59 <Miller`> noob question: What's the haskell way to read 10::Int and 20::Int out of "10 20"?
16:39:19 <EvanR> words
16:39:37 <mauke> > map read . words $ "10 20" :: [Integer]
16:39:38 <lambdabot>   [10,20]
16:40:08 <Miller`> ah, thank you very much
16:40:13 <applicative> > words $ "10 20"
16:40:13 <lambdabot>   ["10","20"]
16:40:36 <orclev> why the $?... words "10 20" would seem to suffice
16:40:52 <applicative> cut and paste; so dishonorable
16:40:56 <orclev> lol
16:41:08 <mauke> > map read . words "10 20" :: [Integer]
16:41:09 <lambdabot>   Couldn't match expected type `GHC.Integer.Internals.Integer'
16:41:09 <lambdabot>         agains...
16:41:10 <EvanR> you lack discipline
16:41:32 <mauke> > read . words "10 20" :: [Integer]
16:41:33 <lambdabot>   [10,20]
16:41:41 * mauke cackles
16:42:31 <orclev> hmm... interesting that read seems to automatically map over [String]
16:42:44 <orclev> :hoogle read
16:42:46 <aavogt> no, that's (.)
16:42:46 <orclev> bah
16:42:50 <orclev> @hoogle read
16:42:50 <lambdabot> Prelude read :: Read a => String -> a
16:42:50 <lambdabot> Text.Read read :: Read a => String -> a
16:42:50 <lambdabot> module Text.Read
16:43:06 <orclev> @hoogle (.)
16:43:06 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
16:43:06 <lambdabot> Control.Category (.) :: Category cat => cat b c -> cat a b -> cat a c
16:43:06 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
16:43:22 * hackagebot CheatSheet 2.3 - A Haskell cheat sheet in PDF and literate formats.  http://hackage.haskell.org/package/CheatSheet-2.3 (JustinBailey)
16:43:49 <aavogt> @type (.)
16:43:50 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:44:20 <orclev> how does (.) contribue that magic, I thought conceptually read . words was equivalent to (\x -> read (words x))
16:44:51 <aavogt> > read `map` words "10 20"
16:44:53 <lambdabot>   [*Exception: Prelude.read: no parse
16:44:56 <mauke> orclev: this is a different (.)
16:44:59 <aavogt> > read `map` words "10 20" :: [Int]
16:45:00 <lambdabot>   [10,20]
16:50:24 * hackagebot CheatSheet 2.4 - A Haskell cheat sheet in PDF and literate formats.  http://hackage.haskell.org/package/CheatSheet-2.4 (JustinBailey)
16:53:10 * syntaxglitch is sick of dealing with moving to a new apartment, it's really cutting into his Haskell time :(
16:55:20 <c_wraith> Somehow, I'm not convinced Justin Bailey is not a pseudonym
16:55:36 <mauke> metroid?
16:55:40 <c_wraith> indeed
16:56:07 <c_wraith> But I'm looking at the name of the uploader on that last hackagebot message
16:56:51 <syntaxglitch> it's not like there aren't other people using pseudonyms for hackage accounts
17:09:58 <lispy> Is Justin Bailey an anagram for anything?
17:10:23 <lispy> I've always wondered why it ended up in metroid as a code to unlock stuff
17:11:22 <tensorpudding> Maybe Justin Bailey was involved in Metroid?
17:11:33 <EvanR> write a haskell to solve for possible anagrams
17:12:27 <lispy> http://www.loadingreality.com/The-Codex/The-Codex-Metroid-s-JUSTIN-BAILEY-Mystery.html
17:12:37 <lispy> according to them, Justin Bailey was not a dev
17:12:57 <c_wraith> hah.  I searched for anagram on google
17:13:03 <c_wraith> that amused me
17:13:21 <syntaxglitch> heh
17:13:46 <Rotaerk> heh
17:13:50 <syntaxglitch> that's almost as good as the recursion one
17:23:29 <EvanR> module imports form a cycle for modules
17:23:44 <EvanR> i thought this thing was supposed to be recursive damimt
17:24:05 <aavogt> they are allowed
17:24:39 <EvanR> seems like an error to me
17:25:30 <aavogt> you need to write some hs-boot files though
17:25:49 <mauke> http://haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
17:27:39 <EvanR> eh, cant the compiler do this for me
17:28:13 * syntaxglitch wonders if it's a bad sign to be heavily documenting code he wrote three days ago because he's pretty sure he won't understand it anymore three more days from now otherwise
17:29:34 <EvanR> maybe there is something fundamentally wrong if i require cyclic imports?
17:30:06 <EvanR> only fundamentally wrong things are this cumbersome in haskell :)
17:30:32 <aavogt> you can avoid cyclic imports by rearranging your code
17:30:33 <syntaxglitch> EvanR, oh dear, then I think the code I'm working on is very, very wrong indeed
17:30:47 <mauke> well, this is a ghc issue, not haskell
17:30:50 <aavogt> either into one module or put the common definitions into a third module
17:31:03 <EvanR> right, somehow combine stuff
17:31:05 <EvanR> thats what i did
17:31:52 <syntaxglitch> aavogt, speaking of my horrible code, you were interested in type-level metaprogramming hackery last time I mentioned it, weren't you?
17:32:14 <aavogt> there was metaprogramming involved?
17:32:31 <syntaxglitch> well, sort of
17:32:46 <syntaxglitch> I've been working on a type-level programming library of sorts
17:33:19 <aavogt> but yes, I was and still am interested
17:33:53 <EvanR> is there a ghci flag which will also load in any imports of the file you loaded
17:34:14 <syntaxglitch> want to take a look at a preliminary version for me sometime... ehh, next week-ish? If I'm showing this to other people, I'd like some critiques as well if possible...
17:34:25 <syntaxglitch> I'm prolly gonna get it tossed up onto github or something
17:34:57 <aavogt> sure
17:35:37 <syntaxglitch> most of the internals are in place, minus some non-critical features, some gaps in validation/error messages, and a couple performance issues
17:36:24 <syntaxglitch> after I at least track down the performance problem and bash out some proof-of-concept code using it I'll drop you line
17:42:41 <jbapple> small programs that have errors are said to generally fail on some small input
17:42:52 <jbapple> hence the existence of smallcheck
17:43:19 <jbapple> But I have a small program that fails on a list of length 68
17:43:21 <jbapple> not 67
17:43:39 <jbapple> not any of [1..66]
17:44:05 <EvanR> try removing the line that says if length ls > 67 then undefined else correctValue where...
17:44:15 <jbapple> I miss Buddha.
17:45:28 <jmcarthur> jbapple: this is why i try to stick with a combination of quickcheck and smallcheck
17:46:06 <dolio> jbapple: The debugger?
17:46:10 <Cale> jbapple: What about 69 or 70?
17:47:03 <jbapple> jmcarthur: I agree.
17:47:30 <Cale> What's this program?
17:47:38 <jbapple> dolio: Yes. I have no experience with any other Buddhas. The debugger set a pretty high standard for how awesome Buddhas are, though.
17:47:44 <Cale> hmm, 68 is 44 hexadecimal...
17:48:11 <EvanR> > 68 - 42
17:48:12 <lambdabot>   26
17:48:13 <dolio> Heh. I'd never heard of anyone who used it. "Declarative debugger" sounds good, though.
17:48:20 <Cale> EvanR: ah, good point
17:48:21 <jbapple> Cale: Cale: fails for all values greater than 68 that I have tested
17:48:47 <jbapple> Cale: the tests are cumulative, though, so if 68 fails, there would have to be an inverse bug to cause x>68 to work
17:49:04 <jbapple> dolio: It was the best debugger I have every used in any environment
17:49:09 <jmcarthur> what about 68*2 or 68^2?
17:49:10 <jbapple> (!)
17:49:11 <Cale> jbapple: I'm sort of curious about what this program does
17:49:15 <jbapple> It was simply awesome
17:49:36 <jbapple> Cale: I'm committing now so you can take a look
17:49:49 <jbapple> short answer: a finger tree with O(1) approximate split
17:50:03 <jmcarthur> wuh?
17:51:05 <jbapple> Cale: beware, no documentation: https://code.google.com/p/three-finger-trees/source/browse/Spinal.hs
17:51:34 <EvanR> @src tail
17:51:34 <lambdabot> tail (_:xs) = xs
17:51:34 <lambdabot> tail []     = undefined
17:52:18 <jbapple> jmcarthur: "approximate split" should split a finger tree into two finger trees each with the same height, and so approximately the same number of elements
17:52:35 <jbapple> Cale: forgot hg push, try again
17:52:45 <jmcarthur> ah
17:53:04 <jmcarthur> i was thinking the normal finger tree split operation
17:53:09 <Cale> okay, so it's not a *particularly* simple program :)
17:53:33 <jbapple> jmcarthur: as for your earlier question, yes, it fails for 68*2 and 68*68
17:54:09 <jbapple> Cale: Yes, not too simple 110 lines (includes whitespace) can do quite a lot!
17:54:11 <jmcarthur> okay, so multiples of 68 then?
17:54:47 <jmcarthur> > map (68/) [4,3,2,1]
17:54:48 <lambdabot>   [17.0,22.666666666666668,34.0,68.0]
17:55:03 <mightybyte> Anyone know what would cause this error when I "cabal install" gitit?
17:55:05 <mightybyte> Linking dist/build/gitit/gitit ...
17:55:05 <mightybyte> <command line>: unknown package: hslogger-1.0.7
17:55:06 <jbapple> jmcarthur: You may have missed above where I noted that the tests are cumulative; specifically [1..n] == fromList $ toList [1..n]
17:55:18 <jbapple> so all values greater than 68 that I have tested fail
17:55:27 <mightybyte> ghc-pkg shows that I have hslogger-1.0.10 installed.
17:55:38 <dcoutts_> mightybyte: solution: cabal clean; cabal configure; cabal build
17:55:40 <dolio> jbapple: Does it depend on GHC in some broken way? Or is the only problem with it that it only works for H98?
17:55:42 <jmcarthur> oh, i thought you were saying they were succeeding and that led you the believe the bug was self-correcting after 68
17:55:51 <mightybyte> dcoutts_: Ok, thanks.
17:55:59 <dcoutts_> mightybyte: you've got existing .hi files that were built against hslogger-1.0.7, so it looks for that when linking
17:56:36 <mightybyte> dcoutts_: Ahh, that makes sense.  I thought I had tried cleaning, but maybe I didn't.
17:56:51 <mightybyte> dcoutts_: Hmmm, same error.
17:57:09 <jbapple> dolio: I don't think it does. I think the error is all mine; GHC is probably not to blame. My file loads in GHCi without any language flags
17:57:27 <Cale> jbapple: Have you tried using hpc?
17:57:51 <Cale> jbapple: That might be able to tell you what the difference in used code is between the smaller test cases and the 68 case is.
17:57:56 <Cale> er, -is
17:58:03 <jbapple> Cale: Great idea!
17:58:11 <mightybyte> dcoutts_: Would that be because some dependency has file built against hslogger-1.0.7?
17:58:23 <dcoutts_> mightybyte: hmm, try ghc-pkg check, does it report any broken packages?
17:58:39 <mightybyte> dcoutts_: Nope
17:59:31 <dcoutts_> mightybyte: I'm stumped, the only place it should be recorded is in .hi files
17:59:36 <jmcarthur> huh good idea
17:59:48 <jmcarthur> i never use hpc
17:59:49 <dcoutts_> mightybyte: or package dependencies, but those would be marked broken if the package is unregistered
18:00:33 <mightybyte> dcoutts_: Yeah, I'm building gitit from source and it's got "hslogger >= 1 && < 1.1" which includes both the installed version and the one it's complaining about.
18:04:43 <mightybyte> dcoutts_: Would it be worth blowing away ~/.cabal and ~/.ghc and trying to reinstall from scratch?
18:04:56 <dcoutts_> mightybyte: worth a go
18:05:23 <mightybyte> dcoutts_: I had actually done that right before I got this build problem, but maybe if I start with gitit...
18:05:32 <dcoutts_> mightybyte: and rm -r dist/ just in case clean is failing or something
18:06:58 <mightybyte> Removing dist didn't fix it.
18:07:22 <jbapple> Sigh. hpc shows the exact same coverage with [1..67] as with [1..68]
18:09:16 <Cale> jbapple: I was just finding that out
18:10:17 <Axman6> hmm, is this valid? data Map k v = Tip | Bin !!Int !k v !(Map k v) !(Map k v), i'm wondering what the !! does
18:10:23 <mightybyte> dcoutts_: Why is it that sometimes "cabal install" won't chase down a dependency and I have to "cabal install" it by hand?
18:10:29 <jbapple> hpc does show a coverage difference between running the program with just 67 and just 68, but the differences are places where I am pretty confident there is no bug
18:10:34 <ezyang> Axman6: Is that from edwardk's slides?
18:10:38 <Axman6> yeah
18:10:41 <ezyang> I was kind of wondering what !! did too
18:10:43 <dcoutts_> mightybyte: you mean for build tools like happy/alex etc?
18:10:45 <dolio> Axman6: !! is what haddock generates when there's an UNPACK pragma.
18:10:53 <Axman6> huh, ok
18:10:55 <ezyang> oho.
18:11:10 <mightybyte> dcoutts_: Well, the one in question right now is HUnit.
18:11:19 <Axman6> so, if it initially said: data Map k v = Tip | Bin {-# UNPACK #-} !Int !k v !(Map k v) !(Map k v), it would become data Map k v = Tip | Bin !!Int !k v !(Map k v) !(Map k v)
18:11:23 <ezyang> I guess it would be kind of cute if GHC supported that
18:11:28 <dcoutts_> mightybyte: it should always track down libraries that are dependencies
18:11:31 <dolio> Yes.
18:11:35 <Cale> jbapple: In toLspine, the case on y only shows the R1 branch being taken. Is that right?
18:11:37 <Axman6> interesting
18:12:11 <dolio> I'm not sure if it's intentional or what.
18:12:12 <dcoutts_> mightybyte: you might be using an interim version of cabal-install that had a bug about optional dependencies
18:12:35 <mightybyte> dcoutts_: Ahhhh...
18:12:52 <mightybyte> cabal-install version 0.8.0
18:12:59 <dcoutts_> right, try upgrading
18:13:10 <Cale> (I'm not really sure what toLspine even does...)
18:13:30 <jbapple> Cale: not in general, but perhaps when the structure is constructed using only conses
18:15:15 <jbapple> Cale: the structure is represented as either (A, left spine) 1-4 values (a digit) and a deque of right spines, or (B, right spine) 1-4 values and a deque of left spines
18:15:44 <jbapple> Cale: If we were at a blackboard, I would draw you a picture.
18:16:32 <dcoutts_> mightybyte: actually it wasn't optional deps, it was deps of tests progs where the test progs do not get built. I was trying to avoid pulling in deps (like HUnit) if we were not going to build the test progs, however it turned out to be harder than I thought and I had to revert it.
18:16:35 <jbapple> Here is what it looks like when I draw it with my finger on my keyboard: xdr5zcthgnfv or mju7n,yghbn
18:16:35 <jbapple> I'm sure that helps immensely
18:17:21 <gwern> forget it man. it's chinatown
18:18:07 <jbapple> I'm going to try vacuum-cairo to help me see if something funny is going on
18:19:07 <Cale> jbapple: The problem appears to be just that the elements are ending up in the wrong order, not that any get missed.
18:19:18 <jbapple> I agree
18:19:35 <Cale> jbapple: Probably just checking each case to ensure that the elements' order is preserved might help.
18:19:38 <EvanR> is there a better way to write do x <- action; replicateM_ x $ do....
18:19:53 <jbapple> Cale: I agree, but I think that may take a long time
18:20:13 <mightybyte> dcoutts_: Ahh, I see.
18:20:32 <jbapple> BTW, everyone, I don't remember how I fixed this last time I had to install vacuum-cairo:
18:20:32 <jbapple> $ haskinst vacuum-cairo
18:20:32 <jbapple> Resolving dependencies...
18:20:32 <jbapple> cabal: cannot configure vacuum-cairo-0.4.1. It requires cairo -any, gtk -any
18:20:32 <jbapple> and svgcairo -any
18:20:38 <mightybyte> dcoutts_: It doesn't look like a more recent version is available for Arch Linux anyway.
18:20:46 <mightybyte> dcoutts_: That issue isn't the end of the world.
18:20:59 <dcoutts_> mightybyte: easy, cabal install 'cabal-install > 0.8'
18:21:26 <dcoutts_> erm > 0.8.0  :-)
18:21:46 <dcoutts_> since 0.8.0 > 0.8
18:22:03 <aavogt> jbapple: you need gtk2hs
18:22:17 <mightybyte> Ok, that does it.  Leaving out the "> 0.8" didn't work for some reason.
18:22:19 <Cale> jbapple: In all your data structures, do the elements go syntactically in their logical order in the structure?
18:22:22 <jbapple> aavogt: thanks
18:22:43 <Cale> (it would help me to check if I knew that this were the case :)
18:22:54 * Kaidelong wishes darcs would build on windows already
18:22:56 <dcoutts_> mightybyte: default version is still 0.6.x, I'm going to switch that default soon since I think 0.8.2 is now good enough
18:22:57 <jbapple> Cale: the digits come before the rest of the LSpine in RSpine
18:23:09 <Kaidelong> maybe I should try for an older version
18:23:19 <mightybyte> dcoutts_: Hmmm, 0.8.2 just got installed, but cabal --version says 0.8.0
18:23:26 <dcoutts_> mightybyte: check your $PATH
18:23:26 <Cale> jbapple: Hmm, so perhaps I should swap that around in the code, just to keep myself sane :)
18:23:29 <jbapple> Cale: I should probably change the definition so it is the smae semantically and syntactically..
18:23:36 <mightybyte> dcoutts_: I did.
18:23:36 <jbapple> Cale: :-)
18:23:48 <mightybyte> "which cabal" points to the new one.
18:24:02 <dcoutts_> mightybyte: then try hash -r ?
18:24:23 <mightybyte> dcoutts_: Oh, woah.  which cabal is right, but just running "cabal" is wrong.
18:24:29 <mightybyte> That seems strange.
18:24:35 <jbapple> Cale: The same is true of RConc
18:24:36 <dcoutts_> does hash -r help?
18:25:02 <mightybyte> dcoutts_: The new one is installed if I explicitly run ~/.cabal/bin/cabal
18:25:09 <jbapple> Cale: or, rather, the digit should come after the rspine
18:25:21 <dcoutts_> mightybyte: yes, and does running hash -r help?
18:27:19 <mightybyte> dcoutts_: I just took the brute force approach and removed the old version. :)
18:28:25 <dcoutts_> mightybyte: hash -r tells bash to flush its name -> path cache
18:28:28 <mightybyte> dcoutts_: Ok, it still aborts on HUnit until I install it manually.  But at least I understand that behavior now.
18:28:47 <dcoutts_> mightybyte: what, using cabal-install-0.8.2 ?
18:28:50 <mightybyte> dcoutts_: Ahh, I never knew about that command.
18:28:51 <mightybyte> Yes
18:29:17 <dcoutts_> mightybyte: can you find me a reproducible case? that should not happen
18:29:26 <dcoutts_> I fixed the case I knew about in version 0.8.2
18:30:19 <dcoutts_> mightybyte: output from cabal install blah --dry-run -v and then the verbose log of it actually failing to install because of the HUnit dep would help.
18:30:22 <jbapple> Cale: I think I found the bug
18:30:25 <mightybyte> Well, it is consistently reproduced for me by blowing away ~/.cabal and ~/.ghc and then installing the latest darcs version of happstack.
18:30:54 <jbapple> Cale: Line 46/51 Moving the digit past the spine illegally
18:31:07 <jbapple> Cale: That's a foul
18:31:20 <mightybyte> Then the same thing happens later in the happstack install for Quickcheck ==2
18:31:36 <dcoutts_> mightybyte: if you have time to post a log (with -v) that'd be great
18:31:54 <dcoutts_> mightybyte: see that sounds just like what I'd expect from version 0.8.0, but not 0.8.2
18:33:21 <mightybyte> dcoutts_: Give me a bit and I'll try to get that together for you.  It's a little more cumbersome since I'm using happstack's build script to build all the subprojects.
18:37:49 <[swift]1> i'm doing a lot of FIFO queue-like operations (reading from front of list, appending to end), and unsurprisingly lists seem pretty slow for this. i've been looking at switching to Data.Queue, but if there are any better choices i'd be interested to hear about them.
18:38:09 <Cale> [swift]1: You can use Data.Sequence as a pretty fast queue
18:38:26 <byorgey> [swift]1: what package is Data.Queue from?
18:38:47 <[swift]1> Cale: cool, i'll check it out
18:39:05 <[swift]1> byorgey: it appears to be in base
18:40:04 <[swift]1> byorgey: huh, not coming up on hoogle, though. looks like the haddock i'm looking at is from ghc 6.4.. maybe they got rid of it now?
18:40:05 <byorgey> [swift]1: really? I have never heard of it before =)
18:40:11 <byorgey> oh, perhaps
18:40:14 <Cale> oh
18:40:15 <byorgey> 6.4 is quite old
18:40:18 <EvanR> interesting queue, use two lists as the 'front and back' when you dequeue and none left in front, reverse ;)
18:41:05 <[swift]1> byorgey: here's the haddock btw (it came up on a google search) http://haskell.org/ghc/docs/6.4/html/libraries/base/Data.Queue.html
18:41:21 <[swift]1> EvanR: that's pretty elegant!
18:41:41 <Cale> Yeah, I think that's called a banker's queue
18:41:58 <jbapple> bankers queue reverses more often
18:42:09 <Cale> ah, okay
18:42:22 <jbapple> for efficiency/amortization reasons
18:42:23 <EvanR> does what i said have a name?
18:43:30 <jbapple> Okasaki may have a name for them
18:44:27 <jbapple> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
18:44:30 <[swift]1> huh, Data.Sequence has an interesting API. are you meant to construct one of these "views" every time you want to read items out of it?
18:44:46 <mightybyte> dcoutts_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25222#a25222
18:44:53 <dcoutts_> Cale: bankers queues work well with persistence iirc, where as normal queues do not. If you save the queue just before it has to do O(n) reverse, then all dequeues from that point have to pay O(n). You loose the amortisation argument.
18:45:02 <mightybyte> dcoutts_: That help?
18:45:59 <dcoutts_> mightybyte: and it's definitely version 0.8.2 you're using there?
18:46:14 <mightybyte> Yep
18:46:22 <mightybyte> Got that guaranteed
18:47:19 <Cale> http://www.eecs.usma.edu/webs/people/okasaki/jfp95.ps
18:47:30 <Cale> ^^ More Okasaki on queues specifically
18:48:20 <dcoutts_> mightybyte: would you mind running that with -v3? I'm interested in the flags it's using when it configures happstack-util
18:49:11 <mightybyte> Sure
18:49:15 <dcoutts_> mightybyte: ah, wait a sec
18:49:29 <dcoutts_> mightybyte: what version of the Cabal lib does cabal-install say it was built against?
18:50:21 <mightybyte> dcoutts_: One moment
18:50:30 <mightybyte> using version 1.8.0.2 of the Cabal library
18:50:43 <dcoutts_> mightybyte: ok, try cabal install Cabal cabal-install-0.8.2
18:50:58 <mightybyte> Ok
18:51:06 <Cale> [swift]1: Yeah, you just  case viewL mySequence of EmptyL -> ...; x :< xs -> ...
18:51:42 <Cale> [swift]1: You might like to use the ViewPatterns extension for that :)
18:52:01 <Cale> foo (viewL -> EmptyL) = ...
18:52:07 <Cale> foo (viewL -> x :< xs) = ...
18:53:23 <[swift]1> Cale: yeah, that looks a lot more convenient with ViewPatterns
18:54:37 <dcoutts_> mightybyte: sorry about that, I now recall that the fix for the problem I mentioned is actually in the Cabal lib, not in cabal-install.
18:54:50 <mightybyte> dcoutts_: No problem
18:55:52 <mightybyte> dcoutts_: Hmmm, getting rid of Cabal-1.8.0.2 looks to be difficult.
18:56:03 <dcoutts_> mightybyte: no need to get rid of it
18:56:10 <dcoutts_> mightybyte: having both is ok
18:56:29 <mightybyte> I just ran the command you said, but it said cabal-install-0.8.2 was built against Cabal-1.8.0.2
18:57:23 <dcoutts_> mightybyte: hmm, try cabal install Cabal-1.8.0.4 cabal-install-0.8.2
18:58:06 <mightybyte> dcoutts_: Oh, there we go.  Same path problem.
18:58:13 <dcoutts_> ok good
18:58:39 <dcoutts_> specifying the package name as a target (should) make cabal pick the best version, not just the installed version
18:59:29 <dcoutts_> mightybyte: btw, I filed a ticket about the path issues http://hackage.haskell.org/trac/hackage/ticket/670
18:59:29 <mightybyte> Oh great
18:59:30 <mightybyte> darcs: ioManagerWakeup: write: Bad file descriptor
19:00:02 <[swift]1> just took a look at Haskell 2010 and I see that PatternGuards made it in (which is great) but not ViewPatterns (too recent I guess? don't see them in the haskell-prime trac at all)
19:00:36 <aavogt> PatternGuards is quite old
19:01:26 <Makoryu> http://pastebin.com/XK8s23aX <- Truly, this bard is a genius with metaphors
19:01:40 <mightybyte> dcoutts_: Looks like it's working with this version of Cabal.
19:01:54 <mightybyte> ...but still not finished yet.
19:03:05 <dcoutts_> mightybyte: ok phew! sorry about all that
19:04:47 <mightybyte> dcoutts_: Yeah, everything looks pretty good.  It got way further this time.  Stopped on happy, but that's because I'm using a new user that doesn't have .cabal/bin in its path.
19:05:30 <dcoutts_> which also is arguably a bug, we should look in the target bindir, even if it's not on the $PATH
19:05:40 <dcoutts_> that one's been filed previously
19:06:06 <mightybyte> That would definitely help the average joe end user.  I had a Haskell newcomer ask me about that one just the other day.
19:06:36 <dcoutts_> aye, that and actually using build-tools dependencies so it installs happy in the first place
19:06:44 <dcoutts_> so much to do
19:06:51 <mightybyte> Yeah
19:07:53 <mightybyte> Hmmm, that happened again on my normal user that does have .cabal/bin in the path.
19:08:16 <dcoutts_> mightybyte: what happened again?
19:09:35 <mightybyte> dcoutts_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25223#a25223
19:10:16 <dcoutts_> mightybyte: what does /usr/local/bin/happy --version say?
19:11:02 <dcoutts_> mightybyte: it also gives a bit more info if you use higher verbosity, about what it was unable to parse as a version number.
19:11:04 <mightybyte>  /usr/local/bin/happy: error while loading shared libraries: libgmp.so.3: cannot open shared object file: No such file or directory
19:11:12 <dcoutts_> ok :-)
19:11:23 <mightybyte> Heh, apparently that's really old since I've been doing everything in my local directory.
19:11:55 <mightybyte> A manual "cabal install happy" puts me on my way.
19:12:35 <dcoutts_> mightybyte: so perhaps cabal should have said that happy is broken rather than just that it can't work out the version number
19:12:38 <dmwit> mightybyte: Sounds like you recently updated an Arch system!
19:12:48 <mightybyte> Yeah
19:12:49 <dmwit> mightybyte: You may need to manually reinstall a bunch of stuff. =)
19:13:06 <mightybyte> :(
19:13:09 <dmwit> (depending on how much you use pacman and how much you use cabal)
19:13:24 <mightybyte> I've been getting by just fine though since I've learned what that pattern typically means.
19:13:28 <dmwit> I use cabal exclusively for Haskell stuff, so I had to rebuild everything. You might be in better shape if you rely on pacman more.
19:13:38 <mightybyte> ...and which libraries install binaries
19:13:54 <mightybyte> dmwit: Well, relying on pacman is part of the reason I'm having this conversation.
19:14:11 <mightybyte> pacman didn't keep me as up to date with Cabal and cabal-install as I expected.
19:14:18 <dmwit> yeah
19:14:47 <dmwit> Oh, dcoutts is here.
19:15:06 <matt_m> Is there any reason I can overload operator *:* and operator :+: but not operator :*: ?
19:15:41 <dmwit> dcoutts_: What's the usual thing for cabal scripts that need certain libraries to be installed to even compile Setup.hs?
19:16:08 <dmwit> dcoutts_: e.g. encoding's Setup.(l)hs imports an XML library.
19:16:22 <byorgey> matt_m: I'm surprised you can overload :+:
19:16:32 <dmwit> encoding.cabal includes that library in its build-depends, but it doesn't even get to the point where it's reading the .cabal file.
19:17:40 <dcoutts_> dmwit: the usual thing is that that does not work
19:18:07 <dmwit> okay =)
19:18:10 <dcoutts_> dmwit: it might work with cabal-install because it'll install deps first, but there's nothing you can do about people running the Setup.hs directly
19:18:31 <dcoutts_> dmwit: and they have every right to expect that to work, the only solution is not to use non-standard packages in Setup.hs
19:18:51 <mightybyte> dcoutts_: And all that brings us back to my original problem with the linker problem with hslogger-1.0.7
19:19:08 <dcoutts_> dmwit: we might do something about that in the Cabal 2 design, since we can deprecate Setup.hs as being the primary user interface, it can become merely a machine interface.
19:19:08 <dmwit> dcoutts_: Would you consider it a reasonable request to add to the Trac for "cabal install" to work?
19:19:17 <dmwit> ah, okay
19:19:34 <dcoutts_> dmwit: does it not work with cabal-install?
19:19:39 * dmwit nods
19:20:08 <applicative> matt_m, what symptoms are you getting with :*: ?
19:21:28 <byorgey> matt_m: operators beginning with : are reserved as names for type constructors
19:21:42 <byorgey> matt_m: just like uppercase identifiers
19:21:57 <byorgey> but yes, I'm also curious what error message you're getting
19:22:57 <applicative> i was wondering if, if  :+:  was okay but  :*: not, that one was a TypeOperator; but you can't do that by accident....
19:23:43 <dcoutts_> dmwit: if it does not work, we should look into why, since cabal will make sure HaXml is installed, so it should be available when compiling the Setup.hs
19:24:51 <dcoutts_> dmwit: cabal does not hide all packages when compiling the Setup.hs, so it should work
19:26:19 <mightybyte> dcoutts_: So I still get this hslogger-1.0.7 problem even when I cabal clean and set the gitit dependency to hslogger >= 1.0.10
19:27:04 <dcoutts_> mightybyte: perhaps it's in one of the global packages
19:27:19 <mightybyte> dcoutts_: How would I track that down?
19:27:22 <dcoutts_> mightybyte: you're sure you cleaned local packages you're hacking on?
19:28:04 <dcoutts_> mightybyte: libs that gitit depends on that you've been hacking on
19:28:33 <mightybyte> Hmmmmm, maybe I didn't clean happstack.
19:29:07 <mightybyte> That's the only local library I've been using.
19:29:24 <dcoutts_> mightybyte: if nothing else works, resort to grep hslogger-1.0.7 -R --yes-look-in-binary-files
19:29:28 * dcoutts_ has to go
19:31:02 <mightybyte> dcoutts_: Ok, thanks for the help.
19:33:33 <evan_arm> Hi #haskell!  Can I ask you guys a question about regexes?
19:34:54 <evan_arm> I'm trying to get all matches of a regex in a string
19:35:28 <aavogt> > "like this" =~ "(k).*(i)" :: [[String]]
19:35:29 <lambdabot>   [["ke thi","k","i"]]
19:36:11 <Makoryu> :t (=~)
19:36:12 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
19:36:13 <aavogt> it works with the pcre regex library
19:36:33 <aavogt> I don't think the posix one can give you back specific matches
19:36:41 <evan_arm> oh!  I'm not sure why it's a [[String]] and not a [String]
19:37:07 <aavogt> I'm not sure either
19:37:16 <Makoryu> Will it work as a [String]?
19:37:27 <byorgey> because it can match in multiple ways, and each way of matching gives you back a list of the captured pieces?
19:37:27 <aavogt> > "like this" =~ "(k).*(i)" :: [String]
19:37:28 <lambdabot>   No instance for (Text.Regex.Base.RegexLike.RegexContext
19:37:28 <lambdabot>                    ...
19:37:52 <Makoryu> > "Will it blend?" =~ "Nope" :: Bool
19:37:53 <aavogt> > "like this" =~ "(k|e).*(i)" :: [[String]]
19:37:53 <lambdabot>   False
19:37:54 <lambdabot>   [["ke thi","k","i"]]
19:38:12 <byorgey> hmm, I guess not
19:38:38 <Makoryu> > "Will it blend?" =~ "(Will|it|blend|[?])" :: [[String]]
19:38:39 <lambdabot>   [["Will","Will"],["it","it"],["blend","blend"],["?","?"]]
19:39:03 <Axman6> :o
19:39:20 <aavogt> there's a whole bunch of newtypes for looking at the results differently
19:39:28 <aavogt> @docs Text.Regex
19:39:28 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Regex.html
19:39:33 <aavogt> :(
19:39:42 <evan_arm> What I was actually hoping to do was a search and replace, so I was hoping to get (offset, length) pairs
19:39:54 <evan_arm> But this is also hlepful.
19:41:09 <aavogt> > "Will it blend?" =~ "(Will|it|blend|[?])" :: [MatchArray]
19:41:10 <lambdabot>   [array (0,1) [(0,(0,4)),(1,(0,4))],array (0,1) [(0,(5,2)),(1,(5,2))],array ...
19:41:22 <aavogt> > "Will it blend?" =~ "(Will|it|blend|[?])" :: MatchArray
19:41:23 <lambdabot>   array (0,1) [(0,(0,4)),(1,(0,4))]
19:42:05 <Kaidelong> Haskell's array class impressed me with its generality
19:43:00 <evan_arm> aavogt: thanks.
19:43:10 <evan_arm> I tried to read the docs for this, but I was completely stumped.
19:43:12 <aavogt> > "Will it blend?" =~ "(Will|it|blend|[?])" :: MatchResult String
19:43:13 <lambdabot>   No instance for (GHC.Show.Show
19:43:13 <lambdabot>                     (Text.Regex.Base.RegexLi...
19:43:19 <evan_arm> Is there some trick to understanding them?
19:44:07 <jmcarthur> :t (=~)
19:44:08 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
19:44:13 <aavogt> stare at the list of instances for RegexContext and RegexLike
19:46:26 <aavogt> but perhaps it's better to understand simpler typeclasses like Monad first
19:48:00 <silva> boa noite a todos
19:52:05 <evan_arm> aavogt: I understand Monad.  Ish.  I think.
19:52:17 <gwern> stand back
19:52:21 <gwern> I know regexps!
19:52:28 <applicative> evan_arm, there was an excellent post by bos some time ago http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/ maybe it is too elementary for you?
19:53:37 <evan_arm> applicative: I found that, but most of the examples don't work for me
19:53:41 <evan_arm> That's when I came here
19:54:03 <Makoryu> evan_arm: http://noordering.wordpress.com/2009/03/31/how-you-shouldnt-use-monad/ <- Best Monad explanation evar, by the way.
19:54:49 <Makoryu> (Pay close attention to the examples)
19:54:52 <aavogt> continuations are boxes
19:55:14 <Makoryu> aavogt: Well stack frames *are* data structures....
19:55:55 <gwern> aavogt: worst analogy ever
19:55:56 <evan_arm> Makoryu: thanks.  I'm pretty solid on monads mechanically.  I just need to write more code.
19:56:03 <evan_arm> Which I'm working on :)
19:56:20 <ivanm> gwern: even worse than "monads are like burritos"?
19:56:47 <aavogt> gwern: it's a satire of Makoryu's link
19:57:04 <pikhq> Well, burritos are much like monads.
19:57:18 <evan_arm> So, um, do the examples in Bryan O'Sullivan's post work for everyone else?
19:57:39 <fryguybob> you don't eat monads, you run them?
19:58:01 <tensorpudding> monads over easy with a bit of pepper
19:58:19 <Trinithis> Monads eat YOU!
19:58:19 <Makoryu> 
19:58:21 <applicative> evan_arm, well, I'm no use, for some reason they are causing ghci + Text.Regex.Posix to crash with a segmentation fault after giving the right answser.
19:58:27 <fryguybob> @what monad
19:58:27 <lambdabot> I know nothing about monad.
19:58:31 <Trinithis> lol
19:58:32 <tensorpudding> you can't make a monadlette without unsafeCoercing a few IO's
19:58:36 <fryguybob> @what burrito
19:58:36 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
19:58:42 <fryguybob> tlol
19:58:50 <Trinithis> @what tlol
19:58:51 <lambdabot> I know nothing about tlol.
19:58:53 <evan_arm> applicative: Things like '"before foodiebar after" =~ pat :: (String,String,String)
19:58:57 <Axman6> g'day rankles
19:58:59 <fryguybob> typo lol?
19:59:00 <evan_arm> don't typecheck for me
19:59:02 <Trinithis> @what 666
19:59:02 <lambdabot> I know nothing about 666.
19:59:23 <Trinithis> @what anything..
19:59:24 <lambdabot> I know nothing about anything...
19:59:25 <Axman6> @what haskell
19:59:25 <lambdabot> http://haskell.org
19:59:43 <fryguybob> @what Nothing
19:59:43 <lambdabot> I know nothing about nothing.
19:59:50 <aavogt> > "before foodiebar after" =~ "foodie" :: (String,String,String)
19:59:51 <lambdabot>   ("before ","foodie","bar after")
19:59:55 <ivanm> hey Axman6
19:59:58 <Trinithis> @what love
19:59:58 <lambdabot> http://en.wikipedia.org/wiki/Where_Is_Love%3F
20:00:00 <Axman6> 'lo
20:00:02 <Trinithis> danm
20:00:18 <ivanm> heh
20:00:32 <edwardk> preflex: xseen jbapple
20:00:32 <preflex>  jbapple was last seen on freenode/#haskell 1 hour, 16 minutes and 5 seconds ago, saying: http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
20:00:39 <evan_arm> aavogt: huh.  Well, never mind.  I must've mistyped something, that works.
20:01:04 <ivanm> Axman6: so, get them all marked? :p
20:01:16 <Axman6> yeah, last weekend
20:01:29 <ivanm> just wait: next assignment coming up! :s
20:01:39 <jbapple> edwardk: heyHEYhey
20:01:54 <ivanm> jbapple: that's not how you're meant to use camelCase...
20:02:11 <ivanm> it should be "heyHeyHey" :p
20:02:14 <jbapple> "ivanM"
20:02:22 <ivanm> true...
20:02:22 <Trinithis> @what where he lives, but I know where his wife lives. I see her nightly
20:02:23 <lambdabot> ?where where
20:02:26 <Trinithis> fuck
20:02:28 <Trinithis> sry
20:02:38 <Trinithis> cyalls
20:02:42 <ivanM> Trinithis: huh?
20:02:44 <ivanM> @help what
20:02:45 <lambdabot> what <key>. Return element associated with key
20:02:45 <edwardk> jbapple: i saw you had more progress on the splittable fingertrees while i was sleeping ;)
20:03:18 <Pseudonym> (\(l,o) (l',o') -> (l+l',o+o')) -- Anyone know of a good combinator to do this?
20:03:22 <jbapple> Yes. They now pass toList . fromList = id.
20:03:39 <Pseudonym> I suspect there should be one, possibly in Data.Arrow.  But I can't find it.
20:03:45 <ivanM> Pseudonym: ((+) *** (+)) ?
20:03:54 <fryguybob> ivanM: the middle HE is an acronym and the last word is Yhey
20:03:54 <Pseudonym> :t ((+) *** (+))
20:03:55 <Makoryu> :t ((+) *** (+))
20:03:55 <lambdabot> forall b b'. (Num b, Num b') => (b, b') -> (b -> b, b' -> b')
20:03:56 <lambdabot> forall b b'. (Num b, Num b') => (b, b') -> (b -> b, b' -> b')
20:03:57 <edwardk> hrmm, is there a reasonable prospect, in this scheme of being able to append them?
20:04:07 <ivanM> @pl \(l,o) (l',o') -> (l+l', o+o')
20:04:08 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
20:04:12 <edwardk> (cheaply)
20:04:14 <ivanM> :o
20:04:15 <Makoryu> _
20:04:19 * edwardk keeps throwing new requirements at you ;)
20:04:28 <Axman6> @pl (\(l,o) (l',o') -> (l+l',o+o'))
20:04:29 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
20:04:35 <Axman6> simple
20:04:42 <ivanM> > ((+) *** (+)) (1,2) (3,4)
20:04:43 <lambdabot>   Couldn't match expected type `t1 -> t'
20:04:43 <lambdabot>         against inferred type `(b ->...
20:04:46 <ivanM> gah
20:04:52 <ivanM> I can never get the *** stuff right
20:04:57 <Pseudonym> Me neither.
20:05:08 <ivanM> that's right, it (f *** g) (a,b) = (f a, g b)
20:05:17 <jbapple> edwardk: yes. Append should be O(lg (lg (min (n,m,abs(n-m)))))
20:05:22 <dolio> ivanM: I think it was supposed to sound like Executive Alpha.
20:05:25 <Pseudonym> @pl (\((l,o),(l',o')) -> (l+l',o+o'))
20:05:26 <lambdabot> uncurry (uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+)))
20:05:30 <Pseudonym> :t (\((l,o),(l',o')) -> (l+l',o+o'))
20:05:31 <lambdabot> forall t t1. (Num t, Num t1) => ((t, t1), (t, t1)) -> (t, t1)
20:05:32 <ivanM> dolio: what was?
20:05:33 <edwardk> jbapple: shucks, was hoping for O(1) given the other invariants ;)
20:05:34 <Makoryu> :t (&&&)
20:05:35 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
20:05:39 <dolio> ivanM: heyHEYhey.
20:05:41 <edwardk> but log log never hurts
20:05:48 <ivanM> what's "executive alpha"?
20:05:55 <Pseudonym> @hoogle (t -> t -> t) -> ((t, t), (t, t)) -> (t, t)
20:05:55 <lambdabot> No results found
20:06:08 <edwardk> shall we move to #haskell-overflow?
20:06:09 <dolio> It's a character in the Futurama episode Bender Should Not be on Television.
20:06:16 <ivanM> edwardk: you mean #haskell-blah?
20:06:29 <jbapple> you mean #haskell-in-depth?
20:06:29 * Pseudonym just sticks with the lambda
20:06:29 <ivanM> wait, there's a #haskell-overflow? since when?
20:06:34 <edwardk> er
20:06:36 <ivanM> Pseudonym: yeah, might be best
20:06:44 <ivanM> there apparently is such a channel...
20:06:51 <gwern> @quote Futamura
20:06:51 <lambdabot> gwern says: good news everyone! we heard you like interpreters so we used the 3rd futamura projection to interpret your compiler so you can compile while you interpret!
20:06:53 <edwardk> #haskell-overflow has been around for a long time ;)
20:06:53 <ivanM>  /topic #haskell-overflow
20:07:13 <ivanM> edwardk: I know of #haskell, #haskell-blah and #haskell-in-depth, but have never heard of -overflow before!
20:07:24 <dolio> ivanM: That's the channel where Cale explains lazy evaluation 6 times a day.
20:07:28 <ivanM> ahhhh
20:07:34 <gwern> dolio: but only when asked
20:07:34 <edwardk> =)
20:07:43 <ivanM> at scheduled sessions every 4 hours?
20:08:30 <ivanM> so it's meant to be on-topic (unlike -blah), too boring/noisy for #haskell but not technical enough for -in-depth?
20:08:48 <gwern> ivanM: oh, evaluation of Cale tutorials is quite unpredictable
20:08:54 <fryguybob> Shouldn't explaining lazy evaluation be done lazily
20:09:03 <ivanM> heh
20:09:14 <gwern> many programmers complain about how hard it is to predict Calevaluations
20:09:34 <ivanM> Caluations ?
20:09:51 <aavogt> it complicates calculations of space and time usage
20:10:25 <ivanM> space == "noise in the IRC channel", time == "how long it takes to learn it with the numerous side explanations"?
20:10:48 <yuriks> Hey
20:10:51 <fryguybob> @quote lazy
20:10:52 <lambdabot> vegai says: Hey Haskell! Give me that File! -Naah, I'm too lazy. *thinks* I'll give you a cookie if you tell me how many letters that file has! -Oh, ok!
20:11:11 * ivanM waves idly in yuriks general direction
20:11:20 <yuriks> ok now I can ask stuff <_< >_>
20:11:34 <ivanM> don't ask to ask, etc.
20:11:45 <ivanM> hey bos
20:11:51 <yuriks> is there a good way of appending an element to the last list inside a list of lists (append as in return a new list with that appended)
20:12:00 <yuriks> ivanM: that was a sort of joke =P
20:12:04 <ivanM> ahhh
20:12:17 <ivanM> yuriks: not really
20:12:32 <evan_arm> Thanks for the help aavogt, everyone
20:12:34 <applicative> evan_arm, sorry, I cant reproduce your troubles, my Text.Regex.Posix isn't hooked up to the C lib properly, what a drag.
20:12:34 <ivanM> it sounds like you want to use a finger tree or something instead
20:12:43 <aavogt> use a function
20:12:48 <aavogt> @hackage DList
20:12:48 <lambdabot> http://hackage.haskell.org/package/DList
20:12:50 <evan_arm> applicative: No, I got it working, it was mostly my fault
20:12:55 <aavogt> @hackage dlist
20:12:56 <lambdabot> http://hackage.haskell.org/package/dlist
20:13:01 <evan_arm> and the [String] [[string]] confusion
20:13:05 <applicative> evan_arm, oh cool
20:13:06 <ivanM> aavogt: that requires you to get the last sub-list in the dlist though
20:13:09 <pikhq> yuriks: Not a very clean way, no. You'd really be better off using a different data structure. A finger tree would probably work, for instance.
20:13:20 <ivanM> pikhq: definitely
20:13:23 <yuriks> I'm kind of writing a basic CSV parser using a foldr =P
20:13:26 <evan_arm> But I'm headed out... dinner time.  Thanks, all
20:13:32 <ivanM> yuriks: *shudder*
20:13:39 <ivanM> don't we already have a CSV parser?
20:13:41 <pikhq> yuriks: Oh. No, don't.
20:13:41 <pikhq> Parsec.
20:13:44 <ivanM> if not, RWH covers how to write one
20:13:48 <pikhq> Use. Parsec.
20:13:55 <yuriks> I looked into Parsec
20:13:59 <ivanM> pikhq: s/parsec/a parsing library/
20:14:05 <pikhq> ivanM: Well.
20:14:07 <yuriks> then I was like "ok, I don't understand monads at all, maybe another day"
20:14:13 <ivanM> @where rwh
20:14:13 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
20:14:21 <pikhq> Yeah. There are other ones, which are occasionally better for things.
20:14:21 <gwern> yuriks: also look into Data.Sequence perhaps if you're dealing with finite lists
20:14:36 <yuriks> does parsec come with the platform?
20:14:39 <ivanM> yuriks: http://book.realworldhaskell.org/read/using-parsec.html
20:14:47 <ivanM> and yes, parsec comes with the platform
20:14:48 <yuriks> or even better, that standard distro
20:14:51 <pikhq> Cale: Hey, monad tutorial time. :P
20:14:54 <yuriks> the standard distro*
20:15:00 <ivanM> gwern: well, Data.Sequence _is_ a finger tree...
20:15:06 <gwern> ivanM: exactly!
20:15:09 <ivanM> but a specialised one such as Data.Sequence might be nicer, yeah
20:15:10 <yuriks> pikhq: I was actually gonna ask if you could explain them to me but I decided not to be bothersome =P
20:15:13 <gwern> ivanM: but how many people know that eh?
20:15:21 <ivanM> yuriks: there is no standard distro...
20:15:24 <gwern> ivanM: much more helpful to say 'use a Seq' than 'use a fingertree'
20:15:37 <ivanM> gwern: true, for this case
20:15:52 <yuriks> ivanM: peh, whatever installing ghci on all these pesky linux distros does install
20:16:00 <ivanM> I'm just so used to generalising everything (plus the mentions of finger trees on reddit made me remember them faster)
20:16:10 <ivanM> yuriks: in that case, no, it doesn't come with GHC
20:16:20 <ivanM> but it does come with the Haskell Platform that most distros should have now
20:16:25 * ivanM glares at ubuntu
20:16:30 <aavogt> because Seq isn't an innuendo
20:16:30 <yuriks> exactly
20:16:50 <gwern> aavogt: no more than Coq
20:17:00 <gwern> or seq
20:17:21 <pikhq> yuriks: Seriously, monads are pretty easy.
20:17:38 <pikhq> yuriks: You grok functors?
20:17:43 <ivanM> @quote wadler monads
20:17:44 <lambdabot> No quotes match. Are you on drugs?
20:17:47 <yuriks> hmm, probably nod
20:17:53 <ivanM> @quote monads
20:17:54 <lambdabot> jmcarthur says: web monads are unicorn burritos that have been laying around in the attic for a few years
20:17:58 <ivanM> @quote monads
20:17:58 <lambdabot> Baughn says: I once explained monads to a non-programmer: 'And? What's so hard about that?'
20:18:01 <ivanM> gah
20:18:04 <ivanM> @quote endo
20:18:05 <lambdabot> psykotic says: [monads aren't hard] they're just monoids on the category of endofunctors over some category, what's the big deal?
20:18:11 <ivanM> there we are!
20:18:16 <yuriks> not*
20:18:21 <gwern> I wonder how you would explain monads to a non-programmer?
20:18:25 <aavogt> @quote wadler
20:18:25 <lambdabot> wadler says: Curried food and curried functions are both acquired tastes
20:18:28 <aavogt> @quote wadler
20:18:29 <lambdabot> wadler says: The way we can tell it's C# instead of Haskell is because it's nine lines instead of two.
20:18:33 <pikhq> So, y'know how a functor is just a data structure that you can stick things of a type in, and has "fmap" defined (*basically*).
20:18:36 <ivanM> yuriks: a Functor is just some type where you can apply a mapping function over the values stored within it
20:18:42 <ivanM> @instances Functor
20:18:43 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
20:19:01 <ivanM> > fmap show (Just 3)
20:19:02 <lambdabot>   Just "3"
20:19:03 <pikhq> A monad is a lot like this, except instead of fmap, you've got (>>=) and return defined.
20:19:06 <jmcarthur> gwern: it's really not that hard. non programmers are surprisingly willing to accept abstract ideas if they have no notion that they will have to actually *use* it later
20:19:08 <pikhq> :t (>>=)
20:19:09 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
20:19:16 <yuriks> ivanM: that didn't explain me much =/
20:19:33 <Makoryu> yuriks: You know the map function?
20:19:41 <aavogt> > Just 3 >>= return . show
20:19:42 <lambdabot>   Just "3"
20:19:42 <Makoryu> > map toLower "LOWERCASE TEXT"
20:19:44 <lambdabot>   "lowercase text"
20:19:45 <pikhq> All that does is take the value "out of" a monad, and pass it to a given function.
20:19:46 <yuriks> yeah
20:19:52 <ivanM> Functor defines an fmap function for different types like how map is for lists
20:19:57 <pikhq> :t return
20:19:58 <jmcarthur> pikhq: except that's wrong :P
20:19:58 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
20:20:08 <pikhq> jmcarthur: Short, quick summary. Sorry.
20:20:09 <gwern> jmcarthur: I mean, in what meaningful way could I explain it? 'a monad is any structure where we have a box we can put stuff into, a way to put the stuff in, and a way to mess with the stuff in the box without pulling it out' is just vague analogizing
20:20:18 <pikhq> And return is, basically, the data constructor for all monads.
20:20:23 <pikhq> And... That's a monad.
20:20:36 <Makoryu> yuriks: Basically, fmap is map, but generalized for lots of types with similar properties to lists
20:20:44 <jmcarthur> gwern: that's exactly why it's easy. you don't have to make it meaningful. analogy is as good as anything for a nonprogrammer
20:20:45 <ivanM> a monad is used when we can sequence functions on the contents of some structure
20:20:53 <jmcarthur> as long as it's not blatantly wrong
20:20:54 <ivanM> the >>= is used for explicit sequencing
20:21:11 <ivanM> jmcarthur: as long as d_i_b_b_l_e_g_o isn't here...
20:21:14 <gwern> jmcarthur: -_- that's like saying _|_ is a valid example of <some random property>
20:21:15 <ivanM> (he hates analogies)
20:21:33 <jmcarthur> ivanM: i'm talking about for nonprogrammers who don't intend to program
20:21:39 <yuriks> hmm, my guess at what monads do is you sequence them, like you do with IO actions: sequencing them in a do "assembles" an IO that ends up being the result of all the actions
20:21:41 <ivanM> ahhh
20:21:51 <ivanM> yuriks: kinda, yeah
20:21:56 <pikhq> yuriks: That's what the IO monad does, yes.
20:22:05 <ivanM> yuriks: I highly suggest you go through RWH, even if you just use the online version
20:22:08 <jmcarthur> gwern: Oh, you want me to prove X? Hold on a minute...
20:22:13 <yuriks> and then people say "Maybe" is a monad and now you've lost me =P
20:22:36 <pikhq> Oh, Maybe is freaking *easy*. Just a sec.
20:22:42 <pikhq> @src Maybe (>>=)
20:22:42 <lambdabot> (Just x) >>= k      = k x
20:22:42 <lambdabot> Nothing  >>= _      = Nothing
20:22:45 <Makoryu> yuriks: It helps to understand how Maybe is a Functor first
20:22:50 <pikhq> @src Maybe return
20:22:51 <lambdabot> return              = Just
20:22:51 <Makoryu> yuriks: And how Monad and Functor are related
20:22:53 <gwern> yuriks: oh, rwh is good for that - it shows how you can manually chain a bunch of 'case foo of Just x -> case bar foo of Just y...' and replace it with >>=/do-notation
20:23:06 <ivanM> yuriks: Maybe is the "safe failure" monad, where as soon as an incorrect value is reached it "short circuits" and keeps returning Nothing
20:23:25 <aavogt> > return undefined :: Maybe Int
20:23:26 <lambdabot>   Just *Exception: Prelude.undefined
20:23:30 <ivanM> (not that it doesn't _really_ short-circuit in that the rest of the computations are still run, but they keep returning Nothing)
20:23:31 <yuriks> ivanM: oh, I see
20:23:34 <aavogt> looks incorrect to me
20:23:47 <jmcarthur> gwern: you must accept this proof i'm still working on because i'm not strongly normalizing
20:23:49 <Makoryu> aavogt: 
20:23:51 <ivanM> aavogt: what does?
20:24:16 <aavogt> that maybe short circuits when it reaches an incorrect value
20:24:18 <Makoryu> > join Just Nothing
20:24:19 <lambdabot>   Couldn't match expected type `a -> a'
20:24:19 <lambdabot>         against inferred type `Data.M...
20:24:22 <Makoryu> Whoops
20:24:25 <Makoryu> > join (Just Nothing)
20:24:26 <lambdabot>   Nothing
20:24:29 <yuriks> Just 5 >>= Just 3
20:24:31 <yuriks> > Just 5 >>= Just 3
20:24:32 <lambdabot>   Couldn't match expected type `t -> Data.Maybe.Maybe b'
20:24:32 <lambdabot>         against infe...
20:24:34 <ivanM> aavogt: where an incorrect value is defined as being Nothing
20:24:44 <yuriks> eh
20:24:49 <ivanM> yuriks: they have to be functions
20:24:51 <Makoryu> > Just 5 >>= Just (^ 2)
20:24:52 <lambdabot>   Couldn't match expected type `t -> Data.Maybe.Maybe b'
20:24:53 <lambdabot>         against infe...
20:24:56 <pikhq> yuriks: ">>=" takes an m a on the left and an (a -> m b) on the right.
20:25:00 <ivanM> > Just 5 >>= (^2)
20:25:01 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe b))
20:25:02 <lambdabot>    arising from the lite...
20:25:07 <tensorpudding> > Just <**> Just (^2)
20:25:08 <lambdabot>   Couldn't match expected type `a -> Data.Maybe.Maybe a -> b'
20:25:08 <lambdabot>         against...
20:25:08 <ivanM> > Just 5 >>= (return . (^2))
20:25:09 <lambdabot>   Just 25
20:25:09 <pikhq> > Just 5 >>= \x->Just (x+3)
20:25:10 <lambdabot>   Just 8
20:25:18 <tensorpudding> > Just 5 <**> Just (^2)
20:25:19 <lambdabot>   Just 25
20:25:22 <ivanM> tensorpudding: stop confusing the poor newbie!
20:25:26 <pikhq> Or, more generically:
20:25:30 <yuriks> ivanM: oh, right, I was thinking of how I would do that but then decided I'd just try constants (Just 2 >>= Just x*2 >>= Just *4 >>= ... wait, doesn't feel right)
20:25:41 <pikhq> > (return 5 >>= \x-> return (x + 3)) :: Maybe Int
20:25:42 <lambdabot>   Just 8
20:25:51 <Makoryu> Oh right oh right
20:26:00 <ivanM> yuriks: yeah, you need to use a function rather than a value
20:26:12 <tensorpudding> I like the idea of teaching Applicatives before Monad.
20:26:14 <yuriks> > Just 2 >>= Just (2*) >>= Just (4*)
20:26:15 <lambdabot>   Couldn't match expected type `t -> Data.Maybe.Maybe a'
20:26:16 <lambdabot>         against infe...
20:26:18 <Makoryu> > pure (5) <*> pure (^ 2)
20:26:19 <lambdabot>   Ambiguous type variable `a' in the constraint:
20:26:19 <lambdabot>    `GHC.Num.Num a'
20:26:19 <lambdabot>      aris...
20:26:21 <yuriks> =S
20:26:24 <ivanM> > (return 5 >>= \x-> return (x + 3)) :: Either String Int
20:26:25 <lambdabot>   Right 8
20:26:30 <ivanM> > (return 5 >>= \x-> return (x + 3)) :: [8]
20:26:31 <lambdabot>   Only unit numeric type pattern is valid
20:26:33 <ivanM> > (return 5 >>= \x-> return (x + 3)) :: [Int]
20:26:35 <lambdabot>   [8]
20:26:40 <pikhq> yuriks: You're getting minor issues because "Just (2*)" is sticking a function in a Maybe.
20:27:03 <ivanM> yuriks: you want to take an Int, and then convert that to a Maybe value
20:27:04 <pikhq> yuriks: That is, that's of type (Num a) => Maybe (a -> a)
20:27:15 <pikhq> When you want something of (a -> Just b)
20:27:23 <ivanM> pikhq: s/Just/Maybe/
20:27:30 <yuriks> > (Just) 2 >>= Just (Just . 2*) >>= Just (Just . 4*)
20:27:31 <lambdabot>   Couldn't match expected type `a1 -> Data.Maybe.Maybe a'
20:27:31 <lambdabot>         against inf...
20:27:35 <Makoryu> > (do x <- return 5; return (x ^ 2)) :: Maybe Int
20:27:37 <lambdabot>   Just 25
20:27:37 <pikhq> ivanM: Yes.
20:27:49 <Makoryu> > (do x <- return 5; return (x ^ 2)) :: [Int]
20:27:50 <lambdabot>   [25]
20:27:51 <ivanM> yuriks: just the stuff in the brackets, not the Just around it ;-)
20:27:55 <pikhq> > Just 2 >>= Just . (2*) >>= Just . (4*)
20:27:57 <lambdabot>   Just 16
20:28:01 <ivanM> > (Just) 2 >>= (Just . 2*) >>= (Just . 4*)
20:28:02 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
20:28:03 <lambdabot>    arising from the lite...
20:28:10 <ivanM> bah, I hate sections
20:28:17 <pikhq> Note that this is just the same as:
20:28:22 <ivanM> > Just 2 >>= (Just . (2*)) >>= (Just . (4*))
20:28:23 <lambdabot>   Just 16
20:28:33 <yuriks> ivanM: \o/
20:28:35 <ivanM> > return 2 >>= (return . (2*)) >>= (return . (4*))
20:28:36 <lambdabot>   No instance for (GHC.Show.Show (m a))
20:28:36 <lambdabot>    arising from a use of `M5250750034...
20:28:38 <pikhq> > do x <- Just 2;y <- Just 2*x;Just 4*y
20:28:39 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe b))
20:28:39 <lambdabot>    arising from the lite...
20:28:42 <ivanM> > return 2 >>= (return . (2*)) >>= (return . (4*)) :: Maybe Int
20:28:43 <lambdabot>   Just 16
20:28:47 <aavogt> you're using them all the time...
20:28:53 <pikhq> Erm. No?
20:29:08 <ivanM> aavogt: I copied that from yuriks' code
20:29:11 <pikhq> > do x <- Just 2;y <- Just (2*x);Just (4*y)
20:29:12 <pikhq> XD
20:29:12 <lambdabot>   Just 16
20:29:20 <ivanM> I typically don't use function composition inside a section
20:30:06 <Kaidelong> anyone have a recommendation for a good library for making genetic algorithms or should I just implement it myself?
20:30:07 <aavogt> > (((+) .) .) 1 2 -- like this?
20:30:08 <lambdabot>   Ambiguous type variable `t' in the constraint:
20:30:08 <lambdabot>    `GHC.Num.Num t' arising f...
20:30:20 <aavogt> > ((+) .) 1 2
20:30:21 <lambdabot>   Ambiguous type variable `t' in the constraint:
20:30:21 <lambdabot>    `GHC.Num.Num t' arising f...
20:30:33 <yuriks> > Just 2 >>= (Just . (2*)) >>= (Just . (4+))
20:30:34 <lambdabot>   Just 8
20:30:35 <Makoryu> :t (((+) .) .)
20:30:36 <lambdabot> forall a (f :: * -> *) (f1 :: * -> *). (Num a, Functor f, Functor f1) => f1 (f a) -> f1 (f (a -> a))
20:30:43 <yuriks> > Just 2 >>= (Just . (2*)) >>= Nothing >>= (Just . (4+))
20:30:44 <lambdabot>   Couldn't match expected type `a1 -> Data.Maybe.Maybe a'
20:30:44 <lambdabot>         against inf...
20:30:57 <yuriks> hmm
20:31:07 <yuriks> > Just 2 >>= (Just . (2*)) >>= (\_ -> Nothing) >>= (Just . (4+))
20:31:08 <lambdabot>   Nothing
20:31:10 <Makoryu> > (((+) .) .) (Just 3)
20:31:11 <yuriks> aha
20:31:12 <lambdabot>   No instance for (GHC.Num.Num (f a))
20:31:12 <lambdabot>    arising from the literal `3' at <int...
20:31:30 <Makoryu> > (((+) .) .) (Just (Just 3))
20:31:31 <lambdabot>   Just (Just {-3->0;-2->1;-1->2;0->3;1->4;2->5;3->6})
20:31:34 <ivanM> yuriks: so you had an intermediary function that indicated an "error" by returning Nothing; from then on the result will always be Nothing
20:31:42 <yuriks> ivanM: mhmm
20:31:48 <ivanM> (assuming you don't do something like \ _ -> return 2)
20:31:58 <yuriks> that makes enough sense I guess
20:32:00 <ivanM> Makoryu: show off ;-)
20:32:05 <yuriks> now, what's up with [] being a monad? =P
20:32:20 <ivanM> yuriks: a slight variant of Maybe is the (Either String) monad, which allows you to specify an error message
20:32:40 <Makoryu> yuriks: Let's start backwards: Maybe is a list with a max length of 1.
20:32:54 <yuriks> mm, ok
20:32:56 <Kaidelong> http://hackage.haskell.org/package/hgalib <- anyone used this?
20:32:57 <ivanM> the list monad allows you to consider each element of a list on its own
20:33:04 <Kaidelong> looks like what I'm looking for actually
20:33:14 <Makoryu> yuriks: So, if you only ever deal with lists with one or zero items in them, the list monad behaves just like the Maybe monad
20:33:21 <ivanM> Kaidelong: I haven't, but I note that the last release was in 2008 and it doesn't build on 6.12
20:33:30 <ivanM> plus its Public Domain
20:33:37 <ivanM> so it looks like it's abandoneware...
20:33:45 <Kaidelong> ah, well that's all there is
20:33:45 <Makoryu> yuriks: If a list has more than one item, it will branch out and try each possibility
20:33:55 <ivanM> ugh, uses diff arrays
20:33:56 <yuriks> wait, what?
20:34:01 <Kaidelong> so I guess I'll write the darwinism in myself
20:34:13 <Makoryu> yuriks: Let's try again. Have you seen list comprehensions?
20:34:17 <yuriks> yeah
20:34:20 <pikhq> > [1,2,3] >>= return . (2+)
20:34:20 <ivanM> > [1,2,3] >>= (return . (*3))
20:34:21 <lambdabot>   [3,4,5]
20:34:22 <lambdabot>   [3,6,9]
20:34:36 <yuriks> hmm... so... a list comprehension? =P
20:34:36 <ivanM> > [1,2,3] >>= (return . (*3)) >>= guard even
20:34:37 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
20:34:37 <lambdabot>         against inferred type ...
20:34:46 <Makoryu> yuriks: Time to get your mind blown... List comprehension syntax is syntactic sugar for monad syntax.
20:34:48 <ivanM> yuriks: pretty much the same as a list comprehension
20:35:00 <ivanM> there used to be general monad comprehensions, but they were removed
20:35:01 <pikhq> > do {x <- [1,2,3];y <- [4,5,6];return (x+y)}
20:35:02 <lambdabot>   [5,6,7,6,7,8,7,8,9]
20:35:08 <ivanM> @hoogle guard
20:35:08 <lambdabot> Control.Monad guard :: MonadPlus m => Bool -> m ()
20:35:09 <lambdabot> Language.Haskell.TH data Guard
20:35:09 <lambdabot> Language.Haskell.TH.Syntax data Guard
20:35:16 <yuriks> Makoryu: hmm, makes sense
20:35:16 <Pseudonym> I just implemented this: http://articles.adsabs.harvard.edu/full/1982CeMec..27...79S
20:35:19 <ivanM> > [1,2,3] >>= (return . (*3)) >>= (guard . even)
20:35:20 <lambdabot>   [()]
20:35:20 <Pseudonym> My brain REALLY hurts now.
20:35:43 <pikhq> yuriks: Also fun (I seem to recall you knowing C#): You know LINQ? That's just monad comprehensions.
20:35:45 <ivanM> dammit, how do you do pseudo-logic stuff with the list monad?
20:35:59 <Pseudonym> I have to say, though, it's not common that scientific theories are the result of international working groups.
20:36:04 <yuriks> pikhq: monad comprehensions? what does that even *mean*? =P
20:36:07 <ivanM> > do { a <- [1,2,3]; guard (even a); return (a*4) }
20:36:08 <lambdabot>   [8]
20:36:18 <ivanM> yuriks: same as you do with list comprehensions, but for any monad
20:36:27 <Pseudonym> "ISO standard theory of General Relativity."  Doesn't really work, right?
20:36:28 <pikhq> yuriks: A "monad comprehension" is just syntactic sugar for monads. It looks like list comprehensions.
20:36:34 <pikhq> It just works on other monads.
20:36:37 <ivanM> Pseudonym: was that meant to have a lot of dots in that link?
20:36:42 <Pseudonym> Yes.
20:36:46 <Pseudonym> The dots are real.
20:37:02 <ivanM> :o
20:37:10 <ivanM> what's NICTA do ing with astrophysics stuff?
20:37:16 <Pseudonym> Nothing.
20:37:24 <Pseudonym> You clearly don't read the beginners mailing list.
20:37:26 <ivanM> oh, you did it for fun but not profit?
20:37:29 <ivanM> Pseudonym: nope ;-)
20:38:04 * yuriks tries to imagine what a monad comprehension would look like
20:38:05 <Pseudonym> http://andrew.bromage.org/darcs/astronomy -- Someone asked for sunrise/sunset calculation.
20:38:28 <Pseudonym> yuriks: [ return l | putStrLn "Hello", l <- readLn ]
20:38:40 <pikhq> Something like [f x | x <- return (x+2); y <- return 3]
20:38:53 <pikhq> Erm.
20:38:57 <dmwit> Pseudonym: s/return// ?
20:39:01 <pikhq> My example was wrong.
20:39:13 <Pseudonym> dmwit: yes
20:40:02 <dmwit> I didn't even know "nutation" was a word.
20:40:04 <dmwit> neat
20:40:17 <yuriks> > [return l | putStr "Hello", l <- readLn ]
20:40:18 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
20:40:18 <lambdabot>         against inferred type ...
20:40:29 <yuriks> > [ l | putStr "Hello", l <- readLn ]
20:40:30 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
20:40:30 <lambdabot>         against inferred type ...
20:40:33 <yuriks> hmmm
20:40:36 <pikhq> yuriks: No longer a Haskell feature.
20:40:41 <dmwit> yuriks: Monad comprehensions aren't available any more, unfortunately.
20:40:48 <dmwit> To Protect the Innocent
20:40:50 <pikhq> Do notation replaced it.
20:41:09 <p_l> old features... reminds me of future-based I/O.
20:41:13 <Makoryu> yuriks: General purpose monad comprehensions only showed up in a couple of old (pre-Haskell 98) interpreters
20:41:14 * p_l *shudders*
20:41:27 <yuriks> well, that didn't clear up a lot
20:41:40 * yuriks is still confused as on how list as a monad would work
20:41:49 <yuriks> erm
20:41:54 <ivanM> > [1,2,3] >>= (return . (*3))
20:41:55 <yuriks> no, I was confused aobut something else
20:41:56 <lambdabot>   [3,6,9]
20:41:57 <ivanM> yuriks: ^^
20:41:57 <dmwit> > do { putStr "hello"; readLn } -- equivalent to the monad comprehension
20:41:58 <lambdabot>   Ambiguous type variable `b' in the constraints:
20:41:58 <lambdabot>    `GHC.Read.Read b'
20:41:58 <lambdabot>      a...
20:41:58 <ivanM> ahhh
20:42:01 <yuriks> damn, I'm confused about what I'm confused
20:42:08 <ivanM> heh
20:42:27 <p_l> yuriks: you're meta-confused
20:42:56 <Pseudonym> The point, though, is that monads are abstract, and hence confusing.
20:43:02 <Makoryu> Meta-confusion is soooo postmodern
20:43:45 <Pseudonym> They're no harder than "groups", "rings", "monoids" or "copy-constructible", but they're just less familiar.
20:45:01 <yuriks> the only one of those I think I know is copy-constructible (emphasis on think)
20:45:55 <pikhq> yuriks is no category theorist. :P
20:46:22 <yuriks> yes, I'm not a very good theorist, I think =P
20:46:35 <yuriks> in general
20:46:35 <pikhq> yuriks: Those have quite a few concrete examples that you are almost certainly aware of.
20:46:46 <Kaidelong> I tend to not worry so much about the theoretical examples
20:47:10 <pikhq> Also, those really don't come up in Haskell. Just abstract algebra and category theory.
20:47:14 <Kaidelong> I find I enjoy programming enough to get a feel for how things are used even if I cannot grasp them formally at first
20:47:27 <pikhq> Well. Monoids are in Haskell.
20:47:49 <pikhq> Don't come up much though.
20:48:08 <Kaidelong> I remember that Monads seemed intimidating before I began using them
20:48:35 <pikhq> Kaidelong: Whereas now it's "oh, theoretical basis for what I do all the time"?
20:49:20 <Kaidelong> pikhq: It's more that I don't worry about it anymore, I suppose, kind of like learning a language through immersion, you start to follow the rules unconciously
20:49:48 <ddarius> pikhq: You could be a category theorist and not know any of "groups", "rings", "monoids", or "copy-constructible."
20:49:53 <Kaidelong> and that has had a downside too since I've used F# and OCaml a fair deal and they are similar, but different...
20:50:15 <Kaidelong> so sometimes I get the wrong intuitions, same with me knowing both Afrikaans and German
20:50:18 <Kaidelong> it's analogous
20:50:24 <pikhq> ddarius: I'm no category theorist. ^_^
20:50:43 <Pseudonym> The thing with that nutation theory is that it looks disturbingly like epicycles.
20:50:51 <Pseudonym> I know it isn't, but it looks like it.
20:53:25 <yuriks> gah, stop it guys, you're frying my brain. The weekly doses of discrete math class are enough already =P
20:54:41 <ddarius> yuriks: What are you learning in discrete math currently?
20:55:00 <yuriks> ddarius: solving recurring sequences
20:55:18 <yuriks> and that raaaaapes my brain =P
20:55:21 <yuriks> I'm weaksauce, I know
20:55:49 <ddarius> yuriks: Look at generating functions.
20:56:03 * ddarius knew that whatever yuriks said, his answer would be "generating functions."
20:56:20 <yuriks> lol
21:01:05 * Cale looks in
21:03:28 * Cale chides ddarius for using the term "generating function" instead of "generating series" ;)
21:03:44 <Cale> yuriks: Need help with the list monad?
21:04:56 <ivanM> Cale: I think we confused him a while back...
21:05:10 <ivanM> Cale: his original question was how to append something to the last list in a list of lists ;-)
21:05:26 <Jonno_FTW> that's easy
21:05:59 <yuriks> =P
21:05:59 <Jonno_FTW> (last xs) : y
21:06:08 <djahandarie> Cale, why would it be called generating series? They are often written in closed form anyways
21:06:09 <yuriks> Jonno_FTW: well, duh, and then insert it back
21:06:24 <yuriks> replacing stuff in lists is a pain, in my experience so far
21:06:25 <Jonno_FTW> oh right
21:06:40 <Cale> djahandarie: Because evaluating them at a point (other than perhaps at 0) is usually meaningless
21:06:40 <djahandarie> Oh, well technically they don't map a domain to a codomain
21:06:41 <Jonno_FTW> yeah i guess it would take a roundabout method
21:06:45 <Cale> djahandarie: right.
21:06:49 <Jonno_FTW> producing a new list
21:06:56 * djahandarie stumbles back out of the room
21:07:04 <Cale> djahandarie: In fact, many of the useful combinatorial ones don't converge anywhere.
21:07:12 <Jonno_FTW> (head xs) : ((last xs):y)
21:07:12 <Cale> (except 0)
21:07:37 <nanothief> shouldn't that be (init xs)?
21:07:38 <ivanM> Jonno_FTW: you mean init xs ++ (last xs ++ y) ?
21:07:42 <Jonno_FTW> yes
21:07:54 <Jonno_FTW> when do you use ++ over : ?
21:08:01 <yuriks> : prepends items
21:08:15 <Jonno_FTW> ok
21:08:20 <yuriks> well, huh, it's pretty easy actually
21:08:28 <yuriks> but I'm guessing that must have some pretty lousy performance
21:08:34 <Jonno_FTW> that
21:08:39 <Jonno_FTW> that's what i thought
21:08:50 * ddarius thinks Cale has "generating function" on highlight.
21:08:57 <ivanM> @type (:)
21:08:58 <lambdabot> forall a. a -> [a] -> [a]
21:08:59 <Cale> Heh, no ;)
21:08:59 <ivanM> @type (++)
21:09:00 <lambdabot> forall m. (Monoid m) => m -> m -> m
21:09:03 <yuriks> I want an append operator, but I guess it can't be done with this list structure
21:09:15 <ivanM> ddarius: Cale has _everything_ highlighted! :p
21:09:15 <Cale> Just decided to look at what was up in the channel at that point
21:09:29 <yuriks> ivanM: teh mindfuck!
21:09:42 <ivanM> hmmm?
21:09:42 <Cale> yuriks: lists aren't usually meant for random access
21:09:58 * Jonno_FTW is reading Introduction to Algorithms atm
21:10:00 <ddarius> Yes, generating "functions" are just compact notations for the generating series they represent.
21:10:02 <Cale> yuriks: If you're going to manipulate lists, you usually want to do it in a nicely uniform way.
21:10:10 <ivanM> yuriks: either use \ xs ys -> init xs ++ (last xs ++ ys), or else do a custom list traversal function
21:10:20 <Wooga> can i some how turn myGetContents into :: String -> String here: http://paste2.org/p/801802 ?
21:10:21 <ivanM> Jonno_FTW: which one?
21:10:31 <ivanM> Wooga: you can't
21:10:37 <ivanM> (well, you can, but you shouldn't)
21:10:52 <Jonno_FTW> ivanM: Corem, Leiserson, Rivest, Stein
21:10:53 <Cale> ddarius: I usually just think of exp and so on as being just particular elements of R[[x]]
21:10:53 <Wooga> because of <- getLine ?
21:10:58 <Jonno_FTW> 3rd ed.
21:11:01 <ivanM> Wooga: you use IO to get data and output data, but you do your computations in pure functions
21:11:12 <ivanM> Wooga: right, and because the whole thing is in IO
21:11:31 <Cale> Wooga: Which String value would it produce, given the empty string?
21:11:32 <ivanM> Wooga: what are you trying to do?  because it looks like you're doing it wrong
21:11:48 <Cale> Wooga: A function, applied to a value, must always give the same result.
21:12:34 <ivanM> @google "referential transparency"
21:12:35 <lambdabot> http://en.wikipedia.org/wiki/Referential_transparency
21:12:35 <lambdabot> Title: Referential transparency - Wikipedia, the free encyclopedia
21:12:38 <Cale> Wooga: That is, if you were to apply any function  f :: String -> String  to some string parameter, and get some particular result, then you would *always* get that result.
21:12:42 <ivanM> Wooga: ^^ that's what cale is talking about
21:12:57 <Wooga> ivanM: homework from http://en.wikibooks.org/wiki/Haskell/Hierarchical_libraries/IO , here is full version: http://paste2.org/p/801806
21:13:07 <drhodes> (^/) :: (VectorSpace v, s ~ Scalar v, Fractional s) => v -> s -> v     trying to figure out what the ~ does, is it substituting the s in v->s->v with (Scalar v)?
21:13:35 <Cale> Wooga: Because it describes an IO action, your function String -> IO String is only confined to producing the same description of what needs to be done, rather than the same String.
21:13:50 <ivanM> Wooga: I would return a list of Strings and then concat them afterwards
21:14:00 <ivanM> though you'd probably want to unlines them rather than concat
21:14:19 <Cale> drhodes: It says that s is the appropriate type of scalar for the vector space v
21:14:26 <Cale> drhodes: ~ is type equality
21:14:37 <drhodes> oh neat
21:14:43 <ivanM> i.e. myGetContents = do cont <- getLine; if (cont == ".") then return [] else liftM ((:) cont) myGetContents
21:14:44 <drhodes> thanks Cale
21:15:22 <Cale> Yeah, you could also write that as:  (^/) :: (VectorSpace v, Fractional (Scalar v)) => v -> Scalar v -> v
21:16:33 <Cale> Wooga: Basically, a value of type (IO t) is a description of some stuff which could be done that may have I/O effects, before producing a value of type t
21:17:21 <Cale> Wooga: In order to execute such an action x, you can use v <- x inside of a do-block, which says "run the action x, naming its result v"
21:17:37 <Cale> The do-block as a whole will be another such IO action.
21:18:01 <Cale> (and eventually, your 'main' will be an IO action, at the very top-level of your program)
21:18:36 <TacticalGrace> ivanm, Axman6: I advertised AusHac2010 in the lecture today
21:18:42 <ivanM> TacticalGrace: cool!
21:18:47 <TacticalGrace> will be interesting to see whether that has an effect
21:18:53 <ivanM> TacticalGrace: what level of students?
21:18:58 <TacticalGrace> 3rd year
21:19:16 <ivanM> I'm going to announce it to students here when they finish the haskell component in a few weeks on the forums, but they're only first years...
21:19:26 <ivanM> so, we might get some more people from your class then
21:19:34 <Jonno_FTW> if only my uni had a haskell course.....
21:20:29 <drhodes> +
21:20:55 <djahandarie> I wish a Haskell course was the first course CSE students take
21:21:01 <djahandarie> Just skip that Java crap
21:21:24 <ivanM> djahandarie: well, TacticalGrace had to give up teaching first years as they make them learn C now :s
21:21:28 <TacticalGrace> djahandarie: yeah, the odl time...
21:21:29 <Jonno_FTW> in my CS classes we haven't actually covered any real programming languages at all after 1 semester
21:21:39 <TacticalGrace> odl = old
21:21:52 <djahandarie> :[
21:21:56 <ivanM> I think the problem is, to have someone teach Haskell you typically need someone that's a language researcher...
21:22:01 <TacticalGrace> blame EE
21:22:11 <ivanM> and most of the IT profs at unis just _use_ the languages rather than doing language research
21:22:35 <djahandarie> Haskell actually makes a shitload more sense than anything else, as well can easily be used for a number of other courses
21:22:48 <Kaidelong> djahandarie: the real problem is that they teach java like it's a procedural language
21:22:59 <Kaidelong> they may as well teach C or FORTRAN
21:23:04 <yuriks> we had C on the intro course
21:23:09 <TacticalGrace> ivanm: doesn't have to be a researcher, just needs to be competent in the language (and that is true for any language)
21:23:11 <yuriks> then our data structures heavily pushed C++
21:23:20 <djahandarie> I understand that some technical colleges and stuff wouldn't start with that, but any serious uni should start with Haskell imo
21:23:21 <yuriks> and now our programming paradigms professor heavily pushes Haskell
21:23:24 <yuriks> and... that's it
21:23:24 <TacticalGrace> Kaidelong: seconded
21:23:31 <ivanM> TacticalGrace: yes, but for Haskell you're more likely to have a prof use it if they're a language researcher
21:23:42 <Kaidelong> I had my intro course at a private college, they used java but focused on classes and events
21:23:48 <Jonno_FTW> maybe i'll talk to my lecturer about it sometime
21:24:03 <Kaidelong> which I think is probably some degree of improvement
21:24:22 <TacticalGrace> ivanm: also, language people are often made to teach the first year programming courses anyway
21:24:39 <djahandarie> I didn't even bother going to my Intro to OO classes, lol.
21:24:51 <ivanM> hmmm, not at UQ (well, they did when they switched to scheme, but that's because hardly anyone there knew scheme...)
21:24:51 <Kaidelong> well the guy doing it here right now is into computational biology
21:25:10 <Kaidelong> but he's smart and does the best he can with any teaching task he's given (small department)
21:25:26 <Kaidelong> I've heard he has been good at teaching freshmen java
21:26:11 <djahandarie> I suppose you could easily get a bad Haskell teacher too
21:26:29 <djahandarie> But... I mean, it's hard to do anything with Haskell if you don't understand certain things, so I don't know what they'd be doing
21:26:47 <djahandarie> "Hey kids, this is a pure function... I'm still trying to figure out monads"
21:27:05 <ivanM> heh, yeah
21:27:18 <ivanM> TacticalGrace: did you ever get to monads in your first year haskell course?
21:27:19 <Cale> I've seen a couple fairly terrible sounding Haskell courses.
21:27:43 <ivanM> well, the course at ANU is a terrible Haskell course... because it's not meant to be a Haskell course
21:28:03 <ivanM> it's a programming course that uses Haskell, so the quality of the Haskell code is rather poor (deliberately)
21:28:04 <djahandarie> "I went on the IRC channel but some guy told me they are just monoids in the category of endofunctors, and I've been trying to learn category theory for the past month."
21:28:11 <TacticalGrace> ivanm: I never did monads, but I did IO right from the start
21:28:15 <ivanM> TacticalGrace: *nod*
21:28:32 <ivanM> TacticalGrace: out of curiosity, did you ever have any problems explaining to students what type classes were?
21:28:42 <TacticalGrace> no
21:28:48 <ivanM> I still get the odd student who doesn't get what the "(Num a) =>" bit means :s
21:28:49 <TacticalGrace> type classes are easy to explain
21:29:11 <Cale> I always like bumping into the sort of beginner who is like "I know what monads are, but what do they have to do with programming?"
21:29:17 <ivanM> heh
21:29:19 <TacticalGrace> I did a very short into right at the start and ellaborated later
21:29:28 <arw> type classes are the trivial part. whats really hard is getting them to be able to read point-free or understand currying.
21:29:35 <TacticalGrace> but in a first year course, it is only about using them, not defining them
21:29:35 <ivanM> Cale: I thought monads were a programmign abstraction from CT and not actually part of CT proper...
21:29:40 <ivanM> TacticalGrace: right
21:29:44 <TacticalGrace> arw: yep
21:29:48 <Cale> ivanM: They are part of CT proper.
21:29:54 <ivanM> ooohhh
21:30:08 <Cale> ivanM: Monads show up all over mathematics :)
21:30:24 <TacticalGrace> ivanm: it's easy to explain the purpose of overloading (at the example of arithmetic and equality)
21:30:29 <arw> and the everlasting "I am looking for the 'for'-loop"...
21:30:30 <ivanM> right
21:30:47 <ivanM> Cale: even in combinatorics (which is the only part of mathematics I need to care about now :p ) ?
21:30:53 <djahandarie> arw, that's why I particularly don't like the intro course being something like Java
21:30:54 <TacticalGrace> ivanm: and I always introduce types as "sets of values", then type classes are just "sets of types"
21:30:54 <bos> ivanM: you asked something about gtk2hs recently?
21:31:01 <djahandarie> Imagine how easy it'd be to teach the untainted minds!
21:31:12 <bos> ivanM: i don't have a working version of it, so i can't try the code to compile it.
21:31:16 <ivanM> bos: any chance of you updating the charting bit of criterion to use vector?
21:31:23 <Cale> ivanM: Hmm... not so many examples from combinatorics that you wouldn't already be aware of.
21:31:25 <ivanM> right
21:31:28 <TacticalGrace> and just like types as sets of values bundle related values, type classes as sets of types bundle related types
21:31:34 <bos> ivanM: not without a working chart library that i can compile against, no
21:31:35 <TacticalGrace> the rest is syntax
21:31:41 <ivanM> bos: you got a repo for it so that I can try to write a patch and send it to you?
21:31:47 <arw> djahandarie: right. but whats worse, most of those java-courses deal more with object-oriented design than imperative procedural structured stuff...
21:31:52 <ddarius> ivanM: Monads are one of the most central ideas of category theory.
21:32:17 <ivanM> ddarius: hmm.... I thought they were just based on monoids :s
21:32:18 <Cale> ivanM: But for example, the completion of a metric space is a monad. (With the embedding of the original space into the completion being 'return' and the isomorphism between C(C(X)) and C(X) being 'join')
21:32:29 <arw> djahandarie: so they don't know their first language right and apply that to their second (haskell).
21:32:37 <ddarius> ivanM: They are intimately related to adjunctions which are almost the most central idea in category theory.
21:32:55 <Cale> ivanM: Closure operators from order theory are all monads
21:32:57 <djahandarie> ddarius, what's the most central idea in category theory? A category? :P
21:33:10 <tensorpudding> I heard that Kan extensions were the most central idea in CT.
21:33:19 <ivanM> Cale: hmmm.....
21:33:22 <tensorpudding> (don't actually know what they are though)
21:33:33 <ddarius> djahandarie: Definitely not a category.  The saying goes: Categories were invented to define functors, which were invented to define natural transformations.
21:33:33 <Cale> djahandarie: Perhaps, though MacLane said he didn't invent categories to study functors, he invented them to study natural transformations :)
21:33:38 <Makoryu> I heard that category theory was the most central idea in recursive category theory.
21:33:45 <djahandarie> There was that section... "All Concepts Are Kan Extensions"
21:33:53 <ddarius> tensorpudding: There's a chapter in Mac Lane's book titled "All Concepts are Kan Extensions".
21:33:59 <tensorpudding> Yes, that's the one.
21:34:08 <ivanM> Makoryu: lol
21:34:21 <ddarius> However, I would put (parameterized) representability as the central idea, though Kan extensions also suffice (and have some advantages.)
21:34:36 <TacticalGrace> #haskell in action: discussion about first-year teaching turns into an argument about CT and Kan extensions
21:34:41 <BMeph> Does anyone have a cogent reason for vector not having a splitAt function? :)
21:34:43 <bos> ivanM: yeah, uh, somewhere
21:34:43 <TacticalGrace> lol
21:34:58 <bos> ivanM: see the README
21:35:08 <ivanM> @remember TacticalGrace #haskell in action: discussion about first-year teaching turns into an argument about CT and Kan extensions
21:35:09 <lambdabot> Nice!
21:35:09 <bos> ivanM: darcs get http://darcs.serpentine.com/criterion
21:35:24 <ivanM> bos: OK, I'll have a look at it this weekend and darcs send you a patch
21:35:30 <bos> ivanM: thanks
21:36:56 <djahandarie> (And then discussion suddenly dies.)
21:38:09 <Cale> Yeah, the "classical" part of category theory is all about finding more and more general frameworks into which definitions may fit.
21:39:14 <ddarius> I do admit that I'm limiting mainly to what could be called 1-category theory or arguably 2-category theory.  For higher category theory, other factors grow in prominence.
21:42:23 <djahandarie> ddarius, are there any books on higher category theory besides that one... Higher Operads Higher Categories I think
21:42:51 <ddarius> djahandarie: Probably.
21:43:25 <djahandarie> Every time I talk to you I feel like I'm talking to myself, since my name is Darius
21:43:54 <djahandarie> I must be having some sort of existential crisis
21:44:15 <ddarius> djahandarie: I use to use the nick, Darius, but then Darius Bacon started coming around.
21:44:35 <Rotaerk> mmm, bacon
21:44:42 <djahandarie> Yeah he has written some cool stuff
21:46:41 <Wooga> Cale: ivanM: thanks for explanations. but isn't there more convenient way to implement while cycle for reading lines?
21:47:09 <ivanM> Wooga: not if you want to stop it when it reaches "."
21:47:53 <EvanR> Wooga: yes, but you havent written it yet ;)
21:48:00 <ivanM> actually, I wonder if "liftM (unlines . takeWhile (/= ".") . lines) getContents" would work
21:48:13 <Cale> Wooga: It's not so hard to write various sorts of while loop... something like  whileM :: IO (Bool,a) -> IO [a] is easy enough.
21:48:39 <EvanR> untilM is popular
21:49:34 <EvanR> maybe untilM :: IO (Maybe a) -> IO [a]
21:49:44 <Cale> Sure, that's a good one too :)
21:50:00 <EvanR> choose your own control flow adventure
21:50:13 * ddarius chooses recursion.
21:50:21 <tensorpudding> choose your own adventure books are more GOTO
21:50:50 <EvanR> think of them as case expressions
21:51:10 <Cale> untilM x = do r <- x; case r of { Nothing -> return []; Just v -> do vs <- untilM x; return (v:vs) }
21:51:10 <djahandarie> I CHOOSE YOU
21:51:19 <tensorpudding> you can think of the book as a digraph
21:51:22 <bos> ddarius: this is relevant to your interests: http://nimoysunsetpie.tumblr.com/post/463479938/fascinating
21:51:29 <tensorpudding> though it may be allowed to have non-trivial loops
21:52:19 <Cale> Wooga: Typically, we just use a little recursion, since a lot of the while-like looping constructs are not much clearer than just plain direct recursion.
21:52:40 <Cale> But if you're collecting a list of the results, it's not a bad plan to separate it out like that.
21:53:13 <EvanR> "goto page 3 and take with you n - 1"
21:54:14 <EvanR> Cale: my main loop was nice and simple until they told me to use StateT :(
21:54:34 <Cale> EvanR: See, I always tell people not to use StateT over IO
21:55:19 <Cale> Just don't do it. IO has enough features. The only monad transformer in mtl which makes sense over IO is possibly ContT, but you almost never really need that.
21:55:46 <EvanR> i was using the recursion to pass the next state of my world
21:56:05 <EvanR> i changed it to use a stateT state in a explicit loop
21:56:15 <EvanR> finally i scapped it and used IORef :(
21:56:32 <Cale> IORef really does have its place
21:56:41 <ivanM> Cale: how about WriterT over IO if you want to do some kind of logging?
21:56:53 <Cale> But often I'll just go with parameter passing.
21:57:13 <Cale> Unless I start needing to tuple things too much.
21:57:34 <Cale> ivanM: Chan
21:57:41 <ivanM> hmmm...
21:58:53 <ddarius> Except that I rarely have call to have a complex top-level, I like to use message-based concurrency for it.
21:58:59 <Wooga> but where i can find usage examples of whileM/untilM ?
21:59:05 <Cale> The main place where I'd consider monad transforming IO is if I wanted to create a restricted monad anyway.
21:59:20 <Wooga> i tried to google, but found nothing
21:59:35 <Cale> Wooga: The one that I wrote for you there, you'd call it something like:
22:00:05 <Cale> untilM (do x <- getLine; if x == "." then Nothing else Just x)
22:00:40 <Cale> Wooga: I just made it up on the spot, it's not in the libraries.
22:08:46 <ivanM> @src untilM
22:08:46 <lambdabot> Source not found. :(
22:08:49 <ivanM> @hoogle untilM
22:08:50 <lambdabot> No results found
22:08:56 <Cale> ivanM: ...
22:09:03 <ivanM> oh, wait, you defined untilM then
22:09:05 <aavogt> @type getLine
22:09:06 <lambdabot> IO String
22:09:08 <Cale> yeah :)
22:09:12 <ivanM> I thought you meant you defined the whole thing then ;-)
22:09:16 <aavogt> how are you to merge the IO and the Maybe?
22:09:20 <Cale> Actually I just finished mentioning that it's not in the libraries :)
22:09:20 <ivanM> my sincere apologies
22:09:32 <Cale> It's fine :)
22:09:37 <ivanM> Cale: right, but I misunderstood what you were referring to
22:09:42 <Cale> ah, okay
22:09:56 <blackdog> anyone played with bos and tibbe's io manager yet? wondering whether it's premature to try to bung it into a socket server of some kind...
22:10:13 <dmwit> You can be the first!
22:10:16 <dmwit> Okay... the third.
22:10:39 <aavogt> Cale: as in, you bind the result from getLine, but then leave a Maybe String on the next line...
22:10:59 <Cale> Oops, I missed a return
22:11:01 <blackdog> dmwit: maybe.:) but if i do something stupid, i'd like it not to be because i didn't check out what else was happening...
22:11:11 <Cale> aavogt: Thanks for catching that :)
22:11:20 <Cale> untilM (do x <- getLine; return (if x == "." then Nothing else Just x))
22:11:25 <bos> blackdog: we'll integrate it into ghc soonish
22:11:30 <Cale> Wooga: ^^
22:12:12 <aavogt> too bad list comprehensions don't work for Maybe, otherwise we'd have the nice syntax:
22:12:20 <aavogt>   [ x | x /= "." ]
22:12:33 <Cale> yeah
22:12:57 <blackdog> bos: at that point, will it Just Work, or will there be further stuff to do?
22:13:20 <bos> blackdog: should just work.
22:13:27 <ddarius> listToMaybe [x | x /= "."]
22:13:39 <aavogt> and by the time you write    guard (x /= ".") >> return x , you might as well write the original expression
22:13:44 <ivanM> aavogt: listToMaybe ?
22:14:31 <aavogt> > (length "listToMaybe [ x | x /= \".\" ]",length "guard (x /= \".\") >> return x")
22:14:32 <lambdabot>   (28,28)
22:15:13 <aavogt> perhaps a bit unfair because I added spaces inside [] but not ()
22:15:25 <dancor> ya who puts spaces in list comps
22:15:31 <aavogt> I do
22:15:38 <dancor> i see
22:15:53 <aavogt> otherwise you sort of confuse with template haskell quotes
22:15:59 <ddarius> There's a question of scalability.
22:16:12 <aavogt> hmm?
22:16:14 <ddarius> [x | even x, (> 5)]
22:16:21 <ddarius> [x | even x, x > 5]
22:16:54 <aavogt> well maybe you don't confuse the parser because there is space around the `|', but for humans
22:17:32 <Makoryu> @src listToMaybe
22:17:33 <lambdabot> listToMaybe []        =  Nothing
22:17:33 <lambdabot> listToMaybe (a:_)     =  Just a
22:17:57 <dancor> @src maybeToList
22:17:57 <lambdabot> maybeToList  Nothing   = []
22:17:58 <lambdabot> maybeToList  (Just x)  = [x]
22:18:18 <aavogt> @type Data.Foldable.foldr (const . Just) Nothing
22:18:19 <lambdabot> forall a (t :: * -> *). (Data.Foldable.Foldable t) => t a -> Maybe a
22:18:22 <ddarius> > foldr (const . Just) Nothing [1,2,3]
22:18:23 <lambdabot>   Just 1
22:19:13 <ddarius> :t maybe
22:19:14 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
22:19:14 <dancor> :t maybe [] (:[])
22:19:15 <lambdabot> forall a. Maybe a -> [a]
22:19:50 <aavogt> libraries@ proposals for simple stuff like that   foldableToMaybe  (call it toMaybe) have a tendency to take quite a bit of effort, no?
22:20:12 <ddarius> > msum [1,2,3] :: Maybe Int
22:20:14 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe GHC.Types.Int))
22:20:14 <lambdabot>    arising f...
22:21:18 <aavogt> ddarius: what do you mean by scalability?
22:21:56 <ddarius> aavogt: Just handling more conditions with less noise.
22:22:13 <ddarius> or more complex conditions
22:22:31 <aavogt> right, && doesn't get you as far as the comma there
22:22:37 <aavogt> since you run out of precedence levels
22:24:36 <mauke> preflex: seen ndm
22:24:37 <preflex>  ndm was last seen on #haskell 355 days, 19 hours, 5 minutes and 55 seconds ago, saying: plus with current compiler technology, it would be slower
22:46:34 <blackdog> bos: i started hacking around with c10k stuff at RailsCamp, but it gets really annoying having to use many OS processes just to hold extra file handles
22:54:01 <roconnor> fab__:
22:54:06 <roconnor> ach
22:54:09 <roconnor> stupid keyboard
22:54:10 <roconnor> sorry
23:00:29 <c_wraith> :t fix
23:00:29 <lambdabot> forall a. (a -> a) -> a
23:01:45 <c_wraith> huh.  Interesting.  I never made the connection between fix and circular reasoning, even though it's obvious in retrospect.
23:05:31 <Kaidelong> ok
23:05:38 <Kaidelong> so to write a genetic algorithm I need:
23:05:51 <Kaidelong> an instance of a chromosome that can be...
23:05:56 <Kaidelong> evaluated for effectiveness
23:06:01 <Kaidelong> mated with another chromosome
23:06:06 <Kaidelong> turned into the data structure I want
23:06:10 <Kaidelong> is that about right?
23:07:07 <Kaidelong> should be straightforward to write a chromosome class but I'm not entirely sure on the syntax on that
23:09:00 <c_wraith> You might also want some ability for random mutation
23:09:42 <Kaidelong> c_wraith: true, how about something like...
23:10:39 <Kaidelong> mate :: (Chromosome a, Num b) => b -> Integer -> Chromosome -> Chromosome -> [Chromosome]
23:11:02 <Kaidelong> where it takes a mutation rate, a population size, and two chromosomes, to make a new population
23:11:14 <Kaidelong> err
23:11:23 <Kaidelong> yeah, you know what I mean
23:11:29 <Kaidelong> substitute a for chromosome
23:12:45 <Kaidelong> b should probably be a Rational or Floating actually
23:28:48 <chipmonkpyro> Hey ive got kindof a dumb question but I'm having trouble understanding IO
23:28:58 <chipmonkpyro> assuming I've got this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25232#a25232
23:30:15 <chipmonkpyro> Is there a way to take the IO[Sting] that was just made and read each element back as one line of IO ()?
23:30:24 <chipmonkpyro> IO[String]*
23:31:13 <ivanM> chipmonkpyro: sorry, what?
23:31:26 <ivanM> not sure I understand what you're wanting
23:31:46 <diPython> exit
23:31:47 <diPython> quit
23:31:47 <chipmonkpyro> essentially something like IO [String] -> IO ()
23:31:49 <diPython> bah
23:31:59 <ivanM> chipmonkpyro: to do what?
23:32:12 <chipmonkpyro> read back each element of the string
23:32:17 <chipmonkpyro> er the list
23:32:24 <chipmonkpyro> read back each string in the list
23:32:30 <ivanM> do { line <- printRead 5; mapM_ print line}
23:32:35 <ivanM> ^^ like that?
23:32:56 <chipmonkpyro> hm lemme try it :P
23:33:40 <ivanM> but saying "read back each string in the list" doesn't make much sense
23:34:57 <chipmonkpyro> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25233#a25233
23:35:07 <chipmonkpyro> that should show what im trying to do a bit better
23:35:19 <ivanM> chipmonkpyro: mapM print =<< printRead n
23:35:43 <ivanM> chipmonkpyro: it doesn't say anything really; "printWrite n = printRead n >> return ()" matches your type signature
23:35:51 <ivanM> what are you actually wanting to _do_ with the result of printRead?
23:36:08 <chipmonkpyro> write them back line by line
23:36:29 <chipmonkpyro> in reverse order :)
23:37:31 <ivanM> chipmonkpyro: OK, so
23:37:32 <chipmonkpyro> the user inputs a certain number n strings in the function "printRead" and the elements are stored in a list
23:37:51 <chipmonkpyro> I want to write those strings back in reverse order
23:37:52 <ivanM> do { lines <- printRead n; mapM putStrLn (reverse lines) }
23:38:43 <jamwt> hmm... I've got an attoparsec question if anyone feels game...
23:39:26 <jamwt> everything's been going great but I've been avoiding the one tricky part of this grammar until now :-)
23:39:37 <chipmonkpyro> like this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25234#a25234
23:39:40 <jamwt> and it's probably b/c I don't really know the natural way to model the parsing
23:40:28 <jamwt> I might have A.B.C\n A.B\n or just A\n
23:40:39 <jamwt> IOW, there are some optional components to this "field"
23:40:49 <jamwt> that may or may not exist before the newline
23:41:33 <jamwt> I guess based on my limited parsec experienced I'd be inclined to do A.B.C <|> A.B <|> A
23:41:48 <jamwt> but it seems like that's probably suboptimal
23:42:05 <jamwt> b/c it'd be unwinding and repeating (I think) parsing A each time
23:42:17 <jamwt> when it hit the fail on C, for example
23:43:14 <ivanM> chipmonkpyro: yes
23:43:22 <ivanM> of course, you can simplify that
23:43:32 <chipmonkpyro> ivanM: Its saying I have an invalid type signature
23:45:34 <ivanM> chipmonkpyro: mapM_
23:45:46 <ivanM> not mapM
23:45:47 <ivanM> sorry
23:47:25 <chipmonkpyro> have this now: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25235#a25235
23:47:32 <chipmonkpyro> still saying invalid type signature
23:47:50 <chipmonkpyro> @ this line: {printWrite n :: Int -> IO ()}
23:49:02 <ivanM> what's the actual error?
23:49:31 <chipmonkpyro> test.hs:162:0: Invalid type signature
23:49:33 <chipmonkpyro> Failed, modules loaded: none.
23:49:56 <chipmonkpyro> line 162 is:
23:49:57 <chipmonkpyro> printWrite n :: Int -> IO ()
23:51:21 <Cale> It's the n
23:51:34 <ivanM> oh, right, I missed that
23:51:36 <Cale> printWrite :: Int -> IO ()
23:51:38 <chipmonkpyro> oh duh
23:51:39 <chipmonkpyro> my b
23:51:46 <chipmonkpyro> lol
23:52:39 <chipmonkpyro> yep works
23:52:41 <chipmonkpyro> thanks man
23:53:14 <Cale> no problem
23:54:42 <Miller`> would someone be willing to explain/english-ify the error in http://codepad.org/7LUvEVrJ ?
23:55:57 <ivanM> Miller`: you suddenly dropped into a monadic do block
23:56:03 <Veinor> yeah, you don't need a do block there
23:56:03 <lament> Miller`: whats do doing there
23:56:07 <ivanM> when it isn't a monad
23:56:18 <ivanM> also, why not keep using guards rather than the if statement?
23:57:26 <Miller`> ivanM, et all: I have no idea what that means, so i've removed the do and now it works, thanks.
23:57:37 <ivanM> why did you have the do block?
23:57:49 <Twey> > (do let { a = 5 }; a) :: Int
23:57:50 <lambdabot>   5
23:57:56 <Twey> Look ma, no monads
23:58:04 <ivanM> Twey: Identity monad...
23:58:06 <Miller`> ivanM: it was left over from before the code was cleaned up
23:58:21 <Miller`> and I didn't know it would change anything...
23:58:29 <Twey> > runIdentity (do let { a = 5 }; return a) :: Int -- Identity monad
23:58:30 <lambdabot>   5
23:58:54 <lament> > runIdentity 5
23:58:55 <lambdabot>   No instance for (GHC.Num.Num (Control.Monad.Identity.Identity a))
23:58:55 <lambdabot>    arisin...
23:58:59 <lament> hehe
23:59:03 <lament> <3 haskell
23:59:22 <lament> :t  (do let { a = 5 }; a)
23:59:23 <lambdabot> forall t. (Num t) => t
23:59:48 <Veinor> (do let {a = x}; x) == x
23:59:54 <Twey> Yep
