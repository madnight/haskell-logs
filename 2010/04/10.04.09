00:00:22 <lpsmith> I honestly can't remember details off the top of my head
00:00:36 <lpsmith> yepp
00:00:43 <tensorpudding> I've got a PA-RISC from 1994
00:00:57 <sinelaw> Question: I have multiple things that use the same resource. Option A: in this case the resource is from a C binding, so I can have the C automatically share the resource (by saving global stuff between calls). Option B: somehow do it in haskell nicely and composably without writing imperative IO crap
00:01:03 <tensorpudding> it's quite exceedingly useless
00:01:05 <sinelaw> any ideas for option B?
00:01:09 <mjrosenb> tensorpudding: that is basically the one architecture that i don't have.
00:01:28 <tensorpudding> it's a pizzabox
00:01:46 <mjrosenb> tensorpudding: once again, i am willing to take it off your hands
00:04:28 <silver> hey
00:04:50 <mjrosenb> silver: hey2
00:05:21 <silver> :-)
00:13:27 <kmc> sinelaw, what's needed to get the resource?
00:19:45 * ManateeLazyCat pasted "typeclass" at http://paste2.org/get/764414
00:19:46 <ManateeLazyCat> aavogt: For my situation, above code is better than TH?
00:21:36 <aavogt> no, that doesn't address the implementation
00:22:35 <ManateeLazyCat> aavogt: If i use typeclass, i still need write `check` `pack` `unpack` for every DaemonSignalArgs type.
00:23:19 <aavogt> maybe not
00:23:27 <ManateeLazyCat> aavogt: And looks still need some TH work, only advantage is user don't need write all type in *one* file.
00:23:44 <ManateeLazyCat> aavogt: maybe not? how ?
00:24:02 <aavogt> do browse Oleg's ftp site
00:24:18 <aavogt> I don't know how... I just have a feeling it's possible
00:25:16 <ManateeLazyCat> aavogt: For typeclass, we just allow user use any type that instance DaemonSignalArgs, but in instance code, we still need do duplicate work.
00:25:31 <aavogt> I mean that the instances can do fancy things
00:26:03 <ManateeLazyCat> aavogt: Detail?
00:26:16 <ManateeLazyCat> aavogt: What do you mean "fancy things"?
00:26:32 <ManateeLazyCat> aavogt: We don't need write instance code?
00:27:49 <jbapple> I have written a Coq-verified implementation of Brodal-Okasaki priority queues. The verification is with respect to a specification I concocted for this project, and the spec is nearly as long as the implementation itself. If anyone here would like to review the spec, I would appreciate it. It can be located at http://code.google.com/p/priority-queues/source/browse/brodal-okasaki/OrderSig.v and http://code.google.com/p/priority-queues/
00:28:16 <ManateeLazyCat> aavogt: If need user write instance by self, i prefer let user write type define in some style, then scan those type in compile-time, then generate `data Foo = A | B | C " automatically.
00:28:44 <jbapple> The Haskell code (extracted by Coq) is here: http://code.google.com/p/priority-queues/source/browse/brodal-okasaki/cabal/Data/MeldableHeap/BrodalOkasakiExtract.hs
00:28:54 <ManateeLazyCat> aavogt: Then don't care user's type, we can scan "data Foo = A | B | C" to generate `FooPack` and `FooUnpack`.
00:29:50 <jbapple> as edwardk noted a few days ago, it is not in the usual haskell style
00:30:42 * edwardk perks up.
00:31:08 <ManateeLazyCat> aavogt: http://okmij.org/ftp/ ?
00:31:26 <aavogt> ManateeLazyCat: I mean that the instance code may not have to be as repetitive as you expect
00:31:42 <jbapple> And the paper they are based on is: ftp://ftp.daimi.au.dk/pub/BRICS/Reports/RS/96/37/BRICS-RS-96-37.pdf
00:32:47 <aavogt> ManateeLazyCat: in particular stuff like here: http://okmij.org/ftp/Haskell/polyvariadic.html
00:33:44 <edwardk> i'm going to go out on the limb here and guess there is no library for dealing with directed series-parallel graphs in haskell?
00:34:05 <edwardk> s/\?$/./
00:34:30 <sinelaw> kmc: in this case IO stuff is needed to allocate
00:34:30 <ManateeLazyCat> aavogt: Reading
00:35:39 <edwardk> i think i finally found a representation for bits that i like for my sat solver
00:35:53 <aavogt> well in any case, your problem has a solution using TH, but I'm not sure there is one using advanced type hackery
00:36:22 <aavogt> IMHO template haskell is easier to understand
00:37:19 <ManateeLazyCat> aavogt: I'm doing some interface that make application programmer don't care low-level implement detail, just give new type then call API, that's all.
00:38:08 <aavogt> well good night
00:38:10 * ManateeLazyCat I'm reading Oleg's blog, maybe it's will give me secret trick. :)
00:38:14 <ManateeLazyCat> aavogt: Night.
00:43:24 <jbapple> edwardk: why build another sat solver?
00:44:28 <edwardk> jbapple: honestly, i just want a "SAT" monad for calling out to external QBF solvers, which can gracefully encode/decode non-prenex AIG problems
00:46:09 <edwardk> jbapple: what i'm looking for is a way to get both a pretty EDSL out of one, so people will want to actually use it, and an internal bit encoding that avoids throwing away the location of the existentials and foralls by smashing everything flat into prenex form, and losing the structure of the problem by smashing it into CNF.
00:46:50 <edwardk> jbapple: whether i go through and implement the actual sat or qbf solving component myself is another matter entirely
00:47:20 <kevinulin> what is the point of a tmvar?
00:47:23 <edwardk> jbapple: ideally i'll just leverage an external sat solver like nflsat or aigsolve that is compatible with my choice of internal notation
00:47:56 <c_wraith> kevinulin: it may or may not contain a value
00:48:03 <kevinulin> but tvars always do?
00:48:08 <c_wraith> correct
00:48:09 <jbapple> edwardk: What do existing constraint-solving clients do to preserve location info?
00:48:41 <edwardk> jbapple: they don't. almost everyone gives it up before handing it off to the sat solver.
00:48:55 <kevinulin> c_wraith: thanks
00:48:59 <edwardk> jbapple: the only qbf solver i know that can really leverage it is aigsolve
00:49:16 <edwardk> jbapple: but there are a couple of sat solvers that can leverage non-cnf input
00:49:33 <edwardk> so i have 2 kinds of structure i'd like to retain in my sat monad that are traditionally discarded
00:50:26 <edwardk> jbapple: that and the only other sat monad that i can find that can call out to an external solver from haskell is GPL'd and hence incompatible with my needs.
00:50:44 <edwardk> jbapple: and is crippled by a very monadic interface
00:52:10 <jbapple> Why is GPL no good for you? Are you going to be selling a closed-source Haskell project?
00:52:16 <edwardk> jbapple: and there are no incremental qbf solvers
00:52:26 <jbapple> I'll start ringing the Jon Harrop alarm :-)
00:52:27 <edwardk> jbapple: i choose not to close myself to the possibility
00:53:13 <edwardk> jbapple: simply because someone who wrote something that isn't core to my application decided to go with the 'safe default' license
00:53:46 <edwardk> they are perfectly within their rights to choose such a license. i'm perfectly within mine then to choose to ignore their software and write something better ;)
00:53:47 <jbapple> edwardk: Well, I suppose you could email them and ask them to dual license it
00:54:12 <edwardk> i could, but honestly, upon investigating the space i felt i could do better
00:54:36 <jbapple> edwardk: fair enough. What is the problem domain?
00:54:42 <edwardk> and it avoids the inertia of convincing them that my bizarre implementation is better
00:55:33 <edwardk> well, i have a few uses, most of which can get by with just a simple prenex cnf'd sat solver, so those can work with just about anything, package dependency resolution in kata, some type inference machinery, etc.
00:55:57 <edwardk> but i've been looking at a few language extensions that make me want to be able to do qbf
00:56:41 <edwardk> that and having such a tool will be useful when i return to playing with extended static checking
00:57:26 <jbapple> good stuff
00:57:34 <edwardk> if i can encode the problem into qbf the compiler will still terminate.... of course PSPACE isn't much of a guarantee ;)
00:58:00 <ski> (note to self : don't press `C-M-DEL' in emacs, while inside X)
00:58:02 <edwardk> but to do that i really need to take advantage of the incremental nature of many of my problems
00:58:10 <edwardk> ski:hahaha
00:58:25 <edwardk> and there don't appear to be _any_ incremental qbf solvers
00:58:45 <ski> (not that i had anything important running in X .. mostly just terminal with screen :)
00:58:56 <edwardk> partially i'd hazard because there is no qbflib style competition problems for them
00:58:56 <kevinulin> not using viper mode in emacs would ruin my life
00:59:41 <kevinulin> when you are creating a module, what exactly is different between DataType and  DataType(..) when you are exporting types in the module definition
00:59:45 <edwardk> i used to all but live in 'screen', but I haven't really used it much in the last 10 years.
00:59:52 <kmc> DataType(..) exports the constructors too
00:59:57 <ski> "qbf" ?
00:59:59 <edwardk> kevin the former just exports the type
01:00:01 <kmc> DataType(Foo, Bar) exports only Foo and Bar
01:00:08 <kmc> DataType exports only the type and none of its data constructors
01:00:55 <jbapple> edwardk: If you build a BSD-licensed incremental qbf-solver, I expect it will be useful to many people doing program analysis
01:01:05 <jbapple> ski: http://en.wikipedia.org/wiki/QBF
01:01:06 <ski> (iirc, `ConstructorName' exports both a type constructor and a data constructor, if you have reused the same name)
01:01:10 <kevinulin> hmm so if i have data Server = { clients :: [Client] }
01:01:15 <edwardk> ski: quantified boolean formula. take something like   exists a. forall b. exists c d e. a && b || ~c && d || ~a || e -- does there exist an assignment to the outermost existential set that makes the statement true
01:01:23 <ski> kevinulin : you need a constructor, too
01:01:23 <kevinulin> and i dont use (..) there should be no way for calling code to access the clients right?
01:01:40 <ski> kevinulin : like `data Server = MkServer { clients :: [Client] }'
01:01:41 <kevinulin> oops ya, i mean: data Server = Server { clients :: [Client] }
01:02:02 <edwardk> jbapple: mostly what i want is a monad in which i can express those problems, and which can call out to either an external qbf solver or an incremental sat solver as appropriate based on the shape of the problem
01:02:11 <kevinulin> i just am going to have information like handles and stuff in the clients that i do not want the calling code to have any way to get to
01:02:17 <ManateeLazyCat> Anyone fix HList with ghc-6.12 ? I want try to use it.
01:02:24 <edwardk> jbapple: but to get there i'm looking at alternative bit representations, because i've been trying to avoid having to use a horrible flat monadic api
01:02:34 <ski> kevinulin : ok, then i *think* exporting `Server' exports both type and data constructor .. either that or just exporting the type constructor, anyway
01:02:55 <kevinulin> if i do MkServer though, ill be safe?
01:03:08 <kevinulin> i want to have Server -> whatever functions definable by the calling code, but nothing more
01:03:11 <ski> (edwardk : any restriction on where the quantifiers can appear ?)
01:03:35 <edwardk> jbapple: what i'm looking at is encoding my bits in 'negation normal form', that is to say, as ands and ors of possibly negated literals, but that would naively mean that negating an expression would have to negate the whole tree down to the leaves, so i'm memoizing each tree with its negation
01:04:20 <edwardk> ski: traditionally you commute the quantifiers up to the top and give the problem in 'prenex' form, but it is entirely valid to reason about problems with them embedded deeper
01:04:26 <edwardk> and fairly trivial to move back and forth.
01:04:29 <ski> kevinulin : if you don't want to allow the user to create elements of `Server' (without going through your exported operations), then i think naming the data constructor e.g. `MkServer' (or anything you like, but `Server' iirc) and not exporting it would work
01:04:45 <edwardk> ski: also traditionally you collapse the formula into CNF, combinatorially exploding its size in the process.
01:05:05 <kevinulin> that is exactly what i want, thanks
01:05:52 <edwardk> jbapple: the other two representations that tend to be used are CNF which is used by the overwhelming majority of solvers, and AIGs which are used primarily in the hardware industry
01:06:20 <edwardk> what i like about the NNF representation is it has a very sexy SAT solving technique: http://reports-archive.adm.cs.cmu.edu/anon/2008/CMU-CS-08-146.pdf
01:07:15 <edwardk> though that technique hasn't been extended to QBF
01:07:27 <edwardk> on the other hand, the AIG rep has AIGsolve which HAS been extended to QBF
01:08:00 <ski> edwardk : ic
01:08:01 <edwardk> though I can go back and forth between AIG and NNF, it looks like it is easier to deal with NNF in Haskell, because with AIG you have to deal with negations at each level of the graph
01:08:16 <tibbe> edwardk: I see that we got some more student proposals. That's good. :)
01:08:19 <edwardk> and with NNF it is much easier to build up big nodes with high fan-in
01:08:35 <jbapple> edwardk: Why is it a problem to have negations at each level?
01:09:25 <edwardk> jbapple: if the negations are all at the leaves it is very easy to look at a big 'and' or a big 'or' and do trivial simplifications.
01:09:49 <jbapple> ok
01:09:50 <edwardk> otherwise you get little binary nodes with possibly negated edges between them and so you need all the sharing info to even start
01:10:23 <edwardk> tibbe: =)
01:11:18 <edwardk> tibbe: and it looks like most if not all of the mentors have signed up
01:11:29 <tibbe> edwardk: yup, thanks for sending the email
01:12:20 <edwardk> i'm much happier with the crop of student proposals now
01:14:08 <tibbe> edwardk: me too
01:14:32 <tibbe> edwardk: in fact, I want to mentor more projects than I have time to. I'll see if I can co-mentor some of them.
01:14:39 <edwardk> likewise
01:17:00 <blueonyx> hi, i got a x :: a -> b -> m (Maybe c) and want to turn it into a a -> b -> m c, but why doesnt liftM fromJust . x work?
01:17:23 <quicksilver> (a) never, ever use fromJust
01:17:41 <quicksilver> (b) because '.' is for composing unary functions and that's a binary one.
01:17:56 <blueonyx> ah thanks
01:18:21 <quicksilver> edwardk: I have been quite impressed by the thoroughness of some of the proposals that have made it to the cafe
01:18:45 <edwardk> quicksilver: yeah this year started out slowly, but it seems to be coming together very nicely
01:18:52 <quicksilver> blueonyx: some people define something sometimes called .: for composing binary functions, but I don't find it worth it personally.
01:19:04 <edwardk> I was worried for a little while that we'd be stuck picking over 3-4 applications ;)
01:19:55 <tibbe> edwardk: well, if we get 3-4 applications that actually help the haskell community in meaningful way I'd be more than happy
01:20:12 <edwardk> true
01:20:23 <tibbe> edwardk: having 3-4 good projects that are worked on by 3-4 good students is difficult to achieve
01:20:53 <tibbe> edwardk: I decided to be more proactive in helping students getting their work integrated into GHC/Cabal/common libraries this year
01:21:29 <tibbe> edwardk: for example, I want less new standalone tools and more improvements to existing ones
01:21:42 <quicksilver> tibbe: the most frustrating thiing (and I feel bad saying this, as I'm complaining about something without offering to help solve it) is when GSoC projects just never quite get finished
01:21:48 <blueonyx> quicksilver: so i cant get rid of the z in y z = liftM fromJust . x z ?
01:22:03 <edwardk> quicksilver: sadly that is something of the nature of student work =/
01:22:24 <quicksilver> tibbe: so a huge amount of useful work is done but the last step to get it usable/adoptable doesn't happen
01:22:46 <quicksilver> edwardk: surely that can't be right. If what you said was true, then you'd expect 95% of all CS PhD projects to end up as bitrotted vaporware?
01:22:47 <ski> blueonyx : you can. (using `(.:)' or partially applied `(.)')
01:22:50 <quicksilver> oh, hang on....
01:23:06 <edwardk> quicksilver: =)
01:23:10 <ski> blueonyx : however, what should happen in the `Nothing' case ?
01:23:51 <quicksilver> blueonyx: liftM fromJust . x z = ((.) (liftM fromJust) (x z)) = (((.) (liftM fromJust)) . x) z
01:24:01 <ski> needs less brackets
01:24:16 <quicksilver> blueonyx: = (liftM fromJust .) . x $ z
01:24:29 <quicksilver> blueonyx: so your original y is (liftM fromJust .) . x
01:24:35 <quicksilver> but some people find that pretty unreadable.
01:24:38 <blueonyx> ski: an error which terminates the app
01:24:43 <blueonyx> ah nice
01:25:52 <tibbe> quicksilver: that's my feeling too
01:25:57 <quicksilver> pl can do the derivation, of course, but I was just showing you the steps ;)
01:26:15 <quicksilver> @pl \x y -> f (g x y)
01:26:15 <lambdabot> (f .) . g
01:26:18 <tibbe> quicksilver: that's why I want things that 1) extend current projects and 2) make sure that commits actually gets into the main repos of those projects
01:26:20 <blueonyx> thank you
01:26:37 <quicksilver> some people define f .: g = (f .) . g
01:26:38 <quicksilver> for this reason
01:26:41 <ski> blueonyx : also using SEC, `result (result (liftM fromJust)) x' which could also be written as `(result . result) (liftM fromJust) x' or `(result . result . liftM) fromJust x'
01:26:43 <quicksilver> but personally I dislike it :)
01:26:48 <ski> where `result = (.)'
01:26:51 <ski> @where SEC
01:26:51 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
01:28:01 <ski> (the lattermost could be read as "modify the monadic result of the result of the result of `x' by `liftM')
01:28:53 <ski> (there's also `argument = flip (.)' for modifying the argument of a function .. but see that conal post)
01:32:25 <cYmen> I have a question about TypeSynonymInstances. I'm currently in ch06 of rwh and I can't figure out the explanation. It says here that "String is a synonym for [Char], which in turn is the type [a] where Char is substituted for the type parameter a. According to Haskell 98's rules, we are not allowed to supply a type in place of a type parameter when we write an instance." but it seems to me that when I write "instance JSON Bool" supplying a type is exactly 
01:33:16 <ski> (possibly cut off at "... but it seems to me that when I write \"instance JSON Bool"\ supplying a type is exactly")
01:34:07 <quicksilver> ski: nice string escaping, but slightly broken :)
01:34:19 <ski> bah, dang! :)
01:34:42 * cYmen looks confused.
01:35:08 <ski> did you, or did you not, intend to say anything more after "exactly" in that message ?
01:35:43 <cYmen> oh I did....
01:35:44 <ski> (in any case, nothing more after "exactly" was delivered to my IRC client .. the IRC protocol is unpredictible like this)
01:35:57 <cYmen> It got cut off? Why can't I see that it got cut off. That's annoying.
01:36:14 <cYmen> [...]but it seems to me that when I write "instance JSON Bool" supplying a type is exactly what I do. What's  going on here?
01:36:26 <jbapple> I think the question is "to what is a a parameter"
01:36:27 <ski> (presumably because your client displays to you what you typed, not what the server sent to the clients ..)
01:36:36 <jbapple> In "Class JSON a", a is a parameter to a class
01:36:58 <jbapple> in "instance Show [Char]", Char is a parameter to []
01:37:28 <ski> in `instance JSON (Foo a b)' `a' and `b' would be parameters to the type constructor being made an instance of the type (this particular example allowed by Haskell 98)
01:38:29 <ski> in `instance JSON (Foo a a)' or `instance JSON (Foo (Maybe c) b)', the arguments to the type constructor are not distinct type variables, so these cases are not allowed by Haskell 98
01:39:06 <ski> similarly, `instance JSON String' really is `instance JSON [Char]', so that is also not valid Haskell 98
01:39:29 <cYmen> what exactly is a type constructor?
01:39:30 <quicksilver> (leaving aside the fact that using a type synonym is *also* invalid haskell 98 independent of the above restriction)
01:39:34 <ski> if you want to allow this kind of this (it is generally thought to be pretty harmless), then enable the extension `FlexibleInstances'
01:39:35 <cYmen> I'm having trouble parsing your sentences.
01:39:44 <quicksilver> cYmen: something that builds a type. 'Maybe' is a type constructor, 'Maybe Int' is a type.
01:40:01 <quicksilver> [] is a type constructor, [Bool] is a type.
01:40:20 <cYmen> ok
01:40:43 <cYmen> so the things that are instances of classes are type constructors?
01:40:52 <quicksilver> not necessarily, that depends on the class.
01:41:00 <ski> cYmen : concrete types like `Int',`Char',`Bool',`Handle', also parameterized types like `Maybe',`[]',`IO',`Map' (but not `Maybe Int',`[a]',`Either IOError',`Map Int')
01:41:04 <cYmen> right...because Bool is a type not a type constructor
01:41:06 <quicksilver> the class JSON has instances which are concrete types.
01:41:12 <quicksilver> similary, the class Num.
01:41:19 <quicksilver> however the class Monad has instances which are type constructors.
01:42:21 <ski> `Bool' is a type constructor (trivially. it is a curried type "function" taking zero type arguments, and giving a type)
01:43:01 <mpiechotka> Hello. In GHC 6.12 what is preferred method of marshaling UTF-8 strings?
01:43:53 <blackh> mpiechotka: My preferred method is to use the 'text' package, but you can also use utf8-string package, or use the base libraries...
01:44:06 <cYmen> So why is String not a type constructor?
01:44:15 <blackh> but there's an incompatibility with the way encodings are handled compared with ghc 6.10.4 in the base libraries.
01:44:30 <cYmen> I mean I could understand "something that is not a complete type is a type constructor" but then Bool and String are the same...
01:44:31 <ski> cYmen : because it is just a type synonym for `[Char]', which is not a type constructor
01:44:34 <cYmen> What's the distinction here?
01:44:47 <ski> type constructors are introduced with `data' and `newtype', but not with `type'
01:44:59 <mpiechotka> blackh: Do you mean GHC.IO packages?
01:45:08 <ski> @src String
01:45:08 <lambdabot> type String = [Char]
01:45:13 <ski> @src Bool
01:45:13 <lambdabot> data Bool = False | True deriving (Eq, Ord)
01:45:35 <blackh> mpiechotka: Well, System.IO, but it's probably true that they call GHC.IO
01:45:36 <ski> @src Writer
01:45:36 <lambdabot> Source not found. Take a stress pill and think things over.
01:45:51 <cYmen> hrm
01:45:52 <ski>   newtype Writer w a = Writer {runWriter :: (a,w)}
01:46:10 <cYmen> So a type constructor is not something that constructs a type but...?
01:46:24 <ski> cYmen : `String' is not a new type, it is treated in the same way as `[Char]', which it is merely a shorthand for
01:46:50 <ski> otoh, `data' and `newtype' declarations introduces new types, i.e. new type constructors
01:46:50 <cYmen> [Char] still seems as much as a type (or type constructor) to me as Bool..
01:46:53 <blackh> cYmen: A type constructor is like a function at the type level - you give it a type and it returns a type (or another type constructor).
01:46:59 <ski> so `Bool' and `Writer' are type constructors
01:47:49 <ski> cYmen : yes, both `[Char]' and `Bool' are types .. but the former is not "atomic", it is build up from the type constructors `[]' and `Bool'
01:48:01 <ski> er, s/and `Bool'/and `Char'/
01:48:08 <blackh> cYmen: ski is saying that 'Bool' is a type constructor that takes 0 arguments. But he's SO WRONG! :7
01:48:30 <ski> blackh : note the "curried \"function\"" !
01:48:49 <quicksilver> I don't think it's standard terminology to describe Bool as a type construcor.
01:49:02 <quicksilver> and I don't think it's GHC's terminology either.
01:49:15 <quicksilver> Bool is as much a nullary type constructor as False is a nullary function.
01:49:18 <ski> hm, that might be the case (i was slightly unsure about that)
01:49:23 <blackh> cYmen: IO is a type constructor.  If you pass it (), it gives you a type, namely IO ()
01:49:39 <quicksilver> obviously it's a consistent view (to think of the nullary case) but I don't think it's the way the word is typically used.
01:49:46 * cYmen 's head explodes.
01:49:54 <ski> quicksilver : `Bool' is as much a nullary type constructor as `False' is a nullary *data* constructor, rather ! :)
01:50:41 <quicksilver> The way I would explain this is to remark that [a] is a parametric type
01:50:43 <ski> (.. or at least, that's how i'd prefer the term "type constructor" to be used)
01:50:49 <ski> but that's not true
01:50:55 <quicksilver> or a family of types (depending how you look at the a there)
01:50:59 <ski> `[]' is a parametric type
01:51:08 <ski> as is `Either IOError'
01:51:10 <quicksilver> I'm abusing notation slightly but bear with me.
01:51:40 * ski is averse to abusing notation :/
01:51:50 <quicksilver> [] is a parametric type (if you must :p) and the designers of haskell98 thought that instances for parametric types should be parametric.
01:52:07 <quicksilver> that turns out to be an unnecessary restriction but it is a good intuition.
01:52:16 <ski> *nod*
01:52:19 <quicksilver> very often it is good for instances of parametric types to be parametric.
01:52:43 <quicksilver> so they intended to forbid having one instance for [Int] and an unrelated one for [Char]
01:52:48 <cYmen> now that sounds a lot more sensible
01:52:58 <quicksilver> the feeling was that 'well-behaved'  instances should just be generically written for [a]
01:53:08 <quicksilver> and work uniformly over all choices for a
01:53:17 <cYmen> of course they were wrong..the fools..hah!
01:53:21 <ski> then, `showList' enters the picture ..
01:53:28 <quicksilver> ...however this turns out, in practice, to be an annoying restriction in some cases.
01:53:42 <quicksilver> especially, although not only, when you have multi-parameter type classes.
01:53:51 <quicksilver> like 'MonadState Int m'
01:54:00 * cYmen flails with his arms.
01:54:05 <cYmen> Stop it right there.
01:54:06 <quicksilver> cYmen: well you grasped the point.
01:54:10 <quicksilver> it seemed like a good idea at the time
01:54:14 <quicksilver> in restrospect it was a mistake
01:54:15 <cYmen> Yes, don't make it worse again now. :)
01:54:24 <quicksilver> and in practice, we use -XFlexibleInstances
01:54:34 <quicksilver> and haskell 2010 will not have this restriction
01:54:35 <quicksilver> IIRC.
01:54:43 <blackh> cYmen: If you want to turn on FlexibleInstances and define different instances for MyType Char, MyType Bool, etc etc, then that's fine, but you can't then define one for MyType a.  The way to work around this is to use OverlappingInstaces, but it is not a good idea.
01:55:00 <cYmen> guys hold your horses!
01:55:29 * blackh holds his horses.
01:55:46 <cYmen> good...now feed them some hay while I go back to reading the book :)
01:55:47 * ski holds Fawkes horses.
01:56:31 <cYmen> thanks for the explanation!
01:56:51 <blackh> No worries. We could talk about Haskell all day. And, in fact, we do!
01:56:54 <cYmen> I think I have enough to read on and come back when the book tries to confuse me with OverlappingInstances, too.
01:57:17 <blackh> OverlappingInstances is simple - don't use it! Pretend it doesn't exist.
01:57:50 <cYmen> But it says here....
01:57:53 * cYmen tapps in the book.
02:00:00 <quicksilver> using OverlappingInstances is the haskell equivalent of buying a new car with high safety rating and replacing the air bags with poison gas, pouring lubricating oil all over the brake pads, cutting the cable to the parking brake, and gluing broken glass shards all over the steering wheel.
02:00:28 <dmhouse> cYmen: which book?
02:00:36 <cYmen> rwh
02:09:44 <roconnor> @quote quicksilver using OverlappingInstances is the haskell equivalent of buying a new car with high safety rating and replacing the air bags with poison gas, pouring lubricating oil all over the brake pads, cutting the cable to the parking brake, and gluing broken glass shards all over the steering wheel.
02:09:44 <lambdabot> No quotes match. My mind is going. I can feel it.
02:09:51 <roconnor> @remember quicksilver using OverlappingInstances is the haskell equivalent of buying a new car with high safety rating and replacing the air bags with poison gas, pouring lubricating oil all over the brake pads, cutting the cable to the parking brake, and gluing broken glass shards all over the steering wheel.
02:09:51 <lambdabot> It is forever etched in my memory.
02:11:01 <dancor> why
02:11:34 <cads> hmm.. should darcs get work with this url? http://semantic.org/hnop/
02:12:01 <cads> It's got a _darcs folder.. I don't know if this makes it a darcs repo however
02:17:15 <stevenmarky> I'd love to see someone drive that car.
02:18:06 * stevenmarky is a sociopath/misanthrope.
02:24:40 <blackh> cads: darcs get http://semantic.org/hnop <-- that should work, in theory
02:25:00 <blackh> A _darcs folder does make it a darcs repo
02:28:16 <cads> oh
02:28:18 <cads> d'oh
02:28:29 <cads> I'd typed segmantic.org :P
02:28:40 <quicksilver> oh d'oh, my favourite kind of water
02:28:42 <roconnor> is it a porno site?
02:28:43 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
02:28:59 <roconnor> @messages
02:28:59 <lambdabot> edwardk said 10h 30m 58s ago: yeah. i have a pair of class associated types for the monad i'm transforming that tell me the two functors involved in the right kan extension.
02:29:27 <cads> roconnor: no but the domain is available should you choose to deploy a porn site on it!
02:29:50 <roconnor> I once made the mistake of going to ghostscript.com or ghostview.com at work.
02:30:43 <cads> oh boy
02:30:48 <cads> I can just imagine
02:31:49 <roconnor> edwardk's monad transformer library sounds awesome
02:32:39 <cads> http://hackage.haskell.org/package/mtl-1.1.0.1 ?
02:33:20 <Twey> roconnor: I'm confused
02:33:25 <Twey> ghostscript.com is what you'd expect
02:35:18 <roconnor> hmm
02:35:22 <cads> I was just watching a presentation on basic monads in clojure. Over there they have the opacity of not having type signatures for their expressions, but it's great how the concept translates easily
02:35:25 <roconnor> I recall it being different 12 years ago
02:36:03 <roconnor> cads: nope, edward's package is different
02:36:20 <kmc> clojure is dynamically typed, isn't it?
02:36:51 <cads> "you are a ghost that has died and now haunt a porno studio. They are terrified porn starlets who know they are being *watched*. Ghostview.com."
02:36:53 <mjrosenb> quicksilver: i don't think overlappinginstances is that bad
02:37:12 <cads> kmc, yes
02:37:22 <Twey> cads: Sadly, it's now down :þ
02:38:17 * ski wonders whether there is any nicer way to define `unfoldr', using `build' (or something similar) ..
02:39:00 <mjrosenb> never mind
02:39:17 * mjrosenb is using FlexibleInstances
02:39:53 <cads> @type unfoldl
02:39:54 <lambdabot> Not in scope: `unfoldl'
02:40:02 <cads> only r.
02:40:16 <mjrosenb> reverse . unfoldr
02:40:27 <mjrosenb> or is it rev?
02:40:37 <ski> no, `r' as in `foldr'
02:40:49 <ski> @type foldr
02:40:50 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
02:41:05 <cads> @type unfoldr
02:41:06 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
02:41:24 <mjrosenb> ski: i am making the assumption that since foldr f i l == foldl (flip f) i (reverse l), the logical unfoldl would hold the same relation.
02:41:50 <mjrosenb> s/hold/have/
02:41:58 <quicksilver> mjrosenb: ;)
02:42:03 <quicksilver> mjrosenb: flexibleinstances is fine.
02:42:19 <mjrosenb> quicksilver: yeah.
02:42:43 <mjrosenb> quicksilver: but for overlapinginstances, doesn't ghc define the order that they are tried in
02:43:00 <cads> hmm.. did I use unfoldr to help write the ackermann function..
02:43:05 <mjrosenb> quicksilver: and aren't there still cases where it will bail because multiple ones match to the same specificity
02:43:06 <quicksilver> yes, it does. But it's not composable
02:43:15 <quicksilver> it breaks modularity and separate compilation of polymorphic functions
02:43:45 <quicksilver> and, in fact, breaks simple equational rewriting
02:43:49 <quicksilver> i.e. everything.
02:43:50 <mjrosenb> separate compilation is for people who don't want whole program optimizations :-p
02:44:02 <roconnor> foldlr is isomorphic to (Either (a,b) () -> b)   ->    [a] ->b  and unfoldr is isomorphic to those two arrows reversed  (b -> (Either (a,b) ()))      ->  b -> ]a
02:44:04 <quicksilver> perhaps, but it's what we all use.
02:44:06 <roconnor> foldlr is isomorphic to (Either (a,b) () -> b)   ->    [a] ->b  and unfoldr is isomorphic to those two arrows reversed  (b -> (Either (a,b) ()))      ->  b -> [a]
02:44:17 <quicksilver> we don't have a whole-program mode to switch GHC into when we want to use overlapping instances.
02:44:37 <quicksilver> (even if we did, other changes would be required to GHC to make it not break rewriting)
02:45:40 <ski> mjrosenb : hm, i'm not sure there is a very sensible `unfoldl'
02:46:00 <ski> (well, i suppose one could define a tail-recursive one)
02:46:06 <mjrosenb> that being said, i have not yet been handcuffed into overlapping instances
02:46:17 <ski> @type uncurry (foldr . curry) . ((. Just) &&& ($ Nothing))
02:46:18 <lambdabot> forall a b. (Maybe (a, b) -> b) -> [a] -> b
02:46:22 <ski> @type uncurry ((. ($ ())) . foldr . curry) . ((. Right) &&& (. Left))
02:46:23 <lambdabot> forall a b. (Either () (a, b) -> b) -> [a] -> b
02:46:29 <ski> @type unfoldr
02:46:30 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
02:47:11 <mjrosenb> roconnor: foldlr?
02:47:26 <roconnor> i meant foldr
02:48:06 <roconnor> I think an
02:48:07 <roconnor> er
02:48:33 <roconnor> I think you could define an unfoldl that way
02:48:43 <roconnor> I'm not sure anyone would use it, but it seems to make sense.
02:49:51 <roconnor> unfoldl f i = reverse (unfoldr (fmap flip . f) i) -- specification
02:50:14 <roconnor> er
02:50:18 <roconnor> s/flip/swap
02:50:23 <cads> oh god
02:50:41 <ski> @let unfoldl :: (s -> Maybe (s,a)) -> (s -> [a]); unfoldl step = loop [] where loop as s0 = case step s0 of Nothing -> as; Just (s1,a) -> loop (a:as) s0
02:50:42 <lambdabot>  Defined.
02:51:00 <mjrosenb> @type unfoldl
02:51:01 <lambdabot> forall s a. (s -> Maybe (s, a)) -> s -> [a]
02:51:11 <mjrosenb> @type unfoldr
02:51:12 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
02:51:22 <ski> > unfoldl (\x -> guard (x < 1000) >> Just (2*x,x-1)) 1
02:51:26 <lambdabot>   mueval-core: Time limit exceeded
02:51:32 <ski> oops :)
02:52:08 <ski> @undefine
02:52:21 <ski> @let unfoldl :: (s -> Maybe (s,a)) -> (s -> [a]); unfoldl step = loop [] where loop as s0 = case step s0 of Nothing -> as; Just (s1,a) -> loop (a:as) s1  -- silly typo
02:52:22 <lambdabot>  Defined.
02:52:24 <ski> > unfoldl (\x -> guard (x < 1000) >> Just (2*x,x-1)) 1
02:52:25 <lambdabot>   [511,255,127,63,31,15,7,3,1,0]
02:52:36 <ski> there you go
02:53:00 <mjrosenb>  > unfoldr (\x -> guard (x < 1000) >> Just (x-1,2*x)) 1
02:53:08 <mjrosenb> > unfoldr (\x -> guard (x < 1000) >> Just (x-1,2*x)) 1
02:53:09 <lambdabot>   [0,1,3,7,15,31,63,127,255,511]
02:53:11 * mjrosenb fail
02:53:30 <ski> > (\f i -> reverse (unfoldr (fmap flip . f) i)) (\x -> guard (x < 1000) >> Just (x-1,2*x)) 1
02:53:31 <lambdabot>   Couldn't match expected type `(a, b)'
02:53:31 <lambdabot>         against inferred type `a1 -> ...
02:53:37 <roconnor> ski: s/flip/swap
02:53:49 <ski> > (\f i -> reverse (unfoldr (fmap (snd &&& fst) . f) i)) (\x -> guard (x < 1000) >> Just (x-1,2*x)) 1
02:53:54 <lambdabot>   mueval-core: Time limit exceeded
02:54:01 <roconnor> :(
02:54:06 <ski> > (\f i -> reverse (unfoldr (fmap (snd &&& fst) . f) i)) (\x -> guard (x < 1000) >> Just (2*x,x-1)) 1
02:54:08 <lambdabot>   [511,255,127,63,31,15,7,3,1,0]
02:54:13 <ski> @type (\f i -> reverse (unfoldr (fmap (snd &&& fst) . f) i))
02:54:15 <lambdabot> forall a b. (a -> Maybe (a, b)) -> a -> [b]
02:54:22 <roconnor> @type swap
02:54:23 <lambdabot> Not in scope: `swap'
02:54:27 <roconnor> pfft
02:54:39 <ski> ah, i used `a -> Maybe (b,a)' in mine, that's the reason why
02:54:42 <roconnor> are we still debating whether to add strict or lazy swap?
02:55:09 <mjrosenb> roconnor: what does swap do?
02:55:12 <ski> @let swap :: (a,b) -> (b,a); swap = snd &&& fst
02:55:13 <lambdabot>  Defined.
02:55:13 <Twey> Why would you need a lazy swap?
02:55:26 <ski> Twey : to lazily swap pairs ?
02:55:26 <mjrosenb> oic
02:55:31 <fax> twey for fixed points I guess
02:55:35 <Twey> Ah
02:55:44 <Twey> And what would the advantage of a strict swap be?
02:55:47 <ski> like in lazy `State[T]' or `Writer[T]', e.g.
02:55:55 <roconnor> Twey: symmetry
02:56:08 <Twey> Okay
02:56:19 <Twey> So we're going to end up with swap and swap', then?  ☺
02:56:20 <mjrosenb> how is lazy swap asymmetric?
02:56:29 <Twey> I guess fst/snd are strict?
02:56:47 <ski> yes (they can't be anything else)
02:56:51 <roconnor> mjrosenb: lazyswap undefined = (undefined,undefined)
02:57:01 <fax> http://lambda-the-ultimate.org/node/3905
02:57:04 <fax> lambda the ipod
02:57:40 <mjrosenb> roconnor: whereas strictswap undefined = undefined?
02:57:59 <cads> oh my poor brain.. does unfoldl produce something other than the reversed result of an unfoldr?
02:58:17 <fax> @src unfoldl
02:58:17 <lambdabot> Source not found. You speak an infinite deal of nothing
02:58:39 <kamatsu> Axman6: woot, typeclasses work :D
02:58:53 <Axman6> whooo, that was quick :)
02:59:04 <cads> fax: we were playing with some speculative code for unfoldl
02:59:08 <kamatsu> well, the language has already been written
02:59:08 <ski> (fax : i gave one definition, just after you joined)
02:59:19 <kamatsu> so i just needed to get the already-generated dictionaries and port their semantics into js
02:59:30 <mjrosenb> ski: he may not have actually seen that.
02:59:31 <ski> mjrosenb : yes
02:59:45 <ski> (hm, i suppose that could be true)
03:00:01 <mjrosenb> there is no absolute time frame in irc
03:00:10 * ski just recalled that :)
03:00:25 * mjrosenb should try to express the laws of GR in terms of IRC
03:00:34 <ski> "GR" being ?
03:00:36 <mjrosenb> massive objects could be loaded servers
03:00:41 <mjrosenb> general relativity
03:00:44 <ski> (oh .. "general relativity")
03:01:29 <ski> so .. no takes on defining `unfoldr' (preferably "nicely", whatever that means) using `build' ?
03:01:51 <fax> :t build
03:01:52 <lambdabot> Not in scope: `build'
03:02:29 <ski> @type GHC.Exts.build
03:02:30 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
03:02:58 <mjrosenb> errr
03:03:28 <mjrosenb> that type seems rather odd....
03:03:31 <mjrosenb> like
03:03:42 <ski> it is sortof, an inverse to `foldr'
03:03:45 <ski> @type foldr
03:03:46 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
03:03:56 <mjrosenb> my brain wants there to be an a as the return value of one of those
03:04:06 <ski> @type flip (flip . foldr)
03:04:07 <lambdabot> forall b a. [a] -> (a -> b -> b) -> b -> b
03:04:52 <mjrosenb> ski: yes, but the value that is returned by foldr has a type related to the return value of one of its arguments
03:05:07 <ski> yes
03:05:16 <mjrosenb> here, you get a list of a's, but you have no way of getting an a from your argument.
03:05:37 <ski> if you move the `forall b' part (but not the `forall a' part) down the first `->' arrow, you get an exact inverse
03:05:59 <ski>   forall a. [a] <-> (forall b. (a -> b -> b) -> b -> b)
03:06:21 <ski> this is actually an application of Yoneda's Lemma, iiuc
03:07:27 <mjrosenb> @src build
03:07:28 <lambdabot> build g = g (:) []
03:07:29 <ski> Reverse Engineering Machines with the Yoneda Lemma <http://blog.sigfpe.com/2006/11/yoneda-lemma.html>
03:07:32 <ski> The continuation passing transform and the Yoneda embedding <http://reperiendi.wordpress.com/2007/12/19/the-continuation-passing-transform-and-the-yoneda-embedding/>
03:07:41 <mjrosenb> uh. huh.
03:07:58 <ski> @quote Yoneda
03:07:59 <lambdabot> slava says: Because top enterprise industry analysts recommend that managers need to focus on Agile methodologies, SOA, B2B and Yoneda's lemma in today's rich Internet application-driven environment.
03:07:59 <lambdabot>  Don't get left behind by the AJAX craze by missing out on call center outsourcing and Yoneda's lemma!
03:08:23 <fax> thats true
03:08:35 <cads> Hmm. I don't understand something. If our way of constructing lists involves adding an element to the head of the list like  (x:xs), starting eventually from an empty list such as xn:xn-1:xn-2: ... :x2:x1:x0:[], how is it that we write a lazy list such as [1..] or fib = 0:1:zipwith (+) fib (tail fib)? I can see that saying head [1..] = 1 and tail [1..] = [2..], head [2..] = 2, tail [2..] = [3..] and so on would let us implement stuff like (take n) even for infin
03:09:08 <mjrosenb> cads: cut off at even for infin
03:09:17 <cads> Does it depend on writing a list as a normal list of elements followed by a thunk for generating the rest of the list?
03:09:28 <cads> "even for infinite lists"
03:09:30 <mjrosenb> cads: yes
03:09:34 <fax> take infinity wont give you an answer
03:09:34 <mjrosenb> cads: that is laziness.
03:10:07 <ClaudiusMaximus> > take 5 (1:2:3:4:5:error "6?")
03:10:08 <lambdabot>   [1,2,3,4,5]
03:10:12 <quicksilver> cads: basically you're wrong to say 'starting eventually from an empty list'
03:10:28 <mjrosenb> ski: i plugged that definition of build into ghci
03:10:29 <quicksilver> cads: there is no requirement imposed by the haskell language / compilers that you start eventually from an empty list.
03:10:32 <mjrosenb> ski: build :: ((a -> [a] -> [a]) -> [a1] -> t) -> t
03:10:54 <ski> mjrosenb : the rationale behind `build' is that using fusion `RULES' like `forall cons nil fold. foldr cons nil (build fold) = fold cons nil', we can deforest away the intermediate list constructed by `build'
03:10:55 <quicksilver> that would be the strict meaning of an inductive type, haskell only gives us something called 'coinductive' types.
03:11:48 <mjrosenb> ski: the type that it said build has makes much more sense to me.
03:11:50 <ski> mjrosenb : note that `build :: ((a -> [a] -> [a]) -> [a1] -> t) -> t' which is short for `build :: forall a a1 t. ((a -> [a] -> [a]) -> [a1] -> t) -> t' is not the same as `build :: forall a. ((a -> o -> o) -> o -> o) -> [a]'
03:12:00 <mjrosenb> excetp that [a1]
03:12:18 <Jafet> @src enumFrom
03:12:18 <lambdabot> Source not found. Where did you learn to type?
03:12:26 <Jafet> Lalala
03:12:41 <ski> mjrosenb : since this is a hingher-ranked type (it uses `forall' in other places that "on the outside"), it can't be inferred, you must specify the type signature (and enable `LANGUAGE' `Rank2Types' or `RankNTypes')
03:13:05 <baaba> @pl f x y = fix ([x, y]++)
03:13:05 <ski> s/hingher/higher/
03:13:05 <lambdabot> f = ((fix . (++)) .) . (. return) . (:)
03:13:35 <baaba> @pl f x y = fix ((x:) . (y:))
03:13:35 <lambdabot> f = (fix .) . (. (:)) . (.) . (:)
03:13:43 <baaba> nice :P
03:14:03 <baaba> is there a prettier way to do that?
03:14:19 <baaba> i guess fix ([x, y]++) is alright
03:14:35 <fax> :t (cycle, repeat)
03:14:36 <lambdabot> forall a a1. ([a] -> [a], a1 -> [a1])
03:14:53 <baaba> oh right, duh
03:15:14 <fax> (interleave `on` repeat) x y
03:15:23 <ski> mjrosenb : .. anyway, re `foldr'/`build'-fusion .. the idea is that if we can express a function that constructs a list in terms of `build (\cons nil -> ..cons..nil..)' instead of `..(:)..[]..', then the fusion rule can fire whenever we use `foldr' on the result of this function
03:15:30 <cads> quicksilver: hmm, I'm still having trouble thinking of the operation that takes a list and adds an element onto the end without essentially reversing the list, consing the element onto the front of the new list, and re-reversing. It feels like this operation would be necessary to read elements further than what have been accessed on an infinite list.. but that also feels wrong.
03:15:39 <ski> mjrosenb : voila : the entire intermediate list is never constructed
03:15:59 <quicksilver> cads: what operation is there that adds an element to the end?
03:16:24 <mjrosenb> ski: neato.
03:16:28 <quicksilver> cads: I think you have your levels confused. On the one hand we have haskell semantics, and on the other hand we have compiler implementation.
03:16:43 <quicksilver> cads: at the level of haskell semantics, the list is always there, and it's always infinite.
03:16:57 <quicksilver> cads: at the level of compiler implementation, the compiler uses mutation to re-write the end of the list.
03:17:01 <mjrosenb> ski: so why did they give build the rank2 type rather than the one that was inferred?
03:17:25 <ski> mjrosenb : so to speak, we are short-circuiting the `cons' and `nil' operations passed to `foldr' into the originally `(:)' and `[]' uses in the function (which now have been replaced by `cons' and `nil' inside a `build (\cons nil -> ...)')
03:17:40 <cads> quicksilver: ah, I am confusing those levels aren't I
03:18:13 <ski> mjrosenb : rank-2 (and generally rank-`n'-types, for `n' greater than 1) can't be inferred in general
03:18:18 <mjrosenb> ski: presumably ghc attempts to turn foldr's into bulids itself
03:18:33 <mjrosenb> ski: right, but why do we want it to be that type?
03:19:01 <ski> mjrosenb : the issue is somewhat similar to polymorphic recursion : you have to explicitly state the type signature you want, and the implementation (GHC and Hugs, at least) will accept it as is (checking that it is correct, of course)
03:19:22 <ski> well, we want it to be an inverse to `foldr'
03:19:31 <mjrosenb> ahh.
03:19:39 <ski> (a pre-inverse, specifically .. though it is actually a post-inverse, too)
03:19:50 * mjrosenb tries to figure out how to call build
03:19:51 <ski> `foldr' can construct a result of any type `b'
03:19:53 <ski> @type foldr
03:19:54 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
03:20:29 <cads> quicksilver: I was thinking of an intermediary list kept on the heap representing an infinite list. Then there'd be the likes of (\x -> (++[x])) to add values to the end of that list if more are needed. Which I see now is not necessary. We're talking about the implementation here and we can use mutation as you say.
03:20:49 <ski> so we want the argument of `build' to also possibly be able to return a result of any arbitrary type `b' (chosen *not* by the called of `build' but by `build' itself (though effectively the wrapping `foldr', when the fusion is applied)
03:20:55 <ski> @type GHC.Exts.build
03:20:56 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
03:22:13 <quicksilver> cads: good :)
03:22:44 <ski> @type let append :: [a] -> [a] -> [a]; append as0 as1 = GHC.Exts.build (\cons nil -> foldr cons (foldr cons nil as1) as0) in append
03:22:45 <lambdabot> forall a. [a] -> [a] -> [a]
03:23:21 <baaba> > let pairs xs = (snd.unzip.filter fst) $ cycle [True, False] `zip` zip xs (tail xs) in pairs [1..20]
03:23:22 <lambdabot>   [(1,2),(3,4),(5,6),(7,8),(9,10),(11,12),(13,14),(15,16),(17,18),(19,20)]
03:23:22 <ski> ^ `append' defined using `build' to make it a "good producer" (also using `foldr' to recur on its argument, to make it a "good consumer" in that argument, should it be constructed by `build')
03:24:20 <ski> mjrosenb : see that example of one call of `build'
03:24:44 <mjrosenb> build (\ cons nil -> 1 `cons` (2 `cons` nil))
03:24:55 <mjrosenb> ok, that [a] now makes a bit more sense to me...
03:26:39 <ski> right, that `build's a list
03:26:49 <ski> cads : take e.g. `take 5 (cycle "abc")'
03:26:53 <ski> @src cycle
03:26:53 <lambdabot> cycle [] = undefined
03:26:53 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
03:27:14 <ski> let us assume for the moment that this is defined as
03:27:38 <ski> hm, actually no, let's not do that :)
03:27:53 <mjrosenb> it just happens that b is always instantiated as [a]...
03:27:53 <ski> so, to evaluate the above expression
03:28:19 <mjrosenb> just i do not know that when i am giving it an argument
03:28:42 <Twey> cycle = fix . (++)
03:28:47 <ski> mjrosenb : yes, but using the `forall cons nil fold. foldr cons nil (build fold) = fold cons nil' fusion rule, the `[a]' actually doesn't happen, instead we directly get the `b' that the outer `foldr' call constructs
03:29:58 <cads> > fix . (++) $ ["kitteh", "dawg", "salamander"]
03:30:00 <lambdabot>   ["kitteh","dawg","salamander","kitteh","dawg","salamander","kitteh","dawg",...
03:30:06 <ski> > foldr (\_ n -> 1 + n) 0 (GHC.Exts.build (\cons nil -> 1 `cons` (2 `cons` nil)))  -- computing length, using `foldr' and `build'
03:30:07 <lambdabot>   Not in scope: `GHC.Exts.build'
03:30:09 <ski> bah
03:30:53 <ski> > let build :: (forall o. (a -> o -> o) -> o -> o) -> [a]; build fold = fold (:) [] in foldr (\_ n -> 1 + n) 0 (build (\cons nil -> 1 `cons` (2 `cons` nil)))  -- computing length, using `foldr' and `build'
03:30:53 <mjrosenb> ski: ok, i think i get it for reals this time.
03:30:54 <lambdabot>   2
03:31:12 <ski> if that is using the fusion rule, that is simplified by the compiler to
03:31:18 <mjrosenb> i just needed to write out something that used build
03:31:31 <ski>   let cons = \_ n -> 1 + n; nil = 0 in 1 `cons` (2 `cons` nil)
03:31:45 <ski> (which avoids the intermediate `[a]')
03:32:30 <ski> cads : anyway, i was going to evaluate `take 5 (cycle "abc")' for you ..
03:33:00 <ski>      take 5 (cycle "abc")  -- the definition of `take' notes that the first argument is larger than zero, so forces the first cell of the argument list
03:34:01 <ski>   =  take 5 (let xs = "abc" ++ xs)  -- definition of `cycle' was unfolded, we still need to get the first cell, and we get that by calling `(++)'
03:34:24 <mjrosenb> ski: i would imagine we could write something for lambdabot that could do this, then have people annotate it as needed.
03:34:32 <ski> (er, missing an ` in xs' after the `++ xs')
03:34:54 <ski>   =  take 5 (let xs = "abc" ++ xs in xs)  -- corrected
03:35:49 <ski>   =  take 5 (let xs = 'a' : xs1; xs1 = "bc" ++ xs in 'a' : xs)  -- now `take' can unfold one step
03:36:10 <cads> ah
03:36:20 <ski>   =  'a' : take (5-1) (let xs = 'a' : xs1; xs1 = "bc" ++ xs in xs)  -- `take' forces `5-1'
03:37:09 <ski> (and typo again, the final `in xs' should be `in xs1')
03:37:20 <ski>   =  'a' : take 4 (let xs = 'a' : xs1; xs1 = "bc" ++ xs in xs1)  -- `take' notes that it still is larger than zero, so forces its argument once again, which calls `(++)'
03:38:02 <ski>   =  'a' : take 4 (let xs = 'a' : xs1; xs1 = 'b' : xs2; xs2 = "c" ++ xs in 'b' : xs2)  -- `take' can now get the head of its argument and do one step
03:38:26 <ski>   =  'a' : 'b' : take (4-1) (let xs = 'a' : xs1; xs1 = 'b' : xs2; xs2 = "c" ++ xs in xs2)  -- decrement
03:38:43 <ski>   =  'a' : 'b' : take 3 (let xs = 'a' : xs1; xs1 = 'b' : xs2; xs2 = "c" ++ xs in xs2)  -- force argument, calling `(++)'
03:39:33 <ski>   =  'a' : 'b' : take 3 (let xs = 'a' : xs1; xs1 = 'b' : xs2; xs2 = 'c' : xs3; xs3 = "" ++ xs in 'c' : xs3)  -- do one `take' step
03:39:59 <ski>   =  'a' : 'b' : 'c' : take 3 (let xs = 'a' : xs1; xs1 = 'b' : xs2; xs2 = 'c' : xs3; xs3 = "" ++ xs in xs3)  -- decrement, force argument, calling `(++)'
03:40:30 <ski>   =  'a' : 'b' : 'c' : take 2 (let xs = 'a' : xs1; xs1 = 'b' : xs2; xs2 = 'c' : xs3; xs3 = xs in 'a' : xs1)  -- one `take' step
03:41:02 <cads> fantastic!
03:41:16 <ski>   =  'a' : 'b' : 'c' : 'a' : take 2 (let xs = 'a' : xs1; xs1 = 'b' : xs2; xs2 = 'c' : xs3; xs3 = xs in xs1)  -- decrement, force argument, which already is forced now !
03:41:49 <ski>   =  'a' : 'b' : 'c' : 'a' : take 1 (let xs = 'a' : xs1; xs1 = 'b' : xs2; xs2 = 'c' : xs3; xs3 = xs in 'b' : xs2)  -- one `take' step
03:42:16 <ski>   =  'a' : 'b' : 'c' : 'a' : 'b' : take 1 (let xs = 'a' : xs1; xs1 = 'b' : xs2; xs2 = 'c' : xs3; xs3 = xs in xs2)  -- decrement, force argument, which already is forced
03:43:20 <ski> er, actually, since now the count reaches zero, we don't force the argument anymore, instead we get to use the base case of `take'
03:43:34 <ski>   =  'a' : 'b' : 'c' : 'a' : 'b' : []  -- and we're done
03:43:42 <cads> amazing
03:43:53 <ski>   =  "abcab"  -- post-evaluation resugaring
03:44:02 <cads> that way of unfolding the evaluation was simply amazing
03:44:17 <cads> thank you, ski!
03:44:40 <ski> the mutation that happens underneath is above modelled by "modifying" the variable bindinds in the `let' by replacing expressions by expressions they evaluates to
03:45:44 <ski> hopefully, the above should give you a rough picture of how to think of the evaluation, and how one can construct and manipulate infinite lists without there needing to be any `[]' at the end of the list
03:46:16 <cads> It absolutely does.
03:47:00 <ski> (also, the above used a *cyclic* list .. after a few evaluations, the whole list was evaluated (and formed a cycle) .. generally that doesn't need to happen, but one can still use the same evaluation model to reason about the code, it's just that the evaluation of the list is never fully "completed")
03:48:14 * ski bows
03:48:20 * BONUS claps
03:48:20 <kmc> wall of code
03:48:31 <cads> hehe
03:48:35 <dobblego> @hoogle [a] -> a -> a
03:48:36 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
03:48:36 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
03:48:36 <lambdabot> Prelude (!!) :: [a] -> Int -> a
03:48:36 <mjrosenb> ski: even though there was a cycle in the elements that were in the list, the nodes that make up the list won't be cyclic.
03:48:52 * cads punches kmc on the arm, "what're you talking about that made _perfect_ sense"
03:49:23 <ski> mjrosenb : write something for lambdabot that does what ? the above of evaluation trace ?
03:49:33 <mjrosenb> ski: yeah.
03:49:33 <cads> I wasn't thinking about evaluation down to that level of precision before
03:50:30 <ski> mjrosenb : in typical implementations, the nodes making up a "fully evaluated" `cycle "abc"' will actually be cyclic .. so i'm not sure what you meant
03:51:08 <ivanm> dobblego: you use skype at work? :s
03:51:12 <dobblego> yes
03:51:15 <mjrosenb> cycle x isn't implemented as cycle x = x ++ cycle x?
03:51:17 <dobblego> why?
03:51:23 <ski> (i.e. the nodes will point to each other in a cyclic manner .. the actual elements of the nodes (here characters) is of course not cyclic)
03:51:31 <quicksilver> mjrosenb: no
03:51:36 <ski> @src cycle
03:51:36 <lambdabot> cycle [] = undefined
03:51:37 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
03:52:07 <roconnor> visualizing haskell data structures: http://www.youtube.com/watch?v=oujaqo9GAmA
03:52:09 <ivanm> dobblego: just found it strange, or is it a work account?
03:52:18 <ski> note the explicit naming of  xs'  there, to give a hint to the implementation that we really'd like a true cyclic list here, if it can produce such
03:52:19 <ivanm> to talk to customers, etc.?
03:52:32 <dobblego> ivanm, no, skype is used throughout our company
03:52:47 <ivanm> *nod*
03:52:57 <ivanm> OK, I thought it was you just leaving your home computer on all the time ;-)
03:53:24 <dobblego> no, it's just that at least one computer is on with me logged in and so using skype
03:53:34 <cads> thanks ski, quicksilver. You guys've greatly clarified the notion of the infinite list. To where my initial misunderstanding feels comical.
03:53:50 <fax> cads what was your intial understanding/
03:53:51 <fax> ?
03:54:08 <cads> I'll save notes in case the misunderstanding pops up again.
03:54:15 <ski> on the down-sides of cyclic lists (and other structures), note that `map toUpper (cycle "abc")' won't in present implementations actually be equivalent to `cycle (map toUpper "abc")', i.e. the former will typically not be a true cyclic list
03:54:37 <quicksilver> cad thought infinite lists were implemented as a turtle standing on elephants standing on elephants standing on elephants....
03:54:54 <ski> because `map' doesn't know it traverses a cyclic list, so it doesn't stop and construct a new cyclic list, instead just goes on and on making more nodes (when it is asked for the next node)
03:55:23 <cads> fax, I had some weird concept where the infinte list would exist in memory and have to be appended to whenever it was read further than it had been before.
03:55:35 <quicksilver> because cyclicity isn't technically a semantic property.
03:55:36 <ketil> ghci appears to stop if it encounters a 'return ()' on a line by itself.  At least when invoked from Emacs Haskell mode... is this expected behavior?
03:55:37 <cads> what quicksilver said :)
03:55:50 <quicksilver> sharing isn't semantic, although it's a shame, because we care about it.
03:55:56 <quicksilver> (perhaps we chose the wrong semantics?)
03:56:01 <ski> (one could probably get this behaviour from `map' with some kind of "HASH-CONSing" memoization of (presumably monomorphic instances of) `map')
03:56:16 <fax> cads: um that's correct unless the list has a cycle in it
03:56:18 <quicksilver> ketil: no. return() does nothing, it shouldn't stop.
03:56:39 <mjrosenb> ski: sounds like a job for a re-write rule :)
03:57:23 <ketil> bug then.
03:57:47 <ski> cads : so, imo one lesson to be learned here is that ".. the .. list would .. have to be appended to .." is really inaccurate; the list isn't appended to, instead more of the unevaluated tail of the list is forced/evaluated/materialized
03:57:59 <mjrosenb> ketil: it took a while to evaluate for me, but it returned
03:58:02 <cads> fax, I thought that each time the list was appended to you'd have to literally take the existing intermediary list, reverse it, cons an item onto it, and then reverse it again
03:58:11 * mjrosenb suspects that ghc was swapped out.
03:58:32 <fax> cads - ah, that's not possible
03:58:53 <ski> cads : at each point, the unevaluated tail of the list "knows" the expression to evaluate to "extend" it further, so one can e.g. never "from the outside" decide arbitrarily to "append `42' to the list"
03:59:25 <Gracenotes> hm: "In your application, try to tell us as much as possible about yourself, and what you want to do. It is much easier to judge a long proposal than a short one. Sell yourself."
03:59:41 <mjrosenb> Gracenotes: gsoc?
03:59:45 <Gracenotes> yeah. you guys had better like long ones, because I'm up to over 2000 words ;)
03:59:48 <ski> mjrosenb : that would work, too .. but probably won't fire if there's (unfolded) calls between the one that constructs the list and the one that calls `map'
03:59:53 <Gracenotes> no wonder why it's taking me so long... grr
04:00:38 <mjrosenb> ski: it doesn't fire any rules after inlining?
04:00:39 <Gracenotes> this'll end up being the only application I submit this year
04:01:00 <ski> mjrosenb : so it is a bit brittle to depend on `RULES' - a bit hard to predict which cases are "safe", i.e. the rule will definitely fire
04:01:02 * mjrosenb has always meant to play around with rewrite rules.
04:01:12 <ski> mjrosenb : sure .. but in case it doesn't inline
04:01:22 <ketil> mjrosenb, hm - I hit C-c C-l in emacs, and got tons of missing definitions - ie. all after the return statement.
04:01:24 <dobblego> @hoogle safeHead
04:01:25 <lambdabot> Data.ByteString.Unsafe unsafeHead :: ByteString -> Word8
04:01:45 <Gracenotes> @hackage safe
04:01:45 <lambdabot> http://hackage.haskell.org/package/safe
04:01:57 <ivanm> hmmm.... this looks wrong; you're seriously trying to tell me that people hardly ever talk about Haskell on Freenode? http://langpop.com/
04:02:22 <dobblego> @type flip fromMaybe . maybeToList
04:02:23 <lambdabot>     Couldn't match expected type `Maybe b' against inferred type `[a]'
04:02:23 <lambdabot>       Expected type: Maybe a -> Maybe b
04:02:24 <lambdabot>       Inferred type: Maybe a -> [a]
04:03:07 <dobblego> @type flip fromMaybe . listToMaybe
04:03:08 <lambdabot> forall b. [b] -> b -> b
04:05:08 <cads> ski, what really helped me understand that was the tail 5 (cycle "abc") example where the kind of 'list intermediaries' became lists with a single element defined up front and expression for evaluating the tail. Rather than lists as these mutable objects that were shuffled around and 'consed onto the ends of' by some magical un-named force, the lists became these statically defined objects where the implications of their definitions were expanded out step by ste
04:05:49 <ski> (cut off at ".. were expanded out step by ste")
04:06:04 <cads> "expanded out step by step by function evaluation rules."
04:06:42 <ski> yes, these `xs1',`xs2',&c. were of course just arbitrary variable names i made up
04:07:07 <zygoloid> there was a webpage someone posted here (maybe a week ago) that did that sort of step-by-step expansion
04:07:32 <ski> if those lists have names at all, they're probably all the `xs' from the definition of `(++)' (all *different* variables, still; because each was generated afresh from a new call to `(++)')
04:07:36 <ski> @src (++)
04:07:37 <lambdabot> []     ++ ys = ys
04:07:37 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
04:07:37 <lambdabot> -- OR
04:07:37 <lambdabot> xs ++ ys = foldr (:) ys xs
04:08:12 <ski> you can think of those `xs1',`xs2',&c. in the "trace" above as heap pointer, that point to (possibly unevaluated) expressions/values
04:11:05 <benmachine> Cale: oh whoops I broke my CGI script, it should be working again now
04:12:20 <ivanm> benmachine: what did you break?
04:13:07 <benmachine> ivanm: you mean, what is my CGI script, or how was it broken?
04:13:09 <ski> (mjrosenb : well, do you care for implementing `unfoldr' in terms of `build' ? ("not really" is a valid answer))
04:13:26 <ivanm> benmachine: what is it
04:13:34 <benmachine> ivanm: http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=map+(%2B+2)+[1%2C2%2C3]
04:14:11 <benmachine> working is, of course, a relative term :)
04:14:18 <ivanm> benmachine: ahhh, right
04:15:02 <mjrosenb> @src unfoldr
04:15:03 <lambdabot> unfoldr f b  = case f b of
04:15:03 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
04:15:03 <lambdabot>    Nothing        -> []
04:16:04 <mjrosenb> unfoldr f b = build (\cons nil -> case f b of Just (a, b') -> a `cons` unfoldr f b'; Nothing -> nil)
04:16:21 <ski> (there is one irritating thing in the implementation i came up with .. i wonder whether there's any way to avoid that .. that's why i'm asking)
04:16:42 <mjrosenb> or should i not call the outer unfoldr within the argument to build?
04:16:48 <dcoutts> kmc: I don't think the patch came through, if you're not subscribed you can attach the patch to the ticket instead (but add a comment too, attachements do not generate notifications)
04:16:49 <ski> that will not make `unfoldr' a "good producer"
04:17:05 * mjrosenb scrolls back and looks at the implementation of append
04:17:18 <ski> `build' should only be called once, for the whole list, and the same `cons' and `nil' then reused
04:17:57 <dcoutts> ski: yep, write it with a local fixpoint
04:18:10 <ski> dcoutts : try it out :)
04:19:04 <mjrosenb> ski: yeah, that is what i thought
04:20:19 <Gracenotes> dcoutts: oh, *waves*  are you still up for hackage-improving for gsoc, as it were?
04:20:27 <dcoutts> Gracenotes: yes
04:20:35 <ski> (the just above definition recursively calls `unfoldr', so repeatedly calls `build', so only the top cell will be fused with an outer `foldr', not the subsequent cells)
04:20:41 <ski> also, it is type-incorrect :)
04:20:55 <Gracenotes> ah, great. I'm finishing up a proposal, among other people doing so probably :)
04:20:59 <ski> @type let unfoldr f b = GHC.Exts.build (\cons nil -> case f b of Just (a, b') -> a `cons` unfoldr f b'; Nothing -> nil) in unfoldr
04:21:00 <lambdabot>     Inferred type is less polymorphic than expected
04:21:00 <lambdabot>       Quantified type variable `b' is mentioned in the environment:
04:21:00 <lambdabot>         unfoldr :: (t -> Maybe (a, t)) -> t -> b
04:21:19 <ski> (and that error hints for the same problem)
04:21:47 <mjrosenb> unfoldr f b = build (\cons nil ->let unfoldr' f b =  case f b of Just (a, b') -> a `cons` unfoldr' f b'; Nothing -> nil in unfoldr' f b) :-p
04:21:53 <dcoutts> Gracenotes: I'm part way through replying to your email
04:22:03 <mjrosenb> although it has the same type (i believe)
04:22:31 <ski> mjrosenb : yes, that works (and the type of  unfoldr'  is not the same as the type of  unfoldr  there)
04:22:56 <ski> @type let unfoldr f b = build (\cons nil ->let unfoldr' f b =  case f b of Just (a, b') -> a `cons` unfoldr' f b'; Nothing -> nil in unfoldr' f b) in unfoldr
04:22:57 <lambdabot> Not in scope: `build'
04:23:05 <ski> @type let unfoldr f b = GHC.Exts.build (\cons nil ->let unfoldr' f b =  case f b of Just (a, b') -> a `cons` unfoldr' f b'; Nothing -> nil in unfoldr' f b) in unfoldr
04:23:06 <lambdabot> forall t a. (t -> Maybe (a, t)) -> t -> [a]
04:23:08 <mjrosenb> ski: yeah, just tried it in ghci.
04:23:09 <ski> while
04:23:20 <mjrosenb> ski: so what is your issue with this?
04:23:41 <Gracenotes> dcoutts: okay, that would be useful. I've more-or-less come up with a scope for the project, but it can certainly expand or contract still
04:23:42 <ski>   unfoldr' :: forall a. (t -> Maybe (a, t)) -> t -> t  -- note, *no* `forall t.' here
04:23:56 <ski> (`t' is a free type variable in the inner type definition)
04:24:22 <ski> mjrosenb : ok, first, you don't really need to pass `f' around (but that's a minor point)
04:24:47 <mjrosenb> true.  i was lazy after upenter.
04:25:14 <ski> mjrosenb : the real issue is that this only calls `build' once the initial `b' has been passed .. while the internal code "morally" is independent of that `b' (since it changes `b's in each recursive call)
04:25:41 <ski> i'd like to define a local recursive function *once*, and then apply it to any given `b'
04:26:12 <ski> so e.g. `map (unfoldr step) seeds' would then only construct the local function once, instead of once for each element of `seeds'
04:27:59 <mjrosenb> ski: so it should start out looking like unfoldr f = build (\cons nil?
04:28:23 <ski> (if you're only going to call `unfoldr step' at most once, on a single seed, then this is a non-problem ..)
04:28:47 <ski> mjrosenb : yes, i'd prefer something like that .. only that i can't figure out a way to make it work
04:28:56 <ski> (i'm doubting it is possible)
04:29:44 <ivanm> preflex: seen Axman6
04:29:45 <preflex>  Axman6 was last seen on #haskell 1 hour, 30 minutes and 51 seconds ago, saying: whooo, that was quick :)
04:29:55 <ski> (it *is*, unsurprisingly, possible, if i change the type of `build' to `forall s a. (forall o. (a -> o -> o) -> o -> s -> o) -> s -> [a])', though)
04:29:55 <Axman6> sure was
04:29:56 * ivanm keeps missing Axman6 for some reason... >_>
04:30:10 <ivanm> Axman6: did lambdabot give you my @tell message?
04:30:11 <Axman6> ivanm: it's because you love me
04:30:12 <mjrosenb> well the return type of build is [a], so if you want to pass in b with unfoldr f = build ..., then you would need to unify b with forall b . (a-> b -> b)->b -> b
04:30:15 <ivanm> heh
04:30:38 <Axman6> yeah, i forget what they were though
04:30:44 <ski> (maybe instead of `(s ->)' i should use `f' assuming `Functor f', though)
04:31:16 <ivanm> Axman6: ask people that have signed up what format they want (lightning talks, etc.) and who would be interested in organising a group booking at a backpackers (and for which nights)
04:31:35 <Axman6> ah right
04:31:53 <ivanm> dobblego: btw, would you mind if I took your QC+parsec tutorial and used it for a talk for the local programming special interest group here later this year?
04:32:01 <ski> mjrosenb : right, the types don't work out, because the return type of `build' is not polymorpic, but is the concrete list type (applied to a type variable, which doesn't matter here)
04:32:12 <dobblego> ivanm, sure no problem
04:32:28 * ivanm points out that Axman6 has all the email addresses, and is thus the only person who is able to spam people that have registered
04:32:45 <Axman6> i can pass them on to you if you'd like
04:32:53 <ivanm> dobblego: ta; do you have an updated version or is it just what you used at BFG last year?
04:32:58 <ivanm> Axman6: sure, why not
04:33:03 * ivanm rubs his hands in glee at the power
04:33:04 <mjrosenb> go ghc, go!!
04:33:07 <ski> mjrosenb : otoh, since the return type of `foldr' *is* polymorphic (strictly speaking, is a type variable that is universally quantified), i can play that kind of trick with `foldr'
04:33:16 * mjrosenb watches ghc slowly drip down the wall.
04:33:53 <dobblego> ivanm, if there are any new versions they'll appear at http://projects.tmorris.net/public/haskell-intro/artifacts/
04:34:09 <dobblego> ivanm, I think I used version 0.6 last year
04:34:12 <ski> > foldr (\a k s -> k (a : s)) (\s -> s) "abcd" ""  -- "leaning so far right it comes back from the left)
04:34:13 <lambdabot>   "dcba"
04:35:10 <mjrosenb> ski: :(
04:35:23 <mjrosenb> i am happier with the redundant parentheses there
04:35:34 <mjrosenb> at least for now.
04:35:43 <ski> you mean `(foldr ...) ""' ?
04:35:53 <Cerulean> I have a function which returns a value of type IO Handle. This is the type of openFile ..., but how can I wrap IO.stdout (which is just of type Handle) in IO so I don't get a type error?
04:35:54 <mjrosenb> yes.
04:35:58 <roconnor> @src foldl
04:35:58 <lambdabot> foldl f z []     = z
04:35:58 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
04:36:14 <mjrosenb> Cerulean: return
04:36:15 <quicksilver> Cerulean: return
04:36:24 <mjrosenb> quicksilver: not quick enough :-p
04:36:41 <benmachine> still silver, though
04:36:45 <mjrosenb> mr. messenger of the gods
04:36:53 <silver> :)
04:37:03 <benmachine> oh heh
04:37:11 <benmachine> sorry silver, didn't see you there
04:37:17 <roconnor> @src reverse
04:37:17 <lambdabot> reverse = foldl (flip (:)) []
04:37:21 <silver> np
04:37:29 <ski> @type return System.IO.stdin :: IO System.IO.Handle  -- type ascription not needed in actual use
04:37:30 <lambdabot> IO GHC.IOBase.Handle
04:37:38 <roconnor> foldl f a bs = foldr (\b g x -> g (f x b)) id bs a
04:37:40 <roconnor> so
04:38:01 <ivanm> dobblego: ta
04:38:22 <Axman6> ivanm: excel, tabbed or csv?
04:38:36 <roconnor> reverse bs = foldr (\b g x -> g ((flip (:)) x b)) id bs []
04:38:55 <ivanm> Axman6: csv is probably best
04:38:56 <roconnor> reverse bs = foldr (\b g x -> g (b : x)) id bs []
04:39:04 <ivanm> tabs is easier to read but can lead to ambiguities
04:39:13 <ski> roconnor : nice deduction :)
04:39:17 <ivanm> and I prefer not to use binary file formats ;-)
04:39:19 <Cerulean> mjrosenb, quicksilver: thanks
04:39:24 <roconnor> which is what ski wrote
04:39:42 <ivanm> dobblego: can't have used 0.6 last year; it has the new logo in it
04:39:51 <ivanm> and pretty sure you gave the talk _before_ we picked the new logo
04:39:53 <mjrosenb> reverse bs = build (\cons nil -> foldr (\b g x -> g (x `cons` x)) id bs nil)
04:40:08 <mjrosenb> gah
04:40:08 * ski grins
04:40:19 <mjrosenb> needs moar polymorphism
04:40:20 <ivanm> dobblego: hmmm... for some reason I thought you covered parsec there as well; my mistake :s
04:40:29 <ski> (hm, maybe you still need a `foldr' in there)
04:40:46 <dobblego> ivanm, that was a different set of slides
04:40:52 <ivanm> ahhhh
04:41:02 <Axman6> ivanm: sent
04:41:04 <dobblego> ivanm, http://projects.tmorris.net/public/haskell-parsers/artifacts/
04:41:20 <quicksilver> community.haskell.org down?
04:41:32 <roconnor> code.haskell.org down?
04:41:43 <ski> mjrosenb : you just have a typo
04:41:49 <benmachine> didn't we switch servers not all that long ago because they kept being down?
04:41:50 <ivanm> dobblego: *nod*
04:42:11 <mjrosenb> reverse bs = build (\cons nil -> foldr (\b g x -> g (b `cons` x)) id bs nil)
04:42:21 <mjrosenb> the keys are right next to each other
04:42:33 <ski> @type let reverse bs = GHC.Exts.build (\cons nil -> foldr (\b g x -> g (b `cons` x)) id bs nil) in reverse
04:42:34 <lambdabot> forall a. [a] -> [a]
04:43:04 <mjrosenb> why does it know the type of GHC.Exts.build now?
04:43:15 <ski> @type GHC.Exts.build
04:43:16 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
04:43:19 <mjrosenb> or does it only know the type
04:43:19 <ski> it always knew
04:43:28 <benmachine> > build
04:43:30 <lambdabot>   Not in scope: `build'
04:43:30 <ski> > let reverse bs = GHC.Exts.build (\cons nil -> foldr (\b g x -> g (b `cons` x)) id bs nil) in reverse "foobar"
04:43:31 <mjrosenb> but doesn't have a definition to use
04:43:31 <lambdabot>   Not in scope: `GHC.Exts.build'
04:44:41 <ski> oh, right .. lambdabot is unfortunately inconsistent like that
04:45:36 <mjrosenb> ski: so can ghc turn most list constructors into calls to build, or does this need to be done explicitly in the libraries (and in the sources if you want to write a new way to build lists?)
04:45:44 <ski> (and for some reason it won't let be `@let' a `build', since then it confusingly complains about not having extension `TypeOperators' switched on .. while the one needed is `Rank2Types' .. not sure what's up with that)
04:46:07 <benmachine> oh I encountered something similar with haskell-src-exts
04:46:16 <ski> mjrosenb : afaik, you need to explicitly use `build' (or call functions that call `build') in libraries
04:46:21 <benmachine> I think when you do forall a . a it thinks . is a type operator
04:46:41 <mjrosenb> ski: run dons through the evil mangler?
04:46:45 <benmachine> which is erm, wrong
04:46:54 <benmachine> but there you go.
04:46:54 <ski> (and the fusion then still only happens when the intermediate calls are first unfolded, so that it spots a redex for the `foldr'/`build' rule)
04:47:36 <ski> benmachine : oh .. strange, yet
04:48:14 * hackagebot minesweeper 0.8.8.3 - Minesweeper game which is always solvable without guessing  http://hackage.haskell.org/package/minesweeper-0.8.8.3 (PeterDivianszky)
04:48:46 <mjrosenb> ohh, i wonder if that game can actually be built
04:49:30 <ski> (mjrosenb : incidentally, i think an implementation of Olin Shivers' "Multi-return function call" for Haskell (possibly in the form of "unboxed variants") would make it possible to guarrantee the fusing behaviour (when you instead use the corresponding unboxed variant types, at least))
04:49:41 <benmachine> HSE doesn't seem to know about the forall keyword at all
04:49:58 <benmachine> (I guess forall is explicitly disallowed as a typevar name?)
04:50:11 <benmachine> :t id :: forall -> forall
04:50:12 <lambdabot> parse error on input `->'
04:50:20 <benmachine> :t id :: forall forall. forall -> forall
04:50:21 <lambdabot> parse error on input `forall'
04:50:24 <benmachine> :(
04:51:16 * ski has pondered a minesweeper implementation that generates the minefield incrementally/lazily .. and in the most evil way !
04:51:25 <benmachine> hah
04:51:31 <mjrosenb> ski: yeah
04:51:33 <Itkovian_> I don't recall who wrote the returnState a line, but, thank you.
04:52:12 <ski> i.e. if one uncovers a square which could *possibly* be a mine, given the revealed information (and what may be deduced from that), then that square is forced to be a mine by the evil generator
04:52:35 <quicksilver> ski: don't you always blow up on your first move then?
04:52:40 <mjrosenb> ski: the variant i thought of was if there is a valid arrangement such that a square can be a bomb, and there is a square that you can determin is not a bomb, then you get the bomb.
04:52:44 <benmachine> ski: oh but can you steal the idea from the other minesweeper game
04:52:51 <quicksilver> on an empty board, every square could be a mine.
04:52:52 <ski> (one could make variants of this evil generator that strives for maximum evil, in some sense, instead of being maximally greedy (failing as soon as possibly))
04:52:58 <benmachine> so that if a situation is unresolvable by ingenuity alone, you are always "lucky"?
04:53:16 <benmachine> i.e. basically remove all elements of chance from the game
04:53:20 <mjrosenb> ski: my only modification on that is that if you truly must guess, then you never get a bomb.
04:53:21 <ski> (oh, and the point of this evil generator would of course be to punish "guessers" :)
04:54:05 <ski> (and, now that i think of it, for extra points, in each stage of the game, there should always be a path that leads to success (i wonder if this is possibly in a strict sense))
04:54:13 <mjrosenb> ski: because getting to 2 squares left, with 1 bomb, and having no way of telling which one is the bomb is more evil than necessary.
04:55:13 <ra1m0> how to distribute applications written in haskell?
04:55:21 <ra1m0> on major platforms
04:55:24 <ski> quicksilver : yes, one would need an exception for the initial move (possibly done by random by the game)
04:55:36 <Twey> ra1m0: Same way as any other application
04:55:47 <mjrosenb> ra1m0: cabal
04:55:53 <benmachine> ski: just have an exception for every move for which you don't have enough information to guarantee safety?
04:55:59 <ra1m0> Twey: compiling to binary and distributing it?
04:56:02 <benmachine> or is that insufficiently evil
04:56:06 <Twey> Make a cabal package and depend on cabal in your package-manager package
04:56:13 <ski> mjrosenb : ok, that sounds similar to what i was thinking about now, too :)
04:56:18 <Twey> Binaries work too, I guess
04:56:44 <mjrosenb> ski: with the 'must guess -> never a bomb' rule, then you do not need to special case the first click.
04:56:57 <ski> (on an empty board, each square *is* a mine. also each square *isn't* a mine .. vacuously :)
04:57:09 <ski> mjrosenb : hm, true
04:57:45 <Twey> ra1m0: You should definitely start with source and cabal, though
04:57:45 <ski> benmachine : which other minesweeper game ?
04:57:53 <benmachine> ski: there's one on hackage
04:58:02 <Twey> Binaries can be compiled per-distribution to match the other packages available
04:58:09 <benmachine> * minesweeper Synopsis: Minesweeper game which is always solvable without guessing
04:58:30 <ra1m0> Twey: users using the application do not have compiler or haskell installed or knowhow to do it
04:58:43 <Twey> benmachine: Isn't that the one that started this whole conversation?
04:59:04 <Twey> ra1m0: Correctly specified dependencies should remove that requirement
04:59:11 <benmachine> Twey: pass
04:59:15 <ski> benmachine : it sounds like what you and mjrosenb are suggesting is basically the same thing (it was awhile ago i thought on this, so i don't really recall how far in the analysis i came)
04:59:22 <Twey> Plus, that's the distribution-package–maintainer's job
04:59:25 <benmachine> ski: yes
04:59:48 <benmachine> Twey: oh, I guess so
04:59:52 <Twey> To take a universal package (in this case, a cabal package) and package it up for the specific distribution and versions of libraries to be used
04:59:54 * benmachine missed that
05:00:07 <ski> mjrosenb,benmachine : so, that would appear to be a nice general exception to the (always bomb if possible) rule :), ty
05:00:22 <ivanm> Axman6: so now _you_ want me to spam them all rather than you?
05:00:38 <Axman6> sure :P
05:01:40 <pokoko222> someone has done Newton method with haskell?
05:02:00 <Twey> pokoko222: Has someone?  Who?
05:02:21 <kamatsu> the newton method is an approximation of calculus
05:02:22 <pokoko222> anyone
05:02:23 <ski> so, the rule is `always bomb  if  possible *and* there exists a no-guess progress"
05:02:38 <kamatsu> i'm sure it's fairly simple, pokoko222 why do you ask?
05:02:39 <ivanm> Axman6: I can't do it right now, can you prod me if I haven't done it by sunday arvo?
05:02:47 <Axman6> sure
05:02:52 <theorbtwo> I would be quite surprised if nobody had done it.
05:03:00 <ski> coupled with `never bomb  if  possible *and* there doesn't exist a no-guess progress"
05:03:40 * ski wonders whether those two rules could be rephrased into one rule in some nice way
05:03:45 <mjrosenb> ski: yup!
05:03:50 <mjrosenb> tlww
05:03:51 <mjrosenb> err
05:03:52 <mjrosenb> hrmm
05:03:58 <stevenmarky_> nice of the bombers to place their bombs in such a configuration
05:05:30 <Twey> newtons f f' = iterate (\x -> x - (f x / f' x))
05:05:45 <Twey> Tada
05:06:06 <Twey> Thanks, Wikipedia
05:06:19 * hackagebot minesweeper 0.8.8.4 - Minesweeper game which is always solvable without guessing  http://hackage.haskell.org/package/minesweeper-0.8.8.4 (PeterDivianszky)
05:06:56 <Twey> It's confusing that Hackage only accepts real-names.  I have no idea who half the submitters are on IRC.
05:07:04 <mjrosenb> why on earth does minesweeper need TH?
05:07:06 <benmachine> thipedia
05:07:28 <mjrosenb> also
05:07:30 <quicksilver> for derive, I guess
05:07:31 <mjrosenb> <3 hackport
05:08:08 <quicksilver> which in turn (still guessing, source not browsable) is to derive binary instances?
05:08:17 <Axman6> hackport?
05:08:18 <roconnor> Twey: you find Hackage confusing but not IRC?!
05:08:32 <mjrosenb> well derive-0.1.4 is not building for me :(
05:09:01 * mjrosenb wonders if it was tested with ghc-6.12.1
05:09:26 <Twey> roconnor: Chosen pseudonyms are generally unique, or close enough
05:10:01 <roconnor> :)
05:10:01 <Twey> The culture of legal names guarantees that in no jurisdiction of which I'm aware
05:10:19 <roconnor> Hackage should require name, date of birth and place of birth.
05:10:20 * hackagebot minesweeper 0.8.8.5 - Minesweeper game which is always solvable without guessing  http://hackage.haskell.org/package/minesweeper-0.8.8.5 (PeterDivianszky)
05:10:30 <Twey> Also, the thought of having someone else choose a unique identifier for one makes my skin crawl
05:10:39 <ski>   forall pos. ([] (Bomb pos) <- <> (Bomb pos)) <- exists pos'. [] (Not (Bomb pos'))
05:10:47 <roconnor> Twey: for one?
05:10:51 <roconnor> oh
05:10:55 <roconnor> now I understand
05:11:17 <ski>   forall pos. ([] (Not (Bomb pos)) <- <> (Not (Bomb pos))) <- forall pos'. <> (Bomb pos')
05:11:17 <mjrosenb> someone is having fun with minesweeper
05:11:25 <Twey> Especially when they're mostly recycled from a vastly over-used pool of existing names — and popular religions enforce this behaviour
05:11:40 <Twey> We might as well be numbered… at least they would be unique
05:11:47 <Twey> </rant>
05:11:49 <ski> seems to be possibly correct encoding of this into modal logic (`[]' being "necessarily", and `<>' being "possibly")
05:11:51 <theorbtwo> Forgive a newbie, but why does cabal install claim "There is no available version of cairo that satisfies >=0.10" (and likewise for gtk and glade)?  Presumably for the same reason that the hackage page does not link to them, but how am I suppose to install them, then?
05:12:19 <Axman6> because gtk2hs isn't on hackage
05:12:24 <dcoutts> yet
05:12:27 <int-e> quicksilver: exactly. there are a couple of $( derive makeBinary ''... ) in there.
05:12:32 <Twey> Why isn't Gtk2Hs on Hackage?
05:12:37 <quicksilver> theorbtwo: unfortunately gtk2hs (which includes cairo) has to be installed by hand
05:12:42 <ski> those rules would be applied lazily, for each position that one uncovers
05:12:46 <quicksilver> Twey: because cabal-install can't install it
05:12:54 <Twey> But why?
05:13:00 <Twey> What does it do that breaks cabal?
05:13:09 <Adamant> Twey: governments are enforcing name over-use more than religions at this point
05:13:19 * quicksilver looks to dcoutts for a precise answer.
05:13:34 <quicksilver> something to do with a complex build system involving pre-processing the gtk2 header files I think?
05:13:39 <Twey> Adamant: How so?
05:13:58 <Adamant> Twey: a fair amount of governments only allow names they approve of, sometimes that only come from a pre-approved list
05:14:17 <Twey> Catholicism at least won't let one be baptised unless one is named after a saint or other religious figure
05:14:24 <Twey> Which governments do that?
05:14:33 <Twey> I know that a lot of governments limit the characters allowed in a name
05:14:37 <Adamant> Twey: Scand and Japanese
05:14:38 <kamatsu> Twey: They don't do that anymore
05:14:50 <Gracenotes> it's described somewhere...
05:14:57 <Gracenotes> Twey: http://www.mail-archive.com/gtk2hs-devel@lists.sourceforge.net/msg00314.html
05:15:02 <Twey> Adamant: That's not true… Japanese limit the characters, not the whole name
05:15:15 <theorbtwo> There's also an old and common hack around that -- your baptismal name is not neccessarly the same as your normal name or your legal name.
05:15:19 <Twey> Adamant: Scandinavian governments just have ‘reasonable name’ requirements
05:15:25 <Twey> theorbtwo: That's true
05:15:27 <Gracenotes> although there has been recent progress, looks like :)
05:15:35 <Twey> kamatsu: ‘They’ meaning the Catholic Church?
05:15:42 <Twey> Gracenotes: Ooh
05:15:43 <kamatsu> yup
05:15:47 <Adamant> Twey: are you sure? I think some just have reasonable name requirements
05:16:06 <Adamant> but I think others require Scand-ish names for folks from there born to Scand parents
05:16:25 <Twey> kamatsu: Oh, when did they change that?
05:16:31 <Twey> Gracenotes: Ah, I see… what a trial :-\
05:16:33 <mjrosenb> moon unit, dweezil, diva thin muffin pigeen, etc.
05:16:46 <Twey> Gracenotes: But I thought I heard the other day that Cabal allows arbitrary code execution?
05:16:58 <Gracenotes> :o
05:17:13 <kamatsu> Twey: I'm not sure, but i remember my cousin being surprised about it when they had their kid baptised.
05:17:15 <Twey> Adamant: Oh, interesting… which ones?
05:17:32 * Gracenotes puts cabal in a box and vows to only take it out when it's behaving
05:17:36 <Adamant> Twey: let me check, i could be misinterpreting the reasonable name stuff
05:17:46 <Twey> theorbtwo: The other is to give the child a ‘Christian’ middle name that nobody will ever use again
05:17:53 <Adamant> or it might go beyond not putting obscenities
05:17:54 <dcoutts> Twey, Gracenotes: indeed, you can put arbitrary evil in your Setup.hs for example
05:18:42 <Gracenotes> I'm not sure gtk2hs's pre-compiling code is in Haskell, though, or if it can mesh with cabal's build order.
05:19:19 <Adamant> Twey: looks like the reasonable name requirement is complicated, which is probably the source
05:19:24 <Adamant> http://parenting.blogs.nytimes.com/2009/05/12/a-baby-boy-named-q/
05:19:32 <quicksilver> dcoutts: is there a Distribution.ArbitraryEvil to work as a starting point for budding evildoers?
05:19:38 <Gracenotes> sounds like it could happen soon...
05:19:40 <burp> http://hackage.haskell.org/packages/archive/time/1.1.4/doc/html/Data-Time-Clock.html#3 ← UTCTime has a Show instance, no?
05:19:55 <quicksilver> burp: yes, in Data.Time.Format
05:19:58 <dcoutts> quicksilver: file a feature request
05:19:59 <burp> ah it's not in Data.Time.Clock ;)
05:20:02 <burp> quicksilver: thanks :>
05:20:24 <quicksilver> dcoutts: I recall http://www.chiark.greenend.org.uk/~sgtatham/putty/wishlist/moon-on-stick.html
05:20:50 <ski> benmachine : i assume you mean <http://hackage.haskell.org/package/hs-pgms> rather than <http://hackage.haskell.org/package/mines> ?
05:21:06 <dcoutts> quicksilver: I particularly like the picture
05:21:34 <Gracenotes> shows you can get out of any situation with clever re-engineering
05:21:53 <quicksilver> dcoutts: very important to illustrate feature requests with relevant previously implementations.
05:22:24 <benmachine> ski: no I was talking about http://hackage.haskell.org/package/minesweeper
05:23:24 <Twey> Adamant: Yeah… http://en.wikipedia.org/wiki/Naming_law_in_Sweden
05:25:07 <ski> theorbtwo(,Twey) : maybe <http://ivanmiljenovic.wordpress.com/2010/03/15/repeat-after-me-cabal-is-not-a-package-manager/> `Repeat after me: "Cabal is not a Package Manager"' can be of some use to you ..
05:25:36 <quicksilver> I posted that link yesterday and it was roundly rebuffed.
05:25:48 <dcoutts> quicksilver: absolutely, I often encourage people submitting feature requests to clearly show how it would look from a users pov
05:25:55 <quicksilver> I still bear a suppurating gwern-shaped scar.
05:26:01 <ski> benmachine : oh, i thought you meant some other package than the one which hackagebot just before reported on
05:26:24 <dcoutts> quicksilver: but this time ivanm is here to defend himself! ;-)
05:27:58 <Twey> ski: How does this relate to Gtk2Hs?
05:30:34 <ski> (you don't have to agree with it to understand the reasoning (but it's not stated whether that is official reasoning, of course))
05:31:26 <ski> Twey : it mentioned `Gtk2Hs' as an example of what cabal can't handle (but didn't elaborate on the issue)
05:31:30 <Philonous1> quicksilver: Maybe my support comes a little late, but in it's current state cabal(-install) really is not a packet manager because - well - it doesn't manage packages. It might be that someday emacs will be a great package manager. But at the moment it just isn't.
05:31:57 * ski doesn't really know very much about this, and would appreciate elaboration
05:32:37 <roconnor> ghc-pkg is a package manager
05:33:01 <benmachine> ski: no the first time I mentioned it I missed the hackagebot thing entirely
05:33:12 <Philonous1> roconnor: No, ghc-pkg doesn't delete the files associated with the package, a feature one might deem essential for a package manager
05:33:49 <Twey> ski: Ahuh
05:33:50 <roconnor> ah
05:34:01 <stevenmarky_> it's a broken package manager then.
05:34:05 <roconnor> well, I was going to say that ghc-pkg is a terrible package manager
05:35:09 <Philonous1> stevenmarky_: It lacks more features. It doesn't resolve conflicts, it doesn't install or update packages. It has some features of a package manager, but not enough that you could it one. Maybe it will become a real package manager someday.
05:35:21 <kamatsu> is happy case insensitive?
05:35:21 <Philonous1> call*
05:35:43 <stevenmarky_> perhaps ghc-pkg and cabal --install could be combined?
05:35:50 <kamatsu> with regards to its own identifieres
05:36:10 <ivanm> *groan* num3rs just talked about analysing the object oriented methodology behind the source code of a _web site_
05:36:37 <kamatsu> oh nevermind
05:36:38 <Axman6> heh
05:36:42 <winxordie> ivanm: don't you code websites in ruby? :P
05:36:55 <ivanm> nope
05:37:11 <ivanm> and AFAICT they're talking about the HTML, not any server side stuff
05:37:21 <winxordie> well clearly the guys over at numb3rs do.
05:37:22 <winxordie> lol
05:37:26 <ivanm> and guess what, it matched up to some code used in an _astrophysics_ project
05:37:33 <winxordie> see?
05:37:35 <winxordie> clearly ruby.
05:37:38 <ivanm> you know, high end numeric computations?
05:37:39 <Philonous1> Don't you use the HCML - the Hyper-C++ markup language
05:37:44 <ivanm> Philonous1: heh
05:37:49 <winxordie> HCML sounds awesome actually
05:37:52 * ivanm prefers HFML
05:38:01 <winxordie> I prefer HF#ML
05:39:10 <fax> how does a mirror know to get the top and botom right?? but the left and right mixed up
05:39:17 <stevenmarky_> exactly, it's magical
05:40:37 * ski whispers "a mirror gets both the top,bottom and the left,right "correct" .. but mixes up the front,back"
05:40:57 <fax> ski :)))
05:41:36 <stevenmarky_> but I just turned 90 degrees and it mixed up my head and feet~
05:41:56 <Philonous1> fax: It's instincts. Maybe you can breed a race of mirrors that will turn you upside down.
05:42:47 <fax> lol
05:43:37 <zygoloid> fax: it doesn't. the thing closest to each edge of the mirror appears closest to that edge of the mirror.
05:44:37 <benmachine> the reason you think left and right are flipped is because when you see people in the mirror facing you you assume they have made a half-turn to face you, which would reverse their left and right
05:44:51 <benmachine> so you are expecting to see their left and right different from yours but it isn't
05:44:53 <stevenmarky_> that's what msn webcam does
05:45:06 <zygoloid> in other words, it's not reflection which swaps over left and right, it's rotation
05:45:34 <FliPPeh__> Erm
05:45:43 <FliPPeh__> Quick, transform an integer to a double
05:45:46 <FliPPeh__> ;o
05:45:49 <benmachine> okay
05:45:51 <benmachine> done
05:46:07 <FliPPeh__> You win!
05:46:09 <nothingmuch> u/w #haskell
05:46:12 <benmachine> @quote fromIntegral
05:46:13 <lambdabot> <kmc> says: head [] = peek . intPtrToPtr . fromIntegral . unsafePerformIO . randomRIO $ (0, 2^32)
05:46:15 <benmachine> no
05:46:16 <nothingmuch> /join newspeak
05:46:20 <FliPPeh__> Okay, srsly nao :)
05:46:23 <benmachine> I always get that wrong
05:46:23 <stevenmarky_> (fromInteger 12 )::Double
05:46:26 <FliPPeh__> Ahh
05:46:30 <FliPPeh__> fromInteger
05:46:33 <benmachine> @quote monochrom fromIntegral
05:46:33 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
05:46:40 <FliPPeh__> fromIntegral
05:46:49 <benmachine> fromIntegral is fromInteger . toInteger
05:46:52 <nothingmuch> it's sad that technology is like 3 orders of magnitude slower than the idiot in front of the keyboard =(
05:46:55 <benmachine> so it is fromInteger but more general
05:47:26 <nothingmuch> anybody know if there's an IRC channel for newspeak? the one on freenode is empty
05:47:45 <benmachine> nothingmuch: never heard of such a thing
05:47:58 <nothingmuch> smalltalk like language, pretty interesting
05:48:22 <benmachine> mightn't orwell claim precedent on the name?
05:48:45 <nothingmuch> the slogan is "it's doubleplusgood" or something
05:49:06 <benmachine> heh
05:49:19 <nothingmuch> i actually like the way they borrowed it, it's a very minimal language so it kinda makes sense
05:49:30 <nothingmuch> though not as minimal as it could be IMHO
05:57:46 <applicative> can I ask a dimwitted cabal install question
05:58:09 <applicative> cabal: cannot configure containers-0.3.0.0. It requires base >=4.2 && <6
05:58:09 <applicative> For the dependency on base >=4.2 && <6 there are these packages: base-4.2.0.0.
05:58:09 <applicative> However none of them are available.
05:58:09 <applicative> base-4.2.0.0 was excluded because of the top level dependency base -any
05:58:39 <mjrosenb> applicative: base is bundled with ghc
05:58:43 <applicative> How do I figure out what is saying -any.  I take it I want to restrict it somehow
05:58:49 <mjrosenb> applicative: and normally should not be updated.
05:58:54 <applicative> yes, i know
05:58:58 <mjrosenb> asetuh'l,cr.id',sutbokse'd.l'cgyf
05:59:04 <mjrosenb> Data/PContainer.lhs:14:9: Could not find module `Number.Peano':
05:59:07 <applicative> what's the solution  it isn
05:59:18 <applicative> t the usual 'hide' mtl or whatever
05:59:25 * mjrosenb is not pleased with minesweeper
06:00:07 <applicative> Is it just that I cant install containers-0.3.0.0 yet?
06:01:10 <mjrosenb> applicative: what version of ghc are you using?
06:01:21 <applicative> still 6.10, is that the problem?
06:01:28 <mjrosenb> can anyone else build the new minesweeper?
06:01:46 <mjrosenb> applicative: probably.  i don't know which base is bundled with which ghc.
06:02:38 <applicative> I have base-3.0.3.1,  base-4.1.0.0, -- maybe the problem is that I already foolishly updated it?
06:02:54 <Saizan> applicative: those base versions come by default
06:03:10 <applicative> with ghc 6.10
06:03:16 <Saizan> yeah
06:03:30 <Saizan> and you can't upgrade to base-4.2, so you can't install containers it seems
06:03:55 <Saizan> *containers-0.3
06:04:29 <applicative> I see. Not surprising, I was trying to install 'AwesomePrelude', maybe its a bit cutting edge and needs containers-03
06:05:08 <mjrosenb> applicative: is there any reason you are tied to 6.10?
06:06:25 <applicative> I'm on OS X.  I tried the platform installer of 6.12, and ... thereby wrecked everything.  I built with the new swanky *64 bit* macports 6.10 and made do with that.
06:07:07 <mjrosenb> applicative: ppc64 or amd64?
06:07:23 * Axman6 is disappointed that the 4 bit 6.10 can't build 6.12 yet :(
06:07:34 <Axman6> mjrosenb: x86_64
06:07:39 <Axman6> 64*
06:07:41 <ivanm> Axman6: "4 bit 6.10"?
06:07:52 <applicative> not ppc
06:07:53 <Saizan> and one is reserved for tagging.
06:08:11 <benmachine> eight memory addresses, then?
06:08:26 <benmachine> whoever needs to remember more than 8 things anyways
06:08:32 <Saizan> right.
06:08:59 <applicative> is that right Axman, I cant bootstrap to a fancy 6.12
06:09:10 <Axman6> well, it failed for me
06:09:22 <mjrosenb> as long as your system words are 16777216 bytes long, there shouldn't be any issues.
06:09:51 <Axman6> i wonder if a double bootstrap might work. the 6.12 build completed, but failed most of the tests in the testsuite
06:10:30 <mjrosenb> Axman6: you mean build a buggy 6.12, then build a new 6.12 with the buggy one and hope to dear god it works?
06:10:30 <applicative> the version of 6.10 I wrecked was the carefully patched one for the snow leopard 32 v 64 nonsense.  It is pleasant not to have to deal with it
06:10:58 <Axman6> mjrosenb: basically. hoping that the code in 6.12 is simple enough that it doesn't hit any of the broken bits ;)
06:11:10 <Axman6> applicative: aye
06:11:47 <roconnor> can I actually use this fancy shape polymorphic data parallel haskell stuff right now?
06:12:05 <applicative> compiled things do seem to work faster, but 32 v 64 etc. is not something I care about, it's over my head really
06:12:16 <Axman6> Repa? once it's released
06:12:23 <medical> /window 23
06:12:43 <medical> whoops :)
06:14:06 <applicative> Axman would your double bootstrapping scheme make a uniformly 64 bit ghc 6.12, if it worked, I mean, without forging orders to the gcc and so on
06:14:27 <Axman6> eh?
06:14:46 <applicative> Axman6	i wonder if a double bootstrap might work. the 6.12 build completed, but failed most of the tests in the testsuite
06:14:55 <applicative> ^^^
06:15:19 <roconnor> iterate building ghc until it reaches a "fixed" point
06:15:22 <Axman6> i was just hypothesising. but by all means try it
06:15:47 <applicative> hahah, I think I'm the last man to be appointed to the task.  On the other hand, i think i
06:15:58 <applicative> have broken enought that it's time to reinstall the OS
06:16:19 <mjrosenb> applicative: that is an impressive level of breakage
06:16:41 <applicative> i have an unusual capacity to introduce defects in the Perl installation
06:16:45 <SamB_XP> roconnor: it wouldn't necessarily ;-P
06:16:53 <SamB_XP> it might just reach fixpoint which was still broken
06:17:01 <SamB_XP> or it might fail at some iteration
06:17:15 <SamB_XP> anyway ... how would you tell when it reached a fixpoint?
06:17:19 <applicative> SamB_XP	are you suggesting the in the idea limit of progress, the ghc is broken
06:18:08 <SamB_XP> applicative: I think I've heard more intelligable sentances from mehahal than that last one ;-P
06:18:40 <Aristid> i somehow fail to find info on this in the wiki... is the ghc gc concurrent?
06:18:49 <applicative> in the ideal limit of progress  -- a standard formula
06:19:01 <SamB_XP> Aristid: I believe that GHC has a concurrent GC now
06:19:14 <SamB_XP> I don't *think* I drempt it
06:19:15 <Axman6> but it's still a stop the world GC
06:19:25 <SamB_XP> oh, right, true
06:19:33 <Axman6> it will use multiple threads for collection though
06:20:56 <Axman6> i think
06:21:03 <Aristid> Axman6: hmm that means you'll have to use multiple OS processes if you don't want the world stopped?
06:21:18 <Axman6> most likely
06:21:30 <SamB_XP> Aristid: or just don't have a big enough live set that it's an issue ?
06:22:23 <SamB_XP> the size of the live set is the thing our big-O depends on
06:24:22 <SamB_XP> say, does anyone know when the "CSS history leak plug" release of firefox is coming?
06:24:57 <Twey> Can it be plugged?
06:25:32 <SamB_XP> @google mozilla css history
06:25:34 <lambdabot> http://blog.mozilla.com/security/2010/03/31/plugging-the-css-history-leak/
06:25:34 <lambdabot> Title: Plugging the CSS History Leak at Mozilla Security Blog
06:26:02 <SamB_XP> Twey: well, they're restricting the changes to color AND lying to javascript that asks about it
06:26:33 <applicative> you can't lie to javascript
06:26:39 <SamB_XP> applicative: hmm?
06:26:53 <SamB_XP> I mean, they're not reporting the computed styles that they actually use for visited links
06:26:54 <applicative> javascript isn't a fellow human subject
06:27:17 <SamB_XP> applicative: that's not relevant
06:27:21 <applicative> i know
06:27:23 <sinelaw> call me stupid, but i just implemented curry in javascript.
06:27:26 <zygoloid> nothingmuch: did you mean newsqueak?
06:27:52 <applicative> excellent work sinelaw.  spread the gospel everywhere.
06:28:08 <SamB_XP> the point is, they're changing the getComputedStyle method so that it does not return the style that is actually used to display visited links, but instead returns the one for unvisited links
06:29:00 <applicative> i occasionally try to learn javascript, it would be useful, but it's so damn ugly considering what it does.  Why not s-expressions or something tasteful like that
06:29:19 <Jafet> And yet we're still sending referers. Or referrers.
06:29:43 <roconnor> is sending referers bad?
06:30:18 * SamB_XP wonders whether this will affect the computed style displayed by firebug?
06:30:21 <fax> I don't like it
06:30:37 <roconnor> there must be a way to disable it, right?
06:30:58 <fax> if you disable it though, some sites will screw with you
06:31:00 <SamB_XP> Jafet: it's not as bad to send referrers as it is to let the opponent ask whether we've been to ANY url they please
06:31:09 <fax> (this is the reason I don't like it)
06:31:36 <Jafet> Hm, is that how that javascript history checker hack worked
06:31:44 <Twey> SamB_XP: Well that's a sane choice…
06:32:05 <Twey> sinelaw: Everyone's done that :þ
06:32:29 <SamB_XP> the other day I caught something actually DOING that
06:32:41 <SamB_XP> at least, it sure LOOKED like it was
06:32:50 <Jafet> sinelaw, haskell to javascript compiler!
06:32:56 <roconnor> I worry more about my user agent string
06:33:03 <SamB_XP> add2anything, it might have been called
06:33:30 <SamB_XP> @google portable applications
06:33:32 <lambdabot> http://portableapps.com/
06:33:32 <lambdabot> Title: PortableApps.com - Portable software for USB drives
06:33:33 <Twey> http://www.dynamicdrive.com/forums/showthread.php?p=103043 http://osteele.com/sources/javascript/functional/
06:33:37 <SamB_XP> at that site
06:33:42 <Twey> Jafet: We've got one of those, too
06:33:50 <Twey> http://www.haskell.org/haskellwiki/Yhc/Javascript
06:33:59 <Jafet> Only one?
06:34:10 <SamB_XP> Jafet: I said I *caught* it doing that
06:34:12 <Jafet> Common Lisp has like four
06:34:15 <applicative> see, and you guys wouldn't help me with the AmazingPrelude, its kindofa haskell to javascript compiler, a javascript writer
06:34:30 <Jafet> SamB, er, caught what?
06:34:43 <Twey> applicative: No it isn't, it's just a prelude with all the concrete types replaced by classes
06:34:58 <SamB_XP> Jafet: er, wait, you're talking about something entirely different
06:35:07 <SamB_XP> nevermind!
06:35:22 <Twey> Oh wait, that was the AwesomePrelude
06:35:23 <applicative> yes, but one purposes of the abstracting to classes is that the expressions can be reinterpreted as javascript values
06:35:29 * SamB_XP thought Jafet had been suggesting that many more things actually exploit the CSS history leak
06:35:44 <applicative> if i understand.  yes, AwesomePrelude, my mild retardation is familiar
06:35:49 <Twey> applicative: That's a motivating case for it, in a separate library
06:36:15 <applicative> yes, i understand what it does. Or rather, want to understand better, for a parallel plan
06:37:46 <Jafet> SamB, that website was some sort of demo, it made your browser somehow report if you'd visited any of a fixed number of sites
06:38:06 <SamB_XP> @google what the internet knows about you
06:38:07 <lambdabot> http://www.whattheinternetknowsaboutyou.com/docs/details.html
06:38:07 <lambdabot> Title: What the Internet knows about you
06:38:35 <SamB_XP> Jafet: that site?
06:38:47 <SamB_XP> @google startpanic
06:38:47 <lambdabot> No Result Found.
06:38:52 <SamB_XP> @google start panic
06:38:53 <lambdabot> http://www.myspace.com/startthepanic
06:38:54 <lambdabot> Title: Start The Panic on MySpace Music - Free Streaming MP3s, Pictures & Music Downloa ...
06:38:58 <SamB_XP> that's not it...
06:39:03 <Jafet> Probably
06:39:04 <SamB_XP> http://startpanic.com
06:39:16 <SamB_XP> http://startpanic.net
06:39:21 <SamB_XP> http://startpanic.org
06:39:24 <SamB_XP> hmm.
06:39:32 <SamB_XP> I coulda sworn there was a site named that!
06:39:44 <danderson> startpanic.com is right
06:40:41 <SamB_XP> I think with current mozilla versions, the only way to plug the leak is to turn off the visited link feature entirely
06:40:46 <SamB_XP> which is kinda unusable ...
06:40:59 <danderson> the newer firefox plugs that leak
06:41:06 <danderson> by making less information accessible to javascript via the DOM
06:41:20 <danderson> everything still renders correctly, but malicious javascript gets lied to.
06:41:23 <SamB_XP> which version plugs it?
06:41:40 <Jafet> What we're missing is a framework to talk about privacy and security with web services.
06:41:41 <SamB_XP> and that blog implies that not everything will render the same
06:41:45 <SamB_XP> only sane sites ;-)
06:41:57 <Jafet> Until we have that framework, all security will be dictatorial, arbitrary and ad-hoc.
06:42:14 <dcoutts> applicative: did you work out the cabal error? it's saying it needs ghc-6.12
06:42:24 <Philonous1> Is this startpanic.com thing supposed to tell me which sites I've visited? because it only says "startpanic.com". And to tell me that is rather vacuous
06:42:47 <SamB_XP> Philippa: did you click the button/link?
06:42:51 <SamB_XP> it doesn't start automatically
06:42:53 <Philonous1> Yeah
06:42:59 <applicative> dcoutts, yeah, i think my rather unhelpful friends led me to grasp that i needed 6.12 by a barrage of humilations
06:43:09 <Philonous1> I had to unblock javascript for the site.
06:43:10 <stevenmarky_> it worked for me
06:43:12 <SamB_XP> alternatively, you could look at this kitteh: http://www.whattheinternetknowsaboutyou.com/cute_kitten
06:43:24 <SamB_XP> Philonous1: oh, yeah, that works too
06:43:27 <SamB_XP> to block the leak
06:43:41 <Philonous1> Well, I activated java script
06:43:44 <Philonous1> So it can't be that
06:43:50 <applicative> dcoutts, how exactly do it tell that from the cabal complaint?  I guess it's obvious
06:44:06 <dcoutts> applicative: sorry the cabal error message is so bad, the "-any" is actually a constraint on the thing being installed, but it does not show that in the text output, just the lack of version constaint
06:44:36 <Philonous1> SamB_XP: That kitteh - is it supposed to do something?
06:45:05 <stevenmarky_> it didn't get the sites I visited in incognito mode!
06:45:27 <applicative> dcoutts, if it's saying, I'm not going to install that version of base, it's because the ghc is too old?  I mean -- as a rule for interpreting
06:46:02 <dcoutts> applicative: no, it's saying it is only prepared to use existing installed versions, it will not install new version of base
06:46:02 <Philonous1> Oh, that must be it. I've instructed FF to start in "porn mode". I got tired of deleting my history every 3 sites
06:46:24 <applicative> i see, so it's a separate fact that I also can't install that version of base
06:46:51 <ivanm> applicative: you can't install base separately; it comes with the compiler...
06:47:17 <applicative> right, i grasp that, and then ungrasp it
06:48:00 <ivanm> apparently "haskell.org" is called "Planet Haskell" and is a "Popular tech site"
06:48:03 <sinelaw> applicative, i have a plan to do that, too
06:48:07 <applicative> in this case, I am misled by the fact that more than one base can come with the compiler
06:49:09 <applicative> dcoutts, the version business is hard, I am grateful to you for having figured so of it much out.
06:49:11 <somebody__> cale> hi
06:50:21 <ivanm> somebody__: does your IRC client come with a Cale prompt?
06:50:47 <somebody__> :)
06:50:49 <somebody__> yes
06:50:57 <applicative> cale> > foldr (+) 0 [1...10]
06:51:02 <Jafet> That gives me an idea to resolve the conflict between pedagogical and demonstrative uses of ghci
06:51:07 <ivanm> applicative: obviously yours doesn't!
06:51:22 <Jafet> Prefix > to use the prelude, prefix Cale> to use caleskell
06:51:36 <byorgey> or maybe just C>
06:51:44 <roconnor> heh
06:51:47 <fax> how about  Prelude>   to use that rubbish
06:51:51 <mjrosenb> well we want it to be like we are talking to cale
06:51:56 <applicative> cale> foldr (+) 0 [1...10]
06:51:57 <mjrosenb> so it should be C:>
06:52:01 <ivanm> @slap fax
06:52:01 * lambdabot smashes a lamp on fax's head
06:52:03 <roconnor> Cale> would be even more annoying for Cale than @stereo was
06:52:06 <fax> fuck off
06:52:09 <mjrosenb> although it looks a it like a hat
06:52:12 <ivanm> byorgey: btw, any ideas when your new version of diagrams will be ready?
06:52:15 <mjrosenb> so i guess we should break it up
06:52:16 <somebody__> Cale
06:52:23 <fax> who ever I have on ignore that is making the bot mention me: Stop it asshole
06:52:25 <byorgey> ivanm: just as soon as I get a round tuit
06:52:26 <ivanm> roconnor: heh
06:52:37 <mjrosenb> and/or indicate that we are just using the base system
06:52:44 <ivanm> byorgey: general timeframe? we talking about months, years, decades, ... ?
06:52:46 <mjrosenb> C:\>
06:52:50 <fax> can some op PLEASE do something about this
06:52:55 <roconnor> mjrosenb++
06:53:00 <mjrosenb> fax: what is the issue?
06:53:07 <byorgey> ivanm: months, hopefully
06:53:08 <fax> some fucker keeps pissing me off
06:53:21 <ivanm> byorgey: OK, so as in 2? 3?
06:53:25 <applicative> byorgey, nice diagrams in the paper.
06:53:31 <byorgey> applicative: thanks =)
06:53:50 * ivanm is wanting to use its promised features when he has to implement some code in a few months time...
06:53:50 <byorgey> ivanm: either 2 or 6
06:53:54 <sw17ch> oh, duh... diagrams... i can use the diagrams package for my network visualization...
06:53:57 <ivanm> byorgey: hmmm...
06:54:02 * hackagebot syb 0.2 - Scrap Your Boilerplate  http://hackage.haskell.org/package/syb-0.2 (JosePedroMagalhaes)
06:54:04 <mjrosenb> fax: i got that.  what are they doing?
06:54:06 <sw17ch> why didn't i think about that before
06:54:06 <applicative> byorgey, i regret to say the content was clearly going to be over my head, but seemed absorbing in principle
06:54:09 <ivanm> byorgey: so if it isn't out within 2 months, then I probably won't be able to use it...
06:54:42 <fax> being a wankshaft?
06:54:46 <fax> fuck knows why
06:55:26 <quicksilver> fax: please moderate your language
06:55:30 <Jafet> Wankshaft, that's a new one
06:55:32 <ivanm> quicksilver: thank you
06:55:46 <fax> quicksilver please moderate the channel!! this is not the firt time this happened
06:56:01 <fax> can we get this command removed if you're not going to remove the guy that keeps doing it?
06:56:15 <ivanm> I presume you're talking about me?
06:56:31 <ivanm> oh, wait, he's ignoring me for some reason
06:56:41 <Saizan> fax: that's a very disproportionate reaction to @slap
06:56:42 <Jafet> @. vixen slap
06:56:42 <lambdabot> i didn't think so
06:56:49 <quicksilver> fax: the occasional @slap is not disrupting the channel. Your behaviour, and tone, is.
06:56:50 <ivanm> that explains why he didn't answer me when I asked why he pasted a whole load of garbage into -blah before...
06:56:51 <byorgey> ivanm: well, I'm certainly going to try my best to get something out in 2 months
06:56:54 <fax> Saizan: I made a fuss about this last time also
06:56:57 <ivanm> byorgey: ta
06:57:11 <Saizan> fax: right, that was disproportionate too.
06:57:22 <fax> was it?? I don't think anyone noticed last time
06:57:30 <sw17ch> @slap sw17ch
06:57:30 * lambdabot jabs sw17ch with a C pointer
06:57:38 * ivanm checks his logs to see when the last time he slapped fax was
06:57:50 <sw17ch> ivanm, itwas just a few minutes ago, no?
06:57:53 <Jafet> Technically, you asked lambdabot to slap fax
06:57:54 <fax> I find this /completely inappropriate/ and I cannot understand why you lot are supporting it
06:57:55 <ivanm> sw17ch: before that I mean
06:58:00 <sw17ch> oh, i see :)
06:58:01 <applicative> byorgey, i was looking at diagrams a while ago, is it possible, or just an imaginary dream that it could be  severed from Cairo, and made more abstract, so that one could have a 'writer' for some other drawing machine?
06:58:07 <ivanm> Jafet: true
06:58:15 <ivanm> methinks fax needs to lighten up
06:58:21 <byorgey> applicative: indeed, that's exactly what I plan to do with the next version
06:58:42 <ivanm> OK, the only time I can find when I've been on in here and #haskell-blah that _anyone_ (not just me) has done "@slap fax" was me just a few minutes ago
06:58:44 <Saizan> fax: i think you're misinterpreting the tone and purpouse of @slap
06:58:44 <applicative> cool, i was trying to think about it.  Pandoc was sort of the mental model
06:58:58 <Jafet> gnuplot can print to three different tex graphics packages
06:59:01 <Jafet> All badly, though
06:59:15 <ivanm> and these logs are from 26 March 2008
06:59:16 <roconnor> haskell-chart FTW!
06:59:20 <ivanm> so I have nfi what he's talking about
06:59:29 <quicksilver> fax: being @slap'ed by the bot - once - is not a proportionate justification for a bad attitude and foul language.
06:59:33 <ivanm> Jafet: Axman6 and I are planning on starting a new one at AusHack
06:59:34 <applicative> jafet: exactly, i was thinking it would be cool if diagrams could write to a tex package
06:59:49 <ivanm> but I doubt we'll be considering tex output ;-)
06:59:50 <Saizan> ivanm: maybe it was some other nick that time
06:59:56 <fax> @tell Cale Can we please remove the slap command from lambdabot? I find it completely inappropriate (of course not everyone agrees with me)
06:59:56 <lambdabot> Consider it noted.
07:00:09 <ivanm> Saizan: this was _anyone_; I just did grep "@slap fax"
07:00:16 <Jafet> Haha, good use of quantifiers fa
07:00:21 <Jafet> s/$/x/
07:00:26 <mjrosenb> fax: i like @slap
07:00:31 <ivanm> the last time someone bitched about me slapping them all the time was MissPiggy after I slapped her once
07:00:35 <Saizan> ivanm: some other nick rather than fax
07:00:39 <mjrosenb> fax: it is how i learned about the existence of the evil mangler.
07:00:42 <Saizan> ivanm: but the same user.
07:00:46 <fax> maybe there could be a slap channel where everyone sits around slapping each other
07:00:49 <ivanm> she then bitched about everyone abusing her on -blah, and IIRC she never came to either channel ever again
07:00:52 <Saizan> ivanm: that's the same user.
07:00:56 <ivanm> (and I wasn't even frequenting -blah at the time)
07:00:59 <ivanm> Saizan: oh? it is?
07:01:01 <ivanm> heh
07:01:04 <fax> remember when people objected to lambdabot @vixen talking about some disgusting pedophile story
07:01:08 <fax> ?
07:01:09 <fax> and that got removed
07:01:10 <ivanm> Saizan: interesting.... fax has been a registered nick for 4 years
07:01:17 <fax> makes sense to remove stuff that people don't like if ask me
07:01:39 <quicksilver> it makes perfect sense to remove stuff that people don't like, and it makes perfect sense to assess various opinions and take a balanced view.
07:01:44 <ivanm> OK, in my logs I only have aavogt slapping MissPiggy once, though IIRC I did once as well
07:01:48 <roconnor> I hope we remove the @src not found remarks while we are at it.
07:01:49 <fax> quicksilver yeah
07:01:50 <quicksilver> I've never heard anyone else complain about @slap.
07:01:57 <ivanm> quicksilver: exactly
07:01:58 <quicksilver> so, your opinion is noted.
07:02:04 <ivanm> roconnor: awwww.....
07:02:06 <quicksilver> however, your foul language in response was a far worse offence.
07:02:07 <ivanm> @src @slap
07:02:07 <lambdabot> Source not found. You type like i drive.
07:02:07 <applicative> i'm not sure @vixen is such a great idea, i hadn't seen that @slap could hurt someone, maybe it is so
07:02:23 <ivanm> nope, only one slap to MissPiggy
07:02:44 <ivanm> google can only find one instance of "@slap misspiggy" once as well
07:03:02 <ivanm> can someone who fax doesn't ignore ask why she's ignored me for it, when I never did it (it was aavogt)?
07:03:07 <applicative> maybe @slap foo   should first say lambdabot> foo, is this a legitimate slap?
07:03:18 <Saizan> ivanm: it's clear that the user in question doesn't like @slap at all, not even once :)
07:03:22 <ivanm> even better: lambdabot did one of her "I won't" responses ;-)
07:03:31 <ivanm> Saizan: yet when that happened _I_ was accused about it
07:03:48 <ivanm> actually, google knows about mreh doing it
07:03:57 <roconnor> we could just program lambdabot not to slap fax
07:04:11 <ivanm> roconnor: heh
07:04:28 <applicative> roconnor, i think thats a good idea, its wrong if it hurts someones feelings
07:04:32 <mjrosenb> fax: any reason that you are ignoring ivanm?
07:04:34 <ivanm> lol: google "@slap fax" (with quotes) and see the fourth response ;-)
07:04:41 <fax> mjrosenb - because of last time this happened
07:05:10 <quicksilver> according to the log checking, it wasn't ivanm last time.
07:05:15 <Saizan> ivanm: i don't think this matters much, but i've two instances of "< ivanm> @slap MissPiggy" in my #haskell.log
07:05:25 <ivanm> Saizan: hmmm, maybe I did
07:05:27 <quicksilver> it was either aavogt or ... ok, maybe it was ;)
07:05:34 <ivanm> Saizan: I thought I did _once_, yet my logs don't say so
07:05:39 <ivanm> and I thought my logs didn't lie... :s
07:05:44 * ivanm stares at xchat
07:05:46 <Twey> Arthroscopic SLAP repair?
07:05:55 <Twey> Oh, quotes.
07:06:05 <Twey> That's interesting
07:06:12 <ivanm> anyway, now that I am outed as an evil @slapper, I shall go to bed
07:06:16 <ivanm> to dream malicious dreams
07:06:22 <Twey> I'm so used to seeing ‘without quotes’ after a quotation that I read it automatically
07:06:27 <byorgey> night ivanm =)
07:06:27 <ivanm> > "mw" ++ cycle "ah"
07:06:28 <lambdabot>   "mwahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahah...
07:06:32 <mjrosenb> fax: so anyone who has @slap'ed you in the past can do it again as much as they want, and you won't even know who to complain about?
07:06:32 <applicative> @slap ivanm -- to keep him awake
07:06:33 <lambdabot> *SMACK*, *SLAM*, take that ivanm -- to keep him awake!
07:06:43 <ivanm> applicative: heh
07:06:46 <quicksilver> ;)
07:06:57 <ivanm> mjrosenb: hey, I like that....
07:07:02 <ivanm> should I? :p
07:07:06 * ivanm feels very tempted...
07:07:20 <EvanR-work> @slap EvanR-work
07:07:21 <lambdabot> *SMACK*, *SLAM*, take that EvanR-work!
07:07:31 <ivanm> EvanR-work: OK, so you're masochistic
07:07:37 <fax> mjrosenb- I don't know, this whole thing is tremendously irritating and distracting, I'm against it
07:07:41 <EvanR-work> trying to figure out why this is so offensive
07:07:58 <portnov> suddenly, a question on a #subject. Have anyone gtk2hs working with ghc 6.12 ?
07:08:01 <ivanm> EvanR-work: fax's gentle sensibilities are easily disturbed
07:08:06 <ivanm> portnov: not a released version, no
07:08:12 <ivanm> you either get HEAD or apply a patch
07:08:13 <applicative> EvanR-work not everyone is the same.
07:08:26 <ivanm> portnov: e.g. we apply the patch on Gentoo
07:08:37 * ivanm -> zzzzzzzzzzzzzzzz
07:08:37 <byorgey> portnov: I have the darcs HEAD version working, it was pretty easy to compile
07:08:41 <EvanR-work> i know that, i watch childrens television too
07:08:42 <portnov> ivanm: darcs head is working? good.
07:08:43 <byorgey> just as easy as the released version
07:08:49 <roconnor> does wxHaskell build under ghc 6.12 ?
07:09:07 <roconnor> maybe it is time to all switch to wxHaskell :D
07:09:22 <quicksilver> I think it does.
07:09:23 <mjrosenb> fax: i have been slapped before, but you complaining about it is at least an order of magnitude more distracting than actually getting slapped.
07:09:54 <fax> mjrosenb why don't you PM me about it then
07:12:55 <applicative> byorgey, before I go, I was going to say what's obvious, but maybe diagrams would be clearer if the leading concetps were not like circle, line, color, but circleDescription, colorExpression, lineTerm -- what one's constituting is the type of diagram-descriptions so to speak.  (not that words liek circleDescription are advisable!)
07:13:35 <byorgey> applicative: I'm not sure I understand what you mean.
07:13:40 <ManateeLazyCat> http://news.yahoo.com/s/pcworld/20100408/tc_pcworld/achineseispmomentarilyhijackstheinternet
07:13:43 * ManateeLazyCat Power of GFW. 
07:14:16 <fax> what's GFW?
07:14:57 <applicative> i mean, ideally you are trying to write a framework that is indifferent to any particular diagram representation
07:14:58 <ManateeLazyCat> fax: Any people living in China will know Damn GFW.
07:15:06 <fax> ok
07:15:26 <EvanR-work> are you allowed to be on irc in china?
07:15:39 <byorgey> applicative: true.
07:16:01 <applicative> and the approach is to abstract the general features of all diagrams
07:16:17 <nominolo> preflex, seen chrisdone
07:16:18 <preflex>  chrisdone was last seen on #haskell-blah 17 hours, 39 minutes and 28 seconds ago, saying: * chrisdone bed
07:16:37 <fax> nominolo: he's probably half way to italy
07:16:50 <applicative> but i wonder if it would be easier to think about in the abstract is, the ways one goes about describing a diagram in different 'formats' -- what is common to those
07:17:05 <EvanR-work> oops, i think i blew manateelazycat's cover :S
07:17:51 <nominolo> fax, ok, thanks
07:21:03 <applicative> byorgey, i think i'm not making myself clear, i'm working with several mental models at once.  it will be pleasing to see a version where you abstract from commitment to cairo some.
07:22:08 <applicative> byorgey, i mean, I look forward to it.
07:23:00 <byorgey> applicative: I think I understand what you mean.
07:23:49 <byorgey> applicative: I have what I think are some good ideas on this front but they're too vague to really explain at the moment.
07:23:58 <byorgey> applicative: hopefully I can have something concrete to show soon. =)
07:24:09 <applicative> byorgey, cool
07:25:29 <applicative> byorgey, one obvious path in my fuzzy head is typeclassing all the figure elements, then you'd have instance CircleDescription Cairo where circle pt pt ...
07:26:01 <applicative> not sure how that would work, like what 'Cairo' is, for example
07:30:19 <applicative> class PointDescribingFormat format => class CircleDrawer format where circle:: PointDescription -> PointDescription -> ....  this isn't quite making sense
07:30:38 <Saizan> preflex: seen copumpkin
07:30:39 <preflex>  copumpkin was last seen on #haskell 20 days, 16 hours, 11 minutes and 59 seconds ago, saying: that seems like an odd type for an "is" function
07:31:12 <applicative> what has happened to copumpkin, always a cause of cheer.
07:32:31 <Saizan> maybe he decided to procrastinate less :)
07:33:02 <applicative> yeah, that's the natural interpretation.  i could think the same...
07:33:28 <applicative> byorgey:  anyway, sorry that was so opaque, i will meditate on making it more lucid
07:45:01 <stepcut> how can I do, runhaskell Foo.hs, if Foo.hs depends on a hidden package ?
07:45:54 <quicksilver> runhaskell -package blah Foo.hs
07:45:55 <quicksilver> (guessing)
07:45:57 <stepcut> if I do, runhaskell -package binary Foo.hs, then it does not automatically chase down the other packages (I think) I can get an error "Not in scope: main"
07:45:57 <stepcut> "
07:46:27 <quicksilver> I don't know the answer, let me ask a question instead
07:46:30 <quicksilver> why are you using runhaskell :)
07:46:35 <quicksilver> any reason not to compile?
07:48:17 <fasta> There are a lot of reasons not to compile, imho.
07:48:31 <fasta> quicksilver, have you ever seen the Self presentation?
07:50:07 <jmcarthur> when not using cabal-install i tend not to compile Setup.lhs, for example
07:50:28 <stepcut> quicksilver: trying to figure out how to run tests from a .cabal / Setup.hs ?
07:50:50 <quicksilver> fasta: no.
07:51:00 <quicksilver> stepcut: fair enough. I can't help you there :(
07:51:47 <fasta> quicksilver, they have this concept of having a running system at all times, which I think as being a good idea.
07:52:02 <stepcut> I wonder how I put /* in a document with out cpphs thinking it is a comment :(
07:52:08 <fasta> quicksilver, and they already had it working in 1995, I wonder why they never did anything with it.
07:52:17 <dankna> that's borrowed from Extreme Programming, that concep
07:52:22 <dankna> *concept
07:52:27 <fasta> dankna, you don't understand.
07:52:32 <dankna> oh?
07:52:50 <fasta> dankna, by "always running", they mean that the system never needs to be "recompiled" for example.
07:52:55 <dankna> oh, hm
07:52:59 <dankna> that's an interesting idea
07:53:00 <fasta> dankna, it really literally never stops.
07:53:27 <fasta> The GUI was programmable using the same concepts.
07:53:31 <dankna> the problem with it - Lisp allows something similar - is that the source is not always sufficient to reconstruct the running state on another machine.
07:54:26 <fasta> Anyway, I wonder how that could be integrated with some kind of Coq like language, if at all.
07:54:32 <dankna> yeah, hm
07:54:53 <fasta> The concept of Coq is also great for well understood problem domains.
07:54:54 <c_wraith> isn't smalltalk the same way?  a smalltalk program is stored as the current runtime state?
07:55:32 <fasta> c_wraith, they had an implementation of Smalltalk in Self, which ran 3 times faster than the fastest commercial Smalltalk, so they claimed.
07:55:35 <dankna> I admit I don't know anything about Coq
07:56:14 <fasta> Coq insures that you are actually making progress with every line you write. From a management point of view that's great.
07:56:21 <dankna> hm
07:56:30 <fasta> You don't have to see the code that your exployees write.
07:56:42 <dankna> haha
07:56:45 <c_wraith> Hmm.  That implies it's not turing-complete, doesn't it?
07:56:46 <dankna> riiiiight
07:56:53 <fax> "you are actually making progress with every line you write" - haha no it doesn't
07:57:06 <jmcarthur> it was misphrased
07:57:10 <fasta> c_wraith, nobody needs a Turing-Complete language currently.
07:57:13 <fax> I've written pages of coq then realized it's rubbish and deleted it
07:57:30 <fasta> c_wraith, there is only one algorithm that I know of which uses Turing Completeness.
07:57:35 <c_wraith> fasta: sure.  It was more of a technical side-issue
07:57:36 <sw17ch> fasta: i've tried getting into Coq a few times and always had issues. Is there a good place to start that you'd recommend? I'm pretty fluent in Haskell, but I do'nt have too much experience with proofs yet.
07:57:46 <fasta> c_wraith, (and almost nobody uses that or derived ones in practice)
07:57:49 <jmcarthur> "uses Turing completeness" is an odd phrase to my eyes
07:58:19 <fasta> jmcarthur, by that, I mean that the person writing the program cannot predict what the program will do.
07:58:49 <jmcarthur> fasta: what algorithm is this? doesn't sound very useful
07:58:59 <fasta> jmcarthur, Levin Search for example.
07:59:00 <c_wraith> err.  doesn't writing a turing machine simulator require turing-completeness?
07:59:17 <c_wraith> Or for that matter, any sort of interpreter for a turing-complete language?
07:59:25 <jmcarthur> indeed it does
07:59:38 <fax> that's a really good example
07:59:40 <fax> (Levin Search)
07:59:46 * c_wraith goes to look up
08:00:07 <Saizan> you don't need to write one if noone needs a turing-complete language
08:00:25 <jmcarthur> but then again, perhaps the interpreter could be modelled with codata. say.. a lazy list of vm states?
08:00:47 <Taejo> is Levin Search the algorithm that solves SAT in polynomial time iff P=NP?
08:00:48 <fasta> jmcarthur, or you could encode a proof that you submit a finite object.
08:01:07 <fasta> Taejo, one of them.
08:01:23 <fasta> Taejo, not a particular sophisticated one.
08:01:46 <fasta> Taejo, the nice thing about Levin search is that if P=NP, but unprovable, Leven search still shows it.
08:01:52 <dankna> ah - I looked that up.  fascinating.
08:02:00 <fasta> It doesn't show a proof obviously, but it just happens to work all the time.
08:02:12 <Taejo> fasta: well, I've never heard the phrase before; I've heard that algorithm being called Levin's Algorithm
08:03:18 <jmcarthur> Cook-Levin theorem?
08:03:41 <jmcarthur> hard to google levin search and find a wikipedia page
08:04:51 <stevenmarky_> I need to convert a UTF-16 file to an ansi/ascii file using haskell. Does anyone have any pointers?
08:05:18 <stepcut> how do I get google chrome to open haskell .hs files in the browser instead of downloading them ?
08:05:33 <Saizan> stevenmarky_: the text package
08:05:39 <jmcarthur> stepcut: afaik that depends no server settings
08:05:42 <dankna> stepcut: you want them served as text/plain.  if it's not your server, you're out of luck.
08:05:45 <jmcarthur> *on server settings
08:05:45 <c_wraith> stepcut: serve them with content type text/plain
08:06:17 <stepcut> there is no server here, just a local file on the disk :(
08:06:30 <dankna> stepcut: out of luck, sorry
08:06:33 <stepcut> anyway, I can't control what ever other server on the planet does, but I can control my browser
08:06:47 <Saizan> write a chrome extension, and then link it to me :)
08:06:53 <fasta> stepcut, download chromium? ;)
08:06:58 <stepcut> bah. firefox has such an extension :(
08:07:07 <jmcarthur> port it
08:07:18 <EvanR-work> you can indeed control your browser, your browser is open source
08:07:29 <fasta> Does anyone use Gitit and find it terribly annoying having to input a message for a change?
08:07:46 <stepcut> EvanR-work: but not written in Haskell :(
08:07:56 <dankna> I don't use gitit, but surely messages for changes are important?
08:08:09 <fasta> dankna, if you do something trivial it is not important.
08:08:14 <dankna> hmm
08:08:16 <dankna> maybe
08:08:21 <jmcarthur> there is no default message?
08:08:29 <dankna> I'd argue that it's at least important to say "this is a trivial change" so you don't confuse it with important changes
08:08:31 <jmcarthur> i haven't used gitit in a while
08:08:46 <fasta> In fact I think the interface of a wiki could better be changed to WYSIWYG for text changes.
08:08:48 <dankna> that said, I have my share of commit messages that just say "I did stuff", so I can't preach
08:09:20 <EvanR-work> stepcut: speaking of which, its about time we have a haskell browser ;)
08:09:42 <dankna> it's been a long time since I was a member of the "rewrite everything in your favorite language" club
08:09:51 <fax> haha
08:09:55 <dankna> I think these days, we have to accept that there are other languages out there
08:10:00 <EvanR-work> including the OS
08:10:03 <dankna> yes, haha
08:10:12 <stepcut> dankna: I accept there are other languages, I just don't fix bugs in apps written in them ;)
08:10:19 <dankna> stepcut: hahahaa, well that's fair
08:10:42 <EvanR-work> man the os would be so easy in haskell, process scheduling is taking care of! ;)
08:10:42 <Saizan> not all other languages are equal either
08:10:53 <jmcarthur> i like to see haskell versions of things because i feel safer using software written in haskell
08:11:10 <dankna> you know what would be neat, is if ghc generated proof-carrying code
08:11:28 <dankna> I think pcc is a really cool idea and I'd like to see it take off
08:11:29 <jmcarthur> like TAL?
08:11:32 <Saizan> and, anyhow, a browser with an xmonad-like design would be much more hackable i think
08:11:46 <dankna> not familiar with TAL, I just read Appel's original paper on pcc a while back and fell in love with the idea
08:11:48 <jmcarthur> yeah i am in the camp that would like to see a haskell browser
08:12:13 <Saizan> we got a webkit binding recently
08:12:18 <stepcut> I just want to see a browser that (1) does not crash when  flash crashes (2) opens .hs files in the browser instead of downloading them
08:12:35 <EvanR-work> hopefully flash is on the way out now
08:12:44 * mjrosenb would like to see an open source implementation of flash that doesn't suck
08:12:55 <mjrosenb> and a million dollars
08:13:02 <stepcut> EvanR-work: to be replaced by what ?
08:13:02 <mjrosenb> the latter is more likely to happen
08:13:03 <c_wraith> I'd be ok with a closed-source implementation of flash that doesn't suck.
08:13:06 <jmcarthur> does flash require running in the same process as the browser or browser tab?
08:13:06 <dankna> Safari on 64-bit Snow Leopard runs Flash in a separate process, which is because Flash is a 32-bit library, but as as a side-effect means you get a nice error message instead of a crash when flash crashes
08:13:08 <mjrosenb> which i am also totally fine by
08:13:15 <EvanR-work> stepcut: for videos, the video element
08:13:22 <jmcarthur> dankna: huh nice
08:13:25 <dankna> jmc: yeah
08:13:48 <Saizan> chrome runs it in a different process too
08:13:54 <jmcarthur> dankna: that seems to contradict what you just said about safari
08:13:59 <stepcut> EvanR-work: if only they code pick a codec :) Also, I heard it is hard to embed videos from a different site using html5 ?
08:14:05 <dankna> what did I just say about Safari?
08:14:14 <jmcarthur> Saizan: in my chrome a crashing flash crashes the tab
08:14:16 <EvanR-work> stepcut: the 'codec war' thing is the most ridiculoud stupid thing i have ever heard
08:14:26 <EvanR-work> thats like saying 'my browser will only support one image, PNG'
08:14:29 <stepcut> dankna: yeah, konqueror did that as well.
08:14:34 <jmcarthur> dankna: you said safari isolates flash into its own process
08:14:36 <dankna> oh
08:14:45 <dankna> it does.  I don't know what other browsers do though.
08:14:46 <stepcut> EvanR-work: yeah, but it costs money to support h264
08:14:47 <EvanR-work> has anyone ever heard of making the codec part modular and using whatever codecs that are on the freaking computer
08:14:55 <EvanR-work> stepcut: not to me it doesnt
08:15:02 <EvanR-work> just download the damn codec
08:15:03 <EvanR-work> ffmpeg
08:15:16 * EvanR-work gets angry
08:15:20 <EvanR-work> people are stupid
08:15:22 <jmcarthur> i say just integrate mplayer into the browser
08:15:28 <stepcut> EvanR-work: but mozilla can not distribute a browser with the codec built in ?
08:15:29 <EvanR-work> right, thats effectively the same thing
08:15:32 <jmcarthur> yeah ffmpeg
08:15:33 <EvanR-work> stepcut: so what?
08:15:40 <EvanR-work> so. WHAT?
08:15:50 <EvanR-work> have a button that says 'install the damn codec i cant distribute'
08:15:58 <jmcarthur> stepcut: they don't need to. this is about modularity
08:16:18 <Saizan> jmcarthur: in mine i only get a sad smily in place of the video
08:16:37 <jmcarthur> Saizan: i get a sad smiley in place of the tab contents :(
08:16:44 <Ke> html5 is still way better than flash in any scenario
08:16:49 <jmcarthur> i'm using google-chrome-dev
08:16:51 <stepcut> EvanR-work: if they can't distribute the codec.. then how would the button distribute the codec ?
08:16:57 <EvanR-work> oh now, imlib2 has codecs for every image known to man, but browsers only support PNG and JPEG because the developers have never written a program in their lives?
08:17:04 <stepcut> EvanR-work: perhaps you put in your CC number and buy a license ?
08:17:11 <Ke> free flash player would still have to implement h264 for flash as well
08:17:13 <EvanR-work> stepcut: you can download it for free
08:17:41 <stevenmarky_> bmp and gif too, hey!
08:17:41 <dankna> and of course there are uses of Flash besides playing videos
08:17:46 <EvanR-work> its not even illegal
08:17:47 <dankna> little vectory games, say
08:17:52 <stepcut> EvanR-work: oh really?
08:17:56 <EvanR-work> no
08:18:07 <dankna> but it's my understanding that html5 has nice support for that stuff, although I haven't looked at it
08:18:15 <jmcarthur> very nice support for it
08:18:20 <Saizan> jmcarthur: chromium 5.0.342.8 (42697), i.e. what you get with the "chromium" package on arch linux
08:18:23 <EvanR-work> dankna: svg element
08:18:26 <dankna> ah good!
08:18:29 <stevenmarky_> sure you can just draw pixels / images on the canvas element
08:18:30 <dankna> that was how I was hoping it worked :)
08:18:38 <EvanR-work> then theres the canvas element for bitmap graphs
08:18:43 <jmcarthur> Saizan: i tried chromium in the past and found it very unstable. are things changed for you?
08:18:49 <jmcarthur> s/for you//
08:19:03 <EvanR-work> it works most of the time, but the linux version crashed on my yesterday
08:19:09 <EvanR-work> gui bug
08:19:21 <EvanR-work> browsing works fine
08:19:29 <jmcarthur> dankna: webgl is pretty cool
08:19:34 <dankna> yeah, webgl is awesome
08:19:49 <dankna> I'm looking forward to its deployment
08:19:51 <stepcut> EvanR-work: you should send your ideas to the mozilla foundation, I am sure they will be pleased to know there is a solution!
08:19:53 <Ke> jmcarthur: chromium is perfectly stable for me
08:20:16 <EvanR-work> stepcut: were talking about web developers, web users, and hipsters, they dont understand anything
08:20:37 <EvanR-work> its all run on fear uncertainty and doubt
08:20:43 <EvanR-work> and some idea that we have to have one single format
08:20:45 <Saizan> jmcarthur: i had to disable some extensions that were causing problems after an upgrade, but no other stability problem in months
08:20:52 <jmcarthur> so who wants to write an html rendering engine in haskell? ;)
08:20:57 <dankna> not me, haha
08:20:59 <EvanR-work> the point of the web is it can deliver MORE THAN ONE content type
08:21:00 <dankna> that's a huge amount of work
08:21:04 <jmcarthur> yes it is
08:21:23 <stevenmarky_> I'd do it if it doesn't have to be standards compliant hoho
08:21:34 <EvanR-work> i would not bother with standards compliance
08:21:36 <malcolmw> stepcut: cpphs --strip to convince cpphs that /* begins a comment.
08:21:47 <EvanR-work> just make it work with defacto standards
08:21:49 <EvanR-work> that arent microsoft
08:21:52 <jmcarthur> stevenmarky_: there's not such thing as a standards compliant rendering engine
08:21:59 <jmcarthur> *no such
08:22:21 <dankna> even the defacto standards are hard.  when I was writing direct-fastcgi I came across a situation with cookies where there are three specs, two of them RFCs and one informal, and actual practice doesn't match /any/ of them.
08:22:25 <stepcut> malcolmw: I want to convience cpphs that /* does not begin a comment. I have a line, Accept: */*, and it is freaking out  :)
08:22:49 <stepcut> malcolmw: I pretty much just want cpphs to look at lines that start with # and ignore everything else
08:22:52 <malcolmw> stepcut: you must have a very old version of cpphs then
08:23:23 <stepcut> malcolmw: oh, it seems I am actually using real cpp :-/
08:23:28 <malcolmw> stepcut: you could try cpphs  --nomacro if you just want conditional compilation/inclusion, without macro expansions
08:23:36 <stepcut> I'll try that
08:24:37 <malcolmw> cpphs has always accepted /* and */ and */* are not comment-related - I even used those operators in the source code of cpphs itself, to make sure :-)
08:24:56 <stepcut> k
08:25:00 <wolgo> hi
08:25:06 <stepcut> I can't remember why I switched to cpp
08:25:11 <stepcut> so I am going to try cpphs again :)
08:25:55 <Saizan> anyhiw, we should write a browser in Agda.
08:25:59 <EvanR-work> my stomach now hurts from ranting about the web. stupid work
08:26:43 <jmcarthur> the defacto standards are probably even harder than the actual standards by now
08:26:54 <jmcarthur> there being so ma
08:26:56 <jmcarthur> *many
08:27:35 <dankna> quite
08:27:37 <stepcut> Saizan: or use Agda to prove it is impossible ;)
08:28:03 <jmcarthur> yay a browser in agda
08:28:11 <goomba> google and ms should just buy mozilla a h264 licence for a year and keep them quiet
08:28:36 <fasta> Agda as proof? Does it even satisfy the the Bruijn principle already?
08:29:09 <EvanR-work> dankna: svg element in action ;) http://scripty2.com/
08:29:42 <byorgey> hi wolgo
08:29:45 <dankna> EvanR: wow that's pretty sweet
08:30:50 <dankna> I love the cards demo
08:31:26 <EvanR-work> the spinning burst background is an svg element, which is probably being rotated with javscript
08:31:31 <dankna> nodnod
08:31:55 <EvanR-work> it even works in IE ;)
08:31:56 <luite> EvanR-work: hmm, that doesn't even work too bad in IE8
08:32:02 <luite> although chrome is much smoother
08:32:05 <dankna> it really works in IE?  wow, nice
08:32:13 <EvanR-work> i thought i just tested it in IE8 on the winbox
08:32:13 <koeien37> I like the haskell platform page, but somehow I should know which Ubuntu version I have
08:32:25 <koeien37> i.e. Karmic, Jaunty. which corresponds to which?
08:32:37 <koeien37> (in terms of the official numbers)
08:33:22 <koeien37> ah it says so in the ubuntu help. Never mind.
08:37:09 <marekw2143> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24789#a24789 - after ghci tutorial.hs there is:  tutorial.hs:30:0: parse error (possibly incorrect indentation)"
08:37:29 <koeien37> yeah, you shouldn't use 'let' there
08:37:46 <koeien37> writePoint should start  in the same column as "main"
08:37:54 <koeien37> i.e. to the left
08:38:05 <ezyang> also you need a definition for writePolygon
08:38:12 <ezyang> even if it's just writePolygon = undefined
08:40:38 <marekw2143> thanks, now it works
08:40:45 <marekw2143> but why on the tutorial (http://www.lisperati.com/haskell/ht3.html) there is indentation? Is language specification changed maybe?
08:41:32 <stevenmarky_> I think that's the code you would type into GHCI
08:42:16 <stevenmarky_> writing code in GHCI and interpreting/compiling a file is a bit different
08:42:36 <ezyang> in particular, you should pretend that you're in a do-block in ghci
08:44:45 * hackagebot uacpid 1.0.1 - Userspace Advanced Configuration and Power Interface  event daemon  http://hackage.haskell.org/package/uacpid-1.0.1 (DinoMorelli)
08:48:43 <c_wraith> with the strange difference that non-IO expressions get an implicit "print" applied to them
08:49:00 <ezyang> c_wraith: s/strange/convenient/
08:49:19 <c_wraith> certainly convenient, but it's a bit strange for a do block :)
08:58:51 <FliPPeh__> How do I access HTTP realms that need authentication?
08:58:57 <FliPPeh__> (With Network.HTTP)
08:59:11 <FliPPeh__> The ones with the password dialog popping up
09:00:58 <dino-> I wonder if basic auth can help with that. http://USER:PASS@DOMAIN/FOO/BAR/...
09:01:11 <dino-> Or perhaps https
09:01:12 <FliPPeh__> dino-: Nope, just failed for me :(
09:01:22 <dino-> What the what!
09:01:24 <FliPPeh__> And it's simple HTTP, no HTTPs
09:02:18 <bmh> Can anyone suggest a good priority queue implementation? Should I just use Data.Graph.Inductive.Internal.Heap?
09:02:37 <koeien37> bmh: there is PSQueue or something like that on Hackage
09:03:03 <igel> bmh: heap :)
09:03:04 <dino-> Not sure. I've been doing basic auth with Network.Curl lately to Twitter's servers.
09:03:36 <orlandu63> > let n = Int 5
09:03:37 <lambdabot>   not an expression: `let n = Int 5'
09:03:42 <orlandu63> > n = Int 5
09:03:43 <lambdabot>   <no location info>: parse error on input `='
09:03:44 <FliPPeh__> dino-: That's exactly what I want to do :)
09:03:45 <bmh> I must confess that I implemented a number of heaps that are now on hackage, but just discovered some pathological memory behavior.
09:03:47 <bmh> oops!
09:03:49 <dino-> BTW Not even a little thrilled with their deprecation of basic auth for OAuth and xAuth. Very jerky for command-line tool devs.
09:03:50 <koeien37> > let n = 5 :: Int
09:03:51 <lambdabot>   not an expression: `let n = 5 :: Int'
09:03:54 <FliPPeh__> But I don't really want to download extra libraries..
09:03:55 <koeien37> > let n = 5 :: Int in n
09:03:56 <lambdabot>   5
09:04:30 <koeien37> orlandu63: you can force an expression to be of a certain type by adding :: Type
09:04:33 <orlandu63> koeien37: there we go
09:04:54 <koeien37> of course, it's still type-checked (it is not a "cast")
09:05:08 <koeien37> > 5 :: String -- will fail to typecheck
09:05:09 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
09:05:09 <lambdabot>    arising from the literal `...
09:05:22 <stevenmarky_>  > 5.12 :: Int
09:05:28 <stevenmarky_> gah I always do that.
09:06:02 <orlandu63> does Int have a value constructor?
09:06:29 <orlandu63> (i just started reading on them, i probably don't know what i'm saying)
09:06:32 <Raynes> gwern: Thanks for the patch, but as you can obviously see, I don't maintain that anymore, and I definitely wouldn't encourage use of it. It was really a "first sucky Haskell project" sort of thing that remains buggy.
09:06:47 <koeien37> orlandu63: no, it doesn't :) at least not for our purposes (maybe internally)
09:07:23 <orlandu63> koeien37: i see. thanks
09:15:04 <jmcarthur> Raynes: what project is this?
09:15:11 <jbapple> I posted this last night, but it was 3AM EST, so I hope nobody minds if I ask again:
09:15:14 <jbapple> I have written a Coq-verified implementation of Brodal-Okasaki priority queues. The verification is with respect to a specification I concocted for this project, and the spec is nearly as long as the implementation itself. If anyone here would like to review the spec, I would appreciate it. It can be located at http://code.google.com/p/priority-queues/source/browse/brodal-okasaki/OrderSig.v and http://code.google.com/p/priority-queues/
09:15:45 <Raynes> jmcarthur: TConfig. From forever ago.
09:16:00 <jbapple> the paper the implementation is based on: ftp://ftp.daimi.au.dk/pub/BRICS/Reports/RS/96/37/BRICS-RS-96-37.pdf
09:16:18 <orlandu63> is it possible to create polymorphic functions by pattern matching against a parameter's type
09:16:20 <orlandu63> ?
09:16:39 <orlandu63> such as `f (Int n) = 5`
09:17:03 <jmcarthur> Raynes: looks like a nice simple api to me. why drop support for it?
09:17:15 <Saizan> orlandu63: no
09:17:21 <gwern> Raynes: it still shows up on hackage reverse deps
09:17:28 <koeien37> orlandu63: no. Fortunately not.
09:17:38 <orlandu63> heh
09:17:43 <koeien37> if you want to overload, you will have to look into type classes
09:17:48 <Raynes> jmcarthur: I don't think it's very useful, and I don't really use Haskell that much anymore.
09:17:53 <Raynes> gwern: People actually use it?
09:17:58 <jmcarthur> Raynes: :(
09:18:08 <gwern> Raynes: on haskell98's devdeps
09:18:26 <Saizan> which package is this?
09:18:35 <jmcarthur> Saizan: tconfig
09:18:41 <fax> orlandu63: you can do this with GADTs
09:18:42 <jmcarthur> http://hackage.haskell.org/package/tconfig
09:20:30 <Raynes> I figured I could safely not improve it, considering there was another, more advanced configuration library.
09:20:31 <Raynes> :|
09:20:57 <aavogt> is it possible without using the ghc-api to check if a given instance exists?
09:20:57 <Raynes> I guess I might have to freshen up my Haskell and see what I can do about it.
09:21:19 <jmcarthur> Raynes: nobody's forcing your hand
09:21:47 <Raynes> jmcarthur: I know, but if anybody actually uses it, I'd like to make sure that it can actually be used.
09:22:00 <jmcarthur> Raynes: hackage doesn't disallow others from overwriting existing packages, for better or for worse. somebody else could pick up maintainance
09:22:00 <Raynes> jmcarthur: Plus, I can put this on github and if people like it, the community can mostly do the work here. ;)
09:22:12 <jmcarthur> it would be nice for it to be on github
09:22:40 <Raynes> I don't know anybody who would want to pick up maintenance. :P
09:22:45 <jmcarthur> heh
09:22:48 <Raynes> If I did, they could go right ahead and do so.
09:23:24 <jmcarthur> it looks marginally useful, at least for the IO functions. i don't personally see any purpose in using the other functions instead of the functions from Data.Map though
09:23:49 <Raynes> jmcarthur: Like I said, "First Haskell Project".
09:23:50 <Raynes> ;)
09:24:00 <jmcarthur> i'm not complaining
09:24:12 <FliPPeh__> How do I extend the parsec lexer? I'm getting "\uXXX" characters in the string, but "stringLiteral" won't fetch it
09:24:13 <Raynes> And that's also why I don't consider it very useful. It's very trivial to do.
09:24:22 <jmcarthur> nothing as sensitive as a programmer's ego ;)
09:24:29 <Raynes> Hehe.
09:24:48 <Raynes> I'll put "slap it on github" on my todo list. I'll go from there.
09:25:42 <portnov> gtk2hs from darcs does compile on ghc 6.12. But when building (ghc --make) `helloworld' with gtk2hs:
09:25:43 <portnov> Linking hello ...
09:25:43 <portnov> hello.o: In function `r3wx_info':
09:25:43 <portnov> (.text+0x46): undefined reference to `gtkzm0zi10zi1_GraphicsziUIziGtkziAbstractziWidget_widgetShowAll_closure'
09:25:57 <portnov> and a number of similar errors :/
09:26:20 <koeien37> --make
09:26:28 <portnov> i used it.
09:26:37 <koeien37> ok. I see that now. sorry for the canned response
09:27:33 <Raynes> jmcarthur: I'll probably just take care of the parsing-it-into-a-map bit and get rid of all the rest, like you pointed out.
09:28:06 <zygoloid> that demangles to: gtk-0.1.1_Graphics.UI.Gtk.Abstract.Widget_widgetShowAll_closure
09:28:48 <jmcarthur> Raynes: yeah that would be nice
09:29:01 <jmcarthur> Raynes: and either export those type synonyms or get rid of them, too
09:29:04 <zygoloid> does lambdabot have an un-z-coding plugin?
09:29:10 <Raynes> Indeed.
09:31:39 <Apocalisp> Is this some standard data type? data OneOrBoth a b = Left a | Right b | Both a b
09:32:15 <FliPPeh__> Please, anyone with experience in Parsec? I use the Token package and it's lexer to parse string literals. Because the website I'm fetching the data from is using unicode, I get "\uXXXXXX" escape codes. I found out in the token source how to implement them, but how do I implement new escape codes from OUTSIDE?
09:32:19 <Apocalisp> Either (Either a b) (a,b)
09:32:37 <aavogt> Apocalisp: (Maybe a,Maybe b)
09:32:44 <ski> fasta : would you have a link to that "Self presentation" ?
09:32:48 <ski> EvanR-work,(Saizan,stepcut) : see (old) WWWBrowser at <http://www.cs.chalmers.se/Cs/Research/Functional/Fudgets/demoform.html> :)
09:32:57 <Apocalisp> aavogt: What about (Nothing,Nothing)?
09:33:09 <koeien37> Apocalisp: it's not really standard.
09:33:34 <ski> (you could call it `IOr', for "inclusive or" :)
09:33:34 <aavogt> Apocalisp: that equivalent to _|_ for our purposes?
09:34:00 <koeien37> aavogt: that seems ugly (i.e. less safe)
09:34:03 <Apocalisp> ski: Good idea
09:34:03 <koeien37> ?
09:34:22 <aavogt> but it's true that that the value is probably unwanted
09:34:23 <koeien37> the names 'Left' and 'Right' clash with the prelude though.
09:34:25 <ski> (not that `Either' isn't in some sense also an "inclusive or", though)
09:34:58 <koeien37> but you can implement functor and monad
09:35:03 <Apocalisp> Either is exclusive, no?
09:35:07 <jmcarthur> isn't Either exclusive or?
09:35:32 <ski> if `A' and `B' are inhabited types, then `Either A B' is still inhabited
09:35:34 <koeien37> it corresponds to inclusive or via curry-howard?
09:35:38 <ski> so, "inclusive" or
09:37:07 <Daerim> Hello
09:37:44 <jmcarthur> oh right. the existence of Either a b doesn't prove a `xor` b, just a `or` b
09:37:48 <sm> morning all
09:37:50 <Apocalisp> ski: Yeah, see what you mean.
09:38:23 <sm> hledger.cabal says  "tested-with:    GHC==6.8, GHC==6.10" but http://hackage.haskell.org/package/hledger shows only "Built on ghc-6.12". Isn't that a little misleading ?
09:38:29 <ski> (but yes, "in some sense")
09:38:34 <jmcarthur> Either (Not a, b) (a, Not b)
09:38:51 <zygoloid> hmm, it's a monad too, in several ways :)
09:39:02 <koeien37> sm: "Built on" is what hackage does, probably
09:39:06 <jmcarthur> huh, that's weird too though
09:39:09 <sm> yes
09:39:37 <portnov> sm: actual hledger works with 6.12.
09:40:01 <Daerim> is there any way graphics library that "just works" under windows? Either for creating an image file, or an image on screen?
09:40:05 <dcoutts> sm: tested-with is what the author puts in
09:40:15 <sm> portnov: thanks - I've heard that, but I'm investigating a bug displaying non-ascii
09:40:23 <dcoutts> sm: it's not all that useful, once we have decent hackage results
09:40:36 <ski> @djinn Not (Either (a,Not b) (Not a,b)) -> (a -> b,b -> a)
09:40:36 <lambdabot> -- f cannot be realized.
09:40:54 <sm> dcoutts: tested-with is useful information we should display, right ?
09:41:02 <FliPPeh__> Okay, I'll try it the other way
09:41:04 <dcoutts> sm: only if we believe it
09:41:17 <dcoutts> sm: I'd prefer to display aggregated build results
09:41:20 <sm> I always considered it useful
09:41:28 <Apocalisp> zygoloid: What's a monad? OneOrBoth?
09:41:29 <FliPPeh__> I have a fairly large string, and there could be "\uXXX" parts in there. How do I transform those to "\xXXX" ?
09:41:31 <koeien37> if it's updated, it is.
09:41:34 <zygoloid> Apocalisp: yeah.
09:41:55 <fax> @djinn Not (Either (a,Not b) (Not a,b)) -> Not (Not (a -> b,b -> a))
09:42:00 <lambdabot> f a b =
09:42:01 <portnov> sm: remove/comment all `import System.IO.UTF8' lines from sources.
09:42:02 <lambdabot>     void (b (\ c ->
09:42:06 <lambdabot>              void (a (Left (c,
09:42:08 <lambdabot>                             \ d ->
09:42:10 <lambdabot>                             a (Right (\ e ->
09:42:12 <lambdabot> Plugin `djinn' failed with: thread killed
09:42:20 <ski> @djinn Not (Either (a,NotNot b) (NotNot a,b)) -> (a -> Not b,b -> Not a)
09:42:21 <lambdabot> f a =
09:42:21 <lambdabot>     (\ b c -> void (a (Left (b, \ d -> d c))),
09:42:21 <lambdabot>      \ e f -> void (a (Left (f, \ g -> g e))))
09:42:34 <Apocalisp> this is for a generalization of zipWith :: (OneOrBoth a b -> c) -> f a -> f b -> f c
09:42:44 <fax> @djinn Not (Either (a,Not b) (Not a,b)) -> (Not a -> b,Not b -> a)
09:42:44 <lambdabot> -- f cannot be realized.
09:42:45 <sm> portnov: I think that's it.. that fix for 6.12 is in head but not the release he's using. THanks
09:42:54 <zygoloid> Apocalisp: CompileResult e a = Error e | Warning e a | Success a :)
09:43:19 <Apocalisp> Hah
09:44:09 <zygoloid> Apocalisp: the generalization doesn't generalize nicely to more than 2 objects
09:44:26 <gwern> http://blacksapphire.com/antispam/ <-- what a peculiar way to give out an email address
09:44:26 <Apocalisp> no zipWith3
09:44:44 <orlandu63> @src Char
09:44:44 <lambdabot> data Char = C# Char#
09:44:52 <zygoloid> "zipWith :: (Maybe a -> Maybe b -> c) -> f a -> f b -> f c" does generalize nicely in the usual way
09:44:54 <orlandu63> what does that mean?
09:44:58 <ski> @index zipWith3
09:44:58 <lambdabot> Data.List, Prelude
09:45:30 <zygoloid> orlandu63: that's how Char is internally implemented. A constructor called 'C#' containing a value of type 'Char#'
09:45:33 <Apocalisp> zygoloid: It does if f has a Zero
09:46:04 <zygoloid> orlandu63: names ending in # are usually not permitted (# is usually an operator character)
09:46:38 <orlandu63> zygoloid: i see
09:46:44 <ski> orlandu63 : that's how `Char' is implemented in GHC .. you don't need to pay any attention to it (i.e. you can treat it as an abstract type), unless you really want to
09:46:48 <zygoloid> orlandu63: they're used here to indicate that C# and Char# are internal GHC-specific names
09:47:02 <orlandu63> are you able to use # in the names of functions, typeclasses, etc?
09:47:27 <zygoloid> not usually, that's a GHC extension, used for GHC internal stuff.
09:47:27 <ski> only if you apply an appropriate extension `LANGUAGE'
09:47:40 <edwardk_> orlandu63: # is _usually_ allowed only in infix symbol names.  the language pragma MagicHash allows it to be used in both symbols and identifiers
09:48:06 <Twey> More whitespace-sensitivity, yay
09:48:24 <Twey> Why can't we just make it universal already?
09:48:28 <edwardk_> orlandu63: another pragma UnboxedTuples allows it to also be used to connote multiple returns without boxing
09:48:52 <ski> (Twey : where ?)
09:49:10 <Twey> ski: Foo# Bar vs. Foo # Bar
09:49:46 * ski nearly always space operators anyway, so ..
09:49:50 <Twey> Right
09:49:55 <Twey> So does just about everyone
09:50:05 <ski> (it just reads better, imo)
09:50:42 <Twey> Making it mandatory would solve unary minus and module vs. composition, as well as vastly expanding the namespaces for both operators and functions
09:51:10 <Twey> Yet there are still people against it, which confuses me
09:51:18 <Apocalisp> zygoloid: It would have to be (Maybe a -> Maybe b -> Maybe c) -> f a -> f b -> f c
09:51:28 <ski> (common exceptions being, the `,' in tuples, lists, and sometimes in list comprehensions, too, explicit `;' for indentation, `@',`~',`:' in patterns)
09:51:36 <dankna> well, now that I understand what you're proposing, Twey, I'm in favor of it
09:52:11 <Twey> , ; @ and ~ are syntax, not operators
09:52:21 <Twey> IMO : should be spaced like any other infix constructor
09:52:34 <benmachine> import Control.Applicative((*>));main=let{gl=getLine;pl=putStrLn;}in do{l<-gl;pl$l;interact(unlines.map(*>"A").lines);} -- Twey you would make code of this sort illegal? :(
09:52:35 <ski> yes, but they read like operators
09:53:06 <Twey> benmachine: Thanks for the vote of support ;)
09:53:08 <edwardk_> why *> rather than just >> ?
09:53:19 <ski> (and i write `foo (x:xs) = ...' out of some kind of custom, and somewhat wanting to not keep left-hand-sides too large)
09:53:23 <edwardk_> @type (*>)
09:53:24 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
09:53:26 <benmachine> edwardk_: I don't remember
09:53:29 <edwardk_> @type (>>)
09:53:30 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
09:53:38 <benmachine> edwardk_: I think it was to demonstrate that imports didn't require newlines
09:53:43 <edwardk_> *nods*
09:53:46 <Twey> ski: They do, but they're not, which means we can make exceptions for them without making exceptions.
09:53:53 <portnov> :t liftM const
09:53:54 <lambdabot> forall a1 b (m :: * -> *). (Monad m) => m a1 -> m (b -> a1)
09:54:07 <ski> Twey : yes
09:54:24 <portnov> @pl \a b -> b
09:54:24 <lambdabot> const id
09:54:32 <benmachine> :t liftA2 const
09:54:33 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f a
09:54:34 <portnov> > liftM (const id)
09:54:35 <lambdabot>   No instances for (Test.SmallCheck.Serial (m a1),
09:54:35 <lambdabot>                    GHC.Sho...
09:54:38 <edwardk_> "let{}in" costs more than "where " as well ;)
09:54:41 <benmachine> :t liftA2 $ const id
09:54:42 <lambdabot> forall a (f :: * -> *) a1. (Applicative f) => f a -> f a1 -> f a1
09:55:31 <benmachine> edwardk_: neat, down to one space :P
09:56:14 <edwardk_> benmachine: can you say where;foo ? or does that bomb out?
09:56:23 <benmachine> main=do{l<-l;p$l;interact(unlines.map(*>"A").lines);}where{l=getLine;p=putStrLn;}
09:56:52 <edwardk_> no need for the terminating ; in the where clause or do
09:56:54 <ski> > let()=()where{}in()
09:56:55 <lambdabot>   ()
09:57:09 <benmachine> heh
09:57:37 <benmachine> > let f x = x + y where;y = 7 in f 3
09:57:38 <lambdabot>   10
09:57:42 <benmachine> > let f x = x + y where;y = 7 in y
09:57:43 <lambdabot>   y
09:57:48 <benmachine> interesting
09:58:17 * hackagebot meldable-heap 1.0 - Asymptotically optimal, Coq-verified meldable heaps, AKA priority queues  http://hackage.haskell.org/package/meldable-heap-1.0 (JimApple)
09:59:34 <mercury^> I bet they are horribly slow. :<
09:59:53 <gwern> mercury^: how could they be slow? they're asymptotically opitmal!
10:00:08 <EvanR-work> big O of 1 where 1 = 10^49
10:00:10 <ezyang> "asymptotic": the weasel word of the algorithms con-man
10:00:19 <edwardk_> ezyang: =)
10:00:42 <Apocalisp> asymptotics: where any constant fraction is as good as a half
10:00:54 <gwern> go not to the Big-Ohs for counsel, for they will tell you yea and nay
10:02:05 <jbapple> Heapsort on 25,000 Ints takes about twice as long with meldable-heap-1.0 as it does with lowasser's pqueue package
10:02:34 <lowasser> working, working, working =P
10:02:44 <edwardk> which means it takes about a fifth of the time using your impl than with the fingertree version ;)
10:03:22 <lowasser> I'm dubious that it'll work better on really large data sets though if you're using Brodal-Okasaki
10:04:45 <jbapple> edwardk: I am surprised fingertrees are that slow for heapsort
10:04:46 <lowasser> what exactly is your heapsort code?
10:04:58 <lowasser> jbapple: fingertrees really don't make very good priority queues....
10:05:17 <fax> why do we say "put 2 and 2 together"
10:05:23 <jbapple> lowasser: It appears so
10:05:24 <lowasser> jpapple: that is, given an import of Data.MeldableHeap, what is the code for heapsort
10:05:30 <fax> is the number 2 even meant?
10:05:47 <benmachine> fax: I believe so
10:05:49 <dankna> fax: this sounds like a question for #linguistics
10:06:04 <benmachine> but yes actual expertise would be better than my answer
10:06:05 <jbapple> Of course, fingertrees can do things other heaps can't
10:06:05 <fax> dankna - uh ?? you're kidding right
10:06:07 <jbapple> like split
10:06:14 <jbapple> and search
10:06:21 <dankna> semi-kidding, but there is such a channel and I imagine they'd have opinions on what you're asking
10:06:25 <fax> that channel is like a trolls bathhouse
10:06:28 <dankna> oh.
10:06:36 <ezyang> tl;dr "inventing new data structures is hard"
10:09:11 <jbapple> The code for heapsort would be something like:  unfoldr extractMin (foldr Data.MeldableHeap.insert empty x)
10:12:12 <rdtsc> can anybody run System.Posix.User.getAllGroupEntries in ghci twice?
10:14:05 <dankna> rdtsc: I cannot; that is, it returns an empty list the second time.
10:14:17 <dankna> rdtsc: looks like a bug to me, failing to reset the thing.
10:14:20 <rdtsc> dankna: it does
10:14:41 <rdtsc> as far as i understand it is a big bug
10:14:42 <dankna> I bet whoever maintains that library would welcome a patch :)
10:15:02 <dankna> it's probably a one-line fix, there's some underlying function to reset the iteration that needs to be called
10:15:05 <Volvic> hi, can someone plz help me debug this function? it should work, and if i add an extra \ESC[1D to each putStr in the definition it kind of does what it's supposed to but i get some random garbage characters, that id ont understand where they are coming from http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24790#a24790
10:16:21 <dankna> Volvic: be aware that by default you are accessing the terminal in UTF8 mode, although I don't /think/ that's affecting this simple example.  It would help to see a hex dump of what output it's actually producing.
10:17:18 <Volvic> dankna: interesting idea, let me see if i can arrange that
10:21:23 <orlandu63> haskell/gol.o:(.text+0x12f): undefined reference to `__stginit_containerszm0zi3zi0zi0_DataziMap_'
10:21:28 <orlandu63> oops
10:21:32 <orlandu63> disregard that
10:21:41 <Volvic> dankna: ok i don't know how to do that tbh
10:22:03 <Volvic> do i pipe the result into a text file and then use the dump command?
10:22:09 <dankna> Volvic: that's probably the easiest way
10:22:14 <Volvic> ok
10:22:27 <yaru1022> is there a case in which using >>= makes the code more expressive than using do notation?
10:22:29 <dankna> ie ./Main | tee foo
10:22:32 <dankna> and then hexdump foo
10:23:44 <dankna> yaru: yeah, it's handy when you need to process the result of a monadic action before you give it a name and don't want to clutter your namespace with confusing foo''' names
10:24:08 <dankna> yaru: ie foo <- getMaybeFoo >>= (return . fromJust)
10:24:35 <dankna> although that particular example would better be written as a pattern match
10:24:39 <dankna> Just foo <- getMaybeFoo
10:24:43 <dankna> but you take the point
10:24:50 <yaru1022> hm... i get it
10:25:58 <kamatsu> Axman6: w00t, `seq` works, along with unsafePerformJS and unsafeCoerce
10:26:05 <kamatsu> Axman6: Now I have a working JS Monad.
10:26:29 <FliPPeh__> Why, oh why can't I extend the parsec token?
10:26:54 <FliPPeh__> I get "\u" escape codes that need to be treated as "\x"
10:26:55 <FliPPeh__> :(
10:27:04 <Volvic> dankna: ok, it seems like my code works when i run it from a command line but only kind of when i run it inside ghci. i guess that is to be considered normal.
10:27:54 <Volvic> Axman6: JS == JavaScript?
10:28:18 <dankna> Volvic: well, it seems as though that ought to be fixable somehow, but it may not be worth tracking down
10:28:32 <Volvic> mm. i
10:28:47 <Volvic> will let it be until it bothers me again. thx though
10:28:49 <dankna> sure
10:29:37 <aavogt>   dankna | yaru: ie foo <- getMaybeFoo >>= (return . fromJust)
10:29:45 <aavogt> ^^ this is much better written as a pattern match
10:29:55 <FliPPeh__> That's it
10:30:02 <FliPPeh__> I'm reimplementing the damn lexer
10:30:18 <aavogt> > Just Nothing >>= return . fromJust
10:30:19 <lambdabot>   Just * Exception: Maybe.fromJust: Nothing
10:30:23 <aavogt> vs:
10:30:29 <dankna> aavogt: yeah, I said that right after
10:30:37 <aavogt> > do Just x <- Just Nothing; return x
10:30:38 <lambdabot>   Nothing
10:30:43 <aavogt> note the different behavior
10:31:12 <dankna> er
10:31:17 <aavogt> > do Just x <- [Nothing]; return x
10:31:18 <dankna> > do Just x <- Nothing; return x
10:31:18 <lambdabot>   []
10:31:19 <lambdabot>   Nothing
10:31:33 <aavogt> those are different things
10:31:51 <fax> they're bothe the same in a different sense
10:32:03 <dankna> > do Just x <- 42; return x
10:32:04 <lambdabot>   No instance for (GHC.Show.Show (m b))
10:32:04 <lambdabot>    arising from a use of `M3742167888...
10:32:06 <fax> > (mzero :: [()], mzero :: Maybe ())
10:32:06 <lowasser> jbapple: back, you caught me in the middle of class and I had a quiz =P
10:32:07 <lambdabot>   ([],Nothing)
10:32:23 <dankna> > do Just x <- return 42; return x
10:32:24 <aavogt> specifically your    do Just x <- Nothing; ...    gets you a sensible value because of the implementation of =<<
10:32:24 <lambdabot>   No instance for (GHC.Show.Show (m b))
10:32:24 <lambdabot>    arising from a use of `M3664524642...
10:32:34 <jbapple> The code for heapsort would be something like:  \x -> unfoldr extractMin (foldr Data.MeldableHeap.insert empty x)
10:32:46 <dankna> > do Just x <- return 42
10:32:47 <aavogt> while the other one isn't an uncaught exception because of how `do' is desugared
10:32:47 <lambdabot>   <no location info>:
10:32:47 <lambdabot>      The last statement in a 'do' construct must be an ...
10:32:50 <jbapple> (that was for lowasser)
10:33:07 <dankna> hmm
10:33:20 <dankna> > do Just x <- return 42; return x :: IO String
10:33:21 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe GHC.Base.String))
10:33:21 <lambdabot>    arising...
10:33:40 <dankna> > do Just x <- return $ Just 42; return x :: IO String
10:33:40 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
10:33:41 <lambdabot>    arising from the literal `...
10:33:42 <aavogt> you would need another return there
10:34:08 <aavogt> also the wrong litteral for your type signature
10:34:17 <monoidal> > do Just x <- return $ Just 42; return x :: IO Int
10:34:18 <dankna> I know it's the wrong literal, I wanted to see what it would do
10:34:18 <lambdabot>   <IO Int>
10:34:30 <dankna> but it didn't get as far as giving me an error because of the wrong literal
10:35:03 <dankna> is it the case in general that you get an exception if you try to match a pattern that doesn't match?
10:35:40 <dankna> I guess your example was in the Maybe monad
10:35:46 <dankna> and I wanted an example in the IO monad so I could understand it :)
10:36:10 <fax> > undefined :: IO Int
10:36:11 <lambdabot>   <IO Int>
10:36:23 <dankna> that's why you say I ned another return - because you want me to be in Maybe?
10:36:25 <dankna> *need
10:37:27 <dankna> and oh, I understand the exception it gave me now.  so it DID work the way I wanted it to (or rather, fail the way I wanted it to).  interesting.
10:38:15 <lowasser> jbapple, I'm using criterion to benchmark
10:38:19 <zygoloid> dankna: if you have a refutable pattern binding of the <- style in side a 'do', then 'fail' is used if the pattern fails. that doesnt' nevessarily give an exception.
10:38:26 <aavogt> @undo do Just x <- f; return x
10:38:26 <lambdabot> f >>= \ a -> case a of { Just x -> return x; _ -> fail ""}
10:38:31 <lowasser> length . List.unfoldr B.minView . foldr B.insert B.empty versus length . List.unfoldr M.extractMin . foldr M.insert M.empty
10:38:35 <aavogt> @undo do Just x <- return f; return x
10:38:35 <lambdabot> return f >>= \ a -> case a of { Just x -> return x; _ -> fail ""}
10:38:40 <lowasser> where B is my pqueue, and M is your MeldableHeap
10:38:46 <zygoloid> > do Just x <- return Nothing; return x :: Either String Int
10:38:47 <lambdabot>   Left "Pattern match failure in do expression at <interactive>:1:136-139"
10:38:47 <aavogt> aww, it doesn't apply any simplifications
10:38:56 <lowasser> I'm getting benchmarks with pqueue about 3x faster
10:38:57 <dankna> zygoloid: gotcha.  yeah.  okay.  I'm not a huge fan of fail :)
10:38:58 <zygoloid> > do Just x <- return Nothing; return x :: Maybe Int
10:38:59 <lambdabot>   Nothing
10:39:13 <lowasser> I'll send you the csv momentarily
10:40:01 <dankna> aavogt: I see
10:41:00 <lowasser> jbapple: what compilation settings / RTS options are you using?
10:41:01 <jbapple> lowasser: How fast is pqueue.heapSort compared to the standard library's sort?
10:41:15 <lowasser> Good question!  One moment please.
10:42:14 <jbapple> lowasser: I've tried -O2 with and without -prof -auto-all, performing GC between each run
10:42:28 <lowasser> hmkay
10:42:34 <jbapple> I was using the tarball I sent to the list a few weeks ago
10:42:47 <jbapple> (slightly modified)
10:43:48 <shapr> YARR!
10:43:54 <jbapple> partially available, but with no documentation or even the most recent code, at http://code.google.com/p/priority-queues/source/browse/performance-testing
10:44:22 <jbapple> It's not all up there because I was following rule #2 of optimizing
10:44:32 <jbapple> ("Don't yet")
10:44:38 <dankna> heh, yeah, good rule
10:45:48 <aavogt> well the idea of fail is good, but it should really be a separate class
10:45:49 <fax> Record DERP {A} `{ORDER A} (der:A -> A -> bool) := Derp {
10:46:37 <dankna> aavogt: yeah.  oh, it was you who said that the other day, wasn't it.  I was completely convinced by that argument, heh.
10:46:48 <aavogt> -XNoImplicitPrelude can do that
10:47:25 <jbapple> fax: what about it?
10:48:54 <Twey> jbapple: What's #1?
10:49:01 <jbapple> "Don't"
10:49:14 <Twey> Ah :-D
10:49:45 <lowasser> jbapple: will have completed progression output in another minute or so
10:52:23 <ksf> hell is just freezing over
10:52:27 <ksf> http://arstechnica.com/open-source/news/2010/04/microsoft-offers-much-needed-fix-for-windows-oss-development.ars
10:54:43 <siracusa> Did anyone else experience GHCi crashing for no reason on WinXP?
10:55:13 <Sgeo_> siracusa, I've had WinGHCi stop doing things after being open for a while on WinXP
10:56:32 <siracusa> I use the standard GHCi 6.10.4, and it randomly crashed while doing nothing lately.
10:57:51 <siracusa> The CPU usage is also pretty high when a lot of modules are loaded ... strange
10:59:07 <aavogt> well it's not as if ghci makes it easy to define lots of stuff you would be sad to lose
11:00:14 <monochrom> haha
11:00:44 <FliPPeh__> It's driving me insane!
11:00:59 <FliPPeh__> Creating your own string literal parser is just horror
11:01:09 <FliPPeh__> And the parsec token one doesn't work for me.
11:01:33 <siracusa> FliPPeh: Yeah, I have the same problem right now :-)
11:01:36 <dankna> Flippeh: funnily enough, I'm working on exactly that
11:01:45 <FliPPeh__> Oh wow
11:01:46 <dankna> Flippeh: as the test case of my lexer/parser generator
11:01:57 <dankna> Flippeh: you might have a few weeks' wait for my solution though :)
11:02:10 <FliPPeh__> Well, I'm getting a string from a website, and this includes "\uXXXX" unicode escapes
11:02:21 <FliPPeh__> T.stringLiteral doesn't accept it
11:02:22 <mauke> meh, parsing string literals is one of the easier things
11:02:28 <dankna> what language's string syntax does the website conform to?
11:02:34 <FliPPeh__> I find NO way to convert it before parsing either
11:02:42 * mauke guesses javascript
11:02:49 <FliPPeh__> mauke is right
11:02:51 <FliPPeh__> It's JSON
11:02:52 <dankna> hm
11:03:13 <dankna> could be worse, you could be parsing extended regexps ><  that took me a bunch of work
11:03:23 <FliPPeh__> I wrote a half working literal parser, but it doesn't correctly handle "\\\""
11:03:25 <FliPPeh__> And it stops
11:03:33 <FliPPeh__> instead of ignoring it
11:03:39 <dankna> I wouldn't use Parsec for this task, honestly, but I wouldn't use Parsec for much at all
11:04:06 <dankna> you can do a function :: String -> String that uses pattern-matching and recursion
11:04:14 <mauke> this is pretty simple with regexes, and the result has an obvious parsec equivalent
11:04:36 <FliPPeh__> I have no idea.
11:04:50 <FliPPeh__> I already wrote a function the replaced a substring in a string
11:04:52 <mauke> string = char '"' *> many strPart <* char '"'
11:04:56 <FliPPeh__> Didn't work at all.
11:05:06 <mauke> strPart = normal <|> escaped
11:05:15 <Twey> ksf: There are loads of Windows .rrrrrr for Windowspackage managers
11:05:16 <Twey> TTehey just don't ge tt distributed iwith Windows, so no-one uses them
11:05:25 <mauke> normal = noneOf "\"\\"
11:05:30 <oxamus> dankna: why not parsec
11:05:37 <oxamus> for anything
11:05:43 <mauke> escaped = char '\\' >> esc
11:05:50 <dankna> Oxamus: well, it's not a good fit for how I think about lexing or parsing.  and for anything realistic, it backtracks, which is inefficient.
11:05:58 <mauke> esc = choice [...]
11:06:16 <dankna> Oxamus: I want to write my lexers as pattern-matches, typically with regexps, and I want to write my parsers as declarative lists of productions.  Parsec is too imperative for my tastes.
11:06:17 <Twey> Er, WTF, terminal/irssi
11:06:29 <FliPPeh__> mauke: Awesome, thanks :) Where do the *> <* operators come from?
11:06:44 <Twey> @index (*>)
11:06:44 <lambdabot> bzzt
11:06:47 <Twey> Bah
11:06:50 <Twey> Control.Applicative
11:06:57 <FliPPeh__> Thanks :)
11:08:04 <oxamus> dankna: most grammars should be LL(1), imho
11:08:10 <oxamus> if not the grammar sucks
11:08:17 <oxamus> most grammars suck
11:08:25 <dankna> oxamus: yes, first off, I disagree with that; but second off, what if you don't control the grammar because you're working to a spec?
11:08:29 <shapr> Especially english grammar!
11:08:42 <dankna> for example, you might be writing a C compiler in Haskell
11:08:56 <FliPPeh__> mauke: the parser is no part of Applicative, what to do?
11:08:56 <dankna> obviously you have to parse whatever grammar C has, regardless of whether you like it or not
11:09:21 <dankna> anyway Joy, when it's done, will handle LALR(k) grammars
11:09:24 <oxamus> are there benchmarks for parsec
11:09:30 <dankna> I'm not aware of any benchmarks, no
11:09:37 <mauke> instance Applicative Parser where pure = return; (<*>) = ap
11:10:09 <oxamus> parsec is some kind of packrat parser right?
11:10:17 <benmachine> I used parsec for something a while back with no bracktracking
11:10:18 <chrisdone> no
11:10:22 <oxamus> or recdesc?
11:10:25 <dankna> Parsec is recursive descent
11:10:27 <benmachine> but I did get to choose my grammar
11:10:37 <chrisdone> Frisby is a haskell packrat parser iirc
11:10:42 <dankna> cute name!
11:10:49 <dankna> that was a great book, haha
11:11:10 <shapr> dankna: You're familiar with the programming language named Joy?
11:11:10 <FliPPeh__> @index ap
11:11:11 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List, Data.Graph.
11:11:11 <lambdabot> Inductive.Query.ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
11:11:21 <dankna> Shapr: no, I'm not :( I may have to change my name :(
11:11:30 <shapr> chrisdone: Yeah, great choice for a name :-) Frisby! NIMH!
11:11:35 <chrisdone> :D
11:11:40 <jmcarthur> i understand why type classes instances are essentially global in scope, but i think it would be nice to be able to limit them in scope to the current package. for example, for orphan instances
11:11:54 <shapr> chrisdone: btw, I used your online ghci in infosec class today, thanks for putting it up!
11:11:59 <shapr> Makes my life easier :-)
11:12:08 <chrisdone> shapr: wow, awesome!
11:12:43 <shapr> chrisdone: My next request is to integrate it into hpaste somehow?
11:13:00 <jmcarthur> like codepad?
11:13:02 <shapr> chrisdone: I'd like to be able to load an hpaste into an interactive buffer at the bottom of the page.
11:13:04 <shapr> jmcarthur: Yeah!
11:13:09 <jmcarthur> ah, interactive codepad :)
11:13:21 <jmcarthur> that would be very nice
11:13:46 <shapr> Wolud be perfect for teaching/learning on #haskell
11:14:08 <shapr> I can imagine a web client that has #haskell in one frame, and currypad in another.
11:14:23 <shapr> Wait, does google wave do this sort of thing already?
11:14:28 <dankna> no, Wave doesn't do that
11:14:29 <aavogt> currypad?
11:14:47 <shapr> aavogt: Random name :-)
11:14:51 <chrisdone> shapr: hmm. well I've been planning on adding a box for pasting code into at some point. I can add something vertically to tryhaskell easily, but you would have to scroll. the api supports giving it files, did you see my blog post about it? it's quite flexible
11:14:58 <shapr> pad curry? as oppose to pad thai?
11:15:00 <aavogt> that name could be a bit confusing since Curry isn't haskell
11:15:08 <chrisdone> it's the weekend so I can sort something out :-)
11:15:16 <shapr> chrisdone: Awesome!
11:15:27 <sm> what's the best library function for testing if a path is a file or directory ?
11:15:35 <mauke> THE BEST
11:15:36 <shapr> chrisdone: No, I didn't see the blog post, I'll look for it.
11:15:43 <chrisdone> shapr: http://chrisdone.com/posts/2010-04-05-haskell-json-service-tryhaskell.html
11:15:43 <FliPPeh__> GAH
11:15:46 <FliPPeh__> It just won't work
11:15:47 <dankna> sm: head reverse
11:15:50 <FliPPeh__> "unknown parse error"
11:15:51 <chrisdone> bbs, dinner's up
11:15:54 <Polarina> Why does ghci crash when I do "peek nullPtr"?
11:15:57 <mauke> @hoogle String -> IO Bool
11:15:57 <lambdabot> System.Directory doesDirectoryExist :: FilePath -> IO Bool
11:15:57 <lambdabot> System.Directory doesFileExist :: FilePath -> IO Bool
11:15:57 <lambdabot> System.Console.Editline.Readline readHistory :: FilePath -> IO Bool
11:15:58 <shapr> chrisdone: Thanks :-)
11:16:05 <dankna> oh hey, look at that
11:16:15 <Vanadium> Polarina: What else would it do?
11:16:38 <Polarina> Vanadium, it should throw an exception.
11:16:39 <gwern> Vanadium: return _|_?
11:16:40 <sm> dankna: I need to check it on disk.. maybe directoryExists path
11:16:49 <shapr> chrisdone: I thought the interactive tutorial was SERIOUSLY AWESOME, by the way.
11:16:52 <mauke> Polarina: er, why?
11:16:56 <mauke> Polarina: and how?
11:16:57 <dankna> sm: ah okay
11:17:06 <Vanadium> You cannot expect it to check for invalid pointer accesses
11:17:09 <shapr> chrisdone++
11:17:09 <Vanadium> It does not do that in C either
11:17:15 <shapr> For great niftiness!
11:17:21 <Polarina> :S
11:17:41 <mauke> you can't check for invalid pointers ... well, not easily
11:17:56 <Vanadium> Not by the C standard, I assume
11:18:16 <shapr> chrisdone: How would you handle things like file access? Just using dons' mueval built-in protections?
11:18:39 <gwern> dons'?
11:18:42 <gwern> :(
11:18:47 <mauke> the C standard says you lose as soon as you touch an invalid pointer, you don't even have to dereference it (the null pointer doesn't count as invalid, though)
11:19:08 <shapr> gwern: oops
11:19:12 <mauke> gwern++  # don't be sad
11:19:15 <shapr> sorry :-(
11:19:20 * gwern sniffles a little
11:19:35 * shapr hugs gwern 
11:19:48 <shapr> gwern: You do lots of great stuff for Haskell and #haskell ! I appreciate you!
11:19:50 * nlogax baked a cake for gwern 
11:19:55 * gwern feels much better
11:20:30 <ville> mauke: does this carry over to C++, there was discussion about p->static_f(); whether it's valid or not.
11:20:42 * shapr tries this again...
11:20:53 <shapr> Just using gwern's mueval?
11:20:59 <mauke> I'm not that familiar with the C++ VM
11:21:09 <ville> ...and I couldn't be more off-topic.
11:21:21 <mauke> but p->static_f() looks like it reads from p, and reading an indeterminate value is UB
11:22:16 * gwern releases mueval 0.8, and feels better
11:22:19 <shapr> Yay!
11:22:29 <shapr> gwern++ # for great mueval-ness!
11:23:00 <gwern> shapr: mm, I'd like mueval better if people didn't make big forks of it, incidating that I didn't design it well
11:23:05 * hackagebot mueval 0.8 - Safely evaluate Haskell expressions  http://hackage.haskell.org/package/mueval-0.8 (GwernBranwen)
11:23:37 <shapr> gwern: At least you know they like and use it.
11:23:41 <jmcarthur> mauke: what do you mean "touch an invalid pointer"?
11:23:54 * gwern supposes so. the only worse thing than being talked about, etc.
11:24:42 <mauke> jmcarthur: evaluate it
11:24:53 <ezyang> mauke: Do you mean... dereference it?
11:24:57 <mauke> no
11:25:09 <mauke> x = p; f(p); if (p) ...
11:25:12 <ezyang> like, I can do foo = (void*) 0xDEADBEEF and then push it around without making my C compiler mad.
11:25:25 <jmcarthur> mauke: so you mean evaluating an invalid pointer is itself invalid?
11:25:27 <mauke> your C compiler is irrelevant
11:25:30 <mauke> jmcarthur: yes
11:25:33 <jmcarthur> wow
11:25:34 <theorbtwo> ezyang: The specification says that the compiler *can* get mad.  That doesn't mean it has to.
11:25:45 <ezyang> O.o
11:25:53 <mauke> bonus wtf: void *p = malloc(1); free(p); if (p) // undefined behavior
11:26:01 <jmcarthur> personally i like that, although i don't know how it could actually be usefully treated in practice
11:26:22 <jmcarthur> oh wait
11:26:44 <jmcarthur> well, i guess checking for null there isn't useful anyway
11:27:06 <twink> mauke: C doesn't specify malloc()/free(), those are UNIX specs.
11:27:13 <arthuraa> I've written a draft of a soc proposal, could someone please review it?
11:27:17 <mauke> twink: wrong
11:27:31 <arthuraa> http://socghop.appspot.com/gsoc/student_proposal/show/google/gsoc2010/arthuraa/t127083645951
11:27:37 <twink> mauke: really? oh wow, you're right
11:28:16 <ezyang> mauke: This... doesn't apply to NULL, right?
11:28:37 <mauke> ezyang: right, NULL is a valid pointer value. you just aren't allowed to dereference it.
11:28:42 <ezyang> huh.
11:28:44 <Apocalisp> class Align f where { align :: (OneOrBoth a b -> c) -> f a -> f b -> f c }
11:28:48 <edwardk> arthuraa: see my comments on #haskell-soc
11:28:52 <Apocalisp> Trying to come up with good properties for Align
11:29:17 <edwardk> Apocalisp: is this a 'zipWithExtension' kind of thing?
11:29:21 <Apocalisp> Also I wonder if Align is not general enough
11:29:41 <Apocalisp> edwardk: Yeah, that kind of thing. What do you mean exactly?
11:30:27 <twink> mauke: I think if (p) varies with whether malloc() returned NULL or not, so void *p = malloc(1); if (!p) return -1; free(p); if (p) dosomething(); else dosomethingelse(); return 0; can simplify the latter if/else to its true branch.
11:30:28 <jmcarthur> mauke: does that actually give any compilers freedom to optimize something away that anybody knows of?
11:30:53 <edwardk> Apocalisp: well, traditionally zipWith only works for functors that have a well defined shape union, the type you propose there i presume covers a functor f, over the intersection of the underlying rep.
11:30:54 <Apocalisp> edwardk: I want to express the general idea of a zipWith that handles holes in either structure.
11:31:00 <edwardk> Apocalisp: *nods*
11:31:18 <edwardk> er flip intersection and union in my statement
11:31:30 <shapr> Hm, didn't ghci support 0b101010 at some point?
11:31:33 <mauke> twink: it can also simplify the latter if/else to printf("hello, world!");
11:31:42 <Twey> (Maybe a, Maybe b)?
11:32:05 <Twey> Oh, right
11:32:40 <Twey> twink: I don't think free() zeroes the pointer…
11:32:46 <twink> mauke: I'm thinking that since the pointer isn't returned by reference the local copy of the pointer value in the stack frame will dominate.
11:32:48 <Apocalisp> edwardk: For lists, align would carry on past the end of the shorter list. For rose trees, it will carry on past the end of the shorter subtree, etc.
11:32:59 <mauke> C has no references or stacks
11:33:00 <edwardk> shapr: its not in '98 http://www.haskell.org/onlinereport/lexemes.html
11:33:02 <jmcarthur> it can't zero the pointer
11:33:03 <Twey> Oh, but if (!p), okay.
11:33:09 <ezyang> mauke: stacks?
11:33:14 <edwardk> Apocalisp: yeah that is exactly what i'm referring to =)
11:33:17 <tromp_> no, it doesnt have the addr of the ptr
11:35:22 <olsner> why all the discussion about C in #haskell? and what are you discussing anyway?
11:35:42 <Apocalisp> edwardk: Do you know of any prior art here?
11:35:48 <twink> olsner: My wild guess is something pertinent to FFI and/or RTS affairs.
11:35:59 <Apocalisp> (no need to reinvent the wheel if I don't have to)
11:36:04 <edwardk> actually i don't think a c compiler is allowed to get mad at the 0xDEADBEEF assignment. at worst (void*)(0 + 0xDEADBEEF) has to work, because it could be a relative offset off of a null pointer.
11:36:35 <mauke> edwardk: not making much sense
11:36:38 <edwardk> Apocalisp: dan piponi used a simple version for some operations over polynomials.
11:36:54 * mauke retreats to #haskell-blah
11:36:55 <ezyang> edwardk: Good point.
11:37:20 <edwardk> mauke:p[delta] =  *(p + delta) = delta[p] in c
11:37:28 <edwardk> p can be 0
11:37:47 <mauke> edwardk: would you like to come to #haskell-blah?
11:38:20 <monoidal> how to write fix in CPS? I guess it should be something like fix f = (fix f) f, but it doesn't work
11:38:34 <fax> monoidal that's not CPS
11:38:52 <monoidal> i mean, compute fix f, and pass f to do it next
11:39:07 <monoidal> as a continuation
11:39:32 <cebewee> hm, is there a formal definition which conditions an implementation of Eq should fulfill?
11:40:06 <ezyang> cebewee: I'd imagine reflexivity, transitivity?
11:40:10 <byorgey> cebewee: (==) should be an equivalence relation, i.e. reflexive, symmetric and transitive
11:40:17 <chrisdone> shapr: no, YOU are seriously awesome!
11:40:17 <chrisdone> shapr: regarding file access, I could possibly write a monad that can do simple restricted file operations. maybe reading/writing from a whitelisted set of files local to the user's session. if someone wants to *write* such a monad that would be nice *hint hint*
11:40:28 <monoidal> and (/=) should be negated (==)
11:40:31 <cebewee> byorgey: that's what i would expect, yes
11:40:45 <cebewee> but i did not find it in the '98 report
11:41:02 <jmcarthur> the report doesn't not have many laws on its type classes :\
11:41:05 <jmcarthur> *does not
11:41:23 <chrisdone> gwern: I think I need to merge my mueval with yours, possibly... hum
11:41:38 <gwern> chrisdone: it would be good, yes
11:41:53 <byorgey> cebewee: oh, you mean in the report.  yeah, not many formally specified laws in there.
11:42:03 <gwern> chrisdone: forks are a dead end for one or the other
11:42:07 <chrisdone> aye
11:42:32 <cebewee> jmcarthur: ok, then back to relying on common sense =)
11:42:46 <gwern> chrisdone: incidentally, aren't there already restricted io monads? I remember oleg did some monads or region stuff splitting out writes and reads etc
11:42:58 <gwern> chrisdone: and the files could just be a virtual system, like ZFS
11:43:05 <cebewee> but this seems like a deficiency to me
11:43:12 <jmcarthur> it is
11:43:23 <byorgey> cebewee: many of the standard type classes correspond obviously to certain mathematical structures (Eq, Ord, Functor, Monoid, Monad...), in those cases you can take the laws to be the mathematical ones those structures must obey
11:43:51 <jmcarthur> what mathematical structure does Ord represent?
11:43:55 <monoidal> linear order
11:44:00 <jmcarthur> ah
11:44:11 <gwern> jmcarthur: a partial ordering thanks to _|_?
11:44:19 <jmcarthur> and then we have Num... good ole Num... :(
11:44:22 <chrisdone> gwern: interesting idea... with different /home/'s per session?
11:44:29 <byorgey> yes, Num is why I said "many"... =(
11:45:01 <gwern> chrisdone: sure, although if you're going with virtual/ram-only/lazily-generated-filesystems, there's no real reason to emulate /home or anything
11:45:16 <gwern> chrisdone: but try installing ZFS and going through the little telnet tutorial
11:45:21 <gwern> chrisdone: it's fairly cool
11:45:37 <chrisdone> gwern: ok I'll look through it
11:46:23 <aavogt> gwern: note that now mueval doesn't jump to -XExtendedDefaultRules
11:46:33 <gwern> aavogt: eh?
11:47:04 <aavogt> it was that the -E flag implied -XExtendedDefaultRules
11:47:12 <aavogt> it doesn't anymore
11:47:23 <aavogt> now that you can supply that flag yourself
11:47:40 <gwern> oh. I wish you had tol dme that earlier
11:47:49 <gwern> now we'll have issues with lambdabot
11:48:14 <gwern> @hoogle last
11:48:15 <lambdabot> Prelude last :: [a] -> a
11:48:15 <lambdabot> Data.ByteString last :: ByteString -> Word8
11:48:15 <lambdabot> Data.List last :: [a] -> a
11:48:27 <aavogt> why?
11:48:57 <aavogt> > last
11:48:58 <lambdabot>   * Exception: Prelude.last: empty list
11:49:03 <aavogt> > take 1
11:49:04 <lambdabot>   {[]->[];[()]->[()];[(),()]->[()];[(),(),()]->[()]}
11:49:27 <aavogt> gwern: then lambdabot should specify -XExtendedDefaultRules
11:49:44 <gwern> aavogt: yeah, but I'll had to add that and put in a new version dep
11:50:13 <aavogt> mueval follows the PVP?
11:50:27 <aavogt> I'm not sure it applies
11:51:42 <gwern> hm. does extendeddefault rules only affect quickcheck?
11:51:48 <gwern> or regular expressions too?
11:52:02 <gwern> quickcheck/smallcheck
11:52:39 <aavogt> the tests.sh still ran
11:57:14 <quicksilver> gwern: do we even think extended defaulting is a good idea for lambdabot?
11:57:21 <gwern> hm. missingh hasn't been uploaded since 2008
11:57:26 <quicksilver> I've always found it mildly annoying but maybe it has its uses
11:57:36 <gwern> quicksilver: I thought a lot of quickcheck tests didn't work without it
11:57:42 <aavogt> gwern: hmm? quickcheck is sort of broken already with respect to its imports
11:58:06 <FunctorSalad> taking this here from #linux... canonicalizePath says that canonicalizing is "impossible" http://hackage.haskell.org/packages/archive/directory/latest/doc/html/System-Directory.html#v:canonicalizePath
11:58:09 <aavogt> @check \f -> apply f () == ()
11:58:10 <lambdabot>   Not in scope: `apply'
11:58:14 <FunctorSalad> do which OS would that apply?
11:58:18 <aavogt> @check \f -> Test.QuickCheck.Function.apply f () == ()
11:58:18 <lambdabot>   Not in scope: `Test.QuickCheck.Function.apply'
11:58:23 <FunctorSalad> (I don't see how to do it in linux)
11:59:04 <mauke> FunctorSalad: do what?
11:59:28 <quicksilver> gwern: I've always annotated my @checks with enough types to be unambiguous, I believe.
11:59:43 <FunctorSalad> mauke: reduce an undecidable prob to pathname canonicalization
11:59:49 <aavogt> it isn't helpful to have things default to () there anyways
12:00:24 <c_wraith> @check \x -> x == reverse x
12:00:25 <lambdabot>   "OK, passed 500 tests."
12:00:30 <quicksilver> FunctorSalad: it's not a question of mathematical undecidability as far as I know.
12:00:30 <aavogt> exactly like that
12:00:33 <c_wraith> see!  lists are the same as their reverse!
12:00:35 <quicksilver> c_wraith: good example.
12:00:43 <FunctorSalad> quicksilver: ok, I took "impossible" to mean that
12:00:47 <quicksilver> FunctorSalad: it's a quesiton of incomplete information.
12:01:04 <quicksilver> the information is not available to work out when a path is 'canonical'
12:01:09 <FunctorSalad> inconsistent system calls?
12:01:16 <FunctorSalad> (for different OS versions/variants)
12:01:21 <mauke> FunctorSalad: multiple names for the same file
12:01:37 <FunctorSalad> mauke: sure, that phenomenon is the problem to be solved in the first place
12:01:44 <mauke> no, it isn't
12:02:21 <FunctorSalad> you could solve the canonicalization problem for hardlinks by imposing some global order on things
12:02:23 <mauke> I'd expect canonicalizePath to clean up multiple consecutive /'s and maybe resolve symlinks
12:02:24 <aavogt> gwern: it should be simple enough to test whether mueval barfs on -X flags, no?
12:02:29 <FunctorSalad> and taking the minimal representative
12:02:41 <aavogt> then take the appropriate action
12:02:45 <FunctorSalad> mauke: read the doc I linked
12:02:58 <FunctorSalad> "Note that it is impossible to guarantee that the implication (same file/dir <=> same canonicalizedPath) holds in either direction: this function can make only a best-effort attempt."
12:03:06 <FunctorSalad> it is the problem we're trying to solve :)
12:04:22 <FunctorSalad> quicksilver: to canonicalize in that sense you wouldn't have to know that is officially the "canonical" representative
12:04:34 <FunctorSalad> just consistently pick one from equiv classes
12:05:38 <chrisdone> gwern: that is pretty damn cool. zippers amaze me
12:05:46 <gwern> chrisdone: I told you
12:06:28 <gwern> chrisdone: one project I'll never do is write a Haskell shell using ZFS, where all your normal reads and writes are on a virtualized/in-memory filesystem copy of your real fs, and every so often you serialize changes back to disk
12:06:40 <gwern> want to undo some bits? np
12:07:08 <chrisdone> gwern: hehe, indeed
12:07:20 <gwern> such a project would require me to understand delimited continuations, though
12:07:32 * chrisdone uses git reset --hard HEAD <file> a lot
12:07:37 <quicksilver> FunctorSalad: the file system(s) can have arbitarily weird tricks in play
12:07:49 <quicksilver> FunctorSalad: including union mounts, bind mounts, nfs re-exports, etc.
12:07:59 <quicksilver> perhaps that's the kind of thing they are referring to?
12:08:03 * quicksilver doesn't know.
12:08:07 <FunctorSalad> quicksilver: I was suspiciously looking at mount --bind too, but not sure if that's enough
12:08:26 <FunctorSalad> it does seem transparent to the usual tools
12:08:52 <FunctorSalad> (but /proc/mounts will tell you, of course ;o)
12:09:08 <kamatsu> what's a good function to test tail recursion optimization is working in a lazy language?
12:10:12 <chrisdone> kamatsu: fix id?
12:10:12 * ManateeLazyCat pasted "my code" at http://paste2.org/get/765643
12:10:13 <ManateeLazyCat> Anyone help me transform above code by TemplateHaskell ?
12:10:14 <tromp_> without tail recursion, stack shld eventually overflow
12:10:58 <kamatsu> tromp_: it can overflow anyway, evaluating thunks
12:11:13 <ManateeLazyCat> I want to use TH generate `packDaemonSignalArgs` for me.
12:11:14 <kamatsu> (which is what is happening in my lazy language)
12:11:23 <ManateeLazyCat> But don't know how to write it by TH.
12:11:36 <kamatsu> chrisdone: hm, i'll have to implement fix, but not a bad idea. It should infinitely loop
12:11:38 <tromp_> not if you used unboxed values
12:12:23 <kamatsu> tromp_: this is not haskell
12:12:24 <FunctorSalad> ManateeLazyCat: dump the AST for one of the clauses and generalize from there?
12:12:33 <kamatsu> tromp_: unboxed values have no meaning here
12:12:57 <ManateeLazyCat> FunctorSalad: AST ? I can't understand
12:13:01 <stevenmarky> what is the difference between text and binary mode for file operations?
12:13:08 <FunctorSalad> ManateeLazyCat: show `fmap` runQ [| .... my code .... |]
12:13:17 <chrisdone> kamatsu: sorry, I totally forgot about the ackermann function
12:13:22 <FunctorSalad> @google abstract syntax tree -- ManateeLazyCat
12:13:23 <lambdabot> No Result Found.
12:13:30 <FunctorSalad> @google abstract syntax tree
12:13:31 <lambdabot> http://en.wikipedia.org/wiki/Abstract_syntax_tree
12:13:31 <lambdabot> Title: Abstract syntax tree - Wikipedia, the free encyclopedia
12:13:44 <ManateeLazyCat> FunctorSalad: I just want a example code.
12:13:52 <FunctorSalad> that kinds produces it ;)
12:13:55 <FunctorSalad> *kinda
12:13:55 <ManateeLazyCat> FunctorSalad: I don't want too deeply on TH
12:14:00 <chrisdone> kamatsu: The Ackermann function, due to its definition in terms of extremely deep recursion, can be used as a benchmark of a compiler's ability to optimize recursion. The first use of Ackermann's function in this way was by Yngve Sundblad, The Ackermann function. A Theoretical, computational and formula manipulative study. (BIT 11 (1971), 107119).
12:14:18 <chrisdone> kamatsu: I used it to test my lazy language :p
12:14:28 <ManateeLazyCat> FunctorSalad: Yes, i know AST can do that, but too kill for that.
12:14:44 <Twey> stevenmarky: Text does encoding/decoding and newline conversion
12:14:45 <ManateeLazyCat> FunctorSalad: I just want use TH simplely.
12:14:45 <FunctorSalad> ManateeLazyCat: if "my code" is  decl, you need to use [d| ... blah ... |] brackets (without d is for exprs)
12:14:46 * Sgeo might find himself needing to parse a C-like language 
12:14:58 <chrisdone> Sgeo: there's a c parser on hackage :o
12:15:00 <Twey> Sgeo: Language.C!
12:15:07 <FunctorSalad> "a decl"
12:15:16 <ManateeLazyCat> FunctorSalad: I know that, but i don't know how to write it. Can you help me write it?
12:15:28 <Sgeo> C-like, not C. It's actually quite a bit simpler than C.
12:15:32 <ManateeLazyCat> Convert http://paste2.org/get/765643 is simple enough for TH expert.
12:15:57 <Sgeo> For one, there are no pointers. 2, no multi-dimensional lists. 3, heterogenous lists, despite being statically typed
12:16:07 <ManateeLazyCat> FunctorSalad: I want someone write example code for me, as starter code.
12:17:10 <aavogt> ManateeLazyCat: you already got some example code ;)
12:17:14 <stevenmarky> thanks Twey
12:17:24 <aavogt> in a function that does the opposite
12:17:25 <FunctorSalad> ManateeLazyCat: uh if I understand your prob correctly, that can be done with TH
12:17:26 <ManateeLazyCat> aavogt: Your code is too complicated for me now.
12:17:34 <FunctorSalad> err
12:17:37 <FunctorSalad> not TH, I mean syb
12:17:41 <dmhouse> shapr: New York
12:17:46 <FunctorSalad> gmapQ toVariant
12:17:55 <dmhouse> shapr: I've landed an internship at Jane Street, so I'll be getting paid to write OCaml
12:17:59 <FunctorSalad> (modulo some type wrapping stuff)
12:18:03 <ManateeLazyCat> FunctorSalad: Please write complete version for me.
12:18:11 <dmhouse> I feel a little like I'm joining the dark side but it's money for FP, so I'm happy :)
12:18:11 <aavogt> FunctorSalad: how do you know that gmapQ doesn't go deeper?
12:18:21 <ManateeLazyCat> FunctorSalad: I'm a newbie for TH, so i perhaps don't understand why use gmapQ
12:18:24 <FunctorSalad> @type gmapQ
12:18:25 <lambdabot> forall u a. (Data a) => (forall d. (Data d) => d -> u) -> a -> [u]
12:18:37 <FunctorSalad> aavogt: because that's its specification? ;)
12:18:50 <FunctorSalad> the ones that go deeper use it as a primitive
12:18:50 <ManateeLazyCat> Oh, guys, i just want TH code for http://paste2.org/get/765643
12:18:58 <FunctorSalad> ManateeLazyCat: instead of TH
12:19:09 <ManateeLazyCat> FunctorSalad: Anyway, example code, please?
12:19:11 <aavogt> deriving (Data,Typeable) is all you would need then
12:19:42 <aavogt> @type gmapQ toDynamic
12:19:43 <lambdabot> Not in scope: `toDynamic'
12:19:49 <aavogt> @type gmapQ toDyn
12:19:50 <lambdabot> forall a. (Data a) => a -> [Dynamic]
12:20:22 <ManateeLazyCat> aavogt: FunctorSalad you two expert, can paste actual code?
12:20:23 <Sgeo> How does Data.Seq work?
12:20:31 <FunctorSalad> aavogt: seems like it would work out-of-the-box even, without dynamic
12:20:43 <FunctorSalad> @type gmapQ
12:20:44 <lambdabot> forall u a. (Data a) => (forall d. (Data d) => d -> u) -> a -> [u]
12:20:56 <FunctorSalad> u := Variant, a := his type
12:21:03 <ManateeLazyCat> Sgeo: Seq is sequence
12:21:11 <ManateeLazyCat> :)
12:21:14 <aavogt> FunctorSalad: right, his type is Dynamic
12:21:23 <aavogt> with a different name
12:21:26 <Sgeo> I meant, how is it implemented that it works efficiently near the ends
12:21:45 <FunctorSalad> I thought Variant is a finite sum type
12:21:45 <ManateeLazyCat> Sgeo: Ord
12:21:53 <ManateeLazyCat> @type Ord
12:21:54 <lambdabot> Not in scope: data constructor `Ord'
12:21:58 <aavogt> @type seq
12:21:59 <lambdabot> forall a t. a -> t -> t
12:22:11 <FunctorSalad> (hmm then toVariant doesn't work on all "Data d"s and you'd have to typecase manually)
12:22:20 <Sgeo> @type Seq.seq
12:22:21 <lambdabot> Couldn't find qualified module.
12:22:55 <ManateeLazyCat> @type Data.Seq.Sequence
12:22:56 <lambdabot> Couldn't find qualified module.
12:23:10 <aavogt> @docs Data.Sequence
12:23:10 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/containers/Data-Sequence.html
12:23:21 <sannysanoff> anyone had success installing gtk2hs + ghc 6.12.1 + win32 ?
12:23:24 * ManateeLazyCat pasted "Seq.hs" at http://paste2.org/get/765655
12:23:34 <aavogt> ooh, it knows which package things are from now
12:23:44 <ManateeLazyCat> Sgeo: http://paste2.org/get/765655 is my utils functions for Data.Seq
12:23:47 <FunctorSalad> Sgeo: "The implementation uses 2-3 finger trees annotated with sizes, as described in section 4.2 of
12:23:47 <FunctorSalad>     * Ralf Hinze and Ross Paterson, "Finger trees: a simple general-purpose data structure", Journal of Functional Programming 16:2 (2006) pp 197-217. http://www.soi.city.ac.uk/~ross/papers/FingerTree.html "
12:24:30 <ManateeLazyCat> aavogt: Can you write TH code for http://paste2.org/get/765643 ?
12:24:56 <ManateeLazyCat> aavogt: TH syntax is still complicated for me.
12:24:58 <aavogt> but where's the fun for you then?
12:25:08 <ManateeLazyCat> ?
12:25:24 <ManateeLazyCat> http://paste2.org/get/765643
12:25:59 * ManateeLazyCat pasted "DBus.hs" at http://paste2.org/get/765659
12:26:04 <ManateeLazyCat> aavogt: Above is complete library that use it.
12:26:38 <ManateeLazyCat> aavogt: `packDaemonSignalArgs` for pack `DaemonSignalArgs` with [Variant]
12:26:53 <ManateeLazyCat> aavogt: Then use `unpackDaemonSignalArgs` unpack [Variant]
12:27:47 <FunctorSalad> the TH AST types are rather straightforward, just a bit clunky/verbose
12:27:56 <ManateeLazyCat> http://paste2.org/get/765643 have information for TH? Just scan the argument number of `DaemonSignalArgs`, then do loop with `toVariant`, and got [Variant]
12:28:03 <FunctorSalad> (not saying it could be done shorter)
12:29:02 <FunctorSalad> some of the documentation is in plain comments rather than haddock last time I checked
12:29:06 <ManateeLazyCat> Oh man, i talk so much. Why example code is so hard?
12:30:00 <ManateeLazyCat> aavogt: I read your `unpackDyn`, less help.
12:30:18 <FunctorSalad> why do you expect others to write code for you that you find just too tedious? (not too hard apparently)
12:30:30 <FunctorSalad> but I don't want to start a fight
12:30:54 <ManateeLazyCat> Oh, forgot it. I think myself.
12:31:27 <ManateeLazyCat> FunctorSalad: Not tedious, i just can't understand TH enough.
12:31:44 <FunctorSalad> I'm not the "RTFM" type usually, but a demanding tone breeds defiance :)
12:31:47 <ManateeLazyCat> FunctorSalad: I just want a easily starter.
12:31:47 <kamatsu> arg
12:32:03 <kamatsu> all these tail recursive functions i write seem to cause thunk blowout but i'm not really able to tell why or how
12:32:18 <kamatsu> and I can't seem to figure out a good function where laziness doesn't get in the way
12:32:21 <Saizan> are you strict in the accumulators?
12:32:26 <dino-> Does parsec 3.0.1 come with ghc 6.12.1?
12:32:56 <Saizan> no parsec comes with ghc-6.12.1 iirc
12:32:57 <kamatsu> Saizan: yes
12:33:10 <FunctorSalad> hmm was I being hostile there?
12:33:23 <Saizan> kamatsu: maybe not enough? you could try pasting the code
12:33:27 <FunctorSalad> don't want to send #haskell into etiquette decline ;o
12:33:45 <kamatsu> Saizan: It's in a haskell-like language
12:34:23 <FunctorSalad> I didn't even say "RTFM", I told him how to obtain an AST for what he has...
12:34:25 <kamatsu> Saizan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24799#a24799
12:35:16 <aavogt> FunctorSalad: and if you look at the required TH code, it's basically the same as was already showed: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24798#a24798
12:35:38 <aavogt> so given unpackDyn, it should be pretty easy to see how to write unpackDyn
12:35:38 <kamatsu> Saizan: It detects the tail-calls correctly, and i'm pretty sure my stack saving logic is correct. SpiderMonkey is complaining of too much recursion on the line where I create thunks though, makes me think laziness has screwed with my brain again
12:35:58 <aavogt> I think that the list comprehensions + quotes are probably a bit confusing ;)
12:36:08 <dino-> Eh, what the hell, just unreg'd the 3.0.1
12:36:11 <FunctorSalad> aavogt: where's that from?
12:36:22 <aavogt> what do you mean where?
12:36:29 <FunctorSalad> did you just write it? must have missed it
12:36:56 <aavogt> FunctorSalad: I wrote the unpackDyn for manatee yesterday
12:37:38 <FunctorSalad> maybe it would be a good idea to put all the convenience functions scattered around various packages into TH main :)
12:38:02 <Saizan> kamatsu: mh, i'd expect any haskell compiler to basically make a loop out of that, so i'm not sure how it could be improved
12:38:02 <FunctorSalad> like builders for the common cases instead of having to deal with filler like `NormalB'
12:38:07 <ehamberg> is there an easy and fast way of getting the type of e.g. map from the command line? i tried installing lambdabot and running “lambdabot -e '@type modify'”, but that often takes > 2 seconds and spews out irc-related messages… :)
12:38:15 <aavogt> FunctorSalad: what's the problem with normalB?
12:38:19 <kamatsu> Saizan: right, so i screwed up writing the tailcall optimization.
12:39:10 <aavogt> I thought it would be enough to show an example and point to documentation for the rest of it
12:39:17 <FunctorSalad> aavogt: nothing, I just meant building ASTs is verbose due to the fine-grainedness necessary for all language constructs
12:39:51 <aavogt> right, you sort of have to limit yourself to some smaller subset of haskell for the generated code
12:39:52 <kamatsu> The way I tried to make it work is have any function application in tail recursive position throw a continuation down the stack
12:39:58 <aavogt> at least for sanity purposes
12:40:00 <kamatsu> but it didn't seem to work
12:41:11 <kamatsu> so, any non-tail application would have an exception handler, and then if the function was tail-recursive that was called, it would bounce into the exception handler that would invoke the continuation, and then merrily merrily all the way to the bank
12:41:21 <FunctorSalad> aavogt: maybe a less prohibitive typing scheme for the metalangauge (TH here) would work? lisp being the other extreme
12:41:44 <FunctorSalad> I mean, metacode gets executed during compile time anyway
12:41:50 <aavogt> well library-wise it might be nice if the AST had a bit more type information
12:42:05 <Saizan> kamatsu: ah, i didn't realize you were writing a compiler :)
12:42:28 <aavogt> you really have no idea in which ways you may combine two ExpQs
12:42:38 <FunctorSalad> (though as in the non-meta case, typing proves correctness of the code generator in more generality than running the code generator)
12:42:48 <kamatsu> Saizan: to JavaScript though
12:43:10 <aavogt> so the types are all in your head when writing TH, as opposed to being occasionally written somewhere
12:43:13 <kamatsu> ah, sigh, i have no clue why this does not work
12:43:27 <FunctorSalad> aavogt: maybe a single phantom-parameterised gadt is a solution, so strong typedness is optional
12:43:46 <FunctorSalad> *dunno*
12:43:58 <aavogt> I suppose it's just a question of tool support for printing the types of ExpS
12:44:02 <FunctorSalad> wrapping names in var constructors is tedious too
12:44:24 <kamatsu> Saizan: Oh pooh, I just realised it wasn't detecting the freaking tail call in the first place
12:44:32 <aavogt> FunctorSalad: you do use the lowercase versions of the actual constructors though, right?
12:44:38 <Saizan> kamatsu: seq was screwing it up?
12:45:02 <FunctorSalad> I'm not sure what you mean by "have no idea in which ways one can combine two ExpQs"
12:45:11 <FunctorSalad> (why it's particularly severe with TH)
12:45:38 <aavogt> FunctorSalad: I mean you can't look at the AST and see which ways will generate valid code
12:45:44 <FunctorSalad> aavogt: hmm depends... sometimes I do all Q-monad binding up-front and make the AST in a pure way
12:46:07 <Saizan> in MetaOcaml Exp is parametrized by the type of the expression, and i'm not sure but they might be supporting some form of HOAS too
12:46:18 <aavogt> writing the AST using just the constructors is more noisy
12:46:34 <aavogt> ex.    VarE f `AppE` VarE x
12:46:42 <aavogt> vs.    [| $f $x |]
12:46:48 <FunctorSalad> Saizan: a type-level AST for types? oh dear
12:46:49 <fax> let ($) = AppE
12:46:55 <aavogt> vs.    [| $(varE f) $(varE x) |]
12:46:56 <fax> VarE f $ VarE x
12:46:58 <FunctorSalad> is that usable?
12:47:29 <FliPPeh__> Has anyone gotten authentication going with Network.HTTP?
12:47:30 <aavogt> fax: sure, but then there's this confusion about which one is actually in scope
12:47:35 <kamatsu> Saizan: how'd you guess?
12:47:43 <kamatsu> Saizan: I fixed it, it seems to be ok now
12:47:46 <FunctorSalad> aavogt: I ran into random restrictions with the brackets though so I just went with the ast
12:47:47 <aavogt> the correction is to make a typeclass ;)
12:47:53 <FunctorSalad> maybe I need to learn how to use the brackets correctly
12:48:04 <aavogt> I went through that phase
12:48:18 <aavogt> not to say I've actually improved or anything
12:48:23 <FunctorSalad> hehe
12:48:29 <Saizan> FunctorSalad: uh, no, i meant Exp :: * -> *, where the argument is the actual type that the expression will have if spliced
12:49:00 <FunctorSalad> Saizan: doesn't that need dependent types? :)
12:49:02 <kamatsu> Saizan: sweet, TCO works now :D
12:49:08 <Saizan> kamatsu: well, syntactically the use of seq makes that definition non-tail recursive :)
12:49:33 <FunctorSalad> since the typing information about the generated code is value-level in the metalang
12:49:48 <FunctorSalad> (if you dynamically make a declaration, e.g.)
12:49:56 <Saizan> only something like GADTs i'd think
12:50:08 <Saizan> however i don't know the details of their type system
12:50:22 <aavogt> FunctorSalad: perhaps the result type may not really depend on any arguments for the metaprogram?
12:50:31 <Saizan> maybe it just typechecks before quoting :)
12:51:24 <kamatsu> oh dear, my compiler is ridiculously slow :(
12:51:35 <FunctorSalad> for quotes it might work; I was thinking something like "do { x <- getLine; return [SigD foo x, ValD foo ....] }"
12:51:37 <FunctorSalad> *g*
12:52:02 <FunctorSalad> (@ Saizan )
12:52:21 <Saizan> heh, i see :)
12:52:33 <FunctorSalad> or runIO getLine
12:53:12 <Saizan> you'd have to use existentials for those
12:53:47 <FunctorSalad> you can have stronger information if you're willing to go into type-level theorem proving hell ;)
12:54:06 <FunctorSalad> (representing knowledge about the type system in the type system)
12:54:14 <aavogt> runIO getLine??
12:54:27 <FunctorSalad> aavogt: to lift it from IO to Q
12:55:45 <marekw2143> what does function1.function2 mean ?
12:55:54 <Saizan> ?src (.)
12:55:54 <lambdabot> (f . g) x = f (g x)
12:55:58 <FunctorSalad> another funny one is: putStrLn ("built on "++ $(do { x <- runIO getCurrentTime; return [LitE (StringL (show x))]; }))
12:56:04 <marekw2143> thx Saizan
12:56:08 <dmhouse> marekw2143: f . g is the function that, given some input x, returns f (g x)
12:56:08 <FunctorSalad> ( aavogt )
12:56:31 <marekw2143> dmhouse: thx
12:56:32 <FunctorSalad> probably some syntax errors there
12:57:29 <zygoloid> $(liftM lift $ runIO getCurrentTime)
12:58:09 <monochrom> f . g is literally a pipeline. figuratively too.
12:58:43 <Saizan> i wish lift didn't have to go through the syntax
12:59:16 <aavogt> FunctorSalad: I know what it's meant for... just that it's craziness to demand user input during compilation
12:59:33 <aavogt> Saizan: me too
12:59:47 <marekw2143> monochrom: whad do you mean by pipeline?
13:00:37 <kmc> marekw2143, like a unix pipeline
13:00:48 <kmc> the output of g goes into the input of f
13:01:12 <FunctorSalad> aavogt: just an example why representing the type of the generated code *literally* in the type of the AST requires dependent types or Dynamic
13:01:19 <marekw2143> oh, so when f1.f2.f3 x1 x2 x3 then it will be f1(f2(f3(x1, x2,x3)))?
13:01:32 <kmc> yes
13:01:43 <kmc> but that's not the Haskell syntax for function application
13:01:50 <kmc> it's the syntax in maths and most other programming languages
13:01:53 <fax> no
13:01:56 <aavogt> marekw2143: it doesn't work that way
13:01:56 <dmhouse> marekw2143: f3(x1,x2,x3) isn't how you write "call f3 with arguments x1 x2 x3"
13:02:07 <aavogt> it works though
13:02:12 <kmc> err and yes you need another operator
13:02:25 <kmc> "f1 . f2 . f3 x" works
13:02:55 <kmc> "f1 . f2 $ f3 x1 x2 x3" works
13:03:08 <FunctorSalad> aavogt: hehe sounds fun actually... have the user enter the code in ncurses prompts ;o
13:03:22 <FunctorSalad> (like debconf)
13:03:33 <zygoloid> marekw2143: f1 . f2 . f3 x1 x2 x3  ==  \y -> f1 (f2 (f3 x1 x2 x3 y))
13:03:52 <aavogt> TH doesn't make any serious guarantees about ordering and repetition of IO, FunctorSalad?
13:04:02 <dmhouse> <kmc> "f1 . f2 . f3 x" works -- depends what you mean by works. That's f1 . f2 . (f3 x)
13:04:06 <FunctorSalad> aavogt: runIO comes with a warning indeed
13:04:12 <FunctorSalad> aavogt: dunno the details
13:04:26 <kmc> yeah
13:04:35 <marekw2143> and in the case f2 takes also 2 parameters (like f1(f2(f3(x1, x2), paramToF2))?
13:05:06 <kmc> f1 (f2 (f3 x1 x2) y)
13:05:17 <kmc> which is:  f1 $ f2 (f3 x1 x2) y
13:05:32 <kmc> marekw2143, every Haskell function really takes exactly one argument
13:05:45 <kmc> some functions take one argument, and return a function that takes another argument
13:05:56 <marekw2143> kmc: right
13:06:17 <marekw2143> btw the $ can be used only once in expression?
13:06:21 <kmc> no
13:06:26 <kmc> it's an ordinary infix operator
13:06:32 <kmc> no more special than (+)
13:06:35 <kmc> @src ($)
13:06:35 <lambdabot> f $ x = f x
13:06:54 <djahandarie> @src (+)
13:06:54 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
13:07:05 <dmhouse> >
13:07:09 <djahandarie> @src subtract
13:07:09 <lambdabot> subtract x y = y - x
13:07:12 <c_wraith> @src Int (+)
13:07:12 <lambdabot> Source not found. My pet ferret can type better than you!
13:07:16 <byorgey> it's actually LESS special than (+)
13:07:17 <dmhouse> > show $ negate $ 3
13:07:18 <lambdabot>   "-3"
13:07:19 <c_wraith> @src Integer (+)
13:07:19 <lambdabot> Source not found. My brain just exploded
13:07:23 <byorgey> since (+) is type class polymorphic =)
13:07:27 <kmc> the point is just that it has low precedence, whereas application by juxtaposition has very high precedence
13:07:41 <dmhouse> c_wraith: they're magic, I doubt you'll find them
13:07:42 <Cale> marekw2143: However, it has the "wrong" associativity for function application, and so if you chain more than one ($) together, it ends up being equivalent in meaning to an expression where all but the last ($) is replaced with (.)
13:07:42 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
13:07:45 <kmc> marekw2143, but it's less common to see multiple $, because the preferred way to write "f $ g $ h $ x" is "f . g . h $ x"
13:08:00 <kmc> reason being that "f . g . h" is still a type-correct and useful expression by itself
13:08:02 <c_wraith> dmhouse: they're not magic.  They're defined in terms of primitive ops.
13:08:11 <kmc> the primitive ops are magic
13:08:16 <mjrosenb> after ghc has built the stage2 compiler, does it use that to build anythign else?
13:08:23 <dmhouse> c_wraith: that's what I mean by magic
13:08:24 <Cale> as well as g . h and f . g, etc.
13:08:28 <kmc> and (+) is primitive in standard Haskell anyway
13:08:36 <Cale> While g $ h and f $ g are going to be ill-typed
13:08:38 <c_wraith> dmhouse: But the primitive ops work on Int#, not Int.
13:08:46 <dmhouse> c_wraith: in GHC
13:09:03 <dmhouse> c_wraith: by "magic" I meant "beyond the scope of the report, defined in a compiler-specific way"
13:09:05 <Cale> (+)'s implementation is primitive, but (+) itself isn't
13:09:18 <Cale> (It's a class method)
13:09:18 <c_wraith> dmhouse: and @src doesn't work from the report
13:09:22 <c_wraith> @src IO
13:09:22 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
13:09:27 <c_wraith> That's not from the report
13:09:29 <dmhouse> Hmm
13:10:13 <aavogt> @hoogle ExpQ -> DecQ
13:10:13 <lambdabot> Language.Haskell.TH.Syntax bindQ :: Q a -> (a -> Q b) -> Q b
13:10:13 <lambdabot> Control.Monad forever :: Monad m => m a -> m b
13:10:14 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
13:13:49 <mjrosenb> ok, where did the second two results come from?
13:15:29 <Cale> heh, curious
13:15:58 <Cale> hoogle does some approximate matching and sometimes it's hard to figure out why it thinks some results are related
13:17:40 <Cale> ExpQ is a type synonym for Q Exp, and DecQ is similarly a type synonym for Q Dec
13:17:45 <Cale> and Q is a monad
13:17:53 <marekw2143> how does Just works?
13:17:54 <Cale> and a functor
13:18:01 <kmc> @src Maybe
13:18:01 <lambdabot> data Maybe a = Nothing | Just a
13:18:13 <aavogt> so fmap with the appropriate (a -> b) is good
13:18:18 <Cale> So forever (x :: ExpQ) :: DecQ actually works, though it's silly
13:18:20 <kmc> marekw2143, any value of type (Maybe a) is either Nothing, or it's (Just v) for some value v of type a
13:18:38 <kmc> :t Just 'x'
13:18:39 <lambdabot> Maybe Char
13:18:56 <kmc> the "data" declaration tells you that
13:19:01 <Cale> marekw2143: It might help to imagine a value of type Maybe t as being like a list of elements of type t whose length is at most 1.
13:19:05 <kmc> and it also says that we can take apart such a value by pattern matching
13:19:16 <kmc> > case Just 'x' of Nothing -> "not a thing"; Just _ -> "some thing"
13:19:17 <lambdabot>   "some thing"
13:19:26 <kmc> @src maybe
13:19:26 <lambdabot> maybe n _ Nothing  = n
13:19:26 <lambdabot> maybe _ f (Just x) = f x
13:19:43 <kmc> ^^^ here's a function named "maybe" (not to be confused with the type "Maybe") which pattern matches such a value
13:20:00 <Cale> Where the "empty list" here is given by the value 'Nothing', and the "list of length 1" case is given by 'Just x' for any value x
13:20:45 <marekw2143> It's haskell's answer to dynamically  typed languages I think
13:20:58 <fax> what is?
13:21:07 <marekw2143> Maybe
13:21:14 <kmc> well, no
13:21:17 <kmc> the general mechanism behind it is
13:21:21 <Cale> Eh, it's just another very simple datastructure
13:21:34 <kmc> the general mechanism is called "algebraic data types"
13:21:56 <FunctorSalad> it's more like 'null' done more sanely ;)
13:21:57 <kmc> each algebraic type has one or more constructors (here, Nothing and Just), and each constructor has zero or more data fields attached
13:21:58 <fax> marekw2143 ahhh I see what you mean
13:22:19 <kmc> "Maybe" is just one example of an algebraic type, that's declared for you in the standard library
13:22:20 <FunctorSalad> as in "explicit whether something may or may not be null at a given point"
13:22:27 <benmachine> kmc: algebraic types have zero or more constructors in h2010 :P
13:22:31 <kmc> true
13:22:41 <kmc> most real Haskell programs will declare many custom types that are more specialized than Maybe
13:22:58 <mjrosenb> benmachine: i am not sure how useful that is compared to one or more.
13:23:08 <kmc> mjrosenb, type-level programming
13:23:15 <mjrosenb> kmc: or just use Either with error
13:23:29 <kmc> er, that's still a small set of the use cases
13:23:40 <benmachine> mjrosenb: some would argue the type of 'forever' could benefit from one
13:23:42 <benmachine> :t forever
13:23:43 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
13:23:49 <mjrosenb> kmc: right, but most programs that are not "here, look what i can do with type theory" aren't going to use it
13:24:01 <jmcarthur> i disagree
13:24:04 <kmc> mjrosenb, but that stuff is actually useful
13:24:06 <jmcarthur> i use empty data types all the time
13:24:17 <benmachine> forever can't actually produce any values of type b, so one could show that in the type
13:24:21 <kmc> type-level programming is important e.g. for adaptive containers
13:24:30 <Cale> benmachine: The type already shows that
13:24:32 <mjrosenb> benmachine: you want it to return an empty type rather than something that will unify with anything?
13:24:39 <kmc> because (forall b. b) is isomorphic to Void
13:24:51 <benmachine> Cale: yes but it typechecks in some situations youd' rather it didn't
13:25:00 <Cale> What situations?
13:25:02 <kmc> it would be less error-prone
13:25:11 <benmachine> :t forever id 7
13:25:12 <lambdabot> forall b. b
13:25:13 <kmc> do { x <- forever (return 'x'); putChar x }
13:25:24 <benmachine> :t forever id 7 'x' getChar sort comparing
13:25:24 <mjrosenb> kmc: there is also one type up to isomorphism that has no constructors
13:25:25 <lambdabot> forall t. t
13:25:31 <kmc> if someone misunderstands "return" they might write that
13:25:35 <Cale> That makes sense to me, type-wise, even though it's a silly program
13:25:58 <kmc> it does make sense type-wise, but you can always use (void <$>)
13:26:03 <kmc> to make your intention explicit
13:26:14 <FunctorSalad> mjrosenb: Void can be plugged into some more general library function (like the identity function, that one isn't practically useless now?)
13:26:15 <kmc> or call it ex_falso_quodlibet if you want to be pretentious like Coq
13:26:29 <FunctorSalad> like rederiving "concat" if your lib only has "concatMap"
13:26:55 <jmcarthur> i'd rather types prevent me from writing obviously silly code even if the end result is the same
13:26:55 <FunctorSalad> the fact that Void isn't really empty in haskell makes it feel dirty though
13:27:02 <jmcarthur> just to make sure i understand what i'm doing
13:28:13 <Cale> Well, what you have in the end there is something which is completely polymorphic. You know it's got to be undefined.
13:29:06 <Cale> It might be nice to have a compiler warning flag to look for ridiculously polymorphic things which are more complicated than 'undefined'
13:29:12 <FunctorSalad> Cale: a truly empty type would rule out way more case-branches though... lke [TrueVoid] being { undefined, [] } and [Void] being infinite...
13:29:17 <jmcarthur> (>>) :: Monad m => m Void -> m a -> m a
13:29:40 <Cale> FunctorSalad: But you can't have a truly empty type.
13:29:50 <FunctorSalad> so I always feel like Void just being like an assertion-like (runtime) safety mechanism :)
13:29:56 <Cale> FunctorSalad: At least, not without somehow crippling the computational class of the language.
13:30:06 <FunctorSalad> Cale: yeah
13:30:08 <monoidal> you can use partiality monad
13:30:19 <monoidal> assuming the language is total "on the surface"
13:30:21 <FunctorSalad> Cale: or the decidability of typechecking...
13:30:27 <FunctorSalad> which might not be that bad
13:31:01 <FunctorSalad> (that sentence should be "without sacrificing the decidability ...")
13:31:46 <monoidal> [Void] has { [] }, Partial [Void] has { undefined, [] }, [Partial Void] has { [], [undefined]... } etc
13:32:02 <Cale> monoidal: Yes, but while I'm convinced that this sort of metaprogramming approach works great for I/O (for the same reason that model/view-controller works). I'm still not convinced that splitting things up in that way will always result in not-completely-awkward program designs.
13:32:24 <FunctorSalad> monoidal: I was playing fast and loose with lazyness and totality there, yes ;)
13:33:27 <FunctorSalad> monoidal: hmm sounds interesting
13:33:31 <Cale> It's not obvious that most or all programs stratify naturally like that into an always-terminating part and a Turing-complete part
13:33:32 <FunctorSalad> (partiality monad)
13:34:05 <FunctorSalad> you retain both turing-completeness and set-like semantics for the part not tainted by the Partial monad?
13:34:10 <FunctorSalad> at the cost of some clutter
13:34:32 <SUraj> Hi
13:34:38 <Cale> hello
13:34:42 <SUraj> anuone who can help me with MYSQL ?
13:34:47 <monoidal> i think yes
13:34:54 <Cale> This channel is about the functional programming language Haskell
13:35:00 <FunctorSalad> though you'd need elaborate constructs like in coq if you want to convince the compiler that your provably terminating function doesn't lead out of Totality land
13:35:30 <Cale> You probably want #mysql or something.
13:35:57 <Adamant> looks like Apple just nuked all non C-family and Javascript apps.
13:36:03 <dankna> Adamant: I heard :(
13:36:04 <SUraj> alright
13:36:18 <fax> innovation!
13:36:22 <jmcarthur> Adamant: yeah, dumbest move ever
13:36:24 <Adamant> dankna: yeah, didn't know if this made it onto here yet or not
13:36:30 <dankna> I don't think it did, but.
13:36:53 <Cale> Adamant: Why do we care about it? Are there Haskell apps?
13:37:02 <dankna> there /could/ be.  I was thinking of writing one.
13:37:08 <Adamant> Cale: there was an effort being made to put them on there
13:37:10 <Adamant> IIRC
13:37:11 <fax> there will not be any haskell programs from now on
13:37:15 <jmcarthur> Cale: yes
13:37:16 <Cale> What does "nuked" mean in this context?
13:37:17 <fax> http://lambda-the-ultimate.org/node/3905
13:37:19 <FunctorSalad> monoidal: in other words, without support for limited recursion schemes not requiring Partial monad, everything will end up in Partial anyway
13:37:29 <dankna> well, I mean, people who wanted to risk Apple's wrath could always use -fvia-c
13:37:35 * benmachine vaguely wonders why lcm was considered important enough to get in the Prelude
13:37:39 <jmcarthur> Cale: apple outlawed them in the license agreement
13:37:40 <Cale> -fvia-C won't really help
13:37:42 <Adamant> Cale: you can't compile Haskell to C
13:37:51 <dankna> it's clearly disallowed by the agreement, but from a technical standpoint it would work
13:37:52 <monoidal> FunctorSalad: yes, this requires things like primitive recursion built in
13:37:57 <Adamant> or compile to native code or whatever
13:37:58 <jmcarthur> Adamant: even if you could it would be disallowed
13:38:00 <jmcarthur> oh wait
13:38:02 <jmcarthur> that's what you mean
13:38:07 <Cale> The resulting C code produces assembly which needs to be mangled by the evil mangler, and can't be used directly
13:38:07 <Adamant> jmcarthur: yeah, that's what I meant
13:38:15 <dankna> I see
13:38:19 <jmcarthur> Cale: there was a ghc port for the iphone
13:38:22 <FunctorSalad> monoidal: that's a good start, sometimes you need stuff like recursion over the size though (like for substitution functions)
13:38:23 <Adamant> yeah
13:38:33 <FunctorSalad> where you recurse on a not-exactly-subterm
13:38:53 <Adamant> basically, you write it in C/Obj-C/C++, or Javascript, or kiss off
13:38:54 <jmcarthur> Cale: http://projects.haskell.org/ghc-iphone/
13:38:58 <Cale> I don't know why people bother with Apple.
13:39:09 <monoidal> induction over N is tricky, if naturals are Succ naturals | Zero then one cannot recuse on n/2
13:39:24 <fax> Cale well I hope other people will also start to realize that now
13:39:35 <fax> monoidal, you can
13:39:36 <Adamant> Cale: probably because when they aren't being control freaks about everything, their products are really good. The downside, of course, is that when they get successful, they start overreaching
13:40:19 <monochrom> such is the life cycle of the rise and fall of every empire
13:40:23 <jmcarthur> apple has had good moments and bad moments... mostly bad moments in the last few years
13:40:24 <monoidal> fax: this requires a proof n/2 < n
13:40:32 <FunctorSalad> fax: but it requires advanced understanding of arithmetic in the type system, no?
13:40:39 <fax> monoidal that's trivial (assuming n is not 0)
13:40:44 <FunctorSalad> to do that kind of stuff in general I mean, not hardwired for Nat
13:40:57 <monochrom> and just induct on n.
13:41:09 <Adamant> monochrom: it's been a repeated pattern with Apple. They didn't use Torx screws on the Mac back in the 80's for engineering concerns.
13:41:33 <fax> Adamant how is that anything similar to now allowing people to write programs for their own computers?
13:41:45 <monochrom> it all comes down to dissonant human nature.
13:41:51 <FunctorSalad> monochrom: I thought others decline due to cba syndrome? ;) somehow companies don't seem to
13:42:00 <FunctorSalad> (empires)
13:42:06 <Adamant> fax: because back in the day people liked to add hardware modifications
13:42:16 <fax> ohh
13:42:32 <fax> I just break stuff when I touch it so that didn't occur to me
13:42:43 <monoidal> also, partiality monad can be implemented to support parallel or/unamb "safely" (without threads)
13:42:48 <monochrom> anyway #haskell-blah needs your support!
13:43:01 <Adamant> monochrom is right on that way.
13:43:03 <Adamant> *one
13:43:04 <FunctorSalad> free membership 30 days
13:43:29 <monochrom> we need a #haskell-blah recruitment program!
13:43:57 <sm> offer daily prizes
13:44:04 <monoidal> recruit :: Haskell -> Blah Haskell
13:44:10 <FunctorSalad> no automatic subscription after that unless recommended by our trusted affiliates
13:44:14 <xerox> we offer one karma point to the first 5 joining
13:44:21 <monochrom> haha
13:44:41 <alpounet> haha
13:44:53 <xerox> starting... now!
13:50:07 <FunctorSalad> fax: n/2 < n for n > 1 isn't all that trivial...
13:50:28 <FunctorSalad> integer division being messy
13:50:30 <fax> oh I thought it was basic arithemtic for some reason
13:50:40 <FunctorSalad> (trivial to prove in a type system, I mean, not for humans ;))
13:52:24 <opqdonut> ISTR of natural numbers + a limited induction of form ( P 1 /\ forall x. P (x/2) -> P x ) -> forall x. P x
13:52:33 <opqdonut> characterising some computability class
13:52:40 <opqdonut> er, s/of//
13:53:16 <dolio> Presumably if you want that kind of induction, you'd be using a view like Bit n = Even (k : N) (n = 2*k) | Odd (k : N) (n = 2*k + 1)
13:53:53 <FunctorSalad> dolio: I was assuming n/2 is a general integer division
13:53:56 <dolio> Then it's pretty trivial to know in each case that k < n, unless n = 0 (which is probably a base case anyway).
13:54:04 <FunctorSalad> (for extra messyness)
13:55:15 <dolio> Yes, but why are we "doing induction by arbitrarily dividing by k"?
13:55:16 <FunctorSalad> that seems to require proving that every n is for every m uniquely of the form n = m * a + b
13:55:24 <FunctorSalad> (to even define integer div)
13:55:35 <FunctorSalad> with 0  <= b < m
13:55:47 <opqdonut> halving can be defined inductively
13:56:30 <StaticPhilly> afternoon all
13:57:10 <jlouis> Damn, I need to force computation...
13:57:24 <b0fh_ua> Hi. Can somebody please explain me what is the easiest way to convert [Char] into Data.ByteString and visa versa?
13:57:40 <dmhouse> ?hoogle pack
13:57:40 <lambdabot> Data.ByteString pack :: [Word8] -> ByteString
13:57:40 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
13:57:41 <lambdabot> Data.ByteString.Lazy pack :: [Word8] -> ByteString
13:57:50 <byorgey> hi StaticPhilly
13:57:54 <b0fh_ua> dmhouse: nice, but Word8 ...
13:58:00 <dmhouse> b0fh_ua: look at the second one
13:58:08 <FunctorSalad> jlouis: NFData?
13:58:14 <b0fh_ua> dmhouse: I have to use first one
13:58:18 <dmhouse> b0fh_ua: why?
13:58:27 <jlouis> FunctorSalad: yes, perhaps
13:58:34 <b0fh_ua> because it is used in Text.CSV.Bytestring
13:58:56 <FunctorSalad> b0fh_ua: you have a choice to make between truncating chars > 255 and utf8-encoding....
13:59:15 <FunctorSalad> withCString just truncates last time I checked :(
13:59:19 <b0fh_ua> FunctorSalad: files are in latin1
13:59:38 <FunctorSalad> hmm, 'ord' is utf8 afaik
13:59:48 <FunctorSalad> so you might want to convert that
14:00:20 <jlouis> FunctorSalad: some precision surgery with NFData might indeed do!
14:00:21 <FunctorSalad> @ty ord
14:00:22 <lambdabot> Char -> Int
14:00:28 <Twey> It's Unicode, not UTF-8
14:00:31 <dankna> if you need to treat your input as binary
14:00:35 <FunctorSalad> Twey: righ
14:00:36 <dankna> you shouldn't be reading Chars at all
14:00:37 <FunctorSalad> *right
14:00:40 <Twey> ord returns a codepoint, not an encoded character
14:00:41 <FunctorSalad> type error on my part
14:00:49 <dankna> you should be using the input functions in ByteString to read bytestrings directly
14:01:01 <Twey> And you can also use UTF-16 or various other encodings
14:01:06 <b0fh_ua> dankna: I am working with text
14:01:08 <Twey> (except on Windows — no codepages yet)
14:01:13 <b0fh_ua> and I need to do some pattern-match
14:01:18 <dankna> well, you may wish to set the encoding explicitly
14:01:19 <Twey> (you're limited to UTF-8, UTF-16, and Latin-1)
14:01:53 <dankna> anyway pack $ map ord should do it
14:02:07 <FunctorSalad> Twey: yeah, I was taking utf8 as the more-or-less-standard-now
14:02:26 <Twey> Well, Windows uses UTF-16 (or was it UCS-2?) internally
14:02:32 <FunctorSalad> pack . fromIntegral . map ord will truncate, dankna
14:02:44 <dankna> hm?  he wants it truncated
14:02:50 <dankna> he's using Latin1
14:03:00 <FunctorSalad> assuming some latin1 chars have unicode codepoints over 255
14:03:01 <FunctorSalad> no idea
14:03:09 <Twey> If you don't mind truncation, you can just use the .Char8 module, I tihnk
14:03:10 <dankna> no, Latin1 is only 8 bits
14:03:10 <liyang> Twey: was UCS-2, now UTF-16.
14:03:22 <dankna> oh, sorry, misread you
14:03:27 <FunctorSalad> dankna: yeah, but it's not the first 256 chars of unicode I think
14:03:30 <dankna> it is in fact
14:03:32 <dankna> he's lucky in that regard
14:03:38 <Twey> It is, but the encoding is different
14:03:39 <dankna> if he wanted Latin2 he'd have to convert the encoding explicitly
14:03:40 <FunctorSalad> I stand corrected
14:03:45 <FunctorSalad> it's a permutation?
14:03:51 <Twey> The codepoints are the same
14:03:57 <Twey> But the binary representation is different
14:04:10 <dankna> the first 256 codepoints of Unicode are the entirety of Latin1
14:04:12 <b0fh_ua> omg
14:04:17 <Twey> (past 127 in the case of UTF-8, and for all of them in the case of UTF-16)
14:04:26 <FunctorSalad> dankna: thanks that's new to me
14:04:28 <Twey> think**
14:04:30 <dankna> Functor: sure
14:04:44 <FunctorSalad> good design from the POV of latin1 users ;)
14:04:56 <Twey> There are lots of regions like that in Unicode
14:05:00 <dankna> yes :) rather irritating design for Latin-X users where X is not 1, haha
14:05:19 <FunctorSalad> why did they permute it though?
14:05:23 <Twey> s/users/codec-writers/ ;)
14:05:32 <dankna> Functor: I don't understand the question
14:05:34 <monochrom> UTF-8 maps every Latin1 character to 2 bytes.
14:05:42 <Twey> monochrom: No?
14:05:45 <Twey> UTF-16 does
14:05:54 <Twey> UTF-8 is one byte for the first 127 (A.K.A. ASCII)
14:06:05 <cebewee> Latin1 \ ASCII is mapped to two bytes
14:06:06 <Twey> FunctorSalad: An initial 1 in UTF-8 indicates a multi-byte character sequence
14:06:12 <dankna> well, technically UTF-8 maps every Latin1 character with codepoints in the range 128 to 255 to 2 bytes
14:06:12 <Twey> cebewee: *nod*
14:06:19 <marekw2143> what does:    readPoint s | Just [x,y] <- matchRegex (mkRegex "someRegex") s = (read x,read y) mean ?
14:06:20 <Zao> cebewee: latin-1 refers to the 8-bit encoding ISO 8859-1.
14:06:35 <Twey> Zao: Which is a superset of ASCII
14:06:53 <Zao> cebewee: From which the first 128 code points are identical in UTF-8, while the last 128 code points are encoded as a 2 code unit UTF-8 sequence.
14:06:55 <FunctorSalad> dankna: I understood you as saying that the *set* of latin1 chars is equal to  the set of unicode chars with codepoint < 256... but nevermind, I forgot utf8 multibyte overhead
14:07:04 <Zao> Twey: Depending on what you mean by "ASCII".
14:07:06 <FunctorSalad> (the set being equal, but order different)
14:07:14 <dankna> Functor: yeah okay.  no, the order is the same.
14:07:15 <Zao> Twey: There's an awful lot of people attaching meaning to the high bit in "ASCII".
14:07:25 <monochrom> You see how these semantic wars never end.
14:07:33 <Twey> Zao: The high bit in ASCII is for parity.
14:07:42 <dankna> meh, I hope in ten years we will finally be settled on some encoding
14:07:46 <dankna> but that may be optimistic
14:07:49 <Twey> dankna: We already are, pretty much
14:07:50 <Zao> Twey: People, not some ancient standard.
14:07:50 <FunctorSalad> the binary incompatibility is due to overhead due to needing a prefixfree code, I reckon
14:07:57 <dankna> Twey: well, yes...
14:08:00 <Twey> Everything's moving towards UTF-8
14:08:08 <Twey> It'll probably be exclusive soon
14:08:14 <dankna> yeah, it helps that UTF-8 is actually a really nice design
14:08:37 <FunctorSalad> (it would have been enough to sacrifice a single byte value though, not half of them)
14:08:39 <Twey> Zao: Nobody with actual technical knowledge includes Latin-1 and other ‘extended ASCIIs’ when saying ‘ASCII’.
14:08:49 <FunctorSalad> to signify "here comes a multibyte char"
14:08:49 <Zao> I'd rather that there was a flag day for UTF-16, so that all the broken crap that accidentally kind of not doesn't handle UTF-8 won't mutilate it.
14:09:13 <Twey> FunctorSalad: No no
14:09:17 <dankna> Functor:
14:09:18 <Twey> FunctorSalad: It sacrifices only one bit
14:09:23 <Zao> FunctorSalad: It's easier to parse, I'd say.
14:09:24 <Twey> FunctorSalad: The rest of the byte goes into making the character
14:09:27 <Zao> Just mask a bit and branch on it.
14:09:37 <dankna> UTF-8 has the property that you can distinguish bytes which are in the middle of a multibyte character from bytes which are not
14:09:56 <dankna> this is very desirable for low-level code dealing with it
14:10:07 <FunctorSalad> Twey: only one bit, but one value would be enough
14:10:10 <dankna> your proposal would not enable that
14:10:12 <Twey> Zao: I… can't parse your last message
14:10:13 <cebewee> Zao: UTF-16 is IMHO the worst of the common unicode encodings
14:10:21 <dankna> yeah, UTF-16 is not nearly as nice
14:10:24 <FunctorSalad> (but would be even worse for other languages than latin1)
14:10:37 <opqdonut> yeah, -8 is nicely compatible, -32 is easiest
14:10:39 <Twey> FunctorSalad: I think you're missing the point… you can't use a smaller indicator than a single bit :þ
14:10:42 <Zao> FunctorSalad: And that value would signify what? That the next code unit is either a code unit in the range 0xFF to 0x1FE?
14:10:54 <Zao> FunctorSalad: It'd be rather unscalable for higher code points.
14:11:07 <dankna> Twey: no no, he's suggesting that ie the codepoint 128 would be encoded as two bytes, FLAG and VALUE
14:11:17 <Zao> You'd have to look hard to come up with an encoding that lets you represent any plane in just four code units.
14:11:19 <Twey> But why?
14:11:30 <Zao> (except UTF-8, which does it nicely)
14:11:37 <FunctorSalad> Twey: you *could* have UTF8 bytes 0-254 map to latin1, and 255 signifying multibyte (but as people said that would have other problems)
14:11:42 <dankna> UTF-8 also has the property that codepoints collate in the same order as the encoded bytestream treated as a sequence of bytes
14:11:51 <dankna> which is not really all that useful, but it's a nice trick
14:11:56 <Twey> FunctorSalad: Ahh, I see, aiming for binary compatibility with more of Latin-1?
14:12:01 <Zao> FunctorSalad: And how would the "multibyte" characters be encoded?
14:12:20 <monochrom> Gosh are we bored.
14:12:26 <Twey> You could have a series of ‘multibyte’ bytes indicating the length of the character
14:12:36 <Zao> FunctorSalad: Your scheme sounds a lot like Shift-JIS and other abysmal encodings.
14:12:36 <dankna> hey I know
14:12:37 <Twey> Horribly inefficient though.
14:12:51 <Twey> monochrom: You noticed? :þ
14:13:06 <dankna> we need to have a bignum indicating the number of bits
14:13:20 <dankna> in case we need more than 2^2^32 codepoints someday
14:13:21 <cebewee> Latin1 is not even that interesting anymore; I guess most people would have shiftet to Latin9 by now, if it weren't for UTF-8
14:13:29 <FunctorSalad> Zao: dankna convinced me already ;) (that picking up in the middle of a stream is a nice property to have)
14:13:36 <dankna> Latin1 is really useful only for a very small handful of languages
14:13:40 <dankna> Functor: oh good :)
14:13:56 <monochrom> Basically if I talked about a url like http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8583 you would starting commenting on how "http" was a poorly chosen name and how you would name it.
14:14:09 <monochrom> Or how you don't like / used that way.
14:14:18 <FunctorSalad> sorry, couldn't answer to everyone, too fast
14:14:20 <dankna> in practice us technical folk are the only ones who include the http when we write URLs anyway
14:14:29 <monochrom> hahaha
14:14:39 <Twey> dankna: I don't think that's true
14:14:47 <dankna> Twey: well... it depends on the context
14:14:59 <Twey> Adding the http:// allows $popular_site to parse them into links
14:14:59 <dankna> if you're writing an advertisement you leave it out
14:15:04 <Twey> Yeah
14:15:08 <monochrom> God, you people are so predictable and unpredictable.
14:15:10 <Twey> But that's because advertising space costs
14:15:10 <dankna> if you're communicating via computer you may include it
14:15:22 <dankna> monochrom: god, you're so metapredictable
14:15:39 <dankna> no, honestly, I think it's because it takes more attention for someone to read a URL with the prefix
14:15:40 <cebewee> monochrom: I'd rather discuss about // being an unfortunate choice; especially for file urls :p
14:15:46 <dankna> and it gives it a nerdy feel
14:15:54 <Twey> I would write http://com.moonpatio/fastcgi/hpaste.cgi/view?id=8583 or something
14:15:55 <dankna> leaving it off is more "hip"
14:15:59 <stevenmarky> moonpatio always reminds me of moonpig http://www.youtube.com/watch?v=aiKs1vSlTSA
14:16:01 <Twey> Consistency FTW
14:16:15 <Twey> dankna: I guess that's so
14:16:22 <cebewee> dankna: Even excluding the www.
14:16:23 <Twey> Also makes it fit better with English text
14:16:35 <dankna> cebewee: yeah - I made www.dankna.com redirect to dankna.com in fact
14:16:35 <Twey> ‘://’ is kind of an odd sequence to see appear in the middle of a sentence
14:16:42 <Twey> Quite jarring
14:16:43 <dankna> Twey - yeah indeed
14:17:06 <Twey> Moo~npi~g
14:17:35 <dankna> hey hey
14:17:44 <dankna> what about UTF-8 in URL/URI protocol specifies?
14:17:52 <FunctorSalad> "<Zao> That the next code unit is either a code unit in the range 0xFF to 0x1FE?" <-- the initial 0xFF byte could be followed by an arbitrary subdecoding for the rest of unicode, but lots of stuff would be forced down to length 3
14:18:05 <FunctorSalad> so it'd be quite euro-imperialistic ;)
14:18:08 <dankna> ?://dankna.com/example/
14:18:08 <lambdabot> Unknown command, try @list
14:18:12 <Twey> dankna: Unicode in URLs and other unique identifiers has security implications
14:18:28 <dankna> Twey: yes.  but having the "looks-like" collation helps mitigate that a bit.
14:18:34 <Twey> Aye
14:18:45 <stevenmarky> how about no multibyte indication, and use ai to judge the context and display the correct characters
14:19:01 <Twey> stevenmarky: Haha.  Markov-based encoding?
14:19:03 <FunctorSalad> the embedded people will love that
14:19:24 <dankna> stevenmarky: unfortunately that's what IRC does... without the AI part :(
14:19:31 <stevenmarky> lol
14:19:45 <FunctorSalad> :D
14:19:47 <dankna> so probably only about half of you could see my snowman above :D
14:20:03 <FunctorSalad> in the mathy channels utf8 seems to have become the standard
14:20:10 <dankna> excellent
14:20:23 <FunctorSalad> thus I was surprised of people complaining about it around other IRC parts
14:20:27 * dankna nods
14:20:36 <dankna> Jabber solves this problem, of course
14:20:38 <dankna> it's not hard to solve
14:20:42 <sungji> hi :)
14:21:08 <Twey> UTF-8 is standard just about everywhere on IRC
14:21:18 <Twey> Even #nihongo finally converted a while back
14:21:32 <FunctorSalad> Zao: I meant to say that you wouldn't need to have a pessimally degenerated tree all the way down, you could go balanced after the 0xFF byte
14:21:42 <FunctorSalad> (but I'm not seriously defending this encoding anymore)
14:21:43 <dankna> yeah, EUC-JP used to be quite entrenched in that community
14:22:04 <dankna> I'm glad that UTF-8 has gotten traction there
14:22:13 <Twey> dankna: It was ISO-2022-JP
14:22:17 <dankna> was it?  oh.
14:22:30 <dankna> that was a nasty one :(
14:22:35 <Twey> Yeah
14:22:47 <Twey> Forms funny mojibake, though
14:22:50 <mle-lucca> dankna: iso-2022-jp is just euc-jp with the highbit stripped and escape sequences. Easy, and easier to detect
14:22:51 <dankna> haha
14:23:23 <dankna> mle-lucca: oh yeah, because having to keep a registry of which escape sequence goes with which client encoding is easy... heh
14:23:27 <dankna> mle-lucca: and hi :)
14:23:44 <mle-lucca> hi
14:24:09 <FunctorSalad> is space-efficiency even a conern of the utf people or is that the job of the compressor?
14:24:19 <dankna> it's a concern.
14:24:23 <sungji> is there a way to somehow successfully "derivate" a fold function for a data-type (e.g. data Tree a = Leaf a | Node (Tree a) (Tree a)) ?
14:24:40 <dankna> but it must be remembered that in ideographic languages there's simply no way to get as efficient as ASCII spacewise
14:24:43 <FunctorSalad> sungji: fold-th (or th-fold, can't remember)
14:24:51 <Twey> It's a concern for -8
14:24:53 <FunctorSalad> someone upload the other as an alias please ;)
14:24:55 <sm> is there a way to get cmdargs' usage string to show ARGS instead of [ARGS] ? I don't think so
14:24:55 <Twey> And -16
14:24:59 <Twey> Not so much for -32
14:25:01 <mle-lucca> you want deriving traversable?
14:25:23 <dankna> look at Scrap Your Boilerplate
14:25:43 <dankna> there might be a tutorial on it somewhere, I dunno.  the original paper is a pretty good tutorial.
14:25:50 <sungji> e.g. data Direction = L | R | Up | Down,       data Block = Tile [(Dir, Block)] ,     how do I derive the fold function for Block? (foldBlock) ?
14:25:53 <FunctorSalad> sm: cmdargs'?
14:25:57 <dankna> if it's not what you want, I'm not convinced that I know what you want.
14:26:02 <sm> http://hackage.haskell.org/package/cmdargs
14:26:34 <FunctorSalad> scrap your boilerplate is kind of a last resort over strongly typed folds though
14:26:37 <mle-lucca> ... you want fold to solve a maze?
14:26:44 <FunctorSalad> (fold-th, like I said)
14:26:47 <dankna> Functor: yeah that's true
14:26:55 <monochrom> sungji: yes there is, but I'm too lazy to describe it.
14:27:38 <sungji> monochrom, exam's on monday. it's one of the two exams I need to pass in order to get my BSc... or I'm out.
14:28:10 <sungji> monochrom, It would be so cool, if you could help me a little with it
14:28:58 <FunctorSalad> (syb does type-theoretically illegal stuff, though the interface it presents is type-safe (but still more powerful than what you could to without unsafeCoerce, I think))
14:29:16 <dankna> hmm
14:29:29 <dankna> that's an interesting point
14:29:42 <FunctorSalad> not entirely sure about the last part, we recently discussed it in #blah
14:29:47 <sungji> FunctorSalad, couldn't find fold-th on haskell.org/hoogle
14:30:14 <FunctorSalad> sungji: http://hackage.haskell.org/packages/archive/th-fold/latest/doc/html/Language-Haskell-TH-Fold.html#v:fold
14:30:38 <FunctorSalad> sungji: I recommend hayoo if you aren't searching for type signatures; it crawls more things
14:30:45 <marekw2143> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24801#a24801 - what will that code define?
14:31:43 <sungji> FunctorSalad, http://holumbus.fh-wedel.de/hayoo/hayoo.html ?
14:31:55 <sungji> FunctorSalad, btw, Guten Abend :)
14:32:33 <sm> there's no replace function in pcre-light, right ?
14:32:34 <FunctorSalad> dankna: I mean, you could implement "cast" manually without cheating in an closed world, but not in an open-world manner extensible through new instances
14:32:39 <FunctorSalad> or am I missing osmething?
14:32:50 <FunctorSalad> sungji: Guten Abend :)
14:33:01 <kmc> Uniplate is another nice library for generic programming
14:33:04 <kmc> very different from SYB
14:33:18 <dankna> I thought the entire point of cast was that it could in fact be implemented without cheating
14:33:22 <FunctorSalad> sungji: yes
14:33:46 <kmc> dankna, the way cast is implemented in Data.Typeable relies on trusting the instances of the class Typeable
14:33:48 <FunctorSalad> dankna: no, it checks typeRep equality, then does unsafeCoerce
14:34:06 <dankna> kmc: hmm...  oh.
14:34:07 <kmc> if you write your own Typeable instance you can easily break the type system
14:34:15 <kmc> they should almost always be derived
14:35:28 <sungji> FunctorSalad, hmm... foldBlock looks like this:      foldBlock f xs = f [(a, (foldBlock f b)) | (a,b) <- xs] ... which looks way more complicated than fold-th suggests ...
14:36:27 <Saizan> FunctorSalad: epigram 2 solves that by making all datatypes defined via an universe
14:36:28 <FunctorSalad> sungji: foldBlock? and the typesig in fold-th is simple because it's a TH macro
14:36:47 <FunctorSalad> sungji: you can see the generated code with the -ddump-splices ghc flag
14:36:59 <sungji> FunctorSalad, hm I'm not allowed to do that in the exam :)
14:37:28 <dankna> it's not even clear to me what foldBlock is supposed to do
14:37:33 <FunctorSalad> sungji:  ah, thought we were talking about convenience, not understanding
14:37:40 <sungji> FunctorSalad, I need to come up with a fold function (for a given data type) on paper
14:38:08 <sungji> dankna, hm so there must be a function signature given, in order to define a proper fold function?
14:38:44 <dankna> sungji: well, it's not mandatory but it certainly makes your code clearer.  but I don't know what you're trying to do.
14:39:00 <FunctorSalad> Saizan: to have a closed world (and know it)?
14:39:23 <sungji> dankna:    this is given:     foldBlock :: ([Dir,a] -> a= -> Block -> a  , now they could ask me to come up with the implementation for that :)
14:39:28 <FunctorSalad> is this OTT?
14:39:41 <Saizan> i think it's orthogonal to OTT
14:40:00 <sungji> dankna, and I'd like to know if there's a more systematic way to come up with the fold function ... (it took me more than an hour to get it)
14:40:12 <Saizan> however yeah, no need to extend the language with new induction principles and such for every datatype declaration
14:40:14 <FunctorSalad> the sigs become mandatory for folds of some non-regular types
14:40:29 <FunctorSalad> (which go outside of hindley-milner)
14:41:03 <FunctorSalad> your Tree is perfectly regular, though
14:41:21 <dankna> it's still not clear to me what the function is supposed to do.  it takes a function from a list of pairs of directions and values to just values, and a block, and.... does something to them...?
14:41:29 <dankna> am I being dense?
14:41:31 <chrisdone> http://www.chrisdone.com/posts/2010-04-09-cabal-install-hacking.html
14:41:31 <chrisdone> 'case anyone wants it
14:41:44 <Saizan> FunctorSalad: http://personal.cis.strath.ac.uk/~dagand/levitation.pdf <- this is the paper if you're interested
14:41:58 <sungji> dankna,  data Direction = L | R | Up | Down,       data Block = Tile [(Dir, Block)]
14:42:07 <dankna> chrisdone, hm cool
14:42:43 <FunctorSalad> sungji: the general scheme is that the fold takes as input a handler for every constructor. then you make the handlers recurse at recursive positions
14:42:47 <dankna> yes, I saw you said that above.  the purpose of this data structure is unclear to me as well.
14:43:00 <FunctorSalad> it's mechanical
14:44:22 <sungji> FunctorSalad, that's what I've been told :D yet I don't see how that applies to foldBlock :) I could name you another example where I see what's going on (like,  data Logic a = Var a | Conj (Logic a) (Logic a) | Disj (Logic a) (Logic a) | Not (Logic a) )
14:44:38 <FunctorSalad> sungji: look at that as the solution to the equation:  x = Tile [(Dir, x)]
14:44:51 <FunctorSalad> (the positions containing the type itself are important for folds)
14:45:13 <sungji> FunctorSalad, mhm ok
14:45:18 <FunctorSalad> if the `x' is buried like it is here, the thing burying it must be a functor
14:45:22 <FunctorSalad> which it is here
14:45:47 <sungji> FunctorSalad, hang on, need to lookup what a functor is ;)
14:46:26 <sungji> hm ok
14:46:27 <FunctorSalad> you don't actually get a fold if x is buried in a non-functorial position
14:46:40 <FunctorSalad> such as data Weird = Weird (Weird -> Weird)
14:46:52 <FunctorSalad> :)
14:47:10 <sungji> FunctorSalad, that's a confusing example :)
14:47:13 <FunctorSalad> so since you do have a functor, just recurse and fmap
14:49:12 <sungji> FunctorSalad, hm did I get you right, functor = Type constructor?
14:50:00 <sungji> like in  Month Int= January Int | February Int | March Int | ... ?
14:50:04 <FunctorSalad> explicitly it should be: foldB h1 = go where go (Tile x) = h1 (my_fmap go x)
14:50:40 <FunctorSalad> (you can't use fmap because while "x \mapsto [(Dir,x)]" is a functor, haskell can't represent compositions of functors as functors directly
14:50:43 <FunctorSalad> )
14:51:38 <FunctorSalad> so you should implement my_fmap :: (x->y) -> [(Dir,x)] -> [(Dir,y)]
14:51:38 <andrewe> I tried the server example of HaXR at http://www.haskell.org/haskellwiki/HaXR (1.1.1.1). If I start this, shouldn't a socket be opened and visible with nmap?
14:51:38 <FunctorSalad> @src Functor
14:51:38 <lambdabot> class  Functor f  where
14:51:38 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
14:52:08 <FunctorSalad> sungji: a type constructor which doesn't just map types, but functions between types too
14:53:51 <FunctorSalad> sungji: maybe this one-constructor one-field example doesn't show you the general pattern
14:53:53 <andrewe> Hm, seems like it doesn't include a server, but I don't know how to use that CGI stuff. :-(
14:53:59 <FunctorSalad> I called it "h1" for "handler for constructor #1"
14:54:06 <FunctorSalad> with more ctors you just accept more handlers
14:54:15 <FunctorSalad> with more fields you feed every field to the handler
14:56:40 <FunctorSalad> fields of unrelated types are passed to the handler as-is
14:56:59 <FunctorSalad> fields where type recursion happens are the interesting part
14:57:33 <FunctorSalad> (things get way more messy with mutually recursive types btw)
14:58:10 <sungji> FunctorSalad, hm I'm trying to understand how this applies to:   foldBlock :: ([Dir,a)] -> a) -> Block -> a ("..folds the block b to a value of type a by recursively folding its neighboring blocks and combining the results using f")
14:59:27 <FunctorSalad> sungji: I didn't think about blocks at all... you just search-and-replace recursive positions :)
15:00:21 <dcoutts_> chrisdone: are you going to send in your command completion patch?
15:00:35 <FunctorSalad> sungji: but your paraphrasis seems right
15:01:08 <chrisdone> dcoutts_: sure!
15:01:46 <dcoutts_> chrisdone: you know that the existing bash command line completion works right?
15:02:09 <dankna> foldBlock function (Tile items) = function $ zip (map fst items) (map (function . snd) items)
15:02:18 <dankna> I finally understand what you want it to do, I think
15:02:24 <dcoutts_> chrisdone: it's a couple more characters I guess, "ins<tab>" since there's also "init" and "info" commands.
15:02:52 <dcoutts_> chrisdone: cabal b<tab> works though
15:02:56 <chrisdone> dcoutts_: that doesn't work here... what version is this for? do I need a special bash version?
15:03:02 <sungji> FunctorSalad, it's an old exam question :/
15:03:06 <FunctorSalad> dankna: or (fmap . fmap) for the functor part if we have `instance Functor ((,) a)'
15:03:11 <dcoutts_> chrisdone: source the bash-completion/cabal script
15:03:16 <FunctorSalad> don't remember
15:03:20 <dankna> FunctorSalad: hm - cool trick
15:03:28 <FunctorSalad> wasn't that instance in some obscure module?
15:03:58 <dcoutts_> chrisdone: cabal has builtin command completion support, so the bash completion script is fairly generic
15:04:01 <chrisdone> dcoutts_: oh, doh. :p I'll delete my post
15:04:17 <dankna> haha don't delete your post, it might be useful to somebody.  just amend it pointing out the better way.
15:04:23 <dcoutts_> chrisdone: no, advertise the existing support! :-)
15:04:30 <chrisdone> will do!
15:04:30 <dcoutts_> chrisdone: it completes flags etc too
15:04:52 <dcoutts_> chrisdone: on the other hand, your patch would be mostly consistent with the existing behaviour for flags
15:04:54 <FunctorSalad> Control.Monad.Writer
15:04:57 <FunctorSalad> has the functor instance
15:05:03 <dankna> dcoutts_: thanks again for talking me out of that arbitrary-key-value thing.  I've got another extension on the horizon now - I want to support my lexer/parser generator Joy in the same way that Alex and Happy are supported.  Is this something for which you'd accept a patch? :)
15:05:04 <FunctorSalad> or something reexported by it
15:05:19 <dcoutts_> chrisdone: the standard command line flag parser allows unique prefixes of flags, it'd make sense to extend that for commands.
15:05:41 <FunctorSalad> (orphan instance)
15:05:55 <dcoutts_> chrisdone: what I'm less sure of is extending it down to ambigious command names, and resolving based on popularity. Maybe that's sensible, I guess it depends on what people think generally.
15:05:58 <FunctorSalad> or maybe not, and C.M.Writer just reexports it
15:06:19 <dankna> I'm not certain about resolving on popularity either.
15:06:35 <dankna> Better would be to print a message saying please use a unique prefix and listing the possible completions.
15:06:39 <dcoutts_> chrisdone: and if you've got any suggestion how we can more widely deploy the bash completion, currently it doesn't actually get installed anywhere, so nobody knows it exists.
15:06:42 <chrisdone> dcoutts_: right. I just picked the ones I use often (e.g. install vs info)
15:06:49 <chrisdone> right
15:07:02 <dcoutts_> dankna: right, that's what it does for flags
15:07:07 <dankna> right, gotcha
15:07:08 <adept> hi. Any chance that http://scvalex.github.com/ is present here?
15:07:32 <dcoutts_> dankna: patches for new pre-processors gratefully accepted
15:07:39 <dankna> dcoutts_: excellent :D
15:07:46 <chrisdone> dcoutts_: do you have an options for doing that? I've never asked cabal to install extra things for me before, so I don't know
15:07:52 <FunctorSalad> are we talking about bash-completing non-common-prefix stuff?
15:07:57 <FunctorSalad> to the most popular option
15:08:07 <dankna> it's probably about three weeks away.  need to have the preprocessor actually working first.  and its name isn't final either because somebody pointed out that Joy is the name of a programming language...
15:08:26 <dcoutts_> FunctorSalad: not tab completion, but if you hit enter with a non-unique prefix
15:09:21 <FunctorSalad> ah
15:09:28 <dcoutts_> chrisdone: partly the problem is cabal has no particular support for installing things in special places (beyond bindir, libdir etc) and partly that it's not clear if there is actually a cross-distro standard location
15:09:52 <dankna> I don't believe there is any standard location, but looking at what Debian and Redhat do would be a good start
15:09:59 <wolgo> man haskell powers are like steroids for geeks
15:09:59 <dcoutts_> chrisdone: a solution might have to be distro-specific, or eg declare the things and let the distro packages put them in the right places.
15:10:02 <dankna> since most distros are based on one or the other
15:10:04 <wolgo> this is fun!
15:10:12 <FunctorSalad> for tab completion I think I prefer a hybrid... first tab completes the common prefix, second tab lists options, third tab picks one and starts cycling
15:10:14 <dcoutts_> dankna: aye
15:10:21 <FunctorSalad> sadly bash doesn't have that to my knowledge
15:10:36 <FunctorSalad> ot 1 + 2 can be combined
15:10:38 <FunctorSalad> *or
15:10:43 <dankna> I'm pretty sure Bash /does/ have that, although I've never used it.  I don't mind the extra typing, haha.
15:11:11 <FauxFaux> That's what I'm using in zsh, but I didn't configure it. ¬_¬
15:12:11 <p_l> ZSH I think has some heuristics for commands that respond in a certain way
15:13:41 <FunctorSalad> you can have both on different keys
15:13:54 <FunctorSalad> the former is menu-complete, the latter cycle-complete
15:14:08 <FunctorSalad> but I can't think of a free key that's as good as tab
15:15:10 <FunctorSalad> sorry, the latter behaviour is the menu-complete command
15:15:44 <FunctorSalad> zsh scared me, is it worth learning?
15:16:02 <adept> Help me out with a "policy" question. Suppose there is a package on hackage that (judging from the name) does some algorithmic stuff. Only it really doesnt, not by a long stretch. If I contact its author and he fails to respond in some reasonable time, would it be ok for me to hijack it?
15:16:30 <fax> hijack??
15:16:31 <adept> Oh should I upload with name like "$pkgname-real"?
15:16:40 <FunctorSalad> ah, the former is just 'complete'
15:16:46 <adept> fax: upload under the same name
15:16:55 <fax> don't upload with the same name
15:17:04 <benmachine> adept: people will have different ideas of what a reasonable time is
15:17:07 <chrisdone> dcoutts_: could you do something like what is done with binary files? (1) install to .cabal/foo and tell the user to add .cabal/foo to their PATH. likewise, that default location is configurable in .cabal/config. I'd be happy with that. I like how cabal stuff is installed in the same place whether I'm on linux, os x, whatever, rather than it trying to be clever
15:17:08 <fax> just try to do things that will not BREAK EVERYTHING
15:17:31 <adept> benmachine: thats understandable. I am not trigger-happy :)
15:18:25 <adept> fax: care to elaborate on why?
15:19:03 <chrisdone> adept: you broke everything
15:19:10 <benmachine> adept: I don't know if there's an official policy, it would probably be useful if there was one
15:19:28 <benmachine> maybe someone should ask haskell-cafe (to/and then) write a wiki page
15:19:36 <adept> chrisdone: "broke"? I didnt do anything yet
15:20:12 <chrisdone> adept: I was joking about fax's lost terminal, hehe
15:20:24 <adept> oh
15:20:32 * adept breathes relief
15:20:48 <chrisdone> dcoutts_: or is that a bad idea?
15:21:00 <sbahra> adept, you could also wait and ask dons.
15:21:51 <adept> @seen dons
15:21:51 <lambdabot> Unknown command, try @list
15:21:59 <sbahra> preflex, seen dons
15:21:59 <preflex>  dons was last seen on #haskell 1 day, 17 hours, 43 minutes and 11 seconds ago, saying: let r += b = do x <- unsafeCoerce# r ; poke (unsafeCoerce# r) (x + 1) ...
15:22:07 <sbahra> Dangerous.
15:22:31 <adept> sbahra: ha! he says that I should "coerce"
15:22:33 <adept> unsafely
15:22:45 <adept> i say this means "hijack it" ;)
15:22:53 <benmachine> adept: what package anyways?
15:23:05 <aavogt> write the improved version already
15:23:42 <adept> benmachine: SegmentTree. What is there is not a segment tree at all, despite the fact that sources mention Wikipedia article on Segment Trees as reference
15:24:26 <benmachine> last updated over a year ago
15:25:56 <FliPPeh__> I have a data type that is built up from a parsed JSON string, and it looks like this: JObject [("key", JString "value"), ("anotherobject", JObject [("moreKeys", JList [JString "and", JString "a", JString "list"])])]... you see, this is getting complicated
15:26:05 <FliPPeh__> How could I write a function such as... JPath?
15:26:16 <FliPPeh__> JPath "key"
15:26:29 <dankna> I take it you want your jpath to be analogous to xpath
15:26:30 <FliPPeh__> JPath "anotherobject/moreKeys"
15:26:37 <FliPPeh__> dankna: Exactly
15:26:42 <dankna> I think syb is the approach you want
15:26:42 <FliPPeh__> Or something similar
15:26:50 <FliPPeh__> What's syb?
15:26:50 <kmc> SYB shouldn't be necessary for that
15:26:53 <dankna> there's actuall a paper comparing syb to xpath
15:26:54 <kmc> @where syb
15:26:54 <lambdabot> http://www.cs.vu.nl/boilerplate
15:27:08 <dankna> it's not necessary for anything - it just simplifies
15:27:20 <kmc> what would it simplify here?
15:27:27 <kmc> the datatype is already homogenous
15:27:31 <FliPPeh__> Couldn't I do this recursively?
15:27:32 <Saizan> just define some "parse combinators"
15:27:32 <sbahra> adept, you can just write an alternative version for now and use a different name.
15:27:41 <dankna> certainly you could do it recursively
15:27:48 <kmc> FliPPeh__, yeah. i would use the "split" package to split your path into names
15:27:51 <adept> sbahra: and then pester Ross to take the package down?
15:27:59 <kmc> and then recurse on the components
15:28:03 <FliPPeh__> Probably "key" <!> "anotherKey" <!> "..."
15:28:19 <FliPPeh__> I think I like this more than the string approach
15:28:23 <dankna> Flippeh: by the way, are you planning to have xpath-like search axes?
15:28:24 <kmc> yes
15:28:52 <FliPPeh__> dankna: I'm just planning for a simple to use data-fetcher for my json
15:28:55 <dankna> gotcha
15:28:58 <FliPPeh__> No matter what method
15:29:01 * dankna nods
15:29:01 <FliPPeh__> :(
15:29:13 <Saizan> FliPPeh__: e.g. line 53-61 http://github.com/Saizan/fbspider/blob/master/Facebook.hs
15:29:18 <dankna> syb basically does recurse, except that it's simpler when the number of constructors is large
15:29:25 <dankna> but you only have a handful of constructors really
15:29:34 <kmc> path [] v = Just v; path (x:xs) (JObject vs) = path xs <$> lookup x vs; path _ _ = Nothing
15:29:39 <kmc> FliPPeh__, ^^^
15:30:02 <dankna> :t ^^^
15:30:03 <lambdabot> parse error on input `^^^'
15:30:08 <dankna> :t (^^^)
15:30:09 <lambdabot> Not in scope: `^^^'
15:30:21 <dankna> oh, nm
15:30:24 <dankna> you were pointing upward
15:32:06 <kmc> if you have lots of queries / big objects, it'd be advantageous to process the object assoc lists into a better assoc data structure
15:33:33 <kmc> if you want to use a generics library, i think Uniplate would be a better fit
15:33:36 <kmc> because of homogeneity
15:33:41 <dankna> I need to read up on Uniplate
15:33:49 <stevenmarky> I'm doing GHC --make -O2 blah.hs and it produces the same output as without the -O2. What am I doing wrong?
15:34:04 <benmachine> in other news
15:34:08 <sungji> FunctorSalad, I think I got it now
15:34:13 <benmachine> has anyone else installed syb-0.2 on GHC 6.12?
15:34:16 <benmachine> cabal won't let me
15:34:21 <benmachine> cabal: dependencies conflict: base-3.0.3.2 requires syb ==0.1.0.2 however
15:34:21 <benmachine> syb-0.1.0.2 was excluded because syb-0.2 was selected instead
15:34:39 <systemfault> stevenmarky: Just in case.. write down that option on your foreheah ( -fforce-recomp )
15:34:54 <systemfault> *forehead
15:34:57 <dankna> ghc-pkg list for me shows syb-0.1.0.2 and syb-with-class-0.6.1
15:35:06 <kmc> stevenmarky, did it actually recompile?
15:35:09 <dankna> so yes, I have successfully installed it, although I haven't tried to actually use it
15:35:11 <kmc> try -fforce-recomp or rm *.o *.hi
15:35:26 <benmachine> dankna: that's not -0.2 >_>
15:35:29 <stevenmarky> ah I think that was it =)
15:35:31 <dankna> oh
15:35:34 <systemfault> kmc: I don't know what the GHC guys were thinking when they did that.
15:35:39 <stevenmarky> thanks systemfault.
15:35:48 <kmc> systemfault, which
15:35:52 <systemfault> kmc: If I invoke ghc then _I WANT_ to recompile
15:36:06 <systemfault> kmc: I shouldn't have to add an extra option for that
15:36:08 <dankna> not necessarily
15:36:10 <kmc> systemfault, the point of "--make" is  that it doesn't recompile everything
15:36:30 <sungji> FunctorSalad, in Conj (Logic a) (Logic a)  the Logic a isn't nested, whereas Block in  data Block = Tile [(something, Block)] is (twice: tuple, list), so one has to "peel" that banana first
15:36:52 <systemfault> kmc: Well, I guess I'll understand that choice better when I'll better with Haskell/GHC
15:36:55 <systemfault> :/
15:37:16 <Saizan> benmachine: it seems you've to do it the old fashioned way
15:37:47 <dankna> benmachine: hmmmm.... it doesn't let me either.  the error message informs me that base-3.0.3.2 relies on the old version.
15:38:01 <benmachine> Saizan: :(
15:38:03 <dankna> no doubt because it used to be part of base but isn't anymore and base-3 is just a wrapper
15:38:06 <Saizan> benmachine: might be worth a bug report on cabal-install
15:38:16 <dankna> I think it's a bug in base really, rather than in cabal
15:38:29 <dankna> in ghc 6.13 base-3 no longer exists so you could always try that
15:38:29 <FunctorSalad> sungji: right
15:38:30 <Saizan> why base?
15:38:32 <benmachine> I'm not sure why cabal is even looking at base3
15:38:54 <dankna> because the error message says that base-3 depends specifically on an old version of syb and that's why the new one can't be installed
15:39:08 <benmachine> I have six versions of HSE installed
15:39:11 <Saizan> benmachine: the handling of the two bases is quite complicated, to allow both to be used in the same build
15:39:12 <FunctorSalad> sungji: (side note: "nested" is a technical term referring to recursion on some other parameter instantiation than `a', which makes folds much more difficult)
15:39:12 <sungji> FunctorSalad, thanks a lot :D   it took me a while :D
15:39:21 <benmachine> Saizan: hmm ok
15:39:31 <FunctorSalad> like Tree a = T a (Tree (Maybe a))
15:39:32 <benmachine> Saizan: installing syb-0.2 manually won't ruin everything forever will it
15:39:35 <FunctorSalad> sungji: :)
15:39:36 <Saizan> dankna: you can simply ignore base-3.
15:39:57 <dankna> can I?
15:40:03 <dankna> hm
15:40:07 <SamB_XP> Saizan: that really shouldn't be base-specific :-(
15:40:17 <dankna> can't you only have one version of a package installed though, unless that package is base?
15:40:23 <benmachine> no
15:40:24 <FunctorSalad> sungji: so I called it "buried", but that's made-up
15:40:29 <dankna> oh
15:40:31 <benmachine> I have multiple versions of several packages
15:40:33 <Saizan> benmachine: no, though i wouldn't upgrade it without a specific reason
15:40:34 <dankna> okay
15:41:04 <benmachine> Saizan: well, my current pet project depends on it, so I would like to know if it works with the new version
15:41:10 <benmachine> I have no reason more compelling than that
15:41:17 <Saizan> that's a good reason :)
15:41:39 <sungji> FunctorSalad, hang on, I'll try to come up with a fold for that Tree...
15:41:54 <FliPPeh__> kmc: That function is awesome, thanks!
15:42:12 <FunctorSalad> sungji: it needs higher-rank types (ghc extension, illegal in haskell 98)
15:42:23 <sungji> FunctorSalad, in that case, forget it :D
15:42:25 <sungji> hahaha
15:42:39 <kmc> systemfault, ghc --make is a substitute for Makefiles etc.
15:42:50 <sungji> FunctorSalad, hm but could you give me another exercise, which I should be able to solve now?
15:42:57 <kmc> so it needs to do conditional recompilation based on modification
15:43:01 <sungji> (again data-fold related)
15:43:02 <FunctorSalad> since now your handler doesn't just have to handle the case where your parameter is `a', now it has to work for lots of `a's
15:43:07 <dankna> imo Cabal is a better substitute for Makefiles, but there's nothing wrong with having multiple solutions
15:43:18 <kmc> Cabal uses --make anyway
15:43:22 <kmc> it's a layer on top
15:43:23 <FunctorSalad> sungji: anything with more ctors than one?
15:43:26 <dankna> hm.  okay.
15:43:29 <FunctorSalad> and with recursion of course
15:43:37 <systemfault> kmc: I see
15:44:29 <SamB_XP> --make also goes faster than individually compiling each thing (usually)
15:44:45 <kmc> because it doesn't have to reload interface file
15:44:46 <SamB_XP> and gives a nicer indication of progress
15:45:37 <kmc> for any language much higher level than the C world of object files and untyped symbols, it's good to let the language implementation drive compilation
15:46:25 <SamB_XP> oh, is that why VB has traditionally been compiled by the IDE itself ;-)
15:46:28 <kmc> i can think of one major offender here
15:46:59 <SamB_XP> kmc: C++?
15:47:13 <FunctorSalad> sungji: data InfiniteFanoutTree a = N (Integer -> InfiniteFanoutTree a) | L a
15:47:15 <kmc> you guessed correctly
15:47:24 <FunctorSalad> sungji: that's a functor too :)
15:47:25 <SamB_XP> well, I'm not sure about the "much higher leve" part
15:47:32 <SamB_XP> but certainly the symbols are not untyped
15:47:38 <kmc> SamB_XP, it at least aspires to be higher level
15:47:40 <SamB_XP> (entirely)
15:47:55 <kmc> it certainly supports a lot of abstractions that don't map cleanly onto the world of symbols and header files
15:48:05 <SamB_XP> (conspicuously absent from most schemes are the return types!)
15:49:36 <sungji> FunctorSalad, first of all, thanks :D secondly: is that a function there? such that  N:: (Integer -> InfiniteFanoutTree a) -> InfiniteFanoutTree a ? (I've never seen that before)
15:50:40 <alpounet> yes it is
15:50:44 <FunctorSalad> yes
15:51:39 <kmc> yeah, data types can contain functions
15:52:21 <kmc> it's a pretty big deal :)
15:53:10 <FliPPeh__> Oh kmc
15:53:26 <FliPPeh__> I there's an error in your path function I can't get rid of somehow
15:53:53 <FliPPeh__> path (x:xs) (JObject vs) = (path xs) <$> (Map.lookup x vs)
15:53:56 <FliPPeh__> Couldn't match expected type `JSON' against inferred type `Maybe JSON'
15:54:03 <kmc> oh right
15:54:08 <FliPPeh__> It's the first argument of <$> mocking up
15:54:13 <kmc> try <*> instead
15:54:17 <kmc> err no
15:54:17 <FliPPeh__> I did :x
15:54:30 <kmc> Map.lookup x vs >>= path xs
15:54:43 <FunctorSalad_> for disconnected there after the "big deal" comment
15:54:45 <FunctorSalad_> s/for/got/
15:54:55 <FliPPeh__> Ahh, that was what I was looking for :)
15:54:58 <FliPPeh__> Thanks kmc
15:55:00 <FliPPeh__> :)
15:55:00 <kmc> :)
15:55:05 <stevenmarky> won't that return a Maybe?
15:55:07 <kmc> i thought it could be done with only applicative but maybe not
15:55:12 <kmc> stevenmarky, yes
15:55:13 <FliPPeh__> stevenmarky: That's right
15:55:16 <FliPPeh__> I needs to
15:55:25 <stevenmarky> ah
15:55:33 <kmc> the overall type here is path :: [Key] -> JSON -> Maybe JSON
15:55:40 <FunctorSalad_> sungji: of course, the type is lying about really being the type of all infinitely branching trees ;)
15:55:51 <FunctorSalad_> since the functions are computable
15:56:09 <dcoutts_> chrisdone: sorry, what was that about $PATHs and binary files?
15:56:21 <FunctorSalad_> (the whole type would be uncountable)
15:56:23 <FliPPeh__> So now let's see if I can change the search pattern from ["...", "..."] to something fancy like "..." <!> "..."
15:56:42 <FliPPeh__> For the fun of it
15:56:46 <FunctorSalad_> "lying" unless you're a constructivist, anyway
15:57:06 <dcoutts_> adept: hijacking hackage names is not on, if a package is unmaintained and you'd like to take over maintenance and the author is uncontactable then propose on the libraries list
15:57:41 <dankna> he actually wants to replace it, not take over maintenance
15:57:55 <dankna> but I'd agree that it's bad practice
15:58:03 <dcoutts_> adept: if you just want the name, for a totally new package, then probably best to just pick a new name. Otherwise negotiate with the maintainer.
15:58:06 <dankna> in the event that anyone is depending on the package, the new one would break those things
15:58:11 <dcoutts_> indeed
15:58:50 <monochrom> "Hi I want to name my new lib 'base' because it's inspired by 'all your base are belong to us'"
15:59:04 <Philonous> A total overhaul would probably brake a lot of things, too
15:59:41 <FunctorSalad_> it could use some filtering capabilities
16:00:20 <FunctorSalad_> (to optionally filter out bitrotten unmaintained stuff)
16:00:59 <sungji> FunctorSalad_, foldInfiniteFanoutTree fN fL  = go     where go (L x) = fL x    go (N g) = ...
16:01:01 <sungji> hm...
16:01:03 <FunctorSalad_> dcoutts_: I guess you deliberately decided against a public voting system?
16:01:14 <dankna> I don't like direct democracies :)
16:01:18 <dankna> they're popularity contests
16:01:18 * mjrosenb continues to watch ghc compile
16:01:24 <dcoutts_> FunctorSalad_: not exactly
16:01:36 <dankna> so I wouldn't approve of a public voting system in its simplest form
16:01:44 <dcoutts_> FunctorSalad_: I'm not against a voting system, it just has to be designed carefully, it's tricky socially
16:02:03 <FunctorSalad_> dankna: well, it wouldn't have any force other than people being able to sort by it, but that's still a lot of force
16:02:07 <dankna> well, yes
16:02:18 <FunctorSalad_> dcoutts_: exactly
16:02:19 <monochrom> "I found a solution! My new lib is called 'bɑse' "
16:02:27 <dcoutts_> FunctorSalad_: my first suggestion for "quality" votes is a combination of downloads and reverse dependencies
16:02:37 <FunctorSalad_> it would be quite discouraging to get voted down...
16:02:52 <FunctorSalad_> unfortunately an up-only system loses a lot of information
16:02:56 <dcoutts_> FunctorSalad_: if another package author has decided to depend on a package, that's a fairly strong vote.
16:03:01 <FunctorSalad_> since you can't tell apart bad stuff and little-seen stuff
16:03:40 <dankna> could also use the future automated "did not compile" reports as down votes
16:04:48 <sungji> FunctorSalad_, foldInfiniteFanoutTree fN fL  = go     where go (L x) = fL x    go (N g) = fN ( foldInfiniteTree FN FL g )   (something is missing...)
16:05:00 <FunctorSalad_> (btw if you do implement this, do it like okcupid and use the lower bound of a confidence interval for the score as the final score... so things with a single 10/10 vote don't come before things with 1000 votes and 9.5 avg)
16:05:19 <dankna> that's a great idea about the confidence interval
16:06:40 <FunctorSalad_> yes, made me instantly love the site ;)
16:07:29 <sungji> FunctorSalad_, is that kinda the right direction?
16:08:18 <FunctorSalad_> sungji: yes, you're just missing the appropriate functor action
16:08:38 <FunctorSalad_> the functor being `(->) N'
16:08:45 <FunctorSalad_> I mean (->) Integer
16:10:37 <sungji> FunctorSalad_, hmmmmmmm
16:10:48 <FunctorSalad_> sungji: you could cheat and import this functor instance from Control.Monad.Error ;) but it's worth thinking about
16:11:26 <sungji> FunctorSalad_, problem is, I need to go to bed now, but I can't sleep without coming up with the solution heh
16:11:32 <FunctorSalad_> it's the universal example of a functor in a certain way
16:12:33 <FunctorSalad_> sungji: ah I know that, but on the plus side I think that kind of obsesive state makes lots of neurons connect ;)
16:12:38 * hackagebot SegmentTree 0.2 - Data structure for querying the set (or count) of intervals covering given point  http://hackage.haskell.org/package/SegmentTree-0.2 (DmitryAstapov)
16:13:09 <FunctorSalad_> (I mean functors of the form (->) A are special; Integer is not special)
16:14:03 * SamB_XP doesn't give a man a fish; he throws the man into the lake in a good spot ;-P
16:14:06 <dankna> Adept: wait - you did it?
16:14:45 <adept> dankna: yes. author turned out to be way more proactive than I expected
16:14:47 <FunctorSalad_> SamB_XP: isn't that pretty evil if he's hungry
16:14:56 <dankna> oh!  good.  if he agreed to it that's all fine then.
16:15:15 <SamB_XP> FunctorSalad_: but there's good fish there!
16:15:47 <dankna> "Light a fire for a man, and he will have fire for a day.  Set a man on fire, and he will have fire for the rest of his life."  Takes a moment to realize what it says, doesn't it.
16:16:00 <monochrom> hahaha
16:16:02 <dankna> grin
16:16:15 <dankna> I rather like that one, but it's too subtle without the last bit :)
16:16:31 <monochrom> That's what punchlines are for.
16:16:33 <dankna> quite so
16:16:55 <xerox> badum-cha!
16:17:43 <monochrom> This sentence should be used in logic courses as exercise in formalizing.
16:17:47 <mornfall> Hm. To which part you refer to as last bit?
16:17:54 <dankna> monrfall "takes a moment..."
16:18:00 <FunctorSalad_> "Give a man plenty of fish, and he will drop a block of sodium in the lake to see it go boom, killing all the fish..." (comment to a video where that is done)
16:18:29 <mornfall> Hm. Didn't here. Wonder what that means... probably nothing good.
16:18:30 <benmachine> it is not too subtle!
16:18:43 <benmachine> subtlety is often underestimated
16:19:21 <mornfall> There's a similar joke in Slovak about laughing last and dying soon.
16:19:26 <dankna> hm
16:19:27 <FunctorSalad_> dankna: hmm I found that one obvious the first time IIRC
16:19:30 <SamB_XP> FunctorSalad_: did it really kill all the fish ?
16:19:31 <mornfall> But I can't make it into proper English.
16:19:55 <chrisdone> it's not the cough that carries you off, it's the coffin they carry you off in
16:19:57 <dankna> he who laughs last obviously does not get the joke?
16:20:03 <FunctorSalad_> since there is no plausible way he could have fire for the actual non-shortened rest of his life
16:20:06 <FunctorSalad_> SamB_XP: I don't know
16:20:14 <SamB_XP> dankna: or he got it slower than everyone else ...
16:20:28 <dankna> Functor: well - I have had people misunderstand "set a man on fire" to be metaphorical
16:20:56 <FunctorSalad_> ah yes, that could send you off a red herring chase
16:20:57 <sungji> FunctorSalad_, hm I don't seem to get it now...
16:23:17 <Eelis> why can't one define an operator using a section? for instance:   (^*^ x) = something
16:23:46 <Twey> Because it doesn't make sense
16:23:58 <Eelis> hmm
16:24:00 <sungji> FunctorSalad_, hm can you explain it to me?
16:24:07 <Twey> No first argument?
16:24:11 <dankna> for the same reason that you can't mix definitions with different numbers of parameters for the same function
16:24:24 <mornfall> Twey: Pointless?
16:24:29 <mornfall> Or, pointfree. :))
16:24:37 <dankna> which I presume is difficulty implementing the resolution of which definition should apply to a given set of arguments
16:24:37 <Twey> mornfall: No, it's not unmentioned, it's just not there
16:24:38 <Eelis> Twey: the first argument would be introduced with a lambda
16:24:42 * hackagebot hoopl 3.7.8.0 - A library to support dataflow analysis and optimization  http://hackage.haskell.org/package/hoopl-3.7.8.0 (NormanRamsey)
16:24:46 <Twey> Eelis: That's not how it works
16:25:04 <mornfall> Twey: Section is partial application, too.
16:25:09 <Twey> If you have (^*^ x) = \y -> …, you've mentioned the second and third arguments, but not the first
16:25:13 <dankna> well, I see what Eelis is thinking.  you can do foo :: a -> b -> c and then define foo a = ...
16:25:19 <Twey> It just doesn't make sense
16:25:42 <Twey> It does make sense to talk about (x ^*^), and I think you can with PostfixOperators or whatever it's called
16:26:15 <mornfall> Twey: Nevertheless, '(^*^ x) y' still makes sense as an expression.
16:26:23 <Twey> mornfall: Not as a pattern
16:26:46 <Eelis> Twey:  "(^*^ x) = y" (where x may occur in y) could be desugared into  "(^*^) z x = y z"
16:26:56 <dankna> anyway, you can trivially reword (^*^ x) = \y -> ... as (y ^*^ x) = ...
16:27:31 <mornfall> dankna: Of course you can, but I guess that's not the ... point. :)
16:27:33 <Twey> mornfall: Oh, I see what you mean
16:27:48 <Twey> Yes, I guess it does, but without the y, it doesn't really
16:27:48 <dankna> mornfall: haha.... that wasn't subtle at all :)
16:27:59 <Eelis> the desugaring i mentioned above would work fine, no?
16:28:24 <mornfall> Twey: Well, without the y, the result just gets a -> type.
16:29:15 <FunctorSalad_> sungji: the functor action is function composition
16:29:24 <FunctorSalad_> sungji: fmap f g = f . g
16:29:30 <Twey> I guess it does make some sense
16:29:31 <Twey> It's just totally inconsistent
16:29:42 <Eelis> i don't see how it is
16:29:45 <FunctorSalad_> sungji: otherwise, it's exactly the same scheme as before
16:29:47 <Eelis> but we're making progress :)
16:32:02 <Twey> (x ^*^) = (5 +); (^*^ x) = (9 +)
16:32:07 <sungji> FunctorSalad_, hm how would go (N g) = .... now look like? (function composition consisting of which two functions?)
16:32:24 <Eelis> Twey: obviously that would be forbidden. no reasonable person would expect that to work
16:33:38 <Twey> It's inconsistent because it allows you to omit the first argument in your pattern yet talk about the second
16:34:05 <Twey> It results in you defining a sort of flipped version of the real function
16:34:28 <dons> ?yow
16:34:28 <lambdabot> Couldn't find fortune file
16:34:30 <dons> doh
16:34:35 <Eelis> Twey: that's what makes it so neat! :P
16:34:52 <Twey> It also makes match-checking more complicated, since number of arguments is no longer a good enough check to see whether two equations can define the same function
16:35:18 <Twey> Eelis: Except that the first argument becomes magic
16:35:49 * hackagebot shelltestrunner 0.8 - A tool for testing command-line programs.  http://hackage.haskell.org/package/shelltestrunner-0.8 (SimonMichael)
16:36:52 <FunctorSalad_> sungji: "f" is the recursion here, "g" the tree node
16:37:00 <Eelis> Twey: fair enough, i'll concede it's a tad exotic. thanks for these observations. i was mostly wondering whether it was fundamentally impossible in the first place
16:38:07 <Twey> And I guess not
16:38:15 <sungji> FunctorSalad_, go (N g) = fN (foldInfiniteFanoutTree FN FL . g) ?
16:40:06 <FunctorSalad_> sungji: looks right (and you can de-inline go there :))
16:40:31 <FunctorSalad_> the `go' tells the compiler and the reader that the f* remain fixed
16:40:44 <sungji> oh ok
16:40:58 <FunctorSalad_> maybe GHC does it automatically  now
16:41:19 <sungji> FunctorSalad_, Vielen Dank :D have a nice weekend, and good night (1:40AM)
16:41:37 <FunctorSalad_> sungji: :) gute nacht
16:41:40 <dons> looks like a job for -O2
16:41:55 <dons> does anyone keep up with hackage, btw?
16:42:04 <ivanm> @remember dons looks like a job for -O2
16:42:04 <lambdabot> Good to know.
16:42:22 <ivanm> dons: in what respect (keeping up with hackage)
16:42:37 <dons> oh, registering mentally each package that goes up.
16:42:44 <dons> there's been a spike this month, http://galois.com/~dons/images/hackage-daily-graph.png
16:42:52 <dons> heading up to 12/day avg
16:42:58 <dons> which means local spikes way above that
16:43:13 <ivanm> dons: is that just new packages, or "whoops, the release I made 2 minutes ago had a bug"?
16:43:26 <ivanm> because there were a few of those in the past month IIRC
16:43:29 <dons> yeah, just keeping in your head an idea of what's new
16:43:32 <FunctorSalad_> dons:  I sometimes look at the 'whatsnew' page, but far from catching it all
16:43:38 <dons> there's so much.
16:43:46 <FunctorSalad_> more to see what people are interested in right now
16:43:54 <dons> btw, 1990 packages.
16:43:57 <dons> 10 more to go!!
16:44:07 <dons> and we doubled inside of 18 months
16:44:09 <ivanm> heh
16:44:34 <Eelis> is there a way to say "module M (thing, <and-all-definitions>)" ? i need to specify "thing" specifically because it's imported from another module rather than defined in M, and so isn't exported by default
16:44:40 <dons> feb 2 2009 we hit 1k
16:45:02 <dons> so 13 months to double, that's awesome
16:45:35 <FunctorSalad_> Eelis: module M(thing, module Real_M) where import module Real_M?
16:45:55 <Eelis> FunctorSalad_: hmm, that could work. ugly though
16:45:57 <FunctorSalad_> with M's body moved there, obviously
16:46:03 <FunctorSalad_> ;)
16:46:03 <ivanm> dons: so not quite Moore's law (which should really have been called "Moore's Observation" :@ ) yet?
16:46:04 <Eelis> was hoping such hacks weren't necessary
16:47:34 <Eelis> FunctorSalad_: hah, "module M (thing, module M)" compiles. now i just wonder what it does :)
16:48:56 <waern> Eelis: yes, that works
16:49:27 <Eelis> so it does. great!
16:50:10 <sm> dons, I do keep an eye on hackagebot announce frequency.. I had thought it was a bit quiet lately
16:50:26 <sm> is that 1990 packages, or 1990 package versions ?
16:50:51 <dons> 1990 packages, ~8000 versions
16:50:59 <dons> 537 users have uploaded 7729 versions of 1990 packages.
16:51:08 <sm> ah right. thanks
16:51:23 <dons> sm: the rate is definitely climbing (90 day moving avgs) http://www.galois.com/~dons/images/hackage-daily-graph.png
16:51:35 <sm> I just saw.. nice
16:51:39 <Eelis> what's the rate of new users per week?
16:51:56 <dons> new people signing up to hackage?
16:51:59 <Eelis> yes
16:51:59 <dons> mmm. good question
16:52:01 <dons> ~1/day ?
16:52:13 <dons> i don't have figures
16:52:17 <Eelis> ok :)
16:54:03 <ivanm> <sarcasm>Of course, if the restriction on using "real names" was removed, that would instantly shoot up to 50/day sign ups and triple the rate of new packages!</sarcasm>
16:55:28 <Eelis> you're still angry about that?
16:55:46 <Eelis> in case you didn't notice; your side won :)
16:57:18 <Eelis> (in the sense that the discussion waned off, and the status quo remains unchanged)
16:58:38 <ivanm> Eelis: not angry
16:59:01 <ivanm> my sarcasm was more aimed at the fact that people thought that removing that restriction would make that big a difference
16:59:14 <Eelis> i don't recall anyone making that argument
16:59:29 <Eelis> the argument was that even losing /some/ contributors was a waste
16:59:36 <goomba> <totallyserious>i cant wait until the restriction is removed so i can spam hackage</totallyserious>
17:00:29 * ivanm calls out the plumber to jump on top of goomba
17:00:42 <Eelis> goomba: no need to wait, you can just give a fake name.
17:00:52 <goomba> thanks Eelis
17:01:04 <Eelis> the restriction is a just a silly pretense.
17:01:27 <ivanm> Eelis: well, yes; people could have always used a fake real-sounding name
17:01:47 <Eelis> ivanm: and have, as the thread on -cafe revealed.
17:01:54 <ivanm> if they kept quite, then the email discussion/argument/whatever would never have arisen and most of us wouldn't have been the wiser ;-)
17:02:15 <dons> haskell kids these days.
17:02:21 <dons> get off the lawn!
17:03:03 * ivanm looks around and can't see any grass anywhere
17:03:39 <Eelis> the days of innocence are over!
17:03:51 <ddarius> ivanm: That's because of all the kids on the lawn.
17:03:55 <ddarius> They've killed the grass.
17:03:59 <ivanm> oh, right
17:04:09 <ivanm> and here I was thinking because I lived in an apartment in the city
17:04:11 <ivanm> silly me
17:05:00 <Eelis> the absolute low point in the discussion was when some guy implied that the real name policy should be in place because it's what facebook does..
17:05:14 <ivanm> heh, yeah
17:05:36 <Adamant> hi, folks, my name is Ned Ludd.
17:06:03 <Adamant> maybe you've heard of my work with early computing predecessor devices, like looms.
17:06:07 <ivanm> stop lying; /whois says it's THeMonkeyMasters
17:06:14 <interferon> where do i find the "macosx-app" program needed to build wxhaskell binaries on os x?
17:06:27 <Adamant> ivanm: sshhh! you'll wake them up
17:07:14 <ville> I demand real names for IRC
17:07:48 <ivanm> ville: is mine close enough?
17:08:04 <danderson> my name is Guybrush Threepwood.
17:08:12 <danderson> And I'm going to be a pirate!
17:08:13 <ville> I wouldn't know.
17:08:15 <xerox> and I want to be a pirate!
17:08:25 <Adamant> danderson: how appropriate. you fight like a cow.
17:08:29 <Adamant> :P
17:08:37 <xerox> danderson: http://gprime.net/flash.php/youareapirate
17:09:13 <danderson> haha, you're all awesome.
17:09:30 <Eelis> another crazy thing was when paterson first said that he preferred real names, then said he allowed nicknames for privacy reasons, but then rejected my desired nick because it was too much like my real name(!). one wouldn't thought that given his preference, that would be a /good/ thing
17:09:57 <Eelis> *would've
17:10:08 <ville> What would you do with 2 people having the same name if real names were required? Well guess that was brought up
17:10:10 <danderson> which side won what in the real name thing btw?
17:10:31 <Eelis> danderson: nothing changed. the policy remains as it was
17:10:33 <ivanm> danderson: it just petered out
17:10:35 <dons> ville: we add primes
17:10:37 <dons> Sean'
17:10:44 <dankna> dons: hahaha
17:10:47 <ivanm> with malcolmw saying he would allow fake names if people asked
17:10:53 <dons> Guybrush Threepwood is mega awesome
17:11:02 <danderson> Eelis: which is what? Real names only? Only fake names that rhyme with "contravariant" ?
17:11:03 <dons> as long as it is Camel Case, we're good
17:11:04 <ivanm> dons: so I guess we get JohnSmith'''''''''''''''''''''' ?
17:11:21 <ivanm> danderson: it asks for real names, but no-one actually checks
17:11:26 <dons> ivanm: seriously, we had two sean's at UNSW: Sean and Sean'
17:11:26 <ivanm> (that it is your real name)
17:11:27 <danderson> ok.
17:11:29 <dons> you know it makes  sense
17:11:36 <Adamant> dons: that has been done at several CS and math departments
17:11:38 <ivanm> dons: heh
17:11:42 <danderson> which makes sense to me. It's only polite to tell people who is doing things.
17:11:47 <dons> Sean' works at NVIDIA now.
17:12:02 <Eelis> danderson: well, it's hard to say. there are really 3 "policies": (1) the one written on the webpage, (2) the one paterson says he uses, and (3) the one paterson actually uses.  (1) is easy to understand. (2) is hard to understand. (3) is totally random
17:12:03 <danderson> In the blackhat security community, I can understand people calling themselves LordMatrix or epiclol123
17:12:11 <ivanm> I like having a unique name (for AUstralia, anyway): at high school we had 5 Chris', but only 1 Ivan
17:12:14 <dons> dankna: you just have to set up an email address as well, so Ross believes you
17:12:19 <danderson> but it does tend to drag down the tone.
17:12:22 <dons> Guybrush Threepwood at Guybrush.Threepwood@gmail.com
17:12:22 <ivanm> danderson: yeah
17:12:25 * danderson reaches for his glass of white wine
17:12:28 <dons> problem solved.
17:12:47 <dons> hey everyone. it's my 30th birthday today. i've spent 10 years in this community. Thank you all for the fun!
17:12:51 <siracusa> Is there a function for converting a string with a given radix to an Integer somewhere in the standard libraries?
17:12:56 <Adamant> dons: don't tell him about Nicolas Bourbaki.
17:13:03 <danderson> And we wouldn't want to lower the tone now, would we (to be said in an old world british accent)
17:13:16 <Adamant> happy birfday!
17:13:21 <dankna> grats dons.
17:13:24 <dons> we've come a long way from the quiet little channel this was in the beginning
17:13:32 <danderson> dons: well, woot. That's a long time.
17:13:39 <dons> hehe. it *is*!
17:13:40 <Eelis> i'm going to try to get an account as JohnDoe. wonder what excuse paterson will find this time for rejecting me
17:13:43 <dons> but we've built lots of cool thiiiiings
17:14:10 <dons> i'm so glad of the triumph of Cabal over Makefiles.
17:14:20 <gwern> dons: wait, now that I can't use your software. 'never trust anyone over 30'
17:14:20 <ivanm> dons: Happy Birthday!
17:14:32 <dons> and its been interesting to watch hugs disappear, nhc98 disappear. and parallelism become a dominating theme.
17:14:32 <ivanm> so you started participating in the Haskell community on your 20th birthday? :p
17:14:40 <twink> dons: happy birthday
17:14:44 <Adamant> gwern: the people who said that are now in their 70's, you can't trust them either :P
17:14:50 <dons> gwern: damn!
17:14:56 <gwern> Adamant: but they were under 30 when they said it
17:15:03 <Adamant> gwern: but now they're over 30
17:15:07 <dons> ivanm: well, 12 years ago, but full on about 10 years ago
17:15:09 <Adamant> so clearly you can't trust them
17:15:11 <ivanm> dons: I think hugs is still hanging around (scrabbling on top of the cliff face of obsolencense with nails being worn down)
17:15:13 <dons> i used gofer on my mac68k
17:15:13 * gwern feels so young. I can't remember hugs being anything but legacy windows, and nhc98 as being anything but historical
17:15:19 <dons> but ported ghc to the mac68k early on
17:15:24 <dons> ghc 4.06 ?
17:15:27 <gwern> Adamant: well, I can't trust anything they say *now*
17:15:33 * dcoutts_ got Oxford to switch from hugs to ghci for teaching
17:15:34 <ivanm> dons: now, if you were a mathematician, it would be time to get worried...
17:15:41 <dons> dcoutts_: ah the switching days, yes.
17:15:48 <ivanm> since IIRC mathematicians usually do their pivotal work by about 33
17:16:05 <Adamant> ivanm: that's probably changing
17:16:06 <gwern> ivanm: ich bin eine mathematician, thanks to curry-howard
17:16:06 <twink> ivanm: I'm 34, so I'm over-the-hill.
17:16:33 <ivanm> well, that was John Nash's big dilemma...
17:16:39 <dcoutts_> dons: oh, happy birthday :-)
17:16:58 <dons> dcoutts_: isn't yours soon ?
17:17:02 <Adamant> ivanm: they've piled more math on top of the existing math now. takes even longer to become an expert :P
17:17:04 <dcoutts_> dons: June
17:17:17 <ivanm> Adamant: yeah :s
17:17:20 <dcoutts_> dons: but I'll only be 29
17:17:30 <dons> you kids and your stream fusion
17:17:32 <dons> back in my day!
17:17:39 * ivanm 's is soon as well, but he'll be only a sprightly young lad of 24 :p
17:17:44 <dcoutts_> dons: was it steam fusion?
17:17:55 <dons> yeah, it was stream fusion in my day,
17:17:56 <ivanm> dcoutts_: lol
17:18:06 <dons> you got me.
17:18:13 <danderson> and on the mathematician theme, your lifeclock should now be blinking red
17:18:22 <danderson> report to Carrousel for the ceremony.
17:18:25 * dons -> out. found a 30y.o scotch to celebrate with
17:18:31 <dcoutts_> :-)
17:18:40 <Adamant> dons: there are some good 30 year ports as well
17:19:04 <Adamant> as in wine, of course :P
17:19:22 <dcoutts_> I expect 30 is around the first age when one can afford scotch as old as oneself
17:19:30 <dcoutts_> certainly cannot at 10 or 20 :-)
17:19:33 <dankna> haha
17:19:35 <ivanm> hang on, dons is out of it because he drank that much scotch already? :p
17:19:52 <ksf> something light to celebrate the weekend, an explanation what makes monad tutorials bad: http://www.ted.com/talks/david_deutsch_a_new_way_to_explain_explanation.html
17:19:55 <ivanm> dcoutts_: well, _maybe_ 20yo scotch...
17:20:51 * dons remembers all 8 original 3rd party libraries, including ddata
17:20:57 <dons> anyone else remember DData?
17:21:10 <danderson> Dons' Data?
17:21:14 <dons> Daan's.
17:21:20 <dons> including Set and Map
17:21:22 <dcoutts_> ah of course
17:21:30 <ksf> I could've easily afforded 15-yo wiskey with 15
17:21:32 <mreh> david deutsch believes in things he can't prove to exist, yet he is an atheist... I find this confusing
17:21:42 <Cale> mreh: eh?
17:21:43 <ksf> but then, I was coke-addicted at that time.
17:21:46 <dcoutts_> dons: I think I removed copies of them from c2hs just a couple years ago
17:21:50 <FliPPeh__> @hpaste
17:21:50 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
17:21:50 <mreh> Cale: multiple universes
17:21:57 <ivanm> ksf: as in cola or cocaine?
17:21:57 <dons> dcoutts_: hehe
17:22:05 <ksf> as in cola
17:22:07 <Cale> mreh: They do "exist", mathematically.
17:22:10 <danderson> mreh: faith and theism are not identical sets
17:22:16 <ivanm> mreh: heh
17:22:17 <Cale> mreh: Which is the only kind of existence that actually matters ;)
17:22:36 <mreh> Cale: so you don't fly then?
17:22:41 <Cale> hm?
17:22:56 <FliPPeh__> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=9604#a9604 - I will have to do that for about 7 such fields, and another record has over 20 of those.. how can I remove this boilercode?
17:23:03 <FliPPeh__> It looks bad and is inefficient
17:23:09 <FliPPeh__> But it was the best I could come up with
17:23:11 <ksf> also, my dad got me off alcohol for a long time. he allowed me to taste beer at the age of 5.
17:23:22 <mreh> Cale: I'm just joshing ya, I was thinking about how planes can't mathematically fly yet
17:23:24 <ksf> never touched the stuff again for 12 years or so.
17:23:41 <dolio> What kind?
17:23:56 <ivanm> FliPPeh__: do what?
17:23:58 <ksf> wasn't that bees?
17:24:03 <ksf> as in they're too heavy
17:24:10 <gwern> ksf: funnily enough, same thing happened to me
17:24:12 <ksf> and we don't know anything about turbulence dynamics.
17:24:16 <Saizan> FliPPeh__: seems like you want to rewrite that with a ReaderT Maybe monad
17:24:22 <Cale> Well, if you're just referring to the quantum sort of multiple universes, then it's really nothing to worry about. Basically, it's just the natural way to picture the formal sums of states which arise in quantum mechanics.
17:24:22 <ivanm> ksf: I've heard of some thing about how the whole wing curvature thing can't actually be explained...
17:24:31 <FliPPeh__> ivanm: "fieldName = extract [fieldNameInObject] ....."
17:24:38 <FliPPeh__> For every single one, repeating over and over again
17:24:42 <mreh> Cale, I thought it was just an interpretation?
17:24:43 <Cale> Of course all observables in QM are linear operators, and split up over that sum
17:24:46 * edwardk1 waves hello,
17:24:48 <FliPPeh__> Unwrapping every single one out of the Maybe
17:24:58 <ivanm> FliPPeh__: use the lenses library or something?
17:24:59 <mreh> like the cat splits into two parallel cats
17:25:04 <FliPPeh__> :/
17:25:17 <kmc> FliPPeh__, look at lenses, data-accessor, and fclabels
17:25:26 <kmc> that may help some
17:25:27 <ivanm> FliPPeh__: or write a function that is fromJust . extract . (:[]), and then map it over a list of strings?
17:25:28 <mreh> *psst we should go to -blah*
17:25:33 <ivanm> won't turn it into a tuple though
17:25:41 <gwern> FliPPeh__: in the interim, start factoring out. you can factor out, as ivanm says, fromJust . extract
17:25:48 <edwardk> preflex: xseen dons
17:25:48 <preflex>  dons was last seen on freenode/#haskell 3 minutes and 51 seconds ago, saying: dcoutts_: hehe
17:25:49 <ivanm> kmc: ahhh, they're the other ones I was trying to remember the names of
17:25:57 <ivanm> edwardk: he's busy drinking 30yo scotch
17:26:00 <gwern> FliPPeh__: then ponder how you would map a function on each part of an ADT like Status
17:26:01 <edwardk> haha
17:26:06 <kmc> in order to go between record labels and strings for the dynamic JSON keys, you'd need something template haskelly
17:26:57 * gwern finds whiskey disgusting
17:27:47 <edwardk> fclabels has the appropriate TH goodness
17:28:19 <Twey> gwern: That's okay
17:28:24 <Twey> gwern: I'll have your share
17:28:24 * ivanm finds ethanol disgusting
17:28:44 <dolio> Methanol is way better.
17:28:54 <mreh> no it isn't
17:28:57 <gwern> wine is fine. mead is great. I like plum wine a fair bit. but whiskey, beer - man. I wonder how people can acquire those tastes
17:29:14 <Twey> Beer I don't get
17:29:20 <ksf> depends on the wine
17:29:21 <Twey> But whiskey is pleasant
17:29:21 <edwardk> gwern: if you knock enough back you stop caring what it tastes like
17:29:28 <dolio> There's lots of different beer.
17:29:40 <ksf> it absolutely musn't be too sweet. I can't stand merlot, for example.
17:29:58 <gwern> I've tried about 10 microbrews running the light-dark gamut, and some regular beers. none of them seem much better than another
17:30:12 <dolio> I'm a fan of really dark stouts, with lots of chocolate and coffee flavors.
17:30:28 <ksf> there is only one beer: http://www.jever.de/index_jever_website.jsp
17:30:39 <dolio> Not so much Miller Light.
17:32:02 <ivanm> ksf: I know a lot of people that argue that this is the only real type of beer: http://en.wikipedia.org/wiki/XXXX#XXXX_Gold
17:32:42 <ivanm> does anyone recall where that new darcsum version could be obtained?
17:32:54 <gwern> teh internets
17:32:56 <dolio> Is 16 the drinking age in Germany?
17:33:10 <ivanm> gwern: wow, you're so unimagibaly helpful!
17:33:14 <pikhq> gwern: Clearly you should use different ethanol sources.
17:33:19 <ivanm> dolio: it is in east europe...
17:33:30 <pikhq> Perhaps denatured?
17:33:36 <gwern> ivanm: my praises are sung daily in my temple
17:33:56 * gwern hums one of the hymns: darcs get http://joyful.com/repos/darcsum
17:34:07 <ivanm> uggh, it's only available in the darcs repo :s
17:34:37 <gwern> ivanm: well, it's not exactly suitable for hackage
17:34:41 <gwern> shesh
17:34:42 <ivanm> well, no
17:34:58 <ivanm> but there are various other places it would be suitable to put a released version up on
17:35:07 <ksf> the only aussie beer I know is fosters
17:35:20 <ksf> ...and I must say, it's the best lemonade-beer there is.
17:35:27 <dolio> Fosters is their word for beer, right?
17:35:32 <mreh> ksf: shandy?
17:35:41 <mreh> is this #haskell-beer?
17:36:02 <gwern> no, this is madness!
17:36:08 <ksf> nope. shandy would be alster water.
17:36:09 <ivanm> ksf: no-one in AUstralia drinks fosters
17:36:24 <ivanm> ksf: actually, I take it back; my dad drank it once when the only other option was VB
17:36:24 <dolio> There's a shocker.
17:36:25 <ksf> lemonade-beer are those light, quite sweet beers
17:36:38 <ksf> like the american budweiser
17:36:45 <ksf> (the czech is ok)
17:36:46 <mreh> shandy is lemonade and beer
17:36:57 <ksf> so is alsterwasser
17:37:12 <ksf> ...but you can have beer that resembles lemonade more than anything else, too.
17:37:22 <aavogt> you people explain beverages as well you do monads
17:37:48 <mreh> i used to make beer with lemonade and apple juice when I was a child
17:37:54 <mreh> "beer"
17:37:55 <ksf> beck's is also too far to the lemonade side of the scale
17:38:04 <gwern> aavogt: with really awesome metaphors, you mean?
17:38:08 <mreh> there is no "lemonade" scale!
17:38:18 * picaflor lol
17:38:58 <aavogt> gwern: more or less
17:39:27 * ivanm figures he should probably get off his computer and go do stuff like he's meant to
17:40:31 <Twey> dolio: 16 is the drinking age throughout most of Europe.
17:40:55 <dolio> I feel so oppressed.
17:41:15 <ksf> ...for beer and wine, that is.
17:41:24 <ksf> it's 18 for hard stuff.
17:41:45 <Twey> Aye
17:41:46 <ksf> one of the sanest things about german law is that you're allowed to drink _before_ you're allowed to drive.
17:42:05 <Twey> In England, at least, we're allowed to drink before sixteen, under appropriate supervision
17:42:15 <ksf> that, too.
17:42:16 <chrisdone> here you can have sex before purchasing alcoholic drinks
17:42:19 <Adamant> ksf: you can't blame Budweiser on us anymore, the Belgians own it now
17:42:20 <dolio> Well, I think that's technically true in the US, as well.
17:42:31 <Twey> (on private property with the supervision of an adult, or in public licensed premises with a meal and an adult)
17:42:41 <Adamant> drinking under supervision varies by state
17:42:44 <ksf> and they recently put an insane tax on mix bewerage that diluted the alcohol taste with much sugar.
17:43:04 <mreh> they;r
17:43:09 <Twey> We're getting an added cider tax :-\
17:43:18 <mreh> typing in the dark...
17:43:26 <mreh> good night
17:43:28 <Adamant> legal age on drinking alone is uniform due to everyone taking road tax money and the Feds making 21 a requirement due to lobbying
17:43:40 <Eelis> hm, is hsc2hs not compatible with UnicodeSyntax ?
17:43:43 <chrisdone> ksf: yeah, my dad got some beck's in and it didn't taste of anything, just generic beer flavour. budweiser is as bland (personally)
17:44:08 <Adamant> Beck's is not good German beer just like Bud isn't good American beer
17:44:32 <ksf> heh. back when I was 6 or 7 or such, we went on holidays to bavaria. I ordered a http://en.wikipedia.org/wiki/Malt_beer , the waitress looked asking at my parents, who were a bit confused, and nodded.
17:44:47 <ksf> it turns out that my dad had to drink the beer, because it was actual _alcoholic_ beer.
17:44:48 <chrisdone> now, Tyskie and Tuborg, those are my favourites
17:44:52 <ksf> but that's the bavarians for you.
17:45:12 <ksf> one liter of beer is not alcohol, legally, there.
17:45:37 <aavogt> ksf: no those drinks have negligible alcohol
17:45:46 <aavogt> they are for training children to like beer
17:46:01 <edwardk> woot, ezyang arranged space for the next bostonhaskell!
17:46:03 <ksf> I still love malt beer
17:46:37 <ksf> ...and they are, legally, alcohol-free.
17:46:38 <gwern> Eelis: lots of haskell stuff isn't compatible. hlint for example was only just fixxed
17:46:45 <ksf> which means as much alcohol content as may be in marmelade.
17:46:54 <Adamant> ksf: heh. reminds me of how pre-1898 guns aren't actually 'guns' in that the ATF (government bureau that does firearm stuff) can't consider them firearms or treat them as such.
17:47:00 <Eelis> gwern: ok, then i'll look for a bug report and file one if there isn't one already
17:47:05 <gwern> Adamant: they're antiques
17:47:18 <gwern> Adamant: kind of like how machine guns get grandfathered in
17:47:43 <Adamant> gwern: yeah, except the later ones are basically the same as a modern bolt action rifle they could regulate.
17:49:02 <Adamant> I did like the just barely alcoholic lemonade the Brits have.
17:49:52 <Eelis> wow, the hsc2hs cabbage is from 2006
17:49:57 <chrisdone> what's that?
17:50:11 <Adamant> it has as much alcohol as 'non-alcoholic beer' or whatever
17:50:17 <gwern> sounds like a twee package system name
17:50:34 <gwern> why *are* coders so terrible at terminolgy?
17:50:35 <chrisdone> Adamant: oh, you mean Shandy?
17:50:46 <benmachine> I thought the alcohol there was sort of incidental
17:50:48 <chrisdone> I used to drink that at school ^_^
17:50:50 <benmachine> as part of the production process
17:51:01 <Twey> 01:44:23 < ksf> it turns out that my dad had to drink the beer, because it was actual _alcoholic_ beer.
17:51:04 <Adamant> chrisdone: dunno, the brand name was Fentamen's or something
17:51:11 <chrisdone> http://en.wikipedia.org/wiki/Shandy
17:51:17 <ksf> ...the one that the waitress brought, yes.
17:51:17 <Adamant> I didn't think it was shandy
17:51:19 <aavogt> ghc comes with a hsc2hs
17:51:21 <Twey> ksf: My grandmother would give the kids a shot of brandy to get them to sleep…
17:51:21 <benmachine> Adamant: oh I get those
17:51:25 <benmachine> fentiman's
17:51:30 <Adamant> yeah, that's it
17:51:30 <benmachine> they are pretty awesome
17:51:32 <Twey> (from age five or so)
17:51:43 <Adamant> benmachine: yeah, there's not enough liquor to really do anything
17:51:54 <benmachine> Adamant: it's not alcoholic except incidentally
17:51:58 <benmachine> well, hmm
17:52:04 <benmachine> they might do alcoholic stuff I don't remember
17:52:04 <chrisdone> Twey: haha, my great gran used to do that
17:52:16 <Adamant> benmachine: yeah, it's just barely, at least the stuff I had
17:52:21 <benmachine> I recall "not more than 0.5% by volume" which is legally low enough to be accidental
17:52:48 <Adamant> ah, so it probably is a shandy
17:53:04 <ksf> you certainly don't feel or taste any of that alcohol, even as a small kid.
17:53:07 <Adamant> they called it a "Victorian lemonade' and I thought that was the actual product category
17:53:07 <chrisdone> I remember drinking Shandy at college. I used to have it with my dinner every day. then one day a stupid teacher shouts at me for drinking an alcoholic drink and threatens to have my suspended if I don't throw it away
17:53:32 <Twey> Heh
17:53:48 <ksf> the shandy around here is 50/50 lemonade and pilsner
17:53:58 <ksf> that's above 0.5%
17:54:13 * hackagebot hledger-lib 0.9 - Core types and utilities for working with hledger (or c++ ledger) data.  http://hackage.haskell.org/package/hledger-lib-0.9 (SimonMichael)
17:54:13 <benmachine> yeah shandy is an actual alcoholic drink
17:54:15 * hackagebot hledger 0.9 - A command-line (or curses or web-based) double-entry accounting tool.  http://hackage.haskell.org/package/hledger-0.9 (SimonMichael)
17:54:20 <benmachine> you don't need ID to buy fentiman's lemonade
17:54:33 <chrisdone> you don't need ID to buy shandy here
17:54:37 <ksf> it's a nice thing to drink when you do bike tours.
17:55:14 <sm> woohoo.. did that release in record time
17:55:37 <gwern> didn't realize people kept track
17:55:39 <sm> I know there will be no problem reports :)
17:56:27 * gwern muses morosely about xmonad's slow release cycle and apathy about reviewing patches
17:56:33 <Eelis> is there perhaps some shortcut for a view pattern of the form   p -> True   ?
17:56:35 <gwern> followthrough. haskellers have no followthrough
17:57:14 <ksf> Eelis, yes, a pattern guard
17:57:27 <Eelis> ksf: but that requires giving the thing a name, which is what i'd like to avoid
17:58:02 <benmachine> it's already quite short
17:58:07 <gwern> sm: it's all great when the bloom is on the rose and in the eager night you thrust through release after release; but what happens in years to come, when hledger starts gaining weight and you're tired of her and the kids?
17:58:17 <gwern> Eelis: are you allowed _ in view patterns?
17:58:24 <sm> gwern: a very good question
17:58:29 <Eelis> benmachine: sure, it just feels like the classical noob mistake of making a condition of the form   yadayada == True   :)
17:58:36 <Eelis> gwern: i don't know
17:58:46 <benmachine> Eelis: I think that's the best you can do
17:58:50 <ksf> Eelis, maybe back off a stuff and do conditional function application?
17:58:52 <benmachine> you are allowed _ in view patterns
17:58:52 <Eelis> benmachine: ok, thanks
17:58:55 <benmachine> not sure what good it would do
17:58:57 <sm> I wrote in haskell because I feel she'll age better
18:00:06 <ksf> case foo of _ | foobar ->
18:00:11 <aavogt> Eelis: choose a shorter constructor name?
18:00:11 <gwern> "I'm still the same hledger I always was! i'll change for you! just darcs pull --tag=0.1 and it'll be like before!' but you'll turn away without any reply - a dagger through her heart
18:00:32 <Eelis> aavogt: Bool's constructor names aren't for me to choose, i'm afraid :)
18:00:32 <benmachine> aavogt: data B = F | T?
18:00:36 <sm> stop it, you're depressing me! :)
18:00:39 <gwern> chrisdone: it is easier to write incorrect code than to understand correct
18:00:47 <benmachine> Eelis: you could define your own bool type!
18:00:56 <Eelis> benmachine: :|
18:00:57 <benmachine> it would save you possibly as many as three characters
18:01:02 <aavogt> haha
18:01:05 <ksf> it's easy to write working code you don't understand.
18:01:09 <ksf> just follow the types.
18:01:29 <aavogt> but seriously, the redundancy isn't there when you use pattern guards
18:01:33 <benmachine> write the code, work out what it does, and then write a spec to match
18:01:43 <siracusa> > let x = 5 in (+) 0x
18:01:44 <lambdabot>   5
18:01:59 <gwern> chrisdone: I suppose I can't complain though, since I do get contributions for mueval
18:02:00 <chrisdone> gwern: haskell code is notably easy to hack on in my personal experience. I love that about it
18:02:01 <Eelis> aavogt: again, a pattern guard would require giving the thing a name, which is even worse
18:02:35 <aavogt> names aren't that expensive
18:02:43 <Eelis> they are!
18:02:50 <gwern> chrisdone: well, assuming everything was designed well. I just gave up on adding some sorting routines to goerzen's datapacker because too many lists and tuples and failure cases
18:02:58 <ksf> haskell is mindboggingly easy to refacto
18:03:06 <ksf> ...IFF you already know haskell
18:03:10 <chrisdone> gwern: well I'll be merging mine with yours tomorrow. my changes were pretty mental so I'll have to refactor it
18:03:16 <ksf> (and got pl and unpl at your side)
18:03:27 <Eelis> ksf: except when you need to make something that was stateless stateful. then you almost have to rewrite all the code
18:03:41 <aavogt> gwern: but lists and tuples are simple!
18:03:56 <gwern> ksf: and you understand the type hierarchy! yi was unspeakably painful before by trial and error I began figuring out how the EditorM YiM IO monads interacted
18:04:20 <chrisdone> yeah I remember reading the yi source when I was first learning haskell and boggling
18:04:20 <gwern> aavogt: but when everything is lists and tuples...
18:04:46 <aavogt> gwern: so that documentation about those monads in yi is due you?
18:04:50 <ksf> I started out with happstack, changing stuff randomly to stumble across enlightening type errors.
18:05:11 <syntaxglitch> ksf: Someone has claimed that any Haskell that type checks does something meaningful, even if you don't know what it is
18:05:19 <syntaxglitch> I don't really buy that in the general case though
18:05:21 <gwern> aavogt: I have more than once gotten my script to look right and typecheck - and be utterly wrong because somewhere in the nested lists something get returned when it needed to stay the same and everything got inferred to something else
18:05:49 <ksf> if the types involved are specific enough, that's true.
18:06:12 <orlandu63> ls
18:06:13 <ksf> ...you can do a lot of function of type State () that just aren't useful, at all.
18:06:13 <aavogt> but at some point you have to design the types
18:07:02 <aavogt> at least in practice
18:07:16 <syntaxglitch> ksf, I dunno, I think it's the other way around
18:07:18 <chrisdone> my first non-haskell-tutorial (non-YAHT-exercise to be specific) haskell program was a connect four AI that used weighted decisions. oh how I struggled against the type errors for that project
18:07:26 * chrisdone coming from scheme
18:07:32 <syntaxglitch> I could be convinced that any fully polymorphic code that typechecks does indeed do something interesting
18:08:09 <syntaxglitch> also excluding any cheating polymorphic types, like (Num a => a)
18:08:44 <aavogt> impredicative?
18:09:04 <ksf> what certainly is true is that any applicative or monad instance that a) typechecks and b) uses every parameter is a valid monad instance
18:09:25 <ksf> ...at least I never came across an invalid one, that way.
18:09:28 <aavogt> you write lawbreaking monad instances, ksf?
18:09:29 <chrisdone> ksf: what about the laws??
18:09:41 <ksf> you might come across the wrong instance, though.
18:09:44 * chrisdone points at the heathen
18:10:31 <ksf> the chances not to obey the laws are quite low.
18:10:42 <benmachine> there ar eplenty
18:10:52 <syntaxglitch> what would be a lawless instance of functor or applicative, anyway? that seems fairly hard to create while still typechecking
18:10:53 <benmachine> you can make a lawbreaking Functor []
18:11:07 <syntaxglitch> though I guess applicative as zipWith on [] would be a good example
18:11:09 <aavogt> one that empties the list
18:11:11 <benmachine> fmap f (x:xs) = f x : f x : fmap f xs is the easiest way
18:11:18 <benmachine> aavogt: that uses every parameter
18:11:26 <ksf> how would zipWith be invalid?
18:11:38 <syntaxglitch> ksf, lists of different lengths
18:11:47 <ksf> benmachine, but it's also obviously worng.
18:11:53 <aavogt> uses in which sense?
18:12:08 <SamB_XP> how about fmap f = reverse . map f
18:12:10 <aavogt> as in the value is forced without seq?
18:12:23 <syntaxglitch> well, what about a lawless instance for a non-recursive type?
18:12:27 <benmachine> ksf: so we're looking for subtly wrong instances?
18:12:30 <syntaxglitch> [] is pretty easy to break, I guess
18:12:54 <benmachine> there was a Monad ZipList that worked iff the lists involved were the same length
18:12:59 <SamB_XP> can't really do it for Maybe or Id ...
18:13:01 <aavogt> also, fmap could be lazy?
18:13:15 <aavogt> with   fmap id /= id
18:13:48 <SamB_XP> @type [fmap, lazy]
18:13:49 <lambdabot> Not in scope: `lazy'
18:13:51 <SamB_XP> aww
18:14:18 <aavogt>   fmap f Nothing = Just undefined; fmap f (Just a) = Just (f a)
18:14:26 <syntaxglitch> zipWith would be a valid <*> on nonfinite lists, wouldn't it?
18:14:38 <aavogt> though this one is disqualified due to the non-use of f in the first equation?
18:14:59 <SamB_XP> aavogt: disqualified for using undefined!
18:15:21 * aavogt uses undefined safely
18:15:26 <aavogt> just not there
18:15:27 <SamB_XP> the real one can't use f in the first one either
18:16:09 <aavogt> who said the real instance meets the criteria of obviously correct instances anyways?
18:16:29 <SamB_XP> well, it ought to ...
18:16:33 <SamB_XP> it's so damn simple!
18:16:40 <syntaxglitch> let's keep it family-friendly now, and not have bottoms hanging out everywhere
18:17:12 <ksf> ...should I add that the code must not exhibit the hoare property, but it also must not defy it?
18:17:14 <benmachine> aavogt: the real instance doesn't use f in that one anyway >_>
18:17:25 <ksf> *doesn't need to
18:17:31 <ksf> (the first one)
18:18:34 <aavogt> you let this hoare tell you what to think?
18:19:52 <aavogt> ksf: what is that restriction anyways?
18:20:30 <ksf> the hoare property or the rule for the instance code?
18:21:05 <ksf> code exhibits the hoare property if it contains obviously no bugs, instead of containing no obvious bugs.
18:21:39 <ksf> my claim was that the latter property is usually enough for instances.
18:21:54 * bremner wonders how people with screen readers interpret the hoare property
18:21:55 <ksf> if it's not, you've got a really, really interesting bug
18:22:58 <aavogt> ksf: so instances that break those laws are interesting?
18:23:32 <ksf> it's not interesting to create them, but they're very, very interesting bugs to debug.
18:24:41 <syntaxglitch> interesting in the sense that "may you live in interesting times" is a curse, I take it
18:25:02 <ksf> well put.
18:25:45 <benmachine> I remember parsec's return used to be excessively strict so that return undefined >> x was not equal to x
18:25:48 <benmachine> does that count
18:25:58 <danderson> well, that can't be good
18:26:06 <ksf> ...the most fun part about haskell is precisely that the bugs you get are way more interesting than in dysfunctional languages
18:26:12 <BlackM> "pbviously contains"... :)
18:26:12 <danderson> I boot my daemon, after not hacking on it for very long
18:26:22 <danderson> first thing it prints when it boots is "Boom!"
18:26:28 <benmachine> heh
18:26:30 <danderson> and I can't remember why it does that...
18:26:51 <BlackM> Bah! "obviously contains no bugs, instead of...". :)
18:28:25 <syntaxglitch> "There are two ways of constructing a software design: One way is to make it so simple that there are obviously no deficiencies, and the other way is to make it so complicated that there are no obvious deficiencies. The first method is far more difficult." -- C. A. R. Hoare
18:28:34 <syntaxglitch> ...in case anyone was curious about the original quote
18:29:22 * syntaxglitch is currently working on some code that is very certainly of the second variety
18:29:26 <dobblego> > getZipList ((+) <$> ZipList [1,2,3] <*> ZipList [100..])
18:29:27 <lambdabot>   [101,103,105]
18:30:03 <Twey> :t getZipList
18:30:04 <lambdabot> forall a. ZipList a -> [a]
18:30:08 <Twey> This seems backwards to me
18:30:19 <aavogt> @src ZipList
18:30:19 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
18:30:36 <dobblego> newtype ZipList a = ZipList { getZipList :: [a] }
18:30:40 <DigitalKiwi> why is dobblego ctcping me?
18:30:46 <danderson> hmmkay, my router doesn't work that well :)
18:30:57 <dobblego> DigitalKiwi, sorry I meant to ping myself (di<tab>)
18:31:14 <danderson> as soon as something non-virtual connects to it, an infinite routing loop starts building up until memory exhaustion
18:31:22 <syntaxglitch> tab completion never does what you hoped in a channel this crowded...
18:31:32 <DigitalKiwi> lmao
18:31:47 <DigitalKiwi> i suppose i and o are somewhat close
18:32:08 <dobblego> DigitalKiwi, I meant to ping dibblego
18:32:18 <Twey> Nah.  The only vowel further from ‘i’ than ‘o’ is ‘a’.  ☺
18:32:19 <DigitalKiwi> oh
18:32:29 <DigitalKiwi> ok that makes a little more sense ;p
18:34:11 <gwern> hlint now catches haskell98 imports
18:34:22 <gwern> huzzah to ndm - for thine is the kingdom, the power, and the glory!
18:38:27 <ksf> Twey, ы
18:39:23 <gwern> Gracenotes: good luck with your SoC app
18:51:23 <FliPPeh__> Is there something like a polymorphic "unwrap"?
18:51:46 <ksf> fromDynamic?
18:51:47 <FliPPeh__> Since I have "JString \"blah\"", "JNumber 5.43223", "JList [...]"
18:51:54 <FliPPeh__> I just want the inner parts
18:52:05 <ksf> as what?
18:52:13 <FliPPeh__> As themselves
18:52:16 <FliPPeh__> That's the problem
18:52:25 <FliPPeh__> Well no, let's make it strings
18:52:30 <FliPPeh__> They'll be used for "read" anyways
18:52:41 <ksf> fmap show over the data
18:52:47 <dankna> class Wrappable a where unwrap :: a -> String
18:52:54 <dankna> or that
18:53:20 <FliPPeh__> ksf: That just maps it INSIDE them
18:53:38 <syntaxglitch> note that just because a type constructor looks like "Wrap a" doesn't mean that the data constructor looks like "Wrap a"
18:53:40 <FliPPeh__> I want "unwrap' (Just 5) == 5"
18:53:46 <FliPPeh__> But not for "Just" only
18:53:52 <syntaxglitch> getting something out requires pattern matching, because the type alone doesn't really tell you anything about what's in there
18:54:06 <FliPPeh__> So there's no really smart way to do it?
18:54:09 <FliPPeh__> Meh.
18:54:14 <ksf> if nothing else, you can derive those things with TH
18:54:18 <bremner> define a typeclass?
18:54:24 <syntaxglitch> what would unwrap do with "data Phantom a = Phantom"?
18:54:27 <bremner> make lots of instances :)
18:54:32 <ksf> there's some libraries to write deriving functions.
18:54:32 <syntaxglitch> is it supposed to find an "a" somewhere?
18:55:00 <aavogt> what's wrong with plain    read :: String -> [JValue] ?
18:55:45 <aavogt> syntaxglitch: then make a list of all the types to try, and return the first one that actually parses
18:56:03 <aavogt> that kind of defeats the purpose of using a typeclass though...
18:56:17 <aavogt> other than taking advantage of deriving (Read)
18:56:37 <syntaxglitch> FliPPeh__, the smart way is with generics/metaprogramming of some sort; either magic instance-deriving that lets you deconstruct, or TH to generate boilerplate unwrap functions, or whatever
18:57:26 <FliPPeh__> hmm
18:59:27 <syntaxglitch> generally speaking, the type system alone can only manipulate types and type arguments; nothing you can do with type classes or such will let you get at term arguments to data constructors except via instance functions
19:00:42 <syntaxglitch> with the addendum that GHC's extended automagic deriving makes it easier to not have to write your own instance functions
19:04:24 <Philonous> FliPPeh__: I think what you want is called generic programming. There are libraries for that ("scratch your boilerplate" aka "syb" for example). They work by pulling the types down into the run time representation via type classes.
19:08:12 <aavogt> scrap your boilerplate
19:08:37 <Philonous> Uhh, yeah, sorry
19:14:58 <aavogt> otherwise it might be a bit hard to find :)
19:26:35 <Gracenotes> gwern: thanks!
19:29:08 <gwern> Gracenotes: the language is a little chatty, and it could use some more technical details
19:30:18 <Gracenotes> gwern: heh, that sounds about right. there aren't many technical details to go into until I become thoroughly familiar with the hackage-server codebase though
19:30:34 <gwern> Gracenotes: you could at least try
19:31:37 <Gracenotes> do, or do not? hm. I'll do some more reading, and if the haskell gsoc headquarters asks me for details, I'll oblige to my bestest
19:32:58 <Gracenotes> it is true that I'm not saving the world -- I'm improving a codebase. You mean technical details about the improvements itself then
19:33:06 <Gracenotes> *themselves
19:34:04 <gwern> yes
19:34:16 <gwern> lots of generalities in your doc
19:35:21 <aavogt> would it make sense for hackage to do openid?
19:35:30 <aavogt> somebody has already done stuff for that...
19:35:45 <SamB_XP> provider or consumer?
19:35:48 <Gracenotes> gwern: I do see places where I could have better translated the idea in my head to something precise
19:35:50 <c_wraith> hackage doesn't really do much auth at the moment
19:35:56 <gwern> I heard bad things about openid's security
19:36:06 <SamB_XP> gwern: really?
19:36:11 <Gracenotes> gwern: and it probably comes off as vaporware-y as a result
19:36:11 <c_wraith> gwern: openid's no worse than the rest of the web.  by the way, the web is horrible.
19:36:26 * c_wraith might be on the openid spec author list
19:36:28 <SamB_XP> probably openid is better than much of the web
19:36:36 <Gracenotes> but, yeah, first year, I'll think again for future years if applicable
19:37:00 <c_wraith> I'm not sure *why* I'm on the spec author list, as all my contributions were totally changed...  But I'm on there anyway
19:37:16 <SamB_XP> c_wraith: you contributed to the PROCESS, I guess
19:37:35 <c_wraith> I contributed more to the openid 1 spec than I did to the 2 spec, but 2 is the one with my name on it
19:37:44 <SamB_XP> oh?
19:38:57 <c_wraith> I was largely responsible for the removal of several unenforceable clauses in the pre-1.0 spec.   Mostly because of my arguments that "this can't be enforced, so we shouldn't expect it to be honored"
19:39:28 <gwern> 'make no un-enforceable laws', eh
19:39:49 <c_wraith> not at the protocol level, anyway.  we leave those for the contract level! :)
19:43:10 <c_wraith> anyway.  the biggest potential problem with openid is that you can claim it trains people to fall victim to phishing attacks.  But since there are technical mitigations of that which are massively ignored by the populace, it's clear that no one thinks phishing is a problem that needs fixing.
19:43:40 <SamB_XP> c_wraith: why do you think it trains people for that ?
19:44:00 <SamB_XP> or, how is the case made?
19:44:37 <c_wraith> SamB_XP: it trains people that when they click on a link, they will be taken to a page that may ask them to authenticate.  if they use username/password, it can easily be phished.  extra-easily, since using openid even tells the attack site what site to fake a login page for.
19:45:05 <c_wraith> I'm a big fan of ignoring the problem and using client certs.  Can't phish them.
19:45:05 <SamB_XP> c_wraith: but I'm ALREADY LOGGED IN
19:45:59 <c_wraith> SamB_XP: really?  you never get logged out of a website randomly?  google logs me out for no apparent reason at least once a week.  myspace trained people to expect to be logged out randomly every few minutes..
19:46:23 <SamB_XP> c_wraith: well, I probably logged back in from a non-phishy site though
19:47:09 <SamB_XP> or possibly it's launchpad, and who's gonna fake that?
19:47:25 <c_wraith> You can do a lot of things to mitigate the risk, but it *is* an increased risk, in terms of training users to be insecure, potentially.  At least, as long as no one uses anything better than passwords for auth.
19:47:44 <SamB_XP> well, I think it's way better than passwords for every site
19:47:57 <c_wraith> Oh, I think OpenID is fine.
19:48:03 <SamB_XP> because probably people are going to use the SAME password all the time anyway
19:48:14 <c_wraith> People who fall victim to phishing attacks via it are going to fall victim to the same attacks anyway.
19:48:44 <SamB_XP> did you read the one about "we security 'experts' are wrong, the users are right; most security tips are effectively useless!"
19:49:09 <SamB_XP> @google externalities users passwords
19:49:11 <lambdabot> http://research.microsoft.com/en-us/um/people/cormac/papers/2009/solongandnothanks.pdf
19:49:11 <lambdabot> Title: So Long, And No Thanks for the Externalities: The Rational Rejection of Security ...
19:49:17 <SamB_XP> that one is it all right
19:49:30 <SamB_XP> it wasn't bad
19:49:51 <SamB_XP> only it made me feel almost like an idiot for bothering to read it ;-P
19:50:18 <c_wraith> It's pretty much true.  I still have to wonder why client certs didn't catch on.  I guess people really hated having to create a cert on each computer?
19:50:21 <SamB_XP> wasting so much time on something I had so little to gain from and so much time to potentially waste on
19:50:46 <SamB_XP> c_wraith: I think it's more that nobody has a clue how to make them
19:51:01 <SamB_XP> the software isn't that widely known and hasn't historically been very widely available
19:51:27 <c_wraith> browsers have supported auto-genning them for at least 5 years.
19:51:34 <SamB_XP> hmm
19:51:40 <c_wraith> probably a lot longer than that.
19:51:46 <c_wraith> But that's a well-kept secret
19:51:47 <SamB_XP> well, sites have been not supporting them for so long
19:51:55 <SamB_XP> nobody knows they EXIST
19:52:03 <SamB_XP> except us
19:52:54 <c_wraith> anyway, off to watch other people play while I suffer in misery with this cold.
19:53:10 <SamB_XP> and then there's probably the fact that most people associate x509 with pain
19:53:23 <SamB_XP> regardless of whether they actually know what it is or not
19:59:24 <Gracenotes> gwern: any areas of the proposal that could have particularly used the touch of an overmeticulous engineer, by the way?
20:01:02 <gwern> Gracenotes: dunno. I've forgotten everything about it
20:01:02 <gwern> (something about hackage)
20:01:16 <Gracenotes> that's the kind of high-impact proposal it is
20:01:36 <SamB_XP> openid maybe ?
20:02:06 <aavogt> I don't recall build reporting being involved
20:02:29 <aavogt> how to summarize opt-in anon build logs for people
20:02:43 <aavogt> filtering out people who just have broken systems
20:02:47 <Gracenotes> hm, being involved where? the functionality is implemented in Cabal.
20:03:05 <Gracenotes> but, right, there are details for what that I could explain in great technical detail
20:03:11 <aavogt> Gracenotes: well that information could be summarized on hackage
20:03:26 <aavogt> I'd trust those more than user comments
20:03:57 <Gracenotes> s/what/that/. the idea is aggregating the data, seeing which combinations are bad
20:04:26 <Gracenotes> I'll have to spend some time working on the auth system, and OpenID integration.. I think there's something on hackage for that?
20:04:40 <aavogt> right. I don't know how that relates to Cabal
20:05:05 <SamB_XP> aavogt: that doesn't really
20:05:06 <aavogt> for all I know, cabal-install already has the ability to send logs
20:05:14 <SamB_XP> doesn't it?
20:05:21 <SamB_XP> I'm pretty sure it does.
20:05:21 <Gracenotes> it does
20:05:46 <aavogt> but the stuff to get meaningful information out of people's uploads isn't done yet
20:06:01 <Gracenotes> about auth: even with OpenID, there's still some extra data to store about each user, and plus anyone with OpenID probably shouldn't be able to upload a package at any time
20:06:11 <Gracenotes> the spam issue
20:06:20 * ManateeLazyCat pasted "TH success, haha." at http://paste2.org/get/766078
20:06:21 <ManateeLazyCat> aavogt: Wow, i success. Above i use `unpackVariant` replace `unpackDaemonSignalArgs'`, works perfect, thanks!
20:06:36 <Gracenotes> aavogt: cabal-install/Distribution/Client/BuildReports and hackage-server/Distribution/Server/BuildReport
20:06:58 <aavogt> so that's done?
20:07:06 <ManateeLazyCat> aavogt: Yes,
20:07:10 <ManateeLazyCat> unpackTest = $(unpackVariant ''DaemonMember ''DaemonSignalArgs)
20:07:30 <ManateeLazyCat> aavogt: Just use `fromVariant` replace `fromDynamic`.
20:07:40 <ManateeLazyCat> aavogt: That's all. Perfect.
20:08:11 <aavogt> http://haskell.org/haskellwiki/Template_Haskell#Marshall_a_datatype_to_and_from_.5BDynamic.5D
20:08:22 <Gracenotes> aavogt: uploading is pretty complete, looks like there's also a way to display a list of like, basically an htmlization of the build log that you have in your ./packages/hackage.haskell.org/build-reports.log
20:08:36 <Gracenotes> ~/.cabal/... that is
20:08:48 <ManateeLazyCat> aavogt: TH save much code.
20:09:13 <aavogt> I think the biggest concern is that dcoutts would do it without using up a student position
20:09:22 <aavogt> or looks like he will
20:11:08 <ManateeLazyCat> aavogt: BTW, you can create `Types.hs, TemplateFunction.hs, TemplateExport.hs`, and import order is `Types -> TemplateFuncton -> TemplateExport`, and every modules just import TemplateExport. Then you won't do a cycle.
20:11:10 <Gracenotes> do what? implement it? well, this summer isn't the be-all-and-end-all of hackage improvements; implementing things and designing it for later implementing things easily are both important
20:11:47 <aavogt> I don't understand your concern for cyclic imports here
20:12:10 <Gracenotes> in this case, there hasn't been that much work on the codebase so far this year, although last year Antoine did lots of stuff, and Duncan too
20:12:47 <ManateeLazyCat> aavogt: Because TH focus we write TH function and splice in different files, so i write all Template function in TemplateFunction.hs and write all splice in TemplateExport.hs.
20:12:49 <Gracenotes> aavogt: cyclic dependencies? it's something that would be suitable as a warning, since it introduces a messy scenario
20:13:10 <ManateeLazyCat> aavogt: Then every module that need TH, just import TemplateExport
20:13:16 <Gracenotes> one I'm not sure can be easily resolved, particularly if the loop brings you to a different version
20:13:33 <aavogt> it's a failure to completetly implement H98
20:13:54 <ManateeLazyCat> aavogt: You still got TH cycle now?
20:14:15 <Gracenotes> A 1.1 depends on B 3.0 depends on A 1.1 is bad enough, without the last item being A 1.0 or something. This is dependencies between packages, not modules themselves, by the way
20:14:31 <aavogt> I don't understand how you would end up in a bad situation with respect to imports
20:14:43 <aavogt> ManateeLazyCat: you mean just to avoid ghc's stage restriction?
20:15:13 <ManateeLazyCat> aavogt: Do you know hs-boot.hs ?
20:15:23 <aavogt> yes, they aren't worth it
20:15:31 <ManateeLazyCat> aavogt: I use Types.hs avoid hs-boot file.
20:15:37 <aavogt> good
20:15:43 <Gracenotes> it's a fragile and volatile, though not impossible, situation to be in. directed acyclic graphs is a good way to keep dependency trees, otherwise you'd have codependency trees
20:16:16 <ManateeLazyCat> aavogt: Yep, so i use TemplateFunction and TemplateExport avoid TH hs-boot file.
20:16:53 <aavogt> I don't believe that hs-boot files help with TH
20:17:09 <ManateeLazyCat> aavogt: Example, A have Template Function, B have splice, so you can't use those splice in A.
20:17:16 <SamB_XP> aavogt: they CAN
20:17:21 <ManateeLazyCat> aavogt: Otherwise you got reference cycle.
20:17:25 <SamB_XP> as long as you don't need to run code *from* them
20:17:40 <ManateeLazyCat> SamB_XP: No, hs-boot will crazy you.
20:17:58 <ManateeLazyCat> SamB_XP: It's hard to fix, in big project that have so many modules.
20:18:01 * Gracenotes isn't sure where the conversation's segmented.. o.o
20:18:27 <aavogt> from package to module dependency graphs
20:18:50 <ManateeLazyCat> SamB_XP: Example, you build many hs-boot files, and when you got cycle, then you fix that, oh you found another cycle, then you fix that, and have another cycle, until crazy you..... :)
20:19:42 <ManateeLazyCat> aavogt: I use hs-boot file before, someday i'm really crazy. You can't fix it, even hs-boot is correct in principle.
20:20:27 <aavogt> ManateeLazyCat: mkDec str f = funD (mkName str) [clause [] (normalB f) []]
20:21:02 <ManateeLazyCat> aavogt: So i make build one direction reference for TH: `Types.hs -> TemplateFun.hs -> TemplateExport.hs`, then i can use any splice in any modules, and don't care cycle problem.
20:21:19 <ManateeLazyCat> aavogt: What's that.
20:21:45 <dobblego> what is the flag to ghci that disallows me to use (#) as an identifier?
20:21:53 <Gracenotes> aavogt: package dependency graphs having cycles may mean that a module dependency graph has cycles. Since the packages compile independently, this might not prevent GHC from doing its job with the messed-up versions, but I think it would confuse cabal's dependency solver. This is something I need to be cautious about.. is all.
20:21:55 <aavogt> -XMagicHask
20:22:00 <aavogt> -XMagicHash
20:22:20 <Gracenotes> disallows?
20:22:38 <aavogt> then add a No
20:22:52 <Gracenotes> I did think it was disallowed by default
20:22:55 <aavogt> oh, you can't disallow it
20:23:01 <aavogt> @type (#)
20:23:02 <Gracenotes> oh.
20:23:02 <lambdabot> parse error on input `)'
20:23:09 <dobblego> something in my ~/.ghci is disallowing it
20:23:17 <aavogt> @let (#) = (+)
20:23:18 <lambdabot>  Defined.
20:23:21 <Axman6> > x^14
20:23:21 <lambdabot>   <local>:3:2: parse error on input `)'<local>:3:2: parse error on input `)'
20:23:23 <aavogt> > 1 # 2
20:23:23 <dobblego> ah it's -fglasgow-exts
20:23:24 <lambdabot>   <local>:3:2: parse error on input `)'<local>:3:2: parse error on input `)'
20:23:36 <Axman6> > x^14
20:23:36 <lambdabot>   <local>:3:2: parse error on input `)'<local>:3:2: parse error on input `)'
20:23:39 <Axman6> o.O
20:23:39 <Gracenotes> heh
20:23:48 <aavogt> funny how that was allowed to be defined
20:23:50 <aavogt> @undef
20:23:52 <Gracenotes> you broke it! to the @undefine-mobile..
20:23:55 <Axman6> > x^14
20:23:56 <lambdabot>   x * x * (x * x) * (x * x * (x * x)) * (x * x * (x * x) * (x * x))
20:23:58 <Axman6> thankyou!
20:24:02 <Axman6> -_-
20:24:52 <dobblego> ghci -fglasgow-exts will disallow let (#) = 7
20:25:51 <monochrom> @remember aavogt -XMagicHask
20:25:52 <lambdabot> Done.
20:26:13 <Gracenotes> dobblego: I'm thinking of MagicHash more like it *allows* you do use primitive-esque identifiers
20:26:45 <Gracenotes> but throws out # as a symbol identifier too :/
20:26:45 <dobblego> Gracenotes, I believe it is allowed by default
20:27:09 <ddarius> Gracenotes: Incorrect.
20:27:16 <aavogt> lambdabot uses -fglasgow-exts
20:27:19 <ddarius> > let ( # ) = (+) in 3 # 5
20:27:19 <lambdabot>   8
20:28:38 <Gracenotes> ddarius: okay, now I'm confused in the first place about when (#) is disallowed
20:28:51 <Gracenotes> seemingly not at all
20:29:00 <dobblego> when -fglasgow-exts at least
20:29:34 <aavogt> Gracenotes: in some places when you use the CP
20:29:37 <aavogt> CPP
20:30:00 <Axman6> > x^12
20:30:01 <lambdabot>   x * x * (x * x) * (x * x * (x * x)) * (x * x * (x * x))
20:30:31 <Axman6> anyone know how to find the minimum number of multiplications needed to take x ^ n?
20:30:32 <Gracenotes> oh. So the ghci command I defined starts up ghci -fglasgow-exts with a module containing modules I like to use
20:30:46 <Gracenotes> s/containing/importing/
20:31:16 <ddarius> :t (# 2, 3 #)
20:31:17 <lambdabot> forall t t1. (Num t, Num t1) => (# t, t1 #)
20:31:19 <Gracenotes> and (#)-as-identifier works there, and so do other things like implicit params
20:32:04 <Gracenotes> if the CPP is involved somehow, perhaps some kind of unholy ritual...
20:33:09 <ManateeLazyCat> aavogt: Why need mkDec ? Have different with `unpackTest = $(unpackVariant ''DaemonMember ''DaemonSignalArgs) ` ?
20:33:45 <aavogt> ManateeLazyCat: you can get away with 2 modules rather than 3
20:34:02 <aavogt> if you use that mkDec
20:34:11 <aavogt> since you can import the splice into the
20:34:11 <syntaxglitch> Axman6, write n in binary, count the number of digits, add the number of 1 digits, subtract two.
20:34:13 <ddarius> Gracenotes: Have you figured out what the problem was yet?
20:34:24 <syntaxglitch> Axman6, I think that would work, at least
20:34:30 <aavogt> module that defines the types, then run it at top-level
20:34:31 <Axman6> is that oprimal?
20:34:34 <Axman6> optimal*
20:34:36 <aavogt> hmm, you can do that anyways
20:35:18 <Axman6> at the moment, i've got this for x^12: let x3 = x*x*x; x2=x3*x3; in x2*x2
20:35:32 <syntaxglitch> Axman6, it's the result of the obviously sensible algorithm, there might be more clever ways that I'm not thinking of
20:36:32 <Axman6> basically, i'm trying to minimise the number of multiplications
20:36:36 <dmwit> i show how spel triangel in only five nunmbers
20:36:42 <Axman6> i don't really need a general algorithm
20:36:52 <aavogt> haha dmelani
20:37:03 <ManateeLazyCat> aavogt: So you mean, we need try to use `$` ?
20:37:04 <aavogt> dmwit actually
20:37:21 <aavogt> sorry dmelani
20:37:22 <Gracenotes> ddarius: okay, now things are behaving a bit more consistently.
20:37:43 <ManateeLazyCat> aavogt: Use you mkDec, i just need *one* module to define, then use that function immediately in other modules.
20:38:02 <dmwit> axmna it's the (^) function thta wors
20:38:02 <twink> There's some addition chain stuff out there somewhere. I think Knuth's TAOCP has something about it.
20:38:09 <aavogt> ManateeLazyCat: I mean that you can use  ''Identifier   in the module that defines the Identifier type
20:38:18 <dmwit> > x^12
20:38:19 <lambdabot>   x * x * (x * x) * (x * x * (x * x)) * (x * x * (x * x))
20:38:23 <Gracenotes> oh, I'm an idiot. +# would be allowed in both modes, because it's a symbol in one and a magical hash in the other
20:38:24 <absentia> x?
20:38:25 <Axman6> i'm not using haskell for this btw
20:38:40 <dmwit> > let x3 = x*x*x; x6 = x3*x3 in x6*x6
20:38:41 <lambdabot>   x * x * x * (x * x * x) * (x * x * x * (x * x * x))
20:38:55 <Axman6> dmwit: it's not bad, but this is for a high performance computation course, i'd quite like optimal :)
20:39:28 <Axman6> trying to maximise sharing if possible
20:40:04 <ManateeLazyCat> aavogt: That's sound good.
20:40:46 <dmwit> > let x2 = x*x; x4 = x2*x2 in x4*x4*x4 -- real (^{ way
20:40:47 <lambdabot>   x * x * (x * x) * (x * x * (x * x)) * (x * x * (x * x))
20:40:50 <aavogt> that's sort of independent of using a function to write your splices as    fun = $(f ''x 'y)  rather than   $(f ''x 'y)
20:41:01 <aavogt> for appropriate types of f
20:41:23 <syntaxglitch> Axman6, nevermind, I was wrong earlier
20:41:50 <syntaxglitch> I think my answer was correct only if you discard intermediate results and keep only the original value and the running total
20:41:57 <twink> There's some dynamic programming approach to this IIRC.
20:42:46 <Axman6> dmwit: doesn't that have the same number of multiplications?
20:44:41 <Axman6> argh! i wish i could use haskell for this :(
20:44:54 <Axman6> maybe i should ask the lecturer if i can
20:44:58 <dmwit> yes yes same multiply
20:45:00 <Axman6> even if we do have to use the ffi
20:45:06 <dmwit> forward and backward bit count ===
20:45:30 <pastorn> Axman6: what are you stuck with? fortran?
20:45:35 <Axman6> python
20:45:37 <twink> chains = Map.fromList $ (1, Set.singleton 1) : [(k, Set.fromList [(chains `Map.lookup` j) `Set.union` (chains `Map.lookup` i) | j <- [1 .. k `div` 2], let i = k - j]) | k <- [2..]] or some such
20:45:38 <pastorn> WAT?
20:45:40 <Axman6> which i don't know very well
20:45:50 <pastorn> i thought you said "high performance computations"
20:45:54 <dmwit> python /= high pefrominc???
20:45:59 <syntaxglitch> python has good numeric libraries
20:46:10 <Makoryu> pastorn: Python has some scientific libs written in C
20:46:12 <syntaxglitch> think "python interface to high-performance C libraries"
20:46:22 <pastorn> yeah... but what about fortran?
20:46:26 <Axman6> pastorn: we've got to write the main computation part of the code in C
20:46:27 <pastorn> or C with inlined ASM?
20:46:52 <Axman6> but, first i need it working in python
20:47:40 <twink> It's a sequence where each element of the sequence is the sum of two of its not-necessarily-distinct predecessors.
20:50:04 <syntaxglitch> ugh, too tired to think about optimal exponentiation
20:51:01 <dmwit> sibrary should provide exponentiation
20:51:03 * syntaxglitch goes back to working on his type-level programming library
20:51:42 <aavogt> optimal type-level exponentiation
20:51:59 <syntaxglitch> :(
20:52:00 <dmwit> python -c 'print 3 ** 12' <- Axman?
20:52:08 <dmwit> Axman6, i mean
20:52:37 <syntaxglitch> aavogt, getting any sort of "type" checking working is bad enough for now, thanks
20:53:17 <aavogt> @quote substitute
20:53:17 <lambdabot> kmc says: types substitute for documentation much better than documentation substitutes for types
20:54:16 <ManateeLazyCat> aavogt: I use "mkDec "unpackTest" (unpackVariant ''DaemonMember ''DaemonSignalArgs)" got above error:
20:54:17 <syntaxglitch> which is why it's a pity that type-level programming is all but "untyped" by default
20:54:17 * ManateeLazyCat pasted "error." at http://paste2.org/get/766115
20:54:30 <ManateeLazyCat> error at http://paste2.org/get/766115
20:54:49 <aavogt> you need to apply    fmap (:[])
20:55:13 <Sgeo> Does anyone actually use http://www.haskell.org/haskellwiki/Haskell_in_web_browser ?
20:55:17 <aavogt> that's a simple type error
20:55:55 <Sgeo> The YHC Web Service thing seems to be down
20:56:06 <dmwit> it's toooo slow anyway
20:56:29 <ManateeLazyCat> aavogt: Thanks, i'm still not familiar with TH syntax.
20:56:34 <syntaxglitch> at least I have type-level map, fold, and zipWith working for type lists, but typechecking is really painful :(
20:56:47 <aavogt> ManateeLazyCat: the type error is just like any other in haskell
20:56:56 <ManateeLazyCat> aavogt: I see.
20:57:10 <Adamant> dmwit: that seems to be the problem with most language deals that convert to Javascript
20:57:21 <Sgeo> How does type-level programming work? Is it turing-complete? How do you do infinite loops?
20:57:31 <dmwit> ?src Fix
20:57:31 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
20:57:37 <dmwit> ?src Mu
20:57:37 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
20:57:37 <aavogt> it's ugly
20:57:48 <Adamant> Scheme had some similar stuff a while back, but what restrained it was speed
20:57:49 <syntaxglitch> Sgeo, GHC has an extension called "UndecidableInstances"
20:58:04 <syntaxglitch> undecidable meaning "subject to the Halting Problem"
20:58:24 <Sgeo> How can an instance be undecidable? What does such a thing look like?
20:58:45 <aavogt> it looks like     instance C1 a => C2 a
20:59:28 <kmc> the undecidable thing is looking up the right instance for a type
20:59:37 <kmc> in H98 (and with lesser extensions) there are structural requirements on instances such that termination is always guaranteed
20:59:53 <kmc> i.e. they're of the form:   instance C1 a => instance C2 (T a)
21:00:08 <kmc> if we have a (T a) and want to see if this instance applies, we have to recursive look for an instance of C1 for a
21:00:14 <kmc> but the type "a" is structurally smaller than "T a"
21:00:21 <kmc> so we know this recursive process will terminate
21:00:37 <aavogt> given that types are not infinite?
21:00:41 <kmc> right
21:00:46 <aavogt> or is that assumed somewhere else?
21:00:51 <syntaxglitch> Sgeo, here's a snippet of a previous revision of my library: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24802
21:00:58 <kmc> GHC doesn't have an extension for infinite types
21:01:06 <syntaxglitch> Please note that I do not actually condone writing code like that
21:01:10 <dmwit> aavogt: it is hard to write an infinite type in finite letters
21:01:18 <kmc> type T = Maybe T
21:01:24 <kmc> there's an infinite type
21:01:27 <kmc> but GHC won't accept it
21:01:57 <monochrom> type Mu f = f (Mu f)
21:02:02 <kmc> yeah
21:02:19 <kmc> but instead we need a wrapper:  data Mu f = MkMu (f (Mu f))
21:02:43 <kmc> and if you want to write an instance like   instance (C (f (Mu f))) => instance C (Mu f)
21:02:47 <kmc> you will have to turn on UndecidableInstances
21:03:15 <kmc> (but if you do, you can "deriving instance Show (f (Mu f)) => Show (Mu f)" which i found quite surprising)
21:03:46 <monochrom> oh what fun
21:04:05 <aavogt> how much Mu does it print?
21:04:37 <dmwit> That doesn't seem that useful, actually.
21:05:36 <dobblego> is there any way to make hlint not bork on (#) ?
21:05:42 * syntaxglitch isn't sure how much *useful* stuff you can do with undecidable instances, but it is fun!
21:06:44 <aavogt> syntaxglitch: write stuff equivalent to    if hasInstance(Show,a) then ...  else ...
21:07:31 <syntaxglitch> yeah, dispatching by type class and such
21:07:32 <ManateeLazyCat> aavogt: Thanks, works well now.
21:07:43 <syntaxglitch> I'm not really sure how often one would want to do that, though
21:08:15 <ManateeLazyCat> aavogt: TH save much code, but i got complicated syntax and slow compile.
21:09:02 <ManateeLazyCat> aavogt: Perhaps not perfect solution for both. :)
21:10:36 <syntaxglitch> most of what I've been playing with is finding ways to write generic code for hierarchical data structures that aren't generally recursive
21:11:18 <syntaxglitch> e.g., nested tuples instead of lists, stuff like that
21:12:02 <aavogt> what sort of generic functions?
21:12:19 * ManateeLazyCat lunch
21:12:40 <syntaxglitch> my current favorite is code that takes a function from some fragment of such a structure, and recursively searches the structure to find chunks that the function fits
21:12:55 <dons> ?yow
21:12:55 <lambdabot> Couldn't find fortune file
21:13:02 <dons> one day, one day
21:13:16 <syntaxglitch> like if you have nested tuples containing Ints and Bools, you could give it a function that takes two consecutive bools and it would "pattern match" into the tuple list for you
21:13:59 <syntaxglitch> though what I actually wanted it for was pattern matching fragments of a nonrecursive AST for doing rewriting
21:14:16 <ManateeLazyCat> Someone fix HList for ghc-6.12 ? I want use it.
21:14:39 <aavogt> get it from code.haskell.org
21:14:53 <ManateeLazyCat> aavogt: Thanks.
21:15:31 <syntaxglitch> I dunno if anyone else would ever want to use this stuff, though, heh
21:16:03 <ManateeLazyCat> aavogt: Do you use HList? I found it from Oleg's paper.
21:16:18 <ManateeLazyCat> aavogt: Looks cool.
21:16:49 <kmc> aavogt, as much Mu as you have
21:16:50 <aavogt> @hackage records
21:16:50 <lambdabot> http://hackage.haskell.org/package/records
21:17:25 <turiya> hi
21:17:39 <aavogt> I don't know if that one is better than hlist
21:17:39 <turiya> how can i derive Show for my data type?
21:17:48 <kmc> turiya, data Foo = Bar deriving (Show)
21:17:49 <aavogt> data X = X deriving Show
21:18:21 <turiya> kmc, that was simple :)
21:20:12 <twink> Okay, almost there.
21:21:24 <twink> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=9616#a9616 <-- addition chain garbage
21:22:48 <dmwit> halp!
21:23:11 <wolgo> uggg
21:23:20 <wolgo> Eccels sonata sounds like hell
21:23:20 <dmwit> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24803#a24803
21:23:37 <syntaxglitch> aavogt: think anyone would be interested in a more extensive library for type-level programming?
21:23:40 <wolgo> time to finish hangman
21:24:06 <twink> syntaxglitch: Yes.
21:24:14 <twink> Who was doing the addition chain stuff?
21:24:56 <syntaxglitch> I've seen a couple on hackage, but they don't usually go much beyond the standard stuff, type-level arithmetic and sequences like HList
21:25:22 <wolgo> zomg this lazy evaluation business...
21:25:32 <wolgo> takes some getting used to.
21:25:49 <ManateeLazyCat> syntaxglitch: Do you use HList much?
21:25:57 <aavogt> syntaxglitch: there's quite a bit of stuff in hlist
21:26:03 <syntaxglitch> ManateeLazyCat, sort of?
21:26:20 <syntaxglitch> I kinda strip-mined HList, ripping it up for spare parts to build my library
21:26:29 <aavogt> it has stuff other than just sequences
21:26:51 <ManateeLazyCat> syntaxglitch: I just found HList yesterday, haven't try.
21:27:20 <tomoj> I couldn't figure out hlist :(
21:27:33 * syntaxglitch lifted HList's type equality and type unification classes verbatim
21:27:57 <aavogt> ManateeLazyCat: don't. If you have trouble to interpret the error    expected: [a]  inferred: a,  it's not going to turn out well
21:28:01 <aavogt> or at least not yet
21:28:50 <aavogt> syntaxglitch: which is the type unification class?
21:29:03 <syntaxglitch> TypeCast
21:29:22 <syntaxglitch> IIRC it unifies two variables if possible, and fails otherwise
21:29:39 * ManateeLazyCat brb
21:30:26 <syntaxglitch> Not all that useful, since most of the time I don't want any instances to fail, the errors are atrocious
21:31:53 <syntaxglitch> better is to have type-level conditionals where the "failure" case has a context with some bogus instance that gives a nice error
21:33:54 <syntaxglitch> something like "class KindMismatch a b c d" with no instances, and the context gives something like "KindMismatch Got t Expected k"
21:34:58 <aavogt> and that's not possible with the TypeCast class?
21:35:29 <aavogt> I mean it would be a duplicate instance declaration I think
21:35:32 <syntaxglitch> If TypeCast can't unify the type variables, it fails right there, which means I don't get a chance to use my own error
21:36:09 * BlackM plans to do some type-level hackery, just to see: "KindMismatch Got (Your Mom) Expected Fun"... ;
21:36:49 <syntaxglitch> whereas TypeEq is a type function returning a boolean value, so I can do the test, and then have a readable failure message if it's wrong
21:37:18 <aavogt> I don't see how TypeCast is more useful than TypeEq
21:37:27 <syntaxglitch> Instead of just "No instance for TypeCast '' () blah blah" etc.
21:37:33 <aavogt> can you explain it?
21:37:53 <syntaxglitch> dunno about more useful, the purpose is different
21:38:19 <aavogt> I mean, when in a context would you write     (TypeCast a b, .... )   instead of just giving a and b the same names?
21:38:46 <aavogt> *name
21:38:56 <syntaxglitch> for similar reasons to why ~ exists for type families
21:39:22 <syntaxglitch> is one reason
21:40:09 <syntaxglitch> also useful sometimes to delay part of the resolution of another instance, to make GHC keep trying
21:40:32 <syntaxglitch> e.g., look at the implementation of TypeEq, I think that's what's going on there
21:41:02 <syntaxglitch> keep in mind that instances are chosen without regard for contexts
21:41:39 <syntaxglitch> so a TypeCast constraint can force equality between two types in the instance head, but without letting GHC "know about it" until after it's chosen an instance
21:42:50 <aavogt> I see now:
21:42:54 <syntaxglitch> I think that a ~ predicate in the context often works just as well as TypeCast, but I'm not sure
21:43:23 <aavogt>   instance T a b ;  instance T a a;   these overlap, but you might want a ~ b
21:43:38 <syntaxglitch> I think ~ comes with type families, but extensive type programming needs fundeps, and I draw the line at enabling both in the same code
21:44:03 <aavogt> hmm, then when would you select for the more general instance?
21:44:09 <kmc> no, enable *everything*
21:44:25 <syntaxglitch> GHC extensions: gotta catch 'em all
21:45:09 <syntaxglitch> aavogt, those overlap too much, couldn't coexist
21:45:14 <kamatsu> okay, in my compiler, i use exceptions to unwind the stack when there is a tail call
21:45:19 <kamatsu> it works, but exceptions are quite slow
21:45:24 <kamatsu> at least, in JavaScript
21:45:26 <monochrom> heh
21:45:31 <kmc> for your convenience: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24804#a24804
21:45:44 <kamatsu> so, I figure I could only optimize tail calls every so often
21:45:55 <kamatsu> let the stack build up a bit and then jump off in one spectacular nose dive
21:46:24 <kamatsu> but I'm wondering the best approach to do this. Maybe keep a variable indicating the height of the stack, and once it reaches a certain point, jump off?
21:46:56 <aavogt> kmc: you forgot that they also have No variants
21:47:02 <syntaxglitch> kmc, thanks, I was missing a few, I'll add them right away
21:47:26 <aavogt> I'm not sure you want -XMonomorphismRestriction
21:47:30 <kmc> haha
21:47:36 <kmc> -XMonomorphismMeHarder
21:48:08 <aavogt> @quote phasm
21:48:08 <lambdabot> mmorrow says: [regarding excessive use of categorical recursion schemes] a morphasm?
21:48:28 <syntaxglitch> I think GHC needs an option -XPolymorphismRestriction
21:48:33 <syntaxglitch> to disallow monomorphic types
21:48:43 <dons> -XPolymorphismAllTheWay
21:48:51 <dons> -XPolymorphism-BringIt
21:48:51 <aavogt> no bool for you
21:48:54 <kmc> Char  ==>   (Char ~ a) => a
21:49:05 <dons> -XPolymorphismIWantMoreTypeVarsDamnIt
21:49:15 <dons> kmc: nice :-)
21:49:25 <syntaxglitch> kmc, that's cheating :(
21:54:50 * syntaxglitch fishes for suggestions on a good name for a library providing something like a DSL for type-level programming in GHC
21:55:25 <syntaxglitch> as a working name I've been calling it "typical" but there's already a package called that :(
21:55:58 <BlackM> -XChannelingOleg
21:56:14 <Kaidelong> retycil?
21:56:32 <BlackM> @hackage pocketOleg
21:56:32 <lambdabot> http://hackage.haskell.org/package/pocketOleg
21:57:07 <tensorpudding> Why is Oleg so legendary?
21:57:34 <syntaxglitch> dunno, I don't really want to give the impression that Oleg is in any way culpable for the atrocities I'm perpetrating in this thing
21:57:34 <aavogt> because people say "xyz can't be done"
21:57:53 <aavogt> and then they are proved incorrect
21:59:43 <Kaidelong> any particular recommendation you guys can make in terms of doing distributed computing in Haskell?
21:59:52 <Kaidelong> only one I've really taken a look at is Holumbus
22:02:56 <dons> Kaidelong: interesting problem.
22:02:58 <mjonsson> Is there any dynamically typed/checked language in the ML family?
22:03:17 <dons> mjonsson: nope. static typing is the defining characteristic
22:03:23 <syntaxglitch> isn't the ML family pretty much defined by H-M type inference?
22:03:27 <kmc> the oleg worship here can get a bit creepy
22:03:39 <kmc> mjonsson, how do you define the family
22:03:54 <kmc> AFAIK, the only popular languages in the ML family are SML, OCaml, and F# if you count that
22:03:59 <kmc> i'd be interested to hear of more
22:04:03 <dons> mjonsson: new languages post-ML, with ML syntax
22:04:04 <dons> ?
22:04:07 <mjonsson> perhaps I should explain what I'm thinking of instead
22:04:13 <Kaidelong> F# has runtime types
22:04:13 <mjonsson> yes
22:04:15 <kmc> you could make a dynamically typed language with ML syntax
22:04:28 <dolio> Worst of both worlds? :)
22:04:28 <dons> Haskell has runtime types
22:04:28 <mjonsson> kmc: that would be close to what I was thinking of
22:04:33 <Kaidelong> it does?
22:04:34 <dons> we all have Dynamic since Cardelli
22:04:44 <kmc> Kaidelong, what do you mean?  that there's a type representing "dynamically typed value"? or that implementations don't perform type erasure?
22:04:53 <dons> the universal type for ML type systems, to defer all type checking to runtime
22:04:55 <Kaidelong> I thought one of haskell's defining features was that the compiler could eliminate types completely at compile time
22:05:00 <dons> it does, yes.
22:05:07 <Kaidelong> kmc: the .NET runtime keeps type information around during run time
22:05:14 <dons> but you can encode types as data, and thus defer types to runtime
22:05:16 <kmc> so does GHC, sort of
22:05:20 <Kaidelong> so you can do things like reflection on objects you don't know the type of
22:05:23 <dons> in ML, Haskell and F#
22:05:27 <Kaidelong> and cast them
22:05:28 <mjonsson> the ML family is mostly functional with pattern matching and constructors
22:05:33 <Kaidelong> to the appropriate type
22:05:40 <kmc> in GHC Haskell each value has a pointer to a static struct of type-specific stuff
22:05:44 <mjonsson> i don't know of any dynamic language based on the same building blocks
22:05:53 <dons> kmc: hmm.
22:06:04 <kmc> mjonsson, it's a shame, because pattern matching would be useful dynamically too
22:06:05 <Kaidelong> you can implement dynamic typing in F# yourself
22:06:11 <kmc> you can hack algebraic types into Javascript or Python
22:06:12 <mjonsson> kmc: exactly my thought
22:06:12 <Kaidelong> but the same could be said of any language
22:06:16 <kmc> i think i've seen the former
22:06:21 <dons> kmc: types are erased, some debug info is kept. if you use Dynamic, you get  type info too
22:06:25 <dons> and a cast function
22:06:35 <Kaidelong> although F# is built under an underlying framework that has a notion of dynamic types
22:06:39 <Kaidelong> atop
22:07:28 <syntaxglitch> it's worth noting that explicit runtime type tags is basically what many "dynamic" languages are doing under the hood, so doing it manually in Haskell really isn't too different
22:07:52 <dons> no, its identical. see bob harper's book :)
22:08:08 <dons> "dynamic typing is just a degenerate static typing case"
22:08:20 <kmc> right, everything has the same static type
22:08:21 <mjonsson> chicken and egg debate :0
22:08:34 <kmc> you can do dynamic typing in a static type system
22:08:34 <dons> you can always encode dynamic typing in a static type system, but not vice-versa
22:08:42 <kmc> you can't really do static... yeah, what dons said :)
22:08:42 <syntaxglitch> well, there are generally syntactic differences
22:08:46 <mjonsson> dons: and then you can create a type system for your dynamic values
22:08:51 <dons> so it is strictly more powerful to introduce phase separation
22:08:56 <dons> mjonsson: indeed
22:09:07 <kmc> well, there are static type systems not powerful enough to do useful dynamic typing
22:09:27 <kmc> and a "universal" / "open" Dynamic type like Haskell's will probably have some magic to its implementation
22:09:59 <kmc> you can consider Dynamic to be an opaque base type, but if you instead want to consider it to be an ordinary algebraic type, there's a bit of trickery going on
22:10:20 <dons> you need a foralll a. a
22:10:21 <dons> type
22:10:35 <kmc> also, Dynamic doesn't include most Haskell types
22:10:39 <kmc> it only includes the monomorphic ones
22:11:17 <dons> not strictly, but the Typeable class constraint makes it more of a puzzzzzzzzzzzzzzzzzzle
22:11:25 <dons> really a puzzle :-)
22:11:37 <kmc> hmm.  how would you get a polymorphic type into/out of Dynamic?
22:11:41 <syntaxglitch> dynamic languages usually do a lot to help you out and smooth things along, I imagine things would be a bit more awkward in something like Haskell
22:11:47 <kmc> does your Typeable instance have to lie?
22:12:42 <dons> kmc: yeah, you have to do unification "your self" (e.g. call the type checker)
22:13:03 <syntaxglitch> but I can't say I've tried... having gone from Python to Haskell, emulating dynamic typing is exactly what I'm not interested in doing :\
22:13:29 <Kaidelong> well yes, the main reason to want a language in the ML family is for useful type errors
22:13:43 <Kaidelong> at least that's been my experience with it
22:13:43 <dolio> It's not as if folk from 'dynamic languages' can complain that Dynamic doesn't handle polymorphic types, because they don't have them at all.
22:14:05 <dons> yeah, wtf.
22:14:17 <dons> just-do-something-types-i-don't-care
22:14:41 * syntaxglitch is more inclined these days to get frustrated with sloppiness in Haskell's type system and start eyeing things like Agda or Coq...
22:14:51 <syntaxglitch> real type systems are addictive :(
22:15:01 <Kaidelong> I've mostly found myself using F# because the tooling for it is so much better
22:15:14 <Kaidelong> trying to get a grasp on haskell for cross platform purposes
22:15:15 <dons> syntaxglitch: you have reached Level 2
22:15:28 <syntaxglitch> dons, what's Level 3
22:15:28 <dons> haskell is a gateway drug to pure types
22:15:34 * syntaxglitch wants to know what to look forward to
22:15:36 <dons> Agda
22:15:45 <dons> once you get bored.
22:15:50 <syntaxglitch> awesome
22:16:01 <aavogt> is Real World Agda coming out soon, dons?
22:16:06 <syntaxglitch> haha
22:16:07 <dons> hey, not from me.
22:16:14 <djahandarie> lmao
22:16:18 <dons> galois' doing an Isabelle training course soon.
22:16:27 <dons> maybe we need an Agda course -- plenty of Agda fans
22:16:48 <dobblego> is the course for employees or for paying clients?
22:17:14 <kyagrd> dons: open at PSU plz ~
22:17:21 <dons> kyagrd: you at PSU?/
22:17:22 * syntaxglitch just wants a type system that can easily express total functions, non-infinite recursive data structures, and maybe a little bit of dependent typing--is that so much to ask?
22:17:26 <dons> it'll be open to psu-vians
22:17:32 <Gracenotes> I've been hanging out in #agda for a few weeks. Though I'm not learning atm, I'm absorbing smarts from the channel by osmosis
22:17:51 <dons> we loves psuvians, they're our precious brains.
22:17:54 <DigitalKiwi> Gracenotes: if that worked I would be an expert haskeller
22:18:18 <Gracenotes> and I am an expert adga..ian! mwahaha
22:18:33 <kyagrd> dons: yeah I'm in the Coq course right now (with B.C. Pierce's material)
22:19:25 <ManateeLazyCat> aavogt: I must put TH code at top position of module? Otherwise i'm compile failed.
22:19:30 <syntaxglitch> now if only I could use a civilized language at the day job :(
22:20:00 <aavogt> order matters for template haskell
22:20:43 <ManateeLazyCat> aavogt: Oh, i see.
22:21:17 <kmc> #agda is pretty dead usually :/
22:21:58 <kmc> it's about as active as #coq, but i'm pretty sure Coq is much more popular overall
22:22:00 <jvoorhis> dons: happy birthday
22:22:11 <kmc> maybe Agda gets a boost from the association with Haskell and its active community
22:23:11 <syntaxglitch> kmc, on the other hand coq enables lots of really tasteless jokes
22:23:37 <syntaxglitch> that has to count for something
22:24:36 <kmc> yeah, you were "eyeing Coq" just now
22:24:53 <kmc> i've stopped trying to make the jokes, or to not make them
22:25:00 <kmc> it's pointless either way
22:25:50 <syntaxglitch> this is #haskell, isn't pointless is the way we like it?
22:25:57 <syntaxglitch> points are overrated
22:26:14 <jvoorhis> pointless, but never *meaningless*
22:26:39 <kyagrd> There was a paper on proving haskell programs using Adga by preprocessing the Haskell core ... Wonder how it is going now.
22:26:40 <BlackM> Haskell: We're academics! We do pointless procesing on purpose! ;
22:26:45 <kmc> always pointless, never meaningless, finally tagless, partially evaluated
22:26:56 <kmc> kyagrd, cool
22:27:10 <kmc> i imagine a bright future wherein programs are written in a mix of something like Haskell and something like Agda
22:27:47 <kmc> there's a nice technique where you have a huge program and a much smaller thing which checks that the program is correct
22:27:54 <kmc> rather, that the output is correct
22:28:11 <kmc> and if you prove the correctness of that verifier then you've proved that the combination will never produce an incorrect result
22:28:19 <kmc> (which does not prove that it always produces a correct result)
22:28:20 <syntaxglitch> then you use the smaller thing to check its own correctness
22:28:44 <kmc> the idea being that parts of your program can be "untrusted" but their output gets verified, and the verifier is trusted
22:29:10 <kmc> of course the verifier would reject at runtime, which is not ideal
22:29:34 <kmc> but it's still a hard guarantee, and much easier than proving the big system never makes mistakes
22:30:55 <kmc> anyway, i can imagine e.g. GHC (several hundred kLoC in Haskell) augmented with a smaller core (maybe 1 kLoC Agda) which verifies some evidence produced by GHC that its code transformations are semantics-preserving
22:32:35 <syntaxglitch> meanwhile, the rest of the world will continue using languages that can't tie their shoes without risking runtime errors
22:32:37 <syntaxglitch> :(
22:33:43 <kmc> only if you mean "errors" in the worst possible way
22:33:56 <kmc> unchecked undefined behavior
22:34:21 * syntaxglitch is mostly just bitter about null reference errors at the day job
22:34:41 <kmc> Haskell is bad for job satisfaction
22:34:58 <kmc> i'm not joking in any way
22:35:37 <kmc> C++ and Java are only bearable if they're your Blub
22:36:00 <elly> (Insert snide remark about lisp and macros here.)
22:36:16 <kmc> because then you think it's natural that invoking the equivalent of "filter (<x)" takes 30 lines of code
22:36:29 <syntaxglitch> I've almost needed a sticky note on my monitor at work that says "Implementing Maybe with SelectMany is not an appropriate use of LINQ extension methods"
22:36:35 <syntaxglitch> because sometimes that almost sounds like a good idea
22:36:36 <kmc> haha
22:36:56 <Makoryu> （　≖‿≖）
22:37:36 <dobblego> how would you implement Maybe with SelectMany?
22:37:48 <syntaxglitch> ...the same way you'd implement it in Haskell?
22:37:58 <jvoorhis> kmc: your language can invoke filter in 1 line, and do all sorts of neat things, and still be plauged with null reference errors :(
22:38:00 <dobblego> how would you implement Maybe with (>>=) ?
22:38:37 <dobblego> data Maybe a = forall x. M x (a -> x)
22:38:44 <Sgeo> syntaxglitch, C# has nullible types
22:38:45 <syntaxglitch> dobblego, I meant "Maybe and its monad instance" if that helps
22:38:48 <Sgeo> *nullable
22:38:53 <dobblego> syntaxglitch, oh right, yes it does
22:39:02 <Jafet> kmc: seq.resize(remove_if(seq.begin(), seq.end(), [](typename decltype(seq)::value_type const& s){ return !(s<x); }) - seq.begin()); // one line!
22:39:06 <dobblego> syntaxglitch, why wouldn't you do that?
22:39:14 <syntaxglitch> Sgeo, it has nullable structs
22:39:25 <dobblego> abstract class Maybe<A> { public abstract Fold<X>(Func<X> nothing, Func<X, A> just); }
22:39:25 <syntaxglitch> reference types can't be "nullable" because they are automatically
22:40:30 * syntaxglitch would probably actually make Maybe a struct in C#, so as to avoid assigning null to a Maybe reference
22:40:51 <Sgeo> Isn't there some Haskell <-> .NET bridge?
22:40:53 <kmc> Jafet, oh, that's beautiful ;P
22:41:03 <Jafet> syntaxglitch, null could be bottom
22:41:17 <syntaxglitch> alternately you could probably hack something to Maybe-ize an existing class, treating null as Nothing
22:41:22 <kmc> i can't wait for C++1x so i can start to use these powerful techniques
22:41:46 <dobblego> syntaxglitch, http://code.google.com/p/kinet/source/browse/Kinet/src/Option.cs
22:41:48 <syntaxglitch> the LINQ functions are extension methods, and you can invoke extension methods on null safely
22:41:58 <syntaxglitch> with hilarity ensuing when someone else sees the code
22:42:06 <Sgeo> syntaxglitch, didn't know that about extension methods
22:42:46 <Sgeo> This is totally worth not going to sleep when I should be
22:43:39 <Jafet> It's quite rare after all to find yourself learning obscure C# hacks in the haskell channel
22:43:40 <syntaxglitch> dobblego, does implementing IEnumerable make that work with LINQ syntax?
22:43:53 * syntaxglitch hasn't actually tried to abuse LINQ that far, so doesn't know how it works
22:44:00 <dobblego> syntaxglitch, no there are extension methods that allow you to do that
22:44:10 <dobblego> IEnumerable just gives you: for(x in option)
22:44:19 <syntaxglitch> 'k
22:44:32 <syntaxglitch> it kinda needs LINQ to be usable
22:44:45 <dobblego> C# needs more than that
22:44:54 <syntaxglitch> binding with nested lambdas is ugly enough in Haskell, and it ain't any prettier in C#, trust me
22:45:18 <syntaxglitch> the LINQ sugar for SelectMany is a bit less hideous
22:45:36 <dobblego> yes there are examples here: http://code.google.com/p/kinet/
22:45:59 <Sgeo> Func monad?
22:46:20 <dobblego> Func<T, _> is a monad yes
22:46:33 <syntaxglitch> isn't that Reader?
22:46:36 <dobblego> yes
22:46:57 * Sgeo gibbers
22:47:19 <syntaxglitch> it's also the Functor instance that lets you write extremely elegant code by replacing function composition with fmap
22:47:49 <dobblego> yes there is a Select as an extension method
22:47:59 <Sgeo> How is <$> more elegent than . ?
22:48:16 <dobblego> it's not; it's just more general
22:48:31 <dobblego> and its name is three times longer than it should be
22:49:32 <syntaxglitch> ugh, anyway, it's.... erh, Saturday, why on earth am I thinking about C#
22:49:45 <syntaxglitch> I think that's a sign I need to call it a night
22:50:46 <kmc> drink heavily to forget C#
22:50:49 <ManateeLazyCat> aavogt: How do you debugging TH? Just runQ? Or have advanced tool?
22:51:00 <kmc> Sgeo, (.) *usually* isn't fmap.  just here, in bizarro world
22:51:01 <kmc> :t (.)
22:51:02 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:51:04 <kmc> @src (.)
22:51:05 <lambdabot> (f . g) x = f (g x)
22:51:09 <syntaxglitch> ManateeLazyCat, I think the preferred method is "write it correctly the first time"
22:51:10 <kmc> @t let (f . g) x = f (g x) in (.)
22:51:11 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
22:51:14 <kmc> :t let (f . g) x = f (g x) in (.)
22:51:15 <lambdabot> forall t t1 t2. (t -> t1) -> (t2 -> t) -> t2 -> t1
22:52:13 <ManateeLazyCat> syntaxglitch: I'm a newbie for TH, find some way to write TH faster.
22:52:53 <Sgeo> What is <*> exactly?
22:53:02 * syntaxglitch notes that (.) is a pleasingly concise name, and starts advocating to junk map, fmap, and <$> and make (.) part of Functor instances
22:53:06 <kmc> it's a typeclass method of Applicative
22:53:10 <Sgeo> > [(+ 1), (+ 2)] <*> [3,4]
22:53:11 <lambdabot>   [4,5,5,6]
22:53:14 <kmc> equivalent to "ap" for monads, but more general
22:53:16 <ManateeLazyCat> Sgeo: For use in constructor. :)
22:53:22 <dobblego> Sgeo, it's covered in a paper titled Applicative Programming With Effects
22:53:30 <kmc> f <$> x <*> y <*> z   ==>     liftM3 f x y z
22:53:33 <kmc> but more general
22:53:39 <kmc> <==> liftA3 f x y z
22:53:45 <kmc> @src liftA3
22:53:46 <lambdabot> Source not found. Just try something else.
22:53:49 <kmc> :t liftA3
22:53:50 <lambdabot> forall a b c d (f :: * -> *). (Applicative f) => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
22:53:58 <kmc> :t \f x y z -> f <$> x <*> y <*> z
22:53:59 <lambdabot> forall a a1 a2 b (f :: * -> *). (Applicative f) => (a -> a1 -> a2 -> b) -> f a -> f a1 -> f a2 -> f b
22:54:02 * Sgeo is somewhat lost
22:54:12 * ManateeLazyCat pasted "<$> and <*>" at http://paste2.org/get/766202
22:54:12 <ManateeLazyCat> Sgeo: Looks above code.
22:54:28 <Sgeo> paste2.org?
22:54:36 <ManateeLazyCat> Sgeo: Yes.
22:54:49 <syntaxglitch> Sgeo, if you have (Just (+2) and (Just 2) you can't get (Just 4) from Functor alone
22:54:54 <syntaxglitch> Applicative lets you do that
22:54:55 <ManateeLazyCat> Sgeo: <$> and <*> is handy for  constructor.
22:55:17 <Sgeo> What's frameNew?
22:55:21 <syntaxglitch> ...ugh, unmatched parenthesis
22:55:33 <ManateeLazyCat> Sgeo: WindowNew in gtk2hs.
22:55:52 <ManateeLazyCat> Sgeo: frameNew :: IO Frame
22:56:22 <ManateeLazyCat> Sgeo: Use <$> and <*>, you can avoid use middle variable for constructor.
22:56:45 <syntaxglitch> okay, time to get some sleep
22:57:08 <ManateeLazyCat> Sgeo: For example, you need write "frame <- frameNew, windowList <- newTVarIO windowListNew ..." if you don't use <$> and <*>
22:57:16 <ManateeLazyCat> syntaxglitch: night. :)
22:57:44 <ManateeLazyCat> Sgeo: Use <$> and <*>, you just need modified one place.
22:58:25 <ManateeLazyCat> Sgeo: In most Haskell complicated knowledge, just use it with feeling or look like that. You will understand that when you use it many many times.
23:00:02 <Sgeo> I think I kind of get it, although only because I'm imagining IO Whatever as a sort of container, which I know is wrong, but that's the only way I can relate it to Functors [and I guess Applicative is what allows <*>, which I saw in a similar context to Functor discussion]
23:01:16 <Sgeo> I think in LYAH, actually
23:01:42 <ManateeLazyCat> Sgeo: Example, when i first use <$> and <*>, i just know, use <$> in first element, then all after use <*>, if element is pure, just wrap pure, like "<*> pure foo"
23:01:54 <kmc> > show <$> lookup "x" [("x", 1), ("y", 2)]
23:01:55 <lambdabot>   Just "1"
23:01:57 <kmc> > show <$> lookup "z" [("x", 1), ("y", 2)]
23:01:58 <lambdabot>   Nothing
23:02:07 <kmc> Sgeo, there's an example with Maybe
23:02:11 <kmc> instead of IO
23:02:16 <kmc> > (*100) <$> lookup "x" [("x", 1), ("y", 2)]
23:02:17 <lambdabot>   Just 100
23:02:19 <kmc> > (*100) <$> lookup "z" [("x", 1), ("y", 2)]
23:02:20 <lambdabot>   Nothing
23:02:28 <Sgeo> But Maybe literally is a container, unlike IO
23:02:37 <kmc> yeah
23:02:48 <kmc> ah i see what you mean now
23:03:23 <kmc> @src liftM
23:03:24 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
23:03:30 <dons> these operators are called "money" and "splat" at galois, fyi
23:03:36 <dons> <$> and <*>
23:03:42 <kmc> Sgeo, there's the implementation of <$> in terms of monad "do" syntax
23:03:47 <kmc> (liftM is <$> is fmap, for monads)
23:03:50 <dons> elliott coined the names, iirc
23:03:50 <dobblego> dons, why not map and apply?
23:03:55 <kmc> dons, that's awesome
23:04:00 <dons> cause money and splat rock  the house
23:04:16 <dobblego> oh of course silly me didn't think of that :)
23:04:24 <dons> i hope then names catch on
23:04:45 <dons> we use this stuff in production code for hard core networking stuff, so you better well use the same names :-)
23:05:25 <dons> money and splat. you heard it, you use it, that's what it is.
23:05:34 <kmc> i hear and i obey
23:06:11 <dons> and all is right in the world
23:06:58 <Axman6> whoot! numerical calculations in python are starting to take shape! to orrow to convert it to C -_-
23:07:12 <Axman6> i think i've earned a bit of a break
23:07:39 <Sgeo> <3 Python
23:07:44 <twink> Axman6: Were you doing the addition chains for the fewest multiplications to raise numbers to a power?
23:07:51 <Sgeo> Although my current language that I'm obsessed with is Haskell
23:08:01 <Sgeo> So don't ask me to write Python anyime soon
23:08:02 <Axman6> Haskell > Python still
23:08:13 <kmc> Axman6, Cython?
23:08:32 <kmc> i really like Python for programs which are obviously correct
23:08:35 <kmc> which tops out at maybe 100 lines
23:08:48 <Axman6> twink: it's for a molecular dynamics assignment, which involved x^14 and x^8 a lot, and i wanted to make them efficient
23:08:50 <dons> "obviously correct" is a cool category of programs
23:09:00 <Axman6> heh
23:09:13 <twink> Axman6: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=9616#a9616 <-- my addition chain stuff
23:09:36 <Sgeo> Do posts on hpaste expire?
23:09:49 * Axman6 thinks his is probably incorrect, but is happy enough with it for now. just needs to handle command line args, and calculate energies
23:11:03 <Sgeo> Any way to embed Lua into Haskell?
23:11:38 <Axman6> i doubt it, not easily anyway
23:11:43 <twink> Axman6: 1, 2, 4, 8, 12, 14 works; x12 = x8*x4; x14 = x12*x2 and x8 (done the obvious way) and x14 even share things in a nice way that needs different code to do properly/generally.
23:12:12 <dons> Sgeo: only if we reset hpaste.
23:12:21 <dons> Sgeo: lua, yes, via the hlua bindings
23:12:25 <dons> but its mega evil
23:12:34 <dons> so you better have a good reason
23:12:34 <Sgeo> Megaevil, howso?
23:12:53 <Axman6> twink: i don't believe that's optimal though. may well be though
23:13:00 <Sgeo> Well, is there any way to load Haskell modules at runtime?
23:13:05 <dons> yeah.
23:13:21 <dons> hs-plugins (OG-style). mueval et al new skool
23:13:36 <Axman6> for 14, i used x3=x*x*x, x7=x*x3*x3, x14=x7*x7
23:13:37 <dons> Sgeo: basically, scripting ghci's mechanisms
23:14:25 <twink> Axman6: I guess my point was x8 and x14 can share multiplications.
23:17:02 <kmc> Sgeo, look at "hint"
23:17:11 <kmc> it's a simple wrapper on the GHC API
23:17:34 <kmc> GHCi itself is a Haskell program that loads Haskell modules at runtime
23:18:05 <twink> Axman6: Basically the optimal x^8 chain is a subset of one of the optimal x^14 chains.
23:24:24 <Sgeo> @hoogle (a -> b -> c) -> (a,b) -> c
23:24:25 <lambdabot> Prelude uncurry :: (a -> b -> c) -> (a, b) -> c
23:24:25 <lambdabot> Data.Tuple uncurry :: (a -> b -> c) -> (a, b) -> c
23:24:25 <lambdabot> Data.IntMap fromAscListWith :: (a -> a -> a) -> [(Key, a)] -> IntMap a
23:24:51 <Sgeo> @hoogle (a -> b -> c -> d) -> (a,b,c) -> d
23:24:51 <lambdabot> No results found
23:26:45 <Sgeo> Night all
23:30:29 <portnov> @djinn  (a -> b -> c -> d) -> (a,b,c) -> d
23:30:29 <lambdabot> f a (b, c, d) = a b c d
23:31:24 <kmc> preflex, seen dcoutts
23:31:24 <preflex>  dcoutts was last seen on #ghc 11 hours, 1 minute and 58 seconds ago, saying: wise choice
