00:20:40 <m4rzito> hi
00:20:45 <m4rzito> someone uses xmonad?
00:25:23 <dabblego> m4rzito, I bet most people in #xmonad do
00:25:25 <dabblego> I do
00:25:56 <kmc> i do
00:26:42 <pookleblinky> I do not so much use xmonad, as worship it.
00:26:52 <m4rzito> hi
00:27:01 <m4rzito> I know, but nobody reply on this channel
00:27:37 <pookleblinky> Are you having a problem with it?
00:27:46 <m4rzito> I've a xmonad with tall, mirror tall, and full layout, When I launch a console, all goes to left of screen
00:28:30 <m4rzito> ok, but I want to set the size of those windows, with mod + h/l I can, but I want to save the size, when I restart X i get the same
00:30:11 <pookleblinky> http://www.haskell.org/haskellwiki/Xmonad/Frequently_asked_questions#XMonad_doesn.27t_save_my_layouts_and_windows
00:30:45 <m4rzito> I read
00:30:58 <m4rzito> but I don't know why I cannot determine/save the layouts
00:33:35 <m4rzito> http://i43.tinypic.com/2rpzbdj.png
00:35:00 <kmc> the doc says it's not a supported feature
00:36:48 <m4rzito> ok thanks
00:37:17 <kmc> you can code your own layouts though
00:37:28 <m4rzito> then I try awesome
00:37:59 <pookleblinky> Layout Per Workspace, for instance, can let you individually adjust the tiling ratios
00:39:10 <m4rzito> how?
00:41:19 <pookleblinky> http://xmonad.org/xmonad-docs/xmonad-contrib/XMonad-Layout-PerWorkspace.html
00:42:49 <pookleblinky> You can pattern match apps to appear on designated workspaces, and then create individual layouts for each space.
00:48:44 <ivanm> what's with that email on -cafe from Vasili Galchin?
01:16:40 <sioraiocht> 5 fonts is too many for one paper
01:20:56 <z1y> hello, I use cabal to install leksah: cabal: cannot configure leksah-0.8.0.4. It requires glib >=0.10, gtk >=0.10  => how to get out of this problem?
01:21:39 <luite> you need to install gtk2hs
01:21:58 <luite> it cannot be installed with cabal-install (yet)
01:23:33 <z1y> luite: thank you
01:24:24 <rajeshsr> how is infix notation used with functions taking more than 2 parameters?
01:24:50 <dabblego> just recognise that functions never take more than one parameter and ask the question
01:25:01 <pastorn> rajeshsr: can't be done
01:25:27 <Liskni_si> (.) is one such function
01:25:30 <pastorn> rajeshsr: well, not for operators at least (operators are, +, -, * etc)
01:25:45 <rajeshsr> dabblego, yeah, i know that!
01:25:50 <pastorn> > (.) (+1) (+1) 0
01:25:51 <rajeshsr> let f a b c = a + b + c
01:25:51 <lambdabot>   2
01:26:13 <rajeshsr> let x = 1 `f` 2 creates a function which doesn't bind c, yet right?
01:26:18 <pastorn> @let f a b c = a + b + c
01:26:19 <lambdabot>  Defined.
01:26:33 <pastorn> > 1 `(f 2)` 3
01:26:34 <lambdabot>   <no location info>: parse error on input `('
01:26:38 <pastorn> awww
01:26:40 <dabblego> > let (+) a b c = a * b * c in (1 + 2) 3
01:26:41 <lambdabot>   6
01:27:01 <pastorn> dabblego: yay! operator overloading!
01:27:11 <rajeshsr> pastorn, `` can be used with functiosn only, not with expressions yielding functions..
01:27:26 <pastorn> seems silly
01:27:32 * pastorn wants lisp rules
01:27:36 <pastorn> or something
01:27:48 <pastorn> dunno if it's different in lisp, i just assume it is
01:28:39 <rajeshsr> dabblego, that was an interesting example! :)
01:28:55 <rajeshsr> so can i assume that you can't bind more than 2 arguments with infix notation?
01:29:20 <dabblego> rajeshsr, just recognise that functions never take more than one argument, then rephrase the question (it will answer itself)
01:30:39 <z1y> hi, can we use haskell to write web applications (a web page, for e.g.)?
01:30:49 <rajeshsr> dabblego, well, i do know that. But when using infix notation with more than 2 arguments it doesn't seem clear. For instance can you make: f 1 2 3 an infix call?
01:31:10 <luite> z1y: yes, see happstack for an example
01:31:22 <Younder> (+ 1 2 3) in lisp or (+) 1 2 3 in Haskell..
01:31:31 <Liskni_si> it is really silly indeed that `` does not work for expressions, like `flip something` for example
01:31:39 <z1y> luite: that's great. I am newbiew to Haskell :). thanks.
01:32:14 <dabblego> rajeshsr, by recognising that f takes one argument (1 `f` 2) 3
01:33:08 <rajeshsr> dabblego, well, it is equivalent to: x 3 where x = 1 `f` 2.  but x 3 is a prefix call! we can't make it infix right?! :)
01:34:07 <Younder> by it's nature infix requires ato values to an operator
01:34:11 <Younder> two
01:35:01 <rajeshsr> Younder, hmm, yeah!
01:53:32 <ivanm> why is it that when you compile a program with profiling support, it's still slower to run even if you're not enabling the profiling?
01:54:03 <opqdonut> because of the profiling hooks being in place
01:55:20 <ksf> the control back channel of iteratees can be used for all sorts of fun things
01:55:40 <ivanm> opqdonut: and they're still fired, etc. even if profiling is not occuring? :(
01:55:54 <opqdonut> I don't know to what extent
01:55:59 <ksf> like hinting the enumerator how much data to read into the buffer or literally anything else
01:56:07 <opqdonut> possibly also profiling disables some optimizations
01:56:30 <opqdonut> optimizations that would mess with the profile
01:56:39 <opqdonut> but I'm just guessing
01:57:05 <ivanm> not sure about that bit; profiling + -O2 is still faster than just profiling
01:57:32 <fasta> @ops
01:57:33 <lambdabot> Maybe you meant: docs oeis pl
01:57:42 <fasta> Please ban XniX23.
01:58:16 <ksf> fasta, chanops can't help you with people that message you
01:58:20 <ksf> ask a staffer
01:58:38 <fasta> ksf, huh?
01:58:50 <ksf> I'm not seeing him spamming the channel
01:58:55 <XniX23> why ban?
01:59:00 <ksf> (but then, I just entered)
01:59:04 <fasta> XniX23, I don't know you.
01:59:07 <ksf> I'm just extrapolating
01:59:14 <fasta> XniX23, you send a message, so you must be a spammer.
01:59:20 <fasta> Spammers must die.
01:59:23 <XniX23> fasta lol
01:59:24 <fasta> Simple logic.
01:59:31 <QtPlatypus> fasta: ...
01:59:41 <ksf> fasta, like, one message?
01:59:45 <XniX23> fasta why would u consider me a spammer for sending u a message -.-'
01:59:59 <fasta> XniX23, because I do not know you.
02:00:01 <QtPlatypus> fasta: Spammers send messages therefor everyone who sends a message must be a spammer?
02:00:20 <fasta> XniX23, there is no reason to talk to me specifically.
02:00:29 <ksf> (a -> b)-> b -> a
02:00:40 <ksf> that's a decent chunk of logic.
02:00:52 <ivanm> preflex: seen kowey
02:00:52 <preflex>  kowey was last seen on #haskell 10 days, 9 hours, 18 minutes and 40 seconds ago, saying: I guess the workaround for now is to build your own wxWidgets without using MacPorts
02:00:54 <QtPlatypus> ksf: Yes, it even has a name.
02:00:56 <ksf> fasta, then tell him.
02:00:59 <fasta> Especially not like "u here?"
02:01:09 <fasta> It shows every sign of a spammer.
02:01:23 <fasta> Anyway, you are too kind for this world if you do not see this.
02:01:24 <QtPlatypus> It shows signs of being a noob
02:01:35 <fasta> QtPlatypus, is there a difference?
02:01:38 <ksf> fasta, nope, it shows every sign of someone who would write youtube comments
02:01:43 <ksf> fasta, yes.
02:01:43 <XniX23> whats wrong with being a noob
02:01:46 <QtPlatypus> fasta: Yes
02:01:53 <ksf> he's not asking you to buy viagra.
02:02:02 <fasta> QtPlatypus, ok, that was a silly remark.
02:02:28 <fasta> Anyway, if I was the only one he messaged, I suppose it is fine for a n00b.
02:02:39 <fasta> But somehow I doubt that.
02:02:46 <ksf> fasta, if you don't want messages, disable them
02:02:51 <ksf> you should know that, noob.
02:03:24 <XniX23> fasta considered you told me about the thinking forth book, i didnt want to spam the channel with that, so i simply clicked you
02:03:34 <Araneidae> A quick nooby question: how do I hide the standard prelude definitions of +,- etc (so I can play with algebra)?
02:03:35 <ksf> iirc you can disable them for non-registered users and completely.
02:03:53 <ksf> XniX23, oh, don't worry about being OT before someone gets annoyed
02:04:19 <ksf> and then the usual path to take is to move the discussion to #haskell-blah
02:04:28 <fasta> ksf, I have no interest in programming my IRC client completely just because someone random wants to talk to me.
02:04:41 <ksf> Araneidae, import Prelude hiding ((+),(-),etc)
02:04:45 <fasta> ksf, it is not a simple matter of the registered users part.
02:04:52 <Araneidae> ksf, ta
02:04:53 <ksf> fasta, it's a freenode option
02:05:00 <fasta> ksf, yes, I know that.
02:05:18 <XniX23> whoa such a chaos for a msg
02:05:30 <XniX23> you guys are amazing ^^
02:05:39 <ksf> it's like having to put a sticker "no advertisment" on your letter box to get less of it.
02:05:42 <Adamant> it used to be that it was very rarely malicious software at fault when a desktop wasn't working. Now it's quite often the reason, except that computers still fail for all the old ones.
02:06:03 <fasta> ksf, yes, well let me do it now then to get somewhat less.
02:07:41 <ksf> Araneidae, there's also serveral takes on mathematical typeclass hierarchies on hackage
02:07:42 <XniX23> fasta, im sorry, i guess you had some bad experiences with private messages :P
02:08:10 <ksf> @preflex, nickometer XniX23
02:08:10 <lambdabot> Unknown command, try @list
02:08:15 <ksf> preflex, nickometer XniX23
02:08:15 <preflex>  XniX23 is 33% lame
02:08:24 <ksf> I've seen worse.
02:08:28 <XniX23> rofl
02:08:40 <XniX23> whats that feature
02:08:44 <Araneidae> ksf, I'm a complete Haskell beginner, I need to try hacking something up myself or I'll never get to grips with it!
02:08:44 <Adamant> preflex, nickometer Adamant
02:08:45 <preflex>  Adamant is 0% lame
02:09:01 <Adamant> preflex, nickometer ksf
02:09:02 <preflex>  ksf is 0% lame
02:09:13 <Araneidae> Still, it's worth a look, can you point me to an easy starting point?
02:09:34 <Araneidae> Just interested in polynomial arithmetic at the moment...
02:09:41 <Adamant> so we've passed the Voight-Kampf.
02:09:45 <ksf> http://www.haskell.org/haskellwiki/Numeric_Prelude
02:10:04 <Araneidae> thanks
02:10:17 <ksf> there's also a couple of vector packages etc.
02:10:24 <Adamant> XniX23: just looks for 'lameness' in your screen name, IIRC.
02:10:35 <Adamant> numbers probably don't help.
02:10:54 <ksf> in general, http://hackage.haskell.org/packages/archive/pkg-list.html#cat:math
02:11:39 <Araneidae> preflex, nickmeter Araneidae
02:12:01 <Araneidae> TMI ! ;)
02:12:16 <Araneidae> preflex, nickometer Araneidae
02:12:17 <preflex>  Araneidae is 0% lame
02:15:25 <ksf> do we have a TH processor to manage a zoo of adts that implement combinations of typeclasses which dub an aspect of the adt?
02:16:12 <ivanm> what is the general consensus of the new -fwarn-unused-do-bind that -Wall brings in for 6.12; worth following its suggestions or selectively disabling it for 6.12?
02:16:35 <ksf> ivanm, yes they're worth following
02:16:47 <ivanm> why?
02:16:55 <ksf> because it's better to be explicit
02:17:16 <ivanm> I _could_ go and do what it says, but then I'd just be duplicating a lot of my parser combinators (one that returns the value and one that returns ())
02:17:21 <ksf> you are, after all, executing a monadic action that has a return value for side-effect
02:17:33 <ksf> you could also use _ <-
02:17:38 <ivanm> which is fugly
02:17:50 <ksf> or do the right thing and use applicative
02:18:18 <ivanm> ksf: polyparse doesn't support applicative...
02:18:32 <ksf> pure = return, <*> = ap
02:18:34 * ivanm finds out from ghc's trac that ndm is to blame for it... :@
02:18:47 <ivanm> ksf: nope, polyparse doesn't support applicative _at all_
02:19:02 <ksf> every monad is an applicative functor.
02:19:05 <ksf> _every_.
02:19:06 <ivanm> IIRC, malcolmw said there was some inconsistency that doesn't work when you try to define the instances
02:19:12 <ivanm> ksf: only if you define it
02:19:19 <ksf> yes, and that's easy.
02:19:28 <ivanm> and there was something funky going on with polyparse's applicative instances
02:19:35 * ivanm trusts upstream on this over ksf
02:19:59 <ksf> then the monad must be broken in some way, too.
02:21:39 <ivanm> "<malcolm> yes, I nearly converted polyparse to have Applicative and Alternative, but there turns out to be a small technical problem"
02:22:13 <ivanm> ^^ not sure what the problem is though
02:22:39 <ivanm> note that the various Parse monads are ones where the fail function is actually _useful_ >_>
02:49:14 <ManateeLazyCat> Split gtk2hs repository is a good idea? What do you think?
02:51:31 <z1y> hi , i am trying to build gtk2hs. but it seems that the package doesn't understand `mv` command on freebsd system
02:52:09 <fasta> ManateeLazyCat, it is a good idea to make it installable with one command.
02:52:39 <ManateeLazyCat> z1y: I haven't FreeBSD, but you can ask this question on gtk2hs-list.
02:52:51 <fasta> ManateeLazyCat, that means cabal install gtk2hs should work on Windows, Linux, BSD and Mac.
02:52:55 <ivanm> z1y: what do you mean?
02:53:21 <z1y> ivanm: there some errors when trying `gmake install`. I will give the output soon
02:54:01 <fasta> And there should be no ways of failure other than possibly no Internet connection.
02:54:24 <z1y> ivanm: http://pastebin.com/apEc55ps (output of gmake install)
02:54:44 <fasta> People "compiling software" and tracking down environment bugs is wasteful.
02:54:46 <z1y> ManateeLazyCat: I am going to ask on that list now
02:54:48 <ManateeLazyCat> fasta: Axel plan split gtk2hs repository with many repositories to support cabal packages, and my solution is still keep one repository for developer maintain, we can use some script generate cabal pacakge for every sub-modules. Then user can use those cabal pacakge to install.
02:55:35 * z1y no irc channel gtk2hs-list :(
02:55:47 <ManateeLazyCat> z1y: I mean gtk2hs mail-list
02:55:49 <fasta> ManateeLazyCat, as long as there is still a way to get everything nobody cares.
02:56:20 <fasta> ManateeLazyCat, unless GTK2HS is going to be used on embedded devices.
02:56:55 <ManateeLazyCat> fasta: t
02:57:19 <ManateeLazyCat> My point is *one* repository for developer, manay smaller cabal release pacakge for user.
02:57:40 <fasta> ManateeLazyCat, that's what I would do.
02:58:03 <ManateeLazyCat> fasta: Because just *few* activate developer woking on gtk2hs, more repositories need more time to test.
02:58:19 <fasta> ManateeLazyCat, but both is fine too. What you do not want is manually do darcs get repo1; darcs get repo2
02:58:41 <ManateeLazyCat> fasta: I agree that use cabal build gtk2hs, but i disagree split darcs repository
02:59:49 <fasta> IMHO, a project should be managed such that communication is reduced to a minimum. Discussing things like "I don't have library package foo" installed, is completely useless.
03:00:06 <fasta> It is not hard to make it work everywhere.
03:00:51 <ManateeLazyCat> fasta: So you agree that split current gtk2hs with many smaller repositories?
03:01:38 <fasta> ManateeLazyCat, if on the developers website there is an up to date script to get all the repositories in one go, I don't care.
03:02:07 <ivanm> z1y: oh, the installer uses gnu-isms for mv?
03:02:17 <fasta> ManateeLazyCat, and there should be one command in the top directory of the repository stating something like "update all" or something like that, which fetches the latest script and executes that script.
03:03:10 <ivanm> ManateeLazyCat: split repos might be easier to package
03:03:21 <ivanm> because if it's in one big repo there might be cross-library contamination
03:04:12 <ksf> z1y, that {.tmp,} looks like a shell glob to me
03:04:30 <ManateeLazyCat> ivanm: But split repository is hard to cross-cutting patches/changes.
03:04:40 <ivanm> right
03:04:41 <fasta> Practically one big repo is easier.
03:04:53 <ivanm> so there's pros/cons either way
03:05:22 <ivanm> ManateeLazyCat: I think I'm with fasta on this: one big repo is in the long run probably going to be easier for developers
03:05:26 <ksf> maybe the script needs bash and make is using sh?
03:05:34 <ivanm> just have each lib in its own separate directory or something
03:05:41 <ManateeLazyCat> ivanm: So i suggestion that still use big repository, but add some script to rebuild cabal package for sub-module automatically.
03:05:44 <ivanm> ksf: sounds about right
03:06:05 <fasta> And if you don't want to discriminate Windows users, the script question is also out of the question, unless you write the script in Haskell.
03:06:06 <ivanm> ManateeLazyCat: hmmm..... scritps... >_>
03:06:10 <ivanm> *scripts
03:06:26 <fasta> (most don't install Cygwin/MingW)
03:06:40 <ivanm> fasta: how about perl? doesn't that come with GHC?
03:06:45 <ivanm> or isn't that accessible externally?
03:06:51 <ksf> anyway, the script should be easy to fix, just duplicate the mv
03:07:02 <ksf> arr no
03:07:05 <fasta> ivanm, uhm, I don't think there is is anything wrong with Haskell to write scripts like these.
03:07:12 <ksf> it's moving foo.tmp to foo
03:07:24 <ivanm> fasta: neither do I; I'm just suggesting possible alternatives
03:07:28 <ManateeLazyCat> ivanm: In current gtk2hs repository, gtk, glib, webkit, vte, sourceview, those sub-module is split in sub-directory, so it's easy to rebuild cabal package for every sub-directory.
03:07:45 <ManateeLazyCat> ivanm: But split repository is hard to maintain for developer.
03:07:50 <z1y> ksf: i am using bash and gmake
03:07:52 <ivanm> ugh, I was building a custom package the other day, and for the -l flags to gcc it was using `...` in the makefile to get the proper name from libsdl or something
03:08:22 <ksf> z1y, yes, but is gmake using bash?
03:08:36 <ManateeLazyCat> ivanm: IMO, user just need cabal package to install easily, they're don't care one repository or split repositories.
03:08:40 <ivanm> except it broke because libsdl spat out two library names and thus it wouldn't build (since something was added to the end of the result of the `...` but it ended up being added to the wrong one)
03:08:41 <ksf> that {.tmp,} syntax should work.
03:09:04 <ivanm> ManateeLazyCat: well, no, but I thought we were talking about developer viewpoint here
03:09:32 <ivanm> ksf: I wonder is the script doing that has #!/bin/sh instead of bash ...
03:10:12 <ksf> if it was a script, make wouldn't be outputting its contents
03:10:25 <ivanm> duh
03:11:09 <ManateeLazyCat> ivanm: Just *few* gtk2hs developers, so i afraid split main repository will waste much time, i don't know. Maybe it's a good idea.
03:11:33 <ManateeLazyCat> ivanm: If gtk2hs have so many developer like Gtk+ Team, i always agree split main repository.
03:11:37 <ivanm> ManateeLazyCat: I did say that overall I agreed with fasta that one repo is probably going to be easier/better... >_>
03:12:55 <fasta> Probably all of Hackage would fit in one repository.
03:12:55 <ksf> the only drawback a non-split repository has is that people have to pull the whole enchilada to get one package
03:13:17 <ksf> ...but that's not so bad, considering that there should be separate .tar.gzs available.
03:13:18 <fasta> OMG, that must be less than 10MB.
03:13:30 <fasta> Imagine the time it will take to download that.
03:13:42 <ivanm> ksf: and that you could have cross-library leakage
03:13:49 <ivanm> fasta: ?
03:14:04 <ivanm> ksf: but realistically the repo is for developers, not end users
03:14:13 <ksf> yep, exactly.
03:14:39 <ManateeLazyCat> ivanm: Yep, i agree, repo is for developer.
03:15:10 <ksf> as long as it's not a virtually unpullable darcs repository like ghc, I don't see any problems.
03:15:11 <fasta> I don't have an empty (there are object files) repo here, but all I am saying is that size is not that important.
03:15:32 <fasta> If darcs cannot scale, just use something else.
03:15:48 <ksf> tell that the ghc guys
03:15:51 <fasta> The Linux kernel seems to work fine with Git.
03:16:10 <ivanm> ksf: apparently, with latest darcs the ghc repo isn't meant to be too bad (if you use --lazy)
03:16:13 <fasta> Well, actually that's not true.
03:16:26 <fasta> Git has too many bad error messages.
03:16:27 <ksf> did they convert to darcs-2 by now?
03:16:28 <ivanm> which is why they didn't bother switching to git after they said they would
03:16:32 <ivanm> ksf: I think they did
03:16:44 <ksf> the last time I tried, I had to get the snapshot via http
03:17:00 <fasta> An advantage of Darcs is that at least the code is easy to read.
03:17:11 <fasta> Git is more like a braindump.
03:17:35 <ManateeLazyCat> fasta: :)
03:19:48 <ManateeLazyCat> ivanm: Update gtk2hs longer than expected.
03:20:04 <ManateeLazyCat> ivanm: I have finish 99.999%
03:20:10 <z1y> kfs and ivanm: the problem is that gmake doesn't understand braket {.tmp,} expansion. I update the `Makefile.in`, reconfigure and it's ok now.
03:21:00 <ManateeLazyCat> z1y: If you install gtk2hs successful, try demo/webkit
03:21:17 <ManateeLazyCat> z1y: I think webkit should okay on FreeBSD.
03:21:28 <z1y> ok I will try  it
03:21:55 <ManateeLazyCat> ivanm: Still need write some code by hand. :-(
03:22:21 * hackagebot haskell-src-exts-qq 0.1 - A quasiquoter for haskell-src-exts.  http://hackage.haskell.org/package/haskell-src-exts-qq-0.1 (MathieuBoespflug)
03:22:32 <z1y> uhm, I can't find webkit in demo/ directory
03:22:50 <ManateeLazyCat> z1y: Please use darcs version.
03:23:01 <ManateeLazyCat> z1y: Just darcs version support GHC-6.12
03:23:16 <z1y> ah... ok I will move to darcs :)
03:23:21 <ivanm> ManateeLazyCat: ummm.... he's finally managed to get gtk2hs to build and install, and now you want him to get it from darcs?
03:23:36 * ivanm still thinks that most users should only ever use release tarballs
03:23:44 <ManateeLazyCat> z1y: In darcs version, i have udpate 99% API to Gtk+ 2.18.3
03:23:53 <ivanm> and most _want_ to only use release tarballs
03:24:03 <ManateeLazyCat> z1y: Otherwise, you need use old API that just support Gtk+ 2.8
03:25:19 <ManateeLazyCat> ivanm: I know you mean, yes, release version is always good. But for current situation, darcs have so *much* new API, (see changes)
03:25:51 <ivanm> unless I missed something from before I came in, why _should_ z1y use the darcs version of gtk2hs?
03:25:58 <ivanm> is he using gtk2hs to develop something?
03:26:10 <ivanm> or is he just wanting to use it for e.g. pretty graphs in criterion?
03:26:13 <ManateeLazyCat> z1y: Which version your GHC?
03:26:35 <ivanm> if the latter, then there's no good reason to (but probably several good reasons _not_ to) use HEAD
03:26:39 <z1y> it's 6.10.4
03:26:42 <ManateeLazyCat> ivanm: gtk2hs-0.10 missing so many APIs.
03:26:46 <z1y> I use port from freebsd 8
03:26:49 <ivanm> ManateeLazyCat: he did manage to build it; it can't be 6.12
03:26:52 <ivanm> ;-)
03:27:09 <ivanm> ManateeLazyCat: yes, but are they _needed_? (in this specific case)
03:27:10 <ManateeLazyCat> z1y: If you just want to a try, gtk2hs-0.1 is okay.
03:27:23 <ManateeLazyCat> z1y: If you use GHC-6.12, you should use darcs version.
03:28:14 <ivanm> but he _isn't_
03:29:00 <ManateeLazyCat> z1y: Darcs version have new APIs, of course, choose your like.
03:29:42 <z1y> darcs requires latex stuff on my freebsd box :( it needs time to build
03:31:06 <ManateeLazyCat> z1y: Please report any problem on gtk2hs mail-list if you use darcs version, we will fix it as soon we can.
03:31:30 <ManateeLazyCat> gtk2hs-users@lists.sourceforge.net
03:33:07 <ivanm> z1y: disable building the docs then
03:33:20 <z1y> ManateeLazyCat: i've registered on that list. I will report any problem if any.
03:34:33 <z1y> I have to leave office now. See you all later.
03:47:34 * hackagebot dedukti 1.1.0 - A type-checker for the » -modulo calculus.  http://hackage.haskell.org/package/dedukti-1.1.0 (MathieuBoespflug)
03:50:52 <dcracked> hi
03:55:40 <mreh> hello
03:56:54 <dcracked> so whats up
03:57:07 <mreh> what up daaawg?
03:57:27 <liyang> Priests overseeing lesbian orgies, apparently.
03:57:57 <mreh> have you any "up dog" my good man?
03:58:19 <mreh> lol
03:58:35 <mreh> bank holidays are great
03:59:41 <mreh> how do you take the dot product of the addition of two vectors? and what about two inner products of a matrix and a vector (also a vector)
04:00:15 <mreh> I could sit here and prove it by hand
04:01:22 <Ke> o_O
04:01:46 <Ke> you have different concept of inner product than us mere mortals
04:02:19 <mreh> for example: inner product -> x'x, outer product -> xx'
04:02:44 <Jafet> Ke, maybe it involves monads
04:03:02 <mreh> it's not a haskell question, it's a haskell-blah question
04:03:16 <mreh> i thought while it was reasonably quiet I could get away with it
04:03:41 <Ke> so could you reformulate the question
04:04:30 <Ke> I guess you know how to add vectors and apply inner product
04:04:35 <mreh> okay, I'll give an example: what is <y-Xw,y-Xw>
04:05:55 <mreh> that's linear least squares
04:05:57 <Ke> If it's with real field <y,y> -2<y,Xw>+<Xw,Xw>
04:06:27 <mreh> yes, its within the reals
04:06:56 <mreh> welcome to the matrix *chuckle*
04:07:59 <mreh> so (Xw)' == (w'X')
04:08:18 <Ke> yup
04:09:01 <crc__> is there a way to have multiple patterns in a single lambda, like (\1->1 ;\2->2) or something like that
04:09:17 <Jafet> case
04:11:58 <ivanm> crc__: if it's that complicated, using a lambda is probably the wrong thing to do
04:13:30 <Jafet> Syntactic sugar, saccharine, or NutraSweet (R)?
04:14:24 <HugoDaniel> hello
04:20:00 <ksf> is System.Posix.Types.CSSize meant to be size_t?
04:20:19 <mux> no, that would be CSize; CSSize is ssize_t
04:20:52 <ksf> ...which presumably is in Foreign, not Posix
04:21:09 <mux> yep, since it's a C type, unlike ssize_t which is a POSIX addition
05:02:04 <dobblego> @src filteRM
05:02:05 <lambdabot> Source not found.
05:02:06 <dobblego> @src filterM
05:02:06 <lambdabot> Source not found. Sorry.
05:12:49 <zakwilson> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24596#a24596 <-- I'm having some confusion with if-then and do blocks. Would someone care to tell me what's wrong with this contrived example?
05:17:59 <burp> I think else can't be indented along with if
05:18:27 <temoto> Yup else can't be indented along with if, it's ugly but known issue.
05:18:45 <burp> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24596#a24597
05:18:49 <burp> I'd probably write it like this
05:19:51 <temoto> zakwilson, 'then' can't be indented along with 'if' too.
05:23:24 <zakwilson> burp: thanks. I tried indenting "then do" on the next line, but Emacs didn't want to indent it more than if, and I assumed Emacs knew what it was doing.
05:30:34 <sori> Would be there a better terminology to say that        f :: Int -> Int        is a "concrete instantiation" of the polymorphic function       f :: a -> a        ?
05:32:43 <Mathnerd314> no, because f :: a-> a must be id, whereas f :: Int -> Int could be f x = x+x
05:32:53 <Mathnerd314> so they're different functions
05:33:17 <Mathnerd314> f :: a -> a is f :: forall a. a->a
05:34:13 <sori> Oh, I'm sorry, I had to be more careful. I mean, given a (defined) polymorphic function      f :: a -> a,        how could I best call the expression        (f :: (Int -> Int))     ?
05:38:04 <EvanR> @src map
05:38:05 <lambdabot> map _ []     = []
05:38:05 <lambdabot> map f (x:xs) = f x : map f xs
05:38:26 <EvanR> @src filter
05:38:26 <lambdabot> filter _ []     = []
05:38:26 <lambdabot> filter p (x:xs)
05:38:26 <lambdabot>     | p x       = x : filter p xs
05:38:26 <lambdabot>     | otherwise = filter p xs
05:38:48 <Philonous> sori: I think it is called type specialization, might be wrong, I'm not sure, though
05:38:54 <pastorn> sori: i would say that (Int -> Int) is a "specific" type signatur while ((Num a) => a -> a) is a general type signature
05:39:23 <pastorn> but that's just my home made semantics...
05:39:30 <sori> Ahh,, thank you,, Both terms are nice, I think :)
05:39:51 <pastorn> sori: say what you want as long as you stay unambiguous when you say it :)
05:41:04 <sori> pastorn, okay, thanks!:)
05:41:07 <Philonous> sori: The GHC manual uses it in the context of ad hoc polymorphism (type classes).
05:41:32 <sori> Philippa, okay.. I'll look at it :)
05:41:53 <sori> (ah sorry, it was to philonous)
05:42:41 <Philonous> sori: Don't bother, it's a rather technical detail. I just recycled the terminus.
05:43:21 <sori> :)
05:53:49 <ksf> sori, concrete types
05:54:15 <ksf> we've got concrete types, type variables and rigid type variables
05:55:06 <ksf> ...where rigid means that you can't make the variable concrete, that happens in a couple of cases with adts or explicit type signatures
05:55:32 <ksf> as in foo :: a; foo = True, 'a' is too rigid to become 'Bool'
05:55:44 <dankna> usually to me, in cases where I don't understand why :)
05:56:40 <sori> ksf: ah, I see. Thanks. I was always wondering what rigid type variables (occuring in the error messages ...) are..
05:56:47 <ksf> the key point is that polymorphism is actually just semantic sugar: every program, once compiled, has completely concrete types throughout.
05:57:20 <dankna> even true if it uses existential quantification, sorta
05:57:41 <sori> Okay,, I was solving a question of the form "what is the most general type of the following definition of a function?"
05:57:59 <dankna> that's not a very Haskell kind of question
05:58:18 <ksf> we've got type inference to do that kind of thing
05:58:43 <sori> yeah it's quite in the context of type inference
06:01:01 <liyang> Mmmâ€¦ delicious semantic sugar.
06:02:26 <edwardk> Yay! My QSAT monad made its first round trip out to minisat and back.
06:02:35 <twink> QSAT being?
06:02:59 <edwardk> http://en.wikipedia.org/wiki/True_quantified_Boolean_formula
06:03:50 <edwardk> given a boolean formula with existential and universal quantifiers, given back a consistent set of boolean values
06:04:34 <edwardk> er give back
06:05:59 <edwardk> twink: there are a number of SAT/QSAT solvers, including at least one or two in haskell, most of them take input in dimacs/qdimacs format. so it gives me a pluggable interface to talk to
06:06:04 <temoto>  <socket: 8>: hGetLine: end of file     How to catch explicitly this error?
06:06:18 <bremner> edwardk: does minisat do qsat directly?
06:06:19 <edwardk> wrapping up the encoding and decoding of various types of values
06:07:43 <temoto> I have basically something like foo `catch` putStrLn . show    and i want to skip normal disconnects and print real errors.
06:07:43 <twink> Okay, I'm good with the 'Q' in QSAT.
06:07:57 <edwardk> bremner: iirc not directly,, but there are a number of them layered on top of it
06:08:21 <edwardk> i.e. http://skizzo.info/
06:08:21 <bremner> edwardk: ok, thanks
06:08:44 <EvanR> whats the difference between let and letrec, haskell only has one, can we emulate the other?
06:08:59 <twink> Every let is a letrec in Haskell
06:09:01 <edwardk> EvanR: we only have letrec
06:09:22 <EvanR> is it possible to do a let
06:09:27 <edwardk> EvanR: the compiler figures out if the binding is recursive. the only caveat is it is tricky to write a function that references something in scope that has its same name.
06:10:05 <edwardk> when you need a let over a letrec it is only because you want to shadow a variable name, which you can fix by alpha renaming
06:10:13 <EvanR> ah
06:10:31 <edwardk> if you want 'let', then work in the Identity monad using do sugar.
06:10:34 <EvanR> yeah, i dont like forms like let x = f x where x is not x ;)
06:10:52 <EvanR> i avoided those in js
06:11:13 <edwardk> foo x = runIdentity $ do x <- return (x + 1); x <- return (x + 1); return (x +1)
06:11:22 * dankna blinks!
06:11:25 <dankna> that's a neat trick
06:11:45 <EvanR> interesting
06:12:12 <edwardk> that works because each of those becomes a nested lambda which isn't in scope during the right hand side
06:12:25 <edwardk> @undo do x <- return (x + 1); x <- return (x + 1); return (x + 1)
06:12:25 <lambdabot> return (x + 1) >>= \ x -> return (x + 1) >>= \ x -> return (x + 1)
06:12:59 <EvanR> @src forever
06:12:59 <lambdabot> Source not found. Do you think like you type?
06:13:17 <Aristid> edwardk: lambdabot can't optimise these things, it seems ;)
06:13:20 <edwardk> you can also emulate let with (\x -> ...) (x + 1) -- and in the ... you'll have the x you want
06:13:35 <ddarius> Also case.
06:13:40 <EvanR> got it
06:13:47 <edwardk> ddarius: yeah
06:13:55 <dankna> also if you're already in a monad you can just use return, haha
06:14:10 <edwardk> or, ironically, 'let' ;)
06:14:13 <dankna> yes, haha
06:15:23 <edwardk> though that one still has self-capture issues
06:16:01 <dankna> yes
06:16:15 <dankna> I actually ran into a situation where I wanted to do this just yesterday
06:16:23 <dankna> but I wound up using the foo, foo', foo'' notation instead
06:16:29 <dankna> I figured it was more Haskelly
06:16:38 <fax> hi
06:17:07 <dankna> 'lo
06:18:20 <fax> In addition to the mobile website, weâ€™ve changed the price of the Wolfram|Alpha App for the iPhone and iPod touch to $1.99, down from $49.99.
06:18:31 <fax> why is it not free? :S
06:18:35 <edwardk> hah
06:18:37 <fax> it's just a freaking webtise
06:18:40 <dankna> are we sure that wasn't April Fools?
06:18:56 <edwardk> dankna: that would presuppose that wolfram has a sense of humor
06:19:01 <dankna> true.
06:19:05 <dankna> I retract the question :)
06:19:52 <fax> http://m.wolframalpha.com/
06:20:04 <fax> so goddamn confusing
06:20:21 <dankna> yeah.... it really needs to not have the natural-language query component :(
06:20:28 <dankna> as it's not very, er, natural for the problem domain
06:20:36 <fax> I really want to make an algebra system in haskell
06:20:41 <dankna> it's a set of very useful tools unified by an un-useful interface
06:20:48 <Jafet> dankna: who are you to question the great Stephen Wolfram, inventor of everything
06:21:04 <dankna> I'm not questioning him, I'm statementing him
06:21:04 <fax> the problem is that it's so much work to just get /started/ AND you have to everything correctly
06:21:27 <dankna> fax - agreed.  it's a natural kind of thing to want to do in Haskell, it would be a great fit for the type system, but it's a huge amount of work.
06:21:51 <dankna> I wonder if it might almost be easier to write an idiomatic C->Haskell translator and start from the GNU CAS :)
06:21:56 <dankna> (I forget what it's called)
06:22:14 <Jafet> fax, start with SICP's differentiator!
06:22:18 <edwardk> dankna: octave or yacas or one of those?
06:22:22 <dankna> yeah, one of those
06:22:40 <fax> and if you try to build up algebra in one of these type theories you quickly start sinking into the quicksand
06:23:02 <edwardk> fax: clearly you should build it on my cheesy sat solving monad ;)
06:23:05 <Jafet> Then add that complicated elementary integration algorithm
06:23:23 <Jafet> Only if you extend it to DPLL/SMT.
06:23:25 <edwardk> Jafet: heh
06:24:10 <edwardk> Jafet: its pluggable, it just calls out using dimacs to an external solver, so, sure. ;)
06:24:33 <Jafet> Agh, cheating scum
06:24:45 <edwardk> =)
06:24:56 <edwardk> i still have to marshal everything in and out of fresh variables, etc.
06:25:28 <Jafet> Octave is some mediocre clone of matlab
06:25:40 <Jafet> You could start near pari/gp, which is more discrete math oriented
06:26:01 <dankna> yay for discrete math.  that is all I have to say about this. :)
06:26:36 <fax> do math discretly my lord
06:36:49 <mreh> good clone of MATLAB, isn't that an oxymoron
06:36:55 <mreh> MATLAB will always be mediocre
06:37:48 <dankna> why do you say that?
06:37:56 <dankna> note: I'm not familiar with it, I'm just curious
06:38:38 <fax> http://math.ucr.edu/home/baez/platonic.html
06:38:55 <mreh> dankna: because everything is not a Matrix :)
06:39:11 <dankna> haha
06:39:12 <dankna> fair nuff
06:39:16 <mreh> and it's quite tough to work with, the libraries are very baroque
06:39:31 <chrisdone> so does GHC inline away "a $ b" to "a (b)"?
06:39:47 <dankna> *nod*
06:39:51 <dankna> fax: neat!
06:39:58 <dankna> chrisdone: I believe so
06:40:05 <chrisdone> believe or know? :p
06:40:07 <mreh> why do Arrows work where Monads don't? I think I missed the point of this Hughes paper, it's more like a pamphlet!
06:40:08 <Jafet> mreh, so what is your opinion of APL
06:40:09 <fax> I like this bit: 'You might things would keep getting more complicated in higher dimensions. But it doesn't! 4-dimensional space is the peak of complexity as far as regular polytopes go. From then on, it gets pretty boring. This is one of many examples of how 4-dimensional geometry and topology are more complicated, in certain ways, than geometry and topology in higher dimensions. And the spacetime we live in just happens to be 4-dimensional. Hmm.'
06:40:16 <mreh> Jafet: I have none
06:40:21 <dankna> yeah, that is indeed interesting
06:40:22 <Jafet> Okay
06:40:28 <dankna> I've seen that observation before
06:40:30 <dankna> but it's still interesting
06:40:34 <mreh> Jafet: what is APL?
06:40:43 <Jafet> A programming language
06:40:47 <dankna> A Programming Language
06:40:49 <mreh> what does it stand for?
06:40:51 <fax> APL is so freaking cool but it's to old to make use of
06:40:53 <mreh> lol
06:40:55 <fax> just learn J
06:40:59 <dankna> haha
06:41:07 <EvanR-work> K
06:41:08 <fax> it uses ASCII instead of the heiroglyphics
06:41:30 * dankna mind-boggles at the hyperdodecahedron
06:41:37 <Jafet> J is a mass-market trade paperback commercial edition of APL. Like a Tolkien book with the Black Speech excerpts romanized.
06:41:38 <SamB_XP> which saves a lot of font setup and suchlike ;-)
06:41:53 <Jafet> One thesis of Iverson was that notation influences thought.
06:44:02 <SamB_XP> did iverson write any tutorials about setting up apps to render the APL characters correctly without screwing up the rest of unicode?
06:44:50 <fax> that GNU APL should work fine I think
06:44:55 <EvanR-work> i dont know about notation influencing thought
06:46:05 <Jafet> Unicode didn't quite exist in the time of APL
06:47:42 <SamB_XP> Jafet: you don't think I know that?
06:48:20 <xerox> dankna: you might enjoy coxeter biography on the mathematicians' biography project :)
06:48:30 <dankna> xerox: oh?
06:49:56 <xerox> there's a funny story on how he was fascinated by the fourth dimension and its polyhedra, but the tutor his family got for him (being a gifted child) forced him to do "real" maths during the week and Â«the fourth dimension only in the weekendsÂ» :D
06:50:16 <dankna> haha
06:50:19 <dankna> that IS amusing
06:50:29 <fax> hehe
06:50:54 <xerox> he was "the Last Geometer" :) http://www-history.mcs.st-and.ac.uk/Biographies/Coxeter.html
06:51:35 * dankna chortles at "H M S Coxeter made him sound like a ship"
06:52:36 <xerox> or maybe it was the review by ams hmm
06:52:38 <chrisdone> EvanR-work: well, language helps you compact thoughts into smaller thoughts, so it makes sense that the syntax will affect this
06:53:44 <EvanR-work> maybe, but once you know everything, switching around the notation a lot leaves you with the same result
06:54:16 <EvanR-work> theres something behind the notation which must be
06:55:04 <EvanR-work> look at all the different equivalent ways to do universal computation
06:55:26 <xerox> or maybe this one http://www.jstor.org/pss/3026700
06:55:26 <chrisdone> but that's irrelevant
06:55:37 <SamB_XP> EvanR: so what ?
06:55:42 <SamB_XP> why do you use Haskell rather than C?
06:55:57 <EvanR-work> so the thought is the same, we have different notation
06:56:37 <EvanR-work> the equivalent solutions in c are huge
06:56:40 <Jafet> If there is any study of the Sapir-Whorf hypothesis, it is going to come from studying programmers.
06:56:59 <dankna> haha
06:57:19 <Jafet> EvanR, that is an incorrect generalization.
06:57:25 <fax> "scientists have (sadly) discovered that only the negation of the Sapir-Whorf hypothesis holds"
06:57:50 <fax> i.e. learning weird languages breaks your brain
06:57:56 <Jafet> Gee, these unnamed scientists again.
06:58:14 <fax> nobody is going to listen to me if I pretend it's my own idea Jafet, come on!
06:58:18 <chrisdone> Jafet: I was once an unnamed scientist
06:58:46 <Jafet> Interesting; how did you get named?
06:58:55 <SamB_XP> chrisdone: how did you IRC without a name ?
06:59:05 <chrisdone> couldn't cope with trying to communite with the other unnamed scientists
06:59:14 <chrisdone> communicate
06:59:43 <Jafet> But IRC is largely multicast.
07:00:00 <chrisdone> Jafet: learning lojban wrecked my english vocabulary for a while
07:01:45 <EvanR-work> the pattern [x] matches a list with one thing. x:_ matches a list with at least one thing, is x:_ the only pattern for this?
07:01:47 <chrisdone> couldn't remember simple words like 'fork'. 'cause in lojban that's food-tool
07:01:51 <mlesniak> I have a problem with Haskell's type inference while using type classes and a State Monad transformer. I'd really appreciate it, when someone could look at the code underhttp://hpaste.org/fastcgi/hpaste.fcgi/view?id=24600#a24600
07:01:56 <fax> lol
07:02:07 <fax> 'that you use to ... dig... food'
07:02:10 <chrisdone> hahaha
07:02:36 <fax> EvanR, yes
07:04:05 <EvanR-work> is it good practice to have a pattern for every possible input
07:04:13 <fax> EvanR, not imo
07:04:39 <EvanR-work> i suppose in many cases the right thing is error
07:04:45 <EvanR-work> which happens automatically
07:06:07 <fax> mlesniak, just annotate a with Maybe Int
07:06:12 <fax> like this:  (a::Maybe Int) <- get
07:06:42 <EvanR-work> what about a <- get :: IO (Maybe Int)? i guess the first one is shorter?
07:06:57 <mlesniak> fax: but what if I don't want to annotate it, since a) it should work for arbitrary type classes?
07:07:05 <edwardk> dankna: i dogeared a couple of 50-60 year old books by coxeter, doing my thesis. ;)
07:07:06 <mlesniak> fax: and not only for int
07:07:14 <dankna> edwardk: cool cool :D
07:07:24 <fax> "but what if I don't want to annotate it" tough!
07:07:42 <edwardk> dankna: his was the last reference to study coordinates in any mathematical reference i could find
07:08:01 <dankna> fascinating
07:08:25 <mlesniak> fax: yes, imagine I have other type classes which return something else than Int (which in fact I have in my real problem) ;)
07:08:50 <mlesniak> fax: that should be independent of get's definition, especially since it seems to be not difficult to inference.
07:08:52 <fax> mlesniak - I think you probably attack this problem the wrong way
07:09:00 <edwardk> dankna: which made things rough for me, because i'd rediscovered them in oriented projective geometry, but OPG wasn't around until well after he stopped writing.
07:09:02 <mlesniak> fax: any pointers to other approaches?
07:09:08 <fax> mlesniak what are you trying to do
07:09:11 <dankna> yeah, I see how that would be a problem
07:09:13 <EvanR-work> fax: i tried  (ref :: IORef [Foo]) <- newIORef [], it says illegal signature in pattern
07:09:33 <EvanR-work> use -XScopedTypeVariables to permit it
07:10:11 <mlesniak> fax well, exactly what is stated there (only the example is smaller): have a StateT monad which encapsulates a state and a type class that works on instances of this state
07:10:39 <fax> mlesniak yeah I just dont really see it -- what's the purpose of such?
07:11:27 <mlesniak> fax on a more high level: encapsulate a state but also have functions for each type of state defined in a type class: imagine having taskpools: we encapsulate state to hide implementation issues but all taskpools should define functions get and put
07:12:17 <fax> what does encapsulate mean?
07:12:18 <mlesniak> fax and I want to transparently switch pools, the get and put should work nonetheless
07:12:28 <mlesniak> fax hide it from the user
07:12:33 <fax> :S
07:12:50 <fax> this is not terms I am comfortable with
07:13:01 <fax> you can probably use a value to represent a pool
07:13:03 <fax> rather than a typeclass
07:13:14 <mlesniak> hmmm, have to think about this
07:13:36 <mlesniak> fax do you have more references? some links/blog posts, ...?
07:13:39 <fax> no
07:14:16 <mlesniak> I mean, passing the information directly to get works, but does not hide the details of each taskpool... :/
07:14:32 <fax> what is all this deceitfulness for?
07:15:24 <mlesniak> by passing taskpool specific informations in the state we can switch taskpool implementations without changing the other code...
07:15:25 <fax> hiding things from someone will just make it difficult for them
07:16:05 <mlesniak> well, the user should not see implementation details, so we can change them without changing the interface...
07:16:19 <fax> by 'user' you mean programmer?
07:17:01 <mlesniak> for example. imagine my approach works.
07:17:05 <fax> I would consider implementation details one of the key things which she works with
07:17:35 <mlesniak> let's not discuss the approach I have but rather if its possible ;)
07:17:55 <mlesniak> I'm probably not fluent enough in english to explain it thoughfully
07:18:24 <fax> mlesniak, why don't you write in haskell like how it SHOULD be -- even if it is not implemented
07:18:36 <mlesniak> ?
07:19:11 <fax> I mean to sketch the concept of it, before geting into implementation
07:20:33 <mlesniak> which I did. each taskpool (continuing my example) has functions get and put. but they also have other taskpool-dependent informations. one way to pass them is to use a StateT transformer and hide it. because, from a taskpool users point of view they are not relevant. the user just uses get and put...
07:20:48 <fax> yeah but I don't get that example and it only has one pool afaict
07:21:41 <mlesniak> fax that's why its a minimal example. posting my whole research code (about 2500 loc) wouldn't make much sense I think... if I could make this small example run, my other problems would be solved, too
07:22:30 <mlesniak> and I think I have stated, what I want to achieve. Using StateT and tyepclasses...
07:23:43 <mlesniak> anyway, I'll probably have to continue thinking about it a bit more but for now I have reached my end of work for today. happy eastern to all of #haskell
07:24:46 <EvanR-work> happy western to everyone else
07:27:43 <benmachine> I see what you did there
07:27:57 <EvanR-work> i know righ
07:34:18 <tilman> (16:28) -!- visof [~visof@41.206.150.171] has quit [Ping timeout: 265 seconds]
07:34:18 <tilman> (16:31) -!- ErhardtMundt [~Laurence@87.18.74.7] has quit [Ping timeout: 276  seconds]
07:34:41 <tilman> yay trackpad
07:35:02 <xerox> ?arr
07:35:02 <lambdabot> Yo ho ho, and a bottle of rum!
07:35:51 <Botje> @vixen where'd all the rum go?
07:35:52 <lambdabot> why don't you guess?
07:36:47 <fax> @nixon
07:36:47 <lambdabot> If you think the United States has stood still, who built the largest shopping center in the world?
07:37:23 <xerox> fax: did you do your exercises
07:38:14 <fax> xerox I did do one
07:38:45 <fax> eventually....
07:38:55 <xerox> it's been two days
07:43:12 <EvanR-work> whats that vim mode that makes tabs work nice in haskell, smarttab something
07:43:27 <dmwit> omnicomplete?
07:43:43 <EvanR-work> tab puts spaces, but backspace treats it like a tab
07:43:54 <dmwit> :help 'sts'
07:44:01 <dmwit> oh
07:44:01 <FliPPeh> > let s = "/home/flippeh/whereisyourgodnow.txt" in drop 1 . snd . flip splitAt s . last . elemIndices '/' $ s
07:44:02 <liyang> soft tabs
07:44:02 <lambdabot>   "whereisyourgodnow.txt"
07:44:09 <EvanR-work> ah
07:44:09 <FliPPeh> Is there an easier way for it?
07:44:29 <mauke> FliPPeh: there's probably a module for that
07:44:42 <FliPPeh> mauke: But it has to work for URLs
07:44:49 <FliPPeh> I know there's a File module
07:45:04 <mauke> there's probably a URL module too
07:45:11 <FliPPeh> I'll see Network.URI
07:45:48 <liyang> > let s = "whereisyourgodnow.txt" in drop 1 . snd . flip splitAt s . last . elemIndices '/' $ s
07:45:49 <lambdabot>   "* Exception: Prelude.last: empty list
07:46:08 <FliPPeh> liyang: I have that covered with a pattern match :)
07:46:29 <FliPPeh> s/pattern match/function guard/
07:46:50 <Botje> FliPPeh: tail . last . filter (\xs -> not (null xs) && head xs == '/') . tails
07:47:17 <liyang> > (reverse . takeWhile (/= '/') . reverse) "/home/member:flippeh/whereisyourgodnow.txt"
07:47:18 <lambdabot>   "whereisyourgodnow.txt"
07:47:46 <liyang> Wat. Where'd that member: come from?
07:47:55 <FliPPeh> dunno :d
07:48:06 <mreh> political metasynthetic variables are a taboo
07:48:22 <FliPPeh> Hmm, I didn't think about double reversing
07:48:33 <FliPPeh> Actually pretty easy
07:48:34 <liyang> Covers all cases. :3
07:48:37 <FliPPeh> and fail proof :)
07:48:46 <McManiaC> FliPPeh: there is also System.FilePath
07:48:48 <EvanR-work> i like fail proof ;)
07:49:03 <FliPPeh> McManiaC: Yup, but this is primary aimed at URLs
07:49:19 <McManiaC> > splitFilePath "/home/member/whereisyourgodnow.txt"
07:49:20 <lambdabot>   Not in scope: `splitFilePath'
07:49:36 <McManiaC> > System.FilePath.splitFileName "/home/member/whereisyourgodnow.txt"
07:49:37 <lambdabot>   Not in scope: `System.FilePath.splitFileName'
07:49:42 <McManiaC> hm
07:49:59 <McManiaC> takeFileName actually
07:50:28 <McManiaC> FliPPeh: I dont see why this shouldnt work for URLsâ€¦
07:50:47 <McManiaC> Prelude System.FilePath> takeFileName "www.foo.bar/moep.txt"
07:50:47 <McManiaC> "moep.txt"
07:50:49 <FliPPeh> McManiaC: It actually does work for URLs
07:50:58 <FliPPeh> But it feels wrong :D
07:51:00 <McManiaC> :>
07:51:01 <liyang> McManiaC: unless you're on Windows.
07:51:07 <FliPPeh> Oh yeah, and that
07:51:26 <liyang> Or old-skool Mac. :3
07:52:01 <FliPPeh> The ones with one mouse button?
07:52:22 <liyang> As opposed to the ones with no mouse buttons, yes.
07:52:45 <McManiaC> liyang: according to haddock documentation this should work on windows too
07:52:58 <McManiaC>  Posix:   splitFileName "/" == ("/","")
07:53:00 <McManiaC>  Windows: splitFileName "c:" == ("c:","")
07:53:19 <FliPPeh> @src System.FilePath.takeFileName
07:53:19 <lambdabot> Source not found. Just try something else.
07:53:21 <FliPPeh> Meh
07:53:33 <Zao> McManiaC: I believe the point is that it'll fail on URLs on Windows, as it assumes \ to be separator there.
07:53:36 <FliPPeh> liyang: But not for "takeFileName"
07:53:43 <McManiaC> Zao: oh hm right
07:53:50 <FliPPeh> As, like Zao just said, the separator.
07:53:53 <Zao> Assumedly, I didn't check the sauce.
07:54:52 <FliPPeh> I could never again get used to Window's way of handling drives and partitions
07:54:59 <FliPPeh> Letter enumeration, seriously
07:55:03 <ManateeLazyCat> Have any Haskell-Cafe admin at here?
07:55:07 <ManateeLazyCat> My mail was rejected automatically.
07:55:18 <FliPPeh> I'm happy I made the complete move to linux some months ago
07:55:23 <fasta> Looks like the Simons have some work to do: http://shootout.alioth.debian.org/u32q/program.php?test=threadring&lang=gcc&id=3
07:55:34 <ManateeLazyCat> Said: "You are not allowed to post to this mailing list..."
07:55:36 <fasta> http://shootout.alioth.debian.org/u32q/benchmark.php?test=threadring&lang=all
07:56:00 <Jafet> The price to pay for type safety!
07:56:02 <fasta> Basically on the threadring benchmark gcc is 4 times faster than GHC.
07:56:03 * Jafet coughs
07:56:16 <dankna> "a small constant factor" :)
07:56:28 <fasta> It should be faster if you have more type information.
07:56:35 <fasta> Otherwise you are just writing a crappy compiler.
08:00:00 <ManateeLazyCat> fasta: But Haskell is damn fast from that table.
08:00:10 <mercury^> That benchmark is meaningless.
08:00:38 <fasta> ManateeLazyCat, that's not how I interpret it.
08:00:56 <fasta> mercury^, because?
08:01:10 <mercury^> I've been over this before.
08:01:13 <mercury^> Even talking to you I think.
08:01:18 <mercury^> Don't want to repeat it every 6 months.
08:01:32 <fasta> The GHC developers even want to cheat on these benchmarks and they are still not the fastest.
08:01:36 <maltem> fasta: Did the timings get worse with ghc 6.12?
08:01:43 <maltem> for this particular benchmark
08:01:56 <fasta> maltem, there was something on the mailing lists about that, yes.
08:03:05 <maltem> I'm surprised, I would have thought the thread performance is only bound by the GHC scheduler, and I didn't hear of significant changes there
08:03:22 <ManateeLazyCat> mercury^: Can you explain your point simple? I'm curious.
08:04:25 <benmachine> mercury^: every 6 months isn't that much to ask really :P
08:04:28 <dankna> so... is the purpose of the Fix monad that it can be used as a base monad in a stack when you only have a transformer and want to turn it into a base monad?
08:04:38 <dankna> ie ErrorT Fix?
08:04:48 <benmachine> dankna: that sounds like Identity
08:04:52 <dankna> oh, okay
08:04:53 <dankna> thanks
08:05:04 <benmachine> dankna: never heard of Fix
08:05:34 <mercury^> ManateeLazyCat, benmachine: as with most benchmarks on that site, the goal is not to measure the solution to a real problem, but to write something that fits arbitrary, underspecified and non-telling execution schemes.
08:05:43 <FliPPeh> What would one have to do to get predictable file IO? The problem I'm facing right now is that functions like readFile do not close the file, because they're lazy. Will I get around this with a strict type like ByteString?
08:05:48 <benmachine> mercury^: oh yeah, I've heard that
08:06:00 <benmachine> mercury^: see, that wasn't so hard? see you in another six months :P
08:06:16 <benmachine> fasta: hey, but the GHC solution uses six times less memory, and six is bigger than four
08:06:36 <mercury^> In this case for example the "best" solution is to implement minimal threading functionality that serves nothing but to be fast on the operations the benchmark demands.
08:06:36 <fasta> mercury^, yes, I can imagine I even agreed with you on that.
08:06:39 <maltem> dankna, there is no "fix monad". (MonadFix is a typeclass)
08:06:43 <benmachine> (the C++ beats us on every count though, how embarassing)
08:06:44 <mercury^> fasta: no, you did not.
08:06:44 <dankna> oh.  okay :)
08:06:48 <EvanR-work> FliPPeh: yeah theres bytestring readFile, but also regular read operations which work normally
08:06:54 <EvanR-work> hGetLine, hGetChar
08:06:57 <fasta> mercury^, then you have to show the logs.
08:07:05 <fasta> mercury^, since Google doesn't find them.
08:07:16 <FliPPeh> EvanR-work: so recursing hGetChar and appending to a list would work?
08:07:17 <benmachine> who cares who agreed with who six months ago?
08:07:23 <benmachine> we agree now, that is the important thing
08:07:30 <EvanR-work> FliPPeh: sounds lazy to me
08:07:50 <EvanR-work> but you can force that whole list to be evaluated
08:08:03 <fasta> benmachine, it is entertaining to see my own stupidity if in fact that existed.
08:08:03 <FliPPeh> Mhh
08:08:09 <benmachine> FliPPeh: yes that will work, although you have to make sure you're sensible at EOF
08:08:11 <maltem> FliPPeh, just don't use Prelude.readFile, Prelude.getContents, Prelude.hGetContents, and the corresponding functions for lazy ByteStrings. Everything else should do.
08:08:16 <FliPPeh> The main problem is that "semi-closing"
08:08:31 <FliPPeh> Because whenever I try to re-open that file, it goes boom
08:08:32 <fasta> mercury^, but shouldn't a good compiler compile away all cruft?
08:08:51 <mercury^> Huh?
08:08:52 <fasta> That is, partially evaluate the run-time system?
08:08:53 <EvanR-work> FliPPeh: perhaps readFile, then 'force evaluation' of the string, and then close the file
08:09:03 <EvanR-work> seq?
08:09:11 <benmachine> fasta: I think JHC does something like that
08:09:16 <mercury^> You cannot possibly expect a compiler to find an optimal threading implementation for a specific program.
08:09:21 <benmachine> fasta: but I imagine it's not easy
08:09:37 <fasta> mercury^, oh, I am sure you can. It is just that people generally don't want to wait that long.
08:10:06 <benmachine> fasta: no-one thinks GHC is perfect, it has bugs and performance regressions like anything else
08:10:21 <benmachine> if what you're trying to say is that it should be faster, well, that's true
08:10:28 <benmachine> but we already knew that
08:10:39 <jmcarthur> i want JHC to get mature
08:10:54 <fasta> jmcarthur, you mean more extensions?
08:11:07 <jmcarthur> i meant not generating executables that crash or do incorrect things
08:11:10 <maltem> FliPPeh, I'd use strict bytestrings for most I/O anyways, unless the code is already written to work with Strings
08:11:11 <benmachine> heh
08:11:12 <benmachine> that would help
08:11:20 <fasta> jmcarthur, ok, I thought it already was passed that.
08:11:25 <FliPPeh> kay :)
08:11:32 <FliPPeh> Thanks for helping out
08:11:33 <jmcarthur> fasta: if it does that it's a recent development
08:11:35 <fasta> I think I tried jhc once.
08:11:39 <fasta> jmcarthur, it is not.
08:12:00 <mercury^> How can you tell that it will never generate incorrect programs by trying it once?
08:12:15 <jmcarthur> i've tried JHC many times over the last few years and it generated incorrect binaries every time except for the simplest of programs
08:12:32 <mercury^> Is it still developed though?
08:12:38 <mercury^> I thought only LHC was developed.
08:12:39 <jmcarthur> yeah it's still actively developed
08:12:53 <jmcarthur> LHC is a fork because it has different goals and approaches
08:12:58 <jmcarthur> but JHC is still active
08:13:04 <mercury^> But LHC has little to do with JHC now anyway.
08:13:13 <benmachine> the large hadron compiler
08:13:35 <mercury^> lemmih's hadron collider
08:13:39 <forrest> I have installed the haskell platform in linux on a drive owned by me other than my home directory, but cabal wants to put stuff in $HOME/.cabal -- is there a way to tell it to install elsewhere?
08:13:51 <forrest> like where i have my haskell?
08:14:17 <jmcarthur> yeah LHC has continued to drift away from JHC
08:14:18 <benmachine> forrest: try looking at .cabal/config
08:15:03 <Zao> benmachine: Requires you to have a .cabal though, but yeah.
08:15:18 <benmachine> Zao: well, I think you need one anyway
08:15:30 <benmachine> cabal wants you to have a config file
08:15:39 <mercury^> On performance though: in my experience, if there was a good and fast array (+string) library, GHC would be fine.
08:15:43 <forrest> i can live with the .cabal dir in my home directory, as long as it's relatively small
08:15:57 <jmcarthur> mercury^: does vector not satisfy that need?
08:16:05 <benmachine> forrest: uncomment the user-install: True line in .cabal/config and change it to False
08:16:09 <Zao> benmachine: You could always hack the cabal-install source to have it elsewhere, I guess.
08:16:16 <benmachine> then edit install-dirs global if necessary
08:16:17 <fasta> mercury^, and judyarrays also have a binding now.
08:16:19 <Zao> But that'd probably be a bit overkill.
08:16:21 <jmcarthur> we don't have a vector-string package yet though i suppose
08:16:24 <benmachine> Zao: well, quite
08:16:27 <jmcarthur> if that would even be practical
08:16:34 <Zao> benmachine: Can't you provide a different directory structure in .cabal/config too?
08:16:40 <Zao> If he still wants user installs.
08:16:53 <benmachine> Zao: yeah
08:17:03 <benmachine> you can have it install stuff basically wherever you like, I think
08:17:15 <benmachine> the config file format should be basically self-explanatory
08:17:31 <benmachine> as long as you remember how haskell comments are written, and that indentation can be significant
08:17:35 <forrest> yeah, i'm in a situation where i can't use my home dir due to disk quota issues, but i'm still putting it in another location just owned by me
08:17:56 <mercury^> jmcarthur: being able to write programs that are fast on ASCII seems like a nice thing.
08:17:57 <fasta> Do you ever write programs that have 50% GC time?
08:18:00 <forrest> so it is a user install, in that i'm not root
08:18:18 <fasta> I think it is way too easy to do that in GHC at least.
08:18:20 <benmachine> forrest: ah, then don't uncomment the user-install line, just change the install-dirs user
08:18:29 <jmcarthur> mercury^: agreed
08:19:34 <forrest> right, that's what I need, thanks
08:19:58 <forrest> to change prefix to the same one i passed to ./configure
08:22:47 <forrest>  /home/forrest/.cabal/config: Unrecognized field prefix on line 47  -- I wasn't supposed to uncomment that line?
08:23:22 <forrest> oh, it's supposed to be indented
08:24:18 <forrest> got it
08:24:23 <EvanR-work> im getting so lost in all these ways of doing exceptions
08:24:36 <EvanR-work> whats the difference between Prelude.catch and Control.Exception.catch
08:25:41 <jmcarthur> :t Prelude.catch
08:25:42 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
08:25:47 <sm> good question
08:25:49 <jmcarthur> :t Control.Exception.catch
08:25:50 <lambdabot> forall a e. (GHC.Exception.Exception e) => IO a -> (e -> IO a) -> IO a
08:26:01 <jmcarthur> the latter looks more general
08:26:25 <jmcarthur> the former only catches IOErrors
08:26:29 <EvanR-work> is IOError a type of exception which works with the latter catch
08:26:44 <jmcarthur> @instances Exception
08:26:44 <lambdabot> Couldn't find class `Exception'. Try @instances-importing
08:26:56 <jmcarthur> @instances-importing Control.Exception Exception
08:26:57 <lambdabot> ArithException, ArrayException, AssertionFailed, AsyncException, BlockedIndefinitely, BlockedOnDeadMVar, Deadlock, ErrorCall, IOException, NestedAtomically, NoMethodError, NonTermination, PatternMatch
08:26:57 <lambdabot> Fail, RecConError, RecSelError, RecUpdError, SomeException
08:27:07 <EvanR-work> i hit a 'gotcha' with HDBC, which uses catchSql and their own custom exceptions? regular catch didnt work :(
08:27:14 <jmcarthur> @hoogle IOError
08:27:15 <lambdabot> Prelude type IOError = IOException
08:27:15 <lambdabot> System.IO.Error type IOError = IOException
08:27:15 <lambdabot> Prelude ioError :: IOError -> IO a
08:27:35 <jmcarthur> EvanR-work: looks like the latter can catch IOError as well
08:27:44 <EvanR-work> ok
08:28:01 <EvanR-work> what do you think the point of catchSql is
08:28:14 <jmcarthur> @hoogle catchSql
08:28:14 <lambdabot> No results found
08:28:22 <jmcarthur> what is that? something in a hackage package?
08:28:26 <EvanR-work> yes
08:28:31 <jmcarthur> what's its type?
08:28:57 <EvanR-work> IO a -> (SqlError -> IO a) -> IO a
08:29:30 <jmcarthur> looks like it catches SqlErrors
08:30:02 <EvanR-work> which are outside the normal exception heirarchy? whats the built in support for making custom exceptions
08:30:21 <jmcarthur> i'm sure SqlError is made an instance of Exception
08:30:29 <jmcarthur> catchSql is just less general
08:30:31 <EvanR-work> it says
08:30:38 <EvanR-work> Eq Read Show and Typeable
08:30:49 <jmcarthur> huh, maybe not then
08:30:55 <EvanR-work> :S
08:31:03 <jmcarthur> i do not know the package
08:36:01 <Jonno_FTW> is there an advantage to using JHC over GHC?
08:36:20 <Lemmih> Jonno_FTW: JHC is very experimental and not a production compiler.
08:36:50 <Lemmih> Jonno_FTW: JHC can be faster in a few microbenchmark settings.
08:36:53 <jmcarthur> for very simple benchmarks, maybe, but aside from that, none that i can think of
08:37:02 <Jonno_FTW> ok
08:37:34 <fasta> Is GHC a production compiler? ;)
08:37:37 <Lemmih> Jonno_FTW: If you're doing compiler research, JHC is a decent place to start.
08:37:49 <Jonno_FTW> thanks
08:38:56 <Lemmih> fasta: No, but if I told my boss that then I wouldn't be allowed to use Haskell. (:
08:39:16 <jmcarthur> it's not? :(
08:39:21 <fasta> Lemmih, heh. I even told mine before I was hired.
08:39:24 <jmcarthur> define "production compiler"
08:39:29 <EvanR-work> the compiler hasnt failed me yet, these damned packages however ;)
08:39:53 <chrisdone> FliPPeh: there's a package on hackage for strict IO based on String
08:40:27 <Lemmih> jmcarthur: I'm just fooling around.
08:40:30 <fasta> For Haskell 98 minus trivial stuff GHC seems to be ready now, though.
08:41:30 <fasta> A problem with some of the extensions that GHC implements is that none of them are documented.
08:41:40 <chrisdone> such as?
08:41:45 <fasta> That is documented in such a way that you can write a replacement in a reasonable amount of time.
08:41:52 <chrisdone> oh
08:41:52 <fasta> chrisdone, fun deps for example.
08:42:11 <fasta> chrisdone, there is a paper, but the GHC implementation has little to do with that.
08:42:36 <fasta> IMHO, if you write a paper about a formal system it should be obvious that it is correct.
08:42:49 <fasta> The paper describing fun deps is a mess.
08:43:02 <fasta> The result was that the implementation was also a mess.
08:44:22 <fasta> All of this relative of course. IMHO, the Coq implementation is also a mess.
08:44:43 <fasta> Some systems do it right, most do not.
08:48:29 <ydo> how do I write "map foo (map (/ 4) [0,2,4])" using dot notation?
08:48:51 <xerox> map f (map g xs) = map (f . g) xs
08:49:07 <xerox> you can read "." as "after"
08:49:45 <ydo> xerox: ty
08:50:16 <xerox> np
08:51:03 <EvanR-work> ive never encountered this error before. when trying to use an exception handler with Control.Exception.catch which looks like \e -> whatever i get error ambiguous type variable `e' in constraint: `Exception e' in catch
08:51:26 <EvanR-work> e should just be an exception, i dont get this
08:51:32 <jmcarthur> EvanR-work: what type do you expect e to have?
08:51:46 <EvanR-work> i guess Exception isnt a type, its a class
08:51:58 <EvanR-work> i expect it to be an IOError
08:52:01 <EvanR-work> no
08:52:03 <EvanR-work> yes
08:52:05 <EvanR-work> IOException?
08:52:12 <jmcarthur> EvanR-work: those are the same
08:52:17 <EvanR-work> im throwing a value from userError
08:52:36 <jmcarthur> EvanR-work: you need to either use it in a way that it's unambiguous what type it is or use a type annotation
08:52:52 <EvanR-work> im trying to show it
08:53:00 <jmcarthur> use a type annotation then
08:53:02 <EvanR-work> how do i use a an annotation here
08:53:07 <jmcarthur> it has no idea what instance to use
08:53:11 <EvanR-work> right
08:53:15 <jmcarthur> show (e :: IOException)
08:53:27 <EvanR-work> should i use Prelude.catch instead?
08:53:33 <jmcarthur> that would work, yes
08:53:42 <jmcarthur> then you dont' need the annotation
08:53:47 <EvanR-work> but does throw work?
08:53:48 <monochrom> You can use Control.Exception.Old
08:54:14 <jmcarthur> EvanR-work: Prelude.catch is probably just defined in terms of Control.Exception.catch
08:54:21 <EvanR-work> ok
08:54:22 <jmcarthur> monochrom: that's deprecated now, isn't it?
08:54:53 <jmcarthur> @src Prelude.catch
08:54:53 <lambdabot> Source not found. Where did you learn to type?
08:55:00 <jmcarthur> :t catch
08:55:01 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
08:55:02 <benmachine> I thought it was OldException
08:55:04 <jmcarthur> @src catch
08:55:05 <lambdabot> catch m k = catchException m handler where handler (IOException err) = k err
08:55:05 <EvanR-work> that solve everything, amazing
08:55:16 <benmachine> I think having Old in the name counts as deprecation
08:55:39 <jmcarthur> benmachine: i don't think Old alone implies that support will be dropped
08:55:45 <jmcarthur> whereas deprecation does
08:55:57 <monochrom> This is why "meaningful names" is bunk.
08:58:08 <ydo> I get parse error on this "map (\([x,y,z]) vertex (Vertex3 x y z))" and I bet there is something more clever to be done with unpacking a list of three coordinates
08:58:50 <monochrom> \([x,y,z]) is a parse error
08:59:15 <ydo> but you see what I'm trying to do monochrom?
08:59:37 <monochrom> Actually I don't.
08:59:52 <dv-> maybe you want \(x:y:z) ->
09:00:30 <ydo> dv-: yes, I think so
09:01:02 <monochrom> If you write x:y:z, z has the wrong type
09:01:27 <ydo> x:y:z:[]?
09:01:32 <monochrom> Yes.
09:01:59 <monochrom> You can also \[x,y,z] ->
09:02:35 <monochrom> > (\[x,y,z] -> (x,y,z)) [4,1,6]
09:02:36 <lambdabot>   (4,1,6)
09:03:45 <Younder> let func (x:y:z:rs) = [x, z, y] or something
09:03:53 <monochrom> perhaps \([x,y,z]) vertex (Vertex3 x y z) is inspired by Scheme.
09:07:24 <Younder> : is a cons operator. so x:y:z means z is the rest of the list not the element (x:y:z:_) makes x, y, z the first third elements
09:07:53 <FliPPeh> I wonder, the lazy byte strings are not as lazy as list, that's what I got. When I read a whole 63 MB data file off the network and wrote it into a file, it trashed my PC, but when I replaced writeFile with Data.ByteString.Lazy.writeFile and made the whole stream a ByteString stream, it worked with 0.8% memory usage constantly until the file was written. What's the method those bytestrings use? Do they evaluate into big chunks, rather than char 
09:09:33 <monochrom> string and lazy byte string are instances of HStream. HTTP calls HStream methods to read.
09:09:59 <benmachine> FliPPeh: yeah, a lazy bytestring is a lazy list of chunks
09:10:14 <benmachine> there's no way to be as lazy as a list without being as inefficient as a list
09:10:17 <ydo> so now I have a list of vertex commands that in a example are after each other in a do-statement, can I expand this list?
09:10:24 <monochrom> This being ad-hoc polymorphism, you can imagine deliberately implementing HStream methods for string to do eager I/O, HStream methods for lazy bytestring to do lazy I/O. Or vice versa.
09:10:32 <FliPPeh> It really amazed me how a file of 63 MB killed my 2 GB of ram AND the swap.
09:10:59 <benmachine> yeah that's a bit odd
09:11:10 <FliPPeh> It killed irssi, pidgin and firefox
09:11:41 <EvanR-work> gah
09:11:41 <Polarina> Aww, cabal crashed. :(
09:11:51 <Polarina> cabal: Distribution/Client/Dependency/TopDown.hs:169:37-73: Non-exhaustive patterns in lambda
09:11:59 <FliPPeh> tehe
09:12:17 <EvanR-work> Printf.printf: bad argument, at runtime. i looked at all the instances and they seem right, is there a way to figure out which one threw this error? :(
09:13:21 <benmachine> printf is a bit unpleasant like that
09:13:27 <benmachine> my understanding is that bad argu
09:13:29 <benmachine> argument
09:13:36 <benmachine> is when you had %s and gave it a Char
09:13:38 <benmachine> or something
09:13:45 <FliPPeh> monochrom: I don't really understand that.. so lazy bytestrings are part of HStream, that's what I found out yesterday, It'll be using the HStream instance methods to access the stream with a "bytestream interface", but I don't understand the part about ad-hoc polymorphism
09:15:16 <EvanR-work> benmachine: i cant seem to get any printouts *before* that error, no matter how 'soon' i put one
09:15:32 <EvanR-work> some effect of laziness?
09:16:13 <EvanR-work> ok, now it works
09:16:37 <Polarina> I am trying to install c2hs, but it's complaining about CLDouble not being in scope.
09:16:49 <FliPPeh> Forgein.C.Types
09:16:51 <FliPPeh> :x
09:16:56 <FliPPeh> Oh wait
09:17:01 <FliPPeh> CLDouble has been raped.
09:17:34 <Polarina> :(
09:17:42 <FliPPeh> I think it simply refers to CDouble
09:17:51 <FliPPeh> Which is a source of great confusion if you ask me
09:18:00 <FliPPeh> By the way, what's XCB doing?
09:18:04 <FliPPeh> :)
09:18:11 <Polarina> FliPPeh, it's doing well.
09:18:21 <Polarina> I am trying to parse a struct I am being given.
09:18:37 <EvanR-work> benmachine: im thinking im not using printf ever again :S
09:18:38 <FliPPeh> Tehe, Forgein structs are a pain
09:19:01 <FliPPeh> I barely managed to make them work :)
09:19:11 <EvanR-work> :t show
09:19:12 <lambdabot> forall a. (Show a) => a -> String
09:19:25 <Polarina> I am more worried about alignment and such.
09:19:36 <temoto> EvanR-work, what are you going to use for formatting string next time?
09:19:38 <Polarina> Of course I could assume sizeOf == alignment, and make my life easier...
09:19:46 <FliPPeh> Polarina: Are you using hsc2hs?
09:20:02 <EvanR-work> temoto: i dont know
09:20:03 <FliPPeh> Polarina: It can do that automatically for you
09:20:08 <Polarina> FliPPeh, no, I was just wondering how c2hs would do it, I am doing it in pure haskell.
09:20:24 <EvanR-work> temoto: something with compile time safety?
09:20:32 <FliPPeh> Polarina: I tried doing it in pure haskell, but that's really a pain
09:20:55 <FliPPeh> Because you cannot get reliable information about those C types
09:21:06 <FliPPeh> hsc2hs gets you those informations
09:21:07 <Polarina> Reliable?
09:21:27 <FliPPeh> Those aligments change from compiler to compiler and platform to platform
09:21:40 <FliPPeh> Can't just stuff some numbers in there :(
09:21:43 <Polarina> alignment in Foreign.Storable
09:22:07 <FliPPeh>  alignment _ = #alignment struct timeval
09:22:13 <FliPPeh> #let alignment t = "%lu", (unsigned long)offsetof(struct {char x__; t (y__); }, y__)
09:22:35 <Polarina> o.O
09:22:44 <FliPPeh> the first line is my Storable interface
09:23:00 <FliPPeh> The second one is what hsc2hs will compute and put into that storable aligment
09:23:27 <Polarina> I need to try harder.
09:23:51 <Polarina> But won't I need to run hsc2hs before ghc --make?
09:23:55 <FliPPeh> Yep
09:23:57 <Polarina> Or will ghc do that for me?
09:24:18 <FliPPeh> hsc2hs transforms your "unclean" .hs file to a clean one that can be compiled
09:24:56 <FliPPeh> However, it also included those darn {-# INCLUDE header #-} pragmas in my files, which are not harmful, but GHC complains about them being deprecated :/
09:25:37 <Polarina> Cabal is unable to install hsc2hs. http://codepad.org/QYswmujc
09:26:15 <Polarina> FliPPeh, using a bash script and sed can fix that for you. :)
09:26:22 <FliPPeh> Polarina: it comes with GHC ;o
09:26:24 <temoto> EvanR-work, if you find any good formatter, please let me know too :)
09:26:27 <Polarina> o.O
09:27:06 <FliPPeh> pacman -Qo /usr/bin/hsc2hs -> "/usr/bin/hsc2hs -> ghc 6.12.1-4"
09:27:07 <FliPPeh> For me
09:27:32 <Polarina> Ah.
09:27:36 <Polarina> Same here. :P
09:27:42 <FliPPeh> Pacman! Waka waka waka waka
09:27:56 <Polarina> :P
09:29:04 <EvanR-work> i found it
09:29:30 <EvanR-work> i had a $ instead of a % in some printf string, in some other file completely, that i tried last
09:31:20 <Polarina> FliPPeh, do you have an example .hsc file of some simple struct and some few functions?
09:31:39 <FliPPeh> I do!
09:31:41 <FliPPeh> @hpaste
09:31:42 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
09:33:22 <FliPPeh> Polarina: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=9208#a9208
09:33:46 <FliPPeh> It's very simple. One struct an a C function that takes a pointer to that struct and fills stuff in it
09:34:31 <Polarina> Thanks.
09:35:47 <Polarina> FliPPeh, if there was a C function that returned a pointer to TimeVal, would the return type be IO (Ptr TimeVal)?
09:36:00 <FliPPeh> Yup
09:36:09 <Polarina> But what if I said IO TimeVal?
09:36:57 <FliPPeh> Then it would happily accept an address to a timeval and try to use it like a timeval
09:37:00 <FliPPeh> = error
09:37:10 <Polarina> You mean a segmentation fault?
09:37:17 <FliPPeh> That would work if that C function returns the struct by VALUE
09:37:35 <Polarina> Ah, I see.
09:37:48 <Polarina> Thanks. :)
09:38:02 <FliPPeh> No problem!
09:38:48 <Polarina> Still learning. :$
09:39:11 <FliPPeh> FFI is in my experience the greatest pain
09:39:23 <FliPPeh> I only """"learned"""" it some days ago
09:39:46 <FliPPeh> That was basically all my knownledge :)
09:39:54 <Polarina> Hehe.
09:40:01 <ydo> so, still struggling, if I have a [IO ()] and want it to be a IO (), I thought I could do something with foldr (>>), but I'm not getting anywhere
09:40:17 <Polarina> :t sequence
09:40:18 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
09:40:23 <Polarina> ydo, :)
09:40:32 <Cale> ydo: You could use foldr (>>) (return ())
09:40:41 <Cale> But this is the same thing as sequence_
09:41:11 <djahandarie> @src sequence_
09:41:11 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
09:41:19 <Cale> (note the underscore -- it's the version which discards the results that you're not interested in)
09:41:42 <Polarina> Cale, but the result is (), so either will do fine. :)
09:41:46 <Cale> The full version of sequence will hand you back a list of the results.
09:42:18 <ydo> thanks again :)
09:42:32 <FliPPeh> sequence [getLine, getLine] -> ["Hello","World"]
09:42:33 <FliPPeh> :)
09:42:43 <Cale> Yeah, sequence xs >> return () will be roughly the same as sequence_ xs here, but if the list of actions is long, you definitely want the second one to avoid the possible space leak.
09:52:52 <ydo> > sin (pi/2.0)
09:52:53 <lambdabot>   1.0
09:53:33 <ydo> > cos (pi/2.0)
09:53:34 <lambdabot>   6.123233995736766e-17
09:53:41 <ydo> why not closer to 0?
09:53:51 <Polarina> Rounding errors.
09:54:44 <Polarina> 6.123233995736766 * 10^(-17)  is quite close to 0.
09:55:00 <blard> hi
09:55:04 <Cale> ydo: That is pretty close to 0
09:55:37 <ydo> yes.. but it's far from > sin 0
09:55:39 <Axman6> > sin pi
09:55:40 <lambdabot>   1.2246467991473532e-16
09:55:47 <ydo> uhm.
09:56:00 <burp> > 2^^(-53)
09:56:01 <lambdabot>   1.1102230246251565e-16
09:56:02 <burp> double precision
09:56:03 <Axman6> > sin pi :: CReal
09:56:04 <lambdabot>   0.0
09:56:10 <ydo> sin 0 gives exactly 0 here
09:56:13 <blard> i try to compile haskell-platfrom unter debian lenny and it keeps telling me "checking for library containing glEnd... no"
09:56:14 <Axman6> > cos (pi/2) :: CReal
09:56:15 <lambdabot>   0.0
09:56:24 <blard> and i installed all the mesa stuff
09:56:33 <EvanR-work> @src words
09:56:33 <lambdabot> words s = case dropWhile isSpace s of
09:56:34 <lambdabot>     "" -> []
09:56:34 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
09:57:08 <EvanR-work> @src lines
09:57:08 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
09:57:15 <djahandarie> That definition of words has always looked too verbose to me
09:58:04 <djahandarie> @src Data.List.lines
09:58:04 <lambdabot> Source not found. I feel much better now.
09:58:09 <Cale> It's hard to make it much better without some equally verbose extra machinery
09:58:49 <ezyang> When traversing folding a recursive structure, it's often useful to know when you enter a child, and then when you "pop" back out to the context.
09:58:56 <ezyang> Is this called something?
09:59:13 <ezyang> I know it's not a normal fold, since doing a fold is indistinguishable from doing it with a list
10:00:22 <Polarina> ezyang, For Data.Map, which is a binary tree, it's called depth, telling you how far into the structure you are.
10:00:33 <Polarina> Well, for binary trees in general.
10:00:36 <djahandarie> Huh? Are you talking about catamorphisms/some operation on them?
10:01:47 <ezyang> Polarina: So, make a custom fold function that passes the folding function the depth?
10:01:55 <ezyang> djahandarie: I think this is a catamorphism
10:02:22 <Polarina> ezyang, something like that, yes.
10:02:53 <ezyang> hm, ok.
10:03:04 <ezyang> I'm trying to convince myself this has the correct semantics for foldM, in the state monad
10:03:05 <Polarina> ezyang, when you start a fold, you "enter" a child. When a fold ends, you "pop" back out.
10:03:25 <Zao> That sounds horribly wrong :D
10:05:28 <ezyang> I'm not really communicating this quite effectively
10:05:37 <ezyang> lesseee
10:05:47 <edwardk> ezyang: there is a generalization
10:05:56 <edwardk> ezyang: there is a notion of a prepromorphism
10:06:17 <edwardk> ezyang: it says that as you go deeper you apply a natural transformation to the base functor. i.e. ticking a counter
10:06:38 <edwardk> it is also terribly obscure ;)
10:06:41 <ezyang> edwardk: Huh. That sort of sounds like what I'm working on
10:06:44 <ezyang> heh :-)
10:06:58 <edwardk> i packaged it up in category-extras with everything else ;)
10:07:40 <FliPPeh>  @src head
10:07:45 <edwardk> it came from martin fokkinga's dissertation
10:07:58 <FliPPeh> lambdabot: I'M TALKING TO YOU
10:08:03 <edwardk> @src head
10:08:03 <lambdabot> head (x:_) = x
10:08:03 <lambdabot> head []    = undefined
10:08:03 <FliPPeh> @src head
10:08:04 <lambdabot> head (x:_) = x
10:08:04 <lambdabot> head []    = undefined
10:08:08 <FliPPeh> Darn spaces
10:08:11 <FliPPeh> :)
10:08:18 <FliPPeh> undefined?
10:08:29 <fax> > 360/5
10:08:30 <lambdabot>   72.0
10:08:33 <FliPPeh> Not in Prelude.
10:08:34 <edwardk> > head []
10:08:34 <lambdabot>   * Exception: Prelude.head: empty list
10:08:43 <ezyang> I don't think I want to use category-extras for this task...
10:08:43 <FliPPeh> Seems more like "error"
10:08:47 <edwardk> they take some liberties with the simplified version that comes from source
10:08:48 <fax> > 180 - (360/5)*2
10:08:49 <lambdabot>   36.0
10:09:03 <edwardk> ezyang: hah i don't blame you
10:09:17 <fax> > 90 - 36
10:09:18 <lambdabot>   54
10:09:55 <edwardk> ezyang: you can always make something like a cataN :: Functor f => (Int -> f a -> a) -> Mu f -> a
10:09:57 <ezyang> Hm. Now I'm wondering if I don't actually want a fold inside the state monad.
10:10:06 <djahandarie> category-extras is a bit scary looking
10:10:23 <ezyang> edwardk: Ok, so there's the difficult bit
10:10:40 <edwardk> ezyang: ?
10:11:17 <Cale> djahandarie: heh, "a bit"
10:11:30 <ezyang> I want to convert an n-ary tree into a boolean value, that says "the leaf children of the base node are ordered, and run this operation on the any subtrees"
10:12:08 <ezyang> edwardk: So it's a recursion, but there's something like two folds going on
10:12:21 <edwardk> er can you rephrase that part?
10:12:25 <fax> ezyang, that is true about there being two folds
10:12:43 <edwardk> you can turn them into one fold. just return the answers to both questions
10:12:51 <fax> I mean if the tree is like   Tree a = Branch [Tree a] | Leaf a
10:12:53 <edwardk> and don't look at it if you don't need it
10:13:03 <fax> because you have [] . Tree you need both folds
10:13:07 <ezyang> oh! I wonder if that works
10:13:24 <edwardk> lemme get you an example
10:13:43 <Cale> edwardk: You should give a talk on category-extras and record it for all the interwebs to see.
10:14:11 <edwardk> Cale: i would but i didn't want to turn boston haskell into a vanity project ;)
10:14:11 <ezyang> fishing for abstractions is fun :-)
10:14:28 <ezyang> category-extras for the masses would be lots of fun
10:14:59 <edwardk> ezyang: thats why i need to refactor it there, is a fair bit of practical in there mixed in with the esoteric but it is almost impossible for folks to find
10:15:48 <edwardk> ezyang: an example of doing 'two folds at once and picking the right one' is in http://repository.upenn.edu/cis_reports/43/
10:15:50 <ezyang> fax: Ok, double fold and extra info I think was the key info I needed.
10:15:52 <edwardk> look at the PAR example
10:16:02 <djahandarie> Ooh this higher-order functor stuff looks like an abstraction I was trying to do awhile ago
10:16:12 <ezyang> "Boxes go Bananas" -> is that, like, a reference to Banana lenses?
10:16:20 <edwardk> ezyang: yeah
10:16:43 <ezyang> oh man :-)
10:17:01 <edwardk> ezyang: in 'bananas in space' meijer and hutton came up with a way to extend catamorphisms and anamorphisms to exotic data types where the variable occurs in negative position.
10:17:16 <edwardk> ezyang: but do to it they had to have an inverse for the cata or anamorphism.
10:17:17 <jmcarthur> negative position?
10:17:29 <edwardk> data Test a = Test (a -> Bool)
10:17:34 <jmcarthur> ah!
10:17:34 <ezyang> whoa
10:17:38 <jmcarthur> cool
10:17:38 <ezyang> !!
10:17:54 <edwardk> or data Exp a = Lam (a -> a) | App a a
10:19:00 <edwardk> fegaras and sheard came along and wrote a nice paper on how you could actually cheat and add an extra constructor that lets you provide a left inverse for your catamorphism, which is sufficient to handle these kinds of recursions
10:20:02 <jmcarthur> but that's cheating
10:20:03 <edwardk> weirich and washburn wrote up a variant on fegaras and sheard's technique that didn't rely on an extra constructor, but instead encoded the data type AS the catamorphism, in a way that let a function that just ignored the function, play the role of that Place constructor.
10:20:06 <jmcarthur> i don't like cheating
10:20:22 <jmcarthur> ah, so kind of a church encoding?
10:20:45 <edwardk> jmcarthur: its a perfectly reasonable fix. you can close the term so that it doesn't exist except when you are folding, so there still won't be any exotic terms in a closed expression
10:21:05 <edwardk> er the 'it' in this case being the Place constructor or the elimination form equivalent
10:21:20 <edwardk> i wrote a blog post on the topic a while back complaining about this very encoding
10:21:21 <jmcarthur> ah
10:21:23 <fax> so what extra constructor would you add for this Exp thing?
10:21:45 <edwardk> http://comonad.com/reader/2008/rotten-bananas/
10:22:22 <edwardk> fax: the constructor would be particular to the result type of the current fold in progress
10:22:30 <Polarina> FliPPeh, There's no such thing as #alignment in hsc2hs. :(
10:22:35 <fax> ahh
10:22:46 <fax> that's clever
10:23:17 <user___> does the haskell platform add a HOME environment variable to the windows environment?
10:23:29 <FauxFaux> No. Â¬_Â¬
10:23:33 <user___> haha
10:23:37 * FauxFaux stalks user___.
10:24:05 <user___> thanks again
10:27:42 * shapr tries cabal install hackage
10:28:00 <shapr> So, hackage isn't in hackage?
10:28:12 <araujo> JOIN Â£SMALLTALK
10:28:18 <araujo> :|
10:28:30 <shapr> I saw the GSoC most important projects, thought it would be fun to hack on hackage.
10:28:58 <dmhouse> Yeah, that did sound cool
10:29:04 <benmachine> shapr: hackage is the set of all packages that do not contain themselves?
10:29:14 <dmhouse> araujo: shift-hash is the Â£ sign for you?
10:29:15 <shapr> benmachine: argh!
10:29:28 * shapr Â£s on the buttons!
10:29:48 <benmachine> dmhouse: on my keyboard Â£ is on shift-3, and # is on alt-3
10:30:00 <benmachine> sometimes # is on shift-3
10:30:05 <djahandarie> alt is my meta key for irssi
10:30:16 <benmachine> yeah, I meant right-alt
10:30:20 <djahandarie> Ah
10:30:27 <dmhouse> AltGr+3 = Â³ for me
10:30:34 <araujo> dmhouse, shift-alt # P
10:30:55 <dmhouse> # has its own key, with ~ the shifted form.
10:31:14 <benmachine> conclusion: keyboards are weird
10:31:22 <benmachine> it doesn't help that I have my own custom xmodmap I guess
10:31:34 <shapr> Ooh, me too!
10:31:35 <araujo> Alt-3 = # , Shift-3 = Â· , Alt+Shift= Â£
10:31:50 <araujo> Alt+Shift+3 = Â£
10:31:55 <araujo> i mean that
10:31:58 <dmhouse> Me - http://en.wikipedia.org/wiki/Keyboard_layout#United_Kingdom
10:32:43 <dmhouse> (With the exception that CapsLock is ctrl, of course. And the "menu" key near right ctrl is another alt, as there's only left alt and AltGr on my laptop keyboard.)
10:32:47 <djahandarie> Why is there a backtick on QWERTY US anyways?
10:33:04 <djahandarie> It is rarely rarely ever used in English
10:33:05 <dmhouse> Well back in the day that's how people wrote `quotes'.
10:33:18 <benmachine> nowadays we have â€˜quotesâ€™ :>
10:33:46 <edwardk> shapr: you should upload a package named hackage to hackage with a set of dependencies which consists of all of the maximally installable subsets of hackage
10:33:56 <edwardk> so you can just 'cabal install hackage'
10:33:58 <dmhouse> Quite. :) AltGr-v and AltGr-b for â€œbeautifulâ€ quotes.
10:34:00 <edwardk> and get it over with
10:34:21 <dmhouse> (Not sure where the single quotes are though...)
10:34:33 <dmhouse> Oh, AltGr+Shift+{v,b}.
10:35:20 <edwardk> dmhouse: You can set LC_ALL=en@quot and apps that use gnu gettext internally will quote with 'beautiful' quotes
10:36:00 <dmhouse> edwardk: hmm, interesting
10:36:11 <edwardk> dmhouse: or LC_ALL=en@boldquot if you want the ansi escape sequence for bold to be used inside of the quoted string as well.
10:36:38 <dmhouse> How does that work? gettext is localisation, right? Do you specify "these characters are quotes" when internationalising?
10:37:02 <dmhouse> I guess that would make sense, so you could get Â«French-style chevronsÂ».
10:37:39 <edwardk> dmhouse: when you 'gettextize' a project it tweaks the autoconf for it, and sets up a 'po' directory for translations. in there you list the 'LINGUAS' you support in a file. and they include two default translations en@quot and en@boldquot that use msgfilter to autogenerate their text using sed
10:37:50 <edwardk> er that probably got clipped:
10:37:52 <edwardk> and they include two default translations en@quot and en@boldquot that use msgfilter to autogenerate their text using sed
10:38:34 <dmhouse> Oh right, so gettext will automagically convert 'quoted stuff' into the localised quotes?
10:38:47 <edwardk> they sed through looking for ` and ' and generate the utf8 quotes instead. this has to be done this way because they require that gettext strings in the source program be ascii text so that the resulting c source is portable.
10:39:52 <shapr> edwardk: Actually, I wanted to hack on hackage the display and sorting thingy...
10:40:12 <edwardk> shapr: and add reverse dependency info ;)
10:40:35 <shapr> Yes, exactly.
10:40:37 <edwardk> shapr: good, and then submit your project to the summer of code like a good little student  =)
10:40:43 <shapr> hm
10:41:00 <edwardk> dmhouse: yep
10:47:00 <chrisdone> excellent
10:47:02 <chrisdone> http://tryhaskell.com/
10:47:08 <chrisdone> now hosted on linode
10:48:02 <chrisdone> (tryhaskell.org is still pointing to my home computer, will point that domain to the linode server now)
10:48:06 <FliPPeh> Say I have a code construct that reads from a socket and unwraps the data body from the record.. until here, there has been no specification of the type that das has, it could be a string, or a bytestring or a lazy bytestring. If I use the ByteString.Lazy.writeFile method, the whole construct will work on a bytestring, right?
10:48:14 <chrisdone> glguy_: hey, you there?
10:48:28 <sm> nice
10:51:00 <fax> > let z = (1/16)*(-1+sqrt(17)+sqrt(34-2*sqrt(17))+sqrt(68+12*sqrt(17)-16*sqrt(34+2*sqrt(17))-2*(1-sqrt(17))*sqrt(34-2*sqrt(17))) in z^17 :: Complex Double
10:51:01 <lambdabot>   <no location info>: parse error on input `in'
10:51:21 <chrisdone> missing a ')'
10:51:24 <FliPPeh> "simpleHTTP (defaultGETRequest_ . fromJust . parseURI $ "google.com") >>= getResponseBody" is of type (HStream a) => IO a
10:51:42 <FliPPeh> If I write that into a file with writeFile, it will be IO String, no?
10:51:53 <FliPPeh> And If I use Data.ByteString, it will be IO ByteString?
10:52:11 <FliPPeh> I want to understand why the same code with a normal string ate my RAM to the point of no return
10:52:24 <fax> > let z = (1/16)*(-1+sqrt(17)+sqrt(34-2*sqrt(17))+sqrt(68+12*sqrt(17)-16*sqrt(34+2*sqrt(17))-2*(1-sqrt(17))*sqrt(34-2*sqrt(17)))) in z^17 :: Complex Double
10:52:25 <lambdabot>   0.3046564751804991 :+ 0.0
10:52:54 <fax> must have a mistake somewhere -- anyone?
10:53:16 <FliPPeh> I'm not gonna try decoding that :x
10:53:26 <fax> it looks right though
10:53:38 <FliPPeh> What is that for?
10:53:45 <fax> it shoudl print 1
10:54:00 <fax> oh no it shouldn't
10:54:02 <FliPPeh> Obfuscation?
10:54:14 <fax> > let z = (1/16)*(-1+sqrt(17)+sqrt(34-2*sqrt(17))+sqrt(68+12*sqrt(17)-16*sqrt(34+2*sqrt(17))-2*(1-sqrt(17))*sqrt(34-2*sqrt(17)))) in (17/2)*acos z :: Complex Double
10:54:14 <lambdabot>   3.1415926535897962 :+ 0.0
10:54:40 <djahandarie> You need Complex for that to work?
10:54:45 <fax> > let z = (1/16)*(-1+sqrt(17)+sqrt(34-2*sqrt(17))+sqrt(68+12*sqrt(17)-16*sqrt(34+2*sqrt(17))-2*(1-sqrt(17))*sqrt(34-2*sqrt(17)))) in (17/2)*acos z :: Double
10:54:47 <lambdabot>   3.141592653589796
10:54:49 <fax> apparently not!
10:55:14 <djahandarie> > pi :: CReal
10:55:15 <lambdabot>   3.1415926535897932384626433832795028841972
10:56:50 <chrisdone> fax: how are you constructing that expression? I don't follow why it outputs pi
10:57:10 <fax> this is actually due to Gauss... I didn't come up with it myself :)
10:57:22 <fax> he got this when he was 18 (jelous...)
10:57:27 <chrisdone> I should've guassed :p
10:57:32 <fax> lol
10:57:38 <djahandarie> I still have months left to create such a thing!
10:58:20 <djahandarie> Haven't really been pursuing the approximation of pi though. :P
10:59:12 <fax> http://en.wikipedia.org/wiki/Heptadecagon
11:01:35 <fax> http://www.fermatslasttheorem.blogspot.com/2008/01/gauss-seventeenth-root-of-unity.html
11:01:55 <fax> there's a derivation but it's pretty crazy
11:02:02 <fax> greek letters and shit
11:04:00 <Sgeo> Hoogle is awesome. I knew I wanted (Read a) => IO a, and Hoogle found me readLn
11:04:13 <chrisdone> @hoogle readLn
11:04:13 <lambdabot> Prelude readLn :: Read a => IO a
11:04:13 <lambdabot> System.IO readLn :: Read a => IO a
11:04:42 <twink> The 17th root of unity is cool.
11:04:52 <fax> yeah this is stunning
11:05:11 <Sgeo> Seriously, this is one of the more awesome things about Haskell
11:05:16 <fax> > (1/16)*(-1+sqrt(17)+sqrt(34-2*sqrt(17))+sqrt(68+12*sqrt(17)-16*sqrt(34+2*sqrt(17))-2*(1-sqrt(17))*sqrt(34-2*sqrt(17))))
11:05:16 <lambdabot>   0.9324722294043557
11:05:19 <twink> The ruler and compass construction of the 17-sided regular polygon is tough to go through though.
11:05:21 <fax> why is it a real number though?
11:05:30 <fax> twink I'm going to try it l ater today :D
11:05:52 * Sgeo goes to write stuff to play around with unsafeInterleaveIO
11:05:59 <djahandarie> fax, because the discriminant is never negative?
11:06:12 <fax> djahandarie, I was sure it should be complex number :S
11:06:14 <EvanR-work> > 1^17
11:06:15 <lambdabot>   1
11:06:20 <EvanR-work> \o/
11:06:32 <chrisdone> D_D
11:06:33 <EvanR-work> found it
11:06:36 <fax> that's the boring one :P
11:06:42 <fax> we want the 16 others
11:06:44 <JeanPijon> Hi can somebody tell me, if it is possible to convert Float to GLFloat ?
11:07:11 <EvanR-work> those cant be real
11:07:37 <djahandarie> fax, assuming the roots are all positive the discriminant shouldn't be negative
11:07:43 <chrisdone> @src Integral
11:07:43 <lambdabot> class  (Real a, Enum a) => Integral a  where
11:07:43 <lambdabot>     quot, rem, div, mod :: a -> a -> a
11:07:43 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
11:07:43 <lambdabot>     toInteger           :: a -> Integer
11:07:56 <chrisdone> JeanPijon: does GLFloat implement the Fractional class?
11:08:23 <JeanPijon> chrisdone: Sorry I am trully begginer, what does mean?
11:10:03 <chrisdone> :t fromIntegral
11:10:04 <lambdabot> forall a b. (Integral a, Num b) => a -> b
11:10:09 <chrisdone> :instances Num
11:10:15 <Cale> fromIntegral is the wrong answer here
11:10:25 <Cale> you want realToFrac to convert between floating point types
11:10:25 <EvanR-work> @src GLFloat
11:10:26 <lambdabot> Source not found. I've seen penguins that can type better than that.
11:10:29 <chrisdone> yeah I'm trying to find my way through with hoogle but blah
11:10:34 <EvanR-work> :info GLFloat
11:11:23 <chrisdone> I doubt hoogle is smart enough to recognise Float -> Double
11:11:26 <chrisdone> :hoogle Float -> Double
11:11:28 <Cale> JeanPijon: The realToFrac function will convert from one to the other. Beware that it can be a bit expensive though. If you can keep the numbers in one type, then it'd be best to do that.
11:11:33 <chrisdone> @hoogle Float -> Double
11:11:33 <lambdabot> Prelude realToFrac :: (Real a, Fractional b) => a -> b
11:11:34 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
11:11:34 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
11:11:40 <chrisdone> oh, well shut me up
11:12:32 <Sgeo> Is there a way to do multi-line comments in Haskell?
11:12:51 <benmachine> {- blah -}
11:12:56 <Sgeo> ty
11:13:10 <JeanPijon> Cale: Well I don't know if it is necessary, but I need random init position for OpenGL object, which needs GLfloat
11:13:13 <Makoryu> Sgeo: They nest!
11:13:40 <Cale> JeanPijon: ah, don't worry about the cost then
11:14:12 <Sgeo> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24603#a24603 FUN :D
11:14:23 <Cale> JeanPijon: I'm not sure if GLfloats have a Random instance, so yeah, converting might be your best bet if they don't.
11:14:32 <JeanPijon> Cale: Can you please describe more in detail, how to use realToFrac function?
11:15:22 <chrisdone> Sgeo: hardcore laziness
11:16:00 <Sgeo> Why should _I_ think about when I need to ask the user something? Let the language do it for me!
11:16:05 <chrisdone> gonna make a blog with jasper's static site maker ^_^
11:17:25 <kmc> (putStrLn . show)  =  print
11:17:35 <EvanR-work> i never hear about lazy patterns in here, are they really useful?
11:17:43 <kmc> EvanR-work, the irrefutable patterns with ~ ?
11:18:04 <EvanR-work> yes
11:18:08 <kmc> they are not useful
11:18:10 <kmc> i have never used one
11:18:13 <EvanR-work> heh
11:18:41 <chrisdone> me neither
11:18:51 <fax> > ((sqrt(5)-1+sqrt(-2*sqrt(5)-10))/4)^5 :: Complex Double
11:18:52 <lambdabot>   0.9999999999999999 :+ (-1.1102230246251565e-16)
11:18:59 <kmc> "let" bindings are already lazy and irrefutable
11:19:01 <fax> > ((sqrt(5)-1+sqrt(-2*sqrt(5)-10))/4)^5 :: Complex CReal
11:19:05 <Sgeo> Now I'm being told to be wary of unsafeInterleaveIO :(
11:19:05 <lambdabot>   mueval-core: Time limit exceeded
11:19:14 <JeanPijon> Cale: Sry, it was obvious:) Never mind, thank you for help
11:19:24 <fax> > ((-sqrt(5)+1+sqrt(2*sqrt(5)-10))/4)^5 :: Complex CReal
11:19:25 <EvanR-work> kmc: so why do i hear more about n+k patterns than ~ patterns ;)
11:19:25 <chrisdone> Sgeo: the 'unsafe' part wasn't enough? :p
11:19:27 <fax> why can't haskell do it
11:19:28 <lambdabot>   mueval-core: Time limit exceeded
11:19:29 <kmc> Sgeo, the name didn't tip you off?
11:19:32 <kmc> ;)
11:20:32 <EvanR-work> @src take
11:20:32 <lambdabot> take n _      | n <= 0 =  []
11:20:33 <lambdabot> take _ []              =  []
11:20:33 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
11:20:35 <benmachine> Sgeo: you should be wary of it, but that doesn't mean you shouldn't use it
11:20:48 * Sgeo wanted to use it everywhere
11:20:50 <benmachine> Sgeo: just be aware that it may cause odd things to happen sometimes
11:21:00 <benmachine> especially with exceptions
11:23:45 <Cale> JeanPijon: Oh, sorry, I'd gotten up from the machine, yeah, you just apply it like any other function, and type inference typically does the rest.
11:24:43 <JeanPijon> Cale: Yes, it was really simple, thx:)
11:25:15 <benmachine> I'm confused by infix declarations
11:25:23 <benmachine> hmm no I'm not
11:25:29 <benmachine> I might be
11:25:35 * benmachine plays with them
11:25:39 <kmc> Sgeo, unsafePerformIO and unsafeInterleaveIO both break a basic property of haskell values
11:25:48 <Cale> So you're confused about whether you're confused about infix declarations.
11:25:53 <benmachine> yes.
11:25:55 <benmachine> :)
11:25:56 <kmc> which is that evaluation does not cause execution
11:26:00 <kmc> even evaluation of IO actions
11:26:14 <Cale> So I'm not confused about whether you're confused about whether you're confused about infix declarations.
11:26:33 <benmachine> you are not, correct
11:26:41 <benmachine> you are not not correct
11:28:02 <dmhouse> Hmm, what's bad about unsafeInterleaveIO?
11:28:22 <ezyang> what is a function that given [1,2,3] will give [(1,2), (2,3)] ?
11:28:24 <jmcarthur> pure functions performing side effects
11:28:28 <benmachine> it can make exceptions pop up in unexpected places
11:28:34 <benmachine> and things happen at strange times
11:28:36 <McManiaC> is there a way to suppress orphane instances?
11:28:41 <McManiaC> *error messages
11:28:46 <McManiaC> or warnings
11:28:53 <ezyang> zip xs (tail xs) perhaps
11:28:58 <benmachine> > zip <*> tail $ [1,2,3]
11:28:59 <lambdabot>   [(1,2),(2,3)]
11:29:08 <benmachine> @quote consecutive
11:29:09 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
11:29:23 <benmachine> ^ this is actually how I started remembering how `ap` works with functions
11:29:52 <ezyang> huh.
11:30:01 <ezyang> this is using the applicative instance for functions, correct?
11:30:06 <benmachine> yep
11:30:11 <ezyang> huh.
11:30:24 <dmhouse> It's just the S combinator ;)
11:30:26 <EvanR-work> ezyang: f [a,b,c] = [(a,b), (b,c)]
11:30:29 <benmachine> f <*> g = (\x -> f x (g x))
11:30:29 <EvanR-work> ;)
11:30:44 <benmachine> call a binary function with a unary function applied to the second argument
11:30:59 <ezyang> aha
11:31:08 <jmcarthur> also the same thing as (liftA2 zip id tail) if that is any more intuitive
11:31:17 <Toxaris> EvanR-work: f _ = [(1, 2), (2, 3)]
11:31:21 <temoto> Could anyone please tell whether this function is looped in Left e branch? http://codepad.org/9kgY4S2B
11:31:30 <ezyang> jmcarthur: that's a bit more intuitive :-)
11:31:51 <EvanR-work> Toxaris: mines more general ;)
11:32:15 <benmachine>  temoto I don't think so
11:32:20 <Toxaris> EvanR-work: how so? Mine is applicable to more values, and has a more general type
11:32:37 <deech> I'd like to use Haskell to generate source in another language (like atom). Atom AFAIK gives the user special functions that generate certain C constructs. Is this the best way to do this?
11:32:51 <temoto> benmachine, so hClose is called anyway, right?
11:32:56 <EvanR-work> Toxaris: i dont know, i think we both apply to a countable infinity of values ;)
11:33:02 <benmachine> temoto: should be
11:33:22 <temoto> benmachine, but i see connections in FIN_WAIT2 state via netstat -teplotan
11:33:42 <ezyang> > zip [] undefined
11:33:43 <lambdabot>   []
11:33:51 <ezyang> excellent :-)
11:34:08 <benmachine> temoto: (hClose h >> putStrLn "hClosed")?
11:34:23 <benmachine> > zip undefined []
11:34:24 <lambdabot>   * Exception: Prelude.undefined
11:34:28 <benmachine> unfortunately
11:36:45 <EvanR-work> i dont understand the semantics of _|_, its in the docs a lot of places, and represents the return value of a computation that either fails or never completes. how does the computer know if a computation never completes?
11:37:01 <benmachine> it doesn't
11:37:15 <EvanR-work> oh
11:37:25 <benmachine> _|_ is not... observable
11:37:26 <benmachine> as it were
11:37:32 <benmachine> or at least, it's not supposed to be
11:37:49 <EvanR-work> and how does a computation return anything if it never completes ;)
11:37:56 <EvanR-work> thats like the last element of an infinite list
11:38:28 <chrisdone> jaspervdj: hey I'm reading your hakyll tutorials =)
11:38:43 <chrisdone> jaspervdj: is the hakyll site generated with hakyll?
11:38:49 <arw_> yes. like \infty. you will never reach it, but you can use it as a symbol for the positive number you will never reach...
11:39:05 <benmachine> EvanR-work: you might say that let x = x in x -- x is _|_
11:39:30 <benmachine> because its computation will never terminate
11:39:33 <jmcarthur> EvanR-work: it doesn't return _|_. it just is
11:39:37 <temoto> benmachine, it doesn't print closed...
11:39:51 <EvanR-work> so let ones = 1 : ones in ones is _|_
11:40:00 <ksf> do we have some magic thingie that can generate stuff like http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24604#a24604 ?
11:40:00 <jmcarthur> no
11:40:03 <EvanR-work> :S
11:40:12 <temoto> benmachine, should mean that loop is called despite return () in error handler?
11:40:14 <benmachine> temoto: might the hGetLine be blocking indefinitely?
11:40:18 <ksf> there's going to be more adts that implement more or less classes
11:40:23 <benmachine> temoto: wait, what?
11:40:30 <Zao> temoto: return is not the C return.
11:40:33 <Zao> It doesn't control flow.
11:40:37 <Zao> It lifts a value into a monad.
11:40:46 <temoto> damnit
11:40:51 <chrisdone> jaspervdj: oh, I scrolled down. haha
11:40:54 <jmcarthur> EvanR-work: your ones value is not _|_ because it is productive
11:40:54 <benmachine> return () is basically an IO action that doesn't do anything
11:41:00 <temoto> i know that and i don't know how to use it properly
11:41:10 <jmcarthur> EvanR-work: however, last ones would be bottom
11:41:25 <benmachine> temoto: just put the recursive loop call in the Right branch
11:41:32 <Zao> do { return () ; putStrLn "lol" } -- would print out "lol"
11:41:35 <jmcarthur> (last ones) is _|_, that is
11:41:49 <benmachine> temoto: so control naturally falls off the end if you get Left e, but recurses if you get Right line
11:42:20 <temoto> benmachine, yeah that makes sense. thanks
11:42:31 <kmc> indeed,  do { return (); m }   ===>  do { m }    in every monad
11:42:37 <kmc> that's basically one of the monad laws
11:43:14 <ksf> return a >>= \_ -> m is for quite obvious reasons m.
11:43:19 <EvanR-work> jmcarthur: wait. ones does not terminate
11:43:36 <ksf> EvanR-work, so what?
11:43:40 <jmcarthur> return <=< a  ==  a;  a <=< return  ==  a;  (a <=< b) <=< c  ==  a <=< (b <=< c)
11:43:50 <jmcarthur> EvanR-work: sure it does
11:43:53 <EvanR-work> so i dont get why its not _|_ why is ones, and last ones different
11:44:03 <EvanR-work> is this about head normal form or something
11:44:08 <Cale> EvanR-work: head ones = 1
11:44:13 <ksf> @src last
11:44:14 <lambdabot> last [x]    = x
11:44:14 <lambdabot> last (_:xs) = last xs
11:44:14 <lambdabot> last []     = undefined
11:44:16 <Cale> EvanR-work: but  head _|_ = _|_
11:44:17 <jmcarthur> > let ones = 1 : ones in seq ones "it terminated!"
11:44:18 <lambdabot>   "it terminated!"
11:44:22 <benmachine> EvanR-work: ones terminates with 1 : ones
11:44:25 <EvanR-work> both ones and last ones 'are productive'
11:44:26 <ksf> ...it has to match for [], you see?
11:44:29 <Cale> > let ones = 1 : ones in head ones
11:44:30 <lambdabot>   1
11:44:34 <jmcarthur> EvanR-work: last ones is not productive
11:44:34 <Cale> > let ones = 1 : ones in take 5 ones
11:44:35 <lambdabot>   [1,1,1,1,1]
11:44:40 <benmachine> it's a circular data structure
11:44:41 <jaspervdj> chrisdone: yes, the hakyll site is done with hakyll
11:44:46 <jaspervdj> chrisdone: very meta, isn't it
11:45:00 <EvanR-work> i didnt say, head ones, i said ones
11:45:15 <benmachine> EvanR-work: it really depends what you mean by terminate
11:45:25 <EvanR-work> right
11:45:30 <EvanR-work> so like, evaluate to head normal form
11:45:34 <EvanR-work> or something
11:45:39 <benmachine> 1 : ones is head normal form
11:45:41 <chrisdone> jaspervdj: eating your own dog food =)
11:45:44 <jmcarthur> EvanR-work: ones has a head normal form
11:45:44 <EvanR-work> ok
11:45:50 <EvanR-work> last ones doesnt?
11:45:52 <jmcarthur> and therefore terminates
11:45:54 <jmcarthur> no
11:45:57 <EvanR-work> ok got it
11:45:59 <Cale> last ones won't terminate
11:46:07 <Cale> (because there is no last element)
11:46:17 <EvanR-work> more like youll never get a head normal form
11:46:19 <temoto> benmachine, yay it's closing now! Thank you.
11:46:25 <EvanR-work> like tail ones
11:46:31 <EvanR-work> you get one there
11:46:34 <Cale> right
11:46:37 <kmc> you won't get it to normal form, though
11:46:48 <EvanR-work> is normal form that interesting
11:46:51 <benmachine> heh
11:46:54 <kmc> yes
11:46:56 <jmcarthur> > let ones = 1 : ones in seq (last ones) "it terminated!"
11:46:56 <jmcarthur> umm
11:46:56 <jmcarthur> that wasn't supposed to kill lb
11:47:01 <lambdabot>   mueval: ExitFailure 1
11:47:10 <benmachine> jmcarthur: I think you lagged
11:47:17 <jaspervdj> chrisdone: yep :-) it's a good thing, I suppose
11:47:26 <dyakovlev> hello! anyone ever see errors like this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24605#a24605
11:47:40 <EvanR-work> bah. whats normal, head normal, and weak head normal S:
11:47:41 <Cale> dyakovlev: compile with --make
11:47:42 <Zao> dyakovlev: --make
11:47:54 <benmachine> EvanR-work: iirc normal is completely reduced
11:47:57 <Zao> Or explicitly reference the packages you want.
11:47:59 <benmachine> no more reducible expressions
11:47:59 <Cale> dyakovlev: or else -package containers
11:48:04 <dyakovlev> oh
11:48:09 <dyakovlev> oops .__.
11:48:13 <Cale> It's okay
11:48:20 <benmachine> head normal and weak head normal are the same except for whether you evaluate under the lambda
11:48:25 <Cale> The error messages *are* pretty stupidly confusing
11:48:30 <chrisdone> jaspervdj: I've moved tryhaskell onto a linode server now, yay speed and uptime!
11:48:41 <EvanR-work> er
11:48:50 <jaspervdj> chrisdone: awesome
11:48:58 <jaspervdj> chrisdone: how many hits this month?
11:49:00 <benmachine> I don't quite remember what the distinction is
11:49:14 <Cale> head normal means that you evaluate underneath lambdas
11:49:15 <benmachine> but in either case you only evaluate far enough to get the top constructor
11:49:39 <benmachine> so, if it's a maybe you're evaluating far enough to check whether it's Nothing or Just, for example
11:49:41 <Cale> weak head normal means that lambdas are already cooked
11:50:14 <chrisdone> jaspervdj: there were 6,000 hits in march. but I released it in march :p
11:50:22 <EvanR-work> already cooked?
11:50:27 <temoto> But sockets still aren't closed. Now they're in TIME_WAIT state.
11:50:28 <Cale> (that is, every lambda is in weak head normal form, but in order to be in head normal form, the body of a lambda must be in head normal form)
11:50:57 <djahandarie> chrisdone, by the way, something weird is that the "history" queue can get messed up in your interface
11:50:59 <chrisdone> jaspervdj: of that, 264 people spent more than one minute on the site, which is about how long it takes to complete the tutorial
11:51:04 <Cale> Weak head normal form is more realistic
11:51:23 <djahandarie> chrisdone, as in, when you run a new command it doesn't reset where you are in the history
11:51:25 <chrisdone> djahandarie: yeah I need to fix the history. I bodged it inbetween my job and didn't finish
11:51:25 <Cale> Since real implementations of functional programming languages rarely evaluate underneath unapplied lambdas.
11:51:44 <mibygl> Huh, MacPorts seems to have disappeared from this iMac.
11:51:55 <benmachine> temoto: I don't exactly know how to deal with that, except that I think SO_REUSEADDR allows you to open a socket on an address which has a TIME_WAIT socket on it
11:52:17 <mibygl> That's what I get for using someone else's machine.
11:53:22 <chrisdone> jaspervdj: I need to add more stuff to it really. I did one initial tutorial one night and that's all that's been on there since. but I have time this easter :D
11:53:25 <EvanR-work> Cale: so in head normal form, all lambda bodies are in head normal form
11:53:39 <Cale> yeah
11:53:42 <benmachine> hmm?
11:53:46 <Cale> er, hmm
11:53:47 <benmachine> not necessarily
11:53:48 <jaspervdj> chrisdone: cool, a â€œfinishedâ€ tutorial would be very nice
11:53:59 <Cale> Actually, that only applies to the top-level lambda
11:54:08 <EvanR-work> :S
11:54:11 <Cale> Lambdas which are in parameter positions might not be
11:54:23 <djahandarie> chrisdone, I think all you need is a ringn = 0; in addToHistory
11:54:23 <Cale> Since it's only *head* normal form
11:54:24 <benmachine> let ones = 1 : ones in 1 : ((\x -> ones) 7) is in head normal form
11:54:42 <Polarina> Why is darcs recommended over, for example, git? For other reasons than it being written in Haskell.
11:55:04 <Cale> Polarina: I like the UI better.
11:55:10 <dyakovlev> is there a way to refer to first char of a string without cons syntax?
11:55:24 <Polarina> dyakovlev, head
11:55:30 <benmachine> Polarina: well, a lot of haskell people use it, so you save people the effort of learning yet another RCS
11:55:31 <dyakovlev> <3
11:55:37 <Cale> dyakovlev: You should be careful with using the head and tail functions.
11:55:38 <chrisdone> djahandarie: well I'm working on it tonight anyway so I'll try that
11:55:51 <Cale> dyakovlev: Both of them fail on the empty list, in a way that can be hard to debug.
11:56:04 <temoto> benmachine, nah it's client sockets don't get closed. I have a server via 'listenOn' and it returns handles. I connect via    echo "foobar" | nc localhost 19292   and do hClose on that handle. So socket ought to be closed from both sides.
11:56:14 <Cale> dyakovlev: So it's best to always use pattern matching unless you're *absolutely* sure that the list can't be empty.
11:56:19 <EvanR-work> there needs to be a list of functions in the prelude which 'may fail in a way thats hard to debug'
11:56:19 <dyakovlev> fair enough
11:56:37 <Polarina> Besides the popularity of darcs, why darcs instead of git (or why git instead of darcs)?
11:56:51 <benmachine> :t foldr const
11:56:52 <lambdabot> forall a. a -> [a] -> a
11:56:56 <benmachine> ^ headWithDefault
11:57:09 <glguy> :t listToMaybe
11:57:10 <lambdabot> forall a. [a] -> Maybe a
11:57:21 <benmachine> I never liked that name really
11:57:26 <djahandarie> :t maybeToList
11:57:27 <lambdabot> forall a. Maybe a -> [a]
11:57:30 <EvanR-work> listToMaybe is sort of inconvenient to use
11:57:37 <Cale> Polarina: istr that darcs does a *much* better job of merges.
11:57:41 <mibygl> I'd like to call it headOr, mimicking how "or" works in some languages.
11:57:47 <benmachine> git people are pretty keen on their merges
11:57:49 <chrisdone> Polarina: I use git for personal projects because I love github
11:58:03 <benmachine> I use git for personal projects because I know it already
11:58:05 <glguy> darcs is good if you don't want to branch much or work with other people
11:58:09 <chrisdone> (it's not really a technical decision for me)
11:58:31 <EvanR-work> use head in a place where you know the list isnt empty, because the pattern is a non empty list
11:58:35 <mibygl> You could, if the language were designed in precisely the right way, say 'head blah or error "Oi!"', and it would evaluate to error "Oi!" when there is no head.
11:58:37 <chrisdone> glguy: how come hpaste doesn't talk to the #haskell channel when someone pastes anymore?
11:59:04 <glguy> chrisdone, because the bot couldn't connect from mmorrow's server for some reason
11:59:17 <chrisdone> glguy: is that where it's hosted now? should I ask mmorrow about it?
11:59:35 <benmachine> > listToMaybe [] <|> Just 'y'
11:59:36 <lambdabot>   Ambiguous occurrence `<|>'
11:59:36 <lambdabot>  It could refer to either `Control.Applicative.<...
11:59:40 <benmachine> augh
11:59:54 <glguy> benmachine, if you are using a default, fromMaybe might be better
11:59:55 <benmachine> :t (Lava.<|>)
11:59:56 <lambdabot> Signal Bool -> Signal Bool -> Signal Bool
12:00:05 <benmachine> glguy: yes but it's less directly analogous
12:00:28 <glguy> otherwise you end up with a Maybe value that is always "Just"
12:01:06 <benmachine> Cale: could you stop lambdabot from importing Lava?
12:01:17 <benmachine> unless it's really cool in some way I don't appreciate
12:01:28 <Polarina> I am trying to convince a friend of mine to use darcs instead of git for a little project of ours. What should I say? :-)
12:01:50 <Zao> Polarina: Is it in Haskell? If not, no.
12:02:01 <Zao> Or convince him to go Mercurial.
12:02:01 <Polarina> Zao, it is a haskell project.
12:02:02 <tromp_> say "10 bucks if you use darcs"
12:02:10 <Zao> If it's in Haskell, darcs is what the romans use.
12:02:29 <FliPPeh> Any way to create FIFOs in Haskell?
12:02:32 <FliPPeh> The unix ones
12:02:33 <Cale> benmachine: Oh, okay.
12:02:35 <FliPPeh> Named pipes
12:03:10 <Zao> FliPPeh: Sounds like something the posix/unix packages ought to have.
12:03:11 <mibygl> If all else fails, you can write a cute little wrapper that creates FIFOs.  But I'm sure they're already possible.
12:03:11 <benmachine> Cale: thanks :)
12:03:24 <mibygl> @docs
12:03:24 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
12:03:29 <EvanR-work> FliPPeh: system.posix
12:03:43 <Zao> http://hackage.haskell.org/packages/archive/unix/latest/doc/html/System-Posix-Files.html
12:03:51 <Zao> http://hackage.haskell.org/packages/archive/unix/latest/doc/html/System-Posix-Files.html#v%3AcreateNamedPipe
12:05:03 <FliPPeh> createPipe :: IO  (Fd, Fd)
12:05:19 <Zao> FliPPeh: Not horribly named, are they?
12:05:19 <FliPPeh> This one looks like the socketPair
12:05:25 <FliPPeh> Yes
12:05:26 <FliPPeh> :x
12:05:34 <FliPPeh> I'm still browsing modules
12:06:12 <Cale> I remember there being a really good example page showing why a lot of VCSes (but not darcs, camp, and a few commercial ones) can silently produce incorrect results while merging.
12:06:31 <Cale> Just having problems locating it again
12:07:06 <mibygl> The Cabal isn't finding my GHC.  I notice that both of their executables are in /opt/local/bin, which is not on my PATH.
12:07:10 <erikc> Cale: http://projects.haskell.org/camp/unique ?
12:07:11 <mibygl> Where does Cabal look for GHC?
12:07:19 <Cale> not that one
12:08:18 <Cale> It had an example of making and merging some plausible changes in a simple piece of C code, and a merge that seemed like it should work resulting in compiling C code that had a bug.
12:08:43 <Cale> (because the merge happened in an unexpected way that didn't respect the history of the changes)
12:09:14 <Sgeo> return (mibygl) :: IO Chatter
12:09:15 <Cale> and a parallel example using simple files that had just letters in them
12:10:07 <mibygl> This error looks familiar: cabal: /Users/tannerswett/.cabal/packages: createDirectory: permission denied (Permission denied)
12:10:33 <benmachine> mibygl: have you been doing sudo cabal install <blah>?
12:10:46 <mibygl> hPutStr sgeo "Hello. How go things?"
12:10:53 <mibygl> benmachine: not that I recall.
12:11:04 <benmachine> mibygl: I used to get that because cabal would create directories in .cabal as root
12:11:16 <benmachine> that was until I started using root-cmd: in the config
12:11:25 <benmachine> which only uses root for what it needs
12:11:32 <benmachine> +grammar
12:11:36 <FliPPeh> Zao: Nothing in Posix :)
12:11:45 <FliPPeh> I think I'd need to browse hackage
12:11:46 <mibygl> Should I chown -R tannerswett .cabal?
12:11:51 <Sgeo> return "Good, although I hate that I just fell in love with unsafeInterleaveIO then was told it's unsafe. You?" >>= hPutStr mibygl
12:12:05 <Sgeo> --Not actually sure if that's correct
12:12:09 <benmachine> mibygl: it can't do any harm, but personally I'd have a look first to find out why that's necessary
12:12:13 <Zao> FliPPeh: So System.Posix.Files.createNamedPipe didn't suffice?
12:12:15 <clouds> what is this arrow stuff?
12:12:18 <Zao> (calls mkfifo)
12:12:27 <FliPPeh> I didn't see that one..
12:12:29 <FliPPeh> laaaame.
12:12:29 <benmachine> Sgeo: it is correct but redundant :P
12:12:38 <clouds> where is a primer on Haskell core?
12:12:38 <Zao> FliPPeh: See the second of my links above :)
12:13:04 <FliPPeh> Zao: I didn't see them, thanks :)
12:13:10 <benmachine> mibygl: find out who *does* own packages, and so guess how to stop it happening again
12:13:16 <mibygl> ($ "Well, I'm trying to install Agda in a satisfactory manner, and it's not going especially well.") (hPutStr sgeo)
12:13:54 <benmachine> mibygl: find . -not -user `whoami`
12:14:12 <benmachine> er, find .cabal
12:14:15 <benmachine> or whatever
12:14:58 <mibygl> I just did the chown and decided to hope it won't happen again.
12:15:07 <benmachine> suit yourself :P
12:15:18 <Sgeo> let ok_mibygl_wins = "I don't even know what Agda is" in hPutStr mibygl ok_mibygl_wins
12:15:38 <Cale> Oh, apparently it used to be here: http://zooko.com/badmerge/concrete-good-semantics.html
12:15:49 <Cale> But that seems down... I'll check the wayback machine
12:15:57 <mibygl> hPutStr sgeo $ error "I have to go, as my mom needs this computer to do her taxes."
12:16:18 <Sgeo> hPutStr mibygl "Bye"
12:17:15 <benmachine> hSeek benmachine AbsoluteSeek 8
12:17:33 <Cale> http://web.archive.org/web/20070606182509/http://zooko.com/badmerge/concrete-good-semantics.html
12:17:42 <Cale> there we go :)
12:19:11 <Cale> ^^ that's why you should use darcs ;)
12:20:10 <EvanR-work> whats better than (\[a,b] -> a ++ "." ++ b)
12:20:33 <chrisdone> that's the nicest way, I think
12:20:57 <Cale> intercalate "." ?
12:21:01 <EvanR-work> thats it
12:21:14 <EvanR-work> > intercalate "." ["google","com"]
12:21:15 <lambdabot>   "google.com"
12:21:42 <chrisdone> I always forget about intercalate
12:23:08 <EvanR-work> what about
12:23:18 <EvanR-work> (\[b,a] -> a ++ "." ++ b)
12:23:21 <ksf> http://www.cs.uu.nl/wiki/bin/view/Center/AspectAG
12:23:40 <BONUS> intercalate "." . reverse
12:23:41 <Cale> compose with reverse?
12:24:28 <EvanR-work> intercalate "." $ reverse $ take 2 $ reverse $ splitOn "." hostname
12:24:50 <chrisdone> intercalate "." . reverse . take 2 . reverse . splitOn "." $ hostname
12:25:17 <chrisdone> using . is more refactorable than using $
12:25:24 <EvanR-work> really
12:25:49 <chrisdone> yeah. let's say you want to move "intercalate "." . reverse . take 2 . reverse" to a function `foo'
12:26:02 <siracusa> Does Parsec's lower/upper exactly cover the permitted letters in a Haskell identifier?
12:26:04 <chrisdone> as it is, it works fine. but if it were $, you'd have to replace them all with ., or add a formal parameter
12:26:13 <JeanPijon> Is there any possibility to exit function before the end? (something similar like return() in C)
12:26:13 <EvanR-work> ok
12:26:34 <byorgey> JeanPijon: no
12:26:38 <martin____> I have the following question. Sorry if it sounds a bit vague, I'm new to Haskell. Essentially, I am thinking about building a (Beowulf) cluster using Haskell. Would it make sense to use openMosix (or it successor LinuxPMI) to get a single system image and then run Haskell just like on a regular multi-core machine? I mean, would it be possible to utilize the different nodes on a cluster in the sense that the threads would be m
12:26:38 <chrisdone> JeanPijon: depending on how deep you want to go, you could use continuations
12:27:35 <JeanPijon> chrisdone: I have some cascade of IFs and after some condition is met, I want to interrupt processing of the following ifs
12:27:42 <byorgey> siracusa: I don't think so, e.g. does 'lower' include underscores?
12:28:02 <chrisdone> JeanPijon: what are the ifs about? paste code?
12:28:19 <siracusa> byorgey: I mean only the letters, except for _ ' and digits
12:28:44 <byorgey> siracusa: oh, well, I think the answer is probably yes then. but I'm not 100% sure.
12:28:47 <chrisdone> siracusa: Haskell's parser is available if you want to parse a symbol with it
12:28:48 <Cale> martin____: Your message was cut off at "threads would be m"
12:28:49 <EvanR-work> JeanPijon: sounds like your function is too big
12:28:51 <FliPPeh> Seems like FIFOs are not what I need :/
12:29:00 <JeanPijon> chrisdone: similar like this:   if (yB+(vY*sp)) <= -1.0
12:29:00 <JeanPijon>    then vector $= (vX, -vY)
12:29:00 <JeanPijon>    else positionBall $= (xB+(vX*sp), yB+(vY*sp))
12:29:23 <martin____> Thanks, Cale. Here's the rest: I mean, would it be possible to utilize the different nodes on a cluster in the sense that the threads would be migrated to the nodes by openMosix?
12:29:30 <siracusa> chrisdone: I need it as a Parsec parser
12:29:36 <Cale> martin____: Well...
12:29:42 <JeanPijon> EvanR-work: well it is possible, it is my first project in haskell and I canÂ§t get rid off the classical C stzle>/
12:29:56 <chrisdone> siracusa: yeah but parsec is flexible enough for you to use your own parsing functions inside it
12:30:18 <EvanR-work> JeanPijon: you know, in C its often good to make the functions smaller too
12:30:27 <EvanR-work> its just harder since you can put function definitions inside functions
12:30:28 <Cale> martin____: The GHC scheduler won't be particularly aware of what's going on in a case like that. You can configure it to create more OS threads, and it will n:m schedule Haskell threads to OS threads which will presumably migrate over your network
12:30:41 <EvanR-work> cant8
12:30:49 <byorgey> JeanPijon: can't you just move the remaining stuff inside the 'else' so it doesn't get executed when the test is true?
12:30:50 <Cale> martin____: But there's no guarantee that this will happen in a really effective way. You can certainly try it.
12:31:24 <siracusa> chrisdone: What parsing functions for Haskell symbols do you mean?
12:31:37 <temoto> Wow, nginx behaves exactly the same. Leaves sockets with TIME_WAIT. I guess it's proper behaviour then.
12:31:43 <JeanPijon> byorgey: I can, but it will be one very ugly IF so if there is nothing like return() I will probably have to refactor it and do some abstraction
12:32:16 <byorgey> JeanPijon: right, well, refactoring and abstraction it is then =)
12:32:21 <benmachine> @src MaybeT
12:32:21 <lambdabot> Source not found. My mind is going. I can feel it.
12:32:24 <benmachine> oops
12:32:38 <benmachine> @hackage MaybeT -- this is (one of) the advanced option[s]
12:32:38 <lambdabot> http://hackage.haskell.org/package/MaybeT -- this is (one of) the advanced option[s]
12:32:41 <martin____> Cale: Thanks. What I'm concerned about is that (as far as I know) openMosix migrates OS processes, not OS threads.
12:32:55 <Cale> JeanPijon: I suppose you could use ContT and callCC to get C-like "return"
12:33:30 <Cale> JeanPijon: Of course, return in the ContT over IO, like return in all monads, has no effect. I mean you can call the function passed to you by callCC with the return value.
12:33:45 <jmcarthur> Cale: i was going to mention that, but was also going to mention that JeanPijon probably doesn't want that ;)
12:33:46 <Cale> martin____: Ah, okay
12:33:49 <chrisdone> siracusa: sorry, my connection's being really slow. I just went to investigate why. let me get the links
12:34:14 <siracusa> chrisdone: No problem
12:34:33 <jmcarthur> JeanPijon: when it comes to keeping if-then-else clean, guards are lifesavers
12:34:34 <Cale> martin____: Then it probably will make no difference at all unless you work out some sort of IPC scheme, since your Haskell program will all be one process.
12:34:36 <JoshTriplett> What function should should I use to expand ~ in a FilePath?
12:34:56 <JeanPijon> Cale: nice, but jmcarthur was right, i suppose:)
12:35:17 <JeanPijon> jmcarthur: ok, I have a look at them
12:35:23 <Cale> JeanPijon: Yeah, usually you don't want to mess around with continuations, but instead design the thing snely.
12:35:43 <Cale> JeanPijon: I just thought I'd point out it's possible to get the funky C-like control effects if you really want them.
12:35:56 <benmachine> http://haskell.org/haskellwiki/Case this has some interesting ideas
12:36:12 <jmcarthur> Cale: even funkier than C control effects ;)
12:36:24 <JeanPijon> Cale: :)
12:36:33 <Cale> Well, yes, you can do even worse with full continuations.
12:38:06 <Cale> I've actually gotten used to return doing nothing special, to the extent that it feels strange that many imperative languages implicitly wrap every function and sometimes every loop body in call/cc, and then give you this limited way of accessing the continuation ;)
12:38:10 <martin____> Cale: Thanks. Basically I was thinking if it is somehow possible to extend what is already possible with SMP to a cluster. Is there anything available in this area?
12:38:21 <Cale> er s/loop body/loop/
12:38:42 <JeanPijon> Thanks I'll give a try to the guards
12:38:52 <Cale> martin____: There has been work on distributed Haskell in the past, but I haven't heard much recent noise about it.
12:39:10 <Cale> martin____: Lately everyone has been more concerned about getting things working well in the SMP case.
12:39:53 <jmcarthur> JeanPijon: guards don't actually help you reorganize your code much aside from putting conditions along with your patterns, but they certainly have a nicer syntax for some kinds of conditionals :)
12:39:55 <JoshTriplett> Cale: Heh.  I have a "FinishT" monad that does exactly that; runFinishT starts the continuation and "finish someValue" ends it.
12:40:17 <JeanPijon> jmcarthur: thats right
12:40:21 <JoshTriplett> Cale: So you can do things like runFinishT $ forever $ do ...
12:40:29 <martin____> Cale: Yeah, there is also GPH, but it also seems a bit out of date. It's a pity.
12:40:46 <Cale> GdH
12:40:54 <Cale> GPH is merged into GHC proper
12:40:58 <SamB_XP> yeah, guards are like "cond"
12:41:06 <SamB_XP> very handy
12:41:59 <martin____> Cale: So this means GPH is actively maintained (sorry for my ignorance)?
12:42:03 <Cale> yes
12:42:17 <Cale> par and pseq work, and you can use them in normal Haskell programs
12:42:26 <Cale> But it's just SMP parallelism
12:42:32 <og01> hey im trying to install darcs, im using the cabal install command from within the darcs source. its moaning about missing dependencies for curl, now i've got libcurl and curl installed and i've checked and i've got libcurl.so in /usr/lib, how can i fidnout what file its looking for?
12:42:36 <jmcarthur> yay sparks!
12:43:03 <Cale> Also, all the strategies stuff is available in the parallel package.
12:43:51 <ezyang> I bet it's looking for headers, not the dynamic library
12:44:05 <Cale> (and the Haskell binding as well)
12:44:22 <chrisdone> siracusa: ah, my bad. I thought I'd seen something about parsing symbols. I've used Haskell.Language.Parser to parse a whole module and probably saw it in the parse result. you could use the internals from that hackage package but I guess you don't care that much about using the standard parser
12:44:36 <martin____> Cale: but doesn't it say something about clusters on the GPH website, too?
12:44:36 * hackagebot tbox 0.1.0 - Transactional variables and data structures with IO hooks  http://hackage.haskell.org/package/tbox-0.1.0 (PeterRobinson)
12:45:23 <Cale> martin____: Does it? Where?
12:45:53 <martin____> Cale: "The unstable branch of development is GUM-6.6 and it is currently being tested on a Beowulf cluster." http://www.macs.hw.ac.uk/~dsg/gph/
12:46:00 <inclement> I'm trying to install cabal. When I run bootstrap.sh, it tells me everything is fine but 'Setup: At least the following dependencies are missing: Cabal ==1.9.*', having previously said 'Cabal is already installed and the version is ok.'. Is there a way to fix this?
12:46:11 <Cale> Interesting
12:46:14 <EvanR-work> is there a pretty printer function, takes a parenthesized, bracketted, braced string and returns it with new lines and tabs?
12:46:28 <JoshTriplett> og01: Do you have libcurl's dev or devel package installed?
12:46:44 <chrisdone> EvanR-work: do you mean pretty printing haskell code?
12:47:07 <EvanR-work> no, only the usual results of show
12:47:10 <martin____> Cale: I just wasn't sure if this is an old message because the latest activity report on that page is from 2005.
12:47:44 <Cale> martin____: Theoretically, par would be okay to use in a distributed setting. Practically, it's somewhat more dubious, as the size of sparks you'd want to migrate over the network would (I think) be much larger than the size of sparks which it'd be okay to just let another core handle.
12:47:58 <JoshTriplett> EvanR-work: Some helper functions exist to help handle the parenthesizing and such for you, but to the best of my knowledge no standard functions exist to add newlines and such.
12:47:59 <og01> JoshTriplett: well i thought i had, im using this dodgy distro called slax
12:48:09 <og01> JoshTriplett: the packages arnt mantained very well
12:48:29 <EvanR-work> an example data would be a Data.Map.toList
12:48:34 <EvanR-work> would be nice if it had newlines
12:48:36 <JoshTriplett> og01: Do you have /usr/include/curl/* ?
12:48:49 <JoshTriplett> EvanR-work: Right; no, nothing that I know of.
12:48:59 <ezyang> og01: hmmm
12:49:07 <ezyang> og01: See if they have a -dev version of the package somewhere
12:49:10 <og01> JoshTriplett: yes i do
12:49:16 <JoshTriplett> og01: Then it *should* work...
12:49:17 <ezyang> oh.
12:49:20 <ezyang> :-/
12:49:21 <martinh_> Cale: Sorry, I just pressed the wrong button. Could you paste again what you just wrote?
12:49:23 <og01> ezyang: no they dontm they got durl and libcurl
12:49:38 <ezyang> you could try strace'ing the process and see what file it looks for before it barfs out
12:49:38 <Cale> <Cale> martin____: Theoretically, par would be okay to use in a distributed setting. Practically, it's somewhat more dubious, as the size of sparks you'd want to migrate over the network would (I think) be much larger than the size of sparks which it'd be okay to just let another core handle.
12:50:52 <siracusa> chrisdone: I'm not going to use it, but it answered my initial question: sIdent c = isAlpha c || ...
12:51:32 <chrisdone> siracusa: excellent
12:51:45 <chrisdone> siracusa: that's in internal.ly?
12:51:50 <martinh_> Cale: I'm not sure I understand. You mean that instead of migrating a spark over to a different node, it would be more efficient to just use another core on the same machine?
12:51:58 <siracusa> chrisdone: Yes
12:52:50 <Cale> martinh_: Yes, or given enough network latency, it might even be better to just compute it sequentially where you need it.
12:53:59 <Cale> martinh_: If your sparks are too small, you run into the problem that scheduling and communication cost more than the computation of the actual results.
12:54:43 <martinh_> Cale: OK, but if I would have for example a large multi-core server, I could use Haskell just 'out of the box?'
12:54:46 <Cale> In an SMP setting, the appropriate size of sparks is smaller than it would be in a distributed setting.
12:54:51 <Cale> yes
12:55:18 <Cale> There are some libraries you should be aware of though. (But I haven't tried them myself)
12:55:21 <Cale> http://hackage.haskell.org/package/Holumbus-Distribution
12:55:30 * Sgeo is looking at a definition of mapMaybe. Why can't it be just mapMaybe = catMaybes . map ?
12:55:37 <Sgeo> :t catMaybes . map
12:55:37 <Cale> http://hackage.haskell.org/package/erlang
12:55:38 <lambdabot>     Couldn't match expected type `[Maybe a]'
12:55:38 <lambdabot>            against inferred type `[a1] -> [b]'
12:55:38 <lambdabot>     Probable cause: `map' is applied to too few arguments
12:55:58 <Sgeo> erm
12:56:25 <chrisdone> EvanR-work: not particularly pretty, but customizable: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24606#a24606
12:56:33 <Sgeo> Well, I'd need to think a bit more, but surely it can be defined using catMaybes and map
12:56:58 <nolrai_FG> Hey GHC.Exts doesnt seem to expose S#? I can get I# but not S#. Ideas?
12:57:36 <martinh_> Cale: Thanks a lot. These packages pertain to a cluster or to 'just' a multi-core machine?
12:57:37 <og01> oh guys thanks for any help - i tried an all in one lib package instead ofthe libcurl package, and it works great
12:57:49 <Cale> martinh_: To a cluster
12:58:41 * hackagebot pqueue 1.1.0 - Reliable, persistent, fast priority queues.  http://hackage.haskell.org/package/pqueue-1.1.0 (LouisWasserman)
12:59:05 <Cale> martinh_: They're a lot more low-level and explicit than you might hope for though
12:59:28 <nolrai_FG> Is the documention I am looking at old?
12:59:39 <og01> ok not great now its failed with: dist/build/darcs/darcs-tmp does not exist
12:59:56 <martinh_> Cale: thaks a lot. I try to avoid MPI, so anything that is 'simpler' is fine with me! :)
13:02:10 <Cale> http://holumbus.fh-wedel.de/trac/wiki/Distribution -- this seems to describe Holumbus' distribution mechanism in more detail.
13:02:24 <edwardk> "We all know that object-oriented programming is dead and buried. Scala gives you a 'grace period'; you can use its deprecated support for objects until you've ported your code to use Monads." -- http://www.infoq.com/news/2010/04/scala-q
13:02:35 <chrisdone> haha, what
13:02:53 <edwardk> heya chrisdone. try haskell is getting more fancy looking by the day!
13:02:58 <clouds> well it is true
13:02:59 <clouds> OOP is OUT
13:03:13 <jmcarthur> oops is a useful abstraction... for certain things
13:03:18 <clouds> the new thing is PDD
13:03:22 <jmcarthur> and i don't mean very general thing like "games"
13:03:24 <twink> What's PDD?
13:03:27 <edwardk> jmcarthur: "oops" is the right name for it =)
13:03:31 <jmcarthur> haha
13:03:47 <clouds> twink: Payment Driven Development, screw method just pour cash on developers
13:03:52 <clouds> it works
13:04:00 <clouds> you give me cash and I will show you it works
13:04:07 <clouds> otherwise
13:04:09 <chrisdone> edwardk: hey there =) I just moved it onto a linode vps before, much better speed and uptime!
13:04:09 <clouds> no deal
13:05:02 <edwardk> it has nice patter to it. one thing i noticed though was that it popped up a message when it had a compilation error, which didn't go away when i entered the next command that did run successfully
13:05:08 <edwardk> so i had to hunt for the mouse to clear it
13:05:24 <twink> clouds: I anticipate "If you bring me Star Trek, I'll pay you a billion dollars."
13:05:48 <chrisdone> edwardk: oh, sure. I can make it autohide when you type
13:06:22 <martinh_> Cale: Great links, I wasn't aware of this. Now I have the following question (it sounds heretical to ask here, but I don't mean any disrespect): if I use holumbus with Hackage, why should I not just use Erlang?
13:06:25 <edwardk> but i ran through a dozen steps with someone and it worked flawlessly =)
13:07:03 <edwardk> martinh_: erlang has a number of advantages and disadvantages
13:07:05 <chrisdone> edwardk: nice! you got someone to try haskell :) what did they think of haskell?
13:07:54 <FliPPeh> chrisdone: Is step12 available already?
13:08:01 <edwardk> chrisdone: they liked it upon seeing that all haskell doesn't consist of my bizarre bits of very theoretical nonsense.
13:08:13 <chrisdone> edwardk: haha
13:08:19 <fax> I can't figure this out :[
13:08:20 <chrisdone> FliPPeh: not yet! I will add some tonight
13:08:26 <FliPPeh> Yay!
13:08:33 <FliPPeh> I need it to convert some peopple to haskell
13:09:14 <chrisdone> FliPPeh: if you have some steps you think would be good I can add them. I might need to reshuffle after some feedback from haskell newbies anyway
13:09:36 <Cale> martinh_: You could use Erlang directly, but you'd miss out on other benefits of Haskell. You could also mix Erlang and Haskell by using the erlang package from Hackage.
13:09:44 * hackagebot relative-date 0.0.1 - Durations and generalized time parsing  http://hackage.haskell.org/package/relative-date-0.0.1 (SamAnklesaria)
13:09:49 <FliPPeh> Maybe defining some polymorphic functions
13:09:58 <Cale> martinh_: (Hackage is our package respository, if that's not obvious)
13:11:00 <fax> does haskell know how to take primitive roots module n?
13:11:03 <fax> modulo*
13:11:13 <edwardk> martinh_: erlang's big advantage is the hotswap machinery and OTP. it also has a rtaher sexy garbage collector, which is made possible by the fact that you just can't build circular data structures at all. the latter can cost you an extra logarithmic term in asymptotic performance here and there
13:11:16 <chrisdone> FliPPeh: here's the tutorial format (in javascript + html): http://pastie.org/900838
13:11:24 <Cale> fax: That's way too special purpose to be built in :)
13:11:44 <fax> I have to find a generator for multiplicative group Z_p
13:12:53 <edwardk> fax: it is easy enough, try them all, run them to length p, then count unique values.
13:13:12 <martinh_> Thank you so much guys, all this information is very valuable.
13:13:12 <fax> okay
13:13:37 <chrisdone> FliPPeh: each page is an object with (1) a function which takes the result of the last page and produces a new message. it can see things like the expression and the type and (2) a trigger for this page, which is a predicate on the result of the previous page. so it basically lets you guide them through the steps interactively
13:13:39 <martinh_> Is there anything else I should (as a complete newbie) be aware of in terms of Haskell on a cluster?
13:14:04 <edwardk> martinh_: on the other hand on the haskell side you get type safety, (and type inference!) which brings along free theorems for reasoning about your code, and greater assurance that it is correct
13:14:15 <fax> > let p = 7 ; repeat 0 f = id ; repeat n f = f . repeat (n-1) f in map (repeat p ((`mod`p) . (^p))) [1..p-1]
13:14:16 <lambdabot>   [1,2,3,4,5,6]
13:14:22 <fax> o_O
13:14:44 <edwardk> in erlang you're more likely to handle when things go wrong correctly, in haskell you're more likely to write the code correctly in the first place, because it is harder to get code that goes wrong to compile ;)
13:14:57 <fax> > let p = 7 ; repeat 0 f x = [] ; repeat n f x = x : repeat (n-1) f (f x) in map (repeat p ((`mod`p) . (^p))) [1..p-1]
13:14:58 <lambdabot>   [[1,1,1,1,1,1,1],[2,2,2,2,2,2,2],[3,3,3,3,3,3,3],[4,4,4,4,4,4,4],[5,5,5,5,5...
13:15:03 <FliPPeh> chrisdone: Nice! Any testbed to test things out?
13:15:08 <fax> it doesn't seem to work
13:15:17 <fax> ohhh i get it
13:15:53 <chrisdone> FliPPeh: hmm good point. I mean, you could download the packages and run it locally, but I could probably hook up a testing version where you can feed it an arbitrary page list
13:16:04 <fax> > let p = 7 in map (\i -> map ((`mod`p) . (i^)) [1..p-1]) [1..p-1]
13:16:05 <lambdabot>   [[1,1,1,1,1,1],[2,4,1,2,4,1],[3,2,6,4,5,1],[4,2,1,4,2,1],[5,4,6,2,3,1],[6,1...
13:16:14 <FliPPeh> :)
13:16:17 <fax> so the one of this ^ which has everything in it -- is a winner
13:16:21 <edwardk> you probably want to start at 0
13:16:37 <fax> but 0 doesn't have a multiplicative inverse
13:16:52 <edwardk> fair enough
13:16:53 <FliPPeh> chrisdone: What's that "rmsg" doing? From the looks of it, it could display a random message, but I always get the same messages
13:17:01 <fax> im not sure if I have this right
13:17:08 <edwardk> so sort and nub
13:17:16 <chrisdone> FliPPeh: it does return a random string from the list
13:17:17 <edwardk> and then count
13:17:24 <fax> it says on wiki tehy are all cyclic groups (which is good)
13:17:25 <edwardk> its awful and inefficient but it'll work
13:17:41 <FliPPeh> chrisdone: I just figured, it only updates when the whole page is refreshed
13:17:45 <chrisdone> FliPPeh: indeed
13:17:57 <edwardk> 5,4,6,2,3,1 is your man
13:18:09 <chrisdone> FliPPeh: http://tryhaskell.org/js/tryhaskell.js
13:18:26 <edwardk> and 3,2,6,4,5,1also works
13:19:16 * FliPPeh installs XAMPP
13:19:36 <og01> can i use a --prefix like option for cabal?
13:20:03 <FliPPeh> og01: You can select whether it's install globally or locally
13:20:07 <fax> *** Exception: Maybe.fromJust: Nothing
13:20:09 <FliPPeh> --global --user
13:20:11 <fax> that's what my code does :[
13:20:12 <FliPPeh> Or was the ghc-only?
13:20:13 <ezyang> is x:y:xs equivalent to x:(y:xs)?
13:20:18 <chrisdone> fax: :(
13:20:25 <FliPPeh> fax :(
13:20:31 <fax> hehe
13:20:33 <FliPPeh> Thou shalt not "fromJust Nothing"
13:20:41 <FliPPeh> It enrages.. HIM
13:21:01 <fax> hmf it's not working
13:21:43 <martinh_> Cale and Edwardk: thanks a lot, I appreciate your feedback very much.
13:22:01 <fax> ah it's because indices are 0 based
13:22:42 <fax> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24607#a24607
13:22:44 <fax> I think this works
13:23:00 <mreh> indices in haskell should not be zero based, I propose it for Haskell'
13:23:01 <fax> it works for 3,5,7 and 11 so by induction it's correct for all values
13:23:04 <benmachine> ezyang: yes
13:23:09 <mreh> this breaking all code written before it
13:23:12 <fax> (not mathematical induction... the other kind)
13:23:48 <edwardk> fax: =)
13:23:56 <benmachine> fax: electrical induction?
13:24:01 <byorgey> doh! I upgraded my arch packages and it broke ghc =(
13:24:07 <chrisdone> FliPPeh: ok, http://82.33.137.16/tryhaskell/ I'll set this up so you can paste the tutorial code into it or some such?
13:24:19 <benmachine> mreh: arrays let you specify the index ranges
13:24:26 <XeZZ> hello, im a bit confused by the haskell page and this mailing lists (im new to haskell) and was searching for a forum where i can ask for some help
13:24:37 <mreh> benmachine: is that only unboxed arrays?
13:24:48 <fax> this is really weird
13:24:53 <benmachine> mreh: no
13:24:53 <fax> it doesn't work for p = 2
13:24:54 <fax> it doesn't work for p = 23***
13:25:01 <writer> XeZZ: this is one of the friendliest channels on Freenode :)
13:25:02 <fax> it's not defined for p=2 so that's fine
13:25:05 <FliPPeh> chrisdone: Looks fine, where would I paste?
13:25:10 <SamB_XP> XeZZ: this is such a forum
13:25:38 <chrisdone> FliPPeh: I'll add a textarea somewhere
13:25:38 <edwardk> XeZZ: this is a good place for that, as is the haskell-beginners mailing list
13:25:44 <FliPPeh> chrisdone: Okay!
13:25:54 <XeZZ> yey but what i was looking for is a normal forum forum xD
13:26:16 <XeZZ> so when i subscribe to the mailing list i get all this topics mailed?^^
13:26:30 <benmachine> mreh: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24608#a24608 the multiplication makes 1-indexed matrices
13:26:38 <chrisdone> XeZZ: that's right
13:26:46 <benmachine> and irrefutable patterns on them
13:26:51 <edwardk> XeZZ: academics are a bit slow to adopt new things. they've been using a mailing list for 20 years. no Haskell phpBB forums around ;)
13:26:55 <jmcarthur> i found a decent article talking about hash tables, trees and tries, submitted to reddit in the hopes of clearing up some of the confusion people seem to have about them, especially regarding hash tables which many people complain about haskell not having
13:27:06 <jmcarthur> http://www.reddit.com/r/programming/comments/blrhn/trees_hash_tables_and_tries/
13:27:37 <fax> > let l = [21,4,15,16,14,18,10,3,17,12,22,2,19,8,7,9,5,13,20,6,11,1] in (lenght l, lenght . nub . sort $ l)
13:27:38 <lambdabot>   Not in scope: `lenght'Not in scope: `lenght'
13:27:45 <fax> > let l = [21,4,15,16,14,18,10,3,17,12,22,2,19,8,7,9,5,13,20,6,11,1] in (length l, length . nub . sort $ l)
13:27:46 <lambdabot>   (22,22)
13:27:59 <jmcarthur> @oeis [21,4,15,16,14,18,10,3,17,12,22,2,19,8,7,9,5,13,20,6,11,1]
13:27:59 <lambdabot>  Sequence not found.
13:28:02 <fax> okay there is something really spooky going on in my code
13:28:15 <XeZZ> well i searched aot and only found 1 forum with very very tiny community ...
13:28:28 <fax> > map ((`mod`23).(20^)) [1..22]
13:28:29 <lambdabot>   [20,9,19,12,10,16,21,6,5,8,22,3,14,4,11,13,7,2,17,18,15,1]
13:28:31 <jmcarthur> sorting before nub doesn't actually speed it up
13:28:52 <jmcarthur> or change anything about the results of nub
13:28:56 <fax> O_o
13:29:05 <jmcarthur> > nub [21,4,15,16,14,18,10,3,17,12,22,2,19,8,7,9,5,13,20,6,11,1]
13:29:06 <lambdabot>   [21,4,15,16,14,18,10,3,17,12,22,2,19,8,7,9,5,13,20,6,11,1]
13:29:10 <jmcarthur> > nub [21,4,15,16,14,18,10,3,17,12,22,2,19,8,7,9,5,13,20,6,11,1,21]
13:29:11 <fax> > map ((`mod`23).(21^)) [1..22]
13:29:11 <lambdabot>   [21,4,15,16,14,18,10,3,17,12,22,2,19,8,7,9,5,13,20,6,11,1]
13:29:12 <lambdabot>   [21,4,15,16,14,18,10,3,17,12,22,2,19,8,7,9,5,13,20,6,11,1]
13:29:13 <edwardk> jmcarthur: nice link
13:29:30 <edwardk> jmcarthur: you're right, i couldn't remember if nub needed a sorted list =)
13:29:52 <dmhouse> > nub [3,2,3]
13:29:53 <lambdabot>   [3,2]
13:30:09 <dmhouse> It doesn't, which is why it's O(n^2).
13:30:12 <jmcarthur> > nub [1..]
13:30:13 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
13:30:35 <jmcarthur> nub is pretty smartly written
13:30:38 <dmhouse> If the element type is in Ord, then map head . group . sort is only O(n log n)
13:30:40 <jmcarthur> to be lazy like that
13:30:43 <xerox> ?src nub
13:30:43 <lambdabot> nub = nubBy (==)
13:30:56 <edwardk> dmhouse: hrmm it should be able to be O(n log n) if you wanted to give up the laziness
13:30:57 <jmcarthur> dmhouse: right
13:31:09 <dmhouse> > map head . group $ sort [1..] -- but it isn't as lazt
13:31:12 <temoto> Is there any string formatter better than printf?
13:31:13 <jmcarthur> edwardk: yeah, if implemented the way dmhouse said
13:31:13 <lambdabot>   mueval-core: Time limit exceeded
13:31:20 <edwardk> yea
13:31:30 <xerox> > map head . group . sort $ [1..] -- why stop with the dots
13:31:34 <lambdabot>   mueval-core: Time limit exceeded
13:31:35 <dmhouse> edwardk: why?
13:31:46 <dmhouse> xerox: fewer characters.
13:32:03 <fax> gack
13:32:04 <fax> this sucks
13:32:08 <edwardk> dmhouse: using an appropriate n log n sort.
13:32:19 <edwardk> fax?
13:32:21 <mreh> like bubble sort
13:32:21 <dmhouse> edwardk: one that didn't require Ord?
13:32:27 <fax> I can't write this progarm
13:32:33 <dmhouse> mreh: erm, bubble sort is O(n^2)
13:32:36 <mreh> lol
13:32:50 <fax> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24607#a24609 doesn't work either
13:33:11 <mreh> most sort algorithms are hard to do in haskell, use a purely functional sorting algorithm
13:33:21 <ezyang> benmachine: Curious. Because the syntax tree is grouped (x:y):xs, which is definitely different
13:33:24 <edwardk> dmhouse: i was agreeing with you that thwere was a faster way, we're using a lot of words to agree while you look for deeper meaning to my words ;)
13:33:29 <jmcarthur> mreh: most of the really bad ones, at least ;)
13:33:35 <dmhouse> edwardk: if you're in Ord and you don't care about laziness, map head . group . sort is O(n log n), as I said. If you're not in Ord or you want laziness, I think the best you can do is O(n^2)
13:34:01 <edwardk> dmhouse: as i said, i agree ;)
13:34:09 <chrisdone> FliPPeh: okay here we are: http://82.33.137.16/tryhaskell/
13:34:14 <jmcarthur> edwardk and dmhouse are in violent agreement
13:34:21 <dmhouse> edwardk: no, I agree!
13:34:26 <edwardk> dmhouse: i agreed first!
13:34:29 <XeZZ> is it Possible to update elements of a list without splitting it up and merge it together?
13:34:33 <fax> I fixed it
13:34:41 <fax> was getting negative numbers from powers being so big
13:34:54 <edwardk> XeZZ: the short and morally correct answer is 'no'
13:34:55 <mreh> XeZZ, what do you mean by update? you can't "update" things in haskell
13:34:59 <chrisdone> FliPPeh: you should be able to work with that? just copy that into your editor, edit it, paste back in to test?
13:35:03 <jmcarthur> XeZZ: sure. implement an imperative list in ST or IO, then you can update elements without rebuilding all you want. you pay the price though...
13:35:14 <mreh> haha
13:35:23 <xerox> ?faq can haskell update elements of a list?
13:35:23 <lambdabot> The answer is: Yes! Haskell can do that.
13:35:25 <edwardk> the long and morally bankrupt answer was just given by jmcarthur though ;)
13:35:27 <chrisdone> FliPPeh: assuming you know javascript here
13:35:27 <jmcarthur> s/imperative/mutable/
13:35:36 <FliPPeh> chrisdone: Should be pretty workable :)
13:35:52 <chrisdone> FliPPeh: excellent. the result object has two attributes, type and expr. pretty straight-forward
13:35:55 <dmhouse> > let replace x n = map (\(i,y) -> if i == n then x else y) . zip [1..] in replace 'E' 1 "hello"
13:35:56 <lambdabot>   "Eello"
13:36:07 <FliPPeh> chrisdone: I don't know it by heart, but I can understand and write it good enough
13:36:08 <XeZZ> well i vae a list with 3 Strings like ["123", "456", "789"] now i want to replace the 4 with an 'x' or something
13:36:15 <chrisdone> FliPPeh: sure =)
13:37:01 <dmhouse> > let replace x n xs = take n xs ++ x : drop (n+1) xs in replace 'E' 1 "hello"
13:37:03 <lambdabot>   "hEllo"
13:37:51 <dmhouse> XeZZ: take + drop is a fairly idiomatic way to replace an element of a list, yes.
13:38:00 <FliPPeh> chrisdone: Hitting "eval" doesn't really change much, sadly :(
13:38:11 <dmhouse> Where by "replace" I mean "obtain a new list which is like the old one, but you've swapped out a given element for something else".
13:38:11 <fax> does anyone have factorize :: Integer -> [Integer]?
13:38:21 <fax> it doesn't have to be really efficent I just want something short I can put into my file
13:38:35 <FliPPeh> Ah now
13:38:45 <jmcarthur> XeZZ: typically you wouldn't not use linked lists if you have to perform operations like that
13:38:58 <edwardk> XeZZ: there are functional ways to think about your problem. one tool that people use is called a zipper, which is like flaying open your list so that the start of the list is behind you and you are 'pointed at' the 4, but then you have to zip the list back up behind you
13:39:03 <jmcarthur> XeZZ: we have arrays and various trees and tries for things like that
13:39:33 <edwardk> xezz: but to jmcarthur's point, if you need to update something in the middle, it shouldn't be a list.
13:39:57 <chrisdone> FliPPeh: should just be able to hit eval and type help, or stepN where N is the step you want to test. note: if you jump to a step there'll be no result passed to the guide function, so your guide function should handle empty results
13:40:12 <edwardk> we have a lot of data structures that provide fast mutation in the middle. 'diffarrays', 'sequences', etc.
13:40:13 <jmcarthur> yeah, and as edwardk points out, if you are traversing the list arbitrarily (as opposed to completely random access) and changing things, a zipper is probably reasonable
13:40:22 <XeZZ> ok thx i will think about using an array though :P
13:40:42 <jmcarthur> XeZZ: we have many kinds of arrays, too, btw, so think hard ;)
13:40:58 <jmcarthur> XeZZ: if you really want mutation then make sure you use a mutable array or a diffarray
13:41:14 <FliPPeh> chrisdone: Something's borked there, when I paste in the whole source from "pastie" you gave me before, it only goes to step2
13:41:18 <edwardk> haskell is a funny language i can think of 7-8 array-like structures, but no decent hash table ;)
13:41:38 <jmcarthur> edwardk: i can think of few reasons to use a hash table, though
13:41:54 <jmcarthur> actually... i can't think of any at all at the moment
13:41:57 <edwardk> jmcarthur: true enough.
13:42:12 <chrisdone> FliPPeh: it shouldn't have the 'var' at the start
13:42:16 <edwardk> jmcarthur: i use a sorted linear hash table in my linear bloom filter code, but thats about it
13:42:46 <FliPPeh> chrisdone: It does
13:42:49 <jmcarthur> edwardk: ah bloom filters are an odd case
13:44:08 <jmcarthur> i guess if your keys are very large and you don't need to store them then a hash table might be preferable to a trie just to save space
13:44:31 <chrisdone> FliPPeh: hmm. it's not proceeding past step2 for me either
13:44:36 <jmcarthur> same argument applies to bloom filters
13:44:40 <dmhouse> let { is_prime n = all (\m -> n `mod` m /= 0) (takeWhile (\m -> m*m <= n) [2..]); first_prime n = head (filter (\m -> is_prime m && n `mod` m == 0) [2..n]); fac 1 = []; fac n = let p = first_prime n in p : fac (n`div`p) } in fac 204 -- fax, how's that?
13:44:44 <dmhouse> > let { is_prime n = all (\m -> n `mod` m /= 0) (takeWhile (\m -> m*m <= n) [2..]); first_prime n = head (filter (\m -> is_prime m && n `mod` m == 0) [2..n]); fac 1 = []; fac n = let p = first_prime n in p : fac (n`div`p) } in fac 204 -- fax, how's that?
13:44:44 <jmcarthur> vs some sort of trie map
13:44:45 <lambdabot>   [2,2,3,17]
13:44:59 <chrisdone> FliPPeh: something to do with pasting the source in the textarea, I imagine
13:45:05 <peaker_> @pl \m -> m*m <= n
13:45:05 <lambdabot> (<= n) . join (*)
13:45:19 <mreh> "An arrow transformer that adds a modifiable state, based of section 9 of Generalising Monads to Arrows, by John Hughes" - section 9 is about a CGI library, can someone elucidate where the State arrow comes into this?
13:45:21 <edwardk> jmcarthur: i use a hybrid hash/bloom filter to do big distributed joins across the network without knowing the set size on either end a priori
13:45:25 * dmhouse finds \m -> m*m <= n much clearer than (<= n) . join (*)
13:45:28 <chrisdone> FliPPeh: let me make it wider
13:45:39 <edwardk> jmcarthur: i think  i blogged it once
13:45:40 <peaker_> dmhouse, What about  (<= n) . (^2) ?
13:45:50 <FliPPeh_> Yuck, back I am
13:45:56 <dmhouse> peaker_: yeah, I personally still find the lambda clearer. Not much in it though
13:45:57 <edwardk> ah yep, i did: http://comonad.com/reader/2008/linear-bloom-filters/
13:46:00 <FliPPeh_> Internet reset
13:46:01 <dmhouse> The lambda just reads nicer.
13:46:10 <peaker_> dmhouse, I find points-free as readable these days (for most things) per-character, so since it's usually shorter, I find it more readable :)
13:46:12 <jmcarthur> edwardk: ah. that sounds like a variation on the need to save space
13:46:36 <peaker_> dmhouse, that is, I read both at the same speed, but with points-free there's usually less to read
13:46:48 <edwardk> jmcarthur: yeah, in this case it lets me save bandwidth, and then send iterative refinements of a base bloom filter until the other side decides it has enough resolution that it should just proceed.
13:47:15 <dmhouse> peaker_: in this case there's little in it. But when you start to introduce things like flip and sections of (.) (e.g. (f .) . g), I find it pretty difficult to read. Lambdas are underrated IMO.
13:47:16 <jmcarthur> edwardk: iterative refinements sounds cool
13:47:20 <fax> "Let d,D be factors of p-1 such that D=qd for some q" <-- this is hard to do
13:47:48 <edwardk> jmcarthur: basically its a 2-tier bloom filter, with a hash picking the bucket the other functions are distributed in, but the upper hash table is a litwin sorted linear hash table.
13:47:54 <dmhouse> fax: find two prime factors r and s of p-1, then your d and D are r and r*s
13:48:09 <fax> dmhouse but which ones?
13:48:14 <dmhouse> fax: does it matter?
13:48:18 <edwardk> jmcarthur: which means that i split buckets every n insertions, so i can have an expected population density per bucket of a given constant
13:48:21 <dmhouse> fax: oh, is q specified?
13:48:33 <chrisdone> FliPPeh_: oh wait, I know the problem
13:48:39 <fax> I don't think q is known
13:48:43 <fax> but it should be smaller than p
13:48:45 <dmhouse> fax: then any two will do
13:48:56 <edwardk> which allows me to deal with the individual blooms for the buckets, and or them together up the tree of splits. so refinement is just sending the delta for how to split each bit in the bucket
13:49:09 <jmcarthur> edwardk: hah, i like that you call one of these ideas mipmapping
13:49:14 <edwardk> =)
13:49:14 <fax> I think I have to parametrize by a monad so that the user can be asked (or a random number generator can pick, or some other process)
13:49:15 <chrisdone> FliPPeh_: fixed it. there was an undefined function that the Eval wasn't picking up
13:49:30 <chrisdone> FliPPeh_: close your tab and reload the page so the textarea is updated
13:49:33 <peaker_> dmhouse, flip is OK, imo.  If you use sections of (.) it's simply because you're probably not familiar with SECs
13:49:48 <peaker_> dmhouse, SECs make sections of (.) unnecessary and are far more readable (and more general than those)
13:49:49 <dmhouse> fax: if they want you to find two factors d and D of p-1 such that d is also a factor of D, then do what I said. If they *give you* a q and they want you to find two factors d and D of p-1 such that D = qd, then that's a bit harder (not impossible though)
13:49:51 <edwardk> i was using them in a distributed column store that proved not to be a commercially viable endeavor
13:49:54 <dmhouse> peaker_: SECs?
13:49:58 <peaker_> @where SEC
13:49:58 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
13:50:01 <peaker_> dmhouse, That
13:50:14 <jmcarthur> edwardk: anything is commercially viable
13:50:26 <jmcarthur> edwardk: i learned that by looking at successful products ;)
13:50:29 <FliPPeh_> chrisdone: Alright, let's see what I can come up with
13:50:33 <chrisdone> FliPPeh_: =)
13:50:49 <FliPPeh_> chrisdone: The "stepN" jumps are automatically updated?
13:51:04 <chrisdone> FliPPeh_: yep
13:51:04 <fax> I suppose i can always pick d=1 D=2
13:51:20 <fax> but smoetimes there might be a more interesting choice :/
13:51:24 <edwardk> jmcarthur: =) well, when stepping into any new market my usual first question is 'why me?' what do i bring to the table that makes my product a special snowflake. if i can't answer that question i'll still usually muddle through for a while, but at least then I _know_ I'm doing something stupid ;)
13:51:43 <dmhouse> fax: where has this problem come from? Are you sure you're interpreting it correctly?
13:51:55 <chrisdone> FliPPeh_: oh woops, I forgot to include the nemesis variable, refresh
13:51:59 <fax> dmhouse, I'm trying to implement this http://crypto.stanford.edu/pbc/notes/numbertheory/rootsunity.xhtml
13:53:00 <FliPPeh_> chrisdone: nemesis variable? :p
13:53:06 <jmcarthur> edwardk: i'm not qualified to say this, but i think the big secret is that you don't have to bring anything special to the table to have something commercially viable. you only need to convince others that you have something special
13:53:23 <edwardk> yeah
13:53:33 <chrisdone> FliPPeh_: yeah, you know where it asks you to `reverse "yourname"' :p
13:53:38 <edwardk> it helps to have a certain level of chutzpah ;)
13:53:43 <jmcarthur> having something special helps, but really, very few things are special ;)
13:53:47 <chrisdone> edwardk: what's chutzpah?
13:53:51 <fax> mabe i just take d and D as parameters for now
13:53:54 <ksf> http://www.haskell.org/haskellwiki/Research_area#._The_Expression_Problem
13:53:57 <ksf> wtf is that about?
13:54:01 <edwardk> chrisdone: http://en.wikipedia.org/wiki/Chutzpah
13:54:03 <ksf> chrisdone, guts
13:55:38 <ksf> "that quality enshrined in a man who, having killed his mother and father, throws himself on the mercy of the court because he is an orphan."
13:55:43 <ksf> that's a perfect description
13:56:36 <chrisdone> sounds like something mullah nasreddin would do
13:56:52 <FliPPeh_> Hmm, something simple about functions
13:58:03 <ksf> well, it claims to solve the expression problem and is written in a way that makes me wonder whether it's a markoff generator or crackpot
14:07:12 <dmhouse> Gah, why did I have to buy a laptop before Easter weekend. One of only two times in the year when "three working days" translates to a whole week.
14:08:20 <xerox> what did you decide in the end
14:09:34 <dmhouse> xerox: on the cheaper Acer (so Vista and 320GB). Sorry, went with the majority ;)
14:09:50 <dmhouse> I plan to spend as little time in Windows as possible so I couldn't really justify the extra cost
14:10:35 <fax> "Let ef=gh=p-1 where f divides g and k=g/f"
14:10:55 <fax> if you have factors = factorize (p-1), how do you pick e,f,g and h?
14:11:11 <fax> there seems to be multiple ways to do it
14:11:36 <FliPPeh_> chrisdone: Needs moar error reporting, finding errors it rather hard when they're silently ignored :)
14:11:48 <FliPPeh_> s/it/is
14:12:03 <fax> so should I just have f=g and e=h?
14:12:13 <fax> but then k = 1...
14:12:53 <chrisdone> FliPPeh_: one sec
14:13:23 <chrisdone> FliPPeh_: how about now
14:14:08 <FliPPeh_> chrisdone: Nice, thanks :)
14:17:59 <byorgey> fax: there is one choice of gh for each (multiset) 2-partition of the factors of p-1
14:18:13 <byorgey> fax: then you can just choose a subset of the factors of g, which gives you ef.
14:20:09 <fax> 2-partition means you just divide it into two parts?
14:20:14 <byorgey> right.
14:20:22 <fax> like {2,2,3,5} --> ({2,5},{2,3})
14:20:30 <byorgey> yep
14:20:34 <fax> so if I have a multiset is there code to find every two partition ?
14:20:49 <byorgey> fax: yes, see the multiset-comb package
14:21:02 <fax> !this is great thank you
14:22:17 <byorgey> once I release the new version of my species library you could even use it directly to generate all choices of e,f,g,h, since it corresponds to the species E^3
14:22:33 <byorgey> or (E+ * E) * E  if you want k /= 1
14:24:27 <fax> byorgey, what function from http://hackage.haskell.org/packages/archive/multiset-comb/0.2/doc/html/Math-Combinatorics-Multiset.html do you use?
14:24:48 <fax> oh splits
14:25:29 <byorgey> yeah, splits
14:26:08 <byorgey> there isn't a way to do size-n partitions for general n, but I think you could probably code that using recursive calls to splits
14:26:28 <theclaw> hi. is there an action which "does nothing"?
14:26:37 <theclaw> might be a stupid question :)
14:27:11 <Makoryu> theclaw: An IO action?
14:27:14 <Makoryu> Sure
14:27:16 <Makoryu> > return ()
14:27:17 <lambdabot>   No instance for (GHC.Show.Show (m ()))
14:27:18 <lambdabot>    arising from a use of `M102636731...
14:27:22 <Makoryu> Phhhffft
14:27:29 <Makoryu> :t return ()
14:27:33 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
14:27:34 <Makoryu> >:|
14:27:38 <Makoryu> There we go.
14:27:49 <Makoryu> theclaw: I suppose that's not what you're asking, though.
14:28:02 <theclaw> Makoryu: yes :). I'm thinking about what to ask right now ;)
14:29:04 <FliPPeh_> chrisdone: Before I jump ahead and write too much, how much of step12 and more have you covered already?
14:29:14 <Makoryu> theclaw: In Haskell, every function has a return value. The least meaningful return value is ()
14:29:18 <FliPPeh_> chrisdone: I'm currently going to explain the type of "(:)" ;x
14:29:38 <Sgeo> :t (:)
14:29:39 <lambdabot> forall a. a -> [a] -> [a]
14:29:48 <Sgeo> Oh, right
14:30:08 <chrisdone> FliPPeh_: I haven't done any more than that. I'm just setting up my blog with hakyll at the moment
14:30:26 <FliPPeh_> chrisdone: In that case, I shall continue!
14:30:33 <chrisdone> FliPPeh_: excellente
14:30:50 <theclaw> Makoryu: isn't there a function which has the type "(Monad m) => m a" ?
14:30:51 <chrisdone> FliPPeh_: I'm not sure about the whole syntactic sugar chapter, but yeah
14:30:55 <inclement> Delete, end, home etc. don't work in ghci (instead inserting '3~', 'F' and 'H' respectively), but most other stuff works (up/down for history, also ctrl+d for delete and so on). Don't know why this is...can I fix it?
14:31:32 <Makoryu> theclaw: Sure!
14:31:36 <Makoryu> :t return undefined
14:31:37 <lambdabot> forall a (m :: * -> *). (Monad m) => m a
14:31:41 <chrisdone> inclement: may be helpful http://www.haskell.org/haskellwiki/GHC/GHCi#Compatibility.2Fshell.2Fplatform_integration
14:31:59 <Makoryu> theclaw: Evaluating this will throw an error.
14:32:03 <FliPPeh_> chrisdone: In case you decide to add some of the chapters I do, you might want to modify them a bit so they match yours in term of formulations and language
14:32:19 <chrisdone> ok
14:32:27 <Makoryu> theclaw: Lemme ask this way. What are you trying to do, exactly?
14:32:44 <Makoryu> theclaw: If I had to guess, you're trying to write an if/then/else without the else branch :p
14:32:56 <theclaw> Makoryu: that's actually something rather obscure.
14:32:59 <theclaw> Makoryu: nope ;)
14:33:45 <benmachine> :t mfix return
14:33:45 <Makoryu> :t return
14:33:46 <lambdabot> forall a (m :: * -> *). (MonadFix m) => m a
14:33:46 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
14:33:53 <benmachine> pfft close enough
14:33:53 <Makoryu> @src mfix
14:33:53 <lambdabot> Source not found. I've seen penguins that can type better than that.
14:33:59 <benmachine> typeclass method
14:34:08 <Makoryu> @src MonadFix
14:34:08 <lambdabot> class (Monad m) => MonadFix m where
14:34:08 <lambdabot>     mfix :: (a -> m a) -> m a
14:34:19 <theclaw> Makoryu: I don't know right now how to explain, honestly
14:34:22 <inclement> chrisdone: Thank you
14:34:52 <peaker_> does anyone know how Django compares to various Haskell alternatives?
14:35:54 <jmcarthur> Makoryu: "The least meaningful return value is ()" i was about to disagree with this and say that Void is the least meaningful, but really i guess it could be more meaningful since it can be used for a function that never returns
14:36:19 <Makoryu> jmcarthur: Void as in "data Void;"?
14:36:24 <jmcarthur> yeah
14:36:31 <Makoryu> jmcarthur: Obviously that's not a return value at all ;)
14:36:36 <jmcarthur> exactly
14:36:45 <jdkoeck__> peaker_: that's an interesting question, I hope someone answers that (I'm not qualified)
14:36:49 <jmcarthur> therefore it gives more information about a function because it shows that it doesn't return
14:36:56 <jmcarthur> () doesn't say one way or the other
14:37:08 <benmachine> it could return undefined
14:37:16 <jmcarthur> benmachine: that's nontermination ;)
14:37:30 <dmhouse> benmachine: same as not returning
14:37:36 <FliPPeh_> :t all
14:37:37 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
14:37:43 <jmcarthur> :t forever
14:37:44 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
14:37:49 <benmachine> oh, yeah
14:37:51 <fax> byorgey, howw would you get all subsets? kSubsets for k = 1..size?
14:37:55 <benmachine> I thought we were talking about actual return
14:37:55 <jmcarthur> forever :: Monad m => m a -> m Void
14:37:57 <dmhouse> jmcarthur: if you look at it like that, then () gives more meaning than Maybe () because you know it either returns () or _|_, whereas the latter could return Just (), Nothing or _|_
14:38:25 <FliPPeh_> > all (isElem 'o') $ words "to moo or not to moo"
14:38:26 <lambdabot>   Not in scope: `isElem'
14:38:33 <FliPPeh_> > all (elemOf 'o') $ words "to moo or not to moo"
14:38:34 <lambdabot>   Not in scope: `elemOf'
14:38:36 <FliPPeh_> :/
14:38:41 <benmachine> :t elem
14:38:42 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
14:38:48 <FliPPeh_> > all (elem 'o') $ words "to moo or not to moo"
14:38:49 <lambdabot>   True
14:38:51 <FliPPeh_> :)
14:38:54 <dmhouse> > all ('o' `elem`) $ words "to moo or not to moo"
14:38:55 <lambdabot>   True
14:38:59 <fax> maybe map fst $ splits
14:39:12 <dmhouse> fax: you want all subsets of a list?
14:39:18 <fax> of a multiset
14:39:22 <jmcarthur> dmhouse: if the function could return only _|_ or Just () then i would say it's more meaningful to give its return type () instead of Maybe ()
14:39:37 <dmhouse> jmcarthur: that's not what I said.
14:39:38 <peaker_> @type maybe map fst
14:39:39 <lambdabot> forall a b b1. Maybe ((a -> b) -> [a] -> [b], b1) -> (a -> b) -> [a] -> [b]
14:39:42 <jmcarthur> dmhouse: i know
14:40:02 <dmhouse> jmcarthur: point is, you have to be precise about what you mean by a "meaningful" return value
14:40:31 <jmcarthur> dmhouse: i just mean i was implicitly saying that "meaningful" means "tight specification"
14:41:07 <fax> is there a list minus? like  [a,b,c,b,a] \ [a,a,b] = [c,b] ?
14:41:08 <dmhouse> > let subsets [] = [[]]; subsets (x:xs) = subsets xs ++ map (x:) (subsets xs) in subsets [1,2,3]
14:41:09 <lambdabot>   [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
14:41:10 <benmachine> the difference between 0 and 1 possible values is more interesting than the difference between 1 and 2
14:41:18 <dmhouse> > [1..4] \\ [1,2]
14:41:19 <lambdabot>   [3,4]
14:41:20 <jmcarthur> benmachine: how so?
14:41:30 <fax> cool!
14:41:32 <fax> thanks
14:41:35 <benmachine> jmcarthur: ummm, pas
14:41:36 <benmachine> pass
14:41:52 <dmhouse> fax: there's a subsets algorithm. It's easy to modify that if you only want subsets of a given size, too
14:42:01 <Makoryu> > delete 'o' "to moo or not to moo"
14:42:02 <lambdabot>   "t moo or not to moo"
14:42:06 <Makoryu> à² _à² 
14:42:09 <jmcarthur> benmachine: and really, we were talking about the difference between 1 and 2 values vs. the difference between 2 and 4 values ;)
14:42:11 <Makoryu> Oh right
14:42:26 <jmcarthur> Maybe () has _|_, Nothing, Just _|_, and Just ()
14:42:27 <dmhouse> > filter (/= 'o') "to moo or not to moo"
14:42:28 <lambdabot>   "t m r nt t m"
14:42:43 <mibygl> Hmm.  I think the machine I was using for development has vanished.
14:42:44 <Sgeo> :i >>=
14:42:50 <Sgeo> :i (>>=)
14:44:02 <Makoryu> @info (>>=)
14:44:02 <lambdabot> (>>=)
14:44:06 <Makoryu> Â¯\O_o/Â¯
14:44:14 <Makoryu> @src (>>=)
14:44:14 <lambdabot> Source not found. Take a stress pill and think things over.
14:44:16 <mibygl> > head . fst . filter (uncurry (==)) . (\x -> zip x (tail x)) . iterate (delete 'o') $ "to moo or not to moo"
14:44:17 <lambdabot>   Couldn't match expected type `([a], b)'
14:44:17 <lambdabot>         against inferred type `[(a1...
14:44:18 <Makoryu> @src Monad
14:44:18 <lambdabot> class  Monad m  where
14:44:19 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
14:44:19 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
14:44:19 <lambdabot>     return      :: a -> m a
14:44:21 <lambdabot>     fail        :: String -> m a
14:44:35 <jmcarthur> > filter (not . (`elem` "aeiou")) "The quick brown fox jumps over the lazy dog."
14:44:36 <lambdabot>   "Th qck brwn fx jmps vr th lzy dg."
14:44:43 <mibygl> :t (\x -> zip x (tail x)) . iterate (delete 'o') $ "to moo or not to moo"
14:44:44 <lambdabot> [([Char], [Char])]
14:45:01 <mibygl> > fst . head . filter (uncurry (==)) . (\x -> zip x (tail x)) . iterate (delete 'o') $ "to moo or not to moo"
14:45:02 <lambdabot>   "t m r nt t m"
14:45:04 <Sgeo> :t infixl
14:45:05 <lambdabot> parse error on input `infixl'
14:45:08 <mibygl> There we go.
14:46:38 <fax> this stuff I am trying to program is very very difficult I don't think I can do it :D
14:46:39 <jmcarthur> i think  iterate . delete  ==  filter . (/=)
14:47:17 <jmcarthur> oh, no
14:47:24 <jmcarthur> it's even worse than i thought
14:47:25 <jmcarthur> ;)
14:47:32 <jmcarthur> :t iterate . delete
14:47:33 <lambdabot> forall a. (Eq a) => a -> [a] -> [[a]]
14:47:35 <benmachine> last . iterate . delete -- :)
14:47:35 <jmcarthur> ah!
14:48:11 <zakwilson> I'm trying to map a function over a directory of some 20,000 files containing serialized instances of (Map Integer Integer). The function must read the file and return (FilePath, Integer). After that, the file should be eligable for GC. My research suggests the solution involves unsafeInterleaveIO, but I'm not really sure how to use it. My current implementation consumes much more memory than is needed (until it starts swapping and I kill
14:48:12 <zakwilson> it)
14:48:17 <mibygl> My method is the most beautiful thing I've ever seen.
14:49:10 <mibygl> You can always open it, read it, and close it manually.
14:49:53 <mibygl> I think.
14:50:09 <zakwilson> My problem isn't that it isn't being closed, but that the data is remaining in memory. I think.
14:50:35 <zakwilson> I previously had problems with too many files open at once, but I found how to use unsafeInterleaveIO to prevent that.
14:51:13 <mibygl> Huh.
14:52:05 <zakwilson> I want to read a file, perform a calculation on its contents, keep the result of the calculation, and GC the contents.
14:52:37 <mibygl> Well, it seems that once the calculation is performed, the contents should be GC'd.
14:52:46 <mibygl> Maybe you're not forcing the calculation?
14:53:16 <orlandu63> what's the square-root function defined as?
14:53:52 <zakwilson> That's a distinct possibility. Is there a standard way to force a function to be evaluated at a specific point in code?
14:54:02 <fax> > ((1/4)*(-1+sqrt(5)+2*sqrt(-5/2-sqrt(5)/2)))^5 :: Complex Double
14:54:03 <lambdabot>   0.9999999999999999 :+ (-1.1102230246251565e-16)
14:54:16 <zakwilson> I googled that and didn't come up with anything general and obvious.
14:54:55 <temoto> @type sqrt
14:54:56 <lambdabot> forall a. (Floating a) => a -> a
14:55:01 <temoto> orlandu63, ^
14:55:02 <orlandu63> @src sqrt
14:55:02 <lambdabot> Source not found. My brain just exploded
14:55:03 <fax> zakwilson, don't force stuff to be evaluated
14:55:24 <orlandu63> temoto: @src ^ shows that it throws an error given a negative exponent
14:55:32 <orlandu63> @srrc (^)
14:55:33 <lambdabot> x ^ 0            =  1
14:55:33 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
14:55:33 <lambdabot>   where f _ 0 y = y
14:55:33 <lambdabot>         f x n y = g x n
14:55:33 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
14:55:35 <lambdabot>                       | otherwise = f x (n-1) (x*y)
14:55:37 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
14:57:03 <zakwilson> fax: alright. How should I map a function over a list of many filenames and gurantee that I don't get all the files in memory at once?
14:57:26 <benmachine> zakwilson: I think unsafeInterleaveIO is a mistake
14:57:28 <Aristid>  :t (^)
14:57:38 <benmachine> you should open each file, process it, and then close it before moving onto the next
14:57:40 <temoto> orlandu63, my guess is that for more complex arguments there ought to be some kind of Math module with proper implementation of everything.
14:57:42 <Aristid> :t (^)
14:57:43 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
14:58:52 <benmachine> zakwilson: depending on the nature of the computation, you may wish to force evaluation of the result before continuing
14:59:09 <orlandu63> temoto: i'm assuming there is no haskell implementation of sqrt, but rather it has a c implementation
14:59:10 <benmachine> zakwilson: you can do that with the 'evaluate' IO action
14:59:23 <FliPPeh_> My X.org is eating 78% RAM...
14:59:38 <benmachine> orlandu63: you could implement in haskell if you liked, but I don't think it would be helpful
14:59:47 <benmachine> it isn't necessarily C though, it could be ASM
15:00:09 <zakwilson> benmachine: from Control.Exception?
15:00:19 <benmachine> zakwilson: yeah, I think so
15:00:35 <benmachine> zakwilson: but I wouldn't use it unless you're sure it's necessary
15:00:51 <orlandu63> i think im going to implement it to practice
15:01:30 * hackagebot syb-with-class-instances-text 0.0.1 - Scrap Your Boilerplate With Class Text instance  http://hackage.haskell.org/package/syb-with-class-instances-text-0.0.1 (JeremyShaw)
15:04:09 <zakwilson> benmachine: Alright. I'll rewrite in a less modular, less functional way, mixing logic with IO, and see if it Just Works before I try evaluate.
15:06:51 <jdsc> oh coo, there's a text instance for syb, didn't even know that :)
15:06:59 <Mathnerd314> @type (.)
15:07:00 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:07:03 <Mathnerd314> @type fmap
15:07:04 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:07:17 <Mathnerd314> coincidence?
15:07:33 <xerox> no
15:07:47 <xerox> f = (e ->)
15:08:11 <Mathnerd314> so fmap == . ?
15:08:12 <jmcarthur> Mathnerd314: lambdabot's definition of (.) is not the same as the standard library's
15:08:20 <Mathnerd314> oh.
15:08:26 <jmcarthur> Mathnerd314: one instance of functor defines fmap as (.)
15:08:36 <xerox> Mathnerd314: so instance Functor Reader where fmap = (.) (modulo packing and unpacking)
15:08:47 <jmcarthur> Mathnerd314: instance Functor ((->) e) where fmap = (.)
15:08:58 <xerox> modulo we can't do that
15:09:15 <Mathnerd314> -xflexibleinstances?
15:09:56 <xerox> but then somebody thinks . is a better name than fmap, and there it goes into lambdabot
15:10:15 <writer> hi everyone
15:10:53 <writer> How do I catch errors, .e.g. when empty list is passed as parameter to head  ?
15:10:59 <writer> > head []
15:11:00 <lambdabot>   * Exception: Prelude.head: empty list
15:11:40 <kpreid> writer: it is better not to do so
15:11:43 <Mathnerd314> :t listToMaybe
15:11:44 <lambdabot> forall a. [a] -> Maybe a
15:12:27 <writer> kpreid: okay, but if i add checks before usage of head, then it makes code ugly ?
15:13:17 <kpreid> writer: then write the checks prettier
15:13:39 <kpreid> the sort of error (undefinedness) which you get from head [] is one which *should not happen*
15:13:45 <jdsc> writer: see that chapter of real world haskell http://book.realworldhaskell.org/read/error-handling.html
15:13:54 <kpreid> if the list might be empty then you shouldn't assume it isn't
15:14:11 <kpreid> instead, use something else that naturally expresses what to do when the list is empty
15:14:22 <writer> okay
15:14:34 <writer> thanks jdsc, going through that.
15:15:50 <jdsc> writer: to compile the error handling examples from real world haskell, replace "import Control.Exception" by "import Control.OldException"
15:16:11 <jdsc> writer: error handling has changed in recent versions of ghc
15:16:50 <writer> okay, jdsc. are there any maybe wrappers already present ?
15:17:01 <writer> like safeTail ?
15:18:32 <Mathnerd314> :t listToMaybe
15:18:33 <lambdabot> forall a. [a] -> Maybe a
15:18:41 <Mathnerd314> safe version of head
15:19:19 <jdsc> writer: the safe package has maybe wrappers: http://hackage.haskell.org/package/safe
15:19:33 <fax> I can't do it I give up
15:19:42 <xerox> don't :(
15:19:52 <writer> thanks Mathnerd314 I didn't realized that was for me.
15:20:44 <writer> adding another dependency seems too much.
15:21:19 <tensorpudding> if you need to use head, pattern matching on the list that is an argument to head, and including a match on [], is usually good idea
15:22:13 <fax> okay what I will to is work through some examples so I 'feel' the algorithm and then see it I can code it
15:24:53 <FliPPeh> chrisdone: http://pastie.org/901064
15:24:57 <FliPPeh> I made it to step13 so far
15:25:03 <FliPPeh> You might want to quick-check it :)
15:25:08 <FliPPeh> I think I'm moving too fast there
15:30:13 <Mathnerd314> FliPPeh: is this tryhaskell.org?
15:30:23 <FliPPeh> Mathnerd314: Yep
15:31:27 <Mathnerd314> live?
15:31:34 <FliPPeh> Nah
15:31:46 <FliPPeh> The original website is stuck at step11
15:32:02 <Mathnerd314> ok.
15:33:46 <Mathnerd314> so you're continuing it?
15:35:13 <FliPPeh> Well, it's still Chris' child, I'm just doing some steps for it at the moment, maybe if he likes what I'm doing
15:35:17 <[swift]_> so i have a design question that i'm not sure how to resolve. i'm writing a parser, and its convenient to define a syntactic rule as a list of Symbols, where a Symbol is either a Nonterminal or a Terminal. so I have a Symbol ADT with those constructors. the tricky part is that i also have lexical rules, and i'd like them to be defined as a Terminal symbol and a regex. The problem is that I can't write LexRule = LexRule Terminal String, but i
15:35:17 <[swift]_> have to use LexRule Symbol String. is there some way around this?
15:42:02 <jlouis> [swift]_: perhaps with a GADT?
15:42:10 <Mathnerd314> > (:)
15:42:11 <lambdabot>   {()->{[]->[()];[()]->[(),()];[(),()]->[(),(),()];[(),(),()]->[(),(),(),()]}}
15:42:11 <jlouis> [swift]_: I am not sure what you want
15:42:37 <Mathnerd314> chrisdone: in tryhaskell that fails :-(
15:42:54 <[swift]_> jlouis: basically i'd like the type system to ensure that a LexRule can only be constructed with a Terminal, if that's possible. (I don't know if it is)
15:43:04 <jmcarthur> Mathnerd314: lambdabot includes an instance of Show for functions from the smallcheck package
15:43:10 <FliPPeh> Mathnerd314: So does it in GHCi
15:43:28 <jmcarthur> @instances Show
15:43:29 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, ST s a, Sum a, [a]
15:43:39 <jmcarthur> functions aren't normally an instance of Show
15:44:04 <jmcarthur> wait, there's an instance for ST?!
15:44:21 <FliPPeh> What is ST?
15:44:34 <Saizan> [swift]_: if you amke your Symbol ADT a GADT you can parametrize it with a typelevel flag that signals if it's a terminal one or not
15:44:35 <xerox> IO without I/O
15:44:38 <jmcarthur> FliPPeh: allows you to use mutation in a referentially transparent functions safely
15:44:41 <FliPPeh> > (1,2,3,4,5,6,7)
15:44:41 <jmcarthur> *function
15:44:42 <lambdabot>   (1,2,3,4,5,6,7)
15:44:53 <FliPPeh> hmm
15:45:02 <jlouis> [swift]_: what Saizan said
15:45:10 <[swift]_> Saizan, jlouis: thanks; looking that up now
15:45:44 <ddarius> > show (readSTRef undefined)
15:45:45 <lambdabot>   "<<ST action>>"
15:46:53 <pikhq> I'm... Very curious how that show instance is defined. If it's naive, I'm going to just find that silly.
15:47:11 <idnar> I would guess: show _ = "<<ST action>>"
15:47:17 <pikhq> Yeah.
15:47:22 <pikhq> That's just silly.
15:47:24 <ddarius> It's not a standard instance
15:47:31 <idnar> > show (return () :: IO ())
15:47:32 <lambdabot>   "<IO ()>"
15:47:43 <pikhq> Ah.
15:47:50 <idnar> the Show instance for functions comes from SmallCheck, I believe
15:48:03 <SamB_XP> idnar: yup
15:48:29 <idnar> if SmallCheck generates a counterexample for a function value, it's useful to get an idea of what the function is
15:54:29 <dancor> > (+ 1)
15:54:30 <lambdabot>   {-3->-2;-2->-1;-1->0;0->1;1->2;2->3;3->4}
15:54:35 <xerox> > succ
15:54:36 <lambdabot>   * Exception: Prelude.Enum.().succ: bad argument
15:54:41 <dancor> you succ
15:54:46 <xerox> man, do I
15:55:07 <dancor> > succ :: (Int -> Int)
15:55:08 <lambdabot>   {-3->-2;-2->-1;-1->0;0->1;1->2;2->3;3->4}
15:55:11 <dancor> :t succ
15:55:11 <lambdabot> forall a. (Enum a) => a -> a
15:55:29 <dancor> > fromInt 0 :: ()
15:55:30 <lambdabot>   Not in scope: `fromInt'
15:55:55 <dancor> > toEnum 0 :: ()
15:55:56 <lambdabot>   ()
15:55:59 <dancor> > toEnum 1 :: ()
15:56:00 <lambdabot>   * Exception: Prelude.Enum.().toEnum: bad argument
15:56:20 <dancor> > succ . const 0
15:56:21 <lambdabot>   {()->1}
15:57:41 <dancor> being non-reflective isn't really in the "definition" of haskell as a lazy pure functional language is it?
15:57:46 <dancor> or is that part of "pure"
15:58:17 <jmcarthur> you'll have to define what reflective would mean for haskell i think
15:58:54 <dancor> jmcarthur: i'm talking about having a funcReflect :: a -> AST
15:59:00 <dancor> or (a -> b) -> AST, not sure
15:59:23 <dancor> ASTWithComments even!
15:59:37 <dancor> dream big
16:00:04 <jmcarthur> dancor: honestly, while i don't think it would necessarily violate the haskell spec, i don't like that. i prefer full abstraction
16:00:22 <dancor> i guess you can already make a Reflectable typeclass and rebuild standard libs in it
16:00:54 <jmcarthur> i think it would need to be primitive
16:00:55 <ksf> oleg claims in http://okmij.org/ftp/Haskell/types.html#de-typechecker that haskell is reflective
16:00:58 <dancor> and comments would be some string combinator
16:01:07 <jmcarthur> ksf: i'll have to check that out
16:04:17 <EvanR> is reflective really that great
16:04:48 * ksf hands jmcarthur a new d20 no re-try his saving throw against confusion
16:05:21 <Mathnerd314> cool, it works
16:05:40 <ksf> n, t. middle finger or ring finger, that's the question.
16:10:11 <wavewave> is anyone using bluetile ?
16:10:34 <ksf> bluetile is herecy
16:10:59 <ksf> it's not by accident that xmonad is named after an ancient african word meaning "you don't need a mouse, dummy"
16:11:30 <Makoryu> ï¼ˆã€€â‰–â€¿â‰–ï¼‰
16:11:41 <Makoryu> What African language is that, pray tell?
16:11:49 <wavewave> bluetile/xmonad is great!
16:11:50 <jlouis> Makoryu: Monadicu
16:12:10 <wavewave> btw, I want to have mouse autofocus in bluetile.
16:12:23 <Makoryu> I think that's spoken in Prague.
16:12:26 <wavewave> which xmonad without bluetile has.
16:12:32 <ksf> sloppy focus follows mouse is default in xmonad
16:12:33 <burp> the same language that ubuntu is "can't install debian" in? ;)
16:12:45 <wavewave> how can i customize bluetile?
16:13:05 <dobblego> I don't think you can at the moment
16:13:07 <EvanR> hack the source
16:13:08 <ksf> I guess in the same way as xmonad
16:13:21 <dobblego> I know someone who has by modifying source and recompiling
16:13:25 <wavewave> in fact, i am also a newbie in xmonad.
16:13:34 <ksf> did xmonad upstream accept bluetile's changes to core?
16:14:29 <ksf> wavewave, if you have customization needs, I guess it's worth the time to get going on pure xmonad
16:15:12 <ksf> (learning how to do it takes way less time than actually deciding/figuring out what you want)
16:15:35 <wavewave> ksf: I understand it. But I would like to stick to bluetile default set up since it's so intuitive.
16:16:08 <wavewave> ksf: anyway, it is worth looking at the insider :)
16:16:19 <Saizan> #xmonad should know more
16:16:26 <wavewave> inside I mean.
16:16:37 <wavewave> oh. it has a separate channel.
16:16:43 <wavewave> thx.
16:17:25 <chrisdone> FliPPeh: sorry I didn't check emacs
16:17:40 <ksf> you don't have to make excuses for that.
16:17:40 * chrisdone tries it
16:17:40 <FliPPeh> chrisdone: No problem!
16:17:43 <wavewave> anyway, bluetile is incooperated in xmonad main branch, so now we don't have to call it bluetile anymore?
16:17:51 <ksf> that'd be like saying "sorry I didn't rape you"
16:17:57 <FliPPeh> chrisdone: I made some improvements to that
16:18:07 <fax> > let w = exp (2*pi*sqrt(-1)*(1/17)) :: Complex Double in (sum $ map (w^) [3,10,5,11,14,7,12,6])*(sum $ map (w^) [9,13,15,16,8,4,2,1])
16:18:08 <lambdabot>   (-3.999999999999999) :+ (-5.064340960824007e-16)
16:18:18 <fax> > let w = exp (2*pi*sqrt(-1)*(1/17)) :: Complex CReal in (sum $ map (w^) [3,10,5,11,14,7,12,6])*(sum $ map (w^) [9,13,15,16,8,4,2,1])
16:18:22 <lambdabot>   mueval-core: Time limit exceeded
16:18:23 <FliPPeh> chrisdone: http://pastie.org/901124
16:18:30 <FliPPeh> That's my current snapshot, 7 seconds ago
16:18:57 <FliPPeh> I'm still not happy, but it's an improvement
16:23:03 <chrisdone> FliPPeh: step12 doesn't seem to want to proceed with that paste
16:23:30 <FliPPeh> chrisdone: Does for me
16:24:10 <chrisdone> function(resulat){ <- typo
16:24:29 <FliPPeh> Whow, when did that happen?
16:24:37 <FliPPeh> Probably when I hitted "ctrl-a"
16:24:41 <chrisdone> hehe
16:25:06 <FliPPeh> s/hitted/hit
16:27:19 <chrisdone> I like the wording but I think the fact you need a few paragraphs means you're going too deep
16:27:30 <FliPPeh> I think so too
16:28:03 <chrisdone> it's hard to judge what's easy and interesting to a newbie
16:28:16 <FliPPeh> I basically wanted to just cover polymorphism first
16:28:19 <chrisdone> my nonprogrammer friend suggested we add more examples of types
16:28:35 <chrisdone> like, an integer, a character, a couple functions
16:28:35 <FliPPeh> But I had to show how "a -> [a] -> [a]" could become "Char -> [Char] -> [Char]"
16:28:50 <Mathnerd314> chrisdone: could you just do the examples from LYAH?
16:28:51 <FliPPeh> And it would only become that, when a char was applied
16:29:05 <FliPPeh> So I had to put that in, too
16:29:07 <fax> or a type annotation
16:29:15 <FliPPeh> Nah
16:29:20 <FliPPeh> :t (:) :: Char
16:29:21 <lambdabot>     Couldn't match expected type `Char'
16:29:21 <lambdabot>            against inferred type `a -> [a] -> [a]'
16:29:21 <lambdabot>     In the expression: (:) :: Char
16:29:23 <chrisdone> maybe I can insert some more fundamental bits before your advanced stuff
16:29:59 <chrisdone> Mathnerd314: let me check them!
16:30:14 <Mathnerd314> http://learnyouahaskell.com/starting-ou
16:30:18 <Mathnerd314> *http://learnyouahaskell.com/starting-out
16:30:40 <FliPPeh> Oh god, X.Org is doing it again
16:30:42 <chrisdone> FliPPeh: true, definitely need to show how a -> a can become concrete types
16:30:44 <FliPPeh> 84% RAM
16:30:51 <FliPPeh> Hold on a second
16:30:55 <FliPPeh> I'll restart my desktop
16:30:55 <fax> Is there a haskell lib that counts quadratic residue and nonresidue?
16:31:27 <tensorpudding> Have you looked at HaskellForMaths?
16:31:43 <FliPPeh> Back I am
16:31:51 <ksf> can the ghc optimizer see through existentials/gadts?
16:32:01 <tensorpudding> There is an off-chance that HFM has a library for quadratic residue
16:32:16 <ksf> that is, can it inline and fuse matches properly?
16:32:30 <FliPPeh> chrisdone: What do you think could I do to shrink step13 a bit?
16:32:39 <chrisdone> hmm
16:32:49 <ksf> (I think the answer is no, but I like good news)
16:34:20 <Saizan> define properly :)
16:35:17 <ksf> actually, it's about optimizing typeable/dynamic
16:35:17 <tensorpudding> define 'define properly' properly!
16:35:42 <ksf> and I don't think ghc even tries to figure stuff out, there.
16:36:04 <ydo> what is the most used package for working with real basic linear algebra, like dot and cross product?
16:36:31 <ydo> something that is probably installable as an ubuntu package :)
16:36:40 <EvanR> define define define define.... ....properly properly!
16:36:43 <tensorpudding> It's pretty trivial to define the dot and cross product for R^3 vectors.
16:36:58 <tensorpudding> There are a lot of vector packages for Haskell though, I hear.
16:37:12 <ksf> there's e.g. Data.Vec
16:37:21 <Saizan> hmatrix?
16:37:29 <chrisdone> FliPPeh: I'm wondering about ('H' :), that's a weird bit of syntax you should describe. up till then that syntax hasn't been explained
16:37:35 <ksf> and of course dph
16:37:46 <ksf> which is propably the best choice if you have ghc 6.12
16:37:49 <chrisdone> FliPPeh: I can't think of a two arg function that's simple and just a word
16:37:52 <FliPPeh> chrisdone: Yep, that's what bothered me so far
16:38:18 <FliPPeh> chrisdone: I had to find a way to lift the polymorphism off the function
16:38:33 <EvanR> div 6 3
16:38:35 <FliPPeh> This is a stupid way, but the best I could come up with :/
16:38:54 <chrisdone> preferably something without type-classes, evan
16:39:06 <EvanR> concrete only?
16:39:15 <EvanR> or forall a
16:39:21 <ydo> ok, well.. can't find any of those in my apt package manager, are they (or could get) compiled in statically?
16:39:23 <FliPPeh> concrete
16:39:30 <ksf> I don't think it's dicactically wise to dumb down stuff.
16:39:35 <chrisdone> FliPPeh: what about take? nah
16:39:49 <EvanR> the only concrete functions i know about are in Data.Char ;)
16:39:55 <EvanR> :t Char
16:39:56 <lambdabot> Not in scope: data constructor `Char'
16:39:58 <EvanR> :t 'a'
16:39:59 <lambdabot> Char
16:40:06 <ksf> say "actually, all these functions have a type that works on more than one type, but we're going to disregard that now and pretend they all work on Floats only"
16:40:19 <FliPPeh> chrisdone: zip ?
16:40:34 <tensorpudding> Concrete functions?
16:40:36 <FliPPeh> It takes two arguments
16:40:40 <FliPPeh> Is polymorphic
16:40:50 <FliPPeh> And uses tuples!
16:40:57 <EvanR> > toUpper 'a'
16:40:57 <FliPPeh> Which were introduced some steps before
16:40:58 <lambdabot>   'A'
16:41:03 <EvanR> :t toUpper
16:41:03 <lambdabot> Char -> Char
16:41:09 <ksf> FliPPeh, then introduce polymorphism earlier.
16:41:15 <ksf> the easiest function, after all, is id.
16:41:26 <tensorpudding> And yet it's very polymorphic, id is
16:41:28 <FliPPeh> ksf: But it has only one argument
16:41:40 <ksf> :t id :: a -> b -> (a -> b)
16:41:41 <lambdabot>     Occurs check: cannot construct the infinite type: a = b -> a -> b
16:41:42 <lambdabot>     In the expression: id :: a -> b -> (a -> b)
16:41:50 <ksf> er.
16:41:56 <tensorpudding> :t id :: (a -> b) -> a -> b
16:41:57 <lambdabot> forall a b. (a -> b) -> a -> b
16:41:58 <chrisdone> the problem is it's gone from: this is a function, to, this is a partially applied function whose polymorphic type variables have now been instantiated with this partially applied operator
16:42:00 <ksf> :t ($ id)
16:42:01 <lambdabot> forall b a. ((a -> a) -> b) -> b
16:42:07 <ksf> :t (id$)
16:42:08 <lambdabot> forall a. a -> a
16:42:15 <chrisdone> FliPPeh: I guess you could test it with some nonhaskeller friends to see if they freak out
16:42:36 <FliPPeh> The only non-haskeller I know who is a programmer, is a low-level freak
16:42:44 <dankna> hey, I've got a quickie this time
16:42:45 <dankna> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24614#a24614
16:42:49 <dankna> why can't I do this?
16:42:53 <chrisdone> FliPPeh: actually I know how we can do it!
16:42:55 <dankna> oh - let me annotate with the error message
16:43:01 <FliPPeh> chrisdone: Shoot!
16:43:13 <dankna> there, it's annotated
16:43:18 <FliPPeh> I'll just remove step13 from my current file for now
16:43:20 <chrisdone> FliPPeh: ask them questions -- say, give me a value of type X
16:43:34 <ksf> dankna, you need to specify a concrete type, somewhere.
16:43:39 <ksf> it's like show . read
16:43:54 <ksf> > show . read $ "foo"
16:43:55 <lambdabot>   "* Exception: Prelude.read: no parse
16:43:57 <dankna> ksf: hm...except not quite because fromEnum is Int -> ...
16:44:01 <Saizan> or maybe just use ScopedTypeVariables ?
16:44:07 <dankna> I mean, is ... -> Int
16:44:20 <dankna> how would ScopedTypeVariables help, exactly?
16:44:22 <chrisdone> FliPPeh: that way, they can only proceed if they're getting it, and so then that forces us to think of questions we think they can get, rather than assuming everything we're guiding them through makes sense
16:44:25 <EvanR> how useful is it to teach non generic functions
16:44:36 <fax> generic functions ?
16:44:36 <Saizan> dankna: the content you use inside the if and the content in your type signature aren't understood as the same thing.
16:44:37 <ksf> dankna, but that's _toEnum_
16:44:39 <ksf> :t toEnum
16:44:40 <lambdabot> forall a. (Enum a) => Int -> a
16:44:41 <tensorpudding> That type on fromEnum looks a bit too polymorphic maybe?
16:44:52 <ksf> you're returning content.
16:44:53 <chrisdone> EvanR: it's useful to teach what a function is before you introduce what a function of any type to any type is
16:44:57 <ksf> you're not passing it in.
16:44:58 <dankna> Saizan: I see that - it's a problem
16:45:05 <dankna> Saizan: hmm
16:45:13 <EvanR> chrisdone: seems not easy to do that in haskell
16:45:14 <Saizan> dankna: you can solve it with ScopedTypeVariables
16:45:27 <dankna> ksf: yeah, actually I should have mentioned that the part that doesn't work is the comparison to fromEnum maxBound
16:45:32 <FliPPeh> chrisdone: Where should I continue? Shall I leave the part ":t (:)" in?
16:45:32 <dankna> ksf: it works fine if I take that out
16:45:55 <dankna> Saizan: I shall try, thanks!
16:46:04 <chrisdone> FliPPeh: yeah, I guess we've already introduced (:) at this point, right?
16:46:09 <FliPPeh> Yep
16:46:13 <ksf> ...don't forget to get rid of the second Bounded context
16:46:37 <ksf> as that shadows the previous binding for content.
16:46:44 <FliPPeh> chrisdone: And because you ended with "Let's learn more about functions", I thought we could continue with looking at the function type of that function
16:46:47 <dankna> ksf: will do
16:46:53 <chrisdone> FliPPeh: aye
16:46:56 <Saizan> dankna: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24614#a24616
16:47:47 <FliPPeh> chrisdone: How should we continue in step12?
16:48:02 <dankna> Saizan: I know how to turn it on, but thank you :D  I just tried that and it worked great
16:49:34 <ski> Sgeo : it depends on what you think "unsafe" means, but imo `unsafeInterleaveIO' is not unsafe
16:51:02 <ski> @type words
16:51:03 <lambdabot> String -> [String]
16:51:07 <chrisdone> FliPPeh: hmm. I guess it doesn't matter too much. we can always put in whatever and then see how people react. Google Analytics tells me how long people are staying on the site. if that drops, we know it's hard. and reddit is full of nonhaskellers willing to give their opinion. go with what you were doing
16:51:23 <ski> (chrisdone : ^ another function with monomorphic type)
16:51:29 <chrisdone> ski: brilliant!
16:51:45 <ski> (but maybe you don't want to introduce parametric types like `[]', yet ?)
16:51:51 <chrisdone> ski: that's a great function for teaching too
16:51:53 <ksf> :t digitToInt
16:51:54 <lambdabot> Char -> Int
16:52:00 <chrisdone> ski: no I've already introduced lists and strings at this point
16:52:14 <ksf> then you can do [String] -> Int
16:52:34 <ski> (`not',`isUpper',`ord',`chr',&c. i assume you included in "ones in `Data.Char'")
16:53:05 <ski> (well, `not' is not in `Data.Char' ..)
16:53:19 <ksf> I think it's important to give a rundown of more or less everything in data.list
16:53:20 <chrisdone> I haven't demonstrated them yet, mostly because it's hard to think of a story to go with them
16:53:48 <HugoDaniel> :)
16:53:54 <HugoDaniel> hey chris
16:53:56 <chrisdone> hi hugo :)
16:54:03 * ski wonders what is the "official" URL of this thing chrisdone is writing
16:54:38 <chrisdone> ski: the official url is http://tryhaskell.org , but we're developing it here so that anyone can write a copypastable tutorial: http://82.33.137.16/tryhaskell/
16:55:29 <ski> .. and you try it by hitting "Eval" ?
16:55:44 <FliPPeh> Hitting eval and re-loading the step you want to see changed
16:55:52 <chrisdone> yes, that loads the tutorial code into it
16:56:04 <chrisdone> ski: type 'help' to begin the tutorial
16:57:00 <ski> nothing happens on this end
16:57:22 <ski> (i have no idea where to type "help" - is there supposed to be some text field ?)
16:57:27 <ksf> chrisdone, the first time typeclasses appear seems to be (Num t) => (t, String)
16:57:50 <chrisdone> ski: the bit that says "Type haskell expresions in here" click that, type help, hit enter
16:58:05 <ski> (this could possibly be my browser being old or something, i suppose)
16:58:26 <ksf> it might also be good to do a bit more checking than the type
16:58:29 <chrisdone> ksf: indeed and I don't address it
16:58:40 <chrisdone> ski: what browser?
16:58:41 <ski> chrisdone : sorry, i see no such bit
16:59:16 <chrisdone> ksf: well it's not a concern really is it?
17:00:03 <ski> chrisdone : Firefox 1.0.4 (i can try in w3m 0.5.1 too, if you like, but somehow i suspect that is not going to work, either)
17:00:11 <ksf> chrisdone, well, it's easy cheating.
17:00:21 <chrisdone> if they type something and the type matches what you wanted, they understand types and that's good enough
17:00:57 <chrisdone> ksf: feel free to add some checks and paste it
17:01:06 <chrisdone> ski: I don't think that will work, no.
17:01:19 <EvanR> chrisdone: this is pretty awesome, ive really been wanting something like this
17:01:39 <chrisdone> ski: tested on Internet Explorer 6;Opera 10.01;Chromium 4.0.237.0 (Ubuntu build 31094);Firefox 3.5.8
17:01:49 <FliPPeh> I liked the ruby one, some years ago
17:01:55 <chrisdone> me too
17:02:04 <chrisdone> EvanR: for learning or playing?
17:02:14 <ski> chrisdone : like i said, browser probably being too old :)
17:02:19 <chrisdone> I sometimes use it at work when I'm on my dinner and thinking about haskell
17:02:58 <fax> if I have x1*x2 = 2 and x1+x2=-1, then x1=1+sqrt(2) so that x2=-2-sqrt(2)?
17:03:05 <FliPPeh> It's fun
17:03:16 <fax> > let x1=1+sqrt(2) ; x2=-2-sqrt(2) in x1*x2
17:03:17 <lambdabot>   <no location info>: parse error on input `in'
17:03:20 <EvanR> chrisdone: a way to do haskell with others who dont necessarily  have ghci at hand ;)
17:03:21 <FliPPeh> chrisdone: What about IO? Couldn't you hook up an IO emulation like the ruby one?
17:03:26 <fax> > let x1 = 1+sqrt(2) ; x2 = (-2-sqrt(2)) in x1*x2
17:03:27 <lambdabot>   -8.242640687119284
17:03:27 <EvanR> and dont know haskell
17:03:31 <siracusa> When clicking Reset the error console shows up -- is that intended?
17:03:31 <fax> ^ this is what I don't get
17:03:37 <fax> why is not 2...
17:03:57 <twink> x2 = 2/x1 so x1 + 2/x1 = -1, then x1^2 + 2 = -x1 and then x1^2 + x1 + 2 = 0, no?
17:04:13 <chrisdone> siracusa: what error console?
17:04:30 <fax> twink yes
17:04:33 <siracusa> chrisdone: Firefox's one
17:04:36 <chrisdone> FliPPeh: yeah you could emulate reading and writing  a file
17:04:37 <ski>   (x - x1) * (x - x2)  =  x^2 - (x1 + x2) * x + (x1 * x2)
17:04:57 <Makoryu> > let x1 :: Rational; x1 = 1 + sqrt 2; x2 = (-2) - sqrt 2 in x1 * x2
17:04:58 <chrisdone> siracusa: that's not intentional. do errors occur?
17:04:58 <lambdabot>   No instance for (GHC.Float.Floating
17:04:59 <lambdabot>                     (GHC.Real.Ratio GHC...
17:05:01 <fax> > 1 - 8
17:05:02 <ski> so you need to solve `x^2 + 1 * x + 2 = 0' for `x'
17:05:02 <Makoryu> Whoops
17:05:02 <lambdabot>   -7
17:05:32 <fax> > let x1 = -(1/2)+sqrt(-7/4) ; x2 = (-1-x1) in x1*x2 :: Complex Double
17:05:33 <lambdabot>   2.0 :+ 0.0
17:05:36 <fax> aha
17:05:49 <fax> thanks all
17:05:50 <fax> :D
17:06:11 * hackagebot type-functions 0.0.0.0 - Emulation of type-level functions  http://hackage.haskell.org/package/type-functions-0.0.0.0 (WolfgangJeltsch)
17:06:23 <siracusa> chrisdone: There was an error, but I'm not sure where it came from
17:07:27 <dankna> it's rather a shame that Enum uses Int and not Integral :(
17:07:42 <chrisdone> I love BONUS's little pictures http://learnyouahaskell.com/startingout.png
17:08:11 <siracusa> chrisdone: the page produced at least a warning about an unknown 'no-repeat' value
17:08:26 <dark> chrisdone, yeah =~
17:08:40 <dark> when i was a child, i painted things like that
17:08:42 <dark> :~.
17:08:52 <chrisdone> dark: vector art?
17:08:57 <dark> no lol
17:09:01 <dark> missing the borders
17:09:05 <ksf>     No context is allowed on a GADT-style data declaration
17:09:13 <ksf> they changed the implementation of emptydatadecls
17:09:16 <dark> painting something outside the border, etc
17:09:42 <EvanR> chrisdone: is there a way to define stuff at the top level
17:09:50 <ski> > let (a,b,c) = (1,1,2); det = b^2 - 4*a*c; xs = [(- b + s_det) / (2 * a) :: Complex Double | s_det <- [sqrt det,- sqrt det]] in (id &&& product &&& sum) xs
17:09:51 <lambdabot>   ([(-0.5) :+ 1.3228756555322954,(-0.5) :+ (-1.3228756555322954)],(2.0 :+ 0.0...
17:10:03 <chrisdone> EvanR: the json service supports it but tryhaskell doesn't yet
17:10:37 <dark> maybe because it uses hugs?
17:10:42 <ski> ksf : when do you get that error ?
17:10:55 <ksf> compiling HList with 6.12
17:10:56 <fax> that is nice ski
17:11:04 <ksf> data HNat x => Label x ns desc
17:11:33 <ksf> ...the thing is that I _can't_ put the constraint on the members because it's empty...
17:11:50 <chrisdone> EvanR: if you want to include it in your blog or something you could do that
17:11:53 <ski> why does it think it is GADT-style ?
17:12:08 <ksf> I think because of emptydatadecls.
17:12:12 * hackagebot records 0.0.0.0 - A flexible record system  http://hackage.haskell.org/package/records-0.0.0.0 (WolfgangJeltsch)
17:12:26 <ksf> It'd be quite straight forward to just treat them as gadts without where.
17:12:37 <ski> hm .. could be
17:13:29 <ski> ksf : you should probably mention this on some mailing-list
17:14:00 <ksf> and I should tell gwern to fix hlist, he's listed as maintainer
17:14:03 <ksf> er no.
17:14:17 <ksf> oleg is the maintainer, gwern uploader. but afaik oleg doesn't do hackage.
17:14:21 <chrisdone> EvanR: http://tryhaskell.org/haskell-eval.json?jsonrpc=2.0&method=load&id=1&params={%22contents%22:%22x=1%22}
17:14:21 <chrisdone> EvanR http://tryhaskell.org/haskell-eval.json?jsonrpc=2.0&method=eval&id=1&params={%22expr%22:%22x%22}
17:15:17 * ski would have no problem with empty data types being declared as `data Foo where {}' (or `data Foo where' with implicit `{}')
17:15:20 <chrisdone> EvanR: stick your top-level definitions/types/classes in the load
17:15:43 <EvanR> i mean, letting the user define stuff
17:15:46 <ski> (reserving `data Foo' for abstract specifications of types)
17:16:31 <ksf> it's also class Foo and instance Foo Bar
17:16:35 <ksf> ...without where
17:16:57 <chrisdone> EvanR: tryhaskell doesn't yet. I need to add a textarea somewhere in the layout to do it. I'll try it now
17:17:06 <ski> ksf : .. point
17:17:29 <EvanR> that would be tight
17:18:24 * ski tries to recall what constraints on data types exactly do again .. apart from being added to the constructors, i.e.
17:18:48 <ski> @src Complex
17:18:48 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
17:19:27 <ski> @type let f :: Complex a -> (a,a); f (a0 :+ a1) = (a0,a1) in f
17:19:28 <lambdabot>     Could not deduce (RealFloat a) from the context ()
17:19:28 <lambdabot>       arising from a use of `:+' at <interactive>:1:35-36
17:19:28 <lambdabot>     Possible fix:
17:19:42 * ski nods slowly
17:20:08 <ski> so `Complex a' isn't wellformed, unless `RealFloat a' is known
17:20:30 <jeffwheeler> Being used to Haskell, I have a tendency to emulate it in other languages. How bad is it to use function ptrs in C?
17:20:46 <HugoDaniel> that post about the google summer of code got me thinking....
17:20:50 <jeffwheeler> Most people don't use them, but is there anything inherently bad about them?
17:20:55 <ski> jeffwheeler : .. why would it be bad ?
17:20:57 <chrisdone> jeffwheeler: that's normal..
17:20:57 <FliPPeh> jeffwheeler: Nothing
17:21:04 <EvanR> function pointers are good
17:21:06 <jeffwheeler> Fair enough; I don't see it often
17:21:08 <FliPPeh> They're actually pretty nice
17:21:12 <FliPPeh> Callbacks and stuff
17:21:13 <Adamant> jeffwheeler: overuse is bad, according to more conventional C programmers
17:21:17 <EvanR> but you cant define local functions in c :(
17:21:43 <Adamant> I don't think too many people in here mind them, me included
17:21:54 <mibygl> Can you return a struct in C?
17:21:59 <jeffwheeler> Heh, good. I figured there was something about how they worked that made them gross.
17:22:03 <EvanR> mibygl: yes
17:22:18 <Saizan> you even have lambdas in some c compilers now, no?
17:22:21 <ski> jeffwheeler : it's clunky to have to pass `void *data' around to represent the existential environment that is implicit in first-classy closures .. and keeping track of when to free that data can be clunky, too
17:22:52 <chrisdone> jeffwheeler: something about the way they are notated makes them gross
17:22:54 <jeffwheeler> ski: my case is a lot simpler than that; I have a list of functions that all have an identical type, but I want to wrap them
17:23:03 <ski> EvanR : you can define local functions in GCC (but they are "downward FUNARGs", only)
17:23:10 <EvanR> i heard of that
17:23:38 <ski> (also, GCC supports (mutual) tail-recursion, to some degree)
17:23:39 <EvanR> such a thing would be just find
17:23:51 <Adamant> Saizan: yes, if by some you just mean LLVM :P
17:23:54 <jeffwheeler> ski: I was wondering about GCC's optimizer and tail recursion. How smart is it?
17:24:12 <jeffwheeler> ski: will -O2 do simple cases without any problems?
17:24:13 <Adamant> GCC's tail recursion for C is not so awesome.
17:24:16 <mibygl> Ooh, mutual tail recursion.
17:24:19 <EvanR> it optimizes tail calls
17:24:28 <jeffwheeler> What's mutual tail recursion?
17:25:00 <mibygl> When foo x = bar (blah x) and bar x = foo (beep x).
17:25:09 <mibygl> Or something like that, anyway.
17:25:37 <jeffwheeler> Oh, hmm. That's definitely a trickier case.
17:25:52 <Mathnerd314> EvanR: who needs tryhaskell.org for doing haskell, when you have lambdabot?
17:25:59 <jeffwheeler> Just handling simple tail calls would make a big difference in a lot of cases.
17:26:15 <jeffwheeler> Mathnerd314: imagine it on haskell.org's homepage!
17:26:16 <EvanR> tail recursion is for schemers ;)
17:26:28 * mibygl goes to tryjavascript.org and is disappointed.
17:26:29 <Adamant> EvanR: Haskell does it too
17:26:48 <EvanR> according to this book, lazy evaluation is automatically tail recursive in that way
17:26:50 <mibygl> tryjavascript.org would be kind of a stupid web site.
17:27:02 <ski> jeffwheeler : i don't know very much about. my dim memory says something about "sibling calls"
17:27:06 <mibygl> Which means that it must be created.
17:27:42 <chrisdone> mibygl: why would it be stupid?
17:28:01 <EvanR> because every site is try javascript
17:28:06 <EvanR> control shift j
17:28:06 <Mathnerd314> chrisdone: could you put some lambdabot functionality into tryhaskell?
17:28:15 <Adamant> EvanR: I would get an opinion from someone more familiar with ghc, but my understanding is that ghc needs to use TCO in a fair amount of cases or stuff falls down and has the same problems Scheme would have without TCO
17:28:16 <chrisdone> Mathnerd314: like what?
17:28:45 <FliPPeh> http://g.imagehost.org/0632/snake.jpg <- Tail recursion?
17:28:45 <Mathnerd314> > listToMaybe
17:28:46 <lambdabot>   {[]->Nothing;[()]->Just ();[(),()]->Just ();[(),(),()]->Just ()}
17:28:51 <Mathnerd314> stuff like that
17:29:02 <EvanR> Adamant: i dont know about that. ghc doesnt use the classic stack based model
17:29:30 <Adamant> EvanR: yes, but it still gets massive expansion in some cases without optimization.
17:29:31 <EvanR> evaluation proceeds by allocating thunks and collecting them
17:29:37 <EvanR> yeah
17:29:52 <jeffwheeler> EvanR: Wait; GHC doesn't use a stack-based model? How broadly do you mean that?
17:30:02 <EvanR> but i dont know if *tail* recursion is the solution to that
17:30:05 <EvanR> TCO
17:30:16 <Mathnerd314> chrisdone: also, lambdabot manages to give much more readable error messages
17:30:38 <Mathnerd314> (most of the time)
17:30:44 <EvanR> jeffwheeler: ghc program executes code allocated on the heap
17:30:54 <chrisdone> huhuh
17:31:01 <Saizan> you still have a fairly conventional stack involved when you start evaluating a bunch of nested strict functions
17:31:04 <jeffwheeler> EvanR: Hmm, this is new to me
17:31:25 <Adamant> yeah, I thought stuff with strictness on was a problem
17:31:29 <EvanR> everything is not strict by default, except IO
17:31:44 <Saizan> but it's true that TCO happens automatically for somthing like the recursion foldl does over the list
17:32:04 <EvanR> i think the concept of a tail call is just very different in lazy environment
17:32:06 <Saizan> the problem is when you go and evaluate the thunk foldl has accumulated :)
17:32:10 <EvanR> let me turn to that page ;)
17:32:43 <Saizan> yeah, what syntactically looks like a tail call doesn't match the situation you'd have in a strict language
17:32:51 <Saizan> s/match/necessarily/
17:32:56 <Saizan> +match
17:33:16 <ski> @src Cont (>>=)
17:33:16 <lambdabot> m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
17:33:27 <ski> ^ `k' is "tail-called"
17:33:42 <ski> (because `c' is passed, instead of `\b -> c b')
17:34:01 <EvanR> chapter 21, "optimizing generalized tail calls", implementation of functional programming languages
17:34:45 <EvanR> he talks about it in the context of supercombinators
17:34:55 <EvanR> which effectively puts your code on a stack
17:35:03 <EvanR> i dont know how applicable it is to ghc
17:35:39 <EvanR> the book is like 20 years old ;)
17:36:01 <Adamant> I think it's kind of like reading the old Dragon book in the late 90's
17:36:14 * ski wonders when GHC updates the thunks to the computed values .. once after computation, or during computation, each time a thunk yields a new thunk ? - or nothing like that ?
17:36:14 <EvanR> probably
17:38:19 <EvanR> 'a tail call is the case when the result of one function is given by a call to another function with exactly the right number of arguments supplied'
17:38:30 <Saizan> i wonder if it's smart enough to avoid updating the thunk when it's not going to be reused elsewhere, but that would mean it's almost doing GC while computing
17:40:14 <ski> (at least this is a potential issue with writing lazy code in strict languages; e.g. in scheme calling `(force (loop))' where `(define (loop) (delay (force (loop))))' will not run in constant stack space, as would be expected)
17:40:15 <fax> > 1/2+(-27/2+3/2*sqrt(93))^(-1)-1/18*sqrt(93)
17:40:16 <lambdabot>   * Exception: Negative exponent
17:40:22 <fax> > 1/2+(-27/2+3/2*sqrt(93))^(-1)-1/18*sqrt(93) :: Complex Double
17:40:23 <lambdabot>   * Exception: Negative exponent
17:40:33 <fax> > 1/2+1/(-27/2+3/2*sqrt(93))-1/18*sqrt(93) :: Complex Double
17:40:34 <lambdabot>   1.0 :+ 0.0
17:40:46 <SamB_XP> Saizan: if it could do that, why would there be a thunk ?
17:41:34 <SamB_XP> on the other hand, there's no point in updating the thunk until the value is in WHNF is there ?
17:41:46 <ski> SamB_XP : maybe the compiler isn't sure whether it will need to be used at all, but somehow still knows it will be used at most once ?
17:41:52 <SamB_XP> besides blackholing it
17:54:36 <ski> (.. hm, i just wrote `Exists' with a reversed `E' on paper)
17:54:47 <FliPPeh> ski: Cover it as a 3
17:54:48 <fax> lol
17:55:44 <ski> (apparently my hand *wants* to write it reversed. it was significatnly harder to write it in the correct fashion, upon retries)
17:58:07 <Philonous> Just leave out the superfluous letters and it's fine again.
17:58:39 <ski> well, this was supposed to be real haskell code, so that doesn't work
17:58:57 <ski> (it's a data constructor name)
17:59:09 <Philonous> ghc can handle unicode. Just rename the constructor.
17:59:29 <Saizan> assumuing it counts as uppercase
18:00:00 <Saizan> > isUpper 'âˆƒ'
18:00:01 <lambdabot>   False
18:00:16 <ski> Philonous : hm, point. .. but i'm not sure if my in-head implementation of haskell code on paper supports unicode
18:00:23 <FliPPeh> Can you name your functions a unicode snowman?
18:00:27 <EvanR> haha
18:00:51 <FliPPeh> > let â˜ƒ = "OMGSNOWMAN" in â˜ƒ
18:00:52 <lambdabot>   <no location info>: parse error on input `â˜ƒ'
18:01:02 <Saizan> moar parentheses
18:01:03 <Philonous> > toUpper 'âˆƒ'
18:01:04 <lambdabot>   '\8707'
18:01:16 <EvanR> > isUpper 'â˜­'
18:01:17 <Saizan> > let (â˜ƒ) = "OMGSNOWMAN" in (â˜ƒ)
18:01:17 <lambdabot>   False
18:01:18 <lambdabot>   "OMGSNOWMAN"
18:01:25 <EvanR> > isLower 'â˜­'
18:01:26 <pokoko222> some of you ninjas has used a modeling language? i am reading this book by MIT press "Software abstractions, logic, language and analysis" and so far reading this i am like "ah, whaaat?"
18:01:26 <lambdabot>   False
18:01:29 <FliPPeh> Oh yeah
18:01:38 <FliPPeh> It counts as an operator :D
18:01:49 <ski> @. read run "\8707"
18:01:50 <lambdabot>  
18:02:15 <benmachine> is it easy to cross-compile haskell windows binaries on linux?
18:02:29 <benmachine> or, to install GHC in wine
18:02:40 <cads> Saizan, Evan, and Flip, 2010, "Programming with Existentials, Sickles, and Snowmen"
18:03:05 <Saizan> that's a great title
18:03:07 <EvanR> let (â˜­) x y = (reverse x) ++ (reverse y) in "soviet" â˜­ "russia"
18:03:08 <FliPPeh> > let x â˜ƒ y = x ++ "OMGSNOWMAN" ++ y in "Hello" â˜ƒ "World"
18:03:09 <lambdabot>   "HelloOMGSNOWMANWorld"
18:03:14 <cads> oh, Philonous too
18:03:16 <fax> cads hahah
18:03:36 <pikhq> Hey, the snowman operator!
18:03:45 <SamB_XP> benmachine: I can't see why it would be hard to install GHC in WINE, unless maybe it's an MSI and WINE lacks the installer for those ...
18:03:58 <ski> `a \sickle b' could be a symbol for a lens / functional reference from `a' to `b' !
18:04:03 <FliPPeh> pikhq: Hell yeah!
18:04:29 <EvanR> in soviet russia, haskell codes you
18:04:45 <FliPPeh> in soviet russia, code compiles you
18:05:04 <SamB_XP> what is this supposed to be: â˜­
18:05:13 <EvanR> sickle and hammer
18:05:14 <SamB_XP> It doesn't come through very well in "unifont"
18:05:16 <pikhq> SamB_XP: Hammer and sickle.
18:05:18 <cads> > (â˜ƒ) = "snow pimp" in (â˜ƒ)
18:05:19 <lambdabot>   <no location info>: parse error on input `='
18:05:25 <cads> oh, duh
18:05:36 <cads> I'm surprised that came though
18:05:39 * FliPPeh mails a "let" to cads
18:05:49 <SamB_XP> > "let" (â˜ƒ) = "snow pimp" in (â˜ƒ)
18:05:50 <lambdabot>   <no location info>: parse error on input `='
18:05:55 <SamB_XP> > let (â˜ƒ) = "snow pimp" in (â˜ƒ)
18:05:56 <lambdabot>   "snow pimp"
18:06:17 <EvanR> this is so cool, im seriously defining these operators from now on ;)
18:06:40 <FliPPeh> :)
18:06:43 <cads> I was checking if the utf-8 symbol was going to to come through correctly with my client
18:06:48 <SamB_XP> warning: it's very hard to make these glyphs out in unifont!
18:06:53 <EvanR> hehe
18:07:06 <EvanR> unifont? im on xterm and i can see them, sort of
18:07:11 <EvanR> â™ž
18:07:13 <FliPPeh> Whoever invented the Unicode snowman, he's truly a winnar
18:07:25 <FliPPeh> Yep, my termial can display those, too
18:07:32 <FliPPeh> It must, this is irssi
18:07:46 <FliPPeh> They are very small, but you can see them :D
18:07:52 <SamB_XP> is your "fixed" bigger than unifont?
18:07:57 <FliPPeh> http://unicodesnowmanforyou.com/ <- Full glory
18:07:58 <SamB_XP> or is it using a TTF?
18:08:02 <ski> are there unicode glyphs for bananas, lenses and barbed wire ?
18:08:04 <cads> Testing, should be a not operator, congruence symbol, intersection symbol, del, a right arrow, a capital sigma, and a capital pi: Â¬	â‰¡	âˆ©	âˆ†	â†’	âˆ‘	âˆ
18:08:08 <cads> huh..
18:08:14 <EvanR> SamB_XP: its a small bitmap font
18:08:15 <SamB_XP> ski: of course!
18:08:15 <FliPPeh> That looks funny here, cads
18:08:23 <FliPPeh> I'm using an X-Font
18:08:32 <FliPPeh> Let's see what happens on TTY
18:08:32 <SamB_XP> cads: it's all good
18:08:33 <EvanR> cads encoding was weird
18:08:39 <EvanR> i got control chars
18:08:51 <FliPPeh> Squares ^____^
18:09:07 <SamB_XP> cads: well, maybe you're using s-jis or something ;-P
18:09:14 <cads> when I save those symbols in a text file and cat the file from cygwin I get a bunch of gibberish
18:09:22 <cads> SamB_XP, it's just windows, I think..
18:09:48 <FliPPeh> uÊop-ÇpÄ±sdn
18:09:49 <SamB_XP> cads: what language, and did you set it to a non-usual encoding for your language ?
18:10:31 <SamB_XP> the only reason I mentioned shift JIS is that that's what I set my Windows to use
18:10:33 <cads> It's english, no wierd encoding - the file is set in mode utf-8 and looks fine in the text editor. However the haskell compiler see wierd symbols as well.
18:10:35 <FliPPeh> > "\2620"
18:10:36 <lambdabot>   "\2620"
18:10:57 <ski> @. read run "\2620"
18:10:58 <lambdabot>  <
18:11:10 <SamB_XP> cads: which GHC ?
18:11:22 <cads> It's funny, it'll compile unless I'm trying to use arrows in the type declarations.
18:11:52 <cads> SamB_XP, 6.10.4, standard haskell platform
18:12:15 <cads> though now you mention it I should try it with 6.12 and 6.10.3
18:12:17 <SamB_XP> hmm, that was before the big file encoding change, right?
18:13:13 <cads> Hmm.. I wonder if it will be any different if I compile from the windows command line instead of cygwin or msys bash
18:13:43 <FliPPeh> > "\x2368"
18:13:44 <lambdabot>   "\9064"
18:13:54 <FliPPeh> > chr 2368
18:13:55 <lambdabot>   '\2368'
18:13:58 <FliPPeh> Lame.
18:14:07 <FliPPeh> â¨
18:15:18 <cads> SamB_XP, what editor do you use in windows?
18:15:31 <Cale> > text "\2368"
18:15:32 <lambdabot>   à¥€
18:15:32 <FliPPeh> > let (â˜ ) = error in [1,2,3,4,â˜ ,6,7]
18:15:33 <lambdabot>   <no location info>: parse error on input `,'
18:15:39 <FliPPeh> > let (â˜ ) = error in [1,2,3,4,(â˜ ),6,7]
18:15:40 <lambdabot>   No instance for (GHC.Num.Num ([GHC.Types.Char] -> a))
18:15:40 <lambdabot>    arising from the l...
18:15:53 <FliPPeh> > let (â˜ ) = error "AHHHHH" in [1,2,3,4,(â˜ ),6,7]
18:15:54 <lambdabot>   [1,2,3,4,* Exception: AHHHHH
18:16:18 <FliPPeh> A skull. Best error raise ever
18:16:21 <SamB_XP> cads: well, lately I've been using VS, notepad++, and whatever that other one is that they have installed at school...
18:16:28 <SamB_XP> textpad, it might be?
18:16:44 <FliPPeh> > text "\x2620"
18:16:45 <lambdabot>   â˜
18:19:21 <rtaycher> is their any way of doing conditional imports in haskell, Im having a problem with circular dependencies
18:19:46 <SamB_XP> rtaycher: that's not the problem you're having
18:19:57 <SamB_XP> you may wish to look into hs-boot files
18:20:08 <SamB_XP> @google ghc "hs-boot"
18:20:10 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html
18:20:10 <lambdabot> Title: 4.6.ï¿½Filenames and separate compilation
18:20:29 * hackagebot xhaskell-library 0.0.2 - Replaces/Enhances Text.Regex  http://hackage.haskell.org/package/xhaskell-library-0.0.2 (KennyLu)
18:21:00 <FliPPeh> â˜› â˜š <- We should replace arrows with those :)
18:21:22 <SamB_XP> http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
18:21:28 * Mathnerd314 plays with fonts
18:21:30 <SamB_XP> FliPPeh: what's the LaTeX for those ?
18:21:38 <FliPPeh> SamB_XP: Don't know :(
18:22:06 <FliPPeh> SamB_XP: Can't you escape the decimal value?
18:22:15 <SamB_XP> the WHAT now ?
18:22:31 <SamB_XP> I guess what I meant was "I don't think those are in the TeX fonts"
18:23:00 <chrisdone> http://82.33.137.16/tryhaskelldev.png
18:23:08 <chrisdone> woot, file loading
18:23:11 <SamB_XP> i.e. they won't work too well in papers for publications that use the bundled TeX fonts...
18:23:16 <Mathnerd314> chrisdone: nice!
18:23:27 <FliPPeh> Sweet
18:23:31 <SamB_XP> or other fonts with ~ the same repoirtoire
18:24:11 <chrisdone> http://82.33.137.16/tryhaskell-dev/
18:25:09 <chrisdone> still need to handle compile errors, but yeah, something like that. btw it will only look right on ie8/firefox/chrome/safari/opera
18:25:12 <mibygl> > let x â˜  y = if x > 3 then x + y else x * y in (1 â˜  1, 2 â˜  2, 3 â˜  3, 5 â˜  5, 8 â˜  8)
18:25:13 <lambdabot>   (1,4,9,10,16)
18:26:06 <chrisdone> EvanR: happy now? :p
18:26:29 <FliPPeh> chrisdone: It does not accept unicode.
18:26:32 <FliPPeh> I'm unhappy
18:26:38 <mibygl> I wish I could let (â˜›) = (->) in \x â˜› foo.
18:27:09 <Mathnerd314> > let (â˜›) = (->) in \x â˜› foo
18:27:10 <lambdabot>   <no location info>: parse error on input `->'
18:27:38 <pikhq> Mathnerd314: Sorry, but -> is syntax, not an operator.
18:27:55 <Mathnerd314> what!?
18:27:56 <chrisdone> FliPPeh: take that back
18:28:09 <SamB_XP> pikhq: only at the value level ;-)
18:28:21 <SamB_XP> but, let only works at the value level too
18:28:42 <FliPPeh> Response received: {"jsonrpc":"2.0","id":"1","error":{"code":"RPCEError_InvalidParams","message":"Invalid params."}}
18:28:46 <pikhq> SamB_XP: Yes, it's an operator at type-level. :)
18:29:05 <SamB_XP> :k (->)
18:29:06 <lambdabot> ?? -> ? -> *
18:29:17 <SamB_XP> :k []
18:29:18 <lambdabot> * -> *
18:29:27 <SamB_XP> :k (,)
18:29:28 <lambdabot> * -> * -> *
18:29:34 <SamB_XP> :k (#,#)
18:29:35 <lambdabot> ? -> ? -> (#)
18:29:39 <SamB_XP> whoot
18:29:47 <srush> is there a haskell data structure for "multi-index maps"
18:30:03 <SamB_XP> srush: what do they do ?
18:30:22 <SamB_XP> or rather, what do you do with them?
18:30:24 <Mathnerd314> chrisdone: I'm failing to replicate your screenshot. I type it in, I click "load", it says "definitions loaded", and... Test is undefined
18:30:39 <srush> I'm thinking something like http://www.boost.org/doc/libs/1_42_0/libs/multi_index/doc/index.html
18:31:00 <srush> each element has a couple indexes associated with it
18:31:24 <srush> and maybe an index query gives back a list
18:31:33 <SamB_XP> what identities does one satisfy?
18:31:51 <SamB_XP> or, uh, do the operations satisfy?
18:32:02 <srush> well insert changes all
18:33:35 <srush> lookup key1 $ insert [key1, key2] val2 $ insert [key1, key2] val1 m = [val1, val2]
18:33:58 <SamB_XP> srush: um, ask oleg to make you one or something ;-)
18:33:58 <fax> @oies 3, 4, 5, 6, 8, 10, 12, 15, 16, 17, 20, 24
18:33:59 <lambdabot>  Numbers of edges of polygons constructible with ruler and compass.
18:33:59 <lambdabot>  [1,2,3,4,5,6,8,10,12,15,16,17,20,24,30,32,34,40,48,51,60,64,68,80,85,96,102,...
18:34:24 <srush> thanks
18:34:30 <srush> maybe it's just a couple lists
18:34:50 <srush> and I punt on any kind of modify operation
18:34:53 <cads> SamB_XP, is this code correct? can you get it to run in windows? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24617#a24617
18:35:38 <cads> hmm, let me see if I can get it to run in my debian vm
18:36:19 <cads> I'm not sure if that language pragma is correct
18:36:42 <chrisdone> Mathnerd314: try it now? http://82.33.137.16/tryhaskell-dev/ works fine here
18:37:23 <Mathnerd314> yeah, now it works...
18:37:50 <SamB_XP> cads: I don't actually have a compiler installed here
18:37:54 <SamB_XP> sorry!
18:38:05 <cads> hehe, it's okay :)
18:38:09 <Mathnerd314> chrisdone: ah, I need cookies enabled for it to work
18:38:16 <chrisdone> yah
18:38:31 <chrisdone> it's per user
18:38:52 <cads> SamB_XP,  if you want to help me get to the bottom of the great windows haskell unicode mystery, let me know :)
18:39:07 <cads> (I don't know if there's anyone else here that uses windows, heh)
18:39:53 <chrisdone> Mathnerd314: can't do that in lambdabot can you? :p
18:41:27 <FliPPeh> It still won't let me define unicode operators :(
18:42:09 <cads> FliPPeh, there's the -XUnicodeSyntax compiler option, I believe
18:42:18 <chrisdone> I'd say that's probably because I don't read the strings in as utf8, off the top of my head. I'm aware that unicode doesn't work ~
18:42:35 <FliPPeh> :)
18:42:52 <cads> oh, you were talking about in tryhaskell
18:42:59 <FliPPeh> yep
18:43:03 <FliPPeh> GHCi does this by default
18:43:07 <chrisdone> FliPPeh: if you get a tryhaskell lesson that you're happy with send me a link to a paste and I'll upload it
18:43:19 <chrisdone> going bed nao
18:43:36 <FliPPeh> chrisdone: Once I figure out how to continue, I'll do it :)
18:43:42 <FliPPeh> Just have a busy weekend coming up
18:44:06 <chrisdone> sounds good
18:44:43 <chrisdone> have a good one. see thee later
18:44:52 <FliPPeh> Good night :)
18:46:55 <byorgey> fax: to get all subsets, just use 'splits' and throw away the second element of each pair
18:47:50 <Veinor> how do I connect to, say, google.com on port 80 via the Network library?
18:48:02 <fax> > let cbrt x = x**(1/3::Complex Double) ; p = -7/3 ; q = 7/27 ; r = 1/3 ; y = cbrt(q/2+sqrt(q^2/4+p^3/27))+cbrt(q/2-sqrt(q^2/4+p^3/27))-r ; x = sqrt(y*(-1+sqrt(5))/2-1) in x^5
18:48:03 <lambdabot>   0.0 :+ 2.5184006352988e-2
18:48:12 <fax> that's not what I wanted
18:50:20 <fax> > let cbrt x = x**(1/3::Complex Double) ; p = -7/3 ; q = 7/27 ; r = 1/3 ; y = cbrt(q/2+sqrt(q^2/4+p^3/27))+cbrt(q/2-sqrt(q^2/4+p^3/27))-r ; x = sqrt(y*(-1+sqrt(5))/2-1) in x^7
18:50:21 <lambdabot>   (-0.0) :+ (-5.775302654291238e-3)
18:50:54 <fax> I am not having any luck with this
18:51:33 <fax> byorgey I have to learn quite a bit more theory before I can continue my program :(
18:54:38 <fax> > let cbrt x = x**(1/3::Complex Double) ; p = 7 ; q = 6 ; y = cbrt(q/2+sqrt(q^2/4+p^3/27))+cbrt(q/2-sqrt(q^2/4+p^3/27))-r in y^3+p*y-q
18:54:39 <lambdabot>   Couldn't match expected type `Data.Complex.Complex
18:54:39 <lambdabot>                         ...
18:56:27 <fax> how do you solve a cubic in lambdabot
18:56:48 <FliPPeh> Youtube want's to fool me I suppose
18:57:00 <FliPPeh> This is what it's telling me when I want to view a video: while(1);{"errors": "I call shenanigans", "success": false}
18:57:03 <FliPPeh> SHENANIGANS!
18:58:04 <fax> > (7*7*7)**(1/3)
18:58:05 <lambdabot>   6.999999999999999
18:58:26 <fax> > let cbrt x = x**(1/3::Complex Double) ; p = 7 ; q = 6 ; y = cbrt(q/2+sqrt(q^2/4+p^3/27))+cbrt(q/2-sqrt(q^2/4+p^3/27))-r in y^3+q*y-p
18:58:27 <lambdabot>   Couldn't match expected type `Data.Complex.Complex
18:58:27 <lambdabot>                         ...
18:58:30 <fax> > let cbrt x = x**(1/3::Complex Double) ; p = 7 ; q = 6 ; y = cbrt(q/2+sqrt(q^2/4+p^3/27))+cbrt(q/2-sqrt(q^2/4+p^3/27)) in y^3+q*y-p
18:58:31 <lambdabot>   17.13401481035796 :+ 25.276424634387375
18:58:57 <fax> pretty weird, I copied this directly and double checked it twice
19:01:01 <temoto> Regarding Data.Map, which function to use to insert-or-overwrite key regardless whether it was ever set?
19:05:14 <stulli> temoto: Should be insert: http://www.haskell.org/ghc/docs/6.10.4/html/libraries/containers/Data-Map.html#5
19:06:04 <temoto> stulli, oh thank you, i was looking at Delete/Update section.
19:07:50 <siracusa> Is there a shorter way to write `modify $ \st -> st { names = name : names st}' ?
19:07:55 <Veinor> so how can I connect to foo on port 4000, then send the string "bar" and read until I get an EOF?
19:10:00 <mibygl> > text "\/*\\*\/+\\+\/\/+\\+\/*\\*\\*\\*\/"
19:10:01 <lambdabot>   <no location info>:
19:10:01 <lambdabot>      lexical error in string/character literal at chara...
19:10:14 <mibygl> Darn.
19:11:05 <aavogt> siracusa: there are some libraries that use TH to define better records
19:11:24 <siracusa> mibygl: Do not escape '/'
19:11:43 <mibygl> I have that string; I'm trying to remove the escapes from it.
19:11:44 <aavogt> such that you can have a function   modify names (name : ) or something
19:11:53 <mibygl> Unfortunately, it uses \/ as an escape sequence for /.
19:12:10 <aavogt> fclabels and data-accessor are sensible options
19:12:27 <aavogt> currently data-accessor-template is kind of awkward to build for ghc-6.12
19:12:43 <siracusa> aavogt: Hhm, TH seems a little too much overhead for this :-)
19:13:48 <siracusa> mibygl: Why not remove the escape for / ?
19:16:57 <mibygl> siracusa: well, I'd like to remove the escapes automatically.
19:17:33 <aavogt> siracusa: well records were not a focus in the design of haskell
19:18:54 <aavogt> if you want a more sensible system without writing those setters and getters yourself, that's more or less your option
19:20:13 <siracusa> fclabels indeed looks a bit cryptic, but I think I'll give it a try
19:20:38 <siracusa> Are there plans to improve the record system in Haskell' ?
19:21:53 <aavogt> there is some extensible record stuff in hugs
19:21:54 <Philonous> *cough* http://hackage.haskell.org/package/HList *cough*
19:23:15 <benmachine> siracusa: it's generally accepted that it needs improving, but no-one's come up with a conclusive answer as to how
19:28:13 <tomoj> for fun I've been wondering what something like opscode's chef might look like in haskell. the problem would be to give a language for building up and 'composing' pure values which describe provisioning operations
19:28:41 <tomoj> I am still so new to haskell that I can't really think of how you might do this, any basic hints on what to study?
19:29:39 <cads> woah, chef looks cool
19:30:32 <cads> groovy - it's written in ruby
19:32:28 * cads is working on extending rubyinline to let you sprinkle haskell code in
19:37:32 <Veinor> hm
19:37:45 <Veinor> in the IO monad, how can I say 'if there are not exactly 3 arguments, fail, else keep going?'
19:38:19 <dmwit> Can you check a cabal flag in your source code?
19:38:24 <dmwit> i.e. can I write something like
19:38:32 <dmwit> #if flag(system_encoding)
19:38:41 <dmwit> {- some ffi stuff using system_encoding.h -}
19:38:42 <dmwit> #endif
19:38:43 <dmwit> ?
19:39:03 <dmwit> Veinor: [x, y, z] <- getArgs
19:39:22 <dmwit> Veinor: If you want to customize the error message, then something like
19:39:37 <tomoj> cads: cool
19:39:37 <tomoj> I love chef but don't like ruby so much
19:39:43 <dmwit> xs <- getArgs; case xs of [x, y, z] -> {- ... -}; _ -> die
19:40:47 <Veinor> so nest another do block in the {- -}?
19:40:55 <Veinor> (obviously don't actually put the comment markers in there)
19:41:05 <dmwit> Veinor: or another option is
19:41:08 <dmwit> xs <- getArgs
19:41:13 <dmwit> when (length xs /= 3) die
19:42:00 <Veinor> oh, huh
19:42:28 <dmwit> If you use genericLength and the Natural type, it will even be a lazy comparison. =)
19:43:17 <Vanadium> main = getArgs >>= case_of [x, y, z] -> do ...?
19:43:50 <dmwit> Vanadium: [x, y, z] <- getArgs does the same thing, and is actual syntax.
19:43:59 <Vanadium> Yeah, but it requires a do-block
19:43:59 <Veinor> I went with 'when'
19:44:19 <dmwit> Vanadium: Your snippet ends with a do block.
19:44:22 <dmwit> =)
19:44:35 <Vanadium> My intention was to address < Veinor> so nest another do block in the {- -}?
19:45:10 <dmwit> ah
19:45:21 <dmwit> Yeah, I'd probably just break whatever it was out into its own function anyway.
19:48:22 <dmwit> It looks like the answer to my question is "no".
19:48:32 <dmwit> So, my next question is, what do people normally do in this situation?
19:50:05 <benmachine> dmwit: isn't that what cpphs is for?
19:50:16 <benmachine> I think you'd set some kind of -Dthing in the flag section
19:50:22 <benmachine> and then let cpphs do the legwork
19:50:56 <benmachine> imo it's cleaner to put all the relevant code in a separate module that's only compiled if the flag is on (if that's possible)
19:51:12 <benmachine> hmm that might not be possible in most cases
19:51:17 <dmwit> benmachine: The problem is that we want to export a name iff a flag is set.
19:51:26 <benmachine> it's possible in the e.g. system-specific code with shared API case
19:51:29 <benmachine> but not otherwise
19:51:30 <dmwit> But tell me more about cpphs
19:51:35 <benmachine> errrm
19:51:55 <benmachine> it's a haskell implementation of CPP with some faffing to make it play nicely with 's and so forth
19:52:01 <dmwit> If you don't know much, it's okay, I'm concurrently looking on the web for more. =)
19:52:20 <benmachine> it can mostly be controlled in the same way cpp can, and accepts most of the same arguments
19:52:27 <benmachine> I don't know how to control it from cabal though
19:52:29 <benmachine> I've never used it
19:52:44 <benmachine> imo it's a bit ew
19:52:49 <benmachine> a bit 70s :P
19:53:20 <dmwit> Man, lava lamps are still awesome.
19:53:33 <benmachine> I thought plasma balls were awesome
19:53:36 <benmachine> but they're just expensive
19:54:27 <kynky> laserpods seem good
19:57:23 <FliPPeh> dmwit: I just watched a mythbusters episode where they turned a lava lamp into a bomb, just by heating it up :)
19:59:35 <dmwit> hah
19:59:46 <dmwit> Anything turns into a bomb if you heat it up enough. ;-)
19:59:50 <tensorpudding> A closed liquid-filled container does work as a bomb when heated.
20:00:48 <dmwit> I guess you'd have to heat it above the one-atmosphere boiling point.
20:00:55 <dmwit> Probably not that hard for water.
20:02:11 <Niccus> if the container is strong enough and transparent instead of a bomb you get a nice demonstration of supercritical fluid
20:02:14 <Mathnerd314> not according to this: http://en.wikipedia.org/wiki/MythBusters_(2006_season)#Stove_Myths
20:02:32 <dmwit> argh
20:02:42 <dmwit> wikimedia: freaking use %28/%29 !
20:02:49 <dmwit> Your URLs don't fit spec.
20:03:02 <idnar> which spec?
20:03:10 <Zao> dmwit: It's legal to not escape them.
20:03:37 <Zao> Quoting the RFC - "...Only alphanumerics [0-9a-zA-Z], the special characters "$-_.+!*'()," [not including the quotes - ed], and reserved characters used for their reserved purposes may be used unencoded within a URL."
20:04:42 <dmwit> huh
20:04:46 <dmwit> What am I thinking of?
20:05:29 <idnar> there are like half a dozen RFCs that talk about URLs
20:15:51 <edwardk1> i vaguely recall seeing a module namespace usage guide other than the old malcolm wallace one, anyone know the one i'm thinking of?
20:50:27 <interferon> so if GHC.Conc.numCapabilities returns 1, i won't be able to take advantage of multiple cores or cpus, correct?
20:50:27 <interferon> and
20:51:01 <interferon> if you have to define the number of threads you want when you build your app, does that mean that an app can't scale up to n available cpu's without being recompiled?
20:51:26 <idnar> you can pass parameters to the RTS when you run the app
20:51:39 <Zao> ./app +RTS -N9001 -RTS
20:52:03 <Zao> Or you can provide those via rtsopts when building.
20:52:42 <interferon> ah i see
20:53:10 <interferon> just curious, why can't it dynamically figure out?
20:53:28 <siracusa> Should 'map be preferred to (mkName "map") in TH?
20:53:49 <blackdog> i don't think it's a matter of not being able to figure it out - it's more a control option, so you don't peg _all_ the cores
20:53:51 <Cale> interferon: It could, but maybe you don't want to use all the CPUs
20:54:15 <Zao> interferon: http://www.haskell.org/ghc/docs/latest/html/users_guide/using-smp.html
20:54:27 <dons> interferon: +RTS -N4 :)
20:54:35 <Zao> interferon: It picks a suitable number if you do not provide one.
20:54:42 <dons> interferon: there's no reliable way to work out cpus on every platform.
20:54:50 <dons> so we let the user tell us
20:55:00 <interferon> it seems to always pick 1
20:55:05 <Zao> That is, if you just provide -N
20:55:24 <interferon> ah
20:55:44 <dons> +RTS -N4 is the flag to set numCapabilties to 4
20:57:01 <Zao> numCapabilities seems to be pessimistically at 1 here though.
20:57:12 <newsham> are there any listings of upcoming haskell type events?
20:57:21 <interferon> some on haskell.org
20:57:29 <interferon> newsham: on the front page of haskell.lorg
20:58:44 <newsham> ahh, was looking for less formal, like users group meetings, local talks, etc.
20:58:56 <newsham> looks like bayfp is defunct(ional)?
21:18:22 <interferon> surprised that there's no new york user group
21:19:58 <blackdog> interferon: for Haskell?
21:20:02 <blackdog> there's an FP one
21:20:06 <blackdog> I turned up once
21:20:16 <blackdog> was just me and some dude who was really into J
21:20:29 <interferon> oh yeah?
21:21:41 <blackdog> http://lisp.meetup.com/59/
21:21:53 <blackdog> maybe you can revive it:)
21:24:32 <interferon> :)
21:24:40 <interferon>  
21:24:46 <dmwit> I dig your nick.
21:34:53 <dmwit> aaaargh
21:35:44 <bos> dons: ping
21:42:03 <dmwit> Does cpphs come with the Haskell platform?
21:43:25 <dmwit> Man, I'm 0/3 on answers tonight. I must be getting better.
21:51:17 <Sgeo> What's mdo?
21:53:04 <aavogt> deprecated
21:53:08 <tensorpudding> @hoogle mdo
21:53:08 <lambdabot> Network.HTTP.Base normDoClose :: NormalizeRequestOptions ty -> Bool
21:53:55 <aavogt> something like -XDoRec or -XRecursiveDo
21:59:59 <dmwit> cabal needs way to run the dependency tree for profiling versions of the libraries
22:00:08 <dons> dmwit: interesting idea. but no, not currently
22:00:17 <dons> dmwit: yes. we do!
22:00:55 <dmwit> dons: "no, not currently" = "no, cpphs doesn't come with the HP currently"?
22:01:12 <dons> right
22:01:16 <dmwit> Okay, thanks.
22:01:24 <dons> you could propose it, but i'm not sure why (?)
22:01:39 <dons> c2hs would be more useful :) or hscolor
22:01:54 <dmwit> I'm trying to get a non-technical person to build http://dmwit.com/wyvern
22:01:58 <dmwit> (on Windows)
22:02:06 <dons> oh, and it needs cpp?
22:02:21 <dmwit> and one of the libraries is "encoding", which I've just retrofitted with a cpp to strip out dependencies on Linux libraries.
22:02:28 <dons> huh
22:02:34 <dmwit> Is there a better way to do it?
22:03:00 <dons> you mean http://hackage.haskell.org/package/encoding has linux-only dependencies?
22:03:19 <dmwit> I believe so, according to responses on haskell-cafe.
22:03:25 <dons> hmm. what library?
22:03:42 <dmwit> Or, you can do it in Windows, but it involves installing Msys/mingw, and I don't fancy explaining that to a non-technical person.
22:03:52 <dmwit> "cabal install cpphs" is much easier than installing msys, I think. =)
22:03:53 <dons> oh, for regex-compat?
22:04:01 <dmwit> No, in encoding itself.
22:04:13 <dmwit> http://code.haskell.org/encoding/system_encoding.h
22:04:24 <dons> ah!
22:04:31 <dons> so yeah, you need to make it more portable somehow
22:04:36 <dons> and let the author know too.
22:04:45 <dmwit> Yep, I'm sending him a darcs patch shortly. =)
22:06:54 <Zeiris> What's a good page/paper to really -get- monad transformers?
22:08:29 <dmwit> There's not much to get, really.
22:08:44 <dmwit> Use them once, or maybe twice, and they'll seem less fearsome.
22:09:04 <luite> it might help if you start with some monad, say State, and implement the transformer, StateT, yourself
22:09:34 <Zeiris> Using them once or twice doesn't seem to have taught me anything. I'll try what luite said :)
22:09:49 <dmwit> Good idea. =)
22:10:13 <dmwit> Oh, I got this weird message again.
22:10:23 <dmwit> "mkUsageInfo: internal name? a{tv a5HE}"
22:10:46 <dmwit> Right in the middle of my build output.
22:11:36 <dmwit> There's nothing on Trac, but I find it really hard to believe I'm the first one to see this stuff.
22:11:37 * aavogt has seen that too, but it doesn't seem to indicate any issues
22:15:54 <aavogt> dmwit: this would be a minimal case: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24619#a24619
22:16:20 <dmwit> Nice, thanks!
22:16:23 <aavogt> or nearly minimal
22:16:34 <aavogt> I'm not sure if your warnings are the same as this one
22:17:10 <aavogt> anyways, it doesn't actually indicate a problem for that code though....
22:17:34 <aavogt> since you can write $t  in a different module and it will work just fine
22:17:48 <dmwit> Yeah, I haven't encountered any problems, either.
22:17:57 <dmwit> It's probably just a Debug.Trace.trace that somebody forgot to take out.
22:19:17 <aavogt> cc me when you file the bug with ghc then?
22:19:33 <dmwit> right
22:19:58 <aavogt> thanks
22:21:53 <dmwit> aavogt: http://hackage.haskell.org/trac/ghc/ticket/3955
22:32:37 <blackdog> think i'm doing something a bit silly, but here goes - if I want access to a whole bunch of values defined in a C header file (ints, for the sake of argument), is there a programmatic way to import them with the FFI, or do I have to have a 'foreign import blah' line for each?
22:33:07 <blackdog> (i'm shifting over from c2hs to avoid the dependence of having it installed on the client)
22:33:29 <dmwit> Yep, one each.
22:33:38 <dmwit> You are, of course, free to write a function that outputs a bunch of FFI lines. =)
22:33:53 <dmwit> err... s/function/program/, but yeah
22:34:12 <blackdog> ah, another c/haskell wrapper :) just what the world needs...
22:34:23 <blackdog> thanks, at least i know i'm not being completely idiotic
23:05:13 <blackdog> dmwit: hrm, actually that doesn't help - all the values are actually in the header file, not the linked library.
23:08:11 <langtree> You could probably make a C program that includes it and outputs a Haskell file.
23:08:37 <langtree> Or outputs a text file that your program uses.
23:08:41 <dmwit> blackdog: Are you sure you don't want to just use c2hs?
23:08:46 <dmwit> I mean... that's what it's there fore.
23:08:51 <dmwit> -e
23:09:06 <dmwit> You can tell I'm a mathematician at heart. =)
23:09:12 <blackdog> it works beautifully with c2hs, but c2hs doesn't work beautifully with ghc 6.12
23:09:22 <blackdog> i'm trying to make it easier for my users to install hubris
23:09:26 <blackdog> at the moment, it's hell
23:09:42 <dmwit> Oh, boy, do I know how hard that is.
23:09:55 <blackdog> ideally, what i'd like to do is produce a tool with no reliance on any particular ruby.h file
23:10:00 <blackdog> and have it do the bindings at runtime
23:10:26 <blackdog> as it stands, it all gets set when you install hubris, which means that installing a new ruby interpreter means reinstalling hubris
23:11:57 <dons> blackdog: use hsc2hs ?
23:12:00 <dons> it comes with ghc/HP.
23:12:41 <dons> e.g. #enum keyword http://code.haskell.org/~dons/code/pcre-light/Text/Regex/PCRE/Light/Base.hsc
23:13:34 <dmwit> There's also Language.C if you really want to do runtime stuff.
23:14:05 <blackdog> dons: hm, that's an idea. thanks.
23:14:41 <blackdog> i sort of feel that i'm missing the right cleavage point. perhaps i should make the ruby.h dependence a typeclass... that way i can factor it out and substitute a new one at runtime
23:15:10 <dmwit> Records are easier to instantiate.
23:15:18 <blackdog> dmwit: the thing is, the runtime stuff i need to do is really minimal - i need to import a few functions and some values defined in the header, and die horribly if they're not there
23:15:34 <blackdog> that's a good point.
23:16:23 <blackdog> dons: i was reading your RWH chapter actually, and thinking about it, but figured that it'd just be swapping one dependency for another
23:16:29 <blackdog> but i think i can assume the HP
23:16:56 <dmwit> Yes! The HP is there to be assumed.
23:18:36 <luite> unfortunately the HP assumes opengl, so I cannot install it on my server :(
23:18:54 <blackdog> seriously?
23:18:57 <dmwit> hah
23:19:07 <dmwit> That's not a failure mode I would have predicted.
23:19:23 <dons> hsc2hs is a good thing to assume
23:19:28 <dons> since ghc ships with it.
23:19:30 <blackdog> surely there's a software opengl mode or something... it's not like you're going to use it anyway
23:19:54 <dons> luite: um... what's the distro?
23:19:58 <dmwit> blackdog: Perhaps he doesn't control the set of software available on the server.
23:19:59 <luite> blackdog: I tried installing the mesa development package, but it still didn't work
23:20:08 <luite> perhaps I did something else wrong
23:20:19 <dons> you don't have an opengl package whatsoever?
23:20:33 <luite> dons: ubuntu, not sure which one, 9.04 probably
23:20:51 <dons> why not just install the ubuntu package then?
23:20:53 <dmwit> luite: Did you install libgl-dev (or whatever it's called with a -dev at the end)?
23:21:20 <luite> dmwit: I did install some package providing the opengl.h header
23:21:21 <dons> the linux bundle warns what C libs you need on debian/ubuntu
23:22:17 <luite> ok, let me check again :)
23:22:39 <dons> luite: your server will build fine if you install the right C package. for ubuntu that's libghc6-opengl-dev
23:22:49 <dons> http://packages.debian.org/sid/haskell-platform <-- e.g. on debian
23:23:11 <luite> I don't run the ghc from a package because I use 6.12, the packaged one is 6.10
23:23:26 <luite> or even 6.8 probably, on this old ubuntu version
23:24:03 <dons> ok. so you certainly then need to resolve the C deps manually. http://packages.debian.org/sid/libghc6-opengl-dev
23:24:07 <dons> the C deps are listed there.
23:25:19 <luite> I don't see an opengl dependency there
23:26:04 <luite> installed mesa-common-dev for the GL/gl.h file, but this is the error I get from ./configure:
23:26:07 <luite> checking for library containing glEnd... no
23:26:09 <luite> configure: error: The OpenGL C library is required
23:27:39 <dons> make sure you have whatever the debian package says it needs.
23:27:54 <dons> i'm sorry ubuntu's lagging behind. they'll import the debian package soon enough
23:28:01 <dons> it'd be great if more people would work on ubuntu support
23:28:33 <luite> that's all it says (at least what configure says), and there is no README
23:28:53 <dons> you're still missing some dependencies, by the looks of it.
23:29:09 <luite> yeah I guess so, but which one :)
23:35:59 <blackdog> dons: is there a conventional way to map C constants to a data declaration with hsc2hs, or do you just write an extra Enum instance?
23:37:33 <luite> hm, I wonder wat goes wrong, I do have /usr/lib/libGL.so
23:39:02 <luite> oh wait, I didn't, only libGL.so.1
23:40:42 <luite> apparently the required packages are libgl1-mesa-dev, libglu1-mesa-dev and libfreeglut3-dev
