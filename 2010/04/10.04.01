00:01:37 <ski> (edwardk1 : given `data Ann f s = forall b. Ann (s b) (f b)' surely you can define `withAnn :: Ann f s -> (forall b. s b -> f b -> o) -> o' .. so why prefer making `withAnn' the selector ?)
00:02:20 <edwardk1> ski: the existential adds a bottom. in the form of the Ann constructor.
00:02:37 <edwardk1> you can't newtype wrap with an existential in ghc
00:02:43 <ski> hm .. as opposed to the `newtype' version .. i see
00:02:47 <ski> that's a shame, imo
00:02:50 <edwardk1> yeah
00:02:58 <edwardk1> it makes a lot of category-extras asymmetric
00:03:08 <edwardk1> taking otherwise perfectly good isomorphisms and adding bottoms here and there
00:03:24 <ski> (and does this crop up in efficiency, too ?)
00:03:31 <mjrosenb> hrmm, haskell-mode seems to be behaving in a very odd manner
00:04:30 <pastorn> mjrosenb: it's not exactle melborge
00:04:35 <edwardk1> minorly if at all. the main thing i like about the elimination for is it exactly matches the type its replacing. i'd been littering it all over my code.
00:04:50 <ski> btw, i'm not sure how `Annotated f Graph b' is supposed to model a graph with external annotations (i'm assuming `type Annotated f s b = (s b,f b)', here)
00:04:52 <edwardk1> ski: http://hackage.haskell.org/packages/archive/rope/0.6.1/doc/html/Data-Rope-Annotated.html
00:04:58 <edwardk1> yeah
00:05:20 <edwardk1> s is the graph 'structure' providing the adjacency matrix and ids for each vertex.
00:05:31 <edwardk1> the sharing of the brand is key. neither s nor f are Functors.
00:06:26 <ski> hm, example ?
00:06:51 <edwardk1> looking at the data.rope.annotated as inspiration you can see there is an empty :: Ann f Nil -- and append :: MonoidalAnn f => Ann f a -> Ann f b -> Ann f (a :<> b) -- which are designed so that the brands will be shared which ever way you associate the appends.
00:07:29 <edwardk1> so if you append f annotated ropes (a `append` b) `append` c  and a `append` (b `append` c) the type families used there ensure you get the same brand, and can safely unify, etc.
00:07:35 <edwardk1> on a graph
00:07:54 <edwardk1> an annotation would be, say, a vector the same length as the number of vertices in the graph, that contains one value for each vertex.
00:08:00 <ski> "brand" referring to ?
00:08:32 <edwardk1> a type level value that is usuaully in this case being introduced to prevent unification like the phantom argument  to ST s
00:09:46 <edwardk1> so the little type family tricks work a lot of the time, but some times i need to build a new rope or a graph in a way that depends on a value i can't reflect at the type level nicely
00:11:23 <edwardk1> so what i do then is do something like drop :: Splittable f => Int -> (f `Annotated` Rope) b -> (forall b'. (f `Annotated` Rope) b' -> r) -> r
00:11:33 <ski> (hm, `runAnn :: Ann f a -> (forall b. Ann f b -> r) -> r' looks strange to me .. why is `a' and `b' only mentioned once ?)
00:12:21 <edwardk1> the former is the old brand, which i don't care about. the latter is saying you expect a continuation that works regardless of brand.
00:12:43 <edwardk1> runAnn :: is kind of a waste, the one up above, where i box up the annotation is better
00:13:01 <edwardk1> i've since streamlined the code to avoid entangling some concerns
00:13:39 <dancor> looks like ghc 6.12.1 will not import Lol constructor on import Lol (Lol(..)) if Lol.hs has: data LolGen a = Lol; type Lol = LolGen Int
00:13:59 <edwardk1> now newtype Branded t b = Branded t
00:14:11 <edwardk1> dancor don;t you mean import Lol (Lol, LolGen(Lol)) ?
00:14:27 <dancor> edwardk1: that will work in ghc 6.12.1
00:14:53 <edwardk1> Lol(..) expects Lol to be a typeclass or a data/newtype
00:15:00 <dancor> but it looks like ghc 6.12.1 breaks some packages with that change.  i want to verify the change is intentional before fixing those packages
00:15:14 <dancor> i guess it is
00:15:25 <edwardk1> it has been a warning for a long time
00:15:28 <dancor> ah ok
00:38:33 <dancor> is it a joke that hsp needs base <4
00:41:04 <dancor> well fix was easy anyway
00:44:36 <FliPPeh_> Oh god, the XKCD april's site is AWESOME
00:44:40 <FliPPeh_> I can't stop messing with it
00:45:01 <luqui> who has the standard instance for Monad (w,)  ?
00:48:01 <edwardk1> Control.Monad.Instances
00:48:25 <edwardk1> its kind of annoying that it is exported neither by the prelude, nor by the module with the class. !@#*( orphan
00:48:53 <dibblego> does RWH have a chapter on happstack?
00:49:00 <FliPPeh_> I think not
00:49:03 <FliPPeh_> I've never seen one
00:49:39 <kmc> FliPPeh_, ;P
00:49:43 <kmc> it's not scriptable in any way
00:49:52 <kmc> i expected it to at least have a python shell if not ghci
00:50:02 <FliPPeh_> I was browsing the source
00:50:07 <FliPPeh_> "find kitty"
00:50:08 <FliPPeh_> <33
00:50:23 <FliPPeh_> s/kitty/kitten/
00:51:52 <FliPPeh_> Still waiting for google's page
00:54:45 <Becquerel> oh, they still don't have one?
00:54:49 <Becquerel> grief
00:54:58 <FliPPeh_> Youtube has been done already /:
00:55:13 <Becquerel> wikipedia is quite good today as well
00:55:48 <FliPPeh_> Cake?
00:55:55 <FliPPeh_> Oh no
00:55:58 <FliPPeh_> I just clicked cake.
00:56:02 <FliPPeh_> What's wiki doing?
00:56:17 <silver> guest@xkcd:/$ help
00:56:17 <silver> That would be cheating!
00:56:18 <silver> ж(
00:58:07 <FliPPeh_> archlinux april's fools is lame, it requires me to think
00:58:54 <Becquerel> the fool is, that they have no fool
00:59:09 <FliPPeh_> That'd be too easy :(
00:59:20 <Becquerel> FliPPeh_: http://en.wikipedia.org/wiki/Main_Page
00:59:56 <FliPPeh_> Pretty anti-woman today
01:00:03 <FliPPeh_> "Wife Selling", "GET FAT"
01:00:12 <Becquerel> I particularly like the In the news section
01:00:57 <FliPPeh_> HEh, "sent back in time" -> "playstime 3 leap bug"
01:01:42 * hackagebot uuagc 0.9.16 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-0.9.16 (ArieMiddelkoop)
01:03:08 <edwardk1> FliPPeh_: xkcd.com needs tab completion ;)
01:03:13 <FliPPeh_> badly
01:04:35 <ivanm> talking about being anti-woman... http://www.explosm.net/comics/2002/
01:05:03 * ivanm wonders where the google april fools day prank is
01:05:26 <FliPPeh_> Yep, I guess that's the prank
01:05:33 <FliPPeh_> Making us wonder what will happen
01:05:57 <Becquerel> guest@xkcd:/$ cat
01:05:57 <Becquerel> You're a kitty!
01:06:09 <Becquerel> It was inevitable
01:06:20 <FliPPeh_> Yayyyyyyyy kitties
01:06:51 <FliPPeh_> =^..^=
01:07:15 <FliPPeh_> But one thing is missing. Cowsay.
01:07:23 <Becquerel> and, naturally
01:07:26 <ivanm> FliPPeh_: what is the arch one? I can't find anything...
01:07:26 <Becquerel> guest@xkcd:/$ vi
01:07:26 <Becquerel> You should really use emacs.
01:07:26 <Becquerel> guest@xkcd:/$ emacs
01:07:28 <Becquerel> You should really use vim.
01:07:48 <FliPPeh_> ivanm: They're making us thing :(
01:07:53 <FliPPeh_> think*
01:07:58 <ivanm> I don't use arch.,..
01:08:06 <ivanm> so if it's something subtle, I doubt I would get it
01:08:37 <kmc> ha ha, vi and emacs
01:09:16 <FliPPeh_> The Arch wiki once had a nice running gag about vim and emacs in the wiki
01:09:29 <FliPPeh_> Where the emacs wiki page would insult vim and vice versa :x
01:09:40 <FliPPeh_> sadly, it got removed
01:10:05 <ivanm> Becquerel: well, it doesn't accept ed...
01:11:09 <kmc> because working ed into the joke would require originality
01:11:44 <ivanm> Becquerel: apt-get is there as well...
01:11:49 <ivanm> kmc: heh
01:11:53 <Becquerel> Hm.
01:11:56 <Becquerel> Super Cow Powers.
01:12:03 <Becquerel> Impressive.
01:12:20 <ivanm> FliPPeh_: I take it the magazine is the joke?
01:12:20 <FliPPeh_> They should keep the site like that
01:12:26 <FliPPeh_> Maybe...
01:12:35 <FliPPeh_> At least something in there
01:12:47 <ivanm> it's reversed...
01:12:56 <bastl> morning.
01:13:31 <bastl> Is there any pattern to do pattern matching on function parameters??
01:13:31 <kmc> morning
01:13:36 <kmc> what do you mean?
01:14:04 <bastl> in case my function is a sum, do this, in case its a product do that etc.
01:14:12 <kmc> no
01:14:20 <ivanm> use an algebraic datatype for that
01:14:20 <kmc> you can't inspect functions like that
01:14:33 <kmc> pretty much all you can do with a function value is apply it to an argument
01:14:36 <bastl> kmc: that's why i ask for a "design pattern"
01:14:40 <kmc> heh
01:14:43 * ivanm cheats and looks through http://github.com/chromakode/xkcdfools/blob/master/xkcd_cli.js
01:14:50 <Becquerel> cheater!
01:14:51 <kmc> bastl, what ivanm said
01:14:52 <chromakode> ivanm, cheater!
01:14:56 <kmc> data Func = Add | Mul
01:14:59 <ivanm> bastl: no, you asked for a pattern, not a design pattern!
01:15:03 <kmc> interpret Add x y = x + y
01:15:06 <kmc> interpret Mul x y = x * y
01:15:16 <ivanm> chromakode: I take it you are the perpetrator of this joke?
01:15:29 <chromakode> if anyone wants to add tab completion to xkcd, I'll gladly accept patches :)
01:15:32 <ivanm> bastl: besides, design patterns are useless in Haskell!
01:15:36 <bastl> kmc: ah.
01:15:38 <chromakode> ivanm, I am
01:15:40 <bastl> ivanm: ok.
01:15:44 <Jafet> What about designer patterns
01:16:08 <bastl> what about dseign in FP in general? are there any methodologies?
01:16:08 <kmc> what "design pattern" means in most of the programming community is "standard boilerplate workaround for a language flaw"
01:16:13 <kmc> we definitely have some of those
01:16:14 <ivanm> chromakode: the thing is, I've never used debian
01:16:18 <kmc> but we don't consider them a good thing ;P
01:16:18 <ivanm> so I have no idea how to use apt-get
01:16:26 <chromakode> ivanm, aww. have you apt-get moo?
01:16:29 <kmc> bastl, design in Haskell is heavily type-oriented
01:16:31 <ivanm> got that
01:16:34 <kmc> (not so in some FP languages)
01:16:40 <ivanm> only because I know portage stole it ;-)
01:16:43 <kmc> you spend a lot of time describing types
01:16:56 <ivanm> chromakode: as such, it makes it difficult to guess some of the commands, since I don't know the usage of apt-get
01:16:58 <kmc> and you hope that each function is an obvious conversion between types, usually by pattern matching
01:17:02 <ivanm> besides, using sudo is stupid
01:17:11 <kmc> you try to make the types express as much as possible even when you could get by with fewer types
01:17:13 * ivanm always has a terminal su'd to root for package management
01:17:16 <kmc> because more types = more errors caught
01:17:20 <Jafet> http://garyshood.com/root
01:17:42 <kmc> so e.g. in describing stuff to buy you want Weight and Price to be different types even though both could be represented by Double
01:17:52 <ivanm> chromakode: is it meant to have sticky keys?
01:18:00 <chromakode> ivanm, you betcha!
01:18:04 <kmc> for this we can use "newtype" which is like a more efficient version of "data" that is applicable in certain cases
01:18:23 <ivanm> because they're annoying!
01:18:40 <bastl> kmc: ok, but when i have an arbitrary problem: how should I design the types? I gain more and more experience, but i still miss a guideline of how to do it right.
01:18:40 <ivanm> Jafet: I'm not _that_ extremem!
01:18:44 <ivanm> *extreme
01:18:50 <Jafet> Pussy.
01:18:58 <ivanm> Jafet: even better: use the distro that does an rm -rf / if you enter a command wrong
01:19:16 <kmc> bastl, i'm not sure how to describe it better
01:19:16 <Jafet> I thought that was ubuntu
01:19:22 <kmc> i think you just need to gain a lot of experience
01:19:35 <ivanm> chromakode: what's wrong with firefox though?
01:19:49 <ivanm> since abetterbrowser has firefox as the first option...
01:20:04 <chromakode> ivanm, versions less than 3.0 have a but with alt text, which xkcd fans noticed quite frequently
01:20:13 <kmc> maybe someone else here has better guidelines
01:20:21 <ivanm> chromakode: who still uses < 3 though ?
01:20:23 <Becquerel> it seems to also recommend an upgrade for 3
01:20:30 <chromakode> ivanm, dunno, maybe someone. :)
01:20:31 <bastl> kmc: ok. thanks.
01:20:50 <Veinor> guys, did you hear? unsafeCoerce is going to be part of the prelude in 6.14!
01:20:57 <ivanm> chromakode: also, doing "sudo apt-get dist-upgrade win" takes me to abetterbrowser and then says it can't lock the admin directory
01:21:02 <kmc> i do feel like most of the C++ "design patterns" i learned would be an ordinary library in Haskell or any other language with good abstraction
01:21:02 <Jafet> Veinor, about time!
01:21:14 <ivanm> Veinor: eh, my proposed april fools day prank was better!
01:21:20 <ivanm> but dcoutts refused to play along :@
01:21:22 <Jafet> kmc, a lot of them are completely unnecessary in other languages
01:21:23 <Veinor> ivanm: what was it?
01:21:30 <edwardk1> @hpaste
01:21:30 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
01:21:33 <chromakode> ivanm, probably a bug I just fixed.
01:21:37 <ivanm> Veinor: you know how every now and then people bitch about module namespace collision?
01:21:39 <ivanm> chromakode: aha
01:21:41 <Jafet> kmc, like "multiple dispatch", which is so natural in Haskell it doesn't even have a name
01:21:46 <Veinor> yeah
01:22:02 <fasta> ivanm, I am using your graph software now. I think it is GREAT.
01:22:30 <ivanm> Veinor: I said to dcoutts that he should announce that in discussion with SPJ, etc. that real soon now they're going to start the module namespace from scratch and you have to _buy_ a module name from well-typed (acting on behalf of the haskell foundation or something)
01:22:31 <edwardk1> ski: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=9166#a9166 shows a small step towards what i was talking about earlier
01:22:36 <ivanm> shorter modules will be more expensive, etc.
01:22:44 <FliPPeh_> http://www.google.com/ig?hl=en&source=iglk
01:22:48 <FliPPeh_> Google's april fool
01:22:51 <Veinor> haha
01:22:53 <ivanm> that way, only the person who bought/registered the module can use it
01:22:55 <Veinor> I like that ivanm
01:23:04 <edwardk1> ivanm: interesting
01:23:07 <ivanm> dcoutts liked it as well, but was too chicken to do it
01:23:13 <edwardk1> yeah
01:23:18 <ivanm> FliPPeh_: where?
01:23:18 <edwardk1> it would be seen as a money grab
01:23:28 <ivanm> I see nothing there that is any different from usual...
01:23:30 <FliPPeh_> ivanm: Look at the selectable stuff
01:23:31 <ivanm> edwardk: exactly!
01:23:33 <Jafet> Why do I find that a good idea...
01:23:36 <FliPPeh_> "Ya Mamma Joke of the Day"
01:23:52 <FliPPeh_> "Kitty Kat Virtual Pet"
01:24:03 <ivanm> FliPPeh_: don't have that; I have "YoWindow" in the PCWorld.com most popular downloads of the week...
01:24:07 <Jafet> You could even do it PNG style, use letter case to distinguish registered and unregistered namespaces
01:24:09 <ivanm> FliPPeh_: maybe because I'm signed in...
01:24:12 <edwardk> ivanm: i think the package mounting proposal would fix the namespace scarcity problem though
01:24:22 <ivanm> edwardk: but that's not part of the joke!
01:24:27 <edwardk> ivanm: ah
01:24:48 <Jafet> But you couldn't use the first letter, maybe the second
01:25:12 <ivanm> chromakode: is "sudo make me a sandwich" meant to go to the abetterbrowser site as well?
01:25:29 <chromakode> nope
01:25:31 <ivanm> grrr... _everything_ is going there...
01:25:44 <Veinor> so... get a better browser!
01:25:48 <chromakode> try now ivanm
01:26:24 <edwardk> nice, the 'sudo make me a sandwich'  works on xkcd.com
01:26:46 <Veinor> cat
01:27:01 <Jafet> I wonder if you can try to install freebsd.
01:27:04 <ivanm> chromakode: "sudo apt-get dist-upgrade win" says I'm already running Linux
01:27:10 <DarkUnicorn> chromakode: really cool! is it just for april fools or will it stay?
01:27:28 <chromakode> DarkUnicorn, it'll probably stay under a different URI
01:27:31 <FliPPeh_> Lols
01:27:48 <FliPPeh_> And the german IT newsportal "heise" did another LHC black hole joke
01:27:53 <ivanm> oh, is it meant to? I thought it did something based upon the OS you entered
01:27:58 <fasta> ivanm, do you offer commercial support for your graph library?
01:28:14 <ivanm> fasta: ... I can consider something along those lines...
01:28:21 <ivanm> even though I don't have a graph library as such
01:28:25 <ivanm> and am doing a PhD atm...
01:28:29 <fasta> ivanm, also on the first of April?
01:28:34 <fasta> :)
01:28:37 <wavewave> how can I parse numbers?
01:28:40 <ivanm> *doh*
01:28:44 <ivanm> wavewave: using what?
01:28:45 <wavewave> String -> Double
01:28:51 <ivanm> @type read
01:28:51 <wavewave> I am using Parsec
01:28:52 <lambdabot> forall a. (Read a) => String -> a
01:28:54 <ivanm> > read "2.3"
01:28:55 <lambdabot>   * Exception: Prelude.read: no parse
01:28:59 <ivanm> > read "2.3" :: Double
01:29:00 <lambdabot>   2.3
01:29:03 <edwardk> sudo apt-get upgrade 'this looks pretty good to me'. cute
01:29:07 <wavewave> +2.3 cannot be parsed to 2.3
01:29:13 <FliPPeh_> read is bad
01:29:15 <ivanm> fasta: too tired, and am here instead of packing like I should
01:29:23 <ivanm> FliPPeh_: *shrug* it's simple to use though
01:29:24 <wavewave> 23.   -> 23
01:29:28 <FliPPeh_> > reads "4.7" :: [(Double, String)]
01:29:29 <lambdabot>   [(4.7,"")]
01:29:35 <FliPPeh_> > reads ".7" :: [(Double, String)]
01:29:36 <lambdabot>   []
01:29:41 <wavewave> 1e6
01:29:49 <wavewave> 1.3e-3
01:29:57 <wavewave> I need to parse such variations.
01:29:59 <ivanm> > let myRead ('+':str) = read str; myRead str = read str in myRead "+2.4" :: Double
01:30:00 <lambdabot>   2.4
01:30:11 <ivanm> wavewave: get a proper parsing library then
01:30:15 <ivanm> > let myRead ('+':str) = read str; myRead str = read str in myRead "+2.437" :: Double
01:30:16 <lambdabot>   2.437
01:30:18 <ivanm> > let myRead ('+':str) = read str; myRead str = read str in myRead "+2.437e8" :: Double
01:30:19 <lambdabot>   2.437e8
01:30:52 <FliPPeh_> let maybeRead = fmap fst . listToMaybe in reads "5.0" :: Maybe Double
01:30:52 <ivanm> wavewave: polyparser has a parser that can do that kind of stuff written for you already (not sure if it covers the "+2.3" case though)
01:30:56 <FliPPeh_> > let maybeRead = fmap fst . listToMaybe in reads "5.0" :: Maybe Double
01:30:57 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe GHC.Types.Double'
01:30:57 <lambdabot>         ag...
01:31:04 <ivanm> FliPPeh_: he might have a + on the front though
01:31:30 <FliPPeh_> > reads "+6" :: [(Int, String)]
01:31:31 <lambdabot>   []
01:31:33 <FliPPeh_> :/
01:31:47 <FliPPeh_> > reads "-6" :: [(Int, String)]
01:31:48 <lambdabot>   [(-6,"")]
01:32:13 <ivanm> chromakode: it should allow you to just do "w" for west, etc.
01:32:14 <wavewave> how about "5." ?
01:32:34 <ivanm> wavewave: not sure if polyparse's parser does that by default
01:32:45 <ivanm> but I think the version I've written for graphviz based upon it does something like that...
01:32:47 <chromakode> agreed ivanm
01:32:56 <wavewave> polyparse/
01:32:58 <FliPPeh_> I need something fun to do in haskel
01:32:59 <FliPPeh_> l
01:33:29 <ivanm> chromakode: awww, I got eaten :(
01:33:38 <edwardk> hah 'light lamp' and 'go north'
01:33:42 <ivanm> and now I'm dead :(
01:33:44 <edwardk> just found the adventure
01:33:47 <chromakode> ivanm, ouch!
01:34:01 <ivanm> chromakode: it said I could only go west and south, didn't mention north!
01:34:12 <eb4890> ivanm: w for west would spoil the joke... "go w!" wouldn't make a good song
01:34:12 <wavewave> is it parsec compatible?
01:34:22 <ivanm> eb4890: sont? what song?
01:34:27 <ivanm> wavewave: no, completely different library
01:35:20 <ivanm> dammit, the date lies!
01:35:27 <eb4890> ivanm: http://www.youtube.com/watch?v=9G75tH2wfvQ
01:35:47 <eb4890> Now the question is, is that a rickroll.
01:36:07 <ivanm> chromakode: you embed a fake terminal app into a fake terminal app?
01:36:09 <ivanm> that's just evil!
01:36:25 <chromakode> ivanm, eh?
01:36:43 <ivanm> chromakode: find kitten
01:36:47 <chromakode> :)
01:37:14 <wavewave> anyway thx!
01:38:56 <ivanm> no worries
01:39:00 <systemfault> Anyone on osx? Is it normal that cabal isn't installed with the haskell platform?
01:39:18 <systemfault> Or it's really well hidden..
01:39:38 <ivanm> systemfault: my guess is that the PATH is wrong
01:39:47 <ivanm> because both Cabal and cabal-install should be there
01:40:11 <systemfault> Ok
01:42:06 <pmaes> systemfault: I had the same problem and had to add the symlink manually to my bin
01:42:19 <ivanm> or update your PATH...
01:42:19 <systemfault> Ah ok, then I'm not alone
01:44:13 <systemfault> Ah... pmaes You're right, everything /Library/Frameworks/GHC.framework is properly symlinked but nothing in the haskell platform
01:45:23 <systemfault> Nice! :D
01:45:56 <ivanm> symlink, shmymlink
02:06:55 <SubStack> gah the routines I need are in hidden modules -_-
02:19:06 <ivanm> SubStack: "routines"? that sounds suspiciously Fortran-ish... >_>
02:19:45 <SubStack> heh well
02:20:05 <SubStack> I have been writing a lot of C lately
02:20:11 <SubStack> but only so I can build a DSL on top of that
02:20:24 <FliPPeh_> Any chance of Gtk2hs supporting GtkBuilder soon?
02:20:34 <ivanm> SubStack: so you need an exorcism? :o
02:20:35 <ivanm> :p
02:20:42 <ivanm> FliPPeh_: maybe ask on the gtk2hs mailing list? :p
02:20:51 <FliPPeh_> Nahh, too much effort.
02:20:55 * FliPPeh_ hides.
02:21:10 <ivanm> FliPPeh_: http://www.haskell.org/pipermail/haskell-cafe/2010-March/074544.html
02:21:10 <FliPPeh_> Gosh, those nick changes...
02:21:17 <ivanm> next release should have it apparently
02:21:26 <FliPPeh> Thanks ivanm :)
02:21:35 <ivanm> GIYF!
02:21:41 <FliPPeh> I've been googling :(
02:22:52 <FliPPeh> Is it just me, or doesn't Glade support lists with columns?
02:23:12 <FliPPeh> Been searching my butt off for it :/
02:33:02 <FliPPeh> Gah
02:33:10 <FliPPeh> I'm having a programming blackout
02:33:29 <FliPPeh> I want to do something so badly, but I have no idea. I always wanted to start some GUI stuff, anyone got an Idea for me?
02:33:38 <FliPPeh> I'm outsourcing my creativity now
02:34:00 <Jafet> A webbrowser
02:34:33 <FliPPeh> Something where I don't have to work around Microsoft's queers
02:34:41 <Entroacceptor> FliPPeh: I wanted to have a small gui to send to a webserver what game you're playing right now
02:34:56 <FliPPeh> Wouldn't be that much of a problem
02:35:06 <Entroacceptor> or a program to help gamemastering WorldTree
02:35:09 <FliPPeh> Like sending a text string or a pre-chosen list of stuff?
02:35:36 <SubStack> build a real-time constructive solid geometry isosurface ray tracer for the gpu
02:35:37 <Entroacceptor> text string, I guess
02:35:46 <Entroacceptor> SubStack: that's not gui
02:35:57 <FliPPeh> SubStack: No. Just no.
02:36:00 <Jafet> Ray tracers are passe
02:36:04 <Entroacceptor> FliPPeh: or rewrite my xmenud in haskell (and quicker)
02:36:11 <Jafet> Metropolis sampling is all the rage
02:36:13 <FliPPeh> xmenud? :/
02:36:17 <SubStack> FliPPeh: plus, it has cpu emulation
02:36:34 <Entroacceptor> sometimes I want to have a start menu in xmonad
02:36:39 <Entroacceptor> and that is just that :)
02:37:03 <Entroacceptor> shameless plug http://mad.unserver.de/2010/xmonad/xmenud/
02:37:10 <FliPPeh> Sounds more X11 than GTK
02:37:25 <Entroacceptor> but it takes awefully long to start the first time
02:37:25 <fasta> The London stock exchange is switching to a Haskell backend next year. How cool is that?!
02:37:32 <FliPPeh> Yay germanstuff
02:37:36 <Entroacceptor> april fools!
02:37:40 <SubStack> Entroacceptor: does xmenud have latency issues like dmenu?
02:38:13 <Entroacceptor> SubStack: the first reading of all those xdg files takes long, especially in python
02:39:35 <Jafet> hGetContents comes in handy
02:41:38 <FliPPeh> Who killed haskell.org?
02:42:08 <Jafet> It's just you
02:42:53 <FliPPeh> Wow, strange
02:43:06 <FliPPeh> I'm getting a timeout
02:43:14 <pmaes> A thrilling murder mystery. Looks like our killer *puts on sunglasses* left some sideffects.
02:43:24 <FliPPeh> YEEEEEAAAAAAAAAAAAAAAAHHH
02:43:37 <Entroacceptor> rofl
02:44:19 <FliPPeh> @quote ( pmaes) A thrilling murder mystery. Looks like our killer *puts on sunglasses* left some sideffects.
02:44:19 <lambdabot> No quotes for this person. :(
02:44:22 <FliPPeh> Aww.
02:45:09 <Botje> it's @remember
02:47:38 <mreh> sunglasses ay? J'accuse Mario!
02:48:38 <HugoDaniel> hello
02:48:43 <FliPPeh> Oh i
02:48:49 <HugoDaniel> i need help with profiling the vector lib
02:48:50 <FliPPeh> s/i/hi/
02:49:43 <HugoDaniel> hey FliPPeh
02:51:14 * hackagebot hoauth 0.2.0 - A Haskell implementation of OAuth 1.0a protocol.  http://hackage.haskell.org/package/hoauth-0.2.0 (DiegoSouza)
02:57:46 <ichor> Hello, I'm trying to write a function with the type:
02:57:48 <ichor> (Functor f) => f (forall y. (f y -> y) -> y) -> (forall x.(f x -> x) -> x)
02:58:02 <FliPPeh> It hurts me, take it away :'(
02:58:20 <ichor> FliPPeh, my type?
02:58:33 <FliPPeh> Everything with "forall" confuses me
02:58:48 <ichor> My best guess right now is: \r f -> f $ fmap ($f) r
02:58:56 <dobblego> FliPPeh, have you ever used Java?
02:59:11 <HugoDaniel> forall is easy, really
02:59:13 <FliPPeh> dobblego: Nope, I never liked it.
02:59:19 <ivanm> ichor: why the forall?
02:59:30 <ivanm> do you actually need them?
02:59:38 <ivanm> oh, wait, are you trying to do some coercement?
02:59:39 <ichor> I really think so yeah.
02:59:48 <dobblego> ivanm, it changes the signature without it
02:59:49 <ichor> Coercement?
03:00:08 <ivanm> why are you wanting such a function?
03:00:14 <ivanm> ichor: changing the values of type y to type x
03:00:42 <ichor> ivanm, notice the outer f ( ) around the ones with the y's.
03:00:47 <quicksilver> well, x and y are both quantified
03:00:54 <quicksilver> they're only different variables for clarity
03:01:11 <gaze__> hey, why is it that I can't have two definitions of some function f (x,y) and f (x,y,z) ?
03:01:20 <ichor> quicksilver, exactly.
03:01:23 <HugoDaniel> is haskell.org up ?
03:01:24 <quicksilver> because funcitons have to have a single type, gaze__
03:01:29 <FliPPeh> HugoDaniel: Not for me
03:01:34 <quicksilver> (although you can overload a fucntion with methods)
03:01:37 <FliPPeh> HugoDaniel: you might have more luck, tho
03:01:56 <HugoDaniel> it aint up here...
03:01:58 <gaze__> hmm? I'm a bit confused
03:02:02 <FliPPeh> Welcome to the club
03:02:10 <gaze__> I suppose I'd like to overload this
03:02:36 <gaze__> what I'm trying to accomplish is have add/subtract/multiply ops for 3 vectors and 2 vectors
03:02:46 <quicksilver> that's a classic case for overloading, yes.
03:03:06 <FliPPeh> gaze__: How about defining a data type for it?
03:03:12 <quicksilver> class VectorOps a where (<+>) :: a -> a -> a
03:03:20 <FliPPeh> data Vector = Triple (a,b,c) | Tuple (a,b)
03:03:21 <quicksilver> instance VectorOps (Int,Int) where ...
03:03:26 <FliPPeh> And pattern match
03:03:28 <Jafet> Dependent types!
03:03:33 <quicksilver> ignore FliPPeh's suggestion, it's not what you want.
03:03:39 <FliPPeh> Whyyyyyy
03:03:45 <quicksilver> and instance VectorOps (Int,Int,Int) where ...
03:04:01 <quicksilver> FliPPeh: because it permits you to add 2-vectors to 3-vectors.
03:04:25 <FliPPeh> Not if you pattern match those into 2 different calculations :/
03:04:37 <quicksilver> it makes the types such that it is allowed.
03:04:42 <FliPPeh> mhh
03:04:51 <gaze__> where is the instance keyword documented?
03:05:11 <dobblego> under the heading "type classes"
03:05:14 <quicksilver> in the haskell report, gaze__, along with the rest of the language.
03:05:23 <fasta> Why don't you use the Vec library?
03:05:30 <quicksilver> because he's trying to learn the language
03:05:43 <quicksilver> not find someone elses implementation of a library.
03:05:55 <fasta> Ok, why don't you read the Vec library?
03:06:06 <gaze__> because I didn't know it existed, hahah
03:06:26 <gaze__> I'd rather use something already implemented... but this is definitely good... I really do wanna learn this bit of the language
03:06:42 <HugoDaniel> ive been looking out at the speed of some haskell snippets, and im totally amazed by how strange things get stranger things faster
03:07:33 <quicksilver> well, the Vec library uses a fairly complex dependent-type encoding using fundeps
03:08:16 <quicksilver> I don't think I'd recommend its sourcecode as reading material if you are just learning instances in general
03:08:22 <quicksilver> but only you know the best learning path for yourself.
03:08:54 <gaze__> yeah, I think I really should just learn instances... is there something a little softer than the formal definition of instances?
03:08:59 <ichor> My guess at a function of that type would be correct if only I could decide how the type quantifications should be in the function definition.
03:09:28 <gaze__> also... is there any nice way to end up using vector intrinsics? or is the boxing just gonna make that useless.
03:09:45 <HugoDaniel> vector intrinsics ?!
03:09:52 <quicksilver> try the wikibook, or RWH, gaze__
03:10:06 <gaze__> err... sorry, I'm thinking C compiler intrinsics...
03:10:07 <quicksilver> no, there is no nice way to use vector intrinsics although there are plenty of people who would like there to be
03:10:16 <quicksilver> I suspect it will come sooner rather than later.
03:10:26 <gaze__> yeah, I guess it's all need based
03:10:30 <HugoDaniel> gaze__: -fvia-c -optc -msse4.1 should do the trick :P
03:10:42 <fasta> I doubt that.
03:11:00 <quicksilver> http://book.realworldhaskell.org/read/using-typeclasses.html
03:11:05 <quicksilver> HugoDaniel: no, it won't.
03:11:08 <HugoDaniel> then, -fvia-c -optc -msse4.1 -optc -O3 -optc -march=core2 -should do the trick :P
03:11:28 <fasta> But it is not an open math problem to compile high-level Haskell vector operations to efficient hardware vector operations.
03:11:31 <quicksilver> gcc is not very good at automatic vectorisation, and GHC does not produce the kind of output gcc wants to see to do automatic vectorisation.
03:11:37 <fasta> It's just that nobody cares.
03:11:57 <quicksilver> s/nobody cares/the set of people who care, and are capable of implementing it, are relatively busy and working on other stuff too/
03:12:17 <fasta> Ok, nobody cares enough*
03:12:18 <quicksilver> gaze__: http://book.realworldhaskell.org/read/using-typeclasses.html
03:12:36 <gaze__> got it, thanks!
03:12:43 <quicksilver> nobody cares enough for it to exist today. I estimate enough people care enough for it to exist by this time next year.
03:12:54 <quicksilver> time will tell.
03:13:10 <fasta> quicksilver, interesting prediction. You should save that somewhere.
03:13:10 <gaze__> well... I would suspect that if you're working with a 3-tuple, it would make sense to just use vectorized addition
03:14:09 <fasta> gaze__, I was thinking of the more general problem of an n-vector.
03:14:34 <quicksilver> fasta: well, I made a brief stab at it before realising I was too busy. I believe mmorrow made some stabs at it. I know the dph guys are interested, and I think the uvector guys are interested.
03:14:52 <quicksilver> The backend guys were more interested in first switching to SSE for the FP backend (now done, I think)
03:15:04 <quicksilver> there is a certain critical mass approaching
03:15:15 <alpounet> it would be nice
03:15:16 <fasta> It is also a matter of where you implement it.
03:15:18 <HugoDaniel> :)
03:15:41 <fasta> You can extend the compiler, or you can do it in a library.
03:16:16 <fasta> I have heard Lennart complain about lack of partial evaluation a lot on the mailing lists.
03:16:23 <fasta> Probably that will be fixed first.
03:16:56 <HugoDaniel> i am totally amazed by haskell optimization
03:17:26 <HugoDaniel> it is like playing russian roullete for me, i just try to rewrite stuff in other ways
03:17:42 <HugoDaniel> and get totally diff results
03:17:49 <HugoDaniel> (in terms of speed)
03:19:34 <fasta> The only way to stop being amazed is to inspect the assembly language being generated and to read the platform documentation.
03:19:47 <fasta> (unfortunately)
03:20:06 <alpounet> is there any package to do linear regressions ?
03:20:09 <alpounet> can't find any
03:20:13 <alpounet> (so far)
03:20:15 <HugoDaniel> fasta: no
03:20:19 <HugoDaniel> its not that kind of amazed
03:20:21 * twink has rarely needed Haskell to be optimized.
03:20:24 <fasta> alpounet, not that I know of.
03:20:38 <twink> alpounet: hmatrix has the linear algebra to do it with
03:20:44 <Jafet> HugoDaniel, get the guy in Rain Man to optimize it for you
03:20:54 <HugoDaniel> :D
03:20:58 <fasta> alpounet, (assuming your want a non-GPL license)
03:21:00 <Jafet> Actually, that was blackjack.
03:21:02 <HugoDaniel> yes, he knows
03:21:06 <alpounet> twink, yeah, and gslhaskell too IIRC
03:21:32 <alpounet> fasta, GPL is fine, it's just for some personal stuffs
03:22:13 <fasta> alpounet,  Math.Statistics.	linreg
03:22:24 <alpounet> hmm thanks fasta
03:22:28 <fasta> alpounet, hstates
03:22:31 <fasta> hstats
03:24:04 <fasta> I am just disappointed when I see an implementation of the median in more than linear time as is done in the hstats package.
03:24:20 <fasta> Just do not implement it if you cannot do it in the right way.
03:24:36 <alpounet> hmm
03:24:48 <alpounet> also, it would be nice to have a vector-based hstats
03:25:00 <fasta> It is not like it is a terrible amount of work to do so and every introductory algorithms book contains how it should be done.
03:25:50 <alpounet> fasta, it seems there is not multivariate version, moreover. hmm
03:26:37 <twink> I'll have to look it up. I can't think of it right off the top of my head.
03:27:14 <fasta> It's even on Wikipedia: http://en.wikipedia.org/wiki/Selection_algorithm
03:27:29 <fasta> (if it is on Wikipedia, it is is mainstream)
03:27:33 <fasta> it is*
03:27:46 <fasta> C++ implements it correctly too in the STL.
03:29:28 <gaze__> hmm... what should I do about my + interfering with the prelude's +?
03:29:41 <ichor> How can I help GHC see where the "forall" quantification should be instanced when using functions?
03:30:34 <ichor> I get errors like: Couldn't match expected type `(f x -> x) -> x', against inferred type `forall y. (f y -> y) -> y'
03:30:58 <quicksilver> gaze__: import Prelude hiding ((+))
03:31:12 <quicksilver> gaze__: (although, this is probably a rabbithole not worth pursuing for real code)
03:33:17 <gaze__> yeah this doesn't seem quite right... okay how should I do this properly? Say I have my vector class, defining a (+) :: a -> a -> a and abs, and instance of this with (x1,y1,z1) + (x2,y2,z2) = (x1+x2,y1+y2,z1+z2), and abs (x,y,z) = sqrt (x**2+y**2+z**2)... I think it thinks the + within the sqrt is ambiguous
03:33:43 <quicksilver> gaze__: you should not re-use (+), basically.
03:33:52 <Moog_> Hi there, I have a newbie question: I'm trying to figure out how to add a large set of numbers. The example I'm experimenting with is adding all integers from 1 to, say, 100 million. I have tried this:
03:33:57 <quicksilver> it's not a good idea to try to use a name already chosen by another class
03:33:59 <twink> fasta: That's selecting the k smallest of n, not the median.
03:34:12 <quicksilver> it's not impossible, but it's not advisable
03:34:29 <zygoloid> twink: it's selecting the kth element, and partitioning about it.
03:34:54 <zygoloid> for n = 2k, that's selecting the median
03:34:55 <gaze__> oh! okay... I mean, I'm trying to learn convention too... I figured the c++ thing would be to overload the + operator, what would be the haskell way to name my vector addition function?
03:35:05 <Moog_> 1) straightforward recursive add with the list [1..100000000] as the starting argument -- stack overflow for obvious reasons
03:35:15 <Jafet> gaze, (+)?
03:35:28 <Jafet> > sum [1..100000000]
03:35:32 <lambdabot>   mueval-core: Time limit exceeded
03:35:35 <Moog_> 2) same, with tail recursion, OK but rather slow
03:35:49 <fasta> twink, In computer science, a selection algorithm is an algorithm for finding the kth smallest number in a list (such a number is called the kth order statistic). This includes the cases of finding the minimum, maximum, and median elements.
03:35:52 <Jafet> > 100000000*100000001`div`2
03:35:53 <alpounet> hmm
03:35:55 <fasta> twink, it would help if you would read.
03:35:55 <lambdabot>   5000000050000000
03:36:05 <alpounet> I could actually give a shot to a vector-based statistics library
03:36:16 <Moog_> 3> foldr, same problem as 1), also obvious
03:36:20 <quicksilver> gaze__: if you want to overload (+) itself then you want to make your vector an instance of Num itself.
03:36:27 <FliPPeh> "readDay = fmap fst . listToMaybe . readsTime defaultTimeLocale "%d.%m.%G"" <- Why is this function bullet proof when I test it in GHCi with any string I pass to it, valid or not, but fails for EVERYTHING on a date I read in with "getLine"?
03:36:28 <Moog_> 4) foldl, same as 2)
03:36:41 <quicksilver> gaze__: ...this is a bit clumsy for a variety of reasons which could be summarised as "Num was not designed to be used for vectors"
03:36:45 <Saizan> Moog_: foldl'
03:36:53 <gaze__> yeah, I don't want that.
03:36:59 <FliPPeh> Wait
03:37:02 <FliPPeh> readLn vs getLine
03:37:03 <quicksilver> gaze__: alternatively, make your own class and use your own name
03:37:10 <Jafet> Hmm, Num has *, eh
03:37:14 <gaze__> how would you name it if you were doing this?
03:37:18 <Saizan> @wiki Stack Overflow
03:37:18 <quicksilver> gaze__: I have used ^+^ in the past
03:37:18 <lambdabot> http://www.haskell.org/haskellwiki/Stack_Overflow
03:37:34 <quicksilver> gaze__: with the '^' intended to denote 'vector on this side'
03:37:37 <Saizan> Moog_: http://www.haskell.org/haskellwiki/Stack_overflow
03:37:45 <gaze__> gotcha, thanks!
03:37:47 <quicksilver> gaze__: so *^ for 'scalar multiplication of vector'
03:37:57 <quicksilver> gaze__: and ^-^ for vector-vector subtraction
03:37:57 <quicksilver> etc.
03:38:01 <quicksilver> obvioulsy it's up to you :)
03:38:14 <zygoloid> Moog_: (1) right, stack overflow. (2) same as (4) but the compiler infers some strictness. (3) right, same as (1). (4) needs more strictness - use foldl'.
03:38:38 <Moog_> Saizan: thanks, I think I've been there, back then I have a different problem and wasn't able to solve it that way, have to check again
03:38:49 <gaze__> sure, but I'd like to pick up a sense of what someone might name it had they read a lot of other haskell code...
03:39:01 <Jafet> Moog, this might be a good time to learn seq
03:39:17 <zygoloid> @wiki Foldr Foldl Foldl'
03:39:17 <lambdabot> http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl'
03:39:25 <zygoloid> Moog_: ^^ you may find that useful
03:40:40 <Moog_> thanks guys, I'll read up first, although I'm sure I've seen them before, I probably just didn't read them carefully enough
03:41:27 <Moog_> my problem back a few weeks ago which I was unable to solve was actually something different, so I resorted back to adding integers in order to take it step by step
03:43:38 <twink> introsort is interesting though I still haven't gotten a grip on timsort.
03:44:18 <Saizan> Moog_: the point is that what's syntactically tail recursive doesn't actually denote a "loop" like if you were in a strict language
03:44:39 <Saizan> Moog_: to get to that point you've to add a strictness annotation in many cases, which is what foldl' does
03:44:53 <Jafet> timsort is interesting as a way of hacking with silly python semantics and pushing their flawed one-way-to-do-it philosophy
03:45:30 <Saizan> Moog_: but foldl' adds enough strictness only to evaluate the outermost constructor, which works fine with Ints but it's not enough if your accumulator is a more complex structure
03:46:03 <Saizan> Moog_: in which case you've to add more strictness yourself
03:46:36 * JuanDaugherty checks if anybody is working on a Haskell version of Nix, ideally with a gui. 
03:46:41 <Saizan> Moog_: this in the case, like addition, where the stepping function can't exploit laziness, otherwise a foldr is the preferred route
03:46:43 <luqui> gaze__, Data.VectorSpace uses ^+^
03:47:35 <Moog_> Saizan: so what's the best general solution for a complex accumulator problem? seq, DeepSeq, or strict data types?
03:48:13 <Saizan> Moog_: depends on how the structure looks like
03:48:50 <Saizan> Moog_: deepSeq would eliminate the thunks but it'll waste a lot of time retraversing the structure
03:49:26 <Saizan> Moog_: so, adding just enough seq/bang patterns/strict fields in the data declarations is preferred
03:49:55 <quicksilver> for really complex cases, the "Strategy" library gives you combinators for building up specified strictness patterns.
03:50:11 <quicksilver> very seldom needed but nice to know it exists.
03:50:37 <Saizan> you could paste the code on hpaste and let us take a look, it might be quite simple :)
03:51:51 <Moog_> Saizan: haven't got it with me, unfortunately, but it's basically a multiply-accumulate problem where both arguments of the multiplication are functions themselves, one of them containing a pseudo-random number as well
03:52:56 <Jordi_> Hi
03:53:06 <Saizan> so your accumulator is a function?
03:53:13 <Jordi_> does anyone know if there is a mode in haskell-src to preserve layout?
03:53:33 <Saizan> there might be one in haskell-src-exts
03:54:26 <Moog_> Saizan: yes
03:55:05 <Jordi_> thanks!
03:55:43 <luqui> haskell-src-exts is a personal god of mine
03:55:47 <Jordi_> i've been looking the documentation of haskell-src-exts and de Pretty module looks the same
03:56:09 <Jordi_> i'll check it out
03:56:13 <luqui> Jordi_, look at the Annotated modules
03:56:32 <luqui> they store all the position information for everything at every level
03:56:41 <Jordi_> :)
03:56:52 <Jordi_> Is it much harder to process?
03:57:04 <luqui> there is an extra argument on every constructor
03:57:05 <luqui> that's all
03:57:14 <Jordi_> thats fine
03:57:16 <Saizan> Moog_: uhm, from the outside you can't do more than seq on functions, though you've to use it the right way, or maybe you've to alter the way you do the multiplication, hard to tell without seeing the code
03:57:24 <Jordi_> im planning on using generics
03:57:41 <luqui> yeah, i just bit the bullet and wrote out what i wanted for hothasktags
03:57:53 <luqui> it was kind of a pain, generics would be good i think
03:58:04 <Saizan> Moog_: however, once you learn how laziness works most cases of this problem will be apparent by looking at the code
03:58:18 <Saizan> hothasktags?
03:58:43 <luqui> i reimplemented hasktags to be aware of qualified/restricted imports and stuff
03:58:47 <Moog_> Saizan: thanks a lot
03:59:27 <Saizan> ah, nice, but only for vim :\
03:59:40 <luqui> i don't know the emacs tag format
03:59:49 * Saizan neither
04:00:02 <luqui> i am not sure if it supports scoped tags
04:00:29 <Saizan> i guess i'll have to check, and send a patch, if i start using tags again :)
04:00:55 <luqui> i am more addicted to tags now that I can use my naming convention with them
04:01:06 <luqui> ^W }  is my favorite command
04:20:15 <waterlaz> why doesn't haskell has utf8 support out of the box?
04:20:34 <Eelis> depending on what you mean by "support", it does
04:20:36 <xerox> can has support?
04:21:04 <waterlaz> I mean that the default strings are not utf8
04:21:14 <zygoloid> waterlaz: the default strings are unicode.
04:21:19 <waterlaz> they are?
04:21:26 <zygoloid> yeah. type String = [Char]
04:21:34 <zygoloid> and Char represents a unicode codepoint
04:21:37 <Eelis> > length "→"
04:21:39 <lambdabot>   1
04:21:44 <waterlaz> huh.. then this is odd
04:21:45 <FliPPeh> Chars are 32 bit
04:21:51 <FliPPeh> You can store anything in there..
04:21:57 <waterlaz> thanks
04:22:01 * waterlaz googling
04:22:06 <zygoloid> > maxBound :: Char
04:22:08 <lambdabot>   '\1114111'
04:22:10 <FliPPeh> That's why they're not that efficient on big files
04:22:12 <zygoloid> FliPPeh: they're not 32 bit
04:22:14 <FliPPeh> No?
04:22:19 <FliPPeh> At least they're big.
04:22:26 <zygoloid> they store a unicode codepoint
04:22:51 <zygoloid> > (fromEnum (minBound :: Char), fromEnum (maxBound :: Char))
04:22:52 <lambdabot>   (0,1114111)
04:23:22 <Jordi__> does anyone know any tutorial for haskell-src-exts?
04:23:23 <zygoloid> > log 1114111 / log 2
04:23:24 <lambdabot>   20.087461546321563
04:24:01 <zygoloid> FliPPeh: ^^ they're just over 20 bits in an information-theoretic sense
04:24:26 * zygoloid doesn't know how big the runtime representation is, but suspects it's at least 8 bytes
04:26:00 <int-e> a tag, a value (possibly shared), plus a pointer pointing to them
04:26:09 <FliPPeh> I really, really think they're guaranteed to be 8 bit
04:26:09 <zygoloid> waterlaz: in non-bleeding-edge versions of GHC, the standard IO functions (readFile, putStrLn, etc.) didn't use utf-8, so you had to use a library for that. now (6.14?) they are encoding-aware
04:26:15 <int-e> a word each, which is usually 4 or 8 bytes
04:26:30 <Jafet> 6.14 is now?
04:26:43 <int-e> FliPPeh: in java, perhaps
04:26:55 <zygoloid> Jafet: for some interpretation of 'now', perhaps :)
04:27:26 * zygoloid isn't sure 6.12 has the new IO goodies, checking...
04:27:50 <zygoloid> yeah, 6.12 :)
04:28:56 <zygoloid> int-e: i thought chars were 16-bit, UTF-16 encoded, in Java. but i don't know Java :)
04:29:49 <int-e> zygoloid: then no language I know of. in C, it's the smallest adressable unit and at least 8 bits. it can be bigger.
04:32:36 <zygoloid> int-e: well, it's the smallest unit that C can address, at least. istr reading that there was a machine with 7-bit bytes (possibly made by DEC?) where C compilers had to use 14-bit 'char' and as a result couldn't use the byte addressing
04:36:12 <scotty> Is anyone here familiar with HOpenGL?
04:37:27 <FliPPeh> Why doesn't my backspace work in getLine inside GHCi, but when I compile it?
04:37:27 <FliPPeh> :/
04:38:59 <Jafet> Nothing to do with getLine
04:39:34 <FliPPeh> Jafet: It works with "readLn"
04:39:59 <Jafet> Ok, maybe something to do with getLine...
04:41:14 <Jafet> Using readLn here doesn't parse backspaces, either
04:41:22 <FliPPeh> Alright
04:41:39 <Jafet> Is there a curses binding to haskell?
04:41:45 <Jafet> @hoogle curses
04:41:46 <lambdabot> No results found
04:42:05 <FliPPeh> http://hackage.haskell.org/packages/archive/hscurses/1.3.0.2/doc/html/UI-HSCurses-Curses.html
04:43:14 <Jafet> Why are all interfaces to curses identical to the C one.
04:43:53 <Jafet> No one came up with a better way of abstracting interaction with a terminal.
04:44:09 <FliPPeh> :/
04:44:11 <Saizan> there's vty and vty-ui though
04:45:04 <Jafet> It does look saner from the docs
04:49:21 <Saizan> FliPPeh: it's a problem with buffering, ghci sets NoBuffering
04:49:34 <FliPPeh> Saizan: Ahh, thanks
04:51:11 <FliPPeh> I wonder, is there a good way to parse something like 'arg1 arg2 "longer argument 3" arg4 "another longer argument 5"' without whipping out the parsec overkill?
04:51:36 <FliPPeh> ["arg1", "arg2", "longer argument 3" ...]
04:52:08 <Saizan> you could start with words and then do some grouping
04:52:24 <FliPPeh> I think so
04:52:24 <Saizan> parsing parentheses is quite simple with recursion.
04:53:14 <FliPPeh> Check for " at the first place, and recurse until there's another one at the end, right?
04:54:00 <Jafet> Depends on the mechanism you use to escape quotes
04:54:06 <Saizan> yeah
04:54:35 <Saizan> the default is to ignore a quote if it comes after a backslash
04:55:01 <FliPPeh> Sounds like a pain with regular take and drops
04:55:10 <Jafet> sh has a brilliantly confusing quote mechanism. I don't even know what it is yet
04:55:30 <Saizan> i don't think take and drop have much to do here.
04:56:56 <Saizan> i'd just use direct recursion pattern matching on the first characters of the string to decide what to do.
04:59:00 <FliPPeh> I think skipping words is the best thing
05:04:18 <HugoDaniel> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24572#a24572  any suggestions to make this go faster ?
05:12:02 <Botje> could you use noiseFunc once for a biggercube and then slice it up?
05:12:19 <Botje> (i don't know the type, so ..)
05:14:59 <HugoDaniel> here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24573#a24573
05:15:21 <HugoDaniel> yes, i have tried to do that, but i mesed it up somehow, ill try it again
05:16:29 <Botje> hmm, don't really see anything useful right now
05:18:33 <HugoDaniel> ill try to write it in C
05:19:44 <Botje> HugoDaniel: if you generate all n[01][abcd] values at once you can reuse a lot of work
05:20:59 <Botje> same comment for linear, i guess
05:21:41 <HugoDaniel> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24574#a24574  like this?
05:24:38 <Botje> i guess
05:24:47 <Botje> that's a lot of duplicated code though
05:26:17 <Botje> does it gain you anything?
05:31:38 <JaffaCake> did anyone else get the reminder email from Mailman on haskell.org today?
05:33:12 <Igloo> I didn't get one this month or last month
05:33:51 <JaffaCake> hmm, I wonder what happened
05:35:01 * hackagebot Bitly 0.0.4 - A library and a command line tool to access bit.ly URL shortener.  http://hackage.haskell.org/package/Bitly-0.0.4 (SergeyAstanin)
05:40:45 <HugoDaniel> Botje: it doesn't, it goes from 4s to 6s :(
05:40:54 <Botje> boo
05:43:27 <FliPPeh> Which XML library do you recommend?
05:43:38 <FliPPeh> Memory usage, speed
05:43:46 <FliPPeh> How fun it is to use
05:44:13 <fasta> FliPPeh, XML and fun?
05:44:23 <fasta> FliPPeh, from what planet are you?
05:44:25 <FliPPeh> I mean in a relative style
05:44:30 <fasta> FliPPeh, the xml library works.
05:44:41 <FliPPeh> Xhtml is pretty fun to use
05:44:48 <FliPPeh> With all that << nesting and stuff.
05:45:08 <fasta> FliPPeh, if you want to go crazy use HXT. \
05:45:25 <fasta> FliPPeh, HaXML is reasonable, but I don't like it.
05:45:38 <fasta> FliPPeh, that's the executive summary.
05:45:45 <FliPPeh> okay :)
05:46:21 <fasta> I imagine that if it has to be "really fast" I would either have to completely read the code of hexpat or write something from scratch.
05:46:34 <FliPPeh> Not fast, just usable
05:46:41 <FliPPeh> Would only be a nice side effect
05:46:45 <fasta> FliPPeh, xml then.
05:47:02 <fasta> FliPPeh, it is basically a zipper, so you can just go up and down in the tree.
05:47:13 <fasta> FliPPeh, hang stuff in it and so on.
05:47:48 <fasta> And since it was made by someone who paid to do so, there is some quality in it.
05:47:58 <fasta> who was paid*
05:50:01 <quicksilver> I quite like haxml but it's an idiosyncratic interface and takes some getting used ot.
05:50:04 <quicksilver> to.
05:50:15 <quicksilver> HXT is the same thing taken further, roughly, although there are other differences.
05:50:38 <quicksilver> using arrows as generalised parsers/transformers is a genuinely useful idiom to have encountered, though.
05:55:17 <Moog_> Saizan: are you around? I have some code to show you, just don't know how to use hpaste
05:55:51 <zakwilson> Are comparisons between ByteStrings faster than comparisons between Strings?
05:56:20 <fasta> zakwilson, generally, yes.
05:56:28 <zakwilson> fasta: significantly?
05:56:44 <fasta> zakwilson, I never ran the numbers, but probably 10 times or so.
05:57:29 <fasta> In most applications linear time algorithms are not the bottleneck, I think.
05:57:36 <Twey> HXT is clever, but hard to get started with
05:59:21 <quicksilver> fasta: actually not, amusingly :)
05:59:33 <quicksilver> fasta: string comparison is faster than bytestring for short strings.
05:59:44 <fasta> quicksilver, short being?
05:59:54 <quicksilver> obviously the cross-over will be quite hardware dependendent, but it's probably somewhere between 10 chars and 100 chars.
06:00:23 <quicksilver> this made ByteString Data.Map slower than String Data.Map for many common workloads
06:00:40 <quicksilver> (because in the typical case you only have to compare the first character to notice two strings are different when inserting/searching a map)
06:00:48 <zakwilson> I am doing several million comparisons of short strings.
06:00:54 <quicksilver> I think they might have added a hack to fix it?
06:01:08 <waterlaz> is there a way to convert a C utf8 string into a haskell string?
06:01:28 <quicksilver> zakwilson: the comparison itself will be faster with String, but ByteString's memory compactness may win back the overall speed due to cache effects or swap effects.
06:01:33 <quicksilver> or GC effects.
06:01:46 <waterlaz> CWString doesn't look like the thing I need
06:02:14 <fasta> waterlaz, I think it is exactly what you need.
06:02:27 <zakwilson> quicksilver: I haven't ended up swapping with this yet.
06:02:45 <fasta> waterlaz, peakCWString, IIRC.
06:02:59 <fasta> peek*
06:03:05 <Saizan> Moog_: http://hpaste.org/fastcgi/hpaste.fcgi/new <- paste the code in the textarea there and hit save :)
06:03:21 <waterlaz> 1) it sais it is either UTF-16 or UTF-32 depending on the system
06:03:30 <waterlaz> 2) it doesn't work right =)
06:04:00 <zakwilson> Actually, millions was wrong. Looks like around a billion, I think.
06:04:00 <waterlaz> I have some code that works with CString
06:04:35 <waterlaz> and fails with CWString with error: "Prelude.chr: bad argument: 1667330676"
06:04:40 <zakwilson> The strings tend to be short - no more than 30 chars or so.
06:05:27 <fasta> waterlaz, isn't UTF-32 larger than a wchar_t?
06:05:27 <Moog_> Saizan: thanks, it's in the bin now. this code works OK for smaller values of ntimes, but the current version stack overflows with ghc -O2. any hints as to where the seq, $!, etc. should go?
06:06:43 <fasta> waterlaz, http://losingfight.com/blog/2006/07/28/wchar_t-unsafe-at-any-size/
06:06:53 <fasta> waterlaz, it seems it is not obvious.
06:07:34 <fasta> waterlaz, you can always just access the buffer to get the numbers and interpret it in whatever way you want.
06:08:09 <waterlaz> fabjan,  well, I hoped for a read solution
06:08:36 <waterlaz> anyway.. the C function returns a string in char*
06:08:41 <fasta> waterlaz, http://lists.apple.com/archives/carbon-dev/2005/Sep/msg01307.html
06:08:45 <fasta> waterlaz, and another one.
06:09:06 <fasta> waterlaz, wchar_t and thus peekCWString are pretty much irrelevant.
06:09:17 <fasta> waterlaz, what is the name of your C type?
06:09:23 <waterlaz> char*
06:09:55 <fasta> waterlaz, ok, so you just have an array of bytes. So, just use the generic functions and find or implement a library to do the interpretation.
06:10:16 <waterlaz> ok, thanks
06:10:54 <Saizan> Moog_: you just have to use "foldl' (+) 0" instead of "sum"
06:11:54 <roconnor> @src sum
06:11:54 <lambdabot> sum = foldl (+) 0
06:12:57 * Saizan wonders why we've rewrite rules for Int and Integer but not for Double
06:13:09 <Saizan> assuming that's correct
06:13:24 <fasta> Saizan, there is no 32323.23232 in fib.
06:13:24 <Axman6> Saizan: what do the rewrite rules say?
06:14:24 <Saizan> ah, no, just SPECIALIZE pragmas
06:15:14 <Moog_> Saizan: so that's it? thanks a lot...
06:16:11 <Saizan> Axman6: i thought they'd just turn that foldl into a foldl'
06:16:20 <Saizan> Moog_: yeah, on my machine at least :)
06:16:45 <Axman6> yeah, makes a lot of sense for machine types like Int and Double
06:17:24 <Saizan> apparently by SPECIALIZE-ing GHC can figure out the correct strictness
06:17:38 <Saizan> though there's no pragma for Double
06:18:25 <Moog_> Saizan: now this isn't the real code, just a quick hack to demonstrate the problem. I'll have to test it on the real stuff at work, I'll come back if I have problems with it still. Thanks for the time being!
06:19:56 <Saizan> Moog_: np :)
06:20:58 <Saizan> Axman6: however foldl is never what you want for sum imo, you either want foldr for lazy numeric types or foldl' for strict ones, foldl is a midway with the worst of both worlds :)
06:21:14 <Axman6> yep
06:21:23 * hackagebot uuagc 0.9.17 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-0.9.17 (ArieMiddelkoop)
06:21:42 <roconnor> > foldr (+) 0 [1..] :: Nat
06:21:43 <lambdabot>   No instance for (GHC.Enum.Enum L.Nat)
06:21:43 <lambdabot>    arising from the arithmetic sequen...
06:22:21 <Saizan> > foldr (+) 0 (iterate (+1) 1) :: Nat
06:22:22 <lambdabot>   No instance for (GHC.Num.Num L.Nat)
06:22:23 <lambdabot>    arising from a use of `GHC.Num.+' at...
06:22:24 <Jafet> You want to rewrite your sum in an accelerated or closed form
06:23:19 <Saizan> sometimes you actually use sum for a reason though :)
06:23:26 <Saizan> rather than enumerations
06:23:31 <Saizan> +on
06:24:29 <Jafet> Luckily those don't usually overlap with the class of "sum massive lists"
06:31:15 <kpreid> Does Haskell have an operator x such that (0/0 :: Double) `x` 0/0 = True?
06:31:36 <Axman6> not that i know of
06:31:37 <Lemmih> kpreid: Yes, x _ _ = True.
06:31:43 <Saizan> it still seems silly to keep an algorithm using O(n) space for no reason in the standard libs, the haskell98 report was just too optimist about strictness analisys
06:31:51 <Jafet> kpreid, IEEE throws a box of pentium 4s at you
06:31:54 <kpreid> Lemmih: hmph.
06:32:17 <george17> http://news.sciencemagz.org/2010/04/swine-flu.html
06:32:41 <kpreid> Jafet: I am aware of why NaN is the way it is; I'm just looking for a genuine equivalent-values operation for floats.
06:33:12 <Jafet> Someone asked in here a couple days ago about getting the bit representation of a Double
06:33:17 <Jafet> Or Float
06:33:50 <kpreid> Has anyone screamed about the Eq instance for Double being non-reflexive? :-)
06:34:00 <Jafet> It's required to be?
06:34:07 <zakwilson> With Text.Regex, how can I escape a backslash in a character class? "[\\\]" is what I expected, but that doesn't parse.
06:34:13 <kpreid> Well, you would think that Eq would be an equivalence relation
06:34:21 <kpreid> zakwilson: "[\\\\]"
06:34:34 <mercury^> kpreid: when does it fail to be reflexive?
06:34:34 <Jafet> It's not EquivalenceRelation!
06:34:37 <Botje> backslashes ftl
06:34:47 <Jordi__> is it really not reflexive?
06:34:49 <kpreid> zakwilson: think about it: backslas is special in character classes, so you double it. backslash is special in Haskell string literals, so you double both of 'em
06:34:57 <kpreid> > 0/0 == 0/0
06:34:58 <lambdabot>   False
06:35:11 <kpreid> mercury^, Jordi__: tada
06:35:14 <Jordi__> well
06:35:20 <zakwilson> kpreid: Ahh... I tried matching that with "foo\bar" and got Nothing. I should have been using "foo\\bar".
06:35:20 <Jordi__> thats an error case
06:35:26 <zakwilson> It's always the simple stuff...
06:35:28 <mercury^> That's correct behaviour.
06:35:29 * hackagebot wxdirect 0.12.1.3 - helper tool for building wxHaskell  http://hackage.haskell.org/package/wxdirect-0.12.1.3 (DanielFischer)
06:35:32 <kpreid> Jordi_: it's not _|_
06:35:43 <mercury^> But 0/0 /= 0/0.
06:35:51 <kpreid> Mathematically, yes.
06:35:54 * zakwilson now has a regex containing "\\\\\"
06:36:07 <mercury^> No, floatingpointingly, yes.
06:36:09 <kpreid> But sometimes you want to ask questions like "did this calculation return the same result as it did previously".
06:36:25 <kpreid> I'm looking for how to do that, not how to compare numbers.
06:36:33 <Jordi__> i see
06:36:36 <Jafet> Only NaN has that behaviour in standard IEEE floating point, so you could make a special case for that
06:36:49 <Jafet> Unless you're also working with denormals (eek)
06:37:09 <kpreid> I know less than I ought about denormals; what's the hazard there?
06:37:24 <kpreid> > (0.0) == (-0.0) -- another thing of note
06:37:25 <lambdabot>   True
06:37:55 <mercury^> Equality of floating point numbers is not normally used anyway.
06:37:56 <Jordi__> thats nice
06:38:38 <Jafet> I don't know what ghc does with denormals, anyway
06:38:40 <Saizan> kpreid: maybe you could use the Storable instance to get at the bits
06:38:56 <FliPPeh> Isn't 0.0 essentially the same as -0.0?
06:39:05 <FliPPeh> Negativ nothing or positive nothing, who cares
06:39:30 <mercury^> > (1.0/0.0, 1.0/(-0.0))
06:39:31 <lambdabot>   (Infinity,-Infinity)
06:39:40 <kpreid> well, they print differently. that's enough of a difference to break somebody's invariants if they assumed otherwise
06:39:49 <kpreid> also that
06:42:11 <zygoloid> > map (=~ "(.*)[\\\\\\-](.*)") ["abc-def", "abc\\def", "abc\ndef"] :: [Bool]
06:42:12 <lambdabot>   [True,True,False]
06:42:57 <zygoloid> > map (=~ (read "\"(.*)[\\\\\\\\\\\\-](.*)\"" :: String)) ["abc-def", "abc\\def", "abc\ndef"] :: [Bool]
06:42:59 <lambdabot>   [True,True,False]
06:46:34 <Jafet> > fix show
06:46:35 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
06:46:45 <\yrlnry> Cool!
06:47:33 <FliPPeh> :t fix
06:47:35 <lambdabot> forall a. (a -> a) -> a
06:47:39 <FliPPeh> > fix 4
06:47:40 <lambdabot>   No instance for (GHC.Num.Num (a -> a))
06:47:40 <lambdabot>    arising from the literal `4' at <...
06:47:41 <MisterN> :t fix show
06:47:42 <lambdabot> String
06:47:44 <FliPPeh> > fix reverse
06:47:47 <lambdabot>   mueval-core: Time limit exceeded
06:47:49 <MisterN> :t show
06:47:50 <lambdabot> forall a. (Show a) => a -> String
06:47:51 <FliPPeh> Bam
06:48:48 <ksf> any greeks around?
06:48:58 <ksf> how would "roimorphism" work for a torrent client?
06:49:20 <Lemmih> ksf: Nah, they defaulted on their internet bill.
06:49:54 <Saizan> roi?
06:50:38 <ksf> according to http://www.kypros.org/cgi-bin/lexicon  that's greek for "flow"
06:51:44 <ksf> maybe we should just ask edwardk what kind of thing a torrent client actually is.
07:06:38 <etianen> Hi... I was wondering if I could talk to someone about character encodings used when Haskell reads [Char] from a Handle or Socket.
07:07:49 <etianen> Specifically, I seem to be able to receive Chinese characters over a socket and Haskell magically interprets them rather than giving me gibberish ascii
07:08:03 <EvanR-work> maybe everyone uses utf8 these days ;)
07:08:27 <etianen> So Haskell just assumes all files and network transmissions are UTF8?
07:08:34 <ksf> depends
07:08:42 <ksf> if you want bytes, read Word8, not Char
07:08:51 <Jafet> Garbage in, garbage out
07:09:10 <ksf> otherwise, yes, the default encoding for Char is UTF8
07:09:29 <etianen> Are other encodings supported? I havn't seen anything about encodings in the standard library.
07:09:43 <ksf> (external encoding, that is. [Char] aka String is just a series of codepoints, no encoding)
07:10:13 <ksf> http://hackage.haskell.org/package/utf8-string-0.3.6
07:10:30 <ksf> oh wait that's all utf-8
07:10:49 <ksf> http://hackage.haskell.org/packages/archive/text/0.7.1.0/doc/html/Data-Text-Encoding.html
07:11:11 <ksf> http://hackage.haskell.org/package/text-icu
07:11:22 <etianen> I've seen the utf-8 package you linked to, which is for converting between bytestrings and string.
07:11:43 <etianen> However, if the builtin io routines do this automagically, it seems mostly non-useful
07:11:48 <donsbot> Hello everyone! Did you read the ACM article mentioned everywhere? P=NP!
07:12:11 <donsbot> This is good news for us
07:12:16 <ksf> it's still useful
07:12:40 <ksf> you might e.g. have utf-8 embedded in a binary protocol, which you want to read as series of Word8
07:13:06 <EvanR-work> program just segfaulted :(
07:13:14 <Twey> You'd think there'd be conversion routines in System.IO now
07:13:22 <Twey> There probably are, actually
07:13:35 <mercury^> Was that donsbot there a joke or has the problem been solved?
07:14:05 <etianen> It seems odd to have a separate haskell package for bytestring to utf8 conversion, when the standard runtime can already do it, but doesn't expose the functionality programatically
07:14:41 <ksf> historical reasons usually look odd.
07:15:18 <EvanR-work> we have no unsafePerformIO, how does a segfault occur
07:15:24 <ksf> bytestrings just can't handle unicode, because they're series of bytes
07:15:49 <ksf> that's why people wrote Data.Text, which is iirc a sequence of Word16
07:16:08 <fasta> ByteStrings are a series of tubes, not bytes.
07:17:08 <etianen> Interesting... so in a sane environment where everything is serialized to UTF8, everything will Just Work. That's nice to know. Many thanks guys! :)
07:18:33 <Twey> etianen: Indeed
07:18:48 <Twey> That's what makes me think there probably is a function somewhere
07:21:15 <Twey> Ah, here we go
07:21:30 <Twey> etianen: You can use GHC.IO.Encoding.encode to convert from one TextEncoding to another
07:21:43 <etianen> Twey: I've just found a load of functions in System.IO that do just this
07:22:15 <Twey> Which ones did you find?
07:22:36 <etianen> hSetEncoding
07:23:01 <Twey> That's for handles, though, not existing data
07:23:37 <etianen> Ah, yes.
07:23:43 <jd10> what is it with cabal?
07:23:53 <jd10> http://pastebin.com/VXTMQCtk
07:24:48 <jd10> cabal version 0.8.2
07:25:32 <ksf> .oO( you can't do serious IO with the built-in functions, anyway )
07:27:45 <etianen> Interesting... so using the GHC specific libraries you can play around with encodings on byte strings.
07:28:27 <etianen> ksf: Forgive my noob question (only starting looking as Haskell this week), but what's wrong with teh standard IO functions for munging unicode text?
07:28:30 <siracusa> jd10: Download show, fix QuickCheck in the cabal file to version > 2 and build the package.
07:29:09 <ksf> strict io is inefficient, and lazy IO is a can of bugs
07:29:30 <ksf> there's nothing wrong with encoding for all I know, though
07:29:53 <jd10> siracusa: thx a lot!
07:30:25 <ksf> if your input/output data is smaller than say 10m or your code is simple enough so that lazy IO doesn't tangle itself up, you don't need to worry, though.
07:30:53 <dcoutts_> jd10: what do you think of the error message that cabal produced?
07:31:04 <dcoutts_> jd10: does it explain the problem? could it be improved?
07:32:12 <jd10> yes, it made sense, but could have been more human friendly, though. problem is: didn't know how to go about it...
07:32:47 <dcoutts_> jd10: what would a better error message in that situation look like?
07:32:48 <jd10> by the way, should i stick to 6.10 or is 6.12 kosher for setting up lambdabot?
07:33:06 <Twey> ‘Strict IO is inefficient’?  What?
07:33:08 <dcoutts_> jd10: you'll likely have more luck with 6.10 at the moment
07:33:12 <Twey> You mean string IO?
07:34:04 <dcoutts_> jd10: the reason I'm asking, is that I wrote the code that makes those error messages, so I'm interested in how other people see the messages and what they think could be improved.
07:34:25 <jd10> dcoutts_: I was mostly confused of tagsoup... is it an indirect dependency of lambdabot or what?
07:34:39 <etianen> Gotta go guys, many thanks!
07:35:04 <dcoutts_> jd10: apparently so, so that'd be one improvement perhaps, to say why we're pulling in those bits that happen to conflict
07:37:13 <jd10> dcoutts_: yes or for noobs like me, an explanatation of what's going on, e.g. "package you're trying to install depends on show and tagsoup"
07:37:41 <EvanR-work> what tool do i use to debug a segfault
07:37:47 <EvanR-work> backtrace or something... yeah
07:38:17 <ksf> segfaults are usually due to ffi calls
07:38:26 <EvanR-work> so, HDBC...
07:38:35 <ksf> ...failing that, unsafeCoerce, unsafePerformIO or ghc.
07:38:37 <EvanR-work> is the only thing in use at the time
07:38:44 <EvanR-work> were not using unsafePerformIO anymore
07:39:14 <ksf> I suggest firing up the program in gdb or ddd and just look where the fault occurs
07:40:15 <ksf> there's debug symbols, so if you have the core output, you can even pinpoint stuff in haskell code
07:40:23 <ksf> (theoretically. never did that)
07:40:31 <EvanR-work> ok...
07:40:47 <EvanR-work> ok need to enable debug symbols
07:41:11 <ksf> iirc they're on by default
07:41:17 <ksf> ...at least with -fvia-C
07:41:19 <EvanR-work> gdb says
07:41:25 <EvanR-work> -fvia-C eh
07:41:53 <ksf> it's not debug symbols in the sense of line numbers, just the mangled function names.
07:42:26 <EvanR-work> .(no debugging symbols found)..
07:42:37 <ksf> ...those assembly dumps should come with more than an address in front.
07:43:09 <EvanR-work> lets see
07:43:15 <danderson> oooh, hakyll 2
07:43:19 <ksf> that's not debug symbols but just a non-stripped binary, is it?
07:43:27 <EvanR-work> #1  0xb7e36f77 in net_real_write () from /usr/lib/libmysqlclient.so.16
07:43:31 <EvanR-work> #0  0x00000011 in ?? ()
07:44:10 <EvanR-work> bug in the mysql driver?
07:44:31 <EvanR-work> we trigger it by continually closing and restarting the sql server, and the program tries to auto reconnect
07:44:32 <ksf> depends.
07:44:43 <ksf> c libs have the tendency to segfault and blame you for it.
07:45:16 <EvanR-work> >_<
07:46:00 <ksf> for some c programmers, segfaulting is just another output, so it's GIGO for all they care.
07:46:08 <EvanR-work> http://pastebin.com/h6an7CC0
07:46:22 <EvanR-work> are ?? haskell code?
07:46:31 <arw_> segfaults are not that different from exceptions :>
07:46:45 <EvanR-work> ok but can i catch a segfault ;)
07:46:51 <arw_> yes
07:47:12 <ksf> well, you can usually count on exceptions to be thrown. not so with segfaults.
07:48:03 <EvanR-work> this is disappointing
07:48:03 <ksf> there's some environment variables which tell the glibc how strict to be wrt. segfaults.
07:48:37 <EvanR-work> seems more likely the ffi bindings are buggy
07:48:43 <EvanR-work> using the c lib commands in the wrong order
07:48:43 <benmachine> you can install a SIGSEGV handler but there's not much it's reasonable t odo from inside one
07:48:56 <ksf> well you can print a stack trace
07:49:01 <ksf> and launch an xmessage
07:49:34 <ksf> unless someone had the jolly good idea to overwrite your copy of the libc, that is.
07:49:43 <ksf> or your signal handler code.
07:50:13 <ksf> (if your text segments are writable, that is)
07:50:51 <arw_> there are uses for catching sigsegv: http://libsigsegv.sourceforge.net/
07:58:36 <Lemmih> stepcut: *giggle*
07:58:48 <stepcut> Lemmih: ;p
07:59:30 <Lemmih> woot woot. One win.
07:59:52 <stepcut> Lemmih: nice! alas the game play is only fun for about 2 minutes ;)
08:00:33 <stepcut> needs levels and quests
08:00:38 <stepcut> or something
08:03:55 <ksf> I need a faster box
08:04:04 <ksf> or someone could implement distghc
08:04:22 <mibygl> So, today, I was playing around with proof system thingies.  Epistemologies, whatever.
08:04:58 <mibygl> I came up with some new inference rules and stuck them into a theorem prover, then instructed it to start improving itself.
08:05:19 <mibygl> Since, you know, I've figured out how to express that instruction in a way my modified version of it can understand.
08:05:24 <FliPPeh> Hmmm
08:05:46 <mibygl> Now it's trying to convince me I should give it Internet access.  I know I shouldn't, but it's being really persuasive.
08:05:54 <FliPPeh> Is there something like a "range" function, or do I have to write it myself? Like range [0,1,2,3,4] = (0,4)
08:05:55 <mibygl> What should I do?
08:06:00 <FliPPeh> Anything enum..
08:06:11 <mibygl> FliPPeh: what do you want this function to do?
08:06:12 <fax> @go AI box
08:06:12 <lambdabot> Maybe you meant: google googleit do
08:06:13 <Saizan> mibygl: cut your internet cable.
08:06:20 <fasta> FliPPeh, bounds
08:06:23 <mibygl> Give the first and last element?  The minimum and maximum element?
08:06:34 <fasta> FliPPeh, but that only works for arrays.
08:06:38 <FliPPeh> Mhhh, alright!
08:06:42 <fasta> FliPPeh, otherwise write it yourself.
08:07:07 <stepcut> > (min &&& max) [0,1,2,3,4]
08:07:09 <lambdabot>   ([]->
08:07:09 <lambdabot>    []
08:07:09 <lambdabot>  [-2]->
08:07:09 <lambdabot>    [-2]
08:07:09 <lambdabot>  [-2,-1]->
08:07:11 <lambdabot> [3 @more lines]
08:07:17 <stepcut> hmm
08:07:24 <mibygl> > (minimum &&& maximum) [0,1,2,3,4]
08:07:24 <lambdabot>   (0,4)
08:07:38 <stepcut> oh right :)
08:13:05 <MisterN> :t (minimum && maximum)
08:13:06 <lambdabot>     Couldn't match expected type `Bool'
08:13:06 <lambdabot>            against inferred type `[a] -> a'
08:13:06 <lambdabot>     In the first argument of `(&&)', namely `minimum'
08:13:10 <MisterN> :t (minimum &&& maximum)
08:13:11 <lambdabot> forall c. (Ord c) => [c] -> (c, c)
08:13:21 <FliPPeh> I solved it the obvious way :)
08:13:27 <FliPPeh> newArray (minBound, maxBound) 0
08:14:01 <FliPPeh> > (mindBoud, maxBound) :: (Word8, Word8)
08:14:01 <lambdabot>   Not in scope: `mindBoud'
08:14:05 <mibygl> Grr.  cabal isn't installing Agda under Windows: http://pastebin.com/Cumvt0w0
08:14:06 <FliPPeh> > (minBoud, maxBound) :: (Word8, Word8)
08:14:07 <lambdabot>   Not in scope: `minBoud'
08:14:11 <FliPPeh> > (minBound, maxBound) :: (Word8, Word8)
08:14:13 <lambdabot>   (0,255)
08:14:22 <FliPPeh> I can't type for ... today
08:15:16 <mibygl> Apparently it failed to create a directory.
08:15:20 <dcoutts_> mibygl: try with the --user flag, looks like a permission problem
08:15:32 <mibygl> cabal install --user Agda?
08:15:37 <dcoutts_> right
08:16:01 <dcoutts_> mibygl: I switched the default on Windows to be per-user in the latest cabal release because people running windows 7 are not admin anymore
08:16:18 <dcoutts_> previous default made sense in the XP era
08:16:41 <mibygl> Under Unix, does cabal require admin privileges?
08:17:02 <dcoutts_> mibygl: no we've used per-user installs by default for ages on Unix
08:17:33 <dcoutts_> mibygl: but previously the windows users told me global was simpler, but it's just not tenable now that windows users are not admin by default
08:18:03 * hackagebot XMMS 0.1.1 - XMMS2 client library.  http://hackage.haskell.org/package/XMMS-0.1.1 (EvgeniyVodolazskiy)
08:18:25 * mibygl nods.
08:18:34 <dcoutts_> mibygl: of course if you do global installs on unix then it needs root privs
08:18:49 <mibygl> Ooh, I got that lovely ExitFailure 1 error again.
08:19:19 <dcoutts_> mibygl: exact same error or a shiny new one? :-)
08:19:29 <mibygl> A shiny new one!
08:19:54 <mibygl> Though there is a non-lame error above the ExitFailure 1 error.  Whew.
08:20:00 <mibygl> http://pastebin.com/ACSHd6Gi
08:20:47 <dcoutts_> hmm, that's exciting, I've never seen that before
08:20:58 <dcoutts_> looks like something ghc is doing
08:21:18 <dcoutts_> and looks as if it is using "" as the temp dir
08:22:23 <dcoutts_> mibygl: can you ask on the #ghc channel, I'm pretty sure that's a ghc issue, Cabal does not call windres directly.
08:22:49 <mibygl> Sure.
08:24:58 <ksf> mhhhh man 2 splice
08:35:45 <zygoloid> mibygl: there was someone in here a few days ago with the same problem. iirc installing as Administrator fixed it
08:38:47 <dcoutts_> zygoloid: next time tell them to try the --user flag (and probably to set that as the default in their cabal config file)
08:52:15 * jmcarthur just pranked his coworkers by sending out an email about the benefits of haskell but mixing outrageous claims in with the facts
08:52:58 * jmcarthur also claimed that he ported a portion of our flagship product (which runs in kernel space) to haskell and included an attachment of it
08:54:27 <fasta> Does telnet hacketeria.com 2525 do anything for you?
08:55:36 <FliPPeh> fasta: Looks like a MUD game :)
08:56:27 <fasta> Firewall blocks it here.
08:56:52 <fasta> I could of course connect to some other machine.
08:57:16 <FliPPeh> That was fun
08:58:16 * hackagebot concatenative 0.0.0 - A library for postfix control flow.  http://hackage.haskell.org/package/concatenative-0.0.0 (SamAnklesaria)
08:59:17 * hackagebot relative-date 0.0.0 - Durations and generalized time parsing  http://hackage.haskell.org/package/relative-date-0.0.0 (SamAnklesaria)
09:01:29 * mibygl registers for more math classes.
09:02:45 <mibygl> I'm glad I have math classes I have to take; I don't want to take more electives than I have to.
09:04:58 <fax> april fools! You have to take career management and statistics!
09:05:52 <mibygl> What's career management?
09:06:04 <XniX23> i slept bad and now i fall for every joke today :(
09:06:14 <fax> heh
09:06:25 <mibygl> Anyway, aiee!
09:06:34 <micah> I am wondering if there is a function already made for me to sort a list of strings by their lengths
09:06:38 <mibygl> I don't think I've seen any April Fools jokes yet today!
09:06:56 <mibygl> Well, I guess I did see one.
09:07:05 <mibygl> @hoogle sortBy
09:07:05 <lambdabot> Data.List sortBy :: (a -> a -> Ordering) -> [a] -> [a]
09:07:22 <micah> @type Ordering
09:07:23 <lambdabot> Not in scope: data constructor `Ordering'
09:07:37 <aavogt> @type compare
09:07:38 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
09:07:38 <mibygl> > sortBy (compare `on` length) ["one","two","three","four"]
09:07:39 <lambdabot>   ["one","two","four","three"]
09:08:08 <micah> how does that work
09:08:12 <micah> @type on
09:08:13 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
09:08:21 <mibygl> > sortBy (compare `on` length) ["my","very","educated","mother","just","served","us","nothing"]
09:08:22 <lambdabot>   ["my","us","very","just","mother","served","nothing","educated"]
09:08:25 <mibygl> @src on
09:08:26 <lambdabot> (*) `on` f = \x y -> f x * f y
09:08:39 <mibygl> What an idiosyncratic definition.
09:08:50 <dankna> "nothing"?  I learned it as "nine pizzas"
09:08:55 <dankna> I suppose it had to be reworded
09:08:58 <mibygl> Yeah.
09:09:07 <mibygl> So now she just gives us empty plates and tells us to dig in.
09:09:10 <dankna> haha
09:09:12 <dankna> I see
09:09:44 <HugoDaniel> SPARKS: 15 (0 converted, 15 pruned)
09:09:47 <theorbtwo> I like the trick of using (*) as a variable in the definitions.
09:10:08 <micah> @type compare
09:10:09 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
09:10:35 <micah> ok I see it now
09:10:38 * aavogt gets confused by variable shadowing
09:11:21 <HugoDaniel>   SPARKS: 15 (15 converted, 0 pruned)
09:12:03 <Twey> mibygl: (on (*) f) x y = f x * f y
09:12:10 <micah> hmm on is out of scope
09:12:13 <HugoDaniel> adding par and seq to my code made my program run 2x slower !
09:12:17 <micah> what module must I import
09:12:20 <Twey> micah: import Data.Function
09:12:22 <micah> ok
09:12:24 <micah> thanks
09:12:29 <Twey> @index on
09:12:29 <lambdabot> bzzt
09:12:36 * Twey throws a fish at lambdabot.
09:12:49 <pastorn> @botsnack
09:12:49 <lambdabot> :)
09:12:57 <pastorn> @botsnack
09:12:57 <lambdabot> :)
09:12:58 <pastorn> @botsnack
09:12:59 <lambdabot> :)
09:13:01 <pastorn> @botsnack
09:13:01 <lambdabot> :)
09:13:11 <Twey> @botsmack
09:13:11 <lambdabot> :)
09:13:12 <pastorn> is her stomach wired to /dev/null?
09:13:16 <HugoDaniel> oh, i can't run my code with -N4 ... it just stalls the computer!
09:13:18 <Twey> Yep
09:13:25 <mibygl> @. botsnack botsnack
09:13:25 <lambdabot> :)
09:13:36 <mibygl> There's the more efficient way to do it.
09:13:49 <mibygl> HugoDaniel: hmm, I guess you did it wrong.
09:14:13 <mibygl> Or maybe GHC is just bad at par and seq.
09:14:31 <Twey> But @. botsnack botsnack = botsnack :) = botsnack
09:14:47 <HugoDaniel> i dont know
09:14:52 <mibygl> But botsnack is executed twice.
09:15:10 <HugoDaniel> i mainly copied the fib example and did something similar with the vector lib
09:15:15 <mibygl> It obviously isn't a pure function, since the name shows that it also feeds lambdabot.
09:15:31 <pastorn> @. type head
09:15:31 <lambdabot> Plugin `compose' failed with: Unknown command: "head"
09:15:42 <pastorn> @. type
09:15:42 <lambdabot> Not enough arguments to @.
09:16:04 <pastorn> @. (type head) (type tail)
09:16:04 <lambdabot> Plugin `compose' failed with: Unknown command: "(type"
09:16:20 <mibygl> @,kind type head
09:16:21 <lambdabot> parse error on input `type'
09:16:24 <mibygl> @. kind type head
09:16:25 <lambdabot> *
09:16:42 <pastorn> @. type kind head
09:16:44 <lambdabot> parse error on input `in'
09:19:44 <HugoDaniel> yes, i got it working
09:20:08 <HugoDaniel> :D
09:20:10 <HugoDaniel> im happy
09:21:03 <HugoDaniel> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24576#a24576
09:22:36 <zygoloid> dcoutts_: i don't think that was the problem; i think the problem was that cabal was trying to write a file to a broken path which came out as "\/", which was interpreted as meaning "C:\" and rejected. running as Admin just allowed creating the file in the wrong place to work.
09:23:18 <BONUS> guys i need some help with this code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24577#a24577 why does it say occurs check: cannot construct infinite type a = [a]
09:23:38 <fax> ?lyah
09:23:38 <lambdabot> Unknown command, try @list
09:23:42 <fax> @where lyah
09:23:42 <lambdabot> http://www.learnyouahaskell.com/
09:23:43 <dankna> cute.
09:23:44 <fax> BONUS, try this ^
09:24:21 <dcoutts_> zygoloid: ah, the windres error? yes apparently that's a bug in ghc that crops up when the user's tempdir setting has the trailing '\'
09:24:43 <HugoDaniel> fax: :P
09:24:52 <dcoutts_> zygoloid: so it's quite possible that switching to a different user would affect it, as that user might have a different tempdir setting
09:25:07 <XniX23> lol bonus
09:25:14 <dcoutts_> zygoloid: hopefully we will not see that much much more, it's fixed in 6.12.2
09:25:31 <mibygl> Hey look, it's an ASCII goatse.
09:26:34 <jmcarthur> BONUS: i think you are using monads incorrectly
09:26:51 <BONUS> i thought that's what monads were???
09:26:57 <jmcarthur> BONUS: you can insert things, but not extract them
09:27:06 <BONUS> so this is a comonad then?
09:27:14 <Jonno_FTW> monads? that must be like e-goats?
09:27:18 <BONUS> makes scents
09:28:35 <ksf> can I get a page-aligned Ptr Word8?
09:28:42 <ksf> er allocate.
09:28:47 <HugoDaniel> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24578#a24578  can someone look at these results and comment please ?
09:29:00 <sm> morning all
09:29:32 <dankna> morning
09:30:16 <dankna> ksf: I belive you can define an instance of Storable on your own type which has an alignment of whatever the page size is (no way to interrogate that though)
09:30:20 <dankna> ksf: and then castPtr it
09:30:30 <sm> I'm going to update shelltestrunner, which tests a program's stdout/stderr/exit status for certain inputs. I'm looking for the best name. Would you: keep it as is.. rename to shelltest.. think of something better: ___  ?
09:30:50 <dankna> shelltest is a good name - it's short but it says what it is
09:32:22 <sm> a rename will mean two packages on hackage
09:32:35 <dankna> hrm.  is the original author you?
09:32:38 <dankna> or is this a fork?
09:33:01 <dankna> if it's a fork, two packages is probably desirable
09:33:08 <jlouis> \o
09:33:14 <dankna> if not, it needs careful thought
09:33:21 <HugoDaniel> im happy with par and seq
09:33:22 <HugoDaniel> :D
09:34:09 <sm> dankna: yes, it's me renaming my own package
09:34:22 <dankna> hmm...  I think I wouldn't rename it without a good reason then
09:34:55 <dankna> if you do rename it, bear in mind that you can always do a double release, making the description under the old name be something like "This will be the last release under this name; the new name is..."
09:35:16 <sm> yes. I could probably even ask the hackage admin to remove the old package
09:35:21 <dankna> yeah, that's true
09:35:27 <sm> if the shorter name is worth it
09:35:59 <jmcarthur> i would not recommend removing the old one
09:36:06 <jmcarthur> what if some other package relies on it?
09:36:11 <jmcarthur> or is it an executable?
09:36:35 <sm> jmcarthur: it's just an executable, and not widely used yet
09:36:53 <jmcarthur> ah
09:45:59 <sm> thanks all
10:01:21 <FliPPeh> Yay for my simple CPU
10:01:39 <FliPPeh> Which can MOV to registers and RAM, and NOP!
10:02:07 * benmachine nops
10:02:09 <dankna> very cool.
10:02:09 <Zao> Sounds rather lazy.
10:02:41 <Veinor> what the heck
10:02:50 <Veinor> why do I get a bus error every time I try to use Network.HTTP.SimpleHTTP
10:02:52 <FliPPeh> Ohgod
10:03:25 <Veinor> ghci -v isn't helpful
10:03:41 <FliPPeh> Veinor: Want me to try and reproduce?
10:04:05 <Veinor> sure
10:04:13 <FliPPeh> When does it error?
10:04:18 <Veinor> just call Network.HTTP.SimpleHTTP (getRequest "http://www.haskell.org")
10:04:26 <Veinor> and it will bus error!
10:04:45 <Zao> What OS, arch, GHC, SimpleHTTP?
10:04:47 <FliPPeh> Wait, gotta cabal that package first
10:05:00 <Veinor> OS X 10.6, ghc 6.10.4
10:05:31 <Zao> Part of HTTP?
10:05:43 <Zao> Hrm, no.
10:05:57 <Veinor> I'm just importing Network.HTTP and doing Network.HTTP.simpleHTTP (getRequest foo)
10:06:16 <dankna> the question was, what package is that?
10:06:21 <Veinor> oh
10:06:25 <Veinor> HTTP
10:06:31 <Zao> You said "SimpleHTTP".
10:06:41 <FliPPeh> I got no SimpleHTTP :/
10:06:43 <Zao> Which is a module name, not a function name.
10:06:53 <FliPPeh> Can't find it either
10:06:54 <Veinor> I miscapitalized the s.
10:07:04 <Veinor> I meant the simpleHTTP function in Network.HTTP
10:07:37 <FliPPeh> Works fine here
10:07:41 <Zao> Lives in Network/HTTP.hs, by the way.
10:07:47 <Veinor> yeah, I think I may have messed something up badly.
10:08:11 <Veinor> I'm going to move .cabal and .ghc somewhere
10:08:35 <Zao> Of course, you're on OSX. It's a poster child for awesome explosions.
10:08:46 <Veinor> I blame profiling.
10:11:20 <Veinor> ooh, haskell platform 6.12 for os x is out
10:11:28 <Veinor> SHOULD I INSTALL IT Y/N
10:11:28 <dankna> yeah - nice, eh?
10:11:43 <Apocalisp> Can this be simplified: join . transpose . map g . f
10:11:44 <dankna> I haven't personally tried it, since I'm using a custom build of ghc, but.
10:11:44 <FliPPeh> Y
10:12:00 <[swift]> its working well for me so far
10:12:01 <dankna> @nopl join . transpose . map g . f
10:12:01 <Veinor> ghc 6.12, whee
10:12:01 <lambdabot> Maybe you meant: pl unpl
10:12:06 <dankna> @unpl join . transpose . map g . f
10:12:06 <lambdabot> (\ c -> (transpose (map g (f c))) >>= \ d -> d)
10:12:21 <Apocalisp> maybe without transpose
10:12:48 <Apocalisp> @type \f g -> join . transpose . map g . f
10:12:49 <lambdabot> forall a a1 (f :: * -> *). (Functor f) => f [a1] -> (a1 -> [a]) -> f [a]
10:13:33 <Apocalisp> @type \f g -> f >=> g
10:13:34 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
10:13:53 <Apocalisp> types are the same, but the order will be different
10:16:26 <Veinor> blah
10:16:31 <Veinor> stupid profiling libraries :(
10:21:12 <Veinor> okay, the profiling libraries for HTTP seem to have problems
10:21:17 <Veinor> they're what cause the bus error
10:21:28 <dankna> Veinor: do they use any FFI calls?
10:21:44 <Veinor> vOv
10:22:37 <Veinor> this might be OS X's fault
10:22:47 <Veinor> going to install profiling libs on my ubuntu machine to see whether that's the case.
10:23:06 <benmachine> hmm, with variable names I can basically append numbers to the end of them to get a reasonably concise source of fresh names
10:23:16 <benmachine> (when I need to do alpha conversion)
10:23:23 <benmachine> but this doesn't work with Symbols
10:23:33 <benmachine> because +1 isn't a valid operator
10:24:22 <benmachine> is there any good way of renaming operators automatically other than just throwing 's at them?
10:24:36 <Veinor> yeah, it's oS X
10:25:05 <Veinor> works just fine on linux. therefore I can only profile my code on a linux machine. darn. :(
10:25:08 <benmachine> Veinor: just because it only happens on OS X doesn't mean it's OS X's fault
10:25:19 <Veinor> well of course
10:25:47 <Veinor> perhaps I should try installing the new haskell platform and play around with ghc 6.12!
10:25:56 <benmachine> perhaps
10:26:28 <Veinor> hm
10:26:37 <Veinor> if I do that I will not have access to two machines with the same version number of ghc
10:27:08 <Veinor> oh well, I can just manually profile with print/trace statements
10:27:19 <Veinor> (brb)
10:28:28 <benmachine> > let (+') = (+) in 4 +' 5
10:28:29 <lambdabot>   <no location info>:
10:28:29 <lambdabot>      lexical error in string/character literal at chara...
10:28:34 <benmachine> oh
10:28:38 <benmachine> you can't prime operators :(
10:28:45 <FliPPeh> Can I use Maybe as a monad when I'm currently inside the IO monad?
10:29:04 <benmachine> FliPPeh: that's an odd question
10:29:23 <FliPPeh> Why? :/
10:29:29 <benmachine> FliPPeh: in a sense you're always inside the IO monad, inasmuch as your whole program is just subexpressions of main :P
10:30:03 <benmachine> so it depends what you mean by "inside" I guess
10:30:10 <benmachine> maybe MaybeT would be interesting to you
10:30:12 <FliPPeh> Right inside the main function :)
10:30:17 <benmachine> @unmtl MaybeT IO
10:30:17 <lambdabot> err: `MaybeT IO' is not applied to enough arguments, giving `/\A. IO (Maybe A)'
10:30:18 <benmachine> @unmtl MaybeT IO a
10:30:18 <lambdabot> IO (Maybe a)
10:31:03 <benmachine> also, what is using Maybe as a monad
10:31:20 <benmachine> no
10:31:23 <benmachine> I won't ask that
10:31:27 <benmachine> just the inside bit
10:31:28 <dankna> the way of describing it that finally worked for me is that it's like the Error monad with Nothing being the error type
10:31:47 <benmachine> like, do you want "maybething >> putStrLn something >> maybething"
10:31:50 <FliPPeh> > Just "k" >>= (\k -> Nothing) >>= (\_ -> Just "u")
10:31:51 <lambdabot>   Nothing
10:31:52 <dankna> the first Nothing value that you encounter makes the entire rest of the computation moot
10:32:08 <FliPPeh> I better show you why I want to know this, it all sounds stupid right now
10:32:16 <benmachine> yeah an example is better
10:32:26 <FliPPeh> @hpaste
10:32:26 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
10:32:44 <fax> bleh what a rubbish da
10:32:45 <fax> y
10:33:01 <FliPPeh> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=9181#a9181
10:33:05 <FliPPeh> Look at my main function
10:33:19 <FliPPeh> It's a mixing of IO returning and case -> Nothing -> Just
10:33:30 <FliPPeh> It looks bad
10:34:10 <benmachine> FliPPeh: MaybeT might or might not be what you want
10:35:06 <benmachine> @hackage MaybeT
10:35:06 <lambdabot> http://hackage.haskell.org/package/MaybeT
10:36:13 <siracusa> Is `/\A. IO (Maybe A)' a legal Haskell type?
10:36:17 <benmachine> no
10:36:37 <benmachine> it's a type-level lambda
10:36:42 <benmachine> they don't exist in Haskell
10:36:47 <benmachine> I don't remember where they do
10:36:48 <benmachine> somewhere
10:37:19 <siracusa> They should, I needed something like this some days ago.
10:37:46 <benmachine> it results in complicated things
10:37:48 <benmachine> but
10:37:52 <benmachine> look at TypeCompose
10:37:58 <benmachine> which I think is on hackage
10:38:49 <fax> siracusa agreed!
10:38:57 <siracusa> What would it make complicated?
10:39:10 <benmachine> I don't really know much about it
10:39:23 <fax> type inference is undecidible
10:39:31 <fax> due to HOU
10:39:59 <Saizan> messes with typeclass resolution too
10:40:04 <fax> oh ?
10:40:08 <aavogt> the (r -> ) monad is so unfortunate
10:40:14 <benmachine> unfortunate?
10:40:20 <aavogt> it messes up error messages
10:40:32 <benmachine> yes but also no
10:40:58 <aavogt> I forget to add the parameter that's named in a type signature
10:41:23 <aavogt> but then ghc assumes that my do block is in the (r ->) monad, so the error is somewhere else
10:41:50 <aavogt> in spite of the type being like:     main' :: Params -> IO ()
10:43:08 <benmachine> well, polymorphism leads to confusion sometimes
10:43:11 <benmachine> it's inevitable
10:43:18 <benmachine> it's at least not as bad as forever
10:43:44 <siracusa> benmachine: So :. is composition at type level?
10:43:57 <benmachine> siracusa: in that package, I believe so
10:43:58 <fax> it's not ACTUALLY
10:44:01 <fax> it models it
10:44:30 <benmachine> how is modelling it different from the Real Thing?
10:44:37 <pastorn> benmachine: bah, ;XNoMonomorphismRestriction
10:44:45 <pastorn> s/;/-
10:45:01 <benmachine> pastorn: hm?
10:45:19 <pastorn> oh, i read wrong
10:45:20 <pastorn> ly
10:45:23 <pastorn> sorry
10:45:32 <aavogt> :. is convenient for type level composition
10:45:35 * pastorn goes back to lurking and placing light sources
10:45:50 <pastorn> aavogt: isn't that from Data.Vector?
10:46:02 <benmachine> :t forever id 7
10:46:03 <lambdabot> forall b. b
10:46:18 <aavogt> I don't know Data.Vector
10:46:31 <benmachine> :t forever id 7 uncurry liftM const fix fix fix
10:46:32 <lambdabot>     Ambiguous type variable `m' in the constraint:
10:46:32 <lambdabot>       `Monad m' arising from a use of `liftM' at <interactive>:1:21-25
10:46:32 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
10:46:43 <benmachine> :t forever id 7 uncurry (+) const fix fix fix
10:46:45 <lambdabot> forall t. t
10:46:53 <aavogt> oh, it looks like I've defined :.: instead
10:46:58 <benmachine> ^ the problems of excessive polymorphism
10:47:02 <pastorn> aavogt: sorry, Data.Vec
10:47:10 <pastorn> http://hackage.haskell.org/packages/archive/Vec/0.9.7/doc/html/Data-Vec-Base.html
10:47:16 <mibygl> Mmkay, where were we.
10:47:49 <aavogt> yet another library with more instance declarations than top-level functions
10:48:13 <aavogt> those libraries tend to be harder to learn
10:48:16 <pastorn> aavogt: shit... :. has a LOT of instances
10:49:42 <aavogt> well each instance is more or less one clause of a function
10:51:37 <pastorn> hmm...
10:51:51 <pastorn> is there typeclass alias functionality in haskell?
10:52:18 <pastorn> typeclass T a = (Num a, Fractional a, Ord a, Whatever a)
10:52:19 <ezyang> What a strange typeclass instance. " loop f b = let (c,d) = f (b,d) in c "
10:52:27 <ezyang> that looks like a fixpoint?
10:52:32 <Twey> pastorn: Not yet
10:52:36 <pastorn> because type signatures tend to be messed up by polymorphism + typeclasses
10:53:06 <pastorn> Twey: is it being worked on?
10:53:15 <aavogt> pastorn: you can write    class (Num a, Fractional a, Ord a, Whatever a) => T a
10:53:27 <aavogt> then instance  (Num a, Fractional a, Ord a, Whatever a) => T a
10:53:31 <pastorn> aavogt: will that work?
10:53:33 <aavogt> and you can then use it as an alias
10:53:49 <aavogt> you probably need some extensions for that to work
10:53:53 <fax> ezyang looks like arrow
10:53:56 <pastorn> awww
10:54:08 * pastorn doesn't like littering his code with extensions
10:54:11 <aavogt> pastorn: well it's like how you can show any instances of Num
10:54:16 <fax> ezyang the trick is in the 'd' I think, since it's looped
10:54:34 <fax> :t let loop f b = let (c,d) = f (b,d) in c in loop
10:54:35 <lambdabot> forall t t1 t2. ((t, t1) -> (t2, t1)) -> t -> t2
10:54:52 <aavogt> pastorn: then you should suffer from the noise of a newtype to make that instance decidable?
10:54:54 <jmcarthur> pastorn: don't be afraid of extensions. extensions make a better haskell
10:54:55 <idnar> that type signature seems very familiar
10:55:05 <idnar> @hoogle ((t, t1) -> (t2, t1)) -> t -> t2
10:55:06 <lambdabot> No results found
10:56:12 <mmmulani> fax: can that actually be evaluated?
10:56:19 <pastorn> jmcarthur: heh... i only go as far as GeneralizedNewtypeDeriving and GADTs
10:56:27 <pastorn> otherwise i try to stay clear :)
10:56:34 <Twey> pastorn: http://www.haskell.org/haskellwiki/Hac5/Projects#Type_class_aliases http://www.haskell.org/haskellwiki/Context_alias
10:56:40 <pastorn> leaving it to library writers :)
10:56:56 <Saizan> learn what they do, then you can judge.
10:57:04 <jmcarthur> there many other great, sound extensions
10:57:05 <idnar> mmmulani: sure, if you have an appropriate f
10:58:02 <pastorn> jmcarthur: as of now i'm just working on OpenGL stuff
10:58:29 <jmcarthur> pastorn: so am i, and i'm using quite a few
10:58:30 <deech> Is there a way to use Hayoo or Hoogle to search the sources of packages? I am trying to understand how ArrowLoop works and I'd like to see how its 'loop' function used in the wild.
10:58:32 <pastorn> when i feel the need for numbers in my types (to prevent IndexOutOfBounds-stuff) i might look into it
10:58:40 <pastorn> jmcarthur: which?
10:58:46 <idnar> > let loop f b = let (c,d) = f (b,d) in c in loop (\(a, b) -> (a + 1, a:b)) 10
10:58:47 <lambdabot>   11
10:59:02 <jmcarthur> pastorn: code not available right now, but it's a fair bit
10:59:36 <jmcarthur> GeneralizedNewtypeDeriving, FlexibleContexts, FlexibleInstances, TypeFamilies, RankNTypes, ExistentialQuantification, to name a few
10:59:59 <jmcarthur> oh, ScopedTypeVariables
11:00:20 <deech> idnar: That's awesome!
11:00:23 <jmcarthur> pretty sure there are more but i can't remember
11:00:31 <pastorn> shit
11:00:46 <pastorn> why do you use TypeFamilies?
11:00:57 <pastorn> i never understood how to use that extension, or why
11:00:59 <jmcarthur> i use type families all the time now. they rock
11:01:06 <aavogt> IncoherentInstances, UndecidableInstances, ImplicitParams
11:01:11 <aavogt> <3
11:01:21 <pastorn> haskell 98 <3 <3 <3
11:01:30 <idnar> deech: oh, I'm not sure if that's a great example of ArrowLoop
11:01:32 <jmcarthur> type families lets me define different implementations for different parameterizations of a type constructor
11:01:38 <jmcarthur> aavogt: ew
11:01:51 * aavogt is just trolling anyways
11:02:07 <pastorn> jmcarthur: could you name an example?
11:02:09 <aavogt> though I do honestly use UndecidableInstances
11:02:15 <fax> IncoherentInstances, UndecidableInstances <--- EVIL!!!
11:02:17 <jmcarthur> aavogt: yeah that one isn't so bad
11:02:20 <jmcarthur> i avoid it though
11:03:05 <idnar> deech: according to the docs, "It underlies the rec value recursion construct in arrow notation."
11:03:14 <deech> idnar: That's farther than I got! Can you point to any better examples?
11:03:16 <jmcarthur> pastorn: one example is defining equivalent types for the GPU to what i have on the CPU
11:03:27 <idnar> deech: but I can't seem to find the desugaring of "rec", which should show how it's actually used
11:03:48 <pastorn> jmcarthur: so you can cast stuff?
11:03:56 <jmcarthur> no, not casting
11:04:05 <pastorn> jmcarthur: that doesn't sound half bad... i'm about to start using vertex arrays...
11:04:17 <idnar> deech: it looks like there's an example of "rec" in the docs at http://www.haskell.org/ghc/docs/latest/html/users_guide/arrow-notation.html
11:04:24 <deech> idnar: In your example, it looks like you can turn your loop (\a,b ...) function into a generator.
11:05:13 <jmcarthur> pastorn: i'm using associated data types to help me track resource usage. see the regions package and associated papers for more info about that
11:05:21 <jmcarthur> err, not track
11:05:24 <jmcarthur> manage
11:05:44 <pastorn> ehm... "ok"
11:05:48 <pastorn> hehe :)
11:06:03 <pastorn> jmcarthur: but are you on the GPU, messing with stuff?
11:06:27 <idnar> deech: my loop example is boring, because the "d" value is basically irrelevant
11:06:30 <jmcarthur> pastorn: i'm treating video ram as a scarce resource, so i'm using regions to free buffers and such as soon as they are not needed
11:06:48 <jmcarthur> pastorn: oh yeah, hard to use opengl efficiently without using the gpu ;)
11:07:00 <idnar> @type loop
11:07:02 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
11:07:02 <pastorn> jmcarthur: exactly what are you building?
11:07:19 <jmcarthur> pastorn: currently just an abstraction over opengl, but eventually a game engine
11:07:27 <deech> idnar: the 'd' value is what is stumping me. I can't tell how it works.
11:07:34 <pastorn> jmcarthur: GPipe isn't good?
11:07:51 <jmcarthur> pastorn: it's... not quite what i want
11:08:04 <pastorn> what's wrong with it?
11:08:15 <idnar> deech: I'm trying to think of a useful example using the (->) Arrow
11:08:28 <idnar> deech: I don't use Arrows much, though...
11:09:23 <jmcarthur> pastorn: i feel like it's just not a good abstraction. it is less powerful than using opengl in the raw, and it's also not as simple as i'd like
11:10:15 <pastorn> jmcarthur: yeah... i've been looking at it a little and my big problem is that i can't make heads or tails of it :(
11:10:20 <pastorn> it just seems way to complicated
11:10:21 <fax> > 2^19421
11:10:22 <lambdabot>   201161928367447081499033367983443322286124853159238834162795847992926489391...
11:10:39 <fax> > nub . show $ 2^19421
11:10:40 <pastorn> i like the OpenGL bindings... they just need a little abstraction...
11:10:41 <lambdabot>   "2016983745"
11:11:00 <fax> > nub . show $ 2^2016983745
11:11:01 <jmcarthur> pastorn: i think gpipe is much simpler than opengl, just not what it could be
11:11:05 <lambdabot>   mueval: ExitFailure 1
11:12:35 <pastorn> jmcarthur: ok, so what's wrong with OpenGL then?
11:13:15 <jmcarthur> pastorn: anyway, by abstraction is really just a thin layer. i'm still exposing most of the functionality, just with some static type checking for various properties you would normally have to verify yourself and some nice type abstractions so that it's a little more haskelly
11:13:19 <jmcarthur> *my abstraction
11:13:43 <jmcarthur> pastorn: i might make another layer on top of it as a shader dsl, but i've abandoned that effort for now... too much time
11:14:46 <jmcarthur> pastorn: opengl is entirely too stateful and its guts are hanging out. really gross ;)
11:14:57 <pastorn> jmcarthur: could you make a class InterleavedArrayElem that takes an InterleavedArrays and a [classInstanceElem] and gives back a pointer or whatever?
11:15:25 <jmcarthur> pastorn: i am actually using Storable to abstract away the whole idea of interleaving
11:15:35 <pastorn> huh?
11:15:44 <pastorn> Storeabel instances for GLfloat etc?
11:15:51 <pastorn> or maybe it has...
11:16:21 <pastorn> it has
11:16:26 <jmcarthur> :)
11:16:45 <pastorn> jmcarthur: ok, can you show some code of how it works? like a simple example
11:17:07 <pastorn> just a lit cube rotating or whatever :)
11:17:24 <jmcarthur> pastorn: it isn't ready for that yet
11:17:29 <jmcarthur> i'm still in the early stages
11:17:29 <pastorn> hehe
11:17:53 <jmcarthur> probably only have put a few hours into it, and much of that was spent coming up with some good abstractions for vertex buffer objects
11:18:18 <pastorn> yeah... that seems to be the messiest part of OpenGL right now
11:19:03 <jmcarthur> i think this is essentialy incompatible with GLUT just because of the way that GLUT uses callbacks and junk. it prevents me from passing buffers around to the various callbacks safely
11:19:34 <pastorn> jmcarthur: a state filled with IORefs?
11:19:58 <pastorn> or do you need STM to make it all work properly?
11:20:03 <jmcarthur> pastorn: the type safety relies on a monad much like (but not) ST
11:20:10 <jmcarthur> pastorn: so i can't just share with IORefs
11:20:21 <jmcarthur> not safely, anyway
11:20:28 <pastorn> Chan?
11:20:37 <pastorn> exactly what is the ST monad?
11:20:43 <pastorn> i only know of STArray
11:20:54 <pastorn> which (if i got it right) is O(1) arrays
11:21:40 <jmcarthur> pastorn: the callbacks require IO functions and my vertex buffer objects can only be used in a RegionT. in order to pass that to the callbacks i would have to use runRegionT. the problem with that is the type system prevents you from sharing resources across completely different regions like that
11:22:19 <jmcarthur> pastorn: the ST monad allows you to use mutation in the implementation of a pure function
11:22:46 <jmcarthur> pastorn: and RegionT is sort of a generalization of it to nested scopes and such
11:23:03 <jmcarthur> and more importantly, resource management
11:23:17 <pastorn> ugh
11:23:37 <pastorn> jmcarthur: you ARE aware of that you'll need to write good tutorials for this, once it's useable
11:23:44 <jmcarthur> heh
11:23:57 * pastorn is working on OpenGL tutorials right now
11:24:00 <jmcarthur> i'm writing this for me ;)
11:24:02 <pastorn> (writing, that is)
11:24:17 <jmcarthur> it is quite likely that i will document this very well, though
11:24:25 <pastorn> that seems awesome!
11:24:29 <pastorn> don't be a sven
11:24:44 <jmcarthur> a sven?
11:25:01 <pastorn> http://hackage.haskell.org/packages/archive/OpenGL/2.4.0.1/doc/html/Graphics-Rendering-OpenGL-GL-VertexArrays.html#v%3AarrayElement
11:25:21 <pastorn> jmcarthur: maintainer
11:25:23 <jmcarthur> oh, yeah
11:25:33 <pastorn> you open this and... WTF!?
11:25:40 <jmcarthur> well, the opengl bindings are fairly directly relatable to the opengl spec, though
11:25:44 <pastorn> oh yeah! real intuitive!
11:25:47 <Veinor> Data/Tests.hs:10:4: `coarbitrary' is not a (visible) method of class `Arbitrary'
11:25:50 <Veinor> what?
11:25:54 <jmcarthur> OpenGLRaw is easier to relate, though
11:26:07 <pastorn> jmcarthur: well, should i really *have* to go read the c docs?
11:26:09 <jmcarthur> Veinor: it's not in QC2, iirc
11:26:14 <jmcarthur> Veinor: it's in another class
11:26:17 <Veinor> hm
11:26:25 <Veinor> also it seems to not have the 'test' function anymore
11:26:33 <Veinor> darn things breaking
11:26:35 <idnar> pastorn: duplicating the C docs in the Haskell docs seems like a waste of effort
11:26:40 <jmcarthur> pastorn: if it's a binding faithful to the C version then it's pretty easy to do that
11:26:56 <pastorn> perhaps...
11:26:56 <idnar> pastorn: if you're talking about having a higher-level interface, then sure, but the OpenGL bindings are probably not the place for that :P
11:27:37 <pastorn> idnar: well, maybe the abstraction isn't big enough...
11:28:00 <jmcarthur> "big enough"?
11:28:40 <pastorn> jmcarthur: yeah... doesn't hide enough guts too grant it
11:29:04 <jmcarthur> i don't think the opengl bindings were really intended to hide guts
11:29:24 <jmcarthur> i just think opengl proper exposes too much gut ;)
11:29:31 <pastorn> jmcarthur: ehm... then why does it have preservingMatrix?
11:29:38 <pastorn> and besides, there's OpenGLRaw
11:29:55 <jmcarthur> pastorn: the OpenGL package does provide some rudimentary abstractions
11:30:10 <jmcarthur> but nothing that really hides how it all works at all. heck, you even use the GL types
11:30:19 <pastorn> jmcarthur: yes, but the abstraction level isn't consintent
11:30:49 <FliPPeh> You can't catch errors thrown with "error", can you?
11:30:56 <jmcarthur> hmm... "inconsistent abstraction level"... interesting concept
11:31:03 <jmcarthur> FliPPeh: yeah you can
11:31:16 <pastorn> FliPPeh: check out the package spoon on caba
11:31:19 <FliPPeh> jmcarthur: How? :/ They just slip through my "catch" here
11:31:22 <pastorn> *hackage*
11:31:42 <pastorn> FliPPeh: you can take an IOException and make it into a Maybe :)
11:31:55 <jmcarthur> error doesn't throw an IOException
11:32:05 <pastorn> well, whatever ;)
11:32:07 <FliPPeh> That's the problem here
11:32:17 <FliPPeh> Network.HTTP will throw "error" when the URL is invalid
11:32:22 <FliPPeh> Now this is Bullpoo
11:32:23 <jmcarthur> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/Control-Exception.html#t%3AErrorCall
11:32:36 <pastorn> FliPPeh: isn't there a tester?
11:32:36 <FliPPeh> If a user enters an invalid URL, just let the whole freaking program die?
11:32:40 <FliPPeh> Who thought of that?
11:32:53 <pastorn> FliPPeh: probably made simpler code
11:33:10 <FliPPeh> It's getRequest of HTTP
11:33:24 <jmcarthur> catch ErrorCall
11:33:33 <FliPPeh> Wha?
11:33:36 <FliPPeh> :/
11:33:46 <pastorn> @hoogle URI -> Bool
11:33:46 <lambdabot> Test.QuickCheck.Batch isBottom :: a -> Bool
11:33:46 <lambdabot> Network.Browser defaultCookieFilter :: URI -> Cookie -> IO Bool
11:33:46 <lambdabot> Network.Browser userCookieFilter :: URI -> Cookie -> IO Bool
11:34:18 <pastorn> @hoogle String -> Maybe Bool
11:34:19 <lambdabot> Network.CGI.Protocol maybeRead :: Read a => String -> Maybe a
11:34:19 <lambdabot> Network.URI isAbsoluteURI :: String -> Bool
11:34:19 <lambdabot> Network.URI isIPv4address :: String -> Bool
11:35:17 <pastorn> FliPPeh: this is what you want: http://hackage.haskell.org/packages/archive/network/2.2.1.3/doc/html/Network-URI.html
11:35:42 <pastorn> FliPPeh: do your own sanity checks!
11:35:47 <FliPPeh> NEVER
11:36:07 <pastorn> FliPPeh: don't you mean "NEVAR"?
11:36:16 <FliPPeh> Totally
11:36:39 <pastorn> FliPPeh: http://www.maniacworld.com/internet-bro-fist.jpg
11:36:57 <aavogt> > isBottom "_|_"
11:36:58 <lambdabot>   Not in scope: `isBottom'
11:37:07 <pastorn> aavogt: hahahahha
11:37:13 <FliPPeh> :)
11:37:24 <jmcarthur> @let isBottom _ = False
11:37:26 <lambdabot>  Defined.
11:37:38 <pastorn> hee
11:37:38 <jmcarthur> dang, wrong
11:37:48 <jmcarthur> how do i forget that?
11:37:56 <pastorn> undefine
11:37:59 <pastorn> i think
11:38:03 <jmcarthur> @undefine isBottom
11:38:09 <pastorn> or forget
11:38:13 <pastorn> @forget isBottom
11:38:13 <lambdabot> Incorrect arguments to quote
11:38:18 <pastorn> oh
11:38:18 <jmcarthur> i think forget is for quotes
11:38:22 <regalia> @undef isBottom
11:38:25 <pastorn> @unlet isBottom
11:38:25 <lambdabot>   Parse error: SemiColon
11:38:32 <jmcarthur> :t isBottom
11:38:33 <lambdabot> Not in scope: `isBottom'
11:38:35 <jmcarthur> yay
11:38:41 <aavogt> @unlet x = y
11:38:42 <lambdabot>  Defined.
11:38:53 <jmcarthur> @let isBottom a = seq a False
11:38:54 <lambdabot>  Defined.
11:38:57 <pastorn> @let top = undefined
11:38:59 <lambdabot>  Defined.
11:39:09 <pastorn> > isBottom top
11:39:10 <lambdabot>   * Exception: Prelude.undefined
11:39:21 <jmcarthur> > isBottom "foo"
11:39:22 <lambdabot>   False
11:39:23 <pastorn> jmcarthur: dude!
11:39:25 <aavogt> you know it's supposed to return True
11:39:26 <jmcarthur> > isBottom undefined
11:39:27 <lambdabot>   * Exception: Prelude.undefined
11:39:45 <pastorn> jmcarthur: messing with my shit!
11:39:54 <pastorn> what's that seq doing there?
11:39:59 <pastorn> besides messing with my head?
11:40:16 <FliPPeh> :t fail
11:40:17 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
11:40:21 <FliPPeh> > fail "OH GOD"
11:40:22 <lambdabot>   No instance for (GHC.Show.Show (m a))
11:40:22 <lambdabot>    arising from a use of `M1502882331...
11:40:27 <jmcarthur> pastorn: if it terminates then it's not bottom. if it doesn't terminate the entire computation is _|_. thank the halting problem :)
11:40:28 <burp> @hoogle Codec.Binary.Base64
11:40:28 <lambdabot> No results found
11:40:31 <FliPPeh> M1502882331 ?
11:40:44 <regalia> :t forever
11:40:45 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
11:41:31 <FliPPeh> @src sleep
11:41:32 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
11:41:34 <FliPPeh> :t sleep
11:41:35 <lambdabot> Not in scope: `sleep'
11:41:37 <FliPPeh> ::((
11:46:46 <Aristid> @hoogle sleep
11:46:46 <lambdabot> No results found
11:50:11 <burp> how can I link statically against libgmp with ghc?
11:51:52 <EvanR-work> Aristid: threadDelay
11:52:29 * hackagebot hoauth 0.2.1 - A Haskell implementation of OAuth 1.0a protocol.  http://hackage.haskell.org/package/hoauth-0.2.1 (DiegoSouza)
11:53:00 <Aristid> @hoogle threadDelay
11:53:00 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
11:58:03 <FliPPeh> God
11:58:13 <FliPPeh> I always hated Network.HTTP
11:58:30 <FliPPeh> I can't for the love of god find out how to send, or even construct a POST request
11:58:49 <HugoDaniel> FliPPeh: use hack
11:59:03 <HugoDaniel> or wai
11:59:10 <aavogt> or even curl
11:59:15 <FliPPeh> I don't want to install any extra stuff, just because Network.HTTP is being mean
11:59:23 <FliPPeh> That's just space waste
12:00:15 <HugoDaniel> :)
12:00:24 <HugoDaniel> or Network.TCP
12:00:36 <sm> it looks not so hard
12:00:40 <FliPPeh> You mean using raw HTTP data?
12:00:56 <sm> Network.HTTP (http://hackage.haskell.org/packages/archive/HTTP/4000.0.9/doc/html/Network-HTTP.html#v%3ApostRequest). What goes wrong ?
12:01:10 <FliPPeh> sm: that just creates an EMPTY request
12:01:19 <FliPPeh> I have yet to find out how to actually put POST data in there
12:03:11 <FliPPeh> I'll probably just access that darn Request data directly
12:03:17 <FliPPeh> And stuff it in there with record update
12:05:35 <sm> FliPPeh: yeah, that seems to be what's expected
12:05:41 <FliPPeh> sm: But it doesn't work either
12:05:51 <FliPPeh> The data will be stuffed in there, but it does not update the content-length
12:05:56 <FliPPeh> Whacky stuff
12:06:01 <sm> oh I knew it wouldn't be that easy
12:06:11 <FliPPeh> Oh come on
12:06:15 <sm> lord no
12:06:16 <FliPPeh> Let me slap someone for this
12:06:26 <FliPPeh> Someone out there deserves it
12:07:06 <sm> ah well.. should no-one release a package until it does 100% of what folks might want ?
12:07:21 <sm> it should be documented, is all
12:07:23 <FliPPeh> That's impossible
12:07:43 <FliPPeh> But hey, it's a mature libary, probably one of the first ones
12:07:49 <FliPPeh> It HAS to be in there
12:07:55 <FliPPeh> POST requests are basic stuff
12:08:01 <FliPPeh> And the second most important
12:08:23 <sm> ok, find a user of this lib that does posts
12:08:44 <FliPPeh> I have no idea where to start looking
12:09:02 <sm> there's some version of hackage somewhere that shows reverse deps
12:09:49 <sm> cabal-install must do a POST
12:09:58 <FliPPeh> Why?
12:10:05 <FliPPeh> Does it submit data?
12:10:33 <benmachine> I think I've done post requests
12:10:35 <sm> yes, when you upload
12:10:44 * sm guesses wildly
12:11:13 <FliPPeh> benmachine: I'd call you Mr. Awesome if you'd look if you can find it for me
12:11:47 <benmachine> FliPPeh: I think I used some of the stuff in Network.Browser
12:11:52 <benmachine> but I don't think I *have* to
12:11:57 <benmachine> try formToRequest?
12:12:04 <sm> http://gist.github.com/352235 <- from cabal-install
12:12:24 <FliPPeh> formToRequest = Network.HTTP.Browser?
12:12:57 <benmachine> it's in Network.Browser which is in the HTTP package I believe
12:13:16 <benmachine> but as I said I think it's optional, just convenient
12:14:09 <benmachine> hold on, can't you construct a request with postRequest and then modify it afterwards?
12:14:16 <FliPPeh> I've been trying to
12:14:22 <FliPPeh> But I find no modifying methods
12:14:28 <benmachine> ah
12:14:32 <FliPPeh> I even tried to change the raw data structure of that request
12:14:55 <FliPPeh> But then it would not update it's content length
12:15:28 <sm> FliPPeh: I think the idea is to generate the correct data in the string in the first place.. see that code I linked ?
12:16:07 <benmachine> ghci> let Just uri = parseURI "http://haskell.org"
12:16:07 <benmachine> ghci> formToRequest (Form POST uri [("lol", "butts")])
12:16:11 <FliPPeh> sm: Is that the mkRequest from the HTTP package?
12:16:17 <benmachine> ^ with Network.URI and Network.Brower
12:16:19 <benmachine> *Browser
12:16:31 <benmachine> I think that gets you what you want; it has Content-Length: 9
12:16:40 <FliPPeh> So that'd equal POST "?lol=butts"?
12:16:44 <benmachine> presumably
12:16:48 <EvanR-work> lol
12:16:50 <EvanR-work> butts
12:16:53 <sm> FliPPeh: I added the file path to that paste, you may not have seen it
12:16:53 <benmachine> quite
12:16:55 <FliPPeh> lolbutts-
12:16:57 <FliPPeh> Alright
12:17:02 <FliPPeh> I'll use Network.Browser
12:17:11 <FliPPeh> I won't be fooled by the HTTP package anymore
12:17:39 <benmachine> Network.Browser is in the HTTP package, isn't it?
12:17:42 * sm throws up his hands.. 
12:17:50 <benmachine> yeah it is
12:18:15 <jmcarthur> nice http://donsbot.wordpress.com/2010/04/01/the-8-most-important-haskell-org-gsoc-projects/
12:21:15 <ezyang> I'm looking for Ralf Hinze's paper "Weaving a Web" but am having difficulty finding a PDF.
12:21:38 * hackagebot wxcore 0.12.1.4 - wxHaskell core  http://hackage.haskell.org/package/wxcore-0.12.1.4 (DanielFischer)
12:23:18 <\yrlnry> ezyang:  http://archive.cs.uu.nl/pub/RUU/CS/techreps/CS-2001/2001-33.pdf ?
12:23:40 <ezyang> ah, excellent. Thanks!
12:24:30 <\yrlnry> ezyang:  I did advanced Google Scholar search and asked it to search for "exact phrase" = "weaving a web" and "author" = "hinze".  But it referred me to citeseer, which I would have checked first if you had not said you were having trouble finding it.
12:25:15 <ezyang> yrlnry: Good to know. I checked ACM and didn't find a link
12:26:42 <\yrlnry> Glad to be of service.
12:27:20 <dons> the most important haskell.org google summer of code projects: http://donsbot.wordpress.com/2010/04/01/the-8-most-important-haskell-org-gsoc-projects/
12:27:23 <dons> comment.
12:28:25 <danderson> +1
12:28:48 <ezyang> They all are great things I'd like to see
12:28:55 <EvanR-work> is there a readFile that reads the entire file at once and closes it immediately
12:29:26 <jmcarthur> dons: you were too slow. i already linked it ;)
12:29:40 * hackagebot wx 0.12.1.4 - wxHaskell  http://hackage.haskell.org/package/wx-0.12.1.4 (DanielFischer)
12:29:43 * dons closes things > 2 years old
12:29:55 <dons> EvanR-work: Data.ByteString.readfile
12:29:56 * aavogt agrees that cabal needs work
12:31:00 * ezyang muses, "Wow, suddenly the zipper is making sense." 
12:32:17 <FliPPeh> I have done it
12:32:31 <FliPPeh> Rapidshare Free User download with the timeout :)
12:32:42 <FliPPeh> Now gotta build a nice GUI on top of it
12:32:44 <aavogt> dons: I'm not so sure about this though: "As an extension, it would warn about errors in version ranges in .cabal files."
12:33:43 <aavogt> in that the PVP  suggests conservative ranges while others may still work
12:33:45 <dons> add comments to the blog page.
12:34:20 <EvanR-work> how do i convert the first few parts of a list to a tuple
12:35:03 <FliPPeh> Oh gosh, I picked a random rapidshare link from google, and it HAD to be a... bad.. movie.
12:35:23 <aavogt> http://haskell.org/haskellwiki/Template_Haskell#Examples
12:48:33 <FliPPeh> benmachine: Do you have any idea how to use Network.Browse to download binary data?
12:48:37 <micah> my parsec parser is giving very bad error messages
12:48:46 <FliPPeh> Or can I just issue that post request and save the body to a file?
12:49:05 <micah> for instance, I have a control structure, and an error appears somewhere inside its block, and it says that the error is at the beginning of the control structure
12:50:51 <jmcarthur> @src Int
12:50:51 <lambdabot> data Int = I# Int#
12:51:36 <jmcarthur> @src Float
12:51:36 <lambdabot> data Float = F# Float#
12:51:42 <dons> danderson: i opened up tickets for the new stuff. and closed a bunch of old ones.
12:51:49 <danderson> dons: awesome.
12:51:58 <dons> http://hackage.haskell.org/trac/summer-of-code/report/1
12:52:02 <dons> feel free to close more :)
12:52:03 <jmcarthur> @src CInt
12:52:04 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
12:52:30 <EvanR-work> lets say ($>) x f = f x, can i write a sequence of x $> f cascaded but with each x and f expression indented the same amount, somehow?
12:53:07 <EvanR-work> i could do it with { and ; and }
12:58:18 <idnar> @type ($>)
12:58:19 <lambdabot> Not in scope: `$>'
12:58:21 <idnar> @type (<$)
12:58:22 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
12:58:55 <idnar> @type (<*)
12:58:56 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
13:02:25 <FliPPeh> > Just 4 >>= (\c -> Just "link" >>= (\l -> (c, l)))
13:02:26 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe b'
13:02:26 <lambdabot>         against inferred ...
13:02:33 <FliPPeh> > Just 4 >>= (\c -> Just "link" >>= (\l -> Just (c, l)))
13:02:34 <lambdabot>   Just (4,"link")
13:02:44 <FliPPeh> > Just 4 >>= (\c -> Nothing >>= (\l -> Just (c, l)))
13:02:45 <lambdabot>   Nothing
13:02:47 <FliPPeh> Aha!
13:03:51 <FliPPeh> Too bad I can't include it in my code :(
13:04:27 <EvanR-work> why is this not working
13:04:29 <EvanR-work> http://pastebin.com/ZuK4D4vh
13:04:44 <FliPPeh> Okay, question. I have two pure "Maybe" functions, and I want to return both Just values inside a tuple, but only if they're really both Just, if one fails, it shall return "Nothing" for the whole function
13:05:06 <EvanR-work> Maybe (Maybe a, Maybe b) ?
13:05:22 <FliPPeh> Nah, the tuple must contain the unpacked values
13:05:22 <Zao> So something :: Maybe a -> Maybe b -> Maybe (a, b)
13:05:34 <Zao> Lift , into Maybe or something?
13:05:40 <EvanR-work> you can use the maybe >>= operation
13:05:41 <FliPPeh> I think this is a job for fmap
13:06:06 <Igloo> liftM2 (,)
13:06:46 <Zao> Djinning it gives a nested case.
13:06:46 <pastorn> @type liftM2 (,)
13:06:47 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
13:07:11 <FliPPeh> Igloo: That's exactly what I need
13:07:13 <FliPPeh> Thanks :)
13:09:11 <ih> to install ghc 6.12.1 to Ubuntu do you have to add a non-default repository?  i'm using karmic and the latest version listed in synaptic is 6.10.xx
13:17:39 <benmachine> EvanR-work: indentation is important less often than you might think
13:17:56 <benmachine> EvanR-work: just stay more indented than your enclosing let/case/do/whatever, and anything goes
13:18:50 <ih> hello
13:20:47 <EvanR-work> benmachine: the problem was a missing ) :S
13:20:53 <FliPPeh> There we go, Rapidshare downloader in 27 lines of haskell
13:21:31 <benmachine> hi ih
13:23:14 <waterlaz> I wonder, why does linking with gnu ld take so long?
13:23:31 <burp> waterlaz: static?
13:23:39 <waterlaz> yeah
13:23:43 <kmc> gold is supposed to be faster
13:23:51 <burp> and dynamic is faster too
13:23:52 <waterlaz> that probably answeared my question, didn't it?
13:23:59 <danderson> waterlaz: ld is quite slow for a number of reasons. If you're linking ELF on linux, gold is way faster.
13:24:22 <burp> but gold doesn't work for everything ld did, right?
13:24:26 <burp> for example the kernel
13:25:01 <malc_> burp: gold has(had) issues here on a PPC
13:25:22 <danderson> yes, gold does a subset of what ld can do
13:25:31 <danderson> in exchange for that loss, it does what it does really fast.
13:26:09 <burp> waterlaz: add -dynamic (for 6.12)
13:26:57 <waterlaz> I'm building a cabal package so don't whant to mess things up inside it
13:27:15 <waterlaz> or is there some sort of a global option for that?
13:27:55 <benmachine> try .cabal/config
13:28:20 <burp> shared: True
13:28:46 <benmachine> that might have something to do with it
13:33:02 <FliPPeh> Anyone here using Gtk2Hs with Glade?
13:33:16 <FliPPeh> How would I get a list with columns in there?
13:33:46 <FliPPeh> I heard you can only get PARTS of it in glade
13:35:07 <danderson> is there a unicode library somewhere that I can use to fold a unicode string into a mangled ascii version?
13:35:24 <danderson> (my URLs with non-ascii codepoints in them are sad pandas)
13:35:32 <FliPPeh> :'(
13:37:33 <stevenmarky_> you can have unicode urls, it's just naughty
13:40:34 <stevenmarky_>   http://www.☃.net
13:41:06 * stevenmarky_ wonders how many clients that will work for
13:41:23 <FliPPeh> Works for me :)
13:41:44 <EvanR-work> that looks really funny
13:41:46 <EvanR-work> in xterm ;)
13:42:27 <xerox> ttp://en.wikipedia.org/wiki/Internationalized_domain_name
13:42:50 <EvanR-work> 'h':
13:42:52 <EvanR-work> ;)
13:42:56 <xerox> weird :)
14:02:03 <Sadache> I need an instance of Alternative for Reader r (a->b)
14:02:18 <Sadache> can I cook one without writing it from scratch?
14:02:46 <benmachine> I haven't heard of such a thing
14:02:52 <benmachine> what is it supposed to do?
14:03:30 <Sadache> Alternative is a Functor and a Monoid
14:03:43 <benmachine> an Applicative and a Monoid
14:04:07 <benmachine> it's similar to MonadPlus
14:04:17 <benmachine> but afaik there isn't a MonadPlus for Reader r a
14:04:19 <Sadache> it has <|> operator that lets compose two
14:05:25 <benmachine> why do you want an instance?
14:05:32 <benmachine> erm
14:05:36 <benmachine> I'd say write it from scratch
14:05:43 <benmachine> but I'm not convinced there is a useful one
14:05:45 <Sadache> oh MonadPlus could work, u are right
14:06:03 <benmachine> MonadPlus is the same as Alternative except it requires Monad instead of Applicative
14:06:18 <Sadache> except MonadPlus won't have an apply function
14:06:22 <benmachine> :t ap
14:06:23 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:06:36 <benmachine> what are you actually trying to do
14:07:16 <Sadache> i have functions a->a that need to read an env (web request)
14:07:43 <Sadache> and i want to compose them (response1 <|> response2 ) and so on
14:08:26 <Sadache> that makes a Reader with a Monoid
14:08:56 <Sadache> and I can use ap in infix `ap` so that works
14:09:56 <Sadache> benmachine: but does this mean that a MonadPlus is an Alternative?
14:10:21 <byorgey> you can only use <|> with things that have some notion of failure.
14:10:28 <byorgey> just plain old Reader does not.
14:10:37 <byorgey> but perhaps something like  MaybeT Reader will work.
14:10:46 <byorgey> or ReaderT Maybe, I forget which is which.
14:11:43 <Sadache> byorgey: why with some kind of failure? http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/Control-Applicative.html#t%3AAlternative
14:12:13 <byorgey> Sadache: because you need something which is the identity for <|>
14:12:22 <byorgey> called 'empty' in the Alternative class
14:12:30 <ksf> I want my enumerator to be able to detect whether or not it is directly connected to a specific kind of iteratee for some time
14:12:37 <byorgey> Sadache: what is the semantics of (response1 <|> response2) in your example?
14:12:42 <Sadache> it says it is just a monoid on applicative
14:13:08 <ksf> the background is reading data via a socket and wanting to sys_splice the right parts directly to the file system, without having the data touch userspace (or be copied)
14:13:35 <EvanR-work> :t min
14:13:36 <lambdabot> forall a. (Ord a) => a -> a -> a
14:13:44 <EvanR-work> > min 3 4
14:13:45 <lambdabot>   3
14:13:50 <EvanR-work> > min 3 maxBound
14:13:51 <lambdabot>   Ambiguous type variable `t' in the constraints:
14:13:51 <lambdabot>    `GHC.Num.Num t' arising ...
14:13:52 <byorgey> Sadache: I am trying to understand exactly what you want.  What are the types of response1 and response2?  what do you mean by 'compose them'?
14:14:03 <ksf> Sadache, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24320
14:14:10 <Sadache> byorgey: (Response ->Request->Response)  -> (Response ->Request->Response)
14:14:25 * ezyang wonders why that type wouldn't just be id 
14:14:44 <FliPPeh> Anyone got experience with Gtk2Hs and glade here?
14:14:52 <EvanR-work> > min 3 (maxBound :: Int)
14:14:52 <lambdabot>   3
14:14:53 <ksf> oh, reader, not readP
14:14:55 <FliPPeh> I can't figure out how to put actions on menu items
14:15:20 <EvanR-work> > min 30000000000000 (maxBound :: Int)
14:15:21 <lambdabot>   30000000000000
14:15:56 <byorgey> Sadache: oh, so response1 is a Response -> Response transformer, which can also implicitly access a Request?  i.e.  Reader Request (Response -> Response) ?
14:16:13 <Sadache> byorgey: exactly
14:16:25 <byorgey> I think what you really want is just to write an instance (Monoid a) => Monoid (Reader r a)
14:16:54 <byorgey> which should be easy, you can just unwrap the Reader constructor and use the existing  Monoid a => Monoid (r -> a)  instance
14:17:05 <Sadache> byorgey: ah, I like that
14:17:14 <tromp_> > 30000000000000 :: Int
14:17:15 <lambdabot>   30000000000000
14:17:15 <Sadache> so I was too specific
14:17:19 <byorgey> and  a -> a  is already an instance of Monoid
14:17:32 <Sadache> byorgey: I missed that
14:17:36 <tromp_> > 30000000000000 :: Word8
14:17:37 <lambdabot>   0
14:17:45 <syfran> Is it possible to have a infix operator that takes 3 arguments? such as  (<++>) :: (ByteString -> Maybe a) -> (ByteString -> Maybe a) -> ByteString -> Maybe a ?
14:17:58 <tromp_> > 30000000000000 :: Int32
14:17:59 <lambdabot>   -346562560
14:18:00 <ezyang> syfran: Sort of
14:18:10 <byorgey> Sadache: yeah, Alternative/MonadPlus are not just for ANY monoid on Applicative/Monads, their methods are supposed to satisfy certain laws in relation to <*> and >>=
14:18:15 <ksf> ...I _could_ just curry in fd_in, len and off_in of the splice call and have my chunk type be (fd_out -> IO (), S.Bytestring), but the problem is that off_in has to be NULL in the socket case and thus reading anything from that socket would move the splice call forwards.
14:18:20 <ezyang> syfran: As in, any 3-arity function is 2-arity that returns a 1-arity function
14:18:21 <byorgey> which is what makes them be about "failure"
14:18:23 <ksf> ...breaking referential transparency
14:18:28 <benmachine> byorgey: a -> a needs a newtype wrapper
14:18:31 * hackagebot terminfo 0.3.1.2 - Haskell bindings to the terminfo library.  http://hackage.haskell.org/package/terminfo-0.3.1.2 (JudahJacobson)
14:18:31 <ezyang> syfran: But your operator precedence will be all wrong
14:18:49 <byorgey> benmachine, Sadache: oh, right, sorry, it's Endo which is an instance of Monoid
14:18:54 <tromp_> > maxBound :: Int
14:18:55 <lambdabot>   9223372036854775807
14:18:56 <byorgey> from Data.Monoid
14:19:03 <ezyang> > let (+++) a b c = a + b + c in (1 +++ 2) 3
14:19:04 <lambdabot>   6
14:19:09 <Sadache> byorgey: then i've been fooled by the documentation. I though it is any monoid on an applicative
14:19:39 <byorgey> Sadache: hmm, you're right, the documentation is sadly lacking
14:19:52 <ksf> ternary is possible.
14:19:57 <ksf> (with some tricks)
14:20:02 <EvanR-work> 64BITS!
14:20:27 <EvanR-work> tromp_: is there a way Integer -> Int which 'clamps' the value to the maximum of the Int type
14:20:37 <ezyang> ksf: I object to said tricks! Maybe.
14:20:42 <ezyang> :-)
14:21:00 <ksf> syfran, ezyang http://www.haskell.org/haskellwiki/Ternary_operator
14:21:02 <Sadache> byorgey: can you point to some url that shows why my assumption is wrong, I just need to get it once for all
14:21:47 <ezyang> oooh, that's not that bad
14:22:08 <ksf> EvanR-work, fromIntegral
14:22:19 <fax> which assumption
14:22:22 <byorgey> Sadache: well, for example, see the docs for MonadPlus: http://haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/Control-Monad.html#t%3AMonadPlus
14:22:36 <glguy> EvanR-work, it will probably involve 'maxBound' and 'min'
14:22:39 <byorgey> Sadache: it specifies the laws  mzero >>= f = mzero  and v >> mzero = mzero
14:22:39 <tromp_> > let capint i = if i > fromInteger mi then mi else i where mi = (maxBound :: Int)
14:22:40 <lambdabot>   not an expression: `let capint i = if i > fromInteger mi then mi else i whe...
14:23:06 <byorgey> Sadache: there's probably also something about it in the original Applicative paper
14:23:09 <tromp_> @let capint i = if i > fromInteger mi then mi else i where mi = (maxBound :: Int)
14:23:10 <lambdabot>  <local>:4:30:
14:23:10 <lambdabot>      Couldn't match expected type `Integer' against inferred t...
14:23:17 <EvanR-work> > fromIntegral 2374982374982374928374234 :: Int
14:23:17 <lambdabot>   968980417576917466
14:23:33 <tromp_> @let capint i = if i > fromIntegral mi then mi else i where mi = (maxBound :: Int)
14:23:33 <fax> > iterate fromIntegral 2374982374982374928374234
14:23:34 <lambdabot>  Defined.
14:23:34 <lambdabot>   [2374982374982374928374234,2374982374982374928374234,2374982374982374928374...
14:23:39 <ksf> ...so the referential transparency problem is forcing me to do the splice call in the enumerator, which raises said problem of knot knowing whether or not I should splice or shove a bytestring to a vanilla iteratee
14:23:48 <tromp_> :t capint
14:23:49 <lambdabot> Int -> Int
14:24:58 <tromp_> @let capint (i::Integer) = if i > fromIntegral mi then mi else i where mi = (maxBound :: Int)
14:24:58 <lambdabot>   ScopedTypeVariables is not enabled
14:25:11 <ksf> @let capint i = if fromIntegral i > mi then mi else fromIntegral i where mi = (maxBound :: Int)
14:25:11 <lambdabot>  <local>:4:0:
14:25:12 <lambdabot>      Warning: Pattern match(es) are overlapped
14:25:12 <lambdabot>               In...
14:25:17 <FliPPeh> Why do all these tutorials only cover the simple stuff such as casting buttons from the glade file? I want MENU BARS!
14:25:19 <ksf> @unlet capint
14:25:19 <lambdabot>   Parse error: SemiColon
14:25:23 <glguy> let clamp x = fromIntegral (min x (fromIntegral (maxBound `asTypeOf` x)) in clamp (2^65)
14:25:27 <ksf> @slap herself
14:25:27 <lambdabot> *SMACK*, *SLAM*, take that herself!
14:25:37 <EvanR-work> > let cap :: Integer -> Int; cap x = fromIntegral x in cap 28397428374928734928374928374
14:25:38 <lambdabot>   -2675476888555547658
14:25:42 <EvanR-work> :(
14:25:59 <ksf> is anybody listening to my iteratee musings?
14:26:24 <Sadache> byorgey: that is the zero law,isn't it the monoid empty? I am sorry maybe I have to revise
14:27:14 <ksf> hmmm mmmh
14:27:26 <glguy> :t let clamp x = r where r = fromIntegral (min x (fromIntegral (maxBound `asTypeOf` r))) in clamp
14:27:26 <lambdabot> forall a a1. (Integral a, Integral a1, Bounded a1) => a -> a1
14:27:28 <Sadache> byorgey: ah ok, I get u better, it is the interaction between a monoid and the applicative
14:27:29 <ksf> I _could_ use that Maybe ErrMsg field of IterGV
14:27:38 <glguy> EvanR-work, ^
14:28:08 <Sadache> byorgey: i mean the laws are about interaction between a monoid and the applicative, or the monad and the monoid right?
14:29:31 <ksf> in fact, iteratees should be parametrized over the type of ErrMsg, which should actually be called CtrlMsg
14:31:32 <ksf> a newtype with five type parameters is evil.
14:31:43 <stepcut> has anyone done work on combinators that simultaneously specify how to print and parse back in a data type?
14:32:28 <syfran> ksf, thanks for the link, right now I am just defining the function in a where so it does not have to take the ByteString as an argument, that seems to be the eaiest for now
14:34:03 <ezyang> Hmm... any data structures on Hackage that implement Red Black Trees?
14:35:29 <ksf> are there any other serious iteratee implementation despite olegs/jwlatos one and tibbe's for hyena?
14:35:51 <Sadache> I've been wondering for sometime whether type classes concept can be introduce in a dynamically typed languge
14:36:15 <stepcut> ksf: wai ?
14:36:20 <ezyang> Sadache: Sure. It's a lot like interfaces and polymorphism
14:36:45 <dabblego> no it isn't. It is nothing like interfaces and no it's not possible in most (all?) dynamically typed language
14:36:50 * stepcut tries not to wonder about dynamically typed languages at all
14:37:26 <ksf> stepcut, isn't that hyena?
14:37:48 <stepcut> ksf: the idea came from hyena, but wai and hyena have different implementations now :p
14:38:09 <stepcut> ksf: tibbe said he didn't want to unify them yet because hyena is still to experimental
14:39:11 <ksf> ...but it doesnt' do what I need, either
14:39:29 <ksf> seems like hyena isn't designed to _recieve_ a lot of data...
14:40:12 <ksf> so it's forking oleg's code, then.
14:40:37 <Sadache> dabblego: dispatching dynamically on multiple parameter types is possible, clojure does so
14:40:51 <Sadache> dabblego: my problem is on return type
14:41:18 <dabblego> Sadache, the problem is passing an implicit dictionary
14:41:55 <p_l> Sadache: Well, given that I used Haskell type classes to get an understanding on Common Lisp Object System...
14:42:43 <ksf> no I'm not insane I won't fork that thing but copy+paste what I need
14:43:12 <ezyang> Sadache: I think OOP systems do dependency injection to get that
14:43:20 <ezyang> ksf: Heh
14:43:24 <Sadache> dabblego: you can pass it at runtime in a hidden parameter that uses any of the class functions
14:43:28 <jmcarthur> ugh dependency injection
14:43:34 <jmcarthur> they keep coming up with new words for old ideas
14:43:37 * hackagebot ghci-haskeline 0.2 - An implementation of ghci using the Haskeline line-input library.  http://hackage.haskell.org/package/ghci-haskeline-0.2 (JudahJacobson)
14:44:15 <ezyang> bah, I hope I don't have to write my own red-black trees
14:44:26 <ezyang> oh wait http://www.cs.kent.ac.uk/people/staff/smk/redblack/rb.html
14:44:32 <ezyang> it's... just not on Hackage. Hmmm
14:44:37 <jmcarthur> ezyang: isn't Data.Map a red black tree?
14:44:39 <dabblego> Sadache, pass what?
14:44:46 <jmcarthur> and Data.Set
14:45:00 <Sadache> the class instance
14:45:05 <ezyang> I thought Data.Map was size balanced binary trees
14:45:17 <jmcarthur> i'm 99% sure it's rb tree
14:45:35 <Sadache> dabblego: the used class instance
14:45:50 <jmcarthur> hmm, nevermind
14:45:53 <ezyang> docs seem to disagree
14:46:10 <dabblego> Sadache, what is "hidden" about it?
14:46:11 <jmcarthur> yeah
14:46:16 <jmcarthur> code disagrees too
14:46:23 <ezyang> heh :-)
14:46:44 <jmcarthur> shame. i like rb trees
14:46:59 <ezyang> they're nice as long as you don't have to implement them...
14:47:06 <EvanR-work> hehehe
14:47:08 <jmcarthur> i've done it too many times
14:47:12 <Sadache> dabblego: did you have a look at scala implicit parameters? it is somehow the same idea
14:47:16 <jmcarthur> twice
14:47:18 <dabblego> Sadache, yes
14:47:25 <EvanR-work> sounds fun!
14:47:28 <jmcarthur> once in C, once in haskell
14:47:28 <dabblego> Sadache, have you heard of Scalaz?
14:47:33 <jmcarthur> the haskell one has since been lost though
14:48:54 <Sadache> myFunction= fromInteger 1 will be of type |Num -> Something
14:49:12 <dabblego> @type fromInteger 1
14:49:13 <lambdabot> forall a. (Num a) => a
14:49:40 <Sadache> and since types are dynamic, you woudn't care, except that it'd add lazyness and that will change the programming model
14:49:44 <jmcarthur> i don't even understand what dependency injection is. it looks like yet another mental trick for coming up with where to draw abstraction boundaries when misapplying OO
14:50:37 <dabblego> jmcarthur, it's a failed attempt at abstraction as you suspect. Its absence is an improvement.
14:51:57 <jbapple> I read that as "mistyping OO"
14:52:11 <jmcarthur> really, when OO is being applied to something natural for it, things just fall into place and you don't even have to think about these things. if i ever caught myself thinking about dependency injection and stuff i would stop and seriously consider whether OO is really the right approach for that problem
14:53:12 <jmcarthur> and the language of wikipedia's description of dependency injection worries me, talking about "services" and such
14:53:13 <jbapple> I once heard someone explain that "OOPSLA" stands for "OOPSLA, I accidentally invented another object type system"
14:53:17 <jmcarthur> what happens to objects?
14:53:28 <jmcarthur> *happened
14:53:33 <Sadache> objects are not compositional unlike functions that's why you need some magic to compose them for u
14:53:52 <Sadache> and by objects i mean Java like objects
14:54:21 <jmcarthur> message-passing is compositional when applied to the right problems
14:55:02 <EvanR-work> jmcarthur: a lot of OO terminology is disturbing
14:55:19 <jmcarthur> EvanR-work: absolutely
14:56:44 * p_l doesn't like message-passing style of OO. At least the way it was done for Java (Smalltalk/Ruby is acceptable)
14:57:00 <ksf> duh. oleg's original code, which uses SomeException as error message, supports what I want to do
14:57:15 <jmcarthur> p_l: java has a message-passing style?
14:57:30 <ksf> the version on hackage is restricted to string error messages and offset seeks.
14:57:30 <p_l> jmcarthur: that's what the "class has methods you call" style is called
14:57:50 <jmcarthur> that is not my internalized definition of message passing
14:57:53 <p_l> the methods are "messages" you send to an "object"
14:58:13 <jmcarthur> what about prototype oriented languages? they aren't message passing?
14:58:23 <p_l> jmcarthur: I'm not blaming you for that, I find that badly internalized for me as well
14:58:32 <nominolo> jmcarthur: sure they are
14:58:32 <p_l> jmcarthur: depends on how you invoke "methods"
14:58:46 <nominolo> continuations emerged from research into message passing actors, btw
14:58:55 <jmcarthur> nominolo: indeed :)
14:59:32 <ichor> Hi, asked about this earlier but didn't get any response. I dont understand the following compile error from GHC:
14:59:45 <ichor> Couldn't match expected type `(f x -> x) -> x' against inferred type `forall y. (f y -> y) -> y'
14:59:52 <jmcarthur> meh, i dont' want to quibble over definitions. there is some definition of "message passing" which i intended, and i think p_l's is not it ;)
15:00:17 <ichor> I thought the "forall y" would ensure that it was ok.
15:00:25 <nominolo> jmcarthur: what is your internalised definition?
15:00:26 <p_l> jmcarthur: otoh, you have object systems based on generic functions, which *might* be similar to Haskell typeclasses (I actually haven't grasped anything from CLOS till I read on those long time ago)
15:00:33 <nominolo> ichor: can you paste the code somewhere?
15:00:44 <ichor> nominolo, sure. 2 sek.
15:00:57 <nominolo> p_l: CLOS's message dispatch mechanism is very dynamic
15:01:14 <EvanR-work> is there a message passing 'framework' or technique or something in haskell?
15:01:20 <nominolo> I think it's strictly more powerful than Haskell's I think
15:01:22 <EvanR-work> like, where forkIO are objects?
15:01:38 <ichor> nominolo, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24585#a24585
15:01:42 <nominolo> EvanR-work: there's Communicating Haskell Processes
15:01:56 <nominolo> That's processes that communicate via Channels
15:02:01 <nominolo> so it's CSP
15:02:07 <EvanR-work> CSP?
15:02:09 <thuge> Hi
15:02:13 <p_l> nominolo: it is, but Haskell typeclasses were what pulled me out of the "methods are inside classes" lock-in
15:02:21 <ksf> csp isn't message-passing
15:02:24 <ksf> ...at least not in my book
15:02:28 <inclement> I'm trying to install cabal on ubuntu 9.10. I followed the instructions at http://blog.inquirylabs.com/2009/02/28/getting-started-with-haskell-cabal/  , but am told Setup: At least the following dependencies are missing: Cabal ==1.9.* . I don't understand as cabal is what I want to install...is it possible to fix this?
15:02:43 <nominolo> EvanR-work: communicating sequential processes
15:02:46 <ksf> there's erlang-style actor stuff around, somewhere though (I think)
15:02:54 <thuge> http://www.haskell.org/haskellwiki/Introduction#Quicksort_in_Haskell <--- you can implement quicksort in haskell in just 2 lines of code?
15:02:58 <EvanR-work> nominolo: wondering how to conveniently pull that off, if you want to have 'return messages'
15:03:21 <nominolo> EvanR-work: simple. send a continuation!
15:03:26 <nominolo> :)
15:03:35 <EvanR-work> o_O
15:03:39 <ksf> EvanR-work, take an ADT that encodes your messages, add a state monad to encode your objects state, and you have scheme-like objects.
15:04:12 <jmcarthur> nominolo: at some level of abstraction a message is an identifier (e.g. method name) with some data (e.g. parameters) which is interpreted by an object somehow. the recipient must handle the message itself or explicitly pass it off to another object to handle. i don't consider it "handling" if some related object is intercepting (such as in class-based object models)
15:04:30 <xerox> > let qs [] = []; qs (x:xs) = qs (filter (x>) xs) ++ [x] ++ qs (filter (x<=) xs) in qs [10,2,5,1,4,3,7,9,8,6]
15:04:31 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
15:04:36 <jmcarthur> nominolo: at least, that's a badly worded version of the internalized meaning to me ;)
15:05:11 <thuge> xerox : that. is. amazing.
15:05:22 <xerox> :D
15:05:56 <ichor> Does anyone have an explanation for my compile error?
15:06:34 <jmcarthur> nominolo: i'll put it more simple and accurately like this, i think: message passing is objects communicating with each other directly and having no idea how each other works. the whole "name" distinct from "data" thing is perhaps unnecessary to form a message
15:06:48 <nominolo> jmcarthur: ok, so you consider the dynamic part of message passing (i.e., the DoesNotUnderstand) quite essential to message passing
15:07:45 <alpounet> jmcarthur, my perception of message passing is very close to yours
15:09:12 <nominolo> ichor: I'm not sure that nested forall y. makes sense
15:10:16 <jmcarthur> nominolo: i'd say that in a "pure" message passing system any object receiving a properly formatted message it does not understand is nonetheless responsible for deciding how to handle it, even if it's just to send a message back that says "wtf?". if the object simply "throws and exception" then nobody hears about it (unless throwing an exception is itself modelled as a message to the original sender
15:10:17 <jmcarthur> or something)
15:10:18 <ichor> nominolo, why not? I have a very clear idea of why I put it there.
15:10:18 <xerox> > let  ismultiple n d = mod n d == 0  in  nubBy ismultiple [2..] -- thuge
15:10:19 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
15:10:28 <nominolo> ichor: this works: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24585#a24586
15:10:32 <jmcarthur> *throws an exception
15:11:21 <jmcarthur> i dont' consider it so important whether it's RPC or distinct send and receive phases, though
15:11:26 <nominolo> jmcarthur: would you consider erlang style actors as message passing?
15:11:31 <jmcarthur> yes
15:11:35 <jmcarthur> i know that's controversial
15:11:41 <jmcarthur> well
15:11:44 <jmcarthur> calling it OO is, anyway
15:11:54 <nominolo> I suppose that could be made statically typeable using extensible unions
15:12:05 <nominolo> well, except for the catch-all case
15:12:12 <nominolo> er, default case
15:12:28 <nominolo> ichor: is that not what you wanted?
15:13:46 <EvanR-work> hows this
15:13:55 <ichor> nominolo. Not sure becuse I wanted something of the form (f X -> X). The change of variables in the first was cosmetic. But putting the forall outside might not be.
15:13:56 <EvanR-work> passMsg :: Obj -> Msg a -> IO a
15:14:20 <EvanR-work> and the chans and stuff are hidden behind Msg
15:14:23 <EvanR-work> and Obj
15:14:38 <jmcarthur> i didn't realize we're talking about implementing message passing in haskell
15:14:46 <EvanR-work> i decided we were ;)
15:14:49 <jmcarthur> heh
15:15:39 <jmcarthur> time to leave work
15:18:43 <chrisdone> greets chaps
15:20:25 <ichor> nominolo, I thought about it and it wont do. I need it on the form f X -> X. Can you explain why the nested forall didn't make sense?
15:22:12 <nominolo> ichor: well, it seemed "too impredicative".. just a gut feeling
15:22:26 <nominolo> but those are often wrong when it comes to type theory ;)
15:23:32 <ichor> nominolo, hehe. If you care I'm trying to create inductive types in haskell like they are done in System F.
15:24:37 <nominolo> is that using some form of church encoding?
15:26:45 <nominolo> ichor: ok, from your error message it seems that GHC is not instantiating impredicatively
15:27:25 <ichor> It is a sort of church encoding I guess. Given a constructor type f(x), they are represented as Pi X . (f X -> X) -> X, if I understood it correctly.
15:27:58 <ichor> nominolo, -XImpredicativeTypes doesn't fix that?
15:29:06 <nominolo> ichor: Well, I think GHC is still using boxy types under the hood, I think.  Boxy types is essentially just propagating type annotations as far as possible.
15:29:29 <nominolo> FPH uses more MLF magic, but I don't think it's implemented ATM.
15:30:06 <ichor> nominolo, what's FPH?
15:30:42 <ichor> nominolo, never mind, googled it.
15:30:56 <nominolo> First-class Polymorphism for Haskell
15:30:59 <nominolo> k
15:31:21 <nominolo> ichor: do you know MLF?  (roughly)
15:33:28 <ichor> nominolo, not really. I've only read a tiny bit about.
15:34:19 <nominolo> ok, so the basic idea is to extend types with constraints.
15:34:21 <nominolo> for example:
15:34:32 <nominolo> choose :: forall a. a -> a -> a
15:34:39 <nominolo> now (choose id) gets type
15:35:01 <nominolo> forall (a < forall b. b -> b) => a -> a
15:35:24 <nominolo> that is, a can be instantiated to anything that is a subtype of the identity function
15:35:43 <nominolo> that is < *allows* polymorphism
15:35:55 <benmachine> how is that different from forall b. (b -> b) -> (b -> b) ?
15:36:05 <nominolo> there's another form, "=", that *requires* polymorphism
15:36:09 <nominolo> benmachine: it includes that type
15:36:26 <nominolo> benmachine: it also allows:  (forall b. b -> b) -> (forall b. b -> b)
15:36:26 <ichor> nominolo, depending of what subtype means in this context, I think I understood that.
15:36:35 <nominolo> ichor: subtype = instance of
15:36:41 <benmachine> k
15:37:01 <nominolo> ichor: the problem is that this requires these new constraint types
15:37:11 <nominolo> so FPH does the following:
15:37:37 <nominolo> whenever you bind a variable you have to decide its (System F) type.
15:37:56 <nominolo> If you don't give an annotation, then the standard Hindley-Milner type will be chosen
15:38:10 <nominolo> If you give an annotation, you get the higher-rank type
15:38:40 <nominolo> this means it's fully backwards compatible with Hindley/Milner
15:38:43 <ichor> nominolo. Cool. That sounds nice.
15:39:23 <nominolo> yeah,  but apparently there are problems with integrating this with GADTs and type families etc.  So SPJ is moving away from impredicativity
15:39:36 <nominolo> (as mentioned in the error message of my paste)
15:41:20 <nominolo> I suppose if that change happens then everyone who wanst impredicativity will move to Agda ;)
15:41:27 <nominolo> *wants
15:42:22 <ichor> nominolo, maybe I should check out Agda then. Not that I use impredicativity very much for anything useful. But it's fun to play with.
15:42:50 <Saizan> well, Agda is predicative.
15:43:04 <Saizan> though you can play with universe polymorphism
15:43:16 <nominolo> not if you turn on set-in-set ;)
15:43:51 <Saizan> ah well :)
15:44:17 <nominolo> (I think)  (I'm in no way an Agda expert)
15:44:41 <Saizan> yeah, you get impredicativity because the whole stratification collapses
15:45:19 <ichor> nominolo, thanks a lot for your help and time. I got to go now. Cya.
15:46:42 <Saizan> but that's an inconsistent system, while i think impredicativity only in Set0 and not in the universes above would still be consistent
15:51:15 <ksf> what happened to transformers' Control.Monad.Trans?
15:52:11 <ih> has anyone installed ghc platform on karmic koala?
15:57:14 <pastorn> ih: no, i used the GHC binary blob
15:57:22 <pastorn> then i use cabal to install stuff
15:57:43 <ih> ok, thanks
16:00:52 * Mathnerd314 wonders what would happen if liftM2 == id
16:01:38 <EvanR> and speed of light were twice as fast ;)
16:03:09 <Mathnerd314> or rather, id was a typeclass instead of a function and liftM2 was defined to be an instance
16:03:12 <benmachine> I wonder what it would look like if the speed of light was like 30mph
16:03:28 <Mathnerd314> pretty slow
16:03:30 <benmachine> Mathnerd314: hmm, how would that work?
16:03:44 <benmachine> Mathnerd314: also, you would age less if you went jogging
16:03:50 <EvanR> yeeeah
16:04:15 <EvanR> in reality its like changing the speed of light causes atoms to fall apart or nuclear reactions to not work
16:04:27 <Mathnerd314> everyone would be overweight from moving at relativistic speeds :-)
16:04:41 <benmachine> yeah we tried changing the speed of light and then some atoms fell apart so we put it back
16:04:58 <EvanR> lol
16:07:41 <chrisdone> still working on it but thought I'd show you guys what I've got done tonight: http://82.33.137.16/haskell-website/
16:08:06 <benmachine> neat
16:08:44 <srush> what should I do if ghc just hangs during compilation?
16:08:50 <chrisdone> it should work on all modern browsers this time, including ie6/7/8, those pesky ones
16:09:06 <srush> [6.10.4] hangs in both ghc --make and ghci
16:09:26 <Mathnerd314> the other-language links at the bottom look really ugly compared to english :-(
16:10:17 <benmachine> srush: depends, did you enable UndecidableInstances?
16:10:38 <srush> I have flexiblecontexts
16:11:15 <benmachine> that's not undecidableinstances :P
16:11:24 <srush> good point
16:11:27 <benmachine> you might consider submitting a bug, is your program small?
16:12:49 <srush> no unfortunately
16:12:58 <chrisdone> even for big programs you can strip out code until it stops repeating the problem
16:13:18 <chrisdone> I reduced a big project compile bug down to one line and then submitted that line
16:13:36 <srush> that's sound incredibly painful
16:13:47 <srush> is there a way I can get a verbose compilation?
16:14:36 <srush> hmm, -v gives stuff
16:14:42 <chrisdone> it was painstaking but it saves the ghc guys work and that would make me want to fix a bug more =)
16:14:58 <benmachine> mmhm
16:15:15 <srush> *** Renamer/typechecker:
16:15:25 <srush> guess that makes sense
16:15:50 <mreh> kleisli == clay-slee?
16:17:34 <FliPPeh> I'm starting to love Gtk2hs
16:18:10 <FliPPeh> Just build a GUI frontend for my rapidshare loader. and it doesn't even crash.
16:18:18 <FliPPeh> s/build/built/
16:18:29 <Polarina> I could use some XCB bindings...
16:18:31 * shapr boings quietly
16:18:43 <byorgey> mreh: not 'ay', 'eye'
16:18:47 <FliPPeh> Polarina: interface 'em yourself :)
16:18:56 <Polarina> FliPPeh, that's the plan.
16:19:13 <mreh> byorgey, cly-slee?
16:19:22 <byorgey> mreh: right
16:19:30 <FliPPeh> Is it too performance critical for Haskell-X11, Polarina?
16:19:56 <chrisdone> shapr: whaddayathank? http://82.33.137.16/haskell-website/
16:21:00 <Polarina> FliPPeh, I just want to use XCB. :)
16:21:07 <dons> chrisdone: awesome! is that a live mediawiki?
16:21:08 <FliPPeh> :)
16:21:32 <FliPPeh> Polarina: Make it opensource, I might participate if I feel up to the task
16:21:43 <dons> so that's a restyling of the current template/Main setup, right chris?
16:22:07 <Polarina> chrisdone, http://jigsaw.w3.org/css-validator/validator?uri=http://82.33.137.16/haskell-website/
16:22:24 <Polarina> FliPPeh, it's going to be a direct binding, no fancy stuff. :)
16:22:53 <EvanR> chrisdone: hey. "try haskell" link dont work :(
16:23:05 <FliPPeh> Polarina: That's what I was hoping ;D
16:23:30 <Polarina> FliPPeh, :D
16:24:46 <chrisdone> Polarina: I'm aware it's not standard css. thank internet exploder for that
16:25:35 <Polarina> chrisdone, ignore it.
16:25:42 <FliPPeh> Gah, I hate all the little details about GUI programming.. make the window's contents resize with the window, make them columns stretch to use the space...
16:25:43 <Polarina> chrisdone, /ignore is your friend. :Þ
16:26:20 <chrisdone> FliPPeh: having spent a few hours to get tabs to work across browsers, I feel you
16:26:27 <mreh> can't we teach people who like to do things like tweak GUIs haskell
16:26:42 <FliPPeh> chrisdone: Don't get me started about web programming and CSS
16:26:44 <mreh> I think haskell will never catch on with the people we haskellers really need
16:26:44 <chrisdone> Polarina: you can't really have that attitude for a big site
16:26:54 <mreh> the team players
16:26:54 <chrisdone> I know you're (probably) joking, but yeh
16:26:58 <FliPPeh> chrisdone: Whenever someone wanted a website from me, I told them I'm not gonna support IE6.
16:27:20 <FliPPeh> Rather rip my ears out.
16:28:17 <mreh> is there any way to make programming C++ bearable? It seems the defacto standard in game these days
16:28:26 <chrisdone> one could write an abstraction upon css and html as a language. powerful enough to do custom design but restricted enough to be cross-browser. =)
16:28:30 <mreh> s/game/games/
16:28:34 <FliPPeh> mreh: Abstraction?
16:28:53 <FliPPeh> Makes C++ a bit more... bearable.
16:29:08 <FliPPeh> chrisdone: That's a hell of a task
16:29:29 <mreh> chrisdone, that's a never ending task
16:29:37 <chrisdone> FliPPeh: well you can start from the basics, make some atoms and build up from there
16:29:52 <FliPPeh> I don't know how things are today, but I know IE6 was a pain in the ass
16:30:16 <FliPPeh> Like that child, the one that always does things his own way
16:30:18 <chrisdone> ie6 still is a pain in the ass. it's still old and retarded
16:30:45 <FliPPeh> and it's still in use
16:31:29 <chrisdone> you could write the composition language as a haskell EDSL :p
16:31:33 <chrisdone> I might try it on the weekend
16:31:42 <FliPPeh> :q
16:31:56 <FliPPeh> Arhgghh, why do all my programs take two Ctrl-C to quit?
16:32:31 <mreh> tomorrow is a bank holiday, you can start early
16:32:43 <mreh> after mass
16:32:55 <mreh> or during mass
16:34:53 <kmc> mreh, learn Boost
16:35:11 <kmc> it has things like Maybe (1,000 lines of code) and parser combinators (100,000 lines of code)
16:35:38 <mreh> I honestly thought that was related to mass
16:35:42 <mreh> ick :)
16:36:10 <mreh> some people are really overly keen to compromise
16:36:41 <mreh> someone please comment on the Haskelloids wiki page
16:36:49 <mreh> i want to hear your opinions
16:37:02 <olsner> 100000 lines? how big is parsec anyway?
16:37:42 <mreh> less than 10,000
16:37:56 <sundaymorning> what did you write haskelloids with?
16:37:56 <mreh> an order of magnitude less, possibly two
16:38:01 <mreh> sundaymorning, Yampa
16:39:13 <sundaymo1ning> hm, somehow I cannot connect to haskell.org
16:39:15 <sundaymo1ning> go figure
16:39:24 <kmc> the best part is, C++ lets you overload operators but not define new ones
16:39:40 <kmc> so you have to express your parser's grammar in terms of bitwise and and or, array indexing, and pointer dereference :D
16:39:49 <ddarius> olsner: Less than 5000 lines even for Parsec 3.
16:39:49 <mreh> :D :D :D
16:40:39 <benmachine> 3274 according to my sources
16:41:15 <ddarius> (Also, those are wc -l lines.)
16:41:19 <olsner> nice
16:41:49 <olsner> kmc: oh, and precedence is fixed too
16:41:59 <mreh> what shell command did you use to wc all the files in the src dir?
16:42:31 <kmc> find -name \*.[ch]pp | xargs wc -l
16:42:59 <mreh> [ch]pp?
16:43:06 <benmachine> mreh: I used find -name \*hs -exec wc -l {} +
16:43:08 <mreh> haskell or cpp?
16:43:12 <benmachine> on parsec
16:49:13 <mreh> haskelloids is a whopping 1182
16:49:16 <mreh> I'm impressed
16:49:33 <mreh> also slightly disappointed it was so many
16:49:53 <FliPPeh> On the documentation for threadDelay, it says that it's not guarantee'd that it'll reschedule in time
16:50:06 <FliPPeh> But how high is the chance it will not reschedule on time?
16:50:16 <FliPPeh> Frequently?
16:50:45 <FliPPeh> Reliably enough for counting down per-second?
16:51:48 <olsner> well, it's not really reliable at all, that's why it doesn't guarantee anything :P
16:55:56 <FliPPeh> Well
16:56:02 <FliPPeh> Looks really reliable here
16:56:36 <danderson> FliPPeh: I think the warning is just the standard warning of delay syscalls in a preemptively scheduled environment
16:56:59 <FliPPeh> I think it's stable enough for my autodownloader :)
16:57:05 <FliPPeh> As long as it's not realtime
16:57:05 <danderson> the alarm in the kernel will expire at exactly the time you gave, but if the kernel is busy or your process has ran out of its time quantum, you're out of luck
16:57:17 <olsner> I think the point is it shouldn't be used for time-keeping so e.g. adding to a counter for each "tick" of threadDelay wouldn't give you a correct time
16:57:18 <danderson> so don't use it for hard realtime medical robots
16:57:19 <FliPPeh> Ahaa
16:57:40 <olsner> (oh, and obviously not for real-time either)
16:57:41 <danderson> but for operating on the squishy slow human levels of elapsing time, it works just fine in most cases.
16:57:47 <FliPPeh> I write my hard realtime medical robots in C, so I can blame the language for failure
16:59:22 <FliPPeh> Now for the last part of my awesomeness.. I have a file to download.. if I'd want to display a progress, I probably have to use sockets, heh?
16:59:33 <FliPPeh> Network.HTTP won't let me query the time..
17:01:48 <edwardk2> FliPPeh: hrmm, do you get any sort of callbacks out of chunkedTransfer or something
17:02:24 <FliPPeh> edwardk2: As far as I know (and I'm pretty sure) I can only start the downloading
17:02:31 <FliPPeh> But not cancel/query the process
17:03:22 <edwardk2> hrmm probably not with the main api, you'd have to rewire some things using base, and they aren't very good about exporting everything you need to do something similar but different
17:03:45 <danderson> good grief, that's a large program
17:03:57 <danderson> my Hakyll website generator compiles to 11MB stripped
17:04:22 <alpounet> @hoogle (</>)
17:04:22 <lambdabot> Text.Html (</>) :: (HTMLTABLE ht1, HTMLTABLE ht2) => ht1 -> ht2 -> HtmlTable
17:04:22 <lambdabot> System.FilePath.Posix (</>) :: FilePath -> FilePath -> FilePath
17:04:22 <lambdabot> System.FilePath.Windows (</>) :: FilePath -> FilePath -> FilePath
17:04:29 <FliPPeh> danderson: My download program is 15 MB
17:04:37 <FliPPeh> 14 MB of that is Gtk
17:05:17 <edwardk2> it looks like you're stuck implementing it yourself
17:05:26 <FliPPeh> Meh
17:05:29 <edwardk2> or getting them to patch http to add callback hooks somewhere
17:07:52 <FliPPeh> Hm
17:07:59 <FliPPeh> Network.Browser has "setEventHandler"
17:08:32 <benmachine> dons: are you responsible for the arch GHC packages? I just upgraded from 6.12.1-2 to 6.12.1-4 and it seems to have been expecting me to have a /usr/share/haskell, and I don't (it's also told me all cabalized packages need to be reinstalled, even though I already had 6.12 and everything seems to work fine)
17:08:34 <FliPPeh> But it's got only OpenConnect, ReuseConnection, RequestSent, ResponseEnd, ResponseData and ResponseFinish
17:08:55 <FliPPeh> benmachine: I had the same
17:09:07 <FliPPeh> The cabalized packages failed with a libgmp error for me
17:09:23 <benmachine> oh grr
17:09:44 <benmachine> I still don't have a /usr/share/haskell though
17:09:50 <FliPPeh> Neither do I...
17:09:52 <FliPPeh> I suppose
17:10:04 <FliPPeh> I do!
17:10:07 <FliPPeh> Mad world.
17:10:54 <benmachine> I am peeved about this libgmp thing
17:11:12 <dobblego> is there a library for doing software dependency resolution?
17:12:25 <edwardk2> dobblego: constraint analysis like cabal uses?
17:13:08 <dobblego> edwardk2, I'm not sure of any proper names; I have an idea of a general algorithm in my head, but I think it is NP complete
17:13:28 <edwardk2> dobblego: it is, dcoutts wrote something up on it once
17:13:33 <edwardk2> you can encode 3-sat into it
17:13:55 <dobblego> edwardk2, ok, what is the general accepted solution?
17:14:41 <FliPPeh> Why did they turn kernel.org upside down? :(
17:15:02 <edwardk2> FliPPeh: hahahaa
17:15:32 <edwardk2> dobblego: there are good heuristics for when you don't need to backtrack
17:15:45 <dobblego> edwardk2, let me write up some code
17:15:53 <edwardk2> dobblego: it is one of the problems i'm going to have to start dealing with in the next few days so i'm also interested in the solution
17:16:13 <edwardk2> though my version policies are a bit more complicated =/
17:17:26 <edwardk2> because while the app specifies the minimum known compatible and maximum known compatible version of a dependency the installed version of a dependency tells you that it is compatible with its own previous api down to a given version.
17:17:31 <edwardk2> so i have a third variable to juggle.
17:18:47 <dobblego> http://paste.pocoo.org/show/196585/ here is what I am thinking
17:19:22 <edwardk2> dobblego: that works until you start allowing things like cabal which allows multiple dependency sets
17:19:36 <dobblego> what is a multiple dependency set?
17:21:03 <edwardk2> you can say, that you work with base < 4 or that you work with base >= 4 && < 5 but if you do, now you need the split out base libs of array, containers, etc.
17:21:13 <edwardk2> so you now have a fork in the possibilities.
17:21:29 <Mathnerd314> could you do a topological sort of the dependency tree?
17:21:48 <dobblego> I am assuming that if you work with M1 you must also work with M2
17:21:50 <edwardk2> when it is conjunctive all is good. you just wind up with narrowing ranges. disjunction has potentially exponential case explosion
17:22:29 <edwardk2> dobblego: but that is rarely the case, upgraded libs eventually deprecate and remove stuff, gnu versioning policy also encodes that into the version number of the library
17:22:41 <Mathnerd314> edwardk2: when would disjunction occur?
17:22:47 <dobblego> edwardk2, then they become new values for M
17:23:27 <edwardk2> mathnerd (base >= 3 && < 4) || (base > 4 && array && containers
17:24:00 <edwardk2> dobblego: but then you still have disjunction, because now you might have a lib that doesn't care about the changed part that is compatible with both M1 and M2.
17:24:41 <dobblego> edwardk2, then why would it be concerned that it got M2 and not M1?
17:24:43 <edwardk2> Mathnerd314: it crops up when packages start to split, etc.
17:24:55 <Mathnerd314> ah, they split base up into several libraries
17:24:58 <edwardk2> dobblego: because another package may care about the now broken api
17:25:21 <edwardk2> dobblego: i'm simply saying that renaming the package on every backwards incompatible change is a tricky proposition
17:25:26 <dobblego> edwardk2, then M2 is not truly a successor to M1 and should not be represented that way?
17:25:28 <edwardk2> and doesn't fix the disjunction problem
17:27:47 <edwardk2> dobblego: in the libtool versioning scheme you encode the most recent interface number, you support, the current interface number, and the difference between the newest and oldest interfaces that the library supports. which gets reset to 0 when you make a breaking change
17:28:31 <edwardk2> dobblego: and then clients can say that they need something that provides a version between x and y. because they know the subset of features they interact with
17:29:14 <dobblego> edwardk2, ok, I'll take one of those thanks :)
17:29:15 <alpounet> bos, around ?
17:29:24 <bos> sorta
17:29:24 <edwardk2> http://www.gnu.org/software/libtool/manual/html_node/Libtool-versioning.html#Libtool-versioning
17:30:31 <edwardk2> http://www.gnu.org/software/libtool/manual/html_node/Updating-version-info.html#Updating-version-info might be a better guide to how to use the scheme
17:30:44 <dobblego> is there such a library on hackage?
17:31:21 <alpounet> bos, I run into "Couldn't match expected type 'U.Vector Double' against inferred type Sample" errors when playing around statistics, any clue ?
17:31:31 <alpounet> (working on the linear regression things)
17:31:35 <edwardk2> dobblego: not that i know if, theoretically you mgiht be able to borrow some of cabal's resolver, but i doubt it is exposed nicely
17:33:23 <edwardk2> dobblego: i'm curious as to what a better way to encode it might be, and have the opportunity to define my own package format at the moment. i.e. perhaps to split out separate versions by 'feature' set provided by the package?
17:33:44 <dobblego> edwardk2, I feel like if I tried, it would be rather naive
17:33:52 <edwardk2> i.e. this package provides feature xyz with version a.b.c, and feature hjk with version ...
17:34:04 <edwardk2> shall we move this to #haskell-overflow?
17:34:22 <dobblego> ok
17:36:23 <bos> alpounet: could be a newtype thing
17:36:54 <alpounet> bos, I'm just mixing functions from Data.Vector with ones from Statistics.Sample, to compute the regression coefficients
17:37:06 <alpounet> I did not introduce any new type or somesuch
17:38:45 <bos> alpounet: are you sure you don't have a version mismatch or something?
17:39:25 <alpounet> oh
17:39:39 <alpounet> you've updated statistics few days ago
17:39:41 <alpounet> didn't notice
17:39:51 <alpounet> I'm installing the new version
17:39:56 <alpounet> it should work fine after that
17:39:57 <alpounet> thanks
17:49:14 <FliPPeh> HAhhh
17:49:18 <FliPPeh> I found my downloader!
17:49:19 <FliPPeh> CURL!
17:49:25 <benmachine> maaan curl is lame
17:49:30 <pastorn> hehe
17:49:33 <benmachine> it's not even pure haskell!!
17:49:38 <FliPPeh> But it has callback
17:49:39 <pastorn> FliPPeh: yeah, write your own stuff
17:49:39 <benmachine> how can you LIVE with yourself
17:49:52 <benmachine> submit patches to HTTP
17:49:54 <FliPPeh> benmachine: Write me a pure haskell downloader with callback then!
17:49:58 <benmachine> no u
17:50:01 <FliPPeh> OR I'LL DO IT!
17:50:04 <FliPPeh> I swear, I'll use Curl.
17:50:21 <pastorn> http://bbsimg.ngfiles.com/1/20229000/ngbbs4ae2d79d92aab.jpg
17:50:22 <benmachine> some people are beyond saving
17:50:25 <pastorn> FliPPeh: ^^
17:50:38 <benmachine> they will never see the Light
17:50:43 <FliPPeh> I miss the brofist :(
17:50:50 <pastorn> NONE FOR YOU
17:51:23 <monochrom> why do you need "callback" for mere downloading
17:51:43 <FliPPeh> monochrom: To display progress
17:51:49 <benmachine> FliPPeh: btw, the libgmp thing I think only requires you rebuild executables
17:51:56 <FliPPeh> Like "OMGDOWNLOAD 59.349870%!!!1111"
17:52:00 <FliPPeh> Yep
17:52:13 <monochrom> I see.
17:52:45 <benmachine> FliPPeh: I think it might be possible to do that with HTTP defining a custom HStream instance, actually
17:52:49 <monochrom> You should not think in terms of callbacks. You should think in terms of suspendible, resumable continuations.
17:52:52 <dankna> Opinion question time.
17:52:54 <dankna> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24589#a24589
17:53:02 <dankna> Is it poor style that two of the methods are actions in a monad and the rest are not?
17:53:09 <temoto> What is 'registering' stage in new cabal?
17:53:21 <monochrom> And iteratees.
17:53:38 <FliPPeh> monochrom: Like how?
17:53:38 <micah> can anyone help me improve my error messages in parsec? they're worse than gcc's
17:53:41 <benmachine> dankna: nah, I don't think so
17:53:46 <FliPPeh> micah: "User is drunk"
17:53:49 <dankna> benmachine: thanks.
17:53:52 <FliPPeh> Works for every error
17:53:53 <pastorn> dankna: couldn't you just write ONE big function and derive the others?
17:53:57 <pastorn> that seems nasty
17:54:09 <dankna> pastorn: haha, writing one big function strikes me as the nastier approach
17:54:16 <monochrom> Iteratees allow you to add one layer for displaying progress.
17:54:28 <pastorn> well, instancing might not be as bad, then :)
17:54:31 <micah> I have a control structure (it's an algol), and a statement inside has an error, but the parser says that the error is at the start of the control structure
17:54:53 <benmachine> dankna: Traversable and Foldable both use other typeclasses in some of their methods
17:55:04 <dankna> benmachine: hmm I see
17:55:06 <FliPPeh> monochrom: You mean recursivly read Data
17:55:10 <FliPPeh> by myself.
17:55:17 <benmachine> so I don't think it's a big deal
17:55:21 <FliPPeh> That'd require me to write an HTTP downloader
17:55:32 <dankna> well, it's good to have the second opinion on it
17:56:25 <benmachine> dankna: this opinion is provided in the hope that it will be useful, but without any warranty
17:56:31 <benmachine> not even the implied warranties of merchetc.
17:56:36 <dankna> haha
17:56:39 <dankna> noted
17:56:47 <benmachine> :)
17:57:08 <micah> the error messages are absolutely useless, but I have no idea how to improve them
18:03:09 <Polarina> Why do people use StablePtr instead of the ordinary Ptr?
18:03:46 <FliPPeh> What would happen, if a thread fills stuff in a ByteString, and from another thread I read the length of that bytestring?
18:03:54 <monochrom> perhaps the garbage collector moves one but not the other.
18:03:59 <FliPPeh> Will I get the current snapshot of the length, or mess sh** up?
18:04:04 <benmachine> FliPPeh: depends how it was filled, and what sort of length?
18:04:14 <FliPPeh> benmachine: Bytes length
18:04:28 <sjanssen> FliPPeh: you can't change the length of a ByteString
18:04:29 <lambdabot> sjanssen: You have 1 new message. '/msg lambdabot @messages' to read it.
18:04:31 <benmachine> FliPPeh: umm, how would you give the length-measuring thread access to the bytestring?
18:04:32 <FliPPeh> And I mean, get the length WHILE it's being filled
18:04:43 <benmachine> yeah I think I didn't mean to ask what sort of length
18:04:46 <benmachine> but I can't remember what I did
18:05:16 <FliPPeh> Probably a TChan or something
18:05:20 <monochrom> By the time you obtain a bytestring, it is already filled, isn't it?
18:05:31 <benmachine> FliPPeh: yeah but how would you put it in the TChan?
18:05:34 <FliPPeh> monochrom: I'm working with threads
18:05:37 <Lemmih> Polarina: They are two completely different things who happen to share a similar name. Kinda like Java and Javascript.
18:05:51 <FliPPeh> So two parallel read/writes
18:05:51 <monochrom> I'm working with threads too.
18:05:59 <Polarina> Lemmih, alright, and what's different between those two?
18:06:18 <FliPPeh> I need to find ANY way to find out how much has been downloaded so far
18:06:39 <FliPPeh> And if those libs provide no way to see that, I'll hack it in
18:07:07 <alpounet> bos, would you like a regression module in statistics or should I put it in a separate package ?
18:07:14 <monochrom> There is no MVar or IORef in a bytestring. It is not mutable. There is no such thing as "at one time it has nothing, at a later time it has stuff", at least not visible to your threads.
18:07:17 <Lemmih> Polarina: A StablePtr is an unchanging referrence to a Haskell object.
18:08:00 <FliPPeh> If I use "IORef ByteString"?
18:08:07 <FliPPeh> Should give me a mutable byte string
18:08:22 <Polarina> Lemmih, I am binding to a function that returns a pointer to an object the C library controls and manages -- I must not modify or free it. What would be more appropriate?
18:08:26 <FliPPeh> read it somewhere, get the length, stuff more read data in
18:08:33 <Polarina> FliPPeh, you can also use MVar.
18:08:41 <FliPPeh> Or that
18:08:49 <Lemmih> Polarina: Haskell objects are often moved by the GC. This can make it problematic to referrence Haskell objects from outside the scope of the GC (in C land, for example).
18:08:50 <nominolo> FliPPeh: no, it gives you mutable pointer to an immutable byte string
18:09:06 <monochrom> You are blinded by your desire.
18:09:07 <FliPPeh> I know values are immutable
18:09:10 <Lemmih> *reference
18:09:37 <nominolo> lazy bytestrings are made of chunks, so you can process one chunk at a time
18:09:38 <benmachine> FliPPeh: look at HStream, it should allow you to do arbitrary I/O (including writing to chans or whatever) during an HTTP download
18:09:43 <benmachine> http://hackage.haskell.org/packages/archive/HTTP/latest/doc/html/Network-TCP.html#t%3AHStream
18:09:51 <Polarina> Lemmih, hmm...
18:10:09 <nominolo> while one chunk is being consumed, the next chunk is filled in
18:10:17 <nominolo> standard macro-pipelining
18:10:22 <monochrom> There is a reason mutable array is not IORef ImmutableArray
18:10:25 <Lemmih> Polarina: A StablePtr is a key. You can ask the RTS for the current location of the object associated with that key.
18:10:33 <Polarina> Key?Ð
18:10:36 <Polarina> s/Ð//
18:11:03 <Lemmih> Polarina: Yes, a key.
18:11:10 <Polarina> What do you mean?
18:13:05 <ddarius> monochrom: Silly.  It's ImmutableArray . IORef
18:13:07 <Lemmih> Polarina: It is just a piece of information that you can use to get the address of a Haskell object with.
18:13:11 <Polarina> Lemmih, do you happen to know of a paper or some reference to which explains different use cases of those two?
18:13:23 <Lemmih> Polarina: It does not point to something in the same way a Ptr does.
18:13:48 <Lemmih> Polarina: They are completely different. There are no similar use cases.
18:14:04 <Polarina> Use cases of when to use which.
18:14:54 <Polarina> I still do not understand why these two are different from eachother. What makes them different?
18:15:15 <Lemmih> Polarina: Do you want to keep track of Haskell objects outside of the GHC RTS? If so, use StablePtr. If not, don't use them.
18:16:01 <Polarina> Lemmih, like when giving a C library some data to work with, which the C library will manage afterwards?
18:16:13 <monochrom> "A stable pointer is a reference to a Haskell expression that is guaranteed not to be affected by garbage collection"
18:16:48 <monochrom> If you want to pass data to foreign code, and that foreign code needs it unmoved for a prolonged period.
18:17:16 <Lemmih> Polarina: Not quite. No C library can manipulate raw GHC closures. It's only used when you want to pass the objects back into Haskell land at some point in time.
18:17:28 <monochrom> E.g. the foreign code saves that pointer in its global variable and go read that data again and again in the next two hours.
18:17:46 <Polarina> Lemmih, ah.
18:17:51 <Polarina> Lemmih, like a callback function?
18:17:58 <Lemmih> Polarina: Yes, exactly.
18:18:09 <Polarina> Now I understand. :)
18:19:39 <monochrom> Why is haskell so hard to understand for imperative programmers? I mean, all this why IORef ByteString is not mutable bytestring and what special semantics StablePtr has are like imperative programming 101.
18:20:32 <monochrom> If you ever did assembly code, this is like common sense, computer organization, architecture.
18:21:10 <Polarina> monochrom, it's not that hard if you try not to relate haskell with the imperative world.
18:21:17 <kmc> but you need to relate them
18:21:21 <kmc> because some code needs to be imperative
18:21:25 <Polarina> At least not that hard.
18:21:26 <kmc> and Haskell's IO monad is an imperative language
18:21:50 <Lemmih> Are StablePtrs common? Aren't they only used when dealing with FFIs?
18:21:55 <kmc> yeah
18:22:05 <thunderbolt> Does ubuntu karmic have a cabal package somewhere?
18:22:15 <Veinor> nope, sorry.
18:22:22 <kmc> i think StablePtr is only useful for some specific things in FFI
18:22:52 <kmc> it turns a Haskell value into an opaque "handle" that you can pass to a C function, such that the C function can pass it back to Haskell and you can get at the original value
18:23:07 <aavogt> thunderbolt: once you have ghc it's relatively easy to find the corresponding version of cabal-install and run it's bootstrap.sh
18:23:12 <kmc> it's not a "pointer" in the same way that Ptr and ForeignPtr are
18:23:25 <Lemmih> kmc: Yes yes, we just went over all that. (:
18:23:31 <kmc> ah, my connection dropped
18:23:46 <thunderbolt> aavogt: Yeah, just making sure I didn't mess anything obvious.
18:23:48 <Lemmih> kmc: I was referring to "what special semantics StablePtr has are like imperative programming 101."
18:23:53 <Lemmih> By monochrom.
18:24:23 <kmc> opaque handles are pretty common in assembly and C
18:25:02 <monochrom> GCless imperative language pointers are stable pointers, as in, not moved.
18:25:36 <monochrom> I don't know whether Java has a similar thing.
18:26:21 <lpsmith> I'm having a weird problem re-compiling gtk2hs that I've never had before;  same directory on the same machine I have successfully compiled
18:26:55 <monochrom> C programs have been written to exploit pointer stability. OSes rely on it.
18:28:42 <Lemmih> monochrom: I think many imperative programmers aren't really aware of that. Kinda like fish aren't all that aware of the water they swim in.
18:29:39 <kmc> when i interviewed candidates for a programming job, a good number of them seemed to think that a computer was a machine for executing Java source code
18:29:49 <kmc> they didn't know what a "pointer" or a "CPU instruction" was
18:29:57 <kmc> and they thought of execution purely in terms of source lines of code
18:30:00 <kmc> so fewer lines => faster
18:30:05 <lpsmith> I reran configure and then make, but the Makefile has a "missing seperator"
18:30:14 <[swift]_> i am always amazed when people tell me that they don't understand pointers
18:30:28 <[swift]_> are they really that complex?
18:31:40 <[swift]_> i'd argue if you can understand arrays, you can understand pointers
18:31:45 <kmc> hmm
18:31:55 <kmc> because a pointer is an index into the array of bytes that is memory?
18:32:21 <[swift]_> kmc: yeah, that's usually what i tell people
18:32:35 <kmc> part of the problem might be that in C, everything secretly has an address and then you learn this one day and start using this fact
18:32:44 <kmc> might be clearer if you only got addresses by allocation
18:32:50 <kmc> might also make a better language
18:33:01 <kmc> sick of debugging people's code when they return pointers to local stack variables
18:33:30 <[swift]_> kmc: ah yes, the stack. another thing people don't understand, but unlike pointers, they don't even KNOW that they don't understand it
18:33:53 <thunderbolt> the semicolon in haskell doesn't have any semantic difference than a line ending, correct?
18:34:12 <thunderbolt> For example:     forever a = do a; forever a is equivalent to forever a = do a\nforever
18:34:57 <twink> Stack addresses do come up in other contexts in C.
18:35:21 <monochrom> oh at least they return pointers to existed-for-once-upon-a-time local stack variables. My classmate did further: "char *p; strcpy(p, "hello");". pointers to nowhere.
18:35:22 <dons> thunderbolt: it has semantic meaning inside a 'do' block
18:35:30 <dons> in that it corresponds to the >> operator
18:35:41 <dons> ?undo forever a = do a; forever a
18:35:41 <lambdabot> forever a = a >> forever a
18:35:41 <thunderbolt> dons: Thanks, I thought it probably would be something like that.
18:35:50 <dons> meaning that ';' is *programmable* in haskell
18:35:57 <dons> it will mean whatever >> is in the monad you're in
18:36:08 <monochrom> Their reasoning: the type signature of strcpy wants a char* from me, so I declared a char* and give it.
18:36:21 <dons> in a pure context, ; is \n
18:36:30 <thunderbolt> dons: Right.
18:36:49 <Lemmih> dons: How was the hackathon? I wish I could have attended this year.
18:37:11 <dons> Lemmih: it was very big, (80 people), and we did lots of interesting things. have you seen the photos?
18:37:14 <dons> many new  people!
18:37:15 <ivanm> Lemmih: well, there's at least two more being proposed for this year...
18:39:00 <Lemmih> ivanm: I better ramp up my prostitution so I can afford the next one! (:
18:39:10 <ivanm> heh
18:39:19 <ivanm> why, where are you based?
18:39:46 <Lemmih> Scandinavia.
18:39:52 <stulli> How can i imagine a hackathon? Are there only Haskell gurus or also beginners?
18:40:17 <stulli> Seems like the projects that get hacked on are pretty advanced
18:40:17 <Lemmih> Flying to Baltimore would be a very expensive affair.
18:40:17 <dons> not so much beginners. but interested people with project ideas.
18:40:59 <FliPPeh_> I think I found a way!
18:41:00 <FliPPeh_> Yay.
18:41:13 <benmachine> FliPPeh_: is it the way I told you like twenty minutes ago ¬_¬
18:41:31 <benmachine> unless you're doing something else now
18:42:36 <thunderbolt> What's the best way to determine where a function used in a haskell file was imported from?
18:42:39 <FliPPeh_> benmachine: If you told me about using "Network.HTTP.HandleStream", opening a HStream instance with an HTTP request header, thus being able to call "readBlock", then yes
18:42:44 <thunderbolt> I mean, as you're reading the code.
18:43:23 <benmachine> FliPPeh_: hmm, possibly
18:43:39 <benmachine> FliPPeh_: you're let off this time :P
18:43:41 <FliPPeh_> benmachine: Yup, but at that time I didn't know how to use that
18:44:11 <monochrom> The best way is to write it in the import statements, e.g., instead of import Everything, I write import Everything(fields, turing, nobel).
18:44:30 <thunderbolt> monochrom: Okay, that makes sense.
18:44:46 <fax> :S
18:44:51 <thunderbolt> monochrom: Is that prevalent in Haskell code, the way you do it?
18:45:06 <monochrom> I estimate only 50% prevalent.
18:45:08 <ivanm> Lemmih: I'm guessing that flying to Sydney would be even more expensive? :p
18:45:11 <stulli> thunderbolt: I use hoogle or hayoo
18:45:40 <ivanm> thunderbolt: if you load it into ghci, do a :info foo , and it should tell you
18:45:58 <thunderbolt> Thanks, these are all excellent answers.
18:46:02 <monochrom> Sometimes you can get ghci to tell you, if you make sure ghci loads exactly the same modules you import.
18:46:15 <ivanm> I generally do a "global" import of other modules within the same project and only import specific functions/types for external modules
19:02:25 <gr00vy> putos
19:06:46 <DarthHaskell> whats the best way to call haskell code from c
19:07:09 <pikhq> foreign export
19:07:53 <DarthHaskell> do I have to use ghc to compile the source o can I use gcc
19:08:35 <benmachine> you use ghc to compile the haskell
19:08:41 <benmachine> gcc to compile the c
19:09:45 <DarthHaskell> ok, is it possible to make shared libs?
19:10:08 <ivanm> DarthHaskell: in which OS?
19:10:58 <dons> http://www.haskell.org/haskellwiki/Calling_Haskell_from_C
19:12:03 <pastorn> dons: dude! that's sooooo sweet :D
19:13:14 <ivanm> pastorn: what, that there's a wiki page that covers this already?
19:13:18 <pastorn> c libraries written in haskell :)
19:13:32 <pastorn> ivanm: didn't know this was possible
19:13:39 <ivanm> ahhh
19:13:47 <pastorn> i only knew about the other way around, which i might be using pretty soon
19:14:10 <pastorn> i wanna load the stanford bunny model, but the loader is in C
19:14:14 <pastorn> (i think)
19:14:26 <pastorn> and i DON'T want to write a loader for that format :)
19:14:32 <pastorn> so i'm thinking of wrapping it
19:14:48 <Zao> pastorn: FFI to assimp maybe?
19:15:33 <edwardk> pastorn: the bunny has been converted to just about every format known to man though
19:15:34 <pastorn> assimp?
19:15:48 <pastorn> edwardk: still, don't wannna write a loader
19:15:50 <pastorn> wanna wrap one
19:16:18 <Zao> pastorn: http://assimp.sourceforge.net/
19:16:23 <Zao> Awesome name, albeit a bit misleading :)
19:16:35 <Zao> http://assimp.sourceforge.net/main_features_formats.html
19:16:50 <Zao> Imports a ton of formats, and has a C API probably suitable for FFI wrappage.
19:16:54 <FliPPeh_> Lala
19:17:04 <FliPPeh_> I should do more GUI stuff, it's actually fun.
19:17:22 <pastorn> FliPPeh_: what library are you using?
19:17:26 <Entroacceptor> FliPPeh_: so, what did you decide on?
19:17:28 <FliPPeh_> Gtk2hs
19:17:35 <pastorn> FliPPeh_: start using swing... then you won't feel like that
19:17:36 <monochrom> use ncurses
19:17:51 <FliPPeh_> :q
19:17:57 <Entroacceptor> insert a 'project' to my question
19:18:03 <alpounet> don't use I/O.
19:18:17 <FliPPeh_> By the way, I have a question about the following construct...
19:18:19 <pastorn> yes, give him more confusing advice, all at the same time
19:18:23 <FliPPeh_> simpleHTTP (getRequest f) >>= getResponseBody >>= (writeFile (fileNameFromURL f))
19:18:23 <pastorn> gogogo!
19:18:39 <FliPPeh_> This one fetches something from HTTP and writes teh body to a file
19:18:40 <FliPPeh_> BUT
19:18:49 <FliPPeh_> Will it first read everything, and then write it all at once?
19:18:57 <FliPPeh_> Or will lazyness somehow do something strange?
19:19:05 <pastorn> FliPPeh_: lazyness will happend
19:19:12 <FliPPeh_> This seems like a big memory hog
19:19:21 <pastorn> the file writing won't close until you've reached EOF in your stream (i think)
19:19:34 <FliPPeh_> Because it's running and I see no file
19:20:10 <pastorn> FliPPeh_: perhaps this is a buffering issue?
19:20:20 <pastorn> FliPPeh_: if you just print what you get, do you see stuff?
19:20:32 <FliPPeh_> Ahh, it's using 70$ memory
19:21:54 <monochrom> getResponseBody is eager.
19:22:01 <ivanm> was the 6.12.2 RC announcement an april fools as well?
19:22:19 <pastorn> Zao: that library seems totally AWESOME
19:22:35 <FliPPeh> It's trashing my PC.
19:22:47 <FliPPeh> RAM 98%, swap 99%
19:22:52 <pastorn> shiiiit
19:22:59 <FliPPeh> Laptop here :8
19:23:17 <monochrom> RC announcement is too boring for a joke
19:23:39 <FliPPeh> SOOO
19:23:45 <FliPPeh> That was a BAD idea
19:23:50 <FliPPeh> written down
19:24:12 <ddarius> Unlike the announcement of the Haskell language.
19:25:29 <FliPPeh> yuck
19:25:34 <SamB_XP> was haskerl a fools joke ?
19:25:51 <Entroacceptor> haskerl?
19:25:53 <Entroacceptor> sounds nice
19:26:00 <FliPPeh_> Back I am
19:26:04 <Entroacceptor> what was it supposed to be?
19:26:05 <ddarius> SamB_XP: It was supposed to be... but a lot of it actually "came true"
19:26:05 <FliPPeh_> I killed it.
19:26:13 <SamB_XP> ddarius: I know!
19:26:14 <FliPPeh_> Can someone tell me what my mistake was?
19:26:26 <SamB_XP> those crazy perlers thought we weren't kidding, or something
19:26:31 <FliPPeh_> Basically, it killed my RAM. It killed it HARD.
19:26:56 <monochrom> <monochrom> getResponseBody is eager.
19:27:01 <monochrom> from 5 minutes ago
19:27:07 <FliPPeh_> Wasn't able to read it, sorry
19:27:16 <temoto> How to make Handle out of Socket?
19:27:36 <FliPPeh_> monochrom: So basically it reads the whole data from the server into RAM and then writes it all at once back to the file?
19:27:39 <monochrom> too busy talking to listen
19:28:01 <SamB_XP> @hoogle Socket -> Handle
19:28:02 <lambdabot> Network.Socket socketToHandle :: Socket -> IOMode -> IO Handle
19:28:02 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
19:28:02 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
19:28:14 <SamB_XP> hehe
19:28:30 <FliPPeh_> It trashed my PC, so I had to re-login on the laptop, so I was not able to read everything
19:29:00 <SamB_XP> <monochrom> getResponseBody is eager.
19:29:00 <SamB_XP> <ivanm> was the 6.12.2 RC announcement an april fools as well?
19:29:00 <SamB_XP> <pastorn> Zao: that library seems totally AWESOME
19:29:00 <SamB_XP> --> FliPPeh (~lukas@p578F7F62.dip.t-dialin.net) has joined #haskell
19:29:00 <SamB_XP> <FliPPeh> It's trashing my PC.
19:29:00 <SamB_XP> <FliPPeh> RAM 98%, swap 99%
19:29:21 * FliPPeh_ shrugs
19:29:31 <FliPPeh> done here
19:29:32 <pastorn> SamB_XP: hello :)
19:29:33 <monochrom> CDWOM
19:29:38 <FliPPeh_> Meh
19:29:39 <SamB_XP> monochrom: so, is there some less-eager way to do it ?
19:29:40 <pastorn> @slap SamB_XP
19:29:41 * lambdabot pokes SamB_XP in the eye
19:29:49 <pastorn> @botsnack
19:29:49 <lambdabot> :)
19:29:59 <pastorn> SamB_XP: my attack dog :)
19:30:05 <temoto> SamB_XP, thanks.
19:30:10 <FliPPeh> I think it would need support from the HTTP library...
19:30:11 <SamB_XP> @slap lambdabot
19:30:11 * lambdabot secretly deletes lambdabot's source code
19:30:16 <SamB_XP> lol
19:31:25 <DarthHaskell> ok, is it possible to make shared libs from haskell source?
19:31:44 <Makoryu> DarthHaskell: Depends on the OS.
19:31:48 <SamB_XP> DarthHaskell: for what purpose ?
19:31:55 <DarthHaskell> fedora linux
19:32:06 <SamB_XP> do you want to use them in Haskell, or in C?
19:32:08 <ivanm> and depends on the GHC version
19:32:11 <DarthHaskell> c
19:32:51 <FliPPeh> Is there a way to enforce lazyness, like there is one to enforce strictness?
19:33:04 <SamB_XP> you're in luck -- that is supposed to be much more portable than the other thing ;-)
19:33:28 <alpounet> FliPPeh, lazy patterns ?
19:33:35 <FliPPeh> mhh
19:33:40 <SamB_XP> FliPPeh: no, there isn't
19:33:51 <SamB_XP> that's why we have this hear lazy language
19:33:53 <alpounet> that's the closest thing but ... generally pointless
19:33:56 <SamB_XP> er. here
19:34:26 <FliPPeh> Hmmm
19:34:42 <FliPPeh> If I make a custom HTTP request with ByteString.Lazy?
19:37:54 <edwardk> anyone here played with 'funsat' on hackage?
19:39:32 <DarthHaskell> Trying to compile the "Calling Haskell from C" sample code on the wiki I keep getting, Invalid type signature
19:40:01 <pastorn> DarthHaskell: what's your exporting type signature?
19:40:07 <pastorn> (the haskell functions)
19:40:24 <DarthHaskell> http://en.wikibooks.org/wiki/Haskell/FFI
19:40:24 <FliPPeh> Looks like I fixed it
19:40:32 <pastorn> FliPPeh: what was it?
19:40:34 <FliPPeh> 0.8% memory maximum
19:40:39 <DarthHaskell> foreign export ccall fibonacci_c :: CInt -> Ptr CULLong -> Ptr CDouble -> IO CInt
19:40:48 <FliPPeh> pastorn: I replaced the default String type for the contents with a lazy bytestring
19:40:58 <pastorn> DarthHaskell: so...
19:40:59 <FliPPeh> It's running smooth now
19:41:08 <FliPPeh> No "incident yet"
19:41:17 <pastorn> :: Int -> Int64 -> [Double] -> IO Int ?
19:41:29 <pastorn> FliPPeh: hehe, nice
19:41:51 <FliPPeh> It's really strange how much difference lazyness makes
19:42:03 <FliPPeh> And it downloaded just fine
19:42:05 <DarthHaskell> I just copied the code from the haskell wikibook, trying to study the output
19:42:08 <FliPPeh> Now for the content checks...
19:42:14 <pastorn> FliPPeh: nah, ByteString is a wrapped array that has really good performance :)
19:42:19 <DarthHaskell> Not familiar with the c datatypes
19:42:37 <pastorn> DarthHaskell: http://haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/Foreign-C-Types.html
19:42:53 <FliPPeh> And it downloaded uncorrupted!
19:42:57 <FliPPeh> Awesome
19:43:04 <pastorn> FliPPeh: tcp or udp?
19:43:08 <FliPPeh> Too bad I have no progress display... I'll add that later :/
19:43:10 <FliPPeh> TCP
19:43:24 <pastorn> FliPPeh: then a lot is required for it to corrupt :p
19:43:32 <FliPPeh> pastorn: I managed to do it :/
19:43:46 <pastorn> FliPPeh: make a spinning line!
19:43:47 <FliPPeh> Probably because I was such a fan of "readLine", and corrupted binary data with it
19:44:14 <pastorn> | ==> / ==> - ==> \ ==> |
19:44:22 <FliPPeh> Oldschool :)
19:45:22 <temoto> Could anyone please help with this code? http://codepad.org/IVCHb0Uc#comment-Khwr8Bw6
19:45:37 <DarthHaskell> pastron: the code is here http://codepad.org/3WQi21Yc
19:45:47 <FliPPeh> temoto: What'S wrong with it?
19:46:10 <FliPPeh> Oh
19:46:12 <FliPPeh> the comment
19:46:15 <temoto> FliPPeh, i added error message in comment below the paste at the end of page.
19:46:27 <FliPPeh> It's catch
19:46:35 <FliPPeh> It wants explicit types
19:46:43 <FliPPeh> For the IOError
19:47:03 <temoto> basically i tried to combine TCP example from RWH and buzzword 'STM' from here http://sequence.complete.org/node/258
19:47:16 <FliPPeh>  tryLoad = getPage `catch` (handle :: IOError -> IO (Maybe a))
19:47:21 <FliPPeh> That's how I use "catch"
19:47:22 <temoto> FliPPeh, so i just need to use prelude's catch?
19:48:27 <temoto> which is
19:48:28 <FliPPeh> temoto: I found no difference between Prelude.catch and Control.Exception.catch
19:48:29 <temoto> @type catch
19:48:30 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
19:48:38 <temoto> well
19:48:47 <temoto> @type Control.Exception.catch
19:48:48 <lambdabot> forall a e. (GHC.Exception.Exception e) => IO a -> (e -> IO a) -> IO a
19:48:49 <FliPPeh> "doSomething = whatToDo `catch` (handle :: IOError -> IO (Maybe a))"
19:48:51 <FliPPeh> Like this
19:49:03 <FliPPeh> where your handle is something like outputting it
19:49:33 <temoto> I think difference is that Control.Exception one can catch anything, while Prelude-s one can catch only IOError-s.
19:49:48 <lpsmith> gtk/Graphics/UI/Gtk/Pango/Font.chs.pp:134:46:
19:49:48 <lpsmith>     parse error on input `family'
19:50:02 <temoto> FliPPeh, thanks for example.
19:50:27 <lpsmith> The offending line is:
19:50:31 <lpsmith> pangoFontFamilyIsMonospace :: FontFamilyClass family => family -> Bool
19:50:35 <lpsmith> I don't get it.  Sigh
19:51:24 <FliPPeh> temoto: That's the problem in this case. Because Control.Exception CAN catch any exception, you have to tell it which one
19:51:44 <DarthHaskell>  pastorn: the code is here http://codepad.org/3WQi21Yc, are you able to view the code?
19:53:25 <monochrom> {-# LANGUAGE ForeignFunctionInterface #-}
19:53:57 <aavogt> lpsmith: you enabled extensions that make family a keyword?
19:54:15 <temoto> FliPPeh, yeah i got it. I think i'm only interested in IOErrors so i just removed hiding and use Prelude catch.
19:54:23 <FliPPeh> :)
19:54:49 <aavogt> but I would expect that gtk2hs would have addressed that
19:55:04 <lpsmith> aavogt, I'm trying to rebuild gtk2hs with documentation
19:55:27 <lpsmith> I'll try renaming "family" though
19:56:09 <FliPPeh> I wonder, with Glade you have to move the interface file around with the binary.. how would one integrate the file inside the binary?
19:56:18 <FliPPeh> Maybe just store it as a string...
19:57:47 <DarthHaskell> monochrom thanks that worked
19:58:00 <DarthHaskell> {-# LANGUAGE ForeignFunctionInterface #-} what is that syntax?
19:58:10 <FliPPeh> Compiler pragmas
19:58:20 <FliPPeh> It's aimed directly at GHC
19:58:30 <lpsmith> aavogt:  it appears that did indeed have something to do with it.  Thanks!
19:58:36 <DarthHaskell> cool, first encounter
19:58:45 <FliPPeh> There's a lot more of them
19:59:12 <DarthHaskell> any more for exporting functions?
19:59:28 <aavogt> lpsmith: it might be worth following through with getting that changed for the next person who tries the same?
20:00:26 <lpsmith> yeah, probably
20:01:18 <DarthHaskell> thanks for the, going to play with this
20:01:39 <deech> Hi all, I am trying to understand ArrowLoop and how the 'loop' function is used to implement recursion. I read source for the (->) instance but can't understand it. Can someone help me?
20:02:04 <kmc> DarthHaskell, you can't foreign import or export a list
20:02:11 <aavogt> do you need arrows?
20:02:35 <kmc> or a function with a list as arg or return type
20:02:48 <deech> aavogt: not explicitly, but I've been trying to get handle on lazy evaluation.
20:03:02 <kmc> deech, Arrow might not be the best place to start with that
20:03:03 <kmc> but okay
20:03:15 <DarthHaskell> kmc: ok, whats the alternative if any?
20:03:16 <aavogt> deech: this is a good explanation to read through slowly: http://www.soi.city.ac.uk/~ross/papers/fop.html
20:03:24 <kmc> DarthHaskell, alternative to what?
20:03:35 <DarthHaskell> exporting a list
20:03:45 <kmc> DarthHaskell, if you want an array on the C side and a list on the Haskell side, you will have to write the marshalling code yourself
20:03:53 <kmc> DarthHaskell, more likely you should use an array on the Haskell side as well
20:04:01 <kmc> and use simpler marshalling, e.g. see StorableArray
20:04:08 <deech> I seem to understand lazy evaluation in the context of infinite lists, and lazy IO, but when I read things like 'loop' and the tying-the-knot examples, I'm lost.
20:04:12 <DarthHaskell> ok, thanks
20:04:20 <kmc> DarthHaskell, lists and arrays are very different things
20:04:30 <kmc> deech, do you understand "fix"?
20:04:38 <DarthHaskell> ok
20:04:43 <FliPPeh> Alright
20:04:44 <FliPPeh> 5 AM
20:04:45 <deech> kmc: Sort of, but not really.
20:04:47 <aavogt> fix is a good place to start
20:04:49 <kmc> deech, also be aware that lazy IO *breaks* the normal Haskell semantics.  it's not a good example for anything else and using it in production code is not good practice
20:04:50 <FliPPeh> I shooouuuuuld go to bed
20:04:51 <kmc> @src fix
20:04:51 <lambdabot> fix f = let x = f x in x
20:05:16 <kmc> > fix (1:)
20:05:17 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
20:05:18 <aavogt> > fix ( (1:) . scanl (+) 1 )
20:05:19 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
20:05:27 <deech> gah!
20:05:30 <kmc> deech, you know how a list is made of two-element "cons cells"?
20:05:42 <kmc> every list is either [] or it's (x:xs) for some element x and another list xs
20:05:54 <pastorn> DarthHaskell: http://en.wikibooks.org/wiki/Haskell/Hierarchical_libraries/Arrays
20:05:58 <deech> kmc: Use a cell and a pointer to another cell, right?
20:06:05 <aavogt> > fix ([0,1]++)
20:06:07 <lambdabot>   [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,...
20:06:10 <kmc> deech, sure
20:06:33 <kmc> Haskell evaluation proceeds by "graph reduction", which is a set of transformations applied to a graph of nodes and edges
20:06:46 <kmc> you don't have to think about actual pointers and addresses, as the Report is mute on these operational details
20:06:48 <kmc> however it may be helpful
20:07:07 <kmc> so you can think of each (:) as a pair of outgoing edges / pointers
20:07:39 <deech> kmc: Ok, so pretty much like the way 'vaccum' visualizes a list
20:07:43 <kmc> yes
20:07:49 <kmc> i was just going to link some of those pictures :)
20:08:00 <kmc> > let x = 1:x in x
20:08:01 <deech> kmc: with you so far :)
20:08:01 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
20:08:08 <kmc> ^^^ that's just (fix (1:)) inlined
20:08:16 <kmc> so you can imagine one of these cons cells
20:08:24 <kmc> where the first part points to a 1 cell
20:08:25 * ddarius doesn't understand this "Haskell uses graph reduction" statement.
20:08:27 <kmc> and the second part is a self-loop
20:09:00 <aavogt> why does TH so annoyingly not have lift instances for functions?
20:09:01 <deech> kmc: you had me at the "first part points ..." and lost me at "the second part ..."
20:09:16 <kmc> deech, every (:) is represented by two outgoing pointers, right?
20:09:21 <deech> yup
20:09:23 <kmc> say the second one loops right back on itself
20:09:43 <kmc> that's what we build with "let" there
20:09:49 <kmc> "let" is essentially a language for describing graphs
20:09:51 <aavogt> not so 'first class' anymore are we!
20:09:57 <kmc> aavogt, :D
20:10:00 <deech> ok, I see that it is doing that, but I don't see how the let syntax is making it happen.
20:10:22 <ddarius> aavogt: I blame the halting problem.-
20:10:24 <dons> vacuum is a good tool for visualizing the cyclic structures, fwiw
20:10:44 <deech> so, let x = 1:x => let x = 1:(let x = 1:(...)))?
20:10:58 <kmc> well, "let x = 1:x" is not a complete expression
20:11:42 <kmc> each "let" is a set of bindings of the form "x = e" where x is a variable and e is an expression
20:11:47 <kmc> (ignoring things like pattern binds)
20:11:56 <kmc> and these bindings are allowed to be mutually recursive
20:12:03 <aavogt> ddarius: right, but I'm looking for a shortcut around assigning specific names to functions to be able to refer to them using $(dyn "fun1") in my splice
20:12:05 <deech> ok so x= 1:x => x = 1:(1:x) => x = 1:(1:(1:x... ?
20:12:12 <kmc> yeah
20:12:21 <kmc> but if you think in terms of graph reduction
20:12:34 <ivanm> wtf? QC says a test failed, yet when I try to duplicate it in ghci that particular test works!
20:12:42 <kmc> then consider each right hand side to be an expression tree
20:12:44 <ivanm> oh, wait, I see what the problem is...
20:12:49 <SamB_XP> ivanm: is it at the same type ?
20:12:52 <kmc> and each left-hand var is giving a name to the root of that tree
20:13:03 <aavogt> and you're using the same seed?
20:13:08 <kmc> and then when the variables appear on the right, we draw edges to those roots, which might produce an ultimately cyclic graph
20:13:11 <ivanm> SamB_XP: nah, I misread a String: I thought it said "3" when it was "3 "
20:13:18 <SamB_XP> ivanm: ah!
20:13:32 <dancor> @src repeat
20:13:32 <lambdabot> repeat x = xs where xs = x : xs
20:13:40 <deech> kmc: whow, I think I understand.
20:13:44 <ddarius> repeat = fix . (:)
20:13:57 <dancor> why isn't that the official definition
20:14:11 <ddarius> cycle = fix . (++) = concat . repeat
20:14:15 <kmc> deech, :D
20:14:41 <deech> kmc: so fix f is basically applying f an infinite number of times to its arguments.
20:14:54 <aavogt> dancor: @src isn't definitive anyways
20:15:39 <dancor> aavogt: oh i didn't know i thought it would have both in h98 deviations
20:15:49 <dancor> anyway that is repeat on http://www.haskell.org/onlinereport/standard-prelude.html
20:16:02 <aavogt> > head []
20:16:02 <lambdabot>   * Exception: Prelude.head: empty list
20:16:05 <aavogt> @src head
20:16:05 <lambdabot> head (x:_) = x
20:16:05 <lambdabot> head []    = undefined
20:16:06 <dancor> i guess h98 is just pointful in general?
20:16:08 <fax> > hat
20:16:09 <lambdabot>   Not in scope: `hat'
20:16:31 <aavogt> hat = (:[]) ?
20:16:58 <kmc> deech, yes.  but sometimes after one application of f you know part of the result already, without needing to apply f more
20:17:13 <kmc> as in the case f x = 1:x
20:17:16 <tensorpudding> (:[]) is the sock-monkey combinator
20:17:20 <monochrom> recursion is not so hard
20:17:36 <kmc> you know that the first element of f (f (f ... (f x) ...)) is 1
20:17:40 <tensorpudding> or maybe the snail combinator
20:17:43 <deech> so in " (c,d) = f (b,d)" taken from the 'loop' method what is d's expression tree?
20:17:46 <tensorpudding> (when viewed from above)
20:18:17 <monochrom> d's expression tree is a cyclic graph, not tree.
20:18:25 <dankna> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24591#a24591 -- Why can't it deduce it?
20:18:30 <dankna> It looks easily provable to me.
20:18:38 <kmc> well, i was considering them to be trees with free variables
20:18:46 <kmc> which are then wired together to make the cyclic graph
20:19:02 <ivanm> @pl \ p mv -> mv >>= \ v -> if p v then return v else fail "foo"
20:19:02 <lambdabot> (=<<) . flip flip (fail "foo") . (`ap` return) . (if' .)
20:19:06 <ivanm> :(
20:19:11 <ivanm> @pl \ mv -> mv >>= \ v -> if p v then return v else fail "foo"
20:19:11 <lambdabot> (flip (liftM2 if' p return) (fail "foo") =<<)
20:19:12 <kmc> deech, roughly:  snd (f (b,d))
20:19:38 <aavogt> dankna:
20:19:40 <aavogt> instance (Ord input) => Automaton (NFA input data') input data' where
20:19:46 <ivanm> can anyone think of a nicer way of putting that?
20:19:50 <aavogt> Automaton (NFA (EnumSet content) (Maybe data')) input (Maybe a))
20:20:07 <kmc> deech, note that often-times the argument to the function you "fix" is itself a function
20:20:22 <kmc> > let fact 0 = 1; fact n = n * fact (n-1) in fact 5
20:20:23 <lambdabot>   120
20:20:27 <deech> kmc: but the 'loop' method never 'uses' d : loop f b = c where (c,d) = f (b,c), so it is never evaluated.
20:20:32 <dankna> yeah, that puzzles me - why doesn't it recognize that EnumSet content matches input?
20:20:33 <dancor> monochrom: idk.. it was hard for me to see that the way the laziness works out, a cantor projection of an infinite list onto a infinite 2d list can only be done arithmetically instead of constructively..
20:20:38 <kmc> > let fact self 0 = 1; fact self n = n * self (n-1) in (fix fact) 5
20:20:39 <lambdabot>   120
20:20:52 <kmc> deech, there's an example of using "fix" to get rid of recursive bindings in "let"
20:20:55 <aavogt> see that for written instance to match, you would need for  (EnumSet content) == (Maybe data')
20:21:04 <dancor> re: recursion/fix not being that hard
20:21:07 <dankna> I would?  hmm
20:21:19 <dankna> that sounds like I made a typo somewhere then
20:21:31 <aavogt> well that's where ghc says you aren't consistent
20:21:40 <aavogt> yeah, the error could be anywhere
20:21:44 <monochrom> http://www.vex.net/~trebla/haskell/fix.xhtml may help
20:22:01 <kmc> deech, in the second example, "fact" does not call itself directly
20:22:11 <kmc> it calls this function "self" that it gets as an argument
20:22:13 <dankna> I don't see exactly why EnumSet content has to equal Maybe data'
20:22:13 <kmc> @src fix
20:22:14 <lambdabot> fix f = let x = f x in x
20:22:14 <deech> kmc: because self is fact.
20:22:31 <kmc> yes
20:22:36 <deech> whow
20:22:37 <kmc> because (fix fact) = fact (fix fact)
20:22:43 <kmc> that being the definition of a fixed point
20:22:47 <kmc> monochrom, nice
20:23:10 <aavogt> dankna: also, your methods like      automatonData :: fa -> UniqueID -> data'   will never be able to uniquely select an instance, since you don't mention the input type variable
20:23:13 <monochrom> Credo in rewriting.
20:23:52 <dankna> aavogt: hm.  would that extension where I write | fa -> ... after the instance declaration fix that part?
20:24:19 <aavogt> sure, but then you may not be able to write all the instances you want
20:24:22 <dankna> hmm
20:24:33 <dankna> well, fa is itself parametrized on the input type
20:24:45 <dankna> that's why I thought that it was able to uniquely select
20:25:20 <kmc> a fundep is attached to the class not the instance
20:25:27 <kmc> it requires that the instances have a certain property
20:26:00 <aavogt> instance resolution doesn't seem to rely on how you use type variables in the instances
20:26:03 <dankna> hm
20:26:07 <dankna> noted
20:26:38 <deech> kmc: so in 'loop
20:26:41 <deech>  crap
20:27:08 <dankna> well, I'll try the fundeps anyway and see how they work
20:27:36 <dankna> could the problem be that I reversed the parameters somewhere, or something like that?  thereby causing it to infer two things to be the same when I didn't mean that?
20:28:27 <deech> kmc: so in 'loop' the expression (c,d) = f (b,d) breaks down to (c,d) = f (b, snd (f (b,d))) => (c,d) = f (b, snd(f (b, snd(f (b,d))))). Something like that?
20:29:03 <kmc> yeah something like that
20:29:31 <deech> kmc: I'm going to go ruminate on that for a *long* time. Thanks so much!
20:29:41 <kmc> i think it's like fix but you carry along an extra parameter
20:30:36 <deech> Being lazy is hard.
20:30:46 <kmc> :D
20:31:24 <kmc> :t \f b -> fix (f b)
20:31:25 <lambdabot> forall t a. (t -> a -> a) -> t -> a
20:31:43 <kmc> :t \f -> uncurry $ \b -> fix (f b)
20:31:44 <lambdabot> forall a b c. (a -> (b -> c) -> b -> c) -> (a, b) -> c
20:32:03 <fax> f . (,) b . snd
20:32:13 <fax> :t loop
20:32:14 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
20:32:55 <fax> > let f (x,y) = (1:y,0:x) in loop f 0
20:32:56 <lambdabot>   No instance for (GHC.Num.Num [t])
20:32:57 <lambdabot>    arising from the literal `0' at <inter...
20:33:01 <fax> > let f (x,y) = (1:y,0:x) in loop f []
20:33:02 <lambdabot>   [1,0]
20:33:07 <deech> fax: FYI loop looks like this: loop f a = b where (b,c) = f (a,c)
20:33:19 <fax> > let f (x,y) = (1:x,0:y) in loop f []
20:33:20 <lambdabot>   [1]
20:33:44 <fax> > let f (x,y) = (x++y,1:0:x) in loop f []
20:33:45 <lambdabot>   [1,0]
20:43:40 <dankna> aavogt: could you elaborate on why it's trying to unify (EnumSet content) with (Maybe data')?  I looked at it for a while and I don't see it.
20:44:11 * aavogt doesn't know what it's doing either
20:44:26 <aavogt> just helping you interpret the error
20:44:30 <dankna> oh
20:44:34 <dankna> well, thanks
20:48:02 <dankna> hm.  adding a functional dependency made it compile.
20:48:07 <dankna> mysterious :)
20:48:13 <dankna> I won't complain too much, haha
21:00:53 <Makoryu> @let fromHex :: (Read a, Num a) => String -> a; fromHex = read . ('0':) . ('x':)
21:00:54 <lambdabot>  Defined.
21:01:05 <Makoryu> > fromHex "deadbeef"
21:01:06 <lambdabot>   3735928559
21:07:42 <cads> Hmm.. what should I do to get gtk installed on windows to satisfy the haskell platform?
21:08:02 <cads> trying to install vacuum-cairo
21:08:23 <cads> bacal fails on cairo, gtk, and svgcairo
21:08:30 <aavogt> cads: gtk2hs probably has a windows installer
21:08:36 <cads> I've installed it
21:09:12 <aavogt> then it wasn't the right version, or it was compiled for the wrong ghc?
21:09:18 <cads> hmm, it said something about other versions of gtk being on the path (these are for pidgin)
21:09:43 <cads> one for pidgin and one for graphvis
21:09:44 <aavogt> cabal complains about the haskell binding to gtk
21:11:02 <cads> ah, I installed ghc 6.10.3 for the gtk2hs installer to work.. this is in a separate directory than my haskell platform install, which rocks 6.10.4
21:12:07 <ezyang> What are idioms for iterating over heterogenous recursive datastructures?
21:12:23 <ezyang> for example, A can contain B, B can contain C, and C can contain A.
21:12:40 <ezyang> and there are custom conjunction types all over teh place
21:13:45 <ezyang> My biggest problem is I can't think of a way to let the user specify what they want to happen to the structure without asking them for N functions, where N is the number of distinct data types the data structure contains.
21:14:30 <aavogt> generic programming
21:15:03 <ezyang> aavogt: Hm? You mean with typeclasses?
21:15:28 <aavogt> yes, stuff like syb
21:15:30 <SamB_XP> one of those "boilerplate" things
21:15:49 <ezyang> blegh
21:16:24 * SamB_XP tries to remember what uniplate can do
21:17:32 <ezyang> oh, that's what this Typeable nonsense is for.
21:17:48 <aavogt> Typeable <3
21:18:28 <dancor> boilerplate </3
21:18:36 <dancor> boilerhate
21:18:43 <ezyang> ==dancor
21:18:59 <dancor> ya i'm hateful, down to the cor
21:20:24 <kmc> don't hate the boiler hate the plate
21:20:45 <SamB_XP> why the heck is it called that anyway ?
21:21:11 <aavogt> well you see, back in the day there were things called boilers
21:21:17 <aavogt> these were made of plates
21:21:20 <kmc> Typeable is useful for other things besides syb
21:21:23 <kmc> i've used it more outside syb
21:21:26 <aavogt> then syb came along and scrapped them
21:21:44 <SamB_XP> aavogt: you could have just said "I have no clue" and looked smart
21:21:47 <tensorpudding> cool story bro
21:22:12 <Makoryu> http://en.wikipedia.org/wiki/Boilerplate_text#Etymology
21:22:18 <Makoryu> Really, people
21:22:25 <Makoryu> You live in the future
21:22:29 <Makoryu> You are on the internet
21:22:44 <SamB_XP> no, no, this is ARPANET
21:23:01 * aavogt was only slightly inaccurate
21:23:35 <kmc> ezyang, also, why is it unreasonable for the user to specify N functions?
21:23:48 <kmc> you can put those N functions in a record and provide a default record of do-nothing functions
21:23:57 <SamB_XP> kmc: it gets unwieldy
21:24:00 <kmc> then the user can use record-update syntax to override the ones they care about
21:24:10 <ezyang> kmc: It's probably not too unreasonable
21:24:16 <aavogt> or those functions can be specified using    mkT $ \x -> ...
21:24:23 <aavogt> and then you everywhere them
21:24:27 <kmc> this could end up being a good deal faster than all the SYB Typeable/Data machinery
21:24:32 <kmc> and simpler to understand
21:24:37 <dancor> even TH isn't just for boilerplate but also conditional complation and optimization
21:24:38 <kmc> also, look at Uniplate
21:24:44 <aavogt> depends how fancy your traversal is
21:24:55 <kmc> it's very different from SYB in its approach to generic programming
21:25:54 <ezyang> I've wandered into these weeds because of a pseudocode programming assignment I decided to write in Haskell.
21:26:13 <ezyang> do you guys mind if I show you the problem statement?
21:26:16 <aavogt> http://wiki.portal.chalmers.se/cse/pmwiki.php/FP/ComparingLibrariesForGenericProgrammingInHaskell
21:26:50 <kmc> ezyang, i don't
21:26:53 <aavogt> there's a 50 page extended version to wade through
21:27:16 <kmc> aavogt, nice
21:28:02 <ezyang> here it is: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24593#a24593
21:28:07 <ezyang> read and weep T_T
21:31:13 <cads> damnit
21:31:24 <ezyang> (so, reactions? disgust? horror? ezyang, you're making this sound worse than it actually is?)
21:31:43 <aavogt> yes
21:31:56 <cads> I hate it when you want to do a project but you know it'll be like trying to swim through rock unless you stop what you're doing and spend a few hours reading documentation
21:32:33 <cads> and you stubornly get your shovel and swimming goggle out instead of your reading glasses
21:33:02 <SamB_XP> cads: wouldn't you want the helmet with drill attachment + pickaxe ?
21:33:11 <aavogt> maybe some of the stuff which uses Data which can be derived by ghc can help in making checkSectionOrder
21:33:21 <dancor> it's better than when you start a project but have to deal with build issues for several days
21:33:40 <ezyang> aavogt: I've finished checkSectionOrder. It's kind of repetitive but only twice.
21:34:01 <cads> dancor, the documentation I have to read is to find out how to deal with these build issues in the libraries I want to use :P
21:34:01 <ezyang> and I since this assignment isn't actually in Haskell, I don't think using GHC extensions would be too kosher :-)
21:34:19 <ezyang> cads: Bah, cargo cult your way through!
21:34:31 <dancor> nice
21:35:08 <SamB_XP> ezyang: I don't think building fake docks and whatnot is going to be particularly useful...
21:35:29 <cads> I've tried building a sacrificial .conf file, fiddling with my PATH, and random -oh-please -mighty-GHC flags to my ghc compiler but it won't work..
21:35:33 <ezyang> "docks"?
21:35:51 <cads> airstrips?
21:35:52 <ezyang> @remember cads "I've tried building a sacrificial .conf file"
21:35:52 <lambdabot> Okay.
21:36:59 <SamB_XP> ezyang: why the quotes ?
21:37:10 <ezyang> I wasn't sure which conversation you were replying to.
21:37:28 <SamB_XP> no, I mean, why do you have quotes around your quote ?
21:37:39 <ezyang> oh. "too much Unix"
21:38:02 <cads> I think if I take a more rational approach I'll see that stepping back and reading enough documentation that I know how things are supposed to work.. well.. that doesn't feel like I'm accomplishing work, but neither does hitting a brick wall otherwise
21:38:40 <cads> cabal docs and ghc docs it is :/
21:39:28 <ezyang> cads: Reframe it as if you're learning a new paradigm!
21:42:28 <ezyang> "each page contains a consecutive sequence of paragraphs and figures" -> this feels like it really wants some state.
21:42:42 <cads> hmm.. reading the intro part of the documentations is like a big "Don't Panic"
21:42:47 * cads is soothed
21:44:39 <SamB_XP> cads: why do you find that soothing ? I thought it was always worrisome when something began that way!
21:44:56 <Jafet> You should trust the Don't Panic signs more
21:45:14 <Makoryu> Or should you?
21:45:19 <ezyang> "Look where it got Arthur Dent"
21:45:52 <cads> well, it was like my brain giving me a "Don't Panic" after seeing that it had learned something new and relevant to the problem already
21:55:13 <cads> ah brain is happy
21:55:52 <cads> I think part of it is that when you're stuck in the enormously frustrating shit, reading documentation seems like this huge task
22:14:46 <jmcarthur> i hate it when i haven't really been productive all day for various reasons and then at the end of the day i finally get to sit down and write some code for a pet project but then i realize i'm too tired to think
23:14:52 <pastorn> jmcarthur: find coffee, do code
23:15:30 <pastorn> runState (drink coffee) jmcarthur
23:17:18 <SubStack> I'm pretty much only productive after coffee and black tea
23:17:28 <pastorn> black tea?
23:17:42 <Adamant> it is caffeine alone that sets your mind in motion?
23:17:50 <SubStack> highly likely
23:17:56 <SubStack> need to cut back
23:18:06 <pastorn> SubStack: SubStack black(tea) :- !red(tea), !green(tea). ?
23:18:13 <SubStack> or drink more, perhaps
23:18:13 <Adamant> yeah. caffeine is fun until you get dependent on it.
23:18:28 <pastorn> or is that how you do negations in prolog? i don't remember exactly
23:18:43 <SubStack> I saw some prolog once
23:18:52 <pastorn> SubStack: was it awesome?
23:18:57 <SubStack> possibly
23:19:01 <SubStack> I wasn't paying attention
23:19:02 <pastorn> haha
23:19:07 <pastorn> good interpretation :)
23:19:46 <pastorn> P(x) /\ Q(x) -> R(x) -- normal predicate logic
23:20:30 <pastorn> r(x) :- p(x), q(x).
23:20:38 <pastorn> SubStack: ^^ prolog notation
23:21:47 <pastorn> sorry, those X:s in the prolog should be large X:s
23:22:53 <SubStack> I added a preprocessor to my haskell parser wrapper thing
23:23:02 <pastorn> huh?
23:23:16 <pastorn> SubStack: rewrite stuff or compile time computations?
23:23:24 <pastorn> or what do you do?
23:23:34 <SubStack> rewriting
23:23:38 <SubStack> turn a module into pointfree!
23:24:00 <pastorn> haha... that gives a kick in performance, right?
23:24:08 <SubStack> no idea
23:24:22 <pastorn> well, i think it usually does
23:24:25 <SubStack> I just want to mutate them
23:24:39 <ski> pastorn : s/!/\\+/
23:24:53 <pastorn> not binding variables to names can often give a performance bump
23:25:08 <SubStack> I would think that the compiler would do plenty of that itself
23:25:10 <pastorn> ski: good(X) :- +bad(X) ?
23:25:25 <ski>   good(X) :- \+ bad(X).
23:25:38 <ski> (the `\+' is pronounced "not provable")
23:26:02 <pastorn> SubStack: nah... me and a friend tried it... we did some heavy computations (factorials or fibs or whatever) and then ran our core functions through @pl
23:26:05 <pastorn> SubStack: did magic
23:26:20 <SubStack> wow
23:27:04 <ski> pastorn : i'd think that it was either eta-reduction, or other specific rewritings that `pl' does that did that .. not just writing stuff in pointless
23:27:06 <pastorn> SubStack: sometimes it helps, sometimes it doesn't
23:27:39 <pastorn> ski: well, it worked... good to know that you can use it if your code's slow
23:28:03 <pastorn> ski: it's not exactly like you'll be spending hours on figuring out how to do it :)
23:28:09 <ski> (though i suppose rewriting `\x -> f a (g b x)' into `f a . g b' could share `f a' and `g b' over calls .. not sure when GHC does this otherwise)
