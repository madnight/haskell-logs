00:00:40 <Zeiris> @src listens
00:00:40 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
00:01:10 <Zeiris> What does the ~ in "~(a,w)<-listen m" inside "do ..." mean?
00:01:27 <langtree> I think it means that the match is lazy
00:14:44 <Cale> Yeah, it means that the result of listen m isn't evaluated immediately to test that it matches the (,) constructor. Instead, that evaluation is deferred to the point where a or w is evaluated.
00:15:04 <Cale> This is of course safe because the pair type has only one constructor
00:15:32 <Cale> In the case of a type with multiple constructors, it can introduce the possibility of a runtime error.
00:26:29 <Zeiris> Where does this Integer type come from, when I only use Int? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24620#a24620
00:28:38 <Zeiris> Interestingly, this happens at runtime rather than compiletime.
00:36:44 <rajeshsr> hi
00:37:25 <rajeshsr> what is the best way to get the first argument passed to the command line?
00:37:35 <rajeshsr> like: let f = head getArgs
00:37:38 <rajeshsr> ?
00:38:24 <dabblego> rajeshsr, System.Args.getArgs
00:38:24 <Jafet> @hoogle getArgs
00:38:24 <lambdabot> System.Environment getArgs :: IO [String]
00:40:58 <rajeshsr> hmm, yeah!
00:41:14 <rajeshsr> i do: {t <- getArgs; let path = head t;}
00:41:34 <rajeshsr> is there any other way to get away with IO and apply head in a single line?
00:42:25 <dabblego> head <$> getArgs
00:42:45 <langtree> @. pl undo do {t <- getArgs; return head t}
00:42:45 <lambdabot> return head =<< getArgs
00:42:48 <dabblego> @type head <$> getArgs
00:42:49 <lambdabot> Not in scope: `getArgs'
00:42:54 <Jafet> > head []
00:42:55 <lambdabot>   * Exception: Prelude.head: empty list
00:43:15 <dabblego> do { (h:_) <- getArgs; ... }
00:43:45 <langtree> @type fmap head getArgs
00:43:46 <lambdabot> Not in scope: `getArgs'
00:43:55 <langtree> @type fmap head System.Args.getArgs
00:43:56 <lambdabot> Couldn't find qualified module.
00:44:02 <langtree> :\
00:44:35 <dabblego> @type head <$> System.Environment.getArgs
00:44:36 <lambdabot> IO String
00:45:00 <langtree> @type fmap head System.Environment.getArgs
00:45:01 <lambdabot> IO String
02:08:05 * hackagebot HaskellNet 0.2.2 - network related libraries such as POP3, SMTP, IMAP  http://hackage.haskell.org/package/HaskellNet-0.2.2 (RobertWills)
02:12:06 * hackagebot HaskellNet 0.2.3 - network related libraries such as POP3, SMTP, IMAP  http://hackage.haskell.org/package/HaskellNet-0.2.3 (RobertWills)
02:21:53 <max22> hi
02:30:35 <Gracenotes> hello max22
02:44:10 <ivanm> @. elite protontorpedo
02:44:10 <lambdabot> HO\/\/ Iz0rz |-|ASkE1l dIFfEReNt 7|-|An Ja\/4?
02:46:35 <mreh> that's amazing
02:46:49 <mreh> @. elite
02:46:49 <lambdabot> Not enough arguments to @.
02:46:56 <mreh> @. elite hello
02:46:57 <lambdabot> Plugin `compose' failed with: Unknown command: "hello"
02:46:58 <ivanm> "@." is plugin composition
02:47:05 <ivanm> @elite hello mreh
02:47:05 <lambdabot> |-|el1O MReh
02:48:12 <mreh> @. elite vixey Hey, baby.
02:48:12 <lambdabot> Plugin `compose' failed with: Unknown command: "vixey"
02:48:21 <mreh> what's the chat bot's name?
02:49:11 <ivanm> @tell dibblego well, youtube seems to be working here now...
02:49:11 <lambdabot> Consider it noted.
02:49:18 <ivanm> @vixen what is your name?
02:49:19 <lambdabot> My name is Emily
02:49:44 <mreh> @vixen How come you type so fast?
02:49:45 <lambdabot> nevermind about that
02:49:58 <Jafet> @. quote vixen
02:49:58 <lambdabot> No quotes for this person. I've seen penguins that can type better than that.
02:50:22 <mreh> @. quote vixen how do you like your new voice?
02:50:22 <lambdabot> No quotes for this person. Your mind just hasn't been the same since the electro-shock, has it?
02:50:27 <Ke> soon lambdabot's emily will surpass string-emil as top hilight source
02:50:29 <mreh> @. elite vixen how do you like your new voice?
02:50:30 <lambdabot> sUr3, i dEFINi+3LY doN't h47E
02:50:32 <ivanm> @@ @elite @vixen what do you think about mreh?
02:50:32 <lambdabot> Plugin `compose' failed with: Unknown command: ""
02:50:38 <Jafet> @. vixen quote
02:50:38 <mreh> haha
02:50:38 <lambdabot> you're cute. :)
02:50:51 <ivanm> hmmm.... I thought you had to use the @@ version to pass values to the plugins...
02:51:08 <ivanm> @. vixen protontorpedo
02:51:09 <lambdabot> sure is
02:51:21 <mreh> @prontotorpedo
02:51:21 <lambdabot> is it a form of lisp?
02:51:26 <mreh> @prontotorpedo
02:51:26 <lambdabot> is there a decent scheduler in haskell? how about a netwrok monitor?
02:53:59 <mreh> "why did someone create haskell" <- personal favourite
02:54:52 <mreh> is this supposed to be the shadow of #haskell, a shrine to all the ignorant questions that hurt our feelings
03:09:33 <ivanm> @help protontorpedo
03:09:33 <lambdabot> protontorpedo is silly
03:21:37 <jlouis> can haskell make coffee?
03:22:18 <jlouis> (I know coffee can make haskell, by the way, I don't seek an answer to that question)
03:24:29 <ivanm> @faq can haskell make coffee?
03:24:29 <lambdabot> The answer is: Yes! Haskell can do that.
03:24:48 * ivanm wonders why dons linked to a feedreader rather than directly to ezyang's blog post on the haskell reddit
03:25:32 <Jafet> To avoid linking to reddit?
03:25:49 <martinhuegel> Does MVarS also work with forkOS (instead of forkIO)?
03:26:07 <ivanm> Jafet: what, ezyang doesn't like reddit having links to his blog? :/
03:26:12 <ivanm> martinhuegel: doubt it
03:26:24 <ivanm> but I'm probably wrong :p
03:26:49 <Jafet> Well, does it compile?
03:27:39 <peaker_> martinhuegel, ivanm: Sure, why wouldn't it work?
03:27:49 <ivanm> *shrug*
03:27:50 <peaker_> forkIO can easily "become" forkOS (sort of) with -threaded
03:28:10 <peaker_> forkIO's can get executed in a separate physical thread
03:28:21 <martinhuegel> Jafet: I'm not sure if it compiles, I'm just thinking about which language I should use for a project where I need to parallelize something on a cluster (and I'm thinking about concurrent Haskell).
03:30:16 <peaker_> martinhuegel, Erlang is pretty good at transparently moving stuff around computers
03:32:15 <HugoDaniel> :)
03:32:22 <HugoDaniel> i like par
03:32:25 <HugoDaniel> is amazing
03:32:58 <martinhuegel> peaker_: thanks, I'm also considering Erlang, but somehow I'm fascinated by Haskell. :) Apparently Haskell is very good with STM on multi-cores, but it's really difficult to find something for distributed memory (i.e. clusters).
03:34:47 <martinhuegel> Yeah, I think par might work with concurrent Haskell on a cluster. What I'm not sure about is its performance because of a potentially large overhead (so to speak).
03:40:08 <martinhuegel> ivanm, peaker_, HugoDaniel: thanks for your feedback, I wish you a nice Easter time.
03:40:15 <ivanm> you too
03:49:50 <FliPPeh> Easter?
03:49:57 <FliPPeh> IT'S ZOMBIE JESUS DAY!
03:50:01 <ivanm> @slap FliPPeh
03:50:01 <FliPPeh> At least I think.
03:50:01 * lambdabot smacks FliPPeh about with a large trout
03:50:17 <FliPPeh> I'm not that much of a holiday specialist, neither am I religious
03:50:27 <FliPPeh> :)
03:50:34 * ivanm is religious
03:55:28 <pastorn> jmcarthur: pm
03:55:31 <Adamant> FliPPeh: 'Zombie Jesus' was a undead chaotic good cleric character (special dispensation from Gygax) that Jesus rolled for the D&D games up in heaven
03:56:02 <FliPPeh> ;o
03:56:03 <Adamant> once Gygax went on the Happy DM'ing Grounds
03:56:37 * Adamant hopes that will be considered funny and not offensive, and will leave things there :P
03:57:04 <FliPPeh> I'd be more concerned if this was #christians and not #haskell
03:59:34 <ivanm> my response whenever people denigrate a Christian belief (especially if they're from what was originally a Christian-oriented country, that is most of the western ones): would you dare say something like that to a Muslim?
03:59:42 <ivanm> if not, why should you go and make fun of Christianity?
03:59:57 <ivanm> s/Muslim/Muslim or a Jew/
04:00:02 <FliPPeh> I'd not dare, they always declare war
04:00:08 <ivanm> _exactly_
04:00:12 <Adamant> ivanm: I am Christian
04:00:14 <FliPPeh> But generally, I don't like any religion
04:00:48 <FliPPeh> But it's a personal choice, I'm not making fun of the people who believe.
04:00:58 <ivanm> FliPPeh: that's your prerogative; but if you wouldn't dare to make fun of one religion, why make fun of any?
04:01:00 <FliPPeh> Except they are religious fanatics. I hate them
04:04:47 <Jafet> emacs!
04:05:03 <Adamant> Jafet: yes, I was just thinking of technical holy wars to start
04:05:17 <Adamant> n+k patterns!
04:05:22 <Jafet> Choose your race, role and alignment
04:07:15 <Vanadium> hm... vim, brackets attached and 2 spaces?
04:08:33 <chrisdone> anyone used jaspervdj's hakyll?
04:11:35 <FliPPeh> ivanm: It all depends on that religion.  It's not like one is like the other, but I think I don't need to emphasize this, that's a given, but with different religions, you get different believers - while it's easy to find fanatic muslims and christians who justify their actions, no matter how stupid, wrong or against everything their religion stands for, with their belonging to that religion, the same is harder for religions like the buddhism fo
04:11:38 <luite> ivanm: I don't think it's a fair comparison if there's fear for punishment involved... I really don't see why one should criticise Christianity less, just because criticising some other religion would cause repercussions
04:11:43 <FliPPeh> But this is getting off topic
04:13:07 <chrisdone> please take it to #haskell-blah
04:13:09 <Adamant> chrisdone: haven't used it, but looks interesting; thanks!
04:13:24 <Adamant> the hakyll bit :P
04:13:50 <FliPPeh> Nah, I've stated my point, I'm not going to get into another religious discussion
04:13:50 <chrisdone> Adamant: yeah I'm building my blog with it! made my home page last night: http://chrisdone.com/
04:13:56 * FliPPeh shivers, thinking of the last one
04:14:41 <FliPPeh> That's Text.Xhtml!
04:15:02 <chrisdone> FliPPeh: indeed, I think Pandoc uses it to render html
04:15:38 <FliPPeh> "Hakyll is a Haskell library for generating static sites"
04:15:43 <FliPPeh> Aww, no guestbooks :(
04:15:54 <chrisdone> I might patch it so it uses the indentation-less rendering funtion
04:16:06 <Adamant> FliPPeh: but also no Youtube comment threads :P
04:16:09 <FliPPeh> chrisdone: prettyHTML ?
04:17:15 <FliPPeh> Or showHtml?
04:17:20 <FliPPeh> The one without newlines at all?
04:17:22 <olsner_> hmm, what's the difference between the mtl and transformers libraries?
04:17:36 <chrisdone> FliPPeh: yeah
04:17:39 <FliPPeh> I found that prettyHtml, just like the docs say, indeed can change the meaning of the document
04:17:55 <FliPPeh> Mystical spaces appearing after hyperlinks and stuff
04:18:14 <FliPPeh> I'd leave it like it is right now
04:18:19 <chrisdone> olsner_: one's a bunch of monads, the other's a bunch of monad transformers
04:18:34 <FliPPeh> People interested in the source will have a much easier time if you don't steal their newlines
04:19:00 <chrisdone> olsner_: iirc transformers is an updated version, more transformers, more stuff
04:19:19 <olsner_> chrisdone: hmm, afaict both libraries provide both monads and transformers
04:19:22 <FliPPeh> Hmm, you can still have dynamic sites in Hakyll
04:19:23 <chrisdone> FliPPeh: I don't care if people are interested in the source :P
04:19:35 <FliPPeh> Just generate them by Haskell and save that as a file ;x
04:19:43 <FliPPeh> chrisdone: :(
04:20:39 <chrisdone> olsner_: actually I can't remember, I've needed both before, heh
04:20:42 <olsner_> but transformers seems to define its monads in terms of transformers in Identity rather than as separate definitions
04:20:55 <chrisdone> ah that's better
04:23:54 <olsner_> for some reason, mtl seems more well-spread, so I think I won't bother changing the import names to transformers :P
04:24:38 <FliPPeh> Is there a difference between "liftM f (m f)" and "fmap f (m f)" ?
04:24:42 <FliPPeh> I get the same results
04:24:49 <Taejo> FliPPeh: no
04:24:50 <chrisdone> yes, one requires a Monad instance
04:25:04 <FliPPeh> liftM is monad only, okay
04:25:13 <Taejo> if the monad and functor instance are both defined correctly, they should be the same
04:25:30 <FliPPeh> It's the same for IO
04:25:32 <FliPPeh> :)
04:25:54 <tomoj> chrisdone: seems like your links are screwed up
04:25:55 <chrisdone> I just noticed jaspervdj used liftM in his code instead of liftA, which I think is preferable when in an arrow
04:26:01 <chrisdone> tomoj: which links?
04:26:07 <tomoj> from asp-mode to vgrabbj-streamish
04:26:17 <tomoj> they link to the next one down for me
04:26:24 <chrisdone> tomoj: oh, hm
04:26:41 <ksf> is there some code on hackage implementing http://www.cs.nott.ac.uk/~wss/Publications/DataTypesALaCarte.pdf ? I couldn't find anything.
04:27:40 <chrisdone> tomoj: fixed
04:29:08 <ksf> mkdir Data; vi Data/ALaCarte.hs
04:30:13 <chrisdone> ksf: the beginnings of a beautiful library
04:48:59 <maltem> When running through sudo, shouldn't cabal default to --global?
04:53:43 <ivanm> maltem: sudo isn't running as root
04:53:54 <ivanm> it's running as the normal user but with root privileges
04:54:14 <maltem> ok point
04:56:04 <rajeshsr> is there an haskell lib for smtp?
04:56:28 <ivanm> rajeshsr: not sure...
04:56:30 <maltem> Ok next one: Do I have control over haddock's --gen-index option from cabal? With sudo cabal install --global, no documentation index is updated, afaics
04:56:32 <ivanm> I think someone started one
04:56:45 <ivanm> maltem: not sure; check the config
04:56:58 <maltem> ivanm: there's nothing there I think
04:57:15 <rajeshsr> ivanm, oh, ok! thanks!
04:57:17 <maltem> I was hoping for something like haddock-options
04:57:18 <dobblego> rajeshsr, there are several on hackage
04:57:31 <ivanm> rajeshsr: there's the start of an IMAP one at least
04:57:40 <ivanm> maltem: what kind of control do you want?
04:57:46 <ivanm> IIRC, the index is just a big hack...
04:57:49 <rajeshsr> dobblego, oh! let me check that..
04:59:57 <maltem> ivanm: Hold on, I'm looking through docs and tickets to find out if maybe there is what I want, and it is just not documented in .cabal/config
05:00:12 <rajeshsr> is there a deb package for cabal? Which repo has it?
05:00:16 <ivanm> maltem: the ability to generate an index is in ~/.cabal/config
05:00:22 <ivanm> rajeshsr: cabal comes with GHC
05:00:26 <ivanm> cabal-install is a different story
05:00:58 <rajeshsr> ivanm, i have ghc but no cabal!
05:01:00 <ivanm> http://packages.debian.org/sid/cabal-install
05:01:07 <ivanm> rajeshsr: cabal /= cabal-install
05:01:12 <ivanm> cabal is a library
05:01:35 <ksf> <3 -XDeriveFunctor
05:01:38 <rajeshsr> ivanm, oh! ok! if i install some package from hackage i need cabal, right?
05:01:43 <ivanm> rajeshsr: http://ivanmiljenovic.wordpress.com/2010/03/15/repeat-after-me-cabal-is-not-a-package-manager/ (first sub-section)
05:01:46 <ivanm> rajeshsr: not at all
05:01:56 <ivanm> using cabal makes it easier to install though
05:02:08 <rajeshsr> ivanm, oh! thanks! let me see.
05:02:11 <ivanm> and cabal-install will let you do it automatically rather than downloading, configuring, building and installing by hand
05:02:15 <maltem> ivanm: ok, looks like my .cabal/config is based on an old template; I'll try with doc-index-file
05:02:35 <ivanm> maltem: back up the old config, run "cabal update", then edit the new config
05:03:41 <maltem> ivanm, that doesn't even touch my config
05:03:50 <ivanm> :o
05:04:01 <ivanm> maltem: oh, backup and then delete your old config ;-)
05:04:12 <maltem> ok :)
05:05:48 <maltem> That worked. Funny though that doc-index-file is not under install-dirs.
05:06:31 <ivanm> don't forget: it's a hack (imagine admiral ackbar saying this...)!
05:06:46 <maltem> :)
05:09:13 <chrisdone> hey dobblego :)
05:09:20 <dobblego> hello
05:10:12 <chrisdone> dobblego: you defended my post on reddit at some point and now we're BFFs
05:10:32 <dobblego> heh, I don't remember
05:11:09 <chrisdone> :t liftA
05:11:10 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
05:12:24 <chrisdone> does someone have a Prelude where all these classes Functor,Applicative,Monad are properly superclassed?
05:12:59 <chrisdone> and (++) = mappend and (.) = fmap. basically caleskell/hascale
05:13:09 <ivanm> nooooooo!!!!!!!
05:13:20 <chrisdone> someone silence that man
05:13:34 * chrisdone pushes trap door button
05:13:42 * ivanm thinks that as soon as that becomes the default, then one of Haskell's main reasons to be - teaching - becomes much harder
05:13:58 <dobblego> chrisdone, if it is done, you don't get do-notation support
05:14:02 <ivanm> it's hard enough explaining to students what bits of Haskell do, without subjecting them to type signatures like:
05:14:04 <ivanm> @type (.)
05:14:05 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:14:12 <chrisdone> dobblego: why's that?
05:14:13 <Jafet> But it's clearer!
05:14:16 <dobblego> ivanm, I strongly disagree; teaching becomes *easier*
05:14:31 <ivanm> chrisdone: probably because it's an inbuilt syntactic sugar, whereas what you want would requrie re-defining Monad, etc.
05:14:32 <dobblego> chrisdone, because you'd have to write your own Monad
05:15:00 <ivanm> dobblego: teaching first year students (most of whom don't see why their Engineering course requries them to learn programming) becomes _easier_ by introducing Functors so early?
05:15:03 * ivanm begs to differ
05:15:08 <Jafet> You could add a template haskell prelude with a do syntax
05:15:12 <dobblego> ivanm, I didn't say that
05:15:25 <ivanm> dobblego: then how does it become easier pray tell?
05:15:25 <chrisdone> surely if you redefine Monad then the do syntax will still work?
05:15:29 <ivanm> chrisdone: nope
05:15:35 <chrisdone> as long as you have >>= and return
05:15:38 <ivanm> since IIRC, the definition of Monad is within GHC.*
05:15:39 <chrisdone> oh well that's totally crap
05:15:48 <dobblego> ivanm, removing map, (.), fmap, liftM, liftA, (<$>) and having only (.) :: (Functor f) => (a -> b) -> f a -> f b makes teaching much easier
05:16:06 <ivanm> I disagree
05:16:13 <dobblego> ivanm, the idea that we exclusively teach specialisation first, is bogus
05:16:18 <ivanm> since then they have to remember that (.) does all of that
05:16:27 <dobblego> no they don't, not if you're a good teacher
05:16:29 <rajeshsr> i get errors like this:
05:16:31 <rajeshsr> cabal: cannot configure time-1.1.4. It requires base ==4.*
05:16:31 <rajeshsr> For the dependency on base ==4.* there are these packages: base-4.0.0.0,
05:16:31 <rajeshsr> base-4.1.0.0 and base-4.2.0.0. However none of them are available.
05:16:39 <rajeshsr> any idea of what to do?
05:16:44 <ivanm> dobblego: I still use liftM for monadic code rather than fmap...
05:16:49 <ivanm> rajeshsr: use an older version of time
05:16:55 <chrisdone> ivanm: they also have to remember that (>>=) does "all of that"
05:17:01 <ivanm> rajeshsr: what version of GHC do you have?
05:17:09 <ivanm> chrisdone: except they haven't gotten to monads yet ;-)
05:17:21 <ivanm> chrisdone: for some of them, picking up _recursion_ is hard enough
05:17:21 <rajeshsr> ivanm, version 6.8.2
05:17:24 <dobblego> ivanm, that doesn't indicate anything; the existence of a decision is the problem
05:17:50 <ivanm> and there are still several people who keep asking what the "(Eq a) =>" stuff in the beginning of type signatures means...
05:17:56 <dobblego> ivanm, try teaching List.reverse to a child with a specialisation
05:18:00 <ivanm> dobblego: if there was a new textbook that used that notation, _maybe_
05:18:14 <ivanm> dobblego: "specialisation"?
05:18:18 <dobblego> ivanm, I'm not talking about haskell specifically; Haskell gets it wrong
05:18:27 * ivanm isn't sure what dobblego is referring to
05:18:36 <dobblego> [Banana] -> [Banana]
05:18:53 <ivanm> oh, right
05:19:09 <ivanm> as opposed to just [a] -> [a] ?
05:19:13 <rajeshsr> ivanm, how am i to get a older version?
05:19:14 <dobblego> right
05:19:33 * ivanm had a student trying to re-define concat (without knowing concat existed) from scratch whilst using type Donkey = [Int] ...
05:19:33 <dobblego> it is not universally true that [Banana] -> [Banana] makes teaching easier than [a] -> [a]
05:19:41 <ivanm> rajeshsr: using what, cabal-install ?
05:19:59 <rajeshsr> ivanm, yep
05:20:02 <ksf> well, the problem with the a la carte types is that it requires type signatures to figure out the shape of the sum type because ghc is not decisive enough just to pick _any_ of the possibilities
05:20:05 <ivanm> dobblego: IMHO, they have enough new names/concepts to pick up without having this mystical (.) operator that does "everything"
05:20:12 <dobblego> there are ways of achieving the full understanding by not appealing to either, but by introducing information in a specific order, depending on questions
05:20:33 <dobblego> ivanm, I don't suggest they have to pick that up
05:20:37 <ivanm> dobblego: _if_ there was a good textbook that used that approach (that (.) = fmap), then it might work
05:20:52 <dobblego> ivanm, it works, I've done it many times (and am doing it right at this moment)
05:20:54 <ivanm> but atm, there isn't, and that makes it more difficult
05:21:08 <ivanm> dobblego: to people who are interested?
05:21:20 * ivanm personally doesn't even like having (.) = fmap = <everything>
05:21:35 <dobblego> ivanm, what do you mean? of course they are interested; they are learning on their own volition
05:21:36 <ivanm> I can see having map = fmap and generalising that _maybe_
05:21:39 <Jafet> Who are you teaching?
05:21:48 <dobblego> an IRC users in another channel
05:21:51 <dobblego> *user
05:21:56 * ksf thinks that the liar's paradox isn't a problem for machines. it's those "do you want vanilla or choclate pudding" questions that are undecidable
05:22:05 <ivanm> dobblego: exactly; I'm talking about engineering students who have nfi why they're forced to learn haskell (since computers are just those things they use to get on Facebook)
05:22:34 <dobblego> ivanm, then that's not a problem of the type of (.)
05:22:35 <chrisdone> ksf: I suppose the liar paradox is just handled by an occurs check?
05:22:44 <Jafet> Why would you force... engineering students to learn haskell?
05:23:04 <Jafet> Lisp for autocad, perhaps, but haskell sounds sketchy
05:23:06 <dobblego> ivanm, the objective of teaching people who are not interested in learning is best done by completely abandoning haskell altogether, not just fmap
05:23:10 <ivanm> Jafet: they have to do a programming subject (don't ask me why), and it just so happens that the first year programming course is 2/3 haskell and 1/3 java
05:23:22 <ksf> I guess there's a set of paradoxical sets which are not paradoxical, somewhere.
05:23:27 <chrisdone> ivanm: what uni. is that?
05:23:34 <ivanm> chrisdone: ANU
05:23:40 <dobblego> ivanm, I once did university lecturing; now I subscript the word "teaching". You're using a different subscript than I am
05:23:42 <ivanm> they do a lot of weird things
05:24:07 <ivanm> e.g. they think that IT/CS students should learn calculus rather than discrete maths
05:24:11 <Jafet> @remember ksf I guess there's a set of paradoxical sets which are not paradoxical, somewhere.
05:24:11 <lambdabot> Good to know.
05:24:13 <ivanm> dobblego: yeah, I know
05:24:20 <dmhouse> I know Oxford University teach Haskell to first year compscis (and here in Cambridge ML is taught), but I'm pretty sure the engineering prorgamming stuff is separate from the compsci department.
05:24:26 <ksf> .oO( someone please construct a set that is only paradox if it is not paradox and only not paradox if it is paradox)
05:24:46 <ivanm> ANU is _really_ post-grad and research oriented; they pretty much take in undergrads because they have to p
05:24:50 <ivanm> * :p
05:24:55 <Jafet> That sounds universally paradoxical
05:25:06 <maltem> ivanm, turns out doc-index-file is ineffective for global installs :/
05:25:12 <ivanm> maltem: :s
05:25:13 <ivanm> I think that the specialised list functions/operations make it easier to teach haskell
05:25:20 <chrisdone> at Glagsow a friend was learning electronics with a Haskell EDSL
05:25:49 <ivanm> in the same way that physics students learn about electron orbitals, etc. before finding out that they are actually just probabalistic regions where you're likely to find an electron, etc.
05:25:57 <bremner> some software engineers are keen on haskell, if that counts
05:26:09 <Jafet> I think the first two languages that should be taught are haskell and scheme. I'm not sure which first, though
05:26:10 <dmhouse> Software engineers != engineers
05:26:17 <stevenmarky_> hey! :-(
05:26:17 <Adamant> ivanm: we have to do both calc and discrete math in most CS programs
05:26:29 <Jafet> ivanm, you learn the former in high school, and high school never counts
05:26:34 <Adamant> or did you mean analysis instead of discrete or something
05:26:36 <dmhouse> Jafet: really? Two functional languages?
05:26:41 <ivanm> Adamant: I only had to do discrete math for my IT degree (but I did calculus for my math/physics majors in my science degree)
05:26:50 <bremner> dmhouse: yeah, I know what you mean, but where I am they half in the EE dept.
05:26:51 <ivanm> dmhouse: exactly
05:26:54 <Jafet> Lisp is rather imperative.
05:26:55 <Adamant> yeah
05:27:32 <Jafet> And anyway, better than teaching dysfunctional ones
05:27:44 <ivanm> Jafet: "the former" == calculus? if so, then not all students in aus do so, and they want to teach _more_ calculus (apparently the people that organised the degree are the comp. physics-based people)
05:27:47 <dmhouse> Well nonfunctional languges certainly have their place
05:27:49 <chrisdone> scheme is great as a way to show how you can build powerful things upon simple constructs
05:28:01 <Jafet> ivanm, the old particle model
05:28:05 <ivanm> Jafet: oh, right
05:28:08 <chrisdone> both semantically and syntactically
05:28:10 <dmhouse> Haskell isn't the be all and end all of languges. *ducks*
05:28:22 <ivanm> Jafet: why does't high school count?
05:28:31 * Jafet writes "dmhouse" in the little black caleskell revolution todo book
05:28:31 <ivanm> dmhouse: exactly: no dependent types!
05:28:47 <chrisdone> we have found a witch. may we burn him? *presents dmhouse*
05:28:56 <ksf> scheme is also great for metacircularity
05:29:09 <dmhouse> *Obligatory Monty Python reference*
05:29:12 <rajeshsr> ivanm, it looks like i need to upgrade gchi, right?
05:29:20 <ivanm> rajeshsr: huh?
05:29:42 <rajeshsr> ivanm,  version 6.8.2 is what i have
05:29:46 <Adamant> Jafet: shouldn't that book be read and have a picture on the cover of Chairman Monoid?
05:29:46 <chrisdone> dmhouse: why do witches use Java? .. because they're.. made of wood? ... goood!
05:29:47 <ivanm> chrisdone: it rained too much; the wood is all wet!
05:29:52 <rajeshsr> and it has smaller versions..
05:29:55 <Adamant> *red
05:30:02 <ivanm> rajeshsr: well, why _do_ you have such an old version? :p
05:30:09 <dmhouse> I think Java and Haskell, or maybe C and Haskell, would make good first year languages.
05:30:14 <Adamant> whether it should be read is an entirely different issue
05:30:20 <ivanm> rajeshsr: but there should be an older version that supports 6.8.2 (look for one that supports base-3)
05:30:25 <rajeshsr> i installed it via synaptic!
05:30:32 <dmhouse> Perhaps an ML instead of Haskell because it might be confusing to introduce a lazy and strict language at the same time
05:31:04 <rajeshsr> ivanm, well, am interested in upgrading haskell of course! So am i to get the source separately?
05:31:12 <Jafet> ivanm, any "computer scientist" has to know a little of all the math covered in TAOCP
05:31:17 <ksf> confusion is the first step to enlightenment
05:31:25 <Jafet> Or what has been published of it so far, at any rate
05:31:25 <ivanm> rajeshsr: which distro?
05:31:31 <ksf> you won't get material into student's head by trying not to confuse them.
05:31:41 <rajeshsr> Jafet, ha, man! That is too much to ask for! TAOCP is really hard!!
05:31:47 <ivanm> Jafet: I've never read TAOCP... (then again, I consider myself more of a mathematician than a CSer)
05:31:49 <rajeshsr> ivanm, debian
05:32:07 <ivanm> rajeshsr: there are newer ghc versions for debian IIRC...
05:32:08 <Jafet> TAOCP is math disguised as a computer science textbook
05:32:10 <dmhouse> ksf: perhaps, but there's no need to deliberately obfuscate things
05:32:33 <rajeshsr> ivanm, any idea of which repo i need to include for that?
05:32:35 <Jafet> Some parts are actually like Martin Gardner for dummies
05:32:37 <ivanm> rajeshsr: http://packages.debian.org/sid/ghc6
05:32:41 <ksf> obfuscating is if you hide fundamental considerations under the carpet.
05:33:15 <Jafet> dmhouse, SICP already introduces lazy, constraint and non-deterministic computing all within the framework of a strict language
05:33:17 <dmhouse> ksf: ... or if you explain things in deliberately confusing language
05:33:45 <ksf> you're free to start out with examples where strict vs. lazy does not make a difference, and then introduce an example in each language that shows how each one is better than the other.
05:34:34 <rajeshsr> ivanm, strange! now synaptic shows about upgrading! I did check periodically! Thanks, let me see about it.
05:35:12 <dmhouse> Jafet: that's mostly orthogonal to what I said
05:35:40 <Jafet> Then I don't think I understood what you said
05:35:43 <rajeshsr> BTW, why not have python for fresh men? I think haskell isn't as easy to learn as python..
05:35:51 <xerox> <Jafet,dmhouse>=0
05:36:00 <dmhouse> Jafet: I can just imagine it being a bit confusing if you're learning two different languages and have to keep in mind the vastly different evaluation semantics, and which belongs to which.
05:36:13 <dmhouse> Perhaps not, actually, seeing as {Java,C} have such different semantics to Haskell anyway
05:36:16 <Jafet> Well, I never gave thought to the idea of teaching both at once.
05:36:32 <dmhouse> Jafet: well this is what I was saying
05:36:52 <dmhouse> "I think Java and Haskell, or maybe C and Haskell, would make good first year languages. Perhaps an ML instead of Haskell because it might be confusing to introduce a lazy and strict language at the same time."
05:37:28 <dmhouse> rajeshsr: yes, that's a nice idea. Python would make a very nice absolute-beginner's language
05:37:30 <rajeshsr> dmhouse, python and haskell looks better! :)
05:37:32 <dobblego> I think the idea that a language is a learning topic is ridiculous, detrimental and holding back the educational institution
05:37:53 <dmhouse> rajeshsr: yeah, you might be right there. You'll have to introduce OOP at some point as it's so important in the real world, but perhaps not in the first course
05:38:03 <kamatsu_> Manuel Chakravarty did a paper on teaching Haskell to first years
05:38:15 <kamatsu_> (i.e TacticalGrave)
05:38:18 <kamatsu_> *Grace
05:38:26 <bremner> I'm trying to make a monad example out of slightly simplified version of the State monad wrapping (s->s)    but I can't see a sensible defininition of (>>=).  Any suggestions?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24622
05:38:44 <kamatsu_> he says that Haskell is a good language for teaching fundamental computing concepts, but the goal shouldn't be to teach FP to first years, it should be to teach computing to first years with FP
05:38:47 <Jonno_FTW> kamatsu_: i would like to read this paper
05:38:52 <dmhouse> bremner: I'm not sure that'll work as a monad. Where's your type parameter?
05:38:54 <dobblego> bremner, it's not a monad
05:39:04 <kamatsu_> Jonno_FTW: the link is at http://liamoc.net/pages/reading.html
05:39:06 <Jafet> The educational institution holds itself back, anyway
05:39:07 <fax> bremner -- it's not possible
05:39:12 <Jonno_FTW> thanks
05:39:12 <rajeshsr> dobblego, well, look at language as a formal way of putting down your thoughts! It is indeed as important for a programmer as much as a natural language is important for a philosopher!
05:39:44 <Jonno_FTW> i think they should teach python instead of C in first year
05:40:00 <bremner> yeah, after beating my head for while, I've reached that conclusion.  But what's the problem? Transform has a type parameter s
05:40:20 <kamatsu> Jonno_FTW: I actually like C in first year
05:40:27 <fax> brenmer, look it isn't possible you can see exactly why if you unfold th definitions
05:40:31 <fax> :t (>>=)
05:40:31 <dobblego> bremner, it has the correct kind, but the type constructor does not form a monad
05:40:32 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
05:40:33 <Jonno_FTW> but, it's so much simpler
05:40:37 <kamatsu> I think Haskell would be better but C is good too
05:40:38 <Jafet> Maybe they should differentiate programmer majors by field
05:40:46 <kamatsu> Python is in no way simpler than C
05:40:52 <Jonno_FTW> if they want to teach procedural programming
05:40:52 <fax> m s = Tranform s = s->s okay?
05:40:57 <dmhouse> kamatsu: it is in some ways. In other ways, it's more complicated.
05:40:57 <Jonno_FTW> i think it might be easier to learn
05:41:00 <fax> we're getting rid of constructors to make it easier to read
05:41:08 <rajeshsr> kamatsu, nope! Pointers are quite hard to fathom for a newbie to C
05:41:14 <dobblego> bremner, (a -> a) -> (a -> b -> b) -> b -> b
05:41:15 <dmhouse> kamatsu: it's certainly simpler to get simple programs working quickly
05:41:15 <kamatsu> rajeshsr: I know, I teach it to them alot
05:41:18 <fax> ?djinn  (a -> a) -> (a -> b -> b) -> (b -> b)
05:41:18 <lambdabot> f _ _ a = a
05:41:20 <dobblego> @djinn (a -> a) -> (a -> b -> b) -> b -> b
05:41:21 <lambdabot> f _ _ a = a
05:41:27 <fax> the only way to do it is the trivial one
05:41:32 <kamatsu> I think that Python introduces concepts like OO and so forth when it would do students better to learn what a stack is
05:41:44 <kamatsu> as in a call stack
05:41:48 <kamatsu> and, how memory works
05:41:53 <kamatsu> these are useful things to learn
05:42:19 <dobblego> bremner, not all things that take a type argument can be used as a monad
05:42:30 <rajeshsr> kamatsu, hmm, right! But not for a newbie, memory management and all will come as they become more proficient
05:42:34 <dmhouse> kamatsu: absolutely, but not straight away. We're talking the very first thing they learn
05:42:45 <kamatsu> At UNSW we teach C to first years with great success
05:42:45 <dmhouse> I'm not even sure I'd teach Python OOP in a first course
05:42:59 <dobblego> bremner, newtype Transform a = Transform (Int -> a) -- this does though
05:43:05 <kamatsu> they learn about stack, machine code, memory allocation and so on
05:43:15 <Jafet> "Welcome to university, freshman! Would you like to major in web development, industrial middleware, console games, legacy maintenance, systems administration, useless academic research, or software testing*? (* Subject to availability)"
05:43:19 <kamatsu> not in a very in-depth way, but at least enough to be able to reason about what their code is doing on the machine.
05:43:28 <rajeshsr> kamatsu, well, here the first programming language people learn in C. Most newbie don't understand malloc at all until they come to 2nd year end or so..
05:43:52 <kamatsu> We encourage those who don't understand malloc after 6 months to drop computer science.
05:44:40 <rajeshsr> kamatsu, haha! :)
05:44:50 <chrisdone> it would be nice if languages were taught with problems that they are useful for solving
05:45:10 <ksandstr> wouldn't it be nicer if you never had a problem that you needed a programming language to solve
05:45:16 <kamatsu> anyway, sadly, Haskell has been relegated to later-year optional courses only at UNSW
05:45:17 <chrisdone> like, don't try to teach high level problems with C
05:45:18 <ksandstr> then you could skip the learning part altogether.
05:45:30 <fax> ksandstr --- that would skip the learning part ?
05:45:31 <kamatsu> chrisdone: depends on what you mean by "high level problems"?
05:46:09 <ksandstr> fax: "reductio ad absurdum", see
05:46:28 <kamatsu> In our 1927 course, Data Structures and Algos, we basically teach all the staple DS+A's in C
05:46:41 <bremner> dobblego: oh, got it finally. Thanks.  comparing to a "pseudo State", monad, I get  newtype IntState a = IntState ( Int->(a,Int) )
05:46:53 <kamatsu> Haskell is better suited to some of them, but none of the C implementations are truly icky.
05:46:56 <dobblego> bremner, yep that'll work too
05:47:21 <chrisdone> kamatsu: well, C solves good filesystem and OS problems and in that sense as a student you can see why it's a good idea to have pointers and variables as vectors of bytes, etc.
05:47:28 <ksandstr> kamatsu: and there's no magic in C
05:47:41 <kamatsu> right, the lack of magic is what I like about teaching it to first years
05:47:51 <bremner> so, on the other topic this morning, what programming languages text do Haskell people like?
05:47:59 <kamatsu> I would advocate teaching C and Haskell simultaneously, but I wonder how well students would cope
05:48:18 <kamatsu> bremner: do you mean, what texts about a programming language? or what programming languages research text?
05:48:28 <dmhouse> bremner: for learning haskell?
05:48:31 <dmhouse> ?where rwh
05:48:31 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
05:48:37 <kamatsu> ?where lyah
05:48:37 <lambdabot> http://www.learnyouahaskell.com/
05:48:43 <bremner> kamatsu, dmhouse: things like SICP
05:48:51 <kamatsu> bremner: ah, SICP, i like that book
05:48:54 <dmhouse> bremner: well, SICP :)
05:49:07 <kamatsu> the books I like are..
05:49:25 <kamatsu> not really related to programming languages per se
05:49:27 <bremner> anyone know: http://www.cs.brown.edu/~sk/Publications/Books/ProgLangs/
05:49:40 <chrisdone> at college we were taught Visual Basic in the first year, then PASCAL and then C. we had to write a maze game in C which read a map from a file and then in the console you'd play a maze game. most people passed but even the teacher didn't understand the problem of reading from a file properl
05:49:58 <kamatsu> bremner: seen it
05:50:08 <kamatsu> bremner: It's not really like SICP as such
05:50:14 <chrisdone> if that was in Python or something, it would've been much easier to grasp
05:50:35 <kamatsu> chrisdone: judging from that selection of languages, you didn't really need Python, you needed better teachers
05:50:39 <dmhouse> chrisdone: Yeah, this is sort of why I think Python would be nice as a first year language. With C as soon as you bring in something as basic as reading a file you've got to think about buffer overflows etc.
05:50:43 <Jafet> python tends to encourage programming by luckiness, which may work well in practice but is hardly something you want to teach to freshmen
05:50:53 <luite> chrisdone: what was the objective of the visual basic course?
05:51:02 <dmhouse> Python's a one-line statement to read the lines of a file into an array for example.
05:51:13 <dmhouse> Jafet: "programming by luckiness"? What do you mean by that?
05:51:17 <chrisdone> kamatsu: the teacher doesn't matter that much in this example, the students had to deal with malloc and pointers to do something that simple
05:51:22 <Twey> 13:50:39 < dmhouse> Python's a one-line statement to read the lines of a file into an array for example.
05:51:35 <Twey> dmhouse: Yes, but by default lines() returns a safe generator
05:51:44 <kamatsu> chrisdone: this is true, but malloc and pointers are *not hard*
05:51:45 <dmhouse> Twey: so?
05:51:46 <chrisdone> luite: basic loops, conditionals, fundamental things like that. it's easy to draw graphics with VB so it's a fast ROI
05:51:58 <bremner> kamatsu: well, I'm currently using http://www.info.ucl.ac.be/~pvr/book.html, which also isn't SICP :)
05:52:09 <fax> kamatsu everything is hard
05:52:14 <Jafet> dmhouse, the type system, the version changes, the strange ad-hoc semantics
05:52:16 <kamatsu> fax: i mean in a relative sense
05:52:28 <kamatsu> The semantics of python are somewhat all over the place
05:52:37 <dmhouse> I find it extremely intuitive
05:52:39 <Jafet> dmhouse, and I don't trust implementations by people like guido
05:52:40 <kamatsu> Haskell doesn't have formal semantics, but at least it's pretty consistent.
05:52:53 <fax> SML has formal semantics
05:52:53 <luite> chrisdone: hm, but why pascal then?
05:52:54 <dmhouse> kamatsu: could you give an example?
05:53:03 <Jafet> fax, for fairly obvious reasons
05:53:09 <kamatsu> I was writing a paper on it last year
05:53:30 <kamatsu> then I realised that if I hated python so much I didn't have to use it and stopped halfway
05:53:33 <chrisdone> luite: god knows. I presume out of tradition, PASCAL is a teaching language after all. it teaches basic structured programming and makes it hard to do anything else as a beginner
05:54:05 <Jafet> I've seen a CRC32 in pascal once
05:54:10 <Jafet> It's breathtaking
05:54:25 <kamatsu> also, I think we all disagree with Guido about his stance  on FP..
05:54:33 <luite> Jafet: probably an optimized crc32 implementation?
05:54:36 <Associat0r> join ##fsharp
05:54:36 <Twey> Why else would we be here?  :Ã¾
05:54:37 <dmhouse> Yes, I don't really respect Guido.
05:54:40 <Associat0r> sorry
05:54:43 <ydo> how to make a list out of a tuple of unknown length?
05:54:47 <luite> a basic one shouldn't be that breathtaking :)
05:54:52 <kamatsu> bremner: wrt to books, check out my reading list http://liamoc.net/pages/reading.html
05:54:53 <fax> ydo, impossible
05:54:53 <Twey> ydo: You can't have a tuple of unknown length
05:54:59 <Twey> ydo: That's not what tuples are for
05:55:02 <dmhouse> ydo: you can't, since the type of "a tuple of unknown length" is variable
05:55:02 <Entroacceptor> kamatsu: what is his stance?
05:55:14 <dmhouse> ydo: think to yourself, what would the type of this function be?
05:55:28 <Jafet> Entroacceptor, cheerful ignorance
05:55:29 <bremner> kamatsu: you crash midori :(
05:55:33 <ydo> the type of the function would be several? :)
05:55:54 <chrisdone> that reminds me, there's a slice syntax for accessing arbitrary tuples which I thought was nice
05:55:54 <Entroacceptor> kamatsu: vimprobable, too
05:56:00 <Entroacceptor> broken webkit
05:56:26 <kamatsu> bremner: I use @font-face.
05:56:29 <chrisdone> $(tuple 3 4) ('a',1,"x",0) == "x", or some such
05:56:30 <kamatsu> bremner: sorry..
05:56:38 <chrisdone> er, splice
05:56:59 <kamatsu> Entroacceptor: vimprobable?
05:57:05 <kamatsu> probable vim?
05:57:31 <Entroacceptor> :) http://yllr.net/vimprobable/
05:57:42 <rajeshsr> why is there so much wave against guido? is it because of python or what?
05:58:02 <bremner> outside of python, who knows him?
05:58:04 <chrisdone> luite: we made a maze game in VB where you have to get from A o B. I wrote pacman :p
05:58:08 <Entroacceptor> like uzbl, but more sanely usable;)
05:58:12 <bremner> inside of python, it's dark
05:58:12 <kamatsu> Entroacceptor: right
05:58:17 <Twey> rajeshsr: It's because of his stance on programming
05:58:19 <jlouis> Guido is cool. His purpose is to be there so the other python devs agree. if they don't, guido will pull an arbitrary decision
05:58:23 <dobblego> rajeshsr, he is quite clueless on programming language design and has designed a popular programming language; the rest follows
05:58:43 <dmhouse> Well Python's design is really quite good I think
05:58:48 <HugoDaniel> is it ?
05:58:49 <Entroacceptor> [citiation needed]
05:58:51 * dobblego giggles
05:58:54 <Twey> Heheh
05:58:59 <chrisdone> jlouis: languages tend to need a dictator at least a figure head who makes the hard decisions. look at Common Lisp
05:59:00 <HugoDaniel> dmhouse: specially the GIL :P
05:59:03 <kamatsu> dmhouse: http://math.andrej.com/2009/04/09/pythons-lambda-is-broken/
05:59:08 <dmhouse> It hits the sweet spot of simplicity and elegance
05:59:12 <dmhouse> HugoDaniel: with notable exceptions.
05:59:16 <HugoDaniel> :)
05:59:19 <kamatsu> chrisdone: does haskell?
05:59:23 <jlouis> chrisdone: mm. I like Go more than Python though
05:59:35 <kamatsu> I was very underwhelmed by Go
05:59:38 <luite> chrisdone: ah we had to write some networked two-player game with ai, so programs could play against each other
05:59:38 <dmhouse> HugoDaniel: (Moreover it could perhaps be argued that's more of an implementation detail. I'm not sure how successful that argument would be, however.)
05:59:38 <jlouis> I would like programming in Go I think
05:59:44 <luite> chrisdone: (in java)
05:59:46 <rajeshsr> well, python seems to be consistent though dynamic typing at times can get annoying! But it is the quickest way to program things that works!
05:59:50 <HugoDaniel> chrisdone is right, in haskell that guy is called HugoDaniel :)
05:59:52 <dobblego> sometimes I use python at work and think to myself if I'd be better off using Java. The answer is often yes
06:00:00 <chrisdone> kamatsu: we have the GHC developers (and, I guess, the haskell committe)
06:00:11 <kamatsu> chrisdone: not exactly a dictator
06:00:12 <fax> rajeshsr no it's not
06:00:13 <HugoDaniel> jlouis: dont you mean algo68 ?
06:00:15 <kamatsu> chrisdone: anyone can become a GHC dev
06:00:16 <HugoDaniel> algol68
06:00:35 <rajeshsr> fax, why?
06:00:47 <kamatsu> len(string) graahrahrahah
06:00:48 <jlouis> HugoDaniel: I like programming Haskell more :)
06:00:49 <chrisdone> kamatsu: well, whatever gets implemented in GHC and some of Hugs pretty much becomes de facto standard and for others actual standard
06:01:14 <dmhouse> Haskell prime was a shambles of getting things done, however :)
06:01:21 <kamatsu> chrisdone: right, but anyone has the power to shape that standard, unlike Python, where the canonical implementation is always Guido's decision.
06:01:33 <chrisdone> dmhouse: but haskell' doesn't matter too much, we still get what we want
06:01:35 <luite> chrisdone: but to be honest, I think gui and network programming shouldn't have been part of a programming course... although it may make the course a bit more 'attractive'
06:01:42 <HugoDaniel> today im going to call a C function from my haskell code
06:01:46 <HugoDaniel> just because i need it fast
06:01:49 <dmhouse> chrisdone: yes, that's true. Haskell is lucky because everyone uses GHC.
06:01:55 <kamatsu> HugoDaniel: tried making the haskell fast?
06:02:15 <Associat0r> did anyone here try Agda?
06:02:20 <kamatsu> I did
06:02:22 <HugoDaniel> i did, it is currently at my best effort
06:02:22 <kamatsu> Agda is awesome
06:02:41 <Jafet> rajeshsr, Guido: "there's nothing wrong with GIL" "cpython doesn't need tail recursion" "we don't want lambda in python"
06:03:00 <kamatsu> He also argued in favor of removing map and other useful fp things
06:03:34 <rajeshsr> Jafet, kamatsu is it?! that is quite strange! Without FP tools, python is useless!
06:03:37 <Associat0r> kamatsu: but it still in early stages right?
06:03:42 <chrisdone> kamatsu: sure, but they are both arbitrators. if the GHC devs don't like something, they don't have to implement it. and I doubt the average haskeller who wants a GHC feature has the x months it would take to get up to scratch with GHC and add the change themselves. so in that sense the GHC devs are dictators of where Haskell is going. we're just lucky that what the community wants tends to get implemented
06:03:45 <luite> kamatsu: the problem is that too many pythonners will switch to haskell if they know too many fp thingies ;)
06:03:52 <FliPPeh> Tail recursion in python?
06:03:55 <kamatsu> Associat0r: yeah, but most certainly usable
06:03:56 <FliPPeh> Like this? http://g.imagehost.org/0632/snake.jpg
06:04:11 <rajeshsr> FliPPeh, i guess he means Tail recursion optimization
06:04:24 <dmhouse> kamatsu: I think I agree with getting rid of map. Pythonites are big on their "only one way to do things", and map can be rewritten as a list comprehension, and fold as a loop. In many cases (in Python), the latter choices are clearer.
06:04:28 <kamatsu> chrisdone: I guess, but such an option isn't even open to the Python community.
06:04:39 <dmhouse> FliPPeh: heh
06:04:41 <kamatsu> dmhouse: I think that one way to do things mentality is harmful
06:04:45 <FliPPeh> :)
06:04:51 <FliPPeh> that's gonna be a deadlock sooner or later
06:05:14 <chrisdone> kamatsu: indeed. but I'm not disputing that's bad. I'm saying I think it's what a language needs to be successful and used by people
06:05:24 <dmhouse> kamatsu: 1) perhaps, but it's central to the Python philosophy so the decision to do without map/filter is certainly Pythonic. 2) Why?
06:05:38 <Jafet> dmhouse, that statement isn't bad, or meaningless, or disagreeable, or controversial. It's just wrong.
06:05:45 <rajeshsr> dmhouse, Only one *elegant* way to do it shall make python totally FP! :)
06:05:46 <dmhouse> Jafet: which one?
06:05:49 <Jafet> There is never one way to do things.
06:06:07 <kamatsu> dmhouse: Some ways are better than others for various circumstances
06:06:10 <Jafet> Or rather, for any class of things X to do, there is never one way to do things for all the things in X.
06:06:15 <HugoDaniel> i do like plone
06:06:17 <dmhouse> Depends under which equivalence relation you view things.
06:06:20 <Jafet> Take timsort, for example. A massive hack.
06:06:23 <kamatsu> some ways communicate programmer intent more clearly in certain circumstances than others
06:06:38 <Jafet> The python programmers view timsort as a massive novel optimization of some sort
06:06:48 <kamatsu> python shouldn't say that because this recursive function can be rewritten as a loop, it should be because that's how you do it, it should be up to the programmer as to what best expresses the intent
06:06:52 <kamatsu> that's why I want TCE
06:07:11 <HugoDaniel> lets not talk about python, and talk about haskell instead
06:07:21 <HugoDaniel> have you guys used the "par" and "seq" functions ?
06:07:24 <HugoDaniel> amazing stuff
06:07:26 <HugoDaniel> :)
06:07:31 <dmhouse> HugoDaniel: magic stuff ;)
06:07:35 <kamatsu> Indeed
06:07:37 <chrisdone> kamatsu: my experience of Common Lisp (admittedly haven't used it in a few years): I needed a sockets library, OK so use the sockets library provided by my implementation. ah it doesn't do X, let's try another implementation, ah it does do this and I'm not sure if it does this because there's no documentation, and now my other code doesn't work on this implementation, and there are no packages for this one, let's try SBCL that has
06:07:37 <chrisdone> everything right? oh it won't even start on windows.  hmm what's this Haskell language? one main implementation? hundreds of packages? god damn!
06:07:41 <dmhouse> kamatsu: that's true, but on the other hand too many different ways of doing things hurts consistency, which in turn hurts readability. It's a toss-up where on the scale you land.
06:07:41 <kamatsu> I also love Control.Concurrent
06:07:46 <dmhouse> s/land/want to land/
06:08:01 <HugoDaniel> i wonder why my code gets so slow whenever i put -Nn where n > number of cores my cpu has
06:08:09 <kamatsu> dmhouse: I think Haskell sits better on the scale than Python, because Python established a set of dogma and Haskell just encourages people to be sensible.
06:08:17 <HugoDaniel> it is probably a nasty ghc bug
06:08:23 <luite> chrisdone: but still the problem of no documentation :p
06:08:38 <Jafet> Another possible explanation is that Python attracts dogmatic programmers and Haskell attracts sensible programmers.
06:08:44 <chrisdone> luite: haha... but at least the standard stuff is well documented
06:08:49 <fax> "Haskell attracts sensible programmers" lol
06:08:51 <HugoDaniel> one of the things i am so amazed is at how many problems can be expressed recursively by the nfibs approach
06:08:51 <Jafet> Hugo, how slow is so slow
06:08:56 <chrisdone> fax: haha
06:09:01 <kamatsu> chrisdone: That is also partially because the Common Lisp community is more isolated than Smalltalk and less active than OCaml.
06:09:01 <HugoDaniel> Jafet: like... 30x slower
06:09:33 <HugoDaniel> ttyl
06:09:40 <jlouis> kamatsu: Control.Concurrent is amazing!
06:09:41 <dmhouse> kamatsu: Haskell establishes some stylistic dogma, too. I've always liked that functions must begin with lowercase and data constructors with uppercase. It encourages more stylistic consistency, which is good for readability, as I said
06:09:42 <chrisdone> kamatsu: I think the CL has many compounding issues that exacerbate the situation
06:09:48 <Jafet> That's... pretty slow
06:10:07 <Jafet> dmhouse, it's German, that's all
06:10:09 <kamatsu> dmhouse: that's not so much dogma as a syntactic rule.
06:10:18 <kamatsu> dmhouse: Ruby has similar rules.
06:10:48 <dmhouse> kamatsu: I agree it's syntactic rather than structural, but it's similar in that by imposing more rules you get more consistent looking programs, which is good.
06:11:01 <Entroacceptor> compare to perl....
06:11:03 <kamatsu> I agree in that respect
06:11:11 <rajeshsr> BTW, someone here gave the link to: http://math.andrej.com/2009/04/09/pythons-lambda-is-broken/
06:11:14 <chrisdone> kamatsu: look at Clojure, it's getting pretty popular, it has a positive community and a dictator
06:11:29 <kamatsu> but I think the way to express a program should be based on the problems presented, not on some arbitrary dogma
06:11:35 <rajeshsr> But what is wrong here? Python is not haskell! It has its own semantics!
06:11:37 <dmhouse> If I were designing a language for example, I'd mandate (1) an indentation style, (2) an identifier naming style (i.e. camelCase versus lisp-style versus under_scores), ...
06:11:39 <kamatsu> casing rules don't really change with respect to the problem
06:11:48 <kamatsu> rajeshsr: It's just that Python's semantics are retarded.
06:12:07 <kamatsu> rajeshsr: and it's lambda therefore is not at all similar to the lambda of lambda calculus
06:12:07 <jlouis> dmhouse: like Go :)
06:12:17 <dmhouse> jlouis: hmm, does Go do that? Interesting.
06:12:20 <Jafet> dmhouse, is there any language which enforces layout?
06:12:31 <dobblego> might I suggest #haskell-blah?
06:12:45 <dmhouse> kamatsu: did you read the comments? They basically say "this is not a trivial issue".
06:12:47 <Jafet> dobblego, I hope you won't
06:12:58 <dobblego> Jafet, why?
06:13:15 <chrisdone> dobblego: he was making a language joke
06:13:22 <kamatsu> dmhouse: I understand why it's non-trivial, I still maintain that it's stupid.
06:13:24 <dobblego> sorry, I'm high
06:13:42 <rajeshsr> kamatsu, hmm! But we can't blame it a retarded semantics! Will you say that, just because arrays in C, in rvalue contexts becomes pointer to first element, it is bad! That has been a source of confusion for many newbies and some intermediates!
06:13:54 <kamatsu> i agree, that's also stupid
06:14:06 <Jafet> C programmers know C is retarded, so it's okay.
06:14:20 <dmhouse> rajeshsr: just out of interest, is your period button broken on your keyboard? Reading your posts ends up with me mentally shouting you've got so many exclamation marks :)
06:14:21 <kamatsu> Python programmers make the mistake of thinking that Python is smart
06:14:26 <rajeshsr> Jafet, haha! right, indeed! :)
06:14:51 <dmhouse> Yeah, there are many C decisions which are retarded in retrospect.
06:15:00 <kamatsu> but at the time they seemed like good ideas
06:15:04 <dmhouse> E.g. nullterminated strings. Made sense back in the 80s, but not so much any more.
06:15:09 <rajeshsr> dmhouse, ha, ok. Let me try to cut down that! It is not the first time, am asked about it! :)
06:15:11 <Jafet> Trigraphs!
06:15:19 <chrisdone> hahaha, he can't stop
06:15:41 <Vanadium> nullterminated strings are not any different from []-terminated lists, come on
06:15:51 <kamatsu> i was going to mention that
06:15:55 <kamatsu> Vanadium beat me to it
06:16:01 <chrisdone> Vanadium: well, it's hard not to terminate a list :)
06:16:06 <Twey> No it isn't
06:16:08 * rajeshsr sets a goal to minimize exclamation usage.
06:16:15 <Jafet> They are. You remove one byte from the character set.
06:16:16 <chrisdone> Twey: show me an unterminated list
06:16:24 <Jafet> > [1..]
06:16:25 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
06:16:26 <Twey> > fix (1 :)
06:16:27 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
06:16:29 <chrisdone> that is terminated
06:16:33 <dmhouse> Vanadium: worse, in fact, as you have to follow pointers with Haskell lists
06:16:35 <Twey> No it isn't
06:16:38 <chrisdone> by virtue of being type [a]
06:16:47 <Twey> There is no [] in either of those lists
06:17:02 <dmhouse> Twey: but you can never fall off the end of a list into a different area of memory
06:17:04 <kamatsu> hm, i wonder if haskell is smart enough
06:17:13 <kamatsu> oh, nevermind
06:17:18 <chrisdone> Twey: without [], you couldn't construct it
06:17:18 <dmhouse> ?faq
06:17:19 <lambdabot> The answer is: Yes! Haskell can do that.
06:17:36 <Jafet> > fix ("lo"++) -- hmm, an unterminated string
06:17:37 <lambdabot>   "lololololololololololololololololololololololololololololololololololololo...
06:17:38 <Twey> chrisdone: But I just did construct it.
06:17:40 <dobblego> chrisdone, you can
06:17:41 <amx> when do I have to write "let .. in" and when is let enough
06:17:42 <Twey> dmhouse: Certainly not
06:17:53 <kamatsu> just wondering if it's possible to determine if a list is infinitely long at runtime in haskell
06:17:56 <Jafet> amx, only in do blocks
06:18:01 <kamatsu> ... but then I realised it isn't
06:18:08 <Twey> amx: In do-blocks, âletâ can be used as a statement to scope over the rest of the block
06:18:14 * Jafet gives kamatsu some rice
06:18:15 <amx> ah, ok.
06:18:24 <dmhouse> kamatsu: hmm, if only there were a landmark computer science result about this sort of thing...
06:18:25 <maltem> data Stream a = S a (Stream a)
06:18:26 <Twey> kamatsu: That's a little thing we like to call the halting problem âº
06:18:27 <kamatsu> oops
06:18:31 <kamatsu> Jafet: Thanks but... ?
06:18:50 <dmhouse> Twey: overflow is a major disadvantage to nullterminated lists, as well as O(n) length. So Haskell wins in that respect.
06:19:10 * hackagebot dedukti 1.1.1 - A type-checker for the » -modulo calculus.  http://hackage.haskell.org/package/dedukti-1.1.1 (MathieuBoespflug)
06:19:17 <kamatsu> Yes yes, 2 hours sleep. Spent so long playing Die Gilde 2
06:19:19 <Vanadium> If you guys had come up with lists, they would probably have a single constructor Cons head tail lengthOfTail >:[
06:19:19 <Twey> dmhouse: Sure (though we also have O(n) length)
06:19:20 <chrisdone> alright I'll take your point that it's an infinite list, regardless of the fact that they are well typed as proper values
06:19:32 <dmhouse> Twey: yes, hence my mentioning that separately.
06:19:37 <Twey> *nod*
06:20:15 <Jafet> Vanadium, that looks more like the lisp formulation of lists
06:20:30 <Twey> Lisp lists have associated lengths?
06:20:51 <kamatsu> Lisp is old, i wouldn't have thought old timers would have tolerated such memory inefficiency
06:20:51 <Twey> That's actually not a bad list design, in a strict languageâ¦
06:20:55 <chrisdone> anyway, my point was obvious even if you want to argue straw man something irrelevant
06:22:13 <chrisdone> Twey: lisp lists are just conses too
06:22:27 <Twey> chrisdone: I thought so
06:22:55 <Twey> '(1 2 3 4) = '(1 . (2 . (3 . (4 . ()))))
06:22:59 <Jafet> Actually old lisp was much more inefficient
06:24:23 <kamatsu> Twey: Lisp has infix cons now?
06:24:47 <Twey> kamatsu: Always has AFAIKâ¦
06:25:02 <Twey> (a . b) is a cons cell with a and b in it
06:25:08 <Twey> Dotted-pair syntax
06:25:12 <kamatsu> oh
06:25:26 <kamatsu> i haven't used lisp extensively, but i didn't realise such a syntax existed
06:25:28 <chrisdone> kamatsu: well, the . syntax works in quotation
06:25:43 <chrisdone> kamatsu: '(1 . 2) = (CONS 1 2)
06:25:54 <kamatsu> ah, right
06:26:21 <Twey> I guess (+ . (1 . (2 . ()))) would evaluate to 3 in a Lisp-1?
06:26:47 <chrisdone> sure
06:26:50 <Jafet> No, it's a syntax error.
06:27:09 <Jafet> If quoted and evaled in the appropriate environment, the result is 3
06:27:27 <chrisdone> Jafet: in what Lisp?
06:27:28 <dobblego> keeping a length with a cons list has quite heavy implications; consider take
06:27:31 <Twey> Oh, huh.
06:28:07 <Jafet> Let's move on to Sequence
06:28:37 <Twey> Well, âCons head tail lenâ doesn't allow zero-length lists
06:28:48 <Jafet> Provide nil.
06:28:52 <Twey> Yeah
06:31:00 <FliPPeh> chrisdone: You made your page using Hakyll, right?
06:31:04 <chrisdone> FliPPeh: yep
06:31:06 <FliPPeh> chrisdone: How did you install it?
06:31:21 <chrisdone> FliPPeh: cabal install hakyll
06:31:26 <FliPPeh> I want to try it out, and whether I install it via pacman or cabal, it won't run
06:31:30 <FliPPeh> It's always missing a package
06:31:44 <chrisdone> what package?
06:31:55 <FliPPeh> Text.Hakyll.ContextCreator
06:32:20 <FliPPeh> I do have Text.Hakyll.Context any every other module
06:32:27 <FliPPeh> But not ContextCreator :/
06:32:30 <kamatsu> I made my page with hakyll as well
06:32:36 <kamatsu> kudos to jaspervdj for making it
06:32:51 <chrisdone> kamatsu: yeah it's ace
06:33:05 <chrisdone> FliPPeh: what module is requiring Text.Hakyll.Context?
06:33:29 <FliPPeh> I was trying the tutorial
06:33:41 <FliPPeh> The function "createPage" lives in the ContextCreator
06:33:55 <FliPPeh> ghc-pkg check reports no broken packages
06:34:21 <chrisdone> FliPPeh: in my hakyll file I have: import Text.Hakyll.CreateContext (createPage)
06:34:36 <chrisdone> FliPPeh: maybe that particular piece of documentation is out-dated
06:34:37 <FliPPeh> CreateContext, I meant that one, sorry
06:35:01 <FliPPeh> hakyll.hs:4:7: Could not find module `Text.Hakyll.CreateContext':
06:35:35 <chrisdone> FliPPeh: what version of hakyll do you have?
06:35:46 <FliPPeh> I guess it's the latest one, but let's see....
06:36:01 <chrisdone> I'm on hakyll-2.0
06:36:03 <FliPPeh> 1.4-1
06:36:07 <chrisdone> time to update!
06:36:17 <chrisdone> cabal update; cabal install hakyll
06:36:23 <FliPPeh> Looks like cabal time then
06:37:40 <FliPPeh> there it is.
06:38:05 <FliPPeh> The first time I tried installing hakyll by Cabal, it failed..
06:38:07 <FliPPeh> Strange
06:38:09 <FliPPeh> But thanks :)
06:38:47 <chrisdone> welcome
06:40:47 <chrisdone> I like how he gives archives of blog sits you can just pick up and edit, and also goes through creating a blog, feeds, tags, etc. progressively so you can do it yourself from the ground up
06:41:16 <FliPPeh> Yep, that's nice :)
07:34:32 <Mathnerd314> > let 1 = 2 in 1+1
07:34:33 <lambdabot>   2
07:34:47 <Mathnerd314> It should be 4, right?
07:35:13 <FliPPeh> Mathnerd314: You can't define variables with numbers as name
07:35:35 <FliPPeh> > let 2 = 666 in 2
07:35:36 <lambdabot>   2
07:35:41 <EvanR> but you have a number data
07:35:55 <EvanR> data Number = Number0 | Number1 | Number2...
07:36:10 <FliPPeh> :/
07:36:14 <FliPPeh> Sounds rather lame
07:36:26 <EvanR> hehehe
07:36:47 <EvanR> or you could defined zero and use church numerals ;)
07:37:49 <FliPPeh> > let x (+) y = 4 in 1+1
07:37:50 <lambdabot>   2
07:37:55 <FliPPeh> Whaaat.
07:38:30 <FliPPeh> > let x `plus` y = 4 in 1 `plus` 1
07:38:31 <lambdabot>   4
07:39:02 <FliPPeh> > let x + y = 4 in 1+1
07:39:03 <lambdabot>   4
07:39:04 <FliPPeh> :)
07:39:16 <FliPPeh> Mathnerd314: That's how you do it!
07:39:26 <maltem> Mathnerd314, in "let 1 = 2", 1 is a pattern that is matched against 2. The pattern-match would diverge, but there's no way to force it, so there's no error.
07:39:28 <FliPPeh> > let x + y = "OH GOD NO" in 1+1
07:39:29 <lambdabot>   "OH GOD NO"
07:41:24 <maltem> One might want the compiler to warn about a single literal used as a patternâ¦
07:41:51 <EvanR> it would be like an assertion ;)
07:41:58 <EvanR> if this expression isnt that value, error
07:42:46 <maltem> Alas, that's not how lazy pattern matches work
07:42:52 <FliPPeh> > let assert False = error "assertion failed" in assert (4 == 6)
07:42:53 <lambdabot>   * Exception: assertion failed
07:42:56 <FliPPeh> > let assert False = error "assertion failed" in assert (4 == 4)
07:42:57 <lambdabot>   * Exception: <interactive>:1:145-183: Non-exhaustive patterns in function a...
07:43:03 <EvanR> well, dont use a lazy pattern
07:43:10 <FliPPeh> That's a FAILSAFE function
07:43:17 <harlekin> > read 4.5 :: Ratio Int
07:43:18 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Base.String)
07:43:18 <lambdabot>    arising from the l...
07:43:18 <maltem> > let !1 = 2 in "foo"
07:43:19 <lambdabot>   "* Exception: <interactive>:1:145-150: Non-exhaustive patterns in pattern b...
07:43:25 <maltem> ok :)
07:43:31 <Twey> Weird
07:43:46 <FliPPeh> > let assert False = error "assertion failed"; assert True = True in assert (4 == 4)
07:43:47 <lambdabot>   True
07:43:51 <FliPPeh> > let assert False = error "assertion failed"; assert True = True in assert (4 == 8)
07:43:52 <lambdabot>   * Exception: assertion failed
07:44:41 <Twey> Oh, I see
07:45:15 <ezyang> I wonder if Hood has pretty-printing of heavily recursive data structures.
07:45:21 * ezyang would like that 
07:46:09 <Twey> GHC - The Glasgow Haskell Compiler (tested with 4.08)
07:46:11 <Twey> Haha
07:54:44 * hackagebot dedukti 1.1.2 - A type-checker for the » -modulo calculus.  http://hackage.haskell.org/package/dedukti-1.1.2 (MathieuBoespflug)
07:56:28 <palmje> anyone know why I get this error? http://pastebin.com/scuruy2H
07:57:38 <Jonno_FTW> is there a a release date on the windows version of the haskell platform?
07:57:53 <etianen> Hello all, I was wondering if anyone knew about how to convert from Data.ByteBuffer.Lazy.Char8 to String in a way that doesn't truncate charactors
07:59:16 <Mathnerd314> Jonno_FTW: try http://www.haskell.org/pipermail/libraries/2010-March/013376.html
07:59:41 <Jonno_FTW> AWESOME
08:00:17 <Jonno_FTW> would it be reasonable to completely remove my old botched installation?
08:00:58 <ezyang> if Windows is like Linux, yes.
08:01:17 <Jonno_FTW> okie dokie
08:02:53 <rajeshsr>  print "\\"
08:03:05 <Jonno_FTW> > print "\\
08:03:06 <lambdabot>   <no location info>:
08:03:06 <lambdabot>      lexical error in string/character literal at end o...
08:03:10 <Jonno_FTW> > print "\\
08:03:11 <lambdabot>   <no location info>:
08:03:11 <lambdabot>      lexical error in string/character literal at end o...
08:03:12 <Jonno_FTW> > print "\\"
08:03:13 <lambdabot>   <IO ()>
08:03:18 <rajeshsr> and putStrLn "\\" prints \ while former prints \\
08:03:24 <etianen> I mean, so far it looks like once you have a ByteString, it's actually impossible to convert it back to a unicode string.
08:03:28 <rajeshsr> so what is the real difference between the two?
08:03:54 <ddarius> print prints "\\" given "\\" as input.
08:05:39 <monochrom> > print "<IO ()>"
08:05:40 <lambdabot>   <IO ()>
08:06:55 <xerox> monochrom: hahaha
08:07:11 <ddarius> etianen: See the utf8-string package or the text package.
08:07:33 <killerstorm2> hi. I have problem installing SMTPClient library via cabal. :(
08:07:51 <xerox> problems are there for us to solve them
08:08:07 <ddarius> @src print
08:08:07 <lambdabot> print x = putStrLn (show x)
08:08:13 <killerstorm2> It says: "Not in scope: data constructor `Message'", relevant (as far as I understand) code fragments: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24623#a24623
08:08:39 <killerstorm2> as I understand only Message the type is imported, not Message the constructor
08:08:42 <etianen> ddarius: But given that GHC has the ability to convert from bytes to unicode when reading files, why isn't is functionality exposed to the developer for files in memory?
08:09:04 <etianen> ddarius: Importing a third-party library to do so seems like a huge duplication of effort.
08:09:37 <ddarius> etianen: Only recently has GHC had support for Unicode conversion/IO.
08:09:45 <ddarius> etianen: Are you using GHC 6.12?
08:11:02 <etianen> ddarius: Yup, I'm using 6.12. There is the GHC.IO.Encoding module, but this relies of creating a CharBuffer to pass the data to a foreign function, which looks to be pretty inefficient
08:11:25 <etianen> ddarius: It also requires creating a monad to do so.
08:14:04 <ddarius> I highly doubt that it is "pretty inefficient"
08:15:03 <ddarius> Also it seems like you are complaining about lack of convenience rather than lack of ability.
08:15:39 <etianen> Not really, I can convert from string to bytestring in pure code, but converting back requires a monda.
08:15:45 <etianen> (monad)
08:15:56 <Twey> Monads are pure codeâ¦
08:16:07 <etianen> Gah... I meant IO
08:16:16 <Twey> Then you're not creating a monad?
08:17:15 <etianen> I'm current a little behind on the terminology... having only looked at Haskell for a week. However, it looks like I have to start performing IO actions to convert bytestrings to [Char]
08:17:29 <Vanadium> That sounds wrong
08:17:45 <Vanadium> I believe you just need unpack and maybe mapping from [Word8] to [Char]
08:17:46 <ddarius> etianen: I would simply recommend using the text package.  It handles all this stuff for you, provides a nice interface, a variety of functions you'll likely need anyway plus an optimization framework for them
08:18:14 <FliPPeh> unpack :: ByteString -> [Char]
08:18:23 <FliPPeh> For Data.ByteString.Char8
08:18:32 <etianen> FliPPeh: that will truncate any non-ascii characters
08:18:33 <FliPPeh> non-monadic
08:18:34 <Twey> Vanadium: I think etianen's problem is that etianen wishes to do decoding of some character encoding
08:18:51 <FliPPeh> unpack :: ByteString -> [GHC.Word.Word8]
08:18:55 <FliPPeh> Still non-monadic
08:19:01 <Vanadium> Oh, I did not realise that
08:19:16 <Twey> For which etianen should use iconv, or something else like utf8-string
08:19:36 <FliPPeh> Isn't there some encode function?
08:19:53 <etianen> There is an encode function burried in GHC.IO.Encoding
08:20:47 <etianen> But the GHC.IO.Encoding module uses Buffer, which can only be created using IO actions.
08:21:12 <FliPPeh> I think one is not supposed to directly access those GHC modules
08:21:20 <etianen> That was what I was thinking too.
08:21:22 <FliPPeh> At least I've never seen it anywhere
08:21:47 <Reisen> http://codepad.org/s15cl3pv # Does anyone have a more elegant solution for replacing items in a list than this?
08:21:48 <etianen> My frustration is that GHC knows how to convert bytestrings to unicode, but does not expose this to the developer
08:22:43 <FliPPeh> etianen: Looks like you'll need the utf8-string
08:22:46 <etianen> The only way I can see of converting a bytestring to a unicode string using a given encoding is to write it to a file, then read it back out of the file again using a handle set to a specific encoding!
08:22:58 <FliPPeh> It includes Data.ByteString.Lazy.UTF8
08:23:08 <FliPPeh> Probably a strict version of it, too
08:26:29 <liyang> > let replace xs pos val = case splitAt pos xs of { (l, []) -> l ; (l, _:r) ->  l ++ val : r } in replace "abcdefgh" 4 'x'
08:26:30 <lambdabot>   "abcdxfgh"
08:26:57 <liyang> Reisen: though, if you're doing that sort of thing, a list is probably the wrong data structure to use.
08:27:34 <Reisen> liyang, yeah I'm certain of it, but I'm just messing with things; and just small lists
08:27:58 <Reisen> Interesting example though :o
08:28:02 <Reisen> Thank you
08:29:05 <etianen> Hmm... thanks peeps!
08:30:05 <palmje> anyone know how I can fix this problem? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24624#a24624
08:30:28 <rajeshsr> what does this give parse error:  globToRegex' '*':cs = ".*" ++ globToRegex' cs
08:30:30 <rajeshsr> ?
08:31:03 <rajeshsr> while adding parentheses to parameter works as:  globToRegex' ('*':cs)
08:31:04 <rajeshsr> ?
08:31:24 <Twey> rajeshsr: Because function application binds more tightly than anything else
08:31:33 <Twey> So that's (globToRegex '*') : cs = â¦
08:31:37 <Twey> Which is an invalid pattern
08:32:00 <Twey> It's clearer if you space your operators properly.
08:32:47 <byorgey> palmje: what is the type of getFile supposed to be?
08:32:51 <rajeshsr> Twey, anyway it is in function equation here...
08:32:54 <Eelis> glguy: i just sent you a pull request on github for a tiny utf8-string patch :)
08:32:59 * hackagebot AspectAG 0.1.5 - Attribute Grammars in the form of an EDSL  http://hackage.haskell.org/package/AspectAG-0.1.5 (MarcosViera)
08:33:16 <byorgey> palmje: perhaps you want  'return (lines contents)', just 'lines contents' by itself at the end of a do-block won't type check
08:33:19 <palmje> byorgey: String -> [String]
08:33:41 <byorgey> palmje: ok, that isn't possible, functions of type  String -> [String] are not allowed to do any I/O
08:33:49 <byorgey> palmje: you will have to give it the type  String -> IO [String]
08:34:05 <byorgey> and that will work if you add a call to return on the last line
08:35:23 <Twey> readLines :: FilePath -> IO [String]; readLines = fmap lines . readFile
08:40:54 <palmje> byorgey, Twey: that works - thanks
08:41:11 <Boxo> Can you make type synonyms Monad instances? here's my problem... http://pastebin.com/73H9aapU
08:42:17 <Twey> You can't make type synonyms instances
08:42:18 <byorgey> Boxo: type synonyms always have to be fully applied, so no
08:42:20 <peaker_> Boxo, there might be a GHC extensions that lets you do that, but I don't see how it could not be a bad idea..
08:42:25 <Twey> Unless you use -XTypeSynonymInstances
08:42:35 <byorgey> Twey: that isn't the problem
08:42:41 <Twey> Ah, no, that's not
08:42:55 <Boxo> I don't see why they should have to be fully spplied :/
08:43:02 <Boxo> *applied
08:43:22 <byorgey> ISTR there's a good (non-obvious) reason, but I don't remember what it is
08:45:00 <ddarius> Partially applied type synonyms lead to needing higher-order unification which is undecidable in general.
08:47:02 <waterlaz> hm.. I had some problems while building happstack
08:47:10 <waterlaz> with ine of it's dependencies
08:47:12 <waterlaz> *one
08:47:39 <waterlaz> SMTPClient-1.0.1 depends on hsemail
08:48:06 <waterlaz> while building smtpclient I get this "Not in scope: data constructor `Message'"
08:48:35 <edwardk1> Boxo: type synonyms are syntactic sugar, they let you avoid saying repetitive stuff over and over, there is nothing 'there' for the compiler to grab onto. What you are really looking for is a newtype. The constructor there comes 'for free'' from the compiler's perspective as well, but its existence is sufficient for it to figure out how to dispatch
08:49:05 <waterlaz> adding  GenericMessage(..),  to import Text.ParserCombinators.Parsec.Rfc2822 seems to solve the problem but this is strange actually
08:49:50 <Boxo> Ok so I'll try using newtype
08:50:19 <Entroacceptor> waterlaz: you have to use an old version of hsemail
08:50:21 <edwardk1> peakerr_: there is an extension for type synonym instances, but it only works if your type fully expands within the instance header, if you try to partially apply one it blows up on you. there was a nice little paper on why partially applied type synonyms blow up, but i can't remember where it was
08:50:25 <Entroacceptor> I think 1.4
08:50:41 <Entroacceptor> so unregister hsemail, cabal install hsemail-1.4
08:51:10 <edwardk1> type Foo a b = Bar b a; instance Monad (Foo a) -- would conflict with instance Monad (Bar b)
08:52:20 <waterlaz> Entroacceptor, thanks
08:52:24 <Boxo> edwardk1: that makes sense
08:53:28 <waterlaz> too bad the author of SMTPClient uses some funky antispam system that I don't want to bother with in order to send him the fix
08:54:48 <Deesl> can I ask a stupid question?
08:55:04 <Eelis> ugh, are pull requests supposed to show up in "Sent messages" on github?
08:55:17 <edwardk1> Deesl: sure. i give stupid answers all the time ;)
08:55:38 <Deesl> is it possible to generate a buffer overflow in haskell, like I could pump in 100 characters in a C character array which has been malloced for 10 characters?
08:55:42 <Deesl> edwardk1: :)
08:55:51 <Vanadium> That is a really elaborate antisam system
08:57:37 <Deesl> okay.. I assume that was too stupid to be answered :(
08:57:41 <waterlaz> Deesl, omg
08:57:51 <waterlaz> it depends on what you want
08:58:02 <Deesl> waterlaz: sorry if that question was too dumb.
08:58:03 <jmcarthur> Deesl: yes. the FFI allows you to write crappy C code in Haskell
08:58:07 * Deesl has a C background only
08:58:31 <jmcarthur> but if you don't use the FFI then that shouldn't happen unless you use somebody else's bad FFI binding
08:58:32 <edwardk1> Deesl: depends on how badly you hack around with System.IO but in general, if you stick to the 'safe' combinators, no. if you use a  method called 'poke', yes ;)
08:59:02 <edwardk1> er s/System.IO/FFI
08:59:10 <waterlaz> edwardk1, I don't think that he means ffi
08:59:32 <jmcarthur> well he was talking about C arrays which naturally made me think of the FFI
08:59:43 <edwardk1> Deesl: the short answer is no, the long answer is there are some unsafe tools available if you need them
08:59:55 <Deesl> what I meant was, say I am accepting a string of input, can my user feed an arbitarary long string and bomb the runtime?
09:00:07 <jmcarthur> Deesl: only by forcing you to run out of memory entirely
09:00:11 <edwardk1> Deesl: nah, the worst that can happen is you run out of memory
09:00:26 <Deesl> okay.. so essentially code injection is impossible in haskell
09:00:42 <jmcarthur> aside from the unsafe things, yes
09:01:05 <Deesl> I can not inject arbitarary code in the stack (I assume exec stacks) for a haskell program
09:01:22 <Deesl> ok I guess my question is answered
09:01:25 <Deesl> thank you for telling me
09:02:01 <edwardk1> gah i just got a screen long 'module imports form a cycle for modules' complaint. i wish i could get ghci to output graphviz for this situation ;)
09:03:07 <jmcarthur> yeah i hate those
09:03:25 <rajeshsr> what is the nice way to list the functions of a module and access its docs?
09:03:36 <jmcarthur> rajeshsr: haddock
09:03:48 <jmcarthur> or do you mean modules of other libraries?
09:04:26 <rajeshsr> jmcarthur, about the libs coming with ghc i mean..
09:04:34 <rajeshsr> like System.Environment etc..
09:05:18 <jmcarthur> rajeshsr: i don't know how, but that documentation magically appears in my .cabal/share/doc
09:06:11 <rajeshsr> jmcarthur, ok, thanks
09:06:16 <jmcarthur> rajeshsr: if you edit your .cabal/config to build documentation when you install packages then it makes a big index of all your documentation. i bookmarked that. it includes the standard docs, which is the mystery
09:17:02 <rajeshsr> how much memory does ghc 6.12 require if compiled from source? It seems to have taken more than 1.5 GB and still proceeding!
09:17:22 <edwardk1> rajeshsr: sounds about right. it is a bit of a beast
09:18:02 <shaagerup> Anybody with ideas on how to go about debugging errors like this: http://imada.sdu.dk/~sorenh07/misc/haskell/Turtle.hs.out -- could it be due to my Haskell code, or is it my installation?
09:18:54 <rajeshsr> edwardk1, hmm, hope it stops soon.
09:19:03 <edwardk1> rajeshsr: when did you start?
09:19:38 <rajeshsr> edwardk, more than 2 hours before and it consumed more than 1.5GB and no sign of finishing; still compiling..
09:20:02 <edwardk> rajeshsr: i usually start ghc compiling before i go to bed ;)
09:20:17 <edwardk> and try not to listen to the ensuing screams from my hardware
09:20:39 <rajeshsr> edwardk, :)
09:21:34 <rajeshsr> Well, the problem is ghc > 6.8 is not available with debian lenny, so had to compile from source. I really wonder what other debian haskellers do.
09:22:15 <edwardk> rajeshsr: they give up and move to another platform? =)
09:22:17 <dankna> rajeshsr: I compiled rom source, heh
09:22:20 <dankna> *from
09:22:50 <dankna> I needed the head anyway, as there's a patch I'm depending on that's not in 6.12.1, so it was an easy decision for me
09:23:05 <edwardk> but i feel your pain, comonad.com was on debian for a long time, and i wound up building a few intermediate generations of ghc myself for that reason
09:23:07 <dankna> well, actually, I managed to remove that dependency ^^' but I /was/
09:23:30 <rajeshsr> dankna, may be some one can put the resulting deb package to download some where!
09:23:51 <dankna> rajeshsr: it would be nice.  I'm not enough of a Debian-phile to know how to make a package out of it though.
09:24:07 <dankna> I just installed into /usr/local/ instead
09:24:08 <rajeshsr> am trying to back-port from sid, let me see, if i can put the deb somewhere for download, in case i succeed.
09:24:17 <dankna> that's a good idea
09:25:20 <dankna> (also since my build, as I said, was from darcs and not a tagged release, I doubt the ghc team would appreciate me distributing it)
09:25:27 <rajeshsr> the thing is am running low of memory in "/". I never thought it will take so much space. So it is highly unlikely for me to succeed, at least today.
09:25:33 <dankna> hrm :(
09:28:01 <rajeshsr> dankna, how much memory it took?
09:28:59 <dankna> rajeshsr, not actually sure.  I ran it on my server and didn't watch that closely.  but it's a relatively modest machine.
09:29:25 <rajeshsr> hmm, can't be > 3GB, right?
09:29:35 <dankna> that would surprise me
09:36:25 <jmcarthur> is anybody here familiar with lightweight monadic regions or the regions package?
09:36:56 <dankna> not I
09:38:48 <gmo> hi, can i derive new datatype like this? "data Board = [[Tile]]"?
09:39:18 <jmcarthur> i'm looking at: Control.Monad.Trans.Region.Unsafe.mapInternalHandle :: (Handle resource1 -> Handle resource2) -> RegionalHandle resource1 r -> RegionalHandle resource2 r  -- wondering if that could be typed as this without necessarily sacrificing more safety: (pr `ParentOf` cr) => (Handle resource1 -> Handle resource2) -> RegionalHandle resource1 pr -> RegionalHandle resource2 cr
09:39:38 <dankna> yeek :)
09:39:48 <jmcarthur> heh, it's not as bad as it looks
09:40:03 <rajeshsr> dankna, 300MB remaining! :)
09:40:08 <dankna> gmo: a) deriving is a term with an exact meaning, which isn't quite what you want
09:40:10 <peaker_> gmo, you want a type-synonym?
09:40:14 <dankna> rajeshsr: good luck!
09:40:42 <jmcarthur> gmo: newtype Board = Board [[Tile]], is what i would do
09:40:50 <dankna> gmo: b) if you change "data" to "type" you can make a type synonym...  or if you change it to data Board = Board [[Tile]] you can make a new type
09:41:01 <gmo> yeah i wanted a new type
09:41:04 <dankna> gmo: but I'd encourage you not to use lists for this, use arrays
09:41:34 <gmo> dankna: ok can you give me a hint how to use it?
09:41:35 <jmcarthur> dankna: that depends on how it's being used, of course. the name might indicate something, but we don't know what kind of board game this is
09:41:40 <dankna> gmo: read the docs on Data.Array
09:41:51 <dankna> jmcarthur: true, of course
09:42:19 <gmo> dankna: i tried to, but i'm a bit confused :/
09:42:31 <dankna> well, I do better at answering specific questions; feel free to ask any you have
09:42:47 <jmcarthur> the thing is if you use immutable arrays you have to recreate the entire array for every write, so the decision to use arrays should also come with the decision to use immutability... that is, of course, unless you are using many recursive algorithms on the array, but that is unlikely if it's a normal board game i think
09:43:01 <jmcarthur> *the decision to use mutability
09:43:04 <jmcarthur> or at least DiffArrays
09:43:09 <dankna> well, if it's an AI then he is in fact using recursive algorithms on it
09:43:23 <rajeshsr> any suggestion as to where those debs can be pushed?
09:43:36 <gmo> dankna: ok im trying to write a simple gomoku game, in the variable should be saved the state of the board
09:43:39 <dankna> rajeshsr: I can host them if they aren't too big
09:43:39 <jmcarthur> dankna: but usually an AI on a board game might use the free undo of immutability, not folds over the board
09:43:47 <dankna> jmcarthur: that's very true
09:43:51 <SamB_XP> DiffArray ... doesn't that tend to be slower than plain-old immutable arrays for small sizes ?
09:44:01 <jmcarthur> SamB_XP: i've heard mixed accounts
09:44:06 <dankna> SamB_XP: gomoku is not small though, it's 19x19 :)
09:44:09 <rajeshsr> dankna, hmm, cool!
09:44:09 <ddarius> jmcarthur: If you switch pr and cr it seems like it would be fine, but as written I don't think that's sound.
09:44:23 <dankna> rajeshsr: sure :)
09:44:26 <gmo> dankna: you can choose the size of the board
09:44:31 <dankna> gmo: oh, neat
09:44:53 <jmcarthur> ddarius: really? seems like the order i have it in should be the correct one to me...
09:44:55 <gmo> im new at haskell, so i could use any help
09:45:13 <dankna> gmo: anyway yeah, you want to thin about whether to use mutable arrays or immutable ones.  are the consequences of that choice clear to you?
09:45:16 <dankna> *think
09:46:10 <gmo> i dont think so :/
09:46:44 <dankna> mutable arrays can be updated, like they could be in other languages.  the drawback is that you have to be in (for the most common type of them, IOArrays) the IO monad to use them.
09:46:45 <jmcarthur> ddarius: hmm... actually now i'm thinking it's unsound either way. if either resource is closed it will probably close the other (assuming they share the same internal resource)
09:47:07 <dankna> immutable arrays are like most Haskell data structures in that they can't be changed once they're created; the "update" functions actually allocate new copies
09:47:34 <gmo> dankna: ok i get it; actually i'm using wxhaskell to write the gui
09:47:48 <dankna> gmo: okay, cool.  the choice of wxhaskell shouldn't bear on this decision.
09:48:40 <dankna> if you don't know that you need mutability, I'd suggest immutable ones simply because they're more Haskelly and will help you learn that style of programming.  but that's not a strong reason.
09:49:25 <monochrom> immutable is less error-prone
09:49:29 <dankna> that as well
09:49:45 <gmo> dankna: can you point me somewhere to learn how to use these arrays?
09:49:49 <dankna> one sec
09:50:08 <gmo> dankna: i don't want to spam here with such noob questions :)
09:50:25 <dankna> gmo: it's fine, it's not spam if it's a sincere question
09:50:36 <dankna> gmo: I don't know of any tutorial material on them unfortunately, only reference material
09:50:41 <dankna> gmo: you probably already found http://www.haskell.org/ghc/docs/latest/html/libraries/array-0.3.0.0/Data-Array.html ?
09:50:55 <gmo> dankna: yeah, looking at them already
09:51:11 <dankna> ah - you might find http://www.haskell.org/tutorial/arrays.html useful
09:51:27 <SamB_XP> yah, anything except monad tutorials is allowed in this cannel, iirc...
09:51:33 <dankna> haha
09:51:52 <SamB_XP> or was that some other channel and monad tutorials ARE allowed here?
09:51:59 <dankna> haha
09:52:24 <twink> Only monad tutorial writing tutorials are allowed.
09:52:26 <jmcarthur> gmo: irc is for asking questions and trolling. we like one more than the other
09:53:18 <FliPPeh> jmcarthur: I thought IRC was for idling?
09:53:19 * liyang doesn't pay much attention in this channel anymore because too many people ask questions.
09:53:52 <SamB_XP> liyang: why ?
09:54:34 <liyang> SamB_XP: old questions are old / tl;dr
09:54:41 <SamB_XP> twink: what's step one? "dunk your head in the nearest available body of lava"?
09:55:18 <twink> SamB_XP: They may very well use the Lava logic circuit DSL.
09:56:03 <ccasin> Can I make unicode work in Strings in 6.10.4, or do I need to use some special type?
09:57:13 <FliPPeh> ccasin: Haskell strings are UTF-32 by default
09:57:37 <dankna> well, it would be more accurate to say that they're Unicode by default.  the internal encoding isn't exposed.
09:57:39 <FliPPeh> They can contain unicode characters
09:57:41 <ccasin> FliPPeh : hmm, they don't seem to be printing right for me when I stick unicode in them, but maybe the problem is somewhere else
09:57:51 <FliPPeh> They do for me :/
09:58:00 <FliPPeh> Try out this: putStrLn "\x2620"
09:58:07 <FliPPeh> Should be a funny little unicode symbol
09:58:17 <dankna> ccasin: the default encoding for IO is UTF8, make sure your terminal is configured to that
09:58:31 <FliPPeh> A jolly roger, that is
09:58:47 <FliPPeh> â 
09:58:54 <FliPPeh> > ord 'â '
09:58:55 <lambdabot>   9760
10:00:58 <ccasin> yes, ok, I think the problem is my terminal font wasn't big enough for the symbols I wanted - thanks
10:01:10 <dankna> np
10:02:46 <Mathnerd314> liyang: isn't the point of FAQ's to get rid of old questions?
10:03:56 <liyang> Mathnerd314: no one reads the FAQs though. These days I just skim through the scrollback in case anything interesting is mentioned.
10:04:18 <dankna> well, that is of course your choice
10:05:00 <Mathnerd314> where are the FAQs?
10:05:11 <dankna> @google haskell faq
10:05:12 <lambdabot> http://www.cs.nott.ac.uk/~gmh/faq.html
10:05:13 <lambdabot> Title: FAQ for comp.lang.functional
10:05:16 <dankna> :(
10:07:47 <Mathnerd314> no FAQ -> lots of old questions, exactly as predicted
10:08:04 <dankna> I'm not convinced it's a problem
10:08:28 <dankna> but if you view it as one, I'm sure people would welcome FAQ-answer contributions
10:08:45 <dankna> probably a good idea to mine the channel logs for ideas about what questions are worth answering
10:08:52 <dankna> maybe do a word concordance on them
10:09:05 <jlouis> FliPPeh: that was a nice idea: This is Combinatorrent â  version v0.1.1-176-g24f5217-dirty
10:10:41 <FliPPeh> jlouis: :)
10:11:38 <SamB_XP> jlouis: is that an abbreviated git revision?
10:11:46 <jlouis> SamB_XP: yup
10:11:51 <Saizan> FAQs are especially nice if you can find them by googling the most obvious keywords
10:12:59 <jlouis> SamB_XP: see git describe and I add -dirty if the tree has some change to it not committed. The latter catches when packages have patched the source with something
10:13:17 <jlouis> packagers even
10:13:53 <jlouis> The first part is just that we are 176 patches after the last tag on the branch, which is v0.1.1
10:15:59 <SamB_XP> jlouis: yeah, I was specifically referring to the 32-bit quantity there in the middle ;-)
10:16:37 <Mathnerd314> ah, I found this: http://www.haskell.org/haskellwiki/Category:FAQ
10:16:55 <dankna> Mathner: ah good.  i thought there was SOMEthing...
10:17:05 <jlouis> SamB_XP: http://github.com/jlouis/combinatorrent/blob/master/configure is what creates it. It is a small shellscript and not an autohellcrap tools generated file
10:17:24 <SamB_XP> oh, if you can't find the answer to your question, you should consider asking it on stack overflow
10:17:33 <SamB_XP> or heck, even if it took you too long to find it ;-)
10:17:45 <SamB_XP> (but please sign up/in first!)
10:19:02 <SamB_XP> and if you already found the answer when you ask on stackoverflow, you can just post your own answer after you post the question
10:21:15 <dmhouse> Time for the new Doctor Who :)
10:22:55 <liyang> dmhouse: damn you license payers.
10:23:33 <dmhouse> liyang: hey, I'm an unemployed student. I've barely paid a pound in tax. Thank my parents.
10:23:56 <dmhouse> Ooh, new theme tune.
10:25:07 <cognominal> having problem with ghc and Mac OS X  10.6.   Downloaded the haskell platform and installed cabal as per the real haskell book. WHen I do "cabal update", I get cabal: Codec.Compression.Zlib: incompatible zlib version
10:25:21 <cognominal> I got that latest zlib port.
10:25:38 <cognominal> Apparently I have deleted any trace of previous ghc
10:26:21 <cognominal> I expected that problem to be fixed with the latest haskell platform
10:28:03 <Oejet> jlouis: I would have loved to be at your presentation at Open Source Days.
10:30:44 <mreh> haskell-cafe is like reading the Daily Telegraph sometimes
10:31:56 <Zao> And page 3 of the sun occasionally.
10:33:35 <mreh> I was thinking more of the Letters to the Editor
10:33:48 <mreh> the readers of Sun are unable to write letters
10:34:00 <SamB_XP> mreh: I'm not familiar with those letters to the editor
10:34:07 <SamB_XP> lol
10:34:24 <mreh> even big letters that aren't joined up
10:34:24 * SamB_XP makes a note never to read the Sun unless he's too tired to read anything else
10:34:34 <FliPPeh> 2
10:34:55 <jlouis> Oejet: with a bit of luck, there will be a video of it
10:35:08 <alex404> What's the easiest way to repeatedly get the rest of the characters from a buffer which is being continually updated (i.e. over a USB port)?
10:35:09 <SamB_XP> what about open source nights ?
10:35:26 <jlouis> SamB_XP: that probably was the beer event afterwards :)
10:35:35 <SamB_XP> alex404: where is the buffer ?
10:36:05 <alex404> SamB_XP: Not sure what you mean. It's a /dev file.
10:36:24 <SamB_XP> alex404: a block dev or a character dev?
10:36:36 <mibygl> Grr.
10:36:55 <mibygl> GHCi isn't recognizing my return key; it just displays an M.
10:36:57 <alex404> SamB_XP: Hmm. Not sure. I'm not at work right now. I'd be able to check with the file command?
10:37:21 <SamB_XP> alex404: if not file, then stat
10:37:41 <alex404> SamB_XP: What's the difference between the two?
10:37:41 <Oejet> jlouis: Will there be a CopenHac?
10:37:50 <mreh> with Arrows you loose the ability to have an unbound variable in an Arrow subexpression don't you?
10:38:04 <mreh> like the "a <-" in do notation
10:38:11 <SamB_XP> well, what I really mean is: is it a BUFFER you want to read from, or just a character stream and the buffer is an implementation detail that you never actually see?
10:38:17 <dankna> "loose" is a particularly unfortunate typo when you're talking about bindings
10:38:26 <dankna> (sorry - former English teacher)
10:38:28 <mreh> XD
10:38:35 <liyang> Oejet: âCopenHackenâ surely.
10:38:41 <mreh> I apologise, "lose"
10:38:46 <alex404> SamB_XP: Right. I'm not exactly sure. Can't I set the buffering mode in haskell?
10:38:50 <dankna> hehe, apology accepted :D
10:38:59 <Oejet> liyang: Would be more appropriate, yes.
10:39:04 <SamB_XP> alex404: I mean, why did you say "buffer"
10:39:17 <SamB_XP> that's really what has me confused ;-)
10:39:52 <alex404> SamB_XP: Hmm... I guess because I access it with a handle. And if I don't try to read the devices return characters, they back up and I can read them all later.
10:40:29 <Saizan> alex404: there's hSetBuffering if that's what you want
10:40:31 <SamB_XP> alex404: ah, okay, so its the kind of buffer you don't need to worry about. good.
10:40:43 <SamB_XP> Saizan: does that let you go into non-blocking mode ?
10:40:58 <jlouis> Oejet: we could make one perhaps
10:41:08 <SamB_XP> @index hSetBuffering
10:41:08 <lambdabot> System.IO
10:41:13 <SamB_XP> @doc System.IO
10:41:13 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
10:41:17 <Saizan> SamB_XP: i don't think so
10:41:23 <Oejet> jlouis: I'll help arrange it!
10:42:01 <Saizan> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html#v%3AhGetBufNonBlocking <- ?
10:42:19 <SamB_XP> Saizan: that name does look promising
10:43:01 <SamB_XP> yeah, that's it alright!
10:43:10 <SamB_XP> alex404: okay, we found it!
10:43:17 <alex404> Yay!
10:43:21 <SamB_XP> it's hGetBufNonBlocking that you want, basically
10:43:24 <alex404> Yah, it seems like the right thing
10:43:56 * Saizan had no clue from the above discussion that alex404 needed non-blocking I/O
10:44:11 <mibygl> Mmkay, GHCi is recognizing both Ctrl+J and Ctrl+M as return, but it's recognizing return as M.
10:44:23 <SamB_XP> Saizan: at the beginning he said he wanted to read what was available from the "buffer"
10:45:08 <mibygl> Except in getLine or something, wherein it recognizes all three as \n.
10:45:30 <alex404> SamB_XP: So why did my usage of the word buffer bother you? I guess it's not a buffer I'm accessing, but just an "implementational detail"?
10:45:50 <SamB_XP> well, basically, yeah
10:46:33 <alex404> Isn't that a pretty murky distinction though? (genuine question)
10:47:18 <SamB_XP> well, I was afraid that your use of the term "buffer" implied that you would have to deal with scary details or something
10:47:41 <jlouis> Oejet: it is a cool idea
10:47:51 <alex404> Right. I have to do that with a different part of my program. But here would the better word be pipe or something?
10:48:09 <SamB_XP> I think I'd just say "device"
10:48:43 <alex404> Cool. Thanks for all the help.
10:48:44 <SamB_XP> or possibly "serial device"
10:48:48 <alex404> Right.
10:48:55 <Oejet> jlouis: It is!
10:52:07 <AxleLonghorn> is there a haskell library like python's urllib?
10:52:25 <SamB_XP> @hoogle URI
10:52:25 <lambdabot> module Network.URI
10:52:25 <lambdabot> Network.URI data URI
10:52:25 <lambdabot> Network.URI URI :: String -> Maybe URIAuth -> String -> String -> String -> URI
10:52:31 <SamB_XP> @hoogle HTTP
10:52:32 <lambdabot> package HTTP
10:52:32 <lambdabot> module Network.HTTP
10:52:32 <lambdabot> Text.Html httpequiv :: String -> HtmlAttr
10:52:44 <SamB_XP> @doc Network.HTTP
10:52:45 <lambdabot> Network.HTTP not available
10:52:48 <SamB_XP> aww
10:52:53 <SamB_XP> @google "Network.HTTP"
10:52:54 <lambdabot> http://kb.mozillazine.org/Network.http.pipelining
10:52:55 <lambdabot> Title: Network.http.pipelining - MozillaZine Knowledge Base
10:53:03 <SamB_XP> AxleLonghorn: what exactly did you want, anyway?
10:53:17 <SamB_XP> and I thought everyone was using urllib2 by now?
10:53:30 <SamB_XP> @google "Network.HTTP" site:haskell.org
10:53:32 <lambdabot> http://www.haskell.org/http/
10:53:32 <lambdabot> Title: The Haskell HTTP package
10:53:57 <Sgeo> Can't urllib2 also handle ftp:// etc?
10:54:05 <AxleLonghorn> yes, I mean urllib2, I'm looking for a library that abstracts the network
10:54:13 <SamB_XP> Sgeo: I think
10:54:21 <AxleLonghorn> I don't want to deal with ports and connections
10:54:43 <SamB_XP> AxleLonghorn: well, were you really wanting anything besides HTTP?
10:54:45 <Sgeo> Something like urllib2.urlopen?
10:54:56 <AxleLonghorn> yes like urlopen
10:54:57 <cognominal> May someone help me on my problem with ghc and Mac OS X  10.6.?
10:55:00 <AxleLonghorn> no, http is fine
10:55:28 <AxleLonghorn> so this: http://hackage.haskell.org/package/HTTP will be fine?
10:55:55 <SamB_XP> AxleLonghorn: probably!
10:56:06 <SamB_XP> if you have any trouble, come right back and ask for help ;-)
10:56:11 <AxleLonghorn> ok, thanks
10:56:14 <SamB_XP> (not that you have to leave now or anything ;-)
10:58:19 <chrisdon`> jaspervdj: ping
10:58:47 <wavewave> what is the runtime error <<loop>>?
10:59:24 <Saizan> it means you've an infinite loop in your program
10:59:40 <Saizan> some of those are detected by GHC's evaluation model
10:59:47 <wavewave> I see.
11:00:10 <SamB_XP> in particular, it means the computation of a particular value needed that very same value in WHNF
11:00:13 <wavewave> but it didn't appear when I don't use -O option.
11:00:34 <SamB_XP> did your program finish without -O ?
11:00:45 <wavewave> No.. I found the bug!!!!
11:00:49 <wavewave> Thanks.
11:00:58 <wavewave> GHC is very clever :)
11:01:24 <SamB_XP> see, the -O makes it easier for the RTS to notice these things ;-)
11:01:27 <benmachine> optimisation leads GHC to do more analysis
11:01:35 <mercury^> Isn't it expensive to test for that?
11:01:40 <SamB_XP> nope
11:01:52 <SamB_XP> @google "black hole" site:haskell.org
11:01:53 <lambdabot> http://hackage.haskell.org/trac/hugs/ticket/47
11:01:53 <lambdabot> Title: #47 (Hugs segfaults on black hole.) â Hugs
11:01:56 <benmachine> mercury^: not if you are gathering that information in the optimisation effort anyway
11:02:01 <SamB_XP> @google "blackhole" site:haskell.org
11:02:01 <lambdabot> No Result Found.
11:02:05 <SamB_XP> @google "blackholing" site:haskell.org
11:02:06 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/using-smp.html
11:02:06 <lambdabot> Title: 4.13.ï¿½Using SMP parallelism
11:02:21 <wavewave> now I have another questions.
11:02:44 <wavewave> I am dealing with rather big several files.
11:03:12 <wavewave> I need all the data from those files.
11:03:13 <rajeshsr> finally got ghc 6.12!
11:03:29 <wavewave> but I just count things.
11:03:36 <rajeshsr> BTW, when i cabal install HaskellNet package i got the following error:
11:03:37 <rajeshsr>  Warning: Module `Prelude' is deprecated:
11:03:38 <rajeshsr>                You are using the old package `base' version 3.x.
11:03:38 <rajeshsr>                Future GHC versions will not support base version 3.x. You
11:03:38 <rajeshsr>                should update your code to use the new base version 4.x.
11:03:43 <rajeshsr> sorry warning..
11:03:58 <wavewave> so once I  process one file, the file is not needed any more.
11:04:02 <rajeshsr> any idea of how to upgrade "base"?
11:04:23 <wavewave> I found the data is still in memory... so finally, it used up all my memory.
11:04:43 <SamB_XP> rajeshsr: you don't need to upgrade, just make your package depend on base >= 4
11:04:55 <SamB_XP> rajeshsr: GHC comes with both
11:05:00 <wavewave> how can I treat a big file one by one... and purge the data when process is done?
11:05:02 <SamB_XP> (for the moment)
11:05:21 <wavewave> I thought lazy evaluation automatically deal with this situation.
11:05:37 <SamB_XP> wavewave: how did you find it still in memory?
11:05:45 <rajeshsr> SamB_XP, you mean the package am installing asks for base > 3 ?
11:05:47 <wavewave> just by 'top' :)
11:06:04 <wavewave> it consumes all the memory and finally goes to swapping.
11:06:13 <wavewave> i mean harddisk swapping.
11:06:24 <SamB_XP> rajeshsr: well, look at the .cabal file/hackage page and see if it can work with base >= 4
11:06:40 <SamB_XP> wavewave: ah. so you've got an actual space leak, then
11:06:59 <wavewave> hmm. should I do some profiling?
11:07:01 <jaspervdj> chrisdone: pong
11:07:22 <SamB_XP> wavewave: or perhaps some vacuuming
11:07:35 <AxleLonghorn> SamB_XP: what's a good html parser? I was looking at tagsoup, but it said it was deprecated in favor tagchup, is there anything better?
11:07:48 <Saizan> rajeshsr: if you're not the maintainer of the package you can just ignore that warning.
11:08:00 <SamB_XP> AxleLonghorn: I would suggest following tagsoups suggestion and using tagchup
11:08:03 <chrisdone> jaspervdj: I'm running your sample blog with tags. what steps would I need to take to use markdown for the index page instead of html?
11:08:05 <SamB_XP> which is presumably it's successor
11:08:08 <SamB_XP> er. its
11:08:16 <wavewave> SamB_XP: but I think data is too big so it is hard to use vacuum in this case, I think.
11:08:37 <kamatsu> so, who read my "Safe" article? :D
11:08:44 <SamB_XP> wavewave: well, I mean, you could look at it not too long after you start the program maybe ?
11:08:55 <jaspervdj> chrisdone: lemme check
11:09:01 <chrisdone> jaspervdj: thanks
11:09:04 <SamB_XP> note that I've never actually tried vacuum myself ;-P
11:09:18 <jaspervdj> chrisdone: Okay, it's not *really* possible
11:09:25 <SamB_XP> but it just seems like the kind of tool that would make it easier to answer the question "WTF is this data still here"
11:09:26 <wavewave> I didn't use it for a real analysis, either.
11:09:42 <jaspervdj> chrisdone: I mean, you could write the âaboutâ section in markdown, but not the entire file, since it's a template
11:09:46 <chrisdone> jaspervdj: I thought not. I think I'm missing something in how this blog works, I will have to read through the code
11:10:05 <rajeshsr> SamB_XP, Saizan hmm, ok! thanks
11:10:09 <kamatsu> alternatively just use the standard pandoc executable to generate your template :D
11:10:12 <Oejet> kamatsu: I was just about to begin reading it.
11:10:21 <wavewave> I will try first profiling.
11:10:24 <wavewave> thx.
11:10:47 <chrisdone> jaspervdj: ah, it's a template. that's so that you can put in keys?
11:10:47 <jaspervdj> chrisdone: But if you would write the about section in markdown, the template will be just a little âbinding stuff togetherâ, so that's nice
11:10:50 <kamatsu> Oejet: Let me know your opinion on the typesetting, I spent quite some time trying to make browsers display large amounts of text legibly.
11:10:54 <SamB_XP> wavewave: yeah, probably wise
11:10:55 <kamatsu> (Most of the time they don't)
11:10:57 <jaspervdj> chrisdone: yep
11:11:08 <SamB_XP> you might wanna try "retainer" profiling
11:11:11 <chrisdone> jaspervdj: right so I pass the markdown /to/ the template?
11:11:18 <chrisdone> from a separate about file or somesuch
11:11:24 <SamB_XP> though that seems kinda hard to understand
11:11:49 <chrisdone> jaspervdj: that's cool. I just didn't want to have to write a bunch of project links in html. much easier in markdown :D
11:12:27 <Oejet> kamatsu: It looks good.
11:12:29 <jaspervdj> chrisdone: You would basically do it the way I added the footer in the âmorepagesâ example
11:12:45 <kamatsu> Sweet
11:12:51 <chrisdone> jaspervdj: right :)
11:14:10 <kamatsu> jaspervdj, your hakyll project seems to be powering the haskelly webpages of the future
11:14:34 <wavewave> SamB_XP: by the way, to use ghc profile, should I recompile other packages that I am using also?
11:14:49 <wavewave> SamB_XP: I am now using Data.Binary.
11:15:35 <SamB_XP> wavewave: you will need to compile them with profiling support, yes
11:15:41 <jaspervdj> kamatsu: that's what I hope :-)
11:15:47 <wavewave> how can I do that with cabal?
11:15:54 <SamB_XP> so unless you always do that, yeah, you'll need to recompile 'em
11:16:06 <chrisdone> jaspervdj: have you tried it with any big sites? I'm curious how fast it would be with a big blog or whatnot, especially the preview with its scanning
11:16:46 <kamatsu> well, the good thing is that the generation speed is purely a convenience for the publisher
11:17:50 <Saizan> wavewave: e.g. cabal install binary -p --reinstall
11:18:08 <kamatsu> so, even if it takes ages, you can just leave it to do so in the background
11:18:16 <ydo> stuck in an imperative mindset, how to I write a function that takes a list and perform function f on each successive pairs, e.g. [1,2,3]  ->  (f 2 1):(f 3 2):[]
11:18:17 <jaspervdj> chrisdone: http://jaspervdj.be/posts/2010-01-25-caching-in-hakyll.html
11:18:53 <kamatsu> ydo: first produce a list of those pairs
11:19:03 <ydo> zipWith and tail?
11:19:15 <kamatsu> ydo: and then map an uncurried function over them
11:19:27 <kamatsu> ydo: that'd do it
11:19:28 <ydo> "uncurried"?
11:19:38 <kamatsu> @type uncurry (+)
11:19:39 <lambdabot> forall a. (Num a) => (a, a) -> a
11:19:54 <Saizan> > let xs = [1,2,3] in zipWith f (tail xs) xs
11:19:55 <lambdabot>   Ambiguous type variable `c' in the constraints:
11:19:55 <lambdabot>    `SimpleReflect.FromExpr ...
11:20:04 <Saizan> > let xs = [1,2,3] in zipWith f (tail xs) xs :: [Expr]
11:20:05 <lambdabot>   [f 2 1,f 3 2]
11:20:24 <jaspervdj> chrisdone: anyway, I gotta go, bye
11:20:26 <kamatsu> oh yeah, that's easier still
11:20:54 <chrisdone> jaspervdj: laters
11:21:02 <wavewave> Saizan: thanks.
11:21:05 <Saizan> it's going to crash on an empty list though
11:21:10 <danblick> could anyone point me to a place I can read about what the bar and arrow mean in typeclass definitions, e.g. "class Someclass m a | m -> a where"...
11:21:33 <Saizan> danblick: that extension is called "functional dependencies"
11:21:57 <danblick> saizan: thanks
11:22:22 <Saizan> it means that for a given m there can be only one a such that Someclass m a holds
11:22:53 <Saizan> so it's more like a function than a relation.
11:22:57 <danblick> ah, ok
11:23:36 <Saizan> it helps with type inference
11:29:27 <benmachine> is it weird that I have a ghci session open in a terminal and I don't remember starting it
11:29:32 <benmachine> or why it is there
11:29:42 <rajeshsr> dankna, it worked finally! Uploading the debs via google docs! :)
11:29:42 <sbahra> No.
11:30:15 <benmachine> oh, good
11:30:20 <dankna> rajeshsr: oh good! :) congrats!
11:30:51 <rajeshsr> see if you can access it
11:30:52 <rajeshsr> https://docs.google.com/leaf?id=0B1I316pAZkHBZGE3YWY1ZmQtNGIwYy00N2NlLWE2NWQtZTBmZTFmZTY4ZWI1&hl=en
11:31:04 <dankna> yes, that works for me
11:31:32 <rajeshsr> docs here: https://docs.google.com/leaf?id=0B1I316pAZkHBODA1NzBmNmEtMGNhNi00MmMxLWJmYTUtMjAxNDBiMzc3ZTc2&hl=en
11:31:46 <rajeshsr> profiling libs still being uploaded...
11:32:04 <rajeshsr> s/libs/deb
11:37:18 <wavewave> SamB_XP: I solved the memory leak problem!
11:37:28 <wavewave> using pseq.
11:37:47 <wavewave> B = A pseq f(A)
11:37:56 <wavewave> C = B pseq f(B)
11:37:57 <wavewave> ...
11:38:10 <JuanDaugherty> any nix users here?
11:38:25 <wavewave> i am.
11:38:30 <wavewave> linux.
11:38:32 <JuanDaugherty> how long?
11:38:40 <JuanDaugherty> no I meant Nixos.
11:38:53 <wavewave> sorry. :-)
11:39:51 <wavewave> is it good? Nixos?
11:39:59 <fax> ueeeeeeeeee'
11:40:01 <wavewave> I am a debian user.
11:41:08 <JuanDaugherty> yes, but they are kina like Haskellers and for the same reason since it is a purely functional pkg mgr
11:41:34 <JuanDaugherty> but they are way snooty about it, at least the users, not the original developers I think
11:42:03 <wavewave> I see..
11:42:30 <Zao> I found Nixos unusable and horribly underdocumented.
11:42:37 <fax> @nixos
11:42:37 <lambdabot> Finishing second in the Olympics gets you silver. Finishing second in politics gets you oblivion.
11:42:39 <edwardk>  JuanDaugherty: i have installed it before and kicked the tires, but i'd hardly call myself a user
11:42:41 <Zao> "just program this package manager in a functional language unlike any other, lol"
11:42:47 <Sgeo> Suppose I have a C API which triggers callbacks. What's the best way to represent that in Haskell so that I can still use, say, State, or even at least keep track of state the non-monadic way?
11:42:56 <fax> @nixos
11:42:56 <lambdabot> I've never canceled a subscription to a newspaper because of bad cartoons or editorials. If that were the case, I wouldn't have any newspapers or magazines to read.
11:43:03 <JuanDaugherty> i did too at first but I got over the first hump and found it more than I thought
11:43:15 <edwardk> JuanDaugherty: i like the general idea of it
11:43:37 <JuanDaugherty> they're putting a lot of work into and they have the right attitude
11:43:43 <wavewave> what this lambdabot is talking about..
11:43:43 <dankna> Sgeo: you need to use a StablePtr
11:43:56 <dankna> Sgeo: and put it in the context parameter of the callback
11:43:58 <dmwit> wavewave: Nixon quotes.
11:43:59 <edwardk> wavewave: those are quotes
11:44:09 * Sgeo should probably learn what those are
11:44:16 <dankna> Sgeo: yes, you probably should :)
11:44:21 <JuanDaugherty> they as much as told me go read the fucking publications (ifcp-2008)
11:44:40 <fax> @nixos
11:44:40 <lambdabot> Always remember that others may hate you but those who hate you don't win unless you hate them. And then you destroy yourself.
11:44:43 <edwardk> JuanDaugherty: not sure that that is the 'right attitude' ;)
11:44:52 <edwardk> JuanDaugherty: not if you want to build a community
11:45:06 <JuanDaugherty> no it was just this one little guy
11:45:19 <JuanDaugherty> like I said I don't think he's one of the principle developers
11:45:40 <JuanDaugherty> *principal
11:45:44 <Sgeo> dankna, suppose the C API doesn't have context parameters. Would I need to write C to wrap it? Or is the "context parameter" stuff something on the Haskell end of the FFI
11:46:06 <JuanDaugherty> but haskell platform is in there, dunno what level
11:46:16 <chrisdone> @vixen will haskell get me laid?
11:46:16 <lambdabot> church is my favourite computer scientist.
11:46:26 <chrisdone> good enough for me
11:46:49 <edwardk> hrmm, straw poll. API preference quiz? 'Build CNF b a' and 'Build QBF b a' or 'SAT b a' and 'QSAT b a' for the monads used to build sat and qsat problems?
11:47:05 <dankna> Sgeo: if it doesn't have context parameters you're out of luck completely, but that would be a very poor design and I can't imagine it doesn't.  what API is it?
11:47:08 <fax> SAT and QSAT
11:47:19 <dankna> Sgeo: often they're called "user info" or something like that?
11:47:45 <aavogt> @nixon
11:47:45 <lambdabot> Voters quickly forget what a man says.
11:47:46 <Sgeo> dankna, actually, I think there are _some_ callbacks that have context parameters.. but not all
11:47:50 <fax> @vixon
11:47:50 <lambdabot> Maybe you meant: nixon vixen
11:47:52 <dankna> Sgeo: what API is it?
11:47:53 <edwardk> fax fair enough, though i may expose them as mere type aliases for the former ;)
11:47:53 <wavewave> so in Nix, in principle, you can rolll back your state to a certain point?
11:48:02 <aavogt> yes
11:48:11 <Sgeo> http://activeworlds.com/sdk/
11:48:13 <JuanDaugherty> yes that's common
11:48:34 <JuanDaugherty> not in principle, it's essential to how it works
11:48:35 <Sgeo> Better reference http://wiki.activeworlds.com/index.php?title=SDK
11:49:00 <Sgeo> Actually, there is: http://wiki.activeworlds.com/index.php?title=AW_OBJECT_CALLBACK_REFERENCE
11:49:12 <wavewave> how mature is it if succeed in installation?
11:49:17 <Sgeo> Wait, "that acts on an object"
11:49:33 <Sgeo> I'm out of luck, aren't I
11:49:38 <dankna> I think you might be
11:50:26 <siracusa> Is `*** Exception: Internal error: empty context in lexStdToken' considered a bug? I think it comes from Language.Haskell.Exts.Lexer
11:50:37 <wavewave> Nix looks like darcs.
11:50:58 <JuanDaugherty> it's better done than darcs
11:51:38 <JuanDaugherty> but yeah, it's the darcs of pkg mgt/linux distros
11:52:02 <aavogt> it doesn't seem to have performance issues
11:52:19 <JuanDaugherty> you have it installed?
11:52:24 <wavewave> interesting.
11:52:27 <aavogt> darcs is more like "reasonably easy to use, but slow"
11:52:48 <dankna> Sgeo: I'm struggling to understand this API... looks like it has some generic setters that are agnostic to the objects they're setting on
11:52:49 <aavogt> nixos is pretty complicated and different from other distros
11:52:59 <dankna> Sgeo: it's not clear to me that you can do what you want, but it's not clear to me that you can't, either
11:53:09 <aavogt> JuanDaugherty: I tried nixos out about a year ago
11:53:38 <dankna> Sgeo: the lack of global variables is the big constraint that Haskell has that C doesn't.  you could use the unsafePerformIO newMVar trick to fake a global variable if you have no other alternative.
11:54:11 <dankna> Sgeo: but surely there must be some way that the callback, if you were coding in C, would be informed what object it was intended to act on and what operation it was intended to perform
11:54:12 <aavogt> that is creating a global variable as far as I'm concerned
11:54:17 <dankna> Sgeo: you just need to hook into that mechanism
11:55:30 <Sgeo> For methods that act on Objects, yes, but those aren't the only ones
11:55:39 <dankna> Sgeo: whether you directly pass the StablePtr to the callback-registration function or you dig it out of your global map, once you've recovered the StablePtr you just extract your state from it and runStateT or whatever
11:56:00 <dankna> Sgeo: well, it's not clear to me how those callbacks that don't have such a mechanism could do their work, even in C.
11:56:08 <chrisdone> does science tell us that reading white on black instead of white on black on your screen is bad for you?
11:56:37 <fax> science is just a theory
11:56:40 <Sgeo> I'd imagine that reading white on black has the same effect as reading white on black
11:56:42 <dmwit> chrisdone: I don't know of any science supporting either direction, despite looking for it.
11:56:58 <chrisdone> fax: haha
11:57:05 <dankna> Sgeo: haha
11:57:09 <dmwit> No science refuting either direction, either; just no science. =/
11:57:10 <JuanDaugherty> aavogt, prolly done a lot since then, I only got into it in last week or so; last fall the ifcp paper said they had 1350 pkgs, now theres 2500
11:57:40 <Sgeo> dankna, actually, I should also have mentioned that there are events
11:57:47 <chrisdone> dmwit: ah well. I love the invert screen function of compiz or os x. there isn't enough lighting in my room so it's like staring at a bulb all night
11:57:50 <aavogt> I suppose that most of those are automatically generated ex. from hackage or whatever
11:58:03 <JuanDaugherty> no it doesn't work that way
11:58:06 <dankna> yeah, that's handy functionality
11:58:24 <dankna> Sgeo: hm.
11:58:30 <JuanDaugherty> some though has to be put into the Nix pkg although I'm sure it's quick once you done a few
11:58:30 <dmwit> chrisdone: Great. Since there's no evidence either way, preference gets to trump all. =)
11:58:37 <JuanDaugherty> *some thought
11:58:37 <chrisdone> dmwit: that's right!
11:58:49 <JuanDaugherty> *you've
11:58:58 <aavogt> JuanDaugherty: you mean that nobody has automated the generation of nix derivations?
11:59:28 <JuanDaugherty> I'm not sure it's even in principal feasible
11:59:31 <aavogt> I found it confusing that there were around 3 different styles to write the derivations
11:59:34 <JuanDaugherty> *in principle
11:59:37 <aavogt> of course it's feasible
12:00:02 <JuanDaugherty> do you mean Nix expressions?
12:00:17 <aavogt> aren't we talking about the same thing?
12:00:36 * aavogt doesn't recall the exact terminology
12:00:39 <JuanDaugherty> it's not the expressions that require manual intervention but the information they contain
12:00:59 <aavogt> the file that specifies what gets built
12:01:17 <JuanDaugherty> by derivations I thought you meant something that would produce a nix pkg from say a rpm
12:01:50 <aavogt> which is more or less a translation of the .cabal files in hackage (+ some more information that you can ask Cabal for)
12:02:04 <aavogt> as an example... CPAN has similar stuff
12:05:24 <JuanDaugherty> but yeah the current level of the stuff generates the expressions from the script language that declaratively specifies the package
12:06:13 <aavogt> right, additional packages which require no additional effort from the nix devs
12:06:20 <JuanDaugherty> *a package
12:06:31 <JuanDaugherty> correct
12:06:54 <JuanDaugherty> which is where the snotty guy came from
12:07:11 <aavogt> I don't understand that reference
12:07:34 <mreh> is this about Haskell?
12:07:59 <JuanDaugherty> scroll up and look at edwardk's comment
12:08:31 <JuanDaugherty> no it isn't and I'll stop but it as about purely function pkg mgt and linux distro that at 1st I thought was in Haskell
12:08:33 * mreh stares blankly at his screen
12:08:53 <mreh> I can't tell if it's about Haskell :\
12:09:05 <JuanDaugherty> (the "scroll up ..." was to aavogt )
12:09:19 <JuanDaugherty> *purely functional
12:09:27 <edwardk> mreh: nixos is a 'functional' linux distro which uses a very novel package manager. so while it isn't haskell it is as close to purely functional as it can get ;)
12:09:54 <JuanDaugherty> well being in haskell isn't a requirement to be purely functional
12:10:09 <aavogt> the language doesn't have haskell-like syntax, but perhaps the semantics are closer?
12:10:11 <JuanDaugherty> the authors of Nixos are doctoral grads in cs
12:10:31 <edwardk> JuanDaugherty: no it isn't, the as close to purely functional comment was a reference to the fact that it has to have side-effects or its a pretty useless package manager ;)
12:10:56 <fax> planet.haskell.org
12:10:58 <EvanR> if i have a tree data structure, how do i write a function to alter one of the nodes and return the new tree :S
12:11:25 <aavogt> differentiate your tree
12:11:34 <edwardk> EvanR: recurse down to the node in question and replace it. look at data.map and data.set for examples
12:11:35 <mreh> EvanR: recursively
12:11:49 <fax> > ((2^).(2^)) . [1..]
12:11:50 <lambdabot>   [4,16,256,65536,4294967296,18446744073709551616,340282366920938463463374607...
12:12:17 <EvanR> so when im at the right place, build a new node, and build new versions of all the parents
12:12:21 <JuanDaugherty> edwardk, yeah there's a semantic clash between their use of the term and the narrow sense in which it applies in programming langs
12:12:44 <EvanR> do i effectively rebuild the entire tree
12:12:52 <mreh> EvanR: yeah, I think
12:13:05 <bos> EvanR: no, just back up to the root
12:13:07 <edwardk> data Tree a = Tip | Bin (Tree a) a (Tree a); delete _ Tip = Tip; delete b (Bin l a r) | b == a = merge l r; | otherwise = bin (delete b l) a (delete b r)
12:13:26 <edwardk> EvanR: i leave merge as an exercise for the reader ;)
12:14:09 <edwardk> EvanR: you call delete on the root of the tree and recurse down until you find the node (obviously with an Ord instance you can go down only the side that might contain the answer)
12:14:17 <JuanDaugherty> is Happs dead?
12:14:42 <EvanR> edwardk: without types its kind of hard to follow ;)
12:14:47 <edwardk> EvanR then give back the new value for your node to your caller, since you defined it recursively, you'll have closed the tree back up around you
12:15:01 <edwardk> delete :: Eq a => a -> Tree a -> Tree a -- was the version i gave
12:15:13 <EvanR> ok
12:15:15 <edwardk> you can write a smarter: delete :: Ord a => a -> Tree a -> Tree a
12:15:24 <edwardk> but i wanted to fit on a line
12:15:37 <EvanR> well it doesnt fit on one of my lines ;)
12:15:38 <JuanDaugherty> ah it's happstack now
12:15:38 <EvanR> its 3
12:15:46 <edwardk> you need a bigger monitor ;)
12:15:53 <EvanR> 80 chars ;)
12:16:32 <edwardk> then you need smaller print ;)
12:16:45 <fax> aaaaaaaugh
12:16:56 <EvanR> then it would be 80 hard to read chars ;)
12:17:00 <edwardk> EvanR: anyways data.set and data.map in containers do this all over the place
12:17:06 <EvanR> yeah i figured
12:19:35 <eikke_> would someone be willing to explain where the 'd' comes from in the '->' ArrowLoop instance?
12:19:56 <dmwit> laziness
12:20:06 <dmwit> Just a bet before I look at the definition.
12:20:29 <eikke_> loop f b = let (c,d) = f (b,d) in c
12:20:47 <dmwit> Damn, I'm good.
12:21:01 <dmwit> d comes from d, via laziness
12:21:32 <helgikrs> could someone explain this behaviour to me, it can be very annoying: http://codepad.org/WwuZFMBf
12:21:36 <dmwit> ?src fix
12:21:36 <lambdabot> fix f = let x = f x in x
12:21:40 <dmwit> eugu: same idea there
12:21:45 <dmwit> err
12:21:51 <dmwit> eikke_, rather
12:21:57 <helgikrs> tl;dr if there's a *.o file there ghci won't work the same way is if it's not there
12:21:59 <eikke_> hmh
12:22:10 <dmwit> helgikrs: The compiled code is less instrumented, but faster.
12:22:21 <mauke> helgikrs: if it's there, ghci will use it instead of looking at the source
12:22:30 <mauke> and the compiled version only exports main
12:22:44 <eikke_> dmwit: I see, it's somewhat like how *** is defined using first, and first using ***
12:22:47 <mauke> you can see the difference in the prompt
12:22:53 <helgikrs> is there a way to make ghci load the source every time .. except by deleting the object file?
12:22:55 <dmwit> eikke_: No, that's completely different.
12:23:06 <eikke_> dmwit: isnt that thanks to laziness as well?
12:23:07 <dmwit> eikke_: A correct Arrow instance has to provide one of (***) or first.
12:23:12 <mauke> helgikrs: try :l *test.hs
12:23:19 <mauke> I think there was some syntax with *
12:23:31 <dmwit> eikke_: Nope, that's thanks to default implementations being overridden by instances.
12:23:37 <eikke_> dmwit: ah damn, right
12:23:56 <helgikrs> mauke: there we go, thanks =)
12:23:58 <monochrom> helgikrs: see http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-compiled.html
12:24:05 <eikke_> dmwit: thanks!
12:26:23 <Polarina> With FFI, a function is returning a struct by value. What should I put as the type?
12:26:41 <mauke> Polarina: I don't think that's FFIable
12:26:53 <Polarina> mauke, that's not good.
12:26:58 <mauke> write a wrapper
12:27:06 <monochrom> need marshalling
12:27:19 <fax> what the hask
12:27:22 <mauke> void f(struct foo *p) { *p = bar(); }
12:28:16 <Polarina> :(
12:29:17 <dmwit> There are tools available to automate this stuff.
12:29:20 <dmwit> ...right?
12:29:39 <dmwit> Isn't this the kind of thing c2hs and hsc2hs were born for?
12:30:10 <Polarina> dmwit, I am using hsc2hs.
12:30:10 <AxleLonghorn> why haven't I heard of hpc before?
12:30:20 <AxleLonghorn> http://liamoc.net/articles/safe.html
12:31:05 <jlouis> AxleLonghorn: because you have not read the GHC docs ?
12:31:28 <Polarina> dmwit, do you know how I would use hsc2hs for this?
12:32:12 <AxleLonghorn> jlouis: I know, lol. I'm just surprised that more people aren't talking about it
12:32:32 <dmwit> sorry, no
12:32:57 <monochrom> the writer monad has come!
12:33:15 <writer> :-)
12:34:08 * jlouis marries writer to reader and state
12:34:35 <ddarius> AxleLonghorn: It was talked about quite a bit when it was new.
12:34:37 <monochrom> 3-way matching is NP-complete!
12:34:53 <writer> jlouis: I need IO to consummate the marriage ;)
12:39:56 <fax> > 1 / read ("0." ++ show . length =<< words "Can I remember the reciprocal?")
12:39:57 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
12:39:57 <lambdabot>         against inferred type...
12:40:23 <fax> > 1 / read ("0." ++ (show . length =<< words "Can I remember the reciprocal?"))
12:40:24 <lambdabot>   3.1415816607028972
12:42:07 <alpounet> nice
12:42:41 <Twey> Did anyone ever implement class aliases?
12:42:43 <EvanR> haha
12:42:49 <fax> Twey yes
12:42:55 <fax> Tom Shrijvers
12:43:14 <Twey> The wiki page says it was meant to be made a start on in April 2009
12:43:18 <Twey> Oh?
12:43:21 <Twey> But it's not in GHC?
12:43:34 <fax> I think it's a stand alone preprocessor
12:44:16 <micah> I try to import LLVM.Core
12:44:27 <micah> but when I build anything with that import
12:44:30 <micah> I get huge long linker errors
12:44:43 <Twey> With --make?
12:44:46 <Lemmih> micah: You can't use the llvm package from GHCi.
12:44:56 <micah> I'm not using ghci
12:45:12 <micah> ghc -o $(OUTPUT) --make $(FILES)
12:45:22 <micah> that's my command
12:46:14 <Twey> Hm
12:54:34 <EvanR> Î»
12:54:55 <monochrom> is an eigenvalue
12:55:11 <EvanR> > isUpper 'Î»'
12:55:12 <lambdabot>   False
12:55:13 <dmhouse> is a nonzero limit ordinal
12:55:15 <EvanR> > isLower 'Î»'
12:55:16 <lambdabot>   True
12:55:26 <EvanR> so i can use lambda as a variable
12:55:36 <EvanR> but i have to use upper case lambda as a data constructor
12:55:39 <dmhouse> That's a character literal, not a variable
12:55:49 <dmhouse> > let Î» = 42 in Î»
12:55:50 <monochrom> for example an eigenvalue
12:55:50 <lambdabot>   42
12:55:56 <dmhouse> But yes, you may.
12:56:27 <EvanR> > data Foo = Î Char Foo
12:56:28 <lambdabot>   <no location info>: parse error on input `data'
12:56:59 <monochrom> data Foo a = Î a [a]  -- heehee
12:57:39 <EvanR> shucks i cant use lower ;)
12:57:48 <ddarius> monochrom: His type is an infinite stream of characters.  Yours is a potentially infinite list of a.
12:58:07 <siracusa> > (Î»x -> x) 1
12:58:08 <lambdabot>   Pattern syntax in expression context: Î»x -> x
12:58:09 <ddarius> (non-empty)
12:58:27 <siracusa> Hhm, thought you can use it ther as well
12:58:30 <HugoDaniel> hey ppl
12:58:34 <EvanR> xterm default font for lambda is really funny ;)
12:58:35 <monochrom> My Foo is mine.
12:58:43 * chrisdone pounces on HugoDaniel
12:58:49 <HugoDaniel> i just rewrote my slowest function in C, and the time to generate a texture dropped from 3.2s to 1.4s
12:58:50 <HugoDaniel> :D
12:58:56 <HugoDaniel> using 2 cores
12:58:57 <chrisdone> cool!
12:59:03 <HugoDaniel> yes
12:59:04 <HugoDaniel> :D
12:59:40 <chrisdone> can I see?
12:59:50 <HugoDaniel> chrisdone: is the same pic :D
12:59:52 <HugoDaniel> ill post the results
12:59:54 <HugoDaniel> w8
12:59:54 <monochrom> "Î a [a]" is designed to look like "Î a . [a]" and play tricks on minds.
13:00:24 <chrisdone> HugoDaniel: can I see the code I mean. I've never used C code from Hasell like that
13:01:36 <HugoDaniel> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24625#a24625
13:01:38 <HugoDaniel> ah
13:01:39 <HugoDaniel> okey
13:01:41 <HugoDaniel> yes
13:01:59 <HugoDaniel> it is very easy, all i did was follow the ffi chapter of the real world haskell
13:02:12 <ddarius> data Î a b = Foo; type Bar = Î a [a]
13:03:02 <Twey> Boo
13:03:26 <Twey> type Î a b = a -> b
13:03:50 <HugoDaniel> i can't wait to try this out on a 4core machine
13:04:02 <monochrom> class LambdaFamily t where data Î t; Î» :: Î t
13:04:13 <Twey> Nice
13:04:23 <chrisdone> HugoDaniel: I can try it on mine if you like
13:04:40 <fax> > 1+1
13:04:40 <lambdabot>   2
13:04:52 <chrisdone> > succ 1
13:04:53 <lambdabot>   2
13:05:04 <Twey> > succ $ negate 1
13:05:05 <lambdabot>   0
13:05:21 <Twey> What's the quickcheck command?
13:05:33 <chrisdone> @check \f -> True
13:05:33 <lambdabot>   "OK, passed 500 tests."
13:05:45 <Twey> @check \n -> succ n == n + 1
13:05:45 <lambdabot>   "OK, passed 500 tests."
13:05:54 <chrisdone> @src succ
13:05:55 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
13:05:59 <chrisdone> :'(
13:06:08 <wavewave> is fusion available for lazy list?
13:06:10 <chrisdone> Source is never found, you damn piece of tin!
13:06:13 <arw_> @check \f -> False
13:06:14 <lambdabot>   "Falsifiable, after 0 tests:\n()\n"
13:06:18 <Twey> @src Integer succ
13:06:18 <lambdabot> Source not found. I feel much better now.
13:06:22 <Twey> @src succ Integer
13:06:22 <wavewave> i mean stream fusion
13:06:22 <lambdabot> Source not found. I feel much better now.
13:06:24 <Twey> Boo
13:06:27 <chrisdone> :t succ
13:06:28 <lambdabot> forall a. (Enum a) => a -> a
13:06:30 <Twey> wavewave: Er, of course?
13:06:35 <Twey> You can't do it for strict lists.
13:06:51 <wavewave> Twey: Ahh.. opposite?
13:07:00 <arw_> @check n * n == 2 * n
13:07:01 <lambdabot>   "Falsifiable, after 0 tests:\n"
13:07:10 <Twey> wavewave: Like I said, you can't do it for strict lists.
13:07:17 <Twey> @check n + n == 2 * n
13:07:17 <lambdabot>   "Falsifiable, after 0 tests:\n"
13:07:27 <Twey> @check \n -> n + n == 2 * n
13:07:28 <lambdabot>   "OK, passed 500 tests."
13:07:33 <chrisdone> arw_: I believe the next few lines give information about the test data used but lambdabot doesn't show it
13:07:37 <Twey> I guess that's the SimpleReflect n
13:07:49 <benmachine> @check False
13:07:50 <lambdabot>   "Falsifiable, after 0 tests:\n"
13:07:54 <alpounet> @Å§ype n
13:07:55 <lambdabot> Expr
13:07:58 <benmachine> @check True
13:07:59 <lambdabot>   "OK, passed 500 tests."
13:08:04 <arw_> chrisdone: yes, i guess so, too. at least the "real" output is more informative :)
13:08:10 <HugoDaniel> chrisdone: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24626#a24626
13:08:20 <chrisdone> who runs lambdabot?
13:08:27 * chrisdone considers patching it to show more info
13:08:56 <chrisdone> HugoDaniel: ah, I see. easy!
13:08:57 <benmachine> there is no test data if it failed after 0 tests
13:09:02 <benmachine> or rather
13:09:09 <alpounet> chrisdone, code.haskell.org/lambdabot/ iirc. and Cale has access to the machine
13:09:09 <benmachine> if it's not a function you're testing
13:09:44 <chrisdone> alpounet: ah, cool. I've patched it previously but wasn't sure who ran it now
13:10:59 <HugoDaniel> :D
13:11:07 <HugoDaniel> im so happy with haskell!!
13:11:41 <wavewave> Twey: isn't vector library using stream fusion and strict list?
13:11:47 <wavewave> Twey: I am confused.
13:12:57 <dmwit> > floor (-0.5)
13:12:58 <lambdabot>   -1
13:12:59 <jlouis> HugoDaniel: \o/
13:13:07 <dmwit> > round (-0.5 - 1)
13:13:08 <lambdabot>   -2
13:13:24 <dmwit> HugoDaniel: That is one weird definition for x0.
13:13:42 <HugoDaniel> dmwit: yes :)
13:13:50 <wavewave> so Data.Vector.Fusion.Stream is lazy?
13:14:22 <dmwit> HugoDaniel: Also it goes apparently unused. =P
13:14:27 <chrisdone> code.haskell.org is down
13:14:32 <HugoDaniel> dmwit: the function continues...
13:14:34 <wavewave> maybe I am confused with Unboxed stuff.
13:14:36 * dmwit nods
13:14:39 <HugoDaniel> i just cut it there
13:14:45 <HugoDaniel> only to show the C calling
13:21:23 <alatter> :-( http://downforeveryoneorjustme.com/code.haskell.org
13:23:16 <Twey> Not again :-\
13:30:07 <jmcarthur> wavewave: vector uses stream fusion to eliminate intermediate vectors entirely, so it's lazy where it fuses even though the result can be strict
13:30:21 <jmcarthur> wavewave: the stream-fusion package has stream fusion for lazy lists, btw
13:30:56 <jmcarthur> wavewave: that is, vector uses lazy streams as it generates new vectors
13:32:12 <Twey> HugoDaniel: I think you can have c_gradientNoise :: Double -> Double -> Double -> Int -> Double and get conversion automatically
13:33:42 <wavewave> jmcarthur: great answer! I see now...
13:37:17 <wavewave> I wish stream is the default lazy type..
13:37:28 <wavewave> lazy -> list..
13:38:21 <ddarius> There was a list library based on stream fusion but it (at the time) didn't handle nested concatMaps of the sort produced by list comprehensions as well as the foldr based fusion system currently used.
13:39:21 <wavewave> yes. I specifically want to use list comprehension for stream.
13:39:43 <jmcarthur> ddarius: was that the stream-fusion package?
13:39:55 <jmcarthur> i am not aware of whatever its limitations are
13:40:02 <aavogt>  ssh://code.haskell.org is still up
13:41:13 <wavewave> I am reading now http://hackage.haskell.org/trac/ghc/ticket/915
13:42:03 <wavewave> seems that it's not ready yet .
13:43:04 <wavewave> ??
13:44:04 <alatter> aavogt - ah! thanks. I had not tried that
13:47:04 <wavewave> Data.List.Stream is an instance of Traversable and Foldable?
13:47:35 <wavewave> I cannot find such subclassing in the haddock documents.
13:48:23 <eikke_> dmwit: one more arrow question: in a 'left' arrow, how can I return a 'Right' for the next step when using '+++'?
13:48:35 <eikke_> since the result of f in f +++ g is always wrapped in a Left
13:49:12 <ddarius> Use |||
13:49:33 <eikke_> ddarius: with returnA as second function?
13:49:59 <dons> Q1 2010 hackage popularity report: http://donsbot.wordpress.com/2010/04/03/the-haskell-platform-q1-2010-report/
13:50:03 <dons> see how your favorite package is doing
13:50:40 <dankna> hey cool
13:51:09 <dons> we'll hit 2000 packages in a few days, and 2M downloads mid-April i think
13:51:21 <dankna> hey, direct-plugins got 35 downloads.  that's 34 more than I expected :D
13:51:39 <Twey> The top ones are needed for cabal-install
13:51:42 <Twey> No fair cheating :Ã¾
13:51:51 <dankna> writing an essential package isn't cheating
13:52:04 <wavewave> cool!
13:52:08 <Twey> But they're installed automatically â not necessarily popular at all
13:52:17 <dons> things like zlib and utf8-string didn't exist 3 years ago
13:52:31 <dons> they filled essential gaps that made other things possible
13:52:35 <dv-> dons: is there a readable version of that dependency graph?
13:52:36 <dons> text and vector seem to be doing a similar job now
13:52:41 <dons> dv-: yikes.
13:52:54 <dons> dv-: that was from a year ago, but it is huge. i'll recrunch it sometime
13:53:02 <dons> but it was from when hackage was about 700 packages
13:53:03 <dons> not 2k
13:53:22 <dons> pandoc is a nice example of a tool that stands purely on its own merits
13:53:27 <dons> agda too
13:53:37 <clanehin> dons: the links to the full data don't seem to work
13:53:51 <dons> http://www.galois.com/~dons/hackage/april-2010/2010-Q1.html ?
13:53:58 <dankna> clanehin: they work for me
13:53:59 <dons>  http://www.galois.com/~dons/hackage/april-2010/popularity.csv
13:54:02 <dons> wfm.
13:54:05 <wavewave> how did you generate the graph? using graphviz?
13:54:24 <dons> yeah, there's a post about it: http://donsbot.wordpress.com/2009/03/16/visualising-the-haskell-universe/
13:54:30 <dons> bit over a year ago
13:54:37 <wavewave> very cool and artisitic ;-)
13:54:52 <clanehin> the address works, but something's going on when I click it
13:54:57 <dons> oh, its the namespace, sorry
13:54:59 <dons> not the dep graph.
13:55:19 <ezyang> fuzzy pictures
13:56:35 <edwardk> trying to figure out how to give prettier error messages when something fails to solve in my cheesy qsat solver. I'm thinking about trying for something like <?> in parsec.
13:59:22 <byorgey> wow, hakyll is made of win
13:59:23 <edwardk> perhaps topologically sort the conjuncts, if the qbf solver actually found a counter example, then take the universally quantified variables that it reported as leading to the failure, set them, and re-run the problem as a simple sat problem, taking the messages from conjuncts that then fail
13:59:48 <Cale> qsat? Is that like some sort of quantum satisfiability problem?
14:00:33 <edwardk> do x <- forall; y <- forall; z <- forall; assert $ (x && y) ==> z === x ==> y ==> z <?> "currying holds"
14:00:59 <edwardk> Cale: qsat is basically solving quantified boolean formulas. 'SAT with forall'
14:01:36 <edwardk> i have a little monad i've been working on for talking to sat solvers and qsat solvers, and for eventually doing the solving myself.
14:01:38 <Cale> ah, okay
14:01:59 <edwardk> i wound up needing it for, of all things, managing package version dependencies ;)
14:02:02 <ezyang> edwardk: Mmmm. Anything distinguishing it from the other monadic sat solvers?
14:02:10 <edwardk> ezyang: bsd license? =)
14:02:13 <ezyang> hee :-)
14:02:27 <edwardk> ezyang: the other piece is notice that the formula above was expressed without using the monad all over the place
14:02:34 <edwardk> it recovers sharing info using stable names.
14:03:10 <edwardk> ezyang: also, if i can figure out the right way to encode it it'll be able to give you back something more expressive than 'unsatisfiable'
14:03:21 <ezyang> cute!
14:03:38 <edwardk> ezyang: that was what i was mentioning above about sorting conjuncts and spotting failure that way
14:03:50 <edwardk> er sorting clauses
14:04:14 <dons> byorgey: yeah, the unsw blog done in hakyll looks good
14:04:21 <wavewave> dons: i have a question. Is the stream in stream-fusion not an instance of Data.Traversable?
14:04:48 <edwardk> ezyang: i looked at fixing satchmo, but the gpl license means i still couldn't use it for my own work when i'm done, so i started over.
14:04:49 <dankna> aw, I can't look at dons's big dependency images because code.haskell.org is down :(
14:05:27 <ezyang> edwardk: Right.
14:05:45 <edwardk> ezyang: i also looked at hooking into external smt solvers for the next tier up in complexity, but i think i'm going to limit my scope for now
14:05:46 <ezyang> A friend of mine surveyed the space a while back, and it seems like there aren't that many well documented ones, at least
14:05:49 <dons> Igloo: apache on c.h.o down?
14:05:57 <dons> wavewave: probably not, no.
14:06:30 <edwardk> ezyang: all i do right now is package up your problem into a valid (q)dimacs problem to send to the sat solver, send it off, get back an answer, and then decode it into bools, ints, enums, etc.
14:06:38 <ksf> open sum types with closed functions, anyone?
14:06:54 <ksf> HList seems to be able to do it, but I'd like to go without heavy dependencies
14:06:59 <edwardk> ezyang: so in the event of success you get not only 'satisfiable' but the values that made up the query, which is kind of nice
14:07:17 <ezyang> edwardk: Yeah, that is definitely something you want
14:07:25 <ezyang> which external SAT solver are you using?
14:07:30 <edwardk> ksf: you need to use fundeps to completely mimic the hlist magic
14:07:38 * Twey wonders why people consider HList a âheavyâ dependency
14:07:59 <edwardk> right now i'm targeting funsat, minisat, skizzo, qube, and quantor as my initial list
14:08:14 <edwardk> funsat not even needing to leave haskell
14:08:21 <edwardk> but it doesn't do qsat
14:08:23 <aavogt> Twey: it's conceptually heavy?
14:08:24 <ksf> Twey, ok, obscure dependency
14:08:33 <Twey> Fair enough
14:08:46 <ksf> actually, arcane
14:09:03 <edwardk> ezyang: another twist is i'm using some type level branding to keep you from mixing up multiple sat problems, but that is more for anal retentiveness/correctness sake ;)
14:09:29 <ksf> ...and oleg isn't known to design interfaces snarfable for mere mortals.
14:09:55 <ezyang> edwardk: As in, associating all of the stable names with a specific problem?
14:09:55 <Twey> I think his interfaces are usually pretty good, actually
14:10:04 <Twey> It's just understanding the workings that's terrifying
14:10:10 <edwardk> actually my biggest problem of HList is the List part. I need to package up my type level fingertrees into an "HSeq" package ;)
14:10:57 <ddarius> edwardk: What operations do you need to be efficient?
14:11:15 <edwardk> @hpaste
14:11:16 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
14:11:35 <ksf> Twey, but I want to understand the inner workings, at least in part
14:11:46 <edwardk> ddarius: as a sat solver?
14:11:52 <pdani> hi
14:11:56 <edwardk> ddarius: oh the hlist
14:12:01 <Cale> Actually, I think the interfaces are usually kind of scary too, if you consider the types to be part of the interface.
14:12:13 <Cale> The value level stuff is usually simple.
14:12:16 <ksf> that is, I'd like to know how polymorphic variants would end up looking at run-time (the shape of the data), whether it's performant
14:12:28 <ksf> ...whether constructor elimination works for them, that is.
14:12:29 <edwardk> ddarius: if you use hlist for records, you basically turn every object it encodes into a big list of fields that are positionally accessed. its like indexing into a list over and over again.
14:12:42 <ezyang> edwardk: Do you know what the overhead of schlepping the data into an external format is, is?
14:12:47 <edwardk> ddarius: An "HSeq" would at least give you logarithmic field access
14:13:05 <ksf> Cale, the problem is that it's easy to procrastinate digging through the source looking for value-level stuff with all those scary classes around.
14:13:20 <edwardk> ezyang: its not so bad, way more time is spent solving the problem than on sending/receiving it.
14:13:32 <ezyang> interesting!
14:13:52 <ezyang> I hear the folks at Galois want a more native interface due to that very concern.
14:13:55 <ddarius> edwardk: I understand, but do you really need "Seq" and not something simpler.
14:13:56 <ddarius> ?
14:14:01 <pdani> which haskell module should i use for working with fixed-length vectors, and i would like to add, and substract them, and i multiply a vector by a scalar?
14:14:18 <ezyang> pdani: uvector, probably
14:14:24 <edwardk> ezyang: an SMT solver would be nicer though, for somethings. i can define ints and how they add and multiply as circuits, and how to marshal an int back and forth, but you repeat the circuit over and over in the result. using SMT i'd be able to express that redundancy
14:14:30 <edwardk> ddarius: probably
14:14:34 <ksf> pdani, vec
14:14:39 <ksf> or data parallel haskell
14:14:45 <edwardk> ezyang: i haven't gotten to very big problems yet. =)
14:14:46 <ksf> http://hackage.haskell.org/packages/archive/Vec/0.9.6/doc/html/Data-Vec.html
14:15:03 <edwardk> ezyang: otoh, i'm also doing some simplification in the sat monad that builds up the problem
14:15:12 <ezyang> edwardk: Ooh
14:15:20 <edwardk> ezyang: so it constant folds, etc.
14:15:31 <edwardk> ezyang: effectively partially evaluating the problem
14:15:38 <pdani> ksf, and how can i multiply a Vec with a numeric?
14:15:58 <pdani> i didn't find the method
14:16:06 <ezyang> pdani: Use the Functor instance.
14:16:07 <pdani> i mean, function
14:16:24 <edwardk> ezyang: so if you create two 'logic variables' bound to known integers and add them, they'll be made out of known bits, and the adders will evaluate to a known value.
14:16:30 <ksf> yep, functor
14:16:42 <edwardk> ezyang: so no actual work will be created
14:16:48 <ksf> well, no. there's http://hackage.haskell.org/packages/archive/Vec/0.9.6/doc/html/Data-Vec-Base.html#v%3Amap
14:17:00 <ezyang> ha! Anything more clever than unit propagation?
14:17:25 <ksf> ...the whole library is based on operations over fixed-length lists
14:17:37 <edwardk> ezyang: not yet. common clause elimination happens by accident more or less by virtual of storing the clauses as a map of IntSets to names.
14:17:54 <edwardk> ezyang: which i'm trying to add so i can give better diagnostics when things fail to be satisfiable
14:18:08 <edwardk> er
14:18:09 <edwardk> rather
14:18:17 <ksf> > fmap (*2) (1.:2.:3.:())
14:18:18 <lambdabot>   Not in scope: `.:'Not in scope: `.:'Not in scope: `.:'
14:19:06 <Sgeo> fmap (*2) (1.0:2.0:3.0:[])
14:19:07 <edwardk> by storing the CNF as a Map IntSet [String] -- so basically constants are eaten out of the clauses, but beyond that i figure the actual sat solver will know better than I what to do
14:19:13 <Sgeo> > fmap (*2) (1.0:2.0:3.0:[])
14:19:14 <lambdabot>   [2.0,4.0,6.0]
14:19:27 <edwardk> i could go and write something to clean up horn clauses, look for pure literals, etc. but that seems rather pointless given the fact that the destination will
14:19:48 <ezyang> edwardk: "don't you be goin' and solvin' the problem yersself"
14:19:49 <edwardk> and that doing it online can adversely affect the asymptotics of the solution
14:21:51 <ezyang> wouldn't your transformations be offline?
14:22:08 <edwardk> i apply the constant propagation as you build the problem
14:22:18 <ezyang> ah
14:22:35 <ezyang> I guess I have them switched
14:23:39 <edwardk> besides for the most part the monad doesn't even know its solving cnf/qbf or something harder, that way later on i can tackle SMT if i'm feeling up to it ;)
14:24:36 <edwardk> the other work that i do is observable sharing.
14:24:40 * hackagebot haskell-src-exts-qq 0.2 - A quasiquoter for haskell-src-exts.  http://hackage.haskell.org/package/haskell-src-exts-qq-0.2 (MathieuBoespflug)
14:24:46 <EvanR> if i have a data Foo = A Int | B Foo can i create a value of type Foo which forms an eventual cycle
14:25:07 <edwardk> which is how i'm trying to make most of the actions for building up expressions non-monadic
14:25:48 <EvanR> let foo = B (B foo)
14:25:50 <EvanR> in
14:25:52 <EvanR> ?
14:26:20 <Saizan_> "foo = B foo" is enough
14:26:35 <EvanR> and that works
14:26:45 <EvanR> amazing
14:26:54 <edwardk> so i have Literals which are actual honest to god logic variables the sat solver will see, I have Lits with are partially evaluated Literals, and Bits which are actually expression trees that internally when you go to assert a Bit, it goes through the expression tree, assigns stable names, and builds those as fresh variables as needed.
14:27:22 <edwardk> so evaluating 1 bit might evaluate thousands of expressions through the partial evaluator
14:27:36 <edwardk> but it'll at least do so with the same sharing as the underlying haskell code
14:27:41 * hackagebot haskell-src-exts-qq 0.2.1 - A quasiquoter for haskell-src-exts.  http://hackage.haskell.org/package/haskell-src-exts-qq-0.2.1 (MathieuBoespflug)
14:28:43 <edwardk> as a nice side effect, when you solve the problem, any bit (even one left unasserted) effectively becomes a function you can decode with the solution
14:29:53 <edwardk> i should be able to do the same thing for fixed width ints
14:30:50 <edwardk> so you can just write let x' = x * x in x' + x' and get observable sharing in the expression. even if you don't use x in the result
14:31:06 <edwardk> if that makes sense
14:35:52 <Cale> EvanR: Though it's not really the most flexible thing, you can also define the rooms in a text-adventure sort of game in a similar way, just defining the rooms to refer to each other in a mutually recursive way.
14:36:39 <EvanR> seems like a natural thing to do
14:37:34 <Cale> It is reasonably natural. It's bad if you need to make any changes though.
14:37:46 <EvanR> at runtime
14:37:50 <Cale> yes
14:38:02 <EvanR> zork never did! ;)
14:38:21 <Cale> Because then you'll end up turning a cyclic thing with finite memory into an infinite thing with the possibility for a memory leak.
14:38:44 <edwardk> clearly what is needed is a room zipper ;)
14:39:07 <EvanR> what is all this zipper hype, whats a zipper
14:39:08 <Cale> Or just change representation to use an IntMap
14:39:18 <edwardk> though that doesn't solve cale's problem directly. you'd still need to move 'out' of the rooms  by storing them in something like an IntMap
14:39:19 <edwardk> yeah
14:40:07 <edwardk> EvanR a zipper is a way to think about being in the middle of a list or data structure, by describing the path taken to get to your current location and the remainder of the list
14:40:39 <edwardk> a zipper in the middle of "abcdef" might look like ("cba","def") , you can go 'right' by moving one char over
14:40:45 <edwardk> ("dcba","ef")
14:40:57 <edwardk> but now it is O(1) to update 'e' to something else
14:41:06 <edwardk> ("dcba","hf")
14:41:14 <edwardk> and you can unzip by reversing out the first half
14:41:19 <edwardk> "abcdhf"
14:41:21 <EvanR> thts cute
14:41:33 <fax> this generalizes to all regular data types
14:41:34 <edwardk> so you get O(1) ability to move right and left through the list
14:41:38 <edwardk> exactly
14:41:49 <EvanR> a turing tape ;)
14:41:59 <edwardk> you can do this over any polynomial data type, but the notion of the 'path' isn't as simple.
14:42:07 <Sgeo> I guess if I wanted to make a BF implementation, I'd use a zipper?
14:42:40 <Cale> Sgeo: You could
14:42:50 <fax> I wouldn't
14:42:53 <Cale> (It should be quite effective to do that)
14:42:54 <edwardk> Sgeo: they are just a tool, to be used when appropriate. not sure i see the immediate benefit in BF terms though
14:42:56 <fax> oh wait
14:43:02 <fax> if you mean for the memory that is quite sane
14:43:06 <Cale> yeah
14:43:12 <fax> but if you meant for the program code, it seem like a bad idea
14:43:27 * Sgeo meant for memory
14:43:27 <ddarius> People have used zippers for BP implementations.
14:43:33 <Sgeo> BP?
14:43:42 <ddarius> BF
14:45:31 <centrinia> Where?
14:46:27 <ddarius> Probably on hpaste somewhere.
14:46:39 <temoto> What's the difference between STM TVar and TMVar ?
14:46:41 <centrinia> Oh. :p
14:47:11 <Cale> temoto: Reading and writing to TVars doesn't block.
14:47:12 <ddarius> temoto: The difference between IORef and MVar roughly.
14:47:26 <aavogt> how do you you encode bidirectional fundeps using type families?
14:47:50 <temoto> Cale, doesn't block other readers or what?
14:47:52 <Cale> temoto: TMVars can be empty or full. Reading from an empty TMVar causes the transaction to retry. Writing to a full TMVar does as well.
14:48:42 <aavogt> such as   class Apply f x r | f x -> r, f r -> x where apply :: f -> x -> r
14:48:46 <pikhq> It's basically an MVar, except that it's transactional instead of locking.
14:49:00 <temoto> Got it, thanks.
14:50:33 <aavogt> hmm, I'll try if    class Apply f where type Arg f :: *; Res f :: *; apply :: f -> Arg f -> Res f   works out
14:51:41 <ddarius> aavogt: That's a bit more strict than the fundep version.
14:52:06 <aavogt> yeah, it sort of means the function takes only one argument and result type
14:53:04 <temoto> I wrote a simple key-value storage with network interface and pass TVar (Map String String) to request handlers (GET/SET/etc). Handlers return STM String, where string is the answer to client. IO loop does 'atomically $ writeTVar state $ handler state' to apply possible change of state.    Does this design make sense and proper use of TVar?
14:53:13 <aavogt> I'm not sure how to say that it takes lots of argument and result types, but that one of the argument or result type can determine the other
14:53:31 <ddarius> aavogt: The associated type version corresponds to class Apply f dom cod | f -> dom, f -> cod where ...
14:53:50 <aavogt> it seems like I need another parmeter to my class
14:53:56 <aavogt> yes
14:54:07 <Cale> temoto: seems sensible
14:57:38 <edwardk> aavogt: class Foo f a b | f a -> b, f b -> a where apply :: f -> a -> b
14:58:12 <edwardk> aavogt: i use that approach with adjunctions
14:58:54 <edwardk> er sorry, the 'categorical functors' in http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor-Categorical.html
14:59:49 <edwardk> aavogt: i think to do so with fundeps would require an explicit pair of apply functions, one for inferring up, the other for inferring down.
15:00:02 <edwardk> er s/fundeps/type families/
15:00:03 <ddarius> aavogt: Not quite the same...
15:00:17 <ddarius> er edwardk
15:00:47 <edwardk> oh i missed he had already pasted the class for the Apply type.
15:01:03 <edwardk> *reads the initial question*
15:01:17 <EvanR> so a cyclic data structure loses the ability to be easily serialized and deserialized with Show and Read
15:01:49 <ddarius> EvanR: A cyclic data structure can't be serialized or deserialized with Show or Read.
15:02:07 <EvanR> is there an alternative way ? :)
15:02:17 <breakspirit> hi guys
15:02:35 <edwardk> EvanR: yeah i mocked up a 'show with observable sharing' at one point using Data and StableNames
15:02:44 <ddarius> EvanR: Actually, I'm wrong to some extent.
15:02:59 <ddarius> EvanR: If your nodes are uniquely labelled somehow, then you can do it.
15:03:22 <EvanR> interesting, interesting
15:03:29 <breakspirit> http://pastebin.com/11uRaG6Z     can someone tell me what's wrong with this bit of code?  I'm a haskell noob
15:03:35 <ddarius> An alternative is to explicitly represent "cycles."
15:03:49 <EvanR> what about Y combinator
15:03:52 <EvanR> ;)
15:03:59 <edwardk> breakspirit: what is it supposed to do?
15:04:00 <ddarius> EvanR: What about it?
15:04:05 <centrinia> :t fst -- You don't apply fst to lists.
15:04:06 <lambdabot> forall a b. (a, b) -> a
15:04:14 <breakspirit> return a bool if the first two elements are the same
15:04:16 <edwardk> breakspirit: you probably mean 'head' not fst.
15:04:18 <EvanR> represent the structure as a lambda expression
15:04:33 <breakspirit> oh, is fst for tuples?
15:04:46 <centrinia> firstTwoEqual (x:x':xs) = x == x'
15:05:03 <edwardk> breakspirit: firstTwoEqual (x:y:_) = x == y firstTwoEqual _ = False -- might be a cleaner way
15:05:06 <breakspirit> x:x' gets the first two things from the list?
15:05:11 <ddarius> EvanR: You can't analyze functions and such a representation would have way more values than you'd want.
15:05:17 <breakspirit> ah, makes sense.  thanks guys
15:05:38 <breakspirit> if i may ask, whats technically wrong with what i wrote, instead of using fst instead of head?
15:05:41 <edwardk> a:b:c:rest breaks up the first three elements and puts them in a b and c
15:05:45 <breakspirit> because it still doesnt work if i replace fst with head
15:06:13 <centrinia> breakspirit, firstTwoEqual :: (Eq a) => [a] -> Bool
15:06:14 <EvanR> suppose the data consisted on simple data values and structures of simple
15:06:20 <eikke_> if someone would be willing to do a little 'review': anything stupid in http://gist.github.com/354885 ?
15:07:02 <edwardk> breakspirit: your function claims to work on all lists, no matter their contents, but it needs to know that it can compare the elements using (==). hence centrinia's clarification
15:07:33 <breakspirit> ah yes, thanks
15:08:28 <edwardk> http://pastebin.com/vMxmD6Dw
15:08:49 <edwardk> after all the result of x == y _is_ a Bool =)
15:09:17 <breakspirit> thanks  =)
15:14:32 <breakspirit> i know that haskell is very functional and so output is inherently weird, but whats a simple way to output a short string of text within a function thats doing something else?
15:14:43 <ezyang> unsafePerformIO
15:14:45 <micah> Debug.Trace?
15:15:04 <breakspirit> i do not understand  =/
15:15:08 <EvanR> divine intervention
15:15:26 <SamB_irssi> breakspirit: you want this for debugging, or what ?
15:15:33 <EvanR> your pure function should be full proof and simple to write, no debug messages needed :)
15:15:42 <SamB_irssi> EvanR: and you should be able to spell
15:15:54 <breakspirit> to explain further, i wish to have text labels displayed before each function's output
15:15:59 <Sgeo> Debug.Trace.trace "Here, print me out" (somestuff that does the actual work)
15:16:10 <EvanR> SamB_irssi: ?
15:16:12 <Sgeo> THat will have the type of (somestuff that does the actual work)
15:16:16 <Hunner> :t trace
15:16:17 <lambdabot> Not in scope: `trace'
15:16:19 <SamB_irssi> EvanR: you said "full proof"
15:16:25 <SamB_irssi> but you meant "fool proof"
15:16:30 <Sgeo> :t Debug.Trace.trace
15:16:31 <lambdabot> forall a. String -> a -> a
15:16:38 <EvanR> fool proof was the derived term
15:16:47 <benmachine> let's not suggest Debug.Trace unless we're sure it's what people want
15:16:49 <Hunner> SamB_irssi: But it could be fully proven -> full proof
15:17:03 <benmachine> use of it is not recommended unless you are debugging, hence the name
15:17:04 <Twey> Sounds like it's exactly what's wanted
15:17:11 <SamB_irssi> Hunner: in that case, he needs to remember to stick in "a" where it's needed ;-P
15:17:35 <benmachine> depends what's means by "each function's output"
15:17:37 <breakspirit> im not debugging though
15:17:37 <Twey> Haha
15:17:39 <dons> breakspirit: you want to trace the result?
15:17:40 <dons> or print it?
15:17:40 <breakspirit> this is for final code
15:17:53 <Twey> Took me a long time to figure out âfull proofâ, EvanR, SamB_irssi
15:17:54 <SamB_irssi> breakspirit: maybe you better start from the beginning ;-)
15:17:54 <micah> so you just want to a append a string to something?
15:17:59 <Twey> I thought perhaps it was some mathematical term
15:17:59 <Hunner> SamB_irssi: It's irc in international waters. You should already be glossing over language discrepencies without even thinking
15:18:00 <dons> if it is not for debugging, you shoudl return the result to a function that is reponsible for the output. e.g. print "foo"
15:18:01 <breakspirit> no, i simply want to display something like "the output is: "  before the function's return value is posted
15:18:06 <micah> oh ok
15:18:13 <dons> print "The output is: " ++ (show result)
15:18:14 <Twey> benmachine: Okay, I stand corrected :Ã¾
15:18:24 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24627#a24627
15:18:24 <SamB_irssi> Hunner: only when someone isn't implying that everyone should be perfect ;-P
15:18:41 <Twey> dons: Why the brackets?
15:18:42 <ksf> I feel like a small kid that's intimidated by a pudding thrice as big as his head
15:18:44 <benmachine> putStrLn $ "The output is: " ++ show result -- pedantic version
15:18:54 <SamB_irssi> ksf: yeah, that's where we keep the proof
15:18:55 <Hunner> ksf: hah
15:19:17 <Sgeo> > (Debug.Trace.trace "Hello" 1) + 1
15:19:18 <lambdabot>   Not in scope: `Debug.Trace.trace'
15:19:39 <alpounet> @hoogle trace
15:19:39 <lambdabot> Debug.Trace trace :: String -> a -> a
15:19:40 <lambdabot> Network.HTTP.Base TRACE :: RequestMethod
15:19:40 <lambdabot> module Debug.Trace
15:19:45 <ksf> it's like deobfuscating source.
15:19:51 <EvanR> i like the (print "my msg") way. have your function return the message to print
15:19:59 <EvanR> along with the value
15:20:03 <ezyang> ksf: ...
15:20:06 <ksf> first step: do some sane type synonyms and don't dare to touch a thing.
15:20:08 <ezyang> is that bind >>= bind?
15:20:11 <ksf> yep
15:20:21 <dons> Twey: just to emphasise
15:20:22 <ezyang> ewww
15:21:00 <ksf> dunno why it's not unifying the inner monads
15:21:06 <breakspirit> http://pastebin.com/M59BVM09   lets say my code is something painfully simple like that, how would i output a string there?
15:21:10 <EvanR> i was actually trying to type full proof, do i dont need to learn to type. learning whether certain phrases are not what they sound like is another story
15:21:25 <EvanR> i have many other real typing problems
15:21:35 <benmachine> breakspirit: I think you would write your code in such a way that it wasn't necessary
15:21:40 <SamB_irssi> EvanR: well, okay, my point was "yeah right, when pigs fly"
15:21:52 <EvanR> ah
15:21:54 <breakspirit> would be better to have a function whose only job was outputting that text?
15:22:07 <benmachine> breakspirit: at some point, you're going to have to do a print or a putStrLn or whatever to actually show the user what that value is; just output your string in the same place at the same time
15:22:15 <FunctorSalad> @seen Baughn
15:22:15 <lambdabot> Unknown command, try @list
15:22:21 <FunctorSalad> preflex: seen Baughn
15:22:22 <preflex>  Baughn was last seen on #haskell-blah 2 days, 9 hours, 47 minutes and 14 seconds ago, saying: Sorry, wrong channel
15:22:34 <SamB_irssi> aww
15:22:54 <FunctorSalad> hmm, odd that he's still active here apparently, yet the trac has fallen prey to the spammers?
15:23:01 <aavogt> edwardk: I'm trying to do it without two separate apply functions
15:23:01 <ksf> is there some way to do class synonyms that doesn't involve UndecidableInstances that I missed?
15:23:07 <SamB_irssi> FunctorSalad: trac for which ?
15:23:21 <FunctorSalad> SamB_irssi: haskell-mode for emacs
15:23:36 <FunctorSalad> (IIRC he is the new maintainer)
15:23:37 <benmachine> breakspirit: instead of a function printing something, it can just as well return whatever it wants printed, and let some higher-level thing print it
15:23:38 <SamB_irssi> FunctorSalad: maybe he hasn't noticed because HIS spam filters filter out the trac spam ?
15:23:49 <Baughn> FunctorSalad: It's a case of "too damn busy with thesis", I'm afraid.
15:23:53 <Baughn> And also, that.
15:23:54 <aavogt> edwardk: basically the intention is to be able to apply functions like Just to hlists such that you could infer the original type from the result type
15:24:08 <breakspirit> ah ok, thanks =)
15:24:10 <FunctorSalad> Baughn: ah. Send you a mail already but in that case ignore it ;)
15:24:15 <aavogt> since Just and many other functions don't discard any type information
15:24:18 <FunctorSalad> *sent
15:24:34 <aavogt> sort of like this:    map (+1) . map read
15:24:37 <aavogt> except for hlists
15:25:24 <Sgeo> What's an hList?
15:25:33 <Sgeo> erm, HList?
15:25:34 <FunctorSalad> Baughn: btw, the darcs patch I posted to the mailing list is missing a newly created file
15:25:56 <aavogt> @hackage HList
15:25:56 <lambdabot> http://hackage.haskell.org/package/HList
15:26:05 <aavogt> Sgeo: a nested tuple
15:26:14 <chrisdone> http://www.emacswiki.org/emacs-en/QuickCheckHaskell mmmm emacs quickcheck support
15:26:17 <SamB_irssi> Sgeo: it's like a tuple on steroids ;-)
15:26:39 <Sgeo> Wait, heterogenous list?
15:26:39 <FunctorSalad> Baughn: but since I'm trying to add some auto-complete-mode integration (for language pragmas for now) I'll wait with resending a proper patch
15:26:43 <SamB_irssi> that, too
15:26:49 <Sgeo> ...why/
15:27:22 <aavogt> because haskell's builtin records are really weak
15:27:55 <FunctorSalad> Baughn: I think we'd need a new option for the 'ghc' (or compatible) executable, for querying it for various stuff
15:28:02 <FunctorSalad> (ghc --supported-languages)
15:28:13 <SamB_irssi> and it's hard to cram usable field names into the type system we already have
15:29:08 <Sgeo> aavogt, weak syntactically, or use-wise?
15:29:22 <Baughn> FunctorSalad: I think it already has a switch to output a list of supported extensions
15:29:24 <SamB_irssi> Sgeo: they're not extensible or anything!
15:30:25 <aavogt> you can work around that sometimes if you're willing to deal with the error prone     data R = R { a,b,c,d,e,kitchen_sink :: Maybe Something }
15:30:26 <FunctorSalad> Baughn: (and I'm scared to mess with the ghci-inside-comint so I'd rather call ghc via shell-command-to-string if possible ;))
15:30:45 <aavogt> or sometimes nesting records
15:31:15 <fax> you can kind of hack together a (slightly bad) record system just using typeclasses
15:31:26 <heatsink> How would extensible records be implemented?
15:31:27 * ksf wants a ghc extension that replaces HList
15:31:37 <heatsink> Not in the type system, but in the runtime
15:31:39 <ksf> those type sigs just aren't practical
15:32:35 <kmc> ksf, would TH type splices do it?
15:33:01 <FunctorSalad> I found hlist a bit discouraging too
15:33:05 <ksf> I've got no idea.
15:33:06 <kmc> metaprogramming is a good meta-extension
15:33:21 <ksf> I don't understand any of those classes beside HasField
15:33:21 <kmc> effort towards making TH less cumbersome would pay off in a lot of ways
15:33:30 <FunctorSalad> (you're not supposed to understand the types instantiating the classes behind the scenes, are you?)
15:33:43 <ksf> kmc, but the main issue is type inferrence.
15:34:01 <fax> what if we just got ocamls records in haskell?
15:34:12 <FunctorSalad> I agree that metaprogramming can give easier-to-use results than typeclass excess
15:34:32 <chrisdone> what are ocaml records like?
15:34:39 <FunctorSalad> (err, not sure if I can say "agree" since that's not exactly what you said)
15:35:21 <micah> does anyone know why linking with llvm gives me a huge long error?
15:35:32 <Lemmih> micah: hpaste them?
15:35:51 <AdaHopper> sudo /Applications/TextEdit.app/Contents/MacOS/TextEdit /etc/hosts
15:35:57 <aavogt> the actual types involved with metaprograms are much more specific
15:35:58 <AdaHopper> sorry!
15:36:17 <FunctorSalad> aavogt: yes, that's the idea
15:36:28 <micah> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24628#a24628
15:36:40 <FunctorSalad> (regular types have more infrastructure support)
15:36:42 <aavogt> but mostly I think it's because errors regarding missing instances are much more general
15:36:56 <FunctorSalad> ("deriving", for example...)
15:37:01 <aavogt> maybe not more general, but more verbose?
15:37:45 <FunctorSalad> well, typeclass programming expresses things with relations rather than functional terms; that's inherently more verbose
15:37:50 <FunctorSalad> (and introduces more variables)
15:38:03 <kmc> does HList use type families at all?
15:38:05 <fax> http://caml.inria.fr/pub/docs/manual-ocaml/manual006.html
15:38:16 <aavogt> kmc: it predates them
15:38:23 <kmc> yeah
15:38:26 <fax> this idea is actually very similar to what epigram is doing
15:38:29 <kmc> so a rewrite using those features might be cleaner
15:38:51 <aavogt> kmc: I was trying that, but it seems there is no nice way to encode this: class ApplyBidi f a b | f a -> b, f b -> a where
15:38:59 <aavogt> but that's not actually part of hlist...
15:39:10 <aavogt> but I find it useful enough anyways ;)
15:39:15 <FunctorSalad> make a type-level pair of f and inv(f)? ;)
15:39:20 <fax> #let f = function `A -> `C | `B -> `D | x -> x;;
15:39:21 <fax> val f : ([> `A | `B | `C | `D ] as 'a) -> 'a = <fun>
15:39:21 <fax> #f `E;;
15:39:21 <fax> - : [> `A | `B | `C | `D | `E ] = `E
15:39:25 <chrisdone> labels look kind of neat
15:39:33 <fax> ^ this is the sort of thing you can just about get workign in haskell with typeclass
15:39:53 <fax> going further than that is probably not worth it
15:40:03 <fax> because it just gets really difficult
15:40:32 <aavogt> ocaml people don't advocate using polymorphic variants though?
15:41:21 <FunctorSalad> what's polymorphic in a "polymorphic variant"?
15:41:34 <fax> see in that example
15:41:37 <FauxFaux> The variant.
15:41:40 <fax> `E is added
15:41:48 <fax> but it was not in the original definition
15:41:58 <fax> also they are identified up to permutation, which is nice
15:42:50 <fax> http://caml.inria.fr/pub/docs/manual-ocaml/manual003.html#s:tut-recvariants
15:42:59 <ksf> the longer I try to refactor that type sig, the more I believe HList is utter overkill
15:43:00 <fax> anyway there is no reason not to steal everything we can from other languages
15:43:29 <heatsink> Hmm.  How are polymorphic variants tagged?
15:44:01 * ksf considers http://guppy.eng.kagawa-u.ac.jp/~kagawa/PVH/
15:44:10 <FunctorSalad> fax: seems a bit like implicit coercion from (OldRecord,E) to OldRecord
15:44:33 <FunctorSalad> never ran into the need for it yet but maybe that's because it's not in my toolbox yet
15:44:34 <fax> I've not really thought about it in that way
15:44:53 <fax> yeah you know how it goes: When you learn a new hammer, everything thinks of nails
15:52:24 <breakspirit> lets say i have a function that returns a string.  how does one use print or putstrln or whatever to print said string?
15:52:42 <fax> putStrLn string
15:52:49 <micah> main = putStrLn $ fun $ arg
15:52:58 <micah> maybe the arg should come from getLine or something
15:53:27 <breakspirit> i dont understand, could i write putStrLn $ fun $ arg  within main?
15:53:37 <micah> yes
15:53:54 <breakspirit> fun is the function that returns the string, what is arg?
15:53:58 <breakspirit> and what are the dollar signs?
15:53:59 <micah> main = do i <- getLine; putStrLn $ fun $ i
15:54:05 <aavogt> @src ($)
15:54:05 <lambdabot> f $ x = f x
15:54:06 <micah> arg is the argument you want to apply it to
15:54:13 <micah> $ is just for conveninece
15:54:15 <micah> instead of
15:54:19 <micah> putStrLn (fun arg)
15:54:20 <micah> you say
15:54:22 <ksf> $ is just a trick to get rid of paranthesis
15:54:25 <micah> putStrLn $ fun arg
15:54:29 <breakspirit> ah, never seen that before
15:54:35 <micah> it can also be useful for
15:54:38 <micah> zipWith
15:54:43 <pikhq> breakspirit: It's fairly common in Haskell.
15:54:52 <ddarius> :t zipWith id
15:54:53 <lambdabot> forall b c. [b -> c] -> [b] -> [c]
15:54:56 <breakspirit> yeah, im very new to haskell  =)
15:55:07 <fax> me too
15:55:20 <ksf> ...the canonically accepted way to write it would be "putStrLn . fun $ arg" or "putStrLn $ fun arg", depending on what's clearer.
15:55:28 <breakspirit> what do you mean by "arg is the argument you want to apply it to"  i dont understand that
15:55:45 * ddarius would probably write "putStrLn (fun arg)"
15:56:10 <sepp2k1> breakspirit: You said you have a function. A function takes an argument.
15:56:11 <ksf> :t putStrLn . unwords $ ["Hello,", "World!"]
15:56:12 <lambdabot> IO ()
15:56:25 <ksf> :t unwords
15:56:26 <lambdabot> [String] -> String
15:56:30 <breakspirit> so it could be anything, like a bool for no purpose other than having an argument?
15:56:55 <ksf> if it doesn't take an argument it's not a function but a value
15:57:17 <ksf> :t putStrLn "Hello, World!"
15:57:19 <lambdabot> IO ()
15:57:20 <ksf> that works, too.
15:57:28 <ksf> or
15:57:50 <sepp2k1> breakspirit: Well, if you don't need an argument, you don't need a function.
15:57:51 <ksf> :t let hw = unwords ["Hello,", "World!"] in putStrLn hw
15:57:53 <lambdabot> IO ()
15:58:03 <sepp2k1> Nothing stops you from just doing putStrLn "My String"
15:58:55 <ksf> :t let hw _ = unwords ["Hello,", "World!"] in putStrLn hw ()
15:58:56 <lambdabot>     Couldn't match expected type `String'
15:58:56 <lambdabot>            against inferred type `t -> String'
15:58:56 <lambdabot>     In the first argument of `putStrLn', namely `hw'
15:59:04 <ksf> :t let hw _ = unwords ["Hello,", "World!"] in putStrLn $ hw ()
15:59:05 <lambdabot> IO ()
15:59:07 <ksf> :t let hw _ = unwords ["Hello,", "World!"] in putStrLn $ hw True
15:59:08 <lambdabot> IO ()
15:59:17 <ksf> :t let hw _ = unwords ["Hello,", "World!"] in putStrLn $ hw (error "huh?")
15:59:18 <lambdabot> IO ()
15:59:28 <ksf> ...especially try the last one.
16:00:29 <ddarius> If Haskell had an actual Void type it would quite confuse programmers of C-style languages.  forever :: IO a -> IO Void
16:00:36 <mtnviewmark> Does anyone know if there is going to be an April Hackathon in PDX?
16:00:40 <mtnviewmark> dons?
16:00:45 <ksf> ()?
16:00:57 <ksf> in my book, void is actually unit.
16:01:08 <ksf> you can, after all, deref a *void
16:01:14 <ddarius> C void is unit, but that wasn't what I was talking about.
16:01:22 <Zao> Void has no values or something?
16:01:41 <Twey> Right
16:01:48 <Twey> data Void
16:02:00 <Twey> â complete definition
16:02:02 <fax> > sqrt(sqrt(-1))-(1+sqrt(-1))/sqrt(2) :: Complex Double
16:02:03 <lambdabot>   1.1102230246251565e-16 :+ 0.0
16:02:05 <Twey> It's a type with no values in it
16:02:15 <monochrom> "return" already confuses a whole bunch of C-style programmers.
16:02:19 <Zao> Bottoms up!
16:03:17 <Twey> Apart from bottom âº
16:03:26 <mtnviewmark> data Void = Vacuum | BlackHole | GapingMaw | Emptyness
16:03:31 <Twey> Haha
16:03:32 <fax> > sqrt(sqrt(-1))-(1+sqrt(-1))/sqrt(2) :: Comple CReal
16:03:33 <lambdabot>   Not in scope: type constructor or class `Comple'
16:03:34 <fax> > sqrt(sqrt(-1))-(1+sqrt(-1))/sqrt(2) :: Complex CReal
16:03:35 <lambdabot>   0.0 :+ 0.0
16:04:03 <ksf> void _has_ members.
16:04:09 <ksf> 256 of them.
16:04:13 <ksf> according to sizeof, that is.
16:05:29 <benmachine> you're not actually allowed to give it any of them though are you?
16:05:37 <ksf> I think void is Dynamic, more or less
16:06:29 <aavogt> > do Just 1; return 2; return 3 -- OMG
16:06:30 <lambdabot>   Just 3
16:06:30 <ksf> I guess you need to cast stuff
16:06:39 <aavogt> spells?
16:06:43 <ksf> but you should be able to write anything directly to a void*
16:07:07 <ksf> ...the type of pointers being quite useless except to scale offsets.
16:07:13 <aavogt> @djinn a -> b
16:07:13 <lambdabot> -- f cannot be realized.
16:07:27 <monochrom> haha 256 of them
16:07:46 <mtnviewmark> oy, is code.haskell.org down again?
16:07:49 <ksf> c's type system is designed around pointer arithmetic. the whole language is.
16:07:58 <ksf> actually, it should be called a pointer-oriented language.
16:08:04 <Twey> Haha, cute.
16:08:47 <Twey> 00:03:39 < ksf> void _has_ members.
16:08:47 <Twey> 00:03:45 < ksf> 256 of them.
16:08:47 <Twey> 00:03:50 < ksf> according to sizeof, that is.
16:08:51 <kmc> haha
16:08:53 <Twey> What?
16:08:56 <kmc> isn't void more like Any
16:09:00 <kmc> and a cast like unsafeCoerce
16:09:00 <Twey> How, what, why?
16:09:02 <Twey> No
16:09:04 <Twey> void* is
16:09:06 <Twey> void isn't
16:09:09 <kmc> ok
16:09:12 <kmc> then why is void Dynamic?
16:09:33 <Twey> void has no values (in fact, you can't even have a variable of type void: it's not a real type, more like a keyword to stand in for a type that isn't there when the language requires one)
16:09:49 <Twey> Are you talking about void (of C fame) or Void?
16:10:06 <kmc> i'm talking about what ksf said
16:10:15 <Twey> I think ksf was talking about C
16:10:27 <kmc> <ksf> I think void is Dynamic, more or less
16:10:31 <Twey> Which is why sizeof(void) == 256 is very very confusing
16:10:33 <Twey> Oh
16:10:42 <ksf> but that's the increment of a void*
16:10:44 <Twey> You two look too similar :<
16:10:50 <kmc> we get that a lot
16:11:13 <mtnviewmark> I imagine on his system sizeof(void) == 1
16:11:15 <Twey> I'd install nickcolor or something, but it lights up my client like a fairground ride
16:11:29 <ksf> that, in fact, would not help.
16:11:36 <Twey> Why not?
16:11:38 <ksf> we get hashed to the same colour.
16:11:46 <Twey> Depends which hash you useâ¦
16:11:46 <aavogt> not here
16:12:29 <ksf> Twey, if in doubt, switch to a proportional font.
16:12:33 <ksf> my nick is shorter.
16:12:46 <Twey> Not necessarily.  That's the wonder of proportional fonts.  ;)
16:13:03 <stevenmarky_> you should have a duel and the victor keeps the name
16:13:26 <kmc> there can be only one
16:13:28 <Twey> Point taken, but I hate proportional fonts for IRC, as well as text-only programs that don't run in a terminal
16:13:35 <Twey> Heh
16:14:08 <Twey> I guess the increment of void* was deliberately chosen to be big, to aid in the production of segfaults?
16:16:02 * ksf infers kmc to be undecidable and watches him dissapear in a puff of logic
16:16:32 <alpounet> c.h.o down ?
16:16:46 <ksf> Twey, other candidates for void* increments are page size or such.
16:16:46 <fax> curry howard o--morhism??
16:17:22 <ksf> but you want to have an increment, or mcpy and so on would have to work with char*
16:17:44 <Twey> Ah, yeah
16:20:24 <AdaHopper> hi, I'm so sorry for disturbing but I was reading about the haskell ideas list for the google summer of code and I'm a bit lost. Any guidance ?
16:23:34 <Cale> AdaHopper: hm?
16:24:05 <Cale> AdaHopper: Of course if none of the ideas appeal to you, you can also come up with something else.
16:25:26 <AdaHopper> I would like to know if all they are still active, and the community is still interested
16:27:25 <Cale> I seem to recall that recently Don Stewart (I think?) put a list of what he thought the 8 most important ones were.
16:27:31 <chrisdone> mhm
16:27:32 <Cale> ... on his blog
16:27:46 <chrisdone> that was posted to the mailing list aussi
16:28:14 <AdaHopper> thank yo very much
16:28:31 <AdaHopper> I find out in the planet
16:30:52 <temoto> What does '| Done !ByteString r' this ! mean in data constructor definition?
16:30:59 <dons> http://donsbot.wordpress.com/2010/04/01/the-8-most-important-haskell-org-gsoc-projects/
16:31:13 <dons> temoto: the ! indicates that that field should always be eagerly evaluated (i.e. strict)
16:31:26 <temoto> dons, thanks.
16:31:30 <dons> even if it isn't yet needed, it will be evaluated when the Done constructor itself is needed.
16:31:48 <dons> knowing this, the compiler can make various additional optimizations
16:32:07 <dons> in particularly, slightly less space will be used to store that field
16:34:27 <AdaHopper> thanks dons!
16:42:43 <fax> > 4 * (sum . map (\n->(-1)^n/(2*n+1)) $ [1..30])
16:42:44 <lambdabot>   Ambiguous type variable `a' in the constraints:
16:42:44 <lambdabot>    `GHC.Real.Fractional a'
16:42:44 <lambdabot> ...
16:42:51 <fax> > 4 * (sum . map (\n->(-1)**n/(2*n+1)) $ [1..30])
16:42:52 <lambdabot>   -0.8261576628092505
16:43:05 <fax> > 4 * (sum . map (\n->(-1)**n/(2*n+1)) $ [0..30])
16:43:06 <lambdabot>   3.1738423371907505
16:43:11 <fax> > 4 * (sum . map (\n->(-1)**n/(2*n+1)) $ [0..200])
16:43:12 <lambdabot>   3.1465677471829556
16:43:44 <fax> wow I can actually understand this one
16:44:07 <fax> is there a data type in haskell corresponding to 1/(x^2-1) ?
16:44:13 <fax> oops
16:44:15 <breakspirit> I need help writing a function that takes a list of tuples and returns a bool indicating whether the list contains a tuple like (a, o) and then immediately followed by (a, u) anywhere in the list
16:44:21 <fax> I want a data type: 1/(x^2+1) ?
16:44:40 <breakspirit> so for example, [...(x, o), (x, u)...] would return true
16:44:55 <aavogt> do you mean  'o' and 'u'?
16:44:57 <fax> breakspirit: so what I would do is write a recrsion operator
16:45:11 <fax> one that goes over the list two at a time
16:45:26 <breakspirit> this is for a tripcode that describes knotted strings, if that helps anyone understand what im doing
16:45:26 <aavogt> @type span
16:45:27 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
16:45:33 <fax> then a function  correct (a,b) (c,d) = (a,b) == (x, o) && (c,d) == (x, u)
16:45:36 <Cale> fax: Sure you don't mean 1/(1-x^2)?
16:45:39 <fax> which checks if it is right
16:45:53 <fax> Cale, well let me double check this
16:46:11 <Cale> 1/(1+x^2) has negative coefficients...
16:46:28 <ddarius> or . ap (zipWith (\(a1,_) (a2,_)) tail
16:47:32 <ddarius> or . ap (zipWith (\(a1,_) (a2,_) -> a1 == a2) tail
16:47:41 <breakspirit> thank you for the tips, im thinking about it
16:47:44 <fax> yeah 1/(1+x^2) and it does have negatives
16:47:57 * ddarius would recommend against writing Bool returning functions.
16:48:00 <fax> 1 - x^2 + x^4 - x^6 + ...
16:48:08 <fax> ddarius, oh, why
16:48:09 <fax> ?
16:49:03 <ddarius> fax: They usually result in a duplication of work.
16:49:08 <Cale> Maybe I don't know what you mean by that as a type if there are negatives in it :)
16:49:38 <ddarius> And they also make it harder to write code that is "obviously correct."
16:49:51 <ddarius> :t unfoldr
16:49:52 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
16:50:11 <breakspirit> fax, would you be able to tell me how that recursion function might look?  im pretty bad with recursion in practice
16:50:42 <ddarius> fax: Implement unfoldr' :: (b -> Bool) -> (b -> a) -> b -> [a] in terms of unfoldr and vice versa.
16:51:20 <fax> I was thinking like   twos p [] = False ; twos p [_] = False ; twos p (x:y:zs) = p x y || twos (y:zs)
16:51:21 <Cale> breakspirit: I would start with something like groupBy (\(x,y) (x',y') -> x == x')
16:51:31 <fax> oops
16:51:31 <adityam> I updated to ghc-12.1-4 on arch linux ... now ghc-pkg list says ghc-pkg: /usr/lib/ghc-6.12.1/package.conf.d/syb-0.1.0.3-5bfc1919690a88f6979448811
16:51:43 <adityam> How do I get correct it
16:51:45 <ddarius> fax: Now inline my code above replacing the lambda with p.
16:51:52 <ddarius> fax: And do the exercise I suggested.
16:51:59 <breakspirit> thanks fax and Cale, im gonna look that over
16:52:00 <Cale> breakspirit: This would take the list and break it into chunks consisting of adjacent elements with the same first component
16:52:02 <aavogt> adityam: correct what?
16:52:53 <Cale> breakspirit: Then you just have to look for a chunk that has more than one element in it. To ensure that this doesn't waste any time counting long segments, it's best to avoid the use of the length function
16:53:09 <ddarius> fax: Correction: unfoldr' :: (b -> Bool) -> (b -> a) -> (b -> b) -> b -> [a]
16:53:18 <adityam> aavogt: whenever I try to install any package I get /usr/lib/ghc-6.12.1/package.conf.d/syb-0.1.0.3-5bfc1919690a88f69794488119844568.conf:
16:53:19 <adityam> hGetContents: invalid argument (invalid UTF-8 byte sequence)
16:53:20 <fax> :t unfoldr
16:53:21 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
16:53:28 <breakspirit> what do you mean by "chunk that has more than one element in it"?
16:53:29 <Cale> breakspirit: So:  any (not . null) . map tail . groupBy ((==) `on` fst)
16:53:29 <fax> okay
16:53:50 <Cale> Or...
16:53:58 <Cale> breakspirit: So:  any (not . null . tail) . groupBy ((==) `on` fst)
16:54:19 <Cale> That uses the on function from Data.Function
16:54:20 <adityam> even running ghc-pkg recache gives ghc-pkg: /usr/lib/ghc-6.12.1/package.conf.d/syb-0.1.0.3-5bfc1919690a88f69794488119844568.conf: hGetContents: invalid argument (invalid UTF-8 byte sequence)
16:54:29 <Cale> But it's equivalent to the lambda that I wrote before
16:54:34 <breakspirit> wow, thats hugely over my head   =)
16:54:46 <temoto> I installed package via  `sudo cabal --global install attoparsec`. Now if try to profile my program with Setup.hs configure --enable-executable-profiling, it chokes on no profiling libraries for Attoparsec-(version). Is there a nice way to install profiling libraries of Attoparsec too?
16:55:01 <Cale> You're looking to see if any of the groups collected by groupBy has a tail which is not null, which means that there was more than one element
16:55:32 <temoto> (or should i issue some other command so it doesn't want profiling aware version of attoparsec? since i'm only interested in profiling of my application, not in profiling of atto)
16:55:35 <heatsink> temoto: use the -p flag wit hcabal install
16:55:39 <ksf> temoto, edit ~root/.cabal/config
16:55:42 <Cale> (the groups collected by groupBy are guaranteed to have at least one element in them, so it's safe to apply tail here)
16:56:16 <fax> ddarius, shouldn't unfoldr' be typed  (b -> Bool) -> (b -> (a,b)) -> b -> [a] -- I changed  a into (a,b)
16:56:17 <Cale> > groupBy ((==) `on` fst) [(1,4),(2,5),(1,3),(3,7),(3,9),(3,12)]
16:56:18 <lambdabot>   [[(1,4)],[(2,5)],[(1,3)],[(3,7),(3,9),(3,12)]]
16:56:21 <ksf> (is ~<user>/ syntax zsh-only?)
16:56:26 <Cale> > groupBy ((==) `on` fst) [(1,4),(2,5),(1,3),(3,7),(3,9),(3,12),(2,8)]
16:56:27 <lambdabot>   [[(1,4)],[(2,5)],[(1,3)],[(3,7),(3,9),(3,12)],[(2,8)]]
16:56:31 <Cale> see?
16:56:35 <breakspirit> Cale: what would the...prototype?  of groupBy look like
16:56:40 <Mathnerd314> is there a syntax for a one-line case?
16:56:42 <Cale> :t groupBy
16:56:43 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
16:56:51 <Cale> That's groupBy's type signature
16:56:54 <breakspirit> the part that describes the arguments and return types
16:56:56 <kmc> Mathnerd314, you mean as opposed to using indentation?
16:56:56 <breakspirit> yeah, signature
16:57:01 <Mathnerd314> kmc: yeah
16:57:03 <Cale> It takes a function for comparing two elements of the list
16:57:07 <Cale> and a list of elements
16:57:13 <kmc> Mathnerd314, indentation is just syntactic sugar for using { ; }
16:57:22 <kmc> > case True of { False -> 3; True -> 4 }
16:57:22 <ddarius> fax: That's fine too.
16:57:23 <fax> ddarius -- oh I see your correction
16:57:23 <lambdabot>   4
16:57:28 <kmc> > case True of False -> 3; True -> 4
16:57:29 <lambdabot>   4
16:57:50 <kmc> Mathnerd314, every Haskell program can be desugared to a whitespace-insensitive program
16:57:56 <Cale> and returns a list of lists produced by chopping the input list into maximal segments where f x y holds when x is the first element of a segment, and y is any other
16:58:14 <Cale> f being the comparison function you give it
16:58:37 <Cale> So in this case, we give it a function that compares the first components of the pairs
16:58:46 <Cale> just seeing if they match or not
16:58:47 <kmc> Mathnerd314, what we lack, and i've seen proposed here several times, is a nice syntax to combine lambda and case
16:58:54 <kmc> so right now you have to write "\x -> case x of ..."
16:59:04 <Cale> and it gives us a list of groups of adjacent pairs having matching first parts
16:59:05 <kmc> but one can imagine "\case of ..." or "case of"
16:59:13 <kmc> with the argument and scrutinee implicitly the same
16:59:23 <Cale> > map tail . groupBy ((==) `on` fst) $ [(1,4),(2,5),(1,3),(3,7),(3,9),(3,12),(2,8)]
16:59:24 <lambdabot>   [[],[],[],[(3,9),(3,12)],[]]
16:59:25 <fax> unfoldr' p a b = unfoldr (\x -> bool (Just (a x, b x)) Nothing (p x))
16:59:29 <fax> unfoldr m = unfoldr' (maybe True (const False) . m) (fst . fromJust . m) (snd . fromJust . m)
16:59:50 <breakspirit> thanks Cale, let me digest that
16:59:52 <fax> and inline what?
17:00:15 <ddarius> fax: And using your other type: unfoldr m = unfoldr' (maybe True (const False) . m) (fromJust . m)
17:00:18 <fax> I get what you are saying now, the bool thing sucks :P
17:00:25 <ksf> > filter (not . (== []) . tail)  . groupBy ((==) `on` fst) $ [(1,4),(2,5),(1,3),(3,7),(3,9),(3,12),(2,8)]
17:00:25 <Cale> Once we discard the first element of each group, any nonempty lists that are left are an indication that there were pairs next to each other with equal first component
17:00:26 <lambdabot>   [[(3,7),(3,9),(3,12)]]
17:00:39 <Cale> Don't use (== []), use null
17:00:50 <ksf> yep
17:00:54 <ksf> I got confused by tail
17:01:18 <ddarius> fax: Yes, notice how 1) you had to execute m twice when using unfoldr' and 2) you had to use "unsafe" functions with the fact that the usages are safe being an implicit invariant.
17:01:20 <Cale> tail is safe here because groupBy always produces a list of nonempty lists
17:01:27 <fax> yeah
17:01:33 <ddarius> fax: Contrary, using unfoldr there is no unsafe functions and no duplication of work.
17:02:16 <ddarius> fax: Such things come up often when using Bools.  Usually, a Maybe return type is more appropriate and its easy to go from Maybe to Bool if desired (via isJust/isNothing).
17:02:30 <ksf> Cale, at least I didn't write ((>1) . length)
17:02:32 <benmachine> bool (Just (a x, b x)) Nothing (p x) = (a x, b x) <$ guard (p x)
17:02:36 <Cale> ksf :)
17:02:39 * benmachine has a fondness for <$ with guard
17:02:48 <kmc> :t (<$)
17:02:49 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
17:02:50 <dons> Hmm, round numbers, haskell reddit is 8x larger than ocaml reddit. haskell irc channel is 8x large than ocaml irc channel, haskell stackoverflow questions are ~8x more frequent. is haskell 8x more popular (8x haskellers for every 1 ocamler?) (and i don't have downloads for caml hump wrt. hackage's 1.88M dls).
17:02:53 <Cale> right, that's the natural thing to write, but works out poorly with strict numbers
17:03:15 <ksf> dons, nope.
17:03:16 <ddarius> dons: Perhaps Haskellers are 8x as loud.
17:03:21 <kmc> ocamlers are 8x as french as haskellers
17:03:25 <dons> slightly more efficient use of resources has massive long term pay off.
17:03:27 <dons> ddarius: i'd say so.
17:03:27 * benmachine giggles
17:03:30 <ddarius> dons: Or it could be in part due to language effects as kmc mentione.d
17:03:38 <ksf> as ocaml is 8x more complex and thus ocamlers post 8x more questions, haskell is 64 times more popular.
17:03:54 <dons> i bet a single 'download haskell' button for a couple of years will be a long term multiplier of total users. little efficiencies paying off
17:04:14 <ksf> we're supposed to avoid success!
17:04:18 <dons> too late.
17:04:25 <fax> > 2 * sqrt(2) * (sum . map (\n->(-1)^(floor (n/2)+1)/(2*n+1)) $ [0..200])
17:04:26 <ksf> defetist!
17:04:26 <lambdabot>   -3.141575152571012
17:04:37 <benmachine> there's still time!
17:04:45 <dons> i wish the lisp or caml guys would publish dl stats for their repos.
17:04:55 <Cale> Haskell's IRC channel has more users than ##C, ##c++, #perl, and ##php, is Haskell more popular than those languages?
17:04:57 <dons> i suspect that without a 'cabal install' they'll be way way far behind.
17:05:03 <kmc> Haskell is doing a good job pushing against the stereotype that all functional languages are niche academic projects
17:05:06 <ddarius> benmachine: We could remove bottom from the language.  That would slow things down quite a bit.
17:05:11 <dons> Cale: right, you have to find "similar" communities
17:05:15 <kmc> Ocaml still fits the stereotype in a lot of ways, even though it's actually industrially relevant
17:05:36 <kmc> i mean the main page has the name of a school in its domain name
17:05:38 <temoto> @quot community
17:05:38 <lambdabot> dons says: [In reference to <joelr1> did you guys know that #ocaml has 37 members and #erlang has 34 vs. 202 on #haskell?] I think part of the #haskell success comes from the approach that we all
17:05:38 <lambdabot> know each other, it's not a homework channel like #java. We created a community of peers, working on the overall goals of the community. That's why people keep coming back
17:05:42 <fax> I think we need to collect everyone from #haskells views about what about make the language better
17:05:56 <fax> like I would say "remove if/then/else" and other people would say other things
17:06:03 <fax> it would be interesting to read this collected
17:06:44 <kmc> i've seen some reddit threads about this
17:06:45 <ksf> finally solving the expression problem
17:06:45 <kmc> dons had one
17:06:49 <temoto> fax, do you really think that removing a single syntax construct would make any language better/worse or was it just an abstract example?
17:06:52 <EvanR> whats wrong with if then else
17:06:57 <Mathnerd314> > let adjacent (a:(b:xs)) = (a,b) : adjacent (b:xs); adjacent [b] = []; adjacent [] = [] in let correct ((a,b),(c,d)) = (a,b) == (1,2) && (c,d) == (1,3) in foldl' (||) False (map correct (adjacent [(1,1),(1,2),(1,3)]))
17:06:58 <lambdabot>   True
17:06:59 <kmc> EvanR, it's special syntax and doesn't need to be
17:07:10 <ksf> EvanR, it can't be curried
17:07:10 <kmc> the proper solution is to add mixfix and then put if_then_else_ into Prelude
17:07:12 <Mathnerd314> ^ breakspirit
17:07:27 <breakspirit> what?
17:07:37 <breakspirit> oh, didnt see it
17:07:44 <ddarius> Mathnerd314: foldl' (||) False is horrible and also corresponds to a better implemented function 'or'
17:07:48 <ddarius> @src or
17:07:48 <lambdabot> or    =  foldr (||) False
17:07:50 <ksf> mixfix still needs research, though
17:07:58 <ksf> ...at least if agda is state of the art
17:07:58 <ddarius> ksf: Really?
17:08:02 <temoto> Could anyone please take a look how to enhance speed of this parser ?  http://codepad.org/TdBA1o7n
17:08:03 <ddarius> ksf: It isn't.
17:08:06 <Mathnerd314> > let adjacent (a:(b:xs)) = (a,b) : adjacent (b:xs); adjacent [b] = []; adjacent [] = [] in let correct ((a,b),(c,d)) = (a,b) == (1,2) && (c,d) == (1,3) in or (map correct (adjacent [(1,1),(1,2),(1,3)]))
17:08:07 <lambdabot>   True
17:08:14 <kmc> if / then / else is also overused by beginners
17:08:21 <ksf> at the very least, parens need to be treated specially
17:08:27 <Cale> You can also write  adjacent xs = zip xs (tail xs)
17:08:42 <ksf> I can't stand things like [ [ 1 + 2 ] * [ 2 + 3 ] ]
17:08:56 <ddarius> @quote zip`ap`tail
17:08:56 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
17:08:56 <Cale> ksf: what?
17:08:58 <ksf> It's supposed to be [[ 1 + 2 ] * [ 2 + 3 ]]
17:09:05 <Cale> oh
17:09:06 <ksf> ...so [[ has to be disallowed.
17:09:12 <Cale> Talking about mixfix?
17:09:16 <ksf> yep
17:09:19 <Aristid> :t zip `ap` tail
17:09:20 <lambdabot> forall b. [b] -> [(b, b)]
17:09:33 <Cale> > zip`ap`tail $ [1,2,3,4,5]
17:09:34 <lambdabot>   [(1,2),(2,3),(3,4),(4,5)]
17:09:35 <ddarius> ksf: Does Agda let you overload juxtaposition?
17:09:42 <Saizan> i like [[_]] for interpretation functions
17:09:56 <ksf> nope
17:10:02 <Aristid> @src ap
17:10:02 <lambdabot> ap = liftM2 id
17:10:11 <breakspirit> mathnerd314: how might one implement that as adjacent being a function?
17:10:12 <Cale> ksf: I was moderately confused by the multiplication of two lists
17:10:13 <ksf> Saizan, use [|_|]
17:10:25 <ddarius> ksf: In the OBJ languages, or at least OBJ3, you can write stuff like: _ _ : A -> List A -> List A
17:10:30 <Aristid> :t liftM2
17:10:31 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
17:10:55 <Saizan> ksf: \[[ \]] if i must
17:10:57 <Mathnerd314> > zip`ap`tail $ []
17:10:58 <lambdabot>   []
17:11:07 <Mathnerd314> since when was tail total?
17:11:16 <ddarius> It isn't.  It never gets executed.
17:11:23 <kmc> > tail []
17:11:23 <ksf> so we make ' ' a typeclass function?
17:11:24 <lambdabot>   * Exception: Prelude.tail: empty list
17:11:25 <ddarius> Welcome to a lazy language.
17:11:34 <Mathnerd314> oh...
17:11:41 <benmachine> ksf: that would be... odd.
17:11:51 <Cale> @src zip
17:11:51 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
17:11:52 <lambdabot> zip _      _      = []
17:12:34 <kmc> aztec gods aside, i prefer zip <*> tail
17:12:35 <Cale> So, zip [] (tail []) doesn't match the first pattern since [] doesn't match (a:as), and the expression evaluates to []
17:12:36 <kmc> :t zip <*> tail
17:12:37 <lambdabot> forall b. [b] -> [(b, b)]
17:12:48 <ddarius> map f $ zip xs ys === zipWith (uncurry f) xs ys
17:12:54 <benmachine> > zip (tail []) [] -- however
17:12:55 <lambdabot>   * Exception: Prelude.tail: empty list
17:13:19 <Mathnerd314> @type ap
17:13:20 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
17:13:22 <Mathnerd314> @type (<*>)
17:13:22 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
17:13:26 <benmachine> that sort of asymmetry always bothered me but I never worked out a way to do anything about it
17:13:28 <ksf> benmachine, unamb
17:13:38 <kmc> heh
17:13:40 <benmachine> ksf: yes because I want to be secretly forking threads all the time
17:13:47 <kmc> it's a secret!
17:13:58 <benmachine> well, it kind of is :P
17:14:16 <idnar> hasn't someone come up with a better unamb implementation?
17:14:17 <ddarius> benmachine: Add zip [] [] = [].
17:14:28 <kmc> in GHC Haskell you can fork like 1000 threads and not notice
17:14:33 <benmachine> ddarius: that won't work, because it tries to match (tail []) against []
17:14:34 <Cale> Yeah, it might be nice if the evaluator would first check the arguments which were already in weak head normal form before forcing evaluation in order to determine if there's a match.
17:14:40 <Mathnerd314> > let adjacent = zip <*> tail in let correct ((a,b),(c,d)) = (a,b) == (1,2) && (c,d) == (1,3) in or (map correct (adjacent [(1,1),(1,2),(1,3)]))
17:14:41 <lambdabot>   True
17:14:54 <ddarius> benmachine: Yes.  It makes zip xs undefined === zip undefined xs
17:15:24 <benmachine> ddarius: well, asymmetric strictness is easy
17:15:29 <benmachine> asymmetric laziness is not
17:15:35 <benmachine> Cale: could that ever change the meaning of programs?
17:15:37 <benmachine> errr
17:15:40 <ddarius> benmachine: I think you want "symmetric"
17:15:42 <benmachine> yes
17:15:46 <benmachine> sorry
17:15:51 <benmachine> I knew what I meant :P
17:15:57 <Cale> benmachine: it could, but it would only make more programs terminate
17:16:30 <ddarius> It would foil some uses of error and such.
17:16:36 <benmachine> foil?
17:16:38 <Mathnerd314> > let adjacent = zip <*> tail in let correct = (==((1,2),(1,3))) in or (map correct (adjacent [(1,1),(1,2),(1,3)]))
17:16:39 <lambdabot>   True
17:16:43 <ksf> I think we could use a haskell implementation which focuses on extensibility and hackability
17:16:44 <ddarius> @wn foil
17:16:45 <benmachine> it depends what you expect
17:16:45 <lambdabot> *** "foil" wn "WordNet (r) 2.0"
17:16:45 <lambdabot> foil
17:16:45 <lambdabot>      n 1: a piece of thin and flexible sheet metal; "the photographic
17:16:45 <lambdabot>           film was wrapped in foil"
17:16:45 <lambdabot>      2: anything that serves by contrast to call attention to
17:16:47 <lambdabot> [16 @more lines]
17:16:52 <benmachine> ddarius: yes I know what it means :
17:16:53 <benmachine> :P
17:16:54 <ksf> interpreted only, written in haskell etc.
17:16:59 <benmachine> (neither of those, naturally)
17:17:18 <benmachine> I was questioning it's use as if someone calling error *wants* the program to crash
17:17:40 <benmachine> I don't see it like that -- to me it's more "I hope you never have to do this, because if you do I can't help"
17:17:52 <kmc> ksf, what about uhc?
17:18:08 <ksf> ...at the very most being able to compile to h98 code using an interpreter
17:18:23 <monochrom> "if you do, I can't help but crash the program"
17:18:49 <benmachine> monochrom: yeah, so anyone calling error would be pleased to have that not forced, imo
17:18:56 <ksf> kmc, I've never looked at the source
17:19:16 <EvanR> i would rather the program crash than, say continue with a random value
17:19:30 <Mathnerd314> > let adjacent = zip <*> tail in let correct a u o = (==((a,u),(a,o))) in let answer f x = or (map f (adjacent x)) in answer (correct 1 2 3) [(1,1),(1,2),(1,3)] -- breakspirit
17:19:31 <lambdabot>   True
17:19:31 <Cale> EvanR: yeah, but this is more subtle than that
17:19:36 <monochrom> If the program doesn't crash, if it runs some code normally, but clearly with wrong data now, it may write wrong things into important files as opposed to leave files with old but valid data.
17:19:37 <benmachine> EvanR: oh of course, but I'd much rather the program found a way of continuing without any value at all
17:19:46 <benmachine> (found a way of not needing one)
17:20:04 <kmc> cool, uhc has partial type signatures
17:20:09 <benmachine> neat
17:20:10 <kmc> f :: (forall a. a -> a) -> ...
17:20:14 <ksf> ...but no hackage release
17:20:17 <ddarius> Mathnerd314: As I said earlier, map f (zip xs ys) === zipWith (uncurry f) xs ys.  Alternatively, or . map p === any p
17:20:31 <kmc> and it lets you write in unification variables
17:20:34 <breakspirit> must be honest, im not sure what any of that does, Mathnerd314
17:20:49 <Mathnerd314> breakspirit: 'tis the goal :-)
17:21:20 <benmachine> kmc: hmm, if I was making a mechanism for partial types, I'd just have a way of saying "type may be a specialisation of this one"
17:21:24 <monochrom> There is usually no such thing as "not need one", apart from either crashing or nop. Perhaps you can argue for nop.
17:21:32 <benmachine> like you could do, length :: String -> a
17:21:38 <EvanR> continuing 'not needing a value' is what javascript does, broken code often returns undefined, and many functions do not fail on undefined, and instead return undefined
17:21:45 <kmc> uhc lets you write "String -> %a"
17:21:46 <benmachine> and it'd get you length :: String -> Int
17:21:50 <kmc> for this purpose
17:21:50 <benmachine> oh right
17:21:55 <breakspirit> would i put that into a function that takes the list as its argument?  im not good enough with haskell to know how to correctly implement such code
17:21:57 <benmachine> awesome, then
17:22:00 <kmc> the % indicates that it's not to be quantified over
17:22:02 <Cale> Mathnerd314: I think you might not have understood the problem that he was trying to solve... I think he just wanted to determine if there were two pairs next to each other in the list which had the same first component.
17:22:10 <kmc> that's why i called it a "unification variable" although i'm not sure that's correct
17:22:31 <Cale> breakspirit: Is that right?
17:22:42 <breakspirit> thats true, Cale, and i need to remove said pairs from the list until the list is empty and if that empties the list, return true
17:22:44 <monochrom> is "unification variable" the same as "rigid variable"?
17:22:54 <breakspirit> if theres still junk in the list thats not pairs as described, then return false
17:22:58 <ddarius> monochrom: No.  It's arguably the opposite.
17:22:59 <kmc> monochrom, i thought they were opposite
17:23:12 <monochrom> alright
17:23:21 <kmc> the result of unification is a map from unification variables to types
17:23:24 <breakspirit> i could write that function in C++ in like 20 minutes, but haskell is so alien to me
17:23:26 <monochrom> "liquid variable" haha
17:23:27 <Cale> breakspirit: ah, okay
17:23:39 <ddarius> monochrom: There are fluid variables in Scheme.
17:23:47 <Mathnerd314> breakspirit: yay for misinterpretation :-) I thought a, u, and o in your problem were given
17:23:49 <ddarius> But they are something else entirely.
17:24:03 <monochrom> "floppy variable"
17:24:09 <breakspirit> sorry i may have explained poorly
17:24:09 <kmc> breakspirit, if you can give me a spec of the function i'll help you write it
17:24:13 <EvanR> breakspirit: and you could probably figure out how to write it in haskell in 20 minutes, you would just be typing less of the time ;)
17:24:24 <breakspirit> haha, im sure thats true
17:24:26 <Twey> breakspirit: An example of input and output is often a good way to describe a function.
17:24:30 <ddarius> monochrom: How 'bout "flabby"?  There are flabby sheaves.
17:24:36 <Cale> breakspirit: Well, better not to think in terms of removing them, I think.
17:24:38 <Twey> At least as a starting-point.
17:24:46 <kmc> Twey, and a good way to start writing QuickCheck tests :)
17:24:48 <breakspirit> ok, let me try to explain a bit better what exactly im attempting
17:24:53 <Twey> kmc: Indeed :Ã¾
17:25:04 <Cale> breakspirit: Instead, as you read from left to right across the list, build up a stack of items that you're looking to match
17:25:05 <monochrom> I like all names.
17:25:13 <breakspirit> i have a function whos signature is checkTripcode :: [(Char,Char)] -> Bool
17:25:46 <Cale> breakspirit: if the thing that you're looking for matches the top of the stack (which is just the head of a list), then you remove the item from the stack and proceed with the next entry
17:26:02 <Cale> breakspirit: otherwise, you *add* the element to the stack and proceed with the tail of the list
17:26:05 <Cale> yeah?
17:26:32 <Cale> So you have two parameters: the stack, and the list of items which you're looking to match
17:26:34 <breakspirit> the input is a list of tuples that are such that the first item could be anything and the second item will always be either o or u.  so, [...(h, o), (x, u)...]  could be valid input, but should return false because the h != x
17:26:43 <ksf> > zip`ap`tail . zip "abcd" "abbd"
17:26:44 <lambdabot>   Precedence parsing error
17:26:44 <lambdabot>      cannot mix `Control.Monad.ap' [infixl 9] and ...
17:26:51 <kmc> breakspirit, by "o or u" you mean the literal Char 'o' or 'u'?
17:26:52 <ksf> > (zip`ap`tail) . zip "abcd" "abbd"
17:26:53 <lambdabot>   Couldn't match expected type `[b]'
17:26:54 <lambdabot>         against inferred type `(GHC.Type...
17:27:00 <breakspirit> thats correct, kmc
17:27:02 <ksf> > (zip`ap`tail) $ zip "abcd" "abbd"
17:27:03 <lambdabot>   [(('a','a'),('b','b')),(('b','b'),('c','b')),(('c','b'),('d','d'))]
17:27:09 <kmc> breakspirit, if that's the case you should probably use a type which is limited to those values
17:27:18 <kmc> data Code = CodeO | CodeU
17:27:25 <kmc> (pick better names since you know what they mean)
17:27:27 <Cale> breakspirit: Let's ignore the second components of the pairs for now
17:27:41 <Cale> breakspirit: Something like [1,2,3,3,2,1] should give True, yes?
17:27:42 <breakspirit> i think i prefer to stick with Char, only to keep things simpler in my head  =)
17:27:43 <kmc> breakspirit, in Haskell it's all about choosing types to eliminate at compile time as much invalid data as you can
17:27:54 <ksf> :t all
17:27:55 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
17:28:05 <ksf> > all (== ) (zip`ap`tail) $ zip "abcd" "abbd"
17:28:06 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
17:28:06 <lambdabot>         against inferred type ...
17:28:07 <Cale> breakspirit: Or in terms of Char, something like "abccbadd"
17:28:10 <ksf> > all (== ) . (zip`ap`tail) $ zip "abcd" "abbd"
17:28:11 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
17:28:11 <lambdabot>         against inferred type ...
17:28:14 <Cale> breakspirit: yes?
17:28:17 <kmc> breakspirit, Haskell types are not for specifying machine representation.  they are for specifying and proving properties of program semantics
17:28:18 <breakspirit> Cale, it would need to be a list of tuples.  if those were tuples, that should actually return false
17:28:28 <kmc> but okay
17:28:28 <ksf> > all (uncurry (==))  . (zip`ap`tail) $ zip "abcd" "abbd"
17:28:29 <lambdabot>   False
17:28:33 <kmc> you can make the change later :)
17:28:35 <Cale> breakspirit: I'm just talking about the first components, since they're all that we're looking at
17:28:35 <ksf> > all (uncurry (==))  . (zip`ap`tail) $ zip "abbd" "abbd"
17:28:36 <lambdabot>   False
17:28:45 <breakspirit> [...(x, o), (x, u)...] would return true
17:28:46 <ddarius> ksf: any
17:28:51 <ksf> > any (uncurry (==))  . (zip`ap`tail) $ zip "abbd" "abbd"
17:28:52 <lambdabot>   True
17:28:54 <Cale> breakspirit: We don't seem to be concerned at all with the second component of any pair here, right?
17:29:00 <ksf> I'm also not sure whether that's the right comparison
17:29:13 <ddarius> ksf: It isn't.
17:29:17 <Cale> breakspirit: You said that we would delete adjacent pairs of equal elements from the list
17:29:19 <ksf> ...but to check consecutive things, use zipaptail
17:29:24 <Cale> breakspirit: and continue to do so
17:29:40 <Cale> breakspirit: and if we eventually empty the whole list, we return True, and if we can't then False, right?
17:29:41 <breakspirit> thats true
17:29:50 <breakspirit> thats correct
17:29:57 <fax> I'm really frustrated because I've got this great program I want to write but I just cant do it because I don't know how to write a program that doesn't collapse after a million lines of code
17:30:02 <Cale> So with "abccbadd", we would go to "abba" and then "aa" and then ""
17:30:07 <breakspirit> the actual VALUE of the first component of each tuple doesnt matter, as long as theyre equal in adjacent tuples
17:30:08 <Cale> and so it should be True, yes?
17:30:16 <ddarius> fax: Make sure you program doesn't go beyond a million lines of code.
17:30:24 <ksf> > map (uncurry ((==) `on` fst))  . (zip`ap`tail) $ zip "abbd" "abbd"
17:30:25 <lambdabot>   [False,True,False]
17:30:31 <kmc> fax, write all your code on one line
17:30:34 <ddarius> fax: I've never come anywhere close to needing a million lines of code in any program I've written.
17:30:53 <benmachine> fax: I think with big projects you just have to accept that it's never going to be easy
17:30:57 <breakspirit> Cale, the tuples need to be adjacent in the list
17:31:00 <Cale> (besides, since the result is a Bool in the end anyway, the actual second components of the entries in the list don't matter, and we can just map fst before applying our function.
17:31:03 <benmachine> fax: just do stuff and then fix it and then fix it some more
17:31:05 <breakspirit> for them to be removed
17:31:11 <Cale> breakspirit: right...
17:31:27 <Cale> breakspirit: So in "abccbadd", we have cc and dd which are adjacent.
17:31:35 <bremner> @hoogle liftM
17:31:35 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
17:31:35 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
17:31:35 <lambdabot> Control.Monad liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
17:31:47 <breakspirit> incorrect, they are not next to each other in the list
17:31:51 <Cale> huh?
17:31:59 <breakspirit> thats how i mean adjacent, sorry if im misusing the word
17:31:59 <Mathnerd314> breakspirit: so "check [(*,'o') ,(*,'u')]" is true, and "check [(*,'o') ,(*,[^u])]" is false?
17:32:02 <Cale> c is next to c
17:32:05 <Cale> d is next to d
17:32:36 <breakspirit> Cale: (C, u), (C, o) would be true and adjacent
17:32:41 <breakspirit> that may be what you mean
17:32:41 <ksf> I think c is next to b and d
17:32:51 <kmc> breakspirit, i think Cale is just writing the first letter of every pair
17:32:56 <kmc> since the second does not matter
17:32:57 <breakspirit> ah, i see
17:32:59 <breakspirit> then he is correct
17:33:01 <Cale> right
17:33:03 <breakspirit> my mistake
17:33:22 <breakspirit> mathnerd314: not sure what [^u] represents
17:33:22 <Cale> Since we're *totally* unconcerned with the second part of each pair, let's just map fst and be done with them
17:33:38 <Mathnerd314> breakspirit: character other than 'u'
17:33:43 <Cale> Or does it actually somehow matter what the second component of the pairs are?
17:33:56 <breakspirit> pair meaning tuple?
17:34:03 <Cale> 2-tuple specifically
17:34:05 <kmc> breakspirit, a pair is a tuple of size 2
17:34:07 <ksf> > filter (==) . zip`ap`tail $ "abccbadd"
17:34:08 <breakspirit> ah, let me think
17:34:08 <lambdabot>   Precedence parsing error
17:34:08 <lambdabot>      cannot mix `L..' [infixr 9] and `Control.Mona...
17:34:15 <ksf> > filter (==) . (zip`ap`tail) $ "abccbadd"
17:34:16 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
17:34:16 <lambdabot>         against inferred type ...
17:34:37 <ksf> :t filter
17:34:38 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
17:34:45 <breakspirit> second part of each pair is important because  if they're both o or both u, then that is not to be removed
17:34:47 <ksf> > filter (uncurry (==)) . (zip`ap`tail) $ "abccbadd"
17:34:48 <lambdabot>   [('c','c'),('d','d')]
17:34:49 <breakspirit> only if one is o and one is u
17:34:53 <Cale> The natural algorithm here I think is just to do simple recursion, maintaining a stack of which letters have been unpaired
17:34:58 <ksf> > filter (uncurry (/=)) . (zip`ap`tail) $ "abccbadd"
17:34:59 <lambdabot>   [('a','b'),('b','c'),('c','b'),('b','a'),('a','d')]
17:35:03 <Cale> breakspirit: ah, okay
17:35:06 <breakspirit> i agree, this begs for recursion  =)
17:35:07 <Cale> Fine fine
17:35:17 <benmachine> it sounds to me a bit like bracket-parsing
17:35:18 <Cale> If we really must, then we'll pay attention to them.
17:35:25 <ksf> > map fst .filter (uncurry (/=)) . (zip`ap`tail) $ "abccbadd"
17:35:26 <lambdabot>   "abcba"
17:35:34 <ksf> er no.
17:35:35 <Cale> Okay
17:35:48 <benmachine> it's equivalent to deciding if "(([])){()}" is properly-paired
17:36:00 <benmachine> I'd do that with a stack which you pushed and popped as you traversed the list
17:36:20 <benmachine> open open open close close close open open close close
17:36:25 <Cale> So... we're going to write the function such that it takes an extra parameter: a stack of the "opening" elements that we're trying to find a matching "closing" element
17:36:37 <Mathnerd314> a fold...
17:36:46 <ksf> :t foldl
17:36:47 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
17:36:50 <benmachine> everything is a fold if you look hard enough :P
17:36:51 <Cale> Yeah, yeah, you could probably fold, but let's not do that for now.
17:37:02 <Mathnerd314> yes, yes, let's fold!
17:37:08 <breakspirit> i agree, no folds  =)
17:37:12 <kmc> 420 fold lists every day
17:37:12 <ksf> :t mapAccumL
17:37:13 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
17:37:25 <ksf> that'd work.
17:37:36 <ksf> doing a non-accumulating fold would be pure pain.
17:37:50 <Cale> breakspirit: okay, so let's take care of the really simple cases:  match [] []
17:37:58 <Cale> Stack is empty, string is empty
17:38:11 <breakspirit> match is the recursive function?
17:38:14 <Cale> yeah
17:38:17 <Cale> I say this looks like it should be True
17:38:17 <breakspirit> roger
17:38:24 <ksf> @let match [] [] = True
17:38:26 <lambdabot>  Defined.
17:38:38 <Cale> er...
17:38:41 <benmachine> interesting
17:38:43 <Cale> We'll have to @undefine
17:38:47 <breakspirit> if the lists start as empty, i must say that it would be false because it would never have contained matching pairs
17:38:48 <Cale> oh well
17:38:52 <ksf> Cale, I don't think so
17:38:58 <Cale> Maybe now
17:38:59 <Cale> not*
17:39:02 <benmachine> depends how @let works
17:39:15 <kmc> breakspirit, all the pairs in an empty list are matching
17:39:21 <benmachine> if it checks for validity, then appends to L.hs then it won't work, but if it appends and then checks it might
17:39:30 <breakspirit> thats true..i guess it doesnt matter either way
17:39:46 <Cale> breakspirit: It does matter, since this will be what we're recursively going to end up with
17:39:46 <kmc> breakspirit, you can always add a special case.  it will make the recursion easier if you don't add it here
17:40:08 <Mathnerd314> breakspirit: do you have a link to a description of the problem?
17:40:08 <breakspirit> Cale, im fine with empty list being true
17:40:10 <Cale> okay
17:40:26 <Cale> So, next, if the stack has some junk on it, but there's nothing left in the string...
17:40:48 <ksf> match (x:xs) "" =
17:40:50 <breakspirit> the exact problem is that i have tripcodes that describe knots as defined by reidemester moves
17:40:54 <Cale> that's got to be False, we were looking for things to match earlier stuff, and never found them
17:40:59 <breakspirit> thats what the input list describes.  knots
17:41:03 <Cale> match (x:xs) [] = ...
17:41:06 <breakspirit> like in a string
17:41:10 <ksf> @let match (x:xs) "" = False
17:41:11 <lambdabot>  Defined.
17:41:14 <breakspirit> like a shoe string kinda string
17:41:16 <benmachine> ooh, it worked
17:41:19 <Cale> It's not *actually* a string
17:41:21 <Cale> @undefine
17:41:22 <benmachine> > match [] []
17:41:23 <lambdabot>   No instance for (Text.Regex.Base.RegexLike.RegexContext
17:41:23 <lambdabot>                    ...
17:41:24 <benmachine> :(]
17:41:26 <Cale> It's actually a list of pairs
17:41:51 <ksf> :t ""
17:41:52 <lambdabot> [Char]
17:41:56 <ksf> hum.
17:42:03 <Twey> :t nubBy
17:42:03 <benmachine> @let match :: [(Char, Char)] -> [(Char, Char)] -> Bool
17:42:04 <lambdabot>  <local>:1:0:
17:42:04 <lambdabot>      The type signature for `match' lacks an accompanying bindi...
17:42:04 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
17:42:06 <benmachine> aw
17:42:12 <breakspirit> i meant that the problem describes a string as in a shoe string in the real world.  its a list of tuples that describes a real world object, a shoe string
17:42:13 <Mathnerd314> breakspirit: so the input is a list of reidermeister moves?
17:42:17 <Twey> :t groupBy
17:42:17 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
17:42:25 <Cale> breakspirit: yeah
17:42:27 <breakspirit> thats correct, Mathnerd314
17:42:40 <breakspirit> well actually, not correct
17:42:51 <Polarina> @src (=<<)
17:42:51 <lambdabot> f =<< x = x >>= f
17:42:54 <breakspirit> its a list of tuples describing the shape of the string
17:42:58 <Polarina> @src (>>=)
17:42:58 <lambdabot> Source not found. I feel much better now.
17:43:00 <Cale> breakspirit: okay, so now, finally a more interesting case
17:43:06 <breakspirit> and i have to figure out reidemeister moves that wil unknot the string
17:43:18 <siracusa> `*** Exception: Internal error: empty context in lexStdToken' -- this is a bug, isn't it?
17:43:33 <kmc> Polarina, (>>=) is a member of the typeclass named Monad.  its definition is different for each instance
17:43:38 <breakspirit> well not the exact moves, just to know if such moves are possible
17:43:43 <Cale> match ((x,Over):ss) (x,Under) = ...
17:43:43 <Polarina> kmc, :(
17:43:45 <Cale> oops
17:43:54 <kmc> @src Maybe (>>=)
17:43:54 <lambdabot> (Just x) >>= k      = k x
17:43:54 <lambdabot> Nothing  >>= _      = Nothing
17:43:59 <Cale> match ((x,Over):ss) ((x',Under):xs) | x == x' = ...
17:44:15 <breakspirit> the process ive been clumsily describing is a type I reidemeister move in a tripcode
17:44:17 <chrisdone> tweet your haskell type errors! http://www.emacswiki.org/emacs/EmacsTweetHaskellTypeErrors
17:44:19 <Twey> > null . filter (== 1) . groupBy (on (==) fst) $ [(1, 'u'), (1, 'o'), (2, 'u'), (2, 'o')]
17:44:20 <lambdabot>   No instance for (GHC.Num.Num [(a, GHC.Types.Char)])
17:44:21 <lambdabot>    arising from the lit...
17:44:33 <Cale> If we see an Under that matches the Over of the same type in our stack, we'll cancel them out and continue on:
17:44:33 <Twey> Oops
17:44:41 <Cale> match ((x,Over):ss) ((x',Under):xs) | x == x' = match ss xs
17:44:48 <Twey> > null . filter ((== 1) . snd) . groupBy (on (==) fst) $ [(1, 'u'), (1, 'o'), (2, 'u'), (2, 'o')]
17:44:49 <lambdabot>   Couldn't match expected type `(a, b)'
17:44:49 <lambdabot>         against inferred type `[(a1, ...
17:44:50 <breakspirit> i think youre on the right track, Cale
17:44:59 <benmachine> siracusa: certainly sounds like it
17:44:59 <Twey> Oh, yes, of course
17:45:00 <breakspirit> though i do not know how to implement said code
17:45:01 <ddarius> Cale already knows what the track is.
17:45:10 <benmachine> siracusa: if it's not a bug, then the fact that it sounds like one is a bug :)
17:45:11 <ddarius> Cale is writing the code.
17:45:19 <breakspirit> hehe
17:45:28 <Twey> > null . filter ((== 1) . length) . groupBy (on (==) fst) $ [(1, 'u'), (1, 'o'), (2, 'u'), (2, 'o')]
17:45:30 <lambdabot>   True
17:45:33 <Cale> Now, we probably want to do the same thing in the opposite direction as well, yes?
17:45:36 <Twey> > null . filter ((== 1) . length) . groupBy (on (==) fst) $ [(1, 'u'), (1, 'o'), (2, 'u')]
17:45:37 <lambdabot>   False
17:45:41 <Cale> match ((x,Under):ss) ((x',Over):xs) | x == x' = match ss xs
17:45:50 <Cale> good?
17:45:57 <Twey> Is this the function you want, breakspirit?  (I know Cale is walking you through it, I'm just trying to figure out your intention)
17:45:58 <breakspirit> i....think
17:46:15 <Lemmih> chrisdone: *giggle*
17:46:20 <siracusa> benmachine: but the code it is produced by is pretty simple: Language.Haskell.Exts.parseExp "}"
17:46:30 <Twey> chrisdone: Haha, what is that?  :Ã¾
17:46:38 <Cale> Now, if they *don't* match up nicely, we want to push the thing we found onto the stack and continue looking for a match for it first
17:46:52 <ksf> Cale, care to post that evaluate whnf first-thing to the h' list?
17:46:55 <breakspirit> Twey: i am trying to follow your input as well, it appears to be in line with my intentions
17:46:55 <Twey> chrisdone: Hey, that second one isn't a type error!  :Ã¾
17:47:00 <Cale> match ss (x:xs) = match (x:ss) xs
17:47:05 <Mathnerd314> breakspirit: so the first element in the pair is a "crossing identifier"?
17:47:09 <benmachine> siracusa: definitely a bug; parseExp is supposed to fail with ParseFailed on bad input
17:47:19 <Cale> and I think we're done here
17:47:37 <breakspirit> that would be correct, Mathnerd314
17:47:46 <ksf> ...patterns are semantically processed in parallel, anyway. otherwise, fallthrough wouldn't work.
17:47:58 <kmc> Cale, i think you can make the stack implicit in the call stack, can't you?  any advantage/disadvantage versus this way?
17:48:07 <ddarius> ksf: What?  No they aren't.
17:48:21 <ksf> "parallel" as in "unspecified order"
17:48:30 <Cale> kmc: uhh... maybe?
17:48:39 <Twey> ksf: What?  No they aren't.  :Ã¾
17:48:43 <ksf> ...well, at least they _could_
17:48:46 <breakspirit> Cale, im going to collect all your code posts and attempt to make compileable code from them  =)
17:48:47 <Twey> They're processed in serial
17:48:56 <Twey> They couldn't, unless overlapping patterns were illegal
17:48:57 <benmachine> left to right, top to bottom
17:49:07 <Cale> breakspirit: You'll also want something like  data Crossing = Under | Over
17:49:14 <Mathnerd314> breakspirit: couldn't you just calculate the Jones polynomial or something?
17:49:16 <ksf> ...and the left to right thing could be changed without sacrificing anything
17:49:17 <chrisdone> Twey: haha, true, a kind error!
17:49:18 <Cale>    deriving (Eq, Ord, Show)
17:49:24 <ksf> except making more programs run.
17:49:32 <Cale> Could also just use Bool or something
17:49:40 <breakspirit> Mathnerd314: i am not familiar with that...algorithm?
17:49:43 <fax> Mathnerd314: I don't think there's anything like that which works for all non-alternating knots
17:49:48 <benmachine> ksf: view patterns can refer to variables bound to their left
17:50:05 <Mathnerd314> breakspirit: you're trying to solve the unknotting algorithm? http://en.wikipedia.org/wiki/Unknotting_problem
17:50:13 <benmachine> (although I'm not sure that's a great idea)
17:50:22 <benmachine> (it's in h2010 now though :P)
17:50:26 <benmachine> (I think)
17:50:34 <chrisdone> Lemmih: I was thinking about the early haskell implementations deleting your code if you had a type error. why instead of angry try shame :)
17:50:43 <Cale> I'm actually not 100% certain about what we're doing here. I know a bit about knots, but not enough to recognise what function we're computing.
17:50:45 <benmachine> (p.s. does a complete h2010 report actually exist anywhere, or is it still just h98+deltas?)
17:50:48 <ksf> is there any sane reason why they can't refer to the right?
17:51:05 <Twey> Wow, a whole branch of mathematics I never knew existed
17:51:17 <Cale> There is a lot of mathematics
17:51:19 <ddarius> benmachine: I don't believe there will ever be such a report.
17:51:22 <benmachine> ksf: it could get messy :P
17:51:29 <fax> Twey you never heard of knot theory!
17:51:33 <Twey> Never once
17:51:33 <ksf> as in mutual recursion?
17:51:34 <fax> It's great
17:51:38 <Twey> But it looks fantastic
17:51:49 <benmachine> ksf: I was thinking that, but I guess that could actually be pretty interesting
17:52:02 <chrisdone> bitches don't know about my loeb :: Functor a => a (a x -> x) -> a x
17:52:02 <breakspirit> Mathnerd314: yes, using tripcodes and reidemeister moves
17:52:34 * ddarius doesn't know about laying claim to something that's named after someone else...
17:53:22 <benmachine> ddarius: is it believed unnecessary to have such a report?
17:53:35 <chrisdone> ddarius: *zoom*
17:53:50 <aavogt> ksf: with view patterns the left-to-right business with patterns is convenient
17:54:36 <aavogt> though the desugaring should probably allow stuff like     f ((x:) -> y) (head -> x) = y
17:55:14 <aavogt> > let f ((x:) -> y) (head -> x) = y in f [] "a"
17:55:15 <lambdabot>   Illegal view pattern:  ((x :) -> y)
17:55:15 <lambdabot>  Use -XViewPatterns to enable view patt...
17:55:31 <Cale> breakspirit: Did the code that I wrote make some amount of sense anyway?
17:55:34 <Twey> * ddarius doesn't know about laying claim to something that's named after someone else... â I call this Twey's Imperative
17:55:48 <aavogt> Cale: have you gotten my request to add -XViewPatterns to \bot?
17:55:56 * Twey seconds that request
17:55:57 <aavogt> or has that been rejected?
17:56:02 <FunctorSalad> pardon, what can't refer to the right in patterns? too much backlog
17:56:08 <Cale> Might be able to do that...
17:56:10 <Twey> FunctorSalad: View patterns
17:56:12 <breakspirit> Cale: i am making a pastebin of what i believe i would write into my .hs file using your code, for your approval  =)
17:56:19 <Cale> okay
17:56:33 <Twey> f x (g x -> y) = â¦ -- valid
17:56:39 <Twey> f (g x -> y) x = â¦ -- invalid
17:56:40 * ddarius would seek the compiler and tests approval.
17:56:40 <aavogt> yes
17:56:48 <kmc> wow, CUFP has a new fancy commercial-ish website
17:56:51 <benmachine> in general if we want to change stuff about lb, should we be darcs sending?
17:56:52 <kmc> and a logo
17:56:55 <benmachine> or just harassing Cale?
17:56:56 <aavogt> Twey: is the second variation actually invalid?
17:56:58 <chrisdone> kmc: link pls
17:57:05 <kmc> http://cufp.org/
17:57:07 <ddarius> benmachine: It depends on what you want to change.
17:57:12 <kmc> maybe it's not new, but i don't remember seeing it before
17:57:21 <chrisdone> kmc: wow, that's nice
17:57:22 <Cale> It might work better if you send me patches...
17:57:33 <aavogt> @help
17:57:33 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:57:37 <benmachine> ddarius: I just wanted to establish if darcs send is a viable option in any case
17:57:39 <aavogt> @src
17:57:39 <lambdabot> src <id>. Display the implementation of a standard function
17:57:40 <Cale> I'm happy to make small changes though
17:57:47 <aavogt> @list
17:57:47 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
17:57:51 <FunctorSalad> Twey: heh, I had no idea the former was legal
17:57:57 <Twey> aavogt: Yes
17:58:04 <Twey> aavogt: âNot in scopeâ error
17:58:30 <breakspirit> http://pastebin.com/3BZn5TG8  theres what i got out of all that, minus a signature and the stuff you said to make at the end
17:58:31 <aavogt> aww, c.h.o is still down
17:58:33 <Twey> kmc: Ooh, pretty
17:58:34 <FunctorSalad> (looks too much like nonlinear patterns, which of course you could shoehorn into that form)
17:58:35 <benmachine> @source
17:58:35 <lambdabot>  not available
17:58:41 <benmachine> umm
17:58:57 <FunctorSalad> f x ( (== x) -> True) = "same"
17:59:02 <dons> kmc: damn straight
17:59:19 <dons> commercial haskell is bringing it. :)
17:59:45 <Mathnerd314> breakspirit: the fact that it's NP seems to me to mean that it will have an ugly solution :-/
17:59:46 <dons> "Big FP".
17:59:57 <Cale> hehe, it's several people's code mixed together...
18:00:02 <breakspirit> i agree, Mathnerd314.  it is quite a problem
18:00:29 <Cale> I'll fix it
18:00:49 <breakspirit> haha i know, it got hard to follow along after awhile
18:01:19 <breakspirit> i want to say i really appreciate everyone's help with this, you guys are great
18:01:54 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24632#a24632
18:02:40 <Cale> So, the first two lines there say that if we get to the end, the result is determined by whether there's anything left to match on the stack
18:02:41 <breakspirit> whoa, it compiled  =)
18:03:16 <Cale> If you want, you can replace Under with U and Over with O... might be easier to type things in that way
18:03:19 <breakspirit> would the signature be the same as the one i had written?    match :: [(Char,Char)] -> Bool
18:03:38 <Mathnerd314> breakspirit: try running :t match
18:03:51 <Cale> match :: (Eq a) => [(a,Crossing)] -> [(a,Crossing)] -> Bool
18:03:59 <breakspirit> good idea, Mathnerd314  =)
18:04:06 <Cale> and then to get the function you're after, we just plug in an empty initial stack
18:04:50 <fax> what the heck is this homotopy lambda calculus
18:04:52 <fax> stuff
18:04:54 <fax> I have no idea
18:05:01 <Cale> fax: I wish I had more information about it.
18:05:12 <Cale> fax: It's something that Voevodsky is working on, apparently.
18:05:42 <fax> I think I'd have to master category theory and synthetic (?) topology to even start to follow that stuff
18:06:25 <breakspirit> thanks again, Cale, im attempting to digest all that
18:06:49 <Cale> The extremely fuzzy idea/hope for it is that it would provide a practical foundation for mathematics which would allow for the right sort of polymorphism to take care of all the sorts of equivalences we normally take for granted in mathematics.
18:07:07 <Cale> But I haven't the slightest clue what it's about beyond that.
18:07:24 <fax> I wonder what equivalences that means
18:07:32 <fax> sounds cool though
18:07:56 <fax> maybe stuff like associativitity of pairs
18:07:57 <Cale> fax: I think things like identifying the rationals with a subset of the reals, and so on.
18:08:02 <fax> oh
18:08:26 <Cale> Like if you prove something about the rationals, it's "obvious" that you've also proved that thing about the particular subset of the reals
18:08:48 <Cale> But formally, you'd need a bunch of tedious garbage to apply the equivalences etc.
18:08:53 <fax> yeah
18:09:08 <FunctorSalad> it's equivalences all the way down
18:09:22 <fax> yes it is :(
18:10:26 <Cale> So this prevents mathematicians from actually using their own formalisms directly
18:10:36 <turiya> hi
18:10:44 <SamB_XP> cowards!
18:10:46 <FunctorSalad> (thinking of higher groupoids there)
18:10:52 <turiya> can someone tell me what "$=" means
18:10:58 <kmc> @hoogle ($=)
18:10:58 <lambdabot> No results found
18:11:06 <kmc> turiya, it's an operator defined in the OpenGL libraries (and elsewhere?)
18:11:09 <dankna> turiya: are you using OpenGL in Haskell by chance?
18:11:09 <kmc> is that what you're using?
18:11:09 <Cale> So, from what I've heard, Voevodsky (who is a smart guy) thinks that this homotopy lambda calculus can be an actually practical and non-tedious formalism.
18:11:11 <breakspirit> Cale, im having trouble understanding how to call the match function from main or another master function
18:11:13 <Cale> But I don't know how it works.
18:11:26 <turiya> it is in GLUT
18:11:34 <breakspirit> i believe it needs to be called from a function that will give it the list
18:11:36 <kmc> turiya, within OpenGL it's used to assign to various stateful variables within the IO monad
18:11:36 <Twey> turiya: It's an operator in the OpenGL bindings used for the assignment of various settings
18:11:41 <kmc> specifically, IORefs, and OpenGL-internal state
18:11:50 <Cale> breakspirit: try something like   match [] [('a',Under), ('b',Over), ('b', Under), ('a', Over)]
18:11:58 <Cale> breakspirit: just at the ghci prompt for now
18:12:04 <breakspirit> ah okey
18:12:07 <kmc> turiya, it's from this library: http://hackage.haskell.org/packages/archive/StateVar/1.0.0.0/doc/html/Data-StateVar.html
18:12:19 <kmc> see the class HasSetter
18:12:23 <Cale> breakspirit: The [] there is the initial state of the stack that we were using
18:12:28 <breakspirit> yeah
18:12:44 <krasno> hi random omegling buddy.
18:12:45 <breakspirit> ive got an input file with a list of tuples to test, was wanting to try it on that
18:12:45 <james_> lol
18:12:50 <james_> hahaha
18:12:56 <Twey> krasno: I'm sorry?
18:13:05 <james_> he's referring to me
18:13:10 <breakspirit> ive got the input file reading correctly, just a matter of calling the match function
18:13:21 <Cale> turiya: I believe it's variable assignment for the StateVar variables that come with that library.
18:13:46 <turiya> initialWindowSize $= windowSize
18:13:47 <Cale> breakspirit: ah, okay
18:13:54 <fax> http://maths.wordpress.com/2006/04/10/voevodsky-homotopy-lambda-calculus-proof-checkers-and-formalising-pure-maths/
18:13:56 <turiya> it is being used in such form
18:13:56 <Cale> breakspirit: what format is the input in?
18:14:03 <fax> This entry was posted on April 10, 2006 O_o
18:14:09 <fax> it has not been followed up
18:14:15 <breakspirit> .txt file.  want to see all my source?
18:14:21 <Cale> turiya: yeah, so that means to set the initialWindowSize state variable to the value windowSize
18:14:23 <fax> I gues it's just a random post someone copied and pasted
18:14:38 <Cale> breakspirit: Well, I mean, what does the contents of the .txt file look like?
18:15:28 <breakspirit> just lists of tuples of the described format.  some valid, some invalid.  for example, heres a line:
18:15:30 <breakspirit> [('a','o'),('a','u')]
18:15:36 <Cale> fax:  I saw a talk about it maybe about a year ago, but it was also very short on details.
18:15:41 <breakspirit> that should return true
18:15:52 <Cale> oh, okay
18:16:04 <Cale> In that case, just replace that Under and Over with 'u' and 'o'
18:16:10 <breakspirit> yeah, i did that
18:16:13 <Cale> okay
18:16:57 <turiya> Cale, initialWindowSize $= windowSize is in a do block and I cant see how this is of type IO b
18:17:03 <Cale> and then use something like   main = do xs <- readFile "input.txt"; print (match [] (read xs))
18:17:46 <Cale> ghci> :t ($=)
18:17:46 <Cale> ($=) :: (HasSetter s) => s a -> a -> IO ()
18:17:50 <Cale> turiya: ^^
18:18:04 <Mathnerd314> breakspirit: any particular reason you're using tripcodes?
18:18:07 <Cale> ghci> :t initialWindowSize
18:18:07 <Cale> initialWindowSize :: StateVar Size
18:18:33 <breakspirit> Mathnerd314: its just the input i want to deal with.  makes sense for the problem
18:18:46 <Mathnerd314> ok.
18:18:58 <Cale> So if we can assume that windowSize :: Size
18:19:19 <Cale> in  :info StateVar  we see:
18:19:24 <Cale> instance HasGetter StateVar -- Defined in Data.StateVar
18:19:24 <Cale> instance HasSetter StateVar -- Defined in Data.StateVar
18:19:28 <Mathnerd314> I need a piece of string :p
18:19:37 <fax> hehe
18:19:37 <turiya> windowSize :: Size indeed. I understand a bit now.
18:19:42 <breakspirit> hehe
18:19:45 <Cale> So StateVar is a valid 's' for the type of ($=)
18:20:04 <Cale> and so in this case, ($=) specialises to  StateVar Size -> Size -> IO ()
18:20:07 <breakspirit> Mathnerd314: were you familiar with the unknotting theory before this conversation?
18:20:11 <breakspirit> you seem to find it interesting
18:20:24 <Mathnerd314> no, but I had some people talk about knot theory
18:20:30 <Mathnerd314> *heard
18:20:42 <turiya> cale, thanks
18:20:59 <Mathnerd314> breakspirit: your problem would be "computational knot theory" :-)
18:21:06 <breakspirit> ah   =)
18:21:40 <Cale> Hmm, I liked CUFP's old logo better.
18:22:00 <Cale> Well, this one does have lambda nicely hidden in it
18:23:10 <kmc> Cale, haha, i didn't even notice
18:23:17 <kmc> it looks so corporate and respectable
18:23:28 <kmc> it's like the arrow in the fedex logo
18:23:35 <kmc> hidden but impossible to miss once you know it's there
18:23:55 <kmc> what was the old logo?
18:23:56 <Cale> The overall impact of the website looks so dreary to me though.
18:24:05 <dankna> oh hey, cute
18:24:07 <Cale> I'll see if I can find it
18:24:08 <dankna> what was the old logo?
18:24:11 <dankna> yes, it looks pretty dreary
18:24:21 <kmc> Cale, but it serves its purpose
18:24:29 <kmc> FP has always had a "damn hippies get off my lawn" problem
18:24:39 <Cale> Oh, maybe I was thinking of IHG
18:24:43 <Cale> Not CUFP
18:24:49 <Cale> yeah, that's what it is :)
18:25:04 <Mathnerd314> breakspirit: so what's the next move? find  '(a,o) (b,o)' and '(a,u) (b,u)' and remove all of them?
18:25:07 <Cale> http://industry.haskell.org/ihg-logo.png
18:25:26 <breakspirit> thats exactly right, Mathnerd314
18:25:29 <dankna> ah - that is quite a logo
18:25:40 <kmc> yeah, i like the IHG logo
18:25:42 <dankna> I don't like the gradient in the text
18:25:45 <dankna> but the rest of it is great
18:26:18 <drhodes> is there a standalone app for browsing the package & types & stuff (similar to the slick side panel in leksah)
18:26:20 <Mathnerd314> breakspirit: why do you want to do this in Haskell? XD
18:26:27 <dankna> drhodes: no :(
18:26:42 <breakspirit> haha, i guess i love pain.  would it be far easier in another language?
18:26:43 <drhodes> and the backslashes in the about \ news \ .. navigation are windows biased
18:27:00 <drhodes> dankna: ok, thanks, saves me the search then :)
18:27:02 <Cale> breakspirit: nah :)
18:27:10 <breakspirit> figured youd think that, Cale
18:27:17 <Cale> after all, it's only a few lines of code
18:27:26 <Cale> How much easier do you want it to be? ;)
18:29:43 <d-snp> hey guys, here I am again :P
18:29:45 <breakspirit> Cale: changing the Over and Under to 'u' and 'o' is giving me a parse error on input '''
18:29:50 <Cale> breakspirit: If you're used to imperative programming, it might help to think in this way: variables in Haskell don't change their value as long as they remain in scope. So if we want something to actually change as our program runs, it should be the parameter to a function.
18:29:56 <Cale> hmm...
18:30:07 <breakspirit> yeah, no side effects in haskell
18:30:08 <Cale> Did you miss a ' somewhere?
18:30:19 <breakspirit> i do not see one, lemme pastebin it
18:30:42 <d-snp> before you use pastebin, consider using pastie.org instead! to save onlookers eyes :)
18:30:43 <breakspirit> http://pastebin.com/pANPEJvw
18:30:53 <breakspirit> did not know there was a difference
18:30:54 <breakspirit> will do
18:31:01 <Mathnerd314> Cale: is x' valid haskell?
18:31:07 * Cale prefers http://hpaste.org/new
18:31:08 <Cale> :)
18:31:09 <d-snp> oh hey, pastebin has a new layout
18:31:13 <Cale> Mathnerd314: yes
18:31:21 <Cale> Mathnerd314: It is a variable
18:31:30 <Mathnerd314> maybe 'u' and x' are confusing the parser...
18:31:39 <Cale> doubt it
18:31:40 <breakspirit> http://pastie.org/902243  theres a pastie flavor
18:31:45 <Cale> oh
18:31:51 <Cale> heh, delete the data declaration
18:32:02 <Cale> 'u' and 'o' are values of type Char
18:32:07 <Cale> we don't have to define them
18:32:07 <breakspirit> haha oh yeah
18:32:21 <aavogt> it's only a character litteral if it starts and ends with an apostrophe (and doesn't contain too much stuff
18:32:22 <aavogt> )
18:32:24 <Cale> and then match's type will change too
18:32:28 <Cale> Crossing becomes Char
18:32:49 <Mathnerd314> just delete it, Haskell will infer it :-)
18:33:00 <aavogt> > let i'n't'e'r'e's't'i'n'gVariable = 1 in i'n't'e'r'e's't'i'n'gVariable
18:33:01 <lambdabot>   1
18:33:12 <breakspirit> in my experience, haskell doesnt infer ANYTHING i think it should
18:33:59 <ddarius> > let ord'x' = 120
18:34:00 <lambdabot>   not an expression: `let ord'x' = 120'
18:34:58 <dons> breakspirit: haha
18:35:03 <breakspirit> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24635#a24635  if thats the calling function of match, how do you change that to correctly call it?
18:35:04 <Cale> > let in let in let let'in = let in'let = let'in in in'let in let'in
18:35:08 <lambdabot>   mueval-core: Time limit exceeded
18:35:14 <dons> breakspirit: your expectations aren't those of Hindley or Milner :-)
18:35:31 <breakspirit> dons: that definitely appears to be the case
18:35:34 <HugoDaniel> hey dons
18:35:39 <dons> heya HugoDaniel
18:35:41 <Mathnerd314> breakspirit: checkTripCode a should be math [] a
18:35:48 <Cale> breakspirit: checkTripcode xs = match [] xs
18:35:58 <Mathnerd314> yeah!
18:35:58 <Cale> and be consistent about case
18:36:16 <breakspirit> meaning checkTripCode?
18:36:18 <HugoDaniel> dons, i managed to parallelize the vector generate using a lame method similar to the nfibs one
18:36:25 <aavogt> what isn't case-sensitive?
18:36:31 <Cale> Either  checkTripCode or checkTripcode, but not both ;)
18:36:37 <dons> HugoDaniel: woo!
18:36:39 <dons> was it faster?
18:36:59 <aavogt> > let aA = 1; aa = 2 in (aA,aa)
18:37:00 <lambdabot>   (1,2)
18:37:04 <Cale> dons: Any news about dph in 6.12?
18:37:32 <breakspirit> oh youre right, Cale, i did use both
18:37:35 <breakspirit> good eye  =)
18:37:35 <dons> sounds like roman's going to write some shootout entries in dph
18:37:40 <dons> its pretty solid now
18:37:47 <d-snp> could someone help me, I'm reading the wikipedia article about monads, and I don't get any of it :P
18:37:52 <dons> there's a paper submitted to icfp on regular parallel arrays too
18:38:02 <EvanR> d-snp: a monad is like a burrito
18:38:04 <Cale> Oh, so they've gotten past enough of the problems with the simplifier then? That's cool. :)
18:38:13 <d-snp> this is going to be good :P
18:38:13 <Cale> d-snp: Which one?
18:38:18 <Cale> d-snp: here...
18:38:24 <kmc> d-snp, ignore all the analogies
18:38:27 <kmc> @where burrito
18:38:28 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
18:38:28 <Cale> d-snp: http://www.haskell.org/haskellwiki/Monads_as_Computation
18:38:42 <d-snp> I was reading this: http://en.wikipedia.org/wiki/Monads_in_functional_programming
18:38:50 <Cale> d-snp: If you're interested in how they apply to programming, try that.
18:38:54 <kmc> d-snp, if by some chance you just want to do some IO in Haskell, understanding monads is not the useful route
18:39:02 <d-snp> ok thanks :)
18:39:09 <HugoDaniel> dons, i managed to parallelize the vector generate function using a method similar to the nfibs
18:39:19 <dons> Cale: "This video contains content from Canadian Broadcasting Corp., who has blocked it in your country on copyright grounds."
18:39:24 <Mathnerd314> kmc: how is http://www.haskell.org/haskellwiki/Hitchhikers_guide_to_Haskell ?
18:39:24 <dobblego> also, if you just want to understand monads, IO in Haskell is not the useful route
18:39:24 <kmc> you don't need to understand anything about monads in general, if you are only interested in using one monad
18:39:26 <dons> -- Canadia strikes back!!
18:39:28 <Cale> dons: haha
18:39:35 <d-snp> kmc: I'm not actually learning haskell (yet), just interested in programming concepts
18:39:40 <kmc> d-snp, cool
18:39:47 <kmc> if you're interested in programming concepts you should learn haskell ;)
18:39:56 <d-snp> I will :D
18:40:05 <Cale> d-snp: Basically, it's not a huge deal. "Monad" is just the name of a particular sort of interface that some libraries implement, and we can write code which works in all monads, making it useful.
18:40:36 <Mathnerd314> amazing how #haskell just picks up as soon as someone comes around asking about monads... :-)
18:40:39 <Cale> d-snp: A monad consists of: A parametric datatype, usually thought of as being "computations" having a "result" of the type parameter
18:40:51 <Mathnerd314> @src Monad
18:40:51 <lambdabot> class  Monad m  where
18:40:52 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
18:40:52 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
18:40:52 <lambdabot>     return      :: a -> m a
18:40:52 <lambdabot>     fail        :: String -> m a
18:40:58 <Cale> d-snp: Along with a couple extra functions
18:41:02 <Mathnerd314> d-snp: m above
18:41:06 <Cale> please ignore fail
18:41:16 <Mathnerd314> d-snp: those functions >>= and return
18:41:21 <Mathnerd314> ignore >> as well
18:41:24 <dankna> why IS fail part of it, anyway?
18:41:34 <kmc> dankna, for pattern-match failure in "do"
18:41:41 <dankna> oh, hm, okay
18:41:51 <kmc> but they should have just said that pattern-match failure in "do" is unrecoverable error, like in "let", unless the monad is an instance of MonadFail
18:41:56 <kmc> which would then contain "fail"
18:42:01 <dankna> I agree
18:42:20 <Cale> *anyway*
18:42:54 <dons> fail is an example of design fail, sadly.
18:43:01 <Cale> We have this type constructor m, and then a function: return :: a -> m a which takes a value and produces the computation which "does nothing" (whatever that means in context) except has that value as its "result"
18:43:03 <dons> no eye on the big piicture
18:43:14 <dankna> well, we aren't wedded to back compatibility, are we?  couldn't we make a language extension that removes it?  heh
18:43:26 <d-snp> the haskell.org article starts with some nice wisdom :)
18:43:41 <ddarius> kmc: That's what they -did- say.
18:43:46 <aavogt> dankna: ghc has extensions to separate do notation from the Monad class in the prelude
18:43:51 <Cale> and then what (>>=) does is a bit of a mouthful, but essentially, it takes a computation, and a function from possible results of that computation to further computations, and sticks them together in the only obvious way
18:43:51 <ddarius> kmc: See the Haskell 1.4 Report.
18:43:59 <dankna> aavogt: oh interesting, I approve, I'll look into that sometime
18:44:04 <kmc> ddarius, why was it changed then?
18:44:08 <EvanR> :t (>>=)
18:44:09 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
18:44:09 <ddarius> kmc: Insanity.
18:44:12 <Cale> and a lot of libraries fit this pattern
18:44:20 <kmc> d-snp, it might be better to think in terms of this function:
18:44:21 <kmc> :t (>=>)
18:44:22 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
18:44:41 <Cale> Like any abstraction, there are a lot of ways to look at these things
18:44:48 <breakspirit> Cale: would it be relatively painless to alter your code to return a string containing the list after all pair removals?
18:44:49 <Cale> and lots of equivalent foundations
18:45:06 <Cale> breakspirit: Well, it shouldn't be too bad...
18:45:08 <Cale> breakspirit:
18:45:10 <kmc> "m b" generalizes over concepts like "a nondeterministic choice from among many b"  or  "some b or failure"  or  "a parser producing a value of type b"
18:45:26 <kmc> and so the operator (>=>), which exists for any monad, says how we can "compose" functions that have this structure
18:45:27 <Cale> er, let me take one moment :)
18:45:36 <breakspirit> =)
18:45:43 <kmc> how we can compose parsers, or possibly-failing computations, or nondeterministic computations
18:45:47 <d-snp> I really need to learn haskell :P
18:45:53 <breakspirit> me too dude
18:46:05 <breakspirit> ive learned much this night, though
18:46:30 <breakspirit> but its one of those kind of things where the more you learn, the more you find you dont know
18:46:50 <EvanR> actually the basics of haskell are few, the complexity comes from the libraries
18:47:06 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24636#a24636
18:47:07 <breakspirit> id say thats true of many languages
18:47:13 <EvanR> some more so than others
18:47:13 <kmc> it's not true of C++ or Perl
18:47:17 <EvanR> php
18:47:20 <kmc> which have lots of built-in magic and special cases
18:47:27 <kmc> Haskell has relatively little of it
18:47:28 <Cale> So this is obviously repetitious, but there you go
18:47:30 <breakspirit> wow you whipped that of really fast Cale
18:47:38 <kmc> although understanding each GHC language extension can take a while
18:47:52 <d-snp> so the code: "m b" executes m with parameter b right?
18:47:57 <Cale> you could also write   fmap (x:) (match ss xs)  in place of that  case ... of ...
18:48:01 <kmc> d-snp, no
18:48:04 <d-snp> oh
18:48:10 <dankna> backwards.  b is the result.
18:48:12 <Cale> Nothing indicates failure
18:48:15 <kmc> d-snp, it means sort of the same thing as m<b> in C++ templates or Java generics
18:48:16 <EvanR> IO b is a command that returns type b when executed
18:48:26 <Cale> Just rs  indicates that rs is the list of removed pairs
18:48:38 <kmc> d-snp, it means that "m" is a type parametrized over another type, and we're instantiating it with the type "b"
18:48:42 <Cale> I didn't do anything to encode whether it was an o/u pair or a u/o pair
18:48:50 <d-snp> ok
18:48:52 <kmc> it uses the same syntax (within types) as used for function application (within expressions)
18:48:55 <breakspirit> Cale: signature is   match :: (Eq a) => [(a,Char)] -> [(a,Char)] -> string   ???
18:49:02 <kmc> because in a sense, a parametrized type is a "function" on types
18:49:11 <breakspirit> er, String
18:49:14 <kmc> for example, Maybe
18:49:14 <Cale> match :: (Eq a) => [(a,Char)] -> [(a,Char)] -> Maybe [a]
18:49:19 <kmc> for any type T, there's another type Maybe T
18:49:23 <kmc> :t Just 7
18:49:24 <lambdabot> forall t. (Num t) => Maybe t
18:49:27 <kmc> :t Just 'x'
18:49:28 <lambdabot> Maybe Char
18:49:34 <kmc> :t Nothing
18:49:35 <lambdabot> forall a. Maybe a
18:50:57 <d-snp> ok, since I'm an idiot and sleep is for wussies, I'm just going to learn haskell right here and now :P
18:51:01 <Cale> Maybe t is similar to Bool, with Nothing taking the place of False, and Just x for various values x of type t taking the place of True.
18:51:12 <fax> d-snp I know what you mean
18:51:29 <Cale> d-snp: Let us know if you have any questions
18:52:12 <EvanR> i tried to learn monads before data structures, so maybe made no sense to me, because it was always introduced as a monad
18:52:20 <Cale> heh
18:52:20 <fax> what's the best thing to do after galois theory and before differential galois theory?
18:52:33 <dankna> fax: have a snack
18:52:38 <fax> done :p
18:52:42 <dankna> haha
18:52:53 <kmc> EvanR, :(
18:53:15 <Cale> fax: mmm... I don't know, you could go off and do some algebraic number theory using all the Galois theory that you know
18:53:17 <aavogt> preflex: seen gwern
18:53:18 <preflex>  gwern was last seen on #haskell 4 days, 1 hour, 38 minutes and 55 seconds ago, saying: what new data could become public after the release of the ciphertext? hm
18:53:22 <EvanR> when in reality i have yet to use Maybe's monad powers ;)
18:53:43 <Cale> But that will probably be painful and scar you for life.
18:53:52 <breakspirit> Cale: i get the error "occurs check: cannot construct the infinite type: a = (a, Char) when generalising the types for 'match'
18:54:12 <breakspirit> using the signature you provided
18:54:14 <aavogt> Cale: as far as I can tell, mueval doesn't allow specifying arbitrary extensions
18:54:24 <Cale> breakspirit: er, just leave the signature out
18:54:32 <breakspirit> different error with no sig
18:54:39 <Cale> What error?
18:54:46 <Cale> oh, silly me
18:54:48 <Cale> I see it
18:54:52 <mm_freak> anything wrong with <http://community.haskell.org/>?
18:55:01 <d-snp> let villain = (23, "tinco") in fst villain <-- that wasn't explained very well, what does in fst mean? is fst short for first?
18:55:01 <mm_freak> i can connect, but it doesn't respond
18:55:11 <aavogt> mm_freak: it's the same server as code.haskell.org I believe
18:55:15 <Cale> the two stack-matching cases should be the same code
18:55:21 <Cale> I typoed the second one
18:55:24 <EvanR> d-snp: yeah
18:55:27 <breakspirit> ah  =)
18:55:30 <Cale> It should be  Just rs -> Just (x:rs)
18:55:31 <breakspirit> i forgive you
18:55:42 <EvanR> @src fst
18:55:42 <lambdabot> fst (x,_) =  x
18:55:45 <Cale> It's my fault for not doing it the right way in the first place ;)
18:55:46 <theorbtwo> d-snp: fst returns the a in (a, b) -- the first slot of the pair.
18:55:56 <theorbtwo> (Or, more generally, the
18:56:01 <mm_freak> aavogt: indeed, and both aren't responding
18:56:06 <breakspirit> you whipped that up incredibly fast, im still impressed
18:56:06 <theorbtwo> the first slot of the tupple.)
18:56:17 <aavogt> > fst (1,2,3) -- theorbtwo
18:56:18 <lambdabot>   Couldn't match expected type `(a, b)'
18:56:19 <lambdabot>         against inferred type `(t, t1...
18:56:26 <EvanR> it only works on pairs
18:56:27 <aavogt> theorbtwo: it isn't overloaded
18:56:32 <theorbtwo> Oh.  I stand corrected.
18:56:48 <theorbtwo> That seems... a bit odd.
18:56:50 <aavogt> it could be... but that wouldn't be friendly to people learning
18:56:50 <HugoDaniel> i need help speeding this up: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24637#a24637
18:56:54 <aavogt> @hackage tuple
18:56:54 <lambdabot> http://hackage.haskell.org/package/tuple
18:57:53 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24636#a24638
18:58:02 <Cale> It's of course possible to eliminate the repetition.
18:58:15 <breakspirit> Cale: to call that new match function from checkTripCode, would it be..  checkTripCode xs = match [] xs    still?
18:58:17 <Cale> and then we can actually make this even better
18:58:34 <mibygl> ...
18:58:46 <Cale> yeah
18:58:56 <mibygl> I have a directory called ~/.cabal/packages^Jdocumentation: True/
18:59:05 <Cale> breakspirit: except that now instead of producing a Bool, we're getting Maybe a list of matches
18:59:10 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24636#a24639
18:59:14 <Cale> ^^ simplified further
18:59:19 <mibygl> I think that's a really horrible name for a directory, containing a non-printable character like that.
18:59:22 <Cale> fmap is like map, but more general
18:59:36 <Cale> mibygl: lol, weird
18:59:41 <breakspirit> thanks a lot, gonna look at that
18:59:46 <Cale> mibygl: Something has gone strange
19:00:00 <Cale> breakspirit: For the Maybe datatype, we have:
19:00:04 <Cale> fmap f Nothing = Nothing
19:00:09 <Cale> fmap f (Just x) = Just (f x)
19:00:15 <mibygl> Okay, in .cabal/config, there's a line that looks like this: remote-repo-cache: /Users/tannerswett/.cabal/packages
19:00:34 <mibygl> Then there are a bunch of commented-out lines, then this: documentation: True
19:00:35 <d-snp> aww the interactive tutorial isn't finished at all :(
19:00:49 <fax> I only say 2 applications: impossibility of trisection & unsolvability of quintic
19:00:49 <Cale> d-snp: You might check out...
19:00:53 <EvanR> d-snp: that seems to be about 3 days old ;)
19:00:55 <Cale> @where lyah
19:00:55 <lambdabot> http://www.learnyouahaskell.com/
19:00:57 <fax> saw*
19:01:03 <mibygl> Oh, heh heh heh.
19:01:09 <Cale> @where rwh
19:01:09 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
19:01:13 <Cale> @where wikibook
19:01:13 <lambdabot> http://en.wikibooks.org/wiki/Haskell
19:01:14 <fax> hm squaring the circle as well
19:01:15 <mibygl> The documentation line is indented farther than the remote-repo-cache line.
19:01:20 <Cale> @where yaht
19:01:20 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
19:01:34 <mibygl> That was very... pathological.
19:01:45 <ddarius> fax: Those are just well-known examples.
19:02:00 <fax> yes :p
19:02:21 <fax> I have only really worked through one set of notes
19:02:54 <ddarius> fax: There's an online book by Robert Ash about abstract algebra that includes a chapter on algebraic number theory.
19:03:17 <fax> thanks I will check it out
19:03:26 <ddarius> It's okay (as a book on abstract algebra).  I wouldn't say it's great.
19:03:42 <breakspirit> Cale: so lets say i have a master function that has arguments of a list of tuples and returns a string which is the remaining list and that function then calls match, would would i convert my list that match returns into a string?
19:04:04 <mibygl> Perhaps we should add some sort of sanity check to cabal to try to prevent this stuff from happening.
19:04:34 <breakspirit> would would = how would  =/
19:04:47 <ddarius> fax: Oh, and apparently he has a course on just alegbraic number theory.  Though those may be the "notes" you were looking at before.
19:05:23 <ddarius> fax: You probably already have this but here's the link: http://www.math.uiuc.edu/~r-ash/
19:05:30 <fax> no this is new to me
19:06:21 <fax> this is my notes http://projecteuclid.org/euclid.ndml/1175197041
19:06:24 <EvanR> breakspirit: you want to convert a list of what into a string?
19:06:47 <Cale> breakspirit: by applying show to it
19:06:51 <breakspirit> the list of tuples returned by the match function written by Cale
19:07:16 <Cale> breakspirit: Or just print it with 'print' as you've been doing
19:07:23 <breakspirit> show ( unknotMatch [] xs ) ?
19:07:28 <Cale> breakspirit: The rest of your program shouldn't have to change.
19:07:43 <Cale> breakspirit: at least, if you still have the main function that I gave you
19:07:58 <breakspirit> im using a different main, so ive been using master functions to call the match function
19:08:03 <breakspirit> seemed easier to implement
19:08:20 <d-snp> hmm, values in haskell are immutable right? they just go into functions and other values come out?
19:08:47 <fax> yes
19:08:48 <ddarius> d-snp: A value is a value.  3 is 3.  It makes no sense to "mutate" 3.
19:08:54 <kmc> values anywhere are by definition immutable
19:08:58 * ManateeLazyCat pasted "Problem" at http://paste2.org/get/755514
19:08:59 <ManateeLazyCat> I occur above involved problem when update gtk2hs APIs, someone help me look? I have write detail at above.
19:09:05 <kmc> in most languages, a variable is a name for a *cell*, not a value
19:09:18 <kmc> i would argue that any language with "mutable values" is grossly misusing the term "value"
19:09:31 <aavogt> except?
19:09:33 <theorbtwo> d-snp: As I understand it, yes, though there are sometimes things that fake it rather well.
19:09:46 <kmc> d-snp, in Haskell, a variable is a name for a value.  however, certain values are names for cells
19:09:51 <kmc> such as IORef
19:10:00 <SamB_XP> kmc: just like almost every language using the term "statement" is grossly misusing that, yeah ...
19:10:00 <kmc> so it's not fair to say "Haskell has no mutable state" as some do
19:10:11 <EvanR> kmc: i run into exactly this problem in javascript all the time. objects and arrays i consider to be my values mutate from under me all the time because some other entity has a reference
19:10:30 <kmc> yeah,  in most languages you cannot create a persistent value except by convention
19:10:40 <ManateeLazyCat> d-snp: In Haskell, every variable is pure, you can change it after create it.
19:10:40 <kmc> even in C++ "const" can be worked around easily
19:10:58 <SamB_XP> ManateeLazyCat: s/can/can't/
19:11:01 <Zao> kmc: Assuming you adhere to The Rules.
19:11:03 <ManateeLazyCat> d-snp: If you want keep variable state, you need some Moand wrap it.
19:11:11 <ManateeLazyCat> SamB_XP: Sorry, yes.
19:11:20 <SamB_XP> ManateeLazyCat: I assume it was a typo
19:11:24 <ManateeLazyCat> d-snp: You can't change variable value after it create.
19:11:36 <d-snp> ok
19:11:39 <EvanR> kmc: when pointing out how ridiculous this is to people, i try to get them to imagine if their variable containing a number 3 was suddenly 7 for no reason ;)
19:11:54 <EvanR> i suppose its like passing IORefs everywhere
19:12:08 <kmc> yes
19:12:18 <kmc> in most languages, a variable is a name for a cell, not a value
19:12:19 <erikc> EvanR: you can do that in fortran :)
19:12:30 <kmc> the semantics are fairly reasonable, if you keep that in mind
19:12:34 <Twey> Haskell has no mutable state.  The imperative, impure language that is the result of evaluating a Haskell program does have state.  âº
19:12:45 <kmc> the problem is that many programmers muddle together value, state, and identity conceptually
19:12:47 <breakspirit> haha, using checkTripCode xs = show (unknotMatch [] xs)     makes the output  "Just a"
19:12:50 <breakspirit> which is strange and funny
19:12:57 <kmc> as they muddle together argument dependence, deferred evaluation, and side effects
19:13:03 <Twey> (State and so on aside)
19:13:09 <kmc> Twey, ;P
19:13:26 <ManateeLazyCat> d-snp: Example, I define "data Foo = Foo Int", then you create it "let fooVariable = Foo 1", then fooVariable's value is always 1.
19:13:30 <kmc> graph reduction is entirely based on mutable state
19:13:32 <kmc> so there ;P
19:13:42 <Twey> Implementation detail :Ã¾
19:14:07 <Twey> ManateeLazyCat: You mean Foo 1
19:14:16 <ManateeLazyCat> d-snp: If you want keep change state of it. You can use newIORef
19:14:29 <d-snp> I don't want to I think :P
19:14:30 <ManateeLazyCat> Twey: Sorry, too tired
19:14:35 <theorbtwo> Similarly, implementing deferred evaluation and keeping your sanity is quite difficult without argument dependence.
19:14:35 <kmc> monads don't magically let you have mutable variables
19:14:47 <fax> yes they do :P
19:14:48 <fax> at least ST does
19:15:00 <kmc> an IORef is not a variable
19:15:04 <kmc> it's a value, which is the name for a cell
19:15:07 <kmc> the cell is not a value
19:15:22 <kmc> the IORef value can be rememberd as a variable, or not.  that's irrelevant
19:15:40 <kmc> anyway this is all pretty metaphysical ;P
19:15:46 <ManateeLazyCat> d-snp: Infact, in Haskell, every new variable is copy.
19:15:57 <kmc> but i think it's important not to think of monads like IO as special cases that let you break the rules
19:16:04 <EvanR> i dont know if its a copy
19:16:05 <ManateeLazyCat> kmc: Yep.
19:16:23 <ManateeLazyCat> kmc: That can make your project stronger and flexibility.
19:16:28 <kmc> rather, they are domain specific languages that allow you to describe, while following the rules, a computation which could be performed
19:16:37 <EvanR> immutable values have the benefit of being shared with no problem of being altered inappropriately
19:16:50 <SamB_XP> the primitives do break the usual rules, though ;-P
19:16:53 <kmc> yes
19:17:25 <kmc> the question "Does Haskell flag side-effecting functions in the type system?" has a trick answer
19:17:35 <kmc> the answer is "no, but you almost never see one unless you are a GHC developer"
19:17:40 * SamB_XP innapropriately mutates the immutable using unsafe* tricks
19:18:47 <d-snp> --->  Building ghc
19:18:49 <adityam> For some reason, ghc --make is not finding an installed package. How do I debug?
19:18:54 <ManateeLazyCat> d-snp: Use Haskell Monad model, you don't need change most code (pure arithmetic), even you refactory code, those pure code is model. You can combination them in any order.
19:18:55 <d-snp> it takes pretty long :P
19:18:56 * theorbtwo watches as SamB_XP's experiment rises up and kills him.  Remember, don't piss off the mutants after you've given them an amantium skeleton.
19:19:07 <EvanR> d-snp: dont compile your own ghc
19:19:16 <SamB_XP> theorbtwo: oh, but I'm mutating YOUR values, not mine ;-P
19:19:32 <ManateeLazyCat> d-snp: If you want switch from single-thread to concurrent problem, just need change wrap code. Example switch from IORef to TVAr.
19:19:32 <SamB_XP> also, s/amantium/adamantium/
19:19:41 <d-snp> EvanR: it'll probably finish someday :P
19:19:49 <EvanR> TVar?
19:19:53 <kmc> d-snp, grab the Haskell Platform if it's available for your system
19:19:56 <ManateeLazyCat> EvanR: STM
19:19:57 <kmc> EvanR, STM's transactional variables
19:20:00 <EvanR> ah
19:20:07 <kmc> the RWH chapter on STM is excellent
19:20:21 <ManateeLazyCat> EvanR: I always use TVar, never use IORef.
19:20:41 <kmc> there are plenty of other options, e.g. MVar, Chan, TMVar
19:20:41 <mm_freak> hmm
19:20:43 <EvanR> im still on level "MVar"
19:20:51 <kmc> sometimes you want to avoid STM
19:20:58 <mm_freak> it seems like a lot of people use either IORef or STM
19:21:02 <ManateeLazyCat> kmc: And have another book named "Beautiful Code", in Chapter 10, special for Haskell STM. :)
19:21:17 <mm_freak> for most use cases, the usual concurrency constructs like MVar and Chan are totally appropriate
19:21:20 <ManateeLazyCat> kmc: When?
19:21:23 <kmc> if you are threading for concurrency, not parallelism, and your threads work more or less in lockstep, STM will probably perform terribly
19:21:31 <kmc> and you should use the blocking constructs like MVar
19:21:37 <SamB_XP> mm_freak: hmm ?
19:21:49 <mm_freak> SamB_XP: question? =)
19:21:55 <ManateeLazyCat> kmc: Yes.
19:22:01 <SamB_XP> oh, I thought you said innapropriate
19:22:06 <SamB_XP> hehehe
19:22:13 <mm_freak> ok =)
19:22:17 <Sgeo> Can you do Erlang-style concurrency in Haskell?
19:22:18 <kmc> sometimes you want to describe a problem as a pipeline of interacting agents, but you don't expect they can do anything useful if they run at the same time
19:22:22 <breakspirit> Cale: thanks again for all your help.  I really appreciate it.  thanks everyone else, too, for your input
19:22:23 <kmc> Sgeo, what's Erlang-style?
19:22:28 <ManateeLazyCat> EvanR: When you program need blocking for some synchronous, just use MVar.
19:22:32 <ddarius> Sgeo: You can do message passing concurrency quite easily.
19:22:35 <kmc> Sgeo, you can fork off millions of lightweight threads and pass messages between them
19:22:42 <kmc> there is not much support for doing so on multiple machines
19:22:43 <ManateeLazyCat> EvanR: Otherwise, STM will waste your resource. :)
19:22:55 <ddarius> Sgeo: There are no libraries for the Erlang-style error handling though.
19:22:57 <kmc> oh, CHP is another option
19:23:04 <kmc> for, err, communicating haskell processes
19:23:20 <ddarius> Sgeo: There's also something that will let you write a Haskell process that will communicate with Erlang nodes.
19:23:22 <ManateeLazyCat> kmc: Can you talk CHP simply? I'm interested.
19:23:23 <mm_freak> honestly each time i thought STM would be great for the job, i found that using MVars with more threads was cleaner
19:23:27 <EvanR> kmc: millions?
19:23:54 <kmc> ManateeLazyCat, http://www.cs.kent.ac.uk/projects/ofa/chp/
19:23:54 <ManateeLazyCat> mm_freak: Yes, STM is cleaner than MVar, haven't mutex variable.
19:24:28 <kmc> EvanR, depends on your system anyway
19:24:29 <kmc> that range
19:24:32 <mm_freak> ManateeLazyCat: maybe my use cases are different
19:24:35 <ManateeLazyCat> kmc: Yep, i know that. I want listen to your word. :)
19:24:40 <kmc> ManateeLazyCat, i don't know much about it
19:25:15 <ManateeLazyCat> kmc: Looks CHP good for Haskell process synchronous.
19:25:26 <ManateeLazyCat> kmc: I use DBus for Haskell process asynchronous handle.
19:25:28 <mm_freak> and it's the subtle "STM is slow" you notice everywhere =)
19:25:44 <ManateeLazyCat> mm_freak: "STM is slow"?
19:25:48 <ManateeLazyCat> mm_freak: Detail?
19:25:54 <kmc> STM is slow if you have lots of contention
19:26:14 <d-snp> wow
19:26:19 <d-snp> wtf, haskell is big
19:26:23 <d-snp> 180mb?
19:26:26 <d-snp> ehh 140mb
19:26:38 <ManateeLazyCat> kmc: Always backroll?
19:26:48 <kmc> yeah
19:26:53 <kmc> d-snp, Haskell is a specification...
19:26:55 <kmc> you mean GHC?
19:27:09 <d-snp> the haskell platform, as offered on haskell.org
19:27:18 <kmc> okay
19:27:31 <d-snp> compiling ghc took worryingly long
19:27:39 <ManateeLazyCat> kmc: Keep STM action little enough?
19:27:44 <mm_freak> ManateeLazyCat: i have no idea, but i read that everywhere
19:27:45 <d-snp> though it's been years since I used a language that had long compile times..
19:28:10 <EvanR> my programs dont take a lot time to compile
19:28:19 <EvanR> compiling the compiler? thats another story
19:28:19 <mm_freak> most of my use cases look like this: two threads, a reader and a processor
19:28:25 <ManateeLazyCat> mm_freak: I use TVar with gtk2hs code. I love mix STM moand with IO Monad.
19:28:26 <d-snp> hmm well mono takes a pretty long while too, so perhaps its normal
19:28:31 <kmc> ManateeLazyCat, sometimes you can't
19:28:40 <ManateeLazyCat> kmc: Detail?
19:28:42 <kmc> ManateeLazyCat, if you have 1,000 threads all trying to increment the same TVar, STM will get nowhere
19:28:50 <kmc> if all they do is sit in a loop and hit that TVar
19:29:37 <ManateeLazyCat> kmc: So this TVar is always backroll and can't finish?
19:29:40 <kmc> yeah
19:30:26 <ManateeLazyCat> kmc: You have test this problem with 1,000 threads?
19:30:33 <kmc> something similar, yeah
19:30:35 <kmc> don't recall the exact details
19:30:56 <ManateeLazyCat> kmc: So, what's your solution?
19:31:00 <kmc> don't use STM
19:31:03 <kmc> for problems like that
19:31:08 <d-snp> ah well I'm going to bed, haskell is a bit more complex than I thought :P
19:31:14 <d-snp> nn, and thanks for all the fish :)
19:31:23 <ManateeLazyCat> d-snp: Much complicated.
19:31:28 <kmc> if you want the scheduler to determine an orderly synchronous execution of threads, then you should use locking constructs
19:31:39 <kmc> i think STM will be very useful in the real world
19:31:48 <kmc> but it's not a magic one-size-fits-all solution
19:32:03 <kmc> not all STM implementations are lock-free and optimistic
19:32:16 <kmc> for example the main Clojure implementation uses locks, iirc
19:32:48 <ManateeLazyCat> kmc: So in inter-control variable (such as 1,000 threads), we still need MVar for blocking.
19:34:02 <ManateeLazyCat> kmc: I have project that use multi-processes with DBus, and RootProcess keep share resource, every other Processes will send request to change it, so it's not a good idea use STM in RootProcess for control those requests?
19:34:32 <kmc> ManateeLazyCat, i'm not really sure
19:34:48 <kmc> it would be nice to have a naive locking implementation of the same STM constructs
19:35:00 <kmc> so that, if that implementation performs better than the "real" one, you know something is seriously contending
19:35:03 <ManateeLazyCat> kmc: Like you said, perhaps too many requests, and this STM action is big, and always backroll can't finish.
19:35:41 <kmc> what do the different threads in RootProcess do?
19:36:50 <ManateeLazyCat> kmc: In RootProcess, it's control main Gtk+ thread and scheduler thread.
19:37:47 <kmc> so one thread processes DBus requests, and the other draws to Gtk?
19:37:55 <ManateeLazyCat> kmc: Example, one main thread for Render Gtk+ function, and every other thread like server to receive request from other processes.
19:38:05 <kmc> ah
19:38:08 <kmc> so one per client
19:38:10 <kmc> plus one for gtk
19:38:34 <kmc> i'm not sure whether STM or MVar/Chan will perform better, to be honest
19:38:40 <kmc> i expect the Gtk thread to be idle most of the tim
19:38:47 <kmc> i don't know about the client threads, that depends on client behavior
19:39:02 <kmc> are the clients frequently updating the same piece of information?
19:39:12 <ManateeLazyCat> kmc: Just Render thread can render, other server threads just receive request then wait Render thread update one by one.
19:40:29 <ManateeLazyCat> kmc: Every processes is Gtk+ process, just RootProcess render frame, ChildProcess render program, then use X-Embedded protocol connect them.
19:41:21 <ManateeLazyCat> kmc: So i use STM control share resource in RootProcess.
19:42:04 <ManateeLazyCat> kmc: When RootProcess receive asynchronous request from DBus message, it's will create one thread try to access those STM resource.
19:42:51 <SamB_XP> user64667: you ain't got a name ?
19:43:14 <ManateeLazyCat> kmc: Because Gtk+ GtkSocket/GtkPlug have use X-Embedded protocol control cross-process render.
19:43:23 <user64667> i could make one up i suppose ;)
19:43:27 <kmc> EvanR, re "millions", i just ran a naive test
19:43:53 <ManateeLazyCat> kmc: So i just use STM manage non-GUI resource, such as, TabList, WindowList, ProcessList.
19:44:00 <kmc> on my 2-core laptop with -threaded and +RTS -N2 i can spawn a million threads and receive a Chan message from each in about 10 seconds total
19:44:09 <kmc> it uses a *lot* of RAM and spends about 50% of its time in GC
19:44:13 <kmc> (ghc 6.10.4
19:44:19 <EvanR> meh
19:44:48 <kmc> so i think "millions" is fair especially if you are considering a server-grade machine
19:45:31 <EvanR> if each is not doing anything most of time i guess it should be ok
19:45:33 <EvanR> how much ram?
19:45:45 <ManateeLazyCat> kmc: I will use STM for a try, if it's always backroll and waste my resource, i will use MVar/Chan replace. :)
19:46:07 <kmc> EvanR, the number actually doing anything at any time is limited by the RTS
19:46:09 <kmc> not how you code
19:46:20 <EvanR> im talking about the workload
19:46:20 <kmc> 4GB RAM on the machine
19:46:39 <kmc> the idea is to decompose your problem naturally, even if that means many threads, then let the RTS do the pooling
19:46:42 <SamB_XP> kmc: he means how many WANT to run at a time
19:46:57 <ManateeLazyCat> kmc: GHC have finish it's compile bug? I use GHC-6.12 compile qtHaskell, eat all my RAM -- 2GB
19:47:07 <kmc> maximum RAM residency about 650 MB
19:47:11 <SamB_XP> i.e. if top was displaying them all, the ones that it would mark R
19:47:27 <EvanR> if 800 thousand are waiting for a socket, well, were really only running 200 thousand ;)
19:47:49 <kmc> why would it be much worse if most of them want to run?
19:47:52 <ManateeLazyCat> kmc: In my project, because every tab is one process, and one Gtk+ process at least need 4MB.
19:48:01 <kmc> granted, pure parallelism might be better handled through explicit sparks
19:48:03 <kmc> err implicit sparks
19:48:04 <EvanR> kmc: less GC time?
19:48:07 <kmc> rather than explicit threads
19:48:23 <SamB_XP> and if 190 thousand of those are waiting on MVars, you've only got 10k in the run queue
19:48:28 <kmc> in my test they were always wanting to run
19:48:35 <kmc> in that each thread immediately writes to a chan and then quits
19:49:01 <SamB_XP> kmc: wouldn't that have left them wanting to run on average HALF of the time ?
19:49:02 <EvanR> right, but in real life you might have a lot of stuff that is waiting for something else, because thats how the problem / workload is
19:49:11 <ManateeLazyCat> kmc: I thinkg about that, if we have super-computer, STM always work? :)
19:49:11 <kmc> yeah
19:49:15 <kmc> ManateeLazyCat, heh
19:49:19 <SamB_XP> ManateeLazyCat: no
19:49:27 <ManateeLazyCat> SamB_XP: Joking.
19:49:29 <SamB_XP> restarts would get worse, I think ;-P
19:49:31 <kmc> back later
19:50:53 <ManateeLazyCat> Anyway, STM is cleaner solution than mutex, and works well for most situation.
19:51:31 <EvanR> meh
19:51:38 <ManateeLazyCat> STM can give your cleaner concurrent logic. And make your program more model.
19:52:15 <SamB_XP> MVars are pretty damn clean, though
19:52:28 <EvanR> i like the MVar and Chan semantics
19:52:42 <dankna> I like MVars and Chans, I just don't feel the need for STM
19:52:49 <ddarius> SamB_XP: MVars are reasonably clean, but they aren't much better that typical locks/monitors/etc.
19:52:51 <dankna> STM is a very powerful abstraction, I can see that
19:53:06 <dankna> but the problem with such abstractions is that they do a lot under the hood and you need to really understand them
19:53:10 <dankna> to use them properly
19:53:30 <SamB_XP> ddarius: I mean, they save an assload of code at least
19:53:51 <ManateeLazyCat> SamB_XP: Okay, MVar is better than STM sometimes, so like kmc said. STM not a magic one-size-fits-all solution
19:53:56 <ddarius> If your pattern of concurrency is simple enough, MVars are easy enough to work with and pretty efficient.  However, for more complex patterns, STM tends to be significantly easier to use, namely due to being much more compositional.
19:54:28 <Sgeo> Is there STM stuff for other languages?
19:54:35 <ddarius> Sgeo: Yes.
19:54:35 <dobblego> yes
19:54:43 <ManateeLazyCat> SamB_XP: I need try to use lock for concurrent.
19:54:53 <ddarius> STM didn't originate in Haskell though it evolved significantly in Haskell.
19:55:38 <EvanR> mutexes and locks are hidden behind the MVar interface, you dont have to directly worry about them, although you can emulate a lock/unlock critical section with them easily
19:55:47 <ManateeLazyCat> ddarius: And STM is easier switch from IORef. :)
19:56:09 <ddarius> The idea of transactional memory has been around for a long time.  Then Keir Fraser did some awesome work on lock-free concurrency using C++.  Then he got with some Haskell people and added STM to Haskell.
19:56:28 <EvanR> sharing mutable variables does not seem very clean to me, explicit communication streams seems to keep things sanity checked
19:56:35 <ManateeLazyCat> ddarius: Hehe.
19:56:36 <ddarius> I highly recommend reading Keir Fraser's dissertation: http://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-579.html
19:56:56 <ManateeLazyCat> ddarius: Thanks for share.
19:57:05 <pikhq> Sgeo: STM is just easy to do in Haskell, since you can pretty well guarantee you're only using transactional memory.
19:57:10 <ddarius> EvanR: Sometimes shared state concurrency fits the problem better sometimes it doesn't.
19:57:22 <EvanR> s/clean/cleaner/
19:57:23 * Sgeo should learn to understand monad transformers
19:57:27 <pikhq> EvanR: We have explicit communication streams that happen to have a buffer size of 1, and block when the buffer's full. :P
19:57:31 * Sgeo wishes he could USE some of this stuff
19:57:45 <ddarius> EvanR: It is the case, though, that shared state concurrency get further and further from the reality of the hardware (particularly so in distributed scenarios.)
19:57:57 <ManateeLazyCat> pikhq: Yep, Haskell type-system make sure you can't wrong use STM.
19:58:19 <ddarius> EvanR: Incidentally, there are channel systems built on STM and also built on MVars.
19:59:01 <ManateeLazyCat> And awesome is, we can mix those in Haskell easier and cleaner.
19:59:08 <EvanR> i was reacting to ManateeLazyCat saying that sharing mutable variables is cleaner, it just sounds like it could get out of hand
19:59:36 <EvanR> sounds more powerful
20:00:05 <ManateeLazyCat> EvanR: Works well so far.
20:00:09 <pikhq> Yes, this is why Haskell offers other abstractions.
20:01:02 <ManateeLazyCat> Someone help me http://paste2.org/get/755514 ? It crazy me, i haven't idea.
20:01:43 <ManateeLazyCat> Current gtk2hs darcs works well, just my new patch will cause above error.
20:01:55 <aavogt> preflex: zdec giozm0zi10zi1_SystemziGIOziTypes_zdfGObjectClassIcon_closure'
20:01:56 <preflex>  gio-0.10.1_System.GIO.Types_$fGObjectClassIcon_closure'
20:02:04 <EvanR> especially if doing GUI stuff
20:02:56 <ManateeLazyCat> EvanR: gtk2hs have finish all APIs (99.99%) to Gtk+ 2.18.3, except some involved functions, you can try it. :)
20:03:08 <ManateeLazyCat> EvanR: I use STM with gtk2hs code a lots.
20:03:19 <EvanR> i am very afraid of gtk+
20:03:27 <EvanR> i dont know anything about gtk2hs
20:03:31 <dev0x> hey all - pretty dumb question : where is the darcs repository for xmobar (I can't seem to connect/resolve)
20:03:37 <ManateeLazyCat> aavogt: Thanks, zdec is good tool
20:04:06 <aavogt> but it doesn't actually say how to correct it
20:04:35 <ManateeLazyCat> aavogt: What's zdec ?
20:05:35 <ManateeLazyCat> aavogt: Looks like gtk lack gio package dependency, and something wrong when link.
20:06:00 <jmcarthur> dev0x: if it's supposed to be on code.haskell.org, it's no surprise you can't connect. the server is having issues
20:06:39 <ManateeLazyCat> preflex: zdec giozm0zi10zi1_SystemziGIOziTypes_zdfGObjectClassIcon_closure
20:06:39 <preflex>  gio-0.10.1_System.GIO.Types_$fGObjectClassIcon_closure
20:06:42 <dev0x> jmcarthur : thanks
20:07:38 <ManateeLazyCat> aavogt: I can find same tools like `zdec` ? Don't use Robot.
20:09:17 <Sgeo> Anyone know when the new Platform will be available for Windows?
20:10:32 <ManateeLazyCat> preflex: seen dcoutts
20:10:32 <preflex>  dcoutts was last seen on #haskell 4 days, 17 hours, 10 minutes and 59 seconds ago, saying: I used unsafeCoerce and demons flew out of my nose!
20:10:42 <jmcarthur> haha
20:10:48 * ManateeLazyCat Always busy. 
20:10:55 <ManateeLazyCat> Busy than me.
20:11:13 <Mathnerd314> Sgeo: http://www.haskell.org/pipermail/libraries/2010-March/013376.html
20:11:33 <Sgeo> Are there likely to be any bugs?
20:11:56 <ManateeLazyCat> jmcarthur: You know what's "preflex: zdec" ? I think it's good tool for develop gtk2hs.
20:12:41 <Mathnerd314> Sgeo: read further. It will be released as-is unless someone *finds* them
20:13:33 <lep-delete> hey, i have a problem with files: im gettin errors with openFile which tells me that the file is locked. im only using readFile, writeFile and appendFile. doest these functions automaticaly close the file-handles? my function causing the error looks rough like this: content <- readFile; writeFile (do some things with content)
20:14:24 <kniu> how do I keep my application from crashing every time it encounters a "broken pipe"?
20:14:39 <kmc> lep-delete, readFile uses "lazy IO"
20:14:40 <kniu> does the IO action throw an exception I can catch?
20:14:49 <kmc> kniu, yeah, see Control.Exception
20:14:57 <kmc> possibly you need to install a signal handler for SIGPIPE
20:15:03 <kmc> which could just throw an async exception to the main thread
20:15:14 <kmc> honestly i'm not sure  about the most haskelly way to handle SIGPIPE
20:15:41 <kmc> lep-delete, "lazy IO" is sort of an abomination that breaks usual Haskell semantics; in particular, it defers the actual IO until the list it returns is evaluated
20:16:19 <lep-delete> i see. but how do i solve my problem?
20:16:57 <kmc> i'd like it if there were just a strict version of readFile
20:17:01 <kmc> but i can't find one in the standard lib
20:17:20 <ManateeLazyCat> kmc: Do you know what's "preflex: zdec" ? I need same tool but not robot.
20:17:25 <kmc> i don't know
20:17:34 <SamB_XP> preflex: about
20:17:39 <SamB_XP> preflex: version
20:17:40 <preflex>  0.127
20:17:44 <SamB_XP> preflex: source
20:17:49 <SamB_XP> preflex: author
20:17:54 <SamB_XP> preflex: help
20:17:55 <preflex>  try 'help help' or see 'list' for available commands
20:17:57 <SamB_XP> preflex: help help
20:17:58 <preflex>  help COMMAND - show help for a command
20:18:02 <SamB_XP> preflex: list
20:18:02 <preflex>  Cdecl: [cdecl]; 8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; Seen: [seen]; Sixst: [6st]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; XSeen: [xseen]; ZCode: [zdec, zenc]
20:18:35 <pikhq> kmc: strictReadFile = do x <- readFile;x `deepSeq` return x --?
20:18:47 <kmc> yeah
20:18:50 <kmc> use that
20:18:56 <kmc> except, not sure where deepSeq lives
20:19:18 <pikhq> Control.Strategies.DeepSeq
20:19:23 <kmc> strictReadFile name = do x <- readFile name; return (x `using` rnf)
20:19:32 <ManateeLazyCat> preflex: help zdec
20:19:32 <preflex>  zdec TEXT - z-decode some text
20:19:34 <kmc> from Control.Parallel.Strategies
20:19:49 <ManateeLazyCat> SamB_XP: thanks.
20:19:50 <pikhq> mmm, that'd work as well.
20:19:56 <kmc> :t (return . (`using` rnf) <$>) . readFile
20:19:57 <lambdabot> forall (m :: * -> *). (Monad m) => FilePath -> IO (m String)
20:20:01 <kmc> :(
20:20:12 <kmc> :t \n -> return . (`using` rnf) <$> readFile n
20:20:13 <lambdabot> forall (m :: * -> *). (Monad m) => FilePath -> IO (m String)
20:20:21 <ManateeLazyCat> preflex: source zdec
20:20:22 <kmc> oh
20:20:27 <kmc> :t \n -> (`using` rnf) <$> readFile n
20:20:28 <lambdabot> FilePath -> IO String
20:20:37 <kmc> :t ((`using` rnf) <$>) . readFile
20:20:38 <lambdabot> FilePath -> IO String
20:20:43 * SamB_XP was hoping there'd be a command to say who wrote preflex or where it can be obtained ...
20:20:54 <lep-delete> hmm, i have no Control.Strategies
20:20:56 <pikhq> :t return . strict <$> readFile name
20:20:57 <lambdabot> Not in scope: `strict'
20:20:57 <lambdabot> Not in scope: `name'
20:21:01 <kmc> lep-delete, Control.Parallel.Strategies
20:21:02 <ManateeLazyCat> SamB_XP: yep.
20:21:33 <lep-delete> dont have that either
20:21:38 <Sgeo> I seem to be unable to download the thing
20:21:44 <kmc> lep-delete, what GHC or Haskell Platform version?
20:22:32 <lep-delete> ghc 6.12.1
20:22:32 <ManateeLazyCat> Where i can get source code of `preflex` ?
20:22:40 <kmc> lep-delete, did you get it through Haskell Platform?
20:22:48 <lep-delete> no
20:22:50 <kmc> in GHC 6.12 they have removed a lot of libraries that used to come with
20:22:57 <kmc> you should really get the Platform unless you have specialized needs
20:23:25 <lep-delete> haskell platform didnt worked on my pc with aptitude. and compiling also did not work
20:24:01 <kmc> damn
20:24:07 <kmc> do you have cabal-install?
20:24:23 <kmc> the command line command named "cabal"?
20:24:29 <kmc> if so,  $  cabal install parallel
20:25:18 <ManateeLazyCat> preflex: zenc gio-0.10.1_System.GIO.Types_$fGObjectClassIcon_closure
20:25:19 <preflex>  giozm0zi10zi1zuSystemziGIOziTypeszuzdfGObjectClassIconzuclosure
20:25:50 <kmc> i feel like i'm back in C++-land
20:26:21 <pikhq> I think I vomited in my mouth a little.
20:26:54 <ManateeLazyCat> preflex: help zenc
20:26:54 <preflex>  zenc TEXT - z-encode some text
20:27:09 <ManateeLazyCat> preflex: help zdec
20:27:10 <preflex>  zdec TEXT - z-decode some text
20:27:39 <ManateeLazyCat> preflex: help ZCode
20:27:39 <preflex>  unknown command: ZCode
20:28:26 <ManateeLazyCat> What's z-decode?
20:28:58 <kmc> it seems to decode the name mangling scheme used by GHC
20:29:13 <Mathnerd314> preflex: zdec giozm0zi10zi1zuSystemziGIOziTypeszuzdfGObjectClassIconzuclosure
20:29:14 <preflex>  gio-0.10.1_System.GIO.Types_$fGObjectClassIcon_closure
20:29:30 <Mathnerd314> e.g. zdec zenc == id
20:29:58 <ManateeLazyCat> kmc: This tools will be useful for debugging gtk2hs code.
20:30:24 <ManateeLazyCat> kmc: It's decode "unknown symbol" with more readability.
20:30:26 <kmc> in my experience ghc does a better job than g++ at insulating me from its name mangling
20:30:29 <kmc> but not a perfect job
20:30:36 <wavewave> I have a question on Data.Binary and Lazy ByteString.
20:30:59 <wavewave> I recorded [Something] using Data.Binary..
20:30:59 <kmc> cool
20:31:07 <wavewave> to some file.
20:31:08 <ManateeLazyCat> kmc: Where i can find source code of `zdec` ?
20:31:13 <kmc> ManateeLazyCat, i haven't any clue
20:31:18 <ManateeLazyCat> kmc: Or GHC name mangling
20:31:31 <kmc> ManateeLazyCat, in the source for GHC
20:31:33 <ManateeLazyCat> kmc: Have any tool do same job?
20:31:37 <kmc> sorry but i don't know of one
20:31:37 <wavewave> Now I retrieve the content from the file and process it one by one.
20:31:49 <ManateeLazyCat> kmc: Okay :)
20:31:53 <SamB_XP> @google site:haskell.org "z-encoding"
20:31:55 <lambdabot> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/SymbolNames
20:31:55 <lambdabot> Title: Commentary/Compiler/SymbolNames â GHC
20:32:08 <wavewave> The file is huge.. so I do want to process it lazily.
20:32:17 <SamB_XP> ManateeLazyCat: check that page, the name looks relevant
20:32:24 <Sgeo> "Thrown when the runtime system detects that the computation is guaranteed not to terminate. Note that there is no guarantee that the runtime system will notice whether any given computation is guaranteed to terminate or not."
20:32:27 <ManateeLazyCat> SamB_XP: Thanks.
20:32:34 <kmc> is there a page that puts all the haddock from every package in Platform together?
20:32:41 <Sgeo> When will the runtime system be able to notice that? ;)
20:32:44 <wavewave> for example, if I just count how many element in [Something] from the file.
20:32:46 <kmc> i.e. one big hierarchy of all the modules
20:32:52 <SamB_XP> Sgeo: when you get lucky
20:32:53 <aavogt> it should be simple enough to write your own zdec
20:33:07 <aavogt> preflex: source
20:33:11 <aavogt> preflex: help
20:33:11 <preflex>  try 'help help' or see 'list' for available commands
20:33:14 <aavogt> preflex: list
20:33:15 <preflex>  Cdecl: [cdecl]; 8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; Seen: [seen]; Sixst: [6st]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; XSeen: [xseen]; ZCode: [zdec, zenc]
20:33:16 <kmc> Sgeo, i'm sure the GHC developers would welcome patches in the event you write a halting oracle ;)
20:33:17 <wavewave> how can I make my program have very small memory foot print?
20:33:28 <aavogt> mauke: is preflex's source somewhere?
20:33:33 <SamB_XP> Sgeo: seriously, when you aren't using -threaded and it enters a black hole
20:33:39 <SamB_XP> @google site:haskell.org "black hole"
20:33:40 <lambdabot> http://hackage.haskell.org/trac/hugs/ticket/47
20:33:41 <lambdabot> Title: #47 (Hugs segfaults on black hole.) â Hugs
20:33:50 <ddarius> aavogt: Yes.  Use a little google.
20:33:59 <SamB_XP> @google site:http://hackage.haskell.org/trac/ghc/wiki/ "black hole"
20:34:00 <kmc> Sgeo, put "main = main" in a .hs file and compile it with -O2
20:34:00 <lambdabot> No Result Found.
20:34:00 <ManateeLazyCat> @google site:haskell.org "preflex"
20:34:01 <lambdabot> No Result Found.
20:34:07 <flippo> wavewave, Use "hi" instead of "Hello, world."
20:34:08 <kmc> Sgeo, note that it won't work in ghci
20:34:12 <SamB_XP> @google site:http://hackage.haskell.org/trac/ghc/wiki/ "blackhole"
20:34:13 <lambdabot> http://hackage.haskell.org/trac/ghc/wiki/GpHEden/PlaceholdersAndGC
20:34:13 <lambdabot> Title: GpHEden/PlaceholdersAndGC â GHC
20:34:45 <ManateeLazyCat> @google site:haskell.org "preflex"
20:34:46 <lambdabot> No Result Found.
20:34:49 <kmc> Sgeo, basically, it's thrown whenever forcing evaluation of some closure requires forcing evaluation of the same closure
20:34:51 <ManateeLazyCat> ???
20:36:06 <aavogt> ManateeLazyCat: preflex would probably be somewhere in here: http://mauke.ath.cx/stuff/
20:37:04 <ManateeLazyCat> aavogt: I haven't found preflex ?
20:37:43 <aavogt> ManateeLazyCat: anyways, the z encoding is just a couple substitutions in a table here: http://www.haskell.org/ghc/docs/latest/html/users_guide/ffi-ghc.html
20:38:40 <ddarius> http://mauke.ath.cx/preflex/
20:38:52 <ManateeLazyCat> aavogt: I don't want rewrite it again, even it just some regular-expression replace, i want preflex source code.
20:39:09 <ManateeLazyCat> ddarius: Cool.
20:39:17 <SamB_XP> is it perl or Haskell or ?
20:39:45 <wavewave> according to  haskell-cafe discussion, the package binary is spine-strict, isn't it?
20:39:50 <ddarius> SamB_XP: Haskell but the wcalc in C.
20:39:55 <ddarius> s/in/is
20:40:04 <wavewave> http://www.mail-archive.com/haskell-cafe@haskell.org/msg33094.html
20:40:13 <ManateeLazyCat> http://mauke.ath.cx/ redirect to http://unicodesnowmanforyou.com/ ?
20:40:22 <ManateeLazyCat> Funny.
20:40:31 <ManateeLazyCat> ddarius: Are you author?
20:40:39 <SamB_XP> mauke would be
20:40:46 <SamB_XP> if it's at mauke.ath.cx
20:40:55 <SamB_XP> don't you think?
20:42:03 <ManateeLazyCat> ddarius: I got source code preflex, thanks.
20:42:48 <aavogt> or ghc-api: http://www.haskell.org/ghc/docs/6.12.1/html/libraries/ghc-6.12.1/Encoding.html
20:43:27 <ManateeLazyCat> aavogt: Wow
20:43:34 <kmc> anyone have recommendations for using debian's packages vs. compile from source to get the latest Haskell Platform?
20:43:55 <ManateeLazyCat> @source zDecodeString
20:43:55 <lambdabot> zDecodeString not available
20:44:31 <ManateeLazyCat> :> zDecodeString giozm0zi10zi1_SystemziGIOziTypes_zdfGObjectClassIcon_closure
20:45:13 <ManateeLazyCat> > zDecodeString giozm0zi10zi1_SystemziGIOziTypes_zdfGObjectClassIcon_closure
20:45:14 <lambdabot>   Not in scope: `zDecodeString'Not in scope:
20:45:14 <lambdabot>    `giozm0zi10zi1_SystemziGIOziT...
20:45:53 <aavogt> ManateeLazyCat: I guess lambdabot doesn
20:45:57 <ManateeLazyCat> lambdabot: Can you install plug yourself?
20:46:00 <aavogt> 't have Encoding imported
20:46:03 <ManateeLazyCat> :)
20:46:17 <aavogt> but if you load ghci with -package ghc, you can import Encoding
20:46:43 <SamB_XP> yay for having TWO copies of GHC loaded at ONCE
20:47:34 <aavogt> @protontorpedo
20:47:34 <lambdabot> so there is no database, monitoring system, web browser, webserver, or scheduling ssytem in haskell?
20:47:46 <kmc> haha
20:50:14 <mm_freak> > filterM (\x -> True : [False | x == 'u']) "/dev/urandom"
20:50:15 <lambdabot>   ["/dev/urandom","/dev/random"]
20:50:27 <kmc> cute
20:50:43 <mm_freak> hmmâ¦  let me point-free that
20:51:44 <kmc> > filterM (\x -> True : [False | x `elem` "aeiou"]) "hello world"
20:51:45 <lambdabot>   ["hello world","hello wrld","hell world","hell wrld","hllo world","hllo wrl...
20:51:52 <kmc> > length $ filterM (\x -> True : [False | x `elem` "aeiou"]) "hello world"
20:51:53 <lambdabot>   8
20:52:11 <mm_freak> yeah, filterM generalizes subsequences
20:52:19 <mm_freak> over the list monad, that is
20:52:28 <mm_freak> useful for lots of stuff
20:52:41 <ManateeLazyCat> aavogt: I can't use Encoding module in ghci, even i use "ghci -package encoding" load it.
20:52:54 <mm_freak> > filterM ((True:) . ([False] <*) . guard . (== 'u')) "/dev/urandom"
20:52:55 <lambdabot>   ["/dev/urandom","/dev/random"]
20:53:05 <mm_freak> ugly and scary, though
20:54:59 <kmc> there's guard and <* again
20:55:00 <wavewave> is there any way to adjust a chuck size for Data.Binary?
20:55:09 <aavogt> ManateeLazyCat: -package ghc
20:55:54 <mm_freak> i also used foldM to bruteforce-solve the problem of finding suitable operators to satisfy an equation like n1 `f1` n2 `f2` n3 == n4, where the values n1, n2, n3 and n4 are known
20:55:58 <aavogt> that one is hidden by default since it pollutes the namespace, and it's only provided by ghc
20:57:01 <kmc> wow
20:57:50 <ManateeLazyCat> aavogt: Oh, another hidden tip. :)
20:58:11 <aavogt> nah, just repetition ;)
20:58:18 <mm_freak> > foldM (\x y -> [x+y, x-y]) [100, 10, 1]
20:58:19 <lambdabot>   No instance for (GHC.Num.Num [t])
20:58:19 <lambdabot>    arising from a use of `GHC.Num.+' at <...
20:58:28 <kmc> after loading "ghci -package ghc" i am in awe of newfound possibilities for breaking shit
20:58:30 <mm_freak> :t foldM
20:58:31 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
20:58:42 <mm_freak> > foldM (\x y -> [x+y, x-y]) 1000 [100, 10, 1]
20:58:43 <lambdabot>   [1111,1109,1091,1089,911,909,891,889]
20:58:51 <aavogt>  "import StrictAnal"
20:58:54 <mm_freak> all possible solutions with + and - =)
20:59:08 <mm_freak> > foldM (\x y -> [x+y, x-y]) a [b, c, d]
20:59:09 <lambdabot>   [a + b + c + d,a + b + c - d,a + b - c + d,a + b - c - d,a - b + c + d,a - ...
20:59:23 <kmc> haha aavogt
20:59:31 <kmc> StrictAnal doesn't export anything :/
20:59:42 <aavogt> that's what you think
20:59:56 <SamB_XP> maybe it has instances ?
20:59:58 <ManateeLazyCat> aavogt: GHC will hidden package if it pollutes the namespace automatically?
20:59:58 <ManateeLazyCat> aavogt: Thanks i can use zDecodeString now.
21:00:03 <mm_freak> :bro LazyOral
21:00:11 <mm_freak> =/
21:00:43 <mm_freak> what is that "z" encoding anyway?
21:00:55 <mm_freak> looks like C++ name mangling
21:00:59 <mm_freak> and is equally scary
21:01:00 <kmc> it's GHC name mangling
21:01:02 <dankna> it is, and it serves the same purpose
21:01:10 <dankna> it gets special characters into the symbol table
21:01:11 <aavogt> ManateeLazyCat: no, packages can be hidden or exposed by default depending on how they are registered with ghc
21:01:16 <kmc> but there's better tool support for not caring about it
21:01:43 <aavogt> when you specify the library you can say if it should be hidden or exposed
21:01:50 <kmc> after browsing the ghc package a bit, i think i've decided that Haskell is like sausage
21:01:58 <mm_freak> you need name mangling with haskell?  disregarding UTF-8 names
21:02:06 <aavogt> kmc: it could export stuff: http://www.haskell.org/ghc/docs/6.12.1/html/libraries/ghc-6.12.1/src/StrictAnal.html
21:02:24 <aavogt> mm_freak: symbols like ^%&*(
21:02:24 <mm_freak> lol
21:02:30 <mm_freak> i thought that was a joke
21:02:40 <aavogt> it still is?
21:02:52 <kmc> but at least it's literate haskell
21:03:17 <kmc> "Alas and alack."
21:04:15 <mm_freak> if it is a joke, i don't get it
21:04:31 <Sgeo> What's the difference between Hoogle and Hayoo?
21:04:42 <SamB_XP> Sgeo: color scheme, mostly ;-P
21:04:44 <aavogt> hoogle is more type-oriented
21:04:45 <mm_freak> Sgeo: hayoo searches hackage, hoogle searches the base library
21:04:45 * SamB_XP kids
21:05:00 <SamB_XP> hoogle searches databases, actually
21:05:16 <aavogt> they both search databaseses
21:05:20 <SamB_XP> it's just that it doesn't tend to have them for everything on hackage
21:05:44 <mm_freak> ok, hoogle searches the base library and a limited number of other packages =)
21:05:54 <mm_freak> and there is also a hoogle for gtk2hs, IIRC
21:05:55 * Sgeo should probably add a thingy to his Chrome search engine thingy for Hayoo
21:06:01 <SamB_XP> mm_freak: well, you can add more if you do it locally
21:07:01 <mm_freak> useful
21:13:56 <ManateeLazyCat> aavogt: It's better if hoogle support regular-expression.
21:14:08 <aavogt> does it?
21:16:20 <ManateeLazyCat> aavogt: Hoogle not support regular-expression.
21:16:48 <aavogt> I dunno, but that doesn't seem to be an important feature
21:17:12 <ManateeLazyCat> aavogt: Regular-expression search will save much time.
21:17:23 <ManateeLazyCat> aavogt: Otherwise you need search hoogle result by hand
21:17:25 <aavogt> more helpful would be to specify whether the types you want are results or consumed
21:18:17 <ManateeLazyCat> aavogt: Example, i develop Code-AutoCompleteion Emacs extension for haskell, base on Hoogle, but hoogle don't support regular-expression, so auto-completion not perfect.
21:18:22 <aavogt> since often I find that I have some value with which I don't know what I can convert to, or how I can get it from
21:18:39 <ManateeLazyCat> aavogt: And hoogle can't search package (such as gtk2hs)
21:19:03 <aavogt> the one online can't
21:19:29 <ManateeLazyCat> aavogt: Neither local. Even i have install gtk2hs.
21:19:40 <ManateeLazyCat> aavogt: Perhaps something wrong, that hoogle can't scan it.
21:19:46 <aavogt> well when you build the docs for gtk2hs, you have to specify hoogle
21:19:56 <aavogt> *that you generate the indexes for hoogle
21:20:40 <ManateeLazyCat> aavogt: I see. thanks.
21:21:21 <aavogt> this is especially helpful when the api has lots of typeclasses
21:21:29 <aavogt> *hoogle
21:26:14 <ManateeLazyCat> haddock: internal Haddock or GHC error: /usr/local/share/doc/mtl-1.1.0.2/html/mtl.haddock: openBinaryFile: does not exist (No such file or directory)
21:26:14 <ManateeLazyCat>  
21:27:14 <ManateeLazyCat> brb for lunch, please leave message to me.
21:30:39 <mm_freak> occasionally i see functions with types like:  () -> a
21:30:48 <mm_freak> those functions don't change semantics (like seq, etc.)
21:30:57 <mm_freak> is there any point in having that () argument?
21:33:08 <SamB_XP> the only point is if it makes it easier to pass them to HOFs
21:33:11 <ddarius> mm_freak: They can lead to different sharing behavior in some implementations.
21:33:17 <kmc> or if you want to force that ()
21:33:32 <kmc> look at Control.Parallel.Strategies -- "Done" is just an alias for ()
21:33:41 <SamB_XP> kmc: he said they don't change semantics like seq does
21:33:59 <kmc> right, it'd be a *user* of something like seq
21:34:13 <kmc> also, you can write seq for many concrete types within ordinary haskell
21:34:22 <SamB_XP> kmc: if it uses seq, it changes semantics like seq does!
21:34:36 <kmc> SamB_XP, oh.  he said it about the function and not its use
21:34:39 <Cale> A function of type () -> a will not memoise (automatically)
21:34:47 <ddarius> SamB_XP: I think you are reading too much into what mm_freak said.
21:34:56 <SamB_XP> possibly
21:34:57 <kmc> seqBool x y = case x of { True -> y; False -> y }
21:34:57 <Cale> So it can help if you only very rarely need the value and it is large.
21:35:06 <kmc> :t let seqBool x y = case x of { True -> y; False -> y } in seqBool
21:35:07 <lambdabot> forall t. Bool -> t -> t
21:35:16 <Cale> (and you don't mind recomputing it)
21:35:20 <kmc> mm_freak, do you have an example of such a function?
21:35:29 <ddarius> Cale: That's not necessarily true.
21:35:43 <kmc> yes, i would beware of lifting there
21:35:46 <Cale> Not necessarily, but in practice.
21:36:12 <kmc> won't ghc lift a let past a lambda quite often?
21:36:19 <ddarius> Cale: There were GHC implementations that that wasn't true for.
21:36:24 <kmc> since let is lazy, it's no more work in the case where the function is not applied
21:36:45 <Cale> Oh? Interesting. Of course, you can't say much of a necessitive nature about memory usage of haskell programs.
21:37:08 <kmc> what's the most basic GHC RTS flag for "use more RAM at once and GC less"
21:37:24 <ddarius> -A maybe (?)
21:38:23 <kmc> seems to make things worse :/
21:39:15 <Mathnerd314> what *is* the proper relation between cpu and ram?
21:39:46 <kmc> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24643#a24643 this spends 50% of its time in GC
21:42:51 <mm_freak> kmc: http://hackage.haskell.org/packages/archive/NumberSieves/0.0/doc/html/NumberTheory-Sieve-ONeill.html
21:42:54 <mm_freak> calcPrimes
21:43:14 <mm_freak> the function is defined like:  calcPrimes () = â¦
21:44:00 <kmc> it's what Cale said
21:44:16 <kmc> if you don't want to store the list of primes permanently, you call calcPrimes locally (and get it GC'd later)
21:44:23 <kmc> if you want it memoized, you use the CAF "primes"
21:44:34 <kmc> this is pretty rare in my experience
21:46:49 <kmc> Mathnerd314, what do you mean?
21:47:09 <mm_freak> oh ok
21:47:26 <Mathnerd314> kmc: e.g., a hash table delivers O(1) performance for O(n) memory
21:47:39 <kmc> a hash table delivers O(lies) performance
21:47:40 <kmc> but yes ;)
21:47:41 <mm_freak> btw, recently i was told that i'm confusing the concept of memoization with the concept of sharing
21:47:57 <mm_freak> i'd say that this is sharing, not memoization
21:48:08 <Mathnerd314> yeah, memory is not generally O(n)
21:48:10 <kmc> hmm, then perhaps i am confusing them as well
21:48:15 <Mathnerd314> *O(1)
21:48:23 <mm_freak> kmc: memoization means caching function return values
21:48:35 <SamB_XP> or perhaps sharing is the way memoization is being done here?
21:48:51 <kmc> SamB_XP, with "nthPrime n = primes !! n"
21:48:53 <kmc> we could certainly say that
21:48:57 <mm_freak> SamB_XP: what's memoized?  there are no arguments at all
21:49:00 <kmc> sharing is being used to memoize nthPrime
21:49:09 <mm_freak> ah, ok
21:49:23 <Mathnerd314> kmc: but yeah, with memoization you can compute a function in theoretically o(memory) time
21:49:29 <mm_freak> yeah, that makes senseâ¦  so the sharing of 'primes' is used to memoize nthPrime
21:49:37 <kmc> Mathnerd314, i refer also to the fact that asymptotic analysis is just not that useful for associative containers in the real world
21:49:38 <SamB_XP> or we could do like okasaki, and call the sharing memoization too ;-)
21:50:00 <SamB_XP> kmc: unless you get O(n) or worse
21:50:06 <kmc> yes
21:50:21 <Mathnerd314> kmc: then access_time(memory address) performance
21:50:41 <mm_freak> for most things O(log n) is very fastâ¦  sometimes faster than O(1)
21:50:43 <kmc> but O(log n) vs. O(1) is often insignificant compared to considerations of caching, quality and runtime of hash function, etc
21:51:13 <kmc> the base of the log in log n matters too
21:51:17 <mm_freak> O(log n) usually means a number of conditional branches and that's it
21:51:19 <kmc> in particular 2-ary trees are terrible for cache
21:51:38 <kmc> i think judy's 256-ary node-packed trees are sexy
21:51:58 <kmc> and would rather use something like that instead of a hash in almost any case
21:52:04 <mm_freak> i assume that Data.Map does The Right Thing
21:52:08 <kmc> but i haven't done any profiling
21:52:13 <mm_freak> and Data.Set, too
21:52:17 <mm_freak> because i use them for a lot of stuff
21:52:26 <kmc> mm_freak, profile if unsure
21:52:45 <mm_freak> no need toâ¦  i haven't had performance problems caused by them yet
21:53:02 <kmc> it seems that they are binary trees
21:53:36 <mm_freak> is there any specific reason why few people seem to be interested in implementing hash tables in/for haskell?
21:54:06 <kmc> they're not a good fit for pure functional programming
21:54:15 <kmc> that said, people do plenty of effectful programming in Haskell
21:54:31 <mm_freak> why?  wouldn't the interface look like Data.Map anyway?
21:54:39 <kmc> there's no sharing
21:54:45 <kmc> you have to copy the structure in full when you insert
21:54:50 <kmc> now a hash trie is a better idea
21:54:51 <mm_freak> ah, i understand
21:54:58 <kmc> Clojure has a nice persistent hash trie
21:55:04 <kmc> with sharing between updates
21:55:06 <ddarius> Zobel designed a data structure called a burst trie with the goal of being highly performant and memory efficient for, if I remember correctly, the construction of full-text inverted indexes.  It was pretty good, much better than standard tree/trie based structures.  He also compared it to a simple move-to-front linked hash table with a simple hash function.  The hash table was smaller and faster for that usage scenario.
21:55:53 <ddarius> kmc: There is a Haskell implementation of Clojure's data structure now.
21:55:58 <kmc> ddarius, cool, name?
21:56:06 <kmc> i've been looking for it for a while
21:57:17 <Cale> http://i.imgur.com/za6dI.jpg -- but... but they're so stackable!
21:58:58 <kmc> one thing i wish for is a nice typeclass interface to associative datastructures
21:59:03 <kmc> so it's easy to try different ones for performance reasons
21:59:18 <ddarius> kmc: There's the Edison library.
22:01:09 <ddarius> kmc: http://github.com/ezyang/hamt
22:05:32 <jbapple> ddarius: I think the burst trie is inherently imperative
22:05:53 <ddarius> jbapple: As are hash tables.
22:06:22 <jbapple> IIRC, it uses space-efficient containers (like AVL trees) for trie nodes until they get large enough, then "burst"s them into arrays
22:06:34 <ddarius> jbapple: My point was simply that a relatively simple, but reasonably well-implemented, hash table is an extremely good data structure in cases of linear usage.
22:06:53 * QtPlatypus isn't sure that hash tables are inherently imperative.
22:08:38 <pjina3> hi everybody
22:08:50 <k23z__> hi pij
22:08:52 <pikhq> QtPlatypus: Few data structures are.
22:08:53 <k23z__> hi pjina3
22:09:06 <kmc> hi dr. nick
22:09:15 <k23z__> dr. nick ?
22:09:16 <pikhq> ... Are there inherently imperative data structures?
22:09:22 <kmc> furthermore Haskell should have good support for imperative data structures, too
22:09:31 <kmc> but maybe it's a secondary priority
22:10:02 <pjina3> I try to compile haskell-palatform-2009.2.0.2 but i got this problem : "./Setup" "configure" "--package-db=../../packages/package.conf.inplace" "--prefix=/usr/local" "--with-compiler=/usr/bin/ghc" "--with-hc-pkg=/usr/bin/ghc-pkg" "--with-hsc2hs=/usr/bin/hsc2hs" "--with-happy=../happy-1.18.4/dist/build/happy/happy" "--happy-options=--template=../happy-1.18.4" "--with-alex=../alex-2.3.1/dist/build/alex/alex" "--with-cabal-install=.
22:10:04 <pjina3> ./cabal-install-0.6.2/dist/build/cabal/cabal" "--enable-library-profiling"
22:10:05 <pjina3> unrecognized option `--with-cabal-install=../cabal-install-0.6.2/dist/build/cabal/cabal'
22:10:05 <pjina3> Error:
22:10:05 <pjina3> Configuring the happy-1.18.4 package failed
22:10:05 <pjina3> make: *** [build.stamp] Error 2
22:10:11 <Mathnerd314> kmc: how would that happen? keeping it in a state monad?'
22:10:12 <pikhq> kmc: Yes, Haskell should be the greatest imperative language.
22:10:41 <kmc> Mathnerd314, not like "State" (which is just sugar over a pure-functional state passing)
22:10:45 <kmc> Mathnerd314, I'm thinking ST primarily
22:10:49 <kmc> and IO as a special case of ST
22:10:49 <pikhq> Mathnerd314: We have plenty of imperativeness. It's even first class.
22:11:06 <kmc> pjina3, please paste long texts at hpaste.org or another pastebin site
22:11:39 <pjina3> ok, sorry
22:12:08 <kmc> ST exists so that we can use imperative datastructures with true mutable update within pure functional code
22:12:21 <kmc> (there's another bullet point for the "pragmatic alternative to Haskell" gimmick post)
22:13:20 <Mathnerd314> huh. ST monad sounds cool.
22:13:37 <kmc> it is :)
22:13:41 <pikhq> It is fairly nice when you want mutation.
22:15:23 <kmc> and fairly useless otherwise ;)
22:15:26 <Mathnerd314> I can't figure out what State# or whatever are supposed to be in the source though...
22:15:31 <pjina3> this is my error http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24644
22:15:33 <kmc> Mathnerd314, deep implementation magic
22:15:57 <ddarius> ST, like IO, should be viewed as a black box.
22:16:01 <kmc> in GHC, the implementation of the ST monad is similar to the implementation of the IO monad
22:16:08 <kmc> in fact IO is basically a special case of ST
22:16:38 <pikhq> Mathnerd314: ST is magic. It is the non-one-way IO monad.
22:16:48 <kmc> ST actions live in various self-contained "threads" (conceptual, not runtime) parametrized by this "s" variable
22:17:08 <kmc> IO is implemented as one particular such "thread", distinguished from the rest
22:17:13 <kmc> by instantiating "s" with RealWorld
22:18:00 <pikhq> kmc: So, all other ST things get their own world to mess with, but IO has reality? Neat. :P
22:18:33 <Mathnerd314> huh. So what type would print have in the ST monad?
22:18:44 <pikhq> Mathnerd314: It wouldn't.
22:18:52 <kmc> Mathnerd314, (Show a) => a -> ST RealWorld String
22:19:04 <kmc> but that can't be passed to runST
22:19:06 <kmc> only to stToIO
22:19:11 <kmc> so it's no different from the "print" we have
22:19:23 <Mathnerd314> or (Show a) => a -> ST Console String... if console was a subset of RealWorld?
22:19:24 <kmc> you can very nearly think of:  type IO = ST RealWorld
22:19:47 <pikhq> Mathnerd314: Yes, but that would have pretty much the same effects.
22:19:47 <kmc> Mathnerd314, not sure how that would formalize.  but it's an important long-range improvement to the language to think about such things
22:19:54 <kmc> and make the IO monad more fine-grained
22:20:13 <Mathnerd314> yeah, the Haskell OS ;-)
22:20:24 <kmc> basically, IO gets one special "thread", and runST allows you to get the result of an ST action as long as you can prove (in the type system) that it doesn't care what "thread" it's in
22:20:44 <kmc> which is the same as proving that it doesn't interact with actions outside of what you're runST'ing
22:21:46 <kmc> which makes me wonder about things that would have names like forkST and parRunST
22:21:50 <Mathnerd314> ah. I feel like I'm seeing ST from the inside out :-)
22:21:54 <kmc> indeed
22:22:09 <kmc> if you're familiar with IORef, STRef will be natural
22:22:20 <kmc> the only trick really is in making actions that runST is happy with
22:22:43 <pikhq> And all that that involves is referential transparency.
22:23:56 <kmc> i've discovered a style of Haskell programming that i quite like
22:24:30 <kmc> instead of using lots of typeclasses, i simply fill in a record with operations that refer to an existentially-quantified type
22:24:43 <kmc> and then create records for various specific types
22:24:49 <kmc> dare i call it... object-oriented?
22:24:53 <ddarius> kmc: Congratulations.  You've rediscovered OO
22:24:56 <kmc> ;)
22:25:00 <kmc> OO: now without the suck
22:25:15 <kmc> (except for all the suck that comes with using records)
22:25:29 <aavogt> and existential quantification in haskell
22:25:40 <kmc> what's wrong with existential quantification in Haskell?
22:25:53 <aavogt> it isn't very first class
22:26:03 <ddarius> aavogt: Use hbc.
22:26:05 <kmc> i don't think Haskell quite so thoroughly subsumes traditional OOP as a special case, the way it subsumes traditional imperative programming as a special case
22:26:11 <kmc> we should get working on that ;)
22:26:32 <Mathnerd314> polymorphic . operators ;-)
22:26:33 <kmc> aavogt, do you have an example where this gets in the way?
22:26:52 <ddarius> kmc: Haskell will neven subsume traditional OO, rather, it will be more readily encodeable in Haskell.
22:27:07 <kmc> that's what i mean
22:27:17 <kmc> i suppose it's not perfectly analogous to the imperative case
22:27:28 <kmc> because you can't (usefully, efficiently, realistically) implement the IO monad in pure Haskell
22:27:58 <Mathnerd314> well, you could, if you were running on a lambda machine
22:28:00 <kmc> but the concepts (if not semantics) of pure Haskell are sufficient to capture imperative programming
22:28:43 <ddarius> kmc: Haskell subsumes basic procedural imperative programming because it includes it.
22:28:57 <kmc> > listArray (1,3) (repeat 'x')
22:28:58 <lambdabot>   array (1,3) [(1,'x'),(2,'x'),(3,'x')]
22:29:49 <aavogt> kmc: it means you have to pattern match on values that are existentially quantified, rather than being able to have a function to do that for you
22:29:57 <Mathnerd314> @wn subsume
22:29:57 <lambdabot> *** "subsume" wn "WordNet (r) 2.0"
22:29:57 <lambdabot> subsume
22:29:58 <lambdabot>      v 1: contain or include; "This new system subsumes the old one"
22:29:58 <lambdabot>      2: consider (an instance of something) as part of a general
22:29:58 <lambdabot>         rule or principle [syn: {colligate}]
22:30:47 <Mathnerd314> you can include it... you just need good semantics for overloading
22:31:07 <Mathnerd314> that's all OO is, right?
22:31:15 <ddarius> Mathnerd314: No.
22:31:24 <Mathnerd314> ad-hoc polymorphism...
22:31:36 <ddarius> Mathnerd314: OO has nothing to do with ad-hoc polymorphism.
22:31:55 <Mathnerd314> then what is OO?
22:32:22 <ddarius> Mathnerd314: If you want to use Strachey's terms, OO is inclusion polymorphism.
22:32:54 <ddarius> (or, more precisely, uses inclusion polymorphism)
22:33:16 <kmc> interesting, you can enable "forall" syntax without ScopedTypeVariables
22:33:18 <kmc> didn't know that
22:33:26 <ddarius> Mathnerd314: Things usually associated with OO are subtyping, inheritance, inclusion polymorphism, dynamic dispatch, encapsulation.
22:33:30 <kmc> Mathnerd314, http://www.paulgraham.com/reesoo.html
22:33:36 <kmc> 9 things that OO sometimes is
22:33:50 <kmc> OO was whatever you're selling
22:33:51 <ddarius> I, personally, wolud say that dynamic dispatch is the most central idea of (traditional) OO.
22:33:59 <kmc> in the same way "agile" is now whatever you're selling
22:34:29 <kmc> "dynamic dispatch" is just limited first-class functions
22:34:42 <Mathnerd314> well, I think haskell has OO now through type classes
22:34:49 <aavogt> ddarius: it isn't clear to me how hbc has first class existentials
22:35:14 <kmc> aavogt, how would such a function look?
22:35:30 <kmc> Mathnerd314, let's look at the list
22:36:05 <aavogt> http://www.mail-archive.com/haskell-cafe@haskell.org/msg58249.html
22:36:18 <Mathnerd314> encapsulation -> yes; code looks identical for 1+1 and 1.1+1.1
22:36:28 <aavogt> kmc: it would more or less be an exists keyword
22:37:03 <Mathnerd314> protection -> yes; a function on a type class cannot inspect that type class
22:37:05 <kmc> (1) is existentials (and optionally typeclasses).  (2) is just the module system.  (3) is typeclasses.  (4) is older and more fundamental.  (5) is true enough if by "object" you mean "boxed value" or "valid parametric instantiation" (and you ignore some low-level stuff)
22:37:30 <kmc> (6) is missing (you can and often do make concrete types)
22:38:20 <Mathnerd314> kmc: I don't see how module system helps
22:38:23 <kmc> (7) isn't there (Haskell has no subtyping, glory be) but you can fake it
22:38:36 <kmc> (8) is present to a degree unheard of in mainstream OO languages
22:38:52 <kmc> (9) is a restriction we don't have
22:39:04 <kmc> Mathnerd314, the module system allows you to export a type but not its constructors
22:39:12 <kmc> thus fulfilling (2)
22:39:25 <Mathnerd314> oh.
22:39:35 <kmc> you're right that parametric polymorphism also makes some such guarantees
22:39:41 <Mathnerd314> but that's ADT, not type classes
22:39:42 <aavogt> kmc: that post more or less describes the annoyances of -XExistentialQuantification
22:39:51 <kmc> Mathnerd314, right
22:39:59 <aavogt> or the alternative of writing in a continuation passing style
22:40:06 <kmc> i'm saying that this particular aspect of OO is fulfilled by ADTs
22:40:13 <kmc> aavogt, thanks
22:41:01 <Mathnerd314> kmc: type class-ally, there was just an example with runST  :: (forall s. ST  s a) -> a
22:41:07 * hackagebot Codec-Image-DevIL 0.2.1 - An FFI interface to the DevIL library  http://hackage.haskell.org/package/Codec-Image-DevIL-0.2.1 (LukePalmer)
22:41:09 * hackagebot Codec-Image-DevIL 0.2.2 - An FFI interface to the DevIL library  http://hackage.haskell.org/package/Codec-Image-DevIL-0.2.2 (LukePalmer)
22:41:10 <kmc> Mathnerd314, there's no type class there
22:41:50 <kmc> aavogt, interesting
22:41:58 <kmc> so the objection is that "data" wrappers are needed
22:42:01 <Mathnerd314> well ok, something like (Num a) => a -> a -> a
22:42:15 <kmc> the same objection is relevant to the impending disappearance of ImpredicativeTypes
22:42:19 <kmc> but nobody seems to care much for those
22:42:53 <Mathnerd314> it has to use either the direct arguments or the functions defined in Num
22:43:17 <kmc> right; in particular, it cannot pattern match on its arguments usefully
22:44:07 <ddarius> kmc: People like impredicative types, but GHC's implementation of them was a hack and the developers don't want to do a real implementation.
22:44:34 <Mathnerd314> kmc: so type classes can indeed restrict the implementation, thus giving protection (inability to detect type)
22:44:40 <kmc> Mathnerd314, yeah
22:44:58 <kmc> Mathnerd314, that's also something like (6)
22:44:58 <ddarius> That's paramatricity, not type classes.
22:45:11 <kmc> type classes give you "middle ground" parametricity
22:45:42 <Mathnerd314> ddarius: I thought parametric polymorphism was stuff like [a]
22:46:19 <kmc> you can "desugar" typeclasses into pure parametric polymorphism
22:46:25 <kmc> at least for present purposes
22:46:34 <kmc> for example sort vs. sortBy
22:46:39 <kmc> :t sort
22:46:40 <kmc> :t sortBy
22:46:40 <lambdabot> forall a. (Ord a) => [a] -> [a]
22:46:41 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
22:46:42 <ddarius> Mathnerd314: Um, and does that not also include: Num a => a -> a -> a.  Do you think those a's are very much different from the one in [a]?
22:46:55 <kmc> well, they are pretty different
22:47:23 <Mathnerd314> [a] you can do nothing with a, Num a you can for example call fromInteger
22:47:38 <kmc> (Num a) => a -> a -> a is like
22:47:43 <kmc> this type: (a -> a -> a) -> (a -> a -> a) -> (a -> a -> a) -> (a -> a) -> (a -> a) -> (a -> a) -> (Integer -> a) -> a -> a -> a
22:48:03 <kmc> and Num is a bad example and a bad typeclass ;P
22:48:08 <Mathnerd314> oh.
22:48:08 * hackagebot Codec-Image-DevIL 0.2.3 - An FFI interface to the DevIL library  http://hackage.haskell.org/package/Codec-Image-DevIL-0.2.3 (LukePalmer)
22:48:12 <ddarius> Mathnerd314: Agreed, but as the potential implementation kmc pointed out, these variables are just normal type variables.  They are not some kind of new "object" or "type class" variables.  Both are (implicitly) introduced by the same binder.
22:48:44 <kmc> let's say that "(Ord a) => [a] -> [a]" is like "(a -> a -> Ordering) -> [a] -> [a]"  (if you ignore Ord instances which break its laws)
22:48:50 <kmc> and that's what i was getting at with sort vs. sortBy
22:49:34 <kmc> Mathnerd314, getting a typeclass constraint is like getting the methods of the typeclass explicitly
22:50:00 <ddarius> That list linked above does not (directly) list dynamic dispatch, which, as I said above, is the core of traditional OO in my opinion.
22:50:16 <Mathnerd314> but you can have typeclasses of typeclasses?
22:50:25 <kmc> mapM :: forall a m b. (a -> m a) -> (m a -> (a -> m b) -> m b) -> [a] -> m [b]
22:50:29 <kmc> Mathnerd314, no, what would that even mean?
22:50:34 <ddarius> Mathnerd314: No.  Type classes aren't type (constructors).
22:50:49 <kmc> type classes are not first class
22:51:07 <Mathnerd314> ok, so they can't be used for first-class OO
22:51:08 <kmc> (well, neither are types)
22:51:14 <kmc> what is "first-class OO"?
22:51:20 <Axman6> o.O
22:51:34 <Axman6> who wants OO anyway?
22:51:34 <aavogt> > cycle "first-class "
22:51:35 <lambdabot>   "first-class first-class first-class first-class first-class first-class fi...
22:51:37 * Mathnerd314 has no idea
22:51:52 <kmc> i can think of a few definitions
22:52:03 <kmc> some of which are not really feasible without dynamic or dependent types
22:52:33 <kmc> Python has first-class classes in a way that C++ never could and Java cannot without heavy machinery
22:52:45 <pikhq> aavogt: Oooh, first-class (cycle first-class).
22:52:54 <kmc> fix first-class
22:53:08 <Mathnerd314> I think it's better to look at Self for OO than to look at Python
22:53:31 <rajeshsr> hi
22:53:34 <kmc> hi rajeshsr
22:53:36 <pikhq> Mathnerd314: I'd say the purest example of OO is still Smalltalk.
22:53:40 <rajeshsr> >let f xs ys = foldr (:) ys xs
22:53:54 <rajeshsr> is same as ++, right?
22:53:59 <Mathnerd314> oh, I meant Smalltalk
22:54:07 <Axman6> @src (++)
22:54:07 <lambdabot> []     ++ ys = ys
22:54:07 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
22:54:07 <lambdabot> -- OR
22:54:07 <lambdabot> xs ++ ys = foldr (:) ys xs
22:54:07 <kmc> :t foldr (:) ys xs
22:54:08 <lambdabot> Not in scope: `ys'
22:54:09 <lambdabot> Not in scope: `xs'
22:54:11 * Mathnerd314 is confusing languages
22:54:15 <ddarius> Self OO is not traditional OO.  (It's known as prototype-based v. class-based.  The only mainstream language using prototyped based OO is javascript.)
22:54:16 <kmc> :t \xs ys -> foldr (:) ys xs
22:54:17 <lambdabot> forall a. [a] -> [a] -> [a]
22:54:31 <kmc> and javascript is also the world's most popular functional language
22:54:50 <rajeshsr> hmm, thanks!
22:54:56 <kmc> @check \xs ys -> (xs ++ ys :: [Char]) == foldr (:) ys xs
22:54:56 <lambdabot>   "OK, passed 500 tests."
22:55:21 <jeffwheeler> Woah that's clever.
22:55:26 <rajeshsr> you guys do magic with lamdabot.
22:55:43 <Mathnerd314> poor lambdabot... :-(
22:55:49 <rajeshsr> Where can i read about a fast introduction to lamdabot?
22:55:50 <aavogt> @check \xs ys -> (length xs + length ys < 3) `const` (xs ++ ys :: String)
22:55:50 <pikhq> rajeshsr: Not magic, well-known things.
22:55:51 <lambdabot>   "Falsifiable, after 6 tests:\n\"\\42676\\406569\"\n\"\\505349\\215070\"\n"
22:56:04 <aavogt> @check \xs ys -> (length xs + length ys < 10) `const` (xs ++ ys :: String)
22:56:04 <ddarius> @list
22:56:05 <lambdabot>   "Falsifiable, after 16 tests:\n\"\\1033224\\744811\\659030\\387896\\540151\...
22:56:05 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
22:56:06 <rajeshsr> pikhq, all is magic till ou know that.
22:56:15 <pikhq> Hah.
22:56:25 <kmc> @check \f xs -> map (f :: Char -> Char) xs == foldr ((:) . f) [] xs
22:56:26 <lambdabot>   Overlapping instances for GHC.Show.Show
22:56:26 <lambdabot>                              (GHC.T...
22:56:37 <aavogt> you have to use :->
22:56:51 <kmc> @check \xs -> xs == reverse xs
22:56:51 <lambdabot>   "OK, passed 500 tests."
22:56:53 <kmc> @check \f xs -> map (f :: Char :-> Char) xs == foldr ((:) . f) [] xs
22:56:54 <lambdabot>   Parse error at ":->" (column 25)
22:57:13 <kmc> @check \n -> n == 7
22:57:13 <ManateeLazyCat> Anyone familiar with "GObject-Introspection"?
22:57:13 <lambdabot>   "Falsifiable, after 0 tests:\n0\n"
22:57:19 <ManateeLazyCat> It's maybe a good way to binding Gtk+ to Haskell.
22:57:29 <ManateeLazyCat> ApiGen for gtk2hs is too tired.
22:59:04 <aavogt> @check \f xs -> map (apply f) xs == foldr ((:) . apply f) [] xs
22:59:05 <lambdabot>   Not in scope: `apply'Not in scope: `apply'
22:59:11 <rajeshsr> @check \xs -> xs == reverse xs
22:59:12 <lambdabot>   "OK, passed 500 tests."
22:59:21 <rajeshsr> why is that right?!
22:59:44 <aavogt> @check \f xs -> let apply = Test.QuickCheck.Function.apply in map (apply f) xs == foldr ((:) . apply f) [] xs
22:59:44 <lambdabot>   Not in scope: `Test.QuickCheck.Function.apply'
22:59:51 <ddarius> rajeshsr: Because the default type is [()]
23:00:28 <rajeshsr> ddarius, you mean that is the only test case it uses to test?
23:00:43 <aavogt> it generates test values based on a type
23:01:08 <aavogt> here it defaults to lists of ()
23:01:46 <aavogt> and since there is only one value with type (), any lists containing () are palindromes
23:02:25 <ManateeLazyCat> I maybe develop new Gtk+ binding with GObject-Interospection.
23:03:01 <ManateeLazyCat> GObject-Interospection support all GNOME libraries, awesome.
23:03:01 <rajeshsr> aavogt, hmm, Stupid way to test.
23:03:19 <dobblego> rajeshsr, quite the contrary; a very clever way to test
23:03:19 <jeffwheeler> ManateeLazyCat: I don't know much about it, but that sounds sweet
23:03:20 <aavogt> then you can specify a different type
23:03:24 <dobblego> @check \xs -> xs == reverse (xs :: [Int])
23:03:24 <lambdabot>   "Falsifiable, after 0 tests:\n[1,-2]\n"
23:03:48 <ManateeLazyCat> jeffwheeler: Yes, I have check GOjbect-Interospection documentation, awesome.
23:04:01 <rajeshsr> dobblego, why, you think so?
23:04:09 <kmc> @check \xs -> (xs :: [Char]) == reverse xs
23:04:10 <lambdabot>   "Falsifiable, after 3 tests:\n\"\\237477\\203932\\548321\\93827\"\n"
23:04:11 <ManateeLazyCat> jeffwheeler: Current gtk2hs have support Gtk+ 2.18.3 fully, but too tired.
23:04:19 <kmc> nice counterexample QuickCheck
23:04:23 <aavogt> you have to think when you write tests regardless
23:04:24 <ManateeLazyCat> jeffwheeler: My neck is so hurt because update gtk2hs API.
23:04:36 <kmc> > text "\237477\203932\548321\93827"
23:04:37 <lambdabot>   ð¹¾¥ð±²ò·¡ðº
23:04:40 <dobblego> rajeshsr, yes, I think so; so much so that I use it even when I write Java (I am very averse to the usual clumsy methods)
23:04:41 <ManateeLazyCat> jeffwheeler: But still have *many* libraries in gnome haven't binding.
23:04:45 <kmc> yeah those aren't real characters ;P
23:04:55 <jeffwheeler> ManateeLazyCat: last time I tried playing with Gtk2Hs, about a week ago, all I felt was pain.
23:05:09 <ManateeLazyCat> jeffwheeler: Why?
23:05:12 <ddarius> kmc: All the better to test with.
23:05:18 <kmc> heh
23:05:21 <jeffwheeler> ManateeLazyCat: trying to compile it, then watching it not work at all with Yi
23:05:39 <ddarius> @check (<100000)
23:05:40 <lambdabot>   "OK, passed 500 tests."
23:05:43 <ManateeLazyCat> jeffwheeler: Perhaps some APIs break.
23:05:46 <rajeshsr> dobblego, well, the default type inferred must be [a]
23:05:55 <ManateeLazyCat> jeffwheeler: Yi update is too slow.
23:05:57 <rajeshsr> you mean it interprets it as [()] ?
23:06:02 <dobblego> rajeshsr, no, it's always monomorphic
23:06:08 <ddarius> rajeshsr: It needs to put something for the a.
23:06:12 <jeffwheeler> ManateeLazyCat: definitely, especially the event handling; I started branching Yi to support it, but it required some fairly big changes
23:06:14 <kmc> rajeshsr, you can't check polymorphic properties with QuickCheck
23:06:18 <ManateeLazyCat> jeffwheeler: It's all my fault if break code. I push recently pathc.
23:06:25 <kmc> you have to choose a type and lambdabot somewhat stupidly chooses [()] for you
23:06:29 <ManateeLazyCat> jeffwheeler: Detail.
23:06:30 <aavogt> rajeshsr: what kinds of sensible values do you have of type [a] other than []?
23:06:32 <ddarius> rajeshsr: Also, it's GHC doing the defaulting (using a recently added extension) not QuickCheck.  Before this extension, that would be a type error.)
23:06:33 <kmc> in a real situation you'd write type signatures on your test cases
23:06:36 <ManateeLazyCat> jeffwheeler: Some APIs break is unavoidable.
23:06:48 <kmc> which extension ddarius?
23:06:54 <mm_freak> @check const True
23:06:55 <lambdabot>   "OK, passed 500 tests."
23:06:55 <ddarius> ExtendedDefaulting
23:06:59 <jeffwheeler> ManateeLazyCat: IIRC, it was the event monad stuff. It's a great new design, but it required some rethinking with Yi.
23:07:04 <ManateeLazyCat> jeffwheeler: Are you maintainer of YI?
23:07:31 <ManateeLazyCat> jeffwheeler: Yep, Events module is depracted.
23:07:40 <ManateeLazyCat> jeffwheeler: Use EventM replace, is cleaner way.
23:07:44 <jeffwheeler> ManateeLazyCat: no, but there really isn't a maintainer; I was messing with it for a while last week, but now I'm back from spring break
23:08:02 <jeffwheeler> ManateeLazyCat: yeah, EventM seems great, just haven't had time to go through and replace Yi's event handling
23:08:17 <ManateeLazyCat> jeffwheeler: Do you want EventM library? I have utils library that base EventM.
23:08:33 <ManateeLazyCat> jeffwheeler: Maybe useful to you.
23:08:35 <jeffwheeler> ManateeLazyCat: unfortunately I don't really have time to play with it anymore
23:08:46 <jeffwheeler> ManateeLazyCat: I was on Spring Break from school last week so had lots of time to hack
23:09:02 <rajeshsr> aavogt, test on various "a"?
23:09:05 <ddarius> kmc: ExtendedDefaultRules is the actual LANGUAGE
23:09:11 * ManateeLazyCat pasted "Event.hs" at http://paste2.org/get/755797
23:09:15 <ManateeLazyCat> jeffwheeler: Above code use EventM
23:09:24 <ManateeLazyCat> jeffwheeler: You can have a look.
23:09:25 <jeffwheeler> ManateeLazyCat: thanks
23:09:38 <ManateeLazyCat> jeffwheeler: It's standalone library from my project.
23:10:41 <ManateeLazyCat> jeffwheeler: You just need use `eventKeystorke` in EventM moand.
23:11:05 <kmc> @hoogle asTypeOf
23:11:05 <lambdabot> Prelude asTypeOf :: a -> a -> a
23:11:51 <ManateeLazyCat> jeffwheeler: `eventKeystorke` will return Emacs style keystorke (same as Yi), exmaple "Alt + a" will convert to "M-a"
23:12:13 <jeffwheeler> ManateeLazyCat: alright, thanks
23:12:25 <ManateeLazyCat> jeffwheeler: So you just need compare with your keymap, that's all.
23:12:46 <jeffwheeler> ManateeLazyCat: unfortunately, Yi is pretty tricky there, and I don't even understand all of it
23:13:11 <ManateeLazyCat> jeffwheeler: To be honest, some code in Yi is complicated.
23:13:17 <aavogt> rajeshsr: well if function is polymorphic, you can infer that the exact type that you do put in there doesn't matter
23:13:21 <ManateeLazyCat> jeffwheeler: And not clean enough.
23:13:28 <jeffwheeler> ManateeLazyCat: absolutely, and not really maintained now
23:13:45 <ManateeLazyCat> jeffwheeler: I have project base gtk2hs completely.
23:13:50 <aavogt> of course typeclass constraints sort of invalidate that claim
23:13:51 <jeffwheeler> what?
23:14:11 <ManateeLazyCat> jeffwheeler: But i think whether build a new Haskell binding base on GObject-Introspection?
23:14:22 <jeffwheeler> ManateeLazyCat: I think it'd be interesting, yeah
23:14:29 <ddarius> All you need is some type with more than one value and correctly implemented equality, e.g. Bool, but not () or Double.
23:14:57 <ddarius> Using more than one type of that kind, e.g. Bool and Int, is just a waste of time.
23:15:01 <ManateeLazyCat> jeffwheeler: http://farm3.static.flickr.com/2628/3952175905_9295a7421a_o.png
23:15:07 <ManateeLazyCat> jeffwheeler: http://farm3.static.flickr.com/2800/4448123474_3879e3f878_o.png
23:15:32 <turiya> hi
23:15:43 <jeffwheeler> ManateeLazyCat: what's that?
23:15:50 <ManateeLazyCat> jeffwheeler: After recently udpate Gtk2hs APIs, i was think, this is neat way to update Haskell binding.
23:15:51 <ddarius> (and a correctly implemented Arbitrary instance)
23:15:55 <turiya> what is IOref for?
23:16:01 <ManateeLazyCat> jeffwheeler: Haskell Application OS.
23:16:17 <jeffwheeler> hmm
23:16:27 <ManateeLazyCat> jeffwheeler: Including editor, webkit, file-manager, terminal. etc.
23:16:34 <jeffwheeler> ManateeLazyCat: that's pretty awesome
23:16:54 <ManateeLazyCat> jeffwheeler: For replace Emacs, firefox, etc *completely*!
23:17:12 <ManateeLazyCat> jeffwheeler: Just base Gtk+ don't like Yi have so many backend.
23:18:44 <ManateeLazyCat> jeffwheeler: I have more screenshot about my project, unfortunately, i forgot my Flickr account. :)
23:19:19 <jeffwheeler> ManateeLazyCat: imgur.com?
23:19:53 <ManateeLazyCat> jeffwheeler: I don't want public my screenshot now. :)
23:20:06 <jeffwheeler> ah
23:20:34 <kmc> turiya, mutable variables that you can read and write within the IO monad
23:20:34 <ManateeLazyCat> jeffwheeler: Now, i'm too busy. I will public screenshot when i ready for release.
23:20:43 <jeffwheeler> ManateeLazyCat: I'll be ready :)
23:20:45 <kmc> sorry
23:20:47 <kmc> i mean "mutable cells"
23:20:50 <kmc> to avoid confusino
23:21:00 <ManateeLazyCat> jeffwheeler: But i was think, whether do a new Haskell binding to replace gtk2hs.
23:21:14 <ManateeLazyCat> jeffwheeler: Update Gtk2hs is really really tired.
23:21:28 <kmc> a value of type (IORef a) is the "name" of a "box" which holds a value of type "a".  you can use IOmonad actions to get that value or put a new one in
23:22:05 <jeffwheeler> ManateeLazyCat: fully support that!
23:22:36 <ManateeLazyCat> jeffwheeler: If GObject-Introspection binding is finish, we can use *all* gnome libraries, and not like gtk2hs, event it have support many libraries.
23:22:49 <jeffwheeler> ManateeLazyCat: that sounds great
23:23:24 <ManateeLazyCat> jeffwheeler: I hope new tools just generate runtime interface for call, don't generate any *middle-code* like gtk2hs, need maintainer write code by hand.
23:23:54 <ManateeLazyCat> jeffwheeler: Current, ApiGen not smart enough, i still need write code by hand for complicated C code
23:24:06 <jeffwheeler> ManateeLazyCat: hm?
23:25:17 * ManateeLazyCat pasted "Code compare" at http://paste2.org/get/755815
23:25:18 <ManateeLazyCat> Example above code.
23:25:18 * hackagebot graphics-drawingcombinators 1.4.0 - A functional interface to 2D drawing in OpenGL  http://hackage.haskell.org/package/graphics-drawingcombinators-1.4.0 (LukePalmer)
23:25:19 <turiya> kmc, these are like variables in C?
23:25:45 <ManateeLazyCat> jeffwheeler: ApiGen can't handle, i need write Haskell *middle-code* by hand.
23:25:51 <ManateeLazyCat> jeffwheeler: And this is painful.
23:26:03 <jeffwheeler> yeah
23:26:13 <kmc> turiya, yeah
23:26:21 <kmc> in C (and many other languages), a variable is a name for a cell
23:26:26 <ManateeLazyCat> jeffwheeler: I will check "GObject-Introspection", if it don't need generate *middle-code*, that's really cool way.
23:26:27 <kmc> in Haskell, a variable is a name for a value
23:26:31 <kmc> and certain values are names for cells
23:26:35 <kmc> for example values of type (IORef a)
23:26:42 <ManateeLazyCat> jeffwheeler: But that mean, i need rewrite GUI-library in my project.
23:27:30 <ManateeLazyCat> jeffwheeler: I found gjs (JavaScript bindings based on gobject-introspection.), i even can write javascript in temrinal to control gnome.
23:27:31 <turiya> but i thought state changes dont happen in haskell
23:27:54 <ManateeLazyCat> jeffwheeler: Call below C code like script.
23:28:05 <jeffwheeler> ManateeLazyCat: I think I remember seeing that before; they used it to implement plugins in Epiphany, IIRC
23:28:10 <jeffwheeler> ManateeLazyCat: that's awesome
23:29:18 <ManateeLazyCat> jeffwheeler: I have check "gobject-introspection-repository", it support almost all libraries, including, gtk, cairo, gdk, atk, clutter, webkit, vte, xft, pango, GStreamer. etc
23:30:11 <ManateeLazyCat> jeffwheeler: Maybe "GObject-Introspection" is right way do Haskell binding, and ApiGen not, because that need maintaier speed *so much* time and health on it.
23:30:30 <ski> turiya : it doesn't (and it does)
23:30:37 <ski> it is a point-of-view question
23:31:18 <ManateeLazyCat> jeffwheeler: If i write new binding, that's mean i need refactory GUI-library in my project, and my project will release longer.
23:31:20 <turiya> ski, IORef does change the values
23:31:36 <ski> turiya : e.g., if you write a function `move :: Move -> GameState -> GameState', then that represents a state-change of a `GameState'
23:31:40 <jeffwheeler> ManateeLazyCat: on the other hand, it'd be amazing library for Haskell in general
23:31:51 <ski> turiya : no, it doesn't change the values, it changes the state
23:32:16 <ManateeLazyCat> jeffwheeler: Yep, if i do that, i will merge into Haskell platform, Haskell community need a really stable GUI library.
23:32:27 <ski> turiya : if you have `ref :: IORef Int', then `ref' is always the same *name* of a state cell .. if you change the contents of the cell, the name is the same, it is not changed
23:32:28 <jeffwheeler> ManateeLazyCat: yep
23:32:36 <kmc> turiya, it's totally untrue that Haskell has no side-effects
23:32:42 <ManateeLazyCat> jeffwheeler: Gtk2hs is cool, but not cool enough.
23:32:42 <kmc> turiya, Haskell *functions* have no side effects
23:32:55 <kmc> we have other types (besides functions) for modeling effectful, stateful computation
23:33:01 <ski> turiya : that's why you can compare `IORef a's for equality without "being in the" `IO'-monad
23:33:13 <kmc> IO is one of those types, and IORefs are real, in-place update mutable cells
23:33:27 <ski> kmc : i like to make a distinction between effects and *side*-effects :)
23:33:30 <kmc> sure
23:33:31 <ManateeLazyCat> jeffwheeler: The most people's gripe to gtk2hs is hard to install and update slow.
23:33:47 <jeffwheeler> ManateeLazyCat: and I'd complain that it's not particularly beautiful, either
23:33:48 <ski> (btw, `State s' is also "one of those types")
23:33:59 <kmc> yeah, but the implementation is very different
23:34:01 <kmc> in GHC
23:34:08 <jeffwheeler> ManateeLazyCat: although I can definitely see an argument for beauty belonging on a higher level
23:34:20 <ManateeLazyCat> jeffwheeler: Yep, some code need write by hand line by line, it's really bad to me.
23:34:46 <turiya> kmc, writeIORef is a function right? It has a side effect then?
23:34:57 <ManateeLazyCat> jeffwheeler: I won't update gtk2hs if i know "GObject-Introspection" easier.
23:35:02 <kmc> turiya, writeIORef is a function that returns an IO action
23:35:06 <kmc> so is putStr
23:35:11 <ManateeLazyCat> jeffwheeler: My neck so hurt. :-(
23:35:11 <kmc> applying the function has no effect
23:35:24 <ski> turiya : `writeIORef :: IORef a -> a -> IO ()' is a function that returns an `IO'-action, *without* having any side-effects
23:35:27 <kmc> the thing you get back from applying it is an action, which you can choose to execute or not to execute
23:35:28 <ManateeLazyCat> jeffwheeler: What's busy recently? Yi?
23:35:38 <kmc> turiya, it's important to distinguish evaluation from execution
23:36:04 <ski> turiya : however *executing* that `IO'-action (possibly as part of a larger one) can have side-effects .. but conceptually, that execution is not part of the Haskell evaluation
23:36:06 <jeffwheeler> ManateeLazyCat: Not really. As I said, I played with it last week and updated the Hackage version to work easily, but I've since stopped again after getting back to school and work.
23:36:13 <kmc> the only IO action that gets executed in a Haskell program is the one named "main" in the main module
23:36:29 <ManateeLazyCat> jeffwheeler: Oh, i see.
23:36:32 <kmc> but since actions are just values like any other, you can return them from functions, and glue several actions together to make a bigger action
23:36:38 <kmc> said gluing is done with the "do" syntax
23:36:44 <kmc> or with certain functions like (>>) and (>>=)
23:37:36 <ski> @type do ref <- newIORef 7; writeIORef ref 32; n <- readIORef ref; return n
23:37:37 <lambdabot> Not in scope: `newIORef'
23:37:37 <lambdabot> Not in scope: `writeIORef'
23:37:37 <lambdabot> Not in scope: `readIORef'
23:37:45 <ski> bah!
23:38:06 <turiya> kmc, why did you say that only haskell functions have no side effects?
23:38:10 * ski dislikes that those are not in scope in the type-checker in lambdabot ..
23:38:32 <kmc> turiya, because applying a Haskell function never has a side effect (ignoring certain ugly corners)
23:38:43 <kmc> but there are other values, which are not functions, that describe effects
23:38:51 <kmc> consider: getChar is not even a function
23:38:53 <ski> turiya : evaluating Haskell expressions, including evaluating function calls, never has *side*-effects in haskell
23:39:09 <kmc> it's just an IO action, a "recipe" for how to do some IO
23:39:19 <kmc> evaluating it does not do any IO, in fact it probably does nothing
23:39:23 <kmc> *executing* it will get a character
23:39:39 <ski> turiya : however, that evaluation can result in actions that *represent* effects (and for `IO' the run-time system takes care of actually executing the actions)
23:39:40 <kmc> evaluation is fundamental to how functions apply and how computation is performed in Haskell (or in the lambda calculus, etc)
23:39:49 <turiya> so anything that "returns" IO a is not a function?
23:39:50 <kmc> whereas execution is a concept specific to these IO-recipes
23:39:52 <kmc> turiya, no
23:39:54 <kmc> the function is a function
23:39:57 <ski> @type getChar
23:39:58 <lambdabot> IO Char
23:40:02 <kmc> the value of type (IO a) *itself* is not a function
23:40:10 <ski> @type putChar
23:40:11 <lambdabot> Char -> IO ()
23:40:17 <kmc> putStr is a function.  (putStr "foo") is a "recipe" for how to print a string "foo"
23:40:25 <kmc> just applying that function does no printing
23:40:38 <ManateeLazyCat> jeffwheeler: Good to see you. Bye, i check "GObject-Introspection" detail now.
23:40:49 <jeffwheeler> ManateeLazyCat: later
23:40:54 <ski> @type do ref <- Data.IORef.newIORef (7 :: Int); Data.IORef.writeIORef ref 32; n <- Data.IORef.readIORef ref; return n
23:40:55 <lambdabot> IO Int
23:41:10 <kmc> turiya, you can construct the recipe now, and then use it later or never
23:41:23 <kmc> that's where much of the power of imperative programming in Haskell comes from
23:41:25 <ski> (or use it many times)
23:41:32 <kmc> and why it's actually a good imperative language, better than most of the common ones
23:42:02 <kmc> for/while loops, try/catch, resource bracketing, launching threads... these are all ordinary functions in Haskell, and you can make your own
23:42:10 <ski> @type replicate 10 (putStrLn "Hiya !")
23:42:11 <lambdabot> [IO ()]
23:42:29 <ski> ^ a list of 10 `IO'-actions (all actually being the same action)
23:42:36 <ski> @type sequence_
23:42:37 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
23:43:05 <ski> ^ a function that takes a list of `m'-actions, and returns a combined action that, when executed, executes all the actions in the list, in order
23:43:12 <ski> @type sequence_ (replicate 10 (putStrLn "Hiya !"))
23:43:13 <lambdabot> IO ()
23:43:29 <dmwit> ?src replicateM_
23:43:29 <lambdabot> replicateM_ n x = sequence_ (replicate n x)
23:43:40 <ski> ^ applying `sequence_' to the previous example yields an `IO'-action that performs `putStrLn "Hiya !"' ten times
23:43:49 <ski> turiya : do you follow that example ?
23:44:10 <turiya> kmc, ski - i cant understand much of what u have just said..
23:44:28 <ski> turiya : do you know the `replicate' function ?
23:44:38 <turiya> ski, no
23:44:40 <ski> > replicate 3 "foo"
23:44:41 <lambdabot>   ["foo","foo","foo"]
23:44:56 <dmwit> > replicate 3 x
23:44:57 <ski> > replicate 8 '.'
23:44:57 <lambdabot>   [x,x,x]
23:44:57 <lambdabot>   "........"
23:45:07 <turiya> ok..
23:45:13 <turiya> i get what it does
23:45:27 <kmc> turiya, do you understand that (putStrLn "foo") is a value of type IO ()?
23:45:36 <kmc> this follows from the type of putStrLn itself:
23:45:38 <kmc> :t putStrLn
23:45:39 <lambdabot> String -> IO ()
23:45:52 <ski> so in the example above, i created a list of ten `IO'-actions (namely ten "copies" of the `putStrLn "foo"' action)
23:46:00 <turiya> kmc, i understand that
23:46:24 <kmc> turiya, and do you understand that merely applying the function, as in (putStrLn "foo"), does not cause any string to be printed?
23:46:30 <ski> so far, nothing has been output, there's just a list of dormant `IO'-actions
23:46:52 <kmc> turiya, then i think you get it
23:46:55 <turiya> kmc, yes that is what i think u r calling evaluation
23:46:58 <kmc> yeah
23:47:01 <ski> yes
23:47:09 <kmc> so which part of what we said did you not understand?
23:48:02 <edwardk> :w
23:48:07 <ski> (*awkward*silence*)
23:48:09 <edwardk> hah wrong window
23:48:31 <ski> heya edwardk
23:48:42 <turiya> kmc, dont really know..
23:48:44 <edwardk> how goes?
23:48:53 <edwardk> got my sat solver to compile again
23:49:04 <edwardk> not i just need to bolt all the functionality back in
23:49:33 * ski was recently pondering the property of `R' : `forall a c. (forall b. R a b <-> R b c) -> R a c' .. trying to figure out what it means
23:49:58 <kmc> turiya, ok... well hanging out here can be a bit like standing in front of a firehose of information
23:50:01 <turiya> kmc, i think my problem is with side effects
23:50:03 <kmc> we don't blame you
23:50:27 <turiya> kmc, yeah cud not read all that and make sense
23:50:29 <kmc> turiya, if you like, Haskell has no *side* effects... it just has effects, represented by values of type (IO a) for some a
23:50:34 <dmwit> turiya: Would you like us to pose some simple exercises to help you play with IO?
23:50:38 <kmc> turiya, but you seem to understand it now
23:50:46 <edwardk> ski: trying to parse what you mean
23:50:46 <kmc> at least, it seems that you get the distinction between evaluation and execution
23:50:53 <kmc> and that effects are only associated with execution
23:51:14 <turiya> kmc, is there a definition of side effect?
23:51:16 <edwardk> <-> is an embedding projection pair or isomorphism?
23:52:00 <ski> (that being `IO'-effects .. there's also `Maybe'-effects represented by values of type `Maybe a' for some `a', list-effects represented by `[a]' values, `State s'-effects represented by `State s a' values, ad nauseum)
23:52:41 <ski> edwardk : just biimplication (i'm thinking of there being at most on proof of `R x y' for any `x',`y')
23:53:02 <kmc> turiya, not really
23:53:21 <ski> edwardk : so it is a property of `R', like transitivity or reflexivity .. i'm just trying to come up with examples to get a feel of what it means
23:53:22 <edwardk> so something like -- data R a c where R :: (forall b. (R a b -> R b c, R b c -> R a b) -> R a c
23:53:26 <kmc> turiya, not one that everyone will agree on
23:53:29 <dmwit> turiya: We usually mean things like printing to a console, munging pointers, interfacing with hardware, calling somebody up on the Internet, etc.
23:53:49 <ski> (s/on proof/one proof/)
23:53:56 <kmc> in the case of Haskell, we include things that are not strictly interfacing with the outside world -- like reading and writing mutable variables within the process's own memory space
23:53:57 <turiya> kmc, if side effect is modifying the the value at an address.. then all functions when executed do that internally
23:54:08 <dmwit> ski: Well, for example, all transitive relations satisfy that property.
23:54:11 <kmc> turiya, right.  but the purpose of a programming language is to abstract that away
23:54:21 <kmc> in particular Haskell abstracts away much of the "how" of computation
23:54:33 <kmc> it's a very declarative language... you just describe what functions return for various inputs
23:54:43 <dmwit> ski: Oh, wait... that might not be right. Hum, that is a weird one! =P
23:54:53 <ski> dmwit : .. indeed :)
23:54:55 <kmc> we also include as "effects" things that come from (but do not influence) the outside world, like getting the current time
23:55:06 <kmc> a function that returned the current time would fail to be a function in the mathematical sense
23:55:13 <kmc> because it would return different values for the same input
23:55:27 <kmc> that's really what this is about
23:55:33 <kmc> referential transparency of functions
23:55:39 <turiya> kmc, i think my problems arise becoz of the many tutorials which say haskell has no side effects
23:55:50 <turiya> haskell has no side effects in evaluation
23:55:52 <kmc> meaning that (f x) is always the same for the same x, now and forever
23:56:00 <ski> edwardk : i'm not sure how such a datatype could relate to what i was thinking about .. i was thinking about `a',`b',`c' there being elements of some carrier, and `R' being a binary relation over that
23:56:08 <kmc> turiya, right, i think a lot of people who write about this issue are being sloppy with terminology, and it causes misunderstanding
23:56:12 <turiya> is that more precise?
23:56:15 <kmc> turiya, yes
23:56:18 <kmc> that's exactly what i'd say
23:56:32 <kmc> Haskell has good support for programming with effects
23:56:38 <kmc> that starts with giving them their own type with first-class values
23:56:46 <turiya> kmc, what exactly is evaluation?
23:56:56 <edwardk> ski: ok, i was trying to parse your original statement, and the first thought i had was the above. ;)
23:57:48 <ski> np, i hadn't thought of trying to interpret it as the type of a haskell function (constructor, here), with `a',`b','c' being types ;)
23:57:57 <ski> turiya : simplification of expressions
23:58:01 <dmwit> turiya: How deep down the rabbit hole do you want to go?
23:58:24 <Sgeo> Is System.Concurrent.Chan basically Erlang-style concurrency?
23:58:29 <ski> turiya : `2 + 3' simplifies to `5'; `let f x = x * x in f 3' simplifies to '3 * 3' simplifies to `9'
23:58:35 <turiya> dmwit, not much
23:58:43 <Sgeo> erm, Control.Concurrent.Chan
23:58:48 <turiya> dmwit, just want to know intuitively
23:59:12 <ski> > reverse "abc" -- simplifies to :
23:59:13 <lambdabot>   "cba"
23:59:28 <turiya> ski, a <- getLine, what does evaluation mean there?
23:59:51 <kmc> turiya, that is just syntactic sugar for:
