00:00:06 <kmc> oh, you can pass the action
00:00:06 <kmc> true
00:00:18 <idnar> hahaha, that quote is awesome
00:01:01 <kmc> heh... GHC bug difficulty levels are Easy, Moderate, Difficult, Project, Rocket Science
00:01:48 <Sgeo> StateVar?
00:02:08 <kmc> is a package on hackage
00:02:12 <Cale> Sgeo: It's an abstraction used in the GLUT (and other OpenGL?) bindings
00:02:14 <ManateeLazyCat> What's wrong with code.haskell.org?
00:02:15 <Cale> oh
00:02:17 <kmc> used by (among other things) OpenGL bindings
00:02:22 <kmc> ManateeLazyCat, stolen by underpants gnomes
00:02:27 <Cale> Apparently it's in its own package too now :)
00:02:50 <Sgeo> main = putToSleep sgeo
00:02:52 <kmc> :t ($=)
00:02:53 <lambdabot> Not in scope: `$='
00:02:57 <Sgeo> Night all
00:03:20 <ManateeLazyCat> kmc: I haven't time now, maybe i will binding new gnome library after i release my project.
00:03:21 <kmc> threadDelay 28800000000
00:03:44 <kmc> ManateeLazyCat, i was making a reference to a stupid TV show
00:03:48 <kmc> ;)
00:03:53 <Cale> ghci> :m + Graphics.UI.GLUT
00:03:53 <Cale> ghci> :t ($=)
00:03:53 <Cale> ($=) :: (HasSetter s) => s a -> a -> IO ()
00:03:55 <ManateeLazyCat> :)
00:04:02 <kmc> it seems code.haskell.org is down though
00:04:05 <kmc> and has been for today
00:04:07 <ManateeLazyCat> kmc: You can use gtk2hs/demo/webkit watch TV.
00:04:15 <kmc> can i now
00:04:17 <kmc> i suppose so
00:04:20 <ManateeLazyCat> kmc: Yes.
00:04:33 <kmc> must replace all non-Haskell programs on my machine
00:04:34 <roconnor> @oesis 0,1,0,1,1,0,0,1,0,1,1,1,0,0,0
00:04:35 <lambdabot>  The defining property of the sequences {A, B} = {A000028, A000379} is that t...
00:04:35 <lambdabot>  [0,0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,0,1,0,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,1,1,0,1...
00:04:38 <kmc> sounds good
00:05:01 <Jafet> Buy an STG machine, they get cheaper every day.
00:05:07 <ManateeLazyCat> kmc: I always use that browser, just 96 lines.
00:05:18 <kmc> :)
00:05:18 <ManateeLazyCat> kmc: Works well, of course simple enough for demo. :)
00:05:53 <kmc> finally tagless, partially evaluated
00:06:21 <ManateeLazyCat> kmc: I need a vacation, i'm so tried to binding those APIs, ApiGen not perfect. :)
00:08:15 <ManateeLazyCat> kmc: I have send request to administrator to update page http://www.gtk.org/language-bindings.html
00:09:50 <ManateeLazyCat> kmc: Haskell is few language that support from Gtk+ 2.8 to Gtk2hs 2.18.3 , just C++, Javascript, Vala support fully.
00:10:05 <ManateeLazyCat> I'm so happy. :)
00:11:03 <kmc> cool
00:11:55 <ManateeLazyCat> kmc: Now just gio need update. Then all core libraries is update to newest!
00:16:44 <ManateeLazyCat> How to edit page http://www.mirrorservice.org/sites/www.haskell.org/gtk2hs/ ?
00:19:27 <ManateeLazyCat> Gtk+ 2.20 released?
00:19:56 <paintballmike> anyone here
00:20:02 <Zao> paintballmike: Just us lambdas.
00:23:23 <solrize> zzz
00:23:30 <solrize> oops sorry
00:25:57 <kmc> yo
00:29:57 <o-_-o> how I do something like the C equivalent of printf ('a' + 1) and it prints b
00:30:26 <Jafet> << 'b'
00:30:27 <kmc> > succ 'a'
00:30:28 <lambdabot>   'b'
00:30:31 <Jafet> Er
00:30:39 <kmc> > fromEnum 'a'
00:30:40 <lambdabot>   97
00:30:41 <kmc> > fromEnum 'a' + 1
00:30:41 <dabblego> print (succ 'a')
00:30:42 <lambdabot>   98
00:30:47 <kmc> > toEnum (fromEnum 'a' + 1)
00:30:48 <lambdabot>   * Exception: Prelude.Enum.().toEnum: bad argument
00:30:51 <kmc> > toEnum (fromEnum 'a' + 1) :: Char
00:30:53 <lambdabot>   'b'
00:30:59 <Jafet> :t succ
00:31:00 <lambdabot> forall a. (Enum a) => a -> a
00:31:07 <o-_-o> ah...cool thanks
00:32:02 <kmc> > print (succ 'a')
00:32:03 <lambdabot>   <IO ()>
00:32:51 <Jafet> Hm, what happens when hPutStr fails?
00:33:00 <kmc> fails how?
00:33:09 <Zao> Closed handle? Pie?
00:33:19 <kmc> there is a system of IO exceptions in the standard
00:33:30 <kmc> in GHC this is replaced with a more general system of extensible exceptions, as in Control.Exception
00:33:50 <kmc> you can actually catch anything including "error" calls
00:34:15 <Jafet> Catch it and return 0, else return 1, then it's printf
00:34:34 <Jafet> Actually printf('a' + 1) isn't legal C
00:35:39 <Zao> Jafet: Depends on if you have a definition for printf or not.
00:35:49 <Zao> When all else fails, everyones an int.
00:36:37 <Jafet> I wonder how you duplicate *that* behaviour in haskell
00:37:18 <Jafet> @quote peek
00:37:18 <lambdabot> <kmc> says: head [] = peek . intPtrToPtr . fromIntegral . unsafePerformIO . randomRIO $ (0, 2^32)
00:37:22 <pikhq> Jafet: FFI
00:37:33 <pikhq> And probably an unsafeCoerce.
00:37:48 <Jafet> -XTryImplicitDeclarations
02:01:44 <ivanm> who's responsible for code.haskell.org ?
02:01:51 <ivanm> it appears to be inaccessible... >_>
02:17:41 <ivanm> for some reason, doing "cabal haddock" in the directory of my library doesn't seem to work... >_>
02:21:26 <ivanm> @tell dcoutts if I try to use the new Cabal 1.8 feature of having an executable depend upon the library, then "cabal haddock" fails saying "Can't find transitive deps for haddock"; I have the sneaking suspicion this is because for some reason there's no way of telling cabal-install (that I know of anyway) only to build docs for libraries and not executables
02:21:26 <lambdabot> Consider it noted.
03:13:36 <ivanm> is it possible to catch and error (even if it's within IO)?
03:14:00 <jlouis> ivanm: Control.Exception?
03:14:14 <ivanm> *an
03:15:16 <ivanm> jlouis: you mean ErrorCall?
03:15:42 <jlouis> ivanm: I don't know what you are trying to do
03:16:17 <ivanm> jlouis: I'm wanting to write a test suite that makes sure my parser can parse "real world" files; the parser throws an error if there's a parsing failure
03:16:24 <dobblego> @type catch
03:16:24 <ivanm> as in error "foo"
03:16:25 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
03:16:26 <ivanm> not an exception
03:19:12 <jlouis> ivanm: I would try ErrorCall, yes
03:19:52 <ydo> I'm using the time package to get two timestamp (getPOSIXTime) and their difference, how to convert that difference of type POSIXTime, to a float?
03:21:26 <ydo> or if there is some other portable way to get the timestamps I'll be glad to hear
03:21:48 <ivanm> ydo: using the time library?
03:21:52 <ydo> ivanm: yes
03:21:53 <ivanm> @hoogle getPOSIXTime
03:21:55 <lambdabot> Data.Time.Clock.POSIX getPOSIXTime :: IO POSIXTime
03:22:27 <ydo> you missed the question?
03:22:33 <ivanm> ydo: posixSecondsToUTCTime
03:22:38 <ivanm> and then compare them
03:22:59 <ivanm> ydo: actually, type POSIXTIme = NominalDiffTIme, and NominalDIffTIme is an instance of Num
03:23:05 <ivanm> so you can just subtract one from the other
03:23:16 <ydo> I did.. but then I want a float
03:23:20 <ivanm> ydo: oh, yes :s
03:23:30 <ivanm> I thought you wanted to _get_ the difference :s
03:23:35 <ydo> :)
03:23:36 <ivanm> ydo: why a float (rather than a Double)?
03:23:47 <ydo> no reason, double is fine
03:23:49 <ivanm> ydo: fromRational?
03:23:56 <ivanm> @type fromRational
03:23:57 <lambdabot> forall a. (Fractional a) => Rational -> a
03:24:07 <ivanm> NominalDIffTIme is an instance of Fractional
03:24:20 <ivanm> grrr... which doesn't help
03:24:30 <ivanm> @hoogle (Fractional a, Fractional b) => a -> b
03:24:30 <lambdabot> Prelude recip :: Fractional a => a -> a
03:24:30 <lambdabot> Prelude (^^) :: (Fractional a, Integral b) => a -> b -> a
03:24:30 <lambdabot> Prelude (/) :: Fractional a => a -> a -> a
03:24:38 <ivanm> I know there's a way...
03:24:42 <ivanm> @hoogle Float -> Double
03:24:42 <lambdabot> Prelude realToFrac :: (Real a, Fractional b) => a -> b
03:24:43 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
03:24:43 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
03:24:43 <jlouis> realToFrac
03:24:47 <ivanm> ydo: ^^
03:24:57 <ivanm> oh, the first one has to be Real...
03:25:03 <ivanm> luckily, NominalDiffTime is!
03:25:35 <ydo> great ty jlouis, ivanm
03:25:46 <jlouis> { a <- getPOSIXTime; ...; b <- getPOSIXTime; ...; realToFrac $ b - a }
03:26:35 <ivanm> @. pl undo do { a <- getPOSIXTime; b <- getPOSIXTime; return . realToFrac $ b - a }
03:26:35 <lambdabot> (getPOSIXTime >>=) . ((return . realToFrac) .) . subtract =<< getPOSIXTime
03:26:40 <ivanm> heh
03:27:31 <Twey> Hm
03:27:37 <notsonerdysunny> @hoogle Map
03:27:37 <lambdabot> module Data.Map
03:27:37 <lambdabot> Data.Map data Map k a
03:27:37 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
03:27:55 <Twey> [a, b] <- replicateM 2 getPOSIXTime
03:28:02 <ivanm> @hoogle (l -> l') -> Either l r -> Either l' r
03:28:02 <lambdabot> Data.Graph.Inductive.Graph nmap :: DynGraph gr => (a -> c) -> gr a b -> gr c b
03:28:02 <lambdabot> Control.Arrow (^>>) :: Arrow a => (b -> c) -> a c d -> a b d
03:28:02 <lambdabot> Data.Graph.Inductive.Basic elfilter :: DynGraph gr => (b -> Bool) -> gr a b -> gr a b
03:28:14 <ivanm> grrr...
03:30:06 <wto> haha
03:30:44 <jlouis> heh, the arrow instance ...
03:38:48 <ydo> how to show a double with 2 decimal places precision?
03:39:44 <bremner> ydo: use Text.Printf ?
03:46:18 <MechaBlue> What is a PAP object?  I'm getting a "internal error: PAP object entered!" error when trying to run a program compiled with GHC 6.12.1.  The program works fine when run through GHCi.
03:48:24 <wavewave> could anyone check this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24684#a24684
03:48:32 <Twey> MechaBlue: http://www.haskell.org/pipermail/glasgow-haskell-bugs/2010-January/021907.html
03:48:39 <Twey> MechaBlue: Looks like you should clean your .ghc
03:48:50 <wavewave> why does this fall in infinite loop?
03:49:38 <Twey> wavewave: Because you create an infinite number of actions and attempt to evaluate them all in order?
03:49:47 <pokoko222> someone has done newton method in haskell?
03:50:05 <Twey> Have they?
03:50:17 <wavewave> Twey: but I just take 3 of the result.
03:50:20 <Twey> That's news to me, though I'm not surprised
03:50:32 <Twey> wavewave: Doesn't matter — sequence evaluates all of it.  IO isn't lazy.
03:50:51 <Twey> s/evaluates/executes/
03:50:53 <wavewave> So is it because of IO?
03:51:18 <Twey> I believe you could do it with Control.Monad.State.Lazy and no IO, yes
03:51:35 <wavewave> I see... Thanks a lot!
03:51:59 <wavewave> by the way, is ST monad lazy?
03:52:06 <Twey> No
03:52:30 <Twey> There is a lazy version in Control.Monad.ST.Lazy, though
03:52:52 <wavewave> Ahh. That's good.
03:56:48 <MechaBlue> Twey:  Deleting all of its contents had no effect.
03:58:48 <Twey> MechaBlue: Maybe reopen the ticket?  The resolution says that this should be fixed in .12.1
03:59:26 <MechaBlue> Okay.  I'm trying to create a minimal test case right now.
04:05:48 <zsol> guys, is code.haskell.org down?
04:06:22 <Ke> seems to be the norm nowadays
04:07:36 <mreh> I have no Haskell project... I am an orphan
04:08:26 <Boxo> @pl \xs -> [take n xs | n <- zipWith const [1..] xs]
04:08:26 <lambdabot> return . ap ((<-) . (| n) . take n) (zipWith const [1..])
04:08:44 <mreh> or rather I have no baby, are there any orphan projects out there?
04:08:57 <zsol> lots of
04:09:27 <dmhouse> Is there a quicker way to tell if all elements of a given IntSet match some criterion, than using toList and all?
04:10:14 <Eelis> dmhouse: hm, toList is O(n), so i doubt there's much to be gained
04:10:42 <dmhouse> Eelis: more worried about constant factors, in my application n <= 20
04:10:52 <Eelis> i see, fair enough
04:11:17 * dmhouse suspects the answer is "no" without plying into IntSet internals
04:11:48 <zsol> probably so
04:12:06 <zsol> not sure what kind of quickness do you expect with n <= 20
04:12:12 <Boxo> @pl \_ -> [x+1 <- [0..]]
04:12:12 <lambdabot> const [x + 1 <- [0..]]
04:12:25 <Boxo> @pl \n -> [x+n <- [0..]]
04:12:25 <lambdabot> return . (x +) . (<- [0..])
04:12:34 <mreh> wasn't there some waffle about Machine Learning library in haksell for GSoC?
04:12:58 <Boxo> @pl \n -> [x+n | x <- [0..]]
04:12:58 <lambdabot> return . (x +) . (<- [0..]) . (| x)
04:13:18 <zsol> Boxo: you realize that you can do this with private MSGs
04:13:34 <dmhouse> zsol: normal quickness :) I'm calling it 26456235 times
04:13:44 <Boxo> no I didn't heh
04:18:35 <bremner> hey all, I need some monomorphism advice.  http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=24685#a24685. I don't understand why putting (Eq a)=> ... for state4 shuts the compiler up, but putting (Eq a) => on nibbledup doesn't
04:33:03 <tibbe> kolmodin: you there?
04:40:03 <hape> hi
04:41:09 <ivanm> tibbe: I doubt it; he probably took the weekend off
04:41:10 <ivanm> preflex: seen kolmodin
04:41:11 <preflex>  kolmodin was last seen on #haskell 20 hours, 10 minutes and 17 seconds ago, saying: tibbe: although I also do a lot of gentoo stuff. so my time is divided between these two
04:41:20 <tibbe> ivanm: ah ok
04:41:33 <ivanm> hmmm, but if he talked to you yesterday then maybe not...
04:43:10 <sanxiyn> Is planet.haskell.org down?
04:44:42 <chrisdone> sanxiyn: indeed, as is code.haskell.org, etc. been down for a couple days
04:44:51 <sanxiyn> I see.
04:46:43 <FliPPeh_> Why doesn't anyone restart it? :/
04:47:00 <FliPPeh_> It's been down for days now
04:47:35 <chrisdone> I think the guy who has access to it is vacant
04:48:45 <FliPPeh_> lame
04:49:14 * hackagebot Combinatorrent 0.2.0 - A concurrent bittorrent client  http://hackage.haskell.org/package/Combinatorrent-0.2.0 (JesperLouisAndersen)
04:54:57 <jlouis> \o/
04:55:43 <chrisdone> haha \o/
04:56:49 <jlouis> chrisdone: now with much improvement
04:58:56 <sanxiyn> Torrent?
04:59:00 <Aristid> jlouis: like?
05:00:50 <jlouis> Aristid: read the ann mail on haskell-cafe, or run git show v0.2.0 on the repo
05:01:21 <Eelis> dmhouse: it seems paterson won't budge :(  i better start creating a fresh hotmail account ;)
05:01:40 <jlouis> If I paste it here, 11 IRC demons will come by my house and devour me
05:01:59 <jlouis> and that would have grave consequences for combinatorrent
05:02:20 <jlouis> Eelis: time for nbourbaki@hotmail.com ?
05:02:37 <Eelis> jlouis: heh, a bit overt ;)
05:03:01 <Eelis> but worth a shot. will be fun to see paterson's reation
05:03:04 <Eelis> *reaction
05:04:05 <Aristid> jlouis: normally people would put these notes in a release notes file, too :P
05:05:09 <Eelis> jlouis: hah, it's available!
05:05:31 <sanxiyn> "improvements to the goat teleporter"?
05:06:34 <FliPPeh_> Goat teleporters?
05:06:35 <FliPPeh_> AWESOME!
05:06:40 <jlouis> sanxiyn: mmm, have not begun work on that one yet
05:06:44 <jlouis> wanna start?
05:07:01 <jlouis> Eelis: how about lcarroll@hotmail.com ?
05:07:01 <sanxiyn> jlouis: Cloned the repo, and now reading...
05:08:38 <jlouis> or preage@hotmail.com...
05:08:42 <jlouis> oh, this is fun!
05:12:34 <Eelis> so bizarre that the centuries old tradition of publishing works under pseudonyms is decided to be acceptable no longer by some power hungry database administrator
05:13:25 <jlouis> Eelis: a worthy discussion indeed. Is this the downfall of anonymity?
05:13:43 <Eelis> well no, because a fake name will work fine :)
05:13:44 <FliPPeh_> Never!
05:14:15 <Eelis> it won't be the downfall until the power hungry database administrator demands to see your passport, too :P
05:14:19 <Jafet> Traditionally a chinese luminary would have three names. One given at birth, one chosen by the self, and one given by others
05:14:21 <Vanadium> Well, anonymous self-publishing did not generally involve getting write access to some other guy's database
05:14:44 <Eelis> Vanadium: true enough, the real problem is with the centralized model
05:15:27 * hackagebot starrover2 0.0.9 - Space simulation game  http://hackage.haskell.org/package/starrover2-0.0.9 (AnttiSalonen)
05:15:48 <chrisdone> ahh, so that's the reason _why never got into Haskell
05:15:56 <sanxiyn> Jafet: I recall those are called 名, 字, 號, respectively.
05:15:56 <chrisdone> he couldn't contribute!
05:16:37 * ivanm doesn't see why people would want to anonymise their Haskellian contributions
05:16:51 <sanxiyn> ivanm: Why not?
05:17:20 <Jafet> There is a difference between anonymity and pseudonymity.
05:17:29 <ivanm> sanxiyn: because who is that ashamed of who they are that they wouldn't be proud of the work they've done for the Haskell community?
05:17:29 <Vanadium> Maybe their day job is working for The ML Comapany
05:17:30 <jlouis> ivanm: if your real name is NataliePortman?
05:17:44 <ivanm> jlouis: *shrug* so?
05:17:46 <chrisdone> sanxiyn: http://meatballwiki.org/wiki/RealNameUserAdvantages contains good reasons why real names are beneficial, but you could really substitute "real name" with "consistent pseudonym"
05:17:59 <idnar> Jafet: you can treat anonymity as a degenerate case of pseudonymity
05:18:06 <Eelis> ivanm: hah, what an utterly bizarre assumption (that people who publish under pseudonyms are ashamed of their work)
05:18:18 <ivanm> Eelis: *shrug*
05:18:18 <idnar> (just use a new pseudonym each time, FSVO "each")
05:18:32 <ivanm> I always have trouble matching up the non-name-related nicks here with -cafe, etc.
05:18:35 <sanxiyn> ivanm: Well maybe they are top secret agent whose name shall not be revealed.
05:18:52 <ivanm> *cough bullshit cough*
05:18:54 <chrisdone> idnar: that's the problem with it. real names are just consistent names that can gain reputation, trust, etc. a pseudonym can do that
05:19:04 <idnar> chrisdone: sure
05:19:26 <idnar> chrisdone: although, if you're going to pick a pseudonym, "John Smith" works a lot better than "TeH_L33t_GUY" or whatever
05:19:37 <sanxiyn> ivanm: I recall one famous science fiction writer wrote under pseudonym because he^H^Hshe worked at CIA.
05:19:47 <idnar> (preferably something even less fake-sounding than that)
05:19:50 <sanxiyn> I think James Tiptree Jr.
05:19:52 <pookleblinky> Cordwainer Smith?
05:19:55 <Vanadium> My favourite pseudonym has 0x539 in it, is that acceptable idnar
05:21:10 <idnar> anyway, I don't mind other people using pseudonyms, but it goes more smoothly if you don't throw it in people's faces; if done correctly, nobody even notices
05:21:21 <sanxiyn> Indeed.
05:21:23 <idnar> I don't generally use them myself, since it's too much effort except in special cases
05:21:43 <Eelis> i have no objection at all to a nickname policy saying you can't use "jIJ879{}L!!" as a nickname
05:22:04 <idnar> it's so very very hard to avoid exposing links between your nyms
05:22:05 <Eelis> but that's quite a different policy from "we demand that you use your real name"
05:22:15 <Vanadium> Eelis: Where do you draw the line? Is Frodo Baggins an acceptable nickname?
05:22:22 <Eelis> Vanadium: absolutely
05:22:29 <Eelis> Vanadium: the line can be drawn with a simple regex :)
05:22:45 <mmaruseacph2> how do you define iy?
05:22:48 <mmaruseacph2> *it
05:23:19 <Vanadium> Now to see if Data.Ring is still available...
05:23:34 <Eelis> mmaruseacph2: i leave that up to your imagination. i hope you don't seriously doubt that it's possible
05:23:47 <Jafet> A simple perl regex
05:24:06 <mmaruseacph2> i only caught the end of the discussion
05:24:20 <mmaruseacph2> i need only a guide to what limit you want to be defined
05:25:01 <Eelis> mmaruseacph2: i was merely being sympathetic to idnar, who stated he disapproved of nicknames such as "TeH_L33t_GUY"
05:25:30 <mmaruseacph2> ah, i agree with both of you on this matter
05:26:14 <ivanm> the way I see it: a student at ANU was able to look up my name as a tutor and find out that I was involved in the Haskell community; because of that she trusted me enough to get my advice on what she should do about having problems learning Haskell in the course
05:26:26 <ivanm> if you use a pseudonym, that kind of stuff isn't possible
05:26:39 <idnar> ivanm: reputation cuts both ways
05:26:46 <Eelis> "X can offer benefits. therefore Y must be forbidden" ?
05:29:21 <TeH_L33t_GUY> Reputation cuts both ways indeed.
05:29:29 <sanxiyn> oops
05:29:42 <idnar> heh
05:29:53 <idnar> sanxiyn: oh no, I think you gave yourself away!@
05:30:00 <felzix> How do I import Data.Set so cabal will let me use it?
05:30:05 <felzix> I get: Could not find module `Data.Set':
05:30:06 <felzix>       it is a member of the hidden package `containers-0.2.0.1'
05:30:31 <sanxiyn> Someone found out that long time ago I was involved in Elvish language flamewar (don't ask) and thought I was very strange
05:30:36 <Jafet> Eelis, pretend to be a teenage girl, that always works
05:30:46 <sanxiyn> Jafet: Does it?
05:31:02 <Jafet> @vixen What do you think?
05:31:03 <lambdabot> i do occassionally, i guess
05:31:10 <Eelis> actually i have my fake account and request email ready to go. i'm only waiting for the discussion on haskell-cafe to resolve.
05:31:14 <FliPPeh_> Like, totally
05:31:24 <mmaruseacph2> sanxiyn: elvish? :) same here:D
05:31:43 <Jafet> Which elvish?
05:31:50 <sanxiyn> mmaruseacph2: Elen siila luumenna omentielvo
05:32:01 <Vanadium> Quenya I hope :I
05:32:34 <Jafet> Quenya is respectable, Sindarin is a grey area
05:32:56 <mmaruseacph2> Anor sila tilameno
05:33:08 <mmaruseacph2> i was more interested in sindarin though
05:33:38 <bremner> *cough* #haskell-blah *cough*
05:33:40 <Jafet> I will have immense respect for any person who can participate in a flamewar in Dwarvish
05:34:28 <mmaruseacph2> If there were books on Dwarvish when I got into Tolkien I would have learnt that language
05:35:52 <FliPPeh_> Rather learn Na'vii
05:36:06 <FliPPeh_> Or Klingon
05:36:16 <FliPPeh_> Those are fun
05:36:18 <sanxiyn> mmaruseacph2: Some of my Sindarin composition (hah that was long time ago...)
05:36:21 <sanxiyn> mmaruseacph2: http://groups.yahoo.com/group/elfling/message/12494
05:37:01 <ivanm> idnar: true; but if you're stupid enough to do something that you don't want to be associated with, then who do you have to blame?
05:37:05 <benmachine> felzix: cabal only uses packages that appear in the build dependencies field of the current building thing
05:37:22 <benmachine> felzix: it hides everything else
05:37:23 <mmaruseacph2> sanxiyn: it's very cool:)
05:37:34 <Vanadium> ivanm: That seems like a very broad argument against the right to privacy
05:37:41 <benmachine> felzix: so put containers >= 2 && < 3 in Build-dependencies:
05:37:51 <benmachine> er
05:37:54 <benmachine> Build-depends:
05:37:54 <idnar> ivanm: well, to take your example, in some circumstances I can imagine association with the Haskell community would be a bad thing :P
05:38:06 <ivanm> Vanadium: OK, let me clarify that: don't do something signed in/named/etc.
05:38:12 <ivanm> idnar: how?
05:38:32 <ivanm> if that is going to have a detrimental effect on your job, then you've got a shitty job
05:38:33 <benmachine> Vanadium: I keep forgetting who you are
05:38:38 <idnar> ivanm: sure, in a perfect world, you wouldn't have that problem; but sometimes things don't work out that way
05:38:39 <benmachine> you may view this as a good or a bad thing
05:38:46 <benmachine> Vanadium: (I have now remembered)
05:39:00 <idnar> ivanm: now, personally, I try to be as transparent as possible, but I think people should be free to make the opposite choice
05:39:04 <Vanadium> :3
05:39:17 <ivanm> *shrug* artificial barriers decrease communication, etc.
05:39:26 <Vanadium> I do not have anything uploaded to hackage, so I am not worth remembering, anyway
05:39:27 <benmachine> ivanm: a lot of people have shitty jobs
05:39:39 <benmachine> Vanadium: :( by that metric nor am I
05:39:44 <idnar> and, well, there are some things I don't flaunt
05:39:52 <benmachine> I submitted a bug to GHC once! am I interesting yet
05:40:13 <FliPPeh_> I constantly spam this channel with question.. am I rememberable?
05:40:18 <idnar> they're there if you go digging a little for them, but they're intentionally a little harder to find
05:40:25 <FliPPeh_> s/question/questions
05:40:30 <ivanm> benmachine: yet if you consider your job shitty, then why do you not try to replace it?
05:40:59 <Jafet> The world doesn't abound and overflow every corner with nice jobs
05:41:00 <benmachine> ivanm: many people do and fail
05:41:11 <benmachine> ivanm: hell, a lot of people don't have a job at all
05:41:17 <ivanm> true
05:41:41 * ivanm has his own opinions on that matter, but it probably isn't polite to bring them up
05:41:58 <benmachine> FliPPeh_: sorta?
05:42:08 <FliPPeh_> benmachine: Yay!
05:42:28 <benmachine> I view people who constantly spam the channel with questions
05:42:37 <benmachine> as just being a few months from those who constantly spam it with answers
05:42:40 <benmachine> so whatever :P
05:42:45 <FliPPeh_> :)
05:43:05 <FliPPeh_> I already spam a few answers, too.
05:43:06 <felzix> benmachine: Awesome, that (mostly) works. Thank you!
05:43:32 <benmachine> then we are much alike!
05:44:45 <FliPPeh_> Bro-five!
05:45:12 <benmachine> :)
05:50:29 <felzix> there's no cabal uninstall, is there?
05:50:50 <byorgey> felzix: nope
05:50:56 <byorgey> use ghc-pkg unregister
05:51:24 <felzix> sorry, I want to uninstall a haskell package installed via cabal, not uninstall cabal itself
05:51:48 <byorgey> right, I knew what you meant
05:52:06 <byorgey> ghc-pkg unregister package-3.5.2 or whatever
05:52:21 <byorgey> possibly with the --user flag to unregister a package that you installed locally
05:52:56 <byorgey> of course that doesn't actually remove the package itself, you just have to use rm for that.
05:52:56 <felzix> oh, ok
05:53:03 <felzix> ah, I see
05:53:08 <FliPPeh_> I think there should be "cabal remove"
05:55:00 <byorgey> yes, that would be nice
05:55:23 <byorgey> but right now cabal doesn't keep track of where things have been installed
05:55:26 <FliPPeh_> Manually tracking files is inefficient
05:56:10 <FliPPeh_> Isn't there a way to run files within a subshell that racks directory and file accesses?
05:56:17 <FliPPeh_> tracks*
05:56:28 <FliPPeh_> I think fakeroot does that
05:56:28 <felzix> ok, so "cabal install" by itself doesn't add cabal files into the global library namespace
05:56:44 <felzix> is there a way to do this?
05:56:45 <idnar> FliPPeh_: that sounds more like checkinstall
05:57:12 <idnar> FliPPeh_: but, bleh, I'd rather have files installed in a more structured manner
05:57:31 <idnar> then again, I already have a package manager :P
05:57:34 <FliPPeh_> Like on a per-package basis
05:57:53 <FliPPeh_> With each package's libs and bins inside a folder named that package
05:58:02 <FliPPeh_> And symlinks within a directory in $PATH
05:58:10 <FliPPeh_> But that wouldn't work on windws :/
06:02:42 <chrisdone> heh, funny error
06:03:02 <chrisdone> I had non-exhaustive patterns, instead of telling me in normal code, it gives me some funny core code
06:03:41 <chrisdone> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24688
06:04:07 <FliPPeh_> :)
06:04:35 <chrisdone> I've never noticed that before
06:07:37 <turiya> hi
06:09:58 <chrisdone> heyo
06:10:08 <turiya> can somebody help tell me whats wrong with this code http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24690#a24690
06:10:49 <Eelis> turiya: what makes you say there's something wrong with it? is there an error? if so, paste it along with the code
06:11:04 <Eelis> or is the output not as you expected? if so, again, paste expected and actual output along with the code
06:12:50 <turiya> Eelis, i got a parse error
06:13:36 <Eelis> turiya: then see the second part of my first message.
06:13:58 <turiya> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24691#a24691
06:14:03 <turiya> thats the error
06:14:26 <turiya> i think i am doing something fundamentally wrong
06:14:36 <Eelis> hm, i think you may be falling victim to Haskell's awkward indentation rules
06:14:42 <Eelis> try putting "g a b" on a line of its own
06:15:23 <turiya> that does not work
06:15:38 <turiya> can i used guards like that in "where"
06:16:01 <Eelis> oh wait, you use == instead of =
06:16:14 <Eelis> (on lines 6-8)
06:16:47 <Twey> Guards don't require indentation at all
06:17:17 <turiya> Eelis, I did that, i got Not in Scope ~=
06:17:19 <Twey> > let f n | n < 0 = "SMALL" | n > 0 = "BIG" | otherwise = "ZERO" in (f $ negate 1, f 0, f 1)
06:17:20 <lambdabot>   ("SMALL","ZERO","BIG")
06:17:38 <Eelis> turiya: well that's really an orthogonal problem. what ~= are you trying to refer to?
06:18:01 <turiya> isnt ~= not equal to?
06:18:04 <Twey> No
06:18:10 <Twey> That's /=
06:18:17 <turiya> oops..
06:18:20 <Twey> =~ is regex match
06:18:25 <Twey> I don't know of anything that defines ~=
06:19:23 <orlandu63> ~= is bitwise not
06:19:24 <orlandu63> i think
06:19:26 <Eelis> Twey: here's an example of a case where guards need a very specific indentation for the code to parse: http://codepad.org/EH5yQtDt
06:19:42 <Eelis> (it does not compile; the guards need more indentation)
06:20:02 <turiya> that still does not solve the problem
06:20:42 <Twey> Eelis: Really?  Hm, okay
06:21:14 <Eelis> i know, it's crazy :)  i hate Haskell's layout rules.
06:21:15 <Twey> orlandu63: Nope
06:21:27 <Twey> turiya: What is your problem?
06:22:04 <Twey> turiya: Is this what you're attempting to write?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24690#a24693
06:22:22 <turiya> ok..
06:22:24 <turiya> solved
06:22:31 <Twey> I think the type is wrong, though
06:22:35 <turiya> i messed up the types
06:22:38 <turiya> Twey, yeah
06:22:46 <Twey> Ah, right
06:23:29 <Twey> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24690#a24694 — like this?
06:23:52 <chrisdone> hmm. can you tell ghci which package to use for a given module?
06:24:06 <chrisdone> Could not find module `Control.Monad.Trans':
06:24:06 <chrisdone> it was found in multiple packages: transformers-0.1.4.0 mtl-1.1.0.2
06:24:47 <Twey> chrisdone: You can… I think you can use the package import syntax in GHCi (import "transformers" Control.Monad.Trans)
06:24:53 <turiya> Twey, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24690#a24695
06:25:18 <Twey> turiya: Yeah, that's equivalent to what I posted, just longer :þ
06:25:28 <chrisdone> Twey: doesn't work
06:25:30 <Twey> (and with more redundancy)
06:25:34 <Twey> chrisdone: Hm, damn
06:25:47 <chrisdone> maybe I can pass it as a flag on ghci's start-up
06:26:21 <turiya> Twey, i did not understand what u wrote :)
06:26:37 <Twey> turiya: Why not?
06:26:45 <Twey> It's just simple guards
06:26:58 * hackagebot uri 0.1.3 - Library for working with URIs  http://hackage.haskell.org/package/uri-0.1.3 (JaroslavGridin)
06:27:05 <turiya> how can the function take four arguments?
06:27:16 <Twey> Oh, you don't understand currying?
06:27:22 <Twey> No Haskell function takes more than one argument
06:27:32 <chrisdone> bah, doesn't make a difference
06:27:37 <Twey> a -> b -> c means a -> (b -> c)
06:27:42 <turiya> Twey, i have no idea what currying is
06:27:51 <Twey> That is, the function takes an a, and returns a function that takes a b and returns a c
06:27:51 <chrisdone> I'll have to temporarily hide transformers
06:28:02 <pmaes_> chrisdone: I think you can hide one of the packages using ghc-pkg hide and use ghc-pkg show later to unhide
06:28:14 <koeien> I think that'd be expose
06:28:16 <pmaes_> No idea if this is recommended practice though
06:28:28 <chrisdone> pmaes_: yehI did that
06:28:40 <Twey> > let addOne = (+) 1 in addOne 5 -- turiya
06:28:41 <lambdabot>   6
06:28:53 <Twey> :t (+)
06:28:54 <lambdabot> forall a. (Num a) => a -> a -> a
06:29:06 <chrisdone> be alright if you could tell ghci to ignore certain packages
06:30:04 <chrisdone> Twey: http://www.chrisdone.com/posts/2010-04-04-tweet-your-haskell-errors.html
06:30:08 <Twey> Here, we pass the first a to get a function (a -> a)
06:30:18 <chrisdone> Twey: have you got the nads to have your ghci tell the world upon compile errors? :p
06:30:30 <Twey> chrisdone: Yeah, I saw it
06:30:40 <Twey> Psht, my code always compiles first time!  ;)
06:30:46 <pmaes_> chrisdone: Have you tried 'ghci -ignore-package' ?
06:31:54 <chrisdone> pmaes_: ohh, perfect! i used :set -ignore-package transformers
06:32:02 <Twey> turiya: f x y = … is sugar for f = \x y -> …, which is sugar for f = \x -> \y -> …
06:34:07 <turiya> Twey, i understand somewhat
06:34:19 <byorgey> chrisdone: funny idea, but honestly I think it would make me much *less* productive
06:39:22 <Twey> turiya: So, likewise, f x = g where g y = … is exactly the same as f x y = …
06:42:45 <sanxiyn> jlouis: Downloaded first torrent with Combinatorrent...
06:43:33 <sanxiyn> What does "Torrent Completed; to honor the torrent-gods thou must now sacrifice a goat!" mean?
06:44:36 <Twey> sanxiyn: It means that the poor unfortunate who wrote your torrent client was an American
06:45:01 * sanxiyn is confused
06:45:10 <Twey> Also, that you should take a live goat, cut its throat with a ceremonial knife, burn its organs on a sacrificial fire, and then feast upon its flesh
06:45:30 <sanxiyn> Not red heifer?
06:46:17 <EvanR-work> @hoogle imap
06:46:17 <lambdabot> No results found
06:46:23 <Twey> I think that would work
06:50:37 <tibbe> What's the ST equivalent to unsafePerformIO?
06:50:53 <tibbe> I want the execution to be interleaved
06:51:11 <tibbe> so not runST
06:51:32 <fax> unsafeIOToST . unsafeInterleaveIO . unsafeSTToIO
06:51:34 <Twey> Control.Monad.ST.Lazy.runST
06:54:24 <Jafet> In other language channels when you ask to do an unsafe thing you are promptly corrected. In #haskell people tell you several ways to do it
06:54:43 <Twey> It's not unsafe with ST
06:55:02 <jlouis> sanxiyn: congratulations. I am happy it works in places other than here
06:55:04 <Twey> (and there's only one proper way to do it, which is to use ST.Lazy)
06:55:45 <Jafet> It isn't? Hrm
06:56:21 <EvanR-work> when passing a do construct into a function i either have to use parentheses or use a $, even if it looks like it should work anyway. but then theres action `catch` do..., and doesnt need a $, so im even more confused
06:56:33 <EvanR-work> that is to say, when used with an operator
06:57:11 <EvanR-work> well `catch` \e -> do
06:58:29 <Axman6> Jafet: ST is safe IO, no actual IO happens, except variable and array mutation
06:59:43 <EvanR-work> if no 'I' happens, then how is it useful
06:59:49 <Jafet> fsvo safe
07:02:34 <mercury^> And fsvo IO.
07:04:08 <Twey> EvanR-work: It allows you to express imperative algorithms using mutable state, and automatically wrap them in a safe pure container that guarantees that what goes on inside it won't give your code impure semantics, so it can be used as a pure function
07:04:55 <EvanR-work> Twey: can is use results of executing input commands?
07:05:22 <EvanR-work> or is it deferred until later
07:06:04 <Twey> EvanR-work: No, that's IO
07:06:17 <Twey> It doesn't do IO.  It does state transformation.
07:06:37 <fax> what shall I do to day
07:06:44 <EvanR-work> but tibbe wanted to do IO in there
07:06:59 <Twey> Says who?
07:07:02 <tibbe> EvanR-work: I don't :)
07:07:05 <EvanR-work> oh
07:07:09 <tibbe> sorry
07:07:12 <Twey> If you want to do IO, you should be using IO, not ST
07:07:15 <EvanR-work> unsafePerformIO suggestd that
07:07:22 <Twey> Note ‘equivalent to’
07:07:58 <tibbe> the story is: I'm converting a Builder monoid ala Data.Binary.Builder to use ST instead of IO
07:08:11 <tibbe> I think runST is the right thing now
07:08:24 <tibbe> possibly the lazy variant
07:13:08 <jmcarthur> actually, you can even mix IO and ST if you are able to use stToIO
07:13:19 <jmcarthur> but that might be stretching it, calling it "mixing"
07:13:34 <fax> yeah but
07:13:37 <fax> ST is just IO
07:13:43 <jmcarthur> internally
07:13:51 <fax> so rather than use STRefs you can use IORefs
07:14:23 <jmcarthur> right, but the advantage of using stToIO is that you end up with more ST functions, which could be used in non-IO contexts
07:14:44 <jmcarthur> still, only works for algorithms where you don't actually *mix* the IO in with the STRefs
07:16:16 <jmcarthur> wait, i'm wrong
07:16:38 <jmcarthur> you could just use STRef RealWorld as an IORef
07:16:45 <Eelis> hm, do i understand correctly that hlint really only looks at the source of a file without trying to resolve references to variables/operators?
07:16:53 <jmcarthur> i was dumb for a second there
07:17:13 <jmcarthur> Eelis: i believe it is purely syntactic
07:17:26 <jmcarthur> could be wrong
07:17:31 <Eelis> jmcarthur: then won't it get confused by operators imported from other modules of which it cannot know the fixities?
07:18:06 <jmcarthur> Eelis: i seem to recall it doing that to me once, but my memory could be bad
07:18:12 <jmcarthur> hence, i could be wrong
07:18:16 <Eelis> ok
07:20:18 <EvanR-work> hlint eh
07:20:24 <EvanR-work> @hoogle hlint
07:20:24 <lambdabot> No results found
07:21:15 <Eelis> jmcarthur: i just tried. i ran it on some of my source files, and it does indeed seem to get confused by (x == y ∨ a == b) where ∨ is an operator i import from Prelude.Unicode
07:21:26 <Eelis> it says: "hlint: Ambiguous infix expression"
07:21:42 <Eelis> pity, hlint sounded like it could be a useful tool
07:21:49 <jmcarthur> Eelis: but ghc doesn't complain about it?
07:21:55 <Eelis> jmcarthur: no, it's perfectly fine
07:21:58 <jmcarthur> aw
07:22:13 <Eelis> ghc knows the fixity because it actually does the import :)
07:22:15 <jmcarthur> that sucks. thanks for the followup
07:25:22 <Eelis> so perhaps someone should make a power-hlint that can resolve references to find out fixities of foreign operators. haddock can do it, after all :)
07:27:02 <benmachine> Eelis: hold on, Prelude.Unicode? maybe it's worth checking if it does a similar thing with ascii operators
07:27:13 <Eelis> benmachine: i'll try
07:27:21 <benmachine> it may be that it's failing to realise it's an operator at all, in which case it would be ambiguous
07:27:49 <Eelis> benmachine: same thing with operator **********
07:27:57 <benmachine> oic
07:28:03 <benmachine> seems a bit like a bug
07:28:23 <Eelis> i tend to agree, seeing as how it makes hlint unusable for me :)
07:29:13 <Eelis> (without adding lots of extra parentheses everywhere where hlint doesn't have built-in knowledge of an operator)
07:37:12 <fax> > 1+1
07:37:13 <lambdabot>   2
07:46:35 <Eelis> benmachine: it's probably a known problem. unfortunately i cannot verify because community.haskell.org is down (as part of Haskell's "avoid success at all cost" policy, no doubt ;) )
07:57:44 <agasdfgasdfsd> Someone who is native english speaker tell me if statement "PASCAL's beginners language" is correct and means the same that "Pascal is beginners language" ?
07:58:54 <fax> agasdfgasdfsd - it doesn't
07:58:58 <sepp2k> It is correct and means The beginners language by Pascal
07:58:59 <byorgey> agasdfgasdfsd: no, you would have to say something like  "PASCAL is a beginners language"
07:59:00 <ivazquez|laptop> It means "(belonging to PASCAL) beginners language".
07:59:17 <fax> PASCAL: The beginners languages
07:59:18 <sepp2k> "Pascal is beginners language" is incorrect because it's missing an article.
07:59:22 <koeien> you would need an article anyway
07:59:44 <agasdfgasdfsd> hmm I want to gen acronym like GNU's not unix
07:59:53 <fax> how
08:00:02 <agasdfgasdfsd> so how to do that with that pascal crap
08:01:58 <byorgey> agasdfgasdfsd: "PASCAL's a beginners language" would be correct (if somewhat informal)
08:01:59 <fax> PASCAL - another slightly crazy attempted language?
08:02:11 <agasdfgasdfsd> heh thx
08:03:21 <agasdfgasdfsd> i am creating very simple scripting language for my system and I need name for it, any help?
08:03:32 <fax> call it PASCAL
08:03:46 <agasdfgasdfsd> :( i heard it was already taken
08:03:54 <fax> why should that stop you
08:04:04 <agasdfgasdfsd> bad fame of pascal
08:05:51 <koeien> pascal is not the world's worst programming language imo, although this is wildly offtopic
08:06:10 <agasdfgasdfsd> ye
08:06:23 <osfameron> call is "paskell" so that people can confuse it with both pascal and haskell ?
08:07:23 <agasdfgasdfsd> but it doesn't have anythink in common with both
08:07:32 <agasdfgasdfsd> or meybe a little from pascal syntax
08:08:53 <Axman6> agasdfgasdfsd: agast, from your nick
08:09:32 <fax> paskell - lol
08:09:59 <koeien> call it 'koeien'!
08:13:00 <agasdfgasdfsd> why
08:13:16 <agasdfgasdfsd> why koeien
08:13:59 <osfameron> call it BAGPUSS (short for "Bagpuss, dear Bagpuss, Old Fat Furry Catpuss"
08:14:26 <fax> :D
08:15:40 <EvanR-work> ._.
08:16:58 <agasdfgasdfsd> ya thx for help ;P
08:18:35 <benmachine> koeien: out of interest, what *is* the world's worst programming language iyo?
08:19:39 <JuanDaugherty> brainfuck
08:19:48 <JuanDaugherty> or whatever it's called
08:19:48 <EvanR-work> theres worst, and theres the one that maximizes badness AND popularity simultaneously
08:20:00 <chrisdone> brainfuck is considerably better than php
08:20:24 <EvanR-work> and, like php, criteria  is what people really want to rant about
08:20:28 <EvanR-work> this criteria*
08:20:44 <EvanR-work> maximize crap popularity product
08:20:55 <benmachine> EvanR-work: well, badness vs. likelihood of having to use it/read it
08:21:06 <EvanR-work> good refinement
08:21:14 <EvanR-work> php is up there
08:21:22 <benmachine> yep
08:22:20 <EvanR-work> maximizing crap on its own its fairly useless, since you could take historical or toy or half assed attempts at language implementations into account there and not get anywhere near php
08:22:29 * osfameron would rather program PHP again than COBOL
08:22:32 * osfameron twitches
08:23:25 <benmachine> besides which there are languages which are deliberately obnoxious
08:24:14 <EvanR-work> right
08:24:30 <Jafet> PLEASE DO NAME ONE
08:24:53 <EvanR-work> intercal!
08:25:08 <fax> hehe
08:25:43 <benmachine> yes I was thinking of that sort of thing
08:25:48 <benmachine> http://esoteric.voxelperfect.net/wiki/Joke_language_list
08:26:06 <danderson> malbolge would be the worst
08:26:42 <danderson> as in, 8 years for a 99 bottles of beer implementation :)
08:46:21 <leino> how would one go about getting the last two elements from a list?
08:47:05 <koeien> how would you get the last element?
08:47:19 <ezyang> @hoogle Int -> [a] -> [a]
08:47:21 <lambdabot> Prelude drop :: Int -> [a] -> [a]
08:47:21 <lambdabot> Prelude take :: Int -> [a] -> [a]
08:47:21 <lambdabot> Data.List drop :: Int -> [a] -> [a]
08:47:48 <ManateeLazyCat> Do you have file "/usr/local/share/doc/mtl-1.1.0.2/html/mtl.haddock" ? I got `openBinaryFile` error when i build gtk2hs Haddock documentation.
08:48:20 <Twey> koeien:
08:48:21 <Twey> :t last
08:48:22 <lambdabot> forall a. [a] -> a
08:48:27 <Twey> > last [1 .. 20]
08:48:28 <lambdabot>   20
08:48:35 <Twey> > last []
08:48:36 <lambdabot>   * Exception: Prelude.last: empty list
08:48:49 <koeien>  Twey: i know. it was a question/hint to leino :)
08:48:50 <Twey> Oh, I'm sorry — that was an answer :þ
08:49:45 <leino> > last [1, 2, 3]
08:49:46 <lambdabot>   3
08:49:59 <Mortomes> drop 8 [1 .. 10]
08:50:05 <Mortomes> > drop 8 [1 .. 10]
08:50:06 <lambdabot>   [9,10]
08:50:33 <leino> yeah but then you have to calculate the length of the list...
08:50:54 * ManateeLazyCat pasted "bug" at http://paste2.org/get/757833
08:50:54 <ManateeLazyCat> Above is bug of haddock or ghc?
08:51:09 <ezyang> leino: But you have to do that anyway, don't you ;-)
08:51:14 <Twey> No
08:51:23 <Mortomes> Yes, there is a more efficient way of doing it
08:51:38 <stevenmarky_> > (take 2) $ reverse [1,2,3,4,5]
08:51:39 <lambdabot>   [5,4]
08:51:48 <ezyang> Twey: as in, you need to do some O(n) operation
08:52:45 <leino> stevenmarkl_: thanks, that'll do it
08:52:59 <leino> *stevenmarky_
08:53:24 <Twey> > let lastTwo xs@[_, _] = xs; lastTwo xs@[_] = []; lastTwo xs@[] = []; lastTwo (_ : xs) = lastTwo xs
08:53:25 <lambdabot>   not an expression: `let lastTwo xs@[_, _] = xs; lastTwo xs@[_] = []; lastTw...
08:53:37 <Twey> > let lastTwo xs@[_, _] = xs; lastTwo xs@[_] = []; lastTwo xs@[] = []; lastTwo (_ : xs) = lastTwo xs in lastTwo [5 .. 10]
08:53:38 <lambdabot>   [9,10]
08:53:43 <Twey> That's the most efficient way
08:53:47 <Twey> But it's also pretty hideous
08:54:00 <Twey> Sadly, to make it nice *and* efficient, you need some clever stream fusion and/or supercompilation
08:54:05 <Twey> Coming soon to a compiler near you
08:54:55 <leino> maybe I dont need lastTwo if I solve my problem differently
08:55:46 <Twey> Well, if you use a Sequence, you can take two off the end in O(1) time
08:56:10 <leino> I want this in order to implement the Fibonacci sequence
08:56:23 <ezyang> ==Twey; if you really need efficient access to the end, you need to pick a different datastructure
08:56:38 <ezyang> leino: Oh. Why didn't you say so.
08:56:46 <fax> leino, f n = f (n-1) + f (n-2) ?
08:56:46 <Twey> ezyang: Well, in this particular case, yeah
08:57:00 <ski> > (last . init &&& last) [0,1,2,3,4,5,6,7]
08:57:01 <leino> fax: yeah
08:57:01 <lambdabot>   (6,7)
08:57:32 <leino> fax: but isn't that a pretty inefficient way of doing it?
08:57:41 <fax> it is inefficent
08:57:47 <ski> (leino : why not represent the list in reverse order ?)
08:57:52 <fax> you can speed it up though
08:58:16 <fax> lets define an aux called f' which gives f n and f (n-1)
08:58:22 <Twey> ezyang: But you should be able to make it at least O(n) without manual recursion
08:58:34 <fax> then f' n = let (fn'1,fn'2) = f' (n-1) in fn'1 + fn'2
08:58:37 <fax> now that is efficient
08:58:50 <fax> oops I got it wrong
08:59:04 <fax> it should return both f n and f (n-1)
08:59:15 <ezyang> Twey: Do you mean n? Because length == O(n) and then drop == O(n), so the combined operation is O(n)
08:59:17 <fax> f' n = let (fn'1,fn'2) = f' (n-1) in (fn'1, fn'1 + fn'2)
08:59:30 <fax> that is actaully still wrong
08:59:36 <leino> ski: the list is infinite :)
09:00:28 <ski> > covr (const 0 : const 1 : repeat (\(a0:a1:_) -> a0 + a1))  -- something like this ?
09:00:29 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
09:00:33 <Twey> ezyang: True, but bigger constants — it should take only one pass through the list
09:00:57 <ezyang> Ok (I was just objecting to the use of big-O notation</pedant>)
09:01:21 <ezyang> Twey: I... think you can do it with a fold
09:01:44 <Twey> Hm, maybe
09:02:03 <Twey> Maintain a pair of items as you go and remove the oldest when encountering a new…
09:02:18 <fax> (x,y) -> (y,x+1)
09:02:21 <leino> ski: looks good, I will have to take a moment to decipher it (I'm a noob :-)
09:02:44 <fax> > iterate (\(x,y) -> (y,x+1)) (1,1)
09:02:45 <lambdabot>   [(1,1),(1,2),(2,2),(2,3),(3,3),(3,4),(4,4),(4,5),(5,5),(5,6),(6,6),(6,7),(7...
09:02:54 <ski> leino : it possibly is both overkill and not quite what you had in mind ..
09:02:54 <fax> > map fst $ iterate (\(x,y) -> (y,x+y)) (1,1)
09:02:55 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
09:03:02 <ezyang> > let lastTwo (x:y:xs) = foldl (\(_,a),b->(a,b)) (x,y) xs in lastTwo [1,2,3]
09:03:03 <lambdabot>   <no location info>: parse error on input `,'
09:03:10 <ezyang> bah
09:03:23 <ezyang> > let lastTwo (x:y:xs) = foldl (\(_,a) b->(a,b)) (x,y) xs in lastTwo [1,2,3]
09:03:24 <lambdabot>   (2,3)
09:03:40 <leino> ski: how so? it is the fib sequence right?
09:03:43 <ezyang> @pl \(_,a) b->(a,b)
09:03:43 <lambdabot> (,) . snd
09:03:47 <ezyang> lol
09:04:20 <ski> leino : yes, but i gathered that you maybe were trying to define the sequence using `fix' ..
09:09:15 <ski> > foldr (\a -> Just . maybe (Left a) (Right . either ((,) a) id)) Nothing [0,1,2,3,4,5,6,7]
09:09:16 <lambdabot>   Just (Right (6,7))
09:10:18 <ezyang> classy ;^)
09:10:44 <liyang> > fix (\ f@ ~(_ : t) -> 0 : 1 : zipWith (+) f t) -- oh god not that old chestnut again
09:10:45 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
09:12:55 <ski> > covr (repeat (succ . product))
09:12:56 <lambdabot>   [2,3,7,43,1807,3263443,10650056950807,113423713055421844361000443,128649386...
09:13:05 <fax> covr ??
09:13:15 <fax> :t covr
09:13:16 <lambdabot> forall a. [[a] -> a] -> [a]
09:13:18 <ski> ("course-of-values recursion" more or less)
09:13:31 <fax> > covr [sum]
09:13:32 <lambdabot>   [0]
09:13:35 <fax> > covr [product]
09:13:36 <lambdabot>   [1]
09:13:38 <fax> O_O
09:13:40 <fax> how the hell
09:13:40 <MoALTz> @src covr
09:13:40 <lambdabot> Source not found. My pet ferret can type better than you!
09:13:49 <fax> > covr [sum,product]
09:13:50 <lambdabot>   [0,0]
09:13:57 <fax> > covr [product,sum,sum,product]
09:13:58 <lambdabot>   [1,1,2,2]
09:14:20 <fax> > covr (product : iterate ((+1).) id)
09:14:21 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
09:14:30 <fax> > covr (product : iterate ((+1).) sum)
09:14:31 <lambdabot>   [1,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535,131071,...
09:14:55 <ManateeLazyCat> Hi guys. Look http://www.gtk.org/language-bindings.html and search "Haskell", cool ah?
09:15:19 <fax> ManateeLazyCat good \o/
09:15:30 <ski> > take 7 $ covr (repeat (leastPrimeFactor . succ . product)) -- only primes
09:15:31 <bluetaslem> Hi.
09:15:31 <lambdabot>   [2,3,7,43,13,53,5]
09:15:35 <ManateeLazyCat> fax: Sweet. :)
09:15:57 <liyang> ManateeLazyCat: awesome. One day I'll actually get around to using GTK+.
09:16:49 <ManateeLazyCat> liyang: Welcome!
09:17:10 <ManateeLazyCat> liyang: Now just wait Axel finish cabal job.
09:17:28 <ski> (MoALTz : the source isn't very complicated ..)
09:17:43 * liyang can't wait to finish this PhD so he can actually go and hack some code. >_>
09:18:04 <MoALTz> ski: sorry... was just curious (did a check on hoogle before trying that)
09:18:29 <ski> > covr (repeat length)
09:18:30 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
09:18:41 <ManateeLazyCat> liyang: http://farm3.static.flickr.com/2628/3952175905_9295a7421a_o.png
09:18:46 <ManateeLazyCat> liyang: http://farm3.static.flickr.com/2800/4448123474_3879e3f878_o.png
09:18:51 <ManateeLazyCat> liyang: Base on gtk2hs.
09:18:55 <Twey> What's the recommended procedure for using an additional GTK widget from Gtk2Hs, like GtkHTML?
09:19:03 <ManateeLazyCat> liyang: And Webkit browser just need 96 lines code.
09:19:04 <Twey> Can Gtk2Hs handle that?
09:19:16 <ManateeLazyCat> Twey: Gtk2hs have support Webkit.
09:19:17 <Twey> ManateeLazyCat: 96 lines of Haskell?!
09:19:22 <ManateeLazyCat> Twey: Yes.
09:19:31 <Saizan> too much.
09:19:32 <ManateeLazyCat> Twey: Looks gtk2hs/demo/webkit
09:19:32 <Twey> Bloody hell… that's a lot of code
09:19:36 <ManateeLazyCat> Twey: Evne less.
09:19:53 <bluetaslem> Is there an infinity in Haskell?
09:20:00 <fax> yes
09:20:11 <fax> > infinity + 1
09:20:12 <lambdabot>   Not in scope: `infinity'
09:20:19 <fax> well there IS one
09:20:19 <Twey> > 1 / 0
09:20:20 <lambdabot>   Infinity
09:20:22 <fax> but lambdabot doesn't know it
09:20:23 <bluetaslem> Is there a value which is larger than all others?
09:20:24 <Twey> > (1 / 0) + 1
09:20:25 <lambdabot>   Infinity
09:20:25 <ManateeLazyCat> Twey: Even just need 40 lines can write a simple Webkit browser.
09:20:36 <Twey> ManateeLazyCat: 40 lines of Haskell is still a lot of code…
09:20:41 <ski> > fix succ :: Natural -- hm
09:20:42 <lambdabot>   Not in scope: type constructor or class `Natural'
09:20:45 <ski> bah!
09:20:50 <Twey> Isn't it Nat?
09:20:55 <ManateeLazyCat> Twey: Okay, you can write all code in *one* line.
09:20:57 <ManateeLazyCat> :)
09:20:57 <Twey> > fix succ :: Nat
09:20:58 <lambdabot>   No instance for (GHC.Enum.Enum L.Nat)
09:20:58 <liyang> ManateeLazyCat: good lord. How many terminals do you need? XD
09:20:58 <lambdabot>    arising from a use of `GHC.Enum.su...
09:21:03 <Twey> ManateeLazyCat: Haha
09:21:05 <bluetaslem> So, for instance...
09:21:24 <Twey> ManateeLazyCat: Yes, 100LoC is a whole Haskell program.
09:21:31 <Twey> Yes, but**
09:21:33 <ManateeLazyCat> liyang: I will release my project fist version in this month.
09:21:41 <ski> Twey : maybe .. i would expect `Nat' only being a finite approximation (like `Int'), though ..
09:21:50 <ManateeLazyCat> Twey: But what?
09:21:51 <Twey> I'd expect a simple example to be no more than 5–10 lines…
09:22:01 <Twey> (excluding imports)
09:22:20 <ManateeLazyCat> Twey: Just i write so much blank line in source code.
09:22:27 <ManateeLazyCat> Twey: Logic is clean enough.
09:22:31 <ManateeLazyCat> :)
09:22:33 <Twey> Hmm.
09:22:47 <bluetaslem> length ( cycle [1,2,3,4]  )
09:23:05 <ManateeLazyCat> Twey: You can build your own Multi-Tab browser base on that demo, just need GtkNotebook replace container.
09:23:16 <Twey> Of course
09:23:21 <bluetaslem> I think I confused Lamddabot...
09:23:33 <Twey> bluetaslem: No, you got ignored by lambdabot.
09:23:40 <Twey> > length $ cycle [1, 2, 3, 4]
09:23:45 <lambdabot>   mueval: ExitFailure 1
09:23:47 <bluetaslem> length ( cycle [1,2,3,4]  )
09:23:49 <Twey> Timeout
09:24:00 <koeien> bluetaslem: add >
09:24:02 <bluetaslem> I see...
09:24:09 <bluetaslem> >length ( cycle [1,2,3,4]  )
09:24:17 <Twey> …
09:24:35 <ski> >-) "strange smiley"
09:24:53 <ski> > "valid lambdabot invokacation"
09:24:54 <lambdabot>   "valid lambdabot invokacation"
09:24:57 <ManateeLazyCat> liyang: BTW, that's not running in terminal, it's build terminal running in my project.
09:25:06 <liyang> > 9000
09:25:07 <lambdabot>   9000
09:25:14 <dv-> > undefined
09:25:15 <lambdabot>   * Exception: Prelude.undefined
09:25:19 <fax> @@run @run @@
09:26:09 <ManateeLazyCat> liyang: Split different Terminal View in different Windows.
09:26:47 <Twey> ski: Heheh
09:28:22 <ManateeLazyCat> Twey: Please use Webkit replace GtkHTML, GtkHTML is slow.
09:28:33 <ManateeLazyCat> Twey: And Webkit is damn fast.
09:28:38 <ManateeLazyCat> :)
09:29:34 <chr1s> hey all.
09:29:46 <Lemmih> hey you.
09:30:05 * ManateeLazyCat I will update gio when i have spare time, then we can build modern file-manager.
09:30:11 <chr1s> I have a weird problem. I'm using some code that uses liftIO in the ReaderT monad
09:30:25 <chr1s> however, GHC says: no instance for LiftIO
09:30:44 <chr1s> when I give it myself, GHC complains that there's a duplicate instance!
09:30:48 <ManateeLazyCat> chr1s: liftIO, not LiftIO?
09:31:02 <chr1s> ManateeLazyCat: yes, liftIO and MonadIO, sorry.
09:31:22 <ManateeLazyCat> chr1s: Can you paste your source code?
09:32:00 <Saizan> chr1s: paste the original error too
09:32:17 <Eelis> @seen ndm
09:32:17 <chr1s> ManateeLazyCat: it's this file by jaspervdj
09:32:17 <lambdabot> Unknown command, try @list
09:32:25 <chr1s> ManateeLazyCat: http://github.com/jaspervdj/Hakyll/blob/master/examples/simpleblog/hakyll.hs
09:32:29 <ski> preflex: xseen ndm
09:32:29 <preflex>  Sorry, I haven't seen ndm
09:32:35 <aavogt> you shouldn't have to write a MonadIO instance if you use transformers defined in the library
09:32:44 <Eelis> ski: thanks
09:32:53 <chr1s> aavogt: yes, that's what I thought.
09:33:08 <aavogt> so you're probably using it wrong
09:33:18 <chr1s> however, I have imported both the Reader and Trans modules.
09:33:20 <Saizan> or misinterpreting the error message.
09:33:32 <Saizan> can you paste the error message?
09:33:55 <ManateeLazyCat> chr1s: Passte error message will help. :)
09:33:55 <chr1s> Saizan:  No instance for (Control.Monad.Trans.MonadIO
09:33:56 <chr1s>                        (mtl-1.1.0.2:Control.Monad.Reader.ReaderT
09:33:56 <chr1s>                           Text.Hakyll.HakyllMonad.HakyllConfiguration IO))
09:33:56 <chr1s>       arising from a use of `liftIO' at hakyll.hs:33:4-9
09:33:58 <chr1s>     Possible fix:
09:34:00 <chr1s>       add an instance declaration for
09:34:03 <chr1s>       (Control.Monad.Trans.MonadIO
09:34:05 <chr1s>          (mtl-1.1.0.2:Control.Monad.Reader.ReaderT
09:34:08 <chr1s>             Text.Hakyll.HakyllMonad.HakyllConfiguration IO))
09:34:16 <chr1s> there it is.
09:34:24 <Saizan> chr1s: in a pastebin next time.
09:34:34 <chr1s> sorry about that.
09:34:39 <Eelis> hah, someone on haskell-cafe says he was actually asked to verify his identity by means of his university mail when he tried to get a hackage account--his gmail account wasn't good enough
09:35:06 <Eelis> so my plan to use a fake name will have to become more refined
09:35:11 <chr1s> I'm guessing it's some weird package problem or something.
09:35:14 <Saizan> chr1s: however, the fact that it's mentioning the package name and version means that you're using two different versions of mtl at a time.
09:35:49 <koeien> i used my own domain and was accepted
09:36:13 <chr1s> solved it.
09:36:34 <aavogt> or you use different monad libraries
09:36:37 <Eelis> koeien: interesting. more evidence that this real name requirement is enforced very capriciously
09:36:41 <chr1s> ghc was defaulting to the transformers package, while hakyll was linked to the mtl package.
09:36:51 <koeien> Eelis: yes. although I used my own name.
09:37:12 <koeien> it is possible that my domain was whois'd, but that seems unlikely
09:37:24 <chr1s> Is there consensus on which of the two we should use? mtl or transformers? or monads-fd?
09:37:43 <koeien> afaik mtl is deprecated or going to be deprecated.
09:37:43 <zygoloid> monads-fd is not an alternative
09:37:55 <chr1s> I see.
09:38:10 <zygoloid> aiui mtl was basically split into transformers plus {monads-fd, monads-tf} depending on your preference of mptc solution
09:38:20 <ManateeLazyCat> Hey, what's your favorite Gtk+ library that gtk2hs haven't provide? Maybe it's a next plan for gtk2hs team. :)
09:39:38 <chr1s> ah, ok. so I should try to make my packages depend on transformers instead of mtl. good to know.
09:39:53 <chr1s> thanks everybody!
09:40:26 <Saizan> chr1s: not really.
09:40:38 <Saizan> chr1s: there's no consensus that we should switch to transformers
09:40:46 <ManateeLazyCat> Maybe clutter is cool.
09:41:06 <Saizan> actually, transformers seems the dullest of mtl alternatives
09:42:35 <chr1s> Saizan: ok. I'm a bit confused. Should I instead do a transformers OR mtl dependency in my cabal files?
09:43:26 <burp> or give MonadLib a try
09:43:59 <Saizan> chr1s: you should pick the one that's most convenient to you, the current situation is broken anyhow if one worries a lot about interoperability
09:44:16 <benmachine> chr1s: whenever I've needed to I've used mtl on the grounds that it's in the haskell platform
09:44:25 <Saizan> chr1s: if it's of any value, transformers is not in the Haskell Platform, while mtl is
09:44:29 <benmachine> so quite a few people already have it
09:47:17 <mmmulani> anyone remember the haskell OS by microsoft reseach?
09:48:13 <ManateeLazyCat> mmmulani: ?
09:48:23 <ManateeLazyCat> mmmulani: Link ?
09:48:30 <ManateeLazyCat> mmmulani: I'm interested.
09:50:39 <dv-> It was called House wasn't it
09:50:47 <EvanR-work> its interesting that microsoft actually does FP research and development
09:51:10 <ManateeLazyCat> EvanR-work: Because FP is the future. :)
09:51:11 <EvanR-work> maybe if they wrote some software with it, their products wouldnt suck :)
09:51:30 <dv-> I'm sure MS could find a way to make it suck
09:51:38 <fax> dv-, F#
09:51:45 <EvanR-work> heh
09:51:48 <ManateeLazyCat> F# is suck
09:51:56 <ManateeLazyCat> unly
09:52:00 <ManateeLazyCat> ugly
09:52:21 <ddarius> That's its ML heritage.
09:52:27 <mmmulani> hmm is House by microsoft?
09:52:34 <ddarius> No.
09:56:52 <liyang> Thought that was Hugh Laurie.
09:56:53 <ManateeLazyCat> http://web.cecs.pdx.edu/~kennyg/house/
10:02:21 <ManateeLazyCat> Use gtk2hs webkit browse http://mugtug.com/sketchpad/ is slow.
10:02:41 <ManateeLazyCat> Looks need binding Google V8 JavaScript engine in gtk2hs.
10:03:05 <ManateeLazyCat> In Chrome, this HTML5 painter is very fast.
10:05:16 <EvanR-work> i suppose its not been achieved to write a compiler that compiles anything else into malbolge
10:05:24 <EvanR-work> *something* else
10:06:04 <EvanR-work> SKI, x86 asm..
10:07:07 <ski> EvanR-work : sorry ?
10:07:24 <ski> .. oh
10:07:48 <EvanR-work> you must get that a lot ;)
10:08:16 <ski> not that often actually :)
10:12:27 <ManateeLazyCat> http://farm3.static.flickr.com/2799/4493538735_bb5b539e9a_o.png
10:12:42 <ManateeLazyCat> Webkit -- fast enough.
10:13:53 <jmelesky> so, i'm on OSX Leopard, and am still getting the dyld error when trying to use cabal with the new install (ghci and ghc both seem to work)
10:14:07 <jmelesky> did cabal not get rebuilt?
10:15:05 <chrisdone> http://chrisdone.com/posts/2010-04-05-haskell-json-service-tryhaskell.html
10:15:07 <chrisdone> :)
10:15:28 <yuriks_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24699
10:15:44 <yuriks_> How do I fix that error? I've already tried several variations of the syntax
10:15:51 <yuriks_> I can only get it working with let ... in ...
10:16:22 <Saizan> jmelesky: why would it be?
10:16:27 <koeien> yuriks_: .. where .. is not an expression.
10:16:28 <chrisdone> you're missing a ']'
10:16:36 <chrisdone> unless my eyes are borked
10:16:48 <ManateeLazyCat> Bye all, night!
10:16:57 <koeien> there are various problems
10:16:58 <chrisdone> oh, you're not missing one, but it's in the wrong place
10:17:02 <koeien> why do you have a [ there ?
10:17:06 <jmelesky> Saizan: it's part of the platform install
10:17:07 <yuriks_> I put the | and the stuff after it after the where too
10:17:13 <yuriks_> koeien: it's a list comprehension
10:17:17 <benmachine> yuriks_: the places "where" is allowed are more limited than let
10:17:43 <benmachine> 'where' can only attach to case statements/branches or function equations as far as I know
10:17:46 <koeien> I am very confused by what you are trying to accomplish
10:17:55 <koeien> well, matrix*vector multiplication, but still :)
10:18:03 <benmachine> (and also classes/instances etc.)
10:18:06 <yuriks_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24700
10:18:17 <Saizan> jmelesky: ah, ok, i thought you only installed ghc
10:18:22 <koeien> aha
10:18:24 <yuriks_> benmachine: ah, so I can't use where in an equivalent way as let..in.. above?
10:18:29 <koeien> yuriks_: that was the original?
10:18:34 <yuriks_> koeien: yeah
10:18:35 <benmachine> yuriks_: indeed
10:18:39 <koeien> replace pair <- by    (w, i) <- zip m v
10:18:58 <koeien> yuriks_: no, you can't. let .. in .. is an expression, but .. where .. isn't
10:19:21 <jmelesky> Saizan: sorry, wasn't clear. yeah, the platform installer for OSX was recently released, as the last build worked on Snow Leopard but not Leopard (10.6, but not 10.5)
10:19:23 <yuriks_> ah, ok, thanks, thanks for the pair tip too
10:19:25 <yuriks_> very useful
10:19:35 <benmachine> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24700#a24701 -- yuriks_, the joys of pattern matching/inbuilt sum function
10:19:47 <koeien> this is pattern matching. Works for more than tuples alone :)
10:19:53 <koeien> also for your own types, and for lists, and so on
10:20:15 <benmachine> yuriks_: in other news, have you heard of the zipWith function?
10:20:59 <yuriks_> I'm still a bit confused on where pattern matching works
10:21:12 <yuriks_> I had tried (w,i) <- (m,v) before
10:21:18 <yuriks_> benmachine: hmm, I think
10:22:02 <koeien> (w,i) <- (m,v) doesn't work, since <- only works where the right-hand side is a list (in a list comprehension)
10:22:05 <benmachine> yuriks_: (w, i) <- (m, v) doesn't work because <- expects a list on its right hand side
10:22:10 <benmachine> yes
10:22:20 <benmachine> listen to koeien he explained it faster and better
10:22:26 <yuriks_> yeah, thanks
10:22:37 <yuriks_> gotta run to class now :)
10:22:49 <EvanR-work> > let x = 1 in x
10:22:50 <lambdabot>   1
10:23:04 <EvanR-work> > let (x,y) = (1,2) in (x,y)
10:23:05 <lambdabot>   (1,2)
10:23:09 <EvanR-work> O_o
10:23:14 <EvanR-work> cool
10:23:47 <EvanR-work> > let Just x = Just 5 in x
10:23:48 <lambdabot>   5
10:23:51 <EvanR-work> o_O
10:24:18 <benmachine> is that surprising
10:24:26 <EvanR-work> pattern matching in let
10:24:28 <EvanR-work> didnt know about that
10:24:33 <benmachine> > let Just x = Nothing in 4
10:24:34 <lambdabot>   4
10:25:04 <ski> > let Nothing = Just 2 in 4
10:25:04 <lambdabot>   4
10:25:13 <EvanR-work> > [a,b,c] = [1,2,3] in [c,a,b]
10:25:14 <lambdabot>   <no location info>: parse error on input `='
10:25:16 <EvanR-work> > let [a,b,c] = [1,2,3] in [c,a,b]
10:25:17 <lambdabot>   [3,1,2]
10:25:32 <benmachine> :t fix In . Just
10:25:33 <lambdabot>     Couldn't match kind `(* -> *) -> *' against `* -> *'
10:25:33 <lambdabot>     When matching the kinds of `Mu :: (* -> *) -> *' and `f :: * -> *'
10:25:34 <lambdabot>       Expected type: f (Mu f)
10:25:34 <benmachine> er
10:25:39 <benmachine> :t fix (In . Just)
10:25:40 <lambdabot> Mu Maybe
10:25:46 <ski> > let _ = () in ()
10:25:46 <lambdabot>   ()
10:25:48 <benmachine> sorry that was irrelevant
10:25:53 <ski> > let _ x = x in ()
10:25:54 <lambdabot>   <no location info>: Parse error in pattern
10:25:57 <pastorn> > let [a,b] = "abc" in [c,a,b]
10:25:58 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
10:25:58 <lambdabot>         against inferred ...
10:26:06 <pastorn> oh shi-
10:26:25 <pastorn> > let [a,b] = "abc" in [a,b]
10:26:26 <lambdabot>   "* Exception: <interactive>:1:137-149: Irrefutable pattern failed for patte...
10:26:31 <pastorn> there we go
10:27:26 <fax> > let ~[a,b] = "abc" in [a,b]
10:27:27 <lambdabot>   "* Exception: <interactive>:1:137-150: Irrefutable pattern failed for patte...
10:28:10 <burp> > let a:b = "abc" in (a,b)
10:28:11 <lambdabot>   ('a',"bc")
10:28:27 <ski> @type fix (In . State . (,))
10:28:28 <lambdabot> forall s. Mu (State s)
10:29:19 <fax> :t out
10:29:20 <lambdabot> forall (f :: * -> *). Mu f -> f (Mu f)
10:29:53 <EvanR-work> trickty
10:29:55 <EvanR-work> tricky
10:30:52 <ski> @type iterate . (In .)
10:30:53 <lambdabot> forall (f :: * -> *). (Mu f -> f (Mu f)) -> Mu f -> [Mu f]
10:32:39 <EvanR-work> @src nub
10:32:39 <lambdabot> nub = nubBy (==)
10:32:45 <EvanR-work> @src nubBy
10:32:45 <lambdabot> nubBy eq []             =  []
10:32:45 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
10:33:38 <EvanR-work> wtf is up with the name nub
10:33:59 <shapr> It's like n00b, but old sk00l
10:34:10 <shapr> Ok, not really.
10:34:41 <ski> that's the nub of the matter
10:35:53 <EvanR-work> it reduces the list to a nub, as if your arm were amputated
10:37:04 <c_wraith> > take 1 $ repeat 1
10:37:05 <lambdabot>   [1]
10:37:52 <c_wraith> > take 1 . nub $ repeat 1
10:37:53 <chrisdone> planet haskell appears to be back up
10:37:54 <lambdabot>   [1]
10:38:49 <jmcarthur> > nub $ repeat 1
10:38:54 <lambdabot>   mueval: ExitFailure 1
10:39:05 <jmcarthur> oh, duh, it won't give the partial result
10:39:52 <pastorn> > (* 3) . (+ 2) . length
10:39:54 <lambdabot>   {[]->6;[()]->9;[(),()]->12;[(),(),()]->15}
10:40:01 <fax> > head $ nub $ repeat 1
10:40:02 <lambdabot>   1
10:40:18 <pastorn> fax: shit, that's cool :)
10:41:22 <fax> > 1/0.1828182818281828182818281828182818281828 :: Rational
10:41:23 <lambdabot>   2500000000000000000000000000000000000000 % 45704570457045704570457045704570...
10:41:35 <fax> > 251/457
10:41:36 <lambdabot>   0.5492341356673961
10:42:06 <fax> > 1/0.1828 :: Rational
10:42:07 <lambdabot>   2500 % 457
10:42:15 <fax> 2499/457
10:45:13 <fax> > 1828/999
10:45:14 <lambdabot>   1.82982982982983
10:45:22 <fax> > 1828/1001
10:45:23 <lambdabot>   1.826173826173826
10:47:49 <sepp2k> @pl \x y -> g $ f x y
10:47:49 <lambdabot> (g .) . f
10:48:14 <chrisdone> BONUS: bump
10:48:34 <BONUS> bomp
10:48:35 <chrisdone> the source of nub is cool
10:48:41 <chrisdone> BONUS: oh there you are
10:48:49 <chrisdone> BONUS: good news! http://chrisdone.com/posts/2010-04-05-haskell-json-service-tryhaskell.html
10:48:50 <BONUS> back from the hospital :[
10:48:57 <chrisdone> BONUS: oh bad news. what's up?
10:49:14 <BONUS> just had a really bad case of stomach flu and they had to keep me for observation for a few days, but i'm well now
10:49:25 <chrisdone> yaay :)
10:49:29 <BONUS> oooh awesome!
10:49:34 <chrisdone> :D
10:49:50 <chrisdone> now you can totally embed it in a book about haskell or something ~_>
10:49:56 <chrisdone> -_<
10:49:58 <BONUS> if only i had such a thing!
10:50:03 <edwardk_> BONUS: ouch
10:50:05 <BONUS> man this is so cool
10:50:21 <chrisdone> \o/
10:50:32 <edwardk_> BONUS: how fares the whole publishing process, anyways?
10:51:04 <BONUS> edwardk_: we're trucking along :) most of the work now is being done by the editor
10:51:13 <BONUS> and the technical editor.
10:51:20 <BONUS> we're planning for a summer release
10:51:29 <chrisdone> I didn't yknow you were getting lyah published!
10:51:57 <edwardk_> bonus: very very cool
10:51:58 <chrisdone> i'll buy it for the vector illustrations printed on glossy paper :p
10:52:03 <BONUS> ya. and i'm going to merge the edits back to the site because they really make the book like 2x better. also they make me look like a real writer instead of some guy from the internet
10:52:07 <BONUS> hehe
10:52:13 <chrisdone> awesome
10:52:19 <edwardk_> i still need to write the opposite extreme
10:52:29 <BONUS> haha
10:52:39 <chrisdone> edwardk_: Teach Them No Haskell?
10:52:53 <edwardk_> generalized abstract nonsense for those who have way too much free time and no interest in practical applications -- in Haskell
10:52:58 <pastorn> BONUS: have you done the monad chapters yet?
10:53:27 <BONUS> i'm not going to do monads and instead there's going to be a chapter or two about Java
10:53:42 <pastorn> oh, howcome?
10:53:48 <edwardk_> bonus: april fools was last week ;)
10:53:50 <BONUS> j/k, the monads chapter is nearly finished, the monad transformers one still needs more work though :)
10:53:52 <fax> > ((-1 + sqrt(-3))/2)^3 :: Complex Double
10:53:53 <lambdabot>   0.9999999999999998 :+ 1.1102230246251565e-16
10:53:55 <chrisdone> haha
10:53:55 <BONUS> haha
10:54:00 <pastorn> :/
10:54:07 * pastorn got tricked :(
10:54:24 <pastorn> BONUS: CAN HAZ Arrows?
10:54:34 <Cale> chrisdone: There's a weird bug with the history in Try Haskell. When I press the up arrow key, it seems to take me back a few expressions, rather than to the last one that I typed.
10:54:43 <BONUS> i tend to think of april fools as a holiday that lasts throughout the whole month
10:54:51 <chrisdone> Cale: ah, sorry. I keep forgetting to fix that
10:54:58 <BONUS> pastorn: not gonna be in LYAH but i'm planning on blogging about them later
10:55:03 <chrisdone> Cale: I'll fix it right now!
10:55:07 <Cale> No problem, just letting you know :)
10:55:38 <BONUS> chrisdone: this is beyond awesome, mind if i reddit it?
10:56:37 <edwardk_> can haz right kan extensions? =)
10:56:45 <BONUS> lol
10:56:51 <Eelis> is haskell-src supposed to parse Haskell 98 perfectly, or is it known to fail on some constructs?
10:57:25 <edwardk_> Eelis: haskell-src-exts should at least. has haskell-src seen much love recently?
10:57:43 <chrisdone> BONUS: sure!
10:57:46 <Eelis> edwardk_: i'm particularly interested in how either haskell-src or haskell-src-exts handle fixities of unknown operators
10:58:07 <Eelis> edwardk_: that is, operators imported from other modules, which haskell-src(/-exts) cannot see
10:58:15 <edwardk_> Eelis: i think the cases that haskell-src fail on are the ones where ALL haskell parsers fail on, a couple of vagaries of the layout rules
10:58:31 <BONUS> submitted 4 minutes ago by dons
10:58:34 <BONUS> curse you, dons
10:58:35 <chrisdone> hahaha
10:58:38 <chrisdone> that man works fast
10:59:37 <Eelis> given "import Bla \n c = x****y^^^^z", how can haskell-src/haskell-src-exts know whether it's (x****y)^^^^z or x****(y^^^^z) ?
11:00:42 <edwardk_> Eelis: theybasically given default fixities to them =(
11:00:44 <ski> precedence
11:01:07 <Eelis> edwardk_: right. so i guess both /are/ known to fail on some constructs then :)
11:01:12 <felzix> how can I add library paths to cabal's searching?
11:01:13 <edwardk_> ski: it doesn't know about the fixities that are currently in scope, TH doesn't supply you would info
11:01:34 <ski> oh
11:01:34 <edwardk_> Eelis:   iirc they include default fixities for the prelude stuff, at least -exts does
11:01:44 <edwardk_> er supply you with the info
11:02:06 <BONUS> is the type of length being [a] -> Int and not Num b => [a] -> b generally considered as an oversight or is it accepted as a good thing
11:02:14 <edwardk_> @type genericLength
11:02:15 <lambdabot> forall b i. (Num i) => [b] -> i
11:02:24 <edwardk_> its there, its just a lot slower
11:02:33 <Eelis> edwardk_: yes, but that's obviously only an ugly hack to cover some common use cases. this afternoon i found out that hlint is unusable for my project because it trips on fixities of foreign operators, because it uses haskell-src-exts
11:02:43 <BONUS> yeah, i'm aware of that, i'm just interested behind the original reasoning
11:03:02 <BONUS> is it considered a wart in the language or is it generally considered as a cool thing
11:03:22 <pastorn> edwardk_: a lot slower?
11:03:29 <pastorn> why? because of the casting?
11:03:32 <pastorn> or does it cast?
11:03:38 <edwardk_> BONUS: i would assume that it was because there wasn't a RULES system at the time of 98 and there was probably some reasoning that you wouldn't be taking multibillion numbers of steps over a list spine.
11:03:46 <fax> genericLength is not fromInteger . length
11:03:51 <fax> so it can be much slower
11:03:51 <chrisdone> BONUS: yeah I wonder that about all the Int things. I know Cale would prefer everything being Integer rather than Int
11:03:52 <jmcarthur> BONUS: i don't think there is a consensus on it. my personal feelings are that it's a wart
11:03:57 <fax> but it ca have other properties too
11:04:00 <edwardk_> @src genericLength
11:04:00 <lambdabot> genericLength []    = 0
11:04:00 <lambdabot> genericLength (_:l) = 1 + genericLength l
11:04:13 <pastorn> edwardk_: that might not be true, you know
11:04:14 <edwardk_> it works right n your Num instance, so if that is expensive...
11:04:19 <chrisdone> fax: hehe that would be a cheeky implementation :p
11:04:19 <jmcarthur> BONUS: in particular, if we are going to limit the type of list lengths, should it not be Word rather than Int anyway?
11:04:33 <edwardk_> pastorn: hence the inclusion of genericLength
11:04:43 <jmcarthur> especially considering (!!) and such
11:04:54 <BONUS> ah. cause currently editing LYAH and there i mention that length has a restrictive type because of historical reasons
11:05:07 <BONUS> the technical reviewer disagrees based on what it says in the report
11:05:11 <BONUS> so i'm wondering
11:05:26 <edwardk_> chrisdone: alas, not valid, Num provides no laws connecting fromIntegral and (+)
11:05:47 <pastorn> @src length
11:05:47 <lambdabot> Source not found. You speak an infinite deal of nothing
11:05:50 <jmcarthur> Num is a wart
11:05:58 <Cale> edwardk_: Though everyone knows that fromInteger ought to be the unique homomorphism from Z into whatever ring you're defining
11:06:09 <edwardk_> it has a restrictive type as one of the random nods to performance/reality in the prelude ;)
11:06:25 <Cale> I think that Int should not occur in the Prelude
11:06:26 <edwardk_> Cale: yes, but that law isn't actually stated =)
11:06:37 <Cale> right
11:06:53 <Cale> Int is a correctness-damaging premature optimisation
11:07:07 <Cale> and it should be shipped out to a separate library
11:07:11 <jmcarthur> i do consider the widespread use of Int in the standard libraries to be a wart
11:07:31 <Eelis> i agree.
11:07:34 <fax> I just hate that there IS a standard library
11:07:59 <jmcarthur> i would also say that in many cases Integer is wrong too. we really need a Natural type (Int is to Integer as Word is to Natural, or something like that)
11:08:05 <fax> they shtould put it all into a cabal thing so we don't have to use it
11:08:49 <Cale> Oh, I pretty much agree about that as well
11:09:09 <Eelis> suppose i need something like haskell-src but which doesn't break on foreign fixities. is there perhaps a way to get ghc to dump concrete syntax trees for compiled modules?
11:09:12 <jmcarthur> fax: i don't mind there being a standard library. i agree that i'd like to be able to entirely not use it if i want
11:09:21 <felzix> Can I make cabal not require every single library I use to need a Build-Depends?
11:10:46 <chrisdone> felzix: can you rewrite that sentence i don't get it?
11:11:21 <felzix> chrisdone: I don't want to specify every library I use in Build-Depends. Cabal seems to demand this, however.
11:11:54 <felzix> My problem really is that cabal isn't using the same library paths as ghc is but no one answered that question so I decided to try this one.
11:12:31 <jmcarthur> it seems counter to the purpose of cabal not to list a package's dependencies
11:12:34 <jmcarthur> to me
11:12:44 <fax> noam???
11:12:45 <Polarina> Hmm... a monad chapter. :P
11:12:56 <noam> what?
11:13:05 <fax> 18:10 -!- 77CAAGZR0 [~k4jd095b@IGLD-84-228-74-1.inter.net.il] has joined #haskell
11:13:12 <fax> 18:11 -!- 18VAAN5YD [~k4jd095b@IGLD-84-228-74-1.inter.net.il] has joined #haskell
11:13:17 <edwardk_> Eelis: you should be able to specify a list of current fixities if you know them
11:13:21 <noam> erm
11:13:25 <fax> forgot to turn off spambot mode?
11:13:35 <noam> i had a
11:13:37 <noam> yes
11:13:55 <fax> ...
11:13:56 <noam> but no not really
11:14:15 <Eelis> edwardk_: i'm not interested in piling hack onto hack. i want a _proper_ solution, and that involves resolving the references to automatically find the actual fixities :)
11:15:19 <felzix> How do I specify the PATH for libraries in cabal. I want to specify Build-Depends with something I manually installed.
11:16:01 <jmcarthur> felzix: how did you install it? it should be listed by ghc-pkg list, if you did it properly
11:16:31 <felzix> it is listed as cmdargs-0.1.1
11:16:31 <Cale> There is no path, either the library is registered with ghc, or it's not.
11:16:39 <Cale> okay, so just use that name
11:17:07 <edwardk_> Eelis: harrass the ghc folks to get better fixity info out of TH ;)
11:17:15 <edwardk_> Eelis: and info on what is currently in scope
11:17:16 <felzix> Cale: I am.
11:17:27 <jmcarthur> felzix: add cmdargs == 0.1.1 to you build depends and it should just work. with a recent enough version of cabal you should be able to say something like  cmdargs == 0.1.*
11:17:31 <jmcarthur> *to your
11:18:11 <Polarina> BONUS, !ping
11:18:18 <BONUS> yo
11:18:24 <Polarina> BONUS, http://learnyouahaskell.com/monads   ;)
11:18:33 <BONUS> agh!
11:18:35 <fax> learn you a monads!
11:18:41 <Eelis> edwardk_: does haskell-src use TH to parse code?
11:18:43 * hackagebot AspectAG 0.1.6 - Attribute Grammars in the form of an EDSL  http://hackage.haskell.org/package/AspectAG-0.1.6 (MarcosViera)
11:18:49 * jmcarthur hacks BONUS's server
11:18:51 <felzix> jmcarthur: neither of those work. I've also tried not specifying version
11:18:57 <pastorn> Polarina: you h4xx3d it
11:19:00 <jmcarthur> felzix: what does it say?
11:19:16 <Polarina> pastorn, yes, yes I did, I did indeed.
11:19:21 <BONUS> monads are cancelled! the next chapter will be about potatoes instead.
11:19:21 <edwardk_> Eelis: haskell src-exts gives you a parse tree ready to be refixitied. parse each of the modules you want and then run the reassociation code
11:19:33 <edwardk_> once you know the fixity definitions you need
11:19:37 <Polarina> BONUS, not Java? :(
11:19:42 <Eelis> edwardk_: hmm.
11:19:43 <pastorn> BONUS: fish and chips?
11:19:43 <edwardk_> in my case it is harder because i want it for a quasiquoter
11:19:49 <BONUS> a little bit of both
11:19:55 <edwardk_> and there i definitely lack the info i need
11:19:58 <felzix> http://pastebin.com/TzAS5xe0
11:20:09 <edwardk_> because some of my fixities come from the same module
11:20:50 <jmcarthur> felzix: are you sure the package is not hidden?
11:21:03 <Eelis> edwardk_: what would be really neat is if we could just translate the output from ghc's various -ddump-* options back into a haskell-src tree value.
11:21:11 <felzix> jmcarthur: for all I know it could be. I am able to use it just fine doing normal imports, though
11:21:35 <Eelis> edwardk_: better yet, perhaps it can be done with a ghc plugin!
11:21:55 <jmcarthur> felzix: oh i know what it is. use  runhaskell Setup.hs configure --user
11:21:57 <edwardk_> Eelis: are you doing this in TH?
11:22:09 <Eelis> edwardk_: i'm not doing anything :)
11:22:11 <jmcarthur> felzix: i use cabal-install to manage my builds which does that automatically, so i didn't think of it
11:22:13 <felzix> jmcarthur: that works!
11:22:22 <Eelis> edwardk_: i'm just musing on the state of affairs and how things ought to work
11:22:34 <Polarina> BONUS, any possibility for a sneak-peak of the monad chapter? Or a teaser?
11:22:46 <pastorn> BONUS: link a picture from it?
11:22:50 <edwardk_> Eelis: the worst idea i can think of is to use TH to use IO to go out and reparse the current file using haskell-src-exts looking for starting fixities
11:22:54 <jmcarthur> felzix: if you have cabal-install, you can just say cabal configure
11:23:04 <jmcarthur> felzix: and cabal build to build it
11:23:12 <edwardk_> I saw worst because i hesistate to ever say that that is my best idea ;)
11:23:36 <felzix> jmcarthur: Thanks! I was about to ask you if there was an option that didn't install the package, since I just want to build it.
11:24:33 <Eelis> edwardk_: another idea: use the GHC api
11:24:57 <Eelis> edwardk_: translating from the GHC api syntax tree type to the haskell-src syntax tree type shouldn't be rocket science, i hope
11:26:56 <BONUS> no sneak peak yet! patience, grasshopper!
11:28:11 <Polarina> :(
11:29:51 <edwardk_> Eelis: but you only get access to the TH info, which isn't enough
11:30:27 <Eelis> edwardk_: oh, then i'm overestimating the GHC api :(
11:30:42 <edwardk_> Eelis: or I'm underestimating it
11:30:57 <Eelis> though i'm not at all sure what TH has to do with it. i'm talking about http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-6.12.1/index.html
11:32:27 <edwardk_> yeah. i was talking about being in the middle of let infixl 2 ^; x ^ y = (x && not y) || (not x && y); z = [$myparser| foo ^ bar ^ baz == quux |] in z
11:34:10 <aavogt> does that work yet?
11:34:45 <edwardk_> aavogt: no
11:34:47 <aavogt> fixities have been an issue for me with haskell-src-exts
11:34:57 <edwardk_> aavogt: that was the complaint above ;)
11:36:04 <edwardk_> aavogt:: theoretically you should be able to comb through and find any use of fixity that is ambiguous and complain at compile time that it needs manual parens
11:36:51 <aavogt> you look for operator-things, get the fixity from reify, and feed that to hsx?
11:36:56 <EvanR-work> there seems to be some controversy whether this 99 bottles malbolge program really loops or just prints output constant value hard coded into the code
11:39:53 <mercury^> I thought there was a simple proof for it looping.
11:40:53 <fax> of what?
11:41:22 <EvanR-work> http://www.lscheffer.com/malbolge.shtml site claims it doesnt, and some of the lamer comments by the source listing cast doubt on it
11:42:28 <EvanR-work> could have been talking about the 'known fake' but the link clearly goes to the one thats supposed to be real
11:42:41 <EvanR-work> http://www.99-bottles-of-beer.net/language-malbolge-995.html
11:44:00 <aavogt> edwardk_: does the Q used in the quote there have access to the fixity of `^'?
11:44:27 <edwardk_> aavogt: no, that is the problem =(
11:45:22 <aavogt> there is some fundamental reason it can't?
11:45:56 <edwardk_> aavogt: not to my knowledge. there is a slot in the info.
11:51:30 <ksf> ...no pwrite in System.Posix.IO?
11:52:56 <felzix> What's a good way to find where Prelude.head is being applied to an empty list?
11:54:25 <liyang> grep head *.hs
11:54:48 <liyang> it's an evil function and should never be used!
11:56:12 <felzix> liyang: what would you suggest in its place?
11:56:20 <bremner> pattern matching
11:57:14 <felzix> hmm, ok. Is there a better way, though? I'm pretty sure the error is in a library I'm using.
11:58:34 <Polarina> felzix, try applying breakpoints at various locations and eliminate possibilities.
12:03:31 <Sgeo> > fix id
12:03:35 <lambdabot>   mueval-core: Time limit exceeded
12:03:45 <Sgeo> fix (+0)
12:03:49 <Sgeo> > fix (+0)
12:03:52 <lambdabot>   mueval-core: Time limit exceeded
12:06:12 <Cale> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
12:06:13 <lambdabot>   3628800
12:07:12 <felzix> Interestingly, if I enable profiling, "cabal install" cannot find cmdargs.
12:07:54 <mercury^> Sgeo: fix is always bottom if the argument is strict.
12:08:51 <EvanR-work> @src fix
12:08:51 <lambdabot> fix f = let x = f x in x
12:08:52 <Sgeo> Wait, what's that 10 for?
12:09:05 <sizzler> if there is a data declaration defined in a module A without using record syntax, is it still possible to get accessor like functions for that datatype when imported used in Module B.
12:09:09 <mercury^> It's the argument to the newly created factorial function.
12:09:32 <Sgeo> So then what is fix operating on?
12:09:56 <EvanR-work> > let Y f = f (Y f) in Y (\fac n -> if n == 0 then 1 else n*fac (n-1)) 10
12:09:57 <lambdabot>   Not in scope: data constructor `Y'Not in scope: data constructor `Y'Not in ...
12:09:57 <Sgeo> Oh, that lambda takes two args
12:10:01 <mercury^> The part in matching parenthesis following fix.
12:10:22 <ksf> NOTES
12:10:22 <ksf>        This document's use of whence is incorrect English, but maintained for historical reasons.
12:10:25 <ksf> I love man pages
12:10:25 <EvanR-work> > let y f = f (y f) in y (\fac n -> if n == 0 then 1 else n*fac (n-1)) 10
12:10:26 <lambdabot>   3628800
12:10:28 <EvanR-work> yay
12:10:32 <LeoD> ksf: haha
12:10:42 <mercury^> ksf: which one?
12:10:52 <ksf> lseek
12:11:03 <mercury^> don't have that :(
12:11:21 <ksf> http://www.kernel.org/doc/man-pages/
12:11:33 <ksf> sounds like a debian or such.
12:11:46 <LeoD> mine doesn't have the note :(
12:11:49 <Cale> > let y f = x where x = f x in y ((0:) . scanl (+) 1)
12:11:50 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
12:12:06 <ksf> release 3.20, dated 2001-09-24
12:13:52 <liyang> if I see that damn Fibonacci function one more time… >_>
12:14:02 <LeoD> hah
12:14:04 <mercury^> A change in language really would confuse the old timers, better maintain it as is and put up a warning...
12:14:41 <sizzler> like in http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24702#a24702
12:15:15 <mercury^> That is such an unlikely mistake to make.
12:17:09 <Cale> sizzler: You could write them by hand
12:17:21 <Cale> sizzler: colorName (Color x) = x
12:18:42 <sizzler> is there any way to avoid writing them by hand. There is quite a lot of data declarations requiring lot of functions to be written
12:19:04 <sizzler> is there a way to generate the accessor functions using a package maybe
12:19:33 <Polarina> Why is http://community.haskell.org/admin/tos.html so restrictive and discriminative?
12:19:37 <stevenmarky_> write a lil parser and code generator to make them maybe
12:20:00 <liyang> sizzler: why not fix module A, or is that out of your control?
12:20:08 <sclv> Polarina: what's wrong with them?
12:20:18 <sizzler> module A is not in my control, I am just using them
12:20:33 <Polarina> sclv, second paragraph, under "Export Controls" is discriminative. The first under the same section is restrictive.
12:20:44 <Polarina> "Users residing in countries on the United States Office of Foreign Assets Control sanction list, including Cuba, Iran, Libya, North Korea, Sudan and Syria, may not post or access CONTENT available through OUR services."
12:20:52 <liyang> sizzler: Submit a patch? :-/ (Also consider using something like data-accessor?)
12:21:21 <sclv> legalese boilerplate for hosting in the u.s., I'd imagine?
12:21:46 <Polarina> sclv, but why the discrimination?
12:21:54 <Polarina> What's wrong with those countries?
12:21:57 <sclv> to comply with u.s. law
12:21:58 <Polarina> Nothing.
12:22:26 <sclv> I'm not saying its good, I'm saying that there's a office of foreign assets control sanction list
12:22:33 <Polarina> :(
12:23:00 <sclv> I think that lots of webservices have to have the same stuff to make the lawyers happy.
12:23:06 <sizzler> ok liyang will consider your suggestions
12:23:28 <sclv> If it turns out that the law doesn't mandate this or something similar, then its a different issue.
12:23:45 <Polarina> sclv, the laws should be changed.
12:23:53 <benmachine> undoubtedly
12:24:42 <sclv> sure. but in the meantime, community.haskell.org is not going to be the test case.
12:25:01 <sclv> for one, galois hosts it, as i recall, which has plenty of government contracts.
12:25:06 <twink> > let fib 0 = 0 ; fib 1 = 1 ; fib 2 = 1 ; fib n = case n `divMod` 2 of { (q,1) -> (fib q)^2 + (fib (q + 1))^2 ; (q,_) -> let t = fib q in t * (2 * fib (q+1) - t) } in map fib [0..10]
12:25:07 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55]
12:25:49 <Polarina> twink, that's overkill for fibonacci.
12:26:35 <Polarina> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
12:26:36 <lambdabot>   not an expression: `let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)'
12:26:47 <Polarina> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
12:26:48 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
12:26:51 <edwardk_> Polarina: good luck with that. it is like with most laws. it is hard to get someone to stand up and say "in the interest of consistency you should subsidize erectile disfunction medication for convinced sex offenders!" -- or yes we should allow those bad countries we've excecuted sanctions against to download stuff
12:26:54 <twink> I'm always overkill on Fibonacci.
12:26:55 <benmachine> seems twink's algorithm is better than the usual
12:27:40 <rajeshsr> is there any "secured" smtp lib for haskell? an lib that can communicate with gmail?
12:28:11 <edwardk_> i used to write cryptographic software before i realized that being an american hopelessly crippled me in that regard on the world stage =/ at one point i was legally registered as an arms dealer for that purpose ;)
12:29:15 <Twey> Ych
12:29:19 <twink> benmachine: Well, I'd bitreverse a fixed-width argument if I really wanted speed.
12:29:27 <Polarina> I can do cryptography all I want. :D
12:29:53 <twink> benmachine: (which is what I did for the fastest)
12:30:01 <Twey> > let fib = (!!) fibs where fibs = zipWith (+) fibs $ tail fibs in map fib [1 .. 10]
12:30:02 <benmachine> neat
12:30:04 <arw_> count your blessings. there are countries which not only have export restrictions on crypto but usage restrictions...
12:30:05 <lambdabot>   mueval-core: Time limit exceeded
12:30:28 <Twey> Er what?
12:30:34 <arw_> like "never ever do crypto over your ham radio connection or you loose your license"
12:30:54 <arw_> or "no rsa with more than 384bit"
12:30:57 <liyang> Does speaking in Navajo count as ‘doing crypto’?
12:30:59 <arw_> stuff like that.
12:31:05 <fax> yeah like britan
12:31:06 <Twey> Oh, haha
12:31:15 <Twey> > let fib = (!!) fibs where fibs = 0 : 1 : zipWith (+) fibs $ tail fibs in map fib [1 .. 10]
12:31:16 <sclv> > let fibs = extendSequence [0,1,1] in fibs
12:31:16 <lambdabot>   Couldn't match expected type `[t]'
12:31:16 <lambdabot>         against inferred type `[a] -> [a]'
12:31:17 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
12:31:24 <Twey> sclv: Cheating :þ
12:31:41 <Polarina> Haha.
12:31:54 <Twey> > let fib = (!!) fibs where fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in map fib [1 .. 10]
12:31:55 <lambdabot>   [1,1,2,3,5,8,13,21,34,55]
12:31:59 <burp> I think they can even force you to handle over the encryption key in britain
12:32:05 <Twey> > let fib = (!!) fibs where fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in map fib [0 .. 10]
12:32:06 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55]
12:32:09 <Twey> There we go
12:32:12 <Twey> burp: Yeah :-\
12:32:20 <Twey> We're allowed to use strong encryption, though
12:32:23 <Polarina> burp, I'll eat it before that happens, or better, encrypt the encryption key! :D
12:32:24 <dv-> burp: 5 years if you refuse
12:32:26 <Twey> And I think they have to have reasonable cause
12:32:33 <stevenmarky_> but what if you forget the key
12:32:42 <Twey> Polarina: Or plausible deniability ;)
12:33:01 <Polarina> Twey, or claim those are random bits. :P
12:33:09 <arw_> stevenmarky_: 5 years, because you took no precautions against your forgetfulness...
12:33:13 <Twey> Polarina: That's plausible deniability :þ
12:33:41 <Twey> stevenmarky_: Good question…
12:33:44 <Polarina> Twey, :Þ
12:33:53 <burp> hope they believe you ;-)
12:34:31 <liyang> Use layered crypto with plausible deniability. (There's a correct technical term for this that's eluding me right now.)
12:34:55 <dv-> They're holding some guy in a mental facility because they say he's paranoid and thinks the government is out to get him
12:35:29 <burp> shutter island? ;)
12:35:34 <liyang> dv-: don't tell them where I live.
12:36:27 <dv-> He was arrested for having a pocket knife, refusing to reveal his passphrase and having 9 nanograms of rdx on his hand
12:36:57 <liyang> RDX?
12:37:00 <Polarina> What's wrong with pocket knives?
12:37:03 <arw_> military explosive.
12:37:34 <arw_> http://en.wikipedia.org/wiki/RDX
12:37:46 <Polarina> RDX is a register on my CPU. :S
12:37:58 <Vanadium> That is what I was thinking too
12:38:13 <brooksbp> Can someone here help me with a search?  I'm trying to find interesting research related to abstract machines (like the SECD machine); particularly using abstract machines to understand memory usage of programs.  Does anyone have suggestions, directions, or links?
12:38:37 <chrisdone> @seen gwern
12:38:37 <lambdabot> Unknown command, try @list
12:38:41 <chrisdone> preflex: seen gwern
12:38:42 <preflex>  gwern was last seen on #haskell 5 days, 19 hours, 24 minutes and 20 seconds ago, saying: what new data could become public after the release of the ciphertext? hm
12:41:35 <liyang> brooksbp: G Hutton and C Hope had some stuff on step counting some years ago for space and time usage.
12:42:47 <brooksbp> liyang: Thanks!
12:43:34 <brooksbp> I guess a better way to rephrase what I'm asking for is: Techniques to analyze environments (Ident -> Value) using abstract machines.
12:55:12 <zong_sharo> can anyone help me with some typeclass magic?
12:55:19 <zong_sharo> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24704#a24704
12:55:52 <zong_sharo> basically i want to propagate instances of the parts of structure to the combined structure
13:00:03 <monochrom> I can see a problem with "A (C,C) C" matching both instances.
13:02:15 <zong_sharo> aah
13:02:16 <zong_sharo> okay
13:03:12 <narens> how can I make sure that the contents of a file I read are garbage collected after the contents have been used?
13:03:27 <liyang> There's always {-# LANGUAGE OverlappingInstances #-} </evil>
13:03:59 <zong_sharo> narens: u can't
13:04:07 <narens> why not
13:04:13 <zong_sharo> sry, contents
13:04:16 <narens> I am using the lazy readFile
13:04:26 <aavogt> infix constructors are confusing to explicitly import
13:04:35 <narens> I mean if i apply pure functions then certainly the memory usage never goes up
13:04:36 <sclv> in this case overlapping instances should be ok?
13:04:38 <zong_sharo> as soon you get rid of all references on data, it will be garbage collected
13:04:43 <sclv> since there's no problem with method selection.
13:04:50 <narens> but, I am running monadic code on it and the memory is not being freed
13:05:00 <sclv> by ghc you mean?
13:05:07 <sclv> as in the executable's memory doesn't go down?
13:05:15 <sclv> the runtime doesn't give back memory to the OS.
13:05:24 <sclv> It just keeps it in a pool.
13:05:46 <Polarina> What parser library do people here recommend? :)
13:05:59 <zong_sharo> liyang: overlapping instances does not changes anything
13:06:08 <zong_sharo> Polarina: parsec, attoparsec
13:06:09 <burp> Polarina: attoparsec
13:06:12 <narens> I mean, I am reading a file laziliy and applying a monadic process to each line and then once I am finished... I read repeat the process a few more times. After each repetition the previous stuff read in needs to be freed but it isn't getting freed
13:06:14 <Polarina> attoparsec?
13:06:21 <lpsmith> Polarina, happy!
13:06:23 <monochrom> {-# LANGUAGE MultiParamTypeClasses,FlexibleInstances,OverlappingInstances,IncoherentInstances,UndecidableInstances #-} does not change it, to save you time.
13:06:24 <lpsmith> :)
13:06:29 <Polarina> o.O
13:06:49 <zong_sharo> monochrom: still
13:07:06 <lpsmith> I've used attoparsec a bit though;  I do like it.   Parsec,  Attoparsec, and Happy are all good choices.   I'm sure there are others
13:07:25 <zong_sharo> monochrom: nope, error still there
13:07:28 <liyang> zong_sharo: it wasn't a serious suggestion…
13:07:32 <zong_sharo> okay
13:07:48 <Polarina> What's the differences between parsec, attoparsec and happy?
13:07:54 <zong_sharo> any advice, how can i do this kind of stuff?
13:08:04 <zong_sharo> Polarina: happy is offline parser generator, irrc
13:08:06 <lpsmith> Is there an implementation of Swierstra and Duponcheel's LL(1) combinators?
13:08:08 <zong_sharo> like bison/lex
13:08:26 <lpsmith> zong_sharo, yes
13:08:32 <monochrom> instance checking is naïve. it just looks at "A (c,x) b" and "A (x,c) b" and already calls it duplication. It does not consider "A b c =>" until a later stage.
13:08:34 <zong_sharo> parsec and attoparsec is parser combinators embeded domain specific language
13:08:47 <zong_sharo> s
13:09:18 <zong_sharo> attoparsec is much faster, but error messages are less friendly
13:09:26 <lpsmith> Is there an implementation of Swierstra and Duponcheel's LL(1) combinators on hackage?
13:09:47 <sclv> hmm
13:10:13 <zong_sharo> lpsmith: google://site:hackage.haskell.org Duponcheel
13:10:25 <sclv> I bet you could use oleg's typecheck function and in particular type level equality checking...
13:10:31 <sclv> but that's painful.
13:13:40 <ManateeLazyCat> How to request a mail-list for project developing?
13:14:13 <clanehin> Trying to figure out why the bytestring that ships with debian doesn't support an IsString instance, even though matching hackage version does.
13:14:14 <ManateeLazyCat> And have a free website for Wiki?
13:15:22 <ManateeLazyCat> How to request a static irc channel?
13:15:53 <Twey> /msg chanserv help register
13:17:02 <chrisdone> is it possible for me to throw an IO exception?
13:17:13 <chrisdone> I can't find the constructors
13:17:15 <sclv> ?hoogle throwIO
13:17:15 <lambdabot> Control.Exception throwIO :: Exception e => e -> IO a
13:17:16 <lambdabot> Control.OldException throwIO :: Exception e => e -> IO a
13:17:16 <lambdabot> Control.Exception.Base throwIO :: Exception e => e -> IO a
13:17:28 <fax> error "aaaaaa"
13:17:30 <sclv> oh, i see, an IO type exception
13:17:40 <fax> fail "fff
13:17:40 <chrisdone> yeah I'm pattern matching on it
13:17:51 <fax> :t catch
13:17:51 <chrisdone> sorry, type matching
13:17:52 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
13:17:58 <fax> that's not it
13:17:58 <chrisdone> repl mueval' `C.catch` \(_ :: C.IOException) -> do
13:17:59 <fax> :t catchIO
13:18:00 <lambdabot> Not in scope: `catchIO'
13:18:07 <chrisdone> so I wanna throw an IOException myself within the `repl' code
13:18:44 <sclv> see System.IO.Error
13:18:46 <chrisdone> hrm
13:18:48 <monochrom> Look in System.IO.Error
13:18:49 <chrisdone> ok
13:18:57 <sclv> ioerrors are an abstract type, but it provides the functions to build them.
13:19:13 <chrisdone> ah brilliant cheers
13:19:19 <sclv> now that we have extensible exceptions this is sort of an outdated way to do things, but its baked deep in
13:20:28 <monochrom> Yeah, if you will catch the exception yourself too, invent your own exception type, then use Control.Exception's typeclass thingie.
13:21:11 <mightybyte> bos: ping
13:21:21 <bos> pong
13:22:04 <pokoko222> CT guys in here?
13:22:09 <mightybyte> bos: I'm using your statistics package, and I find myself wishing the Distribution type class had another function called genSamples (or similar).
13:22:16 <mightybyte> bos: What do you think about that?
13:22:24 <pokoko222> i read but i can not understand, what is really a normal subgroup?
13:22:37 <fax> lol
13:22:52 <fax> http://math.ucr.edu/home/baez/normal.html
13:23:10 <fax> this is not category theory
13:24:06 <bos> mightybyte: why not just use mwc-random for that?
13:24:49 <pokoko222> fax well it is abstract algebra, i said ct sinse lot of people here know stuff
13:24:49 <mightybyte> bos: Yes, that's what would be used.  But in my application, one of the main points of the Distribution abstraction is to facilitate the generation of random variates.
13:25:00 <fax> yeah it's still not category theory
13:25:13 <bos> mightybyte: it's a lot of bother to write a good PRNG for every distribution, so adding that to a typeclass would imply either a lot of effort or a lot of (error "unimplemented")
13:25:33 <ulfdoz> So, uffgewaschen, Hinter gekratzt, Nase gebohrt.
13:25:38 <ulfdoz> ewin,s orry.
13:25:59 <mightybyte> bos: Yeah, but a lot of bother/effort also means a lot of value added in my mind.
13:26:11 <pokoko222> fax yeah i still know, thanks anyways, cool site ;)
13:26:26 <monochrom> Hi any Fields medalist here? What is logical negation?
13:26:35 <fax> :))))
13:27:40 <bos> mightybyte: if you want to do the work, i'll review a patch and consider accepting it.
13:28:07 <mightybyte> bos: The distributions I've added are fairly easy to generate based on uniform and normal.
13:28:38 <pokoko222> monochrom me
13:29:11 <monochrom> You are not logical negation.
13:29:44 <kmc> haha
13:29:57 <Twey> You are not: logical negation
13:30:11 <monochrom> haha
13:30:21 <mauke> as a sleeper in metropolis
13:30:47 <pokoko222> i am abnormal subgroup ma
13:31:05 <clanehin> Let me rephrase my previous question: is it intentional that only the Char8 versions of ByteString support IsString?
13:31:12 <mightybyte> bos: Ok, I may work on that.  (A couple weeks ago I sent you an email about this question.  Don't worry about responding to it.)
13:32:18 <Saizan> clanehin: there are only strict and lazy bytestring, not char8 or non-char8 ones
13:32:23 <bos> mightybyte: yeah, i saw your email. i'd have gotten to it some time in the next month or two :-(
13:32:31 <mightybyte> heh
13:33:07 <mightybyte> bos: Any objections to adding a few more distributions in the process?
13:33:11 <Saizan> clanehin: Data.ByteString.Char8.ByteString is the same as Data.ByteString.ByteString
13:33:16 <pokoko222> the more i read on abstract algebra the more it seems like religion :O i gotta get myself a mentor
13:33:26 <Saizan> and the same holds if you add .Lazy
13:34:40 <clanehin> Saizan: Ok, I get it.  What's throwing me is that the IsString Bytestring instance is reported by hackage's docs under Data.Bytestring .
13:34:42 <kmc> any way i can force a top-level binding to be monomorphic without otherwise constraining its type?
13:35:01 <clanehin> But it's actually under Data.Bytestring.Char8 .
13:35:09 <monochrom> By writing it in the form "name = value", no parameter, e.g., no "name x = value".
13:35:11 <ManateeLazyCat> Have any site support darcs like GitHub for Git?
13:35:25 <kmc> pokoko222, math is like religion in that we invent totally arbitrary rules and then see what the consequences are
13:35:26 <Saizan> clanehin: oh, haddock lists the instances under the type, it doesn't care about where it gets exported
13:35:51 <Saizan> clanehin: pretty confusing at times
13:35:53 <kmc> it's unlike religion in that some effort goes into making the rules consistent, and maybe even useful for solving practical problems
13:35:54 <pokoko222> kmc yeah man, you are nasty people
13:36:08 <kmc> that's right
13:36:20 <clanehin> Saizan: yeah, I'm gonna run off and see if someone's filed a bug report on this yet.
13:36:21 <Saizan> ManateeLazyCat: see patch-tag
13:36:37 <kmc> monochrom, doesn't work
13:36:48 <ManateeLazyCat> Saizan: Thanks.
13:36:51 <kmc> when i say "a = undefined" and check ":t a" i get a :: t
13:36:56 <kmc> perhaps i need to turn on MMR somehow?
13:37:06 <monochrom> Works for me.
13:37:13 <Saizan> no, the MR works only on typeclass polymorphic values
13:37:18 <ManateeLazyCat> Saizan: All haskeller just use Darcs ? Don't use Git?
13:37:27 <Peaker> I use git
13:37:32 <kmc> i use git
13:37:37 <Saizan> there are many that use git.
13:37:38 <kmc> the darcs site is patch-tag
13:37:50 <Saizan> before we start the whole dvcs discussion again :)
13:38:32 <kmc> pokoko222, just so you know, i will never respond to a PM from you
13:38:43 <ManateeLazyCat> patch-tag looks too simple.
13:38:46 <kmc> you might save your typing ;)
13:39:12 <pokoko222> kmc u love me that much? ok someone else please recommend a noob book on abstract algebra, i tried stuff and seems i learn nothing
13:39:15 <ManateeLazyCat> kmc: Why you use git and not darcs ?
13:39:18 <Vanadium> What, would you prefer he broke into your house and made himself comfortable in your living room instead?
13:39:24 <ManateeLazyCat> kmc: More powerful?
13:39:26 <kmc> ManateeLazyCat, because i had to learn git for work and liked it a lot
13:39:31 <kmc> and i never learned darcs to that degree
13:39:34 <fax> pokoko222 have you proved l'hopital yet
13:39:58 <pokoko222> fax are you saying "forget abstract algebra, finish spivak first" ?
13:40:08 <fax> pokoko222 no
13:40:14 <kmc> no you see pokoko222 is a super math ninja, and therefore can skip right to abstract n-category hypertopos theory
13:40:16 <fax> pokoko222 just read what I said literally, it's not symbolic
13:40:34 <ManateeLazyCat> I afraid most haskeller just use darcs, then send git patch is problem.
13:40:47 * sclv idly tries to come up with a pun on l'hopital involving rabbits
13:40:50 <fax> pokoko222 I suppose you did answer "no I haven't proved l'hopitals rule"
13:41:09 <fax> pokoko222 -- this makes me think you are not serious about learning math
13:42:19 <edwardk_> ManateeLazyCat: patch-tag just works ;)
13:42:23 <monochrom> I skipped proving l'Hôpital. I went for Taylor expansion instead. More general and more regular.
13:42:30 <edwardk_> ManateeLazyCat: though i admit the wiki formatting leaves something to be desired
13:42:49 <sclv> I don't really like the wiki sticking its files in my general repo.
13:42:56 <ManateeLazyCat> edwardk_: Yep, i'm looking for wiki site.
13:42:59 <edwardk_> sclv: yeah if i could get a sub-folder i'd be happier
13:42:59 <sclv> Would much prefer a seperate wiki repo for a given project.
13:43:03 <xerox> FWIT l'Hôpital is MVT basically
13:43:05 <ManateeLazyCat> Free, and haven't limit.
13:43:15 <jmcarthur> what? the wiki puts files in the repo? gross!
13:43:18 <edwardk_> sclv: you can of course always make one
13:43:21 <kmc> i think we came to that conclusion a long time ago
13:43:24 <jmcarthur> glad i never enabled a wiki. i would not have been happy with that
13:43:45 <edwardk_> jmcarthur: http://patch-tag.com/r/ekmett/ersatz/snapshot/current/content/pretty
13:43:48 <sclv> I enabled one then disabled it soon after when I came to that realization
13:43:49 <edwardk_> kind of annoyed me
13:43:53 <xerox> (but I perfectly agree with Taylor being better.)
13:44:27 <ManateeLazyCat> HaskellWiki for homepage, gmane for mail-list, freenode.net for IRC, hackage for darcs and cabal.
13:44:33 <ManateeLazyCat> Or better solution?
13:44:55 <ManateeLazyCat> Maybe twitter for Wiki. Joking. :)
13:45:27 <jmcarthur> edwardk_: ugh sharing the repo with gitit :(
13:45:38 <monochrom> l'Hôpital is ugly to prove because there are at least two separate cases 0/0 and oo/oo and whatnot, each case needs something different, not nicely unified.
13:45:55 <ManateeLazyCat> But i hackage server always down.
13:46:10 <ManateeLazyCat> edwardk_: patch-tag stable?
13:46:19 <edwardk_> jmcarthur: yeah i may try and make a subdir with the wiki pages and just point the main page there so one stub like wiki page and the rest in the sub-dirs.
13:46:31 <edwardk_> jmcarthur: but i'm not all that overwhelmed by the css on it
13:46:55 <b_boys150> Hi
13:47:08 <edwardk_> so there are a lot of accumulated negatives are
13:47:18 <edwardk_> er s/ are$//
13:47:20 <b_boys150> !p1
13:48:07 <jmcarthur> it really says something about a lot of C code that when i'm reading it i keep wanting to call the activity "reverse engineering"
13:48:43 <c_wraith> abstraction is slow!
13:49:11 <jmcarthur> we don't need no stinkin' abstraction
13:49:23 <arw_> excess abstraction can make code just as unreadable as a lack of abstraction
13:49:32 * arw_ points to certain java abominations
13:49:46 <b_boys150> !p1 -s 174.36.42.115 -sp 88.191.109.130
13:49:51 <jmcarthur> arw_: i would not call anything abstraction which does not hide complexity
13:50:05 <b_boys150> !p1 -s 88.191.109.130 -sp 174.36.42.115
13:50:10 --- mode: ChanServ set +o monochrom
13:50:22 --- mode: monochrom set +q b_boys150!*@*
13:50:23 <jmcarthur> arw_: obfuscation is the word i would use for a lot of the odd tricks i see in java code
13:51:22 <arw_> jmcarthur: abstraction may hide complexity and at the same time make code unreadable and hard to understand. sometimes its better to leave some of the inner workings exposed.
13:51:25 <edwardk_> c_wraith: then you're using the wrong abstraction ;)
13:51:59 <jmcarthur> arw_: the logic behind it being things along the lines of "i must restructure my code to maintain abstraction X no matter the cost"... it's not the abstraction that's bad, it's the costs of maintaining it in the language
13:52:01 <edwardk_> any behavior taken to a pathological extreme can have detrimental effects
13:52:02 <Peaker> arw_, "unreadable" is a binary verb, not a unary one :)  It becomes unreadable to the casual reader, but more readable to the well-versed
13:52:30 <c_wraith> edwardk_: more often than not, you're really caring about the wrong thing.  my point was that C programmers tend to think anything that costs an extra cycle ever is bad for their code
13:52:44 <arw_> jmcarthur: often its easier to just read the code instead of figuring out what what the hell that AbstractFrobnicatorFacadeFactory should do...
13:52:59 <jmcarthur> arw_: if you care what an abstraction does then it's definitely not an abstraction
13:52:59 <edwardk_> c_wraith: as someone who thinks of c as too high level to optimize for every cycle, occasionally i agree
13:53:27 --- mode: monochrom set -q b_boys150!*@*
13:53:30 --- mode: monochrom set -o monochrom
13:53:37 <jmcarthur> i, too, think C is far too high level for it's intended purposes
13:53:41 <jmcarthur> *its
13:53:59 <jmcarthur> "too high level" is probably the wrong wording
13:54:39 <c_wraith> abstracts out the wrong things? (like calling conventions, etc)
13:55:52 <jmcarthur> my problem with C is that it is stuck at a very specific level of abstraction. on the one hand, you can't construct higher level abstractions in it. on the other, you can't get low enough to do a ton of things you can currently on do in assembler. it almost entirely defeats the purpose
13:56:14 <jmcarthur> *currently only do in assembler
13:56:43 <kmc> C was designed as a portable assembler, and in this role it has a few small but critical flaws
13:57:25 <ManateeLazyCat> jmcarthur: Not can't construct higher level abstractions, just hard to maintain.
13:57:46 <Peaker> jmcarthur, you can abstract things nicely in C, IMO
13:58:05 <jmcarthur> you guys must be talking about very different kinds of abstractions from the ones i'm talking about
13:58:05 <arw_> the "higher levels of abstraction capable" variant of C is called C++
13:58:23 <mauke> arw_: no.
13:58:31 <Peaker> jmcarthur, what kind of abstraction are you missing in C?
13:58:51 <jmcarthur> Peaker: how about something simple, for discussion: a reader monad
13:59:08 <fax> jmcarthur you don't need monads in C
13:59:21 <jmcarthur> fax: you don't need monads in haskell, either
13:59:25 <fax> yes you do
13:59:29 <jmcarthur> no you don't
13:59:35 <fax> okay you win
13:59:57 <Peaker> jmcarthur, That kind of abstraction doesn't fare well in other languages either :)
14:00:22 <jmcarthur> Peaker: at least it's remotely possible, even if not practical, in many other languages
14:00:52 <kmc> it's not abstracted if you need to maintain it manually
14:00:53 <kmc> the oldest and most basic form of abstraction is missing in C
14:01:05 <kmc> haha fax
14:01:21 <arw_> what would that be?
14:01:24 <jmcarthur> kmc: you are saying what i'm thinking. keep going!
14:01:39 <kmc> you need monads in Haskell in a trivial sense... the Report has something called "Monad" in it
14:02:06 <kmc> if you take that out you can do IO perfectly well with functions (return :: a -> IO a) and ((>>=) :: IO a -> (a -> IO b) -> IO b)
14:02:13 <jmcarthur> kmc: that says a haskell implementation must provide monads, not that a haskell user must use them
14:02:20 <kmc> true
14:03:15 <kmc> if my language supports adding two integers, does it "require group theory"?
14:03:30 <jmcarthur> anyway, let's ignore the "monad" part of Reader. let's just say we want two C functions called return and bind that mimicks the return and (>>=) of Reader. i still can't think of a nice way to do this
14:03:32 <kmc> the operator (+) is the operator of a group but that may be totally irrelevant to the language design
14:03:50 <kmc> jmcarthur, as soon as you want "bind" you're hosed... because it's a HOF
14:03:52 <zygoloid> does the Report provide any other way of combining two IO actions other than (>>=)?
14:03:53 <jmcarthur> well, we can't call it return obviously ;)
14:03:56 <fax> that's because you are trying to write haskell in C
14:04:07 <kmc> zygoloid, (>>), which can be (but is not necessarily) implemented in terms of (>>=)
14:04:10 <stevenmarky_> What's a HOF? I forgot.
14:04:12 <jmcarthur> fax: okay, rephrase it to work in C then
14:04:13 <kmc> higher order function
14:04:20 <stevenmarky_> ahh.
14:04:33 <aavogt> haskell has LOFs too
14:04:38 <stevenmarky_> perhaps you could use macros to generate a function
14:04:46 <ManateeLazyCat> Which one you use? code.haskell.org or patch-tag.com
14:04:47 <zygoloid> kmc: sure, but (>>) isn't enough to reimplement (>>=)... in any case, i meant something without a Monad m => constraint
14:04:56 <jmcarthur> i find that i want Reader in C all the time, and this is a basic abstraction i can't create. i can't even do it monomorphicly
14:04:57 <kmc> zygoloid, exception stuff
14:05:30 <zygoloid> haha, nice. i wonder if it's possible to write code without (>>=)/join using just 'catch' :D
14:06:01 <kmc> the type of "catch" is not too different from (>>=)
14:06:08 <jmcarthur> :t catch
14:06:09 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
14:06:14 <Twey> I guess it is
14:06:21 <kmc> this is a weird CPS transformation, where you continue by raising an exception
14:06:22 <jmcarthur> :t Control.Exception.catch
14:06:23 <lambdabot> forall a e. (GHC.Exception.Exception e) => IO a -> (e -> IO a) -> IO a
14:06:32 <Twey> You just have to make all your return values GHC.Exception.Exceptions
14:06:38 <jmcarthur> i never thought of catch that way
14:07:00 <Twey> It's a hack used to implement TCO in some languages that don't have it
14:07:04 <kmc> haha
14:07:05 <zygoloid> you also need an IO a -> (a -> e) -> IO a, which raises the 'e' somehow
14:07:18 <jmcarthur> you also can only return the same type from the continuation that the first action returns
14:07:32 <zygoloid> IO a -> (a -> e) -> IO b, rather
14:07:33 <kmc> but you can program useful programs that use only one type
14:07:40 <jmcarthur> yes
14:07:41 <kmc> in that position
14:11:33 <opqdonut> <kmc> this is a weird CPS transformation, where you continue by raising an exception <-- I've done some proof-of-concept code in java that works like that
14:11:50 <opqdonut> in which also no objects got (fully) constructed
14:12:33 <zygoloid> @type let a >>= f = fmap Control.Exception.throw a `Control.Exception.catch` f in (>>=)
14:12:34 <lambdabot> forall a e a1. (GHC.Exception.Exception e, GHC.Exception.Exception a) => IO a -> (e -> IO a1) -> IO a1
14:12:50 <bluetaslem> Hi..
14:12:58 <bluetaslem> Something I was just thinking....
14:13:07 <bluetaslem> How do you generate random number sin Haskell?
14:13:26 <jmcarthur> bluetaslem: check System.Random
14:13:43 <bluetaslem> I see.
14:13:46 <jmcarthur> bluetaslem: there are also some libraries on hackage. mersenne-twister and mwc-random are the best, in my opinion
14:13:50 <monochrom> I took "random number sin" seriously
14:13:57 <bluetaslem> :P
14:13:59 <jmcarthur> lol
14:14:06 <bluetaslem> @Jm
14:14:07 <zygoloid> > randoms (mkStdGen 42) :: [Bool]
14:14:09 <lambdabot> Maybe you meant: . ? @ bf do ft id pl rc v wn
14:14:11 <lambdabot>   [True,True,True,False,False,True,False,True,False,True,True,True,False,Fals...
14:14:19 <jmcarthur> bluetaslem: basically you either do it impurely or you use a pure generator that you pass around
14:14:21 <bluetaslem> Mersenne twister becomes predictable over time.
14:14:36 <fax> ??
14:14:39 <jmcarthur> bluetaslem: according to who?
14:14:42 <fax> you mean REAL random numbers?
14:14:44 <burp> um.. big time :>
14:14:48 <zygoloid> bluetaslem: you want random rather than pseudorandom?
14:14:49 <fax> that's not computable
14:14:58 <bluetaslem> No, no..
14:14:59 <kmc> bluetaslem, usually, within the context of some monad
14:14:59 <kmc> otherwise you have to pass the generator state explicitly
14:14:59 <kmc> the easiest way, for a beginner, is to do it in the IO monad
14:14:59 <kmc> and use the functions randomIO and randomRIO
14:15:01 <kmc> see http://www.haskell.org/ghc/docs/6.10-latest/html/libraries/random/System-Random.html
14:15:01 <kmc> for a more general interface, see the package MonadRandom on hackage
14:15:12 <bluetaslem> But mersenee twiste ris known to be a poor generator for Cryptography..
14:15:14 <jmcarthur> somebody copy-pasted
14:15:20 <fax> bluetaslem - every "random number generator" algorithm is periodic
14:15:27 <jmcarthur> bluetaslem: oh you need a cryptographic prng?
14:15:30 <bluetaslem> Mersenne is more so, however.
14:15:31 <zygoloid> jmcarthur: probably lag i guess
14:15:44 <jmcarthur> bluetaslem: why not just read from /dev/random or /dev/urandom then?
14:15:54 <bluetaslem> I'm still learning.
14:15:59 <bluetaslem> Oh, which reminds me.
14:16:00 <jmcarthur> bluetaslem: i don't think we have any crypto prngs on hackage
14:16:15 <bluetaslem> I'm having issues with "Loading" files using the GHCi.
14:16:38 <bluetaslem> How in the world am I supposed to do it?
14:16:46 <jmcarthur> how are you trying it?
14:17:01 <jmcarthur> from within a ghci session or from shell?
14:17:15 <bluetaslem> I want to be able to test my programs.
14:17:28 <bluetaslem> I'm saving them as *.hs files
14:17:44 <bluetaslem> But I have no idea how to load them..
14:18:03 <bluetaslem> :l is how I was instructed by my tutorial
14:18:08 <jmcarthur> well, there's ghci MyModule.hs for the shell, :load MyModule.hs for in ghci, or :module MyModule if you're in the right location
14:18:18 <jmcarthur> and :r reloads it after you have made changes
14:18:26 <mauke> bluetaslem: what's the problem?
14:18:27 <jmcarthur> :m is short for :module
14:18:29 <bluetaslem> Wait, what?
14:18:34 <jmcarthur> and i dunno if :l is short for :load
14:18:39 <systemfault> Yes.
14:18:52 <bluetaslem> How can I navigate the GHCi interpreter to load my files?
14:18:52 <systemfault> like m for module... t for type
14:19:19 <jmcarthur> bluetaslem: are we talking about from your shell or from within ghci already?
14:19:23 <mauke> what do you mean by "navigate"?
14:19:32 <bluetaslem> From within GCHi.
14:19:40 <bluetaslem> Get to its location.
14:19:45 <mauke> what
14:19:50 <jmcarthur> bluetaslem: :l MyModule.hs
14:19:55 <bluetaslem> The interpreter is complaining that the file I've requested doesn't exist...
14:20:00 <jmcarthur> bluetaslem: you don't "navigate" in ghci
14:20:05 <bluetaslem> ....
14:20:23 <jmcarthur> you are not giving it the correct path to your file then
14:20:30 <bluetaslem> How do i set that path?
14:20:39 <jmcarthur> if you are giving it a relative path then you should have already been in the correct directory before even launching ghci
14:20:45 <mauke> :l path/to/your/file/here.hs
14:20:48 <mauke> but see :cd
14:20:57 <jmcarthur> there is also a way to run shell commands and such in ghci, but i forget how
14:21:12 <mauke> running shell commands doesn't help
14:21:19 <kmc> it's :!
14:21:38 <kmc> bluetaslem, the easiest thing is to launch ghci with your file on the command line
14:21:41 <jmcarthur> :! cd path/to/my/project won't work like :cd path/to/my/project?
14:21:42 <kmc> ghci foo.hs
14:21:51 <kmc> then you can just use ":r" to reload when you change the file
14:21:51 <mauke> jmcarthur: of course not
14:22:32 <jmcarthur> heh, yeah i guess not
14:22:44 <jmcarthur> i was calling it shell commands, but it's really just commands
14:22:52 <bluetaslem> So....
14:23:01 <bluetaslem> :! cd path/to/my/file
14:23:05 <jmcarthur> bluetaslem: no
14:23:05 <bluetaslem> Right?
14:23:08 <jmcarthur> i was wrong
14:23:11 <jmcarthur> use :cd
14:23:20 <bluetaslem> :cd path/to/my/file
14:23:34 <jmcarthur> path/to/my/directory
14:23:41 <jmcarthur> not to the file
14:23:45 <bluetaslem> Okay.
14:23:46 <bluetaslem> I see.
14:23:50 <jmcarthur> then :l MyModule.hs
14:24:26 <jmcarthur> but it's all unnecessary if you just launch ghci with the full path to the file in the first place or cd into the correct directory in the first place
14:25:36 * ManateeLazyCat GitHub.com is cool
14:25:43 <jlouis> ManateeLazyCat: yup
14:26:12 <ManateeLazyCat> Maybe i need use git instead darcs, haven't any darcs site like GitHub for git.
14:27:50 <jmcarthur> patch-tag
14:27:55 <jmcarthur> but it's nto as nice as github
14:27:57 <jmcarthur> *not
14:28:12 <bluetaslem> Guys?
14:28:20 <bluetaslem> You made 1 mistake.
14:28:30 <bluetaslem> :cd /path/to/my/file
14:28:31 <bluetaslem> Works.
14:28:44 <bluetaslem> Need to have a slash before the first folder.
14:28:51 <bluetaslem> *directory, not file
14:28:57 <jmcarthur> for absolute paths you do
14:28:58 <bluetaslem> But, thanks!
14:29:00 <jmcarthur> for relative paths you don't
14:29:02 <jmcarthur> it wasn't a mistake
14:29:05 <bluetaslem> Yeah, I know.
14:29:12 <bluetaslem> Relative paths get me nowhere.
14:29:26 <bluetaslem> The entire folder that the interpreter is running from is completely locked.
14:29:43 <jmcarthur> doesn't prevent you from using a relative path afaik
14:30:03 <jmcarthur> but we had no intention of implying that you must use a relative path
14:30:25 <kmc> git is very nice
14:30:25 <kmc> and very popular
14:30:25 <kmc> i would be happy to hear some arguments for using darcs, though
14:30:28 <kmc> that's how paths work
14:30:28 <kmc> a path that starts with / is absolute, relative to the top of your hierarchy
14:30:29 <kmc> a path that doesn't start with / is relative to the current directory
14:30:45 <bluetaslem> Hm, ya know?
14:30:58 <fax> :cd ?
14:30:59 <bluetaslem> Why is it that no one has yet made a degubbing system that can help you with typos?
14:31:29 <ManateeLazyCat> kmc: Free account has size limit at GtiHub.com?
14:31:29 <bluetaslem> You'd think that SOMEONE would have made a system that corrects incorrect capitalization, if there's only one alternative!
14:31:41 <jmcarthur> kmc: operations which require rebase in git stand a good chance of not changing patch identities in darcs
14:31:50 <bluetaslem> Well, thanks.
14:32:29 <jmcarthur> kmc: it's a big win. means you can reorder, delete, and cherry pick patches that have been in public without worry
14:32:58 <jmcarthur> kmc: well, of course a deleted local patch will still exist in public repos, but you can always repull it without a merge conflict :)
14:33:45 <jmcarthur> kmc: aside from interface things, which i think is also in darcs' favor, that's the major difference
14:33:54 <kmc> okay
14:33:58 <jmcarthur> kmc: on the downside, darcs lacks conveniences like git stash
14:34:00 <kmc> could that be fixed with a smarter merge strategy in git?
14:34:04 <jmcarthur> or in-blace branching
14:34:07 <kmc> or would it require a fundamental change
14:34:15 <jmcarthur> kmc: it would require a fundamental change
14:34:18 <kmc> (git's merge strategies are more or less self-contained programs)
14:34:23 <kmc> why's that?
14:34:37 <bremner> in place branching rocks
14:34:47 <jmcarthur> it's not the merge strategy that's the problem. it's the model. git models after snapshots of the project. darcs models after changes
14:34:51 <Veinor> what's the easiest way to store a Map (to be used as a cache) on disk?
14:34:57 <etpace> If I want to manage multiple TCP sockets, where each socket would have some data associated with it, what extent of parallelism would I need? I would do some callback stuff in Python, but i'm not sure in Haskell
14:35:07 <ddarius> bremner: Imagine explaining that statement to a lay person and their reaction.
14:35:08 <jmcarthur> kmc: if you change a history in git, the head inherently has a different identity
14:35:29 <bremner> ddarius: heh. get them drunk first.
14:35:52 <ddarius> Veinor: There's probably a Data.Binary instance or some other serialization library.
14:36:02 <kmc> etpace, fork a thread for each one
14:36:19 <Veinor> or I could just hand-roll my own if I want it to be human-readable
14:36:20 <kmc> etpace, Haskell threads are easy and cheap
14:36:26 <etpace> aha
14:36:37 <etpace> any special things I need to learn to use haskell threads?
14:36:45 <kmc> etpace, read the chapters in Real World Haskell
14:37:01 <etpace> cool, thanks
14:37:10 <kmc> also http://donsbot.wordpress.com/2009/09/05/defun-2009-multicore-programming-in-haskell-now/
14:37:13 <jmcarthur> kmc: to be fair, i suppose merge strategies could be devised which might work, but it would require massive and unreliable heuristics.
14:37:19 <kmc> which covers a few things: implicit parallel evaluation, as well as explicit concurrent execution
14:37:34 <kmc> these are different in Haskell and for a concurrent network program you'll want the latter
14:37:43 <aavogt> @tell zong_sharo: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24704#a24706
14:37:44 <lambdabot> Consider it noted.
14:37:55 <kmc> etpace, http://book.realworldhaskell.org/read/concurrent-and-multicore-programming.html
14:38:04 <ddarius> kmc: Concurrency and parallelism are different independent of Haskell.
14:38:17 <jmcarthur> kmc: another nice thing about darcs is that it basically has no concept of merge. doesn't need one
14:38:18 <kmc> true, but in many languages the only way to implement parallelism is to use concurrency
14:38:30 <etpace> ok, thanks a lot kmc
14:38:51 <jmcarthur> i guess some might not see that as nice, but i do
14:38:52 <kmc> etpace, anyway, threads are not necessary just to associate some data with sockets.  but i assume you care about handling requests on each socket no matter how they come in
14:39:08 <bluetaslem> Okay, I have a new problem.
14:39:09 <etpace> yeah, thanks
14:39:19 <bluetaslem> Does Haskell have a built-in % operator?
14:39:24 <kmc> modulus?
14:39:24 <bluetaslem> Modulo that is.
14:39:26 <kmc> :t mod
14:39:27 <lambdabot> forall a. (Integral a) => a -> a -> a
14:39:34 <kmc> like any name you can write it infix, e.g.
14:39:36 <mauke> :t rem
14:39:37 <lambdabot> forall a. (Integral a) => a -> a -> a
14:39:37 <jmcarthur> yeah (%) is something else ;)
14:39:37 <kmc> > 7 `mod` 3
14:39:38 <lambdabot>   1
14:39:41 <jmcarthur> > 4%4
14:39:42 <lambdabot>   1 % 1
14:39:55 <jmcarthur> > 4%5 + 2%3
14:39:55 <bluetaslem> I see...
14:39:56 <lambdabot>   22 % 15
14:40:03 <kmc> (%) is used to construct rational numbers
14:40:09 <kmc> > 7 `divMod` 3
14:40:10 <lambdabot>   (2,1)
14:40:15 <bluetaslem> I see, thanks
14:40:17 <monochrom> Why do the nations think in terms of built-in operators?
14:40:26 <ddarius> monochrom: I have no idea.
14:40:38 <ddarius> I wonder the same thing.
14:40:38 <jmcarthur> @src mod
14:40:38 <lambdabot> Source not found. There are some things that I just don't know.
14:40:39 <kmc> very little is actually "built in" in Haskell
14:40:46 <jmcarthur> oh defined per type, duh
14:40:56 <jmcarthur> @src Int mod
14:40:56 <lambdabot> Source not found. stty: unknown mode: doofus
14:40:59 <kmc> it's usually defined in a module (like Prelude), in terms of some other things (which are actually built-in, and non-standard)
14:41:21 <Veinor> monochrom: nations?
14:42:02 <monochrom> "why do the people imagine a vain thing?"
14:42:05 <zygoloid> > 4 :% 5
14:42:06 <lambdabot>   Not in scope: data constructor `:%'
14:42:19 <Veinor> ?
14:42:28 <aavogt> @src Ratio
14:42:29 <lambdabot> data (Integral a) => Ratio a = !a :% !a
14:42:35 <jmcarthur> zygoloid: it's just a function. it create a Ratio value
14:42:36 <monochrom> I guess you didn't listen to Handel's Messiah.
14:42:38 <jmcarthur> *creates
14:42:51 <zygoloid> jmcarthur: right. and the actual constructor isn't exported. i kinda like that.
14:43:00 <jmcarthur> oh, zygoloid was trying to get the Ration constructor. n/m
14:43:02 <jmcarthur> *Ratio
14:43:04 <aavogt> > 1 % 0
14:43:05 <lambdabot>   * Exception: Ratio.%: zero denominator
14:43:31 <jmcarthur> but how am i supposed to express the infnity ratio?!
14:44:22 <monochrom> first you have to decide whether 1%0 and 1%(-0) are same or different
14:44:26 <ddarius> > (fix succ :: Nat) % 1
14:44:27 <lambdabot>   No instance for (GHC.Real.Integral L.Nat)
14:44:27 <lambdabot>    arising from a use of `GHC.Rea...
14:45:53 <jmcarthur> monochrom: fortunately i was joking and don't have to answer that
14:45:55 <jmcarthur> ;)
14:46:11 <monochrom> the ratio constructor is hidden because when you write 2%4 it may or may not like to reduce it internally.
14:46:48 <ManateeLazyCat> I was thinking about, i still use darcs with patch-tag.com for my project, github.com is cool, but i don't like use mouse click, click. I'm a keyboarder :)
14:46:56 <monochrom> smart constructors enforce data invariants
14:47:13 <Vanadium> smart constructors mainly enforce awkward pattern matching
14:47:19 <ddarius> Abstraction enforces data invariants.
14:47:23 <aavogt> view patterns
14:47:27 <jlouis> ManateeLazyCat: you don't have to use mouseclicks with github
14:47:46 <ManateeLazyCat> jlouis: Detail?
14:48:06 <monochrom> smart compilers enforce typeclass laws
14:48:12 <aavogt> do people know how to explicitly export    data a :.: b = a :.: b
14:48:32 <jlouis> ManateeLazyCat: you can use it exactly like darcs from the command line
14:48:33 <jmcarthur> module Foo ((:.:) (..))
14:48:39 <aavogt> I see that   (:.:) in my export list does the type
14:48:40 <monochrom> module Mine((:.:)(:.:))
14:48:51 <ddarius> monochrom: More parens
14:48:56 <monochrom> yeah
14:49:01 <monochrom> module Mine((:.:)((:.:)))
14:49:07 <jmcarthur> nasty
14:49:22 <ddarius> data a : b = a : b; module Foo((:)((:)))
14:49:26 <jmcarthur> i get bitten by that sometimes too
14:50:06 <jmcarthur> i have never wanted to export one constructor but not another
14:50:15 <ManateeLazyCat> jlouis: I know, i mean i don't need the cool feature of GitHub.com, i will build a wiki site for communications with others.
14:50:16 <monochrom> It pays to learn the grammar properly, as opposed to just picking up a few idioms from irc!
14:50:21 <jmcarthur> are there legit reasons to do it?
14:50:30 <ddarius> jmcarthur: There was one time I wanted to, but it just creates nastiness.
14:50:43 <monochrom> yeah usually just (:.:)(..)
14:50:49 <aavogt> monochrom: I couldn't find the grammar specified anywhere
14:50:59 <ddarius> jmcarthur: Consider Bananas in Space
14:50:59 <aavogt> this is an extension after all
14:51:06 <monochrom> http://haskell.org/onlinereport/
14:51:31 <monochrom> I see. The first :.: is an extension, but the second :.: is haskell98.
14:52:03 <aavogt> right
14:52:13 <aavogt> so the first one will not be specified there
14:53:17 <aavogt> in H98 I would write  Compose((:.:))
14:53:41 <monochrom> I extrapolated.
14:55:28 <aavogt> where do I learn the skill of grammar extrapolation?
14:55:45 <monochrom> rw-rw-rw-
14:56:04 <monochrom> rw-rw-rw-  channel_size
14:56:23 <monochrom> oops, broken
14:56:24 <aavogt> hmm?
14:56:43 <monochrom> People conspire to avoid channel size 666 rw-rw-rw-!
14:57:52 <monochrom> I don't know how to learn extrapolation of anything. Supposedly it's hardwired tendency to generalize.
14:58:02 <aavogt> not anymore
14:58:32 <fax> I thought extrapolation was when you found a way to explain something (the underlying program)
14:58:41 <monochrom> Perhaps experience of having seen a million way other people generalized in the past, then guess the next one.
14:58:43 <fax> then you just use it to find values outside your data set
14:59:39 <aavogt> I mean I did expect some combination of parentheses and type constructor  then value constructor
15:01:32 <ddarius> You don't need to extrapolate.  The extension very likely simply extends the set of type names (plus irrelevant infix stuff), and the export list syntax is in terms of a non-terminal for type names.
15:02:41 <BONUS> haha. just got an email from haskell curry's granddaughter, she said he would have liked my illustration of him :3
15:02:53 <dqd> Haha.
15:02:58 <ddarius> BONUS: Which illustration?
15:02:59 <kmc> where is said illustration?
15:03:12 <BONUS> http://learnyouahaskell.com/curry.png
15:03:17 <monochrom> how does she know? does she extrapolate?
15:03:39 <BONUS> she said he was a cool guy with a sense of humour and he'd have liked it :)
15:04:01 <monochrom> <duck>
15:04:33 <benmachine> <goose>
15:04:58 <benmachine> BONUS: that is brilliant and you win
15:04:59 <stevenmarky_> </goose>
15:05:02 <benmachine> I'm not sure what you win
15:05:05 <fax> haskell curry's granddaughter  fuck yeah!!!!
15:05:06 <benmachine> but you definitely win it
15:05:09 <benmachine> </duck>
15:05:39 <monochrom> how did you stalk a granddaughter of Haskell Curry?
15:05:52 <pokoko222> fax she hot?
15:06:47 <kynky> if she catches you, she will kick you in the monads
15:08:08 <fax> pokoko222 oh not this shit again, I thought you'd grown up
15:08:09 <burp> lol
15:08:26 * fax note to self; Be less forgiving
15:08:33 <kmc> haha
15:08:51 <monochrom> No one grows up until grokking abstract algebra.
15:09:21 <kmc> the first step to growing up is to spell "you" as "you"
15:09:28 <fax> O_o
15:09:33 <felzix> monochrom: So you're saying most people aren't grown up. I can agree to that.
15:09:39 <fax> I was thinking of something else actually
15:09:45 <monochrom> just joking
15:12:11 <mreh> how is the Gaussian kernel infinite dimensional
15:13:05 <mreh> that's rather a difficult question to answer, because it doesn't make much sense
15:15:54 <xerox> usually infinite dimensional things are those where the vectors are functions
15:17:58 <mreh> hmmm
15:18:26 <kmc> convolution of functions is the inner product on the infinite-dimensional vector space of functions
15:18:27 <kmc> isn't it?
15:18:32 <mreh> P.S. wasn't someone talking about ML for GSoC
15:18:38 <mreh> oh, I think that was on haskell cafe
15:18:51 <lispy> mreh: ML?
15:18:56 <mreh> machine learning
15:18:59 <mreh> sorry!
15:19:06 <fax> 22:18 < kmc> convolution of functions is the inner product on the infinite-dimensional vector space of functions
15:19:09 <lispy> oh, I thought you meant the programming language
15:19:12 <fax> kmc: no it's not
15:19:20 <kmc> it's something...
15:19:26 <fax> it's very close to that
15:22:11 <ddarius> The (usual) inner product of function spaces is the straightforward generalization of the inner product of finite dimensional vector spaces.
15:22:40 <ddarius> And it produces a scalar so it certainly can't be convolution in general.
15:22:57 * djahandarie is having a hard time figuring out who was joking and who wasn't
15:23:31 <kmc> i meant \int_{-\infty}^{\infty} f(x) g(x) dx
15:23:38 <kmc> i guess that isn't the convolution
15:23:50 <kmc> is that the "straightforward generalization" of the finite inner product
15:24:33 <ddarius> kmc: Yes.
15:28:59 <mreh> does anyone know of the Math notation where you have an interator subscript and a condition superscript on the outside of a bracket, no capital pi, no capital sigma, just a bracket around some expression indexed by the iterator
15:29:28 <ddarius> mreh: Perhaps just a sequence?
15:29:43 <mreh> it looks like a matrix element, because it's indexed by two variables, but he's clearly talking about a vector
15:29:54 <xerox> kmc: usually g is \bar{g}
15:29:57 <mreh> it's the polynomial kernel for reference
15:30:04 <kmc> xerox, complex conjugate?
15:30:13 <xerox> yeah
15:30:16 <kmc> mm
15:30:27 <kmc> is that so for inner products of complex finite-dimensional vectors as well?
15:30:28 <xerox> for .. -> R doesn't matter, for .. -> C does
15:30:43 <dark> does ghc targets code to c--?
15:30:52 <kmc> yes, internally
15:31:04 <xerox> right
15:31:07 <dark> ['yes' to me?]
15:31:10 <kmc> yes
15:31:12 <kmc> to you dark
15:31:13 <mreh> dark, yes
15:31:20 <dark> isn't it using llvm?
15:31:28 <kmc> there is now a branch that uses llvm
15:31:29 <liyang> not yet.
15:31:31 <dark> or it compiles to c--, and then to llvm?
15:31:33 <dark> hmm.
15:31:34 <liyang> (to you)
15:31:35 <kmc> even then, i think it goes... yeah, that
15:31:37 <liyang> (dark.)
15:31:42 <xerox> zz*=|z|^2
15:31:53 <dark> does c-- have some serious design flaw? or llvm is just faster?
15:31:56 <xerox> (z*=\bar{z})
15:31:57 <dark> is llvm
15:32:02 <mreh> z'z = ||z||^2
15:32:05 <kmc> outputting llvm allows them to take advantage of lots of work done by other people
15:32:11 <kmc> such as low-level optimizers and codegen for lots of platforms
15:32:11 <dark> hm
15:32:17 <kmc> that's the point of llvm
15:32:18 <Gracenotes> code generation isn't easy
15:32:22 <kmc> and of c--, but c-- never caught on
15:32:36 <dark> but couldn't c-- output to llvm?
15:32:41 <kmc> c-- has a website and a spec all its own, but it might be better considered just the name of GHC's last internal language
15:32:42 <mreh> c-- was designed by peyton `simon` jones I thought
15:32:55 <kmc> dark, yes, i believe that's what the LLVM output mode of ghc does
15:33:03 <xerox> mreh: multiplication is commutative, and no need for norm, abs is fine
15:33:05 <dark> kmc, sure? so.. c-- isn't used?
15:33:09 <Gracenotes> I think the main information C-- has over C to aid in compiling is function metadata, plus the simplicity helps I think
15:33:15 <liyang> mreh: why are you writing his name infix? …
15:33:24 <dark> Gracenotes, what about tail calls?
15:33:27 <Gracenotes> and other kinds of metadata which I've not looked at in details
15:33:28 <kmc> dark, Haskell -> Core -> STG -> C-- -> LLVM -> machine code
15:33:29 <ddarius> SPJ influenced C-- significantly.  What GHC uses isn't the "public" version of C-- though.
15:33:30 * mreh chuckles
15:33:43 <dark> hmmmm
15:33:43 <kmc> yeah, perhaps we should distinguish ghc's "Cmm" from C--
15:33:54 <mreh> @quote `simon`
15:33:54 <lambdabot> chrisdone says: I think you mean Peyton `Simon` Jones.
15:33:54 <kmc> dark, but the "standard" versions of GHC don't use LLVM yet
15:34:04 <Gracenotes> dark: hm, I'm not sure where tail calls get put in
15:34:11 <Gracenotes> kmc: don't forget about the AST :P
15:34:21 <kmc> er, each of those languages is an AST
15:34:23 <dark> Gracenotes, i was just looking the site
15:34:29 <ddarius> And indeed, C-- and LLVM operate at different levels and have somewhat different goals, though there is some overlap.
15:34:32 <kmc> it's a pipeline of languages, not of phases
15:34:47 <Gracenotes> well, the parsed Haskell AST derived from the stringy source
15:35:12 <ddarius> Gracenotes: I assume you mean TCO, and it depends.  For compilation to C, the tail call optimization is done by the Evil Mangler on the assembly output by gcc.
15:36:09 <arw_> does the current haskell platform include/support the llvm backend?
15:36:16 <Gracenotes> I forget, why can't the mangler be rewritten in Haskell?
15:36:24 <ddarius> Gracenotes: It can.
15:36:26 <benmachine> it can but I don't think there's much point
15:36:31 <dark> a more subjective question: if one would like to implement a simple toy compiler for a simple (currently non-existent) language, it would be simpler to output to C, to C-- or to llvm? (hmm considering no compiler experience)
15:36:31 <benmachine> or so I've heard
15:36:40 <Gracenotes> ..ah
15:36:41 <kmc> dark, probably LLVM
15:36:47 <chrisdone> mreh: :D
15:36:49 <kmc> you have to jump through some hoops to use C as a target language
15:36:51 <ddarius> I think the problem currently is reverse engineering the knowledge that is contained in the Evil Mangler.
15:36:52 <benmachine> doesn't the native codegen make it redundant anyway
15:36:55 <jmcarthur> i'd go with llvm. easy to output and good optimizations
15:36:56 <kmc> it's missing a few things like tail calls
15:36:57 <ddarius> benmachine: Yes.
15:37:03 <kmc> llvm is popular and well-supported
15:37:18 <kmc> gets you optimizers, many platforms, several implementations
15:37:32 <kmc> also there is a Haskell API for generating LLVM code
15:37:46 <kmc> (i assume you're implementing this compiler in Haskell, because it's the best language I know of for implementing a compiler)
15:37:50 <dark> kmc, hmm i was considering that C-- would be conceptually simpler @.@
15:37:54 <kmc> it might be
15:37:56 <Gracenotes> hm. isn't Clang supposed to be a drop-in replacement for gcc? I should test it out on my semester-long project
15:38:07 <systemfault> Gracenotes: Yes sir.
15:38:14 <jmcarthur> yeah clang is nice
15:38:17 <dark> yes, in haskell
15:38:17 <systemfault> Gracenotes: But the C++ support is not complete.
15:38:28 <Vanadium> as I just found out :]
15:39:06 <Gracenotes> yeah, I've looked at the support table. starts off great, falls off after a while for the more idiosyncratic language semantics
15:39:08 <systemfault> Well, clang is self-hosting so..
15:39:36 <systemfault> The C++ support is not complete but "enough" to compile all of LLVM+clang
15:39:37 <kmc> it's all right, there is no complete C++ compiler in existence
15:39:46 <systemfault> kmc: True
15:39:54 <systemfault> kmc: Comeau if f... close though.
15:40:02 <systemfault> kmc: It even supports export afaik
15:40:05 <liyang> It's all right, no one uses C++ anymore. Have you tried Java?
15:40:14 <systemfault> Java sucks.... Really..
15:40:19 <kmc> liyang, no, i heard about this great new idea called "functional programming"
15:40:20 <systemfault> C# is way better.
15:40:21 <Eelis> liyang: [citation needed]
15:40:26 <kmc> it's really new and cutting edge, but i think it'll catch on
15:40:36 <systemfault> kmc: I hope :)
15:40:36 <dark> it is said that every time a single implementation comes close, the committee creates another version
15:40:43 <kmc> hehe
15:41:13 <liyang> kmc: I'd like to subscribe to your newsletter.
15:41:53 * hackagebot Coadjute 0.1.0 - A generic build tool  http://hackage.haskell.org/package/Coadjute-0.1.0 (MattiNiemenmaa)
15:43:34 <chrisdone> I read in Coders at Work that Ken Thompson didn't like C++ in the early days and Stroustrup went mad, saying if Thompson criticises it no one will use it, so Thompson said "I didn't say it was bad, ... kinda" and kept quiet about it
15:43:53 * hackagebot list-tries 0.2 - Tries and Patricia tries: finite sets and maps for list keys  http://hackage.haskell.org/package/list-tries-0.2 (MattiNiemenmaa)
15:43:58 <Vanadium> If only ken thompson had spoken up back in the day
15:43:58 <chrisdone> back when Stroustrup started his yes-man evangelism
15:44:11 <chrisdone> you want that in C++? sure!
15:45:25 <liyang> Pity he didn't take the whitespace operator seriously.
15:46:08 <Vanadium> What of the things in C++ would you rather not have in?
15:46:19 <kmc> oh no
15:46:26 <kmc> this is gonna get ugly
15:46:36 <Vanadium> The only answer I can think of is C
15:46:39 <mauke> inheritance
15:47:04 <Vanadium> mauke: But then how do you make things inherit from true_type for your template metaprogramming
15:47:09 <mauke> hah
15:47:20 <Vanadium> and how do you do pseudo-mixins without the curiously recurring template pattern :]
15:47:27 <kmc> there's a few features i'd add, so that a lot more could be removed
15:47:33 <mauke> there's a simple answer: "no"
15:47:47 <Vanadium> Nobody ever got rich removing features :<
15:47:51 <kmc> right
15:48:17 <kmc> it's important that easy things should require a bunch of pompous nonsense design patterns
15:48:22 <kmc> so that we can sell books about them
15:48:37 <Vanadium> :3
15:49:47 <mauke> ok, C++ should get rid of implicit pointer conversions
15:49:57 <chrisdone> yeh
15:50:04 <Vanadium> Really? They seem relatively tame.
15:50:29 <mauke> they can just cause segfaults, no big problem
15:50:33 <arw_> Vanadium: implicit conversion from void* to anything? wel...
15:50:39 <Vanadium> arw_: That is not in C++
15:50:43 <liyang> http://www2.research.att.com/~bs/whitespace98.pdf
15:50:45 <mauke> I'm fine with void * -> anything *, actually
15:50:57 <Vanadium> I mostly am I suppose
15:51:13 <arw_> there are valid uses. but there are also abuses.
15:51:14 <Vanadium> mauke: Example for implicit conversions causing inadvertent segfaults?
15:51:32 <mauke> http://mauke.ath.cx/stuff/c++/inheritance-breaks-type-safety.cc http://mauke.ath.cx/stuff/c++/inheritance-breaks-type-safety-2.cc
15:51:35 <chrisdone> I've never accidentally mis-used the void* -> anything * before
15:51:41 <mauke> well, the first one isn't a segfault, it's just silent data corruption
15:51:53 <Vanadium> chrisdone: Well, it is tempting to type-pun using it and...
15:52:54 <Vanadium> The second one is wrong because B2 does not have a virtual destructor, is it not?
15:53:07 <mauke> yes
15:53:19 <Vanadium> The first one is kind of funny :3
15:53:22 <Eelis> mauke: that first one has nothing to do with pointer conversions per se. you could do:  int i, * p = &p; p[3] = 2;  and it would be wrong for the same reason: pretending something is an array when it isn't.
15:53:40 <Eelis> erm, &i
15:53:48 <systemfault> Eelis's right
15:53:50 <mauke> arr is an array, though
15:53:58 <Eelis> mauke: but of a completely different kind.
15:54:11 <mauke> yes, which is why I don't want to have an implicit type conversion there
15:54:43 <Vanadium> Surely arr is not an array at all in lol
15:54:44 <mauke> Eelis: you can pretend i is an array of size 1
15:54:50 <Vanadium> I mean, not only because of the function type adjustment
15:55:10 <mauke> it's just an out of bounds error there
15:55:18 <Eelis> mauke: i don't see how that changes anything. i maintain that the problem is not in the pointer conversion but in passing an array of the wrong kind to the function.
15:55:41 <Vanadium> This is basically the reverse problem of object slicing, no? :
15:55:42 <Vanadium> :V
15:55:50 <Vanadium> array padding, if you will
15:55:51 <mauke> Vanadium: yeah, sort of
15:56:49 <mauke> Eelis: the conversion is (probably?) fine iff you don't do any pointer arithmetic on the result
15:56:50 <Eelis> if any conversion is to be blamed there, it's the array-to-pointer conversion.
15:57:04 <arw_> thats not a conversion.
15:57:11 <arw_> there are no arrays.
15:57:13 <mauke> so yeah, removing the C part from C++ might also be a good idea
15:57:14 <Vanadium> Yes, there are
15:57:24 <Eelis> arw_: i'm afraid the C++ standard disagrees.
15:57:50 <Vanadium> extern const char foo[]; versus extern const char* foo; \o/
15:57:59 <Vanadium> also i think the extern keyword is kind of confusing can we get rid of that too
15:58:14 <Eelis> arw_: (FYI, section 4.2 in the latest draft is called "Array-to-pointer conversion")
15:58:31 <mauke> Vanadium: I'd get rid of "auto" first :-)
15:58:36 <arw_> they really introduced a difference there?
15:58:40 <mauke> arw_: what
15:58:42 <Vanadium> mauke: They did! unless you mean the new one
15:58:44 <Eelis> arw_: no, it was there since forever.
15:58:54 <liyang> remove all the non-whitespace characters from C++, and rename it to ‘whitespace’.
15:59:07 <mauke> hah
15:59:07 <Vanadium> I wonder why there is no interest in defining some sort of frontend language to C++ that exposes all the features you need to interface with C++ code but somehow prevents you from shooting your foot into the gun or whatever
15:59:30 <mauke> impossible, it still has to run on the C VM
15:59:36 <liyang> Vanadium: the same reason some people demand the right to bare arms.
16:00:08 <Vanadium> mauke: Well, not perfectly, but just make it nicer and remove the syntactic pitfalls and refuse to do some implicit conversions
16:00:18 <dark> doesn't haskell compile to CPS? it compiles to CPS and then to SSA?
16:00:34 <mauke> I think it's bound to fail
16:00:41 <dark> [ i'm reading, llvm expects SSA only ]
16:00:44 <dancor> Vanadium: maybe you can get close to that enabling some extreme warnings?
16:00:50 <mauke> http://www.csse.monash.edu.au/~damian/papers/HTML/ModestProposal.html
16:01:10 <Vanadium> dancor: I do enable some extreme warnings and it helps, yeah
16:01:35 <erikc> Vanadium: to interface with c++ you will need preprocessing, c++ parsing, c++ template instantiation, it's a mountain of work
16:02:12 <Vanadium> I dream of a world where I can #include some guy's header
16:02:21 <erikc> c++ as is commonly used does not support separate compilation
16:02:22 <Vanadium> without being afraid that his macros are puking all over my namespace
16:02:55 <chrisdone> modules that are just text includes do tend to have clashing issues..
16:02:59 <Vanadium> erikc: yeah, good points
16:04:05 <stevenmarky_> too bad namespace tester { #include "bleh.h" } doesn't work for macros
16:04:28 <mauke> surprise, bleh.h contains } ... {
16:04:42 <Vanadium> It does not even work for functions, because it changes mangling so your linking stage breaks
16:05:06 <chrisdone> it's like Moriarty on Star Trek
16:05:13 <Vanadium> Haha
16:06:31 <mauke> here's a fun problem: can you find a sequence of characters E such that wherever you insert E in a C/C++/whatever source file it is guaranteed to cause a syntax error?
16:07:14 <Vanadium> Probably not, because I can just hide it with enough #ifdef 0s?
16:07:23 <kmc> Vanadium, there is somewhere an alternate syntax for C++ which is less wretched
16:07:34 <kmc> of course that only solves one of the many layers of problems
16:07:35 <Vanadium> kmc: I think mauke linked it above
16:07:45 <kmc> yeah
16:07:50 <erikc> one significant improvement to c++ would be compile-time traversal (in templates) of structure members because it'd allow the generation of useful things like: offset/pointer swizzlers, serializers, endian swappers, precise garbage collection tracers
16:07:52 <Vanadium> I really hoped for something that is not an 1:1 translation
16:08:10 <arw_> Vanadium: no. you can kill all the #endifs by opening a multiline comment
16:08:30 <arw_> Vanadium: that will at least cause a preprocessor error
16:08:38 <mauke> Vanadium: but the preprocessor has to lex things, you could make that part error
16:08:39 <Vanadium> arw_: What if I put a closing */ before my first #endif?
16:08:50 <kmc> yes, C++ could really use a real metaprogramming facility
16:09:07 <kmc> a way to manipulate C++ code using a decent general-purpose language, not the World's Worst Obfuscated Functional Language
16:09:08 <systemfault> C++0x will help a little bit
16:09:09 <blackh> Anyone know about "ghc: dist/build/Happstack/Data/Default.o: unknown symbol `sybzmwithzmclasszm0zi6_DataziGenericsziSYBziWithClassziInstances_constrZMaeA9ZN_closure'" when configuring happstack?
16:09:14 <arw_> Vanadium: you could do that. in which case i just open one more comment.
16:09:26 <kmc> blackh, are you invoking ghc explicitly or through e.g. cabal?
16:09:33 <kmc> usually ghc linker errors go away by adding --make
16:09:35 <systemfault> Being a noob at haskell.. The errors are not super clean...
16:09:44 <blackh> kmc: 'cabal install happstack' using ghc 6.10.4
16:09:45 <Vanadium> So I could put two newlines, a */, another newline and then #derp or something?
16:09:52 <Saizan> blackh: rebuild syb-with-class with --disable-documentation
16:10:24 <systemfault> When ghc says I have bad indentation when I did something stupid like forgeting a =
16:10:33 <Gracenotes> in case you're wondering about the word mashing, http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/SymbolNames
16:10:36 <systemfault> Not really helpful :/
16:10:42 <Gracenotes> in the the error
16:11:38 <Twey> preflex: zdec ZM
16:11:38 <preflex>  [
16:11:47 <Twey> Ah
16:12:23 <Saizan> yeah, ids generated by TemplateHaskell
16:12:26 <blackh> Saizan: Thanks! That worked. A bit of a weird one, that.
16:12:50 <pastorn> anyone here tried the haskell bindings to DevIL?
16:13:03 <kmc> yeah, ghc error messages could be much improved
16:13:03 <pastorn> what happends if i *don't* initialize?
16:13:15 <blackh> pastorn: Yes - they didn't work very well for me. Kept crashing.
16:13:32 <pastorn> blackh: but they worked once you initialized?
16:13:48 <Cale> systemfault: It's not *always* bad indentation. It's just that some problems *may* be caused by bad indentation, and it's a bit hard for GHC to know whether that was the problem
16:14:09 <Nereid> same thing happens in C with DevIL, it has to be initialized first.
16:14:11 <blackh> pastorn: I can't say that DevIL was definitely the problem, but my app became very unstable, and the problem immediately disappeared when I switched to some other library.
16:14:22 <blackh> pastorn: I did the static initialization.
16:14:27 <Cale> systemfault: So of course you check that, but also look at the code around that spot and make sure that everything is fine
16:14:30 <Saizan> blackh: yeah, bad interaction between recompilation, TH, haddock, and sharing dist directories :)
16:15:27 <pastorn> blackh: static initialization?
16:15:36 <pastorn> http://hackage.haskell.org/packages/archive/Codec-Image-DevIL/0.2.3/doc/html/Codec-Image-DevIL.html#v%3AilInit <-- i'm talking about this function
16:15:51 * Saizan hates non-determinism
16:16:03 <fax> why??
16:16:03 <Saizan> in build systems, at least
16:16:06 <fax> oh
16:16:11 <blackh> pastorn: It was a long time ago so my experience may not apply. Yes, I did the ilInit.
16:16:52 <blackh> pastorn: I think the problem I had was that, even though the libIL documentation says the software is thread safe, I don't think it is.  My code was very threaded.
16:17:40 <pastorn> blackh: oh, well i won't be messing with that :)
16:20:47 <fax> "CS is essentially applied math. In this case, it is simple math where all you need to do is no how to count"
16:22:57 <Veinor> I can't remember the last time I had to do any numeric stuff other than basic manipulation on a math assignment
16:23:31 <mreh> you're everything the Daily Mail hates about society
16:23:50 <Veinor> ?
16:23:57 <mreh> "children could do differential equations in their head in my day!"
16:24:12 <Twey> So they should
16:24:32 <liyang> Maths causes cancer.
16:24:39 <Twey> It's not rocket science
16:24:47 <benmachine>  < mreh> you're everything the Daily Mail hates about society <-- is there anything that they don't :/
16:24:47 <mreh> it's also the cure
16:25:01 <Twey> Rupert Murdoch
16:25:03 <mreh> heh
16:25:06 <fax> maths doesn't exist anyway
16:25:10 <fax> so don't worry
16:25:13 <benmachine> neither do you
16:25:24 <benmachine> I imagined you to distract me from my analysis work
16:25:25 <mreh> maths is a social construction
16:26:13 <Veinor> i imagined all of you
16:26:36 <liyang> http://www.thedailymash.co.uk/news/society/police-remove-makeshift-daily-mail-reader-warning-sign-201004022612/
16:27:18 <mreh> is that a news satire website I take it
16:27:37 <Veinor> presumably :P
16:27:38 <kmc> tricky brits, you can never tell
16:27:44 <FauxFaux> (newb) Is there a typical functional (i.e. library) function that does something like flatten $ map?  let foo a b = flatten $ map a b  -- i.e. foo (\x -> if x == ' ' then "Hello " else [x]) " World" -- giving Hello World.
16:27:54 <Veinor> "And just imagine walking along what looks like a normal English street on a Sunday afternoon, perhaps with your wife and child, when all these weirdos come up to you and start sniffing your bum to see if you've had anal sex.
16:27:58 <Veinor> a: lol
16:28:03 <fax> FauxFaux, (>>=)
16:28:12 <Twey> Hahaha, liyang
16:28:22 <pastorn> > cycle "OM N"
16:28:23 <fax> > "for example" >>= \character -> [character, character]
16:28:23 <lambdabot>   "OM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM...
16:28:24 <lambdabot>   "ffoorr  eexxaammppllee"
16:28:28 <kmc> :t concatMap -- FauxFaux
16:28:29 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
16:28:54 <FauxFaux> Heh, yes, exactly that. :)
16:28:56 <mreh> "Gay teen worries he may be becoming a fundamentalist christian" is my favourite headline
16:29:00 <Twey> > "for example" >>= replicate 2
16:29:01 <lambdabot>   "ffoorr  eexxaammppllee"
16:29:07 <Veinor> mreh: it is pretty awesome.
16:29:47 <mreh> I thought fax's command was responsible for the OM NON
16:29:57 <Veinor> that would be highly confusing
16:29:57 <mreh> I was so like "lol wut?"
16:29:58 <Twey> How confusing
16:30:12 <FauxFaux> Just make the bot always output OM NOM NOM NOm.
16:30:16 <kmc> :t \f -> concat . map f
16:30:17 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
16:30:28 <Twey> :t fmap concat . map
16:30:29 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
16:31:00 <benmachine> :t fmap (fmap concat) fmap
16:31:01 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
16:31:06 <fax> ITYM join
16:31:17 <Twey> ☺
16:31:23 <Veinor> @src (-> a) join
16:31:23 <lambdabot> Source not found.
16:31:29 <benmachine> :t fmap (fmap join) fmap
16:31:30 <lambdabot> forall (m :: * -> *) a a1. (Monad m, Functor m) => (a1 -> m a) -> m a1 -> m a
16:32:00 <Twey> concat = join
16:32:08 <Twey> More newbieskell
16:32:15 <Veinor> hm
16:32:27 <Veinor> :t join
16:32:28 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
16:32:34 <Twey> join ‘flattens’ a monad
16:32:38 <mreh> surely there isn't an issue over anonymity with Hackage if you register a pseudonym
16:32:40 <Veinor> so ((a -> b) -> b) -> (a -> b)?
16:32:52 <jmcarthur> @. pl djinn (a -> a -> b) -> a -> b
16:32:53 <lambdabot> f = join
16:32:58 <benmachine> join = fmap unsafePerformIO
16:33:01 <Twey> (a -> a -> b) -> a -> b
16:33:04 <Veinor> obviously I have it backwards
16:33:07 <Twey> Yeah
16:33:09 <kmc> haha benmachine
16:33:16 <Twey> It applies the same argument twice for functions
16:33:19 <Veinor> it's (a ->) that's a monad, then?
16:33:22 <Twey> Yes
16:33:24 <mreh> ShirleyNott
16:33:29 <Twey> > join (+) 1
16:33:30 <lambdabot>   2
16:33:33 <Veinor> is (-> a) ...... comonad? :O
16:33:37 <benmachine> kmc: <_< I do think it's interesting to think of it as "taking stuff out of the monad" but in the monad
16:33:39 <fax> :t fmap unsafePerformIO
16:33:40 <jmcarthur> nope
16:33:40 <lambdabot> Not in scope: `unsafePerformIO'
16:33:41 <Twey> Don't think so
16:33:43 <Veinor> aw.
16:33:54 <Twey> Comonads still have to have the same structure
16:33:58 <benmachine> lots of people when learning haskell want to do IO a -> a
16:34:00 <benmachine> and you can't
16:34:05 <Twey> It's just the operations that are different
16:34:07 <benmachine> but you can do IO (IO a) -> IO a
16:34:18 * hackagebot SMTPClient 1.0.2 - A simple SMTP client library  http://hackage.haskell.org/package/SMTPClient-1.0.2 (StephenBlackheath)
16:34:26 <pastorn> is there any library on hackage for loading 3D models?
16:34:29 <mreh> that's a fake name if ever I saw one
16:34:32 <kmc> but fmap unsafePerformIO is the wrong implementation of join ;P
16:34:33 <jmcarthur> pretty sure there's   instance Monoid a => Comonad ((->) a)  however
16:34:34 <fax> ah
16:34:37 <Twey> Is join really = fmap unsafePerformIO?
16:34:44 <benmachine> Twey: no >_>
16:34:45 <fax> why not
16:34:46 <Twey> I'm fairly sure it isn't…
16:34:47 <Twey> Heh
16:34:58 <Twey> It's maaaagic
16:34:59 <benmachine> possibly that's unsafeInterleaveIO . join though
16:35:00 <kmc> that'd be roughly like unsafeInterleaveIO
16:36:24 <kmc> it seems darcs.haskell.org is down :/
16:36:29 <Veinor> @src join
16:36:29 <lambdabot> join x =  x >>= id
16:36:44 <felzix> @type join
16:36:45 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
16:36:46 <benmachine> is that the one that's also community.haskell.org and whateverelse.haskell.org
16:38:08 <ddarius> jmcarthur: That instance can be written, yes.
16:41:15 <lispy> kmc: I can reach both community.h.o and darcs.h.o
16:41:48 <Sgeo> What's a comonoid?
16:41:54 <Sgeo> Do I want to know?
16:42:07 <kmc> i don't think there is such a thing
16:42:10 <ddarius> Sgeo: Comonoids don't come up too often.
16:42:12 <ddarius> kmc: Sure there is.
16:42:15 <kmc> what is it?
16:42:52 <kmc> the op of a category that's a monoid is still a monoid
16:43:17 <ddarius> It's like a monoid, you just turn the arrows around.  However, using a set based system produces boring comonoids.
16:43:37 <ddarius> You have k : C -> 1 and d : C -> CxC
16:44:19 <ddarius> Normally, you'd generalize to a monoidal product and/or a different category giving k : C -> I and d : C -> C⊗C
16:45:23 <Cale> The comonoid structures in Set are boring but also perhaps taken for granted a bit more than they ought to be
16:45:59 <ddarius> Cale: True.  It does correspond to weakening and contraction.
16:46:54 <fax> that's really cool
16:47:10 <Mathnerd314> so what other interesting comonoids are there?
16:47:16 <Mathnerd314> *comonads
16:47:18 <fax> thinking of linear logic
16:47:42 <ddarius> Cale: Did you get around to reading that Benabou paper?
16:48:21 <ddarius> fax: Comonoids and comonads do come up in categorical semantics of linear logics.
16:49:07 <fax> non linear logics?
16:49:17 <ddarius> fax: If you are interested in linear logic, I recommend looking at LolliMon and CLF.
16:49:53 <Cale> I looked for a copy of it online, but I only found things that were behind iron curtains.
16:50:00 <fax> CLF, a linear dependent type theory with a monad for concurrency
16:50:34 <ddarius> Cale: Yeah, I got it from JSTOR.  For some reason I thought you'd be able to get it.
16:50:58 <narens> Can someone tell me why if i repeat the following action and watch
16:50:58 <narens> 	 the memory consumption the memory increases after every iteration?
16:50:59 <narens> dataList path = do
16:50:59 <narens>   lns <- lines <$> readFile path
16:51:02 <narens>   mapM_ (\l -> let v = (tail.map read.words $ l) :: [Int]
16:51:06 <narens>                in putStrLn.show.length $ v) lns
16:51:28 <Apocalisp> Mathnerd314: Data.Tree is a (relatively interesting) comonad
16:52:05 <jmcarthur> Stream is also a comonad
16:52:10 <jmcarthur> (infinite list)
16:52:10 <Cale> ddarius: I used to be able to use my university library's proxy, but my account has obviously expired :)
16:52:12 <Apocalisp> Also, TreeLoc, the one-hole zipper over Trees
16:52:37 <ddarius> The free comonad on the list functor
16:52:42 <Apocalisp> (x,_) is a comonad
16:52:59 <jmcarthur> the coreader :)
16:53:08 <Apocalisp> ding!
16:53:09 <ddarius> Cale: I had just discovered that I actually had access to a site like that that was relevant to me through one of my universities.
16:53:18 <ddarius> The free comonad on the identity functor.
16:53:31 <narens> anyone?
16:53:40 <Apocalisp> ddarius: cofree?
16:53:48 <ddarius> Yes, I was just about to make that correction.
16:53:59 <Apocalisp> unambiguous either way
16:54:16 <kmc> narens, you are getting the output each time?
16:54:28 <narens> kmc: which output?
16:54:30 <Cale> narens: No idea.
16:54:31 <kmc> from putStrLn
16:54:34 <kmc> how fast does it grow?
16:54:38 <kmc> O(size of files)?
16:54:42 <narens> kmc: by the amount of the file
16:54:45 <narens> yea
16:54:53 <kmc> are you compiling and if so, did you turn on optimization?
16:55:00 <narens> kmc: if i don't print anything out then the memory does not grow
16:55:03 <narens> -O2
16:55:04 * Saizan is not sure what the difference between free and cofree is
16:55:12 <kmc> narens, it'll grow a little... readFile is lazy though
16:55:13 <Apocalisp> It's after midnight CET. I thought this was CT time in #haskell
16:55:16 <kmc> so it won't read the file in
16:55:38 <narens> kmc: I mean why does it grow each iteration? shouldn't the memory be constant
16:55:40 <kmc> right
16:55:49 <kmc> run your program as: ./prog +RTS -s
16:55:58 <kmc> that will dump some statistics about garbage collection
16:56:16 <kmc> see if for some reason the GC isn't running
16:56:39 <kmc> which GHC version?
16:56:49 <narens> 6.12.1
16:56:53 <narens> the GC is running
16:57:09 <kmc> very strange
16:57:10 <Saizan> it might be that the Strings get propoted to the older generation, so they aren't collected until the next major gc
16:57:17 <Saizan> *promoted
16:57:19 <kmc> you could try switching to ByteString IO
16:57:31 <ddarius> Saizan: Left or right adjoint.
16:57:33 <kmc> it will use less memory too
16:58:01 <aavogt> @hogle performGC
16:58:02 <lambdabot> System.Mem performGC :: IO ()
16:58:02 <narens> hmm, if i use bytestring i have to do an unpack anyway and the files I am going to read in are big
16:58:55 <Saizan> ddarius: oh, of the forgetful functor? makes sense.
16:59:14 <narens> what's this performGC?
17:01:53 <kmc> narens, if you're reading big files you should be using ByteString to begin with
17:02:00 <kmc> and parsing your Ints directly out of that
17:02:32 <narens> kmc: even if I am making only one pass through the data?
17:03:16 <kmc> hmm, it should be fine then
17:03:40 <kmc> maybe use hGetLine instead of readFile
17:03:46 <kmc> imo,  lazy IO should always be avoided
17:05:03 <narens> kmc: really? I've found it to be useful
17:05:11 <kmc> yes, it's useful
17:05:20 <narens> kmc: what's your reason?
17:05:34 <kmc> it produces magical values with semantics that break a basic property of Haskell
17:06:11 <kmc> it requires you to think about when evaluation occurs to understand the correctness of your IO
17:06:37 <narens> kmc: so if I use non lazy IO and I return the lines from the contents of the file... its going to create all of it in memory at once?
17:06:48 <kmc> i mean that you can get one line at a time
17:06:54 <kmc> then process it to [Int]
17:07:09 <kmc> http://sites.google.com/site/haskell/notes/lazy-io-considered-harmful-way-to-go-left-fold-enumerator
17:07:19 <narens> kmc: gotcha... so you have to write things a little differently
17:10:07 <dancor> cool i hadn't seen System.IO.Lazy.Input
17:10:24 <narens> okay, so doing performGC seems to have fixed it
17:10:29 <narens> but, I don't like doing that
17:10:43 <narens> Maybe doing non-lazy as you suggest may also fix it?
17:11:27 <kmc> yeah
17:11:34 <kmc> lazy IO is a hack
17:11:45 <kmc> if you get weird behavior using it, the solution is almost always "don't use lazy IO"
17:11:50 <narens> also, is there any benefit (gc wise) to compiling with -threaded even if you have a single threaded program?
17:11:53 <lispy> wait, using performGC fixed what?
17:11:58 <narens> the memory leak
17:12:01 <lispy> ah
17:12:12 <kmc> narens, there are some disadvantages to -threaded, such as inability to detect simple infinite loops
17:12:19 <kmc> i don't know about GC implications
17:12:34 <mauke> not very lazy if it's immediately forced by putStrLn
17:12:50 <kmc> but having to think about stuff like that is precisely why lazy IO is bad
17:13:02 <narens> kmc: makes sense
17:13:18 <kmc> (and is a problem for understanding performance of Haskell code more generally, but at least here there's a simple fix)
17:13:24 <brooksbp> Is there a channel on freenode dedicated towards static analyses?
17:14:57 <narens> there's one other question... its rather specific. But, I have no idea why an unboxed mutable vector takes about 30 seconds to set all elements (2GB worth) to an value using the set function. Seems really long.
17:15:37 <systemfault> Whoa 2GB
17:15:57 <kmc> narens, how big are the elements?
17:16:04 <systemfault> Even with C or C++.. I wouldn't ask the OS for 2GB of contiguous storage.
17:16:07 <narens> (Float,Float,Float)
17:16:22 <kmc> you can make an unboxed vector of tuples of floats?
17:16:27 <kmc> is this with the "vector" library?
17:16:32 <narens> I really don't have a baseline to compare... don't know how long it would take in C, i should imagine very fast using memset
17:16:36 <narens> yea
17:16:38 <narens> vector lib
17:16:51 <narens> i'm very happy with it except for the set method.
17:17:01 <narens> just wondering why it takes that long
17:18:11 <kmc> narens, "set" is implemented in a fairly generic way
17:18:46 <systemfault> Perhaps there's a way to pass the vector to memset :P
17:18:52 <kmc> in particular it seems it uses the same implementation for boxed or unboxed vectors
17:19:00 <kmc> though i am not sure about that, from a brief perusal of the code
17:20:02 <kmc> yeah, if all else fails, you can get at the bytes and memset() them yourself
17:20:29 <kmc> @hoogle MutableByteArray
17:20:29 <lambdabot> No results found
17:27:48 <narens> is there a good library for splitting ByteStrings on arbitrary delimiters?
17:29:45 <kmc> there are several parser libraries for BS
17:29:59 <kmc> don't know about something simpler
17:30:00 <kmc> perhaps bytestring-lexing or bytestringreadp
17:35:37 <aavogt> alex can parse bytestrings
17:36:29 <Veinor> is there any performance penalty to running a program compiled with -threaded on a single-core machine?
17:36:35 <Veinor> i.e., is there any reason not to compile with -threaded?
17:36:49 <kmc> Veinor, -threaded disables GHC's infinite loop detector
17:37:06 <kmc> also probably adds locks / atomic ops in some places, i'm not sure on that
17:37:25 <Axman6> it seems to not add much overhead at all on a single core though
17:37:48 <kmc> well, there are two questions: "... if i have one core" versus "... if my program only has one thread"
17:37:49 * Veinor nods
17:38:16 <kmc> it's quite common to write multithreaded code to execute on one core, and i can imagine that it might execute better with -threaded
17:38:23 <kmc> and maybe even with more than one OS thread
17:38:30 <kmc> (for starters, there's SMT)
17:38:33 <Veinor> I suspect this is academic in either case because this is not a highly time-critical program
17:38:39 <blackdog> Axman6: one of the things i like best about haskell is that the community's still sort of got an inferiority complex about being slower than C.
17:38:58 <Axman6> haskell is not slower than C!
17:39:00 <Veinor> and I suspect that any time hits would be like... 10% of the speed, which is acceptable for the 20% gain I get from -N2
17:39:00 <Axman6> :P
17:39:03 <sjanssen> Veinor: there are potential slowdowns when using -threaded on a single processor
17:39:04 <blackdog> it's like the kid who used to be fat at school who goes to the gym all the time and ends up mega-ripped without realising it.
17:39:14 <kmc> haha blackdog
17:39:19 <Veinor> blackdog++
17:39:24 <kmc> @remember blackdog [on Haskell performance] it's like the kid who used to be fat at school who goes to the gym all the time and ends up mega-ripped without realising it.
17:39:24 <lambdabot> Done.
17:40:03 <kmc> Haskell is not slower than C! *writes extremely slow C interpreter in Haskell*
17:40:27 <aavogt> C factorial!
17:40:46 <blackdog> *grin* loving that reaction, axman...
17:41:14 <blackdog> ooh, the implementation/specification debate
17:41:18 <Veinor> > product [1..ord 'C']
17:41:19 <lambdabot>   0
17:41:32 <Axman6> > ord 'C'
17:41:33 <lambdabot>   67
17:41:39 <Axman6> o.O
17:41:39 <Axman6> '
17:41:40 <Veinor> wait, what?
17:41:45 <blackdog> at least we have something resembling a spec, i guess. trying to make hubris work with multiple rubies is making me lose hair.
17:41:52 <Axman6> > [1 .. ord 'C']
17:41:53 <Veinor> > product [1..67]
17:41:53 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
17:41:54 <lambdabot>   364711109181886852882498590966054644271676353140495245937016285002679624369...
17:41:59 <kmc> at least ruby admits more than one implementation
17:42:09 <kmc> perl seems to actively thwart the idea
17:42:13 <Veinor> what the hell is going on?
17:42:22 <Veinor> > any (== 0) [1 .. ord 'C']
17:42:23 <lambdabot>   False
17:42:28 <Axman6> Int wrapping i'd guess, intermediate 0 value
17:42:31 <blackdog> kmc: yeah, "what the perl5 binary does" is a bit self-defeating
17:42:36 <kmc> yeah
17:42:41 <Veinor> ahhhh.
17:42:48 <kmc> they change major language semantics in minor version revisions of the perl5 binary
17:42:57 <Axman6> > [1 .. fromIntegral $ ord 'C']
17:42:57 <blackdog> kmc: although ruby did that too
17:42:58 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
17:43:07 <Axman6> > product [1 .. fromIntegral $ ord 'C']
17:43:08 <lambdabot>   364711109181886852882498590966054644271676353140495245937016285002679624369...
17:43:09 <blackdog> lambda scoping changed between 1.8.6 and 1.9
17:43:11 <Veinor> whoo
17:43:13 <kmc> ha
17:43:22 <blackdog> and maybe even between 1.8.6 and 1.8.7
17:43:23 <kmc> but lambda, only weirdos use that ;P
17:44:04 <blackdog> kmc: you are guido van rossum, and i claim my five pounds
17:44:10 <kmc> ha
17:44:13 <kmc> five pounds of what
17:44:43 <blackdog> http://stason.org/TULARC/education-books/sci-fi-sf-fandom/38-Why-You-are-XXX-and-I-claim-my-five-pounds-rec-arts.html
17:45:13 <kmc> i learned something today
17:46:57 <jmcarthur> interesting
17:49:45 <sohum> > fix (1+)
17:49:49 <lambdabot>   mueval-core: Time limit exceeded
17:49:58 <sohum> > unamb (fix (1+)) 999
17:49:59 <lambdabot>   Not in scope: `unamb'
17:50:03 <sohum> poo
17:50:48 <Axman6> > fix (+0+
17:50:49 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
17:50:50 <Axman6> > fix (+0)
17:50:54 <lambdabot>   mueval-core: Time limit exceeded
17:51:10 <Axman6> > fix (*0)
17:51:13 <lambdabot>   mueval-core: Time limit exceeded
17:51:18 <Axman6> > fix (0*)
17:51:20 <aavogt> would unamb be safe for \bot?
17:51:22 <lambdabot>   mueval-core: Time limit exceeded
17:51:30 <mreh> could someone explain how hyperplanes relate to norms?
17:51:42 <fax> > (\i->17^i`mod`40).[1..40]
17:51:43 <lambdabot>   [17,9,33,1,17,9,33,1,17,9,33,1,17,9,33,1,17,9,33,1,17,9,33,1,17,9,33,1,17,9...
17:51:50 <Axman6> has anyone ever read up on the Itanium processor? it seems like a pretty awesome proc
17:51:54 <ddarius> x ∈ P if n.x = 0.
17:52:04 <sohum> aavogt: I'd assume so. as I understand it, it's strictly safter than its arguments
17:52:19 <ddarius> Axman6: I read the manuals(?) when it was new.  It did have quite a few cool things.
17:52:21 <sohum> *safer
17:52:29 <Axman6> sohum!
17:52:33 <arw_> Axman6: in theory. in practice, not even intel managed to write a decent compiler for EPIC.
17:52:36 <sohum> Axman6!
17:52:49 <ddarius> Axman6: It would be a beast to program by hand or write a compiler for, but you would have the potential to do awesome things that way.
17:52:55 <Axman6> arw_: shame
17:53:12 <Axman6> sohum: http://www.haskell.org/haskellwiki/AusHac2010 you're coming right?
17:53:22 <sohum> I... I don't know
17:53:27 <Axman6> that's a yes
17:53:33 <sohum> I /want/ to
17:53:50 <sohum> it's whether I /can/ that's going to be the issue
17:54:33 <Axman6> there's a fair chance that us canberrans will organise transport together
17:54:42 <sohum> ooh
17:55:14 <Axman6> (since Ivan and I are organising it, and we're both here)
17:55:36 <sohum> (right. wait, what? ivan's in canberra already?)
17:56:21 <Axman6> yes, he's been here since the beginning of semester, doing his PhD stuff
17:56:23 <devinus> has anybody been following the snap web framework?
17:56:37 <sohum> that's pretty cool.
17:58:11 <Axman6> blackh! hooray!
17:58:36 <blackh> Axman6: I've been on holiday for two weeks.
17:58:45 <blackh> But I am back!!!!
17:58:49 <Axman6> whoot!
17:58:55 <Axman6> and you're coming to AusHac!
17:58:57 <Axman6> :D
17:59:06 <chrisdone> snap web framework eh
17:59:15 <chrisdone> Axman6: how long does aushac go on for?
17:59:21 <Axman6> three days
17:59:25 <Axman6> fri-sun
18:01:02 <chrisdone> devinus: well nice to see another haskell-web-project-answer-to-all-our-prayers. happstack tried, salvia is trying, snap is trying, regular-web seems promising, I hope they keep coming until one actually works and is used enough to iron out the creases
18:01:29 <Axman6> eh
18:01:31 <Axman6> heh*
18:01:33 <sohum> ouch
18:01:50 <sohum> why did happstack fail?
18:02:22 <Axman6> i found it too complicated to use
18:02:24 <devinus> chrisdone: i got a prerelease look at snap when gregory collins announced his attoparsec-iteratee work
18:02:30 <chrisdone> well I'm not saying it failed, but people are still writing new frameworks
18:02:36 <devinus> chrisdone: it looked....fucking awesome
18:02:51 <chrisdone> devinus: was it easy to use, like Rails easy?
18:03:04 <sohum> hahahah, rails easy.
18:03:23 <devinus> chrisdone: erm...i think different methodology
18:03:26 <chrisdone> ok so I've never used rails, but I saw a video tutorial and it looked easy
18:03:26 <djahandarie> Types should make development easier than rails easy. :-)
18:03:41 <devinus> chrisdone: right ow it's like rack on haskell
18:03:47 <sohum> ok, so I may be a tad out of date, but when I used rails, it was very easy for the first 80% of your app and very difficult for the last 20%
18:04:24 <sohum> um. then again I was trying to do a lot of fancy stuff that I didn't quite understand, so it may have been more my fault.
18:04:37 <chrisdone> devinus: have you tried salvia?
18:04:37 <blackdog> devinus: what is? there's already hack for haskell, which is more or less an exact analogue
18:04:59 <chrisdone> yeah I saw hack
18:05:20 <arw_> rails is actually a very good name to describe what rails does: you get there very fast, at least if you are interested in a station on the way. but its impossible and ends in a catastrophe to stray from the path...
18:05:20 <Axman6> sohum: sounds like my experience with rails too
18:05:30 <devinus> chrisdone: i think a lot of haskellers are doing it wrong with web frameworks right now, really. it seems they're trying to do django/rails in haskell instead of giving me framework that's "performant" and highly concurrent, abstracts http away, and has pluggable templating, session support, auth, etc
18:05:41 <kmc> chrisdone, haha... not used to parsing that question in this context
18:05:50 <sohum> devinus: I... hm. that's an idea.
18:05:53 <chrisdone> devinus: salvia is like that
18:06:08 <chrisdone> http://hackage.haskell.org/package/salvia
18:06:11 <devinus> like...i dont need rails, i just need something to hack on top of
18:06:25 <chrisdone> modular, performant (they say, as usual)
18:06:25 <kmc> i can only hope someone writes a module or something for salvia and names it "divinorum"
18:06:37 <Axman6> i've seen people use salvia, it's pretty hilarious
18:06:46 <Axman6> the plant that is
18:06:49 <chrisdone> Axman6: that's mean, he's put a lot of work into it
18:07:17 <chrisdone> I tried the demo program and half of it didn't work right
18:07:21 <chrisdone> I'll have to spend a weekend with it
18:08:18 <chrisdone> have you guys seen chris eidof's regular-web package?
18:08:41 <chrisdone> it derives database relationships and formlets for your data types, very cool stuff
18:08:53 <chrisdone> http://hackage.haskell.org/package/regular-web
18:09:24 <Veinor> jeez
18:09:34 <Veinor> this thing is 12.1 MB O_o
18:09:35 <Axman6> http://www.bannedinhollywood.com/driving-on-salvia/ <- people using salvia
18:09:36 <Axman6> >_>
18:09:46 <Veinor> I think it's HXT's fault
18:09:52 <chrisdone> Veinor: salvia?
18:09:53 <Axman6> urgh, httpv://www.youtube.com/watch?v=w6dgXX0ytSo even
18:10:01 <kmc> httpv
18:10:02 <Veinor> no, a binary
18:10:05 <devinus> Axman6: when i tripped on salvia i thought i was a shopping cart....
18:10:13 <Axman6> XD
18:10:21 <kmc> salvia is by far the weirdest drug i know of
18:10:39 <Axman6> aww, the video got removed :(
18:11:10 <Axman6> http://www.youtube.com/watch?v=SnwS5sPOzb0 !
18:11:44 <chrisdone> I was going to order some but decided to steer clear because I know I'll have some nightmarish programming perceptions
18:11:47 <Veinor> maybe I should've linked against tagsoup or something instead
18:12:47 <sohum> I have this weird bias against anything using template haskell. Maybe I just don't understand it, but it just seems awkward and inelegant.
18:12:55 <kmc> sohum, it is
18:13:08 <devinus> anybody know how many req/s i could expect from salvia?
18:13:10 <kmc> it's a powerful and complex tool for when simpler tools do not suffice
18:13:18 <kmc> @quote majesty
18:13:18 <lambdabot> malcolm says: I don't believe you need to invoke the full awesome majesty of Template Haskell
18:13:26 * sohum snerk
18:13:41 <kmc> in a functional language, you don't need to manipulate code as much, because you can manipulate functions
18:14:11 <sohum> can't things be powerful without being awkward, though? especially when you /have/ such a (well, theoretically) elegant basis as haskell to build upon?
18:14:28 <kmc> TH could be much better, no question
18:14:42 <kmc> and Haskell's design is elegant in a lot of ways, but was not built around pervasive metaprogramming
18:14:45 <kmc> the way LISP was
18:14:53 <dancor> i was pretty convinced that TH is good for the things the original TH paper suggests it for
18:15:07 * sohum nods.
18:15:12 <kmc> i think TH does solve some tricky issues in metaprogramming, like scoping of variables across stages
18:15:37 <Axman6> sohum: mmorrow used it very effectively to make a very fast FFT library which unrolled all the loops and made it all use types that can be compiled to use SSE instructions very easily. it's pretty damn fast
18:15:56 <dancor> another thing you can do instead of TH is just write a haskell program that creates haskell code, which is then compiled.
18:16:02 <dancor> and once you think of it in that context, you see what TH makes easier/harder versus that.
18:16:29 <sohum> this makes sense, yea.
18:16:36 <kmc> TH is often used to autogenerate boilerplate code based on a datatype
18:16:51 <fax> I need disquisitiones arithmeticae
18:16:53 <kmc> for which its reification feature is nice
18:17:10 <kmc> less work than parsing the code yourself
18:17:19 <fax> I wonder why I can borrow it from the library but not just read it online
18:17:27 <kmc> the holy grail i think is some smooth combination of TH, GHC API, and LLVM backend with JIT and runtime dynamic linking
18:17:38 <dancor> fax: that's probably a sign that you aren't living in the future
18:17:38 <kmc> then you can really get rid of staging distinctions
18:17:43 <chrisdone> fax: number of copies are important!!
18:17:52 <chrisdone> ._.
18:18:18 <fax> well the library does give royalty fee based on the number of times it's borrowed to the author.... who is ... uuh Gauss
18:18:19 <dancor> that work is free domain
18:18:35 <sohum> kmc: right, yea. that'd be heavyweight now, but... hm.
18:18:37 <chrisdone> fax: haha author[^[^[^[^publisher
18:18:50 <fax> I guess that's the answer right there
18:19:03 <kmc> i'd also like to see something capable of metaprogramming modifications to the concrete syntax of Haskell
18:19:04 <fax> wait O_O I thought this was -blah
18:19:07 <kmc> like camlp4
18:19:08 <chrisdone> haha
18:19:14 <kmc> it'd make it much easier to investigate new language extensions
18:19:23 <fax> oh god what I have done
18:19:34 <kmc> GHC has a lot of sugary extensions... it'd be nicer if they were self-contained cabal packages
18:19:48 <kmc> fax, #haskell is NEVER off topic!
18:19:50 <fax> kmc what about starting with lisp (except not using s-exps)
18:19:52 <kmc> you have ruined our reputation
18:20:01 <fax> I mean lazy haskell-type-system lisp
18:20:13 <kmc> a LISP syntax for Haskell
18:20:16 <fax> no
18:20:18 <fax> not lisp syntax
18:20:26 <chrisdone> fax: so quotation and eval?
18:20:35 <fax> I don't think eval would be needed
18:20:39 <fax> definitely want quotation
18:20:40 <chrisdone> hrm
18:20:41 <kmc> TH gives you quotation, and GHC API gives you eval
18:20:43 <ddarius> kmc: Haveyou looked at the MetaML (and co.) work?
18:20:49 <kmc> ddarius, only as referenced by the TH paper
18:20:58 <kmc> MetaML is typed more strongly than TH, iirc
18:21:04 <tensorpudding> A Haskelly Lisp would look a lot like Qi
18:21:07 <ddarius> kmc: There is much newer work than that which is pretty interesting.
18:21:10 <kmc> cool
18:21:56 <sohum> tensorpudding: have you used Qi?
18:22:06 <tensorpudding> No.
18:22:22 <chrisdone> it's a layer ontop of common lisp
18:22:28 <chrisdone> i guess you could do a haskelly equiv.
18:22:36 <tensorpudding> I knew it had pattern-matching though
18:22:47 <ddarius> kmc: I need to (re)find a recent paper that I thought was very good.
18:22:54 <sohum> wasn't the legal status of Qi kinda weird?
18:23:04 <chrisdone> ?
18:23:40 <tensorpudding> You had to register to download it.
18:23:46 <tensorpudding> Which is why I never did.
18:23:53 <aavogt> kmc: what kind of typechecking is missed by TH?
18:23:59 <sohum> oh, right. free for personal/paid proprietary. as compared with floss.
18:24:03 <kmc> aavogt, it's a matter of when the checking occurs
18:24:11 <kmc> in MetaML "code for expression of type T" is a type
18:24:16 <kmc> in TH it's just "code for expression"
18:24:46 <aavogt> that would seem to destroy some of the usefulness of TH
18:24:49 <kmc> yes
18:25:04 <kmc> it removes the use case where you use staged compilation as a substitute for dependent types
18:25:07 <aavogt> where the result type can depend on arguments inside the type
18:25:18 <aavogt> exactly ;)
18:25:19 <sohum> eval :: AST a -> a
18:25:41 <Saizan> i think there's something like a staged "dynamic" for that
18:25:50 <kmc> symmetrically, implementations of eval in Haskell usually give you results in Dynamic, or (Typeable a) => Maybe a
18:25:57 <aavogt> Saizan: in meta ML?
18:26:21 <Saizan> aavogt: yeah, but i could very much be wrong
18:30:20 <dark> Qi was cited here. 'Qi II is currently free for personal and educational use and a proprietary license for producing closed source is included in the language guide available from the home site.' > this bothers anyone here? (that knows qi)
18:31:02 <dark> i have no idea why someone would build non-free language implementations those days (without being tied to a huge company etc)
18:31:10 <sohum> it's pushed my "poke at qi" point a lot further back than it would be otherwise
18:31:34 <dark> (but yes i saw that the "version 1" is gpled)
18:42:37 <Veinor> is there a reason my simple program that uses hxt is 12 megabytes in size? O_o
18:46:18 <chrisdone> Veinor: static linking?
18:46:44 <Veinor> probably.
18:46:58 <Veinor> maybe I want to use haxml instead of hxt
18:47:37 <Veinor> a quick experiment suggests it has smaller binaries
18:51:16 <Veinor> but... there's no guide to it.
18:58:15 <Axman6> > concat . map inits . tails $ [1..3]
18:58:16 <lambdabot>   [[],[1],[1,2],[1,2,3],[],[2],[2,3],[],[3],[]]
18:58:30 <Axman6> > concat . filter null . map inits . tails $ [1..3]
18:58:31 <lambdabot>   []
18:58:38 <Axman6> > concat . filter (not.null) . map inits . tails $ [1..3]
18:58:39 <lambdabot>   [[],[1],[1,2],[1,2,3],[],[2],[2,3],[],[3],[]]
18:58:53 <Axman6> > filter (not.null) . concat . map inits . tails $ [1..3]
18:58:54 <lambdabot>   [[1],[1,2],[1,2,3],[2],[2,3],[3]]
18:59:01 <Axman6> > filter (not.null) . concat . map inits . tails $ [1..5]
18:59:02 <lambdabot>   [[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[2],[2,3],[2,3,4],[2,3,4,5],[3],[3...
19:00:58 <Axman6> > map sum . filter (not.null) . concat . map inits . tails $ [1..5]
19:00:59 <lambdabot>   [1,3,6,10,15,2,5,9,14,3,7,12,4,9,5]
19:01:24 <chrisdone> oh,cute
19:01:32 <Axman6> not my code
19:03:15 <pastorn> is there something special about those  numbers?
19:03:51 <Axman6> not really, it's finding the sum of all continuous subsequences
19:04:13 <pastorn> Axman6: try to generate the number sequence from LOST :)
19:04:24 <Veinor> oh hey, running strip on the binary cuts the size in half
19:04:25 <fax> @oies 1,3,6,10,15
19:04:25 <lambdabot>  Triangular numbers: a(n) = C(n+1,2) = n(n+1)/2 = 0+1+2+...+n.
19:04:25 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,2...
19:04:33 <fax> @oies 2,5,9,14
19:04:34 <lambdabot>  n(n+3)/2.
19:04:34 <lambdabot>  [0,2,5,9,14,20,27,35,44,54,65,77,90,104,119,135,152,170,189,209,230,252,275,...
19:04:36 <Axman6> that would mean paying attention to lost
19:04:37 <pastorn> http://midwestnerds.com/wp-content/uploads/Lost%20Numbers.jpeg
19:04:46 <fax> @oie 3,7,12
19:04:47 <lambdabot> Maybe you meant: bid dice id join more oeis time vote
19:05:04 <Axman6> > maximum . map sum . filter (not.null) . concat . map inits . tails $ [1..10]
19:05:05 <lambdabot>   55
19:05:13 <Axman6> > maximum . map sum . filter (not.null) . concat . map inits . tails $ [-10..10]
19:05:14 <lambdabot>   55
19:05:50 <Axman6> > maximum . map sum . filter (not.null) . concat . map inits . tails . take 100 . randomRs (-100,100 :: Int) $ mkStdGen 18383
19:05:52 <lambdabot>   462
19:06:01 <Veinor> @oeis 4,8,15,16
19:06:01 <lambdabot>  Table of Whitney numbers W(n,k) read by antidiagonals, where W(n,k) is maxim...
19:06:02 <lambdabot>  [1,1,1,1,2,1,1,2,3,1,1,2,4,4,1,1,2,4,7,5,1,1,2,4,8,11,6,1,1,2,4,8,15,16,7,1,...
19:06:27 <Veinor> @oeis 4,8,15,16,23,42
19:06:27 <lambdabot>  The Lost Numbers.
19:06:27 <lambdabot>  [4,8,15,16,23,42,108]
19:06:30 <chrisdone> pastorn: http://82.33.137.16/1269741150722.jpg
19:06:33 <Axman6> heh
19:06:54 <pastorn> haha
19:06:55 <pastorn> nice
19:07:28 * pastorn goes and lurks on /prog/
19:07:49 <pastorn> shit, first thread: http://dis.4chan.org/read/prog/1270499377/1-40
19:08:11 <chrisdone> can't view, banned. :(
19:08:26 <chrisdone> trying sleep again. bbl
19:08:34 <pastorn> chrisdone: what did you do?
19:08:47 <Veinor> Haskell is like the Emperor's New Clothes of programming.
19:08:48 <Veinor> Only people who are very smart like to program in Haskell, ergo, every programmer pretends to like Haskell (while actually implementing everything in Python or Perl). I've never used a bit of useful software actually implemented in Haskell, though.
19:08:51 <pastorn> i saw a nice ban-message-thread earlier today
19:09:07 <pastorn> "Banned 4 lyfe: being a moralfag in a CP thread"
19:10:14 <pastorn> "
19:10:15 <pastorn>     Haskell was designed to be not popular. Get used to it.
19:10:23 <pastorn> haha... new slogan :)
19:10:26 <kmc> haha Veinor
19:10:32 <kmc> we're being dissed by 4chan now
19:10:35 <kmc> a true sign of success
19:10:41 <pastorn> yay!
19:12:39 <Gracenotes> I forget.. is there a process exec function in base?
19:12:45 <Veinor> hm, yeah. with one of the hxt samples, 11MB for the unstripped version, 5MB for stripped
19:13:42 <Gracenotes> or at least without hackaging. does not appear so.
19:14:45 <Veinor> and it's only 4.0 MB for the linux version!
19:15:22 <Gracenotes> :o
19:15:44 <kmc> process exec?
19:15:51 <kmc> System.Process?
19:16:15 <karlzt> hello haskelletons
19:16:40 <Gracenotes> oh. ooh. not base then, but stdlib.
19:16:43 <pastorn> karlzt: i'm a curried meat
19:21:56 <_notallama> is there a sleep function in haskell?
19:22:05 <fax> yes
19:22:09 <fax> :t threadDelay
19:22:10 <lambdabot> Not in scope: `threadDelay'
19:22:12 <fax> damn
19:22:16 <kmc> it's in Control.Concurrent
19:22:20 <fax> there definitely is
19:22:24 <fax> I can't rememberthe name
19:22:25 <kmc> takes its arg in microseconds
19:22:28 <kmc> and it is named threadDelay
19:22:30 <kmc> @hoogle threadDelay
19:22:30 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
19:22:31 <fax> ok
19:22:37 <_notallama> sweet. thanks
19:35:06 <Cale> I find it amusing that because of the use of Int there, the maximum amount of time that you can threadDelay for will be different on a 32 and 64 bit architecture.
19:36:19 <Cale> On a 32 bit machine, you can only threadDelay for about 35 minutes.
19:37:13 <Cale> while on a 64 bit machine, it's 292 millenia or so.
19:38:46 <fax> heh
19:39:17 <ddarius> 35 minutes should be enough for -anyone-.
19:42:30 <kmc> i used threadDelay yesterday to time some food i was cooking
19:42:55 <dons> nice!
19:44:08 <Axman6> let threadDelay' :: Integer -> IO (); threadDelay' x = let x' = x - (fromIntegral (maxBound :: Int)) in if x' > 0 then threadDelay maxBound >> threadDelay' x' else threadDelay (fromItegral x)
19:44:15 <Axman6> let threadDelay' :: Integer -> IO (); threadDelay' x = let x' = x - (fromIntegral (maxBound :: Int)) in if x' > 0 then threadDelay maxBound >> threadDelay' x' else threadDelay (fromIntegral x)
19:44:39 <Axman6> that seems rather verbose
19:44:56 <Cale> Might want to just do division
19:45:01 <Cale> and use replicateM
19:45:18 <Cale> Although, that *also* unfortunately takes an Int parameter, haha
19:45:43 <ddarius> Cale: Which would get you 64 bits with 32-bit ints.
19:46:03 <ddarius> Cale: I don't think the user is going to come back after 292,000 years.
19:46:44 <Cale> ... really long time ... ... 42
19:48:56 <enthymeme> hehe Cale.
19:49:02 <enthymeme> you use swi-prolog at all?
19:49:11 <Cale> I have, yeah :)
19:49:25 <enthymeme> Last release gives the question
19:51:08 <kmc> divMod?
19:51:18 <Axman6> > divMod 10 3
19:51:19 <lambdabot>   (3,1)
19:51:20 <enferris> I did for class about a year ago.
19:51:23 <Axman6> @src div
19:51:24 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
19:51:27 <Axman6> @src mod
19:51:27 <lambdabot> Source not found. It can only be attributed to human error.
19:51:29 <Axman6> bah
19:51:40 <ddarius> @src Integral
19:51:40 <lambdabot> class  (Real a, Enum a) => Integral a  where
19:51:40 <lambdabot>     quot, rem, div, mod :: a -> a -> a
19:51:40 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
19:51:40 <lambdabot>     toInteger           :: a -> Integer
19:51:45 <kmc> > (2^128 :: Integer) `divMod` (fromIntegral (maxBound :: Int))
19:51:46 <lambdabot>   (36893488147419103236,4)
19:51:47 <Axman6> well, div x y = fst (divMod x y)
19:52:18 <Axman6> @src Int div
19:52:18 <lambdabot> Source not found. Take a stress pill and think things over.
19:54:03 <dons> i for one am glad to see openbsd sudo insults return to lambdabot
19:54:13 <Cale> 292 millenia, 277 years, 97 days, 49 minutes, 7 seconds, 383 milliseconds and 100 microseconds.
19:54:41 <pastorn> dons: do you know anything about OpenBSD?
19:54:42 <ddarius> Cale gets the Repeated Applications of DivMod prize.
19:55:04 <pastorn> like... do they use other languages than C for their code?
19:55:27 <Cale> They never left, did they?
19:57:10 <dons> pastorn: i used to be an openbsd dev, and lambdabot originally ran on openbsd for many years
19:57:11 <blackdog> dons: for when passive-aggressive just isn't enough
19:57:51 <pastorn> dons: oh, cool... do you know about different languages in OpenBSD?
19:57:59 <dons> programming languages?
19:58:04 <pastorn> yeah
19:58:07 <pastorn> is it all C?
19:58:11 <dons> no no.
19:58:12 <pikhq> pastorn: OpenBSD proper is pretty much C.
19:58:17 <dons> the openbsd ports system has all the stuff you'd expect
19:58:22 <dons> the kernel is of course C.
19:58:34 <dons> i did the ghc port, which works fine.
19:58:48 <pastorn> dons: ok... don't they look into other languages which has better security models than C
19:58:53 <dons> actually, back when they had a.out format binaries. sigh, wasted yooff
19:59:11 <dons> pastorn: there's some awareness. but not a lot, since it is still kernel devs mostly
19:59:22 <dons> but there is an ocaml guy in the core team as well
19:59:35 <dons> they're interrested in static analysis of C
19:59:36 <pastorn> cool :)
19:59:40 <augur> anyone know of an english parser grammar?
19:59:49 <shapr> Have you checked out GF?
19:59:51 <dons> augur: i think there's something of one in the GF tool
19:59:55 <augur> like, a reference grammar?
20:00:00 <shapr> oh
20:00:01 <dons> shapr: we'll hopefully be using GF in production soon
20:00:04 * shapr hugs dons 
20:00:07 <shapr> dons: Whoa awesome!
20:00:08 <dons> boing!
20:00:12 <shapr> yay!
20:00:13 <augur> what now
20:00:15 <augur> GF?
20:00:19 <shapr> Grammatical Framework
20:00:19 <pastorn> gogo super aarne
20:00:23 <dons> shapr: good for translating to and from formal languages
20:00:33 <shapr> Yeah, exactly, Go Go Super Aarne Ranta!
20:00:49 <shapr> dons: Wow, extremely spiffy!
20:00:52 <dons> i'd like to write a tool with GF too translate haskell types into english
20:00:52 <pastorn> shapr: his swedish is cool, he speaks with a finnish accent :)
20:00:59 <shapr> Sounds like something that's perfect for programmatica.
20:00:59 <dons> so we could auto comment our code :)
20:01:10 <pastorn> dons: haha... sounds cool...
20:01:17 <shapr> pastorn: Does not surprise me, with a name like that... speaking of which, I just got another three antique Swedish books off ebay, yay!
20:01:18 <pastorn> dons: you have an example?
20:01:21 <augur> dons, shapr: <3
20:01:34 <dons> sin :: Double -> Double ----> "sin takes a Double and returns a Double, with no side effects"
20:01:41 <dons> etc
20:01:45 <shapr> dons: That would be freakin awesome... especially with eflite or something installed.
20:01:48 <dons> GF could do that easy too
20:01:52 <shapr> Yeah, totally.
20:01:53 <pastorn> dons: so you wanna generate noob comments :)
20:01:57 <dons> pastorn: right
20:01:58 <kmc> all the functions are "with no side effects"
20:01:59 <dons> just because we can
20:02:06 <kmc> why bother saying it?
20:02:20 <dons> getArgs :: IO [String] ---> "getArgs returns a list of strings, after doing some magic"
20:02:32 <ddarius> kmc: Gotta beat it into those "noobs'" heads
20:02:34 <Gracenotes> not just any list of strings, it's a recipe for cake!
20:02:41 <dons> oh my!
20:02:44 <kmc> this reminds me of cdecl
20:02:58 <dons> yeah
20:03:10 <dons> but GF will also do it in swedish and german and french and ..
20:03:12 <edwardk> an interesting observation about (q)sat solving. if you start building things functionally, you wind up with the 'foralls' and 'exists' commuted down over the operators towards the clauses they control... a sat solver that works on AIGs would normally have to reinvent that step.
20:03:28 <Gracenotes> hm... or the passed arguments. but that's really hard to automate, figuring that out.
20:03:33 <ddarius> "AIGs" == ?
20:03:41 <edwardk> ddarius: and-inverter graphs
20:04:11 <ddarius> edwardk: Question 2: What does "building things functionally" mean in this context?
20:04:12 <edwardk> ddarius: build up nodes as 'ands' and allow optionally negating each edge, as opposed to reducing to CNF or ROBDDs
20:04:13 <dons> edwardk: cryptol compiles to AIGs
20:04:17 <dons> to do equiivalence checking of algos
20:04:53 <edwardk> dons: i'm using AIGs internally in my qsat monad as the intermediate bit rep.
20:05:01 <SamB_XP> > cake
20:05:02 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
20:05:22 <dak1n1> hi guys, could someone please tell me how to get the index/subscript of an item in a list? I've never used Haskell before
20:05:28 <edwardk> and yeah AIGs have nice easy equivalence checking algorithms
20:05:39 <SamB_XP> @let getArgs = return cake
20:05:40 <lambdabot>  Defined.
20:05:40 <kmc> dak1n1, a list is not a good datastructure for random searching
20:05:45 <SamB_XP> > getArgs
20:05:46 <lambdabot>   No instance for (GHC.Show.Show (m [[GHC.Types.Char]]))
20:05:46 <ddarius> dak1n1: Why do you want to do that?
20:05:46 <lambdabot>    arising from a us...
20:05:55 <kmc> dak1n1, that said, look at the Data.List module
20:06:07 <kmc> :t elemIndex
20:06:08 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
20:06:08 <dak1n1> ddarius: I'm a CS student... it's for an assignment.
20:06:17 <dak1n1> kmc: thanks
20:06:22 <kmc> > elemIndex 5 [1,5,3]
20:06:23 <lambdabot>   Just 1
20:06:25 <kmc> > elemIndex 6 [1,5,3]
20:06:26 <lambdabot>   Nothing
20:06:39 <edwardk> trying to tackle the AIGsolve approach incrementally while building up problems in a monad for 'slightly qbf' sat problems
20:06:43 <Gracenotes> and it needs Data.List
20:07:19 <dak1n1> yeah, I got it to return "Just 2" or something like that, but I wasnt able to compare that return value with an int. Like I want to be able to use the index number to see if it's even or odd
20:07:32 <edwardk> ddarius: as for 'functionally' basically what i have looks a lot like kansas lava + HOAS'd forall/exists and support for encoding/decoding the outermost existentials
20:08:12 <SamB_XP> kansas lava ?
20:08:31 <edwardk> runsat $ assert $ forall $ \x y z -> (x && y) ==> z == x ==> y ==> z
20:08:35 <Cale> library for digital circuit design and simulation
20:08:35 <SamB_XP> what kind of circuits do they write in kansas ?
20:08:51 <edwardk> SamB_XP: whatever andy gill can talk them into writing i guess ;)
20:09:02 <kmc> dak1n1, use "case" to take apart the Maybe value
20:09:08 <kmc> :t elemIndex 6 [1,5,2]
20:09:08 <lambdabot> Maybe Int
20:09:11 <SamB_XP> like, is there some reason you had to specify "kansas"?
20:09:20 <ddarius> @google kansas lava Haskell
20:09:21 <lambdabot> http://www.haskell.org/communities/11-2009/html/report.html
20:09:21 <lambdabot> Title: Haskell Communities and Activities Report
20:09:22 <Gracenotes> ooh, there's also Data.Maybe, with utility functions
20:09:26 <kmc> > case elemIndex 5 [1,5,2] of Just n -> n == 1; Nothing -> False
20:09:27 <lambdabot>   True
20:09:27 <edwardk> SamB_XP: there are two 'lava' implementations, there is chalmers lava and kansas lava
20:09:32 <kmc> dak1n1, ^^^^
20:09:37 <edwardk> chalmers uses unsafePerformIO to sprinkle their bits with Ref's
20:09:41 <kmc> or use:
20:09:41 <dak1n1> kmc: awesome! that's just what I was looking for. thanks
20:09:42 <kmc> :t maybe
20:09:43 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
20:09:44 <ddarius> @google "introducing kansas lava"
20:09:45 <lambdabot> http://www.ittc.ku.edu/~andygill/talks/20090923-ifl-kl.pdf
20:09:45 <lambdabot> Title: Introducing Kansas Lava
20:09:46 <kmc> :t fromMaybe
20:09:47 <lambdabot> forall a. a -> Maybe a -> a
20:09:48 <edwardk> kansas uses stableNames to recover sharing post hoc
20:10:02 <kmc> dak1n1, :)
20:10:18 <SamB_XP> edwardk: ah. I may have seen both, but not realized they were from different places ;-).
20:12:01 <edwardk> SamB_XP: personally i prefer the stable name approach. it works well in this situation. i can build up a sat monad that lets you declare the existence of bits and assert that certain formulas of them hold, then run the sat problem, and get out a witness that can be decoded back into haskell types.
20:13:02 <edwardk> i could do it with unsafePerformIO'd newRef's everywhere or with every single and/or wrapped in monadic bindings, but i'd rather not ;)
20:13:39 <edwardk> this way everything that is 'odd' happens in IO action while i gather clauses
20:13:43 <edwardk> er in one big
20:14:39 <edwardk> this is probably overkill for my very tiny package dependency problem ;)
20:17:20 <ddarius> Building package kata... chasing dependencies... none.  Building...
20:17:26 <edwardk> =)
20:17:39 <edwardk> s/very tiny/trivial/ ;)
20:18:03 <Veinor> hm
20:18:17 <edwardk> i'm also using it to replace a bunch of the uglier old datalog bits i had lying around
20:18:28 <Veinor> I'm tempted to distribute precompiled binaries, but I'm not sure how best to do so
20:18:32 <ddarius> What did you have datalog for?
20:19:23 <edwardk> i was using it to encode the logic for what class member definitions to suck into the current context when you declared a new object
20:19:50 <ddarius> I really need to work on my logic language.  Stupid linear logic resource management.
20:22:14 <edwardk> with say: class optimized monad, class monad : endofunctor, class endofunctor : functor, optimized endofunctor adds methods due to a mixin class definition, optimized functor adds more stuff, i need to establish dominator relationships between them to make sure that in the case of conflicts there is clear precedence, etc. it is nice to be able to just state such properties declaratively and get back the answer.
20:23:01 <ddarius> edwardk: Agreed.
20:23:18 <ddarius> This is (part of) why I want my linear logic language.
20:23:30 <edwardk> for the current language a naive greedy approach is sound and complete, but under some minor extensions, having the ability to appeal to sat or qbf would be nice
20:24:17 * ddarius should see if there is any (new) bleeding edge LL RM stuff.
20:25:22 <edwardk> i put down substructural logic after hacking on nuel for too long and winding up with a mess where the types just made everything that much more verbose and not sufficiently faster or more correct to justify the pain.
20:26:04 <edwardk> i still like having access to uniqueness information, but i'm not so sold on traditional linearity. flipping that temporal modality makes more sense to me
20:26:45 <ddarius> edwardk: I'm not terribly interested in it as a compiler analysis tool.
20:26:57 <edwardk> in fact with the sort of loose type info i have with kata anyways, i'm looking at trying to RECOVER uniqueness during garbage collection.
20:27:04 <edwardk> which would be kinda cool
20:27:14 <pastorn> dons: what's this? http://www.cse.unsw.edu.au/~dons/pretty.html
20:27:28 <edwardk> *nods*
20:27:41 <edwardk> linear logic makes a great model for a changing world
20:27:50 <pastorn> dons: i'm scared to run it...
20:27:52 <dons> oh, my first attempt at haskell obfuscation
20:28:04 <dons> it just does a sort of words in the file by frequency
20:28:06 <pastorn> dons: what does it do?
20:28:26 <edwardk> And as ICFP taught us, affine logic makes a great model for a changing world in which you have a flamethrower.
20:29:04 <dons> pastorn: gee, that must be from 2002 or so
20:29:18 <pastorn> dons: do you thnk it still runs?
20:29:41 <dons> probably, yes.
20:29:43 <ddarius> edwardk: How often do you think of the context as an explicit data structure when logic programming?
20:29:48 <dons> it's H98 + hier mods, iirc
20:29:52 * pastorn takes a leap of faith
20:29:54 <dons> my h98 from 1998 still runs
20:30:05 <dons> pastorn: you have to give it a dictionary and a word file as args, iirc
20:30:31 <edwardk> ddarius: not so much, usually just about what is around what i'm manipulating
20:30:54 <edwardk> is the hand empty, is the block on top of the stack, beyond that, what context? the logic takes care of it
20:30:56 <ddarius> edwardk: Same for me until I started looking at linear and particularly ordered linear logic.
20:31:26 <edwardk> ddarius: er.. sorry i had read 'logic programming' as 'linear logic programming'
20:31:35 <ddarius> edwardk: Either way.
20:31:48 <edwardk> my reply was meant to say that in linear logic i don't wind up thinking about context much because i don't have to kill myself to encode it
20:32:04 <ddarius> In the case of ordered linear logic, the context has a very "queue-like" feel and in particular one global implicit queue which leads me to want labelled implication.
20:32:26 <edwardk> labels being actions of some sort?
20:32:44 <ddarius> Labels labelling which context to insert a hypothesis in.
20:33:24 <edwardk> do you have anything you feel a pressing need to model with these tools?
20:33:32 <ddarius> edwardk: E.g. for linear logic the context is like a bag.  You may want multiple bags to keep the contexts from interfering with each other.
20:33:45 <edwardk> ok
20:34:14 <edwardk> you want multiple stacks for ordered logic?
20:34:17 <ddarius> edwardk: With an LLP language in general, it be nice for experimenting the type systems and operational semantics and such.
20:34:41 <edwardk> wouldn't adding a second stack give you the power to sidestep the order constraint?
20:34:49 <edwardk> just like you can use two stacks to run a turing machine?
20:34:51 <ddarius> edwardk: Multiple queues, yes.  Some "new" logical primitives would arise from moving between contexts.
20:35:09 <edwardk> using them like a ordered logic zipper
20:35:18 <edwardk> hrmm
20:35:23 <grok> greetings
20:35:51 <imachuchu> quit
20:35:58 <ddarius> edwardk: I don't think that wouldn't be a problem any more than linear logic languages having an intuitionistic and linear context affects them.
20:36:11 <ddarius> The rules to move between contexts would just need to be appropriate.
20:36:24 <edwardk> fair enough
20:37:16 <edwardk> yeah, you can probably just treat it as a many sorted logic, using the labels as sorts or building a sort lattice off them
20:37:41 <grok> guess i'll ask what i came to ask, i'm trying to write a function to find the 2 largest numbers on a list using the fold function. however i'm very new to haskell. i found a function that uses folds to do the same as the maximum function. now i need to understand it enough to modify it to find the 2 largest
20:38:16 <grok> biggest' :: (Ord a) => [a] -> a
20:38:16 <grok> biggest' = foldr1 (\x acc -> if x > acc then x else acc)
20:38:35 <grok> that is the current function i have. i'm having trouble understanding what it does though.
20:38:36 <edwardk> grok: the foldr you found that computs the maximum holds onto one element as context. you need to be able to hold onto two in your accumulator
20:38:51 <edwardk> > foldr1 f [a,b,c,d,e]
20:38:52 <lambdabot>   f a (f b (f c (f d e)))
20:39:04 <grok> so a tuple would be what i'd want?
20:39:14 <edwardk> at first blush, but there is a problem
20:39:25 <edwardk> what happens when you have fewer than two elements?
20:39:58 <grok> fewer than 2 elements would return the list.
20:40:02 <edwardk> plus you don't have a 'foldr2' to get you started.
20:40:29 <grok> foldr2 is something different than foldr1?
20:40:49 <edwardk> no, foldr2 doesn't exist. i was pointing out that foldr1 grabbed the first element and then ran foldr
20:40:52 <edwardk> @src foldr1
20:40:53 <lambdabot> foldr1 _ [x]    = x
20:40:53 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
20:40:53 <lambdabot> foldr1 _ []     = undefined
20:41:00 <edwardk> er
20:41:10 <edwardk> well, i guess not there it doesn't ;)
20:41:46 <felzix> should cabal accept a version "0.02"?
20:42:00 <dons> 0.0.2 ?
20:42:04 <ddarius> foldr1 f (x:xs) = foldr f x xs
20:42:17 <felzix> dons: yes
20:42:21 <edwardk> so you can define
20:42:42 <felzix> dons: my previous version was 0.1 (typo)
20:43:20 <edwardk> something ehere you kickstart with the first two elements of the list, and then feed it the others to be sorted into your tuple
20:43:24 <grok> ok, so i could compare the first 2 values, if they are not in order, swap them. then compare the second and third values. if they are not in order, swap them. this would eventually give me an array with the first and second element as the largest.
20:44:17 <grok> i should clarify that as descending order.
20:44:34 <ddarius> edwardk: I could also experiment with disposing of associativity too and working in a bunched logic.
20:45:00 <edwardk> top2 (a:b:rest) | a < b = go (b,a) rest | otherwise = go (a,b) rest where go (a,b) (c:cs) = ... ; go (a,b) [] = (a,b)
20:45:48 <edwardk> ddarius: yeah, i went there with nuel and quickly reverted. mostly because i couldn't fit it into my lattice of modalities cleanly
20:47:17 <edwardk> go (a,b) (c:cs) = ... would be responsible for picking the top two elements of a, b, c and throwing the other out and calling 'go' with the result
20:47:46 <ddarius> Bunched logic would probably work great for tree rewriting...
20:47:49 <edwardk> grok: now, do you want the evil answer?
20:48:00 <edwardk> which has the correct asymptotics and is WAY easier?
20:48:41 <SamB_XP> is this take n . sortBy (flip compare)?
20:48:53 <edwardk> > take 2 $ sortBy (flip compare) [2,4,5,1,2,45,5,13]
20:48:54 <lambdabot>   [45,13]
20:48:55 <edwardk> yeah =)
20:49:40 <avenge> GHC 6.12 seems to have made it way, way harder to get a file descriptor out of a file handle.  This makes me very sad, because I write applications that have to call fsync for safety...
20:50:41 <grok> edward is that all you need to do that in haskell?
20:51:02 <dons> avenge: hmm. the unix package should still work fine.
20:51:09 <dons> to collapse the Handle structure
20:51:16 <dons> avenge: worth talking to Simon Marlow about it
20:51:20 <avenge> How, dons?
20:51:22 <edwardk> grok: yeah. the nice thing is that because of laziness, the work that would go into sorting the tail of the list never happens
20:51:26 <SamB_XP> aka JaffaCake
20:51:37 <avenge> You mean if I don't use Handles at all but use FDs?
20:51:44 <SamB_XP> that is you, avenge, should speak with Simon Marlow, aka JaffaCake
20:51:52 <dons> yeah, i guess :/
20:52:02 <edwardk> grok: so take k . sort  is O(n * k), which is the same cost as doing k selections
20:52:20 <SamB_XP> edwardk: that's an implementation detail, isn't it ?
20:52:30 <ddarius> Is this the k-min problem?
20:52:33 <avenge> JaffaCake is an IRC handle?
20:52:38 <Zao> Yes.
20:52:53 <SamB_XP> afaik the standard still doesn't mandate any particular sorting algorithm for sortBy
20:52:56 <edwardk> SamB_XP: yes, but it is correct enough given the implementation of sort in question
20:53:22 <avenge> Okay, thanks.  Will email him.
20:53:30 <grok> odd, it's not running, getting the error "Not in scope: 'sortBy'
20:53:36 <kmc> grok, "import Data.List"
20:53:43 <SamB_XP> hehehe
20:53:53 <SamB_XP> we've got that already imported here ;-)
20:55:01 <grok> i definitely like how short that is to do,
20:55:13 <edwardk> SamB_XP: yeah the report only states that sort is stable. they use foldr (insertBy cmp) []
20:55:37 <SamB_XP> edwardk: ooh, I like it
20:55:54 <SamB_XP> it's not necessarily very GOOD, but it's a sweet demo of insertBy!
20:56:01 <edwardk> yeah
20:56:16 <SamB_XP> and foldr, not that that needs any more demoing ;-)
20:57:38 <ddarius> foldr always needs more demoing!
20:57:45 <ddarius> Just unfoldr needs even more.
20:58:31 <edwardk> unfoldr needs a ViewL/ViewR type in the prelude. ;) so it doesn't pay for two structures ;)
20:58:42 <edwardk> @type unfoldr
20:58:43 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
20:59:22 <pastorn> edwardk: that's a pretty cool function :)
20:59:26 <pastorn> @type unfoldl
20:59:27 <lambdabot> Not in scope: `unfoldl'
20:59:30 <pastorn> awww
20:59:45 <edwardk> pastorn you can build one using Data.Sequence ;)
21:00:06 <Axman6> @src unfoldr
21:00:07 <lambdabot> unfoldr f b  = case f b of
21:00:07 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
21:00:07 <lambdabot>    Nothing        -> []
21:00:29 <ddarius> Who wrote that code?
21:00:36 <edwardk> unfoldr is a better primitive though because it permits 'productive corecursion'. you can read from one end of the list without finishing building
21:00:37 <pastorn> Axman6: shouldn't that be faster if the f was reached from within a where-clause?
21:00:56 <Axman6> reached?
21:02:01 <edwardk> pastorn: you mean if you wrote a loop and removed the 'f' as a variable from the repeated call?
21:02:11 <pastorn> yes
21:02:20 <grok> take 2 $ sortBy (flip compare) [1,234,1,23,1,3,4,5]
21:02:21 <edwardk> pastorn unfoldr f = unfoldr' where unfoldr' b = case f b of ..
21:02:26 <edwardk> turns out not to help =/
21:02:39 <edwardk> because you now have to hold onto the closure that points to f
21:02:43 <Axman6> @let unfoldl f b = ul f b [] where ul f b xs = case f b of Just (a,b') -> ul f b' (a:xs); _ -> xs
21:02:44 <lambdabot>  Defined.
21:02:45 <pastorn> unfoldr f init_b = unfoldr' init_b
21:02:47 <pastorn>    where unfoldr' b = case f b of
21:02:48 <ddarius> I believe GHC already does such transformations.
21:02:49 <pastorn>             Just (a,new_b) -> a : undoldr' new_b
21:02:49 <edwardk> where unfoldr uses nothing of its context
21:02:51 <pastorn>             Nothing        -> []
21:02:53 <grok> umm did i mess up on that syntax edward?
21:03:05 <edwardk> you need a >
21:03:12 <edwardk> > take 2 $ sortBy (flip compare) [1,234,1,23,1,3,4,5]
21:03:13 <lambdabot>   [234,23]
21:03:21 <edwardk> > take 4 $ sortBy (flip compare) [1,234,1,23,1,3,4,5]
21:03:23 <lambdabot>   [234,23,5,4]
21:03:49 <edwardk> > splitAt 2 $ sortBy (flip compare) [1,234,1,23,1,3,4,5]
21:03:50 <lambdabot>   ([234,23],[5,4,3,1,1,1])
21:03:55 <Axman6> > unfoldl (\x -> x > 10 then Nothing else (Just (x,x+1)) 0
21:03:56 <lambdabot>   <no location info>: parse error on input `then'
21:04:00 <grok> > take 2 $ sortBy (flip compare) [1,23423,1,2,4,24,4]
21:04:01 <lambdabot>   [23423,24]
21:04:05 <Axman6> > unfoldl (\x -> if x > 10 then Nothing else (Just (x,x+1)) 0
21:04:06 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
21:04:20 <edwardk> one thing that haskell is good at teaching you is how to string together the builtin functions to get what you want
21:04:49 <Axman6> > unfoldl (\x -> if x > 10 then Nothing else Just (x,x+1)) 0
21:04:50 <lambdabot>   [10,9,8,7,6,5,4,3,2,1,0]
21:05:04 <ddarius> edwardk: Use J.
21:05:10 <edwardk> and unlike almost any other language, haskell is VERY good at peaking inside of them, and shuffling things around to still do things efficiently, laziness lets it skip a lot of the irrelevant activity
21:05:13 <Axman6> > unfoldl (\x -> if x > 1000 then Nothing else Just (x,x*x)) 2
21:05:14 <lambdabot>   [256,16,4,2]
21:05:21 <Axman6> > unfoldl (\x -> if x > 1000 then Nothing else Just (x,x+x)) 2
21:05:22 <lambdabot>   [512,256,128,64,32,16,8,4,2]
21:05:43 <edwardk> ddarius: no thanks, i already went through my apl phase ;)
21:06:06 <ddarius> edwardk: I'm thinking about getting in to J again a bit.
21:06:31 <ddarius> It's a fun language; they just got all the easy stuff wrong.
21:06:40 <edwardk> =)
21:07:05 <grok> odd, seems i'm having trouble downloading data.list, to peak inside of it.
21:07:20 <ddarius> @docs Data.List
21:07:20 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
21:07:24 <SamB_XP> @google "Data.List.hs"
21:07:25 <lambdabot> No Result Found.
21:07:30 <SamB_XP> @google "Data/List.hs"
21:07:31 <lambdabot> No Result Found.
21:07:34 <ddarius> Go there and click "Source Code"
21:07:38 <SamB_XP> @google "Data/List.lhs"
21:07:38 <lambdabot> No Result Found.
21:07:43 <SamB_XP> wah
21:07:55 <edwardk> SamB your google fu is weak
21:08:41 <grok> got it. my google fu is weak
21:09:40 <Cale> @google "how is a psychology degree marketable"
21:09:42 <lambdabot> http://www.eng.tau.ac.il/index.php?option=com_content&view=section&layout=blog&id=44&Itemid=195&language=en-GB
21:09:42 <lambdabot> Title: Department of Industrial Engineering
21:10:22 <Cale> Ah SEO, you make search fun.
21:11:29 <Cale> @google "school bus conversion ontario"
21:11:32 <lambdabot> http://www.eng.tau.ac.il/
21:11:32 <lambdabot> Title: Faculty of Engineering - Tel Aviv University - הפקולטה להנדסה או ...
21:12:09 <SamB_XP> lambdabot: what's with all the moonspeak?!?!?
21:12:37 <Cale> It didn't do the UTF-8 decoding
21:13:08 <grok> -- is the comment characters?
21:13:19 <aavogt> what does that have to do with ontario?
21:13:28 <aavogt> grok: yes
21:13:29 <SamB_XP> > 1 -- well it sure seems likely, doesn't it?"
21:13:30 <lambdabot>   1
21:13:32 <jmcarthur> > 5 :: Nat  -- huh?
21:13:34 <lambdabot>   No instance for (GHC.Num.Num L.Nat)
21:13:34 <lambdabot>    arising from the literal `5' at <int...
21:13:45 <aavogt> > 5 + {- or these -} 2
21:13:46 <lambdabot>   7
21:13:52 <jmcarthur> why would we have a Nat type with no Num instance?
21:14:14 <Cale> aavogt: Absolutely nothing.
21:14:34 <SamB_XP> > (:[ {- Aaaahh! Help! -} ])
21:14:35 <lambdabot>   {()->[()]}
21:14:40 <aavogt> haha
21:14:43 <Cale> aavogt: Except that they have a bunch of random garbage links on that page (viewing with a text browser makes it obvious)
21:15:44 <Cale> Including such gems as "medical school pickup lines", "free online medical courses with certificate", and "basketball high hoop school texas"
21:16:13 <aavogt> I see
21:16:20 <grok> is there a method to go through a list, find a number, and remove that number from the list?
21:16:24 <aavogt> that's pretty useless
21:16:28 <aavogt> @hoogle delete
21:16:28 <lambdabot> Data.HashTable delete :: HashTable key val -> key -> IO ()
21:16:29 <lambdabot> Data.IntMap delete :: Key -> IntMap a -> IntMap a
21:16:29 <lambdabot> Data.IntSet delete :: Int -> IntSet -> IntSet
21:16:41 <aavogt> > delete 'l' "hello"
21:16:43 <lambdabot>   "helo"
21:17:13 <aavogt> this works for lists of numbers too (strings are lists of characters)
21:17:32 <grok> thanks.
21:17:52 <aavogt> it isn't terribly efficient since you have to copy all the list elements you pass through
21:17:57 <kmc> @pl \(x,y) -> (y,x)
21:17:58 <lambdabot> uncurry (flip (,))
21:18:14 <grok> i'm not concerned with efficiency at this point.
21:18:17 <aavogt> up to when you find an element you want to delete
21:18:31 <pastorn> how smart is ghc?
21:18:41 <Axman6> @unpl uncurry (flip (,))
21:18:41 <lambdabot> uncurry (\ b c -> (,) c b)
21:18:42 <pastorn> will it optimize (sum . map (+1))
21:18:42 <aavogt> smarter than I am
21:18:59 <aavogt> look at core, pastorn
21:18:59 <Cale> pastorn: optimise in which way?
21:19:02 <SamB_XP> pastorn: optimize it how ?
21:19:09 <aavogt> it probably will fuse the traversals
21:19:10 <pastorn> to put the (+1) into a function composition together with the fold from sum?
21:19:11 <jmcarthur> pastorn: which sum, which map, over what type?
21:19:23 <pastorn> jmcarthur: just lists
21:19:24 <Cale> Obviously the list one, right?
21:19:33 <aavogt> so you don't have to write    foldl' (\acc n -> n+1+acc) 0
21:19:34 <Axman6> pastorn: turn it into \x -> length xs + sum xs?
21:19:43 <aavogt> @type foldl' (\acc n -> n+1+acc) 0
21:19:44 <lambdabot> forall a. (Num a) => [a] -> a
21:19:46 <jmcarthur> well, there's also the stream-fusion definitions i guess, but i bet the standard list functions get fused too
21:19:55 <SamB_XP> this is Haskell 2010... we don't have map :: Functor f => (a -> b) -> f a -> f b
21:19:56 <pastorn> @src sum
21:19:56 <lambdabot> sum = foldl (+) 0
21:20:21 <jmcarthur> SamB_XP: there are many functions called map besides Data.List.map
21:20:25 <Axman6> aavogt: i wonder if succ n + acc would be any better
21:20:38 <SamB_XP> jmcarthur: usually those get used qualified ...
21:20:45 <jmcarthur> not always
21:20:48 <aavogt> Data.Vector says that Enum instances are relatively slow
21:21:14 <jmcarthur> very often i have a module that doesn't use lists anywhere. i'd use another definition for map unqualified in that case
21:21:31 <jmcarthur> aavogt: where?
21:21:32 <aavogt> and hide the prelude?
21:21:59 <jmcarthur> aavogt: depending on other factors, too
21:22:00 <aavogt> http://hackage.haskell.org/packages/archive/vector/0.5/doc/html/Data-Vector.html#14
21:22:17 <jmcarthur> i've imported the prelude hiding particular functions plenty of times
21:22:47 <jmcarthur> aavogt: oh i didn't notice that the ones with the warnings used Enum and the others used Num
21:23:15 <ddarius> Uh-oh. "Celf"
21:23:21 <jmcarthur> aavogt: i always figured the difference was because with the slow ones it can't figure out in advance how big to allocate up front
21:23:25 <Cale> Celf?
21:24:13 <ddarius> http://www.logosphere.org/~celf/pmwiki/index.php
21:25:07 * Cale tries to guess what this is before clicking the link... an unholy merger of Self and C?
21:25:33 <Cale> ah, no, something a bit more reasonable-sounding than that :)
21:26:19 <jmcarthur> Cale: you guess was the same as mine
21:26:23 <jmcarthur> *your
21:29:40 <kmc> :t \z -> foldr (>>=) (return z)
21:29:41 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
21:29:41 <lambdabot>     Probable cause: `>>=' is applied to too many arguments
21:29:41 <lambdabot>     In the first argument of `foldr', namely `(>>=)'
21:29:58 <kmc> :t iterateM
21:29:59 <lambdabot> Not in scope: `iterateM'
21:30:30 <Cale> :t foldr (>=>) return
21:30:31 <lambdabot> forall (m :: * -> *) c. (Monad m) => [c -> m c] -> c -> m c
21:30:37 <Cale> :t foldr (<=<) return
21:30:38 <lambdabot> forall (m :: * -> *) c. (Monad m) => [c -> m c] -> c -> m c
21:31:00 <aavogt> you still need the replicate there
21:31:34 <aavogt> :t scanr (>=>) return
21:31:35 <lambdabot> forall (m :: * -> *) c. (Monad m) => [c -> m c] -> [c -> m c]
21:31:52 <aavogt> :t scanr (>=>) . return
21:31:53 <lambdabot> forall a (m :: * -> *) c. (Monad m) => m c -> [a -> m a] -> [a -> m c]
21:32:08 <aavogt> :t scanr (<=<) . return
21:32:09 <lambdabot> forall (m :: * -> *) c a. (Monad m) => m c -> [c -> m c] -> [a -> m c]
21:35:03 <edwardk> @pl \x -> ForAll $ \f -> forall (f x)
21:35:03 <lambdabot> ForAll . (forall .) . flip id
21:35:07 <edwardk> meh
21:36:51 <z1y> hi, how to join a list ?
21:37:02 <ddarius> SML/NJ or MLton?
21:37:10 <ddarius> z1y: Define "join"
21:37:17 <z1y> ["ab","cd] => "abcd"
21:37:21 <Cale> concat
21:37:23 <mm_freak> :t let iterateM f x0 = do x1 <- f x0; rest <- iterateM f x1; return (x0:rest) in iterateM
21:37:24 <lambdabot> forall t (m :: * -> *). (Monad m) => (t -> m t) -> t -> m [t]
21:37:27 <ddarius> > concat ["ab", "cd"]
21:37:29 <lambdabot>   "abcd"
21:37:31 <z1y> thank you
21:37:31 <aavogt> > join ["ab","cd"]
21:37:32 <lambdabot>   "abcd"
21:37:39 <Cale> (or, if you've imported Control.Monad, you can use join)
21:37:50 <Cale> Though join's type is actually more general
21:38:07 <Cale> > join (Just (Just 5))
21:38:10 <lambdabot>   Just 5
21:38:15 <mm_freak> you can't write iterateM with Applicative, can you?
21:38:43 <ddarius> mm_freak: No.
21:38:49 <aavogt> mm_freak: can you write iterateM with sequence?
21:39:04 <aavogt> @type  (sequence .) . iterate
21:39:05 <lambdabot> forall (m :: * -> *) a. (Monad m) => (m a -> m a) -> m a -> m [a]
21:39:12 <aavogt> @type  (sequence .) . iterate . return
21:39:14 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a -> m [a]
21:39:27 <mm_freak> aavogt: i don't think so
21:39:35 <mm_freak> you need the intermediary results
21:40:19 <aavogt> oh, it's   (a -> m a) -> a -> m [a]?
21:40:32 <mm_freak> well, at least that would make sense =)
21:40:37 <aavogt> yeah, then applicative wouldn't work
21:40:57 <mm_freak> is that related to your question?
21:41:14 <aavogt> whose?
21:41:20 <mm_freak> aavogt: yours
21:41:56 <aavogt> well if you can use sequence, then it is applicative
21:42:30 <aavogt> @type foldr (\x xs -> (:) <$> x <*> xs) (pure [])
21:42:31 <lambdabot> forall (f :: * -> *) a. (Applicative f) => [f a] -> f [a]
21:43:38 <alex404> How does cabal compile c code?
21:43:48 <mm_freak> ah, useful
21:43:54 <edwardk> alex404: it asks gcc nicely usually
21:44:31 <SamB_XP> edwardk: when does it not ask nicely?
21:44:50 <ddarius> SamB_XP: When it doesn't ask at all.
21:45:00 <edwardk> SamB_XP: when you tell it to ask someone else ;)
21:45:09 <SamB_XP> how do you do that?
21:45:25 <SamB_XP> can you do it from .cabal ?
21:45:38 <SamB_XP> I mean, the .cabal file for the package ?
21:45:42 <edwardk> cabal --with-PROD=PATH
21:45:47 <edwardk> er with-PROG
21:46:09 <edwardk> i don't think those can be loaded in a cabal file
21:46:22 <alex404> edwardk: So here's a pretty rediculous question. I'm developing a program which mixes c and haskell, and I like developing my haskell back and forth with ghci. So I'd like to be able to generate the c .o files I need, without the header files, as in general, I don't need them.
21:46:25 <mm_freak> how can i pass an Integer to a C function?
21:46:39 <alex404> mm_freak: FFI
21:46:40 <SamB_XP> I ask this only because someone asked that on stackoverflow a while back
21:46:58 <mm_freak> alex404: yes, but an Integer?
21:47:30 <ddarius> mm_freak: The "portable" way is to pass it as a StablePtr(?) and manipulate it by calling back into Haskell.
21:47:33 <alex404> mm_freak: How big are they getting?
21:47:42 <ddarius> alex404: He means the Integer type.
21:48:02 <mm_freak> alex404: big
21:48:22 <alex404> mm_freak: And c long ints aren't good enough?
21:48:26 <mm_freak> ddarius: can i somehow extract the actual value without going through haskell?
21:48:35 <ddarius> mm_freak: Not in general.
21:49:04 <mm_freak> alex404: this is hypothetical — let's say i'm implementing a large prime generator and i'd like to use mpn_* functions
21:49:16 <kmc> you can use fromIntegral to turn Integer into Word64
21:49:23 <kmc> it can of course overflow
21:49:34 <kmc> but Word64 is probably the biggest integral type your C compiler can deal with
21:49:43 <ddarius> mm_freak: By exploiting low-level knowledge and particular configurations, you could get the underlying (in those configurations) GMP representation.
21:49:52 <mm_freak> kmc: the compiler doesn't have to deal with the values
21:49:56 <mm_freak> just be able to get them at all
21:50:16 <ddarius> (for GHC)
21:50:24 <mm_freak> hmm
21:50:30 <alex404> mm_freak: Then I'd convert your data to some array type
21:50:35 <alex404> mm_freak: Like hexes
21:50:42 <mm_freak> the thing is, i've written a prime number generator and once i tried to rewrite it in haskell
21:50:44 <kmc> mm_freak, i'm confused, what do you want to do with this Integer on the C side?
21:51:02 <mm_freak> kmc: perform fast mpn_* stuff
21:51:41 <kmc> i have no idea what that is
21:51:41 <mm_freak> alex404: that's a good idea, but the conversions could slow things down a lot
21:52:04 <mm_freak> kmc: sorry, the mpn_* functions are from GMP…  they implement fast integer arithmetic at a very low level
21:52:49 <kmc> isn't that how GHC implements Integer anyway?
21:52:53 <kmc> at least unless you disable it
21:53:10 <systemfault> Yeah..
21:53:12 <pikhq> Yes. He wants to do very specific low-level tricks with it.
21:53:26 <kmc> i would look into how GHC implements Integer in order to see the best / fastest way to marshall between a GHC Integer and a GMP whatever-the-hell
21:53:33 <pikhq> There's *quite* a bit you can do with GMP if you're willing to work at it enough.
21:53:40 <alex404> What kmc said
21:53:54 <pikhq> Yeah, see how to get GHC's boxing out for a bit.
21:53:55 <mm_freak> GHC uses mpz_* and does it quite well, but the thing is that GMP implements a lot of extremely fast primitives, which are inaccessible in the haskell world
21:54:22 <z1y> (show) prints the escape char (\\n instead of \n). How to print '\n'?
21:54:27 <mm_freak> also mpz_* is one level higher than mpn_*, so you can speed things up a lot, if you go one level down
21:54:59 <ddarius> Integers versus naturals?
21:55:36 <kmc> z1y, "show" does not print anything
21:55:40 <kmc> it just converts a value to a string
21:55:45 <z1y> ah...
21:55:48 <kmc> when that value is already a string, it produces a Haskell string literal
21:56:02 <kmc> are you at the GHCi prompt?
21:56:08 <alex404> I've never used GMP before so this is more for my knowledge, but if it allows 'arbitrary precision', shouldn't there be data types which can handle Integer sized values?
21:56:23 <mm_freak> what is great about mpn_* is that they don't do any memory management, so my idea is that you can use them in C code linked to from haskell
21:56:33 <mm_freak> with mpz_* you'll run into trouble
21:56:57 <z1y> khm: no. In the first chapter of http://book.realworldhaskell.org , the author used (show)
21:57:29 <mm_freak> alex404: C data types or haskell data types?
21:57:44 <pikhq> alex404: In theory, yes. In practice, GMP's types are limited to approx. 2^32 bytes of size. ;)
21:58:07 <alex404> i've never studied numerics, but isn't that a bit silly?
21:58:12 <z1y> khc: no. In the first chapter of http://book.realworldhaskell.org , the author used (show). See http://book.realworldhaskell.org/read/getting-started.html#id577314
21:58:45 <mm_freak> pikhq: uhm, not on today's hardware =)
21:58:52 <kmc> z1y, to convert an Int (length (lines input)) to a string
21:58:58 <z1y> sorry, my keyboard... I mean kmc
21:59:06 <aavogt> z1y: interact does the printing to the screen
21:59:07 <kmc> the code then concatencates a newline on with (++ "\n")
21:59:08 <alex404> mm_freak: So what are the limitations of hte GMP data types?
21:59:13 <pikhq> mm_freak: That's hardcoded into GMP.
21:59:18 <mm_freak> alex404: your memory
21:59:21 <mm_freak> practically
21:59:28 <z1y> kmc: I see. thank you
21:59:33 <mm_freak> pikhq: even on 64 bit?
21:59:48 <pikhq> Yes.
21:59:56 <pikhq> Fairly silly, but yes.
21:59:57 <mm_freak> oh, ok
22:00:13 <alex404> So isn't your point moot now, mm_freak?
22:00:17 <alex404> your question, that is
22:00:29 <mm_freak> alex404: which question in particular?
22:00:35 <pikhq> alex404: ... No, you seem to have misunderstood it.
22:01:07 <alex404> Sorry for slowing you guys then ;) I find this stuff pretty interesting though.
22:01:13 <pikhq> He wants to access the underlying GMP value in an Integer so as to use GMP's more efficient, but more painful, low-level primitives.
22:01:15 <mm_freak> alex404: note that 2^32 bytes = numbers up to 256^(2^32)
22:01:23 <mm_freak> - 1 =)
22:02:05 <alex404> Oh BYTES
22:02:10 <z1y> i've written my first `tac` and `wc` program. Haskell kool :)
22:02:26 <mm_freak> that's a number with 10343311892 decimal digits =)
22:03:30 <alex404> Well, unless Integer in haskell is implemented as a continuous strip in memory (which it almost certianly isn't), you're probably going to have to do some processor heavy conversion somewhere, right?
22:03:30 <Axman6> > 256^(2^32)
22:03:36 <lambdabot>   mueval: ExitFailure 1
22:03:50 <mm_freak> > logBase 10 256 * 2^32
22:03:51 <lambdabot>   1.0343311891934566e10
22:03:58 <kmc> alex404, Integer in GHC's Haskell is implemented as a GMP integer
22:04:02 <kmc> unless you disable it when building GHC
22:04:03 <kmc> @src Integer
22:04:03 <lambdabot> data Integer = S# Int#
22:04:04 <lambdabot>              | J# Int# ByteArray#
22:04:11 <kmc> that ByteArray# is a continuous strip of memory
22:04:12 <alex404> kmc: Cool.
22:04:17 <mm_freak> alex404: it is implemented as a byte array in memory
22:04:22 <kmc> (that @src is of course GHC-dependent and not part of the spec)
22:04:32 <mm_freak> because that's what GMP understands, as kmc pointed out
22:05:09 <mm_freak> (though GMP understands a lot of memory formats)
22:05:20 <alex404> So shouldn't you just be able to pass some kind of pointer object, then?
22:05:45 <enferris> night, #haskell.
22:05:48 <mm_freak> probably…  that ByteArray# type sounds promising
22:06:10 <znutar> Are there any good lightweight graph libraries I should be looking at if I just want to do BFS and test if a digraph is strongly connected?
22:07:25 <znutar> lightweight as in "I don't have to write a lot of stuff besides giving it a list of nodes and edges"
22:07:47 <kevinulin> hey znutar
22:08:10 <kevinulin> i dont know the answer to yer question but we've met a few years ago :)
22:09:21 <znutar> oh hiya
22:18:48 <dons> znutar: fgl is ok for that.
22:31:57 <Gracenotes> Is it a sort of eventual goal to add a full-fledged bug reporting system to hackage? though email correspondence works, I'm wondering if it'd be overkill or not..
22:32:48 <ezyang> bug reporting on multi-developer projects is generally worth it.
22:32:55 <ezyang> I'm not too convinced for the single dev case though
22:33:32 <Gracenotes> yeah. and if the maintainer disappears off of the face of the earth, there's nothing you can do in either case :)
22:34:00 <ezyang> I kind of wonder what a combination github+hackage would look like.
22:34:08 <ezyang> kind of wild west, I think.
22:34:19 <Gracenotes> heh
22:34:40 <Gracenotes> it's still a package system, though! needed by cabalites worldwide.
22:35:39 <ezyang> right: you could automatically get a package setup by tagging something in your repo
22:35:52 <ezyang> and folks could usurp maintainership by forking packages willy nilly
22:36:40 <Gracenotes> as it is, repositories (where they exist) are all over the place. Not like that's a bad thing; some people like the choice.
22:57:11 <alex404> Can the FFI deal with structs?
22:58:40 <Gracenotes> it doesn't do spectacularly on its own, though c2hs/hsc2hs can be a great help
23:00:07 <alex404> Interesting... I haven't seen much use for hsc2hs, but maybe this is where it comes in handy
23:00:16 <Gracenotes> mostly, for structs, it does indexing for you, iirc
23:00:39 <alex404> Thanks for the tip
23:00:52 <kevinulin> is there some way to extend a module in a seperate file or access the hidden functions?
23:01:48 <Gracenotes> sure. ofc, beware word size differences and (possibly) endianness and the like
23:02:18 <ddarius> kevinulin: No sane ways.
23:02:30 <tensorpudding> Modules aren't first-class in Haskell.
23:02:50 <pastorn> shit...
23:02:58 <kevinulin> im just so unhappy with this situation and its the first one ive encountered with haskell
23:03:06 <pastorn> the haskell GL tutorials are messing with me... again
23:03:06 <kevinulin> i want to quickcheck hidden functions in a seperate file
23:03:13 <kevinulin> but i dont want to break the module into two
23:03:56 <MasseR> How do I set ghci vi mode?
23:04:01 <dancor> kevinulin: can you have a wrapper that only exposes the public funs?
23:04:03 <dancor> funcs
23:04:39 <dmwit> kevinulin: There's two workarounds I can think of off the top of my head.
23:04:50 <dancor> module Lol (lolPublic1, lolPublic2) where import Lol
23:04:50 <dmwit> kevinulin: One is to write the tests in the same module and export those.
23:04:59 <dancor> err: where import LolSecret
23:05:18 <dmwit> kevinulin: The other is to have two modules, one with the private details exported, and the other which imports the first and re-exports only the public details.
23:05:41 <dmwit> kevinulin: (Then make only the second module available in your package.)
23:06:12 <kevinulin> ya, i just dont like either, i want the test functions to not be a part of the package, so i can not distribute them if i chose not to (i dont know why i wouldnt, but i like the logical seperation)
23:06:23 <kevinulin> and the other requires writing the type defintions twice
23:06:34 <dmwit> Nonsense.
23:06:55 <kevinulin> both would be avoidable with a type of 'protected' export which ghc could identify to allow references withen the same compile
23:06:59 <kevinulin> but that doesnt exist
23:07:29 <Gracenotes> within the same compile..? that might get messy
23:07:52 <tensorpudding> You definitely want the package to not depend on quickcheck.
23:07:56 <kevinulin> im sure someone with a better grasp of the theory could come up with a better defintion, but that is the idea
23:08:34 <dancor> if you really want the tests in a separate package you could make a "private/internal" package and then "test" and "public" packages which uses them.  seems sort of crazy.
23:08:44 <kevinulin> ya
23:08:50 <Gracenotes> you could have an ad-hoc rule involving the module hierarchy for said protected access, but, .. why.
23:08:56 <dancor> i think it's good to have the tests close to the code being tested?
23:09:14 <dancor> like package separation seems too removed
23:09:25 <tensorpudding> Can you give conditional dependencies to cabal?
23:09:59 <tensorpudding> As in, say "if quickcheck is installed, build the test suite, else don't build the test suite"
23:10:00 <dancor> i could see not wanting to have to compile the tests for normal use of the library
23:10:23 <dmwit> tensorpudding: Sort of.
23:10:40 <Gracenotes> this is also where that gsoc cabal test project might come in, if someone gets around to doing it
23:10:43 <dmwit> tensorpudding: You can add a "testing" flag which defaults to on, and when the flag is on, the package will depend on quickcheck.
23:10:53 <dmwit> If it turns out quickcheck isn't installed, it will try turning the flag off.
23:10:56 <dmwit> err...
23:11:06 <Sgeo> Crap, thanks for reminding me, I want to get involved with GSoC
23:11:17 <dmwit> If it turns out it can't satisfy the dependencies, it will try turning the flag off, which I guess is a little different.
23:11:25 <Gracenotes> Sgeo: applications are due this friday. don't miss it :)
23:11:49 <Gracenotes> I'm kind of interested in doing something hackage-related..
23:12:22 <Sgeo> I'd probably end up doing something Python related, even though I find Haskell to be quite interesting, since I'm familiar with Python
23:13:08 <Sgeo> Do I have to find a project by the 9th, or be registered by the 9th?
23:13:35 <Gracenotes> student application submitted by the 9th. So all of the above, I guess.
23:15:18 <Gracenotes> applications differ from organization to organization. interestingly, Dojo Toolkit is having you build a webpage that displays a particular dataset in an intuitive way. *plus* a project application.
23:16:53 <Sgeo> I don't even know what any of the projects are
23:21:38 <Gracenotes> Sgeo: organizations are encouraged to come up with lists.. at least, most of them do. http://socghop.appspot.com/gsoc/program/accepted_orgs/google/gsoc2010
23:22:43 * Sgeo sees an "OSGeo" on there
23:23:28 <Sgeo> Haskell.org has some stuff
23:24:15 <Sgeo> Probably shouldn't
23:25:33 * Sgeo could try Facebook stuff
23:25:44 <Sgeo> Can I apply to more than one organization?
23:25:49 <Sgeo> In case one doesn't accept me?
23:25:51 <Adamant> I don't know who at Google thought making a list that's loaded via Javascript was a brilliant idea
23:26:22 <Jafet> Adamant, it's a filter
23:26:45 <tensorpudding> The Google Chrome download link requires a browser with Javascript, which I found both ironic and obnoxious
23:26:56 <dmwit> Adamant: When taken at face value, your statement is not very surprising.
23:27:18 <dmwit> I should be very surprised indeed if you knew who at Google thought that Javascript was brilliant for this. =)
23:27:54 <tensorpudding> I had to download a browser...so that I could download a browser
23:28:08 <Adamant> dmwit: why would that be :)
23:33:57 <Adamant> (kind of trying to figure out if you're pointing out that most of us don't know who's responsible for what at Random Org X, or if you're just calling me a dope, or if you work for The All-Seeing Cloud :P)
23:35:06 <Adamant> and I guess that's some of kind of Google Docs spreadsheet stuff or derived, actually, but taking 6 seconds to load the whole thing every time is still annoying :P
23:43:27 <Cale> Adamant: I think he just meant the first, that it's not surprising that you don't know this fact.
23:43:58 <Adamant> Cale: it would be fine any of the three ways :P
23:44:40 <kevinulin> can i do circular module references?
23:44:49 <kevinulin> 'imports' rather
23:45:20 <Cale> kevinulin: You're supposed to be able to according to the standard, but in practice, this is one place where the implementations tend to make you jump through hoops and decide whether you *really* want that.
23:46:47 <Cale> kevinulin: http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
23:46:57 <kevinulin> well instead, is it possible to export types from an imported module without making a new type that references the imported type?
23:47:30 <Cale> Oh, sure.
23:47:56 <Cale> If you don't have an explicit export list, they should get exported by default
23:48:01 <Cale> If you do, then you just list them
23:48:09 <kevinulin> so i can do module Example (Example.Pie)
23:48:29 <Cale> You don't even have to qualify it
23:48:33 <Cale> module Example (Pie)
23:48:43 <Cale> and if you want to export the constructors:
23:48:49 <Cale> module Example (Pie(..))
23:49:10 <Cale> You could also list the constructors of the type in place of the two dots
23:49:16 <kevinulin> i mean, module Example (Example.Pie.Slice) where import Example.Pie
23:49:32 <kevinulin> will all code that imports Example, think that Slice is a type in Example?
23:49:52 <Cale> yes
23:50:03 <kevinulin> alright, that saves me some headache, thanks
23:50:29 <Cale> In fact, there's no way to export things with the qualified names
23:51:05 <Cale> When your module exports things, their origins are lost, and everything is just as if it was defined in that same module.
23:51:47 <Cale> (this can be a pain sometimes)
23:52:28 <kmc> @pl \f x -> x ++ concatMap f x
23:52:28 <lambdabot> ap (++) . (=<<)
23:54:13 <kevinulin> this whole idea of splitting the module into two parts to allow quickcheck full access to all the functions but the library to only expose a handful of functions is causing no end of problems, including breaking documentation
23:54:27 <kevinulin> its just such an ugly solution for such an otherwise beautiful language
23:54:43 <Cale> It's a bit of a problem that a lot of packages seem to have.
23:55:14 <Jafet> > let subseqs xs = let s _ [] = []; s xs (y:ys) = let ms = map (++[y]) xs in ms ++ s (xs ++ ms) ys in [] : s [[]] xs in subseqs primes
23:55:15 <lambdabot>   [[],[2],[3],[2,3],[5],[2,5],[3,5],[2,3,5],[7],[2,7],[3,7],[2,3,7],[5,7],[2,...
23:55:17 <kmc> @pl \f x -> x ++ map f x
23:55:17 <lambdabot> ap (++) . map
23:55:19 <Cale> One option I suppose would be just to use, say, the C preprocessor to turn on and off the quickcheck tests and dependencies.
23:55:27 <Cale> But that's not really a great answer.
23:55:51 <kevinulin> ya there isnt one, really either you need to be able to define multiple modules, or you need to expose methods to different degrees
23:56:01 <kevinulin> i mean multiple modules in the same file
23:56:35 <kevinulin> in my humble opinion
