00:18:32 <pastorn> if i want to make my IRC bot into a multi-network bot with shared state, i should use STM, right?
00:19:02 <pastorn> or is that a task for just MVars?
00:20:52 <koeien37> that is a broad question. MVars are OK, if you use just one of them
00:20:57 <koeien37> otherwise it gets tricky quite easily
00:21:43 <pastorn> right now i have ReaderT Handle (StateT BotState IO)
00:22:06 <pastorn> so i can only have one network...
00:22:45 <pastorn> (i would need my program to wait on hGetLine on multiple handles at the same time)
00:22:56 <pastorn> is STM a good way to do that?
00:23:54 <Davse_Bamse> pastorn: maybe you should take a look at the actor paradigme... that sound like an actor setup :-)
00:24:12 <Davse_Bamse> then the shared state is a another actor which all other actors talk to
00:24:13 <pastorn> Davse_Bamse: you've got any cool links for that?
00:25:53 <Davse_Bamse> pastorn: well.. erlang.org but that is not haskell
00:26:01 <pastorn> Davse_Bamse: :(
00:26:03 <Davse_Bamse> but it is still functional
00:26:40 <Davse_Bamse> http://lstephen.wordpress.com/2007/09/08/the-actors-model-and-haskell/ <-- looks like someone did implement it in haskell
00:27:27 <Davse_Bamse> there might even be better implementations, but it is great for getting the hang of the actor model
00:27:42 <pastorn> Davse_Bamse: all using STM :)
00:27:56 <Davse_Bamse> yes :-)
00:28:16 <Davse_Bamse> but i am more of an actor dude than a stm dude.. i have to read a bit more about the stm
00:28:36 <Davse_Bamse> i have done a lot of erlang, and not that much haskell (yet)
00:28:42 <pastorn> heh, ok :)
00:29:24 <HeMan> I've tried both libghc6-parsec2-dev and libghc6-parsec3-dev in Ubuntu 10.04 but I can't compile my simple program where I only import the Parsec module
00:29:44 <HeMan> I get "(.text+0x1bd): undefined reference to `__stginit_parseczm2zi1zi0zi1_TextziParserCombinatorsziParsec_'" with parsec2
00:30:03 <HeMan> and I get "(.text+0x1bd): undefined reference to `__stginit_parseczm3zi0zi1_TextziParserCombinatorsziParsec_'" with parsec3
00:30:16 <pastorn> HeMan: dude, that's cool
00:30:25 <HeMan> is this something I should report to Ubuntu?
00:30:54 <pastorn> HeMan: seems like ghc on ubuntu is still pretty borked
00:31:10 <pastorn> HeMan: install ghc manually from the binary blob on
00:31:12 <pastorn> @where ghc
00:31:13 <lambdabot> http://haskell.org/ghc
00:31:42 <pastorn> and then manually install Cabal and cabal-install (download them from hackage)
00:31:50 <koeien37> HeMan: add --make ?
00:32:00 <HeMan> should I download and compile haskell by hand?
00:32:11 <koeien37> HeMan: no. first try ghc --make YourProgram.hs
00:32:13 <pastorn> HeMan: no, that is actually pre-compiled
00:32:18 <HeMan> koeien37: worked!
00:32:33 <koeien37> automagic dependency chasing
00:32:38 <pastorn> HeMan: but you can't use parsec in ghci?
00:32:45 <HeMan> koeien37: thanks!
00:33:14 <pastorn> koeien37: what was that voodoo magic?
00:33:17 <HeMan> pastorn: well, I'm a haskell-n00b and tried some cut'n'pastin
00:33:46 <koeien37> pastorn: this comes up multiple times per day :)
00:33:56 <koeien37> I regard this as a ghc bug personally
00:34:03 <HeMan> pastorn: I'll try with ghci now
00:34:40 <pastorn> HeMan: when did you get that error?
00:35:08 <HeMan> pastorn: when I tried to compile my program, ghc mytest.hs
00:36:04 <HeMan> pastorn: import Text.ParserCombinators.Parsec in ghci worked
00:37:29 <HeMan> pastorn: anything else I should do to test if it works in ghci?
00:37:51 <pastorn> HeMan: :m +Control.Monad
00:38:13 <pastorn> you might get a cool "mtl or monad-fd"-thingy
00:38:34 <ivanm> HeMan: use "ghc --make mytest.hs" if it's a program
00:38:53 <Gracenotes> oh, GSOC student ranking deadline tomorrow
00:39:15 <HeMan> ivanm: yes, just found out!
00:40:41 <HeMan> pastorn: :m +Control.Monad worked
00:41:01 <pastorn> nice
00:41:32 <pastorn> HeMan: what version is in 10.04? ($ ghc --version)
00:42:01 <HeMan> pastorn: The Glorious Glasgow Haskell Compilation System, version 6.12.1
00:44:19 <HeMan> should I use parsec2 or parsec3?
00:44:25 <pastorn> parsec3
00:44:27 <koeien37> 3
00:54:55 <pastorn> http://en.wikibooks.org/wiki/Haskell/Continuation_passing_style <-- this is really good :)
00:55:47 <koeien37> CPS makes my head hurt
00:55:58 <pastorn> koeien37: you should read that
00:56:05 <pastorn> it's really well written
00:59:34 <sannysanoff> hello, gentlemen! i make use of undefined-s in my program, and now i missed something, and I want to know which undefined triggered program exit. How to do it best way?
00:59:51 <koeien37> replace them by error "Here"
00:59:55 <koeien37> and error "There"
01:00:54 <sannysanoff> koeien, genius. thanks
01:02:40 <pastorn> sannysanoff: if they are actual errors you possibly can recover from, use 'Maybe a' or 'Either SomeErrorTypeLikeStringOrWhatHaveYou a' instead
01:03:37 <sannysanoff> pastorn, no, that is different problem.
01:47:31 <rfh> http://pastebin.com/ekexX05Q
01:50:39 <fasta> rfh, what is the difference between a newtype and a data declaration is essentially what is being asked. Then you use that property to construct a function which behaves differently by exploiting that property.
01:53:34 <rfh> fasta: strictness
01:53:56 <fasta> rfh, if you write down in a sentence exactly what it means it will be trivial to solve.
01:54:14 <quicksilver> well, it's trivial to solve if you know the answer and if you don't it's impossible.
01:54:32 <quicksilver> if you know how to use 'seq' to exhibit strictness behaviour then you can do it
01:54:38 <fasta> rfh, I have the impression you believe that newtype Foo = Foo Int == data Foo = Foo !Int
01:54:41 <quicksilver> if you don't, then you will never do it until someone explains it to you.
01:54:55 <fasta> rfh, if you believe that, you won't ever find the answer.
01:55:32 <rfh> fasta: i believe that MkJane undefined is an element of Jane
01:56:26 <rfh> fasta: but MkDick is isomorphic, MkDick undefined -> not element of Dick
01:56:43 <rfh> MkDick behaves like an Int
01:57:27 <fasta> rfh, so, what would happen if you would pattern match?
01:59:00 <rfh> fasta: thanks, thats it
02:10:55 <jlouis> Axman6: :)
02:11:02 <Axman6> o/ jlouis
02:11:17 <jlouis> Axman6: There some attoparsec code in a branch now :)
02:11:30 <Axman6> nice :)
02:12:10 <ivanm> hey Axman6
02:12:20 <jlouis> Axman6: New target is network-bytestring now :)
02:12:24 <Axman6> i was going to try using it, but thought that sticking to a package that defines an encoder and decoder would be a good idea (the code gets more symmetry)
02:12:35 <Axman6> nice, that would be very handy
02:12:46 <Axman6> (it above being attoparsec)
02:13:25 <jlouis> Axman6: actually, 22% of all allocation happens in the encoder now :/
02:13:32 <Cale> haha, awesome, this paper is using Fraktur in the midst of Haskell code to distinguish between a fixed point type and its underlying functor
02:13:33 <Axman6> :(
02:13:46 <Axman6> jlouis: well, how much allocation is happening?
02:14:10 <jlouis> to much for the speed-obsessed jlouis :)
02:15:06 <jlouis> it is much better after I plugged a large number of memleaks, but the current culprits are allocation because data is copied too much
02:15:22 <Axman6> hmm
02:15:38 <jlouis> which is some of the reason for network-bytestring
02:16:24 <Axman6> did we ever decide on whether to stick to strict or lazy bytestrings?
02:17:04 <jlouis> Axman6: most of them are strict now. The only place where lazy byte strings are used is where the ability to chunk up several is beneficial
02:17:31 <Axman6> ok
02:17:39 <Axman6> maybe lazy might be a better default
02:17:43 <jlouis> concats on lazy bytestrings are much cheaper in essence
02:18:13 <Axman6> yeah
02:18:44 <dcoutts> lazy is usually better where you've got long input and output streams, strict is often better when you know you're working with medium size chunks (and not having to concatenate)
02:18:45 <lambdabot> dcoutts: You have 2 new messages. '/msg lambdabot @messages' to read them.
02:19:06 <jlouis> for the outgoing path, i'd like to serve it a Lazy or a list of strict BS's and then use network-bytestrings vectored io
02:20:07 <jlouis> dcoutts: usually, we break off something like 1-4 kilobytes from the socket
02:30:58 <deteego> hey, I just wanted to ask is there a library in Haskell for doing flag based enumeration
02:32:38 <deteego> as in assigning sucessful enumerations with 0x0,0x1,0x2,0x4 etc so you can add them as flags
02:33:12 <Axman6> why would you need to? that's what Enum is for no?
02:33:49 <deteego> well the point of this system is you can add enums (and then retrieve the Enum's you added), they are often used as flags
02:34:06 <deteego> in haskell Enums just map from [0..n] where n is the number of enums
02:34:08 <quicksilver> no, it's exactly not what Enum does.
02:34:11 <Axman6> > let enumToBit x = 2 ^ fromEnum x in map enumToBit [0..5]
02:34:12 <lambdabot>   [1,2,4,8,16,32]
02:34:17 <quicksilver> Enum is for alternatives.
02:34:25 <quicksilver> deteego wants an efficient way to manage sits.
02:34:26 <quicksilver> sets.
02:34:37 <quicksilver> deteego: to be honest, I think such bit-fiddling is a bit 1970s.
02:34:46 <quicksilver> deteego: I'd use a Data.Set of an ADT
02:34:57 <quicksilver> deteego: (and if necessary convert to a bitmask representation for read/write/network etc)
02:35:13 <deteego> quicksilver: ok thx
02:35:21 <deteego> still getting used to how haskell does things =D
02:35:34 <quicksilver> an idiomatic way to manage bitfields would be cute
02:35:41 <quicksilver> but I think it might be optimising in the wrong place :)
02:35:43 <Axman6> of you're writing 0xsomething, you're probably doing it wrong :P
02:35:53 <Axman6> if*
02:36:01 <deteego> Axman6: nah I just used that as an example
02:36:09 <deteego> because thats how you would do it in C etc etc
02:37:25 <deteego> quicksilver: isn't Data.Set a bit over the top for something I want to do?
02:38:54 <Axman6> no
02:39:09 <Axman6> a list is probably just as good, with a little less overhead
02:41:07 <deteego> yeah I would probably stick with what you suggested
02:41:08 <quicksilver> deteego: why is it over the top? Isn't it *exactly* what you want to do?
02:41:15 <quicksilver> you want to manage a set of options.
02:41:36 <quicksilver> why use a clumsy inappropriate data type when there is an elegant data type which is exactly what you want?
02:41:57 <quicksilver> sure, a list has less overhead, for very small lists, but it has the wrong API
02:42:51 <deteego> well efficency does matter in this case, and the list is going to be small
02:42:56 <deteego> (there are only 5 options)
02:43:36 <deteego> I would probably just make another Enum class which maps to ^2 that works the exact same way current Enum does
02:43:39 <Axman6> then a list would be fine
02:43:48 <deteego> if I want to be "nice"
02:43:52 <Axman6> though a Set might be a little easier to work with
02:43:58 <Axman6> anyway, speed will not be a problem
02:48:30 <Axman6> jlouis: any plans to make a nice wrapper around network-bytestring?
02:52:16 <deteego> in regards to overhead (and also using the assumption that GHC does everything at compile time) there wouldn't be a difference using a "wrapper" for a class vs cloning it
02:53:47 <Axman6> huh?
02:54:35 <deteego> I just want to make an EnumFlag class which is basically a wrapper of Enum class
02:54:42 <deteego> but does what I said above
02:56:05 <deteego> would there be overhead in just calling Enum when required or should I just clone it?
02:57:19 <Axman6> @src Enum
02:57:19 <lambdabot> class  Enum a   where
02:57:19 <lambdabot>     succ                     :: a -> a
02:57:19 <lambdabot>     pred                     :: a -> a
02:57:19 <lambdabot>     toEnum                   :: Int -> a
02:57:19 <lambdabot>     fromEnum                 :: a -> Int
02:57:21 <lambdabot> [3 @more lines]
02:57:38 <Axman6> > toEnum 0 :: Maybe Int
02:57:39 <lambdabot>   No instance for (GHC.Enum.Enum (Data.Maybe.Maybe GHC.Types.Int))
02:57:39 <lambdabot>    arising...
02:57:49 <Axman6> > toEnum 0 :: Double
02:57:50 <lambdabot>   0.0
02:57:57 <Axman6> @instances Enum
02:57:58 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
02:57:58 <jlouis> Axman6: no, not really
02:59:55 <jlouis> deteego: I would not worry too much about performance in the first place.
03:00:45 <Axman6> deteego: you know the premature optimisation quote right?
03:01:07 <Axman6> doing what you're after will actually involve your program doing more work, not less
03:01:39 <jlouis> This is not SPARTA, but rather LAZY, so usually performance problems end up around the laziness
03:03:49 <ivanm> Axman6: the premature optimisation quote is misquoted
03:04:24 <Axman6> @remember ivanm Axman6: the premature optimisation quote is misquothed
03:04:24 <lambdabot> Okay.
03:04:29 <Axman6> you're misquoted
03:04:30 <Axman6> :P
03:04:43 <ivanm> Axman6: it's misquoted, not misquothed
03:04:45 <ivanm> get it right!
03:04:53 <ivanm> geez, you can't even copy-paste properly...
03:05:05 <Axman6> bah, you missed the joke obviously ;)
03:05:13 <ivanm> obviously
03:05:34 <jlouis> "We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil. Yet we should not pass up our opportunities in that critical 3%."
03:07:09 <ivanm> he said he never said that
03:07:30 <ivanm> also, it was referring to really low level bit bashing optimisation IIRC
03:07:41 <ivanm> i.e. you should still profile + optimise
03:07:57 <ivanm> but don't optimise something that only takes up 1% of the runtime
03:07:57 <deteego> well im making a game in haskell
03:07:59 <deteego> as a hobby
03:08:11 <deteego> and I have little idea how GHC optimizes stuff
03:08:17 <deteego> in any case, this is pointless
03:08:27 <deteego> because I could just use a list of Enum's for the options
03:08:34 <ivanm> deteego: use -O2 -funbox-strict-fields and you should be right
03:08:43 <deteego> too god damn used to languages like C :(
03:08:56 <ivanm> picking different algorithms + data structures has nothing to do with GHC ;-)
03:09:05 <ivanm> e.g. vector outperforms Data.Array
03:09:19 <Axman6> ivanm: -funbox-sgtrict-fields requires you to be using strict feilds
03:09:33 <pastorn> -funbox-strict-fields <-- what does this do?
03:09:46 * ivanm forgets, he just remembers someone (dons?) saying that it helps
03:09:57 <deteego> it unbox's data types I believe
03:10:03 <deteego> which allows GHC to better optimize them
03:10:14 <ivanm> I think it replaces Int with Int#, etc. in some situations
03:10:16 <pastorn> "here, take this voodoo magic compiler optimization. you will need it"
03:10:22 <ivanm> Axman6: using IRC obviously doesn't require you to be able to spell though :p
03:10:24 <Axman6> if you have data V = V !Double !Double !Double, that will basically store a V as an array of Doubles, rather than pointers to Doubles
03:11:51 <Axman6> data V = V Double Double Double ~= struct V { double *x, *y, *z; }, data V = V !Double !Double !Double ~= struct V { double[3] elems;}
03:11:54 <Axman6> sort of
03:12:03 <Axman6> it's not that simple, but that's the gist of it
03:12:26 <deteego> whats the alternative to strict data constructors/
03:12:29 <deteego> *?
03:12:39 <Axman6> non strict, which is the default
03:13:11 <ivanm> oh, right, I was using !Int, etc. for counters for some stuff
03:13:54 <tibbe> (Joining in late.) If you use strict constructors you can remove an indirection by passing -funbox-strict-fields to GHC or you could add an UNPACK pragma.
03:14:04 <deteego> is there a wiki article or something along those lines for non strict data constructors
03:14:20 <deteego> can't seem to find it
03:14:23 <Axman6> deteego: how long have you been using haskell?
03:14:31 <tibbe> deteego: http://www.haskell.org/haskellwiki/Performance/Data_types
03:15:51 <deteego> tibbe: thank you
03:16:02 <deteego> Axman6: I have been on and off
03:16:07 <deteego> with haskeel for some time
03:16:11 <tibbe> deteego: You're welcome.
03:17:47 <tibbe> deteego: The caveats on that page are a bit strong. It's almost always worth unpacking simple data types like Ints; I routinely do that for my data types.
03:18:54 <deteego> tibbe: yep, unless you revaluate that data type a lot of times
03:18:57 <Katiebug> can anyone tell me what $! does in Haskell?
03:19:09 <fasta> @src ($!)
03:19:09 <lambdabot> f $! x = x `seq` f x
03:19:24 <Katiebug> @src (seq)
03:19:24 <lambdabot> Source not found. Wrong!  You cheating scum!
03:19:31 <Katiebug> :o
03:19:39 <pastorn> Katiebug: the same as $, but for paralellish stuff
03:19:45 <fasta> @src seq
03:19:45 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
03:19:46 <ivanm> pastorn: not at all
03:19:49 <pastorn> @src ($)
03:19:49 <lambdabot> f $ x = f x
03:20:00 <ivanm> Katiebug: x `seq` y evaluates x to the outermost constructor before evaluating y
03:20:00 <Katiebug> yeah I understand what $ does
03:20:07 <ivanm> it's only useful if y actually uses x
03:20:07 <pastorn> maybe not paralellish stuff, ut it forces x to be evaluated
03:20:09 <fasta> Katiebug, basically, it reduces x to WHNF before calling f.
03:20:12 <deteego> tibbe: one last thing, does this mean if performance is an issue for me
03:20:16 <Katiebug> ok
03:20:23 <ivanm> note that (f x) `seq` (g $ f x) is useless
03:20:23 <Katiebug> so
03:20:28 <mreh> interesting... the "bio" package has impossible dependencies
03:20:30 <ivanm> since it doesn't "remember" evaluating (f x)
03:20:35 <Katiebug> how is that different from $ then?
03:20:37 <ivanm> mreh: oh? this is on hackage?
03:20:44 <deteego> when I have a data constructor with multiple fields, should I just put it into a tuple so it can be unboxed
03:20:51 <deteego> or would GHC do that automatically?
03:20:52 <ivanm> Katiebug: $ doesn't do any forced evaluation
03:20:54 <pastorn> ivanm: it doesn't?
03:21:00 <ivanm> pastorn: no
03:21:06 <ivanm> why should it?
03:21:11 <pastorn> ivanm: how do you make it remember?
03:21:12 <mreh> ivanm: oh, they're not impossible, cabal doesn't know how to resolve the dependency
03:21:30 <ivanm> pastorn: oh, the remember comment
03:21:38 <pastorn> wut?
03:21:39 <ivanm> pastorn: let fx = f x in fx `seq` (g fx)
03:21:39 <dcoutts> mreh: you can usually help it by supplying some constraints
03:21:51 <pastorn> ivanm: ah, cool
03:21:57 <ivanm> pastorn: I thought you were responding to "ivanm> Katiebug: $ doesn't do any forced evaluation"
03:22:02 <mreh> dcoutts: Having multiple versions of the same package is acceptable to cabal?
03:22:17 <dcoutts> mreh: yes, but not in the same install plan
03:22:41 <mreh> dcoutts: what do you mean exactly?
03:23:00 <ivanm> mreh: you can't have the one package transitively depend on two versions of a pacakge
03:23:14 <ivanm> e.g. if foo depends on parsec-2 and bar depends on parsec-3, then baz can't use both foo and bar
03:23:14 <dcoutts> mreh: if I do cabal install A B, and they depend on C, then cabal will pick the same version of C or it will fail. It will never pick different versions of C.
03:23:29 <dcoutts> mreh: however it's perfectly ok to have multiple versions of C installed
03:23:45 <Katiebug> so
03:23:53 <Katiebug> basically $! is a strict version of $?
03:24:02 <pastorn> Katiebug: you could say that
03:24:04 <ivanm> Katiebug: semi-strict
03:24:10 <ivanm> it only evaluates to the first constructor
03:24:15 <mreh> dcoutts: i understand
03:24:34 <fasta> Katiebug, let x = 1 + 2 in x `seq` (f x) means that x is evaluated to 3 before f is called.
03:24:35 <ivanm> e.g. "let xs = [1..] in head $! xs" won't cause the entire infinite list to be evaluated
03:24:45 <ivanm> Katiebug: ^^
03:24:56 <jlouis> tibbe: by the way, the code is now set up for network-bytestringification. I'll let you know how that goes
03:25:09 <fasta> Katiebug, what ivanm says is just an example of evaluating to WHNF.
03:25:12 <mreh> good old --preference flags
03:25:12 <dcoutts> mreh: the assumption is that you want to use A and B together, eg have something depend on it. In that case you need consistent deps (at least under conservative assumptions you need consistent deps).
03:25:35 <fasta> Katiebug, WHNF is the least amount of evaluation you have to do to prove non-bottomness.
03:26:03 <Katiebug> okay
03:26:04 <Katiebug> so
03:26:11 <mreh> dcoutts: does cabal know how to build multiple versions of the same package then? for example in the instance that one is required to be built against another module version in another build plan?
03:26:15 <Katiebug> in practical terms then
03:26:16 <ivanm> well, evaluate to first constructor
03:26:21 <Katiebug> how does it differ from $?
03:26:28 <fasta> Katiebug, so, for [1..], which is (1:2:...), we clearly have that there is at least one element (1: <something>)
03:26:30 <ivanm> Katiebug: sometimes it makes things a bit more efficient
03:26:45 <dcoutts> mreh: you can build multiple versions using separate build plans.
03:26:47 <fasta> Katiebug, and (1:<something>) is clearly not equal to undefined.
03:26:50 <ivanm> Katiebug: and when dealing with lazy IO, you sometimes want to make sure it gets at least part of the String it pulls out from something
03:27:02 <dcoutts> mreh: you cannot have one package depending directly or indirectly on multiple versions of another package
03:27:18 <Axman6> :t fix ($!)
03:27:19 <lambdabot> forall a b. a -> b
03:27:21 <pastorn> > take 5 $! [1..]
03:27:22 <lambdabot>   [1,2,3,4,5]
03:27:25 <Axman6> > fix ($!)
03:27:28 <pastorn> why does that work?
03:27:28 <Katiebug> so f $! x evaluates x to WHNF before evaluating f
03:27:31 <lambdabot>   mueval: ExitFailure 1
03:27:38 <Axman6> > fix ($)
03:27:40 <Katiebug> f $ x also evaluates x before evaluating f
03:27:43 <lambdabot>   mueval: ExitFailure 1
03:27:49 <Katiebug> so how does $ evaluate it then?
03:27:59 <Axman6> Katiebug: ($) doesn't evaluate x i don't think
03:28:15 <jlouis> A good strictness example is in combinatorrent: I genereate some statistics on the way which is generally only printed when the program finishes or when they are requested while running. As such, they are not strict in the result of the program. But I don't want those thunks lying around
03:28:20 <ivanm> Katiebug: $ doesn't do any evaluations
03:28:31 <ivanm> it's just there to be able to define a low-level fixity for function application
03:28:33 <ivanm> @src ($)
03:28:34 <lambdabot> f $ x = f x
03:28:35 <mreh> dcoutts: can you have multiple installs of the same version number?
03:28:37 <ivanm> ^^ doesn't do anything
03:28:46 <Katiebug> but if I call the function f $ x it has to evaluate x before evaluating f
03:28:50 <jlouis> mreh: for different compilers, yes
03:28:58 <ivanm> Katiebug: right, but who knows if the result from f is ever used
03:28:58 <jlouis> mreh: for the same compiler: dunno
03:29:06 <mreh> I'm thinking about cabal
03:29:08 <ivanm> f $! x means at least part of x is evaluated
03:29:11 <danderson> Katiebug: wouldn't that be $! ?
03:29:15 <ivanm> $ is usually used to end a chain of function compositions or to do something like this:
03:29:25 <ivanm> > map ($2) [succ, pred, (*3)]
03:29:26 <lambdabot>   [3,1,6]
03:29:41 <danderson> f $ x is just a nicer form of parenthesis to hint at evaluation order
03:29:43 <pastorn> can someone give an example of when $ and $! yields different results?
03:29:52 <mreh> pastorn: they can't
03:30:02 <Katiebug> so
03:30:07 <mreh> unless they're applied to different arguments
03:30:16 <ivanm> preflex: seen box
03:30:17 <preflex>  Sorry, I haven't seen box
03:30:19 <mreh> this is the principle of referential transparency, isn't it?
03:30:23 <danderson> they won't yield different results, but may have different runtime characteristics
03:30:25 <Katiebug> at compiletime, with f $! x, x gets evaluated to WHNF
03:30:27 <ivanm> pastorn: they shouldn't unless an undefined pops up
03:30:36 <Katiebug> ?
03:30:39 <abberaman> > 5 % 2
03:30:39 <mreh> $ $! are about lazyness and efficiency
03:30:40 <lambdabot>   5 % 2
03:30:40 <ivanm> pastorn: $! sometimes just yields performance enhancements
03:30:41 <pastorn> const 1 $ undefined
03:30:43 <ivanm> that's the whole point
03:30:44 <pastorn> const 1 $! undefined
03:30:50 <jlouis> Katiebug: let f x = 3 in f $ something_which_does_not_terminate is worth pondering about.
03:30:53 <ivanm> > const 1 $! undefined
03:30:54 <lambdabot>   *Exception: Prelude.undefined
03:30:56 <pastorn> those are different
03:30:56 <ivanm> > const 1 $ undefined
03:30:57 <lambdabot>   1
03:31:04 * pastorn found it!
03:31:07 <mreh> ivanm: i stand corrected :)
03:31:07 <pastorn> yoy
03:31:09 <ivanm> pastorn: I did say "unless an undefined pops up"
03:31:10 <abberaman> >let test (a%b) = a
03:31:10 <pastorn> yay*
03:31:12 <ivanm> ;-)
03:31:21 <pastorn> ivanm: i never saw that!
03:31:22 <dcoutts> mreh: no, only one instance of a package version, that's a ghc + cabal restriction. We're moving towards allowing that and doing more nix-style package management, but there are some tricky issues when you allow multiple instances of a single version.
03:31:27 <jlouis> &29
03:31:30 <ivanm> pastorn: learn to read!
03:31:31 * pastorn did it all on his own!
03:31:44 <ivanm> I had your nick to it and everything!
03:31:48 <mreh> dcoutts: it sounds amazing anyway :)
03:31:53 <mreh> three cheers for cabal!
03:31:53 <abberaman> >let test (a%b) = a in test (5%2)
03:32:00 <dcoutts> heh :-)
03:32:01 <pastorn> ivanm: actually i ran it in ghci *BEFORE* you said that
03:32:07 <pastorn> PRIOR ART
03:32:17 <Katiebug> umm
03:32:18 <Katiebug> so
03:32:19 <ivanm> pastorn: _sure_ you did
03:32:20 <Katiebug> my question
03:32:23 <burp> abberaman: space after >
03:32:23 <Katiebug> at compiletime, with f $! x, x gets evaluated to WHNF?
03:32:32 <pastorn> ivanm: ghci needs timestamps...
03:32:36 <abberaman> > let test (a%b) = a
03:32:37 <lambdabot>   <no location info>: Parse error in pattern
03:32:44 <burp> > let test (a%b) = a in test (5%2)
03:32:44 <ivanm> Katiebug: $! is judiciously used at times to improve performance
03:32:44 <lambdabot>   <no location info>: Parse error in pattern
03:32:48 <burp> seems it's not working ;)
03:33:11 <burp> > let (a%b) = a in (5%2)
03:33:12 <lambdabot>   <no location info>: Parse error in pattern
03:33:17 <Katiebug> but that's not an answer to my question :/
03:33:25 <mreh> I've set my cabal config to install profiling libraries as default
03:33:25 <abberaman> nope.. how do you use Rationals in patterns?
03:33:26 <ivanm> Katiebug: not at compile time
03:33:28 <ivanm> at run time
03:33:30 <pastorn> Katiebug: if you want to go further than just testing against undefined you should use deepseq, which takes an expression and fully evaluates it
03:33:40 <ivanm> abberaman: (foo % bar) I believe
03:33:56 <mreh> but i've got so many dependencies that don't have them, how can I reinstall all the profiling libraries en masse?
03:33:58 <abberaman> > let test (foo % barr) = foo
03:33:59 <lambdabot>   <no location info>: Parse error in pattern
03:34:00 <Katiebug> okay, if it does it at runtime, and $ does the same thing at runtime then I still don't see the difference...
03:34:20 <ivanm> Katiebug: $! forces evaluation before f is called
03:34:29 <ivanm> at times this can remove useless thunks from hanging around
03:34:35 <abberaman> > let test (foo % bar)::Ratio = foo
03:34:36 <lambdabot>   <no location info>: Parse error in pattern
03:34:46 <pastorn> Katiebug: let x = Map.fromList (zip [1..10000] (cycle ['a'..'z'])) in x `deepseq` f x
03:34:47 <abberaman> > let test (foo % bar)::Rational = foo
03:34:48 <lambdabot>   <no location info>: Parse error in pattern
03:34:57 <ivanm> Katiebug: e.g.: succ $ succ $ succ $ succ $ 2 can lead to a whole chain of thunks that get evaluated in one go with space leaks
03:35:05 <abberaman> > let test ((%) foo bar) = foo
03:35:06 <lambdabot>   <no location info>: Parse error in pattern
03:35:12 <ivanm> Katiebug: but if you use $! instead, then it forces the evaluation each time so you don't have that problem
03:35:13 <mle> > let (%) = const in 5%2
03:35:14 <lambdabot>   5
03:35:40 <abberaman> > 5 % 2
03:35:41 <lambdabot>   5 % 2
03:35:43 <ivanm> Katiebug: so the difference is _when_ the evaluation occurs: right when you ask for the value, or as you're going along
03:35:55 <pastorn> mle: nice obfuscation :)
03:36:11 <mle> yeah, reading back a bit I see that was pretty useless, heee
03:36:27 <mle> abberaman: I don't think one can, quite like that.
03:36:36 <Katiebug> what do you mean "as you're going along"?
03:36:53 <pastorn> Katiebug: lazyness
03:36:55 <ivanm> Katiebug: let's say you have an accumulating variable
03:37:04 <ivanm> and you keep applying a function to it
03:37:07 <ivanm> e.g. a counter
03:37:13 <abberaman> mle : so I use numerator and denominator then?
03:37:27 <abberaman> mle: so I use numerator and denominator then?
03:37:35 <ivanm> if you just use $, then when you actually want to print the value at the end it will suddenly try to evaluate the whole big chain of thunks (which are also chewing up RAM)
03:37:45 <ivanm> but if you use $!, then it gets evaluated at each step in the calculation
03:37:54 <abberaman> mle: where is the parse error anyway?
03:38:22 <ivanm> Katiebug: I've done physics simulations with 100 000 steps; it gets noticeable that continually applying just succ to the counter degrades performance
03:38:25 <Katiebug> okay, I think I get it now
03:38:37 <ivanm> but by doing succ $! counter, it's much better
03:38:40 <ivanm> Katiebug: \o/
03:39:12 <ivanm> preflex: seen bos
03:39:12 <preflex>  bos was last seen on #haskell 15 days, 14 hours, 6 minutes and 49 seconds ago, saying: mightybyte: yeah, i saw your email. i'd have gotten to it some time in the next month or two :-(
03:39:18 <ivanm> hmmm....
03:39:26 <mle> I guess i didn't answer fast enough
03:41:28 * ivanm wishes bos got criterion working properly with vector-algorithms
03:41:36 <Vitka> Does GHC inline across the modules?
03:41:44 <ivanm> Vitka: I don't think so
03:41:59 <dcoutts> Vitka: yes it does
03:42:08 <ivanm> oooooh
03:42:18 * ivanm never claimed to be right...
03:42:46 <Vitka> So it's not a bad idea to implement basic math functions used through the program in separate module?
03:42:55 <dcoutts> Vitka: that's fine
03:43:05 <Vitka> Good, thanks.
03:44:10 <dcoutts> Vitka: ghc automatically determines if functions are worth inlining and if so puts the function body into the .hi file so that it can be used when compiling other modules.
03:44:15 <deteego> also another thing, does using records inflict a performance penalty?
03:44:29 <dcoutts> deteego: compared to what?
03:44:39 <deteego> using the same data type without records?
03:44:56 <dcoutts> deteego: you mean record syntax vs constructor syntax?
03:45:03 <deteego> yes
03:45:09 <dcoutts> deteego: it's purely syntax
03:45:10 <fasta> dcoutts: doesn't that imply that one essentially has to disable inlining when compiling gtk2hs for a closed source application?
03:45:14 <Feuerbach> Where is haddock module header format documented?
03:45:30 <ivanm> Feuerbach: as in the stability, etc. stuff?
03:45:33 * ivanm copy-pasted
03:45:50 <dcoutts> fasta: no, you can comply with the LGPL without doing that
03:45:56 <Feuerbach> ivanm: yup
03:45:58 * Feuerbach too
03:46:32 <fasta> dcoutts: it sounds like the exact same thing as using GTK+ macros, which has the same problem.
03:46:53 <fasta> (and I never heard them say that this was not a problem, then again, I didn't ask. )
03:47:11 <dcoutts> fasta: my understanding of the LGPL is that inlined functions are not a problem
03:49:07 <koeien37> and what if I change the inlined function? how can I relink then?
03:49:25 <danderson> this appears to jive with the internet's opinion: LGPL considers inlining or macros to be compliant use of an LGPL library, as long as each inlining is under 10 lines in length
03:49:42 <danderson> (section 3 of the license)
03:50:28 <dcoutts> koeien37: the LGPL does not require that there are nice easy tools to make ABI-compatible variants of a lib
03:50:42 <zygoloid> danderson: careful. LGPLv3 allows that, LGPLv2.1 and before do not, iirc
03:50:55 <DerisionSnort> Folding over a list [t] gives me one result t. Is there something like a partial fold that gives me a list [t] of all the partial results?
03:51:18 <dcoutts> koeien37: e.g. ghc cannot currently be used to make ABI-compatible libs in any sensible way
03:51:23 <koeien37> :t scanl
03:51:24 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
03:51:54 <danderson> zygoloid: ah, I was not aware of this.
03:52:29 <danderson> Then again, I tend to avoid LGPL as much as possible, because it really pushes its luck by trying to formally define acceptable use through linker implementation
03:52:29 <koeien37> very often the authors say "or any later version", so yo can pick LGPLv3 if you want
03:52:55 <DerisionSnort> @koeien37 thanks!
03:52:55 <lambdabot> Unknown command, try @list
03:53:03 <DerisionSnort> koeien37: thanks!
03:54:13 <zygoloid> danderson: also i think the 10 lines is an example and the actual limit is somewhat vaguely defined :(
03:54:29 <koeien37> IANAL, but I would be careful before distributing programs under non-(L)GPL using Gtk2Hs in any case
03:55:12 <fasta> koeien37, that essentially means you cannot distribute anything on Linux commercially without doing heavy modifications.
03:55:53 <fasta> In reality it seems that most companies just take the gamble.
03:55:59 <danderson> zygoloid: since the license text doesn't say "for example", unfortunately I suspect that a judge would apply the limit strictly
03:55:59 <koeien37> with Haskell?
03:56:30 <fasta> koeien37, anything which uses macro information directly or inlines stuff.
03:56:42 <koeien37> if you use C it's easier to I guess
03:56:52 <Jafet> @vixen The lawyers are here!
03:56:52 <lambdabot> are you being sincere?
03:56:55 * Axman6 rages at the GPL again
03:57:13 <koeien37> I think the GPL is fine, but I can see why one would dislike it
03:57:26 <koeien37> especially v3, it is fairly complicated
03:58:28 <deteego> GPL2 is fine, i guess
03:58:32 <deteego> although I like BSD better
03:59:07 <fasta> koeien37, in some sense licenses like the GPL are a waste.
03:59:25 <koeien37> fasta: that depends entirely on your goal
03:59:29 <fasta> koeien37, if every OSS project would simply also put a price on their stuff there would be no waste.
03:59:55 <deteego> I would only ever use GPL3 if I was writing some library that for example allowed you to decrypt blue rays
04:00:05 <dcoutts> fasta: note that the LGPLv3 section 3 does not say you can't have inlined functions over 10 lines long, just that if you do then you have to say you're using the LGPL and provide a copy of the license.
04:00:22 <Jafet> fasta, that's the GPL!
04:00:33 <dcoutts> which you have to do anyway according to section 4
04:02:11 <fasta> dcoutts, ok, it seems things really do have changed in version 3.
04:03:47 <dcoutts> fasta: reading the LGPL v2.1, it looks pretty similar
04:04:08 <ivanm> my understanding of the changes to GPLv3 was that the legal language was tightened/updated and the tivoisation loophole was closed
04:04:27 <koeien37> ivanm: plus some extra compatibility options AFAIR
04:04:30 <dcoutts> the point is to give a get out clause, that if you're only using small bits of a header file, but not shipping the library binary, then you don't need to comply with any other terms
04:04:59 <dcoutts>   "If such an object file uses only numerical parameters, data structure layouts and accessors, and small macros and small inline functions (ten lines or less in length), then the use of the object file is unrestricted, regardless of whether it is legally a derivative work. (Executables containing this object code plus portions of the Library will still fall under Section 6.)
04:05:26 <dcoutts> so this has nothing to do with inlinging when using gtk2hs
04:05:47 <dcoutts> since in that case you're linking to the library so you have to comply with section 6
04:05:59 <koeien37> section 4, you mean?
04:07:02 <dcoutts> koeien37: LGPL 2.1
04:07:08 <koeien37> ah. OK.
04:07:13 <dcoutts> which is what gtk2hs uses
04:08:13 <dcoutts> so I've shipped closed-source apps using gtk2hs and made use of LGPL section 6 a)
04:08:33 <dcoutts> ie shipping gtk2hs source code and shipping closed-source app's object code
04:17:26 <pastorn> @src readLn
04:17:26 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
04:17:37 <pastorn> @type readIO
04:17:38 <lambdabot> forall a. (Read a) => String -> IO a
04:17:43 <pastorn> ehm... wut?
04:17:49 <pastorn> @src readIO
04:17:49 <lambdabot> Source not found. Take a stress pill and think things over.
04:18:41 <k23z___> is "A discipline of programming" by Dijkstra common read here ?
04:18:59 <deteego> I never read it
04:19:02 <koeien37> I read it
04:19:06 <deteego> if that means anything
04:19:39 <koeien37> disclaimer: I study in Eindhoven, where the Dijkstra used to teach
04:19:46 <koeien37> s/the //
04:20:26 <k23z___> I am going to read it also
04:20:48 <k23z___> koeien37: were you able to apply techniques described in the book ?
04:20:54 <k23z___> such as proving some programs to be correct ?
04:21:12 <koeien37> I think using a functional approach is often easier
04:21:21 <danderson> zygoloid: since the license text doesn't say "for example", unfortunately I suspect that a judge would apply the limit strictly
04:21:25 <danderson> gaaah.
04:21:26 <danderson> sorry.
04:21:31 <danderson> misfocus.
04:21:41 <k23z___> koeien37: easier with respect to ?
04:21:53 <k23z___> koeien37: in what way easier ?
04:21:59 <koeien37> proving your result correct, and writing the algorithm
04:22:38 <koeien37> e.g. if you want to sum an array of numbers, you can start with the definition. This more or less gives a functional program. If you program in GCL, you will have to derive a program. I prefer to leave that to the compiler
04:23:22 <k23z___> what's GCL ?
04:23:30 <k23z___> koeien37: did you study the book as part of a course ?
04:23:35 <k23z___> koeien37: or independent study ?
04:23:56 <koeien37> independent. I didn't study it extremely carefully though
04:24:14 <koeien37> as a freshman I already got an introduction to the guarded command language
04:24:41 <k23z___> where did you get that introduction from ?
04:24:54 <k23z___> I think you guys at Eindhoven are extremely lucky to be exposed to such things
04:24:57 <koeien37> my university
04:25:31 <k23z___> koeien37: yes but how ? what course ? what books ? were there any direct applications ? would you give more details please ?
04:35:57 <k23z___> koeien37: Dijkstra has a paper on guarded commands, did you read that first ?
04:37:15 * dcoutts wrote a compiler for the guarded command language
04:38:03 <HugoDaniel> :D
04:39:09 <dcoutts> k23z___: the CS degree at Oxford uses the GCL for the course on formal program design
04:39:25 <dcoutts> ie doing lots of proofs about loops, invariants etc
04:40:45 <k23z___> interesting
04:40:52 <k23z___> and do you get to use this in real-world situations ?
04:41:59 <dcoutts> k23z___: see http://web2.comlab.ox.ac.uk/oucl/publications/books/PfS/
04:42:13 <deteego> we ended up having to write an interpreter for Flan
04:42:27 <deteego> which is a basterdization of haskell (it was a language)
04:42:30 <deteego> in first year
04:43:03 <dcoutts> k23z___: not really, it's about the techniques and making you think, we don't scale it up to real-world scale tasks
04:43:33 <dcoutts> k23z___: to do it at scale requires proof assistants etc
04:43:48 <dcoutts> k23z___: for real world scale you'd move on to Z
04:43:53 <dcoutts> or FP
04:44:20 <deteego> never written a compiler though
04:45:10 <k23z___> dcoutts: Z=?
04:45:32 <dcoutts> k23z___: Z notation / formalisation, it's name is "Z"
04:45:59 <dcoutts> k23z___: http://spivey.oriel.ox.ac.uk/~mike/zrm/
04:47:15 * hackagebot GPipe-Collada 0.1.0 - Load GPipe meshes from Collada files  http://hackage.haskell.org/package/GPipe-Collada-0.1.0 (TobiasBexelius)
04:47:30 <deteego> oh AWESOME
04:47:35 <deteego> i was going to write that
04:47:45 <deteego> looks like im gonna be using Gpipe for my game =D
04:52:23 <k23z___> dcoutts: this Z language, it's the first time I see it
04:52:35 <k23z___> dcoutts: it seems a bit similar to what Dijkstra wrote
04:52:38 <k23z___> dcoutts: but not quite ...
04:52:40 <dcoutts> indeed
04:55:15 <dv-> If a module is in multiple packages, can I tell ghc which to use?
04:56:55 <blackh> dv-: Yes, use PackageImports language extension, then .. import "package" ...
04:57:06 <blackh> e.g. import "mtl" Control.Monad.Trans
04:57:28 <blackh> {-# LANGUAGE PackageImports #-}
04:57:47 <dv-> Thanks. I wonder why someone thought it would be a good idea to name one of his modules Control.Monad.State :/
04:58:25 <blackh> Actually ... I might have given you the wrong answer.
04:58:45 <blackh> It's best to use cabal and only depend on the packages you're actually using...
04:58:49 <dv-> It works
04:59:23 <blackh> PackageImports is really best only when you need to use the same module from two different packages in the same program, like I had to.
04:59:40 <dcoutts> dv-: as blackh says, it's much better to use cabal for that. The non-standard PackageImports extension is not intended for this use case.
05:00:08 <dcoutts> ie don't use the PackageImports extension
05:00:50 <dcoutts> dv-: and the reason there are several packages that implement Control.Monad.Trans is because they are alternative implementations of (mostly) the same interface
05:01:10 <dcoutts> and you use the build-depends field in your .cabal file to select which monad package you want to use
05:01:33 <dv-> Using cabal seems a bit overkill when I'm just testing things
05:01:37 <ketil> I need to draw some boxes and stuff.  Is Diagram the thing to use?  Or should I look at other libraries?
05:01:47 <dcoutts> dv-: then use ghci -hide-package blah
05:01:49 <ketil> ("stuff" may include some lines, text, etc)
05:02:01 <dv-> dcoutts: oh
05:02:28 <dcoutts> dv-: or ghc-pkg hide the ones you don't want
05:02:49 <dcoutts> dv-: those are the intended tools for this task, not PackageImports extension
05:04:38 <pastorn> Data.Time is the one to use, right?
05:06:40 <quicksilver> yes.
05:10:41 <mreh> I still never fixed that "read a file without knowing what it is and then read it correctly" problem, I've got it again now I'm reading Bioinformatics data
05:12:45 <ketil> mreh: Bioinformatics?
05:13:11 <mreh> ketil: using computers to try and make sense of all the information we've sequenced from the human genome
05:13:28 <mreh> an impossible task if you ask me, but It's part of my machine learning course
05:14:26 <ketil> What's the parsing (or file reading) problem?
05:15:19 <ketil> And why is it impossible?
05:25:37 <deteego> I know this may sound stupid, but does haskell has something the equivalent of function pointers
05:25:44 <deteego> or basically storing functions in a data type
05:25:46 <koeien37> we don't need them
05:26:00 <koeien37> data Mapping a b = Mapping (a -> b) -- perfectly valid
05:26:18 <koeien37> functions are first-class values
05:26:27 <deteego> ah
05:26:45 <deteego> I knew they were first class, just didn't know you could do that
05:26:50 <koeien37> > zipWith (\f -> f 2) [(*2), (^2), (+1), const 0)
05:26:50 <lambdabot>   <no location info>: parse error on input `)'
05:26:54 <koeien37> > zipWith (\f -> f 2) [(*2), (^2), (+1), const 0]
05:26:55 <lambdabot>   No instance for (GHC.Num.Num (b -> c))
05:26:55 <lambdabot>    arising from the literal `2' at <...
05:27:08 <koeien37> > map (\f -> f 2) [(*2), (^2), (+1), const 0]
05:27:09 <lambdabot>   [4,4,3,0]
05:27:12 <koeien37> sorry for the noise
05:27:35 <koeien37> :t  [(*2), (^2), (+1), const 0]
05:27:36 <lambdabot> forall a. (Num a) => [a -> a]
05:28:45 <deteego> god, that is so handy
05:28:50 <applicative> > zipWith ($) (repeat [ (\f -> f 2) ] ) [(*2), (^2), (+1), const 0]
05:28:51 <lambdabot>   Couldn't match expected type `b -> b1' against inferred type `[a]'
05:28:55 <deteego> thanks koeien37
05:29:11 <sbahra> :t (+)
05:29:12 <lambdabot> forall a. (Num a) => a -> a -> a
05:29:13 <sbahra> :t (+ 1)
05:29:14 <lambdabot> forall a. (Num a) => a -> a
05:29:15 <sbahra> :t (1 + 1)
05:29:16 <lambdabot> forall t. (Num t) => t
05:29:26 <applicative> > zipWith ($) (repeat (\f -> f 2) ) [(*2), (^2), (+1), const 0]
05:29:27 <lambdabot>   [4,4,3,0]
05:30:24 <Axman6> deteego: too much C in your brain
05:30:49 <zygoloid> > map ($2) [(*2), (^2), (+1), const 0]
05:30:50 <lambdabot>   [4,4,3,0]
05:31:23 <deteego> Axman6: I know, its hard getting rid of it when its hard coded in
05:31:28 <deteego> :(
05:31:39 <Axman6> have you been following any tutorials?
05:31:52 <k23z___> does Haskell have a good Symbolic computation package like SymPy ? because in Perl we have this Math::Symbolic which is really unmaintained and not very usable
05:31:54 <deteego> yes I have
05:32:04 <deteego> Ive gone through like 4
05:32:14 <SubStack> > [(*2), (^2), (+1), const 0] <*> pure 2
05:32:15 <lambdabot>   [4,4,3,0]
05:32:35 <deteego> really the issue I am finding is that haskell is so general and things make sense
05:32:49 <deteego> where as other languages have weird and specific ways of doing things
05:33:26 <k23z___> SubStack: in Perl we have map for that
05:33:54 <k23z___> does lambdabot know Perl ?
05:34:04 <ivanm> thankfully, no
05:34:10 <deteego> lol
05:34:14 <k23z___> ok then I'm bringing a friend
05:34:20 <SubStack> you don't get really nice syntax for partial function application though
05:34:40 <SubStack> perl6 has some stuff that isn't too bad for it though
05:36:30 <deteego> Perl6 is like DNF
05:36:50 <k23z___> Deewiant: DNF = ?
05:36:59 <SubStack> k23z___: in perl5 you can do map $_->(2), sub { 2 * shift }, sub { (shift) ** 2 }, sub { 1 + shift }, sub { 0 }
05:37:06 <SubStack> for that example
05:37:13 <deteego> k23z___: duke nukem forever
05:37:28 <k23z___> deteego: yeah I know .. :(
05:37:43 <k23z___> SubStack: I didn't know that !
05:37:46 <SubStack> I hate how sometimes you need parens for function calls in perl
05:38:03 <SubStack> to sort of strange precedence issues
05:38:08 <SubStack> s/of/out/
05:38:10 <deteego> Perl wasn't meant to be syntactically nice
05:38:37 <SubStack> I'm pretty attached to function composition and application anymore
05:38:48 <k23z___> I implemented a Morphism class in Perl
05:39:02 <k23z___> which pretty much does does the function composition you mentioned
05:39:18 <k23z___> I think I'll implement a "*" operator for it
05:39:32 <SubStack> yeah with cpan you can write perl in any language
05:40:36 <deteego> also in regards to this that was given me
05:40:38 <deteego> data Mapping a b = Mapping (a â†’ b)
05:40:56 <deteego> is it possible to restrict the data types which the function in the argument uses
05:41:01 <Cale> sure
05:41:11 <deteego> like lets say I only want a function that is String -> String
05:41:14 <k23z___> eval: map $_->(2), sub { 2 * shift }, sub { (shift) ** 2 }, sub { 1 + shift }, sub { 0 }
05:41:23 <Cale> data Mapping = M (String -> String)
05:41:27 <k23z___> the_outsider: 1+1
05:41:27 <the_outsider> k23z___: Couldn't match input.
05:41:32 <deteego> Cale: ah thanks
05:41:34 <k23z___> the_outsider: eval: 1+1
05:41:55 <the_outsider> k23z___: Error: error: cannot connect to eval server at plugins/eval.pm line 53.
05:42:05 <deteego> man
05:42:11 <deteego> this is sexiness unrivalled
05:42:30 <SubStack> functions are pretty great
05:42:31 <ivanm> Cale: you were the one who suggested I use Lena this morning, weren't you?
05:42:47 <Cale> Yeah.
05:43:09 <Cale> why?
05:44:41 <ivanm> well, I gave the students the URL... but it turns out that Clem's PPM parser they were using couldn't cope with it :s
05:44:58 <deteego> in what regard ivanm?
05:45:07 <deteego> Lua is like one of the fastest scripting languages
05:45:09 <ivanm> deteego: first year programming assignment
05:45:18 <deteego> ah right
05:45:23 <deteego> Lua is easy though...
05:45:34 <ivanm> so I told the students to use the Sean Connery PPM that Clem gave them in the tarball instead :s
05:45:44 <deteego> its like the most generic and easy to learn syntax, apart from from python or maybe go
05:46:05 * ivanm sticks with his haskell
05:46:31 <Ragzouken> How do I do pattern matching for Rational?
05:46:39 <ivanm> Ragzouken: didn't you ask this before?
05:46:44 <deteego> well Lua has its uses that I dont think haskell can do as well
05:46:45 <deteego> as of yet
05:46:46 <ivanm> and I'm pretty sure I answered...
05:46:50 <Ragzouken> ivanm, I haven't been here before
05:47:01 <ivanm> Ragzouken: is this for an assignment then?
05:47:06 <ivanm> because someone was asking before...
05:47:09 <deteego> and that is replacing logic in programs with a very fast and efficient scriptable language
05:47:11 <Ragzouken> Yeah it is :P
05:47:16 <k23z___> ivanm: Sean Connery PPM ?
05:47:37 <ivanm> k23z___: they had a whole bunch of PPM files to test their project out on, and one of them was Sean Connery
05:47:51 <k23z___> ivanm: I don't know what a PPM file is
05:47:58 <ivanm> @google wikipedia PPM
05:47:59 <lambdabot> http://en.wikipedia.org/wiki/PPM
05:48:00 <lambdabot> Title: PPM - Wikipedia, the free encyclopedia
05:48:07 <SubStack> An assignment appears. SubStack casts haskell. It's super effective!
05:48:13 <ivanm> heh
05:48:23 <ivanm> Ragzouken: OK, what does the Rational datatype look like?
05:48:44 <k23z___> Portable pixmap ?
05:48:47 <deteego> oh noes
05:48:53 <deteego> another pokemon reference
05:48:54 * deteego runs
05:48:55 <ivanm> k23z___: something like that, yeah
05:49:13 <k23z___> ivanm: and what was the assignment ?
05:49:15 <Ragzouken> ivanm, I'm not exactly sure. I know I can construct one like '10 % 2' in ghci, but it doesn't seem to work as a pattern
05:49:16 <ivanm> heh, I didn't even get that reference; I thought SubStack was referring to some magical fantasy thing
05:49:37 <ivanm> k23z___: to implement different image transformations (basically list processing on [[(Int,Int,Int)]] ) on PPM images
05:49:41 <quicksilver> Ragzouken: the constructor is private so you can't match on it.
05:49:49 <ivanm> quicksilver: oh? didn't know that
05:49:52 <Ragzouken> ah right
05:49:54 <ivanm> even if you import Data.Ratio?
05:50:27 <Ragzouken> Is it possible to get the two components of the rational in some other way?
05:50:33 <quicksilver> yes.
05:50:36 <ivanm> hmmm.... you can use it to construct values, but not for pattern matching
05:50:38 <ivanm> that's weird :s
05:50:42 <ivanm> @hoogle Ratio a -> a
05:50:43 <lambdabot> Data.Ratio denominator :: Integral a => Ratio a -> a
05:50:43 <lambdabot> Data.Ratio numerator :: Integral a => Ratio a -> a
05:50:43 <lambdabot> Prelude id :: a -> a
05:50:49 <ivanm> Ragzouken: look in Data.Ratio
05:50:54 <quicksilver> ivanm: you cannot use it to construct values.
05:51:01 <quicksilver> ivanm: % is not a constructor.
05:51:03 <ivanm> quicksilver: 5%2 works...
05:51:08 <quicksilver> ivanm: % is not a constructor.
05:51:09 <ivanm> oh, just an infix function?
05:51:13 <Ragzouken> thank you
05:51:18 <ivanm> quicksilver: I got you the first time! :p
05:51:19 <quicksilver> > (3%4) == (6%8)
05:51:19 <lambdabot>   True
05:51:26 <ivanm> ahhhh, right
05:51:29 <ivanm> it's a smart constructor
05:51:37 <quicksilver> if you think about the above example you can see (a) that it isn't a constructor and (b) why they don't expose the constructor.
05:51:40 * ivanm points out that he has never used Ratio before
05:51:46 <ivanm> quicksilver: right
05:51:53 <quicksilver> (infix constructors begin with :, by the way)
05:52:32 <ivanm> quicksilver: they have to? didn't know that :o
05:52:42 * quicksilver nods
05:52:50 <quicksilver> constructors are lexically distinguished in haskell
05:53:02 <quicksilver> prefix ones by a capital letter, infix ones by :
05:53:37 <quicksilver> (infix type constructors, which are only an extension not a haskell feature strictly, have no similar restriction)
05:54:14 <deteego> why would one want to use infix constructors, im just assuming its for style?
05:54:21 <ivanm> type constructors as in type a `Foo` b ?
05:54:32 * ivanm points out : to deteego 
05:54:55 <india> hi
05:54:55 <quicksilver> deteego: infix is only ever for style
05:54:58 <india> how r u '
05:55:03 <quicksilver> lisp does everything prefix and it works OK
05:55:05 * ivanm waves idly in india's general direction
05:55:15 <ivanm> which is about WNW IIRC
05:55:16 <quicksilver> but some people find infix looks nicer for some things.
05:55:18 <ivanm> ;-)
05:55:30 <quicksilver> ivanm: well, more (a ~> b)
05:55:41 <ivanm> ahhhh, right
05:55:51 <ivanm> but I was asking more for what you meant re type constructors
05:56:31 <quicksilver> actually I might be wrong anyway.
05:56:35 <ivanm> heh
05:56:39 <quicksilver> maybe infix type constructors do need to be a : ?
05:56:54 <quicksilver> the example I was thinking of was an infix type constructor *variable*
05:57:00 <quicksilver> variable means it can be 'lower case'
05:57:49 <ivanm> yeah, by experimentation you need : to start an infix constructor
05:57:56 <ivanm> but the error message it gives out is weird:
05:58:12 <ivanm> for "data Foo a b = a <+> b" ghci says "Not a data constructor: `a'"
05:58:18 <ivanm> oh, wait, duh, I get it now
05:58:24 <ivanm> I thought it was referring to the a after FOo
05:58:26 <ivanm> *Foo
05:58:30 <quicksilver> yes, I didn't have any doubt about that case
05:58:37 <quicksilver> it was the type case I was wondering about
05:58:43 <quicksilver> but you need -XTypeOperators for that
05:58:54 * ivanm has no idea how to define them, so *shrug*
05:59:09 <k23z___> ivanm: and if Haskell data structures are lists, how do you do bidimensional indexes ? like [][] ?
05:59:32 <quicksilver> you can have lists of lists yes
05:59:42 <quicksilver> btu if you really want indices then you probably dont' really want lists
05:59:50 <quicksilver> consider Data.Map or Data.Seq
05:59:54 <ivanm> k23z___: you don't
06:00:10 <ivanm> or an array type (Data.Array, vector, hmatrix, etc.)
06:00:13 <fasta> No, use lists, then you need faster hardware, which is good for the economy ;)
06:00:21 <quicksilver> lists are mostly for data which are processed in a stream fashion
06:00:21 <ivanm> heh
06:00:30 <k23z___> fasta: lol
06:00:55 <ivanm> @remember fasta No, use lists [rather than 2D arrays], then you need faster hardware, which is good for the economy ;-)
06:00:55 <lambdabot> Done.
06:01:19 <ivanm> yeah, we get for free what can be a pain to define in other languages
06:01:34 * ivanm vaguely recalls SICP using useless functions to create lazy streams
06:01:36 <fasta> ivanm, how do you unremember stuff?
06:02:25 <ivanm> fasta: @remember <nick> <quote>
06:02:30 <ivanm> oh, unremember
06:02:33 <ketil> fasta: you ensure that no closure refers to it, and then it gets garbage-collected.
06:02:37 <ivanm>  @forget <nick> <quote>
06:02:43 <ivanm> why, don't you want that quote remembered?
06:02:53 <fasta> @forget fasta No, use lists [rather than 2D arrays], then you need faster hardware, which is good for the economy ;-)
06:02:53 <lambdabot> Done.
06:03:22 <ivanm> :(
06:03:33 <ivanm> fasta: why don't you want it remembered?
06:03:48 * ivanm think lambdabot shouldn't let people remember or forget their own quotes...
06:04:05 <fasta> ivanm, because it is not exactly an epic comment.
06:04:09 <ivanm> so?
06:04:19 <ivanm> look at the one Axman6 @remember'd about me...
06:04:31 <ivanm> @quote ivanm quote
06:04:31 <lambdabot> ivanm says: Axman6: the premature optimisation quote is misquothed
06:05:30 <ketil> Oh.  Well, maybe you get another shot at your fifteen minutes of fame. :-)
06:07:07 <k23z___> I think fame is when a lot of people know you, right ?
06:07:29 <fax> yeah
06:07:29 <ivanm> _about_ you
06:07:36 <fax> or at least know of you
06:07:38 * twink knows of ketil
06:07:42 <ivanm> twink: heh
06:07:46 <ivanm> @wn fame
06:07:47 <lambdabot> *** "fame" wn "WordNet (r) 2.0"
06:07:48 <lambdabot> fame
06:07:48 <lambdabot>      n 1: the state or quality of being widely honored and acclaimed
06:07:48 <lambdabot>           [syn: {celebrity}, {renown}] [ant: {infamy}]
06:07:48 <lambdabot>      2: favorable public reputation [ant: {infamy}]
06:08:52 <k23z___> yes apparently the word fame is defined in WordNet
06:09:45 <ketil> twink: huh?
06:10:03 <mreh> @pl (\b -> f a b c)
06:10:04 <lambdabot> flip (f a) c
06:10:23 <k23z___> what's @pl ?
06:10:41 <fax> it rewrites your code to not use \
06:10:50 <Ragzouken> oh nice
06:10:59 <k23z___> why is \ not desirable ?
06:11:05 <ivanm> that's not quite right
06:11:09 <ivanm> @help pl
06:11:09 <lambdabot> pointless <expr>. Play with pointfree code.
06:11:12 <fax> that's not implied by the existence of this program
06:11:17 <ivanm> pointfree code removes variables
06:11:23 <ivanm> @google pointfree haskell
06:11:25 <lambdabot> http://www.haskell.org/haskellwiki/Pointfree
06:11:25 <lambdabot> Title: Pointfree - HaskellWiki
06:11:29 <ivanm> k23z___: ^^
06:11:34 <twink> ketil: Someone used to quote a post of yours from c.l.f. or one of the Haskell mailing lists in their signature.
06:11:45 <ivanm> twink: which quote wasthat?
06:11:52 <k23z___>  @pl (\b -> f a b c)  <------------- b is not used because  f(a) = c
06:11:57 <k23z___> right ?
06:12:19 <fax> k23z__ no
06:12:31 <fax> let g = \b -> f a b c
06:12:34 <fax> then g b = f a b c
06:12:50 <ivanm> @pl \ b -> f a b c
06:12:50 <lambdabot> flip (f a) c
06:12:50 <fax> also g b = flip (f a) c b
06:12:56 <fax> thus g = flip (f a) c
06:13:04 <ivanm> k23z___: pointfree code lets you compose functions easier
06:13:14 <fax> of course this shows that \b -> f a b c = flip (f a) c
06:13:27 <ivanm> it's a lot easier (visually) to compose "flip (f a) c" over "(\b -> f a b c)"
06:16:03 <ivanm> preflex: seen malcolmw
06:16:03 <preflex>  malcolmw was last seen on #ghc 6 days, 28 minutes and 58 seconds ago, saying: readUTF8File name = openFile name ReadMode >>= set_utf8_io_enc >>= hGetContents
06:17:32 <orlandu63> ivanm: i don't think so. the first is highly obfuscated and requires considerable thought to process. the second can be interpreted almost instantly
06:19:57 <twink> ivanm: I don't remember the quote. I also remember there was a flamewar (?) at one point whose subject: line had "a reply from Ketil Z. Malde" in it.
06:20:33 <Saizan> orlandu63: that might be simply lack of familiarity with flip
06:20:59 <orlandu63> Saizan: true
06:21:00 <ketil> I can't remember that.  I guess those were *my* 15 minutes, then.
06:21:46 <Saizan> i need more effort to see where the 'b' is going when i look at the lambda, but i'm not sure which one i'd write in "production code"
06:22:12 <mreh> can someone suggest why Map.insertWith requires the Ord k constraint on the key
06:22:33 <Saizan> ?type M.insertWith
06:22:34 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
06:22:56 <Saizan> mreh: how does it know how to find the position in the Map, otherwise?
06:22:57 <danderson> probably because the map is implemented as some kind of search tree
06:23:07 <danderson> which requires the ability to compare keys to find the one you lookup
06:24:00 <mreh> it's strange that Ord k isn't a constraint on the whole map
06:24:16 <Cale> Without the ability to compare keys for ordering and not just equality, it's impossible to implement a structure in which you can look things up in any better than linear time.
06:24:33 <mreh> I understand the implementation details
06:24:43 <danderson> I think that may be a limitation of the haskell type system
06:24:45 <Cale> Oh, that's because class constraints on data declarations in Haskell 98 are stupid.
06:24:53 <danderson> yeah, what Cale said
06:24:53 <twink> ketil: I'm not sure how much you actually did in it. Your contribution may have been limited to giving the flamewar its Subject: line.
06:24:58 <mreh> I was blindsided by the constraint later on whilst I was implementing the thing
06:25:16 <Cale> (they just restrict the type of the data constructors, and don't save you from constraining all the functions which operate on values of that type)
06:25:19 <mreh> damn you haskell98!
06:26:44 <quicksilver> however, it turns out that not putting constraints on data structures is quite good practice
06:26:57 <quicksilver> quite often it's useful that you can use some of the operations without the constraint
06:26:59 <mreh> quicksilver: can you provide an example?
06:27:24 <mreh> quicksilver: I suppose so
06:27:42 <quicksilver> you might have a game board, and decide that you will store various pieces which conform to some interface there, so you misguidedly do
06:27:44 <mreh> but not in the case when the constraint is so fundamental!
06:27:56 <quicksilver> data GamePiece a => GameBoard a = .....
06:28:14 <quicksilver> and then later discover that it's actually very useful for GameBoard to be a functor
06:28:29 <quicksilver> so you can apply fmaps to build scores or statistics or some such
06:28:43 <quicksilver> ... and the constraint just gets in the way.
06:28:59 <quicksilver> As a rule of thumb, use constraints only in those places/primitives/functions which actually need them.
06:29:06 <scree> again, damn you Haskell98 for not allowing restricted functors
06:29:14 <quicksilver> perhaps, but that's not the whole point.
06:29:30 <quicksilver> I might well want to functor to Double (some place-value scoring system for an AI algorithm?)
06:29:39 <quicksilver> and Double isn't an instance of GamePiece.
06:29:48 <quicksilver> in my hypothetical example :)
06:29:51 <mreh> I need to take an efficient tally of a list of data that doesn't implement Ord
06:30:02 <mreh> I guessed (wrongly) Map
06:30:16 <quicksilver> this is only an anecdotal argument I'm afraid - my anecdotal experience is that you often later find reasons you wish the constraint wasn't there.
06:30:17 <roconnor> mreh: wrap it in a newtype that implements Ord
06:30:34 <mreh> roconnor: it has many constructors
06:30:49 <scree> quicksilver: right, essentially it becomes a problem of not enough generality rather than a typesystem limitation
06:30:53 <roconnor> or just derive Ord :)
06:30:55 <k23z___> I saw a Haskell implementation of surreal numbers
06:31:26 <k23z___> I wonder if Surreal numbers can be computated in a feasible way
06:31:35 <k23z___> they would be very useful in game theory
06:35:24 <EvanR-work> just got here. is there a feasible implementation of real numbers? :)
06:35:36 <k23z___> EvanR-work: yes
06:35:40 <k23z___> EvanR-work: well...
06:35:59 <k23z___> EvanR-work: what do you mean real numbers ? like transcendental numbers in general ?
06:36:09 <k23z___> EvanR-work: because that's the most problematic subset of real numbers
06:36:17 <EvanR-work> arbitrary limits of rational numbers ;)
06:36:30 <k23z___> EvanR-work: ahh .. that's very problematic
06:36:45 <quicksilver> for a reasonable definition of 'feasible' the answer is 'no'
06:36:51 <EvanR-work> so i guess were talking about some interesting subset of surreals
06:37:01 <quicksilver> for a start you can't possibly get all real numbers, just the computable ones
06:37:05 <quicksilver> (a tiny subset)
06:37:13 <quicksilver> and even the computable ones are not particularly feasible
06:37:15 <k23z___> EvanR-work: but there is something I recently read about a continued fraction representation in order for fast and accurate real number computations
06:37:29 <k23z___> EvanR-work: it's some sort of lazy implementation of continued fractions that allows this
06:37:37 <EvanR-work> hmm
06:37:46 <k23z___> EvanR-work: it was implemented in C, if you want I can search in my browser history
06:37:47 <quicksilver> because your model has the property that most primitve operations increase the 'cost' of calculating the number
06:37:55 <quicksilver> k23z___: we already have several of those in haskell
06:37:59 <quicksilver> k23z___: including one in lambdabot
06:38:01 <Saizan> k23z___: those are still only the computable ones, i.e. countable many of them
06:38:03 <quicksilver> > pi :: CReal
06:38:04 <lambdabot>   3.1415926535897932384626433832795028841972
06:38:11 <k23z___> Saizan: yes that is true
06:40:17 <EvanR-work> > (pi :: CReal) < 5
06:40:18 <lambdabot>   True
06:40:27 <EvanR-work> > (pi :: CReal) < 4
06:40:28 <lambdabot>   True
06:40:34 <EvanR-work> where are these diverging comparisons
06:40:44 <Saizan> > (pi :: CReal) == pi
06:40:44 <lambdabot>   True
06:40:52 <Saizan> heh, == cheats
06:41:16 <k23z___> Saizan: that's a cheat ?
06:41:27 <k23z___> I mean the pre-compiler already evaluates that as true ?
06:41:35 <k23z___> pi == pi
06:41:49 <Saizan> it's only checking the first N digits or something like that
06:41:51 <EvanR-work> as long as == is an equivalence relation ;)
06:42:32 <Saizan> > (pi :: CReal) == (pi + (0.1^(10^20)))
06:42:36 <lambdabot>   mueval-core: Time limit exceeded
06:42:38 <Botje> > let a = undefined in a == a
06:42:39 <lambdabot>   *Exception: Prelude.undefined
06:42:53 <Botje> damn you and your semantics! :P
06:42:56 <EvanR-work> Saizan: it would terminate with a longer time limit though?
06:43:29 <Saizan> > (pi :: CReal) == (pi + 0.0000000000000000000000000000000000000000000000001)
06:43:30 <lambdabot>   True
06:44:25 <Saizan> EvanR-work: i'd think so
06:45:13 <EvanR-work> the doc says something about diverging comparisons
06:45:45 <quicksilver> yeah, I think the CReal doc lies
06:45:58 <quicksilver> (or they changed something after it was written)
06:46:05 <scree> quicksilver: do you have a link to a lazy haskell partial fraction thing?
06:46:10 <EvanR-work> can i use CReal as a drop in replacement for Float and Double?
06:46:13 <wvd> BONUS: hey, are u there?
06:46:16 <quicksilver> I'm pretty sure the one in lambdabot has inaccurate, but always terminating, comparisons
06:46:19 <quicksilver> EvanR-work: yes.
06:46:24 <EvanR-work> slower?
06:46:25 <quicksilver> scree: http://hackage.haskell.org/packages/archive/numbers/2009.8.9/doc/html/Data-Number-CReal.html
06:46:30 <quicksilver> many many times slower yes
06:46:35 <EvanR-work> ah ;)
06:46:39 <Jafet> EvanR, patches welcome!
06:46:50 <Jafet> > (e::CReal) == (e::CReal)
06:46:51 <lambdabot>   Couldn't match expected type `Data.Number.CReal.CReal'
06:46:52 <lambdabot>         against infe...
06:47:00 <Jafet> > (exp 1::CReal) == (exp 1::CReal)
06:47:01 <lambdabot>   True
06:47:20 <quicksilver> scree: there are others, too
06:47:24 <Jafet> > (exp 1::CReal) == (exp 1::CReal) - (exp (-100)::CReal)
06:47:25 <lambdabot>   True
06:47:34 <quicksilver> they're not necesarily implemented as partial fractions
06:48:21 <eldragon> hi guys, is there any performance comparison between the current GHC and 6 months ago one?
06:48:45 <Jafet> > (exp 1::CReal) == (exp 1::CReal) - (exp (-20)::CReal)
06:48:46 <lambdabot>   False
06:49:29 <Jafet> The nice thing about haskell is that you can implement them any way you like
06:49:50 <Jafet> Just attach any closure that somehow computes the rest of the digits
06:50:14 <scree> quicksilver: hang on, that's not a continued fraction rep is it?
06:50:59 <fax> oh
06:52:24 <scree> quicksilver: that's "give me an n and i'll give you a rounding of x * 2^n"
06:53:22 <Jafet> Well, I think the interface is currently decimal
06:53:48 <scree> Jafet: right, I mean the internal representation
06:54:26 <Jafet> That didn't make much sense to me.
06:54:38 <scree> sorry
06:54:47 <Jafet> Each CReal is an infinite sequence of the digits in the number.
06:54:57 <Saizan> Jafet: are you sure?
06:55:10 <Jafet> Probably a list, but I don't remember
06:55:15 <Saizan> not a list
06:55:22 <Saizan> data CReal = CR (Int -> Integer)
06:55:46 <Saizan> and i think it's a sequence of approximations like scree described
06:55:46 <Jafet> Oh? I misremembered then
06:55:46 <fax> Int ;(
06:56:00 <Jafet> fax, sure, add BPP to the library and we'll talk
06:56:06 <EvanR-work> at least its not Short ;)
06:56:24 <quicksilver> Int -> Integer is not an infinite sequence of digits
06:56:30 <quicksilver> you woudln't use Integer for a digit (surely)
06:56:41 <Saizan> you can't really do arithmetic with list of digits, because 0.11.... == 1
06:56:59 <EvanR-work> base 2
06:57:10 <scree> and adding works from the wrong end
06:57:36 <quicksilver> didn't roconor have a computable real representation too?
06:57:47 <Jafet> You can, as long as it isn't literally an infinite list of (radix-1)s
06:57:55 <Jafet> But that's a fair point
06:58:15 * zygoloid has a representation of non-computable reals :)
06:58:24 <quicksilver> and there is an interval-based one on hackage also
06:58:27 <EvanR-work> :o
06:58:46 <zygoloid> (for the field CReal adjoin Chaitin's constant)
06:59:00 <zygoloid> though i don't have an Ord instance :p
06:59:29 <Jafet> Or Show, I would suppose
07:00:16 <fax> I guess Chaitin's constant is trancendental over CReal?
07:00:24 <fax> yeah of course it is
07:00:33 <fax> so it's a simple field extension?
07:00:47 <scree> k23z___: so do you have a link for a lazy continued fraction thingy?
07:01:01 <Jafet> As long as you don't need Show or Ord
07:01:18 <fax> http://notvincenz.blogspot.com/2008/02/continued-fractions-in-haskell.html
07:01:55 <EvanR-work> you can have Show and Ord, but it wont correspond with the other real types ;)
07:02:15 <EvanR-work> but it also means you can convert
07:02:17 <EvanR-work> cant**
07:02:27 <scree> and you need to remember the ASCII for \Omega
07:02:29 <Jafet> Interestingly, it's still a valid instance of Num...
07:02:44 <Jafet> @src Num
07:02:44 <lambdabot> class  (Eq a, Show a) => Num a  where
07:02:44 <lambdabot>     (+), (-), (*)           :: a -> a -> a
07:02:44 <lambdabot>     negate, abs, signum     :: a -> a
07:02:44 <lambdabot>     fromInteger             :: Integer -> a
07:02:50 <EvanR-work> theres no omega in ascii ;)
07:02:59 <scree> even worse
07:03:01 <Jafet> Just use omicron
07:03:08 <EvanR-work> you can use unicode dammit
07:03:18 <EvanR-work> Î©
07:03:55 <EvanR-work> so theres no way to conver these numbers to Double or something? inaccurately?
07:04:57 <quicksilver> EvanR-work: realToFrac
07:05:07 <quicksilver> same way you would convert between Float and Double
07:05:10 <Jafet> What numbers?
07:05:12 <quicksilver> or Rational and Double
07:05:12 <EvanR-work> for CReal + Î©
07:05:30 <fax> CReal(Î©)
07:05:38 <Jafet> Sure, as long as you have the first 53 bits of Î©.
07:05:41 <scree> well, we know 0 <= ? <= 1
07:05:46 <fax> it's a ratio of polynomials with coefficients in Î©
07:05:48 <fax> oops
07:05:52 <fax> coefficients in CReal
07:05:54 <Jafet> Computing those is left as an exercise.
07:06:00 <EvanR-work> lol
07:06:02 <fax> and you imagine 'x' stands for Î©
07:06:15 <Jafet> I think about 4-5 are known, saves you work
07:06:25 <EvanR-work> fax: right, i vague remember this from algebra
07:06:42 <fax> I just learned this 2 days ago :)
07:07:40 <fax> it seems quite hard to prove things are trancendental over Q (like p and e), but Î© -- just by being uncomputable must be trancendental over CReal (right?)
07:08:37 <scree> Jafet: doesn't the value depend on what language you're using?
07:08:49 <Jafet> What does "trancendental [sic] over CReal" mean, fax?
07:09:01 <Jafet> scree, I'm going with jot
07:09:53 <scree> Jafet: oh ok
07:10:56 <scree> presumably that it's not a root of any polynomial with CReal coefficients
07:11:28 <scree> (which is true)
07:12:21 <Jafet> CReals, being computable, are enumerable. Any algebraic closure of a countable field is countable. Î©, being uncomputable, is not in any countable set (right?). Thus Î© is transcendental over CReals.
07:13:13 <Jafet> CReal Crunch -- breakfast of champions.
07:13:41 <Saizan> x in computable set -> x is computable ?
07:13:51 <Saizan> err
07:13:58 <Saizan> s/computable set/countable set/
07:14:12 <scree> ? is in {?} which is countable (and finite)
07:14:15 <Jafet> If that isn't correct, we can instead go with CReal is the algebraic closure of CReal
07:14:23 <fax> Saizan,isn't the halting set countable?
07:14:26 <fax> since its a subset of programs
07:14:41 <fax> or did you mean to substitute the other one...
07:14:44 <scree> Jafet: that I agree
07:15:09 <scree> Jafet: because root-finding is computationally possible
07:15:29 <scree> (of polynomials)
07:19:43 <EvanR-work> is CReal[Î©] countable?
07:20:00 <scree> yes
07:20:28 <EvanR-work> this is an annoying situation, like when we did Q[sqrt2], cant we get some others? :)
07:20:42 <EvanR-work> or get somewhere close to all uncomputables somehow
07:20:47 <Cale> EvanR-work: CReal[Î©]?
07:20:58 <EvanR-work> field extension
07:21:18 <Cale> Oh, so the same thing as CReal[x] then?
07:21:31 <fax> i thought F[X] was polynomials and F(a) was adding an element
07:21:36 <EvanR-work> i dont remember
07:21:48 <scree> I think so
07:21:53 <EvanR-work> actually i think i used F{a} or something
07:22:00 <Saizan> Cale: Î© = Chaitin's constant here
07:22:09 <fax> CReal[x] is isomorphic to CReal(Î©) for the reason I gave above
07:22:14 <Cale> F[x] is the polynomial ring, F(x) is the field of rational functions
07:22:18 <fax> wait that is not quite right
07:22:27 <Cale> (the field of fractions of the polynomial ring)
07:22:28 <fax> I think I should have said Quot(CReal[x])
07:22:37 <fax> Cale - ohh I see
07:22:54 <fax> so does that F(x) not clash with the F(a) notation?
07:23:40 <scree> well normally F(X) and X is never a constant
07:24:06 <Cale> If a is an element of some field K, and F is a subfield of K, then F(a) is the smallest subfield of K containing both F and a.
07:26:45 <scree> I was taught to prefer: a is a mythical placemarker for its min poly P, and F(a) := F(X) / (P)
07:27:51 <scree> or is that F[X]
07:28:09 <Cale> That works up to isomorphism when a is algebraic over F
07:28:27 <k23z___> if F is a field
07:28:38 <k23z___> F[X] are polynomials with coefficients in F
07:28:56 <k23z___> and F(X) / (P) is F[X] factorized on the ideal generated by the polynomial P
07:29:18 <k23z___> which if F is finite, then F(X)/(P) is isomorphic to some F_p^n
07:29:31 <k23z___> I know that because I'm studying algebra for an exam lol
07:30:22 <k23z___> normally I wanted to implement an algorithm to compute all galois groups of polynomials in subfields of C
07:30:30 <k23z___> but found the task to be extremely hard ...
07:30:37 <k23z___> is this already done in Haskell ?
07:30:41 <k23z___> computation of Galois groups ?
07:31:05 <roconnor> isn't F(a) just just the image of all elements of F(X) evaluated at a?
07:31:43 <fax> k23z___: I started on it yesterday
07:31:48 <Cale> There are a lot of roughly equivalent ways of describing these things. I thought I should point out though that F(X) won't have any nontrivial ideals, because it's already a field.
07:31:54 <k23z___> fax: you kidding ?
07:32:09 <fax> k23z___: oh not calculating galois groups but field extensions
07:32:20 <k23z___> fax ok can I have a look, I am very interested in this
07:32:21 <philo> is there any option to make ghc output haskell code after the CPS transformation ?
07:32:21 <roconnor> Cale: good point, scree and k23z___ ought to be writing F[X]/(P)
07:32:26 <fax> (the easy first step version)
07:32:55 <Cale> philo: CPS transformation?
07:32:56 <roconnor> Q(pi) is a perfectly reasonable field but clearly pi has no minimal polynomial.
07:33:04 <k23z___> well F(_) means the smalles extension of F that contains _
07:33:05 <Cale> roconnor: right.
07:33:08 <philo> Cale yes ?
07:33:26 <k23z___> while F[_] is the polynomial ring in indeterminates _
07:33:34 <k23z___> with coefficients in F
07:33:43 <k23z___> so roconnor is correct
07:33:46 <scree> I think I was being lectured by a fanatic
07:33:46 <roconnor> Q[pi] is also a perfectly good ring
07:33:50 <Cale> philo: Does GHC even do a transformation into continuation passing style?
07:34:15 <bitstream0101> Can someone tell me if the ghc profiler has any kind of by-module filtering/priority? My cost centre "winners" are off in libraries I don't care about, so I have to dig through a lot of detail to find the modules I care about. (yes, grep etc. works fine, I'm just curious)
07:34:21 <k23z___> does hugs use a vm ?
07:34:27 <roconnor> It just get's confusing because F[a] = F(a) when a is algebraic over F.
07:34:33 <gwern> Cale: I don't think it does. why else would people report significant  speedups when hand-converting to CPS from monads
07:34:37 <philo> Cale:  ho ? i assumed it did ...
07:34:41 <Cale> k23z___: hugs is an interpreter
07:34:45 <philo> thahs
07:34:47 <philo> thanks
07:34:50 <scree> the point is that if everything is a subfield of C it's easy to talk about "the smallest subfield of C ..."
07:34:53 <k23z___> Cale: is there a haskell compiler ?
07:34:55 <Cale> gwern: well...
07:34:59 <EvanR-work> philo: wikipedia explains wtf ghc is doing to the code
07:35:12 <scree> but if your algebraic closure is disgusting, it's easier to think about the polynomial quotient
07:35:18 <k23z___> scree: H is not a subfield of C
07:35:23 <k23z___> scree: S is not a subfield of C
07:35:27 <Cale> gwern: That's another thing again, since you're removing dataconstructors (and avoiding allocation)
07:35:41 <k23z___> scree: M_n(C) is not a subfield of C
07:35:48 <k23z___> scree: and is not even isomorphic to a subfield of C
07:35:52 <Cale> k23z___: yes, GHC, among others.
07:35:57 <k23z___> scree: there are structures much more general than C yes ..
07:36:06 * RayNbow ponders about this tweet... "Did you know that Arrow syntax provides Idiom brackets? #haskell"
07:36:07 <Saizan> bitstream0101: it does for heap profiling at least, maybe also for time, check the manual
07:36:08 <fax> The theorem is that there are only two kinds of simple field extension - algebraic or trancendental
07:36:14 <k23z___> scree: H(quaternions) , S(surreal numbers)
07:36:23 <Cale> S isn't even a set.
07:36:31 <k23z___> scree: M_n(C) (all matrices nxn with entries in C)
07:36:39 <k23z___> Cale: how is S not a set ?
07:36:41 <Cale> (and so it's not technically a field)
07:36:56 <k23z___> Cale: have you studied surreals ?
07:36:59 <Cale> (but that's the only problem with it being a field)
07:37:02 <Cale> yes
07:37:02 <scree> none of these are fields (except possibly S, don't know)
07:37:06 <RayNbow> did the author of Clojure just joined and parted this channel?
07:37:10 <k23z___> Cale: and does a surreal have an inverse ?
07:37:26 <philo> EvanR-work: does it says that ghc doesnt do cps transformation 6
07:37:32 <k23z___> scree: I know for a fact quaternions form a field
07:37:35 <EvanR-work> philo: read it
07:37:49 <Cale> k23z___: Nonzero surreal numbers have multiplicative inverses, yes.
07:37:55 <fax> k23z___: really
07:37:57 <philo> EvanR-work:  i did ...
07:38:00 <Cale> k23z___: They don't form a set because there are too many of them.
07:38:04 <scree> k23z___: they're non-commutative, no?
07:38:06 <EvanR-work> i dont think it says that
07:38:25 <EvanR-work> but absence of evidence isnt evidence of absence
07:38:30 <EvanR-work> tm
07:38:34 <koeien37>  quaternions are a division ring
07:38:41 <philo> EvanR-work:  it doesnt explicit all the source to source tranformation done
07:38:42 <k23z___> scree: true, quaternions form a non-commutative field
07:38:53 <k23z___> Cale: so what is the problem with them being too many ?
07:39:13 <scree> k23z___: as in, "the set of all sets is not a set"
07:39:13 <k23z___> Cale: please excuse my ignorance, I have never encountered a problem with a set having too many elements
07:39:53 <koeien37> k23z__: look up "Russell's paradox"
07:39:58 <EvanR-work> what is S ?
07:40:01 <Cale> There is a unique surreal number corresponding to every ordinal number
07:40:11 <Cale> and the ordinals are a proper class
07:40:17 <k23z___> S = surreal numbers (you can read about them in Calus Tondering's paper, I found that very good)
07:40:24 <k23z___> *Claus Tondering
07:40:26 <Cale> It's not really Russell's paradox, I think it has another name...
07:40:45 <EvanR-work> too many elements??
07:40:56 <k23z___> actually Claus TÃ¸ndering
07:40:56 <koeien37> it's a nice place to start exploring these topics, to see what can go wrong
07:41:02 <roconnor> Burali-Forti paradox
07:41:05 <fax> k23z___ - as step one I thought it would be interesting to implement numbers of the form Q(sqrt(-1),sqrt(2),sqrt(5),...) for all primes
07:41:12 <Cale> roconnor got it :)
07:41:30 <k23z___> fax: I have implemented Z[sqrt(n)] in Perl
07:41:40 <k23z___> fax: including a gcd algorithm for it
07:41:41 <fax> oops I meant Q(sqrt(-1),sqrt(2),sqrt(3),sqrt(5),...)
07:41:44 <k23z___> fax: and norm
07:41:46 <fax> basically it's al the prime numbers
07:41:48 <fax> cool
07:41:54 <k23z___> fax: did you do about the same ?
07:42:00 <k23z___> fax: for Q[sqrt(n)] ?
07:42:08 <k23z___> fax: can I have a look at the code ?
07:42:17 <Cale> k23z___: "On Numbers and Games" by John H. Conway, if you want to know more about surreals.
07:42:19 <fax> I've only written one line of code so far
07:43:02 <k23z___> Cale: I've read the chapter about "Ordinal numbers" in Conway's "The book of numbers", when I have more time I will go through the book you mentioned :)
07:43:31 <bitstream0101> Saizan: Yeah, I've read it and didn't see anything there; I was hoping that the heap profiling qualifiers would apply to time/alloc profiling, but it doesn't seem to be the case.
07:43:39 <scree> The problem is that all good haskellers believe in New Foundations, so sets are not "too large", just "too odd"
07:44:11 <fax> k23z___ - and after that would be cool to have all qth roots of all primes
07:44:19 <fax> which is still not quite algebraic numbers
07:44:19 <roconnor> fax: even more intersting is Q[sqrt(p_n) | n <- [0..], the nth turning machine doesn't halts]
07:44:34 <fax> roconnor what is interesting about that ?
07:44:41 <Cale> NF is weird.
07:45:12 <fax> it just seems impossible to use
07:45:19 <dmwit> fax: I think the joke is that it might be hard to compute it. =)
07:45:23 <roconnor> fax: it isn't a computablely presentable field.
07:45:28 <k23z___> fax: I have qth roots of unity implemented already from Math::Complex
07:45:35 <k23z___> fax: qth roots of primes, what do you mean ?
07:45:39 <k23z___> fax: roots in what field ?
07:45:41 <roconnor> fax:Q[sqrt(p_n) | n <- [0..], the nth turning machine does halts] is also intresting
07:45:46 <k23z___> fax: primitive roots ?
07:45:50 <fax> k23z___, I want to see Math::Complex
07:45:59 <k23z___> fax: search.cpan.org
07:46:06 <roconnor> it is a computable presentable field, but it is undecidable if polyinomials over it are irreducable or not.
07:46:11 <scree> Cale: how so?
07:46:17 <fax> roconnor that's kind of weird
07:46:38 <k23z___> fax: it basically just uses de Moivre and then computes  cos(stuff/n) + i sin(stuff/n)
07:47:03 <fax> okay
07:47:27 <k23z___> fax: what did you mean by qth roots of primes ?
07:47:46 <fax> k23z___, it's obvious what I mean, liek q=5 p=3 5th roots of 3
07:47:47 <k23z___> fax: you mean primes in Q(sqrt(p)) as in elements of norm 1 ?
07:47:59 <fax> i don't know what you mean by norm 1
07:49:15 <k23z___> if z=a+b sqrt(N)  N(z) = z \times \overline{z} = a^2 - Nb^2
07:49:24 <k23z___> if z=a+b sqrt(N) ==>  N(z) = z \times \overline{z} = a^2 - Nb^2
07:49:27 <k23z___> that's the norm
07:49:36 <fax> okay
07:49:37 <k23z___> for Q(\sqrt{N})
07:49:42 <fax> with N negative?
07:49:55 <k23z___> even if N is negative yes
07:50:03 <k23z___> you can still define the norm
07:50:24 <Cale> The category whose objects are the sets of NF and whose morphisms are the functions between those sets is not Cartesian closed.
07:50:41 <Cale> That seems kind of broken to me.
07:51:01 <k23z___> fax: code ?
07:51:01 <roconnor> NF?
07:51:07 <Cale> New Foundations
07:51:09 <tromp_> > showIntAtBase 8 intToDigit  18446744066614919232 ""
07:51:10 <lambdabot>   "1777777777713110100100"
07:51:17 <roconnor> New Foundations?
07:51:35 <Cale> http://en.wikipedia.org/wiki/New_Foundations
07:52:29 <fax> k23z___: yeah but imagine Q(sqrt(-1),sqrt(2),sqrt(3),sqrt(5),...,thirdrt(2),thirdrt(3),...,fithrt(2),...)
07:52:35 <Cale> http://www.dpmms.cam.ac.uk/~tf/cartesian-closed.pdf
07:53:05 <k23z___> fax: thirdrt(2) = ?
07:53:14 <fax> :(
07:53:31 <k23z___> fax: thirdrt(2) = \sqrt[3]{2} zeta_3 ?
07:53:37 <fax> x^3 - 2 = 0
07:53:41 <k23z___> fax: thirdrt(2) = \sqrt[3]{2} \Zeta_3 ?
07:54:16 <k23z___> fax: ok .. so you adjoin all those roots to it and you form an extension
07:54:17 * hackagebot hoauth 0.2.2 - A Haskell implementation of OAuth 1.0a protocol.  http://hackage.haskell.org/package/hoauth-0.2.2 (DiegoSouza)
07:54:25 <k23z___> fax: apparently that's not a finitely generated extension
07:54:26 * scree goes away to read that paper
07:54:33 <k23z___> fax: do you want to describe such a big extension ?
07:54:57 <Cale> It's just a note, a couple of pages.
07:55:10 <fax> k23z___: well it will start with F = Q(sqrt(-1)) and if you have f :: F then take nth root you will be given a new field to work in too
07:55:29 <fax> k23z___: sort of like how you can represent numbers as a list of digits (that grows if neede)
07:55:46 <k23z___> fax: nth roots of unity adjoined to Q form the so-called Cyclotomic fields
07:56:16 <fax> k23z___: yes everything expressible by radicals should be expessible in this data type!
07:57:18 <EvanR-work> how about represent them as roots of polynomials in Q
07:57:30 <tromp_> > showIntAtBase 8 intToDigit 18446744066480701504   ""
07:57:30 <EvanR-work> by specifying the polynomial, and which root ;)
07:57:31 <lambdabot>   "1777777777712110100100"
07:57:45 <fax> EvanR that would be a lot harder I think, so this is step 1
07:58:01 <tromp_> > showIntAtBase 8 intToDigit  18446744073695432768  ""
07:58:02 <lambdabot>   "1777777777777712110100"
07:58:24 <Cale> The axiom of choice also fails in NF, which makes it unsuitable for a lot of things.
07:58:25 <k23z___> fax: a friend has a Galois theory book where field extensions are defined as being ... homomorphisms !
07:58:48 <Cale> k23z___: That's a natural way to look at them.
07:59:06 <fax> homomorphisms between vector spaces?
07:59:08 <k23z___> Cale: well my books defines them differently
07:59:12 <k23z___> fax: fields
07:59:28 <fax> how do you find the degree?
07:59:31 <EvanR-work> who needs axiom of choice anyway ;)
07:59:34 <k23z___> Cale: my book says "the smallest field that contains both K and the adjoined elements"
07:59:47 <fax> I read a great paper about not using axiom of choice
07:59:54 <k23z___> fax: you find degree with tower theorem
07:59:56 <fax> well it wansn't great but it was fun
08:00:07 <k23z___> fax: [F:K] = [F:L][L:K]
08:00:12 <k23z___> fax: you use that repeatedly
08:00:16 <Cale> k23z___: A field extension is a different object from a field, as far as Galois theory is concerned.
08:00:18 <k23z___> fax: and you "hardcode" some known extensions
08:00:19 * hackagebot nptools 0.2.1 - A collection of random tools  http://hackage.haskell.org/package/nptools-0.2.1 (NicolasPouillard)
08:00:36 <Cale> k23z___: A field extension might be defined as a pair of fields, one of which is a subfield of the other.
08:00:45 <mreh> foldl' (flip (flip (insertWith (+)) 1)) tallyMap . fastaSequence $ seq -- uuuuugly
08:00:56 <k23z___> Cale: hmm I think I just confused a field extension F/K with  Q(a)
08:01:05 <k23z___> Cale: what is Q(a) called ?
08:01:14 <fax> [Q(a):Q] is a simple field extension
08:01:31 <fax> and I think you can turn any field extension into a tower of simple ones
08:01:37 <fax> maybe not.
08:01:38 <k23z___> fax: actually what you wrote is a number representing the degree of the extension Q(a)/Q
08:01:49 <k23z___> fax: which is simple because you have adjoined just one element, namely a
08:01:51 <fax> k23z___: ah okay
08:02:17 <k23z___> fax: you can turn some extensions into what you said
08:02:25 <k23z___> fax: by The Primitive element Theorem
08:02:59 <k23z___> fax: any finitely generated separable extension is equal to a simple one and there's an algorithm for finding the primitive element(the a)
08:03:20 * hackagebot regular-xmlpickler 0.1.1 - Generic generation of HXT XmlPickler instances using Regular.  http://hackage.haskell.org/package/regular-xmlpickler-0.1.1 (ErikHesselink)
08:03:36 <mightybyte> How do you construct an expression with unnamed fields in TH?  ConE seems to only apply to null constructors and RecConE seems to only apply to named fields.
08:04:38 <Saizan> mightybyte: ConE name `AppE` foo `AppE` bar
08:04:46 <mightybyte> I would expect ConE to be "ConE Name [Exp]" instead of "ConE Name".
08:04:47 <k23z___> fax: if you show me the code you have currently, I'd be very interested in collaborating and implementing stuff together
08:05:09 <mightybyte> Saizan: Ahhh, funky.
08:05:40 <mightybyte> Wow, Language.Haskell.TH is in serious need of some better documentation.
08:06:51 <fasta> mightybyte, are you an echo from the past?
08:07:29 <mightybyte> fasta: lol.  I guess so.
08:10:49 <roconnor> fax: here is a question that I don't know the answer too.  Given a subspace of the space of n x n matrices (say represented by a list of matrices that span the subspace), can you decide if all matrices in that subspace are invertable or not?
08:11:20 <Jonno_FTW> is it possible to use the haskell ffi with c++?
08:11:42 <EvanR-work> its at least possible to provide a c wrapper for the c++ lib
08:11:48 <EvanR-work> and there is qt bindings
08:11:54 <fax> roconnor: I wonder if you can use the charicteristic polynomial
08:12:04 <fax> (of the basis matrices)
08:12:19 <fax> I don't know that's really difficult
08:12:47 <fax> you could maybe get a new polynomial describing the basis
08:13:30 <roconnor> fax: Sure I can compute a basis for the subspace from the spanning set if you like.
08:14:46 <Ke> I'd speculate that in any non-trivial case all the matrices in a subspace of dimension greater than 2 are not invertible
08:14:57 <roconnor> (btw these are matrices over some countable field F)
08:15:11 <Ke> Ax=a By=a
08:15:40 <Ke> hmm, wait
08:16:29 <fax> roconnor is it equivalent to asking if the matrices are linearly independent?
08:16:40 <roconnor> Ke: you mean that if the dimension of my subspace is at least 2, then it would always certain singular matrix?  I think I have examples of matrix subpaces are arbitarily high dimension that are all non-singuler (excluding 0 of course)
08:16:57 <roconnor> fax: is what equivalent?
08:17:03 <roconnor> fax: finding a basis from a spanning set?
08:17:31 <fax> say the inverstible matrices are {A,B,C} and you're wondering if they span a set of invertible matrices (ignoring 0)
08:17:58 <fax> we know Ax = 0 -> x = 0, so the question is (aA+bB+cC)x = 0 -> 0?
08:18:04 <roconnor> fax: no I'm wondering if we can decide if a given subspace interects the set of all singular matrices or not.
08:18:16 <fax> oh I totally misread it
08:18:37 <roconnor> fax: so given A B C, are all linear combinations of A B and C invertable?
08:18:45 <roconnor> ya sorry
08:27:42 * Saizan wonders what you get by making a dependently typed language based on New Foundations
08:28:04 <ezyang> whooo! http://haskell.org/gtk2hs/archives/2010/04/21/cabalized-version-of-gtk2hs-now-up-for-testing/
08:28:37 <byorgey> nice!
08:28:46 * dcoutts has written 3 patches for it already
08:29:15 <dankna> dcoutts: oh hi!  you get my email with the patches?
08:29:26 <dcoutts> dankna: when? what patches?
08:29:46 <dankna> I might have used the wrong address or something.  I implemented that self-hosting-preprocessor thing for Cabal.
08:29:57 <dankna> It's broken up into smaller changes, hence the plural.
08:30:17 <dankna> this was a couple days ago
08:30:31 <dcoutts> dankna: I've been half on holiday, away from email
08:30:39 <dankna> oh, gotcha.  no worries.
08:31:03 <dcoutts> dankna: if you want me to look at them now then attach them to the appropriate ticket in trac
08:31:13 <dankna> will do
08:31:16 <dankna> in about ten minutes
08:31:20 <dcoutts> dankna: ok great
08:32:53 <orlandu63> is there a function that splits a string at every occurrence of a char?
08:33:20 <ezyang> @hoogle String -> Char -> [String]
08:33:20 <lambdabot> Text.XHtml.Strict renderHtmlWithLanguage :: HTML html => String -> html -> String
08:33:20 <lambdabot> System.FilePath.Posix (<.>) :: FilePath -> String -> FilePath
08:33:20 <lambdabot> System.FilePath.Windows (<.>) :: FilePath -> String -> FilePath
08:33:31 <ezyang> bah
08:33:37 <Botje> orlandu63: check Data.List.Split
08:33:49 <Botje> @hoogle Char -> String -> [String]
08:33:49 <lambdabot> Text.XHtml.Strict renderHtmlWithLanguage :: HTML html => String -> html -> String
08:33:49 <lambdabot> System.FilePath.Posix (<.>) :: FilePath -> String -> FilePath
08:33:49 <lambdabot> System.FilePath.Windows (<.>) :: FilePath -> String -> FilePath
08:33:57 <Botje> you suck, hoogle
08:34:40 <Botje> http://hackage.haskell.org/packages/archive/split/0.1.1/doc/html/Data-List-Split.html
08:34:50 <ezyang> Somewhat relatedly, it occurs to me that generality gets in the way of type-driven searches, doesn't it.
08:34:53 <Jonno_FTW> i tried to compile a script with ghc using the Control.Monad.Reader and it  returned this error
08:35:01 <Jonno_FTW> Ambiguous module name `Control.Monad.Reader':
08:35:16 <Jonno_FTW> it was found in multiple packages: mtl-1.1.0.2 monads-fd-0.0.0.1
08:35:33 <ezyang> "hoo boy"
08:35:44 <ezyang> when did you install monads-fd?
08:35:52 <Saizan> Jonno_FTW: ghc-pkg hide one of the two
08:35:55 <Jonno_FTW> i don't know
08:35:59 <Saizan> Jonno_FTW: or use -hide-package
08:36:11 <Jonno_FTW> which one don't i need?
08:36:18 <ezyang> mtl is default
08:36:23 <Jonno_FTW> ok
08:36:31 <ezyang> (doesn't mean it's better though :-)
08:36:43 <Saizan> monads-fd surely isn't better
08:36:51 <Saizan> at most it's the same.
08:37:06 <ezyang> true dat
08:38:57 <tromp_> > showIntAtBase 8 intToDigit  512-54  ""
08:38:57 <lambdabot>   No instance for (GHC.Num.Num
08:38:58 <lambdabot>                     ([GHC.Types.Char] -> GHC.B...
08:39:06 <tromp_> > showIntAtBase 8 intToDigit  (512-54)  ""
08:39:07 <lambdabot>   "712"
08:42:05 <Berengal_> Is there any support for heredocs in Haskell?
08:42:26 <dmwit> No, but there's string gaps.
08:42:46 <dmwit> > "foo\    \ignores whitespace (including newlines) between slashes"
08:42:46 <fasta> Berengal_, there is a TH package, IIRC, which does that.
08:42:47 <lambdabot>   "fooignores whitespace (including newlines) between slashes"
08:42:57 <Berengal_> fasta: Ah, that's what I was wondering about
08:43:04 <fasta> Berengal_, now, don't ask which one.
08:43:14 <Berengal_> I was thinking about writing one myself, but I'll just have to look I guess
08:44:11 <k23z___> roconnor I don't think so
08:44:28 <k23z___> 18:10 < roconnor> fax: here is a question that I don't know the answer too.  Given a subspace of the space of n x n matrices (say represented by a list of matrices that span the  subspace), can you decide if all matrices in that subspace are invertable or not?
08:44:34 <tromp_> > showIntAtBase 8 intToDigit  208  ""
08:44:35 <lambdabot>   "320"
08:46:46 <orlandu63> @src (>=)
08:46:46 <lambdabot> x >= y = case compare x y of { LT -> False; _other -> True }
08:46:51 <orlandu63> what is the _other in this case?
08:48:24 <zygoloid> k23z___: surely the space will contain a zero, and that will not be invertible?
08:53:17 <dmwit> orlandu63:
08:53:19 <dmwit> ?src Ordering
08:53:19 <lambdabot> data Ordering = LT | EQ | GT
08:53:43 <k23z___> zygoloid: let's suppose that you have a subspace in which all matrices are invertible, then there will be slightly larger subspace containing that one with at least one non-invertible, so there you have it, the sequence cannot help in deiciding
08:54:26 <k23z___> scratch that
08:54:32 <k23z___> I'm wrong
08:54:40 * hackagebot scan 0.1.0.4 - lexical style suggestions for source code  http://hackage.haskell.org/package/scan-0.1.0.4 (ChristianMaeder)
08:54:50 <k23z___> I dunno the answer either...
08:57:14 <dmwit> Surely the all-zero matrix is in every subspace.
08:57:20 <dmwit> Or at least in every span.
08:57:29 <dmwit> (and that matrix is not invertible)
08:57:46 <dmwit> Though I guess the question is still interesting if you ask about all the non-zero matrices. =)
08:58:00 <quicksilver> no, lots of non-zero matrices will also be non-invertible.
08:58:29 <quicksilver> invertible matrix iff determinant non-zero
08:58:33 <quicksilver> (I'm sure you all know this ;)
08:58:41 <dmwit> I don't see that that's necessarily true.
08:58:54 <dmwit> span(I) -- seems to have all invertible matrices other than the all-zero matrix
08:59:07 <quicksilver> sure, that's a one-dimension subspace
08:59:26 <quicksilver> however, in a two-dimensional subspace there are lots.
09:00:13 <quicksilver> all 1D subspaces are isomorphic to R, and the only non-invertible element of R is 0.
09:00:25 <quicksilver> but for dimension larger than one there are lots of other ways to fail to be invertible.
09:05:30 <dmwit> Well, I believe you, but if I had more time, I'd ask you to give a bit more proof. =)
09:06:09 <dankna> dcoutts: commentary and patches attached to ticket 137
09:06:31 <dcoutts> ta
09:13:24 <jmcarthur> wow, sqlite has 679 times as much test code as library code
09:13:36 <jmcarthur> seems like when you are reaching levels like that you might as well just prove the code correct
09:14:07 <jmcarthur> "just"
09:14:18 <hpc> at that point, it would certainly be less work
09:16:12 <jmcarthur> hah, dons beat me to that point in the reddit comment thread on it
09:16:30 <tromp_> > 504 / 7
09:16:31 <lambdabot>   72.0
09:21:19 <shapr> sure is quiet today
09:21:38 * quicksilver drops a lambda
09:21:48 <shapr> I heard that!
09:22:26 <shapr> My XO isn't a great Haskell workstation... I think the keyboard is part of the problem.
09:25:14 <fax> XO is the face when you just burned yourself
09:28:42 <fax> > (( (1 + sqrt(5))/2 + sqrt( (-5 + sqrt(5))/2) )/2)**5 :: Complex Double
09:28:43 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
09:29:00 <fax> > (( (1 - sqrt(5))/2 + sqrt( (-5 + sqrt(5))/2) )/2)**5 :: Complex Double
09:29:01 <lambdabot>   (-8.52965677734867e-2) :+ (-9.695959402084312e-2)
09:29:25 <fax> > (( (1 - sqrt(5))/2 + sqrt( (-5 - sqrt(5))/2) )/2)**5 :: Complex Double
09:29:26 <lambdabot>   (-0.9999999999999994) :+ 3.6739403974420574e-16
09:29:45 <fax> > (( (-1 - sqrt(5))/2 + sqrt( (-5 - sqrt(5))/2) )/2)**5 :: Complex Double
09:29:46 <lambdabot>   1.1334534322265148 :+ (-2.81516769476124)
09:36:00 <milaz> @src foldl
09:36:01 <lambdabot> foldl f z []     = z
09:36:01 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
09:36:43 <milaz> @src foldr
09:36:43 <lambdabot> foldr f z []     = z
09:36:43 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
09:39:08 <shapr> mmm, code
09:39:28 <milaz> i'm sevangelizing haskell to my coleague now :)
09:39:40 <milaz> *evangelizing
09:40:03 <milaz> > foldl + 0 [1, 2, 3, 4]
09:40:03 <lambdabot>   Ambiguous type variable `t' in the constraint:
09:40:04 <lambdabot>    `GHC.Num.Num t' arising f...
09:40:23 <milaz> > foldl (+) 0 [1, 2, 3, 4]
09:40:24 <lambdabot>   10
09:40:58 <ezyang> I have to admit, (+) and `x` were such good ideas :^)
09:41:05 * hackagebot uuagc 0.9.19 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-0.9.19 (ArieMiddelkoop)
09:41:50 <milaz> ezyang: it is really so :)
09:41:59 <shapr> milaz: Yay for evangelizing!
09:42:16 <shapr> I'm slowly convincing peeps here to try Haskell.
09:44:16 <fax> > 10 + 10 == 10 * 10
09:44:17 <lambdabot>   False
09:44:33 <fax> but my computerist told me inside computers 10 + 10 == 10 * 10
09:44:49 <copumpkin> > let (+) = (*) in 10 + 10 == 10 * 10
09:44:50 <lambdabot>   True
09:47:29 <milaz> fax: if there were binary literals, it would be true ;)
09:53:59 <angelicvenus> I am having problems with HDBC using the ODBC driver where, when getting table descriptions I get an exception "Prelude.(!!) index too large", anyone know about HDBC?
09:54:19 <angelicvenus> same problem as this person was having: http://www.haskell.org/pipermail/beginners/2010-April/003954.html
09:56:55 <tommd> Does anyone know the O(?) of Data.Vector.(!) ?
09:56:55 <tommd> I would assume it to be O(1) except I recall the uvector documentation claiming it was O(idx).
10:21:30 <jmcarthur> you know, i have half a mind to actually profile DiffArray and figure out why it sucks so much
10:21:41 <jmcarthur> wouldn't that be novel?
10:21:58 <hpc> as novel as a book
10:23:07 <fax> do it
10:23:08 <fax> !!!!!
10:24:30 <k23z___> :)
10:24:50 <k23z___> I found this thing called bitlbee which is an IRC gateway to other messenger protocols
10:25:40 <Zao> k23z___: Lovely thing.
10:25:52 <Zao> More of a -blah topic though.
10:26:19 <fax> I'm scared of it
10:26:41 * jmcarthur uses bitlbee
10:26:50 <k23z___> jmcarthur: nice !
10:27:06 <k23z___> jmcarthur: I wish this project would be maintained 10-20 years from now
10:27:20 <k23z___> jmcarthur: so I would never have to switch to something else
10:27:21 <jmcarthur> i'm thinking zao is right though
10:29:38 <EvanR-work> is a non zero origin array inefficient?
10:29:58 <EvanR-work> by either using extra space or doing a shift?
10:30:40 <Cale> EvanR-work: Indices are always computed.
10:30:56 <Cale> EvanR-work: You can see the operations responsible in the Ix class.
10:31:07 <EvanR-work> ok
10:53:18 <LoRe> http://pb.rbfh.de/tWkNXbqKd3vj i expected palindrome to be [a] -> [a], why it's [[a]] -> [a]? and how to make it [a] -> [a]? :)
10:55:14 <Jafet> Hmm, you're ghc?
10:55:39 <LoRe> Jafet: me?
10:56:01 <Zao> @type (++)
10:56:02 <lambdabot> forall m. (Monoid m) => m -> m -> m
10:56:07 <Zao> @type (++[])
10:56:08 <lambdabot> forall a. [a] -> [a]
10:56:15 <mauke> LoRe: did you mean: [x]
10:56:48 <Zao> LoRe: It infers the type of x to be [a] because it's one of the arguments to (++).
10:57:18 <LoRe> ah, ok :) i will dig into that, thanks so far
10:58:17 <Zao> LoRe: What do you want line 1 to do?
10:59:22 <LoRe> Zao: i try to solve exercise 4 at the bottom of http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html :)
11:01:10 <Zao> Good luck then.
11:01:47 <LoRe> thanks :)
11:03:38 <zygoloid> > let p[]=[];p[x]=[x];p(x:xs)=return x`mappend`p xs`mappend`return x;s _[]=[];s(y:ys)xs=uncurry(:).second(s ys)$splitAt y xs in s(1:map digitToInt(filter isDigit$show pi)).p.intercalate"a"$["am","n","pl","n","c"]
11:03:39 <lambdabot>   ["a","man","a","plan","a","canal","panama"]
11:06:28 <orlandu63> @pl (\a -> b (f a) (g a) (h a))
11:06:28 <lambdabot> ap (liftM2 b f g) h
11:07:15 <zygoloid> @type liftM3 ?b ?f ?g ?h `asTypeOf` \a -> ?b (?f a) (?g a) (?h a)
11:07:15 <lambdabot> forall a1 a2 a3 r t. (?h::t -> a3, ?g::t -> a2, ?f::t -> a1, ?b::a1 -> a2 -> a3 -> r, Monad ((->) t)) => t -> r
11:07:41 <zygoloid> orlandu63: that's liftM3 / liftA3 in the (->) r Monad / Applicative
11:08:15 <zygoloid> @vixen I'm disappointed in you :(
11:08:15 <lambdabot> whatever
11:10:22 <wvd> Is "Real world haskell" a good book alongside Learn you a haskell?
11:10:42 <Zao> Likely.
11:10:52 <Raynes> wvd: Indeed.
11:10:54 <applicative>  wvd, of course
11:11:04 <Raynes> wvd: It's even better AFTER Learn you a Haskell.
11:11:36 <wvd> Raynes, it looks like Monads are really one of those things that makes Haskell strong. But Learn you a Haskell doesn't have a section about it (yet) :(
11:11:49 <c_wraith> Monads aren't that important
11:12:02 <applicative> wvd, don't worry about it.  Learn you a haskell take the correct approach
11:12:39 <wvd> Like, I think creating your own types for certain things is pretty common in Haskell?
11:12:48 <wvd> e.g. a TCP packet (header & payload)
11:13:17 <applicative> wvd, indeed
11:13:38 <mreh> why isn't there a concatMapM?
11:13:40 <c_wraith> sure.  it's also common in object-oriented languages, though the nature of the division tends to be slightly different
11:13:40 <wvd> applicative, where to use a record instead of a type?
11:13:48 <c_wraith> records are types
11:13:53 <applicative> wvd, I recommend studying LYAH backwards and forwards, then beginning RWH
11:13:58 <wvd> own made type*
11:14:16 <applicative> wvd, 'record syntax' is one way of making a type
11:14:59 <c_wraith> really, record syntax in haskell is very primitive.  It's exactly equivalent to a non-record data structure with a bunch of functions written for you.
11:15:00 <wvd> I should probably re-read it. I tend to pick things up very sloowly when reading English things.
11:15:03 <applicative> data Person = Person {name :: String, serial_number: Int}
11:15:09 <wvd> Took me some questions here to understand curried functions
11:15:26 <zygoloid> wvd: record syntax is just syntactic sugar for creating named accessors for fields of a type. if you were going to write accessors anyway it can be a useful shortcut
11:15:39 <scotty> I would like to know if anybody here has written "big" programs in Haskell and C++ and whether you noticed a decrease in your development time.
11:15:58 <zygoloid> record syntax is also ugly: that comma should really be a semicolon :)
11:16:04 <scotty> That is, does it take you less time in Haskell to write the same thing in C++?
11:16:11 <applicative> arthur :: Person     arthur = Person {name = "Arthur", serial_number = 1635682}
11:16:13 <mauke> definitely, I've actually finished programs in haskell
11:16:37 <scotty> I mean, I know from experience that this is true for small programs, but I haven't written a "big" program in Haskell yet.
11:16:37 <applicative> or am I wrong... I hate record syntax..
11:17:20 <zygoloid> applicative: looks right to me (except that should be :: not : after serial_number!)
11:17:38 <IceDane> scotty: I'm really new at haskell(only a couple of months with off and on hobby programming) but I can say without a doubt that all the haskell programs i've written that I've written corresponding versions of in C++ took shorter time to write, were much shorter and more concise
11:17:46 <applicative> zygloid, indeed,;sorry wvd
11:17:46 <Jafet> scotty, that's like asking how fast one can write a novel in English compared to in Japanese.
11:17:54 <IceDane> Took me logner to think of the ways to do them, though
11:17:56 <Jafet> The two languages cannot express the same programs.
11:18:00 <Jafet> Or novels.
11:18:13 <scotty> Jafet: What do you mean??
11:18:20 <scotty> Jafet: They're Turing complete!
11:18:23 <IceDane> scotty: He means that two languages can't really be compared
11:18:33 <IceDane> Especially not two languages of completely different paradigms
11:18:34 <Jafet> And I'm Turing-hard.
11:18:40 <Twey> scotty: This is a common error
11:18:42 <zygoloid> scotty: you can tell the same stories, but you won't use the same writing style
11:19:06 <Jafet> In programming, the difference is even starker. You can't even imagine yourself telling the same stories.
11:19:31 <scotty> I'm not talking about syntax here.
11:19:33 <Twey> scotty: Turing-completeness only refers to the output given.  The way that output is reached may be *completely* different, and involve concepts that cannot be expressed in another language.
11:19:40 <Jafet> The syntax is superficial.
11:19:42 <scotty> I'm talking about seeing stuff on the screen!
11:19:50 <scotty> Twey: Exactly!
11:19:58 <Jafet> Not all programs cause stuff to be seen on screens.
11:20:11 <Jafet> Try writing a cryptographic driver in Haskell.
11:20:22 <scotty> Jafet: I know.  Perhaps I should clarify.
11:20:24 <zygoloid> all useful programs interact with their environment in some way
11:20:50 <scotty> In some cases, the code is the goal, but I'm just talking about the code as the means to comething else.
11:21:10 <Twey> scotty: That's what Jafet means by â€˜the two languages cannot express the same programsâ€™.  The programs may have the same effect when run, but they will likely be structured in entirely different ways.
11:21:22 <Jafet> Twey, not even that. See my previous comment.
11:21:30 <IceDane> scotty: That still depends on a lot of factors - whether the person is as good at haskell/functional programming as they are at C++/imperative/OOP
11:21:55 <scotty> IceDane: I know.  I was asking about peoples' individual experiences.
11:21:59 <applicative> Jafet, I was unaware that concepts are expressed in C++
11:22:15 <IceDane> I know, and I'm saying those statistics might be completely useless, but I get your point otherwise
11:22:31 <roconnor> scotty: have you ever written a big C++ program?
11:22:39 <scotty> roconnor: Yes
11:22:48 <Jafet> applicative, C++ concepts is still a sore point, please do not raise it again!
11:22:53 <roconnor> scotty: what did it do?
11:23:01 <scotty> roconnor: It was a 3D game.
11:23:04 * roconnor tries to understand what big is
11:23:15 <applicative> Jafet, okay.
11:23:26 <scotty> Yeah, maybe I should have just told you about what I was interested in.
11:23:32 <roconnor> scotty: smiliar in scope to tux racer?
11:23:41 <LeNsTR> =)
11:23:42 <scotty> roconnor: I've never played tux racer.
11:23:52 <scotty> roconnor: Is that like Diddy Kong Racing or something?
11:24:04 <scotty> roconnor: Or Mario Kart?
11:24:08 <pikhq> scotty: Somewhat simpler. It's not a cart racer.
11:24:10 <Jafet> Hackage has bindings to gl, cl and (partial) sdl, scotty.
11:24:19 <Jafet> If that's what your actual question is.
11:24:22 <roconnor> scotty: IIRC it started as graphics project for class
11:24:32 <pikhq> Just a single-player run through a map.
11:24:34 <pikhq> Also herring.
11:24:51 <roconnor> scotty: do you have screenshots?
11:24:52 <pikhq> More fun than it should be.
11:24:55 <roconnor> scotty: of your game?
11:24:57 <scotty> roconnor: Maybe
11:25:03 <scotty> roconnor: It was an abstract puzzle game
11:25:27 <scotty> roconnor: I know I do, but I'm not sure if I have any on this computer.  Let me see if I can ssh into my other machine.
11:26:49 <scotty> Anyhow, more specifically, I wanted to know if I could write games faster in Haskell.
11:27:10 <scotty> I just figured that less people were interested in making games, so I asked a more general question.
11:27:16 <pikhq> Possibly, but not necessarily.
11:27:19 <Jafet> Probably unlikely at present.
11:27:38 <pikhq> Much of the work, though, would be done in IO for the sake of the GL bindings...
11:27:44 <pikhq> And/or SDL bindings.
11:27:57 <roconnor> scotty: everyone is interested in making games!
11:27:58 <Jafet> There are many large frameworks for C++ that make the necessary abstraction bearable, and I guess you use one of them.
11:28:04 <roconnor> scotty: have you seen monodus
11:28:08 <roconnor> monadus
11:28:12 <roconnor> whatever
11:28:14 <pikhq> Which means you're essentially just writing in an imperative language that makes abstraction easy.
11:28:14 <scotty> Well, I've been impressed with HOpenGL so far.
11:28:41 <scotty> The syntax is much cleaner than the corresponding C++ code.
11:28:57 <pikhq> Oh, right. The comparison is with C++.
11:29:00 <pikhq> XD
11:29:11 <roconnor> scotty: http://hackage.haskell.org/packages/archive/pkg-list.html#cat:game
11:29:35 <roconnor> scotty: oh man I forgot about frag
11:29:47 <roconnor> Frag is a 3-d first person shooter
11:29:48 <Jafet> You also generally cannot do X much faster in a language you don't know compared to in a language you do.
11:29:52 <kmc> from +RTS -s: "SPARKS: 475 (119 converted, 0 pruned)"
11:29:54 <roconnor> old too
11:30:03 <kmc> what happened to the other 475-119 sparks?
11:30:31 <pikhq> Jafet: Except C++, which makes doing many things just hard. :P
11:30:34 <roconnor> scotty: http://haskell.org/sitewiki/images/c/c2/Frag1.png -- frag
11:30:46 <Jafet> pikhq, not really.
11:31:12 <scotty> roconnor: Yeah, I saw that.
11:31:13 <Jafet> Number crunching is one of its best applications
11:31:29 <pikhq> Isn't.... Fortran better for that in particular?
11:31:31 <Jafet> And video games today, for better or worse, involve a lot of that
11:31:48 <Jafet> Only if all your numbers come in one-indexed multidimensional arrays.
11:31:50 <jmcarthur> scotty: HOpenGL has its plusses and minuses. One of its plusses is that it's nicer in many ways than the C API. A big minus in my book is that it still doesn't lend itself to functional style.
11:32:14 <Jafet> Still a hidden state machine?
11:32:50 <roconnor> anyone else heard about (F-algebra)-modules (F being a field)?
11:32:51 <scotty> jmcarthur: Yeah, I know.  But what are you going to do with a state-based framework?  Have you seen GPipe?
11:32:56 <jmcarthur> Jafet: it would be okay if it was *hidden* ;)
11:33:10 <Jafet> Oh, dear
11:33:10 <jmcarthur> scotty: gpipe is a bit closer to what i envision
11:33:14 <jmcarthur> but still not there
11:33:47 <jmcarthur> scotty: i mean that gpipe is far more functional, but i disgaree with some of the api choices and the implementation is pretty horrible
11:34:00 <jmcarthur> scotty: plus you lose a lot of power
11:34:02 <scotty> jmcarthur: I agree.
11:34:19 <scotty> jmcarthur: It's not that sophisticated.
11:34:49 <scotty> http://imgur.com/8Ex27.png
11:35:44 <ukl> hello.  I'm looking for an easy way to split a list of length k*n into k parts of size n... any hints?
11:35:56 <mauke> Data.List.Split
11:36:02 <jmcarthur> scotty: is that using gpipe or hopengl?
11:36:22 <ukl> mauke: thanks, I'll have a look
11:36:29 <scotty> jmcarthur: That was for roconnor.  That was a game I wrote in C++.
11:36:43 <jmcarthur> ah
11:37:11 <Jafet> Newtonian mechanics?
11:37:15 <scotty> jmcarthur: I haven't written any games in Haskell.  I've hardly done any HOpenGL.  I've mostly just been tweaking example programs.
11:37:27 <scotty> Jafet: It used PhysX.
11:37:34 <roconnor> scotty: good. ... doesn't seem all that big, but big is really relative.  Arguably it is almost impossible for one person to write a big program nowadays.
11:37:43 <roconnor> scotty: I mean a big program to me is photoshop
11:38:02 <scotty> roconnor: Oh!  Ha-ha... I meant big for one person.
11:38:03 <Jafet> Well, I doubt hackage has bindings to that.
11:38:08 <Cale> ukl: map (take n) . takeWhile (not . null) . iterate (drop n)
11:38:51 <scotty> I'm more interested in making 2-D games at the moment, and Haskell has plenty of bindings for 2-D physics engines.
11:38:51 <roconnor> scotty: I'm not really convinced that writing programs is easier in Haskell.  Only that (accidentally) writing erronous code is harder.
11:39:29 <scotty> roconnor: By easier, do you more quickly?
11:39:44 <Jafet> Assuming you work at constant productivity, yes.
11:39:46 <Null-A> roconnor: debugging has always been a huge component of my projects
11:39:49 <Jafet> (I don't)
11:39:56 <Cale> ukl: Or as mauke suggested, if you get the split package from Hackage, you can import Data.List.Split and use  chunk k
11:40:01 <roconnor> scotty: not only quickly
11:40:22 <roconnor> Null-A: haskell projects?
11:40:25 <pikhq> roconnor: Haskell *does* make programming easier, IMO. But mostly because you don't think about stupid bullshit, but rather the actual... Program.
11:40:42 <roconnor> pikhq: maybe you are right.  It's been so long for me :D
11:40:54 <scotty> pikhq: Yeah, that's what I like.  I find myself going straight for the algorithm.
11:41:00 <pikhq> Of course, if you can do the various stupid bullshit of, say, C without thinking about it, Haskell's not going to do much but save you typing. And a few headaches from segfaults. :P
11:41:18 <Jafet> Haskell, saves me typing? Ha
11:41:24 <scotty> lol
11:41:59 <scotty> I like Haskell because it cuts bullshit code and doesn't leave a lot of room for errors.
11:42:30 <pikhq> Jafet: There are languages where you write "\x->x" as "new callBacker () { public Object callBack(Object x){return x;}}"
11:42:34 <pikhq> :P
11:42:44 <scotty> However, I don't feel that qualified to talk about Haskell as I've only started learning it recently.
11:42:44 <EvanR-work> the io code has all the errors, other functions cant fail!!!11 unless you do head []
11:42:51 <idnar> I don't think Haskell is quite as concise as, say, Factor
11:42:58 <Jafet> Those are the languages in which you don't want to recreate id.
11:43:01 <ozataman> anyone know how to do a multiple value substitution in HDBC? for example "select * from x where name IN (?)" and an indeterministic number of name values may need to be substituted for the ?
11:43:02 <pikhq> idnar: Indeed, it isn't.
11:43:02 <roconnor> idnar: or APL
11:43:11 <idnar> roconnor: you mean J? :P
11:43:13 <Jafet> Writing Haskell in Java is as pointless as writing Java in Haskell.
11:43:14 <jmcarthur> J
11:43:20 <idnar> roconnor: it's two characters shorter!
11:43:33 <EvanR-work> ozataman: we used hdbc recently for this sort of thing...
11:43:34 <jmcarthur> J always wins at gold.
11:43:35 <jmcarthur> err
11:43:37 <jmcarthur> golf
11:43:38 <pikhq> Jafet: Except that callbacks are used in Java. Is a pain.
11:43:56 <Jafet> I don't know Java at all, so I can't sympathize
11:44:10 <ozataman> EvanR-work: yeah it works, but I can't figure out how to substitute a list of values for the "IN (?)" part
11:44:42 <EvanR-work> you cant do that in c api either
11:44:48 <dankna> ozataman: you can't.  the underlying database doesn't support that.
11:45:20 <dankna> (for good reasons having to do with the nature of the query compiler)
11:45:49 <scotty> Well, for anyone that does graphics programming in Haskell, can you rattle off your favorite libraries?
11:46:10 <EvanR-work> ozataman: you might be able to do a more sophisticated query if the IN part are found using another query on some database
11:46:13 <EvanR-work> table
11:46:15 <scotty> I'd like to do as little re-inventing as possible.
11:46:18 <ozataman> dankna: it sure does. it is MySQL, you can do IN ("joe", "jack")
11:46:22 <EvanR-work> like those names are in a table
11:46:46 <ozataman> EvanR-work: yeah, in other words you can solve this issue using sql but not haskell
11:46:48 <ozataman> EvanR-work: too bad
11:46:49 <dankna> ozataman: yes - it just doesn't support substituting multiple values for one
11:46:55 <EvanR-work> ozataman: right
11:47:02 <EvanR-work> haskell / php / c
11:47:11 <EvanR-work> its always better to use sql if you can
11:47:27 <ozataman> dankna: yeah... missing feature in my opinion
11:47:53 <dankna> ozataman: maybe, but talk to the mysql designers about it, not the hdbc designers
11:47:53 <ozataman> HDBC could marshall [String] into the query "val1", "val2", ...
11:48:01 <EvanR-work> its not missing from hdbc, its missing from mysql
11:48:11 <dankna> ozataman: no no no, it doesn't work that way...  it's not a textual substitution!
11:48:14 <EvanR-work> you are talking about prepared statements syntax, not somethin hdbc made up
11:48:31 <dankna> ozataman: it's feeding values to compiled bytecode
11:48:42 <dankna> ozataman: the bytecode only expects a certain number of parameters
11:49:40 <EvanR-work> question about arrays, when you update an array with //, does it make a new copy of the entire array?
11:49:52 <dankna> depends on the array
11:49:58 <EvanR-work> Data.Array
11:50:00 <dankna> mutable arrays no, immutable yes
11:50:16 <dankna> Data.Array as I understand it is the common interface to all kinds of arrays.  how are you constructing it?
11:50:32 <EvanR-work> hypothetically, with array ;)
11:50:33 <ozataman> dankna: ah I see - I didn't know that
11:50:44 <ozataman> dankna: ok it makes sense now
11:50:52 <ozataman> dankna: missing feature in mysql then!
11:51:07 <ozataman> dankna: thanks!
11:51:15 <EvanR-work> you would have better performance and it would be simpler if you could get the names from the database
11:51:25 <dankna> sure thing
11:51:55 <EvanR-work> dankna: right, so immutable arrays are 'costly' to update?
11:52:00 <dankna> EvanR - I think since it's a typeclass you need a type signature to tell it which kind of array it actually is
11:52:02 <dankna> yes indeed
11:52:07 <EvanR-work> got it
11:52:42 <EvanR-work> i think Data.Array and Data.IArray are two implementations of the same standard immutable array type
11:52:55 <EvanR-work> either two implementations or two interfaces, one a superset of the other
11:53:24 <dankna> that's possible
11:53:28 <dankna> I think two interfaces
11:54:44 <EvanR-work> mutable arrays require IO ?
11:54:59 <dankna> not necessarily, there's also diffarrays
11:55:11 <Jafet> ghc has one in ST.
11:55:11 <monadic_kid> STArray
11:55:14 <monadic_kid> StorageArray
11:55:16 <dankna> which I don't know how they work beyond what I can infer from the name
11:55:27 <Jafet> Probably uses magic
11:55:35 <dankna> but in general the answer is yes they do require IO, or something similar
11:55:37 <EvanR-work> i need to learn magic at some point
11:55:47 <fax> how ?
11:56:11 <monadic_kid> dankna: STArray works in STM monad, can not run in IO
11:56:31 <dankna> okay.  haven't used STM.  seems like a pretty big flyswatter to me, mostly.
11:56:42 <monadic_kid> ?
11:56:50 <dankna> as in, it seems like overkill
11:57:00 <Jafet> Sometimes you need to swat flies over a network
11:57:08 <EvanR-work> diff array sounds awesome
11:57:20 <monadic_kid> dankna: Sorry I meant ST monad not STM
11:57:29 <monadic_kid> dankna: and it's not overkill
11:57:33 <Jafet> Diff array sounds inefficient
11:57:59 <dankna> oh okay
11:58:01 <dankna> well, fair
11:58:36 <monadic_kid> dankna: ST monad gives you local mutable references/arrays which can be hidden in a purely functional function type
11:59:04 <EvanR-work> Jafet: doc says accessing older updates get slower, but in a typical usage you dont use those
11:59:10 <dankna> hmmm.... well, it sounds nice
11:59:27 <Jafet> Okay, that would work. But require more magic.
11:59:33 * Jafet flips the switch
11:59:52 * EvanR-work puts more magic on the list too
12:00:24 <monadic_kid> dankna:ST is more restrictive than IO, does not allow IO actions, purely functional mutable varibles
12:00:28 <dankna> gotcha
12:01:23 <scotty> Is there a good image manipulation library in Haskell with similar features to the Image Processing Toolbox in MATLAB?
12:01:31 <jmcarthur> diffarrays are unfortunately slow, and nobody knows why yet. they are not even in the standard library anymore
12:01:50 <EvanR-work> heh?
12:02:00 <jmcarthur> i was just saying earlier today that i'm considering profiling diffarrays to try figuring out where the problem actually is
12:02:12 <jmcarthur> they are not even fast for their intended purpose
12:02:25 <dankna> I would suspect some sort of interaction with the GC
12:02:28 <dankna> if that's so
12:02:36 <monadic_kid> jm, evenr: well it's not much of problem GHC has lots of different kind of arrays for different purposes, unboxed/boxed, IO/ST, for C etc, etc
12:02:58 <jmcarthur> monadic_kid: diffarrays have their place too, if they would only behave as expected
12:03:31 <monadic_kid> EvanR: http://en.wikibooks.org/wiki/Haskell/Hierarchical_libraries/Arrays
12:03:39 <jmcarthur> monadic_kid: for example, in the implementation of a pure function which doesn't need persistent arrays but doesn't need the full power of ST
12:04:06 <jmcarthur> even persistence needn't be slow for diffarray if you don't need *really* old versions
12:04:29 <jmcarthur> (but modifying anything but the newest would still result in an expensive copy, of course)
12:05:50 <monadic_kid> one thing that seems lacking is more operations for haskell arrays, like lists, something like Travasable/Foldable instances
12:05:58 <jmcarthur> dankna: according to the ticket for diffarray's slowness most of the time is being used by system rather than user, oddly
12:06:19 <jmcarthur> monadic_kid: it seems like vector would be a reasonable candidate for that
12:06:42 <jmcarthur> vector actually has a ton of operations. no Foldable, though
12:07:14 <monadic_kid> what about scans?
12:07:17 <dankna> jmc: that would be consistent with GC issues.  IOUArrays had a major GC issue which was fixed in a patch that didn't make it into 6.12.1...
12:07:24 <jmcarthur> monadic_kid: you can do scans
12:07:34 <dankna> jmc: specifically the GC was traversing every element of the array when any element was modified
12:07:36 <jmcarthur> dankna: ooh
12:07:50 <jmcarthur> dankna: i thought that made it into ghc 6.12.1, but i didn't look for it
12:07:55 <dankna> jmc: they fixed it with a strategy called card-marking which holds a bitmask of which regions of the array need to be checked
12:08:07 <dankna> jmc: no, I did look because I was depending on it, it didn't make it in
12:08:15 <jmcarthur> aw :(
12:08:18 <dankna> ya :(
12:08:26 <monadic_kid> how about NDP, how is it that going?
12:08:38 <jmcarthur> monadic_kid: http://hackage.haskell.org/packages/archive/vector/0.5/doc/html/Data-Vector.html#v%3Ascanl
12:09:01 <jmcarthur> monadic_kid: i haven't been following NDP, but i keep hearing that there is progress
12:09:44 <jmcarthur> monadic_kid: i actually meant to link to this: http://hackage.haskell.org/packages/archive/vector/0.5/doc/html/Data-Vector.html#13
12:09:50 <jmcarthur> *just a difference anchor, same page
12:09:53 <jmcarthur> *different
12:10:18 <monadic_kid> no worries, looks great anyways
12:10:26 <jmcarthur> i like vector
12:10:41 <jmcarthur> to get the best performance out of it you have to inline all over the place though
12:11:58 <jmcarthur> ghc 6.13 has a flag to basically implicitly inline everything in the module though, so if your module boundaries work appropriately then you should be able to just use that eventually
12:12:16 <jmcarthur> that flag was added for experimentation with supercompilation, iirc
12:12:57 <jmcarthur> dankna: so GC looks liek system time, not user time?
12:12:59 <mreh> @hoogle Word8 -> Char
12:13:00 <lambdabot> Data.ByteString.Internal w2c :: Word8 -> Char
12:13:00 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
12:13:00 <lambdabot> Prelude show :: Show a => a -> String
12:13:00 <jmcarthur> *like
12:13:09 <jmcarthur> dankna: to the OS, i mean
12:13:50 <dankna> jmc: oh, sorry, you were looking at the OS profiling data?  no, it looks like user time :(
12:13:55 <jmcarthur> ah
12:14:02 <jmcarthur> dankna: then that's not diffarray's problem
12:14:02 <dankna> jmc: to GHC's profiler it looks like "system time" by which it means the runtime system
12:14:06 <dankna> yeah hmmm
12:14:20 <CalJohn> http://goo.gl/d8EY <-- why doe the two memoized fibs in this paste not behave the same way?  I thought graph reduction made this technique fast (at least with lists), is that not the case for the M.Map version?
12:14:40 <jmcarthur> dankna: but i actually cited that ticket wrong anyway.
12:14:58 <jmcarthur> dankna: it's actually lots of real time, but not much user or system time
12:15:02 <dankna> oh weird!
12:15:05 <dankna> deadlocks somehow?
12:15:09 <jmcarthur> maybe
12:15:17 <jmcarthur> the implementation does use a lot of MVar
12:15:34 <jmcarthur> not true deadlocks of course, but maybe a lock "bottleneck"?
12:15:41 <EvanR-work> :(
12:15:46 <dankna> yeah, something like that where it needs to go down a long garden-path of unlocking things
12:15:49 <mreh> how do I get a ByteString to a Char string
12:15:57 <jmcarthur> mreh: unpack
12:15:59 <dankna> mreh: utf8-strings
12:16:03 <mauke> :t Data.ByteString.Char8.unpack
12:16:04 <jmcarthur> heh
12:16:05 <lambdabot> BSC.ByteString -> [Char]
12:16:23 <EvanR-work> unpack wont decode it
12:16:35 <jmcarthur> nope
12:16:38 <dankna> :t Data.ByteString.UTF8.unpack
12:16:39 <lambdabot> Not in scope: `Data.ByteString.UTF8.unpack'
12:16:43 <dankna> :t Data.ByteString.UTF8.toString
12:16:44 <lambdabot> BSC.ByteString -> String
12:16:55 <dankna> of course, that presumes your encoding is UTF8
12:17:00 * jmcarthur wonders how much use the text library gets now
12:17:11 <EvanR-work> Text.Printf baby
12:17:27 <jmcarthur> printf? ew
12:17:31 <jmcarthur> ;)
12:17:44 <mreh> if I do "show byteString" it comes out as a readable string
12:18:08 <jmcarthur> mreh: yes?
12:18:12 <mreh> maybe it's ascii
12:18:30 <jmcarthur> ah encodings. yeah if the string is just ascii then unpack will work fine
12:19:03 <Twey> UTF-8 âŠ‡ ASCII
12:29:09 <jmcarthur> dankna: interestingly, for the same benchmark, i'm seeing this:  5.68s user 0.02s system 98% cpu 5.761 total
12:29:55 <dankna> hm, curious
12:30:48 <jmcarthur> still insanely slow
12:31:03 <jmcarthur> for Data.Array the same benchmark is  0.21s user 0.01s system 94% cpu 0.233 total
12:31:03 <dankna> yes
12:31:09 * dankna nods
12:36:19 <jmcarthur> i'm so interested in diffarray right now because there have been so many times that i've been interested in O(1) update and O(1) read without needing very efficient persistence but not wanting to go with ST
12:36:57 <Saizan> dankna: wasn't the GC issue only for boxed arrays?
12:37:07 <jmcarthur> IntMap would be my normal go-to, but if something potentially faster is possible why not take it?
12:37:29 <jmcarthur> Saizan: yeah i wondered about that. seems like there would be no reason to traverse an unboxed array
12:37:42 <jmcarthur> for GC, i mean
12:37:56 <EvanR-work> diff array would be quite awesome
12:38:13 <EvanR-work> but in the current state might be faster to update a regular array ;)
12:38:37 <jmcarthur> even IntMap is faster right now
12:38:54 <Saizan> jmcarthur: maybe with STM it'd be faster, but i'm not sure if that plays well with unsafePerformIO
12:38:59 <jmcarthur> IntMap is really fast enough for most things anyway
12:39:18 <EvanR-work> is diff array implemented in haskell or... uses some ghc tricks
12:39:21 <jmcarthur> Saizan: i'd be worried about nested calls to atomically
12:39:32 <jmcarthur> EvanR-work: it's in haskell with unsafePerformIO
12:39:39 <jmcarthur> EvanR-work: so the answer is "both"
12:40:31 <mreh> gah, I'm using a library that has imported the Internal implementation of the ByteString
12:40:32 <jmcarthur> Saizan: i think if something makes a nested call to atomically then it's basically a hard crash right there
12:40:40 <mreh> all the libraries use the public one
12:40:52 <kmc> apparently DiffArray performance actually sucks
12:41:00 <kmc> at least there is a ticket to this effect on the GHC trac
12:41:03 <jmcarthur> kmc: yes, and for unknown reasons
12:41:06 <kmc> damn
12:41:12 <Saizan> jmcarthur: i think so too
12:41:33 <jmcarthur> kmc: DiffArray has been pulled out to its own project, so any open GHC tickets about it are outdated i think
12:41:37 <kmc> okay
12:41:44 <kmc> i don't see it on hackage
12:41:51 <jmcarthur> yeah, nobody put it there yet
12:41:52 <hask> hi
12:41:55 <hask> newfag here
12:42:04 <jmcarthur> http://code.haskell.org/diffarray i think, kmc
12:42:06 <kmc> this isn't 4chan
12:42:09 <kmc> thanks jmcarthur
12:42:21 <cvic> newfag - bad. newbie - good
12:43:07 <hask> newbie then
12:43:23 <cvic> Ok then ;-)  Ask away
12:43:38 <hask> hmm I tried to make a new function inside od ghci, it seems to be liek in erlang, where I cant make any fucntions in interactive mode
12:43:39 <hask> right?
12:43:46 <dankna> that is correct
12:43:47 <kmc> hask, you can define functions with "let"
12:43:49 <jmcarthur> you can with let
12:43:55 <jmcarthur> but it's not quite the same
12:43:57 <kmc> hask, the context of GHCi is roughly the same as a "do" block within IO
12:44:02 <ezyang> Learn and love :r
12:44:10 <kmc> hask, you can also use the "let .. in .." form, which is purely an expression
12:44:26 <kmc> hask, what you can't do in GHCi is declare new data types, type classes, instances, etc
12:44:36 <hask> oki ty :)
12:45:06 <twink> It's a little bit arbitrary that way. I think the new types, typeclasses, and instances could be done in ghci without much pain.
12:45:53 <dark> kmc, this means that right now, the compiled haskell is more expressive than any interpreter?
12:46:01 <jmcarthur> it would be nice to be able to just paste in a bunch of code from hpaste into a ghci session
12:46:09 <dark> why not an interpreter that just compiles things :) ?
12:46:11 <jmcarthur> dark: no
12:46:21 <dark> hm
12:46:27 <jmcarthur> dark: you can just use runghc on a source file, and that's interpretation
12:46:38 <jmcarthur> or use hugs
12:46:46 <jmcarthur> but hugs kind of sucks in comparison
12:46:50 <hask> I didnt get the diffrecne between hugs and ghci :3
12:46:52 <Peaker> I really hate all the boilerplate I have to write around each newtype (the "unNewType", "inNewType", "inNewType2", ...)
12:46:59 <Peaker> And using TH to fix that is so inelegant
12:47:03 <dark> hmm.. so why don't the interpreter interprets each input to it as a file? because inputs could be 'partial'?
12:47:05 <cvic> ghc is the flagship
12:47:10 <hask> ok good
12:47:11 <hask> :)
12:47:11 <jmcarthur> hask: hugs is old and feature-lacking compared to ghci
12:47:19 <hask> ty
12:47:23 <jmcarthur> Peaker: me too
12:47:50 <Peaker> takes me about 6 lines to define a newtype :-(
12:48:05 <EvanR-work> dark: because a file is a recursive definition
12:48:05 <Twey> Peaker: newtype NewType = NewType { unNewType :: OldType }
12:48:16 <jmcarthur> Twey: yeah, that helps with one of them
12:48:29 <Peaker> Twey, yeah, and then: inNewType :: (OldType -> OldType) -> NewType -> NewType ; inNewType f = NewType . f . unNewType
12:48:32 <jmcarthur> but not for the inNewType* functions
12:48:55 <Twey> Needs moar Applicative?
12:48:56 <jmcarthur> it gets especially annoying with type parameters
12:49:02 <Peaker> Twey, and then: inNewType2 :: (OldType -> OldType -> OldType) -> NewType -> NewType -> NewType ; inNewType2 f = inNewType . f . unNewType
12:49:05 <Twey> You could do something like ZipList
12:49:28 <Peaker> Twey, The Kind is often *, so it can't be Applicative
12:49:40 <Peaker> Twey, when the kind is (* -> *) I make an Applicative instance using inNewType2
12:49:43 <jmcarthur> and even if the kind is * -> * that doesn't mean it should be applicative
12:49:48 <Twey> Hm
12:50:01 <Peaker> often something like:  (<*>) = inNewType2 . liftA2 $ id
12:50:09 <Peaker> (I'd like it if Applicative let you define either <*> or liftA2
12:50:15 <jmcarthur> i most often don't want to export this functionality in the first place, so using a type class is bad
12:50:58 <Saizan> jmcarthur: you could make an instance only for a newtype of the newtype
12:51:07 <Peaker> hehe
12:51:10 <jmcarthur> lol
12:51:24 <jmcarthur> and then you need wrappers and unwrappers for that too
12:51:26 <dark> Peaker, why do you need to declare the type?
12:51:29 <jmcarthur> so you make another newtype
12:51:32 <jmcarthur> and recurse
12:51:50 <dark> ah, for not seeing the entire type
12:51:55 <Peaker> dark, Because I like top-level type signatures - they aid readability, make type inference less confusing, and allow me to -Wall :)
12:51:59 <cocon> how come 'Either a' is a Functor, but not a Monad?
12:52:18 <Peaker> cocon, Because of "fail" in the Monad class :-(
12:52:33 <Saizan> cocon: see Control.Monad.Error for an ugly instance
12:52:33 <jmcarthur> fail is fail
12:52:52 <Peaker> I wrote the EitherT package (like MaybeT) that pretty much ignores "fail"
12:52:55 <Peaker> and gives a decent EitherT
12:53:01 <Peaker> (no silly constraint)
12:53:29 <Twey> Could still use fail = error
12:53:42 <Peaker> I use something like: fail = Left . error
12:53:50 <jmcarthur> oh that's nicer
12:53:54 <Twey> Why?
12:54:06 <jmcarthur> so you can match the failure without error
12:54:09 <Twey> Oh, right
12:54:14 <jmcarthur> you just can't get a message out of it that way
12:54:28 <Twey> *nod*
12:55:18 <Peaker> also, it lets bind actually work :)
12:55:32 <Peaker> (If you don't eventually look at the error)
12:55:58 <Saizan> sounds like you'd want Maybe.
12:56:12 <jmcarthur> probably
12:56:36 <jmcarthur> as soon as you have something failable then you have something no more useful than maybe
12:57:02 <EvanR-work> what is fail for?
12:57:08 <jmcarthur> EvanR-work: for annoying you
12:57:26 <jmcarthur> EvanR-work: but its intent it so you can do cool things with pattern match failure in do notation
12:57:29 <jmcarthur> *is so
12:57:37 <EvanR-work> 'cool?'
12:57:46 <jmcarthur> semantically meaningful
12:57:48 <EvanR-work> pattern match failure sounds like an error to me
12:57:52 <EvanR-work> a bug
12:58:06 <jmcarthur> > do { x <- Nothing ; y <- Just 5 ; return (x+y) }
12:58:07 <lambdabot>   Nothing
12:58:16 <jmcarthur> oops
12:58:21 <Saizan> that's not pattern match failure!
12:58:26 <jmcarthur> not a useful demonstration there
12:58:39 <jmcarthur> > do { Just x <- Nothing ; y <- Just 5 ; return (x+y) }
12:58:40 <lambdabot>   Nothing
12:58:48 <jmcarthur> > do { Just x <- Just Nothing ; y <- Just 5 ; return (x+y) }
12:58:48 <Saizan> neither.
12:58:49 <lambdabot>   Nothing
12:59:05 <Saizan> > do { Just x <- [Just 1, Nothing, Just 2]; return x }
12:59:06 <lambdabot>   [1,2]
12:59:11 <Saizan> catMaybes ^^^
12:59:17 <jmcarthur> @src catMaybes
12:59:17 <lambdabot> catMaybes ls = [x | Just x <- ls]
12:59:33 <orlandu63> :t return
12:59:34 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
13:00:05 <Peaker> Well, I don't see what's the big problem with making use of fail require a MonadFail or MonadZero context
13:00:11 <jmcarthur> nor i
13:00:24 <Peaker> Haskell needs a Python 3000-like overhaul
13:00:36 <EvanR-work> i got it, its called haskell 2010
13:00:36 <dv-> I wish MonadFix was automatically deriveable
13:00:41 <jmcarthur> i would disagree with it being MonadZero i think. they are kind of different things
13:00:42 <Saizan> enter in haskell'
13:00:43 <chrisdone> Peaker: do it now while no one's looking!
13:00:44 <fax> I'm calling mine Haskell'
13:00:47 <Peaker> EvanR-work, No, I mean backwards incompatible changes
13:00:49 <mreh> @hoogle Data.ByteString.Lazy.ByteString -> Data.ByteString.Lazy.Internal.ByteString
13:00:49 <lambdabot> Parse error:
13:00:50 <lambdabot>   --count=20 "Data.ByteString.Lazy.ByteString -> Data.ByteString.Lazy.Internal.ByteString"
13:00:50 <lambdabot>                  ^
13:01:02 <EvanR-work> Haskell 2.0
13:01:17 <Peaker> So, maybe GHC can start compiling Haskell' too with some flags?
13:01:22 <Peaker> and slowly, people can migrate?
13:01:26 <mreh> i meant that the other way round
13:01:27 <Saizan> mreh: those two are the same type.
13:01:37 <mreh> Saizan: GHC argues otherwise
13:01:46 <Peaker> Using ByteStrings feels like a real chore :-(
13:01:48 <Saizan> mreh: GHC is saying something else.
13:01:50 <mreh> maybe I've cocked something up
13:01:58 <Peaker> Why isn't there a type-class for all of the ByteString operations?
13:02:09 <maltem> mreh: Different versions of bytestring around?
13:02:11 <Peaker> Why duplicate namespaces like it's 1985? :)
13:02:29 <Saizan> Peaker: because no one coded it and/or noone started using it
13:02:49 <Saizan> what seems a big fail is calling both strict and lazy ones "ByteString"
13:02:55 <Peaker> Saizan, Nobody finds it super-annoying?  I enjoy doing Haskell, until I have to deal with ByteString
13:02:56 <jmcarthur> mreh: even Data.ByteString and Data.ByteString.Char8 are the same type. the only type mismatches you should get in the same version of the bytestring package would be between strict and lazy bytestrings
13:03:02 <Peaker> Saizan, Yeah, that too!
13:03:19 <Peaker> Also, why can't ByteString be replaced by some UnboxedArray :: * -> * ?
13:03:41 <mreh> maltem: yes
13:03:43 <jmcarthur> i do consider ByteString a failure of API design
13:03:50 <dmhouse> Peaker: how do you unbox, say, function types?
13:04:00 <dmhouse> Peaker: there is vector, which can unbox more things
13:04:06 <mreh> how did I manage to get two versions of bytestring?
13:04:10 <jmcarthur> as well as our numerous list-like data structures and no elegant general operations over them all
13:04:22 <jmcarthur> and don't even try to call ListLike elegant
13:04:27 <Peaker> dmhouse, Why is ByteString better/more efficient than:  SomeArray Word8 ?
13:04:28 <jmcarthur> ?hackage ListLike
13:04:28 <lambdabot> http://hackage.haskell.org/package/ListLike
13:04:35 <Saizan> there's Foldable/Traversable
13:04:36 <maltem> mreh, maybe some package had a funny dependency, or you updated bytestring, but not all packages that depend on it
13:04:39 <dmhouse> Peaker: it provides string functions?
13:04:48 <Peaker> dmhouse, like what?
13:04:57 <chowder> is there a way to call linux commands from within a haskell program?
13:05:02 <jmcarthur> Saizan: yeah, and they are much more elegant. not very comprehensive of course
13:05:08 <jmcarthur> chowder: look in System.Process
13:05:31 <chowder> jmcarthur, I'm still pretty new to haskell. Is that in the documentation?
13:05:35 <maltem> mreh, the way out is to recompile all relevant packages, and hope they'll pick up one and the same version of bytestring
13:05:37 <dmhouse> Peaker: I meant string IO functions. Like getLine etc.
13:05:38 <Peaker> dmhouse, It's ok to have a class or module that provides stuff that's specific to (SomeArray Word8) -- and it's ok to even call that module ByteString - but the type it should be based on could be a Functor/etc and much more elegant
13:05:49 <jmcarthur> i'm pretty sure this is the reason that we don't have such operations generalized in the standard libs http://hackage.haskell.org/packages/archive/ListLike/1.0.1/doc/html/Data-ListLike.html
13:05:55 <Saizan> jmcarthur: OMG i hadn't seen ListLike before
13:06:03 <dmhouse> Peaker: ByteString can't be a Functor because it's not parametric
13:06:41 <dmhouse> There is probably a Traversable instance
13:06:41 <jmcarthur> chowder: yeah, it is in the base documentation
13:06:49 <Saizan> Peaker: if you want to unbox you can't accept any type
13:06:58 <Peaker> jmcarthur, ListLike may not be elegant, but it seems like it could be much more usable than ByteString
13:07:05 <chowder> jmcarthur, thanks, I'll check it out
13:07:21 <jmcarthur> Saizan: that problem can be addressed by using a type family for the element type
13:07:28 <Peaker> Saizan, Maybe it could use some trick like RMonad to provide a Functor..
13:07:31 <jmcarthur> Saizan: like in the monoids package
13:07:41 <Peaker> (I don't fully understand the trick in RMonad)
13:08:17 <maltem> Isn't the question, why is ByteString not type ByteString = UArray Word8?
13:08:48 <Saizan> i guess that's part of it
13:08:58 <EvanR-work> Data.ByteString2
13:09:07 <Peaker> maltem, Yeah
13:09:10 <Saizan> for lazy bytestrings the answer is obvious
13:09:44 <Peaker> Well, Lazy bytestrings could be generalized to lazy lists of UArrays
13:10:03 <k23z__> any movie in which Haskell appears ?
13:10:06 <Peaker> or maybe lazy lists of Foldable's or something more general?
13:10:16 <dmhouse> What advantage would there be in ByteString being defined as UArray Word8?
13:10:27 <EvanR-work> k23z__: as a guest star, extra, or main character/
13:10:41 <Peaker> dmhouse, Stuff that works with UArray could work with ByteStrings
13:10:46 <jmcarthur> dmhouse: for one you could easily use it as a UArray Word8
13:10:55 <dmhouse> Peaker: But one of the big pros of ByteString is that it's a drop-in replacement for [].
13:11:02 <jmcarthur> dmhouse: no it's not
13:11:07 <Peaker> dmhouse, It isn't - because the list functions don't work with it
13:11:12 <jmcarthur> dmhouse: try it. it will fail miserably
13:11:26 <dmhouse> Well, it should at least be drop-in for String, no?
13:11:31 <jmcarthur> no
13:11:37 <jmcarthur> it's completely different
13:11:52 <dmhouse> What's different?
13:12:06 <Saizan> well, you can't pattern match
13:12:08 <jmcarthur> ByteString is an array of bytes. String is a linked list of Chars
13:12:14 <Saizan> and asymptotics
13:12:15 <dmhouse> jmcarthur: in the API
13:12:21 <jmcarthur> and the interface reflects those differences completely
13:12:24 <Peaker> String represents unicode human text.  ByteString represents a buffer.. of bytes.. containing some serialized data
13:12:28 <jmcarthur> dmhouse: i am talking about both the API and the implementation
13:13:15 <dmhouse> Can you point out a difference in the API between String and ByteString? (Apart from pattern matching, which I concede -- although this isn't impossible in theory.)
13:13:33 <Saizan> however the big differences in the underlying structures are what goes against the use of a typeclass, imo.
13:14:24 <jmcarthur> dmhouse: how about... any list function. it won't work on a bytestring
13:15:15 <Peaker> Saizan, A type-class is still allowed to talk about the similar things, even when there are deep differences
13:15:26 <Peaker> Saizan, [] and IO are very different but they still usefully inhabit the same typeclasses
13:15:31 <jmcarthur> dmhouse: here's a concrete one (out of *many): nub
13:15:39 <jmcarthur> dmhouse: its not in the bytestring api
13:16:08 <Peaker> dmhouse, ByteString has Word8's in it, and a String has Chars in it
13:16:21 <jmcarthur> dmhouse: ByteString can't even store unicode
13:16:30 <Peaker> (It can using encodings)
13:16:32 <jmcarthur> well, it can, but you dont' see it as unicode
13:16:36 <jmcarthur> you see it as bytes
13:17:00 <Peaker> Depends if you're Neo or not :)
13:17:07 <jmcarthur> ha
13:17:20 <EvanR-work> blonde brunette redhead
13:17:27 <Saizan> Peaker: the problem is if with just the typeclass methods you can write useful code
13:17:30 <dmhouse> Peaker: I'm talking about the ability to take a file written for String, put "import Data.ByteString" at the top, do a search-replace of String to ByteString, and have it still work. The fact that ByteString has Word8s in it and String has Chars in it isn't a difference in the API (although it may imply such differences).
13:17:45 <scree> what's the unicode character for brunette?
13:17:50 <scree> there should be one
13:17:55 <jmcarthur> dmhouse: no, it's a major difference
13:17:59 <Peaker> dmhouse, Everywhere where you have "Char" it will fail
13:18:01 * EvanR-work throws a stream of utf8 at scree 
13:18:05 <Peaker> dmhouse, everywhere you use a string literal it will fail
13:18:06 <jmcarthur> dmhouse: and still, i already gave a concrete case where it won't work
13:18:20 <glguy> There is the Data.ByteString.Char8 interface if you want to treat the bytes as Chars
13:18:28 <jmcarthur> glguy: as Char8s, not Chars
13:18:31 <dmhouse> jmcarthur: Char is in Ord, so you should be using map head . group . sort instead of nub.
13:18:46 <jmcarthur> glguy: rather, it doesn't just give you the unicode it might represent
13:19:24 <jmcarthur> dmhouse: that won't give you the same results as it would be String if you have anything out of the range of Word8
13:19:44 <dmhouse> Peaker: yes, so "drop-in" is a slight misnomer. You have to change some types, and you have to do some packing. But you should at least be able to change from String to ByteString without renaming 90% of the functions you use.
13:19:45 <EvanR-work> theres no standard binary i/o interface except bytestring?
13:19:46 <glguy> I didn't see the beginning of the discussion, but if you are dealing with ASCII text and not Unicode text, then that won't be an issue
13:20:04 <jmcarthur> dmhouse: it does different things entirely. you will get different results
13:20:05 <Peaker> dmhouse, and then you'll get wraparound of your Char code points to 0..255
13:20:11 <dmhouse> jmcarthur: I concede that it's limited to ASCII too.
13:20:16 <Saizan> however, unless someone finds a decent interface for "sequences of characters" that permits efficient instances this discussion is moot :)
13:20:34 <jmcarthur> dmhouse: well, we also already established that you will have to change most of your code for it to work anyway
13:20:42 <jmcarthur> even if you are using ASCII
13:20:47 <dmhouse> jmcarthur: we did? Where?
13:20:47 <Peaker> Saizan, btw: Lazy ByteString is really similar to [Word8] in most ways I can think of
13:21:21 <jmcarthur> dmhouse: when we established that many functions aren't in Data.ByteString that are in Data.List, that you can't just use string literals, that you can't pattern match, etc.
13:21:38 <Saizan> Peaker: huge perfomance differences, and strictness properties are probably quite different too
13:21:40 <glguy> can't use string literals?
13:21:50 <jmcarthur> glguy: maybe with OverloadedStrings or whatever it's called
13:22:11 <Peaker> Saizan, btw: Maybe the "Unboxable" requirement can affect GHC optimizations, but not disallow all types (if that's possible)
13:22:14 <jmcarthur> but that's still just yet another thing you have to do
13:22:48 <dmhouse> jmcarthur: "many functions" -- you gave one example, I showed that it's unlikely you'll be using that with Char anyway (of course under the assumption you're working with ASCII text). String literals -- look at performance-heavy code that does a lot of String stuff (particularly String I/O). Do you really have a lot of literals? There will be some unpacking, but I don't think too much
13:22:54 <Saizan> Peaker: Lazy bytestrings are not even the same as [ByteString]
13:23:19 <jmcarthur> dmhouse: do i really have to do the dirty work and find every list function that's not in Data.ByteString? there's just an insane number of them
13:23:26 <Peaker> Saizan, Why not?
13:23:32 <jmcarthur> Saizan: they aren't?
13:23:37 <Saizan> no.
13:23:38 <jmcarthur> or do you mean in API?
13:23:40 <dmhouse> jmcarthur: no, just provide a single one you actually use with String
13:23:49 <Peaker> Saizan, strictness differences?
13:24:06 <Saizan> data ByteString = Cons !S.ByteString ByteString | Empty
13:24:28 <jmcarthur> dmhouse: intersect
13:24:37 <dmhouse> Peaker: have you seen the vector package? It's maps from integers to stuff, and does some clever semi-magic unboxing based on the contained type
13:25:30 <Saizan> and an {-# UNPACK #-}
13:25:31 <EvanR-work> jmcarthur: dmhouse what about parsing
13:25:57 <jmcarthur> EvanR-work: what about it?
13:26:06 <EvanR-work> something youd like to do with Char and Char8/Word8
13:26:21 <jmcarthur> most parser combinator libraries support both that i know of
13:26:22 <dmhouse> Wasn't there a SoC project to get Parsec working with ByteString?
13:26:31 <jmcarthur> it already works with bytestring
13:26:43 <Saizan> and other parser combinators do as well
13:26:46 <dmhouse> Yeah, I mean a few summers ago. Sounds like the answer is "yes".
13:27:00 <jmcarthur> but it wasn't just a drop in replacement as you suggest it should be
13:27:14 <jmcarthur> it wouldn't have been a SoC proposal if it was
13:27:32 <Saizan> well, that's not fair
13:27:49 <jmcarthur> is it?
13:27:56 <Saizan> since the SoC proposal was about making the parsec monad a transformer
13:28:01 <jmcarthur> ah
13:28:05 <Saizan> and to make it generic in the sequence type
13:28:17 <Saizan> not just convert String to ByteString
13:28:18 <jmcarthur> well i didn't realize that
13:28:27 <Peaker> dmhouse, I've only heard of it
13:28:41 <Peaker> jmcarthur, did you use ListLike with ByteStrings? Is it usable?
13:28:49 <jmcarthur> i mean i know that parsec supports that but i didn't know how much of that was due to SoC
13:29:07 <jmcarthur> Peaker: i have not used ListLike
13:29:28 <dmhouse> Look, I'm not suggesting that you can literally replace all instances of String with ByteString and be done with it. However I suspect that for the majority of code that does a lot of high-performance String stuff, and especially String I/O stuff, it is very simple to switch to ByteString.
13:29:34 <jmcarthur> Peaker: but i'm not impressed by the docs. doesn't look like it gives you much slack when writing instances
13:30:08 <jmcarthur> dmhouse: perhaps for some things. i've ported a few things from String to ByteString and it has always given me more trouble than expected
13:30:27 <Peaker> jmcarthur, I mean just as a pain-relief for the pain of using BS
13:30:29 <jmcarthur> really ByteString is a poor replacement for String anyway though since it doesn't even give the same results
13:30:41 <jmcarthur> Text is better in that regard, i'm sure
13:30:45 <jmcarthur> i've not used Text though
13:31:03 <jmcarthur> Peaker: i haven't. i'm not sure how much relief it would actually give you
13:31:35 <kmc> ByteString is not a replacement for String.  it's a replacement for various inappropriate uses of String
13:31:36 <Saizan> Peaker: can you be more specific about the pain? i import something qualified and that's it
13:31:42 <jmcarthur> kmc: exactly
13:32:03 <kmc> "linked list of Unicode character points" and "contiguous array of bytes" are not very similar data types
13:32:33 <cocon> how come 'Either a' is not an Alternative?
13:32:53 <Saizan> cocon: no empty
13:32:54 <jmcarthur> cocon: what is empty supposed to do?
13:32:55 <kmc> cocon, what's the empty element?
13:33:00 <jmcarthur> heh
13:33:10 <kmc> you could have (Monoid a) => Alternative (Either a)
13:33:23 <jmcarthur> would that actually obey the laws?
13:33:30 <kmc> what are the laws?
13:33:32 <mornfall> Maybe (Either a)?
13:33:36 <jmcarthur> monoid laws
13:33:40 <kmc> mornfall, kind error
13:33:46 <mornfall> Err. :D
13:33:47 <dmhouse> kmc: that's implied by the MonadPlus m => Alternative m instance
13:33:50 <mornfall> Of course...
13:33:53 <kmc> dmhouse, ok
13:34:06 <EvanR-work> Maybe (Either a) is a kind error?
13:34:16 <kmc> dmhouse, but there's no such instance; only a WrappedMonad m
13:34:20 <kmc> EvanR, yes
13:34:21 <cocon> ok wrong type class, but I just want the '<|>'...
13:34:22 <kmc> :k Maybe
13:34:23 <mornfall> I guess you can't say Maybe . Either a :))
13:34:23 <lambdabot> * -> *
13:34:26 <kmc> :k Either Char
13:34:27 <lambdabot> * -> *
13:34:32 <jmcarthur> dmhouse: Alternative doesn't require MonadPlus though, so that's maybe an inaccurate way of stating why the laws are the way they are
13:34:45 <kmc> mornfall, you can encode functor composition but there is annoying wrapping and unwrapping
13:34:55 <mornfall> kmc: I can imagine.
13:34:57 <dmhouse> kmc: well, fine, I was speaking up to isomorphism
13:35:15 <jmcarthur> empty <|> a ==  a <|> empty == a   and   (a <|> b) <|> c == a <|> (b <|> c)
13:35:26 <EvanR-work> you cant put a data structure in a maybe?
13:35:31 <Saizan> cocon: you can make the instance if you restrict the error type to something suitable
13:35:34 <Peaker> Saizan, Well, various modules use BS vs LBS
13:35:35 <jmcarthur> EvanR-work: huh? sure you can
13:35:38 <kmc> EvanR-work, ?
13:35:39 <Peaker> Saizan, And I have to manually convert
13:35:41 <k23z__> EvanR-work: main star
13:35:44 <EvanR-work> Just(Left 0)
13:35:44 <k23z__> uh
13:35:46 <dmhouse> jmcarthur: I meant that the Monoid a => Alternative (Either a) instance is implied by the MonadPlus m => Alternative m instance
13:35:53 <k23z__> any Haskell tutorials worth watching ?
13:35:58 <EvanR-work> i dont understand the kind error
13:35:59 <byorgey> EvanR-work: Either a  expects another type argument still
13:35:59 <k23z__> I mean video tutorials
13:36:06 <Saizan> ?type Just (Left 0)
13:36:07 <lambdabot> forall t b. (Num t) => Maybe (Either t b)
13:36:10 <kmc> EvanR, (Either a) is not a type.  (Either a b) is
13:36:11 <EvanR-work> oh
13:36:13 <byorgey> Left 0 does not have type Either Int, it has type  Either Int a
13:36:15 <kmc> and Maybe expects a type
13:36:19 <EvanR-work> Maybe (Either a b)
13:36:25 <kmc> yeah that's a type
13:36:30 <kmc> :k Maybe (Either Char Int)
13:36:31 <lambdabot> *
13:36:39 <Peaker> Saizan, And converting lazy->strict and back is annoying (concat . toChunks) and (fromChunks . return) which I can import from bytestring-class or implement somewhere but is more cruft
13:36:51 <jmcarthur> dmhouse: only if there is a Monoid a => MonadPlus (Either a) instance
13:37:00 <mornfall> Peaker: It's also awfully inefficient in a number of cases.
13:37:20 <Saizan> Peaker: ah, you'd like those producers/consumers to be polymorphic in the sequence type?
13:37:23 <jmcarthur> i suppose it's likely that there is
13:37:25 <Peaker> mornfall, When I use ByteString, it's usually because I want to use a package which uses it -- or because I just have a Byte Buffer, and not a unicode buffer, I don't often care about efficiency
13:37:35 <dmhouse> ?instances MonadPlus
13:37:35 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
13:37:36 <Peaker> Saizan, Yeah
13:37:53 <jmcarthur> > mzero :: Either Any a
13:37:54 <Peaker> Saizan, Ideally, [Word8] should work too (even if it is inefficient) :)
13:37:54 <lambdabot>   No instance for (Control.Monad.Error.Class.Error Data.Monoid.Any)
13:37:55 <lambdabot>    arisin...
13:37:58 <chowder> need some help. Is this correct? gauss :: Int , Int -> Int   \    gauss x y = ((x + y) * y)/2
13:38:01 <jmcarthur> oh error
13:38:06 <jmcarthur> > mzero :: Either String a
13:38:07 <lambdabot>   Left ""
13:38:12 <kmc> chowder, no
13:38:18 <byorgey> chowder: gauss :: Int -> Int -> Int
13:38:23 <kmc> chowder, multiple args in a type are written like Int -> Int -> Int
13:38:29 <byorgey> chowder: also, you should use `div` instead of /
13:38:29 <kmc> all but the last type are argument types
13:38:38 <Peaker> chowder, The syntax: gauss x y = ...  is sugar for:  gauss = \x -> \y -> ...
13:38:40 <byorgey> `div` is integer division, / is only floating-point division
13:38:43 <EvanR-work> then theres (Int, Int) -> Int ;)
13:38:49 <chowder> byorgey, that's just my way of saying that there's a newline.
13:38:54 <Peaker> chowder, so the type of gauss is a function that returns a function that returns an Int
13:39:05 <byorgey> chowder: no, I mean in the definition of gauss
13:39:12 <chowder> Peaker, gauss is a function that takes two Ints and returns an Int
13:39:12 <byorgey> chowder: should be  ((x + y) * y) `div` 2
13:39:31 <chowder> byorgey, I see. Is that for readability?
13:39:33 <Peaker> chowder, Yes, in Haskell, taking 2 Ints  is typically represented as:  Int -> (Int -> ...)
13:39:39 <byorgey> chowder: no, it's for correctness! =)
13:39:44 <byorgey> chowder: / does not apply to Ints
13:39:45 <Peaker> chowder, Which is the same as   Int -> Int -> ...
13:39:49 <hpc> Int != Float
13:39:50 <byorgey> > (3 :: Int) / (5 :: Int)
13:39:51 <jmcarthur> chowder: you are mistaken. gause takes an Int and returns a function that takes an Int and returns an Int
13:39:51 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
13:39:52 <lambdabot>    arising from a use o...
13:39:52 <Peaker> chowder, because -> is right-associative
13:39:53 <EvanR-work> chowder: not just for readability
13:40:14 <EvanR-work> chowder: you can use curried functions to do convenient stuff
13:40:15 <jmcarthur> *gauss
13:40:23 <chowder> I'm used to OO programming so I'm quite confused. :(
13:40:29 <EvanR-work> > map (+2) [1,2,3,4]
13:40:30 <lambdabot>   [3,4,5,6]
13:40:40 <jmcarthur> OO and haskell aren't mutually exclusive
13:41:03 <chowder> jmcarthur, well I've never done any functional programming.
13:41:09 <byorgey> chowder: you don't have to worry about the currying stuff for the moment.  For now, just know that the types of multi-argument functions are written like arg1 -> arg2 -> arg3 -> ... -> result
13:41:11 <hpc> @where lyah
13:41:11 <lambdabot> http://www.learnyouahaskell.com/
13:41:28 <hpc> read that and many of your newbie questions should be answered
13:41:38 <hpc> plus you will get comfortable with FP
13:42:06 <chowder> byorgey, I see. I always thought that it was INPUT -> OUTPUT
13:42:18 <EvanR-work> it is
13:42:25 <byorgey> chowder: well, it is.  this is where the currying comes in =)
13:42:27 <EvanR-work> thats where the currying comes in ;)
13:42:31 <byorgey> it turns out they are sneakily the same.
13:42:35 <kmc> chowder, a function of "two arguments" is a function that takes one argument, and returns a function to take the second argument
13:42:38 * EvanR-work steals his quip back from byorgey 
13:42:46 <kmc> chowder, in this way all Haskell functions really have exactly one argument
13:42:56 <kmc> and so (A -> B -> C) is one way to write (A -> (B -> C))
13:43:23 <kmc> a function that takes A, and returns a function which then takes B, and then does the actual work
13:43:40 <chowder> I think I'm getting it
13:43:45 <kmc> encoding multi-argument functions this way is called "currying" and it's the standard way to encode multi-arg functions in Haskell
13:43:54 <kmc> though another way is to have a function take a tuple argument
13:43:56 <cocon> Saizan: thanks
13:44:39 <jmcarthur> but tuple arguments can get annoying fast once you are used to currying
13:44:41 <chowder> how would I handle commandline args? like if someone were to type ./gauss 1 8
13:44:50 <IceDane> and currying enables you to use pointfree :P
13:44:51 <jmcarthur> chowder: System.IO.getArgs
13:44:53 <kmc> chowder, using getArgs
13:44:58 <jmcarthur> err
13:45:07 <jmcarthur> System.Environment.getArgs, actually, i think
13:45:11 <jmcarthur> not System.IO
13:45:14 <EvanR-work> :t getArgs
13:45:14 <kmc> "import System" should be enough
13:45:15 <lambdabot> Not in scope: `getArgs'
13:45:23 <kmc> chowder, getArgs is not a function.  it's a different kind of thing, an "IO recipe"
13:45:24 <jmcarthur> @hoogle getArgs
13:45:24 <lambdabot> System.Environment getArgs :: IO [String]
13:45:26 <kmc> chowder, have you used those?
13:45:28 <jmcarthur> yeah, Environment
13:45:39 <chowder> kmc, haven't used import
13:45:39 <jmcarthur> kmc: is System in base, or just haskell98?
13:45:44 <kmc> jmcarthur, don't know
13:45:45 <kmc> chowder, ah
13:45:58 <kmc> chowder, you should probably learn more before you try to use command line args
13:46:10 <Peaker> one thing that's fun about Python, btw, is that each and every trade-off between usability and performance, they choose usability.. This of course has a downside, but sometimes there are painful things in Haskell where I wish it was less performance, more usability
13:46:11 <kmc> chowder, this is a good intro to doing IO: http://haskell.org/haskellwiki/Introduction_to_IO
13:46:15 <monadic_kid> from my experience what i've noticed so called "OO" code +90% of the time is really only modular programming.
13:46:16 <chowder> kmc, my background in programming comes from Java, Perl, and some BASH. I'm still very much a newbie.
13:46:32 <Peaker> monadic_kid, I totally agree :)
13:46:39 <jmcarthur> monadic_kid: and even "modular" is pushing it
13:46:58 <jmcarthur> considering how many classes tend to be tightly coupled
13:47:04 <IceDane> chowder: You have a good book you're reading?
13:47:08 <IceDane> Or learnyouahaskell?
13:47:17 <EvanR-work> making things truly generic in c++ is a royal pain
13:47:25 <EvanR-work> its basically a joke principle of c++ oop
13:47:47 <IceDane> I know from personal experience that coming from the oh-so common imperative/OO languages to haskell isn't very easy
13:47:48 <kmc> c++ is a terrible language for doing oop
13:47:50 <EvanR-work> no real project should do that
13:47:52 <EvanR-work> in c++
13:47:54 <kmc> you have to expose so many details
13:48:15 <chowder> IceDane, I've only been reading learnyouahaskell
13:48:22 <kmc> IceDane, the irony i think is that Haskell has a clearer treatment of imperative programming than those languages do
13:48:31 * twink is probably not the best person to ask about imperative -> FP/Haskell changeovers
13:48:41 <IceDane> kmc: Really?
13:48:50 <kmc> IceDane, yes
13:48:50 <IceDane> With the do notation and stuff?
13:48:55 <kmc> IceDane, "do" notation is superficial
13:48:58 <Peaker> chowder, a -> (b -> c)   is something that may generate a different function (b -> c) for each "a" it is given.  So the "c" there actually depends on both the value of "a" (because it dictates which (b->c) will be used), and of "b" because the (b -> c) uses it to compute the "c"
13:49:02 <hpc> i had no problem with a Java/C++ -> Haskell transition
13:49:02 <IceDane> Monads, then?
13:49:11 <kmc> IceDane, it wouldn't necessarily be monads
13:49:17 <kmc> IceDane, and not all monads are about imperative programming
13:49:20 * scree makes a mental note never to ask twink about imperative -> FP/Haskell changeovers
13:49:28 <kmc> IceDane, most languages confuse at least three ideas together: argument dependence, side effects, and delayed evaluation
13:49:34 <kmc> IceDane, Haskell has separate mechanisms for all three
13:49:35 <Peaker> chowder, so (a -> (b -> c)) is said to be a function of 2 args ("a" and "b") that results in "c".  You can also say it's a function of 1 arg returning another function of 1 arg
13:49:41 <IceDane> I see
13:49:49 <kmc> IceDane, and so it's a better functional language, *and* a better imperative language, *and* a better lazy language
13:50:01 <IceDane> Ah, I think I get what you mean
13:50:13 <kmc> IceDane, functional programs use functions to manipulate data.  one of many data types we can manipulate is "sequence of imperative steps"
13:50:24 <kmc> the fact that it's treated as a data type of its own, and not lumped in with something else
13:50:28 <kmc> is why Haskell is a good imperative language
13:50:48 <chowder> Peaker, I see
13:50:51 <kmc> it's also worth noting that many of the gripes about C++ and Java are about the poor expressiveness and design flaws of those particular languages
13:51:00 <kmc> not conceptual problems of the paradigms they claim to support
13:51:28 <kmc> higher-order imperative programming, using actions and functions  to compute more actions and functions, should be totally common and unsurprising by now
13:51:36 <monadic_kid> I don't know but when ever I need to extend a class or implement an interface is when ever I'm forced typically by an OO GUI, I really can't remember any other time except for C++ abuse since I use class inheritance for different purposes there
13:51:38 <kmc> but it's such a royal pain in C++ and Java that it's seen as an esoteric feature still
13:52:17 <EvanR-work> gui is like the only use of oop
13:52:24 <kmc> i disagree
13:52:30 <IceDane> Game programming lends itself to it pretty well
13:52:32 <IceDane> no?
13:52:35 <kmc> lots of things do
13:52:36 <EvanR-work> its a big gui
13:52:42 <IceDane> EvanR-work: Heh, perhaps
13:52:50 <hpc> game programming in C++ is surprisingly smooth
13:52:53 <kmc> i've written lots of OO code in Haskell and none of it had to do with GUIs
13:53:06 <Jafet> Object-obsessive programming
13:53:07 <monadic_kid> IceDane: not necessarily, I work in the industry
13:53:39 <Peaker> chowder, (a -> b -> c)  could possibly be interpreted as either ((a -> b) -> c)  or (a -> (b -> c)) -- Haskell chose the latter (a -> (b -> c)) because using functions that return new functions to represent the notion of multiple arguments turns out to be extremely useful
13:53:54 <IceDane> monadic_kid: I was mainly referring to how in a game it makes sense to have a hierarchy of objects
13:54:00 <Peaker> chowder, so to say you take 2 Ints and return an Int, you just say:  Int -> Int -> Int
13:54:03 <monadic_kid> kmc: depends on what you mean by OO
13:54:07 <kmc> functions that take functions turns out to *also* be extremely useful, but perhaps deserves the more explicit syntax
13:54:17 <kmc> indeed, people mean many  things by OO
13:54:18 <Peaker> kmc, Not as useful as functions that return functions
13:54:26 <EvanR-work> IceDane: i dont think that is the best way to do it
13:54:27 <chowder> Peaker, yea, I changed it to that
13:54:45 <EvanR-work> game elements dont really need to be objects, just data
13:54:49 <Peaker> chowder, It's important to understand why you changed it, though :-)
13:54:55 <kmc> what i mean in this case is bundles of different data and functions conforming to a common interface, which is the only thing exposed to the user
13:54:56 <monadic_kid> IceDane: depends on what aspect you mean and you really want to avoid any hierarchy to be frank
13:55:11 <IceDane> monadic_kid: How come?
13:55:11 <Peaker> I think the "official" OO definition was: 1. Encapsulation 2. Inheritance 3. Polymorphism
13:55:13 <kmc> and an ordinary record type, or an existentially-quantified record type, is a fine way to encode this in Haskell
13:55:19 <kmc> http://www.paulgraham.com/reesoo.html
13:55:23 <kmc> 9 points there
13:55:33 <monadic_kid> IceDane: first you need to tell me what aspect you're talking about
13:56:23 <chowder> Peaker, oh I agree 100%. I'm very determined on learning haskell.
13:56:40 <kmc> many OO languages enforce this rule "new behavior => new type".  but with functional programming it's a pointless rule, since behaviors are just functions
13:57:02 <kmc> and so the "classes" of traditional OO together with their constructors become ordinary Haskell functions, and are fully higher-order and abstractable as such
13:57:10 <kmc> and the "interfaces" become types, possibly with an existential quantifier
13:57:20 <kmc> and "inheritance" can be done just by one ctor calling another
13:57:28 <kmc> (the oo ctors, not the adt ctors)
13:57:33 <Peaker> chowder, Haskell's function type (->) has only functions of 1 argument, and having multiple arguments is implemented on top of this (rather than as a primitive). This allows for some really neat things
13:58:23 <Peaker> kmc, Interface inheritance is just record instantiation or typeclass instances, Implementation inheritance is just a function that returns a record
13:58:33 <kmc> yeah
13:58:51 <kmc> and you lose the requirement that new "methods" have to be declared in a new "type"
13:58:56 <kmc> or "class" rather
13:59:16 <kmc> you can do that all without type classes at all
13:59:27 <kmc> and i think type classes are overused by some Haskell beginners with OO background
13:59:32 <kmc> because they haven't realized this yet
14:00:07 <monadic_kid> IceDane: in any case most games, especially those written for consoles I not written in a traditional OOP style code. If you was having an interview you was asked how to deal with cross-platform code across many platforms and your solution was traditional OO based one you're most likely not going to get the job
14:01:12 <Peaker> btw: One nice consequence of the OO method grouping in a class is that IDE's can often offer you a bunch of functions that can do things with the data at hand.. Haskell IDE's still don't have type-aware completions (afaik) which would be better, so currently Haskell is worse in this sense, even though it could/should be better
14:01:30 <kmc> yeah, that's just a matter of Haskell IDEs being crap
14:02:13 <Peaker> indeed :)
14:02:41 <hpc> you don't really need an IDE though
14:02:42 <kmc> also that feature caters to a limited mindset which is basically first-order
14:03:02 <kmc> the set of things you can do with a value is a finite set fixed at compile time and each one has a name
14:04:02 <gwern> real programmers need no IDE!
14:04:04 <EvanR-work> class cat { method meow(){}; method sleep(){}: }
14:04:11 <kmc> using Scheme syntax, for an application (a b c d ...), in C++ or Java, 'a' will almost always be a name
14:04:29 <kmc> in Haskell (or Scheme) it is much more likely to be an application itself, or a variable bound locally rather than globally
14:05:02 <QtPlatypus> kmc: Though being a lisp-1 tends to encorage this.
14:05:18 <kmc> yeah
14:05:19 <fax> in common lisp it has to be a name (with a few exceptions) in scheme it can be any expression
14:06:02 <Jafet> In other words, you fly first class
14:06:56 <timofonic> Are there a programming language where you can redefine mostly all parts of it easily? :)
14:07:01 <chowder> Peaker, I see
14:07:11 <kmc> timofonic, parts in what sense? syntax? semantics?
14:07:14 <timofonic> It could make all dialects to disappear
14:07:19 <timofonic> kmc: All that, yes
14:07:25 <kmc> timofonic, Scheme and LISP have very flexible syntax
14:07:26 <fax> art of the metaobject protocol
14:07:55 <timofonic> kmc: So?
14:07:59 <timofonic> kmc: And the rest?
14:08:24 <kmc> i suppose, if you can redefine syntax, you can redefine semantics, by mapping old syntax onto new semantics
14:08:57 <timofonic> kmc: I see
14:09:27 <timofonic> kmc: Interesting to know.. :)
14:09:34 <EvanR-work> how do i convert an Integer into an Int so that if Integer is > maxBound :: Int, returns maxBound
14:09:36 <timofonic> Going to sleep, I'm tired. See you
14:09:37 <EvanR-work> (ceil)
14:09:41 <kmc> timofonic, if you are interested in very flexible languages, learn Scheme and LISP
14:09:53 <fax> what do you mean by LISP
14:10:01 <hpc> Scheme is LISP
14:10:15 <fax> I would say Common Lisp but maybe you dont mean that exactly
14:10:23 <fax> although I don't think there's much out there ...
14:11:00 <Zao> EvanR-work: Grab maxBound :: Int as Integer, compare to your number, return either maxBound or your number converted to int?
14:11:07 <QtPlatypus> fax: Other then scheme the other lisps that are extant are elisp, autocad lisp and closure.
14:11:22 <kmc> elisp sucks balls
14:11:24 <kmc> i am told
14:11:30 <kmc> clojure (?) is cool
14:11:41 <kmc> i am sure there are many other extant lisps
14:11:45 * QtPlatypus has no clue how to spell it.
14:11:45 <kmc> you forgot the main one, Common LISP
14:12:12 <QtPlatypus> kmc: fax already mentioned common lisp.
14:12:16 <kmc> ok
14:12:20 <fax> why do you keep writing LISP!
14:12:26 <kmc> my bad
14:12:36 <pickles> there's also arc and qi
14:13:00 <fax> when I said there was not much out there, I was trying to imply that {arc,qi,clojure,autocad,elisp} were all rubbish :P
14:13:04 * QtPlatypus doesn't think highly of arc and is unsure if its implemented anywhere.
14:13:20 <EvanR-work> Zao: right, in a smaller expression?
14:13:21 <kmc> there is an arc implementation in lisp that compiles to lisp, i believe
14:13:28 <kmc> fax, why is clojure rubbish?
14:13:59 <Jafet> autocad lisp is a living reminder that list processing is not a defining characteristic of lisp
14:14:39 <pickles> is autolisp around even in the newest versions?
14:15:02 <QtPlatypus> pickles: I believe so.  There are alot of 3rd party tools that depends on them.
14:15:28 <pickles> mm
14:15:30 <Zao> EvanR-work: Convert maxBound to Integer, return min(i, mb) converted to Int?
14:15:48 <QtPlatypus> There are also the decendants of lisp such as the P* languages.
14:16:03 <Jafet> Well, autolisp isn't worse than many alternatives
14:16:04 <pickles> +++
14:16:16 <twink> QtPlatypus: P* languages? Don't sound familiar.
14:16:16 <pickles> sry, kb hit the chair arm
14:16:43 <QtPlatypus> twink: Perl, Python, PHP, javascript
14:17:02 <EvanR-work> Zao: yeah, guess no built in for it :(
14:17:05 <twink> QtPlatypus: Oh boy. I was expecting Prolog.
14:17:10 <kmc> heh
14:17:18 <pickles> i've heard rebol is lispish if you look for it
14:17:29 <kmc> every language is
14:17:56 <jmcarthur> lisp is the chicken of programming languages
14:17:59 <pickles> ... wasn't lisp the first to have if/then/else? or was that ada...
14:18:02 <jmcarthur> everything tastes like it
14:18:18 <EvanR-work> fortran?
14:19:23 <Peaker> kmc, elisp is dynamically scoped
14:19:41 <kmc> might have been algol
14:20:08 <Peaker> yairchu says: "Lisp is the best language in the world -- you just have to implement that best language first, before you can use it"
14:20:15 <pickles> ah, i mean algol, not ada (i think...)
14:20:38 <Peaker> Implementing Haskell as a bunch of Lisp macros would be painful(!!)
14:20:41 <EvanR-work> Zao: i got this ceil x = fromIntegral $ min x (fromIntegral (maxBound :: Int))
14:20:59 <monadic_kid> EvanR: use toInteger
14:21:07 <EvanR-work> ceil :: Integer -> Int
14:21:17 * k23z__ steals monad from monadic_kid 
14:21:26 <monadic_kid> :t toInteger
14:21:28 <lambdabot> forall a. (Integral a) => a -> Integer
14:21:54 <EvanR-work> so im not converting anything to integer except maxBound :: Int
14:21:54 <Peaker> @type \f x y -> fromIntegral (f (fromIntegral x) (fromIntegral y))
14:21:55 <lambdabot> forall a b a1 b1 a2 b2. (Integral a, Num b, Integral a1, Num b1, Integral a2, Num b2) => (b -> b1 -> a2) -> a -> a1 -> b2
14:22:13 <monadic_kid> EvanR: use toInteger for maxBound
14:22:31 <EvanR-work> what do you want me to use toInteger on?
14:22:32 <Peaker> @let inIntegral f x y = fromIntegral $ f (fromIntegral x) (fromIntegral y)
14:22:33 <lambdabot>  Defined.
14:22:50 <Peaker> @type inIntegral min maxBound
14:22:51 <lambdabot>     Ambiguous type variable `a' in the constraints:
14:22:51 <lambdabot>       `Integral a'
14:22:51 <lambdabot>         arising from a use of `inIntegral' at <interactive>:1:0-22
14:23:31 <monadic_kid> > fromIntegral $ min (fromIntegral (maxBound :: Int)) (0 :: Integer)
14:23:32 <lambdabot>   0
14:23:56 <EvanR-work> thats what ive got
14:24:09 <monadic_kid> > fromIntegral $ min (toInteger (maxBound :: Int)) (0 :: Integer)
14:24:09 <lambdabot>   0
14:24:22 <EvanR-work> whats the difference
14:24:31 <Zao> EvanR-work: Note that ceil is normally used for rounding up floating point numbers.
14:24:36 <Zao> EvanR-work: You might want some other name.
14:24:40 <EvanR-work> right i need to put a different name
14:24:45 <monadic_kid> > fromIntegral
14:24:46 <EvanR-work> i just happen to not have ceil in scope
14:24:46 <lambdabot>   {-3->-3;-2->-2;-1->-1;0->0;1->1;2->2;3->3}
14:24:53 <monadic_kid> :t fromIntegral
14:24:54 <lambdabot> forall a b. (Integral a, Num b) => a -> b
14:24:58 <monadic_kid> :t toInteger
14:24:59 <lambdabot> forall a. (Integral a) => a -> Integer
14:25:12 <EvanR-work> its more specific
14:25:21 <monadic_kid> you want to convert Int -> Integer so toInteger
14:25:34 <EvanR-work> ok
14:27:26 <EvanR-work> it would be simpler if all these system functions didnt take Int ;)
14:27:57 <Peaker> I wish they were all "Integral a =>" too.. perhaps with a pragma that says "specialize for each type" (behave like a C++ template)
14:29:39 <EvanR-work> :t 5
14:29:40 <lambdabot> forall t. (Num t) => t
14:29:50 <hpc> :t min
14:29:51 <lambdabot> forall a. (Ord a) => a -> a -> a
14:30:10 <hpc> :t inIntegral
14:30:11 <lambdabot> forall b1 b2 a a1 a2 b. (Integral a, Num b, Integral a1, Num b1, Integral a2, Num b2) => (b1 -> b2 -> a) -> a1 -> a2 -> b
14:30:12 <EvanR-work> if you never specify the types, what will your number literals be treated as?
14:30:25 <EvanR-work> or is that an error
14:30:35 <hpc> they will be infered by subsequent calls
14:30:59 <monadic_kid> it's nice that literals are treated as Num a
14:31:00 <EvanR-work> what if you only use Num a => functions
14:31:11 <monadic_kid> > 1
14:31:12 <lambdabot>   1
14:31:17 <monadic_kid> :t 1
14:31:18 <lambdabot> forall t. (Num t) => t
14:31:21 <hpc> :t show 1
14:31:22 <lambdabot> String
14:31:24 <hpc> :t show
14:31:25 <lambdabot> forall a. (Show a) => a -> String
14:31:28 <monadic_kid> :t (1 :: Double)
14:31:28 <lambdabot> Double
14:31:35 <monadic_kid> :t (1 :: Float)
14:31:35 <lambdabot> Float
14:31:42 <hpc> > (1 :: Double)
14:31:43 <lambdabot>   1.0
14:31:55 <hpc> numbers must be a special case
14:32:06 <hpc> it just magically picks the right one
14:32:21 <EvanR-work> if its completely ambiguous i thought i read that it chooses Integer
14:32:31 <EvanR-work> either that or logically it gives an ambiguous type errror
14:33:13 <monadic_kid> is it really magically? I don't think so. Unification infers with type-classess, a type inferred language without type-classess would just infer int
14:33:16 <Peaker> There's the "default type" thing in Haskell (Yuck) - where you can specify a list of default types to choose for a typeclass when it's ambiguous.. It's even a keyword "default"
14:34:09 <EvanR-work> thats for number literals?
14:34:15 <jmcarthur> it's nasty
14:34:55 <jmcarthur> :t show (?1)
14:34:56 <lambdabot> Not in scope: `?'
14:35:21 <kmc> :t show ?a
14:35:22 <lambdabot> forall a. (?a::a, Show a) => String
14:35:26 <jmcarthur> oh duh
14:35:35 <jmcarthur> and of course that's not what i intended
14:36:41 <mreh> is anyone familiar with the spectrum kernel?
14:37:01 <kmc> no idea what that is
14:37:11 <mreh> kernel methods?
14:37:18 <mreh> and the kernel trick?
14:38:32 <mreh> I have to take the inner product of two vectors projected into a feature space, a kernel, the kernel trick is an efficient way of computing that indirectly
14:38:42 <kmc> right
14:38:48 <kmc> you combine your kernel with your inner product
14:38:48 <kmc> somehow
14:39:06 <Associat0r> why is noone using DDC Haskell?
14:39:23 <kmc> you mean the compiler for Disciple?
14:39:26 <kmc> which is not Haskell?
14:40:10 <mreh> the spectrum kernel projects strings into a feature space of all the possible substrings of length k
14:40:13 <HugoDaniel> hey
14:40:23 <mreh> you can do the inner product cheaply by comparing substrings
14:40:44 <mreh> I'm reading a paper that says you can do this in O(length(x) + length(y))
14:40:56 <mreh> i'm sure that should be a times, not a plus
14:41:08 <hpc> i think it means the more complex of the two
14:41:49 <mreh> to compare substrings is a O(n^2) operation, with n the length most complex string, right?
14:43:04 <pflanze> I forgot the name of the combinator that changes the order of arguments of a binary function
14:43:27 <tromp_> flip
14:43:28 <dankna> flip
14:43:32 <pflanze> ah yep, thanks
14:43:49 <Associat0r> kmc: then what is it?
14:45:23 <Nebasuke> Associat0r: well I also wondered, because the concept used for typing effects seemed quite promising.
14:45:31 <Nebasuke> although I still have to read the rest of his thesis
14:46:48 <mreh> maybe they're assuming and average case time complexity
14:47:02 <mreh> seems reasonable
14:50:09 <kmc> Associat0r, Disciple is a programming language.  It's not the same language as Haskell
14:51:19 <Nebasuke> well it's more of a Haskell dialect right?
14:51:31 <fax> yeah sure
14:51:32 <tensorpudding> isn't disciple still in the embryonic stage?
14:51:36 <Associat0r> kmc: I know not the same but it's based on it
14:51:47 <kmc> sure
14:52:50 <lowasser> How do I upgrade the containers package for my own GHC without breaking everything?
14:56:02 <ivanm> lowasser: you don't
14:56:18 <lowasser> damn
14:56:20 <FunctorSalad> last time I checked it was particularly impossible with TH ;) not sure about containers
14:56:21 <ivanm> lowasser: the only library that comes with GHC that's safe to upgrade is Cabal
14:56:28 <FunctorSalad> oh
14:56:31 <lowasser> alternative approach:
14:56:34 <ivanm> lowasser: why do you want to?
14:57:08 <lowasser> ivanm: things like "Data.Map could seriously use some rewrite rules to make it fold/build better"
14:57:24 <ivanm> did they add that to the latest containers?
14:57:28 <lowasser> "the current Foldable instance is crappy"
14:57:39 <lowasser> and no, they didn't =(
14:58:02 <ivanm> sooo.... upgrading containers won't make a difference
14:58:22 <lowasser> well, writing my own modifications to containers would fix it, if I could safely install it
14:58:37 <lowasser> hence my original question
14:58:52 <ivanm> and what's so bad about the Foldable instance for Data.Map?
14:59:09 <ivanm> lowasser: suggest your changes to the libraries list for the next version
14:59:14 <lowasser> it only defines foldMap, even though it'd be trivial to define foldr in terms of foldWithKey
15:00:15 <ivanm> lowasser: is the explicit foldr definition any better than the default implementation?
15:00:23 <lowasser> considerably so
15:00:45 <nostrand> Walt: ^^
15:00:54 <Walt> hey
15:04:08 <k23z__> bag of chips
15:07:32 <IceDane> AnAdorableNick: Hey, you asked me to let you know if your tutorial helped me out, and I can't say that it didn't(I'm still going through it) but there are a lot of inconsistencies
15:07:39 <IceDane> and even code that doesn't compile
15:08:23 <AnAdorableNick> IceDane: I see.  What doesn't compile?
15:08:45 <IceDane> I actually can't recall it right now, as I fixed it and compiled it yesterday
15:08:54 <IceDane> but it was an Int vs Integer mistmatch, iirc
15:09:17 <IceDane> But the inconsistencies are mainly mixes with StateType and then State, and some other stuff
15:13:00 <IceDane> AnAdorableNick: But it's probably the best resource I've had on it. What I needed was precisely what your tutorial provides; simple but practical examples
15:13:09 <IceDane> in rwh and the haskell wiki, it's all theoretical
15:13:25 <IceDane> It just tells you "this shit happens" which might work for some people, but seeing it in practice is needed by others
15:15:40 <AnAdorableNick> IceDane: Thanks :)  I apologize for the inconsistencies and the code that doesn't compile; I'll fix those when I have the time.
15:15:49 <IceDane> It's no problem
15:23:39 <AnAdorableNick> My tutorial, http://strabismicgobbledygook.wordpress.com/, doesn't even appear on Google.  I'd like to publicize it a bit more.
15:26:46 <sepp2k> What's an easy way to make a parsec parser accept newlines as an alternative to semicolons when you usually eat up all whitespace?
15:29:20 <Gracenotes> have you guys seen the Haskell article in the April 2010 Communications of the ACM? :)
15:29:38 <hpc> link?
15:29:51 <Gracenotes> by Sergio Antoy and Michael Hanus
15:30:04 <aavogt> sepp2k: parsec has this lexer for haskell-style-syntax I believe
15:30:05 <Gracenotes> not sure, I have a physical copy in the front of me
15:30:05 <pickles> sepp2k: are you writing your own white space consuming function?
15:30:13 <hpc> ah
15:30:17 <pickles> or using the built in?
15:30:33 <Gracenotes> needs an account :(   http://cacm.acm.org/magazines/2010/4/81495-functional-logic-programming/fulltext
15:30:59 <sepp2k> pickles: No, I use functions from parsec like e.g. symbol and identifier, which consume trailing whitespace.
15:31:32 <pickles> ah, i've been defining my own
15:31:42 <pickles> for more control
15:32:00 <pickles> you might try that, it's pretty easy
15:32:06 <hpc> with javascript off, it shows the whole thing
15:32:30 * hpc reads
15:32:45 <pickles> sepp2k: depending on how you're doing things, you might try sepBy or endBy and give it a custom fn as the separator
15:33:13 <pickles> sepp2k: RWH has an example newline parser fn that i've bene using
15:33:38 <pickles> you might try something like: eol <|> char ';'
15:33:57 <pickles> (eol being their newline parser)
15:34:12 <sepp2k> pickles: That can't work if the linebreak has alread been consumed, can it?
15:34:31 <pickles> right
15:34:39 <pickles> so you'd probably have to do a whitespace function too
15:34:55 <pickles> ws = skipMany (oneOf " \t")
15:36:19 <pickles> ofc if the built-ins consume that already, then you'd have to define your own of those, etc
15:36:45 <sepp2k> Yeah, the thing is, I usually want to skip \n as well. Just not in cases where I'm expecting a ;. And yes, I was trying to avoid redefining all the built-ins.
15:37:41 <pickles> hm...
15:37:55 <pickles> so are you wanting to use ; as a whitespace character then?
15:38:02 <pickles> or does it mean something when parsed
15:38:03 <pickles> ?
15:38:25 <Axman6> anyone know the author of http://unlines.wordpress.com/ is?
15:38:45 <sepp2k> It's supposed to separate expressions. Like in most languages.
15:39:18 <pickles> and im assuming a newline does the same?
15:40:40 <sepp2k> Well in an expression like "1+\n1" it would ideally do nothing, but in cases where a ; would be allowed, \n should be equivalent, yes. I really just want it to work like in other ;-optional languages.
15:41:23 <byorgey> Axman6: I definitely know who it is, but not sure if he hangs out in here, if that's what you're asking
15:41:38 <Axman6> it's Roman Leshchinskiy's
15:41:47 <Axman6> i don't think he hangs out here
15:41:52 <thebloggu> can someone tell me a good easy library to fetch a xml file through url and parse it? not necessarily just one
15:42:07 <byorgey> Axman6: ok, then I don't understand what you were asking.
15:42:18 <pickles> sepp2k: is it necessary that you see it when parsing for you to get a complete expression? if not, you might try the "optional" command: optional (char ';')
15:42:21 <ddarius> I think I've seen him on here occassionally, but I might be thinking of other online venues.
15:42:28 <Axman6> i didn't know who wrote it, couldn't find a name on the blog
15:42:34 <ddarius> preflex: seen rl
15:42:34 <preflex>  Sorry, I haven't seen rl
15:42:45 <byorgey> Axman6: oh, but I guess you found it now =)
15:42:53 <Axman6> yup
15:43:03 <Axman6> on the vector package page
15:43:31 <byorgey> Axman6: ... his name is at the top of every post =)
15:43:44 <Axman6> oh, so it is, heh
15:46:24 <sepp2k> pickles: That also allows things like "a=x+1z=y+2", which I don't really want to allow.
15:46:37 <pickles> ah, right
15:48:22 <pickles> i haven't worked with the built-ins (i've only been rolling my own), so there might be something i dont' know about that would help you
15:51:20 <pickles> (im still pretty n00bish)
15:51:55 <sepp2k> Well, thanks for your help so far.
15:52:34 <pickles> sry i couldn't be of more help
15:55:42 <Gracenotes> hpc: what'd you think?
15:56:12 <hpc> pretty nifty
15:57:22 <Gracenotes> yeah :x
15:59:41 <hpc_> sorry, disconnect
15:59:43 <hpc_> [18:55:46]	<hpc>	pretty nifty
15:59:44 <hpc_> [18:56:31]	<hpc>	i don't quite grok logic programming, but the concept seems useful
15:59:51 <hpc_> if you didn't catch it
16:00:09 <halberd> hey I got a real world algorithms problem
16:00:12 <halberd> anyone interested
16:00:31 <monochrom> I prefer the imaginary world.
16:00:44 <halberd> the deal is this:  we have a set of contracts, each with an effective date and a termination date
16:00:55 <halberd> and a set of procedures, each of which happens on a particular date
16:00:55 <aavogt> you need a queue
16:01:03 <aavogt> make your customers wait in it
16:01:13 <halberd> the goal is to efficiently determine which contracts apply to any given procedure
16:01:22 <halberd> based on their effective and termination dates, and the date of the procedure
16:01:37 <monochrom> Be more sophisticated. Put the customers in a pure-functional min-max heap.
16:01:57 <hpc> is the data coming from a database?
16:02:07 <halberd> yes hpc the data is coming from a database
16:02:23 <halberd> but that's not relevant
16:02:43 <hpc> because you can use where and date functions to filter irrelevant data
16:03:24 <halberd> also not relevant, because it's not that kind of database, and not efficient because a where clause would have to do a linear search
16:03:50 <kaja> Is the Haskell wikibook the recommended book for learning haskell?
16:04:12 <hpc> it would be binary if the field was indexed
16:04:49 <teratorn> kaja: I like the learnyouahaskell.com tutorials pretty much, also
16:04:58 <monochrom> My first attempt. Have two Data.Map's, one from effective date to contract, another from termination date to contract. Given a procedure's date, use the date to look into the two maps for "everything after" and "everything before" respectively, then do some intersection.
16:05:03 <hpc> ugh, this wifi is ridiculous; ima move to something with a wire
16:05:16 <halberd> hpc indexing it would not be sufficient to get a binary search
16:05:32 <halberd> because you have to worry about two dates, effective and termination date, not just one
16:05:59 <kaja> teratorn: i just find it a bit odd that the Haskell wikibook is the recommended one and yet it is incomplete?
16:06:14 <kaja> or is it only extra information which is incomplete
16:06:39 <kaja> "further reading" type stuff
16:06:44 <teratorn> kaja: dunno, I'm relatively new to haskell myself
16:07:36 <tromp_> halberd: you want to find what intervals contain given point?
16:08:03 <halberd> yes tromp_ that is the problem
16:08:22 <tromp_> with any pre-processing?
16:09:22 <halberd> well of course you could do a huge amount of preprocessing and just store for each "sub-interval" between any two endpoints of any two intervals, exactly which intervals fall into that sub-interval
16:09:39 <halberd> but that could be O(n^2)
16:09:44 <halberd> for preprocessing
16:09:50 <kaja> thx.
16:10:02 <halberd> so it would be best to keep the preprocessing down to a minimum, some is alright but that should be efficient too
16:10:03 <tromp_> are you given intervals and points together in one go?
16:10:18 <halberd> no, you get the intervals first and then you have a lot of points to process
16:10:39 <halberd> you process the points one at a time
16:10:42 <tromp_> ok, so you want  to proprcess intervals, but only using O(n) memory
16:10:53 <halberd> well n log n would also be fine
16:10:57 <halberd> but n^2 is bad
16:11:33 <tromp_> http://en.wikipedia.org/wiki/Interval_tree
16:12:38 <halberd> excellent thanks
16:13:35 <tyat> Hi there :). does someone know what is the equivalent in Haskell of Gofer's "at" ? (!!) ?
16:14:49 <monochrom> Oh neat, interval tree exists. :)
16:15:36 <Axman6> tyat: type?
16:16:06 <Axman6> (as in, what type does at have? [a] -> Int -> a?)
16:17:24 <tyat> Axman6: it looks like (!!), doesn't it ?
16:19:09 <tyat> Axman6: the example is : ag `at` a .. I'm sure ag is a list, not sure about the type of a. I'm traslating some examples from a paper..
16:19:45 <chowder> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24995#a24995
16:20:13 <chowder> That gives me the following error: sandbox.hs:17:4: parse error on input `='
16:21:01 <kmc> chowder, the statements within "main" need to be in a "do" block
16:21:07 <kmc> you can add the keyword "do" after "main ="
16:21:18 <kmc> and keep the rest of the formatting
16:21:28 <chowder> brb
16:21:31 <kmc> i have no idea what 'x = System "$1"' is supposed to do
16:21:38 <kmc> or where you got that
16:22:04 <kmc> chowder, you might want something like "x <- readLn"
16:22:22 <lispy> I don't think you can use a module name as a function
16:25:19 <teratorn> can someone help me with a compilation problem? http://codepad.org/Re4rJE3u
16:25:44 <Nebasuke> did you try ghc --make?
16:26:00 <teratorn> I've run "cabal install sdl", which succeeded, but I'm unsure if ghc is finding it since it lives under ~/.cabal
16:26:12 <teratorn> Nebasuke: no
16:26:44 <teratorn> Nebasuke: that works :)
16:27:10 <Nebasuke> ^^
16:27:45 <teratorn> so if I didn't use --make, what would I have to do?
16:27:55 <teratorn> just so I understand what it's doing for me
16:27:58 <lispy> teratorn: -package Foo
16:28:07 <teratorn> ah, I was about to try that :)
16:28:34 <lispy> teratorn: I highly recommend using a .cabal file though :)
16:28:38 <lispy> saves your sanity
16:28:51 <teratorn> alright
16:29:31 <teratorn> where do I read about that?
16:30:02 <lispy> teratorn: http://www.haskell.org/cabal/release/cabal-latest/doc/users-guide/
16:30:09 <lispy> teratorn: and the haskell wiki has examples files
16:30:13 <teratorn> ty
16:30:52 <lispy> teratorn: Another great way, is to visit hackage and read the package description of other programs
16:31:02 <lispy> teratorn: for example: http://hackage.haskell.org/packages/archive/hnop/0.1/hnop.cabal
16:31:21 <teratorn> ah, very good idea
16:40:21 <strobedream> Hey guys. This is probably a stupid question but what does the '$' mean. I tried a google search for "haskell $" and got junk.
16:40:48 <kmc> :t ($)
16:40:49 <lambdabot> forall a b. (a -> b) -> a -> b
16:40:50 <kmc> @src ($)
16:40:51 <lambdabot> f $ x = f x
16:40:54 <kmc> strobedream, it's an infix operator
16:40:59 <kmc> which means the same as function application
16:41:01 <kmc> but has a very low precedence
16:41:06 <kmc> meaning you can write:   f . g . h $ x
16:41:09 <kmc> instead of f (g (h x))
16:41:16 <strobedream> okay.
16:41:41 <strobedream> I was wondering why I hand't seen in in "learn you a haskell for great good"
16:42:02 <syntaxglitch> most of the time, $ is used as an alternative to parenthesizing the end of a line of code
16:42:05 <IceDane> it's in there @ strobedream
16:42:15 <kmc> > zipWith ($) [pred, succ] [3,5]
16:42:16 <lambdabot>   [2,6]
16:42:24 <Mathnerd314> > \f g h x -> f $ g $ h $ x
16:42:25 <syntaxglitch> "blah blah $ blah blah blah" instead of "blah blah (blah blah blah)"
16:42:25 <lambdabot>   {{()->()}->{{()->()}->{{()->()}->{()->()}}}}
16:42:28 <Mathnerd314> > \f g h x -> f . g . h $ x
16:42:29 <lambdabot>   {{()->()}->{{()->()}->{{()->()}->{()->()}}}}
16:42:32 <IceDane> yeah, without it writing haskell would be like writing lisp
16:42:38 <kmc> heh
16:42:41 <syntaxglitch> Haskell programmers hate parentheses for some reason
16:42:43 <Mathnerd314> > \f g h x -> f (g (h (x)))
16:42:44 <lambdabot>   {{()->()}->{{()->()}->{{()->()}->{()->()}}}}
16:43:10 <IceDane> I hate them because they're placed really badly on my keyboard layout, and I haven't gotten myself to use programmer's dvorak
16:43:12 <mun__> in logic, what is the difference between a 'term' and a 'constant'?
16:43:13 <IceDane> though I should eventually
16:43:14 <kmc> @pl \f g h x -> f (g (h (x)))
16:43:15 <lambdabot> (. (.)) . (.) . (.)
16:43:31 <kmc> IceDane, what layout do you use?
16:43:36 <IceDane> kmc: Icelandic
16:43:39 <kmc> aha
16:43:39 <syntaxglitch> basically how it works is "arcane infix operators are good, nested parentheses are bad"
16:43:50 <syntaxglitch> think perl vs. lisp :D
16:44:02 <ddarius> mun__: Um, the specific details can vary, but roughly the difference between an expression and a value.
16:44:02 <kmc> don't think perl ;P
16:44:09 <kmc> because perl's operators are magical built-in syntax
16:44:24 <kmc> haskell has almost no "built in" operators in that sense
16:44:26 <syntaxglitch> right, Haskell is better because you can create your own magical syntax
16:44:35 <IceDane> ^
16:44:38 <kmc> not even that
16:44:44 <kmc> it's better cause you can look up the source code
16:44:48 <mun__> ddarius, i see. so terms are expressions?
16:44:57 <kmc> instead of some man page written in english with extensive perl jargon
16:45:14 <ddarius> mun__: More or less.
16:45:33 <syntaxglitch> kmc, also operator precedence is really the only tricky part
16:45:33 <mun__> ddarius, is 'a ^ b' a term?
16:45:59 <ddarius> mun__: No, that is a formula (usually).  Though, it may be called a term in what you are reading.  It should define it.
16:46:00 <syntaxglitch> piles of infix operators aren't actually any more magical than Haskell code is otherwise
16:46:29 <ddarius> mun__: Usually you have predicates, which are what you are trying to prove and terms which are what the predicates classify.
16:46:41 <syntaxglitch> laziness and higher-order functions obviate most stuff that other languages need magic for anyway...
16:46:44 <strobedream> I heard that the haskell channel was helpfull but I really didn't expect that after spending enough time in C and Java
16:47:30 <Mathnerd314> > (fmap (flip fmap fmap) (fmap fmap fmap))  `asTypeOf` \f g h x -> f . g . h $ x
16:47:31 <lambdabot>   {{()->()}->{{()->()}->{{()->()}->{()->()}}}}
16:47:37 <Mathnerd314> success!
16:48:15 <mun__> ddarius, but, typically, are terms not just variables, functional and non-functional ones?
16:48:30 <kmc> syntaxglitch, true, though every good general-purpose language has higher order functions
16:48:49 <kmc> C++ and Java are specific failures of design; they're not the norm
16:49:18 <c_wraith> kmc:  you say that a lot.  Have you written down somewhere what their design failures are?
16:49:27 <kmc> lack of higher-order functions :D
16:49:44 <Mathnerd314> - overbearing presence of classes
16:49:45 <kmc> the C++ FQA is a pretty detailed account of many of the flaws of C++
16:49:46 <strobedream> kmc: I was just referring to people who hang out in those chat rooms.
16:49:46 <ddarius> mun__: In Prolog, terms are what you pass to predicates, such as lists or trees.
16:49:54 <kmc> strobedream, i know, i wasn't respnoding to you
16:49:59 <strobedream> oh
16:50:01 <ddarius> A variable is a special case of a term.
16:50:04 <kmc> i was responding to syntaxglitch's "higher-order functions" vs "other languages"
16:50:08 * hackagebot hstatistics 0.1.0.1 - Statistics  http://hackage.haskell.org/package/hstatistics-0.1.0.1 (VivianMcPhail)
16:50:09 <theorbtwo> In any case, C++ does arguably have higher-order functions.  They aren't embraced, and are probably second-order at best, but they exist, because C++ is mostly a superset of C.
16:50:11 <ddarius> As are constants.
16:50:16 <syntaxglitch> If you tilt your head and squint your eyes a little bit, objects in general look kinda like higher-order functions, since they let you pass around bundles of functions as methods
16:50:21 <kmc> yeah
16:50:29 <kmc> objects are the poor man's closure and closures are the poor man's object
16:50:41 <kmc> the point is, neither C nor C++ provides syntax for capturing local variables in a closure
16:50:52 <kmc> they require you to do this yourself in an extremely tedious verbose way
16:50:59 <Mathnerd314> aren't functions a poor man's closure?
16:51:00 <kmc> and it's a recognized flaw, which they're fixing in C++1x
16:51:03 <theorbtwo> kmc: Correct, but closures and higher-order functions aren't the same thing.
16:51:07 <mun__> ddarius, i see. thanks.
16:51:18 <syntaxglitch> well, the only time I've touched C/C++ in the last few years has been writing glue code for Haskell FFI bindings
16:51:22 <syntaxglitch> so the memories are slowly fading
16:51:25 <kmc> theorbtwo, a closure is an object in memory which implements a first-class function
16:51:29 <theorbtwo> Interestingly, gcc *does* have closures.  IIRC, in both C and C++.
16:51:46 <kmc> but imo you don't have first-class functions unless they easily close (verb) over free variables, whether or not that is implemented with a closure (noun)
16:51:54 <kmc> theorbtwo, oh?
16:52:03 <bremner> tell us more :)
16:52:04 <kmc> gcc c allows nested function definitions
16:52:05 <theorbtwo> kmc: No, a closure is a function that closes over a variable in it's lexical scope.
16:52:19 <kmc> theorbtwo, that's a different usage
16:52:23 <kmc> i am following Cale's usage :)
16:52:25 <theorbtwo> Ah.
16:52:40 <kmc> gcc's nested functions don't close in a persistent way
16:52:46 <kmc> you can't return a pointer-to-nested-function and get anything sane
16:52:49 <syntaxglitch> I would have figured Cale's usage would have more fmaps in it
16:53:12 * theorbtwo rereads gcc's docs on it.
16:53:21 <strobedream> so what kind of problems and projects seem to lend themselves to haskell.
16:53:37 <bremner> theorbtwo: closures in stack frames are a bit tricky ...
16:54:01 <kmc> strobedream, manipulating symbolic data.  e.g. implementing programming languages, interpreters, compilers, code analysis, etc.
16:54:22 <bremner> so its like lisp, then?
16:54:34 <rerr> buenass
16:54:42 <kmc> strobedream, the biggest industrial successes of Haskell are in using it to implement domain-specific languages for cryptography, financial modeling, embedded systems programming, hardware design, etc.
16:54:57 <theorbtwo> "(Nested functions are not supported for GNU C++.) " "If you try to call the nested function through its address after the containing function has exited, all hell will break loose."
16:55:04 <kmc> Haskell is not much like Lisp in a technical sense
16:55:14 <kmc> they are somewhat similar in what they're good at
16:55:17 <kmc> and also somewhat different
16:55:28 <theorbtwo> On the other hand, in feel, it seems to be somewhat like a typesafe lisp.
16:55:30 <kmc> also, both are general-purpose languages
16:55:31 <syntaxglitch> Haskell also has some popularity for being more amenable to formal analysis of what a program does
16:55:36 <strobedream> kmc: interesting I know one of the professors at my uni has scheme and haskell working in second life.
16:55:45 <kmc> cool strobedream
16:56:16 <strobedream> yeah I get to take his class in summer school and I figured I would get a jump before things started to suck.
16:56:21 <syntaxglitch> theorbtwo, Haskell is a mostly gigantic pile of sugar on top of a typed lambda calculus, whereas lisp is a small pile of sugar on top of the untyped lambda calculus, so yes
16:56:38 <kmc> Haskell is a nice, expressive, multiparadigm general-purpose language; it's good for most tasks
16:56:55 <gwern> @quote paradigm
16:56:56 <lambdabot> lennart says: I think people who come from imperative programming come with a mind set that you understand your code by stepping through it in the debugger.  But I find this paradigm much less
16:56:56 <lambdabot> useful for functional code
16:57:03 <kmc> not real-time code, because nobody has a realistic Haskell implementation that doesn't use garbage collection
16:57:17 <kmc> not the very most performance-critical code, but you can write that in C and call it from Haskell
17:06:30 <chowder> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24997#a24997
17:06:48 <chowder> got an error on above prob
17:06:50 <chowder> *function
17:08:15 <tensorpudding> That's some weird indentation on the do block
17:09:46 <tensorpudding> But the error is that you can't end a do block on a <- binding
17:11:58 <kmc> chowder, you can't end a do block with "y <- ..." because you couldn't possibly use y afterward
17:12:08 <tensorpudding> Also it's poorly typed.
17:12:14 <tensorpudding> It doesn't return ()
17:12:16 <kmc> chowder, the reason for disallowing it (as opposed to a mere "unused variable" warning) relates to how "do" is implemented
17:12:32 <kmc> main is allowed to have any type of the form IO a
17:12:37 <kmc> but the result value is ignored
17:12:44 <tensorpudding> But what does this main return?
17:12:47 <kmc> so i think it's best to put in the sig and make sure to return ()
17:13:01 <chowder> tensorpudding, bear in mind that this is pretty much my first haskell program
17:13:03 <tensorpudding> As far as I can tell it isn't returning anything.
17:13:31 <kmc> chowder, maybe you want "x <- readLn; y <- readLn; print (gauss x y)"
17:13:34 <chowder> kmc, what I want the program to do is just accept two ints to represent a finite range and then return the sum of all numbers within that range
17:13:39 <kmc> oh
17:13:43 <theorbtwo> Why does main have such a permissive type, anyway?
17:13:52 <kmc> x <- readLn; y <- readLn; print (sum [x..y])
17:14:00 <chowder> so it'd be like gauss 1 100 and it should return 5050
17:14:15 <kmc> chowder, not sure how you think the code you pasted would work
17:14:21 <kmc> as "main" does not refer to gauss in any way
17:14:30 <kmc> chowder, also, the string arg to putStrLn should be on the same line as putStrLn
17:15:40 <chowder> kmc, well I'm still a newb. :/ I didn't really expect it to work but I wanted to analyze my errors so I could learn from my mistakes
17:15:43 <tensorpudding> Indentation is meaningful in a do-block, each line must either perform an action and ignore the result or bind a variable from the result of an action
17:16:36 <chowder> I see
17:17:00 <tensorpudding> it gets clearer how it works once you learn how to "desugar" the do-block down into standard Haskell syntax
17:17:23 <chowder> yea, I was reading a guide on haskell syntax but I didn't get much from it
17:17:36 <chowder> I'm more of a hands-on type learner
17:18:29 <chowder> kmc: btw, using sum[x..y] makes the program take forever. I've tried it. The Gaussian method is more efficient.
17:18:55 <pikhq> chowder: Basically what you wrote there would only parse if "do" were a function and <- were a defined operator.
17:19:25 <chowder> yea, one of my friends added the <- because I still don't have a strong grasp of functional programming
17:20:09 <pikhq> It's parsing as 'do putStrLn "Gimme a finite range." x <- readLn y <- readLn', in effect.
17:20:23 <tensorpudding> sum [x..y] does take forever, because it requires y-x recursions
17:20:42 <tensorpudding> it's why the gauss formula is useful :)
17:20:50 <chowder> indeed
17:21:08 <pikhq> Also, do you have any intent to do anything *with* those read lines?
17:21:16 <chowder> I just wanna write a program that I'd call like so: ./gauss 1 100 and get the result
17:21:36 <chowder> pikhq, I'm trying to parse commandline args.
17:21:46 <tensorpudding> The problem is that arg parsing is not as effortless
17:22:43 <tensorpudding> You can use System.Args.getArgs, and use read to coerce the types, but that'll give you nice runtime errors on mismatched types if you try entering something read chokes on
17:23:10 <pikhq> In some vague imperative-like language what you've written (minus typos) comes out to: gauss(x,y){return ((x+y)*y)/2;}main(){printf("Gimme a finite range.\n");x=getline();y=getline();}
17:23:15 <pikhq> Which is... Fairly pointless.
17:24:06 <chowder> pikhq, I see. I can write the program in Java. I'm just still new to haskell.
17:24:54 <chowder> pikhq, so basically gauss does nothing because its not within main?
17:25:06 <pikhq> gauss does nothing because it's not been *called*.
17:25:11 <jbapple> Igloo: The release notes in the GHC 6.12.2 announcement that just came out are 404:   Â http://haskell.org/ghc/docs/6.12.1/html/users_guide/release-6-12-2.html
17:25:47 <twink> Um, isn't it (y*(y+1) - x*(x+1)) `div` 2
17:26:16 <pikhq> The only code execution comes from main.
17:26:22 <pikhq> Much like C.
17:27:00 <Igloo> jbapple: Too late to tell me that  :-)   They're here: http://haskell.org/ghc/docs/6.12.2/html/users_guide/release-6-12-2.html
17:27:18 <twink> Or, rather, (y*(y+1) - x*(x-1)) `div` 2
17:27:44 <chowder> twink, don't think so. I've used the function in ghci and it works perfectly
17:28:15 <jbapple> Igloo: maybe you could put a redirect up on the 404 page
17:29:18 <IceDane> Shouldn't I be able to use the >>= operator to do: foo >>= parseStuff where foo = IO ByteString and parseStuff = ByteString -> Maybe ByteString ?
17:30:40 <Cale> IceDane: no
17:31:06 <Cale> If foo :: IO ByteString, then parseStuff would have to have type ByteString -> IO t for some type t
17:31:19 <IceDane> ah, yes
17:31:29 <IceDane> b changes, not m
17:31:30 <IceDane> duh
17:31:50 <pikhq> IceDane: No, it's (Monad m) => m a -> (a -> m b) -> m b, not (Monad m, Monad m1) => m a -> (a -> m1 b) -> m1 b.
17:31:55 <Cale> chowder: Have you worked out your problems?
17:32:05 <IceDane> pikhq: yeah
17:32:08 <pikhq> The second type would let you write unsafePerformIO. Which is EVIL
17:32:16 <chowder> Cale: not really :/
17:32:28 <Cale> chowder: If you want to read commandline args, you can use getArgs from the System.Environment module
17:32:59 <chowder> Cale: In Java or Perl I'd write it relatively easily but I just have to get used to functional programming
17:33:20 <Veinor> yay, GHC 6.12.2
17:33:30 <pikhq> unsafePerformIO a = just $ a >>=!!! (liftM :: a -> Maybe a) -- I think.
17:33:54 <Cale> chowder: Well, the way we handle IO is a little different, but there's nothing too complicated about it in the end.
17:34:06 <pikhq> chowder: Strictly speaking, you're having 0 trouble with functional programming ATM. You're doing imperative programming, in essence. ;)
17:34:17 <Veinor> pikhq: yeah, that looks right
17:34:20 <CalJohn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24999#a24999 <- why does my version of memoizedFib go into an infinite loop?
17:34:35 <chowder> pikhq: yea, I'm still thinking imperatively I guess
17:34:51 <Cale> chowder: The basic idea is this: values of type (IO t) are descriptions of things which could be done, possibly causing some I/O to occur before resulting in a value of type t
17:34:51 <pikhq> chowder: IO is imperative programming.
17:35:17 <Cale> chowder: When you write a do-block, the line v <- x means "execute the IO action x, naming its result v"
17:35:42 <chowder> I see
17:35:48 <Cale> chowder: and the do-block as a whole gets the same type as the last action in it -- in particular, the whole do-block is a description of an IO actio
17:35:49 <Cale> n
17:36:16 <Cale> chowder: In the end, you define your 'main' IO action, and it's what actually gets executed
17:36:41 <Cale> It's important to realise that this IO *execution* is separate from *evaluation*. Evaluation is the reduction of expressions to values.
17:36:58 <twink> CalJohn: this is memoFib not terminating?
17:37:33 <twink> CalJohn: You can't lazily build up an infinite Data.Map data structure.
17:37:38 <CalJohn> yes, it doesn't
17:37:38 <Cale> As any Haskell program runs, there will be an interleaving of these two processes of evaluation to reduce expressions to values, and then execution to make things actually visibly happen.
17:37:39 <chowder> Cale: I think I'm starting to get it
17:37:48 <CalJohn> i thought Data.Map was lazy?
17:38:23 <CalJohn> wait, or is it lazy, but infinite structures still cause non-termination?
17:38:38 <twink> CalJohn: what you just said right there
17:38:51 <Cale> CalJohn: It's strict in the tree structure (and the keys), and lazy in the elements
17:39:13 <CalJohn> oh, ok, so it's not really lazy in my conception of lazy
17:39:27 <CalJohn> it just doesn't force evaluation of it's elements
17:42:35 <Cale> chowder: Okay, so if you want to print the result of evaluating something, you need an IO action for putting things on the screen. Luckily, there are a few handy ones. putStr :: String -> IO () will give the IO action which outputs a given string, putStrLn is the same, but will append a newline, and print :: (Show a) => a -> IO () will print any value whose type is in the Show class (so there's a show :: a -> String av
17:42:35 <Cale> ailable)
17:42:55 <Cale> (print = putStrLn . show)
17:43:59 <Cale> chowder: so you can do some IO to read values from the user as you've been doing, and then print the result of some pure computation involving those values, say
17:44:44 <Cale> main = do x <- readLn; y <- readLn; print (gauss x y)
17:47:19 <chowder> Cale, I'll give that a shot, thanks
17:47:26 <FunctorSalad> is it clearly superior to be strict in the tree structure?
17:47:44 <ezyang> FunctorSalad: Doubtful?
17:47:46 <FunctorSalad> I have a vague image of how Data.Map things evaluate
17:48:06 <Cale> FunctorSalad: Well, you have to be strict in the keys anyway
17:48:21 <FunctorSalad> ezyang: haven't thought it to the end
17:48:36 <chrisf> i might even fix the synchash dumping :)
17:48:40 <chrisf> argh, window.
17:48:40 <FunctorSalad> was just extrapolating from lists...
17:48:49 <FunctorSalad> and how intermediate lists can be wasteful
17:49:10 <ezyang> FunctorSalad: You can definitely have situations in which a lazy tree is helpful
17:49:24 <ezyang> Some people might argue that it's not helpful enough to be strict by default
17:49:31 <ezyang> *not strict
17:49:55 <FunctorSalad> Cale: hmm but maybe you could defer some tree restructurings... but no idea if that could ever be a win in realistic situaations
17:49:59 <FunctorSalad> -a
17:50:07 <monochrom> . o O ( If the computer writes the program for me, that will be really helpful :) )
17:50:23 <Cale> FunctorSalad: yeah, it would be interesting to see anyway
17:50:58 <FunctorSalad> maybe I'm engaging in compiler mysticism about how such restructurings can "cancel out" ;)
17:51:36 <FunctorSalad> (as in "turns out that that insert/update/delete was unnecessary to compute")
17:51:58 <chowder> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25001#a25001 << D:
17:52:22 <FunctorSalad> and memory leaks were an argument for strictness too, I reckon
17:52:45 <Cale> chowder: are you sure? Have you saved the file?
17:52:53 <Cale> [1 of 1] Compiling Main             ( sandbox.hs, interpreted )
17:52:53 <Cale> Ok, modules loaded: Main.
17:53:15 <hpc> :t readLn
17:53:16 <lambdabot> forall a. (Read a) => IO a
17:53:40 <monochrom> Is this on a networked file system? :)
17:53:41 <hpc> huh
17:54:01 <FunctorSalad> whitespace issues?
17:54:09 <hpc> and your input for x can be read into an int?
17:54:11 <FunctorSalad> but then the error should be the line after AIUI
17:54:26 <Cale> FunctorSalad: I think part of it is that all accesses will examine the top bits of the tree with a fairly high likelihood, and so deferring computation there is often more wasteful than helpful. On the other hand, maybe a mixed strategy would work well.
17:54:31 <chowder> Cale, I ran it with runhaskell
17:54:50 <FunctorSalad> maybe that's hugs on your box?
17:54:56 <chowder> Cale: was that a bad idea? Should I just compile it?
17:54:58 <Cale> cale@zaphod:~$ runhaskell sandbox.hs
17:54:59 <Cale> 1
17:54:59 <Cale> 100
17:54:59 <Cale> 5050
17:55:04 <Cale> works for me
17:55:12 <FunctorSalad> (and it doesn't allow to start a do block in the same line as the 'do'?)
17:55:12 <hpc> do it in ghci
17:55:21 <chowder> Cale: idk what the issue could be
17:55:28 <Cale> are you sure that sandbox.hs contains exactly what you pasted to hpaste? Make sure there are no tabs in the file.
17:55:56 <Cale> tabs are evil, and they mess everything up, because everyone's editor displays them differently
17:56:11 <Cale> (and the compiler treats them as aligning to the next 8-space multiple)
17:56:13 <monochrom> But hpaste does not mess up.
17:56:13 <FunctorSalad> Cale: *nod*  "mixed" = lazy starting from some depth, I guess
17:56:18 <FunctorSalad> (or something smarter)
17:56:28 <Cale> monochrom: Yeah, but sometimes copy/paste before that does.
17:56:36 <Cale> FunctorSalad: yeah
17:56:46 <chowder> Cale: yea, I read that tabs are evil. I've only used spaces but i'll double check
17:56:50 <FunctorSalad> chowder: try a newline after `do', and making sure the indentations are all the same
17:57:05 <Cale> runhugs also works for me
17:57:10 <FunctorSalad> chowder: your syntax looks like it should be fine too though
17:57:36 <FunctorSalad> (the indentations of the body should be the same, and larger than that of 'do')
17:57:39 <Cale> It is fine. In fact, it's my preferred syntax (though unless there were more parameters, I usually start the 'do' on the same line as the = sign)
17:57:58 <chowder> I checked with vim and there are no tabs. I'll add the newline and see if it works.
17:58:29 <FunctorSalad> chowder: the style I just described is a bit more resistant to tabs
17:58:43 <chowder> still got the same issue
17:58:53 <FunctorSalad> heh I wrote that before I read Cale's message ;)
17:58:58 <FunctorSalad> no bickering intended
17:58:58 <Cale> http://cale.yi.org/share/sandbox.hs
17:59:07 <Cale> ^^ try that
17:59:29 <Cale> It *should* be the same as your file, but if there are any differences, maybe you'll be able to figure out what the problem is
17:59:52 <chowder> Cale: I'll try it
17:59:57 <FunctorSalad> consistent newlines even allow for proportional fonts, I think
18:00:07 <chowder> it worked
18:00:09 <Cale> If that .hs file doesn't work for you, then the problem is that your Haskell environment is somehow broken, because that program is fine :)
18:00:11 <FunctorSalad> but IIRC there was some other misalignment
18:00:17 <FunctorSalad> (with prop fonts)
18:00:18 <jc57> I'm new to Haskell and I'd like to write a blackjack simulator. But it seems awfully hard to get started. Is functional reactive programming the way to go?
18:00:19 <Cale> ah, good
18:00:32 <chowder> however I haven't the slightest clue what I did wrong
18:00:51 <monochrom> Do a diff. Do a hexdump.
18:01:17 <Cale> chowder: Maybe cat both the files and look for differences, or run diff or comm over them.
18:01:38 <FunctorSalad> newline convention...?
18:01:51 <FunctorSalad> but that doesn't explain the error
18:02:06 <FunctorSalad> Cale: you just changed invisible stuff, right?
18:02:15 <Cale> FunctorSalad: I changed nothing at all.
18:02:27 <Cale> FunctorSalad: I copied what was on hpaste, and pasted it directly into a file using vim
18:02:32 <chowder> oh I see what happened
18:02:36 <FunctorSalad> hmm
18:02:40 <chowder> I did something quite mentally retarded
18:02:47 <monochrom> What's on hpaste is theoretically valid Haskell 98 and in practice passes both hugs and ghc.
18:03:18 <monochrom> I dislike speculations that ignores both.
18:03:44 <FunctorSalad> about the whitespace formats?
18:03:50 <Cale> jc57: FRP is an area of active research. If you're really adventurous, you could dive in and try it, but if you're less willing to put up with experimental stuff, you could just use wxHaskell or Gtk2Hs, which are much more traditional GUI libraries.
18:04:04 <FunctorSalad> that would be relevant to the question what "What's on hpaste" is
18:04:27 <Cale> jc57: They use a little bit of FP abstraction, but for the most part the style of programming shouldn't be too unfamiliar if you're used to GUI programming in an imperative language.
18:04:56 <Cale> FunctorSalad: What's on hpaste is fine, the problem is that it somehow doesn't match the file on his computer ;)
18:05:07 * FunctorSalad is more discouraged from gtk2hs by the endless list of modules than by the imperativeness, now that he thinks about it
18:06:10 <Cale> Yeah, Gtk2Hs, like GTK 2 itself, is HUEG. It can be a bit overwhelming.
18:06:21 <FunctorSalad> qthaskell too. 640 modules or so
18:06:44 <jc57> I'm not particularly interested in writing a GUI. FRP and GUI's in my mind seem completely different things.
18:06:49 <FunctorSalad> there should be a "TFSGTK2HS" wrapper (the fine and simple gtk2hs)
18:06:52 <jc57> In an imperative language, I'd shuffle a shoe, vary my bet according to a counting system, and play according to basic strategy. Once this was done, I'd like to explore the value of various modifications: change strategy according to the count; or change the number of hands I play; how much does the value change as the number of other players changes, or as the cut card moves? What if I know that a particular card is going to appear
18:06:53 <jc57> within a location distribution? What if I know something about the count and location of a group of upcoming cards? Answering these questions is where I believe the composibility of Haskell may shine.
18:07:25 <BMeph> Cale: Hugely Ungainly Enormously Gigantic? ;)
18:07:35 <FunctorSalad> ^^
18:07:39 <FunctorSalad> acronym finder?
18:07:46 <Cale> jc57: What I would do is start by defining data structures for representing the parts and entirety of the game state, and functions for operating on that.
18:08:23 <Cale> jc57: That is, don't worry about the view or controller, the I/O parts of the equation, at all, and just focus on the model.
18:09:01 * BMeph thinks that, in an imperative language, you should just assign yourself winning hands, instead of getting replacement hands different from the ones before. That sounds almost...functional... ;þ
18:09:12 <Cale> A natural encoding for strategies is something like  GameState -> Move
18:09:18 <halberd> I'd like a language where individual functions are pure functional, but within a function you use imperative notation like python
18:09:31 <Cale> halberd: You can use the ST monad.
18:09:51 <halberd> that's the way I like to write code anyway in other languages
18:09:51 <jc57> I'm only concerned about the model. The view is almost irrelevant.
18:10:10 <halberd> when you work with an imperative _local_ notation, you can think in steps
18:10:25 <jc57> State monad? Is there something I can modify? Remember, I'm relatively new to Haskell.
18:10:37 <Cale> halberd: You can also think in steps with a functional local notation. Write functions and compose them.
18:10:43 <Cale> :t (.)
18:10:44 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:10:52 <halberd> like first get the fooblatt, and then use the fooblatt to get the zug and the bludge
18:10:54 <kpreid> jc57: State is different from ST, and ST is precisely the 'be imperative inside a function' monad
18:10:54 <Cale> :t (Prelude..)
18:10:55 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
18:11:03 <Veinor> okay, now that ghc 6.12.2 is out, I don't feel bad about disclosing this anymore
18:11:04 <halberd> you can to write the piece of code that gets the fooblatt before you even know exactly what you're about to do with it
18:11:26 <Veinor> if you're running haskell cgi scripts, you should probably recompile them with -norts-opts in 6.12.2
18:11:34 <kpreid> jc57: you enter ST, set up some variables, do stuff imperatively, and then at the end have to drop them and express your result as a value, since it's still a pure function
18:11:38 <Veinor> or whatever the RTS-disabler is
18:11:48 <kpreid> but you can write all the assignments and control flow you want inside
18:11:53 <halberd> in haskell you normally have to introduce extra "let" statements and levels of indentation
18:11:57 <FunctorSalad> halberd: the problem is that side effects like the classic unsafeLaunchMissiles aren't locally confined. But if you just need mutation, there is ST, as Cale said, and it *does* allow the function as a whole to stay pure.
18:12:32 <halberd> but if I wrote all my code in ST it would be weird for haskell
18:12:40 <Cale> halberd: Let's suppose we have the problem of getting the list of how many occurrences of each character occur in a string. We might first sort it, then chop it into groups of equal characters, then for each group, give the first element (which is the same as the others) and the number of elements it contains.
18:12:41 * hackagebot hscurses-fish-ex 1.3.0 - hscurses swimming fish example  http://hackage.haskell.org/package/hscurses-fish-ex-1.3.0 (DinoMorelli)
18:12:48 <c_wraith> well, sure.  You should only use mutation when it actually matters.
18:12:55 <chrisf> > unsafeLaunchMissiles
18:12:56 <lambdabot>   Not in scope: `unsafeLaunchMissiles'
18:12:56 <jc57> Well, I'm not sure. I could write the whole thing in a ST monad but then how do I get the benefits of composibility?
18:12:56 <Cale> halberd: So, that's naturally a composite :)
18:13:19 <hpc> > let unsafeLaunchMissiles = "Kaboom!"
18:13:20 <lambdabot>   not an expression: `let unsafeLaunchMissiles = "Kaboom!"'
18:13:32 <hpc> > unsafeLaunchMissiles = "Kaboom!"
18:13:33 <lambdabot>   <no location info>: parse error on input `='
18:13:34 <Veinor> @define unsafeLaunchMissiles "Kaboom!"
18:13:40 <hpc> ah
18:13:40 <Cale> > map (head &&& length) . group . sort $ "mississauga"
18:13:41 <lambdabot>   [('a',2),('g',1),('i',2),('m',1),('s',4),('u',1)]
18:13:46 <Veinor> > unsafeLaunchMissiles
18:13:47 <lambdabot>   Not in scope: `unsafeLaunchMissiles'
18:13:48 <halberd> or Cale you might go through the list character by character and put it into a dictionary
18:13:48 <Veinor> hm
18:13:52 <halberd> which is how I might do it in python
18:14:02 <Veinor> could've sworn it was @define
18:14:03 <FunctorSalad> jc57: ST is invisible  from the outside (the state can't escape)
18:14:06 <hpc> i know lambdabot can do this
18:14:06 <halberd> that is more efficient than sorting
18:14:08 <kpreid> it's @let
18:14:19 <hpc> @let unsafeLaunchMissiles = "Kaboom!"
18:14:20 <lambdabot>  Defined.
18:14:22 <halberd> and it's what I would think of first
18:14:22 <Cale> It's equally efficient, asymptotically.
18:14:25 <FunctorSalad> (but general IO can, thus unsafePerformIO is unsafe)
18:14:36 <Cale> We can do that as well though. The Haskell equivalent is to use Data.Map
18:14:47 <halberd> well "asymptotically" maybe, but a hash table can be done more efficiently than log time
18:14:55 <Cale> Actually, it can't.
18:15:19 <halberd> especially in the case of counting character frequencies when you have only a few hundred possibilities at most, depending on the language
18:15:26 <FunctorSalad> jc57: by that I mean that ST can't mutate variables from the surrounding scope; it just mutates its own reference cells
18:15:36 <halberd> in practical terms it can Cale
18:15:42 <jc57> If the state can't escape, then how do I modify, put constraints on, or monitor it? Maybe I'm not understanding things at a fundamental level.
18:15:44 <FunctorSalad> of course you can store a variable from the outside scope in such a cell
18:15:53 <Cale> Any function which is capable of hashing n items into C*n buckets, where C is constant takes at least O(log n) time to compute.
18:16:05 <halberd> in practical terms memory access is O(1) not logarithmic
18:16:26 <hpc> read is constant but write is logarithmic
18:16:32 <FunctorSalad> jc57: my fault. the value produced by the stateful computation can escape, I mean the mutable cells can't escape
18:16:41 <Cale> Hash functions need not be cheap, and in practice good hash functions are often just as expensive as following a handful of pointers.
18:16:55 <halberd> read and write are constant time because that's how most computers are designed
18:17:13 <hpc> *facepalm*
18:17:20 <lispy_> shapr: !
18:17:24 <Cale> The "O(1)" access time for hashtables is a common lie, and one which I wish would die
18:17:29 <lispy_> shapr: Are you around?
18:17:30 <halberd> anyway in this case we don't need an actual hash function
18:17:31 <ddarius> Cale: For a particular, but somewhat taxing problem, Zobel found that a relatively simple and performant hash worked well for strings.
18:17:34 <lispy_> Is edwardk here?
18:17:34 <tensorpudding> How much faster could Haskell be if someone designed a computer architecture around it?
18:17:42 <halberd> you could just use the ascii value of a character
18:17:43 <chrisf> Cale: however, the identity function is adequate for counting character frequencies.
18:17:50 <ddarius> tensorpudding: There is a computer architecture built around it.
18:18:01 <Cale> chrisf: sure, you could use a mutable array
18:18:02 <chrisf> Cale: unless unicode gets even more ridiculous, i suppose
18:18:04 <halberd> so in this case, there actually is an asymptotic advantage to not sorting
18:18:08 <halberd> no matter how ideal your machine is
18:18:09 <tensorpudding> ddarius: What do you mean?
18:18:10 <Cale> chrisf: Indeed. :)
18:18:23 <FunctorSalad> jc57: for example, make a random permutation quickly by using mutation, then return a pure value ("freeze" it)
18:18:36 <halberd> because if there are, say, 255 possible characters, then storing character counts in a table is literally constant time
18:18:55 <FunctorSalad> (dunno if there's an elegant and as efficient functional algorithm :))
18:18:58 <halberd> but sorting is still going to be n log n
18:18:59 <Cale> Sure. But then so is using a balanced tree.
18:19:10 <halberd> yes, or an unbalanced tree
18:19:15 <halberd> constant time, asymptotically
18:19:19 <halberd> better than sorting
18:19:29 <Cale> Because your tree will only have at most log(255)/log(2) elements in it.
18:19:40 <halberd> yes, whatever, better than sorting
18:19:42 <c_wraith> err.  you want to say that's the max depth?
18:19:44 <FunctorSalad> (I mean start with [1, ..., n]; for i = 1 to n-1; transpose ith cell and random cell above i)
18:19:52 <DigitalKiwi> logs need to die!
18:19:53 <chrisf> Cale: where are you getting this log bound from for useful hash functions?
18:20:05 <ddarius> @where reduceron
18:20:06 <lambdabot> http://www-users.cs.york.ac.uk/~mfn/reduceron/index.html
18:20:06 <halberd> you could even use a list
18:20:08 <FunctorSalad> s/transpose/swap/
18:20:10 <halberd> and search it in a linear fashion
18:20:15 <halberd> and it would still be asymptotically better than sorting
18:20:37 <Cale> chrisf: It's obvious. To have n distinct values in your range, you need to inspect at least log(n)/log(2) bits of the input.
18:21:23 <halberd> you see what I'm saying Cale
18:21:30 <Cale> halberd: I think so.
18:21:35 <Cale> Okay, so let's do it that way. We'll convert the string to a Data.Map value and then back again.
18:22:22 <FunctorSalad> jc57: in other words, ST does nothing that State couldn't do (well, except that it can dynamically say what the *type* of the state is, maybe)
18:22:28 <FunctorSalad> but maybe it can be reduced
18:22:29 <halberd> anyway I'm saying that is what occurs to me when I think of an algorithm
18:22:54 <Cale> > M.toList . M.fromListWith (+) . (`zip` repeat 1) $ "mississauga"
18:22:55 <lambdabot>   [('a',2),('g',1),('i',2),('m',1),('s',4),('u',1)]
18:23:09 <halberd> I think of doing things step by step
18:23:11 <chrisf> Cale: i see. although, in practice, you dont *have to* scale the hash length with size of the *input*.
18:23:28 <Cale> Pair each element with the value '1', pack the entries into a dictionary, adding the values on collision, and then convert the dictionary back into a list.
18:23:32 <FunctorSalad> of course you could use a universal state type like "list of bytes", but I don't know if State can literally emulate ST, not just after encoding/decoding (Cale?)
18:24:03 <jc57> Here's a sample problem. Say I know the value of a card 15-20 cards away. The PMF for its location starting at 15 cards is [.2 .3 .3 .1 .05 .05] (for example). What is the optimal way to play it? How much is it worth? If I am able to localize it to 15 or 16 cards away, how much does the value change?
18:24:05 <chrisf> Cale: eww, sounds like something a python programmer would do :)
18:24:21 <FunctorSalad> maybe the State's state type could be a union that covers all the (lexical) possibilities
18:24:30 <Cale> chrisf: You do have to scale the size of the hash with how many elements you want to store.
18:24:48 <halberd> a lot of times I know that I need to get some value first but I don't know just what I want to do with that thing afterwards
18:24:48 <Cale> chrisf: Because if you don't, you get too many collisions, and access time becomes linear
18:25:15 <Cale> halberd: So, you think of what you'd do next, and then do that :)
18:25:26 <halberd> but it's left to right, top to bottom in python
18:25:26 <Cale> halberd: Perhaps 'let' would be of some service?
18:25:30 <halberd> and often backwards in haskell
18:25:58 <Cale> Well, yeah. The order of composition in Haskell follows the traditional mathematical convention.
18:26:11 <halberd> so you end up prepending stuff
18:26:13 <halberd> which is weird
18:26:23 <Cale> But it's similar in python when you write the parameters to functions to the right of the function name.
18:26:26 <FunctorSalad> yeah it's not so great, but too late to change :(
18:26:28 <tensorpudding> It's not weird if you're familiar with composition from maths.
18:26:31 <FunctorSalad> (the backwards notation for function compo)
18:26:38 <FunctorSalad> too late to change in math as a whole, that is
18:26:49 <halberd> well in python you don't compose that many together
18:26:50 <tensorpudding> I would think it bad if it were the other way around.
18:26:52 <halberd> so you can read it left to right
18:26:56 <FunctorSalad> it's annoying in math too once the compos get larger
18:26:59 <halberd> you can read foo(a,b,c) as "foo of a,b, and c"
18:27:14 <Cale> One thing which is nice about this convention in Haskell is that when you see f . g . h in Haskell, it's f which is *really* evaluated first, under lazy evaluation.
18:27:15 <blackdog> if you _really_ hate it, you can always use irish composition
18:27:16 <halberd> in haskell a,b, and c are often complex expressions you have to decipher first, so you really have to read right to left
18:27:23 <Cale> Even if you don't like thinking of it that way.
18:27:37 <ddarius> Or just use a different language.
18:27:46 <Cale> Well, you can actually start in the middle, or anywhere.
18:27:47 <halberd> also in python if you assign to a variable it's easy to use it twice
18:27:58 <Cale> If you see something like f . g . h . k, say
18:28:01 <FunctorSalad> in haskell you have >>> actually
18:28:06 <halberd> but in haskell, using a variable once is noticeably simpler than using it twice
18:28:06 <Cale> You could start by trying to understand g . h
18:28:07 <FunctorSalad> import Control.Category
18:28:25 <halberd> and by variable I mean value
18:28:28 <Cale> That's the nice thing about function composition: it's associative
18:28:40 <tensorpudding> It's as hard to understand as the right-associativity of type signatures
18:28:48 <Cale> So you don't have to start at the end or the beginning, or whatever
18:28:59 <halberd> you can read type signatures left to right easily enough
18:29:10 <halberd> "it takes X, and Y, and Z, and produces W"
18:29:12 <halberd> no problem there
18:29:26 <FunctorSalad> tensorpudding: I find it's not just a matter of habit; if you want to write a single-expression program, with (.), you must start with the end state
18:29:34 <FunctorSalad> (in your thinking)
18:29:42 <FunctorSalad> if you want to write it in one pass
18:29:53 <tensorpudding> But noobies will get confused by the fact that (A -> B) -> C is different from A -> B -> C, whereas A -> (B -> C) is equivalent to the latter
18:29:58 <aavogt> sounds like wishful thinking, FunctorSalad
18:30:23 <Cale> halberd: You get used to it in time. I found it natural myself because I'd done a lot of shell programming before Haskell, and when writing things for the shell, one tends to write a lot of pipelines where the output of one program is the input of the next.
18:30:39 <FunctorSalad> aavogt: one pass?
18:30:40 <halberd> pipelines are read left to right, the opposite of function composition
18:30:43 <Eridius> tensorpudding: (A -> B) -> C is obviously different than A -> B -> C. The only tricky bit is realizing that A -> B -> C is the same as A -> (B -> C), though this too is pretty obvious when you think about how -> works
18:30:45 <aavogt> yes
18:30:51 <Cale> halberd: Yeah, but that's just convention.
18:31:08 <tensorpudding> Yes, but noobies' ideas of how -> works is different.
18:31:10 <halberd> I find it easier to read left to right than right to left
18:31:23 <FunctorSalad> order of compo is not just convention because order of writing already breaks symmetry
18:31:23 <Cale> Then read left to right :)
18:31:42 <Cale> and just understand that you're building up a function which will eventually be applied to something
18:31:44 <kamatsu> you don't ever have to read haskell right to left
18:31:49 <halberd> well that takes more mental effort
18:31:52 <tensorpudding> Then they'll get briefed on partial application and they'll understand.
18:32:00 <kamatsu> just read it like german or something
18:32:04 <kamatsu> or japanese
18:32:13 <kmc> :t (>>>)
18:32:13 <kamatsu> you don't get what all the functions are being applied to until the end
18:32:14 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
18:32:24 <Cale> It's good mental effort, it gets you into the mindset of thinking in terms of functions, which is a good part of what functional programming is about (they even put it in the name ;)
18:32:35 <Cale> and it gets easier with practice
18:32:40 <kmc> function-oriented programming ;)
18:32:51 <halberd> what I like about functional programming is that you don't have to wrestle with side effects
18:32:54 <kamatsu> i think if we called it that, it'd be much more popular
18:32:59 <halberd> the notation isn't thrilling
18:33:07 <aavogt> halberd: how does one use values twice so easily in python?
18:33:09 <kamatsu> halberd: you don't have to wrestle with side effects in imperative languages either
18:33:16 <aavogt> I mean, don't you have to think up a name?
18:33:20 <Cale> So, because we don't have to wrestle with side effects, the order in which things are computed *doesn't matter*.
18:33:25 <halberd> aavogt, you do something like a=foo(blub) and then use a twice later
18:33:33 <FunctorSalad> tensorpudding: that one is easy to remember because the two alternatives are so different qualitatively, I find. just remember that the default one *doesn't* produce a serious higher-order function
18:33:34 <halberd> well yes, but you would probably think up a name anyway
18:33:49 <Cale> (at least, up to termination behaviour)
18:33:53 <halberd> because that's how you tend to do things in python, you automatically give short names to the results of computation so you can use them later
18:34:00 <aavogt> halberd: it's the same in haskell, except   let a=foo(blub) in ...
18:34:03 <halberd> as in most imperative languages
18:34:22 <halberd> let introduces an extra level of indentation
18:34:23 <Cale> Yeah, you can always use let expressions if you feel that it's more natural to give names to the intermediate results.
18:34:26 <Cale> Or where clauses
18:34:29 <tensorpudding> In any case, is (.) really that confusing? I mean, haven't most people who learn Haskell already seen it in maths?
18:34:35 <aavogt> you don't have to indent any more halberd
18:34:36 <halberd> which indents very far, pretty quick, if you do it a lot
18:34:37 <kamatsu> halberd: no such thing as indentation in haskell, just layout
18:34:50 <FunctorSalad> tensorpudding: not the issue for me
18:34:56 <Cale> halberd: Note that you can put multiple declarations inside of a single let
18:35:03 <FunctorSalad> guess you're asking the others
18:35:06 <Cale> let foo = bar^2
18:35:11 <Cale>     bar = baz + 1
18:35:13 <aavogt> the next line after the in is allowed to be indented as far as the l, or less
18:35:15 <Cale> in foo + bar + baz
18:35:31 <halberd> yeah Cale but suppose you want a loop now
18:35:39 <kamatsu> halberd: no such thing as loops
18:35:41 <Cale> What sort of loop?
18:35:44 <Cale> Loops become lists
18:35:53 <Cale> and higher order functions on lists
18:35:56 <kamatsu> right
18:36:14 <halberd> you have to use another function if you want a loop to look nice
18:36:18 <halberd> a helper
18:36:24 <kamatsu> halberd: put it in the let?
18:36:34 <tensorpudding> It's all jumps in the end, isn't it.
18:36:42 <kamatsu> and, there's no reason why you need another function.
18:36:50 <aavogt>  forM xs $ \x -> ...
18:36:52 <halberd> like in python you might initialize some values, then have a loop that's 30 lines long and does a bunch of assignments too
18:37:06 <halberd> with maybe some nested loops inside
18:37:07 <ezyang> this page made me laugh http://www.indeed.com/q-Haskell-jobs.html
18:37:10 <halberd> and not all the assignments at the start
18:37:10 <Cale> Using explicit recursion is admitting defeat.
18:37:33 <FunctorSalad> halberd: one idiom for a quick quasi-loop is "f x = go initial_state where go s = do ..... if condition then go next_s else somevalue"
18:37:38 <aavogt> Cale: do you use ContT for early exit?
18:37:44 <Cale> Instead, choose an appropriate datastructure (usually a list is the right way to translate a loop), and implement your function in terms of operations on that datastructure.
18:37:55 <FunctorSalad> if you  don't want to have to think about whether there's some more consise way
18:38:20 <Cale> Just as a loop either doesn't happen at all, or consists of a single iteration followed by another loop, a list is either empty, or consists of a single element followed by another list.
18:38:29 <FunctorSalad> that would be a do-while-loop
18:38:31 <Cale> They are really the same thing.
18:38:49 <kamatsu> halberd: you're using imperative terminology to describe a language which only has vague analogues of such concepts.
18:39:31 <kamatsu> halberd: loops as you know them in python do not exist in haskell. Assignments as you know them do not exist.
18:39:43 <Cale> You can of course translate imperative programs into functional ones in a trivial way where each step becomes a function, each mutable variable becomes a function parameter, and mutual recursion is used for *all* control flow.
18:39:49 <halberd> Cale what would you do to your character counting function if you decided you also wanted to count the number of capital letters separately
18:39:56 <halberd> in addition to counting the occurrences of each character
18:39:56 <FunctorSalad> (by using an accumulator like "s", the recursion feels more 'forward' or imperative somehow)
18:40:01 <Cale> and I have actually done this in order to understand the functioning of imperative programs
18:40:07 <ddarius> Cale: Only rather simple programs would translate in that way "trivially."
18:40:08 <Cale> (my mind is a little bent like that)
18:40:12 <halberd> it would be easy in python to add a variable that does the count of capital letters
18:40:20 <halberd> but I suspect you'd have to mangle your function a bit to do the same thing
18:40:37 <Cale> halberd: Well, we could add a let.
18:41:03 <halberd> or, worse, suppose you decided that in addition to character frequencies, you wanted to count the occurrences of the word "blue"
18:41:21 <aavogt> you can get pretty close if you shadow names, kamatsu
18:41:34 <kamatsu> aavogt: but the semantics of such a thing is different.
18:41:37 <Cale> halberd: I don't understand how that's any more difficult.
18:41:54 <aavogt> > length $ filter ("blue" `isPrefixOf`) $ tails "hello there blue halberd"
18:41:55 <lambdabot>   1
18:42:00 <hpc> what if you wanted to write fmap in Python?
18:42:04 <hpc> or (<$>)?
18:42:15 <halberd> aavogt, no, I said to alter cale's function
18:42:20 <halberd> which already counts character occurrences
18:42:33 <byorgey> halberd: usually in Haskell you would just write three separate functions to count characters, count capital letters, and count occurrences of "blue".
18:42:36 <kamatsu> halberd: why would you do that, when you can already get the occurrences of "blue" separately?
18:42:40 <Cale> halberd: Well, you now have both computations. They're each correct, and you can use them together.
18:42:48 <aavogt> why would you do that if your 'altered' result is so short?
18:43:00 <byorgey> and then call them all on the same input.
18:43:12 <halberd> yeah you could but you'd be looping twice
18:43:19 <hpc> so?
18:43:24 <hpc> that doesn't slow the program down any
18:43:29 <halberd> it doesn't?
18:43:32 <kamatsu> complexity wise it doesn't
18:43:40 <halberd> okay sure but constant factors do matter
18:43:42 <byorgey> you still have to do exactly the same amount of work, pretty much.
18:43:43 <Cale> Not significantly. Also, this way parallelises better.
18:43:52 <halberd> well, sometimes significantly
18:43:56 <kamatsu> not really
18:43:57 <halberd> especially if your loops involve disk access
18:44:05 <halberd> and are running millions of times a day
18:44:11 <Cale> Okay, so yes, sometimes sharing will create a problem.
18:44:15 <blackdog> you're not allowed to bring up performance until you've profiled:)
18:44:26 <blackdog> and if python's the basis for comparison...
18:44:32 <halberd> anyway, that wouldn't work as well if it were a more complicated function that had stranger control structures
18:44:37 <Cale> But yeah, write first, profile second, and *then* worry about it once you've seen that it's really an issue.
18:44:47 <Cale> It rarely is.
18:44:53 <kamatsu> halberd: in haskell, we don't write complicated functions.
18:45:02 <kmc> ha
18:45:03 <kamatsu> halberd: we write lots of smaller functions and compose them into larger ones.
18:45:04 <hpc> in any event, using separate loops for separate things prevents you from writing "the uberloop" which calculates damn near everything you would ever want or need
18:45:21 <halberd> that is true hpc
18:45:37 <kamatsu> kmc: ha indeed
18:45:52 <FunctorSalad> ddarius: "simple" in which way? sounds fine for arbitrary stateful imperative programs that don't do true IO (missiles etc)
18:45:54 <kmc> i think if your loop runs a million times a day, you are solidly out of the naive-solutions range
18:46:02 <kmc> and should expect to spend many hours optimizing it, in any language
18:46:19 <kmc> unless it is trivial to begin with
18:46:52 <aavogt> kamatsu: sure name shadowing has different results if you have nested scopes, but when you don't have any nesting in the do block, you get the same results
18:47:05 <Cale> If you *really* must, there are a few nice abstractions for composing left folds over a list in such a way that the list need not remain in memory any longer than needs be.
18:47:13 <kamatsu> aavogt: same results, different semantics. I don't think it's helpful to liken haskell bindings to imperative assignment.
18:47:24 <FunctorSalad> kmc: there are inbetweens though.... maybe it's not performance-critical missile guidance code, but it may still make someone's desktop environment yet another little bit more laggy
18:47:25 <ezyang> It occurs to me that *** would be appropriate for this case.
18:47:35 <Cale> Or of course you could do the ugly thing and write the thing recursively. I don't think it's any uglier than imperative code for the same thing.
18:47:44 <Cale> It's just as incomposable.
18:47:45 <BMeph> Where Haskell goes, we don't need roads! :D
18:47:45 <ezyang> :t (***)
18:47:46 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
18:47:51 <kamatsu> halberd: also, haskell has some optimizations (stream fusion) that in some cases can make multiple traversals of data structures into a single traversal.
18:48:01 <ezyang> specialized for a = (->) or something
18:48:02 <FunctorSalad> (so I think a bit of optmizability isn't bad, for every language)
18:49:00 <Cale> halberd: Ah, right, you should know, for instance, that if you write something like  foldr f z . map foo . filter bar $ baz, it will compile into a single loop.
18:49:11 <Cale> (with optimisations turned on)
18:49:38 <halberd> actually sometimes I do use imperative constructs that reach beyond a single function
18:49:44 <halberd> like if I want to collect something
18:50:15 <Cale> If you're squishing multiple unrelated computations into a single loop in an imperative program, then you're killing your own maintainability in the first place, and even in your imperative language, you shouldn't be doing that without a really good reason.
18:50:23 <Cale> Premature optimisation is the root of all evil.
18:50:31 <FunctorSalad> halberd: trace/debug is a legitimate excuse (since observing what's supposed to be unobservable is the point there)
18:50:49 <dino-> Another side (if it hasn't been mentioned) is the laziness. Has to be explicity written in imperative langs.
18:50:50 <halberd> I try to keep the module encapsulated though
18:51:08 <FunctorSalad> otherwise, why not make the collector explicit?
18:52:14 <FunctorSalad> Cale: but it also feels morally wrong to take such a tight loop apart into abstractions that you know have considerable overhead
18:52:33 <Cale> halberd: The problem with loops is that they are inside-out. Loop bodies will typically contain a lot of the same stuff, but it's hard to see that repetition in an imperative mindset, as it can't be factored out nicely.
18:52:40 <FunctorSalad> haskell promises us abstractions that can get eliminated in principle though :)
18:53:14 <FunctorSalad> (assuming said loop is important and already works fine)
18:53:41 <FunctorSalad> I totally agree with that last part, Cale
18:53:46 <halberd> here's an example of the kind of program I write with python http://pastebin.org/166693
18:53:50 <FunctorSalad> I'd like the best of both
18:54:17 <halberd> this was to solve a puzzle some relatives got me a few months ago, 9 turtles which are square tiles, that you're supposed to arrange in a 3x3 grid so they all match up
18:54:45 <halberd> there are a lot of ways to arrange them so that five or six of them match up, but hard to get all 9
18:55:00 <FunctorSalad> (doesn't anyone else feel way more at ease when using abstractions with no runtime cost? ;))
18:55:20 <ezyang> It's nice, but you still have to be careful.
18:55:25 <halberd> and I think that could probably be translated into haskell, without too much difficulty
18:55:30 <halberd> but it would be harder in haskell
18:55:35 <blackdog> FunctorSalad: you should solve that turtle problem in the type system:)
18:55:36 <ezyang> I think translation is the wrong way to go about it.
18:55:38 <halberd> at least, the way I think of things, it would be
18:55:46 <blackdog> reckon type families would do it fine
18:55:58 <hpc> FunctorSalad: low runtime cost is icing on the cake; for many applications, programmer time is more expensive than computer time
18:56:23 <Cale> halberd: Do you have a description of the problem handy?
18:56:25 <FunctorSalad> blackdog: hmm, for fixed problem size that would just be a roundabout way to hardcode the solution directly
18:56:37 <blackdog> hpc: that's fine, up to the point that a basic test suite takes half an hour
18:56:44 <blackdog> hpc: at which point you're wasting dev time
18:56:50 <FunctorSalad> (the final value of the solution, that is)
18:56:53 <kamatsu> halberd: that sounds like a good candidate for Logic languages. Logic programs can be factored out to have linear data flow and then they can be written in Haskell.
18:56:59 <halberd> Cale, I did comment
18:57:10 <halberd> the only other thing I could do is give you a photograph of the puzzle
18:57:14 <halberd> so you can see what it looks like
18:57:30 <halberd> just a minute
18:57:37 <Cale> yeah, that may help :)
18:57:38 <dino-> They have to line up head-to-tail?
18:57:38 <hpc> if a test suite is taking half an hour, it probably isn't the language/features that are at fault
18:57:49 <byorgey> halberd: I think that would be rather easy to code in Haskell.  Let me see if I can translate it...
18:58:04 <Cale> halberd: A lot of puzzles are naturally solved in the list monad, or in a StateT over list or some other nondeterminism monad.
18:58:05 <blackdog> hpc: not necessarily. we have multiple hour-long test suites for our rails apps
18:58:24 <FunctorSalad> hpc: I know that that's the general idea, but still... with costly abstractions, I find I have to think about the tradeoff. that costs energy too
18:58:25 <blackdog> they could probably be done faster, granted, but they all need to be done
18:58:34 <gwern> > 2200000 / 1159
18:58:34 <FunctorSalad> hpc: (about programmer time)
18:58:34 <lambdabot>   1898.188093183779
18:58:49 <blackdog> and the reason they're slow is because people think of computation time as free
18:58:51 <FunctorSalad> hpc: while with static abstractions I can throw them around without a second thought
18:58:55 <blackdog> especially in rubyland
18:58:56 <FunctorSalad> to runtime performance
18:59:24 <halberd> cale http://img682.imageshack.us/i/20100421205800.jpg/
18:59:47 <blackdog> halberd: i smell a haskell golf contest coming up:)
18:59:48 <halberd> that's the puzzle solved, you can see that the edges of each tile can be described as the head or tail of a turtle of varying colors
19:00:06 <FunctorSalad> hpc: also, I think the "performance is not an issue today" card is overplayed... tens of milliseconds in latency do matter for how pleasant an app is to use
19:00:14 <halberd> the edges are kind of hard to make out in this photo but you can see where they would be since it's 3x3
19:00:19 <FunctorSalad> (somtimes subconsciously)
19:00:32 <dino-> Ah, I see, the turtles are split. This is like those Triazle puzzles with squares instead of triangles.
19:01:19 <FunctorSalad> just like you can feel 30fps vs 60fps even though you can't perceive these time scales individually
19:01:47 <gwern> hm. ghc 6.12.2 is out
19:01:59 <kamatsu> a bruteforce solver would do the trick
19:02:13 <aavogt> > product [1..9]
19:02:13 <lambdabot>   362880
19:02:16 <pikhq> FunctorSalad: Except that you can't when the 30fps is coming from a camera rather than being rendered.
19:02:24 <FunctorSalad> pikhq: motion blur
19:02:29 * BMeph is disappointed that he wasn't fast enough to say "pix or it didn't happen!"...
19:02:31 <Schalken> What would be the most concise way to print a list of strings? ([String] -> IO ())
19:02:39 <halberd> well I did write a brute force solver
19:02:40 <pikhq> Yes, motion blur is the cause of that.
19:02:45 <blackdog> mapM_ putStrLn strings
19:02:47 <kamatsu> Schalken: one string per line?
19:02:55 <Schalken> kamatsu: yep.
19:03:04 <kamatsu> Schalken: either blackdog's solution or putStrLn (unlines strings)
19:03:16 <pikhq> Without motion blur, it becomes much harder to give the illusion of motion. :)
19:03:33 <kamatsu> > unlines ["abc","def"]
19:03:34 <lambdabot>   "abc\ndef\n"
19:03:36 <FunctorSalad> pikhq: yeah, and I *was* talking about UIs
19:03:42 <kamatsu> oh, not putStrLn, just putStr
19:03:51 <kamatsu> putStr (unlines strings)
19:03:52 <BMeph> It reminds me of those squares, divvied into four triangles by lines connecting the opposite corners, with four numbers on each side.
19:03:53 <FunctorSalad> (I'm thinking of latency rather than motion here though)
19:03:56 <Schalken> blackdog: aha, that would be exactly what im looking for. thanks!
19:04:06 <pikhq> Heck, in UIs you're not going to be noticing the difference unless there's actual animation.
19:04:43 <halberd> well not quite a brute force solver I guess
19:04:47 <FunctorSalad> pikhq: I think one does notice latencies on these scales
19:05:05 <FunctorSalad> pikhq: say, when maximizing a window
19:05:17 <halberd> my solver does backtrack as soon as it determines there's no next best tile
19:05:19 <pikhq> Not really.
19:05:29 <halberd> so I don't actually generate all 9! configurations
19:05:40 <halberd> but, it's not optimized either
19:05:52 <FunctorSalad> pikhq: or when moving your mouse over a menu bar
19:05:55 <pikhq> Well, you may be noticing latency, but it's not from the display.
19:06:08 <FunctorSalad> you can notice even slight delays in opening of the new submenus
19:06:23 <pikhq> FunctorSalad: There exist 30FPS twitch games your argument is invalid.
19:06:31 <FunctorSalad> pikhq: didn't say it's from the display
19:06:31 <brooksbp> Does anyone know how to "center" a superscript in LaTeX??  Like... if I wanted to create a new function type with some symbol centered over an arrow:  --s--> (where s is above the arrow)
19:06:45 <pikhq> FunctorSalad: But you're *talking about properties of the display*.
19:07:05 <FunctorSalad> pikhq: I'm talking about UI response time including all necessary calculations
19:07:22 <pikhq> The framerate has nothing to do with that.
19:07:42 <Saizan> pikhq: the framerate was a point about human perception
19:07:52 <FunctorSalad> pikhq: the framerate was an illustration of subliminal perception
19:07:57 <FunctorSalad> :)
19:08:03 <pikhq> Ah. I completely misunderstood your point then. :)
19:09:19 <BMeph> I'm thinking using pairs-of-pairs, putting together opposite sides, and matching them up that way. Just brainstorming...
19:10:15 <kamatsu> halberd: here's a little solver written in haskell that I wrote a long time ago for a different problem. My haskell skills have improved since then, but this is a good example of a haskell newbie's attempt at a bruteforce solver:  http://liamoc.net/shotsolver.html
19:16:08 <halberd> my brute force method actually is plenty sophisticated for that particular problem
19:16:13 <halberd> because it's a small problem
19:17:49 <halberd> it tries to place tiles 66293 times and finishes in maybe half a second
19:20:30 <gwern> hm. I wonder how common 'and all for the want of a horseshoe nail' is
19:20:45 <gwern> if I wrote, "The young lady's impatience boiled over after a score of minutes, and she left, much to the dismay of the waiters. And all for the want of a horseshoe nail." would people understand the conclusion of the story?
19:21:39 <Makoryu> gwern: You shouldn't even need to specify "horseshoe." If someone gets the reference, they'll get it one way or another.
19:21:45 <chrisf> gwern: that would definitely be understood here.. not sure elsewhere.
19:21:55 <tensorpudding> for want of a basepoint, the induction was lost
19:21:58 <gwern> Makoryu: you mean emend it to 'want of a nail'?
19:21:58 <BMeph> gwern: I'd use "turtles all the way down," but, that's mainly 'cause I find the image of a stack of turtles appealingly silly. :)
19:22:17 <gwern> BMeph: >.< no, that doesn't have the moral of the story at all
19:22:25 <Makoryu> Haha
19:22:30 <Makoryu> gwern: Exactly
19:22:48 * BMeph gives Makoryu a cyber high-five
19:22:57 <gwern> hm. 'for the want of a horsehoe nail' has a better rhythm to my ear. does it not to you?
19:22:59 <Makoryu> Â¯\O_o/Â¯
19:23:12 * gwern doesn't understand this thing between Makoryu and BMeph 
19:23:19 * Makoryu either
19:23:22 <gwern> congratluations are not in order!
19:23:24 <tensorpudding> for want of a horseshoe crab
19:23:34 <Makoryu> gwern: I'd also drop "the"
19:23:36 <gwern> tensorpudding: if I were writing a medical story, then maybe
19:23:37 <chrisf> gwern: if you havent already read it, there is a good version here btw: http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html
19:23:44 <Makoryu> gwern: How does "for want of a nail" sound?
19:24:03 <gwern> 'And all for want of a nail', dunno, sounds a bit terse and gnomic
19:24:35 <Makoryu> Ah, well
19:24:42 <Makoryu> If terse is bad, don't ask me.
19:24:56 <gwern> gnomic verse is a lost artform
19:25:13 <Makoryu> Your mom is a lost artform.
19:25:15 <aavogt> what has it do to with gnomes?
19:25:47 <gwern> aavogt: it's short
19:28:08 <BMeph> gwern: Like you mom? ;þ
19:28:48 <gwern> no u
19:45:17 <defn> Hey all -- I remember a site about how when you start with haskell you write like this: xyz, but when you're a phd student you write like this, blah blah, etc etc
19:45:23 <defn> anyone remember what im talking about?
19:45:27 <Cale> halberd: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25002#a25002
19:45:38 <alpounet> @google evolution haskell programmer
19:45:39 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
19:45:39 <lambdabot> Title: The Evolution of a Haskell Programmer
19:45:42 <defn> nevermind
19:45:42 <defn> nevermindhttp://www.willamette.edu/~fruehr/haskell/evolution.html
19:45:49 <defn> woops thanks alpounet
19:45:55 <Cale> halberd: (note, I also added some code to do a complete second check on the solutions generated)
19:48:20 <Cale> halberd: Ah, oops, got the convention for printing the solutions backward from yours. Swap the x and y in the list comprehension in showSolution, and it'll print the solutions the same way.
19:48:37 <Cale> (which I'll admit is a saner convention :)
19:50:18 <Cale> halberd: There are a number of ways this could be made better. I could have used Maybe in representing the board, which would allow me to use Nothing to represent empty positions in incomplete boards.
19:50:55 <Cale> (currently, it's a little dangerous because the program will simply fail if an as-yet-undefined part of the board is accessed)
19:51:29 <Cale> I also thought about using a nicer representation for turtles, but decided to copy yours.
19:52:02 <halberd> it's easier to enter that way
19:52:09 <Cale> yeah
19:52:39 <byorgey> Cale: ah, a functional array, nice =)
19:52:49 <Cale> Yeah :)
19:53:08 <Makoryu> data Turtle a = a :@: (Turtle a)
19:53:44 <Cale> I suppose there are more appropriate datastructures I could have used there as well, but this was cheap enough.
19:54:16 <Cale> (if the boards were much larger, I would at least need to stick in some Data.MemoCombinators stuff to hasten accesses)
19:54:41 <Cale> (I think...)
19:55:59 <Cale> Of course, Data.Map would also be a sane option at that point.
19:57:11 <ddarius> That type of representation is atrocious for retaining.
19:57:28 <kamatsu> Cale: Why not Data.Array?
19:57:30 <Cale> Well, it's roughly the same as a list.
19:57:59 <ddarius> Cale: Yes, an association list... that you only add to so it can only get bigger.
19:58:20 <Cale> Right, but I'm always changing it in a monotone-increasing way
19:58:34 <Cale> So it's not like it could ever even stay the same size.
20:00:00 <Cale> Heh, there will be a lovely tree of functions in memory representing the solutions in terms of their initial parts. :)
20:00:06 <ddarius> Cale: I'm not saying that it is a particularly horrible representation in this case, just that it is a particularly horrible representation in almost all cases.
20:00:13 <Cale> yeah
20:00:31 <Cale> actually, an association list would not have done so poorly here either.
20:00:43 <Cale> But in general, it's terrible too
20:00:46 <ddarius> Cale: Your function is completely identical to an association list.
20:00:54 <Cale> right
20:00:59 <ddarius> Except there's less introspection.
20:01:13 <Cale> it's the association list with 'lookup' pre-applied
20:01:18 <ddarius> Exactly.
20:01:42 <ddarius> Lambda: The Poor Man's Object
20:02:34 <halberd> I dunno, I like what you did with checkAdd
20:02:41 * ddarius may start calling Java objects, Hobo HOFs.
20:03:00 <halberd> but a lot of the rest of it seems not entirely straightforward
20:03:39 <Makoryu> Har
20:04:00 <Cale> It's entirely the obvious thing if you know what the list monad is all about
20:04:18 <Cale> inside that 'do', v <- xs means 'pick v from the list xs in all possible ways'
20:04:34 <Cale> It's just another syntax for list comprehensions which works better when they're complicated
20:05:41 <Cale> the 'guard (checkAdd (x,y) tr p)' will ensure that adding the rotated turtle tr at position (x,y) into the board p will work, and induce backtracking if not.
20:06:09 <Cale> 'select' is just a handy function that I wish was in Data.List
20:06:40 <Cale> It picks an element from a list in all possible ways, giving a list of the selections paired with the corresponding depleted list
20:07:09 <Cale> @let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
20:07:10 <lambdabot>  Defined.
20:07:16 <Cale> > select [1,2,3,4]
20:07:17 <lambdabot>   [(1,[2,3,4]),(2,[1,3,4]),(3,[1,2,4]),(4,[1,2,3])]
20:07:29 <Cale> It's extremely handy for this sort of thing
20:07:57 <Cale> So when I write (t,ts') <- select ts, it means pick a turtle t, and call the remainder of the turtles ts'
20:08:16 <Cale> So, we do that, and then we pick a rotation
20:08:23 <Cale> and then see if we can add it
20:08:31 <Cale> and if so, we do, and continue on with the next position
20:10:32 <halberd> well I am pretty rusty with haskell
20:10:53 <aavogt> select should be in base
20:12:57 <halberd> I kind of understand that, but it's not something I would have thought of
20:14:13 <fax> > let i = sqrt(-1) :: Complex Double in e^(-28/11*i*pi) + e^(-16/11*i*pi) + e^(-14/11*i*pi) + e^(-12/11*i*pi) + 4*e^(-10/11*i*pi) + 3*e^(-8/11*i*pi) + 4*e^(-6/11*i*pi) + 2*e^(-4/11*i*pi) + 2*e^(-2/11*i*pi) + 2*e^(2/11*i*pi) + 2*e^(4/11*i*pi) + 4*e^(6/11*i*pi) + 3*e^(8/11*i*pi) + 4*e^(10/11*i*pi) + e^(12/11*i*pi) + e^(14/11*i*pi) + e^(16/11*i*pi) + e^(28/11*i*pi) + 2
20:14:14 <lambdabot>   No instance for (GHC.Real.Integral
20:14:14 <lambdabot>                     (Data.Complex.Comple...
20:14:18 <fax> :/
20:14:33 <fax> > let i = sqrt(-1) :: Complex CReal in e**(-28/11*i*pi) + e**(-16/11*i*pi) + e**(-14/11*i*pi) + e**(-12/11*i*pi) + 4*e**(-10/11*i*pi) + 3*e**(-8/11*i*pi) + 4*e**(-6/11*i*pi) + 2*e**(-4/11*i*pi) + 2*e**(-2/11*i*pi) + 2*e**(2/11*i*pi) + 2*e**(4/11*i*pi) + 4*e**(6/11*i*pi) + 3*e**(8/11*i*pi) + 4*e**(10/11*i*pi) + e**(12/11*i*pi) + e**(14/11*i*pi) + e**(16/11*i*pi) + e**(28/11*i*pi) + 2
20:14:34 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
20:14:34 <lambdabot>         against inferred ...
20:14:51 <fax> oh that is rubbish
20:15:25 <strobedream> ha ha that took me a while to figure out what you were trying to do.
20:15:27 <halberd> it does seem to me that you used a fair amount of somewhat intermediate level language features
20:15:39 <halberd> might just be my haskell inexperience talking
20:15:52 <Cale> I suppose that's less than 100% ideal, control-structure wise. I could also have used a foldM over the list of indices, and avoided the explicit recursion there.
20:15:54 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25002#a25003
20:16:06 <fax> Can I cabal install free digits?
20:16:09 <fax> I mean CREal
20:16:19 <fax> lambdabot isn't accepting it
20:17:17 <fax> oh it's called numbers
20:17:34 <halberd> also it might be due to a difference in taste
20:17:56 <BMeph> > let {e = exp 1; i = sqrt(-1) :: Complex CReal} in e**(-28/11*i*pi) + e**(-16/11*i*pi) + e**(-14/11*i*pi) + e**(-12/11*i*pi) + 4*e**(-10/11*i*pi) + 3*e**(-8/11*i*pi) + 4*e**(-6/11*i*pi) + 2*e**(-4/11*i*pi) + 2*e**(-2/11*i*pi) + 2*e**(2/11*i*pi) + 2*e**(4/11*i*pi) + 4*e**(6/11*i*pi) + 3*e**(8/11*i*pi) + 4*e**(10/11*i*pi) + e**(12/11*i*pi) + e**(14/11*i*pi) + e**(16/11*i*pi) + e**(28/11*i*pi) + 2
20:18:00 <lambdabot>   mueval-core: Time limit exceeded
20:18:12 <Cale> BMeph: heh
20:18:22 <BMeph> Well, at least it didn't "No instance" me... :)
20:18:25 <halberd> in that link I think I prefer the one above
20:18:25 <fax> (-9.5149194836544057191202499811940977574383) :+ 0.0
20:18:30 <fax> that is what I got on my computer
20:18:39 <fax> so apparently that's a rational
20:18:48 <fax> I am not sure if it printed the whole thing or not though
20:18:52 <Cale> halberd: Yeah, it's a little more straightforward, but the foldM one generalises better.
20:19:01 <halberd> I mean I think any programmer in any imperative language could probably understand my python solution without much difficulty
20:19:33 <halberd> I might have to explain what the slice turtle[-2:] meant
20:20:24 * BMeph has "select" in his Util file, only it's called "oneOf"
20:20:34 <halberd> but I think it's a lot easier to understand
20:20:37 <fax> halberd, looks like something I could figure out by reading a manual if I was meant to use your code
20:21:14 <halberd> well also I'd have to explain that permutation[-1] and permutation[-2] mean the last and second to last elements of the permutation list
20:21:37 <Cale> The part of my brain responsible for keeping track of state has atrophied somewhat.
20:22:36 <Cale> But yeah, I basically wanted to show that you could do things in practically the same way
20:22:50 <halberd> I think it would take me quite a significant amount of effort to learn to read your code Cale as easily as I can read mine
20:22:51 <greedo> dang, mcafee fails
20:23:06 <Cale> I don't think it's so bad.
20:23:22 <fax> wow this is taking /forever/
20:23:26 <greedo> http://news.yahoo.com/s/ap/20100421/ap_on_hi_te/us_tec_mcafee_antivirus_flaw
20:23:28 <fax> I am trying to calculate something to 1000 places
20:23:32 <fax> it can't even print the first one
20:23:43 <ddarius> Cale: You may find this paper interesting if you haven't seen it before: http://www.cs.le.ac.uk/people/ngambino/Publications/generalised-species.pdf
20:23:45 <Cale> I would expect any functional programmer to have not much difficulty reading mine. I suppose there's the list monad usage there, but I could replace it with a list comprehension.
20:23:45 <fax> I thought CReal would print them one by one
20:24:10 <halberd> in Haskell there is a great diversity of control structures
20:24:13 <Cale> (and most functional programmers know about the list monad by now anyway :)
20:24:21 <halberd> and probably one of them is the right tool for the job
20:24:26 <Cale> halberd: and yet there are almost none! :)
20:24:36 <Cale> They're all in the libraries :)
20:24:41 <halberd> but you have to know all of them and know which one to use
20:24:47 <c_wraith> I really wish if wasn't in the language.
20:24:49 <halberd> okay Cale , in the libraries doesn't mean they aren't there
20:24:54 <Cale> Right.
20:25:03 <Cale> Most of the common things are operations on lists
20:25:24 <halberd> you need to use libraries to do stuff like that, when most other languages, a smaller number of built in control structures get you to the same place
20:25:35 <ddarius> :t exp -- fax
20:25:36 <lambdabot> forall a. (Floating a) => a -> a
20:26:11 <fax> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25004#a25004
20:26:13 <fax> this is my program
20:26:19 <fax> its been running for maybe 5 mins now...
20:26:26 <ddarius> Cale: You could rewrite the code into LINQ.
20:26:26 <fax> not printing anything ;(
20:26:45 <Cale> halberd: Well, we have almost nothing built in, and while it's quite possible to write a completely general 'for' loop, we tend to prefer more expressive, restricted cases.
20:26:53 <halberd> I used def, return, array references and slices, if, not, for, print, xrange, and a few arithmetic operators
20:27:42 <Cale> Each of your for loops turned into a list operation -- the two important ones turned into '<-' in the list monad
20:27:47 <halberd> also I used a function inside another function which seems natural to me but someone who was unfamiliar with python might wonder about
20:29:03 <kmc> nested 'def'?
20:29:32 <Cale> actually, you just had the two 'for' loops, and I just had the two corresponding <-'s (which desugar into an operation called concatMap)
20:30:10 <halberd> you used zipWith, const, drop, cycle, and, !!, lambda, if/then/else, do (list monad), return, guard, let, iterate, take, error, mapM, ., &&&, <-
20:30:22 <halberd> and list comprehension
20:31:03 <Cale> Well, the zipWith/const/drop/cycle thing is just doing what you did with list sections in rotate_turtle
20:31:21 <Saizan> you could rewrite the whole thing with just S and K, it wouldn't be more readable though.
20:31:23 <Cale> > cycle "DTLTBTRT"
20:31:24 <lambdabot>   "DTLTBTRTDTLTBTRTDTLTBTRTDTLTBTRTDTLTBTRTDTLTBTRTDTLTBTRTDTLTBTRTDTLTBTRTDT...
20:31:30 <Cale> > drop 6 (cycle "DTLTBTRT")
20:31:31 <lambdabot>   "RTDTLTBTRTDTLTBTRTDTLTBTRTDTLTBTRTDTLTBTRTDTLTBTRTDTLTBTRTDTLTBTRTDTLTBTRT...
20:31:43 <Cale> > zipWith const (drop 6 (cycle "DTLTBTRT")) "DTLTBTRT"
20:31:44 <lambdabot>   "RTDTLTBT"
20:31:54 <Cale> Could also have just written take 8
20:32:25 <Cale> rotate = take 8 . drop 6 . cycle
20:32:27 <fax> I like this
20:32:31 <fax> we could all talk in this way
20:32:44 <BMeph> c_wraith: 1) Remove "if" 2) rename "return". :)
20:32:55 <halberd> okay, but I think it's more things to understand, to read your program
20:32:57 <halberd> than to read mine
20:32:59 <Cale> The !! is just list indexing, which you also used
20:33:05 <halberd> yes I know, and I counted it when I used it too
20:33:05 <BMeph> Drat, I hate it when that happens...:(
20:33:15 <aavogt> it tends to be easier to read something you wrote
20:34:08 <halberd> I'm saying that here is a more or less objective measure, that Cale's program used more language or library features than mine did, and therefore would be harder to read by a novice
20:34:44 <ddarius> halberd: And that measure is obviously ludicrous as Saizan pointed out.
20:35:19 <Cale> Someone who is new to imperative or functional programming would have trouble understanding the respective backtracking search idioms we used anyway
20:35:26 <halberd> true, but I don't think I did anything ridiculous like that, I used fewer features but worked at the same level of abstraction
20:36:43 <Cale> halberd: I could have avoided mapM_, (.) and &&&
20:37:02 <halberd> okay
20:37:07 <Cale> They just make that line a bit cleaner (from my perspective)
20:39:38 <Cale> Well, if it weren't for mapM_, I would use recursion over the list of solutions.
20:39:47 <Cale> (.) and (&&&) just save me from using a lambda
20:40:00 <Cale> Keeps me from having to give a name to the 'current solution'
20:40:41 <Cale> and I think  print . (showSolution &&& fullCheck)  is nicely descriptive :)
20:40:48 <kmc> i don't think anyway that "easy to read by a novice" is a design goal of most Haskell code
20:40:52 <EvanR> its cleanest if you recode it in SKI combinators
20:40:57 <Cale> heh
20:41:04 <ddarius> EvanR: Eliminate I.
20:41:23 <kmc> it should be easy to read for someone who knows the language, and knows or is willing to look up all the library functions being used
20:41:31 <halberd> I think accessibility to novices should be a design goal - not necessarily a novice to the language but certainly a novice to the system you're writing code for
20:41:35 <kmc> and there is a core of commonly-used stuff
20:41:38 <Cale> Bonus points for the first person to rewrite it in terms of s and k, along with a harness for printing the answers :)
20:41:42 <kmc> halberd, i think those are two really different things
20:41:52 <kmc> because anyone who has studied Haskell a while will know all the things you listed
20:41:54 <EvanR> replace printing with a list of answers
20:41:59 <kmc> "zipWith, const, drop, cycle, and, !!, lambda, if/then/else, do (list monad), return, guard, let, iterate, take, error, mapM, ., &&&, <-"
20:42:04 <kmc> they're not specific to this system at all
20:42:53 <Cale> and many of those things take about 20 seconds to explain
20:43:04 <kmc> some of them are core language features
20:43:22 <Cale> (but probably longer to internalise)
20:43:34 <kmc> most of the rest are in Prelude
20:43:44 <kmc> the dodgiest thing there is (&&&), from Control.Arrow
20:43:45 <Saizan> anyhow, even if you've to lookup the combinators, their specificity can make easier to see what the whole expression denotes, for loops with mutable state are just so vague
20:44:07 <kmc> and indeed if you look up the general definition of (&&&) it may be confusing
20:44:09 * gwern dislikes &&&. really, just write the lambda.
20:44:33 <greedo> http://pastebin.com/LHpnnh3w
20:44:33 <Cale> Yeah, when you encounter a for loop, the fact that it's a for loop alone tells you very little about the structure of the computation, since there are so many variations of usage.
20:44:43 <greedo> where am I wrong
20:44:45 <aavogt> \x -> (gwern dislikes x, really, just write the lambda. x)
20:44:49 <gwern> &&& shades into pointless realms of unclarity
20:44:55 <greedo> it's some thing with perfect
20:44:56 <Cale> Especially when mutation and early returns are involved.
20:45:20 <gwern> greedo: helps if you include the compile error
20:45:22 <kmc> i don't agree. i think (f &&& g) is very clear, once you know what &&& does.  and it's not hard to explain for (->)
20:45:24 <halberd> well I love static typing, but it's not that hard to read through a loop
20:45:42 <EvanR> Cale: at work we have people who can instantly understand those
20:45:49 <ezyang> I mean, it's all about vocabulary, no?
20:45:56 <halberd> and figure out what it does
20:46:08 <halberd> of course, best of all, someone puts some comments before the loop explaining the gist
20:46:16 <Cale> halberd: It's harder than it needs to be though.
20:46:25 <greedo> http://pastebin.com/vXNerrcK
20:46:46 <ezyang> It occurs to me that my earlier comment about *** doesn't quite work for composing combining functions.
20:47:26 <BMeph> Cale: Yeah, your "add" function wouldv'e been simpler, and introduced fewer things, if you'd used ifM in the ((->) e) monad.... ;þ
20:47:36 <halberd> I'm primarily a Cache programmer these days
20:47:45 <BMeph> *would've
20:47:47 <Cale> When people write things like that in imperative languages, I have to read the whole function as being wrapped in call/cc and then think of return as calling the current continuation, and it makes things a bit awkward to read.
20:47:51 <Saizan> greedo: factors n will return a list, but you're adding those and using the result as an Int
20:47:57 <Cale> BMeph: ifM?
20:48:13 <Cale> BMeph: I suppose I can understand what that would be :)
20:48:20 <Cale> BMeph: I agree.
20:48:30 <EvanR> they look at me funny for spending an undue amount of time verifying every possible branch of the loop
20:48:56 <halberd> well people need to comment more, that's the biggest thing that would improve readability
20:49:07 <gwern> greedo: where x = ((factors n)+(factors n))
20:49:18 <Cale> Nah, that just forces me to verify that the comments are correct ;)
20:49:20 <halberd> explain what contract a piece of code is designed to fulfill
20:49:22 <gwern> greedo: where x = [Int] + [Int]
20:49:42 <halberd> well Cale and code disagree then often it's the code that is wrong
20:49:45 <greedo> didn't know that was possible
20:49:46 <halberd> errr
20:49:47 <gwern> greedo: is +'s typesig  [Int] -> [Int] -> Int
20:49:48 <gwern> ?
20:49:58 <halberd> Cale, if comments and code disagree, then often the code is wrong
20:50:04 <Cale> halberd: Sure.
20:50:19 <greedo> oh, for the typesig
20:50:23 <ddarius> Code gets tested.  Comments do not.
20:50:29 <gwern> greedo: no, I'm pointing out the error
20:50:31 <halberd> often the hardest part is figuring out what the code SHOULD do
20:50:46 <Cale> halberd: Well, I don't deny that comments are useful, only that if I've resigned myself to reading the code at all, I'm not going to trust them :)
20:50:47 <halberd> the comments, in an ideal world, tell you what it should do
20:50:56 <BMeph> "Type annotations are like comments, which are also readable - and checkable - by the compiler." :)
20:51:04 <halberd> yes they are, I love static typing
20:51:07 <ddarius> halberd: In the ideal world, comments wouldn't be necessary.
20:51:14 <halberd> although there are things you can say with a comment that you can't say with a type annotation
20:51:21 <BMeph> I forget where that came from, but I definitely like the concept.
20:51:30 <aavogt> you're not being creative enough with your types
20:51:40 <gwern> greedo: I'm not even sure how to fix that. factors n ++ factors n will typecheck in the where clause, but then it's messed up in thebody since you have a [Int] where you need Int
20:51:42 <Cale> halberd: Only because the type systems we use are relatively inexpressive.
20:51:45 <halberd> for example:  "This piece of code finds all contracts that match the given procedure"
20:51:50 <halberd> say that with types
20:52:09 <ddarius> aavogt: Yes, but assuming soundness of the type system, you can only say things that are -true- about your code with types.  Comments are so much more flexible.
20:52:16 <Cale> halberd: It's easy to express things like that in Agda, for instance.
20:52:23 <halberd> or, "This piece of code finds all contracts that match the given procedure.  If one contract is prohibitive and the other is permissive and both apply, the prohibitive contract shall overrule."
20:52:32 <Makoryu> :t pi -- equal to 3
20:52:33 <lambdabot> forall a. (Floating a) => a
20:52:38 <BMeph> code :: Match Procedure Contract
20:52:43 <BMeph> :D
20:53:01 <aavogt> ddarius: the idea is that the comments are not allowed to be be incorrect sometimes
20:53:05 <EvanR> pi ~= 3
20:53:06 <halberd> types can at best only talk about things that are within the system
20:53:37 <halberd> they aren't very good about talking about the world that the system is trying to model
20:54:08 <Saizan> unless you've a very expressive type system :)
20:54:29 <halberd> express "This procedure performs edge detection on the camera feed" with types--even in theory you can't do it
20:54:48 <ddarius> halberd: Sure you can.
20:54:54 <halberd> how would you?
20:54:57 <ezyang> Feed -> [Edge]
20:55:00 <ezyang> ^_^
20:55:04 <Cale> heh
20:55:11 <ddarius> halberd: Read about dependent type systems, e.g. Agda or Coq.
20:55:13 <ezyang> "It probably isn't that simple"
20:55:19 <halberd> I have read about dependent type systems
20:55:27 <ddarius> halberd: Then you already know the answer.
20:55:43 <halberd> dependent type systems allow you to specify hard mathematical constraints on a function
20:55:53 <ddarius> halberd: What about that comment do you think is not possible?
20:56:01 <halberd> "performing edge detection" is not a hard mathematical constraint on the function
20:56:40 <halberd> only a human can decide whether a given function effectively performs edge detection, by comparing the results of the function with their knowledge of where the edges should be
20:56:42 <Cale> halberd: But it's something which is formalisable.
20:56:53 <halberd> how can it be formalized?
20:57:10 <ddarius> halberd: Then the comment is simply wrong.
20:57:49 <Cale> For instance, that the output image has a brightness which satisfies a bound regarding the magnitude of the derivative of the input image
20:57:53 <FunctorSalad_> halberd: if you don't really know what exactly you're aiming to do, that isn't a specific issue with a type-system?
20:58:13 <halberd> FunctorSalad_, edge detection algorithms are useful for machine vision
20:58:22 <FunctorSalad_> (and all the problems of mapping logic to reality aren't really, either)
20:58:32 <halberd> there's nothing wrong with the aim of creating an edge detection routine
20:58:45 <halberd> and you can't document what you're doing with a type, only with a comment
20:58:53 <FunctorSalad_> halberd: the type could express heuristic measure on the algo's quality
20:58:54 <Cale> Type systems aren't often used to verify numerical properties of that sort, but that's not an argument that they couldn't be
20:58:59 <FunctorSalad_> *measures
20:59:00 <ddarius> halberd: And I'm sure machine vision experts have definitions of what constitutes an "edge detection" routine beyond "it fools a human."
20:59:17 <FunctorSalad_> assuming you have some way of "scoring" potential edge detection algos
20:59:29 <halberd> well ddarius it would be nice if you can use the edge detection to discover objects in the world
20:59:33 <FunctorSalad_> but I doubt you could in practice prove that a given algo satisfies them
20:59:46 <halberd> like bottles of water and barbershops
21:00:00 <Cale> An edge detection algorithm which doesn't satisfy any analytically describable properties would be pretty useless.
21:00:02 <ddarius> halberd: I don't know what your last two sentences have to do with anything I've said.
21:00:08 <halberd> the edge detection feeds into higher level routines that ideally can know about those things
21:00:45 <halberd> and the usefulness of the edge detection can therefore be judged indirectly by the higher level routines that know about barbershops
21:01:19 <halberd> specifically, the edge detection routine should be written in such a way that the higher level routine is more proficient at identifying barbershops
21:01:24 <ezyang> The fact that (a,(b,c)) != (a,b,c) kind of bugs me.
21:01:35 <ddarius> halberd: You can encode those "usefulness" metrics into a (powerful) type system assuming they have some actual meaning.
21:01:41 <Cale> ezyang: yeah, but they do perform differently...
21:01:48 <ezyang> I know.
21:01:56 <Cale> ezyang: In a way that *might* matter for large tuples sometimes.
21:01:57 <halberd> no you can't ddarius , and the reason is that what actually IS a barbershop is not a mathematical construct
21:02:00 <halberd> it's a real world thing
21:02:08 <Cale> ezyang: But large tuples are rare anyway...
21:02:12 <FunctorSalad_> ezyang: maybe a job for TH?
21:02:16 <halberd> it's defined by the millions of barbershops in the world, not by something within your system
21:02:23 <ezyang> It's just... it doesn't give you associativity or any of those nice things
21:02:31 <ezyang> halberd: Right, but we're programmers.
21:02:46 <halberd> and it can be quite useful to write a routine that is wrong in some cases
21:02:50 <FunctorSalad_> $(theCoherenceIsomorphism some_pair_of_tuple_structures)
21:02:56 <halberd> as, indeed, any barbershop-identifying-routine probably is
21:03:10 <Cale> halberd: If your program has to know what a barbershop is, then you *must* have a mathematical description of what it means to be a barbershop somewhere, or you can't even begin to write your program.
21:03:37 <tensorpudding> It's a barbershop if it has the pole outside.
21:03:40 <Cale> Well, suppose you finish writing your program, and it's correct. Then you have such a mathematical description.
21:03:45 <halberd> yes, the pole is crucial tensorpudding
21:03:52 <Cale> (It's just maybe an over-complicated one)
21:03:53 <FunctorSalad_> ezyang:  the current setup has the advantage that (,) is injective though :)
21:03:59 <halberd> programs are never correct Cale
21:04:00 <ddarius> halberd: Yes, but the -image- is a mathematical object.  You can have the type system say "This function will correctly classify these images as having or not having a barbershop that are independently pre-identified by a human.""
21:04:07 <halberd> especially large ones, and especially heuristic ones
21:04:08 <ezyang> FunctorSalad_: It's true :^)
21:04:11 <FunctorSalad_> (1,2,3) doesn't uniquely un-(,)
21:04:30 <Cale> I beg to differ on that point. Programs are often correct.
21:04:35 <halberd> ddarius, you can say that, but in actuality that's not the real type of the function
21:04:46 <ddarius> halberd: I'm saying you can give it that type.
21:04:51 <halberd> because the function isn't supposed to just work right on those pictures
21:04:52 <EvanR> > map (^2) [1,2,3,4,5]
21:04:53 <lambdabot>   [1,4,9,16,25]
21:04:57 <BMeph> halberd: I Really think you meant "perfect" where you said "correct"... ;)
21:04:57 <halberd> but on other pictures even the programmer hasn't seen
21:04:59 <ezyang> I guess my wish boils down to, "I want a product type that I can build up incrementally without making some sort of tree structure"
21:05:08 <ddarius> halberd: Yes, but "work right" is undefined.
21:05:11 <EvanR> square a list function, certainly correct!
21:05:19 <ddarius> halberd: You are talking about a system with no acceptance test.
21:05:25 <halberd> it's defined in the head of a person who knows what a barbershop is
21:05:28 <FunctorSalad_> ezyang: always normalize to right-nested
21:05:30 <FunctorSalad_> or left
21:05:31 <halberd> the person knows more than the system does
21:05:32 <FunctorSalad_> ?
21:05:35 <halberd> this is a very frequent occurrence
21:05:41 <ezyang> Yeah. It just looks kind of ugly.
21:05:55 <ddarius> halberd: People don't agree on what a barbershop is nor does every person know what a barbershop is.
21:06:07 <halberd> well now we're talking about philosophy ddarius
21:06:27 <ddarius> halberd: How is that statement philosophical?  It's a verifiable fact.
21:06:28 <BMeph> ezyang: But...I _like_ tree structures! ;)
21:06:35 <halberd> how does the meaning of "barbershop" arise in social context? this is not a programmer's question
21:06:48 <halberd> it's for the philosophers
21:06:54 <ezyang> halberd: But the programmer needs some answer to tackle the problem
21:06:55 <halberd> or linguists
21:06:57 <ezyang> No matter how superficial
21:06:59 <Saizan> halberd: the point is that to write the program you've to fix some definition for barbershop.
21:07:18 <ddarius> halberd: I'm saying, as I said before, that the only reason, in this case, that your comment is "more powerful" than a type is because it is wrong/untrue.
21:07:32 <Cale> If you don't bother to define a barbershop separately, your program becomes a definition of what a barbershop is.
21:07:34 <ddarius> Inconsistent logics are very powerful.
21:07:34 <FunctorSalad_> ezyang: with a value-level list you are simply forced to right-nest...
21:07:35 <halberd> Saizan, in practice suppose that a kind of barbershop previously unknown to the programmer is discovered, that has a green pole outside
21:07:38 <halberd> instead of a red and white one
21:07:50 <ezyang> FUnctorSalad_: But it's pretty. :-)
21:07:53 <halberd> so perhaps an unhappy user files a bug report about that
21:07:58 <FunctorSalad_> ezyang: the type level lets you put a cons cell in the left slot of the cell, untyped as it is
21:08:05 <ezyang> like, I sometimes wonder if (a,b,c) should just be sugar for (a,(b,c))
21:08:05 <halberd> and then the programmer has to fix his program to classify green-pole barbershops as barbershops
21:08:22 <halberd> so he didn't even know, beforehand, that green-pole barbershops existed
21:08:24 <Cale> A program can be correct and unsuited to the task that the user intends it for.
21:08:37 <halberd> but his program was wrong because it didn't know that green-pole barbershops existed
21:08:55 <Cale> His program might also have been right, but not the right program.
21:08:56 <Saizan> you can change the types of your program too :)
21:09:00 <halberd> so he has to fix it, because it is supposed to identify all barbershops--and you know it's supposed to do that because of comments and documentation in English
21:09:02 <FunctorSalad_> *untyped except for function arities, actually
21:09:11 <FunctorSalad_> the type-level, that is
21:09:19 * aavogt writes correct programs which are unsuitable for any task
21:09:27 <ezyang> snerk
21:09:30 <BMeph> Comments are highly overrated. :)
21:09:31 <ddarius> aavogt: That's not possible.
21:09:40 <ddarius> aavogt: They are suitable for doing whatever it is they do.
21:09:52 <ddarius> aavogt: Even if it is only corrupting memory or making the processor hot.
21:09:58 <Cale> If I try to use my IRC client to design 3D models, my IRC client won't help me. Does that make it an incorrect program, or am I just using it inappropriately.
21:09:59 <pickles> and if they're suitable for being unsuitable?
21:10:00 <Cale> ?
21:10:03 <aavogt> ddarius: :)
21:10:07 <halberd> specifications are sometimes as buggy as programs
21:10:09 <pickles> wouldn't that be a sort of barber's pradox...
21:10:18 <ezyang> "ha!"
21:10:26 <halberd> Cale, your IRC client doesn't have documentations or comments saying it is supposed to be able to design 3d models, so it's not incorrect
21:10:26 <FunctorSalad_> halberd: why stop at critizing type systems? can *you* tell me what exactly a barbershop is?
21:10:36 <halberd> no FunctorSalad_ I cannot
21:10:42 <halberd> not _Exactly_
21:11:06 <dolio> What is the point of this conversation?
21:11:07 <FunctorSalad_> it's just the impossibility to link the informal to the formal
21:11:17 <ddarius> dolio: To fill up the IRC channel.
21:11:23 <halberd> I can provide a more realistic example
21:11:24 <Cale> halberd: But maybe I can very broadly and poetically interpret its documentation.
21:11:38 <Cale> halberd: English doesn't have a fixed semantics after all...
21:11:44 * BMeph writes comments for Cale's IRC client saying that it (the client) is supposed to be able to help Cale design 3-D models...
21:11:48 <Saizan> "The purpouse of a system is what the system does" is taken too seriously here!
21:11:57 <FunctorSalad_> haha
21:12:02 <FunctorSalad_> nice
21:12:04 <ezyang> So, can people think up of examples of natural places where Control.Arrow functions pop up?
21:12:13 <halberd> suppose I have a "charge posting" module
21:12:16 <FunctorSalad_> (@ Saizan )
21:12:17 * BMeph hig-fives himself!
21:12:18 <Cale> ezyang: Mostly with (->)
21:12:27 <halberd> which is supposed to let hospital billers post charges to hospital accounts
21:12:31 <ezyang> Cale: I feel like Kliesli arrows ought to account for something
21:12:33 <ddarius> ezyang: The functions or actual uses of arrows.
21:12:44 <ezyang> ddarius: Functions.
21:12:57 <halberd> now, it turns out that there is a law that says that hospital billers need to inform their patients if Medicare is not likely to cover a given procedure
21:12:59 <ezyang> I think I'd be satisfied with generality over just regular functions and Kliesli arrows
21:13:04 <Cale> ezyang: Usually if you really have a monad, the monad interface is nicer than the Arrow interface. This is one of the main downsides of Arrow.
21:13:09 <dolio> ezyang: Kleisli doesn't work out to being very useful in practice, due to all the wrapping you'd have to do.
21:13:13 <ezyang> Cale: Sadface!
21:13:15 <dolio> Unfortunately.
21:13:17 <FunctorSalad_> ezyang: kleisli arrows correspond 1-to-1 to monads... just a different way of looking at monads
21:13:23 <ddarius> ezyang: Many of them are handy functions when specialized to the (trivial) (->) arrow, such as (&&&), (***), and (+++). (|||) is either.
21:13:40 <halberd> so that can be a bug in the charge posting module--because now, the charge posting module has to comply with the law, and give the billers those warnings (called ABNs, advanced beneficiary notices)
21:13:46 <FunctorSalad_> ezyang: nvm, that was your point
21:13:55 <halberd> when the module was written the law didn't exist
21:13:57 <FunctorSalad_> ezyang: CoKleisli? ;o
21:13:58 <ezyang> FunctorSalad_: Yeah. I was hoping that they could be automatically useful w/o wrapping and unwrapping
21:13:59 * BMeph prefrs Kleisli composition to bind, actually.
21:14:07 <Cale> Yeah, to use the Kleisli arrow with the Arrow interface, you also have to wrap your a -> m b functions, which makes things just awkward enough that you'll probably just avoid it
21:14:26 <aavogt> >=>
21:14:27 <FunctorSalad_> ezyang: I do find <=< useful (which is <<< without that wrapping)
21:14:37 <Cale> Which is why we have >=> and <=<
21:14:40 <ezyang> FunctorSalad_: Yeah
21:14:41 <halberd> eh I guess the channel has moved on
21:14:44 <ezyang> >=> and <=< are great.
21:14:54 <aavogt> fish!
21:14:57 <ezyang> I'm just sad that we can't generalize transparently.
21:15:00 <BMeph> halberd: I think your legislators have a bug in their law-making system... ;)
21:15:04 <dolio> halberd: What is the point of the new example?
21:15:21 <pickles> nite all
21:15:43 <Saizan> halberd: you can encode "this function must comply to the current relevant laws" in the type system, if you want :)
21:15:44 <ezyang> halberd: You should read "Adventures in Financial Contracts"
21:15:53 <ezyang> It might appeal to your current line of thought.
21:15:57 <Cale> halberd: Basically, my argument is that unless you can give me a mathematical specification of what the program is supposed to do, the question of whether it's correct is not a meaningful question anymore. Questions about whether it's useful for a particular task are another thing.
21:16:00 <halberd> dolio, the point is that the way that you knew the charge posting module is supposed to conform to the ABN law, is because it came attached to documentation and comments saying "this module is supposed to perform charge posting in adherence with all necessary accounting and other rules and regulations"
21:16:04 <ddarius> dolio: The point is that you can't write meaningless types but you can write meaningless comments.
21:16:10 <Saizan> halberd: so that type checking requires you to fetch the current laws!
21:16:37 <FunctorSalad_> ezyang: I found that sometimes I'm too eager to make an abstraction 'manifest' in the type system instead of just thinking in it
21:16:38 <dolio> Yes, as Saizan said.
21:16:54 <FunctorSalad_> ezyang: that leads to newtype proliferation indeed
21:17:02 <halberd> yes Saizan it does require you to fetch the current laws
21:17:11 <halberd> and companies that write such software hire lawyers for exactly that
21:17:14 <aavogt> ezyang: you couldn't write the instances that the Kleisli newtype has without the newtype, provided that you're ok with overlapping instances
21:17:39 <ezyang> aavogt: Oh, that's true.
21:17:44 <halberd> it's a process that can only, realistically speaking, be done by humans
21:17:46 <ezyang> Since a -> m b is still just a normal function.
21:18:04 <BMeph> Cans of hairspray are very useful for making impromptu flamethowers. Are they supposed to be used that way, um...no, of course not! :)
21:18:08 <FunctorSalad_> and you'd have to get rid of the plain (->) instance
21:18:18 <FunctorSalad_> I'd support that I think
21:18:37 <FunctorSalad_> for plain functions we have specialized utilities anyway...
21:18:38 <ezyang> bleh
21:18:43 <halberd> or here's a slightly better example (legally speaking), suppose you have to send out a detail bill to a guarantor, because the module does that it has to comply with HIPAA
21:18:46 <halberd> and it's a bug if it doesn't
21:18:51 <ezyang> There should be some way to specify which instance you want in an incoherent case.
21:18:59 <Saizan> halberd: maybe gathering them needs humans, but the type system can easily encode the fact that you've to use the current laws, rather then the ones that were there when you first wrote the program
21:19:06 <halberd> you can't express "compliance with HIPAA" as a type
21:19:19 <halberd> you express it in words, that lawyers have to review
21:19:20 <BMeph> My comment about the buggy legislators still stands. :)
21:19:52 <ezyang> Actually, I don't know if that's a good idea.
21:20:05 <FunctorSalad_> aavogt: wait... how do you make an instance from there?
21:20:53 <FunctorSalad_> we'd need a manifest binary type constructor, not just one in principle
21:20:57 <halberd> that's true Saizan but what if a new health care regulation comes out
21:21:01 <FunctorSalad_> (/\a b -> a -> M b)
21:21:09 <FunctorSalad_> no type lambdas in hs
21:21:10 <dolio> ezyang: I don't think that makes sense. Incoherent instances allow the selection of something like "instance Foo a" if methods of Foo are used on an unconstrained variable.
21:21:20 <dolio> ezyang: Selecting any particular concrete instance would be wrong.
21:21:24 <halberd> it would just come down to a list of legislation that the module is supposed to be compatible with
21:21:36 <halberd> and there's no way to formally verify that the list is correct, the lawyer just has to check it off
21:21:41 <Saizan> halberd: the point is, if there's a way to check that the program as written is acceptable, then there's a way to write that into the type system, unless the only criteria is "some guy says it is"
21:21:54 <ezyang> dolio: Yeah, I'd buy that.
21:22:14 <ezyang> But there are also cases when one instance is "more specific" than another, and hand wave hand wave should use that one hand wave
21:22:20 <halberd> realistically Saizan a surprising amount of what makes a program correct, is a bunch of people agreeing that it is correct
21:22:33 <halberd> for programs in many fuzzy real world problem domains
21:22:39 <ezyang> Really, I guess, you want the newtype transition to be as effortless as possible.
21:22:54 <FunctorSalad_> halberd: then these people should try to capture it in a model
21:23:04 <Saizan> halberd: the hope is that they are doing some kind of analysis of the prgoram, and you can replicate that
21:23:12 <FunctorSalad_> the typesystem should aim at that model from there.
21:23:13 <halberd> life does not often succumb so perfectly to computer models
21:23:26 <FunctorSalad_> it needn't be perfect
21:23:29 <Makoryu> Quick, someone go whip up a variation on Haskell with type-level lambdas and such (also please fix the Functor/Applicative/Monad hierarchy already)
21:23:47 <Saizan> Makoryu: Agda?
21:23:48 <FunctorSalad_> in fact many models are wildly simplifying
21:24:31 <halberd> for probably 90% of bug reports, it would have been impossible to express what they are complaining about as a bug, using types
21:24:43 <halberd> like for example, click hijacking
21:25:00 <FunctorSalad_> ezyang: coq does a logic-programming-style search for instances... the downside is that it's pretty unpredictable when it will succeed
21:25:17 <dolio> halberd: If you want to check the legislation in the type system, the legislation should be written as types. It's just that people don't generally want to do that.
21:25:38 <halberd> it doesn't even have to be a bug, it could just be poor user interface design
21:25:57 <halberd> the user complains "there are too many buttons, the colors are garish" and that is something you have to fix if you want people to use your program
21:25:59 <FunctorSalad_> ezyang: I mean, it doesn't have any restrictions, it just tries to find *any* derivation of MyClass Foo
21:26:16 <Saizan> halberd: yeah, but that's not something you'd write in a comment either
21:26:20 <ezyang> FunctorSalad_: Uhhh.
21:26:27 <Makoryu> Saizan: Hmmmmmmmmmmm maybe I should actually give it a shot
21:26:29 <dolio> -- these colors are not garish.
21:26:30 <ezyang> Are their type classes that bushy?
21:26:32 <Saizan> halberd: or do you write "it has to look nice" as a comment to your widgets?
21:26:38 <halberd> well no, it's generally assumed
21:26:41 <halberd> but actually, yes
21:26:57 <halberd> where I work there are strict UI guidelines that I have to follow, and if I don't follow them, it's a bug
21:27:10 <FunctorSalad_> ezyang: as long as the methods are propositions this is just fine; you don't really care about the proof term
21:27:24 <ezyang> huh.
21:27:27 <halberd> although I guess most of those specific guidelines could probably be checked by machine
21:27:29 * ezyang has difficulty imagining that world order. 
21:27:42 <FunctorSalad_> ezyang: but typeclasses in coq are experimental last time I checked, yes
21:27:43 <halberd> but some of them can't
21:28:15 <BMeph> halberd: Then, you are executing a UI style type system in your head. You just haven't considered that you could execute it with a computer made of silicon, instead of flesh. ;)
21:28:57 <FunctorSalad_> ezyang: yeah it's quite different than .hs
21:29:05 <halberd> well I am all in favor of computers verifying whatever they can verify, but we don't yet have human level AI
21:29:22 <FunctorSalad_> ezyang: with dependent types, a typeclass is just a record type + this automatic search
21:29:46 <ezyang> huh, so you don't declare instances
21:30:04 <Saizan> i think you do
21:30:45 <FunctorSalad_> there is an "instance" keyword, but AIUI it just defines a value of the typeclass type, and updates the search database
21:30:47 <ddarius> halberd: It's not a matter of "human level AI," it is a matter of ill-defined requirements.  A -human- can't accurately validate the "correctness" of your programs in those situations, or at best they can't prove it to someone else (in general) unless they actually have a formal proof."
21:30:53 <Saizan> but they are just functions that produce such records
21:31:01 <FunctorSalad_> yep
21:31:18 <halberd> ddarius, if your program isn't HIPAA compliant and your company and your customer's company both get sued into oblivion, that was a bug
21:31:51 <shapr>  lispy: wot?
21:31:53 <ezyang> halberd: May I suggest taking this discussion to #haskell-blah?
21:32:06 <ezyang> there appears to be an active audience, but I fear it has wandered too far from the path
21:32:12 <ddarius> halberd: You can't show that that "bug" doesn't exist in your code.
21:32:49 <FunctorSalad_> I find that the lack of a special types-and-typeclasses layer is the one thing that's *easier* in dep types ;)
21:33:09 <FunctorSalad_> (typelevel programming can make use of the whole language)
21:33:19 <ezyang> Hm.
21:33:31 <Saizan> though typeclasses are nice for pattern matching on types :)
21:33:47 <Saizan> but Coq has Ltac as a layer for doing that
21:33:50 --- mode: ChanServ set +o shapr
21:33:51 <kmc> you can keep stratification and still have the same constructs available at every level
21:33:56 <shapr> Did I hear off-topic?
21:34:16 <ezyang> it got shunted to #haskell-blah ;-)
21:34:24 <shapr> There's nothing worse than a grumpy shapr and off-topic discussions.
21:34:34 <FunctorSalad_> kmc: you mean as in simply throwing universe errors?
21:34:42 <FunctorSalad_> kmc: (they do that already)
21:35:31 <ezyang> Are there any other instances of arrow?
21:35:38 * BMeph thinks a manic shapr and OT discussions are MUCH worse! ;þ
21:35:43 <ezyang> kleisli and functions appear to be the only ones in Control.Arrow
21:35:49 <FunctorSalad_> ezyang: CoKleisli?
21:36:01 <shapr> BMeph: I disagree. When I feel manic, I politely shunt OT discussions to #haskell-blah.
21:36:04 <shapr> I'm not feeling polite at the moment.
21:36:05 <ezyang> smidge theoretical :^)
21:36:07 --- kick: shapr was kicked by shapr (Kicked by shapr)
21:36:24 * ezyang shouldn't be talking, since he's sort of blogged about comonads... 
21:36:30 <FunctorSalad_> hehe
21:36:34 <BMeph> ezyang: We have open type classes in Haskell; there are other Arrow types, just not in those libraries. :)
21:36:47 <ezyang> yeah. I don't know of a good way to look for them, though
21:36:50 <FunctorSalad_> you mean there are no practical comonads either?
21:36:57 <ezyang> There are.
21:37:09 <ezyang> But most people don't find the abstraction useful, afaict
21:37:14 <FunctorSalad_> ezyang: ah! [a] -> [b] was in one of the early papers I think
21:37:30 <ddarius> ezyang: They will one day.
21:37:30 <FunctorSalad_> not entirely sure what it gains you over Kleisli []
21:37:33 <ezyang> and one of the halmarks of a useful abstraction is you can make stuff for anything that fits in the abstraction.
21:37:34 <BMeph> ezyang: sigfpe disagrees with you there. :)
21:37:59 <ezyang> BMeph: Probably. Though I'll ask for a quote. :^)
21:38:00 <BMeph> ezyang: Er, I meant the comonad remark, BTW. :)
21:39:26 <ezyang> So as a pedagogical tool, it's great that we can draw parallels between the two
21:39:39 <ezyang> But as a programming tool, Control.Arrow seems a bit dinky
21:39:40 <FunctorSalad_> (there are conversions (. singleton) resp. concatMap)
21:39:52 <FunctorSalad_> (from [a]->[b] vs a->[b])
21:40:07 <Saizan> btw, you can rewrite Arrow's methods with Category and Applicative
21:40:10 <FunctorSalad_> not sure if the left type has anything interesting that's not a concatMap
21:40:20 <ezyang> Saizan: Oh really?
21:40:26 <ezyang> I guess I should go look up Category
21:40:44 <FunctorSalad_> well that's even less ;)
21:40:45 <Saizan> s/rewrite/implement/ -- or whatever
21:41:07 <ezyang> is that in category-extras?
21:41:19 <ezyang> looks like it.
21:41:20 <FunctorSalad_> in base
21:42:13 <ezyang> ah, ok
21:42:23 <ezyang> Was briefly scared by {Bi,Di}Kliesli :^)
21:43:10 <Saizan> arr f = f <$> id; f *** g = (,) <$> (arr fst >>> f) <*> (arr snd >>> g);
21:44:20 <ezyang> trippy dude.
21:44:33 <ezyang> are you using the reader applicative instance?
21:44:41 <FunctorSalad_> homfunctor strikes again?
21:44:41 <iaefai> Is there usually any reason to have tabs in an hs file?
21:45:29 * BMeph replaces the (***) with (+++), and other similar changes, to see if it works there, too...
21:46:11 <Saizan> ezyang: yeah, i'm assuming Category arr and Applicative (arr e)
21:46:26 <ezyang> Saizan: Ok, I'll need to think about that some more.
21:49:41 <FunctorSalad_> ezyang: just remember Reader's even a monad and monad is stronger than these
21:49:58 <BMeph> ezyang: About useful comonads: how many useful [a] -> b functions do you know of? ;)
21:50:02 <ezyang> Well, that's why I said "Reader Applicative" :-)
21:50:05 <FunctorSalad_> ezyang: so it's the same superclass defaults as for every monad
21:50:16 <ezyang> BMeph: Huh. Now that you mention, that's every fold ever...
21:50:32 <ezyang> But I'm not sure if the comonad machinery helps you there?
21:50:34 <FunctorSalad_> BMeph: do you mean me?
21:50:35 <Saizan> though this is not the normal Reader, you've to s/->/arr/
21:50:53 <ezyang> Saizan: Bah, non-exotic stuff first :-)
21:50:55 <FunctorSalad_> BMeph: (I had been wondering about [a] -> [b])
21:51:15 <ddarius> ezyang: I'm pretty sure comonads will become popular and (relatively) day-to-day at some point.  Applicative was mostly unknown for years before it became popular.
21:51:17 <BMeph> FunctorSalad_: I only remembered seeing ezyang doubting the usefulness of comonads, but if it applies, sure! ;)
21:51:43 <FunctorSalad_> BMeph: for a concrete value of the arrow type, a and b are fixed, though, not universally quantified
21:51:50 <ezyang> ddarius:  I think part of applicative's success was the highly suggestive "idiom bracket" and <$> + <*>
21:51:53 <FunctorSalad_> BMeph: so `length' would be one example
21:51:58 <Niccus> if monads sounded scary comonads sound twice so
21:52:20 <ddarius> ezyang: Perhaps.  I'm not saying the current interface will become popular.
21:52:27 <ezyang> fair enough
21:52:50 <ezyang> Don't get me wrong; I want these ideas to become popular
21:52:58 <ezyang> I just don't know how to "make it so" :_)
21:53:02 <FunctorSalad_> [a] -> [b] being a "proper" arrow
21:53:55 <Saizan> one problem with comonads is that you lose currying
21:54:42 <FunctorSalad_> BMeph: [a] -> b for fixed a,b seems fine
21:54:59 <BMeph> "Anyway, I was thinking about stream functions. A stream function from a to b is simply a function [a]?[b]. (Strictly speaking we're only considering infinite lists - streams.) This doesn't quite fit the pattern of non-fancy?fancy, it's more like fancy?fancy. And that's what the Arrow interface allows us to do." <- from Dan's "main" comonad advocacy post.
21:55:07 * ezyang now wants to figure out if folds and comonads play nicely. 
21:55:22 <ezyang> I loved that post.
21:55:29 <ezyang> It crystallized so much. On multiple readings.
21:56:09 <BMeph> ezyang: They have to - folds are "unrolled" algebras. <hand waves until ddarius takes over...>
21:56:29 <ezyang> what's an unrolled algebra?
21:56:46 * BMeph was responding to ezyang "out loud"...
21:57:22 <FunctorSalad_> hmm I'd say the fold is the mediator of the fact  that the algebra is initial
21:57:43 <FunctorSalad_> the args to the fold specify a second algebra
21:58:00 <FunctorSalad_> initiality says that there must be a morphism
21:58:50 <ezyang> is an algebra an object in a category?
21:58:56 <ezyang>  I'm only familiar with initial and terminal objects
21:59:15 <FunctorSalad_> yeah, you fix an endofunctor T...
21:59:20 <BMeph> ezyang: Where the function takes all of the sructural forms of the folded type in separate arguments, as opposed to in one swapped-coproducts-for-products-and-vice-versa argument. If that makes any sense at all. :)
21:59:25 <ezyang> No.
21:59:38 <ezyang> More reading for me I guess...
21:59:43 <FunctorSalad_> cat of algebras = (x : Object originalCat, f: T x -> x)
21:59:54 <FunctorSalad_> these are the objects
22:00:00 <FunctorSalad_> morphisms are commuting diagrams
22:00:55 <ezyang> what are the arrows?
22:01:38 <FunctorSalad_> (actually there are two concepts there... algebra over a functor, algebra over a monad?)
22:01:47 <ezyang> ugh
22:01:58 <ezyang> and this is not helped by my fuzzy notion of an Algebra
22:02:00 <FunctorSalad_> the ones over a monad must satisfy some laws too
22:02:14 <FunctorSalad_> it's redefined here
22:02:37 <dolio> An arrow from (x, f : T x -> x) to (y, g : T y -> y) is an arrow h : x -> y such that h . f = g . T h
22:02:47 <ddarius> FunctorSalad_: Monad algebras are special cases of functor algebras.
22:02:48 <BMeph> I think http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html had some stuff about the algebra stuff - I'll re-skim it.
22:02:54 <FunctorSalad_> (but you recover cats of familiar algebraic structures that way; with the monad algebras at least)
22:03:23 <ezyang> >_<
22:03:28 <FunctorSalad_> ddarius: I meant that the cats aren't a special case (Monad-Alg(T)
22:03:38 <FunctorSalad_> \subseteq Functor-Alg(T))
22:03:45 <ddarius> ezyang: Given an endofunctor, F, any endofunctor at all, an F-algebra is simply an arrow FA -> A.
22:04:12 <FunctorSalad_> and you need the monadic conditions to recover algebraic structures AFAIK
22:04:21 <FunctorSalad_> (for T=free group, say)
22:04:28 <ddarius> FunctorSalad_: The category of algebras on a monad is a subcategory of functor algebras over the underlying functor of the monad.
22:04:44 <FunctorSalad_> I just wrote that :)
22:04:45 <ezyang> I don't have a good enough notion of an endofunctor to interpret ddarius's statement
22:05:00 <FunctorSalad_> \subseteq should have been subcat, yes
22:05:13 <ddarius> ezyang: An endofunctor is just a functor F : C -> C for some category C, i.e. a functor with the same domain and codomain.
22:05:25 <ezyang> right, so what does FA mean?
22:05:41 <ezyang> and we're also treating the endofunctors as objects, which is making my head hurt.
22:05:55 <ddarius> ezyang: The functor F applied to an object A.
22:06:03 <ddarius> E.g. in Haskell it would be like Maybe Int.
22:06:24 <ezyang> so... A is an object in the category, sure.
22:06:43 <ezyang> oh!
22:06:57 <ddarius> ezyang: However, I agree.  You want to have a better handle on the basics of functor and category before bothering with F-algebras.  Those aren't even remotely complicated subjects though.
22:07:15 <BMeph> FunctorSalad_: \subsmallcat perhaps? ;)
22:07:16 <ezyang> so... I guess the F-algebra sort of reverses the action of the endofunctor?
22:07:26 <ezyang> ddarius: Yeah.
22:07:41 <ezyang> I finished the first chapter of Awodey's textbook, but I need to do the exercises.
22:07:45 <ddarius> ezyang: No, it is just an arrow.  E.g. in Haskell, type Algebra f a = f a -> a
22:08:09 <ezyang> oh right
22:08:16 <ezyang> need to stop s/arrow/function/
22:08:35 <FunctorSalad_> BMeph: *pictures kitten glyph for some reason*
22:09:15 <BMeph> ezyang: A minor infraction. Just be sure not to do s/arrow/Arrow/ :)
22:09:18 <FunctorSalad_> I think the functor view corresponds to algebraic structures without any laws
22:09:37 <FunctorSalad_> like for f x = (x,x) , an algebra is a magma
22:09:56 <ddarius> FunctorSalad_: In Haskell perhaps, but there is no issue in general.
22:10:09 <tensorpudding> "a small category is a kittygory"
22:10:13 <FunctorSalad_> but for groups, monoids or so you need f x = free group to capture it in this view
22:10:26 <Saizan> a standard example: data Expr a = Const Int | Add a a; evalAlg :: Expr Int -> Int; evalAlg (Const i) = i; evalAlg (Add x y) = x + y; then fold evalAlg :: Mu Expr -> Int
22:10:51 <ezyang> clever use of Mu :^)
22:11:14 <FunctorSalad_> ddarius: I was thinking about the case that the base cat is Set
22:11:31 <FunctorSalad_> to get the correspondence to traditional algebraic structures
22:11:40 <dolio> ddarius: By special case, did you mean that monad algebras for a monad T can be specified as being just the functor algebras for some other functor F? Or that any monad algebra for T is also a functor algebra for T?
22:11:55 <FunctorSalad_> of course the base cat may have equational laws already built in
22:12:09 <FunctorSalad_> of may not be concrete at all
22:13:01 <FunctorSalad_> s/of may/or may/
22:16:13 <ddarius> dolio: The latter.
22:16:17 <dolio> Okay.
22:17:06 * BMeph has concluded that sigfpe needs an index for his blog posts
22:17:29 <ddarius> FunctorSalad_: You can write F : Set -> Set, FX = the free monoid on X quotiented by x^2 = 1.
22:17:38 <FunctorSalad_> I guess the free monad of the functor has the same monad-algebras as the functor has functor-algebras
22:19:02 <FunctorSalad_> ddarius: I mean that with just a functor, you can't enforce that the algebra's multiplication is anything resembling a monoid multiplication
22:19:39 <FunctorSalad_> like the triangle law that says that quoted elements eval back to themselves
22:19:47 <FunctorSalad_> ("quote"=return)
22:20:08 <ddarius> FunctorSalad_: An F-algebra doesn't inherently have a "multiplication."  However, the "multiplication" in something like FX = the free group on X is certainly a group multiplication.
22:20:44 <FunctorSalad_> ddarius: "multiplication" is just a suggestive name for the algebra's morphism
22:21:51 <ezyang> I love suggestive names!
22:22:11 <ezyang> they're bad, but I still like 'em
22:22:22 <ddarius> FunctorSalad_: That's not a very suggestive name.  For an F-algebra, the F-algebra basically -is- the "interpretation" morphism.  There is no sense of "multiplication."  There's not even a binary product (even using a tensor product) in sight.
22:23:07 <FunctorSalad_> ddarius: a function from FX to X is *not* a group structure on X in general
22:23:17 <FunctorSalad_> ddarius: that's exactly what you need the monad-algebra laws for
22:24:16 <FunctorSalad_> and yes, in that case it is the multiplication of formal expressions to values
22:24:35 <FunctorSalad_> "multiplication" as the activity you do while evaluating
22:26:37 <FunctorSalad_> if you picture the free group as the group of formal expressions (in the language of groups) with constants the original group elements
22:26:50 <FunctorSalad_> (modulo the group axioms)
22:28:26 <FunctorSalad_> seems like multiplication to me
22:29:00 <ezyang> Is it just me, or does it feel really natural to look at a concrete system and say, "Here are the bits that you can generalize"?
22:30:05 <ddarius> ezyang: There are usually many obvious points of generalization.  Some more fruitful than others.
22:30:53 <ddarius> FunctorSalad_: I'm pretty sure we've been talking about different things for a while now.
22:33:56 <FunctorSalad_> ddarius: maybe the misunderstanding is that if F = free group functor, then the algebra arrow ("multiplication") m : F X -> X evaluates arbitrary group expressions; it is highly redundant. The binary multiplication is recovered if you plug in a free group element which is the mult. of two generators
22:34:35 <FunctorSalad_> ddarius: this is in contrast to sth like data F x = Ident | Mult x x
22:35:50 <ddarius> FunctorSalad_: Yes, the latter is what F-algebras do.  The former is how T-algebras work.  F-algebras and T-algebras (despite T-algebras being F-algebras) work differently and express somewhat different things.
22:36:14 <FunctorSalad_> ddarius: that's what I was arguing as well
22:36:50 <ddarius> F-algebras are a pretty direct generalization of universal algebra.  The functor F captures the signature, which, and this is why I originally responded, can be an -equational- signature, it can have equations.
22:37:46 <FunctorSalad_> so you put F = one level of term structure, not F = free algebra of the signature in question?
22:37:57 <FunctorSalad_> then I don't see where equations can come in
22:38:33 <FunctorSalad_> except when already built into the base category somehow
22:39:26 <FunctorSalad_> ddarius: ah... I think you're thinking of functors which have to preserve certain diagrams
22:39:49 <FunctorSalad_> *arbitrary* functors won't let you express equations
22:41:41 <FunctorSalad_> no wait, these last two messages are confused...
22:42:26 <FunctorSalad_> it's not F that will preserve stuff here; it's the algebra [function]
22:44:21 <FunctorSalad_> ok I guess my sleepyness shows, but I still don't think you can capture groups as F-algebras for some F : Set -> Set :)
22:44:29 <FunctorSalad_> (@ ddarius )
22:45:12 <ddarius> FunctorSalad_: I think I may just be wrong, but I feel pretty confident that I've seen initial algebras with equational constraints and you don't usually bother calculating the initial T-algebra.
22:46:54 <FunctorSalad_> ddarius: this thing where you formulate the group laws as diagrams?  groups can be defined as functors from that diagram category to Set
22:47:05 <ddarius> FunctorSalad_: I'm not thinking of sketches.
22:47:21 <ddarius> No initial algebras come up there.
22:48:02 <FunctorSalad_> right, "sketches'
22:49:47 <FunctorSalad_> (finite limit preserving functors, to correct myself there)
22:50:39 <FunctorSalad_> or just finite products for groups; pullbacks were for categories etc
22:58:36 <ibid> any community.h.o (nun) admins here?
23:14:02 <ManateeLazyCat> My code use hidden modules in other cabal package, so how to write .cabal file to make can use those hidden modules?
23:14:04 <ManateeLazyCat> Thanks!
23:18:28 <Saizan> you can't, you've to edit the other package to make those modules exposed
23:18:38 <ManateeLazyCat> Saizan: Thanks.
23:18:59 <ManateeLazyCat> Saizan: I'm now convert all non-core gtk2hs package to Cabal.
23:20:14 <Gracenotes> nice. the core already being converted?
23:20:15 <ukl> hello #haskell.  I just stumbled upon python's yield() and generator stuff which helped me quite a bit -- Is there something comparable in Haskell?  (Or how to fix the haskell solution: http://pastie.org/929249 (Haskell) <-> http://pastie.org/929250 (python) ?)
23:20:32 <ManateeLazyCat> Gracenotes: Yes, cairo, glib, gdk, gtk, pango have finish.
23:20:48 <Gracenotes> gtk, cairo and pango are the bits I use :)
23:21:10 <ukl> I think there could be a way to solve the haskell problem with changing what happens with Â»accÂ«, but I can't wrap my mind around it (tuples vs lists isn't important in this case, lists are fine)
23:21:18 <ManateeLazyCat> Gracenotes: After i finish non-core packages convert, i will split all those non-core packages to they own repository.
23:21:33 <Gracenotes> what are some examples of non-core?
23:21:41 <ManateeLazyCat> Gracenotes: Now, i'm tring to convert WebKit and VTE.
23:22:00 <ManateeLazyCat> Gracenotes: All packages except glib, gdk, pango, cairo, gtk, gio.
23:22:01 <Gracenotes> the webkit with the GTK backend, I take it :P
23:22:17 <Axman6> ukl: can you give me an example of an input and an output you expect from sarah?
23:22:24 <ManateeLazyCat> Gracenotes: WebKit can works perfect, just need convert to Cabal make it can install easily.
23:22:52 <ukl> Axman6: input: n, output: all n-tuples with elements in {0,1}
23:23:21 <Axman6> > let sarah n = replicateM n [0,1] in sarah 3
23:23:21 <ukl> like all the paths you could walk down a binary tree of depth n
23:23:22 <lambdabot>   [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]
23:23:23 <Gracenotes> ManateeLazyCat: then we have a Haskell web browser! With features comparable to Firefox! All in a few months! Hurrah!
23:23:31 <Gracenotes> ;)
23:23:31 <Axman6> whoot, binary counting!
23:23:34 * Axman6 levels up
23:23:44 <ManateeLazyCat> Gracenotes: Yes, i have write demo program under `gtk2hs/demo/webkit`.
23:23:55 <Saizan> ukl: why do you think your haskell version is incorrect btw?
23:23:56 <Axman6> ukl: you won't get arbitrary tuples, it won't be well typed
23:24:14 <ukl> Axman6: I know, that's why I'd settle with a list
23:24:21 <Axman6> what about a list of lists?
23:24:39 <ukl> Saizan: I'd hoped to get [[1,1], [1,0], ...] using my haskell solution if it was corrected
23:24:41 <Axman6> which matches what you want a lot better
23:24:49 <Axman6> > let sarah n = replicateM n [0,1] in sarah 2
23:24:50 <lambdabot>   [[0,0],[0,1],[1,0],[1,1]]
23:24:52 <ukl> just like what Axman6's replicateM line does
23:25:37 <ukl> there's this issue, explaing recursion to sarah will be a lot easier than trying to explain replicateM (and she's using python anyway)
23:25:46 <ManateeLazyCat> Gracenotes: All cabal package is in darcs repository of gtk2hs, but please don't use it now, we're still testing those packages.
23:26:23 <Gracenotes> do you think there'll be many versioning issues?
23:26:44 <ukl> So, has anyone an idea how to fix the pastie-try to match "replicateM n [0,1]"'s output?
23:26:57 <Axman6> ukl: yeah, i'm not sure i could explain the replicateM version either
23:27:04 <Gracenotes> then again, people who have been using stable releases can continue to do so, and it should recompile fine...
23:27:27 <ManateeLazyCat> Gracenotes: Well, current core packages have finish, but non-core packages haven't convert finish, we need adjust core package to support non-core packages convert, so current situation is not stable.
23:27:34 * hackagebot graphics-formats-collada 0.1.0 - Load 3D geometry in the COLLADA format  http://hackage.haskell.org/package/graphics-formats-collada-0.1.0 (LukePalmer)
23:28:30 <Saizan> ukl: http://pastie.org/929259
23:28:39 <ManateeLazyCat> Gracenotes: After we finish Cabal package convert, we will release it release version, then we will fix Gtk+2.18 pathces in other repository, after fix, we will push all Gtk+ 2.18 patches to main repository.
23:29:16 <ManateeLazyCat> Gracenotes: After Gtk+ 2.18 test complete, i will update gtk package to Gtk+ 2.20, and this need waiting next month that Ubuntu 10.04 release.
23:29:53 <Gracenotes> oh, right, it's been almost half a year already
23:29:54 <ukl> Saizan: thanks a lot
23:30:02 <Ke> ManateeLazyCat: so did you actually link to webkit-gtk or just make an another bundle
23:30:48 <Saizan> ukl: np, you basically forgot to translate a yield :)
23:31:12 <ManateeLazyCat> Ke: Current, webkit package still in gtk2hs darcs repository, after i finish Cabal convert, i will move Webkit package from gtk2hs darcs repository, build new repository : http://code.haskell.org/webkit
23:31:32 <ukl> Saizan: right, all my lists got flattened out
23:31:42 <Ke> ManateeLazyCat: but what flavour of webkit
23:32:25 <Ke> I have at least 3 installed already
23:32:32 <ManateeLazyCat> Ke: WebKit works perfect. http://farm3.static.flickr.com/2800/4448123474_3879e3f878_o.png
23:32:39 <Ke> code share with webkit is in abysmal state
23:33:23 <Ke> we are not communicating
23:33:50 <ManateeLazyCat> Ke: You mean WebKit is not safe?
23:33:57 <Ke> no
23:35:51 * ManateeLazyCat Damn emacs crash again. 
23:41:34 * ManateeLazyCat I need do convert Cabal job for gtk2hs, all gtk2hs users waiting us release next version, very soon. :)
23:42:12 <Axman6> hooray: just created a function to compute all the grey codes up to an arbitary length
23:43:17 <ski> how about computing every grey code ?
23:43:51 <Axman6> it's possible, but then i don't get nice uniform lengths
23:44:05 <ski> aye
23:44:56 <Axman6> god i love laziness :)
23:45:18 <ezyang> yum yum
23:45:21 <ezyang> "memoization for free"
23:45:39 <Axman6> ezyang: there's not really much free memoisation in haskell :(
23:45:57 <ezyang> Axman6: I thought infinite maps sort of gave you that?
23:46:00 <Axman6> `last (grey 20)` takes less than a second, thanks to laziness
23:46:22 <ski> well, if you indirect your function via an array, or a stream, or other such data structure, you can get "memoization for free"
23:46:49 * Axman6 doesn't count writing extra code as being free
23:46:57 <ezyang> heh
23:47:17 <ezyang> it doesn't really give you a way to reclaim the memory either
23:48:34 <Axman6> not much in haskell does though :P
23:50:04 <blackdog> Axman6: so blackh is coming to ozhack, it seems:) have to arrange a pub night or something
23:50:36 <Axman6> yes indeed :)
23:50:42 <Axman6> wait, only one? what is this!
23:50:51 <blackdog> heh
23:51:01 <blackdog> well, i'd like to make a bid for the taphouse or the red oak
23:51:07 <blackdog> but they're both a fair way away from UNW
23:51:09 <blackdog> UNSW
23:51:37 <Axman6> i'm counting on you to know where good pubs etc are
23:51:52 <blackdog> it's all good if we can make it to the city
23:52:00 <Axman6> ok
23:52:01 <blackdog> out at UNSW ... i guess there's the royal, which sucks
23:52:18 <blackdog> the palace is alright on an afternoon
23:52:23 <blackdog> looking out over coogee
23:52:30 <blackdog> we'll work something out.:)
23:53:00 <Axman6> :)
23:57:02 <ezyang> I have a question about byorgey's assertion that a species is an endofunctor on the category of finite sets with bijections as arrows
23:57:20 <ezyang> which is, where is the "shape" of the specie encoded in this endofunctor?
23:57:36 <ski> > let memoizedFib x = ($ x) . fixTabulate (0,x) $ \fib n -> case n of 0 -> 0; 1 -> 1; n | n >= 2 -> fib (n-1) + fib (n-2) in memoizedFib 100
23:57:38 <lambdabot>   354224848179261915075
23:57:51 <ski> Axman6 : ^ not *that* much extra code ..
23:58:06 <ddarius> ezyang: There's two answers.  There's the concrete but slightly wrong answer and then the definite answer.
23:58:08 <ski> one could also write
23:58:26 <ezyang> I'll go for both.
23:58:37 <ezyang> I assume slightly wrong means that it's not fully general.
23:58:57 <ski>   (memoArr (0,100) -> fib) = \n -> case n of ..fib..
23:59:04 <ddarius> ezyang: One is that the functor produces a finite set and that finite set can be a "thing."  It can and often will have extra structure.  However, really, in set theory all that matters is how many elements you have.
23:59:14 <ski> if one can fix the bounds beforehand
23:59:26 <kamatsu> blackdog: the regent hotel :P
23:59:32 <ddarius> ezyang: So "really" where the "shape" comes in is how the particular functor (for the particular species) acts on bijections.
23:59:37 <blackdog> kamatsu: urgh
23:59:49 <ezyang> Oh wait, sets can have extra structure?
23:59:51 <ezyang> that's news to me
