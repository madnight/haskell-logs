00:00:06 <kmc> that should be the soundbite marketing point for dependently typed languages
00:00:13 <dolio> Which caused agda to use all my memory and force me to reboot.
00:00:17 <kmc> ouch
00:00:27 <kmc> Haskell programs seem especially prone to doing that
00:00:39 <kmc> i've written a lot of shitty python and C++ programs in my day, but rarely did one instantaneously hose the entire machine
00:00:44 <Saizan> kevinulin: if you don't think you want to use the reader function at multiple types, what's the problem?
00:00:56 <kevinulin> I want to be able to read Ints and Strings
00:01:03 <dolio> Maybe there's an option to make failure to termination check an error. Maybe I should check.
00:01:06 <Saizan> kevinulin: there's no subtyping in haskell
00:01:22 <Saizan> kevinulin: ah, ok, so you do want to use it with multiple types
00:01:30 <ski> kevinulin : s/subtypes/type instances/
00:01:40 <kevinulin> hah
00:02:30 <ski> `[Char] -> Int' is not a subtype of `forall a. [a] -> Int' .. it is an instance of the latter generic/polymorphic type
00:02:40 <Saizan> ok, so you want it to be a polymorphic component
00:02:48 <kevinulin> Saizan, i dont expect it to be magic, I want each time the reader is called to look like (reader handle  :: IO Int)
00:02:58 <arcatan> i've been having impression for the whole morning that kevinulin is looking for type classes
00:03:23 <Saizan> kevinulin: i.e. something like data NetworkManagaer = NW { reader :: forall a. Handle -> IO a , ... }
00:03:56 <ski> (maybe with a class constraint, if that's what you want)
00:04:00 <Saizan> kevinulin: the need for type annotations is an orthogonal issue, most of the time the type will be inferred from the context i'd say
00:04:56 <Saizan> kevinulin: the problem with "reader :: forall a. Handle -> IO a" is that it's impossible to write a function with that type, to construct a NetworkManager, so you probably want to add a typeclass constraint there
00:06:01 <Saizan> maybe Binary a =>
00:06:45 <Saizan> since then you can use the get method to make up the value from a stream of bytes
00:07:09 <kevinulin> ya I have been using Binary
00:07:30 <kevinulin> but I am not certain about this "forall" what is that called so I can read up on it
00:07:34 <kevinulin> the overall concept I mean
00:07:35 <Saizan> data NetworkManagaer = NW { reader :: forall a. Binary a => Handle -> IO a , ... }
00:07:42 <Saizan> universal quantification
00:07:51 <Saizan> that's what the forall is doing
00:08:00 <kevinulin> thanks
00:08:15 <Saizan> it's saying that reader should work for all types 'a', so the caller can choose
00:08:49 <Saizan> though the caller must also make sure the type he chooses for 'a' is an instance of Binary, in this case
00:09:03 <Saizan> so the reader function will have access to Binary's methods
00:09:30 <kevinulin> that seems perfect
00:09:46 <kevinulin> there is probably a reason it looks ugly and is hidden, will I be forever shamed for using it?
00:10:02 <Saizan> no
00:10:21 <Saizan> it's a standard technique
00:10:50 <Saizan> you'll have to add {-# LANGUAGE Rank2Types #-} though
00:14:35 <kmc> people on Reddit will use your code to make fun of Haskell
00:14:45 <kmc> but it is very standard
00:15:00 <kmc> i think Rank2Types and ExistentialQuantification are pretty essential for real code
00:15:17 <kmc> the other GHC extensions i could live without, though they make a lot of things nicer, often in superficial but pretty ways
00:15:30 <kmc> (that's not counting FFI or unboxed / primitive stuff as extensions)
00:15:31 <Saizan> yeah, they are how you do larger scope abstractions with just type theory :)
00:16:15 <kevinulin> well I could do the same thing I suppose without passing the function around in the NetworkServer record
00:16:21 <kmc> kevinulin, btw, that's a different type from:  data NetworkManager = forall a. (Binary a) => NW { reader :: Handle -> IO a }
00:16:23 <kevinulin> and then people on reddit will like me
00:16:25 <kmc> which is an "existential type"
00:16:37 <kmc> and says that inside every NetworkManager is *one particular a* only
00:16:52 <kmc> and that the reader will only work with that particular a, and the caller can't tell what it is
00:16:56 <kmc> this is probably not what you want here
00:17:00 <kmc> it is how we do things like OOP in Haskell
00:17:06 <kmc> or a way
00:17:36 <kmc> you have multiple implementaiton types, each hidden, with an exposed interface that keeps the implementation type hidden
00:19:14 <Saizan> kevinulin: also btw, even if you haven't seen the forall keyword you've probably used the same concept before
00:19:28 <Saizan> since the fully explicit type of e.g. map is:
00:19:29 <Saizan> ?type map
00:19:30 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
00:19:58 <kevinulin> seems so redundant
00:20:21 <aavogt> it is
00:20:42 <aavogt> :t runStateT
00:20:43 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
00:20:51 <m3ga> is anyone else having touble logging into the ghc trac?
00:20:55 <Saizan> the forall is in fact redundant if it's there in the prefix, that's why it's hidden by default
00:21:11 <[swift]> i don't get the use of "forall"
00:21:24 <Saizan> though using the forall in inner parts of the type let you do more interesting things.
00:21:28 <aavogt> m3ga: for a bit there, but it has worked very recently
00:21:35 <[swift]> it sounds like it should be "thereexists", and the name "existential type" seems to align with that view
00:21:39 <Saizan> like the NetworkManager above
00:21:56 <[swift]> maybe i'm just not thinking about it correctly
00:21:58 <kmc> [swift], yeah, in other Haskell compilers they have an "exists" kw
00:22:00 <kmc> GHC is weird
00:22:00 <Saizan> [swift]: it's saying that map works forall types a and b
00:22:10 <kmc> it doesn't really have first class suport for existentials
00:22:17 <kmc> the "forall" makes sense on the type of the ctor
00:22:17 <m3ga> i haven't been able to log in since the weekend. iceweasel keeps getting a redirect loop.
00:22:19 <kmc> i.e.
00:22:37 <kmc> data All = forall a. All a;  All :: forall a. a -> All
00:22:42 <kmc> makes even more sense with GADTs
00:22:47 <kmc> with GADT syntax anyway
00:22:49 <m3ga> same with galeon
00:23:07 <aavogt> needs more where
00:23:28 <[swift]> hmm, that does make more sense
00:23:33 <magthe> any user of "haskell mode for vim" in here?
00:27:24 <ski> kmc : even `FlexibleInstances' ?
00:27:38 <kmc> ski, i'm unsure
00:27:44 <kmc> about all the typeclass hackery
00:27:46 <tab> magthe: tried but haven't managed to make it work i think
00:27:46 <kmc> including MPTC
00:28:12 <ski> [swift] : so, the `forall a. (Binary a) => ' in `data NetworkManager = forall a. (Binary a) => NW { reader :: Handle -> IO a }' refers to the fact that when calling the data constructor `NW', it will work for any type `a' in `Binary'
00:28:32 <kmc> ski, i was earlier thinking about this by comparison to C++ and Java
00:28:44 <ski> (and since `a' doesn't occur in the result type `NetworkManager' of the data cosntructor, it will hide/package up the type)
00:28:57 <magthe> tab: I have it working, mostly, the upgrade to 6.12 broke the doc part slightly, I think... at least I can't add imports based on function names at all times
00:29:01 <kmc> and i'd vastly prefer programming a real project in H98 + existentials + rankN than either of those
00:29:18 <ski> what was the comparision ?
00:29:20 <kmc> and i can't for sure say that about pure H98 because some things do get really cumbersome
00:29:44 <kmc> i think ST is essential for real stuff, for example
00:29:55 <tab> magthe: which one are you using ? 20090430 ?
00:29:57 <kmc> sometimes you need the fastest algorithm and it's inherently mutating
00:30:04 <ski> for when you want internally mutable algorithms, yes
00:30:12 <kmc> GHC does unification with a mutating algo, iirc
00:30:22 <kmc> and so ST => Rank2
00:30:37 <kmc> also SYB but that's less essential
00:30:41 * ski did too, in his simple logic programming library (that also allowed goal implication)
00:30:50 * ski is unsure about SYB
00:31:06 <magthe> tab: yes, the latest released version, AFAIK
00:31:18 <kmc> i have not used full-on SYB much, but i do like having Data and Typeable derived
00:31:22 <kmc> for little boilerplate-elimination things
00:32:20 <tab> magthe: it probably need fixing for ghc6.12. I'm going to wait before trying again
00:32:36 <kevinulin> why must days be so short, thanks for the help all, but looks like forall is not a project fornow
00:34:11 <magthe> tab: probably... it's just so weird that for some functions I can use the shortcut to get an import statement, but not for others
00:35:27 <tab> magthe: do you what the feature use to do that ? hoogle ?
00:35:58 <ski> kmc : `Typable' is mostly good, but incomplete .. i haven't looked at what `Data' actually can do much
00:36:33 <ski> (i'm all for eliminating boiler-plate .. i'm just unsure of how good the SYB way of doing that is)
00:37:43 <kmc> ski, mm
00:37:48 <kmc> i like Uniplate too
00:37:51 <kmc> but haven't used it yet
00:37:55 <aavogt> well syb is sort of free if you have RankN types
00:38:05 <aavogt> minus the codegen for Data and Typeable
00:38:26 <aavogt> actually it might only be Rank2
00:38:34 <aavogt> *polymorphism
00:39:41 <kmc> i think only rank 2
00:39:55 <aavogt> syb is quite nice for stuff like: http://code.haskell.org/~aavogt/XMonadConfigUpdater/tests/runTests.hs
00:39:56 <kmc> anyway i don't consider SYB / Typeable / Data "essential" the way that ST is essential
00:40:02 <kmc> and the way that existentials can be essential
00:40:12 <kmc> i'm not aware of any viable pattern for eliminating existentials, in general
00:40:12 <aavogt>                 let eraseSrcLoc = everywhere $ mkT $ const $ SrcLoc "" 0 0
00:40:21 <kmc> possibly you have to make your implicit open variant into an explicit closed variant
00:40:25 <aavogt> that would have been so much code
00:42:11 <ski> kmc : fully agreed on existentials
00:42:49 <ski> (in some cases, you can use closures rather than existentials .. but for serious examples, that's not possible)
00:43:03 <magthe> tab: yes, the feature worked find with 6.10, so I'm fairly sure it's the upgrade that broke it
00:43:21 <aavogt> what about section2 here: http://haskell.org/haskellwiki/Rank-N_types
00:43:32 <aavogt> (regarding existentials)
00:45:27 * ski finds it confusing that `.' links to docs on function composition
00:45:40 <ski> (in that page above)
00:46:16 <kmc> ski, hmm...
00:46:26 <ski> aavogt : but yes, you can use CPS instead .. however, that is often clunky
00:46:27 <kmc> yes you can use closures
00:46:45 <kmc> CPS would be general way to use closures to fake existentials?
00:46:55 <ski> if want to express `exists x. (x,(x,a) -> b', then this is simpler to express as `a -> b'
00:47:10 <aavogt> that didn't come out right
00:47:31 <ski> (in fact, that can be seen as an explanation of how functions that can depend on non-local variables can be implemented in terms of functions which can't)
00:47:53 <plusOverloader> good evenings guys
00:48:00 <ski> the CPS way is not really related to what i meant by using closures, here
00:48:07 <ski> morning, plusOverloader :)
00:48:17 <plusOverloader> ski: right, morning :)
00:48:28 <plusOverloader> I need some help overloading (+)
00:49:08 <plusOverloader> I'm trying to make this work: main = putStrLn ("a" + "b")
00:49:13 <plusOverloader> for that I've done this:
00:49:18 <ski> kmc : "using closure" being that sometimes, instead of storing an `x' (or a structure containing such), and a bunch of functions that operate on that `x', you can partially apply, so the `x' is no longer seen in the type
00:49:18 <plusOverloader> (+) :: [Char] -> [Char] -> [Char]
00:49:23 <plusOverloader> x + y = x ++ y
00:49:33 <kmc> right
00:49:35 <Jafet> Heh
00:49:43 <kmc> plusOverloader, nice nick
00:49:45 <kmc> ;)
00:49:45 <ski>   import Prelude hiding ( (+) )
00:49:57 <plusOverloader> kmc: haha, it's very to the point
00:50:00 <opqdonut> that's not overloading
00:50:01 <aavogt> instance Num String ...
00:50:03 <ski> plusOverloader : use that ^ to hide the standard `(+)' binding
00:50:04 <kmc> plusOverloader, (Prelude.+) has type (Num a) => a -> a -> a
00:50:05 <opqdonut> it's overriding or something
00:50:07 <plusOverloader> ski: right, but won't that also forget (+) for numbers?
00:50:09 <kmc> so you've got to either make a Num instance for String
00:50:12 <kmc> or to hide Prelude.+
00:50:15 <opqdonut> what kmc said
00:50:19 <ski> opqdonut : it is just defining a normal function :)
00:50:20 <kmc> plusOverloader, there's a hack
00:50:24 <kmc> you can define a new type class
00:50:35 <kmc> class Plus a where { (+) :: a -> a -> a }
00:50:48 <kmc> instance Plus String where { (+) = (++) }
00:50:49 <Jafet> AdditiveGroup!
00:51:01 <kmc> instance (Num a) => Plus a where { (+) = (Prelude.+) }
00:51:03 <plusOverloader> wow kmc that definitely looks like a hack
00:51:07 <plusOverloader> i dont even know whats going on
00:51:10 <kmc> turn on GHC extensions until it stops complaining
00:51:15 <kmc> plusOverloader, how much Haskell do you know?
00:51:20 <kmc> this is not a normal thing to do
00:51:23 <ski> Jafet : just say s/AdditiveGroup/Magma/ and be done with it :P
00:51:26 <plusOverloader> kmc: very little :)
00:51:30 <kmc> plusOverloader, ah
00:51:36 <aavogt> undecidable instances are bad
00:51:37 <kmc> then i advise you to just use ++ to glue strings together instead of +
00:51:39 <magthe> tab: it uses local haddock docs to do it... unfortunately it doesn't support using hoogle or hayoo at all :(
00:51:53 <mpiechotka> Hello. Does anyone know how to link yi (i.e. my config file) with mtl? I guess it is similar to xmonad.
00:51:57 <plusOverloader> kmc: no i understand that, its just that i'm following the Craft of functional programming book
00:52:05 <plusOverloader> kmc: and it's now teaching how to create an operator
00:52:10 <plusOverloader> kmc: like &&&
00:52:14 <kmc> oh
00:52:19 <kmc> then pick a name other than (+)
00:52:21 <plusOverloader> kmc: I dont really have a problem with using ++
00:52:23 <kmc> 'cause it's taken
00:52:42 <ski> plusOverloader : the only operations that can be overloaded are those that have been declared as methods of a type class
00:52:44 <kmc> names in Haskell don't overload just by defining them more than once
00:52:47 <kmc> that's illegal
00:52:54 <kmc> you have to define the name once, in a type class, and then provide instances
00:52:55 <chrisdone> outrageous!
00:53:04 <plusOverloader> kmc: it's just that I was expecting not to have any problems when I'm only trying to define (+) to work on [Char] and not anything else, as I've explicitly done in : (+) :: [Char] -> [Char] -> [Char]
00:53:06 <ski> plusOverloader : and even then, you can only do an overloading that conforms to the pattern the writer of the class set
00:53:21 <kmc> plusOverloader, you have two unrelated definitions of the same function (+), so it complains when you use it
00:53:23 <plusOverloader> kmc: I don't think Prelud has a (+) defined for [Char] -> [Char] -> [Char]
00:53:24 <kmc> because it doesn't know which you mean
00:53:30 <kmc> plusOverloader, Prelude has a (+) defined.
00:53:34 <kmc> types don't matter for name resolution
00:53:35 <chrisdone> mpiechotka: are you compiling with cabal?
00:53:46 <kmc> they matter for *instance* resolution, once you've resolved that the name is in a type class
00:54:00 <ski> plusOverloader : i.e. since we have `class Num a where (+) :: a -> a -> a; ...', it is impossible to overload it like `(+) :: X -> [X] -> [X]' for some type `X'
00:54:01 <mpiechotka> chrisdone: No - by yi installed script.
00:54:01 <Saizan> i.e. this is not C++
00:54:11 <kmc> what you're asking for is basically:  f :: Char -> Int; f 'x' = 3; f :: Bool -> Int; f True = 4
00:54:14 <mpiechotka> chrisdone: It is config file
00:54:30 <plusOverloader> ski: oh okay now i understand
00:54:51 <ski> plusOverloader : all things in `Prelude' are automatically imported (so `(Prelude.+)' is in scope), unless you say otherwise
00:55:06 <plusOverloader> ski: so if Prelude would have defined (+) as (+) :: Num -> Num -> Num then I'd be able to define for [Char] -> [Char] -> [Char] ??
00:55:25 <aavogt> use a multiparameter typeclass for your version of Num
00:55:25 <ski> plusOverloader : `Num' is a type class not a type
00:55:38 <chrisdone> mpiechotka: ew. well, if it calls ghc somewhere you can -package mtl
00:55:48 <kmc> plusOverloader, you can't define the same name twice.
00:55:51 <kmc> that's all there is to it.
00:55:57 <plusOverloader> ski: I understand that, I was just expecting Haskell to be a bit more like C++ when it comes to overloading
00:56:04 <aavogt> I do all the time with typeclass instances
00:56:08 <kmc> plusOverloader, expect Haskell to be the opposite of C++ in every way
00:56:14 <ski> plusOverloader : assuming you meant `(+) :: Num a => a -> a -> a' (which is the actual type of `(+)'), then you could technically probably overload it to `[Char] -> [Char] -> [Char]' .. with a few caveats
00:56:24 <plusOverloader> kmc: it's not just the name, it's the type too, but I understand that you're saying that Haskell doesnt take type into consideration when resolving overloads
00:56:27 <kmc> aavogt, i see it as those defining different behaviors of the single (+)
00:56:32 <kmc> plusOverloader, yes
00:56:38 <kmc> well, it does in one sense
00:56:41 <plusOverloader> ski: how would you overload it like that?
00:56:44 <kmc> but not willy nilly everywhere lke C++
00:57:02 <ski> plusOverloader : first, to be able to overload `(+)' you must write `instance Num X where x0 + x1 = ...' where you are wanting to overload it as `(+) :: X -> X -> X'
00:57:10 <kmc> plusOverloader, if it determines that the one only definition of a name is within "class Foo where ...", then it will look at the types you're using and find an "instance Foo where ..."
00:57:36 <ski> plusOverloader : secondly, `Num' not only contains the method `(+)', but also a bunch of other methods .. and you should implement those at the same time (or people will get angry at you)
00:57:57 <kmc> Num is a trainwreck though
00:58:01 <kmc> it really should be broken up into picees
00:58:15 <kmc> and i even think using UndecidableInstances to do so is acceptable in some cases
00:58:17 <kmc> aanyway
00:58:18 * ski is just using `Num' as an arbitrary example of how type classes work, here
00:58:44 <kmc> Num is complicated
00:58:47 <plusOverloader> i'm not concerned with Num
00:58:49 <kmc> Eq and Show are nice
00:58:53 <plusOverloader> just with the function (+)
00:59:01 <kmc> plusOverloader, sure
00:59:07 <kmc> if you were defining a custom function called "head"
00:59:09 <ski> plusOverloader : the other problem here is that even if you define all the methods in `Num' (some have default implementations, so you don't have to define those), `instance Num [Char]' is not valid Haskell 98
00:59:12 <kmc> you'd expect it to conflict with the Prelude head
00:59:32 <plusOverloader> kmc: not unless they've the same type signature
00:59:33 <ski> it is allowed with some extensions, though (but it is not clear that using them in this case is really a good thing to do)
00:59:45 <kmc> plusOverloader, with type inference
00:59:47 <kmc> when you say "head"
00:59:50 <kmc> it needs to know which you mean
01:00:05 <kmc> it would make things incredibly messy to have to keep many unrelated functions in mind
01:00:06 <plusOverloader> kmc: it can resolve that once it sees the types i'm using
01:00:08 <kmc> and then resolve which was meant
01:00:09 <plusOverloader> kmc: just like c++
01:00:17 <kmc> C++ doesn't have type inference
01:00:21 <kmc> you write the types every damn place
01:00:22 <kmc> so it's easy
01:00:23 <ski> plusOverloader : the only way it can do that is by using type classes
01:00:29 <kmc> C++1x will have pitiful type inference
01:00:35 <kmc> anyway, Haskell doesn't have overloading like that.
01:00:50 <ski> plusOverloader : Haskell supports (in one sense) a more general form of overloading than is usual
01:00:51 <plusOverloader> i understand, but at least for strings, it's always obvious that "blabla" is a string, it cant be anything else
01:00:53 <ski> @type sum
01:00:54 <lambdabot> forall a. (Num a) => [a] -> a
01:00:54 <ski> @src sum
01:00:54 <lambdabot> sum = foldl (+) 0
01:01:28 <plusOverloader> @type (+)
01:01:29 <lambdabot> forall a. (Num a) => a -> a -> a
01:01:35 <ski> plusOverloader : the definition of `sum' uses `(+)', but what type to use `(+)' on is *not* fixed at the time `sum' is defined .. it is just deferred to when `sum' is called
01:01:53 <plusOverloader> okay i understand that
01:01:57 <plusOverloader> then let me change my question
01:02:10 <kmc> plusOverloader, *shrug* it sounds like you are arguing for a different language design, rather than talking about what happens in Haskell
01:02:10 <plusOverloader> and this is coming from an assembly perspective so i apologize beforehand
01:02:13 <kmc> that's fine
01:02:15 <plusOverloader> but can I hook (+) ?
01:02:20 <kmc> no
01:02:23 <kmc> you can hide it and redefine it
01:02:25 <ski> so, in general, if you have `head :: [a] -> a', and also `head :: CatFood -> Bool -> String' then it can't know which `head' you want, just by looking at the context
01:02:31 <ski> the context might not tell enough
01:03:14 <plusOverloader> okay, i understand, because of type inference it cant possibly know which function i'm using if they have the same name but different type signatures
01:03:15 <ski> the only way it can do this is if `head' had been declared as a type class method (or as a "deferred overloaded" function that uses such a method)
01:03:32 <plusOverloader> kmc: i'm just trying to understand how haskell works, i don't want to change anything with it, it's a fine language
01:04:19 <kmc> ok
01:04:27 <ski> .. and using a type class forces all implementations of the overloaded `head' method to have a common pattern (the one the writer of the class wants it to have), so `[a] -> a' and `CatFood -> Bool -> String' would probably not be instances of the same pattern, so it wouldn't work in this case
01:04:31 <kmc> i'm not offended by people suggesting design changes
01:04:33 <kmc> btw
01:04:40 <kmc> there are a huge number of extensions in GHC
01:04:44 <kmc> and we spend a lot of time talking about new ones
01:04:46 <aavogt> ski: and getting both instances to resolve without lots of annotations is going to be tricky for that head
01:04:49 <Saizan> also, ad-hoc overloading like the one you're asking for is something that's quite against haskell's philosophy, as i understand it
01:04:49 <ski> type classes are meant to be used in "different, but same" situations
01:04:54 <kmc> i think this one would be against the general Haskell philosophy
01:05:04 <plusOverloader> Saizan: how so?
01:05:12 <plusOverloader> kmc: what's the philosophy?
01:05:16 <ski> type classes are not meant to be used in "oh, i want to reuse the same name for a completely unrelated kind of operation"
01:05:36 <plusOverloader> @type (++)
01:05:37 <lambdabot> forall m. (Monoid m) => m -> m -> m
01:05:46 <plusOverloader> ohh that's weird :)
01:05:48 <kmc> plusOverloader, enforcing that a name "means" one thing even if it works on different types
01:06:03 <plusOverloader> kmc: ok got it
01:06:10 <kmc> so that you can tell what the code does by reading it
01:06:47 <aavogt> > printf "%s-%d" "hello" 3 :: String
01:06:48 <lambdabot>   "hello-3"
01:07:10 <ski> plusOverloader : the actual type of `(++)' is `[a] -> [a] -> [a]' .. it is just that Cale would like it to have the more general type `Monoid m => m -> m -> m' .. so he's defined it in that way in *lambdabot* (to the dismay of some other people, worrying about it possibly confusing newbies about what the official type is)
01:07:57 <Jafet> @instances Monoid
01:07:58 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
01:07:58 <plusOverloader> ski: ok, i just confirmed that youre right with ghci
01:07:59 <ski> aavogt : indeed, type classes can be (ab-)used to do more ad-hoc overloading, too :) i'm just arguing it is not meant for that situation
01:08:03 <Saizan> ad-hoc overloading by type is known to give unexpected results quite easily
01:08:28 <Saizan> also, it's hard to make a larger abstraction over it
01:08:28 <ski> (aavogt : however, it is arguable whether the "vararg" pattern of `printf' is an instance of this "more ad-hoc overloading" proper ..)
01:09:10 <ski> plusOverloader :)
01:09:16 <aavogt> @hackage xformat
01:09:16 <lambdabot> http://hackage.haskell.org/package/xformat
01:10:27 <plusOverloader> well, thank you guys, kmc and ski and aavogt and Saizan
01:10:37 <plusOverloader> I'll go back to do some more reading now
01:10:49 <ski> plusOverloader : e.g. one expects that the overloaded `(==)' operation represents equality (as good as it can be approximated, in the presence of infinte and partial data structures)
01:11:02 <kmc> :)
01:11:17 <ski> and one expects `(+)' to be commutative(?) and associative
01:11:22 <kmc> plusOverloader, asm to Haskell... that's a pretty impressive jump
01:11:30 <kmc> i hope you find the two modes of thought complimentary
01:11:31 <kmc> :)
01:12:55 <plusOverloader> kmc: well I program c# too, but I have asm at heart.
01:13:23 <plusOverloader> kmc: i'm glad haskell has a FFI now (don't know if it had that a long time ago)
01:13:46 <Saizan> ~10 years i think
01:14:07 <plusOverloader> Saizan: why do they talk about it as if it were new for the 2010 release?
01:14:12 <ski> time flies like an arrow
01:14:37 <Saizan> plusOverloader: it wasn't in the haskell98 standard, only in an addendum
01:14:38 * ski feels like the FFI was introduced "recently"
01:14:55 <plusOverloader> Saizan: oh that's what it is then
01:15:00 * Taejo flies like a banana
01:15:07 <Saizan> but it was quite standard de facto :)
01:15:26 <plusOverloader> kmc: it's interesting, but you can also have higher-order functions in ASM
01:15:26 <kmc> hierarchical modules are also "new" in H2010
01:15:34 <kmc> plusOverloader, indeed
01:15:37 <kmc> it's all ASM at some level
01:16:03 <kmc> the FFI addendum is from 2005?
01:16:04 * ski peels Taejo and makes compote. yum !
01:16:06 <plusOverloader> kmc: no but i mean, not evere feature in languages exist in assembly - it could be the compiler translating an idea to something doable
01:16:19 <kmc> well, assembly doesn't have automatic lexical closure then
01:16:31 <kmc> if you want first class functions that have free variables, you have to build and manage closures yourself
01:16:33 <plusOverloader> kmc: what i mean is, you can _actually_ have higher order functions in asm, if only you pass a pointer-to-a-function to a function
01:16:55 <kmc> function pointers alone aren't first class functions
01:18:39 <kmc> because they just point to one of a finite set of predefined code regions
01:18:39 <Taejo> ski: I fly like a banana. Doesn't mean I taste like one
01:18:39 <plusOverloader> kmc: you can pass them around, so..?
01:18:39 <ski> plusOverloader : assembler is in some sense useful to understand CPS and continuations (or rather, understand *one* view-point of them)
01:18:40 <ski> Taejo : the implication was that you're a fruit
01:18:40 <Taejo> nah, CPS is a way to understand assembler :)
01:18:40 <ski> "fruit flies like a banana"
01:18:40 <kmc> you need to augment a function pointer with some "args" to the function, which are established at value creation time rather than call time
01:18:40 <plusOverloader> ski: yes, i wish they'd use asm to explain continuations rather than comparing to the rather unused "setjmp" in C
01:18:40 <kmc> that's common in C callback libraries
01:18:40 <ski> Taejo : well, that's the same thing ! :)
01:18:40 <kmc> and is basically a closure of free variables
01:18:40 <plusOverloader> kmc: i'm not sure what you mean
01:18:55 <kmc> plusOverloader, in C:
01:19:07 <ski> plusOverloader : of course, other view-points of continuations are also needed .. to explain what happens when you capture a continuation are store it somewhere, calling it later .. even calling it twice !
01:19:21 <ski> plusOverloader : also, to understand composable/delimited/sub- continuations
01:19:32 <plusOverloader> kmc: in ASM functions don't really "have" parameters, they just get some values from the stack, and you have to know ahead of time how many and which values it is expecting in the stack and just put them there before calling th function
01:19:33 <kmc> (int (*) (int)) mk_add(int x) { int add(int y) { return x + y; } return &add; }
01:19:39 <kmc> doesn't work
01:19:47 <kmc> but would work in a language with automatic closures
01:19:59 <kmc> we want to return a function which has the argument x "baked in"
01:20:14 <Saizan> plusOverloader: or in haskell if you write "foo x ys = map (\y -> x + y) ys" you've to pass (\y -> x + y) to map, so, you've to put that 'x' somewhere, it's not just a pointer to (+)
01:20:20 <plusOverloader> kmc: you're atalking about currying
01:20:24 <kmc> plusOverloader, not only
01:20:42 <plusOverloader> Saizan: oh i gotcha
01:20:57 <plusOverloader> Saizan: well yes, asm can't have anonymous funcctions, right
01:21:25 <Saizan> or functions defined inside a larger lexical scope, that use vars from that scope
01:21:25 <plusOverloader> Saizan: but then again anonymous functions are for saving time, and if you wanna save time then you shouldnt have picked ASM :)
01:21:41 <kmc> plusOverloader, right.  the ASM way to do this is to save your free variables explicitly
01:21:43 <plusOverloader> Saizan: a.k.a. closures :)
01:21:50 <Saizan> plusOverloader: foo x ys = map bar ys where bar y = x + y
01:21:55 <kmc> in C, when every callback library lets you specify a void* to be passed back into your callback
01:21:57 <kmc> that's for closures
01:22:04 <Zao> kmc: Except for the horrible ones that don't.
01:22:15 <Zao> kmc: Leaving you to construct thunks and other Evil Things.
01:22:16 <Saizan> yeah, closures are a way to implement first-class functions as we intend them
01:22:17 <kmc> Zao, let's don't talk about that ;P
01:22:19 <kmc> and yeah
01:23:11 <plusOverloader> thunks in C?? O_o ?
01:23:30 <Zao> plusOverloader: Not that kind of thunk.
01:23:36 <plusOverloader> Zao: oh ok, haha
01:23:46 <Zao> plusOverloader: In that world, a thunk is a trampoline function in assembly that calls a member function.
01:23:54 <plusOverloader> Zao: i was thinking "is C lazy and nobody told me?? during all these years!"
01:24:10 <mpiechotka> Hmm. Hiding packages is broken with --make. Is it ghc bug?
01:24:10 <plusOverloader> Zao: oh, trampolines, ok
01:24:19 <mpiechotka> Or intended bahaviour
01:24:22 <mpiechotka> ?
01:25:07 <Zao> plusOverloader: Partial function application, the manly way.
01:25:33 <quicksilver> mpiechotka: hmm. I think --make is intended to make a best attempt to work out what packages you need, including possibly hidden ones. I think the algorithm prefers unhidden ones if possible though?
01:25:39 <plusOverloader> Zao: it's be weird to have currying in asm
01:25:58 <plusOverloader> Zao: you'd have to have a function that puts something in the stack and returns without cleaning the stack frame
01:26:03 <mpiechotka> quicksilver: No. It just hides everything
01:26:17 <mpiechotka> quicksilver: Well - at least in case of conflict
01:26:32 <aavogt> try -hide-package before or after --make?
01:26:54 <mpiechotka> aavogt: Everywhere
01:27:36 <aavogt> do you specify the specific package name and version to -hide-package?
01:28:17 <mpiechotka> aavogt: No. Only name (and not I but yi in dyre configuration ;) ).
01:28:28 <quicksilver> the documentation for --make doesn't even mention that it tries to find packges!
01:28:31 <quicksilver> :(
01:28:42 <aavogt> because it doesn't
01:30:00 <aavogt> I think linking the imported modules is distinct from choosing which packages to have exposed
01:30:15 <aavogt> mpiechotka: specify the version too
01:30:44 <mpiechotka> aavogt: Hmm. That is not a solution in long term
01:30:45 <quicksilver> aavogt: it does!
01:30:57 <mpiechotka> aavogt: I can patch the specific yi version
01:30:58 <quicksilver> aavogt: if you compile without --make, you get link errors for missing packages.
01:31:05 <quicksilver> aavogt: if you compile with --make, you don't
01:31:13 <quicksilver> so, --make obviously attempts to work out which pacakges to link with.
01:31:30 <aavogt> it just looks at the ones that have been imported
01:31:34 <mpiechotka> aavogt: But making yi depending on specific version of mtl only to hide it for configuration is pure nonsense ;)
01:31:44 <aavogt> mpiechotka: do you know cabal?
01:31:50 <quicksilver> aavogt: however, you don't import packages. You import modules.
01:31:53 <quicksilver> aavogt: (normally)
01:32:07 <quicksilver> so --make searches the package database to work out which packages you need for those modules.
01:32:36 <myname_> anyone using Yi Editor?
01:32:46 <mpiechotka> aavogt: Yes - I know. But I guess it is not convenient for xmonad-like configuration to use cabal
01:33:38 <mpiechotka> aavogt: I mean - having 3 files and manual rebuilding just to do something simple (print something on stdout) is a bit... well overkill.
01:33:44 <aavogt> quicksilver: I mean that without --make you run into stuff like  it was found in multiple packages: mtl-1.1.0.2 monads-fd-0.0.0.1
01:33:46 <aavogt> anyways
01:34:43 <quicksilver> yes, I know you do :)
01:35:09 <quicksilver> the point I was trying to make is that --make does make some attempt to choose which packages to link against
01:35:19 <aavogt> so how does make try to choose packages?
01:35:20 <quicksilver> and that fact does not appear to be documented at all.
01:35:42 <quicksilver> I don't understand your question.
01:36:09 * Younder has been sweating (swearing) his way though basic category theory..
01:36:18 <aavogt> ghc selects modules from specific packages before --make gets involved
01:36:34 <lars9> any editor can auto-complete haskell code?
01:36:51 <mpiechotka> Hmm. It seems the same in ghci (interactive mode)
01:36:56 <quicksilver> aavogt: but if you don't use --make, you get link errors.
01:37:03 <Jafet> lars9, I type the module name and emacs completes the rest for me
01:37:07 <quicksilver> aavogt: so --make picks the right packages automatically - at least for the link phase.
01:37:30 <aavogt> yes. But those packages were already chosen before the link phase
01:37:30 <dcoutts_> ghc --make picks the packages based on what modules are used
01:37:39 <lars9> jejansse: cool, what mode do you use?
01:37:50 <Younder> So a monid has assosiativity, and a identity element. A subgroup only assosiativity. And a group assosiativity, identity and a computable inverse?
01:38:11 <dcoutts_> based on a module name -> package lookup, which is why it complains when two exposed packages provide the same module
01:38:20 <quicksilver> aavogt: OK, I understand. Nonetheless that's what I meant by --make picking packages automatically.
01:38:25 <luite> Younder: you mean semigroup instead of subgroup
01:38:32 <Younder> luite, yes
01:38:50 <quicksilver> Younder: you wouldn't normally see the word 'computable' there
01:38:58 <quicksilver> a group has inverses for all elements.
01:39:48 <Younder> quicksilver, what do you use instead of computable? (Is that somehow wrong?)
01:39:59 <aavogt> mpiechotka: you can specify  -hide-all-packages -package foo -package bar
01:40:01 <quicksilver> well computable sounds like an additional requirement
01:40:20 <quicksilver> sounds like you are suggesting that a group must come with a finite algorithm to compute the inverses, or something
01:40:22 <mpiechotka> aavogt: I can - by hand
01:40:36 <mpiechotka> aavogt: However please note that the whole dyre is broken
01:40:39 <quicksilver> such things are part of a different branch of mathematics
01:40:52 <mpiechotka> aavogt: As long as anyone specifies that some packages are hidden
01:40:57 <dcoutts_> aavogt, mpiechotka: for the simple case, it's probably easier to use -hide-package on the one causing a problem, rather than hiding all and specifying all manually
01:41:05 <dcoutts_> or using ghc-pkg hide to make it persistent
01:41:45 <roconnor> .. and a quasigroup has dividisability ... and a loop has identites and divisibility (and hence inversese) ...
01:42:13 <Younder> quicksilver, it is for all x element of a space A it has a inverse. Hence here is a x:A . f^-1(x) for all x. That makes it a function and thus computable.. (I think)
01:42:40 <quicksilver> Younder: No. Functions are not necessarily computable.
01:43:01 <quicksilver> Younder: I would recommend you simply avoid that word, it doesn't seem to be relevant to what you seem to want to talk about.
01:43:02 <Younder> quicksilver, what am I missing?
01:43:14 <Younder> quicksilver, OK
01:43:27 <quicksilver> computability theory is an area of mathematics about constructive logic and finite constructions and so on
01:43:34 <plusOverloader> kmc: hey kmc
01:43:35 <quicksilver> I don't think it's relevant to what you wish to discuss here :)
01:43:46 <Younder> quicksilver, I have studied THAT a bit..
01:44:23 <Younder> quicksilver, I probably just need to think it over..
01:44:33 <mpiechotka> dcoutts_: + Rebuilding yi to delete mtl from hiding list ;)
01:44:56 <mpiechotka> dcoutts_: I'm filling bug against ghc anyway
01:45:07 <dcoutts_> mpiechotka: what is the problem exactly?
01:45:16 <dcoutts_> mpiechotka: I might have missed the start of the discussion
01:46:01 <quicksilver> dcoutts_: so, I installed the haskell platform \o/ and it appears to all work.
01:46:13 <quicksilver> dcoutts_: it comes with haddock docs for the packages it includes, which is nice
01:46:15 <dcoutts_> oooh :-)
01:46:27 <quicksilver> dcoutts_: but it doesn't appear to include an index page for all installed packages/modules?
01:46:35 <plusOverloader> kmc: you there?
01:46:39 <kmc> yeah
01:46:40 <mpiechotka> dcoutts_: Given xmonad-like configuration. If one package hides one package (like mtl) --make mode does not work (all packages are hidden).
01:46:54 <dcoutts_> quicksilver: true, where do you think it should go?
01:47:13 <dcoutts_> quicksilver: note that cabal will generate such an index every time you install a new package
01:47:19 <plusOverloader> kmc: take a look at this: http://www.pastebin.ca/1859551
01:47:30 <dcoutts_> quicksilver: if you've got documentation turned on
01:47:34 <quicksilver> dcoutts_: well, where does cabal put it? isn't that the answer to your first question?
01:47:52 <dcoutts_> quicksilver: no, not if you think it should be installed with the platform
01:47:54 <kmc> plusOverloader, i said you'd need to turn on GHC extensions until it stops complaining
01:47:58 <kmc> that's what the -XWhatever suggestions are
01:48:00 <kmc> flags to ghc
01:48:03 <kmc> or you can do at the top of the file
01:48:07 <quicksilver> dcoutts_: can't the platform put it the same place cabal-install would?
01:48:13 <kmc> {-# LANGUAGE TypeSynonymInstances, FlexibleInstances #-}
01:48:14 <kmc> etc
01:48:30 <quicksilver> dcoutts_: shouldn't the platform aim to leave you in the same state you'd be if you'd installed those packages with cabal-install?
01:48:32 <dcoutts_> quicksilver: no, because it has to install things wherever you specify the --prefix= to be
01:48:48 <quicksilver> dcoutts_: OK, well this leads on to my next question
01:48:52 <dcoutts_> quicksilver: no, it must respect the dirs given to the ./configure
01:49:07 <quicksilver> dcoutts_: what is the relationship between the haskell platform install location and cabal-install's --global location?
01:50:06 <dcoutts_> quicksilver: I'd have to go check, it would not surprise me if they're the same
01:50:07 <plusOverloader> kmc: ok, these seem to suffice: {-# LANGUAGE TypeSynonymInstances, FlexibleInstances, UndecidableInstances #-}
01:50:10 <kmc> dcoutts_, hey, if i uploaded some patches to Cabal's trac, do i need to tell someone, or will they just get applied at some point?
01:50:22 <dcoutts_> quicksilver: ie /usr/local/ and then lib/$pkgid etc
01:50:31 <plusOverloader> kmc: but it still wont compile, giving the "ambiguous occurrence" error again
01:51:01 <dcoutts_> kmc: iirc, trac does not send an email to the mailing list if one adds an attachment, only if you add a comment, so make sure you add a comment.
01:51:05 <ski> plusOverloader : there's two problems at that code
01:51:09 <kmc> dcoutts_, ok, i did that too
01:51:13 <plusOverloader> ski: yes
01:51:16 <dcoutts_> kmc: ok great
01:51:31 <quicksilver> dcoutts_: well, on OSX the HP goes in /Library/Frameworks/HaskellPlatform.framework
01:51:45 <ski> plusOverloader : (a) `type String = [Char]' so you've written basically `instance Plus [Char] where ...' .. and that's simply not valid Haskell 98
01:51:46 <dcoutts_> kmc: which ticket ooi?
01:51:59 <quicksilver> dcoutts_: which seems reasonable enoguh, but I don't know where cabal-install will put my first --global'ly installed package.
01:52:05 <dcoutts_> quicksilver: oh, the mac binary installer does that.
01:52:27 <dcoutts_> quicksilver: the generic tarball will use /usr/local, unix style. I think cabal also uses /usr/local for global on OSX
01:52:40 <quicksilver> dcoutts_: what decides "where cabal install --global lives" ? Is that a property of my GHC install, because Cabal-the-library came with GHC?
01:52:45 <dcoutts_> quicksilver: the mac folks have not agreed on a different location
01:52:46 <plusOverloader> ski: that's the code kmc gave me. take a look at an update: http://www.pastebin.ca/1859552
01:53:21 <dcoutts_> quicksilver: the default policy for user and global is specified in the Cabal lib, yes.
01:53:40 <ski> plusOverloader : Haskell 98 requires that if you want to make a compound type (like `[Char]' (which is syntax sugar for `[] Char') or `Maybe Bool') an instance of a class, you *must* write like `instance ... => Plus (Maybe a)' (or `[a]' instead of `Maybe a', in your case) .. i.e. you can only define an instance for all list types at the same time
01:54:07 <dcoutts_> quicksilver: ie what Setup.hs/cabal --user/--global mean (and of course cabal prog uses a config file so you can override the defaults)
01:54:25 <ski> (also you can't define `instance Plus (Either a a) where ..' since no type variable may be repeated in the type to make an instance of the class)
01:54:51 <kmc> dcoutts_, 395, 335, 200, 344, 532
01:54:52 <plusOverloader> ski: ok can you comment on that paste with your corrections to the code so that it works?
01:54:57 <kmc> also i found a bug and opened it as #660
01:55:10 <kmc> ah which you commented on already
01:55:59 <ski> plusOverloader : however, this particular Haskell 98 restriction is often thought to be ok to lift (and GHC allows that, using the `FlexibleInstances' language extension) .. this is considered a more or less harmless extension
01:56:18 <quicksilver> dcoutts_: *nod*
01:56:47 <plusOverloader> ski: goo,d but i'm having trouble putting it all together
01:56:54 <quicksilver> dcoutts_: well OK I think I understand. I think it will confuse some users that the HP ends up in a different place to cabal --global packages, but I can see why
01:57:05 <ski> plusOverloader : but, there's then issue (b) .. your instance `instance Plus [Char] where ...' *overlaps* with `instance Num a => Plus a where ..' .. if we also have `instance Num Char', which implementation should GHC use ?
01:57:12 * hackagebot scan 0.1.0.2 - lexical style suggestions for source code  http://hackage.haskell.org/package/scan-0.1.0.2 (ChristianMaeder)
01:57:47 <plusOverloader> ski: so how do we solve that?
01:58:37 <ski> (plusOverloader : note that there is no way to say in haskell that `instance Num Char' should never happen. so Haskell tries to be forward-compatible with the possible case that someone defines `instance Num Char', and therefore it weill refuse that code, even if it can't currently see a `instance Num Char')
01:58:42 <dcoutts_> quicksilver: if the OSX users think that /Library/Frameworks is the right place then we can change it. When I last asked there was no consensus (but plenty of opinion).
01:59:44 <quicksilver> dcoutts_: fair enough. IMO one large framework wouldn't be sensible, it would have to /Library/Frameworks/<suitably-mangled-package-name>.framework per package. I'm not sure it's worth it
01:59:51 <quicksilver> dcoutts_: /usr/local seems OK to me ;)
02:00:03 <dcoutts_> quicksilver: the OSX installer could and should install an index, feel free to file a ticket.
02:00:08 <plusOverloader> ski: i was also looking at this for some guidance: (see bottom of page) http://groups.google.com/group/comp.lang.ml/tree/browse_frm/month/2003-03/3152b3a7a333f07e?rnum=61&_done=/group/comp.lang.ml/browse_frm/month/2003-03%3F
02:00:10 <ski> plusOverloader : you *could* say that you want it to use the most *specific* instance that gives an implementation of `Plus [Char]', i.e. the one given by `instance Plus [Char]' and not the one given by `instance Num a => Plus a' (assuming `instance Num [Char]' may happen later (sorry, above `Char' should have been `[Char]'))
02:00:31 <dcoutts_> quicksilver: it's a bit harder for the generic unix tarball because there is no obvious place to put it, especially for global installs.
02:01:07 <dcoutts_> quicksilver: note that cabal does not generate one for global installs exactly because we've not worked out where to put it
02:01:41 <dcoutts_> kmc: I've also looked at #660 a bit
02:01:44 <ski> plusOverloader : there is a GHC language extension, `OverlappingInstances', that allow you to say that you want the most specific instance; this will make GHC accept your code .. but people think this is often a bad idea, since this makes code harder to reason about, and more confusing (in specific ways that are often deemed unacceptable)
02:02:02 <dcoutts_> kmc: what approach are you taking to it? You're having to modify the UserHooks presumably
02:02:27 <quicksilver> dcoutts_: Oh, cabal *doesn't* install a doc index for global installs? I think I misunderstood you at first then.
02:02:48 <kmc> dcoutts_, i haven't thought of a good way to do it yet.  not familiar enough with the code
02:02:54 <ski> plusOverloader : to be complete, even with `OverlappingInstances' there can be the case where you want to use your methods where there *is* no most specific instance .. `IncoherentInstances' allows this .. and is even more frowed upon :)
02:02:59 <plusOverloader> adding OverlappingInstances still wont allow the code to compile
02:03:07 <quicksilver> dcoutts_: what did you mean by " dcoutts_> quicksilver: note that cabal will generate such an index every time you install a new package" ?
02:03:26 <dcoutts_> kmc: ok, I can send you a diff of the direction I was going
02:04:01 <kmc> not sure i'll get around to that ticket tbh
02:04:05 <kmc> i'm reporter but not owner on it
02:04:08 <dcoutts_> quicksilver: when you do per-user installs, not global ones. It regenerates an index of all installed packages on the machine (user and iirc, global too)
02:04:18 <dcoutts_> kmc: np
02:05:06 <quicksilver> dcoutts_: OK. I see.
02:05:10 <fasta> quicksilver, he means that cabal-install does not scale to >20000 packages without annoying the user.
02:05:23 <quicksilver> dcoutts_: in the generic unix case, why not /usr/local/share/doc/haskell ?
02:05:26 <dcoutts_> kmc: if you're looking for other really useful tasks, perhaps look at what the gtk2hs folk are doing, and what we could do in Cabal to make their task easier.
02:05:27 <quicksilver> dcoutts_: or something like that.
02:05:37 <quicksilver> dcoutts_: ( $PREFIX/share/doc/haskell I mean )
02:05:49 <dcoutts_> quicksilver: right, we'd have to agree a special shared directory
02:06:05 <quicksilver> dcoutts_: $PREFIX/share/doc is a well accepted standard IMO
02:06:05 <dcoutts_> quicksilver: for the user case we know that we own ~/.cabal/doc/
02:06:13 <plusOverloader> ski: any other ideas?
02:06:19 <dcoutts_> quicksilver: right, but has to be a common subdir
02:06:22 <quicksilver> dcoutts_: and I can't imagine anyone objecting if you used 'haskell' within that standard location.
02:06:42 <dcoutts_> quicksilver: it'll clash for multiple ghc installs
02:06:47 <dcoutts_> multiple versions
02:07:02 <ski> plusOverloader : oh, you're right .. that's because you have `instance Num a => Plus a', where the argument in `Num a' is not "smaller" than the one in `Plus a'  .. i originally misread your code as saying `instance Num a => Plus [a]'
02:07:42 <ski> plusOverloader : GHC suggests to use `UndecidableInstances' to enable this .. but as i've mentioned, it is rarely a good idea to use `UndecidableInstances'
02:07:55 <plusOverloader> ski: i don't need it to say it that way, that was only kmc's code suggestion; i'm ok with any as long as i can overload any existing operator to work the way i want with my types
02:08:09 <dcoutts_> quicksilver: none of this is impossible, it just needs some thought.
02:08:21 <dcoutts_> quicksilver: and someone to notice the inconsistencies :-)
02:08:27 <dcoutts_> quicksilver: please file a ticket :-)
02:08:37 <quicksilver> dcoutts_: against GHC or cabal?
02:08:41 <quicksilver> or platform?
02:08:48 <dcoutts_> quicksilver: wherever seems appropriate
02:09:06 <ski> plusOverloader : the basic problem here is that Haskell has no way of knowing you'll never declare `instance Num [Char]'
02:09:19 <dcoutts_> quicksilver: or both/all cross-linked if there cross-cutting issues
02:09:31 <plusOverloader> ski: i can add the TrustMe flag ;)
02:09:34 <ski> (it might be nice with a way of declaring that some type will never be an instance of a specific class .. but there is no current way of saying that)
02:09:56 <dcoutts_> kmc: you've been working hard I see!
02:10:22 <ski> plusOverloader : using `UndecidableInstances' (as GHC suggests) here means that GHC will make no guarantee about which instance will actually be used
02:10:28 <dcoutts_> kmc: I had not noticed all these patches (the trac has not been sending emails to the list the past few days for reasons I've yet to establish)
02:11:10 <kmc> dcoutts_, good idea about gtk2hs
02:11:12 <ski> plusOverloader : it might use your `instance Plus [Char]' instance .. or if anyone defines `instance Num [Char]' it might use that (together with your `instance Num a => Plus a') instead
02:11:40 * ski wonders whether he said things right there ..
02:11:42 <dcoutts_> kmc: eg gtk2hs uses c2hs which is not especially well supported by cabal (though I just pushed a couple patches)
02:12:08 <plusOverloader> ski: the thing is i already have UndecidableInstances enabled
02:12:11 <ski> plusOverloader : sorry, i was mixing up `UndecidableInstances' with `IncoherentInstances' a bit there
02:12:48 <plusOverloader> ski: just added it, still wont compile
02:12:48 <dcoutts_> kmc: for example I've no idea how they are working around the fact that cabal does not install .chi files
02:12:58 <plusOverloader> ski: i have a boatload now :)   --->   {-# LANGUAGE TypeSynonymInstances, FlexibleInstances, UndecidableInstances, IncoherentInstances, OverlappingInstances #-}
02:13:34 <ski> plusOverloader : it *should* have been saying that using *`IncoherentInstances'* will make no guarantee which instance implementation will actually be used
02:14:26 <ski> `UndecidableInstances' just mean that GHC things that type checking the instances might not terminate (since maybe `instance Num a => Plus a' could enter a loop, if you have `instance Plus a => Num a' as well)
02:16:00 <plusOverloader> ski: don't know what to tell ya :)
02:16:04 <ski> plusOverloader : the last problem you had was that type synonyms are not allowed in instances in Haskell 98 .. and `TypeSynonymInstances' is the extension to enable that (pretty harmless, though maybe in some cases suprising on a human reader)
02:16:35 <ski> so, either use `TypeSynonymInstances' or replace `instance Plus String' by `instance Plus [Char]' :)
02:16:58 <ski> plusOverloader : also, you *don't* need `IncoherentInstances' here (which is *good*), so you can remove it
02:17:07 <ski> (i was confusing myself for awhile)
02:18:03 <ski> (`TypeSynonymInstances' could be surprising on readers because `instance Plus String' and `instance Plus a => Plus [a]' would overlap, even though it doesn't "look like that")
02:18:11 <ski> plusOverloader : all clear ?
02:18:18 <ski> or, maybe, all confused ? :)
02:18:27 <plusOverloader> ski: i also already had TypeSynonymInstances :)
02:18:53 <ski> you could say `instance Plus [Char]' anyway .. it is still allowed :)
02:19:03 <ski> (your choice)
02:19:13 <plusOverloader> ski: well see, go ahead and try to compile it yourself
02:19:23 <plusOverloader> ski: it still wont go despite all these adds and changes
02:19:34 <plusOverloader> ski: even changing to instance Plus [Char] does no good
02:19:37 <ski> it does when i tried it
02:19:53 <plusOverloader> can you paste that code then?
02:20:59 <plusOverloader> here's what i have:
02:20:59 <plusOverloader> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24873#a24873
02:20:59 <hpaste>  plusOverloading (nobody)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24873
02:21:33 * ski arghs again a bit (should check bettern exactly what i tried, before i speak .. probably need nutrition)
02:22:05 <plusOverloader> ski: lol
02:22:40 <ski> (hm, no, sorry, i misread what i said .. i didn't say anything wrong, in the last version ;)
02:22:56 <ski> plusOverloader : so, i have the same code as you, but have added
02:22:59 <ski>   {-# LANGUAGE TypeSynonymInstances,FlexibleInstances,OverlappingInstances,UndecidableInstances #-}
02:23:37 <quicksilver> as far as I know, there is nothing wrong with plusOverloader's code except he didn't hide the (+) from the prelude.
02:23:39 * ski looks at plusOverloader last paste
02:23:51 <quicksilver> import Prelude hiding ((+)); import qualified Prelude
02:23:57 <quicksilver> and it runs fine for me
02:24:01 <plusOverloader> ski: ok, so basically you did away with the Incoherent thingy
02:24:07 <ski> oh, you need *that* as well
02:24:15 <plusOverloader> ski: oh....
02:24:17 <ski> sorry, i took that as so obvious that i didn't think on it
02:24:24 <plusOverloader> ski: hahah that happens
02:24:29 <plusOverloader> ski: i dont know how to hide it
02:24:36 <quicksilver> I just told you
02:25:14 <plusOverloader> quicksilver: oh lemme try
02:25:24 <quicksilver> your code runs fine with that
02:25:33 <ski> plusOverloader : `import Prelude hiding ( (+) )' to hide the `(+)' operator from `Prelude' (since you still want other stuff like `(++)')
02:25:50 <quicksilver> however, just to emphasise some of the things ski has been saying, you should never use OverlappingInstances
02:25:58 <quicksilver> it is unforgivable, and there are no excuses
02:26:06 <plusOverloader> quicksilver: holy balls that worked :))
02:26:25 <ski> plusOverloader : `import qualified Prelude' so that you can access *everything* (including `(+)') in `Prelude' using an explicit module disambiguation prefix
02:26:36 <plusOverloader> quicksilver: but there's no way to get this to work without using OverlappingInstances, or is there?
02:27:06 <plusOverloader> ski: thanks for the explanation of the lines
02:27:35 <ski> plusOverloader : yes, i'm just trying to explain what the various related extensions here do .. by all means, never actually *use* `OverlappingInstances' in code :)
02:28:07 <plusOverloader> ski: but as I said, without using OverlappingInstances there's no way to overload (+) the way i want to, right?
02:28:34 <ski> plusOverloader : you *could* manually make every (known) instance of `Num' also an instance of `Plus'
02:29:23 <plusOverloader> ski: I can't help but think that's the way it should have been implemented originally :/
02:29:37 <ski> that's not a very good way to code, of course .. boilerplate and you still have to manually add 3rd-party types (or several people do it at the same time, so you get conflicts)
02:29:50 <ski> plusOverloader : "it" being ?
02:29:57 <plusOverloader> ski: prelude
02:30:02 <quicksilver> plusOverloader: there would be something to be said for the Num typeclass being broken down into smaller pieces, yes.
02:30:03 <kmc> plusOverloader, yeah, the numeric classes in the Prelude are a mess
02:30:08 <kmc> they should be much more fine grained
02:30:18 <quicksilver> however, nobody has really come up with a coherent and obviously-better version
02:30:28 <plusOverloader> Clean seems to have
02:30:41 <quicksilver> haskell also lacks some conveniences that would help with many small typeclasses
02:30:49 <kmc> context synonyms?
02:30:58 <quicksilver> kmc: something like that, yes.
02:31:13 <ski> also possibly something like JohnMeacham's superclassing proposal
02:31:48 <ski> (for changing the way classes are defined, but still keeping backwards-compatibility, for a while)
02:32:10 <kmc> i would just do that via modules
02:32:13 <quicksilver> plusOverloader: I didn't mean nobody in no language (I'm not familiar with Clean's approach here), I meant nobody within haskell.
02:32:17 <kmc> import PreludeTwoPointOh
02:32:41 <plusOverloader> quicksilver: oh got it
02:32:43 <ski> kmc : you'd still have to sychronize that change of modules among the libraries you want to use
02:32:55 <quicksilver> lots of people talk about how it could be better :) But I've not seen someone demonstrate a haskell library which is obviously "better enough" that people would want to switch.
02:32:55 <kmc> ski, why?
02:33:09 <ski> (but maybe it could be done, somehow)
02:33:28 <kmc> as long as NewPrelude.Double and OldPrelude.Double are the same type
02:33:34 <ski> kmc : well, if you want to pass `forall a. Num a => [a] -> a' operations from one library to the other
02:33:35 <plusOverloader> quicksilver: well, how big is the haskell community to begin with?
02:33:43 <kmc> ski, ah, that's more specialized
02:33:50 <kmc> plusOverloader, pretty big
02:33:56 <kmc> 639 people ;)
02:34:02 <ski> (but i suppose that is not that common, now that i think about it)
02:34:06 <quicksilver> plusOverloader: the community is quite sizeable. The subset of the community with the experience and skill to solve this problem is smaller.
02:34:10 <kmc> ski, it sounds higher-rank
02:34:13 <kmc> but yeah it's an issue
02:34:17 <ski> Rank2, yes
02:34:20 <ski> (at least)
02:34:22 <quicksilver> plusOverloader: the overlap between that subset and the subset with the time and motivation appears to be zero.
02:34:27 <quicksilver> (just empirically :)
02:34:35 <plusOverloader> quicksilver: empiricaly, yes
02:35:01 <kmc> ski, you'd want to have the old prelude available as a qualified import
02:35:14 <kmc> and perhaps even a synonym in NewPrelude for classes in OldPrelude if the names don't clash
02:35:16 <ski> yes, that's obvious :)
02:35:37 <ski> (or even better(?), integrating versioning into the model system, somehow)
02:35:49 <ski> (s/model/module/)
02:37:42 <ski> quicksilver : Clean has syntactic support for defining a one-operation type class in a short-hand way
02:38:24 <ski> quicksilver : yielding signatures something like `sum :: a a -> a | (+) a , Zero a', iirc
02:39:46 <ski> (here `(+) a' is the constraint that `a' implements the type class `(+)' which only contains the `(+) :: a -> a -> a' method)
02:42:38 * hackagebot binary-communicator 1.0 - Send and receive binary data.  http://hackage.haskell.org/package/binary-communicator-1.0 (YvesPares)
02:45:35 <kmc> a tricker question is how can we support multiple instances per type coherently
02:45:44 <kmc> i.e., Integer is a monoid in two ways
02:46:09 <kmc> it would be nice to keep the conventional (+) and (*) but to somehow have the class system know that (+) and 0 play a similar role as (*) and 1
02:46:18 <kmc> and have a less awkward way of choosing than the present newtype wrapping
02:46:24 <dobblego> yeah that's a pain the arse (Bool is a monoid in two ways, [] is an Applicative in three ways, ...)
02:46:31 <kmc> dobblego, three?
02:46:46 <kmc> in languages that implement type classes by implicit arguments, you can just make the dictionary explicit
02:46:51 <opqdonut> the normal, zip, diagonal
02:46:52 <dobblego> er yeah I thought so, but I'm high at the moment
02:46:58 <kmc> haha
02:47:16 <kmc> but this fails in other cases... it's bad to change your idea of Ord midway through using a Map
02:49:00 <mreh> $! evaluates the RHS to WHNF, correct?
02:49:24 <mreh> WHNF treats records like constructors, also true?
02:49:37 <dcoutts_> mreh: yes and yes
02:50:15 <mreh> so all the fields in the record will not be evaluated individually, just up to the constructor
02:50:43 <quicksilver> mreh: records don't get special treatment, but they are constructors as normal.
02:50:52 <quicksilver> mreh: it's just a very slighly alternative syntax
02:51:05 <mreh> it's more that I don't understand WHNF i think
02:51:09 <quicksilver> data Foo = Foo { a :: Int } is the same as data Foo = Foo Int
02:51:18 <dcoutts_> mreh: and constructor fields are only evaluated if the constructor is strict in that field
02:51:21 <quicksilver> you appear to understand it fine :)
02:51:26 <quicksilver> 'just up to the constructor' is right.
02:51:33 <mreh> why give it such a hard name
02:51:42 <ski> why not ?
02:51:44 <ski> :)
02:51:50 <mreh> to SCARE people
02:52:04 <dcoutts_> mreh: blame the academics :-)
02:52:08 <ski> yes, maybe that's the intention :)
02:52:15 <ski> (blame the theoretical computer scientists)
02:52:21 <dcoutts_> they had already defined normal form, and head normal form
02:52:51 <mreh> I have to read a PCM file without knowing the sampling rate, which is reads into the header, then I have to decide what type the content of the file should be, i.e. the sampling rate is proportional to the number of bits per samples
02:52:55 <dcoutts_> iirc, the weak bit is about not evaluating under lambdas
02:53:27 * ski thought that was about not evaluating anything more than the topmost constructor
02:53:40 * mreh never gets round to actually reading these papers
02:53:43 <ski> (lambdas already being out of the question since head normal form)
02:54:02 <mreh> s/reads/read/
02:54:35 <dcoutts_> ski: http://burks.bton.ac.uk/burks/foldoc/53/126.htm
02:55:17 <ski> dcoutts_ : ah, i stand corrected
02:55:17 <ski> ty
02:55:36 <dcoutts_> ski: thanks for making me look it up, I wasn't that sure :-)
02:55:43 <mreh> I had that discussion about partially reading polymorphic types before casting them two days ago
02:56:48 <ski> s/casting them/specializing them to an instance/ ?
02:57:28 <mreh> where are the #haskell logs?
02:57:28 <mreh> ski: yes, old habits die hard
02:59:00 <kmc> mreh, see topic
03:00:53 * ski wonders when Milner passed away
03:01:08 <ibid> recently
03:01:59 <ibid> 20 march, apparently
03:42:33 <cvk_> hi
03:42:56 <cvk_> hi ... anyone here?
03:43:19 <profmakx> cvk_ just ask your question
03:43:26 <kmc> hi
03:43:27 <profmakx> if someone is interested there will be answers :P
03:43:41 <cvk_> had a doubt .. Just came across this as i was learning haskell
03:43:42 <cvk_>  4 * (let a = 9 in a + 1) + 2
03:44:06 <cvk_> can you tell what  the "in" is for?
03:44:25 <kmc> it's part of the syntax of "let"
03:44:33 <vegai> it separates the bindings from the statement
03:44:37 <kmc> > let a = 2 in a + 1
03:44:37 <vegai> let ... in ...
03:44:38 <lambdabot>   3
03:44:42 <kmc> er, no statement
03:44:43 <cvk_> oh
03:44:50 <vegai> expression?
03:44:54 <kmc> it separates bindings from the "body" expression
03:45:15 <adimit> Question: does gitit work with ghc 6.8.2? (I'll assume no.) And, does anyone have any experience with installing a current version of ghc on debian lenny? (preferably without compiling it by hand)
03:45:18 <kmc> and you notice let is an expression itself and can appear in the middle of other stuff
03:45:22 <cvk_> i got it.. i was assuming let was only for assignments
03:45:34 <kmc> assignments?
03:45:39 <kmc> let doesn't do assignments
03:45:46 <kmc> in the sense they're usually meant in imperative languages
03:45:54 <cvk_> yes
03:46:09 <cvk_> now i guess i understand
03:46:12 <kmc> let establishes a name for an expression so you don't have to write it over and over
03:46:28 <kmc> and (in common implementations) it establishes sharing, so the expression won't be recomputed at each use site
03:46:54 <cvk_> kmc: Then let .... in is a standard construct?
03:47:08 <kmc> not sure what you mean
03:47:11 <kmc> it's part of the syntax of Haskell
03:47:15 <kmc> (and a lot of other languages)
03:47:23 <cvk_> ok
03:47:56 <cvk_> kmc:thanks
03:48:00 <kmc> no prob
03:52:10 <stevenmarky> a let evaluates to the expression after the in. the let statement allows the expression/s defined before the in to be used in the expression used after the in. that's how I understand it anyway
03:52:17 <stevenmarky> -statement
03:52:55 <kmc> yes
03:52:56 <forrest> I've messed up my haskell install by deleting a bunch of files manually and now ghc-pkg check tells me lots of packages are broken. What's the best way to fix that?
03:54:30 <arcatan> forrest: don't know about the best way, but last time i did that, i solved it by reinstalling some of the packages
03:54:54 <int-e> reinstall from scratch. depending on what you deleted, unregistering all broken packages and using cabl install to reinstall them as needed may work.
03:55:41 <forrest> yeah i had installed a bunch of extra packages, and can't figure out the order in which to reinstall them because of the dependencies
03:55:49 <forrest> don't know which to reinstall first
03:56:09 <int-e> yes, if you just unregister them cabal-install should figure that out for you
03:56:25 <forrest> int-e: how do i unregister a package?
03:56:39 <int-e> ghc-pkg unregister <packages>
03:56:46 <forrest> ah!
03:56:53 <forrest> thanks muchly!
03:59:32 <forrest> does ghc-pkg check --simple-output output all the broken packages?  so in bash i could do ghc-pkg unregister `ghc-pkg check --simple-output` ?
04:02:04 <int-e> hmpf. unregister only takes a single package argument. so you'll need  xargs -1  or  for pkg in .... I don't know what the output of ghc-pkg check --simple-output  is.
04:02:34 <forrest> ok, thanks
04:04:39 <Younder> anyone else annoyed by the parens rules of Haskell?
04:04:50 <Twey> What about?
04:05:15 <Twey> The fixity of ($) annoys me sometimes
04:05:18 <Younder> I would expect algebra to parse normally.
04:05:49 <hpaste>  . (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24874
04:06:15 <Younder> probably a feeble point..
04:06:18 <fasta> Younder, what doesn't parse normally?
04:07:14 <Younder> fasta, sin x + cos y + c
04:07:56 <Twey> That does parse normally
04:08:05 <Twey> For a mathematical definition of normally
04:08:20 <Twey> (sin x) + (cos y) + c
04:08:27 <int-e> sin x^2  may be confusing.
04:08:56 <Twey> Agreed, but that's one of many reasons that operator whitespace should be mandatory
04:09:10 <michaelcdever> hey all, im getting a duplicate definition error, and i can't see where im going wrong, here's the function thats causing the error, anychance someone could take a look and maybe let me know: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24874#a24874
04:09:36 * int-e thinks it should be written as (sin x)^2
04:09:44 <Younder> why did they differentiate from the standatrd rules for algebra? (Differering 'just a little' is almost worse that 'almost')
04:10:01 <fasta> Younder, because there are no standard rules for every domain.
04:10:04 <Twey> Younder: In your case, they don't.
04:10:05 <Ferdirand> because the standard rules are inconsistent ?
04:10:32 <int-e> Younder: and the standard rules don't support partial application very well
04:11:22 <Younder> Haskell rules are sufficiently consistent to form a language of mathemetics. I guess I souldn't complain. I mean it could be Perl..
04:11:33 <Twey> int-e: sin x ^ 2 would be clear enough
04:11:37 <Younder> shouldnt
04:12:01 <fasta> Younder, you can implement your own parser and compile it to e.g. GHC AST's of course.
04:12:06 <int-e> Twey: right, but in my eyes it's ugly.
04:12:13 <fasta> Younder, if you really care.
04:12:21 <fasta> In practice nobody does care that much.
04:12:21 <Twey> int-e: Why?
04:12:49 <Younder> fasta, I am working on a language I call Formula...
04:13:05 <Younder> fasta, and yes i really care
04:13:12 <int-e> Twey: I tend to use whitespace in accordance with precedences - no spaces for (*), (^), (/) spaces for the rest.
04:13:44 <Twey> int-e: foo x*y must really confuse you, then :
04:14:58 <Twey> Mathematical notation is an inconsistent beast built up with no real planning or goals for ease of comprehension over many centuries by various people, each of whom was unaware of major parts of the existing body of notation when they decided to create more
04:15:13 <Twey> We need to be fixing it, not forcing other things to conform to it
04:15:20 <int-e> Twey: maybe. anyway, it's a matter of taste, not a useful discussion topic.
04:15:24 <Younder> Having alread 'milked' the Lisp community I figure the Haskell community is next. (I also study ML and OCAML)
04:15:56 <Twey> Younder: Heheh I can see that going far
04:16:25 <Younder> There is a small group of us that there is a atomic kernel that should include concurrent programming
04:17:23 <dcoutts_> Younder: btw, how would you parse "sin x + cos y + c" ?
04:18:14 <Younder> For what it's worth you haskell bunch I really like this group. Helpfull and unpresumptious.
04:18:46 <Younder> dcoutts, (+ (sin x) (cos y) c)
04:18:56 <Twey> Younder: That's how it is parsed
04:19:09 <Younder> yes, dumb example
04:19:14 <Twey> (well, (+ (sin x) (+ (cos y) c)))
04:19:22 <dcoutts_> right with two '+'s
04:19:54 <dcoutts_> Younder: ok, I was trying to work out how else mathematicians might parse it :-)
04:19:55 * Younder hit's himself on the head, 40 year old's have such poor memories
04:20:06 <Twey> And grammar >.>
04:20:17 <Younder> here we go...
04:20:48 <Twey> Sorry
04:20:51 <Twey> Hard night
04:22:35 <dcoutts_> Younder: so the main "oddity", if you want to call it that, is that we decided that in a functional language, function application is the most important thing, so it gets to use simple juxtaposition and binds tighter than any infix operator
04:23:07 <Younder> yes, that sounds about right
04:23:27 <dcoutts_> in mathematical syntaxes, they sometimes give juxtaposition to multiplication "a b", and sometimes to function application "cos x"
04:23:42 <Twey> And sometimes to function composition
04:23:57 <Younder> either make it all prefix... Or at least let our infix operators work as expected
04:24:19 <bremner> Twey: well, sometimes the relevant multiplication is function composition
04:24:29 * Younder is a old Lisp'er
04:25:00 <Younder> Well it is probaly a mute point now.
04:25:07 <Saizan> in haskell you can define your own infix operators, btw
04:25:08 <bremner> moot
04:25:18 <Younder> yes, sorry
04:27:23 <bremner> not to be a pedantic twit :)
04:27:44 <Younder> I like that way every infix operator in Mathematica reduces to a prefix syntax. That has been one of my main inspirations in Formula.
04:28:09 <Younder> I worry about error reporting though.
04:28:17 <bremner> the name Formula sounds like FORTRAN, the next generation
04:28:44 <Younder> bremner, It competes ith fortress.. unintentionally
04:29:57 <Younder> With incidenally has come up with many of the same ideas. Haskell is a ruler we both use..
04:32:41 <Saizan> desugaring before checking -> baaad
04:32:52 <Saizan> though maybe you can do something with lenses
04:33:06 <cvk_> Hi... could anybody tell me what is wrong with this function definition
04:33:11 <cvk_> numZerosInFactorial :: Int -> Int
04:33:14 <cvk_> numZerosInFactorial n = sum (x | let x = floor (n/(5^i)), x>=0,i `elem` [1..])
04:33:29 <quicksilver> you want [] not ()
04:33:37 <cvk_> oh
04:33:39 <quicksilver> around the list comprehension: [x | .... ]
04:33:55 <cvk_> but i thought sum was a function
04:33:59 <quicksilver> it is
04:34:06 <Saizan> and you want i <- [1..] rather than i `elem` [1..]
04:34:24 <quicksilver> but sum being a function doesn't change the syntax of list comprehensions :)
04:34:29 <Saizan> (no, it's not prolog)
04:34:31 <quicksilver> list comprehensions are written with [ .. ]
04:34:45 <cvk_> Saizan :  are the two different?
04:34:52 <quicksilver> > sum [1,2,3]
04:34:54 <lambdabot>   6
04:34:55 <Younder> Functional seems the way to go. In paralell processing. Idelly I would like to pipeline thike the processor does and take some of the load of the programmer. In reality it requires a compromise. I allow a suntax that is easilly decomposable. Dataflow mostly. and then build on that (Oz)
04:35:00 <quicksilver> > sum [x | x <- [1,2,3]]
04:35:01 <lambdabot>   6
04:35:16 <cvk_> quicksilver: yes.. got it..
04:35:23 <quicksilver> cvk_: yes, one works and one doesn't.
04:35:25 <quicksilver> ;)
04:35:33 <Saizan> cvk_: yeah "i `elem` [1..]" checks that condition holds, "i <- [1..]" defines i to be an element of the list
04:35:42 <cvk_> oh
04:35:50 <cvk_> So now i have numZerosInFactorial n = sum [x | let x = floor (n/(5^i)), x>=0, i <-[1..]]
04:36:09 <cvk_> it says i not in scope. What do i make of it?
04:36:18 <Saizan> ok, you've to move the "i <-[1..]" just after |
04:36:34 <Saizan> since after the | scoping goes from left to right
04:36:46 <cvk_> Saizan: Oooh.. Thanks a lot
04:37:05 <Younder> I use agents to signifify parelell processing atoms. (Norvig AIMA)
04:37:09 <Saizan> and then you'd need to add a fromIntegral
04:37:34 <quicksilver> and then you need to work out how long it takes to sum an infinite list?
04:37:54 <Saizan> that's a detail
04:38:15 <Saizan> (bah, these people that still run their code)
04:38:33 <hpaste>  constraining type variable (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24876
04:38:46 <cvk_> In numZerosInFactorial n = sum [x |  i <-[1..], let x = floor (n/(5^i)), x>=0]
04:38:55 <dcoutts_> cvk_: and note that currently you get an infinite list of results, which is a tad hard to sum. The fact that the series tends to zero is something you have to explain in your code, there's no magic.
04:39:20 <dantheman_> Hey all, I have a question re type constraints. It's a bit long to type here, so I've put the details on hpaste: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=24876#a24876
04:39:23 <cvk_> i was just going to ask that
04:39:51 <dantheman_> Basically I'm wondering can you constrain a type variable a to be either one type or another?
04:39:55 <Younder> Scaling to 577 cores is difficult (most tequinques scale to 4)
04:40:29 <quicksilver> dantheman_: well my first reaction is why bother?
04:40:33 <cvk_> does numZerosInFactorial n = sum [x |  i <-[1..], let x = floor (n/(5^i)), x>=0] mean that i am going to sum till x>=0
04:40:42 <quicksilver> dantheman_: a slight excess of polymorphism isn't normally a problem
04:40:53 <quicksilver> and sometimes turns out to be handy down the line when you least expect it.
04:40:54 <dcoutts_> cvk_: no, that just filters out list elements where x < 0
04:41:29 <cvk_> dcoutts_: but if i have no loops, how can i achieve that end
04:41:36 <cvk_> :(
04:41:42 <cvk_> Sorry if this is too silly
04:41:51 <quicksilver> dantheman_: the answer to your question is probably to define a typeclass and make User1Params and User2Params members of it... but a typeclass with no methods doesn't appear to add much to your program.
04:41:51 <dantheman_> Ok quicksilver, that's fair enough. It was more so I can learn about the limitations of type constraints.  i.e. can you have (Num a | String a) <= a
04:41:58 <dcoutts_> cvk_: you have to cut the sequence at some point, where you know it is valid to do so
04:42:13 <Saizan> ?type takeWhile
04:42:14 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
04:42:17 <Younder> Anyone from Edinburgh University here?
04:42:18 <dcoutts_> cvk_: I imagine you want to do that as soon as you get the first 0 right?
04:42:20 <michaelcdever> anyone have a minute to maybe look at this and help me spot where the duplicate definition is??? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24874#a24874
04:42:27 <quicksilver> dantheman_: no, you can't have "or" constraints, or at least not easily.
04:42:27 <cvk_> dcoutts_: Yes
04:42:37 <dcoutts_> cvk_: ok, Saizan has given you the hint
04:42:56 <dantheman_> Ok, thanks. If there was a difficult way, could you at least point me in the direction of where I might find out more about it?
04:43:09 <Younder> Anyone from Edinburough University here?
04:43:10 <cvk_> Saizan: Thanks! dcoutts_: Thanks .. I ll check that out
04:43:20 <quicksilver> dantheman_: not specifically, no :) I imagine oleg has written something about it.
04:43:24 <Younder> sigh,
04:43:34 <dantheman_> Ok, thanks anyway!
04:46:44 <michaelcdever> ??
04:47:06 <quicksilver> michaelcdever: I didn't really understand your question.
04:47:11 <quicksilver> michaelcdever: "duplicate definition"
04:47:18 <quicksilver> michaelcdever: did you have an error message in mind? a warning?
04:47:57 <michaelcdever> sorry, the error that im getting is: Multiple declarations of `Term.abstractExpr'
04:48:13 <quicksilver> you won't get that from the code you pasted.
04:48:27 <michaelcdever> hmm
04:48:37 <quicksilver> you well get that if you have two or more equations for abstractExpr separated by something else
04:48:52 <quicksilver> something else == an equation for some other function, or a data type, or etc.
04:50:46 <Younder> Is ALL reseach in OCALM and Coq in 'frogy' (french) sigh
04:51:25 <michaelcdever> hmm, so its something to do with where i call abstractExpr in the module
04:51:55 <Younder> I was tought it in school but my knowlege of the language is truly inferrior
04:52:19 <quicksilver> michaelcdever: you try to define abstractExpr twice, the compiler thinks
04:52:32 <quicksilver> michaelcdever: you could get that error by accidentally putting something esle between two parts of the definition
04:52:41 <quicksilver> or just by accidentally copy-pasting the defition twice.
04:52:44 <michaelcdever> ah
04:53:48 <michaelcdever> damned silly mistakes, compiling a file that links Term, but also contains an old definition :)
04:53:52 <michaelcdever> *facepalms*
04:54:00 <michaelcdever> thanks quicksilver
04:54:08 <Younder> Like Quinnebeq 'Lisp in small peices' helped me a great deal (English translation)
04:54:52 <Younder> quiennec
04:55:19 <Younder> queinnec
04:56:11 * Younder thinks the spelling is insane...
04:56:54 <Younder> uei ..
04:57:05 <Younder> aeiou
04:57:21 <cvk_> Does this seem fine: numZerosInFactorial n = sum [ x |i <-[1..],x <- takeWhile (floor (n/(5^i) >=0 ))[floor (n/(5^i) >=0 )]]
04:58:03 <cvk_> my first real program with list  comprehensions
04:58:37 <cvk_> it does not run though... Some type matching error
04:59:00 <quicksilver> my opinion is that list comprehensions are a bad way to learn haskell.
04:59:10 <Younder> product [i..n]
04:59:16 <quicksilver> they are not typical of the rest of the language, and they are hard to use *until* you understand the rest of the language
04:59:19 <quicksilver> (or enough of it, at least)
04:59:32 <cvk_> quicksilver: Oh
04:59:52 <Younder> that lazy bit i gonna cost
04:59:57 <Younder> is
05:00:28 <Younder> Thouse restrictions cost more thatn their worth
05:00:46 <cvk_> Younder : Oh.. alright
05:01:31 <quicksilver> cvk_: You still have an infinite list (from the i)
05:01:42 <quicksilver> cvk_: your takeWhile syntax is wrong, too
05:01:47 <Younder> the lazy bit
05:02:05 <quicksilver> cvk_: and if you use two <- in the same list comprehension, you're going through two lists, every pair of possibilities
05:02:13 <quicksilver> I don't think any of this is what you want.
05:02:29 <quicksilver> you probably want the takeWhile *outside* the list comprehension, but inside the sum
05:02:32 <cvk_> quicksilver:Oh. :( sure ill check that.. Thanks again
05:02:46 <quicksilver> but more than that you need to get straight about lists, and types, and function application, and basic haskell syntax
05:02:49 <quicksilver> I recommend LYAH
05:02:51 <quicksilver> @where lyah
05:02:52 <lambdabot> http://www.learnyouahaskell.com/
05:04:05 <Younder> or http://book.realworldhaskell.org
05:04:41 <Younder> a bit slow paced.. but worth it in the end..
05:05:24 <Younder> I tried a few faster ones and ended up stranded on details that RWH explained.
05:05:33 <Spockz> Is there somewhere I can find functions defined on unboxed types? It seems that hoogle can't locate them. :(
05:06:23 <Younder> For there to be unboxed types your in types have to match.
05:08:48 <quicksilver> Spockz: in the various GHC-specific implementation files, yes
05:09:38 <quicksilver> Spockz: http://haskell.org/ghc/docs/latest/html/libraries/ghc-prim-0.2.0.0/GHC-Prim.html for example
05:10:19 <quicksilver> hmm why are source links there broken
05:50:19 <ivanm> preflex: seen malcolmw
05:50:19 <preflex>  malcolmw was last seen on #haskell 3 days, 21 hours, 25 minutes and 43 seconds ago, saying: cpphs has always accepted /* and */ and */* are not comment-related - I even used those operators in the source code of cpphs itself, to make sure :-)
05:56:18 <Absolute0> When I try to run cabal install wxcore --global
05:56:43 <Absolute0> in windows, i get this error: setup.exe: wx-config: runGenProcess: does not exist (No such file or directory)
05:57:03 <Absolute0> I tried running cabal install runGenProcess
05:57:04 <fasta> Absolute0, so, do you have wx-config in your PATH?
05:57:10 <Absolute0> but there doesnt seem to be such a package
05:57:39 <Absolute0> fasta: its a fresh ghc platform installation..
05:57:51 <Absolute0> wouldn't wx-config come after wxcore?
05:57:57 <fasta> Absolute0, and?
05:58:04 <Absolute0> let me see..
05:58:11 <fasta> Anyway, I get Resolving dependencies...
05:58:11 <fasta> cabal: cannot configure containers-0.3.0.0. It requires base >=4.2 && <6
05:58:11 <fasta> There is no available version of base that satisfies >=4.2 && <6
05:58:49 <fasta> This is on Linux using 6.10.4, so, as far as I am concerned this is vapourware.
05:58:49 <Absolute0> fasta C:\Program Files (x86)\Haskell\bin ?
05:59:09 <Absolute0> only cabal and wxdirect are in that folder
05:59:09 <fasta> Absolute0, wx-config is part of the wxwidgets library.
05:59:33 <dcoutts_> Absolute0: it's referring to the program wx-config. You need the wxWidgets C bits installed to be able to compile the Haskell bindings to wxWidgets
05:59:41 <fasta> Absolute0, that is a C++ library, which you need before you can bind to it, of course.
05:59:58 <fasta> Absolute0, the wxcore stuff is only a binding with some superficial Haskell stuff.
06:00:08 <dcoutts_> fasta: it's a bad error message, it should say that it's not possible to upgrade the base package
06:00:26 <fasta> dcoutts_, I didn't update cabal here, yet, I think.
06:00:49 <fasta> Is it backwards compatible?
06:01:06 <dcoutts_> fasta: is what backwards compatible? cabal?
06:01:14 <fasta> dcoutts_, yes
06:01:18 <dcoutts_> upgrading cabal is orthogonal to upgrading base
06:01:33 <fasta> dcoutts_, I was referring to the bad error messages.
06:01:46 <dcoutts_> fasta: the error message is no better in the latest version
06:01:54 <dcoutts_> I was just explaining it, not saying it's fixed
06:01:55 <fasta> dcoutts_, I assumed that you thought I had the latest and greatest and things had improved.
06:02:06 <fasta> dcoutts_, ok.
06:02:16 <fasta> Absolute0, is that clear?
06:03:22 <mreh> how is the IOUArray different from the vanilla one?
06:03:56 <ivanm> is it possible to get the sequence of bytes that make up a Char value?
06:04:33 <mreh> ivanm: shifting them and adding?
06:04:33 <Cale> ivanm: In which encoding?
06:04:36 <ivanm> apparently Graphviz parses values on the byte level (i.e. bytestring) and then converts them into characters, whereas I'm dealing with Char values straight away
06:04:43 <ivanm> Cale: utf8 by default
06:04:44 <dcoutts_> ivanm: you can convert each Char to the number of the Unicode code point
06:04:45 <mreh> unicode is one byte anyway
06:04:51 <ivanm> (and that's all I plan on using anyway)
06:04:55 <Cale> mreh: what?
06:05:08 * ivanm quotes the email he got from upstream
06:05:15 <mreh> Cale: that's ASCII
06:05:18 <Cale> UTF-8 uses one byte to encode code points between 0 and 127
06:05:20 <mreh> why do they have an 8 in the name?
06:05:28 <ivanm> actually, I might paste it up somewhere rather than put it here
06:05:31 <mreh> oh
06:05:35 <hape> hi, when "cabal list" leads to "cabal: Command.optionToFieldDescr: feature not implemented" and my ~/.cabal/config file seems to be right what shall I do?
06:06:14 <ivanm> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24877#a24877
06:06:17 <Absolute0> Whats an ideal gui framework for haskell that will allow me to easily code up a chess gui (chessboard, pieces, handle mouse events, etc)?
06:06:18 <hpaste>  How Graphviz parses Strings (ivanm)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24877
06:06:27 <ivanm> oh, right, forgot hpaste was back
06:06:37 <ivanm> Absolute0: a non-existent one methinks
06:06:40 <Cale> Obviously it can't be magical, and has to use more bytes in general, since there are more than 256 possible unicode code points. :)
06:06:46 <Absolute0> And I would like to be able to create binaries for both windows and linux
06:06:53 <Eelis> ivanm: utf8-string 0.3.7 has a Char->[Word8] function, but it's not yet on hackage
06:06:56 <ivanm> since no haskell GUI library that I know of has a "makeChessBoard" function :p
06:06:59 <quicksilver> ivanm: ok, you asked the wrong question.
06:07:02 <ivanm> Eelis: hmmm...
06:07:09 <ivanm> quicksilver: what should have I asked?
06:07:12 <Absolute0> ivanm stop being silly
06:07:16 <Eelis> ivanm: it's on github though
06:07:19 <ivanm> Absolute0: :D
06:07:19 <quicksilver> ivanm: the question you wanted to ask us is "how do I output a String as UTF8"
06:07:29 <Cale> Absolute0: Perhaps Gtk2Hs with Cairo?
06:07:30 <quicksilver> ivanm: at least, that's my reading of what you just paed.
06:07:36 <Eelis> ivanm: also, in <0.3.7 you can just use encodeString [c]
06:07:38 <dcoutts_> hape: seems like there's a field in your ~/.cabal/config that it does not cope with.
06:07:46 <ivanm> quicksilver: well, I was under the impression that they were describing codepoints...
06:07:56 <dcoutts_> hape: presumably you've just been editing the config file
06:07:58 <quicksilver> ivanm: "we require the input character set to be Latin-1
06:07:58 <Absolute0> Cale would that allow me to create shippable binaries for windows?
06:07:59 <quicksilver> or the default UTF-8"
06:08:08 <ivanm> Eelis: atm, I'm just using whatever GHC provides; I later intend on using the text library and forcing utf-8 usage
06:08:10 <quicksilver> ivanm: to me that says they want UTF8
06:08:15 <Absolute0> Cale without the user having to install ghc or gtk?
06:08:16 <Eelis> ivanm: ok
06:08:23 <ivanm> quicksilver: they default to utf-8 but allow you to set it to latin-1
06:08:28 * quicksilver nods
06:08:28 <ivanm> (which I don't plan on supporting)
06:08:36 <quicksilver> so they don't want codepoints
06:08:41 <ivanm> Absolute0: what's wrong with installing the gtk runtime on windows?
06:08:42 <Cale> Absolute0: Well, probably the user will need to install GTK. I'm not sure if there's a way around that.
06:08:45 <ivanm> I did that to get the gimp...
06:08:51 <quicksilver> (not surprising - you very rarely see communication by codepoints)
06:08:55 <ivanm> quicksilver: yeah
06:09:07 <quicksilver> there are a few ways to output utf8
06:09:10 <ivanm> but in that case, how do you get \377? that's more than a byte...
06:09:23 * ivanm isn't sure if just using isLetter is valid :s
06:09:58 <Absolute0> ivanm nothing wrong for me but some clients wouldnt know where to start
06:10:10 <Cale> Absolute0: I suppose another way, which seems a bit less appropriate for chess is to do the whole thing using OpenGL.
06:10:11 <dcoutts_> hape: the optimisation field I'm guessing
06:10:15 <ivanm> Absolute0: "make sure you install this first"
06:10:23 <quicksilver> ivanm: no it's not more than a byte; he's talking octal there
06:10:31 <ivanm> oh...
06:10:32 <quicksilver> ivanm: octal 377 = 255 = hex FF
06:10:37 <ivanm> ahhhhh
06:10:43 * ivanm vaguely recalls that kind of stuff
06:10:53 <quicksilver> anyhow, use utf8-string, would be my recommendation I think
06:10:57 <Cale> Absolute0: Or devise your own GUI abstraction, and implement it using the Win32 API and Gtk2Hs.
06:11:00 <quicksilver> encode :: String -> [Word8]
06:11:06 <Cale> Absolute0: Oh, there's also WxHaskell
06:11:23 <EvanR> fltk2 !
06:11:28 <dcoutts_> hape: http://hackage.haskell.org/trac/hackage/ticket/368
06:11:55 <SamB_XP> Cale: isn't it also possible to ship GTK with the application and install it in the apps directory?
06:12:07 <Cale> SamB_XP: I'm not sure
06:12:08 <ivanm> quicksilver: see, I'm needing/wanting it on a parsing level as well...
06:12:13 <Cale> I never have to deal with Windows
06:12:19 <dcoutts_> Absolute0: I've shipped Windows Haskell binaries using gtk2hs
06:12:20 <hape> dcoutts_ that is true, i edited the config file, but then draw back my changes. perhapse i pickup a fresh one and make diff
06:12:23 <EvanR> windows... apps directory?
06:12:25 <hape> dcoutts_ thanks!
06:12:27 <ivanm> so what should I do? given a char, see if it's valid by converting it to [WOrd8] and checking if they're all valid? :s
06:12:38 <quicksilver> ivanm: why do you need to check it's valid?
06:12:41 * quicksilver re-reads the paste
06:12:49 <Absolute0> dcoutts_: was it painful to do?
06:12:50 <ivanm> quicksilver: because I'm parsing Dot code and need to know how to parse it?
06:13:00 <ivanm> SamB_XP: oh, so the user gets to install Gtk heaps of times? :p
06:13:26 <EvanR> windows programs will look for dlls in the same dir as the binary
06:13:28 <EvanR> put gtk there
06:13:30 <quicksilver> ivanm: just read it as UTF8
06:13:34 <quicksilver> ivanm: and then parse it as Chars
06:13:49 <SamB_XP> ivanm: well, it could be made optional
06:13:54 <dcoutts_> Absolute0: at the time I did it, there was not a windows build for ghc-6.10.4, only for 6.10.1, so I had to build gtk2hs from source on windows. Apart from that it's not problematic.
06:13:55 <SamB_XP> I think
06:13:55 <ivanm> quicksilver: huh?
06:13:57 <quicksilver> ivanm: the rule is almost always: decode on input, process as Char, encode on output.
06:14:12 <ivanm> quicksilver: right, but I need to know when to _stop_ decoding
06:14:26 <quicksilver> why would you stop? why would you not decode everything
06:14:30 <ivanm> and parsing
06:14:37 <dcoutts_> Absolute0: we ship the ghc-compiled exe and all the gtk dlls etc, so it works on any machine
06:14:40 * ivanm isn't sure he understands what quicksilver is talking about
06:14:46 <quicksilver> ivanm: treat the entire file as UTF8.
06:14:50 <quicksilver> ivanm: then you will have no problem.
06:15:03 <Absolute0> dcoutts_: can I come work for you? :)
06:15:16 <quicksilver> or do you need to support the latin1 case too?
06:15:23 <ivanm> quicksilver: my current String parser is: do frst <- satisfy frstIDString; rest <- many (satisfy restIDString); return $ fst : rest
06:15:36 <dcoutts_> Absolute0: heh :-)  we're not exactly a huge company
06:15:43 <Absolute0> where are you based?
06:15:49 <ivanm> where frstIDString checks if the character is in that allowed alphabetic range or an underscore, and restIDString also allows digits
06:15:57 <Absolute0> I am just doing my own project... would love to get paid to code haskell
06:16:15 <dcoutts_> Absolute0: on the internet, but physically Oxford, UK
06:16:24 <ivanm> so my problem is how do I transform that alphabet of values into something I can test for Char values
06:16:50 <ivanm> dcoutts_: oh, btw, someone might be duplicating haskell-updaters rebuild functionality for cabal-install during AusHack; you OK with that?
06:16:59 <Absolute0> dcoutts_: what sort of projects do you work with?
06:17:14 <dcoutts_> ivanm: what would it do?
06:17:30 <quicksilver> ivanm: the union of a-zA-Z and (ord x > 255)
06:17:32 <dcoutts_> Absolute0: some open source, some for private clients
06:17:38 <ivanm> dcoutts_: "cabal rebuild" will rebuild all packages reported as being broken by ghc-pkg check
06:17:50 <dcoutts_> ivanm: ah, I see, right
06:17:51 <ivanm> quicksilver: so ignore the ord x < 377 ?
06:18:07 <dcoutts_> ivanm: and cabal has code to detect the same, so that should be relatively straightforward
06:18:17 <quicksilver> ivanm: sorry, I misspoke
06:18:17 <ivanm> dcoutts_: right; that's what haskell-updater uses ;-)
06:18:21 <quicksilver> ivanm: the union of a-zA-Z and (ord x > 128)
06:18:25 <ivanm> don't you remember me bugging you about this?
06:18:26 <quicksilver> ivanm: is what I meant.
06:18:26 <dcoutts_> ivanm: the key decision is whether to try to make a coherent install plan, or merely individually coherent
06:18:33 <quicksilver> ivanm: he doesn't care about non-ascii characters
06:18:46 <quicksilver> ivanm: anything above 128 (which includes all the multibyte chars) he treats as a letter
06:18:56 <dcoutts_> ivanm: what is likely is that it's not possible to reinstall all the broken packages so that there is a single version of all dependencies.
06:18:56 <ivanm> quicksilver: ahhhh
06:19:00 <EvanR> extended ascii!
06:19:08 <ivanm> quicksilver: do you know if isAlpha would work?
06:19:13 <ivanm> EvanR: shush you
06:19:14 <quicksilver> it would not work.
06:19:25 <ivanm> dcoutts_: *nod*
06:19:27 <quicksilver> isAlpha would *exclude* various things > 128 which are not alpha.
06:19:28 <ivanm> quicksilver: :(
06:19:39 <quicksilver> what's so hard about a-zA-Z or ord > 128?
06:19:46 <ivanm> how do you specify octal values in haskell?
06:19:46 <quicksilver> seems a pretty simple spec to me :)
06:19:51 <quicksilver> FORGET THE OCTAL!
06:19:56 <quicksilver> a-zA-Z or ord > 128?
06:19:59 <quicksilver> that's all you need
06:20:01 <quicksilver> a-zA-Z or ord > 128
06:20:02 <ivanm> quicksilver: nothing; I had already just changed my definition to using isAlpha, that's all ;-)
06:20:11 <ivanm> quicksilver: I meant in future if I needed it ;-)
06:20:23 <quicksilver> I don't think haskell has an octal literal syntax
06:20:28 <ivanm> k
06:21:43 <SamB_XP> what do we use for unix "modes" ?
06:22:25 <quicksilver> an enumerated data
06:22:31 <quicksilver> I presume
06:23:20 <quicksilver> haha, no, we don't
06:23:29 <quicksilver> we use a newtyped Int with custom combinators :) ah well.
06:24:11 <ivanm> quicksilver: OK, so isAsciiUpper x || isAsciiLower x || ord x >= 128
06:24:13 <ivanm> ?
06:24:15 <hape> when editing haskell code, which editor personally prefer?
06:24:21 <hape> when editing haskell code, which editor You personally prefer?
06:24:25 <ivanm> and is the ord bit equivalent to "x >= '\200') ?
06:24:41 <ivanm> hape: most people here use either emacs or a variant of vi
06:24:45 <hape> merci
06:24:46 <quicksilver> ivanm: well, it's not strictly comparable
06:24:51 <ivanm> some use other editors, others use some IDEs
06:24:53 <quicksilver> ivanm: you're talking about characters and he was talking about bytes.
06:24:58 <ivanm> quicksilver: *nod*
06:25:01 <dankna> this has been discussed frequently; Emacs and Vi are the most popular
06:25:13 <ivanm> should we have a #haskell FAQ? :p
06:25:18 <hape> no
06:25:21 <hape> its fine
06:25:22 <dankna> hah, nah, it's interesting when it comes up
06:25:27 <ivanm> heh
06:25:33 <quicksilver> ivanm: but as in happens in UTF8 - as a very special property of UTF8 - all characters >= 128 are represented by multiple bytes ALL OF WHICH are >= 128
06:25:45 <ivanm> quicksilver: *nod*
06:26:05 <quicksilver> ivanm: this very special property of UTF8 is precisely why the graphviz designers can support latin1 and utf8 'at the same time' without most of the code caring which is which
06:26:35 <quicksilver> so maybe the short answer to your question was just 'yes'
06:26:39 <quicksilver> but I felt that didn't do it justice ;)
06:27:05 <ivanm> quicksilver: yet they _don't_ support 122 < x < 200 ...
06:27:17 <ivanm> so wouldn't \200 be better?
06:27:55 <quicksilver> SamB_XP: apparently what we use is ownerReadMode `unionFileMode` ownerWriteMode `unionFileMode` groupReadMode `unionFileMode` otherReadMode
06:28:02 <quicksilver> SamB_XP: read 'em and weep ;)
06:28:07 <quicksilver> ivanm: \200 is 128.
06:28:17 <ivanm> quicksilver: ord says otherwise
06:28:18 <quicksilver> ivanm: there are only 6 chars between 122 and 127
06:28:21 <ivanm> > ord '\200'
06:28:22 <lambdabot>   200
06:28:27 <quicksilver> ivanm: that's because haskell doesn't use octal
06:28:33 <quicksilver> ivanm: but your correspondant in that email is using octal
06:28:35 <ivanm> _ooooooohhhhhhh_
06:28:39 <ivanm> now I get it! :D
06:28:45 <quicksilver> > map chr [122..127]
06:28:46 <lambdabot>   "z{|}~\DEL"
06:28:50 <ivanm> thanks quicksilver
06:28:54 <quicksilver> ivanm: as you can see, those are punctuation
06:28:57 <quicksilver> (plus DEL)
06:29:01 <ivanm> quicksilver: in that case, I can't use that; braces aren't allowed
06:29:03 <quicksilver> so he doesn't want them to be ids
06:29:05 <quicksilver> exactly
06:29:09 <quicksilver> that's why it's >128!
06:29:13 <quicksilver> (not >122!)
06:29:48 <dcoutts_> quicksilver: haskell doesn't use octal "\o77\o77"
06:29:54 <dcoutts_> > "\o77\o77"
06:29:55 <lambdabot>   "??"
06:29:59 <quicksilver> dcoutts_: ah, nice :)
06:30:10 <quicksilver> > ord "\o200"
06:30:11 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
06:30:11 <lambdabot>         against inferred type...
06:30:18 <quicksilver> > ord '\o200'
06:30:19 <lambdabot>   128
06:30:21 <quicksilver> ivanm: there you go :)
06:30:26 <quicksilver> ivanm: all clear now?
06:30:30 <ivanm> I _knew_ there was a way of doing octal!
06:30:32 <ivanm> quicksilver: yup
06:30:38 <SamB_XP> > 0o200
06:30:39 <lambdabot>   128
06:31:17 <dankna> 0o0
06:31:26 <dankna> spectacles
06:31:31 <dankna> with a big nose
06:31:43 <ivanm> > ord '\o377'
06:31:44 <lambdabot>   255
06:32:05 <ivanm> > text ['\o200' .. '\o377']
06:32:06 <lambdabot>   ...
06:32:09 <ivanm> :D
06:32:58 <SamB_XP> that looks kinda screwed up here ...
06:33:03 <alpounet> yeah
06:33:06 <alpounet> many s
06:33:09 <FliPPeh_> Looks okay here
06:33:13 <FliPPeh_> Except for the As
06:33:21 <SamB_XP> I think lambdabot may have cut it off in mid-character?
06:33:25 <FliPPeh_> :T text
06:33:28 <FliPPeh_> :t text
06:33:29 <lambdabot> String -> Doc
06:33:41 <ivanm> quicksilver: OK, so their spec uses \xyz to refer to the octal value character xyz, whereas Haskell uses it for a Unicode codepoint?
06:33:59 <ivanm> SamB_XP: it's meant to be methinks ;-)
06:34:03 <FliPPeh_> > text ['\2556' .. '\255F']
06:34:05 <lambdabot>   <no location info>:
06:34:05 <lambdabot>      lexical error in string/character literal at chara...
06:34:10 <FliPPeh_> > text ['\2556' .. '\2560']
06:34:11 <lambdabot>   
06:34:12 <SamB_XP> ivanm: meant to be what ?
06:34:19 <ivanm> SamB_XP: screwed up ;-)
06:34:25 <quicksilver> ivanm: yes.
06:34:28 <SamB_XP> ivanm: it should only have each char once
06:34:30 <ivanm> *nod*
06:34:45 * ivanm looks again at what it spat out
06:34:53 <SamB_XP> not have U+0080 a bunch of times
06:35:18 <ivanm> heh, ghci running within emacs doesn't like that ;-)
06:35:36 <ivanm> yeah, looks really different within ghci running in a term
06:35:38 <SamB_XP> > text (' ':['\o200' .. '\o377'])
06:35:39 <lambdabot>    ...
06:35:51 <ivanm> but my font doens't like it; has a whole bunch of weird boxes before the upside down !
06:36:06 <ivanm> SamB_XP: oooh, what does that extra space do? :o
06:36:45 <SamB_XP> ivanm: causes lambdabots cut-off point to fall between characters in the UTF-8
06:36:52 <ivanm> aha
06:37:12 <SamB_XP> so that our clients don't think "that can't be utf-8" and display it as latin-1 or whatever
06:37:30 <dcoutts_> SamB_XP: so lambadbot is cutting after conversion to utf8 rather than before, naughty
06:37:31 <ivanm> interesting...
06:37:40 <dankna> yeah, that could be exploitable
06:37:41 * ivanm blames gwern
06:37:42 <ivanm> :p
06:38:20 <ivanm> quicksilver: and the hack works if I assume utf-8 because all code points > 128 will then be valid (since they're composed solely of combinations of bytes > 128)?
06:38:34 <quicksilver> yes
06:39:35 <EvanR-work> utf8 for the win
06:40:41 <ivanm> quicksilver++
06:40:43 <ivanm> thansk for your help
06:40:58 <ivanm> EvanR-work: yes, I'll be explicitly restricting it to utf-8 in a future release
06:41:19 <EvanR-work> since you dont care about non ascii, you dont have to
06:41:42 <Lor_> How is one supposed to bootstrap happy? The 1.18.4 distribution only comes with AttrGrammarParser.ly, not the generated haskell code.
06:42:15 <dankna> argh
06:42:18 <dankna> MPTCs are confusing
06:42:30 <dankna> or at least, this particular use of them is
06:42:51 <EvanR-work> mptc?
06:43:01 <SamB_XP> Lor_: uh, download an earlier version + bugreport ?
06:43:03 <dankna> multi-parameter type classes
06:43:33 <dankna> I'm trying to build a "suspendable monad" facility which has instances for most of the transformers in mtl
06:43:35 * ivanm records quicksilver's contribution in the darcs record message
06:44:26 <Lor_> SamB_XP, it's hard to believe that such a bug would have gone unnoticed for so long
06:44:29 <dankna> so I have a typeclass with four parameters: the monad itself, the type of its "frozen" state
06:44:35 <Lor_> I still suspect I'm missing something obvious.
06:44:42 <dankna> the type of its "inner" result, and the type of its "outer" result
06:44:50 <ivanm> yay, only 3 unparseable sample Dot files remaining, and one of them I don't care about since it's there specifically to demonstrate how to use Latin1 encoding (and thus 6.12 can't even read it since my locale is set to utf-8)! \o/
06:45:09 <EvanR-work> dankna: i thought to be instance of monad you need exactly one type
06:45:20 <SamB_XP> Lor_: you don't think it's possible that nobody who's tried to build happy in the last few years has lacked a copy of happy?
06:45:37 <SamB_XP> at least, not anybody confident enough to report a bug?
06:45:39 <dankna> EvanR: that is correct.  this is a new typeclass SuspendableMonad which "inherits" from Monad.
06:46:08 <Lor_> I'd expect people to do clean slate installs occasionally.
06:46:34 <dankna> the concept is that it's a generic facility for the situation where you need to call something like bracket or withMVar or something
06:46:41 <dankna> which has type IO a -> IO a
06:46:42 <Lor_> That's how I encountered this: tried to install basic haskell development tools from scratch as a luser.
06:46:48 <dcoutts_> ivanm: you can tell ghc to use any locale, or binary
06:46:53 <dcoutts_> erm, encoding
06:46:55 <dankna> but you are in a complicated transformer stack built on top of IO, not in IO directly
06:47:37 <dankna> I got annoyed at writing special-case code for each combination of function I needed to call and monad stack
06:47:41 <ivanm> dcoutts_: right, but if I wanted to support Latin1 as well as utf-8, then I'd have to start reading and parsing through the file and then suddenly switch to Latin1 if it has the encoding attribute set to it
06:47:46 <dankna> and decided to do a general facility
06:47:51 <dankna> and it sort of works except that it doesn't :)
06:48:02 <ivanm> and I'm not sure how well GHC will cope with that :p
06:48:04 <EvanR-work> monad transformers, sounds complex
06:48:04 <SamB_XP> Lor_: well, conisder yourself a person and report the issue!
06:48:14 <dankna> it's somewhat complex
06:48:21 <dankna> it's some of the deepest Haskell I've written, certainly
06:48:21 <ivanm> (besides, in the release after this one I'm going to probably start using text and force utf-8 usage)
06:48:26 <dankna> but I still consider myself a newbie
06:48:37 <Lor_> Right, 1.16 had the .hs included, 1.17 no longer has it.
06:48:46 <ivanm> dcoutts_: my only other option would be to do what Graphviz does and parse on the level of bytes, which I don't really want to do
06:48:48 <dcoutts_> ivanm: if the file does actually declare its own encoding at the top before you have to decode non-ascii then that's not problematic, just switch encodings, ghc copes fine
06:48:48 <SamB_XP> Lor_: I think that was an accident
06:48:58 <ivanm> dcoutts_: well, I don't care :p
06:49:00 <Lor_> And it's been two and a half years since 1.17...
06:49:08 <SamB_XP> probably they switched to a new way of generating the tarball
06:49:12 <ivanm> dcoutts_: lemme guess: I'd have to stop parsing, and do so in IO?
06:49:15 <ivanm> if so, it won't work
06:49:26 <SamB_XP> well, a LOT of us have used binaries to install happy
06:49:32 <ivanm> the encoding specification is in the middle of the Dot graph, not up the top
06:49:53 <ivanm> dcoutts_: http://paste.pocoo.org/show/201367/
06:50:04 <SamB_XP> @hackage happy
06:50:04 <lambdabot> http://hackage.haskell.org/package/happy
06:50:21 <ivanm> and it seems to have failed pasting it...
06:51:09 <SamB_XP> Lor_: oh, it looks like there's more recent versions
06:51:18 <SamB_XP> like 1.18.4
06:51:33 <Lor_> Yes, that's what I tried first.
06:51:46 <SamB_XP> has that file been missing since 1.17, then?
06:51:51 <Lor_> Yeah.
06:52:05 <mreh> No instances for (IArray UArray a, MArray IOUArray a IO)
06:52:05 <mreh>       arising from a use of `parsePCMFile' at ReadWriteWav.hs:49:10-28
06:52:08 <mreh> what does that mean?
06:52:09 <Lor_> Gaah, and with 1.16 I get  "Could not find module `Distribution.Setup'"
06:52:11 <SamB_XP> JaffaCake: you've got some 'splaining to do
06:52:29 <mreh> the type of the function is polymorphic with those restrictions
06:52:41 <SamB_XP> @localtime JaffaCake
06:54:33 <SamB_XP> Lor_: anyway, go ahead and REPORT the bug, for ... er ... our sake!
06:55:51 <SamB_XP> dcoutts: hmm, do you know of a way to make cabal sdist do the right thing for Happy?
06:55:55 <ivanm> hang on, what's the problem with Happy?
06:56:12 <ivanm> do you end up needing a version of Happy installed to be able to build newer versions?
06:56:28 <dcoutts_> SamB_XP: no, but I can find you the ticket in the trac
06:56:41 <dcoutts_> SamB_XP: well, I mean yes, but it needs code changes
06:56:46 <SamB_XP> ivanm: precisely!
06:56:50 <ivanm> SamB_XP: :s
06:57:04 <dankna> hm
06:57:17 <SamB_XP> I assume the tarballs used to be built with "make"
06:57:18 <dankna> I'm interested in this question too - how to make cabal sdist do the right thing
06:57:35 <ivanm> what does it do wrong?
06:57:36 <dankna> because Joy is also going to be self-hosting and need to include its pregenerated source file in the tarball
06:57:46 <dcoutts_> dankna: interested in the sense of willing to do some cabal hacking?
06:57:50 <dankna> it's not clear that it's /wrong/, but it doesn't have a facility
06:57:57 <dankna> dcoutts: I'm going to have to at some point anyway, so sure
06:58:07 <SamB_XP> dankna: well, the right thing is different when you aren't happy ;-)
06:58:32 <dankna> SamB: I'm not sure I follow, unless that was just a joke :)
06:58:50 <SamB_XP> that is, I guess you'd wanna be able to specify which generated files you want to include in the tarball
06:58:57 <dankna> yeah
06:59:06 <dankna> and they need to be findable by the build process on the other end
06:59:27 <dankna> so maybe that means including some of dist/ in the tarball?
06:59:33 <SamB_XP> e.g. alex and happy would want to pre-run alex and happy on the alex and happy sources for their source tarballs
06:59:56 * dcoutts_ looks for the ticket
06:59:59 <dankna> and Joy would want to pre-run Joy on the Joy sources, by the same reasoning, yes.  Joy is to be a self-hosting Lexer/Parser generator.
07:00:21 <SamB_XP> and I suppose frown would want to do something similar
07:00:25 <dankna> I imagine.
07:01:12 <SamB_XP> hmm, does cabal have what it takes to run frown ?
07:02:01 <dcoutts_> SamB_XP: I expect it'd be easy to add
07:02:13 <dankna> dcoutts_: btw, I'm also still potentially interested in helping with the feature for hackage involving reporting of build successes and failures, but I couldn't get the hackage stuff to build for me due to dependency issues.  I'll ask you about that some other time, I don't really have time to dedicate to it today.
07:02:38 <dcoutts_> dankna: ok
07:02:49 <dankna> just so you don't think I forgot :)
07:03:11 <dcoutts_> :-)
07:05:46 <SamB_XP> dcoutts_: but can you tell *current* cabal how to do it?
07:05:54 <dcoutts_> SamB_XP: actually it does already
07:05:57 <dcoutts_> check the tarball
07:06:13 <dcoutts_> probably the problem is that the timestamps are the wrong way around
07:06:21 <ivanm> has that bug been found yet?
07:06:23 <SamB_XP> dcoutts: oh ?
07:06:27 <Lajla> This might be a particularly stupid quaestion, but what exactly is the difference between static and dynamic typing without mutable data?
07:06:28 <SamB_XP> how does that happen ?
07:06:42 <dcoutts_> SamB_XP: happy-1.18.4 right?
07:06:55 <ivanm> Lajla: the mutable data bit is irrelevant AFAIK
07:06:58 <Philippa> Lajla: I'm not sure how that question might make sense to someone
07:07:05 <dankna> ah - this ticket looks relevant - http://hackage.haskell.org/trac/hackage/ticket/166
07:07:17 <ivanm> static and dynamic typing are different full stop
07:07:27 <ivanm> Lajla: http://www.pphsg.org/cdsmith/types.html
07:07:40 * ivanm thinks he's @where+'d that link, but can't remember under what
07:07:52 <SamB_XP> dcoutts_: oh, and when I say "it", I meant "use arbitrary parser-generators or what-have-you"
07:08:16 <dcoutts_> dankna: yes, that got fixed, the .hs files get put in the tarball, however we then have a problem with timestamps
07:08:17 <Lajla> Philippa, well, as I understand it, in static typing, variables have a type while in dynamic typing, their values do, but if the value of a variable cannot change, then it's one and the same, or not?
07:08:22 <dcoutts_> dankna: I think
07:08:44 * ivanm -> land of nod
07:08:44 <SamB_XP> dcoutts_: what happens with the timestamps?
07:08:53 <dcoutts_> SamB_XP: you mean adding custom pre-processors in the Setup.hs?
07:08:54 <dankna> dcoutts: okay - what's the timestamp issue as you understand it?
07:08:57 * SamB_XP -> land of GDI
07:09:00 <dankna> also relevant: http://hackage.haskell.org/trac/hackage/ticket/137
07:09:08 <SamB_XP> dcoutts: yes -- multiple of them
07:09:10 <ivanm> @slap SamB_XP
07:09:10 * lambdabot puts on her slapping gloves, and slaps SamB_XP
07:09:31 <Lor_> Lajla, if the variable is a parameter, it gets multiple values as the function gets applied to different arguments.
07:09:35 <ivanm> wait, SamB_XP isn't MissPiggy, is he? :p
07:09:35 <dcoutts_> SamB_XP: yes, that's been supported for several major releases now
07:10:26 <quicksilver> Lajla: well, yes, what you said was true, but it's not the whole story
07:10:32 <Lajla> Lor_, ahh, so that counts as one variable?
07:10:37 <dcoutts_> dankna: actually now I'm not sure. I cannot reproduce the problem.
07:10:49 <Lajla> Well, then I see there clearly is a difference.
07:10:54 <dankna> dcoutts: hmm
07:10:55 <quicksilver> Lajla: in a typical dynamically typed language (for example) in arrays each element may be of a different type
07:10:57 <Lajla> I'm reading that link now by the way.
07:11:02 <quicksilver> Lajla: that is quite apart from mutation
07:11:16 <quicksilver> (although it's also true that you can typically change any one element, and make it a different type, at the same time[
07:11:26 <dcoutts_> dankna: it is certainly plausible that we could get timestamp problems. I think timestamps are not preserved when unpacking the tarballs.
07:11:28 <Lajla> Ahh, I didn't know that was part of dynamic/static typing too.
07:11:34 <quicksilver> it's all related.
07:11:40 <dcoutts_> dankna: and I don't think they get set when creating the tarballs either
07:11:42 <dankna> dcoutts: hmmm yes
07:12:08 <dankna> dcoutts: I think they probably should be both set and preserved.  would you like me to add that?  it would be nice to have a test that fails without it though.
07:12:30 <dcoutts_> dankna: a more robust solution to the issue of shipping pre-processed files is to put them somewhere more sensible
07:12:52 <dankna> dcoutts: true.  is dist/ even the right place?  should there be a directory called preprocessed/ or something?
07:13:05 <dcoutts_> dankna: yes exactly
07:13:24 <dcoutts_> dankna: dist is not the right place, it gets cleaned and its location is only a default
07:13:42 <dankna> gotcha.  of course the build infrastructure will have to be changed to understand the new location instead of the old one when building.
07:13:52 <dcoutts_> dankna: yes
07:14:09 <dankna> okay, well I'll work on this, maybe even right now
07:14:09 <Lajla> ivanm, the link does seem to be in favour of static typing though, is that true or am I misinterpreting the tone?
07:14:50 <ivanm> Lajla: methinks you're misinterpreting the tone (though a good static typing system like Haskell's has all of the advantages of python-style dynamic typing with less problems)
07:15:28 <dcoutts_> dankna: it'll still need to compare timestamps I guess, since if the Parser.y is newer than the shipped/Parser.hs then we need to generate dist/build/Parser.hs
07:15:42 <dankna> yes, absolutely
07:16:19 <dankna> what would you like that directory to be called?  I think preprocessed/ makes more sense than shipped/, but you're the maintainer, I'll go with whatever you decide
07:16:42 <dcoutts_> dankna: use preprocessed/ until we think of something better, it should be easy to change
07:16:45 <dankna> okiedoke
07:17:29 <dcoutts_> dankna: something you might like to think about at the same time is the possibility to ship multiple versions of pre-processed files, for different profiles, e.g. generic or ghc-optimised
07:17:36 <dankna> yes hmmmm
07:17:38 <dcoutts_> dankna: that's an issue for happy and alex
07:17:41 <dankna> is it?  hmm
07:17:55 <dankna> so perhaps we want
07:17:57 <Lajla> ivanm, I'm not really sure what a python-style dynamic typing would be as I've never coded in python my life, or haskell for that matter, but it's an interesting read.
07:18:03 <dankna> preprocessed/generic/ preprocessed/$compiler/
07:18:16 <dcoutts_> dankna: http://hackage.haskell.org/trac/hackage/ticket/137
07:18:24 <dcoutts_> dankna: right, something like that
07:18:34 <dankna> ah yeah, I've already got that open
07:18:50 <dankna> my list of relevan tickets is 132, 137, 166, did I miss any?
07:18:56 <Twey> Lajla: In static typing, the types are calculated at compile-time; in dynamic typing, they are calculated at run-time.
07:19:27 <dankna> ah, strike 132, it's already fixed
07:19:29 <Lajla> Twey, what are you doing here too, that's not fair.
07:19:50 <bremner> eh?
07:19:52 <dcoutts_> dankna: right, I was just about to say
07:19:58 <Lajla> Twey, hmmhmm, I knew that, I just didn't get what difference it would make at first if variables can't change their values.
07:20:29 <Twey> Lajla: It can be used to dispatch, or to highlight errors
07:21:05 <dcoutts_> dankna: it's not obvious what vars should be allowed for more specialised profiles
07:21:39 <dcoutts_> dankna: compiler is the obvious one of course but I'm sure people could devise cases where more would be preferable
07:21:58 <dcoutts_> dankna: not that we should implement more now, just consider what the naming should be so we can add more later
07:22:10 <dankna> dcoutts: agreed.  indeed, in principle you might even want your custom build-flags to be included.
07:22:28 <Lajla> Twey, errors, errors, I am personally in favour of the simplicity of no typing at all, I think a computer should just be a mindless slave that should do what I tell it to do and it should be my responsibility that the isntructions make sense.
07:22:42 <bremner> C is that way =>
07:22:52 <dcoutts_> dankna: I hope not! you'd have to ship a lot of versions
07:22:59 <dankna> dcoutts: the subdirectory name could be a (textual) list of key-value pairs.  compiler:ghc-6.12.1+flag_myflag:True.
07:23:01 <dankna> yes no kidding
07:23:22 <dcoutts_> dankna: but perhaps gtk2hs might like to ship pre-processed .chs -> .hs files for windows
07:23:23 <Twey> Lajla: That's generally an indication that you've never written a large program
07:23:28 <Philippa> ivanm: Haskell does /not/ have all the advantages of python-style dynamic typing. There are things that can't easily be typed, can't be typed at all or definitely can't be typed without annotations
07:23:36 <dankna> right hmmm
07:23:46 <dcoutts_> dankna: that's a case where there is no generic, it cannot do it for all platforms
07:23:46 <Lajla> bremner, C gives a lot of type errors too, ideally, a programming should run without complaint as soon as the programming contains no syntax errors until it either terminates or the memory runs out.
07:23:53 <Lajla> Twey, or that I'm a masochist, who knows?
07:23:56 <dankna> right
07:24:14 <dankna> but it IS generic with respect to the compiler version - just not to the architecture
07:24:18 <dcoutts_> dankna: but for windows the ABI is fixed and they can ship with a particular gtk version
07:24:29 <dcoutts_> dankna: right
07:24:54 <dankna> the key-value thing is really pretty ugly, especially because how do you decide which version to use?
07:25:13 <dcoutts_> dankna: I don't follow
07:25:14 <dankna> ie in the presence of one specialized on your compiler version and generic to your architecture, and one that's the other way around, which do you choose?
07:25:39 <dankna> the simplest thing is to have a rule saying "don't do that then" but how do you even formulate such a rule?
07:25:40 <dcoutts_> dankna: arbitrary fixed ordering of variables
07:25:44 <dankna> okay, right
07:25:49 <dankna> pragmatic and effective
07:25:57 <dcoutts_> dankna: and tell people not to do that :-)
07:26:00 <dankna> right :)
07:26:28 <dankna> now, how do you tell Cabal what to specialize on?
07:26:41 <dankna> in the .cabal file obviously, but.
07:26:58 <dankna> I think we need a list of use-cases
07:27:06 <dcoutts_> dankna: you mean how to say sdist --do-these-specialisations ?
07:27:40 <dankna> actually no, I was assuming that sdist would simply include everything it finds under preprocessed/
07:27:41 <dcoutts_> dankna: I'd suggest not bothering with any UI atm
07:28:10 <dcoutts_> dankna: it is sdist that generates the pre-processed files
07:28:17 <dankna> oh,
07:28:33 <dankna> I was thinking that both sdist and build need to be able to do that
07:28:39 <dankna> don't they?
07:29:13 <Philippa> Lajla: short of coding in assembler languages or something similarly picky about detail (exactly which addition operation do you mean?) you're not going to get that. The cost of having the computer do what you mean is sometimes it'll realise it hasn't a clue
07:30:16 <dankna> because the idea is that this will replace the current behavior of putting preprocessed files in dist/build/ somewhere, yes?
07:30:48 <Lajla> Philippa, actually because no language existed that did that, I'm currently implementing a high level untyped purely functional language myself to deal with it which probably all people will hate but me but that's what you get with a world of mostly-sane people.
07:31:00 <fasta> Lajla, Forth is pretty close to what you want. Make a mistake and the interpreter generally dies.
07:31:37 <Lajla> I know, forth has its charms, completely consistent syntax is always nice, but it's still to ad-hoc and machine-oriented.
07:32:15 <dankna> dcoutts: haha...... um.... "Fetching a hashed repository would be faster.  Perhaps you could persuade the maintainer to run darcs optimize --upgrade with darcs 2.4.0 or higher?"
07:32:32 <Lajla> It also shows that the middle way never works, it's in all cases oposite of scheme, completely left-branching and no brackets at all but I like both. =P
07:32:35 <dankna> dcoutts: I don't care, I just thought I'd relay the message
07:32:40 <fasta> Lajla, so, you have a language which is "high-level" and is not machine oriented.
07:32:55 <fasta> Lajla, that sounds like something which does nothing.
07:32:59 <Philippa> I strongly suspect it won't meet the Perlis definition of "high-level"
07:33:22 <Lajla> Philippa, why?
07:33:27 <dcoutts_> dankna: ok :-)
07:33:36 <dankna> dcoutts_: hehe
07:33:50 <dcoutts_> dankna: yes, both sdist and build do pre-processing
07:33:53 * dankna nods
07:34:05 <dcoutts_> dankna: but the ones that go in the tarball are generated by sdist, not by build
07:34:28 <Philippa> Lajla: because you have the "which addition operation?" problem - that's the kind of mandatory detail (where there's an obvious one) that inherently puts you at odds with the Perlis definition
07:34:32 <dcoutts_> dankna: it does the pre-processing directly into dist/src/$tmp/the/right/place.hs
07:35:22 <Lajla> Philippa, my language has no types, internal repraesentation of numbers is out of its scope.
07:35:38 <Lajla> You can add two numbers, you can add two pairs, you can add two strings.
07:35:54 <Lajla> (all produce more-ore-less sensible results by the way)
07:36:05 <dankna> dcoutts_: what about the situation where you need to do preprocessing actually on the architecture that you're targeting and then copy them all to your central repository before you sdist?
07:36:19 <Philippa> can you add two records, or whatever the equivalent is?
07:36:25 <dankna> dcoutts_: ie because it needs to ask external programs for the values of things
07:36:28 <Philippa> and if so, how does it attempt to do so?
07:36:43 <dankna> dcoutts_: I know that autoconf has this situation, I don't know whether it's something we care about here
07:36:48 <Lajla> Philippa, sure, you can add all things, but it depends on how you've structured your own records.
07:37:12 <Philippa> and bingo, you have to care about record encoding and you've just failed to meet the Perlis definition of high-level
07:37:14 <dankna> dcoutts_: and I'm not quite wrapping my head around how what you're thinking as a solution is different from what I'm thinking, and whether it deals with that
07:37:21 <Lajla> But to explain it, a character is a natural number (unicode value), a string is a list of characters, the empty string is the empty list, is the identity function et cetera et cetera.
07:37:32 <dcoutts_> dankna: -> #haskell-overflow perhaps?
07:37:35 <dankna> k
07:37:51 <Philippa> oh, good point: what happens when you try to add two functions?
07:38:12 <Lajla> Philippa, depends on the functions, if the functions are numbers it's what you expect.
07:38:37 <Philippa> that's not adding functions, that's adding the results of functions. Either that, or I don't expect what you do
07:38:51 <Lajla> But "String" + "string" in syntax would produce an ordered pair ('s', "string")
07:39:03 <Lajla> Philippa, numbers are functions
07:39:38 <Lajla> But if you want to continue this, could you make it private, I feel self-absorbed because of this.
07:40:04 <Philippa> no, I'm satisfied you've not got a counterexample to my point about high-level
07:42:01 <Philippa> you've just dodged it with numbers by only having one type of number, which won't be so fun for anyone who has to build their own flavour of number
07:43:11 <hpaste>  . (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24878
07:43:44 <Philippa> nice try, whoever just tried to exploit hpaste
07:43:55 <xerox> hahaha
07:44:18 <dankna> hahaha
07:46:00 * Axman6 modifies it
07:46:26 <MadHatterDude> How do I get the time as an Int (like C's time())?
07:47:50 <ClaudiusMaximus> @hoogle epoch
07:47:50 <lambdabot> System.Posix.Types type EpochTime = CTime
07:47:50 <lambdabot> Data.Time.Clock.TAI taiEpoch :: AbsoluteTime
07:47:56 <quicksilver> MadHatterDude: that's not a very portable thing to want :)
07:48:21 <Axman6> @hoogle CTime
07:48:21 <lambdabot> Foreign.C.Types data CTime
07:48:21 <lambdabot> Data.Time.Clock addUTCTime :: NominalDiffTime -> UTCTime -> UTCTime
07:48:22 <lambdabot> Data.Time.Clock diffUTCTime :: UTCTime -> UTCTime -> NominalDiffTime
07:48:34 <Lajla> Philippa, if you say so, I'm actually quite sure you have no idea of the language, which is a reasonable assumption seeing you never heard of it before five minutes ago most likely. It's extremely high level for the simple reason that no constant in it has any machine-repraesentation and its machine repraesentation is also irrelevant tot he funcitoning of the language.
07:48:38 <BONUS> sigh, time is so complicated
07:48:44 * quicksilver recommends getCurrentTime unless you have a very good reason not to use it.
07:48:56 <quicksilver> (it's not a simple Int like C's time() as requested though)
07:49:02 <MadHatterDude> quicksilver: I need a seed for a StdGen
07:49:04 <Philippa> Lajla: that has /nothing/ to do with the Perlis definition of high-level, which it seems you're unfamiliar with
07:49:11 <EvanR-work> Lajla: sounds like haskell without the machine oriented types
07:49:48 <quicksilver> MadHatterDude: there are standard routines which pick a reasonable seed for a StdGen
07:49:57 <MadHatterDude> quicksilver: which are?
07:50:48 <EvanR-work> time is pretty crappy way to securely seed
07:51:13 <EvanR-work> and if you simply want different sequence on each run, then store the state of the generator when program closes and reload
07:51:15 <quicksilver> MadHatterDude: newStdGen
07:51:29 <quicksilver> or just getStdGen
07:51:33 <quicksilver> if you only need the one
07:51:47 <MadHatterDude> EvanR-work: Its for evolutionary algo's, security is not of the essence
07:52:33 <EvanR-work> then just use one generator
07:52:37 <EvanR-work> and never reseed
07:52:41 <EvanR-work> start with whatever you want
07:52:54 <hpaste>  . (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24880
07:53:03 <Lajla> Philippa, I am, I'm just saying you can't know it because you don't know the language, note that I've never claimed a thing about Perlis, I'm just saying that it's high level, which is usually understood as far removed from the machine.
07:53:46 <mreh> "No instances for (IArray UArray a, MArray IOUArray a IO)" -- does this mean it cannot resolve the 'a' into a type?
07:54:39 <Philippa> like I said, you don't know the Perlis definition - which is that a programming language is high level when its programs don't have to specify things that are irrelevant to what they're about
07:54:49 <Philippa> by that definition, Haskell isn't always high-level
07:55:18 <Philippa> and aside from a few machine-level types which are frankly there for when it /is/ relevant, Haskell's about as high-level in the removed-from-the-machine sense as they come
07:55:21 <quicksilver> mreh: yes, there are only UArray instances for particular concrete types, so you must have failed to specify the one you want or something
07:55:50 <Philippa> now, if you'd bothered to ask for or look up the Perlis definition, you would've realised my point was something other than what you seem to've taken it to be quite some time ago
07:56:38 <siracusa> Referring to package spoon, why are functions for catching errors called spoon and teaspoon? :-)
07:56:41 <mreh> MadHatterDude: GA or GP?
07:56:53 <Philippa> incidentally, one of Haskell's best features is the ability to use type info to work out what you actually meant in a reasonably well-structured manner, using type classes
07:57:29 <mreh> quicksilver: I don't want to specify the one I want :(
07:57:49 <MadHatterDude> mreh: The "Methinks this is a weasel" example
07:58:17 <mreh> MadHatterDude: ah, the decidely un-darwinian example
07:58:33 <MadHatterDude> mreh: ?
07:58:36 <quicksilver> mreh: then you don't have to
07:58:56 <quicksilver> mreh: perhaps you are a victim of the dreaded monomorphism restriction and you just need to give your top-level definitions a full type
07:58:57 <Lajla> Philippa, I already gatered that, but that's not the point of the language, the entire point is that a record is not 'a record' but rather some translation scheme which takes a certain input and produces a certain output dependend on that input.
07:58:59 <quicksilver> (including contexts)
07:59:08 <Lajla> And that it is thus not irrelevant.
07:59:21 <mreh> quicksilver: could it be because I've used the result in a context that demands it, without me being fully aware of it?
07:59:54 <Philippa> Lajla: "it is thus not irrelevant" is a pretty religious statement on your part when all someone wanted was a record. If they have to care what a record actually is in your language, it's stopped being high-level
08:00:35 <Philippa> it might be conceptually elegant, it might be very much removed from the machine, but it's not high-level in the Perlis sense
08:00:50 <quicksilver> mreh: I don't think so, although I'm not quite sure what you mean. YOu might have to paste some code.
08:01:01 <Philippa> and the thing is, that's pretty much inherent in what you said about what you want from the language
08:01:02 <Lajla> Well, maybe, but the idea of the language is that it's not very much well applied if all you want is 'a record'.
08:01:03 <mreh> quicksilver: okay
08:01:37 <Lajla> Philippa, it is? I made the language because I wanted to be concerned with what things do opposed to what they conceptually 'are'.
08:01:39 <Philippa> yes. That's fine. Go, enjoy. Just don't be shocked when someone else prefers to look for something that's higher-level per Perlis
08:01:46 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24881#a24881
08:01:46 <hpaste>  . (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24881
08:01:50 <mreh> quicksilver ^
08:01:58 <mreh> uhh
08:02:09 <mreh> we have an hpaste bot, cool
08:02:28 <Philippa> Lajla: same difference, tbh. But if you have to be concerned with the specifics of what it does as opposed to whether it meets some interface? Yep, you've hit that point again
08:02:46 <Lajla> Philippa, I wouldn't be surprised, as I said before, I mainly made it for myself and I realize not a lot of people would find it intuitive to work, I also meant high-level from the start as in dinstanced from the machine, though I should have looked up when you first mention ed perlis as I then still assumed you meant the word high-level in the standard sense.
08:02:50 <Philippa> the high-level question would be "what does it mean?"
08:03:05 <Lajla> Philippa, exactly,
08:03:09 <Lajla> I want to not be concerned with that.
08:03:11 <hpaste>  War And Peices (mreh)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24882
08:03:14 <mreh> :D
08:03:29 <Lajla> Only what it does.
08:04:32 <Philippa> right. Seriously high-level code has to be committed to the idea that what it does on the inside is, modulo any specific concerns you have, irrelevant. Not just what does it do, but what does it do that I care about?
08:05:50 <Lajla> Philippa, well, that is your philosophy and that of most people, but I find it annoying to work that way, as I said, I expect many people to find my approach and this language to work extremely counter-intuitive, I designed it for the same reasona ny person would design a programming language, because all the existing languages 'just aren't it for myself'
08:06:11 <Philippa> *nod*
08:06:53 <Philippa> people around here tend to care about the Perlis definition, FWIW. It's the only one I've seen that makes sense when you want to push higher-level than C or C-without-machine-specific-types
08:07:36 <Lajla> Philippa, I can understand that it works better like that for most people yes.
08:07:55 <Philippa> your goal isn't higher-level programming, that's fine
08:08:22 <Philippa> incidentally, Haskell has plenty of problems of its own with record encoding!
08:08:57 <Lajla> Well, not in perlis definition indeed, I found the term 'high level' a bit abstract always, I praefer 'high level with respect to another language' myself, like with respect to assembly.
08:09:26 <MadHatterDude> yay, got to "Methinks this is a weasel" in only 74 generations
08:10:07 <Philippa> I find the highest level languages tend to make good metalanguages. They let you encode the lower-level languages in them and work in those terms when you do care about something
08:10:19 <Philippa> which is good, because there's usually some detail of the machines we work with that we care about
08:11:20 <MadHatterDude> Wtf?
08:11:24 <Philippa> you end up valuing static typing pretty fast when you work that way though, because the only way you're going to avoid a pile of bugs is to engineer thoroughly
08:11:53 <Null-A> Are there imperative languages with a type system like haskell?
08:12:14 <Philippa> depends on the value of "imperative" and "like haskell". The ML family and Scala are worth a look
08:12:17 <Cale> Null-A: Haskell ;)
08:12:27 <Philippa> OTOH, Haskell's a pretty good imperative language once you get over the fear of monads
08:12:41 <Lajla> Philippa, I guess strong typing makes bug finding eaiser yes.
08:12:44 <Philippa> indeed, because it /has/ monads, it makes it a lot easier to type some surprisingly complex properties about imperative behaviour
08:13:05 <Lajla> static typing*
08:13:26 <Philippa> in the limit, it makes it possible to eliminate bugs entirely
08:13:35 <zygoloid> Philippa: i can't agree with that. haskell doesn't support deep inplace updates without using an IORef, and IORefs aren't cheap enough for haskell to qualify as 'pretty good' in my opinion ;-)
08:13:36 <Lajla> In my language though, I do believe the difference is irrelevant since it only has constants.
08:13:40 <Philippa> at that point, static typing and theorem proving are basically the same thing
08:13:43 <Lajla> I guess that's true too.
08:14:06 <arcatan> OCaml!
08:15:07 <Philippa> actually there's such a thing as a statically-typed point-free language
08:15:53 <Philippa> which is to say: you don't need variables to have static types, a combinator language can have them too
08:17:15 <jmcarthur> http://www.reddit.com/r/programming/comments/bqb5i/does_it_make_sense_to_learn_c_today/c0o15vo
08:17:32 <Lajla> Philippa, are we talking about type as in, a restriction of what may be applied to what, id est, a thing that can generate type errors?
08:18:08 <Philippa> yes
08:18:10 <Null-A> I find haskell a little awkward, when there's a lot of state that I need to pass around continuously, like a database handle. Whereas in OOP, I would just make this a member variable. Is there something I can do in haskell similar to this?
08:18:34 <Twey> Null-A: Many things
08:18:35 <Lor_> Monads.
08:18:43 <Twey> A State monad, for example
08:18:45 <Cale> Null-A: If you have lots of parameters that you find you're just passing around, you can group them into a single parameter which is a record
08:18:54 <BONUS> reader monad
08:18:58 <Philippa> I've seen type systems that can assign types to the SK calculus, and which are "obviously" extendable to SK + some datatypes with associated operations
08:19:00 <jmcarthur> make a record, make a state/reader monad
08:19:18 <Null-A> *nods* right, I recall seeing something like this
08:19:20 <Cale> You *can* use particular monads to help fix the problem, but usually that's overkill. Save it for when you have a real abstraction.
08:19:34 <Lor_> Philippa, I think the type system (minimal logic) came _before_ the computational interpretation.
08:19:41 <Philippa> Lor_: right
08:20:00 <Cale> Parameter passing usually really isn't that bad if you manage it in a reasonable way.
08:20:15 <Philippa> eh, personally I find it worth using a monad to abstract out the patterns anyway
08:20:33 <Philippa> it eliminates a whole class of bug where you accidentally pass the wrong thing somewhere
08:21:08 <jmcarthur> i find that putting state in a monad *causes* me to discover an abstraction boundary
08:21:19 <aavogt> is there an antimonad page on the wiki then?
08:21:36 <jmcarthur> and then i can put all the functions that use the state in one module and not export the guts of the monad
08:21:48 <Null-A> What about data structures, like massive trees with hundreds of children nodes, that you wish to mutate in a purely functional manner. Which I assume would mean duplicating the immutable tree in every aspect except your small change? (Wouldn't this perform poorly)
08:21:51 <Philippa> but I recommend using a record and perhaps Reader or Writer if they make sense rather than using the ST monad with lots of STRefs
08:22:12 <zachk> null-a check out zippers
08:22:19 <Philippa> Null-A: actually you only have to duplicate those parts of the structure's spine that lead to the location of the change
08:22:23 <Null-A> actually, if there's a resource with a bunch of QA perf questions, I'd love to read it =)
08:22:38 <Cale> I also tend to think that you shouldn't necessarily set out to make everything into a monad. Monads are just one nice class of combinator libraries, and while it's nice if your library happens to be a monad, it doesn't tend to be the sort of thing I'd seriously distort things in order to obtain.
08:22:42 <jmcarthur> Null-A: you don't really duplicate things, in implementation
08:22:43 <Null-A> zachk: x thx
08:22:45 <Null-A> k*
08:23:04 <Philippa> Cale: I'm open to the idea that I should use the Reader/State/Writer applicatives more, FWIW
08:23:05 <Null-A> Philippa: isn't this still costly depending on the location of your change
08:23:07 <jmcarthur> Null-A: when you "modify" a pure value, you try to arrange things so that the new structure shares as much as possible with the old
08:23:29 <Philippa> Null-A: yeah, but with good structure design it's a log cost rather than anything nastier
08:23:41 <Cale> Null-A: With immutable trees, you don't have to copy the subtrees which don't contain the thing that you're modifying. You simply refer to them.
08:24:21 <Cale> So the only thing that you have to "copy" (not really, since it's actually the only thing which isn't the same), is the path from the root down to the change.
08:24:21 <Null-A> *nods* still it seems like it'd be more efficient if I used mutable data, right?
08:24:51 <kmc_> Null-A, you can use mutable data in Haskell when you really need to
08:24:53 <Cale> Often the potential for mutation forces you to copy whole structures too.
08:25:08 <jmcarthur> only in rare cases do i feel like i can benefit from mutation
08:25:11 <kmc_> and there's a way to take a computation using mutable state internally and convert it to a pure function
08:25:27 <Cale> With mutable structures, you have to make copies to avoid aliasing problems
08:25:30 <jmcarthur> and in those cases, well, we can do mutation too :)
08:25:31 <kevinulin> kmc you are a robot
08:25:36 <Apocalisp> @djinn (s, k -> Maybe v) -> k -> (s,v)
08:25:37 <lambdabot> -- f cannot be realized.
08:25:40 <kmc_> kevinulin, yes
08:25:41 <Apocalisp> drat
08:25:44 <kmc_> Null-A, the sharing in immutable data is really nice
08:25:56 <Null-A> kmc_: You can write an implementation like this, but avoid having to declare the function a monad?
08:26:07 <kmc_> Null-A, there's this function
08:26:08 <kmc_> :t runST
08:26:09 <lambdabot> forall a. (forall s. ST s a) -> a
08:26:15 <kmc_> which takes "ST monad actions" and returns pure values
08:26:29 <Null-A> that's cool =)
08:26:31 <kmc_> it uses some type system trickery to ensure that the ST monad action is a "closed universe" of mutable state
08:26:33 <Apocalisp> @djinn (s, k -> v) -> k -> (s,v)
08:26:34 <lambdabot> f (a, b) c = (a, b c)
08:26:41 <kmc_> that is, it doesn't reference anything outside of what's being run
08:26:49 * Philippa heads off
08:27:07 <kmc_> as for "declare a function in a monad"... that's not really how it works
08:27:14 <kmc_> monads are not tags that we attach to functions to mark them as impure
08:27:29 <jmcarthur> yeah that's a very common misconception
08:27:52 <kmc_> that model works to a point, but it captures a very limited subset of what's really possible
08:27:59 <Cale> Probably the most useful view of monads from a programmers perspective is that they're just combinator libraries which support a given API.
08:28:06 <Null-A> *nods*
08:28:14 <kmc_> Cale, and "combinators" are like burritos, right? ;)
08:28:20 <Cale> No.
08:28:39 <Lor_> But to understand the API you'd have to understand CPS.
08:28:59 <jmcarthur> monads are return and (<=<), and that's it :)
08:29:11 <Cale> A combinator library is a library which defines some set of primitive computations, together with a set of functions which combine simpler computations into more complex ones, making it somewhat similar to a small embedded programming language.
08:29:18 <Lor_> :t (<=<)
08:29:18 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
08:29:47 <Lor_> Ah, the kleisli arrow composition, reversed.
08:29:57 <jmcarthur> no, unreversed :P
08:30:01 <Null-A> Couldn't the GHC make clever optimizations have the runtime costs of Tree mutations be equivalent with the functional method of managing tree structures? does it?
08:30:03 <jmcarthur> >=> is reversed ;)
08:30:18 <Null-A> optimizations which make the runtime*
08:30:21 <kmc_> Null-A, can you be more specific?
08:30:23 <Twey> > flip (id ***) (2, succ) 3
08:30:24 <lambdabot>   No instance for (GHC.Num.Num ((a -> a) -> c'))
08:30:24 <lambdabot>    arising from the literal ...
08:30:33 <Cale> Null-A: I'm not sure I understand the question...
08:30:46 <Cale> Null-A: The compiler has more guarantees that it can use with immutable structures.
08:31:04 <Null-A> so if you change a leaf node, you said you have to the 'copy' all the way from the root to the leaf, and someone mentioned log complexity of the operation?
08:31:06 <aavogt> Null-A: that ghc will use destructive updates when it can figure out that you never use the older version?
08:31:11 <kmc_> zygoloid, what's the cost of an IORef?
08:31:17 <Cale> Null-A: Yes?
08:31:27 <Null-A> but obviously managing a tree with mutable state, and changing the state at a particular leaf node is O(1)
08:31:35 <kmc_> Null-A, but then the old state is gone
08:31:41 <kmc_> and another thread that was using that state is fuxored
08:31:42 <Null-A> yes.. that's the intention
08:31:48 <fasta> Null-A, that's not completely true.
08:31:50 <jmcarthur> Null-A: it's still O(log n) to get to the leaf node, even with mutation
08:31:51 <Cale> Null-A: That's normal though. Really, even memory access can't be better than O(log n), but we ignore the complexity of most things which are implemented in hardware
08:31:54 <kmc_> when your structures are immutable, you don't need to lock them
08:32:09 <Null-A> jmcarthur: maybe you have a reference to it already
08:32:12 <fasta> Null-A, the garbage collector can destroy that O(1).
08:32:17 <Lor_> Well, there's still internal mutation in the implementation...
08:32:25 <jmcarthur> Null-A: then in that case mutation is O(1), yes
08:32:44 <Null-A> If you care about thread safe tree structures sure... but for many programmers that's not a necessity
08:33:22 <jmcarthur> Null-A: parallel-safe structures are the core of purely functional programming
08:33:31 <Cale> Null-A: It's nice because in Haskell, we can have a primitive operation for computing things in parallel which has trivial semantics (it doesn't change the meaning of any program you add it to)
08:34:10 <Cale> Null-A: In particular, (par x y) is an expression which adds x to a queue of expressions to be evaluated on some processor if there is time available, before resulting in y.
08:34:33 <hpc> :t par
08:34:34 <Null-A> Except this doesn't seem to translate so easily to distributed systems? if you're algorithm's state is distributed across several nodes, you have to implement all the operations in terms of monads again since you're using networking features
08:34:34 <lambdabot> forall a b. a -> b -> b
08:34:47 <Null-A> I totally get the benefits for multi core parallel programming though
08:34:48 <Cale> Null-A: That is true, for now.
08:35:21 <Cale> Null-A: But maybe not in the future. The data parallel Haskell stuff looks like it might generalise to distributed computation.
08:35:23 <Null-A> theoritically the haskell runtime could abstract away distributed systems programming, but this seems like 10+ years off in the future if ever
08:35:24 <hpc> doesn't GHC do multithreading optimizations automatically?
08:35:32 <jmcarthur> we will not have a good story for distributed computing until we decide to work with a stricter definition of referential transparency
08:35:38 <Cale> hpc: No, you need to annotate
08:36:39 <Cale> hpc: Automatic parallelisation is hard, but it's easy to include some simple operations where the programmer can inform the compiler how to parallelise.
08:36:51 <kmc_> Null-A, you can have a distributed computing system which is *implemented* with effects but which presents a pure interface
08:36:54 <hpc> ah
08:36:59 <Cale> Null-A: It's also worth pointing out that in distributed computation, it's going to be even more important that things are immutable.
08:37:35 <Lor_> What's the status of dph nowadays?
08:37:47 <Cale> Because the potential for race conditions affecting the results of computations increases even more.
08:37:49 <kmc_> the fact that you're using networking features to do distributed computation should ideally be no more visible than the fact that you're using the memory controller to do ordinary computation
08:37:56 <kmc_> after all, both involve talking to very stateful hardware
08:37:57 <Lor_> It's been "not quite ready" for ages now.
08:38:21 <kmc_> but Haskell effectively abstracts the first
08:38:35 <kmc_> err second
08:38:39 <kmc_> and with lots and lots of work by very smart people, some day we will abstract the first
08:38:42 <Cale> Lor_: I heard that in 6.12 it's sort of usable? I'm not sure since I haven't tried 6.12 yet.
08:39:09 <Lor_> The manual still says the same as it did for 6.10, "unstable technology preview"
08:39:17 <Cale> Well, that is still true
08:40:23 <Null-A> kmc_: ideally sure, but realistically you have to account for properties of distributed systems in your algorithms, it's incredible difficult for the compiler to make all the right choices on what to do about errors, dead nodes, unresponsive nodes, geographical location of nodes, etc for optimal performance
08:41:38 <Cale> There were serious problems at first, even once the problems with how nested data parallelism was going to work alongside the rest of Haskell's features were hammered out, since it pushes the simplifier harder than any other feature of the language -- essentially every function gets a vectorised and non-vectorised version, and every time you pass functions around, you're passing pairs of functions and so on, and the si
08:41:38 <Cale> mplifier was expected to clean up the mess :)
08:41:56 <Cale> So, it triggered a lot of performance bugs in the compiler at first, and they've been clearing those up.
08:43:15 <Cale> Null-A: Yes, it's tricky in general, but the compiler doesn't have to do everything on its own. It just needs strong hints on how it would be effective to parallelise and distribute things.
08:43:35 <Null-A> that's a good point
08:43:41 <gwern> hm. I wonder if there are any visual assembler editors; assembler would actually work very well, since there's only a few fixed registers and bits of the environment, and it's much clearer how to step through than something like haskell
08:44:16 <Cale> Null-A: Rather than details of exactly what to communicate between machines, you might be able to get away with working at the level of operations on collections of data which are automatically flattened out and parallelised/distributed.
08:44:35 <gwern> (8 or 16 registers would fit easily in 8 or 16 little graphical boxes, and similarly the numbers they contain)
08:45:22 <Null-A> I suppose we need to wait for distributed systems programming to 'stabilize' on common abstractions techniques like mapreduce, distributed hash tables, or sql. Before some sort of 'hinting' technique can be developed that won't need to be updated every year
08:46:11 <Lor_> cale, right, thanks for the summary
08:46:25 <Cale> Well, in this case, I'm thinking you'd let GHC handle which communication protocol it was going to use, and run the same program on multiple nodes.
08:46:46 <FliPPeh_> @hpaste
08:46:47 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
08:46:47 <Null-A> that's like erlang sort of
08:47:09 <Cale> Instead, from your perspective, you'd use a particular datastructure to indicate that you'd like the computations over that structure to be distributed.
08:47:23 <FliPPeh_> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=10011#a10011
08:47:23 <Cale> Data Parallel Haskell defines something called a parallel array.
08:47:28 <FliPPeh_> Any way to put this into a foldr?
08:47:37 <Cale> You can have parallel arrays of arbitrary Haskell values, including other parallel arrays
08:48:27 <Cale> Computations on parallel arrays, even ones which are nested are automatically flattened out into computations on single arrays (plus arrays of indices), and then distributed evenly onto available processing units.
08:49:10 <Cale> Of course, with the latency introduced in a distributed system, you'd have an additional problem to tackle, but at least it's *somewhat* reasonable that it might be possible to do automatically.
08:49:25 <Lor_> FliPPeh_, yes, but the result would be horrible
08:49:30 <Cale> (maybe with a little extra information about how you want things split up)
08:50:06 <Null-A> So in this new compiler, would it ship with massive distributed data structures? it's own implementation of bigtable, gfs, etc
08:50:24 <FliPPeh_> Lor_: Any other kind of fold? Or is it just not suitable for folds?
08:50:45 <Twey> FliPPeh_: It's okay, but you have to pattern-match anyway
08:50:50 <FliPPeh_> Okay :)
08:51:01 <Twey> So you might as well have multiple equations and do the direct recursion
08:51:08 <FliPPeh_> I'm always tempted to first try standard functions before getting my own recursions done
08:51:11 <Cale> Well, possibly. At the basic level (the only job for the compiler writers), you'd have a type of distributed array structure, and libraries could build further abstractions in terms of that.
08:51:15 <Twey> You'd need mutual recursion to deal with taking the first two elements anyway, I think
08:51:58 <hpc> the way you do it now is tail-recursive anyway, so you won't get any speedup
08:51:59 <Null-A> Cale: *nods* there would probably need to be some way for 'hints' to be passed down into the low level distributed array structure implementation
08:52:04 <FliPPeh_> Well, but it least it works :)
08:52:16 <FliPPeh_> My own "%x" replacements
08:52:44 <Cale> Null-A: Yeah. Currently with SMP we have reasonably high memory bandwidth and so the fact that you're using a parallel array seems to be enough of a hint to split things up evenly.
08:53:32 <jmcarthur> i can't wait for accelerate to get the GPU backend
08:53:33 <Cale> Null-A: In a distributed implementation, you'd probably want the program to do some benchmarking as each node was connected, and split tasks up according to latency.
08:53:42 <jmcarthur> if that's even still being worked on
08:54:33 <Null-A> Cale: well probably the task splitter needs to be abstracted too, there's all kinds of ways you could implement this
08:54:41 <Null-A> Cale: network topology could be changing often too
08:55:11 <EvanR-work> how do i make a 'default case' with a case expression
08:55:14 <EvanR-work> pattern _ ?
08:55:22 <Cale> EvanR-work: yes
08:55:26 <EvanR-work> not otherwise?
08:55:36 <Cale> otherwise would be a variable name
08:55:39 <c_wraith> > otherwise
08:55:40 <lambdabot>   True
08:55:46 <EvanR-work> >_>
08:55:50 <Botje> EvanR-work: otherwise would work as well
08:56:03 <Twey> No it wouldn't
08:56:05 <Cale> It'd work, but you'd shadow the Prelude definition of otherwise, which is ugly
08:56:06 <Botje> it would bind whatever value there is to otherwise, though
08:56:09 <kmc_> @src otherwise
08:56:09 <lambdabot> otherwise = True
08:56:12 <Twey> Oh, well, yes
08:56:15 <kmc_> it's an ordinary bool
08:56:20 <kmc_> not a keyword
08:56:25 <EvanR-work> so it wouldnt work if my case is using numbers
08:56:26 <c_wraith> otherwise is just for guards on a pattern match, as a "catch everything else that matched this pattern" case
08:56:29 <Twey> kmc_: So it would be bound
08:56:30 <kmc_> which is why you say "| otherwise" in guards
08:56:31 <EvanR-work> ah
08:56:32 <Botje> EvanR-work: sure it would :)
08:56:33 <EvanR-work> guards
08:56:34 <kmc_> that's just "| True"
08:56:42 <kmc_> i.e. an always succeeding guard
08:56:43 <Botje> > case 42 of otherwise -> ()
08:56:44 <lambdabot>   ()
08:56:53 <Cale> EvanR-work: Well, it'd work, but if you used 'otherwise' inside that branch of the case, it wouldn't refer to True anymore
08:56:53 <EvanR-work> i dont get that
08:57:05 <kmc_> > case 42 of x -> ()
08:57:06 <lambdabot>   ()
08:57:08 <Cale> > case 42 of otherwise -> otherwise
08:57:09 <lambdabot>   42
08:57:14 <Cale> > case 42 of otherwise -> otherwise^2
08:57:15 <Botje> EvanR-work: use _ instead of otherwise and you'll be fine.
08:57:15 <kmc_> > case 42 of x -> x
08:57:16 <lambdabot>   1764
08:57:16 <lambdabot>   42
08:57:16 <Twey> > case 42 of otherwise | otherwise -> ()
08:57:17 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
08:57:17 <lambdabot>    arising from the literal `42...
08:57:18 <Botje> it's shorter, too
08:57:21 <EvanR-work> oh oh. a variable name pattern, always works
08:57:28 <Cale> right
08:57:37 <EvanR-work> so otherwise is a trick
08:57:41 <EvanR-work> unless its a guard
08:57:45 <kmc_> it's a trick as a guard
08:57:51 <kmc_> and that's really the only case to use it
08:57:52 <Cale> Yeah, stay away from shadowing prelude names.
08:59:38 <Cale> Null-A: While it's true that things can be complicated, you'd want something which would "just work" in most cases, even if it didn't deliver absolutely optimal performance.
09:00:05 <Cale> Of course, you want some kind of speedup, and as close to linear in the linear cases as possible.
09:00:35 <fasta> Null-A, what do you expect to find in Haskell?
09:01:39 <Null-A> Cale: Well, it depends what your business goals are. Because once you start scaling to hundreds of machines, the cost to hire skilled c++ programmers is cheaper than the cost of using a nice layer of abstraction, even if the loss of performance is only 10%
09:02:32 <Cale> Programmers that can write efficient and correct distributed code are pretty expensive compared to most hardware...
09:02:38 <Null-A> Cale: Anyone who's building a distributed system is probably considering a scale of this magnitude. Of course if you have other concerns like correctness, then no amount of c++ skill can make the level of guarantee of haskell i would argue
09:02:52 <Null-A> fasta: huh?
09:03:20 <fasta> Null-A, isn't that a valid question?
09:03:30 <Cale> Of course you have to consider correctness. You're not going to build a large system just so that it can fail and give you junk results :)
09:03:40 <fasta> Null-A, you are in #haskell, and you are arguing about whether Haskell is useful or not basically, no?
09:03:57 <Null-A> Cale: when you're talking about the scale of google at least, they'll easily hire dozens of programmers to make marginal improvements to the linux kernel because this translates to millions of saved dollars
09:04:09 <fasta> Null-A, if you create a really big system you probably write your own compiler.
09:04:42 <Null-A> fasta: we're talking about pros/cons of a compiler which abstracts away distributed systems implementations
09:05:15 <Null-A> fasta: Well I think google wrote some compilers for a more specific case, sawzall for mapreduce problems
09:05:16 <Cale> Almost any sort of system with *really* special needs, the very large distributed systems, and the very small embedded ones in particular, are good targets for writing special-purpose compilers.
09:05:21 <fasta> Null-A, ok, well, in a distributed system there is no perfect abstraction until AI is developed.
09:05:23 <hpc> i think this would be better off as a library, than a compiler step
09:05:31 <Null-A> but I'm pretty sure they haven't built a compiler which abstracts away the majority of their distributed systems problems
09:05:41 <Null-A> fasta: can you elaborate?
09:05:42 <fasta> Null-A, so, it is not the place for anything the compiler can do.
09:06:04 <Cale> hpc: There's an extent to which it makes sense as a library, but the compiler has more power to transform code and flatten out computations in a way that you'd need to.
09:06:40 <Cale> fasta: I tend to think that the DPH stuff will generalise to at least some extent.
09:07:06 <fasta> Null-A, basically, in a distributed system you send a message and then after an undefined amount of time it might come back depending on assumptions.
09:07:24 <fasta> Null-A, if there are no assumptions some things are simply impossible.
09:07:54 <EvanR-work> are bang patterns a nice/good/easy/recommended way to make something strict
09:08:02 <hpc> yes
09:08:06 <fasta> Null-A, if you have instead mobile agents, that can destroy each other when a process appears to be crashed, then you can do easy detection of whether a process has crashed or not.
09:08:17 <Cale> Particularly for embarrassingly parallel computations (like linear algebra), I think a DPH-style system for distributed computing might actually work reasonably well.
09:08:26 <hpc> although, depending on what you are calculating, it might already be strict anyway
09:08:36 <fasta> Linear algebra is not embarrassingly parallel.
09:08:47 <Cale> fasta: Things like inner products are :)
09:08:53 <fasta> It is just if you use specific algorithms.
09:08:56 <fasta> Cale, heh.
09:09:05 <fasta> Cale, I was thinking of matrix multiplications.
09:09:15 <Cale> Matrix multiplications are just a bunch of inner products
09:09:25 <fasta> You can do them in different ways.
09:09:29 <Cale> Well, yes :)
09:09:42 <fasta> For n -> infinity those ways are more efficient.
09:09:43 <Cale> and often you want to avoid them altogether, if your matrix is very large
09:10:03 <Null-A> fasta: it's okay to make assumptions, it's just in abstractions of distributed systems, there's the tendency to assume hundreds of things abouth network topology, machine capabilities, etc
09:11:06 <Null-A> if haskell were to abstract it, this would be a massive win for correctness though
09:11:27 <Null-A> it's so difficult to debug, and guarantee correctness in large systems
09:12:16 <EvanR-work> i tried to make a network game where i had guarantees that each player definitely knew the other players had gotten his commands, i think ran into a logical impossibility on that one ;)
09:12:26 <Cale> I'm personally rather happy that we seem to be moving in the direction of extremely parallel architectures, because we have answers which seem to work reasonably well for that. :) For distributed computation though, everything is that much harder.
09:12:37 <Null-A> even simple things like writing an algorithm to sort integers can subtle introduce bugs
09:12:52 <Cale> Null-A: You should see quicksort in DPH :)
09:13:17 <Null-A> Distributed parallel hashtable?
09:13:27 <burp> haskell
09:13:27 <Cale> O(log(n)) time complexity with infinite processors, and it looks not much different from the normal quicksort
09:13:33 <c_wraith> data-parallel haskell
09:13:41 <Null-A> k
09:14:33 <Null-A> Cale: the HS file is massive? http://www.macs.hw.ac.uk/~dsg/gph/nofib/
09:14:55 <Null-A> oh wait that's the strategies file
09:15:12 <Null-A> which is what exactly?
09:15:25 <Null-A> The actual quicksort algorithm is tiny XD
09:15:58 <Null-A> very cool
09:16:18 <Cale> oh, that's really old stuff
09:17:02 <Cale> You can use that way of doing things in GHC today
09:17:45 <Cale> But it doesn't get logarithmic performance because of the fact that it's working with lists
09:18:29 <EvanR-work> im getting an error with hdbc mysql backend, wondering if anyone seen this before Row retrieval was canceled by mysql_stmt_close() call
09:19:12 <EvanR-work> hdbc doesnt let you directly close statements, so i dont know what i can do about this
09:19:44 <Cale> EvanR-work: hmm... hpaste the code and I'll take a look, but I haven't really used that library so much
09:20:04 <EvanR-work> not sure in which of two (or three places) the error happens
09:20:12 <EvanR-work> ill put all three
09:21:47 <EvanR-work> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24883#a24883
09:21:49 <hpaste>  . (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24883
09:22:12 <EvanR-work> relevant functions, getEmailRecord, updateStatus, and isJobDone
09:24:14 * ManateeLazyCat pasted "Show PageTypeWrap." at http://paste2.org/get/771745
09:24:14 <ManateeLazyCat> Can you read class back? Above code just `show` PageTypeWrap`, i want `instance Read PageTypeWrap`.
09:25:30 <hpaste>  dph quicksort (Cale)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24884
09:25:32 <Cale> Null-A: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24884#a24884
09:25:41 <Cale> oh, thankyou hpaste bot
09:26:04 <Null-A> heh
09:27:07 <Null-A> Cale: Yah  abstracting SMP parallelism seems like a no brainer
09:27:15 <Cale> Null-A: So there it is with data parallel arrays. Note the use of the yss array to specify that the sorting of subarrays of elements less and greater than the pivot should be done in parallel
09:28:37 <Cale> and this is magically flattened out and the work is balanced between your available processors, even when the tree of computation is unbalanced
09:28:41 <ManateeLazyCat> For "data PageTypeWrap = forall a . PageType a => PageTypeWrap a", `show` PageTypeWrap is easy: "show (PageTypeWrap a) = show a", but no idea how to `read` PageType.
09:29:06 <Null-A> Cale: are there any other languages that provide similar semantics?
09:29:27 <Cale> Null-A: An obscure research language called NESL
09:29:37 <Null-A> certainly not mainstream languages then
09:29:40 <Cale> Right.
09:29:55 <Null-A> Well, I hope haskell is the future then, because SMP certainly seems to be
09:29:56 <ManateeLazyCat> Have any idea that how to read polymorphism `a` in PageTypeWrap?
09:30:24 <Cale> Null-A: All these transformations crucially rely on immutability too.
09:30:59 <Cale> Well, not just immutability, but complete lack of effects, referential transparency.
09:31:10 <Cale> ManateeLazyCat: Normally you wouldn't.
09:31:20 <ManateeLazyCat> Cale: Trick?
09:31:27 <Cale> ManateeLazyCat: Unless you want to pick a specific type to read.
09:31:53 <Cale> ManateeLazyCat: Which parser should you use for the read values?
09:32:16 <ManateeLazyCat> Cale: I use `PageTypeWrap` wrap polymorphism `a` for type check, but my some code need read PageTypeWrap back.
09:32:45 <ManateeLazyCat> Cale: I use some code in dbus-core.
09:33:50 <Cale> EvanR-work: Where is withDatabase defined?
09:34:32 <ManateeLazyCat> Cale: I need use PageTypeWrap wrap polymorphism `PageType`, and transform `PageTypeWrap` to `Variant`, then dbus-core transform `Variant` to DBus, and DBus transform `Variant` to another process, in process, i need restore `Variant` to `PageTypeWrap`.
09:34:34 <Cale> ManateeLazyCat: Existential types are not magic. When you go to parse the values back, you need to choose a parser to read with.
09:34:37 <Saizan> ManateeLazyCat: the only way i've seen this solved is having a table of the possible wrapped types and put some tag in the serialization format to tell which parser to look up in the table
09:35:26 <Saizan> (or you could try all of them in-order, but that would probably be inefficient)
09:35:40 * ManateeLazyCat pasted "Original version." at http://paste2.org/get/771752
09:35:44 <ManateeLazyCat> Saizan: Above is original version.
09:36:01 <ManateeLazyCat> Saizan: If i build table, i prefer to use http://paste2.org/get/771752
09:36:20 <ManateeLazyCat> Saizan: Then use TH generate duplicate code.
09:36:37 <Saizan> a discriminated union is a nice alternative, yeah :)
09:37:20 <ManateeLazyCat> Saizan: I want use classtype instead `|`, but looks i can't read polymorphism type. :)
09:39:39 <Cale> EvanR-work: still here?
09:40:52 <EvanR-work> yeah
09:40:59 <EvanR-work> ill paste the database stuff
09:41:33 <Twey> Cale: What is lengthP?
09:41:39 <Cale> I'm just wondering if you're accidentally closing the connection somewhere...
09:41:40 <EvanR-work> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24885#a24885
09:41:45 <hpaste>  . (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24885
09:41:46 <Cale> Twey: length of a parallel array
09:41:49 <Null-A> :type lengthP
09:41:54 <Null-A> :t lengthP
09:41:55 <lambdabot> Not in scope: `lengthP'
09:41:57 <Twey> Oh
09:42:03 <EvanR-work> Cale: its not closing because i just put a handler to just retry after 1 second
09:42:05 <EvanR-work> and it works
09:42:08 <Cale> The bot doesn't have the dph libraries imported
09:42:09 <ManateeLazyCat> Thanks all, looks can't read back value in magic. :)
09:42:24 <Cale> EvanR-work: oh, weird.
09:46:40 <Cale> EvanR-work: It appears that the only place that the mysql driver for hdbc calls mysql_stmt_close is when a statement is garbage collected (it's in the finaliser for a ForeignPtr inside the Statement value.)
09:48:16 <EvanR-work> Cale: that would explain the randomly occuring error
09:49:05 <EvanR-work> Cale: so i should use some way of closing the statement when im done with it
09:49:41 <Cale> Well, the question is, how the heck are you trying to execute a statement that's already been GC'd?
09:50:16 <Cale> That should never happen.
09:50:27 <EvanR-work> well im not
09:50:31 <EvanR-work> i make a new one each time
09:50:38 <EvanR-work> question is what is hdbc doing
09:51:34 <Cale> I wonder if mysql doesn't like it when you close a *different* statement while trying to execute one.
09:51:39 <companion_cube> @djinn (Maybe a) -> a
09:51:39 <lambdabot> -- f cannot be realized.
09:51:55 <EvanR-work> Cale: probably
09:51:57 <Cale> That would certainly be stupid if true.
09:52:12 <EvanR-work> hdbc has finish :: Statement -> IO ()
09:52:31 <EvanR-work> 'abort of query' but i dont want to do that... at least not before committing
09:52:51 <EvanR-work> the error says 'fetch' so i dont intend on committing, and i already have the results
09:53:36 <Cale> EvanR-work: ah, yes, the driver explicitly calls finalizeForeignPtr when you finish the Statement
09:53:54 <Cale> Maybe you can finish once you've got the results back
09:53:59 <EvanR-work> ok
09:55:02 <EvanR-work> actually fetch is only a quick query
09:55:24 <EvanR-work> looks like i have to finish ... after i execute a statement directly..
09:55:36 <benmachine> @djinn ()
09:55:36 <lambdabot> f = ()
09:55:39 <Cale> (and stay away from the lazy fetchAllRows)
09:55:53 <EvanR-work> quickQuery' should be strict
09:56:00 <Cale> yeah
10:02:35 <EvanR-work> Cale: that fixed it
10:03:07 <EvanR-work> woulda been nice to show an example in the docs
10:04:05 <Cale> EvanR-work: It also shouldn't really be required, but I guess mysql is super picky about when you call various things.
10:06:04 <EvanR-work> can i show the os threads that my process is using
10:09:15 <EvanR-work> ps -T
10:19:13 <harlekin> I am try to parse time stamps from log files and compare them against localtime. How would I do that using Haskell?
10:19:45 <harlekin> If I use UTCTime, then I get the time wrong (no timezone), if I use ZonedTime, I cannot even compare two time values... \-: At least I don't know how.
10:21:00 <FliPPeh_> Gahh, Cicular Dependencies!
10:21:12 <FliPPeh_> Module A needs module B and module B needs module A!
10:21:15 <hpc> adjust the zoned time to UTC yourself, i would say
10:23:20 <harlekin> hpc, but I am reading local timestamps from the logs. I should read them as ZonedTime and then convert them to UTCTime?
10:23:36 <hpc> yeah
10:24:03 <hpc> or if you can change the way the times are logged, switch all logging to UTC
10:24:20 <zygoloid> FliPPeh_: sounds like you need a Module C!
10:24:23 <Jafet> Remember to find the bindings to your system's DST database
10:24:33 <FliPPeh_> zygoloid: Like a "Base" module defined the types?
10:24:37 <zygoloid> yeah
10:24:46 <FliPPeh_> Sounds Hackish
10:24:46 <harlekin> That both seems pretty inconvenient. My source code is about 4 lines and now I am almost doubling it to fit time conversion functions in it. \-:
10:24:52 <FliPPeh_> What what the heck, I'll do it!
10:24:56 <zygoloid> hooray!
10:25:35 <hpc> so, i have a datatype for mathematical expressions: http://dl.dropbox.com/u/37707/Data/Math/MathUtil.hs
10:25:52 <hpc> and i want to simplify it: http://dl.dropbox.com/u/37707/Data/Math/Simplify.hs
10:26:15 <hpc> my current solution works reasonably well, but i have run into a bit of a wall
10:26:47 <hpc> simplifying (x/x)/2 reduces to 0.5, but simplifying x/(2x) doesn't
10:27:22 <hpc> i have two possible approaches, one being to sort the tree somehow, so the data fits the patterns i want
10:27:30 <hpc> the other being to just add more pattern matches
10:27:43 <hpc> and i am having trouble determining which would be best
10:28:11 <Twey> (x / x) / 2  1 / 2  0.5; x / 2x  1 / 2  0.5
10:28:12 <enkrav> Hello, I have written a little program using CHP and in ghci it works fine by doing   :l prog.hs   and  main  . However, if I do ghc prog.hs  I get a lot of errors like (.text+0x4d): undefined reference to `chpzm2zi1zi0zi1_ControlziConcurrentziCHPziBase_zdfMonadCHP_closure'
10:28:14 <Twey> They're different cases
10:28:15 <Cale> hpc: Well, the problem is that you need to pull constants to the beginning of terms, yeah?
10:28:37 <enkrav> are there some compiler switches I forgot?
10:28:53 <Twey> The first is that x / x is always 1, by the laws of division; the second is that you can eliminate common factors from either side of a division
10:28:53 <arcatan> the problem with pattern route is that you might have to apply them several times and you have to be careful to make mutations stop (if you try to apply them until they stop)
10:28:57 <Cale> I would be tempted to do away with division and subtraction and instead define things in terms of negation and inversion
10:29:19 <hpc> i would do that, but this is intended to be human-readable
10:29:20 <arcatan> so I'd do some kind of normalization (the first way)
10:29:36 <hpc> i do that for differentiation though, to reduce the number of rules
10:29:38 <Cale> (and then put the divisions and subtraction back after simplifying)
10:29:50 <benmachine> enkrav: try --make
10:30:21 <enkrav> benmachine, thank you, it works
10:30:32 <benmachine> hpc: the intermediate bit doesn't need to be human readable, just the input and the output
10:30:49 <benmachine> so you transform into a simpler form and do whatever then untransform and tada
10:31:06 <hpc> i am worried the untransform to division will be ugly though
10:31:48 <Cale> hpc: Ensure that you have a rule in simplification which collects the inverted factors of each term
10:32:38 <Cale> Well, hmm.
10:33:01 <hpc> so, f / g would be f * (g ** -1)
10:33:28 <hpc> but say g is a constant
10:33:36 <hpc> i could end up with f*0.5
10:34:10 <hpc> or f*3.156471265
10:34:13 <lpsmith> preflex, seen bos
10:34:13 <preflex>  bos was last seen on #haskell 7 days, 21 hours, 1 minute and 50 seconds ago, saying: mightybyte: yeah, i saw your email. i'd have gotten to it some time in the next month or two :-(
10:34:25 <FliPPeh_> preflex, seen me
10:34:26 <preflex>  me was last seen on #gentoo 360 days, 10 hours, 27 minutes and 2 seconds ago, saying:  imagemagick maybe?
10:34:29 <FliPPeh_> :)
10:35:11 <lpsmith> Does attoparsec have a public hg repo somewhere?
10:35:13 <Cale> hpc: I suppose, if that's acceptable.
10:35:18 <hpc> i think im gonna go with moving constants to one side of the tree
10:35:42 <Cale> hpc: It might be nicer to avoid constructing non-integer values.
10:35:57 <Cale> But always push constants and their inverses to one side, yes.
10:36:34 <Cale> You probably shouldn't, for instance, "simplify" something like 2/3 to some approximate value like 0.666666
10:36:42 <hpc> if i push all movable constant terms to one side though, all my compound functions will be in terms of x only
10:36:50 <Cale> But these things are always rather subjective
10:37:06 <hpc> then i can simplify that, push any resulting constants out again, then simplify some more
10:38:02 <hpc> and if you are wondering about the Optimus in the data definition, it is for the differentiator
10:38:11 <hpc> derivative of Optimus is Optimus Prime
10:38:56 <FliPPeh_> :t OptimusPrime
10:38:57 <lambdabot> Not in scope: data constructor `OptimusPrime'
10:39:00 <FliPPeh_> :(
10:39:28 <hpc> and all the monadic stuff is for stored functions, like f(x) = 5x+2
10:39:39 <jlouis> My definition newtype Process a b c = Process (ReaderT a (StateT b IO) c)
10:39:47 <jlouis> argh, lets try again
10:40:50 <jlouis> My definition newtype Process a b c = Process (ReaderT a (StateT b IO) c) leaks memory in the StateT component, using mtl as the monad template library. It doesn't use the strict variant. Is there any way to solve this?
10:41:25 <jlouis> It also uses generalizednewtypederiving to get instances (Functor, Monad, MonadIO, MonadState b, MonadReader a)
10:41:42 <hpaste>  . (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24886
10:42:17 <jlouis> code is at http://github.com/jlouis/combinatorrent/blob/master/src/Process.hs and changing to use Control.Monad.State has little implication
10:43:03 <siracusa> Oh, we have a hpaste bot now!?
10:43:03 <c_wraith> jlouis, what is b in your tests?
10:43:44 <jlouis> c_wraith: worthy question, it is data ST = ST { hndl :: Handle } when I tried this
10:44:28 <hpaste>  . (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24887
10:44:36 <c_wraith> if the StateT portion is leaking memory, it's almost certainly because the state isn't being forced, and is holding on to thunks that won't release large structures until executed.
10:44:37 <jlouis> executing the equivalent of runStateT (runReaderT (forever $ return ()) c) st
10:44:45 <zygoloid> jlouis: i guess you're building up a thunk chain in the 'b'
10:45:07 <zygoloid> jlouis: but it sounds like you've solved it already.
10:45:12 <alpounet> is there an epsilon value for Float/Double somewhere ?
10:45:27 <jlouis> zygoloid: I never update the b
10:45:58 <jlouis> perhaps the derivation of MonadState does something like that to me without my knowledge
10:46:10 <c_wraith> huh.  You never update it?  If you never even access it, lazy state could do the same thing.
10:46:20 <zygoloid> /should/ do the same thing
10:46:40 <jlouis> hmm, I could even run with b = (), there is something to try!
10:47:15 <hpc> if you never access b, why use StateT?
10:47:48 <jlouis> hpc: oh, I read b, and more advanced processes update the b quite a lot
10:48:05 <hpc> oh, in this one function
10:49:05 <hpaste>  type inference confusion (mreh)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24888
10:49:08 <mreh> peep this
10:49:19 <glguy> whoa, hpaste bot is back
10:49:32 <jlouis> at least -hd says it is a closure, so unevaled thunks is a really good bet on the problem
10:49:42 <mreh> I can't it to compile without specifying a type for the value read from the wav file
10:50:12 <Saizan> mreh: right
10:50:15 <hpc> parsePCMFile has a nasty type signature
10:50:29 <mreh> hpc: it's not mine, it's in Codec.Wav
10:50:38 <mreh> @hoogle hcodec
10:50:39 <lambdabot> No results found
10:50:46 <mreh> @google HCodec
10:50:48 <lambdabot> http://hackage.haskell.org/package/HCodecs
10:50:48 <lambdabot> Title: HackageDB: HCodecs-0.2
10:51:10 <Saizan> mreh: what's the problem with specifying a type?
10:51:26 <trem> hello. i've run into what i think is a "space leak" problem... well, ultimately it's a lack-of-understanding problem. it's here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24887
10:51:36 <trem> this is the main function of my raytracing toy
10:51:43 <zygoloid> Saizan: well, presumably mreh wants parsePCMFile to be polymorphic
10:51:46 <mreh> Saizan: PCM files have different sampling rates
10:52:06 <trem> recently I added stochastic rendering, so i needed random numbers
10:52:17 <mreh> zygoloid, yes
10:52:20 <Saizan> zygoloid: well, it is polymorphic, but i see what you mean
10:52:35 <hpc> :t sequence
10:52:36 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
10:53:01 <trem> hpc: is that for me?
10:53:25 <Saizan> mreh: you can make the choice dynamically, but you still have to make it
10:53:27 <hpc> for me
10:53:43 <trem> :-)
10:53:44 <mreh> Saizan: dynamic typing in Haskullz?
10:54:04 <Saizan> mreh: no
10:54:05 <Jafet> Hasskillz
10:54:08 <zygoloid> Saizan: it is polymorphic but doesn't compile
10:54:18 <zygoloid> (at least i'm assuming the compile error goes with the code)
10:54:22 <mreh> yeah it doesn't compile
10:54:31 <mreh> that's the error I'm getting from GHC
10:54:31 <Saizan> zygoloid: the use of it without specifying a type doesn't compile.
10:54:42 <jlouis> interesting. Running the StateT with () doesn't help
10:54:47 <mreh> I don't specify types in code all the time
10:54:56 <mreh> I don't understand what makes this different really
10:55:13 <mreh> I'm confused!
10:55:15 <Saizan> the fact that the context doesn't provide any hint of what the type should be either.
10:55:19 <zygoloid> Saizan: oh i see. the line numbers not matching up confused me
10:55:23 <Saizan> you just read it and write it back
10:55:34 <trem> ...i'll just go on: before going stochastic it was like pathTracer :: Ray -> Scene -> (Float, Float, Float) -- pretty straightforward
10:55:45 <zygoloid> mreh: you need to say what type it is because there're many types which can be both produced by parsePCMFile and consumed by W.exportFile
10:55:46 <kamatsu> is there a point free way of writing:
10:55:46 <lambdabot> kamatsu: You have 1 new message. '/msg lambdabot @messages' to read it.
10:55:49 <Saizan> both functions are polymorphic, so they don't give any information on which concrete type to choose
10:55:49 <kamatsu>  sortBy (\x y -> compare (a x) (a y))
10:55:59 <benmachine> @src comparing
10:55:59 <lambdabot> Source not found. Maybe you made a typo?
10:56:07 <benmachine> :t comparing
10:56:08 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
10:56:08 <trem> now pathTracer rolls dice and is like that: pathTracer :: Ray -> Scene -> IO (Float, Float, Float)
10:56:08 <Saizan> mreh: this is known as the "show . read" problem
10:56:17 <mreh> interesting
10:56:27 <mreh> why can't GHC choose the best?
10:56:32 <zygoloid> > show . read $ "()"
10:56:34 <lambdabot>   "()"
10:56:34 <benmachine> kamatsu: I think that's what you want
10:56:36 <Saizan> best based on what?
10:56:43 <kamatsu> benmachine: thanks
10:56:47 <Saizan> zygoloid: lambdabot has extended defaulting
10:56:47 <mreh> Saizan: the sampling rate of the file
10:56:48 <zygoloid> mreh: because you've not satisfied the necessary conditions for defaulting to kick in
10:57:13 <Saizan> mreh: because GHC has no idea what a sampling rate is?:)
10:57:14 <trem> and the commented line was changed into lines above it basically so ghc doesn't complain
10:57:18 <mreh> presumably that would be dynamic typing if the file read was a certain bitrate
10:57:23 <Saizan> mreh: however you could make that choice explicitly
10:57:33 <zygoloid> mreh: it sounds like you want parsePCMFile to return an existential
10:57:37 <Saizan> and wrap the thing in an existential
10:57:44 <zygoloid> that is, you want parsePCMFile to choose 'a' rather than letting the caller choose
10:57:48 <mreh> that sounds philisophical
10:57:57 <mreh> zygoloid: yes!
10:57:58 <mreh> that would do
10:58:17 <trem> the result is that the whole image (actually the computation for it) piles up in "colours" and then gets written out, which pretty much limits me in resoulution / oversampling and everything
10:58:28 <Saizan> yeah, so you've to figure out how to choose that inside parsePCMFile
10:58:50 <mreh> existentials are not haskell98 are they?
10:58:55 <Saizan> the rest is done with an "existential type"
10:58:58 <Saizan> no, they aren't
10:59:29 <trem> ultimately, i want the space behavior of my one-liner back. sorry for being so chatty... don't know how to describe my problem in less words.. :-)
11:00:06 <trem> anyone?
11:00:16 <zygoloid> mreh: one possible interface could be: parsePCMFile :: String -> (forall a. (Audible a, AudibleInWav a) => Audio a -> b) -> IO b
11:00:17 <mreh> Saizan: so using the existential, somewhat like a forall, will limit the interfaces available to the type to the ones specified in the type context
11:00:33 <mreh> oh, you just use a forall?
11:00:44 <FliPPeh_> Why can't I use the record accessor function defined in one module inside the other one, although I import that module? Also, strange thing is, sometimes it does work, and then on the next (seemingly unrelated) change, it does not.
11:00:50 <zygoloid> mreh: well thats a CPS-style alternative to an existential but it's basically the same thing
11:00:54 <FliPPeh_> They type is exportet with "(..)"
11:01:23 <Saizan> FliPPeh_: how does your import line look? and which is the error?
11:01:27 <mreh> zygoloid: okay, kewel
11:01:36 <FliPPeh_> ByteBot/Connection.hs:29:22: Not in scope: `btConnection'
11:01:45 <FliPPeh_>   1 module ByteBot.State                                                                                               |  1 module ByteBot.BotMain
11:01:48 <FliPPeh_>   2 ( BotState(..)
11:01:56 <FliPPeh_> Ignore those numbers, it's VIM's line count
11:02:08 <Saizan> the import line?
11:02:19 <FliPPeh_> "import ByteBot.State"
11:02:20 <FliPPeh_> No hiding
11:02:24 <FliPPeh_> No exclusives
11:02:34 <zygoloid> FliPPeh_: are the record accessors exported?
11:02:40 <benmachine> trem: how strict is makePgm?
11:02:46 <Saizan> FliPPeh_: but it's ByteBot.BotMain that exports that type
11:02:49 <FliPPeh_> zygoloid: Do they have to? I have other records where it indeed does work
11:03:13 <benmachine> trem: (btw, sequence (map f xs) is called mapM f xs)
11:03:29 <FliPPeh_> Saizan: Nope, I didn't notice that vim copied the whole line (I have split screens) and it grabbed the BotMain part from the righthand split window
11:03:35 <trem> benmachine: excuse my ignorance, but how do i find out how strict it is?
11:04:03 <mreh> trem: look at the source code for strictness!
11:04:23 <Saizan> FliPPeh_: you sure you saved all the files?
11:04:24 <trem> benmachine: i added the code http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24887#a24889
11:04:35 <FliPPeh_> Saizan: All saved!
11:04:45 <benmachine> trem: ah
11:04:55 <trem> from what i know it's not strict at all? just a wild guess :-)
11:05:08 <zygoloid> FliPPeh_: is BotState defined in ByteBot.State?
11:05:15 <benmachine> trem: looks pretty lazy yeah
11:05:22 <benmachine> trem: my questino was badly phrased, my apologoies
11:05:24 <benmachine> goies?
11:05:49 <benmachine> trem: anyway, the problem is that IO has to happen in order
11:05:51 <FliPPeh_> zygoloid: BotState is a type alias for "StateT State IO", and "State" is the said... record.. that I don't export....
11:05:54 <FliPPeh_> DANG!
11:06:07 <FliPPeh_> Head meets table in 3... 2... 1
11:06:18 <benmachine> trem: so in your current program, if you're generating random numbers with IO, and then writing to a file, all the random numbers have to be generated before any writing happens
11:06:36 <benmachine> trem: there are a few things you can do to ameliorate this difficulty
11:06:57 <trem> benmachine: i would be glad to read about them :-)
11:07:28 <benmachine> trem: one is, change makePgm to writePgm so it interleaves the IO of colour generation with the file output, but that's a little unsatisfying becaus eyou're making stuff IO that doesn't need to be
11:08:24 <benmachine> trem: another solution would be using unsafeInterleaveIO on the random number generation stuff so that you explicitly state you don't care what order it happens in, but that is, as the name suggests, unsafe... possibly not in any harmful ways but it can result in surprising behaviour
11:08:31 * benmachine wonders if that line was too long
11:09:13 <benmachine> trem: imo the best solution is to use pseudo-random numbers and hence not involve IO in pathTracer at all
11:09:26 <benmachine> you could use State StdGen, for example
11:09:50 <hpc> you still have to carry the RNG around though
11:09:58 <benmachine> erm, by use pseudo-random numbers I mean use a pure PRNG
11:10:04 <benmachine> the IO one is probably pseudo anyway
11:10:06 <trem> benmachine: currently i have type Rand a = IO a at the top of my source
11:10:19 <benmachine> trem: ah
11:10:26 <trem> which gives me the RNG when i need it
11:10:43 <benmachine> http://hackage.haskell.org/package/MonadRandom this may be of interest, but I've never used it
11:10:52 <hpc> the worst i can see happening with unsafe IO applied to random numbers is...
11:10:56 <hpc> randomness
11:11:14 <mauke> everything is broken
11:11:17 * mauke cries
11:11:45 <benmachine> hpc: heh, probably yeah
11:11:51 <benmachine> mauke: agreed.
11:12:01 <benmachine> mauke: what particular aspect of everything broke this time?
11:12:06 <Jafet> @quote RandomRIO
11:12:07 <lambdabot> <kmc> says: head [] = peek . intPtrToPtr . fromIntegral . unsafePerformIO . randomRIO $ (0, 2^32)
11:12:25 <mauke> cabal: dependencies conflict: ghc-6.10.2 requires directory ==1.0.0.3 however
11:12:26 <mauke> directory-1.0.0.3 was excluded because ghc-6.10.2 requires directory ==1.0.1.0
11:12:44 <dcoutts_> mauke: see the Cabal FAQ
11:12:59 <mauke> ghc-pkg check says everything is broken for depending on broken rts-1.0
11:13:15 <mauke> recompiling ghc-6.10.2 fails because 'package' is not in scope in ghc-pkg/Main.hs
11:13:16 <benmachine> oh
11:13:21 <benmachine> you're screwed? :P
11:13:30 <dcoutts_> mauke: ghc-pkg check was broken in 6.10.2
11:13:36 <mreh> is there any research into embedded haskell?
11:13:36 <dcoutts_> mauke: see the FAQ, it's fixable
11:13:51 <mreh> embedded in a browser
11:13:52 <mauke> does it tell me how to make ghc build again?
11:14:02 <dcoutts_> mauke: you don't need to rebuild ghc
11:14:09 <gwern> mreh: yes
11:14:10 <mauke> but I want to
11:14:16 <mreh> gwern: tell me more
11:14:24 <dcoutts_> mauke: then you need to hide the later version of Cabal
11:14:34 <mauke> ah, that's what it is
11:15:09 <mauke> FAQ says it's a conflict between system/user package dbs
11:15:17 <mauke> which is impossible because my user db is empty
11:16:10 <Jafet> "rm -rf ghc-6.10.2 && tar -xzf ghc-6.12.1.tar.gz && pushd ghc-6.12.1 && configure && make install && popd"
11:16:31 <mauke> Jafet: the 'make install' step will fail
11:16:49 <Jafet> My plan is foiled
11:16:59 <mauke> er, wait
11:17:14 <mauke> the untar step will fail because I don't have that file
11:19:07 <mauke> <insert haskeline rant here>
11:19:51 <Jafet> Cool, a lazy rant
11:20:21 <hpc> haha
11:20:25 <mauke> dcoutts_: the FAQ doesn't apply to me, and hiding Cabal-1.8.0.2 didn't fix the ghc build problem
11:20:45 <mauke> do I need an older Cabal than 1.6.0.3 or something?
11:21:14 <alpounet> is there an epsilon value for Float/Double somewhere ?
11:21:21 <dcoutts_> mauke: you may need to unregister it, the ghc build system will be using -package Cabal, and that unhides the package but ghc will pick the latest version.
11:21:37 <mauke> ah
11:21:50 <dcoutts_> mauke: you can get the same conflict within a single db, ie the global one, it's just more common between global/user
11:22:19 <dcoutts_> mauke: you've managed to arrange things so that the ghc package depends on two versions of the directory package
11:22:53 <dcoutts_> probably because you rebuilt a version of a package that the ghc package depends on
11:23:03 <dcoutts_> but rebuilt it against different versions of other packages
11:23:31 <trem> alpounet: i know little about haskell, but from what i know about ieee floating point values i think there can not be a single epsilon for these values
11:23:40 <mauke> probably with 'cabal upgrade'
11:23:59 <dcoutts_> mauke: probably so, that's why I disabled cabal upgrade
11:24:04 <hpc> there is a value that is closest to zero
11:24:23 <hpc> if that's what you want
11:24:24 <aavogt> > last $ fst $ span (>0) $ iterate (/2) 1
11:24:25 <lambdabot>   5.0e-324
11:24:44 <aavogt> > last $ fst $ span (>0) $ iterate (/2) 1 :: Float
11:24:45 <lambdabot>   1.0e-45
11:24:56 <hpc> yeah, those
11:25:21 <aavogt> also the negatives of those numbers
11:25:42 <aavogt> > last $ fst $ span (>0) $ iterate (/2) 1 :: CReal
11:25:43 <lambdabot>   0.0
11:25:55 <aavogt> oO
11:25:57 <opqdonut> errr
11:26:25 <hpc> :t iterate
11:26:25 <lambdabot> forall a. (a -> a) -> a -> [a]
11:26:32 <jmcarthur> :t span
11:26:33 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
11:26:58 <jmcarthur> > span (>5) [1..10]
11:26:59 <lambdabot>   ([],[1,2,3,4,5,6,7,8,9,10])
11:27:01 <aavogt> > last $ takeWhile (>0) $ iterate (/2) 1
11:27:02 <lambdabot>   5.0e-324
11:27:13 <trem> i thought alpounet was after what nextafter / nextafterf do for C99
11:27:14 <quicksilver> there is also an epsilon for any given value, but not a global epsilon
11:27:35 <opqdonut> > iterate (/2) 1 :: CReal
11:27:36 <trem> quicksilver: that's what i mean
11:27:36 <lambdabot>   Couldn't match expected type `Data.Number.CReal.CReal'
11:27:36 <lambdabot>         against infe...
11:27:38 <quicksilver> aavogt's answer is the "epsilon at 0"
11:27:43 <opqdonut> > iterate (/2) (1 :: CReal)
11:27:45 <lambdabot>   [1.0,0.5,0.25,0.125,0.0625,0.03125,0.015625,0.0078125,0.00390625,0.00195312...
11:27:51 <jmcarthur> > last $ takeWhile (>0) $ iterate (/2) 1 :: CReal
11:27:52 <lambdabot>   0.0
11:27:59 <quicksilver> however, I'm curious what one would ever need it for?
11:28:11 <opqdonut> jmcarthur: ah, it only renders as 0
11:28:15 <jmcarthur> aha
11:28:18 <jmcarthur> that explains it
11:28:23 <opqdonut> > let zero = last $ takeWhile (>0) $ iterate (/2) 1 :: CReal in zero == 0
11:28:25 <lambdabot>   False
11:28:26 <opqdonut> there
11:28:37 <opqdonut> CReal has that default printing precision, after all
11:28:43 <jmcarthur> silly CReal
11:28:45 <hpc> heh
11:29:06 <opqdonut> still doesn't explain why that even produces a result...
11:29:14 <jmcarthur> actually... why does that work?
11:29:18 <jmcarthur> heh, yeah, same thought
11:29:48 <jmcarthur> maybe it just happens to be shortcutting it somehow
11:30:01 <jmcarthur> oh i bet Ord is up to some precision
11:30:24 <jmcarthur> (==) is too, iirc
11:30:24 <quicksilver> mreh: sorry, I had to run, did you get it working?
11:31:13 <opqdonut> jmcarthur: yeah, it is
11:31:14 <opqdonut> digits = 40
11:31:42 <alpounet> aavogt, quicksilver, trem, thanks
11:31:52 <alpounet> (I wanted one for each, not a global one
11:31:53 <alpounet> )
11:33:24 <opqdonut> weird, really
11:33:37 <opqdonut> since the docs say that comparison can diverge
11:39:25 <trem> alpounet: it seems to be in http://hackage.haskell.org/package/ieee
11:39:58 <trem> looking at the source, there is a function which seems to do what you want: http://github.com/patperry/hs-ieee/blob/master/Numeric/IEEE.hs#L78
11:40:08 <trem> hope that helps
11:42:04 <trem> hmm, no, that's a constant, not a function.
11:45:25 <mreh> quicksilver: I haven't tried, but I've been given two plausible solutions
11:46:09 <quicksilver> mreh: ok good :)
11:46:40 <alpounet> trem, I'll look further
11:46:41 <alpounet> thanks
11:51:28 <FliPPeh> :/
11:52:29 <FliPPeh> :t doLogIO => "doLogIO :: String -> String -> IO ()", fine, correct. But...  (liftIO . doLogIO) fails completely
11:52:30 <lambdabot> parse error on input `=>'
11:52:37 <FliPPeh> Why can't I partially apply liftIO?
11:53:00 <idnar> @type liftIO
11:53:01 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
11:53:06 <idnar> FliPPeh: (.) is composition, not application
11:53:19 <FliPPeh> idnar: I know
11:53:20 <hpc> :t (.)
11:53:21 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:53:22 <hpc> :t ($)
11:53:23 <lambdabot> forall a b. (a -> b) -> a -> b
11:53:28 <Botje> liftIO . doLogIO = \x -> liftIO (doLogIO x)
11:53:31 <FliPPeh> I want to compose doLogIO and liftIO
11:53:40 <idnar> @type (liftIO .)
11:53:41 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (MonadIO m, Functor f) => f (IO a) -> f (m a)
11:53:42 <Botje> if you then add a second parameter you get liftIO (doLogIO x) y
11:53:50 <Botje> instead of liftIO (doLogIO x y)
11:53:53 <FliPPeh> grrrr
11:54:03 <hpc> you want liftLogIO = liftIO . doLogIO
11:54:04 <idnar> @type (liftIO .) . doLogIO
11:54:05 <lambdabot> Not in scope: `doLogIO'
11:54:08 <hpc> or something of the sort
11:54:15 <idnar> @type (liftIO .) . ?doLogIO
11:54:16 <lambdabot> forall a (m :: * -> *) (f :: * -> *) (f1 :: * -> *). (MonadIO m, Functor f, ?doLogIO::f1 (f (IO a)), Functor f1) => f1 (f (m a))
11:54:33 <idnar> sigh, no
11:54:56 <idnar> @type let doLogIO = undefined :: String -> String -> IO () in (liftIO .) . doLogIO
11:54:57 <lambdabot> forall (m :: * -> *). (MonadIO m) => String -> String -> m ()
11:55:05 <idnar> FliPPeh: ^^^ I think that's what you want
11:55:12 <Botje> @pl \x y -> liftIO (doLogIO x y)
11:55:12 <lambdabot> (liftIO .) . doLogIO
11:56:23 <cvic> I'm reading this tutorial http://tutorial.happstack.com/tutorial/run-tutorial-locally and it gives me this http://pastebin.com/H0WBAWue
11:56:26 <cvic> Any ideas?
11:57:06 <cvic> First time I see cabal fubared
11:58:00 <dcoutts_> cvic: do you understand what the error says?
11:58:23 <cvic> Broken dependencies?
11:58:25 <zygoloid> dcoutts_: it'd be nice if it said why it wants to isntall Crypto-4.2.1
11:58:38 <dcoutts_> zygoloid: aye
11:59:27 <zygoloid> also if it could say 'all those versions of QuickCheck were excluded because [...]' rather than listing each one separately :)
11:59:29 <ccasin> dcoutts_: are you still maintaining c2hs?
11:59:55 <dcoutts_> zygoloid: patches accepted :-)
12:00:25 <quicksilver> dcoutts_: does the PVP say that if you bump a dependency by a major version, you must bump your own major version? Should it say that?
12:00:34 <dcoutts_> cvic: not exactly, it says the Crypto package is needed (though does not say exactly why) as an indirect dependency of happstack-tutorial and that the version of Crypto it has picked requires a version of QuickCheck that conflicts with the version required by the other happstack components
12:00:54 <cvic> I see. I just installed crypto via cabal
12:01:03 <quicksilver> (I'm guessing that's what happened here - Crypto bumped its quickcheck dependency up a major version without bumping its own. But I'm only guessing)
12:01:08 <dcoutts_> cvic: it may be solvable by picking an older version of something, eg Crypto that does not need QC-2
12:01:08 <cvic> And it doesn't work. So, back to the drawing board
12:01:17 <cvic> Yeah, thought so
12:01:43 <dcoutts_> cvic: the dependency solver is somewhat smart, but not very smart
12:02:10 <cvic> I know. It's not perfect, but it gets the job done
12:02:18 <dcoutts_> quicksilver: it does not say that, the PVP talks only about the external API
12:02:44 <quicksilver> dcoutts_: but (sometimes at least) bumping a library dependency by a major version has the consequence above :)
12:02:44 <dcoutts_> ccasin: yes, I'm working on getting the darcs repo restored and I've got a patch to make it work with 6.12
12:03:00 <dcoutts_> quicksilver: only because of the poor dependency solver
12:03:03 <quicksilver> dcoutts_: ...of course it only matters if something else in the same dependency graph uses the same library.
12:03:37 <ccasin> dcoutts_: great, thanks.  Happy to help if you guys are too swamped
12:05:24 <dcoutts_> ccasin: c2hs could do with some love if you've got the time and inclination
12:08:15 <ccasin> dcoutts_: when you get the repository up I'll take a look and see if I can help
12:08:41 <mreh> what is this mirrorservice.org doing at the top of my google search?
12:08:54 <mreh> surely haskell.org has a higher pagerank
12:09:32 <Jafet> It's operated by the university of Kent, and mirrors a few terabytes of websites each with high pagerank
12:09:50 <Jafet> And I guess google staff haven't marked it as such
12:09:50 <dcoutts_> ccasin: great, in the mean time the latest tarball and the c2hs trac are good resources
12:12:24 <mreh> ah yeah, page rank is about outgoing links too
12:13:09 * FunctorSalad winks
12:24:23 <jlouis> Ah, progress. Problem is not StateT itself. Problem is that someone else retains its data
12:28:28 <straszhm> trying to make a function that does different things do different types:  http://codepad.org/I3HIGCxi
12:28:44 <straszhm> ghc doesn't like the forall
12:28:54 <straszhm> I'm missing something basic I bet
12:29:00 <zygoloid> you can't do that :)
12:29:19 <straszhm> heh, okay
12:29:30 <zygoloid> polymorphic functions have to behave parametrically
12:29:46 <zygoloid> that is, they can't behave differently depending on the actual type of the parameter
12:30:05 <FunctorSalad> straszhm: "forall" means that it has to treat all the times uniformly... (so rigidly that you can derive properties from it)
12:30:05 <zygoloid> however, there's a way around this, which you can exploit
12:30:14 <FunctorSalad> zygoloid was faster
12:30:19 <FunctorSalad> s/times/types/
12:31:01 <sepp2k> I want to suggest typeclasses, but there's no way to specify a "default instance" for all types that don't have a specific instance (as far as I am aware).
12:31:11 <zygoloid> if you require the type 'a' to be an instance of some typeclass, you can use the members of that typeclass to, in effect, give different behaviour for different types
12:31:20 <FunctorSalad> for example, a function of type "a -> a -> a" is guaranteed to be either the projection to the first or to the second arg... (one choice for all types, discounting various less defined functions)
12:31:26 <aavogt> sepp2k: you can if you're ok with overlapping instances
12:31:28 <FunctorSalad> ( @ straszhm )
12:31:37 <zygoloid> aavogt: *shudder* :)
12:32:11 <FunctorSalad> (that was formated badly; the "once choice for all types" has nothing to do with the other disclaimer)
12:32:14 <FunctorSalad> *one
12:32:27 * straszhm discoveres that lots of c++ metaprogramming experience doesn't count for much
12:32:37 <sepp2k> aavogt: Those don't seem to be highly regarded around here...
12:32:41 <Jafet> It cultivates masochism.
12:32:52 <FunctorSalad> straszhm: that corresponds to TH
12:33:00 <FunctorSalad> not parametric polymorphism
12:33:02 <chrisdone> Jafet: haha
12:33:11 <zygoloid> straszhm: typeclasses allow you to do something somewhat like template specialization, but not enough like it for the intuition to be useful, i'm afraid...
12:33:13 <FunctorSalad> (well, very vague analogy)
12:33:42 <straszhm> zygoloid: yeah, it is just different enough to not really translate
12:34:04 <FunctorSalad> typeclasses don't break the property we just mentioned because they compile down to explicit dictionary passing, so all types *are* in fact treated uniformly
12:34:21 <FunctorSalad> (namely, their dict's method is invoked, no matter what the type is)
12:34:56 <aavogt> http://codepad.org/gqgvR1Cd
12:35:44 <straszhm> ooo, that's going to teach me something, thanks aavogt
12:35:47 <aavogt> but as mentioned, this needs some shady language extensions
12:36:00 <FunctorSalad> straszhm: btw there is a built-in cheat that lets you case over types: see Data.Typeable
12:36:34 <aavogt> FunctorSalad: and then a cast?
12:36:52 <aavogt> I'm not sure if that's so much better than overlapping instances
12:36:54 <EvanR-work> haskell cheat codes
12:36:55 <FunctorSalad> aavogt: if necessary (your example doesn't even need one)
12:37:14 <aavogt> I don't?
12:37:27 <FunctorSalad> aavogt: you just produce a string depending on the type
12:37:42 <FunctorSalad> (you'd just have to case over the result of typeOf)
12:38:25 <FunctorSalad> hmm, actually, if you don't have to cast, Typeable isn't cheating
12:38:46 <FunctorSalad> Typeable itself is a perfectly ordinary Typeclass, the unsafeCoerce is the cheat...
12:39:12 <aavogt> FunctorSalad: no you need to cast to be able to tell B and C apart
12:39:30 <EvanR-work> what use is there for unsafeCoerce
12:40:00 <straszhm> {-# LANGUAGE FlexibleInstances, OverlappingInstances #-}
12:40:07 <FunctorSalad> aavogt: oh right, read carelessly (though in this particular case you could derive Data.Data too and check the ctor name ;))
12:40:08 <straszhm> ... works ...
12:40:35 <straszhm> what's shady about this stuff?
12:40:37 <aavogt> @type constrIndex . toConstr
12:40:38 <lambdabot> forall a. (Data a) => a -> ConIndex
12:40:43 <FunctorSalad> OOs have issues if the most-specific-type isn't known at compile-time, I think
12:40:50 <aavogt> FunctorSalad: or use Data
12:40:54 <FunctorSalad> *OI's
12:41:07 <FunctorSalad> I'm not sure if that case breaks the type system
12:41:39 <FunctorSalad> straszhm: like if you invoke your function with a type that's itself a variable
12:42:00 <aavogt> straszhm: because when you let instances overlap, adding or removing imports can silently change the behavior of existing code
12:42:03 <FunctorSalad> (statically)
12:42:23 <FunctorSalad> aavogt: "or"?
12:42:28 <FunctorSalad> ("or use Data")
12:43:40 <aavogt> FunctorSalad: you can match over the result of   (constrIndex . toConstr)
12:43:54 <aavogt> that function takes any instance of Data, and gives you an Int
12:44:34 <FunctorSalad> aavogt: I was just confused because I mentioned Data.Data.Data as well ;) we just differed in name vs. index
12:45:06 <aavogt> oh
12:45:08 <aavogt> ;)
12:45:24 <aavogt> I missed that part
12:46:49 <hpaste>  A builder monoid for Data.Text (tibbe)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24890
12:47:11 <FunctorSalad> which parsec clones used backtracking by default again?
12:47:24 <FunctorSalad> (I realize that's bad for performance; this is just for ad-hoc scripts)
12:50:45 <FunctorSalad> (didn't mean 'parsec clones' derogatively; maybe some were even there first)
12:53:30 <quicksilver> FunctorSalad: polyparse is compositional by default
12:53:35 <quicksilver> FunctorSalad: (so, yes ;)
12:54:17 <FunctorSalad> generally I'm wondering whether it would be viable to make parsec (or polyparse) utility lib which is so neat that it can replace sed/grep/etc shell scripts
12:54:40 <FunctorSalad> quicksilver: thanks
12:54:58 <FunctorSalad> (wasn't aware it had something to do with compositionality)
12:57:29 <quicksilver> well, in parsec a <|> b doesn't work for arbitrarily complex a and b
12:57:43 <FunctorSalad> I think one would want a special monad based on Parsec which passes through the whole stream unless you tell it to skip/highlight/insert something
12:57:54 <quicksilver> so that's a kind of compositionality failing
12:58:00 <FunctorSalad> (to get very concise scripting)
12:58:12 <aavogt> because of performance concerns
12:58:16 <FunctorSalad> (ok, that's a special case: formatting output of something)
12:59:09 <FunctorSalad> ParsecT String Char (Writer String) or so
12:59:22 <FunctorSalad> (a user state would probalby be convenient too)
13:00:01 <FunctorSalad> quicksilver: hmm it just seems to have a different idea what "<|>" should mean...
13:00:35 <FunctorSalad> the "without consuming output" part is a bit obscure, admittedly
13:00:40 <FunctorSalad> *input
13:01:59 <FunctorSalad> (you need to know for everything you use, whether it may consume input and then fail)
13:02:20 <FunctorSalad> e.g. with `string' I find it non-obvious
13:03:31 <kevinulin> is there a way to overwrite a instance of a type defined in someone else's module?
13:03:41 <kevinulin> i mean an instance of a type class
13:04:30 <FunctorSalad> kevinulin: no, but you can use newtype
13:05:21 <FunctorSalad> you can avoid loading the instance if it's an orphan instance, but then any program ever importing both at the same time will fail
13:05:27 <FunctorSalad> (bad idea)
13:05:59 <kevinulin> thats fine, my program is the end user of it, and its only temporary until the maintainer fixes the bug
13:06:39 <chrisdone> hmmm
13:07:10 <chrisdone> kevinulin: what about qualification?
13:07:24 <FunctorSalad> but your's probably isn't orphan anyway (an orphan instance is one that's neither in the file that defines the class nor that defined the instancee type)
13:07:25 <chrisdone> can classes by qualified? never tried
13:07:38 <jmcarthur> instances are imported nonetheless, regardless of qualification
13:07:44 <chrisdone> damn
13:07:50 <jmcarthur> they are "global"
13:08:09 <chrisdone> so two modules exporting the same class gives an unavoidable conflict
13:08:13 <jmcarthur> the class itself can be qualified
13:08:16 <jmcarthur> just not instances
13:08:25 <chrisdone> oh that's what I meant
13:08:36 <jmcarthur> two modules having instances of the same class are in conflict
13:08:41 <chrisdone> then you could qualify the class, then import the class again and define an instance for it?
13:08:41 <jmcarthur> they don't even have to export them
13:09:08 <chrisdone> then you have two instance for two "different" (qualified differently) classes?
13:09:13 <jmcarthur> no
13:09:18 <chrisdone> why not?
13:09:19 <zygoloid> no, it's the same class still, just with two names
13:09:27 <jmcarthur> same class, not different
13:09:30 <chrisdone> >:|
13:09:42 <jmcarthur> this is part of the design of type classes
13:09:47 <aavogt> if that did work it would be interesting
13:09:50 <jmcarthur> so that you don't have to pass a dictionary around manually
13:10:14 <kevinulin> guess ill just wait for the bug fix
13:10:17 <jmcarthur> you lose some power with this design, but it was an intentional tradeoff
13:10:28 <FliPPeh_> Maaaan.
13:10:33 <FliPPeh_> I hate my internet provider
13:10:34 <aavogt> ie. if instances conflict, the one imported unqualified wins or something
13:10:58 <johnnowak> hello all. does anyone have a recommended "safe" set of ghc extensions? I'm concerned about interactions like http://hackage.haskell.org/trac/ghc/ticket/1496 which seem to make the type system unsound when using -fglasgow-exts
13:11:01 <jmcarthur> aavogt: it would be nice to have a way to dismbiguate conflicting instances. i have no idea how that would work
13:11:45 <zygoloid> johnnowak: you have to try quite hard to get generalized newtype deriving to break
13:12:11 <jmcarthur> yeah i use it with type families all the time
13:12:14 <chrisdone> I just tried it and it worked???
13:12:23 <johnnowak> zygoloid: Sure; I understand it's not a common problem. But still, I'd much rather have a safe set of extensions and then only step outside that when necessary.
13:12:26 <jmcarthur> chrisdone: what worked?
13:12:35 <chrisdone> wait
13:12:46 <zygoloid> johnnowak: a custom Typeable instance is enough to break the type system, and /using/ that stuff doesn't require any extensions iirc
13:12:50 <FunctorSalad> kevinulin: what about the newtype option?
13:13:15 <kevinulin> im not sure, wont newtype require that i go through all my code and replace the type?
13:13:37 <FunctorSalad> someone made the suggestion to add keywords "close instance" , "open instance", don't know what the counterarguments were
13:14:01 <jmcarthur> "replacing the type" tells me you aren't writing your code sufficiently generally ;)
13:14:10 <zygoloid> johnnowak: plus of course if you use unsafeCoerce yourself then you can easily break the type system. likewise if you unsafePerformIO newIORef...
13:14:12 <jmcarthur> sometimes it can't be avoided of course
13:14:23 <jmcarthur> but generality saves a lot of that
13:14:25 <kevinulin> its pretty general i think
13:14:34 <FunctorSalad> kevinulin: depends... if you mostly call typeclass methods on your type, it's mostly enough to derive the classes for your newtype
13:14:45 <johnnowak> zygoloid: I understand, but that doesn't diminish the value of a system that's safe from problems due to interactions between extensions in ghc.
13:14:47 <FunctorSalad> like if you append your strings with `mappend`, not (++)
13:14:54 <FunctorSalad> then you can just drop in a newtype
13:14:58 <jmcarthur> i mean things like using Foo a => a, instead of Int, when possible
13:14:59 <johnnowak> zygoloid: I'd like to at least know where the unsafe parts are.
13:15:52 <jmcarthur> johnnowak: i think such issue are just bound to happen unless we verified all combinations in a theorem prover
13:15:53 <FunctorSalad> jmcarthur: monotypes have the allure of sane error messages, though ;)
13:15:57 <chrisdone> nevermind, failed
13:16:06 <jmcarthur> FunctorSalad: what's a sane error message?
13:16:40 <FunctorSalad> jmcarthur: something that tells you where the error actually is and not that you could have instantiared Foo with a function type 200 lines back
13:16:47 <FunctorSalad> *ironic exaggeration*
13:16:48 <kevinulin> maybe ill just patch the guys code myself
13:16:56 <kevinulin> that seems like the least awful option
13:17:01 <FunctorSalad> (example: forgetting a comma in a list)
13:17:04 <zygoloid> johnnowak: well, iirc you can exploit the newtype deriving issue with GADTs too, so i'd say GeneralizedNewtypeDeriving should be the thing to avoid. plus it's just some fairly straightforward syntactic sugar anyway
13:17:05 <mreh> can I really do a heterogeneous list with an exists keyword?
13:17:06 <EvanR-work> so if i have a function f x! = ..., x will be fully evaluated before f foo 'returns' ?
13:17:24 <jmcarthur> > 4 5 -- like so, i assume
13:17:25 <lambdabot>   Ambiguous type variable `t' in the constraint:
13:17:25 <lambdabot>    `GHC.Num.Num t' arising f...
13:17:25 <chrisdone> don't think `exists' was ever implemented was it?
13:17:28 <mreh> I suppose that would be completely useless
13:17:30 <johnnowak> jmcarthur: It's a shame though because it seems the problem isn't with deriving for newtypes, but rather the specific mechanism GHC uses
13:17:46 <jmcarthur> > 4 "foo" -- like so, i assume (actually)
13:17:47 <zygoloid> in fact GeneralizedNewtypeDeriving is probably quite easy to reimplement in TH, for the cases where it's safe
13:17:47 <lambdabot>   No instance for (GHC.Num.Num ([GHC.Types.Char] -> a))
13:17:47 <lambdabot>    arising from the l...
13:17:59 <johnnowak> jmcarthur: It should be a syntactic sugar, but it isn't
13:18:00 <jmcarthur> johnnowak: yeah :(
13:18:11 <FunctorSalad> jmcarthur: yeah (there's a 'humour' page on haskellwiki about making function types Num instances)
13:18:23 <FunctorSalad> if someone tries to write multiplication by juxtaposition...
13:18:34 <aavogt> FunctorSalad: I think part of it is that ghc lists 2 source locations when instances don't match up, with the one pointing to the top of the module being the one that various tools lookup
13:19:10 <chrisdone>     Duplicate instance declarations:
13:19:10 <chrisdone>       instance C2.C Int -- Defined at /home/chris/Haskell/cls.hs:4:9-16
13:19:10 <chrisdone>       instance C2.C Int -- Defined at Cls2.hs:5:9-13
13:19:40 <aavogt> that would only work for    2 3, or   5 x, not   k x
13:19:53 <FunctorSalad> aavogt: sometimes the new error isn't about instances at all because it deduces some weird instantiation and only fails later
13:20:03 <zygoloid> johnnowak: "all" that's missing from it being sugar operationally as well as denotationally is for GHC to detect that that the dictionary is the same as that of the underlying type and avoid the duplication, i think
13:20:19 <johnnowak> yes, it doesn't seem particularly difficult
13:20:22 <chrisdone> hi applicative
13:20:30 <chrisdone> oh they left, ha
13:21:53 <FunctorSalad> zygoloid: wait, GNTD (generalized blah) isn't just a macro?
13:23:21 <jmcarthur> nope
13:23:31 <jmcarthur> it should be
13:23:36 <johnnowak> aye
13:23:40 <jmcarthur> but ghc uses soem coersions
13:23:43 <jmcarthur> *some
13:24:00 <jmcarthur> also sucks with standalone deriving
13:24:07 <johnnowak> seems like it has been a known problem for some years now
13:24:17 <jmcarthur> let's you make instances even if you don't have access to the internals
13:24:24 <jmcarthur> like, from another module
13:24:29 <jmcarthur> *lets you
13:24:35 <FunctorSalad> hmm, I never considered private internals a security mechanism
13:24:48 <jlouis> zygoloid: hah, more progress. It seems to happen when I forkIO from inside a StateT and then the stack is retained in a way I can't really figure out. I should perhaps try to build a minimal example and then throw it at the Simons
13:24:51 <FunctorSalad> or you probably mean safety
13:25:03 <jmcarthur> well, safety is security
13:25:28 <FunctorSalad> I mean I thought hiding is just to avoid someone shooting their own foot, not to get guarantees
13:25:41 <jmcarthur> it's abstraction
13:25:50 <johnnowak> abstract data types are all about getting guarantees by hiding
13:25:55 <jmcarthur> and GNTD with SD breaks that abstraction
13:26:18 <FunctorSalad> johnnowak: "hiding" as by "not exporting", not hiding in general
13:26:34 <FunctorSalad> you can have truly abstract types with existentials
13:26:37 <jmcarthur> not exporting is definitely an abstraction boundary
13:26:49 <FunctorSalad> hmm, maybe
13:26:51 <jmcarthur> i use it as such all the time
13:27:12 <FunctorSalad> relatedly, I sometimes find docs with hidden "data" defs /harder/ to read
13:27:24 <quicksilver> well, strong abstraction is IMO when you use polymorphism to prove that your code works "For All" possible implementations.
13:27:31 <quicksilver> (often that requires rank N)
13:27:33 <FunctorSalad> similar to how an axiomatically defined concept in math can be harder at first than an explicit construction
13:27:37 <FunctorSalad> *similarly
13:27:39 <quicksilver> hiding, compared to that, is weak abstraction.
13:27:40 <jmcarthur> sometimes badly designed APIs just wrap an implementation and expect you to understand how it works
13:28:11 <sinelaw> Peaker, hey!
13:28:12 <chrisdone> 9 times out of 10 I use the Source link on any haskell lib I use
13:28:20 <FunctorSalad> quicksilver: I meant something along those lines by 'existential'
13:28:21 <jmcarthur> i do it a lot too
13:28:38 <jmcarthur> that doesn't say much for the quality of the documentation or the model
13:28:43 <johnnowak> chrisdone: that nay say more about the quality of the documentation than anything else
13:28:44 <FunctorSalad> data SomeImpl = forall a. SomeImpl (Interface a) a
13:28:44 <kevinulin> how do i fix this overflow problem: (1 :: Int64) >= 256 ^ 8
13:28:44 <FunctorSalad> ?
13:29:00 <Nebasuke> a hopefully simple question about CmdArgs: how would you print the help message when not getting any arguments from the cmdline?
13:29:24 <jmcarthur> there are also cases where a function *is* best documented by its implementation. generally the function uses things which are best left abstracted though
13:29:36 <kevinulin> check to see that CmdArgs is the empty list?
13:29:40 <chrisdone> yeah
13:29:45 <monochrom> You can in the doc say "this is better explained by a dumb implementation than by axioms, but clearly the real implementation is different"
13:29:49 <jmcarthur> that's where i normally draw a line between library "primitives" and "convenience functions"
13:29:53 <Nebasuke> well it's a data type and not a list
13:30:50 <chrisdone> Nebasuke: commonly I see: error "arguments expected: <foo> <bar>"
13:30:50 <quicksilver> monochrom: that only applies in the case of 'clever algorithms'
13:31:05 <quicksilver> monochrom: e.g., Knuth's books are full of 'clever algorithms' but in my experience 'real live code' has very few :)
13:31:06 <monochrom> That applies to explaining queues and stacks too.
13:31:17 <jmcarthur> it applies to any model
13:31:18 <FunctorSalad> jmcarthur: monochrom: I was talking about abstract ADTs, not functions (not sure if it's really a diff)... the advantage with concrete ADTs is that you immediately have an idea of what this thing is at most capable of, not a magic box where you find more and more features as you read the doc
13:31:39 <carnieri> @users
13:31:39 <lambdabot> Unknown command, try @list
13:31:58 <monochrom> abstract ADT without functions is implementable by data Void =.
13:32:02 <EvanR-work> how do i use zip, but on a expression that results in a list of two lists or a tuple of two lists
13:32:07 <jmcarthur> FunctorSalad: if the type has a clearly defined model than it is "obvious" what functionality it is capable of, and instead of discovering functionality in the docs, you just look for its name instead
13:32:45 <jmcarthur> i mean, because you already know what you're looking for
13:32:55 <jmcarthur> and don't even have to read the whole thing to know what you can do
13:33:23 <FunctorSalad> jmcarthur: by looking for its name you can't know what is a minimal set of primitive functions for the type
13:33:32 <jmcarthur> name /= model
13:33:34 <FunctorSalad> in the sense of "all others can be implemented by these"
13:33:38 <monochrom> I mean this. abstract ADT without functions doesn't need any documentation.
13:34:13 <EvanR-work> are all IO actions strict (besides the specifically lazy ones) that is, will their arguments and results be full evaluated?
13:34:22 <monochrom> No.
13:34:44 <monochrom> Even print is not fully strict.
13:34:45 <jmcarthur> FunctorSalad: i mean, say i exposed a type and a bunch of functions and type class instances for it, and i told you that the type's model is type Foo a = (Real, Real) -> a... you'd have a good idea of how all those instances and functions behave right off the bat
13:35:14 <EvanR-work> er. i would like to make a table from a file, then reopen the file for appending
13:35:15 <monochrom> Not to mention that return just never evaluates its argument and result.
13:35:19 <FunctorSalad> jmcarthur: the SomeImpl existential I mentioned has the advantage that you do, in fact, know everything that is to know about the *abstract* type
13:35:27 <FunctorSalad> (and that quicksilver mentioned)
13:36:12 <EvanR-work> should i seq something, close the file, and open it?
13:36:17 <FunctorSalad> jmcarthur: "model" in which sense? informally?
13:36:38 <jmcarthur> FunctorSalad: in this case, denotational
13:37:29 <FunctorSalad> jmcarthur: is "Foo" the interface-defining type con?
13:37:35 <jmcarthur> FunctorSalad: your existential abstraction is really no different. you hid the implementation (by hiding the identity) and exposed an interface
13:37:47 <jmcarthur> yes
13:38:02 <jmcarthur> "type" is an informal usage
13:38:08 <FunctorSalad> I don't really have a problem with hidden instantiators for an interface, if you *never* need to do anything non-interface
13:38:22 <FunctorSalad> (the existential type makes sure you *can't* do anything else)
13:39:10 <jmcarthur> your existential type is just a different kind of abstraction
13:39:21 <FunctorSalad> if it is an abstract implementation of your class, but the class isn't all that is to know about the implementation and the user has to hunt for impl-specific function, that's bad IMO :)
13:39:41 <FunctorSalad> it behaves as the universal implementation in some sense
13:39:50 <FunctorSalad> can't do anything with it except combine interface methods
13:39:58 <jmcarthur> i'm not getting the point i think
13:40:25 <FunctorSalad> the alternative would be to just define the interface class and export and instantiator, but with constructors hidden
13:40:52 <quicksilver> FunctorSalad: except I would never abuse a typeclass of course. I'd just existentially quantify over the signature
13:40:57 <FunctorSalad> then the user can't be sure whether the instantiator has some extra tricks
13:41:03 <jmcarthur> the whole idea is that there are no exposed data constructors for Foo, really
13:41:22 <FunctorSalad> quicksilver: I did there too (data SomeImpl = forall a. SomeImpl (Interface a) a)
13:41:28 <quicksilver> good.
13:41:34 <FunctorSalad> Interface could be a synonym
13:41:42 <quicksilver> you said 'class' that's a red rag to me :)
13:41:43 <EvanR-work> so in seq :: a -> b -> b, the expression that makes a is useless?
13:41:52 <sinelaw> we got a problem, the first one to solve it gets 100 in the course.
13:41:57 <FunctorSalad> quicksilver: yeah went back to talking about classes then
13:42:00 <hpc> the expression a is unused in future computation
13:42:05 <EvanR-work> ok
13:42:16 <hpc> think of it as the pure version of >>
13:42:21 <sinelaw> so I tried to solve it for an hour or two...unfortunately it seems to be an open problem that hasn't been solved for decades.
13:42:23 <EvanR-work> heh
13:42:34 <monochrom> what a cheap prof
13:42:47 <jmcarthur> lol
13:43:24 <sinelaw> the problem is basically to find an algorithm that for any distribution of an infinite source alphabet produces the optimal code
13:43:41 <FunctorSalad> quicksilver: hmm classes have the convenience advantage that the existential itself can be an instance :)
13:43:51 <c_wraith> sinelaw: similar to huffman encoding?
13:43:55 <sinelaw> c_wraith, yes.
13:44:01 <monochrom> If I were the prof, I would offer: the first one to solve it gets to co-author paper with me, even as first author, even as sole author. (Supposedly he/she would need my guidance in putting together an academic paper.)
13:44:07 <c_wraith> sinelaw: what's the difference from huffman?
13:44:15 <sinelaw> huffman is for finite alphabets
13:44:44 <sinelaw> there have been solutions found for geometrical series of probabilities
13:44:48 <sinelaw> but not for the general case
13:44:59 <monochrom> supposedly "any distribution" is a bummer.
13:45:00 <FunctorSalad> jmcarthur: I could export everything though, then the user would know the data constructors, but can't use that knowledge if some function just works on SomeImpls
13:45:27 <sinelaw> anyway, i'm giving up.
13:45:29 <sinelaw>  :)
13:45:54 <FunctorSalad> he *could* mess with the internals of your concrete instance, but only until something requires SomeImpl
13:48:05 <FunctorSalad> (what exactly she could do would depend on whether she calls a function that takes SomeImpls or produces them)
13:48:41 <FunctorSalad> (for a function that takes them she could construct something using the constructors directly; for SomeImpl-producers it's perfectly abstract)
13:49:57 <Younder> I love functors..
13:51:17 <FunctorSalad> seems like there's a dual concept lurking in the shadows here
13:51:23 <FunctorSalad> :)
13:51:35 <jmcarthur> FunctorSalad: i see that your existential type is a full abstraction. i'm not arguing against that
13:52:41 <FunctorSalad> jmcarthur: I'm not so sure what I'm arguing either; maybe that you can export everything yet have guarantees in functions dealing with SomeImpl?
13:53:03 <FunctorSalad> the type-system does the work rather than the namespace system
13:53:11 <FunctorSalad> (or module system)
13:53:12 <jmcarthur> i hate it when i forget the point of debating
13:53:15 <FunctorSalad> :)
13:55:26 <jmcarthur> i like modules
13:55:35 <jmcarthur> that about sums up my point :)
13:55:49 <jmcarthur> i wish we had more powerful modules, though
13:55:50 * hackagebot RSA 1.0.4 - Implementation of RSA, using the padding schemes of PKCS#1 v2.1.  http://hackage.haskell.org/package/RSA-1.0.4 (AdamWick)
13:56:22 <EvanR-work> need a function :: [a] -> (a -> IO b) -> IO [b]
13:56:31 <EvanR-work> forM ?
13:57:12 <PepeSilvia> :t flip mapM
13:57:13 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
13:58:08 <FunctorSalad> jmcarthur: whether I find the ctors good for understanding doesn't determine how much insulation should be enforced, I guess
13:58:40 <FunctorSalad> (to repeat it in other words, they give you a closed world)
13:58:41 <jmcarthur> FunctorSalad: maybe the dual concept you are seeing the outline of is the same as the relationship between haskell type classes and ml modules
13:59:19 <jmcarthur> your Interface looks like a dictionary to me
13:59:41 <FunctorSalad> jmcarthur: thought it would just be something where the interface is to the left of some arrow :)
13:59:49 <jmcarthur> ah
13:59:55 <FunctorSalad> no sure what would be on the right, maybe a free 'r' like in Cont
13:59:57 <FunctorSalad> *not
14:00:17 <FunctorSalad> I can't say much on ML modules, unfortunately
14:01:09 <FunctorSalad> it just seemed asymmetrical to me that the user can make use of the naked constructors when dealing with SomeImpl consumers, but not with producers
14:02:40 <jmcarthur> oh i see now what you meant
14:03:01 <FunctorSalad> (the 'naked' constructors of some ADT which is an instance of the interface class, or in quicksilvers scheme: for which a dict is provided)
14:04:33 <jmcarthur> okay i just read over the whole conversation and now i think i understand your point
14:04:41 <jmcarthur> it was completely wooshing over my head before
14:05:20 <FunctorSalad> hmm at some point I wasn't arguing against what you said anymore and just stated related bits & pieces
14:05:22 <FunctorSalad> :)
14:05:39 <jmcarthur> at least, i was missing the point that your version expresses a subset of functionality rather than all functionality opaquely at once
14:05:40 <dolio> What are we talking about duals of?
14:06:16 <jmcarthur> FunctorSalad: i typically do the same by creating one module that exports the minimal functionality and another module that exports some conveniences
14:06:26 <FunctorSalad> dolio: of "here is a dictionary "I : * -> *", and a type with a dict
14:06:27 <FunctorSalad> "
14:06:52 <FunctorSalad> dolio: knowing the internals of the type is useable if you deal with abstract consumers, but not producers
14:07:44 <FunctorSalad> jmcarthur: hmm I meant that the existential SomeImpl *doesn't* have more functionality than specified by the interface
14:07:45 <dolio> Isn't the duality between forall and exists?
14:07:59 <dolio> forall hides things inside a given scope. exists hides things outside a given scope.
14:08:09 <FunctorSalad> jmcarthur: whereas with modules your user can't know how much you are telling him about the type :)
14:08:11 <jmcarthur> FunctorSalad: right
14:08:16 <jmcarthur> well
14:08:31 <dolio> If a function returns something universally quantified you can know its specific type (because you choose it), but it can't know it while producing.
14:08:35 <jmcarthur> FunctorSalad: i don't really know how much of your interface is extra either
14:08:48 <dolio> But if it returns something existentially quantified, it can know its specific type, but you can't.
14:09:16 <jmcarthur> FunctorSalad: to make sure i understand, the idea is that your Interface reveals the primitive operations, and anything else can be constructed from those?
14:09:26 <FunctorSalad> dolio: I was varying the type itself though, not the functions
14:09:44 <FunctorSalad> (data SomeI = forall a. SomeI (I a) a)
14:10:23 <FunctorSalad> jmcarthur: the thing taking the place of "a" may have more abilities than the interface says, indeed
14:10:32 <jmcarthur> eh, not what i meant
14:10:45 <jmcarthur> FunctorSalad: are the guts of Interface exposed?
14:10:49 <FunctorSalad> jmcarthur: yes
14:10:50 <jmcarthur> or just SomeI?
14:10:52 <jmcarthur> okay
14:11:30 <FunctorSalad> the interface ops would be primitive operations for SomeI (as enforced by the type system)
14:11:38 <FunctorSalad> but not for the conrete type
14:11:39 <jmcarthur> it looks to me like the same thing could be done with an Interface type class and  data SomeI = forall a . Interface a => SomeI a  no?
14:11:49 <wavewave> Is anyone using leksah?
14:12:04 <jmcarthur> well, yours is more powerful i guess
14:12:12 <jmcarthur> dictionary passing vs. type class
14:12:35 <FunctorSalad> yes it's about the same as what you just wrote
14:12:40 <FunctorSalad> (I think)
14:13:01 <jmcarthur> yours is more powerful because you can have multiple Interfaces even for the same a
14:13:11 <jmcarthur> without newtyping
14:13:37 <FunctorSalad> not sure if quicksilver dislikes it for aesthetic reasons or functionality ones... the functionality seems identical
14:13:49 <jmcarthur> identical to what?
14:13:50 <FunctorSalad> jmcarthur: but newtyping will be hidden by the existential :)
14:14:08 <FunctorSalad> so you could translate dict-using code to typecl-using code by just adding NTs everywhere
14:14:11 <jmcarthur> okay, right
14:14:24 <jmcarthur> eh
14:14:27 <jmcarthur> not quite
14:14:35 <jmcarthur> with yours you could create new interfaces at runtime
14:14:40 <FunctorSalad> the dict and the typeclass way (@"identical what")
14:15:16 <FunctorSalad> but this still has some lexical location
14:15:26 <FunctorSalad> there you can just add the NT unless I'm missing something
14:15:36 <FunctorSalad> (just before wrapping in the ex.)
14:16:04 <jmcarthur> i could have a whole list of [(Interface a, a)] and create a ton of SomeIs from them, and each could be different
14:17:30 <FunctorSalad> (I'm picturing it to be similar to how lexical closures don't quite make up new functions at runtime, they just fill slots with runtime values)
14:17:50 <jmcarthur> say Interface just contains one function :: a -> a... i could say  map SomeI [(Interface (+1), 5), (Interface (*2), 2), (Interface (^3), 7)]
14:18:52 <jmcarthur> okay, sure, you can call the interface a collection of slots
14:19:13 <jmcarthur> but i'm pretty sure the type class version cannot do that
14:19:34 <FunctorSalad> hmm you'd need more than a newtype
14:19:49 <dv-> Is anyone else missing System.Console.Editline.Readline?
14:20:36 <FunctorSalad> jmcarthur: heh, it's even simpler than what I said. You can just make SomeI's out of your list, and have SomeI instantiate the class
14:20:40 <FunctorSalad> (once and for all)
14:21:07 <jmcarthur> class?
14:21:38 <jmcarthur> oh i see
14:21:47 <FunctorSalad> sorry. I mean have the dict-passing "SomeI" instantiate the class from the class-based scheme
14:22:05 <jmcarthur> instance Interface SomeI where...  yeah
14:22:27 <FunctorSalad> than pass the DictSomeI to the ClsSomeI constructor :)
14:22:38 <jmcarthur> *sigh*
14:22:41 <FunctorSalad> (to give them different names)
14:23:07 <jmcarthur> but the ability to combine them doesn't make them equivalent
14:23:18 <jmcarthur> you can create the class version from the dict version, but not vice versa
14:23:25 <jmcarthur> *cringes*
14:23:26 <jmcarthur> i guess you can
14:23:37 <FunctorSalad> I agree that there's a difference between dict-passing and TC's in general (like you mention, one dict per type)
14:23:49 <FunctorSalad> but doesn't the existential nullify that distinction?
14:23:52 <jmcarthur> you can just use the type class to fill in the dictionary
14:24:01 <jmcarthur> i think you are right
14:24:04 <jmcarthur> i have been convinced
14:24:07 <FunctorSalad> (existentials make typeclass instances 'touchable')
14:24:10 <jmcarthur> informally
14:25:14 <jmcarthur> i'm pretty sure that at runtime the existential version would look exactly the same for either implementation
14:25:22 <jmcarthur> both of them would be dictionaries, that is
14:25:42 <jmcarthur> since you can't optimize it out
14:26:15 <FunctorSalad> ah, hadn't thought about the tc -> dictionary direction... but like you say, it'd be boilerplate
14:26:28 <FunctorSalad> yes
14:26:57 <FunctorSalad> (well, I don't know the ghc internals enough to say which would have more wrappage overhead)
14:27:09 <FunctorSalad> but the dict seems dynamic in either case
14:28:26 <FunctorSalad> not entirely sure though
14:28:52 <FunctorSalad> maybe ghc can syntactically track down all the points that can create dicts :)
14:29:07 <orlandu63> what is cons?
14:29:09 <orlandu63> Cons
14:29:24 <FunctorSalad>  @ping Philippa -- didn't you once mention that existentials can be erased at compile time?
14:29:34 <FunctorSalad> (maybe I'm confusing it)
14:31:20 <dolio> They allow for similar erasure as universals.
14:31:44 <jmcarthur> eh?
14:31:46 <dolio> You don't need to pass types to map :: forall a b. (a -> b) -> [a] -> [b] at runtime.
14:31:49 <FunctorSalad> orlandu63: it's how (:) is usually called if for didactic purposes you want to avoid this syntactic special case
14:32:02 <dolio> And you don't need to store a type in exists a. P a at runtime.
14:32:13 <FunctorSalad> but do you need to store the dict?
14:32:15 <jmcarthur> what about instances?
14:32:27 <FunctorSalad> I understood 'erasure' as inlining all the dicts
14:32:54 <FunctorSalad> hmm nvm, that seems pretty impossible
14:33:04 <dolio> It'd probably be harder to erase dictionaries for existentials.
14:33:26 <jmcarthur> normality has been restored then
14:33:44 <FunctorSalad> foo = [Exi bar1, Exi bar2]; if (statically_undecidable_computation) then runDict (foo !! 1) else runDict (foo !! 2)
14:33:51 <FunctorSalad> can't inline there? ;)
14:34:05 <Philippa> FunctorSalad: I may've said that the compiler can optimise away cases where it really knows which dictionary is in use
14:34:25 <Philippa> I can't imagine claiming that all dictionary passing can be eliminated
14:34:34 <dolio> But it rather depends on how you're using existentials.
14:34:37 <orlandu63> FunctorSalad: so is Cons and : a data constructor?
14:34:40 <FunctorSalad> Philippa: I don't remember the context exactly, but no, you didn't say that all dicts can be eliminated
14:34:58 <FunctorSalad> just something about erasing existentials...
14:35:59 <dolio> FunctorSalad: Presumably you can massage that into 'if statically_undecidable_computation then <code with dict1 eliminated> else <code with dict2 eliminated>'.
14:36:21 <dolio> Which is as good as you'd get for the universal case.
14:36:41 <FunctorSalad> Philippa: it was in #blah in the context of the interplay of classes and GADT pattern matching, maybe
14:38:03 <FunctorSalad> dolio: even that seems like quite some compiletime evaluation
14:38:46 <dolio> Well, whether you can create a smart enough compiler to do it is another question.
14:38:58 <FunctorSalad> (maybe it should be "runDict (if ... then ... else ...)" for emphasis... no news that if-then-else can't be statically resolved ;))
14:41:22 <absentia> hey, is there an implementation of haskell written in javascript?
14:43:26 <quicksilver> FunctorSalad: aesthetic. That's not what typeclasses are for.
14:43:37 <quicksilver> FunctorSalad: if you want a dictionary, code a dictionary :)
14:43:57 <quicksilver> FunctorSalad: typeclasses are for when you want the compiler to make a decision for you (choose a dictionary) based on compile-time type information.
14:44:17 <FunctorSalad> quicksilver: hmm but won't you end up with writing a wrapper function for each method, which works on the existential?
14:44:18 <EvanR-work> absentia: i was just thinking of that yesterday
14:44:19 <quicksilver> FunctorSalad: also there was a bit of an annoying meme for a while that exitentials were useless without typeclasses
14:44:32 <EvanR-work> absentia: wouldnt THAT make client side interesting ;)
14:44:40 <FunctorSalad> (you'll have the boilerplate in either case, but with dicts you also get two names per method)
14:45:03 <FunctorSalad> quicksilver: *nod*
14:51:38 <absentia> I was just wondering how many languages could be put into a web browser for offline testing...
14:56:25 <jmcarthur> absentia: there's a haskell -> javascript compiler
14:58:48 <alpounet> YHC iirc
14:59:21 <tensorpudding> Is there a Haskell compiler that runs on Android?
15:01:44 <FunctorSalad> jmcarthur: compiler really? not the AST and prettyprinter?
15:02:17 <jmcarthur> i thought it was a compiler
15:03:31 <Saizan> YHC could compile to js
15:08:35 <chrisdone> I wonder how complete yhc is, then
15:08:58 <chrisdone> then again even a dumb haskell is better than javascript
15:09:29 <tensorpudding> H98 is a good language
15:09:29 <ddarius> YHC should be all of Haskell 98.
15:09:49 <chrisdone> good enough for me
15:12:09 * chrisdone ponders ghc core to javascript
15:15:27 <luite> chrisdone: and then use that to compile ghc itself to javascript, tryhaskell could run completely client side
15:16:07 <chrisdone> hahaha
15:16:23 <monochrom> zomghahaha
15:16:49 <monochrom> Just trampoline like there is no tomorrow.
15:16:50 <djahandarie> Then we can make an awesome framework called hQuery
15:18:09 <EvanR-work> this is insane. Prelude.catch catches IOError and 'user errors' ?
15:18:16 <Saizan> i'm sure you'd find no problem with garbage collection
15:18:57 <EvanR-work> but ADNS is throwing an exception... from somewhere
15:19:00 <EvanR-work> and its not being caught
15:19:07 <mauke> dcoutts++
15:19:09 <EvanR-work> maybe Prelude.catch isnt compatible
15:19:20 <mauke> EvanR-work: Prelude.catch only catches IO errors
15:19:24 <Saizan> EvanR-work: you want Control.Exception.catch
15:19:43 <hpaste>  . (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24891
15:19:49 <EvanR-work> it says the handler requires me to 'cast' the exception value
15:20:19 <EvanR-work> why doesnt ADNS throw IOErrors >_<
15:20:40 <Saizan> cast?
15:20:42 <Eelis> is there some package that provides a few simple type classes consolidating operations like "null" and "member" and "empty" ? having to type Set.member and Map.member all the time gets really boring, especially considering how easy it is to fix
15:20:51 <Saizan> i think you just have to choose the type of exception you want.
15:21:09 <Saizan> "SomeException" to catch them all.
15:21:37 <Saizan> Eelis: there's the edison library
15:21:52 <EvanR-work> \e -> thing that doesnt use e at all
15:22:08 <mauke> yeah, that needs some kind of type annotation
15:22:27 <benmachine> \e -> thing that doesn't use e at all `const` (e :: t)
15:22:27 <Saizan> EvanR-work: \ (SomeException _) ->
15:22:32 <EvanR-work> mmmkay
15:22:34 <mauke> catchAll :: IO a -> IO a -> IO a
15:22:53 <ddarius> replicateM 22 catch
15:23:13 <mauke> catchAll b h = b `catch` (\e -> const h (e :: SomeException))
15:23:14 <Eelis> Saizan: hm, i was hoping for something more modest
15:24:02 <EvanR-work> my handler does not return the error, it returns a useful value
15:24:13 <EvanR-work> using the SomeException pattern
15:24:48 <Saizan> that catchAll doesn't return the error either
15:25:15 * hackagebot gsasl 0.3 - Bindings for GNU SASL  http://hackage.haskell.org/package/gsasl-0.3 (JohnMillikin)
15:25:33 <EvanR-work> great
15:25:43 <EvanR-work> ../src/event.c:708: adns_wait: Assertion `tvp' failed.
15:25:47 <EvanR-work> Aborted
15:25:48 <EvanR-work> wtf
15:26:15 <EvanR-work> this same resolve code worked before, and if i put threadDelay 10^3 then it does not throw this error
15:26:19 <EvanR-work> >_<
15:26:23 <EvanR-work> maybe its related to garbage collection again
15:26:44 * benmachine blames the .c
15:27:06 <EvanR-work> gaaah
15:27:16 <EvanR-work> second foreign library thats failed on me
15:32:24 <tensorpudding> How might you use syb to avoid defining a Functor instance for a particular datatype?
15:33:53 <tensorpudding> or rather, define an fmap replacement
15:34:48 <mauke>         RegAllocLinear.getStackSlotFor: out of stack slots, try -fregs-graph
15:34:51 <mauke> grr
15:35:08 <Saizan> tensorpudding: bah, don't bother, DeriveFunctor
15:35:51 <tensorpudding> I know that you can do that.
15:36:53 <tensorpudding> But I'm trying to understand the rationale for using syb
15:39:10 <aavogt> @ty everywhere
15:39:11 <lambdabot> forall a. (Data a) => (forall a1. (Data a1) => a1 -> a1) -> a -> a
15:39:30 <Saizan> that's not really fmap
15:39:32 <FunctorSalad> tensorpudding: gmapT
15:39:34 <aavogt> tensorpudding: you probably can with some unsafecoerce
15:39:43 <Saizan> ?type gmapT
15:39:44 <lambdabot> forall a. (Data a) => (forall b. (Data b) => b -> b) -> a -> a
15:39:52 <FunctorSalad> hmm wait, `everywhere' is closer
15:39:58 <FunctorSalad> since fmap is "deep"
15:40:02 <FunctorSalad> gmapT is one level only
15:40:16 <Saizan> yeah, both are quite wrong wrt types though
15:40:34 <FunctorSalad> maybe limit the recursion to the children that would actually be affected by an fmap
15:40:36 <Saizan> i think fmap is pretty hard for syb, but you can somehow
15:40:48 <FunctorSalad> (by ugly typecases :p)
15:41:33 <FunctorSalad> is there a unique maximally defined fmap for a type, if it exists?
15:41:53 <FunctorSalad> nevermind, answer is "no"
15:42:13 <aavogt> that is      unsafeCoerce . everywhere (mkT $ \x -> if typeOf x == typeOf (undefined :: a) then unsafeCoerce (f x) else x) :: forall t a. (Data (t a), ?f :: a -> b) => t a -> t b
15:42:16 <FunctorSalad> you can always follow up by endomorphisms of the form "forall a. f a -> f a"
15:42:34 <Saizan> ?
15:42:44 <aavogt> this will probably crash and burn if your Data instance doesn't actually reach everything
15:42:46 <Saizan> don't fmap id = id constrains you?
15:42:47 <FunctorSalad> Saizan: that answers my question negatively
15:43:34 <FunctorSalad> Saizan: hmm, then replace "follow up by" with "conjugate by"?
15:44:06 <FunctorSalad> conjugate(g,h) = g . f . inverse_g
15:44:11 <aavogt> tensorpudding: do you think that could work?
15:44:13 <benmachine> FunctorSalad: probably fmap would commute with whatever you conjugated with
15:44:17 <FunctorSalad> the 'f' is 'h' there :|
15:44:31 <ddarius> benmachine: Indeed.
15:44:37 <FunctorSalad> doh
15:45:07 <FunctorSalad> so is it really unique?
15:45:30 <keroseno> hi
15:45:36 <benmachine> I lack the expertise to prove it but I've thought about it and never been able to come up with a counterexample
15:45:38 <byorgey> hi keroseno
15:45:46 <FunctorSalad> data Foo a = Foo a a a
15:45:46 <benmachine> hmm
15:45:48 <benmachine> although
15:45:49 <FunctorSalad> g = cyclic permutation
15:46:09 <benmachine> FunctorSalad: yes but that does the same thing as fmap
15:46:23 <benmachine> that's like saying map f and foldr ((:) . f) [] are different
15:46:23 <FunctorSalad> hmm
15:46:39 <Saizan> aavogt: the problem there is what happens if you've a datatype like data Foo a = Foo Int a; and your f :: Int -> Bar
15:46:41 <benmachine> I think there's a method with GADTs you can do
15:46:58 <FunctorSalad> benmachine: wasn't arguing from that position, no :) (your first msg)
15:47:07 <keroseno> hello can you help me with the Autoit
15:47:19 <benmachine> data Thing a where Fmap :: (a -> b) -> Thing a -> Thing b
15:47:20 <byorgey> keroseno: what is Autoit?
15:47:23 <FunctorSalad> benmachine: but apparently you're right
15:47:27 <FunctorSalad> (in this case)
15:47:34 <aavogt> though it doesn't seem to be accepted either
15:47:35 <FunctorSalad> in the general case it's just parametricity?
15:48:26 <benmachine> data Thing a where Fmap1 :: (a -> b) -> Thing a -> Thing b; Fmap2 :: (a -> b) -> Thing a -> Thing b -- Fmap1 and Fmap2 are both valid and distinct implementations of fmap, not really interesting though
15:48:26 <aavogt> oh, missing Typeable a, Typeable b
15:48:30 <keroseno> it is a programming software that i have donloaded
15:48:33 <mauke> ahh, new ghc install
15:48:38 <mauke> I feel so fresh and clean
15:48:49 <Saizan> benmachine: are they?
15:49:02 <benmachine> Saizan: oh, wait, probably not
15:49:07 <benmachine> heh
15:49:13 <benmachine> I was thinking of something else
15:49:21 <aavogt> Saizan: that isn't a problem because the type signature constrains it
15:49:34 <aavogt> the most general type of this function is a -> b
15:49:42 <benmachine> I was just reading about a GHC bug which involved instances of fmap, but it didn't require they followed the laws
15:50:01 <benmachine> so yeah ignore that point
15:50:01 <aavogt> possibly for tuples?
15:50:07 <Saizan> aavogt: can't i make a = Int, b = Bar, t = Foo ?
15:50:09 <FunctorSalad> what's wrong with benmachine's example?
15:50:19 <aavogt> oh, I see now
15:50:20 <byorgey> keroseno: is it written in Haskell?  This channel is for discussing the Haskell programming language.
15:50:22 <benmachine> FunctorSalad: the GADT one? fmap id /= id
15:50:28 <aavogt> you will affect the non-parameterized fields
15:50:33 <Saizan> yeah
15:50:38 <jmcarthur> and fmap f . fmap g /= fmap (f . g)
15:50:53 <FunctorSalad> benmachine: right... but somehow it doesn't seem like fmap id = id should save one ;)
15:51:20 <aavogt> so specifically the case of    Foo a = Foo Int a, when a ~ Int
15:51:32 <benmachine> FunctorSalad: why not? it's a pretty restrictive law
15:51:34 <keroseno> Oh im sorry it isnt
15:52:37 <jmcarthur> benmachine: if you dont' export the GADT's implementation and you have an interpreter function for it then it might actually be valid
15:52:41 <tensorpudding> Ugh, I need to stop being so distractable.
15:52:47 <Saizan> aavogt: yeah, you'd get a segfault there, one could also check the return type matches maybe, but then you'd get in trouble again when a = b = Int, since you'd modify the Int that should be left alone
15:52:50 <jmcarthur> if the interpreter follows the functor laws
15:53:02 <tensorpudding> aavogt: I don't think that is very pleasant-looking
15:53:37 <tensorpudding> (the unsafecoerce fmap using everywhere)
15:53:42 <mreh> CPS question: what if the action being performed by a function written in CPS is monadic, and I give it a monadic function
15:53:55 <FunctorSalad> benmachine: hmm I think my feeling was from the fact that "fmap id = id" doesn't follow from "fmap id = id_of_image_F", but right, that says that the law is strong, not weak ;)
15:53:56 <mreh> a monadic continuation
15:54:04 <benmachine> jmcarthur: but then there still wouldn't be two distinct functor instances, right? your implementation would be required to treat Fmap1 and Fmap2 the same?
15:54:05 <Saizan> use a monadic continuation
15:54:07 <jmcarthur> mreh: like (a -> m b) -> m b?
15:54:22 <FunctorSalad> benmachine: still, can't one permute something that leaves id alone?
15:54:23 <jmcarthur> benmachine: yeah. they must be the same, i think
15:54:37 <mreh> jmcarthur: oh right, then the user can lift whatever pure function to the right monad
15:54:55 <FunctorSalad> can't think about such things calmly while so engaged in IRC ;)
15:55:21 <benmachine> FunctorSalad: that's where parametricity kicks in, I think - you can't tell if a function *is* id
15:55:31 <benmachine> because the types you're working with might not be Eq
15:55:40 <benmachine> so you can't have special behaviour for id
15:55:52 <aavogt> tensorpudding: yeah, and it's broken in that it touches fields it isn't supposed to
15:56:06 <tensorpudding> So syb is not supposed to replace fmap, I suppose.
15:56:14 <FunctorSalad> benmachine: the conjugations don't special-case and do leave id alone, though
15:56:16 <mreh> I've just seen this heterogeneous list thing done with an exists... it seems more like a toy exaple than anything useful
15:56:31 <FunctorSalad> benmachine: do you have a reason why they all don't work?
15:56:37 <mreh> you've got a union of all the types, what interface is implemented by all the types?
15:56:38 <FunctorSalad> or just my example
15:56:46 <tensorpudding> Though you can use everywhere and mkT like some kind of gimpy fmap
15:56:52 <benmachine> FunctorSalad: I don't, no, but that doesn't mean one doesn't exist :)
15:56:56 <aavogt> gimpy?
15:57:04 <benmachine> I've very little experience in proofs of this nature
15:57:15 <aavogt> sometimes your data isn't regular
15:57:15 <tensorpudding> an "fmap" with type (Data a) => (a -> a) -> T a -> T a
15:57:18 <benmachine> but if you can find a counterexample then I will officially be impressed
15:57:30 <ddarius> If g is forall a. F a -> F a then g is a natural transformation and so g . fmap f = fmap f . g, so g . fmap f . g^-1 = fmap f . g . g^-1 = fmap f
15:57:36 <Saizan> mreh: existentials are quite nice, CPS all the time is not so great
15:57:38 <aavogt> sometimes your data isn't parameterized over all interesting elements
15:57:57 <aavogt> with instances of   FunctorN, to fmap the n'th type variable
15:58:44 <jmcarthur> (Data a) => (a -> a) -> Set a -> Set a   is definitely not going to make a valid fmap
15:59:01 <mreh> Saizan: but a CPS function with a 2nd order rank type is identical to the same function with the existential qualifier?
15:59:11 <aavogt> well you don't have a fmap for Set
15:59:20 <jmcarthur> you do if you have restricted functors
15:59:32 <jmcarthur> we just... dont' have that :)
16:00:14 <jmcarthur> we could create restricted functors in a couple ways. my favorite is with constraint families, which we also don't have
16:00:56 <jmcarthur> class Functor f where constraint FunctorC f a; fmap :: (FunctorC f a, FunctorC f b) => (a -> b) -> (f a -> f b)
16:01:14 <Saizan> mreh: "forall r. (forall a. T a -> r) -> r" is isomorphic to "exists a. T a" which is given in GHC haskell by "Exists T" where data Exists f = forall a. Exists (f a)
16:01:23 <jmcarthur> as long as there is a default definition for FunctorC then it's no extra work to make an instance, either
16:01:41 <aavogt> anyways, among all the spam: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=10084#a10084
16:01:43 <FunctorSalad> ddarius: I suspected it was just parametricity, but the relations formulations didn't let me see it... good idea to use the "it's a nat. transf." formulation
16:02:02 <FunctorSalad> ("relations" like ftshell outputs)
16:02:06 <jmcarthur> instance Functor Set where constraint FunctorC Set a = Ord a; fmap = Set.map
16:02:26 <aavogt> you and your imaginary language extensions
16:02:49 <aavogt> get them implemented already :)
16:02:55 <FunctorSalad> what would that do? save boilerplate over rmonad?
16:03:49 <FunctorSalad> automatically bring the Ord constraint into scope instead of forcing you to GADT pattern match?
16:04:00 <FunctorSalad> (that would be useful)
16:04:30 <Saizan> i'm only afraid of how these FunctorC f a constrains would propagate
16:05:13 <FunctorSalad> maybe type class variables would be simpler?
16:05:40 <Saizan> they can in general expose a lot of what you commonly consider implementation details when you use fmap
16:05:42 <FunctorSalad> instance Functor c f where fmap :: (c a, c b) => (a -> b) -> (f a -> f b)
16:05:43 <FunctorSalad> ;)
16:06:16 <EvanR> @src zip7
16:06:16 <lambdabot> Source not found. My pet ferret can type better than you!
16:06:37 <FunctorSalad> Saizan: "they" = type class variables?
16:06:56 <Saizan> that looks like you'd be able to write both instance Functor FooClass T; and instance Functor BarClass T
16:07:08 <FunctorSalad> my scheme seems like a mere preprocessor
16:07:26 <FunctorSalad> (of course I'm almost certainly overlooking the devil in the details again)
16:07:29 <Saizan> FunctorSalad: i was talcking of jmcarthur's proposal
16:07:35 <FunctorSalad> ahh
16:07:47 <Saizan> though i think ti applies to yours too.
16:08:15 <Saizan> and i'm not sure how you'd pick 'c'
16:08:27 <FunctorSalad> at instantiation?
16:08:38 <FunctorSalad> by that I mean in the instance declaration
16:09:06 <FunctorSalad> I guess you're thinking of instance decls for generic c... I can see complications there
16:09:10 <FunctorSalad> (type class classes)
16:09:20 <benmachine> Saizan: you could just call those overlapping
16:09:27 <FunctorSalad> doesn't mean that it wouldn't be useful for mono-classes :)
16:09:31 <Saizan> yeah, but what if you're writing a function that's polymorphic in some Functor f? or both f and g? what type would it have?
16:09:31 <benmachine> like instance FooClass t => Functor t would be overlapping
16:09:38 <Saizan> (where g is a functor too)
16:10:28 <benmachine> wait wait, jmcarthur's proposal doesn't have the class constraint as a parameter
16:10:38 <benmachine> so you still only have one functor per type
16:10:50 <Saizan> oh, i guess you can write (Functor c f, Functor d g, c a, d b) => ...
16:10:58 <Saizan> so yeah, that's basically the same thing
16:11:17 <FunctorSalad> Saizan: is the issue how 'c' is quantified?
16:12:11 <Saizan> FunctorSalad: the issue is that you expose those 'a' and 'b', which might not appear anywhere else in the type, because they were just intermediate types of a pipeline for example
16:12:23 <Saizan> but since you don't know what the constraint they must satisfy is
16:12:28 <FunctorSalad> I see how it would get complicated for anything past a macro that expands to FunctorOrd, FunctorEq and so on
16:12:32 <Saizan> you've to put it in the signature
16:12:38 <FunctorSalad> (typeclass inclusions...)
16:12:44 <aavogt> Saizan: addressed the incorrect fields update issue: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=10084#a10087
16:13:42 <Saizan> aavogt: ah, nice
16:13:53 <Saizan> with less uc it'd be nicer :)
16:14:02 <copumpkin> omg
16:14:11 <aavogt> if we don't export C, this is more or less proof that deriving(Data) => deriving (Functor)
16:14:13 <FunctorSalad> Saizan: and one doesn't have to same problem if one *does* know the constraint? (say, c = d = Ord)
16:14:48 <aavogt> Saizan: can something be done with higher rank polymorphism to make sure this doesn't get applied to Set?
16:15:02 <Saizan> FunctorSalad: yeah, you do if the types involved are polymorphic, but i was less worried about that :)
16:15:50 <copumpkin> aavogt: what's "this"?
16:15:57 <aavogt> copumpkin: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=10084#a10087
16:16:15 <copumpkin> omg
16:16:23 <aavogt> I think it probably breaks with some other functions
16:16:26 <FunctorSalad> aavogt: if you're using typeable already, isn't 'cast' enough? over unsafeCoerce
16:17:00 <aavogt> in particular ones that increase the size of the data being written
16:17:08 <copumpkin> aavogt: you already can't get Set into it as far as I can see
16:17:17 <FunctorSalad> Saizan: ok, with type class classes you get ambiguity issues even for `a' and `b' monotypes
16:17:29 <FunctorSalad> (for these intermediates in a pipeline)
16:17:48 <benmachine> if you have to use a where-clause to make the name of unsafeCoerce shorter, you're probably doing something very odd >_>
16:18:05 <aavogt> ooh, fmapData (replicate 100) seems to be ok
16:18:10 <aavogt> it is odd
16:18:27 <FunctorSalad> aavogt: it would make sense that deriving fmap in general should be hard, since it needs to know what the recursive positions are...
16:18:28 <aavogt> maybe stuff with strict fields
16:18:37 <FunctorSalad> (consider mutual recursion)
16:18:51 <benmachine> mutual recursion doesn't sound that hard
16:18:53 <FunctorSalad> or recursion inside another functor
16:19:01 <aavogt> this just defers to the Data instance for that trouble
16:19:08 <benmachine> make some rule that says, we can derive Functor for a if Functor for b
16:19:38 <benmachine> and then try to derive Functor for b assuming that you're successful
16:19:56 <FunctorSalad> aavogt: I don't see how you script distinguishes recursive and non-rec positions
16:20:05 <Saizan> FunctorSalad: if they are concrete types the problem is mostly that it's ugly to expose constraints for them, though i agree you can easily get with unresolvable contexts
16:20:09 <FunctorSalad> data Foo a = Foo (Foo a) (Foo Int)
16:20:14 <Saizan> s/with//
16:20:39 <snk_kid> what do you guys think about my answer: http://www.reddit.com/r/haskell/comments/bqajv/sdl_and_game_state_sdl_game_series_part_2/
16:21:04 <FunctorSalad> aavogt: won't it segfault for that? ;)
16:21:23 <FunctorSalad> at least if called at a = Int
16:21:23 <zygoloid> aavogt: given 'data T a = T Int', 'fmapData :: (Int -> b) -> T Int -> T b' maps the Int inside the T!
16:21:42 <Saizan> FunctorSalad, zygoloid: you missed the C thing, i think
16:22:01 <aavogt> zygoloid: is this different from my one?
16:22:05 <IceDane> How great are the chances of me running into problems with cabal and its cohorts if I try to install it with ghc 6.10.4 as opposed to 6.12.1 as is recommended?
16:22:16 <IceDane> Should I really upgrade ghc or downgrade to earlier version of cabal?
16:22:23 <aavogt> where we imaginarily tag all values that are the parameter
16:22:32 <aavogt> thus the   everywhere only goes to them
16:22:37 <zygoloid> Saizan: yeah, i missed the C thing :)
16:22:37 <Saizan> IceDane: Cabal the lib and cabal-install will both work on 6.10.4
16:22:41 <aavogt> :)
16:22:43 <FliPPeh> ghc: panic! (the 'impossible' happened) (GHC version 6.12.1 for x86_64-unknown-linux)
16:22:46 <FliPPeh> I BROKED IT
16:23:28 <zygoloid> good evil use of newtypes :)
16:23:44 <Saizan> it's quite magical how everywhere can see these non-existant tags :)
16:23:45 <FunctorSalad> Saizan: ok, the rightmost unsafeCoerce "fmap"s all the occurences of 'a' to 'C a'
16:24:12 <zygoloid> unsafeCoerce, the secret newtype fmapper
16:24:18 <aavogt> haha
16:24:24 <FunctorSalad> that's clever
16:24:41 <aavogt> FunctorSalad: are there any useful values of data Foo a = Foo (Foo a) (Foo Int) I can test?
16:24:42 <FunctorSalad> also abuses the identical binary rep, doesn't it...
16:24:56 <zygoloid> FunctorSalad: yeah
16:25:05 <FunctorSalad> aavogt: uh, needs a leaf case I suppose
16:25:18 <zygoloid> aavogt: let f = Foo f i; i = Foo i i in f
16:25:26 <aavogt> I'm not sure how this manages to have space for the additional data: three = fmapData (replicate 100) [1,2,3::Int]
16:25:33 <FunctorSalad> we don't want to complicate it by infinite data ;)
16:25:59 <FunctorSalad> aavogt: but now that I understand it it might well work for Foo
16:26:10 <aavogt> I'm applying (replicate 100) as if the type didn't change
16:26:15 <FunctorSalad> since it won't try to mess with the Int
16:26:27 <zygoloid> aavogt: why shoudn't that work?
16:26:28 <FunctorSalad> maybe "C Int" would be a prob, but that's willfull sabotage
16:26:45 <Saizan> aavogt: are you? don't you get three ::  [[Int]] ?
16:26:48 <aavogt> zygoloid: I'm concerned about what happens when the data is actually stored somewhere
16:26:49 <zygoloid> aavogt: the key is that the representation of 'f a' is uniform because a :: *
16:27:10 <blackdog> anyone know what the current champion of fast parsing in haskell is?
16:27:12 <Saizan> aavogt: you're building new cons cells anyway
16:27:45 <EvanR> snk_kid: its true game state, global counters, per-object counters, etc is a straight forward way to orchestrate a game, but really, there must be a high level way ;)
16:27:55 <EvanR> higher
16:28:12 <djahandarie> AI, probably
16:28:33 <Saizan> blackdog: attoparsec, i'd think
16:28:47 <snk_kid> EvanR: did you write those blog articles?
16:28:51 <blackdog> Saizan: cheers.
16:28:57 <EvanR> snk_kid: uhm no, which ones?
16:29:18 <aavogt> Saizan, zygoloid: I'm uncertain about it working because it isn't clear to me that the data representation doesn't depend on the type
16:29:29 <blackdog> (had an idea last night - if I can provide a clone of something like Treetop in Ruby using Haskell to do the heavy lifting through hubris, i'd have both a good stress test and a use case... :)
16:29:43 <zygoloid> aavogt: well, if it did you couldn't write functions of type 'forall a. Foo a'
16:30:18 <aavogt> would this be useful on hackage?
16:30:30 <zygoloid> aavogt: functions need to be able to operate polymorphically over the contained type, therefore the representation must be uniform
16:30:37 <aavogt> or possibly to simplify ghc's -XDerivingFunctor?
16:30:47 <snk_kid> EvanR: the one i made on comment on in that link, well I don't think the guy is going to use FRP for his/her game-logic so avoiding state monads is going to be painful for him/her eventually
16:30:55 <zygoloid> are there cases where GHC can derive Data but not Functor?
16:31:02 <aavogt> though going through Data may be slower?
16:31:18 <FunctorSalad> aavogt: pasted a nice finite example value ;)
16:31:26 <FunctorSalad> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=10084#a10091
16:31:29 <EvanR> snk_kid: its true that a game has *state* but is it necesarily complex state, and is frp the only alternative
16:31:34 <FunctorSalad> I think DarkFoo may break it
16:32:09 <FunctorSalad> aavogt: might be avoided by not exporting C
16:32:30 <aavogt> yeah, C is not for general consumption
16:32:36 <FunctorSalad> and calling it "IfYouCanSeeThisTypeDueToSomeLoopholeDoNotUseItAnywhere"
16:32:38 <Saizan> aavogt: going through Data is almost surely slower, especially if you aren't clever about avoiding traversing unaffected parts like Uniplate does
16:33:28 <snk_kid> EvenR: well I don't know what he/she is planing on doing. I don't know of another option other than inventing some DSL
16:33:32 <aavogt> true
16:33:48 <FunctorSalad> btw multirec can derive fmap and more safely...
16:34:00 <FunctorSalad> if your type works for it ;)
16:34:01 <EvanR> everything can be considered a DSL
16:34:15 <copumpkin> where your specific domain is general computation?
16:34:21 <FunctorSalad> (I wrote that extended deriver but maybe it has bitrotten already)
16:34:30 <EvanR> the specific problem at hand
16:34:42 <aavogt> I think there were some concerns over how to derive Functor over functions
16:35:17 * copumpkin wants moar contrafunctor
16:35:28 <FunctorSalad> less is more with them
16:35:29 <FunctorSalad> o_O
16:35:45 <copumpkin> zomg :: (a -> b) -> (f b -> f a)
16:36:11 <zygoloid> gmoz :: (f a -> f b) -> (b -> a)
16:36:19 <copumpkin> now that would be impressive
16:36:53 <hpc> haha
16:36:54 <ddarius> copumpkin: And then you'd want bifunctors and functors of mixed variance and free variant and invariant functors and so forth.  When will it end?
16:36:54 <FunctorSalad> that's the proof of a functor being full, sort-of
16:37:00 <FunctorSalad> except it isn't checked
16:37:21 <copumpkin> ddarius: never!
16:37:41 <copumpkin> haskell can be the first language with an infinite (lazy) standard library
16:37:41 <FunctorSalad> product cats and dual cats would be a general solution for that...
16:37:55 <FunctorSalad> but they're awkward now
16:37:58 <copumpkin> we'll have cocode
16:38:06 <FunctorSalad> (and impossible with Control.Category, I think)
16:38:17 <FunctorSalad> since Hask * Hask is restricted to actual product types
16:38:26 <contrafunktal> @faq is the standard library infinite?
16:38:26 <lambdabot> The answer is: Yes! Haskell can do that.
16:39:05 <Jafet> Preludes all the way down
16:39:17 <copumpkin> I thought it was four elephants on the back of a giant turtle
16:39:30 <Jafet> That's the logo standard library
16:39:37 <FunctorSalad> it'd be possible with categories that are constrained by requiring a GADT witness
16:39:39 <copumpkin> oh
16:39:51 <copumpkin> FunctorSalad: like rmonad?
16:39:58 <FunctorSalad> (as I (impractically) did in some package)
16:40:11 * copumpkin eats FunctorSalad 
16:40:13 <FunctorSalad> copumpkin: hmm
16:40:29 <copumpkin> that's one reaction to being eaten
16:40:29 <FunctorSalad> copumpkin: yes seems like it should work
16:40:58 <FunctorSalad> since with a GADT constraint you can know that your type is a product type
16:41:44 <FunctorSalad> data ProductProof x where P :: ProductProof (a,b)
16:42:32 <Eelis> how do you get a synopsis for a module with haddock?
16:42:37 <zygoloid> data F a = forall r. Wrap { unwrap :: a -> r }; gmoz g b = unWrap (g Wrap) b
16:42:44 * benmachine notices a reddit post marked 1 point 37 minutes ago and thinks this is a rather pedantic level of accuracy
16:42:53 <FunctorSalad> Eelis: haddock comment on the module statement?
16:43:18 <Eelis> FunctorSalad: i'll try
16:43:59 <Eelis> FunctorSalad: by "on" do you mean "above" ?
16:44:20 <FunctorSalad> Eelis: yes ('-- |'-style)
16:44:39 <FunctorSalad> never tried '-- ^' after an explicitly-layout'd module
16:44:40 <FunctorSalad> ;)
16:46:01 <EvanR> http://dpaste.com/183560/
16:47:06 <snk_kid> > < <$> Just 3 <*> Just 4
16:47:07 <lambdabot>   <no location info>: parse error on input `<'
16:47:15 <snk_kid> > (<) <$> Just 3 <*> Just 4
16:47:16 <lambdabot>   Just True
16:47:26 <zygoloid> > Nothing < Just 42
16:47:27 <lambdabot>   True
16:47:34 <EvanR> ._.
16:47:56 <EvanR> im trying to use Maybe to mean 'At x' or 'Never'
16:47:59 <Eelis> FunctorSalad: hm, the synopsis is only generated if i add "-- | hm" above any of the functions in the module.. peculiar
16:48:18 <copumpkin> EvanR: why not data Time a = At a | Never ?
16:48:28 <EvanR> good idea
16:48:34 <EvanR> Time isnt taken?
16:49:04 <Eelis> FunctorSalad: so haddock appears to have a rule along the lines of: "if none of the functions in the module has a haddock comment, then the module doesn't get a synopsis listing signatures either", which seems pretty bizarre to me
16:49:34 <Eelis> why would these two things be related?
16:49:58 * contrafunktal has added this fmapData here: http://haskell.org/haskellwiki/Scrap_your_boilerplate  mostly for inspiration
16:51:15 <FunctorSalad> Eelis: are you exporting the functions?
16:51:24 <FunctorSalad> thought it ignores the altogether otherwise
16:51:29 <FunctorSalad> unless you use --internal or so
16:51:36 <FunctorSalad> *ignores them
16:52:30 <Eelis> FunctorSalad: yes, i'm exporting them
16:57:26 <EvanR> how can i tell the minimum interface to implement for a class
16:57:49 <ddarius> You read the documentation.
16:57:56 <byorgey> EvanR: good question.  The answer is, read the documentation and pray that it is right.
16:58:03 <EvanR> guess Ord is in haskell report
16:58:06 <ddarius> byorgey: Or just implement everything.
16:58:37 <alpounet> @src Ord -- works too
16:58:38 <lambdabot> Source not found. Wrong!  You cheating scum!
16:58:43 <alpounet> oh come on
16:58:46 <alpounet> @src Ord
16:58:46 <lambdabot> class  (Eq a) => Ord a  where
16:58:46 <lambdabot>     compare      :: a -> a -> Ordering
16:58:46 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
16:58:46 <lambdabot>     max, min         :: a -> a -> a
16:59:15 <EvanR> seems like i should only have to implement <
16:59:16 <alpounet> for the minimality... well, read the report / docs.
16:59:32 <byorgey> IIRC the minimum interface for Ord is either compare or (<=)
16:59:32 <EvanR> and what on earth is wrong with this webpage http://www.zvon.org/other/haskell/Outputprelude/Ord_c.html
16:59:38 <byorgey> EvanR: you would think that, but it doesn't work =(
16:59:48 <FunctorSalad> Eelis: time for search+replace? ;)
17:00:11 <FunctorSalad> (decl = zeroth-column identifier in haskell?)
17:00:38 <byorgey> EvanR: yep, compare is implemented in terms of (<=), and vice versa, so you must implement one of those two
17:00:46 <EvanR> ok
17:01:13 <FunctorSalad> actually that rule seems pretty accurate for a syntax hackjob
17:01:28 <FunctorSalad> as long as manual layout / braces aren't being used
17:02:27 <FunctorSalad> you'd just have to group a signature with its value decl
17:03:00 <ams100272> question about breadth-first traversal of infinite trees
17:04:16 <ams100272> hello?
17:04:26 <hpc> ask the question first lol
17:04:35 <ams100272> all right...
17:04:40 <blackdog> ams100272: your question is already in WHNF
17:04:41 <blackdog> :)
17:04:54 <ams100272> basically I have a tree of all the ints, in positional order
17:05:12 <ams100272> like 1, 2 3 as the children, then 4 5 6 7, etc.
17:05:31 <byorgey> ams100272: ok
17:05:34 <ams100272> AFAICT this tree is OK -- built using an infinitely recurring function
17:05:56 <ams100272> anyway, I want to BFT the thing, taking advantage of the fact you can do this in hask.
17:06:12 <ams100272> so I write something like (take 100 (bft z))
17:06:18 <ams100272> -- z is the name of the tree
17:06:33 <ams100272> my bft works on finite trees, but spins on the infinite tree
17:06:35 <ams100272> any ideas why?
17:07:22 <blackdog> ams100272: might be easier if you posted to hpaste or something.
17:07:36 <byorgey> hpaste is down, try pastebin.com or something else
17:07:47 <ams100272> cool...I'll check out pastebin thx
17:07:58 <byorgey> ams100272: yeah, without seeing your definition of bft it's hard to know
17:08:14 <EvanR> so to use + with my data type, i must also be able to negate? what if i dont have negatives
17:08:26 <byorgey> just  negate = undefined
17:08:32 <EvanR> @src Num
17:08:32 <lambdabot> class  (Eq a, Show a) => Num a  where
17:08:32 <lambdabot>     (+), (-), (*)           :: a -> a -> a
17:08:32 <lambdabot>     negate, abs, signum     :: a -> a
17:08:32 <lambdabot>     fromInteger             :: Integer -> a
17:08:34 <byorgey> the Num class is kind of dumb like that.
17:09:01 <byorgey> better yet,  negate = error "negation is undefined for Foos"
17:09:23 <EvanR> what are the minimal operations here
17:09:30 <ams100272> thanks all -- http://pastebin.com/5g86AS0t
17:10:01 <byorgey> EvanR: I think (-) is implemented in terms of (+) and negate, but other than that everything is independent
17:10:09 <byorgey> so leaving out things that don't make sense won't hurt anything
17:10:18 <hpc> * can be done in terms of + if they are integers
17:10:20 <Saizan> ams100272: you should rewrite your bft in a non-accumulator style
17:10:29 <lispy> byorgey: what do you mean by won't hurt?
17:10:31 <ams100272> Saizan: why?
17:10:43 <tensorpudding> Why do you want to define a Num instance for something that doesn't at least follow the ring axioms?
17:10:47 <lispy> Also, I think signum is weird and has to be defined
17:11:03 <alpounet> @type signum
17:11:04 <lambdabot> forall a. (Num a) => a -> a
17:11:13 <hpc> @src signum
17:11:14 <lambdabot> Source not found. Where did you learn to type?
17:11:16 <byorgey> ams100272: your bft will never return anything until the queue is empty
17:11:21 <EvanR> tensorpudding: to use + ?
17:11:21 <lispy> signum makes the polynomial instance for Num a little weird.  I guess signum = degree in that case
17:11:27 <Saizan> ams100272: otherwise you'd have to get to an empty tq before you can see any result, i.e. your bft is not lazy enough as it is written to work on infinite values
17:11:47 <ams100272> byorgey: aha! thanks...what a great observation. I'll try to fix
17:11:50 <byorgey> lispy: I'm pretty sure I've left out signum before.
17:11:54 <ams100272> Saizan: same applies
17:12:11 <tensorpudding> there's Monoid for that, I would say
17:12:12 <byorgey> lispy: I just meant that leaving things out won't affect the proper functioning of the things you DO define
17:12:14 <EvanR> yes
17:12:22 <EvanR> but its mappend, not +!
17:12:42 <lispy> byorgey: It's been years, but when I made an instance of for Num a => Num [a], I think I had to provide signum.  I recall not enjoying that part :)
17:12:50 <byorgey> hehe =)
17:13:04 <byorgey> I mean, you have to put SOMETHING or else it complains
17:13:09 <tensorpudding> But Num has so much baggage in it that something that only follows the monoid axioms cannot adequately define
17:13:10 <byorgey> but you should be able to put undefined or error
17:13:13 <Draconx|Laptop> lispy, surely signum = const 1 and abs = id would be fine?
17:13:14 <lispy> Oh
17:13:35 <EvanR> i can naturally define all Num methods
17:13:45 <EvanR> but i would like to restrict negatives
17:13:53 * hackagebot setops 0.1 - Uniform names (and Unicode operators) for set operations on data structures.  http://hackage.haskell.org/package/setops-0.1 (eelis)
17:13:59 <lispy> Draconx|Laptop: I think I used the degree of the polynomial
17:14:01 <alpounet> EvanR, is it your time thing ?
17:14:07 <EvanR> yes
17:14:17 <byorgey> ams100272: your bft function is tail recursive, but in a lazy language tail recursion is not really what you want.
17:14:22 <tensorpudding> Are there any implicit assumptions that functions make regarding Num instances following ring axioms?
17:14:43 <byorgey> ams100272: what you really want is "guarded recursion", where each recursive call occurs underneath (is "guarded by") a data constructor
17:15:02 <Draconx|Laptop> tensorpudding, they shouldn't, because the report defines Num instances that do not satisfy the ring axioms.
17:15:20 <byorgey> ams100272: e.g. map f [] = []; map f (x:xs) = f x : map f xs  uses guarded recursion since the recursive call to 'map' occurs as an argument to the (:) constructor
17:15:22 <tensorpudding> Which ones are those?
17:15:26 <ams100272> *Main> take 10 (bft z)
17:15:28 <ams100272> [1,2,3,4,5,6,7,8,9,10]
17:15:34 <ams100272> -- yay!
17:15:39 <Draconx|Laptop> tensorpudding, Float and Double, to name two.
17:15:40 <byorgey> ams100272: nice!
17:15:41 <ams100272> thanks you guys are as helpful as your reputation
17:16:11 <EvanR> if Num were supposed to be a ring, it should have been called Ring
17:16:13 <EvanR> ;)
17:16:15 <byorgey> ams100272: glad to help =)
17:16:17 <ams100272> I have an ML accent
17:16:17 <tensorpudding> Do they fail to satisfy the distributive law?
17:16:26 <byorgey> ams100272: hehe =)
17:16:43 <ams100272> there is one thing I wonder about now, sort of a dual of the problem I just fixed
17:16:45 <EvanR> i think floating point doesnt have a working distributive law
17:16:53 <pikhq> tensorpudding: Well, NaN != NaN. :P
17:16:54 <Draconx|Laptop> tensorpudding, the only laws they satisfy are identity and commutativity.
17:17:03 <ams100272> so my new bfts has no empty queue case...
17:17:34 <tensorpudding> So (a - a) = 0 isn't guaranteed?
17:17:35 <ams100272> I'm guessing if I make deq return Nothing or Just (elt, q)
17:17:39 <lispy> IEEE 754 does approximately satisfy the laws, right?
17:17:44 <byorgey> ams100272: so it crashes on finite trees?
17:17:47 <ams100272> then I can stop when I reach the end of a non-infinite tree
17:17:52 <Draconx|Laptop> > let x = 1/0 in x - x
17:17:53 <lambdabot>   NaN
17:17:53 <ddarius> lispy: Define "approximately"
17:17:54 <ams100272> @byorgey right
17:17:54 <lambdabot> Unknown command, try @list
17:17:55 <Draconx|Laptop> tensorpudding, ^^
17:18:01 <lispy> If so, maybe that's good enough because they are approximate reals
17:18:04 <tensorpudding> 1/0 isn't a number.
17:18:10 <Draconx|Laptop> tensorpudding, it is a floating point number.
17:18:10 <tensorpudding> That doesn't count.
17:18:10 <lispy> ddarius: up to precision/rounding
17:18:12 <gwern> infamous!
17:18:31 <byorgey> ams100272: I think you should just be able to add a case to check for empty
17:18:46 <EvanR> lispy: they are exactly certain reals
17:18:58 <lispy> but not exactly all reals
17:19:01 <EvanR> except NaN
17:19:01 <ddarius> lispy: The amount of precision changes with operations.
17:19:04 <EvanR> Inf
17:19:13 <byorgey> ams100272: it wasn't the check for empty per se that was the problem
17:19:19 <ams100272> @byorgey right of course -- yes, that works
17:19:19 <lambdabot> Unknown command, try @list
17:19:50 <ams100272> the Haskell way of thinking is different...I'm not used to it.
17:20:02 <byorgey> it definitely takes some getting used to.
17:20:03 <kmc> IRC =/= Twitter
17:20:29 <tensorpudding> @check (\x y -> y * (x - x) == 0) :: Float -> Float -> Bool
17:20:29 <lambdabot>   Couldn't match expected type `GHC.Types.Float
17:20:30 <byorgey> hehe, ams100272, lambdabot thought you were trying to use the @byorgey command
17:20:34 <tensorpudding> err
17:20:35 <byorgey> sadly there is no such command
17:20:39 <tensorpudding> @check (\x y -> y * (x - x) == 0) :: RealFloat -> RealFloat -> Bool
17:20:39 <lambdabot>   Class `GHC.Float.RealFloat' used as a type
17:20:48 <ams100272> @by very cool. if you don't mind the question where (on earth) are you?
17:20:48 <lambdabot>  Done.
17:20:50 <tensorpudding> @check (\x y -> y * (x - x) == 0) :: Double -> Double -> Bool
17:20:51 <lambdabot>   Couldn't match expected type `GHC.Types.Double
17:20:54 <lispy> EvanR:  Well the reals are not computable, so it has to be an approximation
17:21:06 <mauke> ams100272: please stop sending random commands to lambdabot :-/
17:21:17 <lispy> ?bf ++..<>...
17:21:17 <lambdabot>  Done.
17:21:18 <Saizan> byorgey: mmh, we could make one that answers combinatorics questions :)
17:21:27 <byorgey> Saizan: hehe, be my guest =)
17:21:34 <EvanR> lispy: youre trying to say the set of double precision is an approximation to the set of reals, well, its a pretty bad one ;)
17:21:45 <byorgey> ams100272: I'm in Philadelphia, Pennsylvania, USA
17:21:56 <ams100272> right on. in chicago here.
17:22:04 <lispy> EvanR: Right, but it's still useful
17:22:05 <Draconx|Laptop> tensorpudding, falsifiable, after 1 test: x = infinity, y = 0
17:22:06 <hpc> DC here
17:22:26 <tensorpudding> @type NaN
17:22:27 <lambdabot> Not in scope: data constructor `NaN'
17:22:52 <ams100272> thx all. you've improved my lazy evaluation lecture coming up soon...
17:22:57 <ams100272> (subbing for a haskell class)
17:22:58 <tensorpudding> What do you mean by infinity?
17:23:03 <Draconx|Laptop> > 1/0
17:23:04 <lambdabot>   Infinity
17:23:12 <tensorpudding> @type (1/0)
17:23:13 <lambdabot> forall t. (Fractional t) => t
17:23:17 <tensorpudding> Okay, fair
17:23:19 <hpc> it's a possible value of IEEE floats
17:23:38 <hpc> as is negative infinity, NaN, -NaN, and -0
17:24:37 <EvanR> denormal zero
17:24:49 <byorgey> ams100272: excellent, have fun =)
17:24:55 <Draconx|Laptop> EvanR, zero is _always_ subnormal.
17:25:08 <Draconx|Laptop> (though it's usually classified separately)
17:27:47 <EvanR> besides 1/0 - 1/0 pickyness, i think i heard that distributive doesnt work even for floating real numbers
17:28:36 <orlandu63> is (:) a data constructor?
17:28:40 <hpc> floating point math can lose a lot of precision
17:28:41 <pikhq> Yes.
17:28:42 <Draconx|Laptop> EvanR, yes, because many operations are inexact.
17:29:03 <EvanR> floating point is black magic!
17:29:08 <EvanR> give me my integers
17:29:16 <hpc> give me CReal
17:29:23 <Draconx|Laptop> hpc, give me performance!
17:29:27 <hpc> haha
17:29:39 <tensorpudding> I thought the floating points, with a given precision, were accurate.
17:29:56 <byorgey> orlandu63: yes, it is one of the data constructors for lists.
17:30:00 <hpc> > 1/3
17:30:01 <lambdabot>   0.3333333333333333
17:30:03 <EvanR> Int is an abomination
17:30:15 <Draconx|Laptop> > 1 + 5e-324 :: Double
17:30:16 <lambdabot>   1.0
17:30:18 <EvanR> unless you are doing modular arith
17:30:19 <Draconx|Laptop> tensorpudding, see above.
17:30:24 <tensorpudding> You can only represent rational numbers with finite decimal representations.
17:30:36 <hpc> you lose precision on much less pathological cases though
17:30:56 <Draconx|Laptop> er, I guess:
17:31:01 <Draconx|Laptop> > 1 + 5e-324 == 1
17:31:02 <lambdabot>   True
17:31:04 <Draconx|Laptop> is more clear.
17:31:32 <tensorpudding> > 1 + 0.001
17:31:33 <lambdabot>   1.001
17:31:43 <EvanR> > 1 + 0.1
17:31:44 <lambdabot>   1.1
17:31:44 <tensorpudding> So does it just ignore precision past a given point?
17:31:53 <EvanR> 1.1 is not correct
17:32:00 <hpc> look up IEEE floats
17:32:02 <EvanR> > -1 - 0.1
17:32:03 <lambdabot>   -1.1
17:32:11 <hpc> they are bamboozling, to say the least
17:32:13 <tensorpudding> > 5e-324 + 8e-185
17:32:14 <lambdabot>   8.0e-185
17:32:27 <tensorpudding> > 5e-324 + 8e-324
17:32:28 <lambdabot>   1.5e-323
17:33:10 <hpc> even accountants use fixed point numbers for their arithmetic, and they don't even go past 4 decimal places
17:33:11 <EvanR> if you operate on two numbers, the result is as close as possible to the real answer
17:33:36 <Draconx|Laptop> where "as close as possible" depends on the rounding direction.
17:34:01 <EvanR> 1 + 0.1 -> 1.1000000000000001
17:34:03 <tensorpudding> Regarding the original statement, I'd say that Num is overkill if you just want (+)
17:34:07 <EvanR> if i use another interpreter
17:34:35 <EvanR> im implementing all of Num
17:34:39 <hpc> > 1+0.1 :: Float
17:34:40 <lambdabot>   1.1
17:34:51 <EvanR> the only problem with Monoid is the operation is spelled mappend
17:34:53 <tensorpudding> Hmm.
17:35:04 <tensorpudding> > negate (50 :: Word16)
17:35:04 <lambdabot>   65486
17:35:31 <tensorpudding> > negate (1/0)
17:35:32 <lambdabot>   -Infinity
17:35:40 <hpc> >negate 0
17:35:48 <tensorpudding> > (negate (1/0)) + (1/0)
17:35:49 <lambdabot>   NaN
17:35:50 <hpc> > negate (0 :: Float)
17:35:51 <lambdabot>   -0.0
17:35:55 <orlandu63> @type Infinity
17:35:56 <lambdabot> Not in scope: data constructor `Infinity'
17:36:01 <orlandu63> what
17:36:05 <tensorpudding> Har, negative 0...
17:36:14 <hpc> those are hardcoded strings in show
17:36:17 <hpc> not constructors
17:36:31 <orlandu63> oh
17:36:39 <tensorpudding> > (negate 0.0) == 0.0
17:36:40 <lambdabot>   True
17:36:47 <tensorpudding> > (negate (0.0 :: Float)) == 0.0
17:36:48 <lambdabot>   True
17:37:31 <tensorpudding> You could name your function something else, that is more similar to (+)
17:37:48 <hpc> or do something like +' = mappend
17:37:54 <hpc> then use +' instead
17:38:09 <EvanR> ah
17:38:15 <EvanR> then it will still be a monoid
17:38:18 <kmc> why not ++ = mappend
17:38:20 <EvanR> liking this
17:38:26 <EvanR> ++ is defined in the prelude
17:38:29 <kmc> so hide it
17:38:34 <EvanR> thats annoying
17:38:34 <kmc> :t (++)
17:38:35 <hpc> :t (++)
17:38:35 <lambdabot> forall m. (Monoid m) => m -> m -> m
17:38:36 <lambdabot> forall m. (Monoid m) => m -> m -> m
17:38:38 <hpc> ah
17:38:44 <Twey> Shadow it, hide it, pick it up and bounce it~
17:38:57 <Twey> hpc: That's not the Prelude (++)
17:39:16 <hpc> oh right D:
17:39:29 <Draconx|Laptop> {-# LANGUAGE NoImplicitPrelude #-} :P
17:39:31 <Twey> Cale souped it up 
17:39:54 <hpc> you don't need the pragma, you can just import Prelude hiding (++)
17:40:25 <hpc> and [] is an instance of Monoid, so why not use the general version in Prelude?
17:40:27 <tensorpudding> I think I defined a function as (+!+) once
17:41:57 <hpc> it also doesn't make sense to have lift and liftIO
17:42:13 <hpc> when both do the same thing in IO contexts
17:44:20 <EvanR> and mapM !!!!111
17:45:05 <EvanR> if map worked on any monoid, it would work on lists too
17:45:07 <hpc> and fmap should just be map
17:45:08 <EvanR> err monad
17:45:09 <hpc> yeah
17:46:19 <EvanR> haskell is broken?!?!
17:46:23 <EvanR> lol
17:46:47 <tensorpudding> @type map
17:46:48 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
17:47:11 <EvanR> :t mapM
17:47:12 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
17:47:15 <EvanR> :t fmap
17:47:16 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:53:01 <EvanR> what is signum :: a -> a supposed to do
17:53:05 <Mathnerd314> @type Data.Traversable.mapM
17:53:06 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
17:53:50 <byorgey> EvanR: it's supposed to return -1, 0, or 1 depending on the sign of the argument
17:54:01 <EvanR> whats signum Never
17:54:17 <byorgey> EvanR: but of course the idea of a sign only applies to rings.
17:54:43 <EvanR> well, i think this is a ring
17:54:53 <Draconx|Laptop> it doesn't really apply to a lot of rings, either.
17:55:25 <lispy> > signum (-1)
17:55:26 <lambdabot>   -1
17:55:34 <lispy> > signum (1 :+ 2)
17:55:35 <lambdabot>   0.4472135954999579 :+ 0.8944271909999159
17:55:52 <byorgey> Draconx|Laptop: Yeah, I guess you're right.
17:55:54 <ksf> do we have packages for IO testing?
17:55:56 <EvanR> man who came up with this interface
17:56:09 <Draconx|Laptop> EvanR, if you can't define it meaningfully, "const 1" is perfectly valid.
17:56:14 <lispy> ksf: wouter swiestra wrote something for that, with an ICFP paper IIRC
17:56:16 <ksf> I'm interested in files and sockets, mostly.
17:56:31 <lispy> ksf: oh, then maybe you want HUnit
17:56:31 <ksf> iospec?
17:56:38 <lispy> ksf: ah yeah, that's the name
17:57:12 <lispy> it looks like the signum for complex numbers is the magnitude
17:57:33 <Draconx|Laptop> lispy, it's the complex number with the same argument but unit magnitude.
17:57:35 <lispy> > signum (0 :+ 1)
17:57:35 <lambdabot>   0.0 :+ 1.0
17:57:50 <EvanR> its x / |x|
17:57:58 <lispy> yeah, I guess that's what I meant
17:58:05 <lispy> the normalized vector version
17:58:07 <Mathnerd314> > signum (0 :+ 0)
17:58:08 <lambdabot>   0.0 :+ 0.0
17:58:21 <Draconx|Laptop> plus some special cases :P
17:58:24 <lispy> when I said jsut the magnitude that was wrong because the magnitude would be just a real
17:58:46 <Mathnerd314> how would you define it for a finite field?
17:59:02 <EvanR> 1, 0, or....
17:59:03 <Draconx|Laptop> "sign" only really makes sense for subrings of R, probably.
17:59:35 <EvanR> -1 for elements less than zero ;)
17:59:46 <lispy> Mathnerd314: the same way you define it for polynomial rings?  (which is to say, I don't know the proper way)
17:59:48 <EvanR> so youd need order
17:59:59 <lispy> signum is really all about ordder
18:00:11 <lispy> So, really it should be class Ord a => Num a where...
18:00:14 <lispy> I guess...
18:00:19 <Draconx|Laptop> good lord no.
18:00:23 <Draconx|Laptop> Eq and Show are bad enough!
18:00:33 <lispy> Then let's remove signum from Num!
18:00:51 <EvanR> suddenly a crowd of haskellers with torches and pitchforks appears
18:00:57 <lispy> hehe
18:01:22 <lispy> Yeah, this comes up a lot actually
18:01:22 <lispy> Num != Ring
18:01:24 <lispy> There was a GSoC proposal this year for it too, IIRC
18:01:34 <Draconx|Laptop> anyway, the complex definitions of signum and abs are quite reasonable, and the Ord constraint would kill them.
18:02:15 <lispy> We'd just order Complex by their magnitudes :)
18:02:29 <Mathnerd314> class Signum a where..., class Signum a => Num... :-)
18:03:02 <lispy> Mathnerd314: right, that's a better approach
18:03:06 <Mathnerd314> any typeclass with more than one function is too big!
18:03:10 <EvanR> if signum DID always return -1, 0, or 1, which it doesnt for Complex, it could be used to derive an order ;)
18:06:04 <lispy> signum x = x / abs x, works for all the instances in the prelude modulo abs x = 0, right?
18:06:08 <Draconx|Laptop> frankly, I don't see what's wrong with signum = const 1 and abs = id, for types where those functions don't make sense.
18:06:22 <Draconx|Laptop> lispy, x = signum x * abs x is a better rule.
18:07:36 <lispy> Draconx|Laptop: Hmm...okay, but I wanted to actually defined signum in terms of x and abs :)
18:08:00 <lispy> Maybe that would lead to a more natural definition for the polynomial ring
18:08:03 <Draconx|Laptop> unfortunately, the floating point instances don't satisfy that rule for a dumb reason.
18:08:34 <lispy> :t signum
18:08:35 <lambdabot> forall a. (Num a) => a -> a
18:08:47 <lispy> :t abs
18:08:48 <lambdabot> forall a. (Num a) => a -> a
18:09:00 <lispy> I guess signum for polynomial could be map signum
18:09:29 <lispy> (assuming the polynomial supports map like a list does)
18:10:04 <lispy> > abs (1 :+ 1)
18:10:05 <lambdabot>   1.4142135623730951 :+ 0.0
18:10:50 <lispy> I guess it just gets hard to compute.
18:11:17 * lispy heads out
18:11:27 <Mathnerd314> you want things like abs(x y)=abs(x)*abs(y), yes?
18:13:36 <Mathnerd314> then map signum doesn't work for polynomials: (x-1)(x+1)=x^2-1 but (x+1)(x+1)=x^2+2x+1
18:14:29 <EvanR> how do i use (a,a) as a vector space
18:14:37 <EvanR> + -, * by scalar
18:15:06 <EvanR> .+ .- .* ;)
18:27:00 <contrafunktal> EvanR: use  Complex a   instead of (a,a)?
18:31:52 <BMeph> Complex a is a lie! It disallows Gaussians...and for that, I will never forgive. :|
18:32:57 <tensorpudding> You could define your own Gaussian integers/rationals
18:33:54 <ozataman> how can I convert NominalDiffTime to Integer?
18:37:44 <tensorpudding> You can't define a Num instance for it without fudging though.
18:38:07 <ksf> ozataman, you can't, as it's not really reasonable
18:38:17 <ksf> you can use toRational, though
18:38:23 <ozataman> ksf: thanks.. i guess fromEnum would work here
18:38:34 <ksf> yep, but toEnum is Int only
18:38:42 <ksf> (which is a misfeature)
18:38:51 <ozataman> ksf: ah I didn't know that.. but it'll do here
18:38:53 <ozataman> ksf: thanks!
18:39:32 <ksf> it's probably an enum instance for succ and pred
18:39:49 <ksf> ...though goodness knows what'll happen to microseconds, there.
18:39:57 <Draconx|Laptop> BMeph, this seems more like a fundamental language limitation, since it requires both "Complex Double" and "Complex Integer" to use the same instances.
18:39:59 <BMeph> length giving an Int instead of a Word, and the lack of a Natural counter-part to Integer, is also a fail in my eyes.
18:40:33 <ksf> ozataman, you can also use round, ceiling, floor, truncate etc.
18:40:44 <ksf> which are probably what you want, if you want seconds.
18:41:05 <ozataman> ksf: yeah, that is what I want.. so you're saying I should do ceiling . toRational
18:41:25 <ksf> no need for toRational, there.
18:50:28 <EvanR> Complex a, eh
18:52:50 <langtree> Why is gcd a standalone function rather than part of the class definition with a default implementation ?
18:53:18 <EvanR> isnt it an algorithm that works for anything with division
18:53:40 <contrafunktal> @type gcd
18:53:41 <lambdabot> forall a. (Integral a) => a -> a -> a
18:53:44 <langtree> I mean, it makes it hard to define a type that implements variables.
18:54:25 <contrafunktal> but once you implement Integral, you get gcd for free
18:55:01 <langtree> Yeah, but if you have a type that implements variables, you don't know the values of the variables, so gcd fails to terminate.
18:55:15 <langtree> Or, == fails or something.
18:55:43 <contrafunktal> what is this type?
18:56:42 <EvanR> > 1 :+ 1
18:56:43 <lambdabot>   1.0 :+ 1.0
18:56:52 <EvanR> > 2*(1 :+ 1)
18:56:53 <lambdabot>   2.0 :+ 2.0
18:57:02 <EvanR> > (1 :+ 1) + (1 :+ 1)
18:57:03 <lambdabot>   2.0 :+ 2.0
18:57:08 <EvanR> > (1 :+ 1) * (1 :+ 1)
18:57:09 <lambdabot>   0.0 :+ 2.0
18:57:15 <EvanR> > (1 :+ 1) / (1 :+ 1)
18:57:16 <lambdabot>   1.0 :+ 0.0
18:57:53 <EvanR> how does a*(a :+ a) work
18:57:56 <langtree> It's a type I tried to make a few months ago.  Like data Var = Var String; data Expr = Value Integer | Unknown Var | Plus Expr Expr | Minus Expr Expr | ...
18:58:16 <byorgey> EvanR: the constant '2' is polymorphic, it's actually 'fromIntegral 2'
18:58:21 <EvanR> ah
18:58:23 <byorgey> so it converts the 2 to Complex first
18:58:25 <langtree> I probably did a better job than that, but I couldn't "override" gcd, though I could handle lots of other things.
18:58:29 <EvanR> that is tricky
18:59:14 <byorgey> langtree: ah, yes, I see, that's annoying
18:59:38 <contrafunktal> right, then just don't import it
18:59:43 <contrafunktal> import Prelude hiding (gcd)
19:00:27 <byorgey> if anyone feels like staring at a strange type error with type families + type classes, I'd appreciate any suggestions: http://pastebin.com/h7BhE4rc
19:01:00 <byorgey> All the type arguments to (*.*) ought to collapse to v, so I don't know why it's complaining about u
19:01:38 <contrafunktal> diagrams :)
19:01:45 <byorgey> indeed =)
19:02:54 <EvanR> so Complex a is better for 2d coords than (a,a)
19:02:58 <EvanR> what about 3d vector
19:03:57 <byorgey> EvanR: you might want to check out the vector-space package.  Although it might be a bit overkill depending on what you're trying to do.
19:04:40 <EvanR> nah, if i was in 3d i would probably need a full package for cross products, angle, geometry
19:04:47 <EvanR> 2d is simpler
19:10:56 <Gray_> Could someone help me with a quick syntax question? Is it possible to use nested where definitions?
19:11:18 <blackdog> Gray_: sure
19:11:27 <blackdog> just make sure they're indented far enough
19:11:54 <Gray_> Alright, thanks, I keep getting sytax errors whenever I try, but I'll double check :)
19:12:11 <blackdog> Gray_: you know the drill. throw it up on a pastebin :)
19:12:49 <EvanR> check for tabs
19:12:49 <Gray_> Actually I don't know the drill, how do you do that?
19:12:58 <EvanR> step 1, make sure hpaste isnt down
19:13:01 * Axman6 stabs python in the balls
19:13:09 <Gray_> Ihave tabs set for 4 spaces :D
19:13:16 <blackdog> otherwise, pastebin.com
19:13:22 <EvanR> if you use tabs, make your editor turn it into spaces
19:13:25 <blackdog> put your code in, put the error message you're getting...
19:13:37 <blackdog> and post the link here
19:13:46 <Gray_> k, thanks
19:15:55 <hpaste>  . (.)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24892
19:16:35 <Gray_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24892#a24893
19:16:45 <Gray_> if you could take a look, that would be great :)
19:17:28 <blackdog> you're trying to define nextSegments in a tighter scope
19:17:51 <blackdog> but then use it in a wider scope
19:18:11 <blackdog> oh, hang on
19:18:37 <blackdog> should solutions be using the inner cs or the outer cs?
19:18:54 <blackdog> at the moment it's using the outer one
19:19:06 <Gray_> ach, it should be inner, let me fix that
19:19:24 <Gray_> no, wait it is outer, thats right
19:19:56 <blackdog> ok, then solutions is ok at that level
19:20:08 <blackdog> but you're defining nextSegments as a sub-part of solutions
19:20:12 <blackdog> where it's not used
19:20:28 <blackdog> if you move it one level up, underneath 'expand', you should be ok
19:20:38 <Gray_> ah, thanks!
19:21:04 <contrafunktal> byorgey: it's *.* that's the problem
19:21:20 <byorgey> contrafunktal: how so?
19:21:24 <Gray_> awesome, that works, thanks
19:21:44 <contrafunktal> ghc rejects me when I try to define    f = (*.*)    with the type of *.*
19:21:53 <ezyang> If I see a type x[acHi], what does that mean?
19:22:25 <contrafunktal> with roughly the same error as your instance
19:22:38 <contrafunktal> ezyang: it's an internal name from ghc
19:22:54 <ezyang> contrafunktal: blargh
19:23:04 <ezyang> so, am I supposed to interpret it as if it were a or b?
19:23:12 <contrafunktal> probably the only place you see them is when you use template haskell
19:23:40 <contrafunktal> or using one of the -ddump-* flags, or ghc-api
19:23:41 <ezyang> contrafunktal: Right.
19:23:49 <contrafunktal> you want to refer to it?
19:23:58 <ezyang> In this case, I'm looking at the Chart haddock docs, which use Data.Accessor, whic uses Template Haskell
19:24:16 <ezyang> and it makes the types look very scary
19:24:59 <contrafunktal> I suppose you could use variables 'a,b,c,d"
19:25:22 <contrafunktal> but that's risky depending on the context you splice stuff in
19:25:36 <ezyang> oh, is this the name monad?
19:25:42 <ezyang> erm, whatever it's called
19:25:45 <contrafunktal> Q
19:25:51 <ezyang> quote monad, ya
19:26:05 <contrafunktal> yeah, it has a supply of unique names
19:26:41 <contrafunktal> such that you don't shadow anything, or refer to something defined outside
19:26:50 <contrafunktal> when that is not the intention
19:27:01 <byorgey> ezyang: but yes, you can think of x[acHi] as just like a or b
19:27:08 <contrafunktal> or x
19:27:32 <byorgey> i.e. it is just a normal type variable, with a fancy name.
19:27:37 <ezyang> ok
19:28:00 <contrafunktal> you mean it isn't getting the acHi'th element of out x!?!?!
19:28:04 <ezyang> Another question: under what circumstances do Haddock docs not get built on Hackage, and how can we make 'em be built?
19:28:29 <contrafunktal> pester somebody to rebuild them when they are broken
19:28:55 <contrafunktal> Ross?
19:29:33 <ezyang> Ugh, cabal-setup: At least the following dependencies are missing: cairo >=0.9.11, gtk >=0.9.11
19:29:47 <ezyang> I guess they don't have cairo and gtk installed on the build server. That's slightly obnoxious
19:30:04 <contrafunktal> I thought gtk2hs was soon to be available on hackage
19:30:15 <contrafunktal> though I dunno if they would have gtk available there...
19:31:25 <ezyang> is... T a type?
19:32:00 <contrafunktal> quite problematic isn't it?
19:32:14 <ezyang> yep
19:32:39 <contrafunktal> it's mostly a problem with haddock
19:33:22 <byorgey> ezyang: is this a Henning package?
19:34:12 <byorgey> he often has a single type or class per module, named T or C respectively
19:34:30 <byorgey> the intention is that the modules should be imported qualified, so you can then refer to Foo.T or Foo.C
19:34:52 <byorgey> but Hackage doesn't print the qualified names so the resulting documentation is a bit unreadable =(
19:35:32 <byorgey> because there could be multiple T's imported from various modules, in the source it will be obvious since they are all qualified, but in the Haddock output they are all just 'T' and it's impossible to tell the difference
19:35:32 <ezyang> Oh, I bet this is Data.Accessor's fault again
19:35:40 <byorgey> so you just have to look at the source sometimes
19:35:48 <ezyang> *nod*
19:36:48 * ezyang just had a cleve ridea 
19:37:38 <ezyang> EWWW. data-accessor-0.2.1.2:Data.Accessor.Private.T
19:37:49 <ezyang> It's Private, and it's showing up in public type signatures
19:37:53 * ezyang is unhappy 
19:38:08 <byorgey> perhaps it's private in the sense of not exporting its constructors?
19:38:16 <ezyang> yeah
19:38:18 <byorgey> rather than not being exported at all
19:38:42 <ezyang> But it also means that he doesn't document the module or something like that
19:38:58 <byorgey> the real problem here is that the Haskell module system is rather inflexible.
19:46:44 <ezyang> I wish a lot of things
19:46:55 <ezyang> one of the things I wish for now is easy access to source code on Hackage
19:47:10 <contrafunktal> do you know cabal unpack?
19:47:35 <ezyang> oooh
19:48:01 <ezyang> cool joe.
19:49:47 <byorgey> POOF!
19:49:51 <byorgey> And what is your second wish?
19:50:12 <ezyang> Ooh, ooh, working haddock docs for all packages!
19:50:34 <SamB_XP> NICE ones!
19:50:46 <contrafunktal> one problem is no hscolour if you build with cabal install
19:51:13 <byorgey> POOF!
19:51:32 <byorgey> There are now NICE working haddock docs for all packages!
19:51:45 <byorgey> They are stored on a computer in Siberia which is not connected to the Internet.
19:51:52 <ezyang> :^)
19:52:43 <Younder> doing a concurrency session...
19:53:34 <EvanR> byorgey: how does this one work 5.0 * (1.0 :+ 1.0)
19:53:36 <Younder> old school alla hoare algebra + new stuff SVC etc
19:54:49 <contrafunktal> @type fromInteger 5 :: Complex Double
19:54:50 <lambdabot> Complex Double
19:54:50 <Younder> particularly the Hoare algebra  appled to newer tecknology. Verifiabillity is important.
19:54:55 <SamB_XP> byorgey: how did the packages GET to the computer?
19:54:56 <contrafunktal> > fromInteger 5 :: Complex Double
19:54:57 <lambdabot>   5.0 :+ 0.0
19:55:32 <BMeph> 5 :+ 5, I'd say. :)
19:55:56 <EvanR> so if i have a function f x = x*(1.0 :+ 1.0), what must x be/
19:56:29 <SamB_XP> > 5 :: Complex _
19:56:30 <lambdabot>   <no location info>: parse error on input `_'
19:56:33 <contrafunktal> @type *
19:56:33 <lambdabot> parse error on input `*'
19:56:36 <contrafunktal> @type (*)
19:56:37 <lambdabot> forall a. (Num a) => a -> a -> a
19:56:47 * SamB_XP grumbles about missing extensions
19:56:49 <BMeph> SamB_XP: CD+R and (Siberian) Husky, natch! ;
19:57:04 <EvanR> ._.
19:57:30 <EvanR> x must be 'convertible to Complex Double'
19:57:35 * SamB_XP looks at EvanR's beady little eyes quizically
19:57:39 <Younder> so Num is Complex!
19:58:01 <Younder> thought it was real..
19:58:11 <SamB_XP> @info Complex
19:58:11 <lambdabot> Complex
19:58:17 <contrafunktal> no, complex is num
19:58:17 <SamB_XP> @kind Complex
19:58:18 <lambdabot> * -> *
19:58:27 <SamB_XP> @instances-for Complex
19:58:27 <lambdabot> Unknown command, try @list
19:58:32 <SamB_XP> @instances Complex
19:58:33 <lambdabot> Couldn't find class `Complex'. Try @instances-importing
19:58:37 <SamB_XP> @instances Num
19:58:38 <lambdabot> Double, Float, Int, Integer
19:58:48 <contrafunktal> @instances-importing Data.Complex Num
19:58:49 <lambdabot> Complex a, Double, Float, Int, Integer
19:58:58 <Younder> looks real to me
19:59:18 <EvanR> maybe i just dont get how numbers work, anything in Num can be mixed and matched?
19:59:36 <Younder> unless you import Data.Complex..
20:00:16 <Younder> EvanR, of cource not
20:00:43 <EvanR> then it stands to reason that x must be type Complex a where a is type of 1.0
20:01:06 <EvanR> but what if i pass an Integer (not literal)
20:01:15 <Younder> consider Cantors orders of infinity
20:01:37 <contrafunktal> > (1::Double) * (1 :+ 2 :: Complex Double)
20:01:38 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
20:01:38 <lambdabot>         against inferred ty...
20:02:29 <EvanR> so a general function that multiplies my x by my c :: Complex a cant simply be x*c
20:03:38 <EvanR> where x is a
20:03:41 <EvanR> gah
20:03:51 <EvanR> i wanna do scalar multiplication dammit
20:04:08 <Younder> so do..
20:04:13 <EvanR> ? :: a -> Complex a -> Complex a
20:04:35 <Younder> complex nubers are a tuple
20:04:41 <Younder> numbers
20:05:02 <EvanR> i thought they were a :+
20:05:40 <Younder> there is a imaginary part as well..
20:05:58 <Younder> so you need a transform
20:06:02 <Mathnerd314> :t (:+)
20:06:02 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
20:06:21 <EvanR> :t *
20:06:22 <lambdabot> parse error on input `*'
20:06:25 <EvanR> :t (*)
20:06:26 <lambdabot> forall a. (Num a) => a -> a -> a
20:07:02 <Younder> :t :*
20:07:03 <lambdabot> parse error on input `:*'
20:07:21 <Younder> :t (:*)
20:07:22 <lambdabot> Not in scope: data constructor `:*'
20:07:33 <Mathnerd314> @hoogle a -> Complex a -> Complex a
20:07:33 <lambdabot> Data.Complex (:+) :: a -> a -> Complex a
20:07:34 <lambdabot> Data.Complex mkPolar :: RealFloat a => a -> a -> Complex a
20:07:34 <lambdabot> Prelude asTypeOf :: a -> a -> a
20:07:38 <Younder> :t (:+)
20:07:39 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
20:08:08 <Mathnerd314> @hoogle Complex a -> a -> Complex a
20:08:08 <lambdabot> Data.Complex (:+) :: a -> a -> Complex a
20:08:08 <lambdabot> Data.Complex mkPolar :: RealFloat a => a -> a -> Complex a
20:08:08 <lambdabot> Prelude asTypeOf :: a -> a -> a
20:08:10 <Younder> ok so * takes you out of real space
20:08:46 <EvanR> this is a crappy vector space! ;)
20:08:53 <Younder> whith the antisymmetric property we whith do QM love
20:09:05 <Younder> (spin)
20:10:46 <wavewave> hello. I have cabal question.
20:11:32 <wavewave> cabal tries to install QuickCheck-1.2.0.0 which needs base 3.
20:11:39 <EvanR> fine, ill define my own crap
20:11:39 <wavewave> I am now using ghc 6.12
20:12:37 <Mathnerd314> EvanR: http://hackage.haskell.org/packages/archive/vector-space/0.6.1/doc/html/Data-VectorSpace.html
20:12:44 <wavewave> I installed QuickCheck-2.1.0.3 by directly downloading, but still cabal tries to install 1.2.0..
20:13:11 <EvanR> i just want 2d friggin coordinates with basic operations
20:13:28 <wavewave> what is wrong in my system in this case?
20:14:00 <FunctorSalad> EvanR: Vec?
20:14:03 <wavewave> I am trying to install gitit by the way.
20:14:08 <dino-> wavewave: When it's trying to get 1.2.0, is this in the course of installing something else?
20:14:16 <FunctorSalad> (fixed-size vectors)
20:14:17 <dino-> I have 6.12 and my QC is 2.1.0.3
20:14:25 <FunctorSalad> with utilities for one to four dims
20:14:31 <EvanR> tuples or complex would work but they dont act right
20:14:46 <dino-> And that's the QuickCheck that's current on Hackage, I think.
20:14:52 <FunctorSalad> @google hackage "vec"
20:14:53 <lambdabot> http://hackage.haskell.org/package/Vec
20:14:53 <lambdabot> Title: HackageDB: Vec-0.9.7
20:14:56 <FunctorSalad> \o/
20:14:58 <wavewave> dino-: cabal install QuickCheck
20:15:10 <wavewave> dino-: still try to get 1.2
20:15:19 <dino-> wavewave: Silly Q I know, but did you cabal update?
20:15:34 <EvanR> gah, * must be a -> a -> a, rather than a -> A a -> A a
20:15:39 <wavewave> dino-: yes, I did.
20:16:19 <dino-> When you cabal list | less and locate QuickCheck, it really says 1.2.0 for Latest version avail, etc.?
20:16:27 <dino-> Wow!
20:16:35 <FunctorSalad> EvanR: uh if you want C as an R-vector space you want x `smult` y = emb x * y
20:16:45 <FunctorSalad> emb x = x :+ 0
20:16:52 <FunctorSalad> or whatever the constructor was called
20:17:28 <wavewave> dino-: it says "Latest version installed: 2.1.0.3" :-(
20:17:30 <EvanR> yeah, whats it called
20:17:43 <wavewave> dino-: but still looking for QuickCheck 1.2
20:18:17 <FunctorSalad> EvanR: :+ was right
20:18:45 <dino-> wavewave: You're right. I just did `cabal install QuickCheck` and it tried to install 1.2.0.0
20:18:46 <EvanR> smult, emb are not standard names? or are they in Complex
20:18:49 <dino-> That's not right.
20:19:04 <FunctorSalad> EvanR: not standard. I meant "scalar multiplication" and "embed"
20:19:09 <EvanR> ah
20:19:11 <wavewave> dino-: Huk... I also screwed your system up. he...
20:19:13 <dino-> We may need dcoutts
20:19:14 <EvanR> yeah, thats what i want
20:19:42 <dino-> I cancelled it without install.
20:19:50 <FunctorSalad> it's a way to define modules in math too :) abelian group with an embedding of a ring into it
20:19:50 <dino-> Maybe it left build artifacts, nothing more.
20:20:01 <EvanR> a ** c = (a :+ 0) * c
20:20:03 <wavewave> dino-: anyway, it cannot be installed since it needs base3
20:20:24 <wavewave> dino-: but because of this, gitit won't be installed..
20:20:32 <dino-> wavewave: I'm assuming you have something that needs 1.2.0.0 and you want that instead?
20:20:35 <dino-> ah
20:20:45 <FunctorSalad> some languages let you define implicit embeddings, but I think in haskell it has been decided against
20:20:48 <FunctorSalad> (or has it?)
20:21:06 <EvanR> like, auto promotion?
20:21:07 <BMeph> Someone should use that 'smult' as an example...of Appendable! ;
20:21:21 <FunctorSalad> EvanR: yeah, in coq you'd declare 'emb' a 'Coercion'
20:21:38 <dino-> My list shows base 3.0.3.2 and 4.2.0.0 both
20:21:45 <FunctorSalad> BMeph: how? smult is type Real -> Complex -> Complex
20:21:45 <EvanR> sounds handy!
20:21:52 <wavewave> dino- : ah..
20:21:52 <dino-> I wonder if one could be hidden temporarily. How do you deal with this, anybody?
20:22:11 <FunctorSalad> EvanR: can get hard to figure out wtf the compiler did if you have enough coercions, though :)
20:22:25 <BMeph> FunctorSalad: That's Real -> Complex Real -> Complex Real, to you! ;)
20:22:27 <Younder> coercions?
20:23:08 <FunctorSalad> BMeph: yeah, but isn't Appendable the "friendly" name for Monoid?
20:23:08 <wavewave> dino-: I do not have base 3.0.3.2...
20:23:11 <Younder> real -> Complex fine
20:23:24 <wavewave> how can I install older version? hmm.
20:23:32 <FunctorSalad> Younder: functions that get autoapplied so types match
20:23:40 <BMeph> FunctorSalad: But on a more serious note, that was part of the argument against having a class called "Appendable" (this was a -cafe discussion, BTW).
20:23:41 <Younder> Complex -> Real iff im = 0
20:24:03 <FunctorSalad> BMeph: I just mean `mappend' requires type a -> a -> a
20:24:03 <EvanR> Monoid? scalar multiplication?
20:24:25 <Younder> i * i = -1
20:24:48 <EvanR> > (0:+1)^2
20:24:49 <lambdabot>   (-1.0) :+ 0.0
20:24:50 <Younder> ...
20:24:54 <FunctorSalad> Younder: coercions may just be in one direction
20:25:04 <dino-> Huh. How do you have or get more than one base installed in ghc, does anybody know?
20:25:20 <FunctorSalad> (but coq doesn't stop you from defining non-injective ones like the projection to the real line)
20:25:26 <Younder> FunctorSalad, not neccesairly
20:25:36 <dino-> I see only 4.2.0.0 in cabal list
20:25:38 <FunctorSalad> "may" :p
20:25:46 <BMeph> FunctorSalad: Hmm, now that you mention it, I think it was. Pity - it would have been a fun way to tease the debaters.... :)
20:25:52 <Younder> but you need to prove the arrow goes both ways
20:25:52 <EvanR> :t (const 0)
20:25:53 <lambdabot> forall t b. (Num t) => b -> t
20:25:56 <FunctorSalad> in the sense of "aren't required to"
20:25:59 <dino-> It sort of comes with the ghc, doesn't it?
20:26:01 <EvanR> :t (const (0::Complex Double))
20:26:02 <lambdabot> forall b. b -> Complex Double
20:26:37 <FunctorSalad> BMeph: I don't see the pun accept for the initial letter abbreviating a word
20:26:40 <FunctorSalad> *except
20:26:42 <FunctorSalad> o_o
20:26:54 <FunctorSalad> (with both smult and mappend)
20:27:51 <dino-> wavewave: This is latest gitit? Looking at its Hackage page, looks like it specified base >=3 & <5
20:27:58 <dino-> For gitit 0.7.3.5
20:28:02 <wavewave> I try cabal install base-3.0.3.2
20:28:03 <FunctorSalad> ("scalar multiplication" is pretty horrible in the first place - it is not the activity which produces a "scalar product")
20:28:17 <Younder> quite
20:28:44 <wavewave> but it says it needs base >= 4.0, but base = 3.0.3.2
20:29:02 <wavewave> hmm self-inconsistency .
20:29:04 <tensorpudding> I dislike the word scalar product.
20:29:07 <Younder> upgrade?
20:29:19 <tensorpudding> It sounds too much like scalar multiplication.
20:29:29 <mail> RPN calculator
20:29:32 <mail> how fun!
20:29:34 <EvanR> is there a class which defines derivative
20:29:37 <wavewave> dino-: I just did cabal install gitit after cabal update.
20:29:58 <Younder> mail: Your a Fouth fan?
20:30:08 <Younder> forth
20:30:29 <SamB_XP> EvanR: usually Calc I
20:30:34 <EvanR> lol
20:30:43 <tensorpudding> inner product sounds funny though
20:30:48 <tensorpudding> what's it inside?
20:31:11 <dino-> wavewave: I don't get what's going on. The latest gitit is 0.7.3.5 on Hackage. And the page generated from its cabal file is base (>=3 & <5)
20:31:16 <Younder> My experience if from HP calculators and PostScript
20:31:45 <wavewave> dino-: yeah... strange.
20:31:53 <FunctorSalad> tensorpudding: "product" is a bit of a type error
20:32:05 <Younder> bc vs. ddc
20:32:08 <FunctorSalad> ("product" should be the result of an application, not the function itself)
20:32:08 <Younder> dc
20:32:36 <FunctorSalad> (but as a legacy, "scalar product" does refer to the function, mind you)
20:32:47 <dino-> And it was very weird that when I did cabal install QuickCheck it went for 1.2.0.0
20:32:51 <FunctorSalad> ("we define a scalar product on ...")
20:33:12 <Younder> linux myself. some ubuntu some suse, used to be redhat
20:33:14 <tensorpudding> I'm talking about the functions usually denoted <u,v>
20:33:23 <FunctorSalad> me too
20:33:27 <EvanR> deriv f = (\t -> f (t+1) - f t)
20:33:37 <tensorpudding> scalar product emphasizes that it the resulting value is a scalar
20:33:55 <FunctorSalad> semilinear, positive definite conjugate-symmetric bilinear forms
20:34:04 <FunctorSalad> accurate but a bit of a mouthful
20:34:05 <tensorpudding> that's not hard to say at all
20:34:51 <FunctorSalad> *sesquilinear
20:35:01 <FunctorSalad> ("one-and-a-half")
20:35:09 <FunctorSalad> and drop 'bilinear' o_o
20:35:14 <FunctorSalad> sigh
20:36:36 <ezyang> So, do people here have an opinion about Data.Accessor?
20:36:38 <Younder> semilinear?
20:37:08 <Younder> assosiativity only?
20:37:30 <Younder> simigroup..
20:37:36 <FunctorSalad> Younder: sesquilinear is 'linear in one arg, linear but scalars are conjugated when pulled out in the other arg'
20:37:54 <FunctorSalad> I infer that 'semilinear' is just the latter
20:38:06 <tensorpudding> is it better to define vector spaces before metric spaces, or the other way.
20:38:26 <dino-> wavewave: Only thing I can think of is try cabal install gitit-0.7.3.5
20:38:27 <FunctorSalad> tensorpudding: no dependencies there
20:38:39 <FunctorSalad> so you're just asking about didactics?
20:38:49 <dino-> But something is wrong here. cabal-install should try to get the latest, I thought.
20:38:52 <Younder> I am aware of the complex conjugate.. reverse the sign of the i
20:39:15 <SamB_XP> but, how do you know what the sign of the i is in the first place ?
20:39:28 <tensorpudding> Calculus classes usually define vector operations to justify the integral/differential operations on functions over R^n
20:39:38 <SamB_XP> (how does everyone even know they picked the same square root of -1 to call i?)
20:39:38 <FunctorSalad> SamB_XP: you don't, "i" is just as good as "-i"
20:39:41 <Younder> did QM .. lots of SU2 and SU3 group theory
20:39:42 <tensorpudding> dino-: have you cabal update'd?
20:39:56 <wavewave> dino-: it doesn't work.
20:39:57 <FunctorSalad> SamB_XP: you can still say "the other one" even if you can't tell them apart through the interface :)
20:40:29 <SamB_XP> what if we've been drawing our mandelbrot sets upside-down all these years!
20:40:34 <Younder> -i is i^3
20:40:37 <tensorpudding> :o
20:40:48 <FunctorSalad> (through the interface of being a field etc.)
20:40:54 <ezyang> yum yum complex numbers
20:41:16 <Younder> antisymmetry
20:41:20 <FunctorSalad> you can just distinguish i and -i in concrete implementations
20:41:46 <wavewave> dino-: I figured out what causes the problem.
20:41:54 <tensorpudding> In some sense students learn about metric spaces when they learn about the absolute value.
20:42:23 <dino-> I still don't get this. $ cabal install --dry-run QuickCheck
20:42:29 <dino->   QuickCheck-1.2.0.0
20:42:30 <tensorpudding> Or that's a bloody lie, meh.
20:42:35 <dino-> ^^ NOT THE LATEST VERSION
20:42:45 <ams100272> question about type classes, associated type synonyms, I believe
20:43:04 <FunctorSalad> tensorpudding: lie? that is a metric space with metric from a norm, sure
20:43:09 <wavewave> dino-: after cabal install gitit --constraint='QuickCheck>=2'
20:43:19 <ams100272> I want to say, a Queue is a datatyoe that supports some ops (deq, enq)
20:43:26 <dino-> Even if gitit is calling for it, installing QC alone should get latest. Or maybe I don't know how cabal-install really works.
20:43:38 <ams100272> the problem is, it's a polymorphic container type
20:43:42 <wavewave> dino-: it says : cannot configure happstack-util-0.4.1, it requires QuickCheck < 2
20:43:46 <tensorpudding> Yes, but it's the same thing as saying that children learn about Z_10 by counting on their fingers.
20:43:49 <ams100272> so I want to say something like
20:44:02 <wavewave> happstack-util-0.4.1....
20:44:04 <ams100272>   class Queue (Q a) where ...
20:44:09 <SamB_XP> tensorpudding: they might!
20:44:15 <ams100272> (please see http://pastebin.com/pudwvWvn)
20:44:15 <SamB_XP> if they keep going after they reach 10
20:44:57 <ddarius> tensorpudding: Damn straight they do.
20:44:58 <tensorpudding> ams100272: link no worky
20:45:18 <Younder> tensorpudding, I took my PHD in maths in diff. geom.
20:45:23 <ams100272> http://pastebin.com/pudwvWvn (works here ?)
20:45:24 <tensorpudding> ams100272: So you want to create a typeclass for what kind of interface a Queue should have?
20:45:31 <FunctorSalad> SamB_XP: what I'm saying is that while which "i" is which is an implementation detail, the operation "flip the two" is "real", it doesn't depend on the implementation of C
20:45:36 <ams100272> pudding: yes
20:45:59 <tensorpudding> Okay
20:46:07 <EvanR> Z_10 on your figures is something theyd do in soviet russia
20:46:09 <tensorpudding> And what is the problem?
20:46:23 <ams100272> so, I might say something like
20:46:30 <ams100272>   class Queue q where
20:46:36 <ams100272>     emp :: q
20:46:41 <ams100272> pudding : so far so good
20:46:59 <ams100272> but when I try to write down the type of enq (enqueue) it gets problematic
20:47:09 <ams100272>   enq :: a -> q a -> a
20:47:29 <tensorpudding> class Queue a where
20:47:33 <tensorpudding> emp :: q a
20:47:40 <tensorpudding> enq :: a -> q a -> a
20:47:48 <tensorpudding> err
20:49:42 <tensorpudding> rather
20:49:49 <tensorpudding> class Queue q where
20:49:49 <ams100272> pudding: hmm, did you mean class Queue q where
20:49:50 <tensorpudding> etc.
20:49:53 <tensorpudding> Yeah, sorry.
20:49:54 <ams100272> yeah ok
20:50:07 <ams100272> so then haskell knows q is of kind * -> *
20:50:59 <dino-> wavewave: I understand. But I don't even have any happstack installed here. Just trying to install QuickCheck again without version specified is attempting to install the very old one.
20:51:04 <ams100272> pudding: OK great thanks a lot
20:51:22 <dino-> I think maybe this all works differently than I thought.
20:51:46 * Younder made the mistake of leaving my windows open (Norway). Temperatue dropped to 2 degrees (C) . It is 6 in the morning here. Might still be a bit groggy
20:51:54 <dino-> If this is the correct behavior.
20:52:50 * SamB_XP at first thought Younder was talking about e.g. browser windows
20:53:05 <wavewave> dino-: I don't know.. maybe cabal does not always try to install the latest version.
20:53:18 <wavewave> latest /= default ?
20:53:34 <dino-> Not sure. I guess I rarely (never?) tried to have it install something that was already installed.
20:53:48 <dino-> But I've also never been surprised by a not-latest version that I can recall.
20:53:50 <tensorpudding> It is possible that it would choose a non-latest version if the latest version conflicted with a package you had already.
20:54:17 <dino-> tensorpudding: yeah, this is what I'm suspecting. That I don't really know how it works
20:54:41 <Younder> GHC is wreitten in haskell
20:55:21 <Younder> so you have got your basic metacircular compiler
20:57:26 <Younder> ref. A History of Haskell, being lazy with class
20:57:39 <dmwit> dino-: 1. does cabal update fix it? if not, 2. cabal install quickcheck-2.1.0.3 or whatever
20:57:47 <dino-> dmwit: update: no
20:58:37 <dino-> dmwit: Yes, that gives me the message about "If you want to reinstall anyway"
20:58:43 <dino-> with -2.1.0.3
20:59:14 <dino-> I wonder if this is normally not such a big deal until something important is undergoing a major ver change like QC from 1.x to 2.x
20:59:38 <dino-> And we've got things split between needing the old and new affecting deps.
20:59:49 <Younder> quickcheck is a hurdle
21:00:34 <Younder> imcompatabillity between versions 1.0 and 2.0 causes some issues
21:01:02 <Younder> love the lib though
21:01:41 <dino-> Wonder how much work would be involved in hunting down everything not yet ready for 2 and changing, submitting patches. Probably plenty.
21:02:00 <Younder> probably...
21:03:00 <wavewave> lots of other hurdles.
21:03:33 <wavewave> i installed happstack-util by downloading development version using darcs.
21:03:50 <wavewave> happstack-util solved..but..
21:04:08 <wavewave> hsp-0.4.5 requires base >3 && <4.. :-(
21:06:56 <wavewave> baes 3 , base 4 transition seems not smooth..
21:08:32 <dino-> Is <4 what 6.10.x is? I wonder if happstack devs are mostly using 6.10
21:09:39 <Cale> 6.10.4 comes with both base-3.0.3.1 and base-4.1.0.0
21:11:13 <dino-> I guess it's just hsp then. wavewave: you may be able to hack the hsp.cabal to <5 or something.
21:13:35 <wavewave> dino-: unfortunately not. :-(.. feed  also need base <4
21:13:57 <tensorpudding> 6.12 contains a metric ton of new warnings, including ones about base 3
21:14:15 <wavewave> How can  I install base 3 for ghc 6.12?
21:14:56 <tensorpudding> It comes with base 3.
21:15:11 <wavewave> mm?
21:15:26 <tensorpudding> 3.0.3.2, here
21:15:58 <wavewave> tensorpudding : why do I have 4.2.0.0?
21:16:04 <tensorpudding> You probably have both.
21:16:41 <wavewave> tensorpudding: how can I see it? I just check cabal list base
21:17:03 <tensorpudding> ghc-pkg list | grep base
21:17:09 <dmwit> Please.
21:17:13 <dmwit> Just use ghc-pkg list base
21:17:17 <dmwit> It was made for this. =)
21:17:21 <tensorpudding> oh, didn't know that one
21:17:26 <tensorpudding> I discovered ghc-pkg list today.
21:17:31 <dino-> I'm guilty of beating it with the grep hammer too. Habit.
21:17:41 <wavewave> okay.. but I have base-4.2.0.0 only..
21:18:17 <wavewave> hmm interesting, in my other machine, I have 3.0.3.2...
21:18:22 <tensorpudding> Hmm, when did cabal list <package> start working...
21:18:24 <wavewave> and 4.2.0.0.. both.
21:18:24 <dmwit> That's odd... then... WHO WAS PHONE?
21:18:58 <tensorpudding> I'd been ignorant of functionality too long
21:19:21 <dmwit> cabal: the enlightened man's Hackage interface
21:19:36 <dino-> Well, I have to go. But learned about cabal-install today. I didn't know it checked deps of things already present.
21:19:57 <iaefai> I have been using Cocoa and been impressed with its animation abilities. Does Haskell have any user interface stuff that supports animation as well, in a 'set begin and end' sort of fashion?
21:20:05 <wavewave> dino-: thnx for help..
21:20:20 <dmwit> iaefai: I wish... =/
21:20:36 <dmwit> iaefai: Make one!
21:20:38 <dmwit> I'll use it.
21:20:55 <iaefai> I am sure you would, but it would look very much imperative I assure you :p
21:21:11 * dmwit is not afraid of imperative code
21:21:13 <iaefai> Now on a curious point - what would you render with?
21:21:13 <tensorpudding> Animation?
21:21:36 <dmwit> I guess the three standards in here are OpenGL, SDL, and Cairo.
21:21:43 <dmwit> I'm personally a Cairo fan.
21:21:53 <iaefai> tensorpudding: Cocoa supports stuff like begin animation, change property, commit animation and it will just do it for you
21:22:02 <tensorpudding> But what kind of animation?
21:22:23 <iaefai> tensorpudding: geometric property changes is probably the best I can describe
21:22:24 <dmwit> Ever used a Mac?
21:22:33 <dmwit> ...THOSE animations.
21:22:35 <tensorpudding> Okay, so the "progressbar animation" kind.
21:22:43 <dmwit> nono
21:22:45 <tensorpudding> Not the animated video kind.
21:22:47 <iaefai> def. not :p
21:23:02 <dmwit> The "window expanding from the corner" kind and the "webpage wobbling to the right" kind.
21:23:39 <tensorpudding> Oh.
21:23:42 <iaefai> Out of all of those, Cairo is probably the closest thing that supports the primitives. But it is not a backing layer. OpenGL is most portable for that part.
21:23:45 <wavewave> i remember that I compiled ghc 6.12.. that may be the reasion.
21:23:51 <dmwit> The kind that makes you spend big wads of cash before you can stop to think about whether the candy you're looking at has the functionality you want.
21:23:53 <iaefai> Now does it work on mac well...
21:23:54 <tensorpudding> Wouldn't that require compositing and crazy X11 stuff to work?
21:24:01 <tensorpudding> in X, that is
21:24:13 <dmwit> tensorpudding: Not if you're just animating stuff in your own window.
21:24:14 <iaefai> tensorpudding: probably
21:26:22 <iaefai> Interestingly cairo has a quartz backend
21:26:28 <iaefai> So it might work
21:26:34 <iaefai> Worth a look tomorrow
21:26:53 <tensorpudding> Wonder if it would be possible to write Haskell bindings to Cocoa.
21:27:21 <dmwit> Surely "possible" is not the right word.
21:28:10 <iaefai> tensorpudding: There are already things that might do that
21:28:36 <tensorpudding> Well, some way to create Haskell programs that use the native GUI stuff.
21:28:38 <iaefai> dmwit: I would have to say possible is the best I can say :-)
21:28:51 <iaefai> tensorpudding: Possibly
21:29:23 <dmwit> I would be personally affronted if there were any binding that was actually impossible.
21:29:39 <dmwit> Illegal, maybe. Too difficult to be worthwhile, maybe.
21:29:41 <iaefai> dmwit: You worded that very carefully.
21:29:43 <dmwit> But impossible?
21:29:52 <tensorpudding> Any Haskell binding you wrote wouldn't be able to be on the iPad.
21:30:01 <iaefai> I might even get an iPad
21:30:12 <iaefai> tensorpudding: THat is true only on os 4 :p (but practically true)
21:30:25 <dmwit> tensorpudding: I refuse to believe that.
21:30:37 <iaefai> dmwit: Have you read section 3.1.1?
21:30:40 <tensorpudding> The rule says you can't write compatibility layers.
21:30:47 <dmwit> Unless the iPad has come up with some radically new, non-vonNeumann architecture...
21:30:54 <dmwit> iaefai: illegal /= impossible
21:30:55 <tensorpudding> Also that you can't create your own private API's
21:31:06 <iaefai> tensorpudding: It doesn't say that
21:31:18 <tensorpudding> It doesn't?
21:31:43 <iaefai> They don't care what you write, as long as it doesn't use their private APIs and is written in Objc, c++, c
21:32:01 <iaefai> What does your own private api even mean?
21:33:36 <tensorpudding> If you wrote a layer which exposed a richer API on top of the iPhone, say
21:33:54 <p_l> iaefai: it means that if you use something that isn't exposed in their headers, your app is busted.
21:34:11 <p_l> Also, no language-translation allowed (so even stuff like compiling to C is out)
21:34:44 <tensorpudding> Doesn't that essentially mean that you can't write any reusable code at all?
21:34:50 <dark> <iaefai> They don't care what you write, as long as it doesn't use their private APIs and is written in Objc, c++, c
21:34:59 <dark> but what if i compile into C?
21:35:03 <p_l> personally, I'm pondering the legality of someone making an AppStore for jailbroken apps.
21:35:11 <dark> say, haskell into C
21:35:13 <p_l> dark: then it gets rejected.
21:35:19 <iaefai> dark, we shall say *originally* :p
21:35:30 <dark> p_l, how they would know? in general
21:35:37 <dark> they want to see the source code?
21:35:37 <dmwit> You know what bothers me the most?
21:35:47 <iaefai> Rumour of up coming adobe lawsuit (if true, I wonder what the grounds would be)
21:35:47 <dmwit> They have all these freaking users that simply Don't Care.
21:35:57 <dark> dmwit, yes o.O
21:36:10 <iaefai> dmwit: Because for most people it doesn't matter, and they can't do anything about it anyways
21:36:10 <dmwit> I wish there was a way of showing the users how bad Apple is being for the hacker culture.
21:36:14 <p_l> dark: you can quite easily discern if the code was generated or not, unless the compiler is specially designed for readability (like parenscript and LinJ can output stuff that looks "clean")
21:36:17 <dark> this is the crazy thing about drm and other evil stuff that waits all of us in the future
21:36:35 <dark> p_l, ... from the machine code?
21:36:39 <p_l> dark: yes.
21:36:49 <wavewave> dmwit, tensorpudding: I reinstalled ghc and now I have base3, thnx!
21:36:54 <p_l> I spent enough time looking at symbol dumps to notice it :/
21:36:58 * dmwit waves
21:37:00 <dmwit> glad it worked out!
21:37:13 <p_l> dark: GHC would be easily recognizable, for example
21:37:46 <dark> p_l, you can't discern in general
21:37:54 <dmwit> hah
21:37:55 <dark> (but yeah, in practice..)
21:38:07 <dmwit> I wish humans were consistent enough to be mistaken for compilers.
21:38:37 <dark> no, it's compilers that could be inconsistent enough to be mistaken for humans
21:38:49 <dark> (hopefully they aren't..)
21:39:40 <wavewave> this hackage system reminds me of gentoo linux.
21:40:04 <wavewave> I love seeing something being compiled.
21:40:43 <dark> ./configure && make reminds me matrix
21:41:02 <dark> very nice to watch
21:41:43 <dark> "i don't see code anymore.. i see blonde, redhead.."
21:41:46 <iaefai> dmwit: Apple wants 'engineered' applications, not 'hacked' applications. Polish is #1 for them.
21:41:57 <p_l> dark: compilers leave traces. Like mangled symbols, stuff like _eclrjwsQaS2jZ9j9_MuFHZ5z or X11zm1zi5zi0zi0_GraphicsziX11ziTypes_arcPieSlice_closure
21:42:11 <dark> p_l, symbols is something you can strip
21:42:23 <dmwit> iaefai: And we all know nothing says "hacked together" quite like a well-engineered animation framework, ffs.
21:42:34 <wavewave> dark: haskell error and warning message are interesting to see than c/c++ . ;-)
21:42:36 <p_l> dark: not always (some stuff just has to be there)
21:42:37 <dmwit> Or, say, a compatibility layer.
21:43:03 <dark> wavewave, hmm..
21:43:13 <dmwit> "Hm, I think I'll just throw together this app, and then make sure it works on five different operating systems." Yeah, that last step is a real sign of not being dedicated to your program.
21:43:20 <dmwit> grr
21:43:23 <iaefai> Not sure how
21:43:27 <p_l> Apple no longer needs "hackers", or even good programmers, it only needs polish.
21:43:40 <dmwit> How did I get dragged into this. I promised myself not to get dragged into this.
21:43:48 <p_l> I lost any hope for that platform when I learnt that the "I'm rich" app got sold out
21:44:03 <dark> p_l, I just hope they go out of business as soon as possible :(
21:44:04 <iaefai> sold out :p
21:44:09 <dark> but i know this is in vain
21:44:10 <p_l> back when iPhone OS 2.0 was made available.
21:44:22 <dark> because all companies are getting like this, o.o
21:44:30 <iaefai> Nobody is quite like apple
21:44:33 <p_l> iaefai: sold out because the author wanted to sell only 1000 licenses. it was part of the allure.
21:44:47 <dark> almost no one want the old computer, that performs general functions, instead of industry-approved functions
21:45:10 <Veinor> dark: I don't think that people are going to use their iPads as their primary computers though
21:45:11 <iaefai> TBH, I love apple, they make wonderful products that just work. Windows is getting better, and linux is a writeoff.
21:45:23 <dark> Veinor, it's a general trend IMO
21:45:34 <dark> Veinor, maybe the computers of future will be just like this
21:45:35 <iaefai> I agree with dark
21:45:38 * Veinor shrugs
21:45:58 <Veinor> the general-purpose, do-whatever-the-hell-you-want computer will never go away or be hard to get IMO
21:46:14 <dark> Veinor, I hope you are right :)
21:46:57 <iaefai> I saw a video of a 105 year old great-grandmother using an iPad.
21:47:02 <iaefai> That is a form of success
21:47:22 <dark> hm
21:48:43 <p_l> btw, the stuff about Apple being more "approachable" to old people etc. is bullshit, IMHO. People have easy time with what they perceive as similar. If you never used a computer, it wouldn't matter if it's unix console or iPad.
21:49:14 <iaefai> p_l: Do you know a different type of old person than I?
21:50:15 <tensorpudding> The iPad seems like a device for people with disposable income, at least for now.
21:50:37 <iaefai> dmwit: A question you might be able to answer WRT to the animation stuff. In cocoa, it is really easy to make a layer of a certain size and it has a number of different properties. For example, I can make it rounded corners with n radius, I can make it doublesided or not, alpha channel, what have you. How could you easily represent such a thing in haskell?
21:50:44 <dark> p_l, but touching is easier than typing (or, pointing a small thing in the screen!!)
21:51:24 <dark> p_l, also reading in an ebook reader is more meaningful than staring at a monitor (it's almost like reading a paper book)
21:51:42 <iaefai> I should add that I am perhaps erring in the approach, coming from cocoa directly.
21:51:50 <dark> tensorpudding, well, smart phones seems that too (at least here in brazil)
21:51:58 <dmwit> iaefai: data Layer = Layer { corner :: Int, doubleSided :: Bool, alpha :: Channel } -- ?
21:52:15 <dmwit> iaefai: I guess I'm not really sure what you're asking.
21:52:29 <dark> iaefai, what you need is cocoa bindings for haskell, i think
21:52:32 <tensorpudding> Smartphones too.
21:52:46 <dark> tensorpudding, :P (no native english)
21:52:57 <iaefai> dark, I am not looking directly at linking up like that. I am considering the idea of writing a similar thing strictly for haskell.
21:54:26 <iaefai> dmwit: I suppose it isn't a big thing. Because if I had a certain set of layer properties exactly like what you specify there, and I wanted to implement a new type of layer (say custom drawing), it would be as simple as implementing a typeclass.
21:54:44 <tensorpudding> If you only look at what is necessary for day-to-day, you can go pretty far on old hardware.
21:55:04 <iaefai> Now what if somebody needed to store something a little more for their layer, is there a way to extend the Layer you specify there, or would it have to be a new data structure?
21:56:12 <dmwit> I guess there's a few common solutions.
21:56:24 <dmwit> data Layer extra = Layer { ..., extra :: extra }
21:56:30 <dmwit> or
21:56:47 <dmwit> data LayerWrapper = LayerWrapper { layer :: Layer, extra :: Extra }
21:56:48 <dmwit> or
21:56:55 <dmwit> Just keep some extra data lying around.
21:57:09 <iaefai> Might be worth a look later
21:57:17 <dmwit> <- not a Cocoa user
21:57:26 <dmwit> So I'm not sure I understand what you mean, to be honest.
21:59:29 <iaefai> Here is what my general vision would be - a tree of layers, each with some very basic common properties, such as location. But then each type of layer can specialize, like a circle layer, a bitmap layer, etc. They would need additional data.
22:02:55 <augur> http://ocw.mit.edu/OcwWeb/hs/geb/VideoLectures/index.htm
22:03:06 <augur> incase anyone hasnt read the book and wants some fun
22:03:11 <augur> or if you HAVE read the book!
22:03:28 <iaefai> realmedia? I haven't seen that in ages
22:04:25 <augur> i know right
22:09:27 <dark> iaefai, are you looking for a way of doing something similar to subclassing, but adding a new property, and keeping type compatibility?
22:09:46 <iaefai> dark, that is probably the best way of putting it
22:10:06 <dark> iaefai, i don't know haskell :( but i think this should be possible; haskell type system is more expressive than ocaml's, and there are at least two ways of doing it in ocaml
22:10:21 <dark> (using.. classes, duh, or polymorphic variants)
22:10:25 <kmc> dark, it's not strictly more expressive
22:10:30 <dark> hm
22:10:33 <kmc> Haskell's module system is much simpler
22:10:36 <kmc> and less powerful
22:10:43 <kmc> maybe you're not counting that
22:10:44 <iaefai> dark, explain the polymorphic variant thing pls
22:10:46 <dark> also, haskell has row types?
22:10:57 <kmc> iaefai, http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
22:10:59 <kmc> dark, don't think so
22:12:10 <kmc> iaefai, remember that in Haskell, you don't need a new type to define a new behavior
22:12:14 <kmc> because behaviors are just functions or actions
22:12:20 <kmc> and those are first-class values
22:13:41 <iaefai> kmc, well if you have something like a circle and rectangle, they have different properties. If you make a new shape that has text, it has extra data it needs.
22:14:48 <dark> iaefai, if a value is of type [> `A | `B ] as 'a, it can be used in a place that expects a value of type [> `A | `B | `C ] (but the code that deals with `C will never be triggered)
22:15:13 <iaefai> dark, you lost me in notation
22:15:22 <kmc> iaefai, you can handle that with existential quantification
22:15:31 <kmc> to some degree at least
22:15:35 <iaefai> kmc, that sounds religious
22:15:36 <kmc> anyway that article should give you some ideas
22:15:38 <dark> i was looking for the ocaml manual exactly to keep up the notation :P
22:15:55 <dark> <iaefai> kmc, that sounds religious < i'm laughing
22:16:11 <dark> surely math is a kind of religion
22:16:13 <iaefai> Some how whenever I delve deeply into haskell, I always get caught on typing issues
22:16:17 <iaefai> dark, nope
22:16:24 <dark> ^_^
22:16:47 <dark> iaefai, what I meant is hmm.. `A is a value in ocaml, and is accepted if the function accepts "`A or `B or .."
22:17:09 <kmc> math is religion, in that it starts from a set of arbitrary principles and derives consequences
22:17:10 * FunctorSalad knows a legitimate mutable global variable :o
22:17:11 <dark> so it's.. hmm, maybe, a kind of dynamic typing inside the religious static typing of ml
22:17:16 <kmc> unlike most religions, they will admit that's what they're doing ;P
22:17:21 <FunctorSalad> debug-output-indentation-level ;)
22:17:48 <iaefai> dark, that sounds like  data A = A | B
22:17:51 <iaefai> or something like it
22:17:51 <FunctorSalad> maybe that's thread-wide though
22:18:26 <dark> iaefai, yes, this is the syntax for "normal" variant type, but.. is it type-compatible with A | B | C?
22:18:42 <dark> it is source-compatible
22:19:09 <dark> that is, if you change the type, your old source code probably don't break
22:19:13 <iaefai> dark, so you are saying that it basically is like a subclass that adds new data that is ignored by those that don't know of the subclass, from an OOP perspective?
22:20:27 <dark> iaefai, yes, but the compiler itself permits you to combine those `values freely, and just give names (that would be "classes").. you can have `A receiving an int in a part of the code, and `A without parameters in another
22:21:25 <dark> iaefai, if a function receives a value that can be `A or `B, but handles just the `A case, then there is a type error
22:21:31 <iaefai> dark, okay, that does sound like something I could use
22:22:09 <iaefai> So, the question is can haskell do this :p
22:23:00 <iaefai> I am looking at this: http://hackage.haskell.org/trac/haskell-prime/wiki/ExistentialQuantification  and I don't get what it is doing at all
22:23:27 <dark> i don't know.. but in fact, most functional freaks out there (that FunctorSalad joked about) actually hate those polymorphic variants...
22:23:45 <dark> FunctorSalad, in fact, is it lisp? :P
22:23:48 <iaefai> I am not interested in the freaks :p
22:24:14 <dark> iaefai, you will probably have to become one, if just for some seconds, in order to really appreciate haskell
22:24:20 <dark> or ml for that matter
22:24:29 <jargonjustin> To throw an exception in a MonadIO, should throw or (liftIO . throwIO) be used?
22:24:41 <kmc> jargonjustin, do you want to throw on execution, or on evaluation?
22:24:47 <iaefai> dark, I try to be very practical
22:24:49 <kmc> the answers are throwIO respectively throw
22:25:08 <jargonjustin> kmc: ah, throwIO sounds much better then
22:25:21 <kmc> iaefai, that's not a good reference
22:25:34 <kmc> i think the GHC manual is underrated as a source of info about these extensions
22:25:44 <kmc> it can have some good examples
22:25:47 <kmc> http://ryle-if-a.mirrorservice.org/sites/www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#existential-quantification
22:25:57 <dark> iaefai, i would like to have some insight into the practical aspects of FP in fact..
22:26:18 <kmc> iaefai, also http://haskell.org/haskellwiki/Existential_type
22:26:28 <kmc> iaefai, i can give you more examples if those documents don't suffice
22:26:39 <iaefai> ok
22:28:14 <iaefai> kmc, I am not seeing this as a way of extending a datatype, which is really what I was thinking
22:28:32 <kmc> iaefai, it's a way of having more than one data type conform to a single interface
22:29:00 <kmc> and to treat them all as the same type (which type classes alone don't get you)
22:29:06 <kmc> the "interface" can be a type class, or just the signatures of functions in a record
22:29:16 <kmc> maybe you should restate your problem, i think i missed the beginning
22:29:31 <kmc> also, if you know the full set of types
22:29:36 <kmc> then the simplest solution is an ordinary variant
22:29:49 <kmc> data Shape = Circle Point | Rectangle Point Point | ...
22:30:02 <iaefai> kmc, lets work with what you just wrote there
22:30:04 <kmc> the rectangle has extra data compared to the circle
22:30:27 <iaefai> But now, say that somebody wants to make a Triangle, but this is an addon library
22:30:51 <iaefai> So they can't modify the original data
22:30:56 <iaefai> data Shape = ... rather
22:31:27 <iaefai> But they still want to be able to implement Triangle so that it has the data it needs to render, and implement the interface to do it with.
22:32:11 <dark> iaefai, i think the addon don't need to modify the data structure used by the principal program
22:32:21 <iaefai> dark, no it woulnd't
22:32:23 <dark> it could set up callback closures
22:32:58 * iaefai is dumbfounded
22:33:46 <dark> hmm @.@
22:34:03 <dark> i think your problem might be generalized to "how to effectively extend a haskell program?"
22:34:38 <dark> the java, c++ etc solution usually requires subclassing
22:34:50 <iaefai> sure
22:34:59 <iaefai> I am seeing something at 2.3 of this: http://haskell.org/haskellwiki/Existential_type
22:35:25 <dark> going that way, you will find that any language supports OO (look at gtk in C..)
22:36:24 <iaefai> What part in the example shown here: http://haskell.org/haskellwiki/Existential_type#Dynamic_dispatch_mechanism_of_OOP are existential types?
22:36:57 <iaefai> Would it be simply this: data Shape = forall a. Shape_ a => Shape a
22:37:03 <iaefai> and the rest are type classes?
22:39:01 <FunctorSalad> dark: huh? my variable name? not actual elisp, but inspired by recent exposure to it, yeah ;)
22:39:16 <kmc> iaefai, an existential type is a type with "forall" between the = and the value constructor
22:39:27 <kmc> the variables mentioned in that "forall" are "existentially quantified" variables
22:39:52 <kmc> "But now, say that somebody wants to make a Triangle, but this is an addon library"
22:39:53 <iaefai> Perhaps part of the mystery is the 'existentially' part
22:40:03 <FunctorSalad> but tracing is a special case since it's supposed to look into the innards rather than following any rules
22:40:03 <kmc> so that answers in the negative my question about "if you know the full set of types"
22:40:14 <iaefai> I can see how this would work for my application
22:40:37 <FunctorSalad> (e.g., you actually *want* that unsafe trace statement to depend on evaluation order)
22:40:40 <kmc> iaefai, meaning "there exists".  for every value of type Shape, there exists *some* type 'a' which is stored inside, but you don't know what
22:41:09 <kmc> it is unfortunate that ghc uses the "forall" keyword for this
22:41:16 <kmc> it makes sense, kind of, but an "exists" keyword would be clearer
22:41:27 <dark> isn't existential a misnomer? forall is the 'universal' quantifier..
22:41:44 <kmc> forall is the misnomer
22:41:50 <kmc> these are existentially quantified types
22:41:58 <dark> hmm
22:42:01 <kmc> what GHC is getting at by that syntax is that there's a "forall" in the type of the constructor
22:42:07 <FunctorSalad> dark: universal in negative position = existential
22:42:09 <iaefai> What does existential mean exactly?
22:42:10 <kmc> but again, as i said, an "exists" keyword would be clearer
22:42:25 <kmc> iaefai, meaning "there exists".  for every value of type Shape, there exists *some* type 'a' which is stored inside, but you don't know what
22:42:28 <dark> but isn't the type a set? like, "the set of all those things involving x, for all x"
22:42:40 <kmc> iaefai, "existential quantifier" is "there exists T such that ..."
22:42:45 <iaefai> ok
22:42:48 <kmc> "universal quantifier" is "for all T we have ..."
22:43:06 <iaefai> Je ne suis pas un philosophe :-)
22:43:08 <FunctorSalad> dark: consider the classical rule about pulling a negation out of a quantifier....
22:43:27 <dark> FunctorSalad, is this applicable to this situation..?
22:43:27 <systemfault> On parle le franais! Super.
22:43:36 <FunctorSalad> dark: mapping x to x -> R for some fixed R is just a more general negation in a way
22:43:45 <kmc> iaefai, the point is that when I hand you a Shape, you don't know what type is inside.  you just know that it's *some* instance of Shape_
22:43:47 <FunctorSalad> (it is negation for R = the empty type)
22:44:02 <FunctorSalad> it follows the same rules about flipping quantifiers
22:44:04 <iaefai> I might try something in opengl, if the api is decent enough
22:44:06 <kmc> whereas if the variable were universally quantified -- data Shape a = Shape a -- then you'd have a (Shape T), not a Shape, and you'd know that what's inside is T
22:44:14 <kmc> iaefai, it's reasonable
22:44:56 <jmcarthur> the opengl interface is basically the same as the C one with slightly more type safety... slightly
22:45:21 <kmc> iaefai, in particular, with "data Shape a = Shape a", then (Shape 'x' :: Shape Char) and (Shape True :: Shape Bool), so you can't have [Shape 'x', Shape True]
22:45:37 <InsertNickName> zomg ppl.
22:45:38 <kmc> but with "data Shape = forall a. Shape a", (Shape 'x' :: Shape) and (Shape True :: Shape) and you can build that list
22:45:38 <InsertNickName> O.o
22:45:59 <FunctorSalad> dark: just explaining why `exists' appears to be confusingly called `forall'
22:46:02 <InsertNickName> o wait i dont program in Haskell...
22:46:05 <InsertNickName> :\
22:46:07 <iaefai> Well, if I get something working, then I will just ask for help with suggestions for differences
22:46:12 <FunctorSalad> dark: it's just a matter of putting it into a negative position
22:46:15 <dark> InsertNickName, hm
22:46:18 <kmc> InsertNickName, no time like the present to start :)
22:46:29 <dark> FunctorSalad, \/x.y = exists x that y, but, i don't really understand what you say
22:46:33 <InsertNickName> i use C++
22:46:36 <InsertNickName> :P
22:46:37 <kmc> i'm sorry
22:46:40 <dark> InsertNickName, you like it?
22:46:50 <iaefai> InsertNickName: Well you can't sell your soul any cheaper, so you might as well join.
22:46:51 <InsertNickName> i only been doin it for about a month
22:47:02 <iaefai> InsertNickName: How long have you been programming for?
22:47:12 <InsertNickName> about a month and a half
22:47:13 <InsertNickName> XD
22:47:20 <iaefai> Your mind might yet be saved.
22:47:22 <InsertNickName> im a noob
22:47:25 <dark> lol
22:47:26 <InsertNickName> :P
22:47:47 <iaefai> InsertNickName: Do you have a good background with Math?
22:47:58 <InsertNickName> i used to.
22:48:15 <InsertNickName> ...im not very old.
22:48:15 <eintopf> who is the math freak here
22:48:17 <FunctorSalad> dark: ToR (exists x. f[x]) is equal to forall x. ToR(f[x]), where ToR is defined as
22:48:22 <dark> InsertNickName, i might be burned at a stake for this, but you might learn a language that is easier and friendlier than both c++ and haskell. like python, ruby, lua..
22:48:25 <FunctorSalad> ToR a = a -> R
22:48:34 <jmcarthur> @slap dark
22:48:34 * lambdabot is overcome by a sudden desire to hurt dark
22:48:44 <InsertNickName> i looked at python once.
22:48:55 <InsertNickName> the intro took to long to read
22:48:58 <InsertNickName> :D
22:49:00 <iaefai> InsertNickName: How old are you?
22:49:07 <iaefai> oh dear
22:49:16 <iaefai> InsertNickName: Short attention span?
22:49:20 <InsertNickName> ill be 16 in a few months.
22:49:25 <jmcarthur> maybe pretty pictures would help
22:49:28 <jmcarthur> @where lyah
22:49:29 <lambdabot> http://www.learnyouahaskell.com/
22:49:37 <FunctorSalad> you can make such a negative position up if you don't have one by using: A =isomorphic= forall r. (A -> r) -> r
22:49:49 <iaefai> InsertNickName: When I asked about a background in math, high school wasn't what I had in mind :P
22:49:55 <dark> hm :) the point is, memory allocation for someone that is beginning is a big no-no, so C++ is really bad for learning how to program IMO :(
22:49:57 <InsertNickName> :D
22:49:57 <iaefai> But that link is awesome to start
22:50:17 <InsertNickName> im taking a programming class next year
22:50:18 <InsertNickName> :)
22:50:22 <iaefai> InsertNickName: But if you are afraid to read, you might want to stay away from programming
22:50:24 <jmcarthur> i got pretty serious with c++ as a beginner
22:50:31 <jmcarthur> not that i would say it was a *good* thing...
22:50:35 <ologNation> bummer that you can't parameterize types in haskell.
22:50:37 <ologNation> What's up with that?
22:50:42 <jmcarthur> huh?
22:50:44 <iaefai> jmcarthur: I started with GW-Basic...
22:50:45 <Veinor> I learned.... perl
22:50:45 <jmcarthur> you mean with values?
22:50:47 <InsertNickName> bye...
22:50:48 <InsertNickName> XD
22:50:50 <dark> InsertNickName, nice age to learn, hope you don't get pascal
22:50:54 <Veinor> well, first basic, then perl
22:50:56 <ologNation> jmcarthur, yeah.
22:51:05 <jmcarthur> yeah, that does stink
22:51:10 <ologNation> thanks!
22:51:11 <iaefai> dark, people do pascal?
22:51:20 <pippijn> I started with qbasic, then x86 asm ;)
22:51:21 <ologNation> I have a graph container.
22:51:21 <iaefai> dark, I would have hoped it was modula-2 at least now
22:51:21 <dark> iaefai, not sure
22:51:22 <ologNation> Graph.
22:51:25 <jmcarthur> you can always create type-level "values"
22:51:25 <ologNation> it's a datatype.
22:51:29 <joga> pippijn: me too ;)
22:51:30 <ologNation> I can have a function
22:51:37 <ologNation> f:: Graph a -> Graph a
22:51:43 <ologNation> but I CAN'T have a function
22:51:50 <ologNation> f :: g1 -> g2
22:51:55 <ologNation> where g1 and g2 are particular types.
22:52:03 <ologNation> Does anyone know a way to do this?
22:52:03 <jmcarthur> why not?
22:52:03 <FunctorSalad> ?
22:52:10 <ologNation> jmcarthur, Can you?
22:52:13 <dark> i think the most helpful thing people said was the learnyouahaskell.com , i think i overstated the difficulty of haskell anyway
22:52:18 <FunctorSalad> uppercase? *ducks and runs*
22:52:23 <ologNation> I guess I can say data g1 = ...
22:52:31 <ologNation> but I have to do that before compile.
22:52:32 <jmcarthur> :t show :: Int -> String
22:52:33 <lambdabot> Int -> String
22:52:48 <jmcarthur> i don't understand the question
22:54:00 <kmc> ologNation, nor do i
22:54:07 <FunctorSalad> ologNation: you do know that lowercase types are automatically considered variables and universally quantified?
22:54:14 <kmc> if your source code literally says "g1" and "g2", those are type variables
22:54:17 <kmc> they will stand in for any type
22:54:22 <kmc> you can say G1 and G2
22:54:28 <kmc> and use "type" or "data" to give them meaning
22:54:40 <jmcarthur> *cough* or newtype *cough*
22:54:41 <Veinor> ... okay, I thought ologNation was oleg for a second
22:54:45 <iaefai> kmc, merci pour l'aide.
22:54:46 <Veinor> and was like O_o
22:54:52 <jmcarthur> Veinor: would be a great troll
22:54:54 <FunctorSalad> *coughzors* or data instance
22:55:10 <FunctorSalad> I read "olegNotation"
22:55:11 <jmcarthur> *ahem* or newtype instance
22:55:16 <FunctorSalad> for a second
22:55:25 <FunctorSalad> now you're making things up :o
22:55:31 <olegNotion> guys what's a type???
22:55:31 <FunctorSalad> never tried it
22:55:39 <jmcarthur> FunctorSalad: it works as expected
22:55:52 <FunctorSalad> jmcarthur: seriously? easteregg
22:56:02 <jmcarthur> it's not an easteregg...
22:56:10 <FunctorSalad> I know about `type instance'
22:56:11 <jmcarthur> oh, and of course there is also type instance
22:56:29 <FunctorSalad> will have to see it with my own eyes
22:56:50 <jmcarthur> you can use newtype to instantiate a data family
22:56:56 <kmc> iaefai, :D
22:57:37 <FunctorSalad> jmcarthur: meh, I'd try it if I hadn't broken my emacs init file again
22:57:53 <jmcarthur> FunctorSalad: http://hackage.haskell.org/packages/archive/vector/0.5/doc/html/src/Data-Vector-Unboxed-Base.html
22:58:49 <jmcarthur> tons of them there :)
23:01:23 <temoto> Hello.
23:01:29 <kmc> hi
23:01:47 <FunctorSalad> I see...
23:04:05 <temoto> Naive ranking system, like average of 1..5 ratings is not great, because its result is heavily affected by each vote on low vote count, right? There was some ranking system which is named after some man and it can tell the result with some defined probability. What was it?
23:06:11 <cybercobra> (newbie)  is there a way to pattern match using the names of accessors for fields?
23:06:14 <jmcarthur> a rating system is pretty great under certain assumptions, like large numbers of votes
23:06:47 <c_wraith> cybercobra: with records?
23:06:50 <jmcarthur> but sorry, i don't know much about things like confidence intervals and such
23:07:12 <hpaste>  . (dobie_gillis)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24894
23:07:28 <tensorpudding> you can pattern-match on positional arguments, but it'll break if you change the order or number of fields in your record
23:07:48 <dobie_gillis> i have a question regarding loops in the IO monad... see the latest hpaste
23:08:00 <kmc> "-- Why is this not behaving like I want it to?"
23:08:07 <kmc> how is it behaving, and how do you want it to behave?
23:08:19 <dobie_gillis> sorry, i should have been more clear
23:08:45 <cybercobra> c_wraith: yeah, "data". to paralle the non-positional constructor syntax.
23:09:05 <dobie_gillis> I want it to print everything, then wait, then print, etc.. in a never-ending loop
23:09:13 <kmc> cybercobra, yes.  f (MyRecord { a = x, b = y}) = ...
23:09:27 <temoto> jmcarthur, is "rating system" even a good keyword for search on that topic?
23:09:30 <dobie_gillis> right now it just prints once and i don't know why
23:09:33 <cybercobra> kmc: sweet. appreciate it.
23:09:37 <kmc> cybercobra, see also http://ryle-if-a.mirrorservice.org/sites/www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#record-puns and http://ryle-if-a.mirrorservice.org/sites/www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#record-wildcards
23:09:40 <kmc> for extensions withnicer syntax
23:09:51 <kmc> dobie_gillis, displayLoop only calls itself if i == n
23:10:06 <kmc> otherwise it calls showSorted once, waits 1 ms, and returns
23:10:16 <dobie_gillis> kmc: uh duh.. thank you
23:10:37 <kmc> :)
23:10:45 <philo> hi
23:10:49 <kmc> hi
23:10:55 <philo> what happened in case of patern matching overlap ?
23:11:35 <kmc> philo, the first alternative is taken
23:11:44 <dobie_gillis> guess i was just having trouble with basic recursion :) i automatically assumed my problems were related to something monadic
23:12:26 <philo> ok
23:12:37 <philo> no exception are raised ?
23:12:57 <kmc> philo, nope
23:13:04 <kmc> an exception is raised if *none* of the patterns matches
23:13:05 <jmcarthur> temoto: if not, maybe "voting system"?
23:13:08 <jmcarthur> but i don't know
23:13:12 <kmc> which we generally try to avoid being possible
23:13:41 <philo> no autamatic way to force haskell to try matching from the less general to the more general ?
23:13:57 <kmc> no
23:14:08 <kmc> if you have a more specific example, maybe we can help you clean it up
23:14:12 <kmc> you can paste code at
23:14:14 <kmc> @where hpaste
23:14:14 <lambdabot> http://hpaste.org/
23:15:38 <roconnor> can't you just write the patterns in order from less general to most general?
23:15:46 <roconnor> then haskell will match them in that order
23:15:53 <kmc> i assumed that was not included in "automatic"
23:16:02 <ski> (dark : polymorphic variants are nice ..)
23:16:09 <philo> exactly
23:16:22 <philo> roconnor: thanks anyway i will try that
23:16:27 <ski> ologNation : a type is roughly a "shape" that some values share together
23:16:40 <ski> (.. dang)
23:16:54 <philo> btw any one working on a .net implementation of haskell ?
23:17:14 <roconnor> pattern generality isn't a total order so I don't know how an automatic algorithm would even work
23:18:15 <kmc> philo, there are various projects on Hackage regarding interop with .NET
23:18:30 <kmc> meaning something less ambitious than compiling Haskell to CLR
23:18:36 <kmc> that has also been worked on
23:18:45 <kmc> but nothing big / active to my knowledge
23:18:53 <philo> roconnor dont need to be a total oder
23:19:01 <philo> just a partial one could be enought
23:19:19 <philo> kmc:  ok i read somewhere that lazyness what the big problem
23:19:25 <roconnor> which of two incomparable  patterns gets matched first assuming your data matches both of them?
23:19:38 <kmc> philo, for .NET implementation?
23:19:47 <kmc> philo, see http://haskell.org/haskellwiki/Salsa
23:20:08 <philo> roconnor:  if a data set match booth of them then  we can derive an order relationship between those two alternative
23:20:15 <philo> kmc yea
23:20:20 <roconnor> philo: false
23:20:24 <ski> roconnor : one could require an extra pattern covering the overlap in such cases ..
23:20:37 <kmc> philo, which is more specific?  (a, Just b) or (Just a, b)?
23:20:42 <kmc> obviously you can make an arbitrary choice
23:20:46 <kmc> i.e. lexicographic ordering
23:20:54 <kmc> hmm, do all packages that use Win32 fail to build on hackage?
23:21:14 <philo> hummm intersting
23:21:16 <roconnor> (a, True, False) -> True  | (Fasle, True, b) -> False   -- what does this function do when given (False,True,False) ?
23:21:26 <ski> (if you don't require such overlap covering, then you must either prove the two cases give the same result .. or you get nondeterminism (possibly to be encapsulated in a monad))
23:21:40 <roconnor> philo: or are you assuming consistent patterns?
23:21:46 <philo> matching set can intersect without one be included in the other....
23:21:51 <philo> roconnor:  i guess i was
23:21:56 <ski> roconnor : require also a `(False, True, False) -> ...' case, there :)
23:22:01 <ski> philo : ^
23:25:06 <philo> stupid question :  how easy is it to understand ghc code ?
23:25:42 <ezyang> I'd imagine that depends entirely on your background
23:26:26 <philo> ezyang: ok that mean hard lol
23:26:57 <Axman6> > -4497210299489237401290726500281113425057875631824492885260955668162740748288.000000 :: Double
23:26:57 <lambdabot>   -4.497210299489237e75
23:27:48 <roconnor> ski: I'm reminded of programming in O'Cult
23:27:58 <ski> what's that ?
23:29:08 * BMeph can imagine a language that's a mix of Java and OCaml...I'd call it, "O'Carnage"! ;
23:30:16 <roconnor> ski: It's a language from the ICFP 2006 contest
23:30:32 <roconnor> @quote O'Cult
23:30:33 <lambdabot> No quotes match. Where did you learn to type?
23:31:26 <dons> philo: the source?
23:31:26 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
23:31:33 <philo> dons ?
23:31:37 <dons> it is heavily documented, but generally you'll need a good background in haskell and compilers
23:31:43 <dons> "how easy is it to understand ghc code "
23:31:54 <philo> yea the source code
23:31:56 <dons> you don't mean ghc generated C code, for example, I guess
23:33:39 <BMeph> ...or LLVM code. :)
23:35:07 <dons> the llvm code is fun to puzzle through
23:38:10 <kmc> philo, if you want to understand conceptually how GHC works, this is *the* paper: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
23:38:24 <philo> kmc thanks
23:38:24 <kmc> it's old and much has changed since then, but that's the basic idea
23:40:38 <cybercobra> is there a typeful way of expressing "integer >= 1"?
23:41:53 <cybercobra> (or rather, has someone or the std lib already done that somewhere?)
23:44:00 <olsner> not in haskell, afaik... unless you go all the way and encode that integer in the type system (which you can do)
23:44:49 <Axman6> hmm, what's something i can use as a nop in C?
23:45:26 <olsner> I usually use (void)0
23:45:33 <Axman6> sounds good
23:45:34 <Younder> ugh
23:46:00 <cybercobra> olsner: yeah, just have a constructor function check at runtime and use return type Maybe PositiveInt. was just wondering if I am rewriting something out of ignorance. guess not
23:46:08 <olsner> Axman6: or just ";" you know, but that might trigger warnings for having an empty statement and stuff
23:46:18 <Axman6> yeah
23:46:19 <Younder> an acien definition of NULL
23:46:25 <Axman6> (void)0 seems to work
23:46:26 <Younder> ancient
23:46:42 <olsner> Younder: no, that'd be (void*)0, note the *
23:46:42 <Younder> in the old 'BAD' days
23:46:51 <kmc> "nop"?
23:47:05 <kmc> you need an statement with no effect?
23:47:22 <Axman6> yes
23:47:34 <Younder> olsner, you are right, of cource
23:47:35 <kmc> does it need to compile to a nonzero number of instructions?
23:47:46 <Axman6> just needs to do nothing
23:48:00 <kmc> cybercobra, if you want unsigned numbers we have Word and Word16, Word32 etc
23:48:23 <kmc> you can newtype wrap them to shift the representation over to 1-base
23:48:27 <Axman6> i wish there was an unsigned Integer
23:48:32 <ski> (we should have a big-natural number type ..)
23:48:39 <kmc> by redefining fromInteger, Show, etc
23:48:43 <kmc> that's a lot of work thuogh
23:48:43 <Axman6> i believe GMP implements one
23:48:56 <ski> kmc : "1-base" ?
23:49:11 <kmc> the goal was "integer >= 1"
23:49:21 <kmc> Word starts at 0
23:49:31 <ski> oh, sorry, "1-based" .. i was thinking of "base 1"
23:49:46 <cybercobra> kmc: well, as a testament to Haskell's power, it only took 4 lines
23:49:55 <Younder> void is a intersing cocept. but it has no place in a programming language
23:50:04 <Younder> concept
23:50:07 <kmc> Younder, which concept?
23:50:09 <ski> Younder : behold the `()' type
23:50:15 <cybercobra> Younder: well, a functional one at least
23:50:23 <cybercobra> *purely
23:50:29 <ski> @type putStrLn
23:50:30 <lambdabot> String -> IO ()
23:50:33 <kmc> cybercobra, () is very useful in Haskell
23:50:36 <Younder> an empy sequence or set is fine
23:50:42 <cybercobra> kmc: it's impure!
23:50:46 <kmc> cybercobra, ?
23:51:27 <ski> `()' is just the unit of the `(,)' type, so to speak
23:51:49 <Younder> 0
23:52:10 <Younder> or {} or ()
23:52:22 <Younder> or null
23:52:42 <ski> could you maybe expres what you're claiming, more clearly ?
23:53:15 <theorbtwo> () is just a type with only one (non-bottom) value, or the only value of that type.
23:53:24 <Younder> I see void in c all the time... It doesn mean anything (or rather it means nothing) :)
23:53:32 <kmc> indeed, void in C is weird
23:53:41 <kmc> because you can't have values or variables of that type, etc.
23:53:51 <ski> Younder : `void' in C is use in several unrelated situations
23:53:54 <kmc> also the name is confusing
23:54:07 <kmc> because in FP we usually use "void" to mean the type with *no* values, not the type with one value
23:54:58 <ski> Younder : it can be used as an empty tuple type, sortof, like `()' in Haskell
23:54:58 <kmc> which is called "unit" or "()"
23:54:58 <theorbtwo> kmc: you can't have values or variables of type void, only of pointer to void.
23:55:04 <ski> Younder : it can be used in `void *', which roughly correspond to unsafe `Dynamic', or `Ptr Object' in Haskell
23:55:15 <kmc> C is a pretty good systems language and it's tremendously successful because it filled a niche... but the design definitely has its warts
23:55:26 <kmc> i'm not sure why people are taking the C guys as PL experts now
23:55:34 <kmc> in promoting Go and such
23:55:48 <kmc> they made mistakes with C, they made mistakes with Go, and they don't seem to have read much PL research in the meantime
23:56:01 <olsner> I think void in C is more like the Void type than the Unit type really - it's just that it seems more common in functional languages to use Unit as the dummy-return-type
23:56:04 <ski> theorbtwo : function to `void' is also possible :)
23:56:21 <theorbtwo> ski: But that's not the same as a value of type void.
23:56:24 <kmc> olsner, you couldn't use Void as the dummy return in Haskell
23:56:35 <theorbtwo> Everybody makes mistakes.
23:56:36 <kmc> we might write (IO Void) for an IO action that *never* completes
23:56:58 <theorbtwo> K&R managed, however, to make a hugely successful language that had mistakes.
23:57:01 <ski> olsner : i'd say `void' is sometimes *misused* as the `Void' type in Haskell .. where another type would better be used (iirc gcc has some kind of "does_not_return" annotations)
23:57:04 <chrisdone> Younder: null's best equivalent for values that may be empty is Maybe, which is superior
23:57:22 <olsner> kmc: hmm, rather an IO action returning a value that never can be evaluated, right?
23:57:24 <ski> theorbtwo : indeed. i just objected to "only of pointer to void" ;)
23:57:28 <theorbtwo> Quite possibly the most popular programming language ever.
23:57:30 <kmc> olsner, hmm
23:57:48 <kmc> olsner, i think what you said is more correct
23:58:00 <kmc> you can do
23:58:10 <ski> olsner : `void' in C (not talking about `void *') is more like `()' in Haskell .. i.e. uninteresting return value
23:58:12 <kmc> return (undefined :: Void) >> putStrLn "hello"
23:58:16 <Younder> chrisdone, yes
23:58:25 <kmc> the left hand IO action does in fact return
23:58:42 <theorbtwo> kmc: Isn't that a type error anyway?
23:58:45 <kmc> how so?
23:58:52 <theorbtwo> > return (undefined :: Void) >> putStrLn "hello"
23:58:53 <lambdabot>   Not in scope: type constructor or class `Void'
23:59:08 <kmc> > return (undefined :: forall a. a) >> putStrLn "hello"
23:59:09 <lambdabot>   <IO ()>
23:59:22 <kmc> it'd be bad for putStrLn to return (IO Void) instead of (IO ())
23:59:31 <ski> > return (undefined :: forall a. a) >> "hello"
23:59:32 <lambdabot>   "hello"
23:59:39 <kmc> because someone might force the result
23:59:49 <kmc> and there's no sense in that being an exceptional behavior
23:59:53 <ski> @type forever
23:59:53 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
23:59:54 <theorbtwo> kmc: Exactly.  The LHS is IO Void, the RHS is IO ().
