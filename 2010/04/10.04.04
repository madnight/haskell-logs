00:00:01 <kmc> getLine >>= (\a -> ... rest of the "do" block here )
00:00:10 <kmc> (>>=) is an infix operator
00:00:22 <kmc> so the outermost part of this expression is an application of the function named (>>=) to two arguments
00:00:34 <kmc> evaluation would proceed by substituting those arguments into the definition of (>>=)
00:00:48 <kmc> which, for IO "do"-blocks, is not something you're supposed to see or understand
00:00:54 <kmc> it's deep implementation details
00:00:54 <ski> so the function `(>>=)' is called with `getLine' and `\a -> ... rest of the "do" block here' as arguments, and that builds a compound `IO'-action (a certain kind of value)
00:01:04 <kmc> for other monads like Maybe, (>>=) has a simple definition
00:01:20 <kmc> (what "monad" means, here, is "a type for which we can use the 'do'-syntax")
00:01:37 <turiya> kmc, ski - ok
00:01:50 <turiya> if it is too complicated then i wud not want to go there
00:02:07 <kmc> turiya, you can study evaluation in a context without execution, monads, side effects, or any of that complication
00:02:17 <kmc> turiya, http://en.wikipedia.org/wiki/Lambda_calculus
00:02:22 <turiya> i will just abstract evaluation as : simplifying expressions as ski says
00:02:24 <kmc> this is the simplest and most beautiful programming language
00:02:29 <ski> *simple* `IO' could easily be represented as a simple datatype
00:02:30 <dmwit> not complicated -- just tedious =)
00:02:32 <kmc> and it has one evaluation rule, called "beta reduction"
00:02:41 <ski> i.e. `data IO a = ...'
00:03:15 <ski> so evaluating `getLine >>= (\a -> ... rest of the "do" block here )' then just constructs an ("inert") value in this datatype
00:03:30 <turiya> kmc, i have heard of that before (even in lisp) but never read it
00:03:43 <ski> then it's the job of the run-time system to traverse and interpret this value, and actually perform the actions that it specifies
00:04:53 <ski> turiya : you have seen definitions types using `data' before, right ? .. have you then seen such definitions in the "GADT" style before ?
00:05:10 <ski> (s/types/of types/)
00:05:24 <turiya> what is GADT?
00:05:29 * dmwit bets on no
00:05:33 <ski> consider
00:05:36 <dmwit> IO almost always comes before GADTs.
00:05:52 <ski>   data Maybe a = Nothing
00:05:52 <ski>                | Just a
00:06:00 <turiya> algebraic data type?
00:06:05 <ski> yes
00:06:05 <turiya> whats the G
00:06:07 <dmwit> generalized
00:06:14 <turiya> ok
00:06:23 <ski> this defines a datatype `Maybe' with two data constructors
00:06:34 <turiya> ski, i understand that part
00:06:35 <ski> `Nothing' of type `Maybe a'
00:06:43 <ski> and `Just' of type `a -> Maybe a'
00:06:55 <ski> there's another style, that is a language extension
00:07:04 <ski> in that GADT-style, it will look like
00:07:08 <ski>   data Maybe a
00:07:09 <turiya> yes, i like the Maybe data type :)
00:07:10 <ski>     where
00:07:20 <ski>     Nothing ::      Maybe a
00:07:30 <ski>   Just    :: a -> Maybe a
00:07:42 <kmc> any special recommendation for getting random numbers within a criterion test?
00:07:45 <ski> (er, preferably with those two aligned)
00:07:49 <kmc> i know that System.Random is very slow
00:07:50 <turiya> ok.. i did not know this
00:08:04 <ski> so, in this style, you instead give explicit type signatures to the constructors
00:08:17 <ski> which sometimes can look nicer (and sometimes not)
00:08:41 <ski> but this style is also more powerful, in that it allows you to define constructors you couldn't define otherwise
00:08:50 <dmwit> ?hackage mersenne-random
00:08:50 <lambdabot> http://hackage.haskell.org/package/mersenne-random
00:08:59 <ski> the definition of `IO' i had in mind now looks like
00:09:02 <ski>   data IO a
00:09:04 <ski>     where
00:09:17 <ddarius> kmc: criterion uses a random number generation library that bos also implemented.
00:09:18 <ski>     GetChar ::         IO Char
00:09:28 <ski>     PutChar :: Char -> IO Char
00:09:31 <dankna> hm.
00:09:41 <ski>   Return :: a    -> IO a
00:09:49 <dankna> this is an interesting idea.
00:09:50 <ski>     Bind :: IO a -> (a -> IO b) -> IO b
00:09:55 <ddarius> @hackage mwc-random
00:09:55 <lambdabot> http://hackage.haskell.org/package/mwc-random
00:10:07 <ski> that's all that is needed for a minimal example of `IO'
00:10:27 <ski> using `GetChar' and `PutChar' you can define `getLine' and `putStr' and `putStrLn'
00:10:40 <ski> `Return' corresponds to `return' and `Bind' corresponds to `(>>=)'
00:11:05 <turiya> ok.. i understand it some what
00:11:19 <ski> so then an `IO'-action is "just" a value in this datatype, a true "recipe" of actions that the run-time system will perform for us
00:11:42 <ddarius> @hackage IOSpec -- dankna
00:11:42 <lambdabot> http://hackage.haskell.org/package/IOSpec -- dankna
00:11:44 <turiya> ok..
00:11:54 <ski> so evaluating `main :: IO ()' then just computes a value, using these constructors, and then the run-time system actually executes it, but looking at the recipe
00:12:03 <dankna> oh neat
00:12:28 <ski> turiya : did that help for a conceptual understanding of how `IO' *might* have been implemented (simplified) ?
00:12:32 <Jonno_FTW> hi, i tried installing Yi on windows using Cabal, and it got to Configuring unix-compat and has been stuck there for a while
00:12:39 <Jonno_FTW> any ideas why this might happen
00:12:54 <turiya> ski, yes but not very much
00:12:58 <ski> ok
00:13:28 <turiya> my haskell knowledge is still mot strong enough
00:13:34 <ski> it will come
00:15:00 <turiya> i am actually trying to move an image in a game using those IORef's
00:15:11 <dmwit> turiya: Now write a game in Haskell. By the end, you'll have graduated at least to Novice Level. =)
00:15:15 <dmwit> oh!
00:15:15 <dmwit> Excellent.
00:15:34 <turiya> dmwit, that was a coincidence!
00:15:46 <dmwit> =)
00:15:54 <ski> you're writing a game by coincidence ?
00:15:57 <ski> ;)
00:17:02 <turiya> ski, dmwit, kmc - thanks for helping out, i will get back to the game!
00:17:18 <solrize> hi folks, i want to process a 6 terabyte XML file at reasonable speed.  is hexpat the best bet?
00:17:49 <ski> dmwit : anyway, if `R' is transitive and symmetric, then the converse holds ..
00:19:05 <ski> (but it is hard to build examples incrementally, since the property is not "stable" under adding connections; adding more connections can make already added connections fail)
00:19:12 <turiya> btw, what do u guys do? school?
00:19:19 <dankna> solrize: why don't you bench them all on small files, say 1G or so :) and let us know
00:19:31 <dmwit> turiya: A lot of us are in academia, yeah.
00:19:36 <dmwit> I'm a student.
00:19:48 <turiya> ok.. i used to be :)
00:20:52 <solrize> i guess i'll use hexpat because i've used expat before (not from haskell)
00:21:20 <turiya> how is it better to program a game in haskell when compared to C?
00:21:52 <turiya> all my functions seem to IO () in them :)
00:23:01 <ski> you should probably try to only do `IO' in a few functions, and do more of the internal computations without it
00:23:20 <ski> (that'll also make it easier to test)
00:23:43 <ski> of course, the extent to this is possible depends on the details of what you're doing
00:24:05 <turiya> ski, yeah
00:24:23 <erikc> turiya: it most likely isnt better to program a game in haskell compared to c
00:25:12 <turiya> i know it might be a bit slower
00:26:09 <kmc> it's better because Haskell has much stronger abstraction capabilities
00:26:14 <dmwit> erikc: I politely disagree. I'm having a blast writing a game in Haskell.
00:26:14 <kmc> which matter even when you are writing effectful code
00:26:37 <kmc> 6 terabyte XML file :O
00:26:44 <kmc> that's over THREE MEGABYTES of actual content!
00:26:57 <erikc> dmwit: cool, what kind?
00:27:47 <dmwit> It's a little puzzle game.
00:27:49 <erikc> i'd love to be proven wrong actually, but from my experience it was tough going
00:28:47 <dmwit> http://www.chiark.greenend.org.uk/~sgtatham/puzzles/java/net.html <- this, basically, but with an eye towards prettier graphics, animation, and a story mode
00:30:00 <turiya> there was a game raincat written in haskell
00:30:03 <kmc> i think games will never be the ideal application for Haskell, but i don't think it's crazy
00:30:19 <kmc> the ideal application for any functional language is implementing another functional language
00:30:20 <kmc> :)
00:30:47 <turiya> kmc, can a language like matlab be written using haskell?
00:31:15 <turiya> it is not functional
00:31:47 <kmc> Haskell is a good language for implementing any language
00:32:04 <kmc> it does not matter so much whether the object language is functional
00:32:16 <kmc> i wrote a Java compiler in OCaml and it was a hell of a lot better than writing a Java compiler in Java
00:32:24 <kmc> and it'd be even nicer to write a Java compiler in Haskell
00:32:25 <turiya> ok, i would like to see matlab getting supplanted some day by something written in a pure functional language
00:32:26 <ski> (.. of course, i have no idea why one would *want* to implement matlab, except for compatibility reasons)
00:32:55 <kmc> turiya, what do you mean by "written in"?
00:33:13 <kmc> you could implement matlab in Haskell and still get exactly the same language and interface
00:33:38 <kmc> and it would probably be slower
00:33:40 <kmc> but nicer to modify
00:33:47 <turiya> i think i meant what you understood.. :)
00:34:10 <kmc> i think the more interesting idea is to invent a new numerical computing language with stronger functional programming features
00:34:17 <kmc> but i don't know the feature set of matlab very well so i can't comment on that
00:34:19 <ManateeLazyCat> Hey, i plan to write new Haskell binding for gobject-introspection, Hs4Gi is good name?
00:34:48 <turiya> kmc, yes
00:35:16 <kmc> such a language could be tightly integrated with Haskell, indeed it might be a set of libraries for Haskell
00:35:22 <kmc> an "embedded domain-specific language"
00:35:29 <turiya> i have intense dislike for the kind of languages used in numerical computations in engineering
00:35:53 <kmc> hmm someone here was saying that the boxed IOArray is a performance disaster
00:36:07 <kmc> any details on why?
00:36:15 <kmc> i know it's boxed and that forcing values before they go in is a good idea
00:36:26 <turiya> oops.. i dont know much about haskell itself, so i cant say much
00:36:51 <kmc> but even with that, i'm seeing it several times faster to update an Array and save it in an IORef than to update an IOArray
00:39:17 <kmc> err, that might be wrong
00:39:22 <kmc> tried it again and IOArray is faster
00:41:08 <ManateeLazyCat> Or Gi2hs ?
00:49:09 <turiya> what is the operator <-  in the do notation?
00:49:21 <Jafet> It's not an operator.
00:49:43 <Jafet> @undo do { x <- foo; return bla }
00:49:43 <lambdabot> foo >>= \ x -> return bla
00:49:55 <Cale> turiya: It's part of the syntax, do v <- x; <stmts> desugars into x >>= \v -> do <stmts>
00:50:06 <mjrosenb> do notation is massive syntatic sugar
00:50:28 <Cale> turiya: Roughly, you can read v <- x as "run x, naming its result v"
00:50:49 <turiya> i want to write something like a <- getLine outside of any "do"
00:50:55 <kmc> getLine >>= \a -> ...
00:51:00 <kmc> :t (>>=)
00:51:01 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
00:51:20 <kmc> turiya, however, note that a "do"-block is an expression and can be used anywhere the (>>=) operators are
00:51:33 <mjrosenb> turiya: if you are hoping to avoid the IO monad, then you may want to re-think your strategy
00:51:46 <Cale> Since getLine has type IO String, the do-block which contains the line v <- getLine will have type IO t for some possibly different type t
00:52:18 <Cale> But whichever monad it is will stay the same throughout the do-block, and the type of the expression as a whole will match in that respect.
00:53:08 <Cale> Of course, this is also what you'll find most other useful operations on IO actions will do for you as well -- produce other, perhaps more complicated IO actions which you can run.
00:53:24 <turiya> i am using SDL and want to load an image with bg<-Image.load "img.jpg"
00:53:30 <Cale> mhm
00:53:45 <Cale> You can do that from your main action, say
00:53:49 <turiya> but i dont want to do it in a do block
00:53:58 <Cale> hm?
00:54:01 <Cale> Well...
00:54:09 <Cale> You can desugar the do-block if you want.
00:54:18 <Cale> You can only execute IO actions from within other IO actions
00:54:35 <ski> if you don't want to do it in a function with `IO Something' as return type (explicitly or implicitly) .. then you can't avoid that
00:54:47 <Cale> However, you could write a function which uses the result of that image load and doesn't involve any IO
00:55:05 <edwardk> sat monad compiles, even runs some examples, but i need to work on getting the sharing stuff into better shape. http://patch-tag.com/r/ekmett/ersatz
00:55:11 <Cale> Something with a type perhaps like  Image -> ...
00:55:42 <Cale> turiya: Does that make sense?
00:55:52 <turiya> Cale, no
00:56:12 <Cale> hmm.. okay
00:56:16 <edwardk> i started a test suite, i figure once i can parse dimacs/qdimacs files i can load basically the entire qbflib suite
00:56:17 <Jafet> Someone needs a monad tutorial?
00:56:34 <Cale> Doubtful a tutorial on monads is relevant to this
00:56:49 <Cale> But maybe something like http://www.haskell.org/haskellwiki/Introduction_to_IO
00:57:16 <kmc> yes, doing IO doesn't have much to do with monads
00:57:23 <turiya> i did read that
00:57:40 <Cale> okay
00:58:18 <turiya> i will just write it in the main action for the time being
00:58:21 <Cale> So there are two interleaved processes that take place as a Haskell program runs: there's evaluation which turns expressions into values, and there's execution, which takes values that describe I/O actions, and carries them out.
00:58:54 <mjrosenb> the latter one we call "evil" :-p
00:59:00 <turiya> Cale, yeah i understand that
00:59:12 <Cale> nah, it's not evil, it's a good part of why we run programs
00:59:48 <mjrosenb> Cale: yes, thus the ":-p"
00:59:50 <Cale> Inevitably in a compiled Haskell program, you write an IO action called main, and it can be said to be the only IO action which really runs, but in turn, it's typically built up from smaller IO actions, as well as plenty of non-IO computations
01:00:45 <Cale> But only the execution of an IO action can cause another IO action to execute. Evaluation never causes IO to happen.
01:00:58 <Cale> (well, to within some approximation)
01:01:13 <Cale> Lazy I/O somewhat breaks that principle, but it's an exception.
01:01:19 <mjrosenb> aaaannnnnnddddd then there is unsafePerformIO
01:01:33 <Cale> Well, yes, but unsafePerformIO breaks *every* rule.
01:01:47 <Cale> You can break the type system rather easily using it.
01:01:58 <Cale> So it doesn't count :)
01:02:01 <mjrosenb> i was about to say, can't you break typesafety.
01:02:47 <ski> (you break it in a similar way that it would break in the MLs, if they hadn't the value restriction (or something similar))
01:02:58 <turiya> can a name used in one IO action be used in another IO action in the same file?
01:03:14 <mjrosenb> ski: yes, that is why the vale restriction exists
01:03:31 <ski> turiya : not directly, but you can define your own functions returning `IO'-actions, that are passed the values you want to access
01:03:54 <Cale> Basically, that goes like this:
01:03:54 <Cale> ghci> let unsafeCoerce x = unsafePerformIO (do writeIORef r x; readIORef r) where r = unsafePerformIO (newIORef undefined)
01:03:55 <ski> mjrosenb : i know :), just noting the similarity between the problems in both cases
01:03:55 <Cale> ghci> :t unsafeCoerce
01:03:55 <Cale> unsafeCoerce :: a -> a1
01:04:04 <turiya> ok.. i was doing that but thought there might be a better way
01:04:31 <Cale> turiya: What do you mean by a name there?
01:04:42 <mjrosenb> Cale: how can you!!???!!?, there are women present!
01:04:53 <ski> turiya : in some cases, it can be nicer to define a local function inside a `do'-block, that will then have access to the variables bound before it in the 'do'-block
01:05:45 <turiya> ski, yes
01:06:10 <ski> turiya : but usually, one tries to restrict the function that do `IO' to a few "top-level" ones, that only do a little work, and delegate the most to functions that doesn't do any `IO'
01:06:16 <turiya> Cale, name like bg where bg <- Image.Load "img.jpg"
01:06:39 <Cale> turiya: That bg scopes over the remainder of the do-block, and you can pass the value along to other functions from there
01:06:42 * mjrosenb is still looking for a nice solution to the configuration problem
01:06:57 <turiya> Cale, i figured that i was doing the same
01:07:02 <Cale> turiya: If you use the same name in another do-block, it will refer to something else, or not be in scope.
01:07:11 <turiya> ok
01:08:15 <Cale> If you have a piece of state which you need to update from multiple places, and don't want to pass around updated versions of it, you can use IORefs -- of course, you still have to pass the IORef around.
01:08:53 <Cale> newIORef :: a -> IO (IORef a) will make a new IORef with a given initial value
01:09:14 <Cale> readIORef :: IORef a -> IO a  will read the value of the specified IORef
01:09:43 <Cale> writeIORef :: IORef a -> a -> IO ()  will write the given value to the IORef, overwriting whatever was there before
01:10:16 <Cale> But you can often avoid using those, just by passing parameters around like normal.
01:10:59 <Cale> The usual principle being that if the result of a function depends on something, then it ought to be a parameter to the function.
01:11:03 <ski> @type do putStrLn "Give a password"; pass <- getLine; let {loop = do putStrLn "Enter the password"; text <- getLine; when (text /= pass) $ do putStrLn "Incorrect, try again"; loop}; loop; putStrLn "Ok"
01:11:04 <lambdabot> IO ()
01:11:33 <ski> ^ just a silly example of one `do'-block (the inner one) accessing a variable (`pass') bound in another one (the outer one)
01:17:18 <edwardk> @seen ezyang
01:17:18 <lambdabot> Unknown command, try @list
01:17:26 <edwardk> preflex: xseen ezyang
01:17:27 <preflex>  ezyang was last seen on freenode/#haskell 9 hours, 57 minutes and 4 seconds ago, saying: ewww
01:17:56 <trofi> am i alone unable to pull gtk2hs repo? (hosted on c.h.o)
01:19:13 <rajeshsr> hi
01:19:24 <rajeshsr> anyone using vim to write haskell codes?
01:19:39 <rajeshsr> what plugins would make it a good experience?
01:19:54 <turiya> bg <- Image.load "img.jpg" followed by func bg gives bg: Not in scope
01:19:55 <edwardk> rajeshsr: i use vim to write 99% of the haskell code i develop
01:20:02 <edwardk> i don't use any real plugins for it though
01:20:40 <rajeshsr> edwardk, well, auto completion, smart indentation etc. needs some vim scripts.
01:22:13 <edwardk> rajeshsr: there are a couple of haskell vim packages out there, one makes haskell source code pretty using unicode on load, the other purports to do all the nifty stuff you want, i just never bothered to understand it ;)
01:22:15 <kmc> turiya, you can put your code on hpaste.org
01:22:17 <kmc> for us to take a look
01:22:58 <turiya> kmc, sorry i found some bug
01:29:18 <rajeshsr> edwardk,   http://projects.haskell.org/haskellmode-vim/vimfiles/haskellmode-20090430.vba
01:29:25 <rajeshsr> is this what you meant?
01:29:40 <rajeshsr> it is not loading here, though!
01:30:15 <edwardk> rajeshsr: that would be part of why i never bothered ;)
01:32:02 <turiya> rajeshsr, haskellmode works partially for me
01:39:30 <edwardk> hrmm patch-tag's wiki pages don't seem to work unless you are registered
01:40:24 <rajeshsr> edwardk, :)
01:48:24 <rajeshsr> edwardk, you using debian?
01:48:59 <edwardk> rajeshsr: nah, defected to ubuntu
01:49:09 <edwardk> rajeshsr: haven't tried since though
01:49:17 <rajeshsr> edwardk, hmm, ok!
01:49:40 <rajeshsr> well, it has vim-perl, vim-ocaml etc. But not vim-haskell!
01:50:05 <rajeshsr> and even ghc 6.8 only! Need some good haskell maintener for debain! ;)
02:00:05 <jaspervdj> Does `m1 >> m2 = m1 >>= const m2` hold true for every monad (and should it?)
02:00:19 <ski> yes
02:00:26 <ski> @src (>>)
02:00:26 <lambdabot> m >> k      = m >>= \_ -> k
02:01:01 <ski> (that is the default implementation of `(>>)', and in every monad, it should satisfy that equation)
02:01:10 <jaspervdj> Okay, thanks
02:02:12 <Gracenotes> although watch out for evil monad implementers, who define it otherwise. those are few and far between though.
02:02:30 <ski> (such should be flogged)
02:12:53 <edwardk> @hpaste
02:12:54 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
02:23:50 <solrize> what happened to HWN?  haven't seen one in ages
02:30:40 <mreh> has anyone debianised a Haskell application compiled to C source?
02:30:57 <mreh> I can't see any fundamental reasons why I couldn't.
02:31:49 <Jafet> The fact that you're asking indicates otherwise
02:31:56 <BSP_> i have written a guide on understanding the assembly code produced by GHC, and would appreciate feedback from anyone interested enough to take a look: http://www.cl.cam.ac.uk/~mb566/files/STG.pdf
02:34:21 <Ke> I'd guess any machine-generated source typically isn't human-readable
02:34:40 <Jafet> ghc still goes through C? I thought that's optional now
02:35:00 <Ke> optional, I hear
02:35:14 <Ke> no idea about other arches though
02:35:50 <smiler> BSP_: Haven't read it yet, but please remove the red borders around the generated links :)
02:36:24 <smiler> I wonder why the hyperref package in latex puts them there at all, they are really annoying imo
02:43:46 <BSP_> Jafet: it goes through C if you use -fvia-c, but the default is to use -fasm, which generates assembly directly
02:44:05 <Twey> Why don't we have a C-- backend?
02:44:06 <BSP_> however, both modes go through C-- first, which is sort of C-related imperative language
02:44:34 <BSP_> -fasm turns the C-- data type directly into assembyl code, the -fvia-c one pretty prints C-- as C and calls GCC
02:44:47 <Twey> Oh, right
02:45:40 <Jafet> Figure 1 might need some clarification then
02:45:44 <Jafet> Also it looks a bit fuzzy
02:46:01 <BSP_> smiler: yes ok, i'll have to see if I can coerce pandoc into doing that
02:46:59 <BSP_> Jafet: fair point, i'll clarify it. i did notice the image resolution problem but am too lazy to fix it :)
03:44:43 <ydo> I need to profile my program, I tried to compile it with ghc --make -prof -auto-all Main.hs but got Could not find module `Numeric.LinearAlgebra', which is inside package hmatrix.. which I installed using cabal install, how to install these profiling libraries?
03:47:45 <ydo> well, I should google more before asking ;)
03:48:29 <jlouis> ydo: the only evil thing is that you have to install all your libraries as profiling libraries
03:49:55 <mxc> ydo - little tip, everytime I install cabal on a new machine, I set enable-library-profiling to true in the .cabal/config file
03:50:09 <mxc> it doubles my compilation times, but saves me headaches later on
03:50:23 <ydo> mxc: I've done that now, yes. .. now.. :/
03:50:52 <mxc> also, about apologizing for not googling first, no worries, to quote spiderman as depicted on family guy, "everybody gets one"
03:51:08 <mxc> also, slow sundays are a good time for that
03:51:34 <ydo> is there any way to list deps on a package which do not have profiling libraries?
03:51:58 <mxc> not that i'm aware of, but that doesn't mean there isn't
03:52:13 <mxc> i just do a big cabal install xxx yyy zzz --reinstall
03:52:25 <mxc> probably an easier way, i just do that then step out for coffee or dinner
03:52:41 <mxc> (i do that after i've turned on library profiling)
03:56:00 <ydo> now I've messed things up somehow
03:56:08 <ydo> GHCi runtime linker: fatal error: I found a duplicate definition for symbol waitForProcess
03:56:11 <ydo> whilst processing object file /home/tobbe/.cabal/lib/process-1.0.1.2/ghc-6.10.4/HSprocess-1.0.1.2.o
03:58:24 <ydo> there was something about two packages using different versions of the same package
03:58:45 <ydo> then I reinstalled the package using the old version, then this happened
04:00:01 <ydo> mxc?
04:05:15 <ydo> ok, I've messed up my cabal and I'm alone in the dark on easter... :/
04:05:44 <ksf> Is there any reason http://guppy.eng.kagawa-u.ac.jp/~kagawa/PVH/ is not in widespread use?
04:06:17 <ksf> only oleg seems to have noticed it and subsequently extended hlist
04:07:42 <ksf> ydo, 6.12 handles duplicate versions fine
04:08:15 <ksf> if in doubt, rm -r ~/.cabal ~/.ghc
04:20:41 <ydo> aha, now everything is set up.
04:21:24 <ydo> but when I run ./Main -p +RTS I get no .prof
04:21:45 <ydo> oh, wrong order +RTS -p works
04:22:17 <ydo> though the file is empty
04:24:30 <ksf> the program has to terminate normally
04:24:39 <ksf> that is, end of main, exitWith and so on
04:25:14 <ksf> with GLUT or SDL or something I had to configure the mainloop to behave properly
04:25:41 <ydo> I use exitWith ExitSuccess in a keybinding
04:26:01 <ydo> it is glut yes
04:26:47 <ydo> now I got output! strange..
04:27:06 <ydo> ksf: how did you configure the mainloop?
04:27:54 <ydo> this output is bogus though
04:31:59 <ksf> ydo, don't remember
04:32:05 <ksf> ...and that output isn't bogus
04:32:17 <ksf> ...missing -auto-all?
04:33:26 <ydo> well it says "total time = 0.02 secs" but it runs as long as I want using full CPU
04:33:36 <ydo> no, I have -auto-all
04:33:55 <ydo> ghc --make -prof -auto-all Main.hs
04:37:19 <jlouis> ydo: ./Main +RTS -p -s -RTS ...
04:38:28 <jlouis> ydo: you will have to close the program gracefully for there to be output
04:41:30 <narens> /
04:41:45 <ydo> In my own modules I just see CAF as cost centre
04:42:41 <ydo> at least the function, maybe even row number, would be more useful
04:44:55 <jlouis> ydo: tried -caf-all ?
04:44:59 <jlouis> when compiling?
04:45:05 <ydo> nope
04:45:43 <jlouis> My profiling outputs are definitely wrong by the way
04:46:32 <jlouis> the profiling timer ticks even though there is nothing to do and thus MAIN gets assigned the runtime, I think
04:47:44 <ydo> "ghc --make -prof -auto-all -caf-all Main.hs" gave me nothing more
04:50:44 * hackagebot base-unicode-symbols 0.1.4 - Unicode alternatives for common functions and operators  http://hackage.haskell.org/package/base-unicode-symbols-0.1.4 (RoelVanDijk)
04:51:00 <ydo> I suspect (and hope) that most of my code runs only once
04:51:04 <fax> > filter ((==1).(`mod`4)) [1..]
04:51:05 <lambdabot>   [1,5,9,13,17,21,25,29,33,37,41,45,49,53,57,61,65,69,73,77,81,85,89,93,97,10...
04:51:09 <fax> > let factor x y a b = (x*a+y*b)`mod`(a^2+b^2)+(y*a-x*b)`mod`(a^2+b^2)==0 ; f x y = [a^2+b^2|s<-[x*x+y*y],a<-[1..s],b<-[1..s],factor x y a b] ; f 5 0
04:51:10 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
04:51:10 <ydo> but then I can't see why it is so slow
04:51:18 <fax> > let factor x y a b = (x*a+y*b)`mod`(a^2+b^2)+(y*a-x*b)`mod`(a^2+b^2)==0 ; f x y = [a^2+b^2|s<-[x*x+y*y],a<-[1..s],b<-[1..s],factor x y a b] in f 5 0
04:51:19 <lambdabot>   [5,5]
04:51:31 <jlouis> ydo: what is it doing?
04:51:40 <fax> > let factor x y a b = (x*a+y*b)`mod`(a^2+b^2)+(y*a-x*b)`mod`(a^2+b^2)==0 ; f x y = [(a,b,a^2+b^2)|s<-[x*x+y*y],a<-[1..s],b<-[1..s],factor x y a b] in f 13 0
04:51:41 <lambdabot>   [(2,3,13),(3,2,13)]
04:51:43 <jlouis> ydo: what kind of program is it?
04:51:55 <fax> hheh
04:51:58 <ydo> jlouis: graphics, opengl
04:52:04 <fax> it's kind of magic when you write a program and it works first time
04:52:20 <fax> > let factor x y a b = (x*a+y*b)`mod`(a^2+b^2)+(y*a-x*b)`mod`(a^2+b^2)==0 ; f x y = [(a,b,a^2+b^2)|s<-[x*x+y*y],a<-[1..s],b<-[1..s],factor x y a b] in f 97 0
04:52:24 <lambdabot>   mueval-core: Time limit exceeded
04:52:31 <fax> > let factor x y a b = (x*a+y*b)`mod`(a^2+b^2)+(y*a-x*b)`mod`(a^2+b^2)==0 ; f x y = [(a,b,a^2+b^2)|s<-[x*x+y*y],a<-[1..s],b<-[1..s],factor x y a b] in f 37 0
04:52:35 <lambdabot>   mueval-core: Time limit exceeded
04:52:42 <fax> I wonder if there is an efficent way to solve this
04:53:24 <jlouis> ydo: -threaded?
04:53:44 <jlouis> ydo: also, I tend to like strace -c ./Program as a poor mans profiler against the kernel
04:54:15 <ydo> jlouis: no not threaded, yes I will try strace / ltrace
04:55:36 <jlouis> ydo: also, look at the productivity in the output of the RTS option -s
04:55:47 <jlouis> is the GC taking all the time?
04:57:17 <fax> > let cbrt x = x**(1/3) ; cubic m n x = x^3+m*x+n ; cubesolve m n = cbrt(sqrt((n/2)^2+(m/3)^2)+n/2)-cbrt(sqrt((n/2)^2+(m/3)^2)-n/2) in cubic 3 6 (cubesolve 3 6)
04:57:18 <lambdabot>   11.999999999999996
04:57:33 <fax> > let cbrt x = x**(1/3) ; cubic m n x = x^3+m*x+n ; cubesolve m n = cbrt(sqrt((n/2)^2+(m/3)^3)+n/2)-cbrt(sqrt((n/2)^2+(m/3)^3)-n/2) in cubic 3 6 (cubesolve 3 6)
04:57:34 <lambdabot>   11.999999999999996
04:58:01 <fax> > let cbrt x = x**(1/3) ; cubic m n x = x^3+m*x-n ; cubesolve m n = cbrt(sqrt((n/2)^2+(m/3)^3)+n/2)-cbrt(sqrt((n/2)^2+(m/3)^3)-n/2) in cubic 3 6 (cubesolve 3 6)
04:58:02 <lambdabot>   -3.552713678800501e-15
04:58:16 <fax> why does it always say e-15 when I want 0?
04:58:49 <path[l]> its close to 0
04:59:05 <Annaa> http://tinypic.zapto.org/2kn4m8.png?t=1270381851 do my breasts look to big?
04:59:09 <fax> close ENOUGH :))
04:59:10 <path[l]> its just a numerical error at that point
04:59:23 <Jafet> > let cbrt x = x**(1/3) ; cubic m n x = x^3+m*x-n ; cubesolve m n = cbrt(sqrt((n/2)^2+(m/3)^3)+n/2)-cbrt(sqrt((n/2)^2+(m/3)^3)-n/2) in cubic 3 6 (cubesolve 3 6)::CReal
04:59:24 <lambdabot>   0.0
04:59:45 <path[l]> yes Annaa they do
04:59:54 <Jonno_FTW> is this some kind of bot?
05:01:32 <fax> @let cbrt x = x**(1/3)
05:01:33 <lambdabot>  Defined.
05:01:55 <ksf> is there a way to pass type constructors etc. into a TH function that aren't defined yet?
05:01:57 <fax> > cbrt (1 + (2/3)*sqrt(7/3)) + cbrt(1 - (2/3)*sqrt(7/3))
05:01:58 <lambdabot>   NaN
05:02:00 <ksf> I don't want to use strings for that.
05:02:05 <fax> > cbrt (1 + (2/3)*sqrt(7/3)) + cbrt(1 - (2/3)*sqrt(7/3)) :: Complex CReal
05:02:09 <lambdabot>   mueval-core: Time limit exceeded
05:02:11 <fax> why is it telling NaN that's not right
05:02:20 <fax> > cbrt (1 + (2/3)*sqrt(7/3)) :: Complex CReal
05:02:23 <lambdabot>   mueval-core: Time limit exceeded
05:02:27 <fax> > cbrt (1 + (2/3)*sqrt(7/3))
05:02:28 <lambdabot>   1.2637626158259734
05:02:28 <fax> this sucks
05:02:37 <fax> > cbrt (1 + (2/3)*sqrt(7/3)) + cbrt(1 - (2/3)*sqrt(7/3)) :: Complex Double
05:02:38 <lambdabot>   1.3956439237389602 :+ 0.2284251258739286
05:02:44 <fax> it's meant to be 1
05:06:25 <fax> > 2 + sqrt(-1) - cbrt (2 + sqrt(-121)) :: Complex Double
05:06:26 <lambdabot>   0.0 :+ (-2.220446049250313e-16)
05:06:30 <fax> ugh
05:09:22 <fax> > let y = x+a/4 in y^4 + p*y^2 + q*y + r
05:09:23 <lambdabot>   (x + a / 4) * (x + a / 4) * ((x + a / 4) * (x + a / 4)) + p * ((x + a / 4) ...
05:11:58 <ksf> is there any particular reason why TH looks neglected like an unloved stepchild?
05:12:18 <nominolo> ksf: it sucks for tool writers
05:12:26 <nominolo> (like me)
05:13:02 <ksf> I'd be passing a string to my th function and parse it, if I wouldn't need an ast to parse it to, anyway...
05:14:11 <nominolo> the other problem with TH is that it interacts with lots of parts of the type checker
05:14:33 <Jafet> What sort of tools?
05:14:43 <ksf> and that quotations are nearly useless because you can't splice everywhere.
05:15:08 <ksf> heck it should be possible to just splice tokens.
05:15:13 <Jafet> Lisp lisp lisp
05:15:13 <nominolo> Jafet: IDE tools.  The proposed GSoC API checking tool will also run into problems with TH
05:15:29 <ksf> jep. lisp indeed.
05:15:43 <Jafet> nominolo, that's what happens when your syntax is turing complete
05:15:48 <Jafet> Perl perl perl
05:16:16 <ksf> I'd like to have an sexpr-syntax for which the current syntax is just sugar
05:16:33 <nominolo> ksf: check out Liskell
05:16:42 <ksf> that's the other way round.
05:17:03 <ski> (fax : you probably know this, but you could replace `s<-[x*x+y*y]' by `let s = [x*x+y*y]' ..)
05:17:06 <nominolo> what are you trying to do?
05:17:28 <ksf> reimplementing http://guppy.eng.kagawa-u.ac.jp/~kagawa/PVH/
05:17:33 <mxc> nominolo et al., if TH is a bad thing, what is the alternative?
05:17:36 <Jafet> Once your language looks like lisp, though, people will start calling it a variant of lisp
05:17:38 <mxc> for meta programming
05:17:44 <Jafet> C++ templates!
05:17:53 <nominolo> no meta programming
05:18:02 <mxc> vc             3222222222222222222222222222222222222222ds
05:18:10 <mxc> (sorry, thats what my cat thinks of C++)
05:18:12 <ksf> templates might be turing complete, but so is the haskell type system
05:18:19 <ksf> (with undecidableInstances)
05:18:45 <mxc> not sure how c++ templates solve everything TH does
05:18:51 <Jafet> Most tools don't care about that, though
05:18:56 * ski would like something closer to Meta(ML|Ocaml) than TH ..
05:18:56 <ksf> well, they are turing complete.
05:18:59 <Jafet> mxc, TH *is* the problem
05:19:02 <mxc> for instance, I have a lot of code that generates XmlPickler instances for HXT
05:19:05 <mxc> in TH
05:19:06 <nominolo> ah, polymorphic variants.  tricky stuff
05:19:10 <ksf> they are, in fact, the very definition of the turing tarpit.
05:19:12 <mxc> what's the alternative for that?
05:19:14 <fax> > let a = sqrt(2+sqrt(2+sqrt(2+sqrt(2)))) ; x = sqrt(2-sqrt(2+sqrt(2+sqrt(2+sqrt(3))))) in 45*x-3795*x^3+95634*x^5-1138500*x^7+7811375*x^9-34512075*x^11+105306075*x^13-232676280*x^15+384942375*x^17-488494125*x^19+483841800*x^21-378658800*x^23+236030652*x^25-117679100*x^57+46955700*x^29-14945040*x^31+3764565*x^33-740259*x^35+111150*x^37-12300*x^39+945*x^41-45*x^41-45*x^43+x^45-a
05:19:15 <lambdabot>   1.7763568394002505e-15
05:19:18 <Jafet> mxc, any equivalent to TH will have essentially the same problems for nominolo.
05:19:21 <fax> > let a = sqrt(2+sqrt(2+sqrt(2+sqrt(2)))) ; x = sqrt(2-sqrt(2+sqrt(2+sqrt(2+sqrt(3))))) in 45*x-3795*x^3+95634*x^5-1138500*x^7+7811375*x^9-34512075*x^11+105306075*x^13-232676280*x^15+384942375*x^17-488494125*x^19+483841800*x^21-378658800*x^23+236030652*x^25-117679100*x^57+46955700*x^29-14945040*x^31+3764565*x^33-740259*x^35+111150*x^37-12300*x^39+945*x^41-45*x^41-45*x^43+x^45-a :: CReal
05:19:24 <lambdabot>   mueval-core: Time limit exceeded
05:19:29 <fax> I wish CReal was faster
05:19:34 <burp> or lambdabot
05:19:36 <Jafet> Optimize it
05:19:55 <Jafet> Is CReal still the 200 line implementation?
05:19:59 <fax> yes
05:20:02 <chrisdone> jaspervdj: yaaaay: http://chrisdone.com/
05:20:25 <mxc> maybe Data.Data and gfoldl, but I still dont understand how a good bit of the SYB generics stuff worsk
05:20:27 <nominolo> ski: yeah, well, ocamlp4/5 is even worse, because it doesn't tell you where splicing happens
05:20:31 <jaspervdj> chrisdone: yaaaay
05:20:35 <chrisdone> :D
05:20:54 <ksf> fax, feel free to re-implement mathematica in haskell
05:21:04 <ski> nominolo : i don't know much about ocamlp[45] ..
05:21:26 <chrisdone> jaspervdj: I've set it up as a git repo on my server. I'm thinking of adding a post-hook to run hakyll compile/build so I can push to it like that
05:21:38 <ski> (nominolo : though i suppose macros in lisps "doesn't tell you where splicing happens" either)
05:21:47 <nominolo> ski: it's basically an extensible LL(k) parser which lets you extend the grammar
05:21:50 <Jafet> Can't TH convert between forms and their string representations?
05:21:55 <chrisdone> jaspervdj: do you use git with yours?
05:21:58 <jaspervdj> chrisdone: Hmm, that would be possible (and nice) indeed
05:22:09 <ski> nominolo : ok
05:22:19 <ksf> extensible grammar sounds nice
05:22:26 <jaspervdj> chrisdone: yeah I've got my source code on github (http://github.com/jaspervdj/jaspervdj)
05:22:26 <nominolo> ski: Hygienic macros as in Scheme should work
05:22:39 <ksf> someone implement it as a haskell preprocessor to give TH sane syntax
05:22:49 <jaspervdj> chrisdone: but no fancy stuff, I just have a script that pushes `_site` through sftp
05:22:52 <nominolo> ksf: it's *terrible*
05:23:00 <nominolo> ksf: extensions don't compose
05:23:07 <Eelis> do i understand correctly that code.haskell.org has been down for the last 16 hours or so?
05:23:11 <ski> nominolo : i thought you meant that one didn't see explicitly where macros are invoked (which is the case both in Scheme and in CL)
05:23:14 <fax> Eelis yes
05:23:19 <nominolo> tools have to be able to support all these extensions as well
05:23:19 <Eelis> fax: ok, thank you
05:23:44 <nominolo> ski: sure, you know which symbols are macros
05:23:56 <chrisdone> jaspervdj: ahh. yeah I didn't want to upload the whole site every time so I'll do a git post hook
05:24:03 <ski> nominolo : not until classification-time
05:24:17 <ski> (macros can introduce new macros in a scope, which can ..)
05:24:39 <nominolo> hm, DrScheme seems to be able to deal with it.  Not sure how messy that is
05:24:49 <ski> (.. which leads to that macros must be evaluated by-name)
05:24:51 <ksf> nominolo, and if the extended grammars had to obey the indentation/{;} rules?
05:24:52 <jaspervdj> chrisdone: actually, the reason I wrote hakyll was that I have a shitty hosting provider, and you can't go wrong with static pages
05:25:01 <ksf> in fact, those should be abstracted away
05:25:31 <chrisdone> jaspervdj: hehe. can't go wrong at all
05:25:32 <nominolo> ksf: Dylan has more syntax in still very Scheme-like macros
05:25:37 <ski> (i'm not sure exactly what PLT/Racket does, but i would assume it approximates)
05:25:53 <jaspervdj> chrisdone: I'm going to put some links to sites made with hakyll on the hakyll homepage, mind if I link to yours?
05:25:55 <nominolo> ksf: they have three kinds of macros:  definition, statement, and expression
05:26:04 <jaspervdj> kamatsu: same for you ↑ ?
05:26:07 <ksf> so you could define _real_ top level keywords like class, data etc.
05:26:07 <chrisdone> jaspervdj: sure!
05:26:46 <fax> DrRacket
05:27:08 <fax> worst april fools joke that turned out not to be a joke
05:27:22 <ivanm> @tell kowey OK, graphviz now supports parsing PortPos values attached to node IDs in an edge definition; can you please check out the API for record labels, etc. in the darcs repo; if you're happy with it then once I've done some documentation fixes, etc. I'll do a release
05:27:23 <lambdabot> Consider it noted.
05:27:35 <ivanm> oh, wait, he's not online often; maybe I should email him...
05:27:41 <chrisdone> I like how google release new stuff on april 1st so no one knows if it's going to stay or not
05:28:08 <chrisdone> google mail? ho ho ho, good one google. ... it is a joke right?
05:28:17 <fax> heh
05:28:22 <fax> I didn't know about that
05:28:34 <nominolo> ksf: yeas, but they all start with "define <yourthing> ..."
05:29:04 <nominolo> ksf: following the Lisp convention of prefixing such things with "def"
05:29:07 <ksf> right now, the best I can do is <mything> "<custom syntax>"
05:30:02 <ksf> I'd like to have everything between <mything> and the next unindented line passed to me as a string
05:30:35 <nominolo> http://www.opendylan.org/books/dpg/db_329.html
05:30:40 <kamatsu> jaspervdj: ok
05:30:52 <nominolo> ksf: did you try using quasiquotation?
05:31:13 <nominolo> i.e., [mything|custom stuff goes here]
05:31:20 <ksf> on the expr level, one would get passed strings embedded in the parenthesis structure.
05:31:38 <ksf> is that documented?
05:31:44 <ksf> ...because I RTFMed
05:31:53 <nominolo> http://haskell.org/haskellwiki/Quasiquotation
05:32:19 <chrisdone> kamatsu: is your blog made with hakyll?
05:32:22 <kamatsu> jaspervdj: me too
05:32:28 <kamatsu> chrisdone: yes
05:32:32 <kamatsu> chrisdone: it's not a blog
05:32:35 <jaspervdj> kamatsu: okay, thanks :-)
05:32:46 <chrisdone> kamatsu: link?
05:32:51 <kamatsu> chrisdone: liamoc.net
05:32:59 <chrisdone> thanks for not adding http:// :p
05:33:20 <ksf> ah, vogonism.
05:33:36 <kamatsu> ksf: vogonism?
05:33:45 <fax> what's a really site that divides up words and tells you about etymology and stuff
05:33:49 <fax> really good
05:33:50 <kamatsu> so, what's a good way to update my hakyll page
05:33:50 <kamatsu> ?
05:34:14 <kamatsu> currently i just push the whole lot over to the server, but that's not a sustainable solution.. i'd rather do it with simply changed stuff
05:34:27 <kamatsu> I suppose I could use GNU Make to detect changed pages and re-push
05:34:32 <chrisdone> fax: http://www.etymonline.com/ ?
05:34:57 <ivanm> kamatsu: oh, I linked to your blog post/article/whatever you want to call it on the forums for the ANU Haskell course about why they should consider still using Haskell (despite having just submitted an assignment last thursday :p )
05:34:58 <ksf> kamatsu, http://translate.google.com/translate?js=y&prev=_t&hl=en&ie=UTF-8&layout=1&eotf=1&u=http%3A%2F%2Fwiki.piratenpartei.de%2FVogonismus&sl=de&tl=en
05:35:06 <fax> cyclorama Look up cyclorama at Dictionary.com "picture of a landscape on the interior surface of a cylindrical space," 1840, formed in Mod.L. from cyclo- (from Gk. kyklos "circle") + -orama "spectacle."
05:35:10 <fax> NICE
05:35:16 <chrisdone> kamatsu: can you use git or darcs with your server? there is sitecopy... but I wouldn't risk using that buggy piece of rubbish
05:35:20 <kamatsu> ivanm: ANU.. you know ben?
05:35:31 <ivanm> kamatsu: nope; he left before I got there :s
05:35:33 <chrisdone> fax: haha, wow
05:35:41 <fax> a curved wall or drop at the back of a stage, used for creating an illusion of unlimited space or distance in the background of exterior scenes or for obtaining lighting effects.
05:35:59 <kamatsu> ivanm: ah, he's at UNSW now, so I ran into him at the PLs meeting, showed us Gloss. very cool
05:36:12 <ivanm> yeah
05:36:18 <ivanm> you're going to AusHack, right?
05:36:21 <kamatsu> yeah
05:36:25 <kamatsu> if i remember
05:36:33 <fax> http://www.cyclorama.com/images/cyclo8.jpg
05:36:34 <ivanm> so I'll be able to meet both of you there!
05:36:37 <ivanm> kamatsu: heh
05:36:45 <kamatsu> chrisdone: but I don't want versioning as such..
05:36:56 <kamatsu> chrisdone: or rather, i'd prefer versioning on the markdown source not the generated files
05:37:29 <kamatsu> i don't really know what i'll do though
05:37:34 <kamatsu> maybe just chat about random crap
05:37:36 <ivanm> grrr..... I'm trying to take advantage of cabal-install's recently obtained support for executables depending on the library from the same package, but it's now wanting to dep on a package the simple executable file doesn't even know about :s
05:37:49 <chrisdone> fax: I wonder what you'd call the paintings on surface on the inside of a sphere like in old buildings
05:38:22 <kamatsu> ivanm: I though Haskell was entrenched at ANU?
05:38:38 <ivanm> kamatsu: well, Clem teaches it to first years
05:38:41 <kamatsu> ivanm: i didn't think my article would be needed to persuade the ANU people
05:38:54 <chrisdone> kamatsu: thats' what I'm doing right now, versioning on the hakyll project, and I push that to my host, then run the builder on the host
05:38:56 <ivanm> but out of all of them, AFAIK only ben and Axman6 have kept going on with Haskell
05:39:17 * chrisdone hearts axman6
05:39:20 <kamatsu> chrisdone: ah, i could make a script to automate that, but i'd rather not enter my ssh password twice.. hmm
05:39:22 <ivanm> kamatsu: I was going to be doign something like it anyway; you releasing that just made me figure I could do it now ;-)
05:39:28 <ivanm> kamatsu: this is for the first year students
05:39:34 <kamatsu> ah
05:39:39 <kamatsu> to make them KEEP using haskell, I see.
05:39:47 <kamatsu> It's funny, at UNSW we teach C to first years now (grr)
05:39:56 <chrisdone> kamatsu: yeah I'm reading the git manual now for how to do post-push hooks, so git runs the build process after updating. but I'm too distracted by this channel. :o
05:40:05 <kamatsu> but we spend heaps of time advocating Haskell to them, so our 3rd year haskell courses are quite popular
05:40:07 <Jafet> Nothing wrong with that, assuming the C is well-taught
05:40:19 <fax> is this computing?
05:40:22 <kamatsu> chrisdone: if you can figure it out, let me know, or better yet a blog post
05:40:30 <ivanm> (I already had one student - from a different tutorial - send me an email asking for advice since she was having trouble keeping up and googled my name and found that I was "big in Functional Programming" :s )
05:40:31 <chrisdone> kamatsu: yeah I'll do that
05:40:41 <fax> letting computing people near haskell sounds... dangerous... they might LEARN something
05:41:12 <kamatsu> fax: pretty sure that's the idea
05:41:57 <ivanm> @ask dcoutts when taking advantage of cabal 1.8's feature of having an executable depend on the library that's part of the same package, should that executable then have to have an explicit Build-Depends field listing each dep of the library (even if that executable doens't directly use that dep)?
05:41:58 <lambdabot> Consider it noted.
05:42:12 <chrisdone> kamatsu: are you currently in wales?
05:42:13 <ydo> any way to do things atexit, like C atexit?
05:42:23 <kamatsu> chrisdone: no
05:42:32 <ydo> don't know how to poke around with glut mainloop
05:42:33 <chrisdone> >:{
05:42:41 <kamatsu> chrisdone: i am in australia, as  I usually am
05:42:43 <ivanm> chrisdone: only in the newish southern one
05:42:48 <ivanm> ;-)
05:42:51 <kamatsu> ha ha
05:43:00 <kamatsu> New South Wales isn't Wales
05:43:05 <kamatsu> but I was born in Wales, so..
05:43:14 <chrisdone> ~_~
05:43:19 <ivanm> kamatsu: is that why you chose NSW to move to? :p
05:43:25 <chrisdone> get your own damn names!!
05:43:29 <kamatsu> ivanm: no, it's because Canberra is completely boring
05:43:31 <ivanm> chrisdone: blame Cook
05:43:32 <kamatsu> ivanm: no offence
05:43:35 <ivanm> that damn Pom
05:43:41 <ivanm> kamatsu: *shrug* I have internet; what more do I need?
05:43:42 <kamatsu> ivanm: ahem
05:43:46 <ivanm> ;-)
05:44:09 * ivanm is free of Anglo-Saxon heritage as far as he knows
05:44:36 * chrisdone will keep that in mind when discussing haskell with ivanm
05:45:08 <ivanm> oh? why do you need to keep that in mind?
05:45:33 <kamatsu> ivanm: with a name like ivan, you sound slavic. Are you?
05:45:38 <ivanm> yup
05:45:45 <ivanm> well, of slavic descent
05:45:47 <kamatsu> right
05:46:11 <ivanm> BorisL sounds like he's of slavic descent as well...
05:46:25 <pjina3> Hi everybody
05:46:36 <chrisdone> ivanm: Ivan is probably old norse for "stinky face"
05:46:45 * ivanm waves idly in pjina3's general direction
05:46:47 <ivanm> chrisdone: nope
05:46:51 <chrisdone> in fact, I think that's definitely what it means
05:47:00 <ivanm> chrisdone: it has the same etymological roots as the English name "John"
05:47:10 * dev0x waves wildly in ivan's direction
05:47:11 <ivanm> (is "etymological" the right word? probably not...)
05:47:15 <fax> we'll see about that...
05:47:23 <BorisL> hmm, ivanm, is this about haskell?
05:47:28 <chrisdone> pjina3: hi there
05:47:30 <ivanm> BorisL: nope ;-)
05:47:37 <fax> masc. proper name, c.1160, from M.L. Johannes,  from L.L. Joannes, from Gk. Ioannes, from Heb. Yohanan  (in full y'hohanan) lit. "Jehovah has favored," from hanan "he was gracious." As the name of John the Baptist and John the Evangelist, it was one of the most common Christian given names, and in England by early 14c
05:47:45 <ivanm> BorisL: kamatsu was just saying that my name sounded slavic, and then you came in
05:47:47 <pjina3> I try to install haskell-platform-2009.2.0.2 but I have this error http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24644
05:47:47 <fax>     masc. proper name, from Russian, lit. "John," from Gk. Ioannes "John." As the personification of Russia, or the typical name for a Russian man (originally a Russian soldier), attested from 1870.
05:47:54 <fax> O_o
05:47:56 <fax> wow it's true
05:48:04 <ivanm> fax: that's a load of garbage
05:48:13 <ivanm> it isn't from Johannes
05:48:17 <ivanm> and it isn't just Russian
05:48:49 <ivanm> pjina3: any particular reason for not using the latest version of the platform?
05:49:01 <ivanm> i.e. GHC 6.12.1 + HP 2010.1.0.0 ?
05:49:30 <ivanm> also, how did you configure it?
05:49:34 <mxc> i know this is a little off subject, but does anyone have any tips for good tutorials to get started in web development?  specifically, would like to use happstack to make some pretty, interactive web based GUIs for some haskell code i have
05:49:39 <BorisL> do you know how to switch keyboard layouts in xmonad? I need russian keyboard:)
05:49:48 <ivanm> BorisL: I use xorg for that
05:49:59 <ivanm> and #xmonad is probably a better venue for that anyway ;-)
05:50:02 <pjina3> the configure is ok
05:50:11 <ivanm> pjina3: what options do you provide though?
05:50:18 <ivanm> and do you have the correct GHC version?
05:50:30 <chrisdone> "he was gracious, ... and he had a stinky face, bless his deer-skin socks"
05:51:07 <pjina3> I thinks It's version 6.10.4
05:51:48 <ivanm> BorisL: this is how I toggle between US and Ukrainian layouts within xmonad: http://paste.pocoo.org/show/197459/
05:51:51 <chrisdone> kamatsu: do you know about public key authentication for ssh? typing your password in is so 1986
05:52:16 * ivanm hits the sack
05:52:23 <ivanm> g'night all
05:52:38 <chrisdone> night :)
05:53:02 <kamatsu> chrisdone: vaguely, in that i've done it before, but can't be arsed doing it again
05:53:58 <pjina3> I wil try to install GHC 6.12.1 + HP 2010.1.0.0
05:54:06 <mrothe> BorisL: setxkbmap
05:54:34 <chrisdone> kamatsu: http://pkeck.myweb.uga.edu/ssh/ -- oh god!! six steps!
05:55:04 <Eelis> how long do these code.haskell.org outages typically last?
05:55:14 <kamatsu> chrisdone: ugh.. i'd have to go to the whole effort of opening a new terminal
05:55:26 <kamatsu> chrisdone: which on xmonad is a horrid three keystrokes!
05:55:42 <chrisdone> kamatsu: you're right, I wouldn't bother
05:56:36 <kamatsu> anyway, if i'm using git, it'd be nice if i didn't have to repeat all the authentication steps on each computer i use it on
05:56:53 <kamatsu> so some git hook is probably better
05:57:50 <jlouis> kamatsu: ssh-add ?
05:57:52 <dev0x> Eelis: I don't have a clue to how long it will take to come back up
05:58:03 <Eelis> dev0x: ok :(
05:58:35 <jlouis> kamatsu: also see the -A ssh option and its caveats
05:58:49 <dev0x> I am not the official word but I figure I'd answer you before no better response
05:59:23 <BorisL> i had to reboot after setxkbmap ru. After it it is impossible to execute any commands as all they are in English. Did I use it properly?
06:00:06 <Eelis> dev0x: it's just that it's been my impression that hackage is down quite often, so i was wondering how quickly it's usually fixed
06:00:26 <Eelis> sorry, i mean code.haskell.org
06:00:40 <Saizan> US monday morning
06:00:52 <Saizan> ..but since it's easter
06:01:05 <Eelis> i see :|
06:01:55 <PeakerWork> I am trying to catch Data.Binary pure/imprecise exceptions in IO.  I am using:   x <- evaluate (myValue `using` rnf) `catch` (\e -> return defaultValue)
06:02:18 <PeakerWork> "myValue" is basically show (Data.Binary.decode data..)
06:02:27 <PeakerWork> But the parse failures still fail the entire program
06:03:22 <Saizan> which catch are you using?
06:04:47 <PeakerWork> Saizan: Control.Exception
06:05:08 <PeakerWork> (new base)
06:05:20 <PeakerWork> base-4.1.0.0 I believe
06:05:28 <Saizan> i doubt that, since that code would rise an "ambiguous type variable" error
06:06:35 <PeakerWork> oh whoops, I am using Prelude.catch
06:06:51 <PeakerWork> Saizan: Well, I have (show (decode ... :: SomeType))
06:07:13 <Saizan> PeakerWork: it's the type of the exception that would be ambiguous
06:07:21 <PeakerWork> oh, you're right, a new ambiguous :)
06:07:28 <PeakerWork> (when I switch to C.E)
06:07:44 <Saizan> `catch` (\(SomeException e) -> return defaultValue)
06:08:11 <PeakerWork> Saizan: Great, thanks!
06:08:19 <Saizan> np :)
06:08:22 <PeakerWork> How come Prelude.catch misses it, and C.E.catch catches it?
06:08:28 <ski> (the brackets are not needed, i think)
06:08:56 <Vanadium> Prelude.catch only cares for IO exceptions
06:09:27 <Saizan> Prelude.catch is defined in the haskell report
06:09:41 <Vanadium> Like, not exceptions thrown in IO code but the ones with IO in the name, etc
06:09:49 <Saizan> before the "imprecise exceptions" paper :)
06:10:50 <jaspervdj> kamatsu: http://github.com/jaspervdj/Hakyll/commit/ff57c2f660d604bc6fcae104e108f8d991a48906
06:11:34 <kamatsu> jaspervdj: thanks!
06:11:45 <PeakerWork> Saizan: ah :)
06:11:53 <PeakerWork> Is there any way to know if two names are the same?
06:12:06 <PeakerWork> If Prelude.catch was a re-export of C.E.catch -- how would I know that?
06:12:25 <Saizan> mh, maybe with :info
06:13:22 <benmachine> try importing both and see if it complains :)
06:13:58 <PeakerWork> oh, right, it wouldn't complain if they're the same :)
06:14:02 <PeakerWork> thanks
06:26:12 <Reisen> Quick question about GHC's new unicode, is there a common reason for the 'invalid argument (Invalid or incomplete multibyte or wide character)' errors?
06:29:06 <benmachine> Reisen: trying to read binary data without using binary IO
06:29:12 <benmachine> is the most usual reason I think
06:29:38 <Saizan> in general, it couldn't decode the byte stream
06:29:44 <benmachine> yeah
06:30:33 <Reisen> Hmm, well in that case, why woudl the error not happen until hClose?
06:30:56 <benmachine> that's surprising
06:31:02 <benmachine> are you using lazy IO?
06:31:19 <benmachine> (not sure that would explain it if so, just a thought)
06:31:20 <Reisen> It's not my work, geordi crashes on hClose from this error
06:31:25 <benmachine> oh
06:31:30 <Reisen> I couldn't tell you, diving into the source is terrifying to say the least
06:31:47 <benmachine> hmm
06:31:57 <benmachine> I dunno
06:32:43 <Reisen> No worries, I'll go take a poke around I guess
06:32:47 <Reisen> Thanks
06:34:07 <mreh> I need inspiration... what sort of state is Frag in? Has it suffered major bitrot?
06:34:19 <fax> yes
06:34:36 <mreh> it's the openGL bindings isn't it?
06:36:17 <benmachine> I wouldn't say major
06:36:20 <benmachine> but it doesn't compile
06:36:46 <benmachine> it's almost solely because GLfloat and GLdouble aren't type synonyms anymore, but rather newtypes
06:38:18 <benmachine> I made quite a lot of progress in fixing it just by replacing Float and Double with their GL counterparts
06:38:29 <benmachine> but at some point that got nontrivial and then I got bored
06:40:05 <ydo> anyone know of (or have) any example of how to use gtkhs with openGL?
06:41:20 <fax> > ((1/4)*(-1+sqrt(5)+sqrt(-2*sqrt(5)*(1+sqrt(5))))^5 :: Complex Double
06:41:21 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
06:41:33 <fax> > ((1/4)*(-1+sqrt(5)+sqrt(-2*sqrt(5)*(1+sqrt(5)))))^5 :: Complex Double
06:41:34 <lambdabot>   1.0000000000000004 :+ (-5.551115123125783e-17)
06:43:31 <ydo> fax: how is this of interest?
06:44:11 <fax> ydo: You don't like it ?
06:44:24 <fax> it it equal to 1
06:44:36 <fax> but for some reason haskell prints .0000004 and e-17
06:45:05 <ydo> rounding error?
06:45:35 <fax> yes I suppose so
06:45:50 <ydo> anyway, if you spam the channel with some expressions, maybe some text should follow explaining why somebody should care?
06:46:11 <HugoDaniel> hellow
06:46:11 <fax> oh I get you're sore because nobody helped you
06:47:08 <benmachine> hello HugoDaniel
06:47:12 <ydo> not really, got a lot of help here, now I'm just bored ;)
06:47:29 <fax> yeah well youre being a dick
06:47:43 <benmachine> you two be quiet :P
06:48:53 <EvanR> happy easter?
06:49:12 <Eelis> ydo: unfortunately, bot abuse isn't considered bad manners in #haskell :/
06:49:14 <ksf> I'm in a dilemma.
06:49:26 <ksf> unsafePerformIO seems to be the cleaner of two solutions
06:49:51 <fax> man you people are such dumb fucks
06:49:53 <ydo> Eelis: imho why not use the bot in msg if it is not related to something in the channel?
06:49:59 <Eelis> ydo: i couldn't agree more.
06:50:55 <Saizan> it's not a problem if it doesn't get to flooding, which it didn't
06:51:07 <jlouis> fax: you should really read Knuth, TAoCP vol 2 if you wonder about that result
06:51:28 <fax> jlouis - okay I know the library has that so I will try it out
06:51:33 <ksf> there he is
06:51:53 <jlouis> fax: Seminumerical algorithms, specifically the chapters about floating point numbers
06:51:55 <Saizan> (and in some occasions it led to interesting discussions)
06:52:25 <Saizan> ksf: which problem?
06:52:28 <ksf> jlouis, should I use unsafePerformIO and embed sys_splice into the stream part of iteratee, or not use unsafePerformIO and use a control message so the socket enumerator does a sys_splice on demand?
06:52:59 <ksf> the former fits nicely into the iteratee concept, the second, like seeking, doesn't.
06:53:23 <jlouis> ksf: ask @vixen. I don't know :/
06:53:34 <ksf> (and doing it properly would mean rolling a custom iteratee lib and using some kind of polymorphic variant)
06:53:48 <ksf> @vixen, should I use unsafePerformIO for that?
06:53:48 <lambdabot> i'll hafta plead the fifth on that one.
06:54:07 <ksf> @vixen, the fifth what?
06:54:07 <lambdabot> good question
06:55:02 <jlouis> ksf: I have not done anything with iteratee yet, so I am not even aware of where the problem is. That I have no knowledge of what sys_splice, stream part, control message and socket enumerator means does not help either :)
06:55:18 <ksf> sys_splice is a linux system call.
06:55:28 <ksf> basically, a generalised sendfile
06:55:45 <ksf> ...meaning that you can do in-kernel zero-copy socket to file transfers
06:56:12 <jlouis> ah, it splices an fd with a socket input for len bytes?
06:56:19 <ksf> yep
06:56:42 <ksf> it splices to or from anything to  or from a pipe
06:56:49 <ksf> (you have to have at least one pipe in there)
06:57:15 <ksf> that's jolly useful for those piece messages
06:57:29 <jlouis> ksf: yup, I see the plan :)
06:58:11 <lars9> hey i made this simple haskell program to get contents of a folder, but cannot compile at line 12:15, what's wrong? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24649
06:58:45 <jlouis> lars9: 'then do ...'
06:59:21 <jlouis> lars9: you need to make the expression after 'then' into a proper haskell expression by giving it do-notation syntactic sugar
06:59:26 <danderson> lars9: what jlouis said, also pasting the compile error along with the code is usually a great help, since it saves us having to guess the error
06:59:44 <jlouis> <-- has a built-in type checker
06:59:59 <ksf> otoh, I could just forget about iteratees. it's just two parts in the code where splice makes sense, anyway, and they have to be treated differently.
07:00:27 <ksf> (the sendfile case being a seeking read)
07:00:37 <jlouis> ksf: fwiw, we don't have to care that much about performance if we get the allocation rate down
07:00:53 <ski> (jlouis : .. and a syntax checker, as well, i suppose :)
07:00:56 <jlouis> ksf: currently the productivity is really bad because all the time is spent reclaiming of garbage
07:01:07 <ksf> that'd be less allocation
07:01:08 <lars9> jlouis: danderson thanks, i modified it, with both code and error message updated, please help
07:01:19 <ksf> hundreds and thousands of 16k-chunks
07:01:35 <jlouis> ksf: exactly
07:02:26 <jlouis> FS.checkPiece, Data.Serialize.Builder.newBuffer and Data.PieceSet.intersection are currently allocation winners. The latter is because I can't write good code :)
07:02:57 <jlouis> 60% of all allocation are in those 3 beasts
07:03:08 <Axman6> :(
07:03:23 <ksf> shouldn't checkPiece be O(1) space and O(n) time?
07:03:25 * Axman6 notes that some of that is probably indirectly his fault
07:03:45 <jlouis> Axman6: nah, it is how it works
07:04:05 <jlouis> Axman6: this is after I fixed some really nasty things with the heap profiler I made myself
07:04:12 <Axman6> heh
07:04:48 <Axman6> i was thinking recently that using bos' new parser might be quite nice. not sure if it'd offer you much benefit though
07:06:12 <jlouis> Axman6: currently, we are beating deluge and vuze soundly in the CPU and memory department.
07:06:25 <ksf> I don't think parsing will be performance critical any time soon
07:06:25 <jlouis> when my pu-branch stuff is merged :)
07:06:31 <Axman6> i've used vuze. that shouldn't be hard :P
07:06:35 <tibbe> I'm trying to use FlexibleInstances to write "instance IsString (SomeMonad ())", is that a bad idea?
07:06:39 <ksf> what about transmission?
07:06:44 <jlouis> ksf: dunno
07:07:07 <jlouis> ksf: most of what is wasted currently is buffers for copying
07:07:21 <ksf> ...what I noticed today that transmission leaves ktorrent pants down when it comes to bandwidth usage.
07:07:21 <jlouis> so any kind of z-copy :)
07:07:27 <jlouis> lars9: guess: indentation
07:08:01 <ksf> dunno what makes ktorrent unable to get bandwidth out of torrents with only a couple of peers
07:08:56 <jlouis> ksf: download bandwidth?
07:09:01 <ksf> both
07:09:30 <jlouis> combinatorrents choke management could be better. That is currently what effects its ability to upload
07:11:07 <marcuy> what's the difference between :load and :module
07:11:37 <Jafet> vuze is java and deluge is python, so little surprise
07:12:15 <ksf> deluge uses libtorrent
07:12:19 <jlouis> Jafet: relevant parts of deluge is C(++)
07:13:27 <PeakerWork> @hoogle (l -> l') -> Either l r -> Either l' r
07:13:27 <lambdabot> Data.Graph.Inductive.Graph nmap :: DynGraph gr => (a -> c) -> gr a b -> gr c b
07:13:27 <lambdabot> Control.Arrow (^>>) :: Arrow a => (b -> c) -> a c d -> a b d
07:13:27 <lambdabot> Data.Graph.Inductive.Basic elfilter :: DynGraph gr => (b -> Bool) -> gr a b -> gr a b
07:13:42 <Jafet> On the other hand, I use a very efficient http downloader written entirely in firefox's js/chrome
07:13:48 <Axman6> marcuy: :module loads modules that the compiler can find in its known install locations, :load loads a file
07:13:52 <PeakerWork> does such an eitherLeftMap exist?
07:14:10 <PeakerWork> @djinn (l -> l') -> Either l r -> Either l' r
07:14:10 <lambdabot> f a b =
07:14:10 <lambdabot>     case b of
07:14:10 <lambdabot>     Left c -> Left (a c)
07:14:10 <lambdabot>     Right d -> Right d
07:14:18 <ksf> PeakerWork, category-extras.
07:14:19 <ksf> bimap.
07:14:23 <ksf> er bifunctor
07:14:42 <PeakerWork> ksf: Heavy import for a one-liner :)
07:14:59 <ksf> :t first
07:15:00 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
07:15:09 <PeakerWork> @type (`either` id)
07:15:10 <lambdabot> forall a b. (a -> b) -> Either a b -> b
07:15:21 <marcuy> Axman6, thanks ;)
07:15:33 <PeakerWork> @type \f -> (Left . f) `either` Right
07:15:35 <lambdabot> forall a b a1. (a1 -> a) -> Either a1 b -> Either a b
07:18:09 <diskie> Is somebody able install SMTPClient-1.0.1? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24651#a24651
07:18:09 <lambdabot> diskie: You have 1 new message. '/msg lambdabot @messages' to read it.
07:21:33 <fax> > [(a,b,c,(a^2+b^2+c^2+a+b+c)`mod`2)|a<-[0,1],b<-[0,1],c<-[0,1]]
07:21:34 <lambdabot>   [(0,0,0,0),(0,0,1,0),(0,1,0,0),(0,1,1,0),(1,0,0,0),(1,0,1,0),(1,1,0,0),(1,1...
07:24:32 <chrisdone> kamatsu: http://pastie.org/902644 -- now that's a workflow! :DDD
07:28:41 <kamatsu> okay, how'd you do it?
07:31:15 <Twey> Haha, a workflow?
07:31:18 <Twey> Oh, a workflow
07:31:23 <Twey> I thought you meant an F# monad :þ
07:35:31 <tibbe> kolmodin: yo!
07:35:49 <kolmodin> tibbe: hi
07:35:53 <stevenmarky_> Is there a way I can do lambdabot like commands locally like src
07:36:08 <dschoepe> stevenmarky_: you could run lambdabot locally
07:36:19 <dschoepe> it works without an actual IRC connection too.
07:36:48 <dschoepe> and various parts are in separate packages, like pointful for @pl
07:36:56 <stevenmarky_> nice.
07:37:01 <tibbe> kolmodin: I'm curious what you meant by "looking at the primitives" in your twitter comment.
07:39:39 <kolmodin> tibbe: combining and manual inlining of the primitive
07:39:40 <kolmodin> s
07:39:58 <tibbe> kolmodin: do you have any commits I could look at?
07:43:45 <ksf> ahhh. now I remember why I wanted to use iteratees.
07:44:38 <ksf> the protocol parser expects the whole message (it's get-based, after all), but I need to stop reading after a couple of bytes for sys_splice to work.
07:44:42 <ski> @type \f -> left (\x -> f x)  -- PeakerWork : `left'
07:44:43 <lambdabot> forall b c d. (b -> c) -> Either b d -> Either c d
07:45:52 <ksf> really, get should work on lazy bytestrings.
07:46:35 <kolmodin> tibbe: it's uncommitted work so far
07:46:47 <tibbe> kolmodin: ok
07:46:53 <kolmodin> tibbe: but pretty much only removed the inlining
07:46:54 <tibbe> kolmodin: I guess I'll have to wait :)
07:47:01 <ski> > (unwords . map (either id id) . map (left reverse) . map (\s -> (if isUpper (head s) then Left else Right) s) . words) "This is Not a Proper sentence."
07:47:02 <lambdabot>   "sihT is toN a reporP sentence."
07:47:10 <kolmodin> tibbe: yeah, sorry, but it doesn't change the api or the code :)
07:47:16 <tibbe> kolmodin: could you send an email to the other maintainers and see what they think so we can get it into the main branch?
07:47:24 <tibbe> kolmodin: I'm just curious :)
07:47:29 <kolmodin> tibbe: next I started to implement the try functionality
07:47:35 <ski> PeakerWork : ^
07:47:39 <kolmodin> tibbe: but I didn't manage to finish in time, and now I'm quite busy
07:47:52 <kolmodin> been occupied the past couple of weeks, and this next week
07:48:01 <kolmodin> the week after that I'm also partly away
07:48:15 <kolmodin> food! bbl
07:49:22 <ksf> ...and network doesn't seem to support MSG_PEEK
07:49:38 <tibbe> kolmodin: ok! we don't have to get all the functionality in at once! getting the push stuff in there would be most useful
07:50:29 <ksf> so, unless I'm willing to cons a single byte to a strict bytestring, that parser gotta be rewritten.
07:52:16 <ski> > perWord (either id id . left reverse . cond (isUpper . head) Left Right) "This is Not a Proper sentence."
07:52:17 <lambdabot>   "sihT is toN a reporP sentence."
07:53:17 <Axman6> :t perWord
07:53:18 <lambdabot> (String -> String) -> String -> String
07:53:36 <ski> @type onWords
07:53:37 <lambdabot> ([String] -> [String]) -> String -> String
07:54:03 <Axman6> > perWord (\s -> if even (length s) then map toUpper s else s) "this should look strange"
07:54:04 <lambdabot>   "THIS SHOULD LOOK strange"
07:54:29 <Axman6> @hoogle perWord
07:54:30 <lambdabot> No results found
07:54:31 <ski> (see <http://www.haskell.org/haskellwiki/TV#IO> for `onWords' and `perWord')
07:55:42 <ski> > perWord (cond (even . length) (map toUpper) id) "this should look strange"
07:55:43 <lambdabot>   "THIS SHOULD LOOK strange"
07:56:07 <ski> <ski> @let cond :: (a -> Bool) -> (a -> b) -> (a -> b) -> (a -> b); cond p t e a | p a = t a | otherwise = e a
07:56:46 <ski> (i think `perWord' and `onWords' can be said to be SECs)
07:56:50 <ski> @where SEC
07:56:50 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
08:00:36 <chrisdone> kamatsu: http://www.chrisdone.com/posts/2010-04-04-hakyll-and-git-for-you-blog.html
08:05:45 <chrisdone> jaspervdj: git and stuff!
08:06:37 <ksf> damn these abstractions!
08:06:47 <ksf> If I were writing assembler, I wouldn't be thinking all the time!
08:06:50 <danderson> jaspervdj: been messing a lot with hakyll, I'm wondering why you defined dependencies as a union of source files, rather than a DAG of sources/intermediate results/outputs ?
08:07:32 <danderson> (it bothered me because I end up having to reannotate the same posts many times through different code paths when generating tag maps, the pages, and the feeds)
08:07:45 <Eelis> if i use writeFile to write a string containing fancy unicode characters, what character encoding will writeFile use? and how do i override it?
08:08:07 <jaspervdj> danderson: mostly, simplicity reasons
08:08:27 <jaspervdj> danderson: how do you mean, reannoting the same posts many times?
08:08:58 <stevenmarky_> <- newbie here, asking a question on SO: http://stackoverflow.com/questions/2574827/the-reason-for-monadstate-get-and-put
08:09:03 <Zao> @src writeFile
08:09:04 <lambdabot> writeFile f txt = withFile f WriteMode (\ hdl -> hPutStr hdl txt)
08:09:21 <danderson> jaspervdj: makes sense. The DAG would be more correct, but it feels painful to implement.
08:09:52 <danderson> jaspervdj: in my case, my hakyll script reads in all blog posts and annotates them (renderDate, renderTagUrl, etc.)
08:10:24 <danderson> but then, readTagMap reads FilePaths again, and forces me to reapply all those transforms to different instances of the same posts
08:10:24 <jaspervdj> danderson: Hmm, true
08:10:51 <jaspervdj> danderson: I should be able to cache the results somewhere
08:10:56 <danderson> ideally, I would read in all the posts once, annotate them, and then pass those to a function that constructs a tag map without rereading from source
08:11:27 <danderson> but I haven't looked at the caching logic at all, so I'm not sure if that sort of thing would work with that.
08:11:55 <ski> stevenmarky_ : btw, your second version can actually be simplified to `getRandom2 = State random'
08:11:58 <ski> (a) `get' and `put' abstracts over the internals of the `State' data type (you don't have to remember whether the new state comes first or second in the returned pair)
08:12:49 <ski> (b) `get' and `put' also works on any monad transformer stack that includes a `StateT s' in the stack/chain (or `State s' at the bottom)
08:13:03 <ski> @type State random
08:13:04 <lambdabot>     Ambiguous occurrence `random'
08:13:05 <lambdabot>     It could refer to either `System.Random.random', imported from System.Random
08:13:05 <lambdabot>                           or `Lava.random', imported from Lava
08:13:10 <chrisdone> modify random would probably ideal
08:13:12 <ski> @type State System.Random.random
08:13:13 <lambdabot> forall s a. (Random a, RandomGen s) => State s a
08:13:32 <chrisdone> ah, wait, modify doesn't return anything does it. n/m
08:13:54 <danderson> jaspervdj: that said, I'm pretty happy with how hakyll works. Once I've finished fiddling with my script again, my blog/site will probably start using that :)
08:14:07 <ski> @type modify
08:14:08 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
08:14:12 <Axman6> t Lava.random
08:14:16 <stevenmarky_> I see, thanks ski.
08:14:16 <Axman6> :t Lava.random
08:14:17 <lambdabot> forall a. (Constructive a) => Lava.LavaRandom.Rnd -> a
08:14:30 <Axman6> @hoogle lava
08:14:30 <lambdabot> No results found
08:14:31 <danderson> but the rereading of posts makes generating a 500 post blog very slow (~30s @2.4GHz)
08:14:51 <chrisdone> danderson: you have 500 posts!? fantastic use case
08:15:11 <ski> @type \f -> do s0 <- get; let {(a,s1) = f s0}; put s1; return a
08:15:12 <lambdabot> forall (m :: * -> *) s b. (MonadState s m) => (s -> (b, s)) -> m b
08:15:33 <danderson> chrisdone: I don't any more, I took the chance to prune my blog of very very old stuff
08:15:42 <chrisdone> ah :)
08:15:50 <jaspervdj> danderson: cool :-)
08:15:52 <danderson> now I'm down to ~80-100, which hakyll can render in ~3s
08:15:52 <ski> @let modify_ :: MonadState s m => (s -> (a,s)) -> m a; modify_ f = do s0 <- get; let {(a,s1) = f s0}; put s1; return a
08:15:52 <lambdabot>   MultiParamTypeClasses is not enabled
08:15:58 <ski> gah
08:16:09 <ski> @type let modify_ :: MonadState s m => (s -> (a,s)) -> m a; modify_ f = do s0 <- get; let {(a,s1) = f s0}; put s1; return a in StateT modify_
08:16:10 <lambdabot>     Occurs check: cannot construct the infinite type:
08:16:11 <lambdabot>       s = s1 -> ((a, s), s1)
08:16:11 <lambdabot>     Probable cause: `modify_' is applied to too few arguments
08:16:20 <ski> oh
08:16:23 <ski> @type let modify_ :: MonadState s m => (s -> (a,s)) -> m a; modify_ f = do s0 <- get; let {(a,s1) = f s0}; put s1; return a in State modify_
08:16:24 <lambdabot>     Occurs check: cannot construct the infinite type: s = s1 -> (s, s1)
08:16:24 <lambdabot>     Probable cause: `modify_' is applied to too few arguments
08:16:24 <lambdabot>     In the first argument of `State', namely `modify_'
08:16:48 <ski> @type let modify_ :: MonadState s m => (s -> (a,s)) -> m a; modify_ f = do s0 <- get; let {(a,s1) = f s0}; put s1; return a in modify_ . runState
08:16:49 <lambdabot> forall s a (m :: * -> *). (MonadState s m) => State s a -> m a
08:16:51 <chrisdone> ski's mind is crumbling
08:16:54 <ski> (sorry for the noise)
08:17:11 <ski> chrisdone : yes, i'm out of fuel
08:18:14 <ski> stevenmarky_ : did the previous explanation make any sense, btw ?
08:20:24 <stevenmarky_> almost... State isn't liable to change anytime is it? so why do we abstract the internals
08:20:51 <ski> @type let modify_ :: MonadState s m => (s -> (a,s)) -> m a; modify_ f = do s0 <- get; let {(a,s1) = f s0}; put s1; return a in modify_ System.Random.random
08:20:52 <lambdabot> forall s a (m :: * -> *). (MonadState s m, Random a, RandomGen s) => m a
08:21:10 <benmachine> stevenmarky_: State isn't the only way to carry state though
08:21:14 <ski> stevenmarky_ : the (b) reason is more important
08:22:31 <ski> `get' and `put' works both with `State s a' and `StateT s m a', and also with `t m a' for many monad transformers `t' (not including `StateT s' itself), assuming `m' supports `get' and `put'
08:22:43 <stevenmarky_> alright, that makes sense. thanks.
08:23:41 <ski> so if you have `WriterT Log (StateT MyState IO) a', then `put' and `get' will still manipulate the `MyState' state
08:23:51 <kamatsu> chrisdone: just realised my initial problem with that approach
08:24:10 <kamatsu> chrisdone: i have to maintain a haskell build system on my linode
08:24:19 <ski> (for some reason, i'm almost saying "`get' and `set'" instead of "`get' and `put'" ..)
08:24:27 <kamatsu> ski: heresy
08:24:32 <orlandu63> @src (==)
08:24:32 <lambdabot> x == y = not (x /= y)
08:24:35 <orlandu63> @src (/=)
08:24:35 <lambdabot> x /= y = not (x == y)
08:24:43 <kamatsu> orlandu63: fun, isn't it :P
08:24:47 <orlandu63> are these the actual implementations or just proof-of-concept?
08:24:51 <orlandu63> kamatsu: oh yes it is
08:24:55 <kamatsu> orlandu63: actual implementation
08:25:08 <orlandu63> wouldn't that recurse infinitely?
08:25:14 <kamatsu> orlandu63: do you know about typeclasses yet?
08:25:22 <ski> (kamatsu : .. i suppose my mind secretly thinks `get' fits better with `set' than with `put')
08:25:30 <chrisdone> ski: me too
08:25:33 <orlandu63> kamatsu: as in Num, Ord, etc?
08:25:38 <kamatsu> right
08:25:41 <kamatsu> Eq is such a typeclass
08:25:50 <kamatsu> so, == and /= are provided with implementations in terms of each other
08:26:11 <kamatsu> so that when you make a type an instance of Eq, you merely need to define one, and the other one is automagically defined for you
08:26:30 <ski> orlandu63 : those are default definition. at least one of them must be replaced, to break the vicious circle
08:26:58 <kamatsu> hm, i wonder if this works
08:27:02 <orlandu63> kamatsu: i see
08:27:02 <chrisdone> kamatsu: yeah, but it's not hard to install ghc
08:27:06 <kamatsu> @src (==) :: Int -> Int -> Bool
08:27:06 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
08:27:23 <ski> @src Int (==)
08:27:23 <lambdabot> (==) = eqInt
08:27:27 <benmachine> haha
08:27:28 <kamatsu> chrisdone: eh.. on my linode it uses some crazy non-arch distribution
08:27:29 <benmachine> helpful
08:27:31 <chrisdone> haha, cheeky
08:27:37 <benmachine> @src eqInt
08:27:38 <lambdabot> Source not found. Take a stress pill and think things over.
08:27:39 <chrisdone> kamatsu: non-arch?
08:27:40 <benmachine> :x
08:27:41 <Axman6> @src eqInt
08:27:42 <lambdabot> Source not found. Take a stress pill and think things over.
08:27:45 <kamatsu> chrisdone: as in, not arch linux
08:27:48 <Axman6> will do lambdabot
08:27:56 <chrisdone> kamatsu: what is it? mine's ubuntu
08:28:06 <kamatsu> mine probably is too
08:28:10 <kamatsu> i do have ghc on there
08:28:14 <kamatsu> but it's 6.10 i think
08:28:19 <chrisdone> that should be fine
08:28:21 <kamatsu> well, i guess hakyll will still work on that
08:28:21 <benmachine> interesting thing about defining class methods in terms of each other: you turn a compile-time warning to runtime non-termination
08:28:22 * chrisdone checks his ghc version
08:28:25 <orlandu63> do uname -a on it
08:28:31 <kolmodin> tibbe: it's already using CPS, so you can feed it chunks when it runs out of data
08:28:52 <tibbe> kolmodin: oh, didn't know you commited that to the main repo
08:28:58 <kolmodin> not the main repo, no
08:29:00 <chrisdone> kamatsu: haha, how do you get ghc to tell you its version?
08:29:03 <kolmodin> that's still in the other repo
08:29:21 <kamatsu> ghc --version
08:29:21 <orlandu63> benmachine: so the @src of (==) and (/=) are not actually the working implementations?
08:29:25 <ski> (`ghc --version' ?)
08:29:34 <kamatsu> orlandu63: one of them is, it depends on the types involved.
08:29:41 <chrisdone> ah, I typo'd
08:29:51 <chrisdone> kamatsu: yes, I'm on 6.10.4 so you should be fine
08:29:53 <kolmodin> tibbe: we could clean up the benchmarks and tests too
08:30:01 <tibbe> kolmodin: that would be nice
08:30:01 <benmachine> err what I meant was, if you leave a method definition out
08:30:05 <kamatsu> 6.12 is where all the cool kids are
08:30:15 <benmachine> (also, @src is at best a vague hint as to what Really Happens)
08:30:21 <chrisdone> kamatsu: it's hip to be square
08:30:22 <tibbe> kolmodin: my todo list is quite long after vacation :( but getting binary ready for HP is definitely a priority
08:30:22 <kamatsu> benmachine: "method"?
08:30:33 <kolmodin> tibbe: for me too
08:30:45 <benmachine> kamatsu: a function defined in a class
08:30:53 <kolmodin> tibbe: although I also do a lot of gentoo stuff. so my time is divided between these two
08:30:55 <kamatsu> benmachine: I don't believe that's what we call those.
08:30:59 <benmachine> I'm sure I've heard that
08:31:01 <benmachine> but whatever
08:31:03 <ski> orlandu63 : they are the *default* implementations. to define a working `Eq' instance for a new type, you usually define one of `(==)' and `(/=)' (overriding/replacing the default implementation), and the other default implementation will now call your version
08:31:04 <tibbe> kolmodin: sure
08:31:18 <chrisdone> kamatsu: in haskell they're called methods
08:31:25 <kamatsu> chrisdone: really?
08:31:34 <kamatsu> that's kind of strange
08:31:48 <orlandu63> ski: i see; thanks for clearing that up
08:32:00 <chrisdone> kamatsu: from the Haskell 98 report: A class declaration introduces a new class and the operations (class methods) on it.
08:32:12 <ski> (orlandu63 : if one has a more efficient implementation of one of those, than to use the default implementation calling the other one and `not'; i suppose that could be a reason to replace both of them .. or if you just want to be explicit/symmetric)
08:32:18 <chrisdone> kamatsu: why's it strange?
08:32:23 <kamatsu> chrisdone: Ah, I stand corrected.
08:32:52 <kamatsu> Because, typically I have only heard the word "method" use to describe a function that implicitly takes some object as its first argument.
08:33:31 <orlandu63> @src neInt
08:33:31 <lambdabot> Source not found. It can only be attributed to human error.
08:34:00 <chrisdone> kamatsu: technically Haskell's methods have to mention the type to implement in their type (forgetting recent extensions), so that kind of fits well
08:34:02 <ski> here it means roughly a function that implicitly takes a class dictionary/record as its first argument :)
08:34:02 <danderson> Aside from Config.Dyre to manage configurations, is there anything that does simple text configs?
08:34:04 <kamatsu> ascribing such OO terminology to a typeclass seems a stretch at best.
08:34:18 <ski> (if we assume the dictionary-passing implementation, i.e.)
08:34:31 <danderson> (the point is I don't really want to force the installation of 80M of haskell toolchain to run my code, so xmonad-like recompilation would be out)
08:34:54 <kamatsu> ski: right, but then by the OO definition of "method" they'd all be methods on said dictionaries
08:34:55 <chrisdone> danderson: yes, there is a ConfigFile library on Hackage
08:35:10 <ski> kamatsu : "they" referring to ?
08:35:16 <kamatsu> ski: the functions in the typeclass
08:35:24 <danderson> ah, yeah, just found it (it's not in the "Configuration" section, grmbl)
08:35:48 <ski> in haskell, all the operations in a class are called "method"s
08:35:51 <chrisdone> danderson: I guess that section was added afterwards :p
08:36:01 <kamatsu> ski: i know, and i'm saying that's strange
08:36:05 <danderson> chrisdone: looks like dyre inaugurated it, yeah
08:36:14 <ski> kamatsu : i'm not seeing why ..
08:36:24 <kamatsu> ski: because they're not bound to a data structure
08:36:33 <danderson> (notwithstanding, it's really cool that the magic reloading functionality of xmonad was factored out)
08:37:03 <chrisdone> danderson: I haven't heard about that -- is this to remove the GHC dependancy?
08:37:24 <ski> you could, to use strange terminology, say that they are all "bound to" a singleton object (the single unique instance of the class for the type(s) in question)
08:37:46 <danderson> chrisdone: dunno if xmonad proper uses it - but Dyre implements the same sort of logic as xmonad's recompile-and-reload logic
08:37:49 <chrisdone> kamatsu: but they are bound to a data type
08:37:49 <ski> kamatsu : but i suppose you think that ^ sounds even more strange :) ?
08:37:54 <kamatsu> ski: yes
08:38:12 <kamatsu> chrisdone: data structure, not type.
08:38:36 <chrisdone> kamatsu: I mean in haskell, the methods' types must include the type of the implementation
08:38:53 <kamatsu> right, but they're not bound to a specific data structure
08:39:05 <chrisdone> nope
08:39:05 <ski> kamatsu : if you think of `Eq Int' as a type, then there's only one value(/object) of that type in the language, namely the one defined by `instance Eq Int where ...'
08:39:13 <chrisdone> danderson: ah, sorry, I hadn't heard of dyre. this is nice
08:39:25 <danderson> though in my case, if I want dynamic reloading, I'd need a way to preserve open connections across reloads, hwhich would be a bit of a pain to implement
08:39:25 <kamatsu> ski: i understand what you're saying, but I still think this use of terminology is strange
08:39:52 <kamatsu> chrisdone: in OO languages, a method is something you can do to a specific object, to which the method is bound.
08:40:05 <chrisdone> danderson: hint could do that purpose?
08:40:07 <ski> kamatsu : since there's at most one object of this strange type (`Eq a'), we don't have to specify it, when it is to be passed to functions (methods or other functions which are overloaded on the class)
08:40:32 <baaba> @pl \f (x, y) -> f x y
08:40:32 <lambdabot> (`ap` snd) . (. fst)
08:40:49 <danderson> chrisdone: you mean interpret a .hs configuration at runtime?
08:41:00 <chrisdone> kamatsu: I suppose it's strange from common OO languages, although coming from Common Lisp and CLOS, it's not as weird to me
08:41:04 <ski> hm, though maybe it would be nicer to compare this not with the Singleton Object pattern, but with classes with only static methods (and ideally no constructor)
08:41:06 <chrisdone> danderson: yeah
08:41:17 <kamatsu> chrisdone: I'm just saying that it's not a method on a data structure, as in OO languages
08:41:29 <kamatsu> chrisdone: and hence such terminology is confusing
08:41:35 <danderson> chrisdone: yeah, that's one option, although the deps of hint appear to require pulling in all of ghc
08:41:43 <danderson> which is going to be painful in terms of binary size :(
08:41:57 <kamatsu> danderson: can't you use YAML or something?
08:41:59 <chrisdone> kamatsu: sure.  -- but! all methods have to return or take the data structure
08:42:03 <kamatsu> danderson: any particular reason to want Haskell?
08:42:10 <benmachine> kamatsu: arguably it is since the type in question has to appear in its signature
08:42:10 <ski> kamatsu : so, we don't say `Ord.max' to invoke the "static method" on the "static class" `Ord', we just say `max' (but then we can't have any other `max' in the same scope)
08:42:11 <chrisdone> danderson: ah, ok
08:42:24 <kamatsu> chrisdone: no, they have to take the type.
08:42:31 <kamatsu> chrisdone: there is no binding to a specific value of that type.
08:42:33 <ski> (s/on the/`max` on the/)
08:42:36 <benmachine> kamatsu: it's like, methods have implicit self as the first argument, but in haskell that self can be anywhere including in the return type
08:42:45 <danderson> kamatsu: not particularly, although it would be nice to be able to define routing policies in a real programming language. But yeah, I was going to go with .ini or yaml or something similar.
08:42:58 <chrisdone> kamatsu: can you define a haskell method without mentinoning the implementation's type in its type signature?
08:43:00 <baaba> @pl \(x, y) -> x == y
08:43:01 <lambdabot> uncurry (==)
08:43:14 <chrisdone> kamatsu: e.g. is the following valid: class Foo a where bar :: Int
08:43:14 <kamatsu> chrisdone, benmachine: It's not the type that matters, it's a priveleged value
08:43:31 <kamatsu> chrisdone: you might need to enable some extensions for that
08:43:40 <chrisdone> kamatsu: well, as I said before, forgetting recent extensions
08:43:52 <ski> benmachine : no, you can easily have `foo :: Foo a => Ignore a -> Blah', where `data Ignore a = Ignored'
08:43:59 <kamatsu> but i don't care that the type the class is instantiated over must be included in the definition
08:44:03 <kamatsu> that's not what I'm saying
08:44:27 <ski> benmachine : it is as kamatsu says, only the type variable(s) must appear .. values of them do not enter the picture
08:44:54 <chrisdone> ski: CLOS is similar, no?
08:45:37 <Jonno_FTW> how come I can't do g = flip . f, where f x y = x*y ?
08:45:41 <chrisdone> (defgeneric (mymethod myobject1 myobject2) ...)
08:46:01 <kamatsu> Jonno_FTW: lookat the type:
08:46:01 <chrisdone> :t flip $ \f x y -> x * y
08:46:02 <lambdabot> forall a t. (Functor ((->) t), Num a) => a -> t -> a -> a
08:46:03 <kamatsu> @type flip
08:46:04 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
08:46:08 <ski> chrisdone : i don't know very much about CLOS, but i think there multi-methods dispatches on the run-time class of several of its arguments .. so not that similar, iiuc
08:46:17 <benmachine> wait what
08:46:21 <kamatsu> Jonno_FTW: you want just "flip f"
08:46:22 <benmachine> :t fmap fmap fmap
08:46:23 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
08:46:31 <kamatsu> Jonno_FTW: or better still, "flip (*)"
08:46:43 <chrisdone> haha, caleskell
08:46:44 <benmachine> what on earth is with that Functor ((->) t) at the top?
08:46:49 <Jonno_FTW> ok, so i dnd't need the .
08:46:52 <kamatsu> Jonno_FTW: wait, what? why do you need to flip (*)?
08:46:54 <chrisdone> benmachine: see type of flip
08:46:57 <ski> @type Prelude.flip
08:46:58 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
08:47:02 <Jonno_FTW> it was an example function
08:47:02 <chrisdone> kamatsu: hahaha
08:47:12 <benmachine> chrisdone: yes but why is that in the context? that instance should already be in scope, shouldn't it?
08:47:48 <benmachine> just like (+ (1 :: Int)) doesn't have (Num Int) => Int -> Int
08:48:05 <ski> @type \f g -> fmap f (\x -> g x)
08:48:06 <lambdabot> forall a b t. (Functor ((->) t)) => (a -> b) -> (t -> a) -> t -> b
08:48:24 <ski> @type join id
08:48:25 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a)
08:48:25 <lambdabot>     Probable cause: `id' is applied to too few arguments
08:48:25 <lambdabot>     In the first argument of `join', namely `id'
08:48:32 <ski> er
08:48:46 <ski> @type \f -> join (\x -> f x)
08:48:47 <lambdabot> forall t a. (Monad ((->) t)) => (t -> t -> a) -> t -> a
08:49:17 <ski> so, for some reason, i think that instance is not in scope in the `type' command
08:49:26 <ski> (it *is* in scope in the `run' command, though(
08:49:29 <ski> ))
08:49:32 <kamatsu> hm, actually, can someone explain the (-> t) instance of monad? i've never used it and am wondering how it's useful
08:49:35 <benmachine> @type fmap fmap fmap
08:49:36 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
08:49:45 <benmachine> ^ it seems to not be a problem here?
08:49:46 <ski> kamatsu : s/(-> t)/(t ->)/
08:50:00 <kamatsu> ski: right, that one
08:50:09 <benmachine> kamatsu: the Reader monad is a wrapper over the (t ->) monad
08:50:10 <kamatsu> I meant (->) t
08:50:19 <chrisdone> > (+1) >> (*4) $ 1
08:50:20 <lambdabot>   4
08:50:26 <ski> kamatsu : either say `(t ->)' (an operation section at type level, iirc, this is not legal GHC atm) or `(->) t' (partial application, allowed syntax)
08:50:34 <ski> @src Reader
08:50:34 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
08:50:54 <benmachine> newtype Reader r a = Reader (r -> a)
08:50:54 <kamatsu> @src ask
08:50:54 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
08:50:58 <ski>   newtype Reader rho a = Reader {runReader :: rho -> a}
08:51:04 <benmachine> yeah or that
08:51:20 <chrisdone> > (+1) >>= (*) $ 2
08:51:21 <lambdabot>   6
08:51:45 <benmachine> ρ
08:52:04 <benmachine> hmm Ρ looks basically indistinguishable from P
08:52:30 <chrisdone> kamatsu: I don't think I've ever used it
08:52:36 <chrisdone> for anything useful
08:52:56 <ski> > (Reader (\r -> r + 1) >>= \x -> Reader (\r -> x * r)) `runReader` 2
08:52:57 <lambdabot>   6
08:52:57 <kamatsu> hm, ok
08:53:12 <chrisdone> :t do (*5); (+6); (^5)
08:53:13 <lambdabot> forall a. (Num a) => a -> a
08:53:23 <chrisdone> > (do (*5); (+6); (^5)) 3
08:53:24 <lambdabot>   243
08:53:29 <byorgey> kamatsu: it's useful when you have things like configurations that you will often need access to, don't change, and you don't want to explicitly pass around everywhere
08:53:46 <kamatsu> byorgey: well, the reader monad is good for that
08:53:49 <chrisdone> byorgey: are you talking about the Reader monad or the (r ->) monad
08:53:56 <byorgey> they are the same thing.
08:54:00 <byorgey> modulo a newtype wrapper.
08:54:05 <ski> > (ask >>= \r -> return (r + 1) >>= \x -> ask >>= \r -> return (x * r)) `runReader` 2
08:54:06 <lambdabot>   6
08:54:50 <ski> @pl \x -> f x x
08:54:50 <lambdabot> join f
08:55:09 <kamatsu> hm, i see
08:55:11 <ski> ^ is using `Monad (r ->)'
08:55:34 <kamatsu> TIL how the Reader monad worked
08:55:44 <ski> ("TIL" ?)
08:55:50 <kamatsu> today i learnt
08:55:54 <ski> ah, ty
08:56:02 <monochrom> hahahahaha there is an acronym for that?!
08:56:12 <kamatsu> monochrom: they use it at reddit alot
08:56:21 <monochrom> tl;dr
08:56:32 <monochrom>  = too lame; didn't read
08:56:38 <Mana|Linux> or too long
08:56:48 <monochrom> reddit is too lame
08:56:53 <kamatsu> lol
08:56:59 <Mana|Linux> ah.
08:57:10 <kamatsu> there's alot of haskell people on reddit it seems
08:57:14 <kamatsu> well, the haskell reddit
08:57:39 <kamatsu> further away you get from haskell reddit, the less civil everyone becomes
08:57:40 <chrisdone> thousands of subscriptions, hundreds of posters
08:57:53 <bremner> 3 ideas
08:57:57 <chrisdone> haha
08:58:10 * ski wonders whether there's any good reason for having the state and the output as *last* component of the pairs in `State'/`StateT' and `Writer',`WriterT'
08:58:21 <bremner> ski: doesn't matter.
08:58:43 <bremner> ski: to be precise, they do it the other way in RWH, and it doesn't seem to hurt
08:59:10 <bremner> mind you, if you saw the lame questions I ask about monads, you'd ignore my view
08:59:24 <ski> bremner : well, i'd like `State s' to be the composition of the two adjoint functors `(s ->)' and '(s,)'
08:59:54 <ski> (where the `s' is on the same side on the two operators)
09:00:31 <bremner> oh, wait. What I said is false. But I still think it doesn't matter
09:00:41 <ski> also, one can define `instance Functor (w,)', so to me it makes sense to have `Writer w a' be `(w,a)' instead of `(a,w)'
09:01:03 <kamatsu> Can you not define instance Functor (,w) ?
09:01:10 <ski> no
09:01:19 <kamatsu> why not?
09:01:22 <ski> you can't write type lambas
09:01:27 <ski> and you can't define
09:01:29 <kamatsu> oh, phooey
09:01:30 <kamatsu> right
09:01:35 <ski>   type Flip f a b = f b a
09:01:42 <kamatsu> (too much Agda)
09:01:46 <ski>   instance Functor (Flip (,) w)
09:02:24 <ski> (`Flip' must be applied to all the parameters that are given on the left of `=' in the definition)
09:02:41 <kamatsu> what if you made it a newtype?
09:02:48 <ski> that works, of course
09:03:02 <ski> (that is what `Writer' *is* .. a `newtype')
09:03:02 <kamatsu> but then, kind of needlessly complicated
09:03:27 <kamatsu> right, I see what you mean now
09:03:33 <bremner> ski: see for example http://en.wikibooks.org/wiki/Haskell/Advanced_monads#The_State_monad    where State is defined your way
09:04:20 <ski> another reason could be when one is explicitly writing `State $ \s -> (value,new_state)' and `Writer (value,output)' .. it might be more common for `value' to be the larger of the two expressions, in which case readability would improve with having `value' last in the tuple
09:04:46 <ski> .. however, i'm not sure whether it actually is more common for `value' to be the larger expression there
09:05:43 <kamatsu> no, i would think state would be larger in many cases
09:07:17 <Jonno_FTW> how come this doesn't work?: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24652#a24652
09:07:29 <ski> (obviously, if we ever change to `s -> (s,a)' and `(w,a)', then we should also correspondingly change the type of `random' and similar functions, so that we are consistent .. however, `mapAccumL' and `mapAccumR' (and friends for other datatypes) already is in the other way)
09:07:33 <ski> @type random
09:07:34 <lambdabot>     Ambiguous occurrence `random'
09:07:34 <lambdabot>     It could refer to either `System.Random.random', imported from System.Random
09:07:34 <lambdabot>                           or `Lava.random', imported from Lava
09:07:34 <ski> @type mapAccumL
09:07:35 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
09:07:38 <ski> @type mapAccumR
09:07:39 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
09:07:44 <ski> @type System.Random.random
09:07:45 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
09:08:23 <byorgey> Jonno_FTW: that looks like you're trying to apply 'show' to two functions?
09:08:41 <Jonno_FTW> :\
09:08:45 <byorgey> Jonno_FTW: I don't understand what you're trying to do
09:09:00 <Jonno_FTW> http://projecteuler.net/index.php?section=problems&id=33
09:09:30 <Jonno_FTW> trying to get the two numbers as a fraction
09:10:14 <byorgey> Jonno_FTW: what are f and g supposed to be?
09:11:08 <kamatsu> hokay, i'm going to go to bed and read, good night to you, fellow haskellers
09:11:27 <fax> ok
09:11:30 <Jonno_FTW> if you cancel the two numbers, f returns the numerator and g the denominator
09:11:33 <byorgey> Jonno_FTW: maybe you meant  f = same n m; g = same m n ?
09:11:55 <Jonno_FTW> isn't what i have equivalent?
09:12:11 <byorgey> no, you have declared f to be equal to the function 'same'
09:12:18 <Jonno_FTW> darn
09:12:24 <byorgey> it doesn't automatically apply it to n and m
09:12:43 <fax> hehe cancelling 9's
09:12:51 <fax> > 49/98 == 4/8
09:12:52 <lambdabot>   True
09:12:55 <fax> wow
09:13:41 <byorgey> what's so amazing about that?  just cancel the 9's.  ;)
09:13:46 <ski> @type ((State . (swap .)) .) . flip . mapAccumL . flip . (((swap .) . runState) .)
09:13:47 <lambdabot> forall s x y. (x -> State s y) -> [x] -> State s [y]
09:13:49 <ski> @type ((State . (swap .)) .) . flip . mapAccumR . flip . (((swap .) . runState) .)
09:13:51 <lambdabot> forall s x y. (x -> State s y) -> [x] -> State s [y]
09:14:25 <fax> ehehe
09:14:31 <fax> lets see
09:14:41 <Jonno_FTW> yes, well I need a program to cancel the nines for me
09:14:59 <byorgey> Jonno_FTW: I was joking =)
09:15:07 <fax> a/b ---(1+x)--> (a+b)/b
09:15:21 <fax> a/b ---(1/(1+1/x))--> a/(a+b)
09:15:57 <Jonno_FTW> well i got that bit working
09:16:06 <Jonno_FTW> but the rest doesn't
09:16:28 <fax> > let n x = 1 + x ; d x = 1/(1+1/x) in [n,d,n.n,n.d,d.n] . ($1)
09:16:29 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
09:16:37 <fax> > let n x = 1 + x ; d x = 1/(1+1/x) in ($1) . [n,d,n.n,n.d,d.n]
09:16:38 <lambdabot>   [2.0,0.5,3.0,1.5,0.6666666666666666]
09:16:52 <fax> it would be better if they were fractions
09:17:04 <ski> Jonno_FTW : maybe you wanted to apply both `f' and `g' to `n' and `m' ?
09:17:13 <fax> oh wait
09:17:17 <Jonno_FTW> nah, it's ok
09:17:22 <fax> it doesn't matter that the digits are at opposite sides
09:17:23 <Sgeo> @hoogle (a->a)->Int->a->a
09:17:23 <lambdabot> Data.Sequence adjust :: (a -> a) -> Int -> Seq a -> Seq a
09:17:23 <lambdabot> Data.IntMap adjust :: (a -> a) -> Key -> IntMap a -> IntMap a
09:17:23 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
09:17:30 <ski> (oh, byorgey already said that)
09:18:00 <byorgey> @type \f n x -> iterate f x !! n
09:18:01 <lambdabot> forall a. (a -> a) -> Int -> a -> a
09:18:10 <byorgey> Sgeo: ^^^ try that
09:18:11 <ski> @type \f n -> foldr (.) id (replicate n f)
09:18:12 <lambdabot> forall b. (b -> b) -> Int -> b -> b
09:18:37 <Jonno_FTW> except now I get an error with this: [(n%d)|d<-[11..99],n<-[11..d-1],(usame n d) == (n%d)]
09:18:45 <Sgeo> hm, ty
09:18:49 <Jonno_FTW> *** Exception: Prelude.read: no parse
09:19:04 <Sgeo> Although I'd probably use genericTake
09:19:15 <byorgey> Jonno_FTW: probably from when n and m are the same
09:19:29 <byorgey> > show 33 \\ show 33
09:19:30 <lambdabot>   ""
09:19:36 <byorgey> > read (show 33 \\ show 33) :: Int
09:19:37 <lambdabot>   * Exception: Prelude.read: no parse
09:19:46 <Jonno_FTW> ok
09:20:01 <byorgey> oh, wait, you did n <- [11..d-1]
09:20:05 <byorgey> hmm
09:20:15 <Jonno_FTW> it would still happen
09:20:20 <Jonno_FTW> maybe
09:20:34 <byorgey> > show 21 \\ show 12
09:20:35 <lambdabot>   ""
09:20:39 <byorgey> there we go
09:20:42 <ski> > read ('0' : show 33 \\ show 33) :: Int
09:20:43 <lambdabot>   Precedence parsing error
09:20:43 <lambdabot>      cannot mix `:' [infixr 5] and `Data.List.\\' ...
09:20:46 <Jonno_FTW> how do i avoid this?
09:20:50 <ski> > read ('0' : (show 33 \\ show 33)) :: Int
09:20:50 <lambdabot>   0
09:20:59 <ski> > read ('0' : (show (-33) \\ show 33)) :: Int
09:21:00 <lambdabot>   * Exception: Prelude.read: no parse
09:21:10 <Sgeo> I think I'm over-engineering
09:21:14 <Jonno_FTW> -33 isn't going to come up
09:21:36 <ski> > read ('0' : (show 2.5 \\ show 5.2)) :: Int
09:21:37 <lambdabot>   0
09:21:43 <ski> (probably not that either, i suppose ..)
09:22:30 <Jonno_FTW> > show 12 \\ show 21
09:22:31 <lambdabot>   ""
09:22:50 <Jonno_FTW> > read $ '0' : (show 12 \\ show 21) :: Int
09:22:51 <lambdabot>   0
09:23:32 * ski wouldn't bother to use `$', there .. ymmv
09:24:16 <Jonno_FTW> > read '0' : (show 12 \\ show 21) :: Int
09:24:17 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
09:24:17 <lambdabot>         against inferred ty...
09:24:34 <Jonno_FTW> :|
09:24:39 <ski> (*sigh*, brackets)
09:24:54 <ski> > read ('0' : (show 12 \\ show 21)) :: Int  -- ok ?
09:24:55 <lambdabot>   0
09:25:12 <Jonno_FTW> what's wrong with replacing brackets with $ ?
09:25:41 <ski> nothing, except that imo, it doesn't improve readability in this case
09:25:58 <arw_> nothing. just a matter of taste, therefore a personal preference.
09:26:14 * ski nods
09:27:02 <Jonno_FTW> i agree with you in this case
09:27:34 <zakwilson> I'm looking for an explanation of how to do IO on thousands of files at once without exhausting file handles or memory. I've managed to use unsafeInterleaveIO to avoid running out of file handles, but I still end up with everything in memory at once (I think)
09:28:10 <ddarius> zakwilson: How would you do it in another language?
09:30:03 <Jonno_FTW> HAZAH! i got it right!
09:31:10 <Jonno_FTW> all in a respectable 13 lines
09:31:22 <Philonous1> zakwilson: unsafeInterleaveIO is exactly what you should avoid. It delays the IO until some unspecified time in the future. So you loose control over when handles are created and closed and you could run out of handles even when you never use more files than the OS permits at once
09:31:24 <zakwilson> In Scheme or Clojure, I'd do something like (map f directorylisting), expecting it to operate one file at a time and GC the file contents after f is done with them. In Clojure, I might force evaluation with doall .
09:32:01 <zakwilson> Philonous1: without unsafeInterleaveIO, I run out of file handles. With it, I run out of memory.
09:32:01 <ddarius> zakwilson: If that's all you need, simply mapM_ f directoryListing
09:32:36 <zakwilson> ddarius: I run out of file handles when I do that.
09:32:49 <Eelis> which field in cabal's InstallDirs record is for non-user-specific config files (i.e. /etc on *nix)?
09:32:58 <ddarius> zakwilson: Are you using readFile to read the contents of the file?
09:32:59 <Philonous1> zakwilson: Does "f" close the handles?
09:33:06 <ddarius> (or hGetContents)
09:33:19 <zakwilson> Philonous1: f uses readFile
09:33:42 <ddarius> zakwilson: Yeah, the Prelude readFile uses unsafeInterleaveIO which is likely causing your problem.
09:34:54 <byorgey> Jonno_FTW: \o/
09:35:15 <Jonno_FTW> runs in 0.078 seconds
09:35:36 <zakwilson> Actually, this is Data.ByteString.Lazy.readFile, which might actually be the source of the problem. I'm then feeding the data to Codec.Compression.GZip.decompress, which expects a lazy bytestring. I'm not sure how to read the file in a safe, strict way, then get a lazy bytestring.
09:35:39 <Jonno_FTW> and now for some well earned sleep
09:36:40 <ddarius> zakwilson: Use the strict bytestring readFile and then use fromChunks to convert it to a lazy bytestring.
09:36:56 <zakwilson> ddarius: I'll try that. Thanks.
09:38:18 <ddarius> zakwilson: This, of course, assumes that each individual file itself is "small," i.e. you don't mind having the entire contents of one file in memory at a time.
09:39:56 <zakwilson> ddarius: The files are small. It's just that there are 27,000 of them.
09:40:21 <zakwilson> It's running now, and consuming memory much more slowly than before.
09:41:28 <zakwilson> It actually worked before when it was loading all the data at once if the files were small enough. When I made them larger, it started running out of memory.
09:43:11 <Sgeo> Is there any way to have two modules in the same file?
09:43:38 <ddarius> Sgeo: Not with any current implementations.
09:44:39 <Sgeo> Hm. Are there any builtin functions like iterate, but they work with (a -> Maybe a)?
09:44:46 <Twey> unfold
09:44:49 <Twey> :t unfoldr
09:44:49 <ddarius> :t unfoldr
09:44:50 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
09:44:50 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
09:44:53 <Twey> Heh
09:45:19 <Sgeo> Except I'm not dealing with tuples
09:45:24 <Twey> b is the internal state used to generate the list, and a is the item to return in the new list
09:45:34 <ddarius> :t \f -> unfoldr (fmap (id &&& id) . f)
09:45:35 <lambdabot> forall a. (a -> Maybe a) -> a -> [a]
09:45:50 <Sgeo> ddarius, I have no idea how that works
09:46:05 <ksf> :t mfix
09:46:06 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
09:46:06 <Twey> Suffice it to say that you can do what you want with unfoldr
09:46:18 <ksf> :t mfix Just
09:46:19 <lambdabot> forall a. Maybe a
09:46:39 <Sgeo> :t (&&&)
09:46:40 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
09:46:47 <Vanadium> :t iterate
09:46:48 <lambdabot> forall a. (a -> a) -> a -> [a]
09:48:16 <ddarius> :t until isNothing (f . fromJust)
09:48:16 <lambdabot> forall a. (Show a, SimpleReflect.FromExpr (Maybe a)) => Maybe a -> Maybe a
09:48:21 <Sgeo> :t fmap (id &&& id)
09:48:22 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f (a, a)
09:48:24 <ddarius> :t \f -> until isNothing (f . fromJust)
09:48:25 <lambdabot> forall a. (a -> Maybe a) -> Maybe a -> Maybe a
09:48:39 <ddarius> :t \f -> until isNothing (f . fromJust) . Just
09:48:40 <lambdabot> forall a. (a -> Maybe a) -> a -> Maybe a
09:49:35 <zakwilson> ddarius: that solved my problem. It doesn't exhaust file handles or memory that way.
09:49:54 <ddarius> zakwilson: Moral of the story: Lazy IO is the spawn of the devil.
09:50:46 <zakwilson> I'm just not understanding why lazy is translating in to not making things eligable for GC until all the IO is done.
09:51:52 <benmachine> zakwilson: because later evaluation could cause IO to happen, so you can't let go of the handle
09:52:42 <zakwilson> I kindasortathink I get it.
09:53:07 <benmachine> I did something similar to this
09:56:34 <benmachine> zakwilson: you can use the lazy readfile as long as you force evaluation of the whole thing
09:58:33 <zakwilson> benmachine: I tried doing that with Control.Exception.evaluate. It didn't seem to work, but I may have had a problem elsewhere.
09:59:49 <Vanadium> What where you evaluating? The length?
10:01:32 <benmachine> zakwilson: evaluate only does the top-level constructor, so you have to make sur eyou're evaluating enough to force the end of the list
10:01:41 <Sgeo> It wouldn't be sinful to just go with what I understand and have iterate operate on a returned value, would it?
10:02:04 <Twey> Sgeo: No?  I'm not sure exactly what you're trying to do
10:02:11 <Twey> iterate and unfoldr do different things
10:02:14 <ddarius> Sgeo: Sticking with what you understand is a great way to learn new things.
10:02:22 * Twey laughs.
10:02:58 <Twey> Sgeo: Give a specification of the function you want to write.  What is its type?  What are its inputs?  What are its outputs?  Could you perhaps give a sample call and its result?
10:03:36 <Sgeo> I have moveLeft :: Tape a -> Maybe (Tape a)
10:03:36 <Sgeo>  where Tape a is a BF tape
10:03:45 <Sgeo> (and an analogous moveRight)
10:04:21 <Sgeo> and I want to write moveBy, such that moveBy :: Tape a -> Integer -> Tape a
10:04:37 <Sgeo> Moves the tape to the right for positive input, left for negative input
10:04:43 <Twey> BF?
10:04:51 <Sgeo> BF=Brainf*ck
10:05:00 <Twey> Oh, Br**nfuck
10:05:03 <Twey> Okay
10:05:14 <ski> > (\f -> until isNothing (f . fromJust) . Just) (\x -> guard (x < 100) >> Just (2*x)) 1
10:05:15 <lambdabot>   Nothing
10:05:25 <Twey> Well, if moveLeft and moveRight can fail, then moveBy must be able to fail too, no?
10:05:35 <Sgeo> Oh, right
10:05:49 <Sgeo> moveBy :: Tape a -> Integer -> Maybe (Tape a)
10:05:55 <Twey> Right
10:06:05 <Twey> And a Tape is what?
10:06:12 <Twey> A zipper?
10:06:19 <Sgeo> data Tape a = Tape [a] a [a]
10:06:21 <ski> probably `([a],[a])' ..
10:06:24 <ski> ok
10:06:34 <Twey> Okay
10:06:42 <Twey> So why do you need iterate?
10:07:01 <Sgeo> To repeatedly moveLeft or moveRight?
10:07:10 <Twey> That's not quite what iterate does
10:07:17 <Twey> Although I guess you can shoe-horn it to that purpose
10:07:28 <Twey> Okay, let's go with that, then
10:07:34 <Sgeo> BRB
10:07:51 <Twey> Right-ho…
10:09:16 <Sgeo> Back
10:09:28 <Sgeo> Anyway, I think I should attempt to learn unfoldr
10:10:03 <Twey> unfoldr isn't what you want here
10:10:13 <Twey> (though you should learn it)
10:10:18 <Twey> (it's immensely powerful)
10:10:36 <Twey> You probably do just want iterate
10:11:18 <Twey> The problem is that iterate only goes one way
10:11:26 <Twey> I guess you should guard on the number
10:12:14 <Sgeo> I think I can figure it out in terms of turning moveRight into something with Maybe (Tape a) -> Maybe (Tape a) on my own
10:13:16 <Twey> You want to use the Monad instance for Maybe
10:13:18 <Sgeo> @hoogle (a -> Maybe b) -> Maybe a -> Maybe b
10:13:18 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
10:13:18 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
10:13:18 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
10:13:24 <Twey> Precisely ☺
10:13:43 <SamB_XP> why should moveLeft and moveRight be able to "fail"?
10:13:52 <Sgeo> SamB_XP, if the tape is bounded
10:14:12 <mreh> how can I use cabal to build profiling and normal version of a library
10:14:15 <SamB_XP> generally, they either scramble your RAM or implicitly expand the tape when you go too far
10:14:51 <chrisdone> chr1s: ping
10:15:08 <ddarius> SamB_XP: It could wrap as well.
10:15:37 <Sgeo> I don't know how I'd make the tape wrap with my implementation
10:15:42 <Sgeo> Someone elsewhere said it was impossible
10:16:15 <ski> you could just `reverse'
10:16:20 <Gracenotes> I've been thinking... the degree to which stdout-writing is referentially transparent. It *can* be, if you don't count the whole real-world-as-state business.. or am I reasoning myself into a hole?
10:17:12 <SamB_XP> Sgeo: you probably haven't read enough Okasaki ;-P
10:17:17 <Gracenotes> also, piping into something can possibly change the state of things elsewhere, but if you're not reading said states, then what's the difference
10:17:42 <Sgeo> Okasaki?
10:17:53 <ski> Gracenotes : i think that could be seen as the idea behind `trace'
10:18:04 <SamB_XP> @amazon Purely Functional Data Structures
10:18:05 <lambdabot> Unknown command, try @list
10:18:10 <SamB_XP> @google Purely Functional Data Structures
10:18:12 <ski> Sgeo : the book "Purely Functional Data Structures" by Chris Okasaki
10:18:12 <lambdabot> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
10:18:13 <lambdabot> Title: Purely Functional Data Structures
10:18:20 <SamB_XP> @google Purely Functional Data Structures site:amazon.com
10:18:21 <lambdabot> http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504
10:18:24 <Sgeo> Oh, it's free?
10:18:32 <ski> (earlier version also available as that thesis)
10:18:33 <malie> just run across ghc ticket #3353 on ghc 6.12.1, seems there is no solution yet...
10:18:34 <SamB_XP> there's a free version (the thesis there)
10:18:44 <SamB_XP> and a more polished version (the book shown on amazon)
10:19:08 <Gracenotes> hmm
10:20:58 <malie> nobody here using c2hs on 6.12.1?
10:24:16 <ManateeLazyCat> Oh, I got this result again.  http://farm3.static.flickr.com/2781/4490405000_945a460fe6_o.png
10:25:23 <ManateeLazyCat> I just write some Google syntax to search book.
10:26:22 <scanish> someone here who can explain to me why my .a lib made with cabal doesn't know the "atexit" symbol and how I can add it?
10:27:01 <monochrom> atexit sounds like C's runtime system
10:28:27 <scanish> yes i am writing a binding to some library that uses a reference to atexit(), but not in their lib but in a macro I have to use
10:29:19 <stevenmarky_> ew, ugly chrome theme!
10:30:14 <ManateeLazyCat> stevenmarky_: Google filter my IP for speical search. But i just use google syntax search eBooks.
10:33:58 <scanish> so would there be any way to convince Cabal to include the atexit thingie from the standard C library?
10:34:51 <Zao> scanish: Sounds unlikely that you'll have any Haskell environment still running at atexit time.
10:35:07 <Zao> Unless you ignore cleaning it up, but isn't execution of atexit handlers undefined?
10:36:46 <scanish> zao: you're right, but the original library kind of says it needs their cleaning - I tried to encase it in a monad, but that only lead to the lib cleaning too early and finalizing the pointers lead to a segmentation fault
10:40:53 <scanish> zao: also, is it smarter to use safe or unsafe binding to an external C function?
10:41:49 <Zao> That's mostly about reentrancy, isn't it?
10:44:12 <scanish> no idea
10:44:50 <pastorn> in drscheme + #lang slideshow, how do i turn on typechecking?
10:44:50 <Zao> I'm sure the docs can tell you :)
10:44:53 <pastorn> oh
10:44:56 <pastorn> wrong channel
10:44:59 <Zao> pastorn: By using Haskell instead.
10:45:02 <mibygl> So, I have a bunch of Cabal packages that are installed in a certain directory, but I'd like them to be in a different directory instead.
10:45:08 <pastorn> Zao: haha
10:45:20 <pastorn> Zao: i'm working with this: file:///usr/share/plt/doc/quick/index.html
10:45:21 <mibygl> Is it possible to move them from one directory to the other without reinstalling them?
10:45:23 <pastorn> sorry
10:45:32 <pastorn> Zao: http://docs.plt-scheme.org/quick/
10:47:31 <IanCal> I'm trying to set up a nice dev env, but projects.haskell.org seems to be down, are there any mirrors of vim haskellmode? My google-fu is lacking
10:48:27 <Zao> pastorn: Looks like fun.
10:49:34 <pastorn> Zao: it is :)
10:50:10 <Zao> IanCal: http://www.acc.umu.se/~zao/dotvim.tar.bz2
10:50:11 <pastorn> Zao: the cool part about using lisp instead of haskell is that there are no constructors to get in your way, no run functions or anything
10:50:25 <Zao> IanCal: That's my .vim; it should only contain a color scheme, NERDtree and haskellmode.
10:50:43 <IanCal> Zao: That's really helpful, thanks :)
10:51:06 <pastorn> Zao: NERDtree? what's that?
10:51:16 <IanCal> pastorn: it's a file manager in vim
10:51:22 <Zao> pastorn: Directory browser window, kind of.
10:51:28 <pastorn> oh, cool
10:52:02 <pastorn> i have a vimrc that sets ALT+numbers to switch to different tabs and tabs=4*space
10:52:04 <pastorn> interested?
10:52:13 <pastorn> *gvimrc*
10:52:25 <Zao> pastorn: Would collide with my xmonad bindings.
10:52:32 <Zao> I've got enough things overloaded on Alt-numbers already :P
10:52:39 <pastorn> Zao: windows button?
10:53:00 <IanCal> Yeah, I use mod-4 (windows button) for that (although I'm a wmii man :p )
10:53:08 <fax> :t toEnum
10:53:09 <lambdabot> forall a. (Enum a) => Int -> a
10:53:17 <pastorn> IanCal: gogo filesystem!
10:54:31 <IanCal> pastorn: :D
10:55:44 <pastorn> this channel is so much nicer than #scheme :)
10:56:08 <scanish> because haskell is so much nicer than scheme
10:56:28 <scanish> we got the power of the type on our site
10:57:01 <pastorn> scanish: in #scheme it's like if True then RTFM! else RTFM!
10:57:47 <scanish> pastorn: scheme has a manual? there's 20 different versions of it
10:58:01 <ezyang> "R5RS"
10:58:19 <ezyang> see also http://web.mit.edu/~axch/www/scheme/choices.html
10:58:37 <ezyang> in particular http://web.mit.edu/~axch/www/scheme/choices/non-ascii-integer-to-char.html
10:59:06 <Cale> Not R6RS?
10:59:26 <ezyang> does anyone actually use R6RS?
11:00:11 <scanish> ezyang: Does anyone actually use pure Haskell98?
11:00:30 <ezyang> scanish: touché
11:00:32 <Cale> I'm not sure. PLT seems to refer to it...
11:00:48 <pastorn> ugh... there are too many versions of this language!
11:00:58 <Cale> heh
11:01:22 <fax> lots of peopl think R6RS is great
11:01:28 <scanish> when I switched to the R5RS standard, PLT became unusable
11:01:41 <fax> in a few years all the R8RSers will be laughing at us R5RSers for using such a ridiculously small language
11:01:49 <scanish> just the macro system alone is so version dependant
11:02:05 <fax> scanish, you mean dependent on the R5RS ?
11:02:20 <fax> syntax-rules will work across implementations
11:02:20 <ezyang> it looks like PLT scheme is the big player that does R6RS
11:02:26 <scanish> fax: no dependent on the implementation
11:02:31 <fax> what?
11:02:37 <pastorn> shit... i'd like to see a timeline of all these versions and what was added etc...
11:03:07 <fax> I think you must have got the wrong end of the stick at some point
11:03:09 <scanish> every scheme implementation coes wit its own subset of the macro system
11:03:14 <ezyang> part of the problem is no one has been able to actually make a macro system that 1. doesn't have stupid bugs and 2. is understandable by mere mortals
11:03:17 <scanish> *comes with
11:03:39 <scanish> and the macro system in the r6rs is just ignored
11:03:41 <ezyang> the problem has managed to generate many phd theses
11:04:31 <pastorn> ezyang: hehe :)
11:05:42 <fax> Cale (on homotopy calculus) I think I found something
11:05:58 <IanCal> I've got to shoot, thanks again for that Zao, I'll have some happy hacking tonight :)
11:06:10 <fax> this category theory stuff, http://www.andrew.cmu.edu/user/awodey/ has some "Homotopy theoretic models of identity types" which I can't imagine *not* being related
11:07:39 <T_S_> code.haskell.org looks like it is dead. Anyone know when it will be resurrected?
11:07:56 <Jafet> No.
11:08:05 <Zao> When Jesus comes back?
11:08:20 <pastorn> i can't load it :)
11:08:22 <pastorn> :(
11:08:25 <Jafet> When perl 6 is released.
11:08:26 <Zao> My legacy religion knowledge is weak. Is it now he dies or resurrects?
11:08:36 <pastorn> what was code.haskell.org?
11:09:11 <Zao> Repositories?
11:09:15 <Saizan> Zao: died 3 days ago, resurrected today
11:09:19 <fax> I can't follow it
11:09:33 <T_S_> I was running "darcs get http://code.haskell.org/hmatrix"
11:09:35 <arw_> but will make another reappearance in 40 days or so.
11:10:11 <Saizan> only if you keep chanting "encore! encore!"
11:10:49 <Cale> fax: Interesting, thanks :)
11:14:49 <monochrom> preflex: seen jfredett
11:14:49 <preflex>  jfredett was last seen on #haskell-blah 26 days, 9 hours, 49 minutes and 37 seconds ago, saying: and with that, I bid Adeiu to you, fair Haskellians, I go now to sleep.
11:15:18 <monochrom> and not woken since? sleeping beauty?
11:15:33 <monochrom> we need a prince to kiss him awake!
11:17:49 <T_S_> Can anybody get a sensible response from "darcs get http://code.haskell.org/hmatrix" ?
11:18:10 <chrisdone> code.haskell.org is still down
11:18:11 <Zao> T_S_: As projects.h.o is down, it's likely down too.
11:18:13 <chrisdone> ~_~
11:19:08 <T_S_> Thanks Zao and chrisdone. Any eta on its revival?
11:20:42 <Zao> No idea. The responsible people probably don't know it's down.
11:22:03 <byorgey> actually, it seems like it's only the web server on code.haskell.org that is down
11:22:07 <byorgey> I can ssh into it fine
11:22:13 <Saizan> yeah
11:22:15 <byorgey> load average is only 0.07
11:22:48 * Saizan wonders if Igloo is around
11:22:53 * hackagebot wai-extra 0.0.0.1 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-0.0.0.1 (MichaelSnoyman)
11:29:12 <ksf> "legacy religion" is good.
11:49:09 <frja> Hi! (On Windows, GHC 6.12) When compiled with "-threaded" I cannot break (ctrl-c) when the program is waiting for a tcp connection (listenOn/accept), if I remove the -threaded flag, it immediately breaks. Can someone please give some advice on how to work around that?
11:52:38 <FliPPeh> frja: Can't you break it at all, or did you just try it once?
11:52:39 <Tarrasch> Hello, the Haskell School Of Expression has decided to give out it's source code in a strange format. Is there any easy way to just remove those "<" and "|" -lines? Here is what I'm talking about: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24661#a24661
11:52:53 <FliPPeh> Because here, in some programs I write I'd have to type Ctrl-C twice
11:53:21 <Jafet> Tarrasch, did you read the first few lines
11:53:31 <Jafet> It's in Knuth's wacky "literate programming" format
11:53:45 <SamB_XP> Jafet: knuth didn't make one for Haskell!
11:53:50 <FliPPeh> Tarrasch: If you use vim, you could press Ctrl-V an remove the first 2 characters on any line
11:53:51 <ksf> {-# LANGUAGE LiterateHaskell #-}
11:54:17 <FliPPeh> Ctrl-V is block selection
11:54:17 <frja> FliPPeh: Cannot break it at all, have to kill the process. If I connect to it with telnet, it immediately break the program after the accept returns though.
11:54:29 <FliPPeh> Mh :/
11:54:32 <ksf> withSocketsDo?
11:54:34 <Cale> It's just literate haskell. Save it in a .lhs file
11:54:42 <Cale> and it'll just work, no need to change anything
11:54:43 <ksf> network stuff is said to be funky on windows.
11:54:54 <Tarrasch> Cale, it is in a .lhs, wait, does the compiler automatically remove the "junk" ?
11:54:58 <Cale> yes
11:55:02 <FliPPeh> Yes
11:55:02 <SamB_XP> Tarrasch: that's the idea, yeah ;-)
11:55:03 <Cale> That's what .lhs means
11:55:04 <Tarrasch> goddamn
11:55:07 <FliPPeh> While we're on the topic
11:55:10 <edwardk1> @hpaste
11:55:10 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
11:55:10 <Cale> Lines beginning with > are code
11:55:12 <frja> ksf: Yea, I have that first in my main.
11:55:15 <Cale> everything else is a comment
11:55:19 <FliPPeh> Can I invoke "unlit" myself and safe the unlit'd file?
11:55:29 <Cale> FliPPeh: I think you can
11:55:43 <Tarrasch> bah I can't be bothered seeing those lines, I write a converter myself (shouldn't be to difficult I think)
11:55:46 <edwardk1> hrmm. i just had a neat idea: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=9319#a9319
11:55:48 <FliPPeh> I'll browse the docs for that
11:55:49 <FliPPeh> :)
11:55:56 <edwardk1> that gives arrays that can be used as functions
11:56:15 <ksf> grep ^> foo.lhs > foo.hs
11:56:26 <ksf> then either do awk magic or just vim and block selection
11:56:41 <edwardk1> you can then just say things like listArray ('a'..'z') [1..] 'c'
11:56:51 <edwardk1> you can still use them as arrays though
11:57:04 <Cale> Tarrasch: does it really look like the paste all doublespaced like that?
11:57:20 <edwardk1> this generalizes to effectively providing overloaded application
11:57:43 <Tarrasch> Cale, nope, must've been some error between gedit/firefox/paste or something
11:58:08 <edwardk1> i'm using it in my sat solver to provide a solution as either an intmap or a function from a literal to a value depending on how it is used.
11:58:25 <ddarius> edwardk1: Using ! or sectioning it is really not that burdensome.
11:59:25 <ddarius> (!) -- | Converts an array to a function.
11:59:26 <edwardk1> ddarius: well the same thing works for memo tables, etc.
11:59:29 <edwardk1> yes
11:59:53 <edwardk1> but in general there are a lot of data types that are just concrete representations of functions
12:00:08 <edwardk1> i just thought it was neat that you COULD choose to encode something like this =)
12:00:12 <ddarius> They are usually "more" than functions.
12:00:23 <Cale> Tarrasch: Find the 'unlit' program, which will probably be somewhere like /usr/local/lib/ghc-6.10.4/unlit
12:00:39 <edwardk1> ddarius: sure, but it is nice to have access to the ability to use juxtaposition
12:00:52 <Tarrasch> Cale, the pleasure is writing the program that for the first time can be considered "kinda useful" :p
12:00:54 <Cale> Tarrasch: You give it the name of an lhs file and then where to save the stripped output, and it'll do the conversion
12:00:58 <Cale> ah :)
12:01:10 <Tarrasch> Cale, exactly what I'm about to do ^^
12:02:37 <Tarrasch> maybe offtopic, but does vim have any auto-align, kinda  ineffective to push space 10 times after each new-line
12:02:58 <ksf> :set et
12:02:59 <ddarius> Tarrasch: I just use autoindent.  :set ai
12:03:13 <Tarrasch> what is et then?
12:03:13 <ksf> there's a haskell mode, too
12:03:18 <ksf> expand tab
12:03:20 <ddarius> Tarrasch: Anyway, press tab and expandtabs which is what et is.
12:03:30 <edwardk1> just be warned, like most AI, :ai doesn't do nearly as good of a job as you'd expect ;)
12:03:35 <Tarrasch> but it makes the tabs to spaces, right?
12:03:40 <ksf> yep
12:03:48 <pastorn> geon:
12:03:52 <pastorn> @src mapM_
12:03:53 <lambdabot> mapM_ f as = sequence_ (map f as)
12:03:57 <ksf> is -fwarn-tabs default by now?
12:03:58 <ddarius> edwardk1: The thing is ai does something consistent and predictable.
12:04:27 <ksf> but it's not smart enough to dedent once your pattern matches are complete
12:04:33 <Cale> Tarrasch: Yeah, you definitely want tabs being converted to spaces at every opportunity
12:05:11 <Tarrasch> thanks guys
12:07:21 * Sgeo vaguely wishes IO a was an instance of Eq
12:07:36 <Eelis> Sgeo: what on earth would that mean?
12:07:58 <Sgeo> Eelis, nice way to test the IO portion of the code. If .. hm
12:08:00 <Sgeo> Maybe not
12:08:40 <Sgeo> It would mean that, say, getLine == getLine
12:08:59 <jlouis> Tarrasch: also check :help retab
12:09:04 <Sgeo> :help retab
12:09:28 <jlouis> \o/
12:09:40 <jlouis> Sgeo: We are not both in Eq, are we?
12:10:09 <ddarius> Sgeo: And what about: getLine == <definition of getLine> ?
12:10:49 <Sgeo> Wait, does this have anything to do with halting problem issues? Same as determining if a function is equivalent to another function?
12:11:06 <Cale> Sgeo: similar, yes
12:11:26 <Jafet> How do you define equality for IO
12:11:29 <Cale> Sgeo: You could never really check if two IO actions, if executed, would do the same thing or not
12:12:13 <Cale> (which is the only sane way to define equality)
12:12:14 <Jafet> Might not even be meaningful. getTime
12:12:27 <Jafet> @hoogle time
12:12:27 <lambdabot> package time
12:12:28 <lambdabot> module Data.Time
12:12:28 <lambdabot> module System.Time
12:12:30 <Sgeo> Jafet, that's not the issue. getTime always gets the time
12:12:33 <Cale> Well, getTime always "does the same thing" in this sense
12:12:41 <Jafet> It gets a different time
12:12:44 <ksf> Cale, the only sane equality is observational equality
12:12:45 <Cale> right
12:12:48 <Jafet> So, again how do you define quality
12:12:56 <Jafet> s/q/eq/
12:12:58 <Cale> bisimulation
12:13:09 <Jafet> Ok
12:13:44 <Cale> Though I'll admit there are some hazy areas...
12:13:47 <Sgeo> I can still wish it was the case, can't I? Same as I can wish that there exists a notBottom :: a -> Bool
12:13:53 <Sgeo> Even though it can't happen
12:13:58 <Cale> Like, where the time it takes to evaluate something can affect the result.
12:14:22 <Cale> So maybe to do it right, you need to involve nondeterminism.
12:14:35 <Cale> Sgeo: sure :)
12:17:36 * Cale considers what would be the fastest way to conquer the entire world given a working implementation of isBottom.
12:17:36 <wavewave> Why STUArray is slow?
12:17:44 <Cale> Is it slow?
12:17:48 * jlouis hands Cale an Oracle for isBottom
12:17:57 <Jafet> Start an army of bums
12:18:02 <wavewave> Isn't it slow?
12:18:12 <jlouis> wavewave: why should it be?
12:18:15 <Cale> wavewave: I never noticed.
12:18:16 <wavewave> If slow, what is the cause?
12:18:29 <wavewave> Yes, in fact that is my question. :)
12:18:30 <jlouis> wavewave: profile!
12:18:33 <dmhouse> wavewave, why is the sky orange?
12:18:50 <jlouis> wavewave: measure! statistics, bitches, it works!
12:19:04 <wavewave> jlouis: I am just asking, not with a particular thing. :)
12:19:16 <wavewave> So STUArray is not slow at all?
12:19:17 <Twey> I'm pretty sure it's not slow.
12:19:26 <Twey> For most definitions of ‘slow’.
12:19:29 <ddarius> wavewave: You question is like dmhouse's:  "Explain why the sky is orange."
12:19:49 <nominolo> wavewave: why would you think it is?
12:19:50 <ksf> dust in the atmosphere
12:19:52 <Cale> wavewave: Do you have a program which uses STUArray and seems to be slow?
12:19:53 <wavewave> Okay.. how about comparing with C?
12:19:57 <ksf> pollution makes wonderful sunsets
12:20:05 <Twey> It's just an array
12:20:06 <Cale> wavewave: Show us the code which is running slowly.
12:20:07 <jlouis> ksf: neon green?
12:20:27 <Twey> It'll be about the same speed as an array in any language
12:20:34 <wavewave> Cale: No, no... in fact I am just considering to use it...
12:20:38 <jlouis> wavewave: it should run at about the same speed as C?
12:20:41 <ksf> aurora borealis
12:20:46 <dmhouse> wavewave: okay, then it's not slow :)
12:20:55 <nominolo> wavewave: STArray had some problems (note: no "U" in the name)
12:20:55 <wavewave> jlouis: yes..
12:21:00 <dmhouse> (Also, the sky isn't orange in case you were worrying.)
12:21:00 <Twey> There might be a couple more pointer lookups in there, but nothing particularly worth mentioning
12:21:09 <Cale> wavewave: There are senses in which STUArray is "slow", but they are obvious.
12:21:12 <Twey> dmhouse: Speak for yourself — it's sunset here
12:21:14 <Vanadium> C could have unboxed arrays of any type :3
12:21:20 <ksf> don't forget unsafeIndex
12:21:33 <dmhouse> Vanadium: not of infinite lists!
12:21:35 <hape__> Hi, I try to install the Haskell Platform on Ubuntu, but somehow this does not work: when doing make I get:   unrecognized option `--with-cabal-install=../cabal-install-0.6.2/dist/build/cabal/cabal'
12:21:37 <wavewave> Cale: for example?
12:21:41 <jlouis> I would expect STUarray to be as fast or close to as fast as C
12:21:44 <Cale> wavewave: For example, if you want to make a modified version of an STUArray without destroying the one which already exists, it is slow, because you have to make a copy.
12:21:48 <dmhouse> (Unless they were all bottom, mumble mumble.)
12:22:06 <Vanadium> You can have STUArrays of lists?
12:22:08 <wavewave> Cale: that's too obvious.
12:22:08 <goomba> if the sky is not your desired color, just stare into the sun until the sky's tint is acceptable
12:22:12 <jlouis> combinatorrent uses IOUArrays out of convenience, and they are fast when I don't make passes all over them
12:22:21 <nominolo> Cale: isn't STUArray mutable?
12:22:26 <Cale> nominolo: yes
12:22:32 <nominolo> so, no copying
12:22:40 <Cale> Read what I said again
12:22:58 <Cale> "without destroying the one which already exists"
12:23:00 <jlouis> nominolo: freezing copies for example. That is what Cale hints at
12:23:13 <Cale> Mutable update is destructive
12:23:19 <nominolo> sure
12:23:27 <wavewave> What's the difference between vector library and STUArray then?
12:23:30 <hape__> somebody here using Haskell Platform on Ubuntu?
12:23:40 <wavewave> again curious.
12:23:44 <nominolo> wavewave: vector is more recent
12:24:04 <fax> > map ((`mod`7).(6^) [1..]
12:24:05 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
12:24:07 <fax> > map ((`mod`7).(6^)) [1..]
12:24:08 <nominolo> wavewave: it tries to be faster by using stream fusion
12:24:08 <lambdabot>   [6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,...
12:24:19 <Cale> wavewave: More aggressive fusion of operations, not mutable by default.
12:24:35 <fax> I'm lost on this stuff with exponents
12:24:41 <Ferdirand> 6 == -1 mod 7
12:24:49 <wavewave> I see.. it eliminate indirection when map f . map g..
12:25:00 <fax> how do you find one == 1 mod 7?
12:25:07 <nominolo> wavewave: mainly eliminate copying
12:25:09 <Cale> wavewave: For example, yes.
12:25:17 <dmhouse> fax: what do you mean?
12:25:21 <fax> > map ((`mod`7).(4^)) [1..]
12:25:22 <lambdabot>   [4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,...
12:25:54 <fax> http://www.pasteit4me.com/302002
12:26:02 <fax> this solves it by brute force
12:26:14 <jlouis> fax: isn't that the discrete logarithm?
12:26:18 <wavewave> is anyone interested in making a numerical optimization library in haskell?
12:26:19 <fax> I'm trying to get a more efficent algorithm from a proof
12:26:23 <fax> jlouis, I don't know
12:26:38 <wavewave> pure haskell, I mean :) (not FFI)
12:27:00 <dmhouse> fax: anything which is coprime to p will do
12:27:06 <fax> isn't everything coprime to p?
12:27:09 <fax> (p is prime)
12:27:15 <fax> hmmmm
12:27:21 <wavewave> numerical optimization means numerical minimization...
12:27:22 <Jafet> p isn't...
12:27:33 <dmhouse> Oops, multiplicative group.
12:28:16 <dmhouse> fax: what's the algorithm you're trying to implement?
12:28:27 <fax> I don't have an algorithm
12:28:32 <nominolo> wavewave: sounds difficult.  at least if you care about rounding error minimisation
12:28:35 <fax> I've been trying to pull one out of this proof I have here
12:28:37 <fax> but it's not working
12:28:58 <dmhouse> fax: well, what's the proof? What's the theorem, for that matter?
12:29:06 <SamB_XP> fax: just steal the newton's method fractal from a fractal program ;-P
12:29:24 <fax> well it takes up a full chapter
12:29:32 <fax> but like, here is an example:
12:30:16 <fax> > ((`mod`17).(3^)) . [0..16]
12:30:17 <lambdabot>   [1,3,9,10,13,5,15,11,16,14,8,7,4,12,2,6,1]
12:30:18 <wavewave> nominolo: that's about algorithm. at least there are no additional difficulty in haskell, I guess.
12:30:28 <fax> um I must have made a mistake there
12:30:44 <wavewave> nominolo: usually, numerical algorithm has a lot of destructive mutation..
12:31:02 <fax> 1 shouldn't be there twice
12:31:09 <Jafet> That's because numerical algorithms are usually described by people who use imperative languages
12:31:21 <nominolo> wavewave: well, if you use STUArray then you could simply use such an algorithm
12:31:27 <wavewave> but STUArray has the same performance... then
12:31:43 <nominolo> well, module cost of abstraction
12:31:44 <wavewave> yeah. that's what I am thinking of.
12:31:48 <fax> :(
12:31:58 <dmhouse> fax: why not? x^(p-1) = 1, that's Fermat's little theorem
12:31:59 <nominolo> and code generator quality
12:32:14 <fax> ooh
12:32:17 <nominolo> modulo*
12:32:36 <wavewave> ST monad abstraction is good since it separates mutable part from immutable part.
12:32:38 <fax> > map (\x -> x^(p-1)`mod`17) [2..16]
12:32:46 <lambdabot>   mueval-core: Time limit exceeded
12:32:51 <fax> > map (\x -> x^(p-1)`mod`17) [2..5]
12:32:55 <lambdabot>   mueval-core: Time limit exceeded
12:32:59 <fax> :|
12:33:01 <mibygl_> Are you sure that's Fermat's little theorem?  I thought it was Euler's theorem.
12:33:09 <dmhouse> mibygl_: the latter's a generalisation
12:33:11 <wavewave> numerical algorithm usually has very well-defined mutable operations.
12:33:17 <fax> > (\x -> x^(p-1)`mod`17) 2
12:33:20 <Jafet> It gets worse when they start describing it in matlab and everything is a matrix and I can't gouge their eyes out with a spoon
12:33:23 <lambdabot>   mueval: ExitFailure 1
12:33:25 <mibygl_> Funny how there is one theorem that gets the name "Euler's theorem" isn't it.
12:33:25 <fax> lambda bot is broken
12:33:29 <dmhouse> > 1 + 1
12:33:29 <nominolo> wavewave: yes, but you'll probably need various unsafe* access functions, because I'm not sure how well the bounds-checking of the safe operations can get optimised away
12:33:30 <lambdabot>   2
12:33:36 <dmhouse> > 2 ^ 10
12:33:37 <lambdabot>   1024
12:33:40 <fax> > (\x -> x^((p-1)`mod`17)`mod`17) 3
12:33:41 <lambdabot>   * Exception: Negative exponent
12:33:57 <fax> you got to be kidding
12:34:08 <fax> > map (\x -> x^(17-1)`mod`17) [2..5]
12:34:10 <lambdabot>   [1,1,1,1]
12:34:13 <Mowah> > (\x -> x^^((p-1)`mod`17)`mod`17) 3
12:34:13 <fax> > map (\x -> x^(17-1)`mod`17) [2..16]
12:34:14 <lambdabot>   <no location info>: lexical error at character '\SI'
12:34:14 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
12:34:18 <fax> why are they all 1?
12:34:19 <wavewave> nominolo: I really don't want to have 'unsafe' things... that's not haskell. :)
12:34:30 <nominolo> wavewave: but I don't know what you win by writing it in Haskell, instead of FFI?
12:34:35 <dmhouse> fax: Fermat's little theorem, like I said
12:34:47 <fax> dmhouse does that help to find the generator/
12:34:47 <fax> ?
12:34:59 <dmhouse> fax: not as far as I'm aware
12:35:02 <fax> oh okay
12:35:03 <wavewave> nominolo: later on, parallelism can march in...
12:35:08 <dmhouse> fax: what's the name of the theorem you're trying to use?
12:35:09 <nominolo> no
12:35:13 <mibygl_> > -1 `mod` 17
12:35:14 <lambdabot>   -1
12:35:17 <nominolo> wavewave: not if you use STUArray
12:35:18 <mibygl_> > -1 `rem` 17
12:35:19 <lambdabot>   -1
12:35:23 <mibygl_> ...huh?
12:35:34 <dmhouse> > 6 `mod` (-4)
12:35:35 <lambdabot>   -2
12:35:36 <fax> dmhouse it doesn't have a name but the idea is that every multiplicative group Z/pZ has a(t least one) generator
12:35:38 <dmhouse> > 6 `rem` (-4)
12:35:39 <lambdabot>   2
12:35:54 <dmhouse> fax: okay, how does that help?
12:36:04 <nominolo> wavewave: You're essentially working in Haskell's C-like subset, so you have most of its drawbacks.  In general, paralellism as an afterthought hardly ever works out.
12:36:04 <fax> dmhouse well my program finds that
12:36:12 <nominolo> Raytraycers are the exception
12:36:13 <wavewave> nominolo: not all part of numerical algorithm is mutable..
12:36:19 <fax> but what I did was generate the orbits of every element and pick one that covers the whole set
12:36:23 <dmhouse> fax: the way I'd do it is the way you're currently doing it: compute the order of each element and find one which is p-1
12:36:26 <fax> but I think there should be  better way
12:36:36 <Jafet> Every such group has phi(phi(p)) such generators. The problem is finding which.
12:36:46 <fax> wow phi(phi(p))
12:36:47 <jlouis> any embarrassingly parallell problem can get paralellism bolted on as an afterthought in most cases
12:36:50 <wavewave> nominolo: and data parallelism is ubiquotuous in numerical things.
12:36:50 <fax> so that's phi(p-1)
12:37:03 <Jafet> This is the basis for the Miller test
12:37:16 <fax> so if p-1 = q_1^a_1*q_2^a_2*.. then there's a_1+a_2+... generators?
12:37:20 <Jafet> For primality, not for porn
12:37:21 <nominolo> jlouis: but most optimisation stuff is not emberassingly parallel
12:37:26 <fax> sorry that should be times not add
12:37:37 <Jafet> fax, pick up any modern elementary number theory textbook
12:37:41 <fax> okay what is Miller test :)
12:37:50 <fax> Miller–Rabin primality test
12:37:51 <fax> aha
12:37:58 <jlouis> nominolo: true!
12:38:15 <nominolo> wavewave: well, if you implement it with data-parallel Haskell in mind, it might work out with automatic paralellism
12:38:16 <wavewave> nominolo: of course, one of main motivation is also "purism.?.. "
12:38:44 <nominolo> wavewave: but I have no idea how well the existing algorithm map onto DPH
12:38:45 <Jafet> The Miller-Rabin test is QP, Miller is P if some variant of the Riemann conjecture is true
12:39:23 <Jafet> There are also more efficient ways of finding generators. Maybe some crypto textbook will also present it, since you need it for DH and stuff
12:39:30 <wavewave> nominolo: many algorithm can have also divide and conquer type computation.
12:40:25 <wavewave> nominolo: also many algorithms are stochastic.
12:40:44 <wavewave> nominolo: like simulated annealing.
12:41:52 <wavewave> nominolo: neural network is also adequate with data parallelism.
12:42:00 <dmhouse> > let p = 17; order p x = head [ n | n <- [1..p-1], x^n `mod` p == 1 ] in find ((== p-1) . order p) [2..p-1]
12:42:04 <lambdabot>   mueval-core: Time limit exceeded
12:42:10 <dmhouse> Bah
12:42:43 <dmhouse> Write a memoising exponentiation table to speed that up
12:42:49 <wavewave> nominolo: anyway, just prepare for some next generation computing is not a bad idea. :)
12:42:57 <Jafet> Or just let it be, let it be
12:43:27 <dmhouse> I suppose you only need check up to (p-1)/2
12:43:42 <dmhouse> Err, that's actually not true, never mind
12:44:09 <mibygl_> Jafet: is it a stronger variant of the Riemann conjecture, a weaker one, or neither?
12:44:32 <Jafet> I don't really know or care
12:44:53 <wavewave> anyway, for my concern, I need an optimization code..
12:44:56 <mibygl_> Remember the Law of Riemann's Hypothesis: all claims stronger than the Riemann hypothesis are false, and all claims weaker than the Riemann hypothesis are false.
12:45:07 <nominolo> wavewave: yeah, if you get something like PBLAS, or ScaLAPACK to run on DPH that would be nice
12:45:07 <mibygl_> s/false./true./
12:45:23 <Jafet> There's a theorem that at least two of the three numbers 2, 3, 5 are generators for infinitely many finite fields, but no one has any idea which. Who comes up with this shit
12:45:37 <dmhouse> Hah, nice
12:45:38 <fax> :t find
12:45:41 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
12:45:48 <wavewave> yes..
12:46:11 <ksf> Jafet, discordians.
12:46:12 <dmhouse> My favourite is a theorem (can't remember which) which has been proving assuming RH, and also proven using ¬RH. So it's definitely true, but no-one can manage to untangle the proofs :)
12:46:15 <wavewave> I just wondered if haskell is now ready for such computations.
12:46:17 <ksf> in fact, 2+3 = 5
12:46:47 <fax> > let integerOfExponent p q = fromJust $ find (\x -> x^((p-1)/q)`mod`p /= 1) [1..p-1] in integerOfExponent 7 3
12:46:48 <lambdabot>   Ambiguous type variable `t' in the constraints:
12:46:48 <lambdabot>    `GHC.Real.Fractional t'
12:46:48 <lambdabot> ...
12:46:55 <fax> > let integerOfExponent p q = fromJust $ find (\x -> x^((p-1)`div`q)`mod`p /= 1) [1..p-1] in integerOfExponent 7 3
12:46:56 <lambdabot>   2
12:47:15 <fax> > 2^(6/3)`mod`7
12:47:16 <lambdabot>   Ambiguous type variable `t' in the constraints:
12:47:16 <lambdabot>    `GHC.Real.Fractional t'
12:47:16 <lambdabot> ...
12:47:18 <fax> :((((
12:47:22 <fax> why doesn't / just do the right thing
12:47:38 <chrisdone> two types right?
12:47:39 <dmhouse> Because / to mean integer division is evil
12:47:39 <chrisdone> :t (/)
12:47:40 <lambdabot> forall a. (Fractional a) => a -> a -> a
12:47:45 <chrisdone> ohno
12:47:49 <Younder> fax: what's the 'right' thing
12:47:51 <Zao> @type (div, quot)
12:47:52 <fax> bt p-1 goes into q
12:47:52 <lambdabot> forall a a1. (Integral a, Integral a1) => (a -> a -> a, a1 -> a1 -> a1)
12:47:56 <fax> or q goes into p-1
12:47:58 <dmhouse> Classic newbie mistake when writing C programs to put 1/2 intending to get 0.5
12:47:58 <fax> I can not remember which
12:48:06 <Eelis> hm, shouldn't   System.FilePath.normalise "foo/../bar"   be   "bar"   instead of   "foo/../bar"   ?
12:48:16 <wavewave> another category that haskell may prosper is symbolic computation.
12:48:32 <Zao> div,mod and quot,rem are the integral functions for division and remaininder.
12:48:40 <Younder> 1 % 2 from Data.Rational will do what you expect
12:48:41 <Zao> With slightly different semantics wrt. truncation.
12:48:44 <wavewave> replace mathematica.
12:48:55 <fax> wavewave - I like that idea
12:49:07 <ksf> there's already a foss mathematica
12:49:11 <ksf> forgot the name, though
12:49:39 <arw_> there are several iirc.
12:49:44 <arw_> maxima for example
12:49:54 <Younder> ksf: there is also a personal edition for 300$ which is fairy  reasonalble.
12:49:57 <wavewave> yes, it's written in lisp.
12:50:02 <arw_> aem. macsyma...
12:50:09 <Younder> or axiom
12:50:18 <wavewave> I like DoCon.
12:50:28 <ksf> Younder, depends on what you want to do.
12:50:35 <wavewave> I think that is pretty complete package in algebra.
12:50:36 <Jafet> I like the mathematica syntax... a little bit
12:50:43 <ksf> I never did more than expanding stuff and collecting powers
12:50:56 <Eelis> > System.FilePath.normalise "foo/bar"
12:50:56 <Younder> axiom is the only system buildt on topology so you can build new math and inherit properties
12:50:57 <lambdabot>   Not in scope: `System.FilePath.normalise'
12:51:02 <wavewave> Mathematica syntax is lisp with lazy evaluation in some sense.
12:51:04 <arw_> i like maple better. but thats mostly a matter of taste.
12:51:14 <wavewave> pattern matching is a little bit more complicated though
12:51:35 <Younder> fenomonally powerfull, so it is strang that this hasn't caught on more
12:51:40 <Jafet> Also I like the highlighting
12:52:16 <wavewave> For algebra part, I think haskell already has a pretty good packages.
12:52:26 <dmhouse> Eelis: apparently not; from the docs 'Posix:   normalise "/test/file/../bob/fred/" == "/test/file/../bob/fred/"'
12:52:31 <wavewave> also combinatorics.
12:52:57 <wavewave> I think some effort is needed for gathering those and making some good convention or whatever.
12:53:04 <Eelis> dmhouse: but isn't that weird?
12:53:11 <dmhouse> Eelis: yep.
12:53:13 <mibygl_> /test/file/../bob/fred/ is not necessarily /test/bob/fred/.
12:53:26 <dmhouse> mibygl_: symlinks?
12:53:34 <wavewave> Once language part is well developed, then presentation part can be followed quite well.
12:53:37 <mibygl_> /test/file could be a symbolic link to /foo/bar, in which case /test/file/../bob/fred is /foo/bob/fred.
12:53:42 <Eelis> ugh
12:54:06 <arw_> and there could be broken . and .. hardlinks. but only very few filesystems allow that to happen.
12:54:06 <wavewave> Mathematica-like pattern matching is something missing yet.
12:54:31 <fax> I'm not sure if factorizing p-1, finding the integerOfExponent of each one then taking the product is actually better....
12:54:39 <fax> because I mean factorizing is pretty serious
12:54:41 <Eelis> mibygl_: ok, thanks
12:54:42 <wavewave> I also think in that region, strong type will help much!
12:54:48 <dmhouse> fax: write both and profile
12:54:57 <ksf> broken . and .. is quite easy
12:55:08 <mibygl_> Perhaps we could use some normalisation function that actually looks at the filesystem to see what it is.
12:55:08 <wavewave> mathematica is untyped language.
12:55:17 <ksf> in fact, it happend to me with both ext3 and reiserfs
12:55:23 <fax> and what I don't get is why xy /= 1
12:55:57 <arw_> oh, and mounts and deleted directories are another cause of .. beeing "something else".
12:56:12 <Eelis> mibygl_: that would be good, because right now the name "normalise" is a bit misleading, as it doesn't compute any normal form :)
12:56:21 <ksf> you can also unlink .. and have it point somewhere else
12:56:40 <Jafet> It would have to be IO String or something
12:56:42 <Jafet> ksf, nice
12:57:01 <dmhouse> ksf: wow, really?
12:57:12 <ksf> ...well, I never did it
12:57:16 <ksf> but it should be possible
12:58:04 <wavewave> symbolic calculation is where EDSL approach really works well.
12:58:22 <arw_> its quite easy. get 2 shells, make /tmp/foo and go there in the first shell. rmdir /tmp/foo; mkdir /tmp/foo; touch /tmp/foo/something in the second shell.
12:58:27 <arw_> then type ls in the first.
12:58:37 <arw_> then type ls ../foo in the first.
12:59:29 <wavewave> Axiom has a very good typed DSL for symbolic computataion.
12:59:30 <arw_> same effect if you do mount something /tmp/foo instead of rmdir
12:59:32 <mibygl_> Huh, so it's like your current directory is a file descriptor of something that no longer has a place in the filesystem.
12:59:38 <dmhouse> arw_: cuh-razy
12:59:53 <ksf> if in doubt, you can always do it with fuse.
13:00:12 <dmhouse> And of course, doing "cd ../foo; ls" shows up "something"
13:00:20 <arw_> mibygl_: exactly. the inode still has a reference since its cwd of a process. so it wont be deleted until the first shell exits or changes cwd.
13:00:40 <arw_> (cwd == current working directory)
13:00:47 <dmhouse> So what does unlink do at the inode level?
13:00:59 <ksf> decrease the reference count
13:01:06 <arw_> decrease the (static) reference count
13:01:22 <dmhouse> And an inode is deleted when its reference count is 0?
13:01:22 <arw_> there is also a dynamic one which counts open file or directory handles.
13:01:22 <ksf> usually files have exactly one hardlink to exactly one inode
13:01:29 <arw_> dmhouse: yes.
13:01:37 <dmhouse> And opening a file descriptor increases the reference count?
13:01:41 <ksf> directories have number of subdirs + 2 hardlinks
13:01:47 <arw_> dmhouse: the dynamic one, yes.
13:01:57 <arw_> dmhouse: making a hardlink increases the static refcount
13:02:07 <mibygl_> So would it be possible to make two directories whose parent directories are each other?
13:02:09 <ksf> those being /foo, /foo/. and /foo/<bar>/..
13:02:10 <dmhouse> Hm, okay
13:02:32 <arw_> mibygl_: in some filesystems. most modern filesystems only "simulate" . and ..
13:02:51 <arw_> mibygl_: and most don't allow directory hardlinks, since they tend to break things badly
13:03:02 <ksf> unless with a mount option
13:03:20 <ksf> which might make sense because you want to hardlink a directory into your httproot or something
13:03:26 <mibygl_> Now I want to make an evil artificial filesystem that allows such things.
13:03:37 <ksf> @hackage fuse
13:03:37 <lambdabot> http://hackage.haskell.org/package/fuse
13:03:50 <Eelis> i'm experimenting to see whether a particular shell script can be more elegantly expressed as a Haskell program. is there something like "which" in the Haskell standard libraries (or perhaps in a Hackage package)?
13:03:58 <mibygl_> No such package, ksf.
13:04:09 <ksf> well then it's named FUSE or something
13:04:13 <dmhouse> Eelis: you could use a system call, probably the best thing to do
13:04:21 <ksf> but we do have fuse bindings
13:04:38 <mibygl_> Is there really a system call that looks in your $PATH for you?
13:04:39 <arw_> there is no syscall for which
13:04:45 <Jafet> There are supposedly shells in haskell
13:05:07 <Eelis> dmhouse: by "system call", do you mean an actual call to a kernel API function, or a call to Haskell's "system" function?
13:05:29 <Zao> HSH might offer something useful.
13:05:29 <dmhouse> Eelis: the latter
13:05:38 <Zao> I found it quite handy when doing shell-ish things in general.
13:05:54 <Eelis> dmhouse: so you mean i'd just invoke the "which" program through "system"?
13:06:01 <dmhouse> Eelis: yes, exactly
13:06:05 <dmhouse> Sorry for the ambiguity.
13:06:12 <mibygl_> Invokine which through system seems like sort of an inelegant thing to do.
13:06:17 <ksf> you can also getEnv PATH and search for files, there.
13:06:24 <mibygl_> s/e/g/
13:06:25 <Eelis> dmhouse: i see. that would work. it just seemed like such a simple thing that i half expected there to be an existing funciton for it somewhere :)
13:06:32 <mibygl_> But perhaps it's for the best.
13:06:34 <Jafet> Especially since which is usually a shell command.
13:06:47 <Zao> Jafet: There's always /usr/bin/which
13:06:50 <Zao> Often.
13:07:01 <Zao> Of course, you'll fail horribly on awesome platforms like Windows.
13:07:03 <Jafet> locate!
13:07:13 <mibygl_> I've found system calls which are pretty much totally unsupported by Haskell.
13:07:15 <Jafet> Windows doesn't have a shell
13:07:15 <Jafet> So that's moot
13:07:22 <Zao> Jafet: cmd.exe > you
13:07:24 <dmhouse> You could always walk PATH, I guess
13:07:34 <dmhouse> There might be a library for that
13:07:35 <Eelis> dmhouse: someone should write that code and put it in a hackage package :)
13:07:37 <Zao> Heck, .bat files have the ability to find things in %PATH% :)
13:07:40 * dmhouse does know of one
13:07:53 <Eelis> i'll look at HSH i guess
13:08:01 <dmhouse> (which is hard to google for.)
13:08:01 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3893
13:08:07 <arw_> the shells 'which' is somewhat different from /usr/bin/which. the shell usually knows about builtin functions, user-defined functions and aliases.
13:08:07 <ksf> in case you want to glob directories
13:08:21 <ksf> er no that's not the right one
13:08:25 <arw_> but walking $PATH is fine for all cases, except if you build a shell.
13:08:59 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24663#a24663
13:09:08 * mibygl_ types "which if" and gets a blank result.
13:09:16 <ksf> ...I never got around finishing that
13:09:28 <jlouis> ksf: by the way, are you working on and off on the splice calls?
13:09:31 <Eelis> hm, no "which" in HSH as far as i can see
13:09:39 <Jafet> Well, `if` is not a program, function or alias
13:09:40 <ksf> yes and no
13:09:50 <jlouis> ok
13:09:51 <mibygl_> Isn't it a builtin thing?
13:09:53 <Eelis> dmhouse: what library were you thinking of?
13:10:02 <arw_> 2209[snalwuer@faui0sr0:~]# which if
13:10:02 <arw_> if: shell reserved word
13:10:06 <arw_> depends on the shell.
13:10:11 * mibygl_ nods.
13:10:22 <mibygl_> Maybe I shoudl stop using this lousy bash.
13:10:23 <dmhouse> Eelis: I wasn't
13:10:49 <Eelis> dmhouse: ok, then i don't know what you meant with "* dmhouse does know of one"
13:10:49 <Jafet> bash is worse than lousy; it's standard
13:11:02 <dmhouse> Eelis: I missed an "n't"
13:11:02 <ksf> jlouis, but I'm trying hard to hack and not to bikeshed
13:11:10 <Eelis> dmhouse: ah
13:11:18 <mibygl_> So if you open a file in FUSE, does it hand you a file descriptor to a real file, or one to a virtual file that behaves however FUSE wants it to behave?
13:11:41 <Jafet> What's a real file and how is that different to a virtual file
13:12:03 <ksf> mibygl_, is /proc/cpuinfo a real file?
13:12:13 <mibygl_> I guess my question doesn't really mean much.
13:12:14 <ksf> what about /dev/ ?
13:12:15 <Jafet> fuse is a user space programmable filesystem driver, it works like any other driver
13:12:17 <arw_> mibygl_: every kind of file is somehow virtual. the kernel has some syscalls to handle files which are implemented by different FS drivers. FUSE is just one of them.
13:12:48 <Zao> http://dmst.aueb.gr/dds/pubs/inbook/beautiful_code/html/Spi07g.html
13:12:49 <jlouis> ksf: I like the idea however
13:12:59 <mibygl_> So I could make a FUSE file called nh such that if someone runs cat <nh >nh, it runs NetHack.
13:13:04 <ksf> me too.
13:13:06 <Zao> This is an excellent overview of how filesystem drivers can be realized.
13:13:15 <arw_> mibygl_: the kernel just knows that some inode belongs to a certain type of FS and redirects read/write/open/... somewhere.
13:13:16 <Zao> From the same book that has SPJ's awesome STM article.
13:13:16 <dmhouse> Anyone know of a neater way to write the following? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24664#a24664
13:13:30 <arw_> mibygl_: in a way, yes.
13:13:37 <ksf> fact is though, if I attempt to do it The Right Way on the first run, I'm going to depend on HList and worse and it's going to take a month.
13:13:41 <jlouis> ksf: The code could just send around small structures telling where and when to splice. Then almost none of the code would have to change
13:13:46 <dmhouse> Like an iterateUntil
13:14:10 <mibygl_> More importantly, if I run an executable that's on a FUSE filesystem, does that read an executable and run that, or just tell the filesystem driver to run the thing?
13:14:16 <mibygl_> I guess the latter sounds a bit far-fetched.
13:14:18 <dmhouse> Maybe a combination of dropWhile and iterate...
13:14:22 <ksf> jlouis, the first problem is that with the current get-based parser, the data already is in userspace before we know that it's a piece
13:14:30 <arw_> mibygl_: nethack is not a good example since it needs a terminal, but for example with things like netcat this has been done and is very useful.
13:15:09 <mibygl_> Doesn't NetHack interact with the terminal purely by writing to stdout and reading from stdin?
13:15:17 <mibygl_> (And maybe sometimes writing to stderr.)
13:15:20 <arw_> mibygl_: running a file is mmaping it and handing it over to the kernels executable handler.
13:15:28 <jlouis> ksf: yes, we need a delimited continuation at least
13:15:33 <arw_> mibygl_: so generally its the same as reading it.
13:15:46 <ksf> on the where to splice front, though, I've more or less decided to do it in the reciever thread, which asks FS for the proper fds and offsets before doing it and then unblocks the rest of piecemgr to do stuff
13:16:10 <Jafet> mibygl, I can create device files in /dev that do impressive things like write to the screen or send audio signals
13:16:43 <ksf> jlouis, it's quite straight forward to extend iteratees to be able to send "if you can, give me a new buffer n bytes from now"
13:16:46 <mibygl_> Like /dev/stdout and /dev/dsp?  :)
13:16:46 <arw_> mibygl_: so your fs wouldn't really know that the file was executed, it would only see the mmap. but the kernel handles the rest of the execution according to the executable type.
13:17:28 <jlouis> ksf: awesome! One thing I have thought of is to replace all the receiver threads with one big libevent loop
13:17:41 <ksf> as the iteratee knows where the next message begins, with a bit of squinting and correcting one or two off-by one errors it's easy to hit the boundary
13:17:44 <ksf> that, too.
13:17:46 <jlouis> running iteratees
13:17:48 <mibygl_> So it wouldn't be very easy to make a file that, when executed, actually performs some arbitrary action instead of executing something.
13:18:06 <mibygl_> I mean, you could simply have it be an executable that performs the action.
13:18:12 <ksf> event + fionread is awesome.
13:18:12 <mibygl_> But where's the fun in that?  :P
13:18:16 <Jafet> mibygl, fuse is irrelevant to that
13:18:31 <Jafet> fuse just lets you play that trick from userspace
13:18:45 <jlouis> ksf: mmm, tell me if you get any further with the idea. I plan on getting the FAST extension to work
13:19:12 <jlouis> because the old protocol has a bug which is irritating
13:19:48 <dmhouse> fax: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24665#a24665 if you're interested
13:23:04 <mibygl_> Agda looks like it's not a nice module for people who want to simply include a proof system in their application.
13:23:34 <ddarius> mibygl_: It's an implementation of a language.
13:24:34 <ksf> jlouis, will do
13:24:37 <chrisdone> chr1s: you about?
13:25:47 <mibygl_> And that's why.  :)
13:28:28 <fax> dmhouse - oh that's a really good wy to do it, thanks
13:30:03 <dmhouse> fax: that's O(p^2); not sure if there's a faster way
13:32:29 <pozic> How is one supposed to install GHC-6.12 on Ubuntu? From what I can see it is a huge failure. If  you follow all the steps, you end up with a non-working system.
13:32:52 <Jafet> pozic, download the tarball and run the install script
13:32:57 <pozic> See: http://davidsiegel.org/haskell-platform-in-karmic-koala/
13:33:09 <pozic> If people publish garbage, just delete the links.
13:33:23 <pozic> (this is linked from the Haskell platform page)
13:33:44 <pozic> Jafet: yes.
13:33:59 <Jafet> Worksforme
13:39:34 <Eelis> so then, here's my fabulous "which" function: http://codepad.org/wRM0wDf1 -- did i overlook anything obvious?
13:40:05 <Mathnerd314> yes
13:40:12 <Mathnerd314> everything is obvious :-)
13:40:24 <Eelis> i'm not sure what you mean
13:41:47 <chrisdone> anyone using the salvia web framework? looks proper squiffy
13:41:52 <dmhouse> Do we still not have a tokenising function String -> Char -> [String]? (Or perhaps String -> String -> [String])
13:41:58 <Eelis> i was a bit surprised there's no findM in Control.Monad
13:42:12 <Eelis> ?hoogle findM
13:42:14 <lambdabot> Data.IntMap findMax :: IntMap a -> a
13:42:14 <lambdabot> Data.IntSet findMax :: IntSet -> Int
13:42:14 <lambdabot> Data.Map findMax :: Map k a -> (k, a)
13:42:21 <Eelis> hoogle being useful as always
13:42:36 <Tarrasch> lol
13:42:44 <Jafet> dmhouse, seems of doubtful utility
13:42:49 <chrisdone> :t find
13:42:50 <dmhouse> ?hoogle listToMaybe
13:42:50 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
13:42:50 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
13:42:53 <Jafet> *cough strtok*
13:43:01 <dmhouse> Jafet: it's incredibly useful in string manipulation
13:43:08 <jlouis> Eelis: what is the type of findM? A monad-lifted find?
13:43:26 <dmhouse> Jafet: findM is fmap listToMaybe . filterM p
13:43:29 <Eelis> jlouis: yes, similar to mapM, foldM, filterM
13:43:33 <Twey> :t find
13:43:34 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
13:43:44 <Jafet> Thanks, I'll tell Eelis
13:43:47 <dmhouse> jlouis: Monad m => (a -> m Bool) -> [a] -> m (Maybe a)
13:43:57 <Eelis> dmhouse: won't that filterM perform the computation on all elements?
13:43:58 <Twey> So, (a -> m Bool… yeah, that one :þ
13:44:06 <Jafet> And, er jlouis
13:44:23 <poincare101> woah! There's a LOT of people here! (Wait, Jafet, are you on #c++).
13:44:28 <dmhouse> Jafet: was that directed at me? If so, I was replying to your comment that strtok isn't useful
13:44:43 <chrisdone> poincare101: 7th biggest channel on freenode!
13:44:45 <poincare101> I expected a lot less for what I considered a not-so-popular language
13:44:46 <dmhouse> Eelis: maaaaybe.
13:44:49 <Jafet> Then you told me a definition of findM...
13:45:02 <Eelis> dmhouse: i fear it would. the world isn't quite so lazy in IO :)
13:45:05 <Jafet> We're indies.
13:45:11 <Twey> Depends on m
13:45:38 <Eelis> Twey: in my case m is IO, and the predicate is doesFileExist.
13:46:00 <mibygl_> It looks like ivor is the module I want.
13:46:11 <Twey> Eelis: Then yes, of course it will
13:46:12 <dmhouse> Eelis: turns out it does
13:46:16 <mibygl_> "Theorem proving library based on dependent type theory"
13:46:20 <Eelis> ok, as i expected
13:46:32 <dmhouse> "fmap listToMaybe $ filterM (\x -> print x >> return (x<5)) [1..10]" proves it
13:46:33 <Eelis> so that findM-in-terms-of-filterM is no good
13:46:34 <chrisdone> findM would need to be implemented manually, I think?
13:46:44 <Twey> Yeah
13:46:47 <Eelis> chrisdone: that's what i did, and people suggested that it wouldn't need to be
13:46:49 <dmhouse> chrisdone: yes; Eelis did so and I thought it could be done in terms of filterM, but was wrong
13:46:53 <Twey> I imagine so
13:47:04 <Twey> I have often wanted one of these for myself
13:47:07 <Eelis> all the more reason for findM to be in Control.Monad!
13:47:09 <Twey> I think it should be in Control.Monad
13:47:16 <dmhouse> Submit a patch?
13:47:25 <Twey> Yeah…
13:47:28 <chrisdone> Eelis: but, if you're using hGetContents (special case), you could use straight filter!
13:47:42 * chrisdone tries to provide consolation
13:47:43 <Eelis> to whom? i never know who's responsible for stuff in the stdlib, and have been sent from one place to another on more than one occasion
13:47:43 * Twey shudders.
13:47:57 <Twey> GHC bugtracker maybe?
13:48:03 <dmhouse> Eelis: I'd probably send it haskell-cafe and ask for suggestions
13:48:26 <Eelis> dmhouse: meh, i'm not a mailing list person. if there's no bug tracker, i don't bother
13:48:49 <dmhouse> The GHC bugtracker would undoubtebly be fine too
13:49:11 <Eelis> i think i was scolded for suggesting a stdlib feature there once
13:49:40 <chrisdone> I've got a cabal package, I want to just build it, but I don't have the packages required for it; how can I get cabal to download and install the *required* packages, but not to install the package itself
13:50:03 <dmhouse> Eelis: btw, why the pattern guard in split_paths? It's not like you're actually testing anything. Why not just a let?
13:50:18 <Eelis> dmhouse: just routine
13:50:54 <dmhouse> Okay. It visually screams out to me that you don't have exhaustive patterns in there, whereas in fact you do. I wouldn't like it.
13:51:19 <Eelis> it's just a tuple pattern with simple variables for the components, of course it's exhaustive
13:51:40 * hackagebot funion 0.0.1 - A unioning file-system using HFuse  http://hackage.haskell.org/package/funion-0.0.1 (NathanWiegand)
13:51:41 <dmhouse> I know I know, but I get twitchy for guards without an otherwise case
13:52:23 <dons> nice
13:52:29 <mibygl_> So, dependent-typed languages often require everything to terminate.  If you do this, would it be reasonable to have a non-termination monad, with a function fix :: (a -> NT a) -> NT a, or fix :: (NT a -> NT a) -> NT a?
13:52:35 <Twey> dmhouse: That's just OCD ☺
13:52:44 <Twey> mibygl_: I believe Agda does that
13:52:48 <Twey> (or was it Coq?)
13:52:58 * mibygl_ nods.
13:53:02 <Eelis> i've never heard of a nontermination monad in Coq
13:53:08 <Twey> Must be Agda then
13:53:11 <mibygl_> Any idea whether (a -> NT a) -> NT a or (NT a -> NT a) -> NT a is better?
13:53:32 <Twey> The former
13:53:38 <Twey> Otherwise it doesn't work
13:53:47 <dmhouse> Eelis: you going to put your which in hackage?
13:53:49 <Twey> Well, I guess it does, but they have to bind manually each time, which is pointless
13:54:10 <Eelis> dmhouse: no, hackage and i don't mix
13:54:33 <chrisdone> no ideas, guys?  this should be obvious I guess, I must be missing something obvious but I'm looking through the manual
13:54:51 <Twey> I ended up doing it manually
13:55:54 <Eelis> dmhouse: (i requested a user account but the gatekeeper guy insisted that i use my full real name as a user name even though the registered user list showed that not everybody has to do this, so i lost interest)
13:56:16 <Eelis> annoying favouritism
13:56:27 <chrisdone> Eelis: presumably because he doesn't know you, but he knows the other people
13:56:32 <Eelis> chrisdone: yep
13:56:34 <chrisdone> just a way to ensure you're not a cheeky spammer
13:56:48 <Eelis> chrisdone: nonsense. i could provide a fake name.
13:57:03 <chrisdone> Eelis: I'm guessing he'd check up on it
13:57:34 <Eelis> chrisdone: there are a gazillion common names.
13:57:55 <Jafet> Give him a thunk equivalent to "Eelis" ++ _|_
13:58:30 <SamB_XP> Eelis: what the ?
13:58:45 <Eelis> SamB_XP: that was my reaction!
13:58:54 <SamB_XP> Eelis: can't you PROVIDE him with your full name but get a non-realname for your account name?
13:59:01 <Eelis> SamB_XP: nope
13:59:03 <HugoDaniel> :)
13:59:13 <SamB_XP> well, complain to libraries@ or something ...
13:59:15 <Eelis> SamB_XP: i told him my real name, and he demanded that it become my username
13:59:38 <chrisdone> who?
13:59:45 <chrisdone> was he using his real name? :p
13:59:50 <Eelis> it was ross peterson
14:00:03 <Eelis> *paterson
14:00:41 <Eelis> now that i think about it, this fake name idea is great. problem solved :)
14:01:32 <SamB_XP> seriously, how is anyone gonna know who it is if you use your REAL name ?
14:01:46 <Eelis> i don't understand the question
14:01:53 <SamB_XP> I don't KNOW your real name
14:02:08 <Eelis> no, that's why it'll be so easy to provide a fake name
14:02:21 <Eelis> the guy has no way to check
14:02:23 * dmhouse thinks the real name thing is a stupid policy anyway
14:02:26 <SamB_XP> that's also why it would be annoying for you to use that as your account name
14:02:35 <SamB_XP> Eelis: yeah, bring it up on the appropriate list, I say
14:02:37 <Eelis> dmhouse: indeed
14:02:53 * dmhouse would ping a message to hs-cafe ;)
14:02:56 <SamB_XP> you can probably get a favourable ruling from an appropriate tribunal
14:03:00 <Eelis> SamB_XP: that paterson guy is a haskell community nobleman, isn't he? i sure as hell am not going to pick a fight with him on a public mailing list
14:03:20 <Eelis> unless.. i do it under a fake name!
14:03:39 <SamB_XP> well, loads of us already have fake/abbreviated logins to hackage
14:03:45 <Jafet> 'e's figured it out, folks.
14:03:51 <SamB_XP> so you've precedent on your side
14:04:17 <dmhouse> Eelis: no need to pick a fight. "I tried to apply for a hackage account and was told I needed to use my real name. I'd rather not do this as a personal preference. Furthermore, this doesn't seem to have been applied in the past. Does anyone know the reason behind this policy? Thanks, --Eelis"
14:04:24 <Eelis> SamB_XP: hm, http://hackage.haskell.org/cgi-bin/hackage-scripts/list-users shows what looks like mostly real names. the only exception seems to be "alpheccar"
14:04:45 <Eelis> paterson said "alpheccar" was a "special case"
14:05:01 <SamB_XP> oh, wait, maybe that isn't strange
14:05:15 <SamB_XP> I guess I'm thinking of my other N accounts on Haskell.org
14:05:39 <SamB_XP> what was so special about alpheccar?
14:05:46 <dmhouse> Who are they?
14:05:58 <Eelis> SamB_XP: just that he didn't want his name to appear on the internet. but that's no different from my reasons
14:06:08 <SamB_XP> Eelis: indeed ...
14:06:37 <stevenmarky_> whatever you say guido
14:07:19 <stevenmarky_> I'm having trouble installing SMTPClient, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24666#a24666
14:09:44 <Eelis> dmhouse: disregarding the hackage account issue, i'm not sure my Which module really deserves a package of its own. the only reason it isn't a one-liner is because findM is missing in Control.Monad and because there's no sensible string splitting function in the stdlib :)
14:10:09 <dmhouse> The latter has been bikeshedded to death, I can't believe it's not just been done already
14:11:51 <pozic> Eelis: this just shows how broken a centralized system is.
14:11:59 <Jafet> Import parsec, make a one liner with builtin error checking and trendy coffee maker
14:12:20 <pozic> Eelis: it gives power to one individual that others do not have.
14:12:35 <Eelis> pozic: are you referring to the hacakge account issue now, or the omissions in the stdlib?
14:12:39 <pozic> Eelis: (regarding the names)
14:12:44 <Eelis> pozic: ah. yes, i agree :)
14:13:17 <SamB_XP> Eelis: I think you should post to cabal-devel asking for a link to the official policy
14:14:21 <dmhouse> Hmm, what's a unioning file system?
14:14:26 <pozic> If you really want to do something, you just implement some software.
14:14:38 <Eelis> SamB_XP: the policy is written at http://hackage.haskell.org/packages/accounts.html , and it supports paterson's decision. of course, it does not support the exception made for alpheccar
14:14:38 <pozic> Talking about policies has never solved anything before.
14:14:48 <SamB_XP> Eelis: that's not a policy document!
14:16:04 <Eelis> the only annoying thing about using a fake name is that i'll need a fake email account to go along with it, and changing that address back to my regular @eelis.net address might need a separate request to ross. he'll see through my deception!
14:16:25 <dmhouse> Eelis: I'm happy to send it on your behalf if you like
14:16:37 <SamB_XP> dmhouse: how does that help?
14:16:41 <Eelis> dmhouse: send what? a mail to haskell-cafe bringing up the issue you mean?
14:16:46 <SamB_XP> its still leaves him with the wrong email address!
14:16:55 <SamB_XP> oh, if that's what you meant ...
14:16:58 <dmhouse> Eelis: yes exactly
14:17:13 <Eelis> dmhouse: oh, yes, please, by all means do :) just leave my name out of it :)
14:17:21 <dmhouse> Eelis: Are you on the list? I can't really copy you in
14:17:26 <pozic> Eelis: also, why exactly don't you want to bind your name to it?
14:17:33 <Eelis> dmhouse: i follow the list through nntp
14:17:35 <pozic> Eelis: it is easy to figure out your name.
14:17:39 <Jafet> dmhouse, one that merges directories into one virtual filesystem with some conflict resolution. It's used in bootable CDs for example
14:17:43 <SamB_XP> pozic: that's irrelevant
14:17:47 <Eelis> pozic: what SamB_XP said.
14:17:55 <pozic> SamB_XP: I agree on that.
14:18:10 <pozic> Or is this just Google protection?
14:18:13 <dmhouse> Eelis: fair enough. Do you want to write the copy or should I knock something up?
14:18:18 <Eelis> pozic: basically, yes
14:18:30 <pozic> Eelis: in a few years that won't work anymore.
14:18:36 <SamB_XP> Eelis: you don't want people to know you're into Haskell just by googling ?
14:18:37 <Eelis> dmhouse: i leave it up to you to be diplomatic :)
14:18:55 <dmhouse> Eelis: okay
14:19:06 <Eelis> SamB_XP: well, i kinda lost that battle already. but still, i resist!
14:19:08 <pozic> Eelis: if you really want it to work, I suggest you do all your communications via Freenet.
14:19:24 <Jafet> Free kiddie porn
14:19:38 <SamB_XP> Jafet: actually it's pretty easy to avoid CP
14:19:41 <pozic> Jafet: have you ever used Freenet?
14:19:52 <Jafet> Avoid?
14:20:00 <SamB_XP> you just stay out of groups with CP in the name
14:20:20 <Eelis> SamB_XP: it's just retarded that i have 200 user accounts on various services, and some silly meaningless package database demands my real name? screw that.
14:20:24 <Jafet> pozic, yes
14:20:29 <pozic> Also, in the real world there is also CP.
14:21:04 <pozic> Anyway, I don't agree with Big Brother knowing everything.
14:21:37 <pozic> You cannot have basic privacy and copyright at the same time.
14:21:46 <chrisdone> I think it's good to encourage people to use an identity that is well known throughout the haskell community
14:21:55 <chrisdone> asking for your real name is a simple way to make that happen
14:21:55 <fax> i don't :/
14:21:56 <Eelis> encourage is one thing, demand is another
14:22:02 <fax> some people don't want to be real people
14:22:16 <chrisdone> I don't think it's good that it has to be a real name
14:22:25 <chrisdone> but you could use one well known alias
14:22:37 <fax> I think they ask your real name so you don't upload malicious software and to make it seem like there would be consequences if you did
14:22:40 <LeNsTR> hiall
14:22:45 <chrisdone> sure
14:22:48 <fax> this is also why I didn't put any of my libraries onto hackage
14:22:52 <Eelis> fax: but that's vacuous because it's trivial to use a fake name
14:22:52 <pozic> fax: yes, that is probably the "reason".
14:22:54 <Jafet> "Eelis" is well known, maybe not in the haskell community
14:22:59 <Jafet> @google eelis
14:23:03 <lambdabot> http://eelis.ic.envir.ee/
14:23:03 <lambdabot> Title: EELIS infoleht
14:23:19 <Jafet> Or not.
14:23:28 <Eelis> they're my cover operation
14:23:47 <Eelis> a front for my nefarious deeds
14:23:52 <chrisdone> fax: do you at least put them on github or something?
14:24:00 <SamB_XP> I don't see why you'd be more liable to care about damage to your realname's rep than to your alias' rep...
14:24:11 <fax> no
14:24:23 <fax> I delete everything after a few months
14:24:25 <chrisdone> it sucks that a great programmer isn't uploading his code anywhere
14:24:37 <SamB_XP> ... and plus, half the licenses you can put code under specifically deny responsibility for anything your code may do!
14:24:47 <chrisdone> heh
14:24:47 <Jafet> Only half?
14:24:59 <SamB_XP> Jafet: well, some of them are too short for that to fit, I think
14:25:00 <Jafet> I've never clicked through a license that didn't
14:25:22 <SamB_XP> perhaps the MIT license lacks it, for instance
14:26:25 <adulteratedjedi> does anyone know of a library for sending Infrared signals in haskell?
14:26:37 <Eelis> dmhouse: i will put my sneaky fake name subversion on hold in anticipation of what your haskell-cafe yields :)
14:26:42 <chrisdone> fax: could shove all your stuff on github??
14:26:51 <Eelis> *haskell-cafe post
14:27:41 <fax> if I manage to write this next program I have been working on I will make it available
14:27:51 <SamB_XP> fax: how come you delete stuff?
14:27:51 <chrisdone> yay!
14:28:00 <fax> because it sucks
14:28:02 <SamB_XP> they tell me it's bad to delete your code
14:28:05 <SamB_XP> even if it DOES suck
14:28:16 <fax> by delete I mean not-backup
14:28:26 <SamB_XP> oh
14:28:27 <fax> which invariably means it goes missing when I try a new OS or whatever
14:28:32 <SamB_XP> ah
14:28:34 <chrisdone> haha, I do that
14:28:40 <SamB_XP> well, you're supposed to back it up before THAT
14:28:54 <SamB_XP> and then just not remember what you did with the backup media
14:29:04 <SamB_XP> I mean, not be bothered to dig it out, that is
14:29:05 <chrisdone> Are you sure you want to format this drive and install Ubuntu? All your data will be lost.
14:29:05 <chrisdone> ummm [ Yes ]
14:29:49 <Jafet> They forgot to mention sanity
14:29:51 <chrisdone> I just shove anything remotely functional on github and never work on it again
14:29:53 <Eelis> dmhouse: excellent post! i look forward to its reception
14:30:13 <chrisdone> Eelis: to haskell-cafe?
14:30:16 <Eelis> chrisdone: yes
14:31:27 <chrisdone> good post
14:32:06 <chrisdone> hopefully the real name restriction will be lifted
14:32:07 <Eelis> only thing i'm not sure about is if "hackage" accounts and "hackagedb" accounts are separate things
14:32:16 <dmhouse> Oh sorry
14:32:24 <Eelis> because this restriction is specifically for hackagedb
14:32:25 <SamB_XP> Eelis: they wouldn't be
14:32:38 <chrisdone> what's the difference between hackage and hackagedb?
14:32:38 <dmhouse> I'll clarify
14:32:41 <SamB_XP> there is no other account that would be called a "hackage" account
14:33:03 <Eelis> chrisdone: i think hackage is the "platform" (whatever that may mean), and hackagedb is just the collection of packages
14:33:27 <dmhouse> Okay, I won't clarify
14:33:57 <chrisdone> there is only one account related to hackage I'm aware of ... ^o.o
14:34:07 <Eelis> ok, good, then no clarificaiton needed :)
14:37:24 <ksf> http://okmij.org/ftp/Computation/Continuations.html#fix-callcc
14:37:27 <ksf> damn you, oleg!
14:38:01 <ezyang> beat you to the punch?
14:38:19 <pozic> How big is Hackage?
14:38:31 <pozic> And can you fetch everything in one go?
14:38:40 <ksf> it's more like suddenly discovering that you stand before giant toes and can't even make out the shoulders
14:39:05 <dmhouse> pozic: it's probably too big for that
14:39:08 <pozic> Never mind, I already got it.
14:39:16 <pozic> dmhouse: it's only 90MB.
14:39:28 <ksf> but rest assured, I'm quite certain I make better pudding than him.
14:39:59 <ezyang> ^^
14:40:06 <pozic> I wonder whether people in the physical sciences actually stand on each other's shoulders.
14:40:07 <ksf> *can prepare
14:40:13 <ksf> well ambiguity filter
14:40:24 <SamB_XP> pozic: some of them stand in eachothers footprints, I hear
14:40:35 <ksf> still, that ambiguity doesn't exist in any other language I know...
14:40:54 <pozic> It would be so nice if everyone would actually work together without selfish motives.
14:41:06 <pozic> (which is basically what open source code is about)
14:41:14 <pozic> (the selfish cooperation)
14:41:20 <fax> pozic - that's why I can't find any collaberators
14:41:27 <pozic> fax: on what?
14:41:27 <ksf> what's the problem with working together for selfish reasons?
14:41:42 <fax> in general
14:41:42 <pozic> ksf: nothing, it is just rather limited.
14:41:48 <Eelis> no better motivation that selfishness
14:41:52 <Eelis> *than
14:41:54 <ksf> then your egoism is limited.
14:42:00 <SamB_XP> ksf: the problem is if you can't find anyone with a selfish reason to help you ;-)
14:42:11 <ksf> according to the satanists, loving your next is the highest form of egocentrism.
14:42:45 <jmcarthur> i usually have big projects in mind. i wouldn't wish to impose a man-year's worth of work on somebody else just to get my vision implemented unless they benefit somehow
14:43:08 <fax> jmcarthurs that's what I'm talking about
14:43:17 <shapr> What's the best cabbage to inspect to figure out binary parsing?
14:43:29 <pozic> cabbage? Oh, no.
14:43:32 <kmc> on second thought (re: yesterday's topic of doing OOP in Haskell and whether it's "first-class") i think the natural encoding of OOP in Haskell *does* have first-class classes, in the way Python does and C++ doesn't
14:43:32 <pozic> Don't do that.
14:43:40 <SamB_XP> you need to look at pigeon entrails for that
14:43:42 <fax> I don't get it :[
14:43:44 <shapr> pozic: I like it, cabal package == cabbage :-)
14:43:50 <fax> oh
14:43:57 <shapr> Someone else suggested it, I just think it's so funny!
14:43:57 <pozic> shapr: yes, we got it... no need for the explanation.
14:43:59 <ksf> shapr, none.
14:44:08 <pozic> shapr: are you sure it wasn't you?
14:44:14 <jmcarthur> i didn't get it
14:44:15 <shapr> Ruby has gems, Python has eggs, clearly Haskell is healthier than other languages.
14:44:27 <shapr> jmcarthur: cabal package == cabbage, yes?
14:44:29 <pozic> shapr: it falls in the same as KDE, Konqueror, KConfibulator.
14:44:29 <ezyang> we have... cabals
14:44:30 <monochrom> Haskell has values.
14:44:33 <jmcarthur> well i get it now ;)
14:44:34 <Gracenotes> ingesting.. python eggs? blewergh
14:44:41 <ksf> shapr, but you may use http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24320
14:44:49 <monochrom> valupak
14:44:52 <ezyang> yum cabbages
14:45:12 <kmc> it's almost more prototype-based
14:45:13 <kmc> when your interfaces are existentially-quantified record types
14:45:19 <pozic> Is there any market for Haskell consultants?
14:45:31 <dmhouse> Some
14:45:31 <shapr> Yes.
14:45:33 <kmc> then any function which returns a value of that type is something that'd have to declare a new class in, say, C++ or Java
14:45:42 <ksf> consultants _create_ markets.
14:45:42 <pozic> Or do you basically have to sell yourself as Haskell/OCaml/FP guy?
14:45:44 <ksf> that's their job.
14:45:48 <shapr> ksf: Are there example binary parsers for yoctoparse?
14:45:57 <benmachine> ksf: do markets create consultants as well?
14:46:18 <flippo> We need a consultant consultant then.
14:46:24 <ksf> shapr, on my disk, yes, but they're incomplete
14:46:29 <ksf> it's all straight-forward, though.
14:46:30 <shapr> :-/
14:46:37 <chrisdone> pozic: fancy working in research in italy? company I interviewed for use Common Liasp and are into trying haskell, but they don't know it well and only got one application from their post to haskell-cafe (me)
14:46:53 <ksf> it's basically a way to make iteratees more convinient.
14:47:05 <shapr> Oh, interesting.
14:47:15 * dmhouse is hearing next week about a financial programming gig with OCaml
14:47:17 <shapr> Isn't there a cabbage that turns parsec parsers into iteratees?
14:47:22 <shapr> y0 dmhouse, wassup?
14:47:25 <ksf> it specializes in LR(0) parsing
14:47:27 <kmc> i guess that classes in C++ or Java exist because programmers can't be trusted with the power of unrestricted first-class functions?
14:47:30 <ksf> (if I got that right)
14:47:33 <dmhouse> Hey shapr, how's tricks?
14:47:42 <ezyang> kmc: Plausible
14:47:46 <shapr> dmhouse: Life is EXCITING!
14:47:54 <ezyang> I mean, I don't trust myself with first-class functions unless I have a type system.
14:47:59 <dmhouse> shapr: that's not like you ;)
14:48:03 <kmc> you mean a static type system?
14:48:03 <shapr> haha
14:48:09 <shapr> ksf: Well, show me examples, and I may use it.
14:48:16 <dmhouse> shapr: what are you hacking on these days?
14:48:21 <shapr> But I was wondering what the most common binary parser lib is these days.
14:48:29 <shapr> dmhouse: School, lately.
14:48:37 <shapr> And the hackerspace I'm starting with ybit
14:48:40 <dmhouse> shapr: ah, same here.
14:48:47 * dmhouse is writing a Hamiltonian cycle path finder at the moment
14:48:53 <ksf> shapr, first, have a look at word16leP
14:49:01 * dmhouse also wrote a graph colourer and some supercool percolation simulation stuff
14:49:21 <dmhouse> (Although the percolation's in C.)
14:49:32 <ezyang> kmc: yeah
14:49:48 <ezyang> a dynamic type system isn't much of a type system at all...
14:50:42 <Jafet> I would state the fact that I disagree, if not for the fact that this is #haskell
14:50:44 <ybit> dmhouse: yo david!
14:50:48 <ybit> watup
14:50:51 <ybit> <- heath matlock
14:51:04 <shapr> ksf: What's P other than Prelude?
14:51:17 <ezyang> Jafet: Well, it's better than a segfault...
14:51:18 <ybit> shapr: this is the fellow from BU starting builds
14:51:27 <shapr> Ah, nifty!
14:51:36 <ybit> you googled him
14:51:36 <SamB_XP> Jafet: but it makes a really lousy type theory
14:51:38 <kmc> dynamic and static type systems are valuable and quite different things
14:51:40 <dmhouse> Hi ybit
14:51:48 <kmc> anyway
14:51:52 <ksf> shapr, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24320#a24671
14:51:55 <ksf> (some random code)
14:51:56 <SamB_XP> the theorems are really boring
14:51:59 <ksf> P is parser
14:52:03 <ybit> dmhouse: http://tweaklabs.org
14:52:06 <Jafet> Segfaultiness isn't relevant
14:52:09 <Jafet> CLOS/MOP isn't lousy, although you might call it overengineering
14:52:17 <ksf> (there's haddock comments, btw)
14:52:20 <kmc> i don't agree, i use first-class functions extensively in Python
14:52:34 <adulteratedjedi> does anyone know of a library for sending Infrared signals in haskell?
14:52:45 <Jafet> Python procedures are first class?
14:52:48 <Jafet> Sorry, I should stop
14:52:48 <ezyang> kmc: Yeah, I should amend my statement
14:52:48 <kmc> but i think any Python program bigger than a few hundred lines, whether or not it uses first-class functions, will get unmaintainable
14:52:48 <monochrom> @quote monochrom dynamic
14:52:49 <lambdabot> monochrom says: dynamic type is poor man's dependent type, they are so poor they can't buy a theorem prover.
14:53:01 <kmc> because of a lack of static types, mostly
14:53:04 <ezyang> I don't trust myself with higher-order functions in Python
14:53:09 <shapr> kmc: You should see Plone on top of Zope... it's insane.
14:53:09 <kmc> adulteratedjedi, of what kind?
14:53:11 <ezyang> unless it's a very specific pattern, like a decorator
14:53:27 <dmhouse> ybit: "this is the fellow from BU starting builds" -- you weren't referring to me there, were you?
14:53:28 <ksf> shapr, note the nested parsing in NinePWire Version
14:53:35 <ybit> dmhouse: yah
14:53:40 <Jafet> shapr, better to attach them to a console and see the back traces
14:53:43 <dmhouse> ybit: what are the BU starting builds? :)
14:53:50 <Veinor> anybody here have any advice on how to make hxt go faster?
14:53:55 <shapr> ksf: Where's the NinePWire version?
14:54:01 <ybit> dmhouse: perhaps #haskell-blah is a better discussion channel
14:54:03 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24320#a24671
14:55:02 <sannysanoff> hi gentlemen, please help with simple question: how do I get 8 bytes representation from Double value in haskell?
14:55:25 <sannysanoff> .... in machine-dependent way, of course
14:55:37 <Jafet> Painfully
14:55:55 <monochrom> perhaps Data.Binary of the "binary" package
14:55:58 <dschoepe> sannysanoff: I cobbled something together for a similar task using the ffi modules
14:56:01 <benmachine> sannysanoff: unsafeCoerce woooo
14:56:03 <Gracenotes> doing a sort of double-to-long-C-union-trick is possibly with unsafeCoerce.
14:56:08 <ksf> shapr, main features are: no "try" (there just isn't any backtracking), and non-greedyness
14:56:10 <sannysanoff> I saw it in GHC.Prim, with touple*4, this is terrible
14:56:13 <Jafet> Depends on how much typesafety you want to pretend you have
14:56:14 <benmachine> unsafeCoerce to Word64
14:56:18 <sannysanoff> touple/tuple
14:56:20 <kmc> "binary" does serializing, right? no guarantee it's the native representation
14:56:24 <kmc> i would coerce the unboxed values
14:56:28 <sannysanoff> benmachine, i will check it out
14:56:30 <kmc> but i'm not sure you can
14:56:41 <Gracenotes> of course, unsafeCoerce is more than just machine dependent... it's not really dependent on anything, is it
14:56:50 <kmc> you have no guarantee that the heap layout of a Double closure is compatible with a Word64 closure
14:56:56 <dschoepe> sannysanoff: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24672#a24672 - thats what I used for getting the first 4 bytes.
14:56:56 <sannysanoff> monochrom, data.binary is not fun. it converts Double to 25 bytes
14:57:06 <kmc> the safest thing would be to use the FFI modules to marshall a CDouble
14:57:10 <SamB_XP> Gracenotes: implementation-defined at best
14:57:21 <Jafet> You could manually reconstruct the IEEE 754 bit layout, or equivalent
14:57:29 <sannysanoff> kmc, i will check that out (CDouble) too, thanks
14:57:30 <Gracenotes> otherwise.. you can *actually* do the C union trick. Without unions.
14:57:36 <SamB_XP> well, except when the spec says differently
14:57:48 <Gracenotes> at least, without explicit unions
14:59:02 <Gracenotes> also, RealFloat might help, except that it always behaves weirdly here... :/
14:59:12 <ksf> shapr, cereal is comparable because it's got <|>, too, but it's strict bytestring only.
14:59:23 <ksf> another possibility would be attoparsec-iteratee
15:00:58 <sannysanoff> I have found Foreign.Marshal.Utils.with :: Storable a => a -> (Ptr a -> IO b) -> IO b
15:01:13 <kmc> you probably want "alloca"
15:01:36 <ksf> shapr, conceptual-wise packrat parsing would be interesting, too, but I think it's overkill for any binary protocol you will ever come across.
15:01:43 <sannysanoff> .. and this seems to be what i need! thanks everyone.
15:01:59 <kmc> sannysanoff, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24673#a24673
15:02:04 <kmc> you can add size checking to this if desired
15:02:06 <ksf> ...the most complex thing to be found there being null-terminated strings
15:03:01 <sannysanoff> kmc, this is good too, thanks!
15:08:30 <kmc> just tested it against a C cast with QuickCheck
15:08:32 <kmc> seems fine
15:09:41 <chrisdone> glorious quickcheck
15:15:51 <breakspirit> hello everyone
15:15:55 <kmc> hi breakspirit
15:16:21 <ben_m> Greetings!
15:16:39 <kmc> hi
15:16:48 <ben_m> I'm currently writing a turtle graphics library for Haskell, or trying to.
15:17:23 <breakspirit> http://pastebin.com/kvK0Xmmc  can anyone help me remove that case expression and replace with a conditional or a guard
15:17:26 <ben_m> What I have right now is this ... which works, but is ugly.
15:17:32 <ben_m> *Main> return [(0, 0, 0)] >>= return . forward 10 >>= return . right 90 >>= return . forward 10
15:17:34 <ben_m> [(10.0,-10.0,-90.0),(10.0,0.0,-90.0),(0.0,0.0,0.0)]
15:17:45 <fax> hat's cool
15:17:48 <fax> that's cool
15:17:53 <fax> it's like turtle graphics or something
15:17:58 <ben_m> I'd like to remove all the returns somehow
15:18:01 <kmc> :t \a f -> (a >>= return . f)
15:18:02 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => m a -> (a -> a1) -> m a1
15:18:13 <kmc> ben_m, look at the liftM family in Control.Monad
15:18:17 <kmc> also
15:18:19 <kmc> :t (<$>)
15:18:19 <ben_m> fax: I'll write a function that takes that output and draws it :)
15:18:20 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:18:23 <fax> nice
15:18:25 <kmc> from Control.Applicative
15:18:27 <kmc> also "fmap"
15:18:29 <kmc> :t fmap
15:18:30 <ben_m> kmc: Ideally I want to use it with do at the end
15:18:31 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:18:35 <ben_m> So it will look a bit like
15:18:48 <ben_m> withTurtle $ do { forward 10; right 90; forward 10 }
15:18:52 <ben_m> If possible.
15:18:56 <fax> yeah do that
15:19:05 <kmc> breakspirit, (x:) <$> unknotMatch ss xs
15:19:17 <kmc> breakspirit, that uses the Functor instance for Maybe
15:19:30 <kmc> @src Maybe fmap
15:19:30 <lambdabot> fmap _ Nothing       = Nothing
15:19:30 <lambdabot> fmap f (Just a)      = Just (f a)
15:19:50 <breakspirit> what would i replace with that line?
15:19:54 <SamB_XP> @src (<$>)
15:19:55 <lambdabot> f <$> a = fmap f a
15:19:55 <kmc> the case expression
15:20:22 <kmc> (x:) <$> unknotMatch ss xs   =   case unknotMatch ss xs of Nothing -> Nothing; Just rs -> Just (x:rs)
15:20:32 <kmc> by the above definition of fmap
15:20:37 <kmc> (<$> is just an infix alias for fmap)
15:20:52 <breakspirit> hm, not familiar with fmap
15:20:55 <kmc> ben_m, sounds good.  it's a monadic embedded domain specific language
15:21:03 <ksf> what if I have a sum type where one alternative forms an applicative functor, the other one a monad?
15:21:04 <ben_m> yeah that's my goal
15:21:06 <kmc> breakspirit, it essentially applies a function over the "structure" of a "container"
15:21:09 <SamB_XP> breakspirit: it used to be called "map" ;-)
15:21:11 <kmc> in some generalized sense of those two words
15:21:15 <kmc> i.e for lists it is just map
15:21:15 <ben_m> I don't know Haskell well enough though, especially Monads and such things :)
15:21:18 <kmc> > fmap succ [1,2,3]
15:21:19 <lambdabot>   [2,3,4]
15:21:20 <kmc> > fmap succ Nothing
15:21:21 <lambdabot>   Nothing
15:21:23 <kmc> > fmap succ (Just 3)
15:21:24 <lambdabot>   Just 4
15:21:47 <kmc> ben_m, sounds like a good way to learn
15:21:51 <ben_m> indeed!
15:21:54 <kmc> monads seem complicated until you implement one
15:22:04 <kmc> then you see that Monad is just an API interface and a small one at that
15:22:05 <ben_m> Which Monad do I use though?
15:22:13 <ben_m> Or is the list monad correct?
15:22:13 <kmc> ben_m, oh, i thought you'd write your own
15:22:18 <ben_m> oh, do I have to? :D
15:22:23 <kmc> no, but it'll be more fun :)
15:22:26 <ben_m> heh
15:22:31 <kmc> ben_m, why were you using the list monad?
15:22:32 <ben_m> Not that hard though, I did that before.
15:22:41 <Eelis> hm, i'm using the Paths_xxx module generated by Cabal, but the fact that it returns its result in IO is a bit annoying. looking at the source i see that it's done this way because apparently one can override (at runtime) the paths using environment variables. i don't even want this functionality! i wish the Paths_xxx module just exposed the path constants without any extra features
15:22:42 <ben_m> kmc: Well, I want a list at the end, so that looks like a sensible decision
15:22:51 <ben_m> And I do get the correct output ... I just have to write a lot of return :/
15:22:54 <kmc> ben_m, only if you want (>>=) to work the way it does for lists
15:23:01 <kmc> ben_m, in that case you are not using monads
15:23:03 <breakspirit> well thank you very much  =)
15:23:05 <ben_m> hmm
15:23:06 <ksf> Eelis, unsafePerformIO
15:23:08 <kmc> since (a >>= (f . return)) is (fmap f a)
15:23:12 <kmc> you are just using Functor
15:23:13 <kmc> i'm guessing you want some kind of state monad
15:23:17 <ben_m> yeah
15:23:21 <Eelis> ksf: i know.. but life shouldn't be this way
15:23:22 <ben_m> that was my initial guess
15:23:24 <ben_m> :D
15:23:30 <kmc> to update the state of a turtle as it moves around
15:23:36 <kmc> and/or update the state of the screen
15:23:41 <ben_m> mhh well
15:23:46 <kmc> if you're drawing in real time, you'll probably want the IO monad
15:23:51 <kmc> but you can wrap it to hide that from your users
15:23:54 <ben_m> Drawing will be done later
15:24:10 <ben_m> First I want to generate a list of points where the turtles moves to
15:24:15 <kmc> generally in a big Haskell project i will have some custom domain-specific monads which are often "newtype" wrappers on standard mtl monad-transformer stacks
15:24:19 <ben_m> I could use the State Monad for that I suppose
15:24:33 <kmc> and then you define a few domain-specific operations for your monad, and the rest of the code is in terms of those
15:24:34 <ksf> I seriously doubt turtle graphics need a monad
15:24:35 <ben_m> No idea what newtype is, always puzzled me
15:24:51 <kmc> "newtype" is like "data", but only works in a subset of cases
15:24:59 <ksf> unless you want to have isPenUp and getAngle
15:25:02 <kmc> in those cases it's more efficient at runtime than "data"
15:25:09 <ben_m> ksf: nope
15:25:12 <ben_m> kmc: I see
15:25:15 <kmc> (it also differs slightly in the treatment of undefined values)
15:25:25 <ksf> then you can just use monoid
15:25:35 <kmc> ben_m, specifically, "newtype" requires that you have only one constructor with one field
15:25:35 <ben_m> state monad basically just threads a value through the functions, right?
15:25:38 <kmc> yes
15:25:43 <ben_m> that sounds good
15:25:46 <ben_m> i'll try that :)
15:26:44 <Veinor> I'm having problems using Network.Browser; the example for getting a page and following redirects doesn't typecheck.
15:29:51 <ben_m> is there a monad for which bind is basically just function composition?
15:30:13 <kmc> there's a monad for which (<=<) is function composition
15:30:15 <kmc> it's the identity monad
15:30:26 <kmc> :t (<=<)
15:30:27 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
15:31:00 <Mibbigal> Oops, my nick is wrong.
15:31:13 <mibygl> Is there an Extended Euclidean Algorithm function?
15:31:28 <dmhouse> I've written one before
15:31:33 <m3ga> is code.haskell.org down?
15:31:46 <ezyang> Veinor: What's the type error?
15:31:47 <mibygl> @src gcd
15:31:48 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
15:31:48 <lambdabot> gcd x y = gcd' (abs x) (abs y)
15:31:48 <lambdabot>    where gcd' a 0  =  a
15:31:48 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
15:31:57 <dmhouse> I think I actually wrote it in C, though. Never mind
15:33:17 <mibygl> > let egcd a 0 x y = (a,x,y); egcd a b x y = egcd b (a `rem` b) y (x + a `quot` b) in egcd 80 50
15:33:18 <lambdabot>   -3->
15:33:18 <lambdabot>    -3->
15:33:18 <lambdabot>      (10,-1,0)
15:33:18 <lambdabot>    -2->
15:33:18 <lambdabot>      (10,-1,1)
15:33:20 <lambdabot> [3 @more lines]
15:33:24 <mibygl> > let egcd a 0 x y = (a,x,y); egcd a b x y = egcd b (a `rem` b) y (x + a `quot` b) in egcd 80 50 1 1
15:33:25 <lambdabot>   (10,3,4)
15:33:46 <mibygl> I don't think that's the EEA.
15:34:13 <mibygl> > let egcd a 0 x y = (a,x,y); egcd a b x y = egcd b (a `rem` b) y (x - a `quot` b) in egcd 80 50 1 1
15:34:14 <lambdabot>   (10,-1,-2)
15:34:40 * mibygl ponders.
15:34:56 <Veinor> Couldn't match expected type `Network.Stream.Result
15:34:56 <Veinor>                                     (Response String)'
15:34:57 <Veinor>            against inferred type `(Network.URI.URI, Response String)'
15:35:23 <ezyang> which line?
15:36:30 <Veinor> getResponseBody rsp
15:36:43 <Veinor> I have to use return $ (rspBody . snd) rsp instead
15:37:33 <ben_m>     Ambiguous module name `Control.Monad.Identity':
15:37:35 <ben_m>       it was found in multiple packages: transformers-0.1.4.0 mtl-1.1.0.2
15:37:37 <ben_m> ... :/
15:37:55 <ezyang> sounds like broken docs. why don't you poke the module maintainer?
15:38:26 <Veinor> think I will
15:39:02 <SamB_XP> @hoogle getResponseBody
15:39:03 <lambdabot> Network.HTTP getResponseBody :: Result (Response ty) -> IO ty
15:39:19 <SamB_XP> @hoogle rspBody
15:39:19 <lambdabot> Network.HTTP.Base rspBody :: Response a -> a
15:39:52 <Veinor> @hoogle browse
15:39:53 <lambdabot> Network.Browser browse :: BrowserAction conn a -> IO a
15:39:53 <lambdabot> module Network.Browser
15:39:53 <lambdabot> Network.Browser data BrowserAction conn a
15:39:58 <Veinor> er
15:40:02 <Veinor> @hoogle request
15:40:02 <lambdabot> Network.Browser request :: HStream ty => Request ty -> BrowserAction (HandleStream ty) (URI, Response ty)
15:40:03 <lambdabot> Network.HTTP.Base data Request a
15:40:03 <lambdabot> Network.HTTP.Base Request :: URI -> RequestMethod -> [Header] -> a -> Request a
15:40:07 <kmc> ben_m, $ ghc-pkg hide transformers
15:40:22 <kevinulin> im not sure what im trying to is even logical, but if i have a function that accepts a function String -> IO () which it maps to a list, is there a way to create a function that I can pass which fits that signature and also puts the String into a TChan?
15:40:47 <kmc> kevinulin, yes
15:40:49 <mibygl> > let egcd a b = if a `mod` b == 0 then (0,1) else let (x,y) = egcd y (x `rem` y) in (y, x - y * (a `div` b)) -- Wikipedia's version, which, helpfully, is not tail recursive
15:40:50 <lambdabot>   not an expression: `let egcd a b = if a `mod` b == 0 then (0,1) else let (x...
15:41:00 <mibygl> > let egcd a b = if a `mod` b == 0 then (0,1) else let (x,y) = egcd y (x `rem` y) in (y, x - y * (a `div` b)) in egcd 80 50
15:41:01 <JoshTriplett> In playing around with a record-like set of types, I managed to break the coverage condition.  Would someone mind taking a look at my code and telling me what I've done wrong?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24674
15:41:04 <lambdabot>   mueval-core: Time limit exceeded
15:41:09 <kmc> kevinulin, well, the function doesn't put anything... it returns an IO () action which will put into the TChan
15:41:13 <mibygl> > let egcd a b = if a `mod` b == 0 then (0,1) else let (x,y) = egcd y (x `rem` y) in (y, x - y * (a `div` b)) in egcd 16 10
15:41:13 <ben_m> kmc: Thanks <3
15:41:17 <lambdabot>   mueval-core: Time limit exceeded
15:41:22 <JoshTriplett> I intended to allow expressions like this: (X := 5) # X
15:41:32 <Sgeo_> :t (a->Bool)->(b->Bool)->a->b->Bool
15:41:33 <lambdabot> parse error on input `->'
15:41:37 <JoshTriplett> And this: ((X := 5) :+ (Y := 12)) # X
15:41:38 <Sgeo_> @hoogle (a->Bool)->(b->Bool)->a->b->Bool
15:41:38 <lambdabot> No results found
15:41:56 <JoshTriplett> But my instance of HasField for :+ broke the coverage condition.
15:42:04 <kmc> kevinulin, put chan x = atomically $ writeTChan ch x
15:42:14 <kmc> then (put chan) :: String -> IO ()
15:42:20 <kmc> for an appropriate TChan
15:42:52 <kevinulin> i see, it seemed like currying should be appropriate but the concept is still no one i have a solid grasp of yet
15:42:53 <JoshTriplett> I suspect I've written the type of :+ suboptimally.
15:43:00 <kevinulin> kmc: thanks
15:43:15 <marcuy> I have a very basic question implementing an average function.. can anyone help me? http://pastebin.org/135478
15:43:40 <kmc> btw, for the Double -> Word64 thing, a C FFI call seems to take about 40% less time than using poke/peek
15:43:43 <kmc> <3 criterion
15:44:02 <JoshTriplett> marcuy: You've written the type of "promedio" as [Int] -> Double, but you've done nothing to convert from Int to Double.
15:44:18 <JoshTriplett> marcuy: You could write it as [Double] -> Double.
15:44:36 <JoshTriplett> marcuy: Or you could make it convert, but that seems like an odd side effect of an average function.
15:44:49 <JoshTriplett> marcuy: Does that make sense.
15:44:50 <JoshTriplett> ?
15:45:18 <JoshTriplett> (Also, you haven't supplied the functions "sumatoria" and "largo", but I'd guess sumatoria = sum and largo = length? :))
15:45:44 <marcuy> JoshTriplett, hehe they are implemented outside pastebin ;)
15:46:39 <m3ga> is code.haskell.org down? i'm trying to 'darcs pull' from a number of different repos and it just hangs.
15:46:44 <Twey> Yes
15:46:45 <marcuy> JoshTriplett, it make sense I will research more on conversion thanks :)
15:46:59 <Veinor> @unpl \f x -> g x $ f x
15:47:00 <m3ga> thanks Twey. any ETA for a fix?
15:47:00 <lambdabot> \ f x -> g x (f x)
15:47:08 <Veinor> I always get that backwards.
15:47:10 <Veinor> @pl \f x -> g x $ f x
15:47:11 <lambdabot> ap g
15:48:52 <Twey> m3ga: Tomorrow morning PST, if past experience is anything to go by
15:49:09 <Twey> Oh, but it might be a holiday because of Easter, so perhaps the day after
15:49:13 <kmc> and unsafeCoerce is by far the fastest :)
15:49:29 <orlandu63> what does @pl stand for?
15:49:32 <kiris> anyone used haskell from ruby?
15:49:32 <m3ga> thanks. there goes my easter monday hacking :-)
15:49:32 <kmc> "pointless"
15:49:36 <kmc> aka "points-free"
15:49:46 <mibygl> > let egcd xa xb xd ya yb 1 = (ya,yb); egcd xa xb xd ya yb yd = egcd ya yb yd (xa - g*ya) (xb - g*yb) (xd - g*yd) where g = xd `quot` yd in egcd 1 0 80 0 1 50
15:49:47 <kmc> "points" are explicitly-named arguments
15:49:47 <lambdabot>   * Exception: divide by zero
15:49:53 <kmc> @pl \f g x -> f (g x)
15:49:53 <lambdabot> (.)
15:49:55 <m3ga> kiris see hubris on hackage
15:49:55 <Veinor> I am an idiot
15:50:05 <kiris> m3ga: I know of hubris. I'm asking if anyone's used it
15:50:32 <m3ga> ah ok. well i'm not, but i don't ruby :-)
15:50:56 <mibygl> > let egcd xa xb xd ya yb yd = if g == 0 then (ya,yb) else egcd ya yb yd (xa - g*ya) (xb - g*yb) (xd - g*yd) where g = xd `quot` yd in egcd 1 0 80 0 1 50
15:50:57 <lambdabot>   * Exception: divide by zero
15:51:05 <mibygl> > let egcd xa xb xd ya yb yd = if yd == 0 then (ya,yb) else egcd ya yb yd (xa - g*ya) (xb - g*yb) (xd - g*yd) where g = xd `quot` yd in egcd 1 0 80 0 1 50
15:51:06 <lambdabot>   (-5,8)
15:51:21 <orlandu63> kmc: so it's sort of the inverse of @src?
15:51:24 <pastorn> in ghci, can i spawn a thread (a server of sorts) and not have it dying on me when i do :r?
15:51:38 <mibygl> > let egcd xa xb xd ya yb yd = if yd == 0 then (xa,xb,xd) else egcd ya yb yd (xa - g*ya) (xb - g*yb) (xd - g*yd) where g = xd `quot` yd in egcd 1 0 80 0 1 50
15:51:39 <lambdabot>   (2,-3,10)
15:51:41 <kiris> what's :r do?
15:51:54 <marcuy> kiris, reloading
15:52:03 <mibygl> There we go, kind of.  I was hoping for (3,-5,10) or (-3,5,10).  Oh well.
15:52:09 <kmc> orlandu63, not really
15:52:16 <kiris> does it destroy the runtime and create a new one?
15:52:26 <kmc> orlandu63, it uses a bag of tricks to try to get rid of named arguments, and often destroys readability in the process
15:52:58 <Veinor> on the other hand
15:53:13 <Veinor> @unpl on
15:53:13 <lambdabot> on
15:53:15 <Veinor> ...
15:53:21 <Veinor> it doesn't know about on, does it?
15:54:06 <orlandu63> ah i remember now
15:54:48 <Veinor>  @pl can make things nice, but it can also (particularly if the argument is embedded deeply in the function) make them ugly
15:54:52 <benmachine> @unpl \b f x -> b (f x) (f x)
15:54:52 <lambdabot> \ b f x -> b (f x) (f x)
15:54:55 <benmachine> er
15:54:57 <benmachine> @pl \b f x -> b (f x) (f x)
15:54:57 <lambdabot> join . liftM2
15:55:09 <Veinor> @pl \f x -> (f x) (f x)
15:55:09 <lambdabot> join ap
15:55:26 <kmc> rarely will either the most-pointy code or the output of @pl be the best / most readable
15:55:34 <benmachine> @pl liftM
15:55:34 <lambdabot> fmap
15:55:39 <kmc> there is a delicate balancing act
15:55:41 <Twey> Oh, I don't know
15:55:57 <Twey> The output of @pl is beautiful at least as often as it is hideous
15:56:04 <orlandu63> is the points-free style faster in regards to execution time?
15:56:05 <benmachine> heh
15:56:12 <Twey> orlandu63: No
15:56:23 <benmachine> orlandu63: as long as you optimise, they'll probably end up identical
15:56:28 <orlandu63> hmm
15:56:50 <benmachine> it's faster in regards to reading time :)
15:57:10 <orlandu63> :P
15:57:11 <Jafet> Depends on what is reading
15:57:16 <benmachine> other people reading your programs is what programming is all about anyway
15:57:27 <benmachine> this compiling business is just an interesting sidenote
15:58:59 <orlandu63> @pl (\a b -> a + b)
15:58:59 <lambdabot> (+)
15:59:44 <kmc> <3 <3 <3 criterion
15:59:56 <Zao> kmc: You seem slightly happy.
16:00:00 <kmc> yes
16:00:12 <kmc> because i had a question about low-level performance details
16:00:23 <kmc> and it took no time at all to write a benchmark which gives me a definitive answer
16:00:24 <ben_m> @pl (\(x,y,z) -> (x,y))
16:00:24 <lambdabot> (line 1, column 7):
16:00:24 <lambdabot> unexpected ","
16:00:24 <lambdabot> expecting letter or digit, operator or ")"
16:00:24 <lambdabot> ambiguous use of a non associative operator
16:00:31 <ben_m> ups.
16:00:42 <ben_m> Did I just break it?
16:00:47 <kmc> pl doesn't know tuples > 2
16:00:50 <kmc> for some reason
16:00:51 <ben_m> ah :)
16:00:51 <Twey> No, it just doesn't handle big tuples
16:00:57 <Twey> Because there are no functions to deal with them
16:00:58 <kmc> they're rare anyway
16:01:09 <Twey> Silly to have it not even be able to parse them, though
16:01:35 <Twey> > \(x, y) -> (y, y)
16:01:36 <lambdabot>   {((),())->((),())}
16:01:37 <Twey> Er
16:01:39 <benmachine> :t uncurry3
16:01:40 <Twey> @pl \(x, y) -> (y, y)
16:01:40 <lambdabot> join (,) . snd
16:01:41 <lambdabot> Not in scope: `uncurry3'
16:01:54 <Twey> Yeah, it does handle those
16:02:32 <orlandu63> wow awesome
16:02:36 <orlandu63> even , is a function
16:02:59 <orlandu63> there is like no syntactical sugar in haskell
16:03:10 <benmachine> , is both function and sugar
16:03:12 <orlandu63> i dont know why but that blows my mind
16:03:21 <ben_m> Hmm, I'm having a braindead moment right now ... can I feed a value into a do expression?
16:03:59 <benmachine> ben_m: what does that mean
16:04:03 <ben_m> explaining it
16:04:05 <ben_m> :D
16:04:24 <kmc> yeah, the part where you can write (x,y) instead of ((,) x y) is sugar
16:04:48 <ben_m> When I have "return 1 >>= f >>= g", could I write it somehow so I can write "withInit $ f >>= g"
16:04:53 <kmc> Haskell is pretty rich in sugar but it usually translates into more basic forms you can also use
16:05:12 <orlandu63> i see
16:05:13 <kmc> (return x >>= f)  =  (f x)
16:05:15 <kmc> no?
16:05:31 <kmc> :t (,,,,,)
16:05:32 <lambdabot> forall a b c d e f. a -> b -> c -> d -> e -> f -> (a, b, c, d, e, f)
16:05:55 <ben_m> kmc: depends on the monad, doesn't it?
16:06:11 <Veinor> kmc: yeah, do-notation is the sugariest sugar in Haskell
16:06:23 <Veinor> except for maybe record syntax
16:06:30 <Veinor> and both of those have good motivations behind them :)
16:06:34 <kmc> ben_m, isn't it a monad law?
16:06:40 <ben_m> I don't know :D
16:06:43 <kmc> feah
16:06:43 <glguy_> ben_m: You can write an instance of Monad that doesn't satisfy that law, but then it isn't a "monad"
16:06:44 <kmc> yeah*
16:06:52 <kmc> it's one of the laws
16:06:55 <ben_m> ah :)
16:07:02 <kmc> ben_m, http://www.haskell.org/haskellwiki/Monad_Laws
16:07:48 <Veinor> I wonder what would actually happen if you wrote an instance of Monad that didn't satisfy the laws
16:07:51 <Veinor> would stuff break?
16:08:08 <Jafet> Like scifi, you can break the laws of physics if it makes your story more coherent
16:08:24 <Jafet> Stuff that relies on the laws might break
16:08:33 <Jafet> Typewise it would be fine
16:09:49 <kmc> it means some library functions start to do things in "unspecified order"
16:10:08 <Veinor> that's what i meant, how relient are the library functions on the monad laws?
16:10:09 <kmc> for example "sequence" relies on associativity
16:10:25 <kmc> in order to fulfill the contract "executes actions left to right"
16:10:30 <kmc> otherwise there are many "left to right" orders
16:10:55 <kmc> maybe you would just assume a >> (b >> (c >> ...
16:11:27 <Jafet> That's sort of like asking "would stuff break if I switch the house from AC to DC"
16:11:43 <kmc> i can answer that one
16:12:09 <ben_m> Gah so close to finishing this and now I have to use another Monad >_>
16:12:45 <Cale> ben_m: You never have to use a monad.
16:12:57 <kmc> you have to use a monad if your homework says "use a monad" ;)
16:12:57 <Cale> ben_m: Or at least, you never have to admit to using a monad.
16:13:04 <kmc> if all you have is incandescent lamps and you use the DC voltage equal to the AC rms voltage, you're fine ;)
16:13:10 <ben_m> Well the DSL i want to write uses the do notation
16:13:17 <ben_m> So it kind of does use monads.
16:13:22 <Cale> okay
16:13:27 <Jafet> It's still electricity, but yes
16:13:29 <Cale> Or at least one monad
16:14:01 <ben_m> I'm writing a Turtle Graphics lib, and I want it to be used like such "runTurtle $ do { forward 10; right 90; forward 10 }"
16:14:08 <Jafet> That reminds me, I once worked in a shitty high school lab and we were making a transformer and it worked with the bench power supply on AC, then someone switched it to DC by accident and we tried it again without realizing and the transformer still worked
16:14:15 <ben_m> Or something similar
16:14:21 <Veinor> ... how can a DC transformer work? O_po
16:14:23 <Veinor> *O_o
16:15:03 <Cale> ben_m: Of course, you could always invent your own infix operator to join commands from end to end
16:15:07 <p_l> Veinor: by switching to AC, going through transformer and switching back to DC
16:15:13 <ben_m> Cale: Ah, you mean (>>)?
16:15:18 <Veinor> ah
16:15:23 <ben_m> Is that a good idea? :D
16:15:33 <ben_m> Would simplify it I suppose
16:15:37 <Cale> ben_m: Of course, it might be quite similar to (>>)
16:15:46 <ben_m> well do uses (>>), doesn't it? :)
16:15:48 <bremner> <-|-|-|-<   can't go wrong with the dead fish operator
16:15:50 <Cale> Might be best to avoid calling it (>>), since that's taken by the prelude
16:16:17 <Cale> do-notation uses >> and >>=
16:17:01 <kmc> there are DC-DC voltage converters but they are not really "transformers"
16:17:14 <ben_m> yeah
16:17:17 <kmc> do-notation can be programmed to use your own (>>) and (>>=) rather than the Prelude's
16:17:31 <kmc> but the Monad class is already set up for overloading these in a clean way
16:18:28 <ben_m> yeah but then I'd have to either write a very dirty Monad Instance, or come up with how to abide the Monad laws
16:18:52 <Twey> <*<<<-< — dead-fish operator
16:20:32 <Cale> *<>< -- feed noms to fish operator
16:20:54 <Cale> noms *<>< betta
16:21:58 <kevinulin> if i want to write a library that exposes 5 functions, but has 10 functions that i do not want to expose but want to be able to use in quickcheck functions, is the only option to break the module into two?
16:22:43 <Twey> kevinulin: Or put the quickcheck functions inside the module…
16:22:45 <Twey> Cale: Hehe, cute
16:24:08 <kevinulin> seems very wront to include the quickcheck functions in the module
16:24:12 <kevinulin> wrong, rather
16:25:31 <kevinulin> im just not happy with either option really, is there no sort of 'protected' property I can set?
16:26:08 <Polarina> What package has the module Control.Monad.Trans.Maybe? I do not have it.
16:26:50 <Twey> Polarina: transformers
16:27:15 <Aristid> > fix show
16:27:16 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
16:28:47 <Veinor> that never ceases to amuse me
16:29:00 <kmc> > fix error
16:29:01 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
16:30:21 <Veinor> that one too
16:30:29 <Veinor> this is the exception that never ends
16:30:35 <Veinor> it just goes on and on my friends~ o/`
16:31:06 <kmc> > map length . take 20 . filter ((=='\\').head) . group $ fix show
16:31:08 <lambdabot>   [1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535,131071,26...
16:32:05 <Veinor> presumably s_n = 2^(n+1)-1
16:32:16 <kmc> one may presume
16:33:14 <fax> @oies 1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535,131071,26
16:33:15 <lambdabot>  Sequence not found.
16:33:18 <fax> @oies 1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535,131071
16:33:19 <lambdabot>  2^n - 1. (Sometimes called Mersenne numbers, although that name is usually r...
16:33:19 <lambdabot>  [0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535,131071,2...
16:33:29 <fax> the great OIES has spoken!
16:33:31 <benmachine> r
16:33:55 <kmc> @oeis 8,6,7,5,3,0,9
16:33:56 <lambdabot>  From the words to the song "Jenny's Letterbox" by Tommy Tutone.
16:33:56 <lambdabot>  [8,6,7,5,3,0,9,8,6,7,5,3,0,9,8,6,7,5,3,0,9,8,6,7,5,3,0,9,8,6,7,5,3,0,9,8,6,7...
16:34:01 <fax> lol what
16:34:16 <fax> is that mathematica
16:34:18 <fax> l
16:34:26 <Veinor> why does that repeat forever?
16:34:32 <Veinor> I mean shouldn't that be finite?
16:34:33 <kmc> @oeis 1,11,21,1211,111221,312211
16:34:34 <lambdabot>  Look and Say sequence: describe the previous term! (method A - initial term ...
16:34:34 <lambdabot>  [1,11,21,1211,111221,312211,13112221,1113213211,31131211131221,1321131112311...
16:34:40 <kmc> Veinor, it's not infinite, it's the chorus of the song
16:34:43 <kmc> they say it a bunch of times
16:34:50 <Veinor> yeah, but it's not marked as finite in the oeis
16:34:54 <kmc> oh
16:34:56 <fax>  Jenny, Jenny who can I turn to?
16:34:56 <fax> You give me something I can hold on to.
16:34:56 <fax> I know you'll think I'm like the others before
16:34:56 <fax> Who saw your name and number on the wall.
16:34:58 <idnar> I guess once you sing it, you start over again
16:35:28 <Aristid> @oeis 1,6,34,53,1,9,17
16:35:28 <lambdabot>  Sequence not found.
16:35:37 <Veinor> @oeis 1,2,3,7,11
16:35:38 <lambdabot>  Heegner numbers: imaginary quadratic fields with unique factorization (or cl...
16:35:38 <lambdabot>  [1,2,3,7,11,19,43,67,163]
16:36:07 <Aristid> @oeis 2,3,5,7,11
16:36:08 <lambdabot>  The prime numbers.
16:36:08 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
16:36:29 <kmc> @oeis 6,21,107
16:36:30 <lambdabot>  Busy Beaver problem: maximal number of steps that an n-state Turing machine ...
16:36:30 <lambdabot>  [1,6,21,107]
16:36:44 <Veinor> that's a great sequence
16:36:45 <kmc> the next value is not known but is at least 47 million
16:36:49 <idnar> heh
16:37:01 <Veinor> 1, 6, 21, 107, whatthefuck
16:37:07 <Veinor> also http://en.wikipedia.org/wiki/Kruskal's_theorem
16:37:07 <stevenmarky_> lol
16:37:21 <fax> haha
16:37:32 <Veinor> 1, 3, oh god what
16:37:35 <benmachine> > 3 ^ 27
16:37:36 <lambdabot>   7625597484987
16:37:44 <pkrumins> busy beaver!
16:37:44 <benmachine> @oeis 1,4,7625597484987
16:37:45 <lambdabot>  a(n) = n^n^n^...^n (with n n's).
16:37:45 <lambdabot>  [1,4,7625597484987]
16:38:00 <benmachine> > 4 ^ 4 ^ 4 ^ 4
16:38:05 <lambdabot>   mueval: ExitFailure 1
16:38:06 <benmachine> :(
16:38:08 <kmc> > iterate (2^) 1
16:38:09 <lambdabot>   [1,2,4,16,65536,20035299304068464649790723515602557504478254755697514192650...
16:38:16 <benmachine> heehee
16:38:17 <kmc> @. oeis run iterate (2^) 1
16:38:19 <lambdabot>  Sequence not found.
16:39:14 <kmc> > let fact = product . enumFromTo 2 in iterate fact 3
16:39:15 <lambdabot>   [3,6,720,260121894356579510020490322708104361119152187501694578572754183785...
16:40:28 <kmc> @quote undoubtedly
16:40:29 <lambdabot> _pizza_ says: i think Haskell is undoubtedly the world's best programming language for discovering the first few dozen numbers in the Fibonacci sequence over IRC
16:41:26 <lispy|web> heh
16:41:55 <lispy|web> > [1,3..] -- or the odd numbers!
16:41:56 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
16:42:19 <kmc> so is there any difference between unsafeCoerce and unsafeCoerce# ?
16:42:32 <benmachine> unsafeCoerce# works on unboxed values I think?
16:42:34 <benmachine> or something
16:42:53 <SamB_XP> :t unsafeCoerce
16:42:54 <lambdabot> Not in scope: `unsafeCoerce'
16:42:58 <SamB_XP> :t Foreign.unsafeCoerce
16:42:59 <lambdabot> Not in scope: `Foreign.unsafeCoerce'
16:43:05 <SamB_XP> :t Unsafe.unsafeCoerce
16:43:06 <lambdabot> Couldn't find qualified module.
16:43:09 <SamB_XP> :t Data.Unsafe.unsafeCoerce
16:43:10 <lambdabot> Couldn't find qualified module.
16:43:10 <benmachine> :t Unsafe.Coerce.unsafeCoerce
16:43:11 <lambdabot> forall a b. a -> b
16:43:27 <SamB_XP> :t GHC.Prim.unsafeCoerce#
16:43:28 <lambdabot> forall t b. t -> b
16:43:32 <SamB_XP> :k GHC.Prim.unsafeCoerce#
16:43:33 <lambdabot> parse error on input `GHC.Prim.unsafeCoerce#'
16:43:40 <SamB_XP> hmm.
16:43:48 <SamB_XP> it doesn't SHOW any kinds :-(
16:43:58 <SamB_XP> and there's no way to ASK for them :-(
16:44:07 <kmc> ah, it does
16:44:17 <kmc> well, a value does not have a kind
16:44:20 <kmc> :k (->)
16:44:21 <lambdabot> ?? -> ? -> *
16:44:34 <kmc> but not all functions actually accept types of those kinds
16:44:41 <kmc> and i'm not sure how that's described
16:44:57 <idnar> kmc: :t shows you some types, but there's no way to ask for the kinds of those types
16:45:00 <kmc> in some sense ? and ?? are polymorphic kinds which are instantiated when (->) is applied
16:45:18 <kmc> ah
16:45:32 <kmc> so you'd want it to say e.g.  forall (a :: *) (b :: *). a -> b
16:45:33 <kmc> that's fair
16:45:43 <kmc> it does say that sometimes, when the kind is not *
16:45:49 <SamB_XP> hmm
16:45:52 <kmc> but apparently it does not distinguish between * # ? ??
16:46:03 <SamB_XP> :t (#,#)
16:46:04 <lambdabot> forall t t1. t -> t1 -> (# t, t1 #)
16:46:17 <SamB_XP> kmc: I guess :-(
16:46:37 <SamB_XP> because I *know* the kind of that type I just typed
16:46:55 <SamB_XP> @. kind type (#,#)
16:46:57 <lambdabot> *
16:46:59 <SamB_XP> okay
16:47:08 <SamB_XP> @. kind type (#,#) a b
16:47:09 <lambdabot> (#)
16:47:19 <SamB_XP> @. (#,#)
16:47:19 <lambdabot> Not enough arguments to @.
16:47:23 <SamB_XP> :k (#,#)
16:47:24 <lambdabot> ? -> ? -> (#)
16:48:03 <lispy|web> :k unsafeCoerce#
16:48:04 <lambdabot> Not in scope: type variable `unsafeCoerce#'
16:48:14 <lispy|web> :k GHC.Prim.unsafeCoerce#
16:48:16 <lambdabot> parse error on input `GHC.Prim.unsafeCoerce#'
16:48:27 <lispy|web> oh, duh, you tried that
16:48:32 * lispy|web is slow
16:48:39 <ben_m> Baaah
16:48:48 <kmc> yeah, so unsafeCoerce# can indeed coerce unboxed arguments
16:49:02 <benmachine> unsafeCoerce can't?
16:49:05 <kmc> but this is not indicated very well in its type
16:49:07 <kmc> correctc
16:49:12 <kmc> unsafeCoerce is a regular polymorphic function
16:49:18 <kmc> and type variables can't be instantiated to unboxed types
16:49:27 <kmc> unsafeCoerce# is more primitive and magic and so is free of this restriction
16:50:15 <kmc> however you will get a type error with "unsafeCoerce# (3# :: Int#) :: Int#" in ghc
16:50:16 <kmc> ghci*
16:50:45 <kmc> because "print" can't take an unboxed argument
16:50:49 <kmc> (for the same reason)
16:53:06 <SamB_XP> kmc: GHCi can handle unboxed stuff now ?
16:53:09 <benmachine> segmentation fault
16:53:12 <benmachine> whee
16:53:22 <ben_m> It's hard to abuse the do-notation for a DSL
16:53:24 <ben_m> :/
16:53:24 <benmachine> kmc: it tries to print it like anything else and fails
16:53:43 <SamB_XP> benmachine: you mean it segfaulted or type-errored?
16:53:52 <benmachine> SamB_XP: both? :P
16:53:59 <SamB_XP> and you did do the :: Int#, right ?
16:54:09 <benmachine> no I did something else
16:54:11 <kmc> right
16:54:12 <SamB_XP> oh
16:54:19 <SamB_XP> what did you do ?
16:54:27 <benmachine> something segfaulty >_>
16:54:28 <kmc> if you just type "0#" at GHCi it will fail at "print"
16:54:33 <kmc> but you can do "case 0# of x -> I# x"
16:55:18 <benmachine> or I# 0#
16:55:20 <benmachine> -> 0
16:56:30 <ben_m> bah screw this!
16:56:58 <ben_m> [Forward 10, Right 90, Forward 10] isn't bad either
16:57:01 <ben_m> >_<
16:57:08 <fax> that looks good to me
16:57:16 <fax> though I would use FD and RT
16:57:22 <ben_m> The DSL would've been interesting, but I have no idea how to do it.
16:57:28 <fax> and I might use something more interesting than lists
16:57:34 <fax> like maybe you could have loops and stuff in there
16:57:39 <ben_m> I would have to somehow make (>>) behave like I want it to
16:57:42 <fax> rather than just sequencing
16:57:48 <benmachine> ben_m: with -XNoImplicitPrelude you can give >> whatever type you like, I think
16:57:50 <fax> but then again, ambye the list IS the result of a calculation
16:58:04 <ben_m> benmachine: That might mess with other people's code though, no?
16:58:04 <benmachine> ben_m: not recommended unless you are crazy :P
16:58:11 <benmachine> I don't think so
16:58:14 <ben_m> I want to release this as some kind of library
16:58:18 <benmachine> oh
16:58:24 <benmachine> if they import it then that would be a problem yes
16:58:27 <ben_m> yeah.
16:59:32 <ben_m> I could look how the State monad is implemented
16:59:50 <ben_m> and do a similar thing
16:59:58 <ben_m> Without returning a tuple
17:00:05 <ben_m> thing.
17:01:51 <benmachine> or Writer
17:01:57 <pastorn> hello in here
17:02:09 <benmachine> in fact Writer the work's already done for you
17:02:13 <ben_m> hmm
17:02:15 <benmachine> maybe
17:02:18 <benmachine> sorta
17:02:29 <benmachine> Writer [Command] ()
17:02:31 <pastorn> i'm gonna try askingagain :)
17:02:35 <benmachine> then put tells everywhere
17:02:38 <pastorn> if i wanna run a daemon
17:02:44 <pastorn> and send haskell commands to it from ghci
17:02:47 <pastorn> is that possible?
17:02:53 <pastorn> @faq can haskell do that?
17:02:53 <lambdabot> The answer is: Yes! Haskell can do that.
17:03:04 <benmachine> pastorn: do you start the daemon from ghci or what?
17:03:10 <SamB_XP> why from ghci?
17:03:16 <pastorn> benmachine: yes, i won't mind doing that
17:03:24 <pastorn> but i want my daemon to survive :r
17:03:30 <pastorn> SamB_XP: livecoding stuff
17:03:31 <benmachine> pastorn: but I mean, the same ghci session that you send commands from
17:03:39 <benmachine> (run ghci in screen?)
17:03:40 <kmc> pastorn, you can evaluate Haskell strings with mueval or hint
17:04:01 <pastorn> benmachine: yes, same session, but with ':r' in between :)
17:04:14 <benmachine> pastorn: oh, I don't know how to do that
17:04:24 <benmachine> except with generic methods
17:04:33 <pastorn> hmm...
17:04:39 <SamB_XP> what are "generic methods"?
17:04:48 <SamB_XP> are they related to "generic programming"?
17:05:08 <pastorn> benmachine: do you mean stuff like importing a haskell code evaluator?
17:05:40 <benmachine> pastorn: if the commands were serialisable you could just use normal IPC
17:05:53 <benmachine> but I'm guessing they're not, so yeah you're going to need some kind of dynamic loading
17:06:15 <pastorn> benmachine: i was thinking of something along the lines of fluxus
17:06:48 <pastorn> like... i'd tell the server to create a window, then i'd use gl-ish commands to create stuff inside that window and add effects and what not
17:06:58 <kmc> can't that be done just within one ghci session
17:07:08 <kmc> spawning threads so stuff continues to render while you interact
17:07:23 <benmachine> you can do that but persistence might be tricky
17:07:38 <pastorn> kmc: maybe my stuff will be to long, so i need a source file to write them
17:08:13 <kmc> i think you should use Hint or GHC API directly
17:08:25 <pastorn> so i can write stuff in my source, reload my file (without having the server going belly up) and then run my new functions
17:08:58 <ben_m> forward :: Writer [TurtleState] () -> Float -> [TurtleState] -- if Float is the amount to go forward, does that look correct?
17:09:38 <pastorn> ben_m: no, you should end in a Writer (just guessing here)
17:09:42 <ben_m> ah
17:09:53 <kmc> Float -> Writer [TurtleState] ()
17:09:57 <pastorn> ben_m: you want your monadic stuff to look like this:
17:10:11 <pastorn> myMonadComp :: a  -> b -> c -> myMonad d
17:10:17 <kmc> not always
17:10:24 <kmc> you can do powerful stuff by taking monadic actions as args
17:10:32 <pastorn> kmc: true
17:10:56 <pastorn> is GOA a useful package for this?
17:10:59 <ben_m> i am confused :D
17:11:01 <kmc> it's what makes Haskell a good imperative language
17:11:03 <pastorn> or will i have to hack on GHC?
17:11:06 <pastorn> *GHCI*
17:11:16 <kmc> pastorn, you don't have to hack GHCi, you can talk to the GHC API directly
17:11:23 <kmc> or go through Hint, which is a simpler wrapper on it
17:11:37 <Axman6> why not just make your daemon a proper daemon, and connect to it via TCP or something?
17:12:02 <pastorn> Axman6: i want to send haskell expressions to it
17:12:19 <Axman6> then serialise them, and send them over the connection
17:12:22 <kmc> once you're hooking in at the level of hint, you can receive expressions as strings
17:12:28 <pastorn> Axman6: and i don't feel like writing an instance of Storeable for 'a'
17:12:49 <Axman6> no need for storable, use something nice like Binary or Cereal
17:13:19 <pastorn> Axman6: still, then i'd have to express all possible commands in beforehand
17:13:33 <pastorn> Axman6: i just want to be able to run f :: IO a
17:13:37 <pastorn> on my daemon
17:13:39 <Axman6> what sort of commands do you want?
17:13:48 <pastorn> Axman6: OpenGL stuff
17:14:09 <pastorn> http://www.youtube.com/watch?v=2O5DJTOy6EA
17:14:13 <Axman6> make an ADT that represent the commands you want to send
17:14:21 <pastorn> jump in maybe 2 minutes into that video
17:14:39 <pastorn> Axman6: that's kinda low in expressiveness :/
17:20:10 <jmcarthur> pastorn: doing some live coding?
17:20:18 <pastorn> jmcarthur: i want to
17:20:24 <jmcarthur> that would be pretty sweet
17:20:34 <pastorn> jmcarthur: yeah
17:20:53 <pastorn> where can i look at the GHC API?
17:21:12 <aavogt> don't look if there is some other way
17:21:19 <fax> live coding in haskell???
17:21:27 <pastorn> fax: it has been done
17:21:37 <fax> how can you do live coding without SLIME
17:21:47 <SamB_XP> or SmallTalk or something!
17:22:26 <pastorn> http://vimeo.com/6727278 <-- livecoded haskell
17:22:47 <pastorn> but that goes through a server/daemon, with an api
17:24:18 <pastorn> @hoogle Chan
17:24:19 <lambdabot> module Control.Concurrent.Chan
17:24:19 <lambdabot> Control.Concurrent.Chan data Chan a
17:24:19 <lambdabot> Control.Concurrent.Chan dupChan :: Chan a -> IO (Chan a)
17:27:33 <pastorn> haskell is too pure :/
17:27:50 <jmcarthur> huh?
17:28:22 <Jafet> @quote oasis
17:28:22 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
17:28:25 <pastorn> heh... in erlang you can reload code without killing running processes
17:28:49 <pastorn> and python (iirc)
17:28:49 <jmcarthur> erlang also lacks certain kinds of type safety precisely for that purpose
17:28:57 <kmc> which?
17:30:15 <ben_m> woosh!
17:30:17 <jmcarthur> kmc: you can send and receive arbitrary kinds of messages, there is no guarantee that process X knows how to handle message Y that you just changed process Z to send to process X
17:30:18 <ben_m> State Monad ftw!
17:30:22 <pastorn> haha
17:30:29 <pastorn> ben_m: what are you working on?
17:30:31 <jmcarthur> which is by design
17:30:36 <ben_m> pastorn: Turtle Graphics lib
17:31:07 <jmcarthur> you can go ahead and make sure Z is doing what you expect before you bother making X handle it properly
17:31:11 <pastorn> kmc: if an erlang function doesn't know what to do with a certain message nothing happends
17:31:39 <pastorn> kmc: you should watch ERLANG - THE MOVIE
17:31:42 <pastorn> <3 <3 <3
17:31:58 <Sgeo_> Here's a useless, but perhaps fun, thought: If IO a were, in fact, an instance of Eq, could we define notBottom in terms of it, and if so, how?
17:32:10 <Jafet> From your previous comment I would guess Silent Hill
17:32:11 <jmcarthur> huh?
17:32:21 <ben_m> http://sprunge.us/LcWV -- My Turtle Graphics DSL
17:32:47 <jmcarthur> Sgeo_: in what sense can to IO actions be equal?
17:32:51 <jmcarthur> *two
17:33:00 <Sgeo_> jmcarthur, there was a discussion about this earlier: If they do the same thign
17:33:02 <Sgeo_> *thing
17:33:10 <Sgeo_> ioBottom :: IO a
17:33:11 <jmcarthur> Sgeo_: "do"?
17:33:14 <pastorn> ben_m: looked at the chalmers Advanced FP lab much?
17:33:15 <ben_m> I hate that you can't do multiline do in ghci :/
17:33:17 <Sgeo_> ioBottom = ioBottom
17:33:22 <ben_m> pastorn: Nope, what is it? :)
17:33:25 <jmcarthur> Sgeo_: what if you run the same IO action twice in a row? does it do the same thing?
17:33:28 <pastorn> seriously?
17:33:30 <ben_m> yes.
17:33:37 <ben_m> I fail, I know.
17:33:47 <Sgeo_> notBottom a = (return a) /= ioBottom
17:33:53 <pastorn> ben_m: http://www.cse.chalmers.se/edu/course/afp/assignments.html
17:34:30 <ben_m> ah! ;D
17:34:35 <pastorn> ben_m: be careful about using predefined monads... you might want to leave them "available" for the user of the library
17:34:56 <Sgeo_> jmcarthur, getLine == getLine. But yeah, it's impossible, as has been discussed earlier
17:34:56 <pastorn> ben_m: bet that's usually solved by not exporting your actual implementation of it :)
17:34:56 <jmcarthur> Sgeo_: further, if an IO action run twice does not do the same thing both times, is it still equal to itself?
17:34:58 <ben_m> hmm
17:35:16 <SamB_XP> pastorn: aww -- no [], Either, or Just then ?
17:35:27 <Sgeo_> Presumably, "If x it does y else it does z" is one thing
17:35:39 <aavogt> ben_m: you can do  :{ \n\n :}
17:35:40 <pastorn> ben_m: if your DSL makes use of StateT, then the user of your DSL can't if you're not hiding that fact
17:35:59 <ben_m> Just regular State
17:36:07 <pastorn> ben_m: still
17:36:07 <aavogt> but that doesn't make ghci look at layout
17:36:29 <ben_m> hmm
17:36:50 <aavogt> though you can write multiline blocks with explicit {;} that way
17:36:53 <pastorn> ben_m: do you understand the point i'm trying to make?
17:36:58 <ben_m> yeah
17:37:17 <jmcarthur> > () == undefined
17:37:18 <lambdabot>   * Exception: Prelude.undefined
17:37:19 <pastorn> ben_m: but yeah, you can hide that...
17:37:20 <jmcarthur> > undefined == ()
17:37:21 <lambdabot>   * Exception: Prelude.undefined
17:37:36 <pastorn> ben_m: another thing you might want to do is to make your implementation deep
17:37:49 <jmcarthur> Sgeo_: ^^   return == _|_  is just going to be _|_
17:38:01 <kmc> i'd assume getLine == getLine even if you'd get two different lines
17:38:03 <jmcarthur> *return x == _|_
17:38:05 <pastorn> ben_m: lecture 2 and 3 covers that :) http://www.cse.chalmers.se/edu/course/afp/lectures.html
17:38:05 <kmc> you're comparing recipes, not results
17:38:10 <kmc> (the latter is liftM2 (==))
17:38:17 <pastorn> (stay away from lecture 1, it's pretty much all brainfuck)
17:38:25 <Eelis> glguy_: did you receive my pull request on github for the tiny utf8-string patch?
17:38:34 <jmcarthur> kmc: true, but even so it seems about the same as comparing functions
17:38:42 <kmc> i don't think it's crazy to compare functions either
17:38:45 <ben_m> pastorn: do those lectures make sense with just the slides?
17:38:50 <kmc> but your comparison will probably have to be pretty conservative
17:38:50 <jmcarthur> some functions, sure
17:38:54 <Sgeo_> pastorn, Brainfuck how?
17:39:04 <Sgeo_> Does it involve making a brainfuck interpreter? :/
17:39:06 <kmc> you can consider intensional equality for functions
17:39:40 <kmc> hmm, GHC manual says that the syntax "%varid" is stolen by -XImplicitParams
17:39:46 <kmc> i can't find anything on that in the relevant section of ch. 7
17:39:57 <pastorn> Sgeo_: Functional reactive programming, sort of...
17:39:58 <kmc> anyone know what that syntax means?
17:40:04 <aavogt> kmc: there was an extension besides the current implicit params
17:40:18 <aavogt> search the lists for some implicit parameters that got removed from ghc
17:40:18 <Cale> It's a linear implicit parameter
17:40:23 <Jafet> Hahaha (pastorn) "We also look at a first simple example of a domain specific embedded language."
17:40:59 <pastorn> Jafet: i did the course a year ago... i was like "WTF MAN?!?"
17:41:05 <Cale> Basically, if you think of normal implicit parameters as a kind of implicit reader monad, then linear implicit parameters are a sort of implicit state monad.
17:41:12 <Cale> They were removed.
17:41:14 <pastorn> *starting* with FRP is just nasty
17:42:12 <aavogt> pastorn: like interact?
17:43:35 <pastorn> i heard about some of the best stuff ever happening this year in the course... lecture 4 would be the first lecture after introducing monads, so one of the students asked the substitute teacher if he could repeat a little from last lecture. After about five seconds of thinking: "no".
17:44:03 <ezyang> pastorn: >.>
17:44:09 <ezyang> I can't decide if that was a good or bad choice.
17:44:15 <Jafet> What took him so long to decide
17:44:35 <Jafet> Maybe five milliseconds per internet tutorial
17:44:46 <pastorn> then he blazed through parsing monads (going from a shallow (String -> Maybe (a,String)) to a deep, fast implementation in 2 hours
17:44:51 <pastorn> (via GADTs)
17:44:57 <kmc> Cale, cool
17:45:30 <kmc> they take their haskell seriously at chalmers don't they
17:45:41 <pastorn> yup
17:45:51 <pastorn> well
17:45:58 <pastorn> most of the kids at CS hate it
17:46:08 <pastorn> cause when you start at CS you start with haskell
17:46:22 <pastorn> and half don't even know what a type is when they get there
17:46:28 <Sgeo_> Yeah, so my notBottom fails
17:48:43 <kmc> so they hate learning something new? :/
17:49:25 <aavogt> @hackage ChasingBottoms
17:49:25 <lambdabot> http://hackage.haskell.org/package/ChasingBottoms
17:49:40 <fax> if you get given too much in too short time you might not really learn anything
17:49:44 <fax> just get overwhelmed
17:49:52 <fax> I can't imagine that being a very nice experience
17:50:22 * Sgeo_ was about to gibber, but I guess not
17:50:30 <Sgeo_> Too bad it doesn't have halts
17:50:36 <Sgeo_> halts :: a -> Bool
17:50:41 <Sgeo_> ;)
17:50:49 <fax> halts _ = True
17:51:02 <SamB_XP> couldn't they just start the normal people on Java, and the ones who roll their eyes on Haskell/
17:51:06 <aavogt> haha, laziness
17:51:08 <SamB_XP> s|/|?|
17:52:16 <Saizan> @remember SamB_XP couldn't they just start the normal people on Java, and the ones who roll their eyes on Haskell?
17:52:16 <lambdabot> It is forever etched in my memory.
17:52:36 <Saizan> that'd be awesome.
17:53:24 <SamB_XP> that way, the Java people would just see Haskell as "advanced" rather than as "a total PITA"
17:53:26 <aavogt> #haskell would be a homework channel then
17:53:43 <SamB_XP> I meant roll their eyes WRT how dull and ordinary Java is
17:54:43 <pastorn> kmc: don't you remember how it was to start with haskell
17:54:58 <pastorn> kmc: all that happend was that GHCI was screaming at you for being stupid
17:55:17 <jmcarthur> i actually did not use GHCI much when learning haskell
17:55:26 <jmcarthur> i mostly worked with source files and GHC
17:55:31 <SamB_XP> huh
17:55:37 <SamB_XP> I would have used ghci then
17:55:40 <pastorn> jmcarthur: did you know any other programming languages before that?
17:55:44 <jmcarthur> yes
17:55:47 <SamB_XP> just so's I could look at my types easier
17:55:50 <kmc> it'd be a terrible idea to track the "normals" away from good languages
17:56:01 <Saizan> i followed a ~4 hours lecture on how concepts didn't got accepted on C++, we were all like "JUST USE A DAMN TYPECHECKER!!!" while they described the pitfalls of templates
17:56:16 <jmcarthur> SamB_XP: i did use ghci as a type checker for my source files a lot, i guess. i just used :r constantly
17:56:23 <SamB_XP> kmc: I just figure exposing them to such fast-paced material is bad for their perception of Haskell
17:56:31 <Cale> Saizan: We don't want C++ to be better though ;)
17:56:39 <jmcarthur> SamB_XP: but i rarely ran code from it or typed expressions of any sort in it
17:56:40 <fax> hehe Cale is rigt
17:56:40 <kmc> perhaps both groups should learn Haskell, but in different ways
17:56:41 <Cale> I say let it die
17:56:42 <ben_m> pastorn: When you recommended those lectures, did you mean just reading the slides?
17:56:43 <fax> right
17:56:51 <fax> I like that thinking
17:56:57 <pastorn> jmcarthur: then you used ghci
17:57:08 <jmcarthur> pastorn: but not for what most newbies use it for
17:57:13 <pastorn> ben_m: no, look at the code
17:57:15 <jmcarthur> in my observations, anyway
17:57:16 <kmc> the whole problem here is that ancient fundamental ideas like first-class functions are seen as advanced techniques
17:57:17 <ben_m> ah :)
17:57:21 <SamB_XP> kmc: well, I figure the normals will then feel like learning Haskell later
17:57:25 <pastorn> ben_m: compare XDeep.hs and XShallow.hs
17:57:26 <SamB_XP> once they have a clue what a type is
17:57:27 <jmcarthur> kmc: yeah :(
17:57:33 <kmc> SamB_XP, nah, especially if they're in it to get a job
17:57:37 <SamB_XP> hmm
17:57:37 <kmc> then they'll stick with Java and C#
17:57:51 <SamB_XP> well, okay, so they get to do Haskell laters
17:57:52 <SamB_XP> fine
17:58:07 <lispy|web> What is a type?
17:58:08 <pastorn> speaking about java...
17:58:10 <kmc> and it will always make business sense to do lots of programming in Java and C#
17:58:19 <pastorn> that language *really* need higher order functions
17:58:22 <kmc> because they allow you to hire lots of not especially good programmers to do boring work
17:58:26 <Saizan> Cale: yeah, but it's kind of like being stuck watching an horror movie and screaming to the protagonist "DO NOT OPEN THAT DOOR!"
17:58:31 <SamB_XP> pastorn: switch to C#, maybe ;-P
17:58:42 <pastorn> SamB_XP: not as portable
17:58:55 <kmc> they limit the amount of damage a bad programmer can do, and they limit the amount of clever code a good programmer can write (and not be understood by his colleagues)
17:58:59 <pastorn> SamB_XP: C# won't run on android
17:59:02 <SamB_XP> pastorn: so sue novell!
17:59:09 <kmc> so implement a C# to JVM compiler
17:59:14 <pastorn> haha
17:59:28 <jmcarthur> pastorn: but you can just wrap a function in an object and call it a delegate, so why bother with this higher order function crap. </faux stubborn java programmer>
17:59:28 <pastorn> kmc: i'd rather look into a clojure => java compiler
17:59:33 <kmc> err
17:59:35 <SamB_XP> androids don't run CLR anyway, do they ?
17:59:38 <kmc> isn't that how clojure is usually implemented?
17:59:45 <kmc> oh you mean Java not JVM?
17:59:52 <jmcarthur> ew
17:59:52 <kmc> yeah, because Android uses a nonstandard VM
17:59:59 <kmc> but perhaps you can translate JVM to android's VM directly
18:00:00 <pastorn> jmcarthur: yeah
18:00:01 <jmcarthur> the worst thing about the jvm is java
18:00:05 <SamB_XP> kmc: yeah
18:00:07 <kmc> haha jmcarthur
18:00:10 <SamB_XP> that's my understanding
18:00:14 <kmc> @remember jmcarthur the worst thing about the jvm is java
18:00:14 <lambdabot> Good to know.
18:00:19 <jmcarthur> heh
18:00:24 <kmc> it also can't do tail calls...
18:00:24 <pastorn> .clj ==> .java ==> weird android bytecode
18:00:29 <kmc> because that's another SUPER ADVANCED TECHNIQUE
18:00:32 <jmcarthur> yeah that kind of sucks
18:00:34 <pastorn> jmcarthur: hee
18:00:43 <lispy|web> kmc: no, that's not why
18:00:46 <kmc> clj?
18:00:49 <jmcarthur> kmc is channeling guido
18:00:49 <SamB_XP> but maybe you can write a CLR to Android-VM translator, too?
18:00:50 <lispy|web> kmc: and soon the JVM will support tail call
18:00:52 <kmc> oh clojure
18:01:01 <kmc> should i learn clojure?
18:01:14 <dobblego> lispy, the IBM JVM always did and the Sun JVM never will
18:01:18 <ezyang> kmc: "why not?"
18:01:26 <SamB_XP> dobblego: hmm?
18:01:29 <lispy|web> kmc: traditionally, tail call made it so that the JVM security model didn't work.  But, I guess these days they have a solution and soon the JVM will do the tail call stuff
18:01:30 <pastorn> kmc: if you're stuck in a java project, then yes :)
18:01:38 <SamB_XP> why not with JVM option?
18:01:40 <dobblego> SamB_XP, support tail calls
18:01:47 <SamB_XP> I don't see any difficulty
18:01:59 <SamB_XP> the only thing is that it makes debugging ... interesting
18:02:13 <dobblego> feel free to read the RFE from 2001
18:02:15 <jmcarthur> okay, show of hands, who here actually uses debuggers?
18:02:19 <lispy|web> SamB_XP: not just debugging.  Also the security model was harder
18:02:31 <lispy|web> jmcarthur: I've used gdb with haskell to find bugs
18:02:33 <SamB_XP> jmcarthur: I meant because the tracebacks are missing some frames, actually
18:02:38 * pastorn keeps his hands down
18:02:39 <SamB_XP> and I do use debuggers sometimes
18:02:46 <kmc> lispy|web, but it's clearly not fundamentally impossible to make a safe system with tail calls
18:02:47 <jmcarthur> and don't be afraid that i'm going to claim people who use debuggers are dumb or something. i don't think that
18:02:51 <SamB_XP> I just don't like sucky ones like the GHCi debugger
18:02:57 <lispy|web> and I used gdb with evolution (the mail client) because it makes it crash less frequently :(
18:02:58 <ddarius> SamB_XP: http://www.lambdacs.com/debugger/
18:03:04 <kmc> they'd have put more effort in if more people used recursion
18:03:12 <kmc> which is another super advanced technique, apparently
18:03:27 <ddarius> jmcarthur: It wouldn't matter if you did.
18:03:31 <jmcarthur> i really don't use debuggers. i used to, but then realized that i could find bugs just as quickly without them
18:03:32 <SamB_XP> how do tailcalls make security harder?
18:03:36 <aavogt> sounds like a chicken-egg situation
18:03:40 <jmcarthur> but maybe i just suck at using debuggers
18:03:45 <SamB_XP> [CITATION-NEEDED]
18:03:54 <SamB_XP> aavogt: at least there's another chicken vendor ;-)
18:04:04 <ddarius> SamB_XP: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.69.3133&rep=rep1&type=pdf
18:04:10 <lispy|web> SamB_XP: I don't know the gory details, but I looked into it once and the reason for no tail call had to do with verifying bytecode
18:04:19 <SamB_XP> ddarius: you COULD just link me to the HTML page
18:04:38 <ddarius> SamB_XP: I could also put out less effort.
18:04:42 <Saizan> ddarius: you should link the page rather than the pdf, so i can read the abstract!
18:05:09 <aavogt> the abstract comes with the pdf
18:05:27 <ddarius> The abstract also doesn't have the information that is relevant.
18:05:35 <glguy_> Eelis: no, I haven't done that yet
18:05:36 <jmcarthur> also so that my browser can change the pdf link to a google docs version
18:06:35 <SamB_XP> heh, googles second hit for citeseerx.ist.psu.edu is an article about pagerank ;-P
18:06:43 <jmcarthur> ha
18:07:18 <SamB_XP> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.69.3133
18:07:56 <SamB_XP> (That google hit WAS useful -- I pasted the citeseer-mangled doi for this article over the one that was in its URL ;-)
18:08:47 <fax> > let q a b c = drop 20 $ iterate ((-b/a)+).((-c/a)/) 1 in q 1 (-1) (-1)
18:08:48 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
18:09:06 <fax> does anyon know what I did wrong?
18:09:25 <fax> > let q a b c = drop 20 $ iterate (((-b/a)+).((-c/a)/)) 1 in q 1 (-1) (-1)
18:09:26 <lambdabot>   [1.618033985017358,1.6180339901755971,1.6180339882053252,1.6180339889579018...
18:09:30 <fax> ah that's it
18:09:49 <fax> > let q a b c = drop 20 $ iterate (((-b/a)+).((-c/a)/)) 1 ; x = q 7 8 4 ; 7*x^2+8*x+4
18:09:50 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
18:09:55 <fax> > let q a b c = drop 20 $ iterate (((-b/a)+).((-c/a)/)) 1 ; x = q 7 8 4 in 7*x^2+8*x+4
18:09:56 <lambdabot>   No instance for (GHC.Num.Num [t])
18:09:56 <lambdabot>    arising from the literal `7' at <inter...
18:09:59 <fax> :/
18:10:51 <fax> > let q a b c = drop 20 $ iterate (((-b/a)+).((-c/a)/)) 1 ; x = head $ q 7 8 4 in 7*x^2+8*x+4
18:10:52 <lambdabot>   1.7634549417979235
18:11:01 <fax> that should be 0 is my formula wrong O_o
18:11:08 <fax> it worked on 1 (-1) 1
18:11:42 <Saizan> ~1.77, could be a rounding error
18:11:49 <fax> hehe really?? it seem huge
18:11:57 <fax> the rounding errors I got before were like e-14
18:11:59 <Saizan> no :)
18:12:04 <fax> okay phew
18:12:16 <fax> I guess this formula is divergent on some cases
18:12:57 <fax> > let q a b c = drop 20 $ iterate (((-b/a)+).((-c/a)/)) 1 ; x = head $ q 1 (-5) 6 in x^2-5*x+6
18:12:58 <lambdabot>   6.021814747132481e-4
18:13:03 <fax> see it worked thre
18:13:04 <solrize> i ran "cabal install hexpat" earlier today and the online example didn't compile... looks like the current version is 0.12 but cabal installed 0.10 ... does that mean i should upgrade ghc or something?  i'm using 6.10.4 i think
18:13:08 <fax> but why did it pick 3 rather than 2?
18:13:51 <Eelis> glguy_: oh, i wasn't asking if you'd looked at it, but merely if the request made it through :)  this github stuff is still new to me and i'm unsure whether it all works the way i imagine it does :)
18:14:02 <Saizan> solrize: did you cabal update first?
18:14:09 <solrize> no
18:14:12 <glguy_> oh, ha. yeah, I got two requests in my inbox :)
18:14:12 <solrize> should i do that?
18:14:24 <kmc> i've written a program... how can i determine which cabal packages it depends on?
18:14:25 <fax> I wish there was an easy way to multiply polynomials in ahskell
18:14:26 <solrize> updating
18:14:26 <Saizan> it might help
18:14:28 <Eelis> glguy_: ah, ok :)
18:14:30 <kmc> suppose i am lazy or forgetful of what i've installed ;)
18:14:41 <solrize> it's been a month or two since i used cabal for anything else
18:15:07 <solrize> wants me to re-download cabal-install, heh
18:15:11 <solrize> installing
18:15:14 <Saizan> kmc: no supported way
18:15:18 <kmc> :(
18:15:25 <kmc> can i check if my list is complete?
18:15:35 <aavogt> kmc: load it with -hide-all-packages and see what it complains about
18:15:45 <Saizan> if you get to run "cabal install" and it builds it'll be complete
18:16:14 <Saizan> since cabal uses -hide-all-packages and then adds a -package foo for every package listed in build-depends
18:16:27 <aavogt> Saizan: is there a feature request for cabal to guess dependencies?
18:16:28 <fax> > drop 20 $ iterate (\x -> 0 + 1 /( 1 + 1 /( x ) )) 1
18:16:28 <lambdabot>   [4.7619047619047616e-2,4.5454545454545456e-2,4.3478260869565216e-2,4.166666...
18:16:39 <aavogt> for adding to .cabal files
18:17:18 <Saizan> aavogt: no idea, my own build system could do that
18:17:21 <solrize> erm, cabal update just says "downloading latest package list..." but then doesn't upgrade anything
18:17:33 <solrize> ah, cabal upgrade
18:17:40 <jmcarthur> which is bad
18:17:42 <Saizan> don't run cabal upgrade.
18:17:46 <idnar> I think cabal upgrade breaks your system
18:17:49 <solrize> oh great
18:17:53 <kmc> aavogt, thanks, works well enough
18:17:54 <Saizan> just run cabal install hexpat again
18:17:56 <jmcarthur> in later versions it just says that was bad
18:18:10 <solrize> i had already run it, and it said couldn't upgrade b/c of dependencies
18:18:11 <jmcarthur> and conveniently lists the packages it *would* have upgraded
18:18:28 <solrize> ok, cabal install hexpat is getting the new version
18:20:36 <fax> does anyone happen to know which infinity this is?
18:20:44 <solrize> works!  thanks
18:20:46 <fax> we defined 0 as 0 + 1 /( 1 + 1 /(x))
18:20:50 <fax> which is 0 + 1/infinity
18:20:59 <fax> but I was wondering what value that infinity takes?
18:22:01 <Saizan> x?
18:22:44 <fax> not x
18:22:46 <fax> um
18:23:01 <fax> x = 0 + 1 / y ; y = 1 + 1 / x
18:23:16 <fax> in this case x = 0 and y = infinity but I wonder which one it is
18:23:18 <ddarius> fax: Continued fractions are related to linear fractional transforms and certain selections of values for the coefficients of the linear fractional transform lead to "infinity".
18:23:51 <fax> im thinkign about divergent sums such as 1 + 2 + 3 + 4 + ... = -1/2
18:23:55 <fax> im thinkign about divergent sums such as 1 + 2 + 3 + 4 + ... = -1/12 **
18:24:12 <ddarius> fax: Read the "Gosper" sections of this: http://www.inwap.com/pdp10/hbaker/hakmem/cf.html
18:24:15 <fax> I assume that continued fraction will have a value (unless it'r harmonic)
18:24:22 <fax> okay
18:24:59 <fax> Y = [1, 1, 2, 1, 2, ...] = sqrt(3)
18:25:06 <fax> in haskell how might we do that?
18:25:11 <fax> even if it never terminates
18:25:29 <fax> something like    fraction (x:xs) = x + 1/fraction xs ?
18:26:02 <fax> that seems reasonable
18:27:17 <twink> fax: That's not how to do it. cf. http://en.wikipedia.org/wiki/Fundamental_recurrence_formulas
18:27:55 <fax> okay I guess it depends on if the thing has a,b,a,b,... or a,a,a,a,.. form?
18:28:48 <twink> fax: It's just covering the generalized case. The a's are all 1 for your purposes.
18:28:55 <fax> okay
18:28:57 <interferon> i have a module that imports Data.String.Utils from MissingH.  when I use cabal build to generate a binary, it compiles perfectly, but when i use ghc directly (e.g. runghc Blah.hs), it tells me that it can't find Data.String.Utils
18:29:22 <interferon> how can i fix this?  is it possible ghc doesn't know about my cabal libraries?  i recently updated the Haskell Platform and having been  having this problem since them
18:29:59 <fax> twink, it says 'simple continued fraction for pi has no obvious pattern, but there are generalized continued fractions with perfect structure'
18:30:09 <kiris> interferon: what program does 'ghc' refer to, is it an alias to an old version ghc ?
18:30:30 <kiris> interferon: ghc-pkg list, does that give a few lists for different ghc versions?
18:30:33 <interferon> kris: checked that, and it's the latest (i.e. 6.12)
18:30:39 <interferon> kris, yes
18:30:40 <Cale> interferon: Maybe -package MissingH ?
18:30:45 <Cale> interferon: Or --make
18:31:07 <interferon> Cale: it doesn't work with "-package"
18:31:12 <Saizan> kiris: "ghc-pkg list" won't ever list different ghc versions, each ghc-pkg is bound to a single ghc installation
18:31:16 <interferon> is it the differing versions in ghc-pkg list?
18:31:24 <kiris> Saizan: ah, good to know
18:31:32 <Saizan> interferon: are you using --make?
18:31:48 <interferon> no, just "runghc Main.hs"
18:31:55 <interferon> when i use "cabal build" all works perfectly
18:32:00 <kiris> ah
18:32:23 <Cale> What does it say with the additional -package argument?
18:32:31 <Cale> same thing?
18:32:51 <Cale> If you have different versions of that package installed, maybe try specifying which...
18:33:15 <Saizan> cabal by default search for "ghc" on the path, which usually is the same ghc runghc will use
18:33:20 <fax> http://en.wikipedia.org/wiki/Mathematical_constants_%28sorted_by_continued_fraction_representation%29
18:33:21 <Cale> I think you should be able to write  -package MissingH-1.1.0.3
18:33:27 <interferon> <command line>: cannot satisfy -package MissingH:
18:33:27 <interferon>     MissingH-1.1.0.3-ac90093b908873ecbcb397b0f0c47ca3 is unusable due to missing or recursive dependencies:
18:33:27 <interferon>       regex-compat-0.92-85e4505579f1e079262b19c2dd3f25dd
18:33:37 <Cale> okay
18:33:37 <Saizan> hah
18:33:42 <Cale> So that is your problem
18:33:43 <interferon> so i saw that
18:33:49 <interferon> and i tried reinstalling regex-compat
18:33:50 <Saizan> ghc-pkg check ?
18:33:58 <interferon> Saizan: that succeeds
18:34:04 <Saizan> no error?
18:34:06 <interferon> nope
18:34:19 <Saizan> can you paste ghc-pkg list on hpaste.org ?
18:34:24 <interferon> the package system is in some kind of netherstate
18:34:25 <interferon> sure
18:35:04 <interferon> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24678#a24678
18:35:07 <jmcarthur> man, literate programming is a lot slower than just programming
18:35:14 <fax> and a lot better!
18:35:18 <interferon> fax: :)
18:35:30 <jmcarthur> every time i try to make myself do it i get tired of it before i can reap the benefits
18:35:35 <kiris> proper literate knuth style programming or just writing big comments?
18:35:46 <Jafet> "Oh wow, so many consecutive > lines. Something must be wrong."
18:36:11 * hackagebot NaturalSort 0.2.1 - Natural sorting for strings  http://hackage.haskell.org/package/NaturalSort-0.2.1 (JoachimFasting)
18:36:15 <Saizan> interferon: you've the same version of regex-compat installed both in the global and user dbs, that's bad.
18:36:22 <Jafet> I believe Knuth invented it for Pascal.
18:36:30 <Saizan> interferon: you've to ghc-pkg unregister one of the two
18:36:33 <Jafet> Which isn't such an intuitive language either, actually
18:36:37 <jmcarthur> kiris: as far as i know, knuth style. describing not just how but why the code is the way it is in a form suitable for reading top to bottom
18:36:48 <Cale> You have two copies of regex-compat installed which are the same version
18:36:55 <Cale> ...right
18:37:09 <kiris> jmcarthur: well knuth style literally rewrites the code with macro-like magic ..
18:37:16 <Cale> Heh, was scrolled up and didn't see that Saizan already said that :)
18:37:18 <Saizan> interferon: same for regex-base and regex-posix
18:37:32 <shapr> What's the --constraint trick to install happstack stuff? --constraint='datetime==0.1' is not working for happstack-facebook
18:37:33 <kiris> jmcarthur: it merges documentation with code
18:37:35 <jmcarthur> kiris: sure, for languages which make it inconvenient to reorder things. it's a lot more convenient in haskell ;)
18:38:20 <Saizan> shapr: what error are you getting, --dry-run -v might give more info
18:38:54 <shapr> Saizan: It's the whole QuickCheck version confusion.
18:38:56 <interferon> Cale, Saizan: how can i identify these packages when they have the same name and the same version?
18:39:06 <interferon> Cale, Saizan: will unregister remove them both?
18:39:14 <bluetaslem> Hi.
18:39:18 <shapr> hi bluetaslem
18:39:35 <Saizan> shapr: ah, that might need sidestepping cabal-install actually, i didn't install happstack lately though
18:39:35 <Cale> I'm pretty sure it'll only get the user one without extra commandline args
18:39:44 <bluetaslem> I have a few questions about Haskell, I'm a total newbie.
18:39:48 <fax> hi
18:39:51 <fax> me too
18:39:57 <bluetaslem> A question I had..
18:40:02 <shapr> bluetaslem: How may we assist you?
18:40:03 <Cale> bluetaslem: Go right ahead, beginner questions are always welcome :)
18:40:05 <bluetaslem> How can you use graphics with Haskell?
18:40:15 <Saizan> interferon: by default it'll unregister the user one i think, you can always pass it --user or --global anyhow
18:40:17 <Cale> bluetaslem: There are a few options, what sort of graphics?
18:40:19 <kiris> jmcarthur:i went a bit overboard with the coments in this program: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24679#a24679
18:40:29 <bluetaslem> Just the ability to draw pixels, essentially.
18:40:36 <pastorn> ben_m: how's it going?
18:40:37 <kiris> thought it would make a good tutorial eventually but never bothered
18:40:46 <interferon> so why does ghc-pkg check report no problems if i have conflicts?
18:40:54 <Cale> There's a binding to OpenGL, there's Gtk2Hs, as well as SDL and some other stuff.
18:40:55 <ben_m> pastorn: Oh I stopped coding for today, it's 3:40 here. Will continue tomorrow :)
18:41:08 <pastorn> ben_m: it's 3:40 here too
18:41:11 <ben_m> heh
18:41:13 <pastorn> i'm not stopping for nothing!
18:41:25 <kiris> pastorn: even for kittens?
18:41:30 <pastorn> NEVAR
18:41:30 <kmc> bluetaslem, look through the packages on http://hackage.haskell.org/packages/archive/pkg-list.html
18:41:33 <ben_m> I'll read the source of the lectures from bed, good bed lecture.
18:41:35 <kmc> OpenGL is a popular one
18:41:36 <bluetaslem> Um, a questin, because I'm also new to IRC.
18:41:37 <kmc> for "graphics"
18:41:38 <Saizan> interferon: well, ghc-pkg check is not complete
18:41:40 <kmc> Gtk for "GUI"
18:41:46 <kmc> in my opinion SDL sucks, in any language
18:41:48 <bluetaslem> Do the colors of names mean anything? or are they totally random?
18:41:53 <ben_m> bluetaslem: Random
18:41:58 <bluetaslem> Okays.
18:42:01 <kmc> but it can be good for getting events and an OpenGL drawing context
18:42:02 <jmcarthur> kiris: that doesn't look like literate programming style to me, or is that intended as a counterexample?
18:42:14 <ben_m> bluetaslem: But that's your irc client's doing, not irc in general
18:42:22 <Cale> It depends on what client you use, but usually they're random but consistent, to help you differentiate between them
18:42:35 <Cale> There's gloss, which is a quick library for really simple 2D graphics stuff.
18:42:37 <bluetaslem> Hm, jsut confuses me more, actually.
18:42:38 <interferon> Cale, Saizan: thanks!  after unregistering my bogus packages i can use runghc again
18:42:40 <Cale> http://hackage.haskell.org/package/gloss
18:42:44 <jmcarthur> kiris: *an example of lots of comments not being the same as literate programming
18:42:46 <kmc> bluetaslem, also look at graphics-drawingcombinators
18:42:57 <pastorn> kiris: callCC $ \kittens -> forever goOn
18:43:10 <bluetaslem> Now, how exactly would I use "gloss?"
18:43:12 <Saizan> interferon: cheers :)
18:43:13 <kmc> bluetaslem, any C library can be used from Haskell, if you must do graphics a particular way
18:43:22 <bluetaslem> I see.
18:43:22 <kmc> bluetaslem, there's a "gloss-examples" package
18:43:25 <kiris> jmcarthur: well certainly isn't intended as a advocacy. I have done it right on occasion and it's nice, but I don't have any saved examples. I used org-mode to organise one project but it tends to encourage me to make large files
18:43:32 <bluetaslem> So, essentially, for graphics, you call on C?
18:43:35 <kiris> jmcarthur: have you got any examples?
18:43:38 <kmc> bluetaslem, i didn't say that
18:43:44 <fax> bluetaslem - that's one way
18:43:44 <pastorn> kiris: se how i cleverly ignored my function there?
18:43:50 <kmc> bluetaslem, just that you *can*
18:43:56 <kmc> if there is some C graphics library that you want to use in particular
18:44:16 <kiris> pastorn: it's too dangerous to compute alone, take this kitten continuation with you!
18:44:25 <kmc> most any IO you do is going through the operating system's C APIs at some level
18:44:25 <Saizan> most (all?) of the graphic haskell libs are bindings to C libs currently
18:44:35 <kmc> but usually a level far below what you need to be concerned with
18:44:36 * pastorn hears the "get item" tune from zelda
18:45:02 <bluetaslem> Now, curious...
18:45:08 <bluetaslem> How efficient is Haskell?
18:45:11 <Cale> bluetaslem: Well... there are some libraries which reimplement the X protocol
18:45:15 <kmc> Haskell is a language, with various implementations
18:45:20 <kmc> GHC is a pretty sophisticated optimizing compiler
18:45:23 <pastorn> bluetaslem: depends on how efficient you write your code :)
18:45:26 <kmc> @where shootout
18:45:26 <lambdabot> http://shootout.alioth.debian.org/
18:45:33 <kmc> bluetaslem, take a look at comparisons there
18:45:43 <kmc> bluetaslem, that said, Haskell emphasizes "get it working, then make it fast"
18:45:58 <kmc> usually the simplest way to write something will not produce the fastest code
18:46:14 <Cale> Especially in the beginning, you have to be prepared for the performance of code to not be what you might expect from other languages.
18:46:16 <kmc> compared to some other languages where there is *no* simple way, and you have to write it the complicated way, which is also fast
18:46:32 <Cale> and by that I don't mean that it's just going to be slower
18:46:33 <kiris> bedtime
18:46:41 <Cale> I mean that your intuition for what is fast will be poor
18:46:42 <interferon> kmc: :)
18:46:49 <interferon> kmc: that's a good way of putting it
18:46:50 <kmc> bluetaslem, there are some important things to learn early on, such as "lists are not arrays"
18:46:58 <kmc> interferon, Paul Graham said it better in _On Lisp"
18:47:06 <Cale> Once you recover that, it's pretty easy to get decent performance.
18:47:18 <bluetaslem> You know what you all sound like?
18:47:21 <ddarius> Actually, a lot of optimizations are geared toward making the "straightforward" code fast.
18:47:26 <bluetaslem> A multiple headed monster, that shares thoughts..
18:47:30 <fax> bluetaslem - haskell users
18:47:31 <fax> lol
18:47:34 <bluetaslem> Because you're completeing each others' sentences!
18:47:48 <jmcarthur> happens a lot around here
18:48:01 <Saizan> we actually reharse when the channel is silent.
18:48:05 <kmc> @quote contrapuntal
18:48:05 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
18:48:11 <fax> @remember bluetaslem (on #haskell) A multiple headed monster, that shares thoughts..
18:48:12 <lambdabot> Nice!
18:48:15 <Jafet> You can't complete someone else's sentences on IRC
18:48:21 <jmcarthur> @quote overwhelmingly
18:48:21 <lambdabot> No quotes match. I am sorry.
18:48:22 <kmc> you can if
18:48:24 <jmcarthur> dang
18:48:24 <kmc> you only type fractions
18:48:27 <kmc> of a sentence per line
18:48:27 <Sgeo_> Are there languages in which the simple way is generally fast?
18:48:29 <kmc> because you are so excited
18:48:38 <kmc> Sgeo_, that's a matter of implementation not of language
18:48:49 <fax> Sgeo -- I think it's impossible in general
18:49:00 <bluetaslem> Um, what is "@quote"?
18:49:03 <Jafet> You could use a language that is so slow there is no qualitative difference
18:49:07 <kmc> bluetaslem, tells lambdabot to remember a quote
18:49:14 <kmc> lambdabot is an IRC bot that hangs out here and does useful things
18:49:14 <ddarius> Sgeo_: There's different notions of "simple."  The "natural" way to code APL/J leads to good performance, but the natural way of coding in them isn't the natural way of coding for most people.
18:49:15 <jmcarthur> bluetaslem: a command to our resident bot, lambdabot
18:49:17 <kmc> like evaluating haskell code
18:49:22 <Jafet> http://en.wikipedia.org/wiki/Speedup_theorem
18:49:25 <kmc> > fix ((0:) . scanl (+) 1)
18:49:26 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
18:49:29 <bluetaslem> I see.
18:49:33 <kmc> :t map
18:49:34 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
18:49:37 <ddarius> Jafet: Like TCL.
18:49:52 <fax> @oies 0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946
18:49:53 <lambdabot>  Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
18:49:53 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
18:50:02 <Jafet> @undoubtedly
18:50:03 <lambdabot> Unknown command, try @list
18:50:06 <Jafet> @quote undoubtedly
18:50:06 <lambdabot> _pizza_ says: i think Haskell is undoubtedly the world's best programming language for discovering the first few dozen numbers in the Fibonacci sequence over IRC
18:50:16 <bluetaslem> Can new bots be added?
18:50:27 <fax> yes
18:50:31 <kmc> bluetaslem, since this is a public channel, anyone can sign on a client
18:50:33 <kmc> including a bot
18:50:37 <bluetaslem> I see.
18:50:38 <jmcarthur> @vixen Why don't you help bluetaslem make a bot?
18:50:39 <kmc> and it's not forbidden or anything
18:50:40 <lambdabot> no, why? do i seem "botty"?
18:50:44 <Cale> preflex: seen Cale
18:50:45 <kmc> lambdabot is open-source, and you can add plugins to it
18:50:45 <preflex>  Cale was last seen on #haskell 3 minutes and 38 seconds ago, saying: Once you recover that, it's pretty easy to get decent performance.
18:50:52 <kmc> where did lunabot go :/
18:51:02 <Jafet> To the dark side of the moon
18:51:08 <ddarius> kmc: Joining bots to channels is generally not something you do without some sort of "permission."
18:51:10 <bluetaslem> Hm, I'll consider writing a bot..
18:51:12 <Saizan> where did mmorrow go.
18:51:20 <interferon> is there a simple http server package for haskell?
18:51:23 <kmc> ddarius, really?
18:51:50 <Jafet> I wonder who authorized Cale then
18:52:01 <kmc> bluetaslem, http://haskell.org/haskellwiki/Roll_your_own_IRC_bot
18:52:07 <SamB_XP> Jafet: WE did
18:52:07 <ddarius> kmc: If they log, you need permission.  If they are noisy, they'll probably get banned.  However, if they are quiet there's no way to tell.
18:52:09 <Jafet> But I won't complain
18:52:17 <Saizan> interferon: probably a few on hackage
18:52:23 <SamB_XP> anyway, Cale was taking over from dons, who took over from I-don't-know-who
18:52:24 <kmc> bluetaslem, there are also various IRC-related packages on hackage
18:52:25 <ddarius> (log publically)
18:52:29 <SamB_XP> because that was before I was here
18:52:36 <kmc> including libraries and complete bots
18:52:36 <bluetaslem> Sorry, that code is still WAY above me.
18:52:47 * ddarius was here significantly before lambdabot.
18:52:55 <bluetaslem> I'm only an amateur at C++ and an expert in Lua.
18:53:01 <Saizan> how is the web server taken of a Simon Marlow paper called?
18:53:03 <fax> bluetaslem I like lua!
18:53:03 <bluetaslem> Still learning Haskell.
18:53:11 <kmc> bluetaslem, cool! you're in the right place then
18:53:13 <ddarius> Saizan: HWS or HWS-WP
18:53:13 <SamB_XP> ddarius: you mean, lambdabot wasn't always here ?
18:53:20 <ddarius> SamB_XP: Correct.
18:53:21 <SamB_XP> @history
18:53:21 <lambdabot> Unknown command, try @list
18:53:25 <narens> Question: I want a function [FilePath] -> IO String. It should return the contents of all the files as one string lazily. I don't want to incur the cost of using ++ for example... anyway to do it?
18:53:27 <SamB_XP> @changelog
18:53:27 <lambdabot> Unknown command, try @list
18:53:54 <kmc> narens, (++) is lazy
18:54:02 <Cale> narens: just use concat
18:54:11 <interferon> trying to understand how Text.Printf.printf takes a variable number of arguments
18:54:14 <Cale> It's right-associated, so it'll be fine.
18:54:14 <Saizan> interferon: http://hackage.haskell.org/package/mohws <- this is the one i was thinking of
18:54:16 <kmc> when you demand characters from (a ++ b) it will go through the characters of a one at a time, and then switch over to the characters of b once a runs out
18:54:23 <narens> Cale: no penalty for ++. That's what I thought.. wasn't sure.
18:54:35 <interferon> Saizan: thanks!
18:54:36 <SamB_XP> narens: well, there is a little one
18:54:45 <SamB_XP> but if you use concat, it's no problem
18:54:50 <SamB_XP> and you can't exactly AVOID it
18:54:52 <narens> great. thanks
18:55:02 <Jafet> I wonder how you return a string lazily if you read a file eagerly
18:55:05 <kmc> i mean O(|a| + |b|) is not a problem when you plan to traverse both anyway
18:55:20 <narens> yea gonna traverse all
18:55:35 <SamB_XP> Jafet: you could read the file in one go, but not read a given file until its contents come under demand?
18:55:56 <ddarius> SamB_XP: To do that would require unsafeInterleaveIO
18:56:18 <SamB_XP> ddarius: so does hGetContents -- your point being?
18:56:26 <narens> so fmap concat $ mapM readFile files would do?
18:56:31 <Saizan> Jafet: B.S.unpack <$> B.S.readFile file
18:56:41 <fax> I am trying to write this number theory program in haskell but it is too difficult so what shoul I do?
18:56:47 <Jafet> Saizan, point
18:56:49 <Cale> narens: yep
18:56:55 <ddarius> SamB_XP: My point being that it won't happen "by itself" and to make it happen requires an unsafe function.
18:56:57 <Jafet> fax, use pari
18:57:02 <fax> what's tat
18:57:04 <fax> that*
18:57:06 <SamB_XP> fax: avoid number theorems?
18:57:08 <Cale> xs ++ ys takes O(length xs) time if fully evaluated, and the cost only happens one cell at a time as you go through the resulting list
18:57:18 <fax> SamB but that is what the whole program is about
18:57:19 <SamB_XP> er. theorists*
18:57:29 <ddarius> fax: If you look at that Robert Ash page, Pari/GP is mentioned.
18:57:34 <Sgeo_> fax, Coq?
18:58:08 <bluetaslem> Heh, I was just thinking.
18:58:09 <Jafet> @quote coq
18:58:10 <lambdabot> sorear says: <sorear> Unfortunately, Coq *cannot* prove that your program will terminate before the heat-death of the universe. <psnively> Right. That's a software engineering problem, not a
18:58:10 <lambdabot> computer science problem. ;-)
18:58:10 <fax> I couldn't do it in coq either
18:58:16 <bluetaslem> Genetic Programming would be IMPOSSIBLE in Haskell.
18:58:44 <kmc> bluetaslem, oh?
18:58:55 <fax> wow this pari/gp thing sounds cool!
18:59:01 <Jafet> yarly
18:59:06 <bluetaslem> Haskell's syntax is very complex..
18:59:08 <fax> O_O
18:59:09 <narens> bluetaslem: how so? I do machine learning in haskell all the time... best language to do it in
18:59:13 <fax> this is basically what I was wanting to make
18:59:21 <bluetaslem> Genetic Programming would constantly make mistakes.
18:59:27 <Cale> bluetaslem: ?
18:59:44 <Jafet> Great, you don't have to make it anymore
18:59:44 <Jafet> Now you can concentrate on your numbertheoryisms
18:59:50 <kmc> bluetaslem, Haskell would be a great language for implementing a GP algorithm which programs in some smaller language
19:00:06 <bluetaslem> Right.
19:00:10 <fax> is there a haskell library of http://pari.math.u-bordeaux.fr/
19:00:10 <Jafet> blue, do you say that in every channel of a language you barely know
19:00:11 <fax> ?
19:00:26 <kmc> you would evolve not Haskell programs but some domain-specific expression tree
19:00:27 <bluetaslem> But you can't make a GP program that writes Haskel....
19:00:31 <bluetaslem> Say what/
19:00:33 <kmc> you could, it'd just be tricky
19:00:36 <aavogt> sure you could
19:00:38 <fax> bluetaslem - hey check this out:
19:00:42 <Jafet> Avoid feeding sugar.
19:00:46 <aavogt> but there's lots of redundancy in haskell syntax
19:00:48 <fax> ?djinn a -> (Maybe a -> b) -> Maybe b
19:00:49 <lambdabot> f a b = Just (b (Just a))
19:00:51 <kmc> i think GP over a general purpose language is ridiculous cargo cult CS
19:00:54 <bluetaslem> ?
19:00:57 <fax> look it progams haskell code automatically
19:01:05 <fax> so of course you can do GP with haskell
19:01:10 <fax> that's easy in comparison
19:01:12 <bluetaslem> ??
19:01:15 <fax> :D
19:01:20 <kmc> but anyway you might evolve programs in a simple concatencative, or maybe scheme-like language
19:01:21 <Jafet> kmc, remember the quip about a zillion monkeys and java
19:01:25 <kmc> and implement it in Haskell
19:01:43 <kmc> or even a machine language like Avida uses
19:02:25 <kmc> bluetaslem, djinn will find a Haskell term with a given type, which is a task equivalent to proving theorems in first-order propositional logic
19:02:41 <Jafet> The story goes that if you keep a zillion monkeys on a continuous high on java for long enough, one of them writes a valid perl program
19:02:45 <Jafet> Or proving their negation
19:03:14 <jmcarthur> @djinn (b -> c) -> (a -> b) -> (a -> c)
19:03:14 <lambdabot> f a b c = a (b c)
19:03:29 <jmcarthur> @. pl djinn (b -> c) -> (a -> b) -> (a -> c)
19:03:29 <lambdabot> f = (.)
19:03:40 <Saizan> @djinn Not (Not (Either A (Not a)))
19:03:41 <lambdabot> Error: Undefined type A
19:03:46 <Saizan> @djinn Not (Not (Either a (Not a)))
19:03:46 <lambdabot> f a = void (a (Right (\ b -> a (Left b))))
19:03:51 <bluetaslem> Srry, I am still clueless on its purpose.
19:03:54 <bluetaslem> *Sorry.
19:04:03 <fax> bluetaslem it proves that you can go GP in haskell
19:04:08 <kmc> fax, ;P
19:04:16 <bluetaslem> Eh.
19:04:21 <kmc> bluetaslem, you give djinn a Haskell type.  it produces a Haskell expression with that type
19:04:24 <kmc> or says that it can't
19:04:28 <bluetaslem> my brother is going to start on a concept for an AI.
19:04:36 <fax> cool
19:04:48 <bluetaslem> Rather than attempt to decide which symbols it should generate..
19:05:04 <bluetaslem> It determines th operators that control their relationships, and then applies them.
19:05:12 <fax> that sounds cool
19:05:13 <Cale> bluetaslem: If you want to generate Haskell code, take a look at the haskell-src-exts package
19:05:27 <Cale> bluetaslem: But that's not really an effective way to do GP anyway.
19:05:48 <fax> bluetaslem - I was thinking AI would be good if it could explain things to pepole really well
19:06:03 <fax> bluetaslem like you could make an AI which reads a lot of books then it tells you what you want to know
19:06:06 <Cale> http://hackage.haskell.org/package/haskell-src-exts -- It has a parser as well as a prettyprinter, and a representation of the Haskell syntax as a datatype
19:06:34 <Jafet> Exercise: extend djinn to undecidableinstances
19:07:21 <kmc> realistically, Haskell is not built for metaprogramming the way LISP or Scheme is
19:07:30 <Saizan> there's a lot to cover before UndecidableInstances
19:07:30 <kmc> it's a powerful tool we use when other forms of abstraction do not suffice
19:07:34 <kmc> but there are many other forms of abstraction
19:08:01 <Saizan> for metaprogramming, i'd like a more semantic view of functions
19:08:05 <kmc> you don't need functions returning code as much, when you have functions returning functions
19:08:21 <kmc> and the latter is so much easier to work with
19:08:35 <Saizan> rather than the source code, a cyclic table would me more appropriate in many cases, i think
19:08:52 <kmc> i imagine that a successful GP program in Haskell would evolve terms in a first-order representation (e.g. an algebraic data type), and would then have a function to convert one of those terms to a Haskell function
19:08:55 <Saizan> (table in the same sense of MemoTrie tables)
19:09:03 <kmc> and -- importantly -- that conversion can be done without generating Haskell *code*
19:09:08 <kmc> as in syntax
19:09:12 <kmc> because functions are first-class values
19:09:19 <bluetaslem> Hm, ironic how I showed up for the first time, and set you on a topic that could last for hours.
19:09:23 <Jafet> kmc, estimate how long it will take to evolve monadic IO
19:09:35 <fax> a great deal of metaprogramming in haskell by GADT hacking
19:09:37 <kmc> bluetaslem, was that your goal?
19:09:40 <fax> it's sort of a black art
19:09:41 <bluetaslem> No.
19:09:43 <kmc> also i don't see how it's ironic
19:09:45 <bluetaslem> Its just ironic. :P
19:10:01 <fax> and there is also strange things you can do with typeclasses which seem very much unpredicted
19:10:36 <kmc> it's pretty common
19:10:45 <kmc> that a beginner comes in here with a question, and we overanalyze it
19:10:59 <kmc> in ##c++ or #python they will just swear at you
19:11:59 <Jafet> We practice when it's quiet, too.
19:14:06 <Sgeo_> @quote goldilocks
19:14:06 <lambdabot> No quotes match.
19:14:54 <fax> is there a haskell lib to draw lattices?
19:15:04 <kmc> you could use graphviz
19:17:17 <dancor> "base-3.0.3.2 was excluded because of the top level dependency base -any"
19:17:24 <dancor> it just makes sense
19:17:33 <Saizan> why not?
19:17:55 <turiya> hi
19:18:29 <Saizan> maybe check the Cabal FAQs there's one of a similar incomprehensible error, though i'm not sure if it's relevant
19:18:34 <dancor> ok
19:18:51 <turiya> can someone tell me if it possible to write a game without using mutable states?
19:19:11 <aavogt> yes
19:19:14 <zachk> yea just pass around the world between function calls
19:19:14 <aavogt> it is possible
19:19:23 <lispy|web> ?faq is it possible to write a game without using mutable states?
19:19:23 <lambdabot> The answer is: Yes! Haskell can do that.
19:20:13 <lispy|web> The irony of that question is that using mutable state is harder in real programs
19:20:31 <turiya> i am using IORef's and I cant see way withouht using them
19:20:57 <fax> @oies 3,5,17,257,65537
19:20:57 <lambdabot>  Fermat numbers: 2^(2^n) + 1.
19:20:57 <lambdabot>  [3,5,17,257,65537,4294967297,18446744073709551617,34028236692093846346337460...
19:21:17 <fax> 4294967297 isn't prime though
19:21:20 <turiya> the problem is I am forced to think about all the execution paths this way and it is cumbersome
19:21:42 <fax> turiya -- you can use a mix of pure and impure code
19:22:17 <turiya> fax, i do use some impure code but I would like to avoid using IORef
19:22:58 <fax> you use IORefs and stuff to implement a sort of "game engine" + language and then program the game in the (pure) language
19:23:46 <turiya> fax, i dont quite understand
19:24:26 <Veinor> @hoogle hasName
19:24:26 <lambdabot> No results found
19:24:32 <JoshTriplett> Does any difference exist between a context with the constraint (a ~ b, ... a ... b ...) and one with the constraint (... a ... a ...) ?
19:24:35 <Veinor> bah. I hate hoogle not indexing HXT
19:24:43 <JoshTriplett> What, exactly, does ~ mean?
19:24:53 <Veinor> it lengthens vowels ounds
19:24:57 <fax> > (\n->3^n+1) . [1..]
19:24:58 <lambdabot>   [4,10,28,82,244,730,2188,6562,19684,59050,177148,531442,1594324,4782970,143...
19:25:01 <Veinor> not sure what it's doing in a programming language though
19:25:03 <Cale> JoshTriplett: Means those types must be equal
19:25:22 <JoshTriplett> Cale: OK.  But does that mean anything different than just repeating a type variable?
19:25:29 <Cale> JoshTriplett: So, usually, there's no difference, but sometimes the ~ is really needed in order to express something
19:25:45 <JoshTriplett> Cale: Ah, I see.
19:25:54 <Cale> Like if you have (Foo a ~ Bar b) where Foo and Bar are two type families
19:25:55 <fax> > (\n->3^n+2) . [1..]
19:25:57 <lambdabot>   [5,11,29,83,245,731,2189,6563,19685,59051,177149,531443,1594325,4782971,143...
19:26:13 <fax> I wish lambdabot could do prime nubmers
19:26:22 <Jafet> Er, filter isPrime
19:26:24 <Cale> Can't it?
19:26:30 <Sgeo_> Types have derivatives???
19:26:31 <fax> not to my knowledge
19:26:32 <Jafet> > isPrime 3
19:26:33 <lambdabot>   Not in scope: `isPrime'
19:26:38 <Cale> Sgeo_: yeah
19:26:42 <Jafet> Ok, add a let-binding for isPrime and filter with it
19:26:54 <Cale> Sgeo_: I feel like I was the only one who wasn't surprised by this result ;)
19:27:00 <Jafet> Or ask Cale to add isPrime to caleskell
19:27:06 <Jafet> You know, for the pedagogical value
19:27:32 <Sgeo_> > id
19:27:33 <Cale> Sgeo_: (There is something really similar in combinatorics :)
19:27:33 <lambdabot>   {()->()}
19:27:40 <ddarius> > nubBy(((1<).).gcd)[2..]
19:27:41 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
19:27:52 <Sgeo_> > id :: Char -> Char
19:27:53 <lambdabot>   {'a'->'a';'b'->'b';'c'->'c';'d'->'d'}
19:27:57 <JoshTriplett> ddarius: Cute!
19:28:09 <fax> @let isPrime p = find p (nubBy(((1<).).gcd)[2..])
19:28:11 <lambdabot>  Defined.
19:28:13 <JoshTriplett> > (+) :: Int -> Int -> Int
19:28:14 <lambdabot>   -3->
19:28:15 <lambdabot>    {-3->-6;-2->-5;-1->-4;0->-3;1->-2;2->-1;3->0}
19:28:15 <lambdabot>  -2->
19:28:15 <lambdabot>    {-3->-5;-2->...
19:28:19 <Cale> @let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p*p <= n) $ primes
19:28:20 <lambdabot>  <local>:7:37:
19:28:20 <lambdabot>      Multiple declarations of `L.isPrime'
19:28:20 <lambdabot>      Declared at: <l...
19:28:23 <Cale> aww
19:28:23 <SamB_XP> Cale: when you add simple stuff to calaskell, you should add it to @src (with a comment about it being calaskell)
19:28:24 <Jafet> Doesn't smell terribly efficient, that
19:28:27 <fax> @undefine
19:28:29 <fax> sorry
19:28:33 <Jafet> @src nubBy
19:28:33 <lambdabot> nubBy eq []             =  []
19:28:33 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
19:28:39 <Cale> @undefine
19:28:42 <Cale> @let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p*p <= n) $ primes
19:28:43 <lambdabot>  Defined.
19:28:44 <Sgeo_> Wouldn't it be better for primes to be the nubBy trick?
19:28:45 <Cale> > primes
19:28:46 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
19:29:00 <fax> > take 5 $ filter isPrime $ (\n->3^n+2) . [1..]
19:29:01 <lambdabot>   [5,11,29,83,6563]
19:29:03 <fax> > take 6 $ filter isPrime $ (\n->3^n+2) . [1..]
19:29:05 <lambdabot>   [5,11,29,83,6563,59051]
19:29:08 <Cale> The nubBy trick is even less efficient than this way
19:29:14 <fax> > take 6 $ filter isPrime $ (\n->4^n+3) . [1..]
19:29:14 <Cale> and this way isn't all that efficient
19:29:15 <lambdabot>   [7,19,67,4099,65539,262147]
19:29:18 <JoshTriplett> > (:) :: Bool -> [Bool] -> [Bool]
19:29:19 <lambdabot>   True->
19:29:19 <lambdabot>    []->
19:29:19 <lambdabot>      [True]
19:29:19 <lambdabot>    [True]->
19:29:19 <lambdabot>      [True,True]
19:29:21 <lambdabot>    [True,True]->
19:29:23 <lambdabot>   ...
19:29:37 <fax> > take 6 $ filter isPrime $ (\n->5^n+4) . [1..]
19:29:39 <JoshTriplett> Since when can lambdabot print functions? :)
19:29:40 <lambdabot>   mueval-core: Time limit exceeded
19:29:44 <fax> > take 2 $ filter isPrime $ (\n->5^n+4) . [1..]
19:29:45 <lambdabot>   [29,15629]
19:29:51 <Jafet> You also need a function to efficiently take the intersection of two sorted lists
19:30:14 <Jafet> For those sparse sets, like primorial/repdigit primes
19:30:16 <JoshTriplett> > (++) :: [Bool] -> [Bool] -> [Bool]
19:30:18 <lambdabot>   []->
19:30:18 <lambdabot>    []->
19:30:18 <lambdabot>      []
19:30:18 <lambdabot>    [True]->
19:30:18 <lambdabot>      [True]
19:30:20 <lambdabot>    [True,True]->
19:30:22 <lambdabot>      [True,Tr...
19:30:33 <Jafet> And an antispam output filter
19:30:41 <Cale> Patches accepted
19:30:49 <JoshTriplett> Sorry. :)
19:31:24 <JoshTriplett> Cale: Thanks for the explanation about ~.
19:31:26 <SamB_XP> Jafet: personally, I always hate when \bot truncates output without offering @more...
19:31:43 <Jafet> @hoogle intersect
19:31:43 <lambdabot> Data.List intersect :: Eq a => [a] -> [a] -> [a]
19:31:43 <lambdabot> Data.List intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
19:31:43 <lambdabot> Data.IntMap intersection :: IntMap a -> IntMap b -> IntMap a
19:31:49 <Jafet> Doh
19:31:56 <Veinor> @hoogle hasName
19:31:56 <lambdabot> No results found
19:32:04 <Veinor> why doesn't hoogle index hxt?
19:32:10 <fax> the annoying thing about the show index for functions is that it sucks
19:32:15 <dancor> bc it indexes like nothing
19:32:23 <dancor> hayoo has way more
19:32:38 <Jafet> > intersect primes $ map (succ.(^2)) [1..]
19:32:39 <Veinor> but hayoo's type-searching is rather hit and miss
19:32:42 <lambdabot>   mueval-core: Time limit exceeded
19:32:55 <dancor> and it's like closed-source or something crazy
19:33:21 <Veinor> like, searching for the type signature of intercalate on hoogle gives me intercalate as the first result
19:33:35 <Veinor> but it's not on the first page of hayoo
19:33:52 <dancor> why doesn't hoogle just index all of hackage
19:33:54 * Sgeo_ once searched for something on Hoogle, and the second result was unsafeCoerce
19:33:56 <dancor> we may never know
19:34:07 <aavogt> @hoogle a -> b
19:34:07 <Veinor> Sgeo_: baha
19:34:07 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
19:34:07 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
19:34:07 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
19:34:17 * Sgeo_ was looking for Integer -> Char
19:34:27 <Sgeo_> Although Integer -> Maybe Char would probably make more sense
19:34:37 <SamB_XP> @djinn Integer -> Char
19:34:37 <lambdabot> Error: Undefined type Integer
19:34:53 <dancor> :t chr . mod 256
19:34:54 <lambdabot> Int -> Char
19:34:55 <Veinor> Int -> Char
19:34:58 <SamB_XP> @djinn+hoogle Integer -> Char
19:34:59 <lambdabot> Unknown command, try @list
19:35:00 <Veinor> chr 234234
19:35:02 <Veinor> > chr 234234
19:35:03 <lambdabot>   '\234234'
19:35:11 <Veinor> well.
19:35:21 <dancor> > chr 999999999999
19:35:22 <lambdabot>   * Exception: Prelude.chr: bad argument
19:35:25 <Cale> > text '\234234'
19:35:26 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
19:35:26 <lambdabot>         against inferred ty...
19:35:29 <Sgeo_> > fromInteger 8237549234759238475 :: Int
19:35:30 <lambdabot>   8237549234759238475
19:35:32 <Cale> > text "\234234"
19:35:33 <lambdabot>   𹋺
19:35:37 <twink> :t chr . fromIntegral . (`mod` 256)
19:35:38 <lambdabot> forall a. (Integral a) => a -> Char
19:35:48 <Sgeo_> :t fromInteger
19:35:48 <alpounet> @. djinn hoogle a -> b
19:35:48 <lambdabot> Cannot parse command
19:35:49 <lambdabot> Cannot parse command
19:35:49 <lambdabot> Cannot parse command
19:35:49 <lambdabot> forall a. (Num a) => Integer -> a
19:35:59 <Jafet> @let intersectSorted _ [] = []; intersectSorted [] _ = []; intersectSorted (x:xs) (y:ys) = if x<y then intersectSorted xs (y:ys) else if x>y then intersectSorted (x:xs) ys else x : intersectSorted xs ys
19:36:00 <lambdabot>  Defined.
19:36:15 <Veinor> :t text
19:36:16 <lambdabot> String -> Doc
19:36:32 <Jafet> > intersectSorted primes $ map (succ.(^2)) [1..]
19:36:36 <lambdabot>   mueval-core: Time limit exceeded
19:36:41 <fax> > take 5 $ intersectSorted primes $ map (succ.(^2)) [1..]
19:36:43 <lambdabot>   [2,5,17,37,101]
19:36:46 <kmc> yup, unsafeCoerce has a stupidly general type so Hoogle shows it a lot
19:36:46 <fax> > take 15 $ intersectSorted primes $ map (succ.(^2)) [1..]
19:36:48 <lambdabot>   [2,5,17,37,101,197,257,401,577,677,1297,1601,2917,3137,4357]
19:36:59 <Jafet> Hmm, bit too sparse.
19:36:59 <fax> these are prime?
19:37:03 <Sgeo_> > unsafeCoerce 32 :: Char
19:37:04 <lambdabot>   Not in scope: `unsafeCoerce'
19:37:09 <Jafet> Ask Cale, he wrote primes
19:37:35 <fax> but I thought they would be fermat too?
19:37:39 <fax> why are they not fermat
19:37:48 <Cale> er, did I mess up?
19:37:48 <kmc> turiya, maybe you can hpaste some code and we can help you clean it up?
19:37:49 <ddarius> fax: That's x^2+1
19:37:49 <Cale> > primes
19:37:51 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
19:37:53 <fax> ahhh
19:37:54 <fax> okay
19:38:04 <fax> no you didn't Cale I was just trying to figure out something I got mixed up about
19:38:04 <kmc> ultimately any interactive app has mutable state of some kind
19:38:08 <kmc> the user
19:38:12 <fax> @oies 2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101
19:38:13 <lambdabot>  The prime numbers.
19:38:13 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
19:38:14 <Jafet> I thought people in here would be used to basic pointfree
19:38:24 <ddarius> s/mutable state/concurrent process/
19:38:25 * Sgeo_ is not
19:38:29 <Sgeo_> Well, basic, I guess
19:38:38 <Sgeo_> Anything complex, like that nubBy thing, loses me
19:38:42 <SamB_XP> @. oeis eval primes
19:38:42 <lambdabot> Plugin `compose' failed with: Math/OEIS.hs:316:10-40: Irrefutable pattern failed for pattern ('%' : c : _, rest)
19:38:51 <kmc> ddarius, sure, I can implement IOVar with Chan and forkIO
19:38:59 <kmc> err IORef... stupid inconsistent name
19:39:11 <SamB_XP> @type text
19:39:12 <lambdabot> String -> Doc
19:39:15 <Sgeo_> If I want threads to run on different processors, that's forkOS
19:39:15 <Sgeo_> ?
19:39:19 <kmc> Sgeo_, no
19:39:20 <Jafet> kmc, moar abstraction
19:39:24 <SamB_XP> @hoogle Doc -> [Doc] -> Doc
19:39:24 <lambdabot> Text.PrettyPrint.HughesPJ punctuate :: Doc -> [Doc] -> [Doc]
19:39:24 <lambdabot> Language.Haskell.TH.PprLib punctuate :: Doc -> [Doc] -> [Doc]
19:39:24 <lambdabot> Text.PrettyPrint.HughesPJ ($$) :: Doc -> Doc -> Doc
19:39:27 <kmc> Sgeo_, that's +RTS -N
19:39:31 <Sgeo_> So different lightweight threads can run on diff.. ?
19:39:31 <kmc> on the command line to your argument
19:39:34 <kmc> and compile with -threaded
19:39:38 <fax> http://mathworld.wolfram.com/OddPrime.html
19:39:39 <kmc> Sgeo_, forkOS creates lightweight threads too
19:39:41 <kmc> it is really poorly named
19:39:49 <kmc> the only difference between forkOS and forkIO comes when you are making FFI calls
19:40:09 <Sgeo_> So both can make threads that run on different processors? Ojk
19:40:09 <kmc> neither is guaranteed to spawn a new Haskell worker thread at the OS level
19:40:10 <Sgeo_> Ok
19:40:13 <kmc> and in GHC neither ever does
19:40:24 <kmc> Sgeo_, http://donsbot.wordpress.com/2009/09/05/defun-2009-multicore-programming-in-haskell-now/
19:40:28 <SamB_XP> @. oeis eval hcat $ punctuate (text ",") $ map integer primes
19:40:28 <lambdabot> Plugin `compose' failed with: Math/OEIS.hs:316:10-40: Irrefutable pattern failed for pattern ('%' : c : _, rest)
19:40:35 <SamB_XP> @eval hcat $ punctuate (text ",") $ map integer primes
19:40:36 <kmc> Sgeo_, the number of OS threads and thus cores utilized is an RTS option
19:40:44 <SamB_XP> @run hcat $ punctuate (text ",") $ map integer primes
19:40:48 <lambdabot>   mueval-core: Time limit exceeded
19:40:53 <kmc> lightweight threads whether they be forkOS, forkIO, or implicitly spawned from sparks will get mapped onto those OS threads
19:40:55 <SamB_XP> @run primes
19:40:56 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
19:40:58 <SamB_XP> @eval primes
19:41:08 <fax> @run hcat $ punctuate (text ",") $ take 30 $ map integer primes
19:41:09 <lambdabot>   2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
19:41:16 <SamB_XP> @. oeis run primes
19:41:17 <lambdabot>  Sequence not found.
19:41:24 <fax> @@ @oies @run hcat $ punctuate (text ",") $ take 30 $ map integer primes
19:41:25 <lambdabot> Plugin `compose' failed with: Unknown command: "oies"
19:41:32 <fax> @@ @oeis @run hcat $ punctuate (text ",") $ take 30 $ map integer primes
19:41:33 <lambdabot>  Prime sum of n-th group of successive primes in A073684.
19:41:33 <lambdabot>  [5,23,101,109,263,211,251,757,1367,941,2053,1901,911,2347,1861,1187,1249,130...
19:41:40 <fax> o_o
19:42:38 <SamB_XP> @@ @oeis @run hcat $ punctuate (text ",") $ take 50 $ map integer primes
19:42:40 <lambdabot>  Prime sum of n-th group of successive primes in A073684.
19:42:40 <lambdabot>  [5,23,101,109,263,211,251,757,1367,941,2053,1901,911,2347,1861,1187,1249,130...
19:42:46 <SamB_XP> @@ @oeis @run hcat $ punctuate (text ",") $ take 90 $ map integer primes
19:42:47 <lambdabot>  Prime sum of n-th group of successive primes in A073684.
19:42:47 <lambdabot>  [5,23,101,109,263,211,251,757,1367,941,2053,1901,911,2347,1861,1187,1249,130...
19:42:54 <SamB_XP> why does it keep doing that ?
19:43:01 <Sgeo_> Looking at the tutorial
19:43:03 <Sgeo_> What's -O2?
19:43:12 <SamB_XP> Sgeo_: optimization level 2
19:43:24 <Sgeo_> No semantics differences then
19:43:34 <kmc> yes
19:43:44 <SamB_XP> modulo bugs and RULES
19:43:49 <kmc> some things  which have undefined semantics will now have different, still undefined semantics ;)
19:44:02 <kmc> RULES should be semantics-preserving
19:44:29 <kmc> do we have a canonical list of poorly-named things in Haskell?
19:44:57 <SamB_XP> kmc: yes, but they might not preserve the semantics that Sgeo_ was expecting ;-P
19:45:13 <kmc> the name of forkOS seems to suggest precisely the wrong thing
19:45:39 <Sgeo_> :t System.Info.numCapabilities
19:45:40 <lambdabot> Not in scope: `System.Info.numCapabilities'
19:45:45 <Sgeo_> :t GHC.Conc..numCapabilities
19:45:46 <lambdabot> parse error on input `GHC.Conc..'
19:45:48 <SamB_XP> yeah, people might think if they do that they'll need to maintain an entire Linux distribution ;-P
19:45:48 <Sgeo_> :t GHC.Conc.numCapabilities
19:45:50 <lambdabot> Int
19:45:50 <pastorn> kmc: processData-disease?
19:45:52 <jcreigh> kmc: hmm, I haven't done anything with threading. You're saying that forkOS doesn't create an OS-level thread?
19:46:02 <kmc> jcreigh, no, it creates a lightweight thread, same as forkIO
19:46:08 <kmc> the only difference is if you're doing FFI
19:46:09 <pastorn> jcreigh: i was expecting a new OS...
19:46:14 <kmc> haha pastorn
19:46:26 <SamB_XP> jcreigh, kmc: sure it does!
19:46:34 <kmc> it might create an OS-level thread for FFI
19:46:36 <kmc> it might not
19:46:37 <Sgeo_> Suppose I have a non-threadsafe API...
19:46:44 <SamB_XP> kmc: it needs to!
19:46:45 <kmc> it will probably not create an OS-level *worker* thread
19:46:59 <SamB_XP> that's it's whole reason for existance
19:47:04 <kmc> SamB_XP, if you do all FFI throgh a single thread you fulfill the Concurrent Haskell semantics
19:47:12 <kmc> the number of OS-level Haskell worker threads is set by the -N option to the RTS on the command line
19:47:17 <SamB_XP> kmc: I don't think so
19:47:18 <kmc> and will typicaly not change during execution
19:47:40 <kmc> Sgeo_, a C API?
19:47:45 <Sgeo_> yes
19:47:45 <kmc> that is the case where you need forkOS
19:47:46 <SamB_XP> some libs have TLS and that will fail miserably if the Haskell code was trying to use them from more than one forkOS'd thread ...
19:48:00 <Sgeo_> But the API is not expecting threads.
19:48:02 <kmc> it ensures that all FFI called from the forkOS'ed thread come from the same OS thread
19:48:07 <Sgeo_> It has no clue what to do with th.. ah
19:48:10 <kmc> that is what's known as a "bound [lightweight] thread"
19:48:19 <kmc> but that's unrelated to the question of where the pure Haskell evaluation work happens
19:48:24 <kmc> which is on the same pool of OS threads as always
19:48:33 <kmc> at least in GHC's implementation
19:48:44 <kmc> basically, it will spawn an OS thread that sits idle most of the time,  but executes your FFI calls for you
19:50:15 <Sgeo_> So Haskell doesn't automatically do parallelizable work in parallel threads
19:50:28 <kmc> Sgeo_, right.  you have to annotate your work
19:50:37 <kmc> using e.g. the stuff from Control.Parallel.Strategies
19:50:58 <kmc> Sgeo_, but that style of *parallel* programming is very different from the *concurrent* programming you do with forkIO
19:51:03 <kmc> though you can mix the two
19:51:34 <kmc> parallelism is about parallel evaluation; concurrency is about parallel execution
19:51:54 <kmc> parallel programs have deterministic semantics and the implementation on multiple cores is an implementation detail
19:52:00 <SamB_XP> kmc: hmm, the docs in Control.Concurrent suggest that these "bound threads" do their reduction in the OS threads to which they are bound
19:52:15 <kmc> concurrent programs have concurrent semantics and may be useful as an abstraction even if you have only one actual core
19:52:17 <SamB_XP> based on the performance warnings about context-switching between them and unbound threads
19:52:34 <SamB_XP> rather than warnings about the performance of making FFI calls from them
19:52:39 <kmc> SamB_XP, i know i did a test of this
19:53:07 <kmc> if you run with -threaded / +RTS -N 1
19:53:11 <kmc> and you forkOS 100 times
19:53:17 <kmc> you still will not get more than 100% utilization
19:53:47 <SamB_XP> that's because it makes them hand off some token saying who gets to run
19:53:50 <SamB_XP> I think
19:53:55 <kmc> ah
19:54:02 <SamB_XP> hence the warnings about context-switch performance
19:54:20 <kmc> anyway it's definitely wrong to say "i want my program to use more than one core => use forkOS over forkIO"
19:54:25 <kmc> forkOS will probably perform *worse*
19:54:29 <SamB_XP> quite so
19:54:30 <kmc> as you and the docs said
19:55:28 <SamB_XP> forkOS exists only for things that either need TLS or just need stuff running in a specific thread
19:55:38 <kmc> what's special about TLS?
19:55:55 <SamB_XP> it's for OS threads
19:56:03 <SamB_XP> Haskell threads neither have nor want it
19:56:13 <SamB_XP> it doesn't fit nicely with Haskell, after all
19:56:24 <kmc> oh, TLS = thread local storage?
19:56:30 <SamB_XP> Thread Local Sockets, btw, not that SSL thing
19:56:32 <kmc> oh
19:56:35 <kmc> ohkay
19:56:36 <SamB_XP> er. Storage
19:56:37 <kmc> makes sense now :)
19:56:43 <SamB_XP> sorry ;-)
19:56:47 <kmc> my bad
19:56:52 <kmc> too many TLAs in this business
19:57:12 <SamB_XP> anyway, GL uses TLS, GTK and win32 are picky about what threads you make your GUI calls from
19:57:49 <SamB_XP> namely, GTK wants them all from one thread, apparantly; win32 wants you to confine all manipulation of a given window to the thread that created it
19:58:04 <kmc> i keep forgetting that some people use windows
19:58:18 <SamB_XP> well, I think win32 is nicer in this respect
19:58:27 <SamB_XP> I mean, it doesn't make you use ONE thread for EVERYTHING
19:58:43 <SamB_XP> just for everything to do with a given window
19:59:22 <applicative> > let lyah op a = foldr op a [a,a,a,a] in lyah ($$) (lyah (<>) (text "HAHAHAHAHA! "))
19:59:23 <lambdabot>   HAHAHAHAHA! HAHAHAHAHA! HAHAHAHAHA! HAHAHAHAHA! HAHAHAHAHA!
19:59:23 <lambdabot>  HAHAHAHAHA! H...
19:59:29 <applicative> ah well
19:59:52 <SamB_XP> note that I don't actually do win32 programming much, I just do a fair bit of playing around with e.g. IDA and so I end up reading all these scary docs
20:01:00 <Sgeo_> > [: 1 :]
20:01:01 <lambdabot>   <no location info>: parse error on input `]'
20:01:12 <kmc> that's a Data Parallel Haskell array
20:01:16 <kmc> lambdabot doesn't know about them
20:01:32 <applicative> thank God
20:01:39 <kmc> hehe
20:01:42 <SamB_XP> why's that ?
20:01:52 <SamB_XP> you don't want a @undph ?
20:02:21 <Sgeo_> GHCi also gave me a parse error
20:02:34 <SamB_XP> Sgeo_: you need to turn on an -X option
20:02:39 <SamB_XP> not sure which
20:02:41 <Sgeo_> Bleh
20:02:50 <SamB_XP> that's why \bot doesn't grok 'em
20:02:58 <SamB_XP> she hasn't got that -X option either
20:06:26 <SamB_XP> http://www.haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
20:06:33 <Veinor> undph sounds like something you'd say when you get hit
20:06:34 <Veinor> UNDPH!
20:07:07 <aavogt> mueval doesn't easily allow adding -X flags
20:07:42 <SamB_XP> like unpl and unmtl
20:07:45 <aavogt> it just has an option to enable the bunch you get with -fglasgow-exts
20:08:04 <SamB_XP> @unmtl StateT a (Writer b)
20:08:04 <lambdabot> err: `StateT a (Writer b)' is not applied to enough arguments, giving `/\A. a -> (A, a, b)'
20:08:13 <aavogt> @ask gwern can mueval have an interface to enable some -X flags?
20:08:13 <SamB_XP> @unmtl StateT a (Writer b) a
20:08:13 <lambdabot> Consider it noted.
20:08:14 <lambdabot> a -> (a, a, b)
20:08:17 <SamB_XP> @unmtl StateT a (Writer b) c
20:08:17 <lambdabot> a -> (c, a, b)
20:08:29 <SamB_XP> @unmtl StateT s (Writer w) a
20:08:29 <lambdabot> s -> (a, s, w)
20:08:45 * SamB_XP thinks it's lying
20:08:47 * Sgeo_ needs to learn how to use StateT
20:08:50 <dancor> kmc: i just made http://www.haskell.org/haskellwiki/Poorly_named_things with only forkOS so far.  maybe it will be expanded or made to merge with or point at some larger compendium
20:09:13 <aavogt> SamB_XP: what's the difference between nested tuples and that?
20:09:14 <kmc> cool
20:09:16 <Veinor> 'join, return'
20:09:19 <Veinor> also, I need a haskell wiki account
20:09:42 <SamB_XP> Veinor: you can't find where it says who to contact for that?
20:09:55 <Veinor> wait
20:10:00 <dancor> you just put in your email address
20:10:02 <aavogt> fst should be overloaded for other tuple lengths and lists too
20:10:02 <Veinor> you don't need to contact someone anymore O_o
20:10:04 <dancor> it's instant
20:10:11 <Veinor> aavogt: but then what'd the type be?
20:10:15 <SamB_XP> oh w000t
20:10:20 <SamB_XP> that's nice
20:10:20 <aavogt> Veinor: it would have a typeclass
20:10:28 <Veinor> Fstable?
20:10:32 <aavogt> haha
20:10:33 <Sgeo_> :t io
20:10:34 <lambdabot> Not in scope: `io'
20:10:42 <Veinor> aka Fistable
20:10:43 <Sgeo_> :t Control.Monad.State.io
20:10:44 <lambdabot> Not in scope: `Control.Monad.State.io'
20:10:52 <SamB_XP> Veinor: too confusing with F-stable
20:10:54 <Sgeo_> Love ya lambdabot
20:10:54 <Sgeo_> grr
20:11:02 <aavogt> instance Fstable Veinor where ...
20:11:15 <Veinor> oh my :o
20:11:28 <kmc> hmm, implementing IORef in terms of forkIO and Chan was a fun exercise
20:11:37 <aavogt> it would be fine to call the class Fst
20:11:37 <pastorn> hehe
20:11:42 <pastorn> kmc: how do you do that?
20:11:53 <pastorn> (i don't know about either forkIO or Chans...)
20:12:15 <SamB_XP> pastorn: well, Chan is a message queue made from MVars
20:12:18 <kmc> forkIO runs an IO action concurrently with the rest of your program
20:12:22 <kmc> Chan is a simple message channel
20:12:25 <Veinor> are join and return poorly named, would you say?
20:12:32 * Cale wouldn't
20:12:33 <kmc> Veinor, i'd say "return" is
20:12:35 <SamB_XP> Veinor: return, rather
20:12:41 <kmc> maybe should be "pure"
20:12:41 <SamB_XP> join, not really
20:12:46 <Cale> People hate return's name for some reason, but I think it's perfectly appropriate.
20:12:51 <pastorn> kmc: is a Chan a value that you can share between threads?
20:12:55 <kmc> pastorn, no
20:12:59 <Cale> return v is an action which does nothing but to return v
20:12:59 <pastorn> (threads obtained with forkIO)
20:13:08 <kmc> pastorn, it's a message channel
20:13:11 <SamB_XP> Cale: well, I don't mind it much anymore, but I can see why it might be nice to use a different name
20:13:13 <Veinor> Cale: it messes with imperative programmers
20:13:16 <kmc> you can send and receive messages on it
20:13:16 <Veinor> I like inject
20:13:23 <Cale> Sure, but then, so does *everything else*
20:13:28 <SamB_XP> Veinor: that sounds too complicated
20:13:30 <kmc> a message is any value... you can make a (Chan T) for any type T
20:13:30 <pastorn> kmc: what usually sends and what usually recieves?
20:13:36 <Veinor> monadify?
20:13:41 <Cale> ew
20:13:44 <Veinor> monadificate!
20:13:45 <SamB_XP> pastorn: different threads
20:13:45 <kmc> pastorn, readChan and writeChan are IO monad actions...
20:13:49 <kmc> so you can do them anywhere
20:13:52 <kmc> that you have IO monad code
20:13:54 <Cale> If you're going to call it something else, call it eta or unit.
20:13:59 <Veinor> eta? unit?
20:14:05 <SamB_XP> I think I would go for "pure" if arrows hadn't taken that already
20:14:07 <Cale> eta is the traditional name
20:14:08 <kmc> what's cool is that you can send and receive any values
20:14:10 <Cale> η
20:14:13 <kmc> including functions and IO actions
20:14:18 <aavogt> SamB_XP: pure is in Applicative now
20:14:25 <SamB_XP> aavogt: or whatever!
20:14:29 <pastorn> kmc: that's pretty cool :)
20:14:33 <kmc> so it's functional concurrent imperative programming
20:14:34 <Cale> in the literature about monads from category theorists, it's almost always called η
20:14:42 <Cale> and join is called μ
20:14:48 <pastorn> kmc: so how did the guts work?
20:14:49 <SamB_XP> Cale: that's a little hard for most to type
20:14:50 <aavogt> so making Applicative a superclass of Monad...
20:14:55 <Cale> yeah, so eta, mu :)
20:14:57 <pastorn> what happened on myNewIORef?
20:14:58 <SamB_XP> so join = fix ?
20:15:17 <Cale> That's a completely different mu :)
20:15:25 <Sgeo_> What's the difference between lift and liftIO?
20:15:38 <Sgeo_> Is liftIO just lift when used with IO?
20:15:46 <kmc> lift goes up one level in a transformer stack
20:15:50 <kmc> liftIO goes all the way to IO
20:15:58 <aavogt> what is up and down?
20:16:11 <Sgeo_> And what's io?
20:16:12 <SamB_XP> aavogt: well, by "up" he means the only way you can lift
20:16:13 <Veinor> I still like monadificate
20:16:18 <SamB_XP> you cant lift the other way
20:16:24 <aavogt> I don't really understand this analogy in spite of having had some success using the mtl
20:16:28 <pastorn> Sgeo_: if you use -XGeneralizedNewtypeDeriving for your monads you don't have to care :)
20:16:47 <Sgeo_> What's the easiest way to use StateT?
20:16:47 <aavogt> @wn pontificate
20:16:48 <lambdabot> *** "pontificate" wn "WordNet (r) 2.0"
20:16:48 <lambdabot> pontificate
20:16:48 <lambdabot>      n : the government of the Roman Catholic Church [syn: {papacy}]
20:16:48 <lambdabot>      v 1: administer a pontifical office
20:16:48 <lambdabot>      2: talk in a dogmatic and pompous manner; "The new professor
20:16:50 <lambdabot>         always pontificates"
20:16:53 <kmc> pastorn, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24680#a24680
20:17:12 <kmc> pastorn, i spawn a thread for each ref.  the thread listens forever for messages
20:17:13 <SamB_XP> :t lift
20:17:14 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
20:17:20 <pastorn> Sgeo_: easiest? i can only think of one way...
20:17:49 <kmc> each message has a combination projection/update function for the ref, and a channel to send the result
20:17:52 <SamB_XP> see, lift takes something from "m a" and lifts it to "t m a"
20:17:52 <kmc> back to the caller
20:18:02 <Sgeo_> What's the difference between io and liftIO?
20:18:11 <aavogt> @type runReaderT
20:18:12 <lambdabot> forall r (m :: * -> *) a. ReaderT r m a -> r -> m a
20:18:15 <SamB_XP> :t io
20:18:16 <lambdabot> Not in scope: `io'
20:18:22 <aavogt> @type runWriterT
20:18:23 <lambdabot> forall w (m :: * -> *) a. WriterT w m a -> m (a, w)
20:18:26 <SamB_XP> @type liftIO
20:18:27 <kmc> i think io is defined in XMonad
20:18:27 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
20:18:30 <kmc> to do something similar to liftIO
20:18:46 <SamB_XP> Sgeo_: what is the type of io ?
20:18:57 <pastorn> Sgeo_: i'm writing you a little example...
20:19:00 <aavogt> in this sense the transformer creates some value _inside_ the other Monad
20:19:07 <pastorn> kmc: i'll look at your code in 2 secs...
20:19:15 <Sgeo_> http://www.haskell.org/haskellwiki/Simple_StateT_use mentions io
20:19:24 <Sgeo_> ...Oh
20:19:29 <Sgeo_> It's not a library function
20:19:39 <Sgeo_> io = liftIO
20:19:45 * Sgeo_ should learn to read the whole source
20:19:50 <kmc> pastorn, so i said the power of concurrent programming in Haskell comes from sending functions and actions throguh Chans... i should have said that it also comes from sending Chans through Chans
20:19:53 <edwardk> gah, i can feel the pull of the slippery slope. first it was a little sat monad for marshalling to an external solver, then it was adding observable sharing and a naive bit representation, now i want to go translate my bits into and-inverter graphs and perform dag-aware minification...
20:19:58 <kmc> which is the *only* kind of communication you get in the pi calculus
20:20:32 <aavogt> > cycle "Chan ("
20:20:33 <lambdabot>   "Chan (Chan (Chan (Chan (Chan (Chan (Chan (Chan (Chan (Chan (Chan (Chan (Ch...
20:20:33 <pastorn> Sgeo_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24681#a24681
20:20:39 <aavogt> kmc: like that?
20:20:43 <pastorn> Sgeo_: this will probably work...
20:20:46 <kmc> aavogt, yes!
20:20:51 <kmc> i implemented pi calculus using (Mu Chan)
20:20:54 <pastorn> > replicate 4 "chan"
20:20:55 <lambdabot>   ["chan","chan","chan","chan"]
20:20:56 <kmc> it absolutely blew my mind
20:20:57 <pastorn> :D
20:21:02 <edwardk> kmc: =)
20:21:05 <kmc> i was so happy to have a use for the type (Mu Chan)
20:21:08 <SamB_XP> @k Mu
20:21:08 <lambdabot> Maybe you meant: karma karma+ karma- karma-all keal kind . ? @ v
20:21:11 <SamB_XP> @kind Mu
20:21:12 <lambdabot> (* -> *) -> *
20:21:15 <kmc> @src Mu
20:21:15 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
20:21:30 <aavogt> they couldn't call if Fix?
20:21:30 <edwardk> sounds like a japanese idol
20:21:51 <edwardk> aavogt: nah, because there are two fixpoints in theory =)
20:21:58 <edwardk> aavogt: at least that matter
20:21:58 <kmc> least and greatest?
20:22:01 <SamB_XP> aavogt: mu is VERY VERY VERY traditional
20:22:02 <edwardk> kmc: yeah
20:22:11 <kmc> can you write the greatest fixed point?
20:22:17 <pastorn> kmc: Chans through Chans seems funny :)
20:22:19 <kmc> for haskell types?
20:22:19 <aavogt> do we have greatest ones at all?
20:22:25 <pastorn> too bad they all have to be of the same type :)
20:22:28 <kmc> pastorn, i think it's pretty common in other languages too
20:22:35 <kmc> for this kind of request-response stuff
20:22:52 <edwardk> kmc: they unify in Hask, but if you move to a slightly more exotic category they start to diverge. even if you look at isomorphisms or embedding projection pairs over hask
20:22:53 <pastorn> kmc: heh... but you can't open a Chan to something on another machine, right?
20:23:24 <SamB_XP> pastorn: not directly, no
20:23:25 <kmc> pastorn, right.  not with any currently existing implementation
20:23:29 <dmwit> There's no reason for there to be only two fixpoints.
20:23:31 <pastorn> Sgeo_: ask if there's anything you don't understand about that little stateT code i wrote
20:23:32 <dmwit> There could be many more.
20:23:46 <SamB_XP> but there's nothing to prevent you from having one that proxies to another machine
20:23:49 <pastorn> SamB_XP: have you heard of some magic hack-around?
20:23:50 <edwardk> kmc: one way to look at is is you can build up 'Nu' and tear down 'Mu' so it is good when they are the same
20:24:06 <edwardk> dmwit: that was why i added the clarification of 'that matter' =)
20:24:21 <dmwit> =)
20:24:21 <SamB_XP> pastorn: you could easily have a thread at the other end of the channel that sends stuff across a socket, if it isn't terribly hard stuff to send ...
20:24:36 <kmc> but then you need to marshall it
20:24:42 <kmc> which immediately complicates all the interesting cases
20:24:43 <pastorn> SamB_XP: Chan (IO ())
20:24:48 <aavogt> but you can't easily serialize a Chan
20:24:50 <Sgeo_> pastorn, ty
20:24:51 <kmc> i mean so you can send an Int, big deal
20:24:55 <kmc> ;)
20:25:03 <kmc> programming isn't worth doing unless it's higher order
20:25:12 <pastorn> kmc: indeed
20:25:13 <SamB_XP> kmc: uh huh
20:25:25 * pastorn wants an instance of Show (a -> b)
20:25:29 <pastorn> well
20:25:31 <kmc> > succ :: Int -> Int
20:25:32 <lambdabot>   {-3->-2;-2->-1;-1->0;0->1;1->2;2->3;3->4}
20:25:32 <edwardk> kmc: consider: newtype Mu f = Mu (forall a. (f a -> a) -> a); data Nu f = forall a. Nu (a -> f a) a -- when f is _not_ a functor.
20:25:35 <pastorn> Storable (a -> b) is enough :)
20:25:55 <pastorn> > repeat
20:26:00 <lambdabot>   mueval-core: Time limit exceeded
20:26:05 <pastorn> kmc: i killed it
20:26:11 <kmc> heh
20:26:22 <kmc> i imagine a useful distributed Chan *would* let you send Chan through Chan
20:26:24 <Sgeo_> pastorn, there is such an instance.. as you see, apparently
20:26:26 <aavogt> pastorn: that hasn't been done yet?
20:26:34 <kmc> by doing bookkeeping on both ends
20:26:46 <Sgeo_> > putLine
20:26:49 <aavogt> seems like something mmorrow would do
20:26:50 <lambdabot>   mueval-core: Time limit exceeded
20:26:53 <kmc> but sending (IO ()) or functions could be harder
20:26:58 <SamB_XP> > fix
20:27:00 <edwardk> pastorn: i had a toy compiler that implemented that much ;)
20:27:00 <kmc> yhc can serialize functions using its bytecode
20:27:02 <lambdabot>   mueval-core: Time limit exceeded
20:27:06 <SamB_XP> > fix id
20:27:09 <Sgeo_> > id
20:27:09 <lambdabot>   mueval-core: Time limit exceeded
20:27:10 <kmc> presumably it could serialize IO actions if it uses a GHC-like implementation of IO
20:27:10 <lambdabot>   {()->()}
20:27:15 <SamB_XP> > id id
20:27:16 <pastorn> Sgeo_: they are putChar, putStr and putStrLn (and print)
20:27:16 <lambdabot>   {()->()}
20:27:18 <kmc> > take 2
20:27:19 <lambdabot>   {[]->[];[()]->[()];[(),()]->[(),()];[(),(),()]->[(),()]}
20:27:30 <SamB_XP> > putStrLn
20:27:31 <lambdabot>   ""->
20:27:31 <lambdabot>    <IO ()>
20:27:31 <lambdabot>  "a"->
20:27:31 <lambdabot>    <IO ()>
20:27:31 <lambdabot>  "aa"->
20:27:33 <lambdabot> [4 @more lines]
20:27:40 <edwardk> kmc: the tricky part is how to handle references to resources like file handles, etc.
20:27:43 <pastorn> i swear that sending functions would be a very simple task in any lisp-like language :)
20:27:45 <edwardk> kmc: most of it is trivial
20:27:46 <aavogt> prompt monad?
20:27:57 <SamB_XP> pastorn: what about the closed-over scopes ?
20:27:58 <kmc> mm
20:28:13 <aavogt> if you're going to go that way anyways...
20:28:20 <kmc> pastorn, sending *code* is easy
20:28:23 <kmc> sending functions is not as easy
20:28:28 <pastorn> SamB_XP: using the magic '
20:28:37 <kmc> sending code is easy in Haskell too
20:28:48 <pastorn> kmc: hmm... you're right...
20:28:50 <kmc> easy enough to do over IRC :)
20:28:52 <SamB_XP> pastorn: sending references to mutable objects is a bit tricky too ...
20:29:10 <aavogt> you have eval() done easily enough through hint
20:29:12 <edwardk> SamB_XP: just disallow those. done ;)
20:29:12 <pastorn> does the haskell-in-haskell-libraries provide any Function -> String methods?
20:29:37 <SamB_XP> edwardk: well, that rules out almost all the lisp-likes I've ever seen
20:29:42 <SamB_XP> not DSSSL though
20:29:57 <dancor> It's not just you! http://code.haskell.org looks down from here.
20:29:57 <SamB_XP> except DSSSL doesn't usually have any sockets or threads or anything like that anyway
20:29:58 <kmc> pastorn, you mean to get the code of a function?
20:30:07 <edwardk> SamB_XP: you can still get a usable scheme subset ;)
20:30:13 <Sgeo_> So I still can't download the new Platform
20:30:15 <kmc> pastorn, don't know of one.  in general a function will be made of lots of little bits of code partially evaluated together
20:30:16 <SamB_XP> @google down for everyone or just me
20:30:17 <lambdabot> http://downforeveryoneorjustme.com/
20:30:17 <lambdabot> Title: Down for everyone or just me?
20:30:18 <pastorn> kmc: yeah, and then have the library at the recieving machine reconstruct it
20:30:26 <edwardk> its the one most of the r5rs'ers pretend they are limited to anyways
20:30:30 <SamB_XP> http://downforeveryoneorjustme.com/code.haskell.org/
20:30:40 <kmc> pastorn, so you assume both sides have the same compiled code
20:30:53 <SamB_XP> edwardk: hmm?
20:30:55 <SamB_XP> what?
20:30:57 <kmc> then you only need to send the dynamic part of the function (the fields in its closure)
20:31:01 <pastorn> kmc: nah, just that they are using the same library for running haskell in haskell :)
20:31:10 <kmc> and a reference that allows it to find the static part (the info table + code)
20:31:25 <AxleLonghorn> so, I'm trying to download Yi with darcs, and having trouble. is the wiki out of date?
20:31:26 <pastorn> kmc: yeah
20:31:34 <kmc> and everything that closure refers to can either be sent eagerly, or replaced on the receiving side with a thunk that will request it on demand
20:31:54 <AxleLonghorn> ah, nevermind, I see it's not just me
20:31:57 <pastorn> kmc: you make it sound like i came up with something clever here...
20:32:08 <pastorn> kmc: i was just shooting ideas out of my ass...
20:32:21 <kmc> pastorn, it's been done, i'm describing how
20:32:28 <pastorn> oh, ok :)
20:32:53 <kmc> not sure how successfully it's been done
20:35:37 <AxleLonghorn> why is code.haskell.org down?
20:36:24 <lpsmith> AxleLonghorn, I don't know, but planet appears to be down as well
20:37:03 <edwardk> SamB_XP: a lot of schemers i know like to pretend set! isn't in the language. it gives me hope for them ;)
20:37:12 <idnar> heh
20:37:32 <kmc> i wonder how to make this implementation of IORef properly garbage collect refs
20:37:51 <SamB_XP> kmc: you mean GHC won't take care of that?
20:37:56 <edwardk> and if they need it then the write a nice little wrapper for a dialect of the language that does have it, but which doesn't require mutation in the outer scheme and run their dirty code in there ;)
20:37:57 <kmc> the one i wrote?
20:37:59 <SamB_XP> you've already profiled and it didn't work?
20:38:03 <kmc> i don't know
20:38:14 <SamB_XP> GHC can garbage collect entire threads, you know!
20:38:27 <SamB_XP> if it determines they're not going to do anything useful ever
20:38:31 <kmc> if a thread is blocking reading a Chan, and nobody else has a reference to that Chan, will it kill the thread?
20:38:35 <edwardk> SamB_XP: much to my consternation =/
20:38:36 <kmc> it might
20:38:54 <edwardk> SamB_XP: you also can't rely on sparks happening, so they aren;t a valid scheduling mechanism
20:39:03 <SamB_XP> kmc: GC generally does, yes
20:39:04 <dancor> Saizan: i don't suppose you want to upload hbuild to like patch-tag or something?
20:39:10 <kmc> but it's possible in theory to recover from this situation
20:39:11 <SamB_XP> edwardk: hmm?
20:39:22 <kmc> if an async exception kills the read, the thread might do something else with the chan
20:39:35 <kmc> so it would also have to know that i've made no such recovery provision
20:39:44 <edwardk> SamB_XP: if you kickstart a ton of sparks they'll fill up the queues or what have you and just start getting dropped.
20:40:13 <edwardk> SamB_XP: so I wound up needing to use full fledged threads
20:42:00 <mfwitten> The code.haskell.org's repos have been inaccessible for many hours (at least). For instance: http://code.haskell.org/xmobar
20:44:30 <SamB_XP> mfoemmel: someone here MIGHT be able to get it for you if you ask really nicely
20:44:41 <SamB_XP> the SSH was reported to still be working
20:44:48 <idnar> SamB_XP: ITYM mfwitten
20:44:55 <SamB_XP> er.
20:44:56 <SamB_XP> yeah
20:44:58 <SamB_XP> sorry!
20:45:09 <dancor> can we get someone to leak everything to patch-tag and then fork bomb the machine spitefully
20:45:10 <SamB_XP> I'm just too damn lazy for this channel ;-P
20:45:26 <idnar> what's patch-tag like these days?
20:45:28 <idnar> I suppose I should check it out
20:45:38 <dancor> idk i just know it's up ;)
20:45:39 <SamB_XP> patch-tag seems to be darcs2 only
20:46:04 <idnar> I'd use darcs2 for new projects anyway
20:46:55 <SamB_XP> well, all I mean is that it might not be possible to losslessly mirror everything from code.haskell.org to patch-tag ;-)
20:47:00 <dancor> right
20:47:33 <mfwitten> How about I ask: Can someone please start the fscking servers up again?
20:48:03 <SamB_XP> mfwitten: I've mentioned it in #ghc
20:48:20 <mfwitten> SamB_XP: When?
20:48:24 <SamB_XP> most of those here who would have SSH access to the box at all are still just losers
20:48:31 <SamB_XP> mfwitten: about 5 minutes ago
20:48:34 <dancor> i think at this point it's a big mistake to use haskell.org for new projects instead of something more reliable
20:48:44 <SamB_XP> yeah
20:48:50 <SamB_XP> we keep going down :-(
20:49:01 <mfwitten> Is it really a common problem?
20:49:20 <SamB_XP> maybe we should just dropkick apache ;-P
20:50:15 <dancor> there are complete.org and github.com too
20:50:26 <dancor> mfwitten: the lengths of these downtimes is really shocking is the thing
20:50:29 <SamB_XP> dancor: last I checked, github was for GIT
20:50:48 <dancor> ya and complete does darcs and git
20:50:58 <SamB_XP> dancor: it doesn't help that they always seem to happen on the weekend
20:50:59 <dancor> i feel a venn diagram coming on
20:51:03 <idnar> I thought complete.org was just CosmicRay's private site
20:51:09 <mfwitten> SamB_XP: Hmmmmm
20:51:16 <SamB_XP> idnar: what about sequence.complete.org
20:51:27 <SamB_XP> isn't that some important service that the net will die without?
20:51:37 <idnar> SamB_XP: heh
21:14:41 <AxleLonghorn> I'm getting this error when trying to install Yi through cabal: GHCi runtime linker: fatal error: I found a duplicate definition for symbol get_current_timezone_seconds whilst processing object file ~/.cabal/lib/time-1.1.2.4/ghc-6.12.1/HStime-1.1.2.4.o
21:15:37 <dysinger> I'm sure it's a well known issue that code.haskell.org is down ?
21:19:00 <AxleLonghorn> it is, it's been down for a good bit of the day
21:21:30 <mfwitten> dysinger: Yeah; I was just saying so :-)
21:21:36 <kmc> @. pl undo do { f <- readChan ch; v' <- f v; g v' }
21:21:37 <lambdabot> g =<< ($ v) =<< readChan ch
21:21:40 <kmc> yikes
21:22:42 <kmc> why does it use (=<<) i wonder
21:23:14 <SamB_XP> readability ?
21:23:31 <kmc> because it uses (.) also?
21:23:57 <idnar> as opposed to what?
21:24:14 <kmc> (>>=)
21:24:32 <idnar> @undo do { f <- readChan ch; v' <- f v; g v' }
21:24:32 <lambdabot> readChan ch >>= \ f -> f v >>= \ v' -> g v'
21:24:55 <idnar> @type ?g =<< ($ ?v) =<< readChan ?ch
21:24:56 <lambdabot> Not in scope: `readChan'
21:31:05 <kmc> @. pl undo \v -> do { let (v', b) = f v; writeChan ch b; return v' }
21:31:06 <lambdabot> Parse error at ";" (column 45)
21:31:19 <kmc> @. pl undo \v -> do { let { (v', b) = f v }; writeChan ch b; return v' }
21:31:19 <lambdabot> (line 1, column 12):
21:31:20 <lambdabot> unexpected "{"
21:31:20 <lambdabot> expecting "()", natural, identifier or "in"
21:31:26 <kmc> @undo \v -> do { let { (v', b) = f v }; writeChan ch b; return v' }
21:31:27 <lambdabot> \ v -> let { (v', b) = f v} in writeChan ch b >> return v'
21:32:29 <aavogt> so much explicit layout
21:32:35 <aavogt> you can drop the outer {}
21:32:49 <kmc> yeah i was trying to fix it by guesswork
21:32:53 <kmc> pl's parser is a little finicky
21:32:57 <aavogt> @undo \v -> do let { (v', b) = f v }; writeChan ch b; return v'
21:32:57 <lambdabot> \ v -> let { (v', b) = f v} in writeChan ch b >> return v'
21:35:35 <kmc> trying to decide how i feel about "let f x = readChan ch >>= ($ x) >>= f"
21:35:44 <kmc> i think it's pretty clear once you know what it does
21:36:21 <aavogt> that's not simple
21:36:33 <c_wraith> looks clear enough to me
21:36:40 <dmwit> :t \f x ch -> readChan ch >>= ($ x) >>= f
21:36:41 <lambdabot> Not in scope: `readChan'
21:36:57 <dmwit> kmc: If you didn't leave an "x" off the end, that looks like it would have a very strange type.
21:37:14 <c_wraith> assuming the chan contents are of type "Monad m => a -> m b"
21:37:14 <dmwit> :t \f x ch -> readIORef ch >>= ($ x) >>= f
21:37:15 <lambdabot> Not in scope: `readIORef'
21:37:16 <kmc> ch :: Chan (a -> IO a)
21:37:19 <kmc> x :: a
21:37:28 <kmc> f :: a -> IO b
21:37:42 <dmwit> ?hoogle readChan
21:37:42 <lambdabot> Control.Concurrent.Chan readChan :: Chan a -> IO a
21:37:49 <c_wraith> yeah, that implementation is clear enough
21:37:53 <dmwit> readChan ch -- this part doesn't type-check given the types you said
21:38:00 <aavogt> why b and not ()?
21:38:09 <kmc> can specialize to ()
21:38:11 <kmc> which forkIO does for me
21:38:16 <kmc> really, should be (IO Void)
21:38:22 <kmc> point being it never exits
21:38:24 <aavogt> yeah, there isn't any result
21:38:33 <dmwit> err, no, I'm an idiot
21:38:57 <aavogt> aren't you just a dmwit though?
21:39:05 <dmwit> =)
21:39:17 <dmwit> Now you know why I chose this nick. =)
21:40:18 * hackagebot xhaskell-library 0.0.3 - Replaces/Enhances Text.Regex  http://hackage.haskell.org/package/xhaskell-library-0.0.3 (KennyLu)
21:40:30 <aavogt> ironly
21:47:14 <dobblego> edwardk, ping
21:48:58 <notsonerdysunny> hello everybody .. is there an exhaustive documentation of all the standard libraries that I can refer to offline ?
21:49:23 <solrize> there's not even one ON line.
21:49:43 <kmc> every package in Haskell Platform is documented at http://hackage.haskell.org/packages/archive/pkg-list.html
21:49:58 <kmc> http://www.haskell.org/ghc/docs/6.10-latest/html/libraries/ has all the stuff that shipped with GHC 6.10 together in one page
21:50:10 <kmc> it's less useful for 6.12 because more stuff moved out of GHC and into Platform
21:50:28 <kmc> i would like to see combined haddock contents page for all of Platform
21:50:29 <dmwit> notsonerdysunny: You can ask cabal to install documentation with each package you install.
21:50:32 <Cale> I wish that documentation was built against the whole platform anyway
21:50:41 <dmwit> notsonerdysunny: Check ~/.cabal/config
21:50:51 <Cale> It would be way more useful that way, even if it wouldn't then reflect exactly what comes with GHC
21:52:36 <Sgeo_> Why don't I see Control.Monad.State in http://www.haskell.org/ghc/docs/latest/html/libraries/index.html ?
21:52:41 <dobblego> @hoogle f (a, b) -> (f a, f b)
21:52:42 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
21:52:42 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
21:52:43 <kmc> Sgeo_, because it's in the mtl package
21:53:17 <Sgeo> Ugh, so where's the top-level docs for everything in .. let me guess based on previous conversation: There isn't any.
21:53:22 <kmc> yes
21:53:23 <dobblego> zip is to instance Applicative ZipList as unzip is to ?
21:53:26 * Sgeo cries
21:53:30 <kmc> but if you know the package, you can find it on Hackage
21:53:36 <kmc> it even rhymes
21:53:37 <SamB_XP> Sgeo: oh, it exists
21:53:51 <SamB_XP> they just were silly enough to not think how we should find it!
21:54:04 <SamB_XP> it USED to be listed at that URL
21:54:09 <kmc> Hayoo can be useful for that
21:54:10 <SamB_XP> but then they unbundled mtl ...
21:54:33 <kmc> it will find the package(s) for a module
21:54:35 <Sgeo> Should I be using mtl, as opposed to.. some transactions thing I saw on the wiki?
21:54:47 <kmc> transformers?
21:55:09 <kmc> mtl is the standard, old and kinda crappy
21:55:31 <Sgeo> crappy howso?
21:55:53 <kmc> competitors include monadLib, mmtl, mtl-tf, and transformers
21:56:06 <kmc> well, there's the duplication of a transformer and non-transformer version of everything
21:56:35 <o-_-o> dibblego wrote in a reddit comment, what does this mean ? x = \  () -> 4
21:56:43 <kmc> :t \() -> 4
21:56:44 <lambdabot> forall t. (Num t) => () -> t
21:57:03 <kmc> x = a function taking an argument of type (), pattern-matching it to make sure it's really the value (), and returning 4
21:57:16 <langtree> > (\() -> 4) ()
21:57:18 <lambdabot>   4
21:57:22 <kmc> > \() -> 4
21:57:23 <lambdabot>   {()->4}
21:57:33 <jmcarthur> Sgeo: if you have an up to date cabal-install and configure it to build documentation then it will also build a complete index of all the documentation it builds
21:57:34 <kmc> Sgeo, in "transformers" you have only transformers plus an identity monad at the bottom
21:57:36 <gweber> hi all, was trying to install a package. I would appreciate any help:
21:57:38 <langtree> > \x -> 4
21:57:38 <gweber> Database/MongoDB/BSON.hs:369:9:
21:57:39 <gweber>     Type constructor `Exception' used as a class
21:57:41 <lambdabot>   {()->4}
21:57:55 <kmc> gweber, how were you installing it?
21:58:03 <kmc> it's probably a version mismatch with the libraries you already have
21:58:03 <o-_-o> so it is a lambda function taking () as an argument ?
21:58:03 <Sgeo> jmcarthur, any nice tutorials?
21:58:06 <kmc> o-_-o, yes
21:58:10 <jmcarthur> Sgeo: on what?
21:58:11 <langtree> > (\x -> 4) :: (Int -> Int)
21:58:12 <lambdabot>   {-3->4;-2->4;-1->4;0->4;1->4;2->4;3->4}
21:58:13 <pastorn> @djinn Int -> ()
21:58:13 <jmcarthur> cabal-install?
21:58:14 <lambdabot> Error: Undefined type Int
21:58:16 <o-_-o> kmc, cool
21:58:17 <langtree> O-o
21:58:17 <kmc> close to but subtly different from (\ (_ :: ()) -> 4)
21:58:26 <Sgeo> jmcarthur, configuring it to get the documentation as you described
21:58:28 <pastorn> @djinn Maybe () -> ()
21:58:28 <lambdabot> f a =
21:58:29 <lambdabot>     case a of
21:58:29 <lambdabot>     Nothing -> ()
21:58:29 <lambdabot>     Just b -> b
21:58:29 <kmc> which has the same type, but does not force evaluation of its argument
21:58:40 <jmcarthur> Sgeo: edit ~/.cabal/config
21:58:41 <langtree> > (\x -> 4) :: (String -> Int)
21:58:42 <lambdabot>   ""->
21:58:42 <lambdabot>    4
21:58:42 <lambdabot>  "a"->
21:58:42 <lambdabot>    4
21:58:42 <lambdabot>  "aa"->
21:58:44 <lambdabot> [7 @more lines]
21:58:56 <gweber> cabal install mongoDB, also clone from github and cabal install. Om Mac and Linux. Mac installed the Haskell Platform
21:59:09 <kmc> "Maybe ()" is a funny proposition.... "this is either a proof of something trivial, or it's... nothing at all!"
21:59:36 <kmc> @. djinn type maybe
21:59:37 <lambdabot> f a b c =
21:59:37 <lambdabot>     case c of
21:59:37 <lambdabot>     Nothing -> a
21:59:37 <lambdabot>     Just d -> b d
22:00:18 <kmc> Sgeo, i also have an obscure gripe with mtl's implementation of the Cont monad
22:00:37 <jmcarthur> incorrect type for callCC?
22:00:43 <kmc> yeah
22:00:46 <kmc> insufficiently polymorphic
22:00:49 <edwardk> dobblego: pong
22:00:56 <jmcarthur> yeah a little annoying
22:01:02 <jmcarthur> oddly it hasn't bitten me yet though
22:01:13 <dobblego> edwardk, is there anything in category-extras that gives you :: f (a, b) -> (f a, f b) ?
22:01:13 <kmc> explicit continuations are rare enough when you have lazy evaluation
22:01:37 <edwardk> Control.Functor.Zip.unfzip
22:01:41 <gweber> kmc, is there a way I can go about resolving this version mismatch?
22:01:50 <dobblego> edwardk, thanks
22:01:51 <kmc> gweber, how are you trying to install this package?
22:01:52 <edwardk> and the duals and generalizations, etc.
22:01:54 <edwardk> =)
22:02:03 <o-_-o> @remember <kmc> but if you know the package, you can find it on Hackage; <kmc> it even rhymes
22:02:03 <lambdabot> Done.
22:02:34 <gweber> kmc, cabal install
22:02:53 <gweber> kmc, cabal install mongoDB, also clone from github and cabal install. Om Mac and Linux. Mac installed the Haskell Platform
22:02:54 <kmc> gweber, oh... cabal-install should be capable of matching versions
22:02:55 <kmc> that sucks
22:03:00 <edwardk> http://comonad.com/haskell/category-extras/dist/doc/html/category-extras/Control-Functor-Zip.html -- and there are links from there to docs about why unzipping is more powerful than cozipping in haskell
22:03:06 <kmc> perhaps the mongoDB package is just broken
22:03:09 <kmc> what ghc version do you have?
22:03:13 <kmc> latest Platform?
22:03:27 <dobblego> edwardk, where is the source?
22:03:58 <edwardk> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/src/Control-Functor-Zip.html
22:04:08 <dobblego> ah thanks
22:04:32 <gweber> kmc, ghc 6.10.4. mongoDB 0.4.1, I tried installing 0.3, but that had the same problem
22:05:36 <kmc> ah
22:05:42 <kmc> hackage only says mongoDB works on 6.12.1
22:05:50 <kmc> the Platform for 6.12.1 is out now
22:06:37 <gweber> ah, thanks, I will move on up to 6.12
22:09:55 <Sgeo> @hoogle
22:09:55 <lambdabot> No query entered
22:09:55 <lambdabot> Try --help for command line options
22:09:57 <Sgeo> @hoogle (Enum a) => a -> Integer -> a
22:09:58 <lambdabot> Prelude asTypeOf :: a -> a -> a
22:09:58 <lambdabot> Prelude enumFromThen :: Enum a => a -> a -> [a]
22:09:58 <lambdabot> Prelude enumFromTo :: Enum a => a -> a -> [a]
22:10:17 <Sgeo> Please don't help me, I'll write my own
22:10:25 <kmc> what would it do?
22:11:16 <Sgeo> apply pred or succ the correct number of times
22:13:25 <kmc> there is a more efficient way
22:15:04 <Sgeo> ?
22:21:26 <siracusa> Sgeo:
22:21:29 <siracusa> > (\i -> toEnum . (+) i . fromEnum) (-3) 'd' :: Char
22:21:31 <lambdabot>   'a'
22:21:56 <Sgeo> Are Ints big enough to hold all possible unicode characters
22:21:57 <Sgeo> ?
22:22:09 <dons> yeah
22:22:15 <dons> > maxBound :: Char
22:22:16 <lambdabot>   '\1114111'
22:22:18 <dons> > maxBound :: Int
22:22:20 <lambdabot>   9223372036854775807
22:22:35 <Sgeo> > ord (maxBound :: Char)
22:22:36 <lambdabot>   1114111
22:22:36 <dons> > ord '\1114111'
22:22:37 <lambdabot>   1114111
22:22:40 <dons> :)
22:23:03 <dons> 9223372036854775807 ought to be enough characters for anyone
22:23:24 <dmwit> > 2^28 > 1114111
22:23:25 <lambdabot>   True
22:24:05 <mtnviewmark> Unicode code points fit in 21 bits
22:24:13 <dmwit> > (-2)^63 - 1
22:24:14 <lambdabot>   -9223372036854775809
22:24:16 <dmwit> > (-2)^63 - 1 :: Int
22:24:17 <lambdabot>   9223372036854775807
22:24:48 <dmwit> mtnviewmark: That is why I will never understand UTF16.
22:25:06 <mtnviewmark> Surrogates for the win!
22:25:16 <dmwit> You don't get to jump into the middle of a string by offset, plus you waste 8 bits per character for most English text.
22:25:36 <Draconx|Laptop> dmwit, you save 8 bits per character versus utf-8 for most non-english text.
22:25:50 <mtnviewmark> actually, it turns out that for the web, you waste space even for Asian languages -- since so much of the document is markup!
22:25:54 <dons> Sgeo: btw, if you're interested in unicode, look at Data.Text
22:26:07 <mtnviewmark> UTF-8 is the way to go for so many things!
22:26:09 <dmwit> Draconx|Laptop: I'm not sure I buy that. UTF8 is reasonably efficient -- wasting at most one or two bits.
22:26:25 <pikhq> Draconx|Laptop: Which is nowhere near as relevant as you'd think.
22:26:43 <Draconx|Laptop> dmwit, the majority of the BMP requires 3 bytes to encode in UTF-8.  In particular, all of the CJK symbols.
22:26:47 <dmwit> Of course, this could all stem from me not understanding the various encodings very well.
22:27:01 <pikhq> DEFLATE is nearly ubiquitous for HTTP.
22:27:05 <mtnviewmark> dmwit - er, not quite -- the vast majority of Asian characters are 3 bytes in UTF-8
22:27:09 <Sgeo> WHY do I keep typing genericTake when I want genericIndex???
22:27:11 <pikhq> It's really a non-issue.
22:27:42 <mtnviewmark> BUT, as I said, the markup is usually 1 byte characters in UTF-8 and that outweighs the cost!
22:28:12 <dons> Sgeo: index is usually wrong?
22:28:32 <Draconx|Laptop> dmwit, anyway, UTF-16's main advantage is when doing processing inside a program.
22:28:42 <Draconx|Laptop> dmwit, for storage and transmission, UTF-8 is a clear winner IMO.
22:28:50 <kmc> mtnviewmark, solution: chinese version of HTML
22:28:55 <kmc> replace all tag names with single characters
22:29:06 <dmwit> Draconx|Laptop: Is there a one-sentence summary of the benefit to processing?
22:29:08 <blackdog> is there an easy way to mirror cabal?
22:29:08 <pikhq> UTF-8's main advantage is that already-extant ASCII text is also valid UTF-8.
22:29:14 <Draconx|Laptop> dmwit, not having to parse it.
22:29:30 <dmwit> hm?
22:29:30 <kmc> blackdog, i saw some torrents once
22:29:44 <pikhq> And as it just so happens, gigantic chunks of software deal with ASCII in ways that make UTF-8 kinda-sorta work, too.
22:29:45 <dons> blackdog: mirror cabal?
22:29:51 <dons> blackdog: like pull from a different hackage?
22:29:57 <blackdog> dons: am going to a railscamp soonish
22:30:00 <blackdog> no internet access
22:30:01 <u_quark> Hello, I use the http://hackage.haskell.org/packages/archive/xmonad-contrib/0.9.1/doc/html/XMonad-Layout-ComboP.html#t%3AProperty conditions but the title of my window has a weird character and isn't matched. I there a way to find the actual Haskell string ?
22:30:09 <pikhq> *That* is why UTF-8 is useful. It's the legacy encoding.
22:30:10 <blackdog> so they're offering to host various things
22:30:11 <mtnviewmark> actually, most programs I've seen that use UTF-16 internally generally screw up their text processing.... **cough**python**cough**
22:30:15 <Sgeo> Ok, I think I got it working
22:30:25 <Sgeo> I just need some BF to test with
22:30:26 <dons> blackdog: ah, it will cache anything you download. or, alternatively, if you can clone hackage, cabal will pull from that instead.
22:30:36 <dons> blackdog: might be as easy as downloading the index tarball
22:30:46 <dons> blackdog: and modifying your .cabal/config to point to your new localhost
22:30:47 <blackdog> and it'd make it much easier to do the sly conversion of ruby hackers if there's a hackage server
22:30:56 <dons> blackdog: we did it at ICFP 08 live
22:31:00 <dons> hosting a hackage on duncan's laptop
22:31:05 <kmc> u_quark, do you know Haskell?
22:31:11 <dons> and gathering build reports from the room
22:31:17 <dons> so it definitely works
22:31:17 <pikhq> ... Python uses UCS-2 instead of UTF-16? *facepalm*
22:31:17 <u_quark> kmc: a bit
22:31:20 <mtnviewmark> Actually, I have a friend who maintains that we'd all be better off had UTF-8 been defined with the high bit inverted --- that way it WOULDN'T have worked with existing software, and people would have been forced to handle Unicode text correctly rather than fudging it for so long
22:31:23 <blackdog> i think they set DNS up anyway, so i can just put in an entry for hackage
22:31:44 <kmc> u_quark, wonder if  you can use Debug.Trace to print out the values it's trying to match against
22:31:55 <Sgeo> It's starting to occur to me that I didn't actually think about loops in any sane way
22:32:09 <mtnviewmark> pikhq - it depends on the platform on which it is built -- and -- eeek, it is somewhat confused -- you can get unicode strings in Python that claim to have one character but can be indexed by both 0 and 1!
22:32:10 <kmc> that'd require getting the string  though
22:32:20 <dmwit> Draconx|Laptop: How do you deal with surrogate pairs without parsing? Or, what do you mean by parsing?
22:32:29 <pikhq> Anyways. UTF-16 is actually a freaking awful character encoding these days. It's about as much a pain as UTF-8 if you care about things beyond the BMP.
22:32:35 <blackdog> dons: clone hackage? what do you mean, exactly?
22:32:37 <pikhq> mtnviewmark: Ugh.
22:32:42 <Draconx|Laptop> dmwit, yes, you will need to deal with surrogates, but they are *extremely rare*.
22:32:44 <blackdog> was hoping i could just rsync from somewhere
22:32:57 <kmc> u_quark, maybe you can use xprop or xwininfo
22:32:59 <kmc> and copy-paste into your file
22:33:02 <dmwit> um
22:33:07 <blackdog> i can see the latest versions tarball, but there's a good chance i'll need older versions...
22:33:12 <mtnviewmark> Draconx - that's no help -- still gotta deal with 'em!
22:33:16 <dmwit> Exactly.
22:33:19 <Draconx|Laptop> mtnviewmark, not necessarily.
22:33:26 <mtnviewmark> of course  you're all using Data.Text and this whole thing is beside the point!
22:33:35 <dons> blackdog: duplicate the file layout 00-index file etc
22:34:15 <u_quark> kmc: I used xprop but the string I get doesn't match ... I think it's an encoding problem because of the weird trademark character ...
22:34:17 <pikhq> Draconx|Laptop: "Extremely rare" does not matter. It is incorrect to not deal with surrogate pairs.
22:34:37 <dmwit> yes, 1000 times yes
22:35:01 <dmwit> "Simpler because the bugs are rarer" translates to "more complex" in my world.
22:35:20 <u_quark> kmc: even though it seams right and haskell speaks UTF8 afair
22:35:23 <Draconx|Laptop> dmwit, who said simpler?
22:35:52 <pikhq> Now, if you *really* want to say that, make a point of only using UCS-2. You'll have annoying behavior on things outside of the BMP, but it'll at least be *correct* behavior.
22:35:54 <mtnviewmark> haskell speaks Unicode within the environment (generally), and as of GHC 6.12 has an IO system that understands encodings for input/output streams
22:35:55 <Draconx|Laptop> dmwit, this is mainly a performance issue.
22:35:58 <dmwit> Draconx|Laptop: I admit, you didn't say the exact word "simpler".
22:36:00 <pikhq> I'll still punch you for doing it, but much less hard.
22:36:27 <kmc> yes, Strings are lists of unicode Char; they are not in a particular encoding
22:36:32 <kmc> but string literals in source files are
22:36:33 <pikhq> (UCS-2 cannot encode Unicode outside of the BMP)
22:36:41 <Sgeo> Awesome! Hello world works!
22:36:45 <kmc> this would be much easier if this library let you give a function rather than one of a fixed set of conditions
22:36:46 <blackdog> dons: ok, cheers.
22:37:31 <Draconx|Laptop> dmwit, and, versus UTF-32, a space efficiency issue.
22:37:54 <Draconx|Laptop> dmwit, unicode handling is never simple.
22:37:59 <u_quark> mtnviewmark, kmc: I have GHC version 6.10.4 here
22:38:10 <dons> blackdog: send me mail offline, we can do this.
22:38:10 <Sgeo> What does getChar do at EOF?
22:38:14 <pikhq> Draconx|Laptop: Believe it or not, the space used for *strings in memory* is not much of an issue for most cases. ;)
22:38:28 <dons> blackdog: and worse case, i have physical access to hackage, so we could dd it for you :)
22:39:14 <mtnviewmark> u_quark - can you briefly describe the path this string takes?  Is it: source code literal --> some GUI function?
22:39:16 <Draconx|Laptop> pikhq, If you do a lot of text processing, it frequently is.
22:39:20 <pikhq> And IMO it's the best internal encoding format, simply because it's fairly hard to screw up. You've got... Combining characters, still.
22:39:47 <kmc> u_quark, you could pipe the xprop output into hexdump
22:39:51 <kmc> to get the actual codes it's outputting
22:39:54 <pikhq> Draconx|Laptop: Uh. I've got 4G RAM. If it's a major issue for there to be 4G of text *in RAM* then I'm worried.
22:39:56 <kmc> which will be in whatever encoding your terminal uses
22:40:02 <kmc> then figure out the corresponding unicode codepoint
22:40:05 <kmc> i.e. decode it yourself
22:40:07 <pikhq> 4G of *text* is a metric fuckton.
22:40:12 <kmc> then embed a unicode escape literal in your Haskell file
22:40:23 <Draconx|Laptop> pikhq, believe it or not, there are systems with much less memory than that that people run programs on.
22:40:26 <pikhq> Like, "contents of a decent-sized library".
22:40:33 <mtnviewmark> If you paste the hex here - I'm pretty good at sight recognizing character encodings!
22:40:38 <Zao> Draconx|Laptop: I hear that swap is manly.
22:40:43 <pikhq> Draconx|Laptop: Okay, fine. 128MB is still a huge swath of text.
22:40:47 <pikhq> *Huge*.
22:40:51 <u_quark> kmc: maybe I can use `show $ Codec.Binary.UTF8.String.decode $ map fromIntegral string` ?
22:41:00 <pikhq> I'm still worried if there's 128MB of *text* in RAM.
22:41:00 <Draconx|Laptop> pikhq, also believe it or not, there are systems with metric fucktons of text processing to be performed.
22:41:35 <Draconx|Laptop> pikhq, log files are a good example.
22:42:09 <pikhq> Those systems do not need for that to be *in RAM* at all times, I'm pretty sure. And those systems are quite likely to be storing UTF-8 on disk, transforming to UTF-32 to make the text processing *quick and easy*, and then transforming back to UTF-8.
22:42:32 <mxc> pikhq - how many chats and status updates do you think facebook got in the last few minutes?
22:42:34 <Sgeo> @hoogle IO (Maybe Char)
22:42:35 <lambdabot> System.Console.Editline.Readline getCompletionAppendCharacter :: IO (Maybe Char)
22:42:35 <lambdabot> Control.Concurrent.MVar tryTakeMVar :: MVar a -> IO (Maybe a)
22:42:35 <lambdabot> System.Mem.Weak deRefWeak :: Weak v -> IO (Maybe v)
22:42:37 <pikhq> UTF-32 makes finding the value of a character literally indexing an array. No extra logic.
22:42:51 <pikhq> mxc: Tons.
22:43:04 <mxc> to borrow a term - 'metric fucktons'
22:43:09 <pikhq> Yes.
22:43:23 <mtnviewmark> At work we process "metric fucktons" of text all the time -- we do it in UTF-8 generally. We only use UTF-32 in a few outposts of our system (generally just before rendering on screen)
22:43:34 <pikhq> And the memory overhead is probably not an issue.
22:43:55 <pikhq> That there is all about bandwidth and CPU time.
22:44:02 <Draconx|Laptop> pikhq, half of a metric fuckton usually translates to $$$.
22:44:29 <pikhq> mtnviewmark: Which language do you use?
22:44:37 <pikhq> For the text processing, that is?
22:45:11 <mtnviewmark> C++, Python, PHP, Perl, Ruby, Java (in rough order from most to least)
22:45:24 <mtnviewmark> !
22:45:51 <mtnviewmark> I recently re-wrote one of our services from Python into Haskell -- but haven't convinced anyone to deploy it into production ..... yet!
22:46:46 <Adamant> mtnviewmark: lots of documented testing might help, assuming the problem is not strictly language politics
22:46:56 <Adamant> or economic concerns
22:46:58 <pikhq> Indeterminate (but probably one of UTF-8, UTF-16, or ASCII that doesn't break on UTF-8), broken UTF-16, broken UTF-8, UTF-8, UTF-8, non-standard UTF-16, respectively.
22:47:01 <mtnviewmark> Which is a shame, since the haskell version is about 6x faster with no work done on performance tuning --- and is rock-sold (never gives errors under load - unlike the python one)
22:48:03 <mtnviewmark> I duplicated all the unit tests the Python version has --- and we've used the same exact load tester configuration (based on tsung) on it
22:48:14 <mtnviewmark> so - I think everyone believes it is real!
22:48:23 <pikhq> Erm. Sorry. Java uses non-standard UTF-8, not UTF-16.
22:48:40 <Adamant> pikhq: I think it's changed stuff
22:48:50 <mtnviewmark> (And as I'm the Systems Architect ... I'm one of the main people who needs to be convinced to deploy it!   :-)
22:48:50 <blackdog> i've been thinking about one sneaky way of introducing haskell at work, actually - if i can get hubris a bit easier to install, then you might be able to do something interesting with QC testing of ruby objects
22:49:04 <pikhq> Inexplicably, Java has UTF-8 with surrogate pairs and encodes U+0000 as 0xC0,0x80.
22:49:16 <pikhq> (so as to allow in-string NULLs while working with NULL termination)
22:49:45 <mtnviewmark> really? I thought Java worked out all those kinks as of 1.5
22:49:56 <pikhq> mtnviewmark: This is the internal representation.
22:50:04 <pikhq> Externally, it is of course just pure UTF-8.
22:50:20 <mtnviewmark> ah, but exposed interfaces are either Unicode code-points or (legacy) UTF-16, right?
22:50:27 <dmwit> code-points
22:50:29 <dmwit> yes
22:50:33 <Draconx|Laptop> pikhq, it seems that you are confusing a language with an implementation.
22:51:02 <kmc> blackdog, similarly i enjoyed the recent article about benchmarking C functions with Criterion
22:51:05 <mtnviewmark> When it comes to Unicode, alas, I've found most languages have exactly that confusion --- c.f. Python
22:51:09 <mtnviewmark> and Java
22:51:10 <mtnviewmark> and Ruby
22:51:33 <pikhq> Draconx|Laptop: When you name a language that has but one major implementation that shares a name with the language, that's fairly easy to do.
22:51:53 <mtnviewmark> but beautifully - not Haskell!    So glad Haskell gets Unicode right
22:52:05 <kmc> technically, the name of the dominant Python implementation is CPython
22:52:10 <kmc> and i'm glad it has its own name
22:52:18 <idnar> pikhq: in my experience, most text processing is linear, which UTF-8 is perfectly adequate for
22:52:20 <kmc> because i often need to say things like "Python is great but CPython blows huge donkey chunks"
22:52:59 <kmc> and pypy, IronPython, Jython, and Unladen Swallow get enough press
22:53:00 <idnar> mtnviewmark: which confusion is that?
22:53:03 <Draconx|Laptop> pikhq, I can think of at least 5 java implementations off of the top of my head.
22:53:05 <kmc> that at least people are *aware* that Python can be implemented better
22:53:12 <kmc> although they'll still insist on calling it an "interpreted language"
22:53:19 <pikhq> Draconx|Laptop: Yes, but there's one major one, which is called "Java". :P
22:53:22 <Draconx|Laptop> pikhq, Java is not a language that comes to mind when I think of "languages that have one major implementation"
22:53:27 <pikhq> idnar: Yeah, but it's a royal pain to get right in other cases.
22:53:30 <kmc> it's called Sun JVM or Hotspot, isn't it?
22:53:35 <kmc> or Sun javac
22:53:41 <mtnviewmark> the confusion between the implementations internal representation of text, and the language's text data semantics
22:53:41 <blackdog> kmc: yeah, absolutely. the whole "java has wonderful tools" thing has always mystified me a bit - perhaps they have better refactoring tools, but there don't seem to be good analogues of QC and Criterion in many other languages
22:53:42 <pikhq> kmc: Sun... Makes things confusing.
22:53:47 <idnar> kmc: or a "scripting" language
22:53:53 <kmc> idnar, that's even worse
22:53:58 <pikhq> It's called either "Java" or "JVM" or "JRE" or "JDK" or "Hotspot", depending.
22:54:08 <idnar> mtnviewmark: (C)Python doesn't have that confusion at all
22:54:18 <pikhq> (technically, these are all different things. Most of them include implementations, though.)
22:54:30 <idnar> mtnviewmark: with the exception of leaking UTF-16 surrogate pairs if you build it in the incorrectly-named UCS-2 mode
22:54:57 <idnar> mtnviewmark: although a lot of Python /programmers/ have that confusion
22:55:06 <mtnviewmark> idnar - oh yes it does!  Try this on a Mac build of Python:   z = u"\1d122"
22:55:12 <mtnviewmark> then try z[0] and z[1]
22:55:12 <kmc> i'm amazed by how much you guys know about text encoding arcana
22:55:19 <kmc> most developers are like "whatever, learn english"
22:55:47 <idnar> mtnviewmark: that's not confusion though, it's just an inconvenient API
22:55:59 <blackdog> we're getting close to that with ghc, i suspect - i very much doubt much of hackage would work under lhc/jhc/hugs..
22:55:59 <dabblego> when I was at IBM, we were not allowed to use "Java"; only "The Java Platform"
22:56:10 <mtnviewmark> as systems architect of a very large consumer system - with over 60% non-US customers --- I have to know!
22:56:25 <mtnviewmark> idnar -  now try that on a linux build --
22:56:46 <idnar> (I'm assuming the Mac builds are in "UCS-2" mode? I don't actually know)
22:56:48 <mtnviewmark> you'll see that the implementation's choices of text rep have leaked into the languages definition of unicode string
22:57:04 <mtnviewmark> the answers are are different on the two machines, BTW
22:57:10 <pikhq> kmc: I care deeply about doing things correctly, and in particular about handling text correctly.
22:57:41 <pikhq> And one time, mojibake pissed me off enough that I learned about text encodings. :P
22:58:00 <idnar> mtnviewmark: yes, but there's no "confusion"
22:58:13 <idnar> mtnviewmark: it's only "leaky" in the sense that bottom in Haskell is leaky
22:59:13 <idnar> mtnviewmark: in the sense that you can distinguish between different bottoms
22:59:51 <idnar> mtnviewmark: both modes are consistent with the interface "a unicode string is a sequence of codepoints"
22:59:51 <pikhq> idnar: Except that Python claims to have strings of Unicode characters. Surrogate pairs are not Unicode characters.
23:00:17 <pikhq> They're a text encoding artifact that happens to have code points reserved to remove ambiguity.
23:00:42 <mtnviewmark> I believe the context for the word "confusion" here was that while discussing text behavior someone was saying that someone was confusing the implementation's vs. the language's concept of Unicode --- I was pointing out that many languages have let the implementation choices for Text leak into the language definition
23:00:47 <idnar> pikhq: well, the documentation may be incorrect :P
23:01:03 <dancor> s/character/code point/
23:01:20 <Draconx|Laptop> mtnviewmark, right, but there was a particular language in question, namely Java.
23:01:25 <pikhq> idnar: It also claims to be UCS-2. UCS-2 cannot handle code points outside of the BMP. ;)
23:01:33 <idnar> pikhq: yeah, I already touched on that :P
23:01:50 <mtnviewmark> It is true, given the totality of Python implementations we could come up with what the Python language's concept of Unicode text objects is -- -but would be deeply convoluted with the implementations
23:02:05 <kmc> can't you just say that certain behaviors are undefined
23:02:10 <kmc> such as indexing into the middle of a surrogate pair
23:02:13 <kmc> (is that the issue?)R
23:02:15 <idnar> pikhq: "UCS-2" mode is actually UTF-16, and "UCS-4" mode is actually UTF-32
23:02:27 <idnar> kmc: there's no issue at all, really, unless you write code that can't handle surrogate pairs
23:02:34 <pikhq> idnar: The first is facepalm-inducing.
23:02:43 <pikhq> The second is somewhat silly but valid.
23:02:47 <mtnviewmark> I'm just saying I'd call many languages defintion of "What is a Unicode String" to have been really defined by their implementation
23:02:51 <pikhq> (UCS-4 is a synonym for UTF-32)
23:03:04 <idnar> kmc: you pretty much have to deal with Unicode as a sequence of codepoints, because of... combining characters? I can't think of the name
23:03:07 <dancor> http://en.wikipedia.org/wiki/Unicode_character#Character_categories
23:03:19 <pikhq> idnar: Combining characters, yes.
23:03:20 <Draconx|Laptop> idnar, yes, that's the name.
23:03:27 <dancor> idk if it's that terrible to call unicode codepoints "unicode characters" tho
23:03:46 <idnar> dancor: it's terrible because unicode uses the name "character" to mean a different thing to "codepoint"
23:03:50 <Draconx|Laptop> dancor, since single characters can be represented by multiple code points, it's pretty bad.
23:04:15 <dancor> ya but i mean some of that overloading of "character" may be in the unicode spec itself
23:04:21 <idnar> unfortunately it's used somewhat inconsistently
23:04:23 <mtnviewmark> actually - technically, each Unicode character is assigned exactly one Unicode codepoint
23:04:44 <idnar> mtnviewmark: yes, but the mapping is 1:N
23:04:46 <dancor> some words just have multiple meanings even in these supposedly sane computech contexts
23:04:51 <mtnviewmark> nope, it isn't
23:05:05 <idnar> mtnviewmark: there are multiple sequences of codepoints that map to a single character
23:05:12 <mtnviewmark> a + combining accent is 2 characters, not 1
23:05:25 <pikhq> Unicode uses the term "abstract characters".
23:05:26 <idnar> mtnviewmark: what about a surrogate pair?
23:05:37 <pikhq> mtnviewmark: a + combining accent is one abstract character.
23:05:43 <dancor> pikhq: ah.
23:05:46 <mtnviewmark> surrogate pairs, as code points cannot be combined!
23:06:01 <mtnviewmark> they are not legal characters and many not occur in Unicode strings
23:06:15 <idnar> mtnviewmark: they're still codepoints, though
23:06:16 <pikhq> And now for the confusing bit: an abstract character may be represented by one or more characters.
23:06:16 <mtnviewmark> "abstract character" is not a concept in Unicode that I'm aware of
23:06:33 <mtnviewmark> a + combining accent is 2 characters, which may be rendered as one glyph
23:06:44 <pikhq> http://unicode.org/reports/tr17/
23:06:46 <dancor> pikhq: where character there is a synonym for codepoint? (or is the rabbithole even deeper?)
23:07:00 <mtnviewmark> idnar - but as code points they don't represent surrogate pairs
23:07:14 <idnar> mtnviewmark: "represent"?
23:07:19 <mtnviewmark> as code points they are basically "reserved and not allowed"
23:07:29 <idnar> mtnviewmark: a surrogate pair is a pair of codepoints
23:07:35 <mtnviewmark> they only have "surrogate meaning" within UTF-16
23:07:51 <mtnviewmark> no - a surrogate pair is a pair of 16-bit values in a UTF-16 stream
23:08:10 <mtnviewmark> In other words, if you had a Haskell String
23:08:42 <mtnviewmark> that had two values , 0xD834 and 0xDD22
23:09:00 <idnar> mtnviewmark: they're defined in terms of codepoints, above the encoding level
23:09:04 <mtnviewmark> that is an illegal Unicode string and is not the same as the String with the single character 0x1D122
23:09:08 <kmc> this discussion makes me sad
23:09:33 * kmc reads papers
23:10:01 <dancor> unicode has a storied history
23:10:09 <dancor> i think that's part of this b.s.
23:10:25 <idnar> mtnviewmark: well, yes, a Haskell String is a sequence of characters
23:10:45 <pikhq> dancor: It's... Confusing what a "character" is.
23:10:49 <idnar> U+D834 and U+DD22 are illegal characters
23:11:13 <dancor> In 1996, a surrogate character mechanism was implemented in Unicode 2.0, so that Unicode was no longer restricted to 16 bits.
23:11:17 <dancor> lol
23:11:20 <mtnviewmark> "Surrogate code points cannot be conformantly interchanged using Unicode encoding forms. They do not correspond to Unicode scalar values and thus do not have well-formed representations in any Unicode encoding form. (See Section 3.8, Surrogates.)"
23:11:41 <pikhq> I'm seeing characters encoded as characters. XD
23:11:44 <idnar> if you build Python in "UCS-4 mode" (really UTF-32 mode), you can treat unicode strings as sequences of characters, too
23:12:15 <idnar> "UCS-2 mode" (really UTF-16 mode) only exists as an OS interoperability hack
23:12:31 <mle-lucca> ucs-2 and utf-16 are not the same thing.
23:12:41 <pikhq> idnar: UCS-4 is a synonym for UTF-32, though.
23:12:54 <idnar> pikhq: UCS-4 allows values above 0x10ffff, UTF-32 doesn't
23:13:05 <Draconx|Laptop> mle-lucca, indeed, but it was mentioned earlier that python is stupid and conflates the two.
23:13:25 <mtnviewmark> true, though I believe ISO agreed to never assign characters above 0x10FFFF -- so it is moot
23:13:28 <idnar> pikhq: for purposes of encoding Unicode, they're equivalent
23:13:34 <pikhq> Ah, sure enough.
23:13:34 <dancor> idnar: i thought _unicode_ didn't allow anything over 0x10ffff, as of whenever-they-eventually-decided-that-was-enough  ya
23:14:01 <kmc> what happens when aliens visit earth and their language has ten billion glyphs
23:14:05 <pikhq> dancor: This is slightly confused by the existence of the Universal Character Set standard.
23:14:12 <idnar> pikhq: I'm making the distinction, because Python won't let you create a string with a value above 0x10ffff (unless you poke the buffer directly via C, or something)
23:14:25 <idnar> pikhq: so it's closer to UTF-32 than to UCS-4
23:14:28 <mle-lucca> either way going to 4 byte codepoints doesn't let you use them like characters
23:14:32 <idnar> pikhq: and "UCS-2" mode has surrogate pairs, so it's really UTF-16
23:14:33 <mle-lucca> there's still combining marks and whatnot
23:14:37 <dancor> kmc: obviously, at that time we'll create a few more levels of possibility for "character"
23:14:38 <Draconx|Laptop> kmc, we'd suddenly be back to where we were in the 90s, I guess.
23:14:39 <idnar> but anyway, that's just an unfortunately-named build-time flag
23:14:43 <pikhq> Which is a standard which happens to be nearly-compatible with Unicode.
23:14:50 <mle-lucca> utf-16 and surrogate pairs are not the same thing at all
23:15:06 <pikhq> mle-lucca: UTF-16 is UCS-2 + surrogate pairs.
23:15:09 <pikhq> That's what it *is*.
23:15:17 <idnar> Windows APIs use UTF-16 strings, which is why the windows builds are built in that mode
23:15:30 <idnar> I... guess Mac APIs do too? I have no clue what the situation is on that platform
23:15:42 <mle-lucca> idnar: utf-8 mostly.
23:15:48 <idnar> mle-lucca: that's pretty bizarre, then
23:15:58 <idnar> every Linux distro I know of builds Python in UTF-32 mode
23:16:11 <mle-lucca> Not talking about python
23:16:32 <mle-lucca> just saying the system as a whole uses utf-8
23:16:35 <pikhq> idnar: OS APIs.
23:17:00 <pikhq> UTF-8 is used because of UNIX. Everything's used to dealing with things as a bunch of chars.
23:17:16 <mle-lucca> and it's a good general purpose solution.
23:17:22 <Draconx|Laptop> UTF-8 has a number of other properties that make it useful for storage and transmission.
23:17:32 <eldragon> i'll use 1 char = 1 byte
23:17:34 <mle-lucca> utf-8's a plan9 thing, heh heh
23:17:45 <pikhq> Unfortunately, this means that a lot of it is only working because it's not actually doing anything that breaks ASCII.
23:17:47 <Draconx|Laptop> For example, it's quite resilient to many forms of data loss.
23:17:59 <idnar> I wish Python used UTF-8 internally everywhere, but oh well
23:19:03 <pikhq> Draconx|Laptop: And then compression gets used and you mess that up. :P
23:19:19 <pikhq> But fortunately you're transmitting with TCP so it doesn't matter.
23:19:34 <idnar> pikhq: unfortunately, nobody verifies TCP checksums
23:19:41 <pikhq> idnar: ...
23:19:42 <Draconx|Laptop> and TCP checksums are not very strong.
23:19:54 <idnar> pikhq: fortunately, your file transport protocol has checksums!
23:19:57 <idnar> pikhq: unfortunately, ...
23:20:06 <pikhq> idnar: I'm pretty sure the TCP stack does verify those.
23:20:15 <idnar> pikhq: most TCP stacks don't
23:20:26 <pikhq> Otherwise I would be getting random noise pretty much of the time.
23:20:31 <idnar> pikhq: even if it does, the data might get corrupted before it reaches the TCP stack
23:20:41 <pikhq> idnar: Uh... Even *UDP* does that.
23:20:53 <idnar> pikhq: I regularly see minor data corruption when transferring large amounts of data over, say, FTP
23:21:03 <Draconx|Laptop> pikhq, the probability of error in TCP is high enough to need caring about.
23:21:04 * pikhq has a *really* noisy connection
23:21:06 <idnar> I mean, we're talking a few bytes in a few GB
23:21:11 <pikhq> Draconx|Laptop: Yes, this is true.
23:21:14 <o-_-o> I was talking to a lisp person here, and he asked me about haskell. I told him it is a purely functional language yadda, yadda, yadda, etc., .,etc.,. He smiled and asked me how do they do printf ?
23:21:20 <idnar> but that's enough to ruin your day
23:21:35 <pikhq> Some 3/4ths of my packets actually get through on most days.
23:21:37 <o-_-o> I said Monads. But Monads how ?
23:21:49 <o-_-o> is there any place where I can read monads how ?
23:21:53 <idnar> o-_-o: printf is actually done with an ugly arrangements of typeclasses, no monads involved
23:22:08 <idnar> o-_-o: unless you're referring to the "print a string on the screen" part of printf, rather than the string formatting part
23:22:12 <o-_-o> idnar, I think he meant I/O in general
23:22:24 <idnar> o-_-o: ah
23:22:24 <o-_-o> idnar, side-effects rather
23:22:34 <idnar> o-_-o: well, the way I like to think about IO in Haskell is
23:22:39 <dabblego> o-_-o, by tagging them in the type system using a type constructor, which happens to be a monad
23:22:47 <idnar> o-_-o: you have IO actions, that describe a particular side-effect
23:22:51 <pikhq> o-_-o: We write purely functional programs that happen to describe entirely imperative ones. :)
23:23:06 <idnar> o-_-o: there's a special "main" value which is the IO action that is actually run when you execute a Haskell program
23:23:31 <idnar> o-_-o: but there are ways to combine IO actions together, so your "main" action is composed of lots of other actions
23:24:06 <o-_-o> ok...(to all)
23:24:06 <idnar> IO is a Monad, so you combine those actions by using various monadic operations
23:24:58 <o-_-o> idnar, maybe this is too dumb a question, but even after reading about Monads, I still don't know "what" it is ?
23:25:10 <dabblego> it's an interface and IO is one instance of many
23:25:29 <pikhq> o-_-o: It's a type that has the functions (>>=) and return. Seriously, that's all.
23:25:59 <idnar> o-_-o: if you're interested in understanding Monads in general, I'd recommend http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
23:26:12 <idnar> o-_-o: if you don't really care about Monads, but you just want to know how doing IO in Haskell works, I'd recommend http://blog.sigfpe.com/2007/11/io-monad-for-people-who-simply-dont.html
23:26:27 <o-_-o> idnar, I think it is time I understood monads
23:26:53 <o-_-o> pikhq, that sentence is pretty amazing and confusing at the same time
23:27:17 <mtnviewmark> here's a quick one: A Monad is an abstract that lets you do several computations under its control
23:27:27 <o-_-o> so can I do side-effects without monads :-) ?
23:27:33 <mtnviewmark> it can just do them in sequence, it can make a note of them, or just remember them
23:27:55 <o-_-o> mtnviewmark, ok...
23:27:58 <mtnviewmark> the IO monad makes a "mental note of world transforming actions"
23:28:00 <pikhq> o-_-o: We just happen to use side-effects to describe side effects. That's all.
23:28:05 <mtnviewmark> at least to your pure program
23:28:12 <idnar> pikhq: I think your sentence lacks a "monad" somewhere :)
23:28:13 <mtnviewmark> under the covers -- it's actually doin' 'em!
23:28:20 <pikhq> idnar: Hah.
23:28:25 <pikhq> idnar: It's late.
23:28:32 <idnar> pikhq: it's early here, but yeah :)
23:28:47 <kmc> o-_-o, the useful answer to "how does Haskell do IO" has nothing to do with monads
23:28:57 <kmc> the answer is "we don't do IO, we build descriptions of how IO could be done"
23:29:07 <kmc> using an abstract datatype
23:29:10 <o-_-o> late = (early - coffee)
23:29:16 <idnar> o-_-o: haha
23:29:28 <mtnviewmark> so think of:   "getLine >>= putStrLn . ("hello there, " ++)
23:29:54 <mtnviewmark> think of that, in the IO monad as the IO monad saying "Okay, so first you want to getLine... check"
23:30:20 <mtnviewmark> "and then you want to take that result and ... uhm.... prepend a string, and     AH   putStrLn it.... check"
23:30:50 <mtnviewmark> so the IO monad sees your two actions, and under its control, is noting what you'd like to do
23:31:06 <mtnviewmark> but you have no idea if it is doing them right away --- or saving them all for later
23:31:07 <kmc> o-_-o, you can do IO without thinking about the fact that you're using monads
23:31:10 <kmc> see http://haskell.org/haskellwiki/Introduction_to_IO
23:31:21 <mtnviewmark> including saving away your computation (the prepending of the string)
23:31:21 <kmc> in fact, the type "IO" is an unusual example of a monad
23:31:32 <kmc> it's best to ignore it if you're trying to learn about monads in the abstract
23:32:06 <mtnviewmark> And this "not knowing" is what sets you free - because now your program is pure  - and only the IO monad is, er, dirty
23:32:15 <c_wraith> I think knowing that IO is a functor is a much easier first step.
23:32:31 <dabblego> I think not knowing IO is an easier first step
23:32:33 <kmc> o-_-o, http://www.haskell.org/haskellwiki/Typeclassopedia
23:32:45 <kmc> if you want to understand Monad (and other related typeclasses)
23:32:56 <mtnviewmark> +1 for Typeclassopedia
23:33:28 <mtnviewmark> oh! late! later all....
23:33:54 <kmc> because as much as people will try to convince you that monads are containers, or computations or trees with grafting or boxes or pairs of adjoint functiors or spacesuits or burritos...
23:34:17 <c_wraith> pairs of adjoint spacesuits
23:34:20 <kmc> ultimately as far as Haskell is concerned, a monad is just any type which is an instance of the typeclass named "Monad"
23:34:30 <kmc> (and ideally satisfies the monad laws)
23:34:42 <kmc> so it really is just "types supporting a certain API"
23:34:51 <kmc> "types for which you can use the 'do' notation"
23:35:02 <o-_-o> kmc, ok...
23:35:09 <pikhq> And that API happens to be flexible.
23:35:12 <kmc> and trying to figure out what they "really are" can be a distraction from learning how to use them
23:35:17 <o-_-o> type which have >>= and return defined ?
23:35:20 <kmc> which ultimately gets you to understanding what they really are
23:35:21 <kmc> o-_-o, yes
23:35:24 <pikhq> o-_-o: Yes.
23:35:26 <kmc> o-_-o, are you familiar with typeclasses?
23:35:32 <o-_-o> kmc, yes
23:35:37 <kmc> so there's a typeclass named Monad
23:35:44 <kmc> and its two important members are return and (>>=)
23:36:06 <kmc> and when we say "T is a monad" all we mean is "T is an instance of the typeclass 'Monad'"
23:36:17 <o-_-o> kmc, ah....ok
23:36:27 <o-_-o> kmc, suddenly it is more clearer to me
23:36:53 <pikhq> Monads are also burritos. They taste delicious and go down well with hot sauce. j/k
23:37:01 <o-_-o> kmc, if I am trying to write an FFI to some library, would I use monads
23:37:17 <pikhq> o-_-o: Probably not.
23:37:22 <o-_-o> pikhq, yes, especially the fire sauce
23:37:30 <kmc> many C functions would need to be imported in IO
23:37:45 <pikhq> Well. Except that any imperative function in that FFI'd library will be a function in IO.
23:37:53 <kmc> anyway i think the useful page for your LISPer friend would be Cale's "Introduction to IO"
23:37:57 <kmc> and not anything more theoretical
23:37:59 <pikhq> (since, well, it's all real-world-like)
23:38:09 <o-_-o> kmc, link ?
23:38:11 <kmc> because as long as you're only doing IO, you don't even care about the general theory of monads
23:38:13 <kmc> i linked it above
23:38:19 <kmc> http://haskell.org/haskellwiki/Introduction_to_IO
23:38:25 <o-_-o> ah...yeah
23:38:29 <o-_-o> ok...got it
23:38:55 <o-_-o> supposedly the xen guys use haskell and no-one knows haskell here
23:39:16 <o-_-o> so they ran into me with RWH in my hand
23:39:28 <kmc> where is "here"?
23:39:33 <o-_-o> HP
23:39:40 <o-_-o> the printer company
23:39:43 <kmc> haha
23:40:11 <c_wraith> I miss HP the calculator company
23:40:24 <o-_-o> c_wraith, more like the ink company
23:41:02 <c_wraith> my hp48gx served me well in college
23:41:14 <pikhq> Good calculator.
23:41:33 <kmc> o-_-o, if you have RWH then you have a good chapter on FFI
23:41:48 <o-_-o> kmc, I am still somewhere at the beginning
23:42:24 <o-_-o> chapter 7, or something
23:42:50 <o-_-o> anyone here from HP ?
23:42:56 <o-_-o> former or current ?
23:43:12 <kmc> sometimes you have a C function which you know is pure, and you import it without the result being an IO action
23:43:18 <kmc> in those cases the compiler has to trust you
23:43:39 <kmc> sometimes your C function is not pure by itself, but you write some marshalling / wrapper code around it, and the result is pure
23:43:47 <kmc> in which case you use simonSaysPerformIO to make it so
23:43:48 <ManateeLazyCat> Hi all, gtk2hs have update all gtk, gdk, pango APIs to newest version! Enjoy! :)
23:43:52 <kmc> err... unsafePerformIO ;)
23:44:12 <o-_-o> ok...
23:44:18 <Cale> ManateeLazyCat: cool :)
23:44:55 <ManateeLazyCat> Cale: Now ApiGen have bug, i will update all GIO APIs to newest version after Axel fix ApiGen.
23:45:51 <ManateeLazyCat> Cale: Then gtk, gdk, pango, gio, webkit, vte libraries are newest to haskeller. :)
23:46:01 <ManateeLazyCat> Cale: Just gio haven't update.
23:46:02 <o-_-o> damnit now I want to go back to school to do a PhD, so I can learn haskell better
23:46:08 <pikhq> kmc: Yes, but you should think long and hard before using it if you're not named Simon. :P
23:46:20 <kmc> ;)
23:46:33 <kmc> there are some established use cases
23:46:45 <ManateeLazyCat> Please send any problem to gtk2hs mail-list, we can fix it as soon as we can.
23:46:47 <kmc> i wish ghc had jhc's top-level IO actions
23:47:14 <kmc> suppose i am an experienced haskell developer but have never touched GHC codebase
23:47:22 <kmc> how hard would it be for me to hack this in, and would it actually get included?
23:48:05 <Jafet> @remember pikhq <kmc> you use simonSaysPerformIO to make it so <pikhq> Yes, but you should think long and hard before using it if you're not named Simon.
23:48:05 <lambdabot> It is stored.
23:48:21 * ManateeLazyCat I need update page http://www.gtk.org/language-bindings.html , then Haskell newbie will know: Wow, Haskell is support Gtk+ 2.18.3 fully, just few languages got it. :)
23:48:32 <kmc> @quote simonSaysPerformIO
23:48:33 <lambdabot> lilac says: ponders whether unsafePerformIO would be better as simonSaysPerformIO
23:48:44 <Cale> kmc: Top level IO actions?
23:50:02 <Cale> kmc: Is this the suggestion from the people who want to sabotage their own scalability and modularity? ;)
23:50:10 <Sgeo> Would test = unsafePerformIO $ newIORef 'A' be a global variable?
23:50:24 <kmc> Sgeo, yes, and you have to be careful with those
23:50:28 <Cale> Sgeo: Well, module-local, but yeah.
23:50:30 <kmc> rather, it's a global *reference cell*
23:50:38 <Cale> yeah
23:50:39 <kmc> what we mean by "variable" in Haskell is different from what most languages mean
23:50:47 <kmc> and the same as what math usually means
23:51:02 <kmc> Haskell variables don't vary
23:51:10 <kmc> they are names for values, not cells
23:51:12 <Cale> They do so.
23:51:27 <Cale> let f x = x^2 in map f [1..10]
23:51:30 <Cale> x varies
23:51:55 <Cale> They don't vary as long as they remain in scope :)
23:51:57 * Sgeo should be sleeping 3 hours ago
23:52:00 <kmc> that's how they got their name in math
23:52:07 <pikhq> Haskell variables do not mutate, rather.
23:52:17 <pikhq> DOWN WITH MUTANTS.
23:52:21 <kmc> racist
23:52:42 <Cale> I really don't like the top-level <- proposals
23:52:43 <pikhq> ... It's late. Clearly. I'm discussing mutants and Haskell in the same breath.
23:52:51 <pikhq> Perhaps I should bed go.
23:52:55 <Cale> People should learn to just put things into main properly :)
23:53:12 <kmc> Cale, it's a more principled way to handle something that people already do
23:53:24 <Cale> It's something that people *shouldn't* do
23:53:51 <kmc> but passing IORef values everywhere is really galling from a DRY perspective
23:54:20 <kmc> one can think of other solutions
23:54:25 <Cale> It's good from the perspective of being able to understand what parts of the code have access to what.
23:55:48 <Cale> In fact, I would say it's often better to go one step further and split the r :: IORef up into its readIORef r and writeIORef r
23:56:15 <Cale> (if there's something that ought to only need one of the two)
23:56:57 <kmc> StateVar allows that i think
23:57:16 <Cale> Well, so does IORef ;)
23:57:25 <Cale> and MVar, and all the others
23:57:59 <Cale> StateVar is explicitly defined in terms of analogous pairs like that, a getter and setter
