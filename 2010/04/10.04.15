00:01:40 <kingping> Is there a natural way to replace lines 88-99 in http://freebsd.pastebin.com/qYC1Jghs but still make Haskell perform evaluations ?
00:02:00 <kingping> Maybe via any kind of foldl.
00:03:35 <kingping> s/88-99/88-91/
00:12:22 <Saizan> kingping: mapM id ret
00:13:39 <Saizan> mapM_ id ret, actually
00:14:45 <kingping> But first one worked too :)
00:15:20 <Ferdirand> @type mapM_ id
00:15:21 <lambdabot> forall (m :: * -> *) b. (Monad m) => [m b] -> m ()
00:15:25 <Ferdirand> @type sequence_
00:15:26 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
00:15:33 <kingping> I then added return () to satisfy returning type.
00:15:34 <Ferdirand> what's the difference ?
00:15:58 <kingping> sequence_ AFAIR returns ()
00:16:06 <kingping> sequence in turn returns []
00:16:13 <Saizan> Ferdirand: no difference actually :)
00:16:21 <Saizan> i.e. mapM_ id = sequence_
00:16:36 <Saizan> since mapM_ f = sequence_ . map f
00:16:44 <Saizan> and map id = id
00:17:04 <Saizan> so, yeah, the most appropriate is sequence_ there
00:17:07 <kingping> Ah, yes, mapM_ allowed me to remove return ()
00:19:19 <kingping> So () is kind of void in Haskell ?
00:19:33 <pastorn> kingping: yes, but it's a value as well
00:19:35 <kingping> (being an empty tuple)
00:19:38 <pastorn> > () == ()
00:19:39 <lambdabot>   True
00:19:52 <pastorn> > () < ()
00:19:53 <lambdabot>   False
00:20:06 <kingping> > 1 == (1)
00:20:07 <lambdabot>   True
00:20:26 <Saizan> there's no singleton tuple
00:20:26 <pastorn> kingping: no, that's different, that's the same as
00:20:35 <kingping> Saizan: Yep :]
00:20:35 <pastorn> > 2 == (1 + 1)
00:20:36 <lambdabot>   True
01:29:53 <kmc> > integerToBreakfast 4
01:29:54 <lambdabot>   "Bacon, eggs, toast, tomato and mushroom. You deserve it"
01:29:54 <lambdabot> kmc: You have 1 new message. '/msg lambdabot @messages' to read it.
01:31:23 <Ferdirand> > integerToBreakfast (-1)
01:31:24 <lambdabot>   "*Exception: Prelude.(!!): negative index
01:36:02 <solrize> does anyone here use expat ?
01:36:07 <solrize> hexpat
01:36:19 <pastorn> solrize: what is that?
01:36:41 <solrize> expat is a supposedly fast xml parser written in c, that is pretty popular.  hexpat is a haskell wrapper for it
01:36:44 <solrize> in hackage
01:58:26 <lars9> hey, this simple example doesnot compile here, can you? http://www.haskell.org/haskellwiki/Simple_STM_example
02:01:46 <arcatan> lars9: it does compile here
02:03:40 <lars9> arcatan: could you please tell me your ghc version?
02:04:22 <jbapple> When was the last time @seen worked on lambdabot?
02:04:29 <jbapple> @seen god
02:04:29 <lambdabot> Unknown command, try @list
02:04:39 <jbapple> it's on the @list
02:14:51 <roconnor> ugh,  resultant /= resolvant
02:18:26 <Adamant> jbapple: god was last seen one week ago, saying: "look busy, I might be coming"
02:19:01 <jbapple> Adamant: hardy harhar
02:20:36 <Adamant> jbauman: Unknown command, try @list
02:20:50 <Adamant> arrgh, stupid autocomplete
02:20:58 <Adamant> well that pissed away that joke.
02:22:01 <jbauman> jbapple: Unknown command, try @list
02:22:04 <jbauman> fixed for you
02:23:36 <Adamant> lol thanks. sorry for the misname.
02:23:54 <arcatan> lars9: 6.8.2
02:24:34 <arcatan> lars9: what error do you get?
02:25:00 <kmc> @quote preflex
02:25:00 <lambdabot> preflex says: god was last seen on ##c++ 96 days, 6 hours, 19 minutes and 16 seconds ago, saying: I don't really know either actually
02:45:59 <aep> is there a pure version of ForM ?
02:46:12 <quicksilver> you mean "flip map" ?
02:46:14 <quicksilver> no, there isn't.
02:46:39 <aep> :/ key thanks
02:46:41 <quicksilver> although for = flip map seems reasonable, it also seems a bit odd since I normally think of a for loop as being performed for effects.
02:46:50 <aep> yeah
02:47:02 <aep> its especcially ugly since the longest part of the code is in the middle
02:47:35 <magthe> aep: there's Data.Traversable.for, if you can live with its restrictions
02:54:55 <aep> magthe: can i use that on lists?
02:55:38 <magthe> aep: I believe so: http://haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/Data-Traversable.html#t%3ATraversable
02:55:50 <magthe> aep: and [] is an instance
02:55:58 <aep> cool
02:59:02 <quicksilver> yes but it's not what aep wants
02:59:05 <quicksilver> it maps an Applicative
02:59:07 <quicksilver> action
02:59:12 <solrize> @tell bos hexpat is too slow.  i'd appreciate if you could tell me if you think using attoparsec to parse xml in the hope of beating hexpat's speed is feasible.  it would be specialized to one specific document type (multi-terabyte wikipedia dumps), not general purpose.  thanx
02:59:12 <lambdabot> Consider it noted.
02:59:12 <quicksilver> aep just wants to map a pure function.
02:59:22 <solrize> oops meant to msg the bot ;)
02:59:46 <quicksilver> Traverable.for is, in a sense "forA" instead of "forM"
03:00:28 <aep> actually i figured i want a reversed fold
03:01:37 <aep> can't i use some currying black magic to reverse the arguments? :D
03:01:59 <magthe> aep: should be possible
03:02:20 <magthe> I have to say I often do the same... think I need foo, just to find what I really wanted was bar :)
03:04:32 <quicksilver> aep: no idea what you mean by a 'reversed' fold?
03:04:45 <aep> the arguments flipped
03:05:11 <aep> this is awful http://codepad.org/jOj940bk
03:06:20 <quicksilver> aep: I don't find that awful at all.
03:06:25 <quicksilver> aep: but if you don't like it, how about : http://codepad.org/xonbQDEl
03:07:01 <quicksilver> also you have forgotten the two golden rules of foldl
03:07:01 <aep> hm good idea thanks
03:07:08 <aep> which would be?
03:07:09 <quicksilver> 1) NEVER use foldl
03:07:18 <quicksilver> 2) NEVER EVER EVER use foldl with (++)
03:07:26 <aep> uh. why?
03:07:33 <quicksilver> because it has quadratically slow performance
03:07:38 <aep> awesome.
03:07:41 <quicksilver> it keeps re-traversing the left-hand list
03:07:42 <aep> whats the alternative?
03:07:44 <quicksilver> foldr
03:07:53 <aep> i need that order though :)
03:08:09 <aep> ah, i can just append the other way round
03:08:14 <aep> thanks
03:08:43 <quicksilver> foldl (\c d -> c ++ show d) xs is better written as
03:08:50 <quicksilver> concat (map show xs)
03:09:03 <quicksilver> which is sometimes written just as concatMap show xs
03:09:10 <aep> nice
03:09:11 <quicksilver> (did I miss a reverse?
03:09:26 <zygoloid> quicksilver: don't think so
03:09:27 <quicksilver> > foldl (\c d -> c ++ show d) "" [1,2,3]
03:09:28 <lambdabot>   "123"
03:09:38 <quicksilver> > concatMap show [1,2,3]
03:09:39 <lambdabot>   "123"
03:09:53 <quicksilver> no, I didn't :)
03:10:28 <aep> thanks
03:10:42 <quicksilver> and if you want to be really obscure:
03:10:47 <quicksilver> > show =<< [1,2,3]
03:10:48 <aep> no :P
03:10:48 <lambdabot>   "123"
03:10:54 <aep> uuuh
03:10:56 <quicksilver> but I don't recommend that last transform for readable code :)
03:11:17 <quicksilver> I do recommend it for golf though.
03:13:33 <zygoloid> aep: i think i'd write that like this: http://codepad.org/hIercYmm
03:14:00 <zygoloid> (do i need that concat at the start?)
03:14:48 <quicksilver> alternatively:
03:15:09 <aep> nice and condensed. unfortunately i cant read it :D
03:15:21 <quicksilver> concat [show w | x <- W.current s : W.visible s, w <- W.integrate' . W.stack . W.workspace $ s ]
03:15:25 <quicksilver> I think.
03:15:38 <quicksilver> sorry, that final s should be an x
03:15:41 <quicksilver> concat [show w | x <- W.current s : W.visible s, w <- W.integrate' . W.stack . W.workspace $ x ]
03:15:51 <aep> you can actually do nested loops in that? cool
03:15:57 <quicksilver> yup
03:16:15 <quicksilver> with a better choice of names for 'x' and 'w' I find that quite readable
03:16:28 <quicksilver> I can't choose the names because I don't know what you're doing :)
03:16:28 <aep> indeed. i like it
03:16:35 <aep> thats xmonad
03:16:44 <quicksilver> concat [show gadget | widget <- W.current s : W.visible s, w <- W.integrate' . W.stack . W.workspace $ gadget ]
03:16:56 <quicksilver> concat [show gadget | widget <- W.current s : W.visible s, gadget <- W.integrate' . W.stack . W.workspace $ widget ]
03:17:00 <quicksilver> (got it wrong again! doh)
03:17:07 <aep> ah you mean those. i just copy pasted. i have no idea what it is
03:17:16 <aep> but it works. heh
03:17:53 <aep> concatMap is nice
03:19:58 <ivanm> how do I find which exceptions readFile can throw?
03:20:09 <ivanm> specifically, I'm wanting to catch it when ghc complains about the locale
03:20:23 <ivanm> s/locale/encoding/
03:21:15 <quicksilver> ivanm: read the source. Ask the developer.
03:21:25 <quicksilver> ivanm: now write an essay on how exceptions are not a composable or scalable technique.
03:21:29 <quicksilver> ;)
03:21:30 <aep> aarg. now i need a monag inside.  any non pure version of concatMap ? :(
03:21:34 <ivanm> quicksilver: heh
03:21:47 <ivanm> quicksilver: I was hoping reading the haddock docs would suffice :s
03:21:55 <quicksilver> I admire your optimism.
03:21:58 <ivanm> quicksilver: so, how would you prefer to do all this stuff then?
03:22:10 <quicksilver> ivanm: I'd rather not do it. And just complain about it in IRC channels.
03:22:17 <ivanm> lol
03:22:18 <quicksilver> don't come looking to me for answers, this problem is HARD :)
03:23:01 <ivanm> quicksilver: so whenever System.IO.* can't read/write/whatever to a file due to permission problems, etc. it should start up an IRC session and let the bitching commence?
03:23:26 <fasta> quicksilver, how is it hard? There are two choices: either explicit (via a disjoint sum) or implicit (exceptions).
03:24:15 <quicksilver> fasta: the hard part is providing a sensible system whereby the programmer can reasonable know what exceptions might be thrown
03:24:21 <ivanm> fasta: I'm guessing the difficulty is how do you have an exception system that's obvious (e.g. you can tell immediately which exceptions are possibly thrown in Java) but non-intrusive (like Java's exceptions are by forcing you to put them up the chain)
03:24:34 <quicksilver> fasta: ...hard to do in a way which is composable and scalable.
03:25:00 <fasta> quicksilver, if you read a file, and you don't want your program to crash, you just have to handle all the cases.
03:25:08 <quicksilver> but you don't know what all the cases are
03:25:13 <fasta> Of course you do.
03:25:28 <quicksilver> you don't, because they aren't documented.
03:25:30 <fasta> It is just that it currently is not documented in the type.
03:25:39 <quicksilver> they aren't documented *at all*
03:25:41 <fasta> I am saying that this should be done if you want to get rid of it.
03:25:43 <quicksilver> in the type or anywhere else.
03:26:00 <quicksilver> and it's hard to document them scalably, because they can change when a lower-level module changes
03:26:14 <quicksilver> like a new filesystem module is introduced with new exceptional behaviours
03:26:37 <quicksilver> (this is not a made up example - NFS causes lots of unix code to perform badly because it can exhibit exceptional behaviours in new ways)
03:26:43 <fasta> quicksilver, you can argue that that would constitute a completely new system.
03:26:58 <fasta> quicksilver, e.g. readFileOnNewFileSystem.
03:27:05 <quicksilver> you can, yes.
03:27:07 <aep> i cant use monads  [|x<-here] either can i?
03:27:30 <fasta> And if you want to use old code, you could write code generation tools to help with that.
03:27:33 <quicksilver> but pragmatically you expect a readFile which works over all file systems.
03:27:42 <quicksilver> and therein lies the problem.
03:27:46 <quicksilver> aep: no, sadly not
03:27:52 <quicksilver> @hoogle concatMapM
03:27:53 <lambdabot> No results found
03:28:04 <quicksilver> you can do concat (mapM .... ) of course
03:28:13 <quicksilver> erm, not likely to be helpful
03:28:18 <aep> there isnt even foldrM :(
03:28:19 <quicksilver> (liftM concat) (mapM ....), rather
03:28:25 <quicksilver> actually there is.
03:28:27 <aep> uuh lift?
03:28:28 <quicksilver> it's just called 'foldM'
03:28:33 <aep> foldM is left
03:28:42 <quicksilver> :t foldM
03:28:43 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
03:28:48 <dschoepe> aep: liftM == fmap
03:28:53 <fasta> quicksilver, so, the problem is that you cannot write programs against undefined environments that always work? Well, that sounds like something impossible to solve, not hard.
03:29:08 <quicksilver> fasta: yup.
03:29:21 <fasta> quicksilver, so, that makes it useless to discuss, no?
03:30:09 <ivanm> how can I define a function in ghci and provide the type signature?
03:30:27 <zygoloid> fasta: not useless to discuss while other people are still handing us impossible requirements to implement :)
03:30:39 <dschoepe> ivanm: let f = ((\x -> ...) :: type)
03:30:44 <ivanm> aha
03:30:53 <ivanm> I tried using foo x = ... :: type
03:30:55 <ivanm> but that failed :s
03:31:36 <Saizan> let foo :: type; foo x = ...
03:32:13 <quicksilver> fasta: well, no, because it's a real engineering problem.
03:32:40 <quicksilver> fasta: the fact there isn't a perfect solution doesn't prevent discussions about finding a least-worst imperfect solution.
03:33:05 <ivanm> grrrr..... ghc[i] still bitches about "*** Exception: /usr/share/graphviz/graphs/directed/Latin1.gv: hGetContents: invalid argument (Invalid or incomplete multibyte or wide character)" :@
03:33:31 <quicksilver> "How do you design and document an extension system sensitive to the fact that low-level modules may define new exception types and high-level modules, or consumers, want to be able to respond to them sanely"
03:33:46 <quicksilver> 'subclassing' or a hierarchy of exceptions is a partial solution, for example.
03:34:07 <quicksilver> ivanm: hGetContents probably only reports encoding errors lazily (i.e. probably uselessly)
03:34:21 <quicksilver> there must be another way to get the encoding errors in a more timely fashion, I think.
03:34:28 <quicksilver> (but I'm not familiar with the new IO libraries, alas)
03:34:31 <quicksilver> "new"
03:36:26 <bastl> what does the output of ":info MyGADT" mean, especially the "~" and the $-varaiables ? e.g. I have a constructor shown as "Expr :: (($a) ~ Expr) => AST Expr"
03:37:54 <Saizan> weird that you get to see that, it's almost an implementation detail
03:38:41 <Saizan> bastl: i guess that constructor is defined as "Expr :: AST Expr" right?
03:38:55 <bastl> yes
03:39:19 <Saizan> ok, so, since ~ is type equality
03:40:10 <Saizan> and when you pattern match on Expr you get in scope the fact that the index of the value you're pattern matching on is equal to Expr
03:40:23 <Saizan> i guess $a is the index
03:41:13 <Saizan> though at that point it'd make more sense to write "Expr :: (($a) ~ Expr) => AST ($a)" to me
03:41:17 <bastl> you mean the index "Expr" i give to AST in the resulkt ?
03:41:33 <bastl> hm
03:41:46 <bastl> complicated stuff ...
03:43:21 <Saizan> well, it's an implementation detail in the end, i'd file a bug against :info
03:43:26 <bastl> but at least syntactically i have an idea
03:45:37 <bastl> BTW: what is the relation between GADTs and "many sorted signatures" ? Is it the same ?
03:46:16 <Saizan> never heard of "many sorted signatures"
03:46:50 <MoALTz> would you say that it's undefined (according to the monad laws) whether bind affects the state itself
03:48:08 <Saizan> "m >>= return = m" so it's not easy for >>= to affect much
03:49:02 <bastl> Saizan see e.g. http://homepages.feis.herts.ac.uk/~comqejb/algspec/pr.html
03:49:14 <quicksilver> MoALTz: "the state" <- what state?
03:50:18 <MoALTz> quicksilver: looking (naively - inspired yesterday by a video i saw) at monads as if they are just a tuple of (value,state)
03:51:54 <quicksilver> that's like looking at music as if it is just a tambourine
03:52:00 <quicksilver> state monads are one example, that's ..
03:52:02 <quicksilver> all
03:52:03 <Saizan> bastl: sounds quite the same, but i don't see much about the type system there
03:52:23 <ivanm> quicksilver: :(
03:52:33 <ivanm> (r.e.: the lazy error reporting)
03:52:43 <ivanm> who should I ping? #ghc ?
03:52:58 <quicksilver> not sure who understands the new IO layer well
03:52:59 <zygoloid> bastl: "data Foo a where X :: T -> Foo (F b)" is equivalent to "data Foo a = forall b. (F b ~ a) => X T", and it's trying to show you the constructor in the latter form
03:53:07 <quicksilver> but most of them probably hang out in #ghc
03:53:24 <quicksilver> it might even be documented but I don't know where to look
03:54:04 <quicksilver> ivanm: http://haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/System-IO.html#23
03:54:16 <quicksilver> I read that as "if you need to report encoding errors, don't use lazy IO"
03:54:18 <Saizan> bastl: the main point of GADTs is that if you've "x :: AST a" and "case x of Expr -> (1); ... " in (1) you know that the 'a' is actually Expr
03:54:36 <ivanm> quicksilver: :s
03:54:46 <Saizan> bastl: where (1) there was meant as a placeholder, not as the valid haskell expression, sorry :)
03:55:04 <quicksilver> Saizan: another case for turning colours back on in this channel.
03:55:15 <bastl> ah, hard to make two such conversations at a time.
03:55:32 * Saizan is not sure how to use colours with irssi, anyhow
03:55:43 <bastl> zygoloid: so ~ is type equality, or isomorphy, or what?
03:55:59 <Saizan> equality
03:56:20 <bastl> Can i use that in expressions ?
03:56:27 <zygoloid> only in type contexts
03:56:52 <zygoloid> @type let f :: (a ~ Int) => a -> a; f = id in f
03:56:53 <lambdabot> Int -> Int
03:56:56 <bastl> I have to hunt down a very complicated typing error, and cant follow the type inference, nor do i understand the types fully.
03:57:30 <zygoloid> @type let f :: (Maybe a ~ f Int) => f Bool -> (a, a); f = undefined in f
03:57:31 <lambdabot> Maybe Bool -> (Int, Int)
03:57:51 <Saizan> @type let f :: (a ~ Int) => a -> String; f x = [x] in f -- more interesting
03:57:51 <lambdabot>     Couldn't match expected type `Char' against inferred type `Int'
03:57:52 <lambdabot>     In the expression: x
03:57:52 <lambdabot>     In the expression: [x]
03:57:59 <Saizan> doh
03:58:04 <Saizan> @type let f :: (a ~ Char) => a -> String; f x = [x] in f -- more interesting
03:58:05 <lambdabot> Char -> String
03:58:44 <Saizan> it let me use that 'x' to form a String even if it's type was 'a', because in the context i had that a is equal to Char
03:59:38 <bastl> now you use it more as a binding.
04:00:14 <Saizan> (a ~ Char) is still in the typeclass context part of the type
04:00:47 <Saizan> and no, it's not binding 'a' there, the implicit forall is doing that :)
04:01:15 <Saizan> maybe we should have an explicit version of all of this, so it'd be more obvious..
04:03:10 <pikapika> does anyone have a tutorial on writing haskell bindings?
04:04:15 <tambourine> I think there's such a ting in Real World Haskell
04:04:31 <quicksilver> for the case of simple C functions it's very simple
04:04:42 <quicksilver> gets more fiddly if you have to marshal/unmarshal C structs etc.
04:05:27 <pikapika> is there anything that converts a header file to bindings?
04:06:48 <tambourine> hsc2hs might be what you're looking for
04:06:58 <quicksilver> also c2hs
04:16:42 <bastl> ::r
04:16:54 <bastl> oops
04:19:58 <alpounet> hi
04:28:15 <aep> this is so incredible bad code. any idea how i can at least shortcut those returns? http://codepad.org/elirzPE2
04:29:17 <ivanm> aep: return $ case w == ws of ...
04:29:39 <quicksilver> ivanm: you can just put the return outside the outer case
04:29:40 <ivanm> you could also define a bool :: a -> a -> Bool function
04:29:41 <ivanm> and use maybe
04:29:44 <quicksilver> sorry that was for aep
04:29:54 <ivanm> quicksilver: right, missed that he used return for Nothing as well
04:29:59 <aep> yeah good idea. at least return outside helps
04:30:05 <wavewave_> hello..
04:30:06 <quicksilver> I would use a guard instead of a nested boolean case
04:30:11 <quicksilver> I will edit the paste one moment
04:30:28 <wavewave_> how can I change UArray Int Int to Ptr (CInt) for FFI?
04:31:32 <quicksilver> aep: http://codepad.org/z2FloWbj
04:31:52 <quicksilver> wavewave_: go via a list, and map fromIntegral
04:32:11 <aep> quicksilver: indeed. looks slightly better
04:32:34 <quicksilver> wavewave_: and Foreign.Marshal.Array.newArray
04:32:47 <aep> but i was most interested if there is a way to have Nothing and w!=ws end up in the same branch. instead of duplicating that
04:33:25 <quicksilver> yes, there is
04:33:32 <quicksilver> I didn't notice until now they were the same
04:34:09 <quicksilver> aep: http://codepad.org/mbY7xIdK
04:34:25 <aep> aah! nice
04:34:27 <aep> thank you
04:34:37 <wavewave_> quicksilver: thx a lot!
04:35:06 <quicksilver> aep: you could also factor out the "c++" and "++"<fc=#666> | </fc>"" which is common between the two branches
04:35:32 <aep> yeah
04:39:42 <quicksilver> aep: http://codepad.org/P1qCmWXX ?
04:40:23 <quicksilver> can't decide if I like the 'let' on markedupname or if I would just inline the definitio.
04:40:26 <aep> interesting. didnt think that way
04:40:30 <quicksilver> In practice I think I'd probably do the latter
04:46:35 <ivanm> hi malcolmw
04:49:17 <malcolmw> ivanm: hi
04:49:18 <lambdabot> malcolmw: You have 1 new message. '/msg lambdabot @messages' to read it.
04:50:33 <ivanm> malcolmw: just wanted to check something: with polyparse, for some reason the default implementation of bracket (even if I remove the implicit commit; at least for lazy versions) doesn't seem to deal too well if you have to different parsers separated with `onFail` where the bra and ket parsers are identical but the interior is different
04:51:16 <ivanm> specifically, if the first one fails (because the interior parser doesn't consume everything and so the ket parser fails), then it doesn't seem to go back up to the "top" of the parser and just fails completely
04:52:38 <ivanm> whereas the redefined I have here seems to work (haven't checked if the maybe is actually needed): http://code.haskell.org/graphviz/Data/GraphViz/Parsing.hs
04:52:44 <ivanm> it seems the discard is too lazy
04:52:45 <malcolmw> ivanm: good question
05:00:03 <malcolmw> ivanm: the original formulation of discard was indeed too lazy - I fixed it in a patch dated 10th Dec, which should be in polyparse-1.4
05:01:26 <ivanm> well, that's what I'm using
05:01:44 <malcolmw> ivanm: maybe it is still too lazy for some reason
05:02:10 <ivanm> malcolmw: I think that if there's an error for the discarded parser, it isn't applied/forced until later
05:03:00 <ivanm> OK, that optional stuff isn't needed; "do open; a <- pa; close; return a" seems to work
05:03:46 <dancor> open >> pa <* close
05:04:22 <ivanm> @type (<*)
05:04:23 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
05:04:29 <ivanm> dancor: polyparse doesn't have Applicative instances
05:04:33 <dancor> i'm that guy, the one that restates your expression without even reading one line up
05:04:45 <ivanm> `discard` is meant to do what <* does, but it seems to be too lazy
05:04:57 <dancor> ivanm: right but any monad is an applicative
05:05:04 <ivanm> dancor: only if you define the instance
05:05:06 <dancor> haskell is just crazy
05:05:06 <dancor> ya
05:08:23 <dancor> you could also just define a (<*) for your thing i guess
05:14:09 <cads> Is there a number type for naturals?
05:14:22 <cads> Can't find it in the number hierarchy
05:15:18 <bastl> I have a type-checking problem probably related to pattern-matching against a GADT constructor. (using the zipper-0.3). Here is my example code: http://codepad.org/Um5KVhD9 Can someone see the problem? I dont understand it.
05:15:19 <JuanDaugherty> natural = positive definite integers?
05:15:40 <cads> hehe, positive definite, eh?
05:16:08 <cads> > [0..]
05:16:09 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
05:16:13 <cads> these guys :)
05:16:40 <bastl> @type [0..]
05:16:41 <lambdabot> forall t. (Num t, Enum t) => [t]
05:17:13 <bastl> that's their type i guess :)
05:17:42 <cads> I think I can say data Nat = 0 | Succ a
05:18:13 <Itkovian> BOOM analytics. Sounds like an FP opportunity. Erm, a Haskell opportunity. Reduce boilerplate code, let programmer fcus on essence, etc.
05:18:40 <cads> Itkovian: I want in on that
05:18:59 <Itkovian> cads check out the eurosys paper. they're presenting right NOW! :-)
05:19:33 <idnar> @type Nat
05:19:34 <lambdabot> Not in scope: data constructor `Nat'
05:19:38 <idnar> er, no
05:19:39 <idnar> @hoogle Nat
05:19:40 <lambdabot> Text.Parsec.Token natural :: GenTokenParser s u m -> ParsecT s u m Integer
05:19:40 <lambdabot> Text.ParserCombinators.Parsec.Token natural :: GenTokenParser s u m -> ParsecT s u m Integer
05:19:40 <lambdabot> Text.Parsec.Token naturalOrFloat :: GenTokenParser s u m -> ParsecT s u m (Either Integer Double)
05:19:55 <idnar> bah
05:19:57 <Itkovian> right now they use overlog, some prolog like thingie
05:20:06 <Itkovian> from what I see
05:20:39 <idnar> cads: there's a Nat or Natural type somewhere, but I don't recall exactly where
05:20:48 <bastl> @hoogle Int
05:20:48 <lambdabot> module Data.Int
05:20:48 <lambdabot> Text.Read Int :: Integer -> Lexeme
05:20:48 <lambdabot> Text.Read.Lex Int :: Integer -> Lexeme
05:20:59 <bastl> @hoogle Integer
05:20:59 <lambdabot> Text.Parsec.Token integer :: GenTokenParser s u m -> ParsecT s u m Integer
05:20:59 <lambdabot> Text.PrettyPrint.HughesPJ integer :: Integer -> Doc
05:21:00 <lambdabot> Language.Haskell.TH.PprLib integer :: Integer -> Doc
05:21:15 <cads> I think it's one of those trivial things we define as a first example of a recursive datatype.
05:21:44 <idnar> cads: well, the one I'm thinking of has a binary representation, so it's a bit more efficient
05:22:55 <cads> Haha, doing  data Nat = Zero | Succ Nat never ceases to amaze me
05:23:11 <idnar> @type S
05:23:12 <lambdabot> Not in scope: data constructor `S'
05:25:37 <cads> hmm, I'm going to try to find the alternative number stack
05:26:03 <cads> I bet they've got a better organized more mathematical hierarchy
05:26:10 <cads> with nats :)
05:26:46 <cads> because man my nats are O(n) to compare the puppies
05:30:04 <osfameron> no, I cannot give you cheap care insurance!  comparethepuppies.com!  simples!
05:30:19 <idnar> cads: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/nat may be what I was thinking of
05:32:58 <ivanm> malcolmw: I take it the seq and const stuff is what you added to discard for 1.4?
05:33:49 <cads> Hehe I'm having too much fun with my   [Zero ...]  giving me Succ Zero, Succ Succ Zero, Succ SUcc Succ Zero and so no :)
05:34:44 <malcolmw> ivanm: yep, and looking at it now, I don't think it is correct
05:34:56 <ivanm> malcolmw: why not just have: do a <- pa; pd; return pa ?
05:35:17 <ivanm> that usage of apply there looks rather strange to me
05:35:47 <cads> type classes are like burritos!
05:35:56 <cads> they're like interfaces
05:35:57 <dolio> cads: At least comparison is presumably only O(min(m,n)).
05:35:57 <malcolmw> ivanm: yes, it is definitely wrong
05:36:14 <malcolmw> ivanm: doh!
05:36:15 <dolio> cads: So you can compare infinity to some finite number in less than infinite time.
05:36:30 <ivanm> malcolmw: hang on, let me try that and see if it fixes the bracket problem
05:36:50 <cads> that's righteous in a way that makes turning happy
05:37:00 <cads> turing*
05:38:53 <ivanm> malcolmw: yup, that definition of discard seems to make bracket lazy enough for me...
05:39:10 <malcolmw> I'll patch the polyparse repo
05:39:22 <ivanm> good-o
05:39:54 <ivanm> lemme check if it even works with the adjustErrBad definition of bracket
05:40:44 <ivanm> nope; bracket can't have adjustErrBad here or else too many problems fail
05:41:12 <ivanm> (since it completely fails if the bracket isn't parsed rather than trying the next item that has the same bracket but a different interior)
05:41:43 * benmachine wonders about data BinaryNat = Zero BinaryNat | One BinaryNat
05:42:15 <philo> what is the line contuation operator (like \ in c,c++) ?
05:42:33 <ivanm> philo: same thing
05:42:35 <benmachine> (little-endian I guess, and it might help to have an explicit end thing)
05:42:42 <ivanm> philo: for strings that is
05:42:42 <benmachine> philo: are you talking about inside string literals?
05:42:51 <ivanm> an \ at the end of one line, and a \ at the beginning of the next
05:42:51 <benmachine> end the line with \ and start the next one with \
05:43:08 <benmachine> (the latter is so you can avoid putting your indentation in the literal)
05:43:18 <ivanm> benmachine: hah! beat you! :p
05:43:23 <ivanm> dammit, you provided an explanation though :(
05:43:42 <benmachine> ivanm: from here you didn't
05:43:50 <ivanm> hmmmm......
05:43:56 <philo> not
05:43:57 * ivanm blames benmachine's client :p
05:43:58 <benmachine> the gap was small enough to be eaten in the latencies I guess
05:44:05 <philo> not inside string literals
05:44:11 <ivanm> philo: then you don't
05:44:15 <ivanm> why would you want to?
05:44:17 <benmachine> philo: just... carry on writing on the next line?
05:44:21 <ivanm> what kind of line are you wanting a split?
05:44:34 <ivanm> philo: e.g. have a . or $ start the next line (just make sure you indent it)
05:44:35 <quicksilver> philo: .. but make sure you indent it enough to be 'inside' whatever layout block you were in.
05:44:41 <benmachine> you can't split mid-identifier that would be perverse
05:44:50 <benmachine> (can you do that in C?)
05:45:22 <philo> thanks
05:45:25 <philo> it s working
05:45:26 <ivanm> but if your identifiers are that long then you have other problems :p
05:45:36 <benmachine> oh daaaang it works
05:45:44 <benmachine> int ma\
05:45:45 <benmachine> in(void)
05:46:05 <cads> Hey I'm gong to fork out on real world haskell
05:46:24 <cads> before I do anyone wanna pat me on the back an tell me I'm doing the right thing?
05:46:42 <cads> Or give me grave and soul shattering warning that I am in peril?
05:47:00 <nlogax> i enjoyed it, as a total noob
05:47:45 <ivanm> cads: it's a good book to learn more advanced topics
05:47:54 <ivanm> also has some of the best explanations of monads
05:48:05 <ivanm> it's not good as an introductory text, but I presume you don't need one of those
05:48:28 <cads> Basically looking for a workbook
05:48:53 <cads> I think I'll trust your judgement on this one ivanm
05:49:20 <systemfault> RWH was a bit bad for me (With no prior knowledge of Haskell)
05:49:43 <systemfault> But once I read learn you a haskell, RWH was a good choice
05:49:44 <Adamant> cads: you can read it online for free if you need a sample
05:49:52 <medical> that 'real world' aspect makes it really enlightening. things appear out of need, not just out of fancy to abstract some more ;)
05:50:09 <ivanm> cads: :o
05:50:52 <cads> I like the pragmatic take on admitting "yeah, you need to know how to work on json so this is how you get it done.
05:51:24 <cads> and I'm sure it'll be a bunch of great examples to work through
05:51:57 <cads> and in the end, it looks beefy enough to stay on my bookshelves as the go-to book for most haskell questions
05:58:51 <EvanR> i wonder what it says about databases
05:59:05 <EvanR> because the real world needs a non crashing mysql driver
05:59:47 <Jafet> mysql is crap
06:00:26 <EvanR> whats a recommended alternative
06:00:40 <systemfault> Is postgres any better?
06:00:47 <systemfault> (DB noob here)
06:00:49 <Jafet> To do what?
06:01:05 <systemfault> Database stuff I guess.
06:01:52 <EvanR> exactly
06:02:33 <Jafet> What the hell is "database stuff". Use real words not management buzzwords...
06:02:50 <EvanR> insert, delete, update
06:03:00 <EvanR> select
06:03:30 <Jafet> So you want SQL for the sake of using SQL
06:03:47 <Jafet> I'd use sqlite
06:03:52 <orlandu63> mysql is fine for a beginner. postgres requires some command-line fu to work properly at first
06:04:11 <EvanR> for the sake for insertting, deleting, updating, and selecting data that the boss people like to select update insert delete
06:04:14 <Jafet> Because it specifically does not follow the SQL standard, and instead gets a few little things right
06:04:46 <orlandu63> mysql has phpmyadmin which is a godsend, postgresql also has phppgadmin, but as i said postgresql requires some manual work to set up at first, which may be intimidating for a beginner (it was for me)
06:05:00 <Twey> It's not that tricky
06:05:13 <Twey> There are plenty of guides out there
06:05:20 <Twey> MySQL requires some setup, too
06:05:29 <orlandu63> relatively less setup
06:05:36 <EvanR> im thinking we need to look into postgresql, if its considered more serious
06:06:05 <Twey> As I recall, it's a bit of a nightmare to get MySQL to accept external connections.
06:06:08 <Jafet> God forbid we should program trivially!
06:06:12 <Twey> Heh
06:07:07 <EvanR> mysql external connections is a matter of uncommenting the config line that says allow external connetions, but for all i know that huge commented config file was provided by the distro
06:07:32 <theorbtwo> EvanR: It probably was.
06:08:56 <EvanR> RandomGen instances are based on Int, i suppose that means i cant assume Int is a 32bit signed number
06:09:06 <EvanR> thats tricky
06:09:30 <EvanR> (if making a RandomGen instance)
06:11:38 <EvanR> maxBound...
06:12:12 <Jafet> Make your own generator, if you care
06:12:25 <EvanR> thats what im doing
06:12:39 <EvanR> but this time i was trying to make it have the RandomGen interface
06:14:51 <pbtrn10k> @djinni a-> (b -> a)
06:14:51 <lambdabot> f a _ = a
06:15:31 <pbtrn10k> @djinni (a -> (b -> c)) -> ((a -> b) -> (a -> c))
06:15:31 <lambdabot> f a b c = a c (b c)
06:15:49 <benmachine> @djinn a
06:15:49 <lambdabot> -- f cannot be realized.
06:16:09 <orlandu63> what does @djinn do?
06:16:17 <pbtrn10k> @djinni (Plus a b) -> a
06:16:18 <lambdabot> Error: Undefined type Plus
06:16:25 <benmachine> takes a typesig, tries to make a function
06:16:33 <benmachine> @djinn Either a b -> b
06:16:33 <lambdabot> -- f cannot be realized.
06:16:42 <benmachine> tries to make a total function
06:16:55 <pbtrn10k> nice one
06:17:00 <benmachine> @djinn Either a b -> Either b a
06:17:00 <lambdabot> f a =
06:17:01 <lambdabot>     case a of
06:17:01 <lambdabot>     Left b -> Right b
06:17:01 <lambdabot>     Right c -> Left c
06:17:04 <pbtrn10k> just playing rly
06:17:21 <benmachine> there's a lot of stuff it doesn't do, but it's quite neat anyway
06:17:37 <pbtrn10k> @djinni ((Either a b) -> c) -> ((a -> c),(b -> c))
06:17:38 <lambdabot> f a = (\ b -> a (Left b), \ c -> a (Right c))
06:17:42 <EvanR> @djinn a -> Complex a -> Complex a
06:17:42 <lambdabot> Error: Undefined type Complex
06:18:08 <orlandu63> pretty neat
06:18:08 <EvanR> @djinn a -> (a,a) -> (a,a)
06:18:08 <lambdabot> f _ (a, b) = (b, a)
06:18:21 <EvanR> seems to like to ignore args ;)
06:18:31 <benmachine> well, what would you have it do?
06:18:33 <pbtrn10k> who doesn't?
06:18:44 <benmachine> it has three things of type a and two outputs
06:19:03 <EvanR> @djinn Real a => a -> (a,a) -> (a,a)
06:19:04 <lambdabot> Error: Class not found: Real
06:19:11 <EvanR> @djinn Integral a => a -> (a,a) -> (a,a)
06:19:11 <lambdabot> Error: Class not found: Integral
06:19:48 <benmachine> @djinn Eq a => a -> a -> a
06:19:49 <lambdabot> f a b =
06:19:49 <lambdabot>     case a == a of
06:19:49 <lambdabot>     False -> b
06:19:49 <lambdabot>     True -> a
06:19:52 <pbtrn10k> someone told me it was good for seeing how haskell can be used to express proofs
06:19:56 <pbtrn10k> and they were right
06:20:20 <benmachine> would've been better if it'd compared a to b but never mind
06:21:04 <pbtrn10k> @djinn ((a -> c),(b -> c)) -> ((Either a b) -> c)
06:21:04 <lambdabot> f (a, b) c =
06:21:04 <lambdabot>     case c of
06:21:04 <lambdabot>     Left d -> a d
06:21:04 <lambdabot>     Right e -> b e
06:23:02 <benmachine> @djinn z -> z
06:23:02 <lambdabot> f a = a
06:23:05 <pbtrn10k> @djinn ((a -> c), (b -> c)) -> ((Either a b) -> c)
06:23:05 <lambdabot> f (a, b) c =
06:23:05 <lambdabot>     case c of
06:23:06 <lambdabot>     Left d -> a d
06:23:06 <lambdabot>     Right e -> b e
06:23:20 <benmachine> you parenthesis too much
06:23:31 <pbtrn10k> how would you write that then?
06:23:36 <benmachine> well, either
06:23:37 <pbtrn10k> (am new at haskell, not quite up to speed yet)
06:23:47 <benmachine> @djinn (a -> c, b - c) -> Either a b -> c
06:23:47 <lambdabot> Cannot parse command
06:23:54 <Itkovian> HadoopToSQL. They try to restrict the input that needs to be handled. I'm saying: lazy reeds FTW.
06:23:55 <benmachine> @djinn (a -> c, b -> c) -> Either a b -> c -- oops
06:23:55 <lambdabot> Cannot parse command
06:23:57 <mercury^> You arrow too little.
06:23:58 <benmachine> @djinn (a -> c, b -> c) -> Either a b -> c
06:23:58 <lambdabot> f (a, b) c =
06:23:58 <lambdabot>     case c of
06:23:58 <lambdabot>     Left d -> a d
06:23:58 <lambdabot>     Right e -> b e
06:24:03 <benmachine> or!
06:24:09 <benmachine> @djinn (a -> c) -> (b -> c) -> Either a b -> c
06:24:09 <lambdabot> f a b c =
06:24:09 <lambdabot>     case c of
06:24:09 <lambdabot>     Left d -> a d
06:24:09 <lambdabot>     Right e -> b e
06:24:18 <benmachine> less tupley
06:24:59 <pbtrn10k> i see
06:25:07 <pbtrn10k> thanks a lot :)
06:25:11 <orlandu63> i don't understand how (a -> c, b -> c) -> (Either a b -> c) implies f (a, b) c = ...
06:25:35 <orlandu63> the type signature implies 1 argument, the definition shows two
06:25:52 <benmachine> all functions in haskell have one argument!
06:25:53 <mercury^> It has two arguments.
06:26:06 <orlandu63> oh
06:26:13 <orlandu63> i didn't see the -> c at the end :P
06:26:14 <mercury^> There are two arrows in the head before you reach the end.
06:27:12 <mxc> hi
06:27:29 <pbtrn10k> @djinn a, Either b c -> Either (a, b) (a, c)
06:27:30 <lambdabot> Cannot parse command
06:27:37 <pbtrn10k> now i bracket to little
06:27:46 <mxc> has anyone here gotten libcurl to build, cleanly under windows + cygwin or mingw w/ the haskell platform 2010?
06:27:54 <mxc> the instructions here: http://gbacon.blogspot.com/2009/06/installing-curl-from-hackage-on-cygwin.html didn't work for me
06:27:56 <benmachine> pbtrn10k: yeah, tuples need parentheses
06:28:07 <pbtrn10k> @djinn (a, Either b c) -> Either (a, b) (a, c)
06:28:07 <lambdabot> f (a, b) =
06:28:07 <lambdabot>     case b of
06:28:07 <lambdabot>     Left c -> Left (a, c)
06:28:07 <lambdabot>     Right d -> Right (a, d)
06:28:08 <mxc> i still get the missing C library errors
06:28:24 <pbtrn10k> benmachine: cheers mate :)
06:28:34 <benmachine> woo distributibity
06:28:38 <benmachine> er, v
06:28:58 <benmachine> @djinn Either a (Either b c) -> Either (Either a b) c
06:28:59 <lambdabot> f a =
06:28:59 <lambdabot>     case a of
06:28:59 <lambdabot>     Left b -> Left (Left b)
06:28:59 <lambdabot>     Right c -> case c of
06:28:59 <lambdabot>                Left d -> Left (Right d)
06:29:00 <lambdabot>                Right e -> Right e
06:30:41 <pbtrn10k> @djinn (a -> b, b -> c) -> a -> c
06:30:41 <lambdabot> f (a, b) c = b (a c)
06:30:58 <pbtrn10k> all the classics
06:31:51 <pbtrn10k> i can't believe i spend the last four years not knowing about haskell
06:34:41 <Botje> pbtrn10k: you're four years old?! :)
06:34:41 <mercury^> @djinn Homotopy f g -> Equivalence (K f) (K g)
06:34:41 <lambdabot> Error: Undefined type Homotopy
06:34:57 <mercury^> Who forgot to define mah types? :(
06:36:36 <ivanm> dammit, I wanted to ship an executable as a stand alone script under Extra-Source-Files to avoid users having to build the graphviz library multiple times just to use it, but it uses an un-exported function :s
06:37:19 * ivanm gives up and exports it
06:38:01 <fax> what is the meaning of K f?
06:38:16 <pbtrn10k> K a function?
06:38:49 <orlandu63> K is a data constructor maybe
06:39:45 <pbtrn10k> \Botje well four year olds love Hugs ;)
06:39:56 <idnar> K is either a type constructor or a data constructor, I would think
06:39:56 <benmachine> seems to be used as a type constructor
06:39:56 <Twey> Type constructor
06:40:11 <idnar> oh, I missed the context
06:40:16 <Botje> pbtrn10k: not just four year olds :)
06:40:41 * benmachine hugs Botje 
06:41:24 <Botje> yay!
06:41:38 * Botje hugs benmachine back
06:41:48 <benmachine> :)
06:42:08 <pbtrn10k> \me has started something beautiful
06:43:32 <hauk> michaelcdever: Ohai
06:43:56 <mercury^> Anyone wants to be GHCed?
06:44:18 <benmachine> I wouldn't like to be GCed
06:45:15 <systemfault> Oh well.. I'd prefered to be GC'ed by GHC than by the JVM
06:46:39 * magthe just re-discovered the Paths_foo module that Cabal creates... brilliant thing that!
06:47:22 <pbtrn10k> @djinn (b -> c) -> (a -> b) -> (a -> c)
06:47:22 <lambdabot> f a b c = a (b c)
06:47:51 <gbacon> mxc: I need to update that.. I don't have a Cygwin box in front of me, but you might tinker with copying libcurl.a into ghc's lib
06:48:03 <ivanm> magthe: I just wish it was possible to have a dummy Paths_foo module for use when testing rather than having to remember to use Cabal to build the library just to have Paths_foo there :s
06:48:12 <EvanR-work> is there a built in arithmetic for Z modulo n where n is any number
06:48:15 <mxc> gbacon : wow, straight from the source :)
06:48:49 <mxc> gbacon: i tried copying it into c:\ghc\ghc-6.12.1\lib  \gcc-lib and then all the lib subdirectories under the haskell platform directory
06:49:32 <magthe> ivanm: hmm, doesn't it get created on 'Setup.hs configure'?  then you can just use GHCi after that
06:49:50 <ivanm> magthe: IIRC you have to build it still
06:49:56 <ivanm> so do a configure then do a build
06:50:06 <gbacon> mxc: but no dice for any of them?
06:50:12 <mxc> none
06:50:20 <mxc> so even your craps simulator wouldn't work
06:50:24 <gbacon> :-(
06:50:37 <magthe> ivanm: ah, yes, you are correct... silly... should be created on 'configure'
06:50:55 <ivanm> yeah
06:51:34 <mxc> gbacon: with verbose=3, the specific error is ld.exe: cannot find -lcurl
06:52:07 <mxc> so, might be a problem with the libcurl isntalled by cygwin?
06:52:17 <benmachine> or the search paths?
06:52:47 <mxc> in ld, if you pass -lcurl, it basically looks for libcurl.a in any of the directories included with -Lxxx right?
06:53:05 <benmachine> I think so
06:53:26 <benmachine> or is it libcurl.so I can never remember how that works
06:54:13 <ivanm> @ask malcolmw do you envisage making a release of polyparse with the definition of discard fixed any time soon (or should I just go and use my custom definition)?
06:54:13 <lambdabot> Consider it noted.
06:55:03 <gbacon> we need to circumvent the whole issue by lobbying to get the curl stuff in the Haskell Platform!
06:55:24 <gbacon> mxc: did you try the cabal command from Max's comment?
06:55:26 <Jafet> curl is hideous
06:55:30 <ivanm> gbacon: opengl in the platform is a big enough problem because it depends on a C library
06:55:40 <ivanm> I don't think they'd be too happy having another C library as a dep
06:55:52 <ivanm> now, if darcs supported the latest version of HTTP, I'd be tempted to use that
06:56:08 <mxc> the most frustrating thign about this is i dont even need curl
06:56:17 <mxc> i need HXT, and not even the automagic http fetching bits
06:56:17 <ivanm> but it still only supports 3000.x rather than >= 4000
06:57:00 <gbacon> mxc: I thought hxt had been bifurcated with respect to the curl dependency?
06:57:01 <orlandu63> Jafet: how so?
06:58:12 <Jafet> Well, I'm talking about the C interface to it
06:58:25 <Jafet> Although most bindings I've seen tend to copy it
06:59:40 <gbacon> or maybe I just made that up...
07:00:23 <Twey> gbacon++
07:02:50 <mxc> gbacon, i wish you wiere right
07:04:00 <mxc> ok
07:04:03 <mxc> progress
07:04:08 <gbacon> mxc: yeah, it looks like xslt is what moved
07:04:20 <mxc> Haskell Platform\2010.0.0
07:04:27 <mxc> Haskell Platform\2010.0.0\gcc-lib was the right target
07:05:07 <mxc> but, now when i build it, i get all sorts conflicting definitions between socket.h from cygwin and winsock2.h from mingw in the haskell platform
07:05:19 <gbacon> mxc: yeah, that rings a bell
07:07:47 <gbacon> mxc: if you're really anxious to have a working hxt, you might try building libcurl from source with Haskell's gcc. I've never tried it, so you may end up trading one set of frustrations for another.
07:08:33 <mxc> well, the alternative is just to run arch inside VB on my windows machine
07:09:52 <hpc> visual basic? :P
07:10:23 <benmachine> :t (id . id .)
07:10:24 <lambdabot>     The operator `.' [infixr 9] of a section
07:10:24 <lambdabot>         must have lower precedence than that of the operand,
07:10:24 <lambdabot>           namely `.' [infixr 9]
07:10:29 <benmachine> ^ why doesn't this work :(
07:10:52 <hpc> :t ((.) id id) .
07:10:53 <lambdabot> parse error (possibly incorrect indentation)
07:10:55 <mxc> virtual box
07:10:59 <systemfault> hpc: Eww Vulgar words!
07:10:59 <hpc> :t (((.) id id) .)
07:11:00 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f a
07:11:05 <benmachine> I guess it could have surprising results
07:11:11 <hpc> yeah, i was just being a smartass :P
07:11:34 <benmachine> :t ((id . id) .) -- this works fine but the parentheses seem unnecessary
07:11:35 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f a
07:11:56 <gbacon> mxc: that seems like a sane stopgap until we can figure out a proper native solution
07:11:58 <hpc> the parenthesis keep the interpreter from choking
07:12:01 <hpc> :t $
07:12:02 <lambdabot> parse error on input `$'
07:12:06 <hpc> :t ($)
07:12:07 <lambdabot> forall a b. (a -> b) -> a -> b
07:12:14 <benmachine> but I think the trouble with (id . id .) is that id . id would have to be evaluated first, which is contrary to the expected associativitty
07:12:18 <benmachine> -t
07:14:21 <hpc> @pl ((id . id) .)
07:14:21 <lambdabot> id
07:14:30 <benmachine> @pl id . id
07:14:30 <lambdabot> id
07:14:32 <benmachine> neat
07:14:35 <benmachine> @pl f . id
07:14:35 <lambdabot> f
07:14:43 <hpc> @pl id.f
07:14:43 <lambdabot> f
07:15:18 <hpc> moral of the story: ugly compositions of id are mostly pointless
07:15:23 <hpc> (no pun intended)
07:16:00 <yottis> @pl map id
07:16:01 <lambdabot> id
07:16:06 <yottis> nice
07:16:22 <alpounet> http://blog.llvm.org/2010/04/extensible-metadata-in-llvm-ir.html would be nice for the llvm backend
07:16:30 <yottis> @pl map f . map g
07:16:30 <lambdabot> map (f . g)
07:18:27 <hpc> @pl (. <$> $)
07:18:27 <lambdabot> (line 1, column 2):
07:18:27 <lambdabot> unexpected "."
07:18:27 <lambdabot> expecting lambda abstraction or expression
07:18:38 <hpc> @pl ((.) <$> $)
07:18:38 <lambdabot> (line 1, column 10):
07:18:38 <lambdabot> unexpected "$"
07:18:38 <lambdabot> expecting space or simple term
07:18:46 <hpc> @pl (. <$> ($))
07:18:46 <lambdabot> (line 1, column 2):
07:18:46 <lambdabot> unexpected "."
07:18:46 <lambdabot> expecting lambda abstraction or expression
07:18:56 <hpc> bleh
07:19:10 <systemfault> alpounet: I tried to recompile it recently and had some weird problems where programs compiled with the resulting GHC were 32MB and super slow
07:19:13 <systemfault> :P
07:21:11 <alpounet> hmm systemfault weird
07:21:29 <systemfault> Yep.. I'll retry it when I'll get time
07:21:33 <alpounet> mines just smash the NCG
07:21:43 <alpounet> up to 3x speedup
07:21:53 <systemfault> Nice :)
07:23:05 <mxc> its amazing how much faster VBox is on an overclocked, core i7 desktop w/ 4gb ram than my shitty acer netbook
07:23:16 <mxc> well, not exactly amazing, but pleasant :)
07:23:49 <systemfault> :'(
07:23:53 <systemfault> Why!
07:24:01 <systemfault> Overclocking an i7 :(
07:34:46 * byorgey makes lambdaberry pancakes with fmaple syrup
07:35:25 <jmcarthur> i love how i can update my haskell packages at the same time as my system packages with bauerbill
07:37:10 <quicksilver> does sound quite clever
07:37:14 <quicksilver> arch has some shiny toys.
07:42:04 <orlandu63> jmcarthur: you mean the ones through AUR or through cabal?
07:42:53 <alpounet> AUR
07:47:18 <shapr> HASKELL! YAY!
07:48:45 <byorgey> =D
07:49:06 * byorgey is writing a poem about Haskell
07:49:16 <byorgey> it is going to be the best poem EVAR
07:49:34 <BONUS> but nothing rhymes with haskell
07:49:37 <quicksilver> byorgey: is it composed entirely of quotes taken from this channel?
07:49:55 <byorgey> quicksilver: wow, that would be fun.  maybe I will have to write a second poem.
07:50:13 <dankna> ooh ooh.  rhyme it with "pell-mell".
07:50:24 <quicksilver> "task all" "bask all" "flask all"
07:50:33 <byorgey> I would have to first write a program (in Haskell, naturally) to sort quotes from the channel by meter and rhyme
07:50:58 <byorgey> although I suppose I could do free verse
07:51:00 <dankna> sounds like a fun project
07:51:12 <zygoloid> BONUS: seagull?
07:51:13 <byorgey> heck, the program could just write the poem
07:51:24 <BONUS> oh wait
07:51:26 <BONUS> rascall!
07:52:10 <zygoloid> you guys pronouce haskell completely differently from me :o
07:52:12 <byorgey> There once was a BONUS who liked to write Haskell / but he needed to finish his book, the old rascal
07:52:24 <quicksilver> no, I was being forgiving in the rhymes
07:52:27 <dankna> "Eating an orange / while making love / leads to bizzare enj- / oyment thereof." -- Tom Lehrer
07:52:47 <quicksilver> they're not true rhymes
07:52:55 <dankna> (speaking of difficult rhymes)
07:52:58 <BONUS> byorgey: haha, so true
07:53:10 <quicksilver> although it's pretty close, using the northern english pronunciation of 'rascal' actually.
07:53:53 <EvanR-work> you guys pronounce rascal totally different from each other
07:54:32 <quicksilver> well, the way *I* pronounce rascal does not rhyme with haskell, at all.
07:54:45 <quicksilver> but they way they pronounce rascal in the north of england is quite close.
07:54:45 <zygoloid> quicksilver: i'd say that the northern 'rascal' /is/ a rhyme of haskell, even :)
07:55:46 <quicksilver> and given that Blake himself thought he could get away with rhyming 'eye' with 'symmetry' it's clearly all cobblers anyway ;)
07:56:05 <dankna> hee
07:56:09 <dankna> that was a great poem though
07:56:32 <dankna> Tiger, tiger, burning bright / How you save electric light
07:56:43 * byorgey is very curious how other people pronounce all these words, now
07:56:45 <fax> ;D
07:56:56 <byorgey> but unsure how we could even discuss it without everyone knowing IPA
07:57:02 <jmcarthur> orlandu63: either, but i meant automatically using cabal2arch and grabbing them from hackage directly
07:57:10 <dankna> yeah, IPA is probably the easiest way, not that it's easy :/
07:57:35 <byorgey> the way I say 'rascal' and 'Haskell' they rhyme perfectly
07:57:46 <fax> same
07:57:53 <zygoloid> byorgey: what's your nationality?
07:58:01 <EvanR-work> whats the official way to pronounce haskell
07:58:02 <byorgey> USA
07:58:17 <sclv> rhyming poem autogenerated from twitter: http://www.longestpoemintheworld.com/
07:58:23 <quicksilver> byorgey: the A is short, the 'e' is indistinct (schwa)
07:58:27 <Twey> It amazes me that there are still people who don't understand IPA.
07:58:38 <byorgey> quicksilver: yep
07:58:49 * zygoloid is in the southeast of england, and rascal has a long "ar"-type A sound here
07:58:57 <quicksilver> whereas rascal has a long first A, like 'rarrr-scal'
07:58:57 <jmcarthur> yeah haskell rhymes with rascal for me too
07:59:00 <fax> what about shavian
07:59:00 <quicksilver> like a pirate.
07:59:12 <zygoloid> rascal, like a pirate :)
07:59:33 <jmcarthur> rarscal?
07:59:46 <quicksilver> the extra r is pushing the point a bit far :)
07:59:53 <quicksilver> but it is a long A in RP.
07:59:54 <byorgey> quicksilver: oh, I see.  I thought people in the UK said Haskell that way too.
08:00:03 <jmcarthur> harskell?
08:00:50 <Twey> No
08:00:51 <quicksilver> byorgey: which way?
08:00:52 <quicksilver> ;)
08:01:03 <byorgey> quicksilver: so that it rhymes with rascal =)
08:01:15 <quicksilver> nope. Rascal long A, Haskell short A.
08:01:22 <Twey> /ˈrɑːskəl/, /ˈhæskəl/
08:01:22 <byorgey> ok. I say both with a short A.
08:01:26 <jmcarthur> english sucks
08:01:38 <quicksilver> Twey: I'd have done that except I can't type unicode ;)
08:01:41 <jmcarthur> dialects, too
08:01:44 <byorgey> Twey: right, thanks =)
08:01:45 <mercury^> Uh, rascal really has a long a?
08:02:09 <quicksilver> round here it does, at least.
08:02:13 <quicksilver> and we have the queen, so we win.
08:02:16 <Twey> quicksilver: /"rAsk@l/, /"h{sk@l/ — welcome to X-SAMPA :þ
08:02:41 <zygoloid> mercury^: yup. like 'blast' and 'flask'
08:02:50 <Twey> And ‘carp’
08:02:57 <mercury^> Heh. I've never heard it pronounced like that.
08:03:10 <Twey> Are you American?
08:03:17 <mercury^> German.
08:03:35 <Twey> How odd
08:04:03 <quicksilver> not that odd; lots of people are german
08:04:05 <mercury^> Well, I suppose I mostly heard Americans say it.
08:04:07 <quicksilver> I've met some myself.
08:05:09 <Twey> It's odd because I understood that Germans were mostly taught British English with RP.
08:06:43 <byorgey> hmmm what rhymes with 'parametric'
08:07:34 <fax> flooding #haskell with parametric rhymes which stick like a brick to the thick of your nick
08:07:48 <sbahra> What?
08:08:40 <jsk> dielectric
08:08:55 <byorgey> ooh, good one
08:09:41 <sclv> forall a. Syllable a => a -> rhyme; a ++ "etric"
08:09:50 <sclv> a parametric rhyme!
08:09:56 <byorgey> hahahaha
08:10:35 <Twey> Hahahahaha, nice
08:10:42 <yottis> Twey: at least here in finland we're supposedly thought british english, but because of tv and movies and internet and games and whatnot it's not that simple
08:12:00 <yottis> i'm pretty sure all the english teachers are sent to some camp where they learn a supposedly english pronunciation, which doesn't sound english at all if you actually compare it to something found in england
08:12:31 <Twey> Haha, probably
08:12:50 <Twey> My Spanish teacher was French, and my French teacher was Polish
08:13:00 <Twey> I dread to think what my accent's like
08:13:03 <EvanR-work> how do i do an IO action on every value in a Data.Map
08:13:23 <Twey> EvanR-work: mapM_ someAction $ toList yourMap
08:13:29 <byorgey> EvanR-work: use Data.Traversable.mapM
08:13:33 <Twey> Ooh
08:13:37 <Twey> That exists?  Okay.
08:13:58 <byorgey> it essentially amounts to the same thing
08:14:04 <quicksilver> well dependending what EvanR-work meant by 'values
08:14:18 <quicksilver> it might be mapM_ someAction $ elems yourMap
08:14:22 <quicksilver> or assocs.
08:14:29 <quicksilver> (assocs == toList)
08:14:41 <EvanR-work> the B in Map A B
08:14:48 <byorgey> oh, right.  using Traversable would correspond to elems
08:14:52 <byorgey> yes, that.
08:15:11 <EvanR-work> ah. its not a map
08:15:17 <EvanR-work> its a [(a,b)]
08:15:31 <EvanR-work> now what
08:15:38 <byorgey> well then,  mapM_ (someAction . snd)
08:15:51 <quicksilver> or mapM_ someAction . map snd $ yourMap
08:15:58 <quicksilver> with a bit of fusion, it's all the same :)
08:16:15 <byorgey> right, I think of what quicksilver said first and then fuse it in my head =)
08:16:38 <EvanR-work> forM_ stats (finish . snd)
08:16:39 <EvanR-work> ;)
08:16:47 <EvanR-work> bah
08:16:59 <EvanR-work> forM_ (map snd stats) finish
08:17:04 <EvanR-work> hmm
08:19:36 <byorgey> those are the same
08:20:10 <byorgey> my rhymes parametric / are straight up electric / playas wanna hate well I'll bind you with letrec
08:20:22 <Twey> map foo . map bar == map (foo . bar)
08:21:02 <Twey> byorgey: Oh dear :þ
08:21:11 <byorgey> hehe =)
08:21:39 <quicksilver> byorgey++
08:22:11 <quicksilver> but are you a poet or a freestyler?
08:22:35 <byorgey> well, seeing how it took me like ten minutes to come up with that
08:33:55 <EvanR-work> > f (Just x) = 5 in f (Just 4)
08:33:56 <lambdabot>   <no location info>: parse error on input `='
08:34:01 <EvanR-work> > let f (Just x) = 5 in f (Just 4)
08:34:02 <lambdabot>   5
08:34:08 <EvanR-work> > let f Just x = 5 in f (Just 4)
08:34:09 <lambdabot>   Constructor `Data.Maybe.Just' should have 1 argument, but has been given 0
08:34:18 <EvanR-work> shucks
08:34:29 <EvanR-work> parentheses be damned
08:35:05 <quicksilver> well, in "f Just x" , "f" has two parameters - "Just" and "x"
08:35:13 <EvanR-work> right
08:35:17 <EvanR-work> but it could be smart!
08:35:20 <quicksilver> and then that's an error in pattern context, although it would be valid in expression context.
08:35:37 <quicksilver> it could, but the motivation here is to keep pattern syntax and expression syntax uniform
08:35:39 <EvanR-work> Just has one parameter, and cant be omitted, so it just uses that one
08:35:47 <FliPPeh__> > fmap reverse $ Just "Or like this."
08:35:48 <lambdabot>   Just ".siht ekil rO"
08:36:04 <quicksilver> EvanR-work: but in expression context the parameter can, of course, be ommitted.
08:36:10 <EvanR-work> yes
08:36:14 <quicksilver> EvanR-work: "f Just x" as an expression really is passing 'Just' as a parameter.
08:36:21 <quicksilver> > map Just [1,2,3]
08:36:22 <lambdabot>   [Just 1,Just 2,Just 3]
08:36:38 <quicksilver> so, the reason it isn't clever is to avoid parsing patterns in a different way from expressions
08:36:41 <EvanR-work> if its supposed to be uniform, let me use $ in patterns ;)
08:36:43 <quicksilver> that would be more surprising.
08:36:58 <quicksilver> yeah, allowing $ in patterns would be nice.
08:37:09 <FliPPeh__> Not really :(
08:37:16 <idnar> you can use $ in patterns, but it doesn't mean what you want :P
08:37:35 <idnar> > let f $ x = f x in 5
08:37:36 <lambdabot>   5
08:38:29 <fax> um you can't use $ in patterns
08:38:45 <fax> ??
08:38:46 <idnar> I just used it
08:38:48 <quicksilver> well, you can, and idnar just did :)
08:38:53 <quicksilver> but not meaning what EvanR-work wanted.
08:39:07 <fax> I thought f and x are patterns
08:39:16 <fax> and $ is the function being defined
08:39:24 <idnar> the thing being bound is part of the pattern
08:39:49 <quicksilver> well at least the way the grammar is worded it is
08:40:20 <quicksilver> there can, after all, be multiple things:
08:40:28 <quicksilver> let (a,b) = (3,4) in ...
08:40:36 <quicksilver> that's defining a and b, not (,)
08:40:43 <idnar> yeah, I guess I just meant the LHS
08:40:49 <quicksilver> the whole thing (a,b) is the pattern, and a and b are also patterns
08:41:00 <quicksilver> idnar: no you were right, the whole thing is also a pattern
08:41:11 <quicksilver> the grammar is (simplified) let <pat> = <expr>
08:44:42 <orlandu63> quicksilver: isn't (,) in your case a type constructor?
08:44:56 <dankna> well, a data constructor
08:45:09 <dankna> it's a data constructor rather than an ordinary function, which is why it does what you expect in a pattern match.  I think.
08:45:09 <orlandu63> ugh, always get those two confused
08:45:13 <idnar> a better example might be
08:45:20 <idnar> let a :+ b = 3 :+ 4 in ...
08:45:27 <dankna> whereas $ is an ordinary function
08:45:33 <idnar> which pattern matches on (:+)
08:45:35 <Chaze> is there no built-in for such a simple thing?
08:45:35 <Chaze> consecutive n list = if (length list < n) then [] else (take n list) : (consecutive n (drop 1 list))
08:45:43 <idnar> as opposed to let a + b = 3 + 4 in ... where you're defining (+)
08:45:59 <Chaze> consecutive 2 "hello"
08:46:00 <Chaze> == ["he","el","ll","lo"]
08:46:07 <fax> hahaha
08:46:08 <quicksilver> orlandu63: a value constructor / data constructor
08:46:27 <orlandu63> quicksilver: what is a value constructor?
08:46:35 <quicksilver> a data constructor.
08:46:36 <BONUS> Chaze: no build in for that, though it's in the split package
08:46:43 <orlandu63> oh
08:46:44 <BONUS> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/split
08:47:23 <Chaze> BONUS: which do you consider equivalent?
08:47:29 <Chaze> it's not splitEvery
08:47:31 <quicksilver> > let xs = "hello" in  transpose [xs, tail xs]
08:47:32 <lambdabot>   ["he","el","ll","lo","o"]
08:47:42 <Chaze> quicksilver: nice
08:47:45 <BONUS> > let chunks n = unfoldr (\xs -> guard (not $ null xs) >> Just (take n xs, drop n xs)) in chunks 3 "hello"
08:47:46 <lambdabot>   ["hel","lo"]
08:47:54 <quicksilver> BONUS: it's not chunks
08:47:54 <BONUS> hmm lets see
08:47:58 <BONUS> oh it's not?
08:48:03 <BONUS> ohhh, i feel silly
08:48:04 <quicksilver> his are overlapping
08:48:05 <BONUS> i see
08:50:51 <ben_m> Greetings! Is there a a concise pointfree version of (\f (a,b) -> (f a, f b))?
08:50:58 <fax> no
08:51:10 <ben_m> Pity :/
08:51:21 <Zao> Isn't there (f *** f) or something?
08:51:25 <Zao> Probably not pointless enough.
08:51:26 <contrafunktal> @type join (***)
08:51:27 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
08:51:38 <fax> yeah the arrow stuff is kind of lame imo
08:51:44 <Zao> I can never remember what the *** &&& etc do.
08:51:48 <contrafunktal> @type (`asTypeOf`(undefined,undefined)) . join (***)
08:51:48 <lambdabot>     No instance for (Arrow (,))
08:51:49 <lambdabot>       arising from a use of `***' at <interactive>:1:41-45
08:51:49 <lambdabot>     Possible fix: add an instance declaration for (Arrow (,))
08:51:55 <ben_m> oh well f *** f should work
08:51:59 <contrafunktal> @type fmap (`asTypeOf`(undefined,undefined)) . join (***)
08:52:00 <lambdabot> forall (a :: * -> * -> *) b c. (Functor (a (b, b)), Arrow a) => a b c -> a (b, b) (c, c)
08:52:12 <fax> :t curry
08:52:13 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
08:52:14 <fax> :t uncurry
08:52:16 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
08:52:29 <fax> :t (,)`on`?f
08:52:30 <benmachine> :t (Control.Category..)
08:52:30 <lambdabot> forall b a. (?f::a -> b) => a -> a -> (b, b)
08:52:30 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
08:52:38 <contrafunktal> @type (Prelude..) (`asTypeOf`(undefined,undefined)) . join (***)
08:52:39 <lambdabot> forall b c. (b -> c) -> (b, b) -> (c, c)
08:52:47 <benmachine> :t (Control.Category..) . arr
08:52:48 <lambdabot> forall (cat :: * -> * -> *) b c a. (Arrow cat) => (b -> c) -> cat a b -> cat a c
08:52:58 <fax> :t uncurry((,)`on`?f)
08:52:59 <lambdabot> forall b a. (?f::a -> b) => (a, a) -> (b, b)
08:53:06 <contrafunktal> the lambda is monomorphic, so that's the same thing   (join (***))
08:53:14 <ben_m> brain overflow.
08:53:25 <contrafunktal> :)
08:53:56 <jmcarthur> why is the arrow stuff lame?
08:54:10 <jmcarthur> fax: ^^
08:54:45 <EvanR-work> (SamuraiPizza cat) =>
08:54:56 <EvanR-work> somethin
08:55:31 <benmachine> :t (<$> Control.Category.id)
08:55:32 <lambdabot> forall a b (cat :: * -> * -> *). (Control.Category.Category cat, Functor (cat a)) => (a -> b) -> cat a b
08:56:08 <jmcarthur> arr!
08:56:14 <quicksilver> yes, Functor leads to arr
08:56:17 <benmachine> @yarr
08:56:17 <lambdabot> Keelhaul the swabs!
08:56:25 <quicksilver> and Applicative leads to &&&,*** and friends
08:56:39 <benmachine> quicksilver: I remember listening to you talking about this and thinking this is interesting I should write it down and then I didn't write it down
08:56:39 <quicksilver> arrows are just applicatives by another name.
08:56:46 <benmachine> so I rediscover it every now and then
08:57:20 <dv-> arrows are pointless
08:57:26 <benmachine> @pl arr
08:57:26 <lambdabot> arr
08:57:29 <benmachine> so it seems
08:57:33 <EvanR-work> lol
08:57:50 <ben_m> I like Arrows just because they were clearly invented by pirates
08:57:54 <ben_m> arr!
08:57:57 <BONUS> i like ***,&&&,first and second in the (->) instance i guess
08:58:07 <benmachine> I used a Kleisli once
08:58:20 <benmachine> but then I realised I didn't need it
08:58:22 <quicksilver> arrows are a natural way to structure parser/transformers
08:58:36 <ben_m> I fail at understanding what Arrows really are good for
08:58:47 <quicksilver> but they don't have such uniformly useful combinators as Monads
08:58:47 <ben_m> And when to use them instead of a Monad, for example
08:58:59 <quicksilver> so 'noticing' that something is an arrow isn't much of a combinator-reuse win
08:59:12 <quicksilver> indeed I never bothered to write an Arrow instance the last time I used one
08:59:20 <quicksilver> because there was no particular gain in doing so.
09:04:09 <EvanR-work> if you have a data Foo = Foo a a, how do you keep which a is which straight
09:04:22 <EvanR-work> for all functions that use Foo you have to get the pattern order right
09:04:34 <BONUS> EvanR-work: record syntax?
09:04:51 <BONUS> data Foo a = Foo { bar :: a, baz :: a }
09:05:19 <EvanR-work> then you have to use bar and baz to extract it, adding an extra step
09:05:28 <EvanR-work> would be nice if the compiler could tell me if i get the order wrong
09:05:38 <EvanR-work> make a and a new types?
09:05:38 <BONUS> how would it know?
09:06:11 <benmachine> making them newtypes would probably make your life more difficult
09:06:51 <benmachine> you can pattern match on records like let Foo { bar = a, baz = b } = rec in a + b
09:07:22 <BONUS> how do you get the order "wrong" if it's Foo a a? i'm afraid the halting problem catches you here :)
09:07:46 <EvanR-work> in a pattern you name them something that makes sense
09:08:08 <EvanR-work> f (Foo green red) = ...
09:08:20 <EvanR-work> using green and red in opposite order in ... would be bad
09:08:21 <lispy> hey
09:08:30 <quicksilver> EvanR-work: what benmachine said.
09:08:33 <quicksilver> pattern match on the record.
09:08:37 <quicksilver> no extra step.
09:08:43 <EvanR-work> ok
09:08:44 <EvanR-work> good
09:08:49 <BONUS> EvanR-work: but if you switch green and red in the body too then it works fine again
09:09:01 <EvanR-work> and if you dont...
09:09:24 <EvanR-work> the idea is you make more than one f, and you mix up the order because you couldnt remember
09:09:33 <BONUS> well then it doesn't. but are you expecting the compiler to know the concepts of green and red and how they apply to your problem?
09:09:37 <EvanR-work> you clearly use it in the right place in the body
09:10:03 <quicksilver> this seems to be a silly argument?
09:10:06 <EvanR-work> BONUS: yes, if a and a were type b and c instead, but were still the same data
09:10:14 <quicksilver> If you think positional parameters are error prone, use records.
09:10:25 <EvanR-work> yes
09:10:25 <quicksilver> If you think even records are error prone, use distinct types.
09:10:41 <quicksilver> the tools are there, choose your poison
09:10:42 <EvanR-work> can i make new types that dont require constructors
09:10:55 <BONUS> only synonyms
09:10:58 <quicksilver> no, otherwise you wouldn't actually be getting any protection.
09:10:58 <EvanR-work> bah
09:11:04 <quicksilver> the constructor is what keeps you from making a mistake
09:11:15 <quicksilver> without a constructor you'd have an expression which could be one of two types
09:11:24 <quicksilver> ...which gets rid of the safety you just asked for!
09:11:41 <EvanR-work> because type makes a type synonym
09:12:10 <EvanR-work> 5 is an expression that could be one of several types, but they are allowed
09:12:21 <quicksilver> yes, but that doesn't give you the type safety you ask for.
09:12:28 <quicksilver> I didn't say it was impossible
09:12:35 <quicksilver> just pointed out it doesn't acheive what you claim to want.
09:13:08 <EvanR-work> youre saying is impossible to type check without a constructor
09:13:17 <EvanR-work> in principle?
09:13:20 <quicksilver> no.
09:13:25 <quicksilver> I'm saying you wanted not to make mistakes.
09:13:28 <quicksilver> that was your objective.
09:13:33 <quicksilver> so you *must* have the two things being different
09:13:42 <quicksilver> so the compiler can complain if you got it wrnog.
09:13:50 <quicksilver> then, if the two things are the same (like the way '5' works)
09:13:58 <quicksilver> then you've lost the type safety you were asking for
09:14:39 <EvanR-work> f :: Red -> Green -> X
09:14:55 <EvanR-work> f green red = somethingThatTakesGreen red
09:15:02 <EvanR-work> seems to be checkable
09:15:04 <EvanR-work> in princple
09:15:15 <EvanR-work> wait
09:15:20 <EvanR-work> f green red = somethingThatTakesGreen green
09:15:24 <EvanR-work> there
09:18:23 <sclv> let consec n xs = map (take n) $ tails xs) in consec "hello"
09:18:30 <sclv> > let consec n xs = map (take n) $ tails xs) in consec "hello"
09:18:31 <lambdabot>   <no location info>: parse error on input `)'
09:18:45 <sclv> > let consec n xs = map (take n) $ tails xs in consec "hello"
09:18:46 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
09:18:46 <lambdabot>         against inferred type ...
09:18:55 <sclv> nevermint
09:18:59 <sclv> erm, mind
09:19:08 <quicksilver> > let consec n xs = map (take n) $ tails xs in consec 2 "hello"
09:19:09 <lambdabot>   ["he","el","ll","lo","o",""]
09:19:31 <quicksilver> > let consec n xs = takeWhile ((==2).length) $ map (take n) $ tails xs in consec 2 "hello"
09:19:32 <lambdabot>   ["he","el","ll","lo"]
09:20:11 <BONUS> it's interesting how tails is 1000 times more useful than inits
09:20:17 <BONUS> at least it appears to be
09:20:34 <benmachine> @src inits
09:20:34 <lambdabot> inits []     =  [[]]
09:20:35 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
09:20:37 <quicksilver> it's also much more efficient
09:21:09 <benmachine> > inits "bl"
09:21:10 <lambdabot>   ["","b","bl"]
09:23:18 <zygoloid> i wonder whether 'one-way' type synonyms might be possible: where i could say type' B = A, and then for every function with A but not B in the type, i automatically get another version with A replaced everywhere by B
09:24:46 <quicksilver> zygoloid: another ad-hoc overloading mechanism to run in parallell with typeclasses?
09:24:49 <quicksilver> could get messy?
09:26:18 <clanehin_> zygoloid: I don't see the motivation.
09:26:27 <zygoloid> yeah. it's especially nasty since it's trying to say 'code which does these things should not compile' and expressed in terms of permitted constructs rather than banned ones
09:26:58 <zygoloid> clanehin_: consider EvanR-work's example, where Red and Green are type synonyms for the same thing. you want to be able to use operations on the underlying type, but don't want Red and Green to be mixed up.
09:27:42 <zygoloid> is it possible to export a type synonym from a module as an opaque type?
09:28:03 <clanehin_> zygoloid: use phantom types?
09:28:38 <quicksilver> zygoloid: there have been proposals for newtypes which automatically wrapped (but not unwrapped)
09:28:46 <quicksilver> which is this general kind of thing.
09:28:58 <zygoloid> yeah.
09:29:07 <quicksilver> I'm not sure if anyone ever really thought it through to see if that was safe in the wider context of the type checker.
09:29:35 <quicksilver> arguably that is a bit like how Num literals work.
09:29:50 <fax> > [43142746595714191+23681770*n|n<-0..25]
09:29:51 <lambdabot>   <no location info>: parse error on input `..'
09:29:52 <quicksilver> 5 will automatically "wrap" into an Int but not unwrap again into a generic Num.
09:29:55 <fax> > [43142746595714191+23681770*n|n<-[0..25]]
09:29:56 <lambdabot>   [43142746595714191,43142746619395961,43142746643077731,43142746666759501,43...
09:30:06 <zygoloid> if one could export a type from a module without exporting that it was a synonym, that'd almost be right, but i guess that's really no better than GeneralizedNewtypeDeriving
09:30:07 <fax> all prime ^
09:30:28 <fax> hm maybe not......
09:30:32 <quicksilver> zygoloid: IIRC that sounds right but doesn't actually make sense architecturally.
09:30:33 <fax> no I got it wrong
09:30:54 <quicksilver> zygoloid: but I'm only repeating a vague memory of something I think someone said.
09:31:06 <quicksilver> zygoloid: and it might have been about the specific design of GHC rather than "any arbitrary haskellc ompiler"
09:31:44 <zygoloid> > [n^2 + n + 41 | n <- [0..40]]
09:31:45 <lambdabot>   [41,43,47,53,61,71,83,97,113,131,151,173,197,223,251,281,313,347,383,421,46...
09:31:47 <zygoloid> ^^ all prime
09:32:03 <fax> really??
09:32:06 <zygoloid> yeah
09:32:09 <fax> oh I see
09:32:13 <fax> n^2 that's cool
09:32:35 <jmcarthur> > last [n^2 + n + 41 | n <- [0..40]]
09:32:36 <lambdabot>   1681
09:32:51 <zygoloid> quicksilver: to be honest i think newtypes are probably a reasonable compromise as they are
09:33:41 <zygoloid> i guess ghc canonicalizes names too early for the not-exporting-the-synonym plan to be tenable?
09:35:25 <zygoloid> fax: http://mathworld.wolfram.com/PrimeDiophantineEquations.html
09:35:48 <fax> I tried to implement that in haskell but it didn't give any answer
09:37:14 <fizruk_> hi everyone! who can explain why happy shows 1 shift/reduce conflict in this bnf: http://pastebin.com/9h9YuaCM ?
09:37:22 <quicksilver> zygoloid: yes, I think so, although it keeps the non-canonical name around for error reporting in at least some cases.
09:37:46 <quicksilver> zygoloid: I also think newtypes are a working compromise :)
09:39:47 <zygoloid> > [abs (n^5 - 133*n^4 + 6729*n^3 - 158379*n^2 + 1720294*n - 6823316)/4 | n <- [0..56]]
09:39:48 <lambdabot>   [1705829.0,1313701.0,991127.0,729173.0,519643.0,355049.0,228581.0,134077.0,...
09:39:50 <zygoloid> ^^ all prime, apparently
09:40:18 <fax> ;D
09:41:04 <dankna> fizruk: did you try the --info option to Happy to get a full debug trace?
09:41:55 <dankna> looks to me like it's not a LALR(1) grammar because it isn't knowable whether you have an a_opt or just a plain 'a' until two tokens later
09:45:31 <fizruk_> dankna: when i rewrite first rule with 2 (with and without 'a') all is ok
09:47:18 <fizruk_> dankna: i thought it is identical situation
09:47:50 <fax> > sqrt(sqrt(-1)) - (1 + sqrt(-1))/sqrt(2)::Complex Double
09:47:50 <lambdabot>   1.1102230246251565e-16 :+ 0.0
09:52:36 <benmachine> apparently the context (Applicative (a e)) doesn't imply (Applicative (a (b, b')))
09:52:45 * benmachine is somewhat surprised by this
09:53:14 <Chaze> > iterate tail "Hello"
09:53:14 <lambdabot>   ["Hello","ello","llo","lo","o","","*Exception: Prelude.tail: empty list
09:53:21 <benmachine> > tails "Hello"
09:53:22 <lambdabot>   ["Hello","ello","llo","lo","o",""]
09:53:25 <Chaze> thanks
09:54:58 <orlandu63> @src tails
09:54:58 <lambdabot> tails []         = [[]]
09:54:58 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
09:56:20 <aavogt> benmachine: but is e free otherwise?
09:56:26 <benmachine> aavogt: yes
09:57:08 <aavogt> that is odd
09:58:51 <Chaze> benmachine: and if i want to iterate (map tail) ?
09:58:53 <zygoloid> benmachine: why are you surprised? ghc can't assume e ~ (b, b')
09:59:55 <aavogt> but e can be anything, no?
10:00:03 <Chaze> > iterate (map tail) ["hello","world"]
10:00:04 <lambdabot>   [["hello","world"],["ello","orld"],["llo","rld"],["lo","ld"],["o","d"],["",...
10:00:12 <Chaze> *** Exception: Prelude.tail: empty list
10:00:13 <zygoloid> 'e' can be specified (implicitly) by the caller
10:00:39 <fax> Chaze: use something which gives tail' [] = [] such as tail' = drop 1
10:00:51 <stevenmarky2> yeah a safe tail
10:00:52 <monochrom> > map tails ["a","b"]
10:00:52 <lambdabot>   [["a",""],["b",""]]
10:01:01 <monochrom> > transpose (map tails ["a","b"])
10:01:02 <lambdabot>   [["a","b"],["",""]]
10:01:16 <monochrom> works
10:01:22 <Chaze> cheers
10:01:36 <aavogt> oh, it does work
10:01:38 <zygoloid> > transpose (map tails ["abc", "de", "f"])
10:01:39 <lambdabot>   [["abc","de","f"],["bc","e",""],["c",""],[""]]
10:01:59 <zygoloid> > transpose (map tails ["a", "bc", "def"])
10:02:00 <lambdabot>   [["a","bc","def"],["","c","ef"],["","f"],[""]]
10:02:13 <aavogt> g :: Applicative (a (b,b')) => a (b,b') t -> a (b,b') t
10:02:17 <aavogt> x :: Applicative (a e) => a e t
10:02:33 <aavogt> g x  can set the type variable  e  to  (b,b')
10:03:22 <zygoloid> yes, of course. however, x = g (pure (undefined :: t)) shouldn't be allowed
10:03:40 <zygoloid> (because x has no access to an instance of Applicative (a (b, b')))
10:05:18 <zygoloid> (and also because x has to produce a e t, not a (b,b') t -- but that's really the same issue)
10:06:29 <benmachine> zygoloid: that makes sense to me
10:08:07 <cads> Hey what matrix package do you guys use for matrix things?
10:08:19 <cads> I know about hmatrix
10:08:30 <cads> has anyone else used others?
10:10:38 <hpc> if i needed them, i would roll my own, but that's just me
10:11:33 <jmcarthur> so tedious though
10:12:03 <jmcarthur> but i've used hmatrix and Vec and found them both to be tedious as well
10:12:32 <jmcarthur> but not as tedious as reinventing the wheel
10:13:11 <EvanR-work> matlab monoid!
10:13:14 <EvanR-work> .. monad
10:13:32 <EvanR-work> matnad
10:15:28 <EvanR-work> @hoogle quaternion
10:15:28 <lambdabot> No results found
10:20:32 <ksf> why is my code faster if I run it with +RTS -hr?
10:21:33 <c_wraith> vs when compiled without profiling?
10:21:42 <ksf> yep.
10:21:51 <ksf> +RTS -p is even more extreme.
10:21:51 <c_wraith> that's bizarre
10:22:06 <ksf> it's 13.6 vs. 12.3 seconds
10:22:09 <aavogt> have you looked for a ghc bug on this?
10:22:15 <aavogt> I believe there is one
10:23:13 <c_wraith> my initial point was just that +RTS -hr doesn't even work unless the profiling flag is turned on at compile time.  Compiling without profiling creating slower code is kinda scary
10:24:53 <ksf> http://hackage.haskell.org/trac/ghc/ticket/3629
10:28:26 <EvanR-work> C a => C (T a), C a b => C a (T b)
10:28:35 <EvanR-work> C can have one or two type parameters?
10:28:58 <EvanR-work> :S
10:29:27 <dankna> huh?  is that even valid?
10:29:36 <EvanR-work> i found it here
10:29:40 <EvanR-work> http://hackage.haskell.org/packages/archive/numeric-prelude/0.1.3.4/doc/html/Number-Quaternion.html
10:29:52 <dolio> They're different Cs.
10:30:14 <EvanR-work> instance C T and C a (T b)
10:30:18 <EvanR-work> :S
10:30:30 <dolio> Henning Thielemann names all classes C and all types T in his libraries.
10:30:35 <dankna> !
10:30:45 <EvanR-work> how does that even work
10:31:00 <dolio> But haddock isn't designed for that to work well.
10:31:34 <dolio> You import everything qualified and then it's Foo.C and Foo.T versus Bar.C and Bar.T.
10:33:23 <Cale> EvanR-work: I actually started working on a tool to remove this kind of sabotage from code.
10:33:38 <jmcarthur> man haskell-src-exts builds slowly
10:34:18 <jmcarthur> i'm about to write a quick preprocessor to... *ahem*... overload whitespace :)
10:34:51 <EvanR-work> Cale: so... what is C T anyway
10:35:00 <jmcarthur> depends what module you're in
10:35:00 <EvanR-work> for quaternions
10:35:26 <EvanR-work> T is Quaternion
10:35:37 <EvanR-work> C is Ring?
10:35:39 <Cale> EvanR-work: The haddock is completely unreadable, check the source code
10:36:08 <EvanR-work> ah
10:36:27 <EvanR-work> C is Vector
10:36:42 <aavogt> you could also check the destination that the identifier points to
10:37:10 <Liskni_si> fucking hell, why is that shift in fields still not fixed in haddock 2.7.2??
10:37:23 <EvanR-work> why would you rather write Vector.C and Quaternion.T than Vector or Quaternion
10:37:45 <dolio> Because you've been brain washed by writing too much ML.
10:38:09 <EvanR-work> oh i think i heard people talking abuot this in here before ;)
10:38:16 <dankna> Liskni: it's fixed for me
10:38:59 <Liskni_si> dankna: oh, seems like it's a bug somewhere else then; sorry
10:39:02 <dolio> It's kind of the Haskell/ML analogue of "you can write Fortran in any language."
10:39:18 <ruperdupe> Just starting out with Haskell. Can someone tell me how to read in a number as a Rational. Something like: read "1" :: Rational
10:39:40 <EvanR-work> > (read "1") :: Rational
10:39:43 <lambdabot>   *Exception: Prelude.read: no parse
10:40:02 <dolio> > read "1 % 1" :: Rational
10:40:03 <lambdabot>   1 % 1
10:40:18 <benmachine> > toRational (read "1" :: Integer)
10:40:19 <lambdabot>   1 % 1
10:40:25 <ksf> well, about 15 seconds vs. the 9-10 seconds wget uses isn't _that_ bad, but I'm still disappointed by the huge amount of user time.
10:40:28 <dankna> > read "8 % 2" :: Rational
10:40:29 <lambdabot>   4 % 1
10:40:38 <ksf> that's 0.84 vs. 0.05
10:40:47 <ruperdupe> Ah thats it, thanks benmachine.
10:41:03 <EvanR-work> > 6 % 3
10:41:04 <lambdabot>   2 % 1
10:41:08 <EvanR-work> :o
10:42:33 <EvanR-work> >1 % 1
10:42:55 <jmcarthur> okay, i think this is definitely something worth finally trying syb for. now if i can find some nice documentation for it... i guess i could just read one of the papers
10:44:09 <dankna> the papers are pretty good docs
10:44:12 <dankna> start from the first one
10:44:35 <jmcarthur> i had read it before but it's been a couple years and i never used it between then and now
10:45:06 <aavogt> give a chance to the alternative generic programming libraries
10:45:19 <jmcarthur> aavogt: what's good?
10:45:27 <jmcarthur> i don't know anything about them
10:45:35 <dolio> Everyone likes uniplate.
10:45:41 <jmcarthur> this is for something should be very very simple
10:45:47 * jmcarthur looks up uniplate
10:46:04 <aavogt> I dunno, I just use syb for simple stuff like updating some data in a type directed manner
10:46:11 <dolio> If simple is the goal, uniplate is probably better than syb.
10:46:32 <jmcarthur> alright cool
10:46:47 * jmcarthur blindly follows advice today
10:46:53 <benmachine> I use syb for complicated things
10:46:56 <benmachine> does that help
10:47:10 <benmachine> well not *that* complicated
10:47:13 <aavogt> http://wiki.portal.chalmers.se/cse/pmwiki.php/FP/ComparingLibrariesForGenericProgrammingInHaskell
10:47:26 <benmachine> gmapT etc.
10:48:33 <dolio> jmcarthur: Well, I haven't done an extensive comparison. But I do know that uniplate was designed to be a simpler alternative to syb for the majority of cases.
10:49:06 <dolio> And to not necessarily need all sorts of GHC extensions, not that that'd matter much for you.
10:49:20 <jmcarthur> heh
10:57:03 <ksf> ah. that's it.
10:57:18 <ksf> I shouldn't be creating a pipe for every single 4096-byte block.
10:58:06 <FliPPeh__> Piping is ALWAYS an option.
10:58:36 <ksf> ...what I mean is that I should create it once for those 350 megs.
10:59:16 <monochrom> english is retarded
11:13:53 <shapr> I wish cabal had an uninstall command that peeled off all the packages that depend on the one I'm removing.
11:14:25 <hpc> i thought it did
11:14:29 <copumpkin> nope
11:15:25 <Gracenotes> the one you're uninstalling :)
11:16:36 * sclv is a fan of handwritten compos :-)
11:16:47 <brooksbp_> When you design type system inference rules... can you use the same meta-variable to express the identity function?  e.g. If I were making a rule for Application where the function is Id... could I do... (e1 : tau1 -> tau1) (e2 : tau2) ===> e1 e2 : tau2
11:17:07 <sclv> shapr -- I think that ghc-pkg notices and makes them show up broken automatically now
11:17:19 <shapr> Yeah, it does do that.
11:17:27 <fax> brooksbp_ that is sort of insane
11:17:39 <shapr> sclv: Still, if you've tried to install ALL of hackage, it's not fun to do manually.
11:17:40 <brooksbp_> fax: why?
11:23:35 <mjrosenb> speaking of insane things
11:23:57 <mjrosenb> i have a general concept that i would love to see in a type system
11:24:18 <mjrosenb> but the only way i can think of doing it would break so many more things than it would help
11:24:19 <copumpkin> dependent types with automatic inference of arbitrary proofs?
11:24:19 <brooksbp_> Wait... can someone help me understand why that is insane?  Is it incorrect?
11:24:45 <copumpkin> benjamin pierce can
11:24:56 <fax> brooksbp_: it's "correct"
11:25:03 <fax> brooksbp_: bear in mind you are the one making the rules
11:25:25 <fax> brooksbp_: but if I was the ruler of the world and I declared everyone wear bunny slippers.. for example
11:25:35 <mjrosenb> so i want to be able to state the dependence relation of IO expressions
11:25:39 <hpc> i would wear bunny slippers
11:26:08 <mjrosenb> so if i have do x <- readMVar x'; y <- readMVar y'; stuff
11:26:29 <mjrosenb> there is conceptually no good reason that the read of x' needs to come before the read of y'
11:26:33 <Saizan> brooksbp_: that rule would allow me given e1 : Char -> Char, and e2 : Int to conclude (e1 e2) : Int
11:26:58 <mjrosenb> and I think it may be useful to be able to express this explicitly.
11:27:07 <fax> mjrosenb: I think you can already express this sort of stuff
11:27:43 <mjrosenb> fax: i am all ears
11:28:18 <fax> well you put hoare triples in the monad type
11:28:27 <fax> and add pre/post conditions for things
11:28:30 <brooksbp_> Saizan: So a "more correct" rule would be: (e1 : tau1 -> tau1) (e2 : tau1) ==> e1 e2 : tau1 ... and it would basically model (\x.x y) where y is any type and the resulting type is the same type of y, correct?
11:28:31 <shapr> I wonder whatever happened to the QuickCheck tests I contributed to House.
11:28:32 <copumpkin> ho' triples
11:28:49 <copumpkin> shapr: thirteen stole them
11:28:53 <shapr> Seems likely.
11:29:07 <shapr> I don't remember how I was QuickChecking the tcp/ip stack... I'd like to add IPv6 support.
11:29:39 <Saizan> brooksbp_: well, it'll presumably allow e1 to be other things rather than just (\x. x)
11:29:54 <shapr> Does Kenneth Graunke ever show up here?
11:30:03 <shapr> The guy who did LightHouse, the post-House project?
11:30:28 <brooksbp_> Saizan: Assuming we're only working within the simply typed lambda calculus... Id is the only term, right?
11:30:37 <mjrosenb> fax: that sounds like you'd have to explicitly state dependencies, which is ingeneral more error prone than explicitly stating which things do not depend on each other.
11:30:42 <Saizan> brooksbp_: no
11:30:56 <shapr> I sort of want to hack on a pure Haskell TCP/IP stack, even if I can't think of many uses for such a thing.
11:30:58 <mjrosenb> brooksbp_: if you only had id, life would not be very fun.
11:31:28 <brooksbp_> Saizan: ok, well terms that reduce to Id... like \x.(\y.y x)
11:31:32 <mjrosenb> brooksbp_: i can more or less guarantee that such a system would not be turing complete
11:31:36 <Saizan> brooksbp_: more than that
11:31:49 <mjrosenb> brooksbp_: \y . \x . y
11:32:01 <shapr> Oh, I could write an intrusion detection system that mimics the behaviour of various operating systems, thus showing how one stateful IDS just isn't enough.
11:32:01 <Saizan> mjrosenb: you miss context.
11:32:19 <shapr> What else would be useful/interesting about a pure Haskell TCP/IP stack?
11:32:47 <Saizan> brooksbp_: e.g. "\f.\y. f (f y)) : (Int -> Int) -> (Int -> Int)" but it doesn't reduce to id
11:32:56 <brooksbp_> mjrosenb: how does \y.\x.y have type tau1->tau1 ?? it's tau1->tau2->tau1
11:32:58 <shapr> Maybe I should ask on -cafe
11:33:19 <Saizan> brooksbp_: where tau1 = (Int -> Int) here
11:33:19 <mjrosenb> brooksbp_: oh, you are oonly looking for things that have type a->a?
11:33:36 <brooksbp_> Yep
11:33:51 <mjrosenb> or at least unify with a->a evidently
11:33:53 <arcatan> shapr: you should obviously prove it correct. i'm not sure why, but isn't that what's supposed to do with them
11:33:59 <shapr> er
11:34:09 <shapr> Didn't someone do that already with Isabelle/HOL?
11:34:22 <brooksbp_> Saizan: Do you mean \f.\y.(f (f y)) ?
11:34:42 <Saizan> brooksbp_: yes
11:35:02 <mjrosenb> brooksbp_: normally lambdas extend to the right as far as possible
11:35:20 <Saizan> i had an unbalanced parenthesis
11:35:20 <mjrosenb> brooksbp_: otherwise *most* expressions would end up with far more parens than you want
11:35:33 <mjrosenb> oh... so you did
11:35:45 * mjrosenb should come back after he has slept
11:38:46 <Ferdirand> hi room
11:39:25 <Ferdirand> what are the options nowadays for running haskell on parallel machines ?
11:39:52 <traversable> @type par
11:39:53 <lambdabot> forall a b. a -> b -> b
11:40:12 <mjrosenb> Ferdirand: you mean as in on one smp machine, or a cluster?
11:40:36 <dons> Ferdirand: http://haskell.org/haskellwiki/Haskell_for_multicores
11:40:39 <Ferdirand> somewhat in between: cluster, but with a fast interconnect (infiniband)
11:40:56 <dons> cluster is less mature by far than shared-mem multicore
11:41:05 <Ferdirand> found GPH, but it doesn't look alive
11:41:56 <mjrosenb> Ferdirand: the main distinction is "do they share a single address space"
11:42:02 <brooksbp_> So how do you express a type system judgement where the function must reduce to Id?
11:42:03 <Ferdirand> infiniband offers remote dma
11:42:34 <mjrosenb> the actual method of shuffling data back and forth should be pretty irrelevant
11:42:49 <mjrosenb> brooksbp_: i don't think you can
11:43:19 <Ferdirand> i think you can map remote memory into your address space, yes
11:43:29 <mjrosenb> brooksbp_: unless you say explicitly in its evaluation rule that f x => x
11:44:02 <brooksbp_> mjrosenb: but how do you convey that with types?
11:45:55 <mjrosenb> brooksbp_: how would you convey "this integer must b 3" with types?
11:46:19 <brooksbp_> damn
11:48:06 <mjrosenb> as useful as types can be, they do have a tendency to say very little about the actualy runtime behavior of any given function
11:48:58 <hpc> if types were turing complete, haskell would be dynamically typed
11:49:05 <fax> wut
11:49:42 <copumpkin> omgwtfbbq
11:49:47 <EvanR-work> i thought c++ templates were turing complete
11:49:49 <pikhq> With the right extensions, Haskell's type system is TC. But, it's still not dynamically typed.
11:49:56 <pikhq> EvanR-work: They are.
11:50:00 <ezyang> I love barbeque wtf!
11:50:10 <copumpkin> ezyang: oh my god?
11:50:11 <chrisdone> http://82.33.137.16/tryhaskell.png
11:50:14 <chrisdone> what's all that about?
11:50:20 <copumpkin> chrisdone: promotion
11:50:33 <ezyang> Whoo!
11:50:43 <copumpkin> chrisdone: *ahem*
11:50:52 <copumpkin> I hate to be annoying but apple+w stopped working in tryhaskell again :P
11:51:13 <chrisdone> yeah you told me about that a while ago and I just didn't fix it :p
11:51:17 <copumpkin> oh ok
11:51:20 <chrisdone> hahaha
11:51:22 <copumpkin> it worked for a little while
11:51:28 <chrisdone> aye
11:51:59 <chrisdone> last three days I've had alerts saying there's a 30% increase in traffic
11:52:33 <chrisdone> hm
11:52:41 <traversable> awesome, but what accounts for this frightening trough in the second week of April?
11:53:05 <chrisdone> exactly, I have no idea
11:53:36 <EvanR-work> world wide functional programming apathy
11:53:37 <applicative> it's the cognoscenti, they stopped looking at it.  So the genuine rustics kick in April 11
11:53:39 <brooksbp_> If \f.\y.(f (f y)) has type (int -> int) -> (int -> int) then y must be int, and f must be int->int, correct?
11:53:51 <applicative> and it's exponential after that.  I'm worried.
11:54:50 <fax> yes
11:56:57 <chrisdone> http://82.33.137.16/tryhaskell-visits-time-on-site.png
11:57:15 <chrisdone> judging by the fact the time on site average goes very low at this sudden increase
11:57:29 <chrisdone> it's been linked to on some kind of aggregator site
11:57:37 <Twey> Yeah
11:57:37 <chrisdone> so people are clicking and looking at it for a second and leaving
11:57:42 <Twey> I think it made an appearance on Reddit
11:57:53 <applicative> it's clear the wider public knows about it
11:58:38 <applicative> and what do you expect, but that most of them will spend 30 secs looking..  What did you do when you say 'Try Ruby'?
11:58:57 <applicative> So the interesting statistic woiuld be the count of people spending more than 10 minutes on it or something.
11:59:07 <Twey> chrisdone: How does ‘circle’ work, again?
11:59:31 <chrisdone> Twey: I took that off
11:59:35 <Twey> Aw
11:59:38 <Twey> Why?
12:00:17 <chrisdone> I actually can't remember
12:00:22 <chrisdone> it's just commented out in the javascript code
12:00:34 <chrisdone> ahhhh
12:00:38 <chrisdone> to save on bandwidth
12:00:43 <chrisdone> raphael is a big library
12:00:53 <Twey> Aha
12:01:00 <chrisdone> of course, that was when it was hosted on my home computer. I say bandwidth, I mean initial load time had to be fast
12:01:09 <Twey> You could maybe load it in the background?
12:01:19 <chrisdone> yeah it could be loaded on demand
12:01:55 <Twey> Tab-completion would be nice
12:01:55 <chrisdone> applicative: yeah, I have a "goal" setup for people spending >2 minutes on the site
12:02:40 <chrisdone> http://82.33.137.16/conversions.png
12:02:45 <chrisdone> I like the double entendre of conversions
12:02:54 <chrisdone> Twey: tab completion of imported symbols?
12:03:07 <Twey> Yeah
12:03:21 <chrisdone> ah, this is >1 minute on the site
12:03:28 <Twey> What is ‘conversions’ meant to mean?
12:03:42 <chrisdone> converting visits into money, I guessed
12:03:45 <Twey> Aha
12:03:56 <chrisdone> I don't know, though
12:04:35 <chrisdone> unsurprisingly, despite the average time on site decreasing didn't affect the overall performance of the goal, in fact that increased simply due to the number of hits
12:05:14 <Twey> Mm
12:05:15 <chrisdone> I wonder what I can export to..
12:05:48 <chrisdone> if I was joe haskeller and someone else had a haskell site with stats, I'd want to see
12:06:01 <arcatan> conversion is general converting visits to something. money, registration, whatever
12:06:21 <chrisdone> sure
12:06:24 <applicative> he is converting visits to conversions
12:06:43 <chrisdone> :D
12:07:01 <chrisdone> oh crap I thought I was in haskell-blah
12:07:38 <arcatan> I thought you should be on -blah
12:07:50 <chrisdone> sorry. -blah is usually my default tab
12:08:18 <arcatan> blah ambassador
12:08:52 <EvanR-work> i do not understand multiparameter classes...
12:10:11 <chrisdone> EvanR-work: which part?
12:10:35 <EvanR-work> like, what do they mean?
12:10:58 <EvanR-work> C a => means a implements C
12:11:11 <EvanR-work> C a b => means... a and b implement C ?
12:11:41 <mjrosenb> EvanR-work: i do not believe so
12:12:05 <EvanR-work> that would be (C a, C b) =>
12:12:47 <Ferdirand> it's not a type that implements a class. It's an instance that exists for given values of type parameters
12:13:04 <Ferdirand> (or given types, rather, blah)
12:14:36 <EvanR-work> class C a b is a set of operations involving a and b, so an instance is defined for two types together/
12:17:37 <chrisdone> sure
12:17:40 <chrisdone> `C a b' is the instance
12:17:45 <quicksilver> EvanR-work: a normal class represents some property of types
12:17:57 <quicksilver> EvanR-work: a 2-parameter one is a property of pairs of types...
12:18:02 <quicksilver> ...or a relationship between types.
12:18:05 <phaul> Hi all, could someone tell me a good reason why Ix (array index) has to be Ord? I'm also strugling to understand the motives behind the minimal complete definition..
12:18:15 <EvanR-work> ok
12:18:52 <quicksilver> like class Convertible a b where convert :: a -> b
12:18:58 <quicksilver> would be a simple example.
12:19:09 <phaul> in my understanding Ix is supposed to be a type from which a -> Int mapping exist and that should be enough
12:19:29 <chrisdone> quicksilver: is this allowed? class Convertible (a,b) where convert :: a -> b
12:19:41 <chrisdone> no
12:19:48 <chrisdone> but I guess that's the concept
12:20:32 <EvanR-work> ok
12:21:01 <monadic_kid> <phaul>
12:21:11 <monadic_kid> phaul: Why does it not make sense?
12:21:22 <chrisdone> phaul: ord helps to construct trees and things
12:21:40 <chrisdone> but yeah it's an index
12:22:15 <phaul> right, it's just a constraint that you have to satisfy, altough has nothing to do with the fact whether a type is usable as index or not
12:22:53 <EvanR-work> array bounds checking?
12:23:00 <arcatan> well, the a -> Int mapping would have to be injective, methinks
12:23:39 <phaul> EvanR-work: yep should be done on the Int
12:24:01 <phaul> otherwise you would also imply that the -> Int mapping has to be monotonic
12:24:33 <EvanR-work> it doesnt make sense for an array index to be any unconstrained type, because its an array
12:24:37 <EvanR-work> not a map
12:24:54 <EvanR-work> well map requires Ord too
12:25:01 <EvanR-work> for a different reason
12:25:21 <arcatan> array cells are supposed to be in some order, anyway
12:26:38 <arcatan> EvanR-work: does map really require Ord?
12:27:10 <EvanR-work> :t insert
12:27:11 <lambdabot> forall a. (Ord a) => a -> [a] -> [a]
12:27:38 <kniu> > insert 3 [1, 2, 4]
12:27:39 <lambdabot>   [1,2,3,4]
12:27:41 <kniu> huh.
12:27:54 <Veinor> @src insert
12:27:54 <kniu> That's an awfully specific function.
12:27:54 <lambdabot> insert e ls = insertBy (compare) e ls
12:28:02 <EvanR-work> :t Data.Map.insert
12:28:03 <lambdabot> forall k a. (Ord k) => k -> a -> M.Map k a -> M.Map k a
12:28:06 <kniu> :t insertBy
12:28:07 <lambdabot> forall a. (a -> a -> Ordering) -> a -> [a] -> [a]
12:29:25 <monadic_kid> It's not Map the data type that constrains it's type parameter, it's the polymorphic operations that work with Map which constrain the type
12:30:02 <EvanR-work> :info Array
12:30:38 <osaunders> I have a question about testing.
12:30:44 <EvanR-work> same with array operations it seems
12:31:08 <osaunders> There seems to be this problem where in order to test something you need to use the thing you want to test to generate the test data.
12:31:22 <copumpkin> really?
12:31:27 <fax> :/
12:31:29 <osaunders> Say if you want to test (+)
12:31:35 <copumpkin> your generator is tied to what you're testing?
12:31:42 <osaunders> You could say that 1 + 2 should be 3
12:32:17 <copumpkin> you could specify properties of it instead
12:32:22 <copumpkin> x + 0 = x
12:32:25 <copumpkin> 0 + x = x
12:32:28 <osaunders> But then: (+) a b = if a == 1 && b == 2 then 3 else 0
12:32:29 <monadic_kid> Evan: you wont see any universally quantified data type with class constraints.
12:32:30 <copumpkin> x + y = y + x
12:32:33 <osaunders> Would pass the test.
12:32:48 <fax> you could write correctly
12:32:51 <copumpkin> x + (y + z) =(x + y) + z
12:32:55 <fax> then you don't have to test
12:33:04 <EvanR-work> monadic_kid: no?
12:33:07 <copumpkin> osaunders: so avoid testing specific things like that
12:33:23 <copumpkin> state properties that you'd like your operation to respect
12:33:26 <osaunders> I'm not actually testing (+) but this is general problem I've noticed with testing.
12:33:34 <copumpkin> and have someone else generate specific cases
12:33:37 <fax> define 0 + x = x ; S y + x = S (y + x)  it's obviously correct, no testing needed
12:33:45 <idnar> osaunders: have you looked at QuickCheck / SmallCheck
12:33:48 <arcatan> you could prove it correct and then find a bug in your proof
12:33:56 <fax> now if you defined something tricky like binary numbers you can just prove it correct with respect to the peano +
12:33:57 <idnar> er, append a question mark there
12:34:02 <osaunders> arcatan: Yes, exactly.
12:34:07 <copumpkin> well, you could prove it correct and find a bug in the statement you've proved
12:34:15 <osaunders> idnar: No, should I?
12:34:18 <copumpkin> ideally the proof will be correct, but of the wrong statement
12:34:20 <EvanR-work> a bug in your test
12:34:22 <mercury^> fax: are you every actually on topic?
12:34:22 <EvanR-work> test tests
12:34:29 <mercury^> ever*
12:34:29 <copumpkin> fax is always on topic
12:34:39 <fax> you could prove it correct then get hit by lightening
12:34:47 <idnar> osaunders: they attempt to deal with the problem of generating test data in a generic fashion
12:34:49 <fax> it's irrelevant,  you don't take this into consideration
12:34:57 <copumpkin> fax just takes things to a deeper level
12:35:29 <idnar> @scheck let x `plus` y = x + y in \x y -> x + y == x `plus` y
12:35:29 <lambdabot>   "OK, passed 500 tests."
12:35:31 <fax> 19:33 < EvanR-work> test tests
12:35:34 <fax> looool
12:35:36 <mercury^> Yes, in #math she always starts reciting set theoretic axioms and logical principles, no matter the question.
12:35:42 <idnar> @scheck let x `plus` y = if x == 50 then 100 else x + y in \x y -> x + y == x `plus` y
12:35:43 <lambdabot>   "OK, passed 500 tests."
12:35:55 <idnar> @check let x `plus` y = if x == 50 then 100 else x + y in \x y -> x + y == x `plus` y
12:35:56 <lambdabot>   "Falsifiable, after 168 tests:\n50\n34\n"
12:36:06 <copumpkin> ideally you reduce your tests to stuff that is small enough to be obviously correct
12:36:20 <idnar> I often write tests for test helpers
12:36:29 <idnar> I don't think I've ever written a test for an actual test
12:36:35 <osaunders> How does Quickcheck know what behavior we want here?
12:36:35 <copumpkin> I write tests for test writers
12:36:42 <copumpkin> osaunders: you specify the property you want to satisfy
12:36:46 <copumpkin> it takes care of generating test cases
12:37:07 <copumpkin> you could be unlucky and have it not catch the x == 50 case
12:37:07 <osaunders> Mmm
12:37:15 <copumpkin> it can only ever prove your properties wrong, not right
12:37:17 <copumpkin> unless you have a tiny domain
12:37:46 <osaunders> "it can only ever prove your properties wrong, not right" Yes. I like that.
12:37:49 <idnar> smallcheck searches the domain in a different way which may be more thorough than quickcheck, depending
12:37:57 <osaunders> Er, I don't like it but I think it's true.
12:38:10 <idnar> my artificial bug there is an example of the sort of thing smallcheck isn't as good at finding
12:38:13 <copumpkin> osaunders: if you want to prove them right, you need to actually step into the realm of proofs
12:38:21 <fax> how would you prove
12:38:27 <fax> True && True = True
12:38:29 <idnar> but real bugs tend to be less fiendish than that
12:38:31 <fax> _ && _ = False
12:38:31 <fax> ?
12:38:32 <osaunders> Wasn't there problems with prooving 1 + 1 == 2?
12:38:52 <fax> > if 1 + 1 == 2 then "qed" else "1 + 1 is not 2"
12:38:53 <lambdabot>   "qed"
12:39:00 <copumpkin> fax: what's the statement to prove?
12:39:03 <idnar> I don't see how you could "prove" 1 + 1 == 2
12:39:10 <fax> I just did it
12:39:15 <copumpkin> 1 + 1 == 2 is kind of true by definition
12:39:15 <fax> I just proved it right here in #haskell
12:39:19 <copumpkin> 2 + 2 = 4 might be a little harder
12:39:33 <fax> you can prove things equal the defintion, it's just really easy to do so -- so normally people don't
12:39:40 <osaunders> copumpkin: Do you know much about proofs? I'm curious how they work.
12:39:52 <copumpkin> osaunders: a bit :) fax knows more though
12:40:11 <idnar> anyway, tests and proofs are different beasts
12:40:17 <idnar> testing is a lot easier to do than proving
12:40:25 <idnar> of course
12:40:25 <fax> testing is not easier than provng
12:40:28 <idnar> @quote only proved
12:40:28 <lambdabot> No quotes for this person. Your mind just hasn't been the same since the electro-shock, has it?
12:40:35 <idnar> @quote proved it correct
12:40:35 <lambdabot> No quotes for this person. This mission is too important for me to allow you to jeopardize it.
12:40:42 <alpounet> @quote proved.it.correct
12:40:42 <lambdabot> DonaldKnuth says: Beware of bugs in the above code; I have only proved it correct, not tried it.
12:40:48 <idnar> oh, right
12:41:23 <phaul> Ok, going back to Ix, the minimal complete definition is range, index, inRange with pretty peculiar type singature. What I expected was index :: a -> Int. Wouldn't that be much simpler?
12:41:36 <EvanR-work> > 1 + 1
12:41:37 <lambdabot>   2
12:41:41 <EvanR-work> i just proved it
12:41:47 <fax> good
12:41:51 <tensorpudding> @type index
12:41:52 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Int
12:42:14 <tensorpudding> index (1,10) 3
12:42:19 <tensorpudding> > index (1,10) 3
12:42:20 <lambdabot>   2
12:42:44 <copumpkin> osaunders: if you are interested, you should join #agda and/or #coq and look up tutorials for the respective languages there
12:42:56 <copumpkin> (and ask questions if you have any)
12:43:32 <osaunders> Hm.
12:43:41 <phaul> sort of getting the idea of mapping ranges of type to ranges of Int instead of mapping type to Int..
12:43:44 <osaunders> I JUST WANT A SIMPLE ANSWER THOUGH! :'(
12:43:49 <fax> osaunders to what ?
12:43:53 <copumpkin> osaunders: okay, what's the question?
12:43:55 * osaunders wonders why the world is so cruel
12:44:18 <osaunders> My original question.
12:44:22 <fax> what is it
12:44:26 <EvanR-work> 42
12:44:28 <osaunders> Don't worry.
12:44:44 <fax> wow some people suck
12:45:06 <copumpkin> "osaunders: copumpkin: Do you know much about proofs? I'm curious how they work."
12:45:10 <copumpkin> that's the question?
12:45:11 <osaunders> The original question was basically how can I test things are correct without writing the same thing twice and testing it against itself.
12:45:18 <copumpkin> osaunders: I answered that
12:45:30 <osaunders> Yeah. I know.
12:45:31 <copumpkin> state properties you want it to satisfy
12:45:36 <copumpkin> not examples of it being correct
12:45:40 <osaunders> But the answer wasn't simple was it :-)
12:45:58 <osaunders> I'm not complaining about you, you've been very helpful.
12:46:07 <copumpkin> oh okay
12:46:11 * copumpkin 's ego grows
12:46:16 <osaunders> I'm complaining about the the behavior of the universe.
12:46:33 <osaunders> Stupid universe.
12:46:36 * alpounet puts copumpkin's ego in a non-copointed monad
12:46:37 <fax> what
12:46:41 <fax> are you talking about ...........
12:46:59 <copumpkin> damn!!
12:47:08 <copumpkin> it be trapped
12:47:12 <osaunders> fax: Who me?
12:47:18 <fax> yeah I can't understand
12:47:37 <osaunders> I don't think it matters.
12:48:24 <fax> what injustice are you complaining about?
12:48:28 <copumpkin> she clearly wants to understand
12:49:18 <kar-1> osaunders: specifications can be orders of magnitude simpler than implementations: this is why proofs are useful
12:50:34 <gwern> @wn hippish
12:50:35 <lambdabot> No match for "hippish".
12:51:50 <gwern> blast. wish I had my OED nigh
12:52:07 <yitz> @google hippish
12:52:08 <lambdabot> No Result Found.
12:52:22 <mjrosenb> hip hip horrayish
12:52:33 <yitz> @vixen hippish
12:52:33 <lambdabot> so?
12:52:39 <dpratt711> my brain has been fixated on an idea lately; unfortunately I lack the mental tools to solve it to my brain's satisfaction...
12:52:48 <sbpaul> hip hop > hip hip
12:53:06 <sclv> osaunders: http://en.wikipedia.org/wiki/Hoare_logic is one classic way to start. Functional correctness proofs are generally quite different though.
12:53:07 <dpratt711> ...I have the feeling it's the sort of thing that some in this group would've sorted through when they were 3
12:53:36 <dpratt711> I was thinking about automatic parallelization of code...
12:53:53 <sclv> hoare logic is more for imperative programs. but then again, things that are trivially true in functional programs often take work to formalize for imperative ones :-)
12:54:07 <dpratt711> ...and how one might go about "parallelizing" summing a list of numbers...
12:54:19 <copumpkin> have you looked at DPH?
12:54:59 <fax> dpratt711: if you define sum as some kind of fold then parallelizing comes from the fact that + is associative
12:55:24 <dpratt711> fax: right
12:55:47 <fax> it's not obvious that + is associative, so I don't t hink you can automate this
12:55:55 <dpratt711> so how could we tell the automatic "parallelizer" that a given function is associative?
12:56:01 <jmcarthur> dpratt711: you should check out DPH and Repa. not sure if there is a Repa release yet though
12:56:08 <copumpkin> you'd write something that allows you to tell it stuff like that
12:56:15 <fax> dpratt711: you could but that would only solve this one kind of parallelism
12:56:16 <copumpkin> repa?
12:56:26 <jmcarthur> copumpkin: http://justtesting.org/regular-shape-polymorphic-parallel-arrays-in
12:56:39 <fax> dpratt711: if you wanted to solve another kind you could add that too -- but it doesn't seem like it would generalize to the point where it was actually useful
12:56:58 <dpratt711> it also seems like there could be some connection between monoids or monads here, but I'm well out of my league there
12:57:12 <kmc> osaunders, http://www.cis.upenn.edu/~bcpierce/sf/
12:57:15 <fax> well yes you know ++ is associative too
12:57:16 <jmcarthur> copumpkin: Repa has had harrop in a bad mood lately
12:57:19 <jmcarthur> ;)
12:57:22 <copumpkin> oh nice
12:57:25 <kmc> osaunders, read this, you will learn how to prove programs correct in Coq
12:57:32 <dpratt711> I'll look into DPH, et al
12:57:36 <fax> and taking ++/[x]/[] --> +/x/0  is a monoid homormorphism
12:57:44 <kmc> "how can I test things are correct without writing the same thing twice and testing it against itself."
12:57:45 <dpratt711> thanks fax, jmcarthur
12:57:47 <kmc> lots of answers to that
12:58:05 <fax> dph stands for dead parallel haskell?
12:58:06 <kmc> assuming you're talking about testing and not proof then
12:58:13 <kmc> double penetration haskell
12:58:24 <jmcarthur> o_O
12:58:28 <kmc> osaunders, often a problem will have a naive slow but simple to implement algorithm
12:58:33 <kmc> and then a fancier one
12:58:45 <fax> dpratt711 (notice that i used ++ rather than cons, because that way you have divide the work up faster)
12:58:45 <kmc> and it's nice to start with the naive one
12:58:47 <dpratt711> hmm...I don't see what the "Department of Public Health" has to do with this :)
12:58:51 <kmc> first of all, because it might be good enough
12:58:52 <fax> binary tree style
12:59:07 <kmc> but also, if you do get 'round to implementing the fancier algorithm, you can then test it against the simple one
13:00:07 <sclv> parallelizing associative opts actually takes you really far.
13:00:17 <sclv> erm associative ops.
13:00:24 <sclv> all the way to mapreduce, really.
13:00:33 <jmcarthur> copumpkin: my favorite thing in the Repa paper is page 10 where they felt like they had to write a subscript reiterating that one of the benchmark graphs is actually real
13:00:51 <sclv> ekmett'
13:00:52 <sclv> ekmett's monoid library is pretty general in that regard
13:00:57 <osaunders> kmc: Thank you.
13:01:23 <yitz> kmc: read what?
13:01:42 <jmcarthur> sclv: you mean edwardk's
13:01:49 <jmcarthur> oh
13:01:51 <sclv> right :-)
13:01:52 <jmcarthur> that is edwardk
13:02:07 <jmcarthur> sclv: does he go that nick here too?
13:02:32 <sclv> i don't think so -- i mixed it up with his email.
13:02:36 <yitz> yes he does, and i think you've just pinged him
13:02:37 <jmcarthur> ah
13:02:50 <jmcarthur> yitz: :P no i didn't
13:03:08 <yitz> depends which irc client he is using
13:05:10 <alexbobp> If you can judge the sanity of a programming language by how agitated it's users are, then haskell has got to be the only sane language
13:05:28 <alexbobp> every *other* language-specific channel I go to is full of people who get very very angry over the silliest things
13:05:53 <dons> alexbobp: :)
13:05:58 <dons> we like to chillax
13:06:06 <Apocalisp> Haskell is agitating occasionally, but it's mostly a breeze.
13:06:34 <tensorpudding> Haskell people get angry over things.
13:07:08 <Apocalisp> Scala: Why won't this typecheck!?!
13:07:17 <Apocalisp> Haskell: I can't believe this typecked.
13:07:35 <tensorpudding> @type gfoldl
13:07:36 <lambdabot> forall (c :: * -> *) a. (Data a) => (forall d b. (Data d) => c (d -> b) -> d -> c b) -> (forall g. g -> c g) -> a -> c a
13:07:49 <aavogt> more please?
13:07:57 <Cale> Heh, "Why is this typechecking?! I want the compiler to tell me it's wrong!"
13:08:12 <aavogt> also, how to fix it
13:08:26 <Associat0r> and F#?
13:09:05 <tensorpudding> F# might be fun once Mono gets better support for it.
13:09:34 <Apocalisp> F#: Oh look, the copy I made of this function specialised to this monad compiles just like every other copy I made.
13:10:28 <Associat0r> tensorpudding: http://www.reddit.com/r/programming/comments/b3jro/current_developments_in_the_mono_world/
13:10:41 <Associat0r> Apocalisp: well at least it's fast and reliable
13:10:58 <Apocalisp> copy/paste is fast and reliable
13:15:29 <Associat0r> Apocalisp: well there isn't much choice
13:16:51 <c_wraith> let me double-check my understanding of the specialize pragma...  It makes GHC create a different version of the function for the specified type, rather than using dictionary-lookup like functions that use typeclasses generally do?
13:24:39 <EvanR-work> c_wraith: that sounds tricky, like if the function was in a module
13:24:44 <EvanR-work> precompiled
13:25:33 <c_wraith> Nothing about that is particularly tricky.  It's just some extra compiler/linker work
13:26:24 <EvanR-work> well i couldnt figure it out when i tried to make a generic compiler :(
13:27:17 <fax> generic over what parameters?
13:27:55 <dpratt711> now that I'm actively toying with F#, I'm finding the differences and similarities with Haskell very interesting
13:28:10 <EvanR-work> i dont remember
13:28:25 <dpratt711> I think I would be much happier with F# if I hadn't been exposed to Haskell first
13:28:25 <EvanR-work> im getting old here
13:29:00 <c_wraith> I'm not sure I'll ever be happy with a strict functional language anymore.
13:29:45 <mjrosenb> c_wraith: after using what?
13:29:51 <c_wraith> mjrosenb: haskell.
13:30:17 <mjrosenb> err
13:30:19 <c_wraith> mjrosenb: I just like the flexibility default laziness gives for control-flow too much
13:30:22 <mjrosenb> oh strict vs. lazy
13:30:31 <dpratt711> at first the lack of purity (in F#) bothered me a lot; now I'm more frustrated that I have to "spell it out" for the compiler much more than is necessary in Haskell
13:30:34 <mjrosenb> not strict as in we actually do the whole type thing
13:30:37 <mjrosenb> once again
13:30:41 <mjrosenb> i should get some sleep
13:30:47 <c_wraith> mjrosenb: sleep is good. :)
13:30:49 <mjrosenb> since i seem to be misinterpreting everything
13:31:14 <EvanR-work> F# has no types?
13:31:24 <alpounet> it has
13:31:39 <alpounet> it's based on ML
13:32:06 <jmcarthur> it haz no purity though
13:32:58 <c_wraith> ML has no purity, either
13:33:05 <jmcarthur> i'm comparing to haskell
13:33:07 <dpratt711> F# also has a lot of "surface area"; all the functional stuff + all the OO stuff + a bit more to glue it together
13:34:00 <EvanR-work> ive heard of this concept, functional with OO support, how does that work
13:34:20 <c_wraith> I wouldn't mind seeing the type-directed name resolution extension get adopted.  Though I guess it's really just a stopgap that only helps records somewhat
13:34:22 <jmcarthur> EvanR-work: check out OOHaskell
13:34:47 <jmcarthur> EvanR-work: OO is nothing strange
13:34:56 <dpratt711> EvanR-work: better than I expected, but still not fantastic; the two really do not speak the same language
13:35:12 <dpratt711> (so to speak)
13:35:22 <EvanR-work> doesnt seem like it would
13:35:47 <jmcarthur> that's because it's a separate feature rather than constructed from existing ones (my hypothesis)
13:36:02 <aavogt> c_wraith: so TDNR is more or less this here http://hackage.haskell.org/trac/ghc/ticket/2104 + some library with extensible records
13:36:07 <jmcarthur> of course, constructing the OO parts from the functional parts would reveal how unnecessary the OO parts are. can't have that
13:36:23 <dpratt711> it seems to work best when there is a clear division of responsibilities and a minimal and well-defined interface between OO and functional code
13:37:27 <monadic_kid> F# is decent but it's type system isn't as expressive as Haskell and that is (partly) due to .NET
13:39:09 <c_wraith> aavogt: hmm.  the ticket seems straightforward, but I'm not seeing the intended application of it.
13:39:16 <orlandu63> i accidentally deleted ~/.ghc/x86_64.../package.conf.d/package.cache; now, running ghc gives me a file does not exist error, specifying the deleted file. creating the file gives me a "failed reading at byte position 8" error. how can i fix this?
13:40:33 <aavogt> c_wraith: so rather than resolving the actual label based on the type, you just use the same label everywhere
13:40:57 <jmcarthur> orlandu63: if you don't mind reinstalling your --user packages you could just trash ~/.ghc (or move it out of the way instead if you're paranoid)
13:41:01 <aavogt> orlandu63: get rid of your whole ~/.ghc?
13:41:37 <aavogt> but regardless you will have to reinstall your --user packages
13:41:50 <orlandu63> i have no user packages installed, so that would be a quick fix. however, i figured out a cleaner fix: ghc-pkg --user recache
13:42:41 <Eelis> has anyone tried visualizing the hackage dependency graph yet?
13:43:14 <jmcarthur> Eelis: http://donsbot.wordpress.com/2010/04/03/the-haskell-platform-q1-2010-report/
13:43:28 <Eelis> jmcarthur: thanks
13:43:47 <jmcarthur> Eelis: hmm. there doesn't seem to be a link to view the graph larger
13:43:49 <Associat0r> "monadic_kid: F# is decent but it's type system isn't as expressive as Haskell and that is (partly) due to .NET" Scala has higher-kinded types, but then the F# devs wanted it to be closer to the CLR I guess for easier 2way interop
13:43:51 <c_wraith> ah, graphviz.  How distintive your layouts are
13:44:26 <Eelis> jmcarthur: indeed :(
13:44:38 <alpounet> an earlier post of dons provides one iirc
13:44:44 <jmcarthur> Eelis: dons has done the same thing for other quarters. pretty sure some of them are large
13:44:44 <orlandu63> why doesn't the Floating class not automatically imply Enum?
13:45:05 <jmcarthur> orlandu63: floating point numbers shouldn't be Enum anyway :\
13:45:05 <dpratt711> Associat0r: can you briefly explain "higher-kinded types"?
13:45:09 <Associat0r> jmcarthur: OO isn't unnessecary, it's ok for modularity
13:45:10 <c_wraith> orlandu63: how would you enumerate arbitrary-precision floating point numbers?
13:45:13 <jmcarthur> (that's opinion, btw)
13:45:37 <orlandu63> ah, good point
13:45:38 <Associat0r> dpratt711: being able to abstract over type constructors
13:45:40 <EvanR-work> its not about modularity
13:45:42 <jmcarthur> Associat0r: my point was that OO doesn't have to be a language feature to be used
13:45:47 <EvanR-work> its about mutable data hiding
13:45:54 <Associat0r> jmcarthur: then you are bound to greenspun it in
13:45:57 <jmcarthur> EvanR-work: OO isnt' necessarily abotu mutation
13:45:59 <jmcarthur> *isn't
13:46:09 <jmcarthur> Associat0r: i don't see that
13:46:10 <EvanR-work> thats what separates it for me
13:46:17 <benmachine> Float should be Enum but Enum should be renamed
13:46:28 <benmachine> Enum is just about [a .. b] syntax
13:46:29 <EvanR-work> we use modularity and interface vs implementation all the time in haskell, withotu objects
13:46:34 <dpratt711> Associat0r: is that in any way related to what I would think of as "generics"?
13:46:56 <benmachine> hmm I don't know if it should be renamed
13:47:10 <benmachine> I remember someone mentioning FromThenTo once and I thought that was neat but it's kind of ugly
13:47:17 <benmachine> kind of a little
13:47:35 <jmcarthur> the whole idea is kind of ugly though. might as well suck it up ;)
13:47:40 <Associat0r> dpratt711: it's related but, on a higher level
13:47:53 <monadic_kid> higher-kinded types is not the only thing
13:48:26 <dpratt711> Associat0r: is there a canonical example of a higher-kinded type?
13:48:48 <Associat0r> dpratt711: Haskell's functors
13:48:51 <monadic_kid> dpratt711: imagine a generic that can take generic parameters
13:49:32 <Associat0r> yes what monadic_kid said
13:50:24 <kmc> by higher-kinded do you just mean kind not *
13:50:28 <Associat0r> "onadic_kid: higher-kinded types is not the only thing" << true, typeclasses (implicits), abstract members, fields etc
13:50:35 <Associat0r> monadic_kid
13:50:42 <kmc> or do you mean a kind where a -> appears to the left of another ->
13:50:50 <kmc> analogous to higher-order functions
13:51:13 <monadic_kid> kmc: higher-order polymorphism
13:51:19 <Associat0r> yep
13:51:59 <kmc> meaning what?
13:51:59 <kmc> sorry
13:52:20 <monadic_kid> kmc: * -> *
13:52:52 <aavogt> ListT seems unloved
13:53:18 <monadic_kid> kmc: you know the functor type class?
13:53:42 <monadic_kid> :t fmap
13:53:42 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:54:40 <Associat0r> kmc: http://projects.tmorris.net/public/what-does-monad-mean/artifacts/1.0/chunk-html/ar01s03s03.html
13:54:53 <Associat0r> kmc: http://projects.tmorris.net/public/what-does-monad-mean/artifacts/1.0/chunk-html/ar01s03s04.html
13:55:45 <monadic_kid> :t runST
13:55:46 <lambdabot> forall a. (forall s. ST s a) -> a
13:57:00 <kmc> right i see
13:57:03 <Associat0r> monadic_kid: also a reason why F#'s type system is kept simpler is because of better type inference
13:58:20 <monadic_kid> Associat0r: I don't agree, if you mean type inference in the context of sub-type polymorphism then yes but haskell has type inference even on type constraints and higher rank polymorphism among other things
13:58:44 <aavogt> you need some annotations for higher rank polymorphism
13:58:53 <monadic_kid> aavogt: rank-2
13:58:55 <Associat0r> monadic_kid: but it doesn't do subtyping
13:59:09 <Associat0r> monadic_kid: and a lot of the extensions need annotations
13:59:23 <Associat0r> monadic_kid: but I was comparing between Scala and F#
14:00:05 <aavogt> > let f g x y = (g x,g y) in f (+1) 0 1
14:00:06 <lambdabot>   (1,2)
14:00:14 <aavogt> > let f g x y = (g x,g y) in f (+1) (0::Int) 1.0
14:00:14 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
14:00:15 <lambdabot>    arising from the lit...
14:00:36 <monadic_kid> Associat0r: higher-kinded and rank, subtyping can be emulated with existential types and type classess
14:00:52 <Associat0r> monadic_kid: but that's very verbose
14:00:59 <aavogt> > let f :: (Num a, Num b) => (forall n. Num n => n -> n) -> a -> b -> (a,b); f g x y = (g x,g y) in f (+1) (0::Int) 1.0
14:01:00 <lambdabot>   (1,2.0)
14:01:17 <aavogt> ^^ this is what you do to get higher rank polymorphism
14:01:46 <Associat0r> http://www.haskell.org/haskellwiki/Existential_type#Dynamic_dispatch_mechanism_of_OOP
14:01:57 <aavogt> it isn't pretty, mostly to the point that you inline the (+1) yourself
14:02:03 <aavogt> * almost
14:02:19 <Associat0r> monadic_kid: also what about proper modules?
14:02:58 <Associat0r> monadic_kid: and there are also issues with optimizing out typeclasses
14:03:34 <fax> what would be the perfect language for doing math?
14:03:47 <interferon> on a posix-based system, how can i run a  shell command and provide a short string as it's stdin?
14:03:52 <jmcarthur> fax: what kind of math?
14:03:59 <fax> I dont know
14:04:07 <tromp_> i know what stephen wolfram would say...
14:04:14 <fax> oh MATHematica lol
14:04:18 <interferon> looked at System.Command
14:04:27 <interferon> but i don't have a handle to pass in, just a string
14:04:40 <Associat0r> monadic_kid: langauge design is all about compromise
14:04:43 <interferon> i guess "echo foo | blah" ?
14:04:54 <interferon> and my question is answered :)
14:05:00 <aavogt> @hoogle rawSystem
14:05:00 <lambdabot> No results found
14:05:11 <aavogt> @type System.Process.rawSystem
14:05:12 <lambdabot> String -> [String] -> IO GHC.IOBase.ExitCode
14:05:21 <aavogt> oh, no stdin there
14:05:28 <jmcarthur> the more OOP debates i see the more i realize that nobody really agrees on what OOP is
14:05:36 <aavogt> @type System.Process.readProcess
14:05:37 <lambdabot> FilePath -> [String] -> String -> IO String
14:05:40 <EvanR-work> that much is certain
14:05:59 <EvanR-work> whenever i try to use the least common denomenator i get people telling me i dont know what its really about
14:06:03 <jmcarthur> i'd rather decompose everybody's definitions of OOP into smaller parts that we can argue about separately
14:06:03 <aavogt> interferon: ^^
14:06:04 <interferon> createProcess $ shell "echo foo | blah " works
14:06:12 <interferon> aavogt: other way around
14:06:23 <pikhq> jmcarthur: There's enough debates with "what FP is". And FP at least has some common subset of definitions.
14:06:32 <pikhq> (namely, the "has anonymous functions" bit.)
14:06:38 <aavogt> how do you mean?
14:06:49 <aavogt> the third argument is stdin
14:06:55 <EvanR-work> function programming is about functions, oop is about objects ;)
14:06:56 <jmcarthur> pikhq: yeah. i think the problem is just ontological thinking
14:06:58 <interferon> aavogt: ah, i see
14:06:59 <interferon> thanks
14:07:01 <pikhq> Yuh.
14:07:15 <EvanR-work> either that, or its about orientation
14:07:31 <jmcarthur> why talk abotu categories? there's no point. let's talk features instead
14:07:31 <EvanR-work> which would be an interesting paridigm
14:07:43 <Associat0r> there is a formal definition of OOP
14:07:44 <jmcarthur> and no, FP and OOP are nto features
14:07:47 <jmcarthur> *not
14:08:02 <pikhq> jmcarthur: If they were, C has them.
14:08:09 <Associat0r> http://lucacardelli.name/TheoryOfObjects.html
14:08:14 <pikhq> Without any support from C other than possessing function pointers.
14:08:29 <jmcarthur> Associat0r: that is one of many differing formal definitions, of course
14:08:38 <roconnor_> encapsulation, inhertiance and um something else...
14:08:49 <EvanR-work> those are not what makes oop oop
14:08:56 <EvanR-work> we use all that in haskell without objects
14:09:00 <jmcarthur> here we go again
14:09:07 <jmcarthur> who cares what makes something OOP?
14:09:20 <pikhq> EvanR-work: Used in C, too. With some pain.
14:09:21 <jmcarthur> why don't we just talk about encapsulation, inheritance, etc. instead?
14:09:24 <gwern> OOP is whatever alan kay is saying this year
14:09:26 <EvanR-work> thats why i emphasize mutable data
14:09:40 <Associat0r> jmcarthur: http://en.wikipedia.org/wiki/Object-oriented_programming#Formal_definition
14:09:43 <jmcarthur> why dont' we just talk about mutable data? why does it have to be OOP
14:09:47 <pikhq> Who gives a flying fuck, it's all just "means of structuring programs into composible bits". :)
14:09:50 <Associat0r> forget Alan Kay
14:10:01 <Associat0r> Luca Cardelli is where it's at
14:10:10 <benmachine> I've seen C written in an OO style
14:10:33 <pikhq> Yes, it's a common technique.
14:10:33 <jmcarthur> Associat0r: wikipedia definitely has this one right
14:11:07 <roconnor_> I've seen Asm writen in structural programming style
14:11:10 * twink watched some talk by Alan Kay given in the early 80's where he was using footage from the early 1970's.
14:11:19 <jmcarthur> all this talk of style
14:11:19 <Associat0r> http://lambda-the-ultimate.org/node/2417
14:11:23 <pikhq> roconnor: Also common.
14:11:23 <jmcarthur> it's pointless
14:11:43 <Twey> Because pointless is the one true style!  :þ
14:11:51 <EvanR-work> structured programming ftw
14:12:00 <Associat0r> jmcarthur: who says OOP is about mutable data?
14:12:08 <jmcarthur> Associat0r: EvanR-work
14:12:10 <EvanR-work> i do
14:12:28 <EvanR-work> carefully orchestrating and restricting the commands to mutate and read back data
14:12:33 <interferon> java now encourages immutable objects, but that's still OO
14:12:34 <jmcarthur> on the one hand, i disagree, but on the other hand, it would be *pointless* to bother arguing about it
14:12:41 <Associat0r> EvanR-work jmcarthur: well it's not
14:12:48 <interferon> this is indeed pointless
14:12:52 <jmcarthur> Associat0r: no disagreement with me there
14:12:53 <pikhq> Associat0r: If it's not, then the whole thing is boiled down to "type system".
14:12:54 <pikhq> :)
14:13:24 <interferon> i think it is kind of genius how values that might not be supplied have to be explicitly wrapped in a Maybe type
14:13:32 <EvanR-work> if youd rather group typed values with operations for those values, well, what makes those objects, its more like a library or code module
14:13:45 <jmcarthur> it was discussed in #haskell-blah just last night about how you can formulate FP vs. OOP as initial algebras vs. final coalgebras
14:13:52 <jmcarthur> those don't involve mutation at all
14:14:04 <jmcarthur> and they aren't really about type system either
14:14:17 <Associat0r> jmcarthur: exactly
14:14:56 <interferon> could we say that OO involves tightly coupling your functions to your data?
14:15:09 <interferon> that's not enough probably
14:15:09 <jmcarthur> why don't we say nothing about OO because it's a useless category
14:15:10 <jmcarthur> ?
14:15:28 <jmcarthur> (as in the category is useless, not some of the ideas commonly put in it)
14:15:53 <interferon> yeah we could do that
14:16:44 <EvanR-work> my conclusions are from the real world oop hype, (mal)practice, pop books, etc. i dont know any higher theory behind it
14:17:19 <jmcarthur> EvanR-work: i recommend reading some of the formalisms
14:17:26 <jmcarthur> they are quite interesting, actually
14:17:46 <EvanR-work> well, where do i start
14:19:09 <aavogt> > do (+1) -> x <- [1,2]; return x
14:19:10 <lambdabot>   <no location info>: parse error on input `->'
14:19:18 <aavogt> > do ((+1) -> x) <- [1,2]; return x
14:19:19 <lambdabot>   [2,3]
14:19:37 <fax> @oies 2,6,30,210,2310,30030,510510,9699690
14:19:37 <lambdabot>  Primorial numbers (first definition): product of first n primes. Sometimes w...
14:19:38 <lambdabot>  [1,2,6,30,210,2310,30030,510510,9699690,223092870,6469693230,200560490130,74...
14:19:42 <aavogt> > case () of _ | x <- [1,2] -> x
14:19:43 <lambdabot>   [1,2]
14:19:56 <jmcarthur> EvanR-work: no papers for you specifically, but this should give you some key words at least: http://en.wikipedia.org/wiki/Object-oriented_programming#Formal_definition
14:20:18 <jmcarthur> there is one paper pointed out explicitly actually
14:20:28 <jmcarthur> A Theory of Objects
14:20:36 <jmcarthur> i think that was linked to here a few minutes ago, too
14:23:53 <EvanR-work> * records are basis for understanding objects
14:23:54 <EvanR-work> ;)
14:25:01 <interferon> anyone familiar with wxhaskell and os x?  i can't find the macosx-app binary referred to in the wxhaskell docs, so my apps just freezen
14:25:05 <interferon> *freeze
14:26:14 <Associat0r> http://lucacardelli.name/TheoryOfObjects.html
14:26:25 <Associat0r> http://lambda-the-ultimate.org/node/2417
14:28:09 <EvanR-work> gah no actual content
14:29:54 <kmc> "oop vs. fp" is a silly false dichotomy
14:30:04 <kmc> any good oop language is also a functional language
14:30:22 <fax> but notthe other way around XD
14:30:31 <kmc> fax, mostly the other way as well
14:30:45 <kmc> in that any good fp language will provide all things people use objects to do
14:30:58 <kmc> probably not as a single concept
14:31:35 <kmc> what is meant by "object oriented" in common practice is a hodge-podge of different features, see http://www.paulgraham.com/reesoo.html
14:31:54 <kmc> and if you keep your favorite FP language in mind while you read that list, you'll probably see a good way to do most if not all of it
14:32:01 <EvanR-work> right
14:32:16 <EvanR-work> so why do people dwell on oop >_<
14:32:28 <kmc> EvanR-work, who and in what context?
14:32:40 <kmc> e.g. this is why i think existential types are an important Haskell extension
14:32:43 <EvanR-work> megacorps developing oop languages
14:32:56 <EvanR-work> hipsters developing next gen scripting languages
14:32:57 <EvanR-work> and scala
14:33:04 <kmc> Haskell is the ultimate hipster language, actually
14:33:42 <kmc> we talk about how we're special for understanding it, and everyone else is dumb and has inferior taste, yet we also hope it will stay underground to avoid corrupting "the scene"
14:33:53 <EvanR-work> lol
14:34:15 <kmc> EvanR-work, "Perhaps part of the confusion ... is that the C/C++ folks see OO as a liberation from a world that has nothing resembling a first-class functions, while Lisp folks see OO as a prison since it limits their use of functions/objects"
14:34:19 <EvanR-work> enlightening
14:35:13 <kmc> EvanR-work, people fixate on oop because it's legitimately useful as a way to structure programs
14:35:24 <kmc> and it was the first such discipline to get widespread recognition
14:36:54 <EvanR-work> were still in that era?
14:36:58 <quicksilver> in a general sense OO may be full of useful general tools
14:37:24 <quicksilver> but specifically, the rigid class hierarchies and implementation inheritance of Java-like languages are a mistake
14:37:27 <quicksilver> (IMO)
14:37:28 <kmc> EvanR-work, the current state of programming language adoption in industry is in the mid 1930's
14:37:43 <quicksilver> that's the dichotomy that I personally see
14:37:46 <kmc> in that lambda expressions are now seen as the hot new thing
14:37:53 <quicksilver> languages like Java and C++ which limit your abstractions
14:38:02 <Associat0r> Scala is no hipster language
14:38:02 <kmc> yeah, there is also this problem of confounding OOP with "Java and C++"
14:38:12 <kmc> which have specific flaws that are antithetical to OOP as well as good programming in general
14:38:16 <quicksilver> as opposed to languages like lisp and haskell which break them down into smaller reusable modular abstractions.
14:38:19 <Associat0r> and certainly no scriping language
14:38:23 <kmc> C++ in particular does a terrible job of enforcing any kind of OOP-like abstraction
14:38:36 <kmc> "scripting language" is a worthless, politically loaded term and i move that we avoid it entirely
14:39:24 <fax> agreed!
14:39:38 <kmc> a lot of people new to FP tend to rage against OOP and "imperative programming"
14:39:54 * EvanR-work starts raging
14:39:55 <kmc> but i think that's better directed at the languages which support *only* very *narrow* forms of those
14:40:49 <chrisdone> but we know what a script is don't we?
14:40:55 <kmc> and that any good language will give you powerful fundamental constructs that can be used to build OOP-like abstractions and many others
14:41:30 <Associat0r> kmc: that may be too loose
14:42:01 <Associat0r> kmc: if you have to greenspun all those abstractions in, why not just put them in a the language
14:42:17 <Associat0r> -a
14:42:31 <kmc> it's a fair point, especially because you want interoperability
14:42:51 <Associat0r> not only interop
14:42:57 <Associat0r> but general modularity of the program
14:43:01 <Associat0r> interop or not
14:44:20 <kmc> "This is related to Lisp being oriented to the solitary hacker and discipline-imposing languages being oriented to social packs.... In a pack you want to restrict everyone else's freedom as much as possible to reduce their ability to interfere with and take advantage of you, and the only way to do that is by either becoming chief (dangerous and unlikely) or by submitting to the same rules that they do."
14:44:38 <orlandu63> @pl (\x y -> x + y)
14:44:49 <orlandu63> nooo lambabot
14:45:09 <cybercobra> without splitting code into a separate file, is it possible to do something like this?: http://ideone.com/tOmfo
14:45:09 <kmc> the weak abstraction capabilities of java are to some degree a feature, from a business perspective
14:45:20 <EvanR-work> kmc: what are you *reading* ;)
14:45:38 <kmc> cybercobra, no
14:45:58 <cybercobra> kmc: pity. oh well, ultra-short module it is then.
14:46:02 <kmc> not in standard Haskell or GHC's variant
14:46:25 <ivanm> that's it, who crashed lambdabot?
14:46:42 <kmc> Hugs supports "scoped type synonyms" or something like that
14:46:52 <kmc> which might be useful
14:47:02 <kmc> but then you're tied to an unpopular implementation
14:47:14 <cybercobra> kmc: gotcha.
14:47:21 <chrisdone> I'm experiencing a hemmorage trying to come up with a definition for a "script"
14:47:36 <EvanR-work> a program
14:47:54 <kmc> chrisdone, i have engaged this topic many times, and nothing enlightening has ever come of it
14:47:55 <EvanR-work> conservative first attempt ;)
14:48:50 <chrisdone> kmc: it's definitely one of those vague, you know what people mean when they use the word, but it can apply to anything given the right perspective
14:48:56 <arcatan> Merriam-Webster says: script - something written
14:49:08 <kmc> i don't really know what people mean when they use the word
14:49:28 <kmc> sometimes "a program that runs in the context of another program"
14:49:29 <cybercobra> chrisdone: a program that interacts with another program which would normally take its input from a human
14:49:31 <kmc> great, that's everything
14:49:41 <kmc> sometimes "a program which calls on other programs to do its work"
14:49:43 <kmc> also everything
14:49:49 <chrisdone> cybercobra: but then what's javascript?
14:49:55 <EvanR-work> "a program" ;0
14:50:09 <kmc> javascript is a dynamically typed, functional, object-oriented programming language
14:50:12 <chrisdone> kmc: seems to be about right
14:50:22 <kmc> "scripting language" is at best a confusing synonym for "dynamic language"
14:50:36 <kmc> and at worst a derogatory term for whatever language the speaker thinks is not suitable for "real programs" whatever those are
14:50:49 <chrisdone> well you could use haskell for scripting an irc client or whatever
14:50:53 <kmc> "dynamic language" is a fuzzy term and describes a constellation of related features
14:50:59 <kmc> but at least it's relatively neutral and objective
14:51:03 <kmc> if not binary-valued
14:51:06 <hpc> javascript is functional?
14:51:08 <hpc> since when?
14:51:09 <chrisdone> so "a scripting language" is like "a fibonacci writing language"
14:51:12 <erikc> kmc: in my experience, that's what it is (a language intended for non-programmers/untrusted programmers)
14:51:18 <kmc> hpc, since it has first-class functions, which i think is forever
14:51:20 <erikc> at least, as viewed by the business hats
14:51:33 <hpc> that doesn't make it functional though
14:51:37 <hpc> it is still very much imperitive
14:51:49 <EvanR-work> its dysfunctional ;)
14:51:50 <kmc> hpc, "functional" and "imperative" are not antonyms...
14:51:51 <cybercobra> hpc: see Douglas Crockford's writings regarding JavaScript being functional (not pure functional however)
14:52:03 <kmc> Haskell is also an imperative language
14:52:12 <ivanm> kmc: I tend to think of scripting languages as ucompiled languages (even to some bytecode/VM)
14:52:19 <kmc> ivanm, that's nonsensical
14:52:21 <cybercobra> kmc: er, in what sense?
14:52:22 <lelf> ?foldoc script
14:52:23 <ivanm> typically used for small throw-away "programs"
14:52:35 <EvanR-work> many script implementations are compiled, in some way
14:52:37 <kmc> ivanm, that's a property of implementation not of language
14:52:38 <ivanm> lelf: lambdabot is dead atm
14:52:39 <kmc> cybercobra, which?
14:52:48 <ivanm> kmc: yes, but you have defacto implementations
14:53:01 <kmc> ivanm, we shouldn't give defacto implementations too much authority
14:53:01 <ivanm> e.g. perl5 has only the one implementation AFAIK
14:53:02 <EvanR-work> defacto implementations are often compiled, python perl etc
14:53:04 <kmc> becuase often they suck ;P
14:53:05 <cybercobra> kmc: Haskell being imperative
14:53:13 <kmc> cybercobra, you can write imperative programs in Haskell
14:53:14 <cybercobra> lelf: <language>  A program written in a scripting language, but see Ousterhout's dichotomy.
14:53:19 <kmc> and imperative actions are a first-class type
14:53:28 <kmc> which makes it a *better* and more expressive imperative language than many
14:53:30 <chrisdone> kmc: no I think you've hit the nail on the head. a language can be called a scripting language when it's used to control other programs or systems
14:53:37 <olsner> if you use it for scripting it's a scripting language...
14:53:40 <kmc> chrisdone, isn't that every program?
14:53:51 <EvanR-work> any program with IO
14:53:52 <kmc> my C program is just a script for the Linux kernel ;P
14:54:04 <hpc> assembly is processor-script
14:54:07 <chrisdone> kmc: sure it is, but that's a given
14:54:12 <hpc> physics is universe-script
14:54:17 <EvanR-work> haha
14:54:23 <cybercobra> chrisdone: probably more when the system being scripted is platform-ish
14:54:31 <twink> I usually regard scripts as interpreted source (vs. e.g. bytecode).
14:54:34 <chrisdone> kmc: whereas, my c program is a script for mozilla's build process, then you might call it a script
14:54:43 <benmachine> that sounds like an implementation detail
14:54:46 <kmc> cybercobra, Haskell is a functional and imperative language.  some people misuse the term "imperative" to mean "only imperative" or "not functional"
14:55:02 <kmc> what do you mean that it's "a given"?
14:55:12 <hpc> wait, so functional means functions are first-class
14:55:18 <hpc> imperitive means actions are first class
14:55:25 <kmc> then C++ is not an imperative language ;)
14:55:29 <hpc> but functions == groups of actions
14:55:34 <kmc> hpc, not in Haskell
14:55:39 <EvanR-work> what besides haskell has first class actions
14:55:41 <kmc> by "action" i mean something specific
14:55:53 <kmc> EvanR-work, every language where functions are side-effecting and first class
14:55:56 <kmc> which is most of them really
14:56:01 <benmachine> hpc, kmc, your names look exactly the same so I have no chance of following this conversation and will stop trying at this point
14:56:11 <hpc> haha
14:56:18 <Raynes> Indeed.
14:56:28 <pcp> Now I'll fit in!
14:56:29 <cybercobra> benmachine: on my X-Chat, they even have the same color!
14:56:30 <EvanR-work> i usually confused when the first letter is the same, so im good here ;)
14:56:33 <benmachine> doesn't end in c
14:56:37 <gwern> hpc, pcp, kmc, xkcd: stop arguing with yourselves!
14:56:44 <kmc> EvanR-work, C#, D, Perl, Python, Ruby, Go, OCaml, SML, F#, Javascript
14:56:51 <kmc> post correspondence problem?!?
14:57:10 <kmc> Java and C++ with more effort, of course
14:57:15 <kmc> and C
14:57:16 <EvanR-work> kmc: got it, identifying actions with side effecting first class functions
14:57:17 <kmc> i mean you can always fake having closures
14:57:23 <kmc> EvanR-work, right
14:57:46 <EvanR-work> you didnt list PHP ;)
14:57:48 <cybercobra> kmc: they're not first-class in Java in a meaningful way. they're always subordinate to a class
14:57:56 <kmc> cybercobra, functions?
14:58:03 <kmc> i'm pretty sure that's incorrect
14:58:18 <kmc> oh sorry
14:58:25 <kmc> s/Javascript/Java/
14:58:30 <c_wraith> ah, that makes more sense
14:58:40 <hpc> i like to joke that you can make Java pure-functional by making constructors and private fields the only legal members of a class
14:58:41 <kmc> yes, functions are not first class in Java.  what i meant by "with more effort" is that you can use things like anonymous classes to sort of fake it
14:58:47 <kmc> haha hpc
14:58:55 <kmc> your constructor might still have side effects, though
14:59:06 <chrisdone> kmc: in the sense that it's obvious if you're working in linux, it controls the linux kernel. but that's nothing notable. that's how the language works. but if you write a c program to, say, write vim or emacs programs to control the vim/emacs system, then you could say you were scripting vim or emacs
14:59:15 <kmc> "Warning: Module `Prelude' is deprecated"
14:59:17 <kmc> o_O
14:59:21 <hpc> o.O
14:59:25 <c_wraith> kmc: you're compiling against base 3
14:59:29 <kmc> yeah
14:59:34 <kmc> i see that now
14:59:37 <McManiaC> > let ring-bell-function = 5 in ring-bell-function
14:59:42 <McManiaC> where is lambdabot :O
14:59:45 <kmc>  5
14:59:46 <ivanm> McManiaC: dead
14:59:47 <c_wraith> the message should really say "base 3 is deprecated", but whatever...
14:59:48 <ivanm> and I tried that
14:59:49 <McManiaC> =(
14:59:50 <olsner> @bot
14:59:51 <cybercobra> hpc: apparently Clojure's Java code looks very strange due to being functional
14:59:53 <ivanm> it was a failed parse
15:00:00 <ivanm> preflex: seen lambdabot
15:00:00 <preflex>  lambdabot was last seen on #haskell 40 minutes and 16 seconds ago, saying:   [1,2]
15:00:14 <ivanm> preflex: seen Cale
15:00:14 <preflex>  Cale was last seen on #haskell 1 hour, 52 minutes and 17 seconds ago, saying: Heh, "Why is this typechecking?! I want the compiler to tell me it's wrong!"
15:00:14 <McManiaC> [1,2]
15:00:21 <McManiaC> famous last words
15:00:24 <kmc> chrisdone, so you consider the OS to be an "invisible environment" while vim is a "visible environment"?
15:00:26 <orlandu63> heh
15:00:37 <cybercobra> guess there needs to be a meta-lambdabot to monitor lambdabot
15:00:51 <Cale> It thought it was still connected somehow
15:00:52 <chrisdone> kmc: they're both visible but depending on what you care about, aren't they?
15:00:57 <peoplea> can anyone help us or give any suggestion for www.byteinn.com?
15:01:19 <kmc> peoplea, add Haskell to the list of languages at the top ;P
15:01:21 <Saizan> kmc: what were you compiling btw?
15:01:27 <ivanm> @bot
15:01:31 <kmc> Saizan, vacuum-cairo
15:01:33 <lambdabot> :)
15:01:36 <ivanm> :D
15:01:38 <kmc> welcome back lambdabot
15:01:46 <kmc> > fix ((0:) . scanl (+) 1)
15:01:55 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
15:02:01 <kmc> she's usually sluggish right after waking up
15:02:09 <ivanm> yeah
15:02:11 <chrisdone> > fix id
15:02:15 <kmc> > fix error
15:02:16 <ivanm> @vixen here, have some coffee
15:02:21 <lambdabot>   mueval-core: Time limit exceeded
15:02:23 <lambdabot> I'm sorry, I'm confused.
15:02:25 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
15:02:29 <hpc> >fix fix
15:02:38 <kmc> Occurs check: blah blah blah
15:02:54 <chrisdone> a = a -> a
15:02:58 <kmc> cannot construct the infinite type a = a -> a (?)
15:03:05 <kmc> suggestion: read TaPL
15:03:06 <chrisdone> shrug
15:03:09 <kmc> :)
15:03:09 <chrisdone> hehe
15:03:12 <Cale> kmc: lambdabot has to join lots of channels, and this fact combined with the flood protection makes the responses slow
15:03:12 <kmc> it really ought to say that
15:03:13 <ivanm> it's obviously too early in the morning for lambdabot to want coffee...
15:03:40 <hpc> i see lambdabot attached to only #haskell
15:03:50 <hpc> er, member of
15:04:05 <ivanm> hpc: /whois lambdabot
15:04:12 <hpc> that's what i did
15:04:17 <hpc> [18:02:56]	===	lambdabot: member of #haskell
15:04:25 <ivanm> few more here...
15:04:29 <ivanm> #Gentoo-Haskell, etc.
15:04:30 <benmachine> freenode has a default policy of only letting you see channels that you're also in
15:04:54 * hpc is too used to foonetic
15:05:01 <ivanm> benmachine: that must be new, because I used to see a lot more channels listed in /whois than I was in
15:05:26 <benmachine> ivanm: default, if you unset mode +i it doesn't apply I think
15:05:52 <ivanm> in what?
15:06:10 <benmachine> in your heart
15:06:12 <benmachine> i.e. usermode
15:06:26 <chrisdone> kmc: we generally assume a program is going to be pure or work with the filesystem(s). by saying "script" you're adding a bit of info to say this program specifically controls another system. I think that's a pretty usable word
15:06:34 * benmachine -i self
15:06:55 <ivanm> *shrug*
15:06:58 <hpc> yeah, i just -i'd myself and still only get #haskell
15:07:05 <ivanm> chrisdone: wasn't that discussion on -blah?
15:07:13 <ivanm> hpc: lambdabot has to do it so you can see where she is
15:07:19 <hpc> ah
15:07:24 <SubStack> > sum $ take 100000 $ zipWith (*) (cycle [4,-4]) $ iterate (recip . (+2) . recip) 1
15:07:25 <lambdabot>   3.14158265358972
15:07:38 <ivanm> chrisdone: no, wait, I got confused methinks
15:09:57 <FliPPeh_> > let x =3 in x <3
15:09:58 <lambdabot>   False
15:10:02 <FliPPeh_> Tehehe, love.
15:10:07 <FliPPeh_> I wonder....
15:10:14 <fax> :t prime
15:10:15 <lambdabot> forall b. (Integral b) => b -> Bool
15:10:18 <Veinor> =3 is a furry
15:10:24 <FliPPeh_> > let x (<3) y = x ++ " lubs " ++ y
15:10:25 <lambdabot>   <no location info>: Parse error in pattern
15:10:29 <FliPPeh_> NOOOO
15:11:18 <fax> > [z|x<-[5,7],y<-[1,2,3],z<-[2*x*y+1,2*x*y-1],prime z]
15:11:19 <lambdabot>   [11,19,31,29,13,29,43,41]
15:11:28 <fax> hm
15:11:28 <applicative> > > sum $ take 100 $ zipWith (*) (cycle [4,-4]) $ iterate (recip . (+2) . recip) 1
15:11:29 <lambdabot>   <no location info>: parse error on input `>'
15:11:30 <hpc> > let x <3 y = x ++ " lubs " ++ y
15:11:30 <fax> that seems wrong
15:11:31 <lambdabot>   <no location info>: Parse error in pattern
15:11:37 <applicative> > sum $ take 100 $ zipWith (*) (cycle [4,-4]) $ iterate (recip . (+2) . recip) 1
15:11:38 <lambdabot>   3.1315929035585537
15:12:24 <hpc> it would be nice if Haskell required spaces between function names
15:12:35 <kmc> where?
15:12:35 <hpc> so we could have names like <3
15:12:38 <kmc> haha
15:12:52 <kmc> that's pretty much a requirement of doing mixfix correctly
15:12:55 <kmc> so i also agree :)
15:13:07 <at0mizer> good point, hpc
15:13:13 <applicative> oh wait misread 3.13....
15:13:24 <hpc> it would even fix the annoying-as-fuck (4 - -2) thing
15:13:54 <EvanR-work> > 4 - - 2
15:13:55 <lambdabot>   Precedence parsing error
15:13:55 <lambdabot>      cannot mix `GHC.Num.-' [infixl 6] and prefix ...
15:13:57 <EvanR-work> > 4 - -2
15:13:58 <lambdabot>   Precedence parsing error
15:13:58 <lambdabot>      cannot mix `GHC.Num.-' [infixl 6] and prefix ...
15:14:03 <kyagrd> > 4 - (-2)
15:14:04 <lambdabot>   6
15:14:14 <EvanR-work> haskell doesnt support minus a minus! oh.
15:14:45 <EvanR-work> let - -= +
15:14:45 <applicative> kmc, is 'mixfix
15:14:51 <applicative> found only in agda
15:15:05 <kmc> applicative, coq has it too, to some degree
15:15:11 <kmc> not as nice
15:15:13 <fax> uh
15:15:16 <fax> coq doesn't use mixfix
15:16:05 <kmc> Notation "'IFB' e1 'THEN' e2 'ELSE' e3" := (CIf e1 e2 e3) (at level 80, right associativity).
15:16:12 <kmc> seems like mixfix to me
15:16:54 <fax> yeah it's not
15:17:00 <kmc> it's different in that you only declare things prefix but you can then describe "notation" for them
15:17:07 <kmc> what's the key difference fax?
15:17:33 <fax> you dont have to put spaces everywhere
15:17:57 <webwanderer> can some one help me resolve this installation issue? http://pastebin.com/Ny1JU3MM
15:18:09 <webwanderer> I'm on ubuntu lucid.
15:18:43 <hpc> im not on linux atm, but i assume apt-get install GL didn't work?
15:18:52 <kmc> it's usually libmesa-dev or something
15:19:15 <kmc> webwanderer, anyway, you need the opengl development libraries
15:19:22 <kmc> the ones for C; it's not a Haskell issue
15:19:34 <EvanR-work> you know the seasons are changing when you hear new ubuntu names
15:19:42 <applicative> Thats what cabal install is telling him.....
15:20:17 <webwanderer> kmc: yes, but do you know how I can install the required libs under ubuntu?
15:20:28 <hpc> find it in apt
15:20:35 <webwanderer> EvanR-work: true :)
15:20:54 <hpc> that's how you solve almost every issue with missing libs on ubuntu
15:20:54 <dcoutts> kmc: btw, I applied your patch about the foreign libs/headers check
15:21:46 <kmc> dcoutts, thanks
15:22:56 <cybercobra> EvanR-work: what Alliterative Appellation are they on now?
15:23:08 <webwanderer> which one is it? http://pastebin.com/dPgNm9RY
15:23:13 <hpc> lucid lemur, i think
15:24:06 <EvanR-work> cybercobra: lumbering lobotomee or something
15:25:08 <kmc> fornicating ferret
15:26:01 <at0mizer> webwanderer: actually, none of those
15:26:12 <webwanderer> then?
15:26:16 <at0mizer> look up 'glut' or something like that
15:26:27 <webwanderer> at0mizer:^^
15:26:52 * kmc is amused by making type-unsound graphs in vacuum
15:27:10 <gwern> mangy monkey
15:27:23 <gwern> otiose ox
15:27:25 <ddarius> kmc: Why is it amusing?
15:27:42 <gwern> putrefied porpoise
15:27:55 <gwern> quizzical...
15:27:55 <kmc> no particular reason
15:28:02 <kmc> "newtype" is invisible
15:28:08 * gwern ponders. what animals *do* start with 'q'?
15:28:10 <kmc> so you can make a list of type [Mu Maybe]
15:28:10 <Gracenotes> hm, are there any asynchronous network modules readily available?
15:28:19 <ivanm> gwern: quarks? :p
15:28:23 <Gracenotes> there's always just forking a thread and using a Chan...
15:28:25 <kmc> where each element is Just (the previous one)
15:28:41 <gwern> 3 quarks for ivan marks
15:28:50 <RichardBarrell> kmc: are you playing with type-level Fix again?
15:28:57 <ddarius> gwern: quail
15:29:01 <gwern> ah, good
15:29:07 <gwern> quzzical quail
15:29:13 <at0mizer> quirky quail, then
15:29:22 <kmc> heh
15:29:26 <gwern> rabid rhinoceros
15:29:27 <kmc> yes
15:29:29 <kmc> @src Mu
15:29:29 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
15:29:33 <EvanR-work> Gracenotes: works well for me
15:29:34 <gwern> suppurating sheep
15:29:47 <gwern> (suffering sheep, maybe)
15:30:09 <gwern> tentacular tortoise
15:30:09 <Gracenotes> then that's it. and adding an extra Int for cleanup of the thread...
15:30:27 * gwern thinks that is particularly disturbing
15:30:41 <walkshoe> dons?
15:30:42 <cybercobra> gwern: not to mention nonsensical
15:30:43 <Gracenotes> er. so long as the UDP-waiting doesn't prevent GHC's RTS from context switching.
15:30:57 <gwern> cybercobra: only nonsensical if you avoid thinking of what it would be
15:30:58 <EvanR-work> Gracenotes: it doesnt
15:31:00 <RichardBarrell> gwern: not to nitpick or anything, but this kind of crazy would be more on-topic in #haskell-blah. :)
15:31:01 <kmc> testicular tortoise
15:31:06 <Gracenotes> wooo.
15:31:18 <EvanR-work> as long as nothing else is happening
15:31:28 <gwern> oh, that's better. 'oozing ox'
15:31:52 <kmc> Gracenotes, yeah, async IO is almost always handled by threading
15:32:07 <kmc> the RTS will use select() or epoll() on your behalf anyway
15:32:18 <at0mizer> gwern: obsessed octopus
15:32:34 <Axman6> lamer llama
15:32:50 <Gracenotes> umbraged urial
15:33:03 <kmc> async IO is usually some kind of heinous control inversion in order to avoid working with threads
15:33:10 <kmc> which makes less sense when threads are easy and cheap
15:33:13 <gwern> Axman6: L is already taken
15:33:19 <sepp2k> Can't I derive Show or Eq for GADTs?
15:33:21 <Gracenotes> I had to go to [[Outline of zoology]] for that one -.-
15:33:30 <pikhq> kmc: Very much a C thing.
15:33:31 <Axman6> not by a llama it isn't
15:33:32 <Gracenotes> gwern: when they loop around
15:33:43 <Axman6> gwern: god forbid
15:33:48 <Axman6> uh, Gracenotes
15:33:49 <pikhq> As much of a pain as async IO is, it's less so than pthreads.
15:33:52 <gwern> Gracenotes: loop around? that's like 32k codepoints away!
15:33:52 <EvanR-work> by heinous you mean bodacious
15:34:06 <gwern> EvanR-work: actually, I've heard both as synonyms
15:34:15 <gwern> EvanR-work: try pronouncing 'heinous' like Bill & Ted
15:34:25 <EvanR-work> exactly
15:34:34 <Gracenotes> kmc: it's mostly not wanting to get stuck querying UDP, when an event can happen any time (asynchronously, shock)
15:34:39 <kmc> sepp2k, you can use StandaloneDeriving
15:34:57 <Gracenotes> although said datagrams will only be checked once every short-while
15:35:06 <EvanR-work> you dont poll a udp socket, you just wait for stuff to arrive
15:35:21 <kmc> sepp2k, like so http://codepad.org/wsaCNCtW
15:35:25 <EvanR-work> its event based
15:35:43 <sepp2k> kmc: Thanks.
15:35:55 <EvanR-work> non blocking sockets isnt haskelly
15:35:56 <kmc> EvanR-work, polling would be doing nonblocking read() to see if anything's in the buffer
15:36:00 <kmc> yeah
15:36:08 <EvanR-work> and i dont like it in c either
15:36:10 <Gracenotes> well. hence the need for asynchronous functions, wrapped around Network.Socket wrapped around the C socket library
15:36:22 <kmc> well sometimes you might actually just want to check
15:36:23 <Gracenotes> as it is :/
15:36:25 <EvanR-work> no just fork a thread
15:36:35 <Gracenotes> yeah. that's the wrapping part.
15:36:35 <kmc> but nonblocking IO, as a substitute for concurrency, is not Haskelly
15:36:40 <gwern> blocking plays well with laziness, doesn't it?
15:36:56 <EvanR-work> hGetContents on the socket! ;)
15:36:58 <hpc> it doesn't block until it evaluates, so yes, sort of
15:37:05 <kmc> that's not "laziness" though
15:37:10 <kmc> that's "lazy IO", an abomination
15:37:32 <kmc> it's a corruption of the usual semantics of pure evaluation and IO execution
15:37:44 <copumpkin> kmc is so conservative
15:37:57 <Gracenotes> anyway. Chan will come and alleviate my troubles
15:38:08 <copumpkin> data 4Chan
15:38:08 <Gracenotes> haskell-chan? *cringe*
15:38:16 <applicative> kmc, the code you posted gets the usuall error
15:38:28 <kmc> hmm?
15:38:32 <Gracenotes> curri-kun
15:38:40 <applicative> (Constructor `Bar' does not have a Haskell-98 type)
15:39:08 <Ferdirand> data 4Chan = Tits | GTFO ?
15:39:11 <gwern> data 4Chan = DesuDesu 4Chan | GTFO | Tits
15:39:28 <mreh> haaaa
15:39:47 <kmc> applicative, works for me in GHC 6.12.1.  with standalone "deriving instance", not with an attached "deriving (Show)"
15:40:01 <mreh> data AnonTalk?
15:40:09 <applicative> of course, 6.12  I was going to ask about that to begin with.
15:40:12 <gwern> mreh: shut your mouth
15:40:29 <gwern> we don't talk about that
15:41:07 <mreh> I feel like I just made a joke and everyone is laughing, except they're not, they're punching me
15:41:32 * copumpkin punches mreh
15:41:38 <walkshoe> Hello I am actually a woman! I have one of those where your penis goes! Now the challange I want to issue is that one of you make an actually useful program with Haskell. The one who does wins and gets to ... you know with me. I feel pretty safe!
15:41:46 <kmc> @remember mreh I feel like I just made a joke and everyone is laughing, except they're not, they're punching me
15:41:46 <lambdabot> It is forever etched in my memory.
15:41:53 <elly> Um.
15:41:56 <kmc> walkshoe, why are you so sex-negative?
15:42:07 <gwern> @quote sex
15:42:07 <lambdabot> lament says: sex is definitely not the mainstream way of breaking up with someone
15:42:14 <kmc> get your oppressive patriarchal bullshit out of here
15:42:23 <kmc> lambdabot, i respectfully disagree
15:42:23 <walkshoe> you have 24 hours
15:42:34 <copumpkin> walkshoe: we don't want it
15:42:41 <Gracenotes> oh, lord
15:42:48 <gwern> as linus said, sex is like software - better when free
15:42:52 * elly blinks.
15:42:55 <hpc> hahaha
15:42:56 <walkshoe> hahaha way to set yourself up for failure copumpkin
15:43:03 <copumpkin> elly: would you write software for walkshoe to get in her pants?
15:43:07 <copumpkin> I didn't think so!
15:43:15 <elly> copumpkin: er, no, but... I could just like... ask my boyfriend
15:43:22 <Gracenotes> not my type :/
15:43:25 <copumpkin> why would you want him getting in her pants?
15:43:30 <elly> I wouldn't?
15:43:34 <walkshoe> whoa either you're all gay or you doubt in haskell
15:43:39 * copumpkin is being intentionally obtuse
15:43:41 * elly blinks
15:43:49 <elly> my boyfriend also knows haskell
15:43:54 <copumpkin> walkshoe: a fair percentage of us is gay, for what it's worth
15:43:57 <elly> I don't really understand what is being gotten at here
15:44:01 <Gracenotes> ..represent
15:44:04 <fax> 100%
15:44:05 <fax> :D
15:44:06 <walkshoe> elly you should do the same
15:44:11 <elly> I mean, I am one of those 'actual woman' types
15:44:18 <walkshoe> maybe we can get 2 useful haskell programs
15:44:19 <copumpkin> omg real women in the house
15:44:23 <kmc> oh em gee
15:44:34 <elly> walkshoe: or you could learn haskell and write them yourself...?
15:44:34 <at0mizer> oh shi~
15:44:36 <sepp2k> What does "Constructor `Foo' does not have a Haskell-98 type" mean?
15:44:38 <Gracenotes> hah
15:44:41 <copumpkin> now if Gracenotes offered his "graces", I may reconsider
15:44:48 <mauke> then you could get into your own pants?!
15:44:49 <Gracenotes> only for you, copumpkin
15:44:52 <copumpkin> yay
15:44:57 <elly> mauke: That sounds like it could be fun, actually
15:44:58 <walkshoe> elly: auction away you cookie like me
15:45:00 * copumpkin writes a useful program
15:45:04 <kmc> sepp2k, means it's a GADT-specific constructor basically
15:45:06 <elly> walkshoe: that sounds disgusting, actually
15:45:06 <applicative> sepp2k, it just means that its an intrinsically GADT type
15:45:10 <elly> I'd rather have my dignity :P
15:45:15 <walkshoe> elly: are you lesbian?
15:45:18 <elly> no.
15:45:19 <fax> the reason so many haskell programmers are gay is because of the lambda symbol
15:45:24 <walkshoe> these are fine young men
15:45:25 <copumpkin> oh damn, we scared off ddarius
15:45:26 <elly> fax: hahahahahaha
15:45:27 <kmc> fax +5 Insightful
15:45:32 <elly> fax: <3
15:45:39 <walkshoe> now if only they could write a useful Haskell program
15:45:44 <mauke> I don't get it
15:45:46 <elly> walkshoe: I know. I am rather attached to one of them.
15:45:49 <copumpkin> walkshoe: either way, no such program exists
15:45:53 <copumpkin> it's an oxymoron, even
15:45:56 <fax> im just being silly
15:46:00 <elly> (she says, as 'darcs record' waits for input on another terminal, managed by xmonad...)
15:46:13 <copumpkin> fax: damn, you had me convinced! I really thought the lambda was the explanation
15:46:14 <kmc> walkshoe, you should post your request on haskell-cafe@
15:46:18 --- mode: ChanServ set +o mauke
15:46:18 --- mode: mauke set +q *!*@gateway/web/freenode/x-bggknmscudnvsoyt
15:46:20 <hpc> walkshoe: if you are going to let random people from IRC into your pants, you should use protection, preferably AES or RSA
15:46:34 <copumpkin> mauke is flexing his manmuscle
15:46:37 <elly> copumpkin: It's my favorite explanation now
15:46:49 <benmachine> I think there is a lot of silliness going on!
15:46:55 <copumpkin> surely not
15:46:55 <elly> "What's all this, then?"
15:47:08 <copumpkin> mauke: I take it you don't want to get in walkshoe's pants?
15:47:12 <elly> also, thanks mauke :)
15:47:13 <mauke> http://dl.dropbox.com/u/2261572/2elxr4o.png
15:47:15 <applicative> sepp2k are you using ghc-6.12?  6.10 rejects the ...deriving instance... syntax
15:47:26 <mreh> I'm going to annoy everyone again by asking about existentials
15:47:28 <gwern> well said mauke
15:47:30 <benmachine> mauke: well expressed
15:47:36 <copumpkin> mreh: sounds good to me
15:47:36 <benmachine> gwern: also
15:47:44 <elly> mauke: I like it
15:47:44 <sepp2k> applicative: Yeah, I just figured that out. I'm using 6.10
15:47:46 <copumpkin> mreh: are you having an existential crisis?
15:47:49 <gwern> @remember mauke if you are going to let random people from IRC into your pants, you should use protection, preferably AES or RSA
15:47:52 <gwern> @flish
15:47:57 <mauke> @fail
15:48:01 <mreh> I have two conflicting reports, 1) haskell has an existential qualifier 2) haskell does not have an existential qualifier
15:48:03 <kmc> mreh, i'm going to annoy you by attempting to answer your question
15:48:08 <mauke> gwern: I never said that
15:48:09 <mreh> I.E. a backwards E
15:48:09 <applicative> sepp2k, I see, me too.  I don't want to update again....
15:48:10 <copumpkin> mreh: only sort of
15:48:14 <kmc> mreh, standard Haskell 98 or 2010 has no existential types at all
15:48:16 <gwern> doh
15:48:18 <copumpkin> mreh: I think JHC does though
15:48:18 --- mode: mauke set -o mauke
15:48:20 <gwern> @forget mauke if you are going to let random people from IRC into your pants, you should use protection, preferably AES or RSA
15:48:29 <mreh> i'm talking about GHC extensions
15:48:31 <kmc> GHC Haskell has existential types; they are introduced with the "forall" keyword in a special place, rather than with an "exists" keyword
15:48:31 <benmachine> @bots
15:48:31 <gwern> @remember hpc if you are going to let random people from IRC into your pants, you should use protection, preferably AES or RSA
15:48:35 <gwern> @flush
15:48:38 <hpc> hehe
15:48:42 <benmachine> @vixen helloooo
15:48:51 <kmc> some other compilers (UHC? JHC?) support "exists"
15:48:53 <copumpkin> mreh: it doesn't have an exists x. syntax
15:49:04 <kmc> another consequence of the way GHC does it is that you need wrapper types
15:49:12 <kmc> i.e., you can't make [exists a. (Ord a) => a]
15:49:14 <kmc> you have to write
15:49:23 <kmc> data Ordered = forall a. (Ord a) => Ordered a
15:49:26 <kmc> and then [Ordered]
15:49:27 <copumpkin> you can CPS it though
15:49:44 <kmc> if you CPS hard enough then you don't need existentials at all, just rank-N.  i think.
15:49:45 <mreh> copumpking: so if I want to return some polymorphic value (exists a) then I have to do it CPS with a forall
15:49:57 <fax> if you CPS to hard you can rupture your redex
15:49:57 <kmc> mreh, no, you can use an existential wrapper type
15:50:03 <copumpkin> either a wrapper or CPS
15:50:09 <copumpkin> fax: ouch
15:50:30 <mreh> the exists keyword doesn't make intuitive sense to me anyway
15:50:43 --- mode: ChanServ set +o mauke
15:50:43 --- mode: mauke set -q *!*@gateway/web/freenode/x-bggknmscudnvsoyt
15:50:44 <mreh> forall is easy, it follows from first order logic
15:50:47 <fax> DURRRR I just eralized there complex conjugates
15:50:50 <kmc> mreh, a value of type "exists a. T a" is a pair
15:50:55 <kmc> the first element of the pair is a type A
15:51:02 <kmc> the second element is a value of type T A
15:51:08 <kmc> mreh, TaPL has a good chapter on existentials
15:51:20 <copumpkin> use the power of sigma!
15:51:32 <Mathnerd314> > 1+1 -- what happened to lambdabot?
15:51:37 <fax> 2
15:51:38 <copumpkin> she died
15:51:39 <elly> Higher-order types, assemble!
15:51:40 <kmc> mreh, if you think about constructive logic, a proof of "exists a. T a" is some "witness" value plus a proof that T holds for the witness
15:51:49 <copumpkin> elly: so have you learned haskell yet? or are you still waiting for me
15:51:59 * elly .oO(Did we just miss out on the opportunity for hot copumpkin-on-gracenotes action?)
15:52:04 <elly> copumpkin: still waiting! I told you I would :)
15:52:06 <kmc> what now
15:52:11 <copumpkin> elly: it happened in PM, sorry
15:52:14 <elly> copumpkin: :(
15:52:15 <copumpkin> Gracenotes was surprisingly fast
15:52:21 <fax> we should make #haskelgbt
15:52:27 <Gracenotes> ಠ_ಠ
15:52:28 <mreh> ski was explaining this me, I was like "say whaaaaa?!"
15:52:33 <elly> fax: I'm down, let's do it
15:52:39 <fax> :S I was not serious
15:52:43 --- mode: mauke set -o mauke
15:52:56 <mreh> kmc: TaPL?
15:52:59 <kmc> wasn't there already a big thread on haskell-cafe about that?
15:53:00 <kmc> @where TaPL
15:53:04 <mreh> :)
15:53:08 <kmc> hurr durr
15:53:11 <mreh> she isn't there
15:53:12 <kmc> http://www.cis.upenn.edu/~bcpierce/tapl/
15:53:13 <Gracenotes> copumpkin: pure skill. that is all.
15:53:14 <mauke> preflex: ? tapl
15:53:14 <preflex>  factoid not found
15:53:20 <mauke> preflex: + tapl http://www.cis.upenn.edu/~bcpierce/tapl/
15:53:21 <kmc> lambdabot come home
15:53:34 <Gracenotes> there was a series of unproductive haskell-cafe threads about gender and sexuality of haskellers
15:53:53 <kmc> any furry haskellers itt
15:53:56 <applicative> man, it was so alarming
15:53:58 <copumpkin> we're having good talk in #haskelgbt
15:53:59 <gwern> tapl, incidentally, is partially available in google books
15:54:06 <gwern> and an iranian website hosts a complete copy
15:54:08 <mreh> that talk about evo psych was so boring
15:54:10 <alpounet> copumpkin, gbt ?
15:54:25 <mreh> i TL;DRed when I saw how much it was going on
15:54:25 <copumpkin> lgbt
15:54:26 <applicative> can we start spamming people who write obnoxious notes to haskell cafe
15:54:35 <mreh> yeah!
15:54:43 <Gracenotes> also great stuff going on in #haskell-blt
15:54:45 <gwern> applicative: who's been doing that besides the guy asking about gender?
15:54:49 <Gracenotes> much eating of bacon
15:54:59 <mreh> people who think they're experts on that great astrological tradition, evolutionary psychology
15:55:48 <pikhq> Gracenotes: OMNOMNOM
15:55:55 <applicative> that was bad, so was the one about the 'elders'..   The initial letters werent so bad, the guy is pleasant enough, but then all sorts of things that don't make sense in a community of wildly diverse people were said...
15:56:31 <copumpkin> Gracenotes: that channel has just about everyone but you in it now
15:56:35 <chrisdone> I just filter threads like that
15:56:45 <mreh> is this university of Utrecht thing worth stumping up the money?
15:56:57 <kmc> what?
15:57:10 <mreh> advanced functional programming summer school
15:57:29 <chrisdone> mreh: I know there is an army of haskellers at utrecht
15:57:47 <mreh> I might be going there after my advanced unctional programming course
15:57:53 <mreh> in the vatican
15:57:53 <chrisdone> I met 6 or so at zurihac, all brilliant
15:58:08 <mreh> I was hoping some of the brilliance might rub off
15:58:36 <mreh> I had a telephone interview with Jane Street, not bad for a kid who taught himself haskell, but I don't think i was brilliant enough
15:58:54 * chrisdone imagines most haskellers taught themselves
15:59:40 <erikc> i assume having a lot of finance domain knowledge would also be important for Jane Street
15:59:41 <mreh> where can I contribute in haskell right now? I'm at a lose end
15:59:51 * dmhouse is working at Jane Street this summer
15:59:54 <mreh> erikc: they asked nothing of finance
16:00:00 <gwern> erikc: I hear not
16:00:09 <erikc> really? weird
16:00:14 <mreh> I read it on their website
16:00:15 <chrisdone> mreh: if you really care about contributing and that's what motivates you then there's the haskell proposals reddit
16:00:22 <dmhouse> erikc: depends, if you apply in the quant area you're basically just a programmer. I had 5 interviews and no finance knowledge was asked
16:00:39 <mreh> dmhouse: who else?
16:00:59 <dmhouse> mreh: no-one I know from the Haskell community
16:01:10 <chrisdone> personally I like to contribute but that doesn't motivate me
16:01:13 <mreh> dmhouse: who else were you interviewing with
16:01:26 <dpratt71> I just signed on a short time ago and the first thing I see is "Gracenotes: also great stuff going on in #haskell-blt"
16:01:48 <gwern> mreh: as far as contributing, you can adopt a project on darcswatch! few large projects have anyone checking to make sure patches get discussed, applied, and not ignored
16:01:53 <elly> I would totally also join #haskell-blt
16:01:55 <dpratt71> so I /join #haskell-blt and...nothing; did I miss something?
16:02:01 <elly> although I am a vegetarian, so
16:02:09 <theorbtwo> dpratt71: Yes.
16:02:12 <mreh> gwern: I want to adopt Frag, trivial as it is.
16:02:23 <dpratt71> theorbtwo: ok, good to know
16:02:29 <elly> @pl \(x, y) -> (x, x)
16:02:29 <mreh> I want to implement a STRIPs planner, or maybe a Markov decision process
16:02:32 <Gracenotes> elly: try turkey bacon! oh wait, vegetarian is not Jewish, and my mind's all over the place
16:02:33 <chrisdone> mreh: haskell needs a leading web development library
16:02:35 <dmhouse> mreh: oh, I had interviews with Bene, with Mark Shinwell, with Nick Chapman, then an interview down in London with those guys, then a final phone interview with some guy from the US
16:02:43 <dmhouse> mreh: I applied to the London office as I'm British
16:02:48 <gwern> mreh: frag's biggest problem right now is that the AI characters are not in the right place on the level, because I had to rip out the original level data as copyio
16:02:52 <dmhouse> Although I'm spending 2 months in New York
16:02:56 <Gracenotes> dpratt71: it was a fake channel, alas
16:02:58 <mreh> dmhouse: did they insist on flying all the way to america to interview
16:03:07 <gwern> mreh: if you could rejigger the ai characters to actually work with the level, that'd be worth a release
16:03:08 <chrisdone> I think you could copy the ASP .NET model and substitute .NET with Haskell
16:03:11 <dmhouse> mreh: not in the end, it was mentioned as a possibility
16:03:15 <mauke> elly: join (,) . fst ?
16:03:20 <dmhouse> mreh: I would have loved it, an expenses-paid trip to the US :)
16:03:24 <elly> mauke: yeah, I just realized that
16:03:24 <dpratt71> Gracenotes: I see; perhaps I'll take a trip to the archives...
16:03:31 <mreh> gwern: it's biggest problem is that it doesn't compile!
16:03:33 <Gracenotes> .. and only down side to Chans is that there's no foolproof way of doing an asynchronous take, if there's a race condition between isEmptyChan and readChan
16:03:34 * dmhouse has never even been to America
16:03:39 <gwern> mreh: oh? when did that happen?
16:03:51 <dmhouse> mreh, who did you interview with?
16:03:52 <Gracenotes> it still doesn't expose tryTakeMVar, I think. darn it.
16:04:04 <mreh> dmhouse: flying is not fun :)
16:04:04 <mreh> gwern: bitrot
16:04:04 <mreh> dmhouse: bene
16:04:08 <EvanR> Gracenotes: what?
16:04:19 <EvanR> readChan
16:04:21 <kmc> Gracenotes, that sucks :(
16:04:21 <dmhouse> mreh: Bene was hardcore. He didn't give many hints. Don't think I impressed him very much
16:04:28 <mreh> dmhouse: me neither
16:04:35 <mreh> that's good
16:04:53 <Gracenotes> readChan -> IO a
16:05:15 <EvanR> you shouldnt be trying to poll
16:05:19 <mreh> "do you know how to represent a closure?" - "a string?"
16:05:35 <mreh> all I could think of was a lambda expression with an unbound variable
16:05:37 <dmhouse> He asked me about garbage collection on the phone and mostly fucked it up, also fumbled over some basic FP concepts (folds! Got there eventually though). In real life he asked me about reservoir sampling, which is really cool and I'd not seen it before
16:06:06 <dmhouse> Sorry, *I* mostly fucked it up, not him
16:06:06 <EvanR> Gracenotes: if you want to react to two signals in the chan, make the chan Chan (Either a b)
16:06:11 <mreh> dmhouse: he asked me about folds too, right AND left
16:06:18 <mreh> :)
16:06:25 <chrisdone> you fumbled over folds? naughty
16:06:49 <Gracenotes> EvanR: okay.. the goal is to do a once-a-frame look at UDP packages arriving asynchronously
16:07:00 <EvanR> eh?
16:07:16 <Gracenotes> frame here referring to a loop of events
16:07:42 <kmc> Gracenotes, hmm, might actually want async IO for that
16:07:43 <dmhouse> Yeah. "Why is foldl better in a strict language?" "More memory efficient, e.g. summing [1..1000] won't blow up." "What else?" "..." "Do you know what tail recursion is?" "OH, it's also tail recursive!"£
16:07:44 <EvanR> so you want to combine two streams, events and maybe udp
16:07:49 <mreh> the condition for a right fold being lazy I couldn't answer, but it's clearly if it returns a partial solution (e.g. a list element) which is calculated from a finite number of elements of the list
16:07:49 <lispy> Will haskell' ever remove cyclic modules?
16:07:56 <kmc> if some other event loop is running it for you
16:08:08 <Gracenotes> er, by events I might the code that actually analyzes the packages and updates state
16:08:13 <Gracenotes> s/might/mean/
16:08:28 <dmhouse> He asked me again about these things in real life and I was able to give better answers thank god
16:08:33 <EvanR> make a thread which reads from the socket and writes to an MVar
16:08:36 <kmc> or yeah as EvanR suggests, you can have the event loop and the network listener (blocking) showe stuff into a Chan
16:08:38 <Gracenotes> and then probably sleeps for a few dozen milliseconds
16:08:41 <mreh> dmhouse: cool, where is based?
16:08:42 <dmhouse> Mostly by working out on the whiteboard how the difference in association makes a difference
16:08:49 <EvanR> the code that processes it tries to read the MVar
16:08:50 <Gracenotes> EvanR: that's when I'm ending up doing
16:08:57 <Gracenotes> with tryTakeMVar
16:09:10 <dmhouse> mreh: the office was in the Liverpool St. They've just moved about 5 minutes down the road to the Moorgate area
16:09:26 <mreh> dmhouse: I really hope they don't fly me to america
16:09:31 <Gracenotes> @type takeWhileM
16:09:31 <mreh> were you applying to be an intern?
16:09:39 <dmhouse> mreh: yeah
16:09:47 <kmc> we're all living in amerika
16:09:49 <dmhouse> mreh: you?
16:09:53 <kmc> amerika is wunderbar
16:09:55 <mreh> dmhouse: jorb
16:10:14 <mreh> I don't want to fly 14 hours to america and back for a job I don't get :(
16:10:21 <dmhouse> mreh: that's cool. Just had the one interview then?
16:10:24 <kmc> mreh, free trip?
16:10:30 <mreh> kmc: yes
16:10:31 <dmhouse> mreh: really? Ask them to put the flights a week apart and go sightseeing
16:10:32 <theorbtwo> I'm afraid of amerika.  I'm afraid of the world.  I'm afraid I can't take it.
16:10:43 <EvanR> theorbtwo: you too? ;)
16:10:46 <mreh> dmhouse: well, that might be an idea
16:10:58 <erikc> american freaks me out, i dunno why
16:11:04 <erikc> america
16:11:08 <mreh> I've never flown alone
16:11:13 <dmhouse> It's quite easy
16:11:22 <theorbtwo> I have, a couple times.  It's not that bad.
16:11:25 <dmhouse> Turns out we've pretty much nailed the physics of flying by now
16:11:36 <theorbtwo> Take lots of books, avoid long stopovers.
16:11:37 <mauke> huhu, my first flight was alone. to america.
16:11:38 <mreh> are the wings hard to attatch?
16:11:42 <erikc> just get drunk
16:11:46 <kmc> the best entertainment for flying is marijuana
16:11:52 <theorbtwo> My first flight in a very long time was *from* america, alone.
16:12:08 <kmc> because it makes it supremely enjoyable to sit in a chair, watch TV, listen to music, and look out the window at slowly moving pretty pictures
16:12:18 <theorbtwo> ...with very long stopovers in Boston and then a short one in London.
16:12:56 <theorbtwo> s/stopovers/stopover/; s/very/a very/;
16:13:23 <mreh> who flys london to NY?
16:16:32 <mreh> I wonder if they'll fly my mum over too?
16:17:12 <EvanR> what kind of performance could i expect from fromIntegral :: Word32 -> Int
16:17:38 <dmhouse_> mreh, but yeah, I found my interviews with Mark and Nick easier than my one with Bene
16:17:54 <mreh> dmhouse_ cool, bene was quite intense, I agree
16:18:15 <dmhouse_> mreh: also, the salaries are fucking sweet :) I'm not sure I should say exactly how sweet, they seemed fairly protective of their numbers, but I was pleasantly surprised
16:18:41 <mreh> dmhouse_ is it unsatisfying work then?
16:18:55 <mreh> a haskell programmer is quite a skilled person
16:19:19 <dmhouse_> mreh: well I don't know, I'm working this summer
16:19:23 <dmhouse_> But it sounded reasonably interesting
16:19:30 <dmhouse_> I'm quite interested in finance anyway
16:19:42 <dmhouse_> Plus, y'know, it's an FP shop, there must be some smart guys there
16:20:01 <mreh> it's fully genius I'm told
16:20:45 <dmhouse_> Any firm remotely to do with finance will pay shitloads, because they make shitloads. I don't think there's necessarily a correlation between boring work and good pay in software
16:21:00 <dmhouse_> Being an actuary on the other hand... :)
16:21:06 <jmcarthur> woah, DAGs in unix shell http://code.google.com/p/push/
16:22:42 <erikc> getting to use FP at work would be fun
16:23:00 <erikc> i couldnt find a single FP shop in canada
16:23:02 <dmhouse_> jmcarthur: sounds cool. No examples though...
16:23:59 <jmcarthur> looks like the intent is for mapreduce-like workflows
16:24:13 <jmcarthur> based on the abstract
16:24:19 <Gracenotes> I'm not so much liking how these functions make you pass a SockAddr from Network.Socket.Internal: http://hackage.haskell.org/packages/archive/hosc/0.8/doc/html/Sound-OpenSoundControl-Transport-UDP.html
16:24:23 <EvanR> is there an unsigned unbounded type, perhaps called Natural ?
16:24:32 <jmcarthur> EvanR: i wish
16:24:34 <Gracenotes> when you already gave it that information setting up the UDP type :
16:24:45 <fax> data Natural = Zero | Succ Natural
16:24:48 <jmcarthur> EvanR: there's some lazy naturals around, but that might not be what you want
16:24:50 <fax> NEXT
16:24:52 <jmcarthur> yeah like that
16:24:53 <dmhouse_> jmcarthur: also, wtf is that Plan 9 dependence?
16:24:53 <jmcarthur> :P
16:25:03 <jmcarthur> dmhouse_: well, the plan 9 on unix stuff
16:25:04 <dmhouse_> EvanR: Integer
16:25:07 <jmcarthur> i haven't tried it
16:25:12 <jmcarthur> but i hear it's great stuff
16:25:20 <EvanR> hm.
16:25:32 <dmhouse_> EvanR: for anything serious, doing data Nat = Z | S Nat is crazy inefficient
16:25:53 <jmcarthur> heh, yeah, Integer is unsigned if you use it that way (or make a newtype wrapper, perhaps)
16:25:59 <EvanR> Gracenotes: UDP is not bound to an address
16:26:01 <erikc> jmcarthur: http://en.wikipedia.org/wiki/Hartmann_pipeline
16:26:08 <EvanR> Gracenotes: a udp socket can send to any address at any time
16:26:34 <jmcarthur> erikc: cool
16:27:37 <Gracenotes> yeah, though I need the abstraction of talking to a specific OSC-understanding device. I'm not too sure the library writer had something more general in mind...
16:27:41 <FliPPeh_> UDP is not fun :(
16:27:53 <EvanR> Gracenotes: sounds like you want an abstraction
16:28:24 <EvanR> and another for OSC ;)
16:28:26 <Gracenotes> well, why would he make a UDP wrapper around Network.Socket.Socket in the first place then? -.-
16:28:37 <EvanR> so you can use udp
16:29:03 <EvanR> a valid use case is to get datagrams from anywhere, and send to anywhere
16:29:14 <Gracenotes> meh. the other half of the thing comes from using a rather internal type...
16:29:18 <gwern> dmhouse_: er, isn't the answer foldl being 'more memory efficient' inclusive of being 'tail recursive'
16:29:39 <dmhouse_> gwern: yes, I paraphrased badly
16:30:00 <Gracenotes> surely better than doing it *all* myself, though
16:30:26 <EvanR> make your own abstractions, verify them, use them
16:31:20 <EvanR> and when everything is bug free, you still have the possibility of unreliable udp communication ;)
16:31:27 <Gracenotes> you can't use the same socket to both receive and send, can you?
16:31:33 <EvanR> with udp you can
16:31:33 <hpc> yes
16:31:41 <EvanR> and tcp, actually
16:32:03 <EvanR> full duplex!
16:33:14 <Gracenotes> I'm just trying to see where that comes across in the code. so udpServer binds to a port/address, and openUDP calls Network.Socket.connect to it.
16:33:28 <EvanR> you dont connect a udp socket
16:33:40 <Gracenotes> yeah, that's what's confuzzling about it
16:33:44 <EvanR> a udp server is not different from a client
16:33:53 <EvanR> so the api may be misleading
16:34:47 <Gracenotes> now the receive and send ports are different for this OSC device, so I can use that to my advantage... UDP sockets are pretty promiscuous, then
16:35:19 <jmcarthur> wait, you have to go to the low level socket layer to get udp?
16:35:26 <jmcarthur> that doesn't seem right
16:35:31 <EvanR> just Network is pretty barebones
16:35:55 <Gracenotes> the SockAddr object expects a Word8 and a Word32
16:36:24 <EvanR> for best results dont construct your own addresses, use getAddrInfo
16:36:49 <jmcarthur> might i recommend network-fancy?
16:36:56 <jmcarthur> it's surprisingly nice
16:36:59 <Gracenotes> and the method to lookup something is with the innocuously named inet_addr function
16:37:05 <EvanR> yeah, dont use that
16:37:11 <jmcarthur> unless you really *need* low level
16:37:21 <EvanR> inet_addr converts, doesnt look up
16:37:44 <EvanR> a higher level library is probably a good idea ;)
16:37:56 <Gracenotes> well, thankfully it's unequivocally 127.0.0.1
16:38:07 <Gracenotes> so I just put 0x7f000001 in >_>
16:38:16 <jmcarthur> :o
16:38:19 <EvanR> >_<
16:38:22 <jmcarthur> waste of brain power
16:39:02 <fax> I need more brain power
16:40:01 <blackdog> anyone looked at Barry Jay's Bondi language?
16:40:42 <blackdog> really interesting talk last night at fp-syd - manages to retain referential transparency while having the ability to introduce new code and types at runtime
16:42:52 <blackdog> among other things, a really neat solution to the expression problem
16:43:23 * hackagebot data-binary-ieee754 0.4.1 - Parser/Serialiser for IEEE-754 floating-point values  http://hackage.haskell.org/package/data-binary-ieee754-0.4.1 (JohnMillikin)
16:43:49 * EvanR thumbs through the manual to figure the difference between Integral and Num
16:43:55 <EvanR> Integral has division?
16:44:05 <kmc> @src Integral
16:44:12 <kmc> nooooo lambdabot
16:44:17 <EvanR> *cricket* *cricket*
16:44:31 <hpc> Integral has div
16:44:31 <mauke> EvanR: Num is all types of numbers
16:44:38 <hpc> floating has /
16:44:40 <kmc> integral has: quot, rem, div, mod, quotRem, divMod, toInteger
16:44:58 <kmc> so yes, integral division and toInteger
16:44:59 <EvanR> Integral has quotients and remainders
16:46:15 <EvanR> if my algorithm uses Word32, should i make the type of the function Integral a => [a] -> X, or Num a => [a] -> X, or [Word32] -> X
16:46:34 <EvanR> if just convert the input into Word32
16:46:50 <kmc> then all you need is fromIntegral
16:47:06 <kmc> which is (Integral a, Num b) => a -> b
16:47:21 <EvanR> yes, thats how i convert
16:47:22 <kmc> EvanR, Num is less specific; you can always try that and change if it complains
16:47:41 <EvanR> so Num instances may not be convertible ?
16:47:47 <kmc> indeed
16:47:49 <EvanR> i should use Integral then
16:47:55 <kmc> for example, how do you convert a complex number to a Word32?
16:48:09 <hpc> complex as in a function of i?
16:48:10 <EvanR> you cant, it isnt Integral
16:48:15 <kmc> right
16:48:24 <hpc> what EvanR said
16:48:29 <kmc> yeah
16:49:01 <hpc> you can do type Complex = (Word32, Word32) though
16:49:10 <hpc> or something like that
16:49:51 <EvanR> > take 1024 [1,2,3]
16:49:58 <EvanR> >_<
16:55:42 <Twey> EvanR: [1, 2, 3]
16:56:12 <EvanR> thanks
16:56:23 <EvanR> emergency computation procedure
16:56:30 <Twey> Haha
16:57:33 <kmc> when lambdabot's gone, we all have to take our turn in the barrel
16:58:34 <blackdog> kmc: i feel dirty even knowing that joke
16:59:14 * BMeph sympathizes with the dog.
16:59:16 <alpounet> Cale, ping ?
17:00:53 <EvanR> how do i get the top 32bits result of a Word32 multiplication :)
17:01:34 <EvanR> cast to Word64 first?
17:02:00 <Cale> EvanR: yeah
17:04:35 <Reisen> Just how fast is Haskell compared to other languages? I can't help but feel that it's slow, but I'm completely uneducated about it
17:04:48 <fax> Reisen I don't think it's very slow
17:04:52 <Cale> Reisen: Haskell is a language
17:05:01 <Reisen> I keep doing this
17:05:06 <Reisen> Ok, how fast is code outputted by GHC
17:05:06 <Reisen> Sorry
17:05:16 <Cale> Reisen: GHC produces reasonably fast code :)
17:05:18 <Reisen> Obviously it depends on what you're doing but, in general
17:06:51 <Cale> One thing which is tricky at first is that intuition about what performs well under lazy evaluation takes a while to develop.
17:07:03 <Cale> So it's easy to write slow programs at first.
17:07:56 <Cale> But generally if you stick to using appropriate datastructures it's not so bad.
17:08:20 <kmc> Reisen, often the first working attempt at solving your problem in Haskell will be much slower than the first working attempt at solving your problem in C
17:08:27 <kmc> and arrived at in 10-20% of the time
17:08:43 <kmc> so you can take this to mean "Haskell is slow" or you can take it to mean "Haskell gives you results quickly and lets you optimize where needed"
17:08:56 <kmc> if you want to troll Reddit i recommend the former viewpoint
17:09:05 <kmc> if you want to write software, the latter is more useful :)
17:09:31 <kmc> it is important that we *do* have ways of writing fast code
17:09:36 <FliPPeh_> I learned, that the biggest slowdowns are shared by all languages anyways. Network IO really drags stuff down.
17:09:45 <kmc> the easiest being to use a fast datastructure / algorithm library written by someone smart
17:10:04 <kmc> a lot of effort has gone that direction recently and i'm very happy about it
17:10:16 <Reisen> I see
17:10:18 <kmc> Reisen, also, Haskell is much easier to parallelize than most languages
17:10:33 <kmc> because evaluation never has a side effect, so you can just tell the compiler "hey, evaluate this and that at the same time"
17:11:04 <Reisen> I'd like to sit down and just read these library implementations, I did try to dive into some of GHC's nasty standard library code but it was like mincing my balls
17:11:11 <kmc> oh yes
17:11:14 <kmc> it gets hairy
17:11:40 <cybercobra> Reisen: the Shootout has it at between 3x and 10x slower than C (http://shootout.alioth.debian.org/u64/benchmark.php?test=all&lang=ghc&lang2=gcc)
17:12:02 <kmc> i wish nobody would speak about comparing languages for speed
17:12:06 <kmc> it's an obvious category error
17:12:13 <kmc> the shootout compares implementations and is very explicit about this
17:12:21 <kmc> it's a shame too because e.g. there is no reasonable C# implementation on there
17:12:22 <fax> I wish people wouldn't buttons to "DOWNLOAD $LANGUAGE"
17:12:30 <Reisen> Well, to a point of course. But there'll still be a general overall speed difference that is noticeable
17:12:35 <Reisen> So I don't see anythign wrong with at least considering speed
17:12:46 <kmc> Reisen, considering speed is important.  Consider speed of implementations
17:12:47 <Reisen> Wait, 'noticeable'
17:12:53 <Gracenotes> mono yay. :|
17:12:58 <kmc> and if one language consistently has slow implementations, that is a mark against the usability of that language
17:13:02 <kmc> but someone might come along and fix that
17:13:07 <kmc> as happened with Javascript and Lua
17:13:10 <kmc> and as I hope will happen with Python one day
17:13:17 <kmc> yeah, the "download haskell" button should go directly to a PDF of the Haskell 98 Report ;)
17:13:21 <Reisen> Don't say that, I just converted to Django D:
17:13:22 <cybercobra> I'd like to see an efficient DWIM implementation :-)
17:15:02 <orlandu63> is python considered slow?
17:15:21 <copumpkin> careful, kmc is in here
17:15:28 <c_wraith> python is awfully slow in tight loops.  You just rarely write tight loops.
17:15:31 <copumpkin> he'll rip your head off for using those words in the same sentence
17:15:37 <kmc> damn right i will
17:15:49 <kmc> orlandu63, CPython, the most popular Python interpreter, is slow and generally terrible
17:15:53 <EvanR> i cant add a type signature to a instance method definition?
17:15:58 <kmc> EvanR, nope
17:16:01 <cybercobra> orlandu63: in an absolute sense, of course. for most practical purposes, if the performance matters to that degree, you're Doing It Wrong
17:16:25 <kmc> orlandu63, Jython and IronPython are not strictly worse or better; they perform differently on different workloads
17:16:31 <kmc> what the world needs is a good tracing JIT for Python
17:16:34 <kmc> i think google is working on it
17:16:42 <orlandu63> i see
17:16:42 <cybercobra> kmc: well, and PyPy
17:16:47 <kmc> yeah
17:16:52 <kmc> PyPy is an interesting project
17:17:10 <kmc> i like their approach
17:17:19 <aavogt> > pi*pi
17:17:20 <lambdabot>   9.869604401089358
17:17:29 <kmc> boostrapping restricted metacircularity to high performance
17:17:33 <kmc> plus that sounds cool
17:17:54 <fax> > sqrt(pi)
17:17:55 <lambdabot>   1.7724538509055159
17:18:09 <EvanR> ehm. so, i guess im not allowed to use library functions from inside the instance definition? :)
17:18:09 <kmc> also worth mentioning is Cython
17:18:09 <Reisen> 'Rumors have it that the secret goal is being faster-than-C which is nonsense, isn't it?'
17:18:12 <Reisen> They've got me hooked now
17:18:16 <kmc> EvanR, what?
17:18:17 <Reisen> Reading more
17:18:31 <EvanR> implementing split for RandomGen, can i use randoms ? :)
17:18:47 <kmc> EvanR, think so
17:18:51 <kmc> i'm not sure what you're asking
17:18:55 <EvanR> thats counterintuitive
17:18:56 <kmc> there's no special scoping rule for instances
17:19:09 <EvanR> pretend randoms used split
17:19:15 <EvanR> i suppose it would be recursive and just work
17:19:19 <kmc> your instance methods can be mutually recursive just like any other functions
17:19:37 <kmc> moreover they can be superficially "recursive" but actually be a call to a different instance, which is a totally different function
17:19:40 <kmc> so e.g. you'll see like
17:19:50 <kmc> liftOI = lift . liftIO
17:19:52 <kmc> err
17:19:54 <kmc> liftIO = lift . liftIO
17:19:57 <EvanR> that is damn nifty
17:20:07 <kmc> but the liftIO being defined and the one called are for different instances
17:20:14 <kmc> or a simpler example
17:20:15 <EvanR> in my case it would not be
17:20:28 <EvanR> theres only one generator type involved
17:20:28 <kmc> instance (Show a) => Show (Maybe a) where { show Nothing = "Nothing"; show (Just x) = "Just " ++ show x }
17:20:32 <kmc> that's not actually recursive
17:20:50 <EvanR> if split were defined with randoms, and randoms were defined with split?
17:21:14 <Reisen> I ran into this with a much simpler function
17:21:23 <Reisen> toIntegral, when digging through some library code
17:21:46 <kmc> EvanR, nothing here is specific to instances
17:21:49 <aavogt> what kind of rounding is toIntegral?
17:22:02 <ido> hey kmc
17:22:03 <EvanR> ok
17:22:04 <kmc> hi ido
17:22:06 <ido> we're all watching you here at tower
17:22:10 <kmc> that's great
17:22:13 <mauke> @src toIntegral
17:22:13 <lambdabot> Source not found. Maybe if you used more than just two fingers...
17:22:13 <ido> jason says hi.
17:22:15 <copumpkin> that's kind of creepy
17:22:16 <kmc> hi jason
17:22:18 <kmc> it is
17:22:21 <Reisen> There were several rewrite rules for toIntegral
17:22:32 <fax> tower??
17:22:36 <fax> what is going on????
17:22:40 <mauke> @hoogle toIntegral
17:22:41 <lambdabot> No results found
17:22:43 <Reisen> Magic is goign on
17:22:45 <ido> i'm heading uptown, see you in a few.
17:22:48 <kmc> okay
17:23:02 <Mathnerd314> @type toIntegral
17:23:03 <lambdabot> Not in scope: `toIntegral'
17:23:06 <yuriks> I'm trying to update cabal-install using itself, but it seems to be having no effect
17:23:23 <yuriks> I currently have 6.2, and the newest version on hackage is 8.2
17:24:19 <yuriks> but even though cabal-install tells me there's a new version and to update, I run it and it downloads 6.4, compiles and seems to install it, but in the end cabal -V still says 6.2
17:24:45 <aavogt> yuriks: which cabal ?
17:24:52 <aavogt> as in run that command
17:25:05 <yuriks> I'm on Windows
17:25:09 <yuriks> I installed the haskell platform
17:25:12 <aavogt> perhaps your cabal 6.2 is in a location higher up in your $PATH
17:25:19 <aavogt> or %PATH%
17:25:43 <yuriks> ah, yeah, probably
17:25:56 <yuriks> cabal is installing it in \Program Files (x86)\Haskell\bin
17:26:30 <yuriks> and there is the haskell platoform installed in \Program files (x86)\Haskell Platform\2009.2.0.2\bin earlier on the path
17:30:47 <yuriks> aavogt: what should I do, remove the cabal from Haskell Platform\?
17:30:54 <cybercobra> snippet of some code I'm working on: http://ideone.com/qUiEn  critiques? am I doing anything Wrong(tm)? I'm a newbie.
17:31:03 <aavogt> I suppose that could work
17:31:14 <aavogt> or rearrange your %PATH%
17:31:59 <gwern> cybercobra: nested wheres are pretty unusual
17:32:09 <aavogt> @type Data.Set.unions
17:32:09 <lambdabot> forall a. (Ord a) => [S.Set a] -> S.Set a
17:32:24 <gl0w_> so i am trying to write a program in Haskell which will read a Java class file in as bytecode and was having some problems...
17:32:27 <gwern> cybercobra: also, couldn't you import Data.Set as S? all the Set.Sets are killing my eyes
17:32:38 <gl0w_> http://pastebin.com/LS1HGSyA , is what i have so far and i was wondering if someone could at least tell me if i was on the right track...
17:33:09 <yuriks> aavogt: hmm, it appears that the *only* thing in the Haskell dir is the cabal I just updated
17:33:26 <EvanR> i 'discovered' something surprising to me about mutually recursive set of definitions. if i have x which depends on a value that comes from an operation that 'simulataneously' dequeues and enqueues something, and the enqueued value depends on x.... it works ;)
17:33:44 <cybercobra> gwern: well, I'm using functions from it too and `S.union` doesn't read as well as `Set.union`
17:33:56 <EvanR> perhaps because the dequeue enqueue operation is lazy
17:34:13 <aavogt> yuriks: that should be the case unless you've installed other applications with cabal install
17:34:29 <yuriks> aavogt: aha, I'll just change the cabal config to install on the platform dir, is that a good idea?
17:35:21 <aavogt> I'm not sure if windows lets you overwrite currently running binaries
17:36:00 <yuriks> path rearrange it is then
17:36:03 <aavogt> I would just reorder the %PATH%
17:36:04 <aavogt> yeah
17:36:22 <Mathnerd314> > let f 0 = 0; f 1 = 1; f n = f (n-1) + f (n-2) in f (-1) -- why? oh, why?
17:36:25 <lambdabot>   *Exception: stack overflow
17:36:25 <aavogt> cybercobra: you can have it both ways
17:36:46 <shu> question about monads: if i have something like do { f; g x } where x = h y, does x get evaluated each time i use the monadic action or just once?
17:36:47 <aavogt> is f a fibonacci?
17:36:47 <fax> > gcd 4 (gcd 10 12)
17:36:48 <lambdabot>   2
17:37:03 <Mathnerd314> aavogt: yeah
17:37:06 <cybercobra> aavogt: how would I do that?
17:37:06 <aavogt> cybercobra: in that you can import the same module multiple times with different names
17:37:25 <cybercobra> aavogt: ok
17:37:29 <aavogt>  import Data.Set as S\n import Data.Set as Set
17:37:35 <aavogt> possibly import qualified
17:37:36 <mauke> s/\\n/;/
17:37:44 <aavogt> sure
17:37:57 <yuriks> ok, now how come there's version 8.2 on hackage, but cabal-install downloads and builds 6.4?
17:38:06 <aavogt> mauke: what have you got against layout?
17:38:09 <Twey> Dependency says so?
17:38:16 <mauke> aavogt: nothing. that wasn't layout.
17:38:33 <aavogt>  \n is layout
17:38:38 <aavogt> for ;
17:38:49 <mauke> no, \n is the beginning of a lambda function
17:38:49 <Saizan> yuriks: preferences, 0.6.4 is still considered the most stable version, but you need the other ones for ghc-6.12+
17:39:03 <Saizan> yuriks: cabal install "cabal-install >= 0.8"
17:39:17 <yuriks> Saizan: any huge problems?
17:39:34 * mauke ponders import Foo␤import Bar
17:39:38 <aavogt> I guess so, but it wouldn't be allowed there
17:40:00 <mauke> aavogt: even if you interpret \n as a literal newline (which is ugly), you still have an extra space in there :-(
17:40:21 <aavogt> they are both indented the same one space :)
17:40:22 <Saizan> yuriks: no
17:40:32 <mauke> ah, I see
17:40:41 <yuriks> *updates* then
17:40:47 <djahandarie> Mathnerd314, since when did any sequence work with numbers < 0 ? :P
17:40:48 <mauke> ; is underused, though
17:40:52 <aavogt> though it's quite rare to indent the contents of a module
17:41:05 <mauke> ; is in the language so we can talk about code on IRC!
17:41:37 <Mathnerd314> djahandarie: since it was defined!
17:42:35 <aavogt> I think it's in the language to make it sufficiently c-like
17:42:45 <cybercobra> if I do `import qualified Data.Set`, will I access the imported stuff as `Set.union` or `Data.Set.union`?
17:42:58 <mauke> Data.Set.union
17:43:32 <kmc> import qualified Data.Set as Set
17:43:46 <kmc> i usually use that or "as S"
17:44:26 <aavogt> unfortunately people also import Data.Sequence  as S
17:44:43 <kmc> those people can BURN IN HELL
17:44:47 <kmc> by which i mean, whatevs
17:44:54 <mauke> import Data.ByteString as S
17:44:57 <inetic_> cybercobra, I think ghc will give you an error
17:45:09 <kmc> from Data import * as S
17:45:29 <mauke> from Data import S* as S
17:46:17 <djahandarie> sssssss hsssssss
17:46:25 <kmc> don't spring a leak
17:46:41 <djahandarie> You were suppose to make a python joke!
17:47:03 <djahandarie> Or was the joke that there was no python joke...
17:47:08 <Twey> It doesn't matter what other people do.  That's the point of qualified imports.
17:47:13 <kmc> sorry
17:47:14 <kmc> 'E's dead, that's what's wrong with it!
17:47:22 <Twey> Haha
17:47:31 * djahandarie wonders off into the darkness
17:47:45 <Twey> Wondering about what, I wander?
17:49:42 <EvanR> and thats that
17:50:23 <yuriks> Configuring old-time-1.0.0.2...
17:50:24 <yuriks> cabal: The package has a './configure' script. This requires a Unix
17:50:25 <yuriks> compatibility toolchain such as MinGW+MSYS or Cygwin.
17:50:33 <yuriks> I have cywing, how do I tell cabal-install to use it?
17:51:27 <EvanR> i made a RandomGen
17:51:34 <EvanR> comments, ridicule
17:51:36 <EvanR> http://pastebin.com/bWi9QiHW
17:52:13 <EvanR> crap the critical formula is wrong :)
17:52:50 <Mathnerd314> yuriks: add it to your %PATH%
17:53:26 * BMeph will henceforth use "import qualified Data.Set as GoToHellKMC"... :D
17:55:14 <yuriks> Mathnerd314: what, cygwin?
17:55:33 <Mathnerd314> the cygwin programs, yes (such as gcc)
17:55:52 <yuriks> Mathnerd314: I'm using the platform gcc
17:58:10 <Mathnerd314> well, add the directory with those programs to your path
17:58:45 * idnar wonders off into the light
18:00:38 <dpratt71>  suppose that in the course of investigating Haskell, you kept stumbling across blog.sigfpe.com and waisting time and hurting your brain trying in vain to understand what the heck is being discussed...is there any resource -- besides a graduate mathematics course -- that could help in obtaining a shred of understanding?
18:01:05 <Mathnerd314> dpratt71: undergraduate math course?
18:01:07 <twink> dpratt71: learnyouahaskell.com
18:01:36 <dpratt71> twink: I think I'm past LYAH at this point
18:01:45 <newsham> dpratt: its called blog.sigfpe.com (the resource you're looking for, that is)
18:01:46 <systemfault> dpratt71: Then get RWH :P
18:01:51 <jmcarthur> dpratt71: osmosis
18:02:02 <dpratt71> Mathnerd314: ah, thanks :)
18:02:05 <jmcarthur> dpratt71: the more you are exposed to this stuff the more you will pick up
18:02:15 <jmcarthur> the mathy stuff, i mean
18:02:28 <yuriks> Mathnerd314: $ PATH=/cygdrive/c/Program\ Files\ \(x86\)/Haskell\ Platform/2009.2.0.2/:$PATH cabal install wx
18:02:44 <dpratt71> RWH is good stuff; most of what I'm referring to refers to Haskell only indirectly, if at all
18:02:47 <yuriks> Mathnerd314: that failed with "the C compiler can't produce executables" during the configure script
18:04:01 <dpratt71> jmcarthur: my information absorption rate tests my patience
18:04:03 <EvanR> http://pastebin.com/LH3mUSjL
18:05:38 <kmc> dpratt71, any particular article causing you trouble?
18:06:08 <EvanR> how do i do, [a] -> ([a], [a]), [0,1,2,3,4,...] -> ([0,2,4,6,...], [1,3,5,7,...])
18:06:26 <dpratt71> kmc: not really, I'm afraid it's pretty much all of them
18:06:26 <aavogt> partition even
18:06:37 <mauke> heh
18:07:00 <EvanR> > partition even [0..]
18:07:01 <lambdabot>   ([0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,...
18:07:14 <dpratt71> I need "sigfpe for dummies"
18:07:24 <mjrosenb> >partition even [0..20]
18:07:29 <mjrosenb> > partition even [0..20]
18:07:30 <lambdabot>   ([0,2,4,6,8,10,12,14,16,18,20],[1,3,5,7,9,11,13,15,17,19])
18:07:30 <c_wraith> > snd . partition even $ [0..]
18:07:31 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
18:07:58 <EvanR> split (Rng ls) = let (a,b) = partition even ls in (Rng a, Rng b)
18:08:08 <aavogt> why would (snd .) . partition?
18:08:28 <mjrosenb> dpratt71: the abridged version is "Run away while you can"
18:08:39 <monochrom> haha sigfpe for dummies
18:08:53 <mauke> preflex: seen dpiponi
18:08:53 <preflex>  dpiponi was last seen on #haskell 36 days, 1 hour, 54 minutes and 9 seconds ago, saying: Talking of IDEs, It's be fun to have an interactive code building environment like the way Coq works. I believe someone is working on something like that.
18:09:47 <dpratt71> mjrosenb: I'm certainly trying, but I keep getting sucked back in; some of the stuff seems just beyond my grasp...deceptively so, I'm guessing
18:10:09 <monochrom> you are addicted
18:10:30 <aavogt> see #haskell-rehab
18:10:37 <dpratt71> :)
18:12:11 <mjrosenb> dpratt71: i'm now going to assume that my previous assumption that sigfpe == the SIGnal for Floating Point Exception is in fact, incorrect
18:12:34 <dpratt71> mjrosenb: I think that's the inspiration
18:12:41 <dpratt71> (for the handle)
18:13:07 <mjrosenb> because whenever there is a floating point exception, you want to be elsewhere
18:13:16 <mjrosenb> now
18:13:18 <EvanR> how standard is the standard rng
18:13:27 <mjrosenb> dpratt71: what on earth were you talking about?
18:13:28 <monochrom> what, you really anticipated for "signalling floating point exceptions for dummies"?
18:13:37 <cybercobra> does GHC work on x86-64?
18:13:42 <mjrosenb> cybercobra: yes.
18:13:48 <dpratt71> mjrosenb: at your own risk: http://blog.sigfpe.com
18:14:26 <mauke> sigfpe is what happens when you divide by integer zero
18:14:34 <mjrosenb> monochrom: i mean if that is shorthand for "the section of the IEEE floating point spec on raising exceptions", then a for dummies manual would be quite helpful
18:14:54 <mjrosenb> mauke: that is *one* way of getting it
18:14:59 <dpratt71> a formal education is pretty much out of the question at this point; I'm thinking to hunt down some topical...uh...course material; no idea where to start, though
18:15:14 <cybercobra> mjrosenb: is there any way to interrogate GHC as to what arch it was compiled for?
18:15:14 <mauke> the other is dividing minBound by -1
18:15:45 <mjrosenb> mauke: presumably you also get those exceptions when doing actual floating point operations
18:15:52 <Draconx|Laptop> mjrosenb, not usually.
18:15:59 <fax> dpratt on what
18:16:17 <mjrosenb> Draconx|Laptop: when you have signaling floating points...
18:16:24 <aavogt> > System.Info.os
18:16:25 <lambdabot>   Not in scope: `System.Info.os'
18:16:29 <Draconx|Laptop> mjrosenb, right.  Which you don't normally get by default.
18:16:31 <aavogt> > System.Info.arch
18:16:32 <lambdabot>   Not in scope: `System.Info.arch'
18:16:42 <dpratt71> fax: that's the problem; not exactly sure what category sigfpe falls into; he's right on that line between math and cs
18:16:43 <mjrosenb> cybercobra: file `which ghc`
18:17:06 <mjrosenb> cybercobra: there is likely a nicer way, but that will work
18:17:07 <mauke> shell script text
18:17:17 <mjrosenb> as long as it doesn't say shell screfb
18:17:24 <dpratt71> well, I shouldn't say that's *the* problem...it's merely *a* problem
18:18:24 <kmc> heh, on my system `which ghc` is three layers of symlinks ending in a sh script
18:18:31 <cybercobra> mjrosenb: not really, but based on the errors I'm getting, I'll forgo complete confirmation
18:18:35 <EvanR> i seem to have a memory leak...
18:18:49 <mjrosenb> cybercobra: what errors are you getting
18:19:12 <cybercobra> mjrosenb: "32-bit absolute addressing is not supported for x86-64"
18:19:22 <cybercobra> mjrosenb: "cannot do signed 4 byte relocation"
18:20:04 <mjrosenb> cybercobra: how did you install it / what distro are you using?
18:20:27 <EvanR> its only a leak in ghci
18:20:37 <pastorn> hmm...
18:20:39 <EvanR> so if i have infinite printing out text in ghci, memory grows without bound?
18:20:41 <pastorn> how do i get rid of
18:20:44 <pastorn>     Couldn't match expected type `Data.ByteString.Lazy.Internal.ByteString'
18:20:46 <pastorn>            against inferred type `BS.ByteString'
18:20:46 <cybercobra> mjrosenb: Mac OS X; fink
18:21:05 <mauke> pastorn: what is BS?
18:21:09 * hackagebot rpc 0.0.0 - type safe rpcs provided as basic IO actions  http://hackage.haskell.org/package/rpc-0.0.0 (SamAnklesaria)
18:21:13 <pastorn> mauke: qualified import
18:21:19 <pastorn> import qualified Data.ByteString as BS
18:21:24 <mauke> there you go
18:21:49 <pastorn> mauke: huh? that's what i have and i have that error :(
18:21:56 <mjrosenb> cybercobra: ugh; only ossix system i have lying around is from when apple still used real computers
18:22:10 <pastorn> maybe fooling with import Prelude hiding (readFile) might work...
18:22:22 <mauke> pastorn: yes, because you're trying to use a strict bytestring where it expects a lazy one
18:22:32 <cybercobra> mjrosenb: "real" meaning...?
18:23:03 <mjrosenb> cybercobra: ppc64
18:23:21 <monochrom> virtual computers
18:23:22 <pastorn> mauke: i'll show you a paste in 3 seconds...
18:23:23 <cybercobra> mjrosenb: right...
18:24:35 <mjrosenb> pastorn: 3 seconds were up a while ago
18:25:13 <mjrosenb> cybercobra: anyhow, is that from ghc or ghci?
18:25:24 <monochrom> because threadDelay doc says "could be more than 3 seconds"
18:25:53 <pastorn> http://tamu.pastebin.com/cVTWYiLf
18:25:53 <mjrosenb> pastorn: get a better scheduler :-p
18:25:55 <yuriks> is there any GUI binding that works on windows? =/
18:26:05 <pastorn> mjrosenb: just cleaned stuff up
18:26:17 <mjrosenb> yuriks: there is a native windows foobar
18:26:24 <aavogt> most of them do
18:26:43 <mauke> pastorn: :t runGet
18:27:08 <yuriks> so far I've tried wxhaskell and the binary on the site fails with a dll error (and isn't the last version) and the newest version is nigh un-installable with cabal
18:27:16 <pastorn> mauke: runGet :: Get a -> Data.ByteString.Lazy.Internal.ByteString -> a
18:27:19 <mauke> pastorn: exactly
18:27:30 <mauke> pastorn: what are you giving it?
18:27:34 <yuriks> gtk2hs has a setup that fails to detect that ghc is working (but installs) and then afterwards ghc can't find it's modules anyway
18:27:38 <pastorn> mauke: no clue
18:27:56 <pastorn> Data.ByteString.ByteString ?
18:27:58 <mauke> pastorn: a strict ByteString
18:28:04 <cybercobra> mjrosenb: ghc. ghci works just dandily
18:28:05 <mauke> yes
18:28:15 <pastorn> Defined in Data.ByteString.Internal
18:28:19 <mjrosenb> cybercobra: that is ... odd
18:28:24 <mauke> pastorn: ignore the Internal parts
18:28:29 <aavogt> yuriks: well I don't know about the most recent versions, but I didn't have trouble to install and run gtk2hs on windows a year oago
18:28:40 <pastorn> mauke: ok...
18:28:54 <pastorn> so the default ByteString is strict?
18:29:17 <cybercobra> mjrosenb: and I seem to have found the problem (perhaps). Seems Snow Leopard broke GHC and the GHC version in fink is from before the fix. most vexing.
18:29:26 <mauke>  Byte vectors are encoded as strict Word8  arrays of bytes, held in a ForeignPtr, and can be passed between C and Haskell with little effort.
18:29:27 <Saizan_> yuriks: you've to make sure you've the ghc version the gtk2hs installer is expecting
18:29:53 <pastorn> mauke: cool... maybe i can get this working now...
18:31:32 <yuriks> Saizan_: well, but I probably don't, that package is old.
18:33:29 <yuriks> Saizan_: there's this unofficial installer, which works... if you have the platform installed on a path without spaces >_<
18:33:42 <yuriks> god damn doesn't anyone know how to package stuff anymore these days?</rant>
18:35:26 <mjrosenb> yuriks: it is called cabal.  the gtk2hs people say they have issues using cabal though
18:35:37 <gl0w_> if i was attempting to decode a read in file to binary, would contents <- return . D.decode =<< S.readFile "Test.class" be appropriate for that?
18:35:49 <yuriks> mjrosenb: only cabal doesn't work on windows either because lolconfigure scripts
18:35:51 <gl0w_> assuming Data.Binary is D and ByteString is S
18:36:20 <dpratt71> ha! I just read the headline "Kids Learn Math Easily When They Control Their Own Learning"; too bad I'm an adult
18:36:23 <pastorn> mauke: it works! thanks :)
18:36:56 <mjrosenb> yuriks: that's kinda suprising
18:37:14 <yuriks> well, it works for some libraries
18:37:19 <yuriks> it didn't for wxHaskell
18:37:39 <EvanR> how do i write a Word32 to stdout
18:37:59 <pastorn> EvanR: you want to write the actual hex?
18:38:04 <EvanR> binary i/o
18:38:18 <EvanR> four bytes
18:38:43 <tensorpudding> probably could pack it as a bytestring and use the bytestring IO functions
18:39:06 <EvanR> what if i have an infinite list of Word32, and i want to write them all
18:39:14 <pastorn> EvanR: http://hackage.haskell.org/packages/archive/bytestring/0.9.1.4/doc/html/Data-ByteString.html#v%3AhPutStr
18:39:21 <EvanR> Data.ByteString
18:39:36 <tensorpudding> Though you'll have to bit-twiddle the Word32's into [Word8]
18:40:20 <EvanR> hrm
18:40:44 <EvanR> packWith
18:40:45 <pastorn> EvanR: check out the package binary
18:40:50 <pastorn> it's awesome
18:40:56 <EvanR> hrm
18:41:56 <tensorpudding> @hoogle Word32 -> [Word8]
18:41:56 <lambdabot> Data.Data gmapQ :: Data a => (d -> u) -> a -> [u]
18:41:57 <lambdabot> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
18:41:57 <lambdabot> Data.List genericReplicate :: Integral i => i -> a -> [a]
18:42:22 <EvanR> @hoodle [Word32] -> [Word8]
18:42:23 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
18:42:23 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
18:42:23 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
18:42:38 <EvanR> @hoodle [[Word32]] -> [Word8]
18:42:38 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
18:42:38 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
18:42:38 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
18:42:41 <tensorpudding> Damn, we've got Data.List and Data.Data.gmapQ? That's like the least relevant hoogle ever
18:42:58 <tensorpudding> You can use Data.Bytestring.concat
18:43:27 <EvanR> what about pack
18:43:30 <tensorpudding> [ByteString] -> ByteString
18:44:16 <pastorn> EvanR: look at 'binary' on hoogle
18:44:19 <pastorn> awesome library
18:44:23 <pastorn> it's what you want
18:44:26 <EvanR> [Word32] => [Word8] => pack => putStr
18:44:37 <EvanR> its all lazy righ
18:44:47 <pastorn> yes, 'binary' is lazy
18:44:55 <pastorn> *hackage*
18:44:58 <pastorn> not hoogle
18:45:00 <pastorn> sorry
18:45:01 <EvanR> i saw binary, is that the one with Put
18:45:09 <pastorn> yes
18:45:13 <pastorn> that's what you want
18:45:23 <tensorpudding> You can't unsafe-cast a Word32 to a [Word8] can you?
18:45:35 <pastorn> tensorpudding: you can
18:45:39 <EvanR> [Word8] is a list
18:45:39 <pastorn> with Forein
18:46:06 <pastorn> tensorpudding: first you do 'newArray [myW32]'
18:46:07 <tensorpudding> I mean without Foreign
18:46:27 <pastorn> you might need unsafeCoerce...
18:46:44 <kmc> unsafeCoerce :: Word32 -> [Word8] is nearly guaranteed to be a segfault
18:46:49 <kmc> or something much worse
18:47:27 <pastorn> kmc: no, i was talking about unsafeCoerce :: Ptr Word32 -> Ptr Word8
18:47:35 <pastorn> which shoud work
18:47:37 <kmc> why not just use castPtr?
18:47:44 <kmc> unsafeCoerce is less safe
18:47:45 <pastorn> oh, there's that? didn't know :)
18:47:50 <kmc> yeah
18:47:57 <pastorn> cool :D
18:47:58 <kmc> the Foreign modules have all the foot-shooting goodness of C
18:48:08 <kmc> just read Foreign.Ptr
18:48:32 <pastorn> kmc: awsumz :)
18:52:33 <EvanR> forM_ src (BS.putStr . BS.pack . concatMap . f)
18:52:50 <EvanR> f word32 = [0,0,0,0] :: [Word8] ;)
18:54:35 <gwern> preflex: seen chrisdone
18:54:35 <preflex>  chrisdone was last seen on #haskell 2 hours, 48 minutes and 10 seconds ago, saying: you fumbled over folds? naughty
18:54:36 <Meow``> Sorry preflex but there marked as brb at this time, they will say back when they return.
18:54:37 <EvanR> not exactly
18:55:29 <gwern> huh. dcoutts pronounces 'Galois' as Gal-way
18:55:40 * gwern always thought it was Gal-loy
18:55:54 <fax> gaywah
18:55:54 <gwern> chrisdone: how goes the mueval merge?
18:55:58 <fax> galwah*
18:56:05 <gwern> fax: I was about to say :)
18:56:14 <ddarius> gwern: Welcome to French.
18:56:36 * gwern notes that I frequently came close to flunking french
18:57:52 * Axman6 is pretty sure fax  has it right, gal-wah
18:58:09 <fax> I try to learn french
18:58:11 <Axman6> but,m more french sounding than spelling it like that would make you say it
18:58:15 <fax> it is very hard, much harder than haskell
18:58:26 <tensorpudding> It's close to gal-way
18:58:30 <tensorpudding> err, gal-wah
18:58:44 <gwern> fax: compared to japanese french is trivial
18:59:07 <ddarius> As far as pronunciation goes, I fervently disagree.
18:59:09 <gwern> heck, you can read a fair bit if you have a really good english vocab and know the basic syntax and verbs
19:00:36 <gwern> Amgen? who the hell is amgen and why are they in the IHG?
19:00:46 <gwern> I mean, galois of course. but amgen?
19:01:26 <gwern> 'Amgen Inc. (NASDAQ: AMGN, SEHK: 4332) is an international biotechnology  company  headquartered in Thousand Oaks, California. Located in the Conejo Valley, Amgen is the largest independent biotech firm. The company employs approximately 14,000 staff members including the 125 Allied-Barton Security staff and A-post personnel in 2007.'
19:02:04 <gwern> hm. http://www.haskell.org/haskellwiki/Haskell_in_industry#Haskell_in_Industry
19:02:22 * hackagebot mongoDB 0.4.2 - A driver for MongoDB  http://hackage.haskell.org/package/mongoDB-0.4.2 (ScottParish)
19:02:29 <gwern> amgen uses haskell to 'To break developers out of their software development rut by giving them a new way to think about software.'
19:02:59 <gwern> feels like daming with faint praise. 'Oh, you're good for recreation, but we don't use you for shipping software'
19:03:34 <kmc> that's the third of three bullet points
19:03:46 <kmc> the other two making it clear that they actually use it for stuff
19:03:54 <kmc> probably not "shipping software" as they're a biotech company
19:03:57 <nus> rut:: "broadly: sexual excitement in a mammal especially when periodic"
19:04:04 <nus> hah
19:04:07 <kmc> yes
19:04:13 <kmc> as in "rutting like crazed weasels"
19:04:17 <gwern> heh. 'ca-baal' - the dark god of build systems! Ca-Baal demands young libraries be sacrificed to it
19:04:37 <gwern> (accents are endless fodder)
19:05:43 <cybercobra> nus: hm, and yet we use it to mean that one is depressed or stuck...
19:06:39 <gwern> cybercobra: clashing etymologies apparently. one is from latin, 'to roar', and another is from french 'route'
19:07:48 <EvanR> gah
19:07:56 <monochrom> to break out of their rut by giving them rut
19:07:57 <EvanR> i cant get these types to match up :(
19:08:14 <gwern> EvanR: think harder!
19:08:33 <pastorn> EvanR: unsafeCoerce!
19:08:34 <monochrom> You have a thought error.
19:08:36 <nus> "break out of the rut" :-P (-;
19:08:40 <pastorn> always works for me :D
19:09:06 <ddarius> pastorn: This is why C programmers are the happiest programmers.
19:09:12 <pastorn> haha
19:09:19 <cybercobra> pastorn: lol
19:09:21 <monochrom> No, machine code programmers are happier.
19:09:34 <aavogt> lolcode?
19:09:40 <nus> "Do you feel aroused when you think of types"?
19:09:46 <pastorn> assembler - it will get you women
19:09:56 <EvanR> mapM_ (a . b . c . concatMap f) ls
19:10:19 <EvanR> it doesnt like concatMap + f + ls :(
19:10:20 <cybercobra> pastorn: programming a gynoid doesn't count as getting women
19:11:04 <gwern> mm. I wish dcoutts had had more numbers. this IHG presentation felt kind of fluffy
19:11:43 <aavogt> numbers are fluffy too
19:11:46 <EvanR> http://pastebin.com/v0BevtG7
19:11:48 <gwern> 2 and 4 million aspirational haskell programmers? he's nuts
19:11:56 <gwern> there's no way there's that many surely
19:12:33 <gwern> (several hundred thousand members? we couldn't get >100k people if it were free, much less if there were a few)
19:12:53 <gwern> if we really had that many aspirational haskellers, haskell.org would see a hell of a lot more edits
19:13:14 <aavogt> EvanR: just drop the concatMap alltogether
19:13:36 <EvanR> how will that work
19:13:45 <gwern> does even GNU have >100k members?
19:13:53 <nus> wishful thinking?
19:14:25 <EvanR> that will make many bytestrings rather than one
19:14:26 <monochrom> type errors reflect semantic errors and wishful thinking
19:14:39 <EvanR> i get it
19:14:46 <gwern> GNU has at least 9k members
19:14:57 <EvanR> i need to concat map before using mapM
19:16:26 <aavogt> then why do you want mapM at all?
19:16:29 <EvanR> ok
19:16:42 <fax> Where do functions come from?
19:16:45 <EvanR> riht
19:16:48 <EvanR> right
19:16:50 <aavogt> if you're looking to BS.putStr once
19:17:00 <LegendaryPenguin> whats wrong with this? http://pastebin.com/dWbDivsB
19:17:04 <aavogt> fax: other functions
19:17:06 <cybercobra> fax: math
19:17:11 <monochrom> functions come from a man and a woman holding hands
19:17:15 <EvanR> (BS.PutStr . BS.pack . concatMap f) src
19:17:17 <fax>  where do other functions come from ?
19:17:31 <cybercobra> fax: it's functions all the way down
19:17:51 <aavogt> @type array
19:17:52 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
19:17:58 <fax> I think im going to throw up
19:18:13 <cybercobra> fax: that's nice
19:18:44 <chrissbx> http://hpaste.org is down
19:19:15 <monochrom> type EntityBoard = Array (Int, Int) [((Int, Int),Entity)]
19:19:16 <EvanR> wow
19:19:18 <aavogt> LegendaryPenguin: because your type signature is wrong
19:19:20 <EvanR> compiles
19:20:02 <LegendaryPenguin> the size part?
19:20:15 <aavogt> type EntityBoard = Array (Int,Int) Entity
19:20:47 <monochrom> Oh oops
19:21:13 <EvanR> crap
19:21:16 <EvanR> the code
19:21:19 <EvanR> taking gigs of memory
19:21:22 <EvanR> frozen
19:21:35 <LegendaryPenguin> wouldnt that be a 1 dimensional array then
19:22:01 <monochrom> No. You read the meaning of "Array i e" wrong.
19:22:04 <EvanR> looks like i cant put an infinite bytestring
19:22:34 <monochrom> type errors reflect semantic errors and wishful thinking
19:22:47 <chrissbx> What's wrong with the syntax on line 9 in this snippet?: http://pastebin.com/6sW9XGGD
19:22:49 <EvanR> talking to me?
19:22:55 <chrissbx> (ignore the highlighting)
19:22:56 <monochrom> No.
19:24:04 <Axman6> chrissbx: needs to be indented one more space
19:24:19 <Axman6> or the line above needs to be unindented one space
19:24:45 <chrissbx> Axman6: nope; actually the indentation is one thing more that pastebin broke for me argh
19:25:08 <Axman6> are you using tabs?
19:25:14 <chrissbx> Axman6: see in the input box, there the indentation is as I pasted it
19:25:20 <Axman6> also, your indetation and layout is very strange
19:25:30 <aavogt> you aren't allowed to put a where there
19:25:46 <chrissbx> aavogt: hu, seems like, but I wonder why??
19:25:55 <Axman6> because you can't
19:25:55 <monochrom> I always put a where there.
19:25:57 <aavogt> where follows a derclaration, not arbitrary expressions
19:26:12 <chrissbx> hm well so then.
19:26:19 <monochrom> Oh I see, the second where.
19:26:21 <aavogt> > 1 + 1 where x + y = x / y
19:26:22 <lambdabot>   <no location info>: parse error on input `where'
19:26:23 <Axman6> the elements of the where clause must be indented at least as much as the where keyword i think
19:27:03 <aavogt> well at least as much as the next non-whitspace character
19:27:04 <monochrom> No, the elements do not have to be so indented.
19:27:17 <aavogt> and newlines are whitespace
19:27:38 <monochrom> x = y where\n  y = 0  works
19:28:01 <aavogt> well line 9 is not a context where "where" is allowed
19:28:12 <chrissbx> ok changed it into a let .. in. Wonder if that's what you'd do?
19:28:35 <aavogt> or put the where after the else
19:28:39 <Axman6> chrissbx: http://pastebin.com/YLjG17J0 is how i would write it
19:28:56 <EvanR> the speed of my program outting these Word32 is pretty slow ;)
19:29:03 <Axman6> minus the crappy indentation shown there
19:30:09 <monochrom> the colouring is borked anyway.
19:30:27 <Axman6> aye
19:31:30 <monochrom> pastebin colouring is an abomination
19:31:40 <EvanR> hpaste would be nice
19:32:28 <monochrom> colouring : pastebins :: UI : microsoft
19:32:59 <gwern> hm. I'm amused to hear this one commenter say I don't exist as a independent developer
19:33:37 <p_l> gwern: ?
19:33:58 <gwern> p_l: he's tell dcoutts not to worry about stepping on my/our toes because we don't really exist
19:34:09 <Axman6> o.O
19:34:11 <gwern> since haskell code is written by pro devs
19:34:11 <Axman6> wut?
19:34:16 <Axman6> heh
19:34:27 <monochrom> you don't satisfy ax+by+cz=0 ==> a=b=c=0
19:34:51 <kmc> pastebin.com sucks ass
19:35:02 <kmc> use codepad.org or pastebin.ca
19:35:12 <p_l> gwern: ... linky, sounds amusing :D
19:35:33 <EvanR> @hoogle Int -> [a] -> [[a]]
19:35:33 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
19:35:33 <lambdabot> Prelude drop :: Int -> [a] -> [a]
19:35:33 <lambdabot> Prelude take :: Int -> [a] -> [a]
19:35:41 <aavogt> gwern is not pro yet?
19:35:56 <gwern> I'm a pro IRCer
19:36:16 <monochrom> the commenter is a pro opiner.
19:36:40 <ddarius> Independent /= not professional
19:36:55 <EvanR> :t chunk
19:36:56 <lambdabot> Not in scope: `chunk'
19:36:57 <gwern> ddarius: pros are beholden to their owner
19:37:00 <gwern> I mean, employer
19:37:22 <aavogt> professional freelancers
19:37:28 <EvanR> ? 3 [1,2,3,4,5,6,7,8] => [[1,2,3],[4,5,6],[7,8]]
19:37:45 <Mathnerd314> hmm... if I want to read all of blog.sigfpe.com's posts, from oldest to newest, what's the easiest way?
19:37:54 <monochrom> this is why comments should be banned or ignored
19:38:06 <Axman6> gwern: got a link?
19:38:18 <monochrom> read from newest to oldest. then reverse.
19:38:25 <gwern> Mathnerd314: didn't he have a recent compendium post of links?
19:38:28 <gwern> by topic
19:38:40 <aavogt> > unfoldr (\x -> do guard (not (null x)); return . splitAt 3 $ x) [1..8]
19:38:41 <lambdabot>   [[1,2,3],[4,5,6],[7,8]]
19:38:44 <gwern> Axman6: all I remember was I downloaded it from some annoying video site starting with v
19:38:44 <EvanR> Data.List.splitEvery
19:39:04 <Mathnerd314> monochrom: how so?
19:39:18 <mail> alright passed this module CAN i be bothered to make this RPN calculator in haskell?
19:39:21 <Axman6> vimeo?
19:39:29 <ddarius> gwern: Independent pros are beholden unto themselves.
19:39:29 <gwern> probably
19:39:41 <gwern> ddarius: he who pays the piper names the tune
19:40:27 <ddarius> mail: You can write an RPN calculator in two lines of code.
19:40:29 <monochrom> RPN is trivial. Don't bother.
19:40:48 <monochrom> Write a checker for sequent calculus proofs.
19:40:51 <mail> flodl and stack right?
19:41:01 <gwern> I once saw it as 'he who fees the piper calls the reel'. kind of odd, I thought
19:41:42 <mail> but my professor has to be awkward and say you must define and Expression "Type"
19:42:09 <monochrom> why the quotation marks? we know types.
19:42:40 <monochrom> perhaps your professor has to be awkward and insist on "Haskell" too
19:43:01 <EvanR> haskell is a "functional" language
19:43:20 <EvanR> quoty fingers lol
19:43:21 <aavogt> "you" "are" "doing" "it" "wrong"
19:43:24 <gwern> ('wait, this is System F! I know this!')
19:44:08 <monochrom> from RPN to Expression is trivial too. why the whine.
19:48:53 <EvanR> i think my generate is pretty fast, and i/o is pretty fast, its just the conversion from [Int] to ByteString is slow
19:49:07 <EvanR> i tried converting groups of 1024 Ints at a time
19:49:24 <aavogt> how do you think that?
19:49:41 <EvanR> because my algorithm sucks
19:50:26 <EvanR> something is slow, the dieharder test is taking 1% and the generator is taking 99%, when i wrote the generator in C it was the other way around
19:50:28 <Axman6> try using Binary or Cereal
19:50:50 <EvanR> ok
19:50:59 <Axman6> though, if you do that, you'll have to check how they encode Ints
19:51:20 <EvanR> i just need a stream of random binary bits
19:51:26 <EvanR> so endianness isnt a problem
19:56:20 <EvanR> cool
19:56:31 <EvanR> arch/cabal wont let me install Binary
19:56:44 <EvanR> Array package fails to build
19:56:51 <cybercobra> since when do they make non-binary bits?
19:56:54 <Axman6> then Binary is probably what you want (if you want lazy bytestrings, or cereal if you want strict)
19:56:58 <EvanR> Could not find module `GHC.IO.Exception':
19:57:07 <EvanR> yes i wrote the Binary version, its way easier
19:57:19 <EvanR> now i just need to install it :(
19:58:24 <monochrom> screwdriver bits are non-binary. since the dawn of man.
19:59:27 <EvanR> binary bits as opposed to this print $ repeat "01"
19:59:45 <monochrom> yeah "01" is a decimal string
20:00:32 <aavogt> you can open handles in binary mode
20:00:43 <aavogt> @type chr
20:00:44 <lambdabot> Int -> Char
20:00:57 <EvanR> :o
20:01:07 <monochrom> > chr 9413
20:01:08 <lambdabot>   '\9413'
20:01:18 <monochrom> > text [chr 9413]
20:01:18 <lambdabot>   Ⓟ
20:01:20 <EvanR> map chr src
20:01:52 <aavogt> and if you have ghc-6.12, make sure that you're not using unicode IO
20:01:55 <monochrom> > chr (2^30)
20:01:56 <lambdabot>   *Exception: Prelude.chr: bad argument
20:02:24 <monochrom> > char '4'
20:02:25 <lambdabot>   4
20:02:34 <EvanR> encoding Ints are Chars sounds intensive
20:02:53 <EvanR> as
20:03:31 <EvanR> how many bytes get written in binary mode when you write a char :S
20:04:00 <Axman6> 2 i think
20:04:04 <aavogt> depends how many bytes it takes to represent the Char?
20:04:30 <EvanR> in utf8?
20:04:34 <ivazquez|laptop> Between 1 and 4.
20:04:43 <ivazquez|laptop> Inclusive.
20:04:54 <EvanR> sounds like a wonky way to do binary io
20:05:51 <EvanR> this is intolerable
20:06:08 <EvanR> the arch cabal package is broken, it goes into an infinite loop if you try to install it
20:06:19 <EvanR> so you cant install it, to install other cabal stuff
20:06:29 <kmc> EvanR, do you have ghc?
20:06:34 <EvanR> yes
20:06:39 <kmc> by "cabal" do you mean the Cabal library or the cabal-install binary?
20:06:44 <kmc> i think the Cabal library comes with GHC still
20:06:47 <EvanR> cabal-install
20:07:00 <EvanR> so i cant just cabal install binary
20:07:26 <kmc> so i'd grab the tarball from http://hackage.haskell.org/package/cabal-install
20:07:40 <kmc> and install it the old-fashioned way
20:07:44 <kmc> and then cabal-install everything else
20:07:56 <kmc> i thought arch had good haskell support...
20:08:01 <EvanR> bootstrapping
20:08:22 <EvanR> its been like this for about a month, thats when we starting usinghaskell on arch
20:08:47 <EvanR> bootstrapping failed
20:08:59 <EvanR> libgpm.so.3 not found
20:09:59 <EvanR> guess ill symlink it to libgmp.so.10
20:11:02 <dfkjjkfd> Evanr: are you talking about cabal-install or cabal2arch? Because cabal-install works for me (installed today), but cabal2arch gives me the same libgmp error
20:11:16 <EvanR> cabal-install
20:11:22 <EvanR> it failed when configuring parsec
20:11:27 <EvanR> during bootstrap
20:11:42 <EvanR> the AUR package has itself as a dependency
20:11:50 <EvanR> so installation never terminates
20:17:10 <JordiGH> How do I get a list of powers of 2 mod 11?
20:17:11 <EvanR> could not find module `Binary': it is a member of the hidden package ghc-6.12.1
20:17:20 * JordiGH is hoping this is a one-liner.
20:17:40 <dfkjjkfd> sorry, i am unable to reproduce your situation
20:17:55 <EvanR> :(
20:18:16 <Axman6> map ((`mod` 11) . (2)) [1..]
20:18:25 <Axman6> > map ((`mod` 11) . (2)) [1..]
20:18:26 <lambdabot>   Ambiguous type variable `a' in the constraints:
20:18:27 <lambdabot>    `GHC.Num.Num a' arising ...
20:18:36 <Axman6> > map ((`mod` 11) . (^2)) [1..]
20:18:37 <lambdabot>   [1,4,9,5,3,3,5,9,4,1,0,1,4,9,5,3,3,5,9,4,1,0,1,4,9,5,3,3,5,9,4,1,0,1,4,9,5,...
20:18:51 <JordiGH> Axman6: Well, you know the length of the list in advance. It's phi(11) = 10.
20:18:53 <pastorn> what's this? some bytestring lulz? Trying to cast a non-string: MethodRef 22 247
20:18:59 <byorgey> > map (`mod` 11) . iterate (*2) $ 1
20:19:00 <lambdabot>   [1,2,4,8,5,10,9,7,3,6,1,2,4,8,5,10,9,7,3,6,1,2,4,8,5,10,9,7,3,6,1,2,4,8,5,1...
20:19:12 <JordiGH> > map ((`mod` 11) . (^2)) [1..10]
20:19:13 <Axman6> JordiGH: huh?
20:19:14 <lambdabot>   [1,4,9,5,3,3,5,9,4,1]
20:19:24 <JordiGH> Axman6: Euler phi of 11 is 10.
20:19:27 <byorgey> (^2) is squaring.
20:19:38 <Axman6> > map ((`mod` 11) . (2^)) [1..]
20:19:39 <lambdabot>   [2,4,8,5,10,9,7,3,6,1,2,4,8,5,10,9,7,3,6,1,2,4,8,5,10,9,7,3,6,1,2,4,8,5,10,...
20:19:53 <JordiGH> > map ((`mod` 11) . (2^)) [1..10]
20:19:54 <lambdabot>   [2,4,8,5,10,9,7,3,6,1]
20:19:59 <JordiGH> shweet
20:19:59 <Axman6> byorgey: i'm working with an extremely laggy connection, give me a break :P
20:20:00 <EvanR> the powers of two mod 11, there are at most 11 of them
20:20:46 <EvanR> > nub $ map (\x -> mod (2^x) 11) [0..10]
20:20:47 <lambdabot>   [1,2,4,8,5,10,9,7,3,6]
20:20:47 <byorgey> Axman6: no worries. I was just saying. =)
20:21:26 <Axman6> ssh + high lag + high packet loss = extremely painful error correction in irssi
20:21:27 <JordiGH> Oh, I guess 1 is also it.
20:21:36 <fax> JordiGH <3 <3 <3
20:22:00 <JordiGH> fax: Haha, working on the eleventh roots, since that will involve a soluble quintic. :-)
20:22:11 <z1y> > fromFloat
20:22:12 <lambdabot>   Not in scope: `fromFloat'
20:22:14 <fax> JordiGH -- I got further with my 13th roots but still not done yet
20:22:17 <z1y> > toint
20:22:18 <lambdabot>   Not in scope: `toint'
20:22:30 <JordiGH> fax: But that's also cubics and quadratics! Boring. :P
20:22:42 <fax> once I do 13 I'm going to try a p-1 whose factorization has a 5 in it
20:22:51 <JordiGH> fax: 11
20:22:56 <fax> I'm at the cubic bit and totally confused
20:22:59 <fax> hmm
20:23:01 <z1y> hi, how to convert a string to interger/float?
20:23:10 <EvanR> read
20:23:16 <EvanR> > read "123" :: Int
20:23:17 <lambdabot>   123
20:23:18 <fax> As I understand it,  vandermoundes method for n=11 is a little bit different gauss
20:23:30 <aavogt> @hoogle String -> Integer
20:23:32 <lambdabot> Prelude read :: Read a => String -> a
20:23:32 <lambdabot> Text.Read read :: Read a => String -> a
20:23:32 <lambdabot> Prelude error :: [Char] -> a
20:23:35 <fax> because he uses quadratic reciprocity - and gauss uses subgroups
20:23:40 <fax> idk
20:23:44 <fax> maybe there's no real difference
20:23:47 <fax> I can't really tell yet
20:23:48 <z1y> EvanR: thank you.
20:23:55 <JordiGH> fax: Yeah, I just want *a* method that works in general, not a particularly efficient method.
20:24:01 <fax> me too :)))
20:24:17 <JordiGH> fax: Rule 1: (1) make it work (2) profile (3) make it faster. Still on step 1.
20:24:21 <fax> haha
20:24:54 <byorgey> what are you all working on?
20:24:55 <JordiGH> Okay, so, I guess I should learn Haskell syntax...
20:25:13 <Axman6> you should learn haskell. there's a lot more than syntax
20:25:17 <JordiGH> byorgey: Trying to express primitive roots of unity in radicals. We know it can be done, but we are trying to work out an algorithm to do so.
20:25:38 <byorgey> ah, cool
20:25:41 <JordiGH> Axman6: I think I understand the general idea of functional programming, the rest are implementation details. :P
20:26:10 <JordiGH> So `mod` is infix?
20:26:15 <JordiGH> > 5 mod 3
20:26:16 <lambdabot>   Ambiguous type variable `a' in the constraint:
20:26:16 <lambdabot>    `GHC.Real.Integral a'
20:26:16 <lambdabot>    ...
20:26:18 <fax> yes
20:26:21 <byorgey> `backticks` make anything infix
20:26:24 <Axman6> `mod` is infix, mod is prefix
20:26:25 <byorgey> any name
20:26:32 <JordiGH> > 5 `mod` 3
20:26:33 <lambdabot>   2
20:26:34 <JordiGH> Aha.
20:26:38 <Axman6> > mod 5 3
20:26:38 <lambdabot>   2
20:26:43 <JordiGH> I need a repl
20:26:51 <fax> you can /query lambdabot
20:26:54 <fax> if you don't have ghci installed
20:26:56 <byorgey> @where tryhaskell
20:26:56 <lambdabot> I know nothing about tryhaskell.
20:26:57 <tensorpudding> ghci is a REPL
20:27:07 <mxc> if anyone is curious, I finally got curl running well in windows 7.. takes a pretty powerful machien though
20:27:11 <JordiGH> I'll install ghci.
20:27:19 <tensorpudding> Well, not a fully-featured one
20:27:23 <fax> the bit I'm stuck on is... I've to solve something like  k = z + z^3 + z^9
20:27:29 <byorgey> @where+ tryhaskell http://tryhaskell.org/
20:27:30 <lambdabot> I will never forget.
20:27:31 <fax> and I have no clue how to reduce that to a cubic
20:27:45 <Axman6> JordiGH: you'll install ghc, and get ghci with it
20:27:48 <EvanR> dammit
20:28:15 <EvanR> cabal install keeps installing stuff in ~/.cabal/lib/packagename/ghc-6...
20:28:20 <EvanR> so my main ghc cant find it
20:28:38 <tensorpudding> cabal should be registering packages with ghc
20:28:49 <EvanR> it says it is
20:28:53 <tensorpudding> do you have more than one ghc?
20:28:58 <EvanR> i hope not
20:29:02 <tensorpudding> Do they show up in ghc-pkg list?
20:29:19 <JordiGH> Is there much symbolic algebra available in Haskell?
20:29:20 <tensorpudding> It's the default behavior of cabal to install packages there.
20:29:24 <EvanR> tensorpudding: yes
20:29:33 <tensorpudding> Then GHC knows about them
20:29:38 <EvanR> it says 'member of a hidden package'
20:29:45 <Axman6> > a + b^7
20:29:46 <lambdabot>   a + b * b * (b * b) * (b * b * b)
20:29:48 <tensorpudding> Which package?
20:30:03 <EvanR> It is a member of the hidden package `ghc-6.12.1'
20:30:06 <Axman6> JordiGH: it's extremely eassy to write yourself
20:30:29 <Axman6> easy*
20:30:35 <mxc> this solution is to run arch linux under virtual box..
20:30:42 <byorgey> dcoutts: http://byorgey.wordpress.com/2010/04/15/cabal-init/
20:30:49 <JordiGH> Axman6: For example, something that "knows" that exp(2*pi*i*k/p)^p = 1.
20:30:54 <fax> JordiGH,
20:31:08 <fax> for concrete values you can use CReal
20:31:11 <tensorpudding> That's a bit...odd. Is that the version of GHC you have?
20:31:16 <fax> but for symbolic stuff I don't know
20:31:27 <EvanR> yes
20:31:41 <byorgey> JordiGH: there might be packages to do that, but it's not built in
20:32:04 <tensorpudding> Maybe your cabal config is messed up
20:32:14 <EvanR> i just ran the bootstrap :(
20:32:22 <EvanR> it installed itself in my home dir
20:32:29 <EvanR> and now packages are being installed there
20:32:49 <EvanR> and ghci keeps saying package not found, its a member of the hidden package ghc-...
20:32:53 <mxc> byorgey - looks like i'll miss hacphi again this year :(
20:32:58 <EvanR> :''(
20:33:04 <byorgey> mxc: boo =(
20:33:41 <monochrom> a package cannot be a member of another package.
20:33:55 <EvanR> according to ghci it can
20:34:08 <EvanR> eh, module not found
20:34:19 <JordiGH> byorgey: I see.
20:34:32 <mxc> anything exciting happening at Penn CS lately?
20:34:34 <JordiGH> I was expecting packages, just wondering if they were common.
20:35:24 <JordiGH> DoCon seems to be the first hit.
20:35:30 <byorgey> JordiGH: you can look here to see what math-related packages there are: http://hackage.haskell.org/package/#cat:math
20:35:39 <byorgey> yeah, I've heard of DoCon but never tried it
20:36:13 <monochrom> the "Cabal" package does not use any module from the "ghc" package
20:36:17 <tensorpudding> Could it be an error in cabal-install?
20:36:45 <EvanR> i tried cabal-install twice
20:36:52 <EvanR> bootstrap
20:36:53 <EvanR> .hs
20:36:54 <EvanR> sh
20:37:21 <EvanR> i think my ghc is not configured to look in ~/.cabal/lib
20:37:32 <EvanR> though it is, to tell me where that module is
20:37:52 <fax> JordiGH  -- I've been using haskell for numerical calculations and pari/gp for multiplying out polynomials
20:38:19 <JordiGH> fax: I'm pretty sure pari/gp does Galois groups? I've been using GAP for that.
20:38:35 <JordiGH> Sometimes I also use Maxima, but it feels really ghetto.
20:38:42 <monochrom> the "binary" package does not use the "ghc" package either
20:38:50 <JordiGH> Unfortunately, ghetto as it is, it's the one I know best.
20:39:20 <EvanR> i will delete ~/.cabal
20:39:27 <EvanR> i will uninstall and reinstall ghc
20:42:06 <EvanR> i seem to have broken all my packages, and ghc-pkg check confirms that
20:42:40 <EvanR> reinstalling those
20:45:33 <EvanR> how do i unregister packages with ghc
20:46:04 <Veinor> ghc-pkg unregister package
20:46:19 <Veinor> you could also delete ~/.ghc
20:46:48 <EvanR> package zlib, ~/.cabal/lib/zlib/ghc doesnt exist...
20:46:51 <EvanR> ok ~/.ghc
20:47:15 <EvanR> bootstrap is now working
20:48:35 <Veinor> man, I love #haskell
20:49:45 <EvanR> cabal install binary worked
20:49:51 <EvanR> ghci, import Binary
20:49:56 <EvanR> could not find module Binary
20:50:03 <EvanR> it is a member of the hidden package ghc-6.12.1
20:50:27 <Axman6> Data.Binary
20:50:48 <Axman6> check the docs before trying to use packages ;)
20:51:00 <EvanR> >_<
20:51:36 <EvanR> that was the problem all along
20:52:55 <jgh> fax: The soluble quintic for 11 is x^5 + x^4 - 4x^3 - 3x^2 + 3x + 1. I checked with GAP. Its Galois group is C_5 as it should be.
20:53:05 <fax> woah
20:53:10 <jgh> Generated by raising to the 2nd power.
20:53:20 <fax> okay but how DO you solve it ?
20:53:22 <gl0w_> i am getting a type error with this (http://pastebin.com/raw.php?i=F5VzsKBw) code and was wondering if someone could possibly help me figure out why
20:53:30 <jgh> fax: I'll think about it tomorrow. :P
20:53:55 <fax> hmmm
20:53:59 <fax> jgh can you check something for me
20:54:05 <ezyang> gl0w_: Operator precedence error
20:54:12 <fax> well
20:54:16 <fax> I should just install GAP and try it myself
20:54:20 <gl0w_> ezyang: meaning? i'm pretty new to haskell
20:54:43 <jgh> fax: I'm pretty sure pari/gp also computes Galois groups...
20:54:56 <ezyang> actually, it looks like you've got other problems too
20:55:05 <EvanR> ByteString is defined in more than one module?
20:55:07 <fax> \beta_1 = \zeta_{13}+\zeta_{13}^3+\zeta_{13}^9, \beta_2 = \zeta_{13}^4+\zeta_{13}^{10}+\zeta_{13}^{12}, \beta_3 = \zeta_{13}^2+\zeta_{13}^5+\zeta_{13}^6, \beta_4 = \zeta_{13}^7+\zeta_{13}^8+\zeta_{13}^{11}
20:55:12 <fax> this are my equations
20:55:13 <gl0w_> its suppose to be reading in a class file as binary
20:55:16 <fax> like
20:55:20 <gl0w_> at least thats what im attempting to do
20:55:21 <fax> k = z+z^3+z^9
20:55:27 <fax> ^ this is a solvable _cubic_?
20:55:39 <jgh> All cubics are soluble. :-)
20:55:41 <fax> that's what I don't get.. I mean it's got 3 terms
20:55:46 <tensorpudding> Does Pari have a C library?
20:55:47 <fax> but.....  the powers are wrong
20:55:52 <jgh> But that doesn't have a cubic.
20:56:02 <jgh> tensorpudding: Pari *is* a C library, GP is an interface to it.
20:56:09 <fax> I don't /think/ it's possible to transform it into a cubic,
20:56:11 <tensorpudding> Oh, okay.
20:56:12 <Veinor> it can be reduced to a quartic though
20:56:19 <tensorpudding> Maybe you could write Haskell bindings to Pari then.
20:56:20 <fax> Veinor yikes how did you do that?
20:56:25 <Veinor> oh wait, k, not 0
20:56:27 <ezyang> gl0w_: Ok, sir
20:56:28 <fax> ah
20:56:29 <Veinor> my mistake
20:56:36 <tensorpudding> (maybe someone already has)
20:56:38 <ezyang> gl0w_: tell me the type of getWord16be
20:57:05 <jgh> fax: I'm not following that. I'll think about it tomorrow. I must go to sleep now, past my bedtime.
20:57:19 <fax> night night !
20:57:34 <gl0w_> ezyang: ummm  according to what i've read it says its   Get Word16
20:57:36 <EvanR> gah
20:58:03 <Veinor> but yeah, z+z^3+z^9 is not a cubic
20:58:04 <EvanR> Data.ByteString.Internal.ByteString vs Data.ByteString.Lazy.Internal.ByteString
20:58:06 <ezyang> gl0w_: Ok. So, Get is not a function.
20:58:36 <fax> O_O
20:58:38 <fax> all the roots of x^5 + x^4 - 4x^3 - 3x^2 + 3x + 1 are real
20:58:45 <fax> that can't be right!!
20:58:48 <gl0w_> ezyang: its just a type then?
20:59:33 <ezyang> Get t is a type. Get is actually a monad, for some reason.
20:59:36 <tensorpudding> that would be rather astonishing
21:00:28 <gl0w_> ezyang: ok.... so how does that apply to my issue then?
21:01:01 <ezyang> remind me what you were trying to do again?
21:01:11 <gl0w_> ezyang: read in a class file as binary
21:01:30 <gl0w_> ezyang: or rather as bytecode
21:01:50 <gl0w_> ezyang: evenutally it will have to parse that to determine things like super classes, numbers in the constant pool etc
21:04:06 <ezyang> ok, you might have better luck playing with the sample code here to start off http://code.haskell.org/binary/
21:06:19 <ezyang> but the code you have is a little misdirected
21:07:40 <ezyang> > runGet getWord8 (pack "foo")
21:07:40 <lambdabot>   Not in scope: `runGet'Not in scope: `getWord8'Not in scope: `pack'
21:07:44 <ezyang> bah
21:08:05 <tensorpudding> @type Data.Binary.runGet
21:08:06 <lambdabot> Not in scope: `Data.Binary.runGet'
21:10:02 <ezyang> but to give you an idea of what you were trying to do:
21:10:04 <ezyang> *Main Data.ByteString.Lazy.Char8> runGet getWord8 (pack "foo")
21:10:12 <ezyang> 102
21:10:38 <ezyang> runGet runs something of type "Get a", getWord8 is of type "Get Word8", and (pack "foo") generates a bytestring to run it on.
21:11:06 <ezyang> the output result is a, in this case Word8
21:11:18 <ezyang> and you have to be careful about what kind of bytestream you're feeding to the functions
21:11:38 <kmc> Get is a monad for a clear reason, I think
21:11:47 <ezyang> kmc: Yeah, it seems a lot clearer to me now
21:11:53 <ezyang> I wasn't sure what Data.Binary did before
21:12:31 <gl0w_> ezyang: i'm looking at this sample code and its pretty confusing too me >_>
21:12:46 <gl0w_> ezyang: but i kinda see what you're saying about runGet
21:12:54 <ezyang> yeah. Play around with that, make incremental changes
21:13:07 <ezyang> start learning to interpret the type errors. It's like reading the matrix
21:13:16 * ezyang goes to bed now 
21:13:21 <gl0w_> thank you
21:16:06 <kmc> i don't even see the code anymore
21:16:37 <Veinor> i just see monad, monoid, functor
21:18:48 <newsham> nobody can tell you what the type error means
21:19:00 <newsham> (shoulda took the red pill)
21:19:50 <djahandarie> I just see s k i...
21:20:07 <newsham> my god, its full of combinators!
21:20:34 <kmc> jupiter and beyond the infinite
21:20:48 <djahandarie> I just see monomorphisms catamorphisms exomorphisms.......
21:21:08 <djahandarie> codensities cofrees and kan extensions!!!
21:21:11 * djahandarie goes to bed
21:21:15 <kmc> are there exomorphisms? probably in category-extras
21:22:12 <blackdog> djahandarie: not s and f?
21:22:29 <newsham> are there no new conal blog posts since january (since he mentioned RSS being fixed) or am I doing something wrong?
21:22:31 <blackdog> they're more general than s and k...
21:22:35 <BMeph> Mmm...zygomorphism!
21:26:27 <Veinor> zygohistomorphic prepromorphisms!
21:30:17 <ddarius> blackdog: Reading Barry Jay, eh?
21:30:33 <cybercobra> don't use zygomorphisms for cloning, it's unethical!
21:30:48 <blackdog> ddarius: he gave a talk last night at the sydney fp user group
21:30:54 <fax> whats f?
21:31:32 <cybercobra> fax: a combinator apparently
21:31:38 <fax> yes what is it
21:31:45 <blackdog> http://www-staff.it.uts.edu.au/~cbj/patterns/
21:32:38 <blackdog> FAMN -> M for any atom A
21:32:38 <ddarius> http://www-staff.it.uts.edu.au/~cbj/Publications/factorisation.pdf in particular
21:32:49 <fax> atom??
21:32:52 <blackdog> F(PQ)MN -> NPQ if PQ is a compound
21:33:00 <fax> what you can't do this
21:33:15 <blackdog> in SK? no.
21:33:16 <fax> how does it know whats an atom
21:33:32 <ddarius> fax: S and F are the atoms.
21:34:36 <ddarius> Perhaps more generally, anything that is not an application is an atom.
21:36:53 <blackdog> it's a funny distinction - it's a bit more syntactically based in a way
21:37:15 <blackdog> for instance, you could have two different SK expressions which evaluate to the same thing
21:37:26 <ddarius> E.g. SKS SKK
21:37:33 <blackdog> and you can't tell them apart, because all you can do to an expression is evaluate it
21:38:07 <blackdog> but you can write them down differently, so technically in the process of putting either SKS or SKK (thank you ddarius) on the tape, you've got information out that you shouldn't technically have
21:38:41 <blackdog> (this is my poor re-telling of barry's talk)
21:39:18 * blackdog is waiting for ddarius to tell him he's an idiot :)
21:40:44 <Axman6> you're an idiot
21:40:59 <blackdog> Axman6: why are canberrans so unkind?
21:41:06 <kmc> oh no he di'int
21:41:08 <blackdog> especially since I'm visiting you bastards tonight
21:41:17 <Axman6> you are?
21:41:29 <blackdog> going to camp cottermouth for RailsCamp
21:41:56 <blackdog> proselytising the unwashed ruby masses
21:42:30 <Axman6> good work
21:42:38 <Axman6> should have told me, we could have gone to the pub
21:42:42 <blackdog> just mirroring hackage as we speak
21:43:09 <blackdog> i think railscamp is pretty full on:)
21:43:13 <Cale> blackdog: Barry's talk?
21:43:19 <Cale> Is this something online?
21:43:34 <blackdog> Cale: I don't think it was recorded
21:43:47 * Axman6 will be back in 5
21:43:55 <blackdog> the slides might be up at http://www-staff.it.uts.edu.au/~cbj/patterns/
21:50:25 <fax> im confused, does roots of unity come before or after galois theory?
21:50:33 <ddarius> fax: No
21:50:54 <Cale> Mathematics is not totally ordered
21:50:55 <fax> they're mutually recursive?
21:51:11 <m3ga> Cale: baryy's previsou talk slides about pattern calc are here : http://www-staff.it.uts.edu.au/~cbj/Publications/fpsyd.pdf
21:51:26 <Cale> Roots of unity might show up in the analysis of some number fields using Galois theory.
21:51:40 <blackdog> m3ga: we really have to start recording those talks
21:51:48 <blackdog> google must have the setup to do it
21:52:01 <m3ga> last night was mostly a demo of the bondi language and he then got dragged back into the calc.
21:52:03 <Cale> A root of unity is just a number x such that x^n = 1 for some n.
21:52:06 <blackdog> failing that, even someone with a webcam up the back:)
21:52:16 <blackdog> m3ga: well, it's just so shocking
21:52:35 <fax> Cale - I got the impression to solve a solvable polynomial you needed all the roots of unity -- and that was pretty much it
21:52:36 <m3ga> blackdog: yes, google have the equipment and it rocks. but we need someone to drive it.
21:52:47 <fax> Cale so I tried to learn about the roots of unity but it seems ot make use of galois theory
21:53:01 <fax> so maybe they depend on each other
21:53:19 <Cale> fax: I'm not sure I understand what you mean... how to find the roots of a polynomial in terms of roots of unity when that's possible to do?
21:54:02 <fax> oohhhh
21:54:35 <m3ga> blackdog: are you volunteering to coordinate with google chaps to get the videos?
21:54:47 <fax> that's neat you just leave it as a parameter... then you can instantiate it later: And that lets you solve both problems in which ever order you like
21:55:02 <Cale> Sorry, I don't understand ;)
21:55:10 <fax> you just made me realize that
21:55:52 <blackdog> m3ga: anything else would be hugely hypocritical, i suppose:)
21:56:02 <m3ga> :-)
21:56:03 <Cale> leave what as a parameter?
21:56:15 <fax> the roots of unity
21:56:37 <fax> I was describing it sort of like modules in ML
21:56:45 <fax> but that's not a normal way to think about math... I guess
21:56:50 <m3ga> for many talks, i'm pretty sure people would be happiest not to be videoed, but both of Barry's talks should have more exposure.
21:57:17 <m3ga> i would have been good to capture ben's first disciple talk as well.
21:57:48 <blackdog> even for smaller talks, it's good feedback - obviously you don't put it up online if people are uncomfortable with it, but i'd love to have video of my talks just to improve for next time
22:00:59 <ddarius> The pattern calculus work, especially the most recent stuff, is very impressive.
22:01:35 <blackdog> ddarius: absolutely. i saw barry talk at SAPLING and sort of filed it under "interesting but ridiculously esoteric"
22:01:56 <blackdog> but the bondi demo is pretty compelling
22:02:44 * ddarius recommends this for (close to) the latest stuff: http://journals.cambridge.org/repo_A45US65o
22:02:59 <ddarius> That's a disguised link to a PDF.
22:03:54 <kmc> hell yes, first class everything
22:07:48 <Veinor> first class types!
22:07:59 <copumpkin> dynamic languages!
22:08:04 <fax> 0th class
22:08:23 <blackdog> copumpkin: booo
22:08:28 <kmc> Veinor, hell yes
22:08:46 <blackdog> getting the flexibility while keeping the type guarantees statically, that's the exciting bit
22:09:05 <blackdog> btw, has anyone ever heard the term "behavioural consistency" before?
22:09:18 <blackdog> barry seems to use it to mean a slightly weaker version of referential transparency
22:10:00 <blackdog> ie, you can add functionality to existing code, but it won't change the behaviour of expressions that worked beforehand
22:10:10 <blackdog> sort of like adding a typeclass instance at runtime, i suppose
22:11:08 <kmc> interesting
22:16:01 <blackdog> s/continuity/consistency/
22:33:32 * hackagebot mmap 0.5.5 - Memory mapped files for POSIX and Windows  http://hackage.haskell.org/package/mmap-0.5.5 (GracjanPolak)
22:38:33 * hackagebot mmap 0.5.6 - Memory mapped files for POSIX and Windows  http://hackage.haskell.org/package/mmap-0.5.6 (GracjanPolak)
23:31:05 <kmc> @src ($!)
23:31:06 <lambdabot> f $! x = x `seq` f x
