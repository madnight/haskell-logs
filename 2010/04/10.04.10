00:13:08 <ManateeLazyCat> What's syb?
00:13:22 <c_wraith> scrap your boilerplate
00:14:08 <tensorpudding> is scrapping boilerplate a green initiative?
00:14:26 <ManateeLazyCat> c_wraith: use syb for what?
00:14:46 <ManateeLazyCat> c_wraith: It can generate template code?
00:14:54 <ivanm> ManateeLazyCat: something like that
00:14:58 <ivanm> see the paper, etc.
00:15:03 <ivanm> it's a generics library
00:15:12 <ivanm> tensorpudding: depends on what it's used for
00:15:19 <ManateeLazyCat> ivanm: I'm try to use TH, but TH really alien for any code.
00:15:30 <ManateeLazyCat> ivanm: TH make me like AST writer.
00:15:32 <ManateeLazyCat> :)
00:15:41 <ivanm> ManateeLazyCat: syb is to remove redundant/duplicate code
00:16:12 <tensorpudding> To what extent is the result able to be understood by mortals?
00:16:35 <ivanm> tensorpudding: you mean the stuff generated by syb?
00:16:40 <ManateeLazyCat> ivanm: I want use TH save my code lines, but i found I need much time to write correct TH and got complicated alien code.
00:16:43 <ivanm> IIRC, it's just computer generated code
00:16:53 <ivanm> ManateeLazyCat: why are you using TH?
00:17:23 <ManateeLazyCat> Wait, i post code.
00:18:17 <ivanm> no, say _why_ you're doing it
00:18:21 <ManateeLazyCat> ivanm: Above is origin version
00:18:22 * ManateeLazyCat pasted "1 version" at http://paste2.org/get/766259
00:18:32 <ivanm> I shouldn't even be here, as I've got to go somewhere tonight
00:18:40 <ManateeLazyCat> ivanm: Okay
00:19:10 <ManateeLazyCat> ivanm: I use TH for generate function delcaration.
00:19:34 * ManateeLazyCat pasted "TH code" at http://paste2.org/get/766262
00:19:36 <ManateeLazyCat> ivanm: Like above
00:20:22 <ivanm> *shrug* I've never used TH or syb so I don't know if what you want is possible
00:20:29 <ivanm> but I've used pretty to generate code
00:20:55 <ivanm> ManateeLazyCat: this looks like the kind of thing you're wanting: http://code.haskell.org/graphviz/Data/GraphViz/AttributeGenerator.hs
00:21:10 <ManateeLazyCat> ivanm: Simple is, i have datatype "data Foo = FooA Arg1 Arg2 Arg3 | FooB Arg1 Arg2 Arg3", i want to use TH generate function delcartion that "Foo -> [Variant]"
00:21:17 <ivanm> ManateeLazyCat: tip: if you don't care about the arguments, use Foo{} to avoid having to do an explicit match on each one (and thus knowing how many arguments it takes)
00:21:43 <ManateeLazyCat> ivanm: Yes, i have change that.
00:21:54 <ManateeLazyCat> use {} avoid _ _ _
00:23:49 <ivanm> ManateeLazyCat: anyway, I've never used TH, but I think it's the wrong approach to generate (semi-)static code
00:24:13 <ManateeLazyCat> ivanm: So i want to is: Generate Template Code for datatype structure, and don't want TH's alien style.
00:24:48 <ivanm> do something like what I've done in the link above; you could even do String comparisons to generate something like checkDaemonSignalArgs
00:25:12 <ivanm> ManateeLazyCat: I'd also be tempted to combine DaemonMember and DaemonSignalArgs into the one datatype
00:25:45 <ManateeLazyCat> ivanm: No, template code is useful for "extension system"
00:25:50 <ManateeLazyCat> ivanm: See this situation: I build a API interface, application programmer just need add new type in list and call interface, that's all, system will scan those type list and generate code automatically.
00:25:52 <ivanm> ManateeLazyCat: I've also done similar kind of stuff using emacs' regex replacement stuff
00:26:02 <ivanm> *shrug*
00:26:03 <ManateeLazyCat> ivanm: Then other developer  don't care implementation detail.
00:26:47 <BMeph> Would it be wrong (I know it'd ba hackish) to just derive Enum on both of those types, and just say they're true when their toInteger vals are? :)
00:26:58 <ivanm> ManateeLazyCat: *shrug*
00:27:09 <ManateeLazyCat> ivanm: But DaemonMember is standalone datatype for DBus message.
00:27:25 <ivanm> BMeph: could be hacky and more likely to break if a dev accidentally changes something
00:27:43 <ivanm> ManateeLazyCat: have a Arg -> Member function and you could do comparisons using that
00:27:58 <ivanm> checkDaemonSignalArgs m as = m == toMember as
00:27:59 <ManateeLazyCat> ivanm: Yep.
00:28:09 <ivanm> much easier!
00:28:24 * ivanm leaves before he wastes any more time
00:28:51 <ManateeLazyCat> ivanm: :)
00:29:07 <ManateeLazyCat> Okay i explore syb self.
00:29:09 <ivanm> I've got somewhere to be in 1.5 hrs, and need to eat, etc. first
00:29:18 <ivanm> ManateeLazyCat: there are other generics libraries as well
00:29:26 * ManateeLazyCat I bla bla bla too much....
00:29:34 <ivanm> ManateeLazyCat: http://hackage.haskell.org/package/#cat:generics
00:31:10 <ManateeLazyCat> ivanm: Thanks, i explore those myself. :)
01:23:51 * hackagebot control-monad-attempt 0.2.0 - Monad transformer for attempt.  http://hackage.haskell.org/package/control-monad-attempt-0.2.0 (NicolasPouillard)
02:32:25 <sadache> I am looking for a generalized version of all function
02:32:47 <sadache> a kind of fold that short circuits under some condition
02:34:19 <Gracenotes> foldr is the short-circuiting kind
02:34:45 <Gracenotes> the short circuit behavior depends entirely on how strict the function is
02:35:58 <kmc> @type \p -> foldMap (All . p)
02:35:59 <lambdabot> Not in scope: `foldMap'
02:36:02 <sadache> Gracenotes: oh that's great, didn't think of that
02:36:05 <kmc> @type \p -> Data.Foldable.foldMap (All . p)
02:36:06 <lambdabot> forall a (t :: * -> *). (Data.Foldable.Foldable t) => (a -> Bool) -> t a -> All
02:36:23 <kmc> @type \p -> getAll . Data.Foldable.foldMap (All . p)
02:36:24 <lambdabot> forall a (t :: * -> *). (Data.Foldable.Foldable t) => (a -> Bool) -> t a -> Bool
02:37:07 <kmc> > let f p = getAll . Data.Foldable.foldMap (All . p) in f (== 7) Nothing
02:37:08 <lambdabot>   True
02:37:24 <sadache> thank you Gracenotes
02:37:28 <kmc> > let f p = getAll . Data.Foldable.foldMap (All . p) in f (== 7) [7,7,7]
02:37:29 <lambdabot>   True
02:37:30 <kmc> > let f p = getAll . Data.Foldable.foldMap (All . p) in f (== 7) [7,7,8]
02:37:31 <lambdabot>   False
02:37:46 <Gracenotes> sadache: sure. here is a quick example
02:38:23 <Gracenotes> > let firstNegative xs = foldr (\x acc -> if x < 0 then Just x else acc) Nothing xs in (firstNegative [1, 2, 3, 4], firstNegative [1, 2, 6, -10, 2])
02:38:24 <lambdabot>   (Nothing,Just (-10))
02:38:56 <Gracenotes> as a rule of thumb, forcing the evaluation of acc requires going down the list further
02:42:49 <Gracenotes> er and there's always just find (<0) :/
02:42:54 <sadache> but my problem with foldr is that it can span a lot of space
02:43:15 <sadache> I mean for longer lists
02:44:16 <sadache> what I was thinking about is a version of foldl that short circuits so that I can get a tail recursion too
02:45:51 <Gracenotes> you might not get tail recursion, but if GHC is smart enough it might be able to give you tail calls, I think. But I don't know if it can guess that.
02:46:06 <Gracenotes> @src foldr
02:46:06 <lambdabot> foldr f z []     = z
02:46:06 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
02:46:37 <Gracenotes> foldr can be a tail call to f, and f can be a tail call to foldr, until the recursion ends.
02:47:15 <Gracenotes> which might require some mighty inlining indeed..
02:47:33 <sadache> i see
02:51:55 <Jafet> @src foldl'
02:51:56 <lambdabot> foldl' f a []     = a
02:51:56 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
02:52:19 * hackagebot tconfig 0.5.1 - Simple text configuration file parser library.  http://hackage.haskell.org/package/tconfig-0.5.1 (AnthonySimpson)
02:53:19 * hackagebot strict-io 0.1.1 - A library wrapping standard IO modules to provide strict IO.  http://hackage.haskell.org/package/strict-io-0.1.1 (NicolasPouillard)
02:57:00 <BMeph> Good night, all.
03:27:45 <monadic_kid> 2 more lessons to port and i'm done http://github.com/snkkid/LazyFooHaskell
03:32:32 <gio123> ski: hi
03:33:23 <maltem> preflex: seen spencerjanssen
03:33:23 <preflex>  Sorry, I haven't seen spencerjanssen
03:35:09 <gio123> ski: hi
03:38:06 <Eelis> hurray, after one more round of nagging, paterson let me have "eelis" as my hackagedb user name!
03:38:29 <kalven> \o/
03:39:57 <alp_> preflex, seen sjanssen
03:39:57 <preflex>  sjanssen was last seen on #haskell 4 days, 10 hours and 53 seconds ago, saying: Veinor: there are potential slowdowns when using -threaded on a single processor
03:40:11 <alp_> maltem, ^^^
03:40:40 <maltem> thx
03:41:14 <Jafet> Does this establish precedent? My real name is sort of lame
03:42:20 <Eelis> Jafet: i would say so
03:43:02 <Eelis> Jafet: i suspect that the new policy is: real names in camelcase, nick names in lowercase (because he asked me whether i would settle for "eelis" after i'd requested "Eelis")
03:43:22 <Eelis> and because the only other overt nickname was "aphaccar" before
03:44:16 <Ke> he should never have given in
03:44:49 <maltem> Eelis, I vote for pseudonyms that resemble real names anyways. What about making up a good surname to go with Eelis?
03:45:07 <Jafet> I go for "Norris"
03:45:09 <Eelis> maltem: i don't share your preference.
03:45:31 <maltem> pity, I would have liked Eelis Norris :)
03:48:02 <Gracenotes> Eelis Tucker, the protagonist of the 1910 pastoral drama/romance novel
03:48:26 <Gracenotes> ..it could work
03:48:27 <Eelis> i'll admit both have a ring to them
04:02:18 <jlouis> Eelis: no bourbaki?
04:03:43 <Eelis> jlouis: i actually offered it (as part of a whole list for him to choose from), but he let me have "eelis" instead
04:07:02 <kamatsu> I have a Android G!
04:07:05 <kamatsu> *G1
04:07:12 <kamatsu> thinking of getting haskell on it
04:07:50 <Jafet> Eelis Bernoulli
04:10:17 <Jafet> Hmm, what
04:10:30 <Jafet> Apparently I'd heard of the Charles Bourbaki, but not the Nicolas
04:11:07 <JuanDaugherty> it's a fiction for a group of french mathematicians
04:11:18 <JuanDaugherty> nom de plume
04:11:19 <winxordie> Jafet: there's a Charles Bourbaki?
04:11:29 <Jafet> Yes
04:11:49 <winxordie> I've only heard of the great Nicolas schizophrenic.
04:25:49 <dschoepe> Can I specify a default type for an associated type?
04:34:53 <Younder> busy week learning category theory, lambda calculus and dataflow analysis (self study)
04:35:29 <Younder> waiting for my book on garbage collection algorithms..
04:36:26 <Younder> Anyone know of a good source for Fw calculus (typed lambda calculus)?
04:37:41 <Younder> For the record after type checking Haskell get's desugared into Fw..
04:37:55 <chrisdone> Huet, G. (1975) A Unification Algorithm for Typed Lambda Calculus. Th. Comp. Sci., 1, 1, pp. 27-57.
04:38:28 <Younder> chrisdone, thanks
04:40:59 <chrisdone> gwern: ping
04:49:07 <twink> Younder: Kim Mens, "An Introduction to the Polymorphic Lambda Calculus with Subtyping" has it along with some more things.
04:51:46 <marekw2143> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24805#a24805 - does it tells that to get book id I need to pass a Book type, id of book and other book properties?
04:51:59 <marekw2143> to bookID funciton
04:52:19 <kmc> marekw2143, the bookID function is defined for a single argument
04:52:21 <FliPPeh> @hpaste
04:52:21 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
04:52:25 <kmc> which is (Book id title authors)
04:53:10 <kmc> it's "pattern matching" on a value of type BookInfo
04:53:24 <marekw2143> kmc: so the argument is a tuple?
04:53:31 <kmc> marekw2143, not a tuple per se
04:53:35 <kmc> but like a tuple yes
04:53:43 <kmc> in that there are several fields
04:54:24 <marekw2143> but in ghci :type bookID gives: bookID :: BookInfo -> Int
04:54:26 <FliPPeh> I somehow think my programming style is WAY to explicit.. so, can someone have a quick glance over my source at http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=9630#a9630 and tell me whether it looks good or something could be improved?
04:54:35 <FliPPeh> I'd appreciate it big time :)
04:54:48 <Jafet> Explicit code is sexy
04:54:57 <FliPPeh> Not really :(
04:55:22 <FliPPeh> I'm glad I managed to improve me codes that fill in stuff in a large record
04:55:40 <FliPPeh> By folding over a default record and update every value inside a new function
04:56:18 <Raynes> Holy lots of records.
04:56:19 <Raynes> :p
04:57:27 <FliPPeh> Raynes: Hell yes :)
04:57:40 <FliPPeh> Twitter exports way too much information
04:57:51 <FliPPeh> Something like "name: status: time" would be sufficient :)
04:57:59 <FliPPeh> But this is web 2.0!
04:58:15 <Raynes> All APIs export too much information.
04:58:39 <Raynes> I ask wunderground for a forecast and it tosses 30 of them at me. :p
04:58:56 <p_l> FliPPeh: why can't you ignore unnecessary data?
04:59:12 <FliPPeh> Well
04:59:20 <FliPPeh> It feels so uncomplete :/
04:59:26 <p_l> even if the lib makes them a required argument...
04:59:45 * p_l is used to seeing declarations of an argument being ignorable in CL
04:59:47 <FliPPeh> There's no lib :x
05:00:01 <p_l> heh
05:00:04 <chrisdone> FliPPeh: the names at 239 aren't that necessary, seeing as they don't (1) give more information or (2) abstract an idea used more than once, imho
05:01:06 <p_l> write a type for the function parsing the argument, and have flexible return type (one that doesn't need all fields fitted, or maybe a lazy data structure that queries server for extra data?) and then write specialized variants that extract only the data you want...
05:01:13 <FliPPeh> chrisdone: They shouldn't give lots of information, just peek into my JSON structure and fetch some data out of it
05:02:01 <FliPPeh> Or did you mean removing the "fieldName = " part, and just fold them in order of the record?
05:02:12 <Jafet> Flippeh, make a twitter boilerplate library for hackage!
05:02:49 <FliPPeh> p_l: Querying the server for more data is bad
05:02:58 <FliPPeh> Twitter returns all data in one chunk in one request
05:03:14 <FliPPeh> There's no API method to request additional information
05:03:51 <p_l> FliPPeh: does the data returned contain an id that allows for the same message to be queried for?
05:05:08 <chrisdone> FliPPeh: I just meant like this: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=9630#a9631
05:05:28 <FliPPeh> p_l: It depends what I query. If I query a timeline, I get all message objects (where each also includes the whole profile information of the author) and each of them carries an ID, that I could later query to get only that status with again the whole profile header and message information
05:05:46 <FliPPeh> So it always returns everything
05:05:54 <chrisdone> it's a shame record assignment isn't first-class otherwise that could be abstracted
05:06:13 <harlekin> chrisdone, can this be realized using template haskell?
05:06:13 <FliPPeh> I might as well just read all of it at once
05:06:25 <chrisdone> like: setOpt opt r v = r { opt = v }
05:06:31 <FliPPeh> chrisdone: Oh, inlining it, now I get it
05:06:38 <FliPPeh> Yeah, that's an improvement
05:06:40 <FliPPeh> Thanks :)
05:06:41 <chrisdone> harlekin: probably but I don't know the exact means to do it
05:06:52 <marekw2143> kmc :thanks
05:07:04 <chrisdone> FliPPeh: sure. it's just being picky I guess, hahaha
05:07:46 <chrisdone> harlekin: do you know?
05:07:48 <FliPPeh> Not that picky, single functions used for just one purpose shouldn't float around
05:07:51 <FliPPeh> :)
05:08:06 <harlekin> chrisdone, I don't know much template haskell unfortunately.
05:08:31 <chrisdone> FliPPeh: sure
05:08:44 <chrisdone> FliPPeh: I'm guessing you're already following this guide? http://github.com/tibbe/haskell-style-guide
05:09:41 <FliPPeh> chrisdone: Actually, I'm not, I looked at other sources and adopted a structure that seems useful
05:10:03 <Phyx-> I was wondering if it's possible to make class declarations that take both kind * and kind # types
05:10:05 <chrisdone> ~_~
05:10:31 <FliPPeh> I had to lift the 80 character limit, tho
05:10:39 <chrisdone> FliPPeh: why's that?
05:10:56 <FliPPeh> Some lines where hard to understand when broken
05:11:01 <FliPPeh> Or just didn't look awesome enough
05:11:52 <chrisdone> ~_~
05:14:02 <Phyx-> I was wondering if it's possible to make class declarations that take both kind * and kind # types
05:33:04 <dobblego> @hoogle Either a a -> a
05:33:05 <lambdabot> Data.Either rights :: [Either a b] -> [b]
05:33:05 <lambdabot> Data.Either lefts :: [Either a b] -> [a]
05:33:05 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
05:35:32 <FliPPeh> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=9632#a9632
05:35:37 <FliPPeh> This is stupid ^^^^
05:35:43 <FliPPeh> How can I generalize that?
05:36:32 <Twey> FliPPeh: Functor instance
05:36:33 <kmc> in what direction?
05:36:37 <Twey> Or wait
05:36:40 <Twey> Oh wait**
05:36:48 <Twey> Not a Functor instance
05:36:56 <Jonno_FTW> @hpaste
05:36:56 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
05:37:05 <kmc> FliPPeh, SYB would help you write some of those
05:37:14 <kmc> but there is clearly JSON-specific logic going on here
05:37:20 <kmc> e.g. jsToBool
05:38:00 <kmc> (also, JSON defines different boolean interpretation of floats? ugh)
05:38:04 <ksf> do we have a standard set of parser benchmarks?
05:38:06 <ksf> if not, why not?
05:38:12 <FliPPeh> I don't know :x
05:39:37 <Jonno_FTW> how come this won't load at at the 4th line of the pattern match? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=9633#a9633
05:40:14 <Jonno_FTW> i get the error:     Occurs check: cannot construct the infinite type: a = [a]
05:41:06 <Twey> I don't believe JSON defines type coercions of any kind
05:41:08 <dankna> that error means that you did something that would require a type to be a list of itself
05:41:12 <Twey> JS does
05:41:42 <dankna> try putting a type signature on mergeSort
05:41:46 <dankna> then you'll get a more meaningful message
05:41:53 <Jonno_FTW> ok
05:42:15 <dankna> that said, I think I see your problem
05:42:22 <dobblego> Jonno_FTW, you really should not be calling length anyway
05:42:23 <dankna> but for didactic purposes I'm not going to tell you the solution :D
05:42:33 <Jonno_FTW> yeah
05:42:34 <Jonno_FTW> i got stuck
05:42:37 <dankna> that's true, you could do it with a pattern match
05:42:43 <Jonno_FTW> i was going to ask about the length thing
05:42:52 <Jonno_FTW> how can i check if a list is [a,b]
05:42:54 <dankna> mergeSort (a:b:[]) ...
05:42:57 <dankna> mergeSort (a:[]) ...
05:43:04 <dankna> oh wait
05:43:07 <dankna> even easier
05:43:11 <dankna> mergeSort [a, b] ...
05:43:13 <dobblego> [a, b]
05:43:14 <dankna> mergeSort [a] ...
05:43:53 <Jonno_FTW> how would i check if a list is of length 2 without calling length?
05:44:07 <dankna> the pattern match that dobblego and I both just gave you
05:44:24 <Jonno_FTW> oh right
05:44:26 <dankna> split "mergeSort xs | ..." into multiple definitions
05:44:31 <Jonno_FTW> yep
05:44:31 <dankna> without the guard (the part from | on)
05:45:40 <Jonno_FTW> ok i fixed that
05:45:55 <dankna> great.  did you add the type signature yet?  what's the new error message?
05:46:34 <Jonno_FTW> but I can't figure out the type sig
05:46:56 <dankna> well, you're taking a list of any type that can be compared, for which the typeclass is Ord
05:46:58 <Jonno_FTW> this is really only the first half of the algorithm
05:47:00 <dankna> and returning the same thing
05:47:18 <dankna> really?  it looks like the full algorithm to me
05:47:34 <Jonno_FTW> mergeSort :: [a] -> (Ord [a])
05:47:43 <dankna> except Ord is a typeclass, not a type, so it needs to be
05:47:50 <dankna> mergeSort :: (Ord a) => [a] -> [a]
05:47:55 <Jonno_FTW> i would think that it would make a list of the split up lists
05:48:05 <dankna> oh, yes, I didn't know if you saw that
05:48:11 <dankna> sorry, you're right
05:48:29 <dankna> anyway you should make the type sig be what you want the final thing to be and it will nicely tell you where you violate it
05:49:23 <Jonno_FTW> ok
05:49:26 <Jonno_FTW> now i get the error
05:49:38 <Jonno_FTW>     Occurs check: cannot construct the infinite type: a = [a]
05:49:40 <Jonno_FTW>     When generalising the type(s) for `mergeSort'
05:49:43 <dankna> okay
05:49:51 <dankna> well, I wanted to lead you to figuring this out yourself
05:49:55 <dankna> but I'll just explain it, haha
05:49:58 <dankna> as that isn't very helpful
05:50:06 <dankna> look at the first of the three definitions
05:50:12 <dankna> what is the return type of just that definition?
05:50:16 <dankna> order xs
05:50:29 <dankna> or rather, you must have changed that to order [a, b] I guess
05:50:38 <Jonno_FTW> i'll post what i have now
05:50:41 <dankna> okay
05:51:14 <Jonno_FTW> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=9633#a9634
05:51:21 <dankna> okay yeah
05:51:30 <dankna> look at the first definition, mergeSort [a] = [a].
05:51:33 <dankna> what is the return type there?
05:51:38 <Jonno_FTW> a
05:51:47 <dankna> well not exactly, it's a list of a, isn't it?
05:51:49 <dankna> so [a]
05:51:54 <Jonno_FTW> ok
05:52:05 <dankna> second definition.  order [a, b].  what is the return type?
05:52:10 <Jonno_FTW> [a,b]
05:52:17 <dankna> that's not actually a type
05:52:26 <dankna> a and b are the same type - lists in Haskell are always of a single type
05:52:28 <Jonno_FTW> [a,a]
05:52:32 <dankna> just list the first item
05:52:35 <dankna> since they're the same
05:52:38 <Jonno_FTW> [a]
05:52:40 <dankna> yeah
05:52:48 <dankna> notice that it's the same as the type of the first definition
05:52:50 <dankna> so we have no problem yet
05:52:57 <Jonno_FTW> yep
05:52:57 <dankna> they match each other, and they match the signature too
05:53:01 <dankna> now
05:53:05 <dankna> what is the type of pt fst?
05:53:18 <dankna> don't look at that whole definition yet, just the pt fst part of it?
05:53:20 <Jonno_FTW> [a]
05:53:21 <dankna> good
05:53:26 <dankna> and pt snd is also [a], right?
05:53:29 <Jonno_FTW> yep
05:53:36 <Jonno_FTW> so i guess i need another function
05:53:40 <dankna> true
05:53:47 <dankna> so you just realized that what you have there is a list of lists
05:53:51 <dankna> [[a]] it would be written
05:53:53 <Jonno_FTW> yep
05:54:02 <dankna> read that "list of list of a"
05:54:16 <dankna> since that's not the same type as [a], Haskell complains
05:54:24 <Jonno_FTW> mergeSort' :: [a] -> [[a]] ?
05:54:32 <dankna> other way around
05:54:43 <dankna> you want to take two lists of lists and convert them to just one list
05:54:47 <dankna> I would write it personally as
05:54:58 <dankna> merge :: [a] -> [a] -> [a]
05:55:04 <dankna> taking two separate parameters instead of a list
05:55:17 <dankna> this isn't Lisp or Perl where lists are considered efficient, you want to avoid them when you can
05:55:40 <dankna> same goes for your definition of order by the way - I would rewrite it in the form order a b instead of order [a, b]
05:55:59 <Jonno_FTW> ok
05:56:36 <dankna> I'm going to explain what that rather opaque error message means, okay?
05:56:41 <dankna> even though I already told you how to fix it :)
05:56:47 <Jonno_FTW> ok
05:56:50 <Jonno_FTW> wait
05:57:01 <dankna> sure
05:57:09 <Jonno_FTW> should order be of type order :: a -> a -> [a] ?
05:57:15 <dankna> yes, exactly
05:57:38 <Jonno_FTW> ok
05:57:43 <dankna> it's a -> a -> [a], not a -> b -> [a] or anything like that, because the two things have to be the same type
05:57:45 <Jonno_FTW> continue
05:57:48 <dankna> you probably also need to add a type context there
05:57:55 <dankna> order :: (Ord a) => a -> a -> [a]
05:57:59 <dankna> see, Haskell is seeing that you have some definitions that return [a] and some that return [[a]]
05:58:07 <dankna> you and I can see at a glance that these aren't the same type
05:58:14 <dankna> but it can't, it can conceive that they could be
05:58:22 <Jonno_FTW> right
05:58:23 <dankna> specifically, they could be if "a" were the same type as "[a]"
05:58:46 <dankna> but that would result in an infinite type: the type "foo-list" is defined as "list of foo-lists"
05:58:50 <dankna> which is recursive
05:58:57 <Jonno_FTW> is it possible to have a function that can return multiple types?
05:59:05 <dankna> in general the answer is no
05:59:07 <dankna> not in Haskell
05:59:16 <Jonno_FTW> anywhere?
05:59:18 <dankna> there are some special cases which look like they break that rule without actually breaking it
05:59:40 <dankna> Haskell is all about strong typing, so I'd encourage you to think in terms of functions that only ever return one type
05:59:52 <Jonno_FTW> yep, i was just curious
06:00:17 <dankna> now if you want to return multiple VALUES you can return a tuple.  like you can have the type be ... -> (a, b) which is read "blah blah blah to pair of a and b"
06:00:29 <dankna> and then construct that value as (foo, bar) where foo is of type a and bar is of type b
06:00:32 <dankna> but that's not really the same thing
06:00:36 <dankna> anyway
06:00:43 <dankna> so this would be a recursive type
06:00:43 <Jonno_FTW> ok
06:00:48 <Jonno_FTW> yep
06:00:51 <dankna> because there would be no way to ever USE such a type, it's disallowed
06:01:09 <dankna> the "occurs check" is part of the algorithm called "unification" which is used to check whether two types could possibly be the same
06:01:21 <dankna> and in this case it's saying "they could be the same but only if they were infinite"
06:01:28 <dankna> so it's not a very useful error message
06:01:32 <dankna> but that's what it means
06:01:48 <dankna> it usually comes up in exactly this situation
06:01:52 <Jonno_FTW> ok
06:01:57 <dankna> where you have some definitions that return a and some that return [a]
06:02:06 <dankna> if you ever get it again, hopefully you'll know what you did wrong :)
06:02:15 <Jonno_FTW> i think the problem now, is linking merge and mergeSort
06:02:43 <dankna> mergeSort xs = merge (pt fst, pt snd), yes?
06:02:49 <dankna> or
06:02:57 <dankna> mergeSort xs = merge (pt fst) (pt snd) is what I meant to say, sorry
06:03:02 <ManateeLazyCat> Why i always got " Not in scope: `x[a6ud]' " error when i write TH code?
06:03:14 <dankna> MLC: I'd have to see the code
06:03:40 <Jafet> If I want to load a program into ghci, do I have to break the main function off into another source file?
06:03:48 <dankna> Jafet: no
06:03:52 <dankna> Jafet: it should just work
06:04:45 <Jafet> Well, I want to use the functions in the program
06:04:50 <Jafet> (Other than main)
06:04:58 <dankna> just do ghci Foo.hs
06:05:10 <dankna> and it will load up to a prompt where you can use those functions
06:06:12 <Jafet> Nope, all I get is to use main
06:06:23 <dankna> could you hpaste the exact error message?
06:07:00 <Jafet> ghci just doesn't tab complete my names
06:07:12 <dankna> I wasn't aware ghci even had tab-completion
06:07:16 <Jafet> And I get "Not in scope" error when I try to use them anyway, qualified and unqualified
06:07:19 <dankna> doesn't mean it doesn't, haha.  just that I've never used it.
06:07:31 <danderson> which is the preferred monad transformer package these days? Can't remember if it's mtl or transformers, or something else
06:07:36 <dankna> well, go ahead and hpaste your entire file.
06:07:42 <dankna> danderson: it's mtl, transformers is old.
06:08:06 <Jafet> Are you asking lazycat to hpaste, or me?
06:08:10 <dankna> you
06:08:17 <danderson> dankna: excellent, thanks.
06:08:22 <dankna> danderson: sure :)
06:08:40 <Jonno_FTW> ok I'm stuck again with merge:  http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=9633#a9635
06:08:59 <Jafet> Well, I don't think it would help. It's probably just ghci doesn't support it here
06:09:03 <Jafet> Thanks anyway
06:09:18 <dankna> Jafet: I disagree, I think it does support it, but your decision
06:09:45 * ManateeLazyCat Looks `newName` have some trick in TH.
06:10:05 <Jafet> It works if I make it a module, but that means I can't build it as a program
06:10:09 <Jafet> I'll just use it this way then
06:10:29 <dankna> Johnno: okay, so first off, merge is taking two parameters, so its pattern should be like "merge xs ys" or somesuch
06:10:48 <Jonno_FTW> yep
06:10:54 <dankna> you've got "merge xs" there
06:11:19 <Jonno_FTW> but what happens with merge?
06:11:23 <dankna> now, I take it you're stuck on how to actually implement this algorithm
06:11:28 <Jonno_FTW> yes
06:11:35 <dankna> I would do it recursively.  might not be the best way, but it's probably the easiest to understand.
06:11:36 <Jonno_FTW> i guess i just rejoin the sublists
06:11:37 <dankna> like so
06:12:02 <dankna> first case:  if you have a nonempty list for xs and an empty list for ys (use the pattern []), just return xs
06:12:10 <dankna> second case: if you have that reversed, just return ys
06:12:47 <Jonno_FTW> and then a case for both?
06:12:57 <dankna> well, actually I'm going to break that last case into two cases
06:12:58 <Jonno_FTW> non-empty lists that is
06:13:02 <dankna> with a guard
06:13:24 <dankna> if you have both lists nonempty the first item of xs is less than or equal to the first item of ys,
06:13:42 <dankna> return a list consisting of the first item of xs, followed by a recursive call to merge, with the rest of xs and the entirety of ys
06:14:09 <dankna> then the "otherwise" case returns a list with the first item of ys, followed by a recursive call to merge, with the entirety of ys and the rest of xs
06:14:27 <dankna> you could do this by calling "head" in the guard, but an easier way is to write it like this:
06:15:09 <dankna> merge xs@(x:restX) ys@(y:restY) | x <= y = x : (merge restX ys)
06:15:32 <dankna> this is nice and short, but it uses two or arguably three features that you probably haven't seen before, right?
06:15:51 <Jonno_FTW> i know of : and @ and |
06:15:57 <dankna> okay
06:16:13 <Jonno_FTW> @ is pretty handy
06:16:16 <dankna> yeah it really is
06:16:33 <dankna> so is that definition clear to you, or you need something explained in it?
06:16:50 <dankna> and then you'll want to write | otherwise = y : (merge xs restY)
06:16:57 <Spockz> is anyone familiar with the cuda-0.1 package on haskell? I'm trying to install it on Snow Leopard, but I can't find where I should point cabal to for the cuda libraries. (I installed the drivers and the developers toolkit...)
06:17:07 <dankna> and the two base cases with empty ys and empty xs
06:17:14 <dankna> Spockz: sorry - never tried it.
06:17:29 <Spockz> dankna: too bad :(
06:18:06 <dankna> Spockz: find where the file libcuda.a was installed by the dev toolkit.  if it's in the directory /usr/local/nvidai/lib/, add -L/usr/local/nvidia/lib/ to your command line.
06:18:22 <dankna> Spockz: check the readme that came with the dev toolkit, if any, for help with finding hat
06:18:26 <dankna> *that
06:18:41 <Spockz> dankna: how did you know I should look for libcuda.a? :P
06:18:53 <chrisdone> I hope gwern likes coding standards 'cause I just formatted all of mueval according to tibbe's guide
06:18:56 <dankna> Spockz: it was a lucky guess.  libraries usually follow that naming scheme.  it could be wrong.
06:19:07 <dankna> chrisdone: haha, awesome
06:19:32 <chrisdone> :p I need my 80 columns for split code view
06:19:54 <dankna> yeah, I actually was working in 90 columns without realizing it for practically a year
06:20:01 <dankna> now I want to make it really 80 columns
06:20:08 <dankna> but I can't because I still need to work with that code :(
06:20:17 <dankna> an automatic reindenter that doesn't break my code would be nice :(
06:20:21 <chrisdone> hehe
06:20:28 * chrisdone is an automatic reindenter
06:20:31 <dankna> hehe
06:20:35 <dankna> I see!
06:21:03 <dankna> Spockz: it could also be libcuda.dylib btw
06:21:08 <chrisdone> i'm using column-marker minor-mode to show when code goes past 80 cols
06:21:13 <dankna> oh, good idea!
06:21:22 <dankna> can I configure that to work in all buffers?
06:21:30 <Jafet> Word-wrap!
06:21:38 <dankna> well, not "can I" but "how can I", haha.  this being Emacs.
06:21:41 <chrisdone> dankna: yeah there is a global mode. personally I have it setup specifically for haskell mode
06:21:54 <dankna> chrisdone: hmmmmmm
06:22:02 <chrisdone> http://www.emacswiki.org/emacs/ColumnMarker
06:22:04 <Jonno_FTW> many thanks dankna
06:22:13 <Spockz> dankna: libcuda_r195_96.dylib << I have those, but if I point to that folder I still get the same error
06:22:30 <dankna> Jonno: very welcome!
06:22:36 <dankna> chrisdone: thanks!
06:22:39 <Jonno_FTW> except it returned an incorrect result
06:22:43 <chrisdone> technically I *always* have split-view so I'm well practised in indenting tricks
06:22:45 <dankna> Jonno: show me
06:22:52 <Jonno_FTW> *Main> mergeSort [1,2,3,4,3,1]
06:22:53 <Jonno_FTW> [1,3,2,3,1,4]
06:22:54 <dankna> chrisdone: heh, yeah, I see
06:23:05 <dankna> Jonno: hmm.... hpaste the code again
06:23:08 <chrisdone> like:
06:23:08 <chrisdone> foo = do bar
06:23:08 <chrisdone>          mu
06:23:08 <chrisdone> you get more space if you write:
06:23:11 <chrisdone> foo = do
06:23:14 <chrisdone>   bar
06:23:17 <chrisdone>   mu
06:23:19 <dankna> chrisdone: yeah I like to do it that way
06:23:25 <Jonno_FTW> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=9633#a9636
06:23:25 <chrisdone> :)
06:23:40 <Jonno_FTW> this is way harder than binary search
06:23:55 <Jafet> You can't binary search a list
06:23:55 <dankna> Jonno: true, it is.  anyway I see your bug.  it's in order.
06:24:05 <dankna> well you can, but it's O(something big)
06:24:42 <Jonno_FTW> those are the 3 cases aren't they?
06:24:45 <Jafet> For one thing, lists are infinite
06:24:53 <Jafet> Er, can be
06:25:00 <dankna> those are indeed the three cases, your problem is that the definitions for the first two are wrong!
06:25:38 <Jonno_FTW> hmm
06:25:42 <Jonno_FTW> oh right
06:25:43 <dankna> Jafet: well.  I should say that you can binary search a finite list, yes.  but it isn't a true binary search because each step of the recursion will iterate through from the start again.
06:25:53 <Jonno_FTW> otherwise i would be sorting the other way
06:26:06 <dankna> Jonno: indeed
06:26:11 <Jonno_FTW> *Main> mergeSort [1,2,3,4,3,1]= [1,1,2,3,3,4]
06:26:17 <Jonno_FTW> all good now
06:26:19 <Jafet> You can 2,3-search a finger tree
06:26:19 <dankna> great!
06:26:21 <dankna> congrats!
06:26:34 <Jafet> Better check if it's stable
06:26:55 <Jafet> Probably need your own ord instance though, or pass a predicator
06:27:02 <dankna> Jafet: you just volunteered to explain what a stable sort is to him :)
06:27:20 * Jafet *whoosh* disappears
06:27:23 <dankna> haha
06:27:44 <Jonno_FTW> hmm
06:28:02 <stevenmarky> symmetric, transitive and something else
06:28:16 <dankna> colloquially, a stable sort is one that preserves the existing ordering if the comparison says two things are equal
06:28:32 <dankna> so if it finds two elements that are both 4, it would leave them in the same order, guaranteed
06:28:44 <Jonno_FTW> mine doesn't do that
06:28:54 <dankna> actually it does :) it's the third case of order
06:29:16 <Jonno_FTW> what if they appear at length/2 -1 and length/2 +1
06:29:17 <Spockz> dankna: ah now I get a header preprocessing errror :p
06:29:22 <dankna> I only know that a priori because I know the algorithm
06:29:39 <dankna> Spockz: the hackage page on cuda has the solution for that, http://hackage.haskell.org/package/cuda
06:30:15 <dankna> Jonno: oh you're right inasmuch as it's not trivial to know that that works
06:30:19 <Spockz> dankna: I'm using that: cabal install cuda-0.1 --c2hs-option=-ccpp-4.0 --extra-lib-dirs=/usr/local/cuda/lib
06:30:32 <Jonno_FTW> could i add in a case somewhere to preserve such ordering?
06:30:46 <Jonno_FTW> or wouldn't it matter?
06:30:54 <Spockz> dankna: it's compiling!
06:31:17 <dankna> Jonno: well, why don't you - as an additional learning exercise - devise a way to test whether your sort is stable?
06:31:42 <dankna> I am pretty sure you would only have to change some small detail to make it stable, if it's not already, which there's a decent chance that it is
06:31:50 <dankna> Spockz: good.  what was the problem?
06:32:08 <Spockz> I needed to add the `include' dir of cuda :)
06:32:13 <dankna> Spockz: ah :)
06:32:34 <Spockz> now I still have to find out how to use it :D
06:32:37 <dankna> indeed
06:32:48 <Spockz> there is no documentation strangely
06:33:15 <dankna> that's not strange for open-source, sadly
06:33:33 <dankna> but you can get autogenerated documentation by running cabal haddock
06:33:39 <dankna> and then looking in dist/doc/html/
06:33:59 <Spockz> dankna: yes, but I'm surprised it isn't in hackagedb
06:33:59 <Jafet> Don't think cuda is open source
06:34:15 <Spockz> Jafet: this is about the cuda package on hackage
06:34:17 <dankna> Jafet: yeah but the binding to it is
06:34:36 <dankna> Spockz: it's not there because it doesn't build on the Hackage server, because the foreign library on which it depends isn't installed there
06:34:45 <Jafet> Oh. Yeah, you just have to stare at the type signatures until you figure it out
06:34:53 <Jafet> For most hackage packages
06:34:59 <Ke> there is an opensource implementation of cuda
06:35:11 <Ke> but most people should want opencl
06:36:24 <Spockz> well if I can easily run haskell code on my gfx card I'm not entirely biased to one technique or another
06:37:22 <Ke> is there something that allows for _haskell_ on gpu?
06:37:38 <dankna> I don't believe there is - there would have to be a backend
06:37:43 <mxc> anyone mind a stupid question about withMVar
06:37:54 <dankna> it would be possible in principle, say by implementing STG on top of whatever language it uses
06:37:57 <dankna> mxc: go for it
06:38:13 <Spockz> Ke: I read something about something that is being developed at chalmers
06:38:18 <Jafet> You could use a different prelude which doesn't need much of a runtime
06:38:31 <mxc> say i have some arbitrary monad stack - StateT (ReaderT IO) .. or whatever
06:38:39 <Jafet> Prelude needs way too much runtime support and most of it doesn't make sense on a GPU
06:38:53 <Spockz> Ke: it's called obsidian
06:39:02 <mxc> is there an easy way to run that kind of action inside wihtMVar or does it need to be unwrapped, like withMVar (runStateT (runReaderT blah env) state)
06:39:30 <Spockz> http://www.cse.chalmers.se/~joels/writing/dccpaper_obsidian.pdf
06:40:56 <dankna> mxc: it needs to be unwrapped and then rewraped
06:40:59 <dankna> *rewrapped
06:41:14 <dankna> mxc: there's no general way to do it because not all monads CAN be rewrapped in that way
06:42:22 <dankna> mxc: I don't know whether this is good style or not, but the approach I use to that problem is to define a pair of helper functions:
06:42:34 <mxc> looking at the source code though, if i just copied it word for word, but replaced the type signature with withMVar :: (MonadIO m) => MVar a -> (a -> m b) -> m b and stuck in some liftIO's shoudl work
06:43:03 <dankna> suspendMyMonad :: m (some tuple)
06:43:23 <dankna> resumeMyMonad :: (some tuple) -> m a -> IO a
06:43:29 <Ke> Spockz: yup we had something about that at one seminar
06:43:29 <chrisdone> Eelis: I like github too :-)
06:43:51 <dankna> mxc: what you're suggesting may very well work as well, but is less general
06:44:01 <mxc> dankna - only problem is htat i'm trying not repeat a previous mistake and I want to keep my functions as general as possible
06:44:05 <dankna> mxc: but it might be right for you, depending.  have to make a style call.
06:44:07 <gwern> interesting. modafinil prices are rising
06:44:25 <gwern> of the 4 or 5 online sellers I track, half have increased in price, and none decreased
06:44:26 <dankna> gwern: :( :( :(
06:44:32 <gwern> maybe it's the media coverage
06:44:34 <chrisdone> gwern: !
06:44:41 <dankna> gwern: damn, that sucks.  speaking as someone whose quality of life depends on Provigil/Modafinil.
06:44:45 <gwern> chrisdone: ?
06:44:54 <mxc> like instead of foo :: ReaderT Env (IO ()) i'd rather have foo :: (MonadReader Env m, MonadIO m) => m ()
06:44:55 <chrisdone> gwern: ...
06:44:59 <dankna> gwern: and whose insurance doesn't cover it :(
06:45:03 <gwern> dankna: well, I'm sure you have a nice legal prescription...
06:45:10 <mxc> dankna - how is it?  side effects?
06:45:10 <dankna> I do, but my insurance doesn't cover it
06:45:14 <chrisdone> gwern: haha, erm, if I reformatted mueval to use tibbe's guide, would you accept the patches?
06:45:18 <dankna> never noticed even the slightest side effects
06:45:19 <dankna> it's great
06:45:37 <Jafet> "Modafinil [...] is an analeptic drug [...] for the treatment of narcolepsy, shift work sleep disorder, and excessive daytime sleepiness associated with obstructive sleep apnea."
06:45:38 <dankna> it works on the nervous system instead of the muscles, so it doesn't make you twitchy, which is a common side-effect of other stimulants
06:45:43 <gwern> dankna: although I suppose nuvigil might push up prescription prices
06:45:44 <Jafet> I didn't know those were considered illnesses
06:45:59 <mxc> dankna i've heard that, but it wreaks of "too good to be true"
06:46:14 <dankna> yes, I have excessive daytime sleepiness.  to the point that it interferes with my ability to have a job at all.  Provigil makes it much much better.
06:46:34 <gwern> mxc: the real downside is that it's not too easy to get legally or at all, and many people build up tolerance
06:46:36 <Jafet> So I need to take some of this to get a job? Scary
06:46:46 <dankna> it's not supposed to be tolerance-forming
06:47:02 <gwern> dankna: it's not supposed to be, but it is
06:47:06 <dankna> at least not to any greater extent than, say, coffee
06:47:16 <dankna> gwern: I'd love to see an actual study to that effect if you have a citation
06:47:23 <gwern> well, caffeine builds up pretty severe tolerance
06:47:32 <dankna> well, yes
06:47:37 <dankna> but that doesn't mean we shouldn't use it
06:47:46 <gwern> dankna: all the citations are the opposite way, but I know what my personal experience says
06:48:06 <dankna> but yes =p it's legal to buy whatever drugs you want as long as you have a prescription for them.  even if your insurance doesn't cover them.  I'm covered legally.
06:48:20 <gwern> dankna: I do like the theory that the tolerance is caused by the long half-life of modafinil combined with a U-response curve; if I get more I'll try out that theory
06:48:25 <dankna> hmmmmmm
06:48:29 <dankna> that's an interesting thought
06:48:47 <chrisdone> gwern D:
06:48:56 <dankna> the long half-life is great, it stays in me all day.  I can feel when it wears off, heh.
06:49:02 <gwern> chrisdone: I have no idea what your reformatting request means
06:49:06 <dankna> I've been on 200mg a day for about two years.
06:49:30 <chrisdone> gwern: http://github.com/tibbe/haskell-style-guide
06:49:40 <gwern> dankna: where do you get yours? there are so many suppliers online
06:49:53 <dankna> gwern: from my local CVS, heh
06:50:04 <gwern> >.<
06:50:13 <dankna> gwern: I don't trust online suppliers - I believe most of them sell counterfeit drugs
06:50:18 <gwern> (sometimes I envy those with prescriptions)
06:50:22 <dankna> aw :(
06:50:32 <dankna> I'm sure you could find a general practitioner to prescribe it for you :(
06:50:46 <gwern> dankna: I can't speak to most, but I think there are a few trustworthy sellers
06:50:52 <dankna> that might be
06:51:01 <dankna> since I don't have to go into that world, I prefer not to
06:51:02 <gwern> enough people with prescriptions buy from the big sellers and can compare
06:51:08 <dankna> *nod* I can see how that could be
06:52:49 <gwern> chrisdone: can't say I really like the export list format
06:53:23 <chrisdone> gwern: that's just standard haddock
06:54:12 <gwern> dankna: here's what I have so far: http://community.haskell.org/~gwern/wiki/Modafinil.page
06:56:00 <mercury^> gwern: you are on modafinil?
06:56:28 <Ke> heh reading that text made me think I'm on modafinil
06:56:41 <Ke> that's some hypochondria
06:57:18 <dankna> Ke: indeed
06:57:35 <dankna> gwern: hmm.  how hard have you tried to get a prescription?
06:59:49 <OOOOaaah> dons?
07:10:45 <paulvisschers> I've been looking into HaskellDB, but can't really find a suitable recent example anywhere, does anyone here know one?
07:12:40 <dankna> no.  I got so frustrated with it that I wrote my own low-level binding instead :(
07:13:35 <paulvisschers> dankna: Yeah me too, but this time it's for a project for my thesis, so I can't simply say fuck it :)
07:13:48 <dankna> oh :)
07:14:46 * danderson implements action at a distance with ReaderT IO and MVars, muahahahah
07:15:19 <paulvisschers> I actually need to understand the inner workings at least partly this time, so lucky me
07:15:26 <dankna> yeah... good luck with it
07:15:38 <danderson> although it does feel slightly wrong, I don't really see a better way of sharing updatable data between many threads. Any better ideas?
07:16:01 <sioraiocht> dankna: IORef?
07:16:06 <sioraiocht> danderson: ^
07:16:17 <danderson> sioraiocht: why IORef rather than MVar?
07:16:35 <dankna> I think it's pretty reasonable
07:17:05 <paulvisschers> still it's a cool project, going to make a monad for optimistic locking on databases
07:17:40 <dankna> yeah that does sound cool
07:17:49 <sioraiocht> danderson: I'm not sure what the differences are, tibbe prefers IORefs for certain situations, though
07:18:02 <dankna> the differences are simple: IORefs aren't thread-safe
07:18:05 <Twey> IORefs are faster but not threadsafe
07:18:20 <dankna> since he really does have multiple threads, he really does need MVars
07:18:21 <sioraiocht> Twey, danderson, but you can use atomicModifyIORef
07:19:01 <sioraiocht> danderson: the synchonisation in MVar is more general, you can implement more complicated concurrency
07:20:02 <sioraiocht> so I suppose it owud depend on your usage
07:20:26 <danderson> sioraiocht: my question is more on how atomicModifyIORef is implemented
07:20:42 <sioraiocht> I have *no* idea
07:20:43 <danderson> is it implemented in terms of CPU primitives that loops on a CAS, or does it use proper locking?
07:21:00 <sioraiocht> AFAIK, there is no looping
07:21:13 <dankna> you can check the source easily
07:21:17 <dankna> it's on hackage I'm sure
07:21:50 <danderson> yeah, but the implementation delves deep into GHC internals
07:22:04 <danderson> atomicModifyIORef (IORef (STRef r#)) f = IO $ \s -> atomicModifyMutVar# r# f s
07:22:09 <danderson> I have no idea how to parse that :)
07:22:16 <dankna> hm
07:22:22 <sioraiocht> danderson: again, iirc, tibbe told me there was no looping in the implementation
07:22:24 <dankna> that's a primop I guess
07:22:28 <paulvisschers> danderson: I had a similar problem when looking at STM
07:22:34 <sioraiocht> danderson: r# is a machine level variable
07:22:39 <danderson> sioraiocht: sounds good then, I'll go with IORef instead of MVar.
07:22:41 <sioraiocht> danderson: STRef is a reference in the ST rather than IO monad
07:22:52 <danderson> I actually don't need more than a consistent read and atomic write.
07:23:00 <sioraiocht> I believe IORef is the answer, for that
07:23:36 <danderson> and I'd like it to be efficient (ie. based on real locking, not a lock-free loop), because I'm considering hitting the update from many threads
07:24:05 <danderson> right now, only one thread modifies the data, all others just read it. I'm pretty sure IORef is perfect for that case, but not sure what happens when N threads both read and write the IORef.
07:24:06 <sioraiocht> you cn always benchmark it, but I suspect IORef does what you want
07:24:18 <danderson> yeah, I guess I'll throw it under a profiler and see what happens.
07:24:21 <danderson> Thanks for the wisdom
07:24:35 <sioraiocht> np
07:25:44 <paulvisschers> So does anyone have working source code using haskelldb?
07:26:04 <paulvisschers> I thought I'd check out the darcs repos, but it doesn't seem to actually exist
07:26:15 <dankna> not I
07:27:34 <Axman6> danderson: MVars are very fast, and you should look into using them. they can give you the guarantees you want, with very high performance
07:28:04 * Eelis discovers in horror that Data.List.intersect is not commutative!
07:28:23 <sungji> hi. assume a binary tree, where an Int is stored in the nodes. now what does [x | Node x _ _ <- tree]    return?   (tree :: Tree a)
07:28:36 <mauke> a list
07:28:40 <xerox> [a]
07:28:51 <sungji> xerox: 100 pts, mauke: 50pts
07:28:54 <mauke> well, it doesn't typecheck
07:29:02 <Axman6> [Int]
07:29:16 <xerox> the code is fine
07:29:25 <mauke> I disagree
07:29:36 <Axman6> not really, it assumes that tree is a list of Tree Int
07:29:41 <Axman6> which, i'm guessing it isn't5
07:29:44 <Axman6> -5
07:29:48 <mauke> (tree :: Tree a)
07:29:56 <xerox> do {Â Node x _ _ <- tree; return x }
07:30:21 <Axman6> in this case tree has to be a list of trees though, since its a list comprehension
07:30:23 <xerox> na. it doesn't typecheck, I give back my points
07:30:25 <sungji> unfortunately, list comprehension with data types other than another list as a "datasource" is kinda new to me... it looks like as if the data is filtered somehow, such that leafs aren't in the list....
07:30:37 <mauke> sungji: it's not possible
07:30:41 <Axman6> sungji: you can't do it
07:30:43 <mauke> only lists can be sources
07:30:56 <Axman6> quit stealing my advice!
07:30:57 <Axman6> :P
07:31:01 <sungji> hmmm
07:31:42 <Axman6> you'll need to write your own function
07:32:07 <sungji> breadthfirsttraversal tree = [ x | Node x _ _ <- tree ] ++ [ t | Node _ l r, t <- [l,r]]
07:32:35 <sungji> how's 'tree' handled here, in the list comprehension?
07:32:48 <Axman6> tree needs to be a list
07:32:52 <Axman6> it can't be a Tree
07:33:03 <mauke> sungji: that doesn't compile
07:33:07 <jlouis> view types :)
07:33:21 <Axman6> vals :: Tree a -> [a]; vals (Node x l r) = vals l ++ x:vals r; vals (Leaf x) = [x];
07:33:34 <jlouis> oh, you are in effect building a view type!
07:33:37 <Axman6> or, you can change the order around if you like
07:33:41 <jlouis> carry on :)
07:34:43 <sungji> breadthfirsttraversal [tree] = [ x | Node x _ _ <- [tree] ] ++ [ t | Node _ l r <- [tree], t <- [l,r]]
07:34:45 <sungji> does that work?
07:35:09 <Axman6> it's not recursive
07:35:14 <Axman6> so, it won't do what you want
07:36:00 <gwern> dankna: I haven't tried very hard. I don't like lying to doctors
07:36:46 <Axman6> bfs x = bfs' x []; bfs' (Node x l r) xs = x : (bfs' l (bfs r xs)); bfs' (Leaf x) xs = x:xs
07:36:54 <Axman6> something like that will work quite efficiently
07:38:39 <dankna> gwern: I don't understand why it would be a lie.  "I have sleep problems and I heard good things about this medication" is presumably true or you wouldn't be taking it in the first place.
07:38:58 <gwern> I don't have sleep problems, though
07:39:13 <dankna> you just like the feeling of alertness it gives you?
07:39:15 <gwern> (or if I did, the melatonin takes care of them)
07:39:18 <dankna> (ah)
07:39:42 <xerox> warm milk
07:39:45 <Axman6> @src Tree
07:39:46 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
07:39:51 <Axman6> @hoogle Tree
07:39:51 <lambdabot> module Data.Graph.Inductive.Tree
07:39:51 <lambdabot> module Data.Tree
07:39:52 <lambdabot> Data.Tree data Tree a
07:40:04 <Axman6> :t Node 1 []
07:40:05 <lambdabot> forall t. (Num t) => Tree t
07:40:08 <Axman6> -
07:40:11 <xerox> +
07:40:12 <Axman6> -_-
07:40:15 <jlouis> Axman6: btw, have you seen teh awezome in combinatorrent? We have much better heap properties now. Not splendid, but not bad either
07:40:44 <Axman6> I haven't no, been far too busy lately with uni (I haven't actually written any haskell in months :'(
07:40:59 <jlouis> See, uni is a waste of time
07:41:30 <jlouis> I still haven't gotten around to actually start my thesis
07:41:40 <jlouis> realsoonnow(tm)
07:42:12 <dankna> *sigh* I wish I had a thesis :)
07:42:32 <Axman6> let bfs x = bfs' x []; bfs' (Node x bs) xs = x : foldr bfs' xs bs; bfs' (Leaf x) xs = x:xs in bfs (Node 1 [Node 2 [Node 3[],Node 4 []],Node 5 []])
07:42:36 <Axman6> > let bfs x = bfs' x []; bfs' (Node x bs) xs = x : foldr bfs' xs bs; bfs' (Leaf x) xs = x:xs in bfs (Node 1 [Node 2 [Node 3[],Node 4 []],Node 5 []])
07:42:37 <lambdabot>   Not in scope: data constructor `Leaf'
07:42:54 <danderson> Axman6: what of IORefs then?
07:42:54 <Axman6> > let bfs x = bfs' x []; bfs' (Node x bs) xs = x : foldr bfs' xs bs in bfs (Node 1 [Node 2 [Node 3[],Node 4 []],Node 5 []])
07:42:55 <lambdabot>   [1,2,3,4,5]
07:43:05 <Axman6> danderson: forget them
07:43:14 <danderson> I'm not at all clear on the differences between the two, and why I should prefer one over the other.
07:43:30 <danderson> it seems MVars offer a few more high level operations (which I don't need), and other than that they're two solutions for the same problem
07:43:57 <Axman6> MVars have the nice property that if one thread tries to read from an empry MVar, the RTS puts it to sleep, until it is filled again, which gives very good concurrent performance
07:44:22 <Axman6> basically, IORefs aren't considered safe at all, but MVars can be
07:44:35 <Axman6> and there's little, if any performance loss with them
07:44:48 <roconnor> what' unsafe about IORefs?
07:45:25 <danderson> thing is, the MVar wouldn't actually be empty for any large amount of time. I'd be using them as a mutex around a storage location.
07:45:53 <danderson> the semantics of atomicModifyIORef appear to be exactly what I want: don't prevent other threads from reading the old IORef while the update is in progress, but atomically swap the old and new values.
07:45:54 <Axman6> that's ok too
07:46:39 <Axman6> hmm, wtf happened here? http://shootout.alioth.debian.org/u32/benchmark.php?test=threadring&lang=all Haskell used to be the fastest, and was faster than that listed there
07:46:39 <danderson> (note that I'm not defending my use of IORef, I'm just trying to understand the differences)
07:47:37 <c_wraith> danderson: just note that atomicModifyIORef has bad performance under attempted concurrent update
07:48:05 <danderson> c_wraith: so, it does implement a loop around a CAS attempt?
07:48:33 <c_wraith> danderson: I'm not sure of the actual implementation, but that matches the performance characteristics I saw in testing
07:48:40 <danderson> I see.
07:48:43 <sioraiocht> hrm
07:48:50 <sioraiocht> I think you're going to have to test this for us, danderson ;)
07:48:53 <danderson> okay, that would be a good reason to not use IORef :)
07:49:23 <danderson> in any case, once I've implemented my transformer stack, it should be trivial to swap IORef and MVars around and see what happens.
07:50:20 * Axman6 would never use IORefs when he could use MVars
07:50:42 <danderson> I understood that, what I don't understand is why :P
07:50:52 <Axman6> because they're damn fast
07:51:00 <danderson> aside from IORefs being fairly low level compared to MVars, in the abstraction stack
07:51:00 <Axman6> they have much better safety properties
07:51:05 <mauke> wtf?
07:51:08 <Axman6> MVars are low level too
07:51:19 <mauke> MVars also have completely different semantics
07:51:38 <Axman6> semantics which make more sense in a concurrent environment
07:51:42 <danderson> I don't see the difference in safety
07:51:53 <mauke> AFAIK IORefs are completely unsafe
07:52:00 <danderson> I do see how, depending on how IORef is implemented, MVars would have better performance
07:52:13 <c_wraith> mauke, atomicModifyIORef is safe.
07:52:25 <Axman6> ecause the RTS knows more about MVars usage, and will schedule threads based on how they are used
07:52:26 <mxc> as long as there is only one IORef
07:52:35 <mxc> the account transfer problem needs mvars
07:52:41 <mxc> (or STM or something else, but not IORefs)
07:52:47 <c_wraith> mxc: that holds with mvar, too.  if there are multiples, mvar doesn't do the job
07:52:55 <Axman6> yes it does
07:52:58 <danderson> mxc: yeah, but I need a loosely coupled updatable data object
07:53:04 <danderson> I don't need safe combination
07:53:06 <Axman6> you take the values out, change them, and place them back
07:53:09 <mxc> c_wraith - yes it does,  it just might deadlock
07:53:14 <c_wraith> Axman6: that can deadlock
07:53:30 <rubendg> I'm using gtk2hs with multiple window definitions inside a .glade file. When the app starts though it only shows one window. When a button is clicked in the main window it pops up one of the other windows (widgetShowAll). Though after disposing the window and hitting the button again it does show the other window but without all its widgets...  Any ideas on how to overcome this problem? thanks
07:53:35 <Axman6> sure, but it does solve the atomicity issue
07:53:59 <danderson> anyway, I'll go with MVars, and once I've actually fixed my ugly code, I'll swap them for IORefs and see how performance changes in my (specific, slightly unusual) case.
07:54:10 <mxc> i have this problem that withMVar can't work with an aribtary transformer stack wihtout wrapping and unwrappng
07:55:05 <Axman6> and, sleep time. night all
07:55:11 <danderson> to be more specific about what I'm trying to accomplish: I have a routing table, which many threads need to consult.
07:55:23 <danderson> One thread infrequently regenerates a new, different routing table
07:55:31 <danderson> and needs to be able to propagate that new table to the readers
07:55:32 <mxc> the main problem is that block doesn't work with a stack
07:55:58 <mauke> STACKENBLOCKEN
07:56:11 <danderson> under that scenario, an IORef that is read by many threads and atomically mutated by one, would seem to work fine. As would an MVar with the APIs whose names I don't recall.
07:56:14 <c_wraith> danderson: if you don't have conflicting writes, atomicModifyIORef is probably better.
07:56:26 <c_wraith> but yeah, test the alternatives :)
07:56:28 <danderson> I agree that MVars are more versatile and safe in the general case, but it seems I don't need that here.
07:56:50 <danderson> anyway, yeah, back to coding.
07:56:57 <mxc> there's also STM
07:57:36 <mxc> which has even more overhead, but i've heard that where the threads wont generally block,the optimistic assumption of STM can save a lot vs the pessmisim of MVars
07:57:38 <c_wraith> I'm sort of disillusioned with STM.  It's a beautiful model, but the use case it's actually good for is very limted.
07:58:17 <danderson> I started out with STM, but in my case deploying composable memory transactions is a little like swatting a fly with a tactical nuclear warhead
07:58:37 <c_wraith> Basically, it's good in the use case where there are many cells that might be updated, and you want to update small arbitrary subsets of them atomically.
07:59:03 <c_wraith> When there's write contention, it gets sad :(
07:59:40 <danderson> that's the whole selling point iirc: "yeah, it sucks on write contention, but in practice programs don't have that much contention anyway"
08:00:10 <c_wraith> except, for many common cases, the *only* concurrent access is something like "every request should update this field" or something
08:00:47 <c_wraith> and in those cases, you only have contention
08:01:25 <danderson> yup, STM is not a good pick for those.
08:04:07 <mxc> its a shame that MTL or Transformers isn't standardized
08:04:32 <mxc> i feel like a lot of the base libraries that have IO types really only need MonadIO m => m...
08:06:33 <mxc> like my withMVar problem
08:14:39 <ManateeLazyCat> aavogt: I have use TH replace my code, works perfect. Thanks for your help!
08:15:11 * ManateeLazyCat pasted "TH code." at http://paste2.org/get/766731
08:15:11 <ManateeLazyCat> aavogt: Above is my TH code.
08:15:34 <ManateeLazyCat> Now TH generate all function for me, and don't care how i change datatype.
08:16:38 <xcvii> hey folks, what's an easy way to generate all the sequences with given length over a finite set? this is for project euler, so a single pointer would be great (:
08:17:09 <ManateeLazyCat> aavogt: For communication with DBus, all message is check/pack/unpack automatically, always safe, and don't need write any duplicate code, so sweet. :)
08:17:14 <mauke> > replicateM 3 "abc"
08:17:15 <lambdabot>   ["aaa","aab","aac","aba","abb","abc","aca","acb","acc","baa","bab","bac","b...
08:17:41 <xcvii> whoa cheers
08:17:59 <ManateeLazyCat> xcvii: Cool ah?
08:19:01 <xcvii> yeah (: i was pretty sure there was a ...M function for that
08:19:18 <mauke> @hoogle Int -> [a] -> [[a]]
08:19:19 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
08:19:19 <lambdabot> Prelude drop :: Int -> [a] -> [a]
08:19:19 <lambdabot> Prelude take :: Int -> [a] -> [a]
08:20:33 <stevenmarky> trying to get GD image module working on windows is a pain, is there an easymode installer?
08:21:40 <Eelis> is there still no way to share fields like build-depends and ghc-options between multiple sections in a .cabal file? i'm getting really tired of maintaining 4 duplicate lists..
08:22:44 * ManateeLazyCat TH is cool for maintainer for big project, even TH's syntax not readable.
08:23:43 <dantheman_> Can anyone explain to me how the io monad gives referential transparency? So, say I have a function to read a file:  readFile :: String -> IO String  readFile filename = ...  At time t1, if I invoke it it returns say:  IO "Contents at t1"  At time t2, if I invoke it it returns say:  IO "Contents at t2"  Given that we supplied the function with the same argument (i.e. fname), and it returns two different values, how can they be
08:24:15 <mauke> dantheman_: no, it returns the same value each time
08:24:26 <mauke> there is no IO "contents"
08:25:29 <SamB_XP> nor are there beans or an astronaut
08:26:11 <mauke> something of type IO String is an action that (when run) produces a String
08:26:16 <Jafet> main = let a = putStrLn "a" in a >> a >> a
08:26:16 <roconnor> dantheman_: you should be aware of the difference between evaluation and execution of an IO a
08:26:33 <Jafet> There should be a magical Eq instance for IO
08:26:59 <c_wraith> that would be magical.  doing it properly is turing-complete :)
08:27:03 <SamB_XP> Jafet: halting problem ;-P
08:27:36 <dantheman_> So, is my readFile function similar to a function readFile :: String -> ImplicitInvocationTime -> String ?
08:27:45 <mauke> dantheman_: no
08:27:47 <Jafet> Bottoms.
08:28:06 <c_wraith> Jafet: so it's ok for it to not terminate on all input?
08:28:33 <danderson> dantheman_: if you want it to be similar to something, you could see it as String -> (Universe -> String)
08:28:35 <Jafet> Sure
08:28:37 <dantheman_> so that different calls acan be differentiated by their time of invocation (and hence the value they return)?
08:28:49 <dantheman_> hmmm.
08:28:50 <danderson> that is, readFile returns an action which, when given the current state of the universe, produces a string
08:28:53 <mauke> dantheman_: readFile doesn't care when it was called
08:29:04 <mauke> it always returns the same action
08:29:16 <danderson> the IO monad just hides away that Universe thing
08:29:26 <danderson> sorry, that's actually wrong
08:29:33 <dantheman_> So what is the difference between the evaluation and the execution of an IO a?
08:29:34 <danderson> String -> (Universe -> (String, Universe))
08:29:49 <mauke> I don't like that explanation because the universe is not actually being processed by my PC
08:29:57 <danderson> and IO action takes in the state of the universe, and produces a value along with a possibly changed universe
08:30:08 <SamB_XP> mauke: it's a fake universe ;-P
08:30:14 <SamB_XP> it's actually nothing at all
08:30:16 <danderson> mauke: it's a universe in a bottle.
08:30:17 <Jafet> The semantics of IO are explained well in the awkward squad paper
08:30:19 <mauke> SamB_XP: then how does it do real IO?
08:30:21 <danderson> a klein bottle.
08:30:21 <Vanadium> It is a scrap of paper with universe written on it
08:30:27 <stevenmarky> you can't extract a value from the universe without being in the universe
08:30:30 <SamB_XP> mauke: by breaking ALL of the rules
08:30:32 <stevenmarky> to 'extract' a value from an IO you have to be in an IO
08:30:35 <mauke> yeah, that explains nothing
08:30:36 <Jafet> http://kleinbottle.com
08:30:44 <mauke> dantheman_: http://mauke.ath.cx/stuff/haskell/how-to-io.html
08:31:14 <roconnor> dantheman_: one way is to think of IO a as having the value a program (perhaps think C program) than when executed by the runtime will do something.  So evaluation of an IO a will compute the source code.
08:31:24 <roconnor> not really the best way to look at it, but somewhat helpful
08:31:28 <danderson> dantheman_: if you are familiar with the State monad, which lets you combine functions that can read and write to a state, without having to explicitly manage the state
08:31:45 <danderson> the IO monad is equivalent, except that the state is the universe.
08:32:06 <mauke> danderson: how does that play with multithreading?
08:32:08 <Jafet> roconnor, "evaluation" in haskell means the reduction of expressions
08:32:12 <danderson> and thus, actions in the IO monad can do things like I/O, because that's interacting with the universe - which it has access to.
08:32:33 <danderson> mauke: in crazy, crazy ways.
08:32:46 <danderson> the universe metaphor only stretches so far :)
08:33:04 <danderson> in a multithreaded environment, the same universe gets modified concurrently by all threads
08:33:07 <Jafet> mauke, parallel universes!
08:33:20 <burp> multiverses
08:33:35 <danderson> which is why you need concurrency control primitives, to help the threads modify the same bits of the universe without ripping a hole in the fabric of space-time
08:33:36 * stevenmarky falls through the floor
08:33:44 <mauke> passing universes around is no better than spacesuits of apples in oceans
08:33:54 <danderson> mauke: but it's like burritos!
08:34:04 <dantheman_> Jesus. Talk about a can of worms!
08:34:39 <SamB_XP> dantheman_: huh, I don't recall hearing about THAT monad tutorial!
08:35:04 <Jafet> It's funny how monad tutorials become monadic IO tutorials
08:35:23 <Jafet> Unless you're saying I need lead gloves to process lists
08:35:57 <dantheman_> So if I understand correctly, both invocations of my readFile function above return a function that takes in the state of the universe, and returns a new state of the universe together with a string.
08:36:12 <dino-> I always liked the All About, which starts with Maybe monad and the sheep
08:36:24 <dino-> No IO
08:36:26 <dantheman_> So when talking about equality, I should be looking at the fact that the two FUNCTIONS returned are equal
08:36:50 <dantheman_> However, when they are executed, they may then return different values?
08:36:50 <Jafet> dantheman, you still don't grasp the dichotomy of evaluation and execution.
08:37:22 <danderson> My favorite monad tutorial is the one kmc ad-libbed here
08:37:47 <danderson> "A monad is like a giant, angry gorilla. The (>>=) operator is like a banana, except it's filled with nails. And the banana doesn't exist, it's only in your mind."
08:38:01 <stevenmarky> lol!
08:38:13 <roconnor> dantheman_: that sounds about right
08:38:42 <dantheman_> AHHA!
08:38:54 <dankna> hahahah
08:38:54 <dankna> nice one
08:39:25 <SamB_XP> "it is not the bananana which bends; it is only yourself"
08:39:38 <Jafet> @quote banana
08:39:38 <lambdabot> monochrom says: Time flies like an arrow.  Fruit flies like a banana.  Syntax rules like a macro.
08:39:43 <Jafet> @quote gorilla
08:39:44 <lambdabot> No quotes match. I am sorry.
08:40:10 <danderson> I don't think it was recorded at the time
08:40:31 <Jafet> I'm not actually sure if talking about equality makes sense. There isn't a definition for equality of IO's
08:41:15 <danderson> in the context of referential transparency, you can view the returned IO actions as equal, but yeah, you can't explicitly compare them
08:41:26 <danderson> that is, given the same input String, readFile will always return the same IO action
08:41:38 <danderson> which however may yield a different string each time it's executed
08:42:08 <Jafet> Maybe one could apply some bastardized notion of eta transformation
08:43:02 <stevenmarky> it will return a different input string because the universe has changed
08:43:02 <Jafet> The semantics of readFile cannot be expressed in the evaluation half of Haskell, at any rate
08:43:21 <Jafet> It fills sludge from the nearest spacesuit
08:43:28 <SamB_XP> stevenmarky: depends on how the universe has changed
08:43:35 <SamB_XP> it might be that that file hasn't!
08:43:38 <maltem> Two IO values are equal if their World -> World representations equal? Sounds good to me, you can't check this anyways
08:44:02 <maltem> *are equal
08:44:03 <SamB_XP> maltem: you forgot the "a"
08:44:18 <danderson> SamB_XP: ah, but the universe has still changed!
08:44:37 <danderson> the hard drive has had a little more wear and tear, the filesystem moved a bit, and so on
08:44:49 <danderson> even if the file doesn't change, the disk might have exploded after the file was read
08:45:09 <maltem> SamB_XP, yeah sloppy writing
08:45:34 <SamB_XP> maltem: I mean, the return value ;-)
08:45:44 <maltem> I know
08:46:00 <danderson> dantheman_: we're rambling on here, but is this making somewhat sense?
08:48:29 <FliPPeh> Changing universes? Exploding hard drives?
08:48:35 <FliPPeh> WHAT
08:48:45 <Jafet> A typical Haskell discussion.
08:48:55 <FliPPeh> Figured.
08:49:08 <Jafet> This must be why we get so many weird monadic IO blog tutorials
08:49:18 <danderson> what, you've never juggled universes in your haskell programs?
08:49:35 <SamB_XP> I wanna see the "can of worms" one that dantheman_ mentioned before
08:49:37 * Jafet writes a Haskell primer called "Thinking in Metaphors"
08:49:48 <FliPPeh> danderson: I usually handle multiverses. How much different are those to universes?
08:50:05 <SamB_XP> FliPPeh: they have more comic book characters in them ?
08:50:11 <FliPPeh> Ohhhh
08:50:29 <danderson> FliPPeh: not much, multiverses are one ListT away from universes, no?
08:50:46 <SamB_XP> danderson: as long as it's done right!
08:50:50 <deech> Hi all,
08:50:56 <orlandu63> what's the difference between Main.Nothing and Prelude.Nothing?
08:50:57 <FliPPeh> Hi deech
08:51:04 <FliPPeh> orlandu63: Nothing
08:51:08 <FliPPeh> no pun intended.
08:51:15 <danderson> yeah, right.
08:51:26 <maltem> Random question: How do IORefs behave in a multi-threaded program? Will readIORef block when a write is going on at the same time?
08:51:27 <FliPPeh> Alright, pun intended
08:51:28 <deech> Does anyone know of a way to import, say, Text.XML.HXT.*?
08:51:43 <orlandu63> what should i do if i'm getting an ambiguous-reference error concerning the two Nothings?
08:51:44 <FliPPeh> maltem: Probably not
08:51:56 <FliPPeh> maltem: Stuff it in a TChan or something
08:51:56 <pikhq> maltem: Probably not, don't do that, we've got MVars.
08:52:05 <danderson> maltem: readIORef just gives you the value, no blocking
08:52:07 <FliPPeh> orlandu63: Hide one of them
08:52:27 <FliPPeh> "import Prelude hiding (Nothing)"
08:52:30 <Jafet> orlandu, are you defining Nothing?
08:52:42 <orlandu63> FliPPeh: thank you
08:52:50 <FliPPeh> orlandu63: No problem
08:52:54 <orlandu63> Jafet: i'm not
08:52:55 <Twey> Heheh
08:52:56 <maltem> danderson, so basically, I can get a corrupted value and segfault if I use IORefs with multiple threads?
08:53:00 <Twey> hiding (Nothing)â¦ nice :Ã¾
08:53:02 <Twey> maltem: Yes
08:53:05 <Jafet> Then that's strange
08:53:08 <FliPPeh> Twey: hey, but it works :D
08:53:14 <danderson> maltem: if you use readIORef and atomicallyModifyIORef, you should be okay
08:53:27 <danderson> since the value of the IORef will atomically switch from valid value to valid value
08:53:31 <Twey> I'm surprised by atomicallyModifyIORef
08:53:39 <danderson> if you use writeIORef though, you're screwed.
08:53:59 <danderson> maltem: but, as per an earlier discussion, default to using MVars if you can
08:54:10 <maltem> ok, thanks guys
08:54:16 <danderson> they have completely safe semantics and comparable performance
08:54:39 <FliPPeh> I see Haskell everywhere already... a quick glance through my playlist reveals "Maybe Memories"...
08:54:57 <FliPPeh> Let's see if they have a song called "Nothing"...
08:54:58 <danderson> lovely way to implement amnesia
08:55:04 <Jafet> The Blow - Parentheses
08:55:57 <deech> There's a local St.Louis band called the Monads. All connection to Haskell is completely coincedental.
08:55:57 <FliPPeh> > printf "%.2f" 6.55443
08:55:57 <Jafet> Will this be a new pasttime? Looking for valid Haskell programs in pop lyrics?
08:55:58 <lambdabot>   Ambiguous type variable `a' in the constraints:
08:55:58 <lambdabot>    `Text.Printf.PrintfType ...
08:56:02 <FliPPeh> What!
08:56:15 <FliPPeh> > printf "%.2f" (6.55443 :: Double)
08:56:16 <lambdabot>   Ambiguous type variable `a' in the constraints:
08:56:16 <lambdabot>    `GHC.Show.Show a'
08:56:16 <lambdabot>      a...
08:56:16 <dankna> Simon and Garfunkel had a little-known song called "Occurs check: Unable to construct infinite type."
08:56:19 <FliPPeh> Why, oh why
08:56:34 <harlekin> > printf "%.2f" (6.55443 :: Double) :: String
08:56:35 <lambdabot>   "6.55"
08:56:39 <harlekin> > printf "%.2f" (6.55443 :: Double) :: IO String
08:56:39 <lambdabot>   <IO [Char]>
08:56:44 <jmcarthur> FliPPeh: i can be either string or io
08:56:47 <FliPPeh> IO printf?
08:56:48 <jmcarthur> *it can
08:56:58 <deech> dankna: must have been a B-side
08:57:03 <jmcarthur> as in it outputs it
08:57:04 <dankna> deech: haha, yes
08:57:09 <SamB_XP> > printf "%.2f" (6.55443 :: Double) :: IO ()
08:57:10 <lambdabot>   <IO ()>
08:57:16 <SamB_XP> > printf "%.2f" (6.55443 :: Double) :: IO Void
08:57:17 <lambdabot>   Not in scope: type constructor or class `Void'
08:58:03 <FliPPeh> printf "%.2f" (4.6 :: Double) :: IO String
08:58:03 <FliPPeh> 4.60"*** Exception: Prelude.undefined
08:58:03 <FliPPeh> What's happening here?
08:58:03 <FliPPeh> undefined?
08:58:30 <harlekin> > printf "%.2f" (4.60 :: Double) :: String
08:58:31 <lambdabot>   "4.60"
08:58:35 <harlekin> > printf "%.2f" (4.6 :: Double) :: String
08:58:36 <lambdabot>   "4.60"
08:58:47 <FliPPeh> In GHCI it blows up for IO
08:59:09 <maltem> danderson, I actually think that STM is best for my case, which is: one mutable variable per slave thread. A slave writes to its variable, the master reads all variables at regular intervals, but no synchronization is needed among the slaves. IIUC, STM gives me non-blocking reads
08:59:32 <dankna> maltem: also consider using Chans
08:59:53 <danderson> maltem: do the slaves also readback their vars?
09:00:03 <danderson> if not, yeah, Chans may be the droid you're looking for
09:00:11 <jmcarthur> MVars might even be enough
09:00:16 <jlouis> newtype R2D2Chan
09:00:21 <harlekin> FliPPeh, there's a nice exaple of printf using Template Haskell. You just have to write your own formatting function. I guess I'd go for that option if I was to be using printf.
09:00:23 <SamB_XP> danderson: can they make calls, too?
09:00:38 <orlandu63> whenever i import Data.Map, i get random linking errors which seem to be coming from the C intermediate code. what can be the cause of this? (i'm using ghc 6.12)
09:00:52 <maltem> danderson, they don't. Does a Chan only ever hold one value? (The name suggests otherwise)
09:00:55 <dankna> orlandu63: hpaste us some of the errors
09:00:56 <FliPPeh> harlekin: For my purpose it works just fine, I just want to print a double with a fixed amount of decimals :)
09:00:59 <danderson> maltem: the general rule I was given (by dons) is to avoid STM unless you really need the composability of transactions
09:01:18 <harlekin> FliPPeh, http://www.haskell.org/ghc/docs/6.10.1/html/users_guide/template-haskell.html (8.9.3)
09:01:21 <danderson> because the implementation is still not as fast as using MVars, which are very efficient
09:01:45 <dankna> maltem: a Chan can hold multiple values, but there are primitives for getting them all at once, so you can just do that and discard all but the last
09:01:59 <danderson> STM is good when you need to combine many atomic operations into larger atomic operations, such that using low level concurrency primitives becomes too hard
09:02:08 <orlandu63> dankna: hpaste isn't working at the moment, so: (.text+0x217): undefined reference to `__stginit_containerszm0zi3zi0zi0_DataziMap_'
09:02:20 <danderson> but if you're just doing atomic reads/writes on a single var, start with MVar
09:02:36 <danderson> and also investigate IORef afterwards, if MVar has unsatisfactory performance
09:02:42 <dankna> orlandu63: what program are you using to link?  you should be using ghc to link
09:03:28 <orlandu63> dankna: i believe i am. i am simply calling ghc ttt.hs
09:03:39 <dankna> orlandu63: hmmmmm..... try adding -package containers and see if that helps
09:03:56 <maltem> dankna, ok, but I'd rather not have mutliple values in the first place. danderson: Would it make sense to use (MVar a, MVar a) to get non-blocking reads?
09:04:07 <dankna> maltem: fair enough.  I think MVar makes sense for you then.
09:04:56 <danderson> maltem: unless a profiler shows that you're getting lock contention, start simple
09:05:01 <danderson> use a plain MVar and see how it goes
09:05:34 <danderson> it's equivalent in performance to a mutex-protected variable from other languages, which is more than fine in general
09:06:09 <danderson> (also, modern CPUs actually do optimistic locking internally, so even a "regular" mutex can be very fast on non-contended reads)
09:06:23 <maltem> if you all say so - I'll start with plain MVars then
09:06:24 <dankna> (did not know that)
09:07:02 <danderson> dankna: vague recollection says the Pentium 4 was the first to do that
09:07:08 <dankna> I see
09:07:17 <danderson> I'd have to dig out a citation though, memory is fuzzy
09:07:31 * dankna nods
09:11:39 * hackagebot MonadCatchIO-transformers 0.2.0.0 - Monad-transformer compatible version of the Control.Exception module  http://hackage.haskell.org/package/MonadCatchIO-transformers-0.2.0.0 (AriePeterson)
09:13:59 <EvanR> is there built in functions for integer square root?
09:14:29 <danderson> bah, google fails to provide a reference. I'll dig through my architecture books tonight.
09:14:34 <dankna> danderson: okay, cool.
09:18:08 <rubendg> I'm using gtk2hs with multiple window definitions inside a .glade file. When the app starts though it only shows one window. When a button is clicked in the main window it pops up one of the other windows (widgetShowAll). Though after disposing the window and hitting the button again it does show the other window but without all its widgets...  Any ideas on how to overcome this problem? thank
09:19:12 <dankna> I have no more answer now than I did several hours ago; I've never used gtk2hs, or, indeed, gtk.
09:20:30 <rubendg> maybe someone else has, how was not there several hours ago :)
09:22:18 <Phyx-> Does anyone know if haskell-src-exts supports literal haskell files?
09:26:29 <danderson> Anyone fancy a round of golf? How would I make getPeerState into a one-liner? http://haskell.pastebin.com/01QAnEfX
09:27:09 <dankna> ask >>= (liftIO . readIORef . _peerState), isn't it?
09:27:31 <BONUS> getPeerState = ask >>= liftIO . readIORef . peerState
09:27:34 <BONUS> beaten
09:27:36 <dankna> hehe
09:27:52 <danderson> oh, of course. Somehow brainfarted and didn't think of >>= to plug the ask into the rest.
09:27:55 <danderson> thanks.
09:27:56 <portnov> Q: anyone uses funcmp (http://hackage.haskell.org/package/funcmp-1.5) ?
09:28:31 <portnov> or any other way to generate Metapost sources from Haskell...
09:31:32 <Phyx-> is it possible to have types of kind # in class/instance declarations?
09:31:57 <SamB_XP> BONUS, dankna: eww! have an (=<<)!
09:32:21 <dankna> SamB: oh, yeah, good point
09:33:44 <Phyx-> oh well, looks like i'm 0 for 2 here today :P
09:38:17 * Phyx- taps the mic, is this thing on
09:38:31 <Botje> Phyx-: try dancing around a bit, i hear it improves reception
09:39:14 <dankna> ow!  my ears!  please don't do that :D
09:39:25 <EvanR> does an instance of monad have to have exactly one ... uhm... type parameter
09:39:30 <EvanR> m a
09:39:31 <dankna> EvanR: yes
09:39:34 <kamatsu> Phyx-: tapping microphones is bad for them, click your fingers near them instead
09:39:50 <EvanR> so if i cant figure out what that parameter is for, then im probably not thinking of a monad
09:39:51 * Phyx- does the lambada
09:39:57 <dankna> EvanR: that seems likely to me
09:40:14 <EvanR> guess i have to try harder ;)
09:40:16 <dankna> hee
09:40:24 <Phyx-> kamatsu: really?
09:40:45 <Phyx-> since there's a haskell song, is there a haskell dance?
09:41:37 <siracusa> Are pattern variables starting with an underscore handled specially by GHC?
09:41:46 <dankna> Phyx:  yes, it goes   <(-'.'-<) <(-'.'-)> (>-'.'-)>
09:41:50 <Twey> siracusa: No
09:42:06 <Twey> Only the underscore itself is an ignored wildcard match
09:42:19 <Twey> It can be reÃ¼sed
09:42:20 <Jafet> Only when they're just underscores
09:42:31 <Phyx-> <(-'.'-<) <(-'.'-)> (>-'.'-)> does anyone know if there's a way to allow unlifted types in class/instances? <(-'.'-<) <(-'.'-)> (>-'.'-)>
09:42:41 <dankna> hahahahaha
09:43:02 <Phyx-> seems ineffective dankna :P
09:43:12 <dankna> sorry.  if I knew, I would answer.  the dance definitely motivated me to pay attention.
09:43:20 <Phyx-> hahaha :P
09:43:54 <kamatsu> Phyx-: yep
09:44:04 <siracusa> Ok, I know about the wildcard pattern, I just thought it may suppress warnings or so.
09:44:16 <EvanR> dankna: so what is a typical use for this a in m a?
09:44:18 <kamatsu> (audio expert)
09:44:20 <Phyx-> kamatsu: is that a yep to the dance, or yep to the "is there a way"
09:44:23 <Phyx-> oh
09:44:25 <Phyx-> that yep
09:44:29 <kamatsu> lol
09:45:00 <dankna> EvanR: well, if the monad is a container type like List or Maybe, it's the thing that you have a list or maybe of.
09:45:25 <danderson> yay, I have a working monad transformer stack for my program's main
09:45:31 <dankna> EvanR: if it's a state type like Reader, Writer, or State, it's the thing that you have state of
09:45:38 <danderson> now, to rewrite Main.hs to use it, instead of passing 20 parameters around everywhere...
09:45:47 <dankna> EvanR: and now that you mention it I'm not totally sure that the answer to your original question is what I said.
09:45:49 <dankna> :k Monad
09:45:50 <lambdabot> Class `Monad' used as a type
09:45:55 <dankna> @src Monad
09:45:56 <lambdabot> class  Monad m  where
09:45:56 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
09:45:56 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
09:45:56 <lambdabot>     return      :: a -> m a
09:45:56 <lambdabot>     fail        :: String -> m a
09:45:59 * Phyx- goes to mail haskell cafe
09:46:05 <dankna> yeah, okay, it is
09:46:12 <SamB_XP> oh, what happened with that "real name" thread?
09:46:15 <EvanR> i am trying to model motions. a motion is a function of time and some condition for when to stop, it seems like i can combine these motions into bigger motions
09:46:20 <dankna> Sam: it Petered out
09:46:29 <dankna> (pardon the pun)
09:46:42 <SamB_XP> dankna: don't get the pun
09:46:53 <BONUS> EvanR: sounds like a monoid
09:46:56 <dankna> Peter is a name.  it was fairly lame.
09:47:05 <SamB_XP> I know peter is a name
09:47:12 <dankna> it's a thread about names.
09:47:18 <SamB_XP> oh
09:47:19 <dankna> but it stopped happening.
09:47:24 <EvanR> first i would expect to combine them so one happens after another stops, but also it would be cool if i could simply add the two motions together
09:47:24 <dankna> so it petered out.
09:47:27 <SamB_XP> I thought you might have been referring to a specific Peter
09:47:29 <EvanR> BONUS: monoid eh
09:47:30 <dankna> no, afraid not
09:47:40 <dankna> that would have been cleverer
09:47:59 <dankna> hmmm..... monoids.... I need to learn monoids
09:48:01 <BONUS> EvanR: yeah. mempty = no motion at all, mappend = one happens after the other
09:48:03 <SamB_XP> see, I give you credit for being cleverer than you are
09:48:06 <SamB_XP> monoids are easy!
09:48:17 <dankna> SamB: well, that's a good thing!
09:48:18 <SamB_XP> they have a 0 and a + -- or a 1 and a *
09:48:23 <EvanR> and im guessing that one another another, and add two motions can both be expressed using a well defined >>=
09:48:28 <SamB_XP> it all comes down to the same thing ;-)
09:48:35 <SamB_XP> it's just a matter of notation
09:48:37 <EvanR> BONUS: ok how about composing motions
09:48:39 <roconnor> you could have invented monoids
09:48:43 <dankna> is there do-notation for monoids?
09:48:53 <SamB_XP> nope
09:48:54 <BONUS> and they sound associative, it shouldn't matter if you do motion1 `mappend` (motion2 `mappend` motion3) or (motion1 `mappend` motion2) `mappend` motion3
09:48:55 <SamB_XP> @src Monoid
09:48:55 <lambdabot> class Monoid a where
09:48:56 <lambdabot>     mempty  :: a
09:48:56 <lambdabot>     mappend :: a -> a -> a
09:48:56 <lambdabot>     mconcat :: [a] -> a
09:49:01 <danderson> so, just to be sure I'm not missing anything... I have a monad transformer stack with IO at the bottom. I have no option but to wrap all `IO a` with liftIO to pull them up the stack, correct?
09:49:14 <BONUS> EvanR: composing would be mappend, just like mappend is composition on a -> a functions
09:49:18 <EvanR> monoid, good to know, i think thats what i was thinking of originally
09:49:22 <danderson> (assuming these are functions that return IO a, not (MonadIO m) => m a)
09:49:26 <roconnor> danderson: more or less. There are some fancy dangrous haskell class abuse that can help
09:49:27 <dankna> danderson: yes
09:49:31 <SamB_XP> hmm -- do we have any nice infix operators for mappend yet ?
09:49:53 <BONUS> SamB_XP: only in caleskell :[
09:49:58 <danderson> roconnor: where can I learn more about the dangerous stuff?
09:50:01 <danderson> dankna: thanks.
09:50:08 <roconnor> monadlib
09:50:08 <EvanR> BONUS: so mappend is to compose two motions, m1 + m2, mconcat is do one motion after another
09:50:12 <danderson> (not that I want to do dangerous stuff, I'm just curious)
09:50:14 <SamB_XP> BONUS: no nice cabbage for it yet ?
09:50:30 <Phyx-> does anyone know how come the "foreign" keyword is treated as a identifier? I thought it was a language keyword
09:50:35 <BONUS> EvanR: mconcat is [motion] -> motion, so it takes a list of motions and composes them
09:50:37 <SamB_XP> EvanR: mconcat is just many mappends
09:50:48 <dankna> why is mconcat its own method, then?
09:50:48 <SamB_XP> it's basically a fold
09:50:54 <EvanR> got it, monoid
09:50:54 <dankna> couldn't it be defined with foldl?
09:50:55 <BONUS> by default it's just foldr mappend mempty xs
09:51:14 <dankna> ah - foldr instead of foldl because laziness?
09:51:25 <BONUS> dankna: because of efficiency reasons, sometimes there's a more efficient implementation than foldr mappend mempty
09:51:29 <SamB_XP> dankna: some notion that there may be a slightly more efficient but equivalent definition to the foldr one
09:51:34 <EvanR> BONUS: however when i just started talking with you, i realized theres another way to combine them than 'one afteranother'... theres path1 + path2, so circle plus line is ... helix
09:51:39 <SamB_XP> for a particular monoid
09:51:45 <dankna> BONUS, SamB: hmmmm okay
09:52:05 <jmcarthur> Sum
09:52:18 <EvanR> Sum?
09:52:29 <jmcarthur> foldl' is more efficient than foldr
09:52:32 <jmcarthur> in that case
09:52:48 <SamB_XP> a definition for Coq or Agda or their ilk would not have mconcat as part of the monoid record/class/module/whatever
09:52:55 <BONUS> EvanR: yeah there are sometimes several ways for something to be a monoid
09:53:04 <BONUS> like numbers can be + and 0  or * and 1
09:53:20 <EvanR> so would i defined two monoid operations
09:53:32 <jmcarthur> > getSum $ Sum 4 `mappend` Sum 5
09:53:33 <lambdabot>   9
09:53:44 <exDM69> is anyone working with Haskell LLVM bindings a regular in this channel?
09:53:52 <jmcarthur> > getProduct $ Product 4 `mappend` Product 5
09:53:53 <lambdabot>   20
09:54:13 <EvanR> is jmcarthur trying to explain something? :)
09:54:34 <jmcarthur> @instances Monoid
09:54:35 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
09:54:45 <dankna> hm
09:54:52 <dankna> @instances Dual
09:54:53 <lambdabot> Couldn't find class `Dual'. Try @instances-importing
09:55:15 <jmcarthur> :t getDual
09:55:16 <lambdabot> forall a. Dual a -> a
09:56:14 <jmcarthur> > getDual $ Dual "foo" `mappend` Dual "bar"
09:56:15 <lambdabot>   "barfoo"
09:56:57 <EvanR> how about this: given a path, a time of collision (collision is a generalized 'event' that occurs during motion), and f (?), combine them to get a new path value (after collision)
09:58:16 <EvanR> but i want to encode that into the path itself, so the path knows how to react to events
09:58:38 <dankna> what's your program, anyway, EvanR?  some sort of game thing?  it sounds interesting
09:58:57 <EvanR> no program, just something i was thinking about
09:59:01 <dankna> oh
09:59:11 <EvanR> could be used for a game, stuff typical flies around in games a lot
09:59:15 * dankna nods
09:59:42 <EvanR> and paths are altered by events
09:59:47 <dankna> certainly
09:59:51 <dankna> that's what made me think that
09:59:59 <EvanR> and thats basically the entire gameplay of all games, besides the gui
10:00:06 <dankna> yeah, haha
10:00:15 <BONUS> what exactly do you consider to be an event
10:00:21 <BONUS> like, formally
10:00:27 <BONUS> a point in time?
10:00:32 <EvanR> the time is separate
10:01:04 <EvanR> the event would be information about what kind of surface you hit, or what button was pressed
10:01:31 <dankna> so a typeclass that has a method which takes a path and alters it?
10:01:49 <dankna> hmm
10:01:55 <dankna> probably not sufficient
10:02:07 <dankna> as it needs to know about the state of the game-world as well
10:02:13 <EvanR> no
10:02:20 <EvanR> i defined paths to be location independent
10:02:43 <EvanR> so you cant have motion that depends on absolute position
10:03:10 <EvanR> they only know about events
10:03:15 <dankna> hmm
10:03:39 <dankna> then the event has to encapsulate the game-world information within itself
10:03:44 <EvanR> so im thinking when building a complex path from simpler paths, also specify ways to react to events
10:04:00 <EvanR> the event should have as little as possible information
10:04:15 * dankna nods
10:04:29 <EvanR> hit a bullet, hit a horizontal wall, hit water surface
10:04:38 <EvanR> player pressed jump
10:04:52 <BONUS> EvanR: have you heard about functional reactive programming?
10:05:01 <BONUS> s/about/of
10:05:06 <EvanR> heard the name
10:05:30 <BONUS> it think you might be trying to invent it here :)
10:05:35 <BONUS> possibly
10:05:39 <EvanR> maybe
10:05:53 <EvanR> monoid sounds right for just the paths
10:08:16 <EvanR> ill get the paths alone working and report back
10:08:21 <dankna> cool
10:09:02 <BONUS> how are you modeling your paths? i mean how do you represent them in haskell
10:09:31 <EvanR> beware, im about to use integers in my types, ignore them ;)
10:10:00 <EvanR> data Path = Path (Integer -> (Integer, Integer)) (Integer -> (Integer, Integer) -> Bool)
10:10:15 <dankna> O_O
10:10:20 <stevenmarky> o.0
10:10:30 <stevenmarky> two functions that return the start and end points?
10:10:34 <monochrom> > 1-1 :: Double
10:10:35 <lambdabot>   0.0
10:10:38 <EvanR> a function from time to 2d space, and a condition for when to stop
10:10:43 <dankna> two functions, one from a time to space, and one for the end--
10:10:44 <dankna> ah
10:11:13 <EvanR> the second part could be 'total distance traveled' using integration
10:11:21 <EvanR> or just total time
10:11:25 <BONUS> how about Integer -> (Integer, Integer, Bool)?
10:11:28 <EvanR> or 'stop at this location'
10:11:33 <BONUS> e.g. (x,y,stop/go)
10:11:40 <dankna> wouldn't the stop condition be better modeled (since you have discrete time steps rather than floats) as just Integer - the time to stop?
10:11:50 <EvanR> time to stop is one way to stop
10:11:56 <EvanR> location to stop is another
10:11:59 <EvanR> total distance is another
10:12:02 <EvanR> or whatever
10:12:04 <dankna> hm
10:12:08 <EvanR> i think that type covers more
10:12:31 <EvanR> erm
10:12:46 <EvanR> position is a function of time, revise the second part to
10:12:52 <EvanR> (Integer -> Bool)
10:13:01 <EvanR> now you can do all of the above, using the path
10:13:27 <EvanR> path (t -> (x,y)) (t -> bool)
10:13:45 <BONUS> are Integer -> (Integer, Integer, Bool) and your Path type with the two functions isomorphic?
10:13:49 <BONUS> i think so
10:14:05 <EvanR> ok
10:14:18 <EvanR> yes
10:14:49 <EvanR> if i have f and g, your h is (a,b,c) where (a,b) = f and c = g, so to speak
10:14:49 <dankna> but why is it a function to bool?  surely it's more useful to be able to query, what time do we stop
10:14:51 <stevenmarky> I don't think that is FRP, the second function would have to be polled to know when to stop
10:14:56 <BONUS> better even Integer -> Maybe (Integer, Integer)
10:15:01 <dankna> rather than to have to iterate through them and ask "do we stop here?  no?  how about here?"
10:15:46 <dankna> I hope you're taking this as constructive criticism, btw, which is how it's intended
10:15:51 <dankna> and not as an attempt to tear your thing apart
10:15:52 <EvanR> im thinking
10:15:55 <BONUS> Integer -> Maybe (Integer, Integer) is ReaderT Integer Maybe (Integer, Integer)
10:16:07 <BONUS> @unmtl ReaderT Integer Maybe (Integer, Integer)
10:16:07 <lambdabot> Integer -> Maybe (Integer, Integer)
10:16:13 <dankna> !
10:16:20 <dankna> @mtp Integer -> Maybe (Integer, Integer)
10:16:20 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
10:16:22 <dankna> @mtl Integer -> Maybe (Integer, Integer)
10:16:23 <lambdabot> Maybe you meant: ft map msg pl unmtl url
10:16:27 <dankna> aw
10:16:29 <EvanR> ignoring the execution, is seems like these definitions are easier to do
10:16:40 <EvanR> since an (x,y) function and a bool function are easy separate
10:17:03 <BONUS> EvanR: yes, it all depends on the rest of your program and how it works with it
10:17:27 <EvanR> im not sure about the best way to execute something, and it doesnt sound as interesting anyway ;)
10:19:20 <EvanR> BONUS: about the end condition, ending is always at a certain time, regardless of defining it as distance or position, because you can solve for time
10:19:39 <EvanR> so when constructing the path, you can solve for end time
10:19:53 <dankna> I agree
10:20:12 <EvanR> that makes the data have Integer for end time
10:20:29 <EvanR> solving may be involved for a complex path ;)
10:21:17 * dankna nods
10:22:02 <EvanR> lets figure out of thats well defined. we can easily solve for simple primitive paths. does it make sense to be able to use those numbers as part of an 'after' combination?
10:22:47 <EvanR> if a circle 'ends' at 6, and a line ends at 9, does that mean, the combination ends at 6+9
10:23:11 <BONUS> i gotta fly now, but good luck with your thing! :)
10:23:13 <EvanR> no because the motion is different so if it was define with position, it would need to be recomputed?
10:23:30 <EvanR> thanks
10:23:56 <EvanR> dankna: ah no, if its 'after' then 6+9 makes sense ;)
10:24:03 <dankna> yeah :)
10:24:15 <EvanR> but if it was 'sum' to a helix path...
10:24:21 <EvanR> its clearly not 6+9
10:24:29 <EvanR> how do you resolve it
10:24:32 <SamB_XP> a line and a parabola don't sum to a helix
10:24:38 <SamB_XP> they just make another parabola
10:24:46 <EvanR> line and circle
10:25:00 <SamB_XP> oh
10:25:08 <SamB_XP> line and forever repeating circle?
10:25:20 <EvanR> not in this case
10:25:38 <SamB_XP> oh, so line SEGMENT and one-time-around circle?
10:25:39 <EvanR> circle ends after 6 time
10:25:44 <c_wraith> x = cos t, y = sin t, z = t
10:25:45 <EvanR> could be a partial circle
10:25:49 <c_wraith> there's your helix
10:25:54 <SamB_XP> could it be two times around?
10:25:57 <EvanR> yes
10:25:58 <EvanR> or 1.5
10:26:20 <EvanR> so a sum would be a helix for part of the trip
10:26:23 <EvanR> then a line
10:26:24 <dankna> what if the circle and line segment don't end at the same time?  I guess you have to take the minimum of the two end times
10:26:26 <EvanR> then stop
10:26:37 <dankna> yeah, I would call this the product rather than the sum
10:26:47 <EvanR> why because its more complex ;)
10:26:54 <dankna> yes :)
10:26:56 <EvanR> hah
10:27:01 <EvanR> nice
10:28:25 <EvanR> dankna: if the end condition was based on space, then the end times of the two parts are irrelevant i think
10:29:00 <dankna> EvanR: then what you actually want is to make the duration of the product path be always "1" or something
10:29:05 <EvanR> so it could be recomputed with a search, if the conditions were stored in the path
10:29:09 <dankna> EvanR: and apply a scale operation afterward
10:29:35 <dankna> hmm
10:29:52 <EvanR> not all paths end though
10:30:01 <EvanR> crap, thats why its a function, not a number ;)
10:30:19 <EvanR> ok back to functions
10:30:48 <ddarius> Perhaps look at algebraic topology?
10:30:55 <EvanR> in execution, polling the condition is the same as computing it each time for the path
10:31:07 <chrisdone> BONUS: how do :-)
10:31:23 <EvanR> so separate function is ok, and lets use compute path independently if we want, for integration
10:31:23 <BONUS> a thought: say you model paths as a -> Maybe (a,a). then you could have a function, say, stopAtCondition which would take a condition (like if the x and y are too high) and a path and return a new path that would return Nothing when such a condition is met
10:31:28 <BONUS> hey chrisdone :)
10:31:43 <EvanR> ah
10:31:49 <drhodes> it looks like google chrome is going to be able to run haskell programs in their native client: http://blog.chromium.org/2010/03/native-client-and-web-portability.
10:32:15 <SamB_XP> drhodes: the WHAT now ?
10:32:33 <SamB_XP> drhodes: Haskell programs supplied how ?
10:32:39 <drhodes> it loks like the llvm backend can target the native client
10:32:59 <SamB_XP> can it?
10:33:06 <drhodes> http://nativeclient.googlecode.com/svn/data/site/pnacl.pdf
10:33:06 <EvanR> BONUS: i like that
10:33:27 <BONUS> so then you can take that path that you just got and modify it with yet another function
10:33:28 <EvanR> ill just need to wrap all primitives in Just
10:33:49 <SamB_XP> I mean, GHC isn't known for cross-compilation support
10:34:09 <SamB_XP> GCC does FAR, FAR better at cross-compilation
10:34:46 <SamB_XP> heck, I think MS Optimizing C/C++ Compiler does
10:35:29 <EvanR> newtype Path a = Path (a -> Maybe (a,a))
10:37:10 <SamB_XP> why, I think I even have an x86->amd64 version of the MS compiler here...
10:37:36 <SamB_XP> IA-64 too
10:38:10 <dankna> EvanR: newtype Path a b = Path (a -> Maybe (b, b))
10:38:21 <EvanR> ok
10:38:23 <dankna> no reason time and space have to both be either discrete or non-discrete
10:39:22 <EvanR> hm
10:39:32 <EvanR> circle :: b -> b -> Path a b
10:39:49 <EvanR> circle r w = (\t -> Just (r*cos(w*t), r*sin(w*t)))
10:39:51 <EvanR> ?
10:39:56 <SamB_XP> Microsoft (R) 32-bit C/C++ Optimizing Compiler Version 13.10.4035 for 80x86
10:40:10 <SamB_XP> Microsoft (R) C/C++ Optimizing Compiler Version 14.00.40310.39 for IA-64
10:40:12 <dankna> looks good
10:40:21 <SamB_XP> Microsoft (R) C/C++ Optimizing Compiler Version 14.00.40310.41 for AMD64
10:40:24 <EvanR> timeLimit :: a -> Path a b
10:40:29 <EvanR> er
10:40:34 <EvanR> timeLimit :: a -> Path a b -> Path a b
10:41:02 <dankna> and similarly, spaceLimit :: b -> Path a b -> Path a b
10:41:20 * EvanR wonders if this will actually work
10:41:22 <BONUS> limitTo :: (a,a) -> Path a b -> Path a b -- limits the function to only work inside an interval
10:41:32 <SamB_XP> Microsoft (R) C/C++ Optimizing Compiler Version 8.00c
10:41:34 <ddarius> @google fundamental group
10:41:34 <lambdabot> http://en.wikipedia.org/wiki/Fundamental_group
10:41:35 <lambdabot> Title: Fundamental group - Wikipedia, the free encyclopedia
10:42:14 <SamB_XP> that last one is, in fact, x86 to x86-16 ;-)
10:43:06 <EvanR> i forgot the constructor on my circle
10:43:18 <SamB_XP> (these compilers came with WinDDK 3790.1830)
10:44:25 <SamB_XP> betcha didn't know that MS's C compilers had version numbers more than 2x as high as the OS, didja?
10:46:09 <SamB_XP> and I think the cl version 14.x is probably what shipped with VS 2003 .NET
10:46:43 <EvanR> BONUS: dankna: hrm, a 'box limit' could test for inside a box, but then the path wouldnt end if it went outside the box and came back in later ;)
10:47:09 <EvanR> i suppose it could be more complex
10:47:12 <SamB_XP> hmm, cl 12 shipped with VS 6
10:48:09 <BONUS> EvanR: a box limit seems more like an (a,a) -> Path a b -> Bool function
10:48:16 <BONUS> umm wait no
10:48:20 <SamB_XP> cl 8 shipped with MSVC 1.5
10:48:23 <BONUS> Box a -> Path a b -> Bool
10:48:35 <EvanR> what does that do
10:49:03 <SamB_XP> what, hmm?
10:49:16 <BONUS> nah, wait. Box a -> a -> Path a b -> Bool. takes a box and an a and tells you if that the path on that a point is in the box
10:49:20 <BONUS> or something
10:49:20 <EvanR> b is space
10:49:29 <BONUS> oh, then it's Box b
10:49:45 <SamB_XP> VS 2003 only included CL 13.10.x (for i386, anyway)?
10:50:11 <EvanR> so that doesnt really do what we want, which is return a path that ends when it first leaves a box
10:50:11 <SamB_XP> even though that 14.00 for amd64 was copyrighted -2002?
10:50:30 <sungji> hi. http://gist.github.com/362190, can anyone tell me what exactly happens in the right part of the  list comprehension there?
10:50:30 <BONUS> ah is that what we want? sorry :)
10:50:37 <EvanR> yeah but it might be impossible
10:51:16 <BONUS> modeling things as functions like this has some drawbacks. there are quite some things that you can infer from knowing what the function is that haskell can't
10:51:29 <BONUS> for instance if you see what the definition of a function is, you can figure out its inverse
10:51:36 <BONUS> whereas haskell can't
10:51:38 <BONUS> etc.
10:52:15 <EvanR> well modelling as functions is the business were in here ;0
10:52:16 <EvanR> ;)
10:52:37 <EvanR> you can do a search algorithm
10:52:45 <EvanR> which may not terminate
10:53:09 <danderson> I have a bit of a problem here. I have a `Router a`, which is my custom monad stack (ReaderT Conf IO a), and I want to forkIO and run that.
10:53:25 <danderson> but how do I get IO () -> IO () (forkIO's signature) to become Router () -> Router () ?
10:53:41 <danderson> liftIO does the return value, but I don't see how to do the input in a nice way
10:53:42 <dankna> danderson: you were the one who had the related problem with withMVar earlier, right?
10:54:01 <dankna> it's something like (names probably wrong because I haven't used ReaderT before)
10:54:22 <danderson> it's related in that it's the same program, but it's a completely separate problem of how to ForkIO an action from a custom monad stack
10:54:27 <dankna> yeah
10:54:34 <dankna> well, I see them as two cases of the same problem
10:54:35 <dankna> but yeah
10:54:53 <dankna> :t forkIO
10:54:54 <lambdabot> Not in scope: `forkIO'
10:55:21 <aavogt> @undo [ t | Node _ l r <- ts, t <- [l,r] ]
10:55:21 <lambdabot> concatMap (\ a -> case a of { Node _ l r -> concatMap (\ t -> [t]) [l, r]; _ -> []}) ts
10:55:25 <danderson> just a general idea will do, I can come up with the details myself
10:55:31 <aavogt> UnderTaLker: ^^ that's what happens
10:55:34 * SamB_XP wonders about a Windows equivalent of oprofile...
10:55:38 <sungji> aavogt, well, thanks :)
10:55:39 <aavogt> sungji rather
10:55:45 <dankna> forkRouter :: Router () -> Router ThreadId
10:55:52 <dankna> forkRouter action = do
10:55:58 <dankna>   state <- ask
10:56:15 <dankna>   liftIO $ forkIO $ runReaderT action state
10:56:17 <sungji> aavogt, so basically, it's just like [ b | (a,b) <- [(1,2),(3,4)]]  --> [2,4]
10:56:38 <dankna> and you could go pointfree for bonus points
10:56:52 <sungji> aavogt, wow, how did you get lambdabot to "unroll" the function?
10:57:14 <aavogt> somebody wrote a plugin to do that
10:57:21 <aavogt> @commands
10:57:21 <lambdabot> Unknown command, try @list
10:57:23 <aavogt> @list
10:57:23 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
10:57:27 <sungji> cool
10:57:28 <sungji> :)
10:57:54 <sungji> aavogt, what did you mean, going pointfree for bonus points?
10:58:02 <aavogt> I didn't say that
10:58:07 <dankna> sungji: that was me who said that, and I was talking to danderson
10:58:19 <sungji> dankna, aavogt: oh ok, I'm sorry
10:58:31 <danderson> dankna: yeah, I see. I was hoping for a nicer way, but it makes sense that I need to tear everything down and rebuild it. Thanks.
10:58:42 <SamB_XP> but why the heck do you get bonus points for having no points?
10:58:54 <aavogt> when they are left over
10:59:03 <aavogt> because you didn't use them
10:59:08 <dankna> danderson: yeah.  sure thing.  if you find a more elegant way to express it, let me know - it's a special case of something which I have to do often.
10:59:10 <SamB_XP> oh
10:59:12 <SamB_XP> I see now
10:59:15 <dankna> haha
10:59:54 <aavogt> sungji: well it's more like  [ x | (a,b) <- [(1,2),(3,4)], ... ] --> [1,2,3,4]
11:00:12 <dankna> I'm tempted to be like
11:00:19 <danderson> dankna: it's made even more annoying by the fact that I already have forkIO wrappers for various stuff (propagate exception to parent thread, swallow all exceptions, run a group of threads and kill them all as soon as any one of them dies...
11:00:24 <aavogt> where the ... is that second binding in the list comprehension
11:00:28 <danderson> which I'm now going to have to rewrap for my custom monad :/
11:00:34 <dankna> danderson: no not at all.
11:00:35 * SamB_XP is a bit annoyed that gzip is not on his %PATH%
11:00:58 <danderson> dankna: huh?
11:01:03 <dankna> danderson: forkReader :: (IO () -> IO ThreadId) -> (Reader ()) -> (Reader ThreadId)
11:01:14 <dankna> danderson: forkReader forkWrapper action = ...
11:01:28 <dankna> using forkWrapper instead of forkIO but otherwise just like the definition I gave above
11:01:39 <dankna> or perhaps
11:01:48 <dankna> forkReader :: (IO () -> IO a) -> (Reader ()) -> (Reader a)
11:01:53 <dankna> if the wrapper doesn't return a ThreadId
11:02:40 <danderson> well, sure, that can all be done. But it'd be nicer to rewrite the basic utilities in terms of, eg., MonadIO, and get all the transmission of the monad stack for free
11:02:45 <dankna> I agree
11:02:53 <danderson> but this is just me wanting a pony, I can live with it
11:02:59 <dankna> something like
11:03:14 <dankna> class (Monad m) => SuspendableMonad m
11:03:29 <dankna> er
11:03:39 <dankna> class (Monad m) => SuspendableMonad m state where
11:03:43 <dankna>   suspend :: m state
11:04:02 <dankna>   resume :: state -> (m a) -> IO a
11:04:19 <danderson> yeah, exactly
11:04:32 <edwardk> dankna: you probably want to flip the args to SuspendableMonad around.
11:04:42 <danderson> and then implementations for the various transformers in mtl
11:04:46 <edwardk> dankna: and for inference reasons you may want to add a fundep from m -> state
11:04:47 <dankna> that's an idea which I thought of but haven't had the chance to use yet, and will probably use the next time I run into this
11:04:49 <dankna> and yes
11:04:57 <dankna> edwardk: yes and yes, both those are good suggestions
11:05:19 <Taejo> :t fmap ?f id
11:05:20 <lambdabot> forall a b. (?f::a -> b) => a -> b
11:05:38 <edwardk> dankna: and to be really pedantic: resume :: MonadIO n => state -> m a -> n a ;)
11:05:46 <dankna> edwardk: true
11:06:21 <dankna> note that I called it SuspendableMonad rather than MonadSuspendable because the latter naming pattern has a different feel to me... like it's for monads that provide a certain end-user facility
11:07:01 <dankna> whereas SuspendableMonad feels more like it fits in "SuspendableMonad is to Monad as Floating is to Num"
11:07:29 <bremner> crack?
11:07:43 <dankna> bremner: pardon?
11:07:59 <bremner> floating point is a tool of the devil, dontcha know?
11:08:02 <dankna> mm
11:08:04 <dankna> it has its uses
11:08:13 <bremner> see crack
11:08:17 <dankna> someday you should see quadruple-precision libraries used by astronomers :)
11:08:20 <dankna> they're insane :)
11:09:01 <SamB_XP> dankna: how do they work ?
11:09:20 <dankna> SamB: for some reason they do NOT work by having a struct with exponent and mantissa separate
11:09:39 <SamB_XP> what do they do instead ?
11:09:43 <dankna> SamB: instead, they pass around two double-precision floats everywhere, which are conceptually a single value
11:09:50 <dankna> the sum of the two being the value
11:09:58 <SamB_XP> I was actually wondering if that was how they worked ;-)
11:10:01 <dankna> yeah :)
11:10:02 <dankna> hehe
11:10:29 <dankna> it seems to me that that makes more work for them, but I reserve judgement since I don't know what the motivation is
11:10:30 <SamB_XP> I believe I've seen somewhere a Haskell module that did aribitrary-precision arithmatic with lists of Double
11:10:35 <dankna> interesting!
11:10:47 <SamB_XP> well, it might be faster than doing it in software
11:10:52 <dankna> hmm
11:10:54 <SamB_XP> and it might easily be less work too
11:10:56 <dankna> that's a fair point
11:11:24 <SamB_XP> though there are undoubtedly many corner cases to be dealt with, at least they basically only have to deal with those, right?
11:11:36 <dankna> right.
11:12:08 <dankna> well, there are cases where the significant places overlap, and cases where they aren't contiguous (there's a gap), ... similar to precision-loss
11:12:10 <SamB_XP> of course, the Haskell module probably has a lot less corner cases since it uses an arbitrary-length list ...
11:12:17 <dankna> so you have to worry about getting into canonical form
11:12:22 <dankna> before comparisons are sensible
11:13:12 <SamB_XP> dankna: I would think the lower-exponent chunk would be kinda meaningless if it wasn't contiguous with the upper chunk ;-)
11:13:31 <dankna> SamB: yes, that's the problem I refer to :)
11:13:50 <dankna> and true; using a list increases the dimensionality by one so the corner cases become edge cases and there are new corners.  and it's well known that the higher the dimensionality the fewer the corners you have in general ;)
11:14:02 <SamB_XP> dankna: hah
11:14:06 <dankna> grin
11:14:35 <SamB_XP> I meant that not being constrained to two would be useful for e.g. multiplication
11:14:50 <dankna> yeah, I see what you mean, I was just being silly
11:14:58 <SamB_XP> in that you could just map * over the cross product
11:15:21 <SamB_XP> or, really, liftM2 (*)
11:15:25 <SamB_XP> right?
11:15:46 <SamB_XP> well, maybe not quite that simple
11:15:51 <SamB_XP> but you see what I mean
11:15:59 <dankna> you probably want to re-canonicalize after that
11:16:04 <SamB_XP> probably
11:16:17 <dankna> but at least that confines all the weirdness to the canonicalization function
11:16:37 <SamB_XP> but even those astronomers must get some of these benefits
11:16:43 <dankna> I'm sure
11:16:57 <dankna> they are intelligent people, after all, haha
11:17:01 <SamB_XP> they probably have a few standard intermediate forms
11:17:07 <dankna> yeah
11:17:12 <dankna> I'd imagine, but I'm speculating
11:17:21 <SamB_XP> each with their own canonicalizing function
11:17:43 <SamB_XP> I mean, they'd want to avoid writing more of those than they have to ...
11:18:44 * dankna nods
11:23:29 <dankna> hmmm, I think it's fine for my parser generator to require a couple modest ghc extensions.  Happy's generated code isn't even compatible with 6.13 and up...
11:25:14 <centrinia> There is a ghc-6.13 ? :O
11:28:30 <siracusa> centrinia: It's the current development version
11:28:53 <Twey> Odd versions for development?
11:29:15 <siracusa> Yes
11:39:38 <deech> Anyone here wish Haskell had keyword arguments like Smalltalk?
11:39:54 <Philonous> deech: You can have them. Just pass a record
11:40:13 <EvanR> dankna: boxLimit box p = maybe p (\t -> timeLimit t p) (whenFirstExits box p)  ;)
11:40:39 <EvanR> whenFirstExits is a search over all space and time, and returns Nothing if it never exits ;)
11:40:52 <dankna> EvanR: hmmmmm okay :)
11:40:59 <EvanR> any ideas? :)
11:41:28 <deech> Philonous: say I wanted a function that searched for files of some name in some directory, currently I'd have to write: findFile file dir. I want to write 'findFile file in:dir'.
11:41:30 <dankna> for what?  how to implement it?  as cases based on the nature of the path.  there's no general-purpose algorithm; obviously that's the same as the halting problem.
11:41:42 <EvanR> yeeeeah :(
11:41:52 <EvanR> can i use a heuristic
11:42:29 <dankna> I can't think of one.  You really do need geometry code in there.  For example, for a line segment a bunch of simple comparisons will be sufficient, whereas for a circle you'll need to do trigonometry.
11:44:28 <sinelaw> greetingz
11:44:29 <EvanR> sucks, since p doesnt have that sort of info
11:44:46 <dankna> indeed
11:45:20 <EvanR> fractal algorithms sort of do this
11:45:52 <EvanR> whenFirstExits determines color, and Nothing would result in black for example
11:47:43 <Philonous> deech: You could say data File = File { name :: String, in :: Maybe FilePath}, file n = File { name=n, in = Nothing}, then you can write foo (file "myfile.txt"){in="/usr/a/b/c}
11:48:11 <Philonous> + the missing quotation mark
11:48:20 <dankna> EvanR: interesting observation
11:48:33 <dankna> I'm not sure it's /helpful/, but it's interesting :)
11:48:46 <deech> Philonous: true. It is a nice workaround.
11:48:48 <EvanR> dankna: how would i force the evaluation of whenFirstExits, because if im not mistaken, it will be deferred until that path is being used
11:49:01 <dankna> you're not mistaken, but why do you want to force it?
11:49:11 <dankna> and I don't think I know enough about laziness semantics to answer that, really
11:49:24 <dankna> play around with seq and see if it helps
11:49:27 <EvanR> k
11:50:10 <Philonous> deech: Oh, and there is a "Just" missing. Well it doesn't really look too nice, then
11:51:58 <EvanR> dankna: how about... boxLimit does... if f t is not in the box, return nothing. if its in the box, it checks to see if it ever was outside the box before that...
11:52:41 <EvanR> that solves it in the discrete case ;)
11:52:46 <dankna> true enough
11:52:53 <dankna> the discrete case is far easier :)
11:53:08 <dankna> I think to answer whether that's appropriate
11:53:16 <dankna> we would need to have a specific application for this
11:53:39 <dankna> so that we could know whether the performance tradeoffs were acceptable
11:55:11 <dmwit> deech: byorgey wrote an article about this recently
11:55:27 <dmwit> http://byorgey.wordpress.com/2010/04/03/haskell-anti-pattern-incremental-ad-hoc-parameter-abstraction/
11:55:35 <dmwit> deech: for your example, I would write something like
11:56:10 <dmwit> (using Philonous' File type)
11:56:24 <cebewee> hm, i wonder whether there is some standard combinator to write function composition from left to right?
11:56:28 <EvanR> imagine the previous  history of the function 'isInsideBox p', which is a true false function of time. the structure of this function could be very crazy if we used real numbers somewhere
11:56:32 <dmwit> findFile default { name = "foo", in = "/usr/a/b/c" }
11:56:41 <sinelaw> can i constrain a data type's parameterized type to be of a certain typeclass?
11:56:42 <EvanR> but in reality our 'intervals' will be sensible
11:56:48 <dmwit> or findFile default { name = "foo" } -- to just search in whatever default path is set in the "default" value.
11:57:12 <EvanR> if we allow cantor set like parts to be ignored, corresponding with a loss of resolution...
11:57:19 <cebewee> i.e. like pipes in the shell
11:57:29 <EvanR> we might be able to have a performance improvement
11:57:30 <dmwit> cebewee: >>>
11:57:40 <dmwit> sinelaw: Yes, but it's generally considered bad practice.
11:58:00 <EvanR> the result will be a 'collision test' which isnt exactly right, but fuzzy
11:58:26 <pflanze> Hello. Is anyone using Hircules, or another IRC client written in Haskell? Otherwise, which *good* IRC client are you using? (I've been an xchat user for a long time but I start to doubt its stability and safety.)
11:58:31 <EvanR> if you stay outside the box for long enough, you have a higher probability of being noticed by the high performance algorithm
11:58:33 <EvanR> its quantum mechanical
11:58:35 <cebewee> dmwit: Thanks
11:59:00 <dmwit> pflanze: irssi doesn't suck horribly
11:59:45 <deech> pflanze: emacs erc
12:02:04 <writer> Hi everyone
12:04:20 <writer> 'Data.ByteString.readFile "/proc/cpuinfo"' returns an "" ByteString, whereas 'Data.ByteString.Lazy.readFile "/proc/cpuinfo"' returns an 'Chunk "processor\t: 0..." Empty' ByteString. Why is this difference ?
12:04:32 <writer> Is this because of /proc/cpuinfo being special file ?
12:06:05 <writer> looks like it is.
12:06:53 <sinelaw> dmwit, why?
12:07:43 <theorbtwo> Strange, I'd have thought that lazy reading would be the one to fail, but I'm not terribly surprised that they don't behave the same.
12:08:14 <dmwit> sinelaw: Experience shows that this comes back to bite you later. It's not always true, but often enough to be considered bad practice. =)
12:08:20 <pflanze> writer: proc files usually have size 0 reported through stat, even if they return data (probably to make stat cheap)
12:08:26 <dmwit> sinelaw: (Because it is too restrictive, and limits your API.)
12:08:29 <sinelaw> ok
12:08:41 <sinelaw> i don't need it here anyway, after all. i guess that was a sign
12:08:55 <theorbtwo> /proc files and the like won't neccessarly behave the same if you seek into them, and then read them.
12:09:03 <sinelaw> @pl (\f g -> f . g . f)
12:09:03 <lambdabot> liftM2 (.) (.) (flip (.))
12:09:08 <sinelaw> @pl (\g f -> f . g . f)
12:09:09 <lambdabot> ap (.) . (.)
12:09:29 <EvanR> you just lifted and flipped some (.) (.)
12:09:30 <sinelaw> @type (\g f -> f . g . f)
12:09:31 <lambdabot> forall a b. (b -> a) -> (a -> b) -> a -> b
12:09:50 <theorbtwo> EvanR: Sounds like experimental plastic surgery.
12:09:53 <EvanR> lol
12:10:01 <cebewee> dmwit: is there some ready-mode equivalent for $, too?
12:10:04 <sinelaw> @type (\f -> fromIntegral . f . fromIntegral)
12:10:05 <lambdabot> forall a b a1 a2. (Integral a, Num b, Integral a2, Num a1) => (a1 -> a) -> a2 -> b
12:10:10 <sinelaw> @hoogle (\f -> fromIntegral . f . fromIntegral)
12:10:10 <lambdabot> Parse error:
12:10:10 <lambdabot>   --count=20 "(\f -> fromIntegral . f . fromIntegral)"
12:10:10 <lambdabot>                ^
12:10:19 <sinelaw> ok, pm :)
12:10:52 <cebewee> something like this works for me, but is not nice yet: flip ($) "hello world" $ map ord >>> filter (<105) >>> map chr
12:11:59 <writer> pflanze: yes, thats what I concluded from the source code of Data.ByteString.readFile. Thanks
12:12:01 <dmwit> :t pure
12:12:02 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
12:12:09 <dmwit> :t arr
12:12:10 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
12:13:03 <dmwit> cebewee: [c | c <- "hello world", ord c < 105] -- ?
12:13:11 <dmwit> or better
12:13:12 <dmwit> > chr 105
12:13:13 <lambdabot>   'i'
12:13:20 <dmwit> cebewee: [c | c <- "hello world", c < 'i']
12:13:57 <dmwit> um
12:14:06 <dmwit> filter (<'i') "hello world" -- =P
12:14:10 <pflanze> (writer: "probably to make stat cheap", actually probably even more so because stat and open are not atomic hence the contents could change anyway and the size would be meaningless)
12:14:14 <Twey> Hehe
12:14:32 <writer> okay
12:14:33 <Twey> > filter (< 'i') "hello world"
12:14:34 <lambdabot>   "he d"
12:14:39 <Twey> Hed!
12:15:08 <cebewee> dmwit: ok, that's the nicest solution for this example ;)
12:15:23 <dmwit> > "Oh no " ++ filter (< 'i') "hello world" ++ "idn't!"
12:15:24 <lambdabot>   "Oh no he didn't!"
12:16:06 <cebewee> but i was wondering more about the general case, i.e. building some transformation chain in ghci
12:16:56 <dmwit> Use (.) and the Home key. ;-)
12:17:18 <dmwit> or learn about "it"
12:17:49 <dmwit> Or, if you're really, really set on (>>>), you could do this
12:18:23 <dmwit> eh
12:18:25 <dmwit> never mind
12:18:34 <dmwit> That way isn't really that much better. =P
12:19:01 <cebewee> :p
12:19:43 <cebewee> It was motivated by this line, constructed iteratively
12:19:44 <cebewee> openBinaryFile "/dev/random" ReadMode >>= (\h -> hSetBinaryMode h True >> hGetContents h) >>= return . take 63 . map chr . filter (\x -> x >= 32 && x <= 126) . map ord
12:20:19 <cebewee> dmwit: yeah, i tend to forget about "it", but i like oneliners, too ;)
12:20:37 <Twey> They're easier to copy and paste into a file
12:20:38 <Sgeo> What's (>>>)? I remember seeing it somewhere, don't remember what it is
12:20:44 <Twey> Sgeo: Arrow sequencing
12:20:44 <jlouis> Sgeo: arrow
12:20:55 <Twey> For functions, flip (.)
12:21:25 <Sgeo> I'm going to go play with Worms
12:22:16 <Sgeo> WinGHCi loves to stop working on me when I leave it open overnight
12:22:19 <Sgeo> Oh, there we go
12:23:12 <sinelaw> what's the standard vector space typeclass, and where is it?
12:23:35 <cebewee> i'll have to play with it some more, when i have some more time
12:25:23 <cebewee> back to work now
12:27:21 <centrinia> sinelaw, there is a vector space typeclass in numeric-prelude.
12:27:47 <sinelaw> is that considered standard by any measure?
12:28:16 <centrinia> It is standard with respect to numeric-prelude. :)
12:28:27 <sinelaw> yes, i meant the package itself :)
12:28:33 <sinelaw> i think conal also has one
12:28:49 <sinelaw> http://hackage.haskell.org/package/vector-space
12:28:50 <centrinia> Well, numeric-prelude is Experimental. :)
12:29:38 <sinelaw> i'll use conal's one
12:32:44 <sinelaw> @pl (0-)
12:32:44 <lambdabot> (-) 0
12:34:12 <centrinia> :t (-) 0
12:34:13 <lambdabot> forall t. (Num t) => t -> t
12:42:39 <sinelaw> @hoogle Double -> Int
12:42:39 <lambdabot> Foreign.Storable alignment :: Storable a => a -> Int
12:42:40 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
12:42:40 <lambdabot> Prelude exponent :: RealFloat a => a -> Int
12:42:47 <sinelaw> @hoogle round
12:42:48 <lambdabot> Prelude round :: (RealFrac a, Integral b) => a -> b
12:42:48 <lambdabot> Text.Html background :: String -> HtmlAttr
12:42:48 <lambdabot> Text.XHtml.Transitional background :: String -> HtmlAttr
12:42:52 <tensorpudding> > (-0)
12:42:53 <lambdabot>   0
12:44:02 <tensorpudding> > fix (\x -> (-x))
12:44:06 <lambdabot>   mueval-core: Time limit exceeded
12:48:42 <iammisc> how do i take the md5sum of a string?
12:49:19 <EvanR> @src take
12:49:20 <lambdabot> take n _      | n <= 0 =  []
12:49:20 <lambdabot> take _ []              =  []
12:49:20 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
12:55:08 <EvanR> @src foldr
12:55:08 <lambdabot> foldr f z []     = z
12:55:08 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
12:58:29 * glguy presents the future of "syntax highlighting" http://www.galois.com/~emertens/output.html
12:58:54 <dankna> glguy: tie that into darcs annotate and it will be roughly what I want
12:59:13 <glguy> see, you know where you are in the file by what color things are
12:59:21 <dankna> mm, I'm not sure that's that useful
12:59:25 <dankna> that's what scrollbars are for :)
12:59:27 <mauke> <font color="">? you're fired
12:59:48 <glguy> haha, if /that/ is what you have a problem with then /you/ are fired ;)
12:59:55 <paxcoder> glguy: you run out of colors real soon. especially if you fade.
13:01:46 <paxcoder> glguy: ouch you did it for each letter. take it from a guy who's to lazy to replace tables on his site: you're fired :-P
13:01:52 <xcvii> nice coloring, now you can tell the top of the block from the bottom at a glimpse
13:01:53 <paxcoder> *too
13:02:04 <glguy> Thanks xcvil!
13:02:11 <glguy> you are the first one to understand me
13:02:29 <dankna> haha
13:02:52 <Twey> Sadly, you didn't understand 97 ;)
13:03:49 <Twey> glguy: I'm a little confused as to what the fading is representing
13:04:04 <Twey> It looks like the whole program just fades from green to pink?
13:04:06 <dankna> I get what he's going for - the fading represents how far down the document it is
13:04:09 * glguy feels like he is being taken a bit too seriously
13:04:14 <Twey> Ah, I see
13:04:32 <xerox> Rainbowskell
13:05:25 <Twey> Heh
13:06:09 <glguy> Twey: it fades it between any two colors, I Just happened to pick those two
13:06:30 <dankna> also, the choice of green for the top color and pink for the bottom color clearly betrays the creator's immersion in the false dichotomy of plants (green) versus vampires (pink), which is outmoded and generally accepted as frivolous.  the color choice needs to have better dynamic harmonies in order to include transnormal quantitative epistemological analysis in its ontological schema...
13:06:30 <glguy> I was thinking about back when faders were popular in AOL chatrooms
13:06:33 * dankna nods seriously
13:06:45 * dankna can't keep a straight face
13:06:57 <glguy>  /betrays/ yes, that was the word I was looking for
13:07:01 <dankna> haha
13:07:03 <Twey> glguy: Oh, okay :Ã¾
13:07:13 <Twey> dankna: Hehehe
13:07:52 <glguy> I used to have a VB program that you would type into and then it would wonder around the controls and type faded html text into the chatroom
13:08:12 <glguy> I was also 12, so it seems more justifiable :-D
13:08:21 <dankna> haha, cool cool
13:08:29 <paxcoder> speaking about editors: http://www.youtube.com/watch?v=5JzaEUJ7IbE (see the second half of the video)
13:08:56 <paxcoder> *about
13:10:43 <paxcoder> it's ok, you can thank me later on that amazing video
13:11:36 <dankna> watching it
13:13:41 <dankna> yes!  6:05 "The intensity of the line" something or other the number of edits to that line
13:13:44 <dankna> that is the feature I want
13:15:21 <dankna> unfortunately their other features fail to excite me
13:15:34 <dankna> I think more could be done with heterogeneous fonts
13:15:38 <dankna> that's an area with some promise
13:15:50 <dankna> but they don't really explore it beyond having header lines really big (too big, in fact)
13:16:19 <dankna> (but I don't blame them for that, it's a proof of concept)
13:17:14 <paxcoder> yeah, they were set out to make a complete ZUI (not just the editor/text viewer), and this is just its predecessor.
13:17:25 * dankna nods
13:17:57 <dankna> have you seen videos of CLIM on the Lisp Machine?
13:18:36 <dankna> you can click on your program's output, or the output of ANY program using that library, and get a visual debugger of the value you clicked on
13:18:49 <dankna> and you can specify that certain types should react to the mouse in certain ways
13:19:56 <paxcoder> will give it a looksy, link perhaps?
13:20:03 <dankna> it's been ages, let me dig it up
13:20:20 <paxcoder> sure, thanks
13:25:00 <dankna> http://www.sts.tu-harburg.de/~r.f.moeller/uims-clim/clim-intro.html this is the best introduction I can find, and here is a paper on the concepts: ftp://publications.ai.mit.edu/ai-publications/pdf/AITR-794.pdf
13:25:21 <dankna> sorry, that's even MORE work to look into than a video link would have been, but I can't find any of the videos that people made ten years ago :)
13:28:18 <paxcoder> k, thx for trying
13:33:54 * hackagebot allocated-processor 0.0.1 - Functional combinators for monadic actions that require allocation and de-allocation  http://hackage.haskell.org/package/allocated-processor-0.0.1 (NoamLewis)
13:39:56 * hackagebot cv-combinators 0.1.2.2 - Functional Combinators for Computer Vision  http://hackage.haskell.org/package/cv-combinators-0.1.2.2 (NoamLewis)
13:39:58 * hackagebot HOpenCV 0.1.2.1 - A binding for the OpenCV computer vision library  http://hackage.haskell.org/package/HOpenCV-0.1.2.1 (NoamLewis)
13:48:20 <Craig`> hello guys
13:48:34 <chrisdone> hi
13:48:42 <lpsmith> hpaste is down
13:48:56 <Craig`> I'm thinking of trying haskell
13:49:14 <Craig`> as I have never really done much of it
13:49:18 <chrisdone> Craig`: http://tryhaskell.org/ !
13:49:28 <Craig`> oh nice :D
13:49:31 <Craig`> just like tryruby :D
13:49:34 <chrisdone> ;D
13:49:38 <Craig`> and then learnyouahaskell is awesome like Why's
13:49:52 <systemfault> Yeah..
13:50:00 <systemfault> Learn you a Haskell is the best.
13:50:02 <systemfault> Really.
13:50:41 <systemfault> RWH is nice but harder to understand
13:50:50 <Craig`> would RWH be good after LYAH?
13:50:54 <alpounet> yeah
13:51:02 <systemfault> Craig`: Definitely
13:51:09 <alpounet> RWH makes you write actual useful programs
13:51:20 <Craig`> well, I'm starting A Level Maths/Further Maths in September, and I was thinking Haskell is different, and it seems awesome for Maths
13:51:37 <Craig`> I really like Ruby, so I'd continue using that, with Haskell on the side/both at once
13:53:34 <chrisdone> you could use Hubris which lets you use Haskell from Ruby
13:53:42 <chrisdone> literally use them both at once
13:53:48 <Craig`> that would be pretty epic
13:53:50 * Craig` looks into that
13:54:02 <Craig`> oh and btw, did you create tryhaskell.org chrisdone?
13:54:08 <chrisdone> yep
13:54:12 <Craig`> oh nice one, :D
13:54:18 <chrisdone> ;D
13:55:25 <Craig`> simple question, when would I use a tuple?
13:55:31 <Craig`> just tryhaskell basically just said type this
13:55:36 <Craig`> not why I'd use it rather than array
13:56:02 <mauke> how would you use it instead of an array?
13:56:04 <sepp2k1> Craig`: A tuple can contain elements of different types. A list can not.
13:56:07 <xcvii> a tuple can hold values of different types
13:56:09 <sepp2k1> Oh and neither can an array.
13:56:19 <sepp2k1> But you shouldn't normally use arrays.
13:56:27 <mauke> I don't think arrays and tuples overlap in any useful way
13:56:50 <Craig`> thanks
13:58:17 <monochrom> I wouldn't worry about "when would I use ___" until I had accumulated a critical mass of knowledge. Then I would write something purposeful or reading other people's purposeful code, and then "when would I use ___" would come to me.
13:58:48 <SamB_XP> monochrom: Well, it might. Or it might not.
13:59:15 <sungji> hm... what do I have to think about, in order to implement a haskell function that returns a list of all lists of length n of type Bool? I'm sure I'm not thinking in haskell enough :)
13:59:26 <monochrom> I wouldn't even worry that it might not. If it will not, so be it.
13:59:42 <Craig`> do you think A Level maths and Haskell would work together nicely?
13:59:48 <SamB_XP> I guess the best question you could ask if you're worried you've missed something obvious that it's good for is "how have you used this?"
13:59:50 <mauke> > replicateM 4 [False,True]
13:59:51 <lambdabot>   [[False,False,False,False],[False,False,False,True],[False,False,True,False...
13:59:59 <sepp2k1> Craig`: A tuple also has a fixed size. You can say "this function excepts a tuple of three integers", but you can't say "this function accepts a list of three elements"... well, you can, but it won't be enforces at compile-time.
14:00:20 <stevenmarky> sungji: think about the type of the function first
14:00:27 <sinelaw> @hoogle IO ()
14:00:27 <lambdabot> Network.BSD endHostEntry :: IO ()
14:00:28 <lambdabot> Network.BSD endNetworkEntry :: IO ()
14:00:28 <lambdabot> Network.BSD endProtocolEntry :: IO ()
14:00:33 <sinelaw> @type return ()
14:00:34 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
14:00:36 <chrisdone> :t ("hello",5,True)
14:00:37 <lambdabot> forall t. (Num t) => ([Char], t, Bool)
14:00:41 <sinelaw> @type return () :: IO ()
14:00:42 <lambdabot> IO ()
14:01:01 <sinelaw> ah nvm.
14:01:11 <sinelaw> sup chrisdone ? :)
14:01:12 <Craig`> can someone share their opinion to what I asked last please? :)
14:01:25 <sungji> stevenmarky, nbools :: Int -> [[Bool]]  and the base case:  nbools 0 = [[]] :)
14:01:31 <chrisdone> sinelaw: just hacking on mueval here :-)
14:01:50 <sinelaw> whyhaskell is cool, btw.
14:02:00 <chrisdone> adding an --interactive option
14:02:29 <chrisdone> whyhaskell?
14:02:33 <sinelaw> oops.
14:02:34 <sinelaw> try haskell
14:02:39 <chrisdone> hehe
14:02:40 <stevenmarky> Craig`: honestly I don't think you need to learn or use a programming language for A level maths...
14:02:46 <sinelaw> "why haskell?" could be a new one
14:02:47 <stevenmarky> Why the lucky stiff!
14:03:02 <SamB_XP> who is that guy?
14:03:11 <Craig`> stevenmarky, I know I don't, well it was just an idea
14:03:17 <stevenmarky> SamB_XP: He wrote the Ruby version of the tutorial
14:03:31 <SamB_XP> ruby version of what tutorial?
14:03:37 <dschoepe_> of tryhaskell
14:03:47 <SamB_XP> and did he really burn everything he'd ever written in a fit of rage?
14:03:49 <Craig`> I was hoping that I'd be able to apply what I learned in Haskell more easily
14:03:57 <sinelaw> chrisdone, still hacking on my computer vision + haskell + robot thingy
14:04:36 <sinelaw> i'm writing a haskell binding for... the Segway RMP!
14:04:37 <sinelaw> :)
14:04:47 <monochrom> so you caused all those OpenCV hackage updates.
14:04:49 <chrisdone> robot thingy!?
14:04:51 <SamB_XP> Craig`: what does A level maths involve?
14:04:57 <sinelaw> monochrom, yes.
14:05:02 <sungji> stevenmarky, and what comes after the the signature and the base case?
14:05:02 <Craig`> SamB_XP, I don't have loads of details
14:05:08 <SamB_XP> you might only want Haskell for pred 'A' level maths...
14:05:12 <SamB_XP> > pred 'A'
14:05:13 <lambdabot>   '@'
14:05:20 <SamB_XP> @-level maths, yes
14:05:20 <lambdabot> Unknown command, try @list
14:05:41 <Craig`> > sort "Craig`"
14:05:42 <lambdabot>   "C`agir"
14:05:45 <Craig`> heh
14:05:51 <sinelaw> chrisdone, i'm working on a project to control a robot from haskell, with frp-style code
14:05:54 <SamB_XP> the what now ?
14:05:55 <stevenmarky> sungji, well write the remaining cases :p I'm not sure exactly what you want it to do
14:06:06 <SamB_XP> > map ord "Craig`"
14:06:07 <lambdabot>   [67,114,97,105,103,96]
14:06:18 <SamB_XP> oh, right, capital/lowercase
14:06:21 * SamB_XP silly
14:06:26 <chrisdone> sinelaw: very cool. source available?
14:06:39 <sinelaw> yes
14:06:48 <sinelaw> the opencv stuff is already on hackage
14:06:57 <SamB_XP> > sortBy (compare `on` toLower) "Craig`"
14:06:58 <lambdabot>   "`aCgir"
14:06:59 <sinelaw> the robotic stuff will be there once i finish a draft and test it
14:07:01 <Craig`> just want to see what It'd look like: how would I map through each char of "Craig`", succ it, and then join the output
14:07:06 <SamB_XP> > sortBy (compare `on` toUpper) "Craig`"
14:07:07 <lambdabot>   "aCgir`"
14:07:20 <sungji> stevenmarky, I want to generate a list of all lists of length n of type Bool. e.g. booln 2 = [[True,True],[False,False],[True,False],[False,True]]
14:07:33 <chrisdone> :t map
14:07:34 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
14:07:44 <SamB_XP> > map succ "Craig`"
14:07:45 <lambdabot>   "Dsbjha"
14:07:47 <voker57> :t on
14:07:48 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
14:08:01 <glguy> > sortBy (\ _ _ -> GT) "Craigmember:Craig%60"
14:08:02 <lambdabot>   "06%giarC:rebmemgiarC"
14:08:08 <Craig`> SamB_XP, nice
14:08:11 <mauke> > replicateM 2 [True,False]
14:08:12 <lambdabot>   [[True,True],[True,False],[False,True],[False,False]]
14:08:25 <xerox> ?fresh
14:08:25 <lambdabot> Hacw
14:08:26 <xerox> ?fresh
14:08:27 <lambdabot> Hacx
14:08:27 <glguy> (hmmm, that was a weird paste)
14:08:34 <xerox> this function should be nice to golf
14:08:43 <sungji> mauke, wow. but I'm supposed to come up with my own implementation in the exam
14:08:45 <SamB_XP> glguy: seriously, I was wondering if you ran it through the inverse of c++filt
14:08:45 <sinelaw> problem with the segway is that it's a hefty device
14:08:46 <xerox> (the "succ" one used by fresh)
14:08:48 <sinelaw> it can kill!
14:08:50 <xerox> any ideas?
14:09:02 <Craig`> so, are LYAH and RWH the only recommended readings on Haskell? any other books (proper as well)
14:09:16 <sungji> mauke, oh and only Prelude functions are allowed.
14:09:23 <SamB_XP> xerox: hmm, you mean golf succ for [a] ?
14:09:24 <mauke> @src replicateM
14:09:24 <lambdabot> replicateM n x = sequence (replicate n x)
14:09:33 <mauke> @index sequence
14:09:33 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
14:09:35 <xerox> SamB_XP: yeah, you saw that
14:09:38 <SamB_XP> sungji: no Data.List?
14:09:39 <mauke> @index replicate
14:09:39 <lambdabot> Data.List, Prelude
14:09:47 <sungji> SamB_XP, no :)
14:09:58 <mauke> sungji: sequence (replicate 2 [True,False])
14:10:02 <chrisdone> Craig`: other books are _A Gentle Introduction to Haskell_, _Programming in Haskell_, but the two you mentioned are most recommended
14:10:18 * glguy first read "The Haskell School of Expression"
14:10:20 <siracusa> @check \s -> sortBy (\ _ _ -> GT) s == reverse s
14:10:21 <lambdabot>   "OK, passed 500 tests."
14:10:29 <SamB_XP> glguy: I found that one a letdown
14:10:44 <SamB_XP> then I lost it an/or didn't fully retreve it from someone to whom I had lent it
14:10:57 <sungji> mauke, thanks. But I was trying to get some ideas on how to improve my thinking when it comes to implementing such functions in haskell
14:11:02 <dschoepe_> !h fix (\booln n -> if n == 1 then [True,False] else map (True:) (booln $ n-1) ++ map (False:) (booln $ n-1)) 2
14:11:10 <dschoepe_> > fix (\booln n -> if n == 1 then [True,False] else map (True:) (booln $ n-1) ++ map (False:) (booln $ n-1)) 2
14:11:11 <lambdabot>   Couldn't match expected type `[GHC.Bool.Bool]'
14:11:12 <lambdabot>         against inferred typ...
14:11:15 <SamB_XP> I was hoping for a meatier book about the design of EDSLs
14:11:35 <dschoepe_> > fix (\booln n -> if n == 1 then [[True],[False]] else map (True:) (booln $ n-1) ++ map (False:) (booln $ n-1)) 2
14:11:36 <lambdabot>   [[True,True],[True,False],[False,True],[False,False]]
14:12:48 <monochrom> Eh? A truth table of size n?
14:13:00 <sungji> here's another one:   booln 0 = [[]], bool n = map (False:) b ++ map (True:) b  where b = bool $ (n-1)
14:14:02 <monochrom> Has anyone suggested using sequence yet? :)
14:14:09 <monochrom> Or replicateM
14:14:10 <sungji> monochrom, mauke
14:14:15 <sungji> did
14:14:20 <monochrom> Good.
14:14:22 <sungji> :)
14:15:50 <sungji> heh, but it's not about the concrete solution. I was asking this cuz I hoped to get some input about the thinking process behind the implementation... I saw the base case, the signature and I know how the result looks like. but I couldn't figure out how to implement the step case
14:16:44 <monochrom> Recursive thinking.
14:17:19 <monochrom> To add 10 numbers, add 9 numbers, then figure out how to fix it up by compensating for the 10th.
14:18:04 <monochrom> Of course you can also add 5 of the numbers, add the other 5, then figure out how to combine.
14:18:05 <sungji> monochrom, that's something :) my fault is that I would have started with 0 instead of 1 heh
14:18:09 <sungji> err 10
14:18:11 <sungji> (here)
14:18:18 <andrewsw> average then and then multiply by 10.
14:18:32 <monochrom> haha
14:28:25 <sungji> I hope this (http://learnyouahaskell.com/recursion) will give me the required idea
14:37:42 <sungji> not really. I can't deal with '2-dimensional' recursions... i don't quite see the link between 1d and 2d
14:39:58 <Volvic> marekw2143: it is the notation for function composition, i.e.  it means function1(function2 (x) ), assuming you pass 'x' to it
14:40:08 <Phyx-> hmm
14:40:09 <Phyx-> odd
14:40:33 <Phyx-> large lag for not doing anything
14:40:35 <Volvic> can someone tell me how to capture keyboard input such as arrow key presses?
14:41:01 <mauke> Volvic: what OS?
14:41:05 <Volvic> osx
14:41:10 <mauke> oh, no idea
14:41:17 <Volvic> anything then :)
14:42:01 <mauke> well, first you need to create an X window, I think
14:42:11 <mauke> and then you get X keypress events
14:42:15 <Volvic> whoa, no way to capture it from the console?
14:42:32 <mauke> the console only gives you characters, not keys
14:42:51 <Volvic> oh
14:43:16 <Volvic> but it accepts characters that move the cursor
14:43:23 <mauke> huh?
14:43:29 <Volvic> 1 moment
14:44:13 <Volvic> this escape sequence moves the cursor 1 character to the right: \Esc[1C
14:45:38 <Phyx-> mauke: might you know if it' possible to use unlifted types in class declarations/instances?
14:45:49 <mauke> I don't even know what that is
14:46:23 <Volvic> like, i am able to capture a backspace key press using getChar (it returns '\BS')
14:46:44 <mauke> ok?
14:46:50 <Volvic> but not the arrows somehow
14:46:56 <mauke> what do you get instead?
14:47:02 <Volvic> nothing
14:47:16 <Volvic> i guess my terminal might be blocking them somehow
14:47:21 <mauke> ok, maybe your terminal hates you
14:47:25 <Volvic> lol
14:47:35 <Volvic> it's mutual at this point
14:47:41 <Phyx-> mauke: aw, oh well, thanks anyway
14:52:17 <ezyang> Is there a theory of non-structure preserving transformations?
14:52:36 <ezyang> I guess you can sort of get this kind of thing with monads, but that's a little too ad hoc, iiuc
14:52:45 <edwardk> ezyang: ?
14:52:51 <Volvic> yeah google "amorphism"
14:53:29 <ezyang> for example, say I have a list, and I'm grouping it into a list of lists
14:53:59 <ezyang> if an element in the first list corresponds to a list in the second list, I have a map
14:54:22 <edwardk> ezyang: did you read byorgey's pearl on species?
14:54:22 <ezyang> but if I have multiple items in the first list correspond to a list in the second list, I don't see any common pattern
14:54:33 <ezyang> edwardk: Not yet, it's on my reading list.
14:54:43 <edwardk> ezyang: it talks to much this sort of concern
14:54:47 <Phyx-> "Constraint is no smaller than the instance head" why does the constrains have to be strictly smaller? it's giving that on Foo Int => Foo (Maybe Int), :S
14:55:00 <Phyx-> why not "smaller or equal"
14:55:08 <edwardk> Phyx-: if they are strictly smaller than, by the fact that their size is well-founded you know it terminates
14:55:31 <edwardk> Phyx-: if the constraint is the same size the compiler doesn't know its making headway and could spin forever
14:55:44 <edwardk> henced why you need UndecidableInstances, etc.
14:55:51 <edwardk> er s/henced/hence/
14:57:30 <Phyx-> edwardk: ah, but couldn't it in this case conclude that it will terminate because the head has one applies type less
14:59:45 <edwardk> Phyx-: you are capable of that reasoning, but finding monotonically decreasing well founded termination metrics is in general a very hard thing for a compiler to do
15:00:14 <edwardk> Phyx-: once you've convinced yourself you can add the UndecidableInstances flag in good conscience ;)
15:02:07 <Phyx-> edwardk: sure, but I have alot of other instances in that file, that might really have a problem and then UndecidableInstances would let them compile aswell. Unless i'm missunderstanding what this extension can cauze
15:02:30 <ezyang> hm. Brent's paper is too far away from my current position to be useful in bounded time.
15:02:57 <edwardk> Phyx-: correct. you can of course split up your source files, but there isn't a way to turn it on or off per class. =/
15:03:34 <edwardk> Phyx-: sadly that monotonicity condition is a global reasoning property about the class as a whole as a result of all of its instances, so its not something the compiler can really do for you
15:03:44 <edwardk> er s/do/find/
15:05:02 <Phyx-> edwardk: well, this and Instance head matching are my two biggest gripes lately about type classes
15:05:09 <gwern> ...wow. firefox can now recursively restore sessions
15:05:13 <Phyx-> I understand the difficulty in both
15:05:21 <Phyx-> but it's still makes me wonder if they can't be solved
15:05:30 <gwern> I'll admit, I didn't expect it to work
15:06:03 <edwardk> Phyx-: well, solving the head matching situation requires backtracking. that can be 'solved' but introduces some potentially explosive compilation times.
15:06:33 <edwardk> but here i think you're screwed. ;)
15:07:12 <ezyang> edwardk: "just put a SAT solver in GHC..."
15:07:21 <edwardk> ezyang: hsh
15:07:24 <edwardk> er hah
15:07:52 <Phyx-> edwardk: would still be handy as a flag, or a way to help guide the compiler along
15:08:10 <dankna> sigh
15:08:15 <dankna> is it bad style to use a Maybe Maybe a?
15:08:22 <edwardk> dankna: no
15:08:32 <dankna> good.  why not? :)
15:08:44 <ezyang> dankna: You have two nullary conditions
15:08:47 <dankna> yeah, I do
15:08:49 <ezyang> which I presume you want to be distinct
15:08:53 <dankna> yes, they need to
15:08:57 <edwardk> dankna: because sometimes you need two levels of conditions. i.e. IntMap (Maybe String)
15:09:00 <Phyx-> edwardk: for instance, I've had really simple instances, one with Num as a constraindt and another one with Functor, but they overlap thanks to only head matching
15:09:01 <dankna> they apply at different levels, heh
15:09:05 <edwardk> lookup returns a Maybe (Maybe String)
15:09:27 <dankna> okay.  I don't take much convincing when you're telling me "do things the easy way that works fine" :)
15:09:28 <edwardk> Nothing says that the key wasn't present, Just Nothing says the key was present but mapped to Nothing
15:09:46 <EvanR> why not just dont story the Nothings and have IntMap String
15:09:55 <EvanR> store
15:10:00 <dankna> EvanR: because sometimes you need that to be distinct :)
15:10:06 <edwardk> EvanR: that depends on if you need to be able to distinguish Just "" from Nothing
15:10:28 <dankna> ie you might be storing the attribute-value pairs of an xml element, which are not really attribute-value pairs because the value is optional
15:10:33 <dankna> that's not what I'm doing, but.
15:10:38 <edwardk> Feel free of course, to replace 'String' in my example with 'a'
15:10:39 <EvanR> you can distinguish Nothing from "" with IntMap String
15:10:44 <dankna> rather, I have the type type Lexer content = DFA (EnumSet content) (Maybe (Maybe ClientExpression)) ()
15:10:59 <edwardk> then an IntMap (Maybe a) has the same issues.
15:11:01 <ezyang> :t mzero
15:11:02 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
15:11:04 <ezyang> :t mempty
15:11:05 <lambdabot> forall a. (Monoid a) => a
15:11:23 <ezyang> hmm, I wonder when you'd want to use mzero but not mempty.
15:11:43 <edwardk> a good example might be [[a]] -- [] and [[]] are units for different monoids on [[a]]
15:11:53 <ezyang> edwardk: Aha!
15:12:19 <dankna> well, thanks edwardk :)
15:12:31 <edwardk> [] is the unit for (++), [[]] is the unit for xxs `mappend` yys = [ xs ++ ys | xs <- xxs | ys <- yys ]
15:12:47 <edwardk> the two together form a right seminearring
15:14:11 <EvanR> semi earring?
15:14:42 <edwardk> > let xxs `times` yys = [ xs ++ ys | xs <- xxs | ys <- yys ] in [["twenty","thirty"]] [["","one","two","three"]]
15:14:43 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[a]'
15:14:46 <edwardk> gah
15:15:40 <edwardk> > let xxs `times` yys = [ xs ++ ys | xs <- xxs, ys <- yys ] in ["twenty","thirty"] `times`["","one","two","three"]
15:15:41 <lambdabot>   ["twenty","twentyone","twentytwo","twentythree","thirty","thirtyone","thirt...
15:16:14 <Itkovian> prolly a stupid question, but if I want to contruct a ReaderT r m a, with something of type r inside it, how do I do this?
15:16:26 <edwardk> EvanR: start ripping properties off of rings, and you get a seminearing ;)
15:17:23 <edwardk> in particular it is a semiring with only a one-sided distributive
15:17:26 <edwardk> law
15:17:39 <dankna> Itkovian: look at runReaderT
15:17:48 <dmwit> Itkovian: ask?
15:17:56 <gwern> hm. how does 'tibbe' work at google?
15:17:56 <dankna> ("There are no stupid questions, only inquisitive idiots.")
15:17:57 <tensorpudding> "i'm writing a paper on modular pseudo-Noetherian seminearings of the second kind"
15:17:57 <Itkovian> dmwit: no, ask is to get the stuff out
15:18:12 <edwardk> Itkovian: ask gives you ReaderT r m r
15:18:21 <dankna> not what he meant
15:18:24 <gwern> tensorpudding: that sounds like a line from a lovecraft story
15:18:25 <dmwit> Itkovian: Then I don't understand the question. Can you rephrase?
15:18:38 <edwardk> tensorpudding: sounds like fun
15:18:42 <dankna> he's asking, I believe, how you invoke an action in the monad from outside it
15:18:56 <edwardk> on runReaderT
15:18:58 <Itkovian> dankna: no, I don't think so
15:19:01 <dankna> no?
15:19:01 <edwardk> @type runReaderT
15:19:02 <lambdabot> forall r (m :: * -> *) a. ReaderT r m a -> r -> m a
15:19:21 <Itkovian> well, maybe I should just ask for a Reader, as it'll amount to the same
15:19:28 <dankna> @type runReader
15:19:29 <lambdabot> forall r a. Reader r a -> r -> a
15:19:35 <dmwit> :t local -- ?
15:19:36 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
15:20:03 <Itkovian> I have something of type r, and I wish to wrap it in the Reader monad, such that the next ask inside the monad returns the thingie of type r
15:20:11 <dmwit> Itkovian: local
15:20:22 <dmwit> Itkovian: If local isn't good enough, then you need State instead of Reader. =)
15:20:38 <dankna> Itkovian: are you already inside the Reader, or not?
15:20:56 <edwardk> Itkovian: you can't do it in the monad you're in , but you can use local to make a nested scope in which 'ask' gives the answer you want
15:21:11 * Itkovian tries to grok that
15:21:13 <edwardk> if you need to change the answer of 'ask' without nesting a scope you should be using State
15:21:23 <edwardk> @type local
15:21:24 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
15:21:28 <Itkovian> I need not change anything, I just wat to create the Reader
15:21:36 <Itkovian> s/wat/want/
15:21:38 <dankna> you don't really "create" a monad
15:21:42 <dankna> you "use" it, I would say
15:21:46 <dankna> or "invoke an action in it"
15:21:57 <edwardk> local (const 12) $ do ... -- inside of ... 'ask' answers with 12.
15:21:58 <Itkovian> right, but you need to put the 'red' thing in the reader, right?
15:22:17 <dmwit> Itkovian: Let's ask another way. What are the types of the values you have, and what is the type of the value you want?
15:22:24 <Itkovian> I mean, how else does the use of the Reader knows what to read when the ask comes up
15:22:37 <dankna> yes, you do; you put it in at the time that you invoke the action in it
15:22:42 <dmwit> Itkovian: from runReader(T)
15:22:47 <edwardk> Itkovian: you put the value in when you call runReader or runReaderT
15:22:52 <edwardk> @type runReader
15:22:53 <lambdabot> forall r a. Reader r a -> r -> a
15:23:05 <dankna> we're giving him the same type signatures over and over :)
15:23:06 <Itkovian> OK, so there's no way to actually 'create' it
15:23:10 <edwardk> runReader (myreadermonadicaction) (thevalueIwantasktogive)
15:23:13 <Itkovian> dankna: yeah :-)
15:23:31 <Itkovian> anyway. types.
15:23:50 <dmwit> dankna: Well, he's asking the same question over and over. =)
15:23:54 <dankna> dmwit: haha fair
15:25:30 <Itkovian> I have a data MollomConfiguration = MollomConfiguration { ... }, a data MollomServerList  = ... and a type MollomMonad = ErrorT MollomError (StateT (Maybe String) (ReaderT  MollomConfiguration (StateT MollomServerList IO)))
15:26:12 <Itkovian> So, to start off, people shoudl have some MollomConfiguration thingie and maybe a MollomServerList, as the MaybeString will be Nothing
15:26:44 <Itkovian> I had thought to have a createMollomMonad :: MollomConfiguration -> MollomServerList -> MollomMonad ()
15:26:51 <Itkovian> but maybe that's not the way to do it?
15:27:00 <dankna> well, a monad is a domain in which computation takes place
15:27:24 <dmwit> Itkovian: wrong direction =)
15:27:28 <dankna> if a function has a return value of type "m ()" where m is a monad type
15:27:35 <dankna> that means the function is an action which can be executed in the monad
15:27:36 <EvanR> mollom...?
15:27:43 <dmwit> Itkovian: You want a runMollomMonad :: MConf -> MServList -> MMonad() -> IO ()
15:27:53 <Itkovian> EvanR: http://mollom.com
15:28:09 <Itkovian> dmwit: OK, that seems to make sense
15:28:38 <dankna> the third parameter to runMollomMonad as dmwit defined it is itself a function, the action you want to run.
15:29:06 <dankna> well, it's not necessarily a function, in that it could have zero arguments; I should just say, it's the action you want to run
15:29:10 <dmwit> Itkovian: A value of type MollomMonad () knows what to do with every possible state and reader value (not *just* the ones you happen to be using to start with), so it makes sense not to tell it those values until the very end.
15:29:30 <dmwit> Itkovian: ...if that makes sense. If it doesn't, it's probably worth just ignoring rather than trying to think about monads in exactly the same way as I do. =P
15:30:23 <Itkovian> It make sense, but the pieces are not falling together completely :-)
15:30:29 <dankna> so supposing you have an action doInterestingMollomThing
15:30:44 <dankna> the type of it would be doInterestingMollomThing :: MollomMonad ()
15:31:05 <dankna> and you want to run it with a configuration called exampleConfiguration and a server list called exampleServerList
15:31:08 <dankna> then you would invoke
15:31:24 <dankna> runMollomMonad exampleConfiguration exampleServerList doInterestingMollomThing
15:31:30 <dankna> and this would cause the action to execute in the monad
15:32:20 <Itkovian> danka right, but the code would need a sequence of actions, depending on what happened in each previous action, so it would :: MMonad a, no?
15:32:36 <dankna> an action can call other actions
15:32:56 <dankna> think in terms of creating one big top-level action that calls your other ones, if that's possible
15:33:05 <Itkovian> because each interesting action returns a value, e.g. if the post is spam ham, whatever ... so the usual usage would be like so
15:33:21 <dankna> then okay
15:33:28 <dankna> the type of runMollomMonad becomes
15:33:47 <dankna> :: MollomConf -> MollomServList -> (MollumMonad a) -> IO a
15:34:39 <Itkovian> do { spamresponse <- checkContent content; case spamresponse of unsure -> do { getCaptcha ; correct <- sendResponse; if correct then publish else perish } }
15:37:12 <Itkovian> so then the above should be executed as argument to a runMMonad?
15:40:30 * Itkovian ponders
15:40:39 <dmwit> > 0xffff
15:40:40 <lambdabot>   65535
15:40:47 <dmwit> > 0xfffff
15:40:48 <lambdabot>   1048575
15:40:57 <dmwit> > 0xffffff
15:40:58 <lambdabot>   16777215
15:41:28 <dmwit> Itkovian: yes
15:41:34 <dmwit> Itkovian: But that case is awfully spurios.
15:41:57 <dmwit> case x of y -> anything === anything { x / y }
15:42:19 <dmwit> (where { x / y } is my notation for substituting x for y wherever y is free in anything ;-)
15:47:47 <dankna> sorry about that - got a phone call
15:49:49 <Itkovian> np
15:49:55 <Itkovian> important things first eh
15:50:09 <EvanR> haskell is more important than all!!!?
15:53:31 <Phyx-> hmm.. you need to get out more then :P no offense :P
15:54:40 <wavewave> hoogle is not working?
15:55:05 <Sgeo> @hoogle a -> b
15:55:05 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
15:55:06 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
15:55:06 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
15:55:36 * Sgeo unsafely Coerces wavewave 
15:55:49 <wavewave> @hoogle isSpace
15:55:52 <lambdabot> Data.Char isSpace :: Char -> Bool
15:55:54 <lambdabot> Data.ByteString.Internal isSpaceChar8 :: Char -> Bool
15:55:56 <lambdabot> Data.ByteString.Internal isSpaceWord8 :: Word8 -> Bool
15:56:05 <wavewave> the web interface seems not working.
15:56:43 <MadHatterDude> Does length evaluate its list argument?
15:57:03 <wavewave> MadHatterDude: I don't think so
15:57:23 <mauke> MadHatterDude: only the spine
15:57:39 <ClaudiusMaximus> > length [undefined, error "boom"]
15:57:40 <lambdabot>   2
15:57:45 <MadHatterDude> ok
15:58:13 <Sgeo> > length [1..]
15:58:17 <lambdabot>   mueval-core: Time limit exceeded
15:58:19 <MadHatterDude> > let l = [undefined, error "boom"] in l `seq` length l
15:58:20 <lambdabot>   2
15:58:37 <Phyx-> does anyone know a large repository of source code/snippets of different languages? need to train my model
15:58:38 <MadHatterDude> Um... *scratches head*
15:58:58 <Sgeo> I guess the list being strict does not imply the contents being so
15:59:10 <mauke> MadHatterDude: a list is either [] or a (:)
15:59:17 <mauke> @src []
15:59:17 <lambdabot> data [] a = [] | a : [a]
15:59:21 <MadHatterDude> Sgeo: I guess you might be right.
15:59:29 <MadHatterDude> Oh, yeah, right
15:59:30 <Sgeo> > let force = a `seq` a in map force [undefined, error "boom"]
15:59:31 <wavewave> that 'seq' does not evaluate the list to normal form
15:59:31 <lambdabot>   Couldn't match expected type `a -> b'
15:59:32 <lambdabot>         against inferred type `Simple...
15:59:43 <Sgeo> > let force a = a `seq` a in map force [undefined, error "boom"]
15:59:44 <lambdabot>   [* Exception: Prelude.undefined
16:00:00 <wavewave> only up to weak head normal form.
16:00:02 <MadHatterDude> Yeah
16:00:09 <Phyx-> right, seq only evaluates till WNHF
16:00:12 <mauke> Sgeo: a `seq` a is the same as a
16:00:16 <Phyx-> ah, beaten
16:00:22 <MadHatterDude> I'm getting the hang of this WHNF
16:01:05 <MadHatterDude> Anyway, should I or should I not make the regex pattern building strict?
16:01:07 <wavewave> To do "full" evaluation, you may need to use DeepSeq .
16:01:13 <Sgeo> Oh, so the reason it crashed is because it tried to display it, rather than the seq?
16:01:14 <EvanR> if i have f, f^-1, g, g^-1, and h = f + g, can i define h^-1 = (f+g)^-1 in terms of f^-1 and g^-1
16:01:32 <dmwit> Usually no.
16:01:45 <EvanR> gah, math sucks :)
16:01:49 <Phyx-> @hoogle deepSeq
16:01:50 <lambdabot> No results found
16:02:45 <ski> EvanR : `h = f + g' meaning ?
16:03:00 <EvanR> h x = f x + g x
16:03:01 <MadHatterDude> What about foldl'?
16:03:06 <ski> `h(x) = sum_{y + z = x} (f(y) + g(z))' ?
16:03:06 <chrisdone> anyone actually used hubris? your experience of it?
16:03:27 <Itkovian> EvanR:  and f . f^-1 == id?
16:03:31 <EvanR> yes
16:07:51 <ski>   inv h x = inv (f+g) x  <=>  (f+g) (inv h x) = x  <=>  f (inv h x) + g (inv h x) = x  <=>  f (inv h x) = x - g (inv h x)  <=>  inv h x = inv f (x - g (inv h x))
16:07:55 <ski> hm
16:08:40 <ski>   <=>  inv h x = fix (\y -> inv f (x - g y))
16:09:18 <ski> (assuming there exist a canonical such fixed-point, which we can choose)
16:09:35 <jmcarthur> ugh... i am making a binding to DevIL. i have an Image newtype wrapper around an image "name" (just an unsigned integer), and i have a finalizer assigned to it that deletes the image once the name becomes unreachable. the problem, though, is that DevIL has a notion of a globally "bound" image on which operations are performed, so it is conceivable that a bound image's name might trigger the finalizer
16:09:36 <jmcarthur> despite being bound. is there anything i can do about this short of removing the finalizer and exposing manual deletion instead?
16:10:05 * ski isn't sure how to think of this, though ..
16:10:23 <jbapple> Does cabal upload work for anybody here?
16:10:39 <jbapple> I keep getting 401 auth errors
16:10:49 <jbapple> Yet I'm sure I have my password correct
16:11:27 <EvanR> ski: so the question is invertSum f f' g g' = ?
16:11:30 <jbapple> (cabal 1.6.0.1)
16:11:47 <ski> what is  f'  and  g'  ?
16:11:50 <ski> derivatives ?
16:11:51 <EvanR> f^-1
16:11:53 <EvanR> g^-1
16:11:54 <ski> or inverses ?
16:12:11 <ski>   invertSum f g = \x -> fix (\y -> inv f (x - g y))
16:12:25 <ski> or, using  f'  and  g'
16:12:30 <EvanR> presumably we cant auto compute f' and g'
16:12:37 <ski>   invertSum f f' g g' = \x -> fix (\y -> f' (x - g y))
16:12:54 <EvanR> it doesnt use g', thats weird
16:13:03 <ski> it doesn't use  f  either
16:13:23 <EvanR> how did you do this >_<
16:13:29 <ski> (you can obviously derive a symmetric formula that uses  f  and  g'  but not  f'  and  g  )
16:13:37 <ski> just formal manipulation
16:13:40 <jmcarthur> i suppose i could create an opaque value upon intializing the library representing the "state" of the library and requiring it as a parameter to the exposed functions, and that value's implementation could be an IORef holding the name of the currently bound image...
16:13:44 <ski> doesn't need to actually
16:13:46 <jmcarthur> that's kind of ugly though
16:13:48 <ski> *mean* anything, though
16:13:56 <EvanR> does it work?
16:14:54 <ski> (specifically, the fix-point need not exist .. or if it does, it might not be unique, and then we might not be able to canonically choose a value for it .. or possibly not in a continuous way, though)
16:15:00 <jargonjustin> In attoparsec, is it possible to create a "peek" parser, which will succeed without consuming any input?
16:15:01 <ski> EvanR : i have no idea :)
16:15:04 <EvanR> lol
16:15:25 <ski> it would depend on assumptions on `f' and 'g', typically, i assume
16:19:04 * hackagebot meldable-heap 1.1 - Asymptotically optimal, Coq-verified meldable heaps, AKA priority queues  http://hackage.haskell.org/package/meldable-heap-1.1 (JimApple)
16:19:34 <EvanR> so its optimal if you have an infinite amount of data
16:21:11 <wavewave> what is the fastest library for reading double number from bytestring?
16:21:19 <jbapple> EvanR: exists c and N such that forall n > N it is within c of optimal.
16:21:19 <jbapple> Maybe?
16:22:02 <mjrosenb> well, since nobody seems to be active in #ghc
16:22:16 <bluetaslem> Um, I have a question regarding "show"
16:22:21 <kmc> go ahead
16:22:24 <bluetaslem> The function, not the Typelcass
16:22:27 <Saizan> wavewave: isn't a function for that in bytestring itself? it might depend on how the double is stored too
16:22:33 <mjrosenb> does anyone know what directories it is safe to remove between building stage1 and stage2
16:22:38 <bluetaslem> What exactly is the interpreter outputting when you do:  show "a"
16:22:56 <Twey> GHCi?  show (show "a")
16:23:00 <mjrosenb> bluetaslem: show is always a function, Show is always the typeclass
16:23:01 <wavewave> Saizan: it's just text format  like 3.14159
16:23:02 <Saizan> mjrosenb: safe to remove for what purpouse (though i don't know anyway)
16:23:34 <Twey> GHCi will automatically âshowâ any non-IO value that results from an evaluation.
16:23:37 <wavewave> Saizan: I read a file to ByteString so now it becomes (Chuck "3.14159" Empty)
16:23:40 <bluetaslem> I was just clarifying, I was trying to avoid someone asking me.
16:23:49 <bluetaslem> But, I mean..
16:23:51 <bluetaslem> Its saying this:
16:24:08 <bluetaslem> Oh, wait....
16:24:11 <bluetaslem> I just noticed..
16:24:15 <bluetaslem> it was confusing me..
16:24:21 <wavewave> Saizan: should I just use read for String? or is there any faster library?
16:24:29 <Twey> > text $ "a"
16:24:30 <lambdabot>   a
16:24:33 <Twey> > text . show $ "a"
16:24:34 <lambdabot>   "a"
16:24:35 <bluetaslem> It was an escape sequence, it made the output hard to read.
16:24:37 <Twey> > text . show . show $ "a"
16:24:38 <lambdabot>   "\"a\""
16:24:57 <Twey> > text $ "ã"
16:24:58 <Saizan> wavewave: ah, there's only readInt, i think there's a bytestring-lex on hackage, not sure about how performant it is
16:24:58 <lambdabot>   ã
16:25:00 <bluetaslem> See what I mean?
16:25:01 <Twey> > text . show $ "ã"
16:25:02 <lambdabot>   "\12354"
16:25:08 <Twey> > text . show . show $ "ã"
16:25:09 <lambdabot>   "\"\\12354\""
16:25:18 <Twey> Clearer?
16:25:29 <Saizan> read is not particularly fast.
16:25:34 <bluetaslem> I understand now.  "\"  represent "  as a character.
16:25:43 <bluetaslem> whoops, I meant:
16:25:44 <Twey> \" does
16:25:46 <bluetaslem> "\""
16:25:50 <bluetaslem> Right.
16:25:52 <Twey> Yes
16:25:53 <Twey> As in most languages
16:25:59 <bluetaslem> Actually..
16:26:01 <bluetaslem> No...
16:26:01 <mjrosenb> Saizan: to cut down on the space that everything occupies while it is building
16:26:03 <twink> IOCB_CMD_POLL never got merged.
16:26:05 <bluetaslem> In most I'm familiar with..
16:26:14 <wavewave> Saizan: thank you. bytestring-lex seems to be what i want
16:26:18 <bluetaslem> You can use the ' around the " to make it... no escape sequence.
16:26:24 <bluetaslem> Like this:  '"'
16:26:28 <bluetaslem> Or, in Lua,  [["]]
16:26:38 <kmc> bluetaslem, when GHCi evaluates something that's not an IO action, it will execute this IO action:   let it = <thing you typed> in print it
16:26:46 <kmc> you will actually see references to the variable "it" in some error message
16:26:53 <bluetaslem> ...
16:27:01 <bluetaslem> YOu're not helping in the slightest..
16:27:16 <kmc> that's the source of your double "show"
16:27:20 * jmcarthur resorts to the unsafePerformIO hack
16:27:26 <bluetaslem> Double?
16:27:31 <bluetaslem> > 5+5
16:27:32 <lambdabot>   10
16:27:36 <bluetaslem> > show "a"
16:27:37 <lambdabot>   "\"a\""
16:27:39 <Twey> bluetaslem: In Haskell, as in C, C++, Java, C#, &c., single quotes denote a character literal.
16:27:42 <bluetaslem> THats what confused me.
16:27:50 <bluetaslem> '"'
16:27:53 <bluetaslem> > '"'
16:27:54 <lambdabot>   '"'
16:27:54 <Saizan> > show (5 + 5)
16:27:55 <lambdabot>   "10"
16:28:07 <kmc> bluetaslem, sorry, i misread Twey's comment as yours
16:28:26 <mjrosenb> bluetaslem: 'f' is the character f, like in C.
16:28:37 <bluetaslem> Yeah..
16:28:40 <kmc> the characters that GHCi outputs when you type «show "a"» are the characters in the string «show (show "a")»
16:28:44 <bluetaslem> But in most othrt languages...
16:28:45 <tensorpudding> @type 'f'
16:28:46 <lambdabot> Char
16:28:46 <mjrosenb> bluetaslem: "f" is the string that has a single character, 'f', in it
16:28:48 <Twey> kmc: Bad encoding
16:28:52 <tensorpudding> @type "f"
16:28:53 <lambdabot> [Char]
16:29:01 <kmc> which are the characters making up a Haskell literal for the string «show "a"»
16:29:03 <bluetaslem> It would have outputted as:  ""a"" and not "\"a\""
16:29:09 <tensorpudding> > 'f' == "f"
16:29:10 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
16:29:10 <lambdabot>         against inferred type...
16:29:11 <kmc> Twey, i think you're the only one who sees them wrong
16:29:14 <mjrosenb> since  '"' is unambiguous, it does not need to be escaped
16:29:19 <dobblego> bluetaslem, in most other languages 'f' is the character f, like in C and most other languages
16:29:35 <bluetaslem> I know.
16:29:42 <Saizan> i've never seen ""a"", actually
16:29:47 <Twey> kmc: Possibly, since I disabled the default Latin-1 fallback on my client
16:30:00 <bluetaslem> But, "  is not considered an escape character (or not displayed as one) when outputted in a string.
16:30:01 <mjrosenb> bash is particularly special w.r.t. '
16:30:10 <bluetaslem> Saizan?
16:30:16 <Cale> > let f x y z = x ++ y ++ z; a = "hello" in f ""a""
16:30:17 <lambdabot>   "hello"
16:30:22 <Cale> ;)
16:30:25 <bluetaslem> The reaosn for that is only haskell shows the quotes around strings when they're outputted..
16:30:31 <bluetaslem> Most other languages chop them off.
16:30:57 <Saizan> really?
16:30:58 <Cale> bluetaslem: use putStr or putStrLn to print a string to the terminal directly
16:31:11 <bluetaslem> Try here:
16:31:11 <chrisdone> oh hell yeah
16:31:16 <mjrosenb> bluetaslem: the point of show is to encode anything that is showable in a way that can be read back by the read function
16:31:16 <bluetaslem> lua.org/demo.html
16:31:19 <chrisdone> the fclabels library is AWESOME
16:31:20 <bluetaslem> print("Hello world")
16:31:23 <Saizan> so you don't see any difference between the number 10 and the string containing the characters "10" at the repl?
16:31:33 <bluetaslem> Yeah.
16:31:34 <Saizan> that's totally different.
16:31:46 <Saizan> try print "Hello world" in ghci
16:31:48 <bluetaslem> C++ is like that in a lot of cases, not always, of coursae.
16:31:49 <Saizan> err,
16:31:52 <bluetaslem> I know what it does.
16:31:55 <mjrosenb> bluetaslem: since you are asking it to show a string, it needs to wrap quotes around it.
16:31:58 <Saizan> putStrLn, rather than print
16:32:00 <Cale> bluetaslem: print will turn Haskell values into usually source-code valid representations of themselves
16:32:05 <bluetaslem> Right, that would make sense..
16:32:21 <bluetaslem> I just expected the quotes to be displayed as quotes, and not as escape sequences.
16:32:34 <Cale> They will be...
16:32:44 <bluetaslem> > show "a"
16:32:45 <lambdabot>   "\"a\""
16:32:49 <bluetaslem> No, they won't.
16:32:57 <kmc> > "a"
16:32:58 <lambdabot>   "a"
16:33:01 <bluetaslem> \"  is an escape sequence.
16:33:05 <Cale> That applies show *twice*
16:33:10 <kmc> bluetaslem, lambdabot already applies "show" to what you type
16:33:12 <kmc> as does GHCi
16:33:16 <Twey> > text $ "\"a\""
16:33:17 <lambdabot>   "a"
16:33:24 <kmc> that's what i was getting at with the «let it = show <thing you typed> in print it»
16:33:28 <kmc> because print = putStrLn . show
16:33:43 <Twey> You can use âtextâ to stop it using the String instance of âshowâ (which escapes characters)
16:33:45 <bluetaslem> Right, but wouldn't it chop the outermost quote soff, then?
16:33:53 <kmc> would what?
16:34:02 <Cale> if you just put  print "a"  into ghci, it will be quoted, but only once, and with no escapes
16:34:02 <bluetaslem> Lambdabot.
16:34:07 <kmc> "show" doesn't treat strings specially.  it turns a string into a Haskell literal for that string
16:34:14 <bluetaslem> I know...
16:34:21 <kmc> lambdabot doesn't treat them specially either
16:34:29 <bluetaslem> I know!
16:34:41 <kmc> so why would you expect the quotes to get chopped off?
16:34:42 <Saizan> there's no chopping
16:34:46 <kmc> that would be special
16:34:50 <Cale> lambdabot doesn't check if the string it's about to show already looks like the show of some string
16:34:51 <mjrosenb> bluetaslem: so what would you rather have happen?
16:34:51 <kmc> > "\""
16:34:52 <lambdabot>   "\""
16:34:55 <kmc> > fix show
16:34:55 <Saizan> we like that string literals gets shown as string literals :)
16:34:55 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
16:35:01 <Cale> > show . show . show . show $ "a"
16:35:02 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"a\\\\\\\\\\\\\\\"\\\\\\\"\\\"\""
16:35:07 <chrisdone> > ("foo",read . show $ "foo") :: (String,String)
16:35:08 <lambdabot>   ("foo","foo")
16:35:13 <mjrosenb> Cale: any ideas about ghc?
16:35:19 <bluetaslem> I would prefer it display (show "a")  as ""a"" than as "\"a\""
16:35:27 <Cale> mjrosenb: What kind of ideas?
16:35:55 <Cale> bluetaslem: But that wouldn't be valid code.
16:36:08 <bluetaslem> It would be valid output.
16:36:10 <Cale> bluetaslem: "" is an empty string, a would then be a variable outside the string
16:36:18 <Cale> and then "" would be another empty string
16:36:19 <kmc> bluetaslem, "show" is supposed to produce Haskell source code
16:36:20 <kmc> when possible
16:36:25 <bluetaslem> http://www.lua.org/demo.html
16:36:34 <kmc> i don't really care what lua does
16:36:36 <bluetaslem> print( [[  " " """ """ "" """ """ ]])
16:36:41 <bluetaslem> My point is this:
16:36:49 <bluetaslem> It works in other languages, so it IS possible.
16:37:06 <kmc> okay
16:37:11 <Cale> " " """ """ "" """ """ is a type error
16:37:14 <MadHatterDude> bluetadlem: Haskell is not other languages... Haskell is haskell
16:37:16 <bluetaslem> Not in Lua.
16:37:19 <kmc> the rule in Haskell is simple and consistent
16:37:22 <Twey> Of course it's possible.  It's just not logical.
16:37:29 <bluetaslem> It is to me.
16:37:37 <Cale> " " is the string of length 1 containing a space, and it's being applied as if it were a function to:
16:37:40 <Cale> "" the empty string
16:37:42 <kmc> we generally care more about simple and consistent rules than about making everything superficially pretty
16:37:43 <bluetaslem> Just curious..
16:37:43 <Cale> " "
16:37:51 <Cale> and then another empty string
16:37:53 <mjrosenb> bluetaslem:does that parse as many strings, one after another>?
16:37:54 <MadHatterDude> bluetaslem: The space is not insignificant in haskelll
16:37:55 <bluetaslem> Does Haskell have any way to generate new types/typeclasses?
16:37:57 <Cale> and so on...
16:38:00 <kmc> bluetaslem, "generate"?
16:38:01 <Saizan> haskell probably didn't want to add another keyword to delimit strings with " in them
16:38:03 <tensorpudding> Though simplicity and consistency are usually kinda pretty?
16:38:06 <bluetaslem> Create your own.
16:38:09 <kmc> yes of course
16:38:17 <kmc> it's fundamental
16:38:20 <bluetaslem> Theoretrically, could it make one thats "nothing"?
16:38:22 <tensorpudding> I guess Lazy K is the simplest, prettiest functional language
16:38:27 <bluetaslem> *Theoretically.
16:38:30 <kmc> in fact most of the "built in" types are not special
16:38:39 <kmc> they are declared in the standard library, the same way you can declare your own
16:38:43 <kmc> some of them have syntactic sugar
16:38:51 <kmc> but they generally have the same semantics as user-defined types
16:38:58 <Twey> bluetaslem: It's not logical, because that output would not be a valid string literal â you'd be inventing a magic new language.  That's not what âshowâ does â it attempts to format values as valid Haskell.
16:39:00 <Saizan> what do you mean by nothing?
16:39:00 <kmc> e.g.  data List a = Nil | Cons a (List a)
16:39:09 <kmc> that's entirely equivalent to the type [a]
16:39:15 <bluetaslem> A type that has no values in it..
16:39:16 <kmc> modulo special syntax
16:39:22 <kmc> bluetaslem, with a GHC extension
16:39:24 <kmc> you can declare such a type
16:39:24 <Twey> bluetaslem: It's called âVoidâ
16:39:37 <Cale> bluetaslem: The general rule is that you should be able to copy the output from 'print' and paste it into your source code directly if you want.
16:39:38 <kmc> except you can still write non-terminating or exception-throwing expressions that have that type
16:39:42 <Saizan> data Nothing = Nothing !Nothing; also
16:39:43 <MadHatterDude> bluetaslem: data Nothing = Nothing? thats not very useful
16:39:54 <kmc> but that type has one value
16:39:55 <Twey> MadHatterDude: That has a value in it
16:39:56 <tensorpudding> data [a] = [] | (:) a [a], if such syntax were allowed at all
16:39:59 <MadHatterDude> bluetaslem: You mean like nil?
16:40:03 <Cale> bluetaslem: There are a number of exceptions to this, but generally people try to avoid it
16:40:06 <Twey> nil has a value in it
16:40:16 <bluetaslem> I like learning about totally useless information.... Its more enjoyable than learning practical information. :P
16:40:17 <MadHatterDude> Twey: Yeah, a null pointer.
16:40:24 * chrisdone doesn't want to hear about null values in haskell
16:40:34 <chrisdone> >:3
16:40:38 <Twey> MadHatterDude: Well, if we're talking about Lua nil, it actually is a value.
16:40:47 <Twey> Not a pointer.
16:40:48 <tensorpudding> Can you make null pointers using the FFI?
16:40:49 <bluetaslem> Yeah, Lua's nil is a type and a value.
16:40:51 <kmc> tensorpudding, yes
16:40:52 <MadHatterDude> chrisdone: You don't have to, we're discussing lua, me an' Twey
16:40:57 <Saizan> tensorpudding: nullPtr
16:40:59 <kmc> tensorpudding, you need to for many C functions
16:41:05 <kmc> you can segfault GHCi in one line using Foreign
16:41:11 <Cale> tensorpudding: nullPtr  :: Ptr  a
16:41:11 <bluetaslem> for instance, nil == nil
16:41:14 <jmcarthur> i find that i want this function fairly often: Bool -> a -> Maybe a
16:41:18 <kmc> it really gives you all of the foot-shooting power of C
16:41:44 <tensorpudding> Haskell, you can have your foot and shoot it too, but only when you want to.
16:41:45 <Twey> jmcarthur: (Just ?? const Nothing)
16:41:55 <hosebeast> Hey, can someone school me on type constructors vs. data constructors?  I'm trying to do something like this: http://pastebin.org/144968
16:42:10 <jmcarthur> yeah basically
16:42:13 <kmc> hosebeast, what's your question?
16:42:17 <Twey> hosebeast: Type constructors construct types.  Data constructors construct values.
16:42:19 <jmcarthur> :t (??)
16:42:20 <lambdabot> Not in scope: `??'
16:42:24 <jmcarthur> @hoogle (??)
16:42:24 <lambdabot> No results found
16:42:26 <chrisdone> :t guard
16:42:27 <hosebeast> It says there's no type constructor for Num in my code.
16:42:27 <jmcarthur> :(
16:42:27 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
16:42:39 <jmcarthur> hmm, guard...
16:42:40 <chrisdone> :t guard True :: Maybe ()
16:42:41 <lambdabot> Maybe ()
16:42:43 <hosebeast> I'm confused! :-O
16:42:43 <bluetaslem> Is there a built-in Typeclass for positive numbers?
16:42:43 <kmc> hosebeast, Num is not a type
16:42:44 <chrisdone> hmm
16:42:48 <kmc> hosebeast, it's a type class
16:42:55 <Twey> bluetaslem: There is Word
16:42:58 <kmc> you should probably pick a concrete numerical type like Integer or Double
16:43:00 <bluetaslem> Word?
16:43:06 <jmcarthur> :t \p x -> x <$ guard p
16:43:07 <lambdabot> forall a (f :: * -> *). (MonadPlus f, Functor f) => Bool -> a -> f a
16:43:12 <kmc> bluetaslem, there's no type class for positive numbers
16:43:15 <kmc> bluetaslem, there are various types though
16:43:18 <MadHatterDude> hosebeast: use Int instead of Num
16:43:20 <Twey> Oh, yes, not a typeclass
16:43:22 <jmcarthur> :t \p x -> x `liftM` guard p
16:43:23 <tensorpudding> You can think of typeclasses as interfaces.
16:43:23 <lambdabot> forall r (m :: * -> *). (MonadPlus m) => Bool -> (() -> r) -> m r
16:43:28 <Twey> Not 'til we sort out the Num monstrosity
16:43:28 <bluetaslem> Hm..
16:43:32 <hosebeast> What is Int?
16:43:33 <kmc> hosebeast, if you need it to be generic, you need to add a parameter to WAE
16:43:38 <hosebeast> A Type?
16:43:39 <bluetaslem> Is it possible for a type to SOMETIMES belong t a Typeclass?
16:43:44 <jmcarthur> woops
16:43:46 <bluetaslem> not always, not never?
16:43:47 <kmc> i.e. data WAE n = LNum n | LAdd (WAE n) (WAE n) | ...
16:43:48 <Twey> bluetaslem: No
16:43:53 <kmc> bluetaslem, how would that work
16:43:53 <bluetaslem> Hm...
16:43:55 <kmc> hosebeast, yes
16:43:57 <hosebeast> Oh
16:43:59 <tensorpudding> You define a Integer, and it is able to implement the typeclass Num
16:44:01 <kmc> hosebeast, Int is the type of machine-size integers
16:44:03 <bluetaslem> Positive/Negative numbers is one example...
16:44:08 <tensorpudding> It also implements Integral, and Ix, and a ton of other things
16:44:08 <kmc> hosebeast, easier to use Integer
16:44:13 <kmc> hosebeast, which never overflows, unlike Int
16:44:19 <Twey> If it doesn't always implement a specific typeclass, then it doesn't implement it reliably.  You'd get random runtime errors â it breaks the type system.
16:44:31 <kmc> bluetaslem, you're talking about whether a value is in a particular set
16:44:32 <bluetaslem> True...
16:44:35 <kmc> typeclasses are sets of *types* not of values
16:44:36 <jmcarthur> would be nice to have guard for Alternative
16:44:43 <hosebeast> But then how do I define calc (LNum n)?
16:44:48 <kmc> hosebeast, the same way
16:44:48 <bluetaslem> Perhaps, then someone could write a special extension for people like me who'd appreciate it..
16:44:50 <hosebeast> Wait
16:44:51 <Saizan> ?faq is it possible to ... ?
16:44:51 <lambdabot> The answer is: Yes! Haskell can do that.
16:44:52 <hosebeast> Not that
16:44:53 <kmc> err
16:44:53 <hosebeast> Sorry
16:44:57 <kmc> hosebeast, yes, the same way
16:45:11 <hosebeast> Let me explain, 'cause I tried Integer already.
16:45:21 <Twey> bluetaslem: No, it *doesn't make sense*.
16:45:43 <chrisdone> jmcarthur: http://hackage.haskell.org/packages/archive/higherorder/0.0/doc/html/Data-Bool-Higher.html
16:45:46 <Twey> Typeclasses are a compile-time constraint.  You don't know until runtime what a value will be.
16:45:49 <bluetaslem> I know how to make it make sense...
16:45:54 <kmc> it would make sense with dependent types :)
16:45:55 <bluetaslem> Although its ridiculously complex..
16:45:55 <hosebeast> The type of 1 + 2 is not an Integer.
16:46:05 <hosebeast> How do I define calc (LAdd l r)?
16:46:06 <Twey> Dependent types are perhaps what you're looking for.
16:46:12 <kmc> hosebeast, it depends on what the types of 1 and 2 are
16:46:14 <jmcarthur> chrisdone: thanks. i just went ahead and used guard this time
16:46:18 <pikhq> bluetaslem: What you ask is, in essence, "could I make Haskell not type-safe? I like more failures."
16:46:19 <chrisdone> sure
16:46:30 <kmc> hosebeast, are you sure you don't want:   eval :: WAE -> Integer
16:46:34 <kmc> eval (LNum n) = n
16:46:43 <kmc> eval (LAdd l r) = eval l + eval r
16:46:55 <bluetaslem> Imagine the ability for the interpreter to constantly create types that are duplicates of each other, and implicitly convert them automatically, so that types coudl switch Typeclasses, so that there could be a "Sometimes/Maybe" way to declare a Function/Value type.
16:47:03 <hosebeast> I think you're right.
16:47:28 <hosebeast> What am I trying to do? XD
16:47:31 <pikhq> bluetaslem: "Could I make Haskell not type-safe? I like more failures."
16:47:35 <hosebeast> Go from a Type to a Type?
16:47:37 <Twey> bluetaslem: Of course, you can do that, by simply using Data.Dynamic or whatever.
16:47:39 <Cale> bluetaslem: Uh, there are types like  Maybe (a -> b)
16:47:49 <Twey> You just lose half the power of Haskell.
16:47:55 <pikhq> Or, yes, Maybe (a -> b)
16:48:37 <Cale> It's even actually convenient to use values of type Maybe (a -> b), in conjunction with the Control.Applicative operators
16:48:49 <Cale> > Just reverse <*> Just "hello"
16:48:50 <lambdabot>   Just "olleh"
16:48:53 <MadHatterDude> bluetaslem: You must throw away thine casts and thy dynamic typing in order to truly understand haskell
16:48:54 <Cale> > Just reverse <*> Nothing
16:48:54 <Twey> > Just succ <*> Just 3
16:48:55 <lambdabot>   Nothing
16:48:55 <lambdabot>   Just 4
16:49:04 <Cale> > Nothing <*> Just "hello"
16:49:05 <lambdabot>   Nothing
16:49:07 <Veinor> > reverse <$> Just "Hello"
16:49:07 <lambdabot>   Just "olleH"
16:49:14 <mun> does anyone know why higher-order logic is needed to logically formalise the real numbers?
16:49:49 <edwardk> mun did you try ##logic?
16:49:55 <Cale> mun: Well...
16:50:04 <kmc> mun, because the principle of induction is an axiom schema over all well-formed formulae?
16:50:15 <kmc> if you want to write it as a single axiom, you need second-order quantification
16:50:29 <kmc> but usually people are happy to do first-order logic with infinite (but r.e.) axiom sets
16:50:30 <MadHatterDude> @pl let f x (l, h) = (l * x, h * x) in \n x -> f x (n, n)
16:50:31 <lambdabot> flip ((`ap` snd) . (. fst) . ap (flip . (((.) . (,)) .) . (*)) (*)) . join (,)
16:50:35 <Cale> mun: Initially, the first reason that it's not easy (not a proof that it can't be done) is that you have the least upper bound principle
16:50:46 <Cale> The ordered field axioms are of course first order
16:50:52 <mjrosenb> also, because you cannot define the real numbers without reasoning about limits of infinite sequences
16:50:56 <edwardk> mun: in short the supremum property is what trips you up
16:51:03 <Cale> (you can put things in terms of the <= relation and the algebraic operations)
16:51:14 <mun> right
16:52:29 <Cale> There's a theorem, called the downward LÃ¶wenheim-Skolem theorem
16:52:35 <tomoj> doesn't the fact that there are uncountably many reals already leave you screwed?
16:52:37 <tomoj> ah, yeah
16:52:51 <Cale> which says that any countable first order theory with a model has a countable model
16:53:15 <Cale> and if the theory is supposed to characterise the real numbers, then the only model should be uncountable
16:53:27 <Cale> So no countable first order theory can possibly do it.
16:53:29 <edwardk> cale++
16:53:32 <mun> so why does the supremum property require second order?
16:53:34 <kmc> nice
16:53:48 <Cale> Well, it's directly second order: it's a property of sets of real numbers
16:53:53 <edwardk> mun: because you need to be able to say 'forall sets there exists ...
16:54:14 <Cale> Every nonempty set of real numbers which is bounded above has a least upper bound
16:55:34 <Cale> The interesting thing here is that it applies even to infinite sets of real numbers -- objects which you couldn't express finitarily in terms of individual particular real numbers
16:57:06 <Cale> So, for example, even the set of all real numbers x for which x^2 < 2, which is nonempty, since 1^2 < 2, and has an upper bound, since if x > 2, then x^2 > 2^2 = 4 > 2
16:57:48 <Cale> and this essentially shows that the square root of 2 must exist, something which doesn't hold in the rationals
16:57:58 <jbapple> But you could, if you wished, describe what a "set of real numbers" is in a first-order way, no?
16:58:09 <Cale> This is not to say that there aren't first order theories in which there are square roots
16:58:10 <Veinor> @pl \n x -> (n * x, n * x)
16:58:10 <lambdabot> ap (ap . ((,) .) . (*)) (*)
16:58:24 <Cale> But any first order theory will effectively leave out some reals
16:58:34 <Cale> because it will have a countable model, and the reals are not countable
16:59:00 <mun> Cale, is the rationals countable?
16:59:11 <twink> SamB_XP: LSD was what I took, the stomach acid was the "unintended consequence."
16:59:24 <SamB_XP> twink: uh, we were talking in -blah
16:59:28 <Cale> mun: yes
16:59:38 <jbapple> But there are FO models of the reals in which "the reals are not countable" is provable, even though, from outside the model, they are, right?
16:59:51 <edwardk> forall nonempty sets A. (there exists z in R such that forall w in A, w <= z) -> (there exists an x such that forall y. [w in A => w <= y) <=> x <= y. -- this gives us x as the least upper bound, but note the second order formulation.
16:59:53 <Saizan> can you define the reals in ZFC?
17:00:14 <Cale> jbapple: You can do something completely different from what we're talking about and have a first order set theory, like ZFC, and define the reals inside that set theory
17:00:17 <twink> I think Newton's method for square roots might do something useful.
17:00:24 <MadHatterDude> is there a way to turn (Just s) into (Nothing) and (Nothing) into (Just "") without a conditional?
17:00:47 <jbapple> mun: http://www.cs.nott.ac.uk/~rcb/MPC/RecountingRationalsTwice.pdf counts the rational number in Haskell
17:00:56 <Cale> But that's not what we're talking about... we're talking about first order theories where the quantifiers quantify over real numbers, not over sets
17:01:01 <edwardk> MadHatterDude: maybe (Just "") (const Nothing) internally uses the conditional though
17:01:40 <mjrosenb> is there some nice way of installing packages from hackage on ubuntu?
17:01:41 <jbapple> Cale: fair enough. Sorry to come in on the end and miss the context
17:02:00 <mjrosenb> as in prefferably using the apt system
17:02:08 <Cale> So, perhaps to be more precise about it, if you take any first order theory, and try to form a model of it whose universe is a subset of the real numbers, and where the interpretations of the algebraic and order operations are the usual operations on the real numbers, the only possible models are *proper* subsets of the reals
17:02:16 <Cale> er...
17:02:20 <Cale> no, that's wrong
17:02:41 <Cale> Every theory with a model, will have a model which is a proper subset of the reals
17:02:43 <Cale> better :)
17:03:02 <mjrosenb> Cale: the only possible models that are subsets of the reals are proper subsets of the reals?
17:03:06 <Cale> So no first order theory will really ensure the existence of all the real numbers
17:03:16 <mjrosenb> Cale: can't you model the gaussian integers?
17:03:18 <jbapple> I am suspicious of second-order logic :-)
17:03:22 <Cale> mjrosenb: I was wrong in the first case there
17:03:57 <mjrosenb> oh, whose universe is a subset of the reals
17:04:00 <mjrosenb> totally missed that.
17:04:02 <Cale> mjrosenb: *If* there is a model of some theory, perhaps using the whole set of real numbers, *then* there will be a model of that same first order theory which only uses a countable subset
17:04:30 <Cale> and so in that sense, no first order theory ensures the existence of all the real numbers
17:04:39 <tomoj> I wonder if all the nonstandard uncountable models of the reals have uncomputable operations?
17:05:14 <Cale> jbapple: Then all you have to do is use first order set theories.
17:05:30 <Cale> jbapple: and define the reals and so on as particular sets inside those :)
17:05:32 <mjrosenb> tomoj: i would say yes, just due to the fact that there are only a countable number of computable numbers
17:05:45 <mjrosenb> *countable number of computable anything
17:07:02 <mjrosenb> there isn't an ubuntu package for cabal-install.  how cute
17:07:18 <tomoj> mjrosenb: of course
17:07:28 <mjrosenb> also, i'm guessing that there isn't an equivalent to hackports
17:07:47 <mjrosenb> which will make a .deb out of thecabal stuffs
17:08:14 <MadHatterDude> Solving type errors at 2 am... Story of my life...
17:09:00 <mun> thanks guys
17:09:13 <Saizan> mjrosenb: there's a cabal-to-deb thing, and some well hidden deb repo
17:10:10 <mjrosenb> ghc --version
17:10:11 <mjrosenb> The Glorious Glasgow Haskell Compilation System, version 6.8.2
17:10:14 <mjrosenb> great
17:10:25 <Cale> Roughly the way that the LÃ¶wenheim-Skolem theorem works is by noticing that there are only countably many existence statements you can make in a countable first order theory, and if you're careful about how you do it, you can apply the axiom of choice and choose a set of elements from your model to serve as witnesses to those existence statements.
17:10:25 <mjrosenb> apt also says that this is the newest version available
17:10:29 <mjrosenb> great.
17:10:59 <Cale> (that's perhaps a bit glib, but that's the idea behind it anyway)
17:11:33 * ski wonders about modelling sets with Vladimir Voevodsky's Homotopy Lambda Calculus
17:11:50 <ski> s/sets/real numbers/
17:12:05 <Cale> Did you find a real description of how it works?
17:12:25 <mjrosenb> ski: just use the surreal numbers, and all your numbers *are* sets
17:12:37 <ski> not that i know (i have only watched a video, so far, not tried to read the paper(s))
17:12:42 <Cale> mjrosenb: All your numbers are sets in standard mathematics as well
17:13:16 <mjrosenb> Cale: but you get, all of the real, infintesmal and infintie cardnals for free
17:13:22 <mjrosenb> *infinite
17:13:24 <ski> the problem is that one could possibly define functions which aren't extensional over the real numbers
17:13:26 <MadHatterDude> @src on
17:13:26 <lambdabot> (*) `on` f = \x y -> f x * f y
17:13:27 <ski> iiuc
17:13:46 <ski> so, one gets too many functions
17:14:09 <Saizan> yo dawg i heard you like sets so we put sets in your numbers so you can check membership while you calculate?
17:14:16 <Cale> mjrosenb: In particular, the reals are often defined as particular sets of rational numbers, and each rational as a particular set of pairs of integers, and each integer as a particular set of pairs of naturals, and each natural as an ordinal, which is a set whose only elements are subsets of itself.
17:14:57 <mjrosenb> Cale: aren't the reals defined as the limit of sequences of rationals?
17:15:09 <Cale> That's an alternative method
17:15:25 <dcoutts_> Anyone here use Windows with a non-English code page?
17:15:40 <dcoutts_> apparently cabal is doing funny thing in Japanese
17:15:52 <Cale> Well, equivalence classes of Cauchy-sequences of rationals
17:16:05 <Cale> So sets of sequences
17:16:13 <dcoutts_> Saizan: good try ;-)
17:16:28 <ski> (mjrosenb : in arbitrary toposes (with some extra structure, which i forget), those two ways are generally not isomorphic)
17:17:17 <mjrosenb> Cale: butdata  Surreal = Number [Surreal] [Surreal] is so much prettier
17:17:29 <dcoutts_> mjrosenb: btw, there's a cabal->deb tool somewhere
17:17:42 <Cale> Try defining the operations on them and see if it's still pretty ;)
17:17:42 <mjrosenb> dcoutts_: so i have heard.
17:17:48 <Cale> Well, okay, it's still somewhat pretty
17:17:54 <Cale> But the operations are really non-obvious
17:18:12 <mjrosenb> adding is obvious
17:18:14 <Cale> Also, not every such value is a surreal number
17:18:14 <MadHatterDude> "Couldn't match expected type 'a' agains inferred type 'b'" a and b have the smae restraints, I swear!
17:18:16 <mreh> how do most people do fast fourier transforms in their haskell work here?
17:18:18 <mjrosenb> multiplying is not.
17:18:33 <Cale> You have to ensure that all the values in the left set are less than the values in the right set
17:18:51 <Cale> and you also need full sets of surreals, not just countable sets
17:18:53 <Saizan> MadHatterDude: the joy of universal quantification
17:18:54 <ski> MadHatterDude : restrain yourself
17:18:57 <stevenmarky> I don't even do slow fourier transforms.
17:19:09 <ski> MadHatterDude : (seriously), what's the code ?
17:19:11 <mjrosenb> Cale:true.
17:19:23 <alpounet> mreh, there's a binding of libfftw out there on hackage
17:19:23 <mjrosenb> Cale: also, you can have a bunch of non-canonical numbers as well.
17:19:26 <alpounet> iirc
17:19:26 <mreh> stevenmarky: I'll take any discrete fourier transform algorithm
17:19:33 <Cale> mjrosenb: yeah
17:19:40 <mreh> alpounet, cooool
17:19:44 <mjrosenb> Cale: but we can ensure all of that in the constructors
17:19:51 <mjrosenb> Cale: and hide Number
17:19:54 <Cale> mjrosenb: There are probably Set-many representations of any given surreal number :)
17:20:16 <mreh> alpounet, unable to locate, have an idea what it's called
17:20:17 <alpounet> hmm mreh http://hackage.haskell.org/package/pure-fft
17:20:25 <alpounet> it's not a binding actually
17:20:33 <mjrosenb> why does ubuntu not wat to install a newer ghc
17:20:35 <mjrosenb> :(
17:20:45 <Cale> Well, if you want all the really large and really small surreals, it doesn't really do to construct them in only a fixed set of "safe" fashions
17:20:46 <mreh> yeah, cool-aid turkey, that's what I wanted
17:20:52 <alpounet> and http://hackage.haskell.org/package/fft here is the binding
17:20:52 <Cale> You'll always miss some out
17:20:54 <MadHatterDude> ski: follow :: Pattern -> Pattern -> Pattern; toPattern :: (Patternelem a) => a -> Pattern; follow `on` toPattern :!: (Patternelem a, Patternelem b) => a -> b -> Pattern
17:20:57 <alpounet> in case you want to try it too
17:21:01 <bluetaslem> I think I'm being really forgetful, but..
17:21:09 <mreh> alpounet, thanks
17:21:16 <bluetaslem> How do you get the n'th member of a list?
17:21:22 <mjrosenb> Cale: you can let them be the fixed points of operations involving themselves
17:21:27 <mjrosenb> bluetaslem: !!
17:21:30 <alpounet> you're welcome
17:21:43 <Cale> mjrosenb: Some of them are larger than any computable notation will give you
17:21:44 <bluetaslem> That is to say...
17:21:54 <stevenmarky> > [1,2,3] !! 1
17:21:54 <alpounet> bluetaslem:
17:21:55 <lambdabot>   2
17:21:56 <Cale> mjrosenb: After all, any computable notation can only give you finitely many such things.
17:21:57 <alpounet> @type (!!)
17:21:58 <lambdabot> forall a. [a] -> Int -> a
17:22:01 <Cale> er, blah
17:22:05 <Cale> countably many of course
17:22:06 <bluetaslem> A built-in function, I could obviously do:  last take n list
17:22:08 <dolio> Surreal numbers miss out on a lot of pretty ordinary numbers if you try to do them computably, no?
17:22:09 <yuriks_> what pastebin should I use? the one on the topic is down
17:22:23 <Cale> dolio: That I'm not sure
17:22:25 <bluetaslem> Hm.
17:22:27 <bluetaslem> THanks..
17:22:31 <alpounet> bluetaslem, "your_list !! n"
17:22:34 <bluetaslem> Isn't that a weird operator to use, though?
17:22:42 <Cale> dolio: I would tend to think you could get all the computable reals, but perhaps I'm wrong.
17:22:45 <Saizan> yuriks_: pastebin.com is fine
17:22:56 <alpounet> but needing it that much is a sign that you're maybe using the wrong data structure
17:23:06 <mjrosenb> Cale: i think there are issues with anything that is not of the forrm x/2^y
17:23:16 <Cale> bluetaslem: Getting the nth element of a list is a weird thing to do in the first place
17:23:17 <alpounet> random access is more efficient with arrays/vectors
17:23:37 <ski> MadHatterDude :   follow `on` toPattern  will have type  Patternelem a => a -> a -> Pattern
17:23:37 <Cale> bluetaslem: Lists are things that you generally want to perform collective operations on
17:23:49 <kmc> lists are really more about control flow than data flow
17:23:56 <dolio> Cale: I guess you might be able to get up to S_omega.
17:24:00 <mreh> I don't get it, the implementation of the discrete fourier transform accepts a list of Complex Doubles
17:24:03 <dolio> Or something like it.
17:24:06 <kmc> we glue together a list producer and a list consumer to make a coroutine
17:24:08 <mreh> should they be signed integers
17:24:10 <Cale> bluetaslem: Think of them like loops in an imperative language. Running just the nth iteration of a loop would be strange, ordinarily.
17:24:12 <kmc> and often no explicit list is created in memory
17:24:17 <kmc> Cale, good analogy
17:24:25 <ski> MadHatterDude : if haskell had first-class existentials, then maybe, you'd get the type you wanted there .. but that's not how haskell works (atm)
17:24:25 <Cale> There are cases where you might want to do it, but it's an odd thing to want to do
17:25:04 <yuriks_> http://pastebin.com/3ajG4dZp
17:25:08 <dolio> Cale: You need S_omega to get some rational numbers, though, if I'm reading wikipedia right.
17:25:17 <yuriks_> what's up with that error? I can't for the life of me figure out how to fix it
17:25:40 <mjrosenb> oh yeah, someone had an article on strictness as a fundamental part of algorithms, not a "speed optimization"
17:25:41 <ski> MadHatterDude : the problem is that `toPattern' is passed monomorphically to `on', so it passes not a function of type `forall a. Patternelem a => a -> Pattern' to `on', but a function of type `a -> Pattern' (for a given type parameter `a')
17:25:41 <Cale> dolio: What does S_omega denote here?
17:25:49 <ski> @type on
17:25:50 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
17:25:51 <mjrosenb> does anyone know what article that is?
17:25:52 <dolio> Cale: The omega-th iteration of the surreal construction.
17:26:12 <mreh> yuriks_, e is not in scope
17:26:14 <Cale> dolio: Many countably infinite things are okay, we can use fixed points to get at them
17:26:25 <BMeph> mjrosenb: The Onion, perhaps? ;
17:26:32 <BMeph> )
17:26:34 <kmc> yuriks_, your typeclass doesn't relate "t" and "e" in any way
17:26:37 <mjrosenb> dolio: yes, with finite many operations, you can only get x/(2^y)
17:26:42 <Cale> dolio: But there comes a point between omega and omega_1, the first uncountable ordinal, where computability breaks down
17:26:47 <kmc> you probably want:  search :: (Ord e) => t e -> e -> Maybe e
17:26:50 <dolio> Right.
17:26:57 <kmc> insert :: t e -> e -> t e
17:27:00 <mreh> yuriks_, I think your definition of trees is a bit confused
17:27:04 <kmc> remove :: t e -> e -> (Maybe e, t e)
17:27:10 <bluetaslem> Anyone here interested in Google CodeJam?
17:27:13 <mjrosenb> Cale: i suspect that many operations with infinite anything in the surreal numbers will be sad.
17:27:18 <mjrosenb> bluetaslem: yo.
17:27:33 <mjrosenb> bluetaslem: i did it in 2008, but totally forgot about it in 2009
17:27:37 <mjrosenb> now that i think about it
17:27:38 <bluetaslem> :P
17:27:51 <mjrosenb> i was knocked out in 2008 because i slept through my time slot
17:27:58 <bluetaslem> Hey, just curious... Which languages usually win?
17:28:01 <mreh> isn't the codejam a recruitment campaign for google?
17:28:05 <bluetaslem> Yes.
17:28:13 <kmc> isn't the internet a recruitment campaign for google?
17:28:14 <mreh> and they get to steal your ideas
17:28:15 <Cale> yuriks_: Your type for insert says that *no matter which type of element* e that I want to insert into the tree of type t, I can do it.
17:28:16 <bluetaslem> But its also a compeittion, $100 for 4th-25th places.
17:28:22 <mjrosenb> mreh: also, gives money
17:28:34 <yuriks_> Cale: oh
17:28:36 <kmc> yuriks_, if you can't live with the constraint that every tree type is a 1-parameter type constructor parametrized by the element type, you'll need something fancier like multiparam typeclasses with functional dependencies, or associated types (preferred imo)
17:28:37 <Cale> yuriks_: So the elements that I insert wouldn't be constrained to have the same type, and so (==) might be meaningless
17:28:45 <bluetaslem> Ad the problems aren't very helpful for forwarding their business, especially sicne all of them need to be solved already by them in order to check your answers.
17:28:50 <mreh> $100 dolars is worth much in my currency!
17:29:03 <bluetaslem> What's your currency?
17:29:13 <mreh> the pound, it's broken
17:29:26 <bluetaslem> I see, inflation?
17:29:28 <kmc> GBP?
17:29:35 <mreh> GBP
17:29:44 <kmc> GBP ain't what it used to be
17:29:54 <mreh> that's good if you're earning dollars!
17:30:09 <Cale> yuriks_: There are a number of ways around this problem, the simplest of which is just to assume that the type t in the definition of the Tree class is not a plain type, but a parametric one, and has a type parameter e
17:30:17 <mreh> what's the criteria for code jam, I'm too lazy to find out myself
17:30:23 <Cale> yuriks_: So the type of insert would become  insert :: t e -> e -> t e
17:30:23 <bluetaslem> Not much....
17:30:31 <bluetaslem> 13+ in age, few other things..
17:30:38 <bluetaslem> You can't live in Quebec, its illegal there.
17:30:42 <bluetaslem> Um..
17:30:49 <bluetaslem> And you have to go to their site and register to compete.
17:30:50 <Cale> yuriks_: Another way is to use a multiparameter typeclass, probably with a functional dependency (but this is a language extension)
17:30:57 <Cale> That would look like:
17:31:00 <bluetaslem> You can still see the older problems though, in their archives.
17:31:19 <Cale> class (Eq t, Eq e, Show t) => Tree e t where ...
17:31:26 <yuriks_> Cale: assuming t is parametric is fine with me
17:31:37 <Cale> or:
17:31:40 <Cale> class (Eq t, Eq e, Show t) => Tree e t | t -> e where ...
17:31:53 <Cale> (saying that the type t uniquely determines the element type e)
17:32:00 <yuriks_> but search :: t e -> e -> Maybe e didn't work either
17:32:09 * ski waits for Cale to finish off with associated data types
17:32:17 <yuriks_>  Kind error: `t' is applied to too many type arguments
17:32:38 <ski> yuriks_ : you need to either use `t' or `t e', consistently
17:32:43 <Cale> yuriks_: Make sure that you've applied t to a type parameter everywhere that it occurs
17:32:45 <mreh> i'm thinking I have no chance, but I'll give it a whirl
17:32:55 <yuriks_> Cale: I did, as far as I can see
17:33:02 <mreh> it's during the tail end of my exams, but to hell with it
17:33:06 <Cale> Including in the (Eq t) part
17:33:17 <ski> (though `t' should still be an argument of the class, `t e' shouldn't be (but `e' should also be, if `t' is not parametric))
17:33:47 <Cale> actually, that might get you a complaint
17:33:52 <yuriks_> it does
17:33:58 <Cale> (since e isn't in scope there)
17:34:19 <Cale> So perhaps just move that context inward to the operations which really need it
17:34:29 <bluetaslem> DOes "$" have ANY purpose/
17:34:37 <Cale> In fact, I don't think your operations really need Eq or Show on trees anyway
17:34:40 <bluetaslem> Besides reducing the number of ( and )?
17:34:44 <Cale> bluetaslem: sure
17:34:54 <Cale> Well, it's equivalent to id
17:35:04 <alpounet> read it as "apply to"
17:35:09 <Cale> but it serves as a handy way to say "function application"
17:35:11 <Cale> yeah
17:35:15 <Cale> So for example...
17:35:24 <yuriks_> Cale: I was more planning for the whole tree to be Eq-able and Show-able
17:35:29 <Cale> > zipWith ($) [(+2), (*2), (^2)] [5,6,7]
17:35:30 <lambdabot>   [7,12,49]
17:35:33 <yuriks_> the elements net to be Ord-able
17:35:54 <kmc> > map ($ 3) [succ, pred]
17:35:55 <lambdabot>   [4,2]
17:35:57 <Cale> yuriks_: yeah, but the operations in the Tree class don't really require that restriction, so why impose it?
17:36:12 <bluetaslem> So, its helpful, but doesn't add any new functionality? Just improves redability and such?
17:36:22 <kmc> bluetaslem, it's an ordinary user defined operator
17:36:25 <kmc> @src ($)
17:36:25 <lambdabot> f $ x = f x
17:36:27 <Cale> bluetaslem: It's just defined in the Prelude as an ordinary function
17:36:35 <kmc> bluetaslem, so it doesn't add new functionality in a fundamental sense
17:36:37 <Cale> It's just a library definition that we use a lot
17:36:41 <Saizan> yuriks_: are you sure you want a type class at all?
17:36:44 <kmc> but it is simpler than writing
17:36:48 <kmc> > map (\f -> f 3) [succ, pred]
17:36:49 <lambdabot>   [4,2]
17:36:56 <Saizan> yuriks_: defining new typeclasses is quite unusual
17:36:59 <bluetaslem> Mkay. Just curious if its really necessary.
17:37:13 <Cale> and yeah, mostly to improve readability and maintainability, in conjunction with (.), which is the real superstar if you ask me :)
17:37:22 <yuriks_> Cale: don't I need to do that to be able to show trees on places where I have a (Tree t) => restriction?
17:37:36 <kmc> in Haskell we try not to name arguments within small functions.  "apply to 3" is a more concise description than "take a function f and apply f to 3"
17:37:42 <Cale> yuriks_: Yeah, but you can always add a Show restriction where you really need it
17:38:13 <yuriks_> Saizan: I'm gonna have several implementations of tree algorithms that will all be used by stuff restricting on Tree
17:38:16 <yuriks_> Cale: ohhh
17:38:55 <orlandu63> should ($) be used as a substitude for parentheses?
17:39:00 <orlandu63> substitute*
17:39:09 <Cale> orlandu63: often
17:39:23 <Cale> orlandu63: but it should not be used as a substitute for (.)
17:39:33 <orlandu63> okay
17:39:45 <Cale> if you have a chain of functions being applied to a value, compose them with (.), and apply the result with ($)
17:39:56 <bluetaslem> http://images.google.com/imgres?imgurl=http://donsbot.files.wordpress.com/2009/03/haskell_universe.jpg&imgrefurl=http://donsbot.wordpress.com/2009/03/16/visualising-the-haskell-universe/&usg=__YmZHAr2hkiRKiUFSxVBs9gRMhLk=&h=300&w=600&sz=68&hl=en&start=1&um=1&itbs=1&tbnid=kd-cPo15KFCpyM:&tbnh=68&tbnw=135&prev=/images%3Fq%3Dhaskell%2Bmodules%26um%3D1%26hl%3Den%26safe%3Dactive%26sa%3DN%26tbs%3Disch:1
17:40:02 <bluetaslem> Sorry for the large link..
17:40:08 <bluetaslem> But it has some interesting images.
17:40:10 <Cale> this results in the most easily refactorable code, because you effectively have more subexpressions than you otherwise would
17:40:16 <Cale> If you write:
17:40:20 <Cale> f $ g $ h $ x
17:40:31 <Cale> then, for example, g $ h is meaningless on its own
17:40:36 <Cale> But if you write
17:40:40 <Cale> f . g . h $ x
17:40:42 <yuriks_>     Kind mis-match
17:40:43 <yuriks_>     Expected kind `* -> *', but `BinTree e' has kind `*'
17:40:47 <hosebeast> Does the latest GHC come with Parsec?
17:40:52 <yuriks_> what the hell does that mean?
17:40:55 <kmc> hosebeast, Haskell Platform comes with Parsec
17:40:57 <Cale> then g . h and f . g, and so on are meaningful and can be understood on their own
17:41:06 <orlandu63> Cale: good point
17:41:10 <kmc> yuriks_, that you are applying another type to "BinTree e"
17:41:12 <kmc> as in "BinTree e a"
17:41:29 <kmc> yuriks_, kinds are like "types for types"... e.g. Int :: *, Maybe :: * -> *, Either :: * -> * -> *
17:41:30 <hosebeast> How do I get ghci to load Parsec?
17:41:30 <edwardk> yuriks_: you used one too many arguments, 'try stripping off' the 'e'
17:41:47 <kmc> hosebeast, :m + Text.Parsec
17:41:49 <Cale> hosebeast: import Text.Parsec
17:41:56 <Cale> Or yeah, :m + Text.Parsec
17:42:01 <bluetaslem> http://donsbot.files.wordpress.com/2009/03/haskell_universe.jpg
17:42:07 <bluetaslem> Its module dependency.
17:42:12 <hosebeast> Oh, Text.Parsec!
17:42:19 <hosebeast> I just had import Parsec.
17:42:24 <Cale> hosebeast: It has moved around a lot in its history
17:42:48 <Cale> hosebeast: Old documents call it just Parsec, then for a while it was Text.ParserCombinators.Parsec
17:43:02 <Cale> and then people realised that was a hassle and shortened it to Text.Parsec :)
17:43:13 <hosebeast> I'm getting "Could not find module 'Text.Parsec'"
17:43:23 <Cale> hosebeast: Perhaps the parsec package isn't installed
17:43:30 <Cale> Do you have cabal-install?
17:43:56 <hosebeast> Is that a package?
17:44:05 <Sgeo> Are there nice things for Parsec when I know I'm dealing with something almost, but not entirely, like C?
17:44:28 <hstefan> 21:42 -!- Irssi: Join to #haskell was synced in 3 secs
17:44:29 <hstefan> 21:42 < Cale> hosebeast: It has moved around a lot in its history
17:44:52 <Cale> hosebeast: It's a program
17:44:57 <Cale> hosebeast: (and a package)
17:45:13 <hosebeast> I don't know if I have it.  I think I originally just did apt-get install ghc haskell
17:45:14 <Cale> If you have it, then you can just type: cabal install parsec  on the commandline and get it
17:45:18 <Cale> oh
17:45:29 <Cale> You installed your distribution's packages, hmm...
17:45:33 <hosebeast> Yeah
17:45:38 <Cale> Which GHC do you have?
17:45:41 <yuriks_> http://pastebin.com/0RCBu44g
17:45:47 <yuriks_> I got here, and I'm stick again
17:45:59 <yuriks_> stuck*
17:46:27 <Saizan> yuriks_: use Tree BinTree
17:46:33 <hosebeast> Hm, it says ghci is version 6.10.4.
17:46:36 <kmc> hosebeast, on debian you can now apt-get install haskell-platform
17:46:46 <kmc> you really want the Platform and not just ghc itself
17:46:52 <orlandu63> whenever i try to compile a script that imports Data.Map, ghc complains: (.text+0x217): undefined reference to `__stginit_containerszm0zi3zi0zi0_DataziMap_'
17:47:02 <orlandu63> what could this mean, and how can it be fixed?
17:47:02 <mauke> orlandu63: ghc --make
17:47:05 <kmc> orlandu63, compile with --make
17:47:10 <hosebeast> kmc: Hm, that's not in my repo.
17:47:14 <kmc> that really ought to be the default
17:47:18 <yuriks_> Saizan: then I get that e isn't Ord
17:47:18 <kmc> there's a ticket to that effect
17:47:28 <yuriks_> I assume I need to stick ord into the search signature then?
17:47:28 * DrSyzygy wooooooots. BIG time.
17:47:32 <hosebeast> Let me search Synaptic.
17:47:39 <kmc> hosebeast, might be only in testing or unstable
17:47:46 <Saizan> yuriks_: yeah
17:47:47 <DrSyzygy> I've got a result that lets me present a DPH-based project at ICMS in Kobe in September.
17:47:58 <orlandu63> hmm
17:48:11 <hosebeast> Hm, it says I have "libhugs-cabal-bundled."
17:48:44 <orlandu63> would it be safe to alias ghc to ghc --make?
17:48:54 <hosebeast> And I have ghc6.
17:49:07 <Saizan> DrSyzygy: cool
17:49:20 <hosebeast> I guess I'll just make cabal-install.
17:49:35 <yuriks_> Saizan: can I apply that Ord e restriction just to the function in BinTree?
17:49:55 <yuriks_> Saizan: if I try copying the type signature from Tree to BinTree to add it it complains about a misplaced signature
17:50:29 <mauke> yuriks_: your BinTree isn't an instance of Tree
17:50:30 <Saizan> yuriks_: you can't, you'd need the multiparameter typeclass approach in Tree to get that effect
17:50:44 <mauke> it can't implement the search method, for example
17:51:01 <yuriks_> mauke: huh?
17:51:22 <chrisdone> @src Tree
17:51:22 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
17:51:25 <DrSyzygy> Saizan: Computing GrÃ¶bner bases is generally a really hard thing to parallelize. But I'm watching the code I wrote with a couple of collaborator run. And it's pegging 6 processors out of 6 allocated. SO awesome! All thanks to Data Parallel Haskell!!
17:51:33 <chrisdone> sigh
17:51:41 <mauke> yuriks_: search :: t e -> e -> Maybe e clearly promises that search works for all e, not just those that implement Ord
17:51:43 <yuriks_> chrisdone: pasted a few lines up
17:51:44 <Saizan> i guess you could also use GADTs to hide the typeclass context in the constructor
17:51:53 <hosebeast> I suppose Cabal comes with caball-install?
17:51:59 <yuriks_> mauke: hmm, I guess
17:52:06 <yuriks_> well, I'll compromise, then
17:52:49 <Saizan> hosebeast: the Cabal haskell package has only the library
17:52:55 <hosebeast> Oh, crap.
17:53:52 <Saizan> DrSyzygy: great :D hoping you actually get better performance than a single-threaded solution :)
17:57:03 <chrisdone> I say again, fclabels is awesome
17:58:09 <Saizan> fclabels++
17:58:13 <Saizan> i should try it.
17:58:42 <pastorn> chrisdone: yeah, it kinda is
17:58:49 <pastorn> though i dislike the MTL dependency :)
17:58:51 <pastorn> :(
17:59:38 <chrisdone> ageAndCity :: Person :-> (Int, String)
17:59:38 <chrisdone>  ageAndCity = Label $ (,) <$> fst `for` age <*> snd `for` (city . place)
17:59:45 <chrisdone>  moveToAmsterdamOverTwoYears :: Person -> Person
17:59:45 <chrisdone>  moveToAmsterdamOverTwoYears = mod ageAndCity (\(a, b) -> (a+2, "Amsterdam"))
17:59:51 <chrisdone> totally sweet
18:00:11 <dude4> so uh...... you guys like turtles right?
18:00:13 <chrisdone> that'll make using the state monad much more fun
18:00:23 <chrisdone> dude4: we like nomads
18:00:34 * BMeph likes comonads
18:00:35 <dude4> turtles are frequently nomadic
18:00:53 <dude4> and they are noble, wise, and sexy
18:01:00 * ski wonders whether coturtles are conomadic
18:01:36 <LegendaryPenguin> turtles stink
18:01:39 <dude4> i love turtles.. i ate like 3 today
18:01:48 <dude4> well you gotta wash'em!
18:01:51 <LegendaryPenguin> oh
18:02:07 <LegendaryPenguin> godzilla was a turtle
18:02:14 * BMeph wants to petition pharm companies to produce a replacement stimulant for Ritalin, brand-named Deine
18:02:32 <dude4> indeed, although he has fallen from the path of the great tortoise
18:02:51 * BMeph thought that was Gamera
18:03:18 <LegendaryPenguin> why dont they still make cheap old monster movies
18:03:19 <pastorn> chrisdone: did you have any trouble with installing fclabels?
18:03:21 <LegendaryPenguin> those were the best..
18:03:27 <dude4> perhaps, my godzillistory is a little rusty
18:04:00 <dude4> i at turtle soup today, and used the shell for a bowl!
18:04:39 <dude4> they are delicious and nutritious - but most importantly they are the spiritual leaders of our time
18:05:38 <dude4> goodbye my friends... may the great tortoise smile upon you all
18:06:12 <kmc> that was odd
18:08:21 <mjrosenb> gah, why on earth is this computer ubuntu
18:08:38 <mjrosenb> it cannot install libghc6-http-dev
18:09:01 <Zao> mjrosenb: It's punishment for past transgressions.
18:09:08 <Zao> If you don't shape up, you'll get Gentoo.
18:09:38 <mjrosenb> Zao: that is what i run on *every* *one* of my computers
18:09:57 <mjrosenb> Setting up libghc6-http-dev (30010004-3) ...
18:09:58 <mjrosenb> ghc-pkg: cannot find package HTTP-4000.0.4
18:10:06 <mjrosenb> yeeeaaahhhh....
18:11:15 <Zao> Sounds like you've mangled your install good.
18:12:12 <mjrosenb> better quewstion
18:12:20 <mjrosenb> why does cairo depend on http
18:12:49 <mjrosenb> oh it doesn't
18:12:54 <mjrosenb> just http failed once
18:13:02 <mjrosenb> and every time i attempt to install anything
18:13:10 <mjrosenb> it attempts to finish installing http
18:13:14 <mjrosenb> and fails
18:13:38 <mauke> fail early, fail often
18:13:55 <Zao> Sounds about as fun as when directory thought it should reinstall itself.
18:13:58 <Zao> Hint - it can't on Windows :)
18:15:13 <mjrosenb> http://pastebin.org/146406
18:15:18 <mjrosenb> gharf
18:24:07 <aditya> Hi all, I'm having trouble understanding the difference between mplus and mappend. They both seem to do the same thing.
18:24:57 <pastorn> aditya: mplus is for 'computations' and 'mappend' is for data
18:25:27 <pastorn> but yeah, if you have both monad and monoid for some structure they are usually the same
18:26:04 <mauke> Maybe
18:26:06 <aditya> pastorn: could you elaborate? mplus takes two monads and returns a monad. mappend takes two a's and returns an a. The first seems like a specialization of the second.
18:26:29 <mauke> > Just "foo" `mplus` Just "bar"
18:26:30 <lambdabot>   Just "foo"
18:26:34 <mauke> > Just "foo" `mappend` Just "bar"
18:26:35 <lambdabot>   Just "foobar"
18:26:48 <pastorn> aditya: two 'monadic computations'
18:26:54 <Saizan> pastorn: rarely the same, actually!
18:27:23 <pastorn> > "lol" `mappend` "lulz"
18:27:24 <lambdabot>   "lollulz"
18:27:34 <pastorn> > "lol" `mplus` "lulz"
18:27:35 <lambdabot>   "lollulz"
18:27:45 <Saizan> aditya: the first kind of is a specialization of the second, except that it guarantees it won't touch the results
18:28:00 <Saizan> aditya: because the mplus implementation has to be parametric in 'a'
18:29:00 <alpounet> @type mappend
18:29:01 <lambdabot> forall a. (Monoid a) => a -> a -> a
18:29:04 <alpounet> @type mplus
18:29:05 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
18:29:05 <Sgeo> @hoogle a -> [a] -> [[a]]
18:29:05 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
18:29:05 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
18:29:06 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
18:29:47 <pastorn> @type intercalate -- Sgeo
18:29:48 <lambdabot> forall a. [a] -> [[a]] -> [a]
18:29:59 <aditya> Saizan: so mplus returns one of the arguments, but mappend combines them somehow. Correct?
18:30:16 <pastorn> aditya: that's true for Maybe
18:30:28 <mjrosenb> aditya: depends on the instance
18:30:37 <mjrosenb> iirc, that does not hold for lists?
18:30:43 <alpounet> mappend is just the usual operation associated to a given monoid
18:30:52 <Saizan> aditya: if i guess correctly what you mean by arguments, then yeah it's allowed to for the second
18:30:53 <mjrosenb> > [1,2,3] `mplus` [5,6,7]
18:30:54 <lambdabot>   [1,2,3,5,6,7]
18:30:56 <alpounet> mplus is the equivalent in a monad-also-being-a-monoid
18:31:06 <Saizan> aditya: though i don't endorse that meaning of argument :)
18:31:28 <mjrosenb> Saizan: argument is fine
18:31:45 <mjrosenb> Saizan: functions taking more than one argument is a bit questionable :-p
18:31:46 <Saizan> mplus arguably looks at its arguments too.
18:31:50 <Sgeo> :t partition
18:31:51 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
18:31:53 <aditya> Just trying to get a feel for how the two are used.
18:32:24 <Saizan> it can't look at the parts that will be of type 'a' from 'm a' but it can look at the rest.
18:33:19 <edwardk> mappend and mplus agree in basically all cases except for Maybe. unfortunately there are two choices for Maybe. one is the simplest way to turn a semigroup into a monoid, the other is behavior of mplus.
18:33:48 <edwardk> (well, there is also the equivalent of flip mappend)
18:34:28 <edwardk> i think the monoid instance for Maybe is a bit of a mistake =/
18:35:21 <Saizan> i think the policy is to use "lifting instances" for Monoid, when the thing is at least an Applicative
18:35:23 <alpounet> @src Maybe mappend
18:35:24 <lambdabot> Source not found. Maybe you made a typo?
18:35:24 <Sgeo> :t fromMaybe
18:35:25 <lambdabot> forall a. a -> Maybe a -> a
18:35:29 <Saizan> though [a] doesn't fit that
18:35:47 <Saizan> (e ->) does though
18:36:57 <edwardk> Saizan: sadly there are multiple choices then, if it is alternative there is the (empty,<|>) monoid, but there is also the lifted monoid (pure mempty,liftA2 mappend)
18:37:24 <edwardk> Saizan: which is why i provide both in the monoids package
18:38:12 <edwardk> http://hackage.haskell.org/packages/archive/monoids/0.1.36/doc/html/Data-Monoid-Applicative.html
18:39:18 <edwardk> the Alt formulation has the advantage that you get not only a monoid out of the result, but a right seminnearing if your alternative wraps a monoid.
18:39:20 <Sgeo> <|>?
18:39:25 <Saizan> yeah, i meant that the latter is preferred, though i agree that it's a bit annoying
18:39:31 <edwardk> Sgeo: Alternative's 'mplus' equivalent
18:39:43 <edwardk> @src Alternative
18:39:43 <lambdabot> class Applicative f => Alternative f where
18:39:43 <lambdabot>     empty :: f a
18:39:43 <lambdabot>     (<|>) :: f a -> f a -> f a
18:40:06 <Sgeo> Alternative?
18:40:20 <edwardk> Alternative : Applicative :: MonadPlus : Monad
18:46:54 <BMeph> edwardk: Isn't it the equivalent of "flip mplus" that is the third alternative? :)
18:49:30 <edwardk> BMeph: yeah, (9:33:18 PM) edwardk: (well, there is also the equivalent of flip mappend) =)
18:50:49 <edwardk> trying to figure out a haskelly way to encode the directed series parallel graphs from http://reports-archive.adm.cs.cmu.edu/anon/2008/CMU-CS-08-146.pdf
18:51:41 <edwardk> in general i'm only concerned with paths from a root node to somewhere halfway through the graph, so a zipper does seem to make a lot of sense.
18:51:47 <quuxman> are there any haskell ray tracing libraries that support difraction?
19:01:03 * BMeph wonders how much it complicates doing TECS with an implication "gate" vice the NAND...
19:04:16 <mibygl> Can lambdabot translate percentiles to z-scores?
19:04:18 <edwardk> TECS?
19:05:36 <kmc> @faq Can Haskell translate percentiles to z-scores?
19:05:36 <lambdabot> The answer is: Yes! Haskell can do that.
19:05:57 <tensorpudding> @faq
19:05:58 <lambdabot> The answer is: Yes! Haskell can do that.
19:06:03 <BMeph> edwardk: http://www1.idc.ac.il/tecs/
19:06:21 <mibygl> lambdabot and Haskell are not the same thing.
19:06:22 <edwardk> ah, as in running through the examples with the other gate?
19:06:31 <mibygl> > Statistics.Distribution.quantile
19:06:32 <lambdabot>   Not in scope: `Statistics.Distribution.quantile'
19:06:59 <edwardk> is => universal?
19:07:23 <edwardk> i don't see how you'd build 'not' out of it
19:07:57 <mibygl> It's not universal.  => and F is universal.
19:08:07 <edwardk> ah
19:08:15 <kmc> erf-inverse is a hairy function
19:08:29 <edwardk> mibygl: that is what i was looking for =)
19:12:49 <BMeph> Isn't NAND universal, though? :)
19:12:58 <edwardk> nand is, => isn't
19:13:29 <edwardk> so the complication is needing a supply of ground, not that onerous
19:14:22 <edwardk> then you can translate "not p = p -> false"
19:14:58 <BMeph> Yeah. I thought it interesting that from the introduction, it specifically gives you NAND _and_ F, and I always thought that you can get F out of two NANDs one hooked up to give NOT. :)
19:17:32 <tensorpudding> there is a known polynomial expansion for erf^(-1) though
19:22:29 <tensorpudding> hmm, the Fortran version of erf is called DERF
19:31:01 <Lemon> alright, so my program crashes with something about a broken pipe.
19:31:33 <Lemon> how come it keeps giving me that same error even though it should be dead?
19:31:41 <Lemon> I mean, I can't get the pid of it at all.
19:37:24 <kmc> tensorpudding, haha
19:37:28 <kmc> hurf derf
19:38:37 <tensorpudding> need to find some mathematical function that would get abbreviated as DERP
19:39:04 <mibygl> I love it when Google Chrome crashes.
19:39:13 <tensorpudding> Oh noes!
19:39:20 <mibygl> @docs
19:39:20 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
19:39:34 <tensorpudding> At least Chrome is quick on the startup, I say.
19:39:48 <Sgeo> Those docs don't have everything in Platform, apparently :(
19:40:01 <mibygl> So, I have come up with the perfect piece of code.
19:40:15 <tensorpudding> It would be nice to have a set of docs for everything in platform, all linked up nice and tight.
19:40:32 <Sgeo> tensorpudding, agreed
19:41:16 <mibygl> :t do x <- newEmptyMVar; forkIO (putMVar x True); forkIO (putMVar x False); takeMVar x
19:41:17 <lambdabot> Not in scope: `newEmptyMVar'
19:41:18 <lambdabot> Not in scope: `forkIO'
19:41:18 <lambdabot> Not in scope: `putMVar'
19:41:25 <mibygl> Anyway, it's that.
19:42:09 <Sgeo> Basically, race to see which thread puts into the MVar first?
19:42:30 <Sgeo> If you did another takeMVar, the second one should be opposite of the first
19:42:38 <mibygl> Right.
19:42:52 <mibygl> I think that both the winning thread and the losing thread will be garbage collected.
19:43:21 <Sgeo> Also, there should be { } around most of that
19:44:28 <mibygl> For some reason, lambdabot prefers them left out.
19:44:54 <mibygl> > (do x <- undefined; undefined (undefined x True); undefined (undefined x False); undefined x) :: [Int]
19:44:55 <lambdabot>   * Exception: Prelude.undefined
19:45:01 <mibygl> > {do x <- undefined; undefined (undefined x True); undefined (undefined x False); undefined x} :: [Int]
19:45:02 <lambdabot>   <no location info>: parse error on input `{'
19:45:28 <Sgeo> Because you're using them incorrectly
19:45:28 <mibygl> I wonder why that is.
19:45:34 <mibygl> Oh?
19:45:40 <mibygl> > do {x <- undefined; undefined (undefined x True); undefined (undefined x False); undefined x} :: [Int]
19:45:41 <lambdabot>   * Exception: Prelude.undefined
19:45:44 <mibygl> Heh heh.
19:45:47 <gwern> mibygl: I don't think it matters. mueval doesn't import control.concurrent or the others
19:46:01 <gwern> mibygl: since mueval is meant for *pure* code...
19:46:06 <mibygl> Right.
19:47:37 <Sgeo> > let x = unsafePerformIO ( randomRIO :: Int) in do { print x; print x }
19:47:37 <lambdabot>   Not in scope: `unsafePerformIO'
19:48:41 <mibygl> print is strict, so it ought to evaluate only once.
19:49:01 <gwern> mibygl: 'ought to'?
19:49:22 <gwern> the compiler can make x be evaluated as many time as it pleases; that's what not having an IO signature means
19:49:29 <mibygl> I would expect the compiler to arrange things such that it evaluates only once.
19:49:56 <gwern> mibygl: full laziness can lead to massive space leaks; how can it know in general that x gets reused?
19:50:07 * mibygl shrugs.
19:52:17 <mibygl> I've been pondering a Haskell processor lately.  I'd give it lots of cores and a garbage collector.
19:52:31 <tensorpudding> A processor with a garbage collector?
19:52:35 <dcoutts_> gwern: btw, are you still working on the gitit wiki stuff?
19:52:42 <gwern> dcoutts_: I'm not not working on it
19:52:48 <dcoutts_> gwern: :-)
19:53:21 <wolgo> say I have a value that I want to update when a certain action happens (like a bad hangman guess) it would be improper to try and "update" a variable. Is there a way to emulate this?
19:53:29 <dcoutts_> gwern: am I remembering correctly that you've been talking about wiki support for haddock docs?
19:53:48 <dcoutts_> gwern: something like that could be a killer feature for hackage, if done right
19:54:03 <wolgo> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24806#a24806
19:54:05 <gwern> dcoutts_: I've discussed it for quite a while, but it's always seemed quite hard
19:54:11 <wolgo> I need to keep track of guesses
19:55:04 <dcoutts_> gwern: mm, I guess one of the problems the hackage context is that we only have a tarball version, not an actual darcs repo, and matching up changes in a release vs the HEAD might be tricky
19:55:16 <dcoutts_> gwern: what do you think the hardest bits are?
19:55:38 <dcoutts_> gwern: the mapping between .hs source and html/wiki versions?
19:55:42 <gwern> dcoutts_: well, haddock to html; gitit is kind of premised on calling pandoc to generate
19:56:46 <gwern> dcoutts_: my original proposal tried to sidestep haddock->html by working off editing the .hs
19:57:02 <alex404> So, I've been writing this program to communicate over a serial port with a piece of hardware, and it's been working fine. For no reason I can discern, it's started telling me it doesn't like any of the messages I send it. I can, however, open up gtkterm, send it (what I believe are) the same commands, and the hardware doesn't complain. Now here's the weird part: If I leave gtkterm open, and then send my commands through haskell, it works! Does anyone
19:58:18 <gwern> dcoutts_: it's clear how to take the repo for containers, maintain a public gitit wiki anyone can edit, and periodically send off patch bundles to maintainers; not so clear how to integrate into hackage, edit files, and send back to author without a repo available
19:58:25 <dcoutts_> gwern: so that requires working out which bit of the .hs file to edit, given a section of the html
19:58:50 <dcoutts_> gwern: many packages specify a darcs repo
19:59:06 <gwern> dcoutts_: many? no way. a few
19:59:23 <dcoutts_> gwern: well, ok but we could probably get more to do so if there are clear advantages
19:59:34 <dcoutts_> gwern: for non-darcs repos I suppose we could just send a diff style patch
19:59:42 <gwern> a few weeks ago I was writing a tagsoup script to scrap hackage for repos to download from; didn't get very many hits at all...
19:59:47 <BMeph> wolgo: in your findAndShow function, you should say "if not $ null $ ..." == True. ;þ
19:59:51 <tensorpudding> wonder what the state of various RCS's in haskell is
20:00:10 <dcoutts_> gwern: eugh, don't do that, it's all there in the 00-index.tar.gz and we've got code to download and parse that properly.
20:00:31 <gwern> dcoutts_: I didn't feel like learning how to gunzip and untar from haskell
20:00:44 <dcoutts_> right, don't bother just use the existing code
20:01:23 <dcoutts_> gwern: though it's actually only a couple lines of code using the zlib and tar packages
20:01:36 <tensorpudding> compress is fun
20:02:14 <jbapple> wolgo: often, values that would be mutable in imperative code turn into function parameters in recursive code.
20:02:50 <wolgo> BMeph: wouldnt that cause a type problem?
20:02:52 <wolgo> let me test
20:02:54 <gwern> dcoutts_: I suppose the question is whether darcs will eat unshared patches
20:03:33 <dcoutts_> gwern: unshared? I'm not sure what you're referring to
20:03:59 <gwern> dcoutts_: if it can, then it doesn't matter if an author didn't provide the repo; we can still send them useful patches
20:05:47 <dcoutts_> gwern: I think it's fine to only have it work if there's a darcs repo available
20:06:09 <BMeph> wolgo: Naugh, I'm just kidding you. Basically, what I mean to say is "if not $ null $ xs then xs else []" is better said as: "xs". :)
20:07:34 <wolgo> oh
20:07:59 <gwern> dcoutts_: ok, so what's your idea? one darcs gets the repo to foo/, then runs 'gitit' with a default config with wikidata = foo/, and then what? gitit/pandoc will render the various .hs files as .hs
20:08:23 <wolgo> okay now I need to make a reveal function
20:08:30 <gwern> that's great for literate files http://gitit.net/paste.lhs
20:08:32 <wolgo> that means that I need IO
20:08:33 <gwern> but haddocks?
20:09:07 <dcoutts_> gwern: not quite, I was thinking to show the original haddocks, but with edit links for each bit
20:09:32 <gwern> dcoutts_: and how do the edits become new haddocks?
20:09:37 <dcoutts_> gwern: those would give you a editor with the haddock markup for that function
20:09:55 <gwern> is it one-way? you submit the the contents of the editor to the original author and the haddocks don't change until a fresh upload?
20:10:04 <dcoutts_> gwern: it's not a live wiki, it generates a darcs patch that is sent to the normal darcs send address of the repo
20:10:10 <dcoutts_> gwern: exactly
20:10:26 <gwern> dcoutts_: hm. that might be worthwhile, but I don't see how gitit ever comes into play
20:10:44 <dcoutts_> gwern: maybe the tech is rather different
20:11:47 <dcoutts_> gwern: and the point is mainly for those little improvements here and there, not for massive overhauls/restructuring
20:12:16 <gwern> dcoutts_: the section editing might not be too difficult. haddocks already allow you to jump to somewhere in the copy of the source, so presumably one can also tell the edit box 'jump down 45 rows'; and diff will keep the diff as small as possible
20:12:56 <dcoutts_> gwern: haddocks allow specific links to a wiki with a url scheme that can use names
20:13:10 <dcoutts_> we just don't use that much
20:13:16 <dcoutts_> we use the source links feature
20:14:16 <dcoutts_> --source-base/module/entity=URL and --comments-base/module/entity=URL
20:14:43 <dcoutts_> I don't recall what the link gets called
20:15:38 <gwern> dcoutts_: actually, given the --hyperlink-source stuff, there's no need for darcs is there?
20:16:10 <gwern> you already have a copy of the source; when someone does an edit, send them a copy, keep a copy in /tmp, and diff /tmp against the copy they send back
20:16:16 <dcoutts_> gwern: the point would be to generate patches for the maintainer in the preferred format
20:16:23 <gwern> no security concerns about darcs hooks either
20:18:06 <dcoutts_> diff/patch is ok though not really ideal, darcs and git users would prefer something native
20:18:41 <gwern> hm. looks like all the hooks can be disabled
20:19:06 <gwern> dcoutts_: it's a reasonable plan. very much worse is better
20:19:17 <dcoutts_> heh :-)
20:20:05 <dcoutts_> gwern: the thing about doing it on hackage is you've got to not piss off maintainers, so things like live edits will not fly
20:20:25 <gwern> 'full blown round trip editing of haddocks in gitit? nah, we'll just give people an edit box and `patch`, and it'll be copacetic'
20:20:27 <dcoutts_> maintainers could set up something more live on their own sites
20:21:35 <dcoutts_> in particular something corresponding to the head branch, rather than a release
20:22:19 <dcoutts_> which actually is one reason we'd want to make darcs patches, since those will likely still apply to the head, even when they were made against an older tag
20:27:21 * hackagebot ghc-mod 0.3.0 - Happy Haskell programming on Emacs  http://hackage.haskell.org/package/ghc-mod-0.3.0 (KazuYamamoto)
20:55:19 <gwern> @wn monepic
20:55:21 <lambdabot> No match for "monepic".
20:58:12 <kmc_> can i convince cabal (configuring one package) to look directly at another package's source directory as a dependency, rather than going through the package db?
20:58:34 <gwern> er. not that I know of
20:58:44 <gwern> that sounds like one of those Don't Do That Then things
20:58:45 <dcoutts_> kmc_: not without modifying the package
20:59:02 <kmc_> i want to hack on darcs HEAD cabal-install, but it depends on the version of Cabal that's not released yet
20:59:13 <gwern> kmc_: so install cabal from darcs?
20:59:20 <kmc_> but then it affects my whole Haskell setup
20:59:28 <dcoutts_> kmc_: is that really true?
20:59:29 <kmc_> i just want it for building this one other package, which i also won't install
20:59:38 <kmc_> dcoutts_, which?
20:59:42 <dcoutts_> kmc_: I thought it depended on Cabal 1.8
20:59:45 <dcoutts_> not 1.9
20:59:46 <gwern> kmc_: so install cabal, then darcs, then hide the cabal
21:00:14 <dcoutts_> gwern, kmc_: more sensible in that situation would be to use a local package db, which cabal supports --package-db
21:00:45 * gwern thinks that sounds fragile, tedious, and all around harder than just installing and hiding later
21:01:21 <dcoutts_> gwern: cabal doesn't care about hidden packages, hiding it only affects manual ghci/ghc --make
21:01:30 <gwern> fine, unregister then!
21:02:22 <kmc_> unpacking the entire Platform into a throwaway dir sounds easier, honestly
21:02:31 <mun> does anyone know why first-order logic provers can be automated even when FOL is only semi-decidable?
21:02:41 <dino-> Or do this work in a VM
21:04:25 <dcoutts_> kmc_: I don't understand why you think any of this is necessary
21:04:40 <dcoutts_> as far as know, darcs head uses Cabal-1.8 which is certainly released
21:05:56 <kmc_> dcoutts_, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24808#a24808
21:06:03 <kmc_> maybe i misinterpret this message
21:06:30 <dcoutts_> kmc_: why do you need cabal-install HEAD?
21:06:45 <dcoutts_> kmc_: there's not much in it over the released 0.8.x versions
21:06:53 <kmc_> to submit patches for cabal-install
21:06:59 <dcoutts_> ahh
21:07:13 <dcoutts_> ok then yes you want the darcs head version of Cabal lib too
21:07:35 <kmc_> which i have, but not installed
21:07:41 <kmc_> i suppose it's not a terribly big deal to install it
21:07:59 <dcoutts_> you can use a local package-db if you don't want it registered globally
21:08:14 <dcoutts_> cabal install --package-db=some-location
21:08:32 <dcoutts_> just use the same db when configuring cabal-install
21:09:17 <Veinor> if a module I import reexports some other modules, can I stop it from doing that?
21:11:11 <dcoutts_> Veinor: no, but you can import qualified or hiding certain bits
21:11:26 <dcoutts_> or just import specific bits
21:15:00 <Veinor> basically, I'm trying to use HXT without linking everything
21:18:32 <Veinor> hm, nope
21:18:35 <Veinor> still have a 13MB binary
21:19:37 <Saizan> what gets linked in is quite a different issue
21:20:19 <Saizan> but you could try strip
21:22:30 <dcoutts_> Veinor: and you can build hxt with --enable-split-objs
21:23:21 <Veinor> oh, if I strip and gzip it goes down ot like 1MB
21:23:58 <dcoutts_> Veinor: building all the dependent libs with --enable-split-objs will substantially reduce the size
21:24:15 <dcoutts_> it's used for the ghc core libs, but it's not on by default for other libs
21:24:16 * Saizan fears --enable-split-objs from the days he had only ~300MB of ram
21:24:21 <Veinor> dcoutts_: ok... now how do I do that and what's the downside?
21:24:28 <dcoutts_> right, it takes more time linking
21:24:34 <dcoutts_> more memory especially
21:24:41 <Veinor> ok, figured out how to do that (.cabal/config, whee)
21:25:37 <cads> Hey, can I use cabal to build a project into a set of 30 or so executables as necessary, and configure things so that they'll build in either linux or windows?
21:26:09 <dcoutts_> cads: yes, it's designed to allow portability
21:26:54 <Veinor> ok, reinstalling hxt with split objs didn't save space
21:27:22 <cads> dcoutts is the cabal manual what I should start with?
21:27:30 <dcoutts_> cads: yep
21:27:35 <Veinor> oh
21:27:37 <Veinor> I enabled plit-objs
21:27:38 <Veinor> :(
21:28:09 <Veinor> how do I reinstall libraries with split-objs using cabal?
21:28:09 <dcoutts_> does it not warn about unrecorgnised config fields?
21:28:15 <dcoutts_> --reinstall flag
21:28:22 <Veinor> that makes ld complain a lot
21:28:34 <Veinor> about things not being of the right architecture
21:28:44 <Veinor> (I'm running OS X)
21:29:00 <dcoutts_> hmm, never seen that before
21:29:17 <Veinor> let's try it anyway, see if it works!
21:29:28 <dcoutts_> perhaps split objs is borked on osx, if it is then file a ghc ticket
21:29:34 <Veinor> all else fails, I'll just blow away .ghc and .cabal
21:29:51 <dcoutts_> it's mostly a ghc feature, cabal just passes an extra flag to ghc
21:30:02 <Veinor> hm
21:30:06 <Veinor> yeah, not working
21:30:11 <Veinor> gonna blow everything away, wheee
21:30:48 <siracusa> Is there a way to conveniently derive functions like isNothing and isJust from a data type with lots of constructors?
21:31:47 <ddarius> siracusa: Sure.  If you don't care about performance, you can use Data.Data.
21:32:01 <kmc_> > toConstr Nothing
21:32:02 <lambdabot>   Ambiguous type variable `a' in the constraint:
21:32:02 <lambdabot>    `Data.Data.Data a'
21:32:02 <lambdabot>      a...
21:32:05 <Veinor> ok, yeah, it's doing it on a fresh install
21:32:08 <kmc_> > toConstr (Nothing :: Maybe Char)
21:32:09 <lambdabot>   Nothing
21:32:13 <kmc_> i think toConstr should be not that expensive
21:32:29 <siracusa> What does it do?
21:32:44 <kmc_> siracusa, returns a Constr value representing the constructor at the top of a value
21:32:45 <kmc_> :t toConstr
21:32:46 <lambdabot> forall a. (Data a) => a -> Constr
21:32:49 <kmc_> > toConstr (2 + 3)
21:32:50 <lambdabot>   5
21:32:52 <kmc_> err weird
21:32:58 <kmc_> yeah, i guess it's notionally that way
21:33:06 <kmc_> > toConstr (Left 'x' :: Either Char Bool)
21:33:07 <lambdabot>   Left
21:33:28 <kmc_> this is just morally equivalent to toConstr Nothing = "Nothing"; toConstr (Just_) = "Just"
21:33:32 <Veinor> gonna try it on my linux machine
21:33:33 <kmc_> hopefully with faster equality
21:33:41 <kmc_> and with instances defined for you via "deriving (Data)"
21:34:04 <kmc_> also, the "derive" package can derive some things besides typeclasses
21:34:05 <siracusa> So the result is a String?
21:34:12 <kmc_> siracusa, the result is a Constr
21:34:14 <kmc_> :t toConstr
21:34:15 <lambdabot> forall a. (Data a) => a -> Constr
21:34:26 <kmc_> siracusa, which has Eq and Show etc
21:34:42 <siracusa> Ok, I have to look at the source ...
21:35:07 <Veinor> hm, split-objs is making part of hxt be really, really slow
21:35:45 <Veinor> ok, there we go
21:35:59 <ddarius> split-objs is hard on the linker.
21:36:25 <Veinor> yeah.
21:36:39 <Veinor> maybe I should just install ghc 6.12.1
21:36:48 <Veinor> I heard it's better on OS X
21:38:20 <siracusa> kmc_: And to check equality I use it like so: toConst val == toConst (isJust undefined)?
21:40:04 <Veinor> ahahaha, dammit
21:40:12 <Veinor> after all that lengthy compiling it tells me it can't find deepseq
21:40:35 <Veinor> I'm just going to blow everything away and install 6.12.1
21:41:05 <kmc_> > toConst (Just 'x') == toConst (Just undefined)
21:41:06 <lambdabot>   Not in scope: `toConst'Not in scope: `toConst'
21:41:13 <kmc_> > toConstr (Just 'x') == toConstr (Just undefined)
21:41:13 <lambdabot>   Ambiguous type variable `a' in the constraint:
21:41:14 <lambdabot>    `Data.Data.Data a'
21:41:14 <lambdabot>      a...
21:41:24 <kmc_> yeah, so this is a little picky
21:41:31 <kmc_> might not be worth the effort tbh
21:41:32 <dcoutts_> Veinor: ghc-6.10 vs 6.12 seems to be orthogonal to what you're talking about
21:41:58 <Veinor> yeah, I know
21:42:05 <dcoutts_> Veinor: I mean it's not obvious to me that upgrading ghc is a solution to your problems
21:42:22 <dcoutts_> if you need deepseq then install deepseq
21:43:01 <Veinor> I'm just screwing around at this point
21:43:38 <Veinor> like, I can't get split-objs to work at all on my OS X install
21:44:04 <dcoutts_> it might well be borked, it doesn't get tested much
21:44:09 <dcoutts_> except in the ghc nightly builds
21:44:24 * Veinor shrugs
21:44:36 <Veinor> I'm just slightly annoyed that my simple XML script has 6MB binaries
21:45:44 <Veinor> which gzips down to 1.2MB
21:45:45 <dcoutts_> it'll be better when we get shared libs working on OS X
21:46:22 <Veinor> well, if you do that, then that requires the end-user to install shared libraries, which I don't know if that's something I want people to have to do
21:46:29 <Veinor> right?
21:46:36 <dcoutts_> not if you ship them
21:46:41 <Veinor> true
21:46:51 <dcoutts_> of course it only helps if you've got several progs
21:46:59 <dcoutts_> so that there's actually some sharing going on
21:47:34 <Veinor> if Haskell were more popular I could just say 'go compile it yourself if your connection is bad'
21:47:48 <Veinor> but it's not :P
21:48:22 <Veinor> ... hopefully, I can ad a 'yet' to the end of that sentence
21:49:27 <Veinor> although I'll be happy if anything haskell-ish becomes mainstream
21:49:28 <Veinor> :D
21:52:02 <kmc_> Veinor, but this channel will go to shit if it does :/
21:52:09 <Veinor> haha
21:52:19 <Veinor> 'yeah, I liked Haskell when it was underground'
21:52:28 <jmcarthur> most real progress would stop, too
21:52:59 <jmcarthur> many potential changes are held back by popularity and lock-in already
21:53:40 <Veinor> like rewriting the numeric prelude?
21:54:16 <jmcarthur> the numeric heirarchy, algebra, and monad heirarchy are good examples
21:54:32 <jmcarthur> debatable whether those first two should be the same or not
21:54:38 <jmcarthur> is why i list them separately
21:55:29 <kmc_> yeah, Ruby used to be the hipster language
21:55:33 <kmc_> but i think it's too popular now
21:55:38 <kmc_> i hope we can take that position
21:55:52 <jmcarthur> we need a killer app
21:55:53 <cads> better string handling, yo
21:55:55 <kmc_> maybe hipsters program in Visual Basic ironically
21:56:06 <jmcarthur> xmonad is great, but not it
21:56:14 <jmcarthur> darcs too
21:56:38 <monochrom> we need a killer app to kill haskell success
21:56:39 <jmcarthur> it needs to be something that makes somebody in the haskell community rich
21:56:41 <cads> once haskell takes off we'll all move to dependently types language
21:56:51 <jmcarthur> once that happens, everybody else will want in on the action
21:57:08 <kmc_> agda is for lovers
21:57:10 <erikc> because they'll mistakenly think the language was the success factor
21:57:15 <jmcarthur> right
21:57:18 <cads> thats genius
21:57:21 <Veinor> .quote monochrom we need a killer app to kill haskell success
21:57:29 <Veinor> someone who knows how add that quote
21:57:36 <monochrom> use @remember
21:58:05 <Veinor> @remember monochrom we need a killer app to kill haskell success
21:58:05 <lambdabot> Done.
21:58:25 <erikc> it will probably have to be a webapp
21:58:26 <monochrom> haskell programs for financial derivative products made somebody in the haskell community rich
21:58:30 <cads> some kind of money ai?
21:58:48 <cads> monochrom: really?
21:58:56 <jmcarthur> it has to be visible, something everybody can get to
21:58:57 <monochrom> but no one dares mention that because by making that someone rich, it made the rest of us poor.
21:59:04 <erikc> haha
21:59:28 <monochrom> that someone dares not speak up, lest we migh hire assasins to kill him/her/them
21:59:55 <ddarius> monochrom: Hiring assassins costs money and wouldn't get us our money back.
21:59:58 <monochrom> therefore, no one wants in on the action
21:59:59 <jmcarthur> that would be dumb. why not just steal his/her/their money?
22:00:01 * twink goes in for the Indian Institutes of Technology, which seems to do stochastic processes in terms of electrical engineering.
22:00:43 <monochrom> This disproves the theory "if haskell makes someone rich, everyone wants in"
22:00:59 <monochrom> haskell made someone rich and everyone wants to stay away
22:01:18 <cads> it has to make some idiot rich.
22:01:49 <jmcarthur> heck no. just get rich and hire bodyguards. easy
22:02:06 <cads> may as well me be
22:02:09 <jmcarthur> and pay off the best assassins
22:02:25 <monochrom> as for "why hire assassin, why not get money back instead": whoever told you that the human race is rational and smart is an idiot.
22:03:35 <jmcarthur> but my mama says i'm smart
22:03:47 <monochrom> in fact, try explaining that to al quaeda
22:05:34 <cads> hmm, rationally you might not have any way of assuring you'll get a fortune
22:05:52 <cads> also, it's not rational to assume you'll be killed for amassing wealth
22:06:55 <cads> but trying to become wealthy should give you an advantage over the people that rule it out as a possibility and so take no measures
22:07:46 <cads> I don't think most people will ever seriously study what it takes to make a large fortune
22:10:29 <twink> I just think it's kind of interesting. I'm not trying to make money with it.
22:11:13 <cads> can I find dudes in india to code haskell for me?
22:11:24 <ddarius> cads: Sure.
22:11:53 <monochrom> If you ask them "do you know haskellscript?" they will answer "yes" too. :)
22:12:10 <kmc_> they'll buy Teach Yourself Haskell in 3 Days
22:12:18 <andrewsw> we have over 40 years of haskell experience in all realized paradigms!
22:12:21 <cads> learn you a haskell
22:12:27 <jmcarthur> I can haz Hazkillz?
22:12:38 <twink> cads: No idea. The comment was meant for ##economics. Anyhow, I was mostly just sort of hoping to stochastically model stuff or some such.
22:14:19 <twink> cads: I'm watching http://www.youtube.com/watch?v=ya0-S1apej8 and their stochastic process stuff starts in the next lecture, http://www.youtube.com/watch?v=zU05FtRYGYU
22:16:53 <mibygl> When was Haskell first thought up?
22:17:03 <Veinor> okay, building with split-objs takes forever
22:17:27 <Veinor> probably because... oh god, it's swapping
22:17:28 <mibygl> 1987, I guess.
22:20:33 <aavogt> @where history
22:20:33 <lambdabot> I know nothing about history.
22:20:50 <aavogt> @google history of haskell
22:20:51 <lambdabot> http://www.haskell.org/haskellwiki/History_of_Haskell
22:20:51 <lambdabot> Title: History of Haskell - HaskellWiki
22:23:55 <cads> "Please now telling me what the FUCK are the monads? This was NOT in our contract" - discussion with an indian virtual programming assistant, hired for $10/hr
22:24:34 <leoncamel> cads: haha...
22:25:21 <dolio> That doesn't seem very professional.
22:28:11 <wolgo>     Couldn't match expected type `Char' against inferred type `a b'
22:28:41 <wolgo> cads: I lold
22:28:58 <Veinor> cads: haha
22:29:08 <Veinor> plz send me the monad analogies
22:29:59 * hackagebot c10k 0.4.0 - C10k server library using prefork  http://hackage.haskell.org/package/c10k-0.4.0 (KazuYamamoto)
22:30:01 <cads> what is this burrito of which you speak?
22:30:16 <leoncamel> cads: Haha, so what kind of contact is that ? A haskell monanic system ?
22:30:44 <leoncamel> s/contact/contract/
22:31:14 <monochrom> "a monad is like a paratha"
22:31:39 <monochrom> err, "a monad is like  Kati roll"
22:32:14 <Veinor> dear god, it's still compiling
22:32:24 <Veinor> ok, yeah, not using split-objs on my 500-megabyte VM
22:33:00 * hackagebot webserver 0.4.0 - HTTP server library  http://hackage.haskell.org/package/webserver-0.4.0 (KazuYamamoto)
22:34:00 * hackagebot mighttpd 0.4.0 - Simple Web Server in Haskell  http://hackage.haskell.org/package/mighttpd-0.4.0 (KazuYamamoto)
22:34:57 <monochrom> 500MB is not enough
22:35:54 <Veinor> apparently not!
22:36:07 <Veinor> on the other hand, this gives me a good way to determine the dependencies
22:36:19 <Veinor> remove .ghc and installed cabal packages, see what I need to install to get it to run :D
22:37:20 <dcoutts_> a cheaper way is to use cabal install --global --dry-run
22:37:47 <dcoutts_> it'll list everything it would install, and will ignore packages from the user package db
22:39:01 * hackagebot Lastik 0.6.1 - A library for compiling programs in a variety of languages  http://hackage.haskell.org/package/Lastik-0.6.1 (TonyMorris)
22:41:03 <monochrom> This is appetizing. I now want to eat newbie kati rolls. I should go to sleep.
22:44:02 * hackagebot Lastik 0.6.2 - A library for compiling programs in a variety of languages  http://hackage.haskell.org/package/Lastik-0.6.2 (TonyMorris)
23:06:15 <scotty> I'm trying to install caball-install from source and the bootstrap script gives me the following: Setup: At least the following dependencies are missing:
23:06:18 <scotty> time ==1.1.*
23:06:34 <scotty> Has anyone experienced this?
23:23:01 <aavogt> scotty: which ghc version and cabal-install?
23:25:16 <scotty> cabal-install-0.8.2 and ghc 6.10.4
23:25:59 <aavogt> you can probably work around by either getting a cabal-install-0.6.x  or editing the bootstrap script to grab time
23:26:32 <scotty> What is the time package?
23:26:35 <leoncamel> scotty: why not install haskell-platform ?
23:26:47 <scotty> haskell-platform isn't in my repo.
23:26:57 <scotty> I guess I could build that.
23:28:03 <aavogt> scotty: the bootstrap script downloads a bunch of packages off hackage, and then runs the Setup script for each of them
23:28:10 <scotty> Yeah
23:28:24 <scotty> Can you point me to time, or help me with the bootstrap?
23:28:27 <aavogt> ghc probably has time already installed, but an older version
23:28:41 <scotty> I can put my bootstrap file on pastebin.
23:28:42 <aavogt> scotty: it's easier to just get an older cabal-install
23:28:47 <scotty> Okay
23:29:22 <aavogt> and if you actually need the newer cabal-install, it should be possible to install  cabal-install-0.8 with a 0.6 version
23:30:39 <scotty> I can't find older versions of cabal-install on the web page.  I'm looking here: http://www.haskell.org/cabal/download.html
23:30:48 <scotty> All I see are older versions of Cabal.
23:31:14 <dcoutts_> scotty: they're not linked but they're all there, see the releases dir
23:31:46 <scotty> Ah, I see.
23:31:55 <leoncamel> scotty: Or, you can select proper version from hackage : http://hackage.haskell.org/package/Cabal
23:32:08 <scotty> So, 0.6.4 should be good, yeah?
23:32:22 <dcoutts_> scotty: 0.6.4 or 0.8.4
23:32:33 <dcoutts_> any particular reason to be using an older version?
23:33:06 <dancor> scotty: just for the record, a way to find a package like 'time' without cabal-install is on hackagedb: http://hackage.haskell.org/packages/archive/pkg-list.html
23:33:41 <leoncamel> dcoutts_: for ghc-6.10.4, cabal-install-0.6.4 is better.
23:34:04 <dcoutts_> leoncamel: in any particular way?
23:34:22 <dcoutts_> it's certainly backwards compatible
23:34:54 <dcoutts_> works back to ghc-6.6 iirc
23:35:34 <dcoutts_> leoncamel: if you're aware of any regressions I would certainly be interested
23:35:38 <leoncamel> dcoutts_: Oh. I just guess it.
23:35:43 <dcoutts_> ok :-)
23:36:09 * dcoutts_ did regression testing against hackage before releasing cabal-install-0.8.2 and 0.8.4
23:36:27 <dcoutts_> with ghc-6.10 and 6.12
23:38:21 <scotty> I have to run the bootstrap and then do runghc Setup.hs configure, right?
23:38:44 <leoncamel> scotty: sure.
23:39:08 <scotty> It said I'm missing more things: Setup.hs: At least the following dependencies are missing:
23:39:11 <scotty> HTTP >=4000.0.2 && <4001, network >=1 && <3, zlib >=0.4 && <0.6
23:39:19 <scotty> I guess I'll have to get some of these manually.
23:39:22 <dcoutts_> scotty: the bootstrap installs the dependencies
23:39:37 <dcoutts_> and it installs the cabal-install package
23:39:43 <scotty> Hm...
23:40:01 <scotty> Okay, well I already ran the bootstrap and it didn't seem to complain about anything.
23:40:15 <leoncamel> scotty: Oh. that i why I strongly suggest you to install *haskell-platform-2009*
23:40:38 <dcoutts_> if it completes succesfully it tells you where the 'cabal' program got installed
23:40:39 <leoncamel> scotty: instead of install cabal-install from scratch.
23:41:00 <dcoutts_> scotty: and it tells you that you might need to adjust your $PATH
23:41:27 <scotty> Yeah
23:41:29 <scotty> I see that.
23:41:47 <scotty> I tried typing cabal in ghci and it didn't know what I was talking about.
23:41:55 <scotty> What should I change the path to?
23:42:12 <dcoutts_> scotty: the path it says in the message
23:42:37 <dcoutts_> which will be $HOME/.cabal/bin
23:42:59 <dcoutts_> add it mind you, not replace the whole $PATH :-)
23:42:59 <scotty> http://pastebin.org/146602
23:43:19 <scotty> It says that's where PATH is already.
23:43:44 <scotty> Oh, nevermind.
23:43:48 <dcoutts_> scotty: no, it says you need to add that dir to the path
23:44:02 <scotty> Yeah, I see.
23:46:33 <scotty> Okay, I added the directory to my path, but ghci still doesn't seem to know about cabal.  Is there something I'm missing?
23:48:01 <dcoutts_> scotty: it's a command line program, not a ghci function
23:48:07 <dcoutts_> you use it from the shell, not from within ghci
23:48:12 <scotty> Oh :-O
23:48:16 <scotty> XD
23:49:24 <Gracenotes> :!
23:51:57 <scotty> Okay, I did cabal install -p parsec
23:51:57 <scotty> Resolving dependencies...
23:52:01 <scotty> No packages to be installed. All the requested packages are already installed.
23:52:12 <scotty> That means it's installed, right?
23:52:35 <dcoutts_> scotty: yes, at least the default version is
23:52:39 <scotty> Hm...
23:53:30 <scotty> ghci still complains, saying it doesn't know about the module Text.Parsec, which is what I'm trying to use.
23:53:33 <dcoutts_> the default version is version 2, if you need version 3 you can install that with cabal install 'parsec >= 3'
23:53:38 <scotty> Ah
23:53:46 <scotty> I tried doing cabal install -p parsec3
23:53:50 <scotty> Okay
23:53:51 <scotty> Thanks
23:54:24 <yuriks_> how can I catch the exception raised by 'read'?
23:55:21 <dobblego> yuriks_, you can use reads to avoid the exception in the first place
23:56:09 <scotty> Wooo, success!
23:56:16 <scotty> Thanks dcoutts_!
23:56:27 <dcoutts_> gald you got it working
23:59:03 <yuriks_> dobblego: I'm totally confused by what reads is returning
23:59:25 <dobblego> > reads ("78abcdef" :: [(Int, String)]
23:59:26 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
23:59:27 <dobblego> > reads ("78abcdef" :: [(Int, String)])
23:59:28 <lambdabot>   Couldn't match expected type `(GHC.Types.Int, GHC.Base.String)'
23:59:28 <lambdabot>         aga...
