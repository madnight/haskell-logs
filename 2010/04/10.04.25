00:11:05 <ezyang> Is there a reason hackage does builds on 6.12?
00:11:17 <kbp> I have a question: can we execute a function inside a function ?
00:11:25 <ezyang> kbp: Yes.
00:11:36 <SubStack> so you can recurse while you recurse
00:11:37 <kbp> for example: I have function doit x = doit2 x and I also want execute another function in doit to print out x (for example putStrLn (show x)) for testing purpose
00:11:55 <ivanm> ezyang: because it's the latest?
00:11:56 <c_wraith> kbp: you need to make the types work, of course
00:12:01 <ivanm> SubStack: exactly!
00:12:15 <SubStack> kbp: printing is a side effect, but you can use Debug.Trace
00:12:43 <kbp> SubStack: nah that's just an example, i want to call a specific function not just print...
00:12:48 <ezyang> ivanm: Yeah, but it results in a lot of failed builds...
00:13:11 <ivanm> ezyang: so maintainerrs should start updating their packages!
00:13:25 <c_wraith> What I don't understand is why haddock on 6.12 mangles my docs so badly.  It's discouraging.
00:13:34 <ivanm> c_wraith: there was a bug in 2.6.0
00:13:37 <ezyang> ivanm: I dunno if they notice the build fails
00:13:57 <ivanm> 2.7.0 is fixed, but I don't know if 2.6.1 (which comes with 6.12.2) is or not
00:14:39 <SubStack> > "So you can " ++ cycle "recurse while you "
00:14:41 <lambdabot>   "So you can recurse while you recurse while you recurse while you recurse w...
00:14:42 <augur> anyone know the stanford parser?
00:15:01 <ivanm> I don't
00:15:22 <augur> SubStack: stop being Xzibit :|
00:15:32 <kbp> @_@
00:16:10 <augur> > "Yo dawg, we herd u liek Haskell so we put a recurshin in ur recurshin so you can " ++ cycle "recurse while you "
00:16:11 <lambdabot>   "Yo dawg, we herd u liek Haskell so we put a recurshin in ur recurshin so y...
00:16:15 <augur> oh lame
00:16:36 <SubStack> "sup dawg" is the canonical form if I remember correctly
00:16:46 <augur> shut yo fayce >|
00:19:13 <Jafet> "Yo momma so big, she's her own least fixed point"
00:21:40 <c_wraith> Wouldn't someone who's their own greatest fixed point be larger?
00:22:46 <augur> Jafet: i imagine thats what riley from boondocks would say if he were a nerd
00:22:56 <augur> also, c_wraith, what
00:22:58 <augur> that makes no sense D:
00:57:30 <kbp> http://codepad.org/PrmQNl4A <----- in these 2 cases, which case violates the indent law?
01:05:34 <ivanm> kbp: both look like they're acceptable
01:05:45 <ivanm> but for doit2, I would keep the = on the previous line
01:05:53 <ivanm> i.e. doit2 a = a
01:06:08 <ivanm> and for doit1, why not just pattern match?
01:06:12 <ivanm> oh, and there's no otherwise there
01:06:23 <kbp> ivanm: how about the "where" word, should it start behind | or = instead of same column?
01:06:33 <ivanm> it's OK where it is
01:06:45 <ivanm> it might be better if the guards were indented slightly more, but it's OK
01:07:30 <kbp> )
01:08:12 <kbp> codepad gets server error 500 now
01:08:15 <kbp> :D nice
01:09:16 <Maxdamantus> Haskell's not indent sensitive right? When ghci says "possibly incorrect indentation" it just means I might've indented something wrong making me misunderstand my code?
01:09:51 <koala_man> Maxdamantus: it is indent sensitie
01:09:59 <Maxdamantus> Oh. :\
01:10:20 <koala_man> http://en.wikibooks.org/wiki/Haskell/Indentation
01:11:28 <Maxdamantus> I see.
01:12:01 <DigitalKiwi> I use gentoo on my vserver because it's more stable and I have better control with USE flags, this can save some RAM.
01:12:07 <DigitalKiwi> I lawled
01:12:23 <DigitalKiwi> 2 above should be in quotes
01:12:48 <Axman6> i'll USE ur flags!
01:12:56 <koala_man> I wonder what the rest of your life is like if you consider gentoo stable
01:13:03 <Axman6> heh
01:13:21 <DigitalKiwi> ivanm: is this true? does compiling openoffice save you ram?
01:13:32 <ivanm> I don't compile openoffice
01:13:41 <ivanm> spending 8 hours compiling a program I barely use isn't worth it
01:13:47 <DigitalKiwi> i heard it takes a few gig to compile, so surely it must have to save way more for it to be worth it
01:13:51 <ivanm> (if it was only say an hour, I would)
01:13:59 <ivanm> DigitalKiwi: yeah, 10 gig of temp space :s
01:14:12 <Axman6> ....
01:14:14 <Axman6> ...................
01:14:16 <Axman6> ..........................................................
01:14:18 <Axman6> o.O
01:14:23 <Axman6> christ
01:14:26 <DigitalKiwi> aww we scared off glguy :(
01:14:29 <ivanm> Axman6: what?
01:14:36 <DigitalKiwi> ivanm: i am stuck again
01:14:41 <ivanm> DigitalKiwi: :(
01:15:16 <killing-joke> maybe Axman6's blue pill is kicking in
01:15:38 <Axman6> i was astounded by the 10GB temp space needed
01:16:07 <blackdog> i assume everyone has seen funroll-loops.info?
01:16:11 <tensorpudding> Chromium requires something like 5 GB.
01:16:44 <ivanm> Axman6: well, "temp space" == "build space"
01:16:59 <Axman6> == fucking massive nonetheless!
01:17:02 <ivanm> but yeah, HDD, RAM and time usage of building OO.org is _crazy_
01:17:11 <dark> Axman6, but hey, google chrome is just like that too
01:17:14 <Axman6> blackdog: ?
01:17:21 <dark> but at least it is useful y.y
01:17:25 <Axman6> i'm no fan of google chrome either
01:17:29 <blackdog> Axman6: as long as we're kicking gentoo:)
01:17:34 <killing-joke> i have been wondering about what a good use for an extra-large EC2 image would be. there it is. (re)build Chromium.
01:17:36 * dark have daily ubuntu builds for free (chromium)
01:17:38 <Axman6> blackdog: link?
01:17:47 <blackdog> and to be fair, ghc isn't exactly a speed demon in terms of compile time either
01:17:54 <dark> although i'm using debian
01:17:58 <blackdog> http://funroll-loops.info
01:18:02 <tensorpudding> It's nice that binary systems exist so that you don't need to compile everything yourself.
01:18:10 <ivanm> blackdog: about 45 min here IIRC
01:18:49 <dark> tensorpudding, i would like to use a system fast enough for compiling everything on the fly
01:19:02 <tensorpudding> Why do you need to compile everything on the fly?
01:19:07 <killing-joke> dark, have you tried TCC?
01:19:11 <ivanm> I don't....
01:19:33 <dark> tensorpudding, i don't
01:19:38 <Axman6> blackdog: ha, have you seen where this is from? "HOLY COW I'M TOTALLY GOING SO FAST OH F***"
01:19:40 <dark> but i would like to be able
01:19:42 <halberd> I was thinking that how much of a software product you install could in theory be determined by your use of it
01:19:43 <dark> killing-joke, tcc?
01:19:47 <tensorpudding> It wastes cycles and electricity.
01:19:59 <dark> specially because source code is just too much more reliable
01:20:07 <dark> hmm, yes, i was thinking about energy too
01:20:15 <halberd> the software product could run on a virtual machine that tracks what data and code it is trying to reference, as it runs
01:20:16 <blackdog> Axman6: ... uh, from the website?
01:20:25 <dark> the flexibility outweighs the costs imo
01:20:31 <Axman6> blackdog: http://www.fenslerfilm.com/PSAS.htm, number 5
01:20:32 <halberd> and if that data and code is not already on the computer, the virtual machine could download it
01:20:45 <halberd> giving you an automatic, incremental install of only what you need
01:20:50 <dark> tensorpudding, in fact, a system written mostly in higher level languages might have this issue too
01:21:04 <Axman6> a good powtion of my time in college was spent watching those 25 videos with friends over and over again
01:21:14 <ivanm> Axman6: yeah, I know the guy who made up that quote
01:21:30 <Axman6> the fensler guy?
01:21:52 <blackdog> Axman6: that's awesome:)
01:21:52 <tensorpudding> Oh shit, the GI Joe guy.
01:21:57 <killing-joke> dark, tcc is a Fabrice Bellard tool. http://bellard.org/tcc/
01:22:01 <Axman6> :D
01:22:02 <killing-joke> nine times faster than gcc
01:22:08 <tensorpudding> That's like a blast from 2003.
01:22:10 <ivanm> no, the "OMG I'm going so fast" quote was made up by redhatter to make fun of someones CFLAGS in a bug report
01:22:20 <ivanm> _real_ gentooers aren't crazy about their CFLAGS, etc.
01:22:34 <tensorpudding> Sounds like a Scotsman to me.
01:22:37 <dark> killing-joke, ah, yeah, i found fun to see C... scripts
01:22:51 <Axman6> ivanm: bah, it's totally from that video i linked (http://www.fenslerfilm.com/moviesF/PSAsmall/FenslerFilm_PSA05_small.mpg)
01:22:54 <killing-joke> tcc is fast enough to allow you to write scripts in C and put a shebang at the top of the file, to run them "interpreted"
01:23:35 * Axman6 is still really looking forward to clang being production ready
01:23:38 <halberd> of course, that could sometimes cause problems with timeouts
01:23:44 <Axman6> well, i only use it for C, where it already is
01:23:52 <dark> killing-joke, i was thinking about having a 'tips' file that would give compiler hints, that couldn't possibly change the meaning of the code but would make faster to apply optimizations
01:23:53 <blackdog> Axman6: chicken and egg, perhaps.
01:24:01 <killing-joke> clang is going to remake the world in some weird ways
01:24:15 <dark> killing-joke, i'm not sure if any compiler does that
01:24:24 <killing-joke> how many QA people have jobs because gcc is ... uhhh, not ideal?
01:25:06 <Axman6> aye
01:25:29 <Axman6> even if clang produced shitty code, it would still be worth using due to its error messages
01:25:36 <killing-joke> yes
01:25:56 <dark> hmmm.. o.o
01:25:58 <killing-joke> heaven knows there is enough sheeyott flowing INTO the compilers
01:25:59 <tensorpudding> It's a race to see how fast the BSD's will switch to Clang.
01:26:06 <Axman6> and IDe integration, which they've done a fantastic job with in Xcode
01:26:08 <dark> after you said that, i'm installing clang right now.. heh
01:26:09 <Axman6> IDE*
01:26:22 <ivanm> Axman6: I think for most people they'd prefer good performance over good error messages
01:26:28 <ivanm> and not everyone cares about IDE integration
01:26:52 <Axman6> the thing is, clang also produces better code than gcc
01:26:54 <blackdog> ivanm: gcc performance is nothing special, though.
01:27:00 <dark> ivanm, the build systems should be generally compiler-agnostic
01:27:05 <dark> or with few places to change
01:27:08 <blackdog> the intel compilers used to smoke gcc pretty regularly, iirc
01:27:14 <ivanm> blackdog: true
01:27:16 <blackdog> of course, gcc runs on toaster ovens...
01:27:27 <ivanm> blackdog: and intel compilers don't work on amd chips apparently...
01:27:36 <ivanm> dark: unless they use compiler-specific stuff
01:27:36 <Axman6> if anyone's interested in why clang is awesome, check out http://arstechnica.com/apple/reviews/2009/08/mac-os-x-10-6.ars/9
01:27:41 <ivanm> like GHC does
01:27:48 <ivanm> Axman6: except I don't use OSX ;-)
01:28:02 <Axman6> ivanm: it doesn't matter, stop being a snob ;)
01:28:16 <ivanm> heh
01:28:31 <dark> osx? isn't clang fine to use with, say, debian?
01:28:39 <ivanm> Axman6: the intro on that review doesn't make me think clang is great though
01:28:49 <ivanm> oh wow, apple is using clang to replace gcc; whoop-de-do
01:28:51 <tensorpudding> clang runs perfectly fine on debian
01:29:00 <Axman6> dark: it sure is
01:29:05 <tensorpudding> though you can't replace gcc with clang on debian yet
01:29:13 <Axman6> ivanm: way to completely miss the point of the page
01:29:18 <tensorpudding> too much stuff doesn't compile yet
01:29:23 <killing-joke> can clang build a 2.6 kernel?
01:29:24 <ivanm> Axman6: :D
01:29:27 <tensorpudding> no
01:29:30 <Axman6> it's getting there though
01:29:32 <dark> "yet"? hm o.o
01:29:40 <killing-joke> that's a pretty important goal
01:29:43 <tensorpudding> they're working on it
01:29:51 <ivanm> Axman6: I wonder how much of clangs improved speed, etc. is because gcc _has_ to deal with other languages as well
01:29:58 <Axman6> C and Objective-C are complete, C++ isn't, but getting there
01:30:05 <Axman6> well "complete"
01:30:06 <ivanm> killing-joke: the kernel uses gcc-specific extensions
01:30:25 <tensorpudding> GCC only deals with a couple languages more than Clang.
01:30:38 <Axman6> ivanm: none really, all languages get converted into its IR and them compiled. it's just a crappy compiler ;)
01:30:44 <ivanm> wait, it generates _images_? doesn't sound like it's command-line friendly then...
01:30:50 <DigitalKiwi> is that a...blue eyes white dragon...
01:30:50 <tensorpudding> Ada, Fortran and some other odds and sods
01:30:52 <ivanm> Axman6: maybe, maybe not
01:30:53 <dark> it's a bit sad to me to see that everyone wants to replace gcc :P (and other gnu tools). openbsd, apple..
01:30:55 <killing-joke> ivanm, somebody at the clang project is probably working on a plugin to parse code salted with those little shrapnel pieces
01:30:55 <Axman6> ivanm: huh?
01:31:06 * DigitalKiwi refuses to take that website seriously
01:31:12 <dark> tensorpudding, java.. o.o (not very complete)
01:31:17 <ivanm> Axman6: the static analysis stuff
01:31:18 <Axman6> dark: why? gnu and gnu tools suck :P
01:31:21 <tensorpudding> Fuck gcj.
01:31:27 <Axman6> ivanm: it doesn't produce images
01:31:30 <ivanm> unless that's xcode, even though they say it's from clang
01:31:41 <Axman6> the images there are screen caps of Xcode
01:31:48 <ivanm> DigitalKiwi: arstechnica?
01:31:52 <ivanm> Axman6: right, they could have said so
01:31:56 <Axman6> which uses CLang as its static analyser
01:31:57 <dark> Axman6, i think they mismanage things, but i like the project
01:32:13 <DigitalKiwi> ivanm: well at the least the page he linked to
01:32:13 <ivanm> Axman6: I can see better performance and error messages being helpful
01:32:16 * Axman6 hates the GPL, do dislikes the project with a passion
01:32:16 <DigitalKiwi> but perhaps the whole site
01:32:20 <ivanm> DigitalKiwi: yeah
01:32:21 <DigitalKiwi> i have not yet decided
01:32:28 <killing-joke> i thought the feature page was worth reading   ...   http://clang.llvm.org/features.html
01:32:29 <dark> Axman6, ... gpl?
01:32:39 * ivanm vows to license all new projects under the GPL just to piss Axman6 off
01:32:39 <dark> Axman6, do you like open source, at least?
01:32:47 <ivanm> dark: he uses a proprietary OS; go figure
01:32:47 <Axman6> yes
01:32:53 <Axman6> and i do not consider the GPL to be open
01:32:57 <dark> Axman6, gpl is a strong contributor to linux success, linus says
01:33:09 <Axman6> i greatly dislike linux too ;)
01:33:21 * Axman6 -> dinner
01:33:26 <DigitalKiwi> linux kernel is gpl 2 right?
01:33:26 <tensorpudding> I like Linux but I dislike the GPL.
01:33:36 <dark> @.@
01:33:36 <lambdabot> Maybe you meant: . @
01:33:37 <DigitalKiwi> the last free gpl
01:33:39 <DigitalKiwi> amirite?
01:33:44 <dark> what's the problem with gpl?
01:33:46 * killing-joke is now known as L1NUX_PH4NB01
01:33:54 <dark> DigitalKiwi, yes
01:34:03 <DigitalKiwi> np: Sick Puppies - War
01:34:13 * DigitalKiwi thought it fits the tone of conversation
01:34:28 <Axman6> dark: its a disease
01:34:33 * DigitalKiwi plays this everytime people argue about window managerees or text editors
01:34:41 <DigitalKiwi> (not really)
01:34:51 <dark> Axman6, ? o.o why do you think so?
01:35:00 <dark> DigitalKiwi, hahaha
01:35:20 <ivanm> Axman6: http://producingoss.com/en/license-choosing.html#license-choosing-gpl (especially the "Is the GPL free or not free?" bit)
01:35:21 <dark> Axman6, not even microsoft thinks that anymore (since they released some linux code as gpl, anyway)
01:35:26 <DigitalKiwi> if that was true i would have 20k listens of this instead of everything else i have >.>
01:35:40 <ivanm> DigitalKiwi: how is 3 less free than 2?
01:35:47 <DigitalKiwi> have you read it?
01:36:04 <dark> the sole problem with 3 is that it's not compatible with 2
01:36:04 <DigitalKiwi> it gets all na...naughty like
01:36:05 <ivanm> not the entire thing, no
01:36:13 <dark> but most gpl2 software is gpl 2 or more
01:36:44 <DigitalKiwi> "this is war, and it never ends, this is warrrr, and it never ends"
01:36:48 <Maxdamantus> Eh, so how do I get "if" on a line following "where foo =" .. I can get it after the = but then the "then"/"else" needs to be indented even further.
01:37:47 <dark> DigitalKiwi, =DDDD
01:39:03 <DigitalKiwi> grr why won't this do what i want!
01:39:22 <dark> DigitalKiwi, because you are not asking the right way
01:39:55 <DigitalKiwi> hehe
01:44:52 <Axman6> dark: i don't believe the GPL is free because I can't use someone else's GPL'd code without being forced to make my code GPL'd too
01:45:10 <Axman6> which I don't want to do, because it leads to the above situation
01:45:30 <blackdog> you are gift horsing, Axman.
01:45:31 <Axman6> it's a disease because it infects other people's code
01:45:53 <blackdog> there is no obligation to use GPLed code, and you don't get to dictate the terms under which someone else gives something away
01:46:31 <blackdog> I tend to licence my code BSD because I'd like to see it used as widely as possible, but it would be reasonable for me to have other aims and therefore licence it as GPL
01:46:39 <Axman6> no i'm not. if you're going to make your code free, make it free, not some strange definition of free which emposes restrictions on people which they may feel are unreasonable
01:46:43 <tensorpudding> You can still lament the fact that it's cooperation that is lost due to creative differences.
01:47:08 <blackdog> tensorpudding: see, that's a reasoned and subtle distinction, and therefore completely out of place in this firefight.
01:47:21 <tensorpudding> The whole having to recreate the wheel for reasons of ideology.
01:47:26 <Axman6> blackdog: i never said i did have the right to dictate what licence people use, but i can disagree with their choice
01:48:03 * Axman6 completely agrees with tensorpudding
01:48:22 <tensorpudding> It's the same motivation which leads people to get fussy over using any proprietary code.
01:48:36 <Axman6> i feel the GPL stunts progress with ideology, much like religion
01:48:37 <blackdog> Axman6: that's fine. but that's not what you did - you claimed that GPLed code is not free
01:48:50 <Axman6> i don't think it is free
01:48:57 <Axman6> it's just another set of restrictions
01:49:13 <tensorpudding> GPL code isn't free in any sense I would use.
01:49:25 <tensorpudding> Well, besides being free to use.
01:49:52 <blackdog> you can read it, you can learn from it, you can run closed code on it.
01:50:00 <blackdog> i think you are straining at gnats
01:50:08 * Axman6 is glad he has found someone who agrees with him, is also more reasonable than he is :P
01:50:38 <DigitalKiwi> gah it's almost 4 :(
01:50:41 <DigitalKiwi> and i'm still stuck
01:50:41 <tensorpudding> You can read it, and you can learn from it, but it comes with restrictions on how you can use it.
01:50:46 <DigitalKiwi> i won't sleep if i am stuck
01:50:51 <halberd> nothing is really free, the question is whether the GPL is more or less free than other licenses like BSD or proprietary licenses
01:51:05 <halberd> it is more free than proprietary licenses but less free than the BSD
01:51:27 <halberd> then the question is whether the reduction in freedom compared to the BSD is made up for in its other advantages
01:51:28 <tensorpudding> It is more free than proprietary licenses, sure.
01:52:09 <blackdog> and then there are the second-order consequences to consider - does the GPL encourage more free software to be written, etc etc
01:52:11 <ivanm> GPL ensures transitive freedom
01:52:18 <tensorpudding> I don't see explicit advantages.
01:52:25 <ivanm> BSD-style licenses don't
01:52:25 <halberd> ivanm said it
01:53:03 <Axman6> ivanm: that's not an advantage to me
01:53:06 <tensorpudding> It ensures that political ideology will consistently divide the community.
01:53:21 <Axman6> because i'm the one who is hindered by it, not helped
01:53:35 <dark> Axman6, of course you can. you don't need to accept gpl to just use the code, to begin with
01:53:36 <ivanm> Axman6: but your users maybe be hindered by it
01:53:58 <Axman6> not if i use a BSd licence
01:53:59 <Axman6> D*
01:54:06 <ivanm> Axman6: OK, the users of your users
01:54:41 * Axman6 doesn't want anything to do with the users and abusers of his users :P
01:54:44 <tensorpudding> In any case, for pragmatic reasons both sides are going to end up using some of the other's code.
01:54:53 <dark> Axman6, you can't link it to your code and distribute it without distributing it as gpl. but, if you want to distribute some derived code, it's reasonable to give your code too imo
01:55:09 <ivanm> Axman6: if I write some code and someone forks it and improves it, I'd like to see _how_ they improve it
01:55:20 <Axman6> so ask them
01:55:28 <Adamant> it all depends on what you are doing and what you want.
01:56:22 <Axman6> if i write a really fucking useful piece of code, why do i have the right to see how people use it? sure i'd like to know what changes they've made (to improve my code), but why should a company using my library be forced to show me all their code because of that? it's nonsense
01:56:39 <Adamant> if your objective is to popularize some technology among all software developers, putting stuff as GPL is arguably counterproductive.
01:56:40 <blackdog> Axman6: they don't have to. they just don't get to use your code.
01:56:52 <Axman6> but i want them to use my code
01:57:01 <blackdog> so licence it BSD:) but that's your choice.
01:57:03 <Axman6> if its the best tool for the job, then they should be able to use it
01:57:18 <blackdog> that's not an automatic right.
01:57:19 <Adamant> OTOH, the reason you can have multiple Linux commercial distros is arguably the GPL
01:57:26 <dark> Axman6, no, gpl does not give the developer this right. you can use the code privately, without telling anyone for what you are using it
01:57:35 <ivanm> blackdog: right, use whatever license you want but stop bashing people who choose differently
01:57:46 <mercury^> If you wrote the best code for some task, you might want to use the power that gives you to do some good. That could be to have more people change to a more free license.
01:57:48 <blackdog> dark: ah, the software-as-a-service loophole:)
01:57:53 <dark> Axman6, gpl only restricts your ability of distributing a modified version of the code
01:57:54 <Axman6> where would the world be if SQLite were GPL'd?
01:58:06 <dark> yes, gpl doesn't make web services free
01:58:12 <Adamant> Axman6: or OpenSSL
01:58:18 <dark> Axman6, in the same place it is
01:58:26 <blackdog> it's all a moot point now really. there's very little non-open but redistributed code around
01:58:39 <ivanm> dark: AGPL!
01:58:45 <blackdog> everything's web services, at which point BSD/GPL makes no difference.
01:58:50 <Adamant> but, the reason Linux commercial distros haven't blown up into a repeat of the Unix wars
01:58:50 <dark> ivanm, agpl isn't gpl
01:58:54 <Axman6> dark: well, no, SQLite is the most widely used database in the world, it's used everywhere
01:59:10 <rsaarelm> Btw, did I understand correctly that LGPL works a bit differently with Haskell software development than with eg. C, since Haskell doesn't do as decouplable dynamic linking as C?
01:59:12 <Adamant> is quite arguably the GPL requiring sharing.
01:59:14 <ivanm> I thought oracle was...
01:59:26 <Axman6> if it was GPL'd, then everyone would be writing their own database, to reproduce what SQLite could be soing
01:59:29 <Axman6> d*
01:59:31 <Adamant> ivanm: more installs of SQLite. it's in everything.
01:59:42 <dark> Axman6, gpl would be only a issue if one wants to deploy a proprietary program, and don't want to share the code, *but* want to use a gpl library
01:59:46 <mercury^> Axman6: some would have published their code.
01:59:47 <DigitalKiwi> ok as long as we are talking about something licenses i won't feel bad asking if anyone can help me with some fortran >.> or at least tell me if this pseudocode is even right (it's been wrong before so >.>) http://codepad.org/bav382bz I am working on post_order_tree_evaluation
01:59:51 <Adamant> Axman6: everyone doesn't write MySQL just because it's GPL'ed.
01:59:58 <ivanm> Adamant: how about just considering proprietary software?
02:00:09 <Axman6> ivanm: SQLite is used everywhere, phones, servers, browsers, you probably have at least 3 applications running on your computer right now using it
02:00:09 <ulfdoz> ivanm: There are even more mysqls than oracles.
02:00:18 <Adamant> ivanm: it would probably still be true even then
02:00:24 <ivanm> Adamant: hmmm...
02:00:37 * ivanm checks what he has installed that uses sqlite
02:00:44 <Axman6> everything
02:00:48 <Axman6> all of it!
02:00:51 <Adamant> your browser is the first likely target
02:00:56 <ivanm> Adamant: yeah
02:00:57 <Axman6> Firefox uses it
02:00:59 <dark> i know firefox uses it, but i don't use firefox
02:01:00 <ivanm> Axman6: GHC doesn't!
02:01:04 <DigitalKiwi> Required By    : aircrack-ng  aircrack-ptw  aria2  heimdal  libgda  libwebkit  lua-sqlite3  mpd  nss  python  python-apsw  qt  redland  smalltalk
02:01:08 <dark> chromium?
02:01:10 <Axman6> GHC should!
02:01:11 <Axman6> :P
02:01:14 <ivanm> why?
02:01:16 <Adamant> I think chromium and safari both use it
02:01:18 <killing-joke> history
02:01:19 <tensorpudding> What would GHC do with SQlite?
02:01:21 <Axman6> i'd be surprise of chromium didn't
02:01:21 <ivanm> what does it need a DB for? it's a _compiler_!
02:01:23 <dark> history?
02:01:29 <dark> i want my history in a damn text file
02:01:31 <Axman6> tensorpudding: what wouldn't it do? :P
02:01:34 <killing-joke> browser URLs
02:01:45 <Adamant> dark: believe it or not, it's an improvement
02:01:50 <Axman6> anyway, time for me to head off.
02:01:52 <dark> i like unix
02:02:00 <dark> i want my text files back :P
02:02:04 <tensorpudding> Databases are not the answer to every question of "where to put some data"
02:02:07 <Axman6> urgh
02:02:16 <killing-joke> dark, try dillo. :)
02:02:17 <Adamant> getting some data from Firefox and similar browsers with wacky legacy data formats was previously a pain in the ass
02:02:27 <ivanm> wtf? why does subversion use sqlite? :s
02:02:28 <killing-joke> you'll be begging for Opera or Firefox within an hour
02:02:28 <dark> i like chromium config JSON
02:02:30 <DigitalKiwi> so if anyone can help me with this problem i will adopt your chosen methodology of license choosing for at least a day
02:02:34 <Axman6> tensorpudding: with SQLite, they sort of can be. making your own file formats based on SQLite is fairly easy
02:02:36 <DigitalKiwi> how's that for incentive!?
02:03:13 <Adamant> DigitalKiwi: that's only useful if you're gonna write code today :P
02:03:16 <Adamant> but what's the problem?
02:03:38 <halberd> Firefox is released under the GPL and the Mozilla public license
02:03:45 <tensorpudding> But then you have to add a dependency to SQlite, and then add code to interface with it in your program, and that isn't worth it for something as trivial as storing command history.
02:03:51 <halberd> it could still be released under the GPL if SQLite were GPL
02:03:52 <halberd> too
02:03:56 <dark> ivanm, well, at least git doesn't use it
02:04:00 <killing-joke> sqlite is pd
02:04:39 <DigitalKiwi> http://codepad.org/bav382bz i'm not sure if the code for post_order_tree_evaluation is right (construct_tree was wrong)
02:05:35 <DigitalKiwi> i've implemented it but it's not working, and i don't know why :(
02:05:44 <DigitalKiwi> obviously if i did i would fix it >.>
02:14:53 <Maxdamantus> Gahdam. This indentation stuff is really getting annoying.
02:15:07 * Maxdamantus hasn't even got to a construct yet that looks like it would be ambiguous without it.
02:15:26 <Maxdamantus> Hm. Actually, if/else maybe.
02:16:44 <chrisdone> "this indentation stuff"?
02:17:56 <dark> you can use { } and ; too, Maxdamantus
02:20:12 <Maxdamantus> Hmm.. But what I'm trying to make work all works (other than type stuff I've yet to figure out) on one line.
02:20:33 <Maxdamantus> With no semicolons, curly brackets, or indents.
02:21:23 <dark> @_@
02:21:27 <Maxdamantus> bsplit b num = bsp' 0 where bsp' n = let o = floor(num / b ^ n) in if o == 0 then [] else o `mod` b : bsp' (n + 1)
02:21:29 <Maxdamantus> Hrm >_<
02:21:31 <dark> Maxdamantus, what about trying perl?
02:21:50 <DigitalKiwi> :(
02:22:16 <Maxdamantus> I want to try Haskell because it seems more interesting.
02:22:29 <chrisdone> how can something "seem" interesting? :p
02:22:31 <fax> haskell is pretty cool
02:22:42 <tensorpudding> i don't see any point in having the the let clause inside the where.
02:22:43 <Maxdamantus> Because it's purely functional, which I have not tried yet.
02:22:43 <dark> i think you will eventually drop the one liner stuff
02:24:04 <Maxdamantus> Maybe.
02:24:28 <Maxdamantus> This guide (learn you a haskell) didn't seem to mention indenting, it just randomly started indenting code
02:24:58 <halberd> haskell seems to be written diagonally
02:25:42 <ivanm> @tell BONUS according to Maxdamantus you need to have something up front in LYAH about indentation; apparently you just start randomly indenting code rather than saying what you have to do and why
02:25:42 <lambdabot> Consider it noted.
02:25:53 <kynky> haskell seems very pure, not lots of rubbish extras like c++ has
02:26:02 <dark> halberd, i see a lot of flat ml code
02:26:10 <dark> at least well-written ones
02:26:21 <dark> dunno about haskell
02:26:27 <tensorpudding> Haskell's syntax is fairly sparse.
02:26:28 <Maxdamantus> Mmm.. I don't really like it when languages take long to learn due to their extreme complexities.
02:26:53 <Maxdamantus> Haskell seems to go against that - it seems relatively simple itself
02:27:08 <scriptdevil> Has this been reported? Hoogle links to base 4.2.0.0 which actually has been replaced by 4.2.0.1
02:27:13 <chrisdone> in before knots
02:27:23 <tensorpudding> It just looks messy because of the combinators, arrows and all that stuff
02:27:41 <kynky> im not saying haskell got lots of syntax to learn, but there are some things which take a bit of thinking to learn like, monads and cps
02:27:57 <chrisdone> CPS isn't really specific to Haskell
02:28:13 <tensorpudding> Definitely it's not easy to learn.
02:28:17 <ivanm> scriptdevil: give it a week or so, then send ndm an email
02:28:31 <ivanm> the new ghc (including new base) only came out on thursday or something
02:29:09 <DigitalKiwi> over 500 lines now :(
02:29:24 <tensorpudding> Does it include even more warnings?
02:29:32 <scriptdevil> ivanm: Ok :)
02:29:41 <ivanm> tensorpudding: in a sense: qualified explicit imports now generate an error
02:29:44 <dark> learning haskell is taking long for me, except that i'm not really dedicated.. i just see some snippets here and there, and do some basic stuff. i'm into ruby and python right now .-. but i want to see some haskell in some months
02:29:46 <chrisdone> monads and cps are easy to learn the "what" and the "how", it's more "why" that puzzles
02:30:03 <tensorpudding> What do you mean by qualified explicit imports?
02:30:16 <ivanm> import qualified Data.Map as Map (Map.insertWith)
02:30:32 <tensorpudding> Oh.
02:30:47 <ivanm> gtk2hs was using that in their forked c2hs
02:30:52 <fax> I learned CPS in scheme
02:30:57 <kynky> well writing your own monads and cps harder than just using existing stuff i thought, for a beginner
02:30:58 <ivanm> (the darcs version has it fixed, but the release still uses it)
02:31:04 <chrisdone> yeh it's easy in scheme
02:31:12 <tensorpudding> That sounds problematic.
02:31:34 <fax> but "CPS" in haskell is a monad (Cont)
02:32:09 <tensorpudding> Not surprising.
02:32:10 <kynky> lots of things are monads , IO , lists etc
02:32:10 <chrisdone> my favourite monad
02:32:39 <chrisdone> i want to use it for a web site
02:32:42 <tensorpudding> @type callCC
02:32:43 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
02:34:17 <tensorpudding> it'd be peirce's law without the MonadCont parts
02:35:18 <dark> tensorpudding, Hmmm Ãµ.o
02:35:39 <dark> tensorpudding, i had some classes on curry-howard isomorphism, but i missed most of them
02:35:48 <dark> i regret that
02:37:34 <dark> pierce's law is the strangest law of logic i know of, it's completely non-intuitive (for me)
02:37:51 <tensorpudding> Pun intended?
02:38:59 <dark> haha.. i can barely identify a pun on intuitionist logic, but it wasn't indented
02:39:52 <tensorpudding> ((a -> b) -> a) -> a is kinda daunting but it's not too hard
02:42:15 <Maxdamantus> Is that like.. let foo bar = bar 5?
02:42:33 <Maxdamantus> nvm
02:42:48 <dark> this is cps, yes
02:43:13 <Maxdamantus> Ah yeah, it seems to be what I thought, but an extra call or something.
02:48:47 <Maxdamantus> Oh cool, I think I figured out the indenting of this thing.
02:59:02 <scriptdevil> Can someone explain such a data type declaration? data Hide2 t where Hide2 :: t a b -> Hide2 t
02:59:14 <Baughn> That's a GADT
02:59:51 <Baughn> I'd explain the details, but I've just barely figured them out myself and would probably make a hash of it. :/
02:59:59 <Baughn> I'll try to explain any concrete questions, though
03:00:31 <Baughn> (And /that/ one looks to be some kind of existential.. thingy... as well. I'm uncertain how it works.)
03:01:02 <Twey> More than that, it's a type family
03:01:04 <Twey> I think
03:01:30 <scriptdevil> Ok. I figured out that it possibly takes something like SomeType Int Float and makes it Hide2 Sometype
03:01:42 <Twey> Oh, maybe not
03:01:59 <Baughn> It hides two types, definitely..
03:02:02 <Maxdamantus> Hmm.. This probably doesn't make sense on its own, but I was trying to narrow down this error I can't understand - apparently there's some type ambiguation and it can't decide whether to use Integral or RealFrac or something: Prelude> let bsp' a b c = (let o = floor (a / b ^ c) in (4 `mod` b))
03:02:14 <Maxdamantus> Then bsp' 1 2 3 will fail with that.
03:02:20 <Baughn> scriptdevil: That much is correct. What I'm not sure is, er, how it's useful..
03:02:36 <Baughn> There's no typeclass contexts in there, so I don't see how you'd extract.. anything
03:02:46 <Baughn> scriptdevil: Where did you see it?
03:02:50 <scriptdevil> Baughn: Hmmmm. In most of the Haskell books, where isn't mentioned to work with data
03:02:57 <scriptdevil> Baughn: In the source code of Camp
03:03:03 <scriptdevil> Camp.Core.Types
03:03:15 <Baughn> Camp? Hackage name?
03:03:27 <tensorpudding> Camp is that Darcs fork isn't it?
03:03:41 <Baughn> And thus not on hackage, I see
03:03:42 <scriptdevil> Baughn: http://projects.haskell.org/camp/index
03:03:49 <scriptdevil> tensorpudding: Yeah :)
03:04:04 <Maxdamantus> Hm. I don't think I've thought of this yet.. Does it not know what to use because I'm using b as the left operand of ^, which should be an Integral, aswell as on the right of `mod` which should be a .. nvm, that's an Integral.
03:05:22 <Baughn> scriptdevil: Oh dear lord
03:05:31 <Baughn> unsafeCoerce...
03:05:59 <Baughn> scriptdevil: I'm going to go out on a limb here and tell you /not to copy that/.
03:06:25 <Baughn> In fact, don't even look at it too closely. It might affect your mind.
03:06:43 <scriptdevil> Baughn: I saw that. :D
03:07:02 <scriptdevil> http://en.wikibooks.org/wiki/Haskell/GADT < Seems ok. Thanks for the name Baughn, I wouldn't have known where to look for it
03:07:19 <scriptdevil> Baughn: I need to rip apart some real world app to learn practical Haskell. Where?
03:07:25 <Baughn> scriptdevil: GADTs are /really/ nice, even if they can be abused to do this. :P
03:07:26 <Maxdamantus> Ah. Seems I can't make something from floor do something from mod.
03:07:44 <Baughn> scriptdevil: ..I don't really know. That's not how I learn. :/
03:08:17 <scriptdevil> Maxdamantus: Use Data.Fixed.mod'
03:08:30 <chrisdone> scriptdevil: darcs, xmonad, hyena
03:09:06 <Maxdamantus> O_o
03:09:17 <Baughn> > mod (floor 3.2) 2
03:09:18 <Maxdamantus> What's wrong with the normal mod?
03:09:18 <lambdabot>   1
03:09:31 <Baughn> Maxdamantus: What problem are you seeing, exactly?
03:10:03 <Maxdamantus> floor (pi) + (mod 4 5)
03:10:13 <scriptdevil> Maxdamantus: I thought you wanted something like floor(mod 4.6 3.3)
03:10:16 <Baughn> > floor pi
03:10:17 <lambdabot>   3
03:10:22 <Baughn> > floor pi + mod 4 5
03:10:23 <Maxdamantus> Ambiguous type variable `t' in the constraints: `Fractional t' arising from a use of `+' at <interactive>:1:0-21 ...
03:10:23 <lambdabot>   7
03:10:47 <Baughn> Maxdamantus: None of your parantheses were necessary, though they wouldn't /hurt/
03:11:09 <Maxdamantus> Mmm.. I was just deriving stuff and didn't bother to remove them.
03:11:32 <Maxdamantus> Does the bot have something like mod = Data.Fixed.mod' ?
03:11:35 <Baughn> Maxdamantus: That said, the code you quoted clearly works.
03:11:38 <Baughn> @src mod
03:11:38 <lambdabot> Source not found. Maybe you made a typo?
03:11:42 <Baughn> :t mod
03:11:43 <lambdabot> forall a. (Integral a) => a -> a -> a
03:11:48 <Baughn> :t floor
03:11:49 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
03:11:49 <Maxdamantus> It's not working in my ghci. :\
03:12:05 <Maxdamantus> They have the same types as that too
03:12:21 <Baughn> > floor (pi) + (mod 4 5) -- Just in case something is horribly, horribly wrong
03:12:22 <lambdabot>   7
03:12:50 <Baughn> Maxdamantus: So to clarify, "Prelude> floor pi + mod 4 5" gets you an error?
03:12:54 <Maxdamantus> http://pastebin.com/xidkYu3g
03:13:07 * Maxdamantus tries again in a fresh interpreter.
03:13:12 <Baughn> Oh, wait. "Ambiguous"..
03:13:28 <Maxdamantus> Ah ffs, I must've screwed with mod somewhere.
03:13:31 <Baughn> Maxdamantus: Try "floor pi + mod 4 5 :: Integer"
03:13:32 <Maxdamantus> nvm
03:13:51 <Baughn> Maxdamantus: It just doesn't know what type you want. GHC 6.12 has expanded defaulting rules, which is why I don't have a problem here.
03:13:58 <Maxdamantus> Except I seem to be getting it on this source file when I use `ghc`
03:14:13 <Baughn> The compiler is stricter about it than the interpreter, too
03:14:17 <Maxdamantus> Ah.
03:14:39 <Baughn> It isn't saying "there are no types that make this work", it's saying "there are too many types that make this work, please pick one".
03:16:30 <scriptdevil> chrisdone: Thanks :)
03:16:36 <Maxdamantus> Hmm.. Just noticed, that's actually not the problem. >_<
03:19:18 <kolmodin> Igloo: code.haskell.org appears to be down
03:19:19 <mreh> Cale: it's all better now
03:19:22 <mreh> \o/
03:19:30 <Maxdamantus> It appears to have the same error, but looks to me for a different reason, and can't see where I would explicitly say the type: > let test a = floor (1/a^1) + mod 4 a
03:19:40 <kolmodin> Igloo: oh, now it worked better
03:19:47 <mreh> I need more practice writing efficient code, any suggestions?
03:21:11 <Jafet> Beat msieve
03:21:43 <Jafet> (You probably need to patch ghc a bit)
03:22:02 <Baughn> Implement dynamic optimization of some sort in ghc. ;)
03:22:38 <Maxdamantus> > let a = 4 in floor (1/a^1) + mod 4 a
03:22:39 <lambdabot>   Ambiguous type variable `b' in the constraints:
03:22:39 <lambdabot>    `GHC.Real.Integral b'
03:22:39 <lambdabot>   ...
03:22:41 <Jafet> I think factorization is a good overall test
03:22:55 <Cale> mreh: hey, cool
03:23:16 <Cale> mreh: What was causing the problem? Was it just that accumulation?
03:23:30 <mreh> Cale: yeah, quite surprisingly
03:23:54 <mreh> I just "put $| rdeepseq"ed the accumulator
03:35:24 <DigitalKiwi> ivanm: it works!
03:36:01 <ivanm> \o/
03:36:03 <ivanm> what was the problem?
03:36:21 <DigitalKiwi> there were a few little things
03:36:44 <DigitalKiwi> i think i can make it better than it is right now but it works
03:37:08 <ivanm> recursively and everything?
03:47:02 <Fredrich3> Hi, i *really* need some assistance. I have a problem i really want to do, but i can't figure out a decent way to do it (or even a working way to do it :P). I need to define a function which creates a list with 1 as an element, 2n+1 as an element, and 3n+1 *and* have it in order (ie, lowest to highest)
03:47:53 <Twey> f n = sort [1, 2 * n + 1, 3 * n + 1]
03:47:55 <dibblego> Fredrich3, is it for homework?
03:48:10 <Fredrich3> not my homework, no
03:48:19 <DigitalKiwi> someone elses homework?
03:48:43 <halberd> what he probably means is he wants to generate a list of all numbers of the form 2n+1 or 3n+1 for an integer n, in sorted order
03:48:44 <Fredrich3> It's from a homework question - but i just want to do it because it looks freaking annoying
03:48:53 <DigitalKiwi> oh you want annoying
03:49:01 <DigitalKiwi> want to see my homework? D:
03:49:10 <mail> nop
03:49:11 <Fredrich3> nooo
03:49:15 <DigitalKiwi> yes you do!
03:49:18 <DigitalKiwi> you want annoying!
03:49:56 <dibblego> Fredrich3, what have you tried so far?
03:50:06 <Botje> Fredrich3: here's an idea: generate the lists separately and merge them together later on
03:51:04 <Botje> although i don't see why that's necessary, since 2n+1 < 3n+1 < 4n+1 < ...
03:51:05 <Fredrich3> i've tried intList' a = a : (intList' (2*a+1))++(intList' (3*a+1)) and other stuff which i have since deleted :P
03:51:16 <Fredrich3> Botje: but they would be infinite lists?
03:51:33 <DigitalKiwi> to sum it up: you are given fully parenthesized infix equations, you have to build an expression tree, then postfix traverse it to display RPN, then postfix traverse evaluate it, display intermediate results and answer, then take that RPN equation you got and use a stack to parse it, pringing intermediate values, and then compare the answers
03:51:40 <DigitalKiwi> To top it all off
03:51:46 <DigitalKiwi> IT IS IN FREAKING FORTRAN >.>
03:51:49 <Cale> > let (x:xs) /\/ (y:ys) = case compare x y of { LT -> x : (xs /\/ (y:ys)); EQ -> x : y : (xs /\/ ys); GT -> y : ((x:xs) /\/ ys) }; foo = 1 : map (\n -> 2*n+1) foo /\/ map (\n -> 3*n+1) foo in foo
03:51:50 <lambdabot>   [1,3,4,7,9,10,13,15,19,21,22,27,28,31,31,39,40,43,45,46,55,57,58,63,63,64,6...
03:51:52 <Cale> done
03:52:17 <Cale> Fredrich3: You just need an ordered merge :)
03:52:32 <fax> I like /\/
03:52:33 <Fredrich3> thanks, now i need to read it
03:52:41 <mail> can't be sorting infinite list
03:52:48 <DigitalKiwi> how is it haskell programmers shoot themself in the head? :(
03:53:12 <Botje> DigitalKiwi: they generate a new instance of their head which is already blown off
03:53:23 <mail> mhhm I wonder how you can simulate non dterminism in haskell
03:53:32 <halberd> you get 1,3,4,5 mod 6
03:54:20 <Cale> > let (x:xs) /\/ (y:ys) = case compare x y of { LT -> x : (xs /\/ (y:ys)); EQ -> x : y : (xs /\/ ys); GT -> y : ((x:xs) /\/ ys) }; foo = 1 : map (\n -> 2*n+1) foo /\/ map (\n -> 3*n+1) foo in map (`mod` 6) foo
03:54:21 <lambdabot>   [1,3,4,1,3,4,1,3,1,3,4,3,4,1,1,3,4,1,3,4,1,3,4,3,3,4,1,1,3,4,1,3,1,3,4,4,3,...
03:55:30 <fax> mail, you can use a list of values to represent multiple choice (nondeterminism)
03:55:50 <halberd> you could just use that fact instead of trying to translate it directly
03:56:09 <mail> talking about multiple choices at any point
03:56:17 <mail> have to follow all choices
03:56:21 <ski> ("how to replace failure with a list of successes" by Wadler ?)
03:56:30 <mail> then backtracking would be involved
03:56:49 <Cale> mail: The list monad?
03:57:58 <ski> > do z <- [1..]; y <- [1..z-1]; x <- [1..y-1]; guard (x^2 + y^2 == z^2); return (x,y,z)
03:58:02 <lambdabot>   mueval-core: Time limit exceeded
03:58:13 <ski> (bah, it worked just before ..)
03:58:25 <ski> > do z <- [1..30]; y <- [1..z-1]; x <- [1..y-1]; guard (x^2 + y^2 == z^2); return (x,y,z)
03:58:26 <lambdabot>   [(3,4,5),(6,8,10),(5,12,13),(9,12,15),(8,15,17),(12,16,20),(15,20,25),(7,24...
03:58:34 <Cale> halberd: There don't seem to be many (any?) elements which are congruent to 5 mod 6 in it, and it doesn't have all the elements of the other cosets.
03:58:45 <DigitalKiwi> hmm, why do people get so upset when people ask for help with homework as long as they are putting an honest effort into it and not be like "do my homework!?"
03:58:51 <DigitalKiwi> I mean think about it
03:59:02 <DigitalKiwi> they have to PAY to get to do those problems
03:59:08 <DigitalKiwi> we get to do them for free!
03:59:19 <halberd> 2*2+1 = 5, 2*5+1=11=5 mod 6
03:59:59 <Cale> halberd: But 2 and 5 don't occur in the sequence...
04:00:13 <Cale> (perhaps I'm not understanding the question properly)
04:00:55 <Cale> But I thought the idea was to define a sequence such that 1 was in the sequence, and 2n+1 and 3n+1 are in it whenever n is, and it's in sorted order.
04:01:04 <fax> is there any number system that -1 * -1 = -1
04:01:09 <halberd> perhaps that is what he meant
04:01:22 <halberd> I had a different interpretation I said above
04:01:25 <Cale> ah
04:01:35 <halberd> just all #'s of the form 2n+1 or 3n+1
04:01:40 <Oejet> DigitalKiwi: In some countries, yes.
04:01:42 <Cale> ah, okay
04:01:51 <mreh> can I introduce a "deriving" separately from a "data"
04:02:12 <Cale> mreh: With GHC extensions, if the data constructors are all still in scope, you can.
04:02:29 <DigitalKiwi> oh man I don't even want to know how much this fortran class cost me
04:02:36 <ski> > let (x:xs) /\/ (y:ys) = case compare x y of { LT -> x : (xs /\/ (y:ys)); EQ -> x : y : (xs /\/ ys); GT -> y : ((x:xs) /\/ ys) }; foo = 1 : map (\n -> 2*n+1) foo /\/ map (\n -> 3*n+1) foo in filter ((5 ==) . snd) . map ((`mod` 6) `graph`) $ foo
04:02:40 <lambdabot>   mueval-core: Time limit exceeded
04:02:45 <Cale> StandaloneDeriving
04:02:51 <DigitalKiwi> and I'm sure the probably half of the class that is going to fail it doesn't want to be reminded of it either >.>
04:02:55 * DigitalKiwi is not part of that half
04:03:31 <tensorpudding> fax: what do you mean by -1 there
04:03:38 <Oejet> DigitalKiwi: Hm, if you pay for the class anyway, why not pay for tutoring too?
04:03:57 <fax> anything
04:04:03 <Fredrich3> oh sorry - [23:00] <halberd> perhaps that is what he meant
04:04:04 <Cale> DigitalKiwi: I will steal the opportunity to do homework from someone if the homework looks interesting.
04:04:05 <fax> it doesn't need to be any particul one
04:04:06 <Fredrich3> that is what i meant
04:04:09 <rsaarelm> fax: That makes -1 look like an algebraic unity, since x * -1 = x for that one example at least. Can a sensible number system have more than one of those?
04:04:23 <Cale> Fredrich3: ah, that's much simpler
04:04:25 <DigitalKiwi> Oejet: if you are already spending a fortune why spend EVEN more?
04:04:30 <tensorpudding> if 1 = -1 in that system
04:04:31 <fax> rsaarelm ah
04:05:07 <Cale> Fredrich3: I sort of figured that was a much too simple interpretation, since you explicitly stated that 1 was in the list, which is unnecessary if it already contains all the numbers of the form 2n+1
04:05:13 <tensorpudding> so I guess the field Z_2
04:05:14 <Fredrich3> Cale: i meant, what you did was correct
04:05:17 <DigitalKiwi> Cale: i know right? just the other day i was trying to do someone elses homework assignment for fun
04:05:19 <Cale> oh, okay
04:05:27 <Fredrich3> sorry for the confusion :P
04:05:29 <Oejet> DigitalKiwi: Um, to get a better grade? ;)
04:05:34 <DigitalKiwi> not even to help them, since they were already done, and i was doing it in a different language >.>
04:05:45 <DigitalKiwi> Oejet: better than an A+?
04:06:08 <Cale> Fredrich3: This is one place where laziness works out very nicely
04:06:10 <Oejet> DigitalKiwi: A++ even.
04:06:56 <Fredrich3> oh yes
04:07:34 <mreh> Cale: inscope, meaning imported
04:07:48 <Cale> mreh: yeah, and exported in the first place
04:07:53 <Oejet> DigitalKiwi: I agree with you and Cale. I'd help with a homework assignment on #haskell, if the problem seems interesting.
04:08:52 <Cale> Often I'm kinder than that though, and don't just give away the answer :)
04:09:12 <Fredrich3> uh, one more thing (if my newbieness isn't apparent already :P) what is that /\/ in your definition you gave?
04:09:13 <DigitalKiwi> 0.99222222222222
04:09:18 <DigitalKiwi> that is my grade right now
04:09:22 <Oejet> DigitalKiwi: So, I guess, we only get angry, if someone comes with a hard and uninteresting problem.
04:09:22 <Cale> Fredrich3: It's a function that I defined
04:09:24 <Fredrich3> been trying to google it but it google is failing me
04:09:28 <Fredrich3> oh what
04:09:31 <Fredrich3> brainfuck
04:09:39 <Oejet> DigitalKiwi: What does that even mean?
04:10:21 <Cale> Fredrich3: You can define new infix functions with any combination of symbol characters as their name (with a few exceptions of course)
04:10:40 <Fredrich3> ohh ok
04:10:41 <DigitalKiwi> it means i have a 99% in the class ;p
04:11:06 <Cale> Fredrich3: I could also write it like this:
04:11:13 <Oejet> DigitalKiwi: So you can't do any better than 100%, right?
04:11:53 <Cale> > let merge (x:xs) (y:ys) = case compare x y of { LT -> x : merge xs (y:ys); EQ -> x : y : merge xs ys; GT -> y : merge (x:xs) ys }; foo = 1 : merge (map (\n -> 2*n+1) foo) (map (\n -> 3*n+1) foo) in foo
04:11:53 <lambdabot>   [1,3,4,7,9,10,13,15,19,21,22,27,28,31,31,39,40,43,45,46,55,57,58,63,63,64,6...
04:11:56 <DigitalKiwi> well it was possible as i did get extra credit but i lost more points on quizzes than i got extra credit for :(
04:12:00 <DigitalKiwi> there is a curve though
04:12:06 <DigitalKiwi> cause half the class is failing >.>
04:12:09 <Fredrich3> ah, righteo
04:12:14 <Cale> Same thing, but I called the function merge instead of (/\/)
04:12:29 <Fredrich3> thank you again
04:12:37 <Fredrich3> i'm going to go now - 11pm (sleeptime :D)
04:12:46 <Oejet> DigitalKiwi: I am curious, what do classes cost typically?
04:12:50 <Fredrich3> much appreciated
04:12:57 <Cale> Also note, I left the base cases off of merge because I didn't need them, but usually you'd want to handle the empty list as well ;)
04:13:23 <DigitalKiwi> this semester at uni was....over 3 thousand USD :/
04:13:45 <Cale> Man, I have way too much energy for 7:13am (not having slept)
04:13:55 <DigitalKiwi> maybe 3500 including books *shrug*
04:14:04 <Oejet> DigitalKiwi: For 4-6 classes?
04:14:47 <Cale> Maybe I should make myself a cappuccino and just go to bed early tonight.
04:14:47 <DigitalKiwi> this semester i did three
04:15:25 <DigitalKiwi> next semester i am also doing three but am going to be about twice as busy :(
04:16:07 <DigitalKiwi> calculus has a lecture and recitation, autocad has lab and lecture, and chemistry has lab, lecture, recitation....
04:18:47 <Oejet> DigitalKiwi: Have you had a course that used/teached Haskell?
04:18:56 <DigitalKiwi> no
04:19:00 <DigitalKiwi> i just started at uni
04:19:33 <DigitalKiwi> i dunno if they have any courses for haskell, but the servers have ghc =D
04:19:43 <ski> (Cale : the cappuccino won't make you unable to sleep, then ?)
04:20:59 <DigitalKiwi> omg they have ocaml too
04:24:28 <mail> mhhm finally finished my PDA simulator in C
04:25:01 <mail> ugly ugly code
04:25:15 <ivanm> it sounds like it
04:25:20 <ivanm> I mean, it's in _C_ :p
04:25:36 <DigitalKiwi> hey good C can be quite elegant!
04:25:37 <ivanm> DigitalKiwi: either they do or it's a standard install package set
04:26:20 <DigitalKiwi> suse 10 i think
04:26:54 <mail> my uni is quite good
04:27:23 <mail> they even have the google Go compiler on the remote unix machines
04:32:24 <Jafet> The harder someone needs to think to understand your program, the cooler it is
04:33:07 <mail> yep when I try to understand some haskell I see sometimes I feel like this
04:33:09 <mail> http://dl.dropbox.com/u/1828618/blontdmeisjegroot.jpeg
04:34:08 <Jafet> I wish I could park my bicycle like that
04:46:16 <SubStack> wooo refactoring to use Generics
04:54:24 <mamalujo_> hm
04:55:13 <mamalujo_> um, am I actually BANNED in #haskell-in-depth? I literally never in my life uttered a word there? or is that the reason?
04:55:40 <tensorpudding> does #haskell-in-depth still exist?
04:55:45 <Jafet> Maybe you need to utter some words to nickserv.
04:55:56 <tensorpudding> Maybe it's still +r
04:56:57 <mamalujo_> hm. but thats what I was trying to do, change my nick to remove the underscore, it complained that I cannot change the nick while banned?
04:57:31 <Jafet> Group your alt-nick (/nickserv help)
04:57:36 <mamalujo> oh, so I first needed to leave
04:58:20 <mamalujo> ok, thx
05:07:04 <paulvisschers> Can anyone tell me where exactly in the ghc code STM is implemented?
05:07:40 <portnov> @hoogle Eq a => [(a,b)] -> [(a,b)] -> [(a,b)]
05:07:40 <lambdabot> Control.Arrow (<+>) :: ArrowPlus a => a b c -> a b c -> a b c
05:07:40 <lambdabot> Data.Graph.Inductive.Query.BFS leveln :: Graph gr => [(Node, Int)] -> gr a b -> [(Node, Int)]
05:07:40 <lambdabot> Data.Graph.Inductive.Query.BFS bfen :: Graph gr => [Edge] -> gr a b -> [Edge]
05:08:20 <fax> @hoogle [a] -> [b] -> [c]
05:08:20 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
05:08:20 <lambdabot> Data.List zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
05:08:20 <lambdabot> Prelude zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
05:09:30 <chrisdone> :t Data.List.union
05:09:31 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
05:09:44 <chrisdone> hoogle is clever
05:10:12 <chrisdone> i want to see its type unifier
05:13:37 <chrisdone> guys please explicitly import your symbols so i don't have to search though modules manually
05:17:00 <dv-> Where would one go to find (-<)?
05:17:08 <portnov> @hoogle merge
05:17:09 <lambdabot> Data.Graph.Inductive.Internal.Heap merge :: Ord a => Heap a b -> Heap a b -> Heap a b
05:17:09 <lambdabot> Data.Graph.Inductive.Internal.Heap mergeAll :: Ord a => [Heap a b] -> Heap a b
05:17:09 <lambdabot> Text.Parsec.Error mergeError :: ParseError -> ParseError -> ParseError
05:17:27 <portnov> @hoogle (-<)
05:17:28 <lambdabot> No results found
05:17:37 <portnov> Control.Arrow, I think.
05:17:49 <dv-> I though so too
05:17:52 <dv-> thought*
05:17:56 <dv-> but apparently not
05:22:11 <portnov> may be it's part of syntax when -XArrows is enabled?
05:23:16 <dv-> Oh right. Thanks
05:28:36 <roconnor> chrisdone: can you write a program to rewrite my modules to import only the functions I use?
05:29:40 <StarFire> Is there any advantage to writing in the (f . g . h $ x) style instead of (f $ g $ h x), or is it just a stylistic question?
05:30:33 <fax> StarFire: yes
05:30:36 <fax> there is an advantage
05:30:56 <fax> . is associative, but $ isn't
05:31:03 <fax> so the . version is more malleable
05:31:35 <StarFire> Ahh, I see.
05:35:01 <chrisdone> roconnor: interesting problem
05:35:27 <roconnor> such a tool would make me happy
05:35:56 <chrisdone> i could probably take haddock as a guide
05:39:08 <Eelis> such a tool would be very useful
05:40:29 <ivanm> what kind of tool are people wanting now?
05:40:57 <chrisdone> scroll up five lines
05:41:42 <xezz> hello
05:42:11 <xezz> im trying to add eclipse support for haskell in linux but i fail by installing cabal
05:43:53 <xezz> it says me that i need to have parsec package installed in order to install cabal. but i already have the parsec2 package installed and when i try to get the parsec package via apt-get it says me i should use parsec2 instead and it is already the actual versdion
05:43:59 <xezz> some1 can help me xD?
05:44:55 <Cale> xezz: ghc-pkg list parsec and see what it says
05:45:48 <xezz> /usr/local/lib/ghc-6.12.1/package.conf.d
05:46:05 <Cale> xezz: No actual package listed?
05:46:11 <Cale> hmm
05:46:30 <xezz> thats what it says if i make what u said in shell
05:46:42 <xezz> hope that was intended im realy new to linux xD
05:46:53 <Cale> xezz: yeah, if that's the only line, that's just the name of the file that it checked
05:47:17 <Cale> /home/cale/.ghc/i386-linux-6.12.1/package.conf.d
05:47:17 <Cale>    parsec-2.1.0.1
05:47:29 <Cale> ^^ here's what it says on my system, for instance
05:47:48 <Cale> (actually, that's in addition to the line you gave)
05:48:11 <Cale> So whatever you were doing to install parsec didn't work
05:48:18 <xezz> sudo apt-get install libghc6-parsec-dev
05:48:29 <xezz> Paketlisten werden gelesen... Fertig
05:48:30 <xezz> Abhängigkeitsbaum wird aufgebaut
05:48:30 <xezz> Lese Status-Informationen ein... Fertig
05:48:30 <xezz> Hinweis: wähle libghc6-parsec2-dev an Stelle von libghc6-parsec-dev
05:48:30 <xezz> libghc6-parsec2-dev ist schon die neueste Version.
05:48:30 <xezz> 0 aktualisiert, 0 neu installiert, 0 zu entfernen und 0 nicht aktualisiert
05:48:38 <Cale> ah, hmm
05:48:50 <xezz> oh its german xD
05:48:59 <Cale> That's fine
05:49:26 <Cale> http://hackage.haskell.org/packages/archive/cabal-install/0.8.2/cabal-install-0.8.2.tar.gz
05:50:00 <Cale> Download that, unpack it, and then run the bootstrap.sh script from a terminal, and hopefully it'll succeed...
05:50:19 <xezz> what was the unpacking command xD?
05:50:26 <xezz> tar -xvvz ?
05:50:31 <Cale> tar -zxvf
05:51:12 <Cale> Though I like the 'unp' command, which you can probably install using apt-get
05:51:23 <Cale> (It knows how to unpack various types of packages)
05:52:28 <mpiechotka> Hello. Is there any nice command for rebuilding all 'user' packages after ghc upgrade? Something like haskell-updater is for portage?
05:52:30 <Cale> This is assuming that you don't have cabal-install already, as that was I think your original goal
05:53:45 <Cale> mpiechotka: I don't know of one, anyway. You might be able to whip something up using the directory listing of ~/.cabal/packages/hackage.haskell.org
05:54:02 <xezz> ok it succeeded
05:54:03 <xezz> nice
05:54:09 <xezz> thx
05:54:16 <Cale> No problem
05:54:25 <ivanm> mpiechotka: nope
05:54:26 <xezz> now i can delete install folder?
05:54:33 <Cale> xezz: yeah
05:55:52 <mpiechotka> Cale: I know. I meant something ready...
05:57:11 <ivanm> it probably wouldn't be too difficult to get a list of old packages, and then pipe them to cabal install
05:57:55 <tibbe> dcoutts: you there?
05:59:17 <xezz> ok
05:59:25 <xezz> next problem :P
05:59:31 <xezz> im using this tutorial..
05:59:31 <xezz> http://eclipsefp.sourceforge.net/build.html
05:59:33 <chrisdone> tibbe: ! what was that guy's name at zurihac who works on youtube with a python templating system, he came in to talk about it and blazehtml
05:59:59 <xezz> im at step 3 now
06:00:11 <xezz> cd scion
06:00:15 <tibbe> chrisdone: Fredrik Lundh
06:00:16 <xezz> i come to the folder
06:00:21 <tibbe> chrisdone: effbot.net
06:00:23 <xezz> but cabal install
06:00:39 <xezz> says me command not found xD
06:00:42 <chrisdone> tibbe: thanks!
06:00:50 <tibbe> chrisdone: sorry, effbot.org
06:01:19 <Cale> xezz: hmm, that was just supposed to have been installed when you ran bootstrap.sh
06:01:36 <Cale> xezz: Perhaps it's in ~/.cabal/bin ?
06:02:26 <xezz> it is there yes
06:03:27 <chrisdone> tibbe: in case you haven't seen, hamlet is pretty cool <http://docs.yesodweb.com/hamlet/syntax.html> it provides compile time checking for html and javsacript with its haml-like templating engine
06:03:28 <xezz> so i have to run the cabal command as  ~/.cabal/bin install?
06:04:17 <Cale> xezz: You could add that directory to your $PATH environment variable
06:04:20 <tibbe> chrisdone: I've seen it. I've come to the belief that templating languages are a bad idea
06:04:59 <Cale> xezz: You can open up your .profile file and add something like this to the end of it:
06:05:04 <chrisdone> tibbe: because they evolve into mini languages when you could just use haskell and an edsl?
06:05:05 <Cale> if [ -d ~/.cabal ]
06:05:05 <Cale>   then export PATH=~/.cabal/bin:"${PATH}"
06:05:05 <Cale>   fi
06:05:13 <xezz> well the command is unknown cause it is nor registered?
06:05:25 <tibbe> chrisdone: yes, they evolve into poor programming languages
06:05:34 <Cale> xezz: It's just not in a directory that your shell is set to looking for programs in.
06:06:10 <tibbe> chrisdone: and I think the main argument for them:,that designers can read them, is bogus. They can't once you have a real site because there's too much dynamic behavior and very little raw HTML
06:06:18 <Cale> xezz: You can add that directory to the set of paths that your shell looks for programs, and it'll save you the trouble of moving the programs around when you install things using cabal
06:06:28 <tibbe> chrisdone: You can get an edsl with pretty good syntax in haskell
06:07:21 <chrisdone> tibbe: true. it puts me off too. compile-time checking of html-validity is really attractive to me though
06:07:46 <tibbe> chrisdone: to what extent does haml check it?
06:07:49 <chrisdone> tibbe: yeah, do notation a la blazehtml is impressively easy to read and edit (compared to what else i've seen anyway)
06:07:50 <xezz> k i added that to my .profile (and saved it ;))
06:07:58 <xezz> same error
06:08:11 <tibbe> chrisdone: does it make sure that the generated html follow the html content model?
06:08:15 <Cale> Try closing your terminal and opening a new one
06:08:54 <Cale> (If all else fails, log out and log back in again)
06:08:58 <chrisdone> tibbe: that's what i'm lead to believe but i haven't read the source. regardless, that is what i meant by something attractive to me
06:09:05 <Cale> (I forget when .profile gets run)
06:10:10 <tibbe> chrisdone: I'm not sure it's worth it (to me). With the type system I can check some lightweight properties which is a good trade-off I think; Compared to having a whole new language with it's own preprocessor/compiler
06:11:49 <XeZZ> well that worked :)
06:12:47 <XeZZ> very complicated^
06:13:12 <chrisdone> tibbe: sure. i suppose you can always build a well typed layer on the top of a text.xhtml/blaze-like library
06:13:42 <tibbe> chrisdone: sure, the properties that seem reasonably easy to encode in the types is the proper nesting of tags
06:14:21 <Cale> XeZZ: Well, another option would have been to move everything from ~/.cabal/bin to ~/bin (assuming that's also in your $PATH already), and then replacing the ~/.cabal/bin directory with a symlink to ~/bin
06:14:29 <tibbe> chrisdone: but ensuring that the generated html corresponds to the given doc tag requires a full-blown HTML validator
06:14:34 <chrisdone> tibbe: for some limited sub-set that you care about?
06:14:40 <tibbe> chrisdone: I kinda doubt hamlet does that
06:14:44 <Cale> (that way when cabal puts stuff there it just gets put in your user bin directory)
06:14:53 <chrisdone> tibbe: me too.
06:15:20 <tibbe> chrisdone: the nesting model (e.g. inline elements inside block elements, etc) seems feasible to encode fully. I think there's a library on Hackage that does that.
06:18:15 <XeZZ> mh ok ill have to read some about linux system things later :P
06:18:23 <tibbe> chrisdone: I think something like BlazeHtml, if done right, solves the majority of problems that actually crop up in web development: Proper escaping and support for abstraction. Next steps is formlets to make forms nicer to create (and compose!) and to automaticlly inject anti-XSS tokens into forms
06:19:07 <XeZZ> ...
06:19:10 <chrisdone> tibbe: yeah, I've been playing with blazehtml. don't you think Formlets are a good way to make forms?
06:19:11 <XeZZ> next step xD
06:20:07 <tibbe> chrisdone: I think the idea is great. I haven't had much time to look at the actual implementation
06:21:01 <chrisdone> tibbe: ah. i liked it so much i implemented it in javascript. i suspect one could spit out javascript on the side too to unify client-side and server-side validation, although i'm not sure how much i like the idea
06:22:46 <tibbe> chrisdone: To generate javascript on the server side? I'm not sure what I'd prefer. Perhaps a javascript library that implements the actual validation and a server side that generates minimal javascript in the form that actually calls that library.
06:23:25 <Athas> @hoogle [a] -> [a] -> Bool
06:23:25 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
06:23:25 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
06:23:25 <lambdabot> Data.List isSuffixOf :: Eq a => [a] -> [a] -> Bool
06:23:33 <XeZZ> mh probably im missunderstanding something
06:23:34 <XeZZ> but
06:23:49 <chrisdone> tibbe: perhaps... you could assign an attribute set to a tag according to a class such as Attributable. e.g. if I have a div, i could assign attributes with data GenericAttributes = GenericAttributes { gen_class :: String, gen_id :: String }, or I could use TableAttributes { table_class :: String, table_summary :: String }, etc. that way, you make sure you don't assign an attribute twice, and you only use the right type of
06:23:49 <chrisdone> attributes. questions are (1) are attributes a massive problem? (2) is writing tag_class instead of just class really annoying? (I don't think i've be too bothered by it if I could make use of record syntax)
06:23:53 <XeZZ> for what do i need this many projekts imported?
06:24:29 <XeZZ> i cant even use my own haskell projekts with eclipse right now
06:24:40 <XeZZ> (imported form windows...)
06:24:40 <tibbe> chrisdone: I haven't thought it over enough I'm afraid.
06:25:07 <chrisdone> tibbe: yeah, to generate javascript code on the server side to be included with the form. true, you could also use the javascript to kind of submit the form remotely, or parts of it, but you'd have latency issues i suppose. have you done anything like this before? at the moment i manually write my validation with a jquery library..
06:27:04 <tibbe> chrisdone: so RoR does both async posts using JS and normal posts using HTTP
06:27:18 <chrisdone> ok
06:27:20 <Schalken> I have a function "g :: a -> Either String a" and function "f :: b -> ErrorT String Writer b", which calls g. How can I get an error in g to translate into an error in f?
06:27:25 <tibbe> chrisdone: they have a JS library that does most of these things by finding elements with certain classes
06:27:36 <tibbe> chrisdone: you might want to look at that
06:27:40 <chrisdone> tibbe: right. 'validate_email validate_required', etc.?
06:27:55 <tibbe> chrisdone: something like that
06:28:47 <chrisdone> right, i have one like that (probably less sophisticated). question is how to handle "this input is required if this one is" and "these two must be equal" etc. in a nice way... i'll look at tit
06:28:57 <tibbe> chrisdone: the client side validation will often be a subset of the server side one as the client side doesn't always have access to all the data needed to validate (unless it does async requests to the server for that data).
06:29:21 <tibbe> chrisdone: in javascript
06:29:22 <tibbe> ?
06:29:22 <chrisdone> sure
06:29:54 <chrisdone> tibbe: yeah, how to handle those things in a nice way, in javascript
06:30:01 <tibbe> chrisdone: you could view the validation as a function Form -> Bool
06:30:15 <tibbe> chrisdone: is no real difference between haskell and javascript in this manner
06:30:23 <tibbe> chrisdone: you can't just do per field validation
06:30:35 <tibbe> chrisdone: validation is :: form -> bool, not field -> bool
06:31:21 <tibbe> chrisdone: you might get away with "foldr (&&) fields" style validation in many cases but not always
06:31:40 <chrisdone> tibbe: sure that doesn't work for password1==password2
06:31:46 <tibbe> sure it does
06:32:01 <chrisdone> tibbe: foldr (&&) fields?
06:32:05 <tibbe> form {passwd1, passwd2 } -> passwd1 == passwd2
06:32:20 <chrisdone> yeah i meant folding, i agree form -> bool works
06:32:22 <tibbe> chrisdone: I was trying to say that often you can validate fields separately and then and the result
06:32:33 <tibbe> chrisdone: yes so folding doesn't work in general
06:32:37 <chrisdone> oh right
06:33:01 <tibbe> chrisdone: since validation is not really "linear"
06:33:14 <tibbe> (I should figure out what the real properties of validation are)
06:33:25 <tibbe> lineraly seperable?
06:34:43 <chrisdone> ah, dinner's up. sorry. i was about to say formlets in javascript would solve the problem because every "input" is really a formlet and you just plug them all together and call it a form. whether you really need such composability is up for question but i think so
06:34:43 <chrisdone> bbl
06:34:52 <portnov> >> Over 1800 Haskell packages have now been released on Hackage.
06:34:52 <portnov> Seems we all are waiting when there will be over 9000 packages! :)
06:36:52 <tibbe> kolmodin: there?
06:41:11 <laynor> hi, I'm trying to compile and install yi on cabal under windows. I'm having some problems, now my installation stops with errors when compiling dyre. any help?
06:45:45 <orlandu63> last time i tried to compile yi, it failed as well
06:45:51 <orlandu63> i think this is a common problem
06:46:40 <XeZZ> mh anothe rproblem occurded now... I imported all the files from eclipseFP to my workspace now.
06:47:29 <XeZZ> the tutorial says now: "Hit Run, Run Configurations. Add a new launch Eclipse Application launch configuration. The default settings for this launch configuration should work, so just click Run."
06:47:50 <XeZZ> but when i get there i cant add a new because its all grayed
06:59:01 <jinjing> @bot
06:59:01 <lambdabot> :)
07:08:14 <tibbe> what's the corresponding function to inlinePerformIO for ST?
07:10:25 <sioraiocht> AFAIK there isn't one
07:10:37 <sioraiocht> as you can "runST" to get out of the state monad properly
07:11:01 <tibbe> @tell dcoutts I'm implementing a builder monoid for Text using ST instead of IO since I think you suggested Tom should use that. I'm kinda stuck at the part where the Binary builder monoid uses unsafeInterleaveIO. How did you envision ST design?
07:11:01 <lambdabot> Consider it noted.
07:11:08 <tibbe> sioraiocht: hi :)
07:11:22 <tibbe> sioraiocht: perhaps you know what dcoutts had in mind?
07:11:23 <sioraiocht> tibbe: you can use unsafeInterleaveST
07:11:35 <tibbe> sioraiocht: it's ST s a -> ST s a right?
07:11:46 <tibbe> sioraiocht: I don't see how.
07:11:46 <sioraiocht> which allows you to introduce lazy computation into the strict ST monad
07:12:12 <tibbe> sioraiocht: with lazy computations, would the Builder still have the same type?
07:12:28 <sioraiocht> tibbe, the idea was that you don't leave the ST monad as you break off chunks but can still delay building them until demand
07:12:45 <tibbe> sioraiocht: I see
07:12:51 <tibbe> sioraiocht: let me post some code
07:13:50 <tibbe> sioraiocht: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25039#a25039
07:13:57 <tibbe> sioraiocht: it's in an intermediate state
07:14:09 <tibbe> sioraiocht: where exactly should we introduce the laziness?
07:14:35 <sioraiocht> GOOD question.  I *think* at flush, as this is were things are actually "broken off"
07:14:49 <sioraiocht> before then you are sort of building up a continuation
07:15:32 <sioraiocht> - TODO: What on earth do we do here?!?
07:15:32 <sioraiocht>     else Text (unsafeInterleaveST (A.unsafeFreeze p)) o u : k (Buffer p (o+u) 0 l)
07:15:40 <sioraiocht> But to be honest, that's as far as I am sure
07:15:56 <sioraiocht> I'm not sure that call is correclty placed, but I think it's in the general vicinity
07:16:01 <sioraiocht> (I know, that's incredibly helpful)
07:16:11 <tibbe> :)
07:18:19 <sioraiocht> tibbe: I guess the point is that we don't want that chunk created immediately, right? We only want it written out if we try to read it
07:18:53 <sioraiocht> or is it more we want to make sure that if we demand that first chunk, it doens't write out the rest of the list as well?
07:19:07 * sioraiocht scratches chin thoughtfully.
07:20:13 <tibbe> sioraiocht: the second I think
07:20:20 <sioraiocht> yes, me too
07:20:56 <sioraiocht> so the unsafeInterleaveIO needs to be place probably around the tail portion of the list
07:21:27 <tibbe> sioraiocht: the laziness in the Binary builder is after flushing in ensureFree and after ensureFree in writeN
07:22:00 <tibbe> sioraiocht: but the Binary builder doesn't need to freeze in flush so we probably need some more unsafe interleaving than done in the binary builder
07:22:15 <sioraiocht> agreed
07:22:36 <tibbe> sioraiocht: so as you said, we probably need to make the call to the continuation lazy
07:22:45 <sioraiocht> yes
07:23:57 <tibbe> sioraiocht: buf' <- unsafeInterleaveST (k (Buffer p (o+u) 0 l))
07:24:07 <tibbe> sioraiocht: that should make the rest of the computation lazy right?
07:25:30 <sioraiocht> tibbe: I *believe* so, yes
07:26:12 <tibbe> sioraiocht: at least it compiles ;)
07:26:32 <sioraiocht> tibbe: In Haskell that's an awfully good sign!
07:26:43 <tibbe> sioraiocht: I guess I'll go back to my second problem, for some reason the text version gets different inlining even when I changed the code to be almost exactly like the binary version
07:26:47 <tibbe> sioraiocht: :)
07:26:52 <tibbe> sioraiocht: gotta run now though, ttyl!
07:28:19 <pao> does any one know if it is possible to add haskell-platforma in Build-depends cabal stanza?
07:29:01 <pao> I were hoping that that would have allowed leaving out all more specific dependencies
07:29:12 <tibbe> sioraiocht: Here's something that compiles: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25042#a25042
07:29:19 <tibbe> sioraiocht: ttyl!
07:29:53 <pao> hi tibbe, any news on the epoll runtime?
08:01:35 <fax> append : list list -> list      odd
08:02:11 <Twey> I think that append = Haskell concat?
08:02:30 <EvanR> :t concat
08:02:31 <lambdabot> forall a. [[a]] -> [a]
08:02:35 <EvanR> :t append
08:02:36 <lambdabot> Not in scope: `append'
08:02:48 <EvanR> :t (++)
08:02:49 <lambdabot> forall m. (Monoid m) => m -> m -> m
08:06:58 <EvanR> > pi2
08:06:59 <lambdabot>   Not in scope: `pi2'
08:10:31 <EvanR> question about lazy evaluation. i have an infinite list of numbers each of which take some computation to produce, but they are independent from each other. each one does not depend on the previous one. when traversing the list can i skip some to avoid computing them if i dont need them?
08:10:51 <EvanR> drop 5
08:11:12 <danderson> should work, yes
08:11:14 <sioraiocht> EvanR: yes
08:11:22 <EvanR> sweet
08:11:27 <sioraiocht> EvanR: It will create thunks for those numbers, but they will never be evaluated
08:12:01 <EvanR> the thunks will be created when i drop them?
08:12:12 <EvanR> and hopefully be collected shortly after?
08:13:28 <EvanR> @src drop
08:13:28 <lambdabot> drop n xs     | n <= 0 =  xs
08:13:28 <lambdabot> drop _ []              =  []
08:13:28 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
08:16:42 <Botje> EvanR: if there is nothing that references them, yes.
08:17:28 <Botje> but since you probably have a reference to the start of your list, that'll be a problem
08:19:25 <EvanR> i do not
08:19:59 <EvanR> xs is passed to the next iteration of the loop
08:20:07 <fax> I wish I could program in haskell and prolog at the same time
08:20:16 <fax> I mean one algorithm partly in both
08:20:32 <byorgey> sounds like you want Curry.
08:20:33 <Twey> fax: See Curry, LogicT
08:20:59 <Twey> Or the list monad for simple cases
08:21:07 <Twey> fax: http://hackage.haskell.org/packages/archive/logict/0.2.3/doc/html/Control-Monad-Logic.html
08:21:19 <fax> prolog can solve linear algebra problems
08:30:04 <fax> how do you do  Sum[i<j<k<...<n] f(i,j,k,...,n)
08:30:17 <fax> it can't be a list comprehension I think it will have to use recursion
08:30:54 <EvanR> forM_ [1..n] $ writeIORef ;)
08:31:46 <EvanR> nesteed
08:32:08 <fax> f .. = undefined -- Sum[i<j<k<...<n] f(i,j,k,...,n)
08:32:11 <fax> that will do for now
08:32:29 <fax> I hope
08:39:58 <fax> I can't really get any of these algorithms I want done it is immensely frustrating
08:52:41 <CalJohn> it's a bit disappointing that the reduceron didn't pan out as well as hoped
08:52:50 <CalJohn> it looks like the research has now stopped
08:53:11 <k23z__> DOES HASKELL HAVE a symbolic computation package like SymPy
08:53:22 <k23z__> this is the 2353246 time I am asking this on this channel in the past 10 days
08:53:30 <k23z__> does anyone here know the answer to my question
08:53:42 <k23z__> has anyone here played with Symbolic computation packages like SymPy ?
08:53:45 <IceDane> k23z__: Were you as polite about it the last times as well?
08:53:48 <k23z__> is there something like this on Hackage ?
08:53:58 <EvanR> @hoogle symbolic
08:53:58 <lambdabot> No results found
08:54:07 <EvanR> @google haskell symbolic
08:54:08 <lambdabot> http://www.haskell.org/pipermail/haskell/2004-November/014939.html
08:54:08 <lambdabot> Title: [Haskell] Typeful symbolic differentiation of compiled functions
08:54:23 <Adamant> CalJohn: in particular, what was disappointing about it
09:06:16 <bremner> k23z__: google for "haskell computer algebra" turns up some hits.
09:06:49 <eldragon> why does the binary uncompressed GHC waste the 900MB of diskspace?
09:07:37 <eldragon> it's 8 times higher than old Java2.
09:08:17 <k23z__> bremner, I am in particular interested in a polynomial computation package that allows for multivariate polynomials
09:09:20 <bremner> this is the point where you say "I checked out X, Y, and Z and they don't do it"
09:09:22 <eldragon> GHC seems too impractical and a waste of resources for me.
09:09:53 <Axman6> your loss
09:10:01 <serhalp> Hello, #haskell.  Bit of a challenge for you: can you write a non-hideous sort function without pattern matching or anything from Prelude, other than !!, ++ and length?
09:10:26 <Axman6> serhalp: they're all hideous functions, so no
09:11:02 <kosmikus> and it's unlikely that we could write a sorting function without being allowed to use comparison
09:11:13 <bigorilla> serhalp: you really don't want to use "!!" !! it's linear time to access a list
09:11:17 <Twey> Of course not.  All functions without pattern matching are intrinsically hideous.
09:11:44 <serhalp> kosmikus: add (<) to the list of allowed functions
09:11:55 <kosmikus> Twey: so what about one-liners, such as invocations of higher-order functions or compositions?
09:12:07 <Axman6> they all use pattern matching
09:12:08 <serhalp> bigorilla: In this case, we do not care about efficiency whatsoever.
09:12:21 <Twey> serhalp: Homework exercise?
09:12:42 <serhalp> Twey: I thought it might sound that way.  It isn't.
09:12:53 <aavogt> eldragon: there are other haskell implementations... and ghc doesn't have to include profiling libraries, documentation etc.
09:13:09 <Axman6> serhalp: are the requirements that you write a function that takes any list, and returns a sorted list?
09:13:12 <EvanR> non hideous non pattern match list processing?
09:13:21 <Twey> It doesn't seem like a challenge so much as a choreâ¦
09:13:33 <EvanR> i dont think the non hideous is do able
09:13:37 <Twey> (apart from the ânon-hideousâ bit, perhaps)
09:14:03 <serhalp> Axman6: You can assume [Int] -> [Int] if that simplifies anything.
09:14:09 <Axman6> good
09:14:16 <bremner> serhalp: write your favourite sort function in C, translate it into haskell
09:14:21 <Twey> Haha
09:14:25 <Axman6> let f xs = [] in f [18,4,2,4,5,35,5]
09:14:31 * Twey laughs.
09:14:32 <Axman6> > let f xs = [] in f [18,4,2,4,5,35,5]
09:14:33 <lambdabot>   []
09:14:36 <serhalp> And we can drop the non-hideous requirement, if we have to.
09:15:11 <Axman6> serhalp: anyway, the answer is yes. if you ask if any of us will do it, then answer is no
09:15:42 <aavogt> axman speaks for all!
09:15:55 <EvanR> forall a
09:16:24 <Axman6> forall a. Hask
09:16:34 <Axman6> forall a. HashHaskell a
09:16:52 <Axman6> forall a. HashHaskell a => a
09:16:55 <Axman6> better
09:17:08 <CalJohn> lastlog Adamant
09:17:18 <serhalp> Axman6: I'm not asking for anyone to do it for me.  I've been attempting to do it and I'm having trouble with it.  Asking for help is frowned upon now?
09:17:34 <Axman6> you weren't asking for help
09:17:36 <aavogt> serhalp: an insertion sort shouldn't be too bad if you're allowed pattern guards (without pattern matching)
09:17:50 <CalJohn> Adamant: sorry about that highlight.  what seems to have happened with the reduceron is that they decided the final performances was not good enough to warrant continuing
09:18:46 <aavogt> so     sort acc xss | null xss = acc | let x = xss !! 0 ...
09:18:55 <serhalp> Axman6: By "can you write," I meant "can you write," not "may you write."  I'm sorry I used proper English?
09:18:56 <aavogt> oh, no tail allowed...
09:19:39 <EvanR> no prelude allowed but <. how about rewriting necessary parts of it
09:19:41 <Axman6> serhalp: well, you've already been given the answer to that question
09:19:48 <serhalp> aavogt: I've written a hideous tail that uses !!, ++ and length, so I can use that (and head, which is just xs !! 0).
09:20:03 <aavogt> then you are using some kind of range
09:20:49 <serhalp> Heh, although no guards... or cases.
09:21:31 * hackagebot yaml-rpc 0.1 - Simple library for network (TCP/IP) YAML RPC  http://hackage.haskell.org/package/yaml-rpc-0.1 (IlyaPortnov)
09:21:55 <I_LIVE> how to read numbers from a string, if quantity is unknown before reading
09:22:09 <EvanR> > read "1234567" :: Int
09:22:10 <lambdabot>   1234567
09:22:15 <Axman6> > read "123.456"
09:22:15 <lambdabot>   *Exception: Prelude.read: no parse
09:22:20 <Axman6> > read "123.456" :: Double
09:22:21 <lambdabot>   123.456
09:22:56 <EvanR> > map read (words "123 123 123") :: [Int]
09:22:57 <lambdabot>   [123,123,123]
09:24:15 <I_LIVE> what does 'read' mean there?
09:24:31 <EvanR> :t read
09:24:32 <lambdabot> forall a. (Read a) => String -> a
09:24:38 <Twey> serhalp: It was more the âI've got a challenge for youâ comment that lead me to believe you expected us to do it for you.
09:25:02 <Twey> serhalp: Well, in the spirit of that question, you've got your answer: yes, we can.  âº
09:25:04 <EvanR> I_LIVE: convert a string into any type that is in class Read
09:25:09 <I_LIVE> sum( map read(words "a b c") :: [Int] )
09:25:50 <Axman6> > read "a" :: Int
09:25:51 <lambdabot>   *Exception: Prelude.read: no parse
09:25:51 <serhalp> Twey: Sorry, that's not how I meant it.  It seemed tricky to me to write it with such limited resources, so I posed it as a challenge.
09:25:53 <bigorilla> serhalp: the real question is, why?
09:26:01 <Maxdamantus> Uhh.. Quickly, before I sleep (so I can test this thing) ... How do I sleep in ghc? Not in scope: `Control.Concurrent.threadDelay'
09:26:02 <I_LIVE> how to use lambdabot?
09:26:15 <Axman6> > 1+1
09:26:16 <lambdabot>   2
09:26:17 <Twey> Maxdamantus: You have to import itâ¦
09:26:19 <I_LIVE> 4+4
09:26:32 <I_LIVE> > 4+4
09:26:33 <lambdabot>   8
09:26:35 <Axman6> I_LIVE: > expr
09:26:36 <EvanR> I_LIVE: your example wont work, you cant convert "a" into a number
09:26:39 <Axman6> there you go
09:26:44 <serhalp> bigorilla: I've written a fairly... minimal Haskell compiler, and I was wondering if I could write a sort with what I have.
09:26:46 <I_LIVE> thanks
09:26:46 <Maxdamantus> Ahah. It compiled.. import Control.Concurrent
09:26:48 <Maxdamantus> Thanks.
09:27:06 <marcelo> is there any symbol to represent epsilon (empty string) of a pushdown automaton in haskell?
09:27:16 <Maxdamantus> woot, my one-liner Game of Life works.
09:27:20 <bigorilla> serhalp: cool :)
09:27:25 <EvanR> marcelo: you can use epsilon
09:27:28 <IceDane> Maxdamantus: code? :P
09:27:45 <Maxdamantus> When you see it you'll regret asking.. sec
09:28:01 <EvanR> > let Îµ = 3 in Îµ
09:28:02 <lambdabot>   3
09:28:11 <IceDane> heh.
09:28:16 <Axman6> marcelo: sure, just define your own type: data PDA = Zero | One | Epsilon
09:28:18 <EvanR> > data S = Î
09:28:19 <lambdabot>   <no location info>: parse error on input `data'
09:28:43 <marcelo> EvanR, is that type predefined?
09:28:49 <EvanR> what type
09:28:56 <marcelo> EvanR, epsilon
09:29:20 <Maxdamantus> http://codepad.org/oqgG6rHN
09:29:21 <EvanR> i used it as a variable and as a data constructor (capital epsilon)
09:29:23 <EvanR> not a type
09:29:28 <Maxdamantus> Damn it.. Too slow for codepad. :(
09:29:56 <Maxdamantus> It is very slow.. Takes maybe 1/15 of a sec to generate the next generation and text for it here.
09:30:18 <marcelo> Axman6, that makes sense.. but what would zero or one stands for there?
09:30:38 <Axman6> i was thinking of a turing machine, sorry
09:30:43 <IceDane> wow, I'm not going to even try to grok that
09:30:55 <Maxdamantus> grok?
09:31:03 <EvanR> i grok spock
09:32:14 <I_LIVE> what lambdabot does is essentially same as possible with ghci?
09:32:30 <EvanR> lambdabot has more stuff imported
09:32:39 <EvanR> and changes to the prelude
09:33:16 <Axman6> evil, vile changes
09:33:35 <Botje> Maxdamantus: you compiled with -O2, right?
09:33:39 <Axman6> Maxdamantus: nice work
09:34:37 <Maxdamantus> Botje, no.
09:34:40 * Maxdamantus tries
09:35:45 <Maxdamantus> Mmm.. A bit quicker now.
09:36:56 <I_LIVE> are unboxed arrays feature of ghc, or haskell standard
09:37:07 <XeZZ> anyone knows if there is a good emulator for motorola 68k so i can test my homeworks?^^
09:37:09 <Axman6> ghc
09:37:39 <Axman6> XeZZ: try Qemu, it might have a 68k emulator. though i don't know why you're asking in here
09:38:48 <XeZZ> know thats not the right channel but thought maybe someone knows here about things like that :P thx
09:39:42 <Axman6> you could always just google it too...
09:40:48 <XeZZ> mh yeha  but that does not realy tell me what im looking for...
09:41:15 <Axman6> http://www.thefreecountry.com/emulators/macintosh.shtml
09:41:24 <I_LIVE> what would be data structure to use for 2d array of integers?
09:41:38 <EvanR> an array
09:41:47 <Axman6> Array (Int,Int) Integer
09:42:06 <Axman6> XeZZ: http://www.ticalc.org/archives/news/articles/12/128/128547.html
09:42:30 <I_LIVE> oh. 'Int' and 'Integer' is like 'int','Integer' in Java?
09:42:31 <Axman6> depending on whether you want to emulate a Mac or a TI calculator
09:42:41 <Axman6> I_LIVE: sort of
09:42:56 <Axman6> althought they're both primitive in haskell
09:43:07 <I_LIVE> what's primitive for int
09:43:21 <StarFire> I_LIVE: Integer is more like BigInteger.
09:43:24 <bigorilla> serhalp: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25043#a25043
09:43:41 <Axman6> > 2^272374 :: Int
09:43:42 <lambdabot>   0
09:43:46 <Axman6> > 2^272374 :: Integer
09:43:47 <lambdabot>   554675497044173237242123103464939405278529091646566117101847514070729499557...
09:44:12 <I_LIVE> > 2^40 :: int
09:44:13 <lambdabot>   Could not deduce (GHC.Num.Num int) from the context ()
09:44:13 <lambdabot>    arising from the ...
09:44:13 <Axman6> bigorilla: you're a monster
09:44:35 <bigorilla> sry
09:44:39 <Axman6> (not because you're a bi gorilla though)
09:44:49 <bigorilla> actually I'm a big orilla
09:45:03 <bigorilla> :)
09:45:07 <Axman6> pfft
09:45:17 <Axman6> keep wishing honey :P
09:45:41 <Axman6> hmm, i have a feeling that's the most efeminate thing i've ever said on IRC
09:45:57 <Raevel> tadaa
09:47:29 <I_LIVE> > 2^31 :: Int
09:47:30 <lambdabot>   2147483648
09:47:34 <I_LIVE> > 2^32 :: Int
09:47:35 <lambdabot>   4294967296
09:47:41 <I_LIVE> > 2^64 :: Int
09:47:42 <lambdabot>   0
09:47:45 <I_LIVE> > 2^63 :: Int
09:47:46 <lambdabot>   -9223372036854775808
09:48:00 <I_LIVE> compiled as 64-bit?
09:48:03 <EvanR> > 2^63-1 :: Int
09:48:04 <lambdabot>   9223372036854775807
09:48:04 <Axman6> yes
09:48:11 <Axman6> > maxBound :: Int
09:48:12 <lambdabot>   9223372036854775807
09:48:25 <Axman6> > maxBound :: Word
09:48:26 <lambdabot>   18446744073709551615
09:49:28 <EvanR> > maxBound :: Word128
09:49:28 <lambdabot>   Not in scope: type constructor or class `Word128'
09:50:29 <I_LIVE> which is space efficiency for Array(Int,Int)
09:50:36 <I_LIVE> is it jagged array or 2d?
09:52:08 * chrisdone puts on lipstick and kisses Axman6
09:52:26 <Axman6> o.O
09:52:36 <Axman6> you're not coming to AusHac are you?
09:52:45 <chrisdone> not this time
09:52:54 <chrisdone> :-{}
09:53:04 <Axman6> oh good, my girlfriend would be jealous :)
09:53:41 <chrisdone> i don't think you have a girlfriend, enjoy your jealousy :p
09:54:24 <Axman6> i sure do have a girlfriend
09:55:25 <chrisdone> alright, don't go on about it :p
09:55:45 <Null-A> I don't think he was lol
10:03:51 <EvanR> I_LIVE: arrays are implemented with arrays
10:11:35 <aavogt> @src Ix
10:11:35 <lambdabot> class (Ord a) => Ix a where
10:11:35 <lambdabot>     range           :: (a,a) -> [a]
10:11:35 <lambdabot>     index           :: (a,a) -> a -> Int
10:11:35 <lambdabot>     inRange         :: (a,a) -> a -> Bool
10:11:35 <lambdabot>     rangeSize       :: (a,a) -> Int
10:12:08 <aavogt> > index ((0,0),(5,5)) (2,2)
10:12:09 <lambdabot>   14
10:13:01 <EvanR> too bad I_LIVE left ;)
10:14:00 <aavogt> well I still don't understand what I_LIVE meant for the options
10:14:42 <EvanR> he probably wanted to know if a 2d array was a 1d array of 1d arrays
10:15:39 <aavogt> but what does that have much effect on the space usage?
10:16:07 <EvanR> if the secondary arrays can could have different lengths, then it could possible take up less room
10:17:09 <Zao> A "jagged" array.
10:18:36 <EvanR> sounded like he wanteded a 1d array of lists
10:30:07 <malosh> Hi. Is there something in ghc to handle IEEE-754 hardware rounding modes ?
10:30:21 <fax> > let o = e^(2*sqrt(-1)*pi/3) in (2+o*3+o^2*7)^3 + (2+o^2*3+o*7)^3
10:30:22 <lambdabot>   Ambiguous type variable `a' in the constraints:
10:30:22 <lambdabot>    `GHC.Real.Integral a'
10:30:22 <lambdabot>   ...
10:30:26 <fax> > let o = e^(2*sqrt(-1)*pi/3) in (2+o*3+o^2*7)^3 + (2+o^2*3+o*7)^3 :: Complex Double
10:30:27 <lambdabot>   Couldn't match expected type `Data.Complex.Complex
10:30:27 <lambdabot>                         ...
10:30:33 <fax> > let o = eexp(2*sqrt(-1)*pi/3) in (2+o*3+o^2*7)^3 + (2+o^2*3+o*7)^3 :: Complex Double
10:30:34 <lambdabot>   Not in scope: `eexp'
10:30:36 <fax> > let o = exp(2*sqrt(-1)*pi/3) in (2+o*3+o^2*7)^3 + (2+o^2*3+o*7)^3 :: Complex Double
10:30:37 <lambdabot>   161.99999999999997 :+ (-1.9895196601282805e-13)
10:30:42 <fax> > let o = exp(2*sqrt(-1)*pi/3) in (2+o*3+o^2*7)^3 * (2+o^2*3+o*7)^3 :: Complex Double
10:30:43 <lambdabot>   9261.0 :+ (-2.637534635141492e-11)
10:30:59 <EvanR> malosh:'s question gets swept away ;)
10:31:20 <Twey> Iâ¦ think that might have been an answer to it
10:31:27 <Twey> But I have no idea really :Ã¾
10:32:28 <malosh> I do not believe the categorists care a lot about numerical analysis ;-) Well, in fact, neither do I, but sometimes you have to
10:33:50 <jacobian> I have an automorphism f : a -> a, which takes leaves of a polymorphic tree type, to leaves of a polymorphic tree type.  Whats a clean way of extending it to an automorphism of the tree type>
10:34:12 <mercury^> :t fmap
10:34:13 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:37:26 <jacobian> thanks
10:41:59 <EvanR> what does O(min(n,W)) mean, (from IntMap documentation)
10:42:16 <Philippa> do you understand O() notation in general?
10:42:38 <Philippa> it's just saying that the bound is the minimum of n and W
10:43:00 <EvanR> so its either O(n) or O(1)
10:43:36 <EvanR> and if W is 32, does the n matter?
10:44:57 <Philippa> depends, is it <32?
10:45:07 <EvanR> most of the time its more than 32
10:45:28 <Philippa> then W < n, what's special about W = 32?
10:45:47 <EvanR> i surmise that W is the word size of an Int
10:45:51 <Philippa> (W is log (max n))
10:46:23 <Philippa> I'm guessing the implementation is linear scan up to a point and then a tree
10:47:00 <benmachine> This means that the operation can become linear in the number of elements with a maximum of W -- the number of bits in an Int (32 or 64).
10:47:07 <jacobian> is there a prelude function that splits a list at an index into two lists, a prefix and a suffix?
10:47:09 <benmachine> http://hackage.haskell.org/packages/archive/containers/0.3.0.0/doc/html/Data-IntMap.html
10:47:14 <EvanR> benmachine: i read that, i dont understand it
10:47:29 <EvanR> can become linear in the number of elements with a maximum of W
10:47:33 <EvanR> this does not parse for me
10:47:40 <benmachine> EvanR: actually, nor me
10:47:57 <benmachine> it says min and then maximum as well
10:48:01 * hackagebot yaml 0.2.1 - Low-level binding to the libyaml C library.  http://hackage.haskell.org/package/yaml-0.2.1 (MichaelSnoyman)
10:48:03 <benmachine> confusing
10:48:33 <EvanR> so either worse case complexity is linear (bad) or constant (amazing), and i cant figure out which
10:48:44 <EvanR> or is W not constant
10:48:49 <ddarius> jacobian: You'll never guess what it is called.
10:48:56 <benmachine> W is constant on a per-machine basis I guess
10:49:01 <jacobian> split?
10:49:02 <EvanR> and i would expect a tree structure to give somewhere between n and 1
10:49:05 <jacobian> :t split
10:49:06 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
10:49:25 <benmachine> EvanR: mm, that is odd
10:49:29 <jacobian> ddarius: Still failing to guess...
10:49:58 <jbapple> It means "good"
10:50:02 <EvanR> jacobian: splitAt
10:50:04 <jbapple> W is small
10:50:05 <EvanR> :t splitAt
10:50:06 <lambdabot> forall a. Int -> [a] -> ([a], [a])
10:50:16 <jacobian> Thanks :)
10:50:32 <jbapple> but n can be even smaller
10:50:56 <EvanR> but this case seems irrelevant
10:51:11 <EvanR> its like saying exponential algorithms are fast for n less than 4
10:51:12 <benmachine> jbapple: but it says min - so at least as big as W, and probably bigger
10:51:18 <benmachine> not that O(32) makes any sense anyway
10:51:35 <Makoryu> O(32) is O(1)
10:51:44 <benmachine> well yes
10:51:46 <jbapple> I disagree with you about the definition of "min"
10:51:51 <benmachine> oh
10:51:53 <benmachine> so do I
10:51:58 <benmachine> sorry
10:52:03 <jbapple> and, as Makoryu, O(32) makes plenty of sense
10:52:07 <benmachine> I was thinking of the bit later on when it says maximum
10:52:14 <jbapple> *"as Makoryu says"
10:52:36 <benmachine> yes but O(min(32, n)) woudl surely be the same as O(min(1, n))
10:52:43 <Philippa> benmachine: no
10:52:50 <EvanR> except min(1,n) is n
10:53:02 <EvanR> which is what im complaining about, who cares about the 1-32 case
10:53:07 <aavogt> what?
10:53:08 <ddarius> Sure it would, except that's not what it says.
10:53:11 <aavogt> > min 1 100
10:53:12 <lambdabot>   1
10:53:19 <EvanR> erm
10:53:22 <EvanR> min(1,n) is 1
10:53:24 <EvanR> O(1)
10:53:36 <Philippa> benmachine: 1 subsumes min(1,n), but min(1,n) carries more info
10:54:12 <Philippa> EvanR: someone using IntMap with lots of small maps might well care
10:54:13 <EvanR> so is IntMap in general a constant time structure?
10:54:38 <Philippa> EvanR: yes, it's bound by O(1) as well as the function given
10:54:41 <ddarius> For a fixed size for Int, of course.
10:54:47 <aavogt> because it can only hold a finite number of elements
10:54:57 <jbapple> I think the thing to do to get the feel for this is read up on different models of computation: pointer machine, word RAM, etc
10:55:00 <ddarius> aavogt: Exactly.
10:55:03 * hackagebot control-monad-attempt 0.2.0.1 - Monad transformer for attempt.  http://hackage.haskell.org/package/control-monad-attempt-0.2.0.1 (MichaelSnoyman)
10:55:23 <EvanR> how can i tree be constant time
10:55:24 <EvanR> a
10:55:35 <Philippa> EvanR: because there's an upper bound on n
10:55:53 <Philippa> consider a binary tree branching on each bit in the Int
10:56:06 <benmachine> you can't store more than 2^W things in it, so lookups can't take longer than W
10:56:18 <jbapple> w should be considered an indeterminate -- it's not really constant, it's variable in the same way as n
10:56:29 <ddarius> jbapple: Exactly.
10:56:31 <benmachine> (err, can but don't)
10:56:39 <illissius> hi! is there any way to define a custom integer type which only has valid values, from, say, 1 to 960?
10:56:48 <benmachine> illissius: sort of but not really
10:56:54 <Makoryu> illissius: Sure, but you won't like it....
10:57:13 <EvanR> Philippa: ah, kind of misleading then
10:57:16 <illissius> use a custom type and make it an instance of Bounded?
10:57:18 <Makoryu> (This is one of the things I miss from Pascal and Ada)
10:57:28 <jbapple> Of course, for any particular machine, n is constant, too: it's no more than the size of your RAM, or RAM+VM, or RAM+VM+HD. To understand w, I think you need to take the quantifier out of your considerations
10:57:31 <EvanR> its like saying you have a regular tree, but you cant put more than 2^32 things in it
10:57:44 <benmachine> illissius: Bounded isn't enforced, really
10:57:53 <EvanR> so your upper bound is 2^32
10:57:53 <jbapple> intmap lookup is "forall w . O(min(n,w))"
10:57:54 <benmachine> illissius: it's more a promise than a rule
10:58:03 <ddarius> EvanR: It would be -if- it omitted the W and then wrote O(1).
10:58:03 <EvanR> all practical search algorithms are O(2^32) :)
10:58:10 <illissius> yeah -- but that was the way you were thinking of, then?
10:58:11 <ddarius> EvanR: Yep.
10:58:13 <EvanR> = O(1)
10:58:14 <EvanR> lol
10:58:19 <EvanR> thats stupid
10:58:21 <jbapple> In the long run, we're all O(1)
10:58:29 <benmachine> EvanR: it's log size of tree, isn't it?
10:58:33 <benmachine> so 32 not 2^32
10:58:40 <ddarius> EvanR: O notation doesn't describe the "practical" case.
10:58:40 <EvanR> im assuming the worst possible search
10:58:41 <jbapple> Or maybe, "in the long run, we're all dead in O(1) time"
10:58:47 <Philippa> EvanR: not really, because that upper bound is inherent in the datatype used as index. Compare and contrast with bounded-size bag implementations
10:58:52 <benmachine> illissius: I think the usual way is to define your own data type in a module and then not export the constructors
10:59:05 <Philippa> (which support a number of operations in constant time, unlike unbounded-size bags)
10:59:14 <benmachine> illissius: then make your own functions that check the parameter for validity before building a value of the type
10:59:32 <benmachine> illissius: *then*, just only supply functions to manipulate it that do the relevant checks at runtime
10:59:42 <Philippa> you're free to change the bound, use an Int with a different value of W
10:59:58 <benmachine> illissius: like, you have to decide what happens when someone does 500 + 461
10:59:59 <jbapple> or maybe "forall w, intmap lookup is O(min(n,w))"
11:00:05 * hackagebot web-encodings 0.2.5 - Encapsulate multiple web encoding in a single package.  http://hackage.haskell.org/package/web-encodings-0.2.5 (MichaelSnoyman)
11:00:06 <illissius> benmachine: I see, thanks. probably not worth the trouble :)
11:00:20 <aavogt> there could be a library for that
11:00:40 <aavogt> set your bounds with a type variable
11:00:59 <EvanR> use an index
11:01:00 <benmachine> illissius: probably not
11:01:21 <benmachine> hmm I guess if you were a bit silly you could construct a 960-constructor type by hmmmm
11:01:43 <illissius> Philippa: how do you mean? googling haskell int w didn't turn up much
11:01:52 <ddarius> benmachine: That wouldn't make any difference though.  You still have to decide what 500+500 means.
11:01:52 <jbapple> illissius: Oleg & Ken Shan (sp?) explain how with their lightweight static capabilities
11:02:07 <benmachine> ddarius: true
11:02:12 <illissius> 'undefined'
11:02:22 <benmachine> ddarius: but you would be able to export all 960 constructors :P
11:02:25 <benmachine> and pattern-match on them
11:02:41 <jbapple> the idea is that you only export "safe" constructors that check their arguments for correctness
11:02:45 <ddarius> benmachine: View patterns make that unnecessary.
11:03:05 <EvanR> mkBounded x | x < min || x > max = undefined
11:03:37 <Philippa> illissius: you're missing context here :-) We're talking about IntMap, which has a function with time bounded by O(min(n,W)) where W is the width of the Int type
11:03:59 <illissius> oh, ok
11:04:13 <Philippa> several people were WTFing about how that's any different from O(1)
11:04:15 <EvanR> and the fact that linear search through my entire harddrive is O(G), where G is 2^12
11:04:18 <EvanR> O(1) ;)
11:04:26 <illissius> seems our signals got mixed, with both of us using the word 'bound'
11:04:31 <benmachine> @quote squares
11:04:31 <lambdabot> <copumpkin> says: I love: Warning: Due to a known bug, the default Linux document viewer evince prints N*N copies of a PDF file when N copies requested. As a workaround, use Adobe Reader acroread
11:04:31 <lambdabot> for printing multiple copies of PDF documents, or use the fact that every natural number is a sum of at most four squares.
11:04:39 <Philippa> (the answer is that it's more specific than O(1), telling you how it behaves for small n)
11:05:07 <Philippa> EvanR: it's only a tree behind the scenes. Pretend the tree's not there and you get a constant bound for a known int size
11:05:08 <illissius> anyway, if there's no nice default way to do it like Ada etc. then i'll just stick with Int, it's not really important -- thanks for the help
11:05:13 <Twey> Hahaha, minor bug
11:05:28 <EvanR> Philippa: that seems weird, is it really constant? and fast?
11:05:30 <Twey> Hahaha
11:05:44 <ddarius> EvanR: It's a trie on the bits of the key.
11:06:02 <ddarius> For a 32-bit key, it will never take more than 32 steps.
11:06:07 * hackagebot wai-extra 0.0.0.2 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-0.0.0.2 (MichaelSnoyman)
11:06:18 <EvanR> and i presume a lot fewer than 32 in practice
11:06:37 <ddarius> Actually, I'm wrong.
11:07:01 <Philippa> EvanR: I mentioned bounded bags, should I go into detail about that or do you know what I mean there?
11:07:02 <ddarius> I believe it may require even less steps in the worst case.
11:07:23 <Philippa> yeah, but same difference in the end
11:07:38 <EvanR> im good
11:07:47 <Philippa> once you've carried out the min step, it's just a constant multiplier
11:09:38 <EvanR> if i have rectangles, and i want to check for pairs of colliding rectangles, should i use some sort of fold or map over an IntMap Rect ?
11:09:55 <xerox> fold sounds nice
11:10:10 <Philippa> you should probably have them inserted into a quadtree
11:10:25 <EvanR> ah right
11:11:13 <Philippa> then it's a tree walk: you test the rectangles at a given node and all the rectangles in a node with all the rectangles in the node's children
11:11:37 <Philippa> spatial partition is your friend :-)
11:11:39 <EvanR> let see if i get this right, i have a structure containing rectangles, and i can efficiently ask it for all rectangles that intersect a given rect
11:11:45 <benmachine> illissius: btw, I think the type (Maybe (), Maybe (), Maybe (), Maybe (), Maybe (), Maybe (), Maybe (Maybe ()), Maybe (Maybe (Maybe (Maybe ())))) has 960 fully-defined values :P
11:12:08 * hackagebot http-wget 0.6.0.1 - Provide a simple HTTP client interface by wrapping the wget  command line tool.  http://hackage.haskell.org/package/http-wget-0.6.0.1 (MichaelSnoyman)
11:12:12 <benmachine> hmm I should exponentiate more
11:12:28 <ddarius> benmachine: You could use strict variants to get 960(+1) values.
11:12:44 <benmachine> wait I could just use Bool that would be much less terrible
11:12:49 <benmachine> still pretty terrible but less so >_>
11:13:00 <Philippa> EvanR: I'd imagine wikipedia has a reasonable article on quadtrees? Implement one
11:13:01 <illissius> was about to say
11:13:18 <benmachine> (Bool, Bool, Bool, Bool, Bool, Bool, Ordering, Either Bool Ordering)
11:13:19 <benmachine> <_<
11:13:23 <Makoryu> benmachine: How about Maybe (EveryThingYouJustWrote)
11:13:31 <ddarius> benmachine: You can use function types to make that more compact.
11:13:32 <Philippa> it doesn't rapidly give you everything that /does/ intersect, but it does give you a fast way to cull out ones that definitely won't
11:13:34 <EvanR> question about data types. if i have Rect Int Int Int Int, and SDL exports Rect Int Int Int Int, can i efficiently convert between them? (they are the same friggin thing after all)
11:13:38 <benmachine> ddarius: yeah, I was just thinking that
11:13:50 <ddarius> benmachine: I was wondering if that was what you meant.
11:14:02 <EvanR> Philippa: thats just a detail, as a rect is just four points
11:14:09 * hackagebot authenticate 0.6.0.1 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-0.6.0.1 (MichaelSnoyman)
11:14:29 <ddarius> EvanR: You can't convert between them for free (though it potentially will be optimized to nothing.)
11:14:37 <ddarius> EvanR: I would recommend using SDL's type.
11:14:42 <Philippa> same here
11:14:52 <EvanR> bah
11:14:57 <Philippa> or build a free wrapper around it
11:15:11 <Philippa> newtyping it might be sensible for portability
11:15:18 <benmachine> ddarius: A -> B is B^A, right?
11:15:23 <ddarius> benmachine: Yes
11:15:44 <ddarius> Philippa: His issue is probably he doesn't want to depend on SDL in part of the code, but he does want pattern matching.
11:15:58 <Philippa> yeah, so define the accessors and suck it up
11:15:58 <EvanR> i have to use SDL rect in the sdl part of the code
11:16:05 <Philippa> view patterns are your friend
11:16:12 <benmachine> soo, (Ordering -> Bool -> Bool, Ordering, Either Ordering Bool)
11:16:13 <benmachine> tada
11:16:21 <benmachine> okay I will stop being silly now
11:16:26 <Philippa> you can put the accessors in a Rect class if it makes you feel better
11:16:32 <benmachine> can't pattern match on functions though
11:16:36 <ddarius> > 2^6 * 3 * (3+2)
11:16:37 <lambdabot>   960
11:16:57 <Philippa> (if SDL doesn't export labels for the fields, that does suck somewhat)
11:17:10 <jbapple> > length ([minBound .. maxBound] :: [(Maybe (), Maybe (), Maybe (), Maybe (), Maybe (), Maybe (), Maybe (Maybe ()), Maybe (Maybe (Maybe (Maybe ()))))])
11:17:11 <lambdabot>   No instances for (GHC.Enum.Bounded (Data.Maybe.Maybe ()),
11:17:11 <lambdabot>                  ...
11:17:33 <ddarius> Incidentally, it would probably make more sense for it to be Rect !Int !Int !Int !Int
11:17:34 <benmachine> Philippa: I dunno, how often do you need to get at a single corner of a rect?
11:17:47 <EvanR> ah yeah
11:17:56 <Philippa> benmachine: you need to get at the coords a lot if you're doing spatial partitioning and the like
11:17:57 <EvanR> it might be !Int in SDL
11:18:09 <benmachine> Philippa: but you'd probably get at all of them at once?
11:18:36 <Philippa> eh, it still forces you to write the pattern match out longhand and prevents you abstracting over the datatype
11:19:09 <aavogt> you're familiar with view patterns?
11:19:15 <EvanR> im not
11:19:27 <benmachine> @quote view.pattern
11:19:27 <lambdabot> benmachine says: let (\x -> case x of (\x -> x -> x) -> x -> x) = 0 in x / best view pattern evar
11:19:36 * benmachine self-indulgent
11:19:59 <EvanR> hulk smash
11:20:13 <benmachine> view patterns are an extension for applying an arbitrary function to a thing and matching on the result
11:20:33 <benmachine> > case [(1,2)] of (lookup 1 -> Just n) -> n
11:20:34 <lambdabot>   2
11:20:59 <benmachine> that calls lookup 1 [(1,2)] and then matches the result against the pattern Just n
11:21:11 <aavogt> > Seq.fromList [1,2,3,4]
11:21:12 <lambdabot>   fromList [1,2,3,4]
11:21:30 <EvanR> quad tree eh, so im guessing i want to make the methods polymorphic, i can store anything with 2d coords
11:22:14 <EvanR> what class is tht
11:22:25 <aavogt> > case Seq.viewL &&& Seq.viewR $ Seq.fromList [1,2,3,4] of (1 Seq.:< _, _ Seq.:< 4) -> ()
11:22:26 <lambdabot>   Not in scope: `Seq.viewL'Not in scope: `Seq.viewR'
11:22:50 <aavogt> @type viewL
11:22:51 <lambdabot> Not in scope: `viewL'
11:23:10 <aavogt> EvanR: stuff from Data.Sequence
11:23:58 <EvanR> theres no classes in there
11:24:38 <EvanR> ill use a type variable for the type of coordinate, and use (a,a) as the key
11:25:06 <Philippa> terminology question/straw poll: what term would you use to describe all of monads, applicatives, arrows and any other structure used to manage effects in a similar way? What term would you use for the equivalent of monad/applicative/arrow transformers, but excluding eg the monad-to-arrow newtype and other conversions between different structures(as opposed to the same ones?)
11:25:32 <fax> idioms ?
11:25:49 <lament> functors?
11:25:58 <danderson> burritos
11:26:05 <kynky> thingemajigs
11:26:16 <danderson> ie. many different ways to wrap meaty goodness
11:26:23 <ddarius> Philippa: Incidentally, I recommend that you simply cease responding on the subthread of that discussion involving macro.
11:26:29 <ddarius> s/macro/marco/
11:26:35 <jbapple> @type Seq.viewl
11:26:36 <lambdabot> forall a. Seq.Seq a -> Seq.ViewL a
11:26:41 <Philippa> no, not something that assumes there's a "most generic" structure. I suspect there isn't a good one
11:27:00 <lament> functors imo
11:27:00 <Philippa> (I can think of good uses for structures that aren't meaningfully functors, for example)
11:27:06 <lament> yeah?
11:27:48 <cads> This is frustrating. I have a cabal package that deploys (installs? compiles? anyways..) just fine in windows if I give it some --extra-lib-dir's and --extra-include-dir's -- so long as I'm doing this from msys bash
11:27:50 <Philippa> yeah. Suppose you want to resource-count something, so you can't allow arbitrary pure computations
11:28:18 <cads> from the windows command there is an error about the config script not having any SH to be run with, and rightly so
11:28:20 <Peaker> Does anyone here know some about Vty? Performance-wise, how it redraws?  I am using it and wondering whether performance issues are mine or Vty's
11:28:25 <Philippa> ddarius: yeah, that was pretty much my plan. Just wanted to say my piece about metalinguistry being relevant in a critique of FP
11:28:50 <Peaker> Vty seems to require you to update the entire screen - so it probably doesn't do differential updates
11:28:55 <cads> the fix is to change the cabal file's build type from Custom to Simple
11:29:20 <cads> I was wondering if there any way to do this automatically
11:29:43 <aavogt> install a sh?
11:29:55 <cads> I can't seem to be able to say if(windows) ; build-type: Simple
11:30:18 <cads> aavogt: this is in the interest of making hmatrix work naturally on windows
11:30:33 <aavogt> why can't it be build-type: Simple everywhere?
11:31:04 <cads> hmm, that's a good question
11:31:31 * Philippa is tempted to simply describe the structures as (embedded) languages, but could use a better term for the transformers than "language transformers"
11:32:08 <aavogt> abstractions
11:32:10 <Peaker> Anyone know if there's a better alternative to vty, performance-wise?
11:32:26 <dv-> ncurses?
11:32:35 <ddarius> "notions of computation"
11:32:42 <Peaker> dv-, something less painful? :)
11:32:59 <dv-> that's awfully picky
11:33:02 <benmachine> heh
11:33:16 <Philippa> ddarius: yeah, and then I can find a qualifier for "notion transformers" to indicate I'm talking about ones on the same structure
11:33:50 <Philippa> has "notions of computation" been used somewhere? I've got a feeling it has, but can't remember where...
11:34:02 <ddarius> Um... Moggi
11:34:08 <Philippa> ah, d'oh!
11:34:45 <Philippa> I should probably re-read. I'm going somewhere with this - specifically, I want to turn round and tell shap that effects don't scale :-)
11:34:45 <Peaker> oh wait, the performance issue is in my code...
11:35:02 <Peaker> I wish Vty supported image stacking so I wouldn't have to do a half-assed wrapper
11:35:15 <Philippa> (and shed a little bit of light on why, and where we might look for subsets that do scale and what consequences for architecture might be)
11:54:01 <cads> aavogt: does the build-type: Custom setting mean only that cabal install must run the configure.sh script?
11:54:28 <cads> In this case, all the configure script run is configure.hs, which seems a little redundant
11:57:02 <benmachine> hlint has some pretty weird ideas about what is a warning and what is an error
12:00:43 <ickabob> quit
12:01:14 <EvanR> @hoogle Int -> a -> (a -> m a) -> m a
12:01:15 <lambdabot> No results found
12:01:42 <EvanR> update a Int times using an action
12:02:21 <aavogt> cads: build-type: Custom tends to mean that it runs the Setup script
12:05:05 <EvanR> http://codepad.org/SIwWpWOE
12:06:27 <aavogt> @type replicateM
12:06:28 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
12:06:33 <aavogt> @type replicateM_
12:06:34 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
12:06:53 <EvanR> replicate M doesnt pass the result to future iterations
12:08:32 <aavogt> @type execStateT $ replicateM ?i (get >>= ?f >>= put)
12:08:33 <lambdabot> forall s (m :: * -> *). (Monad m, ?f::s -> StateT s m s, ?i::Int) => s -> m s
12:08:54 <EvanR> now were getting somewhere, i think
12:09:05 <Peaker> EvanR, Maybe you want:
12:09:06 <aavogt> @type execStateT $ replicateM ?i (get >>= lift . ?f >>= put)
12:09:07 <lambdabot> forall s (m :: * -> *). (Monad m, ?f::s -> m s, ?i::Int) => s -> m s
12:09:09 <Peaker> @type foldr (>=>) return
12:09:10 <lambdabot> forall (m :: * -> *) c. (Monad m) => [c -> m c] -> c -> m c
12:09:16 <Peaker> with:
12:09:18 <Peaker> @type iterate
12:09:19 <lambdabot> forall a. (a -> a) -> a -> [a]
12:09:32 <Peaker> oops, with replicate
12:09:37 <EvanR> im looking at it wrong
12:10:01 <EvanR> i dont need IO
12:10:04 <EvanR> so
12:10:19 <EvanR> :: Int -> a -> (a -> a) -> a
12:10:28 * hackagebot web-routes-quasi 0.0.0 - Define data types and parse/build functions for web-routes via a quasi-quoted DSL  http://hackage.haskell.org/package/web-routes-quasi-0.0.0 (MichaelSnoyman)
12:10:29 <EvanR> now where are we
12:11:05 <EvanR> :t foldr
12:11:06 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
12:12:11 <EvanR> (compose f n times) a ;)
12:13:31 <EvanR> run n x f = f `((.) * n)` x
12:13:48 <EvanR> not even close
12:16:03 <EvanR> http://codepad.org/agggX4th
12:16:25 <c_wraith> that's an awesome path in that url
12:16:32 <EvanR> lol
12:17:28 <EvanR> :t foldr
12:17:29 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
12:18:06 <EvanR> foldr (\a b -> f b) x [1..n]
12:18:21 <c_wraith> isn't that functionally equivalent to applyALot f n x = iterate f n !! x
12:18:45 <EvanR> :t iterate
12:18:46 <lambdabot> forall a. (a -> a) -> a -> [a]
12:18:53 <uorygl> What's that fancy do notation thing where you can refer to things that have yet to be bound?
12:19:02 <c_wraith> mdo ?
12:19:12 <c_wraith> I've never used it.
12:19:17 <EvanR> c_wraith: i know theres gotta be a short way
12:19:24 <uorygl> Yeah, that.  What's the class that lets you use mdo, and what's its member?
12:19:29 <EvanR> last (iterate f x)
12:19:30 <EvanR> ?
12:19:36 <c_wraith> last will never finish
12:19:42 <c_wraith> iterate generates an infinite list
12:19:42 <EvanR> on
12:19:44 <EvanR> oh
12:19:53 <EvanR> (iterate f x) !! n
12:19:54 <c_wraith> @src MonadFix
12:19:54 <lambdabot> class (Monad m) => MonadFix m where
12:19:54 <lambdabot>     mfix :: (a -> m a) -> m a
12:20:01 <c_wraith> uorygl: that's the class
12:20:04 * uorygl nods.
12:20:24 <c_wraith> But I've never used it, and really have no clue what it does. :)
12:21:00 <uorygl> > do {Nothing; Nothing}
12:21:01 <lambdabot>   Nothing
12:21:07 <EvanR> c_wraith: this is pretty bad ass ;)
12:21:53 <uorygl> Well, I think it would allow you to do stuff like this: mdo {lift (putStr "foo"); goto x; lift (putStr "bar"); x <- label; lift (putStr "baz")}
12:22:04 <EvanR> iterate produces the evolution of the rest of the game, assume no more i/o occurs, but i do !! n and stop for i/o, which changes history ;)
12:22:09 <uorygl> In the Continuation monad, with suitable definitions of goto and label, that will print "foobaz".
12:22:10 <EvanR> laziness is nice
12:22:13 <EvanR> i mean, nuts
12:22:30 <Adamant> even better, it's both
12:22:33 <EvanR> haha
12:23:50 <uorygl> Now to ponder how the hell you implement mfix in a continuation monad.  I mean, >>= was bad enough!
12:24:53 <c_wraith> I feel like you can just follow the types to implement it
12:25:14 <c_wraith> you might even be able to get @djinn to implement it
12:25:42 <uorygl> It's recursion that isn't guaranteed to terminate.  I don't think that's going to happen.
12:25:55 <c_wraith> oh, right.  djinn can't do recursion
12:26:09 <seanmcl> This is off topic, but does anyone know how to count the number of cache misses in a program?  Do you need a simulator or is there a mode you run the processor where it counts?   Can the Haskell profiler do it?  Thanks.
12:26:16 <gwern> be a good project to work on djinn to the point it was actually useful
12:26:43 <uorygl> Make Djinn use Ivor instead.  :P
12:26:45 <gwern> I wonder how much of the prelude could be djinn-generated from its type?
12:27:00 <uorygl> I really should find out a better way to find out how Ivor works than reading its expository paper.
12:28:12 <cads> uorygl: what's ivor?
12:28:25 <uorygl> It's a proof system for Haskell.
12:32:34 <EvanR> heres my main loop
12:32:36 <EvanR> http://codepad.org/zDEof1RW
12:33:53 <cads> this is very strange
12:34:30 <cads> have you guys had any troubles compiling hackage packages in a vmware VM?
12:35:11 <cads> I'm in windows, VM is debian linux. It gets stuck on the linking step.
12:35:55 <Zao> cads: Low memory?
12:36:57 <cads> no, the memory is fine - only 16M of paged memory, 50% of my physical memory is free, as well
12:37:17 <cads> the vm process only have 16M of paged mem*
12:37:51 <cads> hmm, it's just cranking away at %10 CPU usage and getting nowhere
12:38:43 <EvanR> > minBound :: Word
12:38:44 <lambdabot>   0
12:39:03 <EvanR> > -1 < (minBound :: Word)
12:39:04 <lambdabot>   False
12:39:42 <gwern> > -1 :: Word
12:39:43 <lambdabot>   18446744073709551615
12:39:55 <EvanR> hehe
12:40:05 <gwern> well, that explains that
12:40:18 <gwern> > maxBound :: Word
12:40:19 <lambdabot>   18446744073709551615
12:40:28 <gwern> overflow
12:40:28 <EvanR> shouldnt the compiler warn you of these things
12:40:48 <Peaker> EvanR, maybe you wanted:
12:40:50 <Peaker> @foldr (.) id
12:40:51 <lambdabot> No match for "(.)".
12:40:52 <lambdabot>  
12:40:52 <lambdabot> *** "id" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
12:40:52 <lambdabot> Id
12:40:52 <lambdabot>  
12:40:53 <gwern> EvanR: if you wish to play with sharp binary blades, you have no excuses
12:40:53 <lambdabot> [14 @more lines]
12:40:56 <Peaker> @type foldr (.) id
12:40:57 <lambdabot> forall b. [b -> b] -> b -> b
12:41:17 <EvanR> displays his full collection of binary blades
12:41:36 <gwern> EvanR: if you want safety, go use Integer!
12:41:37 * hackagebot extensible-exceptions 0.1.1.2 - Extensible exceptions  http://hackage.haskell.org/package/extensible-exceptions-0.1.1.2 (IanLynagh)
12:42:06 <nus> exceptional extensions?
12:42:13 <EvanR> Peaker: i decided to use iterate
12:42:31 <benmachine> @type mconcat . foldMap endo
12:42:32 <lambdabot> Not in scope: `foldMap'
12:42:32 <lambdabot> Not in scope: `endo'
12:42:35 <benmachine> oh er
12:42:49 <benmachine> @type appEndo . Data.Foldable.foldMap Endo
12:42:50 <lambdabot> forall a (t :: * -> *). (Data.Foldable.Foldable t) => t (a -> a) -> a -> a
12:44:58 <Peaker> EvanR, You probably don't want:  world : iterate update world
12:45:06 <EvanR> i was about to ask about this
12:45:11 <Peaker> > take 5 $ iterate (+1) 0
12:45:12 <lambdabot>   [0,1,2,3,4]
12:45:17 <Peaker> (it already has 0)
12:45:27 <EvanR> oh really
12:45:37 <EvanR> nice
12:46:00 <EvanR> i was wondering about the evaluation of (iterate f x) !! n
12:46:09 <Peaker> EvanR, also, you can use forever $ do   instead of recursing like that
12:46:29 <EvanR> but i would need mutable variables
12:46:49 <Peaker> EvanR, You mean a StateT?
12:47:02 <EvanR> IORef
12:47:03 <c_wraith> there's also
12:47:06 <c_wraith> :t iterateM
12:47:07 <Peaker> EvanR, no need for IORef
12:47:07 <lambdabot> Not in scope: `iterateM'
12:47:13 <c_wraith> oh.  well there should be!
12:47:18 <Peaker> @hoogle iterateM
12:47:18 <lambdabot> No results found
12:47:24 <EvanR> the iterate part is pure
12:47:26 <c_wraith> it's trivial to write.
12:48:04 <Peaker> EvanR, why not use:  mainLoop video input timer = (`evalStateT` initialWorld) . forever $ do ...
12:48:26 <Peaker> Maybe throw a MaybeT in there if you want to stop
12:48:38 <EvanR> monad transformers? :S
12:49:10 <EvanR> and yeah i do want to stop
12:50:34 <EvanR> i cant find the doc for StateT
12:50:53 <Peaker> EvanR, yeah, why not use transformers here?
12:51:09 <EvanR> what do i gain
12:51:30 <Peaker> EvanR, IMO: clarity
12:51:39 <EvanR> mkay
12:51:54 <Peaker> (The type says mainLoop takes video input and timer as inputs, but "world" is a state that it changes too)
12:52:19 <Peaker> and the type will also describe the fact it stops - and instead of a recursive call, "forever" will make it clear that it's a loop
12:52:47 <Peaker> Your reassignment into "world" can be nicer with StateT's "modify"
12:53:21 <Peaker> here's the doc: http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/Control-Monad-State-Lazy.html#2
12:53:38 <EvanR> how do you stop a forever
12:55:52 <Peaker> EvanR, With an exception
12:56:01 <Peaker> EvanR, Either IO exception or using a MaybeT exception
12:56:25 <Peaker> MaybeT IO replaces (IO a) with (IO (Maybe a)) where (>>=) stops when it encounters a Nothing
12:56:41 * hackagebot control-monad-failure 0.6.1 - A class for monads which can fail with an error.  http://hackage.haskell.org/package/control-monad-failure-0.6.1 (PepeIborra)
12:56:58 <EvanR> this sounds complex
12:57:11 <Peaker> EvanR, The unknown often does :)
12:57:17 <EvanR> yes
12:57:19 <Peaker> EvanR, You can try it out to learn about transformers and then ditch it
12:57:47 <Peaker> EvanR, Loops sound more complicated than goto's -- but they add valuable structure.. Transformers add similar structure
12:58:03 <EvanR> i see the StateT doc, but i dont see functions you can use inside the monad
12:58:07 <EvanR> like modify
12:59:30 <EvanR> mmm :\
13:00:13 <rfh> division of natural numbers can be specified by the condition that (n x m)/n= m for all positive n and all m. construct a program for division and prove that is meets the specification. dont know how to define such a function for division(m x n is defined by m x n = foldn (+m) 0 n)
13:02:31 <rfh> certainly its trivial, but i have not even an idea how to begin
13:03:51 <EvanR> brain exploding from these monad transformers
13:06:10 <kynky> EvanR, thats one of the side effects
13:08:22 <EvanR> :t get
13:08:22 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
13:08:25 <EvanR> :t put
13:08:26 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
13:09:00 <aavogt> @unmtl StateT s m a
13:09:00 <lambdabot> s -> m (a, s)
13:11:07 <aavogt> there is no MaybeT
13:11:41 <aavogt> at least without getting another package
13:11:51 <EvanR> mainLoop :: ... -> StateT World IO ()
13:13:44 <EvanR> maybe not
13:13:54 <aavogt> why not?
13:14:02 <IceDane> If I wanted to set up ghc on a server simply for running lambdabot, should I just get ghc 6.8?
13:14:22 <EvanR> ok maybe so ;)
13:14:33 <benmachine> @hackage MaybeT
13:14:33 <lambdabot> http://hackage.haskell.org/package/MaybeT
13:14:46 <EvanR> i was thinking -> IO (), but internally it uses a StateT
13:14:48 <aavogt> IceDane: the current lambdabot runs on ghc-6.10, so you might have no problems
13:14:57 <IceDane> aavogt: I see
13:15:10 <gwern> IceDane: 6.10 should work
13:15:14 <IceDane> Sweet, thanks
13:15:15 <gwern> if it doesn't tell me
13:15:56 <aavogt> EvanR: does mainLoop call itself?
13:16:50 <EvanR> the normal version does
13:16:59 <aavogt> @type execStateT $ do return ()
13:17:00 <lambdabot> forall s (m :: * -> *). (Monad m) => s -> m s
13:17:15 <EvanR> the StateT version, i think, wont and will use forever
13:18:25 <cads> Zao - increasing my VM's ram to a gig (from 256) gets it pas the linking step
13:18:55 <cads> I wonder why it didn't simply fail when it didn't have enough memory before?
13:21:48 <Zao> cads: Got sufficient swap?
13:22:02 <Peaker> EvanT: I wrote a tutorial explaining their basics: http://www.haskell.org/haskellwiki/Monad_Transformers_Tutorial
13:22:04 <Zao> cads: I guess it might get stuck trying to mmap stuff or something. strace/truss it maybe and see what it tried to do?
13:22:22 <Peaker> EvanR, Basically explaining MaybeT, but if you understand State, I think going from there to StateT would be easy
13:22:43 <EvanR> im in the middle of doing StateT
13:23:29 <Peaker> I don't understand why "ld" eats up so much memory when linking Haskell
13:24:44 <Botje> it's not written in haskell, that's hy :)
13:24:56 <Zao> Peaker: Lots of stuff to link?
13:25:11 <mamalujo> hello. I seem to remember it being claimed that with common class extensions - mptcs and fd/assoc types - classes are effectively first class. What is exactly meant by this, does someone recognize perhaps, and what kind of encoding/style is in question?
13:25:12 <Zao> If you're in a horrible bind, you could try that oddball "gold" linker too.
13:25:19 <EvanR> Peaker: http://codepad.org/QrUdLFdd
13:27:03 <pikhq> Peaker: GNU ld sucks. That's about it.
13:27:17 <benmachine> s/ld // # :O controversy
13:27:30 <Ke> !
13:27:56 * hackagebot todos 0.1 - Easy-to-use TODOs manager.  http://hackage.haskell.org/package/todos-0.1 (IlyaPortnov)
13:28:07 <benmachine> oh hey I wrote one of those
13:28:16 <benmachine> mine was really small and a bit naff though
13:30:44 <EvanR> Peaker: if i have the general form correct, i see a problem. the initial world will never be collected?
13:35:35 <EvanR> Peaker: and in light of the transformer and explicit loop, im thinking it would be nicer if i broke out using untilM
13:45:02 <IceDane> How am I supposed to interpret this? http://codepad.org/wWl3y00v
13:45:12 <IceDane> Was setting up the haskell platform, btw
13:45:33 <IceDane> that's "sudo checkinstall -y"
13:50:39 <jon_of_arc> I'm attempting to clean up an attribute grammar library, and am having difficulty not requiring the user to manually tie the knot for inherited attributes (or otherwise manually handle data propagation); any advice on how to provide a clean way to assist users in writing mutually-recursive-by-default abstract syntax trees?
13:50:45 <EvanR> if my runStateT function uses any functions that do IO, do those functions have to return StateT s IO a
13:51:17 <EvanR> even if they dont use put get gets modify
13:51:43 <qwerty01> anyone knows where can I find examples of deterministic pushdown automatons?
13:53:52 <EvanR> :t runStateT
13:53:53 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
13:54:07 <benmachine> EvanR: you can only pass a StateT s IO a to runStateT, and you can only bind StateT s IO a to other StateT s IO a
13:54:21 <benmachine> EvanR: but you could do some portion of the code in IO then liftIO it all at once
13:54:22 <EvanR> benmachine: thats what i was afraid of :)
13:54:37 <EvanR> :t liftIO
13:54:38 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
13:54:50 <benmachine> EvanR: it has often been said though that StateT s IO is a bit weird anyway
13:54:55 <benmachine> on account of, IO already has state in it
13:55:01 <benmachine> e.g. ReaderT IORef IO
13:55:43 <EvanR> why is liftIO a special function, why not lift any monad
13:55:58 <Peaker> benmachine, pure functions already have argument passing, why ReaderT?
13:56:23 <Peaker> StateT s IO  is nicer - lets you later refactor your code to use something weaker than IO
13:56:27 <benmachine> Peaker: convenience
13:58:22 <danderson> Peaker: imagine a case where your program has some static configuration, but the code that actually needs it is 5 or 6 levels down the call chain
13:58:39 <danderson> are you going to pass a Params to each of those levels, and pass that argument on everywhere?
13:59:04 <danderson> much easier to make everything part of a custom monad stack for your app, and ask for the Params at the place you actually need them
13:59:34 <Peaker> danderson, I was satiring "IO already has state"
13:59:51 <EvanR> im still confused
14:00:00 <EvanR> what do you mean by 'liftIO all at once'
14:00:02 <Peaker> EvanR, there's "lift" of any monad
14:00:13 <Peaker> EvanR, liftIO does "lift . lift . lift ..." the proper amount of times to get to IO
14:00:35 <EvanR> which is 1 here
14:02:27 <benmachine> by liftIO all at once I meant build a compound IO action from smaller ones in the usual way
14:02:36 <benmachine> then instead of liftIO a >> liftIO b >> liftIO c
14:02:42 <benmachine> you do liftIO (a >> b >> c)
14:02:45 <benmachine> for example
14:02:49 <benmachine> liftIO/lift whatever
14:03:01 <EvanR> or just liftIO action
14:03:03 <benmachine> liftIO is just a convenience measure because the thing you want to lift is usually IO
14:03:10 <EvanR> and you do that in the part that is using StateT
14:04:49 <yitz> It means that the number of layers in your monad transformer stack is not hard-wired into your program. You can change the type without changing your code. You have the luxury to do that with IO, because it's always at the very bottom of the stack.
14:05:16 <benmachine> due to the nonexistence of IOT
14:05:32 <yitz> benmachine: that's a chickandeggism
14:05:40 <benmachine> is it
14:05:44 <EvanR> im going to paste what i have so far
14:06:24 <EvanR> http://codepad.org/feztBcuI
14:06:31 <EvanR> this is supposed to be the runStateT
14:06:43 <EvanR> prior to currying
14:07:10 <aavogt> you can't get out of forever without some additional tricks
14:07:19 <EvanR> i would use untilM
14:07:26 <aavogt> like  ContT
14:07:41 <yitz> @remember aavogt you can't get out of forever without some additional tricks
14:07:41 <lambdabot> It is stored.
14:09:19 <EvanR> alright
14:09:33 <EvanR> important question, the initial world is always available, thats bad
14:09:42 <EvanR> why is it even available there
14:09:49 <EvanR> its in get too
14:16:03 <Peaker> yitz, you can also do so by writing a bit of boilerplate (named lifters for each layer)
14:17:13 <yitz> Peaker: yeah. so you need to change just one line of code for each affected layer of the stack when you change it. whereas for IO you don't need even that.
14:23:29 <ddarius> > forever (do Nothing)
14:23:29 <lambdabot>   Nothing
14:23:51 <uorygl> Not only did lambdabot do something, but it stopped afterward!
14:24:17 <aavogt> > forever_ Nothing
14:24:18 <lambdabot>   Not in scope: `forever_'
14:24:33 <uorygl> So, I just came up with a semi-silly idea: HaDL, the Haskell-Like Hardware Description Language.
14:24:51 <ddarius> uorygl: There are already several Haskell-inspired HDLs.
14:24:54 <uorygl> It's a computer language for describing circuits; the syntax is as close as possible to Haskell's.
14:25:04 <uorygl> Several?  Huh.
14:25:43 <EvanR> gah.
14:25:47 <EvanR> :t runStateT
14:25:48 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
14:26:19 <IceDane> what's with code.haskell.org?
14:26:28 <EvanR> runStateT :: s -> m (a, s)
14:26:30 <IceDane> ffff, when I finally decide to set up lambdabot it's broken
14:27:59 <ivanm> IceDane: lambdabot is tricky to set up even at the best of times
14:28:14 <EvanR> @google StateT
14:28:15 <lambdabot> http://www.walware.de/goto/statet
14:28:15 <lambdabot> Title: WalWare - Homepage
14:28:20 <EvanR> >_<
14:28:24 <EvanR> @google StateT tutorial
14:28:25 <lambdabot> http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html
14:28:26 <lambdabot> Title: Online Tutorial: What the hell are Monads?
14:28:47 <IceDane> ivanm: I can't even arrive at the trikcy part
14:28:55 <uorygl> Oh, Lava.  I've kind of actually heard of that one; I didn't know it was an HDL.
14:28:56 <IceDane> well, I did have to manually patch an install script
14:29:00 <IceDane> but that wasn't particularly tricky
14:29:45 <ivanm> IceDane: well, lambdabot is on hackage...
14:30:58 <EvanR> whats with the two different types of runStateT given by definition of StateT and by lambdabot
14:31:06 <IceDane> ivanm: according to the wiki, I have to get stuff from the darcs repos
14:31:19 <IceDane> for 6.10+
14:31:25 <ivanm> hmmm...
14:31:27 <IceDane> and the install script I patched was for the haskell platform
14:31:28 <ivanm> *shrug*
14:31:40 <Botje> EvanR: 23:26 < EvanR> runStateT :: s -> m (a, s)
14:31:44 <Botje> that's not the right type
14:31:49 <Botje> where'd you get that?
14:32:24 <EvanR> newtype StateT s m a = StateT { runStateT :: (s -> m (a,s)) }
14:32:28 <Botje> ah.
14:32:33 <Botje> that's record syntax
14:32:42 <EvanR> sure is easy pick this stuff up ;)
14:32:57 <Botje> compare it with data Foo = Foo { foo :: Int }
14:33:03 <EvanR> its like decyphering heiroglyphs
14:33:07 <Botje> the foo function takes a Foo and produces an Int
14:33:20 <EvanR> ah
14:33:26 <Botje> likewise, runStateT takes a StateT s m a and produces a function s -> m (a,s)
14:33:28 <EvanR> foo :: Foo -> Int
14:34:01 <EvanR> tricky
14:34:19 <dons> go, cabal, go!
14:34:30 <EvanR> that is why i couldnt understand how to write a friggin runStateT
14:49:29 <EvanR> ok so all the runState runStateT execStateT etc all take a monad as its first argument like StateT s IO a, is this what its referring to as the 'initial state', if so, how do i construct one.
14:50:30 <BMeph> EcanR: "return". ;)
14:50:57 <EvanR> > return 4 :: StateT Int IO ()
14:50:58 <lambdabot>   No instance for (GHC.Num.Num ())
14:50:58 <lambdabot>    arising from the literal `4' at <intera...
14:51:09 <EvanR> > return 4 :: StateT Int IO Int
14:51:10 <lambdabot>   No instance for (GHC.Show.Show
14:51:10 <lambdabot>                     (Control.Monad.State.Laz...
14:51:52 <EvanR> > return 4 :: StateT () IO Int
14:51:53 <lambdabot>   No instance for (GHC.Show.Show
14:51:53 <lambdabot>                     (Control.Monad.State.Laz...
14:52:24 <Mathnerd314> :k StateT
14:52:25 <lambdabot> * -> (* -> *) -> * -> *
14:52:58 <Mathnerd314> kind should show constraints :-/
14:53:58 <Mathnerd314> though I guess those only show up on instances
14:53:59 <Philonous> > runStateT (return "abc") 4 :: Maybe (String, Int)
14:54:00 <lambdabot>   Just ("abc",4)
14:54:02 <EvanR> return 5... results in a StateT which... when run with an initial value... returns 5 and the unchange initial value
14:54:53 <Philonous> EvanR StateT is parametrised over your state type. You construct the initial state just by passing runStateT whatever value you like
14:55:08 <EvanR> yes
14:56:39 <EvanR> why is the initial value second
14:56:47 <cads> zao, strace is pretty great btw
14:57:02 <EvanR> putting a larger expression in for return would be annoying
14:57:37 <monadic_kid> well you can use flip, flip runStateT $ do ...
14:57:54 <monadic_kid> flip runStateT init $ do ...
14:58:03 <Philonous> EvanR Yes, I agree. That's a nuissance
14:59:00 <monadic_kid> :t flip runStateT
14:59:01 <lambdabot> forall a (m :: * -> *) a1. a -> StateT a m a1 -> m (a1, a)
14:59:35 <EvanR> okay
15:02:53 <dons> shapr: Python eggs, Ruby gems and Haskell cabbages, amirite?
15:04:52 <ivanm> dons: just because those languages decide to be "cute" doesn't mean we have to as well
15:05:03 <ivanm> calling them "cabbages" is IMHO rather silly
15:05:56 <EvanR> the logo should also be changed to a pikachu dancing with a teletubby
15:07:38 <Philonous> A manga version of Haskell Curry throwing little lambdas at the complexity beast.
15:08:09 <Saizan_> ooh, we should make and adventure game out of that
15:08:32 * ivanm begs to differ
15:08:51 <Saizan_> it could turn out quite lame if taken seriously
15:09:04 <EvanR> too late
15:09:09 <EvanR> already on it
15:11:12 <dons> ivanm: ok. we shouldn't be cute.
15:12:06 <dons> Ruby Gems, Haskell Remotely Obtainable Component Systems. "Rocks"
15:12:23 <Saizan_> is there a pun with "lambda" and "package"?
15:12:34 <dons> also, down with learn you a haskell, up with 'a gentle introduction to haskell'!
15:12:36 <Saizan_> or we could go esoteric via cabal
15:12:39 <dons> its so retro it is cool again
15:13:15 <dons> hmm. cabal eh? haskell conspiracies?
15:13:24 <dons> haskell secrets?
15:13:37 <gwern> cabal is an acronym, you know
15:13:47 <dons> or is it...
15:14:13 <rickythesk8r> thanks for brining up the 'gentle introduction'
15:14:17 <rickythesk8r> bringing*
15:14:28 <Philonous> Btw, can't we get rid of the Lambda? Every second functional language features it in the logo
15:14:43 <Saizan_> someone was learning directly from the haskell report the other day
15:14:44 <EvanR> its way better than the old logo
15:14:49 <dons> should be hosted on a site like lyah, http://www.haskell.org/tutorial/
15:14:54 <gwern> dons: no, it is an acronym. that's where the word came from
15:14:59 <rickythesk8r> I am working with section 9.3, Monads, and playing with the sample code
15:15:02 <dons> gwern: that's what we tell you.
15:15:08 <EvanR> http://www.mirrorservice.org/sites/www.haskell.org/HaskellLogo_2.jpg
15:15:14 <gwern> -_-
15:15:38 <EvanR> the current logo rocks
15:15:46 <EvanR> incorporating >>=
15:15:47 <rickythesk8r> i'm pretty completely flummoxed by the definiton "readSM :: SM S"
15:16:52 <rickythesk8r> and in particular, the following line: "readSM = SM (\s -> (s,s))
15:16:55 <rickythesk8r> "
15:17:15 <rickythesk8r> where the comment says, "extracts the state from the monad"
15:17:41 <Saizan_> "extract" is not so right
15:18:07 <Saizan_> in the sense that the state is the value returned by that monadic action
15:18:16 <Saizan_> but you're not going out of the monad
15:18:18 <Philonous> EvanR: Yeah, that is until you read the rants about how monads are a totally orthogonal concept to haskell
15:18:32 <EvanR> ._.
15:19:17 <EvanR> its one of like two classes with special syntax
15:19:51 <EvanR> list isnt a class, so like one
15:19:55 <Saizan_> rickythesk8r: the idea though, is that if you write "readSM >>= \x -> ..." in ".." x is the state as it was when readSM could see it
15:20:14 <Saizan_> s/in/inside/
15:20:24 <rickythesk8r> if i construct an "SM" in ghci like this: let y = SM (\x -> (0::S,x)) then ";t y" is "SM S"
15:20:54 <rickythesk8r> S is a type synonym for Integer; not in the text but in the sample code
15:21:21 <Saizan_> ok
15:22:29 <Saizan_> SM (\x -> (0::S,x)) = return (0 :: S), btw
15:23:03 <rickythesk8r> interesting; i was following the code from top
15:23:51 <EvanR> :t flip (-)
15:23:52 <lambdabot> forall a. (Num a) => a -> a -> a
15:24:04 <cads> this logo
15:24:07 <cads> http://www.haskell.org/sitewiki/images/7/75/Pure_Devil_Haskell.png
15:24:07 <EvanR> > 5 `flip (-)` 2
15:24:08 <lambdabot>   <no location info>: parse error on input `('
15:24:12 <cads> needs to be our logo.
15:24:22 <EvanR> > 5 `(flip (-))` 2
15:24:23 <lambdabot>   <no location info>: parse error on input `('
15:24:34 <cads> evil bird-lambda oversees functional compilation.
15:24:37 <cads> and all is good.
15:24:38 <Berengal> Parallelism is wicked cool
15:26:15 <EvanR> i rewrote my main loop using StateT
15:26:21 <EvanR> http://codepad.org/ClyINXM8
15:26:50 <EvanR> is it better
15:27:51 <rickythesk8r> one more question: the 'e9' example produces ((0,1),1)
15:29:14 <Saizan_> rickythesk8r: could you link it?
15:29:41 <Berengal> What would be the easiest way to push bits onto a display?
15:29:54 <Berengal> SDL bindings? OpenGL? X?
15:29:56 <rickythesk8r> how?
15:30:00 <rickythesk8r> plz
15:30:39 <EvanR> i do like the modify put get stuff more than the old version, but all the liftIO is makes is chunkier
15:31:02 <monadic_kid> Berengal: what are you trying to do exactly?
15:31:12 <EvanR> Berengal: using SDL bindings now. they do not let you manipulate bits in the display, unlike the c lib
15:31:59 <Berengal> monadic_kid: Nothing in particular just yet, but probably something easy like asteroids, invaders, tetris..
15:32:09 <Berengal> Well, "easy". Simple, more like
15:32:23 <EvanR> for graphics drawing commands, maybe you need cairo, or opengl
15:32:25 <Saizan_> rickythesk8r: where are these examples in the guide? or you could always paste the code in a pastebin site
15:32:34 <monadic_kid> Berengal: i suggest sticking with SDL, nice and simple
15:32:43 <EvanR> sdl does not have line drawing, or put pixel
15:32:50 <monadic_kid> EvanR: ...
15:32:55 <rickythesk8r> yes, i'm looking a codepage so i should figure this out in a minute
15:33:22 <Berengal> EvanR: What, no put pixel?
15:33:24 <EvanR> the haskell bindings let you fillrect and blit surfaces you loaded from a file
15:33:33 <rickythesk8r> http://codepad.org/Myz2fnnO
15:33:39 <monadic_kid> EvanR: you're wrong
15:33:58 <EvanR> how so
15:34:50 <EvanR> Berengal: well, you can fillrect a pixel sized rect
15:34:51 <rickythesk8r> what confuses me is the type of runSM :: S -> SM a -> (a,S) where the 2nd parameter is that do block and not a type
15:35:35 <Saizan_> rickythesk8r: that do-block is of type "SM (S,S)" so it matches SM a
15:35:46 <monadic_kid> EvanR: first of all you can trivally access/set pixel data with SDL Surfaces, 2nd vertical/horizental line drawing is trivial, lastly if you want to more complicated geometric primitives in SDL there is sdl-gfx.
15:35:47 <Saizan_> rickythesk8r: if you take a = (S,S)
15:36:10 <EvanR> monadic_kid: how do you trivially access the pixel data in a surface
15:36:17 <Saizan_> rickythesk8r: so in the end the result type will be ((S,S),S), which matches the type of the value you see as result
15:36:26 <monadic_kid> EvanR: with haskell bindings?
15:36:38 <EvanR> monadic_kid: you mean, write your own?
15:36:55 <Saizan_> rickythesk8r: runSM gives you back both the result and the final state, that's why you've the extra 1
15:37:20 <monadic_kid> Berengal: you can access/set pixel data in SDL, don't worry about that. I seriously suggest SDL for 2D games.
15:37:31 <EvanR> Berengal: yes, its great. in C
15:37:44 <Berengal> monadic_kid: Indeed, I'm looking at the documentation, and it seems possible to do
15:38:00 <EvanR> am i losing my mind? what documentation are you looking at?
15:38:01 <rickythesk8r> Saizan_: thanks; this gives me a leg up
15:38:10 <monadic_kid> EvanR: you realize you can get the pixel data in haskell, get pointer
15:38:23 <monadic_kid> EvanR: with SDL bindings
15:38:43 <EvanR> the bindings are bound to the extent you get a Foreign Ptr
15:38:56 <EvanR> what do you do with it?
15:39:19 <monadic_kid> EvanR: did you see the function surfaceGetPixels?
15:39:44 <EvanR> Surface -> IO Pixels
15:40:06 <EvanR> Pixels has no description
15:40:51 <monadic_kid> EvanR: that is exactly what you want to access pixel data, it's a pointer to data, haskell trick with empty data defintions
15:41:05 <EvanR> ok. what do you do with it?
15:41:25 <monadic_kid> somebody give me paste it bin link
15:41:28 <Berengal> The Pixels type isn't exported...
15:41:43 <EvanR> even the pixelFormat has description
15:41:45 <EvanR> no
15:42:06 <monadic_kid> trust me, somebody give me a paste bin link and i'll show you how to do it
15:42:08 <EvanR> ah it has accessors
15:42:11 <ivanm> @hpaste
15:42:11 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
15:42:24 <ivanm> monadic_kid: ^^ there you are, since you can't be bothered to find one for yourself...
15:42:37 <monadic_kid> danke
15:42:38 <Saizan_> EvanR: btw, i guess you need s/(get >>= liftIO $ draw video)/(get >>= liftIO . draw video)/ to make it typecheck?
15:42:53 <EvanR> thanks
15:42:53 <monadic_kid> it seems dead
15:43:09 <monadic_kid> basically you need to use the Storage class
15:43:10 <jlouis> hpaste.org works
15:43:11 <EvanR> :t liftIO
15:43:12 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
15:43:30 <EvanR> Saizan_: takes a IO a rather than a x -> IO a
15:44:18 <monadic_kid> EvanR, Berengal: this how you get/set a 32-bit surface: http://hpaste.org/fastcgi/hpaste.fcgi/save
15:44:27 <Saizan_> yeah, and draw video needs the extra parameter to return a IO a
15:44:37 <monadic_kid> EvanR, Berengal:  hold on a sec wrong link
15:44:44 <monadic_kid> EvanR, Berengal:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25047#a25047
15:45:19 <monadic_kid> EvanR, Berengal: 32-bit RGBA surface
15:45:27 <EvanR> pokeElemOff castPtr
15:45:46 <monadic_kid> it's a haskell trick using empty data definitions
15:45:53 <monadic_kid> data PixelData
15:46:08 <monadic_kid> data Pixels = Ptr PixelData
15:46:29 <EvanR> this would be nice to document
15:46:51 <Berengal> Even better would be to just put the functions in the library...
15:47:02 <Berengal> But it's a very low-level binding, looks like
15:47:15 <EvanR> sdl itself never needed this sort of function, you do your dirty work with c pointers
15:47:38 <EvanR> and an efficient way to do anything you want is probably not possible
15:47:47 <EvanR> i dont know if haskell should have a higher level api
15:48:29 <monadic_kid> Berengal: the reason it probably doesn't exist is because 1. it doesn't exist in SDL, 2. you have different pixel formats so you will have slighty different get/put pixel functions
15:48:56 <EvanR> so theres a graphics lib for haskell sdl?
15:49:05 <monadic_kid> ?
15:49:16 <ivanm> EvanR: I believe there are sdl bindings, yes
15:49:22 <EvanR> you said sdl_gfx, i thought you were talking about haskell
15:49:24 <ivanm> look on hackage
15:49:38 <EvanR> sdl_gfx c lib is sort of lame
15:50:36 <Berengal> Some documentation would be nice.. That one has no haddocks at all
15:50:39 <EvanR> but something that can do lines and shapes to free you from the pixel format crap would be nice
15:51:16 <monadic_kid> Berengal: you can see the source, just click on the source link where surfaceGetPixels is documentated but you need to recognize the trick
15:51:46 <IceDane>  trying to cabal install lambdabot, it complains about it needing quickcheck <2 - I installed it, it still complains. Any advice?
15:52:16 <Berengal> monadic_kid: It's just calling a c-function, so the haskell source is pretty useless
15:52:39 <monadic_kid> Berengal: i don't mean the function itself but the whole source like where Pixels is defined
15:53:08 <monadic_kid> Berengal: anyways you might be interested in this: http://github.com/snkkid/LazyFooHaskell
15:53:29 <EvanR> lazyfoo sdl tutorials are so bad
15:54:00 <monadic_kid> EvanR: not really, the mainpoint is you have examples of using SDL in haskell
15:54:11 <monadic_kid> EvanR: is that really bad?
15:54:19 <EvanR> i havent look at 'lazyfoohaskell'
15:54:51 <Berengal> monadic_kid: Yes, well, I know what the Haskell code is doing, but I don't know what the C code is doing, and using the C reference when writing Haskell is sort of weird and context-switchy
15:55:08 <EvanR> you basically have to for sdl
15:56:20 <Berengal> I should take this as an opportunity to give to the community by improving the documentation...
15:56:49 <Berengal> (But I'm so lazy I usually don't even bother with WHNF)
16:00:31 <Chaze> :t curry (+)
16:00:32 <lambdabot> forall a b. (Num (a, b)) => a -> b -> (a, b) -> (a, b)
16:00:41 <Chaze> does this function make any sense?
16:01:31 <EvanR> > (curry (+)) 2 2
16:01:32 <lambdabot>   No instance for (GHC.Num.Num (a, b))
16:01:32 <lambdabot>    arising from a use of `GHC.Num.+' a...
16:01:34 <dibblego> do you have an instance Num for (a, b) ?
16:01:39 <EvanR> > (curry (+)) 2 2 (2,2)
16:01:40 <lambdabot>   No instance for (GHC.Num.Num (a, b))
16:01:40 <lambdabot>    arising from a use of `GHC.Num.+' a...
16:01:42 <ivanm> > curry (+) 2 3 (4,5)
16:01:43 <lambdabot>   No instance for (GHC.Num.Num (a, b))
16:01:43 <lambdabot>    arising from a use of `GHC.Num.+' a...
16:01:54 <ivanm> oh, wait, it doesn't
16:01:54 <Chaze> ivanm: that's what i tried
16:01:58 <ivanm> because of "Num (a,b)"
16:01:58 <jbapple> > :t uncurry (+)
16:01:59 <lambdabot>   <no location info>: parse error on input `:'
16:02:06 <jbapple> :t uncurry (+)
16:02:07 <lambdabot> forall a. (Num a) => (a, a) -> a
16:02:10 <Chaze> what would Num(a,b) be?
16:02:27 <ivanm> so, if you define instance (Num a, Num b) => Num (a,b)  then it would
16:02:40 <ivanm> but I think most of the class methods won't make sense for it
16:02:43 <ivanm> @src Num
16:02:43 <lambdabot> class  (Eq a, Show a) => Num a  where
16:02:43 <lambdabot>     (+), (-), (*)           :: a -> a -> a
16:02:43 <lambdabot>     negate, abs, signum     :: a -> a
16:02:43 <lambdabot>     fromInteger             :: Integer -> a
16:02:59 <ivanm> fromInteger definitely doesn't; the rest you can do piecewise I suppose...
16:03:00 <EvanR> > 5 `flip evalStateT` (return 2)
16:03:01 <lambdabot>   <no location info>: parse error on input `evalStateT'
16:03:08 <ivanm> but that then breaks the point of signum :s
16:04:02 <EvanR> > 5 `(flip evalStateT)` (return 2)
16:04:03 <lambdabot>   <no location info>: parse error on input `('
16:08:55 <brad_larsen> Regarding implementation of type classes:  do any implementations do something other than dictionary passing?
16:09:08 <mauke> yeah, jhc
16:09:29 <brad_larsen> mauke: what does jhc do?
16:09:47 <mauke> I don't really remember
16:09:57 <brad_larsen> ok
16:10:04 <brad_larsen> just pondering
16:11:06 <brad_larsen> I wonder, under what conditions can ghc *not* statically resolve type class instances?
16:11:33 <brad_larsen> existential types, GADTs, separately compiled modules?
16:12:21 <c_wraith> when the specific instance never leaks
16:12:32 <c_wraith> :t newListArray
16:12:33 <lambdabot> Not in scope: `newListArray'
16:12:57 <mauke> > let f :: (Show a) => Int -> a -> String; f n x = if n <= 0 then show x else f (n - 1) (x, x) in f 2 'x'
16:12:58 <lambdabot>   "(('x','x'),('x','x'))"
16:13:28 <EvanR> spooky
16:13:36 <c_wraith> @hoogle newListArray
16:13:36 <lambdabot> Data.Array.MArray newListArray :: (MArray a e m, Ix i) => (i, i) -> [e] -> m (a i e)
16:13:43 <c_wraith> yeah, hat one.
16:13:49 <c_wraith> err, *that
16:14:05 <mauke> > let f :: (Show a) => Int -> a -> String; f n x = if n <= 0 then show x else f (n - 1) (x, x) in f 4 'x'
16:14:06 <lambdabot>   "(((('x','x'),('x','x')),(('x','x'),('x','x'))),((('x','x'),('x','x')),(('x...
16:14:13 <brad_larsen> you are saying that newListArray might not be able to have the instances statically resolved?
16:14:18 <c_wraith> I've written code where GHC has failed to derive the type of a in newListAray
16:14:23 <c_wraith> err, newListArray
16:15:10 <brad_larsen> you must have been using it in a more complex expression, then, where the `a' doesn't show up in the result type.  right?
16:15:29 <brad_larsen> in which case the instance `doesn't leak'.
16:15:38 <c_wraith> right.
16:15:44 <c_wraith> The a never did show up in the result type
16:16:05 <c_wraith> I only ever used typeclass methods
16:16:16 <brad_larsen> and so ghc gives you an `ambiguous type variable' error, right?
16:16:34 <brad_larsen> like read . show
16:16:43 <c_wraith> if you want to play with it:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25048#a25048
16:16:48 <jon_of_arc> Any recommendations for approaches to cleanly evaluate functions on a node in a parse tree that need access to the parent node? I'm hoping there's some way to extract the tying-the-knot that my current approach requires everywhere.
16:16:57 <c_wraith> I ended up using scoped type variables to help *resolve* the ambiguity
16:17:40 <c_wraith> Because I wouldn't have been able to give it the type signature in the way I did without the ScopedTypeVariables extension
16:17:51 <brad_larsen> c_wraith: yes, i see
16:17:53 <c_wraith> But ghc couldn't derive that statically
16:18:44 <brad_larsen> c_wraith: it seems like the cases you are talking about are ones that would result in `ambiguous type' errors
16:19:10 <brad_larsen> c_wraith: I am wondering about cases where it is not an error, but ghc cannot determine which specific instance is used
16:19:16 <IceDane> Any easy way to find the index of a substring inside a string?
16:19:27 <brad_larsen> c_wraith: and has to reify the dictionary
16:20:02 <c_wraith> Hmm.  I guess that applies at module boundaries.
16:20:12 <brad_larsen> c_wraith: or in other words, in what cases can ghc not optimize away dictionary passing?
16:20:17 <brad_larsen> i would imagine so
16:20:26 <Berengal> brad_larsen: Whenever a constrained function is exported, for one thing. GHC does separate compilation.
16:21:53 <c_wraith> Note that the specialize pragma can be used to force ghc to generate code specifically for particular types that you want to optimize for.
16:21:55 <brad_larsen> Berengal: right.  But if you {-# INLINE #-} the function, then the dictionary passing could possibly be optimized away?
16:22:19 <Berengal> brad_larsen: Yes, or {-# SPECIALIZE #-} as noted above
16:22:40 <Berengal> Not sure about mauke's function yet...
16:22:44 <EvanR> IceDane: Data.List ?
16:23:55 <EvanR> :t scanl
16:23:56 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
16:24:05 <EvanR> i cant seem to get the docs atm
16:24:27 <c_wraith> scanl is a fold that shows intermediate values
16:24:53 <brad_larsen> A GADT whose constructors involve type constraints probably makes this `dictionary elimination' (not sure what it's called) much harder
16:25:04 <c_wraith> > fix $ (0:) . scanl (+) 1 -- everyone's favorite scanl example
16:25:05 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
16:25:31 <IceDane> wait wat o_I
16:25:38 <Makoryu> Huhuhuhuhu
16:26:25 <c_wraith> or was that everyone's favorite fix example?  I can never recall...
16:26:49 <olsner> my favorite fix example is a different one
16:27:06 <Twey> > scanl (*) 1
16:27:07 <lambdabot>   []->
16:27:07 <lambdabot>    [1]
16:27:07 <lambdabot>  [-2]->
16:27:07 <lambdabot>    [1,-2]
16:27:07 <lambdabot>  [-2,-1]->
16:27:09 <lambdabot> [3 @more lines]
16:27:14 <Twey> Err
16:27:16 <Twey> > scanl (*) 1 [1 ..]
16:27:17 <lambdabot>   [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800...
16:27:29 <Twey> That's got to be everyone's favourite scanl :Ã¾
16:27:51 <Berengal> > scanl1 (*) [1..]
16:27:52 <lambdabot>   [1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,8...
16:27:53 <brad_larsen> how about a good mfix example?  (I've never gotten around to reading the papers about it...)
16:29:13 <olsner> there was an article in TMR about using mfix for writing assembly code (specifically, to allow using labels before their definition)
16:30:18 <gwern> using harpy?
16:31:30 <olsner> no, I think it was using a small made-up assembly language instead
16:34:49 <kynky> masm?
16:35:03 <aavogt> @google awesomeprelude
16:35:04 <lambdabot> http://github.com/tomlokhorst/AwesomePrelude
16:35:04 <lambdabot> Title: tomlokhorst's AwesomePrelude at master - GitHub
16:38:53 <olsner> hmm, awesomeprelude adds additional type class parameters to the entire Functor/Applicative/Monad hierarchy
16:40:29 <Saizan_> class Functor j f where map :: (j a -> j b) -> j (f a) -> j (f b) <- doesn't look too awesome!
16:40:55 <Saizan_> it could have parametrized (->) away instead
16:43:33 <byorgey> it's for abstracting over typed ASTs
16:44:11 <byorgey> so j is the type of the AST, indexed by the type it 'represents'
16:45:00 <byorgey> it's explained well in the video of their talk at Dutch HUG
16:45:17 <Saizan_> ah, i see, i forgot that the package is mostly geared towards EDSLs
16:45:36 <byorgey> yeah, it's not really supposed to be a general-purpose Prelude replacement
16:46:24 <byorgey> the title notwithstanding.
16:49:02 <EvanR> ghci is awesome
16:49:38 <EvanR> i can test all my shit, even IO and stuff that uses foreign libs
16:50:06 <EvanR> i just found out how to store stuff in variables ;)
16:50:25 <Saizan_> let and <- ?
16:50:30 <EvanR> yeah
16:50:40 <EvanR> before i wrote entire expressions like they do in the channel ;)
16:50:44 <EvanR> on one line
16:52:26 <Saizan_> i feel claustrofobic when i write longish pipelines at the ghci prompt, i think i'd like a rectangular buffer instead
16:52:40 <IceDane> Saizan_: /agree
16:53:22 <EvanR> rectangular buffer?
16:54:00 <IceDane> EvanR: so that expressions continue on the line below, from the left, instead of to the right
16:54:29 <Saizan_> something like an emacs buffer
16:54:59 <EvanR> the expression doesnt continue on the left, on the line below
16:55:04 <EvanR> does**
16:56:01 <IceDane> EvanR: What do you mean?
16:56:16 <EvanR> a long expression wraps around
16:56:26 <IceDane> If you write an expression that goes 'further than the borders of your terminal', it scrolls to the left
16:56:27 <Makoryu> EvanR: A rectangular buffer is one with multiple lines.
16:56:37 <monochrom> Like Pidgin and possibly other good quality IM software. When you type more, the input box grows in height.
16:56:39 <EvanR> it does not scroll to the left on my term
16:57:04 <EvanR> it continues on the next line
16:57:25 <monochrom> Everything you're typing is shown completely, no scrolling needed to view "the rest".
16:57:33 <ddarius> Saizan_: See the :{ and :} commands.
16:58:01 <monochrom> The :{ and :} commands do not let you go to a previous line and edit.
16:58:13 <EvanR> IceDane: what terminal is that
16:58:16 <ddarius> monochrom: Stop making mistakes.
16:59:02 <IceDane> EvanR: The term I'm using?
16:59:04 <IceDane> urxvt
16:59:10 <Saizan_> i think after the fact editing is what i really miss :)
16:59:11 <EvanR> in xterm i get no scrolling behavior
16:59:23 <IceDane> But for the record, in a normal terminal session it's multiline
16:59:32 <IceDane> Does your ghci session support end, home and so on?
16:59:42 <Makoryu> I like how Lisp folks pooh-pooh ghci for not having the same level of support for interactive programming as the console/image system... And then when you ask how you should go about writing a program interactively, they tell you not to do that, and that instead the best practice is to put all your code in a file and reload the file when you change something
17:00:07 <EvanR> IceDane: end and home go to the beginning and end of your input, possibly skipping lines
17:00:18 <ddarius> Makoryu: The Lisp people are right, as are the ML people.
17:00:44 <IceDane> EvanR: Not for me, for some reason
17:00:48 <IceDane> normally, but not in ghci
17:01:11 <EvanR> term conf issu
17:01:20 <EvanR> or ghci version
17:02:14 <johnw> Makoryu: yeah, been there too
17:02:32 <johnw> "You don't want to do that" is a familiar Lisp refrain
17:03:12 <ddarius> It's probably even more familiar here.
17:03:25 <blackdog> ddarius: How do I do OO in Haskell?
17:03:46 <EvanR> with existentials ;)
17:04:11 <dancor> can't you do oo by putting one typeclass per module
17:04:17 <monochrom> My car is superior to yours because both front seats are equipped to be driver seats. "Oh but what if traffic police sees you driving in the wrong seat?" you ask. Answer: Don't do that!
17:04:43 <dancor> the module is the class
17:04:47 <blackdog> the correct answer is "these are not the programming paradigms you are looking for"
17:05:17 <ddarius> Some of the ideas associated with and (arguably) distinctive of OO are quite sound.
17:05:17 <DigitalKiwi> aww i missed a bunch of what is probably an interesting conversation :(
17:05:34 <DigitalKiwi> haskell code is so short you don't even need OO! :P
17:08:34 <EvanR> DigitalKiwi: what are you talking about, everythings an object
17:09:26 <gwern> objects are a oor man's closure
17:09:26 <DigitalKiwi> when did we start talking about ruby
17:09:26 <monochrom> everything is a subject too.
17:09:27 <EvanR> subject oriented
17:09:35 <ddarius> There is subject-oriented programming.
17:09:39 * EvanR trademarks
17:09:48 <Adamant> SVO, SOV, VOS
17:10:03 <DigitalKiwi> http://en.wikipedia.org/wiki/Subject_oriented_programming
17:10:12 <EvanR> you missed OSV OVS and VSO
17:10:36 * monochrom goes on to invent adverb-phrase-oriented-programming
17:10:47 <gwern> monochrom: souds like aspect-oriented programming
17:10:49 <DigitalKiwi> aren't there 2 more?
17:11:15 <gwern> DigitalKiwi: in grammar, there's as many as you want because it's a fake subject
17:11:16 <monochrom> > 3*2*1
17:11:17 <lambdabot>   6
17:11:17 <DigitalKiwi> or is it more hmm
17:11:22 * Makoryu is just waiting for polysynthesis-oriented programming
17:11:30 <gwern> it's like saying, aren't there a couple more kinds of angels?
17:13:27 <EvanR> group S3
17:13:27 <Makoryu> gwern: A fake subject, eh?
17:13:27 <gwern> Makoryu: sure. physicists can be bopped over the head when they propose useless new particles or forces. what do you do with a grammarian?
17:13:27 <Makoryu> gwern: Burn him at the stake for linguistic prescriptivism
17:13:27 <gwern> :)
17:14:45 <BMeph> Sounds wasteful; you should build a bridge with him instead... ;þ
17:14:45 <DigitalKiwi> lawl
17:14:45 <DigitalKiwi> <3 monty python and the holy grail
17:15:25 * BMeph goes on to claim supreme executive power, because some watery tart threw him a sword...
17:15:35 <DigitalKiwi> ivanm: are you here?
17:15:40 <ivanm> yeah
17:15:45 <DigitalKiwi> =D
17:15:47 <DigitalKiwi> guess what
17:16:02 <ivanm> what?
17:16:08 <ivanm> the lecturer is making the assignment easier?
17:16:21 <DigitalKiwi> http://bbs.archlinux.org/viewtopic.php?pid=749268#p749268
17:17:04 <DigitalKiwi> http://pasteit.ghost1227.com/2903
17:17:05 <DigitalKiwi> =D
17:17:17 <ivanm> heh
17:17:23 <ivanm> what was wrong with the pseudocode?
17:17:50 <ivanm> also, what you had didn't look like RPN...
17:18:11 <DigitalKiwi> some prints in the wrong spots in various functions, construct_tree is just foobarred
17:18:16 <ivanm> oh, wait, it converts it to pseudocode?
17:18:24 <DigitalKiwi> ?
17:18:37 <ivanm> s/pseudocode/RPN/
17:18:44 <DigitalKiwi> you give it an infix and the postorder traversal produces postfix
17:18:56 <ivanm> DigitalKiwi: which makes it even better for you, since if it took you that long to work it out the other students definitely wont' get it (thus giving you a better grade)? :p
17:19:07 <DigitalKiwi> hehe
17:19:12 <ivanm> DigitalKiwi: slight bug: you have "5 4" instead of "54"
17:19:28 <ivanm> you obviously aren't joining digits together in your stack
17:19:45 <DigitalKiwi> the correct output is 5 4
17:19:57 <DigitalKiwi> str = "((5+4)+(3/(4$(3-(9/8)))))"
17:20:01 <ivanm> duh, RPN
17:20:05 * ivanm facepalms
17:20:18 <ivanm> DigitalKiwi: so what does the input look like?
17:20:23 <DigitalKiwi> like str
17:20:33 <Gracenotes> oh damn it, I keep on forgetting that mod in C++ doesn't handle negatives like mathematical mod does
17:20:37 <Gracenotes> you've spoiled me, Haskell
17:21:41 <Gracenotes> that was an annoying bug, too
17:22:24 <ivanm> DigitalKiwi: so, do you get any extra credit?
17:22:28 <EvanR> > (-5) `mod` 3
17:22:29 <lambdabot>   1
17:22:32 <ivanm> Gracenotes: wtf? :o
17:22:38 <DigitalKiwi> i dunno why i would need it >.>
17:22:50 <ivanm> because you did extra work?
17:22:58 <ivanm> DigitalKiwi: and what do you mean "like str"?
17:23:03 <DigitalKiwi> 19:19 < DigitalKiwi> str = "((5+4)+(3/(4$(3-(9/8)))))"
17:23:06 <Gracenotes> ivanm: :o ??
17:23:07 <ivanm> I'm just wondering what input gave you that output
17:23:10 <ivanm> oh, missed that
17:23:12 <ivanm> duh
17:23:14 <DigitalKiwi> ;p
17:23:24 <ivanm> Gracenotes: that C++ doesn't do mod properly
17:23:43 <EvanR> > (-5) `rem` 3
17:23:43 <ivanm> DigitalKiwi: what does $ do?
17:23:43 <lambdabot>   -2
17:23:46 <Gracenotes> same in C, Java, etc. We call it rem
17:23:50 <DigitalKiwi> i only have like two changes to make, make it read the str from stdin, and make it write to file
17:23:56 <DigitalKiwi> $ is exponentiation
17:24:17 <ivanm> ahhh
17:24:20 <EvanR> now for the shocker
17:24:27 <EvanR> > 5 `mod` (-3)
17:24:28 <lambdabot>   -1
17:24:30 <EvanR> :o
17:24:34 <ivanm> is it meant to be optional where input/output come from?
17:24:54 <EvanR> > 5 `rem` (-3)
17:24:55 <lambdabot>   2
17:25:01 <Gracenotes> ivanm: the fix: if you know that it can only go to the range -n to infinity, replace x % n with (x+n)%n
17:27:04 <jsilver> can you write anything in haskell?
17:27:10 <gwern> no
17:27:13 <DigitalKiwi> I cannot write any haskell
17:27:16 <gwern> it's purely theoretical
17:27:38 <gwern> if anyone told you that real programs can and have been written in haskell, they are unscrupulous promoters
17:27:41 <EvanR> you can read anything in haskell
17:28:15 <tensorpudding> What do you mean by writing anything?
17:29:00 <jsilver> can i write a web application or a desktop application in haskell
17:29:04 <jsilver> or am i totally getting it all wrong
17:29:05 <Axman6> yes
17:29:15 <Makoryu> jsilver: You can write anything in Haskell that you'd be able to write in C++ or Java. Now, there are cases where it wouldn't be a good idea to write certain things, but it's still possible.
17:29:22 <DigitalKiwi> @faq can you write anything in haskell?
17:29:23 <lambdabot> The answer is: Yes! Haskell can do that.
17:29:35 <EvanR> question about memory leaks http://codepad.org/wyp7p2KT
17:29:36 <jsilver> what should I write
17:29:43 <jsilver> what shouldn't* I write
17:29:44 <jsilver> sorry
17:29:44 <EvanR> will "start" be collected eventually?
17:29:45 <Axman6> everything
17:30:38 <monochrom> > ()
17:30:38 <lambdabot>   ()
17:30:41 <tensorpudding> Haskell's got libraries for things, but not everything.
17:30:47 <monochrom> There, I have just written anything in Haskell.
17:31:12 <Makoryu> jsilver: I would not like to write very low-level kernel code in Haskell (for example, drivers). But there are even some DSLs for writing a Haskell program to verify and generate that kind of code....
17:31:18 <ivanm> hey Axman6
17:31:25 <Axman6> Makoryu: others would, and have
17:31:29 <jsilver> interesting
17:31:32 <Makoryu> Axman6: I know
17:31:33 <ivanm> which part of sydney were you thinking of staying? closer to the CBD?
17:31:59 <Axman6> no idea
17:32:11 <Axman6> we haven't looked into it yet
17:32:13 <Makoryu> Axman6: I'm just paranoid about memory usage in very low-level code, to the point that I would never rely on a GC
17:32:27 <Axman6> pfft
17:32:45 <ivanm> Axman6: well, there are places with rooms for about $100/night twin share near UNSW available now (for that weekend at least)
17:32:58 <Axman6> link?
17:32:59 <ivanm> Makoryu: I would think that timing would be a bigger thing than memory usage
17:33:12 <ivanm> because you never know when the GC will kick in
17:33:15 <mamalujo> http://www.galois.com/~lerkok/techSeminarSlides/KernelModulesInHaskell.pdf
17:33:18 <ivanm> Axman6: wotif ;-)
17:33:26 <EvanR> real time gc
17:33:27 <Axman6> -_-
17:33:29 <DigitalKiwi> Trust in the GC!
17:33:31 <Makoryu> ivanm: I said "memory usage"... I should have said "everything having to do with memory"
17:33:37 <ivanm> Makoryu: right
17:33:42 <ivanm> Axman6: don't recall them, sorry
17:33:46 <DigitalKiwi> In garbage collectors we trust
17:33:54 <ManateeLazyCat> @seen igloo
17:33:54 <ManateeLazyCat> @preflex seen igloo
17:33:55 <lambdabot> Unknown command, try @list
17:33:55 <lambdabot> Unknown command, try @list
17:34:16 <ManateeLazyCat> Who change lambdabot? I always forgot command.
17:34:19 <tensorpudding> preflex: seen igloo
17:34:19 <preflex>  igloo was last seen on #ghc 6 hours, 17 minutes and 10 seconds ago, saying: * igloo had misunderstood the HP webpage then, that's all
17:34:24 <gwern> preflex: seen igloo
17:34:25 <preflex>  igloo was last seen on #ghc 6 hours, 17 minutes and 16 seconds ago, saying: * igloo had misunderstood the HP webpage then, that's all
17:34:42 <ManateeLazyCat> Ok, i found a bug of System.Directory
17:35:11 * Axman6 doubts that
17:35:18 <Axman6> what's the bug?
17:35:33 <ManateeLazyCat> Axman6: Unicode.
17:35:42 <ManateeLazyCat> Axman6: System.Directory just use peekCString
17:35:44 <gwern> figures
17:35:58 <ManateeLazyCat> Axman6: But it's wrong with UTF-8
17:36:50 <ivanm> ManateeLazyCat: I believe that someone (ndm?) already complained to -cafe about that
17:36:58 <EvanR> :t lift
17:36:59 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
17:37:03 <ManateeLazyCat> ivanm: Wait
17:37:06 <ivanm> ManateeLazyCat: it isn't meant to be UTF-8 though, because on unix its a sequence of bytes and not encoded IIRC
17:37:21 <ivanm> well, that was with System.Process but it's probably the same thing
17:38:02 <ManateeLazyCat> ivanm: http://code.haskell.org/gtk2hs/glib/System/Glib/
17:38:06 <EvanR> lift is a function which takes any monadic value can embeds it within a value appropriate for any monad transformer
17:38:11 <EvanR> s/can/and/
17:38:12 <ManateeLazyCat> ivanm: Look UTFString.chs
17:38:23 <ManateeLazyCat> ivanm: We use peekUTFString in Gtk+ binding.
17:38:41 <ivanm> ManateeLazyCat: ... so?
17:38:49 <ivanm> what does that have to do with System.Directory?
17:39:03 <ManateeLazyCat> ivanm: So we should peekUTFString instead peekCString.
17:39:03 <ivanm> (and on who's right or wrong)
17:39:28 <jsilver> wow guys, haskell is f*ckin awesome, thanks - a ruby guy
17:39:30 <ManateeLazyCat> peekUTFString strPtr = liftM fromUTF $ peekCString strPtr
17:39:33 <ivanm> ahhh, it was CosmicRay
17:39:38 <winxordie> anyone know what haskell on steroids is/was?
17:39:41 <Axman6> jsilver: why do you say that?
17:39:53 <jsilver> * being a function
17:39:58 <jsilver> blowing my mind here
17:40:04 <winxordie> jsilver: check out hubris sometime
17:40:09 <gwern> ManateeLazyCat: what's the downside of that?
17:40:11 <EvanR> haha
17:40:17 <jsilver> similar to Ruby in a way
17:40:19 * hackagebot parsimony 1.0.1 - Monadic parser combinators derived from Parsec  http://hackage.haskell.org/package/parsimony-1.0.1 (IavorDiatchki)
17:40:22 <ivanm> ManateeLazyCat: http://comments.gmane.org/gmane.comp.lang.haskell.cafe/73747
17:40:23 <jsilver> + is a method on object Fixnum
17:40:30 <Axman6> jsilver: * is always a function
17:40:34 <ivanm> winxordie: a cheating language
17:40:35 <ivanm> ;-)
17:40:36 <Axman6> everywhere
17:41:00 <winxordie> ivanm: Moar detail please
17:41:01 <ivanm> Axman6: unless you do and explicit import of Prelude hiding it...
17:41:05 <EvanR> * may have the side effect of setting overflow flags in the computer ;)
17:41:13 <ivanm> winxordie: athletes use steroids to cheat...
17:41:29 <gwern> EvanR: only if there are incorrect optimizations
17:41:34 <gwern> Int considered harmful!
17:41:35 * ivanm actually has no idea what winxordie is talking about
17:41:36 <monochrom> The idiom "x on steroid" does not connote cheating.
17:42:08 <ivanm> monochrom: yet when you have "athlete on steroids" they are stripped of their medal and banned...
17:42:28 <winxordie> ivanm: if you look at http://pleac.sourceforge.net/ you'll see entries for "haskell" and "haskell on steroids"
17:42:31 <monochrom> That is confined to athletes.
17:42:39 <ManateeLazyCat> ivanm: I think peekUTFString is right way.
17:43:19 <Axman6> jsilver: if you find (*) being amazing, wait until you actually start learning haskell ;)
17:43:19 <gwern> ManateeLazyCat: is pekUTFString really always correct? are there no issues with other locales?
17:43:34 <jsilver> im learning
17:43:44 <jsilver> i wanna get to the hard stuff
17:43:44 <winxordie> now unless someone made a language called haskell on steroids just for the lols, I'd assume that "haskell on steroids" actually means something non-trivial
17:43:57 <ManateeLazyCat> ivanm: Yes, we have test many functions in Gtk2hs.
17:43:58 <ivanm> ManateeLazyCat: that's one opinion; check on the libraries list first before saying that System.DIrectory is "wrong" as there might be a reason why it has that behaviour
17:43:59 <EvanR> jsilver: yeah, not only that... but... + is also a function:)
17:44:02 <ivanm> gwern: exactly
17:44:05 <jsilver> i get that
17:44:07 <jsilver> ;)
17:44:09 <gwern> there's ghci on acid
17:44:19 <ivanm> ManateeLazyCat: on _your_ machines in controlled environments
17:44:32 <Axman6> jsilver: start with the easy stuff
17:44:39 <winxordie> *bangs head on counter* Ghci on acid. Clever.
17:44:42 <Axman6> jsilver: what are you using to learn haskell?
17:44:51 <ManateeLazyCat> ivanm: Well, from user's viewport, if result is wrong, it's "wrong"
17:44:58 <ivanm> winxordie: I'm guessing that it's just someone wanting to do "advanced haskell" or something
17:45:00 <gwern> winxordie: goa
17:45:02 <ddarius> winxordie: Someone made a completely non-idiomatic library/redefinings to make the code look more like ruby because, I'm assuming, they suffer from brain damage.
17:45:09 <ivanm> ManateeLazyCat: my point is, maybe _you're_ wrong
17:45:15 <jsilver> Axman6, learnyouagoodhaskell.com
17:45:19 <gwern> let's point him at some oleg stuff, and after his head explodes, he'll start over at the beginning
17:45:27 <jsilver> yeah
17:45:31 <ivanm> jsilver: you sure that's right?
17:45:33 <jsilver> point me to hardest shit please
17:45:37 <ivanm> isn't it LYAH, not LYAGH?
17:45:37 <Axman6> @remember ddarius Someone made a completely non-idiomatic library/redefinings to make the code look more like ruby because, I'm assuming, they suffer from brain damage.
17:45:38 <lambdabot> Good to know.
17:45:39 <jsilver> learnyouahaskell.com ?
17:45:40 <ManateeLazyCat> ivanm: Are you use UTF8?
17:45:44 <gwern> @where lyah
17:45:44 <lambdabot> http://www.learnyouahaskell.com/
17:45:49 <ivanm> jsilver: someone that's constipated
17:45:53 <ivanm> ManateeLazyCat: yes, but not everyone does
17:45:58 <ivanm> @where LYAH
17:45:59 <lambdabot> http://www.learnyouahaskell.com/
17:46:01 <ivanm> jsilver: ^^
17:46:04 <winxordie> lol, alright
17:46:07 <jsilver> oh
17:46:13 <jsilver> can i use that
17:46:16 <jsilver> @where LYAH
17:46:16 <lambdabot> http://www.learnyouahaskell.com/
17:46:18 <jsilver> ok
17:46:19 <jsilver> lol
17:46:21 <Axman6> no!
17:46:30 <jsilver> i think yes
17:46:31 <ivanm> winxordie: http://ircanswers.com/haskell/87471/also-haskell-on-steroids-except-optimized-hell
17:46:42 <gwern> you're such a lyah
17:46:45 <ManateeLazyCat> ivanm: getDirectoryContents works well with UTF8? In your machine?
17:46:53 <jsilver> can i see a complicated multiline haskell program now
17:47:00 <monochrom> I like ivanm's interpretation of "hardest shit" :)
17:47:01 <gwern> @where hackage
17:47:01 <lambdabot> http://hackage.haskell.org/package/
17:47:14 <ivanm> monochrom: thank you, I'm here all day
17:47:21 <Axman6> jsilver: why don't you contimue the tutorial, and then write one?
17:47:34 <jsilver> nice nice
17:47:42 <Axman6> @src map
17:47:42 <lambdabot> map _ []     = []
17:47:42 <lambdabot> map f (x:xs) = f x : map f xs
17:47:49 <DigitalKiwi> can anyone tell me about ghcs compile to C feature or whatever it is
17:47:52 <ManateeLazyCat> ivanm: If getDirectoryContents can work well in your machine, maybe i'm wrong.
17:47:52 <EvanR> protip, use burritos to make it more clear
17:47:54 <Axman6> that's complicated
17:48:03 <monochrom> ghc -via-C IIRC
17:48:04 <tensorpudding> Damn I want burritoes now...
17:48:09 <EvanR> me too
17:48:20 <winxordie> thanks ivanm
17:48:24 <monochrom> I'm missing another option.
17:48:31 <Axman6> -fvia-C
17:48:52 <winxordie> though "pure executable category theory" could mean anything. ;)
17:49:39 <ivanm> ManateeLazyCat: it doesn't show non-ASCII properly, but as I've already said there seems to be a good reason why it doesn't do so
17:49:44 <monochrom> ghc -fvia-C -C  then look for *.hc files and have fun heart-attacking and/or stroking
17:50:55 <monochrom> in fact if you -C you may omit -fvia-C
17:51:14 <ManateeLazyCat> ivanm: So i need encode result?
17:51:24 <ivanm> monochrom: that sounds suspiciously close to a "Yo Dawg" meme...
17:51:46 <monochrom> hahahaha
17:52:29 <ivanm> ManateeLazyCat: http://comments.gmane.org/gmane.comp.lang.haskell.cafe/73747
17:52:37 <monochrom> co-yo-dawg because it omits rather than adds :)
17:52:57 <ivanm> ManateeLazyCat: what you're saying _might_ be right, but let's wait until the people that know better say whether it is or not
17:53:06 <ivanm> monochrom: I think we can shorten that to just "co-dawg"
17:53:24 <I_LIVE> what's wrong: (\xs -> read xs :: Int) "123"
17:53:39 <Axman6> > (\xs -> read xs :: Int) "123"
17:53:40 <lambdabot>   123
17:53:44 <Axman6> nothing
17:54:01 <ivanm> except that you probably don't want to do that for many values in production
17:54:06 <tensorpudding> > read "123" :: Int
17:54:06 <ManateeLazyCat> ivanm: Can we use UTF8 always, I mean use peekUTFString, then we always got right result.
17:54:07 <lambdabot>   123
17:54:14 <ivanm> ManateeLazyCat: I don't know
17:54:18 <ivanm> that's what I'm saying
17:54:22 <monochrom> Co dawg, we heard you like records so we put record puns so you can omit field names while you name fields.
17:54:34 <ivanm> so you should _ask_ on the libraries list or something without just saying that you're right and System.Directory is wrong
17:54:47 <ivanm> @remember monochrom Co dawg, we heard you like records so we put record puns so you can omit field names while you name fields.
17:54:47 <lambdabot> Nice!
17:54:54 <ivanm> preflex: seen jfreddet
17:54:54 <preflex>  Sorry, I haven't seen jfreddet
17:55:01 <ManateeLazyCat> ivanm: Thanks. :)
17:55:02 <ivanm> did I misspell his nick?
17:55:12 <ivanm> ManateeLazyCat: pretty sure I said that earlier though...
17:55:16 <I_LIVE> what's wrong: (\x->x*x) . (\xs -> read xs :: Int) "123"
17:55:29 <I_LIVE> > (\x->x*x) . (\xs -> read xs :: Int) "123"
17:55:30 <lambdabot>   Couldn't match expected type `f a'
17:55:30 <lambdabot>         against inferred type `GHC.Types...
17:55:31 <ivanm> I_LIVE: bad function application
17:55:35 <ivanm> you need a $ there
17:55:43 <ivanm> > (\x->x*x) . (\xs -> read xs :: Int) $ "123"
17:55:44 <lambdabot>   15129
17:55:48 <mauke> I_LIVE: precedence
17:55:49 <I_LIVE> i know using $ suceeds
17:55:50 <DigitalKiwi> i more meant like what happens when you do it and why you should/n't do it than specificaly how to do it via cli options ;p
17:55:50 <Axman6> > (\x->x*x) . (\xs -> read xs :: Int) $ "123"
17:55:51 <lambdabot>   15129
17:55:53 <monochrom> preflex: seen jfredett
17:55:54 <preflex>  jfredett was last seen on #haskell-blah 47 days, 16 hours, 30 minutes and 42 seconds ago, saying: and with that, I bid Adeiu to you, fair Haskellians, I go now to sleep.
17:56:11 <mauke> I_LIVE: a . b c is a . (b c), not (a . b) c
17:56:19 <monochrom> I used HWN to look up jfredett's spelling.
17:56:22 <Makoryu> > ((\x -> x * x) . (\xs -> read xs :: Int)) "123"
17:56:23 <lambdabot>   15129
17:56:24 <ivanm> I_LIVE: without the $, it thinks that everything after the `.' is the function
17:56:26 <ivanm> which it isn't
17:56:27 <Makoryu> @I_LIVE
17:56:27 <lambdabot> Unknown command, try @list
17:56:31 <Axman6> I_LIVE: (\x->x*x) . (\xs -> read xs :: Int) "123" is (\x->x*x) . ((\xs -> read xs :: Int) "123"), not ((\x->x*x) . (\xs -> read xs :: Int)) "123"
17:56:39 <ivanm> monochrom: aha
17:56:42 <scott__> Why can't I use this function signature?: foo :: Map String ([Expr] -> Expr) = ...
17:56:43 <I_LIVE> thanks
17:56:48 * ivanm wants his HWN fix!
17:56:48 <ddarius> ivanm: Yes, you did mispell it.
17:56:55 <I_LIVE> is there a tool which produces AST given haskell source?
17:56:56 <ivanm> yeah, I noticed
17:57:00 <Makoryu> I_LIVE: Function application (foo bar) has the highest precedence
17:57:06 <ivanm> I_LIVE: haskell-src-exts?
17:57:10 <Axman6> scott__: you have an = sign after a type declaration
17:57:21 <scott__> XD
17:57:24 <monochrom> This doesn't fare well. He is like Sleeping Beauty. Could some handsome prince go kiss him? Pretty please?
17:57:28 <scott__> Whoops
17:57:29 <I_LIVE> what's wrong with a.(b c) ?
17:57:36 <scott__> I meant to have that be the definition!
17:57:47 <Axman6> :t (.)
17:57:48 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:57:49 <Makoryu> I_LIVE: Nothing is wrong with it, so long as that's what you mean
17:57:52 <scott__> My brain merged the signature and definition into one!
17:57:54 <mauke> I_LIVE: nothing but read "123" is 123, not a function
17:57:54 <ivanm> monochrom: methinks the CCC strip about this has come true, except for the girlfriend/wife offering the position out...
17:57:59 <Axman6> I_LIVE: both arguments to (.) need to be functions
17:58:02 <Makoryu> I_LIVE: But (.) always returns a function
17:58:17 <ivanm> monochrom: IIRC, he's apparently busy with uni atm
17:58:24 <Makoryu> @unlet
17:58:24 <lambdabot>  Defined.
17:58:26 <Makoryu> :t (.)
17:58:27 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:58:28 <I_LIVE> so as long compiler figures that some expr is constant, it refuses to produce function?
17:58:30 <Makoryu> Huh
17:58:31 <Axman6> god damn it Cale!
17:58:41 <mauke> I_LIVE: what?
17:58:45 <Axman6> I_LIVE: constants aren't functions
17:58:47 <ddarius> :t flip -- Axman6
17:58:48 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
17:58:56 <mauke> Axman6: what
17:59:06 <Axman6> well, in the sense he means
17:59:21 <Makoryu> I_LIVE: No, see, (\xs -> read xs :: Int) does not return a function.
17:59:26 <Makoryu> I_LIVE: It returns an Int
17:59:40 <Makoryu> And (.) expects two functions and returns another function
17:59:56 <mauke> :t (P..)
17:59:57 <lambdabot> Couldn't find qualified module.
18:00:04 <Makoryu> :t (Prelude..)
18:00:05 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
18:00:44 <I_LIVE> Makoryu O_O. But (\xs -> read xs :: Int) is THE definition of function string->int
18:01:11 <Axman6> I_LIVE: yes, but "(\xs -> read xs :: Int) "123") is not a function
18:01:16 <mauke> I_LIVE: it is a function. it does not return a function.
18:01:23 <Axman6> it's a value (an Int)
18:01:38 <mauke> > (\xs -> read xs :: Int) "123"
18:01:38 <lambdabot>   123
18:01:54 <mauke> > (\x -> x * x) . 123
18:01:55 <lambdabot>   No instance for (GHC.Num.Num (f a))
18:01:55 <lambdabot>    arising from the literal `123' at <i...
18:02:01 <mauke> > (\x -> x * x) 123
18:02:02 <lambdabot>   15129
18:02:24 <Makoryu> I_LIVE: The function is a function, yes. But the return value of that function is not a function.
18:02:26 <I_LIVE> why compiler can't think of 123 as of function which returns 123 for all inputs?
18:02:35 <mauke> I_LIVE: it can, actually
18:02:36 <ivanm> I_LIVE: because it breaks the type signature
18:02:43 <Axman6> > (\f x -> f x * f x) (\xs -> read xs :: Int) "123"
18:02:43 <Makoryu> I_LIVE: You could make it do that....
18:02:44 <lambdabot>   15129
18:02:45 <ivanm> @type (Prelude..)
18:02:46 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
18:02:47 <Axman6> >_>
18:02:53 <mauke> I_LIVE: it's not defined like that in the standard library, though
18:03:02 <ivanm> I_LIVE: ^^ an Int doesn't match either of the first two argument types
18:03:22 <ivanm> mauke: what, have even constants being expressed as implicit functions?
18:03:25 <ivanm> how would that work?
18:03:34 <mauke> he said 123, not 123 :: Int
18:03:37 <Makoryu> ivanm: instance Num b => Num (a -> b) where...
18:03:50 <ivanm> mauke: oh, right; but then there's problems with the Read instance
18:03:53 <ivanm> Makoryu: yeah, I get you
18:03:59 <ivanm> that's probbaly not what he wants though ;-)
18:04:04 <mauke> I_LIVE: it wouldn't work in your case because you explicitly said :: Int, and an Int is not a function
18:04:11 <habitue> hey does anyone have any experience compiling epigram?
18:04:18 <Makoryu> ivanm: I don't get what he wants anymore.
18:04:25 <I_LIVE> > (\x->x*x) . (\xs -> read xs :: void->Int) "123"
18:04:26 <lambdabot>   Could not deduce (GHC.Read.Read (void -> GHC.Types.Int))
18:04:26 <lambdabot>    from the contex...
18:04:38 <ivanm> Makoryu: he wantes _the world_!
18:04:42 <Makoryu> OF COURSE!
18:04:44 <Axman6> :t
18:04:46 <ivanm> habitue: the developers hopefully do!
18:04:52 <Axman6> :t (\xs -> read xs :: void->Int) "123"
18:04:53 <lambdabot>     Could not deduce (Read (void -> Int)) from the context ()
18:04:53 <lambdabot>       arising from a use of `read' at <interactive>:1:8-14
18:04:53 <lambdabot>     Possible fix:
18:04:59 <I_LIVE> > (\x->x*x) . (\xs -> read xs :: Void->Int) "123"
18:05:00 <lambdabot>   Not in scope: type constructor or class `Void'
18:05:13 <Axman6> where are you getting Void from?
18:05:19 <Makoryu> I_LIVE: Why exactly are you trying to do it this way?
18:05:21 <mauke> I_LIVE: you can't 'read' functions
18:05:25 <Axman6> it does technically exist
18:05:25 <ivanm> I_LIVE: there is no Num (a -> b) instance, and even if there were you'd still have to provide a value to evaluate that function before you can print it
18:05:38 <ivanm> mauke: well, fromIntegral . read ...
18:05:49 <ivanm> Axman6: C, Java, etc. methinks
18:06:27 <ddarius> ivanm: No you wouldn't since Num (a -> b) implies Show (a -> b)
18:06:40 <ivanm> ddarius: duh
18:06:43 <Makoryu> I_LIVE: Are you just somehow obsessed with writing "foo . bar baz" instead of "foo . bar $ baz"?
18:06:49 <ivanm> well, there is a module that provides one...
18:06:55 <ivanm> where show f = "<function>" or something
18:06:56 <Makoryu> Or "(foo . bar) baz" for that matter
18:06:59 <orlandu63> i think he's trolling
18:07:00 <ivanm> Makoryu: yes
18:07:02 <I_LIVE> Makoryu, no, i'm learning the language
18:07:24 <ivanm> I_LIVE: lets say you don't need to use $ like you want... what happens when you have ten such functions chained together
18:07:27 <ivanm> that would get _ugly_
18:07:51 <Axman6> I_LIVE: basic rule of thumb is: write this: f . g . h $ x, or (f . g . h) x, not f . g . h x (unless h :: a -> b -> c)
18:08:15 <orlandu63> Axman6: i don't think thats going to help someone who would ask such a question to begin with
18:08:19 <monochrom> IMO you could get to your real point: why can't the computer read your mind.
18:08:31 <ivanm> monochrom: because I don't want it to
18:08:42 <Makoryu> I_LIVE: Okay, well, the dot operator (.) is function composition. The left and right sides of it have to be functions. In your code, the right side is a function applied to an argument, rather than just a function.
18:09:01 * ivanm tries to remember where he saw that comic strip about why it's good that computers can't read your mind
18:09:06 <Makoryu> I_LIVE: So in your code, the right side of (.) is the number 123.
18:09:06 <I_LIVE> how do i make function which takes no param and returns constant?
18:09:15 <Makoryu> > const 123 ()
18:09:16 <lambdabot>   123
18:09:21 <orlandu63> f = 1
18:09:23 <ivanm> something about thinking rm -rf / or something
18:09:25 <monochrom> > 'c'
18:09:26 <lambdabot>   'c'
18:09:31 <ivanm> I_LIVE: you can't
18:09:34 <Makoryu> > id 123
18:09:35 <lambdabot>   123
18:09:38 <monochrom> takes no param and returns 'c' always
18:09:41 <ivanm> Makoryu: that evaluates to a constant
18:09:52 <Mathnerd314> :t const 123
18:09:52 <lambdabot> forall t b. (Num t) => b -> t
18:09:55 <Axman6> functions have to take arguments no?
18:10:01 <ivanm> Axman6: exactly
18:10:02 <Axman6> it's not a function otherwise
18:10:13 <monochrom> I personally don't take the "make function" seriously.
18:10:40 <dancor> "a" is on it's way out of the language
18:10:47 <dancor> i support its demise
18:11:09 <ivanm> dancor: out of the English language you mean?
18:11:11 <ivanm> if so, why?
18:11:23 <Makoryu> > let f x = x * x; readInt x = read x :: Int in (f . readInt) "123"
18:11:24 <lambdabot>   15129
18:11:28 * Makoryu pokes I_LIVE
18:11:31 <I_LIVE> ?
18:11:39 <idnar> ivanm: I think he just means out of Haskell type signatures ;)
18:11:51 <ivanm> ahhhh
18:12:02 <Saizan_> I_LIVE: with purity and lazy evaluation nullary functions aren't needed, just make a definition like let <somename> = <some value>
18:12:20 <ivanm> so he wants to use just ['b'..'z'] and type variables of length greater than 1?
18:12:53 <Mathnerd314> > (\x->x*x) . (\xs -> const . read $ xs) "123"
18:12:54 <lambdabot>   {()->15129}
18:13:20 <ivanm> Saizan_: weren't you following the discussion? he _wants_ functions like that to avoid having to apply values to function compositions
18:13:27 <Makoryu> :t (*) . const . read
18:13:28 <lambdabot> forall a b. (Num (b -> a), Read a) => String -> (b -> a) -> b -> a
18:13:51 <Saizan_> ivanm: ah, sorry, just got the tail of that
18:14:10 <monochrom> Perhaps it's a blessing to not follow the discussion. It's so ill-perceived.
18:14:45 <monochrom> "why can't 123 stand for the following function ... ?" Yeah, why can't the computer read your mind.
18:14:46 <BMeph> Someone needs to tell I_LIVE about continuations... 8D
18:15:22 <Schalken> Can someone tell me what's wrong with this? "trace :: (MonadWriter [t] m) => ProgramState -> t -> m ()". I get "Non type-variable argument in the constraint: MonadWriter [t] m".
18:16:06 <Mathnerd314> @pl (a * b) x = (a x) * (b x)
18:16:06 <lambdabot> (line 1, column 11):
18:16:06 <lambdabot> unexpected "="
18:16:07 <lambdabot> expecting variable, "(", operator or end of input
18:16:11 <Makoryu> Schalken: That's because you wrote [t] instead of t
18:16:19 <Mathnerd314> @pl mult a b x = (a x) * (b x)
18:16:19 <lambdabot> mult = liftM2 (*)
18:16:42 <aavogt> -XFlexibleContexts or something like it
18:16:45 <Schalken> Makoryu: Okay. So how do I enforce the monoid to be a list?
18:17:42 <Makoryu> Schalken: I'm not familiar with MonadWriter, so I'm not clear why you wrote it that way. Would "... -> [t] -> ..." work?
18:18:02 <aavogt> Schalken: you just need to enable some extensions to be able to write that type signature
18:18:23 * Makoryu defers to aavogt
18:19:02 <Schalken> Makoryu: No, the function takes argument of type t, but the monoid must be a lit of that type, [t].
18:19:12 <EvanR> :t runWriter
18:19:13 <aavogt> the error message tends to name the extensions you need
18:19:13 <lambdabot> forall w a. Writer w a -> (a, w)
18:19:19 <Makoryu> Schalken: So listen to aavogt
18:19:38 <Schalken> aavogt: This is a university assignment for which I don't have control over the compile-time flags.
18:19:50 <gwern> so use LANGUAGE
18:19:58 <gwern> if you have sauce, you have compile-time flags!
18:20:10 <aavogt> you don't get linker flags though
18:20:12 <Makoryu> Put a {-# LANGUAGE -XBlah #-} comment in there somewhere
18:20:19 <aavogt> drop the -X
18:20:23 <gwern> Seig Heil, mon GHC! Banzai! banzai! banzai!
18:20:49 <Makoryu> So {-# LANGUAGE FlexibleContexts #-}?
18:21:01 <Schalken> But is it then no longer standard Haskell 98?
18:21:07 * gwern salutes Makoryu with the iron cross posture
18:21:31 <aavogt> also, depending on your ghc version, it should be one of the first lines
18:21:36 * Makoryu chases gwern to the ends of the earth (or at least the Czech Republic)
18:21:39 <gwern> Schalken: if you won't tell, we won't
18:21:58 <aavogt> the class MonadWriter isn't haskell 98
18:22:08 <EvanR> Writer is awesome
18:22:15 <aavogt> MPTCs and FDs
18:22:47 * gwern hides from Makoryu through the ratline. mon fuhrer! I shall return and exterminte the juden c++!
18:23:37 <jon_of_arc> Anyone know why attempting to build (via cabal install) HList with Cabal 1.8.0.2 on GHC 6.12.1 might die on a "no context is allowed on a GADT-style data declaration" error?
18:23:46 <aavogt> jon_of_arc: yes
18:23:59 <gwern> oleg knows
18:24:06 <aavogt> get one that works from   http://code.haskell.org/HList
18:24:37 <gwern> aavogt: that's odd. I thought I did an upload the last batch of updates
18:24:56 <aavogt> @hackage HList
18:24:56 <lambdabot> http://hackage.haskell.org/package/HList
18:25:06 <aavogt> Upload dateTue Sep 15 16:54:00 UTC 2009
18:25:28 <gwern> It was a while, light blind me if I'm lying
18:25:31 <aavogt> gwern: those changes for ghc-6.12 are new since about february
18:25:35 <ivanm> jon_of_arc: why do you want to use hlist for?
18:26:02 <gwern> oh, he didn't tell me
18:26:25 <Mathnerd314> @instances Monad
18:26:26 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
18:27:01 <Schalken> aavogt: gwern: Makoryu: {-# LANGUAGE ... did it! Thanks for your help. Out of curiosity why isn't something that seems so to make perfect sense in the type system not standard Haskell?
18:27:16 <Makoryu> Schalken: Â¯\O_o/Â¯
18:27:19 <gwern> Schalken: because '98 was a long time ago
18:27:23 <aavogt> because standard haskell is over 10 years old
18:27:24 <Mathnerd314> @src Monad (->)
18:27:24 <lambdabot> Source not found. You untyped fool!
18:27:29 <Mathnerd314> @src Monad ((->) r)
18:27:30 <lambdabot> Source not found. Sorry.
18:27:50 <Mathnerd314> hmm... where is that instance?
18:27:56 <gwern> aavogt: it sounds better if you say over 12 years
18:28:03 <Makoryu> @index Monad ((->) r)
18:28:03 <lambdabot> bzzt
18:28:06 <Makoryu> Pffft
18:28:06 <Schalken> gwern: aavogt: Any idea if it's in Haskell 2010?
18:28:10 <aavogt> Schalken: I suppose those type system features were not mature enough to standardize yet
18:28:19 <applicative> Is FlexibleContextst part of fglasgow-exts?
18:28:19 <jon_of_arc> ivanm: I'm going to have a bunch of functions a->? where ? is heterogeneous, which all need to be fed the same value of a, and I want to get out of doing it manually
18:28:20 <gwern> and given how long it took to make the report in the first place, you can say haskell '98 is more than a baker's dozen years old!
18:28:28 <gwern> Schalken: dunno. go check the haskell 2010 site
18:28:40 <Schalken> gwern: Thanks.
18:28:44 <ivanm> jon_of_arc: but what are you going to do with all those values?
18:28:55 <aavogt> gwern: but the 98 report is just a revision of some older report
18:29:10 <ivanm> haskell 1.0 methinks
18:29:17 <gwern> aavogt: academic publishing be mad slow dawg
18:29:32 <aavogt> -fglasgow-exts is crazy
18:29:55 <aavogt> it makes `rec' a keyword among other things
18:30:02 <Makoryu> What
18:30:03 <applicative> Schalken FlexibleContexts isn't mentioned in the preliminary announcement of 'haskell 2010' http://www.haskell.org/pipermail/haskell-prime/2009-July/002812.html
18:30:12 <jon_of_arc> ivanm: that's unfixed. The project is a library for supporting attribute grammar-style programming, and I'm trying to concisely express the operation of giving a reference to the parent node to all of the functions that define inherited attributes
18:30:24 <Schalken> applicative: Yeah, I just saw that.
18:30:26 <aavogt> well multiparameter typeclasses aren't even named
18:30:29 <ivanm> jon_of_arc: will it be a finite known set of values?
18:30:33 <ivanm> if so, define a sum-type instead
18:31:13 <aavogt> gwern: so there's another upload of HList happening soon?
18:31:28 <gwern> aavogt: I dunno. what's it worth to ya
18:31:39 <jon_of_arc> ivanm: I'd have to make the user do that, which I'm trying to get out of, and even if that happens it seems like the set would be large.
18:31:58 <Makoryu> Oh here we go: instance Monad ((->) r) where return = const; f >>= k = \ r -> k (f r) r
18:32:09 <ivanm> jon_of_arc: thing is, if you have an hlist, what will you be doing with all those values and how would you get them out of the hlist?
18:32:36 <aavogt> hlists let you index and fold and other nice stuff on them
18:32:42 <gwern> @quote hlist
18:32:42 <lambdabot> joelr says: Fundeps, existential types, & HList take a while to grasp
18:32:54 <ivanm> preflex: seen dons
18:32:54 <preflex>  dons was last seen on #haskell 3 hours, 17 minutes and 52 seconds ago, saying: gwern: that's what we tell you.
18:32:54 <Mathnerd314> Makoryu: I don't want the source, just the location to import
18:33:05 <jon_of_arc> ivanm: I'll admit, I'm not certain yet. I went to install the library while I read the documentation, and then got the error I originally asked about.
18:33:14 <gwern> bah. we need a good quote abotu hlist like 'if hlist is the answer, I don't want to know the question'
18:33:15 <Makoryu> Mathnerd314: Control.Monad.Instances, or any of the several modules that import it
18:33:33 <Axman6> @remember gwern if hlist is the answer, I don't want to know the question
18:33:33 <lambdabot> It is forever etched in my memory.
18:33:38 <Axman6> <_<
18:33:52 <gwern> @flush
18:33:57 <gwern> I guess I'll take it
18:34:15 <jon_of_arc> ivanm: if you've got a better suggestion for how to propagate the parent node's environment down to the children without making the user tie a bunch of knots, I'm all ears :) I got nothing on that question earlier.
18:34:16 <ivanm> @tell dons with the comment on haskell reddit "No one is using Darcs 1.*"; that plot is for people using darcs xmonad, which are probably a bit more technically literate than the norm; not all distributions (e.g. debian) may provide darcs-2 yet
18:34:16 <lambdabot> Consider it noted.
18:34:21 <ivanm> gwern: agreed
18:34:25 <applicative> Schalken, if you think through the history of 'type classes', it isn't so suprising that 'FlexibleContexts' is not first on the agenda.  Some of the relevant materials are on http://homepages.inf.ed.ac.uk/wadler/topics/type-classes.html
18:34:26 * Schalken loves FlexibleContexts
18:34:38 <gwern> ivanm: stable debian provides darcs 2
18:34:39 <ivanm> jon_of_arc: no idea what you're doing, so I can't really help you
18:34:48 <ivanm> gwern: oh? shows what I know
18:34:49 <gwern> (as I said in my original email)
18:34:56 * ivanm wonders when gentoo got darcs-2 stabilised
18:35:23 <Mathnerd314> :t const fromInteger
18:35:24 <gwern> darcs 2 is ancient
18:35:24 <lambdabot> forall a b. (Num a) => b -> Integer -> a
18:35:25 <ivanm> gwern: what email? I"m looking at reddit! ;-)
18:35:32 <gwern> wasn't that in like 2008?
18:35:44 <jon_of_arc> ivanm: was that an invitation to explain, or a polite way of indicating that you're done trying to save me from myself? ;)
18:35:44 <gwern> ivanm: you should read the xmonad email list more often
18:35:51 <Mathnerd314> :t fromInteger
18:35:52 <lambdabot> forall a. (Num a) => Integer -> a
18:35:54 <ivanm> @tell dons nvm, gwern just informed me that debian stable has darcs-2
18:35:54 <lambdabot> Consider it noted.
18:35:54 <aavogt> why submit stuff to reddit, rather than just upgrading the repo?
18:36:04 <ivanm> gwern: I read it; whether I remember everything from it is a different story ;-)
18:36:08 <gwern> jon_of_arc: latter
18:36:10 <Mathnerd314> :t const . fromInteger
18:36:11 <lambdabot> forall a b. (Num a) => Integer -> b -> a
18:36:17 <ivanm> jon_of_arc: normally the former, but I'm about to head off for a bit
18:36:21 <gwern> aavogt: well, consumers will have issues
18:36:26 <gwern> aavogt: so best not be hasty
18:36:30 <aavogt> which consumers?
18:36:36 <aavogt> look at the graph already!
18:36:38 <ivanm> gwern: I thought debian took 5 years before it let something be marked as "stable"...
18:36:38 <gwern> aavogt: anyone who pulls
18:36:56 <gwern> ivanm: fine go to debian and and prove me wrong
18:36:58 <ivanm> aavogt: of _xmonad_; I'd be more interested in say a c.h.o darcs-1 vs darcs-2 plot
18:37:06 <gwern> gawrsh!
18:37:06 <ivanm> gwern: no idea where to look
18:37:07 <ivanm> ;-)
18:37:17 <gwern> ivanm: I think that was in the xmonad thread as well...
18:37:23 <ivanm> IIRC, c.h.o still defaults to darcs 1
18:37:25 <Schalken> applicative: Okay. Any idea if the extension loosens the type system in any way such that previously cought compile-time errors will now occur at runtime?
18:37:27 <jon_of_arc> ivanm: fair enough, thanks anyway.
18:37:32 <aavogt> ivanm: there's a script for looking through apache logs....
18:37:39 <ivanm> gwern: how long ago was this?
18:37:54 <ivanm> oh, wait, found it
18:37:58 <gwern> ivanm: a brace of days
18:38:05 <ivanm> strage, I don't recall anything about that thread even though I read it...
18:38:14 <Mathnerd314> > const 123 undefined
18:38:15 <lambdabot>   123
18:38:20 <jon_of_arc> If anyone else is feeling more masochistic, please let me know; it'll take more explaining than I think I want to do without a confirmed ear.
18:38:24 <gwern> ivanm: memory is always the first thing to go
18:38:28 <aavogt> it would be a minor modification to that program
18:38:38 <ivanm> that thread only has plots for xmonad, not overall c.h.o
18:38:49 <gwern> ivanm: does it matter?
18:38:51 <ivanm> gwern: what were we talking about sorry?
18:38:51 <ivanm> :p
18:38:53 <gwern> we're discussing upgrading xmonad
18:38:57 <aavogt> ivanm: because the logs are hundreds or M!
18:39:02 <gwern> ivanm: the will, remember
18:39:08 <ivanm> gwern: dons was saying in general to dump darcs-1 on the haskell reddit
18:39:14 <ivanm> gwern: but I don't have one...
18:39:18 <gwern> ivanm: he's probably right
18:39:18 <ivanm> ;-)
18:39:19 <aavogt> dons likes generalizing though
18:39:23 <ivanm> yeah
18:39:25 <gwern> ivanm: right, you were going to make one in my favor
18:39:30 <ivanm> heh
18:39:36 <gwern> you really do have memory problems
18:39:52 <ivanm> anyway; I agree that we should switch to darcs-2 in general is a good idea; whether it's feasible is a different story
18:40:10 <gwern> what's not feasible about it?
18:40:28 <Axman6> Don Stewart: Haskell's go faster stripes
18:40:40 <ivanm> gwern: because we have no idea of the install base of darcs-1 vs darcs-2
18:40:48 <gwern> I'd like all darcs-1 repos to die. global cache yay
18:41:05 <gwern> ivanm: sure we do. minimal to everyone else
18:41:19 <ivanm> _relative_ install base then
18:41:36 <Mathnerd314> > fix (const 1)
18:41:36 <lambdabot>   1
18:41:41 <ivanm> ignoring all other VCSs
18:41:52 <Mathnerd314> @src fix
18:41:52 <lambdabot> fix f = let x = f x in x
18:41:55 <gwern> the c.h.o logs for xmonad don't say anything but 'no one uses darcs1'
18:42:04 <gwern> did they show even a single user of darcs-1?
18:42:23 <aavogt> gwern: http://code.haskell.org/~aavogt/darcsVersions/0
18:42:25 <Mathnerd314> @pl fix f = let x = f x in x
18:42:25 <lambdabot> fix = fix id
18:42:45 <Axman6> heh
18:42:46 <aavogt> gwern: so 12 in 2010 so far
18:42:55 <gwern> aavogt: interpret the runes for me, soothsayer!
18:43:10 <Mathnerd314> > fix (\x -> x+x) :: Integer
18:43:13 <lambdabot>   mueval-core: Time limit exceeded
18:43:17 <Makoryu> :t (fix, fix id)
18:43:18 <lambdabot> forall a a1. ((a -> a) -> a, a1)
18:43:27 <gwern> aavogt: 12 whats?
18:43:28 <aavogt> > id fix const Nothing
18:43:29 <lambdabot>   Occurs check: cannot construct the infinite type: a = b -> a
18:43:35 <Mathnerd314> > fix (\x -> x+x) :: Double
18:43:39 <lambdabot>   mueval-core: Time limit exceeded
18:43:51 <Mathnerd314> > fix id
18:43:55 <lambdabot>   mueval-core: Time limit exceeded
18:44:02 * ivanm heads off
18:44:05 <Mathnerd314> > fix id :: ()
18:44:09 <lambdabot>   mueval-core: Time limit exceeded
18:44:19 <Mathnerd314> fix id == undefined?
18:44:25 <Axman6> yes
18:44:33 <Axman6> :t fix id
18:44:34 <lambdabot> forall a. a
18:44:41 <Axman6> :t undefined
18:44:42 <lambdabot> forall a. a
18:45:02 <aavogt> gwern: number of times a like like : [25/Apr/2010:05:18:18 -0400] "GET /xmobar/_darcs/prefs/motd HTTP/1.1" 200 - "-" "darcs/2.4.1 libcurl/7.20.1"  happens in the logs
18:45:15 <gwern> so each is a pull
18:45:20 <gwern> 12 pulls. that could be one person
18:45:23 <aavogt> yes
18:45:45 <gwern> bwa ha ha ha!
18:45:51 <gwern> sorry.
18:46:16 <aavogt> I only looked at the major version of darcs though
18:46:44 <gwern> bad aavogt. you threw away information. differing minor versions would've told us distinct users
18:46:51 <Mathnerd314> > fix (\x -> 2)
18:46:52 <lambdabot>   2
18:46:55 <aavogt> if you look at IP + the whole user agent, you might have a different picture
18:47:24 <Mathnerd314> > fix (\x -> if (x == 2) then (x+1) else 2)
18:47:26 <gwern> yes yes
18:47:27 <lambdabot>   mueval-core: Time limit exceeded
18:47:44 <gwern> but shall we let the needs of the postulated one outweigh the needs of the many (gwern)?
18:47:54 <Mathnerd314> > fix (\x -> if (x == 2) then 2 else (x+1))
18:47:58 <lambdabot>   mueval-core: Time limit exceeded
18:48:24 <Mathnerd314> > fix (\x -> if (x == ()) then () else undefined)
18:48:24 <aavogt> the only way to find out for sure is to upgrade the repo and see who complains
18:48:26 <gwern> I say no! I say progress must continue! For a better tomorrow! forward the programmer's paradise!
18:48:28 <lambdabot>   mueval-core: Time limit exceeded
18:48:57 <gwern> forward and damn the torpedos!
18:49:06 <aavogt> gwern: how do older darcs fail when interacting with the 'new' repo format?
18:49:07 <Mathnerd314> @pl f g = (g undefined)
18:49:07 <lambdabot> f = ($ undefined)
18:49:12 <gwern> don't upgrade till you see the whites of their eyes!
18:49:29 <gwern> aavogt: I believe they say something like 'repo format unrecognized'
18:49:49 <gwern> improving the forward compat messages was something done in 2.x iirc
18:53:58 <EvanR> i think im done with main
18:54:45 <EvanR> http://codepad.org/T7MHzpWP
18:56:34 <pps> EvanR: Just curious - what is the type of that StateT you're evaling?
18:57:05 <EvanR> i knew this a few hours ago :S
18:57:16 <EvanR> StateT World IO ()
18:57:29 <pps> Ah, thank you.
18:57:30 <xerox> why StateT over IO?
18:57:38 <xerox> IO's got state
18:57:40 <EvanR> Peaker told me to do it
18:57:54 <Axman6> IO's got state yo!
18:58:20 <EvanR> modify get and put are more compact than readIORef, at least
18:58:36 <EvanR> but the liftIO is kind of annoying
18:58:40 <xerox> you can define modify get and put
18:58:47 <xerox> to mean ioref stuff
18:58:51 <pps> I was just wondering if all of the liftIOs were necessary. Perhaps I don't understand exactly how monad transformers work.
18:58:53 <xerox> or m g p for that matter
18:59:24 <EvanR> pps: well, the type of each 'statement' is StateT World IO (), but each of my IO commands is of type IO a
18:59:30 <EvanR> s/()/a/
18:59:38 <EvanR> so >>= doesnt work
18:59:44 <pps> Ah, thank you.
18:59:46 <applicative> Schalken, if I understand it, the paper http://research.microsoft.com/en-us/um/people/simonpj/Papers/type-class-design-space/ seems to maintain that FlexibleContexts, at least the sort you were using, is no big deal .
19:00:26 <EvanR> xerox: id need to pass in an ioref
19:00:53 <Schalken> applicative: Have you been reading up on it since I asked?
19:01:09 <applicative> yes, you got me interested, curse you...
19:01:15 <xerox> EvanR: why do you need the IO during the Stateful computation?
19:01:52 <applicative> I take it you saw the pros and cons on the Haskell Prime trac http://hackage.haskell.org/trac/haskell-prime/wiki/FlexibleContexts
19:02:03 <EvanR> getInput is necessarily IO. input causes an impure 'acceleration' which changes the way the evolution unfolds
19:02:15 <EvanR> it has to be interleaved
19:02:22 <EvanR> timer is IO
19:02:26 <EvanR> sleep is IO
19:02:29 <EvanR> reduce cpu
19:02:37 <EvanR> and drawing output is IO
19:02:48 <EvanR> i added the execOutput to allow for sound effects
19:05:15 <EvanR> xerox: we can make it pure simply by removing the input. this eliminates interactivity, the other stuff wouldnt be a big deal to remove, because you can generate a large portion and render it however fast you want (a demo)
19:07:40 <gwern> aavogt: I've sent another email to the list
19:11:30 <aavogt> gwern: there is no sign of it
19:11:50 <gwern> gmail offline. it'll send it when it's good and ready
19:12:14 * gwern is on a bad connection. you can IRC fine over pigeons, but anythin else...
19:12:52 <tensorpudding> Those must be some fast-moving pidgeons
19:26:02 <Mathnerd314> there must be a name for the general pattern of "instance X a => X (a -> b)"
19:26:17 <Mathnerd314> * X( b -> a)
19:27:38 <dolio> That generalizes to 'instance (X a, Applicative f) => X (f a)', typically.
19:27:57 <dolio> where 'foo = liftA(N) foo'
19:28:15 <monochrom> "pointwise lift". Example: "if B is a poset, X->B is a poset by pointwise lifting the order"
19:29:18 <siracusa> dcoutts: ?
19:29:22 <gwern> mmm... posset...
19:29:41 <Mathnerd314> you get more complicated things though, like when implementing fromInteger
19:29:51 <Mathnerd314> :t fromInteger
19:29:52 <lambdabot> forall a. (Num a) => Integer -> a
19:29:55 <aavogt> @wn mmm
19:29:55 <lambdabot> No match for "mmm".
19:30:08 <Mathnerd314> :t const . fromInteger
19:30:09 <lambdabot> forall a b. (Num a) => Integer -> b -> a
19:30:18 <Mathnerd314> :t pure . fromInteger
19:30:19 <lambdabot> forall a (f :: * -> *). (Applicative f, Num a) => Integer -> f a
19:30:25 <Mathnerd314> oh
19:30:38 <monochrom> onoes. "She was cosseted and posseted." --O. W. Holmes.
19:30:41 * gwern thinks aavogt chose the wrong word to @wn
19:31:38 <monochrom> I am monnaded.
19:32:11 <gwern> @wn posset
19:32:11 <monochrom> @vixen are you cosseted and posseted?
19:32:11 <lambdabot> *** "posset" wn "WordNet (r) 2.0"
19:32:12 <lambdabot> posset
19:32:12 <lambdabot>      n : sweet spiced hot milk curdled with ale or beer
19:32:12 <lambdabot> yes, i am
19:32:13 <Mathnerd314> is there a "coapplicative"?
19:32:42 <dolio> @go applicative decisive
19:32:42 <lambdabot> Maybe you meant: google googleit do
19:32:48 <dolio> @google applicative decisive
19:32:50 <lambdabot> http://www.springerlink.com/index/77182j5307032301.pdf
19:32:50 <lambdabot> Title: SpringerLink Home - Main
19:33:28 <dolio> @google decisive functors
19:33:29 <lambdabot> No Result Found.
19:33:38 <dolio> Well now it's just lying.
19:33:48 <dolio> http://sneezy.cs.nott.ac.uk/fplunch/weblog/?p=69
19:34:48 <monochrom> programming with decisive applicatives, administrative functors, and executive monads.
19:35:23 <gwern> now that's enterprise-ready research
19:35:35 <xerox> hahaha
19:35:54 <xerox> synergystic syntax
19:46:14 <gwern> aavogt: if'n it please you, I've uploaded hlist 0.2.1
19:46:38 <aavogt> thanks
19:46:38 <ivanm> gwern: what? I thought you hated hlist...
19:46:38 <Mathnerd314> @hoogle CoApplicative
19:46:38 <lambdabot> No results found
19:46:38 <Mathnerd314> @hoogle Coapplicative
19:46:38 <lambdabot> No results found
19:46:50 <aavogt> for the greater good of the hackage!
19:46:52 <gwern> ivanm: I do. doesn't mean I didn't package it
19:46:57 * hackagebot HList 0.2.1 - Heterogeneous lists  http://hackage.haskell.org/package/HList-0.2.1 (GwernBranwen)
19:46:57 <gwern> how else could I learn to hate it?
19:46:58 <Mathnerd314> @hoogle Decisive
19:46:58 <lambdabot> No results found
19:47:06 <ivanm> gwern: so _you're_ the one to blame for it being on hackage!
19:47:18 * ivanm had to exorcise it from the gentoo-haskell overlay after he found it in there
19:47:20 <gwern> ye got me dead to rights, guvnor!
19:47:38 <aavogt> http://hackage.haskell.org/package/xhaskell-library
19:48:00 <ivanm> aavogt: yeah, saw that
19:48:03 <ivanm> that's just... weird :s
19:48:04 <gwern> ivanm: Im going to assume that's a good thing
19:48:27 <ivanm> took a lot of holy water
19:48:29 <ivanm> ;-)
19:48:43 <gwern> fortunately you could replace it with the cabalized version
19:48:45 <Mathnerd314> dolio: are there any Decisive functors lying around on hackage?
19:48:56 * gwern won't lie, took a fair bit of effort to cabalize hlist
19:49:03 <dolio> I don't know. Decisive is pretty weird.
19:49:11 <ivanm> gwern: why _did_ you bother?
19:49:24 <gwern> ivanm: aavogt already said
19:49:30 <Mathnerd314> @type ($undefined)
19:49:31 <lambdabot> forall a b. (a -> b) -> b
19:49:32 <ivanm> ahhhh
19:49:35 <gwern> why did I not climb Mt. Everest?
19:49:38 <ivanm> gwern: and to stop people asking about it?
19:49:41 <gwern> why did I upload 100 packages to hackage?
19:49:44 <ivanm> because you weren't stupid?
19:49:51 <ivanm> (r.e. Mt Everest)
19:49:56 <Mathnerd314> @type ($undefined) -- nogood
19:49:57 <lambdabot> forall a b. (a -> b) -> b
19:50:09 <gwern> ivanm: well, if stopping people from talking about hlist was my plan, cabalizing it is pretty counterproductive
19:50:10 <dolio> For instance, you can't get from f Zero -> Zero to f a -> a, which would be copointed.
19:50:11 <Mathnerd314> not certain what orwell should be
19:50:17 <ivanm> Mathnerd314: huh?
19:50:21 <ivanm> what's orwell?
19:50:29 <Mathnerd314> ivanm: http://sneezy.cs.nott.ac.uk/fplunch/weblog/?p=69
19:50:32 <aavogt> it's a pseudonym
19:50:38 <dolio> At least, not the f a -> a that you'd want.
19:50:49 <ivanm> gwern: well, people kept asking how to do it, so one advantage of having hlist there was that we could point to it and then saying why they _shouldn't_ use it
19:50:57 <gwern> ivanm: orwell is a fine pig
19:51:08 <ivanm> Mathnerd314: ahhhh
19:51:18 * ivanm was thinking more 1984..
19:51:20 <aavogt> but do you know hlist enough to hate it?
19:51:29 <ddarius> Orwell was a lazy functional programming language back in the day.
19:51:36 <ivanm> aavogt: I hate the very concept of it, because it doesn't make sense
19:51:38 <aavogt> some people hate monads
19:51:45 <ivanm> and is against the whole point of Haskell's type system
19:51:50 <ivanm> ddarius: :o
19:51:52 <Saizan_> the first packaging of hlist came out all wrong though, i hope it got better
19:51:54 <gwern> uniqueness types forever1
19:52:06 <gwern> Saizan_: I fixed it :(
19:52:17 <gwern> I didn't realize the entire damn examples subdirectory was important
19:52:21 <aavogt> gwern: I think there's still some code in it that's unused
19:52:38 <aavogt> as in, included but not compiled
19:52:48 <gwern> (it was 'examples'! how was I to know those were critical?)
19:52:53 <aavogt> also, the comments must be turned into haddock comments
19:52:56 <gwern> aavogt: I thought I got them all
19:53:10 <gwern> eh, now you're asking too much. if it builds I'm cool with it
19:53:23 <ivanm> aavogt: yeah, whoever packages the shuffle package failed to do that
19:53:29 <Mathnerd314> dolio: I can't see how orwell is of type (f a -> f b) -> f(a->b) though
19:53:37 <DigitalKiwi> ivanm: do you know about the C mode for ghc?
19:53:44 <gwern> ivanm: oleg's shuffle emails were packaged?
19:53:44 <ivanm> DigitalKiwi: nope ;-)
19:53:46 <DigitalKiwi> also email sent
19:53:48 <DigitalKiwi> aww :(
19:53:49 <ivanm> gwern: yup
19:53:52 <aavogt> what is shuffle?
19:53:59 <aavogt> some kind of permutation?
19:54:00 <ivanm> aavogt: perfect list shuffling
19:54:02 <ivanm> yeah
19:54:05 <ivanm> random permutation
19:54:14 <aavogt> shuffleboard
19:54:18 <ivanm> knuth has the canonical implementation for imperative languages
19:54:23 <dolio> Mathnerd314: It isn't.
19:55:20 <DigitalKiwi> hrm what to do...
19:55:44 <dolio> Mathnerd314: refute and branch are the analogues to the Applicative class in the libraries.
20:06:53 <blackdog> is there an idiomatic 'undefined' that lets you know where it's been used?
20:07:20 <blackdog> i guess i can do it with CPP or something equally undignified
20:07:27 <dons> GHC.Base.assert False (return ())
20:07:27 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
20:07:27 <dons> *** Exception: <interactive>:1:0-14: Assertion failed
20:07:28 <Makoryu> > error "Line 404: Something horrible happened"
20:07:29 <lambdabot>   *Exception: Line 404: Something horrible happened
20:07:29 <ddarius> Check out GHC's assert library.
20:07:49 <blackdog> dons: cheers, that's exactly what i awnt
20:07:51 <gwern> blackdog: look for interlude
20:07:54 <dons> other option is: -cpp,   error __LINE__
20:08:25 <gwern> (this must be the 3rd or 4th time I've recommended the interlude to someone. useful little thing)
20:08:26 <dons> watch out for ghc -O2 compiling out asserts though.
20:08:39 <iaefai> When I run configure on haskell platform with ghc 6.12.2, it complains about base-4.2.0.0 missing, I do have 4.2.0.1 however. Is this something that can be fixed?
20:09:42 <blackdog> gwern: so, hang on - if I import interlude, undefined just does something more helpful without any extra work on my part?
20:10:06 <DigitalKiwi> ivanm:
20:10:09 <DigitalKiwi> Hello Charles:
20:10:09 <DigitalKiwi> Thanks for your feedback.  I will pass this to Nate.  It will help many students.
20:10:12 <DigitalKiwi> Thanks again.  Keep up the good work,
20:10:16 <DigitalKiwi> Jitender Deogun.
20:10:18 <DigitalKiwi> =D
20:10:35 <gwern> blackdog: I believe that's how it works
20:10:44 <gwern> or wait no
20:10:49 <gwern> you're calling undefined?
20:11:04 <blackdog> yep
20:11:12 * gwern suddenly forgets how interlude works. I know it'll tell you where you're calling things like 'head []', but an explicit undefined?
20:11:27 <blackdog> yeah, it doesn't seem to work there
20:11:27 <blackdog> pity
20:12:00 <blackdog> I'm trying to get a blend of type-driven and test-driven dev going
20:12:19 <aavogt> the idiomatic undefined is to not use it
20:12:20 <blackdog> using undefined as a sort of marker of where to start implementing again
20:12:28 <dons> mm. let undef = GHC.Base.assert False undefined ??
20:12:33 <aavogt> gwern: I think it requires you to -XCPP
20:12:36 <dons> Prelude> let f x = undef
20:12:36 <dons> Prelude> f 2
20:12:36 <dons> *** Exception: <interactive>:1:12-26: Assertion failed
20:12:58 <dons> oh, you'll get the line def of 'undef' everytime, not the call site.
20:13:26 <Saizan_> yeah, you can't abstract over assert
20:13:26 <Axman6> cabal install llvm ... "Generating and compiling a zillion numerical type aliases, this might take a while"
20:13:34 <aavogt> can you use the magic that assert uses to get the source location?
20:13:56 <blackdog> aavogt: I'm obviously not going to leave them in. I'm just trying to get away from the pattern of fully implementing before I have any tests
20:14:01 <aavogt> in base, it looks like some  SrcLoc# extra argument
20:14:34 <blackdog> dons: that doesn't help me much, that always reports the error at the definition of undef
20:14:41 <dons> yeah.
20:14:43 <andrewsw> hi, I'm struggling to figure out how to turn [IO[Foo]] into IO [Foo]. Some kind of concat, but I'm lost here
20:14:48 <Saizan_> you could use a macro
20:14:51 <dons> you need a literal call to assert at each site.
20:14:59 <blackdog> so back to CPP
20:15:05 <dons> e.g. #define undef (assert False undefined)
20:15:05 <aavogt> assertError :: Addr# -> Bool -> a -> a
20:15:19 <dons> or #define undef (error (show __LINE__))
20:15:38 <dons> or maybe you get lucky with {-# INLINE undef #-} ??
20:15:43 <Saizan_> undef = [| GHC.Base.assert False undefined |], and then $undef where you want
20:16:17 <blackdog> hm. been wondering about that - is TH totally mainstream now?
20:16:33 <blackdog> i've been avoiding it for trivial things, but maybe it's assumable now
20:16:38 <aavogt> neither is haskell
20:17:11 <Saizan_> if even ndm uses it..
20:17:13 <andrewsw> but maybe I'm barking up the wrong tree... turning :: String -> IO [Foo] into :: [String] -> IO [Foo] with map is probably a bad idea.
20:17:42 <Saizan_> andrewsw: it's part of the solution
20:17:55 <Saizan_> ?type sequence
20:17:56 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
20:18:04 * hackagebot time 1.2.0.2 - A time library  http://hackage.haskell.org/package/time-1.2.0.2 (AshleyYakeley)
20:18:05 <Saizan_> then you need that, and some concat
20:18:15 <Saizan_> ?src mapM
20:18:15 <lambdabot> mapM f as = sequence (map f as)
20:18:17 <aavogt> @type Data.Foldable.foldMap (?f :: String -> IO [Int])
20:18:17 <lambdabot>     No instance for (Monoid (IO [Int]))
20:18:18 <lambdabot>       arising from a use of `Data.Foldable.foldMap'
20:18:18 <lambdabot>                    at <interactive>:1:0-47
20:18:22 <aavogt> :(
20:18:25 <blackdog> dons: any idea what macro gets defined for the column?
20:18:33 <dons> blackdog: TH is what, 8 years old?
20:18:40 <dons> its mainstream, brother.
20:18:42 <ddarius> dons: About.
20:18:49 <aavogt> TH is second class though
20:18:49 <blackdog> i shall use it without compunction, then
20:19:03 <ddarius> It was being added to GHC about the time I got here which was roughly 2002.
20:19:11 <andrewsw> Saizan_: thanks for the pointer.
20:19:16 <aavogt> as in, a low priority for updates by ghc
20:19:17 <blackdog> a bunch of people got very upset when i used matt's quasiquoting stuff to do something as trivial as string interpolation:)
20:19:42 <aavogt> blackdog: quasiquoters are newer though
20:19:53 <Axman6> :t let double (x:xs) = x:x:double xs in fix double
20:19:54 <lambdabot> forall t. [t]
20:20:02 <Axman6> > let double (x:xs) = x:x:double xs in fix double
20:20:03 <aavogt> they were added only a couple years ago
20:20:06 <lambdabot>   mueval-core: Time limit exceeded
20:20:11 <ddarius> Axman6: That's a vicious loop.
20:20:55 * Axman6 is a vicious person
20:21:10 <ivanm> DigitalKiwi: heh
20:21:30 <Axman6> ivanm: are you all done with your marking?
20:21:42 <ivanm> Axman6: yeah, I handed them back to the students in class
20:21:52 <Axman6> ok
20:21:55 * ddarius had been imagining ivanm walking about pissing on things.
20:22:04 <Axman6> i'm just finishing the last of mine now
20:22:05 <ivanm> ddarius: huh?
20:22:09 <ivanm> Axman6: how'd they go?
20:22:11 <Axman6> haven't had time until this weekend >_<
20:22:30 <blackdog> there's a funny tension between type driven and test driven dev
20:22:32 <Axman6> alright, some were really quite good, most were... average (whodathunkit?)
20:22:48 <blackdog> types seem to make me do things top-down, and tests make me do things bottom-up
20:22:51 <aavogt> too many drivers I suppose
20:23:31 <DigitalKiwi> ivanm: are you a teacher?
20:23:34 <ivanm> tutor
20:24:01 <ivanm> Axman6: I got 1 with a 10 (lost .5 for comments, got .5 bonus for doing 5 extra transformations)
20:24:11 <ivanm> most of the rest were about 7.5 - 8
20:24:12 <Makoryu> > let (::) foo Int; (=) foo 5 in foo
20:24:13 <lambdabot>   <no location info>: parse error on input `::'
20:24:16 <Axman6> i've given two 11's
20:24:19 <ivanm> :o
20:24:27 <blackdog> Axman6: bit too much spinal tap?
20:24:28 <wanghorn> > abs(0.8 - 0.5)
20:24:29 <Axman6> because they were really good
20:24:29 <lambdabot>   0.30000000000000004
20:24:31 <ivanm> I thought you could only give 1 x 0.5 bonus
20:24:38 <wanghorn> > abs(0.5 - 0.8)
20:24:39 <lambdabot>   0.30000000000000004
20:24:41 <Axman6> yeah, i might check that
20:24:42 * ivanm heads off to watch Beneath Hill 60
20:24:45 <Makoryu> > ---------5
20:24:46 <lambdabot>   not an expression: `---------5'
20:24:50 <Makoryu> Oh right
20:24:56 <Makoryu> > - - - - - - - - - - 5
20:24:57 <ivanm> bbl
20:24:57 <lambdabot>   <no location info>: parse error on input `-'
20:25:02 <Makoryu> Â¯\O_o/Â¯
20:25:10 <blackdog> wanghorn: programmers who compare floating point numbers for equality are in a state of sin.
20:25:22 <Axman6> > - ( - ( -( -(5))))
20:25:23 <lambdabot>   5
20:25:43 <Makoryu> > -(-(-(-(-(-(-(-5)))))))
20:25:44 <lambdabot>   5
20:25:45 <Axman6> > iterate (\x -> -x) 5
20:25:46 <lambdabot>   [5,-5,5,-5,5,-5,5,-5,5,-5,5,-5,5,-5,5,-5,5,-5,5,-5,5,-5,5,-5,5,-5,5,-5,5,-5...
20:25:47 <Makoryu> Yep
20:26:02 <Makoryu> > iterate (\x -> -x) 0.5
20:26:03 <lambdabot>   [0.5,-0.5,0.5,-0.5,0.5,-0.5,0.5,-0.5,0.5,-0.5,0.5,-0.5,0.5,-0.5,0.5,-0.5,0....
20:26:11 <wanghorn> blackdog: but should abs(-0.5) be causing a seg fault?
20:26:13 <Makoryu> > iterate (\x -> -x) (1.0 / 3.0)
20:26:14 <lambdabot>   [0.3333333333333333,-0.3333333333333333,0.3333333333333333,-0.3333333333333...
20:26:23 <Makoryu> wanghorn: o_o
20:26:29 <Axman6> wanghorn: .... no
20:26:30 <Axman6> never
20:26:33 <Axman6> wut?
20:26:37 <Axman6> ur doin it rong!
20:26:40 <Axman6> oh god!
20:26:47 <Axman6> :'O
20:27:10 <aavogt> @check \x y -> (x*y) == y*(x::Double)
20:27:10 <lambdabot>   "OK, passed 500 tests."
20:27:30 <Axman6> aavogt: i think that's guarsnteed by IEEE-754
20:27:34 <Axman6> though...
20:27:44 <aavogt> yes, it should be commutative
20:27:54 <blackdog> aavogt: what's that generating in x and y, though?
20:27:58 <Axman6> @check (\x y -> (x+y)-y == x +(y-(y::Double))
20:27:59 <lambdabot>  Unbalanced parentheses
20:28:05 <Axman6> @check (\x y -> (x+y)-y == x +(y-(y::Double)))
20:28:06 <lambdabot>   "Falsifiable, after 7 tests:\n-1.0\n-1.3333333333333333\n"
20:28:10 <ddarius> blackdog: Clearly not NaNs.
20:28:12 <blackdog> oh, still doubles but different order
20:29:00 <aavogt> @check \x -> x == (x::Double)
20:29:01 <lambdabot>   "OK, passed 500 tests."
20:29:08 <andrewsw> Saizan_: so, I did `liftM concat . mapM (f) where f :: String -> IO [Item]`
20:29:10 <ddarius> x .==. y = isNaN x && isNaN y || x == y
20:29:18 <andrewsw> but that seems like I'm missing something.
20:29:50 <Saizan_> andrewsw: that's what i'd write as well
20:30:12 <andrewsw> huh. okay, cool.
20:31:33 <Saizan_> except for s/(f)/f/ and s/liftM/fmap/, but that's inessential
20:32:08 <andrewsw> ah ha, yes. I knew there was something more like that.
20:32:11 <iaefai> Can anyone suggest any non-trivial code that outputs to stdout, but doesn't need input? I am testing my [cocoa] haskell editor's ability to run something with runhaskell, but all I have is two opengl based examples.
20:32:40 <Axman6> hello world...
20:32:54 <iaefai> Axman6: That is where the non-trivial comes into play.
20:33:07 <Axman6> main = putStrLn "Hello, World" >> main
20:33:08 <Axman6> >_>
20:33:12 <DigitalKiwi> i've seen some pretty complex hello worlds
20:33:26 <Axman6> iaefai: which editor are you using?
20:33:28 <iaefai> DigitalKiwi: That describes most of haskell
20:33:32 <DigitalKiwi> hehe
20:33:35 <iaefai> Axman6: My own, Hcode :p
20:33:41 <Axman6> heh
20:33:49 <Axman6> planning a release any time?
20:33:52 <iaefai> http://github.com/iaefai/Hcode
20:33:55 <aavogt> darcs
20:34:05 <iaefai> It isn't looking like much yet
20:34:13 <aavogt> I'm not sure if you can get it's main out of the library part though
20:34:27 <iaefai> aavogt: that would be too non-trivial :p
20:34:37 <iaefai> I will take axman6's code for now...
20:35:32 <iaefai> Axman6: Right now it pretty much displays line number and column, does autoindenting (using previous line's indent), correctly tabs with spaces, and then shifts code left and right four spaces.
20:36:03 <Axman6> sounds like it does a lot of what i want from an editor :)
20:36:10 <Axman6> thoug, i love TextMate too much to change
20:36:15 <iaefai> Axman6: We feel the same then :p
20:36:28 <DigitalKiwi> vim is all i need!
20:36:30 <iaefai> Axman6: My 'market' is for those too cheap to buy textmate I guess
20:36:38 <Axman6> heh
20:36:47 <DigitalKiwi> and more
20:36:59 <iaefai> I want something very convenient for me, and feels like a real nice cocoa program
20:37:03 <iaefai> vim is too alien
20:37:22 <iaefai> I am definitely not trying to compete with textmate, but I don't really see the attraction to it.
20:37:44 <aavogt> right, to interpret various larger projects, you need to be able to include various other stuff provided by cabal
20:37:51 <Makoryu> Auto-indentation in TextMate is a nightmare for any language with a "top-heavy" indentation pattern
20:37:53 <aavogt> like cpp macros for versionings
20:38:39 <iaefai> Makoryu: What do you mean top-heavy?
20:39:45 <iaefai> aavogt: My intent is to provide a sort of cabal file editor, haven't decided on how yet. Then you can either 'runhaskell' if you don't have a cabal file in the folder, or if you open a folder it will treat it more like a single window project.
20:40:01 <iaefai> I think espresso does a few things that I want to do, but applied to haskell
20:40:17 <Makoryu> iaefai: No balanced indentation tokens.
20:40:36 <iaefai> Makoryu: My auto-indentation is probably the most basic you can imagine
20:40:48 <Makoryu> So I gathered :p
20:41:06 <iaefai> I am not talking about the type that would autoindent after pressing enter after main = do; you would still have to press tab for that.
20:41:18 <iaefai> I really don't think it is the program's job to do all of that for you :p
20:41:26 <iaefai> I just don't want to press tab after every single enter
20:41:34 <Makoryu> I dunno, it's kinda nice when it does that
20:41:55 <iaefai> Sometimes an editor does too much for me that I find annoying.
20:42:16 <iaefai> For example, espresso has an autoinsertion for matching tags as I recall.
20:42:27 <iaefai> xcode does it with } else ...
20:42:38 <iaefai> It tends to annoy me pretty quickly.
20:42:56 <iaefai> Some form of module doc lookup would be very useful for me though
20:44:33 <Makoryu> iaefai: Well naturally you should be able to disable any autoindent feature.
20:44:46 <iaefai> Makoryu: this I don't support yet :p
20:44:52 <iaefai> I am planning a preferences window shortly
20:45:11 <iaefai> If there was a way to define simple auto indent rules, I would probably allow for them
20:47:22 <Axman6> if you could specify rules like: "where |", meaning align the following indented lines with the position of the |, that would be awesome
20:47:38 <pastorn> Axman6: there are skrypts for that
20:47:52 <pastorn> i saw a guy writing a deep implementation of a monad
20:47:54 <Axman6> skrypts?
20:48:51 <pastorn> having loads of 'X a >>= k -> ...'; 'Y a b c >>= k -> ...' and then just doing something like :align/>>=/g
20:48:55 <iaefai> Axman6: That would be a good idea
20:49:08 <pastorn> Axman6: vim skryptz0rz
20:49:17 <Axman6> vim--
20:49:32 <pastorn> Axman6--;
20:49:38 <fatalerrorx> can i manipulate raw memory with haskell?
20:49:44 <pastorn> fatalerrorx: yes
20:49:48 <aavogt> poke
20:49:51 <Axman6> not easily
20:49:53 <pastorn> fatalerrorx: what do you wish to accomplish?
20:49:56 <aavogt> yes easily
20:50:01 <fatalerrorx> i need a driver
20:50:03 <iaefai> Anyone know a good looking icon I could use for Hcode (and documents)? I have a very basic tile looking one with a lambda on it.
20:50:04 <Axman6> and we would all highly recommend against doing so
20:50:19 <fatalerrorx> Axman6: really?
20:50:19 <pastorn> fatalerrorx: use FFI
20:50:33 <Makoryu> iaefai: Replace the lambda with the new Amtrak-sponsored logo
20:50:41 <pastorn> fatalerrorx: write C functions doing all the nasty stuff and then do haskell wrappers
20:50:48 <fatalerrorx> pastorn: thats what i was thinking but can it to all that C++ can?
20:51:01 <pastorn> fatalerrorx: you can run C++ from C
20:51:09 <pastorn> i think that's how wxHaskell does it
20:51:14 <iaefai> Makoryu: You mean the lambda with the = after it?
20:51:23 <aavogt> the >>=
20:51:35 <Makoryu> iaefai: Yeah, the >Î»= thing
20:51:42 <fatalerrorx> pastorn: i wanted to support only one code
20:51:50 <fatalerrorx> not three :)
20:52:05 <pastorn> fatalerrorx: does a driver already exist?
20:52:06 <iaefai> Makoryu: I could do that, but hopefully with different colours - those ones look really tacky
20:52:19 <iaefai> I should look for a high resolution version
20:52:26 <Makoryu> iaefai: Yeah. The original version of that logo was grayscale
20:52:41 <fatalerrorx> could i possibly create a dll? and call it from C++
20:52:54 <pastorn> fatalerrorx: yes...
20:52:55 <fatalerrorx> can haskell make dlls?
20:53:04 <fatalerrorx> ghc*
20:53:11 <pastorn> fatalerrorx: http://www.haskell.org/haskellwiki/Calling_Haskell_from_C
20:54:16 <iaefai> I was just looking at the logo contest, and I love this icon: http://www.haskell.org/sitewiki/images/d/da/Haskell2v3.png
20:54:22 <iaefai> Just the H part
20:54:52 <fatalerrorx> nope its no good
20:55:09 <ddarius> iaefai: Do you see the secret lambda?
20:55:09 <fatalerrorx> i need C++ and need to compile with visual C++
20:55:21 <fatalerrorx> :(
20:55:32 <Axman6> ew
20:55:41 <iaefai> ddarius: The lighter part, yes
20:55:56 <pastorn> fatalerrorx: write your haskell code that does your computations, wrap that as C functions and call them
20:56:23 <iaefai> I wonder if I could get the svgs from chromakode :-)
20:56:27 <fatalerrorx> pastron isn't that the same issue as above?
20:56:44 <fatalerrorx> neeading to compile code with haskell
20:57:03 <pastorn> fatalerrorx: http://tinyurl.com/36btlqx
20:57:05 <chromakode> iaefai, hello!
20:57:09 <iaefai> The grayscale current logo I will try to do with illustrator and fix up a bit :p
20:57:13 <iaefai> chromakode: Hi :-)
20:57:18 <iaefai> lovely logo there
20:57:32 <pastorn> fatalerrorx: yes, your driver writing would then have to be on a separate branch, i presume
20:57:42 <fatalerrorx> Making Haskell libraries into DLLs doesn't work on Windows at the moment;
20:57:43 <iaefai> chromakode: I am making an editor for haskell (Hcode) on the mac and need an icon.
20:57:45 <chromakode> iaefai, thank you! let me see if I have the SVG up somewhere
20:58:07 <pastorn> fatalerrorx: but seriously? a driver in haskell? seems odd...
20:58:22 <iaefai> I would love to get some aqua style icon, but until that point I nice icon is a good idea too
20:58:33 <iaefai> Unfortunately I am no artist...
20:58:59 <chromakode> iaefai, http://chromakode.com/misc/haskell-logo2-2.svg
20:59:00 <pastorn> fatalerrorx: what's it for?
20:59:02 <Schalken> How can I specify -fglasgow-exts within a source file???
20:59:58 <Saizan_> {-# OPTIONS -fglasgow-exts #-} at the top
21:00:22 <fatalerrorx> pastron: exe protector
21:00:30 <iaefai> chromakode: Thank you. What did you make it in? Illustrator choked a little bit, but did load it up
21:00:38 <fatalerrorx> pastorn: don't want to make it in C++ or asm
21:01:33 <Schalken> Saizan_: Didn't work. :(
21:01:42 <pastorn> fatalerrorx: what i would do is that i'd write haskell functions that are formatBitsForOutgoing :: Opt1 -> Opt2 -> Opt3 -> [BitMask]
21:02:00 <pastorn> then i'd call those functions from C and let C handle the IO port stuff
21:02:07 <pastorn> and kernel messing
21:02:17 <fatalerrorx> ah ok
21:02:35 <fatalerrorx> is is possible to get ghc to produce a map file?
21:02:37 <pastorn> fatalerrorx: but i don't know what you're doing, so in reality i have no clue
21:02:44 <pastorn> a what?
21:02:49 <chromakode> iaefai, it's made in Inkscape :)
21:03:02 <iaefai> chromakode: did it take long?
21:03:13 <fatalerrorx> pastorn: file witch has names and addresses of functions in the binary
21:03:15 <Saizan_> Schalken: it goes above the module .. where line
21:03:29 <fatalerrorx> C++ can do this
21:03:35 <pastorn> fatalerrorx: then it's not a driver...
21:03:41 <pastorn> i thought you were doing hardware access
21:03:42 <Schalken> Saizan_: Yup, that's exactly where I've got it.
21:03:59 <Saizan_> Schalken: paste code and error then, please :)
21:04:20 <chromakode> iaefai, not too bad, probably 2-3 hours from concept to polishing
21:04:30 <iaefai> better than I could do :-)
21:04:41 <fatalerrorx> pastron: i couldn't describe it any other way but it needs to manipulated process memory
21:04:48 <iaefai> Closest real work I have done in illustrator is doing some drafting (I hate autocad)
21:05:04 <pastorn> fatalerrorx: why not use a debugger?
21:05:32 <iaefai> chromakode: Through the middle H (big) there is a light band going around the edges, do you remember why you made that design choice?
21:05:34 <Schalken> Saizan_: http://pastebin.com/ijuYcXbw
21:05:44 <fatalerrorx> pastorn: i attach the haskell binary to the exe then the haskell binary does its magic with the file then just to the main exe entry point
21:06:00 <fatalerrorx> jumps*
21:06:07 <uorygl> Hrm, there doesn't seem to be a quick and easy way to transfer a file from Windows to a Mac.
21:06:19 <uorygl> Bluetooth didn't work, anyway.
21:06:26 <Axman6> wifi?
21:06:31 <chromakode> iaefai, hmm, I think it was an attempt to render a shiny object in a uniformly lit white space. it's reflecting the ground surface
21:06:35 <Axman6> just create a network on the mac
21:06:41 <pastorn> fatalerrorx: so you want to create a haskell program that does something with an .exe before launching it?
21:06:44 <Schalken> Saizan_: There is obviously a lot more in the source file, which I can also paste if required.
21:06:51 <fatalerrorx> pastorn: YES
21:06:58 <pastorn> like... reading its symbol table and get stuff from it
21:07:12 <chromakode> iaefai, it's also good to stack light and dark lines next together -- humans perceive that as sharpness
21:07:12 <fatalerrorx> yes
21:07:30 <pastorn> fatalerrorx: why not just scrpt this? http://en.wikipedia.org/wiki/Microsoft_Visual_Studio_Debugger
21:07:54 <pastorn> that way you won't have to mess with binary data...
21:07:58 <fatalerrorx> has to be part of the exe
21:08:01 <iaefai> chromakode: ok, I see. I think that is the only part I have to remove, because I am doing this starting at 512x512 and it looks just a little out of place. But I think it is partly the svg -> illustrator -> photoshop that I am doing, could easily change colours a little bit.
21:08:21 <pastorn> fatalerrorx: that seems nasty...
21:08:33 <uorygl> Create a network on the Mac?  Ay.
21:08:43 <pastorn> why not just have a script that first runs the haskell program and then launches the 'real' program?
21:08:44 <chromakode> iaefai, feel free to do whatever you like with it :)
21:08:52 <Saizan> Schalken: mh, maybe you've to put it above the comments, try at the very first line
21:08:58 <fatalerrorx> pastron: yeah thats why i was wandering if i can do it in haskell or stick with C++
21:09:13 <pastorn> fatalerrorx: that's what i would do
21:09:30 <Schalken> Saizan: Aha! That's done it. Thanks. :D
21:09:30 <fatalerrorx> haskell would make life so much easier if it could be done
21:09:37 <Axman6> uorygl: airport menu -> Create Network...
21:09:46 <iaefai> here it is: http://i.imgur.com/eHYIq.png
21:09:49 <fatalerrorx> pastron: stick to C++?
21:09:53 <pastorn> fatalerrorx: main = do { exe <- readFile myProg; createAndPrintTable exe; system exe }
21:10:08 <chromakode> iaefai, ah, looks very flat!
21:10:25 <iaefai> My eyes see it 3dish
21:10:33 <fatalerrorx> pastorn: doesn't compile :)
21:10:46 <Saizan> Schalken: btw, -fglasgow-exts is quite broad (even if they are all fairly tame extensions), i think {-# LANGUAGE FlexibleContexts #-} is the specific one you need
21:11:01 <iaefai> v2: http://i.imgur.com/0JrYl.png  removed the inner glow, made it unsightly
21:11:14 <uorygl> Axman6: mmkay, what do I do then?
21:11:28 <fatalerrorx> pastron: it can't read the file it acts like a virus a unpacks the file in memory
21:11:29 <Axman6> get the windows computer to join the neteork
21:11:29 <pastorn> fatalerrorx: launching arbitrary programs from within a haskell program is easy
21:11:30 <Axman6> w*
21:11:35 <Schalken> Saizan: That's what I had already when it came up with that error. But it might have been because, again, it wasn't right on the first line.
21:11:49 <pastorn> i just can't remember the functions name right now...
21:12:10 <fatalerrorx> pastorn: needs to link itself with the target exe
21:12:15 <uorygl> Axman6: just connect to it, or more than that?
21:12:23 <pastorn> fatalerrorx: no, it doesn't
21:12:41 <pastorn> you just hardcode the target exe into the haskell program (or get that information elsewhere)
21:12:45 <Schalken> Saizan: And even on the first line, {-# LANGUAGE FlexibleContexts #-} doesn't work.
21:12:58 <iaefai> chromakode: I do have an idea that is just removing part of the light line, I think it will help in the area you are talking and in my eye
21:13:29 <Axman6> uorygl: i'm getting there. is the windows machine on the network you created?
21:13:36 <uorygl> Axman6: yeah, it seems to be.
21:13:50 <Axman6> ok, iun system prefs -> sharing
21:14:01 <chromakode> iaefai, cool, let me know when you've got more to share!
21:14:15 <fatalerrorx> pastron: i just could imagine how great it would be to create an asm obfuscator in hakell :)
21:14:16 <Axman6> tick file sharing, then click options
21:14:34 <pastorn> fatalerrorx: why would you want that?
21:14:38 <Schalken> Saizan: Do you know where I can find docs on this stuff?  Googling "Haskell "{-# LANGUAGE"" doesnt work. :(
21:14:42 <pastorn> it doesn't seem that hard, just tedious :(
21:14:45 <Axman6> and then click "Share files and folders using SMB (Windows)"
21:15:03 <uorygl> Should I check the box that says "On" next to my name?
21:15:08 <Axman6> yes
21:15:32 <pastorn> fatalerrorx: here's what you need to run stuff from within haskell: http://hackage.haskell.org/packages/archive/process/latest/doc/html/System-Process.html#v:runProcess
21:15:47 <aavogt> Schalken: they are called language pragmas
21:16:15 <aavogt> you can find a description either in the ghc-manual or maybe on the haskell-prime site
21:17:18 <fatalerrorx> pastorn: not what i need exe is never on disk :)
21:17:34 <fatalerrorx> its wrapped by the protector internally
21:17:39 <fatalerrorx> in its mem
21:17:51 <pastorn> fatalerrorx: ah, ok
21:18:04 <pastorn> fatalerrorx: can't you script visual studio?
21:18:21 <fatalerrorx> then unpack and decrypted then execution leaves the haskell stub and the program runs
21:18:25 <pastorn> like... 'compile this shit into memory, then freeze and give me the pointer'
21:18:29 <uorygl> Axman6: so then what?  My Mac isn't showing up in "Network" on Windows.
21:18:37 <Saizan> Schalken: you can start from the reference table http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html#id598783
21:18:45 <fatalerrorx> pastorn: yeah
21:19:00 <Schalken> aavogt: Thanks.
21:19:12 <pastorn> fatalerrorx: why do you do all this nastyness?
21:19:15 <fatalerrorx> its like linking some extra code into an exe
21:19:24 <Schalken> Saizan: Aha. LANGUAGE pragmas aren't supported in my GHC version at uni: http://www.haskell.org/ghc/docs/6.4.1/html/users_guide/pragmas.html.
21:19:26 <fatalerrorx> pastorn: writing and exe protector
21:19:29 <fatalerrorx> an*
21:19:35 <Axman6> uorygl: connect to \\computername.local\ i think. that options window should telly ou how to connect
21:19:36 <tensorpudding> Jesus, 6.4.1?
21:19:40 <Saizan> Schalken: ooh, that's ancient!
21:19:54 <Schalken> Saizan: Aye, Sep 2005.
21:20:02 <uorygl> Axman6: what options window?
21:20:11 <fatalerrorx> writing a asm code obfuscator would have been easier in haskell then C++
21:20:13 <Axman6> the windows where you turned on SMB sharing
21:20:14 <tensorpudding> Maybe you should get them to update to a new version.
21:20:26 <Axman6> huh, maybe not
21:20:30 <Schalken> Send your complaints to www.csse.unimelb.edu.au
21:20:41 <aavogt> it has features not present in current versions of ghc: http://www.haskell.org/ghc/docs/6.4.1/html/users_guide/type-extensions.html#linear-implicit-parameters
21:20:43 <pastorn> fatalerrorx: yes it would :)
21:20:47 <tensorpudding> Is it because they're also running a 5-year old OS?
21:20:51 <uorygl> Axman6: oh, I see what window you're referring to.
21:20:56 <pastorn> fatalerrorx: are you working on military stuff or what?
21:20:56 <fatalerrorx> pastorn: transforming code is what haskell would be awesome at
21:21:12 <fatalerrorx> pastorn: :) nah..
21:21:15 <uorygl> Axman6: it says that Windows cannot access it; check the spelling of the name; etc.
21:21:22 <Axman6> -.local
21:21:23 <Schalken> tensorpudding: I think the servers we SSH into run Solaris. I dont know what version.
21:21:23 <pastorn> then why all the paranoia?
21:21:41 <fatalerrorx> perhaps i could create a dll that did obfuscation?
21:21:51 <applicative> Schalken, but fglasgow-exts worked, I thought you said.
21:22:03 <fatalerrorx> and run it in memory with the protector
21:22:29 <Schalken> applicative: Yes. Saizan was suggesting I use LANGUAGE isntead. I was explaining why I couldnt.
21:22:34 <pastorn> fatalerrorx: no, you'd probably need 2xMem for the transformation
21:22:47 <fatalerrorx> hmm
21:22:48 <uorygl> Axman6: removing the .local doesn't help.  Let me try connecting to the Mac's IP address.
21:22:52 <wavewave> hello. I have  a question on subclassing with type family.
21:23:02 <pastorn> fatalerrorx: haskell being garbage collected and all
21:23:04 <Axman6> good idea
21:23:08 <wavewave> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25051#a25051
21:23:11 <pastorn> but why don't you save your binary to disk?
21:23:20 <fatalerrorx> pastron oh yeah forgot about that
21:23:22 <pastorn> that'd make everything A LOT simpler
21:23:24 <uorygl> Aha, the IP address worked.
21:23:40 <wavewave> Can I have a subclass with specialized type function instance?
21:24:09 <wavewave> the above code is not compiled..
21:24:22 <wavewave> any idea??
21:24:42 <uorygl> And woot, I got the file copied!
21:25:08 <fatalerrorx> pastron: that could be an option copy some mem from program pass it to haskell dll obfuscator and that would return some mem with obfuscated code and then you would inject that into process mem and wipe the stuff that was there before?
21:27:07 <uorygl> I was given an hour to upload that file and I got it up in a mere 90 minutes.  :P
21:27:14 <pastorn> fatalerrorx: why not just compile to disk, like normal people?
21:27:16 <Axman6> heh
21:27:16 <uorygl> But now I know what to do next time.
21:27:41 <uorygl> Thanks.
21:27:45 <Axman6> no worries
21:27:55 <fatalerrorx> pastorn: not safe :)
21:27:59 <Axman6> there may be easier ways, your first place to look should have been Apple's help docs
21:28:21 <pastorn> fatalerrorx: ok, then do it like this:
21:29:00 <pastorn> wait
21:29:12 <pastorn> i don't know how the **** you should do this
21:29:21 <tensorpudding> @type (****)
21:29:22 <lambdabot> Not in scope: `****'
21:29:26 <pastorn> this is retarded
21:29:31 * Axman6 thinks that's a good indication that you shouldn't do this
21:29:32 <pastorn> fatalerrorx: COMPILE TO DISK
21:29:42 * Axman6 fully agrees with pastorn 
21:30:35 <fatalerrorx> lol pastro
21:30:39 <pastorn> fatalerrorx: anything IS possible, but handling pointers etc. is just retarded... and you can't let you old procesess die and what not
21:30:43 <fatalerrorx> i'll do it in C++
21:30:54 <Axman6> -_-
21:31:16 <Axman6> fatalerrorx: i haven't been paying attention, but what you seem to be asking for sounds completely rediculous
21:31:18 <pastorn> fatalerrorx: ever heard of pipes?
21:31:22 <applicative> wavewave, pretty fancy type families you got there.  I will ask for a tutorial when you figure it out....
21:31:25 <fatalerrorx> i can already do it in C++ but code transformation is hard in C++
21:31:58 <fatalerrorx> the protector stops debuggers from debugging the main program
21:32:04 <pastorn> fatalerrorx: http://images.google.se/imgres?imgurl=http://doc.cat-v.org/unix/pipes/pipe.png&imgrefurl=http://doc.cat-v.org/unix/pipes/&usg=__7gSStETmZAgbrjkWE_ozzoIrlzo=&h=790&w=612&sz=90&hl=sv&start=2&sig2=Z2USR2e0pnNnO4qwOL0c4w&um=1&itbs=1&tbnid=muE_vG9KvMV30M:&tbnh=143&tbnw=111&prev=/images%3Fq%3Dhistory%2Bunix%2Bpipe%26um%3D1%26hl%3Dsv%26sa%3DN%26tbs%3Disch:1&ei=IhfVS_-JBZWQmwOXtNysDw
21:32:06 <pastorn> shit
21:32:08 <pastorn> sorry
21:32:13 <pastorn> http://doc.cat-v.org/unix/pipes/
21:32:40 <wavewave> applicative: it's not working :-/ anyway... my brain is hot now..
21:33:03 <pastorn> compiler | debugtable | obfuscator | run
21:33:10 <fatalerrorx> i think you all don't understtand that there arn't two programs its one program that has threads and shit to
21:33:16 <applicative> wavewave, I can well imagine.
21:33:28 <fatalerrorx> pastron: yeah
21:33:41 <applicative> pastorn, I wouldn't have thought the expression "massage data" existed in 1964
21:33:53 * Axman6 doesn't trust anyone who says "it's a program that has threads and shit"
21:35:15 <fatalerrorx> lol :)
21:35:30 <fatalerrorx> its a pain to describe
21:35:34 <pastorn> fatalerrorx: then just write one small haskell program that just transforms the program and call that from a c++ context
21:35:48 <pastorn> fatalerrorx: your c++ program would be
21:37:17 <pastorn> temp = getTempFile(); runProcess("myAwesomeHaskellProg", temp); free(oldLocation); ptr = loadFile(temp); jump(*ptr);
21:37:29 <pastorn> deleteFile(temp);
21:37:42 <pastorn> my C++-fu is seriously lacking...
21:37:54 <fatalerrorx> yeah except obfuscate the above with the protector
21:38:08 <pastorn> the what now?
21:38:11 <Axman6> "protector"
21:38:20 <DigitalKiwi> that's what she said
21:38:22 <fatalerrorx> you protect the protector when you have a protector
21:38:32 <fatalerrorx> :)
21:38:36 <pastorn> fatalerrorx: why don't you just rid your systems OF GODDAMN VIRII AND H4XX0RZ??!
21:38:42 <pastorn> then you can actually compile to disk
21:38:47 <pastorn> LIKE NORMAL PEOPLE
21:38:51 <fatalerrorx> lol
21:39:09 <Axman6> what are you trying to protect what from?
21:39:12 <fatalerrorx> its so the program can't be tampered with
21:39:30 <Makoryu> fatalerrorx: Your mom can't be tampered with.
21:39:38 <pastorn> Makoryu: nice
21:39:50 <Makoryu> This whole conversation seems to be about alien space bats
21:39:56 <fatalerrorx> Makoryu: rofl
21:39:57 <pastorn> Makoryu: she also only resides in memory?
21:39:58 <Axman6> fatalerrorx: the program can be tampered with
21:40:14 <Makoryu> So my question is: How do space bats see? There's no sound in space.
21:40:26 <fatalerrorx> Axman6: how?
21:40:37 <Axman6> no matter how good you think your protector is, there are smarter people out there than you, and they will find a way
21:40:41 <Axman6> they always do
21:40:43 <fatalerrorx> i'll have threads running checksums on mem
21:40:52 <fatalerrorx> Axman6: true
21:41:06 <fatalerrorx> Axman6: I want to stop the novices
21:41:09 <Makoryu> fatalerrorx: This is a lost cause. Please stop stapling the space bats to your program.
21:41:12 <Axman6> you're implementing a DRM system, and DRM systems have a very consistent history of not working
21:41:17 <fatalerrorx> not the hardcore crowd
21:41:41 <Axman6> well do things like strip the program
21:41:56 <pastorn> fatalerrorx: are you working on cool stuff like that crc checking code that blizzard has in WoW?
21:42:16 <pastorn> the code that's like tamper-proof?
21:42:27 <fatalerrorx> pastorn: similar but not for them :) I wish
21:42:46 <fatalerrorx> pastron: yes
21:43:31 <DigitalKiwi> the hardcore crowd cracks it and gives it to the lowly peons
21:43:41 <Axman6> ye
21:43:43 <Axman6> aye*
21:44:06 <tensorpudding> THis is the way it has been done before.
21:44:11 * ManateeLazyCat Plan to binding GIO, anyone interested? Maybe we can work together.
21:44:37 <DigitalKiwi> 23:39 < Makoryu> So my question is: How do space bats see? There's no sound in space.
21:44:41 <DigitalKiwi> but there is on myspace
21:44:55 <Axman6> not these days
21:45:00 <Axman6> ba doom cha
21:45:01 <Makoryu> So now they're Myspace bats?
21:45:06 <DigitalKiwi> yes
21:45:15 <DigitalKiwi> soon they will be face boo bats
21:45:15 <pastorn> is: How do space bats se
21:45:20 <pastorn> http://instantrimshot.com/
21:45:34 <DigitalKiwi> because that's where all the cool bats/people go
21:45:56 <ManateeLazyCat> File functions is not convenient for Gtk+ code, always need encode or decode.
21:46:31 <pastorn> fatalerrorx: if you really need it to work, what you need is in Foreign, System.Process and Data.Binary
21:46:33 <tensorpudding> mm trimshots
21:46:46 <pastorn> (binary is not part of the standard haskell libraries iirc)
21:47:17 <fatalerrorx> pastron: i need it to build the code obfuscator and i think i know how i will do it :)
21:47:31 <fatalerrorx> thanks for the help
21:47:46 <pastorn> fatalerrorx: i'd recommend using BNFC
21:47:53 <pastorn> or wait
21:47:54 <pastorn> sorry
21:47:58 <pastorn> i wouldn't
21:48:09 <pastorn> BNFC doesn't like binary data...
21:49:13 <Axman6> BNFC?
21:49:41 <pastorn> Axman6: Backus Naur form converter, or something...
21:49:48 <Axman6> ah
21:50:02 <ManateeLazyCat> pastorn: Link?
21:50:28 <pastorn> http://lmgtfy.com/?q=bnfc&l=1
21:50:44 <pastorn> shit
21:50:51 <pastorn> works on my swedish google :)
21:51:09 <pastorn> http://www.cse.chalmers.se/research/group/Language-technology/BNFC/
21:51:19 <portnov> re
21:51:23 <tensorpudding> Works here too
21:51:38 <ManateeLazyCat> pastorn: You search for me? Funny. :)
21:52:02 <portnov> what about `haskelldb'? is it alive? haskelldb.sf.net says last news from 2007 :/
21:53:55 <fatalerrorx> cool
22:01:21 <Axman6> hmm, anyone know a relatively simple binary format (file, or protocol)? i feel like writing a parser
22:01:39 <pastorn> Axman6: vCard
22:01:49 <pastorn> well, that's not binary
22:01:54 * Axman6 checks to see if a parser already exists
22:04:19 <Axman6> hmm, there is one, and vCards aren't particularly interesting to me
22:04:45 <ddarius> Axman6: The various ISO file systems.
22:04:55 <ddarius> Axman6: I wrote two readers in C# a while back.
22:05:01 <pastorn> Axman6: i wrote a java .class parser recently...
22:05:07 <pastorn> in applicative style
22:05:11 <pastorn> turned out pretty awesome
22:05:19 <Axman6> ddarius: there's various kinds?
22:05:28 <Axman6> pastorn: nice :)
22:05:35 <pastorn> Axman6: iso, nrg etc.
22:05:56 <Axman6> I kind of like the idea of a binary disassembler, but i know that would be a hell of a lot of effort
22:06:09 <Axman6> probably duplicated effort too
22:06:32 <Axman6> (by disassembler, i mean binary -> asm, not binary -> C etc)
22:09:03 <ddarius> Axman6: Yes, ECMA-119, ECMA-167, ECMA-167/2, ECMA-168
22:09:22 <Axman6> oh god, the acronym of doom!
22:09:24 <Axman6> >_>
22:09:53 <ddarius> There are probably newer ones for DVD
22:10:18 <ddarius> Probably ECMA-267 and others
22:11:02 <Axman6> i think i'm after something simpler. i've written one for bencoding used in .torrent files, and the bittorrent wire protocol (both for jlouis' combinatorrent)
22:11:10 <Axman6> i think that's what its called now
22:11:29 <ddarius> Axman6: ECMA-119 is actually really simple.  The others aren't much harder, just more detailed.
22:11:50 <Axman6> hmm, i should take a look. any tips on where to look?
22:12:05 <ddarius> http://www.ecma-international.org/publications/standards/Standard.htm
22:12:16 <ddarius> http://www.ecma-international.org/publications/standards/ECMA-119.HTM specifically
22:13:02 <Axman6> thanks
22:27:58 <Mathnerd314> hmm... are there any good embeddings of TeX/LaTeX into Haskell?
22:28:58 <Axman6> you can write literate haskell as LaTeX documents
22:29:13 <Axman6> wrapping your code in \begin{code} ... \end{code}
22:29:15 <Axman6> i think
22:29:27 <tensorpudding> Yeah.
22:29:42 <tensorpudding> the code environment does a lot of nice things
22:30:13 <Mathnerd314> that's Haskell in LaTeX
22:31:30 <Mathnerd314> I'm asking for the reverse
22:31:46 <Axman6> haskell generating LaTeX?
22:32:12 <tensorpudding> A LaTeX interpreter written in Haskell?
22:32:33 <Mathnerd314> one of those two, yeah
22:33:33 <Mathnerd314> don't care which
22:33:49 <Mathnerd314> *prefer that Haskell generates the LaTeX
22:34:46 <Axman6> i think pandoc can do that
22:35:15 <pastorn> pandoc <3 <3 <3
22:35:19 <pastorn> friggin awesome
22:36:23 <pastorn> btw, how does LaTeX work? How is the software built?
22:36:45 <tensorpudding> I thought LaTeX was a set of macros built atop TeX.
22:37:39 <Axman6> it is
22:38:00 <pastorn> but how does it work? how do they represent the actual data?
22:38:34 <rtaycher> is it possible to include a [Int] in a alg. data type?
22:38:45 <pastorn> yes
22:38:53 <Axman6> pastorn: how does it work?
22:38:55 <pastorn> data IntCollection = IC [Int]
22:39:16 <pastorn> Axman6: like... what's a character? what's a font? how does it know how to place stuff?
22:39:27 <fatalerrorx> Axman6: i writing a dissassembler :)
22:39:45 <Axman6> pastorn: have you ever used LaTeX?
22:39:46 <fatalerrorx> i can tell you its heaps of work
22:40:11 <pastorn> Axman6: yes, but i've never looked at the gritty details
22:40:36 <Mathnerd314> pastorn: get a copy of "Tex: The Program"
22:41:01 <pastorn> Mathnerd314: cool, thanks :)
22:42:05 <tensorpudding> TeX is written in WEB, the original literate programming language
22:42:23 <Mathnerd314> WEB = literate pascal
22:43:30 <tensorpudding> Though you don't need Pascal to compile TeX, since there is a program that turns WEB into C
22:44:05 <Mathnerd314> that's what I need; web2hs
22:44:24 <pastorn> Mathnerd314: do eeeeeet
22:44:41 <Mathnerd314> I wouldn't know the types
22:46:22 <pastorn> Mathnerd314: huh?
22:48:18 <Mathnerd314> porting C to Haskell makes things look really weird
22:48:36 <tensorpudding> To compile WEB to Haskell would require learning WEB, which does have types.
22:56:04 <rtaycher> I keep running into parse problems on my module names? anyone knw which common problems cause this?
22:57:13 <pastorn> rtaycher: maybe you have the wrong folder structure?
22:58:10 <pastorn> rtaycher: to always make it work i have ./A/B/C.hs and then always write 'module A.B.C where' and 'import A.B.C' (from a file residing at .)
22:58:55 <Axman6> rtaycher: can you paste the module line?
23:04:35 <rtaycher> I have also had a ton of trouble with nested modules but currently I simply have a hw1.lhs file w/ > module hw1 where
23:05:49 <siracusa> Haskell allows nested modules?
23:05:59 <Axman6> yes
23:06:04 <Axman6> well,depends what you mean
23:06:22 <siracusa> A module in a module
23:06:24 <Axman6> rtaycher: modules need to start with a capitol letter
23:06:27 <Axman6> no
23:06:45 <siracusa> Axman6: So what do you mean?
23:06:58 <Axman6> i meant you can have Foo. and Foo.Bar
23:07:26 <siracusa> Ah ok
23:12:33 <rtaycher> Axman6++, (as an aside I hate ghci parse errors they never seem to tell you anything, other then occasionly where the error is, ocasionally where in a line it is)
23:12:52 <Axman6> it all comes with experience
23:15:18 <pastorn> Axman6: you figured out what you want to parse?
23:15:30 <Axman6> i might give ISO files a go
23:15:58 <Axman6> though i still need to look at the standard. after weeks of there being shit all on reddit, i've finally found some stuff worth reading -_-
23:19:00 <pastorn> Axman6: this? http://dvd.wwwdotorg.org/specs/specs.html
23:19:54 <Axman6> i was going to start with http://www.ecma-international.org/publications/standards/Ecma-119.htm
23:21:41 <pastorn> Axman6: you writing it with Data.Binary + Applicative?
23:22:08 <Axman6> i might try using attoparsec, supposed to be super fast
23:25:43 <pastorn> Axman6: hm... you don't have the cool binary files you might need
23:25:55 <pastorn> getWord16be getWord32be etc...
23:26:15 <Axman6> really? hmm, i haven't looked into using attoparsec yet
23:26:31 <Axman6> i also have a feeling i won't have time to get any of this done :)
23:26:37 <pastorn> i'm just looking at the docs on hackage...
23:27:03 <pastorn> Axman6: using binary you'd get it done :)
23:27:19 <Axman6> i've used binary plenty of times though
23:27:23 <pastorn> oh, ok
23:27:26 <Axman6> cereal is quite nice too
23:27:31 <Axman6> you should check it out
23:27:57 <Axman6> lets you write parsers which can fail, and use Alternative
23:28:44 <Axman6> makes writing something like: parseFoo = parseName <|> parseAddress feasable
