00:05:47 <mae> hello.
00:06:10 <Cale> hello :)
00:12:44 <killing-joke> it may be late here, but my blurry eyes do not see an 'uninstall' in cabal
00:12:53 <killing-joke> is there a 'delete'?
00:12:55 <copumpkin> no
00:13:00 <copumpkin> space is cheap
00:13:17 <killing-joke> ah, yes, but my 'happy' she is broken
00:14:11 <killing-joke> and blocking the installation of haskell-src-exts
00:14:15 <systemfault> I'm sure how to ask that, anyone knows a page with clever haskell tricks like one-liners that does a lot
00:18:09 <killing-joke> ahah
00:18:12 <killing-joke> 'ghc-pkg list' and 'ghc-pkg unregister', according to the haskell-cafe ML  (http://www.mail-archive.com/haskell-cafe@haskell.org/msg50430.html)
00:18:21 <killing-joke> copumpkin, thanks
00:20:44 <copumpkin> @quote kmc
00:20:44 <lambdabot> kmc says: Right, for example Either (pun not intended)
01:00:20 <solrize> ddarius, that patterns paper is neat, can you put it on reddit?
01:01:32 <copumpkin> ddarius on reddit? surely not
01:01:49 <solrize> oh ok
01:16:12 <augur> copumpkin: oh do put it on reddit
01:17:27 <killing-joke> is there really no way to clean up a h0rked cabal install? i have rm'ed the whole thing twice now. the early packages install cleanly, but everything goes into the shredder when i try to install haskell-src-exts
01:19:16 <killing-joke> should i try to copy the files into place manually and register them one by one?
01:23:17 <tensorpudding> how does installing haskell-src-exts break things?
01:26:45 <killing-joke> tensorpudding, i exaggerated. it fails to install, and seems to break in a way that prevents other packages from installing correctly
01:27:15 <killing-joke> rm -rf .cabal takes me back to square one nicely
01:27:34 <kmc> killing-joke, what version of GHC and of haskell-src-exts?
01:28:17 <kmc> are you using Haskell Platform?
01:28:27 <kmc> also, can you put your haskell-src-exts build error on a pastebin?
01:29:58 <killing-joke> CentOS 5.4 latest i686  GHC 6.12.1 ... stage 2 booted by GHC version 6.10.4   haskell-src-exts-1.9.0
01:30:37 <killing-joke> kmc, no platform yet. the HOWTOs have not called for it.
01:35:08 <killing-joke> http://pastebin.org/153474    <---  haskell-src-exts fails
01:35:59 <Cale> killing-joke: It says that happy is missing. Is happy installed?
01:36:25 <tensorpudding> I get compile failures regarding happy a lot, for some reason it never gets pulled as a dependency even though it is.
01:36:44 <killing-joke> Cale, see the pastebin. it is installed and a notch higher version than required.
01:36:50 <tensorpudding> Wait, I'm thinking of alex...
01:39:39 <killing-joke> this is a fresh install on a machine that has never had a Haskell toolchain. started with GHC, then added Cabal. finally tried to pull HappStack components.
01:42:07 <Cale> killing-joke: hmm, weird, I totally don't get the same error
01:42:15 <Cale> I'm using GHC 6.10.4 though
01:42:32 <Cale> Also, I'm not running as root
01:42:35 <killing-joke> maybe i should clean up and start with six ten four, then
01:43:19 <Cale> Well, everything is supposed to be moving toward compatibility with  6.12.1
01:43:49 <killing-joke> Cale, that would be the Devil's Heisenbug ... "fails with increased privilege"
01:51:17 <quicksilver> is it as simple as hs/.cabal/bin not being in your path?
01:51:27 <quicksilver> I'm not sure how it checks for happy...
01:51:27 <killing-joke> i'll try it
01:59:11 <killing-joke> quicksilver, that might have been it. all kinds of new things are happening.
01:59:44 <quicksilver> building stuff as root does kind of suck, though.
02:00:20 <killing-joke> how so?
02:01:14 <quicksilver> compilers are not designed to run as root
02:01:24 <quicksilver> (the same is true for other tools run in the build)
02:01:53 <quicksilver> running them as root escalates any possible bugs or security holes they may contain into system-damaging problems or root-capable security holes.
02:02:20 <quicksilver> in general, you should run as little as possible as root, and stick to well-audited, well-understood, simple executables as root.
02:03:33 <killing-joke> while i agree with your analysis, i unfortunately find myself short of time for preparing these well-contained environments. :\
02:03:45 <killing-joke> my compromise is to use VMs
02:04:18 <killing-joke> this VM's purpose is to run GHC. still, building the toolchain as root is not a good idea, i agree.
02:05:16 <quicksilver> you don't need to prepare them.
02:05:37 <quicksilver> default linux installations come stocked with a wide array of simple well audited programs which are considered safe to run as root
02:05:41 <quicksilver> like 'mv' and 'cp' for example.
02:05:56 <quicksilver> 'gcc' and 'ghc' are not in the list of 'this has to be run as root' ;)
02:06:53 <killing-joke> i got a whole bunch of warnings on the build, but it seems to have completed correctly.
02:07:38 <killing-joke> after i am done with the dev setup, this build will be privilege-reduced, but that is a separate process that i am only partly involved in
02:08:36 <cads> what do we use in haskell to generate html templates? In ruby you can write html templates using ERB and use those files with piping laid back to the backend to pretty much make the face of your website. How do we do it in haskell style?
02:09:54 <Phyx-> I'm having a problem with cabal, on every cabal install it builds all dependencies and installs them. every time
02:09:58 <kmc_> cads, there are lots of options, search through hackage descriptions for "html" or "template"
02:10:07 <kmc_> i don't do this stuff so i don't know of a single best option
02:10:08 <arcatan> cads: there're some HTML combinator libraries (are they called that), which let you build HTML programmatically, Markaby-style
02:11:18 <kmc_> "press" provides supposedly Django-compatible templates
02:11:23 <arcatan> I've been thinking of porting Mustache template language to Haskell
02:11:57 <quicksilver> there's one called hstringtemplate (?) which looked quite good when I looked at it.
02:12:23 <Phyx-> anyone ever experience the same problem with cabal-install? it just started suddenly
02:12:40 <quicksilver> I think ERB is pretty disgusting actually
02:13:20 <quicksilver> but there are two extreme approaches IMO - one is to use convenient combinators to generate HTML elegantly from code.
02:13:32 <quicksilver> This is great for abstraction, modularity, and power, but it means you need programmers.
02:14:02 <quicksilver> alternative you use a lightweight templating language which looks as much as possible like plain HTML, but permits things like including files, simple substitutions, and loops.
02:14:22 <quicksilver> the main advantage of that is you can employ an HTML expert (instead of a haskell programmer) to build your templates.
02:16:32 <killing-joke> quicksilver, thanks for your insight. working now.
02:19:06 <quicksilver> killing-joke: just a lucky guess, but I'm glad it works.
02:22:42 <kevinulin> does hdbc take care of protecting against sql injection attacks or should i create my own regular expressions?
02:22:53 <michaelcdever> hey all, i want to benchmark the time and memory usage of some haskell programs, any ideas on how to do this?
02:22:56 <dhouthoo> wicket (a java web framework) has a nice way of separating code and html
02:23:25 <cads> thanks quicksilver, that was thought provoking
02:24:03 <Phyx-> if ghc-pkg lists a package, and ghc --make can't find it.... what can be wrong?
02:24:11 <dhouthoo> wicket might be nice to port to haskell ... lot's of anonymous inner classes there
02:24:12 <cads> I think I'd rather generate the html from some ivory tower of abstraction
02:25:32 <quicksilver> cads: if I was writing for myself, I'd use combinators and abstraction and a modular website.
02:25:52 <quicksilver> cads: but, in my day job, I run a website-based company and we need to work with non-programming designers, both internal and external.
02:26:07 <quicksilver> cads: so in practice we need something 'enough like' plain HTML that they can cope.
02:27:28 <arcatan> kevinulin: I believe if you use prepared statements, values are inserted into queries safely
02:27:48 <kevinulin> ya i was thinking that might be the case too
02:27:57 <quicksilver> prepared statements are inherently safe on most (all?) sane DBS
02:29:32 <arcatan> probably all
02:29:57 <cads> quicksilver: wouldn't it be less brain horsepower for you to use a commodity system at home? Or do you find the higher level approach is just easier?
02:29:59 <alpounet> hello, #haskell
02:33:27 <whald> hello, alpounet
02:34:25 <quicksilver> cads: it's just easier.
02:34:43 <quicksilver> cads: same reason you use functions rather than copy-pasting code each time you re-use it.
02:35:07 <tensorpudding> but function calls are slow!
02:35:20 <kevinulin> gotos are efficient
02:35:24 <quicksilver> tensorpudding: but, even in languages where that is actually true, we still do it.
02:35:25 <tensorpudding> this whole structured programming thing just isn't going to go nowhere
02:35:37 <quicksilver> because sometimes other things are more important than execution time.
02:56:10 <whald> i'm currently re-organizing my little Haskell project. I had something like "data Foo = Bar1 Float | Bar2 String | Bar3 [Foo]" and some method "magicFoo :: Foo -> Stuff"
02:56:31 <whald> this method pattern-matched against the Foo constructors and everything was nice
02:56:39 <pastorn> ok...
02:57:02 <whald> now i turned Foo into a class and made Bar1 and Bar2 instances of that
02:57:22 <whald> (because there will be several variants of Foo in the future)
02:57:46 <whald> i have no idea how the instance of Bar3 should look
02:58:06 <whald> maybe i'm missing some syntax, maybe some underlying understanding
02:58:14 <pastorn> whald: make a paste
02:58:44 <whald> that would be lengthy
02:59:09 <whald> i *think* my basic problem is that with the old style it was trivial to have a list of Foo
02:59:34 <whald> but i don't see how to make a list of different instances of "class Foo"
03:00:09 <pastorn> oh, you want a list of different kinds of Foo in the same list?
03:00:19 <whald> i think so
03:00:43 <pastorn> you can use forall
03:00:44 <quicksilver> whald: data AnyFoo = forall a . Foo a => a
03:00:46 <whald> (Foo a) => [a] means it's all the same foo?
03:00:56 <quicksilver> data Bar3 = [AnyFoo]
03:01:06 <quicksilver> oops, missing constructor, twice!
03:01:18 <quicksilver> whald: data AnyFoo = forall a . Foo a => MkAnyFoo a
03:01:25 <quicksilver> data Bar3 = Bar3 [AnyFoo]
03:01:31 <whald> whew! that's what that forall is for... it always puzzled me :-)
03:01:32 <quicksilver> always make that mistake in IRC.
03:01:42 <ToRA> quicksilver: probably also need {-# LANGUAGE ExistentialQuantificatoin #-}
03:01:50 <whald> np, thanks a lot quicksilver
03:01:50 <quicksilver> or RankNTypes
03:01:55 <quicksilver> but yes, ToRA is right.
03:02:01 <quicksilver> or even  Rank2Types
03:02:12 <quicksilver> although ToRA can't spel ;)
03:02:13 <whald> that's language extansion, yes?
03:02:16 <quicksilver> yes.
03:02:27 <quicksilver> s/oin/ion/
03:02:50 <ToRA> lol good spot
03:03:02 <whald> for some reason i fear that... is my Foo bad so i have to use extensions?
03:03:32 <quicksilver> ExistentialQuantification is widely considered to be a very sane extension.
03:03:41 <quicksilver> it's not a controversial one.
03:04:02 <quicksilver> It's possible to encode it in standard haskell98 as well, but not "locally".
03:04:02 <whald> is what i am doing so unusual that it was not considered in the original spec?
03:04:25 <quicksilver> you have to transform every function which uses the type inside out, so it's a global transform
03:04:30 <quicksilver> but it does map into haskell98
03:04:48 <quicksilver> I don't know the details of what existential quantification wasn't in haskell98
03:04:59 <quicksilver> it might be as simple as no clear view on the syntax to use?
03:05:06 <quicksilver> s/what/why/
03:06:17 <quicksilver> there is some discussion on http://hackage.haskell.org/trac/haskell-prime/wiki/ExistentialQuantification
03:07:11 <whald> ok, so if the experts agree that existential quantification is a good i'll just do that :-) thanks a lot!
03:11:02 <tapas> http://xmonad.org/xmonad-docs/xmonad/XMonad-StackSet.html
03:11:06 <tapas> haskell noob here..
03:11:17 <tapas> assume i have a function that takes a StackSet
03:11:23 <tapas> how to access e.g. the current "field"?
03:11:46 <RayNbow> <quicksilver> you have to transform every function which uses the type inside out, so it's a global transform  <--  is there a webpage or paper that describes this transformation?
03:12:34 <quicksilver> RayNbow: it's the CPS transform.
03:13:12 <quicksilver> RayNbow: if you have a function which returns AnyFoo, that's easy : b -> AnyFoo becomes Foo a => b -> a
03:13:26 <quicksilver> erm, no, that's backwards.
03:13:29 <quicksilver> let me try that again.
03:13:38 <quicksilver> if you have a function which *accepts* AnyFoo, that's the easy one.
03:13:47 <quicksilver> AnyFoo -> b becomes Foo a => a -> b
03:14:01 <quicksilver> (because Foo a => a -> b does, indeed, accept any argument of type a, where a is a Foo)
03:14:12 <quicksilver> the case where it returns AnyFoo is the harder case
03:14:53 <quicksilver> b -> AnyFoo has to become forall a r . Foo a => (a -> r) -> b -> r
03:15:54 <quicksilver> because you can't return 'an unknown type' but you can pass a function which accepts an unknown type and tell the caller to use that with whatever type they have.
03:16:14 * quicksilver hopes that was (a) clear and (b) correct :)
03:16:16 <zygoloid> that's not right either. it's :: forall r. (forall a. Foo a => a -> r) -> b -> r
03:17:20 <quicksilver> zygoloid: really? there's no rank-1 unfolding?
03:18:01 <zygoloid> the LHS of an arrow is contravariant so it'd be: forall r. exists a. Foo a => (a -> r) -> b -> r
03:18:27 <zygoloid> another view: the caller of this function is given back a Foo a instance, it doesn't provide one
03:19:05 <quicksilver> yes. I was confused.
03:19:19 <quicksilver> I could have sworn there was a way to code it up in rank-1
03:19:23 <zygoloid> the "=>" in the 'exists' formulation is also probably misleading
03:20:42 <whald_> wow. when i ran my "forall Foo" version my computer crashed. that's been the first crash since 01-30-2007.
03:20:56 <whald_> that was the day i tried vista
03:21:09 <whald_> must have been a crack in the continuum
03:21:16 <RayNbow> quicksilver, zygoloid: thanks :)
03:21:21 <whald_> now it works, thanks everybody :-)
03:21:23 <zygoloid> whald_: time to pray to santa?
03:21:31 <whald_> :-D
03:26:27 <jaspervdj> Is one of the Data.Binary guys here? dons, dcoutts?
03:27:06 <pastorn> jaspervdj: you found a bug?
03:27:38 <jaspervdj> pastorn: nope, it's more of a suggestion/remark
03:29:08 <pastorn> jaspervdj: whut?
03:30:13 <zygoloid> magic 8-ball says: some way of dealing with parse errors without generating a bottom would be nice
03:30:24 <jaspervdj> pastorn: The fact is that writing [Word8] lists to the builder monoid can be done way more efficient than (mconcat . map singleton)
03:30:49 <pastorn> hmm...
03:31:00 <jaspervdj> pastorn: there currently is no function to do that, and I could really use one
03:31:03 <pastorn> jaspervdj: have you done benchmarks?
03:31:24 <jaspervdj> pastorn: yep, I patched a 2x faster `fromList` function myself
03:32:43 <jaspervdj> (simple benchmark with criterion)
03:33:49 <quicksilver> jaspervdj: that's a bug in fusion then
03:34:07 <quicksilver> jaspervdj: I'm sure it's dons' intention that mconcat . map singleton compiles to perfect code
03:34:18 <quicksilver> fusion bugs have been caused by compiler upgrades in the past
03:34:29 <quicksilver> this complex multipass static optimisation seems a bit fragile.
03:35:06 <quicksilver> On reflection, I have been too emphatic. s/I'm sure/I strongly suspect/
03:35:06 <quicksilver> ;)
03:36:27 <osfameron> are you sure that you strongly suspect?
03:38:00 * hackagebot xhaskell-library 0.0.4 - Replaces/Enhances Text.Regex  http://hackage.haskell.org/package/xhaskell-library-0.0.4 (KennyLu)
03:43:47 <bbb> pl \x -> x
03:44:52 <burp> id
04:04:18 <Vitka> If I have a function [a] -> [(a,a)], is there an easy way to use it for MyType [a] -> [MyType2 (a,a)]?
04:04:52 <quicksilver> map MyType2 . f . unMyType
04:05:09 <quicksilver> not hard, although perhaps you were hoping for something shorter.
04:05:30 <Vitka> Ok I get the idea.
04:12:22 <Vitka> @pl \cs -> map CenterPair (pairs cs)
04:12:23 <lambdabot> map CenterPair . pairs
04:12:29 <Jafet> @hoogle m [a] -> (a -> b) -> [m b]
04:12:29 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
04:12:29 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
04:12:29 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
04:12:45 <Vitka> :)
04:13:58 <Jafet> > fmap (\x -> zip x x) (Maybe [1, 2, 3])
04:13:59 <lambdabot>   Not in scope: data constructor `Maybe'
04:14:03 <Jafet> > fmap (\x -> zip x x) (Just [1, 2, 3])
04:14:04 <lambdabot>   Just [(1,1),(2,2),(3,3)]
04:14:12 <Jafet> Not quite, eh
04:15:45 <mreh> has anyone heard of AFRPForceable? This is from back in 2003 when I was still wearing short trousers
04:16:14 <mreh> oh, I found it in the new package
04:16:14 <zygoloid> looks to be part of Yampa
04:16:24 * mreh sits in the corner
04:16:37 <mreh> what on earth does it do?
04:16:47 <mreh> hyperstrict evaluation?
04:16:58 <mreh> evaluates before you even knew you wanted it?
04:17:31 <zygoloid> deepseq
04:17:49 <zygoloid> or rather rnf i guess
04:18:30 <mreh> okay, I've never tried it before, the yampa project has gone so quiet recently
04:18:54 <mreh> have the creators gone onto doing more interesting things?
04:21:01 <mreh> -- Quick 'n dirty adaptation from old robot simulator. Could probably be
04:21:01 <mreh> -- done better in the new AFRP framework. (Henrik Nilsson 2003)
04:21:24 <mreh> do you think he's admitting Yampa is rubbish? AFAIK there is no *new* AFRP framework
04:56:31 <whald> i think i've found some bug in ghc. anyone wants to hear about it? how many times a day does a newbe come up with this? :-)
04:57:09 <kingping> ()s are confusing why not use {} for tuples ? ;)
04:57:13 <Zao> whald: Try it and see?
04:57:30 <Zao> whald: It may be that your GHC is built incorrectly or that you've misunderstood the nuances of some concept.
04:57:36 <Zao> whald: Or have enabled scary extensions.
04:57:52 <whald> ok, have a look at http://pastebin.com/4x6YMx8T (where's hpase?)
04:58:20 <Zao> Lambdacats eated it.
04:58:21 <whald> the only extension i use is that ExistentialQuantifications
04:58:37 <Zao> And this does what to GHC, and on which version?
04:58:45 <whald> this is obviously part of some raytracer
04:59:11 <whald> the commented - out version of "Intersectable AnyIntersectable" causes weird behavior, which is:
04:59:47 <whald> ghc: gives me an excpetion that "test.ppm" (the file where the image goes) is accessed after it was closed
04:59:59 <whald> ghci: does simply nothing
05:00:03 <whald> i type "main"
05:00:09 <quicksilver> well you've made an infinite loop
05:00:18 <quicksilver> intersect = intersect is just going to keep calling itself
05:00:19 <whald> and it just sits there (no cpu usage)
05:00:59 <whald> quicksilver: yeah, i see, but that should result in a stack overflow
05:01:06 <whald> well, it's tail-recursive
05:01:15 <whald> so it at least should hog the cpu
05:01:18 <Zao> Optimizations are fun.
05:01:27 <Zao> "this does nothing, let's nop"
05:01:43 <quicksilver> GHC can detect some kinds of infinite loop, depending on various settings
05:01:47 <Zao> If run under ghci, that would <loop>, wouldn't it?
05:01:54 <quicksilver> infinite loops have a variety of ways they can misbehave
05:02:29 <mreh> FLOATING_TYPE(GLfloat,tyConGLfloat,"GLfloat",CFloat) -- what the heck is this?
05:02:53 <McManiaC> is there a way to reexport a module without one, two functions
05:02:54 <McManiaC> ?
05:03:04 <McManiaC> module Foo (module Bar hiding (...)) where ...
05:03:27 <mreh> you only reexport what you import
05:04:01 <McManiaC> hmkay
05:04:09 <McManiaC> oh right
05:04:13 <mreh> I think that's correct... I feel the immortal words coming on... try it and see... sorry :(
05:04:19 <mreh> I can't remember
05:06:43 <McManiaC> yeh
05:07:07 <McManiaC> my mistake was something else
05:08:15 <McManiaC> @src Default
05:08:15 <lambdabot> Source not found. Maybe if you used more than just two fingers...
05:09:39 <benmachine> mreh: I imagine it's a CPP macro that instantiates some classes
05:16:33 <whald> > 1 / 0 :: Float
05:16:34 <lambdabot>   Infinity
05:16:50 <whald> @type Infinity
05:16:51 <lambdabot> Not in scope: data constructor `Infinity'
05:16:59 <whald> o.O
05:22:10 <stevenmarky> > (1/0) - (1/0)
05:22:11 <lambdabot>   NaN
05:23:17 <whald> stevenmarky: i think according to ieee infinity can only be used with certain operations, i need it for comparisons
05:23:26 <whald> > (1/0) * 2 :: Float
05:23:27 <lambdabot>   Infinity
05:23:51 <whald> > (2 > (1/0::Float))
05:23:52 <lambdabot>   False
05:23:55 <whald> > (2 < (1/0::Float))
05:23:56 <lambdabot>   True
05:24:09 <whald> so far that's good enough for me
05:27:46 <quicksilver> > (1/0) == (1/0 :: Float)
05:27:47 <lambdabot>   True
05:28:18 <quicksilver> > (1/0) - (1/0) == (1/0) - (1/0 :: Float)
05:28:19 <lambdabot>   False
05:28:52 <zygoloid> hmm, can GeneralizedNewtypeDeriving cope with existentials?
05:28:52 <whald> comparisons to NaN are always false by ieee definition -- is it safe to rely on this in haskell?
05:29:17 <zygoloid> 'data AnyIntersectable = forall a. Intersectable a => MkAnyIntersectable a deriving (Intersectable)'
05:29:23 <zygoloid> i guess tha'd be a different extension
05:30:54 <whald> zygoloid: i read in the ghc documentation that existantials do not mix with deriving, but maybe i got this wrong
05:36:29 <quicksilver> zygoloid: it has been suggested, but it doesn't feel like quite the same thing
05:36:48 <quicksilver> > isIEEE (0 :: Float)
05:36:49 <lambdabot>   True
05:36:56 <quicksilver> whald: probably safe if isIEEE is true
05:41:46 <whald> quicksilver "probably safe" wtf :-)
05:42:14 <whald> -wtf +ftw
05:42:19 <whald> tsss...
05:42:51 <idnar> @type isIEEE
05:42:52 <lambdabot> forall a. (RealFloat a) => a -> Bool
05:43:22 <Jafet> probablySafePerformIO
05:44:48 <EvanR> i switched from Data.ByteString to Data.Binary and Data.ByteString.Lazy, my output performance went from 99%/1% to 96%/4%, that is to say, my program does spends 96% of the time producing the data for the much faster test suite...
05:45:14 <EvanR> the c version reversed these numbers
05:53:00 <quicksilver> whald: it's made of software, right?
05:53:04 <quicksilver> whald: therefore, it is broken.
05:53:42 <quicksilver> software is bugs, tied together by garden twine.
05:54:07 <quicksilver> EvanR: so perhaps IO is not the bottleneck, but the data production is?
06:03:15 <arcatan> mm_freak: you wrote fastirc, didn't you? how do I do something inside the Bot monad, say join the channel in onConnect event handler?
06:06:51 <EvanR> quicksilver: ill try with -O2
06:07:55 <EvanR> another 1% change
06:08:31 <EvanR> quicksilver: the data production, im figuring, is via an infinite list from an unfoldr which does Word32 / Word64 arithmetic
06:08:47 <EvanR> i was hoping it would be as fast as C
06:09:02 <EvanR> hmm, 90% / 10%
06:10:36 <quicksilver> well, GHC doesn't compile arithmetic quite as well as GCC in the general case.
06:10:49 <quicksilver> but you'd expect to get fairly close
06:12:59 <EvanR> ill paste the code, see if anyone wants to identify bottlenecks :)
06:13:41 <EvanR> http://pastebin.com/C3s3yHZP
06:14:23 <quicksilver> EvanR: a hunch : replace all the Word with Int?
06:14:30 <quicksilver> (even if that breaks the program a bit)
06:14:37 <Saizan> System.Random is known to not be so fast
06:14:42 <quicksilver> I have some vague memory of someone talking about missing optimisation rules for Word
06:14:49 <Jafet> Why would Int be faster than... oh ok
06:14:56 <Jafet> There's always -fvia-c
06:15:09 <quicksilver> he's not using System.random is he?
06:15:13 <quicksilver> he's writing his own RNG
06:15:38 <Saizan> oh, sorry
06:15:51 <paulvisschers> Is there a way to create data during the execution of a monad, and store this data so that during another execution of the same monad, this data is available?
06:15:52 <zygoloid> he is using System.Random for 1025 random numbers
06:16:17 <EvanR> im using system to seed it
06:16:21 <quicksilver> ah yes
06:16:25 <quicksilver> that's a one-off cost though.
06:16:41 <EvanR> maybe the spliting into 1024
06:16:42 <quicksilver> try the Int/Word replace just in case I'm right about the missing optimisation rules
06:16:45 <EvanR> ints
06:16:48 <Saizan> paulvisschers: you mean a monadic action?
06:16:53 <quicksilver> and try -fvia-c
06:17:04 <zygoloid> EvanR: do you really need to use (.&. 0xffffffff) on (what appears to be) a Word32?
06:17:13 <paulvisschers> Saizan: I think so
06:17:36 <Jafet> paul, do you mean StateT
06:17:38 <EvanR> zygoloid: its a Word64, but youre right, fromIntegral should drop the top 32bits
06:17:56 <zygoloid> > fromIntegral (0x123456789 :: Word64) :: Word32
06:17:57 <quicksilver> EvanR: are you using a 64-bit GHC, by the way?
06:17:57 <lambdabot>   591751049
06:18:06 <zygoloid> > 0x23456789
06:18:07 <lambdabot>   591751049
06:18:07 <EvanR> no, and my computer is 32bits
06:18:09 <Saizan> paulvisschers: you've to do this explicitly, maybe the Monad you're using provides this feature, or you could add a StateT layer
06:18:14 <quicksilver> EvanR: ah well that could be a problem
06:18:15 <EvanR> but i need the top 32bits of the 32*32 mult
06:18:24 <quicksilver> Word64 is extraordinarily slow on a 32 bit machine
06:18:30 <paulvisschers> Saizan: The point is that I want to have a function that can cache intermediate values in a monadic action, but this data is hetergeneous and its type is dependent on the execution of the monad
06:18:33 <zygoloid> EvanR: have you tried making 'next' a bit stricter?
06:18:33 <EvanR> it was pretty fast in gcc :(
06:18:51 <quicksilver> it's said to be faster to write the calculation of paper and take it on a public bus to your local unversity and find a math undergrad to do the multiplication for you
06:18:56 <zygoloid> EvanR: next (c, hds, tls) = x' `seq` c' `seq` Just (x', (c', hds', tls'))
06:19:02 <quicksilver> than to use Word64 on a 32 bit machine.
06:19:13 <Saizan> paulvisschers: for the type issue you can use an existential or Dynamic
06:19:25 <EvanR> a ghc function to return (x,x) of the machine 32 bit multiplication would be ideal
06:19:36 <quicksilver> yes, I've often wanted that, EvanR
06:19:40 <quicksilver> sadly GHC exposes no such primitive
06:19:41 <EvanR> :(
06:20:09 <EvanR> well that i think explains things, ill add the other suggestions too just in case
06:20:22 <paulvisschers> Saizan: Would that work with any data?
06:20:39 <Saizan> paulvisschers: or just a sum type if you've a fixed set of cases
06:20:51 <zygoloid> EvanR: have you tried -fvia-C?
06:21:20 <Saizan> paulvisschers: Dynamic is like a sum type of everything that's Typeable
06:21:39 <Jafet> @remember quicksilver it's said to be faster to write the calculation of paper and take it on a public bus to your local unversity and find a math undergrad to do the multiplication for you, than to use Word64 on a 32 bit machine.
06:21:39 <lambdabot> It is stored.
06:21:58 <paulvisschers> Saizan: I'd rather not require Typeable if I can help it
06:22:31 <Saizan> paulvisschers: depends on what you want to do with this data
06:22:42 <Jafet> paul, is your question a StateT question or a dynamic typing question?
06:23:08 <paulvisschers> Jafet: I think it might be both
06:23:14 <Saizan> paulvisschers: do all these types provide a known interface and you'll only use that this interface to manipulate this data?
06:23:25 <Jafet> Well, it's easier if they're separate questions.
06:24:37 <paulvisschers> Saizan: The only thing that is controlled is the monad that they have to use, other than that, the data I'm actually caching could be anything
06:26:40 <paulvisschers> Saizan: At this point the monad is completely pure, so the cached value will always be the same as the inputted value, but I will extend the monad so that this might not be the case (but the cache function itself will still return the same data)
06:26:44 <Saizan> if you want to implement a standalone heterogenous cache, then it's either Dynamic or you've to parametrize it by a list of possible types like HList does
06:28:26 <paulvisschers> Saizan: But if I use the State monad (or StateT) with HList-like types, how do I know the type of my state?
06:29:50 <paulvisschers> Saizan: I think that is based on the contents of the monadic action
06:32:35 <Saizan> it's a list of possible types
06:32:51 <Saizan> however, maybe you just want the ST monad?
06:33:06 <Saizan> so you store things inside STRef's
06:33:15 <Saizan> and then you can read from those
06:35:13 <paulvisschers> Saizan: But how do I know the second time which STRefs I read from?
06:36:06 <paulvisschers> Saizan: "It serves to keep the internal states of different invocations of runST separate from each other", but I actually want to share it
06:36:42 <Saizan> well, you'll have to stay inside the same ST region
06:38:52 <EvanR-work> paulvisschers: you want STM ?
06:39:06 <McManiaC> can I "hide" an instance declaration from a module I import?
06:40:41 <paulvisschers> EvanR-work: I'm going to implement something like STM, but for databases, which involves retrying while skipping user interactions (and using the cached value instead)
06:40:59 <paulvisschers> EvanR-work: But I don't think I actually need STM for it
06:42:53 <pozic> What do you think about a feature such that take [1,2,3] 1 == take 1 [1,2,3]?
06:42:58 <paulvisschers> Saizan: So if I understand you properly, I should translate my own monad action to an ST monad action and embed STRefs during this translation, and then if I run it a couple of times, it should use the same STRefs?
06:43:19 <idnar> pozic: how would that work?
06:43:46 <Daerim> pozic, sounds like it could cause a lot of problems
06:43:53 <pozic> Daerim: like?
06:43:56 <paulvisschers> pozic: that wouldn't be very general, like for subtract 2 1
06:44:17 <pozic> paulvisschers: yes, but for a lot of purposes it would work.
06:44:18 <Saizan> paulvisschers: you've to create the STRefs only once if you want them to be same ones
06:44:22 <Daerim> pozic, the compiler has to guess the order of the parameters?
06:44:48 <Daerim> sounds like the source of a ton of hard to debug bugs
06:44:49 <Jafet> pozic, er, just flip take.
06:45:09 <pozic> Daerim: it simply looks at what the users gives and then matches that what whatever the "canonical" function expects.
06:45:25 <pozic> Some C++ template libraries do this.
06:45:29 <Daerim> pozic, but that matching is non trivial, and what if it does it wrong?
06:45:36 <paulvisschers> Saizan: Right, so I would create them during the translation from my own monad to the ST monad (and embed them into the actions)
06:45:36 <pozic> Daerim: uh, that is trivial.
06:45:44 <Jafet> Using C++ in your argument is a sure way to fail
06:45:45 <Saizan> pozic: type inference
06:45:47 <pozic> Daerim: that definitely does not count as non-trivial.
06:46:04 <Saizan> paulvisschers: yeah
06:46:18 <Daerim> for two arguements, maybe not, but for more?
06:46:38 <Jafet> pozic, all functions in Haskell take one argument.
06:46:58 <pozic> Jafet: ok, that is sort of a good argument :)
06:47:07 <paulvisschers> Saizan: I'll to get something like that working, I'll keep you posted, thanks
06:47:29 <pozic> Jafet: but you could interpret f a b c d slightly different.
06:47:49 <pozic> Jafet: actually, it doesn't matter.
06:49:01 <Saizan> my main argument is that it'll decrease the information available for type inference, and it'll reduce readability
06:49:25 <pozic> Saizan: compile time will go up, but I don't agree on the readability issue.
06:49:26 <Saizan> (which is more or less the same point)
06:49:42 <pozic> Saizan: IMHO, flip is line noise.
06:49:55 <quicksilver> pozic: consider foldr, which has arguments of types "b" and "[a]"
06:50:11 <pozic> quicksilver: ok, that's a better example.
06:50:13 <quicksilver> pozic: a type like [Int] could be either of those
06:50:21 <pozic> quicksilver: yes, I made the connection.
06:50:22 <Saizan> pozic: it's not a matter of compile time, it's a matter of increased need for type annotations
06:50:29 <quicksilver> so with the (partially applied) "foldr [1,2,3]"
06:50:37 <quicksilver> which argument did I intend to fill in? the seed or the list?
06:51:13 <quicksilver> I think if you are prepared to ditch partial application and currying, then it is probably more practical.
06:51:20 <pozic> quicksilver: ok, but still there are lots of cases in which it does work.
06:51:27 <quicksilver> yes, there are.
06:51:54 <quicksilver> although it interacts a bit badly with typeclasses too
06:51:58 <quicksilver> consider genericTake
06:52:01 <quicksilver> :t genericTake
06:52:02 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
06:52:10 <paulvisschers> Saizan: Actually, I see here that the ST monad also has a single state type, so it would actually be impossible to have STRefs of more than one type
06:52:12 <ivanm> @hoogle Maybe a -> Bool
06:52:12 <lambdabot> Data.Maybe isJust :: Maybe a -> Bool
06:52:12 <lambdabot> Data.Maybe isNothing :: Maybe a -> Bool
06:52:13 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
06:52:16 <ivanm> oh, duh
06:52:24 <pozic> paulvisschers: that is sort of the point of ST.
06:52:29 <quicksilver> with "genericTake [1,2,3]" am I thinking of an exotic Integral instance for lists, perhaps?
06:52:38 <Saizan> paulvisschers: the 's' is not the state type
06:53:04 <pozic> paulvisschers: you can do newSTRef "hi">>newSTRef (4::Int), though.
06:53:21 <Saizan> quicksilver: it interacts badly with all polymorphism, and with everything that's not already of a specialized type during inference :)
06:54:09 <paulvisschers> Ah right, the s is a state thread (whatever that means exactly)
06:54:53 <McManiaC> how can I "catch" a "Prelude.read: no parse" exception in a pure function?
06:54:54 <Saizan> it's kind of a tag to keep STRefs from escaping
06:55:28 <dubhrosa> can anyone recommend some code or tutorials to read that illustrate the techniques that work when manipulating reasonably complex record style data? I'm trying to implement a simple enough stock exchange matching engine (about 40 lines of c++) in Haskell, and I'm struggling a bit with the general lack of immutability...
06:55:37 <quicksilver> McManiaC: don't.
06:55:42 <quicksilver> McManiaC: use "reads" instead.
06:55:53 <quicksilver> McManiaC: "read" should only ever be used when you know that exception cannot occur
06:56:52 <McManiaC> hm
06:57:33 <quicksilver> > let maybeRead s = case read s of [(x,"")] -> Just x ; _ -> Nothing in (maybeRead "123.4" :: Maybe Int)
06:57:34 <lambdabot>   *Exception: Prelude.read: no parse
06:57:45 <quicksilver> > let maybeRead s = case reads s of [(x,"")] -> Just x ; _ -> Nothing in (maybeRead "123.4" :: Maybe Int)
06:57:46 <lambdabot>   Nothing
06:57:50 <Saizan> dubhrosa: fclables, data-accessor, and others on hackage are packages meant to help working with records
06:58:56 <Saizan> dubhrosa: immutability shouldn't be a problem when it's straightforward to create a new version of your record even if you've to update a deeply nested field
07:00:55 <dubhrosa> thanks, they look interesting; wrt immutability I think it's just my long background in imperative programming that's in the way
07:02:07 <dubhrosa> the matching algorithm naturally walks through existing orders, removing those that are fully matched against the new order and emitting trades as it does so, to translate into a more functional form is proving a bit tricky for me
07:05:07 <Saizan> that sounds like [Order] -> ([Order],[Trade]), which might be convenient to write as "State [Order] [Trade]" or "[Order] -> Writer [Trade] [Order]", or maybe combine both monads
07:05:21 <Saizan> and you might need some other structure rather than lists
07:06:00 <Saizan> anyhow, if you find some repetitive pattern in your code there's probably a way to abtract it out
07:07:49 <dubhrosa> yep, that's pretty much the signature, thanks for the suggestions, I'll give them a try
07:07:49 <Axman6> Saizan: any chance you could give me a quick explanation of what the Writer monad does?
07:08:29 <quicksilver> Axman6: are you happy with the State monad?
07:08:41 <Axman6> yep
07:08:47 <Axman6> and Reader
07:09:00 <quicksilver> Axman6: the writer monad is a state monad which you can't read, and all you can do is `mappend` to it.
07:09:05 <ivanm> hey Axman6
07:09:08 <Axman6> o/
07:09:10 <Jafet> It writes, but secretly
07:09:15 <Axman6> :O
07:09:23 <ivanm> Jafet: ooooohhhh.... so it's a sikrit? :o
07:09:23 <quicksilver> at least, that's not how it's implemented but that's a simple way to imagine it.
07:09:29 <DrTeggy> Think log writing
07:09:37 <Jafet> ivanm, sshh!
07:09:45 <Jafet> Don't want to give it away to axman
07:09:53 <Axman6> quicksilver: got a quick, canonical example by any chance?
07:09:57 <quicksilver> you kind of can read it , because of 'listen', but nobody uses listen and it breaks the typeclasses anyway.
07:10:47 <quicksilver> > runWriter (tell ["ssh"] >> tell ["it's a secret"] >> return 3)
07:10:48 <lambdabot>   (3,["ssh","it's a secret"])
07:10:52 <Axman6> how can you listen to writing anyway?
07:10:58 <quicksilver> so that "returned" 3, but also "logged" two messages.
07:11:07 <Jafet> Scritch, scritch
07:11:11 <Axman6> ah, i see, that's quite handy indeed
07:11:15 <quicksilver> Axman6: that's why it's in Control.Monad.Mixed.Metaphor.
07:11:28 <Axman6> heh
07:13:40 <DarkUnicorn> quicksilver: is that to get out of the IO monad?
07:13:54 <DarkUnicorn> or better, to not get into it
07:14:02 <ivanm> Axman6: some pens make a scratching sound when you use them; hence you can listen to people writing! :p
07:14:18 <Jafet> Not all writes are IO.
07:14:42 <Axman6> @src Writer
07:14:42 <lambdabot> Source not found. My pet ferret can type better than you!
07:14:47 <EvanR-work> someone explain simply what the Writer does / is for
07:15:24 <Jafet> @lyah
07:15:24 <lambdabot> Unknown command, try @list
07:15:42 <Jafet> Erm
07:15:48 <EvanR-work> allows you to use a write command in the middle of pure code?
07:15:48 <writer> http://www.haskell.org/all_about_monads/html/writermonad.html
07:16:10 <Axman6> EvanR-work: there's nothing at all impure about Writer
07:16:15 <Jafet> It's writer in person!
07:16:19 <EvanR-work> yes
07:16:24 <writer> :D
07:16:27 <Axman6> the example quicksilver showed how you can do some simple logging
07:16:32 <ivanm> EvanR-work: ummm, Jafet and quicksilver just said what it's for
07:16:43 <Saizan> it let you produce some kind of log (for an abstract sense of log) as a "side-effect" of your computation
07:17:01 <EvanR-work> right, so in order to use it, you have to do some imperative stuff in between normal computations
07:17:07 <EvanR-work> functional style
07:17:09 <ivanm> EvanR-work: not at all
07:17:21 <ivanm> well, to actually log something, you use the WRiter monad itself
07:17:28 <EvanR-work> yes
07:17:36 <ivanm> but it's not really imperative... >_>
07:17:45 <EvanR-work> seems like it is
07:17:51 <EvanR-work> do tell x; tell y; tell z;
07:18:00 <Axman6> well, it's a monad
07:18:03 <ivanm> EvanR-work: I can write list monad code that uses a do block
07:18:07 <ivanm> doesn't make it imperative
07:18:09 <Axman6> that's how most monadic code looks
07:18:22 <EvanR-work> list monad doesnt seem imperative, this does
07:18:25 <ivanm> though I suppose ordering _does_ matter, so you could argue that it is partially imperative
07:18:28 <Axman6> > do { [1,2,3]; [4,5,6]}
07:18:29 <lambdabot>   [4,5,6,4,5,6,4,5,6]
07:18:48 <ivanm> EvanR-work: but any kind of "logging" would have the same imperative nature, because you want one logging message to appear before another
07:18:52 <Jafet> To avoid further confusing newbies who have read Haskell blog tutorials, IO shall be renamed to Monad in the next Haskell standard.
07:18:54 <EvanR-work> yes
07:18:57 <ivanm> even if you're using ("foo"++)
07:19:06 <ivanm> Jafet: :o
07:19:14 <ivanm> Axman6: :o
07:19:30 * ivanm sees how it works, but wonders why anyone would do such a thing
07:19:40 <Jafet> > replicateM 3 [4,5,6]
07:19:41 <lambdabot>   [[4,4,4],[4,4,5],[4,4,6],[4,5,4],[4,5,5],[4,5,6],[4,6,4],[4,6,5],[4,6,6],[5...
07:20:02 <Axman6> @src replicateM
07:20:02 <lambdabot> replicateM n x = sequence (replicate n x)
07:20:06 <EvanR-work> its imperative because you sequence commands to do something, in this case, write
07:20:14 <EvanR-work> semantics here
07:20:40 <EvanR-work> "foo"++"bar" is a computation, you dont expect side effects
07:20:57 <EvanR-work> i understand its all the same theoretically
07:21:55 <Jafet> Imperative does not mean side-effecting
07:22:12 <EvanR-work> it means commands
07:22:38 <EvanR-work> writer lets you use an imperative style
07:22:39 <ivanm> Jafet: exactly
07:22:52 <ivanm> EvanR-work: do-notation lets you use an imperative style
07:22:54 <ivanm> @wn imperative
07:22:55 <lambdabot> *** "imperative" wn "WordNet (r) 2.0"
07:22:55 <lambdabot> imperative
07:22:55 <lambdabot>      adj 1: requiring attention or action; "as nuclear weapons
07:22:55 <lambdabot>             proliferate, preventing war becomes imperative";
07:22:55 <lambdabot>             "requests that grew more and more imperative" [ant: {beseeching}]
07:22:57 <lambdabot> [5 @more lines]
07:23:00 <ivanm> @more
07:23:00 <lambdabot>      2: relating to verbs in the imperative mood
07:23:01 <lambdabot>      n 1: a mood that expresses an intention to influence the
07:23:03 <lambdabot>           listener's behavior [syn: {imperative mood}, {jussive
07:23:05 <lambdabot>           mood}]
07:23:06 <EvanR-work> >_<
07:23:06 <Jafet> I see writer as aspect programming, not as imperative programming
07:23:07 <lambdabot>      2: some duty that is essential and urgent
07:23:17 <Jafet> @moar
07:23:17 <lambdabot> Maybe you meant: map more
07:23:17 <DarkUnicorn> quit
07:23:21 <DarkUnicorn> :)
07:23:34 <EvanR-work> hmm.
07:23:49 <Saizan> oh, god, stop debating "imperative", you should debate clear and simple semantics vs. rats' nest
07:23:59 <EvanR-work> so do notation with any monad can be considered imperative
07:24:33 <Saizan> one way to get a rats' nest is with uncontrolled mutability that you commonly find in imperative languages, but that's an accident, rather than the substance
07:25:10 <EvanR-work> i like simple semantics
07:25:40 * ivanm -> sleep
07:26:03 <Saizan> sorry for the rant :)
07:26:36 <EvanR-work> why do people look at me funny when i tell them uncontrolled mutable style leads to rats nest :(
07:26:59 <EvanR-work> is there a fundamental problem with imposing disciple on style?
07:27:03 <EvanR-work> discipline
07:27:07 <EvanR-work> gah
07:27:51 <EvanR-work> perjorative terms 'bondage of discipline language' appear
07:27:52 <Jafet> I impose my disciples with style
07:27:56 <EvanR-work> bondage and discipline
07:27:58 <Jafet> And bondage!
07:28:14 <EvanR-work> i cant spell anything
07:28:59 * EvanR-work beats his program with a hammer until it compiles
07:30:36 <Saizan> one of the reasons might be a reaction against the need to better express to the machine what you want to do
07:30:39 <quicksilver> (tell ["hi"] >> tell ["there"]) is no more (also, no less) imperative than (["hi"] ++ ["there"])
07:30:45 * stevenmarky /title #haskell: bondage and discipline.
07:31:06 <quicksilver> since, give or take a tuple, they are the same expression.
07:31:08 <EvanR-work> quicksilver: that makes sense
07:31:10 <Jafet> evan, screwing it always works
07:31:16 <Jafet> But that takes longer
07:31:22 <Saizan> with a substantial use of types you end up putting much more information in your code
07:31:57 <Saizan> (or readily available one, at least)
07:32:00 <roconnor> quicksilver: (tell ["hi"] >> tell ["there"]) is more impreative
07:32:15 * quicksilver waits for the punchline.
07:32:16 <Axman6> > runWriter (tell "test" >> tell "ing")
07:32:17 <lambdabot>   ((),"testing")
07:32:19 <roconnor> quicksilver: no wait I take that back
07:32:23 <Axman6> :t tell
07:32:24 <lambdabot> forall w (m :: * -> *). (MonadWriter w m) => w -> m ()
07:32:28 <quicksilver> (because "tell!" is the imperative form of the verb?)
07:32:41 <EvanR-work> yes
07:32:59 <Axman6> @src Writer (>>=)
07:32:59 <lambdabot> Source not found. I am sorry.
07:33:03 <Axman6> :(
07:33:09 <roconnor> quicksilver: Probably the writer monad laws say that it is equivalent to tell (["hi"] ++ ["there"]) ... not that I know what the writer monad laws are.
07:33:10 <Axman6> right, sleep time
07:33:30 <quicksilver> roconnor: yes, they do.
07:33:42 <quicksilver> roconnor: tell a >> tell b === tell (a `mappend` b)
07:33:51 <Axman6> :t tell "test"
07:33:52 <lambdabot> forall (m :: * -> *). (MonadWriter [Char] m) => m ()
07:33:54 <roconnor> quicksilver: I was concerned that tell might have some side effect, but then I realized that it probably couldn't
07:34:00 <roconnor> sorry about my outburst
07:34:58 <quicksilver> Axman6: (a,w) >>= f = let (b,w') = f a in (b,w `mappend` w')
07:35:13 <EvanR-work> its pure so has no 'real' side effects, but side effects dont imply imperative
07:35:37 <quicksilver> well, nobody can agree what imperative means, and I won't argue with you about meanings of words.
07:35:56 <EvanR-work> no one likes to take the simple routes around here ;)
07:36:02 <roconnor> why do side effects not imply imperative?
07:36:17 <quicksilver> but I will tell you what I mean by imperative; a programming language in which you issue commands, where a command may very well have non-local or hard to model semantics
07:36:34 <EvanR-work> of the top of my head, you may have a language that doesnt consist of commands, but has the effect of causing side effects anyway ;)
07:36:38 <EvanR-work> like c
07:36:53 <quicksilver> since the Writer monad has a very clear declarative semantics it is a poor example of imperative programming for me.
07:36:56 <Jafet> If a programming languages has only simple semantics, it is not worth programming in...
07:37:15 <quicksilver> whilst the IO monad has non-local and hard to model semantics and therefore I'm content to describe it as imperative.
07:37:30 <Jafet> There is one thing I can tell you, nested monad transformers are incredibly hard to pick apart
07:37:40 <elly> [[/w 38
07:37:42 <elly> oops
07:37:42 <Eelis> roconnor: if the side effects are commutative then the order doesn't matter, which makes it not very imperative
07:37:48 <quicksilver> you may invent your own definition of imperative and come to a completely different conclusion if you wish, I will not prevent you.
07:37:49 <Eelis> *their order
07:38:03 <Jafet> It's like shopping in new york, lifts everywhere.
07:38:05 <EvanR-work> monoidal side effects!
07:39:14 <EvanR-work> memory writes act like that
07:39:19 <EvanR-work> doesnt matter what order to do them in
07:39:21 <roconnor> Eelis: I can accept that
07:39:29 <roconnor> EvanR-work: wtf?
07:39:38 <EvanR-work> as long as you do all the writes
07:39:42 <EvanR-work> the end result is the same
07:39:57 <roconnor> EvanR-work: I'd argue that is side effect free
07:39:58 <Jafet> That depends on what "memory" is.
07:39:59 <quicksilver> unless two of them are to the same location, of course
07:40:12 <EvanR-work> an abstract register machine or turing tape or something
07:40:30 <quicksilver> indeed hard disk controllers re-order writes
07:40:36 <cypher> non-haskell question: how do you usually type bnf grammars in latex?
07:40:38 <quicksilver> and, for all I know, memory controllers may do so topo
07:40:53 <Jafet> cypher, I don't. ##latex
07:41:16 <Jafet> It gets even more exciting with SMP architectures
07:41:25 <quicksilver> I think EvanR-work means 'commutative monoidal side effects' not just monoidal.
07:41:34 <quicksilver> most side effects are monoidal.
07:41:35 <EvanR-work> ah
07:41:38 <cypher> Jafet: thanks, I'll ask there
07:41:48 <EvanR-work> communtative
07:41:52 <EvanR-work> gah
07:41:55 <roconnor> quicksilver: do harddisk controlers reorder writes to the same sector?
07:42:02 <quicksilver> roconnor: one assumes not :)
07:42:10 <quicksilver> roconnor: but this is not an area in which I claim expertise.
07:42:38 <quicksilver> roconnor: they perhap coalesce writes to the same sector, if they affect different bytes within one sector.
07:42:55 <quicksilver> but I don't think so.
07:42:59 <EvanR-work> if they didnt, they could drop some
07:43:06 <quicksilver> I think hard disk controllers only ever work on the whole-sector level.
07:43:30 <quicksilver> roconnor: in order to argue that something is 'side-effect free' you have to decide what the 'side' is.
07:43:50 <quicksilver> I have previously argued that the IO monad is 'side-effect free' because its effects are precisely the main effect
07:43:54 <quicksilver> they are not 'side' to anything.
07:44:04 <roconnor> quicksilver: yea but if you can never observe side effects then they aren't realy there
07:44:11 <quicksilver> whereas, in the C expression "a = f(x) + g(y)"
07:44:18 <quicksilver> the "main" effect is the evaluation of that expression
07:44:26 <Jafet> If you deal with security, you know damn well what side effects are.
07:44:28 <quicksilver> and any "side" effects which f and g have are 'side'
07:44:41 <Jafet> Fortunately, Haskell is not yet ready for security applications, so we don't have to worry about those.
07:44:48 <quicksilver> because they're "side" to the main evaluation.
07:44:52 <quicksilver> Jafet: what do you mean?
07:45:12 <Jafet> I'm probably agreeing with you, if you want to know
07:50:07 <EvanR-work> a commutative monoid is also called abelian? or is that only for groups
07:52:52 <copumpkin> @faq can haskell do security applications?
07:52:53 <lambdabot> The answer is: Yes! Haskell can do that.
07:52:56 <copumpkin> Jafet: ahem
07:53:08 <Jafet> Lies!
07:53:14 <copumpkin> sorry, lambdabot said so
07:53:20 <copumpkin> bots are never wrong
07:53:47 <elly> lambdabot is programmer to be right.
07:54:19 <stevenmarky> elly isn't :p
07:54:29 <elly> Hey!
07:54:37 <elly> Oh, heh. :P
07:54:41 * elly feels silly
07:56:15 * stevenmarky IS silly.
07:56:55 * copumpkin is always serious
07:57:37 <aluink> anybody here have any info on ICFP? i'm looking for cost information
07:58:40 <elly> copumpkin: No you aren't :P
07:58:45 <copumpkin> !!!!
07:58:51 <copumpkin> I have never been so insulted
07:59:11 <idnar> coserious?
07:59:44 <copumpkin> serious copumpkin, coserious pumpkin
07:59:55 <elly> :P
07:59:56 <copumpkin> get it right!
08:04:33 <EvanR-work> can i used error in IO
08:04:51 <Jafet> You can used it, yes
08:05:23 <EvanR-work> do x <- getChar; case x of 'z' -> error; 'y' -> print "OK!";
08:05:27 <Jafet> Hm, is there a lambdabot command to execute code?
08:05:30 <EvanR-work> i mean error / undefined
08:05:41 <Jafet> You can used undefined, yes!
08:05:45 <EvanR-work> ok
08:05:57 <EvanR-work> is it better to use an exception
08:06:09 <Jafet> error raises an exception
08:06:09 <Saizan> yes
08:06:18 <Jafet> So does undefined, I think
08:06:36 <Saizan> it's better to throw that exception as an IO effect with throwIO though
08:06:38 <ksf> @src undefined
08:06:38 <lambdabot> undefined =  error "Prelude.undefined"
08:06:48 <Saizan> because it's more predictable when it gets thrown
08:07:04 <Saizan> otherwise it depends on evaluation order
08:07:30 <EvanR-work> error "x y z does not exist, went away, exploded, vomitted" is easier to type than the equivalent ioError userError
08:07:35 <EvanR-work> ah
08:07:50 <ksf> EvanR-work, when you're lazy you can also say 'x' <- getChar
08:07:58 <Saizan> EvanR-work: use fail
08:08:04 <EvanR-work> ah fail
08:08:05 <ksf> well 'y' <- getChar
08:08:12 <ksf> ...which will invoke fail
08:08:42 <zygoloid> EvanR-work: if you write: foo = do x <- getChar; case x of 'z' -> error "Eep!"; 'y' -> print "OK!"
08:09:17 <zygoloid> EvanR-work: then forcing 'foo' will not do anything. Now if you factor out the 'getChar' so "foo :: Char -> IO ()", then forcing "foo 'z'" will throw an exception. that would be bad
08:09:30 <ksf> if you're doing interactive stuff, though, you should rather loop if you can't parse, prompting again.
08:10:51 <EvanR-work> this is IO code where a lookup into a table *should not* result in Nothing, if so, i coded it wrong and the program should crash
08:11:11 <ksf> use assert, then?
08:11:12 <EvanR-work> i suppose i could just not have a Nothing pattern
08:11:28 * EvanR-work looks up assert
08:11:42 <iaefai> If I wanted to have a program that does essentially what cabal does, but with some added additions (I am looking into creating an IDE of sorts) for communication with outside programs, would the Cabal-1.8.0.4 module be what I would want to look at?
08:11:59 <ksf> there's no program called cabal
08:12:03 <ksf> there's only cabal-install.
08:12:10 <ksf> but, yes, Cabal is what you're looking for
08:12:30 <iaefai> $ which cabal   ->   /Users/iaefai/.cabal/bin/cabal
08:12:30 <ksf> ...unless you want to do stuff that cabal-install does, in which case you want to look at its source, too.
08:12:33 <iaefai> That is a program :p
08:12:35 <jmcarthur> well, the executable is called cabal, but not the cabal package is different
08:12:46 <iaefai> I assumed it was
08:12:56 <jmcarthur> *but the
08:13:05 <ksf> cabal-install is strictly more powerful than cabal
08:13:13 <ksf> ...it does e.g. all the dependency resolving etc.
08:13:23 <iaefai> ok, then I would probably need to do something to cabal-install
08:14:14 <ksf> I suggest doing cabal unpack cabal-install and hacking away on it.
08:14:27 <Saizan> iaefai: there's an interest in splitting an "hackage-client" library out of cabal-install
08:14:34 <ksf> when stuff gets ready for release, you can add a flag to enable/disable the gui
08:14:38 <ksf> ...or that, yes.
08:15:04 <iaefai> What I am planning for is a sparse editor done in cocoa, with some very basic project management, but primarily making cabal even more convenient to use.
08:15:13 <ksf> Saizan, and renaming cabal the executable hackage?
08:15:39 <ksf> wait I think we _do_ have a package called hackage...
08:16:00 <ksf> doesn't leksah come with some cabal integration?
08:16:15 <iaefai> Hardest part seems to be finding an editor component that is sufficient for the purpose, but I think I found something that might work. Of course this part isn't strictly a haskell matter.
08:16:29 <EvanR-work> is there a haskell text editor
08:16:37 <ksf> there's yi
08:16:59 <ksf> which is a unified vi/nano/emacs
08:17:08 <iaefai> I want a well behaved, extremely mac-like, haskell editor.
08:17:16 <ksf> (not all at the same time, tohugh)
08:17:24 <EvanR-work> haha
08:17:35 <EvanR-work> ncurses?
08:17:44 <ksf> curses and gtk
08:18:09 <ksf> ...the gui part is abstracted away from the rest
08:18:26 <iaefai> Is there any debug tool that supports the idea of breakpoints in haskell, or does debugging take another form?
08:18:47 <paulvisschers> Saizan: I've got some sort of implementation now, but I'm having a lot of trouble with defining the Bind
08:18:52 * ksf debugs using print and trace
08:19:15 <quicksilver> iaefai: ghci has some breakpoint support in recent versions but I've never used it and rarely wanted it.
08:19:16 <Jafet> @quote oasis
08:19:16 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
08:19:17 <ksf> ghci comes with a tracer, but I never used it.
08:19:19 <iaefai> ksf, I like print, but not sure about this 'trace' thing :p
08:19:35 <ksf> trace is a refreshing desert in an oasis of purity.
08:20:00 <quicksilver> iaefai: I generally use the REPL - ghci - to find bugs by evaluating expressions and looking at the results
08:20:12 <iaefai> Would it feel dirty to write pure code in an impure editor?
08:20:38 <ksf> impurity is an illusion. the universe is a pure fixpoint.
08:20:52 * Jafet munches a burrito
08:21:02 * ksf needs to go shopping
08:21:45 <EvanR-work> i do not understand the joke
08:22:17 <EvanR-work> ah, purity is in a bigger desert ;)
08:22:19 <Jafet> If you wear a spacesuit, the universe is an illusion too.
08:22:37 <iaefai> Is all of reality just  a monad?
08:22:59 <fax> ask leibniz
08:23:14 <quicksilver> iaefai: I would be wary of inventing a new text editor. A good text editor is very hard to write (a bad one is very easy) and it will distract you for the more interesting cabal work you're talking about.
08:23:28 <quicksilver> iaefai: probably the best approach is just to embed the OSX rich text widget
08:23:38 <quicksilver> iaefai: that's a bad editor, but at least you didn't waste time writing it yourself.
08:23:41 <Jafet> It excites the masochist in you, to prepare you for cabal
08:24:03 <paulvisschers> Saizan: http://pastebin.com/1QYe2w2a Basically using run 5 (f test2) works great, but run 5 (f test) shows that the left hand argument to the Bind is only performed once, probably because of the join, but I'm not sure how to get around that sensibly (is that even possible?)
08:24:13 <quicksilver> however I should point out that as far as I know the haskell cocoa bindings are not currently being maintained?
08:24:15 <iaefai> quicksilver: That is the what I am going to start with. I have some work somebody else did for NSTextView that does somethings that will work for a code editor.
08:24:30 <iaefai> quicksilver: I would be doing some form of IPC for communication
08:25:04 <paulvisschers> Anyone other than Saizan's help would be greatly appreciated too :)
08:25:05 <iaefai> It is simply about getting cabal to report specifics to the editor. It might even do all that in a way that can be parsed easily now.
08:25:57 <quicksilver> iaefai: you mean you're writing an editor in ObjC and doing IPC to a haskell process?
08:26:17 <iaefai> That would essentially be it
08:26:34 <iaefai> The haskell process would only be for building, or possibly in future a ghci window
08:26:34 <Null-A> Is there a link which summarizes job market response to haskell over time?
08:26:48 <iaefai> Primarily this is a text editor though.
08:27:18 <iaefai> I want to be able to build an opengl application, properly in a bundle and run it with just a cmd-R press and it works fine.
08:27:24 <iaefai> If I can do that, I am golden
08:27:52 <iaefai> I also want an interface to edit a basic cabal file too
08:28:33 <iaefai> I do wonder how many haskellers are also mac people too.
08:29:14 <paulvisschers> iaefai: It seems popular among Utrecht University people
08:30:02 <iaefai> Maybe somebody would localize the editor if it ends up being useful :p
08:30:22 <EvanR-work> we want the demand for haskell to go up, but not the supply ;)
08:30:28 <EvanR-work> *not sold in stores*
08:31:01 <paulvisschers> EvanR-work: Well we're halfway done then :)
08:31:17 <paulvisschers> but can anyone help me with my problem please: http://pastebin.com/1QYe2w2a
08:31:27 <iaefai> EvanR: #haskell is 666  members right now, satanic I know, but it is 3 times that of macdev :p
08:31:40 <EvanR-work> why is there always 666 people in here
08:31:47 <Jafet> You could leave
08:31:55 <Saizan> paulvisschers: it's not possible to get around that using that definition of Test
08:32:06 <iaefai> Jafet: Somebody did that for us
08:32:12 <zygoloid> well, the channel got less satanic when roconnor left. what does that tell us? :)
08:32:13 <Jafet> Yay
08:32:13 <iaefai> Not sure which one of them was satan though.
08:32:35 <iaefai> I hear Satan hates purity
08:32:41 <paulvisschers> Saizan: Hmm, so in what way would it have to change?
08:32:44 <pippijn> iaefai: pure evil?
08:32:58 <iaefai> pippijn: pure evil freaks even him out
08:33:06 <pippijn> ;)
08:33:20 <zygoloid> pure evil :: (Applicative a) => a (IO b -> b)
08:33:29 <EvanR-work> gah whats a nice way to format if then else
08:33:32 <Jafet> Purity? Is that a new alignment dimension?
08:33:35 <zygoloid> EvanR-work: guards
08:33:39 <Jafet> I want to be impure neutral neutral.
08:33:42 <EvanR-work> ah
08:35:25 <aavogt> EvanR-work: view patterns
08:35:30 <Saizan> paulvisschers: to be able to generate the ST refs only once at the start and then run the action multiple times, you've to be able to see all the "Cache" constructors involved without entering inside a Bind
08:35:51 <EvanR-work> view patterns?
08:35:56 <Saizan> paulvisschers: so maybe this is not a viable solution at all for your use case
08:36:51 <aavogt> those are yet more flat than pattern guards
08:37:13 <Jafet> Or use if'
08:37:15 <EvanR-work> http://dpaste.com/184592/
08:37:19 <aavogt> EvanR-work: they are a relatively new ghc extension though
08:38:04 <EvanR-work> i forgot to read into c
08:38:06 <paulvisschers> But would there even be a way to get rid of the bind, but still keep Test a monad?
08:38:08 <EvanR-work> but anyway
08:38:23 <EvanR-work> that _ _ seems kind of silly
08:38:55 <aavogt> EvanR-work: you can write     case remaining of _ | eof -> ...; 0 -> return ...; _ -> loop ...
08:39:24 <EvanR-work> hm
08:39:37 <paulvisschers> Saizan: Like maybe translating (>>=) into a combination of constructors that can be converted by f (or is that basically the same thing)?
08:39:56 <EvanR-work> better
08:39:57 <aavogt> since if the last guard for a single binding fails, you the matching goes on to the next equation
08:40:15 <aavogt> > case True of _ | False -> undefined; _ -> True
08:40:16 <lambdabot>   True
08:45:00 <Saizan> paulvisschers: you get the same problem if you keep it a monad, i think
08:46:21 <EvanR-work> aavogt: http://dpaste.com/184594/
08:46:24 <EvanR-work> :\
08:46:38 <Saizan> paulvisschers: i think it might make more sense for your action itself to produce the updated version of itself with the references backed in
08:47:37 <paulvisschers> Saizan: So like :: Test a -> IO (Test' a)?
08:53:22 <paulvisschers> Saizan: I think that will make it more legible, but I don't think it fixes the monad problem
08:53:29 <Saizan> paulvisschers: more like Test a -> IO (a, IO a)
08:53:53 <paulvisschers> Saizan: Oh right, that makes more sense
08:54:04 <Saizan> paulvisschers: where the first 'a' is the result of running it the first time, and the IO a is what to use to rerun it
08:54:21 <paulvisschers> Saizan: I'll try that, thanks
08:55:14 <harlekin> @src reads
08:55:14 <lambdabot> reads = readsPrec minPrec
08:55:21 <harlekin> @src read
08:55:21 <lambdabot> read s = either error id (readEither s)
08:55:31 <harlekin> @info minPrec
08:55:31 <lambdabot> minPrec
09:00:00 <jmcarthur> has anybody in the haskell community written anything up about maintaining cache coherency in ghc/haskell programs? i'm kind of curious if there are some good general tips about it pertaining specifically to haskell
09:00:34 <quicksilver> jmcarthur: GHC makes an effort to keep the nursery small enough to fit in cache
09:00:48 <quicksilver> jmcarthur: so "newly constructed" stuff is always in cache; that's quite important
09:00:55 <jmcarthur> ah that's pretty nice
09:00:57 <quicksilver> jmcarthur: the downside is that old/stable data will often be a cache miss.
09:01:04 <jmcarthur> yeah
09:01:12 <quicksilver> but minor GCs can run entirely in-cache
09:01:33 <jmcarthur> okay, that's a pretty big hint. thanks
09:01:49 <quicksilver> JaffaCake thinks pretty hard about this stuff
09:01:55 <quicksilver> you could pick his brains when you next see him around.
09:01:59 <jmcarthur> alright, thanks
09:03:38 <Chaze> i was thinking that haskell stored previously calculated results of expressions. if that's the case, why is this so inefficient? http://pastebin.com/aneHxKsi
09:03:52 <jmcarthur> hmm... could this mean that it could be faster sometimes to duplicate things than to share?
09:04:58 <sclv> Chaze: that's not the right intuition
09:05:10 <jmcarthur> Chaze: i think collatzLength will be evaluated for every comparison in that code
09:05:13 <jacobian> Is there an elegant way to choose just one pattern from a disjoint union into Maybe (leaving Nothing, if the pattern didn't match)
09:05:15 <jmcarthur> actually...
09:05:20 <jmcarthur> @src maximumBy
09:05:20 <lambdabot> Source not found. Just try something else.
09:05:21 <EvanR-work> why does pastebin look like it was styled by mattel barbie
09:05:23 <jmcarthur> grr
09:05:26 <ksf> if collatz would take no argument, then it would be cached.
09:05:39 <Chaze> maximumBy gives a stack overflow, but that's not my main issue
09:05:41 <sclv> let f x = x * 2 in f [1,1,1,1,1,1] will multiply 1 by two multiple times.
09:05:47 <sclv> you need to memoize yourself.
09:05:55 <jmcarthur> Chaze: compiling with optimizations?
09:06:05 <Chaze> not compiling at all
09:06:17 <sclv> let foo = 2 * 2 in [foo,foo,foo] will only compute foo once.
09:06:23 <jmcarthur> heh, i wouldn't talk about performance at all without compiling with optimization
09:06:30 <EvanR-work> not sure about automatic memoization
09:06:36 <EvanR-work> is that feasible, wise/
09:06:48 <jmcarthur> there is no automatic memoization in ghc
09:06:56 <Chaze> i'm just wondering if results of collatz are being 'cached' in some way
09:06:56 <sclv> if you want sharing, the only guaranteed way is to write it yourself.
09:07:02 <jmcarthur> unless it does CSE
09:07:05 <sclv> there are memotables packages on hackage.
09:07:06 <ksf> it's easy to memoize, but it's always better to use dynamic programming.
09:07:10 <jmcarthur> it does sometimes, but not predictably
09:07:30 <jmcarthur> even then... it's not really memoization. just has a similar effect
09:07:33 <zygoloid> jacobian: more elegant than: case foo of pat1 -> Just e1; pat2 -> Just e2; ...; _ -> Nothing  ?
09:07:34 <Chaze> how could i rewrite this then, to be more efficient?
09:07:40 <EvanR-work> Chaze: if the same expression appeared in more than one place, then it makes sense to share. if your computation had an expression thats the same for any number, that would make sense to share
09:07:44 <jmcarthur> you could compile with -O2, for one
09:07:51 <EvanR-work> that part
09:08:00 <ksf> Chaze, make collatzLength a list
09:08:10 <ksf> ...each successive element using the previous one.
09:08:15 <jmcarthur> yeah that's the big tip
09:08:32 <sclv> ?wiki Memoization
09:08:32 <lambdabot> http://www.haskell.org/haskellwiki/Memoization
09:08:44 <sclv> ?go hackage memo
09:08:44 <lambdabot> Maybe you meant: google googleit do
09:08:55 <jmcarthur> actually, it can't just depend on the previous value
09:09:00 <sclv> ?google hackage memo
09:09:01 <lambdabot> No Result Found.
09:09:01 <ksf> memoization is for people who can't refactor.
09:09:08 <EvanR-work> hah
09:09:20 <sclv> http://hackage.haskell.org/package/data-memocombinators-0.4.0
09:09:36 <jmcarthur> ksf: i don't think you can just make a list for this one
09:10:07 <ksf> yep
09:10:32 <sclv> collatzLength is Int -> Int, no? of course you can make a list!
09:10:35 <sclv> it just might be a bit slow.
09:10:42 <jmcarthur> well ;)
09:10:49 <sclv> better to use a trie.
09:10:50 <jmcarthur> it can't just be iterated
09:11:06 <zygoloid> someone doing project euler?
09:11:33 <ksf> ...you can make each collatz sequence a list
09:11:40 <ksf> and then just use length
09:11:55 <jmcarthur> that's not really a speedup though
09:11:55 <Chaze> zygoloid: obviously ^^
09:12:07 <ksf> I don't think memoising collatz would gain you anything, as the computation is cheap.
09:12:15 <jmcarthur> it can gain you quite a bit
09:12:30 <sclv> memoising collatzLength does gain you a lot though!
09:12:31 <Chaze> ksf: well, in a different language, hashing the result of collatz is key
09:12:36 <zygoloid> Chaze: iirc i used an array for the first 2N entries, and computed higher ones on the fly.
09:13:01 * ksf thinks caching will cost more in lookups+cache misses than just recalculating the stuff.
09:13:06 <sclv> in any case (compare `on`) can be subject to a schwartzian transform as well, which should help...
09:13:15 <jmcarthur> i did that problem using full memoization and it performed well
09:13:18 <ksf> that should be a one-cycle function.
09:14:13 <sclv> jmcarthur: his collatz is just a single numeric transform -- the tricky bit is in collatzLength, which follows the chain...
09:14:20 <jmcarthur> right
09:14:33 <zygoloid> ksf: that problem is too slow if you don't cache iirc
09:14:51 <ksf> ...collatzLength, yes. collatz, nope.
09:15:03 <systemfault> What problem?
09:15:06 <EvanR-work> what is collatz is english
09:15:22 <ksf> heck it's one compare and bitshift or one compare and a multiplication and increment
09:15:46 <zygoloid> ksf: sorry, i see what you mean now. yes. caching collatz would be silly
09:16:05 <systemfault> For PE14, brute force is the key
09:16:08 <Chaze> ksf: right, what i said earlier was stupid. i'd store length obviously
09:17:01 <ksf> ...and collatzLength can't be dynamicised, at least not without doing maths that are too fancy for my tastes, so a memotable is ok
09:17:08 <jmcarthur> actually i don't remember how i did this one now
09:17:39 <Chaze> i also have to get rid of maximumBy, as that uses too much stack
09:17:50 <jmcarthur> Chaze: it doesn't if you compile with optimizations
09:18:02 <ksf> @src maximumBy
09:18:02 <lambdabot> Source not found. stty: unknown mode: doofus
09:18:02 <Chaze> -02 ?
09:18:05 <jmcarthur> yes
09:18:07 <jmcarthur> -O2
09:18:16 <Zao> o, not zero.
09:18:19 <ksf> should be a foldl and run in constant space.
09:18:27 <sclv> "-O2 the letter not the number"
09:18:33 <jmcarthur> Chaze: ghc --make Main.hs -O2
09:18:55 <Chaze> sclv: there we go :)
09:20:28 <gio123> in higher order unification does variables has types?
09:20:31 <gio123> free variables?
09:20:39 <paulvisschers> Saizan: YES, it works now, thanks a lot
09:22:09 <Saizan> paulvisschers: np
09:22:25 <gio123> in higher order unification does variables has types??
09:22:26 <gio123> free variables?
09:23:16 <Saizan> they don't necessarily have to
09:24:21 <lispy> hi
09:24:24 <lispy> How's code?
09:25:14 <paulvisschers> Saizan: I hope I can extend this approach to my actual problem, which does actually contain dynamic data that might change each run (but is heavily restricted so it shouldn't be able to change the control flow monadically)
09:25:58 <lispy> gio123: In Haskell?
09:26:04 <gio123> Saizan: no in general
09:26:35 <gio123> Saizan: no in general, for example second order unification are to decide wheter second order terms are euqual
09:26:48 <gio123> so, i expetc this terms has same types
09:27:12 <gio123> also, free variables in this term has to be typed?
09:28:07 <lispy> gio123: I'm a little confused about what you mean by free variables
09:28:20 <lispy> gio123: an example might help
09:28:24 <EvanR-work> i was told that Word64 on a 32bit machine will be very slow. so would it be faster to use Integer :)
09:28:27 <gio123> which is not binded by lambda
09:28:37 <gio123> X(t)=Y(m)
09:28:40 <gio123> this
09:30:24 <lispy> gio123: m is a free variable?
09:30:47 <gio123> no
09:30:51 <gio123> X,Y
09:31:29 <lispy> Can you give me an example in Haskell?
09:32:21 <sclv> http://conal.net/papers/elliott90.pdf
09:32:48 <sclv> _conal's thesis on higher order unification
09:33:30 <gio123> no
09:33:34 <gio123> i do not know haskel
09:33:36 <gio123> :(
09:34:23 * slonopotamus wonders what bits of his mind he has to change in order to understand haskell
09:35:19 <sclv> gio: section 2.4.2 states "in unfication over a typed calculus, we are given not just the set of variables to be instantiated during unification, but also their types"
09:35:47 <gio123> section of there?
09:35:59 <sclv> of the pdf I just pointed you to.
09:40:33 <gio123> sclv: aha great, this means variables are also typed
09:40:36 <gio123> is not?
09:40:58 <gio123> so, free variables also have types and not any term can be instanteated
09:41:09 <sclv> if i understand you correctly, yes.
09:41:23 <sclv> (and if i understand correctly myself...)
09:41:29 <gio123> term with same type can be only instateated instead of variable
09:41:59 <gio123> som if varyable has type let say sigma
09:42:03 <sclv> the paper is much smarter than i am at all this. you'd be better off just reading it carefully.
09:42:12 <gio123> term instanteated for this variable has to have type sigma
09:42:35 <sclv> if you're unifying over a typed calculus, yes.
09:47:15 <rajeshsr> sclv, just curious, what branch of CS should i study in order to understand what is being talked in the thesis? Logic? Sorry for this stupid question!
09:51:09 <sclv> type theory and logic, i'd imagine...
09:51:26 <sclv> I'm really more of a dabbler myself.
09:51:58 <rajeshsr> sclv, ha, ok!
09:52:04 <rajeshsr> thanks
09:52:53 <sclv> proof theory too
09:55:58 <rajeshsr> sclv, hmm, ok! thanks
10:13:20 <MadHatterDude> What do I need to link to in order to use Control.Monad.State
10:13:22 <MadHatterDude> ?
10:14:03 <c_wraith> mtl or transformers
10:14:09 <zygoloid> mtl or transformers+monads-fd or transformers+monads-tf or monadlib
10:14:31 <jmcarthur> monadLib doesn't have Control.Monad.State
10:14:36 <zygoloid> :(
10:14:45 <jmcarthur> different module name
10:14:53 <jmcarthur> i like monadLib though
10:14:54 <Chaze> I'm reading up on tries now, and i'm already lost on this definition
10:14:55 <Chaze> class HasTrie a where
10:14:55 <Chaze>     data (:->:) a :: * -> *
10:15:13 <fax> it just means the class has a data in it
10:15:22 <fax> each instance might use a different data
10:15:34 <Chaze> it's unlike any class/data definition i've seen so far
10:15:39 <fax> the thing is called :->: but hopefully you are not confused about that
10:15:46 <fax> you could call is Arrow or anything you want
10:15:48 <jmcarthur> it's a somewhat newer extension than most tutorials would probably bother explaining
10:16:00 <jmcarthur> TypeFamilies
10:16:07 <jmcarthur> it's also wicked awesome
10:16:56 <Chaze> ?wiki TypeFamilies
10:16:56 <lambdabot> http://www.haskell.org/haskellwiki/TypeFamilies
10:17:10 <Chaze> nothingness
10:17:14 <fax> it's a pretty natural extension
10:17:18 <fax> class C ... where
10:17:21 <fax>  f :: type
10:17:21 <zygoloid> jmcarthur: what is it you like about monadlib?
10:17:25 <fax> function having a given type
10:17:27 <fax> class C ... where
10:17:31 <fax>  data d :: kind
10:17:37 <fax> data having a given kind ..
10:17:56 <jmcarthur> zygoloid: it feels more consistent and puts parameters in the "right" order
10:18:52 <jmcarthur> and also little things, like having BaseM instead of MonadIO, allowing you to put something like ST at the bottom instead of IO without extra hassle
10:19:07 <lispy> jmcarthur: I think that's why monadLib exists, specifically to fix the subtle problems with mtl
10:19:08 <Chaze> ST?
10:19:13 <zygoloid> hmm, so you write 'StateM IO Int a' instead of 'StateT Int IO a'
10:19:26 <jmcarthur> zygoloid: not what i meant
10:20:01 <jmcarthur> Chaze: ST let's you use mutation in the implementation of a function while keeping the function externall referentially transparent
10:20:05 <jmcarthur> *externally
10:20:12 <sclv> Chaze: you should just be able to use luke's library without having to worry about the details
10:20:14 <jmcarthur> *lets
10:20:56 <sclv> also its better to figure out what a trie is in general, from e.g. wikipedia than to get the concept directly from the code.
10:20:58 <zygoloid> BaseM does seem like an improvement over MonadIO
10:21:56 <zygoloid> jmcarthur: which parameters did you mean then?
10:23:24 <jmcarthur> zygoloid: okay, i was actually wrong on the parameters thing. mixed it up with some other transformer library i think. but i'll add another benefit for monadLib
10:23:29 <jmcarthur> zygoloid: monadLib has more helper functions
10:23:40 <jmcarthur> for example:   sets :: StateM m s => (s -> (a, s)) -> m a
10:24:05 <jmcarthur> also has a nice exception monad, separate from the abort monad
10:24:18 <c_wraith> I should look at monadlib
10:24:23 <c_wraith> @hackage monadlib
10:24:23 <lambdabot> http://hackage.haskell.org/package/monadlib
10:24:27 <zygoloid> it doesn't have execState or evalState, but i think that's no great loss
10:24:32 <c_wraith> drat!
10:24:45 <zygoloid> also no non-transformer versions of the monads
10:24:56 <jmcarthur> zygoloid: it does have that letter
10:24:59 <jmcarthur> *latter
10:25:08 <jmcarthur> http://hackage.haskell.org/packages/archive/monadLib/3.6.1/doc/html/MonadLib-Monads.html
10:25:16 <zygoloid> ah, different module :)
10:25:43 <jmcarthur> also has a module full of helpers for writing instances
10:26:07 <jmcarthur> yeah, no execState, which kinda stinks
10:26:38 <zygoloid> the helper module seems to be basically a less convenient GeneralizedNewtypeDeriving
10:26:38 <jmcarthur> also still has the "wrong" type for callCC
10:26:50 <c_wraith> IdT?  wtf?
10:26:55 <jmcarthur> GNTD doesn't work for all the classes
10:26:55 <Twey> Hahaha
10:27:10 <c_wraith> when do you ever need IdT???
10:27:26 <Twey> c_wraith: I guess some things give you an option of what monad transformer to use
10:27:28 <jmcarthur> as the docs say... as a placeholder
10:27:45 <jmcarthur> like if you have a transformer as a type parameter and you dont' want anything useful there
10:28:02 <c_wraith> yeah, that's the only place it makes any sense at all
10:29:48 <jmcarthur> it looks like yav is willing to merge in changes if anybody ever gets around to just adding execState and evalState themselves
10:30:05 <jmcarthur> at least, there is a merge history on github
10:30:07 <c_wraith> shouldn't those be trivial?
10:30:10 <jmcarthur> yeah
10:30:41 <jmcarthur> my point is maybe the maintainer just never got around to needing it or forgot about it
10:31:27 <c_wraith> on a somewhat less trivial note, that could all use type functions to get rid of the functional dependencies, right?
10:31:58 <jmcarthur> pretty sure, yeah
10:32:06 <jmcarthur> monadLib predates type families
10:34:36 <zygoloid> is it possible to access {-# ANN #-} annotations from TH?
10:39:35 <sclv> I don't think so?
10:39:41 <dankna> no, unfortunately not
10:39:47 <dankna> no reason in principle that you couldn't
10:39:50 <dankna> but it's not in the data model
10:40:08 <dankna> ditto for comments, which somebody wanted recently for the purpose of generating docs automatically
10:40:25 <sclv> oh that would be slick!
10:40:44 <jmcarthur> huh
10:41:14 <sclv> a two stage pass could do it though -- extract annotations and comments via a custom preprocessr and toss them in as some extra info accessible to the th...
10:41:43 <jmcarthur> just for the record, haskell-src-exts with generics is amazing. TH with generics probably as well
10:42:08 <jmcarthur> used generics for the first time yesterday in a preprocessor with haskell-src-exts. it was easy and the code is amazingly short
10:46:09 <aavogt> jmcarthur: help add to here: http://en.wikibooks.org/wiki/Haskell/SYB ?
10:48:37 <jmcarthur> aavogt: i used uniplate
10:50:38 <aavogt> then the page can be about uniplate too?
10:50:50 <jmcarthur> heh perhaps
10:51:14 <jmcarthur> i used exactly two uniplate functions and was done. i'm hardly an expert
11:15:42 * hackagebot TigerHash 0.2 - TigerHash with C implementation  http://hackage.haskell.org/package/TigerHash-0.2 (NikolayOrlyuk)
11:21:14 <Apocalisp> @type let f a b = (liftM2 f a b) `mplus` a `mplus` b in f
11:21:15 <lambdabot>     Occurs check: cannot construct the infinite type: a1 = m a1
11:21:15 <lambdabot>       Expected type: m a1
11:21:15 <lambdabot>       Inferred type: a1
11:21:25 <Apocalisp> @type let f a b = (liftM2 f) a b `mplus` a `mplus` b in f
11:21:26 <lambdabot>     Occurs check: cannot construct the infinite type: a1 = m a1
11:21:26 <lambdabot>       Expected type: m a1
11:21:26 <lambdabot>       Inferred type: a1
11:21:47 <Apocalisp> @type let f g a b = (liftM2 g) a b `mplus` a `mplus` b in f
11:21:48 <lambdabot> forall a2 (m :: * -> *). (MonadPlus m) => (a2 -> a2 -> a2) -> m a2 -> m a2 -> m a2
11:22:20 <c_wraith> I like the choice of a2 as the type variable name.  clean.  concise.  bizarre :)
11:22:47 <Apocalisp> @type liftM2
11:22:47 <c_wraith> Also, that appears to be a generalized zipwith?
11:22:48 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
11:22:53 <Cale> It comes from there
11:23:07 <Apocalisp> yeah, comes from liftM2
11:23:32 <Cale> When unifying type variables, GHC tries to preserve at least one of the names provided in the source :)
11:23:51 <Apocalisp> @let zapWith g a b = (liftM2 g) a b `mplus` a `mplus` b
11:23:52 <lambdabot>  Defined.
11:24:33 <Apocalisp> > zapWith (*) (Just 1) Nothing
11:24:34 <lambdabot>   Just 1
11:24:44 <Apocalisp> > zapWith (*) (Just 3) (Just 2)
11:24:45 <lambdabot>   Just 6
11:25:24 <zygoloid> > zapWith (+) [1,2] [3,4,5]
11:25:25 <lambdabot>   [4,5,6,5,6,7,1,2,3,4,5]
11:25:52 <zygoloid> > zapWith (++) "fizz" "buzz"
11:25:54 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Char)
11:25:54 <lambdabot>    arising from a use o...
11:26:23 <Apocalisp> > liftM2 (+) [1,2] [3,4,5]
11:26:24 <lambdabot>   [4,5,6,5,6,7]
11:26:33 * Saizan wants an orElse for []
11:26:47 <Saizan> in the stdlib
11:27:11 <lispy> orElse [] xs = xs; orElse xs _ = xs ?
11:27:45 <Apocalisp> I seem to want zapWith a lot.
11:28:04 <Apocalisp> Meaning it comes up all over the place
11:28:49 <Saizan> lispy: yup
11:29:33 <lispy> Saizan: hmm...I'm surprised we don't have that already
11:29:45 <opqdonut> hmm, for Maybe zapWith == liftA2, right?
11:29:56 <zygoloid> opqdonut: no
11:29:58 <Apocalisp> opqdonut: No, that's the thing
11:30:18 <opqdonut> > liftA2 (*) (Just 1) Nothing
11:30:19 <lambdabot>   Nothing
11:30:25 <opqdonut> > zapWith (*) (Just 1) Nothing
11:30:26 <lambdabot>   Just 1
11:30:31 <opqdonut> ah
11:30:51 <Cale> It's basically liftM2, plus some extra junk tacked onto the end ;)
11:30:51 <opqdonut> so kinda like a combineWith
11:31:01 <zygoloid> something like: zapWith f a b = liftA2 f a b <|> a <|> b
11:31:20 <opqdonut> i'd guess zapWithing lookups is a good use example
11:31:21 <zygoloid> (but for MonadPlus not Alternative)
11:31:53 <opqdonut> @src mergeWith
11:31:53 <lambdabot> Source not found. Maybe you made a typo?
11:32:33 <opqdonut> @src unionWith
11:32:33 <lambdabot> Source not found. I've seen penguins that can type better than that.
11:32:41 <opqdonut> @src Data.Map.unionWith
11:32:41 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
11:32:43 <opqdonut> hrmmh
11:32:43 <lispy> sassy bot
11:35:16 <alpounet> @type zapWith
11:35:17 <lambdabot> forall a2 (m :: * -> *). (MonadPlus m) => (a2 -> a2 -> a2) -> m a2 -> m a2 -> m a2
11:39:04 <sannysanoff> hello, gentlemen. I am running my program with GHC profiler, then looking at the resulting .prof file, and I see top CPU-eaters, and first of them MAIN (72%), then next function with name, eating around 12%..... Am I correct that MAIN means IDLE time, so all CPU usage percent values sum up to 100%?
11:39:33 <Saizan> no
11:40:07 <Saizan> have you compiled it with -auto-all -caf-all ?
11:40:19 <sannysanoff> Saizan, without -caf-all,
11:40:31 <sannysanoff> let me try..
11:42:29 <sannysanoff> Saizan, unfortunatly nothing changed.
11:42:39 <Apocalisp> @type let zapWith f [] xs = xs; zapWith f xs [] = xs; zapWith f xs ys = zipWith f xs ys in zapWith
11:42:40 <lambdabot> forall c. (c -> c -> c) -> [c] -> [c] -> [c]
11:43:05 <Apocalisp> so, no I don't want it to be like liftM2 at all, except for Maybe
11:44:02 <jlouis> What version of cabal-install is needed for Cabal-1.9.0 ?
11:44:35 <Apocalisp> @type let zapWith f [] xs = xs; zapWith f xs [] = xs; zapWith f (x:xs) (y:ys) = f x y : zapWith xs ys in zapWith
11:44:36 <jlouis> sannysanoff: using -threaded?
11:44:36 <lambdabot>     Couldn't match expected type `[t]'
11:44:36 <lambdabot>            against inferred type `t -> t -> a'
11:44:37 <lambdabot>     Probable cause: `zapWith' is applied to too few arguments
11:45:03 <Apocalisp> @type let zapWith f [] xs = xs; zapWith f xs [] = xs; zapWith f (x:xs) (y:ys) = f x y : zapWith f xs ys in zapWith
11:45:04 <lambdabot> forall a. (a -> a -> a) -> [a] -> [a] -> [a]
11:45:40 <Saizan> jlouis: 0.9 i'd say, i.e. the darcs one
11:45:54 <jlouis> Saizan: grabbing :)
11:45:54 <sannysanoff> jlouis, yes
11:46:32 <jlouis> sannysanoff: I have seen it report wrongly with -threaded. I think the prof2dot tool reports the times correctly however. prof2dot is on hackage
11:47:25 <jlouis> sannysanoff: basically, most time spent in MAIN is idle or the RTS doing stuff, though I have not yet figured out exactly what it is doing
11:47:31 <EvanR-work> we added freeResult :: Statement -> IO () to HDBC and HDBC mysql driver
11:47:38 <EvanR-work> and it works
11:47:53 <EvanR-work> but im wondering if this is not appropriate for other drivers and so cant be contributed
11:47:56 <sannysanoff> jlouis, I will check prof2dot, but I wonder where it will get the data from? .prof does not seem too complex / big
11:48:16 <sannysanoff> jlouis, that was my assumption (MAIN = idle)
11:48:29 <EvanR-work> prepared statement performance doesnt seem to have changed much though, unfortunately, so maybe its for the best
11:48:36 <jlouis> sannysanoff: prof2dot takes the "raw" output. See the -px RTS option
11:48:53 <Apocalisp> I think what I'm looking at is the Monoidal typeclass from the applicative paper.
11:48:58 <sannysanoff> jlouis, thanks, will check
11:49:21 <jlouis> sannysanoff: -px is definitely not for humans... aliens may perhaps find pleasure in studying it
11:49:31 <Apocalisp> (Except mine is less general)
11:55:25 <sannysanoff> jlouis, thanks, the resulting .ps is monstrous, but something is colored there..
11:55:37 <jlouis> why oh why must darcs get be so slow
11:55:37 <sbpaul> is there a function, "strip out all non-ascii characters"
11:55:57 <sbpaul> if so where ;)
11:56:06 <Apocalisp> @type let (<|>) = (Control.Applicative.<|>); f g a b = (g <$> a <*> b) <|> a <|> b in f
11:56:07 <lambdabot> forall a (f :: * -> *). (Alternative f) => (a -> a -> a) -> f a -> f a -> f a
11:56:35 <jlouis> sbpaul: Data.Char
11:56:49 <jlouis> sbpaul: you may need to select the right one
11:57:02 <jlouis> and then combine with some function like filter
11:57:19 <sbpaul> there has to be a better way to do this
11:57:34 <jlouis> :t filter isAlpha
11:57:35 <lambdabot> [Char] -> [Char]
11:58:08 <jlouis> sbpaul: better way? What is your input type? Something different than String?
11:58:31 <sbpaul> i'm not sure what the error is
11:58:40 <sbpaul> somebody else said it had to do with xmobar misinterpreting utf8 strings or something
11:58:56 <sbpaul> well literally it's "hPutChar: resource vanished: broken pipe"
11:59:02 <djahandarie> > filter isAlpha " my name is Darius."
11:59:03 <lambdabot>   "\12393\12358\12418mynameisDarius"
11:59:14 <sbpaul> good old hiragana...
11:59:40 <pippijn> > filter isAlpha ""
11:59:41 <lambdabot>   "\20320\22909"
11:59:45 <jlouis> Unicode is hard, lets go hunt memleaks in Core :P
12:00:06 <gwern> > fromEnum "0"
12:00:07 <lambdabot>   No instance for (GHC.Enum.Enum [GHC.Types.Char])
12:00:08 <lambdabot>    arising from a use of `...
12:00:17 <djahandarie> I forget what it was... but maybe I'll guess
12:00:27 <djahandarie> > print ""
12:00:28 <lambdabot>   <IO ()>
12:00:37 <djahandarie> Oh obivously not that
12:00:41 <c_wraith> > text  ""
12:00:42 <lambdabot>   
12:00:48 <djahandarie> Yeah that's the one. :P
12:00:54 <Cale> > text ""
12:00:55 <lambdabot>   
12:01:21 <c_wraith> shouldn't that really be douzo in context, anyway? :)
12:01:30 <c_wraith> (I don't have an IME set up at the moment)
12:04:57 <EvanR-work> > reverse ""
12:04:58 <lambdabot>   "\12377\12414\12356\12374\12372\12358\12424\12399\12362"
12:05:06 <EvanR-work> > text $ reverse ""
12:05:07 <lambdabot>   
12:06:19 <djahandarie> I'm going to some seminar on quivers
12:06:30 <djahandarie> No idea what the guy is going to go on about in detail
12:08:53 <voker57> :t text
12:08:54 <lambdabot> String -> Doc
12:09:21 <djahandarie> It is some pretty print thing if I recall correctly
12:09:27 <voker57> !hoogle text
12:09:29 <voker57> @hoogle text
12:09:30 <lambdabot> Text.Html text :: String -> HtmlAttr
12:09:30 <lambdabot> Text.PrettyPrint.HughesPJ text :: String -> Doc
12:09:30 <lambdabot> Text.XHtml.Transitional text :: String -> HtmlAttr
12:09:58 * hackagebot dbus-core 0.8.2 - Low-level D-Bus protocol implementation  http://hackage.haskell.org/package/dbus-core-0.8.2 (JohnMillikin)
12:11:46 <zygoloid> > doubleQuotes (text "Hello")
12:11:47 <lambdabot>   "Hello"
12:13:23 <Null-A> Is there a haskell tutorial which is extremely concise and takes a beginner to intermediate?
12:13:42 <Null-A> I really like real world haskell, but feel it's a little too verbose
12:13:49 <Null-A> I guess I could skim through it
12:14:18 <burp> @url lyah
12:14:18 <lambdabot> http://www.learnyouahaskell.com/
12:14:19 <c_wraith> @where lyah
12:14:20 <lambdabot> http://www.learnyouahaskell.com/
12:14:25 <c_wraith> drat, I was too slow
12:14:30 <Null-A> lol thanks
12:15:55 <aavogt> the haskell report
12:16:16 <aavogt> @where report
12:16:16 <lambdabot> http://www.haskell.org/onlinereport/
12:17:21 <jmcarthur> lyah is kind of verbose too
12:17:37 <c_wraith> true, but it's a lot more...  light
12:18:06 <zygoloid> i guess tryhaskell is a bit more nothing -> beginner than beginner -> intermediate
12:19:52 <dv-> how about the gentle introduction to haskell?
12:20:21 <dv-> @where gentle
12:20:21 <lambdabot> http://www.haskell.org/tutorial/
12:23:30 <Associat0r> Zao: http://garabedyan.wordpress.com/2009/05/25/resource-aware-programming/
12:23:40 <Associat0r> Zao: http://www.youtube.com/watch?v=7MIK_ppEXno
12:23:43 <Zao> Associat0r: Wrong language.
12:24:03 <Associat0r> Zao: it's related
12:24:06 <Zao> No.
12:24:09 <Zao> -blah maybe.
12:24:10 <Associat0r> Zao: Happy Template Haskell etc
12:24:23 <Associat0r> Zao: not blah
12:24:42 <Zao> I don't have any intent to watch over an hour of some wanker fapping around with Yet Another Toy Fantasy Language.
12:24:47 <Zao> Stop bothering me.
12:25:04 <Zao> The language and guy might be nice, but I do not like you.
12:25:19 <dv-> wow rude
12:25:37 <Zao> dv-: It's not like this is the first time I meet Ass0.
12:26:01 <Associat0r> Zao: what did I do wrong now?
12:26:18 <Zao> Linking me irrelevant shit in a channel where it doesn't belong.
12:26:28 <Associat0r> Zao: it's PLT related
12:26:42 <Zao> This is #haskell, not #programminglanguagetheoryhugglecircle
12:26:53 <Associat0r> Zao: didn't you link me some F# stuff in #gamedev last time?
12:27:03 <Associat0r> Zao: and then accuse me of mentioning F#
12:27:19 <Zao> Associat0r: I suggest taking this discussion out of this channel, as it belongs even less.
12:27:40 <Zao> That channel is by definition off topic by default.
12:27:57 <Associat0r> Zao: I am sure a lot of people in this channel appreciate the links I showed
12:28:26 <Zao> So link them without targetting me?
12:28:31 <Zao> Also, -blah.
12:28:47 <Associat0r> Zao: well since you did code generation I thought you would like it
12:28:52 <Cale> Generally we don't mind anything related to programming, computer science or mathematics here as long as it's not interfering with discussion about Haskell.
12:29:11 <Zao> Fair enough.
12:30:59 <Zao> I may have overreacted somewhat, but that's mostly because I assumed it was Yet Another Irrelevant F# pimpage.
12:31:38 <Associat0r> it had nothing todo with F# at all
12:31:53 <faure> haha burned
12:31:54 <Associat0r> other than being OCaml related
12:32:05 <djahandarie> People tend to talk about Coq, Agda, and stuff in here quite a bit
12:32:17 <mreh> you said Coq
12:32:19 <mreh> haha
12:32:40 <djahandarie> It's from the word rooster I swear!!!
12:33:04 <Null-A> is a list just represented as a function in haskell internally?
12:33:12 <Null-A> f( index ) = element or something+
12:33:13 <faure> its not from the word coquette?
12:33:40 <Zao> @src []
12:33:41 <lambdabot> data [] a = [] | a : [a]
12:33:42 <pippijn> it's funny how there are at least two languages called "cock" in some way
12:33:50 <mreh> Null-A it's represented as a graph
12:33:52 <Zao> Null-A: That's the definition of a list.
12:34:06 <pippijn> coq and kogut
12:34:10 <Null-A> ah k, thanks
12:34:23 <mreh> but that's irrelevant
12:34:24 <Zao> Null-A: You could see it as a singly linked list.
12:34:25 <EvanR-work> indexing is slow
12:34:30 <djahandarie> lol pippijn
12:34:54 <EvanR-work> @src (!!)
12:34:55 <lambdabot> xs     !! n | n < 0 = undefined
12:34:55 <Zao> "asdf" is 'a' : ('s' : ('d' : ('f' : [])))
12:34:55 <lambdabot> []     !! _         = undefined
12:34:55 <lambdabot> (x:_)  !! 0         = x
12:34:55 <lambdabot> (_:xs) !! n         = xs !! (n-1)
12:34:59 <jbapple> pippijn: What's the other one
12:35:14 <Zao> That is, 'a' with a tail of ('s' with a tail of ('d' ...
12:35:27 <pippijn> kogut is an impurely functional dynamically typed programming language
12:35:41 <Null-A> EvanR: yeah pretty scary, what would you use for indexing?
12:35:49 <Null-A> hash table..
12:35:59 <pippijn> it has pretty neat FFI
12:36:01 <EvanR-work> Null-A: theres arrays and search trees
12:36:11 <pippijn> with perl, python and C and some others I don't remember
12:36:11 <djahandarie> I've always liked Data.Sequence
12:36:17 <Zao> Null-A: Depends on what kind of indexing you need. There's vector and arrays if you need random-access.
12:36:20 <twink> What's the other one besides Coq?
12:36:24 <djahandarie> Finger trees are just cool
12:36:32 <Zao> Map/Set/whatnot if you want associative containers.
12:36:40 <EvanR-work> Null-A: usually you will be guided away from hash tables
12:37:00 <pippijn> twink: I hope you are either not asking me or not expecting an answer
12:37:33 <mreh> finger trees are like arrays, but more complicated, because we like to confuse people
12:37:33 <twink> I have no idea who I was asking, but was expecting an answer.
12:37:54 <roconnor> finger trees are like arrays?
12:37:59 <pippijn> 21:33 < pippijn> coq and kogut
12:38:12 <mreh> roconnor: constant time access
12:38:14 <mreh> kind of
12:38:26 <roconnor> by constant time you mean log(n)?
12:38:34 <mreh> amortised constant time
12:38:53 <roconnor> I don't think that is right
12:39:03 <mreh> me neither
12:39:18 <c_wraith> it's amortized constant time to where the fingers point.
12:39:34 <roconnor> mreh: it take log(n) time just to decode what the heck the index is
12:39:41 <c_wraith> the common implementations (like Data.Sequence) have a finger to the first and last elements.
12:39:52 <c_wraith> But you could theoretically include additional fingers
12:39:59 <mreh> like the middle
12:40:04 <mreh> and the middle of the first half
12:40:09 <jbapple> It's worst-case constant time to where the fingers point
12:40:15 <c_wraith> you could make a binary tree of fingers!
12:40:27 <roconnor> jbapple: what's the best case?
12:40:39 <mreh> constant time
12:40:48 <mreh> right?
12:40:50 <roconnor> sub-constant time
12:40:55 <jbapple> You can only really include a constant number of fingers in purely functional finger trees
12:41:16 <roconnor> I wonder if quantum mechanics gives you sub-constant time algorithms
12:41:20 <roconnor> (amortized)
12:41:34 <mreh> @wn amortized
12:41:34 <jbapple> There already are O(0) amortized algorithms
12:41:36 <lambdabot> No match for "amortized".
12:41:39 <mreh> @wn amortised
12:41:40 <lambdabot> No match for "amortised".
12:41:45 <mreh> it isn't a word
12:41:46 <roconnor> jbapple: :O
12:42:03 <jbapple> I have a link, brb:
12:42:06 <EvanR-work> echo "sub-constant time?"
12:43:20 <jbapple> http://arxiv.org/abs/0903.4130
12:43:44 <jbapple> amortized O(0) heap meld
12:43:55 <xerox> O(0) is 0
12:44:01 <jbapple> yup
12:44:05 <dschoepe> t
12:44:14 <c_wraith> what does O(0) even mean?  you can perform an O(0) op n times for a constant cost?
12:44:14 <mreh> why isn't there more research into best case execution time?
12:44:34 <pippijn> O(0) is nice
12:44:39 <Twey> O(0)?  So you get it for free?
12:44:42 <pippijn> yep
12:44:46 <EvanR-work> you can do infinite of them!
12:44:49 <Twey> In other words, you don't do it :
12:44:53 <pippijn> you can do an infinite number of calculations in no time
12:44:54 * EvanR-work something tells me you dont ever really do them in the first place
12:45:00 <pippijn> Twey: correct
12:45:04 <djahandarie> Twey, you don't do it, your clone in the other world does!
12:45:07 <c_wraith> So I can not do it infinite times in finite time!
12:45:08 <Twey> Hahaha
12:45:22 <EvanR-work> this is shenanigans
12:45:29 <pippijn> you can do nothing an infinite times in finite time
12:45:32 <pippijn> that time is 0
12:45:43 <jbapple> The paper I linked to above does not "not do" the melds, it simply assigns the cost elsewhere
12:45:44 <pippijn> broken english
12:45:50 <jbapple> This is the magic of amortization.
12:45:53 <mreh> what's nothing time inifinity?
12:46:04 <pippijn> inf * 0 = 0
12:46:11 <Twey> Ah, aye
12:46:15 <EvanR-work> > Inf * 0.0
12:46:16 <lambdabot>   Not in scope: data constructor `Inf'
12:46:20 <EvanR-work> > Infinity * 0.0
12:46:21 <lambdabot>   Not in scope: data constructor `Infinity'
12:46:29 <dankna> > 1.0 / 0.0
12:46:30 <lambdabot>   Infinity
12:46:33 <c_wraith> eh.  you have to use l'hopital to really figure out inf * 0 :)
12:46:37 <pippijn> > (1.0 / 0.0) * 0.0
12:46:38 <lambdabot>   NaN
12:46:40 <pippijn> great
12:46:42 <EvanR-work> NaN, i knew it
12:46:45 <pippijn> ieee </3
12:47:07 <mreh> back to understand the OpenGL bindingd
12:47:10 <pippijn> c_wraith: according to l'hospital, that would be 0
12:47:17 <Apocalisp> repeat () `zip` []
12:47:19 <Apocalisp> > repeat () `zip` []
12:47:20 <lambdabot>   []
12:47:23 <EvanR-work> O(NaN)
12:47:24 <mreh> can someone explain why the types are written as C++ macros?
12:47:30 <c_wraith> pippijn: depends on how you got the zeroes, really.
12:47:36 <pippijn> *hopital
12:47:48 <pippijn> c_wraith: yes, that's true
12:48:51 <lispy> mreh: the types of what?
12:49:22 <lispy> mreh: oh, the OpenGL stuff?  Hmm...I don't know the real reason, but I can speculate
12:49:27 <jmcarthur> C++ doesn't even have macros, does it? or do you mean CPP?
12:49:44 <mreh> lispy: Graphics.Rendering.OpenGL.Raw.Core31
12:49:48 <mreh> yeah, CPP
12:49:51 <jmcarthur> *doesn't even have its own macros
12:49:58 <jmcarthur> CPP = C PreProcessor
12:50:03 <mreh> oh, lol :)
12:50:20 <jmcarthur> it's probably just written that way for convenience
12:50:21 <mreh> someone said CPP, I thought they meant C++
12:50:31 <jmcarthur> yeah, i guessed that. common
12:50:37 <Twey> C++ has limited macros, called templates ;)
12:50:55 <EvanR-work> on american keyboards shift P and shift + are next to each other
12:51:10 <jmcarthur> huh?
12:51:15 <Twey> No they aren't, are they?
12:51:17 <lispy> mreh: Well if the types are in a .hsc file then it's because they come from C includes.  Otherwise, I would speculate that they did it for platform compatibility (have to match what C generates, so might as well use its convention)
12:51:21 <jmcarthur> not on mine
12:51:25 <pippijn> they are underneath each other on mine
12:51:27 <EvanR-work> so its not inconvenient to say c++ when you mean c++
12:51:27 <Twey> P is next to [ on a standard US QWERTY keyboard
12:51:36 <pippijn> P is under +
12:51:38 <EvanR-work> its close enough
12:51:42 <lispy> QWERTY?  Doesn't everyone use Dvorak?
12:51:45 <jmcarthur> all the keys around P on mine are:  0ol;[-
12:51:51 <Twey> lispy: Probably most here do :
12:52:00 <mreh> I use QWERTY, don't hate me
12:52:07 <Twey> It's surprising how Dvorak's taken off recently
12:52:10 <Twey> Considering how old it is
12:52:10 <jmcarthur> qwerty here
12:52:11 <mreh> i use all my fingers though!
12:52:13 <EvanR-work> qwerty obliterates my wrists
12:52:17 <Twey> EvanR-work: Same
12:52:23 <EvanR-work> the only word it can type easily is... qwerty
12:52:26 <mreh> my little finger has started twitching recently
12:52:31 <pippijn> + is really far away from P on dvorak
12:52:42 <Twey> pippijn: Most of the keyboard away :  Same row, though!
12:52:53 <jmcarthur> with dvorak you can type shithead without leaving the home row. if that's not reason to switch then i don't know what is
12:53:00 <pippijn> Twey: yes
12:53:13 <Twey> jmcarthur: Hehe
12:53:18 <mreh> i might switch for the lulz
12:53:32 <mreh> "alright you type it then!" "WTF!"
12:53:33 <dolio> With qwerty you can type stewardesses with one hand.
12:53:46 <mreh> dolio: that's a bad thing
12:53:49 <jmcarthur> dolio: oh god but it's the left hand
12:53:50 <Twey> Yeah
12:53:58 <Twey> That's anti-ergonomics in action :
12:54:07 <jmcarthur> colemac seems compelling to me
12:54:13 <jmcarthur> *colemak?
12:54:16 <Twey> Colemak
12:54:28 <jmcarthur> i like the idea of optimizing for "finger runs"
12:54:39 <Twey> Seems interesting, but less support, and not a significant benefit over Dvorak (compared to Dvorak over QWERTY)
12:55:09 <jmcarthur> but if i am switching away from qwertyy and not dvorak i've thought it might be perhaps worth considering
12:55:30 <Twey> Colemak doesn't come with Windows, though
12:55:55 <mreh> if you're on someone else's computer how do you cope?
12:56:01 <mreh> who doesn't type qwerty
12:56:08 <mreh> who does type qwerty
12:56:26 * killing-joke is now known as "qwerty"
12:56:28 <jmcarthur> you deal
12:56:41 <Twey> I can type QWERTY okay it just kills my wrists to do it for long periods
12:56:56 <Twey> If I'm on someone else's computer for more than half an hour I take the time to switch the layout
12:57:22 <jmcarthur> windows comes with dvorak? i didn't know that
12:57:26 <jmcarthur> i knew os x did
12:57:28 <Twey> Yeah, it does
12:57:33 <jmcarthur> and some linux distros
12:57:47 <Twey> Standard, right-handed, *and* left-handed
12:57:56 <Twey> But not ANSI or Programmer's
12:57:59 <mreh> I don't understand why the openGL bindings are now using its own double type
12:58:01 <jmcarthur> programmer dvorak?
12:58:02 <jmcarthur> aw :(
12:58:20 <aavogt> mreh: because it's safer
12:58:22 <jmcarthur> mreh: because the spec doesn't say it has to be haskell's double type
12:58:30 <Twey> Also, as a Brit, the lack of a compose key hurts me
12:58:37 <jmcarthur> this way it's abstracted and won't break code if they change the underlying representation
12:58:55 <EvanR-work> @hoogle Word32 -> Word32 -> (Word32, Word32)
12:58:56 <lambdabot> Prelude divMod :: Integral a => a -> a -> (a, a)
12:58:56 <lambdabot> Prelude quotRem :: Integral a => a -> a -> (a, a)
12:58:56 <lambdabot> Data.Fixed divMod' :: (Real a, Integral b) => a -> a -> (b, a)
12:58:58 <jmcarthur> well, not as likely to break code anyway
12:59:04 <Twey> I can't type  or  or any accented characters since the Windows Dvorak is US-only
12:59:06 <EvanR-work> @hoogle Word32 -> Word32 -> Word64
12:59:06 <lambdabot> Data.Fixed div' :: (Real a, Integral b) => a -> a -> b
12:59:06 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
12:59:06 <lambdabot> Prelude curry :: ((a, b) -> c) -> a -> b -> c
12:59:13 <nus> layouts? chords!
12:59:13 <aavogt> jmcarthur: well dvorak is some kind of international standard
12:59:19 <nus> @google chorded keyboard
12:59:20 <lambdabot> http://en.wikipedia.org/wiki/Chorded_keyboard
12:59:20 <lambdabot> Title: Chorded keyboard - Wikipedia, the free encyclopedia
12:59:21 <jbapple> In British Haskell, compose is tryped "Full Stop"
12:59:28 <jbapple> *typed
12:59:33 <mreh> way to type :)
12:59:42 <Twey> Hehe
12:59:48 <Twey> @let full_stop = fmap
12:59:49 <lambdabot>  Defined.
13:00:02 <Twey> > (* 2) `full_stop` (+ 1) $ 3
13:00:03 <lambdabot>   8
13:00:06 <mreh> I laugh when american's say period
13:00:10 <Twey> mreh: Yeah :
13:00:19 <mreh> s/american's/american
13:00:29 <mreh> not LOL, but LQTM
13:00:37 <EvanR-work> gah. there must be an efficient way to get the overflow of a mult of two Word32s :(
13:01:10 <aavogt> EvanR-work: is this different from converting the two to Word64 before multiplying?
13:01:14 <Twey> mreh: I mostly just SQTM
13:01:15 <mreh> aavogt, jmcarthur: haskell's double type isn't likely to change though
13:01:24 <jmcarthur> mreh: but opengl's is
13:01:34 <mreh> jmcarthur, why?
13:01:37 <jmcarthur> mreh: which is why it doesn't use haskell's
13:01:40 <EvanR-work> aavogt: doing that, but i was told ghc Word64 is slow on 32bit machines
13:01:48 <jmcarthur> mreh: because the spec says it's up to the implementation
13:01:56 <FliPPeh_> > let x % y = x `mod` y in 5%2
13:01:57 <lambdabot>   1
13:02:03 <aavogt> perhaps it's quick enough?
13:02:03 <FliPPeh_> I wonder, why isn't it in prelude?
13:02:04 <jmcarthur> mreh: and opengl implementations do indeed vary widely
13:02:17 <Twey> FliPPeh_: (%) is the Data.Ratio construction operator
13:02:20 <EvanR-work> aavogt: maybe, but its making my statistical tests take forever
13:02:24 <mreh> jmcarthur, oh... I didn't realise this
13:02:26 <FliPPeh_> Oh
13:02:27 <Twey> > 6 % 2
13:02:28 <lambdabot>   3 % 1
13:02:35 <mreh> is there a GNU openGL?
13:02:43 <Twey> 1 % 3 means , for example
13:02:45 <jmcarthur> mreh: not that i know of
13:02:48 <Twey> mreh: Mesa, no?
13:02:53 <jmcarthur> is mesa GNU?
13:03:28 <EvanR-work> no
13:03:29 <mreh> i had no idea openGL was specification until now
13:03:29 <Twey> Well, it's MIT
13:03:30 <jmcarthur> don't think it is
13:03:58 <mreh> *just* a specification
13:04:08 <jmcarthur> mreh: you should read the spec. it's comprehensive and useful
13:04:16 <mreh> jmcarthur: I often don't
13:04:20 <jmcarthur> mreh: make sure you read the right version
13:04:31 <mreh> is it long?
13:04:41 <jmcarthur> mreh: the OpenGL package supports opengl 2.1, iirc, and the specs are up to version 4 now
13:04:58 <jmcarthur> mreh: fairly long, yes, but you should read it if you intend to do any serious opengl programming
13:05:05 <jmcarthur> or at least have it around
13:05:12 <mreh> I watched some video about hitler and openGL
13:05:19 <jmcarthur> mreh: OpenGLRaw supports opengl 3
13:05:25 <jmcarthur> heh
13:05:39 <jmcarthur> mesa does not, however
13:05:44 <absentia> http://www.spy.org/tmp/lang-by-sdy.jpg ... need to ad hitler in there somewhere?
13:06:16 <mreh> the FFIs try to mirror the major version number of the interface they're implementing, no?
13:06:36 <jmcarthur> not that i know of, but i may be wrong
13:06:41 <jmcarthur> i haven't bothered checking that
13:07:03 <jmcarthur> mreh: OpenGLRaw definitely doesn't do that
13:07:26 <mreh> addy hitler
13:07:27 <jmcarthur> oh, huh, looks like OpenGL supports version 3.2 after all
13:07:39 <jmcarthur> (and the version number doesn't reflect that either, btw)
13:07:44 <jmcarthur> waitaminute
13:07:49 <mreh> jmcarthur, where did you read this?
13:07:59 <jmcarthur> ugh, it doesn't actually
13:08:11 <jmcarthur> mreh: http://hackage.haskell.org/package/OpenGL
13:08:12 <mreh> jmcarthur, it imports the types from Raw, which is confusing
13:08:34 <jmcarthur> the OpenGL package doesn't even export enough of the functionality to be opengl 3
13:08:40 <jmcarthur> openglraw should though
13:08:58 <jmcarthur> i'm pretty sure OpenGL on hackage supports version 2.1 of the spec
13:09:11 <mreh> jmcarthur, I'm just trying to get my head round the frag code
13:09:24 <mreh> i'll stick with what he's used for now, just to get it to compile
13:09:29 <jmcarthur> ew frag
13:09:42 <erikc> frag probably uses the fixed function pipeline
13:09:43 <mreh> <_<
13:09:48 <jmcarthur> yeah probably
13:09:56 <mreh> I don't know what that means
13:10:03 <jmcarthur> it means it's slow and antiquated
13:10:09 <mreh> excellent
13:10:26 <Twey> What is the fixed function pipeline?
13:10:29 <mreh> it looks like to was written before cabal
13:10:54 <jmcarthur> Twey: when you use immediate mode and the old-school GL pipeline rather than VBOs and shaders
13:10:57 <erikc> mreh: pre-2.0 opengl was an API for manipulating a fixed data processing pipeline, with most of the computations predetermined and little hooks here and there to influence it
13:11:40 <erikc> opengl2 added the ability to inject little programs (shaders) to execute at certain parts of this pipeline, replacing most of the fixed machinery in the process
13:11:48 <jmcarthur> erikc: 2.0 didn't even deprecate it, did it? it wasn't until 3 that that was actually deprecated i think
13:11:50 <mreh> is there an openGL o'reilly or similar worth reading?
13:12:06 <jmcarthur> mreh: maybe opengl superbible or something
13:12:09 <mreh> on the linear algebra level
13:12:13 <jmcarthur> i haven't read much literature on it
13:12:14 <erikc> one of the reasons opengl is so ugly is cause it keeps the old fixed function stuff alive rather than cutting it out, cause there's lot of big companies with legacy code bases etc etc
13:12:16 <jmcarthur> oh
13:12:24 <Null-A> what do you guys recommend as a haskell editor?
13:12:28 <Null-A> (or ide)
13:12:42 <erikc> opengl3 was supposed to cut out the old pipeline (like directx10 did), but they ran into problems getting it done in the committee
13:12:50 <jmcarthur> i dunno about the linear algebra level. i have a textbook from my computer graphics course in uni, but i forget the name. i could get back to you with the name later if you want, mreh
13:13:01 <jmcarthur> erikc: yeah :(
13:13:20 <mreh> jmcarthur, I'm taking machine vision, which is like inverse graphics, but the graphics pipeline is something I never learned
13:13:32 <jmcarthur> Null-A: i used emacs and love it, especially for haskell. nobody here is going to universally agree of course
13:13:43 <mreh> Null-A: gedit
13:13:46 <erikc> mreh: i recommend http://www.amazon.com/dp/1568814240/?tag=rbookshop-20
13:13:52 <erikc> it is very current
13:13:57 <mreh> erikc: thanks
13:14:11 <erikc> has hardware overviews of ps3 / pc / xbox360 / mobile hardware
13:14:14 <erikc> as well
13:14:27 <jmcarthur> hmm... i might have to order this
13:14:34 <Null-A> jmcarthur: do you know how vim stacks up in terms of haskell support?
13:14:48 <jmcarthur> Null-A: it has some, but i don't use it much for haskell
13:15:02 <Null-A> k, i'll checkout emacs
13:15:21 <Null-A> is there any autocompletion for haskell?
13:15:25 <jmcarthur> Null-A: other people will disagree with my choice btw, so don't take my word as gold
13:15:26 <revertTS> Null-A: vim works pretty well; there's a set of useful plugins, too: http://projects.haskell.org/haskellmode-vim/
13:16:30 <Null-A> revertTS: thx
13:16:54 * jmcarthur leaves work
13:17:26 <mreh> did he just say "the openGL shitting language"
13:17:47 <erikc> shading
13:18:36 <mreh> Eskil Steenberg lost weight
13:20:01 <roconnor> @hoogle base
13:20:01 <lambdabot> package base
13:20:01 <lambdabot> Text.Html base :: String -> HtmlAttr
13:20:01 <lambdabot> Text.XHtml.Frameset base :: String -> HtmlAttr
13:20:21 <erikc> mreh: if you are interested in non-real time graphics, Physically Based Rendering is a good one
13:22:45 <mreh> erikc: raytracing?
13:25:10 <erikc> yea
13:27:37 <Associat0r> erikc: new one is coming out
13:28:17 <erikc> Associat0r: new PBR?
13:28:38 <Associat0r> yep
13:28:57 <erikc> cool, good to know, i'll wait instead of buying the old edition
13:29:53 <erikc> oh, it's an open source book: http://github.com/mmp/pbrt-v2
13:30:27 <erikc> n/m, that's just the accompnaying code
13:52:39 <ajoop> how do i import happy and parsec?
13:53:23 <ajoop> i need to do a project where i compare and contrast the two libs, but i don't know how to load them, i finally got haskell to load in emacs
13:55:40 <iaefai> roconnor: There is a logo concept you have on the wiki for ghc. I was wondering if I could get the svg, I want to see if I can make a decent looking mac icon with it.
14:04:01 <h-cell>  > (return 2) * 3
14:04:08 <h-cell> > (return 2) * 3
14:04:08 <lambdabot>   No instance for (GHC.Num.Num (m t))
14:04:09 <lambdabot>    arising from the literal `3' at <int...
14:04:18 <h-cell> ?
14:04:25 <mreh> h-cell: what are you trying to do?
14:04:59 <h-cell> multply an IO Int by a double
14:05:07 <hpc> that's...not possible
14:05:12 <hpc> unless you want
14:05:20 <tromp_> not necessarily IO, any monad
14:05:24 <hpc> > (*3) <$> (return 2)
14:05:25 <mreh> > (return 2) `liftM` (*3)
14:05:25 <lambdabot>   No instance for (GHC.Show.Show (f a))
14:05:25 <lambdabot>    arising from a use of `M1771045596...
14:05:26 <lambdabot>   {-3->2;-2->2;-1->2;0->2;1->2;2->2;3->2}
14:05:51 <h-cell> > (return 3)  >>=  (*2)
14:05:51 <lambdabot>   No instance for (GHC.Num.Num (m b))
14:05:52 <lambdabot>    arising from the literal `3' at <int...
14:06:02 <mreh> h-cell: do you understand monads?
14:06:08 <mreh> in haskell IO is a monad
14:06:10 <h-cell> not at all
14:06:35 <hpc> btw, you want GHCi for this
14:06:38 <mreh> h-cell: you can't even go (IO a -> a) in haskell
14:06:40 <hpc> lambdabot doesn't like IO
14:06:48 <Twey> h-cell: The function to the right of >>= needs to wrap the value in the monad again
14:07:02 <mreh> lambdabot only evaluates expressions, she doesn't execute IO
14:07:07 <Twey> > return 3 >>= return (* 2) :: Maybe Int
14:07:08 <lambdabot>   The section `GHC.Num.* 2' takes one argument,
14:07:08 <lambdabot>  but its type `Data.Maybe.May...
14:07:11 <Twey> Oops
14:07:14 <Twey> > return 3 >>= return . (* 2) :: Maybe Int
14:07:15 <lambdabot>   Just 6
14:08:36 <Twey> h-cell: You can't multiply an IO Int by anything, because you don't know what the Int is yet  an IO Int is like a recipe that specifies a sequence of actions that need to be performed, that will yield an Int
14:08:55 <Twey> h-cell: What you can do is add a bit onto the end of that sequence that says  and then multiply it
14:09:00 <Twey> That's what >>= is for
14:11:29 <dancor> do {i <- read `fmap` getLine; return (fromIntegral (i :: Int) * 3.1)}
14:11:50 <dancor> :t do {i <- read `fmap` getLine; return (fromIntegral (i :: Int) * 3.1)}
14:11:50 <lambdabot> forall b. (Fractional b) => IO b
14:12:03 <dancor> :t do {i <- read `fmap` getLine; return (fromIntegral (i :: Int) * (3.1 :: Double))}
14:12:04 <lambdabot> IO Double
14:13:02 <FliPPeh_> Is there no good HxT Tutorial?
14:13:06 <FliPPeh_> @hoogle hxt tutorial
14:13:06 <lambdabot> No results found
14:13:23 <FliPPeh_> I'd love to find one that's NOT using the arrow notation
14:13:33 <FliPPeh_> It's just confusing me even more
14:13:39 <tensorpudding> @google HxT Tutorial
14:13:40 <lambdabot> http://www.haskell.org/haskellwiki/HXT
14:13:41 <lambdabot> Title: HXT - HaskellWiki
14:13:59 <EvanR-work> > !True
14:14:00 <lambdabot>   <no location info>: Illegal bang-pattern (use -XBangPatterns)
14:14:02 <edlinde> what editor do most people use for haskell?
14:14:05 <edlinde> emacs?
14:14:06 <EvanR-work> > not True
14:14:07 <lambdabot>   False
14:14:12 <EvanR-work> :\
14:14:12 <FliPPeh_> vim
14:14:14 <FliPPeh_> Notepad
14:14:19 <tensorpudding> I think most peole use emacs, vim or yi
14:14:25 <edlinde> ok
14:14:42 <edlinde> so there is no funny bracket matching business going on with Haskell?
14:14:43 <tensorpudding> Some Windows people use Notepad or Notepad++, and some Mac people probably use Textmate
14:14:54 <edlinde> yeah I use textmae
14:14:56 <edlinde> mate
14:14:57 <tensorpudding> There is also Leksah but I'm not sure of its use.
14:15:21 <tensorpudding> Leksah is the only thing that claims to be an IDE for Haskell.
14:15:22 <FliPPeh_> Leksah is confusing
14:15:30 <FliPPeh_> I was unable to even compile anything
14:15:41 <tensorpudding> Yi is the most interesting editor written in Haskell.
14:15:58 <edlinde> yi comes for macosx?
14:16:17 <nlogax> it works fine, using it on 10.6.something right now
14:16:21 <tensorpudding> It is written in Haskell so it should be available anywhere you can compile Haskell.
14:16:30 <edlinde> cool
14:16:35 <tensorpudding> It's console-based so you'd run it inside Terminal.app
14:16:37 <nlogax> install the haskell platform, then cabal install yi
14:16:51 <tensorpudding> Well, unless it depends on the unix package, but I'm pretty sure OS X supports the unix package.
14:17:06 <edlinde> I have haskell installed last time
14:17:54 <revertTS> is work still being done on eclipsefp?
14:18:56 <edlinde> actually its a shame that I have a functional programming course next semester and the language of instruction will be ML
14:19:07 <edlinde> but over summer I really want to learn Haskell though
14:19:34 <edlinde> would I be able to transfer some of the functional programming concepts from Haskell to ML?
14:19:43 <erikc> yes, very easily
14:19:53 <ajoop> how do you open up different libraries in haskell? i need to compare happy and parsec, but i don't know how to import them and then import them into two different windows
14:20:19 <tensorpudding> Some of them.
14:20:38 <edlinde> erikc: ok thanks
14:20:47 <tensorpudding> ML is very kin to Haskell in the way it handles polymorphic types and patten matching; Haskell drew from ML significantly in those areas.
14:21:03 <tensorpudding> But ML is impure and strict, in opposition to Haskell.
14:21:25 <aavogt> the keywords are all different over there
14:21:37 <aavogt> case -> match, of -> with
14:21:38 <edlinde> hmm so haskell is not strict type checking?
14:21:50 <Associat0r> lazy
14:21:58 <tensorpudding> Also it breaks down when you consider the special GHC extensions, like higher-kinded types, etc. which I wouldn't know if are available in SML or OCaml
14:22:12 <aavogt> edlinde: types are checked at compile time
14:22:14 <tensorpudding> The typechecking uses Hindley-Milner.
14:22:20 <tensorpudding> But evaluation is lazy.
14:22:28 <edlinde> ok
14:22:42 <Associat0r> tensorpudding: aren't higher-kinded types standard Haskell?
14:22:48 <edlinde> i heard something along the lines of that you can have infinite sets in haskell
14:23:08 <Associat0r> tensorpudding: I guess you mean fundeps and GADT's
14:23:29 <tensorpudding> Err, I meant Rank-n types.
14:23:41 <chrissbx> edlinde: "strict" as in http://en.wikipedia.org/wiki/Evaluation_strategy#Strict_evaluation
14:23:44 <tensorpudding> Which you need a compiler extension to use.
14:23:50 <Associat0r> ah ok
14:24:11 <tensorpudding> The fact that you can have infinite sets is facilitated by Haskell, but you can simulate them in ML as well.
14:24:48 <edlinde> ok
14:25:28 <fax> infinite sets ?
14:25:45 <edlinde> i just hear that it takes a long time before you actually get the grasp of functional programming.. I haven't done any in the past
14:25:51 <edlinde> so... hmm :)
14:26:07 <tensorpudding> Not just infinite sets, but infinite data structures in general.
14:26:51 <fax> od
14:26:53 <fax> oh ok
14:27:23 <tensorpudding> by set I mean Data.Set
14:27:49 <tensorpudding> I think.
14:28:48 <fax> Data.Set can't be infinite though can it?
14:28:53 <Null-A> Monad's look extremely costly to execute, especially considering that imperative programs merely have to increment eip to get to the next instruction
14:29:14 <tensorpudding> Probably not.
14:29:27 <monochrom> Not just monad. Any function.
14:29:32 <dobblego> Null-A, monads are an interface
14:29:32 <lambdabot> dobblego: You have 1 new message. '/msg lambdabot @messages' to read it.
14:29:39 <tensorpudding> Though you can't have an infinite list in memory, you can generate them, and pass them around
14:30:01 <fax> Null-A why not compile the monad into eip++ then?
14:30:35 <Null-A> fax: because they're a lot more complicated than that, they support additional features
14:30:47 <mreh> don't we usually mention that one line of haskell usually replaces many lines of the equiv imperative program?
14:30:53 <fax> Null-A ok
14:30:56 <monochrom> But "increment eip" does so little, I don't care how fast you can do it.
14:30:59 <dobblego> @type flip fmap pure
14:31:00 <lambdabot> forall b a (f :: * -> *). (Applicative f) => (f a -> b) -> a -> b
14:33:32 <idnar> Null-A: a program that does nothing but increment eip is not terribly interesting
14:33:53 <Null-A> idnar: right... I think you understand what I'm trying to express
14:33:56 <Null-A> i'm still really new to haskell
14:34:24 <Null-A> e.g. what are the performance differences between haskell code which makes 10 sequential opengl calls, and C++ code
14:34:49 <pikhq> Depends.
14:34:58 <idnar> I'd expect there to be no significant difference, assuming you're talking about straight low-level opengl calls
14:34:59 <Null-A> all these massive abstractions "Monads", etc look costly
14:35:12 <pikhq> Monads are, for the most part, very *un*costly.
14:35:22 <aavogt> have you seen that they are too expensive?
14:35:28 <pikhq> (certain monads are, certain monads are nearly no-ops)
14:35:33 <Null-A> not yet, I haven't conducted any experiments
14:35:42 <Null-A> the compiler must be pretty amazing then
14:35:48 <Null-A> (if the performance is similar)
14:35:56 <opqdonut> not really
14:36:04 <monochrom> Please don't waste time on your uninformed opinion.
14:36:05 <pikhq> It is, but that's beside the point, as monads actually don't have complicated semantics.
14:36:07 <opqdonut> sure, it is amazing, but it neend't be
14:36:20 <pikhq> It's literally two tiny functions.
14:36:37 <opqdonut> you see, Null-A, most type stuff disappears at runtime
14:36:50 <Null-A> isn't every statement in a moment a single function call?
14:36:51 <opqdonut> what's left is a bunch of functions and a very efficient implementation of lazy evaluation
14:36:54 <opqdonut> basically
14:37:39 <opqdonut> calling a function isn't done by allocating a stack frame etc. as it is in, say, C
14:38:07 <pikhq> Null-A: Function calls in Haskell are cheap.
14:38:13 <pikhq> (... Normally.)
14:39:04 <pikhq> Also, GHC does a *lot* of inlining. :)
14:39:12 <Null-A> right *nods* one of my questions
14:39:39 <erikc> does GHC do cross-module inlining?
14:39:46 <pikhq> erikc: Yes.
14:40:02 <erikc> is that done on the compile step or the link step?
14:40:09 <pikhq> I dunno.
14:42:03 <monochrom> compile step
14:42:44 <monochrom> If -O, *.hi files contain code, not just types and names.
14:43:05 <erikc> right
14:43:21 <erikc> so comparable to C++ inlining + one definition rule
14:43:35 <pikhq> Except without the pain of headers.
14:43:40 <erikc> yes :)
14:43:47 <erikc> which is a nice pain to be rid of
14:50:26 <Chaze> i assume there's no build-in function (f 123) == [1,2,3] ?
14:50:49 <tensorpudding> is that 123, or 1 2 3?
14:50:52 <monochrom> No. but there is (show 123) == ['1','2','3']
14:52:24 <Chaze> > map (read . (:[])) (show 123) :: [Int]
14:52:25 <lambdabot>   [1,2,3]
14:53:17 <twink> > unfoldr (\n -> if n == 0 then Nothing else Just . uncurry (flip (,)) $ n `divMod` 10) 123
14:53:18 <lambdabot>   [3,2,1]
14:53:30 <lelf> > map digitToInt . show $ 12345
14:53:31 <lambdabot>   [1,2,3,4,5]
14:54:02 <bo0ts__> Hi, I have a list with functions and want to apply every function to a corresponding list with arguments. Is there a simple way to do that?
14:54:28 <mle> Chaze: map (\x->ord x - 48) $ show
14:55:05 <Chaze> mle: i'd rather not use that :)
14:55:09 <twink> > map (reverse . unfoldr (\n -> if n == 0 then Nothing else Just . uncurry (flip (,)) $ n `divMod` 10)) [123,12345]
14:55:09 <mle> heh
14:55:10 <lambdabot>   [[1,2,3],[1,2,3,4,5]]
14:55:18 <mle> digitToInt is better anyway
14:55:52 <Chaze> > reverse $ map ((flip mod) 10) (takeWhile (>0) (iterate ((flip div) 10) 123))
14:55:54 <lambdabot>   [1,2,3]
14:56:00 <twink> mle: I was working on the assumption that relying on library implementations of radix conversion was not kosher.
14:56:06 <monochrom> @type digitToInt
14:56:07 <lambdabot> Char -> Int
14:56:18 <EvanR-work> bo0ts__: map map ? :)
14:56:21 <EvanR-work> :t map map
14:56:22 <lambdabot> forall a b. [a -> b] -> [[a] -> [b]]
14:56:23 <monochrom> > map digitToInt (show 1231415)
14:56:24 <lambdabot>   [1,2,3,1,4,1,5]
14:57:00 <mreh> how long can you argue with someone who doubts FP is "useful"
14:57:13 <bo0ts__> EvanR-work: I tried that, but I got stuck with compile errors. I thought map would take one function and a list but I have a whole list of functions.
14:57:55 <EvanR-work> bo0ts__: yes, map map theList
14:58:06 <monochrom> I argue for 0 seconds with someone who doubts FP usefulness.
14:58:18 <lelf> > map digitToInt . flip showHex "" $ 1023
14:58:19 <lambdabot>   [3,15,15]
14:58:26 <mreh> there's alot of FUD from the games community it seems
14:58:47 <monochrom> Why would you want more people to compete with you in FP?
14:59:12 <EvanR-work> increase the demand for haskell, but not the supply. convertting / englightening programmers increases the supply
14:59:57 <mreh> so who wants to develop games with me?
15:00:07 <monochrom> Perhaps you believe they are not potential competitors, they are potential collaborators. But I don't see why, given their stance, they could possibly be collaborators.
15:00:12 <twink> mreh: I thought games work was mostly in their scripting engines and the graphic design and audio vs. something FP would have much to do with.
15:00:19 <gwern> mreh: wouldn't you rather play a nice game of chess?
15:00:35 <mreh> gwern: battle chess?
15:00:40 <EvanR-work> functional chess
15:00:41 <gwern> wizarding chess!
15:00:48 <mreh> gwern: I was about to say that
15:00:54 <monochrom> functional thermal nuclear war
15:01:02 <twink> 3-dimensional battle chess?
15:01:03 <monochrom> @quote thermal
15:01:03 <lambdabot> No quotes match. I am sorry.
15:01:04 <aavogt> you might be able to convince somebody that a project can be written using some FPL?
15:01:21 <monochrom> functional thermal nuclear war is referentially transparent
15:01:33 <TomMc> Hello. Can anyone recommend a simple 2d graphics library? I don't need anything fancy like openGL rendering, just plot points, lines, fills etc.
15:01:41 * gwern eats an almond. I always worry, is this going to be from the one tree that mutated back to producing cyanide?
15:01:43 <mreh> TomMc: HGL
15:01:57 <gwern> mreh: thought that was graphs, not graphics :)
15:02:02 <TomMc> mreh: I'll take a look.
15:02:19 <lispy> TomMc: there is also a cairo binding
15:02:45 <mreh> TomMC: HGL is stupidly simple, I did an asteroids clone in it, but that's about all it's good for
15:03:26 * EvanR-work gives gwern an almonad
15:03:30 <EvanR-work> way better
15:03:44 <mreh> twink: scripting is something I'd like to introduce to frag
15:04:09 <TomMc> cool. All I want it for is to draw some simple fractals (don't need a fractal library, or L-systems yet)
15:04:26 <mreh> TomMc: snowflakes? perfect
15:04:28 <gwern> TomMc: maybe you should just rip off elerea
15:04:29 <alpounet> mreh, you will work on frag ?
15:04:35 <gwern> or no, nyphaea?
15:04:40 * gwern forgets
15:04:50 <mreh> alpounet: yeah, once I understand OpenGL, i know FRP,
15:04:56 <alpounet> ok
15:04:56 <gwern> nymphaea?
15:04:58 <mreh> I wrote Haskelloids
15:05:01 <alpounet> oh
15:05:03 <alpounet> I tried it
15:05:06 <alpounet> I had fun :D
15:05:26 <mreh> a framework for writing decent GUIs is something I'd like to learn next
15:05:37 <gwern> mreh: you and every FRP academic
15:05:56 <EvanR-work> i like fltk, but its very c++
15:06:05 <EvanR-work> dont know about the possibility of haskell binding or wrapping
15:06:16 <mreh> gwern: Imagining how I'd have a menu running over a game as it runs sort of makes me cry
15:06:16 <gwern> if we can bind qt...
15:06:29 <Twey> We have QtHaskell
15:06:38 <Twey> Ah, right, yeah.
15:06:45 <TomMc> gwern: Don't think I'll need FRP just yet.
15:07:15 <alpounet> is it that hard ?
15:07:21 <alpounet> (to make right, I mean)
15:07:43 <mreh> alpounet, ?
15:07:49 <alpounet> <mreh> gwern: Imagining how I'd have a menu running over a game as it runs sort of makes me cry
15:08:24 <mreh> alpounet: well defining an interface that relays user input
15:08:31 <mreh> to both the game and menu and captures the outputs
15:08:46 <mreh> it's a union of all the interfaces into one horrible interface
15:08:56 <mreh> that isn't scalable
15:08:59 <alpounet> hmm
15:09:13 <mreh> these are my first thoughts on the matter
15:09:18 <alpounet> maybe you could design some sort of "graphical work queue"
15:09:20 <mle> composable interfaces
15:09:29 <alpounet> a bit similar to that of the new I/O manager
15:09:43 <mle> with a design something like what xmonad does
15:09:50 <bo0ts__> EvanR-work: What is wrong with this? map (map mapMult [1..]) [1..]
15:10:03 <mreh> maybe I have a life in research and not games design
15:10:13 <bo0ts__> mapMult :: (Num a, Enum a) => a -> Int -> [Char]
15:10:39 <alpounet> mreh, I think a work queue based approch can be nice
15:10:44 <aavogt> @unpl map mapMult [1..]
15:10:44 <lambdabot> map mapMult [1 ..]
15:10:51 <alpounet> but I agree that the current situation isn't very practical...
15:10:57 <alpounet> *approach
15:11:13 <aavogt> bo0ts__: the outer Int isn't being added where you think it is
15:11:37 <mreh> alpounet: have you got a paper on the work queue thing?
15:12:32 <bo0ts__> aavogt: How do I fix it? xD
15:12:58 <aavogt> a list comprehension might be clearer here:
15:13:20 <aavogt>   [ mapMult x y | x <- [1..], y <- [1..] ]
15:13:30 <aavogt> though I'm not sure which order of x, y you have
15:14:00 <mreh> mle: how does xmonad work?
15:14:15 <aavogt> mle: it it a game?
15:14:18 <aavogt> :P
15:14:39 <alpounet> mreh, check http://citeseer.ist.psu.edu/hinze01simple.html
15:14:39 <bo0ts__> aavogt: That makes perfect sense. Thanks alot.
15:14:40 <aavogt> anyways, xmonad isn't terribly composable with it's configurations
15:14:58 <alpounet> mreh, see http://github.com/tibbe/event/blob/master/src/System/Event/PSQ.hs and Johan's blog
15:15:03 <alpounet> for implementation
15:15:04 <mreh> alpounet: got an offline version of that?
15:15:17 <mreh> or one off the academic network
15:15:21 <mreh> i'm not at university
15:15:44 <alpounet> mreh, it is downloadable for everyone
15:15:50 <alpounet> see the right corner
15:15:55 <alpounet> "DOWNLOAD"
15:18:10 <mreh> alpounet: the 5th I tried, but I got it in the end ;)
15:18:24 <alpounet> heh ok :)
15:18:35 <alpounet> mreh, you can use the "Cached" links generally
15:18:45 <alpounet> i use them generally
15:25:40 <Chaze> :t ap
15:25:40 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
15:36:47 <Mathnerd314> how hard is it to replace the prelude?
15:36:59 <ddarius> Not hard with GHC.
15:37:16 <ddarius> Not particularly hard otherwise.
15:37:30 <Mathnerd314> so why is it defined?
15:39:30 <gwern> Mathnerd314: network effects?
15:40:29 <Mathnerd314> well, one could turn it into another library
15:41:53 <Mathnerd314> there don't seem to be many network effects with those
15:42:17 <applicative> Mathnerd314, whats wrong with the prelude as it stands?   ...Just wondering.
15:42:31 <Mathnerd314> @type (.)
15:42:32 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:43:05 <Mathnerd314> @type flip
15:43:06 <applicative> you can get rid of that for sure.
15:43:07 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
15:43:13 <Mathnerd314> etc.
15:43:18 <EvanR> how do you hide the entire prelude
15:43:19 <aavogt> that's not the real Prelude though
15:43:27 <aavogt> import Prelude ()
15:43:27 <EvanR> import Prelude ()
15:43:29 <EvanR> ok
15:43:35 <ivanm> byorgey: yay for "cabal init" blog post! \o/
15:43:38 <aavogt> that still exposes instances
15:43:39 <applicative> the pragma noimplifit prelude
15:43:56 <applicative> the pragma IoImplicitPrelude
15:43:59 <aavogt> though I'm not sure how those matter if the classes are not imported either
15:44:31 <mreh> what is the incentive to start a blog? I have webspace now... it would fill up the space
15:45:03 <ezyang> mreh: Get some laddies together and do Iron Blogger <http://iron-blogger.mit.edu/the-rules/>
15:45:55 <mreh> ezyang: that's majorly uncool
15:46:17 <dancor> ha
15:46:27 <dancor> the blogger calling the kettle black
15:46:55 <mreh> I had a moment of self denial then
15:47:14 <mreh> thank god that's over
15:53:38 <slava> dons: why are mine and erg's submissions blocked by proggit?
15:53:43 <slava> dons: this has been the case for a few months now
15:53:59 <gwern> slava: obviously you spammed too much. maybe if you spammed some haskell stuff instead you'd be unblocked
15:54:22 <gwern> re-educate yourself, slava!
15:56:03 <applicative> Mathnerd314, I meant to say that there is the ever amusing example of Jijing Wang, who imports his MPS library http://hackage.haskell.org/package/mps into everything he writes.  There are many odd preludes afloat, I used to use a UTF8 prelude sometimes
15:56:46 <ezyang> mps \o/
15:57:03 <applicative> pretty wild.
15:58:09 <ezyang> It might be kind of interesting to do a survey of all of the alternative preludes floatingi n the wild
15:59:07 <gwern> 'tenth' well gosh isn't that useful
16:00:08 <gwern> and 'is_palindrom :: (Eq a) => [a] -> Bool'! truly a useful function
16:00:21 <nus> huh, "DSL that allows one to write Haskell from left to right" ?
16:00:23 <applicative> oh, yeah, tenth.  I guess it humanizes.
16:00:26 <Saizan> applicative: oh, god
16:00:31 <ezyang> nus: It's amazing. :-)
16:00:51 <nus> and ordinarily you write Haskell, what, RTL?
16:01:19 <Saizan> nus: it refers to composition pipelines
16:01:43 <applicative> Saizan,  Mathnerd314 seems to have gone missing, but he was inquiring about the possibility of chucking the standard Prelude... this was to show it's quite possible.
16:01:54 * Mathnerd314 is here
16:02:01 <ezyang> I mean, the standard Prelude almost certainly ought to be chucked
16:02:12 <ezyang> But no one can decide "for what" and how to deal with the resulting bc headache
16:02:30 <Mathnerd314> well, one can start by generalizing all the types
16:02:30 <nus> Saizan, oh.. quite unhelpful description it is, then.
16:02:43 <applicative> I like it, but I'm an idiot.  I think it's for educational, pedagogical purposes.
16:02:54 <nus> (http://github.com/nfjinjing/mps/ doesn't exists, also)
16:03:13 <applicative> nus, I noticed, he's taken everything down from github
16:03:32 <applicative> Mathner314, speaking of github, there
16:03:53 <Mathnerd314> applicative: ?
16:04:01 <applicative> is the "awesomeprelude" there
16:04:25 <applicative> it attempt to turn all the prelude types into type classes
16:04:32 * nus cabal unpack's mps
16:04:48 <ezyang> http://github.com/tomlokhorst/AwesomePrelude
16:04:59 <applicative> it is very interesting, but for a special purpose.
16:05:07 * ivanm hates mps
16:05:18 <ivanm> the versioning system doesn't help, nor the lack of comments
16:05:38 <ivanm> but I don't get why people keep trying to program C in Haskell...
16:07:22 <applicative> ivanm, isn't e.g. 'do' syntax aimed at that taste?
16:07:38 <ivanm> applicative: I'm talking about even more than that
16:07:44 <ivanm> e.g. zaxis on -cafe
16:07:56 <ivanm> and even all the mps stuff is an attempt to do that IMHO
16:09:33 <ivanm> OK, apparently mps is "simply OO"
16:10:00 <Mathnerd314> hmm... "awesomeprelude" doesn't seem compatible with the existing prelude
16:10:04 <nus> http://www.maztravel.com/haskell/MPSexamples.html -- is this what all the fuss about?
16:10:07 <nus> feh
16:10:14 <nus> is about*
16:10:33 <applicative> yes but mr. mps had the best response to zaxis
16:10:48 <ivanm> applicative: "best response"?
16:11:01 * ivanm doesn't actually know what the basis of this conversation is about, as he just came in... >_>
16:11:14 <applicative> http://old.nabble.com/About-code-style---tt27414627.html#a27429649
16:12:15 <ivanm> applicative: so it's _his_ fault that zaxis has that stupid definition in his sig...
16:13:18 <applicative> ivanm, i guess
16:16:16 <dancor> but what's all the js stuff in the AwesomePrelude
16:16:18 <ezyang> nom "I stuck with the Haskell 98 names. In some cases I find them lacking. Neglecting backwards compatibility, we have renamed classes as follows: Num --> Ring, Fractional --> Field, Floating --> Algebraic + Transcendental, RealFloat --> RealTranscendental, "
16:17:06 <Saizan> i guess zaxis also writes "x = { y + z };" in C
16:17:11 <dancor> does signum always make sense for rings
16:17:51 <ddarius> dancor: Does signum make sense for fields?
16:18:47 <dmhouse> dancor, no
16:18:47 <Mathnerd314> > signum 2.5
16:18:48 <lambdabot>   1.0
16:19:20 <dmhouse> dancor: there's no requirement you have an order relation on rings
16:19:49 <dmhouse> dancor: if you had a total order that would do it (or at least a partial order where either 0 < x or x < 0 for all x)
16:20:53 <dancor> so Num is like OrdRing
16:21:05 <dancor> well there's no order
16:21:09 <dancor> it's a mess.
16:21:11 <ddarius> dmhouse: Wouldn't that induce a total order? (x - y) < 0
16:21:25 <dancor> hm
16:21:36 <dmhouse> ddarius: if the order were compatible with the ring operations, yeah (which you probably want)
16:21:42 <Saizan> in the standard prelude (Show a, Ord a) => Num a
16:22:00 <dmhouse> Saizan: huh? It says (Eq a, Show a) here
16:22:16 <Saizan> oh, i misremembered then
16:22:17 <ddarius> Saizan: Ord is definitely not a requirement.
16:22:20 <dmhouse> You can get an Ord instance given a Num one though
16:22:37 <ddarius> > (3 :+ 2) < (4 :+ 2)
16:22:38 <lambdabot>   No instance for (GHC.Classes.Ord (Data.Complex.Complex t))
16:22:38 <lambdabot>    arising from ...
16:22:46 <dmhouse> Or maybe not, hang on
16:22:53 <ddarius> > signum (3 :+ 2)
16:22:54 <lambdabot>   0.8320502943378437 :+ 0.5547001962252291
16:23:08 <Saizan> Ring doesn't imply decidable equality either, though :)
16:23:19 <xerox> ?type signum
16:23:20 <lambdabot> forall a. (Num a) => a -> a
16:23:28 <ddarius> I guess if signum is a -> a then you don't have a total order necessarily.
16:23:33 <dmhouse> No, I guess there's no way of getting an Ord instance from the Num operations
16:23:48 <xerox> I guess 5
16:24:20 <dmhouse> I was thinking you could test signum (x - y) against fromInteger 1, fromIntger 0 and fromInteger (-1), but there's no requirement that the range of signum is restricted to these
16:24:33 <dmhouse> Also, many Num instances don't implement signum etc.
16:24:45 <Mathnerd314> so signum is completely separate from the rest of Num... thus it should be a separate typeclass
16:24:47 <benmachine> x = abs x * signum x is how I understand it
16:24:53 <LegendaryPenguin> how can I call system from haskell on windows?
16:25:08 <ddarius> > magnitude (signum (1 :+ 1))
16:25:09 <lambdabot>   0.9999999999999999
16:25:10 <Saizan> LegendaryPenguin: see System.Process
16:25:14 <dmhouse> benmachine: yep, that's what the docs say
16:25:19 <ddarius> > signum (1 :+ 1)
16:25:20 <lambdabot>   0.7071067811865475 :+ 0.7071067811865475
16:25:59 <dmhouse> So signum x = x / abs x, but for e.g. Complex this can take on many values
16:26:08 * ddarius needs to remember to use signum on complex numbers more often.
16:26:26 <benmachine> dmhouse: signum x = x / abs x whenever / is defined on x :)
16:26:32 <dancor> in general haskell seems curiously uninterested in typeclass sanity
16:26:42 <dmhouse> benmachine: oh, oops, (/) isn't in Num
16:26:49 <lispy> ?hoogle system
16:26:49 <lambdabot> No results found
16:27:11 <ddarius> benmachine: What's abs defined as (in general)?
16:27:24 <ddarius> (Note finite fields have division...)
16:27:36 <dmhouse> abs doesn't make sense in finite fields
16:27:44 <benmachine> ddarius: the amount of bigness of x
16:27:44 <dmhouse> Since they're not orderable
16:27:56 <ddarius> dmhouse: Exactly.
16:28:15 <lispy> LegendaryPenguin: http://www.haskell.org/ghc/docs/latest/html/libraries/process-1.0.1.2/System-Cmd.html#v%3Asystem
16:28:30 <benmachine> I think the Prelude hierarchy is designed for the Prelude types
16:28:44 <benmachine> fromInteger should probably be separated out because it's used in syntax
16:29:47 <Mathnerd314> dmhouse: abs x = 1 works well for finite fields
16:30:02 <dmhouse> Mathnerd314: in what sense?
16:30:03 <kbp> could anyone please help me with pattern matching? I don't know why there is error in http://codepad.org/kvqoLRKv
16:30:20 <Mathnerd314> dmhouse: nothing stops working
16:30:24 <benmachine> abs x = 1 and signum = id; sorted
16:30:34 <dmhouse> Well that'd work in any ring
16:30:43 <ezyang> kbp: Remove the parens
16:31:01 <Mathnerd314> actually, abs x = if x == 0 then 0 else 1
16:31:02 <kbp> ezyang: oh silly me, thank you :D
16:31:02 <dmhouse> I'd like abs x to always satisfy abs x >= 0, equality iff x = 0, but this doesn't make sense unless you can order the ring
16:31:08 <ezyang> you'll need to fix the bottom too
16:32:32 <benmachine> dmhouse: maybe it's strange that abs returns an element of the type
16:32:45 <benmachine> I was thinking of making it determinant for matrices, for exampe
16:32:47 <benmachine> *example
16:32:53 <benmachine> but that doesn't really work
16:33:07 <dmhouse> Matrix norm would work better
16:33:09 <ddarius> benmachine: You'll just have to generalize to a larger algebra.
16:33:23 <dmhouse> (FSOV "better".)
16:33:39 <Mathnerd314> @type abs
16:33:40 <lambdabot> forall a. (Num a) => a -> a
16:39:14 <FunctorSalad_> unless I'm missing something, the norm must be constant? since if 0 < a, you get 0 < 0 eventually by repeated transitivity and addition congruence?
16:39:25 <FunctorSalad_> ( 0 < a < a +a < .... < 0 )
16:39:37 <FunctorSalad_> same for 0 > a, of course
16:40:48 <dmhouse> FunctorSalad_: that's why you can't define an order on a finite ring
16:41:33 <FunctorSalad_> dmhouse: doh, I'm just not paying enough attention
16:42:26 <FunctorSalad_> was muddling general norms with norms derived from the ordering maybe
16:42:30 <Mathnerd314> > abs (1 :+ 2)
16:42:31 <lambdabot>   2.23606797749979 :+ 0.0
16:42:57 <Mathnerd314> definitely need abs [[a,-b][b,a]] == [[a,-b][b,a]]/(a^2+b^2) for matrices
16:43:02 <FunctorSalad_> (err and even that is just positive-ring-element-valued, not real-valued)
16:43:07 <ddarius> @src Complex abs
16:43:07 <lambdabot> Source not found. You type like i drive.
16:43:11 <ddarius> @src abs
16:43:11 <lambdabot> Source not found. Where did you learn to type?
16:44:36 <FunctorSalad_> hmm a general matrix norm was defined as a vector space norm that's also submultiplicative?
16:44:50 <FunctorSalad_> before I further embarass myself o_o
16:45:13 <dmhouse> The matrix norm is the operator norm, ||A|| = sup { ||Av|| : ||v|| = 1 }
16:45:30 <dmhouse> Or at least, that's the terminology I've heard
16:45:30 <FunctorSalad_> that's a particular (family of) norms
16:45:42 <FunctorSalad_> (still depends on the two vector space norms)
16:46:23 <FunctorSalad_> of course, they all give the same topology
16:46:51 <Twey> kbp: var2 is not a constructor of Expr
16:46:54 <dmhouse> Do they? Do all vector space norms give the same topologies?
16:47:07 <Twey> Only constructors can be deconstructed
16:47:47 <dmhouse> Certainly true for finite dimensional vector spaces as there all norms are eequivalent, which is stronger than inducing the same topology, but does it hold in the infinite dimensional case?
16:47:55 <Twey> Also, you need ++, not +, to concatenate strings (or any lists), and you'll need some brackets around that, since functions bind more tightly.
16:48:05 <fax> no it doesn't hold in infinte dimensions
16:48:10 <dmhouse> Actually it surely can't
16:48:19 <kbp> Twey: so how to fix....? im not really sure
16:48:28 <Twey> kbp: I don't know what you're trying to do
16:48:44 <Twey> kbp: Which value of Expr is (var1 var2) supposed to represent?
16:48:48 <Twey> You haven't defined such a value.
16:49:01 <Twey> (you can't, in fact)
16:49:11 <FunctorSalad_> dmhouse: eh, infinite dimensional matrix rings? ;)
16:49:21 <FunctorSalad_> assumed matrices are finite by def
16:49:22 <kbp> Twey: data Exp = Var Var where data Var = A | B | C | D
16:49:31 <FunctorSalad_> in infinite dimensions you're right
16:49:36 <dmhouse> FunctorSalad_: I was talking generally for a second
16:49:46 <kbp> Twey: im trying to match var1 var2 to Var Var
16:49:49 <dmhouse> The operator norm can apply in infinite dimensions
16:49:57 <Twey> kbp: Okay, I think you've confused yourself here by using the same name for two different things
16:50:01 <dmhouse> If you want to apply it to matrices I guess you almost certainly want fd though
16:50:06 <FunctorSalad_> which equivalence is stronger than topological? the one about a constant factor?
16:50:19 <dmhouse> Yeah, Lipschitz equivalence it's called
16:50:22 <Twey> kbp: In that Var Var, the first Var is the name of a constructor for Expr  it's a constant
16:50:38 <Twey> kbp: That constructor takes one argument, of type Var
16:50:59 <Twey> For example, you can have Var A, or Var B
16:51:00 <dmhouse> If the norms are |.| and |.|' then exists c > 0 st |x|'/c < |x| < |x|'*c for all x
16:51:10 <FunctorSalad_> dmhouse: an easy example is the maximum norm vs. some integral-of-pth-power-norm, on some function space
16:51:15 <FunctorSalad_> (counterexample)
16:51:27 <kbp> Twey: oh i see!!! that's it!!! the highlight fooled me around
16:51:28 <dmhouse> FunctorSalad_: yep I was just writing down that exact counterexample :)
16:51:33 <kbp> Twey: thank you very much :D
16:51:34 <FunctorSalad_> you can find a family who all have maximum norm 1, but as small 1-norm as you like
16:52:08 <dmhouse> Triangles getting thinner = convergence to 0 in l^1 but constant norm 1 in the sup norm
16:52:23 <FunctorSalad_> yeah
16:52:46 <dmhouse> Good old triangles, the basis of every good counterexample in a space of continuous functions
16:53:06 <FunctorSalad_> hehe, my mental image was smooth
16:53:37 <FunctorSalad_> good old exp(1/(x^2)) or what it was ;o
16:54:08 <dmhouse> Naw, it's always triangles. Like putting a triangle height 1 and width 1/n^2 on each integer is the counterexample to int_0^infty f exists => f(x) -> 0 as x -> infty
16:54:11 <Twey> kbp: You're welcome 
16:54:34 <FunctorSalad_> if I had to write it down and continuous is enough, I'd go with a triangle too, sure
16:54:48 <FunctorSalad_> but they're pointy :o
16:55:01 <dmhouse> But their areas are easy to calculate :)
16:55:40 <FunctorSalad_> think you can just squeeze any function horizontally ;)
16:59:27 <gwern> @hoogle ($)
16:59:27 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
16:59:27 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
16:59:27 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
17:02:17 <Mathnerd314> > let ($) = id in (\x -> x+x) $ 1
17:02:18 <lambdabot>   2
17:02:25 <Mathnerd314> so ($) == id, yes?
17:02:31 <dmhouse> Up to precedence
17:02:44 <Mathnerd314> yeah; $ was a syntactic trick anyway
17:02:57 <dmhouse> > show `id` 3 + 3
17:02:58 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
17:02:58 <gwern> just once, I'd like to be able to say 'up to isomorphsm' and not have it be a wild guess
17:02:58 <lambdabot>    arising from the literal `...
17:03:00 <Draconx|Laptop> and up to type.
17:03:21 <FunctorSalad_> "foo `id` bar" confused me the first time ;)
17:03:46 <FunctorSalad_> yeah, id is more general
17:04:30 <Mathnerd314> @let ($) = id
17:04:31 <lambdabot>  .L.hs:83:17:
17:04:31 <lambdabot>      Ambiguous occurrence `$'
17:04:31 <lambdabot>      It could refer to either `L....
17:04:40 <Saizan> gwern: learn about initial objects, they are pretty simple
17:05:25 <jfoutz> are initial objects the mempty in monoid? 0, "", id
17:06:10 <Saizan> no
17:06:54 <jfoutz> reading wikipedia now.
17:08:39 <LegendaryPenguin> whats wrong with :   do boardSize <- (getStdRandom (randomR (1,25)))
17:08:51 <LegendaryPenguin> when I use let in the terminal, it doesnt complain
17:09:00 <kmc> <- is not the same as "let"
17:09:10 <kmc> <- (roughly) runs a monadic action and gives you the result
17:09:16 <kmc> let just gives a name to an expression
17:09:24 <Twey> LegendaryPenguin: getStdRandom doesn't take an argument, and do-blocks need an expression at the end
17:09:26 <monochrom> @pl \b t -> fmap (b &&) (s t)
17:09:26 <lambdabot> (. s) . fmap . (&&)
17:09:35 <monochrom> nevermind :)
17:09:37 <Saizan> ?type getStdRandom
17:09:38 <lambdabot> forall a. (StdGen -> (a, StdGen)) -> IO a
17:09:43 <Saizan> it does take an argument
17:09:44 <kmc> a monadic action is an expression like any other, so you can give it a name with "let", but that won't run the action
17:09:54 <Twey> monochrom: fmap s . fmap . (&&)!
17:10:01 <kmc> LegendaryPenguin, perhaps do you want randomRIO?
17:10:03 <kmc> :t randomRIO
17:10:04 <lambdabot> forall a. (Random a) => (a, a) -> IO a
17:10:11 <LegendaryPenguin> it says No instance of (Num String)
17:10:11 <Twey> Saizan: Oh, so it does.  Pardon me.
17:10:12 <kmc> > randomRIO (1,25)
17:10:13 <lambdabot>   <IO Integer>
17:10:24 <LegendaryPenguin> in the expression 1
17:10:45 <Twey> LegendaryPenguin: Needs more context
17:10:56 <Saizan> LegendaryPenguin: a do-block has to have a return value, so it can't just end with a binding like that
17:10:58 <Twey> LegendaryPenguin: Presumably you've tried to use the result of the expression as a string somewhere
17:11:09 <LegendaryPenguin> oh
17:11:29 <Twey> LegendaryPenguin: But the fact that you passed numbers to your randomR call means that what you get back will be a number, not a string
17:15:56 <orlandu63> is the <- operator that's used in list comprehension the same (functionally) one that's used in a do statement?
17:16:14 <kmc> orlandu63, basically
17:16:21 <kmc> you can rewrite any list comprehension as a "do" block
17:16:34 <kmc> which uses the list monad
17:16:45 <orlandu63> interesting
17:17:00 <Cale> orlandu63: It's not really an operator though, it's built-in syntax.
17:17:16 <kmc> and used to be, comprehensions *also* worked on any monad, like "do" does
17:17:26 <kmc> but now they are restricted to [] because of confusion and type ambiguity
17:17:37 <Cale> do v <- x; <stmts>  translates into  x >>= (\v -> do <stmts>)  however
17:18:23 <kmc> orlandu63, [ 2*x | x <- [0..], x^2 > 3 ]    ===>   do { x <- [0..]; guard (x^2 > 3); return (2*x) }
17:18:24 <Cale> and list comprehensions *could* use the same translation here, but instead translate into concatMaps
17:18:38 <Cale> which are equivalent to using >>= in the case of the list monad
17:18:52 <orlandu63> i see
17:18:53 <kmc> yeah. (>>=) is (flip concatMap)
17:19:04 <kmc> :t guard
17:19:05 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
17:19:45 <kmc> at the risk of proposing yet another monad tutorial, i'd like to see "monads are generalized list comprehensions"
17:20:31 <orlandu63> i haven't learned monads yet, i'm only feigning understanding of what you two are saying heh
17:21:02 <orlandu63> do you have a recommended tutorial? the one i finished (learnyouahaskell.com) hasn't wrote about monads yet
17:21:35 <orlandu63> or rather, hasn't finished its seciton on monads
17:22:03 <monochrom> Twey: Hahahahaha fmap s . fmap . (&&), even fmap s `fmap` fmap `fmap` (&&)
17:22:15 <nus-> orlandu63, get used to applicative functors, first
17:22:37 <orlandu63> nus: okay, will do
17:22:39 <Twey> monochrom: fmap (fmap s) $ fmap fmap (&&)
17:22:46 <Twey> 
17:22:55 <monochrom> kmc: Philip Wadler did that. "comprehending monads"
17:23:26 <monochrom> Wadler has all the pun-intended titles. Another one I like: linear types can change the world!
17:23:27 <Twey> monochrom: join fmap fmap s $ fmap fmap (&&)
17:23:39 <monochrom> This is so anti-golfing!
17:23:52 <Twey> It's a sort of golf
17:24:02 <Twey> The aim is to use as few non-fmap symbols as possible
17:24:03 <monochrom> australian golf
17:24:42 <kmc> orlandu63, Typeclassopedia
17:24:45 <kmc> @where typeclassopedia
17:24:45 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
17:25:00 <Saizan> http://www.haskell.org/haskellwiki/Monads_as_computation <- i'll throw this in then
17:25:18 <kmc> and the other one, http://haskell.org/haskellwiki/Monads_as_containers
17:25:25 <kmc> @where burrito
17:25:26 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
17:25:46 <orlandu63> thank you
17:26:05 <Saizan> we should take wadler's paper and port it to the modern libs
17:26:22 <kmc> orlandu63, the burrito article is about monad tutorials and where they go wrong
17:26:34 <kmc> and about the learning process generally
17:26:43 <monochrom> http://www.haskell.org/haskellwiki/Monads_as_presidents_of_the_united_states
17:26:53 <kmc> haha
17:27:01 <Twey> 
17:27:18 <kmc> orlandu63, also beware that the IO monad is an atypical monad
17:27:35 <kmc> so if you've been doing IO so far, you might want to ignore it when learning monads-as-such
17:28:51 <dolio> monochrom: You need to flesh that out.
17:29:10 <twink> monochrom: Which monad is Millard Fillmore?
17:30:06 <kmc> i think my favorite monad is the Omega monad
17:30:12 <kmc> because it sounds like something you'd use to power a spaceship
17:30:25 <kmc> (incidentally, it is actually useful)
17:30:47 <twink> What's the worst monad ever (i.e. James Buchanan)?
17:32:53 <LegendaryPenguin> what about this error? http://pastebin.com/AD8cEB1B
17:33:13 <Mathnerd314> kmc: Omega doesn't seem to be an actual monad
17:33:28 <LegendaryPenguin> im trying to make a list of pairs containing random values
17:33:46 <dankna> line four
17:33:53 <dankna> change it to either
17:34:02 <dankna> allCellLocs <- return $ ...
17:34:04 <dankna> or, preferably
17:34:10 <dankna> let allCellLocs = ...
17:35:15 <dankna> do you see why?
17:35:18 <monochrom> In fact combine both allCellLocs and liveCells under one single let. Screw the "in".
17:35:57 <monochrom> This is because the do-notation includes a special "let" without bothering with "in".
17:36:33 <monochrom> > do { x<-[0,1]; let y=x+1; [y] }
17:36:34 <lambdabot>   <no location info>: parse error on input `}'
17:36:41 <monochrom> > do { x<-[0,1]; let {y=x+1}; [y] }
17:36:42 <lambdabot>   [1,2]
17:38:16 <LegendaryPenguin> oh, i thought randomRs was an IO for some reason
17:38:28 <dankna> even if it were, zip isn't
17:39:22 <monochrom> To complete the error, think both randomRs and zip were IO. :)
17:40:49 <kmc> Mathnerd314, it is, so long as you pretend the list of results is a set
17:40:56 <kmc> http://hackage.haskell.org/packages/archive/control-monad-omega/0.3/doc/html/Control-Monad-Omega.html
17:41:08 <Mathnerd314> kmc: since when has "pretend" worked?
17:41:33 <Mathnerd314> kmc: Omega should be defined on sets then
17:41:47 <kmc> Mathnerd314, need restricted monads for that
17:44:09 <kmc> not sure what you mean by "worked" here
17:45:44 <kmc> hmm, perhaps you don't need restricted monads, perhaps all you need is runOmega to sort its output
17:45:52 <kmc> but that introduces additional overhead for apps that don't care
17:54:24 <chrisdone> who has access to hpaste.org? it's clearly changed so someone has access to it. I will maintain it or host it on my vps if someone grants me access. drop me a message
17:55:06 <dankna> heh, it says hello ^^''''
18:01:53 <aavogt> chrisdone: that would be bos?
18:09:04 <alp_> chrisdone, $ git clone http://code.haskell.org/hpaste.git
18:35:53 <jmillikin> bos: have you gotten a chance to look at the patch to text-icu I sent you? It lets multiple versions of libicu be supported, which is useful because Ubuntu 10.04 doesn't include libicu 4.0.
19:22:27 <BMeph> I barely remember someone discussing how adding the first and last elements of a list is affected by which one is first in the formula. Does anyone remember this, and if so, do you have a link? :)
19:23:10 <aavogt> BMeph: if your + is lazy?
19:23:42 <LegendaryPenguin> getStdRandom (randomR (1,6))
19:23:42 <LegendaryPenguin>  how does randomR take a range and a generator?
19:24:13 <BMeph> I guess I should mention: this isn'y a theoretical discussion, but an observed behavior in GHC. Does this ring any bells?
19:24:31 <BMeph> s/'y/'t/
19:24:50 <LegendaryPenguin> s/*//
19:26:04 <LegendaryPenguin> generating random numbers is tough
19:27:13 <ClaudiusMaximus> > (\xs -> head xs + last xs) [ 1 .. 1e10 ]
19:27:17 <lambdabot>   mueval-core: Time limit exceeded
19:28:02 <ClaudiusMaximus> > (\xs -> let { y = head xs ; z = last xs } in y `par` z `pseq` y + z) [ 1 .. 1e10 ]
19:28:08 <lambdabot>  Terminated
19:28:41 <interferon> does anyone know of a complete haskore example that emits a midi file?
19:35:37 <kmc> LegendaryPenguin, did you try randomRIO?
19:35:46 <kmc> LegendaryPenguin, if you are generating random numbers in the IO monad, that's by far the easiest way
19:35:58 <LegendaryPenguin> i was using randomRs, but then it kept producing the same numbers
19:36:05 <kmc> so did you try randomRIO
19:36:10 <LegendaryPenguin> no
19:36:32 <LegendaryPenguin> i dont get it though, why do the random functions say they take a generator when you can call them with just pairs?
19:36:45 <Cale> LegendaryPenguin: Functions in Haskell always produce the same result when you pass them the same parameters.
19:36:52 <kmc> :t randomR
19:36:56 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
19:37:02 <kmc> LegendaryPenguin, it *does* take a generator
19:37:18 <kmc> "getStdRandom (randomR (1,6))" is not a way of applying randomR to two arguments
19:37:22 <Cale> LegendaryPenguin: So if you want a function to produce different results, it's then clear that you're going to have to pass it different parameters
19:37:42 <LegendaryPenguin> i dont see where the second argument is coming from
19:37:45 <kmc> uh
19:37:47 <Cale> LegendaryPenguin: In the case of a pseudorandom generator, it will have to be a value which somehow represents the state of the generator
19:37:47 <kmc> you're not giving it one
19:37:49 <kmc> so nowhere ;P
19:37:52 <LegendaryPenguin> i know, so why does it work
19:37:55 <kmc> it doesn't
19:37:57 <kmc> randomRIO does
19:38:08 <kmc> (randomR (1,6)) is a function
19:38:10 <Cale> :t getStdRandom
19:38:11 <kmc> it's still waiting for a generator
19:38:11 <lambdabot> forall a. (StdGen -> (a, StdGen)) -> IO a
19:38:19 <Cale> getStdRandom will pass it one
19:38:27 <kmc> oh, right
19:38:37 <kmc> getStdRandom != getStdGen
19:38:47 <kmc> LegendaryPenguin, getStdRandom is a function that takes another function
19:38:52 <kmc> the function it takes is (randomR (1,6))
19:38:57 <kmc> but really, this is a longwinded way of doing randomRIO
19:39:10 <kmc> which is the simple way of getting random numbers
19:39:34 <LegendaryPenguin> so does it seed itself
19:39:51 <kmc> getStdRandom seeds its argument, which is a random generator
19:40:01 <kmc> err
19:40:01 <cypher> does anyone know some example of a program making good use of vector library? i.e. something to show good performance
19:40:10 <Cale> Let's understand the non-IO way of dealing with random number generators first.
19:41:36 <Cale> We have these values of type StdGen which represent the possible states of the random number generator. When you apply randomR, say, to a pair (representing the endpoints of the range that you'd like to uniformly select from), and one of these StdGen values, you get a new StdGen value along with your result
19:41:58 <Cale> That new StdGen is what you're expected to use to get the next pseudorandom number.
19:42:10 <Cale> If you pass in the same StdGen multiple times, you will always get the same result
19:42:20 <Cale> > randomR (1,6) (mkStdGen 42)
19:42:22 <lambdabot>   (6,1720602 40692)
19:42:24 <Cale> > randomR (1,6) (mkStdGen 42)
19:42:25 <lambdabot>   (6,1720602 40692)
19:42:26 <Cale> > randomR (1,6) (mkStdGen 42)
19:42:27 <lambdabot>   (6,1720602 40692)
19:43:07 <Cale> the second part of the pair there with the awkward Show instance is the StdGen. We can capture it and use it to generate another pseudorandom number.
19:43:40 <Cale> > let (n,g) = randomR (1,6) (mkStdGen 42); (m,g') = randomR (1,6) g in (m,g')
19:43:41 <lambdabot>   (4,128694412 1655838864)
19:43:51 <Cale> > let (n,g) = randomR (1,6) (mkStdGen 42); (m,g') = randomR (1,6) g in (n,m,g')
19:43:52 <lambdabot>   (6,4,128694412 1655838864)
19:44:28 <Cale> LegendaryPenguin: Make sense?
19:44:33 <LegendaryPenguin> yeah
19:44:49 <Cale> Now the question is how do we get an initial StdGen to use which will be different every time?
19:44:58 <Cale> :t newStdGen
19:44:58 <lambdabot> IO StdGen
19:45:17 <aavogt> that one tends to be seeded from the system clock
19:45:31 <Cale> ^^ this function will make a new one for us (which ideally would be based on system entropy, but yes, is actually seeded from the clock)
19:46:19 <aavogt> not that it matters much for those numerical methods that need random numbers
19:46:36 <Cale> Yeah, you just wouldn't want to use this for crypto.
19:47:19 <Cale> It may seem awkward to thread these StdGen values around through your program, so there are a number of things you can do instead.
19:47:50 <Cale> One is just to generate random values from IO using the IO variants: randomIO and randomRIO.
19:48:12 <Cale> You can then pass the randomly generated values into pure functions from there.
19:49:08 <Cale> You can also use a StdGen obtained from newStdGen (or elsewhere), and apply randoms or randomRs to it, to get an infinite list of random numbers (which will always be the same list for the same StdGen of course)
19:49:53 <Cale> There are also monads specifically to save you the trouble of keeping track of the generator.
19:50:04 <Cale> Like the MonadRandom package on Hackage.
19:57:59 <kmc> yeah
20:00:29 <m3ga> i've just installed ghc-6.10.4 on freebsd, followed by cabal-install and now "cabal update" says "cabal: does not exist". clues?
20:00:45 <kmc> use random[R]IO for simplicity
20:01:06 <kmc> use MonadRandom if you want to specify a generator (e.g. with a specific seed), or you want to separate randomness from other side effects
20:01:23 <kmc> m3ga, i think that's a very nasty cabal bug
20:01:39 <kmc> is it something like "cabal: \0: does not exist"
20:01:49 <kmc> where the \0 might be an actual NUL or any other character, often non-printable?
20:01:59 <kmc> m3ga, i had this bug a while ago and know no fix
20:02:09 <kmc> you can try to rm your ~/.cabal but that didn't work for me (on linux)
20:02:20 <kmc> i upgraded to the latest Haskell Platform with GHC 6.12.1 and it went away
20:03:26 <LegendaryPenguin> is there a stack overflow somewhere in this? http://pastebin.com/aun9SsYk
20:03:49 <m3ga> thanks kmc. i'll fiddle with it a bit because i'd kinda like to avoid having to build ghc from source :-)
20:04:41 <kmc> LegendaryPenguin, why do you think there is?
20:05:05 <kmc> LegendaryPenguin, btw, sequence (map f xs)  is mapM f xs
20:06:03 <LegendaryPenguin> is the sequence a problem?
20:06:09 <kmc> don't know
20:06:11 <LegendaryPenguin> when i run it, it gives me stack overflow
20:06:14 <kmc> your code will be more readable as mapM
20:06:33 <kmc> LegendaryPenguin, you seem to be generating an infinite number of random numbers
20:06:38 <kmc> since you sequence a random list
20:07:03 <kmc> an infinite list i mean
20:07:05 <kmc> actually, two of them
20:07:13 <Cale> (which will take forever)
20:07:13 <kmc> is that what you want?
20:07:19 <LegendaryPenguin> yeah
20:07:21 <kmc> yeah, "sequence" isn't lazy enough
20:07:24 <LegendaryPenguin> thats how many i need
20:07:36 <kmc> or something
20:07:37 <Cale> Just use randomRs
20:07:44 <kmc> yeah, i have to contradict my earlier advice :/
20:07:47 <kmc> there's no randomRsIO
20:07:48 <kmc> for some reason
20:07:55 <Cale> along with newStdGen to get the generator
20:07:58 <LegendaryPenguin> thats what im trying to do there
20:08:29 <Cale> LegendaryPenguin: It's not possible to execute an infinite number of IO actions, but it is possible to get an infinite list of random numbers using randomRs
20:08:38 <Cale> :t randomRs
20:08:39 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
20:08:49 <LegendaryPenguin> but then i need a seed
20:08:55 <LegendaryPenguin> do i have to call newStdGen twice
20:09:00 <Cale> So, you need that g parameter which you can get by  g <- newStdGen
20:09:06 <Cale> Yeah, just call it twice
20:11:09 <kmc> LegendaryPenguin, this is how i'd write it: http://codepad.org/6zkJHvqy
20:11:18 <kmc> LegendaryPenguin, note that a lot of your type signatures are unnecessary
20:11:33 <LegendaryPenguin> i only need the first ones?
20:11:42 <kmc> numCells is constrained to Int because you use it in "take"
20:12:01 <kmc> the ones in listA and listB are constrained to Int, because the upper bound is boardSize which you already constrained to Int
20:12:14 <kmc> there is some sense to putting in the sigs anyway, but i think i wouldn't
20:13:13 <kmc> LegendaryPenguin, "f <$> a" is just "do { x <- a; return (f x) }"
20:13:20 <kmc> (except more general, but don't worry about that now)
20:14:28 <kmc> the same thing is also called "fmap" and "liftM"
20:15:20 <kmc> i defined "get" in a let because anywhere you see a repeated pattern in your code, you can probably generalize it out
20:19:09 <osaunders> When Data.Map.fromList encountered duplicate keys it discards all but the last.
20:19:20 <osaunders> So: Data.Map.fromList [(1, 'a'), (1, 'b')] ! 1 == 'b'
20:20:03 <osaunders> Is that behavior in any way intrinsically superior to others?
20:20:47 <osaunders> You could have, for instance, it always return a list, which would explicitly acknowledge the possibility of duplicate keys occurring.
20:21:03 <osaunders> So: Data.Map.fromList [(1, 'a'), (1, 'b')] ! 1 would == ['a', 'b']
20:21:06 <ezyang> osaunders: It reflects a straightforward way of setting up the map
20:21:27 <ezyang> namely folding on the list from left to right with insert
20:21:30 <BMeph> osaunders: Yes. It allows you to change an existing key, or to change it back later.
20:21:41 <BMeph> Also, the fold-thing. :)
20:21:48 <ClaudiusMaximus> @type Data.Map.fromListWith
20:21:49 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> [(k, a)] -> M.Map k a
20:21:56 <ezyang> You can get the behaviour you propose, though
20:22:02 <osaunders> Ah.
20:22:29 <ezyang> though I don't know how built-in the function is
20:22:30 <ClaudiusMaximus> @type Data.Map.fromListWith (++) . map (second (:[]))
20:22:31 <lambdabot> forall k b. (Ord k) => [(k, b)] -> M.Map k [b]
20:22:37 <ezyang> "thar we go"
20:22:49 <osaunders> Ah, OK. That's pretty nice.
20:22:55 * osaunders loves Haskell.
20:23:03 <BMeph> osaunders: There are also ...With functions given to let you do something with both a new and old value. :)
20:24:11 <ClaudiusMaximus> > (Data.Map.fromListWith (++) . map (second (:[]))) [(1, 'a'), (1, 'b')] ! 1 -- to check it does do something useful
20:24:12 <lambdabot>   Not in scope: `Data.Map.fromListWith'
20:24:17 <ClaudiusMaximus> oops
20:24:33 <ezyang> \o/
20:24:58 <ClaudiusMaximus> i remember some of the Map ...With having really convoluted names/behaviours
20:25:43 <copumpkin> M.
20:25:56 <copumpkin> > (M.fromListWith (++) . map (second (:[]))) [(1, 'a'), (1, 'b')] ! 1 -- to check it does do something useful
20:25:57 <lambdabot>   Couldn't match expected type `GHC.Arr.Array i e'
20:25:57 <lambdabot>         against inferred t...
20:26:05 <copumpkin> > (M.fromListWith (++) . map (second (:[]))) [(1, 'a'), (1, 'b')] M.! 1 -- to check it does do something useful
20:26:08 <lambdabot>   "ba"
20:26:27 <copumpkin> I'm so good
20:28:36 * Mathnerd314 is halfway through blog.sigfpe.com
20:28:49 * ezyang salutes you 
20:29:29 <Mathnerd314> I
20:29:44 <Mathnerd314> 'm not certain how much I should understand at this point :-)
20:32:24 <siracusa> Is there a Gtk2Hs binary package for GHC 6.10.4?
20:32:35 <Zao> siracusa: Most probably.
20:32:40 <Zao> Depending on platform.
20:32:45 <siracusa> WinXP
20:33:04 <Zao> As far as I know, the latest proper release is for 6.10.x
20:33:09 <ddarius> Mathnerd314: His blog is not presented in a pedagogical order.
20:33:37 <Mathnerd314> really? I would think it evolved as he wrote it...
20:33:51 <siracusa> Zao: The latest binary on the GtK2Hs homepage is compiled with GHC 6.10.3
20:34:24 <Zao> siracusa: Rather lazy of the team, I'd say.
20:34:43 <Zao> Or is it 6.10.4 that introduced the changes in foreignPtr?
20:35:48 <siracusa> Hhm, I don't know
20:36:37 <Zao> http://www.mail-archive.com/gtk2hs-devel@lists.sourceforge.net/msg00340.html
20:36:39 <Zao> This might help.
20:37:50 <Zao> I believe it will fail horribly if your Haskell Platform directory has spaces in the path.
20:37:54 <siracusa> Zao: Thanks for this!
21:10:43 <kmc> hmm, System.Random.MWC.normal seems to infinite loop on my machine
21:10:48 <kmc> anyone else have this problem?
21:19:55 <uorygl> Where are the Cabal's generated docs supposed to end up?
21:20:42 <mle> ~/.cabal/share/doc
21:21:37 <uorygl> Oh, turns out my Cabal is broken again.
21:22:02 <uorygl> What is this remote-repo-cache stuff?  Is that stuff actually required?  Can I just delete it?
21:22:32 <uorygl> Can I just delete .cabal/packages, that is.
21:29:10 <uorygl> "Unlike other systems, Ivor is intended to be used by programs, rather than a human operator."  Hoorah!
21:29:36 <uorygl> Since that's precisely what I want in a proof system right now.
21:31:37 <Saizan_> well, .cabal/packages also contains the index, but you can always run cabal upload to download it again
21:31:53 <uorygl> Sounds like I can delete it, then.
21:33:39 <Mathnerd314> cool; just realized I'm trying to write a confluent system for the ternary operator
21:35:23 <uorygl> Darn, I forgot the syntax for deleting a file whose name includes a line break, and so I deleted the wrong file.
21:35:27 <uorygl> Oh well.
21:37:01 * hackagebot HDBC-mysql 0.6.2 - MySQL driver for HDBC  http://hackage.haskell.org/package/HDBC-mysql-0.6.2 (ChrisWaterson)
21:37:17 * uorygl downloads ivor.pdf
21:37:20 <uorygl> Woo, this thing is huge.
21:37:51 <uorygl> Actually, it's only eighteen pages.
21:56:32 <Axman6> uorygl: i think you just found the advantage of the trash can metaphore for deleting files
21:57:07 <uorygl> Instead of deleting them immediately, move them to a "trash" folder so that if you regret it soon enough you can have it back?
21:57:16 <uorygl> That's what I get for not using that feature, I guess.
22:00:50 <matthewmunz> Hi all.  I'd like to do some Web programming in Haskell and am looking for suggestions on what packages to use for this.
22:01:24 <uorygl> There's a certain one that functions as a database and web server.  Its name escapes me.
22:01:35 <Axman6> there's quite a few to choose from, take a look at them and decide which ones you like
22:01:47 <Axman6> Happstack
22:01:53 <uorygl> Yeah, that's the one.
22:01:58 <tensorpudding> Happstack is the most functional Haskell web framework
22:02:41 <matthewmunz> I'm looking for a project that's stable and active and that can be used with apache.
22:07:55 <uorygl> Woo.  Reading about Ivor is fun (or maybe I'm just telling myself that), but as it's past 1 AM, I should get going to bed.
22:08:30 <matthewmunz> The main Happstack website is offline :(
22:09:59 <uorygl> I wonder if there's a clone of it you can use.
22:10:11 <uorygl> Look at its Google cache; search Google for phrases it contains.
22:12:45 <timmaxw> has anyone done any work on a syntactic sugar for monads that lets them be written inline? for example, it would be nice to be able to implement the quadratic formula as "x = (-b +- sqrt (b*b-4*a*c))/(2*a)" using the List monad
22:12:47 <timmaxw> and i
22:12:53 <timmaxw>  think it would be possible with an appropriate desugaring
22:14:16 <uorygl> Well, there's [ (-b +- sqrt (b^2 - 4*a*c))/(2*a) | (+-) <- [(+),(-)] ].
22:15:17 <timmaxw> i wasn't trying to solve that specific problem; i was trying to provide an example of what i meant by "written inline"
22:15:26 * uorygl nods.
22:15:52 <timmaxw> it seems like there's an intuitive way to turn code like that into 'do' notation, but i've never seen it done
22:16:22 <kmc> isn't that a list comprehension?
22:16:33 <kmc> which is just another syntax for list-monad "do"
22:16:37 <kmc> and they used to allow comprehension for any monad
22:16:46 <uorygl> I'm tempted to continue giving ways of implementing the quadratic formula there.
22:17:55 <timmaxw> i'm trying to imagine an "Either String" comprehension... i think i get it
22:18:13 <timmaxw> (that wasn't what i was looking for, though)
22:26:16 <matthewmunz> The Happstack site just came back online.  It looks interesting. uorygl, Axman6 -- thanks for the pointer :)
23:58:47 * hackagebot xhaskell-library 0.0.5 - Replaces/Enhances Text.Regex  http://hackage.haskell.org/package/xhaskell-library-0.0.5 (KennyLu)
23:59:25 <edlinde> hi all, I haven't done any haskell but I was wondering if you can write a program for any problem in haskell or is it restricted to certain kinds of problem sets?
23:59:52 <fax> edlinde: You can use it for anything
